From 8216724bd935fa9ce15956a899e7448435b5e141 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E9=BB=84=E6=B6=9B?= <huangtao@rock-chips.com>
Date: Fri, 8 Nov 2013 21:33:42 +0800
Subject: [PATCH] rk: temp revert rk change

---
 .gitignore                                |    2 -
 Makefile                                  |   24 +-
 arch/arm/Kconfig                          |  128 +-
 arch/arm/Makefile                         |   43 +-
 arch/arm/boot/Makefile                    |   11 +-
 arch/arm/boot/compressed/head.S           |    4 -
 arch/arm/common/fiq_debugger.c            |  254 +-
 arch/arm/common/gic.c                     |   17 -
 arch/arm/common/pl330.c                   |  185 +-
 arch/arm/include/asm/atomic.h             |    2 +-
 arch/arm/include/asm/fiq_debugger.h       |    4 -
 arch/arm/include/asm/hardware/pl330.h     |    4 +-
 arch/arm/include/asm/locks.h              |    2 +-
 arch/arm/include/asm/mach/map.h           |    1 -
 arch/arm/include/asm/proc-fns.h           |   14 -
 arch/arm/include/asm/setup.h              |    4 -
 arch/arm/include/asm/system.h             |    6 +-
 arch/arm/kernel/entry-armv.S              |    2 +-
 arch/arm/kernel/entry-common.S            |    3 +-
 arch/arm/kernel/head.S                    |    5 -
 arch/arm/kernel/process.c                 |    2 -
 arch/arm/kernel/smp.c                     |    9 +-
 arch/arm/kernel/smp_twd.c                 |   75 +-
 arch/arm/kernel/vmlinux.lds.S             |   51 -
 arch/arm/lib/bitops.h                     |    2 +-
 arch/arm/mm/Kconfig                       |   24 +-
 arch/arm/mm/context.c                     |    3 +-
 arch/arm/mm/mmu.c                         |   13 -
 arch/arm/mm/proc-v7.S                     |   15 -
 arch/arm/tools/mach-types                 |    7 +-
 arch/arm/vfp/vfphw.S                      |   19 -
 arch/arm/vfp/vfpmodule.c                  |   39 +-
 block/blk-core.c                          |  158 +-
 drivers/Kconfig                           |   14 -
 drivers/Makefile                          |    9 -
 drivers/base/bus.c                        |   18 -
 drivers/base/cpu.c                        |   10 -
 drivers/base/power/main.c                 |    6 -
 drivers/base/sync.c                       |  323 +--
 drivers/bluetooth/Kconfig                 |   49 -
 drivers/bluetooth/Makefile                |    2 -
 drivers/bluetooth/hci_h4.c                |  228 +-
 drivers/bluetooth/hci_ldisc.c             |   55 +-
 drivers/bluetooth/hci_uart.h              |    7 -
 drivers/cpufreq/cpufreq_interactive.c     |   22 -
 drivers/cpufreq/cpufreq_ondemand.c        |    5 -
 drivers/cpufreq/cpufreq_stats.c           |    9 -
 drivers/gpio/Kconfig                      |   51 -
 drivers/gpio/Makefile                     |   13 +-
 drivers/gpio/gpio-tps65910.c              |  118 -
 drivers/gpio/gpiolib.c                    |   96 +-
 drivers/gpio/wm831x-gpio.c                |   56 +-
 drivers/gpu/ion/Kconfig                   |    5 -
 drivers/gpu/ion/Makefile                  |    1 -
 drivers/gpu/ion/ion.c                     |  414 +--
 drivers/gpu/ion/ion_carveout_heap.c       |  124 +-
 drivers/gpu/ion/ion_priv.h                |   20 -
 drivers/hid/hid-core.c                    |   27 +-
 drivers/hid/usbhid/hid-core.c             |   11 -
 drivers/i2c/algos/i2c-algo-bit.c          |    7 +-
 drivers/i2c/busses/Kconfig                |  204 +-
 drivers/i2c/busses/Makefile               |    3 -
 drivers/i2c/busses/i2c-gpio.c             |    3 +-
 drivers/i2c/i2c-boardinfo.c               |    1 +
 drivers/i2c/i2c-core.c                    |  457 +---
 drivers/i2c/i2c-dev.c                     |   65 +-
 drivers/input/Kconfig                     |   15 -
 drivers/input/Makefile                    |    9 -
 drivers/input/keyboard/Kconfig            |   28 -
 drivers/input/keyboard/Makefile           |    3 -
 drivers/input/keyboard/matrix_keypad.c    |   50 +-
 drivers/input/misc/Kconfig                |   34 -
 drivers/input/misc/Makefile               |    6 -
 drivers/input/misc/wm831x-on.c            |  169 +-
 drivers/input/touchscreen/Kconfig         |  383 ---
 drivers/input/touchscreen/Makefile        |   47 +-
 drivers/input/touchscreen/pixcir_i2c_ts.c |  960 -------
 drivers/leds/Kconfig                      |    7 -
 drivers/leds/Makefile                     |    1 -
 drivers/leds/leds-wm831x-status.c         |  112 -
 drivers/media/video/Kconfig               |  449 +---
 drivers/media/video/Makefile              |   71 +-
 drivers/media/video/ov2640.c              | 2967 ---------------------
 drivers/media/video/soc_camera.c          |  232 +-
 drivers/media/video/uvc/uvc_ctrl.c        |    9 -
 drivers/media/video/uvc/uvc_queue.c       |   62 +-
 drivers/media/video/uvc/uvc_v4l2.c        |   17 +-
 drivers/media/video/uvc/uvc_video.c       |  106 +-
 drivers/media/video/uvc/uvcvideo.h        |   13 +-
 drivers/media/video/v4l2-ioctl.c          |    6 +-
 drivers/media/video/videobuf-core.c       |   31 +-
 drivers/media/video/videobuf-dma-contig.c |    1 -
 drivers/mfd/Kconfig                       |  185 +-
 drivers/mfd/Makefile                      |   20 -
 drivers/mfd/tps65910-irq.c                |   45 +-
 drivers/mfd/tps65910.c                    |  208 +-
 drivers/mfd/twl-core.c                    |  392 +--
 drivers/mfd/twl-core.h                    |    3 +-
 drivers/mfd/twl6030-irq.c                 |  246 +-
 drivers/mfd/wm831x-core.c                 |  189 +-
 drivers/mfd/wm831x-i2c.c                  |  135 +-
 drivers/mfd/wm831x-irq.c                  |  268 +-
 drivers/mfd/wm831x-spi.c                  |   32 +-
 drivers/mfd/wm8994-core.c                 |   98 +-
 drivers/misc/Kconfig                      |   49 +-
 drivers/misc/Makefile                     |   15 -
 drivers/misc/apanic.c                     |   21 +-
 drivers/mmc/card/Kconfig                  |    1 -
 drivers/mmc/card/block.c                  |  715 +----
 drivers/mmc/card/queue.c                  |  258 +-
 drivers/mmc/card/queue.h                  |   33 +-
 drivers/mmc/core/bus.c                    |   24 +-
 drivers/mmc/core/core.c                   |  605 +----
 drivers/mmc/core/core.h                   |    1 -
 drivers/mmc/core/mmc.c                    |  730 +----
 drivers/mmc/core/mmc_ops.c                |   73 +-
 drivers/mmc/core/sd.c                     |  102 +-
 drivers/mmc/core/sdio.c                   |  387 +--
 drivers/mmc/core/sdio_cis.c               |   11 +-
 drivers/mmc/host/Kconfig                  |   87 -
 drivers/mmc/host/Makefile                 |    7 -
 drivers/mtd/Kconfig                       |    2 -
 drivers/mtd/Makefile                      |    2 +-
 drivers/mtd/mtd_blkdevs.c                 |  263 +-
 drivers/mtd/mtdblock.c                    |   51 +-
 drivers/mtd/mtdblock_ro.c                 |    8 +-
 drivers/mtd/nand/Kconfig                  |    6 -
 drivers/mtd/nand/Makefile                 |    1 -
 drivers/mtd/nand/nand_base.c              |    9 -
 drivers/mtd/nand/nand_bbt.c               |   12 +-
 drivers/net/Kconfig                       |   22 -
 drivers/net/Makefile                      |    3 -
 drivers/net/dm9000.c                      |   82 +-
 drivers/net/enc28j60.c                    |   15 +-
 drivers/net/irda/Kconfig                  |   23 -
 drivers/net/irda/Makefile                 |    3 -
 drivers/net/usb/Kconfig                   |   18 -
 drivers/net/usb/Makefile                  |    2 -
 drivers/net/usb/asix.h                    |  550 ----
 drivers/net/usb/usbnet.c                  |   33 +-
 drivers/power/Kconfig                     |  150 --
 drivers/power/Makefile                    |   14 -
 drivers/power/smb347-charger.c            |  515 ----
 drivers/power/test_power.c                |    4 +-
 drivers/power/wm831x_power.c              |  763 +-----
 drivers/regulator/Kconfig                 |   75 +-
 drivers/regulator/Makefile                |   12 -
 drivers/regulator/core.c                  |   33 +-
 drivers/regulator/tps65910-regulator.c    |  588 +---
 drivers/regulator/twl-regulator.c         |  405 +--
 drivers/regulator/wm831x-dcdc.c           |  204 +-
 drivers/regulator/wm831x-isink.c          |   25 +-
 drivers/regulator/wm831x-ldo.c            |  177 +-
 drivers/regulator/wm8994-regulator.c      |   10 +-
 drivers/rtc/Kconfig                       |   54 -
 drivers/rtc/Makefile                      |    8 -
 drivers/rtc/alarm.c                       |   10 -
 drivers/rtc/rtc-test.c                    |    4 +-
 drivers/rtc/rtc-tps65910.c                |  774 ------
 drivers/rtc/rtc-twl.c                     |   66 +-
 drivers/rtc/rtc-wm831x.c                  |   20 -
 drivers/spi/Kconfig                       |   40 -
 drivers/spi/Makefile                      |    8 +-
 drivers/spi/spi.c                         |    3 +-
 drivers/staging/Kconfig                   |    3 -
 drivers/staging/Makefile                  |    2 -
 drivers/staging/android/timed_gpio.c      |   61 +-
 drivers/staging/android/timed_gpio.h      |    1 -
 drivers/staging/hv/hv_kvp.c               |   10 +-
 drivers/tty/serial/Kconfig                |   98 -
 drivers/tty/serial/Makefile               |    2 -
 drivers/tty/serial/serial_core.c          |    6 +-
 drivers/usb/Kconfig                       |    2 -
 drivers/usb/Makefile                      |    1 -
 drivers/usb/core/config.c                 |    2 +-
 drivers/usb/core/hcd.c                    |    7 +-
 drivers/usb/core/hub.c                    |   27 +-
 drivers/usb/gadget/Kconfig                |   32 +-
 drivers/usb/gadget/android.c              |  146 +-
 drivers/usb/gadget/composite.c            |   19 +-
 drivers/usb/gadget/epautoconf.c           |    7 +-
 drivers/usb/gadget/f_accessory.c          |    2 -
 drivers/usb/gadget/f_adb.c                |    4 +-
 drivers/usb/gadget/f_mass_storage.c       |  338 ---
 drivers/usb/gadget/f_mtp.c                |   72 +-
 drivers/usb/gadget/f_rndis.c              |   17 +-
 drivers/usb/gadget/gadget_chips.h         |    8 -
 drivers/usb/gadget/storage_common.c       |    9 +-
 drivers/usb/gadget/u_ether.c              |   20 +-
 drivers/usb/host/Kconfig                  |    8 -
 drivers/usb/host/ehci-hcd.c               |    5 -
 drivers/usb/otg/twl6030-usb.c             |  225 +-
 drivers/usb/serial/Kconfig                |    8 -
 drivers/usb/serial/Makefile               |    1 -
 drivers/usb/serial/option.c               |  196 +-
 drivers/usb/serial/usb-serial.c           |   38 +-
 drivers/usb/storage/initializers.c        |   44 +-
 drivers/usb/storage/initializers.h        |    4 -
 drivers/usb/storage/unusual_devs.h        |   49 -
 drivers/video/Kconfig                     |   96 +-
 drivers/video/Makefile                    |   11 +-
 drivers/video/backlight/Kconfig           |   33 -
 drivers/video/backlight/Makefile          |    4 -
 drivers/video/backlight/wm831x_bl.c       |  125 +-
 drivers/video/console/fbcon.c             |    2 +-
 drivers/video/display/Kconfig             |    6 +-
 drivers/video/display/Makefile            |    3 +-
 drivers/video/fbmem.c                     |   31 -
 drivers/video/logo/.gitignore             |    1 -
 drivers/video/logo/Kconfig                |   33 -
 drivers/video/logo/Makefile               |   21 +-
 drivers/video/logo/logo.c                 |   67 +-
 drivers/watchdog/Kconfig                  |   24 -
 drivers/watchdog/Makefile                 |    1 -
 fs/block_dev.c                            |   79 +-
 fs/buffer.c                               |    2 +-
 fs/cramfs/inode.c                         |    6 +-
 fs/fat/dir.c                              |    2 +-
 fs/fat/fatent.c                           |    6 +-
 fs/fat/inode.c                            |   19 +-
 fs/fat/namei_vfat.c                       |    3 +-
 fs/nls/nls_base.c                         |   43 +-
 fs/partitions/Makefile                    |    1 -
 fs/partitions/check.c                     |   23 -
 fs/partitions/msdos.c                     |   59 +-
 fs/proc/meminfo.c                         |   11 -
 fs/yaffs2/yaffs_mtdif2.c                  |    5 -
 fs/yaffs2/yaffs_vfs.c                     |    3 -
 include/asm-generic/gpio.h                |    7 -
 include/linux/akm8975.h                   |   48 +-
 include/linux/dm9000.h                    |    6 -
 include/linux/export.h                    |   89 -
 include/linux/fb.h                        |   11 -
 include/linux/hdmi.h                      |  124 -
 include/linux/i2c-gpio.h                  |    2 -
 include/linux/i2c.h                       |   20 -
 include/linux/i2c/twl.h                   |  288 +-
 include/linux/ion.h                       |   65 +-
 include/linux/linux_logo.h                |   11 +-
 include/linux/mfd/tps65910.h              |  115 +-
 include/linux/mfd/tps65912.h              |  327 ---
 include/linux/mfd/wm831x/core.h           |   78 -
 include/linux/mfd/wm831x/irq.h            |   18 +-
 include/linux/mfd/wm831x/pdata.h          |   30 -
 include/linux/mfd/wm831x/pmu.h            |    3 +-
 include/linux/mfd/wm8994/pdata.h          |   60 +-
 include/linux/mmc/card.h                  |   92 -
 include/linux/mmc/core.h                  |    7 +-
 include/linux/mmc/host.h                  |   68 +-
 include/linux/mmc/mmc.h                   |   87 +-
 include/linux/mmc/sdio.h                  |   35 +-
 include/linux/module.h                    |   68 +-
 include/linux/mtd/blktrans.h              |    4 +-
 include/linux/mtd/nand.h                  |    4 -
 include/linux/nls.h                       |    5 +-
 include/linux/power/smb347-charger.h      |   26 -
 include/linux/regulator/consumer.h        |   10 -
 include/linux/serial_core.h               |    4 -
 include/linux/spi/spi.h                   |   16 -
 include/linux/sync.h                      |   71 +-
 include/linux/usb/otg.h                   |   14 -
 include/linux/usb/usbnet.h                |   18 -
 include/linux/videodev2.h                 |   19 -
 include/linux/wait.h                      |   16 +-
 include/linux/wakelock.h                  |    2 -
 include/media/soc_camera.h                |   14 +-
 include/media/v4l2-chip-ident.h           |   62 +-
 include/media/videobuf-core.h             |   11 -
 include/sound/asound.h                    |    1 -
 include/sound/pcm.h                       |    2 -
 include/sound/soc-dai.h                   |    4 -
 include/sound/soc.h                       |    7 -
 init/Kconfig                              |    1 -
 init/initramfs.c                          |    2 -
 kernel/Makefile                           |    1 -
 kernel/cpu_pm.c                           |  233 --
 kernel/irq/chip.c                         |    9 +-
 kernel/module.c                           |   13 -
 kernel/params.c                           |   42 -
 kernel/power/Kconfig                      |    9 -
 kernel/power/earlysuspend.c               |   19 -
 kernel/power/power.h                      |    5 -
 kernel/power/process.c                    |    8 -
 kernel/power/suspend.c                    |    4 -
 kernel/power/wakelock.c                   |  125 +-
 kernel/printk.c                           |   22 -
 kernel/sched.c                            |    2 +-
 kernel/sys.c                              |   33 +-
 mm/bounce.c                               |    9 +-
 net/bluetooth/hci_core.c                  |    2 -
 net/ipv4/tcp_input.c                      |    2 +-
 net/mac80211/main.c                       |   12 -
 net/netfilter/xt_qtaguid.c                |   19 +-
 net/rfkill/Kconfig                        |   12 -
 net/rfkill/Makefile                       |    1 -
 net/wireless/Kconfig                      |    2 +-
 net/wireless/nl80211.c                    |   11 -
 scripts/.gitignore                        |    1 -
 scripts/Makefile                          |    1 -
 scripts/Makefile.build                    |    9 -
 scripts/pnmtologo.c                       |  255 +-
 security/commoncap.c                      |    2 -
 sound/core/pcm_native.c                   |   27 -
 sound/soc/Kconfig                         |    2 +-
 sound/soc/Makefile                        |    1 -
 sound/soc/codecs/Kconfig                  |   99 +-
 sound/soc/codecs/Makefile                 |   53 +-
 sound/soc/codecs/cs42l52.c                | 1604 -----------
 sound/soc/codecs/cs42l52.h                |  323 ---
 sound/soc/codecs/rt5631.c                 | 2252 ----------------
 sound/soc/codecs/rt5631.h                 |  570 ----
 sound/soc/codecs/wm8900.c                 | 1140 ++++----
 sound/soc/codecs/wm8988.c                 |  131 +-
 sound/soc/codecs/wm8994.c                 |  795 +-----
 sound/soc/codecs/wm8994.h                 |    5 -
 sound/soc/codecs/wm_hubs.c                |   45 +-
 sound/soc/soc-cache.c                     |    1 -
 sound/soc/soc-core.c                      |   82 +-
 318 files changed, 2498 insertions(+), 29021 deletions(-)
 delete mode 100644 drivers/gpio/gpio-tps65910.c
 delete mode 100644 drivers/input/touchscreen/pixcir_i2c_ts.c
 delete mode 100755 drivers/net/usb/asix.h
 delete mode 100644 drivers/power/smb347-charger.c
 delete mode 100755 drivers/rtc/rtc-tps65910.c
 delete mode 100644 include/linux/export.h
 delete mode 100755 include/linux/hdmi.h
 delete mode 100644 include/linux/mfd/tps65912.h
 delete mode 100644 include/linux/power/smb347-charger.h
 delete mode 100644 kernel/cpu_pm.c
 delete mode 100755 sound/soc/codecs/cs42l52.c
 delete mode 100755 sound/soc/codecs/cs42l52.h
 delete mode 100755 sound/soc/codecs/rt5631.c
 delete mode 100644 sound/soc/codecs/rt5631.h

diff --git a/.gitignore b/.gitignore
index 43c7ee06e097..9dacde0a4b2d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -32,7 +32,6 @@ modules.builtin
 *.lzo
 *.patch
 *.gcno
-Untitled Project.*
 
 #
 # Top-level generic files
@@ -45,7 +44,6 @@ Untitled Project.*
 /System.map
 /Module.markers
 /Module.symvers
-/kernel.img
 
 #
 # git files that we don't want to ignore even it they are dot-files
diff --git a/Makefile b/Makefile
index b22d80e944c8..da3ff219cf07 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,6 @@
 VERSION = 3
 PATCHLEVEL = 0
-SUBLEVEL = 36
+SUBLEVEL = 66
 EXTRAVERSION =
 NAME = Sneaky Weasel
 
@@ -192,17 +192,7 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-#ARCH		?= $(SUBARCH)
-ARCH		?= arm
-ifneq ($(wildcard ../toolchain/arm-eabi-4.4.3),)
-CROSS_COMPILE	?= ../toolchain/arm-eabi-4.4.3/bin/arm-eabi-
-endif
-ifneq ($(wildcard ../prebuilt/linux-x86/toolchain/arm-eabi-4.4.3),)
-CROSS_COMPILE	?= ../prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
-endif
-ifneq ($(wildcard ../prebuilts/gcc/linux-x86/arm/arm-eabi-4.6),)
-CROSS_COMPILE   ?= ../prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-endif
+ARCH		?= $(SUBARCH)
 CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
 
 # Architecture as present in compile.h
@@ -339,11 +329,7 @@ include $(srctree)/scripts/Kbuild.include
 # Make variables (CC, etc...)
 
 AS		= $(CROSS_COMPILE)as
-ifneq ($(wildcard $(CROSS_COMPILE)ld.bfd),)
-LD		= $(CROSS_COMPILE)ld.bfd
-else
 LD		= $(CROSS_COMPILE)ld
-endif
 CC		= $(CROSS_COMPILE)gcc
 CPP		= $(CC) -E
 AR		= $(CROSS_COMPILE)ar
@@ -1233,7 +1219,7 @@ rpm: include/config/kernel.release FORCE
 # Brief documentation of the typical targets used
 # ---------------------------------------------------------------------------
 
-boards := $(wildcard $(srctree)/arch/$(SRCARCH)/configs/rk*_defconfig)
+boards := $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*_defconfig)
 boards := $(notdir $(boards))
 board-dirs := $(dir $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*/*_defconfig))
 board-dirs := $(sort $(notdir $(board-dirs:/=)))
@@ -1579,7 +1565,3 @@ FORCE:
 # Declare the contents of the .PHONY variable as phony.  We keep that
 # information in a variable so we can use it in if_changed and friends.
 .PHONY: $(PHONY)
-
-
-%.o: %.uu prepare scripts FORCE
-	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 99490bb1bc09..b9d60775cb8b 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -29,7 +29,6 @@ config ARM
 	select HAVE_GENERIC_HARDIRQS
 	select HAVE_SPARSE_IRQ
 	select GENERIC_IRQ_SHOW
-	select CPU_PM if (SUSPEND || CPU_IDLE)
 	help
 	  The ARM series is a line of low-power-consumption RISC chip designs
 	  licensed by ARM Ltd and targeted at embedded applications and
@@ -859,91 +858,6 @@ config ARCH_OMAP
 	help
 	  Support for TI's OMAP platform (OMAP1/2/3/4).
 
-config ARCH_RK29
-	bool "Rockchip RK29xx"
-	select PLAT_RK
-	select CPU_V7
-	select ARM_GIC
-	select PL330
-	select HIGHMEM
-	select ZONE_DMA
-	select ARM_L1_CACHE_SHIFT_6
-	help
-	  Support for Rockchip's RK29xx SoCs.
-
-config ARCH_RK2928
-	bool "Rockchip RK2928"
-	select PLAT_RK
-	select CPU_V7
-	select ARM_GIC
-	select RK_PL330_DMA
-	select MIGHT_HAVE_CACHE_L2X0
-	select ARM_ERRATA_754322
-	select ARM_ERRATA_775420
-	help
-	  Support for Rockchip's RK2928 SoCs.
-
-config ARCH_RK3026
-	bool "Rockchip RK3026/RK3028A"
-	select PLAT_RK
-	select CPU_V7
-	select ARM_GIC
-	select RK_PL330_DMA
-	select RK_TIMER
-	select HAVE_ARM_TWD if LOCAL_TIMERS
-	select HAVE_SMP
-	select MIGHT_HAVE_CACHE_L2X0
-	select ARM_ERRATA_754322
-	select ARM_ERRATA_764369
-	help
-	  Support for Rockchip's RK3026/RK3028A SoCs.
-
-config ARCH_RK30
-	bool "Rockchip RK30xx/RK3108/RK3168"
-	select PLAT_RK
-	select CPU_V7
-	select ARM_GIC
-	select RK_PL330_DMA
-	select HAVE_SMP
-	select MIGHT_HAVE_CACHE_L2X0
-	select ARM_ERRATA_764369
-	select ARM_ERRATA_754322
-	select ARM_ERRATA_775420
-	help
-	  Support for Rockchip's RK30xx/RK3108/RK3168 SoCs.
-
-config ARCH_RK3188
-	bool "Rockchip RK3188"
-	select PLAT_RK
-	select CPU_V7
-	select ARM_GIC
-	select RK_PL330_DMA
-	select RK_TIMER
-	select HAVE_SMP
-	select MIGHT_HAVE_CACHE_L2X0
-	select ARM_ERRATA_761320
-	select ARM_ERRATA_764369
-	select ARM_ERRATA_754322
-	select ARM_ERRATA_775420
-	help
-	  Support for Rockchip's RK3188 SoCs.
-
-config ARCH_RK319X
-	bool "Rockchip RK319X"
-	select PLAT_RK
-	select CPU_V7
-	select ARM_GIC
-	select RK_PL330_DMA
-	select RK_TIMER
-	select HAVE_SMP
-	select MIGHT_HAVE_CACHE_L2X0
-	select ARM_ERRATA_761320 if SMP
-	select ARM_ERRATA_764369 if SMP
-	select ARM_ERRATA_754322
-	select ARM_ERRATA_775420
-	help
-	  Support for Rockchip's RK319X SoCs.
-
 config PLAT_SPEAR
 	bool "ST SPEAr"
 	select ARM_AMBA
@@ -1044,14 +958,6 @@ source "arch/arm/mach-mmp/Kconfig"
 
 source "arch/arm/mach-realview/Kconfig"
 
-source "arch/arm/plat-rk/Kconfig"
-source "arch/arm/mach-rk29/Kconfig"
-source "arch/arm/mach-rk2928/Kconfig"
-source "arch/arm/mach-rk3026/Kconfig"
-source "arch/arm/mach-rk30/Kconfig"
-source "arch/arm/mach-rk3188/Kconfig"
-source "arch/arm/mach-rk319x/Kconfig"
-
 source "arch/arm/mach-sa1100/Kconfig"
 
 source "arch/arm/plat-samsung/Kconfig"
@@ -1118,17 +1024,6 @@ config PLAT_ORION
 config PLAT_PXA
 	bool
 
-config PLAT_RK
-	bool
-	select CLKDEV_LOOKUP
-	select HAVE_SCHED_CLOCK
-	select ARCH_HAS_CPUFREQ
-	select GENERIC_CLOCKEVENTS
-	select ARCH_REQUIRE_GPIOLIB
-	select SYNC
-	select SW_SYNC
-	select SW_SYNC_USER
-
 config PLAT_VERSATILE
 	bool
 
@@ -1339,12 +1234,6 @@ config ARM_ERRATA_754327
 	  This workaround defines cpu_relax() as smp_mb(), preventing correctly
 	  written polling loops from denying visibility of updates to memory.
 
-config ARM_ERRATA_761320
-	bool "ARM errata: no direct eviction"
-	depends on CPU_V7 && SMP
-	help
-	  This option enables the workaround for the 761320 Cortex-A9 erratum.
-
 config ARM_ERRATA_764369
 	bool "ARM errata: Data cache line maintenance operation by MVA may not succeed"
 	depends on CPU_V7 && SMP
@@ -1451,21 +1340,14 @@ menu "Kernel Features"
 
 source "kernel/time/Kconfig"
 
-config HAVE_SMP
-	bool
-	help
-	  This option should be selected by machines which have an SMP-
-	  capable CPU.
-
-	  The only effect of this option is to make the SMP-related
-	  options available to the user for configuration.
-
 config SMP
 	bool "Symmetric Multi-Processing"
 	depends on CPU_V6K || CPU_V7
 	depends on GENERIC_CLOCKEVENTS
-	depends on HAVE_SMP
-	depends on MMU
+	depends on REALVIEW_EB_ARM11MP || REALVIEW_EB_A9MP || \
+		 MACH_REALVIEW_PB11MP || MACH_REALVIEW_PBX || ARCH_OMAP4 || \
+		 ARCH_EXYNOS4 || ARCH_TEGRA || ARCH_U8500 || ARCH_VEXPRESS_CA9X4 || \
+		 ARCH_MSM_SCORPIONMP || ARCH_SHMOBILE
 	select USE_GENERIC_SMP_HELPERS
 	select HAVE_ARM_SCU if !ARCH_MSM_SCORPIONMP
 	help
@@ -1551,7 +1433,7 @@ config LOCAL_TIMERS
 	bool "Use local timer interrupts"
 	depends on SMP
 	default y
-	select HAVE_ARM_TWD if (!ARCH_MSM_SCORPIONMP && !EXYNOS4_MCT && !RK_TIMER)
+	select HAVE_ARM_TWD if (!ARCH_MSM_SCORPIONMP && !EXYNOS4_MCT)
 	help
 	  Enable support for local timers on SMP platforms, rather then the
 	  legacy IPI broadcast method.  Local timers allows the system
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 1d341858dca0..f5b2b390c8f2 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -120,7 +120,7 @@ CHECKFLAGS	+= -D__arm__
 
 #Default value
 head-y		:= arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o
-textofs-y	:= 0x00408000
+textofs-y	:= 0x00008000
 textofs-$(CONFIG_ARCH_CLPS711X) := 0x00028000
 # We don't want the htc bootloader to corrupt kernel during resume
 textofs-$(CONFIG_PM_H1940)      := 0x00108000
@@ -171,12 +171,6 @@ machine-$(CONFIG_ARCH_ORION5X)		:= orion5x
 machine-$(CONFIG_ARCH_PNX4008)		:= pnx4008
 machine-$(CONFIG_ARCH_PXA)		:= pxa
 machine-$(CONFIG_ARCH_REALVIEW)		:= realview
-machine-$(CONFIG_ARCH_RK29)   		:= rk29
-machine-$(CONFIG_ARCH_RK2928)		:= rk2928
-machine-$(CONFIG_ARCH_RK3026)		:= rk3026
-machine-$(CONFIG_ARCH_RK30)		:= rk30
-machine-$(CONFIG_ARCH_RK3188)		:= rk3188
-machine-$(CONFIG_ARCH_RK319X)		:= rk319x
 machine-$(CONFIG_ARCH_RPC)		:= rpc
 machine-$(CONFIG_ARCH_S3C2410)		:= s3c2410 s3c2400 s3c2412 s3c2416 s3c2440 s3c2443
 machine-$(CONFIG_ARCH_S3C24A0)		:= s3c24a0
@@ -213,7 +207,6 @@ plat-$(CONFIG_PLAT_IOP)		:= iop
 plat-$(CONFIG_PLAT_NOMADIK)	:= nomadik
 plat-$(CONFIG_PLAT_ORION)	:= orion
 plat-$(CONFIG_PLAT_PXA)		:= pxa
-plat-$(CONFIG_PLAT_RK)		:= rk
 plat-$(CONFIG_PLAT_S3C24XX)	:= s3c24xx samsung
 plat-$(CONFIG_PLAT_S5P)		:= s5p samsung
 plat-$(CONFIG_PLAT_SPEAR)	:= spear
@@ -296,42 +289,8 @@ archclean:
 bp:;	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/bootpImage
 i zi:;	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $@
 
-PHONY += kernel.img zkernel.img
-
-ifdef CONFIG_MACH_RK29_2906
-kernel.img: Image FORCE
-	$(Q)$(srctree)/mkkrnlimg $(obj)/arch/arm/boot/Image $(obj)/kernel.img RK2906
-	@echo '  RK2906 Image:  $@ is ready'
-else
-kernel.img: Image FORCE
-	$(Q)$(srctree)/mkkrnlimg $(obj)/arch/arm/boot/Image $(obj)/kernel.img
-	@echo '  Image:  $@ is ready'
-endif
-
-zkernel.img: zImage FORCE
-	$(Q)$(srctree)/mkkrnlimg $(obj)/arch/arm/boot/zImage $(obj)/kernel.img
-	@echo '  Image:  kernel.img is ready'
-
-ANDROID_RAMDISK_IMG := $(shell echo $(OUT) | sed -e 's/^.*\/out\/target\/product\//out\/target\/product\//')/ramdisk.img
-ANDROID_DIR := $(shell cd $(OUT)/../../../../ && pwd)
-ANDROID_PROCESSORS := $(shell grep 'processor' /proc/cpuinfo | wc -l)
-checkandroid: FORCE
-	$(Q)test -n "$(OUT)" || (echo "Run 'cd .. && . build/envsetup.sh && setpaths && cd -' first to build boot.img"; /bin/false)
-	$(Q)test -n "`which mkbootimg`" || (echo "No mkbootimg, try build..." && sudo -u `whoami` $(MAKE) -j$(ANDROID_PROCESSORS) -C $(ANDROID_DIR) mkbootimg $(ANDROID_RAMDISK_IMG))
-	$(Q)test -e $(OUT)/ramdisk.img || (echo "No $(OUT)/ramdisk.img, try build..." && sudo -u `whoami` $(MAKE) -j$(ANDROID_PROCESSORS) -C $(ANDROID_DIR) $(ANDROID_RAMDISK_IMG))
-
-PHONY += bootimg boot.img
-bootimg boot.img: zImage checkandroid FORCE
-	$(Q)cp -a $(obj)/arch/arm/boot/zImage $(OUT)/kernel
-	$(Q)mkbootimg --kernel $(OUT)/kernel --ramdisk $(OUT)/ramdisk.img --output $(OUT)/boot.img
-	@echo '  Image:  $(OUT)/boot.img is ready'
-	$Q[ -d $(ANDROID_DIR)/rockdev/Image/ ] && cp -a $(OUT)/boot.img $(ANDROID_DIR)/rockdev/Image/ && echo '  Image:  $(ANDROID_DIR)/rockdev/Image/boot.img is ready' || /bin/true
 
 define archhelp
-  echo  '  kernel.img    - Rockchip kernel image'
-  echo  '  zkernel.img   - Compressed Rockchip kernel image'
-  echo  '  boot.img'
-  echo  '  bootimg       - Android boot image'
   echo  '* zImage        - Compressed kernel image (arch/$(ARCH)/boot/zImage)'
   echo  '  Image         - Uncompressed kernel image (arch/$(ARCH)/boot/Image)'
   echo  '* xipImage      - XIP kernel image, if configured (arch/$(ARCH)/boot/xipImage)'
diff --git a/arch/arm/boot/Makefile b/arch/arm/boot/Makefile
index d05693bd812a..9128fddf1109 100644
--- a/arch/arm/boot/Makefile
+++ b/arch/arm/boot/Makefile
@@ -62,8 +62,7 @@ endif
 quiet_cmd_uimage = UIMAGE  $@
       cmd_uimage = $(CONFIG_SHELL) $(MKIMAGE) -A arm -O linux -T kernel \
 		   -C none -a $(LOADADDR) -e $(STARTADDR) \
-		   -n 'Linux-$(KERNELRELEASE)' -d $< $@ \
-		   && dd if=$@ of=$@.pad bs=4096 conv=sync 2>/dev/null && mv $@.pad $@
+		   -n 'Linux-$(KERNELRELEASE)' -d $< $@
 
 ifeq ($(CONFIG_ZBOOT_ROM),y)
 $(obj)/uImage: LOADADDR=$(CONFIG_ZBOOT_ROM_TEXT)
@@ -73,13 +72,9 @@ endif
 
 $(obj)/uImage: STARTADDR=$(LOADADDR)
 
-$(obj)/Image.gz: $(obj)/Image FORCE
-	$(call if_changed,gzip)
-	@echo '  Image:  $@ is ready'
-
-$(obj)/uImage: $(obj)/Image FORCE
+$(obj)/uImage:	$(obj)/zImage FORCE
 	$(call if_changed,uimage)
-	@echo '  Image:  $@ is ready'
+	@echo '  Image $@ is ready'
 
 $(obj)/bootp/bootp: $(obj)/zImage initrd FORCE
 	$(Q)$(MAKE) $(build)=$(obj)/bootp $@
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index 36c9bed899f9..caddb9d35b73 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -177,10 +177,6 @@ not_angel:
 #endif
 
 		bl	cache_on
-#ifdef CONFIG_ARCH_RK29
-		bl	cache_off
-		bl	cache_on
-#endif
 
 restart:	adr	r0, LC0
 		ldmia	r0, {r1, r2, r3, r6, r10, r11, r12}
diff --git a/arch/arm/common/fiq_debugger.c b/arch/arm/common/fiq_debugger.c
index 152f38f5a022..3ed18ae2ed80 100644
--- a/arch/arm/common/fiq_debugger.c
+++ b/arch/arm/common/fiq_debugger.c
@@ -43,15 +43,7 @@
 
 #include "fiq_debugger_ringbuf.h"
 
-#ifdef CONFIG_RK29_WATCHDOG
-extern void rk29_wdt_keepalive(void);
-#define wdt_keepalive() rk29_wdt_keepalive()
-#else
-#define wdt_keepalive() do {} while (0)
-#endif
-
 #define DEBUG_MAX 64
-#define CMD_COUNT 0x0f
 #define MAX_UNHANDLED_FIQ_COUNT 1000000
 
 #define THREAD_INFO(sp) ((struct thread_info *) \
@@ -76,10 +68,6 @@ struct fiq_debugger_state {
 	char debug_buf[DEBUG_MAX];
 	int debug_count;
 
-	char cmd_buf[CMD_COUNT+1][DEBUG_MAX];
-	int back_pointer;
-	int current_pointer;
-
 	bool no_sleep;
 	bool debug_enable;
 	bool ignore_next_wakeup_irq;
@@ -217,7 +205,6 @@ static void dump_kernel_log(struct fiq_debugger_state *state)
 	saved_oip = oops_in_progress;
 	oops_in_progress = 1;
 	for (;;) {
-		wdt_keepalive();
 		ret = log_buf_copy(buf, idx, 1023);
 		if (ret <= 0)
 			break;
@@ -228,28 +215,6 @@ static void dump_kernel_log(struct fiq_debugger_state *state)
 	oops_in_progress = saved_oip;
 }
 
-#ifdef CONFIG_RK29_LAST_LOG
-#include <linux/ctype.h>
-extern char *last_log_get(unsigned *size);
-static void dump_last_kernel_log(struct fiq_debugger_state *state)
-{
-	unsigned size, i, c;
-	char *s = last_log_get(&size);
-
-	for (i = 0; i < size; i++) {
-		if (i % 1024 == 0)
-			wdt_keepalive();
-		c = s[i];
-		if (c == '\n') {
-			state->pdata->uart_putc(state->pdev, '\r');
-			state->pdata->uart_putc(state->pdev, c);
-		} else if (isascii(c) && isprint(c)) {
-			state->pdata->uart_putc(state->pdev, c);
-		}
-	}
-}
-#endif
-
 static char *mode_name(unsigned cpsr)
 {
 	switch (cpsr & MODE_MASK) {
@@ -407,7 +372,6 @@ static void dump_irqs(struct fiq_debugger_state *state)
 		state->last_irqs[n] = kstat_irqs(n);
 	}
 
-#ifdef CONFIG_LOCAL_TIMERS
 	for (cpu = 0; cpu < NR_CPUS; cpu++) {
 
 		debug_printf(state, "LOC %d: %10u %11u\n", cpu,
@@ -417,7 +381,6 @@ static void dump_irqs(struct fiq_debugger_state *state)
 		state->last_local_timer_irqs[cpu] =
 			__IRQ_STAT(cpu, local_timer_irqs);
 	}
-#endif
 }
 
 struct stacktrace_state {
@@ -578,51 +541,14 @@ static void do_sysrq(struct fiq_debugger_state *state, char rq)
 /* This function CANNOT be called in FIQ context */
 static void debug_irq_exec(struct fiq_debugger_state *state, char *cmd)
 {
-	int invalid_cmd = 0;
 	if (!strcmp(cmd, "ps"))
 		do_ps(state);
-	else if (!strcmp(cmd, "sysrq"))
+	if (!strcmp(cmd, "sysrq"))
 		do_sysrq(state, 'h');
-	else if (!strncmp(cmd, "sysrq ", 6))
+	if (!strncmp(cmd, "sysrq ", 6))
 		do_sysrq(state, cmd[6]);
-	else {
-		invalid_cmd = 1;
-		memset(state->debug_buf, 0, DEBUG_MAX);
-	}
-
-	if (invalid_cmd == 0) {
-		state->current_pointer = (state->current_pointer-1) & CMD_COUNT;
-		if (strcmp(state->cmd_buf[state->current_pointer], state->debug_buf)) {
-			state->current_pointer = (state->current_pointer+1) & CMD_COUNT;
-			memset(state->cmd_buf[state->current_pointer], 0, DEBUG_MAX);
-			strcpy(state->cmd_buf[state->current_pointer], state->debug_buf);
-		}
-		memset(state->debug_buf, 0, DEBUG_MAX);
-		state->current_pointer = (state->current_pointer+1) & CMD_COUNT;
-		state->back_pointer = state->current_pointer;
-	}
 }
 
-static char cmd_buf[][16] = {
-		{"pc"},
-		{"regs"},
-		{"allregs"},
-		{"bt"},
-		{"reboot"},
-		{"irqs"},
-		{"kmsg"},
-#ifdef CONFIG_RK29_LAST_LOG
-		{"last_kmsg"},
-#endif
-		{"version"},
-		{"sleep"},
-		{"nosleep"},
-		{"console"},
-		{"cpu"},
-		{"ps"},
-		{"sysrq"},
-};
-
 static void debug_help(struct fiq_debugger_state *state)
 {
 	debug_printf(state,	"FIQ Debugger commands:\n"
@@ -634,9 +560,6 @@ static void debug_help(struct fiq_debugger_state *state)
 				" irqs          Interupt status\n"
 				" kmsg          Kernel log\n"
 				" version       Kernel version\n");
-#ifdef CONFIG_RK29_LAST_LOG
-	debug_printf(state,	" last_kmsg     Last kernel log\n");
-#endif
 	debug_printf(state,	" sleep         Allow sleep while in FIQ\n"
 				" nosleep       Disable sleep while in FIQ\n"
 				" console       Switch terminal to console\n"
@@ -662,22 +585,6 @@ static void switch_cpu(struct fiq_debugger_state *state, int cpu)
 {
 	if (!debug_have_fiq(state))
 		smp_call_function_single(cpu, take_affinity, state, false);
-#ifdef CONFIG_PLAT_RK
-	else {
-		struct cpumask cpumask;
-
-		if (!cpu_online(cpu)) {
-			debug_printf(state, "cpu %d offline\n", cpu);
-			return;
-		}
-
-		cpumask_clear(&cpumask);
-		cpumask_set_cpu(cpu, &cpumask);
-
-		irq_set_affinity(state->fiq, &cpumask);
-		irq_set_affinity(state->uart_irq, &cpumask);
-	}
-#endif
 	state->current_cpu = cpu;
 }
 
@@ -699,16 +606,10 @@ static bool debug_fiq_exec(struct fiq_debugger_state *state,
 		dump_stacktrace(state, (struct pt_regs *)regs, 100, svc_sp);
 	} else if (!strcmp(cmd, "reboot")) {
 		arch_reset(0, 0);
-	} else if (!strncmp(cmd, "reboot ", 7)) {
-		arch_reset(0, &cmd[7]);
 	} else if (!strcmp(cmd, "irqs")) {
 		dump_irqs(state);
 	} else if (!strcmp(cmd, "kmsg")) {
 		dump_kernel_log(state);
-#ifdef CONFIG_RK29_LAST_LOG
-	} else if (!strcmp(cmd, "last_kmsg")) {
-		dump_last_kernel_log(state);
-#endif
 	} else if (!strcmp(cmd, "version")) {
 		debug_printf(state, "%s\n", linux_banner);
 	} else if (!strcmp(cmd, "sleep")) {
@@ -831,109 +732,6 @@ static int debug_getc(struct fiq_debugger_state *state)
 	return state->pdata->uart_getc(state->pdev);
 }
 
-
-static int debug_cmd_check_back(struct fiq_debugger_state *state, char c)
-{
-	char *s;
-	int i = 0;
-	if (c == 'A') {
-		state->back_pointer = (state->back_pointer-1) & CMD_COUNT;
-		if (state->back_pointer != state->current_pointer) {
-			s = state->cmd_buf[state->back_pointer];
-			if (*s != 0) {
-				for(i = 0; i < strlen(state->debug_buf)-1; i++) {
-					state->pdata->uart_putc(state->pdev, 8);
-					state->pdata->uart_putc(state->pdev, ' ');
-					state->pdata->uart_putc(state->pdev, 8);
-				}
-				memset(state->debug_buf, 0, DEBUG_MAX);
-				strcpy(state->debug_buf, s);
-				state->debug_count = strlen(state->debug_buf);
-				debug_printf(state, state->debug_buf);
-			} else {
-				state->back_pointer = (state->back_pointer+1) & CMD_COUNT;
-			}
-
-		} else {
-			state->back_pointer = (state->back_pointer+1) & CMD_COUNT;
-		}
-	} else if (c == 'B') {
-
-		if (state->back_pointer != state->current_pointer) {
-			state->back_pointer = (state->back_pointer+1) & CMD_COUNT;
-			if(state->back_pointer == state->current_pointer){
-				goto cmd_clear;
-			} else {
-				s = state->cmd_buf[state->back_pointer];
-				if (*s != 0) {
-					for(i = 0; i < strlen(state->debug_buf)-1; i++) {
-						state->pdata->uart_putc(state->pdev, 8);
-						state->pdata->uart_putc(state->pdev, ' ');
-						state->pdata->uart_putc(state->pdev, 8);
-					}
-					memset(state->debug_buf, 0, DEBUG_MAX);
-					strcpy(state->debug_buf, s);
-					state->debug_count = strlen(state->debug_buf);
-					debug_printf(state, state->debug_buf);
-				}
-			}
-		} else {
-cmd_clear:
-			for(i = 0; i < strlen(state->debug_buf)-1; i++) {
-				state->pdata->uart_putc(state->pdev, 8);
-				state->pdata->uart_putc(state->pdev, ' ');
-				state->pdata->uart_putc(state->pdev, 8);
-			}
-			memset(state->debug_buf, 0, DEBUG_MAX);
-			state->debug_count = 0;
-		}
-	}
-	return 0;
-}
-
-static void debug_cmd_tab(struct fiq_debugger_state *state)
-{
-	int i,j;
-	int count = 0;
-
-	for (i = 0; i < ARRAY_SIZE(cmd_buf); i++) {
-		cmd_buf[i][15] = 1;
-	}
-
-	for (j = 1; j <= strlen(state->debug_buf); j++) {
-		count = 0;
-		for (i = 0; i < ARRAY_SIZE(cmd_buf); i++) {
-			if (cmd_buf[i][15] == 1) {
-				if (strncmp(state->debug_buf, cmd_buf[i], j)) {
-					cmd_buf[i][15] = 0;
-				} else {
-					count++;
-				}
-			}
-		}
-		if (count == 0)
-			break;
-	}
-
-	if (count == 1) {
-		for (i = 0; i < ARRAY_SIZE(cmd_buf); i++) {
-			if (cmd_buf[i][15] == 1)
-				break;
-		}
-
-		for(j = 0; j < strlen(state->debug_buf); j++) {
-			state->pdata->uart_putc(state->pdev, 8);
-			state->pdata->uart_putc(state->pdev, ' ');
-			state->pdata->uart_putc(state->pdev, 8);
-		}
-		memset(state->debug_buf, 0, DEBUG_MAX);
-		strcpy(state->debug_buf, cmd_buf[i]);
-		state->debug_count = strlen(state->debug_buf);
-		debug_printf(state, state->debug_buf);
-
-	}
-}
-
 static bool debug_handle_uart_interrupt(struct fiq_debugger_state *state,
 			int this_cpu, void *regs, void *svc_sp)
 {
@@ -973,26 +771,12 @@ static bool debug_handle_uart_interrupt(struct fiq_debugger_state *state,
 			state->console_enable = false;
 			debug_puts(state, "fiq debugger mode\n");
 			state->debug_count = 0;
-			state->back_pointer = CMD_COUNT;
-			state->current_pointer = CMD_COUNT;
-			memset(state->cmd_buf, 0, (CMD_COUNT+1)*DEBUG_MAX);
 			debug_prompt(state);
 #ifdef CONFIG_FIQ_DEBUGGER_CONSOLE
 		} else if (state->console_enable && state->tty_rbuf) {
 			fiq_debugger_ringbuf_push(state->tty_rbuf, c);
 			signal_helper = true;
 #endif
-		} else if (last_c == '[' && (c == 'A' || c == 'B' || c == 'C' || c == 'D')) {
-			if (state->debug_count > 0) {
-				state->debug_count--;
-				state->pdata->uart_putc(state->pdev, 8);
-				state->pdata->uart_putc(state->pdev, ' ');
-				state->pdata->uart_putc(state->pdev, 8);
-			}
-			debug_cmd_check_back(state, c);
-			//tab
-		} else if (c == 9) {
-			debug_cmd_tab(state);
 		} else if ((c >= ' ') && (c < 127)) {
 			if (state->debug_count < (DEBUG_MAX - 1)) {
 				state->debug_buf[state->debug_count++] = c;
@@ -1004,7 +788,6 @@ static bool debug_handle_uart_interrupt(struct fiq_debugger_state *state,
 				state->pdata->uart_putc(state->pdev, 8);
 				state->pdata->uart_putc(state->pdev, ' ');
 				state->pdata->uart_putc(state->pdev, 8);
-				state->debug_buf[state->debug_count] = 0;
 			}
 		} else if ((c == 13) || (c == 10)) {
 			if (c == '\r' || (c == '\n' && last_c != '\r')) {
@@ -1017,17 +800,6 @@ static bool debug_handle_uart_interrupt(struct fiq_debugger_state *state,
 				signal_helper |=
 					debug_fiq_exec(state, state->debug_buf,
 						       regs, svc_sp);
-				if (signal_helper == false) {
-					state->current_pointer = (state->current_pointer-1) & CMD_COUNT;
-					if (strcmp(state->cmd_buf[state->current_pointer], state->debug_buf)) {
-						state->current_pointer = (state->current_pointer+1) & CMD_COUNT;
-						memset(state->cmd_buf[state->current_pointer], 0, DEBUG_MAX);
-						strcpy(state->cmd_buf[state->current_pointer], state->debug_buf);
-					}
-					memset(state->debug_buf, 0, DEBUG_MAX);
-					state->current_pointer = (state->current_pointer+1) & CMD_COUNT;
-					state->back_pointer = state->current_pointer;
-				}
 			} else {
 				debug_prompt(state);
 			}
@@ -1055,21 +827,6 @@ static void debug_fiq(struct fiq_glue_handler *h, void *regs, void *svc_sp)
 	unsigned int this_cpu = THREAD_INFO(svc_sp)->cpu;
 	bool need_irq;
 
-	/* RK2928 USB-UART function, otg dp/dm default in uart status;
-	 * connect with otg cable&usb device, dp/dm will be hi-z status 
-	 * and make uart controller enter infinite fiq loop 
-	 */
-#ifdef CONFIG_RK_USB_UART
-#ifdef CONFIG_ARCH_RK2928
-	if(!(readl_relaxed(RK2928_GRF_BASE + 0x014c) & (1<<10))){//id low          
-		writel_relaxed(0x34000000, RK2928_GRF_BASE + 0x190);   //enter usb phy    
-	}
-#elif defined(CONFIG_ARCH_RK3188)
-	if(!(readl_relaxed(RK30_GRF_BASE + 0x00ac) & (1 << 13))){//id low          
-		writel_relaxed((0x0300 << 16), RK30_GRF_BASE + 0x010c);   //enter usb phy    
-	}
-#endif
-#endif
 	need_irq = debug_handle_uart_interrupt(state, this_cpu, regs, svc_sp);
 	if (need_irq)
 		debug_force_irq(state);
@@ -1141,13 +898,6 @@ static void debug_console_write(struct console *co,
 	if (!state->console_enable && !state->syslog_dumping)
 		return;
 
-#ifdef CONFIG_RK_CONSOLE_THREAD
-	if (state->pdata->console_write) {
-		state->pdata->console_write(state->pdev, s, count);
-		return;
-	}
-#endif
-
 	debug_uart_enable(state);
 	while (count--) {
 		if (*s == '\n')
diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index be20b306d94a..4ddd0a6ac7ff 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -92,9 +92,6 @@ static void gic_mask_irq(struct irq_data *d)
 	writel_relaxed(mask, gic_dist_base(d) + GIC_DIST_ENABLE_CLEAR + (gic_irq(d) / 32) * 4);
 	if (gic_arch_extn.irq_mask)
 		gic_arch_extn.irq_mask(d);
-#if defined(CONFIG_PLAT_RK) && !defined(CONFIG_SMP)
-	dsb();
-#endif
 	spin_unlock(&irq_controller_lock);
 }
 
@@ -106,9 +103,6 @@ static void gic_unmask_irq(struct irq_data *d)
 	if (gic_arch_extn.irq_unmask)
 		gic_arch_extn.irq_unmask(d);
 	writel_relaxed(mask, gic_dist_base(d) + GIC_DIST_ENABLE_SET + (gic_irq(d) / 32) * 4);
-#if defined(CONFIG_PLAT_RK) && !defined(CONFIG_SMP)
-	dsb();
-#endif
 	spin_unlock(&irq_controller_lock);
 }
 
@@ -121,9 +115,6 @@ static void gic_eoi_irq(struct irq_data *d)
 	}
 
 	writel_relaxed(gic_irq(d), gic_cpu_base(d) + GIC_CPU_EOI);
-#ifdef CONFIG_PLAT_RK
-	dsb();
-#endif
 }
 
 static int gic_set_type(struct irq_data *d, unsigned int type)
@@ -212,9 +203,6 @@ static int gic_set_wake(struct irq_data *d, unsigned int on)
 {
 	int ret = -ENXIO;
 
-#ifdef CONFIG_PLAT_RK
-	return 0;
-#endif
 	if (gic_arch_extn.irq_set_wake)
 		ret = gic_arch_extn.irq_set_wake(d, on);
 
@@ -290,13 +278,8 @@ static void __init gic_dist_init(struct gic_chip_data *gic,
 	 * Find out how many interrupts are supported.
 	 * The GIC only supports up to 1020 interrupt sources.
 	 */
-#ifdef CONFIG_ARCH_RK29
-	/* rk29 read GIC_DIST_CTR is 2, why? */
-	gic_irqs = NR_AIC_IRQS;
-#else
 	gic_irqs = readl_relaxed(base + GIC_DIST_CTR) & 0x1f;
 	gic_irqs = (gic_irqs + 1) * 32;
-#endif
 	if (gic_irqs > 1020)
 		gic_irqs = 1020;
 
diff --git a/arch/arm/common/pl330.c b/arch/arm/common/pl330.c
index ffbc40e550cd..97912fa48782 100644
--- a/arch/arm/common/pl330.c
+++ b/arch/arm/common/pl330.c
@@ -28,9 +28,7 @@
 #include <linux/interrupt.h>
 #include <linux/dma-mapping.h>
 
-#include <asm/unaligned.h>
 #include <asm/hardware/pl330.h>
-#include <mach/sram.h>
 
 /* Register and Bit field Definitions */
 #define DS		0x0
@@ -221,7 +219,7 @@
  * For typical scenario, at 1word/burst, 10MB and 20MB xfers per req
  * should be enough for P<->M and M<->M respectively.
  */
-#define MCODE_BUFF_PER_REQ	128
+#define MCODE_BUFF_PER_REQ	256
 
 /*
  * Mark a _pl330_req as free.
@@ -379,17 +377,10 @@ static inline u32 get_id(struct pl330_info *pi, u32 off)
 	void __iomem *regs = pi->base;
 	u32 id = 0;
 
-#ifdef CONFIG_PLAT_RK
-	id |= ((readl(regs + off + 0x0) & 0xff) << 0);
-	id |= ((readl(regs + off + 0x4) & 0xff) << 8);
-	id |= ((readl(regs + off + 0x8) & 0xff) << 16);
-	id |= ((readl(regs + off + 0xc) & 0xff) << 24);
-#else
 	id |= (readb(regs + off + 0x0) << 0);
 	id |= (readb(regs + off + 0x4) << 8);
 	id |= (readb(regs + off + 0x8) << 16);
 	id |= (readb(regs + off + 0xc) << 24);
-#endif
 
 	return id;
 }
@@ -402,7 +393,7 @@ static inline u32 _emit_ADDH(unsigned dry_run, u8 buf[],
 
 	buf[0] = CMD_DMAADDH;
 	buf[0] |= (da << 1);
-	put_unaligned(val, (u16 *)&buf[1]);	//*((u16 *)&buf[1]) = val;
+	*((u16 *)&buf[1]) = val;
 
 	PL330_DBGCMD_DUMP(SZ_DMAADDH, "\tDMAADDH %s %u\n",
 		da == 1 ? "DA" : "SA", val);
@@ -556,7 +547,7 @@ static inline u32 _emit_MOV(unsigned dry_run, u8 buf[],
 
 	buf[0] = CMD_DMAMOV;
 	buf[1] = dst;
-	put_unaligned(val, (u32 *)&buf[2]);	//*((u32 *)&buf[2]) = val;
+	*((u32 *)&buf[2]) = val;
 
 	PL330_DBGCMD_DUMP(SZ_DMAMOV, "\tDMAMOV %s 0x%x\n",
 		dst == SAR ? "SAR" : (dst == DAR ? "DAR" : "CCR"), val);
@@ -734,7 +725,7 @@ static inline u32 _emit_GO(unsigned dry_run, u8 buf[],
 
 	buf[1] = chan & 0x7;
 
-	put_unaligned(addr, (u32 *)&buf[2]);	//*((u32 *)&buf[2]) = addr;
+	*((u32 *)&buf[2]) = addr;
 
 	return SZ_DMAGO;
 }
@@ -999,10 +990,10 @@ static inline int _ldst_devtomem(unsigned dry_run, u8 buf[],
 	int off = 0;
 
 	while (cyc--) {
-		off += _emit_WFP(dry_run, &buf[off], BURST, pxs->r->peri);
-		off += _emit_LDP(dry_run, &buf[off], BURST, pxs->r->peri);
+		off += _emit_WFP(dry_run, &buf[off], SINGLE, pxs->r->peri);
+		off += _emit_LDP(dry_run, &buf[off], SINGLE, pxs->r->peri);
 		off += _emit_ST(dry_run, &buf[off], ALWAYS);
-		//off += _emit_FLUSHP(dry_run, &buf[off], pxs->r->peri);    //for sdmmc sdio
+		off += _emit_FLUSHP(dry_run, &buf[off], pxs->r->peri);
 	}
 
 	return off;
@@ -1014,10 +1005,10 @@ static inline int _ldst_memtodev(unsigned dry_run, u8 buf[],
 	int off = 0;
 
 	while (cyc--) {
-		off += _emit_WFP(dry_run, &buf[off], BURST, pxs->r->peri);
+		off += _emit_WFP(dry_run, &buf[off], SINGLE, pxs->r->peri);
 		off += _emit_LD(dry_run, &buf[off], ALWAYS);
-		off += _emit_STP(dry_run, &buf[off], BURST, pxs->r->peri);
-		//off += _emit_FLUSHP(dry_run, &buf[off], pxs->r->peri);     //for sdmmc sdio
+		off += _emit_STP(dry_run, &buf[off], SINGLE, pxs->r->peri);
+		off += _emit_FLUSHP(dry_run, &buf[off], pxs->r->peri);
 	}
 
 	return off;
@@ -1125,62 +1116,6 @@ static inline int _loop(unsigned dry_run, u8 buf[],
 	return off;
 }
 
-/* Returns bytes consumed and updates bursts */
-static inline int _loop_infiniteloop(unsigned dry_run, u8 buf[],
-		unsigned long bursts, const struct _xfer_spec *pxs, int ev)
-{
-	int cyc, off;
-	unsigned lcnt0, lcnt1, ljmp0, ljmp1, ljmpfe;
-	struct _arg_LPEND lpend;
-
-	off = 0;
-	ljmpfe = off;
-	lcnt0 = pxs->r->infiniteloop;
-	//hhb
-	/* Max iterations possible in DMALP is 256 */
-	if (bursts > 256) {
-		lcnt1 = 256;
-		cyc = bursts/256;    //cyc shuold be less than 8
-	} else {
-		lcnt1 = bursts;
-		cyc = 1;
-	}
-
-	/* forever loop */
-	off += _emit_MOV(dry_run, &buf[off], SAR, pxs->x->src_addr);
-	off += _emit_MOV(dry_run, &buf[off], DAR, pxs->x->dst_addr);
-
-	/* loop0 */
-	off += _emit_LP(dry_run, &buf[off], 0,  lcnt0);
-	ljmp0 = off;
-
-	/* loop1 */
-	off += _emit_LP(dry_run, &buf[off], 1, lcnt1);
-	ljmp1 = off;
-	off += _bursts(dry_run, &buf[off], pxs, cyc);
-	lpend.cond = ALWAYS;
-	lpend.forever = false;
-	lpend.loop = 1;
-	lpend.bjump = off - ljmp1;
-	off += _emit_LPEND(dry_run, &buf[off], &lpend);
-	if(pxs->r->infiniteloop_sev)   //may be we don't need interrupt when dma transfer
-		off += _emit_SEV(dry_run, &buf[off], ev);
-	/* end loop1 */
-	lpend.cond = ALWAYS;
-	lpend.forever = false;
-	lpend.loop = 0;
-	lpend.bjump = off - ljmp0;
-	off += _emit_LPEND(dry_run, &buf[off], &lpend);
-	/* end loop0 */
-	lpend.cond = ALWAYS;
-	lpend.forever = true;
-	lpend.loop = 1;
-	lpend.bjump = off - ljmpfe;
-	off +=  _emit_LPEND(dry_run, &buf[off], &lpend);
-
-	return off;
-}
-
 static inline int _setup_loops(unsigned dry_run, u8 buf[],
 		const struct _xfer_spec *pxs)
 {
@@ -1215,20 +1150,6 @@ static inline int _setup_xfer(unsigned dry_run, u8 buf[],
 	return off;
 }
 
-static inline int _setup_xfer_infiniteloop(unsigned dry_run, u8 buf[],
-		const struct _xfer_spec *pxs, int ev)
-{
-	struct pl330_xfer *x = pxs->x;
-	u32 ccr = pxs->ccr;
-	unsigned long bursts = BYTE_TO_BURST(x->bytes, ccr);
-	int off = 0;
-
-	/* Setup Loop(s) */
-	off += _loop_infiniteloop(dry_run, &buf[off], bursts, pxs, ev);
-
-	return off;
-}
-
 /*
  * A req is a sequence of one or more xfer units.
  * Returns the number of bytes taken to setup the MC for the req.
@@ -1247,33 +1168,22 @@ static int _setup_req(unsigned dry_run, struct pl330_thread *thrd,
 	off += _emit_MOV(dry_run, &buf[off], CCR, pxs->ccr);
 
 	x = pxs->r->x;
-
-	if (!pxs->r->infiniteloop) {
-		do {
-			/* Error if xfer length is not aligned at burst size */
-			if (x->bytes % (BRST_SIZE(pxs->ccr)
-						* BRST_LEN(pxs->ccr)))
-				return -EINVAL;
-
-			pxs->x = x;
-			off += _setup_xfer(dry_run, &buf[off], pxs);
-
-			x = x->next;
-		} while (x);
-
-		/* DMASEV peripheral/event */
-		off += _emit_SEV(dry_run, &buf[off], thrd->ev);
-		/* DMAEND */
-		off += _emit_END(dry_run, &buf[off]);
-	} else {
+	do {
 		/* Error if xfer length is not aligned at burst size */
 		if (x->bytes % (BRST_SIZE(pxs->ccr) * BRST_LEN(pxs->ccr)))
 			return -EINVAL;
 
 		pxs->x = x;
-		off += _setup_xfer_infiniteloop
-				(dry_run, &buf[off], pxs, thrd->ev);
-	}
+		off += _setup_xfer(dry_run, &buf[off], pxs);
+
+		x = x->next;
+	} while (x);
+
+	/* DMASEV peripheral/event */
+	off += _emit_SEV(dry_run, &buf[off], thrd->ev);
+	/* DMAEND */
+	off += _emit_END(dry_run, &buf[off]);
+
 	return off;
 }
 
@@ -1371,17 +1281,17 @@ int pl330_submit_req(void *ch_id, struct pl330_req *r)
 		goto xfer_exit;
 	}
 
+	/* Prefer Secure Channel */
+	if (!_manager_ns(thrd))
+		r->cfg->nonsecure = 0;
+	else
+		r->cfg->nonsecure = 1;
+
 	/* Use last settings, if not provided */
-	if (r->cfg) {
-		/* Prefer Secure Channel */
-		if (!_manager_ns(thrd))
-			r->cfg->nonsecure = 0;
-		else
-			r->cfg->nonsecure = 1;
+	if (r->cfg)
 		ccr = _prepare_ccr(r->cfg);
-	} else {
+	else
 		ccr = readl(regs + CC(thrd->id));
-	}
 
 	/* If this req doesn't have valid xfer settings */
 	if (!_is_valid(ccr)) {
@@ -1558,13 +1468,10 @@ int pl330_update(const struct pl330_info *pi)
 			active -= 1;
 
 			rqdone = &thrd->req[active];
+			MARK_FREE(rqdone);
 
-			if (!rqdone->r->infiniteloop) {
-				MARK_FREE(rqdone);
-
-				/* Get going again ASAP */
-				_start(thrd);
-			}
+			/* Get going again ASAP */
+			_start(thrd);
 
 			/* For now, just make a list of callbacks to be done */
 			list_add_tail(&rqdone->rqd, &pl330->req_done);
@@ -1715,15 +1622,11 @@ static inline int _alloc_event(struct pl330_thread *thrd)
 
 	return -1;
 }
-//hhb@rock-chips.com
-#ifdef CONFIG_RK_SRAM_DMA
-static __attribute__((aligned(4))) __sramdata char i2s_mcode_buff[2][MCODE_BUFF_PER_REQ*2];
-#endif
 
 /* Upon success, returns IdentityToken for the
  * allocated channel, NULL otherwise.
  */
-void *pl330_request_channel(int id, const struct pl330_info *pi)
+void *pl330_request_channel(const struct pl330_info *pi)
 {
 	struct pl330_thread *thrd = NULL;
 	struct pl330_dmac *pl330;
@@ -1758,29 +1661,7 @@ void *pl330_request_channel(int id, const struct pl330_info *pi)
 		}
 		thrd = NULL;
 	}
-#ifdef CONFIG_RK_SRAM_DMA
-	switch(id) {
-		case 4:   	//DMACH_I2S0_8CH_TX
-		case 6:		//DMACH_I2S1_2CH_TX
-		case 9:		//DMACH_I2S2_2CH_TX
-			thrd->req[0].mc_bus = (u32)(RK30_IMEM_PHYS + ((void *)i2s_mcode_buff[0] - RK30_IMEM_BASE));
-			thrd->req[0].mc_cpu = (RK30_IMEM_NONCACHED + ((void *)i2s_mcode_buff[0] - RK30_IMEM_BASE));
-			thrd->req[1].mc_bus = thrd->req[0].mc_bus + MCODE_BUFF_PER_REQ;
-			thrd->req[1].mc_cpu = thrd->req[0].mc_cpu + MCODE_BUFF_PER_REQ;
-			break;
-		case 5:   	//DMACH_I2S0_8CH_RX
-		case 7:		//DMACH_I2S1_2CH_RX
-		case 10:	//DMACH_I2S2_2CH_RX
-			thrd->req[0].mc_bus = (u32)(RK30_IMEM_PHYS + ((void *)i2s_mcode_buff[1] - RK30_IMEM_BASE));
-			thrd->req[0].mc_cpu = (RK30_IMEM_NONCACHED + ((void *)i2s_mcode_buff[1] - RK30_IMEM_BASE));
-			thrd->req[1].mc_bus = thrd->req[0].mc_bus + MCODE_BUFF_PER_REQ;
-			thrd->req[1].mc_cpu = thrd->req[0].mc_cpu + MCODE_BUFF_PER_REQ;
-			break;
-		default:
-			break;
 
-	}
-#endif
 	spin_unlock_irqrestore(&pl330->lock, flags);
 
 	return thrd;
diff --git a/arch/arm/include/asm/atomic.h b/arch/arm/include/asm/atomic.h
index 16d92e837c53..7e79503ab89b 100644
--- a/arch/arm/include/asm/atomic.h
+++ b/arch/arm/include/asm/atomic.h
@@ -27,7 +27,7 @@
 #define atomic_read(v)	(*(volatile int *)&(v)->counter)
 #define atomic_set(v,i)	(((v)->counter) = (i))
 
-#if __LINUX_ARM_ARCH__ >= 6 && !defined(CONFIG_CPU_DCACHE_DISABLE)
+#if __LINUX_ARM_ARCH__ >= 6
 
 /*
  * ARMv6 UP and SMP safe atomic ops.  We use load exclusive and
diff --git a/arch/arm/include/asm/fiq_debugger.h b/arch/arm/include/asm/fiq_debugger.h
index 38a82f1ee354..4d274883ba6a 100644
--- a/arch/arm/include/asm/fiq_debugger.h
+++ b/arch/arm/include/asm/fiq_debugger.h
@@ -59,10 +59,6 @@ struct fiq_debugger_pdata {
 
 	void (*force_irq)(struct platform_device *pdev, unsigned int irq);
 	void (*force_irq_ack)(struct platform_device *pdev, unsigned int irq);
-
-#ifdef CONFIG_RK_CONSOLE_THREAD
-	void (*console_write)(struct platform_device *pdev, const char *s, unsigned int count);
-#endif
 };
 
 #endif
diff --git a/arch/arm/include/asm/hardware/pl330.h b/arch/arm/include/asm/hardware/pl330.h
index 407d0f9e7fc3..575fa8186ca0 100644
--- a/arch/arm/include/asm/hardware/pl330.h
+++ b/arch/arm/include/asm/hardware/pl330.h
@@ -165,8 +165,6 @@ struct pl330_req {
 	struct pl330_reqcfg *cfg;
 	/* Pointer to first xfer in the request. */
 	struct pl330_xfer *x;
-	unsigned int infiniteloop;
-	unsigned int infiniteloop_sev;
 };
 
 /*
@@ -211,7 +209,7 @@ extern int pl330_add(struct pl330_info *);
 extern void pl330_del(struct pl330_info *pi);
 extern int pl330_update(const struct pl330_info *pi);
 extern void pl330_release_channel(void *ch_id);
-extern void *pl330_request_channel(int id, const struct pl330_info *pi);
+extern void *pl330_request_channel(const struct pl330_info *pi);
 extern int pl330_chan_status(void *ch_id, struct pl330_chanstatus *pstatus);
 extern int pl330_chan_ctrl(void *ch_id, enum pl330_chan_op op);
 extern int pl330_submit_req(void *ch_id, struct pl330_req *r);
diff --git a/arch/arm/include/asm/locks.h b/arch/arm/include/asm/locks.h
index 82df16603b8f..ef4c897772d1 100644
--- a/arch/arm/include/asm/locks.h
+++ b/arch/arm/include/asm/locks.h
@@ -12,7 +12,7 @@
 #ifndef __ASM_PROC_LOCKS_H
 #define __ASM_PROC_LOCKS_H
 
-#if __LINUX_ARM_ARCH__ >= 6 && !defined(CONFIG_CPU_DCACHE_DISABLE)
+#if __LINUX_ARM_ARCH__ >= 6
 
 #define __down_op(ptr,fail)			\
 	({					\
diff --git a/arch/arm/include/asm/mach/map.h b/arch/arm/include/asm/mach/map.h
index 0d96c8c0f6d2..d2fedb5aeb1f 100644
--- a/arch/arm/include/asm/mach/map.h
+++ b/arch/arm/include/asm/mach/map.h
@@ -29,7 +29,6 @@ struct map_desc {
 #define MT_MEMORY_NONCACHED	11
 #define MT_MEMORY_DTCM		12
 #define MT_MEMORY_ITCM		13
-#define MT_DEVICE_STRONGLY_ORDERED	14
 
 #ifdef CONFIG_MMU
 extern void iotable_init(struct map_desc *, int);
diff --git a/arch/arm/include/asm/proc-fns.h b/arch/arm/include/asm/proc-fns.h
index 35c3fc93b88f..8ec535e11fd7 100644
--- a/arch/arm/include/asm/proc-fns.h
+++ b/arch/arm/include/asm/proc-fns.h
@@ -97,22 +97,8 @@ extern void cpu_resume(void);
 
 #ifdef CONFIG_MMU
 
-#ifdef CONFIG_SMP
-
-#define cpu_switch_mm(pgd, mm)	\
-	({							\
-		unsigned long flags;				\
-		local_irq_save(flags);				\
-		cpu_do_switch_mm(virt_to_phys(pgd), mm);	\
-		local_irq_restore(flags);			\
-	})
-
-#else /* SMP */
-
 #define cpu_switch_mm(pgd,mm) cpu_do_switch_mm(virt_to_phys(pgd),mm)
 
-#endif
-
 #define cpu_get_pgd()	\
 	({						\
 		unsigned long pg;			\
diff --git a/arch/arm/include/asm/setup.h b/arch/arm/include/asm/setup.h
index 7f440953bae7..ee2ad8ae07af 100644
--- a/arch/arm/include/asm/setup.h
+++ b/arch/arm/include/asm/setup.h
@@ -16,11 +16,7 @@
 
 #include <linux/types.h>
 
-#if defined(CONFIG_RK_CONFIG)||defined(CONFIG_MACH_RK_FAC)
-#define COMMAND_LINE_SIZE 65536
-#else
 #define COMMAND_LINE_SIZE 1024
-#endif
 
 /* The list ends with an ATAG_NONE node. */
 #define ATAG_NONE	0x00000000
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index bb3bc5beb66d..832888d0c20c 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -269,14 +269,14 @@ static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size
 #ifdef swp_is_buggy
 	unsigned long flags;
 #endif
-#if __LINUX_ARM_ARCH__ >= 6 && !defined(CONFIG_CPU_DCACHE_DISABLE)
+#if __LINUX_ARM_ARCH__ >= 6
 	unsigned int tmp;
 #endif
 
 	smp_mb();
 
 	switch (size) {
-#if __LINUX_ARM_ARCH__ >= 6 && !defined(CONFIG_CPU_DCACHE_DISABLE)
+#if __LINUX_ARM_ARCH__ >= 6
 	case 1:
 		asm volatile("@	__xchg1\n"
 		"1:	ldrexb	%0, [%3]\n"
@@ -346,7 +346,7 @@ void cpu_idle_wait(void);
 
 #include <asm-generic/cmpxchg-local.h>
 
-#if __LINUX_ARM_ARCH__ < 6 || defined(CONFIG_CPU_DCACHE_DISABLE)
+#if __LINUX_ARM_ARCH__ < 6
 /* min ARCH < ARMv6 */
 
 #ifdef CONFIG_SMP
diff --git a/arch/arm/kernel/entry-armv.S b/arch/arm/kernel/entry-armv.S
index 53f63061825b..2cd00764016d 100644
--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -905,7 +905,7 @@ __kuser_cmpxchg:				@ 0xffff0fc0
 	ldmfd	sp!, {r7, pc}
 1:	.word	__ARM_NR_cmpxchg
 
-#elif __LINUX_ARM_ARCH__ < 6 || defined(CONFIG_CPU_DCACHE_DISABLE)
+#elif __LINUX_ARM_ARCH__ < 6
 
 #ifdef CONFIG_MMU
 
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index db5fe89543f6..b2a27b6b0046 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -22,8 +22,7 @@
  * possible here, and this includes saving r0 back into the SVC
  * stack.
  */
-/* ret_fast_syscall: */
-ENTRY(ret_fast_syscall)
+ret_fast_syscall:
  UNWIND(.fnstart	)
  UNWIND(.cantunwind	)
 	disable_irq				@ disable interrupts
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index 453814097c1d..673151c7f54b 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -42,12 +42,7 @@
 	.equ	swapper_pg_dir, KERNEL_RAM_VADDR - 0x4000
 
 	.macro	pgtbl, rd, phys
-#ifdef CONFIG_PLAT_RK
-	add	\rd, \phys, #((TEXT_OFFSET - 0x4000) & 0xffff0000)
-	add	\rd, \rd,   #((TEXT_OFFSET - 0x4000) & 0x0000ffff)
-#else
 	add	\rd, \phys, #TEXT_OFFSET - 0x4000
-#endif
 	.endm
 
 #ifdef CONFIG_XIP_KERNEL
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 65d27efb1a91..c132e8145754 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -279,9 +279,7 @@ void machine_shutdown(void)
 	 * thread that might wind up blocking on
 	 * one of the stopped CPUs.
 	 */
-#ifndef CONFIG_PLAT_RK
 	preempt_disable();
-#endif
 
 	smp_send_stop();
 #endif
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index b75e51c923ff..e895f97ab008 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -310,9 +310,7 @@ asmlinkage void __cpuinit secondary_start_kernel(void)
 
 	notify_cpu_starting(cpu);
 
-#ifndef CONFIG_PLAT_RK
 	calibrate_delay();
-#endif
 
 	smp_store_cpu_info(cpu);
 
@@ -328,6 +326,13 @@ asmlinkage void __cpuinit secondary_start_kernel(void)
 	 */
 	percpu_timer_setup();
 
+	while (!cpu_active(cpu))
+		cpu_relax();
+
+	/*
+	 * cpu_active bit is set, so it's safe to enable interrupts
+	 * now.
+	 */
 	local_irq_enable();
 	local_fiq_enable();
 
diff --git a/arch/arm/kernel/smp_twd.c b/arch/arm/kernel/smp_twd.c
index 9cf875559507..2c277d40cee6 100644
--- a/arch/arm/kernel/smp_twd.c
+++ b/arch/arm/kernel/smp_twd.c
@@ -10,17 +10,13 @@
  */
 #include <linux/init.h>
 #include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/cpufreq.h>
 #include <linux/delay.h>
 #include <linux/device.h>
-#include <linux/err.h>
 #include <linux/smp.h>
 #include <linux/jiffies.h>
 #include <linux/clockchips.h>
 #include <linux/irq.h>
 #include <linux/io.h>
-#include <linux/percpu.h>
 
 #include <asm/smp_twd.h>
 #include <asm/hardware/gic.h>
@@ -28,9 +24,7 @@
 /* set up by the platform code */
 void __iomem *twd_base;
 
-static struct clk *twd_clk;
 static unsigned long twd_timer_rate;
-static DEFINE_PER_CPU(struct clock_event_device *, twd_ce);
 
 static void twd_set_mode(enum clock_event_mode mode,
 			struct clock_event_device *clk)
@@ -86,52 +80,6 @@ int twd_timer_ack(void)
 	return 0;
 }
 
-/*
- * Updates clockevent frequency when the cpu frequency changes.
- * Called on the cpu that is changing frequency with interrupts disabled.
- */
-static void twd_update_frequency(void *data)
-{
-	twd_timer_rate = clk_get_rate(twd_clk);
-
-	clockevents_update_freq(__get_cpu_var(twd_ce), twd_timer_rate);
-}
-
-static int twd_cpufreq_transition(struct notifier_block *nb,
-	unsigned long state, void *data)
-{
-	struct cpufreq_freqs *freqs = data;
-
-	/*
-	 * The twd clock events must be reprogrammed to account for the new
-	 * frequency.  The timer is local to a cpu, so cross-call to the
-	 * changing cpu.
-	 *
-	 * Only wait for it to finish, if the cpu is active to avoid
-	 * deadlock when cpu1 is spinning on while(!cpu_active(cpu1)) during
-	 * booting of that cpu.
-	 */
-	if (state == CPUFREQ_POSTCHANGE || state == CPUFREQ_RESUMECHANGE)
-		smp_call_function_single(freqs->cpu, twd_update_frequency,
-					 NULL, cpu_active(freqs->cpu));
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block twd_cpufreq_nb = {
-	.notifier_call = twd_cpufreq_transition,
-};
-
-static int twd_cpufreq_init(void)
-{
-	if (!IS_ERR_OR_NULL(twd_clk))
-		return cpufreq_register_notifier(&twd_cpufreq_nb,
-			CPUFREQ_TRANSITION_NOTIFIER);
-
-	return 0;
-}
-core_initcall(twd_cpufreq_init);
-
 static void __cpuinit twd_calibrate_rate(void)
 {
 	unsigned long count;
@@ -176,18 +124,7 @@ static void __cpuinit twd_calibrate_rate(void)
  */
 void __cpuinit twd_timer_setup(struct clock_event_device *clk)
 {
-	if (twd_clk == NULL) {
-		twd_clk = clk_get_sys("smp_twd", NULL);
-		if (IS_ERR_OR_NULL(twd_clk))
-			pr_warn("%s: no clock found\n", __func__);
-	}
-
-	if (!IS_ERR_OR_NULL(twd_clk))
-		twd_timer_rate = clk_get_rate(twd_clk);
-	else
-		twd_calibrate_rate();
-
-	__raw_writel(0, twd_base + TWD_TIMER_CONTROL);
+	twd_calibrate_rate();
 
 	clk->name = "local_timer";
 	clk->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |
@@ -195,11 +132,13 @@ void __cpuinit twd_timer_setup(struct clock_event_device *clk)
 	clk->rating = 350;
 	clk->set_mode = twd_set_mode;
 	clk->set_next_event = twd_set_next_event;
-
-	__get_cpu_var(twd_ce) = clk;
-
-	clockevents_config_and_register(clk, twd_timer_rate, 0xf, 0xffffffff);
+	clk->shift = 20;
+	clk->mult = div_sc(twd_timer_rate, NSEC_PER_SEC, clk->shift);
+	clk->max_delta_ns = clockevent_delta2ns(0xffffffff, clk);
+	clk->min_delta_ns = clockevent_delta2ns(0xf, clk);
 
 	/* Make sure our local interrupt controller has this enabled */
 	gic_enable_ppi(clk->irq);
+
+	clockevents_register_device(clk);
 }
diff --git a/arch/arm/kernel/vmlinux.lds.S b/arch/arm/kernel/vmlinux.lds.S
index 1a76c2ef2188..e5287f21badc 100644
--- a/arch/arm/kernel/vmlinux.lds.S
+++ b/arch/arm/kernel/vmlinux.lds.S
@@ -259,57 +259,6 @@ SECTIONS
 		__tcm_end = .;
 	}
 #endif
-#ifdef CONFIG_PLAT_RK
-        /*
-	 * We align everything to a page boundary so we can
-	 * free it after init has commenced and SRAM contents have
-	 * been copied to its destination.
-	 */
-	.sram_start : {
-		. = ALIGN(PAGE_SIZE);
-		__sram_start = .;
-		__sram_code_start = .;
-	}
-
-	.text_sram_code SRAM_CODE_OFFSET : AT(__sram_code_start)
-	{
-		__ssram_code_text = .;
-		*(.sram.text)
-		*(.sram.rodata)
-		. = ALIGN(4);
-		__esram_code_text = .;
-	}
-
-	/*
-	 * Reset the dot pointer, this is needed to create the
-	 * relative __sram_data_start below (to be used as extern in code).
-	 */
-	. = ADDR(.sram_start) + SIZEOF(.sram_start) + SIZEOF(.text_sram_code);
-
-	.sram_data_start : {
-		__sram_data_start = .;
-	}
-
-	/* TODO: add remainder of ITCM as well, that can be used for data! */
-	.data_sram SRAM_CODE_OFFSET + SIZEOF(.text_sram_code) : AT(__sram_data_start)
-	{
-		. = ALIGN(4);
-		__ssram_data = .;
-		*(.sram.data)
-		. = ALIGN(4);
-		__esram_data = .;
-	}
-
-	/* Reset the dot pointer or the linker gets confused */
-	. = ADDR(.sram_data_start) + SIZEOF(.data_sram);
-
-	/* End marker for freeing TCM copy in linked object */
-	.sram_end : AT(ADDR(.sram_data_start) + SIZEOF(.data_sram)){
-		__sram_end = .;
-	}
-
-	. = ALIGN(PAGE_SIZE);
-#endif
 
 	NOTES
 
diff --git a/arch/arm/lib/bitops.h b/arch/arm/lib/bitops.h
index 679c981ee5f0..10d868a5a481 100644
--- a/arch/arm/lib/bitops.h
+++ b/arch/arm/lib/bitops.h
@@ -1,4 +1,4 @@
-#if __LINUX_ARM_ARCH__ >= 6 && !defined(CONFIG_CPU_DCACHE_DISABLE)
+#if __LINUX_ARM_ARCH__ >= 6
 	.macro	bitop, instr
 	ands	ip, r1, #3
 	strneb	r1, [ip]		@ assert word-aligned
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index a4818f129bd2..0074b8dba793 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -721,8 +721,6 @@ config CPU_ICACHE_DISABLE
 config CPU_DCACHE_DISABLE
 	bool "Disable D-Cache (C-bit)"
 	depends on CPU_CP15
-	depends on !SMP && !SWP_EMULATE
-	select GENERIC_ATOMIC64
 	help
 	  Say Y here to disable the processor data cache. Unless
 	  you have a reason not to or are unsure, say N.
@@ -818,23 +816,13 @@ config CACHE_FEROCEON_L2_WRITETHROUGH
 	  Say Y here to use the Feroceon L2 cache in writethrough mode.
 	  Unless you specifically require this, say N for writeback mode.
 
-config MIGHT_HAVE_CACHE_L2X0
-	bool
-	help
-	  This option should be selected by machines which have a L2x0
-	  or PL310 cache controller, but where its use is optional.
-
-	  The only effect of this option is to make CACHE_L2X0 and
-	  related options available to the user for configuration.
-
-	  Boards or SoCs which always require the cache controller
-	  support to be present should select CACHE_L2X0 directly
-	  instead of this option, thus preventing the user from
-	  inadvertently configuring a broken kernel.
-
 config CACHE_L2X0
-	bool "Enable the L2x0 outer cache controller" if MIGHT_HAVE_CACHE_L2X0
-	default MIGHT_HAVE_CACHE_L2X0
+	bool "Enable the L2x0 outer cache controller"
+	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || \
+		   REALVIEW_EB_A9MP || SOC_IMX35 || SOC_IMX31 || MACH_REALVIEW_PBX || \
+		   ARCH_NOMADIK || ARCH_OMAP4 || ARCH_EXYNOS4 || ARCH_TEGRA || \
+		   ARCH_U8500 || ARCH_VEXPRESS_CA9X4 || ARCH_SHMOBILE
+	default y
 	select OUTER_CACHE
 	select OUTER_CACHE_SYNC
 	help
diff --git a/arch/arm/mm/context.c b/arch/arm/mm/context.c
index 131f381712c9..b0ee9ba3cfab 100644
--- a/arch/arm/mm/context.c
+++ b/arch/arm/mm/context.c
@@ -99,7 +99,8 @@ static void reset_context(void *info)
 	set_mm_context(mm, asid);
 
 	/* set the new ASID */
-	cpu_switch_mm(mm->pgd, mm);
+	asm("mcr	p15, 0, %0, c13, c0, 1\n" : : "r" (mm->context.id));
+	isb();
 }
 
 #else
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index fa89cdc64ae2..19d9369bd75c 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -211,12 +211,6 @@ static struct mem_type mem_types[] = {
 		.prot_l1	= PMD_TYPE_TABLE,
 		.prot_sect	= PROT_SECT_DEVICE | PMD_SECT_WB,
 		.domain		= DOMAIN_IO,
-	},
-	[MT_DEVICE_STRONGLY_ORDERED] = {  /* Guaranteed strongly ordered */
-		.prot_pte       = PROT_PTE_DEVICE,
-		.prot_l1        = PMD_TYPE_TABLE,
-		.prot_sect      = PROT_SECT_DEVICE | PMD_SECT_UNCACHED,
-		.domain         = DOMAIN_IO,
 	},	
 	[MT_DEVICE_WC] = {	/* ioremap_wc */
 		.prot_pte	= PROT_PTE_DEVICE | L_PTE_MT_DEV_WC,
@@ -312,10 +306,8 @@ static void __init build_mem_type_table(void)
 			cachepolicy = CPOLICY_WRITEBACK;
 		ecc_mask = 0;
 	}
-#ifndef CONFIG_PLAT_RK
 	if (is_smp())
 		cachepolicy = CPOLICY_WRITEALLOC;
-#endif
 
 	/*
 	 * Strip out features not present on earlier architectures.
@@ -361,7 +353,6 @@ static void __init build_mem_type_table(void)
 			mem_types[MT_DEVICE_NONSHARED].prot_sect |= PMD_SECT_XN;
 			mem_types[MT_DEVICE_CACHED].prot_sect |= PMD_SECT_XN;
 			mem_types[MT_DEVICE_WC].prot_sect |= PMD_SECT_XN;
-			mem_types[MT_DEVICE_STRONGLY_ORDERED].prot_sect |= PMD_SECT_XN;
 		}
 		if (cpu_arch >= CPU_ARCH_ARMv7 && (cr & CR_TRE)) {
 			/*
@@ -736,11 +727,7 @@ void __init iotable_init(struct map_desc *io_desc, int nr)
 		create_mapping(io_desc + i);
 }
 
-#if defined(CONFIG_PLAT_RK)
-static void * __initdata vmalloc_min = (void *)(VMALLOC_END - SZ_512M);
-#else
 static void * __initdata vmalloc_min = (void *)(VMALLOC_END - SZ_128M);
-#endif
 
 /*
  * vmalloc=size forces the vmalloc area to be exactly 'size'
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index 9151e3ad3bf5..21cd29834076 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -355,11 +355,6 @@ __v7_setup:
 	orrlt	r10, r10, #1 << 11		@ set bit #11
 	mcrlt	p15, 0, r10, c15, c0, 1		@ write diagnostic register
 #endif
-#ifdef CONFIG_ARM_ERRATA_761320
-	mrc	p15, 0, r10, c15, c0, 1		@ read diagnostic register
-	orr	r10, r10, #1 << 21		@ set bit #21
-	mcr	p15, 0, r10, c15, c0, 1		@ write diagnostic register
-#endif
 
 3:	mov	r10, #0
 	mcr	p15, 0, r10, c7, c5, 0		@ I+BTB cache invalidate
@@ -372,16 +367,6 @@ __v7_setup:
 	ALT_SMP(orr	r8, r8, #TTB_FLAGS_SMP)
 	ALT_UP(orr	r8, r8, #TTB_FLAGS_UP)
 	mcr	p15, 0, r8, c2, c0, 1		@ load TTB1
-#ifdef CONFIG_ARCH_RK29
-	/* Setup L2 cache */
-	mrc	p15, 1, r5, c9, c0, 2
-	bic	r5, r5, #1 << 29		@ L2 data RAM read multiplexer select: 0 = two cycles
-	bic	r5, r5, #7 << 6
-	bic	r5, r5, #15
-	orr	r5, r5, #2 << 6			@ Tag RAM latency: b010 = 3 cycles
-	orr	r5, r5, #3			@ Data RAM latency: b0011 = 4 cycles
-	mcr	p15, 1, r5, c9, c0, 2
-#endif
 	ldr	r5, =PRRR			@ PRRR
 	ldr	r6, =NMRR			@ NMRR
 	mcr	p15, 0, r5, c10, c2, 0		@ write PRRR
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 5bb762af6c1d..3b3776d0a1a7 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -568,11 +568,8 @@ oratisaes		MACH_ORATISAES		ORATISAES		2924
 smdkv310		MACH_SMDKV310		SMDKV310		2925
 siemens_l0		MACH_SIEMENS_L0		SIEMENS_L0		2926
 ventana			MACH_VENTANA		VENTANA			2927
-#wm8505_7in_netbook	MACH_WM8505_7IN_NETBOOK	WM8505_7IN_NETBOOK	2928
-rk29			MACH_RK29		RK29			2929
-rk2928			ARCH_RK2928		RK2928			2928
-rk30			ARCH_RK30		RK30			3066
-#ec4350sdb		MACH_EC4350SDB		EC4350SDB		2929
+wm8505_7in_netbook	MACH_WM8505_7IN_NETBOOK	WM8505_7IN_NETBOOK	2928
+ec4350sdb		MACH_EC4350SDB		EC4350SDB		2929
 mimas			MACH_MIMAS		MIMAS			2930
 titan			MACH_TITAN		TITAN			2931
 craneboard		MACH_CRANEBOARD		CRANEBOARD		2932
diff --git a/arch/arm/vfp/vfphw.S b/arch/arm/vfp/vfphw.S
index 6e26f5db0cb3..404538ae591d 100644
--- a/arch/arm/vfp/vfphw.S
+++ b/arch/arm/vfp/vfphw.S
@@ -204,25 +204,6 @@ ENTRY(vfp_save_state)
 	mov	pc, lr
 ENDPROC(vfp_save_state)
 
-#ifdef CONFIG_ARCH_RK29
-ENTRY(vfp_load_state)
-	@ Save the current VFP state
-	@ r0 - save location
-	@ r1 - FPEXC
-	DBGSTR1	"save VFP state %p", r0
-	VFPFLDMIA r0, r2		@ save the working registers
-	ldmia   r0, {r1,r2,r3,r12}
-	tst	r1, #FPEXC_EX		@ is there additional state to save?
-	beq	1f
-	tst	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
-	beq	1f
-1:
-	VFPFMXR FPSCR, r2
-	VFPFMXR	FPEXC, r1
-	mov	pc, lr
-ENDPROC(vfp_load_state)
-#endif
-
 	.align
 vfp_current_hw_state_address:
 	.word	vfp_current_hw_state
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index 834341cf9997..192e9dd4c39b 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -11,8 +11,6 @@
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/cpu.h>
-#include <linux/cpu_pm.h>
-#include <linux/hardirq.h>
 #include <linux/kernel.h>
 #include <linux/notifier.h>
 #include <linux/signal.h>
@@ -397,10 +395,7 @@ void VFP_bounce(u32 trigger, u32 fpexc, struct pt_regs *regs)
 
 static void vfp_enable(void *unused)
 {
-	u32 access;
-
-	BUG_ON(preemptible());
-	access = get_copro_access();
+	u32 access = get_copro_access();
 
 	/*
 	 * Enable full access to VFP (cp10 and cp11)
@@ -408,7 +403,9 @@ static void vfp_enable(void *unused)
 	set_copro_access(access | CPACC_FULL(10) | CPACC_FULL(11));
 }
 
-#ifdef CONFIG_CPU_PM
+#ifdef CONFIG_PM
+#include <linux/syscore_ops.h>
+
 static int vfp_pm_suspend(void)
 {
 	struct thread_info *ti = current_thread_info();
@@ -444,33 +441,19 @@ static void vfp_pm_resume(void)
 	fmxr(FPEXC, fmrx(FPEXC) & ~FPEXC_EN);
 }
 
-static int vfp_cpu_pm_notifier(struct notifier_block *self, unsigned long cmd,
-	void *v)
-{
-	switch (cmd) {
-	case CPU_PM_ENTER:
-		vfp_pm_suspend();
-		break;
-	case CPU_PM_ENTER_FAILED:
-	case CPU_PM_EXIT:
-		vfp_pm_resume();
-		break;
-	}
-	return NOTIFY_OK;
-}
-
-static struct notifier_block vfp_cpu_pm_notifier_block = {
-	.notifier_call = vfp_cpu_pm_notifier,
+static struct syscore_ops vfp_pm_syscore_ops = {
+	.suspend	= vfp_pm_suspend,
+	.resume		= vfp_pm_resume,
 };
 
 static void vfp_pm_init(void)
 {
-	cpu_pm_register_notifier(&vfp_cpu_pm_notifier_block);
+	register_syscore_ops(&vfp_pm_syscore_ops);
 }
 
 #else
 static inline void vfp_pm_init(void) { }
-#endif /* CONFIG_CPU_PM */
+#endif /* CONFIG_PM */
 
 void vfp_sync_hwstate(struct thread_info *thread)
 {
@@ -558,7 +541,7 @@ static int __init vfp_init(void)
 	unsigned int cpu_arch = cpu_architecture();
 
 	if (cpu_arch >= CPU_ARCH_ARMv6)
-		on_each_cpu(vfp_enable, NULL, 1);
+		vfp_enable(NULL);
 
 	/*
 	 * First check that there is a VFP that we can use.
@@ -579,6 +562,8 @@ static int __init vfp_init(void)
 	} else {
 		hotcpu_notifier(vfp_hotplug, 0);
 
+		smp_call_function(vfp_enable, NULL, 1);
+
 		VFP_arch = (vfpsid & FPSID_ARCH_MASK) >> FPSID_ARCH_BIT;  /* Extract the architecture version */
 		printk("implementor %02x architecture %d part %02x variant %x rev %x\n",
 			(vfpsid & FPSID_IMPLEMENTER_MASK) >> FPSID_IMPLEMENTER_BIT,
diff --git a/block/blk-core.c b/block/blk-core.c
index 17db3c410518..35ae52df6b6d 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -28,7 +28,6 @@
 #include <linux/task_io_accounting_ops.h>
 #include <linux/fault-inject.h>
 #include <linux/list_sort.h>
-#include <linux/delay.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/block.h>
@@ -348,51 +347,6 @@ void blk_put_queue(struct request_queue *q)
 }
 EXPORT_SYMBOL(blk_put_queue);
 
-static void blk_drain_queue(struct request_queue *q)
-{
-	int i;
-
-	while (true) {
-		bool drain = false;
-
-		spin_lock_irq(q->queue_lock);
-
-		if (q->elevator)
-			elv_drain_elevator(q);
-
-		/*
-		 * This function might be called on a queue which failed
-		 * driver init after queue creation or is not yet fully
-		 * active yet.  Some drivers (e.g. fd and loop) get unhappy
-		 * in such cases.  Kick queue iff dispatch queue has
-		 * something on it and @q has request_fn set.
-		 */
-		if (!list_empty(&q->queue_head) && q->request_fn)
-			__blk_run_queue(q);
-
-		drain |= q->rq.elvpriv;
-//		drain |= q->request_fn_active;
-		/*
-		 * Unfortunately, requests are queued at and tracked from
-		 * multiple places and there's no single counter which can
-		 * be drained.  Check all the queues and counters.
-		 */
-//		drain |= !list_empty(&q->queue_head);
-		for (i = 0; i < 2; i++) {
-			drain |= q->rq.count[i];
-			drain |= q->in_flight[i];
-			drain |= !list_empty(&q->flush_queue[i]);
-		}
-
-		spin_unlock_irq(q->queue_lock);
-
-		if (!drain)
-			break;
-
-		msleep(10);
-	}
-}
-
 /*
  * Note: If a driver supplied the queue lock, it is disconnected
  * by this function. The actual state of the lock doesn't matter
@@ -401,31 +355,22 @@ static void blk_drain_queue(struct request_queue *q)
  */
 void blk_cleanup_queue(struct request_queue *q)
 {
-	spinlock_t *lock = q->queue_lock;
+	/*
+	 * We know we have process context here, so we can be a little
+	 * cautious and ensure that pending block actions on this device
+	 * are done before moving on. Going into this function, we should
+	 * not have processes doing IO to this device.
+	 */
+	blk_sync_queue(q);
 
-	/* mark @q DEAD, no new request or merges will be allowed afterwards */
+	del_timer_sync(&q->backing_dev_info.laptop_mode_wb_timer);
 	mutex_lock(&q->sysfs_lock);
 	queue_flag_set_unlocked(QUEUE_FLAG_DEAD, q);
-
-	spin_lock_irq(lock);
-	queue_flag_set(QUEUE_FLAG_NOMERGES, q);
-	queue_flag_set(QUEUE_FLAG_NOXMERGES, q);
-	queue_flag_set(QUEUE_FLAG_DEAD, q);
+	mutex_unlock(&q->sysfs_lock);
 
 	if (q->queue_lock != &q->__queue_lock)
 		q->queue_lock = &q->__queue_lock;
 
-	spin_unlock_irq(lock);
-	mutex_unlock(&q->sysfs_lock);
-
-	/* drain all requests queued before DEAD marking */
-	blk_drain_queue(q);
-
-	/* @q won't process any more request, flush async actions */
-	del_timer_sync(&q->backing_dev_info.laptop_mode_wb_timer);
-	blk_sync_queue(q);
-
-	/* @q is and will stay empty, shutdown and put */
 	blk_put_queue(q);
 }
 EXPORT_SYMBOL(blk_cleanup_queue);
@@ -731,19 +676,10 @@ static bool blk_rq_should_init_elevator(struct bio *bio)
 	return true;
 }
 
-/**
- * get_request - get a free request
- * @q: request_queue to allocate request from
- * @rw_flags: RW and SYNC flags
- * @bio: bio to allocate request for (can be %NULL)
- * @gfp_mask: allocation mask
- *
- * Get a free request from @q.  This function may fail under memory
- * pressure or if @q is dead.
- *
- * Must be callled with @q->queue_lock held and,
- * Returns %NULL on failure, with @q->queue_lock held.
- * Returns !%NULL on success, with @q->queue_lock *not held*.
+/*
+ * Get a free request, queue_lock must be held.
+ * Returns NULL on failure, with queue_lock held.
+ * Returns !NULL on success, with queue_lock *not held*.
  */
 static struct request *get_request(struct request_queue *q, int rw_flags,
 				   struct bio *bio, gfp_t gfp_mask)
@@ -754,9 +690,6 @@ static struct request *get_request(struct request_queue *q, int rw_flags,
 	const bool is_sync = rw_is_sync(rw_flags) != 0;
 	int may_queue, priv = 0;
 
-	if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))
-		return NULL;
-
 	may_queue = elv_may_queue(q, rw_flags);
 	if (may_queue == ELV_MQUEUE_NO)
 		goto rq_starved;
@@ -849,18 +782,11 @@ static struct request *get_request(struct request_queue *q, int rw_flags,
 	return rq;
 }
 
-/**
- * get_request_wait - get a free request with retry
- * @q: request_queue to allocate request from
- * @rw_flags: RW and SYNC flags
- * @bio: bio to allocate request for (can be %NULL)
- *
- * Get a free request from @q.  This function keeps retrying under memory
- * pressure and fails iff @q is dead.
+/*
+ * No available requests for this queue, wait for some requests to become
+ * available.
  *
- * Must be callled with @q->queue_lock held and,
- * Returns %NULL on failure, with @q->queue_lock held.
- * Returns !%NULL on success, with @q->queue_lock *not held*.
+ * Called with q->queue_lock held, and returns with it unlocked.
  */
 static struct request *get_request_wait(struct request_queue *q, int rw_flags,
 					struct bio *bio)
@@ -874,9 +800,6 @@ static struct request *get_request_wait(struct request_queue *q, int rw_flags,
 		struct io_context *ioc;
 		struct request_list *rl = &q->rq;
 
-		if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))
-			return NULL;
-
 		prepare_to_wait_exclusive(&rl->wait[is_sync], &wait,
 				TASK_UNINTERRUPTIBLE);
 
@@ -907,15 +830,19 @@ struct request *blk_get_request(struct request_queue *q, int rw, gfp_t gfp_mask)
 {
 	struct request *rq;
 
+	if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))
+		return NULL;
+
 	BUG_ON(rw != READ && rw != WRITE);
 
 	spin_lock_irq(q->queue_lock);
-	if (gfp_mask & __GFP_WAIT)
+	if (gfp_mask & __GFP_WAIT) {
 		rq = get_request_wait(q, rw, NULL);
-	else
+	} else {
 		rq = get_request(q, rw, NULL, gfp_mask);
-	if (!rq)
-		spin_unlock_irq(q->queue_lock);
+		if (!rq)
+			spin_unlock_irq(q->queue_lock);
+	}
 	/* q->queue_lock is unlocked at this point */
 
 	return rq;
@@ -1336,10 +1263,6 @@ static int __make_request(struct request_queue *q, struct bio *bio)
 	 * Returns with the queue unlocked.
 	 */
 	req = get_request_wait(q, rw_flags, bio);
-	if (unlikely(!req)) {
-		bio_endio(bio, -ENODEV);	/* @q is dead */
-		goto out_unlock;
-	}
 
 	/*
 	 * After dropping the lock and possibly sleeping here, our request
@@ -1428,9 +1351,14 @@ static int __init setup_fail_make_request(char *str)
 }
 __setup("fail_make_request=", setup_fail_make_request);
 
-static bool should_fail_request(struct hd_struct *part, unsigned int bytes)
+static int should_fail_request(struct bio *bio)
 {
-	return part->make_it_fail && should_fail(&fail_make_request, bytes);
+	struct hd_struct *part = bio->bi_bdev->bd_part;
+
+	if (part_to_disk(part)->part0.make_it_fail || part->make_it_fail)
+		return should_fail(&fail_make_request, bio->bi_size);
+
+	return 0;
 }
 
 static int __init fail_make_request_debugfs(void)
@@ -1443,10 +1371,9 @@ late_initcall(fail_make_request_debugfs);
 
 #else /* CONFIG_FAIL_MAKE_REQUEST */
 
-static inline bool should_fail_request(struct hd_struct *part,
-					unsigned int bytes)
+static inline int should_fail_request(struct bio *bio)
 {
-	return false;
+	return 0;
 }
 
 #endif /* CONFIG_FAIL_MAKE_REQUEST */
@@ -1529,7 +1456,6 @@ static inline void __generic_make_request(struct bio *bio)
 	old_dev = 0;
 	do {
 		char b[BDEVNAME_SIZE];
-		struct hd_struct *part;
 
 		q = bdev_get_queue(bio->bi_bdev);
 		if (unlikely(!q)) {
@@ -1550,10 +1476,10 @@ static inline void __generic_make_request(struct bio *bio)
 			goto end_io;
 		}
 
-		part = bio->bi_bdev->bd_part;
-		if (should_fail_request(part, bio->bi_size) ||
-		    should_fail_request(&part_to_disk(part)->part0,
-					bio->bi_size))
+		if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))
+			goto end_io;
+
+		if (should_fail_request(bio))
 			goto end_io;
 
 		/*
@@ -1768,9 +1694,11 @@ int blk_insert_cloned_request(struct request_queue *q, struct request *rq)
 	if (blk_rq_check_limits(q, rq))
 		return -EIO;
 
-	if (rq->rq_disk &&
-	    should_fail_request(&rq->rq_disk->part0, blk_rq_bytes(rq)))
+#ifdef CONFIG_FAIL_MAKE_REQUEST
+	if (rq->rq_disk && rq->rq_disk->part0.make_it_fail &&
+	    should_fail(&fail_make_request, blk_rq_bytes(rq)))
 		return -EIO;
+#endif
 
 	spin_lock_irqsave(q->queue_lock, flags);
 
@@ -2109,7 +2037,7 @@ bool blk_update_request(struct request *req, int error, unsigned int nr_bytes)
 			error_type = "I/O";
 			break;
 		}
-		printk(KERN_DEBUG "end_request: %s error, dev %s, sector %llu\n",
+		printk(KERN_ERR "end_request: %s error, dev %s, sector %llu\n",
 		       error_type, req->rq_disk ? req->rq_disk->disk_name : "?",
 		       (unsigned long long)blk_rq_pos(req));
 	}
diff --git a/drivers/Kconfig b/drivers/Kconfig
index fd5737ef1600..d0258eb26d8b 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -52,10 +52,6 @@ source "drivers/i2c/Kconfig"
 
 source "drivers/spi/Kconfig"
 
-source "drivers/adc/Kconfig"
-
-source "drivers/headset_observe/Kconfig"
-
 source "drivers/pps/Kconfig"
 
 source "drivers/ptp/Kconfig"
@@ -132,14 +128,4 @@ source "drivers/hwspinlock/Kconfig"
 
 source "drivers/clocksource/Kconfig"
 
-source "drivers/cmmb/Kconfig"
-
-source "drivers/testcode/Kconfig"
-
-source "drivers/smc/Kconfig"
-
-source "drivers/cir/Kconfig"
-
-source "drivers/mtk_wcn_combo/Kconfig"
-
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 9462d48bd26d..4ea4ac9e57af 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -51,7 +51,6 @@ obj-$(CONFIG_ATA)		+= ata/
 obj-$(CONFIG_TARGET_CORE)	+= target/
 obj-$(CONFIG_MTD)		+= mtd/
 obj-$(CONFIG_SPI)		+= spi/
-obj-y				+= headset_observe/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
@@ -78,7 +77,6 @@ obj-$(CONFIG_INPUT)		+= input/
 obj-$(CONFIG_I2O)		+= message/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
 obj-y				+= i2c/ media/
-obj-y				+= adc/
 obj-$(CONFIG_PPS)		+= pps/
 obj-$(CONFIG_PTP_1588_CLOCK)	+= ptp/
 obj-$(CONFIG_W1)		+= w1/
@@ -125,10 +123,3 @@ obj-y				+= ieee802154/
 obj-y				+= clk/
 
 obj-$(CONFIG_HWSPINLOCK)	+= hwspinlock/
-obj-$(CONFIG_CMMB)		+= cmmb/
-obj-$(CONFIG_TEST_CODE)		+= testcode/
-obj-y				+= smc/
-obj-y				+= cir/
-obj-$(CONFIG_ARCH_RK29)		+= dbg/
-obj-$(CONFIG_MTK_COMBO)		+= mtk_wcn_combo/
-obj-$(CONFIG_MT5931_MT6622)     += mtk_wcn_bt/
diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index dd4223b022cd..000e7b2006f8 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -18,8 +18,6 @@
 #include <linux/string.h>
 #include "base.h"
 #include "power/power.h"
-#include "linux/usb.h"
-#include "devices_filter.h"
 
 #define to_bus_attr(_attr) container_of(_attr, struct bus_attribute, attr)
 
@@ -406,20 +404,7 @@ int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,
 	klist_iter_init_node(&bus->p->klist_drivers, &i,
 			     start ? &start->p->knode_bus : NULL);
 	while ((drv = next_driver(&i)) && !error)
-	{
-		if( !strcmp(drv->name, "usb-storage") && data )
-		{
-			struct usb_device *udev = interface_to_usbdev( to_usb_interface( (struct device *)data) );
-			usb_parameter usbp = {udev->descriptor.idVendor, udev->descriptor.idProduct, 
-        	                        udev->manufacturer, udev->product, NULL};
-			if( is_skip_device(&usbp) )
-			{
-				printk("Skip device\n");
-				continue;
-			}
-		}
 		error = fn(drv, data);
-        }
 	klist_iter_exit(&i);
 	return error;
 }
@@ -666,10 +651,7 @@ int bus_add_driver(struct device_driver *drv)
 	if (drv->bus->p->drivers_autoprobe) {
 		error = driver_attach(drv);
 		if (error)
-		{
-			printk(KERN_ERR "driver_attach failed\n");
 			goto out_unregister;
-		}
 	}
 	klist_add_tail(&priv->knode_bus, &bus->p->klist_drivers);
 	module_add_driver(drv->owner, drv);
diff --git a/drivers/base/cpu.c b/drivers/base/cpu.c
index 5775b99ceeaf..251acea3d359 100644
--- a/drivers/base/cpu.c
+++ b/drivers/base/cpu.c
@@ -11,7 +11,6 @@
 #include <linux/device.h>
 #include <linux/node.h>
 #include <linux/gfp.h>
-#include <linux/crc32.h>
 
 #include "base.h"
 
@@ -149,15 +148,6 @@ static ssize_t show_cpus_attr(struct sysdev_class *class,
 	struct cpu_attr *ca = container_of(attr, struct cpu_attr, attr);
 	int n = cpulist_scnprintf(buf, PAGE_SIZE-2, *(ca->map));
 
-#if (defined(CONFIG_ARCH_RK3188) || defined(CONFIG_ARCH_RK319X)) && defined(CONFIG_CRC32)
-	if( !strcmp(attr->attr.name, "present") &&
-	    crc32(0, current->comm, strlen(current->comm))==0xe7b53cc5 )
-	{
-		memcpy(buf, "0-1", 3);
-		n = 3;
-	}
-#endif
-
 	buf[n++] = '\n';
 	buf[n] = '\0';
 	return n;
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 7687c5df8ff3..4282d442d352 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -28,9 +28,6 @@
 #include <linux/async.h>
 #include <linux/suspend.h>
 #include <linux/timer.h>
-#ifdef CONFIG_PLAT_RK
-#include <linux/console.h>
-#endif
 
 #include "../base.h"
 #include "power.h"
@@ -611,9 +608,6 @@ static void dpm_drv_timeout(unsigned long data)
 	printk(KERN_EMERG "**** DPM device timeout: %s (%s)\n", dev_name(dev),
 	       (dev->driver ? dev->driver->name : "no driver"));
 
-#ifdef CONFIG_PLAT_RK
-	resume_console();
-#endif
 	printk(KERN_EMERG "dpm suspend stack:\n");
 	show_stack(tsk, NULL);
 
diff --git a/drivers/base/sync.c b/drivers/base/sync.c
index ec3b0fa3d742..d6913f8e194e 100644
--- a/drivers/base/sync.c
+++ b/drivers/base/sync.c
@@ -15,7 +15,6 @@
  */
 
 #include <linux/debugfs.h>
-#include <linux/export.h>
 #include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
@@ -28,13 +27,8 @@
 
 #include <linux/anon_inodes.h>
 
-#define CREATE_TRACE_POINTS
-#include <trace/events/sync.h>
-
 static void sync_fence_signal_pt(struct sync_pt *pt);
 static int _sync_pt_has_signaled(struct sync_pt *pt);
-static void sync_fence_free(struct kref *kref);
-static void sync_dump(void);
 
 static LIST_HEAD(sync_timeline_list_head);
 static DEFINE_SPINLOCK(sync_timeline_list_lock);
@@ -55,7 +49,6 @@ struct sync_timeline *sync_timeline_create(const struct sync_timeline_ops *ops,
 	if (obj == NULL)
 		return NULL;
 
-	kref_init(&obj->kref);
 	obj->ops = ops;
 	strlcpy(obj->name, name, sizeof(obj->name));
 
@@ -71,12 +64,9 @@ struct sync_timeline *sync_timeline_create(const struct sync_timeline_ops *ops,
 
 	return obj;
 }
-EXPORT_SYMBOL(sync_timeline_create);
 
-static void sync_timeline_free(struct kref *kref)
+static void sync_timeline_free(struct sync_timeline *obj)
 {
-	struct sync_timeline *obj =
-		container_of(kref, struct sync_timeline, kref);
 	unsigned long flags;
 
 	if (obj->ops->release_obj)
@@ -91,17 +81,19 @@ static void sync_timeline_free(struct kref *kref)
 
 void sync_timeline_destroy(struct sync_timeline *obj)
 {
-	obj->destroyed = true;
+	unsigned long flags;
+	bool needs_freeing;
 
-	/*
-	 * If this is not the last reference, signal any children
-	 * that their parent is going away.
-	 */
+	spin_lock_irqsave(&obj->child_list_lock, flags);
+	obj->destroyed = true;
+	needs_freeing = list_empty(&obj->child_list_head);
+	spin_unlock_irqrestore(&obj->child_list_lock, flags);
 
-	if (!kref_put(&obj->kref, sync_timeline_free))
+	if (needs_freeing)
+		sync_timeline_free(obj);
+	else
 		sync_timeline_signal(obj);
 }
-EXPORT_SYMBOL(sync_timeline_destroy);
 
 static void sync_timeline_add_pt(struct sync_timeline *obj, struct sync_pt *pt)
 {
@@ -118,6 +110,7 @@ static void sync_timeline_remove_pt(struct sync_pt *pt)
 {
 	struct sync_timeline *obj = pt->parent;
 	unsigned long flags;
+	bool needs_freeing;
 
 	spin_lock_irqsave(&obj->active_list_lock, flags);
 	if (!list_empty(&pt->active_list))
@@ -125,10 +118,12 @@ static void sync_timeline_remove_pt(struct sync_pt *pt)
 	spin_unlock_irqrestore(&obj->active_list_lock, flags);
 
 	spin_lock_irqsave(&obj->child_list_lock, flags);
-	if (!list_empty(&pt->child_list)) {
-		list_del_init(&pt->child_list);
-	}
+	list_del(&pt->child_list);
+	needs_freeing = obj->destroyed && list_empty(&obj->child_list_head);
 	spin_unlock_irqrestore(&obj->child_list_lock, flags);
+
+	if (needs_freeing)
+		sync_timeline_free(obj);
 }
 
 void sync_timeline_signal(struct sync_timeline *obj)
@@ -137,33 +132,26 @@ void sync_timeline_signal(struct sync_timeline *obj)
 	LIST_HEAD(signaled_pts);
 	struct list_head *pos, *n;
 
-	trace_sync_timeline(obj);
-
 	spin_lock_irqsave(&obj->active_list_lock, flags);
 
 	list_for_each_safe(pos, n, &obj->active_list_head) {
 		struct sync_pt *pt =
 			container_of(pos, struct sync_pt, active_list);
 
-		if (_sync_pt_has_signaled(pt)) {
-			list_del_init(pos);
-			list_add(&pt->signaled_list, &signaled_pts);
-			kref_get(&pt->fence->kref);
-		}
+		if (_sync_pt_has_signaled(pt))
+			list_move(pos, &signaled_pts);
 	}
 
 	spin_unlock_irqrestore(&obj->active_list_lock, flags);
 
 	list_for_each_safe(pos, n, &signaled_pts) {
 		struct sync_pt *pt =
-			container_of(pos, struct sync_pt, signaled_list);
+			container_of(pos, struct sync_pt, active_list);
 
 		list_del_init(pos);
 		sync_fence_signal_pt(pt);
-		kref_put(&pt->fence->kref, sync_fence_free);
 	}
 }
-EXPORT_SYMBOL(sync_timeline_signal);
 
 struct sync_pt *sync_pt_create(struct sync_timeline *parent, int size)
 {
@@ -177,12 +165,10 @@ struct sync_pt *sync_pt_create(struct sync_timeline *parent, int size)
 		return NULL;
 
 	INIT_LIST_HEAD(&pt->active_list);
-	kref_get(&parent->kref);
 	sync_timeline_add_pt(parent, pt);
 
 	return pt;
 }
-EXPORT_SYMBOL(sync_pt_create);
 
 void sync_pt_free(struct sync_pt *pt)
 {
@@ -191,11 +177,8 @@ void sync_pt_free(struct sync_pt *pt)
 
 	sync_timeline_remove_pt(pt);
 
-	kref_put(&pt->parent->kref, sync_timeline_free);
-
 	kfree(pt);
 }
-EXPORT_SYMBOL(sync_pt_free);
 
 /* call with pt->parent->active_list_lock held */
 static int _sync_pt_has_signaled(struct sync_pt *pt)
@@ -264,7 +247,6 @@ static struct sync_fence *sync_fence_alloc(const char *name)
 	if (fence->file == NULL)
 		goto err;
 
-	kref_init(&fence->kref);
 	strlcpy(fence->name, name, sizeof(fence->name));
 
 	INIT_LIST_HEAD(&fence->pt_list_head);
@@ -300,15 +282,8 @@ struct sync_fence *sync_fence_create(const char *name, struct sync_pt *pt)
 	list_add(&pt->pt_list, &fence->pt_list_head);
 	sync_pt_activate(pt);
 
-	/*
-	 * signal the fence in case pt was activated before
-	 * sync_pt_activate(pt) was called
-	 */
-	sync_fence_signal_pt(pt);
-
 	return fence;
 }
-EXPORT_SYMBOL(sync_fence_create);
 
 static int sync_fence_copy_pts(struct sync_fence *dst, struct sync_fence *src)
 {
@@ -324,68 +299,12 @@ static int sync_fence_copy_pts(struct sync_fence *dst, struct sync_fence *src)
 
 		new_pt->fence = dst;
 		list_add(&new_pt->pt_list, &dst->pt_list_head);
+		sync_pt_activate(new_pt);
 	}
 
 	return 0;
 }
 
-static int sync_fence_merge_pts(struct sync_fence *dst, struct sync_fence *src)
-{
-	struct list_head *src_pos, *dst_pos, *n;
-
-	list_for_each(src_pos, &src->pt_list_head) {
-		struct sync_pt *src_pt =
-			container_of(src_pos, struct sync_pt, pt_list);
-		bool collapsed = false;
-
-		list_for_each_safe(dst_pos, n, &dst->pt_list_head) {
-			struct sync_pt *dst_pt =
-				container_of(dst_pos, struct sync_pt, pt_list);
-			/* collapse two sync_pts on the same timeline
-			 * to a single sync_pt that will signal at
-			 * the later of the two
-			 */
-			if (dst_pt->parent == src_pt->parent) {
-				if (dst_pt->parent->ops->compare(dst_pt, src_pt) == -1) {
-					struct sync_pt *new_pt =
-						sync_pt_dup(src_pt);
-					if (new_pt == NULL)
-						return -ENOMEM;
-
-					new_pt->fence = dst;
-					list_replace(&dst_pt->pt_list,
-						     &new_pt->pt_list);
-					sync_pt_free(dst_pt);
-				}
-				collapsed = true;
-				break;
-			}
-		}
-
-		if (!collapsed) {
-			struct sync_pt *new_pt = sync_pt_dup(src_pt);
-
-			if (new_pt == NULL)
-				return -ENOMEM;
-
-			new_pt->fence = dst;
-			list_add(&new_pt->pt_list, &dst->pt_list_head);
-		}
-	}
-
-	return 0;
-}
-
-static void sync_fence_detach_pts(struct sync_fence *fence)
-{
-	struct list_head *pos, *n;
-
-	list_for_each_safe(pos, n, &fence->pt_list_head) {
-		struct sync_pt *pt = container_of(pos, struct sync_pt, pt_list);
-		sync_timeline_remove_pt(pt);
-	}
-}
-
 static void sync_fence_free_pts(struct sync_fence *fence)
 {
 	struct list_head *pos, *n;
@@ -412,19 +331,16 @@ struct sync_fence *sync_fence_fdget(int fd)
 	fput(file);
 	return NULL;
 }
-EXPORT_SYMBOL(sync_fence_fdget);
 
 void sync_fence_put(struct sync_fence *fence)
 {
 	fput(fence->file);
 }
-EXPORT_SYMBOL(sync_fence_put);
 
 void sync_fence_install(struct sync_fence *fence, int fd)
 {
 	fd_install(fd, fence->file);
 }
-EXPORT_SYMBOL(sync_fence_install);
 
 static int sync_fence_get_status(struct sync_fence *fence)
 {
@@ -450,7 +366,6 @@ struct sync_fence *sync_fence_merge(const char *name,
 				    struct sync_fence *a, struct sync_fence *b)
 {
 	struct sync_fence *fence;
-	struct list_head *pos;
 	int err;
 
 	fence = sync_fence_alloc(name);
@@ -461,23 +376,11 @@ struct sync_fence *sync_fence_merge(const char *name,
 	if (err < 0)
 		goto err;
 
-	err = sync_fence_merge_pts(fence, b);
+	err = sync_fence_copy_pts(fence, b);
 	if (err < 0)
 		goto err;
 
-	list_for_each(pos, &fence->pt_list_head) {
-		struct sync_pt *pt =
-			container_of(pos, struct sync_pt, pt_list);
-		sync_pt_activate(pt);
-	}
-
-	/*
-	 * signal the fence in case one of it's pts were activated before
-	 * they were activated
-	 */
-	sync_fence_signal_pt(list_first_entry(&fence->pt_list_head,
-					      struct sync_pt,
-					      pt_list));
+	fence->status = sync_fence_get_status(fence);
 
 	return fence;
 err:
@@ -485,7 +388,6 @@ struct sync_fence *sync_fence_merge(const char *name,
 	kfree(fence);
 	return NULL;
 }
-EXPORT_SYMBOL(sync_fence_merge);
 
 static void sync_fence_signal_pt(struct sync_pt *pt)
 {
@@ -519,22 +421,33 @@ static void sync_fence_signal_pt(struct sync_pt *pt)
 				container_of(pos, struct sync_fence_waiter,
 					     waiter_list);
 
+			waiter->callback(fence, waiter->callback_data);
 			list_del(pos);
-			waiter->callback(fence, waiter);
+			kfree(waiter);
 		}
 		wake_up(&fence->wq);
 	}
 }
 
 int sync_fence_wait_async(struct sync_fence *fence,
-			  struct sync_fence_waiter *waiter)
+			  void (*callback)(struct sync_fence *, void *data),
+			  void *callback_data)
 {
+	struct sync_fence_waiter *waiter;
 	unsigned long flags;
 	int err = 0;
 
+	waiter = kzalloc(sizeof(struct sync_fence_waiter), GFP_KERNEL);
+	if (waiter == NULL)
+		return -ENOMEM;
+
+	waiter->callback = callback;
+	waiter->callback_data = callback_data;
+
 	spin_lock_irqsave(&fence->waiter_list_lock, flags);
 
 	if (fence->status) {
+		kfree(waiter);
 		err = fence->status;
 		goto out;
 	}
@@ -545,120 +458,44 @@ int sync_fence_wait_async(struct sync_fence *fence,
 
 	return err;
 }
-EXPORT_SYMBOL(sync_fence_wait_async);
-
-int sync_fence_cancel_async(struct sync_fence *fence,
-			     struct sync_fence_waiter *waiter)
-{
-	struct list_head *pos;
-	struct list_head *n;
-	unsigned long flags;
-	int ret = -ENOENT;
-
-	spin_lock_irqsave(&fence->waiter_list_lock, flags);
-	/*
-	 * Make sure waiter is still in waiter_list because it is possible for
-	 * the waiter to be removed from the list while the callback is still
-	 * pending.
-	 */
-	list_for_each_safe(pos, n, &fence->waiter_list_head) {
-		struct sync_fence_waiter *list_waiter =
-			container_of(pos, struct sync_fence_waiter,
-				     waiter_list);
-		if (list_waiter == waiter) {
-			list_del(pos);
-			ret = 0;
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&fence->waiter_list_lock, flags);
-	return ret;
-}
-EXPORT_SYMBOL(sync_fence_cancel_async);
-
-static bool sync_fence_check(struct sync_fence *fence)
-{
-	/*
-	 * Make sure that reads to fence->status are ordered with the
-	 * wait queue event triggering
-	 */
-	smp_rmb();
-	return fence->status != 0;
-}
 
 int sync_fence_wait(struct sync_fence *fence, long timeout)
 {
-	int err = 0;
-	struct sync_pt *pt;
-
-	trace_sync_wait(fence, 1);
-	list_for_each_entry(pt, &fence->pt_list_head, pt_list)
-		trace_sync_pt(pt);
+	int err;
 
-	if (timeout > 0) {
+	if (timeout) {
 		timeout = msecs_to_jiffies(timeout);
 		err = wait_event_interruptible_timeout(fence->wq,
-						       sync_fence_check(fence),
+						       fence->status != 0,
 						       timeout);
-	} else if (timeout < 0) {
-		err = wait_event_interruptible(fence->wq,
-					       sync_fence_check(fence));
+	} else {
+		err = wait_event_interruptible(fence->wq, fence->status != 0);
 	}
-	trace_sync_wait(fence, 0);
 
 	if (err < 0)
 		return err;
 
-	if (fence->status < 0) {
-		pr_info("fence error %d on [%p]\n", fence->status, fence);
-		sync_dump();
+	if (fence->status < 0)
 		return fence->status;
-	}
 
-	if (fence->status == 0) {
-		if (timeout > 0) {
-			pr_info("fence timeout on [%p] after %dms\n", fence,
-				jiffies_to_msecs(timeout));
-			sync_dump();
-		}
+	if (fence->status == 0)
 		return -ETIME;
-	}
 
 	return 0;
 }
-EXPORT_SYMBOL(sync_fence_wait);
-
-static void sync_fence_free(struct kref *kref)
-{
-	struct sync_fence *fence = container_of(kref, struct sync_fence, kref);
-
-	sync_fence_free_pts(fence);
-
-	kfree(fence);
-}
 
 static int sync_fence_release(struct inode *inode, struct file *file)
 {
 	struct sync_fence *fence = file->private_data;
 	unsigned long flags;
 
-	/*
-	 * We need to remove all ways to access this fence before droping
-	 * our ref.
-	 *
-	 * start with its membership in the global fence list
-	 */
+	sync_fence_free_pts(fence);
+
 	spin_lock_irqsave(&sync_fence_list_lock, flags);
 	list_del(&fence->sync_fence_list);
 	spin_unlock_irqrestore(&sync_fence_list_lock, flags);
 
-	/*
-	 * remove its pts from their parents so that sync_timeline_signal()
-	 * can't reference the fence.
-	 */
-	sync_fence_detach_pts(fence);
-
-	kref_put(&fence->kref, sync_fence_free);
+	kfree(fence);
 
 	return 0;
 }
@@ -669,12 +506,6 @@ static unsigned int sync_fence_poll(struct file *file, poll_table *wait)
 
 	poll_wait(file, &fence->wq, wait);
 
-	/*
-	 * Make sure that reads to fence->status are ordered with the
-	 * wait queue event triggering
-	 */
-	smp_rmb();
-
 	if (fence->status == 1)
 		return POLLIN;
 	else if (fence->status < 0)
@@ -685,7 +516,7 @@ static unsigned int sync_fence_poll(struct file *file, poll_table *wait)
 
 static long sync_fence_ioctl_wait(struct sync_fence *fence, unsigned long arg)
 {
-	__s32 value;
+	__u32 value;
 
 	if (copy_from_user(&value, (void __user *)arg, sizeof(value)))
 		return -EFAULT;
@@ -700,13 +531,8 @@ static long sync_fence_ioctl_merge(struct sync_fence *fence, unsigned long arg)
 	struct sync_fence *fence2, *fence3;
 	struct sync_merge_data data;
 
-	if (fd < 0)
-		return fd;
-
-	if (copy_from_user(&data, (void __user *)arg, sizeof(data))) {
-		err = -EFAULT;
-		goto err_put_fd;
-	}
+	if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+		return -EFAULT;
 
 	fence2 = sync_fence_fdget(data.fd2);
 	if (fence2 == NULL) {
@@ -864,17 +690,7 @@ static void sync_print_pt(struct seq_file *s, struct sync_pt *pt, bool fence)
 		seq_printf(s, "@%ld.%06ld", tv.tv_sec, tv.tv_usec);
 	}
 
-	if (pt->parent->ops->timeline_value_str &&
-	    pt->parent->ops->pt_value_str) {
-		char value[64];
-		pt->parent->ops->pt_value_str(pt, value, sizeof(value));
-		seq_printf(s, ": %s", value);
-		if (fence) {
-			pt->parent->ops->timeline_value_str(pt->parent, value,
-						    sizeof(value));
-			seq_printf(s, " / %s", value);
-		}
-	} else if (pt->parent->ops->print_pt) {
+	if (pt->parent->ops->print_pt) {
 		seq_printf(s, ": ");
 		pt->parent->ops->print_pt(s, pt);
 	}
@@ -889,11 +705,7 @@ static void sync_print_obj(struct seq_file *s, struct sync_timeline *obj)
 
 	seq_printf(s, "%s %s", obj->name, obj->ops->driver_name);
 
-	if (obj->ops->timeline_value_str) {
-		char value[64];
-		obj->ops->timeline_value_str(obj, value, sizeof(value));
-		seq_printf(s, ": %s", value);
-	} else if (obj->ops->print_obj) {
+	if (obj->ops->print_obj) {
 		seq_printf(s, ": ");
 		obj->ops->print_obj(s, obj);
 	}
@@ -914,8 +726,7 @@ static void sync_print_fence(struct seq_file *s, struct sync_fence *fence)
 	struct list_head *pos;
 	unsigned long flags;
 
-	seq_printf(s, "[%p] %s: %s\n", fence, fence->name,
-		   sync_status_str(fence->status));
+	seq_printf(s, "%s: %s\n", fence->name, sync_status_str(fence->status));
 
 	list_for_each(pos, &fence->pt_list_head) {
 		struct sync_pt *pt =
@@ -929,7 +740,8 @@ static void sync_print_fence(struct seq_file *s, struct sync_fence *fence)
 			container_of(pos, struct sync_fence_waiter,
 				     waiter_list);
 
-		seq_printf(s, "waiter %pF\n", waiter->callback);
+		seq_printf(s, "waiter %pF %p\n", waiter->callback,
+			   waiter->callback_data);
 	}
 	spin_unlock_irqrestore(&fence->waiter_list_lock, flags);
 }
@@ -983,34 +795,7 @@ static __init int sync_debugfs_init(void)
 	debugfs_create_file("sync", S_IRUGO, NULL, NULL, &sync_debugfs_fops);
 	return 0;
 }
-late_initcall(sync_debugfs_init);
 
-#define DUMP_CHUNK 256
-static char sync_dump_buf[64 * 1024];
-void sync_dump(void)
-{
-       struct seq_file s = {
-               .buf = sync_dump_buf,
-               .size = sizeof(sync_dump_buf) - 1,
-       };
-       int i;
-
-       sync_debugfs_show(&s, NULL);
+late_initcall(sync_debugfs_init);
 
-       for (i = 0; i < s.count; i += DUMP_CHUNK) {
-               if ((s.count - i) > DUMP_CHUNK) {
-                       char c = s.buf[i + DUMP_CHUNK];
-                       s.buf[i + DUMP_CHUNK] = 0;
-                       pr_cont("%s", s.buf + i);
-                       s.buf[i + DUMP_CHUNK] = c;
-               } else {
-                       s.buf[s.count] = 0;
-                       pr_cont("%s", s.buf + i);
-               }
-       }
-}
-#else
-static void sync_dump(void)
-{
-}
 #endif
diff --git a/drivers/bluetooth/Kconfig b/drivers/bluetooth/Kconfig
index f35537692a6e..11b41fd40c27 100644
--- a/drivers/bluetooth/Kconfig
+++ b/drivers/bluetooth/Kconfig
@@ -70,16 +70,6 @@ config BT_HCIUART_ATH3K
 
 	  Say Y here to compile support for HCI UART ATH3K protocol.
 
-config BT_HCIUART_RTKH5
-	bool "Realtek H5 protocol support"
-	depends on BT_HCIUART
-	help
-	  Realtek H5 is serial protocol for communication 
-	  between Realtek Bluetooth device and host. This protocol is required for 
-	  Realtek uart h5 bluetooth controller
-
-	  Say Y here to compile support for Realtek HCI H5 protocol.
-
 config BT_HCIUART_LL
 	bool "HCILL protocol support"
 	depends on BT_HCIUART
@@ -217,34 +207,6 @@ config BT_MRVL_SDIO
 	  Say Y here to compile support for Marvell BT-over-SDIO driver
 	  into the kernel or say M to compile it as module.
 
-config BT_HCIBCM4325
-	tristate "HCI BCM4325 UART driver"
-	depends on  BT_HCIUART
-	help
-	  Bluetooth HCI BCM4325 UART driver.
-	  This driver provides the firmware loading mechanism for the Broadcom
-	  Blutonium based devices.
-
-	  Say Y here to compile support for HCI BCM4325 devices into the
-	  kernel or say M to compile it as module (bcm4325).
-
-if BT_HCIBCM4325
-choice
-        prompt "BD_ADDR read from"
-config IDBLOCK
-        bool "NAND ID block"
-config WIFI_MAC
-        bool "WIFI MAC+1"
-endchoice
-endif
-
-config BT_AUTOSLEEP
-	tristate "Bluetooth auto sleep"
-	depends on BT_HCIUART
-	help
-	  If the Bluetooth have no data transfer within three seconds, then 
-          it will automatically go to sleep until the arrival of new data
-
 config BT_ATH3K
 	tristate "Atheros firmware download driver"
 	depends on BT_HCIBTUSB
@@ -267,15 +229,4 @@ config BT_WILINK
 
 	  Say Y here to compile support for Texas Instrument's WiLink7 driver
 	  into the kernel or say M to compile it as module.
-
-if BCM4330
-choice
-        prompt "Select the bluetooth module"
-        default BT_MODULE_NH660
-
-        config BT_MODULE_NH660
-        bool "AzureWave NH660"
-endchoice
-endif
-
 endmenu
diff --git a/drivers/bluetooth/Makefile b/drivers/bluetooth/Makefile
index fd5c3d2959ea..f4460f4f4b78 100644
--- a/drivers/bluetooth/Makefile
+++ b/drivers/bluetooth/Makefile
@@ -2,7 +2,6 @@
 # Makefile for the Linux Bluetooth HCI device drivers.
 #
 
-obj-$(CONFIG_BT)		+= vflash.o
 obj-$(CONFIG_BT_HCIVHCI)	+= hci_vhci.o
 obj-$(CONFIG_BT_HCIUART)	+= hci_uart.o
 obj-$(CONFIG_BT_HCIBCM203X)	+= bcm203x.o
@@ -29,5 +28,4 @@ hci_uart-$(CONFIG_BT_HCIUART_H4)	+= hci_h4.o
 hci_uart-$(CONFIG_BT_HCIUART_BCSP)	+= hci_bcsp.o
 hci_uart-$(CONFIG_BT_HCIUART_LL)	+= hci_ll.o
 hci_uart-$(CONFIG_BT_HCIUART_ATH3K)	+= hci_ath.o
-hci_uart-$(CONFIG_BT_HCIUART_RTKH5) += hci_rtk_h5.o
 hci_uart-objs				:= $(hci_uart-y)
diff --git a/drivers/bluetooth/hci_h4.c b/drivers/bluetooth/hci_h4.c
index 12eb9ee3bcab..2fcd8b387d69 100644
--- a/drivers/bluetooth/hci_h4.c
+++ b/drivers/bluetooth/hci_h4.c
@@ -44,14 +44,6 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
-#if defined(CONFIG_MT5931_MT6622)
-#include "../mtk_wcn_bt/bt_hwctl.h"
-#if 0//def BT_DBG
-#undef BT_DBG
-#define BT_DBG(fmt, arg...) printk(KERN_INFO "%s" fmt "\n", __FUNCTION__, ##arg)
-#endif
-#endif
-
 #include "hci_uart.h"
 
 #define VERSION "1.2"
@@ -61,15 +53,6 @@ struct h4_struct {
 	unsigned long rx_count;
 	struct sk_buff *rx_skb;
 	struct sk_buff_head txq;
-
-#if defined(CONFIG_MT5931_MT6622)
-	/* add for MT6622 */
-	int rxAck;
-	struct timer_list rxTime;
-	unsigned long last_jiffies;
-	unsigned long ulMagic;
-	spinlock_t ack_lock;
-#endif
 };
 
 /* H4 receiver States */
@@ -79,7 +62,6 @@ struct h4_struct {
 #define H4_W4_SCO_HDR		3
 #define H4_W4_DATA		4
 
-
 /* Initialize protocol */
 static int h4_open(struct hci_uart *hu)
 {
@@ -132,54 +114,8 @@ static int h4_close(struct hci_uart *hu)
 static int h4_enqueue(struct hci_uart *hu, struct sk_buff *skb)
 {
 	struct h4_struct *h4 = hu->priv;
-#if defined(CONFIG_MT5931_MT6622)
-	unsigned long lCurrentTime = 0; /* in msec */
-	struct sk_buff *skbMagic = NULL; /* used to store magic skb */
-	unsigned char ucMagic = 0xFF;
-#endif
-	BT_DBG("hu %p skb %p", hu, skb);
-
-#if defined(CONFIG_MT5931_MT6622)
-	if(bt_cb(skb)->pkt_type == 1){
-		unsigned short usOpCode = 0;
-		usOpCode = (((unsigned short)(skb->data[1])) << 8) | 
-                        ((unsigned short)(skb->data[0]));
-
-		BT_DBG("Command 0x%04x\n", (int)usOpCode);
-
-		if(usOpCode == 0xFCC1){
-	        	/* Prepend skb with frame type */
-	        	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
-	        	skb_queue_head(&h4->txq, skb);
-
-	        	/* because controller has waken host. Host assume device is ready to process. */
-	        	clear_bit(1, &h4->ulMagic); /* allow TX to run */
-	        	return 0;
-	        }
-	}
-
-	/* wake up device */
-	lCurrentTime = jiffies_to_msecs(h4->last_jiffies);
-
-	if((jiffies_to_msecs(jiffies) - lCurrentTime) > 4 * 1000){
-		BT_DBG(" h4_enqueue idle more than 4s 0x%08lx 0x%08lx\n", 
-			jiffies, h4->last_jiffies);
-
-		/* Allocate packet */
-		skbMagic = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC); /* only 0xFF is required */
-
-		if (!skbMagic) {
-			BT_ERR("Can't allocate mem for new packet"); /* how to handle? */
-			return 0;
-		}
-		skbMagic->pkt_type = 1;
-		skbMagic->dev = (void *) hu->hdev;
 
-		memcpy(skb_put(skbMagic, 1), &ucMagic, 1);
-		skb_queue_tail(&h4->txq, skbMagic);
-	}
-	h4->last_jiffies = jiffies;
-#endif
+	BT_DBG("hu %p skb %p", hu, skb);
 
 	/* Prepend skb with frame type */
 	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
@@ -204,6 +140,7 @@ static inline int h4_check_data_len(struct h4_struct *h4, int len)
 		h4->rx_count = len;
 		return len;
 	}
+
 	h4->rx_state = H4_W4_PACKET_TYPE;
 	h4->rx_skb   = NULL;
 	h4->rx_count = 0;
@@ -214,7 +151,6 @@ static inline int h4_check_data_len(struct h4_struct *h4, int len)
 /* Recv data */
 static int h4_recv(struct hci_uart *hu, void *data, int count)
 {
-#if !defined(CONFIG_MT5931_MT6622)
 	int ret;
 
 	ret = hci_recv_stream_fragment(hu->hdev, data, count);
@@ -224,172 +160,12 @@ static int h4_recv(struct hci_uart *hu, void *data, int count)
 	}
 
 	return count;
-#else
-	struct h4_struct *h4 = hu->priv;
-	register char *ptr;
-	struct hci_event_hdr *eh;
-	struct hci_acl_hdr   *ah;
-	struct hci_sco_hdr   *sh;
-	register int len, type, dlen;
-	int iDiscard = 0;
-	int while_count = 0;
-
-	BT_DBG("hu %p count %d rx_state %ld rx_count %ld", 
-		hu, count, h4->rx_state, h4->rx_count);
-
-	ptr = data;
-	while (count) {
-		while_count ++;
-
-		if(while_count > 5000){
-			BT_ERR("h4_recv while_count %d\n", while_count);
-		}
-
-		if (h4->rx_count) {
-			len = min_t(unsigned int, h4->rx_count, count);
-			memcpy(skb_put(h4->rx_skb, len), ptr, len);
-			h4->rx_count -= len; count -= len; ptr += len;
-
-			if (h4->rx_count)
-				continue;
-
-			switch (h4->rx_state) {
-			case H4_W4_DATA:
-				iDiscard = 0; /* default not to drop packet */
-				if(HCI_EVENT_PKT == bt_cb(h4->rx_skb)->pkt_type){
-					unsigned short usOpCode = 0;
-
-					eh = hci_event_hdr(h4->rx_skb);
-                   
-					switch(eh->evt){
-					case HCI_EV_CMD_COMPLETE:
-						usOpCode = (((unsigned short)(h4->rx_skb->data[4])) << 8) | 
-							((unsigned short)(h4->rx_skb->data[3]));
-
-						if(usOpCode == 0xFCC0){
-							iDiscard = 1;
-							clear_bit(1, &h4->ulMagic); /* allow TX to run */
-							BT_DBG("recv event 0x%04x\n", (int)usOpCode);
-							/* flag is cleared. we may resume TX. or later? */
-							hci_uart_tx_wakeup(hu);
-						}
-
-						if(usOpCode == 0xFCC1){                        
-							BT_DBG("recv host awake command event 0x%04x\n", (int)usOpCode);
-							//mt_bt_enable_irq();
-						}
-						break;
-					}
-				}
-
-				if(!iDiscard){
-				    hci_recv_frame(h4->rx_skb);
-				}
-				else{ 
-				    kfree_skb(h4->rx_skb);
-				}
-
-				h4->rx_state = H4_W4_PACKET_TYPE;
-				h4->rx_skb = NULL;
-				continue;
-
-			case H4_W4_EVENT_HDR:
-				eh = hci_event_hdr(h4->rx_skb);
-
-				BT_DBG("Event header: evt 0x%2.2x plen %d", eh->evt, eh->plen);
-
-				h4_check_data_len(h4, eh->plen);
-				continue;
-
-			case H4_W4_ACL_HDR:
-				ah = hci_acl_hdr(h4->rx_skb);
-				dlen = __le16_to_cpu(ah->dlen);
-
-				BT_DBG("ACL header: dlen %d", dlen);
-				h4_check_data_len(h4, dlen);
-				continue;
-
-			case H4_W4_SCO_HDR:
-				sh = hci_sco_hdr(h4->rx_skb);
-
-				BT_DBG("SCO header: dlen %d", sh->dlen);
-
-				h4_check_data_len(h4, sh->dlen);
-				continue;
-			}
-		}
-
-		/* H4_W4_PACKET_TYPE */
-		switch (*ptr) {
-		case HCI_EVENT_PKT:
-			BT_DBG("Event packet");
-			h4->rx_state = H4_W4_EVENT_HDR;
-			h4->rx_count = HCI_EVENT_HDR_SIZE;
-			type = HCI_EVENT_PKT;
-			break;
-
-		case HCI_ACLDATA_PKT:
-			BT_DBG("ACL packet");
-			h4->rx_state = H4_W4_ACL_HDR;
-			h4->rx_count = HCI_ACL_HDR_SIZE;
-			type = HCI_ACLDATA_PKT;
-			break;
-
-		case HCI_SCODATA_PKT:
-			BT_DBG("SCO packet");
-			h4->rx_state = H4_W4_SCO_HDR;
-			h4->rx_count = HCI_SCO_HDR_SIZE;
-			type = HCI_SCODATA_PKT;
-			break;
-
-		default:
-			BT_ERR("Unknown HCI packet type %2.2x", (__u8)*ptr);
-			hu->hdev->stat.err_rx++;
-			ptr++; count--;
-			continue;
-		};
-
-		ptr++; count--;
-		/* Allocate packet */
-		h4->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);
-		if (!h4->rx_skb) {
-			BT_ERR("Can't allocate mem for new packet");
-			h4->rx_state = H4_W4_PACKET_TYPE;
-			h4->rx_count = 0;
-			return 0;
-		}
-
-		h4->rx_skb->dev = (void *) hu->hdev;
-		bt_cb(h4->rx_skb)->pkt_type = type;
-	}
-
-	return count;
-#endif
 }
 
 static struct sk_buff *h4_dequeue(struct hci_uart *hu)
 {
 	struct h4_struct *h4 = hu->priv;
-#if !defined(CONFIG_MT5931_MT6622)
 	return skb_dequeue(&h4->txq);
-#else
-	struct sk_buff *skb = NULL;
-
-	if(test_bit(1, &h4->ulMagic)){
-		BT_DBG("magic number is being performed\n");
-		return NULL;
-	}
-
-	skb = skb_dequeue(&h4->txq);
-
-	if(skb){
-		if((skb->pkt_type == 1) && (skb->len == 1) && (skb->data[0] == 0xFF)){
-			BT_DBG("h4_dequeue magic number\n");
-			set_bit(1, &h4->ulMagic);
-		}
-	}
-	return skb;
-#endif
 }
 
 static struct hci_uart_proto h4p = {
diff --git a/drivers/bluetooth/hci_ldisc.c b/drivers/bluetooth/hci_ldisc.c
index 215fd3f8d349..8f3d6dbeb122 100644
--- a/drivers/bluetooth/hci_ldisc.c
+++ b/drivers/bluetooth/hci_ldisc.c
@@ -44,21 +44,10 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
-#if defined(CONFIG_MT5931_MT6622)
-#include <linux/wakelock.h>
-#include "../mtk_wcn_bt/bt_hwctl.h"
-#endif
-
 #include "hci_uart.h"
 
 #define VERSION "2.2"
 
-#if defined(CONFIG_MT5931_MT6622)
-/* Add wake lock mechamism */
-#define WAKE_LOCK_TIMEOUT (5 * HZ)
-static struct wake_lock bt_wake_lock;
-#endif
-
 static int reset = 0;
 
 static struct hci_uart_proto *hup[HCI_UART_MAX_PROTO];
@@ -144,18 +133,7 @@ int hci_uart_tx_wakeup(struct hci_uart *hu)
 
 restart:
 	clear_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);
-#if !defined(CONFIG_MT5931_MT6622)
-/*added by Barry,for broadcom 4325*/
-#ifdef CONFIG_BT_AUTOSLEEP
-#ifdef CONFIG_RFKILL_RK
-    extern int rfkill_rk_sleep_bt(bool bSleep);
-    rfkill_rk_sleep_bt(false);
-#else
-    //extern void bcm4325_sleep(unsigned long bSleep);
-    //bcm4325_sleep(0);
-#endif
-#endif
-#endif
+
 	while ((skb = hci_uart_dequeue(hu))) {
 		int len;
 
@@ -177,11 +155,6 @@ int hci_uart_tx_wakeup(struct hci_uart *hu)
 		goto restart;
 
 	clear_bit(HCI_UART_SENDING, &hu->tx_state);
-
-#if defined(CONFIG_MT5931_MT6622)
-	/* Host can enter sleep after 5s no UART data */
-	wake_lock_timeout(&bt_wake_lock, WAKE_LOCK_TIMEOUT);
-#endif
 	return 0;
 }
 
@@ -195,9 +168,6 @@ static int hci_uart_open(struct hci_dev *hdev)
 
 	set_bit(HCI_RUNNING, &hdev->flags);
 
-#if defined(CONFIG_MT5931_MT6622)
-	mt_bt_enable_irq();
-#endif
 	return 0;
 }
 
@@ -231,9 +201,6 @@ static int hci_uart_close(struct hci_dev *hdev)
 	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
 		return 0;
 
-#if defined(CONFIG_MT5931_MT6622)
-	mt_bt_disable_irq();
-#endif
 	hci_uart_flush(hdev);
 	hdev->flush = NULL;
 	return 0;
@@ -566,9 +533,6 @@ static int __init hci_uart_init(void)
 
 	BT_INFO("HCI UART driver ver %s", VERSION);
 
-#if defined(CONFIG_MT5931_MT6622)
-	wake_lock_init(&bt_wake_lock, WAKE_LOCK_SUSPEND, "bt");
-#endif
 	/* Register the tty discipline */
 
 	memset(&hci_uart_ldisc, 0, sizeof (hci_uart_ldisc));
@@ -599,14 +563,9 @@ static int __init hci_uart_init(void)
 	ll_init();
 #endif
 #ifdef CONFIG_BT_HCIUART_ATH3K
-       ath_init();
+	ath_init();
 #endif
-//Realtek_add_start	
-//add realtek h5 support	
-#ifdef CONFIG_BT_HCIUART_RTKH5
-	h5_init();
-#endif
-//Realtek_add_end	
+
 	return 0;
 }
 
@@ -627,17 +586,9 @@ static void __exit hci_uart_exit(void)
 	ath_deinit();
 #endif
 
-#ifdef CONFIG_BT_HCIUART_RTKH5
-	h5_deinit();
-#endif
-
 	/* Release tty registration of line discipline */
 	if ((err = tty_unregister_ldisc(N_HCI)))
 		BT_ERR("Can't unregister HCI line discipline (%d)", err);
-
-#if defined(CONFIG_MT5931_MT6622)
-	wake_lock_destroy(&bt_wake_lock);
-#endif
 }
 
 module_init(hci_uart_init);
diff --git a/drivers/bluetooth/hci_uart.h b/drivers/bluetooth/hci_uart.h
index 3bf515ffc05e..99fb35239d1f 100644
--- a/drivers/bluetooth/hci_uart.h
+++ b/drivers/bluetooth/hci_uart.h
@@ -102,10 +102,3 @@ int ll_deinit(void);
 int ath_init(void);
 int ath_deinit(void);
 #endif
-
-//Realtek_add_start
-#ifdef CONFIG_BT_HCIUART_RTKH5
-int h5_init(void);
-int h5_deinit(void);
-#endif
-//Realtek_add_end
diff --git a/drivers/cpufreq/cpufreq_interactive.c b/drivers/cpufreq/cpufreq_interactive.c
index fa55603a0a95..7d1952c5cb16 100644
--- a/drivers/cpufreq/cpufreq_interactive.c
+++ b/drivers/cpufreq/cpufreq_interactive.c
@@ -300,10 +300,6 @@ static void cpufreq_interactive_timer(unsigned long data)
 	cpu_load = loadadjfreq / pcpu->target_freq;
 	boosted = boost_val || now < boostpulse_endtime;
 
-#ifdef CONFIG_PLAT_RK
-	pcpu->target_freq = pcpu->policy->cur;
-#endif
-
 	if (cpu_load >= go_hispeed_load || boosted) {
 		if (pcpu->target_freq < hispeed_freq) {
 			new_freq = hispeed_freq;
@@ -923,25 +919,7 @@ static int cpufreq_governor_interactive(struct cpufreq_policy *policy,
 		freq_table =
 			cpufreq_frequency_get_table(policy->cpu);
 		if (!hispeed_freq)
-#ifdef CONFIG_PLAT_RK
-		{
-			unsigned int index;
 			hispeed_freq = policy->max;
-			if (policy->min < 816000)
-				hispeed_freq = 816000;
-			else if (cpufreq_frequency_table_target(policy, freq_table, policy->min + 1, CPUFREQ_RELATION_L, &index) == 0)
-				hispeed_freq = freq_table[index].frequency;
-			if (policy->max > 1416000) {
-				timer_slack_val = 20000;
-				min_sample_time = 40000;
-				above_hispeed_delay_val = 80000;
-				store_target_loads(NULL, NULL, "70 1200000:80 1416000:99", 0);
-			}
-			boostpulse_duration_val = 500000;
-		}
-#else
-			hispeed_freq = policy->max;
-#endif
 
 		for_each_cpu(j, policy->cpus) {
 			unsigned long expires;
diff --git a/drivers/cpufreq/cpufreq_ondemand.c b/drivers/cpufreq/cpufreq_ondemand.c
index ce0b7a41f73c..891360edecdd 100644
--- a/drivers/cpufreq/cpufreq_ondemand.c
+++ b/drivers/cpufreq/cpufreq_ondemand.c
@@ -32,13 +32,8 @@
 #define DEF_FREQUENCY_UP_THRESHOLD		(80)
 #define DEF_SAMPLING_DOWN_FACTOR		(1)
 #define MAX_SAMPLING_DOWN_FACTOR		(100000)
-#ifdef CONFIG_ARCH_RK29
-#define MICRO_FREQUENCY_DOWN_DIFFERENTIAL	(10)
-#define MICRO_FREQUENCY_UP_THRESHOLD		(80)
-#else
 #define MICRO_FREQUENCY_DOWN_DIFFERENTIAL	(3)
 #define MICRO_FREQUENCY_UP_THRESHOLD		(95)
-#endif
 #define MICRO_FREQUENCY_MIN_SAMPLE_RATE		(10000)
 #define MIN_FREQUENCY_UP_THRESHOLD		(11)
 #define MAX_FREQUENCY_UP_THRESHOLD		(100)
diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 5ab2cc9c6c6b..c315ec9d5686 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -159,10 +159,6 @@ static struct attribute_group stats_attr_group = {
 static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 {
 	int index;
-#ifdef CONFIG_PLAT_RK
-	if (!stat->freq_table)
-		return -1;
-#endif
 	for (index = 0; index < stat->max_state; index++)
 		if (stat->freq_table[index] == freq)
 			return index;
@@ -219,9 +215,7 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 		goto error_out;
 
 	stat->cpu = cpu;
-#ifndef CONFIG_PLAT_RK
 	per_cpu(cpufreq_stats_table, cpu) = stat;
-#endif
 
 	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
 		unsigned int freq = table[i].frequency;
@@ -259,9 +253,6 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	stat->last_time = get_jiffies_64();
 	stat->last_index = freq_table_get_index(stat, policy->cur);
 	spin_unlock(&cpufreq_stats_lock);
-#ifdef CONFIG_PLAT_RK
-	per_cpu(cpufreq_stats_table, cpu) = stat;
-#endif
 	cpufreq_cpu_put(data);
 	return 0;
 error_out:
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index dadd65efd04e..80ccce9f6721 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -261,12 +261,6 @@ config GPIO_TC3589X
 	  This enables support for the GPIOs found on the TC3589X
 	  I/O Expander.
 
-config GPIO_TPS65912
-	tristate "TI TPS65912 GPIO"
-	depends on (MFD_TPS65912_I2C || MFD_TPS65912_SPI)
-	help
-	  This driver supports TPS65912 gpio chip
-
 config GPIO_TWL4030
 	tristate "TWL4030, TWL5030, and TPS659x0 GPIOs"
 	depends on TWL4030_CORE
@@ -438,45 +432,6 @@ config GPIO_UCB1400
 	  To compile this driver as a module, choose M here: the
 	  module will be called ucb1400_gpio.
 
-config GPIO_PCA9554
-	bool "GPIO EXPANDER PCA9554"
-	depends on I2C
-	help
-	  Say yes here to access the PCA9554 GPIO EXPANDER
-
-config IOEXTEND_TCA6424
- 	bool "ROCKCHIP TCA6424 CONTROL"
-	depends on I2C
-	help
-	  Say yes here to access the TCA6424 GPIO EXPANDER
-
-config EXPANDED_GPIO_NUM  
-	int "setting the amount of expanded gpios"
-	help
-	  for tca6424, set 24
-	
-config EXPANDED_GPIO_IRQ_NUM
-	int "setting the amount of expanded gpio irqs"
-	help
-	  for tca6424, set 24	
-
-config EXPAND_GPIO_SOFT_INTERRUPT
-	bool "soft interrupt for expand gpio use"
-	help
-	  if you want expand gpio support interrupt,choose it
-
-config SPI_FPGA_GPIO_NUM  
-	default 96
-	int "setting the amount of fpga gpios"
-	help
-	  for fpga, set 96,no used ,set 0
-	
-config SPI_FPGA_GPIO_IRQ_NUM
-	default 16
-	int "setting the amount of fpga gpio irqs"
-	help
-	  for fpga, set 16,no used ,set 0	
-
 comment "MODULbus GPIO expanders:"
 
 config GPIO_JANZ_TTL
@@ -499,10 +454,4 @@ config GPIO_TPS65910
 	help
 	  Select this option to enable GPIO driver for the TPS65910
 	  chip family.
-config GPIO_RT5025
-	bool "Richtek RT5025 GPIO support"
-	depends on MFD_RT5025
-	default n
-	help
-	  This is the gpio driver for RT5025 PMIC.
 endif
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index a3a3515f5c4a..b605f8ec6fbe 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -36,26 +36,15 @@ obj-$(CONFIG_GPIO_BT8XX)	+= bt8xxgpio.o
 obj-$(CONFIG_GPIO_IT8761E)	+= it8761e_gpio.o
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_WM831X)	+= wm831x-gpio.o
-obj-$(CONFIG_GPIO_PCA9554)	+= pca9554.o
-obj-$(CONFIG_IOEXTEND_TCA6424)	+= tca6424.o
-obj-$(CONFIG_EXPAND_GPIO_SOFT_INTERRUPT) += expand_gpio_soft_interrupt.o
 obj-$(CONFIG_GPIO_WM8350)	+= wm8350-gpiolib.o
 obj-$(CONFIG_GPIO_WM8994)	+= wm8994-gpio.o
 obj-$(CONFIG_GPIO_SCH)		+= sch_gpio.o
 obj-$(CONFIG_MACH_U300)		+= gpio-u300.o
 obj-$(CONFIG_PLAT_NOMADIK)	+= gpio-nomadik.o
 obj-$(CONFIG_GPIO_RDC321X)	+= rdc321x-gpio.o
-obj-$(CONFIG_ARCH_RK29)		+= gpio-rk29.o
-obj-$(CONFIG_ARCH_RK2928)	+= gpio-rk30.o
-obj-$(CONFIG_ARCH_RK30)		+= gpio-rk30.o
-obj-$(CONFIG_ARCH_RK3188)	+= gpio-rk30.o
-obj-$(CONFIG_ARCH_RK3026)	+= gpio-rk30.o
-obj-$(CONFIG_ARCH_RK319X)	+= gpio-rk30.o
 obj-$(CONFIG_GPIO_JANZ_TTL)	+= janz-ttl.o
 obj-$(CONFIG_GPIO_SX150X)	+= sx150x.o
 obj-$(CONFIG_GPIO_VX855)	+= vx855_gpio.o
 obj-$(CONFIG_GPIO_ML_IOH)	+= ml_ioh_gpio.o
 obj-$(CONFIG_AB8500_GPIO)       += ab8500-gpio.o
-obj-$(CONFIG_GPIO_TPS65910)	+= gpio-tps65910.o
-obj-$(CONFIG_GPIO_TPS65912)	+= gpio-tps65912.o
-obj-$(CONFIG_GPIO_RT5025)	+= rt5025-gpio.o
+obj-$(CONFIG_GPIO_TPS65910)	+= tps65910-gpio.o
diff --git a/drivers/gpio/gpio-tps65910.c b/drivers/gpio/gpio-tps65910.c
deleted file mode 100644
index 7eef648a3351..000000000000
--- a/drivers/gpio/gpio-tps65910.c
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * TI TPS6591x GPIO driver
- *
- * Copyright 2010 Texas Instruments Inc.
- *
- * Author: Graeme Gregory <gg@slimlogic.co.uk>
- * Author: Jorge Eduardo Candelaria jedu@slimlogic.co.uk>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under  the terms of the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the License, or (at your
- *  option) any later version.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/errno.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/mfd/tps65910.h>
-
-static int tps65910_gpio_get(struct gpio_chip *gc, unsigned offset)
-{
-	struct tps65910 *tps65910 = container_of(gc, struct tps65910, gpio);
-	uint8_t val;
-
-	tps65910->read(tps65910, TPS65910_GPIO0 + offset, 1, &val);
-
-	if (val & GPIO_STS_MASK)
-		return 1;
-
-	return 0;
-}
-
-static void tps65910_gpio_set(struct gpio_chip *gc, unsigned offset,
-			      int value)
-{
-	struct tps65910 *tps65910 = container_of(gc, struct tps65910, gpio);
-
-	if (value)
-		tps65910_set_bits(tps65910, TPS65910_GPIO0 + offset,
-						GPIO_SET_MASK);
-	else
-		tps65910_clear_bits(tps65910, TPS65910_GPIO0 + offset,
-						GPIO_SET_MASK);
-}
-
-static int tps65910_gpio_output(struct gpio_chip *gc, unsigned offset,
-				int value)
-{
-	struct tps65910 *tps65910 = container_of(gc, struct tps65910, gpio);
-
-	/* Set the initial value */
-	tps65910_gpio_set(gc, offset, value);
-
-	return tps65910_set_bits(tps65910, TPS65910_GPIO0 + offset,
-						GPIO_CFG_MASK);
-}
-
-static int tps65910_gpio_input(struct gpio_chip *gc, unsigned offset)
-{
-	struct tps65910 *tps65910 = container_of(gc, struct tps65910, gpio);
-
-	return tps65910_clear_bits(tps65910, TPS65910_GPIO0 + offset,
-						GPIO_CFG_MASK);
-}
-
-void tps65910_gpio_init(struct tps65910 *tps65910, int gpio_base)
-{
-	int ret;
-	struct tps65910_board *board_data;
-
-	if (!gpio_base)
-		return;
-
-	tps65910->gpio.owner		= THIS_MODULE;
-	tps65910->gpio.label		= tps65910->i2c_client->name;
-	tps65910->gpio.dev		= tps65910->dev;
-	tps65910->gpio.base		= gpio_base;
-
-	switch(tps65910_chip_id(tps65910)) {
-	case TPS65910:
-		tps65910->gpio.ngpio	= TPS65910_NUM_GPIO;
-		break;
-	case TPS65911:
-		tps65910->gpio.ngpio	= TPS65911_NUM_GPIO;
-		break;
-	default:
-		return;
-	}
-	tps65910->gpio.can_sleep	= 1;
-
-	tps65910->gpio.direction_input	= tps65910_gpio_input;
-	tps65910->gpio.direction_output	= tps65910_gpio_output;
-	tps65910->gpio.set		= tps65910_gpio_set;
-	tps65910->gpio.get		= tps65910_gpio_get;
-
-	/* Configure sleep control for gpios */
-	board_data = dev_get_platdata(tps65910->dev);
-	if (board_data) {
-		int i;
-		for (i = 0; i < tps65910->gpio.ngpio; ++i) {
-			if (board_data->en_gpio_sleep[i]) {
-				ret = tps65910_set_bits(tps65910,
-					TPS65910_GPIO0 + i, GPIO_SLEEP_MASK);
-				if (ret < 0)
-					dev_warn(tps65910->dev,
-						"GPIO Sleep setting failed\n");
-			}
-		}
-	}
-
-	ret = gpiochip_add(&tps65910->gpio);
-
-	if (ret)
-		dev_warn(tps65910->dev, "GPIO registration failed: %d\n", ret);
-}
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 482dec010e53..a971e3d043ba 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -1225,7 +1225,7 @@ int gpio_request(unsigned gpio, const char *label)
 	spin_unlock_irqrestore(&gpio_lock, flags);
 	return status;
 }
-EXPORT_SYMBOL(gpio_request);//EXPORT_SYMBOL_GPL(gpio_request);
+EXPORT_SYMBOL_GPL(gpio_request);
 
 void gpio_free(unsigned gpio)
 {
@@ -1262,9 +1262,7 @@ void gpio_free(unsigned gpio)
 
 	spin_unlock_irqrestore(&gpio_lock, flags);
 }
-//EXPORT_SYMBOL_GPL(gpio_free);
-EXPORT_SYMBOL(gpio_free);
-
+EXPORT_SYMBOL_GPL(gpio_free);
 
 /**
  * gpio_request_one - request a single GPIO with initial configuration
@@ -1420,9 +1418,7 @@ int gpio_direction_input(unsigned gpio)
 			__func__, gpio, status);
 	return status;
 }
-//EXPORT_SYMBOL_GPL(gpio_direction_input);
-EXPORT_SYMBOL(gpio_direction_input);
-
+EXPORT_SYMBOL_GPL(gpio_direction_input);
 
 int gpio_direction_output(unsigned gpio, int value)
 {
@@ -1433,8 +1429,6 @@ int gpio_direction_output(unsigned gpio, int value)
 
 	spin_lock_irqsave(&gpio_lock, flags);
 
-	if (value !=0 && value !=1)
-		goto fail;
 	if (!gpio_is_valid(gpio))
 		goto fail;
 	chip = desc->chip;
@@ -1479,68 +1473,7 @@ int gpio_direction_output(unsigned gpio, int value)
 			__func__, gpio, status);
 	return status;
 }
-//EXPORT_SYMBOL_GPL(gpio_direction_output);
-EXPORT_SYMBOL(gpio_direction_output);
-
-/* 
-gpio pull up or pull down
-value = 0, normal
-value = 1, pull up
-value = 2, pull down
-*/
-int gpio_pull_updown(unsigned gpio, unsigned value)
-{
-	unsigned long		flags;
-	struct gpio_chip	*chip;
-	struct gpio_desc	*desc = &gpio_desc[gpio];
-	int			status = -EINVAL;
-
-	spin_lock_irqsave(&gpio_lock, flags);
-	
-	if (value >3)
-		goto fail;
-	if (!gpio_is_valid(gpio))
-		goto fail;
-	chip = desc->chip;
-	if (!chip || !chip->get || !chip->pull_updown)
-		goto fail;
-	gpio -= chip->base;
-	if (gpio >= chip->ngpio)
-		goto fail;
-	status = gpio_ensure_requested(desc, gpio);
-	if (status < 0)
-		goto fail;
-
-	/* now we know the gpio is valid and chip won't vanish */
-
-	spin_unlock_irqrestore(&gpio_lock, flags);
-
-	might_sleep_if(extra_checks && chip->can_sleep);
-
-	if (status) {
-		status = chip->request(chip, gpio);
-		if (status < 0) {
-			pr_debug("GPIO-%d: chip request fail, %d\n",
-				chip->base + gpio, status);
-			/* and it's not available to anyone else ...
-			 * gpio_request() is the fully clean solution.
-			 */
-			goto lose;
-		}
-	}
-	status = chip->pull_updown(chip, gpio,value);
-	
-lose:
-	return status;
-fail:
-	spin_unlock_irqrestore(&gpio_lock, flags);
-	if (status)
-		pr_debug("%s: gpio-%d status %d\n",
-			__func__, gpio, status);
-	return status;
-}
-//EXPORT_SYMBOL_GPL(gpio_pull_updown);
-EXPORT_SYMBOL(gpio_pull_updown);
+EXPORT_SYMBOL_GPL(gpio_direction_output);
 
 /**
  * gpio_set_debounce - sets @debounce time for a @gpio
@@ -1622,17 +1555,13 @@ int __gpio_get_value(unsigned gpio)
 	struct gpio_chip	*chip;
 	int value;
 
-	if (!gpio_is_valid(gpio))
-		return -1;
 	chip = gpio_to_chip(gpio);
 	WARN_ON(chip->can_sleep);
 	value = chip->get ? chip->get(chip, gpio - chip->base) : 0;
 	trace_gpio_value(gpio, 1, value);
 	return value;
 }
-//EXPORT_SYMBOL_GPL(__gpio_get_value);
-EXPORT_SYMBOL(__gpio_get_value);
-
+EXPORT_SYMBOL_GPL(__gpio_get_value);
 
 /**
  * __gpio_set_value() - assign a gpio's value
@@ -1647,17 +1576,12 @@ void __gpio_set_value(unsigned gpio, int value)
 {
 	struct gpio_chip	*chip;
 
-	if(value !=0 && value !=1)
-		return;
-	if (!gpio_is_valid(gpio))
-		 return;
 	chip = gpio_to_chip(gpio);
 	WARN_ON(chip->can_sleep);
 	trace_gpio_value(gpio, 0, value);
 	chip->set(chip, gpio - chip->base, value);
 }
-//EXPORT_SYMBOL_GPL(__gpio_set_value);
-EXPORT_SYMBOL(__gpio_set_value);
+EXPORT_SYMBOL_GPL(__gpio_set_value);
 
 /**
  * __gpio_cansleep() - report whether gpio value access will sleep
@@ -1690,13 +1614,9 @@ EXPORT_SYMBOL_GPL(__gpio_cansleep);
 int __gpio_to_irq(unsigned gpio)
 {
 	struct gpio_chip	*chip;
-	
-	if (!gpio_is_valid(gpio))
-		 return -1;
-	
+
 	chip = gpio_to_chip(gpio);
-	
-	return chip->to_irq ? chip->to_irq(chip, gpio - chip->base) : -1;
+	return chip->to_irq ? chip->to_irq(chip, gpio - chip->base) : -ENXIO;
 }
 EXPORT_SYMBOL_GPL(__gpio_to_irq);
 
diff --git a/drivers/gpio/wm831x-gpio.c b/drivers/gpio/wm831x-gpio.c
index 0aadbb63c359..2bcfb0be09ff 100644
--- a/drivers/gpio/wm831x-gpio.c
+++ b/drivers/gpio/wm831x-gpio.c
@@ -35,22 +35,6 @@ static inline struct wm831x_gpio *to_wm831x_gpio(struct gpio_chip *chip)
 	return container_of(chip, struct wm831x_gpio, gpio_chip);
 }
 
-static int wm831x_gpio_pull_up_down(struct gpio_chip *chip, unsigned offset, unsigned value)
-{
-	struct wm831x_gpio *wm831x_gpio = to_wm831x_gpio(chip);
-	struct wm831x *wm831x = wm831x_gpio->wm831x;
-
-	if(value == GPIOPullUp)
-		value = WM831X_GPIO_PULL_UP;
-	else if(value == GPIOPullDown)
-		value = WM831X_GPIO_PULL_DOWN;
-	else if(value == GPIONormal)
-		value = WM831X_GPIO_PULL_NONE;
-	//printk("wm831x_gpio_pull_up_down=%x,%x\n",WM831X_GPIO1_CONTROL + offset,value);
-	return wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + offset, 
-		WM831X_GPN_PULL_MASK, value);
-}
-
 static int wm831x_gpio_direction_in(struct gpio_chip *chip, unsigned offset)
 {
 	struct wm831x_gpio *wm831x_gpio = to_wm831x_gpio(chip);
@@ -59,7 +43,7 @@ static int wm831x_gpio_direction_in(struct gpio_chip *chip, unsigned offset)
 
 	if (wm831x->has_gpio_ena)
 		val |= WM831X_GPN_TRI;
-	//printk("wm831x_gpio_direction_in=%x,%x\n",WM831X_GPIO1_CONTROL + offset,val);
+
 	return wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + offset,
 			       WM831X_GPN_DIR | WM831X_GPN_TRI |
 			       WM831X_GPN_FN_MASK, val);
@@ -70,19 +54,15 @@ static int wm831x_gpio_get(struct gpio_chip *chip, unsigned offset)
 	struct wm831x_gpio *wm831x_gpio = to_wm831x_gpio(chip);
 	struct wm831x *wm831x = wm831x_gpio->wm831x;
 	int ret;
-	int gpn_pol;
-	
-	ret = wm831x_reg_read(wm831x, WM831X_GPIO1_CONTROL + offset);
-	if (ret < 0)
-		return ret;
-	gpn_pol = (ret & WM831X_GPN_POL_MASK) >> WM831X_GPN_POL_SHIFT;
-	
+
 	ret = wm831x_reg_read(wm831x, WM831X_GPIO_LEVEL);
-	//printk("wm831x_gpio_get=%x,%d,%d\n",ret,offset,gpn_pol);
 	if (ret < 0)
 		return ret;
-	
-	return !((ret>>offset)^gpn_pol);
+
+	if (ret & 1 << offset)
+		return 1;
+	else
+		return 0;
 }
 
 static void wm831x_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
@@ -104,10 +84,10 @@ static int wm831x_gpio_direction_out(struct gpio_chip *chip,
 
 	if (wm831x->has_gpio_ena)
 		val |= WM831X_GPN_TRI;
-	//printk("wm831x_gpio_direction_out=%x,%x\n",WM831X_GPIO1_CONTROL + offset,val);
+
 	ret = wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + offset,
 			      WM831X_GPN_DIR | WM831X_GPN_TRI |
-			      WM831X_GPN_FN_MASK | WM831X_GPN_POL_MASK, val|WM831X_GPN_POL);
+			      WM831X_GPN_FN_MASK, val);
 	if (ret < 0)
 		return ret;
 
@@ -155,7 +135,7 @@ static int wm831x_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
 		fn = 1;
 	else
 		return -EINVAL;
-	//printk("wm831x_gpio_set_debounce=%x,%x\n",WM831X_GPIO1_CONTROL + offset,fn);
+
 	return wm831x_set_bits(wm831x, reg, WM831X_GPN_FN_MASK, fn);
 }
 
@@ -259,7 +239,6 @@ static struct gpio_chip template_chip = {
 	.get			= wm831x_gpio_get,
 	.direction_output	= wm831x_gpio_direction_out,
 	.set			= wm831x_gpio_set,
-	.pull_updown    = wm831x_gpio_pull_up_down,
 	.to_irq			= wm831x_gpio_to_irq,
 	.set_debounce		= wm831x_gpio_set_debounce,
 	.dbg_show		= wm831x_gpio_dbg_show,
@@ -272,11 +251,11 @@ static int __devinit wm831x_gpio_probe(struct platform_device *pdev)
 	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
 	struct wm831x_gpio *wm831x_gpio;
 	int ret;
-	printk("%s\n",__FUNCTION__);
+
 	wm831x_gpio = kzalloc(sizeof(*wm831x_gpio), GFP_KERNEL);
 	if (wm831x_gpio == NULL)
 		return -ENOMEM;
-	
+
 	wm831x_gpio->wm831x = wm831x;
 	wm831x_gpio->gpio_chip = template_chip;
 	wm831x_gpio->gpio_chip.ngpio = wm831x->num_gpio;
@@ -293,17 +272,6 @@ static int __devinit wm831x_gpio_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-#ifdef CONFIG_PLAT_RK
-	if (pdata && pdata->pin_type_init) {
-		ret = pdata->pin_type_init(wm831x);
-		if (ret != 0) {
-			dev_err(wm831x->dev, "pin_type_init() failed: %d\n", ret);
-			WARN_ON(gpiochip_remove(&wm831x_gpio->gpio_chip));
-			goto err;
-		}
-	}
-#endif
-
 	platform_set_drvdata(pdev, wm831x_gpio);
 
 	return ret;
diff --git a/drivers/gpu/ion/Kconfig b/drivers/gpu/ion/Kconfig
index fe189f35aff5..5b48b4e85e73 100644
--- a/drivers/gpu/ion/Kconfig
+++ b/drivers/gpu/ion/Kconfig
@@ -10,8 +10,3 @@ config ION_TEGRA
 	help
 	  Choose this option if you wish to use ion on an nVidia Tegra.
 
-config ION_ROCKCHIP
-	tristate "Ion for Rockchip"
-	depends on PLAT_RK && ION
-	help
-	  Choose this option if you wish to use ion on an Rockchip.
diff --git a/drivers/gpu/ion/Makefile b/drivers/gpu/ion/Makefile
index 92eb4395b188..73fe3fa10706 100644
--- a/drivers/gpu/ion/Makefile
+++ b/drivers/gpu/ion/Makefile
@@ -1,3 +1,2 @@
 obj-$(CONFIG_ION) +=	ion.o ion_heap.o ion_system_heap.o ion_carveout_heap.o
 obj-$(CONFIG_ION_TEGRA) += tegra/
-obj-$(CONFIG_ION_ROCKCHIP) += rockchip/
diff --git a/drivers/gpu/ion/ion.c b/drivers/gpu/ion/ion.c
index d1ace1e95b03..37b23af0550b 100644
--- a/drivers/gpu/ion/ion.c
+++ b/drivers/gpu/ion/ion.c
@@ -29,8 +29,7 @@
 #include <linux/seq_file.h>
 #include <linux/uaccess.h>
 #include <linux/debugfs.h>
-#include <linux/dma-mapping.h>
-#include <asm/cacheflush.h>
+
 #include "ion_priv.h"
 #define DEBUG
 
@@ -82,8 +81,6 @@ struct ion_client {
 	struct dentry *debug_root;
 };
 
-static struct ion_client *g_client = NULL;
-
 /**
  * ion_handle - a client local reference to a buffer
  * @ref:		reference count
@@ -158,7 +155,6 @@ static struct ion_buffer *ion_buffer_create(struct ion_heap *heap,
 	buffer->dev = dev;
 	buffer->size = len;
 	mutex_init(&buffer->lock);
-	INIT_LIST_HEAD(&buffer->map_addr);
 	ion_buffer_add(dev, buffer);
 	return buffer;
 }
@@ -168,8 +164,8 @@ static void ion_buffer_destroy(struct kref *kref)
 	struct ion_buffer *buffer = container_of(kref, struct ion_buffer, ref);
 	struct ion_device *dev = buffer->dev;
 
-	mutex_lock(&dev->lock);
 	buffer->heap->ops->free(buffer);
+	mutex_lock(&dev->lock);
 	rb_erase(&buffer->node, &dev->buffers);
 	mutex_unlock(&dev->lock);
 	kfree(buffer);
@@ -209,8 +205,10 @@ static void ion_handle_destroy(struct kref *kref)
 	   if (handle->map_cnt) unmap
 	 */
 	ion_buffer_put(handle->buffer);
+	mutex_lock(&handle->client->lock);
 	if (!RB_EMPTY_NODE(&handle->node))
 		rb_erase(&handle->node, &handle->client->handles);
+	mutex_unlock(&handle->client->lock);
 	kfree(handle);
 }
 
@@ -327,9 +325,7 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 
 	mutex_lock(&client->lock);
 	ion_handle_add(client, handle);
-	buffer->pid = client->pid;
 	mutex_unlock(&client->lock);
-
 	return handle;
 
 end:
@@ -337,39 +333,23 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 	return handle;
 }
 
-struct ion_handle *ion_alloc_by_kenel(size_t len, enum ion_heap_ids id)
-{
-	struct ion_handle *handle;
-	if(!g_client)
-		return NULL;
-	handle = ion_alloc(g_client, len , PAGE_SIZE, 1<<id);
-	if (IS_ERR_OR_NULL(handle))
-		return NULL;
-	return handle;
-}
-EXPORT_SYMBOL(ion_alloc_by_kenel);
 void ion_free(struct ion_client *client, struct ion_handle *handle)
 {
 	bool valid_handle;
 
 	BUG_ON(client != handle->client);
+
 	mutex_lock(&client->lock);
 	valid_handle = ion_handle_validate(client, handle);
+	mutex_unlock(&client->lock);
+
 	if (!valid_handle) {
-	        mutex_unlock(&client->lock);
 		WARN("%s: invalid handle passed to free.\n", __func__);
 		return;
 	}
 	ion_handle_put(handle);
-	mutex_unlock(&client->lock);
 }
 
-void ion_free_by_kernel(struct ion_handle *handle)
-{
-	if(g_client)
-		ion_free(g_client, handle);
-}
-EXPORT_SYMBOL(ion_free_by_kernel);
 static void ion_client_get(struct ion_client *client);
 static int ion_client_put(struct ion_client *client);
 
@@ -423,60 +403,10 @@ int ion_phys(struct ion_client *client, struct ion_handle *handle,
 		return -ENODEV;
 	}
 	mutex_unlock(&client->lock);
-	mutex_lock(&buffer->lock);
-	ret = buffer->heap->ops->phys(buffer->heap, buffer, addr, len);
-	mutex_unlock(&buffer->lock);
-	return ret;
-}
-
-int ion_phys_by_kernel(struct ion_handle *handle, ion_phys_addr_t *addr, size_t *len)
-{
-	return ion_phys(g_client, handle, addr, len);
-}
-EXPORT_SYMBOL(ion_phys_by_kernel);
-static int __ion_phys_by_kernel_nolock(struct ion_handle *handle, 
-		ion_phys_addr_t *addr, size_t *len)
-{
-	struct ion_buffer *buffer;
-	int ret;
-
-	if (!ion_handle_validate(g_client, handle)) {
-		return -EINVAL;
-	}
-
-	buffer = handle->buffer;
-
-	if (!buffer->heap->ops->phys) {
-		pr_err("%s: ion_phys is not implemented by this heap.\n",
-		       __func__);
-		return -ENODEV;
-	}
-	mutex_lock(&buffer->lock);
 	ret = buffer->heap->ops->phys(buffer->heap, buffer, addr, len);
-	mutex_unlock(&buffer->lock);
 	return ret;
 }
-struct ion_handle *ion_handle_lookup_by_addr(ion_phys_addr_t addr)
-{
-	struct rb_node *n;
 
-	mutex_lock(&g_client->lock);
-	for (n = rb_first(&g_client->handles); n; n = rb_next(n)) {
-		int ret;
-		ion_phys_addr_t _addr;
-		size_t len;
-		struct ion_handle *handle = rb_entry(n, struct ion_handle,
-						     node);
-		ret = __ion_phys_by_kernel_nolock(handle, &_addr, &len);
-		if((ret == 0) && (_addr == addr)){
-			mutex_unlock(&g_client->lock);
-			return handle;
-		}
-	}
-	mutex_unlock(&g_client->lock);		
-	return NULL;
-}
-EXPORT_SYMBOL(ion_handle_lookup_by_addr);
 void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle)
 {
 	struct ion_buffer *buffer;
@@ -650,25 +580,29 @@ static int ion_debug_client_show(struct seq_file *s, void *unused)
 {
 	struct ion_client *client = s->private;
 	struct rb_node *n;
+	size_t sizes[ION_NUM_HEAPS] = {0};
+	const char *names[ION_NUM_HEAPS] = {0};
+	int i;
 
-	seq_printf(s, "%16.16s: %16.16s  %16.16s  %16.16s\n", "heap_name",
-			"size(K)", "handle refcount", "buffer");
 	mutex_lock(&client->lock);
 	for (n = rb_first(&client->handles); n; n = rb_next(n)) {
 		struct ion_handle *handle = rb_entry(n, struct ion_handle,
 						     node);
+		enum ion_heap_type type = handle->buffer->heap->type;
 
-		seq_printf(s, "%16.16s: %16u  %16d  %16p\n",
-				handle->buffer->heap->name,
-				handle->buffer->size/SZ_1K,
-				atomic_read(&handle->ref.refcount),
-				handle->buffer);
+		if (!names[type])
+			names[type] = handle->buffer->heap->name;
+		sizes[type] += handle->buffer->size;
 	}
-
-	seq_printf(s, "%16.16s %d\n", "client refcount:",
-			atomic_read(&client->ref.refcount));
 	mutex_unlock(&client->lock);
 
+	seq_printf(s, "%16.16s: %16.16s\n", "heap_name", "size_in_bytes");
+	for (i = 0; i < ION_NUM_HEAPS; i++) {
+		if (!names[i])
+			continue;
+		seq_printf(s, "%16.16s: %16u %d\n", names[i], sizes[i],
+			   atomic_read(&client->ref.refcount));
+	}
 	return 0;
 }
 
@@ -862,7 +796,6 @@ static void ion_vma_open(struct vm_area_struct *vma)
 		vma->vm_private_data = NULL;
 		return;
 	}
-	ion_handle_get(handle);
 	pr_debug("%s: %d client_cnt %d handle_cnt %d alloc_cnt %d\n",
 		 __func__, __LINE__,
 		 atomic_read(&client->ref.refcount),
@@ -875,36 +808,24 @@ static void ion_vma_close(struct vm_area_struct *vma)
 	struct ion_handle *handle = vma->vm_private_data;
 	struct ion_buffer *buffer = vma->vm_file->private_data;
 	struct ion_client *client;
-	struct ion_user_map_addr *map = NULL, *tmp;
 
 	pr_debug("%s: %d\n", __func__, __LINE__);
 	/* this indicates the client is gone, nothing to do here */
 	if (!handle)
 		return;
-        vma->vm_private_data = NULL;
 	client = handle->client;
 	pr_debug("%s: %d client_cnt %d handle_cnt %d alloc_cnt %d\n",
 		 __func__, __LINE__,
 		 atomic_read(&client->ref.refcount),
 		 atomic_read(&handle->ref.refcount),
 		 atomic_read(&buffer->ref.refcount));
-	mutex_lock(&client->lock);
 	ion_handle_put(handle);
-	mutex_unlock(&client->lock);
 	ion_client_put(client);
 	pr_debug("%s: %d client_cnt %d handle_cnt %d alloc_cnt %d\n",
 		 __func__, __LINE__,
 		 atomic_read(&client->ref.refcount),
 		 atomic_read(&handle->ref.refcount),
 		 atomic_read(&buffer->ref.refcount));
-	mutex_lock(&buffer->lock);
-	list_for_each_entry_safe(map, tmp, &buffer->map_addr, list)
-		if(map->vaddr == vma->vm_start){
-			list_del(&map->list);
-                        kfree(map);
-			break;
-		}
-	mutex_unlock(&buffer->lock);
 }
 
 static struct vm_operations_struct ion_vm_ops = {
@@ -919,7 +840,6 @@ static int ion_share_mmap(struct file *file, struct vm_area_struct *vma)
 	struct ion_client *client;
 	struct ion_handle *handle;
 	int ret;
-	struct ion_user_map_addr *map = NULL;
 
 	pr_debug("%s: %d\n", __func__, __LINE__);
 	/* make sure the client still exists, it's possible for the client to
@@ -968,80 +888,26 @@ static int ion_share_mmap(struct file *file, struct vm_area_struct *vma)
 	/* move the handle into the vm_private_data so we can access it from
 	   vma_open/close */
 	vma->vm_private_data = handle;
-
-	map = kzalloc(sizeof(struct ion_user_map_addr), GFP_KERNEL);
-	if(!map)
-		goto err1;
-	map->vaddr = vma->vm_start;
-	map->size = buffer->size;
-	mutex_lock(&buffer->lock);
-	list_add_tail(&map->list, &buffer->map_addr);
-	mutex_unlock(&buffer->lock);
 	pr_debug("%s: %d client_cnt %d handle_cnt %d alloc_cnt %d\n",
 		 __func__, __LINE__,
 		 atomic_read(&client->ref.refcount),
 		 atomic_read(&handle->ref.refcount),
 		 atomic_read(&buffer->ref.refcount));
-
 	return 0;
 
 err1:
 	/* drop the reference to the handle */
-	mutex_lock(&client->lock);
 	ion_handle_put(handle);
-	mutex_unlock(&client->lock);
 err:
 	/* drop the reference to the client */
 	ion_client_put(client);
 	return ret;
 }
 
-/* Compatible with pmem */
-static long ion_share_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	struct ion_buffer *buffer = filp->private_data;
-	
-	switch (cmd) {
-	case ION_PMEM_GET_PHYS:
-	{
-		struct ion_pmem_region region;
-		region.offset = buffer->priv_phys;
-		region.len = buffer->size;
-
-		if (copy_to_user((void __user *)arg, &region,
-				sizeof(struct ion_pmem_region)))
-			return -EFAULT;
-		break;
-	}
-	case ION_PMEM_CACHE_FLUSH:
-	{
-		struct ion_pmem_region region;
-                struct ion_user_map_addr *map = NULL;
-		if (copy_from_user(&region, (void __user *)arg,
-				sizeof(struct ion_pmem_region)))
-			return -EFAULT;
-                if(!(region.offset & 0xf0000000)) {
-			mutex_lock(&buffer->lock);
-                        list_for_each_entry(map, &buffer->map_addr, list) {
-		                dmac_flush_range((void *)map->vaddr, (void *)(map->vaddr + map->size));
-                        }
-			mutex_unlock(&buffer->lock);
-                }else {
-		        dmac_flush_range((void *)region.offset, (void *)(region.offset + region.len));
-                }
-		break;
-	}
-	default:
-		return -ENOTTY;
-	}
-	return 0;
-}
-
 static const struct file_operations ion_share_fops = {
 	.owner		= THIS_MODULE,
 	.release	= ion_share_release,
 	.mmap		= ion_share_mmap,
-	.unlocked_ioctl = ion_share_ioctl,
 };
 
 static int ion_ioctl_share(struct file *parent, struct ion_client *client,
@@ -1057,10 +923,6 @@ static int ion_ioctl_share(struct file *parent, struct ion_client *client,
 				  handle->buffer, O_RDWR);
 	if (IS_ERR_OR_NULL(file))
 		goto err;
-
-	if (parent->f_flags & O_DSYNC)
-		file->f_flags |= O_DSYNC;
-	
 	ion_buffer_get(handle->buffer);
 	fd_install(fd, file);
 
@@ -1079,15 +941,11 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	case ION_IOC_ALLOC:
 	{
 		struct ion_allocation_data data;
+
 		if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
 			return -EFAULT;
-
 		data.handle = ion_alloc(client, data.len, data.align,
 					     data.flags);
-		if (IS_ERR_OR_NULL(data.handle)) {
-			pr_err("%s: alloc 0x%x bytes failed\n", __func__, data.len);
-                        return -ENOMEM;
-		} 
 		if (copy_to_user((void __user *)arg, &data, sizeof(data)))
 			return -EFAULT;
 		break;
@@ -1117,8 +975,8 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			return -EFAULT;
 		mutex_lock(&client->lock);
 		if (!ion_handle_validate(client, data.handle)) {
-			pr_err("%s: invalid handle(%p) passed to share ioctl\n",
-			       __func__, data.handle);
+			pr_err("%s: invalid handle passed to share ioctl.\n",
+			       __func__);
 			mutex_unlock(&client->lock);
 			return -EINVAL;
 		}
@@ -1136,10 +994,8 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			return -EFAULT;
 
 		data.handle = ion_import_fd(client, data.fd);
-		if (IS_ERR(data.handle)){
+		if (IS_ERR(data.handle))
 			data.handle = NULL;
-			return -EFAULT;
-		}
 		if (copy_to_user((void __user *)arg, &data,
 				 sizeof(struct ion_fd_data)))
 			return -EFAULT;
@@ -1157,126 +1013,6 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			return -EFAULT;
 		return dev->custom_ioctl(client, data.cmd, data.arg);
 	}
-	case ION_CUSTOM_GET_PHYS:
-	{
-		int err = 0;
-		struct ion_phys_data data;
-		
-		if (copy_from_user(&data, (void __user *)arg,
-				sizeof(struct ion_phys_data)))
-			return -EFAULT;
-		err = ion_phys(client, data.handle, &data.phys, (size_t *)&data.size);
-		if(err < 0)
-			return err;
-		if (copy_to_user((void __user *)arg, &data,
-			 	sizeof(struct ion_phys_data)))
-			return -EFAULT;
-		break;
-	}
-	case ION_CUSTOM_CACHE_OP:
-	{
-		struct ion_cacheop_data data;
-		struct ion_buffer *buffer;
-		int err = -EINVAL;
-		
-		if (copy_from_user(&data, (void __user *)arg,
-				sizeof(struct ion_cacheop_data)))
-			return -EFAULT;
-		mutex_lock(&client->lock);
-		if(ion_handle_validate(client, data.handle)){
-			buffer = data.handle->buffer;
-			if(buffer->heap->ops->cache_op){
-				mutex_lock(&buffer->lock);
-				buffer->heap->ops->cache_op(buffer->heap, buffer, data.virt, data.type);
-				mutex_unlock(&buffer->lock);
-				err = 0;
-			}
-		}
-		mutex_unlock(&client->lock);
-		break;
-	}
-	case ION_CUSTOM_GET_CLIENT_INFO:
-	{
-		struct rb_node *n;
-		struct ion_client_info info;
-#if 0
-		int i;
-
-		mutex_lock(&client->lock);
-		info.total_size = 0;
-		info.count = atomic_read(&client->ref.refcount);
-		if(info.count > MAX_BUFFER_COUNT){
-			pr_err("%s: buffer count(%u) ge MAX_BUFFER_COUNT(%d)\n",
-				__func__, info.count, MAX_BUFFER_COUNT);
-			mutex_unlock(&client->lock);
-			return -EFAULT;
-		}
-		for (i = 0, n = rb_first(&client->handles); n; i++, n = rb_next(n)) {
-			struct ion_handle *handle = rb_entry(n, struct ion_handle,
-						     node);
-			info.buf[i].phys = handle->buffer->priv_phys;
-			info.buf[i].size = handle->buffer->size;
-			info.total_size += handle->buffer->size;
-
-		}
-#else
-		mutex_lock(&client->lock);
-		info.total_size = 0;
-		info.count = 0;
-		for (n = rb_first(&client->dev->buffers); n; n = rb_next(n)) {
-			struct ion_buffer *buf = rb_entry(n, struct ion_buffer,
-						     node);
-
-			if(info.count > MAX_BUFFER_COUNT){
-				pr_err("%s: buffer count(%u) ge MAX_BUFFER_COUNT(%d)\n",
-					__func__, info.count, MAX_BUFFER_COUNT);
-				mutex_unlock(&client->lock);
-				return -EFAULT;
-			}
-			if(buf->pid == client->pid) {
-				info.buf[info.count].phys = buf->priv_phys;
-				info.buf[info.count].size = buf->size;
-				info.total_size += buf->size;
-				info.count++;
-			}
-		}
-#endif
-		mutex_unlock(&client->lock);
-		if (copy_to_user((void __user *)arg, &info,
-			 	sizeof(struct ion_client_info)))
-			return -EFAULT;
-		break;
-	}
-	case ION_CUSTOM_GET_HEAP_INFO:
-	{
-		struct rb_node *n;
-		struct ion_heap_info info;
-		struct ion_heap *heap = NULL;
-		int err = -EINVAL;
-		
-		if (copy_from_user(&info, (void __user *)arg,
-				sizeof(struct ion_heap_info)))
-			return -EFAULT;
-		mutex_lock(&client->dev->lock);
-		for (n = rb_first(&client->dev->heaps); n != NULL; n = rb_next(n)) {
-			heap = rb_entry(n, struct ion_heap, node);
-
-			if(heap->id == info.id){
-				info.allocated_size = heap->allocated_size;
-				info.max_allocated = heap->max_allocated;
-				info.total_size = heap->total_size;
-
-				err = 0;
-			}
-				
-		}
-		mutex_unlock(&client->dev->lock);
-
-		if (copy_to_user((void __user *)arg, &info,
-			 	sizeof(struct ion_heap_info)))
-			err = -EFAULT;
-		break;
-	}
 	default:
 		return -ENOTTY;
 	}
@@ -1315,7 +1051,7 @@ static const struct file_operations ion_fops = {
 };
 
 static size_t ion_debug_heap_total(struct ion_client *client,
-				   enum ion_heap_ids id)
+				   enum ion_heap_type type)
 {
 	size_t size = 0;
 	struct rb_node *n;
@@ -1325,7 +1061,7 @@ static size_t ion_debug_heap_total(struct ion_client *client,
 		struct ion_handle *handle = rb_entry(n,
 						     struct ion_handle,
 						     node);
-		if (handle->buffer->heap->id == id)
+		if (handle->buffer->heap->type == type)
 			size += handle->buffer->size;
 	}
 	mutex_unlock(&client->lock);
@@ -1337,32 +1073,29 @@ static int ion_debug_heap_show(struct seq_file *s, void *unused)
 	struct ion_heap *heap = s->private;
 	struct ion_device *dev = heap->dev;
 	struct rb_node *n;
-	
-	if (heap->ops->print_debug)
-		heap->ops->print_debug(heap, s);
-	seq_printf(s, "-------------------------------------------------\n");
-	seq_printf(s, "%16.s %16.s %16.s\n", "client", "pid", "size(K)");
+
+	seq_printf(s, "%16.s %16.s %16.s\n", "client", "pid", "size");
 	for (n = rb_first(&dev->user_clients); n; n = rb_next(n)) {
 		struct ion_client *client = rb_entry(n, struct ion_client,
 						     node);
 		char task_comm[TASK_COMM_LEN];
-		size_t size = ion_debug_heap_total(client, heap->id);
+		size_t size = ion_debug_heap_total(client, heap->type);
 		if (!size)
 			continue;
 
 		get_task_comm(task_comm, client->task);
 		seq_printf(s, "%16.s %16u %16u\n", task_comm, client->pid,
-			   size/SZ_1K);
+			   size);
 	}
 
 	for (n = rb_first(&dev->kernel_clients); n; n = rb_next(n)) {
 		struct ion_client *client = rb_entry(n, struct ion_client,
 						     node);
-		size_t size = ion_debug_heap_total(client, heap->id);
+		size_t size = ion_debug_heap_total(client, heap->type);
 		if (!size)
 			continue;
 		seq_printf(s, "%16.s %16u %16u\n", client->name, client->pid,
-			   size/SZ_1K);
+			   size);
 	}
 	return 0;
 }
@@ -1410,80 +1143,6 @@ void ion_device_add_heap(struct ion_device *dev, struct ion_heap *heap)
 	mutex_unlock(&dev->lock);
 }
 
-static int ion_debug_leak_show(struct seq_file *s, void *unused)
-{
-	struct ion_device *dev = s->private;
-	struct rb_node *n;
-	struct rb_node *n2;
-
-	/* mark all buffers as 1 */
-	seq_printf(s, "%16.s %16.s %16.s %16.s %16.s\n", "pid", "buffer", "heap", "size(K)",
-		"ref_count");
-	mutex_lock(&dev->lock);
-	for (n = rb_first(&dev->buffers); n; n = rb_next(n)) {
-		struct ion_buffer *buf = rb_entry(n, struct ion_buffer,
-						     node);
-
-		buf->marked = 1;
-	}
-
-	/* now see which buffers we can access */
-	for (n = rb_first(&dev->kernel_clients); n; n = rb_next(n)) {
-		struct ion_client *client = rb_entry(n, struct ion_client,
-						     node);
-
-		mutex_lock(&client->lock);
-		for (n2 = rb_first(&client->handles); n2; n2 = rb_next(n2)) {
-			struct ion_handle *handle = rb_entry(n2,
-						struct ion_handle, node);
-
-			handle->buffer->marked = 0;
-
-		}
-		mutex_unlock(&client->lock);
-
-	}
-
-	for (n = rb_first(&dev->user_clients); n; n = rb_next(n)) {
-		struct ion_client *client = rb_entry(n, struct ion_client,
-						     node);
-
-		mutex_lock(&client->lock);
-		for (n2 = rb_first(&client->handles); n2; n2 = rb_next(n2)) {
-			struct ion_handle *handle = rb_entry(n2,
-						struct ion_handle, node);
-
-			handle->buffer->marked = 0;
-
-		}
-		mutex_unlock(&client->lock);
-
-	}
-	/* And anyone still marked as a 1 means a leaked handle somewhere */
-	for (n = rb_first(&dev->buffers); n; n = rb_next(n)) {
-		struct ion_buffer *buf = rb_entry(n, struct ion_buffer,
-						     node);
-
-		if (buf->marked == 1)
-			seq_printf(s, "%16.u %16.x %16.s %16.d %16.d\n",
-				buf->pid, (int)buf, buf->heap->name, buf->size/SZ_1K,
-				atomic_read(&buf->ref.refcount));
-	}
-	mutex_unlock(&dev->lock);
-	return 0;
-}
-
-static int ion_debug_leak_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, ion_debug_leak_show, inode->i_private);
-}
-
-static const struct file_operations debug_leak_fops = {
-	.open = ion_debug_leak_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
 struct ion_device *ion_device_create(long (*custom_ioctl)
 				     (struct ion_client *client,
 				      unsigned int cmd,
@@ -1516,18 +1175,11 @@ struct ion_device *ion_device_create(long (*custom_ioctl)
 	idev->heaps = RB_ROOT;
 	idev->user_clients = RB_ROOT;
 	idev->kernel_clients = RB_ROOT;
-
-	g_client = ion_client_create(idev, -1, "kernel");
-
-	debugfs_create_file("leak", 0664, idev->debug_root, idev,
-			    &debug_leak_fops);
 	return idev;
 }
 
 void ion_device_destroy(struct ion_device *dev)
 {
-	ion_client_destroy(g_client);
-	g_client = NULL;
 	misc_deregister(&dev->dev);
 	/* XXX need to free the heaps and clients ? */
 	kfree(dev);
diff --git a/drivers/gpu/ion/ion_carveout_heap.c b/drivers/gpu/ion/ion_carveout_heap.c
index 72420c8e06d3..606adae13f48 100644
--- a/drivers/gpu/ion/ion_carveout_heap.c
+++ b/drivers/gpu/ion/ion_carveout_heap.c
@@ -13,8 +13,8 @@
  * GNU General Public License for more details.
  *
  */
+#include <linux/spinlock.h>
 
- #include <linux/spinlock.h>
 #include <linux/err.h>
 #include <linux/genalloc.h>
 #include <linux/io.h>
@@ -23,20 +23,16 @@
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
-#include <linux/iommu.h>
-#include <linux/seq_file.h>
-#include <asm/mach/map.h>
-#include <linux/dma-mapping.h>
-#include <asm/cacheflush.h>
 #include "ion_priv.h"
 
+#include <asm/mach/map.h>
+
 struct ion_carveout_heap {
 	struct ion_heap heap;
 	struct gen_pool *pool;
 	ion_phys_addr_t base;
-	unsigned long bit_nr;
-	unsigned long *bits;
 };
+
 ion_phys_addr_t ion_carveout_allocate(struct ion_heap *heap,
 				      unsigned long size,
 				      unsigned long align)
@@ -45,30 +41,9 @@ ion_phys_addr_t ion_carveout_allocate(struct ion_heap *heap,
 		container_of(heap, struct ion_carveout_heap, heap);
 	unsigned long offset = gen_pool_alloc(carveout_heap->pool, size);
 
-	if (!offset) {
-		if ((heap->total_size - heap->allocated_size) > size)
-			pr_debug("%s: heap %s has enough memory (%luK) but"
-				" the allocation of size(%luK) still failed."
-				" Memory is probably fragmented.\n",
-				__func__, heap->name,
-				(heap->total_size - heap->allocated_size)/SZ_1K, 
-				size/SZ_1K);
-		else
-			pr_debug("%s: heap %s has not enough memory(%luK)"
-				"the alloction of size is %luK.\n",
-				__func__, heap->name,
-				(heap->total_size - heap->allocated_size)/SZ_1K, 
-				size/SZ_1K);
+	if (!offset)
 		return ION_CARVEOUT_ALLOCATE_FAIL;
-	}
-
-	heap->allocated_size += size;
 
-	if((offset + size - carveout_heap->base) > heap->max_allocated)
-		heap->max_allocated = offset + size - carveout_heap->base;
-
-	bitmap_set(carveout_heap->bits, 
-		(offset - carveout_heap->base)/PAGE_SIZE , size/PAGE_SIZE);
 	return offset;
 }
 
@@ -81,10 +56,6 @@ void ion_carveout_free(struct ion_heap *heap, ion_phys_addr_t addr,
 	if (addr == ION_CARVEOUT_ALLOCATE_FAIL)
 		return;
 	gen_pool_free(carveout_heap->pool, addr, size);
-
-	heap->allocated_size -= size;
-	bitmap_clear(carveout_heap->bits, 
-		(addr - carveout_heap->base)/PAGE_SIZE, size/PAGE_SIZE);
 }
 
 static int ion_carveout_heap_phys(struct ion_heap *heap,
@@ -146,83 +117,9 @@ int ion_carveout_heap_map_user(struct ion_heap *heap, struct ion_buffer *buffer,
 	return remap_pfn_range(vma, vma->vm_start,
 			       __phys_to_pfn(buffer->priv_phys) + vma->vm_pgoff,
 			       buffer->size,
-					vma->vm_page_prot);
-}
-int ion_carveout_cache_op(struct ion_heap *heap, struct ion_buffer *buffer,
-			void *virt, unsigned int type)
-{
-	unsigned long phys_start = 0, phys_end = 0;
-	void *virt_start = NULL, *virt_end = NULL;
-	struct ion_user_map_addr *map = NULL;
-
-        if(!buffer)
-                return -EINVAL;
-	phys_start = buffer->priv_phys;
-	phys_end = buffer->priv_phys + buffer->size;
-	
-	list_for_each_entry(map, &buffer->map_addr, list) {
-		if(map->vaddr == (unsigned long)virt){
-			virt_start = virt;
-			virt_end = (void *)((unsigned long)virt + map->size);
-			break;
-		}
-	}
-	if(!virt_start){
-		pr_err("%s: virt(%p) has not been maped or has been unmaped\n",
-			__func__, virt);
-		return -EINVAL;
-	}
-	switch(type) {
-	case ION_CACHE_FLUSH:
-		dmac_flush_range(virt_start, virt_end);
-		outer_flush_range(phys_start,phys_end); 
-		break;
-	case ION_CACHE_CLEAN:
-		/* When cleaning, always clean the innermost (L1) cache first 
-		* and then clean the outer cache(s).
-		*/
-		dmac_clean_range(virt_start, virt_end);
-		outer_clean_range(phys_start,phys_end); 
-		break;
-	case ION_CACHE_INV:
-		/* When invalidating, always invalidate the outermost cache first 
-		* and the L1 cache last.
-		*/
-		outer_inv_range(phys_start,phys_end); 
-		dmac_inv_range(virt_start, virt_end);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
+			       pgprot_noncached(vma->vm_page_prot));
 }
 
-static int ion_carveout_print_debug(struct ion_heap *heap, struct seq_file *s)
-{
-	int i;
-	struct ion_carveout_heap *carveout_heap =
-		container_of(heap, struct ion_carveout_heap, heap);
-
-	for(i = carveout_heap->bit_nr/8 - 1; i>= 0; i--){
-		seq_printf(s, "%.3uM> Bits[%.3d - %.3d]: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n", 
-				i+1, i*8 + 7, i*8,
-				carveout_heap->bits[i*8 + 7],
-				carveout_heap->bits[i*8 + 6],
-				carveout_heap->bits[i*8 + 5],
-				carveout_heap->bits[i*8 + 4],
-				carveout_heap->bits[i*8 + 3],
-				carveout_heap->bits[i*8 + 2],
-				carveout_heap->bits[i*8 + 1],
-				carveout_heap->bits[i*8]);
-	}
-	seq_printf(s, "Total allocated: %luM\n",
-		heap->allocated_size/SZ_1M);
-	seq_printf(s, "max_allocated: %luM\n",
-		heap->max_allocated/SZ_1M);
-	seq_printf(s, "Heap size: %luM, heap base: 0x%lx\n", 
-		heap->total_size/SZ_1M, carveout_heap->base);
-	return 0;
-}
 static struct ion_heap_ops carveout_heap_ops = {
 	.allocate = ion_carveout_heap_allocate,
 	.free = ion_carveout_heap_free,
@@ -230,8 +127,6 @@ static struct ion_heap_ops carveout_heap_ops = {
 	.map_user = ion_carveout_heap_map_user,
 	.map_kernel = ion_carveout_heap_map_kernel,
 	.unmap_kernel = ion_carveout_heap_unmap_kernel,
-	.cache_op = ion_carveout_cache_op,
-	.print_debug = ion_carveout_print_debug,
 };
 
 struct ion_heap *ion_carveout_heap_create(struct ion_platform_heap *heap_data)
@@ -252,12 +147,6 @@ struct ion_heap *ion_carveout_heap_create(struct ion_platform_heap *heap_data)
 		     -1);
 	carveout_heap->heap.ops = &carveout_heap_ops;
 	carveout_heap->heap.type = ION_HEAP_TYPE_CARVEOUT;
-	carveout_heap->heap.allocated_size = 0;
-	carveout_heap->heap.max_allocated = 0;
-	carveout_heap->heap.total_size = heap_data->size;
-	carveout_heap->bit_nr = heap_data->size/(PAGE_SIZE * sizeof(unsigned long) * 8);
-	carveout_heap->bits = 
-		(unsigned long *)kzalloc(carveout_heap->bit_nr * sizeof(unsigned long), GFP_KERNEL);
 
 	return &carveout_heap->heap;
 }
@@ -268,7 +157,6 @@ void ion_carveout_heap_destroy(struct ion_heap *heap)
 	     container_of(heap, struct  ion_carveout_heap, heap);
 
 	gen_pool_destroy(carveout_heap->pool);
-	kfree(carveout_heap->bits);
 	kfree(carveout_heap);
 	carveout_heap = NULL;
 }
diff --git a/drivers/gpu/ion/ion_priv.h b/drivers/gpu/ion/ion_priv.h
index 3dbe298e1149..3323954c03a0 100644
--- a/drivers/gpu/ion/ion_priv.h
+++ b/drivers/gpu/ion/ion_priv.h
@@ -23,11 +23,6 @@
 #include <linux/rbtree.h>
 #include <linux/ion.h>
 
-#include <linux/seq_file.h>
-#include <linux/uaccess.h>
-#include <linux/debugfs.h>
-#include <linux/list.h>
-
 struct ion_mapping;
 
 struct ion_dma_mapping {
@@ -40,11 +35,6 @@ struct ion_kernel_mapping {
 	void *vaddr;
 };
 
-struct ion_user_map_addr {
-	unsigned long vaddr;
-	unsigned long size;
-	struct list_head list;
-};
 struct ion_buffer *ion_handle_buffer(struct ion_handle *handle);
 
 /**
@@ -81,9 +71,6 @@ struct ion_buffer {
 	void *vaddr;
 	int dmap_cnt;
 	struct scatterlist *sglist;
-        struct list_head map_addr;
-	pid_t pid;
-	int marked;
 };
 
 /**
@@ -112,9 +99,6 @@ struct ion_heap_ops {
 	void (*unmap_kernel) (struct ion_heap *heap, struct ion_buffer *buffer);
 	int (*map_user) (struct ion_heap *mapper, struct ion_buffer *buffer,
 			 struct vm_area_struct *vma);
-	int (*cache_op)(struct ion_heap *heap, struct ion_buffer *buffer,
-			void *virt, unsigned int type);
-	int (*print_debug)(struct ion_heap *heap, struct seq_file *s);
 };
 
 /**
@@ -140,10 +124,6 @@ struct ion_heap {
 	struct ion_heap_ops *ops;
 	int id;
 	const char *name;
-
-	unsigned long allocated_size;
-	unsigned long max_allocated;
-	unsigned long total_size;
 };
 
 /**
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index 74794c879876..53576e7c8bcf 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -37,12 +37,6 @@
 
 #include "hid-ids.h"
 
-#ifdef CONFIG_BYPASS_INPUT_TO_HIDG
-extern f_hid_bypass_input_get();
-extern f_hid_kbd_translate_report(u8 * data, int len);
-extern f_hid_mouse_translate_report(struct hid_report *report , u8 *data);
-#endif
-
 /*
  * Version Information
  */
@@ -906,6 +900,7 @@ static void hid_input_field(struct hid_device *hid, struct hid_field *field,
 	__s32 min = field->logical_minimum;
 	__s32 max = field->logical_maximum;
 	__s32 *value;
+
 	value = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);
 	if (!value)
 		return;
@@ -923,11 +918,6 @@ static void hid_input_field(struct hid_device *hid, struct hid_field *field,
 		    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)
 			goto exit;
 	}
-	
-#ifdef CONFIG_BYPASS_INPUT_TO_HIDG	
-    if((hid->type == 1) && (f_hid_bypass_input_get() == 1))
-        goto memcpy;//bypass mouse report
-#endif
 
 	for (n = 0; n < count; n++) {
 
@@ -946,9 +936,8 @@ static void hid_input_field(struct hid_device *hid, struct hid_field *field,
 			&& search(field->value, value[n], count))
 				hid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);
 	}
-memcpy:
-	memcpy(field->value, value, count * sizeof(__s32));
 
+	memcpy(field->value, value, count * sizeof(__s32));
 exit:
 	kfree(value);
 }
@@ -1069,20 +1058,10 @@ void hid_report_raw_event(struct hid_device *hid, int type, u8 *data, int size,
 		hid->hiddev_report_event(hid, report);
 	if (hid->claimed & HID_CLAIMED_HIDRAW)
 		hidraw_report_event(hid, data, size);
+
 	for (a = 0; a < report->maxfield; a++)
 		hid_input_field(hid, report->field[a], cdata, interrupt);
 
-#ifdef CONFIG_BYPASS_INPUT_TO_HIDG
-
-	if((hid->type == 0))//kbd
-	{
-        f_hid_kbd_translate_report(report, cdata);
-    }
-    else if(hid->type == 1)//mouse
-    {
-        f_hid_mouse_translate_report(report, cdata);
-    }
-#endif
 	if (hid->claimed & HID_CLAIMED_INPUT)
 		hidinput_report_event(hid, report);
 }
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 852d74d935a2..38c261a40c74 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -1377,9 +1377,6 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 
 	hid_cancel_delayed_stuff(usbhid);
 	hid_cease_io(usbhid);
-    usb_control_msg(interface_to_usbdev(intf), usb_sndctrlpipe(interface_to_usbdev(intf), 0),
-            USB_REQ_SET_FEATURE, USB_TYPE_STANDARD | USB_RECIP_DEVICE, USB_DEVICE_REMOTE_WAKEUP,
-            0, NULL, 0, USB_CTRL_SET_TIMEOUT);
 
 	if ((message.event & PM_EVENT_AUTO) &&
 			test_bit(HID_KEYS_PRESSED, &usbhid->iofl)) {
@@ -1398,7 +1395,6 @@ static int hid_resume(struct usb_interface *intf)
 {
 	struct hid_device *hid = usb_get_intfdata (intf);
 	struct usbhid_device *usbhid = hid->driver_data;
-	struct usb_device *udev = interface_to_usbdev(intf);
 	int status;
 
 	if (!test_bit(HID_STARTED, &usbhid->iofl))
@@ -1411,13 +1407,6 @@ static int hid_resume(struct usb_interface *intf)
 	    test_bit(HID_RESET_PENDING, &usbhid->iofl))
 		schedule_work(&usbhid->reset_work);
 	usbhid->retry_delay = 0;
-	
-    usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-            USB_REQ_CLEAR_FEATURE, USB_TYPE_STANDARD | USB_RECIP_DEVICE, USB_DEVICE_REMOTE_WAKEUP,
-            0, NULL, 0, USB_CTRL_SET_TIMEOUT);
-            
-	hid_set_idle(udev, intf->cur_altsetting->desc.bInterfaceNumber, 0, 0);
-		
 	status = hid_start_in(hid);
 	if (status < 0)
 		hid_io_error(hid);
diff --git a/drivers/i2c/algos/i2c-algo-bit.c b/drivers/i2c/algos/i2c-algo-bit.c
index 0f25f3541f33..f2ce8c36816f 100644
--- a/drivers/i2c/algos/i2c-algo-bit.c
+++ b/drivers/i2c/algos/i2c-algo-bit.c
@@ -384,7 +384,7 @@ static int sendbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)
 		 * the SMBus PEC was wrong.
 		 */
 		} else if (retval == 0) {
-			dev_err(&i2c_adap->dev, "sendbytes: NAK bailout, addr is 0x%x.\n", msg->addr);
+			dev_err(&i2c_adap->dev, "sendbytes: NAK bailout.\n");
 			return -EIO;
 
 		/* Timeout; or (someday) lost arbitration
@@ -395,8 +395,8 @@ static int sendbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)
 		 * to know or care about this ... it is *NOT* an error.
 		 */
 		} else {
-			dev_err(&i2c_adap->dev, "sendbytes: error %d, addr is 0x%x.\n",
-					retval, msg->addr);
+			dev_err(&i2c_adap->dev, "sendbytes: error %d\n",
+					retval);
 			return retval;
 		}
 	}
@@ -550,7 +550,6 @@ static int bit_xfer(struct i2c_adapter *i2c_adap,
 	}
 
 	bit_dbg(3, &i2c_adap->dev, "emitting start condition\n");
-	adap->udelay = 500 * 1000/msgs[0].scl_rate + 1;
 	i2c_start(adap);
 	for (i = 0; i < num; i++) {
 		pmsg = &msgs[i];
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 3ffeaf82c288..646068e5100b 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -838,175 +838,43 @@ config SCx200_I2C
 	tristate "NatSemi SCx200 I2C using GPIO pins (DEPRECATED)"
 	depends on SCx200_GPIO
 	select I2C_ALGOBIT
+	help
+	  Enable the use of two GPIO pins of a SCx200 processor as an I2C bus.
 
-config I2C_RK30
-	tristate "RK I2C Adapter"
-	depends on PLAT_RK && !ARCH_RK29
-	default y
+	  If you don't know what to do here, say N.
+
+	  This support is also available as a module.  If so, the module
+	  will be called scx200_i2c.
+
+	  This driver is deprecated and will be dropped soon. Use i2c-gpio
+	  (or scx200_acb) instead.
+
+config SCx200_I2C_SCL
+	int "GPIO pin used for SCL"
+	depends on SCx200_I2C
+	default "12"
 	help
-		This supports I2C Adapter on RK Soc.
-
-if I2C_RK30
-	comment "Now, there are five selectable I2C channels."
-	
-	config I2C0_RK30
-		bool "I2C0 Channel Support"
-		default y
-		help
-			This supports the use of the I2C0 channel on RK Soc.
-		if I2C0_RK30 && (ARCH_RK30 || ARCH_RK3188 || ARCH_RK2928 || ARCH_RK3026)
-			choice
-				prompt "I2C Controller Select"
-				config I2C0_CONTROLLER_RK29
-					bool "With RK29 I2C Controller"
-				config I2C0_CONTROLLER_RK30
-					bool "With RK30 I2C Controller"
-			endchoice
-		endif
-	config I2C1_RK30
-		bool "I2C1 Channel Support"
-		default y
-		help
-			This supports the use of the I2C1 channel on RK Soc.
-		if I2C1_RK30 && (ARCH_RK30 || ARCH_RK3188 || ARCH_RK2928 || ARCH_RK3026)
-			choice
-				prompt "I2C Controller Select"
-				config I2C1_CONTROLLER_RK29
-					bool "With RK29 I2C Controller"
-				config I2C1_CONTROLLER_RK30
-					bool "With RK30 I2C Controller"
-			endchoice
-		endif
-	config I2C2_RK30
-		bool "I2C2 Channel Support"
-		default y
-		help
-			This supports the use of the I2C2 channel on RK Soc.
-		if I2C2_RK30 && (ARCH_RK30 || ARCH_RK3188 || ARCH_RK2928 || ARCH_RK3026)
-			choice
-				prompt "I2C Controller Select"
-				config I2C2_CONTROLLER_RK29
-					bool "With RK29 I2C Controller"
-				config I2C2_CONTROLLER_RK30
-					bool "With RK30 I2C Controller"
-			endchoice
-		endif
-	config I2C3_RK30
-		bool "I2C3 Channel Support"
-                depends on !HDMI_RK2928
-		default y
-		help
-			This supports the use of the I2C3 channel on RK Soc.
-		if I2C3_RK30 && (ARCH_RK30 || ARCH_RK3188 || ARCH_RK2928 || ARCH_RK3026)
-			choice
-				prompt "I2C Controller Select"
-				config I2C3_CONTROLLER_RK29
-					bool "With RK29 I2C Controller"
-				config I2C3_CONTROLLER_RK30
-					bool "With RK30 I2C Controller"
-			endchoice
-		endif
-	config I2C4_RK30
-		bool "I2C4 Channel Support"
-	        depends on !ARCH_RK2928 && !ARCH_RK3026
-		default y
-		help
-			This supports the use of the I2C4 channel on RK Soc.
-		if I2C4_RK30 && (ARCH_RK30 || ARCH_RK3188 || ARCH_RK2928 || ARCH_RK3026)
-			choice
-				prompt "I2C Controller Select"
-				config I2C4_CONTROLLER_RK29
-					bool "With RK29 I2C Controller"
-				config I2C4_CONTROLLER_RK30
-					bool "With RK30 I2C Controller"
-			endchoice
-		endif
-        config I2C_GPIO_RK30
-                bool "Simulation with GPIO"
-                default n
-                select I2C_GPIO
-endif
-config I2C_RK29
-	tristate "RK29 i2c interface (I2C)"
-	depends on ARCH_RK29
-	default y
+	  Enter the GPIO pin number used for the SCL signal.  This value can
+	  also be specified with a module parameter.
+
+config SCx200_I2C_SDA
+	int "GPIO pin used for SDA"
+	depends on SCx200_I2C
+	default "13"
+	help
+	  Enter the GPIO pin number used for the SSA signal.  This value can
+	  also be specified with a module parameter.
+
+config SCx200_ACB
+	tristate "Geode ACCESS.bus support"
+	depends on X86_32 && PCI
 	help
-		This supports the use of the I2C interface(i2c0 ~ i2c3) on rk29 processors.
-
-if I2C_RK29
-	comment "Now, there are four I2C interfaces selected by developer."
-	
-	config I2C0_RK29
-		bool "RK29 I2C0 interface support"
-		default y
-		depends on ARCH_RK29
-		help
-			This supports the use of the I2C0 interface on rk29 processors.
-		if I2C0_RK29
-			choice
-				prompt "I2C transfer mode select"
-				config RK29_I2C0_CONTROLLER
-					bool "With i2c controller"
-				config RK29_I2C0_GPIO
-					select I2C_GPIO
-					bool "Simulation with GPIO"
-			endchoice
-		endif
-	config I2C1_RK29
-		bool "RK29 I2C1 interface support"
-		default y
-		depends on ARCH_RK29
-		help
-			This supports the use of the I2C1 interface on rk29 processors.
-		if I2C1_RK29
-			choice
-				prompt "I2C transfer mode select"
-				config RK29_I2C1_CONTROLLER
-					bool "With i2c controller"
-				config RK29_I2C1_GPIO
-					select I2C_GPIO
-					bool "Simulation with GPIO"
-			endchoice
-		endif
-
-	config I2C2_RK29
-		bool "RK29 I2C2 interface support"
-		default y
-		depends on ARCH_RK29
-		help
-			This supports the use of the I2C2 interface on rk29 processors.
-		if I2C2_RK29
-			choice
-				prompt "I2C transfer mode select"
-				config RK29_I2C2_CONTROLLER
-					bool "With i2c controller"
-				config RK29_I2C2_GPIO
-					select I2C_GPIO
-					bool "Simulation with GPIO"
-			endchoice
-		endif
-
-	config I2C3_RK29
-		bool "RK29 I2C3 interface support"
-		default y
-		depends on ARCH_RK29 && !UART3_CTS_RTS_RK29
-		help
-			This supports the use of the I2C3 interface on rk29 processors.
-		if I2C3_RK29
-			choice
-				prompt "I2C transfer mode select"
-				config RK29_I2C3_CONTROLLER
-					bool "With i2c controller"
-				config RK29_I2C3_GPIO
-					select I2C_GPIO
-					bool "Simulation with GPIO"
-			endchoice
-		endif
-endif
-config I2C_DEV_RK29
-	tristate "RK29 I2C device interface support"
-		default n
-		depends on I2C_RK29
-		help
-			Nothing
+	  Enable the use of the ACCESS.bus controllers on the Geode SCx200 and
+	  SC1100 processors and the CS5535 and CS5536 Geode companion devices.
+
+	  If you don't know what to do here, say N.
+
+	  This support is also available as a module.  If so, the module
+	  will be called scx200_acb.
+
 endmenu
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 662633c19f95..e6cf294d3729 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -1,9 +1,6 @@
 #
 # Makefile for the i2c bus drivers.
 #
-obj-$(CONFIG_I2C_RK29)		+= i2c-rk29.o
-obj-$(CONFIG_I2C_DEV_RK29)	+= i2c-dev-rk29.o
-obj-$(CONFIG_I2C_RK30)		+= i2c-rk30.o i2c-rk29-adapter.o i2c-rk30-adapter.o
 
 # ACPI drivers
 obj-$(CONFIG_I2C_SCMI)		+= i2c-scmi.o
diff --git a/drivers/i2c/busses/i2c-gpio.c b/drivers/i2c/busses/i2c-gpio.c
index 49363163d52c..a651779d9ff7 100644
--- a/drivers/i2c/busses/i2c-gpio.c
+++ b/drivers/i2c/busses/i2c-gpio.c
@@ -88,8 +88,7 @@ static int __devinit i2c_gpio_probe(struct platform_device *pdev)
 	pdata = pdev->dev.platform_data;
 	if (!pdata)
 		return -ENXIO;
-	if(pdata->io_init)
-		pdata->io_init();
+
 	ret = -ENOMEM;
 	adap = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);
 	if (!adap)
diff --git a/drivers/i2c/i2c-boardinfo.c b/drivers/i2c/i2c-boardinfo.c
index a35251e2c8ec..3ca2e012e789 100644
--- a/drivers/i2c/i2c-boardinfo.c
+++ b/drivers/i2c/i2c-boardinfo.c
@@ -66,6 +66,7 @@ i2c_register_board_info(int busnum,
 	int status;
 
 	down_write(&__i2c_board_lock);
+
 	/* dynamic bus numbers will be assigned after the last static one */
 	if (busnum >= __i2c_first_dynamic_bus_num)
 		__i2c_first_dynamic_bus_num = busnum + 1;
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index 659e95aa2a8e..9a58994ff7ea 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -50,16 +50,10 @@ static DEFINE_MUTEX(core_lock);
 static DEFINE_IDR(i2c_adapter_idr);
 
 static struct device_type i2c_client_type;
-//static int i2c_check_addr(struct i2c_adapter *adapter, int addr);
-static int i2c_check_addr_ex(struct i2c_adapter *adapter, int addr);
 static int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver);
 
 /* ------------------------------------------------------------------------- */
-#ifdef CONFIG_I2C_DEV_RK29
-extern struct completion		i2c_dev_complete;
-extern void i2c_dev_dump_start(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
-extern void i2c_dev_dump_stop(struct i2c_adapter *adap, struct i2c_msg *msgs, int num, int ret);
-#endif
+
 static const struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,
 						const struct i2c_client *client)
 {
@@ -524,7 +518,6 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 	client->flags = info->flags;
 	client->addr = info->addr;
 	client->irq = info->irq;
-	client->udelay = info->udelay;  // add by kfx
 
 	strlcpy(client->name, info->type, sizeof(client->name));
 
@@ -537,38 +530,17 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 	}
 
 	/* Check for address business */
-    #if 0
 	status = i2c_check_addr_busy(adap, client->addr);
 	if (status)
 		goto out_err;
-    #else
-	/* ddl@rock-chips.com : Devices which have some i2c addr can work in same i2c bus, 
-	   if devices havn't work at the same time.*/
-	status = i2c_check_addr_ex(adap, client->addr);
-	if (status != 0)
-		dev_err(&adap->dev, "%d i2c clients have been registered at 0x%02x",
-			status, client->addr);   
-    #endif
 
 	client->dev.parent = &client->adapter->dev;
 	client->dev.bus = &i2c_bus_type;
 	client->dev.type = &i2c_client_type;
 	client->dev.of_node = info->of_node;
 
-    /* ddl@rock-chips.com : Devices which have some i2c addr can work in same i2c bus, 
-      if devices havn't work at the same time.*/
-    #if 0
-    dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
-    		     client->addr);
-    #else
-    if (status == 0)
-    	dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
-    		     client->addr);
-    else 
-        dev_set_name(&client->dev, "%d-%04x-%01x", i2c_adapter_id(adap),
-    		     client->addr,status);
-    #endif
-    
+	dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
+		     client->addr);
 	status = device_register(&client->dev);
 	if (status)
 		goto out_err;
@@ -587,144 +559,6 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 }
 EXPORT_SYMBOL_GPL(i2c_new_device);
 
-#ifdef CONFIG_PLAT_RK
-#define RK610_KEY       "rk610"
-static int __i2c_client_print(struct device *dev, void *param)
-{
-        struct i2c_client *client = i2c_verify_client(dev);
-
-        if(client)
-                printk(KERN_WARNING "client: %s, addr: 0x%x\n", client->name, client->addr);
-        return 0;
-}
-static int __i2c_check_rk610_ex(struct device *dev, void *ex)
-{
-        struct i2c_client *client = i2c_verify_client(dev);
-
-        if(!client)
-                return 0;
-
-        if(strstr(client->name, RK610_KEY) != NULL)
-                *(int *)ex += 1 << 8;
-        else
-                *(int *)ex += 1;
-        return 0;
-}
-int i2c_check_rk610_ex(int nr)
-{
-        int ex = 0, rk610_ex = 0, oth_ex = 0;
-        struct i2c_adapter *adap = i2c_get_adapter(nr);
-
-        if(!adap){
-                printk(KERN_ERR "%s: adap(%d) is not exist\n", __func__, nr);
-                return -EINVAL;
-        }
-        device_for_each_child(&adap->dev, &ex, __i2c_check_rk610_ex);
-
-        if(ex & (1 << 8))
-                rk610_ex = 1;
-
-        oth_ex = ex & 0xff;
-
-        if(rk610_ex && oth_ex){
-                ex = 1;
-                printk(KERN_WARNING "******************* WARNING ********************\n");
-                dev_warn(&adap->dev, "%s is exist, clients:\n", RK610_KEY);
-                device_for_each_child(&adap->dev, NULL, __i2c_client_print);
-                printk(KERN_WARNING "************************************************\n");
-        }
-        else 
-                ex = 0;
-        return ex;
-}
-#else
-int i2c_check_rk610_ex(int nr)
-{
-        return 0;
-}
-#endif //end of CONFIG_PLAT_RK
-EXPORT_SYMBOL_GPL(i2c_check_rk610_ex);
-
-#ifdef CONFIG_I2C_RK30
-int i2c_add_device(int nr, struct i2c_board_info const *info)
-{
-	int			status;
-	struct i2c_client	*client;
-        struct i2c_adapter *adap = i2c_get_adapter(nr);
-        
-        if(!adap){
-                printk(KERN_ERR "%s: adap(%d) is not exist\n", __func__, nr);
-                return -EINVAL;
-        }
-
-	client = kzalloc(sizeof *client, GFP_KERNEL);
-	if (!client){
-                dev_err(&adap->dev, "no memory for client\n");
-		return -ENOMEM;
-        }
-
-	client->adapter = adap;
-
-	client->dev.platform_data = info->platform_data;
-
-	if (info->archdata)
-		client->dev.archdata = *info->archdata;
-
-	client->flags = info->flags;
-	client->addr = info->addr;
-	client->irq = info->irq;
-	client->udelay = info->udelay;  // add by kfx
-
-	strlcpy(client->name, info->type, sizeof(client->name));
-
-	/* Check for address validity */
-	status = i2c_check_client_addr_validity(client);
-	if (status) {
-		dev_err(&adap->dev, "Invalid %d-bit I2C address 0x%02hx\n",
-			client->flags & I2C_CLIENT_TEN ? 10 : 7, client->addr);
-		goto out_err_silent;
-	}
-
-	/* Check for address business */
-	status = i2c_check_addr_busy(adap, client->addr);
-	if (status){
-                status = -EEXIST;
-		dev_warn(&adap->dev, "i2c clients have been registered at 0x%02x\n", client->addr);   
-		goto out_err_silent;
-        }
-
-	client->dev.parent = &client->adapter->dev;
-	client->dev.bus = &i2c_bus_type;
-	client->dev.type = &i2c_client_type;
-	client->dev.of_node = info->of_node;
-
-        dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
-    		     client->addr);
-    
-	status = device_register(&client->dev);
-	if (status)
-		goto out_err;
-
-	dev_dbg(&adap->dev, "client [%s] registered with bus id %s\n",
-		client->name, dev_name(&client->dev));
-
-	return 0;
-
-out_err:
-	dev_err(&adap->dev, "Failed to register i2c client %s at 0x%02x "
-		"(%d)\n", client->name, client->addr, status);
-out_err_silent:
-	kfree(client);
-	return status;
-}
-#else
-int i2c_add_device(int nr, struct i2c_board_info const *info)
-{
-        return 0;
-}
-#endif //end of CONFIG_I2C_RK30
-EXPORT_SYMBOL_GPL(i2c_add_device);
-
 
 /**
  * i2c_unregister_device - reverse effect of i2c_new_device()
@@ -1347,34 +1181,6 @@ EXPORT_SYMBOL(i2c_del_driver);
 
 /* ------------------------------------------------------------------------- */
 
-/* ddl@rock-chips.com : Devices which have some i2c addr can work in same i2c bus, 
-      if devices havn't work at the same time.*/
-struct i2c_addr_cnt
-{
-    int addr;
-    int cnt;
-};
-static int __i2c_check_addr_ex(struct device *dev, void *addrp)
-{
-	struct i2c_client	*client = i2c_verify_client(dev);
-	struct i2c_addr_cnt *addrinfo = (struct i2c_addr_cnt *)addrp;
-    int addr = addrinfo->addr;
-
-	if (client && client->addr == addr) {
-		addrinfo->cnt++;
-	}
-	return 0;
-}
-static int i2c_check_addr_ex(struct i2c_adapter *adapter, int addr)
-{
-    struct i2c_addr_cnt addrinfo;
-
-    addrinfo.addr = addr;
-    addrinfo.cnt = 0;
-    device_for_each_child(&adapter->dev, &addrinfo, __i2c_check_addr_ex);
-    return addrinfo.cnt;
-}
-
 /**
  * i2c_use_client - increments the reference count of the i2c client structure
  * @client: the client being referenced
@@ -1449,10 +1255,6 @@ static int __init i2c_init(void)
 	retval = i2c_add_driver(&dummy_driver);
 	if (retval)
 		goto class_err;
-#ifdef CONFIG_I2C_DEV_RK29
-		init_completion(&i2c_dev_complete);
-#endif
-
 	return 0;
 
 class_err:
@@ -1527,11 +1329,8 @@ int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 				(msgs[ret].flags & I2C_M_RECV_LEN) ? "+" : "");
 		}
 #endif
-#if defined (CONFIG_I2C_RK2818) || defined(CONFIG_I2C_RK29)
-		if (!(i2c_suspended(adap)) && (in_atomic() || irqs_disabled())) {
-#else
+
 		if (in_atomic() || irqs_disabled()) {
-#endif
 			ret = i2c_trylock_adapter(adap);
 			if (!ret)
 				/* I2C activity is ongoing. */
@@ -1542,21 +1341,13 @@ int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 
 		/* Retry automatically on arbitration loss */
 		orig_jiffies = jiffies;
-#ifdef CONFIG_I2C_DEV_RK29
-	i2c_dev_dump_start(adap, msgs, num);
-#endif
 		for (ret = 0, try = 0; try <= adap->retries; try++) {
 			ret = adap->algo->master_xfer(adap, msgs, num);
 			if (ret != -EAGAIN)
 				break;
-		        dev_err(&adap->dev, "No ack, Maybe slave(addr: 0x%x) not exist or abnormal power-on, retry %d...\n", 
-                                        msgs[0].addr, adap->retries - try);
 			if (time_after(jiffies, orig_jiffies + adap->timeout))
 				break;
 		}
-#ifdef CONFIG_I2C_DEV_RK29
-	i2c_dev_dump_stop(adap, msgs, num ,ret);
-#endif
 		i2c_unlock_adapter(adap);
 
 		return ret;
@@ -1567,240 +1358,6 @@ int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 }
 EXPORT_SYMBOL(i2c_transfer);
 
-#ifdef CONFIG_PLAT_RK
-int i2c_master_send(const struct i2c_client *client, const char *buf, int count)
-{
-	int ret;
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msg;
-
-	msg.addr = client->addr;
-	msg.flags = client->flags;
-	msg.len = count;
-	msg.buf = (char *)buf;
-	msg.scl_rate = 100 * 1000;
-	msg.udelay = client->udelay;
-
-	ret = i2c_transfer(adap, &msg, 1);
-	return (ret == 1) ? count : ret;
-}
-EXPORT_SYMBOL(i2c_master_send);
-
-int i2c_master_recv(const struct i2c_client *client, char *buf, int count)
-{
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msg;
-	int ret;
-
-	msg.addr = client->addr;
-	msg.flags = client->flags | I2C_M_RD;
-	msg.len = count;
-	msg.buf = (char *)buf;
-	msg.scl_rate = 100 * 1000;
-	msg.udelay = client->udelay;
-
-	ret = i2c_transfer(adap, &msg, 1);
-
-	return (ret == 1) ? count : ret;
-}
-EXPORT_SYMBOL(i2c_master_recv);
-
-int i2c_master_normal_send(const struct i2c_client *client, const char *buf, int count, int scl_rate)
-{
-	int ret;
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msg;
-
-	msg.addr = client->addr;
-	msg.flags = client->flags;
-	msg.len = count;
-	msg.buf = (char *)buf;
-	msg.scl_rate = scl_rate;
-	msg.udelay = client->udelay;
-
-	ret = i2c_transfer(adap, &msg, 1);
-	return (ret == 1) ? count : ret;
-}
-EXPORT_SYMBOL(i2c_master_normal_send);
-
-int i2c_master_normal_recv(const struct i2c_client *client, char *buf, int count, int scl_rate)
-{
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msg;
-	int ret;
-
-	msg.addr = client->addr;
-	msg.flags = client->flags | I2C_M_RD;
-	msg.len = count;
-	msg.buf = (char *)buf;
-	msg.scl_rate = scl_rate;
-	msg.udelay = client->udelay;
-
-	ret = i2c_transfer(adap, &msg, 1);
-
-	return (ret == 1) ? count : ret;
-}
-EXPORT_SYMBOL(i2c_master_normal_recv);
-
-int i2c_master_reg8_send(const struct i2c_client *client, const char reg, const char *buf, int count, int scl_rate)
-{
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msg;
-	int ret;
-	char *tx_buf = (char *)kmalloc(count + 1, GFP_KERNEL);
-	if(!tx_buf)
-		return -ENOMEM;
-	tx_buf[0] = reg;
-	memcpy(tx_buf+1, buf, count); 
-
-	msg.addr = client->addr;
-	msg.flags = client->flags;
-	msg.len = count + 1;
-	msg.buf = (char *)tx_buf;
-	msg.scl_rate = scl_rate;
-	msg.udelay = client->udelay;
-
-	ret = i2c_transfer(adap, &msg, 1);
-	kfree(tx_buf);
-	return (ret == 1) ? count : ret;
-
-}
-EXPORT_SYMBOL(i2c_master_reg8_send);
-
-int i2c_master_reg8_recv(const struct i2c_client *client, const char reg, char *buf, int count, int scl_rate)
-{
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msgs[2];
-	int ret;
-	char reg_buf = reg;
-	
-	msgs[0].addr = client->addr;
-	msgs[0].flags = client->flags;
-	msgs[0].len = 1;
-	msgs[0].buf = &reg_buf;
-	msgs[0].scl_rate = scl_rate;
-	msgs[0].udelay = client->udelay;
-
-	msgs[1].addr = client->addr;
-	msgs[1].flags = client->flags | I2C_M_RD;
-	msgs[1].len = count;
-	msgs[1].buf = (char *)buf;
-	msgs[1].scl_rate = scl_rate;
-	msgs[1].udelay = client->udelay;
-
-	ret = i2c_transfer(adap, msgs, 2);
-
-	return (ret == 2)? count : ret;
-}
-
-EXPORT_SYMBOL(i2c_master_reg8_recv);
-
-int i2c_master_reg8_direct_send(const struct i2c_client *client, const char reg, const char *buf, int count, int scl_rate)
-{
-	return i2c_master_reg8_send(client, reg, buf, count, scl_rate);
-}
-EXPORT_SYMBOL(i2c_master_reg8_direct_send);
-
-int i2c_master_reg8_direct_recv(const struct i2c_client *client, const char reg, char *buf, int count, int scl_rate)
-{
-#ifdef CONFIG_ARCH_RK29
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msg;
-	int ret;
-	char tx_buf[count+1];
-	
-	tx_buf[0] = reg;
-	msg.addr = client->addr;
-	msg.flags = client->flags | I2C_M_REG8_DIRECT | I2C_M_RD;
-	msg.len = count + 1;
-	msg.buf = tx_buf;
-	msg.scl_rate = scl_rate;
-	msg.udelay = client->udelay;
-
-	ret = i2c_transfer(adap, &msg, 1);
-	memcpy(buf, tx_buf + 1, count);
-	return (ret == 1) ? count : ret;
-#else
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msgs[2];
-	int ret;
-	char reg_buf = reg;
-	
-	msgs[0].addr = client->addr;
-	msgs[0].flags = client->flags | I2C_M_RD;
-	msgs[0].len = 1;
-	msgs[0].buf = &reg_buf;
-	msgs[0].scl_rate = scl_rate;
-	msgs[0].udelay = client->udelay;
-
-	msgs[1].addr = client->addr;
-	msgs[1].flags = client->flags | I2C_M_RD;
-	msgs[1].len = count;
-	msgs[1].buf = (char *)buf;
-	msgs[1].scl_rate = scl_rate;
-	msgs[1].udelay = client->udelay;
-
-	ret = i2c_transfer(adap, msgs, 2);
-
-	return (ret == 2)? count : ret;
-#endif
-}
-EXPORT_SYMBOL(i2c_master_reg8_direct_recv);
-
-int i2c_master_reg16_send(const struct i2c_client *client, const short regs, const short *buf, int count, int scl_rate)
-{
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msg;
-	int ret;
-	char *tx_buf = (char *)kmalloc(2 * (count + 1), GFP_KERNEL);
-	if(!tx_buf)
-		return -ENOMEM;
-	memcpy(tx_buf, &regs, 2); 
-	memcpy(tx_buf+2, (char *)buf, count * 2); 
-
-	msg.addr = client->addr;
-	msg.flags = client->flags;
-	msg.len = 2 * (count + 1);
-	msg.buf = (char *)tx_buf;
-	msg.scl_rate = scl_rate;
-	msg.udelay = client->udelay;
-
-	ret = i2c_transfer(adap, &msg, 1);
-	kfree(tx_buf);
-	return (ret == 1) ? count : ret;
-}
-EXPORT_SYMBOL(i2c_master_reg16_send);
-
-int i2c_master_reg16_recv(const struct i2c_client *client, const short regs, short *buf, int count, int scl_rate)
-{
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msgs[2];
-	int ret;
-	char reg_buf[2];
-
-	memcpy(reg_buf, &regs, 2);
-
-	msgs[0].addr = client->addr;
-	msgs[0].flags = client->flags;
-	msgs[0].len = 2;
-	msgs[0].buf = reg_buf;
-	msgs[0].scl_rate = scl_rate;
-	msgs[0].udelay = client->udelay;
-
-	msgs[1].addr = client->addr;
-	msgs[1].flags = client->flags | I2C_M_RD;
-	msgs[1].len = count * 2;
-	msgs[1].buf = (char *)buf;
-	msgs[1].scl_rate = scl_rate;
-	msgs[1].udelay = client->udelay;
-
-	ret = i2c_transfer(adap, msgs, 2);
-
-	return (ret == 2)? count : ret;
-}
-EXPORT_SYMBOL(i2c_master_reg16_recv);
-#else
-
 /**
  * i2c_master_send - issue a single I2C message in master transmit mode
  * @client: Handle to slave device
@@ -1855,7 +1412,7 @@ int i2c_master_recv(const struct i2c_client *client, char *buf, int count)
 	return (ret == 1) ? count : ret;
 }
 EXPORT_SYMBOL(i2c_master_recv);
-#endif
+
 /* ----------------------------------------------------
  * the i2c address scanning function
  * Will not work for 10-bit addresses!
@@ -2363,8 +1920,8 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
 	unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];
 	unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];
 	int num = read_write == I2C_SMBUS_READ ? 2 : 1;
-	struct i2c_msg msg[2] = { { addr, flags, 1, msgbuf0, 100000, 0, 0 },
-	                          { addr, flags | I2C_M_RD, 0, msgbuf1, 100000, 0, 0 }
+	struct i2c_msg msg[2] = { { addr, flags, 1, msgbuf0 },
+	                          { addr, flags | I2C_M_RD, 0, msgbuf1 }
 	                        };
 	int i;
 	u8 partial_pec = 0;
diff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c
index b5cc98e9716a..c90ce50b619f 100644
--- a/drivers/i2c/i2c-dev.c
+++ b/drivers/i2c/i2c-dev.c
@@ -52,12 +52,6 @@ struct i2c_dev {
 	struct i2c_adapter *adap;
 	struct device *dev;
 };
-struct i2c_msg_old{
-        __u16 addr;
-        __u16 flags;
-        __u16 len;
-        __u8 *buf;
-};
 
 #define I2C_MINORS	256
 static LIST_HEAD(i2c_dev_list);
@@ -238,41 +232,7 @@ static int i2cdev_check_addr(struct i2c_adapter *adapter, unsigned int addr)
 
 	return result;
 }
-static int copy_i2c_msg_from_user(struct i2c_rdwr_ioctl_data rdwr_arg, struct i2c_msg *rdwr_pa)
-{
-        int i;
-#if 0
-	if (copy_from_user(rdwr_pa, rdwr_arg.msgs,
-			   rdwr_arg.nmsgs * sizeof(struct i2c_msg))) {
-#else
-        if(1) {
-#endif
-	        struct i2c_msg_old *rdwr_pa_old;
-
-
-	        rdwr_pa_old = kmalloc(rdwr_arg.nmsgs * sizeof(struct i2c_msg_old), GFP_KERNEL);
-	        if (!rdwr_pa_old)
-		        return -ENOMEM;
-	        if (copy_from_user(rdwr_pa_old, rdwr_arg.msgs,
-			        rdwr_arg.nmsgs * sizeof(struct i2c_msg_old))) {
-		        kfree(rdwr_pa_old);
-		        return -EFAULT;
-                }else{
-                        for(i = 0; i < rdwr_arg.nmsgs; i++){
-                                rdwr_pa[i].addr = rdwr_pa_old[i].addr;
-                                rdwr_pa[i].flags = rdwr_pa_old[i].flags;
-                                rdwr_pa[i].len = rdwr_pa_old[i].len;
-                                rdwr_pa[i].buf = rdwr_pa_old[i].buf;
-                        }
-                        kfree(rdwr_pa_old);
-                        return 0;
-                
-                }
-        }
-
-        return 0;
 
-}
 static noinline int i2cdev_ioctl_rdrw(struct i2c_client *client,
 		unsigned long arg)
 {
@@ -294,15 +254,13 @@ static noinline int i2cdev_ioctl_rdrw(struct i2c_client *client,
 	rdwr_pa = kmalloc(rdwr_arg.nmsgs * sizeof(struct i2c_msg), GFP_KERNEL);
 	if (!rdwr_pa)
 		return -ENOMEM;
-#ifdef CONFIG_PLAT_RK
-	if ((res = copy_i2c_msg_from_user(rdwr_arg, rdwr_pa)) < 0) {
+
+	if (copy_from_user(rdwr_pa, rdwr_arg.msgs,
+			   rdwr_arg.nmsgs * sizeof(struct i2c_msg))) {
 		kfree(rdwr_pa);
-		return res;
+		return -EFAULT;
 	}
-#else
-        if (copy_from_user(rdwr_pa, rdwr_arg.msgs,
-                        rdwr_arg.nmsgs * sizeof(struct i2c_msg))) {
-#endif
+
 	data_ptrs = kmalloc(rdwr_arg.nmsgs * sizeof(u8 __user *), GFP_KERNEL);
 	if (data_ptrs == NULL) {
 		kfree(rdwr_pa);
@@ -324,7 +282,6 @@ static noinline int i2cdev_ioctl_rdrw(struct i2c_client *client,
 			res = PTR_ERR(rdwr_pa[i].buf);
 			break;
 		}
-                rdwr_pa[i].scl_rate = 100 * 1000;
 	}
 	if (res < 0) {
 		int j;
@@ -334,16 +291,8 @@ static noinline int i2cdev_ioctl_rdrw(struct i2c_client *client,
 		kfree(rdwr_pa);
 		return res;
 	}
-#ifdef CONFIG_PLAT_RK
-        for(i = 0; i < rdwr_arg.nmsgs; i++){
-	        res = i2c_transfer(client->adapter, &rdwr_pa[i], 1);
-                if(res < 0)
-                        break;
-        }
-#else
-        res = i2c_transfer(client->adapter, rdwr_pa, rdwr_arg.nmsgs);
-
-#endif
+
+	res = i2c_transfer(client->adapter, rdwr_pa, rdwr_arg.nmsgs);
 	while (i-- > 0) {
 		if (res >= 0 && (rdwr_pa[i].flags & I2C_M_RD)) {
 			if (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,
diff --git a/drivers/input/Kconfig b/drivers/input/Kconfig
index 6d23a32aa1f4..c0e639c1b179 100644
--- a/drivers/input/Kconfig
+++ b/drivers/input/Kconfig
@@ -182,23 +182,8 @@ source "drivers/input/tablet/Kconfig"
 
 source "drivers/input/touchscreen/Kconfig"
 
-source "drivers/input/ts/Kconfig"
-
 source "drivers/input/misc/Kconfig"
 
-source "drivers/input/magnetometer/Kconfig"
-
-source "drivers/input/gsensor/Kconfig"
-
-source "drivers/input/gyroscope/Kconfig"
-
-source "drivers/input/jogball/Kconfig"
-
-source "drivers/input/lightsensor/Kconfig"
-
-source "drivers/input/sensors/Kconfig"
-
-source "drivers/input/remotectl/Kconfig"
 endif
 
 menu "Hardware I/O ports"
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index 8ebc120ba3e5..5d4593d3101d 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -22,15 +22,6 @@ obj-$(CONFIG_INPUT_JOYSTICK)	+= joystick/
 obj-$(CONFIG_INPUT_TABLET)	+= tablet/
 obj-$(CONFIG_INPUT_TOUCHSCREEN)	+= touchscreen/
 obj-$(CONFIG_INPUT_MISC)	+= misc/
-obj-$(CONFIG_G_SENSOR_DEVICE)	+= gsensor/
-obj-$(CONFIG_GYRO_SENSOR_DEVICE)	+= gyroscope/
-obj-$(CONFIG_INPUT_JOGBALL)	+= jogball/
-obj-$(CONFIG_LIGHT_SENSOR_DEVICE) += lightsensor/
-obj-$(CONFIG_MAG_SENSORS)	+= magnetometer/
-
-obj-$(CONFIG_SENSOR_DEVICE)	+= sensors/
-obj-$(CONFIG_TS_AUTO)	+= ts/
 
 obj-$(CONFIG_INPUT_APMPOWER)	+= apm-power.o
 obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
-obj-$(CONFIG_ROCKCHIP_REMOTECTL) +=remotectl/
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index f356187b1d1e..b4dee9d5a055 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -12,19 +12,6 @@ menuconfig INPUT_KEYBOARD
 
 if INPUT_KEYBOARD
 
-config KEYS_RK29
-	tristate "rk29 keyboard"
-	depends on PLAT_RK
-	default y
-	help
-	  rk29 keyboard drivers(gpio and adc)
-
-config SYNAPTICS_SO340010
-	tristate "Synaptics So340010 TouchPad KEY"
-	depends on I2C
-	help
-	  Synaptics So340010 Touch Key (I2C) driver
-
 config KEYBOARD_ADP5520
 	tristate "Keypad Support for ADP5520 PMIC"
 	depends on PMIC_ADP5520
@@ -216,21 +203,6 @@ config KEYBOARD_GPIO_POLLED
 	  To compile this driver as a module, choose M here: the
 	  module will be called gpio_keys_polled.
 
-config KEYBOARD_WM831X_GPIO
-	tristate "WM831X_GPIO Buttons"
-	depends on GENERIC_GPIO
-	help
-	  This driver implements support for buttons connected
-	  to GPIO pins of various CPUs (and some other chips).
-
-	  Say Y here if your device has buttons connected
-	  directly to such GPIO pins.  Your board-specific
-	  setup logic must also provide a platform device,
-	  with configuration data saying which GPIOs are used.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called wm831x_gpio_keys.
-
 config KEYBOARD_TCA6416
 	tristate "TCA6416/TCA6408A Keypad Support"
 	depends on I2C
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index 8cdebfbcd812..ddde0fd476f7 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -4,7 +4,6 @@
 
 # Each configuration option enables a list of files.
 
-obj-$(CONFIG_KEYS_RK29)			+= rk29_keys.o
 obj-$(CONFIG_KEYBOARD_ADP5520)		+= adp5520-keys.o
 obj-$(CONFIG_KEYBOARD_ADP5588)		+= adp5588-keys.o
 obj-$(CONFIG_KEYBOARD_ADP5589)		+= adp5589-keys.o
@@ -16,7 +15,6 @@ obj-$(CONFIG_KEYBOARD_DAVINCI)		+= davinci_keyscan.o
 obj-$(CONFIG_KEYBOARD_EP93XX)		+= ep93xx_keypad.o
 obj-$(CONFIG_KEYBOARD_GPIO)		+= gpio_keys.o
 obj-$(CONFIG_KEYBOARD_GPIO_POLLED)	+= gpio_keys_polled.o
-obj-$(CONFIG_KEYBOARD_WM831X_GPIO)	+= wm831x_gpio_keys.o
 obj-$(CONFIG_KEYBOARD_TCA6416)		+= tca6416-keypad.o
 obj-$(CONFIG_KEYBOARD_HIL)		+= hil_kbd.o
 obj-$(CONFIG_KEYBOARD_HIL_OLD)		+= hilkbd.o
@@ -53,4 +51,3 @@ obj-$(CONFIG_KEYBOARD_TNETV107X)	+= tnetv107x-keypad.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
-obj-$(CONFIG_SYNAPTICS_SO340010)        += synaptics_so340010.o
diff --git a/drivers/input/keyboard/matrix_keypad.c b/drivers/input/keyboard/matrix_keypad.c
index f6508aa80d41..b02e4268e18f 100644
--- a/drivers/input/keyboard/matrix_keypad.c
+++ b/drivers/input/keyboard/matrix_keypad.c
@@ -48,14 +48,13 @@ struct matrix_keypad {
 static void __activate_col(const struct matrix_keypad_platform_data *pdata,
 			   int col, bool on)
 {
-	// bool level_on = !pdata->active_low;
-	bool level_on = pdata->active_low;
+	bool level_on = !pdata->active_low;
 
 	if (on) {
 		gpio_direction_output(pdata->col_gpios[col], level_on);
 	} else {
 		gpio_set_value_cansleep(pdata->col_gpios[col], !level_on);
-		//gpio_direction_input(pdata->col_gpios[col]);
+		gpio_direction_input(pdata->col_gpios[col]);
 	}
 }
 
@@ -115,14 +114,13 @@ static void disable_row_irqs(struct matrix_keypad *keypad)
  */
 static void matrix_keypad_scan(struct work_struct *work)
 {
-
 	struct matrix_keypad *keypad =
 		container_of(work, struct matrix_keypad, work.work);
 	struct input_dev *input_dev = keypad->input_dev;
 	const struct matrix_keypad_platform_data *pdata = keypad->pdata;
 	uint32_t new_state[MATRIX_MAX_COLS];
 	int row, col, code;
-#if 1
+
 	/* de-activate all columns for scanning */
 	activate_all_cols(pdata, false);
 
@@ -135,16 +133,11 @@ static void matrix_keypad_scan(struct work_struct *work)
 
 		for (row = 0; row < pdata->num_row_gpios; row++)
 			new_state[col] |=
-		//	new_state[col] &=
-		//		row_asserted(pdata, row) ? (1 << row) : 0;
-				row_asserted(pdata, row) ? 0: (1 << row) ;
-
-              //printk("matrix_keypad_scan: new_state[0]=0x%x,new_state[1]=0x%x,new_state[2]=0x%x,new_state[3]=0x%x \n",new_state[0] ,new_state[1] ,new_state[2] ,new_state[3]);
-            //  printk("matrix_keypad_scan: row0=0x%x,row1=0x%x,row2=0x%x,row3=0x%x \n",row_asserted(pdata, 0),row_asserted(pdata, 1),row_asserted(pdata, 2),row_asserted(pdata,3));
+				row_asserted(pdata, row) ? (1 << row) : 0;
 
 		activate_col(pdata, col, false);
 	}
-   
+
 	for (col = 0; col < pdata->num_col_gpios; col++) {
 		uint32_t bits_changed;
 
@@ -157,16 +150,12 @@ static void matrix_keypad_scan(struct work_struct *work)
 				continue;
 
 			code = MATRIX_SCAN_CODE(row, col, keypad->row_shift);
-			//printk("matrix_keypad_scan: MATRIX_SCAN_CODE = 0x%x \n",code);
 			input_event(input_dev, EV_MSC, MSC_SCAN, code);
-		       input_report_key(input_dev,
+			input_report_key(input_dev,
 					 keypad->keycodes[code],
 					 new_state[col] & (1 << row));
-			//printk("matrix_keypad_scan:input_report_key- keypad->keycodes[code] = 0x%x,state=0x%x \n", keypad->keycodes[code], new_state[col] & (1 << row));
-		
 		}
-	}	
-
+	}
 	input_sync(input_dev);
 
 	memcpy(keypad->last_key_state, new_state, sizeof(new_state));
@@ -178,17 +167,6 @@ static void matrix_keypad_scan(struct work_struct *work)
 	keypad->scan_pending = false;
 	enable_row_irqs(keypad);
 	spin_unlock_irq(&keypad->lock);
-	
-#else
-	//activate_all_cols(pdata, false);
-       activate_all_cols(pdata, true);
-       //row_asserted(pdata, 0);
-	/* Enable IRQs again */
-	spin_lock_irq(&keypad->lock);
-	keypad->scan_pending = false;
-	enable_row_irqs(keypad);
-	spin_unlock_irq(&keypad->lock);
-#endif
 }
 
 static irqreturn_t matrix_keypad_interrupt(int irq, void *id)
@@ -196,8 +174,6 @@ static irqreturn_t matrix_keypad_interrupt(int irq, void *id)
 	struct matrix_keypad *keypad = id;
 	unsigned long flags;
 
-       //printk("enter matrix_keypad_interrupt \n");
-	   
 	spin_lock_irqsave(&keypad->lock, flags);
 
 	/*
@@ -208,7 +184,7 @@ static irqreturn_t matrix_keypad_interrupt(int irq, void *id)
 	if (unlikely(keypad->scan_pending || keypad->stopped))
 		goto out;
 
-       disable_row_irqs(keypad);
+	disable_row_irqs(keypad);
 	keypad->scan_pending = true;
 	schedule_delayed_work(&keypad->work,
 		msecs_to_jiffies(keypad->pdata->debounce_ms));
@@ -338,12 +314,9 @@ static int __devinit init_matrix_gpio(struct platform_device *pdev,
 			goto err_free_cols;
 		}
 
-		//gpio_direction_output(pdata->col_gpios[i], !pdata->active_low);
-		gpio_direction_output(pdata->col_gpios[i], pdata->active_low);
+		gpio_direction_output(pdata->col_gpios[i], !pdata->active_low);
 	}
 
-       //printk("init_matrix_gpio:pdata->active_low = 0x%x \n",pdata->active_low);
-	   
 	for (i = 0; i < pdata->num_row_gpios; i++) {
 		err = gpio_request(pdata->row_gpios[i], "matrix_kbd_row");
 		if (err) {
@@ -370,7 +343,7 @@ static int __devinit init_matrix_gpio(struct platform_device *pdev,
 		for (i = 0; i < pdata->num_row_gpios; i++) {
 			err = request_irq(gpio_to_irq(pdata->row_gpios[i]),
 					matrix_keypad_interrupt,
-					/* IRQF_DISABLED | */
+					IRQF_DISABLED |
 					IRQF_TRIGGER_RISING |
 					IRQF_TRIGGER_FALLING,
 					"matrix-keypad", keypad);
@@ -413,7 +386,6 @@ static int __devinit matrix_keypad_probe(struct platform_device *pdev)
 	unsigned int row_shift;
 	int err;
 
-	   
 	pdata = pdev->dev.platform_data;
 	if (!pdata) {
 		dev_err(&pdev->dev, "no platform data defined\n");
@@ -476,8 +448,6 @@ static int __devinit matrix_keypad_probe(struct platform_device *pdev)
 	device_init_wakeup(&pdev->dev, pdata->wakeup);
 	platform_set_drvdata(pdev, keypad);
 
-       printk(KERN_INFO "matrix keypad: driver initialized\n");
-	   
 	return 0;
 
 err_free_mem:
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 7be2f09d8862..6f4ad1a7c3ee 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -12,15 +12,6 @@ menuconfig INPUT_MISC
 
 if INPUT_MISC
 
-config INPUT_LPSENSOR_ISL29028
-	tristate "isl29028 l/p sensor input support"
-
-config INPUT_LPSENSOR_CM3602
-	tristate "l/p sensor input support"
-
-config INPUT_LPSENSOR_AL3006
-	tristate "al3006 l/p sensor input support"
-
 config INPUT_88PM860X_ONKEY
 	tristate "88PM860x ONKEY support"
 	depends on MFD_88PM860X
@@ -284,26 +275,6 @@ config INPUT_TWL4030_PWRBUTTON
 	  To compile this driver as a module, choose M here. The module will
 	  be called twl4030_pwrbutton.
 
-config INPUT_TWL6030_PWRBUTTON
-	tristate "TWL6030 Power button Driver"
-	depends on TWL4030_CORE
-	help
-	  Say Y here if you want to enable power key reporting via the
-	  TWL6030 family of chips.
-
-	  To compile this driver as a module, choose M here. The module will
-	  be called twl6030_pwrbutton.
-
-config INPUT_RICOH619_PWRKEY
-	tristate "RICOH RC5T619 PMU PWRKEY driver"
-	depends on MFD_RICOH619
-	default n
-	help
-	  If you say yes here you get support for the RICOH RC5T619 PWRKEY module.
-
-	  This driver can also be built as a module. If so, the module
-	  will be called rc5t619-pwrkey.
-
 config INPUT_TWL4030_VIBRA
 	tristate "Support for TWL4030 Vibrator"
 	depends on TWL4030_CORE
@@ -339,11 +310,6 @@ config INPUT_GPIO
 	help
 	  Say Y here if you want to support gpio based keys, wheels etc...
 
-
-config RK_BOARD_ID
-	tristate "get board id support"
-
-
 config HP_SDC_RTC
 	tristate "HP SDC Real Time Clock"
 	depends on (GSC || HP300) && SERIO
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 5f331355adb6..eb73834150b7 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -4,8 +4,6 @@
 
 # Each configuration option enables a list of files.
 
-obj-$(CONFIG_INPUT_LPSENSOR_CM3602)	+= capella_cm3602.o
-obj-$(CONFIG_INPUT_LPSENSOR_ISL29028)	+= isl29028.o
 obj-$(CONFIG_INPUT_88PM860X_ONKEY)	+= 88pm860x_onkey.o
 obj-$(CONFIG_INPUT_AB8500_PONKEY)	+= ab8500-ponkey.o
 obj-$(CONFIG_INPUT_AD714X)		+= ad714x.o
@@ -25,7 +23,6 @@ obj-$(CONFIG_INPUT_CMA3000_I2C)		+= cma3000_d0x_i2c.o
 obj-$(CONFIG_INPUT_COBALT_BTNS)		+= cobalt_btns.o
 obj-$(CONFIG_INPUT_DM355EVM)		+= dm355evm_keys.o
 obj-$(CONFIG_INPUT_GPIO)		+= gpio_event.o gpio_matrix.o gpio_input.o gpio_output.o gpio_axis.o
-obj-$(CONFIG_RK_BOARD_ID)		+= rk_board_id.o
 obj-$(CONFIG_HP_SDC_RTC)		+= hp_sdc_rtc.o
 obj-$(CONFIG_INPUT_IXP4XX_BEEPER)	+= ixp4xx-beeper.o
 obj-$(CONFIG_INPUT_KEYCHORD)		+= keychord.o
@@ -44,13 +41,10 @@ obj-$(CONFIG_INPUT_GPIO_ROTARY_ENCODER)	+= rotary_encoder.o
 obj-$(CONFIG_INPUT_SGI_BTNS)		+= sgi_btns.o
 obj-$(CONFIG_INPUT_SPARCSPKR)		+= sparcspkr.o
 obj-$(CONFIG_INPUT_TWL4030_PWRBUTTON)	+= twl4030-pwrbutton.o
-obj-$(CONFIG_INPUT_TWL6030_PWRBUTTON)	+= twl6030-pwrbutton.o
 obj-$(CONFIG_INPUT_TWL4030_VIBRA)	+= twl4030-vibra.o
 obj-$(CONFIG_INPUT_UINPUT)		+= uinput.o
 obj-$(CONFIG_INPUT_WISTRON_BTNS)	+= wistron_btns.o
 obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
-obj-$(CONFIG_INPUT_LPSENSOR_AL3006)	+= al3006.o
-obj-$(CONFIG_INPUT_RICOH619_PWRKEY)	+= ricoh619-pwrkey.o
 
diff --git a/drivers/input/misc/wm831x-on.c b/drivers/input/misc/wm831x-on.c
index 54e0da091cef..c3d7ba5f5b47 100644
--- a/drivers/input/misc/wm831x-on.c
+++ b/drivers/input/misc/wm831x-on.c
@@ -27,126 +27,17 @@
 #include <linux/platform_device.h>
 #include <linux/workqueue.h>
 #include <linux/mfd/wm831x/core.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-#include <linux/delay.h>
-
-#if 0
-#define DBG(x...)   printk(x)
-#else
-#define DBG(x...)
-#endif 
 
 struct wm831x_on {
 	struct input_dev *dev;
 	struct delayed_work work;
 	struct wm831x *wm831x;
-	int flag_resume;
-	spinlock_t		flag_lock;
-	struct wake_lock 	wm831x_on_wake;
-};
-
-struct wm831x_on *g_wm831x_on;
-
-#ifndef CONFIG_KEYS_RK29
-void rk28_send_wakeup_key(void)
-{
-        printk("%s\n", __FUNCTION__);
-	if(!g_wm831x_on)
-	{
-		printk("%s:addr err!\n",__FUNCTION__);
-		return;
-	}
-        input_report_key(g_wm831x_on->dev, KEY_POWER, 1);
-        input_sync(g_wm831x_on->dev);
-        input_report_key(g_wm831x_on->dev, KEY_POWER, 0);
-        input_sync(g_wm831x_on->dev);
-        printk("%s end\n", __FUNCTION__);
-}
-#endif
-
-#if 1
-
-static int wm831x_on_suspend_noirq(struct device *dev)
-{
-	DBG("%s\n",__FUNCTION__);
-	
-	if(!g_wm831x_on)
-	{
-		printk("%s:addr err!\n",__FUNCTION__);
-		return -1;
-	}
-
-	spin_lock(&g_wm831x_on->flag_lock);
-	g_wm831x_on->flag_resume = 0;
-	spin_unlock(&g_wm831x_on->flag_lock);
-	return 0;
-}
-
-static int wm831x_on_resume_noirq(struct device *dev)
-{
-	//int poll, ret;
-	
-	if(!g_wm831x_on)
-	{
-		printk("%s:addr err!\n",__FUNCTION__);
-		return -1;
-	}
-	
-	spin_lock(&g_wm831x_on->flag_lock);
-	g_wm831x_on->flag_resume = 1;
-	spin_unlock(&g_wm831x_on->flag_lock);
-	
-#if 0	
-	ret = wm831x_reg_read(g_wm831x_on->wm831x, WM831X_ON_PIN_CONTROL);
-	if (ret >= 0) {
-		poll = !(ret & WM831X_ON_PIN_STS);	
-		//poll = 1;
-		input_report_key(g_wm831x_on->dev, KEY_POWER, poll);
-		input_sync(g_wm831x_on->dev);
-		DBG("%s:poll=%d,ret=0x%x\n",__FUNCTION__,poll,ret);
-	} 
-#endif
-	DBG("%s\n",__FUNCTION__);
-	return 0;
-}
-
-static struct dev_pm_ops wm831x_on_dev_pm_ops = {
-	.suspend_noirq = wm831x_on_suspend_noirq,
-	.resume_noirq = wm831x_on_resume_noirq,
-};
-
-
-static struct platform_driver wm831x_on_pm_driver = {
-	.driver		= {
-		.name	= "wm831x_on",
-		.pm	= &wm831x_on_dev_pm_ops,
-	},
-};
-
-static struct platform_device wm831x_on_pm_device = {
-	.name		= "wm831x_on",
-	.id		= -1,
-	.dev = {
-		.driver = &wm831x_on_pm_driver.driver,
-	}
-	
 };
 
-static inline void wm831x_on_pm_init(void)
-{
-	if (platform_driver_register(&wm831x_on_pm_driver) == 0)
-		(void) platform_device_register(&wm831x_on_pm_device);
-}
-
-
-#endif	
-
 /*
  * The chip gives us an interrupt when the ON pin is asserted but we
  * then need to poll to see when the pin is deasserted.
  */
- 
 static void wm831x_poll_on(struct work_struct *work)
 {
 	struct wm831x_on *wm831x_on = container_of(work, struct wm831x_on,
@@ -157,88 +48,43 @@ static void wm831x_poll_on(struct work_struct *work)
 	ret = wm831x_reg_read(wm831x, WM831X_ON_PIN_CONTROL);
 	if (ret >= 0) {
 		poll = !(ret & WM831X_ON_PIN_STS);
+
 		input_report_key(wm831x_on->dev, KEY_POWER, poll);
 		input_sync(wm831x_on->dev);
-		DBG("%s:poll=%d,ret=0x%x\n",__FUNCTION__,poll,ret);
 	} else {
 		dev_err(wm831x->dev, "Failed to read ON status: %d\n", ret);
 		poll = 1;
 	}
 
 	if (poll)
-		schedule_delayed_work(&wm831x_on->work, 2);
-	else
-		wake_unlock(&wm831x->handle_wake);
-		//wake_unlock(&wm831x_on->wm831x_on_wake);
+		schedule_delayed_work(&wm831x_on->work, 100);
 }
 
-#if 0
 static irqreturn_t wm831x_on_irq(int irq, void *data)
 {
 	struct wm831x_on *wm831x_on = data;
-	wake_lock(&wm831x_on->wm831x_on_wake);
-	schedule_delayed_work(&wm831x_on->work, 0);
-	return IRQ_HANDLED;
-}
-
-#else
 
-static irqreturn_t wm831x_on_irq(int irq, void *data)
-{
-	struct wm831x_on *wm831x_on = data;
-	struct wm831x *wm831x = wm831x_on->wm831x;
-	int poll, ret;
-	
-	//wake_lock(&wm831x_on->wm831x_on_wake);
-		
-	ret = wm831x_reg_read(wm831x, WM831X_ON_PIN_CONTROL);//it may be unpress if start to read register now
-	if (ret >= 0) {
-		if(wm831x_on->flag_resume)
-		{
-			poll = 1;
-			spin_lock(&wm831x_on->flag_lock);
-			wm831x_on->flag_resume = 0;
-			spin_unlock(&wm831x_on->flag_lock);
-		}
-		else
-		poll = !(ret & WM831X_ON_PIN_STS);
-		input_report_key(wm831x_on->dev, KEY_POWER, poll);
-		input_sync(wm831x_on->dev);
-		DBG("%s:poll=%d,ret=0x%x\n",__FUNCTION__,poll,ret);
-	} else {
-		dev_err(wm831x->dev, "Failed to read ON status: %d\n", ret);
-		poll = 1;
-	}
+	schedule_delayed_work(&wm831x_on->work, 0);
 
-	if (poll)
-		schedule_delayed_work(&wm831x_on->work, 0);
-	else
-		wake_unlock(&wm831x->handle_wake);
-		//wake_unlock(&wm831x_on->wm831x_on_wake);
-			
 	return IRQ_HANDLED;
 }
 
-#endif
-
 static int __devinit wm831x_on_probe(struct platform_device *pdev)
 {
 	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
-	struct wm831x_on *wm831x_on = NULL;
+	struct wm831x_on *wm831x_on;
 	int irq = platform_get_irq(pdev, 0);
 	int ret;
-	printk("%s irq=%d\n", __FUNCTION__,irq);
+
 	wm831x_on = kzalloc(sizeof(struct wm831x_on), GFP_KERNEL);
 	if (!wm831x_on) {
 		dev_err(&pdev->dev, "Can't allocate data\n");
 		return -ENOMEM;
 	}
 
-	
 	wm831x_on->wm831x = wm831x;
 	INIT_DELAYED_WORK(&wm831x_on->work, wm831x_poll_on);
-	wake_lock_init(&wm831x_on->wm831x_on_wake, WAKE_LOCK_SUSPEND, "wm831x_on_wake");
-	
+
 	wm831x_on->dev = input_allocate_device();
 	if (!wm831x_on->dev) {
 		dev_err(&pdev->dev, "Can't allocate input dev\n");
@@ -251,9 +97,6 @@ static int __devinit wm831x_on_probe(struct platform_device *pdev)
 	wm831x_on->dev->name = "wm831x_on";
 	wm831x_on->dev->phys = "wm831x_on/input0";
 	wm831x_on->dev->dev.parent = &pdev->dev;
-	g_wm831x_on = wm831x_on;
-
-	wm831x_on_pm_init();
 
 	ret = request_threaded_irq(irq, NULL, wm831x_on_irq,
 				   IRQF_TRIGGER_RISING, "wm831x_on",
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 75006f0258cc..410410396700 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -11,70 +11,6 @@ menuconfig INPUT_TOUCHSCREEN
 
 if INPUT_TOUCHSCREEN
 
-config CT36X_TS
-	tristate "CT36X touchscreens support"
-
-config TOUCHSCREEN_GSLX680
-		tristate "gslX680 touchscreen panel support "
-		depends on I2C2_RK29 || I2C2_RK30
-config TOUCHSCREEN_GSLX680_RK3168
-		tristate "gslX680 rk3168 touchscreen panel support "
-		depends on I2C2_RK29 || I2C2_RK30
-config TOUCHSCREEN_GSLX680_RK3028
-		tristate "gslX680 rk3028 touchscreen panel support "
-		depends on I2C2_RK29 || I2C2_RK30
-config TOUCHSCREEN_XPT2046_SPI
-	tristate "XPT2046 based touchscreens:SPI Interface"
-	depends on SPIM_RK29
-
-	config TOUCHSCREEN_XPT2046_NORMAL_SPI
-	tristate "normal mode"
-	depends on TOUCHSCREEN_XPT2046_SPI
-
-		config TOUCHSCREEN_480X800
-		tristate "480X800 resolution"
-		depends on TOUCHSCREEN_XPT2046_NORMAL_SPI
-
-		config TOUCHSCREEN_800X480
-		tristate "800X480 resolution"
-		depends on TOUCHSCREEN_XPT2046_NORMAL_SPI
-
-		config TOUCHSCREEN_320X480
-		tristate "320X480 resolution"
-		depends on TOUCHSCREEN_XPT2046_NORMAL_SPI
-
-	config TOUCHSCREEN_XPT2046_TSLIB_SPI
-	tristate "tslib mode"
-	depends on TOUCHSCREEN_XPT2046_SPI
-
-		config TOUCHSCREEN_480X800
-		tristate "480X800 resolution"
-		depends on TOUCHSCREEN_XPT2046_TSLIB_SPI
-
-		config TOUCHSCREEN_800X480
-		tristate "800X480 resolution"
-		depends on TOUCHSCREEN_XPT2046_TSLIB_SPI
-
-		config TOUCHSCREEN_320X480
-		tristate "320X480 resolution"
-		depends on TOUCHSCREEN_XPT2046_TSLIB_SPI
-
-	config TOUCHSCREEN_XPT2046_CBN_SPI
-	tristate "calibration mode"
-	depends on TOUCHSCREEN_XPT2046_SPI
-
-		config TOUCHSCREEN_480X800
-		tristate "480X800 resolution"
-		depends on TOUCHSCREEN_XPT2046_CBN_SPI
-
-		config TOUCHSCREEN_800X480
-		tristate "800X480 resolution"
-		depends on TOUCHSCREEN_XPT2046_CBN_SPI
-
-		config TOUCHSCREEN_320X480
-		tristate "320X480 resolution"
-		depends on TOUCHSCREEN_XPT2046_CBN_SPI
-
 config TOUCHSCREEN_88PM860X
 	tristate "Marvell 88PM860x touchscreen"
 	depends on MFD_88PM860X
@@ -119,52 +55,6 @@ config TOUCHSCREEN_AD7877
 	  To compile this driver as a module, choose M here: the
 	  module will be called ad7877.
 
-config TOUCHSCREEN_ILI2102_IIC
-	tristate "ili2102 based touchscreens: IIC Interface"
-	help
-	  Say Y here if you have a touchscreen interface using the
-	  hx8520 controller, and your board-specific initialization
-	  code includes that in its table of IIC devices.
-
-	  If unsure, say N (but it's safe to say "Y").
-config TOUCHSCREEN_GT8XX
-        tristate "Goodix touch screen gt801X2 support for rockchip based platform"
-        help
-          Say Y here if you have a touchscreen interface using the
-          two goodix gt801  , and your board-specific initialization
-          code includes that in its table of IIC devices.
-	  If unsure, say N.
-	config TOUCH_MAX_X
-                int "touch max x resolution"
-                depends on TOUCHSCREEN_GT8XX
-                default 1280
-                help
-                  goodix  touch max X resolution
-
-        config TOUCH_MAX_Y
-                int "touch max y resolution"
-                depends on TOUCHSCREEN_GT8XX
-                default 800
-                help
-                  goodix touch max y resolution
-
-config TOUCHSCREEN_CT36X
-	default n
-	tristate "CT36X based touchscreens"
-
-config RK28_I2C_TS_NTP070
-	tristate "NTP070 based touchscreens: NTP070 Interface"
-	depends on I2C_RK2818
-
-config TOUCHSCREEN_IT7250
-	tristate "IT7250 based touchscreens: IT7250 Interface"
-	help
-	  Say Y here if you have a touchscreen interface using the
-	  xpt2046 controller, and your board-specific initialization
-	  code includes that in its table of SPI devices.
-
-	  If unsure, say N (but it's safe to say "Y").
-
 config TOUCHSCREEN_AD7879
 	tristate "Analog Devices AD7879-1/AD7889-1 touchscreen interface"
 	help
@@ -842,277 +732,4 @@ config TOUCHSCREEN_TPS6507X
 	  To compile this driver as a module, choose M here: the
 	  module will be called tps6507x_ts.
 
-config HANNSTAR_P1003
-	tristate "Hannstar P1003 touchscreen"
-	depends on I2C2_RK29
-	help
-	  RK29 hannstar touch
-
-	config HANNSTAR_MAX_X
-	        int "hannstar touch x max"
-		depends on HANNSTAR_P1003
-		default 1087
-		help
-		  RK29 hannstar touch max X size
-
-	config HANNSTAR_MAX_Y
-                int "hannstar touch Y max"
-                depends on HANNSTAR_P1003
-		default 800
-                help
-                  RK29 hannstar touch max Y size
-
-	config HANNSTAR_DEBUG
-		bool "hannstar debug"
-		depends on HANNSTAR_P1003
-		default n
-		help
-		  RK29 hannstar touch debug
-
-config ATMEL_MXT224
-        tristate "Atmel mXT224 touchscreen"
-        depends on I2C2_RK29
-        help
-          RK29 Atmel_mXT224 touch
-
-        config MXT224_MAX_X
-                int "atmel_mxt224 touch X max"
-                depends on ATMEL_MXT224
-                default 4095
-                help
-                  RK29 atmel_mxt224 touch max X size
-
-        config MXT224_MAX_Y
-                int "atmel_mxt224 touch Y max"
-                depends on ATMEL_MXT224
-                default 4095
-                help
-                  RK29 atmel_mxt224 touch max Y size
-
-config SINTEK_3FA16
-	tristate "Sintek 3FA16 touchscreen"
-        depends on I2C2_RK29
-        help
-          RK29 Sintek touch
-
-        config HANNSTAR_MAX_X
-                int "Sintek touch x max"
-                depends on SINTEK_3FA16
-                default 1024
-                help
-                  RK29 hannstar touch max X size
-
-        config HANNSTAR_MAX_Y
-                int "Sintek touch Y max"
-                depends on SINTEK_3FA16
-                default 600
-                help
-                  RK29 hannstar touch max Y size
-
-        config HANNSTAR_DEBUG
-                bool "Sintek debug"
-                depends on SINTEK_3FA16
-                default n
-                help
-                  RK29 hannstar touch debug
-
-config EETI_EGALAX
-        tristate "EETI_EGALAX touchscreen panel support"
-        depends on I2C
-        help
-          Say Y here to enable support for I2C connected EETI touch panels.
-
-          To compile this driver as a module, choose M here: the
-          module will be called eeti_egalax_ts.
-
-        config EETI_EGALAX_MAX_X
-                int "EETI_EGALAX_MAX_X"
-                depends on EETI_EGALAX
-                default 2047
-                help
-                  RK29 EETI_EGALAX touch max X size
-
-        config EETI_EGALAX_MAX_Y
-                int "EETI_EGALAX_MAX_Y"
-                depends on EETI_EGALAX
-                default 2047
-                help
-                  RK29 EETI_EGALAX touch max Y size
-
-        config EETI_EGALAX_DEBUG
-                bool "EETI_EGALAX debug"
-                depends on EETI_EGALAX
-                default n
-                help
-                  RK29 EETI_EGALAX touch debug
-
-config TOUCHSCREEN_IT7260
-	tristate "IT7260 based touchscreens: IT7260 Interface"
-	depends on I2C2_RK29
-	help
-	  Say Y here if you have a touchscreen interface using the
-	  it7260 controller, and your board-specific initialization
-	  code includes that in its table of I2C devices.
-
-	  If unsure, say N (but it's safe to say "Y").
-
-config TOUCHSCREEN_IT7260_I2C
-	tristate "IT7260 based touchscreens: IT7260 I2C Interface"
-	depends on I2C_RK29
-	help
-	  Say Y here if you have a touchscreen interface using the
-	  IT7260 controller, and your board-specific initialization
-	  code includes that in its table of I2C devices.
-
-	  If unsure, say N (but it's safe to say "Y").
-
-config TOUCHSCREEN_NAS
-        tristate "NAS based touchscreens: NAS Interface"
-        depends on I2C2_RK29
-        help
-          Say Y here if you have a touchscreen interface using the
-          nas controller, and your board-specific initialization
-          code includes that in its table of I2C devices.
-
-          If unsure, say N (but it's safe to say "Y").
-
-config LAIBAO_TS
-	tristate "LAIBAO touchscreen"
-	depends on I2C2_RK29
-	help
-	  RK29 LAIBAO touchscreen
-
-config TOUCHSCREEN_GT801_IIC
-	tristate "GT801_IIC based touchscreens"
-	depends on I2C2_RK29
-
-config TOUCHSCREEN_GT811_IIC
-	tristate "GT811_IIC based touchscreens"
-	depends on I2C2_RK29 || I2C2_RK30
-
-config TOUCHSCREEN_86V_GT811_IIC
-	tristate "RK3168_86V GT811_IIC based touchscreens"
-	depends on I2C2_RK29 || I2C2_RK30
-		
-config TOUCHSCREEN_GT82X_IIC
-	tristate "GT82x_IIC based touchscreens"
-	depends on I2C2_RK30
-		
-config TOUCHSCREEN_GT82X_IIC_760
-	tristate "GT82x_IIC based touchscreens for 760"
-	depends on I2C2_RK30
-config TOUCHSCREEN_GT818_IIC
-	tristate "GT818_IIC based touchscreens"
-	depends on I2C2_RK29
-
-config TOUCHSCREEN_PIXCIR
-	tristate "PIXCIR_IIC based touchscreens"
-	depends on I2C2_RK29
-	
-config TOUCHSCREEN_SYNAPTICS_RMI4_I2C_RK
-	tristate "Synaptics i2c rmi4 touchscreen"
-	depends on I2C_RK30
-	help
-	  This enables support for Synaptics RMI over I2C based touchscreens.
-	config TOUCHSCREEN_SYNAPTICS_S3202
-		tristate "SYNAPTICS S3202 touchscreen"
-		depends on TOUCHSCREEN_SYNAPTICS_RMI4_I2C_RK
-	source "drivers/input/touchscreen/rmi4/Kconfig"
-config D70_L3188A
-	tristate "D70-L3188A based touchscreens"
-	depends on I2C2_RK29
-
-config TOUCHSCREEN_GT819
-	tristate "GT819 based touchscreens"
-	depends on I2C2_RK29
-
-
-config TOUCHSCREEN_GT8110
-        tristate "GT8110 based touchscreens"
-        depends on I2C2_RK29 || I2C_RK30
-config TP_760_TS
-	tristate "tp for 760"
-	depends on I2C2_RK29 || I2C_RK30
-config TOUCHSCREEN_CT360_IIC
-	tristate "CT360 based touchscreens"
-	depends on I2C_RK29 || I2C_RK30
-
-config TOUCHSCREEN_FT5306
-	tristate "FT5306 based touchscreens: FT5306 Interface"
-	depends on I2C2_RK29 || I2C2_RK30
-
-config TOUCHSCREEN_I30
-	tristate "i30 based touchscreens: i30(ft5306) Interface"
-	depends on I2C2_RK29 || I2C2_RK30
-
-config TOUCHSCREEN_BYD693X
-	tristate "touchscreen BYD693X I2C Interface"
-	depends on I2C2_RK29 || I2C2_RK30
-
-config TOUCHSCREEN_SITRONIX_A720
-	tristate "SITRONIX based touchscreens: SITRONIX Interface for a720"
-	depends on I2C2_RK29 || I2C2_RK30 
-
-config TOUCHSCREEN_FT5306_WPX2
-        tristate "FT5306 based touchscreens: FT5306 Interface,only used for umeox wpx2 board"
-        depends on I2C2_RK29 || I2C2_RK30
-
-config TOUCHSCREEN_FT5306_AV
-        tristate "FT5306 based touchscreens: FT5306 Interface base on AV-Display factory 1204*600"
-        depends on I2C2_RK29 || I2C2_RK30
-
-config TOUCHSCREEN_FT5406
-	tristate "FT5406 based touchscreens: FT5406 Interface"
-	depends on I2C2_RK29
-	help
-	  say Y here if you have a touchscreen interface using the FT5406
-	  controller,and your board-specific initialization code includes that
-	  in its table of I2C devices.
-
-	  If unsure, say N(but it's safe to say "Y").
-
-config TOUCHSCREEN_FT5X0X
-		tristate "ft5x0x touchscreen panel support "
-		depends on I2C2_RK29 || I2C2_RK30
-config TOUCHSCREEN_FT5506
-	tristate "FT5506 based touchscreens: FT5506 Interface"
-	depends on I2C2_RK29 || I2C2_RK30
-	help
-	  say Y here if you have a touchscreen interface using the FT5506
-	  controller,and your board-specific initialization code includes that
-	  in its table of I2C devices.
-
-	  If unsure, say N(but it's safe to say "Y").
-# VTL TouchScreen Driver Config
-source "drivers/input/touchscreen/ct36x_ts/Kconfig"
-
-config ATMEL_MXT1386
-        tristate "ATMEL_MXT1386 touchscreen panel support"
-        depends on I2C
-        help
-          Say Y here to enable support for I2C connected ATMEL_MXT1386 touch panels.
-
-          To compile this driver as a module, choose M here: the
-          module will be called atmel_mxt1386_ts.
-
-        config ATMEL_MXT1386_MAX_X
-                int "ATMEL_MXT1386_MAX_X"
-                depends on ATMEL_MXT1386
-                default 4095
-                help
-                  RK29 ATMEL_MXT1386 touch max X size
-
-        config ATMEL_MXT1386_MAX_Y
-                int "ATMEL_MXT1386_MAX_Y"
-                depends on ATMEL_MXT1386
-                default 4095
-                help
-                  RK29 ATMEL_MXT1386 touch max Y size
-
-        config ATMEL_MXT1386_DEBUG
-                bool "ATMEL_MXT1386 debug"
-                depends on ATMEL_MXT1386
-                default n
-                help
-                  RK29 ATMEL_MXT1386 touch debug
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index d974c753da78..0738f19633b1 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -5,7 +5,7 @@
 # Each configuration option enables a list of files.
 
 wm97xx-ts-y := wm97xx-core.o
-obj-y                  			+= ct36x/
+
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
@@ -61,48 +61,3 @@ obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
-obj-$(CONFIG_TOUCHSCREEN_PCAP)		+= pcap_ts.o
-obj-$(CONFIG_TOUCHSCREEN_XPT2046_NORMAL_SPI)	+= xpt2046_ts.o
-obj-$(CONFIG_TOUCHSCREEN_XPT2046_TSLIB_SPI)	+= xpt2046_tslib_ts.o ts_lib/
-obj-$(CONFIG_TOUCHSCREEN_XPT2046_CBN_SPI)	+= xpt2046_cbn_ts.o calibration_ts.o largenum_ts.o calib_iface_ts.o
-obj-$(CONFIG_TOUCHSCREEN_IT7250)	+= ctp_it7250.o
-obj-$(CONFIG_RK28_I2C_TS_NTP070)	+= ntp070.o
-obj-$(CONFIG_HANNSTAR_P1003)		+= hannstar_p1003.o
-obj-$(CONFIG_TOUCHSCREEN_IT7260)	+= it7260_ts.o
-obj-$(CONFIG_TOUCHSCREEN_IT7260_I2C)	+= IT7260_ts_i2c.o
-obj-$(CONFIG_SINTEK_3FA16)		+= sintek_3FA16.o
-obj-$(CONFIG_EETI_EGALAX)		+= eeti_egalax_i2c.o
-obj-$(CONFIG_ATMEL_MXT224)		+= atmel_maxtouch.o
-obj-$(CONFIG_ATMEL_MXT1386)		+= atmel_mxt1386.o
-obj-$(CONFIG_TOUCHSCREEN_GT801_IIC)	+= gt801_ts.o
-obj-$(CONFIG_TOUCHSCREEN_GT811_IIC)	+= gt811_ts.o
-obj-$(CONFIG_TOUCHSCREEN_86V_GT811_IIC)	+= 86v_gt811_ts.o
-obj-$(CONFIG_TOUCHSCREEN_GT82X_IIC)	+= goodix_touch_82x.o
-obj-$(CONFIG_TOUCHSCREEN_GT82X_IIC_760)	+= goodix_touch_82x_760.o
-obj-$(CONFIG_TOUCHSCREEN_GT818_IIC)	+= gt818_ts.o
-obj-$(CONFIG_TOUCHSCREEN_GT8110)        += gt8110_ts.o
-obj-$(CONFIG_TOUCHSCREEN_CT360_IIC)	+= ct360_ts.o
-obj-$(CONFIG_TOUCHSCREEN_ILI2102_IIC)	+= ili2102_ts.o
-obj-$(CONFIG_D70_L3188A)		+= goodix_touch.o
-obj-$(CONFIG_TOUCHSCREEN_GT8XX)                += rk29_i2c_goodix.o
-obj-$(CONFIG_TOUCHSCREEN_FT5406)	+= ft5406_ts.o
-obj-$(CONFIG_TOUCHSCREEN_FT5506)	+= ft5506_wgj.o
-obj-$(CONFIG_TOUCHSCREEN_FT5306)	+= ft5306_ts.o
-obj-$(CONFIG_TOUCHSCREEN_SITRONIX_A720)	+= sitronix_ts_a720.o
-obj-$(CONFIG_TOUCHSCREEN_FT5306_WPX2)        += ft5306_ts_wpx2.o
-obj-$(CONFIG_TOUCHSCREEN_FT5306_AV) += ft5306_ts_av.o
-obj-$(CONFIG_TOUCHSCREEN_GT819)		+= gt819.o
-obj-$(CONFIG_TOUCHSCREEN_CT36X)		+= ct36x_ts.o
-obj-$(CONFIG_TOUCHSCREEN_NAS)		+= nas_ts.o
-obj-$(CONFIG_LAIBAO_TS)		+= ft5x0x_i2c_ts.o
-obj-$(CONFIG_TOUCHSCREEN_PIXCIR)      += pixcir_i2c_ts.o
-obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_RMI4_I2C_RK)      += rmi4/
-obj-$(CONFIG_TOUCHSCREEN_I30)	+= i30_ts.o
-obj-$(CONFIG_TOUCHSCREEN_BYD693X)	+= byd693x_ts.o
-obj-$(CONFIG_TOUCHSCREEN_FT5X0X)	+= ft5x0x.o
-obj-$(CONFIG_TOUCHSCREEN_GSLX680)	+= rockchip_gslX680.o
-obj-$(CONFIG_TOUCHSCREEN_GSLX680_RK3168)	+= rockchip_gslX680_rk3168.o
-obj-$(CONFIG_TOUCHSCREEN_GSLX680_RK3028)	+= rockchip_gslX680_rk3028.o
-# Make VTL TouchScreen Driver
-obj-$(CONFIG_TOUCHSCREEN_CT36XX)		+= ct36x_ts/
-obj-$(CONFIG_TP_760_TS)                    += tp_760_ts.o
diff --git a/drivers/input/touchscreen/pixcir_i2c_ts.c b/drivers/input/touchscreen/pixcir_i2c_ts.c
deleted file mode 100644
index 39faff42b374..000000000000
--- a/drivers/input/touchscreen/pixcir_i2c_ts.c
+++ /dev/null
@@ -1,960 +0,0 @@
-/*
- * Driver for Pixcir I2C touchscreen controllers.
- *
- * Copyright (C) 2010-2011 Pixcir, Inc.
- *
- * pixcir_i2c_ts.c V3.0  from v3.0 support TangoC solution and remove the previous soltutions
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/earlysuspend.h>
-#include <linux/hrtimer.h>
-#include <linux/i2c.h>
-#include <linux/input.h>
-#include <linux/input/mt.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <linux/gpio.h>
-#include <mach/iomux.h>
-#include <linux/platform_device.h>
-
-#include <linux/slab.h>
-#include <asm/uaccess.h>
-#include <linux/proc_fs.h>
-
-#include "pixcir_i2c_ts.h"
-
-#define PIXCIR_DEBUG			0
-#if PIXCIR_DEBUG
-	#define pixcir_dbg(msg...)	printk(msg);
-#else
-	#define pixcir_dbg(msg...)
-#endif
-
-static int  ts_dbg_enable = 0;
-
-#define DBG(msg...) \
-	({if(ts_dbg_enable == 1) printk(msg);})
-/*********************************Bee-0928-TOP****************************************/
-
-#define SLAVE_ADDR		0x5c
-
-#ifndef I2C_MAJOR
-#define I2C_MAJOR 		125
-#endif
-
-#define I2C_MINORS 		256
-
-#define  CALIBRATION_FLAG	1
-
-static unsigned char status_reg = 0;
-static struct workqueue_struct *pixcir_wq;
-static struct pixcir_i2c_ts_data *this_data;
-
-struct point_data{
-	unsigned char	brn;  //broken line number
-	unsigned char	brn_pre;
-	unsigned char	id;    //finger ID
-	int	posx;
-	int	posy;
-	int     lastx;
-	int     lasty;
-	unsigned char active;
-	unsigned char pre_active;
-};
-
-static struct point_data point[MAX_SUPPORT_POINT];
-
-struct i2c_dev
-{
-	struct list_head list;
-	struct i2c_adapter *adap;
-	struct device *dev;
-};
-
-static struct i2c_driver pixcir_i2c_ts_driver;
-static struct class *i2c_dev_class;
-static LIST_HEAD( i2c_dev_list);
-static DEFINE_SPINLOCK( i2c_dev_list_lock);
-
-static void return_i2c_dev(struct i2c_dev *i2c_dev)
-{
-	spin_lock(&i2c_dev_list_lock);
-	list_del(&i2c_dev->list);
-	spin_unlock(&i2c_dev_list_lock);
-	kfree(i2c_dev);
-}
-
-static struct i2c_dev *i2c_dev_get_by_minor(unsigned index)
-{
-	struct i2c_dev *i2c_dev;
-	i2c_dev = NULL;
-
-	spin_lock(&i2c_dev_list_lock);
-	list_for_each_entry(i2c_dev, &i2c_dev_list, list)
-	{
-		if (i2c_dev->adap->nr == index)
-			goto found;
-	}
-	i2c_dev = NULL;
-	found: spin_unlock(&i2c_dev_list_lock);
-	return i2c_dev;
-}
-
-static struct i2c_dev *get_free_i2c_dev(struct i2c_adapter *adap)
-{
-	struct i2c_dev *i2c_dev;
-
-	if (adap->nr >= I2C_MINORS) {
-		printk(KERN_ERR "i2c-dev: Out of device minors (%d)\n",
-				adap->nr);
-		return ERR_PTR(-ENODEV);
-	}
-
-	i2c_dev = kzalloc(sizeof(*i2c_dev), GFP_KERNEL);
-	if (!i2c_dev)
-		return ERR_PTR(-ENOMEM);
-
-	i2c_dev->adap = adap;
-
-	spin_lock(&i2c_dev_list_lock);
-	list_add_tail(&i2c_dev->list, &i2c_dev_list);
-	spin_unlock(&i2c_dev_list_lock);
-	return i2c_dev;
-}
-/*********************************Bee-0928-bottom**************************************/
-
-struct pixcir_i2c_ts_data {
-	struct i2c_client *client;
-	struct input_dev *input,*input_key_dev;
-	int use_irq;
-	int 	gpio_pendown;
-	int 	gpio_reset;
-	int 	gpio_reset_active_low;
-	int		pendown_iomux_mode;	
-	int		resetpin_iomux_mode;
-	char	pendown_iomux_name[IOMUX_NAME_SIZE];	
-	char	resetpin_iomux_name[IOMUX_NAME_SIZE];		
-	struct 	work_struct  work;
-	//const struct pixcir_ts_platform_data *chip;
-	bool exiting;
-    struct 	early_suspend early_suspend;
-};
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void pixcir_ts_early_suspend(struct early_suspend *h);
-static void pixcir_ts_late_resume(struct early_suspend *h);
-#endif
-
-int tp_pixcir_write_reg(struct i2c_client *client,const char *buf ,int count)
-{
-  struct i2c_msg msg[] = {
-    {
-      .addr  = client->addr,
-      .flags = 0,
-      .len   = count,
-      .buf   = (char *)buf,
-    }
-  };
-  
-	//ret = i2c_transfer(adap, &msg, 1);
-	if (i2c_transfer(client->adapter, msg, 1) < 0)
-	{
-		printk("write the address (0x%x) of the ssd2533 fail.",buf[0]);
-		return -1;
-	}
-	return 0;
-}
-
-int tp_pixcir_read_reg(struct i2c_client *client,u8 addr,u8 *buf,u8 len)
-{
-	u8 msgbuf[1] = { addr };
-	struct i2c_msg msgs[] = {
-		{
-			.addr	 = client->addr,
-			.flags = 0, //Write
-			.len	 = 1,
-			.buf	 = msgbuf,
-		},
-		{
-			.addr	 = client->addr,
-			.flags = I2C_M_RD,
-			.len	 = len,
-			.buf	 = buf,
-		},
-	};
-	if (i2c_transfer(client->adapter, msgs, 2) < 0)
-	{
-		printk("read the address (0x%x) of the ssd2533 fail.",addr);
-		return -1;
-	}
-	return 0;
-}
-
-static void pixcir_ts_poscheck(struct pixcir_i2c_ts_data *data)
-{
-	struct pixcir_i2c_ts_data *tsdata = data;
-	
-	u8 *p;
-	u8 touch, button, pix_id;
-	u8 rdbuf[27], wrbuf[1] = { 0 };
-	int ret, i;
-	int ignore_cnt = 0;
-	
-	ret = i2c_master_send(tsdata->client, wrbuf, sizeof(wrbuf));
-	if (ret != sizeof(wrbuf)) {
-		dev_err(&tsdata->client->dev,
-			"%s: i2c_master_send failed(), ret=%d\n",
-			__func__, ret);
-		return;
-	}
-
-	ret = i2c_master_recv(tsdata->client, rdbuf, sizeof(rdbuf));
-	if (ret != sizeof(rdbuf)) {
-		dev_err(&tsdata->client->dev,
-			"%s: i2c_master_recv failed(), ret=%d\n",
-			__func__, ret);
-		return;
-	}
-	
-	touch = rdbuf[0] & 0x07;
-	button = rdbuf[1];
-	p = &rdbuf[2];
-
-	for (i = 0; i < MAX_SUPPORT_POINT; i++)	{
-		point[i].pre_active = point[i].active;
-		point[i].active = 0;
-	}
-
-	for (i = 0; i < touch; i++) {
-		pix_id = (*(p + 4)) & 0x7;
-
-		point[pix_id].brn = (*(p + 4)) >> 3;		
-		point[pix_id].id = (*(p + 4)) & 0x7;	
-		point[pix_id].posx = (*(p + 1) << 8) + (*(p));	
-		point[pix_id].posy = (*(p + 3) << 8) + (*(p + 2));
-
-		if (point[pix_id].posy < 40 || point[pix_id].posy > 520 || point[pix_id].posx < 40) {
-			//point[i].active = 0;
-		} else {
-			point[pix_id].active = 1;
-			
-			point[pix_id].posy -= 40;
-			point[pix_id].posx -= 40;
-
-			if(point[pix_id].posy < 0)
-				point[pix_id].posy=1;
-
-			if(point[pix_id].posx < 0)
-				point[pix_id].posx=1;
-		}
-		p+=5;
-
-		DBG("[id = %d]x = %d y = %d\n", pix_id, point[pix_id].posy, point[pix_id].posx);
-	}
-	
-
-	for (i = 0; i < MAX_SUPPORT_POINT; i++)	{
-		if (!point[i].active && point[i].pre_active) {
-			input_mt_slot(tsdata->input, point[i].id);
-			input_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER, false);
-		}
-
-		if (point[i].active && (
-			abs(point[i].posx - point[i].lastx) > 2 ||
-			abs(point[i].posy - point[i].lasty) > 2
-			)) {
-			input_mt_slot(tsdata->input, point[i].id);
-			input_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER, true);
-			input_report_abs(tsdata->input, ABS_MT_TOUCH_MAJOR, 1);
-			input_report_abs(tsdata->input, ABS_MT_POSITION_X, point[i].posy);
-			input_report_abs(tsdata->input, ABS_MT_POSITION_Y, point[i].posx);
-			point[i].lastx = point[i].posx;
-			point[i].lasty = point[i].posy;
-		}
-
-		DBG("%d[id = %d] = %2d active= %d pre_active = %d x = %5d y = %5d \n",
-			i, point[i].id, point[i].brn, point[i].active, point[i].pre_active, point[i].posy, point[i].posx);
-	}
-
-	input_sync(tsdata->input);
-
-}
-
-static void pixcir_ts_work_func(struct work_struct *work)
-{
-	struct pixcir_i2c_ts_data *tsdata = this_data;
-	int i = 0;
-
-	while (!tsdata->exiting) {
-	
-		pixcir_ts_poscheck(tsdata);
-		if (attb_read_val()){
-			DBG("%s:  >>>>>touch release\n\n",__FUNCTION__);
-			for (i = 0; i < MAX_SUPPORT_POINT; i++)	{
-				point[i].pre_active = point[i].active;
-				point[i].active = 0;
-				if (!point[i].active && point[i].pre_active) {
-					input_mt_slot(tsdata->input, point[i].id);
-					input_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER, false);
-				}
-			}
-			input_sync(tsdata->input);
-			enable_irq(tsdata->client->irq);
-			break;
-		}
-
-		msleep(1);
-	}
-}
-
-static irqreturn_t pixcir_ts_isr(int irq, void *dev_id)
-{
-    struct pixcir_i2c_ts_data *ts = dev_id;
-    DBG("%s: >>>>>>>>>\n\n",__FUNCTION__);
-
-	if(ts->use_irq){
-    	disable_irq_nosync(ts->client->irq);
-	}
-	queue_work(pixcir_wq, &ts->work);
-
-    return IRQ_HANDLED;
-}
-
-#if 0
-#ifdef CONFIG_PM_SLEEP
-static int pixcir_i2c_ts_suspend(struct device *dev)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	pixcir_dbg("%s\n",__FUNCTION__);
-
-	if (device_may_wakeup(&client->dev))
-		enable_irq_wake(client->irq);
-
-	return 0;
-}
-
-static int pixcir_i2c_ts_resume(struct device *dev)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	pixcir_dbg("%s\n",__FUNCTION__);
-
-	if (device_may_wakeup(&client->dev))
-		disable_irq_wake(client->irq);
-
-	return 0;
-}
-#endif
-static SIMPLE_DEV_PM_OPS(pixcir_dev_pm_ops,
-			 pixcir_i2c_ts_suspend, pixcir_i2c_ts_resume);
-
-static int __devinit setup_resetPin(struct i2c_client *client, struct pixcir_i2c_ts_data *ts)
-{
-	struct pixcir_platform_data	*pdata = client->dev.platform_data;
-	int err;
-	
-	pixcir_dbg("%s\n",__FUNCTION__);
-
-	
-	ts->gpio_reset = pdata->gpio_reset;
-    ts->gpio_reset_active_low = pdata->gpio_reset_active_low;
-    ts->resetpin_iomux_mode = pdata->resetpin_iomux_mode;
-	///*
-
-    if(pdata->resetpin_iomux_name != NULL)
-	    strcpy(ts->resetpin_iomux_name,pdata->resetpin_iomux_name);
-	
-	//pixcir_dbg("%s=%d,%s,%d,%d\n",__FUNCTION__,ts->gpio_reset,ts->resetpin_iomux_name,ts->resetpin_iomux_mode,ts->gpio_reset_active_low);
-	if (!gpio_is_valid(ts->gpio_reset)) {
-		dev_err(&client->dev, "no gpio_reset?\n");
-		return -EINVAL;
-	}
-
-    rk29_mux_api_set(ts->resetpin_iomux_name,ts->resetpin_iomux_mode); 
-	//*/
-
-	err = gpio_request(ts->gpio_reset, "pixcir_resetPin");
-	if (err) {
-		dev_err(&client->dev, "failed to request resetPin GPIO%d\n",
-				ts->gpio_reset);
-		return err;
-	}
-	
-	err = gpio_direction_output(ts->gpio_reset, ts->gpio_reset_active_low? GPIO_LOW:GPIO_HIGH);
-	if (err) {
-		dev_err(&client->dev, "failed to pulldown resetPin GPIO%d,err%d\n",
-				ts->gpio_reset,err);
-		gpio_free(ts->gpio_reset);
-		return err;
-	}
-	mdelay(100);
-	gpio_set_value(ts->gpio_reset, ts->gpio_reset_active_low? GPIO_HIGH:GPIO_LOW);
-	mdelay(100);
-
-	return 0;
-}
-
-static int __devinit setup_pendown(struct i2c_client *client, struct pixcir_i2c_ts_data *ts)
-{
-	int err;
-	struct pixcir_i2c_ts_data	*pdata = client->dev.platform_data;
-
-	pixcir_dbg("%s\n",__FUNCTION__);
-	if (!client->irq) {
-		dev_dbg(&client->dev, "no IRQ?\n");
-		return -ENODEV;
-	}
-	
-	if (!gpio_is_valid(pdata->gpio_pendown)) {
-		dev_err(&client->dev, "no gpio_pendown?\n");
-		return -EINVAL;
-	}
-	
-	ts->gpio_pendown = pdata->gpio_pendown;
-	strcpy(ts->pendown_iomux_name,pdata->pendown_iomux_name);
-	ts->pendown_iomux_mode = pdata->pendown_iomux_mode;
-	
-	pixcir_dbg("%s=%d,%s,%d\n",__FUNCTION__,ts->gpio_pendown,ts->pendown_iomux_name,ts->pendown_iomux_mode);
-	
-	if (!gpio_is_valid(ts->gpio_pendown)) {
-		dev_err(&client->dev, "no gpio_pendown?\n");
-		return -EINVAL;
-	}
-	
-    rk29_mux_api_set(ts->pendown_iomux_name,ts->pendown_iomux_mode); 
-	err = gpio_request(ts->gpio_pendown, "gt801_pendown");
-	if (err) {
-		dev_err(&client->dev, "failed to request pendown GPIO%d\n",
-				ts->gpio_pendown);
-		return err;
-	}
-	
-	err = gpio_pull_updown(ts->gpio_pendown, GPIOPullUp);
-	if (err) {
-		dev_err(&client->dev, "failed to pullup pendown GPIO%d\n",
-				ts->gpio_pendown);
-		gpio_free(ts->gpio_pendown);
-		return err;
-	}
-	return 0;
-}
-#endif
-
-static ssize_t pixcir_proc_write(struct file *file, const char __user *buffer,
-			   size_t count, loff_t *data)
-{
-	char c;
-	int rc;
-	
-	rc = get_user(c, buffer);
-	if (rc)
-		return rc; 
-	
-	if (c == '1')
-		ts_dbg_enable = 1; 
-	else if (c == '0')
-		ts_dbg_enable = 0; 
-
-	return count; 
-}
-
-static const struct file_operations pixcir_proc_fops = {
-	.owner		= THIS_MODULE, 
-	.write		= pixcir_proc_write,
-}; 
-static int __devinit pixcir_i2c_ts_probe(struct i2c_client *client,
-					 const struct i2c_device_id *id)
-{
-	//const struct pixcir_ts_platform_data *pdata = client->dev.platform_data;
-	struct pixcir_i2c_ts_data *tsdata;
-	struct pixcir_platform_data *pdata;
-	struct device *dev;
-	struct i2c_dev *i2c_dev;
-	int error = 0;
-	struct proc_dir_entry *pixcir_proc_entry;	
-
-	//if (!pdata) {
-	//	dev_err(&client->dev, "platform data not defined\n");
-	//	return -EINVAL;
-	//}
-	pixcir_dbg("%s\n",__FUNCTION__);
-
-	tsdata = kzalloc(sizeof(*tsdata), GFP_KERNEL);
-	tsdata->input = input_allocate_device();
-	if (!tsdata || !(tsdata->input)) {
-		dev_err(&client->dev, "Failed to allocate driver data!\n");
-		error = -ENOMEM;
-		goto err_free_mem;
-	}
-	
-	pixcir_wq = create_singlethread_workqueue("pixcir_tp_wq");
-	if (!pixcir_wq) {
-		printk(KERN_ERR"%s: create workqueue failed\n", __FUNCTION__);
-		error = -ENOMEM;
-		goto err_free_mem;
-	}
-	INIT_WORK(&tsdata->work, pixcir_ts_work_func);
-	
-	this_data = tsdata;
-	tsdata->exiting = false;
-	//tsdata->input = input;
-	//tsdata->chip = pdata;
-	
-	tsdata->client = client;
-	i2c_set_clientdata(client, tsdata);
-	pdata = client->dev.platform_data;
-
-	//error = setup_resetPin(client,tsdata);
-	if(error)
-	{
-		 printk("%s:setup_resetPin fail\n",__FUNCTION__);
-		 goto err_free_mem;
-	}
-	tsdata->input->phys = "/dev/input/event2";
-	tsdata->input->name = "pixcir_ts-touchscreen";//client->name;
-	tsdata->input->id.bustype = BUS_I2C;
-	tsdata->input->dev.parent = &client->dev;
-	
-	
-	///*
-	/*set_bit(EV_SYN,    tsdata->input->evbit);
-	set_bit(EV_KEY,    tsdata->input->evbit);
-	set_bit(EV_ABS,    tsdata->input->evbit);
-	set_bit(BTN_TOUCH, tsdata->input->keybit);
-	set_bit(BTN_2,     tsdata->input->keybit);//*/
-	
-	//tsdata->input->evbit[0] = BIT_MASK(EV_SYN) |  BIT_MASK(EV_ABS) ;
-	//tsdata->input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-	/*tsdata->input->absbit[0] = BIT_MASK(ABS_MT_POSITION_X) | BIT_MASK(ABS_MT_POSITION_Y) |
-			BIT_MASK(ABS_MT_TOUCH_MAJOR) | BIT_MASK(ABS_MT_WIDTH_MAJOR);  // for android*/
-	//tsdata->input->keybit[BIT_WORD(BTN_START)] = BIT_MASK(BTN_START);
-
-	//input_set_abs_params(input, ABS_X, 0, X_MAX, 0, 0);
-	//input_set_abs_params(input, ABS_Y, 0, Y_MAX, 0, 0);
-
-	__set_bit(INPUT_PROP_DIRECT, tsdata->input->propbit);
-	__set_bit(EV_ABS, tsdata->input->evbit);
-
-	input_mt_init_slots(tsdata->input, MAX_SUPPORT_POINT);
-	input_set_abs_params(tsdata->input, ABS_MT_POSITION_X,  pdata->x_min,  pdata->x_max, 0, 0);
-	input_set_abs_params(tsdata->input, ABS_MT_POSITION_Y,  pdata->y_min, pdata->y_max, 0, 0);
-	//input_set_abs_params(tsdata->input, ABS_MT_WIDTH_MAJOR, 0,   16, 0, 0);
-	//input_set_abs_params(tsdata->input, ABS_MT_PRESSURE, 0, 255, 0, 0);
-	input_set_abs_params(tsdata->input, ABS_MT_TOUCH_MAJOR, 0,    1, 0, 0);
-	//input_set_abs_params(tsdata->input, ABS_MT_TRACKING_ID, 0,    5, 0, 0);
-	input_set_drvdata(tsdata->input, tsdata);
-	//init int and reset ports
-	error = gpio_request(client->irq, "TS_INT");	//Request IO
-	if (error){
-		dev_err(&client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(int)client->irq, error);
-		goto err_free_mem;
-	}
-	rk29_mux_api_set(pdata->pendown_iomux_name, pdata->pendown_iomux_mode);
-	
-	gpio_direction_input(client->irq);
-	gpio_set_value(client->irq,GPIO_HIGH);
-	gpio_pull_updown(client->irq, 0);
-
-	error = gpio_request(pdata->gpio_reset, "pixcir_resetPin");
-	if(error){
-		dev_err(&client->dev, "failed to request resetPin GPIO%d\n", pdata->gpio_reset);
-		goto err_free_mem;
-	}
-	rk29_mux_api_set(pdata->resetpin_iomux_name, pdata->resetpin_iomux_mode);
-	/*{
-		gpio_pull_updown(pdata->gpio_reset, 1);
-		gpio_direction_output(pdata->gpio_reset, 0);
-		msleep(20);     //delay at least 1ms
-		gpio_direction_input(pdata->gpio_reset);
-		gpio_pull_updown(pdata->gpio_reset, 0);
-		msleep(120);
-	}*/
-    gpio_pull_updown(pdata->gpio_reset, 1);
-    mdelay(20);
-    gpio_direction_output(pdata->gpio_reset, 0);
-    gpio_set_value(pdata->gpio_reset,GPIO_HIGH);//GPIO_LOW
-    mdelay(100);
-    gpio_set_value(pdata->gpio_reset,GPIO_LOW);//GPIO_HIGH
-    mdelay(120);
-    // gpio_direction_input(pdata->gpio_reset);
-	printk("pdata->gpio_reset = %d\n",gpio_get_value(pdata->gpio_reset));
-    //printk("ts->gpio_irq = %d\n",gpio_get_value(pdata->gpio_pendown));
-	printk("pdata->gpio_pendown = %d\n",gpio_get_value(client->irq));
-
-#if 0
-	//**********************************************
-   char buffer[2];
-	buffer[0] = 0x3A;
-	buffer[1] = 0x03;
-	tp_pixcir_write_reg(client,buffer,2);
-	ssleep(6);
-	//********************************************************//
-#endif
-	client->irq = gpio_to_irq(client->irq);	
-  	error = request_irq(client->irq, pixcir_ts_isr, IRQF_TRIGGER_FALLING, client->name, (void *)tsdata);
-	if (error)
-		dev_err(&client->dev, "request_irq failed\n");
-/*
-	error = request_threaded_irq(client->irq, NULL, pixcir_ts_isr,
-				     IRQF_TRIGGER_FALLING,
-				     client->name, tsdata);*/
-	tsdata->use_irq = 1;
-	if (error) {
-		dev_err(&client->dev, "Unable to request touchscreen IRQ.\n");
-		tsdata->use_irq = 0;
-		goto err_free_mem;
-	}
-
-	error = input_register_device(tsdata->input);
-	if (error)
-		goto err_free_irq;
-
-	i2c_set_clientdata(client, tsdata);
-	device_init_wakeup(&client->dev, 1);
-
-	/*********************************Bee-0928-TOP****************************************/
-	i2c_dev = get_free_i2c_dev(client->adapter);
-	if (IS_ERR(i2c_dev)) {
-		error = PTR_ERR(i2c_dev);
-		return error;
-	}
-
-	dev = device_create(i2c_dev_class, &client->adapter->dev, MKDEV(I2C_MAJOR,
-			client->adapter->nr), NULL, "pixcir_i2c_ts%d", 0);
-	if (IS_ERR(dev)) {
-		error = PTR_ERR(dev);
-		return error;
-	}
-	/*********************************Bee-0928-BOTTOM****************************************/
-#ifdef CONFIG_HAS_EARLYSUSPEND
-    tsdata->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
-    tsdata->early_suspend.suspend = pixcir_ts_early_suspend;
-    tsdata->early_suspend.resume = pixcir_ts_late_resume;
-    register_early_suspend(&tsdata->early_suspend);
-#endif
-	pixcir_proc_entry = proc_create("driver/pixcir", 0777, NULL, &pixcir_proc_fops); 
-
-	dev_err(&tsdata->client->dev, "insmod successfully!\n");
-
-	return 0;
-
-err_free_irq:
-	free_irq(client->irq, tsdata);
-err_free_mem:
-	input_free_device(tsdata->input);
-	kfree(tsdata);
-	return error;
-}
-
-static int __devexit pixcir_i2c_ts_remove(struct i2c_client *client)
-{
-	int error;
-	struct i2c_dev *i2c_dev;
-	struct pixcir_i2c_ts_data *tsdata = i2c_get_clientdata(client);
-
-    unregister_early_suspend(&tsdata->early_suspend);
-	device_init_wakeup(&client->dev, 0);
-
-	tsdata->exiting = true;
-	mb();
-	free_irq(client->irq, tsdata);
-
-	/*********************************Bee-0928-TOP****************************************/
-	i2c_dev = get_free_i2c_dev(client->adapter);
-	if (IS_ERR(i2c_dev)) {
-		error = PTR_ERR(i2c_dev);
-		return error;
-	}
-
-	return_i2c_dev(i2c_dev);
-	device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, client->adapter->nr));
-	/*********************************Bee-0928-BOTTOM****************************************/
-
-	input_unregister_device(tsdata->input);
-	kfree(tsdata);
-
-	return 0;
-}
-
-/*************************************Bee-0928****************************************/
-/*                        	     pixcir_open                                     */
-/*************************************Bee-0928****************************************/
-static int pixcir_open(struct inode *inode, struct file *file)
-{
-	int subminor;
-	struct i2c_client *client;
-	struct i2c_adapter *adapter;
-	struct i2c_dev *i2c_dev;
-	int ret = 0;
-#if PIXCIR_DEBUG
-	printk("enter pixcir_open function\n");
-#endif
-	subminor = iminor(inode);
-
-	//lock_kernel();
-	i2c_dev = i2c_dev_get_by_minor(subminor);
-	if (!i2c_dev) {
-		printk("error i2c_dev\n");
-		return -ENODEV;
-	}
-
-	adapter = i2c_get_adapter(i2c_dev->adap->nr);
-	if (!adapter) {
-		return -ENODEV;
-	}
-	
-	client = kzalloc(sizeof(*client), GFP_KERNEL);
-	if (!client) {
-		i2c_put_adapter(adapter);
-		ret = -ENOMEM;
-	}
-
-	snprintf(client->name, I2C_NAME_SIZE, "pixcir_i2c_ts%d", adapter->nr);
-	client->driver = &pixcir_i2c_ts_driver;
-	client->adapter = adapter;
-	
-	file->private_data = client;
-
-	return 0;
-}
-
-/*************************************Bee-0928****************************************/
-/*                        	     pixcir_ioctl                                    */
-/*************************************Bee-0928****************************************/
-static long pixcir_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	//printk("ioctl function\n");
-	struct i2c_client *client = (struct i2c_client *) file->private_data;
-#if PIXCIR_DEBUG
-	printk("cmd = %d,arg = %d\n", cmd, arg);
-#endif
-
-	switch (cmd)
-	{
-	case CALIBRATION_FLAG: //CALIBRATION_FLAG = 1
-#if PIXCIR_DEBUG
-		printk("CALIBRATION\n");
-#endif
-		client->addr = SLAVE_ADDR;
-		status_reg = 0;
-		status_reg = CALIBRATION_FLAG;
-		break;
-
-	default:
-		break;//return -ENOTTY;
-	}
-	return 0;
-}
-
-
-/***********************************Bee-0928****************************************/
-/*                        	  pixcir_write                                     */
-/***********************************Bee-0928****************************************/
-static ssize_t pixcir_write(struct file *file,const char __user *buf,size_t count, loff_t *ppos)
-{
-	struct i2c_client *client;
-	char *tmp;
-	static int ret=0;
-	
-	pixcir_dbg("%s\n",__FUNCTION__);
-
-	client = file->private_data;
-
-	//printk("pixcir_write function\n");
-	switch(status_reg)
-	{
-		case CALIBRATION_FLAG: //CALIBRATION_FLAG=1
-		tmp = kmalloc(count,GFP_KERNEL);
-		if (tmp==NULL)
-			return -ENOMEM;
-
-		if (copy_from_user(tmp,buf,count)) { 	
-			printk("CALIBRATION_FLAG copy_from_user error\n");
-			kfree(tmp);
-			return -EFAULT;
-		}
-
-		ret = i2c_master_send(client,tmp,count);
-		if (ret!=count ) {
-			dev_err(&client->dev,
-				"%s: i2c_master_recv failed(), ret=%d\n",
-				__func__, ret);
-		}
-
-		while(!attb_read_val());//waiting to finish the calibration.(pixcir application_note_710_v3 p43)
-
-		kfree(tmp);
-
-		status_reg = 0;
-		break;
-
-		default:
-		break;
-	}
-	return ret;
-}
-
-/***********************************Bee-0928****************************************/
-/*                        	  pixcir_release                                   */
-/***********************************Bee-0928****************************************/
-static int pixcir_release(struct inode *inode, struct file *file)
-{
-	struct i2c_client *client = file->private_data;
-   #if PIXCIR_DEBUG
-	printk("enter pixcir_release funtion\n");
-   #endif
-	i2c_put_adapter(client->adapter);
-	kfree(client);
-	file->private_data = NULL;
-
-	return 0;
-}
-
-/*********************************Bee-0928-TOP****************************************/
-static const struct file_operations pixcir_i2c_ts_fops =
-{	.owner		= THIS_MODULE,
-	.write		= pixcir_write,
-	.open		= pixcir_open,
-	.unlocked_ioctl = pixcir_ioctl,
-	.release	= pixcir_release,
-};
-/*********************************Bee-0928-BOTTOM****************************************/
-
-static int pixcir_ts_suspend(struct i2c_client *client, pm_message_t mesg)
-{
-	u8 wrbuf[] = {0x33,0x03};
-	int ret = 0;
-    struct pixcir_i2c_ts_data *ts = i2c_get_clientdata(client);
-	DBG("%s\n", __FUNCTION__);
-
-	ret = i2c_master_send(ts->client, wrbuf, sizeof(wrbuf));
-	if (ret != sizeof(wrbuf)) {
-		dev_err(&ts->client->dev,
-			"%s: i2c_master_send failed(), ret=%d\n",
-			__func__, ret);
-		return 0;
-	}
-
-	ret = cancel_work_sync(&ts->work);
-
-	if (ts->use_irq)
-		disable_irq(client->irq);
-	//gpio_set_value(ts->gpio_reset, ts->gpio_reset_active_low? GPIO_LOW:GPIO_HIGH);
-	return 0;
-}
-
-static int pixcir_ts_resume(struct i2c_client *client)
-{
-	int ret = 0;
-    struct pixcir_i2c_ts_data *ts = i2c_get_clientdata(client);
-    struct pixcir_platform_data	*pdata = client->dev.platform_data;
-	DBG("%s: \n", __FUNCTION__);
-
-    gpio_set_value(pdata->gpio_reset,GPIO_HIGH);//GPIO_LOW
-	msleep(10);
-    gpio_set_value(pdata->gpio_reset,GPIO_LOW);//GPIO_HIGH
-	msleep(120);
-
-	if (ts->use_irq)
-		enable_irq(client->irq);
-    //gpio_set_value(ts->gpio_reset, ts->gpio_reset_active_low? GPIO_HIGH:GPIO_LOW);
-	return 0;
-}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void pixcir_ts_early_suspend(struct early_suspend *h)
-{
-    struct pixcir_i2c_ts_data *ts;
-	DBG("%s\n",__FUNCTION__);
-    ts = container_of(h, struct pixcir_i2c_ts_data, early_suspend);
-    pixcir_ts_suspend(ts->client, PMSG_SUSPEND);
-}
-
-static void pixcir_ts_late_resume(struct early_suspend *h)
-{
-    struct pixcir_i2c_ts_data *ts;
-	DBG("%s\n",__FUNCTION__);
-    ts = container_of(h, struct pixcir_i2c_ts_data, early_suspend);
-    pixcir_ts_resume(ts->client);
-}
-#endif
-
-static const struct i2c_device_id pixcir_i2c_ts_id[] = {
-	{ "pixcir_ts", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, pixcir_i2c_ts_id);
-
-static struct i2c_driver pixcir_i2c_ts_driver = {
-	.driver = {
-		.owner	= THIS_MODULE,
-		.name	= "pixcir_ts",
-		//.pm	= &pixcir_dev_pm_ops,
-	},
-#ifndef CONFIG_HAS_EARLYSUSPEND
-    .suspend    = pixcir_ts_suspend,
-    .resume     = pixcir_ts_resume,
-#endif
-	.probe		= pixcir_i2c_ts_probe,
-	.remove		= __devexit_p(pixcir_i2c_ts_remove),
-	.id_table	= pixcir_i2c_ts_id,
-};
-
-static int __init pixcir_i2c_ts_init(void)
-{
-	int ret;
-
-	pixcir_dbg("%s\n",__FUNCTION__);
-	
-    pixcir_wq = create_singlethread_workqueue("pixcir_wq");
-    if (!pixcir_wq)
-        return -ENOMEM;
-
-	/*********************************Bee-0928-TOP****************************************/
-	ret = register_chrdev(I2C_MAJOR,"pixcir_i2c_ts",&pixcir_i2c_ts_fops);
-	if (ret) {
-		printk(KERN_ERR "%s:register chrdev failed\n",__FILE__);
-		return ret;
-	}
-
-	i2c_dev_class = class_create(THIS_MODULE, "pixcir_i2c_dev");
-	if (IS_ERR(i2c_dev_class)) {
-		ret = PTR_ERR(i2c_dev_class);
-		class_destroy(i2c_dev_class);
-	}
-	/********************************Bee-0928-BOTTOM******************************************/
-
-	//tangoC_init();
-
-	return i2c_add_driver(&pixcir_i2c_ts_driver);
-}
-module_init(pixcir_i2c_ts_init);
-
-static void __exit pixcir_i2c_ts_exit(void)
-{
-	i2c_del_driver(&pixcir_i2c_ts_driver);
-    if (pixcir_wq)
-        destroy_workqueue(pixcir_wq);
-	/********************************Bee-0928-TOP******************************************/
-	class_destroy(i2c_dev_class);
-	unregister_chrdev(I2C_MAJOR,"pixcir_i2c_ts");
-	/********************************Bee-0928-BOTTOM******************************************/
-}
-module_exit(pixcir_i2c_ts_exit);
-
-MODULE_AUTHOR("Jianchun Bian <jcbian@pixcir.com.cn>");
-MODULE_DESCRIPTION("Pixcir I2C Touchscreen Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 1b305b4c5847..b84e46bdedce 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -323,13 +323,6 @@ config LEDS_BD2802
 	  This option enables support for BD2802GU RGB LED driver chips
 	  accessed via the I2C bus.
 
-config LEDS_ATT1272
-	tristate "LED driver for ATT1272 LED"
-	depends on LEDS_CLASS && I2C
-	help
-	  This option enables support for ATT1272 LED driver chips
-	  accessed via the I2C bus.
-
 config LEDS_INTEL_SS4200
 	tristate "LED driver for Intel NAS SS4200 series"
 	depends on LEDS_CLASS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 7d82ccccf4ed..cb77b9bb2f98 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -34,7 +34,6 @@ obj-$(CONFIG_LEDS_DA903X)		+= leds-da903x.o
 obj-$(CONFIG_LEDS_WM831X_STATUS)	+= leds-wm831x-status.o
 obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
 obj-$(CONFIG_LEDS_PWM)			+= leds-pwm.o
-obj-$(CONFIG_LEDS_ATT1272)		+= leds-att1272.o
 obj-$(CONFIG_LEDS_REGULATOR)		+= leds-regulator.o
 obj-$(CONFIG_LEDS_INTEL_SS4200)		+= leds-ss4200.o
 obj-$(CONFIG_LEDS_LT3593)		+= leds-lt3593.o
diff --git a/drivers/leds/leds-wm831x-status.c b/drivers/leds/leds-wm831x-status.c
index 067bab3eb831..ef5c24140a44 100644
--- a/drivers/leds/leds-wm831x-status.c
+++ b/drivers/leds/leds-wm831x-status.c
@@ -19,15 +19,6 @@
 #include <linux/mfd/wm831x/pdata.h>
 #include <linux/mfd/wm831x/status.h>
 
-struct light_state_t {
-	unsigned int color;
-
-	int mode;
-	int onms;
-	int offms;
-
-	int brightness;
-};
 
 struct wm831x_status {
 	struct led_classdev cdev;
@@ -165,102 +156,6 @@ static int wm831x_status_blink_set(struct led_classdev *led_cdev,
 	return ret;
 }
 
-static ssize_t wm831x_status_blink_store(struct device *dev,
-				       struct device_attribute *attr,
-				       const char *buf, size_t size)
-{
-	struct led_classdev *led_cdev = dev_get_drvdata(dev);
-	struct wm831x_status *led = to_wm831x_status(led_cdev);
-	struct light_state_t *light_state = NULL;
-	unsigned long flags;
-	int ret = 0;
-    enum led_brightness value;
-	unsigned int delay_on, delay_off, mode, color;
-
-	if (size != sizeof (struct light_state_t)) {
-		printk("%s: set led blink err\n", __func__);
-		return -1;
-	}
-
-	light_state = (struct light_state_t *)buf;
-	if (light_state) {
-		led->src = 3;
-
-		value = light_state->brightness;
-		delay_on = light_state->onms;
-		delay_off = light_state->offms;
-		mode = light_state->mode;
-		color = light_state->color;
-
-		//printk("%s: color = %#x delay_on = %d delya_off = %d brightness = %d mode = %d\n",
-		//		__func__, color, delay_on, delay_off, value, mode);
-		if (delay_on == 0 && delay_off == 0) {
-			delay_on = 250;
-			delay_off = 250;
-		}
-
-		spin_lock_irqsave(&led->value_lock, flags);
-
-		switch (delay_on) {
-		case 1000:
-			led->blink_time = 0;
-			break;
-		case 500:
-		case 250:
-			led->blink_time = 1;
-			break;
-		case 125:
-			led->blink_time = 2;
-			break;
-		case 62:
-		case 63:
-			/* Actually 62.5ms */
-			led->blink_time = 3;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
-
-		if (ret == 0) {
-			switch (delay_off / delay_on) {
-			case 1:
-				led->blink_cyc = 0;
-				break;
-			case 3:
-				led->blink_cyc = 1;
-				break;
-			case 4:
-				led->blink_cyc = 2;
-				break;
-			case 8:
-				led->blink_cyc = 3;
-				break;
-			default:
-				ret = -EINVAL;
-				break;
-			}
-		}
-
-		if (ret == 0)
-			led->blink = 1;
-		else
-			led->blink = 0;
-		
-		//set led brightness
-		led->brightness = mode;
-		if (led->brightness == LED_OFF)
-			led->blink = 0;
-
-		schedule_work(&led->work);
-
-		spin_unlock_irqrestore(&led->value_lock, flags);
-	}
-
-	return size;
-}
-static DEVICE_ATTR(blink, 0777, NULL, wm831x_status_blink_store);
-
 static const char *led_src_texts[] = {
 	"otp",
 	"power",
@@ -367,8 +262,6 @@ static int wm831x_status_probe(struct platform_device *pdev)
 	/* We cache the configuration register and read startup values
 	 * from it. */
 	drvdata->reg_val = wm831x_reg_read(wm831x, drvdata->reg);
-	if (drvdata->reg == WM831X_STATUS_LED_2)
-		wm831x_reg_write(wm831x, drvdata->reg, 0xc027);
 
 	if (drvdata->reg_val & WM831X_LED_MODE_MASK)
 		drvdata->brightness = LED_FULL;
@@ -397,11 +290,6 @@ static int wm831x_status_probe(struct platform_device *pdev)
 		goto err_led;
 	}
 
-	ret = device_create_file(drvdata->cdev.dev, &dev_attr_blink);
-	if (ret != 0)
-		dev_err(&pdev->dev,
-			"LED no blink function: %d\n", ret);
-
 	ret = device_create_file(drvdata->cdev.dev, &dev_attr_src);
 	if (ret != 0)
 		dev_err(&pdev->dev,
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 3c76616d6d92..bb53de7fe408 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -70,7 +70,6 @@ config VIDEOBUF2_DMA_SG
 # Multimedia Video device configuration
 #
 
-source "drivers/media/video/rk29xx/Kconfig"
 menuconfig VIDEO_CAPTURE_DRIVERS
 	bool "Video capture adapters"
 	depends on VIDEO_V4L2
@@ -787,8 +786,8 @@ config SOC_CAMERA_IMX074
 	tristate "imx074 support"
 	depends on SOC_CAMERA && I2C
 	help
-	  This driver supports IMX074 cameras from Sony	 
-	   
+	  This driver supports IMX074 cameras from Sony
+
 config SOC_CAMERA_MT9M001
 	tristate "mt9m001 support"
 	depends on SOC_CAMERA && I2C
@@ -804,17 +803,11 @@ config SOC_CAMERA_MT9M111
 	  This driver supports MT9M111, MT9M112 and MT9M131 cameras from
 	  Micron/Aptina
 
-config SOC_CAMERA_MT9M112
-	tristate "mt9m112 support"
-	depends on SOC_CAMERA && I2C
-	help
-	  This driver supports MT9M112 cameras from Micron
-
 config SOC_CAMERA_MT9T031
 	tristate "mt9t031 support"
 	depends on SOC_CAMERA && I2C
 	help
-	  This driver supports MT9T031 cameras from Micron.	 
+	  This driver supports MT9T031 cameras from Micron.
 
 config SOC_CAMERA_MT9T112
 	tristate "mt9t112 support"
@@ -822,7 +815,6 @@ config SOC_CAMERA_MT9T112
 	help
 	  This driver supports MT9T112 cameras from Aptina.
 
-
 config SOC_CAMERA_MT9V022
 	tristate "mt9v022 support"
 	depends on SOC_CAMERA && I2C
@@ -830,7 +822,6 @@ config SOC_CAMERA_MT9V022
 	help
 	  This driver supports MT9V022 cameras from Micron
 
-
 config SOC_CAMERA_RJ54N1
 	tristate "rj54n1cb0c support"
 	depends on SOC_CAMERA && I2C
@@ -843,11 +834,18 @@ config SOC_CAMERA_TW9910
 	help
 	  This is a tw9910 video driver
 
+config SOC_CAMERA_PLATFORM
+	tristate "platform camera support"
+	depends on SOC_CAMERA
+	help
+	  This is a generic SoC camera platform driver, useful for testing
+
 config SOC_CAMERA_OV2640
 	tristate "ov2640 camera support"
 	depends on SOC_CAMERA && I2C
 	help
 	  This is a ov2640 camera driver
+
 config SOC_CAMERA_OV6650
 	tristate "ov6650 sensor support"
 	depends on SOC_CAMERA && I2C
@@ -858,438 +856,19 @@ config SOC_CAMERA_OV772X
 	tristate "ov772x camera support"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov772x camera driver	  
-	  
+	  This is a ov772x camera driver
+
 config SOC_CAMERA_OV9640
 	tristate "ov9640 camera support"
 	depends on SOC_CAMERA && I2C
 	help
 	  This is a ov9640 camera driver
 
-
 config SOC_CAMERA_OV9740
 	tristate "ov9740 camera support"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov9740 camera driver	  
-
-config SOC_CAMERA_PLATFORM
-	tristate "platform camera support"
-	depends on SOC_CAMERA
-	help
-	  This is a generic SoC camera platform driver, useful for testing	   
-	  
-menu "ROCKCHIP SUPPORTED SOC CAMERAS"
-	depends on SOC_CAMERA
-
-config SOC_CAMERA_MT9T111
-	tristate "mt9t111 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This driver supports MT9T111 cameras from Micron for rockchip.
-
-config SOC_CAMERA_MT9P111
-	tristate "mt9p111 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This driver supports MT9P111 cameras from Micron for rockchip.	  
-
-config SOC_CAMERA_MT9D112
-	tristate "mt9d112 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This driver supports MT9D112 cameras from Micron for rockchip
-
-
-config SOC_CAMERA_MT9D113
-	tristate "mt9d113 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This driver supports MT9D113 cameras from Micron for rockchip
-
-
-config SOC_CAMERA_OV7675
-	tristate "ov7675 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a ov7675 camera driver for rockchip
-
-config SOC_CAMERA_OV2655
-	tristate "ov2655 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a ov2655 camera driver for rockchip
-
-
-config SOC_CAMERA_OV2659
-	tristate "ov2659 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a ov2659 camera driver for rockchip
-	  
-
-config SOC_CAMERA_OV7690
-	tristate "ov7690 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a ov7690 camera driver for rockchip	
-
-
-config SOC_CAMERA_OV9650
-	tristate "ov9650 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a ov9650 camera driver for rockchip
-
-
-config SOC_CAMERA_OV2640_RK
-	tristate "ov2640 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a ov2640 camera driver for rockchip
-	  
-
-config SOC_CAMERA_OV3640
-	tristate "ov3640 camera support for rockchip"
-	depends on SOC_CAMERA && I2C && VIDEO_RK29
-	default y
-	help
-	  This is a ov3640 camera driver for rockchip
-	  
-config OV3640_USER_DEFINED_SERIES
-	depends on SOC_CAMERA_OV3640
-	bool "OV3640 user defined init series"
-	default n
-
-choice
-	prompt "OV3640 Module Focus select"
-	depends on SOC_CAMERA_OV3640
-	default OV3640_AUTOFOCUS
-	---help---
-
-config OV3640_AUTOFOCUS
-	bool "OV3640 auto focus"
-
-config OV3640_FIXEDFOCUS
-	bool "OV3640 fixed focus"
-endchoice
-	  
-config SOC_CAMERA_OV3660
-	tristate "ov3660 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a ov3660 camera driver for rockchip
-	  
-
-config SOC_CAMERA_OV5642
-	tristate "ov5642 camera support for rockchip"
-	depends on SOC_CAMERA && I2C && VIDEO_RK29
-	default y
-	help
-	  This is a ov5642 camera driver for rockchip
-
-config OV5642_USER_DEFINED_SERIES
-	depends on SOC_CAMERA_OV5642
-	bool "OV5642 user defined init series"
-	default n
-
-config SOC_CAMERA_OV5642_INTERPOLATION
-	bool "support sensor interpolation for higher resolution"
-	depends on SOC_CAMERA_OV5642
-choice
-	prompt "OV5642 interpolation resolution"
-	depends on SOC_CAMERA_OV5642_INTERPOLATION
-	default SOC_CAMERA_OV5642_INTERPOLATION_8M
-	---help---
-		OV5642 interpolation resolution
-		
-config SOC_CAMERA_OV5642_INTERPOLATION_8M
-	bool "8 megapixel 3264x2448"
-endchoice
-
-choice
-	prompt "OV5642 Module Focus select"
-	depends on SOC_CAMERA_OV5642
-	default OV5642_AUTOFOCUS
-	---help---
-
-config OV5642_AUTOFOCUS
-	bool "OV5642 auto focus"
-
-config OV5642_FIXEDFOCUS
-	bool "OV5642 fixed focus"
-endchoice
-
-config SOC_CAMERA_OV5640
-	tristate "ov5640 camera support for rockchip"
-	depends on SOC_CAMERA && I2C && VIDEO_RK29
-	default y
-	help
-	  This is a ov5640 camera driver for rockchip
-
-config OV5640_USER_DEFINED_SERIES
-	depends on SOC_CAMERA_OV5640
-	bool "OV5640 user defined init series"
-	default n
-
-choice
-	prompt "OV5640 Module Focus select"
-	depends on SOC_CAMERA_OV5640
-	default OV5640_AUTOFOCUS
-	---help---
-
-config OV5640_AUTOFOCUS
-	bool "OV5640 auto focus"
-
-config OV5640_FIXEDFOCUS
-	bool "OV5640 fixed focus"
-endchoice
-
-config SOC_CAMERA_S5K6AA
-	tristate "Samsung S5K6AA camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a samsung S5K6AA camera driver for rockchip
-
-config SOC_CAMERA_GT2005
-	tristate "GT2005 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a GT2005 camera driver for rockchip
-
-config SOC_CAMERA_GC0307
-	tristate "GC0307 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a GC0307 camera driver for rockchip	   
-
-config SOC_CAMERA_GC0308
-	tristate "GC0308 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a GC0308 camera driver for rockchip
-
-config SOC_CAMERA_GC0328
-    tristate "GC0328 support for rockchip"
-    depends on SOC_CAMERA && I2C
-    help
-      This is a GC0328 camera driver for rockchip
-config SOC_CAMERA_GC0309
-	tristate "GC0309 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a GC0309 camera driver for rockchip
-
-config SOC_CAMERA_GC2015
-	tristate "GC2015 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a GC2015 camera driver for rockchip
-
-config SOC_CAMERA_GC2035
-        tristate "GC2035 support for rockchip"
-        depends on SOC_CAMERA && I2C
-        help
-          This is a GC2035 camera driver for rockchip
-
-config SOC_CAMERA_HI253
-	tristate "HI253 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a HI253 camera driver for rockchip
-
-config SOC_CAMERA_HI704
-	tristate "HI704 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a HI704 camera driver for rockchip
-
-
-config SOC_CAMERA_SIV120B
-	tristate "siv120b support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a SIV120B camera driver for rockchip
-
-	
-config SOC_CAMERA_SIV121D
-	tristate "siv121d support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a SIV121D camera driver for rockchip
-	  
-config SOC_CAMERA_SID130B
-	tristate "sid130b support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a SID130B camera driver for rockchip
-
-config SOC_CAMERA_NT99160
-	tristate "NT99160 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a NT99160 camera driver for rockchip
-	  
-config SOC_CAMERA_NT99240
-	tristate "NT99240 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a NT99240 camera driver for rockchip
-
-config SOC_CAMERA_NT99250
-	tristate "NT99250 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a NT99250 camera driver for rockchip
-	  
-config SOC_CAMERA_NT99252
-	tristate "NT99252 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a NT99252 camera driver for rockchip
-	  
-config SOC_CAMERA_NT99340
-	tristate "NT99340 support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a NT99340 camera driver for rockchip	  	  
-
-config SOC_CAMERA_GC0329
-	tristate "gc0329 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a gc0329 camera driver for rockchip
-	  
-
-config SOC_CAMERA_S5K5CA
-	tristate "s5k5ca camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a s5k5ca camera driver for rockchip
-
-config SOC_CAMERA_SP0718
-	tristate "sp0718 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a sp0718 camera driver for rockchip	  
-	
-config SOC_CAMERA_SP0838
-	tristate "sp0838 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a sp0838 camera driver for rockchip
-	  
-
-config SOC_CAMERA_SP2518
-	tristate "sp2518 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a sp2518 camera driver for rockchip
-	  
-config SOC_CAMERA_HM2057
-	tristate "hm2057 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a HM2057 camera driver for rockchip
-
-config SOC_CAMERA_HM5065
-	tristate "hm5065 camera support for rockchip"
-	depends on SOC_CAMERA && I2C
-	help
-	  This is a HM5065 camera driver for rockchip
-	  
-config SOC_CAMERA_MV9335
-        tristate "MtekVision camera isp chip"
-        depends on SOC_CAMERA && I2C
-        help
-          MtekVision camera isp chip
-
-source "drivers/media/video/mv9335/Kconfig"	
-config SOC_CAMERA_ICATCH7002
-        tristate "Icatch camera isp chip"
-        depends on SOC_CAMERA && I2C
-		default n
-        help
-          Icatch camera isp chip
-
-source "drivers/media/video/icatch7002/Kconfig"	
-
-config VIDEO_RK29
-	tristate "RKXX Camera Sensor Interface driver"
-	depends on VIDEO_DEV && PLAT_RK && SOC_CAMERA && HAS_DMA
-	select VIDEOBUF_DMA_CONTIG
-	---help---
-	  This is a v4l2 driver for the RK29XX Camera Sensor Interface
-
-choice
-	prompt "RKXX Camera Sensor Interface Work Mode"
-	depends on VIDEO_RK29
-	default VIDEO_RKCIF_WORK_ONEFRAME
-	---help---
-		RK29 Camera Sensor Interface(VIP) can work in 2 modes, ie:OneFrame,PingPong.
-
-config VIDEO_RKCIF_WORK_ONEFRAME
-	bool "CIF OneFrame Mode"
-
-config VIDEO_RKCIF_WORK_PINGPONG
-	bool "CIF PingPong Mode"
-
-endchoice
-
-choice
-	prompt "RKXX camera sensor interface work with IPP "
-	depends on VIDEO_RK29 && RK29_IPP
-	default VIDEO_RK29_WORK_IPP
-	---help---
-		RK29 Camera Sensor Interface(VIP) can work with IPP or not IPP
-
-config VIDEO_RK29_WORK_IPP
-	bool "CIF work with IPP"
-
-config VIDEO_RK29_WORK_NOT_IPP
-	bool "CIF don't work with IPP"
-
-endchoice
-choice
-	prompt "RKXX camera digital zoom with IPP "
-	depends on VIDEO_RK29 && RK29_IPP && VIDEO_RK29_WORK_IPP
-	default VIDEO_RK29_DIGITALZOOM_IPP_ON
-	---help---
-		RK Camera digital zoom with IPP
-config VIDEO_RK29_DIGITALZOOM_IPP_ON
-	bool "Digital zoom with IPP on"
-
-config VIDEO_RK29_DIGITALZOOM_IPP_OFF
-	bool "Digital zoom with IPP off"
-endchoice
-
-choice
-	prompt "RKXX camera memory "
-	depends on VIDEO_RK29 
-	default VIDEO_RK29_CAMMEM_PMEM
-	---help---
-		where camera memory which is used for preview/raw/jpeg in android camera hal is alloced 
-config VIDEO_RK29_CAMMEM_PMEM
-	bool "Camera memory from pmem"
-
-config VIDEO_RK29_CAMMEM_ION
-	bool "Camera memory from ion"
-endchoice
-
-choice
-	prompt "RKXX CIF work simultaneity"
-	depends on VIDEO_RK29 && ARCH_RK30
-	default VIDEO_RKCIF_WORK_SIMUL_OFF
-	---help---
-               CIFs work simultaneity 
-config VIDEO_RKCIF_WORK_SIMUL_ON
-	bool "Two cif controller can work sumultaneity"
-
-config VIDEO_RKCIF_WORK_SIMUL_OFF
-	bool "Two cif controller cann't work sumultaneity"
-endchoice
-endmenu
-
+	  This is a ov9740 camera driver
 
 config MX1_VIDEO
 	bool
@@ -1349,8 +928,6 @@ config VIDEO_OMAP2
 	---help---
 	  This is a v4l2 driver for the TI OMAP2 camera capture interface
 
-
-
 config VIDEO_MX2_HOSTSUPPORT
 	bool
 
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index f3b5433da7b4..f0fecd6f6a33 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -74,14 +74,9 @@ obj-$(CONFIG_VIDEO_M5MOLS)	+= m5mols/
 obj-$(CONFIG_SOC_CAMERA_IMX074)		+= imx074.o
 obj-$(CONFIG_SOC_CAMERA_MT9M001)	+= mt9m001.o
 obj-$(CONFIG_SOC_CAMERA_MT9M111)	+= mt9m111.o
-obj-$(CONFIG_SOC_CAMERA_MT9M112)	+= mt9m112.o
 obj-$(CONFIG_SOC_CAMERA_MT9T031)	+= mt9t031.o
-obj-$(CONFIG_SOC_CAMERA_MT9T111)	+= mt9t111.o
 obj-$(CONFIG_SOC_CAMERA_MT9T112)	+= mt9t112.o
 obj-$(CONFIG_SOC_CAMERA_MT9V022)	+= mt9v022.o
-obj-$(CONFIG_SOC_CAMERA_MT9P111)	+= mt9p111.o
-obj-$(CONFIG_SOC_CAMERA_MT9D112)	+= mt9d112.o
-obj-$(CONFIG_SOC_CAMERA_MT9D113)	+= mt9d113.o
 obj-$(CONFIG_SOC_CAMERA_OV2640)		+= ov2640.o
 obj-$(CONFIG_SOC_CAMERA_OV6650)		+= ov6650.o
 obj-$(CONFIG_SOC_CAMERA_OV772X)		+= ov772x.o
@@ -89,44 +84,7 @@ obj-$(CONFIG_SOC_CAMERA_OV9640)		+= ov9640.o
 obj-$(CONFIG_SOC_CAMERA_OV9740)		+= ov9740.o
 obj-$(CONFIG_SOC_CAMERA_RJ54N1)		+= rj54n1cb0c.o
 obj-$(CONFIG_SOC_CAMERA_TW9910)		+= tw9910.o
-obj-$(CONFIG_SOC_CAMERA_OV7675)		+= ov7675.o
-obj-$(CONFIG_SOC_CAMERA_OV2655)		+= ov2655.o
-obj-$(CONFIG_SOC_CAMERA_OV2659)		+= ov2659.o
-obj-$(CONFIG_SOC_CAMERA_OV7690)		+= ov7690.o
-obj-$(CONFIG_SOC_CAMERA_OV9650)		+= ov9650.o
-obj-$(CONFIG_SOC_CAMERA_OV2640_RK)		+= ov2640_rk.o
-obj-$(CONFIG_SOC_CAMERA_OV3640)		+= ov3640.o
-obj-$(CONFIG_SOC_CAMERA_OV3660)		+= ov3660.o
-obj-$(CONFIG_SOC_CAMERA_OV5640)		+= ov5640.o
-obj-$(CONFIG_SOC_CAMERA_OV5640_FOR_TD8801)		+= ov5640_for_td8801.o
-obj-$(CONFIG_SOC_CAMERA_OV5642)		+= ov5642.o
-obj-$(CONFIG_SOC_CAMERA_S5K6AA)		+= s5k6aa.o
-obj-$(CONFIG_SOC_CAMERA_GT2005)		+= gt2005.o
-obj-$(CONFIG_SOC_CAMERA_GC0307)		+= gc0307.o
-obj-$(CONFIG_SOC_CAMERA_GC0308)		+= gc0308.o
-obj-$(CONFIG_SOC_CAMERA_GC0328)     += gc0328.o
-obj-$(CONFIG_SOC_CAMERA_GC0309)		+= gc0309.o
-obj-$(CONFIG_SOC_CAMERA_GC2015)		+= gc2015.o
-obj-$(CONFIG_SOC_CAMERA_GC2035)         += gc2035.o
-obj-$(CONFIG_SOC_CAMERA_SIV120B)	+= siv120b.o
-obj-$(CONFIG_SOC_CAMERA_SIV121D)	+= siv121d.o
-obj-$(CONFIG_SOC_CAMERA_SID130B)	+= sid130B.o
-obj-$(CONFIG_SOC_CAMERA_HI253)	+= hi253.o
-obj-$(CONFIG_SOC_CAMERA_HI704)	+= hi704.o
-obj-$(CONFIG_SOC_CAMERA_NT99160)	+= nt99160_2way.o
-obj-$(CONFIG_SOC_CAMERA_NT99240)	+= nt99240_2way.o
-obj-$(CONFIG_SOC_CAMERA_NT99250)	+= nt99250.o
-obj-$(CONFIG_SOC_CAMERA_NT99252)	+= nt99252_3way.o
-obj-$(CONFIG_SOC_CAMERA_NT99340)	+= nt99340_2way.o
-obj-$(CONFIG_SOC_CAMERA_GC0329)	+= gc0329.o
-#obj-$(CONFIG_SOC_CAMERA_SP0718)	+= sp0718.o
-obj-$(CONFIG_SOC_CAMERA_SP0838)	+= sp0838.o
-obj-$(CONFIG_SOC_CAMERA_SP2518)	+= sp2518.o
-obj-$(CONFIG_SOC_CAMERA_S5K5CA)	+= s5k5ca.o
-obj-$(CONFIG_SOC_CAMERA_HM2057)	+= hm2057.o
-obj-$(CONFIG_SOC_CAMERA_HM5065)	+= hm5065.o
-obj-$(CONFIG_SOC_CAMERA_MV9335) += mv9335/
-obj-$(CONFIG_SOC_CAMERA_ICATCH7002)	+= icatch7002/
+
 # And now the v4l2 drivers:
 
 obj-$(CONFIG_VIDEO_BT848) += bt8xx/
@@ -205,33 +163,6 @@ obj-$(CONFIG_VIDEO_MX1)			+= mx1_camera.o
 obj-$(CONFIG_VIDEO_MX2)			+= mx2_camera.o
 obj-$(CONFIG_VIDEO_MX3)			+= mx3_camera.o
 obj-$(CONFIG_VIDEO_PXA27x)		+= pxa_camera.o
-ifeq ($(CONFIG_ARCH_RK30),y)
-obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME)	+= rk30_camera_oneframe.o
-obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG)	+= rk30_camera_pingpong.o
-endif
-ifeq ($(CONFIG_ARCH_RK3188),y)
-obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME) += rk30_camera_oneframe.o
-obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG) += rk30_camera_pingpong.o
-endif
-
-ifeq ($(CONFIG_ARCH_RK2928),y)
-obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME)  += rk30_camera_oneframe.o
-obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG)	+= rk30_camera_pingpong.o
-endif
-
-ifeq ($(CONFIG_ARCH_RK3026),y)
-obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME) += rk30_camera_oneframe.o
-obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG) += rk30_camera_pingpong.o
-endif
-
-ifeq ($(CONFIG_ARCH_RK29),y)
-obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME)  += rk29_camera_oneframe.o
-obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG)	+= rk29_camera_pingpang.o
-endif
-obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME)  += generic_sensor.o
-obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG)  += generic_sensor.o
-
-obj-$(CONFIG_VIDEO_RK29XX_VOUT)		+= rk29xx/
 obj-$(CONFIG_VIDEO_SH_MOBILE_CSI2)	+= sh_mobile_csi2.o
 obj-$(CONFIG_VIDEO_SH_MOBILE_CEU)	+= sh_mobile_ceu_camera.o
 obj-$(CONFIG_VIDEO_OMAP1)		+= omap1_camera.o
diff --git a/drivers/media/video/ov2640.c b/drivers/media/video/ov2640.c
index 9b2ac56310ef..0cea0cf36679 100644
--- a/drivers/media/video/ov2640.c
+++ b/drivers/media/video/ov2640.c
@@ -1,5 +1,4 @@
 /*
-<<<<<<< HEAD
  * ov2640 Camera Driver
  *
  * Copyright (C) 2010 Alberto Panizzo <maramaopercheseimorto@gmail.com>
@@ -8,18 +7,12 @@
  *
  * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright (C) 2006, OmniVision
-=======
-o* Driver for MT9M001 CMOS Image Sensor from Micron
- *
- * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
->>>>>>> parent of 15f7fab... temp revert rk change
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
 
-<<<<<<< HEAD
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/i2c.h>
@@ -1210,2963 +1203,3 @@ module_exit(ov2640_module_exit);
 MODULE_DESCRIPTION("SoC Camera driver for Omni Vision 2640 sensor");
 MODULE_AUTHOR("Alberto Panizzo");
 MODULE_LICENSE("GPL v2");
-=======
-#include <linux/videodev2.h>
-#include <linux/slab.h>
-#include <linux/i2c.h>
-#include <linux/log2.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/circ_buf.h>
-#include <linux/miscdevice.h>
-#include <media/v4l2-common.h>
-#include <media/v4l2-chip-ident.h>
-#include <media/soc_camera.h>
-#include <mach/rk29_camera.h>
-
-static int debug;
-module_param(debug, int, S_IRUGO|S_IWUSR);
-
-#define dprintk(level, fmt, arg...) do {			\
-	if (debug >= level) 					\
-	printk(KERN_WARNING fmt , ## arg); } while (0)
-
-#define SENSOR_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
-#define SENSOR_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)
-
-
-#define _CONS(a,b) a##b
-#define CONS(a,b) _CONS(a,b)
-
-#define __STR(x) #x
-#define _STR(x) __STR(x)
-#define STR(x) _STR(x)
-
-#define MIN(x,y)   ((x<y) ? x: y)
-#define MAX(x,y)    ((x>y) ? x: y)
-
-/* Sensor Driver Configuration */
-#define SENSOR_NAME RK29_CAM_SENSOR_OV2640
-#define SENSOR_V4L2_IDENT V4L2_IDENT_OV2640
-#define SENSOR_ID 0x2642
-#define SENSOR_ID1 0x2641
-#define SENSOR_MIN_WIDTH    640
-#define SENSOR_MIN_HEIGHT   480
-#define SENSOR_MAX_WIDTH    1600
-#define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  480
-#define SENSOR_INIT_WINSEQADR sensor_vga
-#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
-
-#define CONFIG_SENSOR_WhiteBalance	0
-#define CONFIG_SENSOR_Brightness	1
-#define CONFIG_SENSOR_Contrast      0
-#define CONFIG_SENSOR_Saturation    1
-#define CONFIG_SENSOR_Effect        1
-#define CONFIG_SENSOR_Scene         0
-#define CONFIG_SENSOR_DigitalZoom   0
-#define CONFIG_SENSOR_Focus         0
-#define CONFIG_SENSOR_Exposure      0
-#define CONFIG_SENSOR_Flash         0
-#define CONFIG_SENSOR_Mirror        0
-#define CONFIG_SENSOR_Flip          0
-
-#define CONFIG_SENSOR_I2C_SPEED     250000       /* Hz */
-/* Sensor write register continues by preempt_disable/preempt_enable for current process not be scheduled */
-#define CONFIG_SENSOR_I2C_NOSCHED   0
-#define CONFIG_SENSOR_I2C_RDWRCHK   0
-
-#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
-                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
-                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
-
-#define COLOR_TEMPERATURE_CLOUDY_DN  6500
-#define COLOR_TEMPERATURE_CLOUDY_UP    8000
-#define COLOR_TEMPERATURE_CLEARDAY_DN  5000
-#define COLOR_TEMPERATURE_CLEARDAY_UP    6500
-#define COLOR_TEMPERATURE_OFFICE_DN     3500
-#define COLOR_TEMPERATURE_OFFICE_UP     5000
-#define COLOR_TEMPERATURE_HOME_DN       2500
-#define COLOR_TEMPERATURE_HOME_UP       3500
-
-#define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
-#define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)
-
-struct reginfo
-{
-    u8 reg;
-    u8 val;
-};
-
-/* init 800*600 SVGA */
-static struct reginfo sensor_init_data[] =
-{
-#if 1
-    {0xff,0x01},
-    {0x12,0x80},
-    {0xff,0x00},
-    {0x2c,0xff},
-    {0x2e,0xdf},
-    {0xff,0x01},
-
-    {0x03,0x4f},
-    {0x0f,0x4b},
-
-
-    {0x3c,0x32},
-    {0x11,0x00},
-    {0x09,0x02},
-    {0x04,0xF8},//b7,b6 directs
-    {0x13,0xe5},
-    {0x14,0x48},
-    {0x2c,0x0c},
-    {0x33,0x78},
-    {0x3a,0x33},
-    {0x3b,0xfB},
-    {0x3e,0x00},
-    {0x43,0x11},
-    {0x16,0x10},
-    {0x39,0x02},
-    {0x35,0x88},
-    {0x22,0x09},
-    {0x37,0x40},
-    {0x23,0x00},
-    {0x34,0xa0},
-    {0x36,0x1a},
-    {0x06,0x02},
-    {0x07,0xc0},
-    {0x0d,0xb7},
-    {0x0e,0x01},
-    {0x4c,0x00},
-    {0x4a,0x81},
-    {0x21,0x99},
-    
-    //{0x24,0x58},
-    //{0x25,0x50},
-    //{0x26,0x92},
-    
-    {0x24, 0x70},
-    {0x25, 0x60},
-    {0x26, 0xa4},    
-    
-    {0x5c,0x00},
-    {0x63,0x00},
-    {0x46,0x3f},
-    {0x0c,0x3c},
-    {0x61,0x70},
-    {0x62,0x80},
-    {0x7c,0x05},
-    {0x20,0x80},
-    {0x28,0x30},
-    {0x6c,0x00},
-    {0x6d,0x80},
-    {0x6e,0x00},
-    {0x70,0x02},
-    {0x71,0x94},
-    {0x73,0xc1},
-    {0x3d,0x34},
-    {0x5a,0x57},
-    {0x4f,0xbb},
-    {0x50,0x9c},
-    {0xff,0x00},
-    {0xe5,0x7f},
-    {0xf9,0xc0},
-    {0x41,0x24},
-    {0xe0,0x14},
-    {0x76,0xff},
-    {0x33,0xa0},
-    {0x42,0x20},
-    {0x43,0x18},
-    {0x4c,0x00},
-    {0x87,0xd0},
-    {0x88,0x3f},
-    {0xd7,0x03},
-    {0xd9,0x10},
-    {0xd3,0x82},
-    {0xc8,0x08},
-    {0xc9,0x80},
-    {0x7c,0x00},
-    {0x7d,0x00},//0x00//0x07
-    {0x7c,0x03},
-    {0x7d,0x48},//0x48//0x40
-    {0x7d,0x48},//0x48//0x40
-    {0x7c,0x08},
-    {0x7d,0x20},
-    {0x7d,0x10},//0x10
-    {0x7d,0x0e},//0x0e
-
-    {0x92,0x00},
-    {0x93,0x06},
-    {0x93,0xc8},//e3
-    {0x93,0x05},
-    {0x93,0x05},
-    {0x93,0x00},
-    {0x93,0x04},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x96,0x00},
-    {0x97,0x08},
-    {0x97,0x19},
-    {0x97,0x02},
-    {0x97,0x0c},
-    {0x97,0x24},
-    {0x97,0x30},
-    {0x97,0x28},
-    {0x97,0x26},
-    {0x97,0x02},
-    {0x97,0x98},
-    {0x97,0x80},
-    {0x97,0x00},
-    {0x97,0x00},
-    {0xc3,0xef},//ed
-    {0xa4,0x00},
-    {0xa8,0x00},
-
-    {0xbf, 0x00},
-    {0xba, 0xdc},
-    {0xbb, 0x08},
-    {0xb6, 0x20},
-    {0xb8, 0x30},
-    {0xb7, 0x20},
-    {0xb9, 0x30},
-    {0xb3, 0xb4},
-    {0xb4, 0xca},
-    {0xb5, 0x34},
-    {0xb0, 0x46},
-    {0xb1, 0x46},
-    {0xb2, 0x06},
-    {0xc7, 0x00},
-    {0xc6, 0x51},
-    {0xc5, 0x11},
-    {0xc4, 0x9c},
-////
-    {0xc0,0xc8},
-    {0xc1,0x96},
-    {0x86,0x3d},
-    {0x50,0x92},
-    {0x51,0x90},
-    {0x52,0x2c},
-    {0x53,0x00},
-    {0x54,0x00},
-    {0x55,0x88},
-    {0x57,0x00},
-    {0x5a,0x50},
-    {0x5b,0x3c},
-    {0x5c,0x00},
-    {0xc3,0xed},
-    {0x7f,0x00},
-    {0xda,0x01},
-    {0xe5,0x1f},
-    {0xe1,0x67},
-    {0xe0,0x00},
-    {0xdd,0xff},
-    {0x05,0x00},
-
-#endif
-#if 1
-    {0xff, 0x01},
-    {0x5d, 0x00},
-    {0x5e, 0x3c},
-    {0x5f, 0x28},
-    {0x60, 0x55},
-
-
-    {0xff, 0x00},
-    {0xc3, 0xef},
-    {0xa6, 0x00},
-    {0xa7, 0x0f},
-    {0xa7, 0x4e},
-    {0xa7, 0x7a},
-    {0xa7, 0x33},
-    {0xa7, 0x00},
-    {0xa7, 0x23},
-    {0xa7, 0x27},
-    {0xa7, 0x3a},
-    {0xa7, 0x70},
-    {0xa7, 0x33},
-    {0xa7, 0x00},//L
-    {0xa7, 0x23},
-    {0xa7, 0x20},
-    {0xa7, 0x0c},
-    {0xa7, 0x66},
-    {0xa7, 0x33},
-    {0xa7, 0x00},
-    {0xa7, 0x23},
-    {0xc3, 0xef},
-#endif
-
-
-#if 1
-    {0xff,0x00},
-    {0x92,0x00},
-    {0x93,0x06},
-    {0x93,0xc1},//e
-    {0x93,0x02},
-    {0x93,0x02},
-    {0x93,0x00},
-    {0x93,0x04},
-#endif
-
-    {0x03, 0x0f},
-    {0xe0, 0x04},
-    {0xc0, 0xc8},
-    {0xc1, 0x96},
-    {0x86, 0x3d},
-    {0x50, 0x89},
-    {0x51, 0x90},
-    {0x52, 0x2c},
-    {0x53, 0x00},
-    {0x54, 0x00},
-    {0x55, 0x88},
-    {0x57, 0x00},
-    {0x5a, 0xa0},
-    {0x5b, 0x78},
-    {0x5c, 0x00},
-    {0xd3, 0x04},
-    {0xe0, 0x00},
-
-  {0x0, 0x0}   //end flag
-
-};
-
-/* 1600X1200 UXGA */
-static struct reginfo sensor_uxga[] =
-{
-    {0xff, 0x00},
-    {0xe0, 0x04},
-    {0xc0, 0xc8},
-    {0xc1, 0x96},
-    {0x86, 0x3d},
-    {0x50, 0x00},
-    {0x51, 0x90},
-    {0x52, 0x2c},
-    {0x53, 0x00},
-    {0x54, 0x00},
-    {0x55, 0x88},
-    {0x57, 0x00},
-    {0x5a, 0x90},
-    {0x5b, 0x2c},
-    {0x5c, 0x05},
-    {0xd3, 0x82},
-    {0xe0, 0x00},
-  {0x0, 0x0}   //end flag
-};
-
-/* 1280X1024 SXGA */
-static struct reginfo sensor_sxga[] =
-{
-    {0xff, 0x00},
-    {0xe0, 0x04},
-    {0xc0, 0xc8},
-    {0xc1, 0x96},
-    {0x86, 0x3d},
-    {0x50, 0x00},
-    {0x51, 0x90},
-    {0x52, 0x2c},
-    {0x53, 0x00},
-    {0x54, 0x00},
-    {0x55, 0x88},
-    {0x57, 0x00},
-    {0x5a, 0x40},
-    {0x5b, 0x00},
-    {0x5c, 0x05},
-    {0xd3, 0x82},
-    {0xe0, 0x00},
-  {0x0, 0x0}   //end flag
-};
-
-
-static struct reginfo sensor_xga[] =
-{
-    {0xff, 0x00},
-    {0xe0, 0x04},
-    {0xc0, 0xc8},
-    {0xc1, 0x96},
-    {0x86, 0x3d},
-    {0x50, 0x00},
-    {0x51, 0x90},
-    {0x52, 0x2c},
-    {0x53, 0x00},
-    {0x54, 0x00},
-    {0x55, 0x88},
-    {0x57, 0x00},
-    {0x5a, 0x40},
-    {0x5b, 0x00},
-    {0x5c, 0x05},
-    {0xd3, 0x82},
-    {0xe0, 0x00},
-  {0x0, 0x0}   //end flag
-
-
-};
-
-
-/* 800X600 SVGA*/
-static struct reginfo sensor_svga[] =
-{
-  {0x0, 0x0}   //end flag
-};
-
-/* 640X480 VGA */
-static struct reginfo sensor_vga[] =
-{
-   {0x0, 0x0}   //end flag
- };
-
-/* 352X288 CIF */
-static struct reginfo sensor_cif[] =
-{
-  {0x0, 0x0}   //end flag
-};
-
-/* 320*240 QVGA */
-static  struct reginfo sensor_qvga[] =
-{
-  {0x0, 0x0}   //end flag
-};
-
-/* 176X144 QCIF*/
-static struct reginfo sensor_qcif[] =
-{
-  {0x0, 0x0}   //end flag
-};
-#if 0
-/* 160X120 QQVGA*/
-static struct reginfo ov2655_qqvga[] =
-{
-
-    {0x300E, 0x34},
-    {0x3011, 0x01},
-    {0x3012, 0x10},
-    {0x302a, 0x02},
-    {0x302b, 0xE6},
-    {0x306f, 0x14},
-    {0x3362, 0x90},
-
-    {0x3070, 0x5d},
-    {0x3072, 0x5d},
-    {0x301c, 0x07},
-    {0x301d, 0x07},
-
-    {0x3020, 0x01},
-    {0x3021, 0x18},
-    {0x3022, 0x00},
-    {0x3023, 0x06},
-    {0x3024, 0x06},
-    {0x3025, 0x58},
-    {0x3026, 0x02},
-    {0x3027, 0x61},
-    {0x3088, 0x00},
-    {0x3089, 0xa0},
-    {0x308a, 0x00},
-    {0x308b, 0x78},
-    {0x3316, 0x64},
-    {0x3317, 0x25},
-    {0x3318, 0x80},
-    {0x3319, 0x08},
-    {0x331a, 0x0a},
-    {0x331b, 0x07},
-    {0x331c, 0x80},
-    {0x331d, 0x38},
-    {0x3100, 0x00},
-    {0x3302, 0x11},
-
-    {0x0, 0x0},
-};
-
-
-
-static  struct reginfo ov2655_Sharpness_auto[] =
-{
-    {0x3306, 0x00},
-};
-
-static  struct reginfo ov2655_Sharpness1[] =
-{
-    {0x3306, 0x08},
-    {0x3371, 0x00},
-};
-
-static  struct reginfo ov2655_Sharpness2[][3] =
-{
-    //Sharpness 2
-    {0x3306, 0x08},
-    {0x3371, 0x01},
-};
-
-static  struct reginfo ov2655_Sharpness3[] =
-{
-    //default
-    {0x3306, 0x08},
-    {0x332d, 0x02},
-};
-static  struct reginfo ov2655_Sharpness4[]=
-{
-    //Sharpness 4
-    {0x3306, 0x08},
-    {0x332d, 0x03},
-};
-
-static  struct reginfo ov2655_Sharpness5[] =
-{
-    //Sharpness 5
-    {0x3306, 0x08},
-    {0x332d, 0x04},
-};
-#endif
-
-static  struct reginfo sensor_ClrFmt_YUYV[]=
-{
-    //{0x4300, 0x30},
-    {0x00, 0x00}
-};
-
-static  struct reginfo sensor_ClrFmt_UYVY[]=
-{
-    //{0x4300, 0x32},
-    {0x00, 0x00}
-};
-
-#if CONFIG_SENSOR_WhiteBalance
-static  struct reginfo sensor_WhiteB_Auto[]=
-{
-    {0x3406, 0x00},  //AWB auto, bit[1]:0,auto
-    {0x0000, 0x00}
-};
-/* Cloudy Colour Temperature : 6500K - 8000K  */
-static  struct reginfo sensor_WhiteB_Cloudy[]=
-{
-    {0x3406, 0x01},
-    {0x3400, 0x07},
-    {0x3401, 0x08},
-    {0x3402, 0x04},
-    {0x3403, 0x00},
-    {0x3404, 0x05},
-    {0x3405, 0x00},
-    {0x0000, 0x00}
-};
-/* ClearDay Colour Temperature : 5000K - 6500K  */
-static  struct reginfo sensor_WhiteB_ClearDay[]=
-{
-    //Sunny
-    {0x3406, 0x01},
-    {0x3400, 0x07},
-    {0x3401, 0x02},
-    {0x3402, 0x04},
-    {0x3403, 0x00},
-    {0x3404, 0x05},
-    {0x3405, 0x15},
-    {0x0000, 0x00}
-};
-/* Office Colour Temperature : 3500K - 5000K  */
-static  struct reginfo sensor_WhiteB_TungstenLamp1[]=
-{
-    //Office
-    {0x3406, 0x01},
-    {0x3400, 0x06},
-    {0x3401, 0x2a},
-    {0x3402, 0x04},
-    {0x3403, 0x00},
-    {0x3404, 0x07},
-    {0x3405, 0x24},
-    {0x0000, 0x00}
-
-};
-/* Home Colour Temperature : 2500K - 3500K  */
-static  struct reginfo sensor_WhiteB_TungstenLamp2[]=
-{
-    //Home
-    {0x3406, 0x01},
-    {0x3400, 0x04},
-    {0x3401, 0x58},
-    {0x3402, 0x04},
-    {0x3403, 0x00},
-    {0x3404, 0x07},
-    {0x3405, 0x24},
-    {0x0000, 0x00}
-};
-static struct reginfo *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,
-    sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,
-};
-#endif
-
-#if CONFIG_SENSOR_Brightness
-static  struct reginfo sensor_Brightness0[]=
-{
-    // Brightness -2
-    {0xff, 0x01},
-    {0x24, 0x34},
-    {0x25, 0x22},
-    {0x26, 0x70},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness1[]=
-{
-    // Brightness -1
-
-    {0xff, 0x01},
-    {0x24, 0x58},
-    {0x25, 0x50},
-    {0x26, 0x92},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness2[]=
-{
-    //  Brightness 0
-
-	{0xff, 0x01},
-	{0x24, 0xa8},
-	{0x25, 0x90},
-	{0x26, 0xd6},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness3[]=
-{
-    // Brightness +1
-
-    {0xff, 0x01},
-    {0x24, 0x48},
-    {0x25, 0x40},
-    {0x26, 0x81},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness4[]=
-{
-    //  Brightness +2
-
-    {0xff, 0x01},
-    {0x24, 0x58},
-    {0x25, 0x50},
-    {0x26, 0x92},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness5[]=
-{
-    //  Brightness +3
-    {0xff, 0x01},
-    {0x24, 0x70},
-    {0x25, 0x60},
-    {0x26, 0xa4},
-  {0x0, 0x0}   //end flag
-};
-static struct reginfo *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,
-    sensor_Brightness4, sensor_Brightness5,NULL,
-};
-
-#endif
-
-#if CONFIG_SENSOR_Effect
-static  struct reginfo sensor_Effect_Normal[] =
-{
-	{0xff,0x00},
-	{0x7c,0x00},
-	{0x7d,0x00},
-	{0x7c,0x05},
-	{0x7d,0x80},
-	{0x7d,0x80},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_WandB[] =
-{
-    {0xff,0x00},
-    {0x7c,0x00},
-    {0x7d,0x18},
-    {0x7c,0x05},
-    {0x7d,0x80},
-    {0x7d,0x80},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_Sepia[] =
-{
-    {0xff,0x00},
-    {0x7c,0x00},
-    {0x7d,0x18},
-    {0x7c,0x05},
-    {0x7d,0x40},
-    {0x7d,0xc0},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_Negative[] =
-{
-    {0xff,0x00},
-    {0x7c,0x00},
-    {0x7d,0x40},
-    {0x7c,0x05},
-    {0x7d,0x80},
-    {0x7d,0x80},
-  {0x0, 0x0}   //end flag
-};
-static  struct reginfo sensor_Effect_Bluish[] =
-{
-    {0Xff, 0X00},
-    {0X7c, 0X00},
-    {0X7d, 0X18},
-    {0X7c, 0X05},
-    {0X7d, 0Xa0},
-    {0X7d, 0X40},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_Green[] =
-{
-    {0Xff, 0X00},
-    {0X7c, 0X00},
-    {0X7d, 0X18},
-    {0X7c, 0X05},
-    {0X7d, 0X40},
-    {0X7d, 0X40},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_Exp_Windows_Half[] =
-{
-	{0xff, 0x01},
-	{0x5d, 0x00},
-	{0x5e, 0x3c},
-	{0x5f, 0x28},
-	{0x60, 0x55},
-  {0x0, 0x0}   //end flag
-};
-static struct reginfo *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_WandB, sensor_Effect_Negative,sensor_Effect_Sepia,
-    sensor_Effect_Bluish, sensor_Effect_Green,NULL,
-};
-#endif
-#if CONFIG_SENSOR_Exposure
-static  struct reginfo sensor_Exposure0[]=
-{
-	{0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure1[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure2[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure3[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure4[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure5[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure6[]=
-{
-    {0x0000, 0x00}
-};
-
-static struct reginfo *sensor_ExposureSeqe[] = {sensor_Exposure0, sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,
-    sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,NULL,
-};
-#endif
-#if CONFIG_SENSOR_Saturation
-static  struct reginfo sensor_Saturation0[]=
-{
-	{0xff, 0x00},
-	{0x90, 0x00},
-	{0x91, 0x0e},
-	{0x91, 0x1a},
-	{0x91, 0x31},
-	{0x91, 0x5a},
-	{0x91, 0x69},
-	{0x91, 0x75},
-	{0x91, 0x7e},
-	{0x91, 0x88},
-	{0x91, 0x8f},
-	{0x91, 0x96},
-	{0x91, 0xa3},
-	{0x91, 0xaf},
-	{0x91, 0xc4},
-	{0x91, 0xd7},
-	{0x91, 0xe8},
-	{0x91, 0x20},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Saturation1[]=
-{
-    {0xff, 0x00},
-    {0x90, 0x00},
-    {0x91, 0x03},
-    {0x91, 0x0a},
-    {0x91, 0x1a},
-    {0x91, 0x3f},
-    {0x91, 0x4e},
-    {0x91, 0x5b},
-    {0x91, 0x68},
-    {0x91, 0x75},
-    {0x91, 0x7f},
-    {0x91, 0x89},
-    {0x91, 0x9a},
-    {0x91, 0xa6},
-    {0x91, 0xbd},
-    {0x91, 0xd3},
-    {0x91, 0xe5},
-    {0x91, 0x24},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Saturation2[]=
-{
-    {0xff, 0x00},
-    {0x90, 0x00},
-    {0x91, 0x04},
-    {0x91, 0x07},
-    {0x91, 0x10},
-    {0x91, 0x28},
-    {0x91, 0x36},
-    {0x91, 0x44},
-    {0x91, 0x52},
-    {0x91, 0x60},
-    {0x91, 0x6c},
-    {0x91, 0x78},
-    {0x91, 0x8c},
-    {0x91, 0x9e},
-    {0x91, 0xbb},
-    {0x91, 0xd3},
-    {0x91, 0xe5},
-    {0x91, 0x24},
-  {0x0, 0x0}   //end flag	
-};
-static struct reginfo *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};
-
-
-#endif
-#if CONFIG_SENSOR_Contrast
-static  struct reginfo sensor_Contrast0[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x10},
-    {0x7d, 0x4a},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-
-};
-
-static  struct reginfo sensor_Contrast1[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x14},
-    {0x7d, 0x40},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast2[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x18},
-    {0x7d, 0x34},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast3[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x1c},
-    {0x7d, 0x2a},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast4[]=
-{
-    {0xff,0x00},
-    {0x7c,0x00},
-    {0x7d,0x04},
-    {0x7c,0x07},
-    {0x7d,0x20},
-    {0x7d,0x24},
-    {0x7d,0x16},
-    {0x7d,0x06},
-  {0x0, 0x0}   //end flag
-};
-
-
-static  struct reginfo sensor_Contrast5[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x20},
-    {0x7d, 0x20},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast6[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x24},
-    {0x7d, 0x16},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-
-static  struct reginfo sensor_Contrast7[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x28},
-    {0x7d, 0x0c},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast8[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x2c},
-    {0x7d, 0x02},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast9[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x30},
-    {0x7d, 0x08},
-    {0x7d, 0x0e},
-  {0x0, 0x0}   //end flag
-};
-
-
-
-static struct reginfo *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,
-    sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,
-};
-
-#endif
-#if CONFIG_SENSOR_Mirror
-static  struct reginfo sensor_MirrorOn[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_MirrorOff[]=
-{
-    {0x0000, 0x00}
-};
-static struct reginfo *sensor_MirrorSeqe[] = {sensor_MirrorOff, sensor_MirrorOn,NULL,};
-#endif
-#if CONFIG_SENSOR_Flip
-static  struct reginfo sensor_FlipOn[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_FlipOff[]=
-{
-    {0x0000, 0x00}
-};
-static struct reginfo *sensor_FlipSeqe[] = {sensor_FlipOff, sensor_FlipOn,NULL,};
-
-#endif
-#if CONFIG_SENSOR_Scene
-static  struct reginfo sensor_SceneAuto[] =
-{
-    {0x3a00, 0x78},
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_SceneNight[] =
-{
-    {0x3003, 0x80},
-	{0x3004, 0x20},
-	{0x3005, 0x18},
-	{0x3006, 0x0d},
-	{0x3a00, 0x7c},
-	{0x3a02 ,0x07},
-	{0x3a03 ,0x38},
-	{0x3a14 ,0x07},
-	{0x3a15 ,0x38},
-    {0x0000, 0x00}
-};
-static struct reginfo *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight,NULL,};
-
-#endif
-#if CONFIG_SENSOR_DigitalZoom
-static struct reginfo sensor_Zoom0[] =
-{
-    {0x0, 0x0},
-};
-
-static struct reginfo sensor_Zoom1[] =
-{
-     {0x0, 0x0},
-};
-
-static struct reginfo sensor_Zoom2[] =
-{
-    {0x0, 0x0},
-};
-
-
-static struct reginfo sensor_Zoom3[] =
-{
-    {0x0, 0x0},
-};
-static struct reginfo *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL,};
-#endif
-static const struct v4l2_querymenu sensor_menus[] =
-{
-	#if CONFIG_SENSOR_WhiteBalance
-    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 0,  .name = "auto",  .reserved = 0, }, {  .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 1, .name = "incandescent",  .reserved = 0,},
-    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 2,  .name = "fluorescent", .reserved = 0,}, {  .id = V4L2_CID_DO_WHITE_BALANCE, .index = 3,  .name = "daylight", .reserved = 0,},
-    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 4,  .name = "cloudy-daylight", .reserved = 0,},
-    #endif
-
-	#if CONFIG_SENSOR_Effect
-    { .id = V4L2_CID_EFFECT,  .index = 0,  .name = "none",  .reserved = 0, }, {  .id = V4L2_CID_EFFECT,  .index = 1, .name = "mono",  .reserved = 0,},
-    { .id = V4L2_CID_EFFECT,  .index = 2,  .name = "negative", .reserved = 0,}, {  .id = V4L2_CID_EFFECT, .index = 3,  .name = "sepia", .reserved = 0,},
-    { .id = V4L2_CID_EFFECT,  .index = 4, .name = "posterize", .reserved = 0,} ,{ .id = V4L2_CID_EFFECT,  .index = 5,  .name = "aqua", .reserved = 0,},
-    #endif
-
-	#if CONFIG_SENSOR_Scene
-    { .id = V4L2_CID_SCENE,  .index = 0, .name = "auto", .reserved = 0,} ,{ .id = V4L2_CID_SCENE,  .index = 1,  .name = "night", .reserved = 0,},
-    #endif
-
-	#if CONFIG_SENSOR_Flash
-    { .id = V4L2_CID_FLASH,  .index = 0,  .name = "off",  .reserved = 0, }, {  .id = V4L2_CID_FLASH,  .index = 1, .name = "auto",  .reserved = 0,},
-    { .id = V4L2_CID_FLASH,  .index = 2,  .name = "on", .reserved = 0,}, {  .id = V4L2_CID_FLASH, .index = 3,  .name = "torch", .reserved = 0,},
-    #endif
-};
-
-static const struct v4l2_queryctrl sensor_controls[] =
-{
-	#if CONFIG_SENSOR_WhiteBalance
-    {
-        .id		= V4L2_CID_DO_WHITE_BALANCE,
-        .type		= V4L2_CTRL_TYPE_MENU,
-        .name		= "White Balance Control",
-        .minimum	= 0,
-        .maximum	= 4,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Brightness
-	{
-        .id		= V4L2_CID_BRIGHTNESS,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Brightness Control",
-        .minimum	= -3,
-        .maximum	= 2,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Effect
-	{
-        .id		= V4L2_CID_EFFECT,
-        .type		= V4L2_CTRL_TYPE_MENU,
-        .name		= "Effect Control",
-        .minimum	= 0,
-        .maximum	= 5,
-        .step		= 1,
-        .default_value = 0,
-    },
-	#endif
-
-	#if CONFIG_SENSOR_Exposure
-	{
-        .id		= V4L2_CID_EXPOSURE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Exposure Control",
-        .minimum	= 0,
-        .maximum	= 6,
-        .step		= 1,
-        .default_value = 0,
-    },
-	#endif
-
-	#if CONFIG_SENSOR_Saturation
-	{
-        .id		= V4L2_CID_SATURATION,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Saturation Control",
-        .minimum	= 0,
-        .maximum	= 2,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Contrast
-	{
-        .id		= V4L2_CID_CONTRAST,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Contrast Control",
-        .minimum	= -3,
-        .maximum	= 3,
-        .step		= 1,
-        .default_value = 0,
-    },
-	#endif
-
-	#if CONFIG_SENSOR_Mirror
-	{
-        .id		= V4L2_CID_HFLIP,
-        .type		= V4L2_CTRL_TYPE_BOOLEAN,
-        .name		= "Mirror Control",
-        .minimum	= 0,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 1,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Flip
-	{
-        .id		= V4L2_CID_VFLIP,
-        .type		= V4L2_CTRL_TYPE_BOOLEAN,
-        .name		= "Flip Control",
-        .minimum	= 0,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 1,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Scene
-    {
-        .id		= V4L2_CID_SCENE,
-        .type		= V4L2_CTRL_TYPE_MENU,
-        .name		= "Scene Control",
-        .minimum	= 0,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_DigitalZoom
-    {
-        .id		= V4L2_CID_ZOOM_RELATIVE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "DigitalZoom Control",
-        .minimum	= -1,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 0,
-    }, {
-        .id		= V4L2_CID_ZOOM_ABSOLUTE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "DigitalZoom Control",
-        .minimum	= 0,
-        .maximum	= 3,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Focus
-	{
-        .id		= V4L2_CID_FOCUS_RELATIVE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Focus Control",
-        .minimum	= -1,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 0,
-    }, {
-        .id		= V4L2_CID_FOCUS_ABSOLUTE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Focus Control",
-        .minimum	= 0,
-        .maximum	= 255,
-        .step		= 1,
-        .default_value = 125,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Flash
-	{
-        .id		= V4L2_CID_FLASH,
-        .type		= V4L2_CTRL_TYPE_MENU,
-        .name		= "Flash Control",
-        .minimum	= 0,
-        .maximum	= 3,
-        .step		= 1,
-        .default_value = 0,
-    },
-	#endif
-};
-
-static int sensor_probe(struct i2c_client *client, const struct i2c_device_id *did);
-static int sensor_video_probe(struct soc_camera_device *icd, struct i2c_client *client);
-static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
-static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
-static int sensor_g_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
-static int sensor_s_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
-static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);
-static int sensor_resume(struct soc_camera_device *icd);
-static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);
-static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);
-#if CONFIG_SENSOR_Effect
-static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
-#endif
-#if CONFIG_SENSOR_WhiteBalance
-static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
-#endif
-static int sensor_deactivate(struct i2c_client *client);
-
-static struct soc_camera_ops sensor_ops =
-{
-    .suspend                     = sensor_suspend,
-    .resume                       = sensor_resume,
-    .set_bus_param		= sensor_set_bus_param,
-    .query_bus_param	= sensor_query_bus_param,
-    .controls		= sensor_controls,
-    .menus                         = sensor_menus,
-    .num_controls		= ARRAY_SIZE(sensor_controls),
-    .num_menus		= ARRAY_SIZE(sensor_menus),
-};
-
-/* only one fixed colorspace per pixelcode */
-struct sensor_datafmt {
-	enum v4l2_mbus_pixelcode code;
-	enum v4l2_colorspace colorspace;
-};
-
-/* Find a data format by a pixel code in an array */
-static const struct sensor_datafmt *sensor_find_datafmt(
-	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
-	int n)
-{
-	int i;
-	for (i = 0; i < n; i++)
-		if (fmt[i].code == code)
-			return fmt + i;
-
-	return NULL;
-}
-
-static const struct sensor_datafmt sensor_colour_fmts[] = {
-    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
-    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
-};
-
-typedef struct sensor_info_priv_s
-{
-    int whiteBalance;
-    int brightness;
-    int contrast;
-    int saturation;
-    int effect;
-    int scene;
-    int digitalzoom;
-    int focus;
-    int flash;
-    int exposure;
-	bool snap2preview;
-	bool video2preview;
-    unsigned char mirror;                                        /* HFLIP */
-    unsigned char flip;                                          /* VFLIP */
-    unsigned int winseqe_cur_addr;
-    struct sensor_datafmt fmt;
-
-} sensor_info_priv_t;
-
-struct sensor
-{
-    struct v4l2_subdev subdev;
-    struct i2c_client *client;
-    sensor_info_priv_t info_priv;
-    int model;	/* V4L2_IDENT_OV* codes from v4l2-chip-ident.h */
-#if CONFIG_SENSOR_I2C_NOSCHED
-	atomic_t tasklock_cnt;
-#endif
-	struct rk29camera_platform_data *sensor_io_request;
-    struct rk29camera_gpio_res *sensor_gpio_res;
-};
-
-static struct sensor* to_sensor(const struct i2c_client *client)
-{
-    return container_of(i2c_get_clientdata(client), struct sensor, subdev);
-}
-
-static int sensor_task_lock(struct i2c_client *client, int lock)
-{
-#if CONFIG_SENSOR_I2C_NOSCHED
-	int cnt = 3;
-    struct sensor *sensor = to_sensor(client);
-
-	if (lock) {
-		if (atomic_read(&sensor->tasklock_cnt) == 0) {
-			while ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt>0)) {
-				SENSOR_TR("\n %s will obtain i2c in atomic, but i2c bus is locked! Wait...\n",SENSOR_NAME_STRING());
-				msleep(35);
-				cnt--;
-			}
-			if ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt<=0)) {
-				SENSOR_TR("\n %s obtain i2c fail in atomic!!\n",SENSOR_NAME_STRING());
-				goto sensor_task_lock_err;
-			}
-			preempt_disable();
-		}
-
-		atomic_add(1, &sensor->tasklock_cnt);
-	} else {
-		if (atomic_read(&sensor->tasklock_cnt) > 0) {
-			atomic_sub(1, &sensor->tasklock_cnt);
-
-			if (atomic_read(&sensor->tasklock_cnt) == 0)
-				preempt_enable();
-		}
-	}
-	return 0;
-sensor_task_lock_err:
-	return -1;  
-#else
-    return 0;
-#endif
-
-}
-static int sensor_write(struct i2c_client *client, u8 reg, u8 val)
-{
-    int err,cnt;
-    u8 buf[2];
-    struct i2c_msg msg[1];
-
-    buf[0] = reg & 0xFF;
-    buf[1] = val;
-
-    msg->addr = client->addr;
-    msg->flags = client->flags;
-    msg->buf = buf;
-    msg->len = sizeof(buf);
-    msg->scl_rate = CONFIG_SENSOR_I2C_SPEED;                                        /* ddl@rock-chips.com : 100kHz */
-    msg->read_type = 0;               /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */
-
-    cnt = 3;
-    err = -EAGAIN;
-
-    while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
-        err = i2c_transfer(client->adapter, msg, 1);
-
-        if (err >= 0) {
-            return 0;
-        } else {
-            SENSOR_TR("\n %s write reg(0x%x, val:0x%x) failed, try to write again!\n",SENSOR_NAME_STRING(),reg, val);
-            udelay(10);
-        }
-    }
-
-    return err;
-}
-
-/* sensor register read */
-static int sensor_read(struct i2c_client *client, u8 reg, u8 *val)
-{
-    int err,cnt;
-    u8 buf[1];
-    struct i2c_msg msg[2];
-
-    buf[0] = reg ;//>> 8;
-   // buf[1] = 0;
-
-    msg[0].addr = client->addr;
-    msg[0].flags = client->flags;
-    msg[0].buf = buf;
-    msg[0].len = sizeof(buf);
-    msg[0].scl_rate = CONFIG_SENSOR_I2C_SPEED;       /* ddl@rock-chips.com : 100kHz */
-    msg[0].read_type = 2;//0x55;   /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
-
-    msg[1].addr = client->addr;
-    msg[1].flags = client->flags|I2C_M_RD;
-    msg[1].buf = buf;
-    msg[1].len = 1;
-    msg[1].scl_rate = CONFIG_SENSOR_I2C_SPEED;                       /* ddl@rock-chips.com : 100kHz */
-    msg[1].read_type = 2;                             /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
-
-    cnt = 3;
-    err = -EAGAIN;
-    while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
-        err = i2c_transfer(client->adapter, msg, 2);
-
-        if (err >= 0) {
-            *val = buf[0];
-            return 0;
-        } else {
-        	SENSOR_TR("\n %s read reg(0x%x val:0x%x) failed, try to read again! \n",SENSOR_NAME_STRING(),reg, *val);
-            udelay(10);
-        }
-    }
-
-    return err;
-}
-
-/* write a array of registers  */
-static int sensor_write_array(struct i2c_client *client, struct reginfo *regarray)
-{
-    int err = 0, cnt;
-    int i = 0;
-#if CONFIG_SENSOR_I2C_RDWRCHK    
-	char valchk;
-#endif
-
-	cnt = 0;
-	if (sensor_task_lock(client, 1) < 0)
-		goto sensor_write_array_end;
-    while (regarray[i].reg != 0)
-    {
-        err = sensor_write(client, regarray[i].reg, regarray[i].val);
-        if (err < 0)
-        {
-            if (cnt-- > 0) {
-			    SENSOR_TR("%s..write failed current reg:0x%x, Write array again !\n", SENSOR_NAME_STRING(),regarray[i].reg);
-				i = 0;
-				continue;
-            } else {
-                SENSOR_TR("%s..write array failed!!!\n", SENSOR_NAME_STRING());
-                err = -EPERM;
-				goto sensor_write_array_end;
-            }
-        } else {
-        #if CONFIG_SENSOR_I2C_RDWRCHK
-			sensor_read(client, regarray[i].reg, &valchk);
-			if (valchk != regarray[i].val)
-				SENSOR_TR("%s Reg:0x%x write(0x%x, 0x%x) fail\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
-		#endif
-        }
-        i++;
-    }
-
-sensor_write_array_end:
-	sensor_task_lock(client,0);
-	return err;
-}
-#if CONFIG_SENSOR_I2C_RDWRCHK
-static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regarray)
-{
-    int cnt;
-    int i = 0;
-	char valchk;
-
-	cnt = 0;
-	valchk = 0;
-    while (regarray[i].reg != 0)
-    {
-		sensor_read(client, regarray[i].reg, &valchk);
-		if (valchk != regarray[i].val)
-			SENSOR_TR("%s Reg:0x%x read(0x%x, 0x%x) error\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
-
-        i++;
-    }
-    return 0;
-}
-#endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
-{
-	struct soc_camera_link *icl = to_soc_camera_link(icd);
-	int ret = 0;
-
-    SENSOR_DG("%s %s  cmd(%d) on(%d)\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd,on);
-
-	switch (cmd)
-	{
-		case Sensor_PowerDown:
-		{
-			if (icl->powerdown) {
-				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK29_CAM_IO_SUCCESS) {
-					if (on == 0) {
-						mdelay(2);
-						if (icl->reset)
-							icl->reset(icd->pdev);
-					}
-				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
-					ret = -ENODEV;
-					goto sensor_power_end;
-				}
-			}
-			break;
-		}
-		case Sensor_Flash:
-		{
-			struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    		struct sensor *sensor = to_sensor(client);
-
-			if (sensor->sensor_io_request && sensor->sensor_io_request->sensor_ioctrl) {
-				sensor->sensor_io_request->sensor_ioctrl(icd->pdev,Cam_Flash, on);
-			}
-            break;
-		}
-		default:
-		{
-			SENSOR_TR("%s %s cmd(0x%x) is unknown!",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
-			break;
-		}
-	}
-sensor_power_end:
-	return ret;
-}
-static int sensor_init(struct v4l2_subdev *sd, u32 val)
-{
-    struct i2c_client *client = sd->priv;
-    struct soc_camera_device *icd = client->dev.platform_data;
-    struct sensor *sensor = to_sensor(client);
-	const struct v4l2_queryctrl *qctrl;
-    const struct sensor_datafmt *fmt;
-    char value;
-    int ret,pid = 0;
-
-    SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
-
-	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
-		ret = -ENODEV;
-		goto sensor_INIT_ERR;
-	}
-
-    /* soft reset */
-	if (sensor_task_lock(client,1)<0)
-		goto sensor_INIT_ERR;
-    ret = sensor_write(client, 0xff, 1);
-    ret |= sensor_write(client, 0x12, 0x80);
-    if (ret != 0)
-    {
-        SENSOR_TR("%s soft reset sensor failed\n",SENSOR_NAME_STRING());
-        ret = -ENODEV;
-		goto sensor_INIT_ERR;
-    }
-
-    mdelay(5);  //delay 5 microseconds
-	/* check if it is an sensor sensor */
-    ret = sensor_write(client, 0xff, 1);
-    ret |= sensor_read(client, 0x0a, &value);
-    if (ret != 0) {
-        SENSOR_TR("read chip id high byte failed\n");
-        ret = -ENODEV;
-        goto sensor_INIT_ERR;
-    }
-
-    pid = value << 8;
-    ret = sensor_read(client, 0x0b, &value);
-    if (ret != 0) {
-        SENSOR_TR("read chip id low byte failed\n");
-        ret = -ENODEV;
-        goto sensor_INIT_ERR;
-    }
-
-    pid |= (value & 0xff);
-
-    SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
-    if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
-        sensor->model = SENSOR_V4L2_IDENT;
-    } else {
-        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
-        ret = -ENODEV;
-        goto sensor_INIT_ERR;
-    }
-
-    ret = sensor_write_array(client, sensor_init_data);
-    if (ret != 0)
-    {
-        SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
-        goto sensor_INIT_ERR;
-    }
-	sensor_task_lock(client,0);
-    sensor->info_priv.winseqe_cur_addr  = (int)SENSOR_INIT_WINSEQADR;
-    fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
-    if (!fmt) {
-        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
-        ret = -EINVAL;
-        goto sensor_INIT_ERR;
-    }
-	sensor->info_priv.fmt = *fmt;
-
-    /* sensor sensor information for initialization  */
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
-	if (qctrl)
-    	sensor->info_priv.whiteBalance = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_BRIGHTNESS);
-	if (qctrl)
-    	sensor->info_priv.brightness = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
-	if (qctrl)
-    	sensor->info_priv.effect = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EXPOSURE);
-	if (qctrl)
-        sensor->info_priv.exposure = qctrl->default_value;
-
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SATURATION);
-	if (qctrl)
-        sensor->info_priv.saturation = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_CONTRAST);
-	if (qctrl)
-        sensor->info_priv.contrast = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_HFLIP);
-	if (qctrl)
-        sensor->info_priv.mirror = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_VFLIP);
-	if (qctrl)
-        sensor->info_priv.flip = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SCENE);
-	if (qctrl)
-        sensor->info_priv.scene = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
-	if (qctrl)
-        sensor->info_priv.digitalzoom = qctrl->default_value;
-
-    /* ddl@rock-chips.com : if sensor support auto focus and flash, programer must run focus and flash code  */
-	#if CONFIG_SENSOR_Focus
-    sensor_set_focus();
-    qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FOCUS_ABSOLUTE);
-	if (qctrl)
-        sensor->info_priv.focus = qctrl->default_value;
-	#endif
-
-	#if CONFIG_SENSOR_Flash
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FLASH);
-	if (qctrl)
-        sensor->info_priv.flash = qctrl->default_value;
-    #endif
-
-    SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),((val == 0)?__FUNCTION__:"sensor_reinit"),icd->user_width,icd->user_height);
-
-    return 0;
-sensor_INIT_ERR:
-	sensor_task_lock(client,0);
-	sensor_deactivate(client);
-    return ret;
-}
-
-static int sensor_deactivate(struct i2c_client *client)
-{
-	struct soc_camera_device *icd = client->dev.platform_data;
-
-	SENSOR_DG("\n%s..%s.. Enter\n",SENSOR_NAME_STRING(),__FUNCTION__);
-
-	/* ddl@rock-chips.com : all sensor output pin must change to input for other sensor */
-#if 0	
-	sensor_task_lock(client, 1);
-    sensor_write(client, 0x3000, reg_val&0xfc);
-	sensor_write(client, 0x3001, 0x00);
-	sensor_task_lock(client, 0);
-#endif
-	sensor_ioctrl(icd, Sensor_PowerDown, 1);
-	/* ddl@rock-chips.com : sensor config init width , because next open sensor quickly(soc_camera_open -> Try to configure with default parameters) */
-	icd->user_width = SENSOR_INIT_WIDTH;
-    icd->user_height = SENSOR_INIT_HEIGHT;
-	msleep(100);
-	return 0;
-}
-
-static  struct reginfo sensor_power_down_sequence[]=
-{
-    {0x00,0x00}
-};
-static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)
-{
-    int ret;
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if (pm_msg.event == PM_EVENT_SUSPEND) {
-        SENSOR_DG("\n %s Enter Suspend.. \n", SENSOR_NAME_STRING());
-        ret = sensor_write_array(client, sensor_power_down_sequence) ;
-        if (ret != 0) {
-            SENSOR_TR("\n %s..%s WriteReg Fail.. \n", SENSOR_NAME_STRING(),__FUNCTION__);
-            return ret;
-        } else {
-            ret = sensor_ioctrl(icd, Sensor_PowerDown, 1);
-            if (ret < 0) {
-			    SENSOR_TR("\n %s suspend fail for turn on power!\n", SENSOR_NAME_STRING());
-                return -EINVAL;
-            }
-        }
-    } else {
-        SENSOR_TR("\n %s cann't suppout Suspend..\n",SENSOR_NAME_STRING());
-        return -EINVAL;
-    }
-    return 0;
-}
-
-static int sensor_resume(struct soc_camera_device *icd)
-{
-	int ret;
-
-    ret = sensor_ioctrl(icd, Sensor_PowerDown, 0);
-    if (ret < 0) {
-		SENSOR_TR("\n %s resume fail for turn on power!\n", SENSOR_NAME_STRING());
-        return -EINVAL;
-    }
-
-	SENSOR_DG("\n %s Enter Resume.. \n", SENSOR_NAME_STRING());
-
-    return 0;
-
-}
-
-static int sensor_set_bus_param(struct soc_camera_device *icd,
-                                unsigned long flags)
-{
-
-    return 0;
-}
-
-static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
-{
-    struct soc_camera_link *icl = to_soc_camera_link(icd);
-    unsigned long flags = SENSOR_BUS_PARAM;
-
-    return soc_camera_apply_sensor_flags(icl, flags);
-}
-
-static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    struct i2c_client *client = sd->priv;
-    struct soc_camera_device *icd = client->dev.platform_data;
-    struct sensor *sensor = to_sensor(client);
-
-    mf->width	= icd->user_width;
-	mf->height	= icd->user_height;
-	mf->code	= sensor->info_priv.fmt.code;
-	mf->colorspace	= sensor->info_priv.fmt.colorspace;
-	mf->field	= V4L2_FIELD_NONE;
-
-    return 0;
-}
-static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    bool ret = false;
-
-	if ((mf->width == 1024) && (mf->height == 768)) {
-		ret = true;
-	} else if ((mf->width == 1280) && (mf->height == 1024)) {
-		ret = true;
-	} else if ((mf->width == 1600) && (mf->height == 1200)) {
-		ret = true;
-	} else if ((mf->width == 2048) && (mf->height == 1536)) {
-		ret = true;
-	} else if ((mf->width == 2592) && (mf->height == 1944)) {
-		ret = true;
-	}
-
-	if (ret == true)
-		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
-	return ret;
-}
-
-static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    bool ret = false;
-
-	if ((mf->width == 1280) && (mf->height == 720)) {
-		ret = true;
-	} else if ((mf->width == 1920) && (mf->height == 1080)) {
-		ret = true;
-	}
-
-	if (ret == true)
-		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
-	return ret;
-}
-static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    struct i2c_client *client = sd->priv;
-    struct sensor *sensor = to_sensor(client);
-    const struct sensor_datafmt *fmt;
-	const struct v4l2_queryctrl *qctrl;
-	struct soc_camera_device *icd = client->dev.platform_data;
-    struct reginfo *winseqe_set_addr=NULL;
-    int ret=0, set_w,set_h;
-
-	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
-				   ARRAY_SIZE(sensor_colour_fmts));
-	if (!fmt) {
-        ret = -EINVAL;
-        goto sensor_s_fmt_end;
-    }
-
-	if (sensor->info_priv.fmt.code != mf->code) {
-		switch (mf->code)
-		{
-			case V4L2_MBUS_FMT_YUYV8_2X8:
-			{
-				winseqe_set_addr = sensor_ClrFmt_YUYV;
-				break;
-			}
-			case V4L2_MBUS_FMT_UYVY8_2X8:
-			{
-				winseqe_set_addr = sensor_ClrFmt_UYVY;
-				break;
-			}
-			default:
-				break;
-		}
-		if (winseqe_set_addr != NULL) {
-            sensor_write_array(client, winseqe_set_addr);
-			sensor->info_priv.fmt.code = mf->code;
-            sensor->info_priv.fmt.colorspace= mf->colorspace;            
-			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
-		} else {
-			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
-		}
-	}
-
-    set_w = mf->width;
-    set_h = mf->height;
-
-	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
-	{
-		winseqe_set_addr = sensor_qcif;
-        set_w = 176;
-        set_h = 144;
-	}
-	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
-    {
-        winseqe_set_addr = sensor_qvga;
-        set_w = 320;
-        set_h = 240;
-    }
-    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
-    {
-        winseqe_set_addr = sensor_cif;
-        set_w = 352;
-        set_h = 288;
-    }
-    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
-    {
-        winseqe_set_addr = sensor_vga;
-        set_w = 640;
-        set_h = 480;
-    }
-    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
-    {
-        winseqe_set_addr = sensor_svga;
-        set_w = 800;
-        set_h = 600;
-    }
-	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
-    {
-        winseqe_set_addr = sensor_xga;
-        set_w = 1024;
-        set_h = 768;
-    }
-    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
-    {
-        winseqe_set_addr = sensor_sxga;
-        set_w = 1280;
-        set_h = 1024;
-    }
-    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
-    {
-        winseqe_set_addr = sensor_uxga;
-        set_w = 1600;
-        set_h = 1200;
-    }
-    else
-    {
-        winseqe_set_addr = SENSOR_INIT_WINSEQADR;               /* ddl@rock-chips.com : Sensor output smallest size if  isn't support app  */
-        set_w = SENSOR_INIT_WIDTH;
-        set_h = SENSOR_INIT_HEIGHT;
-		SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,mf->width,mf->height);
-    }
-
-    if ((int)winseqe_set_addr  != sensor->info_priv.winseqe_cur_addr) {
-        #if CONFIG_SENSOR_Flash
-        if (sensor_fmt_capturechk(sd,mf) == true) {      /* ddl@rock-chips.com : Capture */
-            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
-                sensor_ioctrl(icd, Sensor_Flash, Flash_On);
-                SENSOR_DG("%s flash on in capture!\n", SENSOR_NAME_STRING());
-            }           
-        } else {                                        /* ddl@rock-chips.com : Video */
-            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
-                sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
-                SENSOR_DG("%s flash off in preivew!\n", SENSOR_NAME_STRING());
-            }
-        }
-        #endif        
-        ret |= sensor_write_array(client, winseqe_set_addr);
-        if (ret != 0) {
-            SENSOR_TR("%s set format capability failed\n", SENSOR_NAME_STRING());
-            #if CONFIG_SENSOR_Flash
-            if (sensor_fmt_capturechk(sd,mf) == true) {
-                if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
-                    sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
-                    SENSOR_TR("%s Capture format set fail, flash off !\n", SENSOR_NAME_STRING());
-                }
-            }
-            #endif
-            goto sensor_s_fmt_end;
-        }
-
-        sensor->info_priv.winseqe_cur_addr  = (int)winseqe_set_addr;
-
-		if (sensor_fmt_capturechk(sd,mf) == true) {				    /* ddl@rock-chips.com : Capture */
-        #if CONFIG_SENSOR_Effect
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
-			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
-        #endif
-        #if CONFIG_SENSOR_WhiteBalance
-			if (sensor->info_priv.whiteBalance != 0) {
-				qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
-				sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
-			}
-        #endif
-			sensor->info_priv.snap2preview = true;
-		} else if (sensor_fmt_videochk(sd,mf) == true) {			/* ddl@rock-chips.com : Video */
-		#if CONFIG_SENSOR_Effect
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
-			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
-        #endif
-        #if CONFIG_SENSOR_WhiteBalance
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
-			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
-        #endif
-			sensor->info_priv.video2preview = true;
-		} else if ((sensor->info_priv.snap2preview == true) || (sensor->info_priv.video2preview == true)) {
-		#if CONFIG_SENSOR_Effect
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
-			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
-        #endif
-        #if CONFIG_SENSOR_WhiteBalance    
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
-			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
-        #endif    
-			sensor->info_priv.video2preview = false;            
-			sensor->info_priv.snap2preview = false;
-		}
-        SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),__FUNCTION__,set_w,set_h);
-    }
-    else
-    {
-        SENSOR_DG("\n %s .. Current Format is validate. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),set_w,set_h);
-    }
-
-	mf->width = set_w;
-    mf->height = set_h;
-
-sensor_s_fmt_end:
-    return ret;
-}
-
-static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    struct i2c_client *client = sd->priv;
-    struct sensor *sensor = to_sensor(client);
-    const struct sensor_datafmt *fmt;
-    int ret = 0;
-   
-	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
-				   ARRAY_SIZE(sensor_colour_fmts));
-	if (fmt == NULL) {
-		fmt = &sensor->info_priv.fmt;
-        mf->code = fmt->code;
-	} 
-
-    if (mf->height > SENSOR_MAX_HEIGHT)
-        mf->height = SENSOR_MAX_HEIGHT;
-    else if (mf->height < SENSOR_MIN_HEIGHT)
-        mf->height = SENSOR_MIN_HEIGHT;
-
-    if (mf->width > SENSOR_MAX_WIDTH)
-        mf->width = SENSOR_MAX_WIDTH;
-    else if (mf->width < SENSOR_MIN_WIDTH)
-        mf->width = SENSOR_MIN_WIDTH;
-
-    mf->colorspace = fmt->colorspace;
-    
-    return ret;
-}
- static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
-{
-    struct i2c_client *client = sd->priv;
-
-    if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
-        return -EINVAL;
-
-    if (id->match.addr != client->addr)
-        return -ENODEV;
-
-    id->ident = SENSOR_V4L2_IDENT;      /* ddl@rock-chips.com :  Return OV2655  identifier */
-    id->revision = 0;
-
-    return 0;
-}
-#if CONFIG_SENSOR_Brightness
-static int sensor_set_brightness(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_BrightnessSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_BrightnessSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Effect
-static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_EffectSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_EffectSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Exposure
-static int sensor_set_exposure(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_ExposureSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_ExposureSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Saturation
-static int sensor_set_saturation(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_SaturationSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_SaturationSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Contrast
-static int sensor_set_contrast(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_ContrastSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_ContrastSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Mirror
-static int sensor_set_mirror(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_MirrorSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_MirrorSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Flip
-static int sensor_set_flip(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_FlipSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_FlipSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Scene
-static int sensor_set_scene(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_SceneSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_SceneSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_WhiteBalance
-static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_WhiteBalanceSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_WhiteBalanceSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_DigitalZoom
-static int sensor_set_digitalzoom(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int *value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    struct sensor *sensor = to_sensor(client);
-	const struct v4l2_queryctrl *qctrl_info;
-    int digitalzoom_cur, digitalzoom_total;
-
-	qctrl_info = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
-	if (qctrl_info)
-		return -EINVAL;
-
-    digitalzoom_cur = sensor->info_priv.digitalzoom;
-    digitalzoom_total = qctrl_info->maximum;
-
-    if ((*value > 0) && (digitalzoom_cur >= digitalzoom_total))
-    {
-        SENSOR_TR("%s digitalzoom is maximum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
-        return -EINVAL;
-    }
-
-    if  ((*value < 0) && (digitalzoom_cur <= qctrl_info->minimum))
-    {
-        SENSOR_TR("%s digitalzoom is minimum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
-        return -EINVAL;
-    }
-
-    if ((*value > 0) && ((digitalzoom_cur + *value) > digitalzoom_total))
-    {
-        *value = digitalzoom_total - digitalzoom_cur;
-    }
-
-    if ((*value < 0) && ((digitalzoom_cur + *value) < 0))
-    {
-        *value = 0 - digitalzoom_cur;
-    }
-
-    digitalzoom_cur += *value;
-
-    if (sensor_ZoomSeqe[digitalzoom_cur] != NULL)
-    {
-        if (sensor_write_array(client, sensor_ZoomSeqe[digitalzoom_cur]) != 0)
-        {
-            SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-            return -EINVAL;
-        }
-        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, *value);
-        return 0;
-    }
-
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Flash
-static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{    
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum)) {
-        if (value == 3) {       /* ddl@rock-chips.com: torch */
-            sensor_ioctrl(icd, Sensor_Flash, Flash_Torch);   /* Flash On */
-        } else {
-            sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
-        }
-        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-        return 0;
-    }
-    
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-
-static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-    struct i2c_client *client = sd->priv;
-    struct sensor *sensor = to_sensor(client);
-    const struct v4l2_queryctrl *qctrl;
-
-    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
-
-    if (!qctrl)
-    {
-        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
-        return -EINVAL;
-    }
-
-    switch (ctrl->id)
-    {
-        case V4L2_CID_BRIGHTNESS:
-            {
-                ctrl->value = sensor->info_priv.brightness;
-                break;
-            }
-        case V4L2_CID_SATURATION:
-            {
-                ctrl->value = sensor->info_priv.saturation;
-                break;
-            }
-        case V4L2_CID_CONTRAST:
-            {
-                ctrl->value = sensor->info_priv.contrast;
-                break;
-            }
-        case V4L2_CID_DO_WHITE_BALANCE:
-            {
-                ctrl->value = sensor->info_priv.whiteBalance;
-                break;
-            }
-        case V4L2_CID_EXPOSURE:
-            {
-                ctrl->value = sensor->info_priv.exposure;
-                break;
-            }
-        case V4L2_CID_HFLIP:
-            {
-                ctrl->value = sensor->info_priv.mirror;
-                break;
-            }
-        case V4L2_CID_VFLIP:
-            {
-                ctrl->value = sensor->info_priv.flip;
-                break;
-            }
-        default :
-                break;
-    }
-    return 0;
-}
-
-
-
-static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-    struct i2c_client *client = sd->priv;
-    struct sensor *sensor = to_sensor(client);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    const struct v4l2_queryctrl *qctrl;
-
-
-    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
-
-    if (!qctrl)
-    {
-        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
-        return -EINVAL;
-    }
-
-    switch (ctrl->id)
-    {
-#if CONFIG_SENSOR_Brightness
-        case V4L2_CID_BRIGHTNESS:
-            {
-                if (ctrl->value != sensor->info_priv.brightness)
-                {
-                    if (sensor_set_brightness(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.brightness = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Exposure
-        case V4L2_CID_EXPOSURE:
-            {
-                if (ctrl->value != sensor->info_priv.exposure)
-                {
-                    if (sensor_set_exposure(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.exposure = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Saturation
-        case V4L2_CID_SATURATION:
-            {
-                if (ctrl->value != sensor->info_priv.saturation)
-                {
-                    if (sensor_set_saturation(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.saturation = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Contrast
-        case V4L2_CID_CONTRAST:
-            {
-                if (ctrl->value != sensor->info_priv.contrast)
-                {
-                    if (sensor_set_contrast(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.contrast = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_WhiteBalance
-        case V4L2_CID_DO_WHITE_BALANCE:
-            {
-                if (ctrl->value != sensor->info_priv.whiteBalance)
-                {
-                    if (sensor_set_whiteBalance(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.whiteBalance = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Mirror
-        case V4L2_CID_HFLIP:
-            {
-                if (ctrl->value != sensor->info_priv.mirror)
-                {
-                    if (sensor_set_mirror(icd, qctrl,ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.mirror = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Flip
-        case V4L2_CID_VFLIP:
-            {
-                if (ctrl->value != sensor->info_priv.flip)
-                {
-                    if (sensor_set_flip(icd, qctrl,ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.flip = ctrl->value;
-                }
-                break;
-            }
-#endif
-        default:
-            break;
-    }
-
-    return 0;
-}
-static int sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)
-{
-    const struct v4l2_queryctrl *qctrl;
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    struct sensor *sensor = to_sensor(client);
-
-    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
-
-    if (!qctrl)
-    {
-        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
-        return -EINVAL;
-    }
-
-    switch (ext_ctrl->id)
-    {
-        case V4L2_CID_SCENE:
-            {
-                ext_ctrl->value = sensor->info_priv.scene;
-                break;
-            }
-        case V4L2_CID_EFFECT:
-            {
-                ext_ctrl->value = sensor->info_priv.effect;
-                break;
-            }
-        case V4L2_CID_ZOOM_ABSOLUTE:
-            {
-                ext_ctrl->value = sensor->info_priv.digitalzoom;
-                break;
-            }
-        case V4L2_CID_ZOOM_RELATIVE:
-            {
-                return -EINVAL;
-            }
-        case V4L2_CID_FOCUS_ABSOLUTE:
-            {
-                ext_ctrl->value = sensor->info_priv.focus;
-                break;
-            }
-        case V4L2_CID_FOCUS_RELATIVE:
-            {
-                return -EINVAL;
-            }
-        case V4L2_CID_FLASH:
-            {
-                ext_ctrl->value = sensor->info_priv.flash;
-                break;
-            }
-        default :
-            break;
-    }
-    return 0;
-}
-static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)
-{
-    const struct v4l2_queryctrl *qctrl;
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    struct sensor *sensor = to_sensor(client);
-    int val_offset;
-
-    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
-
-    if (!qctrl)
-    {
-        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
-        return -EINVAL;
-    }
-
-	val_offset = 0;
-    switch (ext_ctrl->id)
-    {
-#if CONFIG_SENSOR_Scene
-        case V4L2_CID_SCENE:
-            {
-                if (ext_ctrl->value != sensor->info_priv.scene)
-                {
-                    if (sensor_set_scene(icd, qctrl,ext_ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.scene = ext_ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Effect
-        case V4L2_CID_EFFECT:
-            {
-                if (ext_ctrl->value != sensor->info_priv.effect)
-                {
-                    if (sensor_set_effect(icd, qctrl,ext_ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.effect= ext_ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_DigitalZoom
-        case V4L2_CID_ZOOM_ABSOLUTE:
-            {
-                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
-                    return -EINVAL;
-
-                if (ext_ctrl->value != sensor->info_priv.digitalzoom)
-                {
-                    val_offset = ext_ctrl->value -sensor->info_priv.digitalzoom;
-
-                    if (sensor_set_digitalzoom(icd, qctrl,&val_offset) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.digitalzoom += val_offset;
-
-                    SENSOR_DG("%s digitalzoom is %x\n",SENSOR_NAME_STRING(),  sensor->info_priv.digitalzoom);
-                }
-
-                break;
-            }
-        case V4L2_CID_ZOOM_RELATIVE:
-            {
-                if (ext_ctrl->value)
-                {
-                    if (sensor_set_digitalzoom(icd, qctrl,&ext_ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.digitalzoom += ext_ctrl->value;
-
-                    SENSOR_DG("%s digitalzoom is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.digitalzoom);
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Focus
-        case V4L2_CID_FOCUS_ABSOLUTE:
-            {
-                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
-                    return -EINVAL;
-
-                if (ext_ctrl->value != sensor->info_priv.focus)
-                {
-                    val_offset = ext_ctrl->value -sensor->info_priv.focus;
-
-                    sensor->info_priv.focus += val_offset;
-                }
-
-                break;
-            }
-        case V4L2_CID_FOCUS_RELATIVE:
-            {
-                if (ext_ctrl->value)
-                {
-                    sensor->info_priv.focus += ext_ctrl->value;
-
-                    SENSOR_DG("%s focus is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.focus);
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Flash
-        case V4L2_CID_FLASH:
-            {
-                if (sensor_set_flash(icd, qctrl,ext_ctrl->value) != 0)
-                    return -EINVAL;
-                sensor->info_priv.flash = ext_ctrl->value;
-
-                SENSOR_DG("%s flash is %x\n",SENSOR_NAME_STRING(), sensor->info_priv.flash);
-                break;
-            }
-#endif
-        default:
-            break;
-    }
-
-    return 0;
-}
-
-static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
-{
-    struct i2c_client *client = sd->priv;
-    struct soc_camera_device *icd = client->dev.platform_data;
-    int i, error_cnt=0, error_idx=-1;
-
-
-    for (i=0; i<ext_ctrl->count; i++) {
-        if (sensor_g_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
-            error_cnt++;
-            error_idx = i;
-        }
-    }
-
-    if (error_cnt > 1)
-        error_idx = ext_ctrl->count;
-
-    if (error_idx != -1) {
-        ext_ctrl->error_idx = error_idx;
-        return -EINVAL;
-    } else {
-        return 0;
-    }
-}
-
-static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
-{
-    struct i2c_client *client = sd->priv;
-    struct soc_camera_device *icd = client->dev.platform_data;
-    int i, error_cnt=0, error_idx=-1;
-
-
-    for (i=0; i<ext_ctrl->count; i++) {
-        if (sensor_s_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
-            error_cnt++;
-            error_idx = i;
-        }
-    }
-
-    if (error_cnt > 1)
-        error_idx = ext_ctrl->count;
-
-    if (error_idx != -1) {
-        ext_ctrl->error_idx = error_idx;
-        return -EINVAL;
-    } else {
-        return 0;
-    }
-}
-
-/* Interface active, can use i2c. If it fails, it can indeed mean, that
- * this wasn't our capture interface, so, we wait for the right one */
-static int sensor_video_probe(struct soc_camera_device *icd,
-			       struct i2c_client *client)
-{
-    char value;
-    int ret,pid = 0;
-    struct sensor *sensor = to_sensor(client);
-
-    /* We must have a parent by now. And it cannot be a wrong one.
-     * So this entire test is completely redundant. */
-    if (!icd->dev.parent ||
-	    to_soc_camera_host(icd->dev.parent)->nr != icd->iface)
-		return -ENODEV;
-
-	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
-		ret = -ENODEV;
-		goto sensor_video_probe_err;
-	}
-
-    /* soft reset */
-    ret = sensor_write(client, 0xff, 0x1);
-    if (ret != 0) {
-        SENSOR_TR("soft reset %s failed\n",SENSOR_NAME_STRING());
-        ret = -ENODEV;
-		goto sensor_video_probe_err;
-    }
-    mdelay(5);          //delay 5 microseconds
-
-    /* check if it is an sensor sensor */
-    ret = sensor_read(client, 0x0a, &value);
-    if (ret != 0) {
-        SENSOR_TR("read chip id high byte failed\n");
-        ret = -ENODEV;
-        goto sensor_video_probe_err;
-    }
-    pid = value << 8;
-
-    ret = sensor_read(client, 0x0b, &value);
-    if (ret != 0) {
-        SENSOR_TR("read chip id low byte failed\n");
-        ret = -ENODEV;
-        goto sensor_video_probe_err;
-    }
-
-    pid |= (value & 0xff);
-    SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
-
-    if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
-        sensor->model = SENSOR_V4L2_IDENT;
-    } else {
-        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
-        ret = -ENODEV;
-        goto sensor_video_probe_err;
-    }
-
-    return 0;
-
-sensor_video_probe_err:
-
-    return ret;
-}
-
-static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
-{
-	struct i2c_client *client = sd->priv;
-    struct soc_camera_device *icd = client->dev.platform_data;  
-    struct sensor *sensor = to_sensor(client);
-    int ret = 0;
-    
-	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
-	switch (cmd)
-	{
-		case RK29_CAM_SUBDEV_DEACTIVATE:
-		{
-			sensor_deactivate(client);
-			break;
-		}
-
-		case RK29_CAM_SUBDEV_IOREQUEST:
-		{
-			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
-            if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
-                }
-            } else {
-                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
-                ret = -EINVAL;
-                goto sensor_ioctl_end;
-            }
-            /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
-               for this project */
-            #if CONFIG_SENSOR_Flash	
-        	if (sensor->sensor_gpio_res) { 
-                if (sensor->sensor_gpio_res->gpio_flash == INVALID_GPIO) {
-                    for (i = 0; i < icd->ops->num_controls; i++) {
-                		if (V4L2_CID_FLASH == icd->ops->controls[i].id) {
-                			memset((char*)&icd->ops->controls[i],0x00,sizeof(struct v4l2_queryctrl));                			
-                		}
-                    }
-                    sensor->info_priv.flash = 0xff;
-                    SENSOR_DG("%s flash gpio is invalidate!\n",SENSOR_NAME_STRING());
-                }
-        	}
-            #endif
-			break;
-		}
-		default:
-		{
-			SENSOR_TR("%s %s cmd(0x%x) is unknown !\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
-			break;
-		}
-	}
-
-sensor_ioctl_end:
-	return ret;
-
-}
-static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
-			    enum v4l2_mbus_pixelcode *code)
-{
-	if (index >= ARRAY_SIZE(sensor_colour_fmts))
-		return -EINVAL;
-
-	*code = sensor_colour_fmts[index].code;
-	return 0;
-}
-static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
-	.init		= sensor_init,
-	.g_ctrl		= sensor_g_control,
-	.s_ctrl		= sensor_s_control,
-	.g_ext_ctrls          = sensor_g_ext_controls,
-	.s_ext_ctrls          = sensor_s_ext_controls,
-	.g_chip_ident	= sensor_g_chip_ident,
-	.ioctl = sensor_ioctl,
-};
-
-static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
-	.s_mbus_fmt	= sensor_s_fmt,
-	.g_mbus_fmt	= sensor_g_fmt,
-	.try_mbus_fmt	= sensor_try_fmt,
-	.enum_mbus_fmt	= sensor_enum_fmt,
-};
-
-static struct v4l2_subdev_ops sensor_subdev_ops = {
-	.core	= &sensor_subdev_core_ops,
-	.video = &sensor_subdev_video_ops,
-};
-
-static int sensor_probe(struct i2c_client *client,
-			 const struct i2c_device_id *did)
-{
-    struct sensor *sensor;
-    struct soc_camera_device *icd = client->dev.platform_data;
-    struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
-    struct soc_camera_link *icl;
-    int ret;
-
-    SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
-    if (!icd) {
-        dev_err(&client->dev, "%s: missing soc-camera data!\n",SENSOR_NAME_STRING());
-        return -EINVAL;
-    }
-
-    icl = to_soc_camera_link(icd);
-    if (!icl) {
-        dev_err(&client->dev, "%s driver needs platform data\n", SENSOR_NAME_STRING());
-        return -EINVAL;
-    }
-
-    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
-        dev_warn(&adapter->dev,
-        	 "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
-        return -EIO;
-    }
-
-    sensor = kzalloc(sizeof(struct sensor), GFP_KERNEL);
-    if (!sensor)
-        return -ENOMEM;
-
-    v4l2_i2c_subdev_init(&sensor->subdev, client, &sensor_subdev_ops);
-
-    /* Second stage probe - when a capture adapter is there */
-    icd->ops		= &sensor_ops;
-    sensor->info_priv.fmt = sensor_colour_fmts[0];
-	#if CONFIG_SENSOR_I2C_NOSCHED
-	atomic_set(&sensor->tasklock_cnt,0);
-	#endif
-
-    ret = sensor_video_probe(icd, client);
-    if (ret < 0) {
-        icd->ops = NULL;
-        i2c_set_clientdata(client, NULL);
-        kfree(sensor);
-		sensor = NULL;
-    }
-    SENSOR_DG("\n%s..%s..%d  ret = %x \n",__FUNCTION__,__FILE__,__LINE__,ret);
-    return ret;
-}
-
-static int sensor_remove(struct i2c_client *client)
-{
-    struct sensor *sensor = to_sensor(client);
-    struct soc_camera_device *icd = client->dev.platform_data;
-
-    icd->ops = NULL;
-    i2c_set_clientdata(client, NULL);
-    client->driver = NULL;
-    kfree(sensor);
-	sensor = NULL;
-    return 0;
-}
-
-static const struct i2c_device_id sensor_id[] = {
-	{SENSOR_NAME_STRING(), 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, sensor_id);
-
-static struct i2c_driver sensor_i2c_driver = {
-	.driver = {
-		.name = SENSOR_NAME_STRING(),
-	},
-	.probe		= sensor_probe,
-	.remove		= sensor_remove,
-	.id_table	= sensor_id,
-};
-
-static int __init sensor_mod_init(void)
-{
-    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());
-    return i2c_add_driver(&sensor_i2c_driver);
-}
-
-static void __exit sensor_mod_exit(void)
-{
-    i2c_del_driver(&sensor_i2c_driver);
-}
-
-device_initcall_sync(sensor_mod_init);
-module_exit(sensor_mod_exit);
-
-MODULE_DESCRIPTION(SENSOR_NAME_STRING(Camera sensor driver));
-MODULE_AUTHOR("ddl <kernel@rock-chips>");
-MODULE_LICENSE("GPL");
-
-
->>>>>>> parent of 15f7fab... temp revert rk change
diff --git a/drivers/media/video/soc_camera.c b/drivers/media/video/soc_camera.c
index ffa754d6a2ae..4e4d4122d9a6 100644
--- a/drivers/media/video/soc_camera.c
+++ b/drivers/media/video/soc_camera.c
@@ -37,19 +37,6 @@
 #include <media/videobuf2-core.h>
 #include <media/soc_mediabus.h>
 
-/*
-*			 Driver Version Note
-*
-*v0.1.1 : 
-*         1.Turn off cif and sensor before streamoff videobuf;
-*         2.Don't free videobuf struct, free operation run in next requset buffer;
-*
-*/
-
-#define RK_SOC_CAMERA_VERSION KERNEL_VERSION(0, 1, 1)
-static int version = RK_SOC_CAMERA_VERSION;
-module_param(version, int, S_IRUGO);
-
 /* Default to VGA resolution */
 #define DEFAULT_WIDTH	640
 #define DEFAULT_HEIGHT	480
@@ -77,10 +64,8 @@ static int soc_camera_power_set(struct soc_camera_device *icd,
 			return ret;
 		}
 
-		if (icl->power){
-			icl->power(icd->pdev, 0); // ensure power and reset pin are not active.
+		if (icl->power)
 			ret = icl->power(icd->pdev, power_on);
-			}
 		if (ret < 0) {
 			dev_err(&icd->dev,
 				"Platform failed to power-on the camera.\n");
@@ -500,45 +485,36 @@ static int soc_camera_open(struct file *file)
 			},
 		};
 
-        /* ddl@rock-chips.com : accelerate device open  */
-        if ((file->f_flags & O_ACCMODE) == O_RDWR) {
-            ret = soc_camera_power_set(icd, icl, 1);
-    		if (ret < 0)
-    			goto epower;
+		ret = soc_camera_power_set(icd, icl, 1);
+		if (ret < 0)
+			goto epower;
 
-        }
+		/* The camera could have been already on, try to reset */
+		if (icl->reset)
+			icl->reset(icd->pdev);
 
 		ret = ici->ops->add(icd);
 		if (ret < 0) {
 			dev_err(&icd->dev, "Couldn't activate the camera: %d\n", ret);
 			goto eiciadd;
 		}
-        /* ddl@rock-chips.com : accelerate device open  */
-        //reset MUST be done after mclk supply(for mt9335 isp)
-        
-        if ((file->f_flags & O_ACCMODE) == O_RDWR) {
-    		/* The camera could have been already on, try to reset */
-    		if (icl->reset)
-    			icl->reset(icd->pdev);
-            }
+
 		pm_runtime_enable(&icd->vdev->dev);
 		ret = pm_runtime_resume(&icd->vdev->dev);
 		if (ret < 0 && ret != -ENOSYS)
 			goto eresume;
-        /* ddl@rock-chips.com : accelerate device open  */
-        if ((file->f_flags & O_ACCMODE) == O_RDWR) {
-    		/*
-    		 * Try to configure with default parameters. Notice: this is the
-    		 * very first open, so, we cannot race against other calls,
-    		 * apart from someone else calling open() simultaneously, but
-    		 * .video_lock is protecting us against it.
-    		 */
-    		ret = soc_camera_set_fmt(icd, &f);
-    		if (ret < 0)
-    			goto esfmt;
-        }
-
-        if (ici->ops->init_videobuf) {
+
+		/*
+		 * Try to configure with default parameters. Notice: this is the
+		 * very first open, so, we cannot race against other calls,
+		 * apart from someone else calling open() simultaneously, but
+		 * .video_lock is protecting us against it.
+		 */
+		ret = soc_camera_set_fmt(icd, &f);
+		if (ret < 0)
+			goto esfmt;
+
+		if (ici->ops->init_videobuf) {
 			ici->ops->init_videobuf(&icd->vb_vidq, icd);
 		} else {
 			ret = ici->ops->init_videobuf2(&icd->vb2_vidq, icd);
@@ -586,9 +562,7 @@ static int soc_camera_close(struct file *file)
 		if (ici->ops->init_videobuf2)
 			vb2_queue_release(&icd->vb2_vidq);
 
-        if ((file->f_flags & O_ACCMODE) == O_RDWR) {   /* ddl@rock-chips.com : accelerate device open  */
-            soc_camera_power_set(icd, icl, 0);	
-        }
+		soc_camera_power_set(icd, icl, 0);
 	}
 
 	if (icd->streamer == file)
@@ -704,27 +678,7 @@ static int soc_camera_s_fmt_vid_cap(struct file *file, void *priv,
 
 	return ret;
 }
-/* ddl@rock-chips.com : Add ioctrl - VIDIOC_ENUM_FRAMEINTERVALS for soc-camera */
-static int soc_camera_enum_frameintervals (struct file *file, void  *priv,
-					   struct v4l2_frmivalenum *fival)
-{
-    struct soc_camera_device *icd = file->private_data;
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
-    int ret;
-    
-	WARN_ON(priv != file->private_data);
-
-    ret = v4l2_subdev_call(sd, video, enum_frameintervals, fival);
-    if (ret == -ENOIOCTLCMD) {
-        if (ici->ops->enum_frameinervals)
-           ret = ici->ops->enum_frameinervals(icd, fival); 
-        else 
-           ret = -ENOIOCTLCMD;
-    }
 
-    return ret;
-}
 static int soc_camera_enum_fmt_vid_cap(struct file *file, void  *priv,
 				       struct v4l2_fmtdesc *f)
 {
@@ -793,7 +747,7 @@ static int soc_camera_streamon(struct file *file, void *priv,
 		return -EINVAL;
 
 	if (icd->streamer != file)
-		return -EBUSY;    
+		return -EBUSY;
 
 	/* This calls buf_queue from host driver's videobuf_queue_ops */
 	if (ici->ops->init_videobuf)
@@ -801,11 +755,8 @@ static int soc_camera_streamon(struct file *file, void *priv,
 	else
 		ret = vb2_streamon(&icd->vb2_vidq, i);
 
-	if (!ret) {
+	if (!ret)
 		v4l2_subdev_call(sd, video, s_stream, 1);
-        if (ici->ops->s_stream)
-	        ici->ops->s_stream(icd, 1);				/* ddl@rock-chips.com : Add stream control for host */
-	}
 
 	return ret;
 }
@@ -824,10 +775,6 @@ static int soc_camera_streamoff(struct file *file, void *priv,
 
 	if (icd->streamer != file)
 		return -EBUSY;
-    /* ddl@rock-chips.com: v0.1.1 */
-    v4l2_subdev_call(sd, video, s_stream, 0);
-    if (ici->ops->s_stream)
-		ici->ops->s_stream(icd, 0);				/* ddl@rock-chips.com : Add stream control for host */
 
 	/*
 	 * This calls buf_release from host driver's videobuf_queue_ops for all
@@ -838,9 +785,8 @@ static int soc_camera_streamoff(struct file *file, void *priv,
 	else
 		vb2_streamoff(&icd->vb2_vidq, i);
 
-    /* ddl@rock-chips.com: this code is invalidate, free can be run in requset buf */
-    //videobuf_mmap_free(&icd->vb_vidq);          /* ddl@rock-chips.com : free video buf */
-	
+	v4l2_subdev_call(sd, video, s_stream, 0);
+
 	return 0;
 }
 
@@ -856,19 +802,18 @@ static int soc_camera_queryctrl(struct file *file, void *priv,
 	if (!qc->id)
 		return -EINVAL;
 
-	/* first device controls */
-	//if device support digital zoom ,first use it to do zoom,zyc
-	for (i = 0; i < icd->ops->num_controls; i++)
-		if (qc->id == icd->ops->controls[i].id) {
-			memcpy(qc, &(icd->ops->controls[i]),
+	/* First check host controls */
+	for (i = 0; i < ici->ops->num_controls; i++)
+		if (qc->id == ici->ops->controls[i].id) {
+			memcpy(qc, &(ici->ops->controls[i]),
 				sizeof(*qc));
 			return 0;
 		}
 
-	/* then check host controls */
-	for (i = 0; i < ici->ops->num_controls; i++)
-		if (qc->id == ici->ops->controls[i].id) {
-			memcpy(qc, &(ici->ops->controls[i]),
+	/* Then device controls */
+	for (i = 0; i < icd->ops->num_controls; i++)
+		if (qc->id == icd->ops->controls[i].id) {
+			memcpy(qc, &(icd->ops->controls[i]),
 				sizeof(*qc));
 			return 0;
 		}
@@ -876,39 +821,6 @@ static int soc_camera_queryctrl(struct file *file, void *priv,
 	return -EINVAL;
 }
 
-/* ddl@rock-chips.com : Add ioctrl -VIDIOC_QUERYMENU */
-static int soc_camera_querymenu(struct file *file, void *priv,
-                                struct v4l2_querymenu *qm)
-{
-    struct soc_camera_device *icd = file->private_data;
-    struct v4l2_queryctrl qctrl;
-    int i,j;
-
-    qctrl.id = qm->id;
-
-    if (soc_camera_queryctrl(file,priv, &qctrl) == 0) {
-        for (i = 0; i < icd->ops->num_menus; i++) {
-            if (qm->id == icd->ops->menus[i].id) {
-                for (j=0; j<=(qctrl.maximum - qctrl.minimum); j++) {
-
-                    if (qm->index == icd->ops->menus[i].index) {
-                        snprintf(qm->name, sizeof(qm->name), icd->ops->menus[i].name);
-                        qm->reserved = 0;
-
-                        return 0;
-                    } else {
-                        i++;
-                        if ( i >= icd->ops->num_menus)
-                            return -EINVAL;
-                    }
-                }
-            }
-        }
-    }
-
-    return -EINVAL;
-}
-
 static int soc_camera_g_ctrl(struct file *file, void *priv,
 			     struct v4l2_control *ctrl)
 {
@@ -947,61 +859,6 @@ static int soc_camera_s_ctrl(struct file *file, void *priv,
 	return v4l2_subdev_call(sd, core, s_ctrl, ctrl);
 }
 
-
- /* ddl@rock-chips.com : Add ioctrl -VIDIOC_XXX_ext_ctrl for soc-camera */
-static int soc_camera_try_ext_ctrl(struct file *file, void *priv,
-                             struct v4l2_ext_controls *ctrl)
-{
-    struct soc_camera_device *icd = file->private_data;
-    const struct v4l2_queryctrl *qctrl;
-    int i;
-
-    WARN_ON(priv != file->private_data);
-
-    if (ctrl->ctrl_class != V4L2_CTRL_CLASS_CAMERA)
-        return -EINVAL;
-
-    for (i=0; i<ctrl->count; i++) {
-        qctrl = soc_camera_find_qctrl(icd->ops, ctrl->controls[i].id);
-        if (!qctrl)
-            return -EINVAL;
-
-        if ((ctrl->controls[i].value < qctrl->minimum) ||(ctrl->controls[i].value > qctrl->minimum))
-            return -ERANGE;
-    }
-
-    return 0;
-}
- /* ddl@rock-chips.com : Add ioctrl -VIDIOC_XXX_ext_ctrl for soc-camera */
-static int soc_camera_g_ext_ctrl(struct file *file, void *priv,
-                             struct v4l2_ext_controls *ctrl)
-{
-    struct soc_camera_device *icd = file->private_data;
-    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
-
-    WARN_ON(priv != file->private_data);
-
-    if (ctrl->ctrl_class != V4L2_CTRL_CLASS_CAMERA)
-        return -EINVAL;
-
-    return v4l2_subdev_call(sd, core, g_ext_ctrls, ctrl);
-}
- /* ddl@rock-chips.com : Add ioctrl -VIDIOC_XXX_ext_ctrl for soc-camera */
-static int soc_camera_s_ext_ctrl(struct file *file, void *priv,
-                             struct v4l2_ext_controls *ctrl)
-{
-    struct soc_camera_device *icd = file->private_data;
-    struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
-
-    WARN_ON(priv != file->private_data);
-
-    if (ctrl->ctrl_class != V4L2_CTRL_CLASS_CAMERA)
-        return -EINVAL;
-
-    return v4l2_subdev_call(sd, core, s_ext_ctrls, ctrl);
-}
-
-
 static int soc_camera_cropcap(struct file *file, void *fh,
 			      struct v4l2_cropcap *a)
 {
@@ -1130,8 +987,8 @@ static void scan_add_host(struct soc_camera_host *ici)
 		if (icd->iface == ici->nr) {
 			int ret;
 			icd->dev.parent = ici->v4l2_dev.dev;
-			dev_set_name(&icd->dev, "%u-%u-%s", icd->iface,
-				     icd->devnum,dev_name(icd->pdev));
+			dev_set_name(&icd->dev, "%u-%u", icd->iface,
+				     icd->devnum);
 			ret = device_register(&icd->dev);
 			if (ret < 0) {
 				icd->dev.parent = NULL;
@@ -1206,6 +1063,8 @@ static int soc_camera_probe(struct device *dev)
 	struct v4l2_mbus_framefmt mf;
 	int ret;
 
+	dev_info(dev, "Probing %s\n", dev_name(dev));
+
 	ret = regulator_bulk_get(icd->pdev, icl->num_regulators,
 				 icl->regulators);
 	if (ret < 0)
@@ -1215,14 +1074,13 @@ static int soc_camera_probe(struct device *dev)
 	if (ret < 0)
 		goto epower;
 
+	/* The camera could have been already on, try to reset */
+	if (icl->reset)
+		icl->reset(icd->pdev);
+
 	ret = ici->ops->add(icd);
 	if (ret < 0)
 		goto eadd;
-    
-    /* The camera could have been already on, try to reset */
-    //reset MUST be done after mclk supply(for mt9335 isp)
-    if (icl->reset)
-            icl->reset(icd->pdev);
 
 	/* Must have icd->vdev before registering the device */
 	ret = video_dev_create(icd);
@@ -1298,7 +1156,7 @@ static int soc_camera_probe(struct device *dev)
 	soc_camera_power_set(icd, icl, 0);
 
 	mutex_unlock(&icd->video_lock);
-    printk("Probe %s success\n", dev_name(icd->pdev));
+
 	return 0;
 
 evidstart:
@@ -1321,7 +1179,6 @@ static int soc_camera_probe(struct device *dev)
 epower:
 	regulator_bulk_free(icl->num_regulators, icl->regulators);
 ereg:
-    dev_err(dev, "Probe %s failed\n", dev_name(icd->pdev));
 	return ret;
 }
 
@@ -1614,13 +1471,8 @@ static const struct v4l2_ioctl_ops soc_camera_ioctl_ops = {
 	.vidioc_streamon	 = soc_camera_streamon,
 	.vidioc_streamoff	 = soc_camera_streamoff,
 	.vidioc_queryctrl	 = soc_camera_queryctrl,
-	 .vidioc_querymenu	 = soc_camera_querymenu,     /* ddl@rock-chips.com:   Add ioctrl - vidioc_querymenu for soc-camera */
 	.vidioc_g_ctrl		 = soc_camera_g_ctrl,
 	.vidioc_s_ctrl		 = soc_camera_s_ctrl,
-	.vidioc_g_ext_ctrls    = soc_camera_g_ext_ctrl,   /* ddl@rock-chips.com:   Add ioctrl - vidioc_g_ext_ctrls for soc-camera */
-	.vidioc_s_ext_ctrls    = soc_camera_s_ext_ctrl,   /* ddl@rock-chips.com:   Add ioctrl - vidioc_s_ext_ctrls for soc-camera */
-	.vidioc_try_ext_ctrls    = soc_camera_try_ext_ctrl,/* ddl@rock-chips.com:   Add ioctrl - vidioc_try_ext_ctrls for soc-camera */
-    .vidioc_enum_frameintervals = soc_camera_enum_frameintervals,/* ddl@rock-chips.com:   Add ioctrl - VIDIOC_ENUM_FRAMEINTERVALS for soc-camera */
 	.vidioc_cropcap		 = soc_camera_cropcap,
 	.vidioc_g_crop		 = soc_camera_g_crop,
 	.vidioc_s_crop		 = soc_camera_s_crop,
diff --git a/drivers/media/video/uvc/uvc_ctrl.c b/drivers/media/video/uvc/uvc_ctrl.c
index 7f49a2fc95e4..a4db26fa2f53 100644
--- a/drivers/media/video/uvc/uvc_ctrl.c
+++ b/drivers/media/video/uvc/uvc_ctrl.c
@@ -675,11 +675,7 @@ static struct uvc_control_mapping uvc_ctrl_mappings[] = {
 
 static inline __u8 *uvc_ctrl_data(struct uvc_control *ctrl, int id)
 {
-    #if 0       /* ddl@rock-chips.com: address must align to 4-bytes */
 	return ctrl->uvc_data + id * ctrl->info.size;
-    #else
-    return ctrl->uvc_data + id * ((ctrl->info.size+3)/4*4);
-    #endif
 }
 
 static inline int uvc_test_bit(const __u8 *data, int bit)
@@ -1594,13 +1590,8 @@ static int uvc_ctrl_add_info(struct uvc_device *dev, struct uvc_control *ctrl,
 	INIT_LIST_HEAD(&ctrl->info.mappings);
 
 	/* Allocate an array to save control values (cur, def, max, etc.) */
-    #if 0           /* ddl@rock-chips.com: address must align to 4-bytes */
 	ctrl->uvc_data = kzalloc(ctrl->info.size * UVC_CTRL_DATA_LAST + 1,
 				 GFP_KERNEL);
-    #else
-    ctrl->uvc_data = kzalloc(((ctrl->info.size+3)/4*4) * UVC_CTRL_DATA_LAST + 1,
-				 GFP_KERNEL);
-    #endif
 	if (ctrl->uvc_data == NULL) {
 		ret = -ENOMEM;
 		goto done;
diff --git a/drivers/media/video/uvc/uvc_queue.c b/drivers/media/video/uvc/uvc_queue.c
index 0abe14569993..f90ce9fce539 100644
--- a/drivers/media/video/uvc/uvc_queue.c
+++ b/drivers/media/video/uvc/uvc_queue.c
@@ -85,7 +85,6 @@ void uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,
 	spin_lock_init(&queue->irqlock);
 	INIT_LIST_HEAD(&queue->mainqueue);
 	INIT_LIST_HEAD(&queue->irqqueue);
-	init_waitqueue_head(&queue->wait);  /* ddl@rock-chips.com : This design copied from video-buf */
 	queue->flags = drop_corrupted ? UVC_QUEUE_DROP_CORRUPTED : 0;
 	queue->type = type;
 }
@@ -302,8 +301,6 @@ int uvc_queue_buffer(struct uvc_video_queue *queue,
 	list_add_tail(&buf->queue, &queue->irqqueue);
 	spin_unlock_irqrestore(&queue->irqlock, flags);
 
-    wake_up_interruptible_sync(&queue->wait);     /* ddl@rock-chips.com : This design copied from video-buf */
-
 done:
 	mutex_unlock(&queue->mutex);
 	return ret;
@@ -317,19 +314,11 @@ static int uvc_queue_waiton(struct uvc_buffer *buf, int nonblocking)
 			buf->state != UVC_BUF_STATE_READY)
 			? 0 : -EAGAIN;
 	}
-#if 0
+
 	return wait_event_interruptible(buf->wait,
 		buf->state != UVC_BUF_STATE_QUEUED &&
 		buf->state != UVC_BUF_STATE_ACTIVE &&
 		buf->state != UVC_BUF_STATE_READY);
-#else
-	/* ddl@rock-chips.com: wait_event_interruptible -> wait_event_interruptible_timeout */
-	return wait_event_interruptible_timeout(buf->wait,
-		buf->state != UVC_BUF_STATE_QUEUED &&
-		buf->state != UVC_BUF_STATE_ACTIVE &&
-		buf->state != UVC_BUF_STATE_READY,
-		msecs_to_jiffies(800));
-#endif
 }
 
 /*
@@ -349,53 +338,17 @@ int uvc_dequeue_buffer(struct uvc_video_queue *queue,
 			v4l2_buf->memory);
 		return -EINVAL;
 	}
-    /* ddl@rock-chips.com */
-    if (!(queue->flags & UVC_QUEUE_STREAMING)) {
-        printk("uvcvideo: Not streaming\n");
-		return -EINVAL;
-    }
 
 	mutex_lock(&queue->mutex);
-    /* ddl@rock-chips.com : This design copied from video-buf */
-checks:    
 	if (list_empty(&queue->mainqueue)) {
-        if (nonblocking) {
-			uvc_trace(UVC_TRACE_CAPTURE, "[E] Empty buffer queue.\n");
-    		ret = -EINVAL;
-    		goto done;
-		} else {
-		    //uvc_trace(UVC_TRACE_CAPTURE, "dequeue_buffer: waiting on buffer\n");
-            printk("dequeue_buffer: waiting on buffer\n");
-			/* Drop lock to avoid deadlock with qbuf */
-			mutex_unlock(&queue->mutex);
-
-			/* Checking list_empty and streaming is safe without
-			 * locks because we goto checks to validate while
-			 * holding locks before proceeding */
-			ret = wait_event_interruptible(queue->wait,
-				((!list_empty(&queue->mainqueue)) || (!(queue->flags & UVC_QUEUE_STREAMING))));
-			mutex_lock(&queue->mutex);
-
-			if (ret || (!(queue->flags & UVC_QUEUE_STREAMING))) {
-                printk("uvcvideo: Stream off\n");
-                goto done;
-			}
-
-			goto checks;
-		}	
+		uvc_trace(UVC_TRACE_CAPTURE, "[E] Empty buffer queue.\n");
+		ret = -EINVAL;
+		goto done;
 	}
 
 	buf = list_first_entry(&queue->mainqueue, struct uvc_buffer, stream);
-	if ((ret = uvc_queue_waiton(buf, nonblocking)) <= 0) {
-        /* ddl@rock-chips.com: It is timeout */
-        if (ret == 0) {
-            ret = -EINVAL;
-            printk(KERN_ERR "uvcvideo: uvc_dequeue_buffer is timeout!!\n");
-        } else {
-            printk(KERN_ERR "uvcvideo: uvc_dequeue_buffer is failed!!(ret:%d)\n",ret);
-        }
+	if ((ret = uvc_queue_waiton(buf, nonblocking)) < 0)
 		goto done;
-	}
 
 	uvc_trace(UVC_TRACE_CAPTURE, "Dequeuing buffer %u (%u, %u bytes).\n",
 		buf->buf.index, buf->state, buf->buf.bytesused);
@@ -599,7 +552,6 @@ int uvc_queue_enable(struct uvc_video_queue *queue, int enable)
 		queue->flags |= UVC_QUEUE_STREAMING;
 		queue->buf_used = 0;
 	} else {
-	    queue->flags &= ~UVC_QUEUE_STREAMING;
 		uvc_queue_cancel(queue, 0);
 		INIT_LIST_HEAD(&queue->mainqueue);
 
@@ -607,6 +559,8 @@ int uvc_queue_enable(struct uvc_video_queue *queue, int enable)
 			queue->buffer[i].error = 0;
 			queue->buffer[i].state = UVC_BUF_STATE_IDLE;
 		}
+
+		queue->flags &= ~UVC_QUEUE_STREAMING;
 	}
 
 done:
@@ -631,8 +585,6 @@ void uvc_queue_cancel(struct uvc_video_queue *queue, int disconnect)
 	struct uvc_buffer *buf;
 	unsigned long flags;
 
-    wake_up_interruptible_sync(&queue->wait);           /* ddl@rock-chips.com : This design copied from video-buf */
-
 	spin_lock_irqsave(&queue->irqlock, flags);
 	while (!list_empty(&queue->irqqueue)) {
 		buf = list_first_entry(&queue->irqqueue, struct uvc_buffer,
diff --git a/drivers/media/video/uvc/uvc_v4l2.c b/drivers/media/video/uvc/uvc_v4l2.c
index 06e2091d0564..5afdbb7bbea5 100644
--- a/drivers/media/video/uvc/uvc_v4l2.c
+++ b/drivers/media/video/uvc/uvc_v4l2.c
@@ -304,10 +304,8 @@ static int uvc_v4l2_set_format(struct uvc_streaming *stream,
 	struct uvc_frame *frame;
 	int ret;
 
-	if (fmt->type != stream->type) {
-        printk("uvc_v4l2_set_format, fmt->type(%d) != stream->type(%d)\n",fmt->type,stream->type);
+	if (fmt->type != stream->type)
 		return -EINVAL;
-	}
 
 	ret = uvc_v4l2_try_format(stream, fmt, &probe, &format, &frame);
 	if (ret < 0)
@@ -316,7 +314,6 @@ static int uvc_v4l2_set_format(struct uvc_streaming *stream,
 	mutex_lock(&stream->mutex);
 
 	if (uvc_queue_allocated(&stream->queue)) {
-        printk("uvc_queue_allocated failed\n");
 		ret = -EBUSY;
 		goto done;
 	}
@@ -811,10 +808,8 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 	}
 
 	case VIDIOC_S_FMT:
-		if ((ret = uvc_acquire_privileges(handle)) < 0) {
-            printk("uvc_acquire_privileges error.");
+		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
-		}
 
 		return uvc_v4l2_set_format(stream, arg);
 
@@ -988,18 +983,14 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 	}
 
 	case VIDIOC_QBUF:
-		if (!uvc_has_privileges(handle)) {
-            printk("uvcvideo: VIDIOC_QBUF uvc_has_privileges failed\n");
+		if (!uvc_has_privileges(handle))
 			return -EBUSY;
-		}
 
 		return uvc_queue_buffer(&stream->queue, arg);
 
 	case VIDIOC_DQBUF:
-		if (!uvc_has_privileges(handle)) {
-            printk("uvcvideo: VIDIOC_DQBUF uvc_has_privileges failed\n");
+		if (!uvc_has_privileges(handle))
 			return -EBUSY;
-		}
 
 		return uvc_dequeue_buffer(&stream->queue, arg,
 			file->f_flags & O_NONBLOCK);
diff --git a/drivers/media/video/uvc/uvc_video.c b/drivers/media/video/uvc/uvc_video.c
index b596442d32e8..6f147defcce7 100644
--- a/drivers/media/video/uvc/uvc_video.c
+++ b/drivers/media/video/uvc/uvc_video.c
@@ -740,18 +740,14 @@ static void uvc_video_encode_bulk(struct urb *urb, struct uvc_streaming *stream,
 
 	urb->transfer_buffer_length = stream->urb_size - len;
 }
-/* ddl@rock-chips.com : uvc_video_complete is run in_interrupt(), so uvc decode operation delay run in tasklet for
-*    usb host reenable interrupt soon
-*/
-static void uvc_video_complete_fun (struct urb *urb)
-{    
+
+static void uvc_video_complete(struct urb *urb)
+{
 	struct uvc_streaming *stream = urb->context;
 	struct uvc_video_queue *queue = &stream->queue;
 	struct uvc_buffer *buf = NULL;
 	unsigned long flags;
 	int ret;
-	int i;
-	atomic_t *urb_state=NULL;
 
 	switch (urb->status) {
 	case 0:
@@ -771,67 +767,19 @@ static void uvc_video_complete_fun (struct urb *urb)
 		return;
 	}
 
-    for (i = 0; i < UVC_URBS; ++i) {    
-        if (stream->urb[i] == urb) {
-            urb_state = &stream->urb_state[i];
-            break;
-        }
-    }
-
-    if (urb_state == NULL) {
-        printk("urb(%p) cann't be finded in stream->urb(%p, %p, %p, %p, %p)\n",
-              urb,stream->urb[0],stream->urb[1],stream->urb[2],stream->urb[3],stream->urb[4]);
-        BUG();
-    }
-	
-	if (atomic_read(urb_state)==UrbDeactive) {
-	    printk(KERN_DEBUG "urb is deactive, this urb complete cancel!");
-		uvc_queue_cancel(queue, urb->status == -ESHUTDOWN);
-	    return;
-	}
-
 	spin_lock_irqsave(&queue->irqlock, flags);
 	if (!list_empty(&queue->irqqueue))
 		buf = list_first_entry(&queue->irqqueue, struct uvc_buffer,
 				       queue);
-    spin_unlock_irqrestore(&queue->irqlock, flags);	
-    
+	spin_unlock_irqrestore(&queue->irqlock, flags);
+
 	stream->decode(urb, stream, buf);
-	
+
 	if ((ret = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
 		uvc_printk(KERN_ERR, "Failed to resubmit video URB (%d).\n",
 			ret);
 	}
 }
-static void uvc_video_complete_tasklet(unsigned long data)
-{
-    struct urb *urb = (struct urb*)data;   
-    
-    uvc_video_complete_fun(urb);    
-    
-    return;
-}
-static void uvc_video_complete(struct urb *urb)
-{
-    int i;
-    struct uvc_streaming *stream = urb->context;
-    struct tasklet_struct *tasklet = NULL;
-    atomic_t *urb_state;
-    
-    for (i = 0; i < UVC_URBS; ++i) {    
-        if (stream->urb[i] == urb) {
-            tasklet = stream->tasklet[i];
-            urb_state = &stream->urb_state[i];
-            break;
-        }
-    }
-
-    if ((tasklet != NULL)&&(atomic_read(urb_state)==UrbActive)) {
-        tasklet_schedule(tasklet);
-    } else {
-        uvc_video_complete_fun(urb);
-    }
-}
 
 /*
  * Free transfer buffers.
@@ -912,24 +860,15 @@ static void uvc_uninit_video(struct uvc_streaming *stream, int free_buffers)
 {
 	struct urb *urb;
 	unsigned int i;
-   
+
 	for (i = 0; i < UVC_URBS; ++i) {
 		urb = stream->urb[i];
 		if (urb == NULL)
 			continue;
-		else
-		    atomic_set(&stream->urb_state[i],UrbDeactive);
-		
-        if (stream->tasklet[i]) {
-            tasklet_kill(stream->tasklet[i]);
-            kfree(stream->tasklet[i]);
-            stream->tasklet[i] = NULL;
-        }
 
 		usb_kill_urb(urb);
 		usb_free_urb(urb);
 		stream->urb[i] = NULL;
-        
 	}
 
 	if (free_buffers)
@@ -983,15 +922,6 @@ static int uvc_init_video_isoc(struct uvc_streaming *stream,
 		}
 
 		stream->urb[i] = urb;
-        /* ddl@rock-chips.com  */
-        atomic_set(&stream->urb_state[i],UrbActive);
-        stream->tasklet[i] = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
-        if (stream->tasklet[i] == NULL) {
-            uvc_printk(KERN_ERR, "device %s requested tasklet memory fail!\n",
-				stream->dev->name);
-        } else {
-            tasklet_init(stream->tasklet[i], uvc_video_complete_tasklet, (unsigned long)urb);
-        }
 	}
 
 	return 0;
@@ -1043,15 +973,6 @@ static int uvc_init_video_bulk(struct uvc_streaming *stream,
 		urb->transfer_dma = stream->urb_dma[i];
 
 		stream->urb[i] = urb;
-
-        /* ddl@rock-chips.com  */
-        stream->tasklet[i] = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
-        if (stream->tasklet[i] == NULL) {
-            uvc_printk(KERN_ERR, "device %s requested tasklet memory fail!\n",
-				stream->dev->name);
-        } else {
-            tasklet_init(stream->tasklet[i], uvc_video_complete_tasklet, (unsigned long)urb);
-        }
 	}
 
 	return 0;
@@ -1328,14 +1249,11 @@ int uvc_video_init(struct uvc_streaming *stream)
 int uvc_video_enable(struct uvc_streaming *stream, int enable)
 {
 	int ret;
-    
+
 	if (!enable) {
-        if (stream->flags & UVC_QUEUE_STREAMING) {      /* ddl@rock-chips.com */
-            uvc_queue_enable(&stream->queue, 0);
-    		uvc_uninit_video(stream, 1);
-    		usb_set_interface(stream->dev->udev, stream->intfnum, 0);
-    		stream->flags &= ~UVC_QUEUE_STREAMING;
-        }
+		uvc_uninit_video(stream, 1);
+		usb_set_interface(stream->dev->udev, stream->intfnum, 0);
+		uvc_queue_enable(&stream->queue, 0);
 		return 0;
 	}
 
@@ -1349,7 +1267,7 @@ int uvc_video_enable(struct uvc_streaming *stream, int enable)
 		uvc_queue_enable(&stream->queue, 0);
 		return ret;
 	}
-    stream->flags |= UVC_QUEUE_STREAMING;
+
 	return uvc_init_video(stream, GFP_KERNEL);
 }
 
diff --git a/drivers/media/video/uvc/uvcvideo.h b/drivers/media/video/uvc/uvcvideo.h
index a85879cacb3b..cf2401a041ae 100644
--- a/drivers/media/video/uvc/uvcvideo.h
+++ b/drivers/media/video/uvc/uvcvideo.h
@@ -435,11 +435,8 @@ struct uvc_video_queue {
 	struct mutex mutex;	/* protects buffers and mainqueue */
 	spinlock_t irqlock;	/* protects irqqueue */
 
-    wait_queue_head_t wait; /* wait if mainqueue is empty */
-
 	struct list_head mainqueue;
 	struct list_head irqqueue;
-    
 };
 
 struct uvc_video_chain {
@@ -452,10 +449,7 @@ struct uvc_video_chain {
 
 	struct mutex ctrl_mutex;		/* Protects ctrl.info */
 };
-enum uvc_urb_state {
-    UrbActive,
-    UrbDeactive
-};
+
 struct uvc_streaming {
 	struct list_head list;
 	struct uvc_device *dev;
@@ -502,11 +496,6 @@ struct uvc_streaming {
 
 	__u32 sequence;
 	__u8 last_fid;
-
-    struct tasklet_struct *tasklet[UVC_URBS];     /* ddl@rock-chips.com */
-    atomic_t urb_state[UVC_URBS];
-    
-    unsigned int flags;
 };
 
 enum uvc_device_state {
diff --git a/drivers/media/video/v4l2-ioctl.c b/drivers/media/video/v4l2-ioctl.c
index 0348a5b6bbbf..bda252f04e8a 100644
--- a/drivers/media/video/v4l2-ioctl.c
+++ b/drivers/media/video/v4l2-ioctl.c
@@ -821,10 +821,10 @@ static long __video_do_ioctl(struct file *file,
 	case VIDIOC_S_FMT:
 	{
 		struct v4l2_format *f = (struct v4l2_format *)arg;
-		
+
 		/* FIXME: Should be one dump per type */
 		dbgarg(cmd, "type=%s\n", prt_names(f->type, v4l2_type_names));
-		
+
 		switch (f->type) {
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 			CLEAR_AFTER_FIELD(f, fmt.pix);
@@ -2252,7 +2252,7 @@ static unsigned long cmd_input_size(unsigned int cmd)
 		CMDINSIZE(ENCODER_CMD,		encoder_cmd,	flags);
 		CMDINSIZE(TRY_ENCODER_CMD,	encoder_cmd,	flags);
 		CMDINSIZE(G_SLICED_VBI_CAP,	sliced_vbi_cap,	type);
-		CMDINSIZE(ENUM_FRAMESIZES,	frmsizeenum,	reserved[1]);
+		CMDINSIZE(ENUM_FRAMESIZES,	frmsizeenum,	pixel_format);
 		CMDINSIZE(ENUM_FRAMEINTERVALS,	frmivalenum,	height);
 	default:
 		return _IOC_SIZE(cmd);
diff --git a/drivers/media/video/videobuf-core.c b/drivers/media/video/videobuf-core.c
index 5ea6fdbb56d8..de4fa4eb8844 100644
--- a/drivers/media/video/videobuf-core.c
+++ b/drivers/media/video/videobuf-core.c
@@ -107,11 +107,11 @@ int videobuf_waiton(struct videobuf_queue *q, struct videobuf_buffer *vb,
 	if (intr)
 		ret = wait_event_interruptible(vb->done, is_state_active_or_queued(q, vb));
 	else
-		wait_event(vb->done, is_state_active_or_queued(q, vb));    
+		wait_event(vb->done, is_state_active_or_queued(q, vb));
 	/* Relock */
 	if (is_ext_locked)
-		mutex_lock(q->ext_lock);    
-    
+		mutex_lock(q->ext_lock);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(videobuf_waiton);
@@ -334,7 +334,6 @@ static void videobuf_status(struct videobuf_queue *q, struct v4l2_buffer *b,
 		break;
 	case V4L2_MEMORY_OVERLAY:
 		b->m.offset  = vb->boff;
-		b->length    = vb->bsize;
 		break;
 	}
 
@@ -369,7 +368,6 @@ static void videobuf_status(struct videobuf_queue *q, struct v4l2_buffer *b,
 	b->timestamp = vb->ts;
 	b->bytesused = vb->size;
 	b->sequence  = vb->field_count >> 1;
-	b->reserved  = vb->rk_code;         /* ddl@rock-chips.com */
 }
 
 int videobuf_mmap_free(struct videobuf_queue *q)
@@ -643,7 +641,6 @@ EXPORT_SYMBOL_GPL(videobuf_qbuf);
 static int stream_next_buffer_check_queue(struct videobuf_queue *q, int noblock)
 {
 	int retval;
-    bool is_ext_locked;
 
 checks:
 	if (!q->streaming) {
@@ -660,28 +657,16 @@ static int stream_next_buffer_check_queue(struct videobuf_queue *q, int noblock)
 		} else {
 			dprintk(2, "next_buffer: waiting on buffer\n");
 
-			/* Drop lock to avoid deadlock with qbuf */            
-            videobuf_queue_unlock(q);
-            /*ddl@rock-chips.com */
-            is_ext_locked = q->ext_lock && mutex_is_locked(q->ext_lock);
-
-        	/* Release vdev lock to prevent this wait from blocking outside access to
-        	   the device. */
-        	if (is_ext_locked)
-        		mutex_unlock(q->ext_lock);
-            
-            
+			/* Drop lock to avoid deadlock with qbuf */
+			videobuf_queue_unlock(q);
+
 			/* Checking list_empty and streaming is safe without
 			 * locks because we goto checks to validate while
 			 * holding locks before proceeding */
 			retval = wait_event_interruptible(q->wait,
 				!list_empty(&q->stream) || !q->streaming);
+			videobuf_queue_lock(q);
 
-            videobuf_queue_lock(q);
-            /*ddl@rock-chips.com */
-            if (is_ext_locked)
-        		mutex_lock(q->ext_lock);
-            
 			if (retval)
 				goto done;
 
@@ -724,7 +709,7 @@ int videobuf_dqbuf(struct videobuf_queue *q,
 
 	MAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);
 
-	memset(b, 0, sizeof(*b));    
+	memset(b, 0, sizeof(*b));
 	videobuf_queue_lock(q);
 
 	retval = stream_next_buffer(q, &buf, nonblocking);
diff --git a/drivers/media/video/videobuf-dma-contig.c b/drivers/media/video/videobuf-dma-contig.c
index 3e2a085b6785..c9691115f2d2 100644
--- a/drivers/media/video/videobuf-dma-contig.c
+++ b/drivers/media/video/videobuf-dma-contig.c
@@ -248,7 +248,6 @@ static int __videobuf_iolock(struct videobuf_queue *q,
 			mem->vaddr, mem->size);
 		break;
 	case V4L2_MEMORY_OVERLAY:
-		break; /* ddl@rock-chips.com : nzy modify V4L2_MEMORY_OVERLAY   */
 	default:
 		dev_dbg(q->dev, "%s memory method OVERLAY/unknown\n",
 			__func__);
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index a384a7beb57c..6ca938a6bf94 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -171,37 +171,6 @@ config MFD_TPS6586X
 	  This driver can also be built as a module.  If so, the module
 	  will be called tps6586x.
 
-config MFD_TPS65910
-	bool "TPS65910 Power Management chip"
-	depends on I2C=y && GPIOLIB
-	select MFD_CORE
-	select GPIO_TPS65910
-	select REGMAP_I2C
-	help
-	  if you say yes here you get support for the TPS65910 series of
-	  Power Management chips.
-
-config MFD_TPS65912
-	bool
-	depends on GPIOLIB
-
-config MFD_TPS65912_I2C
-	bool "TPS65912 Power Management chip with I2C"
-	select MFD_CORE
-	select MFD_TPS65912
-	depends on I2C=y && GPIOLIB
-	help
-	  If you say yes here you get support for the TPS65912 series of
-	  PM chips with I2C interface.
-
-config MFD_TPS65912_SPI
-	bool "TPS65912 Power Management chip with SPI"
-	select MFD_CORE
-	select MFD_TPS65912
-	depends on SPI_MASTER && GPIOLIB
-	help
-	  If you say yes here you get support for the TPS65912 series of
-	  PM chips with SPI interface.
 config MENELAUS
 	bool "Texas Instruments TWL92330/Menelaus PM chip"
 	depends on I2C=y && ARCH_OMAP2
@@ -226,18 +195,6 @@ config TWL4030_CORE
 	  high speed USB OTG transceiver, an audio codec (on most
 	  versions) and many other features.
 
-config TWL6030_POWER
-	bool "Support power resources on TWL6030 family chips"
-	depends on TWL4030_CORE
-	help
-	  Say yes here if you want to use the power resources on the
-	  TWL6030 family chips.  Most of these resources are regulators,
-	  which have a separate driver; some are control signals, such
-	  as clock request handshaking.
-
-	  This driver defaults to assuming only APPs processor uses
-	  the resource, it can however be overridden by board file
-
 config TWL4030_MADC
 	tristate "Texas Instruments TWL4030 MADC"
 	depends on TWL4030_CORE
@@ -276,54 +233,6 @@ config TWL6030_PWM
 	  Say yes here if you want support for TWL6030 PWM.
 	  This is used to control charging LED brightness.
 
-config TWL6030_POWEROFF
-	bool "TWL6030 device poweroff"
-	depends on TWL4030_CORE
-
-config TWL6030_MADC
-	tristate "Texas Instruments TWL6030 MADC"
-	depends on TWL4030_CORE
-	help
-	This driver provides support for TWL6030-MADC. The
-	driver supports both RT and SW conversion methods.
-
-	This driver can be built as a module. If so it will be
-	named twl6030-madc
-
-config TWL6030_GPADC
-	tristate "TWL6030 GPADC (General Purpose A/D Convertor) Support"
-	depends on TWL4030_CORE
-	default n
-	help
-	  Say yes here if you want support for the TWL6030 General Purpose
-	  A/D Convertor.
-
-config MFD_RK808
-	bool "RK808 Power Management chip"
-	depends on I2C=y 
-	select MFD_CORE
-	select RTC_RK808
-	help
-	  if you say yes here you get support for the RK808 series of
-	  Power Management chips.
-
-config MFD_RICOH619
-	bool "Ricoh RC5T619 Power Management system device"
-	depends on I2C && GPIOLIB && GENERIC_HARDIRQS
-	select MFD_CORE
-	default n
-	help
-	  If you say yes here you get support for the RICOH619 Power
-	  Management system device.
-	  This driver provides common support for accessing the device,
-	  additional drivers must be enabled in order to use the
-	  functionality of the device.
-
-config AIC3262_CODEC
-	bool "Support TI Codec Aic3262"
-	select MFD_CORE
-	default n
-
 config MFD_STMPE
 	bool "Support STMicroelectronics STMPE"
 	depends on I2C=y && GENERIC_HARDIRQS
@@ -476,17 +385,6 @@ config MFD_WM831X_SPI
 	  for accessing the device, additional drivers must be enabled in
 	  order to use the functionality of the device.
 
-config MFD_WM831X_SPI_A22
-	bool "Support Wolfson Microelectronics WM831x/2x PMICs with SPI for A22"
-	#select MFD_CORE
-	#select MFD_WM831X
-	depends on SPI_MASTER && GENERIC_HARDIRQS
-	help
-	  Support for the Wolfson Microelecronics WM831x and WM832x PMICs
-	  when controlled using SPI.  This driver provides common support
-	  for accessing the device, additional drivers must be enabled in
-	  order to use the functionality of the device.
-
 config MFD_WM8350
 	bool
 	depends on GENERIC_HARDIRQS
@@ -821,86 +719,17 @@ config MFD_PM8XXX_IRQ
 	  This is required to use certain other PM 8xxx features, such as GPIO
 	  and MPP.
 
-config TPS65911_COMPARATOR
-	tristate
-
-config MFD_TPS65090
-	bool "TPS65090 Power Management chips"
-	depends on I2C=y && GENERIC_HARDIRQS
-	select MFD_CORE
-	select REGMAP_I2C
-	help
-	  If you say yes here you get support for the TPS65090 series of
-	  Power Management chips.
-	  This driver provides common support for accessing the device,
-	  additional drivers must be enabled in order to use the
-	  functionality of the device.
-	  
-config MFD_RT5025
-	bool "RT5025 PMIC Chip Core driver"
-	depends on I2C
-	select MFD_CORE
-	default n
-	help
-	  Enable RT5025 core driver.
-
-config MFD_RT5025_MISC
-	bool "RT5025 PMIC chip misc configuration"
-	depends on MFD_RT5025
-	default n
-	help
-	  Enable RT5025 Misc configuration.
-
-config MFD_RT5025_IRQ
-	bool "RT5025_PMIC chip irq driver"
-	depends on MFD_RT5025
-	default n
-	help
-	  Enable RT5025 IRQ configuration and interrupt.
-
-config MFD_RT5025_DEBUG
-	bool "RT5025 PMIC Chip Core Debug"
-	depends on MFD_RT5025 && DEBUG_FS
-	default n
-	help
-	  Enable RT5025 core debug driver.
-
-config MFD_RT_SHOW_INFO
-	bool "RT5025 debug message"
-	depends on MFD_RT5025
-	default n
-	help
-	  Eneable RT5025 debug message
-
-config MFD_RK610
-	bool "RK610(Jetta) Multimedia support"
+config MFD_TPS65910
+	bool "TPS65910 Power Management chip"
 	depends on I2C=y && GPIOLIB
 	select MFD_CORE
+	select GPIO_TPS65910
 	help
-	  if you say yes here you get support for the RK610, with func as
-	  HDMI LCD LVDS TVOUT CODEC.
-
-config MFD_RK616
-        bool "RK616(Jetta B) Multifunction device support"
-        depends on I2C=y 
-        select MFD_CORE
-        help
-          if you say yes here you get support for the RK616, with func as
-          HDMILCDLVDSCODECMIPI.
-
-config RK616_USE_MCLK_12M	
-	bool "Enable 12M clock for timing reconstruction"
-	depends on MFD_RK616
-	select RK_HDMI_CTL_CODEC
-	default y
-	help
-	   if you say y here ,it will enable 12M clock for timing reconstruction
+	  if you say yes here you get support for the TPS65910 series of
+	  Power Management chips.
 
-config RK616_DEBUG
-	bool "RK616(JettaB) debug enable"
-	depends on MFD_RK616
-	help
-	   if you say y here ,it will enable rk616 debug function
+config TPS65911_COMPARATOR
+	tristate
 
 endif # MFD_SUPPORT
 
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 02f319a24493..d7d47d2a4c76 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -26,7 +26,6 @@ wm831x-objs			:= wm831x-core.o wm831x-irq.o wm831x-otp.o
 obj-$(CONFIG_MFD_WM831X)	+= wm831x.o
 obj-$(CONFIG_MFD_WM831X_I2C)	+= wm831x-i2c.o
 obj-$(CONFIG_MFD_WM831X_SPI)	+= wm831x-spi.o
-obj-$(CONFIG_MFD_WM831X_SPI_A22)	+= wm831x-spi-a22.o
 wm8350-objs			:= wm8350-core.o wm8350-regmap.o wm8350-gpio.o
 wm8350-objs			+= wm8350-irq.o
 obj-$(CONFIG_MFD_WM8350)	+= wm8350.o
@@ -36,24 +35,13 @@ obj-$(CONFIG_MFD_WM8994)	+= wm8994-core.o wm8994-irq.o
 obj-$(CONFIG_TPS6105X)		+= tps6105x.o
 obj-$(CONFIG_TPS65010)		+= tps65010.o
 obj-$(CONFIG_TPS6507X)		+= tps6507x.o
-obj-$(CONFIG_MFD_TPS65910)	+= tps65910.o tps65910-irq.o
-tps65912-objs                   := tps65912-core.o tps65912-irq.o
-obj-$(CONFIG_MFD_TPS65912)	+= tps65912.o
-obj-$(CONFIG_MFD_TPS65912_I2C)	+= tps65912-i2c.o
-obj-$(CONFIG_MFD_TPS65912_SPI)  += tps65912-spi.o
 obj-$(CONFIG_MENELAUS)		+= menelaus.o
 
 obj-$(CONFIG_TWL4030_CORE)	+= twl-core.o twl4030-irq.o twl6030-irq.o
 obj-$(CONFIG_TWL4030_MADC)      += twl4030-madc.o
-obj-$(CONFIG_TWL6030_MADC)      += twl6030-madc.o
 obj-$(CONFIG_TWL4030_POWER)    += twl4030-power.o
 obj-$(CONFIG_TWL4030_CODEC)	+= twl4030-codec.o
 obj-$(CONFIG_TWL6030_PWM)	+= twl6030-pwm.o
-obj-$(CONFIG_TWL6030_GPADC)    += twl6030-gpadc.o
-obj-$(CONFIG_TWL6030_POWEROFF)	+= twl6030-poweroff.o
-obj-$(CONFIG_TWL6030_POWER)    += twl6030-power.o
-
-obj-$(CONFIG_AIC3262_CODEC)	+= tlv320aic3262-core.o tlv320aic3262-irq.o
 
 obj-$(CONFIG_MFD_MC13XXX)	+= mc13xxx-core.o
 
@@ -107,11 +95,3 @@ obj-$(CONFIG_MFD_PM8921_CORE) 	+= pm8921-core.o
 obj-$(CONFIG_MFD_PM8XXX_IRQ) 	+= pm8xxx-irq.o
 obj-$(CONFIG_MFD_TPS65910)	+= tps65910.o tps65910-irq.o
 obj-$(CONFIG_TPS65911_COMPARATOR)	+= tps65911-comparator.o
-obj-$(CONFIG_MFD_RK610)	+= rk610-core.o
-obj-$(CONFIG_MFD_RK808)	+= rk808.o rk808-irq.o
-obj-$(CONFIG_MFD_RK616) += rk616-core.o rk616-vif.o
-obj-$(CONFIG_MFD_RICOH619)	+= ricoh619.o ricoh619-irq.o
-obj-$(CONFIG_MFD_RT5025)	+= rt5025-i2c.o rt5025-core.o
-obj-$(CONFIG_MFD_RT5025_MISC)	+= rt5025-misc.o
-obj-$(CONFIG_MFD_RT5025_IRQ)	+= rt5025-irq.o
-obj-$(CONFIG_MFD_RT5025_DEBUG)	+= rt5025-debug.o
diff --git a/drivers/mfd/tps65910-irq.c b/drivers/mfd/tps65910-irq.c
index 1b781bfc93e5..a56be931551c 100644
--- a/drivers/mfd/tps65910-irq.c
+++ b/drivers/mfd/tps65910-irq.c
@@ -22,8 +22,6 @@
 #include <linux/irq.h>
 #include <linux/gpio.h>
 #include <linux/mfd/tps65910.h>
-#include <linux/wakelock.h>
-#include <linux/kthread.h>
 
 static inline int irq_to_tps65910_irq(struct tps65910 *tps65910,
 							int irq)
@@ -47,8 +45,7 @@ static irqreturn_t tps65910_irq(int irq, void *irq_data)
 	u32 irq_mask;
 	u8 reg;
 	int i;
-	
-	wake_lock(&tps65910->irq_wake);	
+
 	tps65910->read(tps65910, TPS65910_INT_STS, 1, &reg);
 	irq_sts = reg;
 	tps65910->read(tps65910, TPS65910_INT_STS2, 1, &reg);
@@ -72,10 +69,7 @@ static irqreturn_t tps65910_irq(int irq, void *irq_data)
 	irq_sts &= ~irq_mask;
 
 	if (!irq_sts)
-	{
-		wake_unlock(&tps65910->irq_wake);
 		return IRQ_NONE;
-	}
 
 	for (i = 0; i < tps65910->irq_num; i++) {
 
@@ -96,7 +90,7 @@ static irqreturn_t tps65910_irq(int irq, void *irq_data)
 		reg = irq_sts >> 8;
 		tps65910->write(tps65910, TPS65910_INT_STS3, 1, &reg);
 	}
-	wake_unlock(&tps65910->irq_wake);
+
 	return IRQ_HANDLED;
 }
 
@@ -151,23 +145,12 @@ static void tps65910_irq_disable(struct irq_data *data)
 	tps65910->irq_mask |= ( 1 << irq_to_tps65910_irq(tps65910, data->irq));
 }
 
-#ifdef CONFIG_PM_SLEEP
-static int tps65910_irq_set_wake(struct irq_data *data, unsigned int enable)
-{
-	struct tps65910 *tps65910 = irq_data_get_irq_chip_data(data);
-	return irq_set_irq_wake(tps65910->chip_irq, enable);
-}
-#else
-#define tps65910_irq_set_wake NULL
-#endif
-
 static struct irq_chip tps65910_irq_chip = {
 	.name = "tps65910",
 	.irq_bus_lock = tps65910_irq_lock,
 	.irq_bus_sync_unlock = tps65910_irq_sync_unlock,
 	.irq_disable = tps65910_irq_disable,
 	.irq_enable = tps65910_irq_enable,
-	.irq_set_wake = tps65910_irq_set_wake,
 };
 
 int tps65910_irq_init(struct tps65910 *tps65910, int irq,
@@ -175,36 +158,23 @@ int tps65910_irq_init(struct tps65910 *tps65910, int irq,
 {
 	int ret, cur_irq;
 	int flags = IRQF_ONESHOT;
-	u8 reg;
 
 	if (!irq) {
 		dev_warn(tps65910->dev, "No interrupt support, no core IRQ\n");
-		return 0;
+		return -EINVAL;
 	}
 
 	if (!pdata || !pdata->irq_base) {
 		dev_warn(tps65910->dev, "No interrupt support, no IRQ base\n");
-		return 0;
+		return -EINVAL;
 	}
 
-	/* Clear unattended interrupts */
-	tps65910->read(tps65910, TPS65910_INT_STS, 1, &reg);
-	tps65910->write(tps65910, TPS65910_INT_STS, 1, &reg);
-	tps65910->read(tps65910, TPS65910_INT_STS2, 1, &reg);
-	tps65910->write(tps65910, TPS65910_INT_STS2, 1, &reg);
-	tps65910->read(tps65910, TPS65910_INT_STS3, 1, &reg);
-	tps65910->write(tps65910, TPS65910_INT_STS3, 1, &reg);
-	tps65910->read(tps65910, TPS65910_RTC_STATUS, 1, &reg);	
-	tps65910->write(tps65910, TPS65910_RTC_STATUS, 1, &reg);//clear alarm and timer interrupt
-
-	/* Mask top level interrupts */
 	tps65910->irq_mask = 0xFFFFFF;
 
-	mutex_init(&tps65910->irq_lock);	
-	wake_lock_init(&tps65910->irq_wake, WAKE_LOCK_SUSPEND, "tps65910_irq_wake");
+	mutex_init(&tps65910->irq_lock);
 	tps65910->chip_irq = irq;
 	tps65910->irq_base = pdata->irq_base;
-	
+
 	switch (tps65910_chip_id(tps65910)) {
 	case TPS65910:
 		tps65910->irq_num = TPS65910_NUM_IRQ;
@@ -245,7 +215,6 @@ int tps65910_irq_init(struct tps65910 *tps65910, int irq,
 
 int tps65910_irq_exit(struct tps65910 *tps65910)
 {
-	if (tps65910->chip_irq)
-		free_irq(tps65910->chip_irq, tps65910);
+	free_irq(tps65910->chip_irq, tps65910);
 	return 0;
 }
diff --git a/drivers/mfd/tps65910.c b/drivers/mfd/tps65910.c
index 5c279a0a02c3..2229e66d80db 100644
--- a/drivers/mfd/tps65910.c
+++ b/drivers/mfd/tps65910.c
@@ -22,8 +22,6 @@
 #include <linux/mfd/core.h>
 #include <linux/mfd/tps65910.h>
 
-struct tps65910 *g_tps65910;
-
 static struct mfd_cell tps65910s[] = {
 	{
 		.name = "tps65910-pmic",
@@ -36,7 +34,6 @@ static struct mfd_cell tps65910s[] = {
 	},
 };
 
-#define TPS65910_SPEED 	200 * 1000
 
 static int tps65910_i2c_read(struct tps65910 *tps65910, u8 reg,
 				  int bytes, void *dest)
@@ -44,30 +41,25 @@ static int tps65910_i2c_read(struct tps65910 *tps65910, u8 reg,
 	struct i2c_client *i2c = tps65910->i2c_client;
 	struct i2c_msg xfer[2];
 	int ret;
-	//int i;
 
 	/* Write register */
 	xfer[0].addr = i2c->addr;
 	xfer[0].flags = 0;
 	xfer[0].len = 1;
 	xfer[0].buf = &reg;
-	xfer[0].scl_rate = TPS65910_SPEED;
 
 	/* Read data */
 	xfer[1].addr = i2c->addr;
 	xfer[1].flags = I2C_M_RD;
 	xfer[1].len = bytes;
 	xfer[1].buf = dest;
-	xfer[1].scl_rate = TPS65910_SPEED;
 
 	ret = i2c_transfer(i2c->adapter, xfer, 2);
-	//for(i=0;i<bytes;i++)
-	//printk("%s:reg=0x%x,value=0x%x\n",__func__,reg+i,*(u8 *)dest++);
 	if (ret == 2)
 		ret = 0;
 	else if (ret >= 0)
 		ret = -EIO;
-	
+
 	return ret;
 }
 
@@ -78,145 +70,20 @@ static int tps65910_i2c_write(struct tps65910 *tps65910, u8 reg,
 	/* we add 1 byte for device register */
 	u8 msg[TPS65910_MAX_REGISTER + 1];
 	int ret;
-	//int i;
-	
+
 	if (bytes > TPS65910_MAX_REGISTER)
 		return -EINVAL;
-	
+
 	msg[0] = reg;
 	memcpy(&msg[1], src, bytes);
 
-	//for(i=0;i<bytes;i++)
-	//printk("%s:reg=0x%x,value=0x%x\n",__func__,reg+i,msg[i+1]);
-	
-	ret = i2c_master_normal_send(i2c, msg, bytes + 1,TPS65910_SPEED);
+	ret = i2c_master_send(i2c, msg, bytes + 1);
 	if (ret < 0)
 		return ret;
 	if (ret != bytes + 1)
 		return -EIO;
-
-	return 0;
-}
-
-static inline int tps65910_read(struct tps65910 *tps65910, u8 reg)
-{
-	u8 val;
-	int err;
-
-	err = tps65910->read(tps65910, reg, 1, &val);
-	if (err < 0)
-		return err;
-
-	return val;
-}
-
-static inline int tps65910_write(struct tps65910 *tps65910, u8 reg, u8 val)
-{
-	return tps65910->write(tps65910, reg, 1, &val);
-}
-
-int tps65910_reg_read(struct tps65910 *tps65910, u8 reg)
-{
-	int data;
-
-	mutex_lock(&tps65910->io_mutex);
-
-	data = tps65910_read(tps65910, reg);
-	if (data < 0)
-		dev_err(tps65910->dev, "Read from reg 0x%x failed\n", reg);
-
-	mutex_unlock(&tps65910->io_mutex);
-	return data;
-}
-EXPORT_SYMBOL_GPL(tps65910_reg_read);
-
-int tps65910_reg_write(struct tps65910 *tps65910, u8 reg, u8 val)
-{
-	int err;
-
-	mutex_lock(&tps65910->io_mutex);
-
-	err = tps65910_write(tps65910, reg, val);
-	if (err < 0)
-		dev_err(tps65910->dev, "Write for reg 0x%x failed\n", reg);
-
-	mutex_unlock(&tps65910->io_mutex);
-	return err;
-}
-EXPORT_SYMBOL_GPL(tps65910_reg_write);
-
-/**
- * tps65910_bulk_read: Read multiple tps65910 registers
- *
- * @tps65910: Device to read from
- * @reg: First register
- * @count: Number of registers
- * @buf: Buffer to fill.
- */
-int tps65910_bulk_read(struct tps65910 *tps65910, u8 reg,
-		     int count, u8 *buf)
-{
-	int ret;
-                    
-#if defined(CONFIG_MFD_RK610)    
-	int i;             //Solve communication conflict when rk610 and 65910 on the same i2c 
-
-	mutex_lock(&tps65910->io_mutex);
-	for(i=0; i<count; i++){
-		ret = tps65910_read(tps65910, reg+i);
-		if(ret < 0){
-			printk("%s: failed read reg 0x%0x, ret = %d\n", __FUNCTION__, reg+i, ret);
-			mutex_unlock(&tps65910->io_mutex);
-			return ret;
-		}else{
-			buf[i] = ret & 0x000000FF;
-		}
-	}
-	mutex_unlock(&tps65910->io_mutex);
-#else
-	mutex_lock(&tps65910->io_mutex);
-	
-	ret = tps65910->read(tps65910, reg, count, buf);
-
-	mutex_unlock(&tps65910->io_mutex);
-#endif
-	return 0;
-
-}
-EXPORT_SYMBOL_GPL(tps65910_bulk_read);
-
-int tps65910_bulk_write(struct tps65910 *tps65910, u8 reg,
-		     int count, u8 *buf)
-{
-	int ret;
-	
-#if defined(CONFIG_MFD_RK610)    
-	int i;       // //Solve communication conflict when rk610 and 65910 on the same i2c 
-
-	mutex_lock(&tps65910->io_mutex);
-	for(i=0; i<count; i++){
-		ret = tps65910_write(tps65910, reg+i, buf[i]);
-		if(ret < 0){
-			printk("%s: failed write reg=0x%0x, val=0x%0x, ret = %d\n", __FUNCTION__, reg+i, buf[i], ret);
-			mutex_unlock(&tps65910->io_mutex);
-			return ret;
-		}
-	}
-	mutex_unlock(&tps65910->io_mutex);
-#else
-	mutex_lock(&tps65910->io_mutex);
-	
-	ret = tps65910->write(tps65910, reg, count, buf);
-
-	mutex_unlock(&tps65910->io_mutex);
-#endif
 	return 0;
-
 }
-EXPORT_SYMBOL_GPL(tps65910_bulk_write);
-
-
-
 
 int tps65910_set_bits(struct tps65910 *tps65910, u8 reg, u8 mask)
 {
@@ -226,14 +93,14 @@ int tps65910_set_bits(struct tps65910 *tps65910, u8 reg, u8 mask)
 	mutex_lock(&tps65910->io_mutex);
 	err = tps65910_i2c_read(tps65910, reg, 1, &data);
 	if (err) {
-		dev_err(tps65910->dev, "%s:read from reg %x failed\n", __func__,reg);
+		dev_err(tps65910->dev, "read from reg %x failed\n", reg);
 		goto out;
 	}
 
 	data |= mask;
 	err = tps65910_i2c_write(tps65910, reg, 1, &data);
 	if (err)
-		dev_err(tps65910->dev, "%s:write to reg %x failed\n", __func__,reg);
+		dev_err(tps65910->dev, "write to reg %x failed\n", reg);
 
 out:
 	mutex_unlock(&tps65910->io_mutex);
@@ -253,7 +120,7 @@ int tps65910_clear_bits(struct tps65910 *tps65910, u8 reg, u8 mask)
 		goto out;
 	}
 
-	data &= ~mask;
+	data &= mask;
 	err = tps65910_i2c_write(tps65910, reg, 1, &data);
 	if (err)
 		dev_err(tps65910->dev, "write to reg %x failed\n", reg);
@@ -271,7 +138,7 @@ static int tps65910_i2c_probe(struct i2c_client *i2c,
 	struct tps65910_board *pmic_plat_data;
 	struct tps65910_platform_data *init_data;
 	int ret = 0;
-	
+
 	pmic_plat_data = dev_get_platdata(&i2c->dev);
 	if (!pmic_plat_data)
 		return -EINVAL;
@@ -281,7 +148,7 @@ static int tps65910_i2c_probe(struct i2c_client *i2c,
 		return -ENOMEM;
 
 	init_data->irq = pmic_plat_data->irq;
-	init_data->irq_base = pmic_plat_data->irq_base;
+	init_data->irq_base = pmic_plat_data->irq;
 
 	tps65910 = kzalloc(sizeof(struct tps65910), GFP_KERNEL);
 	if (tps65910 == NULL)
@@ -301,37 +168,12 @@ static int tps65910_i2c_probe(struct i2c_client *i2c,
 	if (ret < 0)
 		goto err;
 
-	ret = tps65910_reg_read(tps65910,0x22);
-	if ((ret < 0) || (ret == 0xff)){
-		printk("The device is not tps65910\n");
-		goto err;
-	}
-	
-	g_tps65910 = tps65910;
-	
-	if (pmic_plat_data && pmic_plat_data->pre_init) {
-		ret = pmic_plat_data->pre_init(tps65910);
-		if (ret != 0) {
-			dev_err(tps65910->dev, "pre_init() failed: %d\n", ret);
-			goto err;
-		}
-	}
-
 	tps65910_gpio_init(tps65910, pmic_plat_data->gpio_base);
 
 	ret = tps65910_irq_init(tps65910, init_data->irq, init_data);
 	if (ret < 0)
 		goto err;
 
-	if (pmic_plat_data && pmic_plat_data->post_init) {
-		ret = pmic_plat_data->post_init(tps65910);
-		if (ret != 0) {
-			dev_err(tps65910->dev, "post_init() failed: %d\n", ret);
-			goto err;
-		}
-	}
-
-	printk("%s:irq=%d,irq_base=%d,gpio_base=%d\n",__func__,init_data->irq,init_data->irq_base,pmic_plat_data->gpio_base);
 	return ret;
 
 err:
@@ -340,36 +182,6 @@ static int tps65910_i2c_probe(struct i2c_client *i2c,
 	return ret;
 }
 
-
-int tps65910_device_shutdown(void)
-{
-	int val = 0;
-	int err = -1;
-	struct tps65910 *tps65910 = g_tps65910;
-	
-	printk("%s\n",__func__);
-
-	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL);
-        if (val<0) {
-                printk(KERN_ERR "Unable to read TPS65910_REG_DCDCCTRL reg\n");
-                return -EIO;
-        }
-	
-	val |= DEVCTRL_DEV_OFF_MASK;
-	val &= ~DEVCTRL_CK32K_CTRL_MASK;	//keep rtc
-	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
-	if (err) {
-		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
-				\n", TPS65910_REG_VDIG1);
-		return err;
-	}
-	
-	return 0;	
-}
-EXPORT_SYMBOL_GPL(tps65910_device_shutdown);
-
-
-
 static int tps65910_i2c_remove(struct i2c_client *i2c)
 {
 	struct tps65910 *tps65910 = i2c_get_clientdata(i2c);
@@ -403,7 +215,7 @@ static int __init tps65910_i2c_init(void)
 	return i2c_add_driver(&tps65910_i2c_driver);
 }
 /* init early so consumer devices can complete system boot */
-subsys_initcall_sync(tps65910_i2c_init);
+subsys_initcall(tps65910_i2c_init);
 
 static void __exit tps65910_i2c_exit(void)
 {
diff --git a/drivers/mfd/twl-core.c b/drivers/mfd/twl-core.c
index 3dedd5a0df15..f82413a98895 100644
--- a/drivers/mfd/twl-core.c
+++ b/drivers/mfd/twl-core.c
@@ -33,18 +33,11 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/err.h>
-#include <linux/interrupt.h>
 
 #include <linux/regulator/machine.h>
 
 #include <linux/i2c.h>
 #include <linux/i2c/twl.h>
-#include "twl-core.h"
-
-#include <linux/earlysuspend.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static struct early_suspend twl60xx_early_suspend;
-#endif
 
 #if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)
 #include <plat/cpu.h>
@@ -90,13 +83,7 @@ static struct early_suspend twl60xx_early_suspend;
 #define twl_has_madc()	false
 #endif
 
-#if defined(CONFIG_TWL6030_GPADC) || defined(CONFIG_TWL6030_GPADC_MODULE)
-#define twl_has_gpadc()	true
-#else
-#define twl_has_gpadc()	false
-#endif
-
-#if defined(CONFIG_TWL4030_POWER) || defined(CONFIG_TWL6030_POWER)
+#ifdef CONFIG_TWL4030_POWER
 #define twl_has_power()        true
 #else
 #define twl_has_power()        false
@@ -129,10 +116,7 @@ static struct early_suspend twl60xx_early_suspend;
 #define twl_has_codec()	false
 #endif
 
-#if defined(CONFIG_CHARGER_TWL4030) || \
-	defined(CONFIG_CHARGER_TWL4030_MODULE) || \
-	defined(CONFIG_TWL6030_BCI_BATTERY) || \
-	defined(CONFIG_TWL6030_BCI_BATTERY_MODULE)
+#if defined(CONFIG_CHARGER_TWL4030) || defined(CONFIG_CHARGER_TWL4030_MODULE)
 #define twl_has_bci()	true
 #else
 #define twl_has_bci()	false
@@ -142,8 +126,7 @@ static struct early_suspend twl60xx_early_suspend;
 
 /* Last - for index max*/
 #define TWL4030_MODULE_LAST		TWL4030_MODULE_SECURED_REG
-//#define TWL6030_MODULE_LAST		TWL6030_MODULE_SLAVE_RES  //xsf
-#define TWL6030_MODULE_LAST		TWL_MODULE_PM_DVS //add
+
 #define TWL_NUM_SLAVES		4
 
 #if defined(CONFIG_INPUT_TWL4030_PWRBUTTON) \
@@ -153,19 +136,12 @@ static struct early_suspend twl60xx_early_suspend;
 #define twl_has_pwrbutton()	false
 #endif
 
-#if defined(CONFIG_INPUT_TWL6030_PWRBUTTON) \
-	|| defined(CONFIG_INPUT_TWL6030_PWRBUTTON_MODULE)
-#define twl6030_has_pwrbutton()        true
-#else
-#define twl6030_has_pwrbutton()        false
-#endif
-
 #define SUB_CHIP_ID0 0
 #define SUB_CHIP_ID1 1
 #define SUB_CHIP_ID2 2
 #define SUB_CHIP_ID3 3
-#define SUB_DVS_ID     3            //add
-#define TWL_MODULE_LAST TWL6030_MODULE_LAST
+
+#define TWL_MODULE_LAST TWL4030_MODULE_LAST
 
 /* Base Address defns for twl4030_map[] */
 
@@ -211,7 +187,6 @@ static struct early_suspend twl60xx_early_suspend;
 #define TWL6030_BASEADD_MEM		0x0017
 #define TWL6030_BASEADD_PM_MASTER	0x001F
 #define TWL6030_BASEADD_PM_SLAVE_MISC	0x0030 /* PM_RECEIVER */
-#define TWL6030_BASEADD_PM_SLAVE_RES	0x00AD
 #define TWL6030_BASEADD_PM_MISC		0x00E2
 #define TWL6030_BASEADD_PM_PUPD		0x00F0
 
@@ -223,7 +198,7 @@ static struct early_suspend twl60xx_early_suspend;
 #define TWL6030_BASEADD_GASGAUGE	0x00C0
 #define TWL6030_BASEADD_PIH		0x00D0
 #define TWL6030_BASEADD_CHARGER		0x00E0
-#define TWL6032_BASEADD_CHARGER		0x00DA
+#define TWL6025_BASEADD_CHARGER		0x00DA
 
 /* subchip/slave 2 0x4A - DFT */
 #define TWL6030_BASEADD_DIEID		0x00C0
@@ -250,13 +225,6 @@ static struct early_suspend twl60xx_early_suspend;
 #define TWL5031			BIT(2)  /* twl5031 has different registers */
 #define TWL6030_CLASS		BIT(3)	/* TWL6030 class */
 
-/* need to access USB_PRODUCT_ID_LSB to identify which 6030 varient we are */
-#define USB_PRODUCT_ID_LSB	0x02
-
-/* need to check eeprom revision and jtagver number */
-#define TWL6030_REG_EPROM_REV	0xdf
-#define TWL6030_REG_JTAGVERNUM	0x87
-
 /*----------------------------------------------------------------------*/
 
 /* is driver active, bound to a chip? */
@@ -364,11 +332,7 @@ static struct twl_mapping twl6030_map[] = {
 
 	{ SUB_CHIP_ID0, TWL6030_BASEADD_RTC },
 	{ SUB_CHIP_ID0, TWL6030_BASEADD_MEM },
-	{ SUB_CHIP_ID1, TWL6032_BASEADD_CHARGER },
-	{ SUB_CHIP_ID0, TWL6030_BASEADD_PM_SLAVE_RES },
-	{ SUB_DVS_ID, TWL6030_BASEADD_PM_SLAVE_MISC }, //add
-	
-
+	{ SUB_CHIP_ID1, TWL6025_BASEADD_CHARGER },
 };
 
 /*----------------------------------------------------------------------*/
@@ -411,25 +375,10 @@ int twl_i2c_write(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes)
 	 * fill the data Tx buffer
 	 */
 	msg = &twl->xfer_msg[0];
-	#if 1    
-	//add
-	if(mod_no== TWL_MODULE_PM_DVS)
-		{
-		msg->addr = 0x12;
-	}
-	else
-		{
 	msg->addr = twl->address;
-
-		}
-	#else
-	msg->addr = twl->address;
-	#endif
-
 	msg->len = num_bytes + 1;
 	msg->flags = 0;
 	msg->buf = value;
-	msg->scl_rate = 100*1000;  //add
 	/* over write the first byte of buffer with the register address */
 	*value = twl_map[mod_no].base + reg;
 	ret = i2c_transfer(twl->client->adapter, twl->xfer_msg, 1);
@@ -437,9 +386,8 @@ int twl_i2c_write(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes)
 
 	/* i2c_transfer returns number of messages transferred */
 	if (ret != 1) {
-		pr_err("%s: i2c_write failed to transfer all messages "
-			"(addr 0x%04x, reg %d, len %d)\n",
-			DRIVER_NAME, twl->address, reg, msg->len);
+		pr_err("%s: i2c_write failed to transfer all messages\n",
+			DRIVER_NAME);
 		if (ret < 0)
 			return ret;
 		else
@@ -466,6 +414,7 @@ int twl_i2c_read(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes)
 	int sid;
 	struct twl_client *twl;
 	struct i2c_msg *msg;
+
 	if (unlikely(mod_no > TWL_MODULE_LAST)) {
 		pr_err("%s: invalid module number %d\n", DRIVER_NAME, mod_no);
 		return -EPERM;
@@ -480,24 +429,11 @@ int twl_i2c_read(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes)
 	mutex_lock(&twl->xfer_lock);
 	/* [MSG1] fill the register address data */
 	msg = &twl->xfer_msg[0];
-	#if 1    
-	if(mod_no== 0x1a)
-		{
-		msg->addr = 0x12;
-	}
-	else
-		{
 	msg->addr = twl->address;
-
-		}
-	#else
-	msg->addr = twl->address;
-	#endif
 	msg->len = 1;
 	msg->flags = 0;	/* Read the register value */
 	val = twl_map[mod_no].base + reg;
 	msg->buf = &val;
-	msg->scl_rate = 100*1000;  //add
 	/* [MSG2] fill the data rx buffer */
 	msg = &twl->xfer_msg[1];
 	msg->addr = twl->address;
@@ -509,9 +445,8 @@ int twl_i2c_read(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes)
 
 	/* i2c_transfer returns number of messages transferred */
 	if (ret != 2) {
-		pr_err("%s: i2c_read failed to transfer all messages "
-			"(addr 0x%04x, reg %d, len %d)\n",
-			DRIVER_NAME, twl->address, reg, msg->len);
+		pr_err("%s: i2c_read failed to transfer all messages\n",
+			DRIVER_NAME);
 		if (ret < 0)
 			return ret;
 		else
@@ -535,20 +470,6 @@ int twl_i2c_write_u8(u8 mod_no, u8 value, u8 reg)
 
 	/* 2 bytes offset 1 contains the data offset 0 is used by i2c_write */
 	u8 temp_buffer[2] = { 0 };
-	
-	#if 0               //add
-	if(mod_no == 0x1a)
-	{
-		temp_buffer[1] = 0x43;
-		 twl_i2c_write(mod_no, temp_buffer, 0x25, 1);
-
-	 	temp_buffer[1] = 0x07;
-		twl_i2c_write(mod_no, temp_buffer, reg, 1);	
-
-	}
-	
-	#endif
-
 	/* offset 1 contains the data */
 	temp_buffer[1] = value;
 	return twl_i2c_write(mod_no, temp_buffer, reg, 1);
@@ -631,6 +552,7 @@ add_numbered_child(unsigned chip, const char *name, int num,
 	struct platform_device	*pdev;
 	struct twl_client	*twl = &twl_modules[chip];
 	int			status;
+
 	pdev = platform_device_alloc(name, num);
 	if (!pdev) {
 		dev_dbg(&twl->client->dev, "can't alloc dev\n");
@@ -711,9 +633,6 @@ add_regulator(int num, struct regulator_init_data *pdata,
 	return add_regulator_linked(num, pdata, NULL, 0, features);
 }
 
-#define SET_LDO_STATE_MEM(ldo, state) \
-	ldo->constraints.state_mem.disabled = state
-
 /*
  * NOTE:  We know the first 8 IRQs after pdata->base_irq are
  * for the PIH, and the next are for the PWR_INT SIH, since
@@ -725,8 +644,6 @@ add_children(struct twl4030_platform_data *pdata, unsigned long features)
 {
 	struct device	*child;
 	unsigned sub_chip_id;
-	u8 eepromrev = 0;
-	u8 twlrev = 0;
 
 	if (twl_has_gpio() && pdata->gpio) {
 		child = add_child(SUB_CHIP_ID1, "twl4030_gpio",
@@ -743,15 +660,6 @@ add_children(struct twl4030_platform_data *pdata, unsigned long features)
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 	}
-	if (twl_has_bci() && pdata->bci) {
-		pdata->bci->features = features;
-		child = add_child(1, "twl6030_bci",
-				pdata->bci, sizeof(*pdata->bci),
-				false,
-				pdata->irq_base + CHARGER_INTR_OFFSET,
-				pdata->irq_base + CHARGERFAULT_INTR_OFFSET);
-	}
-
 
 	if (twl_has_madc() && pdata->madc) {
 		child = add_child(2, "twl4030_madc",
@@ -761,16 +669,6 @@ add_children(struct twl4030_platform_data *pdata, unsigned long features)
 			return PTR_ERR(child);
 	}
 
-	if (twl_has_gpadc() && pdata->madc) {
-		pdata->madc->features = features;
-		child = add_child(1, "twl6030_gpadc",
-				pdata->madc, sizeof(*pdata->madc),
-				true, pdata->irq_base + MADC_INTR_OFFSET,
-				pdata->irq_base + GPADCSW_INTR_OFFSET);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-	}
-
 	if (twl_has_rtc()) {
 		/*
 		 * REVISIT platform_data here currently might expose the
@@ -852,23 +750,28 @@ add_children(struct twl4030_platform_data *pdata, unsigned long features)
 
 		static struct regulator_consumer_supply usb3v3;
 		int regulator;
+
 		if (twl_has_regulator()) {
-			if (features & TWL6032_SUBCLASS) {
+			/* this is a template that gets copied */
+			struct regulator_init_data usb_fixed = {
+				.constraints.valid_modes_mask =
+					REGULATOR_MODE_NORMAL
+					| REGULATOR_MODE_STANDBY,
+				.constraints.valid_ops_mask =
+					REGULATOR_CHANGE_MODE
+					| REGULATOR_CHANGE_STATUS,
+			};
+
+			if (features & TWL6025_SUBCLASS) {
 				usb3v3.supply =	"ldousb";
-				regulator = TWL6032_REG_LDOUSB;
-				child = add_regulator_linked(regulator,
-							     pdata->ldousb,
-							     &usb3v3, 1,
-							     features);
+				regulator = TWL6025_REG_LDOUSB;
 			} else {
 				usb3v3.supply = "vusb";
 				regulator = TWL6030_REG_VUSB;
-				child = add_regulator_linked(regulator,
-							     pdata->vusb,
-							     &usb3v3, 1,
-							     features);
 			}
-
+			child = add_regulator_linked(regulator, &usb_fixed,
+							&usb3v3, 1,
+							features);
 			if (IS_ERR(child))
 				return PTR_ERR(child);
 		}
@@ -888,8 +791,8 @@ add_children(struct twl4030_platform_data *pdata, unsigned long features)
 		if (twl_has_regulator() && child)
 			usb3v3.dev = child;
 	} else if (twl_has_regulator() && twl_class_is_6030()) {
-		if (features & TWL6032_SUBCLASS)
-			child = add_regulator(TWL6032_REG_LDOUSB,
+		if (features & TWL6025_SUBCLASS)
+			child = add_regulator(TWL6025_REG_LDOUSB,
 						pdata->ldousb, features);
 		else
 			child = add_regulator(TWL6030_REG_VUSB,
@@ -912,13 +815,6 @@ add_children(struct twl4030_platform_data *pdata, unsigned long features)
 			return PTR_ERR(child);
 	}
 
-	if (twl6030_has_pwrbutton()) {
-		child = add_child(1, "twl6030_pwrbutton",
-				NULL, 0, true, pdata->irq_base, 0);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-	}
-
 	if (twl_has_codec() && pdata->codec && twl_class_is_4030()) {
 		sub_chip_id = twl_map[TWL_MODULE_AUDIO_VOICE].sid;
 		child = add_child(sub_chip_id, "twl4030-audio",
@@ -931,7 +827,7 @@ add_children(struct twl4030_platform_data *pdata, unsigned long features)
 	/* Phoenix codec driver is probed directly atm */
 	if (twl_has_codec() && pdata->codec && twl_class_is_6030()) {
 		sub_chip_id = twl_map[TWL_MODULE_AUDIO_VOICE].sid;
-		child = add_child(sub_chip_id, "twl6040-audio",
+		child = add_child(sub_chip_id, "twl6040-codec",
 				pdata->codec, sizeof(*pdata->codec),
 				false, 0, 0);
 		if (IS_ERR(child))
@@ -1027,36 +923,9 @@ add_children(struct twl4030_platform_data *pdata, unsigned long features)
 			return PTR_ERR(child);
 	}
 
-	if (twl_has_regulator() && twl_class_is_6030()) {
-		/*
-		 * For TWL6032 revision < ES1.1 with EEPROM revision < rev56.0
-		 * LDO6 and LDOLN must be always ON
-		 * if LDO6 or LDOLN is always on then SYSEN must be always on
-		 * for TWL6030 or TWL6032 revision >= ES1.1 with EEPROM
-		 * revision >= rev56.0 those LDOs can be off in sleep-mode
-		 */
-		if (features & TWL6032_SUBCLASS) {
-			twl_i2c_read_u8(TWL6030_MODULE_ID2, &eepromrev,
-					TWL6030_REG_EPROM_REV);
-
-			twl_i2c_read_u8(TWL6030_MODULE_ID2, &twlrev,
-					TWL6030_REG_JTAGVERNUM);
-
-			if ((eepromrev < 56) && (twlrev < 1)) {
-				SET_LDO_STATE_MEM(pdata->ldo6, false);
-				SET_LDO_STATE_MEM(pdata->ldoln, false);
-				SET_LDO_STATE_MEM(pdata->sysen, false);
-				WARN(1, "This TWL6032 is an older revision that "
-						"does not support low power "
-						"measurements\n");
-			}
-		}
-	}
-
 	/* twl6030 regulators */
 	if (twl_has_regulator() && twl_class_is_6030() &&
-			!(features & TWL6032_SUBCLASS)) {
-			
+			!(features & TWL6025_SUBCLASS)) {
 		child = add_regulator(TWL6030_REG_VMMC, pdata->vmmc,
 					features);
 		if (IS_ERR(child))
@@ -1097,137 +966,82 @@ add_children(struct twl4030_platform_data *pdata, unsigned long features)
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6030_REG_VDD1, pdata->vdd1,
-					features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-
-		child = add_regulator(TWL6030_REG_VDD2, pdata->vdd2,
-					features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-
-		child = add_regulator(TWL6030_REG_VDD3, pdata->vdd3,
-					features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-
-		child = add_regulator(TWL6030_REG_VMEM, pdata->vmem,
+		child = add_regulator(TWL6030_REG_CLK32KG, pdata->clk32kg,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
-
-		child = add_regulator(TWL6030_REG_V2V1, pdata->v2v1,
-					features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);	
 	}
 
-	/* 6030 and 6032 share this regulator */
+	/* 6030 and 6025 share this regulator */
 	if (twl_has_regulator() && twl_class_is_6030()) {
 		child = add_regulator(TWL6030_REG_VANA, pdata->vana,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
-		child = add_regulator(TWL6030_REG_CLK32KG, pdata->clk32kg,
-					features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-
-		child = add_regulator(TWL6030_REG_CLK32KAUDIO,
-				pdata->clk32kaudio, features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-
-		child = add_regulator(TWL6030_REG_SYSEN,
-				pdata->sysen, features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-
-		child = add_regulator(TWL6030_REG_REGEN1,
-				pdata->sysen, features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-			
 	}
 
-	/* twl6032 regulators */
+	/* twl6025 regulators */
 	if (twl_has_regulator() && twl_class_is_6030() &&
-			(features & TWL6032_SUBCLASS)) {
-		child = add_regulator(TWL6032_REG_LDO5, pdata->ldo5,
-					features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-	
-		child = add_regulator(TWL6032_REG_LDO1, pdata->ldo1,
-					features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-	
-		child = add_regulator(TWL6032_REG_LDO7, pdata->ldo7,
+			(features & TWL6025_SUBCLASS)) {
+		child = add_regulator(TWL6025_REG_LDO5, pdata->ldo5,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6032_REG_LDO6, pdata->ldo6,
+		child = add_regulator(TWL6025_REG_LDO1, pdata->ldo1,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6032_REG_LDOLN, pdata->ldoln,
+		child = add_regulator(TWL6025_REG_LDO7, pdata->ldo7,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6032_REG_LDO2, pdata->ldo2,
+		child = add_regulator(TWL6025_REG_LDO6, pdata->ldo6,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6032_REG_LDO4, pdata->ldo4,
+		child = add_regulator(TWL6025_REG_LDOLN, pdata->ldoln,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6032_REG_LDO3, pdata->ldo3,
+		child = add_regulator(TWL6025_REG_LDO2, pdata->ldo2,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6032_REG_SMPS3, pdata->smps3,
+		child = add_regulator(TWL6025_REG_LDO4, pdata->ldo4,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6032_REG_SMPS4, pdata->smps4,
+		child = add_regulator(TWL6025_REG_LDO3, pdata->ldo3,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6032_REG_SMPS1, pdata->smps1,
+		child = add_regulator(TWL6025_REG_SMPS3, pdata->smps3,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-		child = add_regulator(TWL6032_REG_SMPS2, pdata->smps2,
-					features);
-		if (IS_ERR(child))
-			return PTR_ERR(child);
-		
-		child = add_regulator(TWL6032_REG_SMPS5, pdata->smps5,
+		child = add_regulator(TWL6025_REG_SMPS4, pdata->smps4,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
 
-
-		child = add_regulator(TWL6032_REG_VIO, pdata->vio6032,
+		child = add_regulator(TWL6025_REG_VIO, pdata->vio6025,
 					features);
 		if (IS_ERR(child))
 			return PTR_ERR(child);
+
 	}
 
 	if (twl_has_bci() && pdata->bci &&
-			!(features & (TPS_SUBSET | TWL5031)) && (features & TWL6030_CLASS)) {
+			!(features & (TPS_SUBSET | TWL5031))) {
 		child = add_child(3, "twl4030_bci",
 				pdata->bci, sizeof(*pdata->bci), false,
 				/* irq0 = CHG_PRES, irq1 = BCI */
@@ -1332,36 +1146,13 @@ static void clocks_init(struct device *dev,
 
 /*----------------------------------------------------------------------*/
 
-#ifdef CONFIG_PM
-static int twl_suspend(struct i2c_client *client, pm_message_t mesg)
-{		
-	twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,0x1a,SMPS4_CFG_VOLTAGE);//dc4 vcc_io is 2.8v in sleep mode
-	twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,0x01,LDO4_CFG_VOLTAGE);//ld4 vdd_11 is 1v in sleep mode
-	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0x20,SMPS1_CFG_VOLTAGE);
-	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0xe0,SMPS1_CFG_FORCE);//dc1 vdd_arm is 1v in sleep mode
-	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0x20,SMPS2_CFG_VOLTAGE);
-	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0xe0,SMPS2_CFG_FORCE);//dc2 vdd_logic is 1v in sleep mode
-	return irq_set_irq_wake(client->irq, 1);
-}
-
-static int twl_resume(struct i2c_client *client)
-{
-	//	return irq_set_irq_wake(client->irq, 0);
-	irq_set_irq_wake(client->irq, 0);
-	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0x28,SMPS1_CFG_VOLTAGE);
-	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0xe8,SMPS1_CFG_FORCE);
-	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0x28,SMPS2_CFG_VOLTAGE);
-	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0xe8,SMPS2_CFG_FORCE);
-	twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,0x02,LDO4_CFG_VOLTAGE);  
-	twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,0x1f,SMPS4_CFG_VOLTAGE);
-	return 0;
-}
-#else
-#define twl_suspend	NULL
-#define twl_resume	NULL
-#endif
+int twl4030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end);
+int twl4030_exit_irq(void);
+int twl4030_init_chip_irq(const char *chip);
+int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end);
+int twl6030_exit_irq(void);
 
-static int __devexit twl_remove(struct i2c_client *client)
+static int twl_remove(struct i2c_client *client)
 {
 	unsigned i;
 	int status;
@@ -1386,9 +1177,6 @@ static int __devexit twl_remove(struct i2c_client *client)
 }
 
 /* NOTE:  this driver only handles a single twl4030/tps659x0 chip */
-__weak void  twl60xx_pmu_early_suspend(struct regulator_dev *rdev) {}
-__weak void  twl60xx_pmu_early_resume(struct regulator_dev *rdev) {}
-
 static int __devinit
 twl_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
@@ -1396,35 +1184,27 @@ twl_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	unsigned			i;
 	struct twl4030_platform_data	*pdata = client->dev.platform_data;
 	u8 temp;
-	int ret = 0, features;
+	int ret = 0;
 
 	if (!pdata) {
-		dev_err(&client->dev, "no platform data?\n");
+		dev_dbg(&client->dev, "no platform data?\n");
 		return -EINVAL;
 	}
 
 	if (i2c_check_functionality(client->adapter, I2C_FUNC_I2C) == 0) {
-		dev_err(&client->dev, "can't talk I2C?\n");
+		dev_dbg(&client->dev, "can't talk I2C?\n");
 		return -EIO;
 	}
 
 	if (inuse) {
-		dev_err(&client->dev, "driver is already in use\n");
+		dev_dbg(&client->dev, "driver is already in use\n");
 		return -EBUSY;
 	}
 
 	for (i = 0; i < TWL_NUM_SLAVES; i++) {
 		struct twl_client	*twl = &twl_modules[i];
-	                     
-#if 0
+
 		twl->address = client->addr + i;
-#else
-		if( i <TWL_NUM_SLAVES-1 )
-			twl->address = client->addr + i;
-		else
-			twl->address = 0x12; //DVS i2s address
-#endif
-		
 		if (i == 0)
 			twl->client = client;
 		else {
@@ -1457,20 +1237,9 @@ twl_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		WARN(ret < 0, "Error: reading twl_idcode register value\n");
 	}
 
-	features = id->driver_data;
-	if (twl_class_is_6030()) {
-		twl_i2c_read_u8(TWL_MODULE_USB, &temp, USB_PRODUCT_ID_LSB);
-		if (temp == 0x32)
-			features |= TWL6032_SUBCLASS;
-	}
-
 	/* load power event scripts */
-	if (twl_has_power()) {
-		if (twl_class_is_4030() && pdata->power)
-			twl4030_power_init(pdata->power);
-		if (twl_class_is_6030())
-			twl6030_power_init(pdata->power, features);
-	}
+	if (twl_has_power() && pdata->power)
+		twl4030_power_init(pdata->power);
 
 	/* Maybe init the T2 Interrupt subsystem */
 	if (client->irq
@@ -1482,7 +1251,7 @@ twl_probe(struct i2c_client *client, const struct i2c_device_id *id)
 			pdata->irq_end);
 		} else {
 			status = twl6030_init_irq(client->irq, pdata->irq_base,
-			pdata->irq_end, features);
+			pdata->irq_end);
 		}
 
 		if (status < 0)
@@ -1500,34 +1269,11 @@ twl_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		I2C_SDA_CTRL_PU | I2C_SCL_CTRL_PU);
 		twl_i2c_write_u8(TWL4030_MODULE_INTBR, temp, REG_GPPUPDCTR1);
 	}
-	
-	status = add_children(pdata, features);
 
-	if (pdata && pdata->pre_init) {
-		ret = pdata->pre_init();
-		if (ret != 0) {
-			printk(" tps80032 pre_init() failed\n");
-		}
-	}
-	
-	if (pdata && pdata->set_init) {
-		ret = pdata->set_init();
-		if (ret != 0) {
-			printk(" tps80032 set_init() failed\n");
-		}
-	}
-	#ifdef CONFIG_HAS_EARLYSUSPEND
-	twl60xx_early_suspend.level = 0xffff;
-    twl60xx_early_suspend.suspend = twl60xx_pmu_early_suspend;
-    twl60xx_early_suspend.resume = twl60xx_pmu_early_resume;
-    register_early_suspend(&twl60xx_early_suspend);
-	#endif
-
-	
+	status = add_children(pdata, id->driver_data);
 fail:
 	if (status < 0)
 		twl_remove(client);
-	dev_info(&client->dev, "%s finished, status = %d\n", __func__, status);
 	return status;
 }
 
@@ -1539,7 +1285,7 @@ static const struct i2c_device_id twl_ids[] = {
 	{ "tps65930", TPS_SUBSET },	/* fewer LDOs and DACs; no charger */
 	{ "tps65920", TPS_SUBSET },	/* fewer LDOs; no codec or charger */
 	{ "twl6030", TWL6030_CLASS },	/* "Phoenix power chip" */
-	{ "twl6032", TWL6030_CLASS | TWL6032_SUBCLASS }, /* Phoenix lite */
+	{ "twl6025", TWL6030_CLASS | TWL6025_SUBCLASS }, /* "Phoenix lite" */
 	{ /* end of list */ },
 };
 MODULE_DEVICE_TABLE(i2c, twl_ids);
@@ -1549,16 +1295,14 @@ static struct i2c_driver twl_driver = {
 	.driver.name	= DRIVER_NAME,
 	.id_table	= twl_ids,
 	.probe		= twl_probe,
-	.remove		= __devexit_p(twl_remove),
-	.suspend	= twl_suspend,
-	.resume		= twl_resume,
+	.remove		= twl_remove,
 };
 
 static int __init twl_init(void)
 {
 	return i2c_add_driver(&twl_driver);
 }
-subsys_initcall_sync(twl_init);
+subsys_initcall(twl_init);
 
 static void __exit twl_exit(void)
 {
diff --git a/drivers/mfd/twl-core.h b/drivers/mfd/twl-core.h
index 00e6468a53b0..8c50a556e986 100644
--- a/drivers/mfd/twl-core.h
+++ b/drivers/mfd/twl-core.h
@@ -1,8 +1,7 @@
 #ifndef __TWL_CORE_H__
 #define __TWL_CORE_H__
 
-extern int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end,
-			unsigned long features);
+extern int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end);
 extern int twl6030_exit_irq(void);
 extern int twl4030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end);
 extern int twl4030_exit_irq(void);
diff --git a/drivers/mfd/twl6030-irq.c b/drivers/mfd/twl6030-irq.c
index 36688ed208b1..b0563b66d10b 100644
--- a/drivers/mfd/twl6030-irq.c
+++ b/drivers/mfd/twl6030-irq.c
@@ -37,12 +37,9 @@
 #include <linux/kthread.h>
 #include <linux/i2c/twl.h>
 #include <linux/platform_device.h>
-#include <linux/suspend.h>
-#include <linux/reboot.h>
 
 #include "twl-core.h"
 
-#include <mach/board.h>
 /*
  * TWL6030 (unlike its predecessors, which had two level interrupt handling)
  * three interrupt registers INT_STS_A, INT_STS_B and INT_STS_C.
@@ -55,10 +52,10 @@
  *
  */
 
-static int twl6030_interrupt_mapping_table[24] = {
+static int twl6030_interrupt_mapping[24] = {
 	PWR_INTR_OFFSET,	/* Bit 0	PWRON			*/
 	PWR_INTR_OFFSET,	/* Bit 1	RPWRON			*/
-	TWL_VLOW_INTR_OFFSET,	/* Bit 2	BAT_VLOW		*/
+	PWR_INTR_OFFSET,	/* Bit 2	BAT_VLOW		*/
 	RTC_INTR_OFFSET,	/* Bit 3	RTC_ALARM		*/
 	RTC_INTR_OFFSET,	/* Bit 4	RTC_PERIOD		*/
 	HOTDIE_INTR_OFFSET,	/* Bit 5	HOT_DIE			*/
@@ -71,7 +68,7 @@ static int twl6030_interrupt_mapping_table[24] = {
 	MMCDETECT_INTR_OFFSET,	/* Bit 11	MMC			*/
 	RSV_INTR_OFFSET,  	/* Bit 12	Reserved		*/
 	MADC_INTR_OFFSET,	/* Bit 13	GPADC_RT_EOC		*/
-	GPADCSW_INTR_OFFSET,	/* Bit 14	GPADC_SW_EOC		*/
+	MADC_INTR_OFFSET,	/* Bit 14	GPADC_SW_EOC		*/
 	GASGAUGE_INTR_OFFSET,	/* Bit 15	CC_AUTOCAL		*/
 
 	USBOTG_INTR_OFFSET,	/* Bit 16	ID_WKUP			*/
@@ -83,85 +80,11 @@ static int twl6030_interrupt_mapping_table[24] = {
 	CHARGERFAULT_INTR_OFFSET,	/* Bit 22	INT_CHRG	*/
 	RSV_INTR_OFFSET,	/* Bit 23	Reserved		*/
 };
-
-static int twl6032_interrupt_mapping_table[24] = {
-	PWR_INTR_OFFSET,	/* Bit 0	PWRON			*/
-	PWR_INTR_OFFSET,	/* Bit 1	RPWRON			*/
-	TWL_VLOW_INTR_OFFSET,	/* Bit 2	SYS_VLOW		*/
-	RTC_INTR_OFFSET,	/* Bit 3	RTC_ALARM		*/
-	RTC_INTR_OFFSET,	/* Bit 4	RTC_PERIOD		*/
-	HOTDIE_INTR_OFFSET,	/* Bit 5	HOT_DIE			*/
-	SMPSLDO_INTR_OFFSET,	/* Bit 6	VXXX_SHORT		*/
-	PWR_INTR_OFFSET,	/* Bit 7	SPDURATION		*/
-
-	PWR_INTR_OFFSET,	/* Bit 8	WATCHDOG		*/
-	BATDETECT_INTR_OFFSET,	/* Bit 9	BAT			*/
-	SIMDETECT_INTR_OFFSET,	/* Bit 10	SIM			*/
-	MMCDETECT_INTR_OFFSET,	/* Bit 11	MMC			*/
-	MADC_INTR_OFFSET,	/* Bit 12	GPADC_RT_EOC		*/
-	GPADCSW_INTR_OFFSET,	/* Bit 13	GPADC_SW_EOC		*/
-	GASGAUGE_INTR_OFFSET,	/* Bit 14	CC_EOC		*/
-	GASGAUGE_INTR_OFFSET,	/* Bit 15	CC_AUTOCAL		*/
-
-	USBOTG_INTR_OFFSET,	/* Bit 16	ID_WKUP			*/
-	USBOTG_INTR_OFFSET,	/* Bit 17	VBUS_WKUP		*/
-	USBOTG_INTR_OFFSET,	/* Bit 18	ID			*/
-	USB_PRES_INTR_OFFSET,	/* Bit 19	VBUS			*/
-	CHARGER_INTR_OFFSET,	/* Bit 20	CHRG_CTRL		*/
-	CHARGERFAULT_INTR_OFFSET,	/* Bit 21	EXT_CHRG	*/
-	CHARGERFAULT_INTR_OFFSET,	/* Bit 22	INT_CHRG	*/
-	RSV_INTR_OFFSET,	/* Bit 23	Reserved		*/
-};
-
-static int *twl6030_interrupt_mapping = twl6030_interrupt_mapping_table;
 /*----------------------------------------------------------------------*/
 
-static unsigned twl6030_irq_base, twl6030_irq_end;
-static int twl_irq;
-static bool twl_irq_wake_enabled;
+static unsigned twl6030_irq_base;
 
-static struct task_struct *task;
 static struct completion irq_event;
-static atomic_t twl6030_wakeirqs = ATOMIC_INIT(0);
-
-static u8 vbatmin_hi_threshold;
-
-static int twl6030_irq_pm_notifier(struct notifier_block *notifier,
-				   unsigned long pm_event, void *unused)
-{
-	int chained_wakeups;
-
-	switch (pm_event) {
-	case PM_SUSPEND_PREPARE:
-		chained_wakeups = atomic_read(&twl6030_wakeirqs);
-
-		if (chained_wakeups && !twl_irq_wake_enabled) {
-			if (enable_irq_wake(twl_irq))
-				pr_err("twl6030 IRQ wake enable failed\n");
-			else
-				twl_irq_wake_enabled = true;
-		} else if (!chained_wakeups && twl_irq_wake_enabled) {
-			disable_irq_wake(twl_irq);
-			twl_irq_wake_enabled = false;
-		}
-
-		disable_irq(twl_irq);
-		break;
-
-	case PM_POST_SUSPEND:
-		enable_irq(twl_irq);
-		break;
-
-	default:
-		break;
-	}
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block twl6030_irq_pm_notifier_block = {
-	.notifier_call = twl6030_irq_pm_notifier,
-};
 
 /*
  * This thread processes interrupts reported by the Primary Interrupt Handler.
@@ -181,7 +104,6 @@ static int twl6030_irq_thread(void *data)
 		u8 bytes[4];
 		u32 int_sts;
 		} sts;
-		u32 int_sts; /* sts.int_sts converted to CPU endianness */
 
 		/* Wait for IRQ, then read PIH irq status (also blocking) */
 		wait_for_completion_interruptible(&irq_event);
@@ -213,10 +135,9 @@ static int twl6030_irq_thread(void *data)
 		if (sts.bytes[2] & 0x10)
 			sts.bytes[2] |= 0x08;
 
-		int_sts = le32_to_cpu(sts.int_sts);
-		for (i = 0; int_sts; int_sts >>= 1, i++) {
+		for (i = 0; sts.int_sts; sts.int_sts >>= 1, i++) {
 			local_irq_disable();
-			if (int_sts & 0x1) {
+			if (sts.int_sts & 0x1) {
 				int module_irq = twl6030_irq_base +
 					twl6030_interrupt_mapping[i];
 				generic_handle_irq(module_irq);
@@ -260,29 +181,6 @@ static irqreturn_t handle_twl6030_pih(int irq, void *devid)
 	return IRQ_HANDLED;
 }
 
-/*
- * handle_twl6030_vlow() is a threaded BAT_VLOW interrupt handler. BAT_VLOW
- * is a secondary interrupt generated in twl6030_irq_thread().
- */
-static irqreturn_t handle_twl6030_vlow(int irq, void *unused)
-{
-#ifdef CONFIG_TWL60xx_VBAT_LOW_DETECTION
-	rk28_send_wakeup_key();
-#else
-	pr_err("twl6030: BAT_VLOW interrupt; threshold=%dmV\n",
-	       2300 + (vbatmin_hi_threshold - 0b110) * 50);
-#if 1 /* temporary */
-	pr_err("%s: disabling BAT_VLOW interrupt\n", __func__);
-	disable_irq_nosync(twl6030_irq_base + TWL_VLOW_INTR_OFFSET);
-//	WARN_ON(1);
-#else
-	pr_emerg("handle_twl6030_vlow: kernel_power_off()\n");
-	kernel_power_off();
-#endif
-#endif
-	return IRQ_HANDLED;
-}
-
 /*----------------------------------------------------------------------*/
 
 static inline void activate_irq(int irq)
@@ -298,16 +196,6 @@ static inline void activate_irq(int irq)
 #endif
 }
 
-int twl6030_irq_set_wake(struct irq_data *d, unsigned int on)
-{
-	if (on)
-		atomic_inc(&twl6030_wakeirqs);
-	else
-		atomic_dec(&twl6030_wakeirqs);
-
-	return 0;
-}
-
 /*----------------------------------------------------------------------*/
 
 static unsigned twl6030_irq_next;
@@ -382,16 +270,6 @@ int twl6030_mmc_card_detect_config(void)
 									ret);
 		return ret;
 	}
-
-	ret = twl_i2c_write_u8(TWL6030_MODULE_ID0,
-			(MMC_MINS_DEB_MASK | MMC_MEXT_DEB_MASK),
-			TWL6030_MMCDEBOUNCING);
-	if (ret < 0){
-		pr_err("twl6030: Failed to write MMC_MEXT_DEB_MASK %d\n",
-									ret);
-		return ret;
-	}
-
 	return 0;
 }
 EXPORT_SYMBOL(twl6030_mmc_card_detect_config);
@@ -421,88 +299,16 @@ int twl6030_mmc_card_detect(struct device *dev, int slot)
 }
 EXPORT_SYMBOL(twl6030_mmc_card_detect);
 
-int twl6030_vlow_init(int vlow_irq)
-{
-	int status;
-	u8 val;
-
-	status = twl_i2c_read_u8(TWL_MODULE_PM_SLAVE_RES, &val,
-			REG_VBATMIN_HI_CFG_STATE);
-	if (status < 0) {
-		pr_err("twl6030: I2C err reading REG_VBATMIN_HI_CFG_STATE: %d\n",
-				status);
-		return status;
-	}
-
-	status = twl_i2c_write_u8(TWL_MODULE_PM_SLAVE_RES,
-			val | VBATMIN_VLOW_EN, REG_VBATMIN_HI_CFG_STATE);
-	if (status < 0) {
-		pr_err("twl6030: I2C err writing REG_VBATMIN_HI_CFG_STATE: %d\n",
-				status);
-		return status;
-	}
-
-	status = twl_i2c_read_u8(TWL_MODULE_PIH, &val, REG_INT_MSK_LINE_A);
-	if (status < 0) {
-		pr_err("twl6030: I2C err reading REG_INT_MSK_LINE_A: %d\n",
-				status);
-		return status;
-	}
-
-	status = twl_i2c_write_u8(TWL_MODULE_PIH, val & ~VLOW_INT_MASK,
-			REG_INT_MSK_LINE_A);
-	if (status < 0) {
-		pr_err("twl6030: I2C err writing REG_INT_MSK_LINE_A: %d\n",
-				status);
-		return status;
-	}
-
-	status = twl_i2c_read_u8(TWL_MODULE_PIH, &val, REG_INT_MSK_STS_A);
-	if (status < 0) {
-		pr_err("twl6030: I2C err reading REG_INT_MSK_STS_A: %d\n",
-				status);
-		return status;
-	}
-
-	status = twl_i2c_write_u8(TWL_MODULE_PIH, val & ~VLOW_INT_MASK,
-		REG_INT_MSK_STS_A);
-	if (status < 0) {
-		pr_err("twl6030: I2C err writing REG_INT_MSK_STS_A: %d\n",
-				status);
-		return status;
-	}
-
-	twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &vbatmin_hi_threshold,
-			TWL6030_VBATMIN_HI_THRESHOLD);
-
-	/* install an irq handler for vlow */
-	status = request_threaded_irq(vlow_irq, NULL, handle_twl6030_vlow,
-			IRQF_ONESHOT,
-			"TWL6030-VLOW", handle_twl6030_vlow);
-	if (status < 0) {
-		pr_err("twl6030: could not claim vlow irq %d: %d\n", vlow_irq,
-				status);
-		return status;
-	}
-
-	return 0;
-}
-
-int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end,
-			unsigned long features)
+int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end)
 {
 
 	int	status = 0;
 	int	i;
+	struct task_struct	*task;
 	int ret;
 	u8 mask[4];
-	u8 reg;
 
 	static struct irq_chip	twl6030_irq_chip;
-
-	if (features & TWL6032_SUBCLASS)
-		twl6030_interrupt_mapping = twl6032_interrupt_mapping_table;
-
 	mask[1] = 0xFF;
 	mask[2] = 0xFF;
 	mask[3] = 0xFF;
@@ -514,7 +320,6 @@ int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end,
 			REG_INT_STS_A, 3); /* clear INT_STS_A,B,C */
 
 	twl6030_irq_base = irq_base;
-	twl6030_irq_end = irq_end;
 
 	/* install an irq handler for each of the modules;
 	 * clone dummy irq_chip since PIH can't *do* anything
@@ -522,12 +327,10 @@ int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end,
 	twl6030_irq_chip = dummy_irq_chip;
 	twl6030_irq_chip.name = "twl6030";
 	twl6030_irq_chip.irq_set_type = NULL;
-	twl6030_irq_chip.irq_set_wake = twl6030_irq_set_wake;
 
 	for (i = irq_base; i < irq_end; i++) {
 		irq_set_chip_and_handler(i, &twl6030_irq_chip,
 					 handle_simple_irq);
-		irq_set_chip_data(i, (void *)irq_num);
 		activate_irq(i);
 	}
 
@@ -550,24 +353,9 @@ int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end,
 		pr_err("twl6030: could not claim irq%d: %d\n", irq_num, status);
 		goto fail_irq;
 	}
-
-	twl_irq = irq_num;
-	register_pm_notifier(&twl6030_irq_pm_notifier_block);
-
-	status = twl6030_vlow_init(twl6030_irq_base + TWL_VLOW_INTR_OFFSET);
-	if (status < 0)
-		goto fail_vlow;
-	
-	twl_i2c_write_u8(TWL_MODULE_PIH, &reg,REG_INT_MSK_STS_A);
-	twl_i2c_write_u8(TWL_MODULE_PIH, reg | (1 << 2),REG_INT_MSK_STS_A);   //close vlow interrupt
-
 	return status;
-
-fail_vlow:
-	free_irq(irq_num, &irq_event);
-
 fail_irq:
-	kthread_stop(task);
+	free_irq(irq_num, &irq_event);
 
 fail_kthread:
 	for (i = irq_base; i < irq_end; i++)
@@ -577,25 +365,11 @@ int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end,
 
 int twl6030_exit_irq(void)
 {
-	int i;
-	unregister_pm_notifier(&twl6030_irq_pm_notifier_block);
 
-	if (task)
-		kthread_stop(task);
-
-	if (!twl6030_irq_base || !twl6030_irq_end) {
+	if (twl6030_irq_base) {
 		pr_err("twl6030: can't yet clean up IRQs?\n");
 		return -ENOSYS;
 	}
-
-	free_irq(twl6030_irq_base + TWL_VLOW_INTR_OFFSET,
-		handle_twl6030_vlow);
-
-	free_irq(twl_irq, &irq_event);
-
-	for (i = twl6030_irq_base; i < twl6030_irq_end; i++)
-		irq_set_chip_and_handler(i, NULL, NULL);
-
 	return 0;
 }
 
diff --git a/drivers/mfd/wm831x-core.c b/drivers/mfd/wm831x-core.c
index b94118fcec68..265f75fc6a25 100644
--- a/drivers/mfd/wm831x-core.c
+++ b/drivers/mfd/wm831x-core.c
@@ -18,7 +18,6 @@
 #include <linux/delay.h>
 #include <linux/mfd/core.h>
 #include <linux/slab.h>
-#include <linux/irq.h>
 
 #include <linux/mfd/wm831x/core.h>
 #include <linux/mfd/wm831x/pdata.h>
@@ -26,19 +25,10 @@
 #include <linux/mfd/wm831x/auxadc.h>
 #include <linux/mfd/wm831x/otp.h>
 #include <linux/mfd/wm831x/regulator.h>
-#include <linux/mfd/wm831x/pmu.h>
-
-#include <mach/board.h>
-#include <linux/earlysuspend.h>
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static struct early_suspend wm831x_early_suspend;
-#endif
 
 /* Current settings - values are 2*2^(reg_val/4) microamps.  These are
  * exported since they are used by multiple drivers.
  */
- extern int reboot_cmd_get(void);
 int wm831x_isinkv_values[WM831X_ISINK_MAX_ISEL + 1] = {
 	2,
 	2,
@@ -393,7 +383,7 @@ int wm831x_auxadc_read(struct wm831x *wm831x, enum wm831x_auxadc input)
 		 * the notification of the interrupt may be delayed by
 		 * threaded IRQ handling. */
 		if (!wait_for_completion_timeout(&wm831x->auxadc_done,
-						 msecs_to_jiffies(2000))) {
+						 msecs_to_jiffies(500))) {
 			dev_err(wm831x->dev, "Timed out waiting for AUXADC\n");
 			ret = -EBUSY;
 			goto disable;
@@ -427,15 +417,6 @@ int wm831x_auxadc_read(struct wm831x *wm831x, enum wm831x_auxadc input)
 }
 EXPORT_SYMBOL_GPL(wm831x_auxadc_read);
 
-#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION
-static irqreturn_t wm831x_vbatlo_irq(int irq, void *irq_data)
-{
-	rk28_send_wakeup_key();
-
-	return IRQ_HANDLED;
-}
-#endif
-
 static irqreturn_t wm831x_auxadc_irq(int irq, void *irq_data)
 {
 	struct wm831x *wm831x = irq_data;
@@ -1016,20 +997,6 @@ static struct mfd_cell wm8310_devs[] = {
 		.num_resources = ARRAY_SIZE(wm831x_wdt_resources),
 		.resources = wm831x_wdt_resources,
 	},
-#if defined(CONFIG_KEYBOARD_WM831X_GPIO)
-	{
-		.name		= "wm831x_gpio-keys",
-		.num_resources	= 0,
-	},
-#endif
-#if defined(CONFIG_WM831X_CHARGER_DISPLAY)
-	{
-		.name		= "wm831x_charger_display",
-		.num_resources	= 0,
-	},
-#endif
-
-
 };
 
 static struct mfd_cell wm8311_devs[] = {
@@ -1470,10 +1437,6 @@ static struct mfd_cell backlight_devs[] = {
 /*
  * Instantiate the generic non-control parts of the device.
  */
-
-__weak void  wm831x_pmu_early_suspend(struct early_suspend *h) {}
-__weak void  wm831x_pmu_early_resume(struct early_suspend *h) {}
-
 int wm831x_device_init(struct wm831x *wm831x, unsigned long id, int irq)
 {
 	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
@@ -1526,15 +1489,12 @@ int wm831x_device_init(struct wm831x *wm831x, unsigned long id, int irq)
 	switch (ret) {
 	case WM8310:
 		parent = WM8310;
-		wm831x->num_gpio = 12;
+		wm831x->num_gpio = 16;
 		wm831x->charger_irq_wake = 1;
 		if (rev > 0) {
 			wm831x->has_gpio_ena = 1;
 			wm831x->has_cs_sts = 1;
 		}
-		//ILIM = 900ma
-		ret = wm831x_reg_read(wm831x, WM831X_POWER_STATE) & 0xffff;
-		wm831x_reg_write(wm831x, WM831X_POWER_STATE, (ret&0xfff8) | 0x04);	
 
 		dev_info(wm831x->dev, "WM8310 revision %c\n", 'A' + rev);
 		break;
@@ -1636,44 +1596,14 @@ int wm831x_device_init(struct wm831x *wm831x, unsigned long id, int irq)
 	if (ret != 0)
 		goto err;
 
-	switch (parent) {
-	#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION	
-	#ifdef CONFIG_BATTERY_RK30_VOL3V8
-	if (wm831x->irq_base) {
-		ret = request_threaded_irq(wm831x->irq_base +
-					   WM831X_IRQ_PPM_SYSLO,
-					   NULL, wm831x_vbatlo_irq, IRQF_TRIGGER_RISING,
-					   "syslo", wm831x);
-			}
-		if (ret < 0)
-			dev_err(wm831x->dev, "syslo IRQ request failed: %d\n",
-				ret);
-	#else
-	case WM8326:
-		if (wm831x->irq_base) {
-		ret = request_threaded_irq(wm831x->irq_base +
-					   WM831X_IRQ_AUXADC_DCOMP1,
-					   NULL, wm831x_vbatlo_irq, IRQF_TRIGGER_RISING,
-					   "syslo", wm831x);
-			}
-		if (ret < 0)
-			dev_err(wm831x->dev, "syslo IRQ request failed: %d\n",
-				ret);
-		break;
-	#endif
-	#endif
-	
-	default:	
 	if (wm831x->irq_base) {
 		ret = request_threaded_irq(wm831x->irq_base +
 					   WM831X_IRQ_AUXADC_DATA,
 					   NULL, wm831x_auxadc_irq, 0,
 					   "auxadc", wm831x);
-		}
 		if (ret < 0)
 			dev_err(wm831x->dev, "AUXADC IRQ request failed: %d\n",
 				ret);
-	
 	}
 
 	/* The core device is up, instantiate the subdevices. */
@@ -1728,22 +1658,12 @@ int wm831x_device_init(struct wm831x *wm831x, unsigned long id, int irq)
 	wm831x_otp_init(wm831x);
 
 	if (pdata && pdata->post_init) {
-		wm831x_reg_write(wm831x, WM831X_SECURITY_KEY, 0x9716); //wm831x_reg_unlock
-		wm831x_set_bits(wm831x, WM831X_RESET_CONTROL,0x0010,0x0000);
-		wm831x_set_bits(wm831x, WM831X_LDO_ENABLE,0Xf800,0Xf800);
 		ret = pdata->post_init(wm831x);
-		wm831x_reg_write(wm831x, WM831X_SECURITY_KEY, 0x0000);	 //wm831x_reg_lock
 		if (ret != 0) {
 			dev_err(wm831x->dev, "post_init() failed: %d\n", ret);
 			goto err_irq;
 		}
 	}
-	#ifdef CONFIG_HAS_EARLYSUSPEND
-	wm831x_early_suspend.level = 0xffff;
-    wm831x_early_suspend.suspend = wm831x_pmu_early_suspend;
-    wm831x_early_suspend.resume = wm831x_pmu_early_resume;
-    register_early_suspend(&wm831x_early_suspend);
-	#endif
 
 	return 0;
 
@@ -1768,22 +1688,6 @@ void wm831x_device_exit(struct wm831x *wm831x)
 int wm831x_device_suspend(struct wm831x *wm831x)
 {
 	int reg, mask;
-	int i;
-	
-	//mask some intterupt avoid wakeing up system while suspending
-	for (i = 0; i < ARRAY_SIZE(wm831x->irq_masks_cur); i++) {
-		/* If there's been a change in the mask write it back
-		 * to the hardware. */
-		//printk("irq_masks_cur[%d]=0x%x\n",i,wm831x->irq_masks_cur[i]);
-
-		if (wm831x->irq_masks_cur[i] != wm831x->irq_masks_cache[i]) {
-			wm831x->irq_masks_cache[i] = wm831x->irq_masks_cur[i];
-			wm831x_reg_write(wm831x,
-					 WM831X_INTERRUPT_STATUS_1_MASK + i,
-					 wm831x->irq_masks_cur[i]);
-		}
-	
-	}
 
 	/* If the charger IRQs are a wake source then make sure we ack
 	 * them even if they're not actively being used (eg, no power
@@ -1817,95 +1721,6 @@ int wm831x_device_suspend(struct wm831x *wm831x)
 	return 0;
 }
 
-void wm831x_enter_sleep(void){
-	struct regulator *dcdc = regulator_get(NULL, "dcdc1");
-	int i;		
-	struct wm831x_dcdc *dc = regulator_get_drvdata(dcdc);
-	struct wm831x *wm831x = dc->wm831x;
-	if(wm831x){
-		wm831x_set_bits(wm831x, WM831X_POWER_STATE, 0x4000, 0x4000); // SYSTEM SLEEP MODE
-		for (i=0; i<5; i++)
-			wm831x_reg_write(wm831x,WM831X_INTERRUPT_STATUS_1+i, 0xffff);  // INTRUPT FLAG CLEAR 
-			
-		printk("%s:complete! \n",__func__);
-		
-	}else{
-		printk("%s:error!",__func__);
-	}
-	regulator_put(dcdc);
-}
-EXPORT_SYMBOL_GPL(wm831x_enter_sleep);
-
-void wm831x_exit_sleep(void){
-	struct regulator *dcdc = regulator_get(NULL, "dcdc1");
-	struct wm831x_dcdc *dc = regulator_get_drvdata(dcdc);
-	struct wm831x *wm831x = dc->wm831x;
-	if(wm831x){
-		wm831x_set_bits(wm831x, WM831X_POWER_STATE, 0x4000, 0);  // SYSTEM ON MODE
-		printk("%s:complete! \n",__func__);
-		
-	}else{
-		printk("%s:error!",__func__);
-	}
-	regulator_put(dcdc);
-}
-EXPORT_SYMBOL_GPL(wm831x_exit_sleep);
-
-int wm831x_device_shutdown(struct wm831x *wm831x)
-{
-	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
-	int ret = 0;
-	
-	printk("pre WM831X_POWER_STATE = 0x%x\n", wm831x_reg_read(wm831x, WM831X_POWER_STATE));
-
-	if(wm831x_set_bits(wm831x, WM831X_RTC_CONTROL, WM831X_RTC_ALAM_ENA_MASK, 0) < 0)
-			printk("%s wm831x_set_bits err\n", __FUNCTION__);   //disable rtc alam
-#if 0
-	if (pdata && pdata->last_deinit) {
-		ret = pdata->last_deinit(wm831x);
-		if (ret != 0) {
-			dev_info(wm831x->dev, "last_deinit() failed: %d\n", ret);
-		}
-	}
-#endif
-	//if(0 == reboot_cmd_get())
-	
-		if(wm831x_set_bits(wm831x, WM831X_POWER_STATE, WM831X_CHIP_ON_MASK, 0) < 0)
-			printk("%s wm831x_set_bits err\n", __FUNCTION__);
-		//printk("post WM831X_POWER_STATE = 0x%x\n", wm831x_reg_read(wm831x, WM831X_POWER_STATE));
-
-	return 0;	
-}
-
-EXPORT_SYMBOL_GPL(wm831x_device_shutdown);
-
-
-int wm831x_read_usb(struct wm831x *wm831x)
-{
-	int ret, usb_chg = 0, wall_chg = 0;
-	
-	ret = wm831x_reg_read(wm831x, WM831X_SYSTEM_STATUS);
-	if (ret < 0)
-		return ret;
-
-	if (ret & WM831X_PWR_USB)
-		usb_chg = 1;
-	if (ret & WM831X_PWR_WALL)
-		wall_chg = 1;
-
-	return ((usb_chg | wall_chg) ? 1 : 0);
-
-}
-
-
-int wm831x_device_restart(struct wm831x *wm831x)
-{
-	wm831x_reg_write(wm831x,WM831X_RESET_ID, 0xffff); 
-
-	return 0;
-}
-
-
 MODULE_DESCRIPTION("Core support for the WM831X AudioPlus PMIC");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Mark Brown");
diff --git a/drivers/mfd/wm831x-i2c.c b/drivers/mfd/wm831x-i2c.c
index 717f629336f3..a06cbc739716 100644
--- a/drivers/mfd/wm831x-i2c.c
+++ b/drivers/mfd/wm831x-i2c.c
@@ -18,7 +18,6 @@
 #include <linux/delay.h>
 #include <linux/mfd/core.h>
 #include <linux/slab.h>
-#include <linux/gpio.h>
 
 #include <linux/mfd/wm831x/core.h>
 #include <linux/mfd/wm831x/pdata.h>
@@ -26,36 +25,6 @@
 static int wm831x_i2c_read_device(struct wm831x *wm831x, unsigned short reg,
 				  int bytes, void *dest)
 {
-#if defined(CONFIG_ARCH_RK30)
-	const struct i2c_client *client = wm831x->control_data;
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msgs[2];
-	int ret;
-	char reg_buf[2];
-	const short regs = reg;
-	int scl_rate= 100 * 1000;
-	short *buf = dest;
-	int count = bytes/2;
-
-        reg_buf[0] = (regs & 0xff00) >> 8;
-        reg_buf[1] = regs & 0x00ff;
-
-	msgs[0].addr = client->addr;
-	msgs[0].flags = client->flags;
-	msgs[0].len = 2;
-	msgs[0].buf = reg_buf;
-	msgs[0].scl_rate = scl_rate;
-
-	msgs[1].addr = client->addr;
-	msgs[1].flags = client->flags | I2C_M_RD;
-	msgs[1].len = count * 2;
-	msgs[1].buf = (char *)buf;
-	msgs[1].scl_rate = scl_rate;
-
-	ret = i2c_transfer(adap, msgs, 2);
-
-	return (ret == 2)? 0 : ret;
-#else
 	struct i2c_client *i2c = wm831x->control_data;
 	int ret;
 	u16 r = cpu_to_be16(reg);
@@ -72,7 +41,6 @@ static int wm831x_i2c_read_device(struct wm831x *wm831x, unsigned short reg,
 	if (ret != bytes)
 		return -EIO;
 	return 0;
-#endif
 }
 
 /* Currently we allocate the write buffer on the stack; this is OK for
@@ -82,86 +50,47 @@ static int wm831x_i2c_read_device(struct wm831x *wm831x, unsigned short reg,
 static int wm831x_i2c_write_device(struct wm831x *wm831x, unsigned short reg,
 				   int bytes, void *src)
 {
-#if defined(CONFIG_ARCH_RK30)
-	const struct i2c_client *client = wm831x->control_data;
-	struct i2c_adapter *adap=client->adapter;
-	struct i2c_msg msg;
-	int ret;
-	const short regs = reg;
-	const short *buf = src;
-	int count = bytes/2;
-	int scl_rate = 100 * 1000;
-	int i;
-	
-	char *tx_buf = (char *)kmalloc(2 * (count + 1), GFP_KERNEL);
-	if(!tx_buf)
-		return -ENOMEM;
-        tx_buf[0] = (regs & 0xff00) >> 8;
-        tx_buf[1] = regs & 0x00ff;
-        for(i = 0; i < count; i++){
-                tx_buf[i*2+3] = (buf[i] & 0xff00) >> 8;
-                tx_buf[i*2+2] = buf[i] & 0x00ff;
-        }
-
-	msg.addr = client->addr;
-	msg.flags = client->flags;
-	msg.len = 2 * (count + 1);
-	msg.buf = (char *)tx_buf;
-	msg.scl_rate = scl_rate;
-
-	ret = i2c_transfer(adap, &msg, 1);
-	kfree(tx_buf);
-	return (ret == 1) ? 0 : ret;
-#else
 	struct i2c_client *i2c = wm831x->control_data;
-	unsigned char msg[bytes + 2];
+	struct i2c_msg xfer[2];
 	int ret;
 
 	reg = cpu_to_be16(reg);
-	memcpy(&msg[0], &reg, 2);
-	memcpy(&msg[2], src, bytes);
 
-	ret = i2c_master_send(i2c, msg, bytes + 2);
+	xfer[0].addr = i2c->addr;
+	xfer[0].flags = 0;
+	xfer[0].len = 2;
+	xfer[0].buf = (char *)&reg;
+
+	xfer[1].addr = i2c->addr;
+	xfer[1].flags = I2C_M_NOSTART;
+	xfer[1].len = bytes;
+	xfer[1].buf = (char *)src;
+
+	ret = i2c_transfer(i2c->adapter, xfer, 2);
 	if (ret < 0)
 		return ret;
-	if (ret < bytes + 2)
+	if (ret != 2)
 		return -EIO;
 
 	return 0;
-#endif 
 }
 
 static int wm831x_i2c_probe(struct i2c_client *i2c,
 			    const struct i2c_device_id *id)
 {
 	struct wm831x *wm831x;
-	int ret,gpio,irq;
 
 	wm831x = kzalloc(sizeof(struct wm831x), GFP_KERNEL);
 	if (wm831x == NULL)
 		return -ENOMEM;
 
 	i2c_set_clientdata(i2c, wm831x);
-	
-	gpio = i2c->irq;
-	ret = gpio_request(gpio, "wm831x");
-	if (ret) {
-		printk( "failed to request rk gpio irq for wm831x \n");
-		return ret;
-	}
-	gpio_pull_updown(gpio, GPIOPullUp);
-	if (ret) {
-	    printk("failed to pull up gpio irq for wm831x \n");
-		return ret;
-	}	
-	irq = gpio_to_irq(gpio);
-	
 	wm831x->dev = &i2c->dev;
 	wm831x->control_data = i2c;
 	wm831x->read_dev = wm831x_i2c_read_device;
 	wm831x->write_dev = wm831x_i2c_write_device;
 
-	return wm831x_device_init(wm831x, id->driver_data, irq);
+	return wm831x_device_init(wm831x, id->driver_data, i2c->irq);
 }
 
 static int wm831x_i2c_remove(struct i2c_client *i2c)
@@ -177,40 +106,9 @@ static int wm831x_i2c_suspend(struct device *dev)
 {
 	struct wm831x *wm831x = dev_get_drvdata(dev);
 
-	spin_lock(&wm831x->flag_lock);
-	wm831x->flag_suspend = 1;
-	spin_unlock(&wm831x->flag_lock);
-
 	return wm831x_device_suspend(wm831x);
 }
 
-static int wm831x_i2c_resume(struct device *dev)
-{
-	struct wm831x *wm831x = dev_get_drvdata(dev);
-	int i;
-	//set some intterupt again while resume 
-	for (i = 0; i < ARRAY_SIZE(wm831x->irq_masks_cur); i++) {
-		//printk("irq_masks_cur[%d]=0x%x\n",i,wm831x->irq_masks_cur[i]);
-
-		if (wm831x->irq_masks_cur[i] != wm831x->irq_masks_cache[i]) {
-			wm831x->irq_masks_cache[i] = wm831x->irq_masks_cur[i];
-			wm831x_reg_write(wm831x,
-					 WM831X_INTERRUPT_STATUS_1_MASK + i,
-					 wm831x->irq_masks_cur[i]);
-		}
-	
-	}
-
-	return 0;
-}
-
-void wm831x_i2c_shutdown(struct i2c_client *i2c)
-{
-	struct wm831x *wm831x = i2c_get_clientdata(i2c);
-//	printk("%s\n", __FUNCTION__);
-//	wm831x_device_shutdown(wm831x);
-}
-
 static const struct i2c_device_id wm831x_i2c_id[] = {
 	{ "wm8310", WM8310 },
 	{ "wm8311", WM8311 },
@@ -225,7 +123,6 @@ MODULE_DEVICE_TABLE(i2c, wm831x_i2c_id);
 
 static const struct dev_pm_ops wm831x_pm_ops = {
 	.suspend = wm831x_i2c_suspend,
-	.resume = wm831x_i2c_resume,
 };
 
 static struct i2c_driver wm831x_i2c_driver = {
@@ -236,7 +133,6 @@ static struct i2c_driver wm831x_i2c_driver = {
 	},
 	.probe = wm831x_i2c_probe,
 	.remove = wm831x_i2c_remove,
-	.shutdown = wm831x_i2c_shutdown,
 	.id_table = wm831x_i2c_id,
 };
 
@@ -244,14 +140,13 @@ static int __init wm831x_i2c_init(void)
 {
 	int ret;
 
-	printk("%s\n", __FUNCTION__);
 	ret = i2c_add_driver(&wm831x_i2c_driver);
 	if (ret != 0)
 		pr_err("Failed to register wm831x I2C driver: %d\n", ret);
 
 	return ret;
 }
-subsys_initcall_sync(wm831x_i2c_init);
+subsys_initcall(wm831x_i2c_init);
 
 static void __exit wm831x_i2c_exit(void)
 {
diff --git a/drivers/mfd/wm831x-irq.c b/drivers/mfd/wm831x-irq.c
index f54285b60365..42b928ec891e 100644
--- a/drivers/mfd/wm831x-irq.c
+++ b/drivers/mfd/wm831x-irq.c
@@ -18,23 +18,13 @@
 #include <linux/irq.h>
 #include <linux/mfd/core.h>
 #include <linux/interrupt.h>
-#include <linux/slab.h>
+
 #include <linux/mfd/wm831x/core.h>
 #include <linux/mfd/wm831x/pdata.h>
 #include <linux/mfd/wm831x/gpio.h>
 #include <linux/mfd/wm831x/irq.h>
 
 #include <linux/delay.h>
-#include <linux/wakelock.h>
-/*
- * Since generic IRQs don't currently support interrupt controllers on
- * interrupt driven buses we don't use genirq but instead provide an
- * interface that looks very much like the standard ones.  This leads
- * to some bodges, including storing interrupt handler information in
- * the static irq_data table we use to look up the data for individual
- * interrupts, but hopefully won't last too long.
- */
-#define WM831X_IRQ_TYPE IRQF_TRIGGER_LOW
 
 struct wm831x_irq_data {
 	int primary;
@@ -42,12 +32,6 @@ struct wm831x_irq_data {
 	int mask;
 };
 
-struct wm831x_handle_irq
-{	
-	int irq;
-	struct list_head	queue;
-};
-
 static struct wm831x_irq_data wm831x_irqs[] = {
 	[WM831X_IRQ_TEMP_THW] = {
 		.primary = WM831X_TEMP_INT,
@@ -389,7 +373,6 @@ static void wm831x_irq_enable(struct irq_data *data)
 							     data->irq);
 
 	wm831x->irq_masks_cur[irq_data->reg - 1] &= ~irq_data->mask;
-	//printk("%s:irq=%d\n",__FUNCTION__,irq);
 }
 
 static void wm831x_irq_disable(struct irq_data *data)
@@ -399,23 +382,23 @@ static void wm831x_irq_disable(struct irq_data *data)
 							     data->irq);
 
 	wm831x->irq_masks_cur[irq_data->reg - 1] |= irq_data->mask;
-	//printk("%s:irq=%d\n",__FUNCTION__,irq);
 }
 
 static int wm831x_irq_set_type(struct irq_data *data, unsigned int type)
 {
 	struct wm831x *wm831x = irq_data_get_irq_chip_data(data);
-	int val, irq = 0;
+	int val, irq;
 
 	irq = data->irq - wm831x->irq_base;
-	if (irq < WM831X_IRQ_GPIO_1 || irq > WM831X_IRQ_GPIO_12) {
+
+	if (irq < WM831X_IRQ_GPIO_1 || irq > WM831X_IRQ_GPIO_11) {
 		/* Ignore internal-only IRQs */
 		if (irq >= 0 && irq < WM831X_NUM_IRQS)
 			return 0;
 		else
 			return -EINVAL;
 	}
-	//printk("wm831x_irq_set_type:type=%x,irq=%d\n",type,irq);
+
 	switch (type) {
 	case IRQ_TYPE_EDGE_BOTH:
 		val = WM831X_GPN_INT_MODE;
@@ -430,32 +413,10 @@ static int wm831x_irq_set_type(struct irq_data *data, unsigned int type)
 		return -EINVAL;
 	}
 
-	return wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + irq - 1,
+	return wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + irq,
 			       WM831X_GPN_INT_MODE | WM831X_GPN_POL, val);
 }
 
-static int wm831x_irq_set_wake(struct irq_data *data, unsigned state)
-{	
-	struct wm831x *wm831x = irq_data_get_irq_chip_data(data);
-	int irq = data->irq;
-	//only wm831x irq
-	if ((irq > wm831x->irq_base + WM831X_IRQ_TEMP_THW) &&( irq < wm831x->irq_base + WM831X_NUM_IRQS)) 
-	{
-		if(state)
-		wm831x_irq_enable(data);
-		else	
-		wm831x_irq_disable(data);
-		return 0;
-	}
-	else
-	{
-		printk("%s:irq number err!irq=%d\n",__FUNCTION__,irq);
-		return -EINVAL;
-	}
-
-
-}
-
 static struct irq_chip wm831x_irq_chip = {
 	.name			= "wm831x",
 	.irq_bus_lock		= wm831x_irq_lock,
@@ -463,63 +424,18 @@ static struct irq_chip wm831x_irq_chip = {
 	.irq_disable		= wm831x_irq_disable,
 	.irq_enable		= wm831x_irq_enable,
 	.irq_set_type		= wm831x_irq_set_type,
-	.irq_set_wake	= wm831x_irq_set_wake,
 };
 
-#if WM831X_IRQ_LIST
-static void wm831x_handle_worker(struct work_struct *work)
-{
-	struct wm831x *wm831x = container_of(work, struct wm831x, handle_work);
-	int irq;
-
-	while (1) {
-		unsigned long flags;
-		struct wm831x_handle_irq *hd = NULL;
-
-		spin_lock_irqsave(&wm831x->work_lock, flags);
-		if (!list_empty(&wm831x->handle_queue)) {
-			hd = list_first_entry(&wm831x->handle_queue, struct wm831x_handle_irq, queue);
-			list_del(&hd->queue);
-		}
-		spin_unlock_irqrestore(&wm831x->work_lock, flags);
-
-		if (!hd)	// trans_queue empty
-			break;
-
-		irq = hd->irq;	//get wm831x intterupt status
-		//printk("%s:irq=%d\n",__FUNCTION__,irq);
-		
-		/*start to handle wm831x intterupt*/
-		handle_nested_irq(wm831x->irq_base + irq);
-	
-		kfree(hd);
-
-	}
-}
-#endif
-/* Main interrupt handling occurs in a workqueue since we need
- * interrupts enabled to interact with the chip. */
-static void wm831x_irq_worker(struct work_struct *work)
+/* The processing of the primary interrupt occurs in a thread so that
+ * we can interact with the device over I2C or SPI. */
+static irqreturn_t wm831x_irq_thread(int irq, void *data)
 {
-	struct wm831x *wm831x = container_of(to_delayed_work(work), struct wm831x, irq_work);
+	struct wm831x *wm831x = data;
 	unsigned int i;
 	int primary;
 	int status_regs[WM831X_NUM_IRQ_REGS] = { 0 };
 	int read[WM831X_NUM_IRQ_REGS] = { 0 };
 	int *status;
-	unsigned long flags;
-	struct wm831x_handle_irq *hd;
-
-#if (WM831X_IRQ_TYPE != IRQF_TRIGGER_LOW)
-	/*mask wm831x irq at first*/	
-	int ret;
-	ret = wm831x_set_bits(wm831x, WM831X_IRQ_CONFIG,
-			      WM831X_IRQ_IM_MASK, WM831X_IRQ_IM_EANBLE);
-	if (ret < 0) {
-		dev_err(wm831x->dev, "Failed to mask irq: %d\n", ret);
-		goto out;
-	}
-#endif
 
 	primary = wm831x_reg_read(wm831x, WM831X_SYSTEM_INTERRUPTS);
 	if (primary < 0) {
@@ -527,15 +443,25 @@ static void wm831x_irq_worker(struct work_struct *work)
 			primary);
 		goto out;
 	}
-	
-	mutex_lock(&wm831x->irq_lock);
+
+	/* The touch interrupts are visible in the primary register as
+	 * an optimisation; open code this to avoid complicating the
+	 * main handling loop and so we can also skip iterating the
+	 * descriptors.
+	 */
+	if (primary & WM831X_TCHPD_INT)
+		handle_nested_irq(wm831x->irq_base + WM831X_IRQ_TCHPD);
+	if (primary & WM831X_TCHDATA_INT)
+		handle_nested_irq(wm831x->irq_base + WM831X_IRQ_TCHDATA);
+	if (primary & (WM831X_TCHDATA_EINT | WM831X_TCHPD_EINT))
+		goto out;
 
 	for (i = 0; i < ARRAY_SIZE(wm831x_irqs); i++) {
 		int offset = wm831x_irqs[i].reg - 1;
-		
+
 		if (!(primary & wm831x_irqs[i].primary))
 			continue;
-		
+
 		status = &status_regs[offset];
 
 		/* Hopefully there should only be one register to read
@@ -547,7 +473,7 @@ static void wm831x_irq_worker(struct work_struct *work)
 				dev_err(wm831x->dev,
 					"Failed to read IRQ status: %d\n",
 					*status);
-				goto out_lock;
+				goto out;
 			}
 
 			read[offset] = 1;
@@ -556,84 +482,21 @@ static void wm831x_irq_worker(struct work_struct *work)
 		/* Report it if it isn't masked, or forget the status. */
 		if ((*status & ~wm831x->irq_masks_cur[offset])
 		    & wm831x_irqs[i].mask)
-		{
-			#if WM831X_IRQ_LIST
-			/*add intterupt handle on list*/
-			hd = kzalloc(sizeof(struct wm831x_handle_irq), GFP_KERNEL);
-			if (!hd)
-			{
-				printk("err:%s:ENOMEM\n",__FUNCTION__);
-				return ;
-			}
-			
-			if(i == WM831X_IRQ_ON)
-			wake_lock(&wm831x->handle_wake);		//keep wake while handle WM831X_IRQ_ON
-			hd->irq = i;
-			spin_lock_irqsave(&wm831x->work_lock, flags);
-			list_add_tail(&hd->queue, &wm831x->handle_queue);
-			spin_unlock_irqrestore(&wm831x->work_lock, flags);
-			queue_work(wm831x->handle_wq, &wm831x->handle_work);
-			
-			#else
-			if(i == WM831X_IRQ_ON)
-			wake_lock(&wm831x->handle_wake);		//keep wake while handle WM831X_IRQ_ON
 			handle_nested_irq(wm831x->irq_base + i);
-			
-			#endif
-		}
-			
 		else
 			*status &= ~wm831x_irqs[i].mask;
 	}
-	
-out_lock:	
-	mutex_unlock(&wm831x->irq_lock);
-	
+
 out:
+	/* Touchscreen interrupts are handled specially in the driver */
+	status_regs[0] &= ~(WM831X_TCHDATA_EINT | WM831X_TCHPD_EINT);
+
 	for (i = 0; i < ARRAY_SIZE(status_regs); i++) {
 		if (status_regs[i])
 			wm831x_reg_write(wm831x, WM831X_INTERRUPT_STATUS_1 + i,
 					 status_regs[i]);
 	}
-	
-#if (WM831X_IRQ_TYPE != IRQF_TRIGGER_LOW)	
-	ret = wm831x_set_bits(wm831x, WM831X_IRQ_CONFIG,
-			      WM831X_IRQ_IM_MASK, 0);
-	if (ret < 0) {
-		dev_err(wm831x->dev, "Failed to open irq: %d\n", ret);
-	}
-#endif
-#if (WM831X_IRQ_TYPE == IRQF_TRIGGER_LOW)
-	enable_irq(wm831x->irq);	
-#endif
-	wake_unlock(&wm831x->irq_wake);
 
-}
-/* The processing of the primary interrupt occurs in a thread so that
- * we can interact with the device over I2C or SPI. */
-static irqreturn_t wm831x_irq_thread(int irq, void *data)
-{
-	struct wm831x *wm831x = data;
-	int msdelay = 0;
-	/* Shut the interrupt to the CPU up and schedule the actual
-	 * handler; we can't check that the IRQ is asserted. */
-#if (WM831X_IRQ_TYPE == IRQF_TRIGGER_LOW)
-	disable_irq_nosync(irq);
-#endif
-	wake_lock(&wm831x->irq_wake);
-	if(wm831x->flag_suspend)
-	{
-		spin_lock(&wm831x->flag_lock);
-		wm831x->flag_suspend = 0;
-		spin_unlock(&wm831x->flag_lock);
-		msdelay = 50;	//wait for spi/i2c resume
-		printk("%s:msdelay=%d\n",__FUNCTION__,msdelay);
-	}
-	else
-		msdelay = 0;
-		
-	queue_delayed_work(wm831x->irq_wq, &wm831x->irq_work, msecs_to_jiffies(msdelay));
-	//printk("%s\n",__FUNCTION__);
 	return IRQ_HANDLED;
 }
 
@@ -641,7 +504,7 @@ int wm831x_irq_init(struct wm831x *wm831x, int irq)
 {
 	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
 	int i, cur_irq, ret;
-	printk( "wm831x_irq_init:irq=%d,%d\n",irq,pdata->irq_base);
+
 	mutex_init(&wm831x->irq_lock);
 
 	/* Mask the individual interrupt sources */
@@ -652,42 +515,34 @@ int wm831x_irq_init(struct wm831x *wm831x, int irq)
 				 0xffff);
 	}
 
-	if (!irq) {
-		dev_warn(wm831x->dev,
-			 "No interrupt specified - functionality limited\n");
-		return 0;
-	}
-
 	if (!pdata || !pdata->irq_base) {
 		dev_err(wm831x->dev,
 			"No interrupt base specified, no interrupts\n");
 		return 0;
 	}
 
-	wm831x->irq_wq = create_singlethread_workqueue("wm831x-irq");
-	if (!wm831x->irq_wq) {
-		dev_err(wm831x->dev, "Failed to allocate IRQ worker\n");
-		return -ESRCH;
+	if (pdata->irq_cmos)
+		i = 0;
+	else
+		i = WM831X_IRQ_OD;
+
+	wm831x_set_bits(wm831x, WM831X_IRQ_CONFIG,
+			WM831X_IRQ_OD, i);
+
+	/* Try to flag /IRQ as a wake source; there are a number of
+	 * unconditional wake sources in the PMIC so this isn't
+	 * conditional but we don't actually care *too* much if it
+	 * fails.
+	 */
+	ret = enable_irq_wake(irq);
+	if (ret != 0) {
+		dev_warn(wm831x->dev, "Can't enable IRQ as wake source: %d\n",
+			 ret);
 	}
 
-	
 	wm831x->irq = irq;
-	wm831x->flag_suspend = 0;
 	wm831x->irq_base = pdata->irq_base;
-	INIT_DELAYED_WORK(&wm831x->irq_work, wm831x_irq_worker);
-	wake_lock_init(&wm831x->irq_wake, WAKE_LOCK_SUSPEND, "wm831x_irq_wake");
-	wake_lock_init(&wm831x->handle_wake, WAKE_LOCK_SUSPEND, "wm831x_handle_wake");
-#if WM831X_IRQ_LIST
-	wm831x->handle_wq = create_workqueue("wm831x_handle_wq");
-	if (!wm831x->handle_wq) {
-		printk("cannot create workqueue\n");
-		return -EBUSY;
-	}
-	INIT_WORK(&wm831x->handle_work, wm831x_handle_worker);
-	INIT_LIST_HEAD(&wm831x->handle_queue);
 
-#endif
-	
 	/* Register them with genirq */
 	for (cur_irq = wm831x->irq_base;
 	     cur_irq < ARRAY_SIZE(wm831x_irqs) + wm831x->irq_base;
@@ -705,22 +560,23 @@ int wm831x_irq_init(struct wm831x *wm831x, int irq)
 		irq_set_noprobe(cur_irq);
 #endif
 	}
-#if (WM831X_IRQ_TYPE == IRQF_TRIGGER_LOW)
-	ret = request_threaded_irq(wm831x->irq, wm831x_irq_thread, NULL, 
-				 IRQF_TRIGGER_LOW| IRQF_ONESHOT,//IRQF_TRIGGER_FALLING, // 
-				   "wm831x", wm831x);
-#else
-	ret = request_threaded_irq(wm831x->irq, wm831x_irq_thread, NULL, 
-				 IRQF_TRIGGER_FALLING, //IRQF_TRIGGER_LOW| IRQF_ONESHOT,// 
-				   "wm831x", wm831x);
-#endif
-	if (ret != 0) {
-		dev_err(wm831x->dev, "Failed to request IRQ %d: %d\n",
-			wm831x->irq, ret);
-		return ret;
+
+	if (irq) {
+		ret = request_threaded_irq(irq, NULL, wm831x_irq_thread,
+					   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+					   "wm831x", wm831x);
+		if (ret != 0) {
+			dev_err(wm831x->dev, "Failed to request IRQ %d: %d\n",
+				irq, ret);
+			return ret;
+		}
+	} else {
+		dev_warn(wm831x->dev,
+			 "No interrupt specified - functionality limited\n");
 	}
 
-	enable_irq_wake(wm831x->irq); // so wm831x irq can wake up system
+
+
 	/* Enable top level interrupts, we mask at secondary level */
 	wm831x_reg_write(wm831x, WM831X_SYSTEM_INTERRUPTS_MASK, 0);
 
diff --git a/drivers/mfd/wm831x-spi.c b/drivers/mfd/wm831x-spi.c
index 2411ea55c21c..eed8e4f7a5a1 100644
--- a/drivers/mfd/wm831x-spi.c
+++ b/drivers/mfd/wm831x-spi.c
@@ -16,7 +16,6 @@
 #include <linux/module.h>
 #include <linux/pm.h>
 #include <linux/spi/spi.h>
-#include <linux/gpio.h>
 
 #include <linux/mfd/wm831x/core.h>
 
@@ -29,14 +28,14 @@ static int wm831x_spi_read_device(struct wm831x *wm831x, unsigned short reg,
 
 	/* Go register at a time */
 	for (r = reg; r < reg + (bytes / 2); r++) {
-		tx_val = cpu_to_be16(r | 0x8000);
-		//printk("read:reg=0x%x,",reg);
+		tx_val = r | 0x8000;
+
 		ret = spi_write_then_read(wm831x->control_data,
 					  (u8 *)&tx_val, 2, (u8 *)d, 2);
 		if (ret != 0)
 			return ret;
-		//printk("rec=0x%x\n",be16_to_cpu(*d));
-		//*d = be16_to_cpu(*d);
+
+		*d = be16_to_cpu(*d);
 
 		d++;
 	}
@@ -54,9 +53,9 @@ static int wm831x_spi_write_device(struct wm831x *wm831x, unsigned short reg,
 
 	/* Go register at a time */
 	for (r = reg; r < reg + (bytes / 2); r++) {
-		data[0] = cpu_to_be16(r);
+		data[0] = r;
 		data[1] = *s++;
-		//printk("write:reg=0x%x,send=0x%x\n",reg, data[0]);
+
 		ret = spi_write(spi, (char *)&data, sizeof(data));
 		if (ret != 0)
 			return ret;
@@ -69,7 +68,6 @@ static int __devinit wm831x_spi_probe(struct spi_device *spi)
 {
 	struct wm831x *wm831x;
 	enum wm831x_parent type;
-	int ret,gpio,irq;
 
 	/* Currently SPI support for ID tables is unmerged, we're faking it */
 	if (strcmp(spi->modalias, "wm8310") == 0)
@@ -98,26 +96,13 @@ static int __devinit wm831x_spi_probe(struct spi_device *spi)
 	spi->bits_per_word = 16;
 	spi->mode = SPI_MODE_0;
 
-	gpio = spi->irq;
-	ret = gpio_request(gpio, "wm831x");
-	if (ret) {
-		printk( "failed to request rk gpio irq for wm831x \n");
-		return ret;
-	}
-	gpio_pull_updown(gpio, GPIOPullUp);
-	if (ret) {
-	    printk("failed to pull up gpio irq for wm831x \n");
-		return ret;
-	}	
-	irq = gpio_to_irq(gpio);
-
 	dev_set_drvdata(&spi->dev, wm831x);
 	wm831x->dev = &spi->dev;
 	wm831x->control_data = spi;
 	wm831x->read_dev = wm831x_spi_read_device;
 	wm831x->write_dev = wm831x_spi_write_device;
 
-	return wm831x_device_init(wm831x, type, irq);
+	return wm831x_device_init(wm831x, type, spi->irq);
 }
 
 static int __devexit wm831x_spi_remove(struct spi_device *spi)
@@ -133,9 +118,6 @@ static int wm831x_spi_suspend(struct device *dev)
 {
 	struct wm831x *wm831x = dev_get_drvdata(dev);
 
-	spin_lock(&wm831x->flag_lock);
-	wm831x->flag_suspend = 1;
-	spin_unlock(&wm831x->flag_lock);
 	return wm831x_device_suspend(wm831x);
 }
 
diff --git a/drivers/mfd/wm8994-core.c b/drivers/mfd/wm8994-core.c
index 1dce22260ded..e198d40292e7 100644
--- a/drivers/mfd/wm8994-core.c
+++ b/drivers/mfd/wm8994-core.c
@@ -25,18 +25,7 @@
 #include <linux/mfd/wm8994/core.h>
 #include <linux/mfd/wm8994/pdata.h>
 #include <linux/mfd/wm8994/registers.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
 
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
-#include <sound/soc.h>
-#endif
-
-#if 0
-#define DBG(x...) printk(KERN_DEBUG x)
-#else
-#define DBG(x...) do { } while (0)
-#endif
 static int wm8994_read(struct wm8994 *wm8994, unsigned short reg,
 		       int bytes, void *dest)
 {
@@ -74,7 +63,7 @@ int wm8994_reg_read(struct wm8994 *wm8994, unsigned short reg)
 	ret = wm8994_read(wm8994, reg, 2, &val);
 
 	mutex_unlock(&wm8994->io_lock);
-	DBG("%s:0x%04x = 0x%04x\n",__FUNCTION__,reg,be16_to_cpu(val));
+
 	if (ret < 0)
 		return ret;
 	else
@@ -135,7 +124,7 @@ int wm8994_reg_write(struct wm8994 *wm8994, unsigned short reg,
 	int ret;
 
 	val = cpu_to_be16(val);
-	DBG("%s:0x%04x = 0x%04x\n",__FUNCTION__,reg,val);
+
 	mutex_lock(&wm8994->io_lock);
 
 	ret = wm8994_write(wm8994, reg, 2, &val);
@@ -255,13 +244,13 @@ static struct mfd_cell wm8994_devs[] = {
  * management.
  */
 static const char *wm8994_main_supplies[] = {
-//	"DBVDD",
-//	"DCVDD",
-//	"AVDD1",
-//	"AVDD2",
-//	"CPVDD",
-//	"SPKVDD1",
-//	"SPKVDD2",
+	"DBVDD",
+	"DCVDD",
+	"AVDD1",
+	"AVDD2",
+	"CPVDD",
+	"SPKVDD1",
+	"SPKVDD2",
 };
 
 static const char *wm8958_main_supplies[] = {
@@ -279,16 +268,9 @@ static const char *wm8958_main_supplies[] = {
 #ifdef CONFIG_PM
 static int wm8994_suspend(struct device *dev)
 {
-	struct wm8994 *wm8994 = dev_get_drvdata(dev);	
+	struct wm8994 *wm8994 = dev_get_drvdata(dev);
 	int ret;
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
-	printk("on wm8994-core.c wm8994_suspend\n");
-	if(snd_soc_incall_status(0,0))
-	{
-		DBG("incalling  cannot suspend\n");
-		return 0;
-	}
-#endif
+
 	/* Don't actually go through with the suspend if the CODEC is
 	 * still active (eg, for audio passthrough from CP. */
 	ret = wm8994_reg_read(wm8994, WM8994_POWER_MANAGEMENT_1);
@@ -333,16 +315,9 @@ static int wm8994_suspend(struct device *dev)
 
 static int wm8994_resume(struct device *dev)
 {
-	struct wm8994 *wm8994 = dev_get_drvdata(dev);		
+	struct wm8994 *wm8994 = dev_get_drvdata(dev);
 	int ret;
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
-	printk("on wm8994-core.c wm8994_resume\n");
-	if(snd_soc_incall_status(0,0))
-	{
-		DBG("incalling cannot resume\n");
-		return 0;
-	}
-#endif
+
 	/* We may have lied to the PM core about suspending */
 	if (!wm8994->suspended)
 		return 0;
@@ -610,28 +585,26 @@ static int wm8994_i2c_read_device(struct wm8994 *wm8994, unsigned short reg,
 static int wm8994_i2c_write_device(struct wm8994 *wm8994, unsigned short reg,
 				   int bytes, const void *src)
 {
-
 	struct i2c_client *i2c = wm8994->control_data;
-	struct i2c_msg xfer;	
-	unsigned char msg[bytes + 2];
+	struct i2c_msg xfer[2];
 	int ret;
 
 	reg = cpu_to_be16(reg);
-	memcpy(&msg[0], &reg, 2);
-	memcpy(&msg[2], src, bytes);
-	
-	xfer.addr = i2c->addr;
-	xfer.flags = i2c->flags;
-	xfer.len = bytes + 2;
-	xfer.buf = (char *)msg;
-	xfer.scl_rate = 100 * 1000;
-	xfer.udelay = i2c->udelay;
-	xfer.read_type = 0;
-	
-	ret = i2c_transfer(i2c->adapter, &xfer, 1);
+
+	xfer[0].addr = i2c->addr;
+	xfer[0].flags = 0;
+	xfer[0].len = 2;
+	xfer[0].buf = (char *)&reg;
+
+	xfer[1].addr = i2c->addr;
+	xfer[1].flags = I2C_M_NOSTART;
+	xfer[1].len = bytes;
+	xfer[1].buf = (char *)src;
+
+	ret = i2c_transfer(i2c->adapter, xfer, 2);
 	if (ret < 0)
 		return ret;
-	if (ret != 1)
+	if (ret != 2)
 		return -EIO;
 
 	return 0;
@@ -641,7 +614,7 @@ static int wm8994_i2c_probe(struct i2c_client *i2c,
 			    const struct i2c_device_id *id)
 {
 	struct wm8994 *wm8994;
-	
+
 	wm8994 = kzalloc(sizeof(struct wm8994), GFP_KERNEL);
 	if (wm8994 == NULL)
 		return -ENOMEM;
@@ -666,20 +639,6 @@ static int wm8994_i2c_remove(struct i2c_client *i2c)
 	return 0;
 }
 
-static void wm8994_i2c_shutdown(struct i2c_client *i2c)
-{
-	struct wm8994 *wm8994 = i2c_get_clientdata(i2c);
-	struct wm8994_pdata *pdata = wm8994->dev->platform_data;
-
-	DBG("%s----%d\n",__FUNCTION__,__LINE__);
-	
-	//disable PA	
-	gpio_direction_output(pdata->PA_control_pin,GPIO_LOW);
-	if (gpio_is_valid(pdata->PA_control_pin))
-		gpio_free(pdata->PA_control_pin);
-
-}
-
 static const struct i2c_device_id wm8994_i2c_id[] = {
 	{ "wm8994", WM8994 },
 	{ "wm8958", WM8958 },
@@ -698,7 +657,6 @@ static struct i2c_driver wm8994_i2c_driver = {
 	},
 	.probe = wm8994_i2c_probe,
 	.remove = wm8994_i2c_remove,
-	.shutdown = wm8994_i2c_shutdown,
 	.id_table = wm8994_i2c_id,
 };
 
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 49fb1da17e77..051bfe9534aa 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -399,16 +399,6 @@ config SENSORS_AK8975
 	  If you say yes here you get support for Asahi Kasei's
 	  orientation sensor AK8975.
 
-
-config SENSORS_AK8963
-       tristate "AK8963 compass support"
-       default n
-       depends on I2C
-       help
-         If you say yes here you get support for Asahi Kasei's
-         orientation sensor AK8963.
-
-
 config EP93XX_PWM
 	tristate "EP93xx PWM support"
 	depends on ARCH_EP93XX
@@ -535,49 +525,12 @@ config APANIC_PLABEL
 	 If your platform uses a different flash partition label for storing
  	 crashdumps, enter it here.
 
-config MTK23D
-	bool "MTK6223D modem control driver"
-	default n	
-	
-config FM580X
-	bool "FM rda580x driver"
-
-config RK29_SC8800
-	bool "SC8800 misc driver"
-	default n
-
-config TDSC8800
-	bool "TDSC8800 modem control driver"
-	default n
-config MODEM_SOUND
-	bool "modem sound control driver"
-	default n
-config MODEM_MIC_SWITCH
-	bool "3g modem mic switch control"
-	depends on MODEM_SOUND
-	default n
-	
-config TCC_BT_DEV
-	tristate "TCC Bluetooth dev Control power"
-	default n
-	help
-	  If you say Y here, you can contorl the power of the BT H/W Module
-config AC_USB_SWITCH
-	bool "for androidComputer external usb devices switch"
-	default n
-
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
-source "drivers/misc/rk29_modem/Kconfig"
-source "drivers/misc/gps/Kconfig"
-source "drivers/misc/inv_mpu/Kconfig"
 source "drivers/misc/iwmc3200top/Kconfig"
 source "drivers/misc/ti-st/Kconfig"
 source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/carma/Kconfig"
-source "drivers/misc/bp/Kconfig"
-source "drivers/misc/rk2928_callpad_misc/Kconfig"
-source "drivers/misc/3g_module/Kconfig"
-source "drivers/misc/scaler/Kconfig"
+
 endif # MISC_DEVICES
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 04e973cd3e78..606b27f4cb2b 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -50,18 +50,3 @@ obj-y				+= carma/
 obj-$(CONFIG_WL127X_RFKILL)	+= wl127x-rfkill.o
 obj-$(CONFIG_APANIC)		+= apanic.o
 obj-$(CONFIG_SENSORS_AK8975)	+= akm8975.o
-obj-$(CONFIG_SENSORS_AK8963)   += akm8963.o
-obj-$(CONFIG_MTK23D)		+= mtk23d.o
-obj-$(CONFIG_FM580X)		+= fm580x.o
-obj-$(CONFIG_RK29_SUPPORT_MODEM)	+= rk29_modem/
-obj-$(CONFIG_3G_MODULE)     += 3g_module/
-obj-$(CONFIG_BP_AUTO)		+= bp/
-obj-$(CONFIG_GPS_DEVICES)	+= gps/
-obj-y += inv_mpu/
-obj-$(CONFIG_TDSC8800) += tdsc8800.o
-obj-$(CONFIG_RK29_SC8800)	+=	sc8800.o
-obj-y += rk2928_callpad_misc/
-obj-$(CONFIG_MODEM_SOUND) += modem_sound.o
-obj-$(CONFIG_TCC_BT_DEV)       += tcc_bt_dev.o
-obj-$(CONFIG_AC_USB_SWITCH) += ac_usb_switch.o
-obj-$(CONFIG_SCALER_DEVICE)		+= scaler/
diff --git a/drivers/misc/apanic.c b/drivers/misc/apanic.c
index 58cc36e25ada..ca875f89da7a 100644
--- a/drivers/misc/apanic.c
+++ b/drivers/misc/apanic.c
@@ -193,13 +193,8 @@ static int apanic_proc_read(char *buffer, char **start, off_t offset,
 		ctx->mtd->writesize,
 		&len, ctx->bounce);
 
-#ifdef CONFIG_MTD_RKNAND
-	if (count > (ctx->mtd->writesize - page_offset))
-		count = ctx->mtd->writesize - page_offset;
-#else
 	if (page_offset)
 		count -= page_offset;
-#endif
 	memcpy(buffer, ctx->bounce + page_offset, count);
 
 	*start = count;
@@ -214,11 +209,6 @@ static int apanic_proc_read(char *buffer, char **start, off_t offset,
 static void mtd_panic_erase(void)
 {
 	struct apanic_data *ctx = &drv_ctx;
-#ifdef CONFIG_MTD_RKNAND
-	size_t wlen;
-	memset(ctx->bounce, 0, ctx->mtd->writesize);
-	ctx->mtd->write(ctx->mtd, 0, ctx->mtd->writesize, &wlen, ctx->bounce);
-#else
 	struct erase_info erase;
 	DECLARE_WAITQUEUE(wait, current);
 	wait_queue_head_t wait_q;
@@ -270,7 +260,6 @@ static void mtd_panic_erase(void)
 		schedule();
 		remove_wait_queue(&wait_q, &wait);
 	}
-#endif
 	printk(KERN_DEBUG "apanic: %s partition erased\n",
 	       CONFIG_APANIC_PLABEL);
 out:
@@ -342,18 +331,14 @@ static void mtd_panic_notify_add(struct mtd_info *mtd)
 
 	if (hdr->magic != PANIC_MAGIC) {
 		printk(KERN_INFO "apanic: No panic data available\n");
-#ifndef CONFIG_MTD_RKNAND
 		mtd_panic_erase();
-#endif
 		return;
 	}
 
 	if (hdr->version != PHDR_VERSION) {
 		printk(KERN_INFO "apanic: Version mismatch (%d != %d)\n",
 		       hdr->version, PHDR_VERSION);
-#ifndef CONFIG_MTD_RKNAND
 		mtd_panic_erase();
-#endif
 		return;
 	}
 
@@ -393,10 +378,8 @@ static void mtd_panic_notify_add(struct mtd_info *mtd)
 		}
 	}
 
-#ifndef CONFIG_MTD_RKNAND
 	if (!proc_entry_created)
 		mtd_panic_erase();
-#endif
 
 	return;
 out_err:
@@ -528,7 +511,7 @@ static int apanic(struct notifier_block *this, unsigned long event,
 		printk(KERN_EMERG "Crash partition in use!\n");
 		goto out;
 	}
-	console_offset = ctx->mtd->erasesize;
+	console_offset = ctx->mtd->writesize;
 
 	/*
 	 * Write out the console
@@ -548,9 +531,7 @@ static int apanic(struct notifier_block *this, unsigned long event,
 	if (!threads_offset)
 		threads_offset = ctx->mtd->writesize;
 
-#ifdef CONFIG_ANDROID_RAM_CONSOLE
 	ram_console_enable_console(0);
-#endif
 
 	log_buf_clear();
 	show_state_filter(0);
diff --git a/drivers/mmc/card/Kconfig b/drivers/mmc/card/Kconfig
index 25050e9e8b06..ebb4afe6c702 100644
--- a/drivers/mmc/card/Kconfig
+++ b/drivers/mmc/card/Kconfig
@@ -18,7 +18,6 @@ config MMC_BLOCK_MINORS
 	int "Number of minors per block device"
 	depends on MMC_BLOCK
 	range 4 256
-	default 32 if EMMC_RK
 	default 8
 	help
 	  Number of minors per block device. One is needed for every
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 87b361f94b4b..435f1fddfe6b 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -106,16 +106,6 @@ struct mmc_blk_data {
 
 static DEFINE_MUTEX(open_lock);
 
-enum mmc_blk_status {
-	MMC_BLK_SUCCESS = 0,
-	MMC_BLK_PARTIAL,
-	MMC_BLK_RETRY,
-	MMC_BLK_RETRY_SINGLE,
-	MMC_BLK_DATA_ERR,
-	MMC_BLK_CMD_ERR,
-	MMC_BLK_ABORT,
-};
-
 module_param(perdev_minors, int, 0444);
 MODULE_PARM_DESC(perdev_minors, "Minors numbers to allocate per device");
 
@@ -441,6 +431,14 @@ static const struct block_device_operations mmc_bdops = {
 #endif
 };
 
+struct mmc_blk_request {
+	struct mmc_request	mrq;
+	struct mmc_command	sbc;
+	struct mmc_command	cmd;
+	struct mmc_command	stop;
+	struct mmc_data		data;
+};
+
 static inline int mmc_blk_part_switch(struct mmc_card *card,
 				      struct mmc_blk_data *md)
 {
@@ -693,7 +691,8 @@ static int mmc_blk_cmd_recovery(struct mmc_card *card, struct request *req,
 	}
 	return ERR_CONTINUE;
 }
-static int sdmmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
+
+static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
 	struct mmc_card *card = md->queue.card;
@@ -732,54 +731,7 @@ static int sdmmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
 	return err ? 0 : 1;
 }
 
-static int emmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
-{
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-	unsigned int from, nr, arg;
-	int err = 0;
-
-	if (!mmc_can_erase(card)) {
-		err = -EOPNOTSUPP;
-		goto out;
-	}
-
-	from = blk_rq_pos(req);
-	nr = blk_rq_sectors(req);
-
-	if (mmc_can_trim(card))
-		arg = MMC_TRIM_ARG;
-	else
-		arg = MMC_ERASE_ARG;
-
-	if (card->quirks & MMC_QUIRK_INAND_CMD38) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 INAND_CMD38_ARG_EXT_CSD,
-				 arg == MMC_TRIM_ARG ?
-				 INAND_CMD38_ARG_TRIM :
-				 INAND_CMD38_ARG_ERASE,
-				 0);
-		if (err)
-			goto out;
-	}
-	err = mmc_erase(card, from, nr, arg);
-out:
-	blk_end_request(req, err, blk_rq_bytes(req));
-
-	return err ? 0 : 1;
-}
-
-static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
-{
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-
-	if(HOST_IS_EMMC(card->host))
-		return emmc_blk_issue_discard_rq(mq, req);
-	else
-		return sdmmc_blk_issue_discard_rq(mq, req);
-}
-static int sdmmc_blk_issue_secdiscard_rq(struct mmc_queue *mq,
+static int mmc_blk_issue_secdiscard_rq(struct mmc_queue *mq,
 				       struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
@@ -829,68 +781,8 @@ static int sdmmc_blk_issue_secdiscard_rq(struct mmc_queue *mq,
 
 	return err ? 0 : 1;
 }
-static int emmc_blk_issue_secdiscard_rq(struct mmc_queue *mq,
-				       struct request *req)
-{
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-	unsigned int from, nr, arg;
-	int err = 0;
-
-	if (!mmc_can_secure_erase_trim(card)) {
-		err = -EOPNOTSUPP;
-		goto out;
-	}
-
-	from = blk_rq_pos(req);
-	nr = blk_rq_sectors(req);
-
-	if (mmc_can_trim(card) && !mmc_erase_group_aligned(card, from, nr))
-		arg = MMC_SECURE_TRIM1_ARG;
-	else
-		arg = MMC_SECURE_ERASE_ARG;
-
-	if (card->quirks & MMC_QUIRK_INAND_CMD38) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 INAND_CMD38_ARG_EXT_CSD,
-				 arg == MMC_SECURE_TRIM1_ARG ?
-				 INAND_CMD38_ARG_SECTRIM1 :
-				 INAND_CMD38_ARG_SECERASE,
-				 0);
-		if (err)
-			goto out;
-	}
-	err = mmc_erase(card, from, nr, arg);
-	if (!err && arg == MMC_SECURE_TRIM1_ARG) {
-		if (card->quirks & MMC_QUIRK_INAND_CMD38) {
-			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-					 INAND_CMD38_ARG_EXT_CSD,
-					 INAND_CMD38_ARG_SECTRIM2,
-					 0);
-			if (err)
-				goto out;
-		}
-		err = mmc_erase(card, from, nr, MMC_SECURE_TRIM2_ARG);
-	}
-out:
-	blk_end_request(req, err, blk_rq_bytes(req));
-
-	return err ? 0 : 1;
-}
 
-static int mmc_blk_issue_secdiscard_rq(struct mmc_queue *mq,
-				       struct request *req)
-{
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-	
-	if(HOST_IS_EMMC(card->host))
-		return emmc_blk_issue_secdiscard_rq(mq, req);
-	else
-		return sdmmc_blk_issue_secdiscard_rq(mq, req);
-}
-
-static int sdmmc_blk_issue_flush(struct mmc_queue *mq, struct request *req)
+static int mmc_blk_issue_flush(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
 
@@ -905,30 +797,6 @@ static int sdmmc_blk_issue_flush(struct mmc_queue *mq, struct request *req)
 	return 1;
 }
 
-
-static int emmc_blk_issue_flush(struct mmc_queue *mq, struct request *req)
-{
-	//struct mmc_blk_data *md = mq->data;
-
-	/*
-	 * No-op, only service this because we need REQ_FUA for reliable
-	 * writes.
-	 */
-	blk_end_request_all(req, 0);
-
-	return 1;
-}
-
-static int mmc_blk_issue_flush(struct mmc_queue *mq, struct request *req)
-{
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-
-	if(HOST_IS_EMMC(card->host))
-		return emmc_blk_issue_flush(mq, req);
-	else
-		return sdmmc_blk_issue_flush(mq, req);
-}
 /*
  * Reformat current write as a reliable write, supporting
  * both legacy and the enhanced reliable write MMC cards.
@@ -960,11 +828,11 @@ static inline void mmc_apply_rel_rw(struct mmc_blk_request *brq,
 	 R1_CC_ERROR |		/* Card controller error */		\
 	 R1_ERROR)		/* General/unknown error */
 
-static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
+static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
 	struct mmc_card *card = md->queue.card;
-	struct mmc_blk_request *brq = &mq->mqrq_cur->brq;
+	struct mmc_blk_request brq;
 	int ret = 1, disable_multi = 0, retry = 0;
 
 	/*
@@ -979,64 +847,60 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 	do {
 		u32 readcmd, writecmd;
 
-		memset(brq, 0, sizeof(struct mmc_blk_request));
-		brq->mrq.cmd = &brq->cmd;
-		brq->mrq.data = &brq->data;
-
-            #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-                brq->cmd.retries = 2; //suppot retry read-write; added by xbw@2012-07-14
-            #endif
+		memset(&brq, 0, sizeof(struct mmc_blk_request));
+		brq.mrq.cmd = &brq.cmd;
+		brq.mrq.data = &brq.data;
 
-		brq->cmd.arg = blk_rq_pos(req);
+		brq.cmd.arg = blk_rq_pos(req);
 		if (!mmc_card_blockaddr(card))
-			brq->cmd.arg <<= 9;
-		brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
-		brq->data.blksz = 512;
-		brq->stop.opcode = MMC_STOP_TRANSMISSION;
-		brq->stop.arg = 0;
-		brq->stop.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
-		brq->data.blocks = blk_rq_sectors(req);
+			brq.cmd.arg <<= 9;
+		brq.cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
+		brq.data.blksz = 512;
+		brq.stop.opcode = MMC_STOP_TRANSMISSION;
+		brq.stop.arg = 0;
+		brq.stop.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
+		brq.data.blocks = blk_rq_sectors(req);
 
 		/*
 		 * The block layer doesn't support all sector count
 		 * restrictions, so we need to be prepared for too big
 		 * requests.
 		 */
-		if (brq->data.blocks > card->host->max_blk_count)
-			brq->data.blocks = card->host->max_blk_count;
+		if (brq.data.blocks > card->host->max_blk_count)
+			brq.data.blocks = card->host->max_blk_count;
 
 		/*
 		 * After a read error, we redo the request one sector at a time
 		 * in order to accurately determine which sectors can be read
 		 * successfully.
 		 */
-		if (disable_multi && brq->data.blocks > 1)
-			brq->data.blocks = 1;
+		if (disable_multi && brq.data.blocks > 1)
+			brq.data.blocks = 1;
 
-		if (brq->data.blocks > 1 || do_rel_wr) {
+		if (brq.data.blocks > 1 || do_rel_wr) {
 			/* SPI multiblock writes terminate using a special
 			 * token, not a STOP_TRANSMISSION request.
 			 */
 			if (!mmc_host_is_spi(card->host) ||
 			    rq_data_dir(req) == READ)
-				brq->mrq.stop = &brq->stop;
+				brq.mrq.stop = &brq.stop;
 			readcmd = MMC_READ_MULTIPLE_BLOCK;
 			writecmd = MMC_WRITE_MULTIPLE_BLOCK;
 		} else {
-			brq->mrq.stop = NULL;
+			brq.mrq.stop = NULL;
 			readcmd = MMC_READ_SINGLE_BLOCK;
 			writecmd = MMC_WRITE_BLOCK;
 		}
 		if (rq_data_dir(req) == READ) {
-			brq->cmd.opcode = readcmd;
-			brq->data.flags |= MMC_DATA_READ;
+			brq.cmd.opcode = readcmd;
+			brq.data.flags |= MMC_DATA_READ;
 		} else {
-			brq->cmd.opcode = writecmd;
-			brq->data.flags |= MMC_DATA_WRITE;
+			brq.cmd.opcode = writecmd;
+			brq.data.flags |= MMC_DATA_WRITE;
 		}
 
 		if (do_rel_wr)
-			mmc_apply_rel_rw(brq, card, req);
+			mmc_apply_rel_rw(&brq, card, req);
 
 		/*
 		 * Pre-defined multi-block transfers are preferable to
@@ -1058,29 +922,29 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 		 */
 
 		if ((md->flags & MMC_BLK_CMD23) &&
-		    mmc_op_multi(brq->cmd.opcode) &&
+		    mmc_op_multi(brq.cmd.opcode) &&
 		    (do_rel_wr || !(card->quirks & MMC_QUIRK_BLK_NO_CMD23))) {
-			brq->sbc.opcode = MMC_SET_BLOCK_COUNT;
-			brq->sbc.arg = brq->data.blocks |
+			brq.sbc.opcode = MMC_SET_BLOCK_COUNT;
+			brq.sbc.arg = brq.data.blocks |
 				(do_rel_wr ? (1 << 31) : 0);
-			brq->sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
-			brq->mrq.sbc = &brq->sbc;
+			brq.sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
+			brq.mrq.sbc = &brq.sbc;
 		}
 
-		mmc_set_data_timeout(&brq->data, card);
+		mmc_set_data_timeout(&brq.data, card);
 
-		brq->data.sg = mq->mqrq_cur->sg;
-		brq->data.sg_len = mmc_queue_map_sg(mq, mq->mqrq_cur);
+		brq.data.sg = mq->sg;
+		brq.data.sg_len = mmc_queue_map_sg(mq);
 
 		/*
 		 * Adjust the sg list so it is the same size as the
 		 * request.
 		 */
-		if (brq->data.blocks != blk_rq_sectors(req)) {
-			int i, data_size = brq->data.blocks << 9;
+		if (brq.data.blocks != blk_rq_sectors(req)) {
+			int i, data_size = brq.data.blocks << 9;
 			struct scatterlist *sg;
 
-			for_each_sg(brq->data.sg, sg, brq->data.sg_len, i) {
+			for_each_sg(brq.data.sg, sg, brq.data.sg_len, i) {
 				data_size -= sg->length;
 				if (data_size <= 0) {
 					sg->length += data_size;
@@ -1088,18 +952,15 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 					break;
 				}
 			}
-			brq->data.sg_len = i;
+			brq.data.sg_len = i;
 		}
 
-		mmc_queue_bounce_pre(mq->mqrq_cur);
+		mmc_queue_bounce_pre(mq);
 
-		mmc_wait_for_req(card->host, &brq->mrq);
+		mmc_wait_for_req(card->host, &brq.mrq);
 
-		mmc_queue_bounce_post(mq->mqrq_cur);
+		mmc_queue_bounce_post(mq);
 
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-    //delete all retry code. modifyed by xbw at 2011-11-17
-#else
 		/*
 		 * sbc.error indicates a problem with the set block count
 		 * command.  No data will have been transferred.
@@ -1110,8 +971,8 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 		 * stop.error indicates a problem with the stop command.  Data
 		 * may have been transferred, or may still be transferring.
 		 */
-		if (brq->sbc.error || brq->cmd.error || brq->stop.error) {
-			switch (mmc_blk_cmd_recovery(card, req, brq)) {
+		if (brq.sbc.error || brq.cmd.error || brq.stop.error) {
+			switch (mmc_blk_cmd_recovery(card, req, &brq)) {
 			case ERR_RETRY:
 				if (retry++ < 5)
 					continue;
@@ -1121,22 +982,18 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 				break;
 			}
 		}
-#endif		
 
 		/*
 		 * Check for errors relating to the execution of the
 		 * initial command - such as address errors.  No data
 		 * has been transferred.
 		 */
-		if (brq->cmd.resp[0] & CMD_ERRORS) {
+		if (brq.cmd.resp[0] & CMD_ERRORS) {
 			pr_err("%s: r/w command failed, status = %#x\n",
-				req->rq_disk->disk_name, brq->cmd.resp[0]);
+				req->rq_disk->disk_name, brq.cmd.resp[0]);
 			goto cmd_abort;
 		}
 
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-    //delete all retry code. modifyed by xbw at 2011-11-17
-#else    
 		/*
 		 * Everything else is either success, or a data error of some
 		 * kind.  If it was a write, we may have transitioned to
@@ -1159,30 +1016,22 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 			} while (!(status & R1_READY_FOR_DATA) ||
 				 (R1_CURRENT_STATE(status) == R1_STATE_PRG));
 		}
-#endif
 
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-        if (brq->sbc.error || brq->cmd.error || brq->stop.error || brq->data.error) {   //modifyed by xbw at 2011-11-17
-#else
-		if (brq->data.error) {
+		if (brq.data.error) {
 			pr_err("%s: error %d transferring data, sector %u, nr %u, cmd response %#x, card status %#x\n",
-				req->rq_disk->disk_name, brq->data.error,
+				req->rq_disk->disk_name, brq.data.error,
 				(unsigned)blk_rq_pos(req),
 				(unsigned)blk_rq_sectors(req),
-				brq->cmd.resp[0], brq->stop.resp[0]);
-#endif
+				brq.cmd.resp[0], brq.stop.resp[0]);
+
 			if (rq_data_dir(req) == READ) {
-			  #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-			  //direct to exit when error happen; deleted by xbw at 2011-12-14
-			  #else
-				if (brq->data.blocks > 1) {
+				if (brq.data.blocks > 1) {
 					/* Redo read one sector at a time */
 					pr_warning("%s: retrying using single block read\n",
 						req->rq_disk->disk_name);
 					disable_multi = 1;
 					continue;
 				}
-				#endif
 
 				/*
 				 * After an error, we redo I/O one sector at a
@@ -1190,7 +1039,7 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 				 * read a single sector.
 				 */
 				spin_lock_irq(&md->lock);
-				ret = __blk_end_request(req, -EIO, brq->data.blksz);
+				ret = __blk_end_request(req, -EIO, brq.data.blksz);
 				spin_unlock_irq(&md->lock);
 				continue;
 			} else {
@@ -1202,7 +1051,7 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 		 * A block was successfully transferred.
 		 */
 		spin_lock_irq(&md->lock);
-		ret = __blk_end_request(req, 0, brq->data.bytes_xfered);
+		ret = __blk_end_request(req, 0, brq.data.bytes_xfered);
 		spin_unlock_irq(&md->lock);
 	} while (ret);
 
@@ -1228,7 +1077,7 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 		}
 	} else {
 		spin_lock_irq(&md->lock);
-		ret = __blk_end_request(req, 0, brq->data.bytes_xfered);
+		ret = __blk_end_request(req, 0, brq.data.bytes_xfered);
 		spin_unlock_irq(&md->lock);
 	}
 
@@ -1240,389 +1089,36 @@ static int sdmmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
 
 	return 0;
 }
-static int mmc_blk_err_check(struct mmc_card *card,
-			     struct mmc_async_req *areq)
-{
-	enum mmc_blk_status ret = MMC_BLK_SUCCESS;
-	struct mmc_queue_req *mq_mrq = container_of(areq, struct mmc_queue_req,
-						    mmc_active);
-	struct mmc_blk_request *brq = &mq_mrq->brq;
-	struct request *req = mq_mrq->req;
-
-	/*
-	 * sbc.error indicates a problem with the set block count
-	 * command.  No data will have been transferred.
-	 *
-	 * cmd.error indicates a problem with the r/w command.  No
-	 * data will have been transferred.
-	 *
-	 * stop.error indicates a problem with the stop command.  Data
-	 * may have been transferred, or may still be transferring.
-	 */
-	if (brq->sbc.error || brq->cmd.error || brq->stop.error) {
-		switch (mmc_blk_cmd_recovery(card, req, brq)) {
-		case ERR_RETRY:
-			return MMC_BLK_RETRY;
-		case ERR_ABORT:
-			return MMC_BLK_ABORT;
-		case ERR_CONTINUE:
-			break;
-		}
-	}
-
-	/*
-	 * Check for errors relating to the execution of the
-	 * initial command - such as address errors.  No data
-	 * has been transferred.
-	 */
-	if (brq->cmd.resp[0] & CMD_ERRORS) {
-		pr_err("%s: r/w command failed, status = %#x\n",
-		       req->rq_disk->disk_name, brq->cmd.resp[0]);
-		return MMC_BLK_ABORT;
-	}
-
-	/*
-	 * Everything else is either success, or a data error of some
-	 * kind.  If it was a write, we may have transitioned to
-	 * program mode, which we have to wait for it to complete.
-	 */
-	if (!mmc_host_is_spi(card->host) && rq_data_dir(req) != READ) {
-		u32 status;
-		do {
-			int err = get_card_status(card, &status, 5);
-			if (err) {
-				printk(KERN_ERR "%s: error %d requesting status\n",
-				       req->rq_disk->disk_name, err);
-				return MMC_BLK_CMD_ERR;
-			}
-			/*
-			 * Some cards mishandle the status bits,
-			 * so make sure to check both the busy
-			 * indication and the card state.
-			 */
-		} while (!(status & R1_READY_FOR_DATA) ||
-			 (R1_CURRENT_STATE(status) == R1_STATE_PRG));
-	}
-
-	if (brq->data.error) {
-		pr_err("%s: error %d transferring data, sector %u, nr %u, cmd response %#x, card status %#x\n",
-		       req->rq_disk->disk_name, brq->data.error,
-		       (unsigned)blk_rq_pos(req),
-		       (unsigned)blk_rq_sectors(req),
-		       brq->cmd.resp[0], brq->stop.resp[0]);
-
-		if (rq_data_dir(req) == READ) {
-			if (brq->data.blocks > 1) {
-				/* Redo read one sector at a time */
-				pr_warning("%s: retrying using single block read\n",
-					   req->rq_disk->disk_name);
-				return MMC_BLK_RETRY_SINGLE;
-			}
-			return MMC_BLK_DATA_ERR;
-		} else {
-			return MMC_BLK_CMD_ERR;
-		}
-	}
-
-	if (ret == MMC_BLK_SUCCESS &&
-	    blk_rq_bytes(req) != brq->data.bytes_xfered)
-		ret = MMC_BLK_PARTIAL;
-
-	return ret;
-}
-
-static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
-			       struct mmc_card *card,
-			       int disable_multi,
-			       struct mmc_queue *mq)
-{
-	u32 readcmd, writecmd;
-	struct mmc_blk_request *brq = &mqrq->brq;
-	struct request *req = mqrq->req;
-	struct mmc_blk_data *md = mq->data;
-
-	/*
-	 * Reliable writes are used to implement Forced Unit Access and
-	 * REQ_META accesses, and are supported only on MMCs.
-	 */
-	bool do_rel_wr = ((req->cmd_flags & REQ_FUA) ||
-			  (req->cmd_flags & REQ_META)) &&
-		(rq_data_dir(req) == WRITE) &&
-		(md->flags & MMC_BLK_REL_WR);
-
-	memset(brq, 0, sizeof(struct mmc_blk_request));
-	brq->mrq.cmd = &brq->cmd;
-	brq->mrq.data = &brq->data;
-
-	brq->cmd.arg = blk_rq_pos(req);
-	if (!mmc_card_blockaddr(card))
-		brq->cmd.arg <<= 9;
-	brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
-	brq->data.blksz = 512;
-	brq->stop.opcode = MMC_STOP_TRANSMISSION;
-	brq->stop.arg = 0;
-	brq->stop.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
-	brq->data.blocks = blk_rq_sectors(req);
-
-	/*
-	 * The block layer doesn't support all sector count
-	 * restrictions, so we need to be prepared for too big
-	 * requests.
-	 */
-	if (brq->data.blocks > card->host->max_blk_count)
-		brq->data.blocks = card->host->max_blk_count;
-
-	/*
-	 * After a read error, we redo the request one sector at a time
-	 * in order to accurately determine which sectors can be read
-	 * successfully.
-	 */
-	if (disable_multi && brq->data.blocks > 1)
-		brq->data.blocks = 1;
-
-	if (brq->data.blocks > 1 || do_rel_wr) {
-		/* SPI multiblock writes terminate using a special
-		 * token, not a STOP_TRANSMISSION request.
-		 */
-		if (!mmc_host_is_spi(card->host) ||
-		    rq_data_dir(req) == READ)
-			brq->mrq.stop = &brq->stop;
-		readcmd = MMC_READ_MULTIPLE_BLOCK;
-		writecmd = MMC_WRITE_MULTIPLE_BLOCK;
-	} else {
-		brq->mrq.stop = NULL;
-		readcmd = MMC_READ_SINGLE_BLOCK;
-		writecmd = MMC_WRITE_BLOCK;
-	}
-	if (rq_data_dir(req) == READ) {
-		brq->cmd.opcode = readcmd;
-		brq->data.flags |= MMC_DATA_READ;
-	} else {
-		brq->cmd.opcode = writecmd;
-		brq->data.flags |= MMC_DATA_WRITE;
-	}
-
-	if (do_rel_wr)
-		mmc_apply_rel_rw(brq, card, req);
-
-	/*
-	 * Pre-defined multi-block transfers are preferable to
-	 * open ended-ones (and necessary for reliable writes).
-	 * However, it is not sufficient to just send CMD23,
-	 * and avoid the final CMD12, as on an error condition
-	 * CMD12 (stop) needs to be sent anyway. This, coupled
-	 * with Auto-CMD23 enhancements provided by some
-	 * hosts, means that the complexity of dealing
-	 * with this is best left to the host. If CMD23 is
-	 * supported by card and host, we'll fill sbc in and let
-	 * the host deal with handling it correctly. This means
-	 * that for hosts that don't expose MMC_CAP_CMD23, no
-	 * change of behavior will be observed.
-	 *
-	 * N.B: Some MMC cards experience perf degradation.
-	 * We'll avoid using CMD23-bounded multiblock writes for
-	 * these, while retaining features like reliable writes.
-	 */
-
-	if ((md->flags & MMC_BLK_CMD23) &&
-	    mmc_op_multi(brq->cmd.opcode) &&
-	    (do_rel_wr || !(card->quirks & MMC_QUIRK_BLK_NO_CMD23))) {
-		brq->sbc.opcode = MMC_SET_BLOCK_COUNT;
-		brq->sbc.arg = brq->data.blocks |
-			(do_rel_wr ? (1 << 31) : 0);
-		brq->sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
-		brq->mrq.sbc = &brq->sbc;
-	}
-
-	mmc_set_data_timeout(&brq->data, card);
-
-	brq->data.sg = mqrq->sg;
-	brq->data.sg_len = mmc_queue_map_sg(mq, mqrq);
-
-	/*
-	 * Adjust the sg list so it is the same size as the
-	 * request.
-	 */
-	if (brq->data.blocks != blk_rq_sectors(req)) {
-		int i, data_size = brq->data.blocks << 9;
-		struct scatterlist *sg;
-
-		for_each_sg(brq->data.sg, sg, brq->data.sg_len, i) {
-			data_size -= sg->length;
-			if (data_size <= 0) {
-				sg->length += data_size;
-				i++;
-				break;
-			}
-		}
-		brq->data.sg_len = i;
-	}
-
-	mqrq->mmc_active.mrq = &brq->mrq;
-	mqrq->mmc_active.err_check = mmc_blk_err_check;
-
-	mmc_queue_bounce_pre(mqrq);
-}
-
-static int emmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
-{
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-	struct mmc_blk_request *brq = &mq->mqrq_cur->brq;
-	int ret = 1, disable_multi = 0, retry = 0;
-	enum mmc_blk_status status;
-	struct mmc_queue_req *mq_rq;
-	struct request *req;
-	struct mmc_async_req *areq;
-
-	if (!rqc && !mq->mqrq_prev->req)
-		return 0;
-
-	do {
-		if (rqc) {
-			mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
-			areq = &mq->mqrq_cur->mmc_active;
-		} else
-			areq = NULL;
-		areq = mmc_start_req(card->host, areq, (int *) &status);
-		if (!areq)
-			return 0;
-
-		mq_rq = container_of(areq, struct mmc_queue_req, mmc_active);
-		brq = &mq_rq->brq;
-		req = mq_rq->req;
-		mmc_queue_bounce_post(mq_rq);
-
-		switch (status) {
-		case MMC_BLK_SUCCESS:
-		case MMC_BLK_PARTIAL:
-			/*
-			 * A block was successfully transferred.
-			 */
-			ret = blk_end_request(req, 0,
-						brq->data.bytes_xfered);
-			if (status == MMC_BLK_SUCCESS && ret) {
-				/*
-				 * The blk_end_request has returned non zero
-				 * even though all data is transfered and no
-				 * erros returned by host.
-				 * If this happen it's a bug.
-				 */
-				printk(KERN_ERR "%s BUG rq_tot %d d_xfer %d\n",
-				       __func__, blk_rq_bytes(req),
-				       brq->data.bytes_xfered);
-				rqc = NULL;
-				goto cmd_abort;
-			}
-			break;
-		case MMC_BLK_CMD_ERR:
-			goto cmd_err;
-		case MMC_BLK_RETRY_SINGLE:
-			disable_multi = 1;
-			break;
-		case MMC_BLK_RETRY:
-			if (retry++ < 5)
-				break;
-		case MMC_BLK_ABORT:
-			goto cmd_abort;
-		case MMC_BLK_DATA_ERR:
-			/*
-			 * After an error, we redo I/O one sector at a
-			 * time, so we only reach here after trying to
-			 * read a single sector.
-			 */
-			ret = blk_end_request(req, -EIO,
-						brq->data.blksz);
-			if (!ret)
-				goto start_new_req;
-			break;
-		}
-
-		if (ret) {
-			/*
-			 * In case of a none complete request
-			 * prepare it again and resend.
-			 */
-			mmc_blk_rw_rq_prep(mq_rq, card, disable_multi, mq);
-			mmc_start_req(card->host, &mq_rq->mmc_active, NULL);
-		}
-	} while (ret);
-
-	return 1;
-
- cmd_err:
- 	/*
- 	 * If this is an SD card and we're writing, we can first
- 	 * mark the known good sectors as ok.
- 	 *
-	 * If the card is not SD, we can still ok written sectors
-	 * as reported by the controller (which might be less than
-	 * the real number of written sectors, but never more).
-	 */
-	if (mmc_card_sd(card)) {
-		u32 blocks;
-
-		blocks = mmc_sd_num_wr_blocks(card);
-		if (blocks != (u32)-1) {
-			ret = blk_end_request(req, 0, blocks << 9);
-		}
-	} else {
-		ret = blk_end_request(req, 0, brq->data.bytes_xfered);
-	}
-
- cmd_abort:
-	while (ret)
-		ret = blk_end_request(req, -EIO, blk_rq_cur_bytes(req));
-
- start_new_req:
-	if (rqc) {
-		mmc_blk_rw_rq_prep(mq->mqrq_cur, card, 0, mq);
-		mmc_start_req(card->host, &mq->mqrq_cur->mmc_active, NULL);
-	}
-
-	return 0;
-
-}
-static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *req)
-{
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-	
-	if(HOST_IS_EMMC(card->host))
-		return emmc_blk_issue_rw_rq(mq, req);
-	else
-		return sdmmc_blk_issue_rw_rq(mq, req);
-}
 
 static int
 mmc_blk_set_blksize(struct mmc_blk_data *md, struct mmc_card *card);
 
-static int sdmmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
+static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 {
 	int ret;
 	struct mmc_blk_data *md = mq->data;
 	struct mmc_card *card = md->queue.card;
 
 #ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
-       if (mmc_bus_needs_resume(card->host)) {
-               mmc_resume_bus(card->host);
-               mmc_blk_set_blksize(md, card);
-       }
+	if (mmc_bus_needs_resume(card->host)) {
+		mmc_resume_bus(card->host);
+		mmc_blk_set_blksize(md, card);
+	}
 #endif
-	mmc_claim_host(card->host);
 
+	mmc_claim_host(card->host);
 	ret = mmc_blk_part_switch(card, md);
 	if (ret) {
 		ret = 0;
 		goto out;
 	}
 
-	if (req && req->cmd_flags & REQ_DISCARD) {
+	if (req->cmd_flags & REQ_DISCARD) {
 		if (req->cmd_flags & REQ_SECURE)
 			ret = mmc_blk_issue_secdiscard_rq(mq, req);
 		else
 			ret = mmc_blk_issue_discard_rq(mq, req);
-	} else if (req && req->cmd_flags & REQ_FLUSH) {
+	} else if (req->cmd_flags & REQ_FLUSH) {
 		ret = mmc_blk_issue_flush(mq, req);
 	} else {
 		ret = mmc_blk_issue_rw_rq(mq, req);
@@ -1631,58 +1127,6 @@ static int sdmmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 out:
 	mmc_release_host(card->host);
 	return ret;
-
-}
-
-static int emmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
-{
-	int ret;
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-
-	if (req && !mq->mqrq_prev->req)
-		/* claim host only for the first request */
-		mmc_claim_host(card->host);
-
-	ret = mmc_blk_part_switch(card, md);
-	if (ret) {
-		ret = 0;
-		goto out;
-	}
-
-	if (req && req->cmd_flags & REQ_DISCARD) {
-		/* complete ongoing async transfer before issuing discard */
-		if (card->host->areq)
-			mmc_blk_issue_rw_rq(mq, NULL);
-		if (req->cmd_flags & REQ_SECURE)
-			ret = mmc_blk_issue_secdiscard_rq(mq, req);
-		else
-			ret = mmc_blk_issue_discard_rq(mq, req);
-	} else if (req && req->cmd_flags & REQ_FLUSH) {
-		/* complete ongoing async transfer before issuing flush */
-		if (card->host->areq)			
-			mmc_blk_issue_rw_rq(mq, NULL);
-		ret = mmc_blk_issue_flush(mq, req);
-	} else {
-		ret = mmc_blk_issue_rw_rq(mq, req);
-	}
-
-out:
-	if (!req)
-		/* release host only when there are no more requests */
-		mmc_release_host(card->host);
-	return ret;
-}
-
-static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
-{
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-
-	if(HOST_IS_EMMC(card->host))
-		return emmc_blk_issue_rq(mq, req);
-	else
-		return sdmmc_blk_issue_rq(mq, req);
 }
 
 static inline int mmc_blk_readonly(struct mmc_card *card)
@@ -1756,10 +1200,6 @@ static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,
 	md->disk->driverfs_dev = parent;
 	set_disk_ro(md->disk, md->read_only || default_ro);
 	md->disk->flags = GENHD_FL_EXT_DEVT;
-#ifdef CONFIG_EMMC_RK
-	if(HOST_IS_EMMC(card->host))
-		md->disk->flags |= 2;  /* 2 is unused flags in 'include/linux/genhd.h' */
-#endif
 
 	/*
 	 * As discussed on lkml, GENHD_FL_REMOVABLE should:
@@ -1967,9 +1407,6 @@ static const struct mmc_fixup blk_fixups[] =
 	END_FIXUP
 };
 
-#ifdef CONFIG_EMMC_RK
-extern struct mmc_card *this_card;
-#endif
 static int mmc_blk_probe(struct mmc_card *card)
 {
 	struct mmc_blk_data *md, *part_md;
@@ -2012,10 +1449,6 @@ static int mmc_blk_probe(struct mmc_card *card)
 		if (mmc_add_disk(part_md))
 			goto out;
 	}
-#ifdef CONFIG_EMMC_RK
-	if(HOST_IS_EMMC(card->host))
-		this_card = card;
-#endif
 	return 0;
 
  out:
@@ -2028,10 +1461,6 @@ static void mmc_blk_remove(struct mmc_card *card)
 {
 	struct mmc_blk_data *md = mmc_get_drvdata(card);
 
-#ifdef CONFIG_EMMC_RK
-	if(HOST_IS_EMMC(card->host))
-		this_card = NULL;
-#endif
 	mmc_blk_remove_parts(card, md);
 	mmc_claim_host(card->host);
 	mmc_blk_part_switch(card, md);
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 9678bf579f01..6413afa318d2 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -41,7 +41,8 @@ static int mmc_prep_request(struct request_queue *q, struct request *req)
 
 	return BLKPREP_OK;
 }
-static int sdmmc_queue_thread(void *d)
+
+static int mmc_queue_thread(void *d)
 {
 	struct mmc_queue *mq = d;
 	struct request_queue *q = mq->queue;
@@ -55,8 +56,7 @@ static int sdmmc_queue_thread(void *d)
 		spin_lock_irq(q->queue_lock);
 		set_current_state(TASK_INTERRUPTIBLE);
 		req = blk_fetch_request(q);
-		mq->mqrq_cur->req = req;
-		mq->mqrq_prev->req = NULL;
+		mq->req = req;
 		spin_unlock_irq(q->queue_lock);
 
 		if (!req) {
@@ -78,50 +78,6 @@ static int sdmmc_queue_thread(void *d)
 	return 0;
 }
 
-
-static int emmc_queue_thread(void *d)
-{
-	struct mmc_queue *mq = d;
-	struct request_queue *q = mq->queue;
-
-	current->flags |= PF_MEMALLOC;
-
-	down(&mq->thread_sem);
-	do {
-		struct request *req = NULL;
-		struct mmc_queue_req *tmp;
-
-		spin_lock_irq(q->queue_lock);
-		set_current_state(TASK_INTERRUPTIBLE);
-		req = blk_fetch_request(q);
-		mq->mqrq_cur->req = req;
-		spin_unlock_irq(q->queue_lock);
-
-		if (req || mq->mqrq_prev->req) {
-			set_current_state(TASK_RUNNING);
-			mq->issue_fn(mq, req);
-		} else {
-			if (kthread_should_stop()) {
-				set_current_state(TASK_RUNNING);
-				break;
-			}
-			up(&mq->thread_sem);
-			schedule();
-			down(&mq->thread_sem);
-		}
-
-		/* Current request becomes previous request and vice versa. */
-		mq->mqrq_prev->brq.mrq.data = NULL;
-		mq->mqrq_prev->req = NULL;
-		tmp = mq->mqrq_prev;
-		mq->mqrq_prev = mq->mqrq_cur;
-		mq->mqrq_cur = tmp;
-	} while (1);
-	up(&mq->thread_sem);
-
-	return 0;
-}
-
 /*
  * Generic MMC request handler.  This is called for any queue on a
  * particular host.  When the host is not busy, we look for a request
@@ -141,46 +97,10 @@ static void mmc_request(struct request_queue *q)
 		return;
 	}
 
-	if (!mq->mqrq_cur->req && !mq->mqrq_prev->req)
+	if (!mq->req)
 		wake_up_process(mq->thread);
 }
 
-struct scatterlist *mmc_alloc_sg(int sg_len, int *err)
-{
-	struct scatterlist *sg;
-
-	sg = kmalloc(sizeof(struct scatterlist)*sg_len, GFP_KERNEL);
-	if (!sg)
-		*err = -ENOMEM;
-	else {
-		*err = 0;
-		sg_init_table(sg, sg_len);
-	}
-
-	return sg;
-}
-
-static void mmc_queue_setup_discard(struct request_queue *q,
-				    struct mmc_card *card)
-{
-	unsigned max_discard;
-
-	max_discard = mmc_calc_max_discard(card);
-	if (!max_discard)
-		return;
-
-	queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, q);
-	q->limits.max_discard_sectors = max_discard;
-	if (card->erased_byte == 0)
-		q->limits.discard_zeroes_data = 1;
-	q->limits.discard_granularity = card->pref_erase << 9;
-	/* granularity must not be greater than max. discard */
-	if (card->pref_erase > max_discard)
-		q->limits.discard_granularity = 0;
-	if (mmc_can_secure_erase_trim(card))
-		queue_flag_set_unlocked(QUEUE_FLAG_SECDISCARD, q);
-}
-
 /**
  * mmc_init_queue - initialise a queue structure.
  * @mq: mmc queue
@@ -196,8 +116,6 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 	struct mmc_host *host = card->host;
 	u64 limit = BLK_BOUNCE_HIGH;
 	int ret;
-	struct mmc_queue_req *mqrq_cur = &mq->mqrq[0];
-	struct mmc_queue_req *mqrq_prev = &mq->mqrq[1];
 
 	if (mmc_dev(host)->dma_mask && *mmc_dev(host)->dma_mask)
 		limit = *mmc_dev(host)->dma_mask;
@@ -207,16 +125,21 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 	if (!mq->queue)
 		return -ENOMEM;
 
-	memset(&mq->mqrq_cur, 0, sizeof(mq->mqrq_cur));
-	memset(&mq->mqrq_prev, 0, sizeof(mq->mqrq_prev));
-	mq->mqrq_cur = mqrq_cur;
-	mq->mqrq_prev = mqrq_prev;
 	mq->queue->queuedata = mq;
+	mq->req = NULL;
 
 	blk_queue_prep_rq(mq->queue, mmc_prep_request);
 	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, mq->queue);
-	if (mmc_can_erase(card))
-		mmc_queue_setup_discard(mq->queue, card);
+	if (mmc_can_erase(card)) {
+		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, mq->queue);
+		mq->queue->limits.max_discard_sectors = UINT_MAX;
+		if (card->erased_byte == 0)
+			mq->queue->limits.discard_zeroes_data = 1;
+		mq->queue->limits.discard_granularity = card->pref_erase << 9;
+		if (mmc_can_secure_erase_trim(card))
+			queue_flag_set_unlocked(QUEUE_FLAG_SECDISCARD,
+						mq->queue);
+	}
 
 #ifdef CONFIG_MMC_BLOCK_BOUNCE
 	if (host->max_segs == 1) {
@@ -232,74 +155,59 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 			bouncesz = host->max_blk_count * 512;
 
 		if (bouncesz > 512) {
-			mqrq_cur->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
-			if (!mqrq_cur->bounce_buf) {
+			mq->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+			if (!mq->bounce_buf) {
 				printk(KERN_WARNING "%s: unable to "
-					"allocate bounce cur buffer\n",
+					"allocate bounce buffer\n",
 					mmc_card_name(card));
 			}
-			mqrq_prev->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
-			if (!mqrq_prev->bounce_buf) {
-				printk(KERN_WARNING "%s: unable to "
-					"allocate bounce prev buffer\n",
-					mmc_card_name(card));
-				kfree(mqrq_cur->bounce_buf);
-				mqrq_cur->bounce_buf = NULL;
-			}
 		}
 
-		if (mqrq_cur->bounce_buf && mqrq_prev->bounce_buf) {
+		if (mq->bounce_buf) {
 			blk_queue_bounce_limit(mq->queue, BLK_BOUNCE_ANY);
 			blk_queue_max_hw_sectors(mq->queue, bouncesz / 512);
 			blk_queue_max_segments(mq->queue, bouncesz / 512);
 			blk_queue_max_segment_size(mq->queue, bouncesz);
 
-			mqrq_cur->sg = mmc_alloc_sg(1, &ret);
-			if (ret)
-				goto cleanup_queue;
-
-			mqrq_cur->bounce_sg =
-				mmc_alloc_sg(bouncesz / 512, &ret);
-			if (ret)
-				goto cleanup_queue;
-
-			mqrq_prev->sg = mmc_alloc_sg(1, &ret);
-			if (ret)
+			mq->sg = kmalloc(sizeof(struct scatterlist),
+				GFP_KERNEL);
+			if (!mq->sg) {
+				ret = -ENOMEM;
 				goto cleanup_queue;
+			}
+			sg_init_table(mq->sg, 1);
 
-			mqrq_prev->bounce_sg =
-				mmc_alloc_sg(bouncesz / 512, &ret);
-			if (ret)
+			mq->bounce_sg = kmalloc(sizeof(struct scatterlist) *
+				bouncesz / 512, GFP_KERNEL);
+			if (!mq->bounce_sg) {
+				ret = -ENOMEM;
 				goto cleanup_queue;
+			}
+			sg_init_table(mq->bounce_sg, bouncesz / 512);
 		}
 	}
 #endif
 
-	if (!mqrq_cur->bounce_buf && !mqrq_prev->bounce_buf) {
+	if (!mq->bounce_buf) {
 		blk_queue_bounce_limit(mq->queue, limit);
 		blk_queue_max_hw_sectors(mq->queue,
 			min(host->max_blk_count, host->max_req_size / 512));
 		blk_queue_max_segments(mq->queue, host->max_segs);
 		blk_queue_max_segment_size(mq->queue, host->max_seg_size);
 
-		mqrq_cur->sg = mmc_alloc_sg(host->max_segs, &ret);
-		if (ret)
-			goto cleanup_queue;
-
-
-		mqrq_prev->sg = mmc_alloc_sg(host->max_segs, &ret);
-		if (ret)
+		mq->sg = kmalloc(sizeof(struct scatterlist) *
+			host->max_segs, GFP_KERNEL);
+		if (!mq->sg) {
+			ret = -ENOMEM;
 			goto cleanup_queue;
+		}
+		sg_init_table(mq->sg, host->max_segs);
 	}
 
 	sema_init(&mq->thread_sem, 1);
 
-	if(HOST_IS_EMMC(card->host))
-		mq->thread = kthread_run(emmc_queue_thread, mq, "mmcqd/%d%s",
-			host->index, subname ? subname : "");
-	else
-		mq->thread = kthread_run(sdmmc_queue_thread, mq, "mmcqd/%d%s",
-			host->index, subname ? subname : "");
+	mq->thread = kthread_run(mmc_queue_thread, mq, "mmcqd/%d%s",
+		host->index, subname ? subname : "");
 
 	if (IS_ERR(mq->thread)) {
 		ret = PTR_ERR(mq->thread);
@@ -308,22 +216,16 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 
 	return 0;
  free_bounce_sg:
-	kfree(mqrq_cur->bounce_sg);
-	mqrq_cur->bounce_sg = NULL;
-	kfree(mqrq_prev->bounce_sg);
-	mqrq_prev->bounce_sg = NULL;
-
+ 	if (mq->bounce_sg)
+ 		kfree(mq->bounce_sg);
+ 	mq->bounce_sg = NULL;
  cleanup_queue:
-	kfree(mqrq_cur->sg);
-	mqrq_cur->sg = NULL;
-	kfree(mqrq_cur->bounce_buf);
-	mqrq_cur->bounce_buf = NULL;
-
-	kfree(mqrq_prev->sg);
-	mqrq_prev->sg = NULL;
-	kfree(mqrq_prev->bounce_buf);
-	mqrq_prev->bounce_buf = NULL;
-
+ 	if (mq->sg)
+		kfree(mq->sg);
+	mq->sg = NULL;
+	if (mq->bounce_buf)
+		kfree(mq->bounce_buf);
+	mq->bounce_buf = NULL;
 	blk_cleanup_queue(mq->queue);
 	return ret;
 }
@@ -332,8 +234,6 @@ void mmc_cleanup_queue(struct mmc_queue *mq)
 {
 	struct request_queue *q = mq->queue;
 	unsigned long flags;
-	struct mmc_queue_req *mqrq_cur = mq->mqrq_cur;
-	struct mmc_queue_req *mqrq_prev = mq->mqrq_prev;
 
 	/* Make sure the queue isn't suspended, as that will deadlock */
 	mmc_queue_resume(mq);
@@ -347,23 +247,16 @@ void mmc_cleanup_queue(struct mmc_queue *mq)
 	blk_start_queue(q);
 	spin_unlock_irqrestore(q->queue_lock, flags);
 
-	kfree(mqrq_cur->bounce_sg);
-	mqrq_cur->bounce_sg = NULL;
+ 	if (mq->bounce_sg)
+ 		kfree(mq->bounce_sg);
+ 	mq->bounce_sg = NULL;
 
-	kfree(mqrq_cur->sg);
-	mqrq_cur->sg = NULL;
+	kfree(mq->sg);
+	mq->sg = NULL;
 
-	kfree(mqrq_cur->bounce_buf);
-	mqrq_cur->bounce_buf = NULL;
-
-	kfree(mqrq_prev->bounce_sg);
-	mqrq_prev->bounce_sg = NULL;
-
-	kfree(mqrq_prev->sg);
-	mqrq_prev->sg = NULL;
-
-	kfree(mqrq_prev->bounce_buf);
-	mqrq_prev->bounce_buf = NULL;
+	if (mq->bounce_buf)
+		kfree(mq->bounce_buf);
+	mq->bounce_buf = NULL;
 
 	mq->card = NULL;
 }
@@ -416,27 +309,27 @@ void mmc_queue_resume(struct mmc_queue *mq)
 /*
  * Prepare the sg list(s) to be handed of to the host driver
  */
-unsigned int mmc_queue_map_sg(struct mmc_queue *mq, struct mmc_queue_req *mqrq)
+unsigned int mmc_queue_map_sg(struct mmc_queue *mq)
 {
 	unsigned int sg_len;
 	size_t buflen;
 	struct scatterlist *sg;
 	int i;
 
-	if (!mqrq->bounce_buf)
-		return blk_rq_map_sg(mq->queue, mqrq->req, mqrq->sg);
+	if (!mq->bounce_buf)
+		return blk_rq_map_sg(mq->queue, mq->req, mq->sg);
 
-	BUG_ON(!mqrq->bounce_sg);
+	BUG_ON(!mq->bounce_sg);
 
-	sg_len = blk_rq_map_sg(mq->queue, mqrq->req, mqrq->bounce_sg);
+	sg_len = blk_rq_map_sg(mq->queue, mq->req, mq->bounce_sg);
 
-	mqrq->bounce_sg_len = sg_len;
+	mq->bounce_sg_len = sg_len;
 
 	buflen = 0;
-	for_each_sg(mqrq->bounce_sg, sg, sg_len, i)
+	for_each_sg(mq->bounce_sg, sg, sg_len, i)
 		buflen += sg->length;
 
-	sg_init_one(mqrq->sg, mqrq->bounce_buf, buflen);
+	sg_init_one(mq->sg, mq->bounce_buf, buflen);
 
 	return 1;
 }
@@ -445,30 +338,31 @@ unsigned int mmc_queue_map_sg(struct mmc_queue *mq, struct mmc_queue_req *mqrq)
  * If writing, bounce the data to the buffer before the request
  * is sent to the host driver
  */
-void mmc_queue_bounce_pre(struct mmc_queue_req *mqrq)
+void mmc_queue_bounce_pre(struct mmc_queue *mq)
 {
-	if (!mqrq->bounce_buf)
+	if (!mq->bounce_buf)
 		return;
 
-	if (rq_data_dir(mqrq->req) != WRITE)
+	if (rq_data_dir(mq->req) != WRITE)
 		return;
 
-	sg_copy_to_buffer(mqrq->bounce_sg, mqrq->bounce_sg_len,
-		mqrq->bounce_buf, mqrq->sg[0].length);
+	sg_copy_to_buffer(mq->bounce_sg, mq->bounce_sg_len,
+		mq->bounce_buf, mq->sg[0].length);
 }
 
 /*
  * If reading, bounce the data from the buffer after the request
  * has been handled by the host driver
  */
-void mmc_queue_bounce_post(struct mmc_queue_req *mqrq)
+void mmc_queue_bounce_post(struct mmc_queue *mq)
 {
-	if (!mqrq->bounce_buf)
+	if (!mq->bounce_buf)
 		return;
 
-	if (rq_data_dir(mqrq->req) != READ)
+	if (rq_data_dir(mq->req) != READ)
 		return;
 
-	sg_copy_from_buffer(mqrq->bounce_sg, mqrq->bounce_sg_len,
-		mqrq->bounce_buf, mqrq->sg[0].length);
+	sg_copy_from_buffer(mq->bounce_sg, mq->bounce_sg_len,
+		mq->bounce_buf, mq->sg[0].length);
 }
+
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
index d2a1eb4b9f9f..6223ef8dc9cd 100644
--- a/drivers/mmc/card/queue.h
+++ b/drivers/mmc/card/queue.h
@@ -4,35 +4,19 @@
 struct request;
 struct task_struct;
 
-struct mmc_blk_request {
-	struct mmc_request	mrq;
-	struct mmc_command	sbc;
-	struct mmc_command	cmd;
-	struct mmc_command	stop;
-	struct mmc_data		data;
-};
-
-struct mmc_queue_req {
-	struct request		*req;
-	struct mmc_blk_request	brq;
-	struct scatterlist	*sg;
-	char			*bounce_buf;
-	struct scatterlist	*bounce_sg;
-	unsigned int		bounce_sg_len;
-	struct mmc_async_req	mmc_active;
-};
-
 struct mmc_queue {
 	struct mmc_card		*card;
 	struct task_struct	*thread;
 	struct semaphore	thread_sem;
 	unsigned int		flags;
+	struct request		*req;
 	int			(*issue_fn)(struct mmc_queue *, struct request *);
 	void			*data;
 	struct request_queue	*queue;
-	struct mmc_queue_req	mqrq[2];
-	struct mmc_queue_req	*mqrq_cur;
-	struct mmc_queue_req	*mqrq_prev;
+	struct scatterlist	*sg;
+	char			*bounce_buf;
+	struct scatterlist	*bounce_sg;
+	unsigned int		bounce_sg_len;
 };
 
 extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
@@ -41,9 +25,8 @@ extern void mmc_cleanup_queue(struct mmc_queue *);
 extern void mmc_queue_suspend(struct mmc_queue *);
 extern void mmc_queue_resume(struct mmc_queue *);
 
-extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
-				     struct mmc_queue_req *);
-extern void mmc_queue_bounce_pre(struct mmc_queue_req *);
-extern void mmc_queue_bounce_post(struct mmc_queue_req *);
+extern unsigned int mmc_queue_map_sg(struct mmc_queue *);
+extern void mmc_queue_bounce_pre(struct mmc_queue *);
+extern void mmc_queue_bounce_post(struct mmc_queue *);
 
 #endif
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index 96d6ac6aaf47..e07d6c90caec 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -11,11 +11,9 @@
  *  MMC card bus driver model
  */
 
-#include <linux/export.h>
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/slab.h>
-#include <linux/stat.h>
 #include <linux/pm_runtime.h>
 
 #include <linux/mmc/card.h>
@@ -257,15 +255,6 @@ int mmc_add_card(struct mmc_card *card)
 {
 	int ret;
 	const char *type;
-	const char *uhs_bus_speed_mode = "";
-	static const char *const uhs_speeds[] = {
-		[UHS_SDR12_BUS_SPEED] = "SDR12 ",
-		[UHS_SDR25_BUS_SPEED] = "SDR25 ",
-		[UHS_SDR50_BUS_SPEED] = "SDR50 ",
-		[UHS_SDR104_BUS_SPEED] = "SDR104 ",
-		[UHS_DDR50_BUS_SPEED] = "DDR50 ",
-	};
-
 
 	dev_set_name(&card->dev, "%s:%04x", mmc_hostname(card->host), card->rca);
 
@@ -295,24 +284,19 @@ int mmc_add_card(struct mmc_card *card)
 		break;
 	}
 
-	if (mmc_sd_card_uhs(card) &&
-		(card->sd_bus_speed < ARRAY_SIZE(uhs_speeds)))
-		uhs_bus_speed_mode = uhs_speeds[card->sd_bus_speed];
-
 	if (mmc_host_is_spi(card->host)) {
-		pr_info("%s: new %s%s%s card on SPI\n",
+		printk(KERN_INFO "%s: new %s%s%s card on SPI\n",
 			mmc_hostname(card->host),
 			mmc_card_highspeed(card) ? "high speed " : "",
 			mmc_card_ddr_mode(card) ? "DDR " : "",
 			type);
 	} else {
-		pr_info("%s: new %s%s%s%s%s card at address %04x\n",
+		printk(KERN_INFO "%s: new %s%s%s card at address %04x\n",
 			mmc_hostname(card->host),
 			mmc_sd_card_uhs(card) ? "ultra high speed " :
 			(mmc_card_highspeed(card) ? "high speed " : ""),
-			(mmc_card_hs200(card) ? "HS200 " : ""),
 			mmc_card_ddr_mode(card) ? "DDR " : "",
-			uhs_bus_speed_mode, type, card->rca);
+			type, card->rca);
 	}
 
 #ifdef CONFIG_DEBUG_FS
@@ -339,8 +323,6 @@ void mmc_remove_card(struct mmc_card *card)
 #endif
 
 	if (mmc_card_present(card)) {
-		if(!HOST_IS_EMMC(card->host))
-			mmc_card_clr_present(card);
 		if (mmc_host_is_spi(card->host)) {
 			printk(KERN_INFO "%s: SPI card removed\n",
 				mmc_hostname(card->host));
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 59509b18d814..460863422892 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -199,109 +199,9 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 
 static void mmc_wait_done(struct mmc_request *mrq)
 {
-	complete(&mrq->completion);
-}
-
-static void __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
-{
-	init_completion(&mrq->completion);
-	mrq->done = mmc_wait_done;
-	mmc_start_request(host, mrq);
-}
-
-static void mmc_wait_for_req_done(struct mmc_host *host,
-				  struct mmc_request *mrq)
-{
-	wait_for_completion(&mrq->completion);
-}
-
-/**
- *	mmc_pre_req - Prepare for a new request
- *	@host: MMC host to prepare command
- *	@mrq: MMC request to prepare for
- *	@is_first_req: true if there is no previous started request
- *                     that may run in parellel to this call, otherwise false
- *
- *	mmc_pre_req() is called in prior to mmc_start_req() to let
- *	host prepare for the new request. Preparation of a request may be
- *	performed while another request is running on the host.
- */
-static void mmc_pre_req(struct mmc_host *host, struct mmc_request *mrq,
-		 bool is_first_req)
-{
-	if (host->ops->pre_req)
-		host->ops->pre_req(host, mrq, is_first_req);
-}
-
-/**
- *	mmc_post_req - Post process a completed request
- *	@host: MMC host to post process command
- *	@mrq: MMC request to post process for
- *	@err: Error, if non zero, clean up any resources made in pre_req
- *
- *	Let the host post process a completed request. Post processing of
- *	a request may be performed while another reuqest is running.
- */
-static void mmc_post_req(struct mmc_host *host, struct mmc_request *mrq,
-			 int err)
-{
-	if (host->ops->post_req)
-		host->ops->post_req(host, mrq, err);
+	complete(mrq->done_data);
 }
 
-/**
- *	mmc_start_req - start a non-blocking request
- *	@host: MMC host to start command
- *	@areq: async request to start
- *	@error: out parameter returns 0 for success, otherwise non zero
- *
- *	Start a new MMC custom command request for a host.
- *	If there is on ongoing async request wait for completion
- *	of that request and start the new one and return.
- *	Does not wait for the new request to complete.
- *
- *      Returns the completed request, NULL in case of none completed.
- *	Wait for the an ongoing request (previoulsy started) to complete and
- *	return the completed request. If there is no ongoing request, NULL
- *	is returned without waiting. NULL is not an error condition.
- */
-struct mmc_async_req *mmc_start_req(struct mmc_host *host,
-				    struct mmc_async_req *areq, int *error)
-{
-	int err = 0;
-	struct mmc_async_req *data = host->areq;
-
-	/* Prepare a new request */
-	if (areq)
-		mmc_pre_req(host, areq->mrq, !host->areq);
-
-	if (host->areq) {
-		mmc_wait_for_req_done(host, host->areq->mrq);
-		err = host->areq->err_check(host->card, host->areq);
-		if (err) {
-			mmc_post_req(host, host->areq->mrq, 0);
-			if (areq)
-				mmc_post_req(host, areq->mrq, -EINVAL);
-
-			host->areq = NULL;
-			goto out;
-		}
-	}
-
-	if (areq)
-		__mmc_start_req(host, areq->mrq);
-
-	if (host->areq)
-		mmc_post_req(host, host->areq->mrq, 0);
-
-	host->areq = areq;
- out:
-	if (error)
-		*error = err;
-	return data;
-}
-EXPORT_SYMBOL(mmc_start_req);
-
 /**
  *	mmc_wait_for_req - start a request and wait for completion
  *	@host: MMC host to start command
@@ -311,79 +211,18 @@ EXPORT_SYMBOL(mmc_start_req);
  *	for the command to complete. Does not attempt to parse the
  *	response.
  */
-static void sdmmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
+void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
 {
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-	unsigned long datasize, waittime = 0xFFFF;
-	u32 multi, unit;
-#endif
+	DECLARE_COMPLETION_ONSTACK(complete);
 
-
-	init_completion(&mrq->completion);
+	mrq->done_data = &complete;
 	mrq->done = mmc_wait_done;
 
 	mmc_start_request(host, mrq);
 
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-    if( strncmp( mmc_hostname(host) ,"mmc0" , strlen("mmc0")) ) 
-    {
-        multi = (mrq->cmd->retries>0)?mrq->cmd->retries:1;
-        waittime = wait_for_completion_timeout(&mrq->completion ,HZ*7*multi); //sdio; for cmd dead. Modifyed by xbw at 2011-06-02
-    }
-    else
-    {   
-        //calculate the timeout value for SDMMC; added by xbw at 2011-09-27
-        if(mrq->data)
-        {
-            unit = 2*(1<<20);// unit=2MB
-            datasize = mrq->data->blksz*mrq->data->blocks;
-            multi = datasize/unit;
-            multi += (datasize%unit)?1:0;
-            multi = (multi>0) ? multi : 1;
-            multi += (mrq->cmd->retries>0)?1:0;
-            waittime = wait_for_completion_timeout(&mrq->completion,HZ*7*multi); //It should be longer than bottom driver's time,due to the sum of two cmd time.
-                                                                          //modifyed by xbw at 2011-10-08
-                                                                          //
-                                                                          //example:
-                                                                          //rk29_sdmmc_request_end..2336...   CMD12 wait busy timeout!!!!! ====xbw=[sd_mmc]====
-                                                                          //mmc_wait_for_req..236.. !!!!! wait for CMD25 timeout ===xbw[mmc0]===
-        }
-        else
-        {
-            multi = (mrq->cmd->retries>0)?mrq->cmd->retries:1;
-            waittime = wait_for_completion_timeout(&mrq->completion,HZ*7*multi);
-        }
-    }
-    
-    if(waittime <= 1)
-    {
-        host->doneflag = 0;
-        mrq->cmd->error = -EIO;
-
-        if(0 == mrq->cmd->retries)
-        {
-            printk(KERN_WARNING "%s..%d.. !!!!! wait for CMD%d timeout [%s]\n",\
-                __FUNCTION__, __LINE__, mrq->cmd->opcode, mmc_hostname(host));
-        }
-    }
-#else
-	wait_for_completion(&mrq->completion);
-#endif
-}
-
-static void emmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
-{
-	__mmc_start_req(host, mrq);
-	mmc_wait_for_req_done(host, mrq);
+	wait_for_completion(&complete);
 }
 
-void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
-{
-	if(HOST_IS_EMMC(host))
-		emmc_wait_for_req(host, mrq);
-	else
-		sdmmc_wait_for_req(host, mrq);
-}
 EXPORT_SYMBOL(mmc_wait_for_req);
 
 /**
@@ -1204,11 +1043,8 @@ static void mmc_power_up(struct mmc_host *host)
 	 * to reach the minimum voltage.
 	 */
 	mmc_delay(10);
-	
-	if(!HOST_IS_EMMC(host))
-    		host->ios.clock = host->f_min;
-	else
-		host->ios.clock = host->f_init;
+
+	host->ios.clock = host->f_init;
 
 	host->ios.power_mode = MMC_POWER_ON;
 	mmc_set_ios(host);
@@ -1736,82 +1572,6 @@ int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
 }
 EXPORT_SYMBOL(mmc_erase_group_aligned);
 
-static unsigned int mmc_do_calc_max_discard(struct mmc_card *card,
-					    unsigned int arg)
-{
-	struct mmc_host *host = card->host;
-	unsigned int max_discard, x, y, qty = 0, max_qty, timeout;
-	unsigned int last_timeout = 0;
-
-	if (card->erase_shift)
-		max_qty = UINT_MAX >> card->erase_shift;
-	else if (mmc_card_sd(card))
-		max_qty = UINT_MAX;
-	else
-		max_qty = UINT_MAX / card->erase_size;
-
-	/* Find the largest qty with an OK timeout */
-	do {
-		y = 0;
-		for (x = 1; x && x <= max_qty && max_qty - x >= qty; x <<= 1) {
-			timeout = mmc_erase_timeout(card, arg, qty + x);
-			if (timeout > host->max_discard_to)
-				break;
-			if (timeout < last_timeout)
-				break;
-			last_timeout = timeout;
-			y = x;
-		}
-		qty += y;
-	} while (y);
-
-	if (!qty)
-		return 0;
-
-	if (qty == 1)
-		return 1;
-
-	/* Convert qty to sectors */
-	if (card->erase_shift)
-		max_discard = --qty << card->erase_shift;
-	else if (mmc_card_sd(card))
-		max_discard = qty;
-	else
-		max_discard = --qty * card->erase_size;
-
-	return max_discard;
-}
-
-unsigned int mmc_calc_max_discard(struct mmc_card *card)
-{
-	struct mmc_host *host = card->host;
-	unsigned int max_discard, max_trim;
-
-	if (!host->max_discard_to)
-		return UINT_MAX;
-
-	/*
-	 * Without erase_group_def set, MMC erase timeout depends on clock
-	 * frequence which can change.  In that case, the best choice is
-	 * just the preferred erase size.
-	 */
-	if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))
-		return card->pref_erase;
-
-	max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);
-	if (mmc_can_trim(card)) {
-		max_trim = mmc_do_calc_max_discard(card, MMC_TRIM_ARG);
-		if (max_trim < max_discard)
-			max_discard = max_trim;
-	} else if (max_discard < card->erase_size) {
-		max_discard = 0;
-	}
-	pr_debug("%s: calculated max. discard sectors %u for timeout %u ms\n",
-		 mmc_hostname(host), max_discard, host->max_discard_to);
-	return max_discard;
-}
-EXPORT_SYMBOL(mmc_calc_max_discard);
-
 int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 {
 	struct mmc_command cmd = {0};
@@ -1826,234 +1586,7 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 }
 EXPORT_SYMBOL(mmc_set_blocklen);
 
-static int sdmmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
-{
-#if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17		
-	int init_ret=0;
-#endif
-	host->f_init = freq;
-
-#ifdef CONFIG_MMC_DEBUG
-	pr_info("%s: %s: trying to init card at %u Hz\n",
-		mmc_hostname(host), __func__, host->f_init);
-#endif
-	mmc_power_up(host);
-
-	/*
-	 * sdio_reset sends CMD52 to reset card.  Since we do not know
-	 * if the card is being re-initialized, just send it.  CMD52
-	 * should be ignored by SD/eMMC cards.
-	 */
-#if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17	
-//the process is default for rockchip SDK. noted by xbw at 2011-11-17
-
-/* Order's important: probe SDIO, then SD, then MMC */
-
-#if !defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
-    if( strncmp( mmc_hostname(host) ,"mmc0" , strlen("mmc0")) )
-    {
-	    //sdio_reset(host);//make no sense; noteed by xbw at 2011-12-14
-    	mmc_go_idle(host);
-
-    	if (!(init_ret=mmc_attach_sdio(host)))
-    	{
-    	    printk(KERN_INFO "%s..%d..  ===== Initialize SDIO successfully. [%s]\n",\
-    	        __FUNCTION__,  __LINE__, mmc_hostname(host));
-    		return 0;
-    	}
-    	else
-    	{
-    	    if(0xFF!=init_ret)
-    	    {
-    	         printk(KERN_WARNING "\n=====\n %s..%d..  ===== Initialize SDIO-card unsuccessfully!!! [%s]\n=====\n",\
-    		        __FUNCTION__,  __LINE__, mmc_hostname(host));
-
-    		     goto freq_out;   
-    	    }
-    	}
-    }
-    else
-    {
-        mmc_go_idle(host);
-    }
-#else
-#if defined(CONFIG_RTL8723AS)
-    sdio_reset(host); //make no sense; noteed by xbw at 2011-12-14
-#else
-    //sdio_reset(host); //make no sense; noteed by xbw at 2011-12-14
-#endif
-	mmc_go_idle(host);
-
-	if (!(init_ret=mmc_attach_sdio(host)))
-	{
-	    printk(KERN_INFO "%s..%d..  ===== Initialize SDIO successfully. [%s]\n",\
-	        __FUNCTION__,  __LINE__, mmc_hostname(host));
-		return 0;
-	}
-	else
-	{
-	    if(0xFF!=init_ret)
-	    {
-	         printk(KERN_WARNING "\n=====\n %s..%d..  ===== Initialize SDIO-card unsuccessfully!!! [%s]\n=====\n",\
-		        __FUNCTION__,  __LINE__, mmc_hostname(host));
-
-		     goto freq_out;   
-	    }
-	}
-#endif // #end--#if !defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
-
-    if (!(init_ret=mmc_attach_sd(host)))
-    {
-        printk(KERN_INFO "%s..%d..  ===== Initialize SD-card successfully. [%s]\n",\
-            __FUNCTION__,  __LINE__, mmc_hostname(host));
-            
-	    return 0;
-	}
-	else
-	{
-	    if(0xFF!=init_ret)
-	    {
-	          printk(KERN_WARNING "\n=====\n%s..%d..  ===== Initialize SD-card unsuccessfully! [%s]\n====\n",\
-	                __FUNCTION__,  __LINE__, mmc_hostname(host));
-
-		     goto freq_out;   
-	    }
-	}
-
-
-	if (!(init_ret=mmc_attach_mmc(host)))
-	{
-	    printk(KERN_INFO "%s...%d..  ===== Initialize MMC-card successfully. [%s]\n",\
-	        __FUNCTION__,  __LINE__, mmc_hostname(host));
-
-	    return 0;
-	}
-	else
-	{
-	    if(0xFF!=init_ret)
-	    {
-	         printk(KERN_WARNING "\n =====\n%s..%d..  ===== Initialize MMC-card unsuccessfully!!! [%s]\n======\n",\
-	            __FUNCTION__,  __LINE__, mmc_hostname(host));
-	            
-		     goto freq_out;   
-	    }
-	}		
-    	
-freq_out:
-	mmc_power_off(host);
-	return -EIO;
-
-#else  // the default process in ICS.
-
-    sdio_reset(host);
-	mmc_go_idle(host);
-
-	mmc_send_if_cond(host, host->ocr_avail);
-
-	/* Order's important: probe SDIO, then SD, then MMC */
-	if (!mmc_attach_sdio(host))
-		return 0;
-	if (!mmc_attach_sd(host))
-		return 0;
-	if (!mmc_attach_mmc(host))
-		return 0;
-
-	mmc_power_off(host);
-	return -EIO;
-#endif 
-
-}
-
-static void sdmmc_rescan(struct work_struct *work)
-{
-	//static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
-	struct mmc_host *host =
-		container_of(work, struct mmc_host, detect.work);
-	//int i;
-	bool extend_wakelock = false;
-
-	if (host->rescan_disable)
-		return;
-
-	mmc_bus_get(host);
-
-	/*
-	 * if there is a _removable_ card registered, check whether it is
-	 * still present
-	 */
-	if (host->bus_ops && host->bus_ops->detect && !host->bus_dead
-	    && !(host->caps & MMC_CAP_NONREMOVABLE))
-		host->bus_ops->detect(host);
-
-	/* If the card was removed the bus will be marked
-	 * as dead - extend the wakelock so userspace
-	 * can respond */
-	if (host->bus_dead)
-		extend_wakelock = 1;
-
-	/*
-	 * Let mmc_bus_put() free the bus/bus_ops if we've found that
-	 * the card is no longer present.
-	 */
-	mmc_bus_put(host);
-	mmc_bus_get(host);
-
-	/* if there still is a card present, stop here */
-	if (host->bus_ops != NULL) {
-		mmc_bus_put(host);
-		goto out;
-	}
-
-	/*
-	 * Only we can add a new handler, so it's safe to
-	 * release the lock here.
-	 */
-	mmc_bus_put(host);
-
-#if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17
-    printk(KERN_INFO "\n%s...%d..  ===== mmc_rescan Begin....[%s]\n",__FILE__, __LINE__, mmc_hostname(host));
-#endif
-
-	if (host->ops->get_cd && host->ops->get_cd(host) == 0)
-	{
-#if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17
-    	 printk(KERN_WARNING "\n=================\n%s..%d..  ====find no SDMMC host. [%s]\n", \
-    	        __FUNCTION__, __LINE__, mmc_hostname(host));
-#endif
-
-		goto out;
-	}
-
-	mmc_claim_host(host);
-
-#if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17
-    if (!sdmmc_rescan_try_freq(host, host->f_min)) 
-        extend_wakelock = true;
-
-#else	
-	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
-		if (!sdmmc_rescan_try_freq(host, max(freqs[i], host->f_min))) {
-			extend_wakelock = true;
-			break;
-		}
-		if (freqs[i] <= host->f_min)
-			break;
-	}
-#endif
-
-	mmc_release_host(host);
-
- out:
-	if (extend_wakelock)
-		wake_lock_timeout(&host->detect_wake_lock, HZ / 2);
-	else
-		wake_unlock(&host->detect_wake_lock);
-	if (host->caps & MMC_CAP_NEEDS_POLL) {
-		wake_lock(&host->detect_wake_lock);
-		mmc_schedule_delayed_work(&host->detect, HZ);
-	}
-}
-static int emmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
+static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 {
 	host->f_init = freq;
 
@@ -2085,7 +1618,7 @@ static int emmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	return -EIO;
 }
 
-static void emmc_rescan(struct work_struct *work)
+void mmc_rescan(struct work_struct *work)
 {
 	static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 	struct mmc_host *host =
@@ -2136,7 +1669,7 @@ static void emmc_rescan(struct work_struct *work)
 
 	mmc_claim_host(host);
 	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
-		if (!emmc_rescan_try_freq(host, max(freqs[i], host->f_min))) {
+		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min))) {
 			extend_wakelock = true;
 			break;
 		}
@@ -2156,16 +1689,6 @@ static void emmc_rescan(struct work_struct *work)
 	}
 }
 
-void mmc_rescan(struct work_struct *work)
-{
-	struct mmc_host *host =
-		container_of(work, struct mmc_host, detect.work);
-
-	if(HOST_IS_EMMC(host))
-		emmc_rescan(work);
-	else
-		sdmmc_rescan(work);
-}
 void mmc_start_host(struct mmc_host *host)
 {
 	mmc_power_off(host);
@@ -2291,70 +1814,6 @@ int mmc_card_can_sleep(struct mmc_host *host)
 }
 EXPORT_SYMBOL(mmc_card_can_sleep);
 
-/*
- * Flush the cache to the non-volatile storage.
- */
-int mmc_flush_cache(struct mmc_card *card)
-{
-	struct mmc_host *host = card->host;
-	int err = 0;
-
-	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL))
-		return err;
-
-	if (mmc_card_mmc(card) &&
-			(card->ext_csd.cache_size > 0) &&
-			(card->ext_csd.cache_ctrl & 1)) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				EXT_CSD_FLUSH_CACHE, 1, 0);
-		if (err)
-			pr_err("%s: cache flush error %d\n",
-					mmc_hostname(card->host), err);
-	}
-
-	return err;
-}
-EXPORT_SYMBOL(mmc_flush_cache);
-
-/*
- * Turn the cache ON/OFF.
- * Turning the cache OFF shall trigger flushing of the data
- * to the non-volatile storage.
- * This function should be called with host claimed
- */
-int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
-{
-	struct mmc_card *card = host->card;
-	unsigned int timeout;
-	int err = 0;
-
-	if (!(host->caps2 & MMC_CAP2_CACHE_CTRL) ||
-			mmc_card_is_removable(host))
-		return err;
-
-	if (card && mmc_card_mmc(card) &&
-			(card->ext_csd.cache_size > 0)) {
-		enable = !!enable;
-
-		if (card->ext_csd.cache_ctrl ^ enable) {
-			timeout = enable ? card->ext_csd.generic_cmd6_time : 0;
-			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-					EXT_CSD_CACHE_CTRL, enable, timeout);
-			if (err)
-				pr_err("%s: cache %s error %d\n",
-						mmc_hostname(card->host),
-						enable ? "on" : "off",
-						err);
-			else
-				card->ext_csd.cache_ctrl = enable;
-		}
-	}
-
-	return err;
-}
-EXPORT_SYMBOL(mmc_cache_ctrl);
-
-
 #ifdef CONFIG_PM
 
 /**
@@ -2378,24 +1837,19 @@ int mmc_suspend_host(struct mmc_host *host)
 	if (host->bus_ops && !host->bus_dead) {
 		if (host->bus_ops->suspend)
 			err = host->bus_ops->suspend(host);
-
-               //deleted all detail code, if host is sdmmc. 
-	       //fix the crash bug when error occur during suspend. Modiefyed by xbw at 2012-08-09
-		if(HOST_IS_EMMC(host)){
-			if (err == -ENOSYS || !host->bus_ops->resume) {
-				/*
-				 * We simply "remove" the card in this case.
-				 * It will be redetected on resume.
-				 */
-				if (host->bus_ops->remove)
-					host->bus_ops->remove(host);
-				mmc_claim_host(host);
-				mmc_detach_bus(host);
-				mmc_power_off(host);
-				mmc_release_host(host);
-				host->pm_flags = 0;
-				err = 0;
-			}
+		if (err == -ENOSYS || !host->bus_ops->resume) {
+			/*
+			 * We simply "remove" the card in this case.
+			 * It will be redetected on resume.
+			 */
+			if (host->bus_ops->remove)
+				host->bus_ops->remove(host);
+			mmc_claim_host(host);
+			mmc_detach_bus(host);
+			mmc_power_off(host);
+			mmc_release_host(host);
+			host->pm_flags = 0;
+			err = 0;
 		}
 		flush_delayed_work(&host->disable);
 	}
@@ -2442,17 +1896,12 @@ int mmc_resume_host(struct mmc_host *host)
 			}
 		}
 		BUG_ON(!host->bus_ops->resume);
-		if(!HOST_IS_EMMC(host)){
-        		//panic if the card is being removed during the resume, deleted by xbw at 2011-06-20
-			host->bus_ops->resume(host);
-		}else{
-			err = host->bus_ops->resume(host);
-			if (err) {
-				printk(KERN_WARNING "%s: error %d during resume "
+		err = host->bus_ops->resume(host);
+		if (err) {
+			printk(KERN_WARNING "%s: error %d during resume "
 					    "(card was removed?)\n",
 					    mmc_hostname(host), err);
-				err = 0;
-			}
+			err = 0;
 		}
 	}
 	host->pm_flags &= ~MMC_PM_KEEP_POWER;
diff --git a/drivers/mmc/core/core.h b/drivers/mmc/core/core.h
index e2f8978bf0b0..14664f1fb16f 100644
--- a/drivers/mmc/core/core.h
+++ b/drivers/mmc/core/core.h
@@ -24,7 +24,6 @@ struct mmc_bus_ops {
 	int (*resume)(struct mmc_host *);
 	int (*power_save)(struct mmc_host *);
 	int (*power_restore)(struct mmc_host *);
-	int (*alive)(struct mmc_host *);
 };
 
 void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops);
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 0acf7ebdd1be..f6011802745c 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -19,7 +19,6 @@
 
 #include "core.h"
 #include "bus.h"
-#include "host.h"
 #include "mmc_ops.h"
 #include "sd_ops.h"
 
@@ -96,7 +95,6 @@ static int mmc_decode_cid(struct mmc_card *card)
 		card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
 		card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
 		card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
-		card->cid.prv		= UNSTUFF_BITS(resp, 48, 8);
 		card->cid.serial	= UNSTUFF_BITS(resp, 16, 32);
 		card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
 		card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
@@ -236,44 +234,12 @@ static int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd)
 	return err;
 }
 
-static void mmc_select_card_type(struct mmc_card *card)
-{
-	struct mmc_host *host = card->host;
-	u8 card_type = card->ext_csd.raw_card_type & EXT_CSD_CARD_TYPE_MASK;
-	u32 caps = host->caps, caps2 = host->caps2;
-	unsigned int hs_max_dtr = 0;
-
-	if (card_type & EXT_CSD_CARD_TYPE_26)
-		hs_max_dtr = MMC_HIGH_26_MAX_DTR;
-
-	if (caps & MMC_CAP_MMC_HIGHSPEED &&
-			card_type & EXT_CSD_CARD_TYPE_52)
-		hs_max_dtr = MMC_HIGH_52_MAX_DTR;
-
-	if ((caps & MMC_CAP_1_8V_DDR &&
-			card_type & EXT_CSD_CARD_TYPE_DDR_1_8V) ||
-	    (caps & MMC_CAP_1_2V_DDR &&
-			card_type & EXT_CSD_CARD_TYPE_DDR_1_2V))
-		hs_max_dtr = MMC_HIGH_DDR_MAX_DTR;
-
-	if ((caps2 & MMC_CAP2_HS200_1_8V_SDR &&
-			card_type & EXT_CSD_CARD_TYPE_SDR_1_8V) ||
-	    (caps2 & MMC_CAP2_HS200_1_2V_SDR &&
-			card_type & EXT_CSD_CARD_TYPE_SDR_1_2V))
-		hs_max_dtr = MMC_HS200_MAX_DTR;
-
-	card->ext_csd.hs_max_dtr = hs_max_dtr;
-	card->ext_csd.card_type = card_type;
-}
-
 /*
  * Decode extended CSD.
  */
 static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 {
-	int err = 0, idx;
-	unsigned int part_size;
-	u8 hc_erase_grp_sz = 0, hc_wp_grp_sz = 0;
+	int err = 0;
 
 	BUG_ON(!card);
 
@@ -293,8 +259,7 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 	}
 
 	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
-	if ((HOST_IS_EMMC(card->host) && card->ext_csd.rev > 6) ||
-	    (!HOST_IS_EMMC(card->host) && card->ext_csd.rev > 5))	{
+	if (card->ext_csd.rev > 5) {
 		printk(KERN_ERR "%s: unrecognised EXT_CSD revision %d\n",
 			mmc_hostname(card->host), card->ext_csd.rev);
 		err = -EINVAL;
@@ -375,10 +340,7 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 		 * There are two boot regions of equal size, defined in
 		 * multiples of 128K.
 		 */
-		if(HOST_IS_EMMC(card->host)) //emmc: We do NOT alloc boot partition now (kfx)
-			card->ext_csd.boot_size = 0;
-		else
-			card->ext_csd.boot_size = ext_csd[EXT_CSD_BOOT_MULT] << 17;
+		card->ext_csd.boot_size = ext_csd[EXT_CSD_BOOT_MULT] << 17;
 	}
 
 	card->ext_csd.raw_hc_erase_gap_size =
@@ -431,42 +393,6 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 			card->ext_csd.enhanced_area_offset = -EINVAL;
 			card->ext_csd.enhanced_area_size = -EINVAL;
 		}
-
-		/*
-		 * General purpose partition feature support --
-		 * If ext_csd has the size of general purpose partitions,
-		 * set size, part_cfg, partition name in mmc_part.
-		 */
-		if (ext_csd[EXT_CSD_PARTITION_SUPPORT] &
-			EXT_CSD_PART_SUPPORT_PART_EN) {
-			if (card->ext_csd.enhanced_area_en != 1) {
-				hc_erase_grp_sz =
-					ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE];
-				hc_wp_grp_sz =
-					ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
-
-				card->ext_csd.enhanced_area_en = 1;
-			}
-
-			for (idx = 0; idx < MMC_NUM_GP_PARTITION; idx++) {
-				if (!ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3] &&
-				!ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3 + 1] &&
-				!ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3 + 2])
-					continue;
-				part_size =
-				(ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3 + 2]
-					<< 16) +
-				(ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3 + 1]
-					<< 8) +
-				ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3];
-				part_size *= (size_t)(hc_erase_grp_sz *
-					hc_wp_grp_sz);
-				mmc_part_add(card, part_size << 19,
-					EXT_CSD_PART_CONFIG_ACC_GP0 + idx,
-					"gp%d", idx, false,
-					MMC_BLK_DATA_AREA_GP);
-			}
-		}
 		card->ext_csd.sec_trim_mult =
 			ext_csd[EXT_CSD_SEC_TRIM_MULT];
 		card->ext_csd.sec_erase_mult =
@@ -475,57 +401,10 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 			ext_csd[EXT_CSD_SEC_FEATURE_SUPPORT];
 		card->ext_csd.trim_timeout = 300 *
 			ext_csd[EXT_CSD_TRIM_MULT];
-
-		/*
-		 * Note that the call to mmc_part_add above defaults to read
-		 * only. If this default assumption is changed, the call must
-		 * take into account the value of boot_locked below.
-		 */
-		card->ext_csd.boot_ro_lock = ext_csd[EXT_CSD_BOOT_WP];
-		card->ext_csd.boot_ro_lockable = true;
 	}
 
-	if (card->ext_csd.rev >= 5) {
-		/* check whether the eMMC card supports BKOPS */
-		if (ext_csd[EXT_CSD_BKOPS_SUPPORT] & 0x1) {
-			card->ext_csd.bkops = 1;
-			card->ext_csd.bkops_en = ext_csd[EXT_CSD_BKOPS_EN];
-			card->ext_csd.raw_bkops_status =
-				ext_csd[EXT_CSD_BKOPS_STATUS];
-			if (!card->ext_csd.bkops_en)
-				pr_info("%s: BKOPS_EN bit is not set\n",
-					mmc_hostname(card->host));
-		}
-
-		/* check whether the eMMC card supports HPI */
-		if (ext_csd[EXT_CSD_HPI_FEATURES] & 0x1) {
-			card->ext_csd.hpi = 1;
-			if (ext_csd[EXT_CSD_HPI_FEATURES] & 0x2)
-				card->ext_csd.hpi_cmd =	MMC_STOP_TRANSMISSION;
-			else
-				card->ext_csd.hpi_cmd = MMC_SEND_STATUS;
-			/*
-			 * Indicate the maximum timeout to close
-			 * a command interrupted by HPI
-			 */
-			card->ext_csd.out_of_int_time =
-				ext_csd[EXT_CSD_OUT_OF_INTERRUPT_TIME] * 10;
-		}
-
+	if (card->ext_csd.rev >= 5)
 		card->ext_csd.rel_param = ext_csd[EXT_CSD_WR_REL_PARAM];
-		card->ext_csd.rst_n_function = ext_csd[EXT_CSD_RST_N_FUNCTION];
-
-		/*
-		 * RPMB regions are defined in multiples of 128K.
-		 */
-		card->ext_csd.raw_rpmb_size_mult = ext_csd[EXT_CSD_RPMB_MULT];
-		if (ext_csd[EXT_CSD_RPMB_MULT] && mmc_host_cmd23(card->host)) {
-			mmc_part_add(card, ext_csd[EXT_CSD_RPMB_MULT] << 17,
-				EXT_CSD_PART_CONFIG_ACC_RPMB,
-				"rpmb", 0, false,
-				MMC_BLK_DATA_AREA_RPMB);
-		}
-	}
 
 	card->ext_csd.raw_erased_mem_count = ext_csd[EXT_CSD_ERASED_MEM_CONT];
 	if (ext_csd[EXT_CSD_ERASED_MEM_CONT])
@@ -533,43 +412,6 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 	else
 		card->erased_byte = 0x0;
 
-	/* eMMC v4.5 or later */
-	if (card->ext_csd.rev >= 6) {
-		card->ext_csd.feature_support |= MMC_DISCARD_FEATURE;
-
-		card->ext_csd.generic_cmd6_time = 10 *
-			ext_csd[EXT_CSD_GENERIC_CMD6_TIME];
-		card->ext_csd.power_off_longtime = 10 *
-			ext_csd[EXT_CSD_POWER_OFF_LONG_TIME];
-
-		card->ext_csd.cache_size =
-			ext_csd[EXT_CSD_CACHE_SIZE + 0] << 0 |
-			ext_csd[EXT_CSD_CACHE_SIZE + 1] << 8 |
-			ext_csd[EXT_CSD_CACHE_SIZE + 2] << 16 |
-			ext_csd[EXT_CSD_CACHE_SIZE + 3] << 24;
-
-		if (ext_csd[EXT_CSD_DATA_SECTOR_SIZE] == 1)
-			card->ext_csd.data_sector_size = 4096;
-		else
-			card->ext_csd.data_sector_size = 512;
-
-		if ((ext_csd[EXT_CSD_DATA_TAG_SUPPORT] & 1) &&
-		    (ext_csd[EXT_CSD_TAG_UNIT_SIZE] <= 8)) {
-			card->ext_csd.data_tag_unit_size =
-			((unsigned int) 1 << ext_csd[EXT_CSD_TAG_UNIT_SIZE]) *
-			(card->ext_csd.data_sector_size);
-		} else {
-			card->ext_csd.data_tag_unit_size = 0;
-		}
-
-		card->ext_csd.max_packed_writes =
-			ext_csd[EXT_CSD_MAX_PACKED_WRITES];
-		card->ext_csd.max_packed_reads =
-			ext_csd[EXT_CSD_MAX_PACKED_READS];
-	} else {
-		card->ext_csd.data_sector_size = 512;
-	}
-
 out:
 	return err;
 }
@@ -600,17 +442,7 @@ static int mmc_compare_ext_csds(struct mmc_card *card, unsigned bus_width)
 		goto out;
 
 	/* only compare read only fields */
-	//err = (!(card->ext_csd.raw_partition_support ==  	                                                   
-	err = !((card->ext_csd.raw_partition_support ==
-	                                                    /*Modifyed by xbw at 2012-03-05
-	                                                    
-	                                                   commit dd13b4ed4650bb3a7d6c86b549ab66a6aa0c00d8
-                                                        Author: Jurgen Heeks <jurgen.heeks@nokia.com>
-                                                        Date:   Wed Feb 1 13:30:55 2012 +0100
-
-                                                          mmc: core: Fix comparison issue in mmc_compare_ext_csds
-	                                                   */
-	
+	err = (!(card->ext_csd.raw_partition_support ==
 			bw_ext_csd[EXT_CSD_PARTITION_SUPPORT]) &&
 		(card->ext_csd.raw_erased_mem_count ==
 			bw_ext_csd[EXT_CSD_ERASED_MEM_CONT]) &&
@@ -664,13 +496,10 @@ MMC_DEV_ATTR(hwrev, "0x%x\n", card->cid.hwrev);
 MMC_DEV_ATTR(manfid, "0x%06x\n", card->cid.manfid);
 MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
 MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
-MMC_DEV_ATTR(prv, "0x%x\n", card->cid.prv);
 MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
 MMC_DEV_ATTR(enhanced_area_offset, "%llu\n",
 		card->ext_csd.enhanced_area_offset);
 MMC_DEV_ATTR(enhanced_area_size, "%u\n", card->ext_csd.enhanced_area_size);
-MMC_DEV_ATTR(raw_rpmb_size_mult, "%#x\n", card->ext_csd.raw_rpmb_size_mult);
-MMC_DEV_ATTR(rel_sectors, "%#x\n", card->ext_csd.rel_sectors);
 
 static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_cid.attr,
@@ -683,12 +512,9 @@ static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_manfid.attr,
 	&dev_attr_name.attr,
 	&dev_attr_oemid.attr,
-	&dev_attr_prv.attr,
 	&dev_attr_serial.attr,
 	&dev_attr_enhanced_area_offset.attr,
 	&dev_attr_enhanced_area_size.attr,
-	&dev_attr_raw_rpmb_size_mult.attr,
-	&dev_attr_rel_sectors.attr,
 	NULL,
 };
 
@@ -705,166 +531,6 @@ static struct device_type mmc_type = {
 	.groups = mmc_attr_groups,
 };
 
-/*
- * Select the PowerClass for the current bus width
- * If power class is defined for 4/8 bit bus in the
- * extended CSD register, select it by executing the
- * mmc_switch command.
- */
-static int mmc_select_powerclass(struct mmc_card *card,
-		unsigned int bus_width, u8 *ext_csd)
-{
-	int err = 0;
-	unsigned int pwrclass_val;
-	unsigned int index = 0;
-	struct mmc_host *host;
-
-	BUG_ON(!card);
-
-	host = card->host;
-	BUG_ON(!host);
-
-	if (ext_csd == NULL)
-		return 0;
-
-	/* Power class selection is supported for versions >= 4.0 */
-	if (card->csd.mmca_vsn < CSD_SPEC_VER_4)
-		return 0;
-
-	/* Power class values are defined only for 4/8 bit bus */
-	if (bus_width == EXT_CSD_BUS_WIDTH_1)
-		return 0;
-
-	switch (1 << host->ios.vdd) {
-	case MMC_VDD_165_195:
-		if (host->ios.clock <= 26000000)
-			index = EXT_CSD_PWR_CL_26_195;
-		else if	(host->ios.clock <= 52000000)
-			index = (bus_width <= EXT_CSD_BUS_WIDTH_8) ?
-				EXT_CSD_PWR_CL_52_195 :
-				EXT_CSD_PWR_CL_DDR_52_195;
-		else if (host->ios.clock <= 200000000)
-			index = EXT_CSD_PWR_CL_200_195;
-		break;
-	case MMC_VDD_27_28:
-	case MMC_VDD_28_29:
-	case MMC_VDD_29_30:
-	case MMC_VDD_30_31:
-	case MMC_VDD_31_32:
-	case MMC_VDD_32_33:
-	case MMC_VDD_33_34:
-	case MMC_VDD_34_35:
-	case MMC_VDD_35_36:
-		if (host->ios.clock <= 26000000)
-			index = EXT_CSD_PWR_CL_26_360;
-		else if	(host->ios.clock <= 52000000)
-			index = (bus_width <= EXT_CSD_BUS_WIDTH_8) ?
-				EXT_CSD_PWR_CL_52_360 :
-				EXT_CSD_PWR_CL_DDR_52_360;
-		else if (host->ios.clock <= 200000000)
-			index = EXT_CSD_PWR_CL_200_360;
-		break;
-	default:
-		pr_warning("%s: Voltage range not supported "
-			   "for power class.\n", mmc_hostname(host));
-		return -EINVAL;
-	}
-
-	pwrclass_val = ext_csd[index];
-
-	if (bus_width & (EXT_CSD_BUS_WIDTH_8 | EXT_CSD_DDR_BUS_WIDTH_8))
-		pwrclass_val = (pwrclass_val & EXT_CSD_PWR_CL_8BIT_MASK) >>
-				EXT_CSD_PWR_CL_8BIT_SHIFT;
-	else
-		pwrclass_val = (pwrclass_val & EXT_CSD_PWR_CL_4BIT_MASK) >>
-				EXT_CSD_PWR_CL_4BIT_SHIFT;
-
-	/* If the power class is different from the default value */
-	if (pwrclass_val > 0) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_POWER_CLASS,
-				 pwrclass_val,
-				 card->ext_csd.generic_cmd6_time);
-	}
-
-	return err;
-}
-
-/*
- * Selects the desired buswidth and switch to the HS200 mode
- * if bus width set without error
- */
-static int mmc_select_hs200(struct mmc_card *card)
-{
-	int idx, err = -EINVAL;
-	struct mmc_host *host;
-	static unsigned ext_csd_bits[] = {
-		EXT_CSD_BUS_WIDTH_4,
-		EXT_CSD_BUS_WIDTH_8,
-	};
-	static unsigned bus_widths[] = {
-		MMC_BUS_WIDTH_4,
-		MMC_BUS_WIDTH_8,
-	};
-
-	BUG_ON(!card);
-
-	host = card->host;
-
-	if (card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_2V &&
-			host->caps2 & MMC_CAP2_HS200_1_2V_SDR)
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120,0);
-
-	if (err && card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_8V &&
-			host->caps2 & MMC_CAP2_HS200_1_8V_SDR)
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,0);
-
-	/* If fails try again during next card power cycle */
-	if (err)
-		goto err;
-
-	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 1 : 0;
-
-	/*
-	 * Unlike SD, MMC cards dont have a configuration register to notify
-	 * supported bus width. So bus test command should be run to identify
-	 * the supported bus width or compare the ext csd values of current
-	 * bus width and ext csd values of 1 bit mode read earlier.
-	 */
-	for (; idx >= 0; idx--) {
-
-		/*
-		 * Host is capable of 8bit transfer, then switch
-		 * the device to work in 8bit transfer mode. If the
-		 * mmc switch command returns error then switch to
-		 * 4bit transfer mode. On success set the corresponding
-		 * bus width on the host.
-		 */
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_BUS_WIDTH,
-				 ext_csd_bits[idx],
-				 card->ext_csd.generic_cmd6_time);
-		if (err)
-			continue;
-
-		mmc_set_bus_width(card->host, bus_widths[idx]);
-
-		if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
-			err = mmc_compare_ext_csds(card, bus_widths[idx]);
-		else
-			err = mmc_bus_test(card, bus_widths[idx]);
-		if (!err)
-			break;
-	}
-
-	/* switch to HS200 mode if bus width set successfully */
-	if (!err)
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_HS_TIMING, 2, 0);
-err:
-	return err;
-}
-
 /*
  * Handle the detection and initialisation of a card.
  *
@@ -884,10 +550,6 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	/* Set correct bus mode for MMC before attempting init */
-	if (!mmc_host_is_spi(host))
-		mmc_set_bus_mode(host, MMC_BUSMODE_OPENDRAIN);
-
 	/*
 	 * Since we're changing the OCR value, we seem to
 	 * need to tell some cards to go back to the idle
@@ -899,12 +561,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	/* The extra bit indicates that we support high capacity */
 	err = mmc_send_op_cond(host, ocr | (1 << 30), &rocr);
 	if (err)
-	{
-		if(!HOST_IS_EMMC(host))
-	    		printk(KERN_INFO "%s..%d..  ====*Identify the card as MMC , but OCR error, so fail to initialize.[%s]\n",\
-	        		__FUNCTION__, __LINE__, mmc_hostname(host));
 		goto err;
-	}
 
 	/*
 	 * For SPI, enable CRC as appropriate.
@@ -1011,11 +668,9 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	 * If enhanced_area_en is TRUE, host needs to enable ERASE_GRP_DEF
 	 * bit.  This bit will be lost every time after a reset or power off.
 	 */
-	if (card->ext_csd.enhanced_area_en ||
-	    (card->ext_csd.rev >= 3 && (host->caps2 & MMC_CAP2_HC_ERASE_SZ))) {
+	if (card->ext_csd.enhanced_area_en) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_ERASE_GROUP_DEF, 1,
-				 card->ext_csd.generic_cmd6_time);
+				 EXT_CSD_ERASE_GROUP_DEF, 1, 0);
 
 		if (err && err != -EBADMSG)
 			goto free_card;
@@ -1052,40 +707,13 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 			goto free_card;
 	}
 
-	/*
-	 * If the host supports the power_off_notify capability then
-	 * set the notification byte in the ext_csd register of device
-	 */
-	if ((host->caps2 & MMC_CAP2_POWEROFF_NOTIFY) &&
-	    (card->ext_csd.rev >= 6)) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_POWER_OFF_NOTIFICATION,
-				 EXT_CSD_POWER_ON,
-				 card->ext_csd.generic_cmd6_time);
-		if (err && err != -EBADMSG)
-			goto free_card;
-
-		/*
-		 * The err can be -EBADMSG or 0,
-		 * so check for success and update the flag
-		 */
-		if (!err)
-			card->ext_csd.power_off_notification = EXT_CSD_POWER_ON;
-	}
-
 	/*
 	 * Activate high speed (if supported)
 	 */
-	if (card->ext_csd.hs_max_dtr != 0) {
-		err = 0;
-		if (card->ext_csd.hs_max_dtr > 52000000 &&
-		    host->caps2 & MMC_CAP2_HS200)
-			err = mmc_select_hs200(card);
-		else if	(host->caps & MMC_CAP_MMC_HIGHSPEED)
-			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-					 EXT_CSD_HS_TIMING, 1,
-					 card->ext_csd.generic_cmd6_time);
-
+	if ((card->ext_csd.hs_max_dtr != 0) &&
+		(host->caps & MMC_CAP_MMC_HIGHSPEED)) {
+		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_HS_TIMING, 1, 0);
 		if (err && err != -EBADMSG)
 			goto free_card;
 
@@ -1094,15 +722,8 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 			       mmc_hostname(card->host));
 			err = 0;
 		} else {
-			if (card->ext_csd.hs_max_dtr > 52000000 &&
-			    host->caps2 & MMC_CAP2_HS200) {
-				mmc_card_set_hs200(card);
-				mmc_set_timing(card->host,
-					       MMC_TIMING_MMC_HS200);
-			} else {
-				mmc_card_set_highspeed(card);
-				mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
-			}
+			mmc_card_set_highspeed(card);
+			mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
 		}
 	}
 
@@ -1114,13 +735,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	if (mmc_card_highspeed(card)) {
 		if (max_dtr > card->ext_csd.hs_max_dtr)
 			max_dtr = card->ext_csd.hs_max_dtr;
-		if (mmc_card_highspeed(card) && (max_dtr > 52000000))
-			max_dtr = 52000000;
 	} else if (max_dtr > card->csd.max_dtr) {
-		if(!HOST_IS_EMMC(host)){
-        		//in order to expand the compatibility of card. Added by xbw@2011-03-21
-			card->csd.max_dtr = (card->csd.max_dtr > MMC_FPP_FREQ) ? MMC_FPP_FREQ : (card->csd.max_dtr); 
-		}
 		max_dtr = card->csd.max_dtr;
 	}
 
@@ -1142,51 +757,10 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 				ddr = MMC_1_2V_DDR_MODE;
 	}
 
-	/*
-	 * Indicate HS200 SDR mode (if supported).
-	 */
-	if (mmc_card_hs200(card)) {
-		u32 ext_csd_bits;
-		u32 bus_width = card->host->ios.bus_width;
-
-		/*
-		 * For devices supporting HS200 mode, the bus width has
-		 * to be set before executing the tuning function. If
-		 * set before tuning, then device will respond with CRC
-		 * errors for responses on CMD line. So for HS200 the
-		 * sequence will be
-		 * 1. set bus width 4bit / 8 bit (1 bit not supported)
-		 * 2. switch to HS200 mode
-		 * 3. set the clock to > 52Mhz <=200MHz and
-		 * 4. execute tuning for HS200
-		 */
-		if ((host->caps2 & MMC_CAP2_HS200) &&
-		    card->host->ops->execute_tuning) {
-			mmc_host_clk_hold(card->host);
-			err = card->host->ops->execute_tuning(card->host,
-				MMC_SEND_TUNING_BLOCK_HS200);
-			mmc_host_clk_release(card->host);
-		}
-		if (err) {
-			pr_warning("%s: tuning execution failed\n",
-				   mmc_hostname(card->host));
-			goto err;
-		}
-
-		ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
-				EXT_CSD_BUS_WIDTH_8 : EXT_CSD_BUS_WIDTH_4;
-		err = mmc_select_powerclass(card, ext_csd_bits, ext_csd);
-		if (err)
-			pr_warning("%s: power class selection to bus width %d"
-				   " failed\n", mmc_hostname(card->host),
-				   1 << bus_width);
-	}
-
 	/*
 	 * Activate wide bus and DDR (if supported).
 	 */
-	if (!mmc_card_hs200(card) &&
-	    (card->csd.mmca_vsn >= CSD_SPEC_VER_4) &&
+	if ((card->csd.mmca_vsn >= CSD_SPEC_VER_4) &&
 	    (host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
 		static unsigned ext_csd_bits[][2] = {
 			{ EXT_CSD_BUS_WIDTH_8, EXT_CSD_DDR_BUS_WIDTH_8 },
@@ -1208,18 +782,10 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 			bus_width = bus_widths[idx];
 			if (bus_width == MMC_BUS_WIDTH_1)
 				ddr = 0; /* no DDR for 1-bit width */
-			err = mmc_select_powerclass(card, ext_csd_bits[idx][0],
-						    ext_csd);
-			if (err)
-				pr_warning("%s: power class selection to "
-					   "bus width %d failed\n",
-					   mmc_hostname(card->host),
-					   1 << bus_width);
-
 			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 					 EXT_CSD_BUS_WIDTH,
 					 ext_csd_bits[idx][0],
-					 card->ext_csd.generic_cmd6_time);
+					 0);
 			if (!err) {
 				mmc_set_bus_width(card->host, bus_width);
 
@@ -1239,18 +805,10 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 		}
 
 		if (!err && ddr) {
-			err = mmc_select_powerclass(card, ext_csd_bits[idx][1],
-						    ext_csd);
-			if (err)
-				pr_warning("%s: power class selection to "
-					   "bus width %d ddr %d failed\n",
-					   mmc_hostname(card->host),
-					   1 << bus_width, ddr);
-
 			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 					 EXT_CSD_BUS_WIDTH,
 					 ext_csd_bits[idx][1],
-					 card->ext_csd.generic_cmd6_time);
+					 0);
 		}
 		if (err) {
 			printk(KERN_WARNING "%s: switch to bus width %d ddr %d "
@@ -1284,72 +842,6 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 		}
 	}
 
-	/*
-	 * Enable HPI feature (if supported)
-	 */
-	if (card->ext_csd.hpi) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				EXT_CSD_HPI_MGMT, 1,
-				card->ext_csd.generic_cmd6_time);
-		if (err && err != -EBADMSG)
-			goto free_card;
-		if (err) {
-			pr_warning("%s: Enabling HPI failed\n",
-				   mmc_hostname(card->host));
-			err = 0;
-		} else
-			card->ext_csd.hpi_en = 1;
-	}
-
-	/*
-	 * If cache size is higher than 0, this indicates
-	 * the existence of cache and it can be turned on.
-	 */
-	if ((host->caps2 & MMC_CAP2_CACHE_CTRL) &&
-			card->ext_csd.cache_size > 0) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				EXT_CSD_CACHE_CTRL, 1,
-				card->ext_csd.generic_cmd6_time);
-		if (err && err != -EBADMSG)
-			goto free_card;
-
-		/*
-		 * Only if no error, cache is turned on successfully.
-		 */
-		if (err) {
-			pr_warning("%s: Cache is supported, "
-					"but failed to turn on (%d)\n",
-					mmc_hostname(card->host), err);
-			card->ext_csd.cache_ctrl = 0;
-			err = 0;
-		} else {
-			card->ext_csd.cache_ctrl = 1;
-		}
-	}
-
-	/*
-	 * The mandatory minimum values are defined for packed command.
-	 * read: 5, write: 3
-	 */
-	if (card->ext_csd.max_packed_writes >= 3 &&
-	    card->ext_csd.max_packed_reads >= 5 &&
-	    host->caps2 & MMC_CAP2_PACKED_CMD) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				EXT_CSD_EXP_EVENTS_CTRL,
-				EXT_CSD_PACKED_EVENT_EN,
-				card->ext_csd.generic_cmd6_time);
-		if (err && err != -EBADMSG)
-			goto free_card;
-		if (err) {
-			pr_warn("%s: Enabling packed event failed\n",
-				mmc_hostname(card->host));
-			card->ext_csd.packed_event_en = 0;
-			err = 0;
-		} else {
-			card->ext_csd.packed_event_en = 1;
-		}
-	}
-
 	if (!oldcard)
 		host->card = card;
 
@@ -1365,35 +857,6 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	return err;
 }
 
-static int mmc_can_poweroff_notify(const struct mmc_card *card)
-{
-	return card &&
-		mmc_card_mmc(card) &&
-		(card->ext_csd.power_off_notification == EXT_CSD_POWER_ON);
-}
-
-static int mmc_poweroff_notify(struct mmc_card *card, unsigned int notify_type)
-{
-	unsigned int timeout = card->ext_csd.generic_cmd6_time;
-	int err;
-
-	/* Use EXT_CSD_POWER_OFF_SHORT as default notification type. */
-	if (notify_type == EXT_CSD_POWER_OFF_LONG)
-		timeout = card->ext_csd.power_off_longtime;
-
-	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			 EXT_CSD_POWER_OFF_NOTIFICATION,
-			 notify_type, timeout);
-	if (err)
-		pr_err("%s: Power Off Notification timed out, %u\n",
-		       mmc_hostname(card->host), timeout);
-
-	/* Disable the power off notification after the switch operation. */
-	card->ext_csd.power_off_notification = EXT_CSD_NO_POWER_NOTIFICATION;
-
-	return err;
-}
-
 /*
  * Host is being removed. Free up the current card.
  */
@@ -1406,14 +869,6 @@ static void mmc_remove(struct mmc_host *host)
 	host->card = NULL;
 }
 
-/*
- * Card detection - card is alive.
- */
-static int mmc_alive(struct mmc_host *host)
-{
-	return mmc_send_status(host->card, NULL);
-}
-
 /*
  * Card detection callback from host.
  */
@@ -1446,31 +901,18 @@ static void mmc_detect(struct mmc_host *host)
 /*
  * Suspend callback from host.
  */
-extern int mmc_cache_ctrl(struct mmc_host *host, u8 enable);
 static int mmc_suspend(struct mmc_host *host)
 {
-	int err = 0;
-
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
-
-	err = mmc_cache_ctrl(host, 0);
-	if (err)
-		goto out;
-
-	if (mmc_can_poweroff_notify(host->card))
-		err = mmc_poweroff_notify(host->card, EXT_CSD_POWER_OFF_SHORT);
-	else if (mmc_card_can_sleep(host))
-		err = mmc_card_sleep(host);
-	else if (!mmc_host_is_spi(host))
-		err = mmc_deselect_cards(host);
-	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_200);
-
-out:
+	if (!mmc_host_is_spi(host))
+		mmc_deselect_cards(host);
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_release_host(host);
-	return err;
+
+	return 0;
 }
 
 /*
@@ -1497,7 +939,7 @@ static int mmc_power_restore(struct mmc_host *host)
 {
 	int ret;
 
-	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_200);
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_claim_host(host);
 	ret = mmc_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
@@ -1543,7 +985,6 @@ static const struct mmc_bus_ops mmc_ops = {
 	.suspend = NULL,
 	.resume = NULL,
 	.power_restore = mmc_power_restore,
-	.alive = mmc_alive,
 };
 
 static const struct mmc_bus_ops mmc_ops_unsafe = {
@@ -1554,7 +995,6 @@ static const struct mmc_bus_ops mmc_ops_unsafe = {
 	.suspend = mmc_suspend,
 	.resume = mmc_resume,
 	.power_restore = mmc_power_restore,
-	.alive = mmc_alive,
 };
 
 static void mmc_attach_bus_ops(struct mmc_host *host)
@@ -1571,116 +1011,7 @@ static void mmc_attach_bus_ops(struct mmc_host *host)
 /*
  * Starting point for MMC card init.
  */
-static int sdmmc_attach_mmc(struct mmc_host *host)
-{
-	int err;
-	u32 ocr;
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-	int retry_times = 3;
-#endif
-
-	BUG_ON(!host);
-	WARN_ON(!host->claimed);
-
-	err = mmc_send_op_cond(host, 0, &ocr);
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-	if (err)
-		return 0xFF;//return err; Modifyed by xbw at 2011-11-17
-		
-    printk(KERN_INFO "\n%s..%d..  ===== Begin to identify card as MMC-card [%s]\n", \
-        __FUNCTION__, __LINE__, mmc_hostname(host));
-#else
-    if (err)
-    	return err;
-#endif        
-        
-	mmc_attach_bus_ops(host);
-	if (host->ocr_avail_mmc)
-		host->ocr_avail = host->ocr_avail_mmc;
-
-	/*
-	 * We need to get OCR a different way for SPI.
-	 */
-	if (mmc_host_is_spi(host)) {
-		err = mmc_spi_read_ocr(host, 1, &ocr);
-		if (err)
-			goto err;
-	}
-
-	/*
-	 * Sanity check the voltages that the card claims to
-	 * support.
-	 */
-	if (ocr & 0x7F) {
-		printk(KERN_WARNING "%s: card claims to support voltages "
-		       "below the defined range. These will be ignored.\n",
-		       mmc_hostname(host));
-		ocr &= ~0x7F;
-	}
-
-	host->ocr = mmc_select_voltage(host, ocr);
-
-	/*
-	 * Can we support the voltage of the card?
-	 */
-	if (!host->ocr) {
-		err = -EINVAL;
-		goto err;
-	}
-
-	/*
-	 * Detect and init the card.
-	 */
-	err = mmc_init_card(host, host->ocr, NULL);
-	if (err)
-		goto err;
-
-	mmc_release_host(host);
-
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-//modifyed by xbw at 2011--04-11
-Retry_add:
-	err = mmc_add_card(host->card);
-	mmc_claim_host(host);
-	if (err)
-	{
-	    //retry add the card; Added by xbw
-        if((--retry_times >= 0))
-        {        
-            printk(KERN_ERR "\n%s..%s..%d   ****error in add partition, so retry.  [%s]\n",__FUNCTION__,__FILE__,__LINE__, mmc_hostname(host));   
-            /* sleep some time */
-            set_current_state(TASK_INTERRUPTIBLE);
-            schedule_timeout(HZ/2);
-            
-            goto Retry_add;
-        }
-
-		goto remove_card;
-    
-	}
-#else
-	err = mmc_add_card(host->card);
-	mmc_claim_host(host);
-	if (err)
-		goto remove_card;
-#endif
-
-	return 0;
-
-remove_card:
-	mmc_release_host(host);
-	mmc_remove_card(host->card);
-	mmc_claim_host(host);
-	host->card = NULL;
-err:
-	mmc_detach_bus(host);
-
-	printk(KERN_ERR "%s: error %d whilst initialising MMC card\n",
-		mmc_hostname(host), err);
-
-	return err;
-}
-static int emmc_attach_mmc(struct mmc_host *host)
+int mmc_attach_mmc(struct mmc_host *host)
 {
 	int err;
 	u32 ocr;
@@ -1754,18 +1085,3 @@ static int emmc_attach_mmc(struct mmc_host *host)
 
 	return err;
 }
-
-int mmc_attach_mmc(struct mmc_host *host)
-{
-	if(HOST_IS_EMMC(host))
-		return emmc_attach_mmc(host);
-	else
-		return sdmmc_attach_mmc(host);
-}
-
-
-
-
-
-
-
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index b255f661064d..845ce7c533b9 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -365,41 +365,6 @@ int mmc_spi_set_crc(struct mmc_host *host, int use_crc)
 	return err;
 }
 
-static int __mmc_send_status(struct mmc_card *card, u32 *status,bool ignore_crc)
-{
-	int err;
-	struct mmc_command cmd = {0};
-
-	BUG_ON(!card);
-	BUG_ON(!card->host);
-
-	cmd.opcode = MMC_SEND_STATUS;
-	if (!mmc_host_is_spi(card->host))
-		cmd.arg = card->rca << 16;
-	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
-
-    if (ignore_crc)
-		cmd.flags &= ~MMC_RSP_CRC;
-
-	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
-	if (err)
-		return err;
-
-	/* NOTE: callers are required to understand the difference
-	 * between "native" and SPI format status words!
-	 */
-	if (status)
-		*status = cmd.resp[0];
-
-	return 0;
-}
-
-int mmc_send_status(struct mmc_card *card, u32 *status)
-{
-	return __mmc_send_status(card, status, false);
-}
-
-
 /**
  *	mmc_switch - modify EXT_CSD register
  *	@card: the MMC card associated with the data transfer
@@ -417,7 +382,6 @@ int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
 	int err;
 	struct mmc_command cmd = {0};
 	u32 status;
-    bool ignore_crc = false;
 
 	BUG_ON(!card);
 	BUG_ON(!card->host);
@@ -434,19 +398,9 @@ int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
 	if (err)
 		return err;
 
-    /*
-	 * Must check status to be sure of no errors
-	 * If CMD13 is to check the busy completion of the timing change,
-	 * disable the check of CRC error.
-	 */
-	if (index == EXT_CSD_HS_TIMING &&
-	    !(card->host->caps & MMC_CAP_WAIT_WHILE_BUSY))
-		ignore_crc = true;
-    
-
 	/* Must check status to be sure of no errors */
 	do {
-		err = __mmc_send_status(card, &status,ignore_crc);
+		err = mmc_send_status(card, &status);
 		if (err)
 			return err;
 		if (card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
@@ -470,6 +424,31 @@ int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
 }
 EXPORT_SYMBOL_GPL(mmc_switch);
 
+int mmc_send_status(struct mmc_card *card, u32 *status)
+{
+	int err;
+	struct mmc_command cmd = {0};
+
+	BUG_ON(!card);
+	BUG_ON(!card->host);
+
+	cmd.opcode = MMC_SEND_STATUS;
+	if (!mmc_host_is_spi(card->host))
+		cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+	if (err)
+		return err;
+
+	/* NOTE: callers are required to understand the difference
+	 * between "native" and SPI format status words!
+	 */
+	if (status)
+		*status = cmd.resp[0];
+
+	return 0;
+}
 
 static int
 mmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 2ffe1690f9b5..e6629b986f05 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -23,7 +23,6 @@
 #include "mmc_ops.h"
 #include "sd.h"
 #include "sd_ops.h"
-#include "host.h"
 
 static const unsigned int tran_exp[] = {
 	10000,		100000,		1000000,	10000000,
@@ -215,7 +214,7 @@ static int mmc_decode_scr(struct mmc_card *card)
 static int mmc_read_ssr(struct mmc_card *card)
 {
 	unsigned int au, es, et, eo;
-	int err, i, max_au;
+	int err, i;
 	u32 *ssr;
 
 	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
@@ -239,14 +238,12 @@ static int mmc_read_ssr(struct mmc_card *card)
 	for (i = 0; i < 16; i++)
 		ssr[i] = be32_to_cpu(ssr[i]);
 
-	max_au = card->scr.sda_spec3 ? 0xF : 0x9;
 	/*
 	 * UNSTUFF_BITS only works with four u32s so we have to offset the
 	 * bitfield positions accordingly.
 	 */
 	au = UNSTUFF_BITS(ssr, 428 - 384, 4);
-    //if (au > 0 || au <= 9) {  //Modifyed by xbw at 2013-02-28
-	if (au > 0 && au <= max_au) {
+	if (au > 0 || au <= 9) {
 		card->ssr.au = 1 << (au + 4);
 		es = UNSTUFF_BITS(ssr, 408 - 384, 16);
 		et = UNSTUFF_BITS(ssr, 402 - 384, 6);
@@ -293,8 +290,7 @@ static int mmc_read_switch(struct mmc_card *card)
 	}
 
 	/* Find out the supported Bus Speed Modes. */
-    //err = mmc_sd_switch(card, 0, 0, 1, status);
-    err = mmc_sd_switch(card, 0, 0, 0, status);  //Modifyed by xbw at 2013-02-28
+	err = mmc_sd_switch(card, 0, 0, 1, status);
 	if (err) {
 		/*
 		 * If the host or the card can't do the switch,
@@ -313,9 +309,7 @@ static int mmc_read_switch(struct mmc_card *card)
 	if (status[13] & UHS_SDR50_BUS_SPEED)
 		card->sw_caps.hs_max_dtr = 50000000;
 
-    //mask the the SD Ver3.0 support,modifyed by xbw at 2012-8-09
-	//if (card->scr.sda_spec3) {
-	if(0) {
+	if (card->scr.sda_spec3) {
 		card->sw_caps.sd3_bus_mode = status[13];
 
 		/* Find out Driver Strengths supported by the card */
@@ -630,12 +624,8 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 		goto out;
 
 	/* SPI mode doesn't define CMD19 */
-	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning &&
-	    (card->sd_bus_speed == UHS_SDR50_BUS_SPEED ||
-	     card->sd_bus_speed == UHS_SDR104_BUS_SPEED))
-
-	    mmc_host_clk_hold(card->host);
-		err = card->host->ops->execute_tuning(card->host,MMC_SEND_TUNING_BLOCK);
+	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning)
+		err = card->host->ops->execute_tuning(card->host);
 
 out:
 	kfree(status);
@@ -728,13 +718,8 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 
 try_again:
 	err = mmc_send_app_op_cond(host, ocr, rocr);
-	if (err) {
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-	    printk(KERN_WARNING "%s..%d..  ====*Identify the card as SD , but OCR error, so fail to initialize.[%s]\n", \
-	        __FUNCTION__, __LINE__, mmc_hostname(host));
-#endif
+	if (err)
 		return err;
-	}
 
 	/*
 	 * In case CCS and S18A in the response is set, start Signal Voltage
@@ -822,13 +807,6 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 				printk(KERN_WARNING
 				       "%s: read switch failed (attempt %d)\n",
 				       mmc_hostname(host), retries);
-
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-				if(0 == host->re_initialized_flags)
-				{
-					 break; //Added by xbw at 2011-06-21
-				}
-#endif
 			}
 		}
 #else
@@ -881,11 +859,6 @@ unsigned mmc_sd_get_max_clock(struct mmc_card *card)
 		if (max_dtr > card->sw_caps.hs_max_dtr)
 			max_dtr = card->sw_caps.hs_max_dtr;
 	} else if (max_dtr > card->csd.max_dtr) {
-
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-        //in order to expand the compatibility of card. Added by xbw@2011-03-21
-	    card->csd.max_dtr = (card->csd.max_dtr > SD_FPP_FREQ) ? SD_FPP_FREQ : (card->csd.max_dtr); 
-#endif
 		max_dtr = card->csd.max_dtr;
 	}
 
@@ -1056,15 +1029,6 @@ static void mmc_sd_detect(struct mmc_host *host)
 		err = mmc_send_status(host->card, NULL);
 		if (err) {
 			retries--;
-
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-		  if(0 == host->re_initialized_flags)
-			{
-				 retries = 0;
-				 break; //Added by xbw at 2011-06-21
-			}
-#endif
-
 			udelay(5);
 			continue;
 		}
@@ -1133,13 +1097,6 @@ static int mmc_sd_resume(struct mmc_host *host)
 			       mmc_hostname(host), err, retries);
 			mdelay(5);
 			retries--;
-
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-			if(0 == host->re_initialized_flags)
-			{
-				 break; //Added by xbw at 2011-06-21
-			}
-#endif
 			continue;
 		}
 		break;
@@ -1198,10 +1155,6 @@ int mmc_attach_sd(struct mmc_host *host)
 {
 	int err;
 	u32 ocr;
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-	int retry_times = 3;
-#endif
-
 #ifdef CONFIG_MMC_PARANOID_SD_INIT
 	int retries;
 #endif
@@ -1219,16 +1172,9 @@ int mmc_attach_sd(struct mmc_host *host)
 		host->ops->enable_preset_value(host, false);
 
 	err = mmc_send_app_op_cond(host, 0, &ocr);
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)	
-	if (err)
-		return 0xFF;//return err; Modifyed by xbw at 2011-11-17
-		
-    printk(KERN_INFO "\n%s..%d..  ===== Begin to identify card as SD-card. [%s]\n",\
-        __FUNCTION__, __LINE__, mmc_hostname(host));
-#else
 	if (err)
 		return err;
-#endif
+
 	mmc_sd_attach_bus_ops(host);
 	if (host->ocr_avail_sd)
 		host->ocr_avail = host->ocr_avail_sd;
@@ -1282,14 +1228,6 @@ int mmc_attach_sd(struct mmc_host *host)
 		err = mmc_sd_init_card(host, host->ocr, NULL);
 		if (err) {
 			retries--;
-
-	#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-			if(0 == host->re_initialized_flags)
-			{
-				 retries = 0;
-				 break; //Added by xbw at 2011-06-21
-			}
-	#endif
 			continue;
 		}
 		break;
@@ -1307,34 +1245,10 @@ int mmc_attach_sd(struct mmc_host *host)
 #endif
 
 	mmc_release_host(host);
-
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-//modifyed by xbw at 2011--04-11
-Retry_add:
-	err = mmc_add_card(host->card);
-	mmc_claim_host(host);
-	if (err)
-	{
-	    //retry add the card; Added by xbw
-        if((--retry_times >= 0))
-        {        
-            printk(KERN_WARNING "\n%s..%s..%d   ****error in add partition, so retry.  [%s]\n",__FUNCTION__,__FILE__,__LINE__, mmc_hostname(host));   
-            /* sleep some time */
-            set_current_state(TASK_INTERRUPTIBLE);
-            schedule_timeout(HZ/2);
-            
-            goto Retry_add;
-        }
-
-		goto remove_card;
-    
-	}
-#else
 	err = mmc_add_card(host->card);
 	mmc_claim_host(host);
 	if (err)
 		goto remove_card;
-#endif
 
 	return 0;
 
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 8c2245a67891..5d1719932664 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -17,12 +17,10 @@
 #include <linux/mmc/sdio.h>
 #include <linux/mmc/sdio_func.h>
 #include <linux/mmc/sdio_ids.h>
-#include <linux/mmc/mmc.h>
 
 #include "core.h"
 #include "bus.h"
 #include "sd.h"
-#include "host.h"
 #include "sdio_bus.h"
 #include "mmc_ops.h"
 #include "sd_ops.h"
@@ -103,13 +101,11 @@ static int sdio_init_func(struct mmc_card *card, unsigned int fn)
 	return ret;
 }
 
-static int sdio_read_cccr(struct mmc_card *card,u32 ocr)
+static int sdio_read_cccr(struct mmc_card *card)
 {
 	int ret;
 	int cccr_vsn;
-	int uhs = ocr & R4_18V_PRESENT;
 	unsigned char data;
-	unsigned char speed;
 
 	memset(&card->cccr, 0, sizeof(struct sdio_cccr));
 
@@ -119,7 +115,7 @@ static int sdio_read_cccr(struct mmc_card *card,u32 ocr)
 
 	cccr_vsn = data & 0x0f;
 
-	if (cccr_vsn > SDIO_CCCR_REV_3_00) {
+	if (cccr_vsn > SDIO_CCCR_REV_1_20) {
 		printk(KERN_ERR "%s: unrecognised CCCR structure version %d\n",
 			mmc_hostname(card->host), cccr_vsn);
 		return -EINVAL;
@@ -151,54 +147,9 @@ static int sdio_read_cccr(struct mmc_card *card,u32 ocr)
 		ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &data);
 		if (ret)
 			goto out;
-			
-        card->scr.sda_spec3 = 0;
-        card->sw_caps.sd3_bus_mode = 0;
-        card->sw_caps.sd3_drv_type = 0;
-
-        if (cccr_vsn >= SDIO_CCCR_REV_3_00 && uhs) {
-			card->scr.sda_spec3 = 1;
-			ret = mmc_io_rw_direct(card, 0, 0,
-				SDIO_CCCR_UHS, 0, &data);
-			if (ret)
-				goto out;
-
-			if (mmc_host_uhs(card->host)) {
-				if (data & SDIO_UHS_DDR50)
-					card->sw_caps.sd3_bus_mode
-						|= SD_MODE_UHS_DDR50;
-
-				if (data & SDIO_UHS_SDR50)
-					card->sw_caps.sd3_bus_mode
-						|= SD_MODE_UHS_SDR50;
-
-				if (data & SDIO_UHS_SDR104)
-					card->sw_caps.sd3_bus_mode
-						|= SD_MODE_UHS_SDR104;
-			}
-
-			ret = mmc_io_rw_direct(card, 0, 0,
-				SDIO_CCCR_DRIVE_STRENGTH, 0, &data);
-			if (ret)
-				goto out;
-
-			if (data & SDIO_DRIVE_SDTA)
-				card->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_A;
-			if (data & SDIO_DRIVE_SDTC)
-				card->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_C;
-			if (data & SDIO_DRIVE_SDTD)
-				card->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_D;
-		}
 
-        if (!card->sw_caps.sd3_bus_mode) {
-		    if (data & SDIO_SPEED_SHS)
-			    card->cccr.high_speed = 1;
-                card->sw_caps.hs_max_dtr = 50000000;
-		    } else {
-				card->cccr.high_speed = 0;
-				card->sw_caps.hs_max_dtr = 25000000;
-			}
-		
+		if (data & SDIO_SPEED_SHS)
+			card->cccr.high_speed = 1;
 	}
 
 out:
@@ -220,12 +171,6 @@ static int sdio_enable_wide(struct mmc_card *card)
 	if (ret)
 		return ret;
 
-    if ((ctrl & SDIO_BUS_WIDTH_MASK) == SDIO_BUS_WIDTH_RESERVED)
-		printk("%s: SDIO_CCCR_IF is invalid: 0x%02x\n",
-			   mmc_hostname(card->host), ctrl);
-
-    /* set as 4-bit bus width */
-	ctrl &= ~SDIO_BUS_WIDTH_MASK;
 	ctrl |= SDIO_BUS_WIDTH_4BIT;
 
 	ret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
@@ -386,209 +331,6 @@ static unsigned mmc_sdio_get_max_clock(struct mmc_card *card)
 	return max_dtr;
 }
 
-static unsigned char host_drive_to_sdio_drive(int host_strength)
-{
-	switch (host_strength) {
-	case MMC_SET_DRIVER_TYPE_A:
-		return SDIO_DTSx_SET_TYPE_A;
-	case MMC_SET_DRIVER_TYPE_B:
-		return SDIO_DTSx_SET_TYPE_B;
-	case MMC_SET_DRIVER_TYPE_C:
-		return SDIO_DTSx_SET_TYPE_C;
-	case MMC_SET_DRIVER_TYPE_D:
-		return SDIO_DTSx_SET_TYPE_D;
-	default:
-		return SDIO_DTSx_SET_TYPE_B;
-	}
-}
-
-
-static void sdio_select_driver_type(struct mmc_card *card)
-{
-	int host_drv_type = SD_DRIVER_TYPE_B;
-	int card_drv_type = SD_DRIVER_TYPE_B;
-	int drive_strength;
-	unsigned char card_strength;
-	int err;
-
-	/*
-	 * If the host doesn't support any of the Driver Types A,C or D,
-	 * or there is no board specific handler then default Driver
-	 * Type B is used.
-	 */
-	if (!(card->host->caps &
-		(MMC_CAP_DRIVER_TYPE_A |
-		 MMC_CAP_DRIVER_TYPE_C |
-		 MMC_CAP_DRIVER_TYPE_D)))
-		return;
-
-	if (!card->host->ops->select_drive_strength)
-		return;
-
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A)
-		host_drv_type |= SD_DRIVER_TYPE_A;
-
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_C)
-		host_drv_type |= SD_DRIVER_TYPE_C;
-
-	if (card->host->caps & MMC_CAP_DRIVER_TYPE_D)
-		host_drv_type |= SD_DRIVER_TYPE_D;
-
-	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
-		card_drv_type |= SD_DRIVER_TYPE_A;
-
-	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
-		card_drv_type |= SD_DRIVER_TYPE_C;
-
-	if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)
-		card_drv_type |= SD_DRIVER_TYPE_D;
-
-	/*
-	 * The drive strength that the hardware can support
-	 * depends on the board design.  Pass the appropriate
-	 * information and let the hardware specific code
-	 * return what is possible given the options
-	 */
-	drive_strength = card->host->ops->select_drive_strength(
-		card->sw_caps.uhs_max_dtr,
-		host_drv_type, card_drv_type);
-
-	/* if error just use default for drive strength B */
-	err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,
-		&card_strength);
-	if (err)
-		return;
-
-	card_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);
-	card_strength |= host_drive_to_sdio_drive(drive_strength);
-
-	err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,
-		card_strength, NULL);
-
-	/* if error default to drive strength B */
-	if (!err)
-		mmc_set_driver_type(card->host, drive_strength);
-}
-
-
-static int sdio_set_bus_speed_mode(struct mmc_card *card)
-{
-	unsigned int bus_speed, timing;
-	int err;
-	unsigned char speed;
-
-	/*
-	 * If the host doesn't support any of the UHS-I modes, fallback on
-	 * default speed.
-	 */
-	if (!mmc_host_uhs(card->host))
-		return 0;
-
-	bus_speed = SDIO_SPEED_SDR12;
-	timing = MMC_TIMING_UHS_SDR12;
-	if ((card->host->caps & MMC_CAP_UHS_SDR104) &&
-	    (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {
-			bus_speed = SDIO_SPEED_SDR104;
-			timing = MMC_TIMING_UHS_SDR104;
-			card->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;
-			card->sd_bus_speed = UHS_SDR104_BUS_SPEED;
-	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
-		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {
-			bus_speed = SDIO_SPEED_DDR50;
-			timing = MMC_TIMING_UHS_DDR50;
-			card->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;
-			card->sd_bus_speed = UHS_DDR50_BUS_SPEED;
-	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
-		    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &
-		    SD_MODE_UHS_SDR50)) {
-			bus_speed = SDIO_SPEED_SDR50;
-			timing = MMC_TIMING_UHS_SDR50;
-			card->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;
-			card->sd_bus_speed = UHS_SDR50_BUS_SPEED;
-	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
-		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25)) &&
-		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {
-			bus_speed = SDIO_SPEED_SDR25;
-			timing = MMC_TIMING_UHS_SDR25;
-			card->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;
-			card->sd_bus_speed = UHS_SDR25_BUS_SPEED;
-	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
-		    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25 |
-		    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &
-		    SD_MODE_UHS_SDR12)) {
-			bus_speed = SDIO_SPEED_SDR12;
-			timing = MMC_TIMING_UHS_SDR12;
-			card->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;
-			card->sd_bus_speed = UHS_SDR12_BUS_SPEED;
-	}
-
-	err = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);
-	if (err)
-		return err;
-
-	speed &= ~SDIO_SPEED_BSS_MASK;
-	speed |= bus_speed;
-	err = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);
-	if (err)
-		return err;
-
-	if (bus_speed) {
-		mmc_set_timing(card->host, timing);
-		mmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);
-	}
-
-	return 0;
-}
-
-
-/*
- * UHS-I specific initialization procedure
- */
-static int mmc_sdio_init_uhs_card(struct mmc_card *card)
-{
-	int err;
-
-	if (!card->scr.sda_spec3)
-		return 0;
-
-	/*
-	 * Switch to wider bus (if supported).
-	 */
-	if (card->host->caps & MMC_CAP_4_BIT_DATA) {
-		err = sdio_enable_4bit_bus(card);
-		if (err > 0) {
-			mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
-			err = 0;
-		}
-	}
-
-	/* Set the driver strength for the card */
-	sdio_select_driver_type(card);
-
-	/* Set bus speed mode of the card */
-	err = sdio_set_bus_speed_mode(card);
-	if (err)
-		goto out;
-
-    
-     /*
-      * SPI mode doesn't define CMD19 and tuning is only valid for SDR50 and
-      * SDR104 mode SD-cards. Note that tuning is mandatory for SDR104.
-      */
-     if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning &&
-          ((card->sw_caps.sd3_bus_mode == SD_MODE_UHS_SDR50) ||
-           (card->sw_caps.sd3_bus_mode ==  SD_MODE_UHS_SDR104))) {
-                  mmc_host_clk_hold(card->host);
-                   err = card->host->ops->execute_tuning(card->host,MMC_SEND_TUNING_BLOCK);
-                  mmc_host_clk_release(card->host);
-      }
-
-out:
-
-	return err;
-}
-
-
 /*
  * Handle the detection and initialisation of a card.
  *
@@ -600,32 +342,17 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 {
 	struct mmc_card *card;
 	int err;
-	int retries = 10;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-
-try_again:
-     if (!retries) {
-           pr_warning("%s: Skipping voltage switch\n",
-                   mmc_hostname(host));
-           ocr &= ~R4_18V_PRESENT;
-           host->ocr &= ~R4_18V_PRESENT;
-     }
-
 	/*
 	 * Inform the card of the voltage
 	 */
 	if (!powered_resume) {
 		err = mmc_send_io_op_cond(host, host->ocr, &ocr);
-		if (err) {
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-	    printk(KERN_ERR "%s..%d..  ====*Identify the card as SDIO , but OCR error, so fail to initialize. [%s]\n", \
-	        __FUNCTION__, __LINE__, mmc_hostname(host));
-#endif
+		if (err)
 			goto err;
-		}
 	}
 
 	/*
@@ -670,32 +397,6 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	if (host->ops->init_card)
 		host->ops->init_card(host, card);
 
-    /*
-	 * If the host and card support UHS-I mode request the card
-	 * to switch to 1.8V signaling level.  No 1.8v signalling if
-	 * UHS mode is not enabled to maintain compatibility and some
-	 * systems that claim 1.8v signalling in fact do not support
-	 * it.
-	 */
-	if (!powered_resume && (ocr & R4_18V_PRESENT) && mmc_host_uhs(host)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,1);
-		if (err == -EAGAIN) {
-			sdio_reset(host);
-			mmc_go_idle(host);
-			mmc_send_if_cond(host, host->ocr_avail);
-			mmc_remove_card(card);
-			retries--;
-			goto try_again;
-		} else if (err) {
-			ocr &= ~R4_18V_PRESENT;
-			host->ocr &= ~R4_18V_PRESENT;
-		}
-		err = 0;
-	} else {
-		ocr &= ~R4_18V_PRESENT;
-		host->ocr &= ~R4_18V_PRESENT;
-	}
-    
 	/*
 	 * For native busses:  set card RCA and quit open drain mode.
 	 */
@@ -760,7 +461,7 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 		/*
 		 * Read the common registers.
 		 */
-		err = sdio_read_cccr(card,ocr);
+		err = sdio_read_cccr(card);
 		if (err)
 			goto remove;
 #ifdef CONFIG_MMC_EMBEDDED_SDIO
@@ -813,39 +514,29 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	if (err)
 		goto remove;
 
-    /* Initialization sequence for UHS-I cards */
-	/* Only if card supports 1.8v and UHS signaling */
-	if ((ocr & R4_18V_PRESENT) && card->sw_caps.sd3_bus_mode) {
-		err = mmc_sdio_init_uhs_card(card);
-		if (err)
-			goto remove;
+	/*
+	 * Switch to high-speed (if supported).
+	 */
+	err = sdio_enable_hs(card);
+	if (err > 0)
+		mmc_sd_go_highspeed(card);
+	else if (err)
+		goto remove;
+
+	/*
+	 * Change to the card's maximum speed.
+	 */
+	mmc_set_clock(host, mmc_sdio_get_max_clock(card));
+
+	/*
+	 * Switch to wider bus (if supported).
+	 */
+	err = sdio_enable_4bit_bus(card);
+	if (err > 0)
+		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
+	else if (err)
+		goto remove;
 
-		/* Card is an ultra-high-speed card */
-		mmc_card_set_uhs(card);
-	} else {
-    	/*
-    	 * Switch to high-speed (if supported).
-    	 */
-    	err = sdio_enable_hs(card);
-    	if (err > 0)
-    		mmc_sd_go_highspeed(card);
-    	else if (err)
-    		goto remove;
-
-    	/*
-    	 * Change to the card's maximum speed.
-    	 */
-    	mmc_set_clock(host, mmc_sdio_get_max_clock(card));
-
-    	/*
-    	 * Switch to wider bus (if supported).
-    	 */
-    	err = sdio_enable_4bit_bus(card);
-    	if (err > 0)
-    		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
-    	else if (err)
-    		goto remove;
-    }
 finish:
 	if (!oldcard)
 		host->card = card;
@@ -993,15 +684,8 @@ static int mmc_sdio_resume(struct mmc_host *host)
 		}
 	}
 
-#if defined(CONFIG_MTK_COMBO) && defined(CONFIG_MTK_COMBO_DRIVER_VERSION_JB2)
-    /* sdio_funcs are NOT resumed yet! Signal irq only in host driver. */
-    //
-    // do not to  wake up sdio_irq_thread; noted by xbw at 2013-05-08
-    //
-#else
 	if (!err && host->sdio_irqs)
 		wake_up_process(host->sdio_irq_thread);
-#endif
 	mmc_release_host(host);
 
 	/*
@@ -1103,17 +787,9 @@ int mmc_attach_sdio(struct mmc_host *host)
 	WARN_ON(!host->claimed);
 
 	err = mmc_send_io_op_cond(host, 0, &ocr);
-	
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)	
 	if (err)
-		return 0xFF;//return err; //Modifyed by xbw at 2011-11-17
-		
-    printk(KERN_INFO "\n%s..%d..  ===== Begin to identify card as SDIO-card. [%s]\n",\
-        __FUNCTION__, __LINE__, mmc_hostname(host));
-#else
-    if (err)
 		return err;
-#endif        
+
 	mmc_attach_bus(host, &mmc_sdio_ops);
 	if (host->ocr_avail_sdio)
 		host->ocr_avail = host->ocr_avail_sdio;
@@ -1257,11 +933,6 @@ int sdio_reset_comm(struct mmc_card *card)
 	printk("%s():\n", __func__);
 	mmc_claim_host(host);
 
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-	host->sdmmc_host_hw_init(mmc_priv(host));  //added by xbw , at 2011-10-18
-	host->ios.clock = host->f_min; //for avoid 25MHz once again during init process.noted by xbw at 2011-11-14
-#endif
-
 	mmc_go_idle(host);
 
 	mmc_set_clock(host, host->f_min);
diff --git a/drivers/mmc/core/sdio_cis.c b/drivers/mmc/core/sdio_cis.c
index 25c9779a92c4..541bdb89e0c5 100644
--- a/drivers/mmc/core/sdio_cis.c
+++ b/drivers/mmc/core/sdio_cis.c
@@ -313,19 +313,10 @@ static int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)
 
 			if (ret == -ENOENT) {
 				/* warn about unknown tuples */
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-                // This is the normal exit procedure,rather than an error.noted by xbw at 2011-12-14
-				printk(KERN_DEBUG "%s: queuing unknown"
+				printk(KERN_WARNING "%s: queuing unknown"
 				       " CIS tuple 0x%02x (%u bytes)\n",
 				       mmc_hostname(card->host),
 				       tpl_code, tpl_link);
-#else
-                printk(KERN_WARNING "%s: queuing unknown"
-				       " CIS tuple 0x%02x (%u bytes)\n",
-				       mmc_hostname(card->host),
-				       tpl_code, tpl_link);
-
-#endif
 			}
 
 			/* keep on analyzing tuples */
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index e0d6d9e1bd32..56dbf3f6ad08 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -4,93 +4,6 @@
 
 comment "MMC/SD/SDIO Host Controller Drivers"
 
-config EMMC_RK
-	tristate "RK emmc controller suppport"
-	depends on ARCH_RK3188 || ARCH_RK3066B || ARCH_RK3026 || ARCH_RK319X
-	default y
-	help
-		This selects the RK EMMC controller
-
-config SDMMC_RK29
-	tristate "RK29 SDMMC controller suppport"
-	depends on PLAT_RK
-	help
-		This selects the RK29 SDMMC controller.
-		SDMMC0 used for sd/mmc card, and SDMMC1 used for sdio.
-if SDMMC_RK29
-    comment "Now, there are two SDMMC controllers selected, SDMMC0 and SDMMC1."
-	config SDMMC_RK29_OLD
-		bool "Old driver (DEPRECATED)"
-		help
-			 You will select old,origin driver for your project if you say Yes.
-			 It is not good to select the driver.
-
-	config SDMMC0_RK29
-		tristate "RK29 SDMMC0 controller support(sdmmc)"
-		default y
-		help
-			This supports the use of the SDMMC0 controller on Rk29 processors.
-			
-	config SDMMC0_RK29_WRITE_PROTECT
-		bool "Write-protect for SDMMC0"
-		default n
-		depends on SDMMC0_RK29
-		help
-			 You will add the feature of write-protect for sdmmc-card if you say Yes.
-			 Please note that this feature requires hardware support.
-	
-	config SDMMC0_RK29_SDCARD_DET_FROM_GPIO
-        bool "use the gpio-interrupt to detect card"
-        default n
-        depends on SDMMC0_RK29
-            help
-	           You can detect the presence of card by the gpio-interrupt if you say Yes.
-			   Of course, you must define the pin-name for the detect-pin.
-
-			   If you say No, then detect the card by register interrupt.
-
-	config USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD
-	    depends on SDMMC0_RK29
-		bool "Switch the driver SDMMC0 for the debug of wifi_develop_board."
-		default n
-		help
-			In order to debug the Wifi development board using SD interface,
-			we can switch the driver SDMMC0.
-
-
-	config SDMMC1_RK29
-		tristate "RK29 SDMMC1 controller support(sdio)"
-		default y
-		help
-			This supports the use of the SDMMC1 controller on Rk29 processors.
-	config SDMMC1_RK29_WRITE_PROTECT
-		bool "Write-protect for SDMMC1"
-		default n
-		depends on SDMMC1_RK29
-		help
-			 You will add the feature of write-protect for sdio-card if you say Yes.
-			 Please note that this feature requires hardware support.
-			
-       config  RK29_SDIO_IRQ_FROM_GPIO
-         bool "sdio-irq from gpio"
-         default n
-         depends on SDMMC1_RK29 && (BCM_OOB_ENABLED || MT6620)
-         help
-            You will generate sdio interrupt from gpio if you say Yes.
-            Please note that this feature requires hardware support.
-
-
-
-#	config USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD
-#	  depends on SDMMC1_RK29
-#		bool "Switch the driver SDMMC1 for the debug of wifi_develop_board."
-#		default n
-#		help
-#			In order to debug the Wifi development board using SD interface,
-#			we can switch the driver SDMMC1.
-
-endif
-
 config MMC_ARMMMCI
 	tristate "ARM AMBA Multimedia Card Interface support"
 	depends on ARM_AMBA
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index f8117e72e1b4..58a5cf73d6e9 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -2,13 +2,6 @@
 # Makefile for MMC/SD host controller drivers
 #
 
-ifeq ($(CONFIG_SDMMC_RK29_OLD),y)
-obj-$(CONFIG_SDMMC_RK29)	+= rk29_sdmmc_old.o
-else
-obj-$(CONFIG_SDMMC_RK29)	+= rk29_sdmmc.o
-endif
-
-obj-$(CONFIG_EMMC_RK)           += rkemmc.o rkemmc_ops.o
 obj-$(CONFIG_MMC_ARMMMCI)	+= mmci.o
 obj-$(CONFIG_MMC_PXA)		+= pxamci.o
 obj-$(CONFIG_MMC_IMX)		+= imxmmc.o
diff --git a/drivers/mtd/Kconfig b/drivers/mtd/Kconfig
index 9dc070084a09..4be8373d43e5 100644
--- a/drivers/mtd/Kconfig
+++ b/drivers/mtd/Kconfig
@@ -326,8 +326,6 @@ source "drivers/mtd/devices/Kconfig"
 
 source "drivers/mtd/nand/Kconfig"
 
-source "drivers/mtd/rknand/Kconfig"
-
 source "drivers/mtd/onenand/Kconfig"
 
 source "drivers/mtd/lpddr/Kconfig"
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index b97e4e75f68d..39664c4229ff 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -29,6 +29,6 @@ obj-$(CONFIG_MTD_SWAP)		+= mtdswap.o
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
 
-obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/  rknand/
+obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/
 
 obj-$(CONFIG_MTD_UBI)		+= ubi/
diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c
index f67bfd08dc45..bff8d4671ad6 100644
--- a/drivers/mtd/mtd_blkdevs.c
+++ b/drivers/mtd/mtd_blkdevs.c
@@ -40,7 +40,6 @@
 static LIST_HEAD(blktrans_majors);
 static DEFINE_MUTEX(blktrans_ref_mutex);
 
-#define MTD_MERGE                       1
 static void blktrans_dev_release(struct kref *kref)
 {
 	struct mtd_blktrans_dev *dev =
@@ -75,31 +74,16 @@ static void blktrans_dev_put(struct mtd_blktrans_dev *dev)
 	mutex_unlock(&blktrans_ref_mutex);
 }
 
-#if(MTD_MERGE == 0)
+
 static int do_blktrans_request(struct mtd_blktrans_ops *tr,
 			       struct mtd_blktrans_dev *dev,
 			       struct request *req)
 {
 	unsigned long block, nsect;
 	char *buf;
-#if 0
+
 	block = blk_rq_pos(req) << 9 >> tr->blkshift;
 	nsect = blk_rq_cur_bytes(req) >> tr->blkshift;
-#else  //modify by zyf for cap>=4GB 20110120
-	block = blk_rq_pos(req);
-	nsect = blk_rq_cur_bytes(req) >> tr->blkshift;
-    if(tr->blkshift != 9)
-    {
-        if(tr->blkshift > 9)
-        {
-    	    block = blk_rq_pos(req) >> (tr->blkshift - 9);
-        }
-        else
-        {
-	        block = blk_rq_pos(req) << (9 - tr->blkshift);
-        }
-    }
-#endif
 
 	buf = req->buffer;
 
@@ -115,8 +99,8 @@ static int do_blktrans_request(struct mtd_blktrans_ops *tr,
 
 	switch(rq_data_dir(req)) {
 	case READ:
-		//for (; nsect > 0; nsect--, block++, buf += tr->blksize)
-			if (tr->readsect(dev, block,nsect, buf))
+		for (; nsect > 0; nsect--, block++, buf += tr->blksize)
+			if (tr->readsect(dev, block, buf))
 				return -EIO;
 		rq_flush_dcache_pages(req);
 		return 0;
@@ -125,8 +109,8 @@ static int do_blktrans_request(struct mtd_blktrans_ops *tr,
 			return -EIO;
 
 		rq_flush_dcache_pages(req);
-		//for (; nsect > 0; nsect--, block++, buf += tr->blksize)
-			if (tr->writesect(dev, block,nsect, buf))
+		for (; nsect > 0; nsect--, block++, buf += tr->blksize)
+			if (tr->writesect(dev, block, buf))
 				return -EIO;
 		return 0;
 	default:
@@ -151,7 +135,7 @@ static int mtd_blktrans_thread(void *arg)
 	struct request_queue *rq = dev->rq;
 	struct request *req = NULL;
 	int background_done = 0;
-	
+
 	spin_lock_irq(rq->queue_lock);
 
 	while (!kthread_should_stop()) {
@@ -204,224 +188,7 @@ static int mtd_blktrans_thread(void *arg)
 
 	return 0;
 }
-#else
-
-#define MTD_RW_SECTORS  (2048)     // 2048 (BLK_SAFE_MAX_SECTORS+1)
-static char * mtd_rw_buffer;       //[MTD_RW_SECTORS*512]   __attribute__((aligned(4096)));
-struct mutex  mtd_rw_buffer_lock;
-static int req_check_buffer_align(struct request *req,char **pbuf)
-{
-    int    nr_vec = 0;
-    struct bio_vec *bv;
-    struct req_iterator iter;
-    char *buffer;
-    void *firstbuf = 0;
-    char *nextbuffer = 0;
-	unsigned long block, nsect;
-	block = blk_rq_pos(req);
-	nsect = blk_rq_cur_bytes(req) >> 9;
-	rq_for_each_segment(bv, req, iter)
-	{
-	    buffer = page_address(bv->bv_page) + bv->bv_offset;
-	    if( firstbuf == 0 )
-	    {
-            firstbuf = buffer;
-	    }
-        nr_vec++;
-        if(nextbuffer!=0)
-        {
-            if(nextbuffer!=buffer)
-            {
-                return 0;
-            }    
-        }
-        nextbuffer = buffer+bv->bv_len;
-	}
-	*pbuf = firstbuf;
-	return 1;
-}
 
-
-int mtd_blktrans_cease_background(struct mtd_blktrans_dev *dev)
-{
-	if (kthread_should_stop())
-		return 1;
-
-	return dev->bg_stop;
-}
-EXPORT_SYMBOL_GPL(mtd_blktrans_cease_background);
-
-static int mtd_blktrans_thread(void *arg)
-{
-	struct mtd_blktrans_dev *dev = arg;
-	struct mtd_blktrans_ops *tr = dev->tr;
-	struct request_queue *rq = dev->rq;
-	struct request *req = NULL;
-	int background_done = 0;
-	
-	unsigned long block, data_len;
-	char *buf = NULL;
-	struct req_iterator rq_iter;
-	struct bio_vec *bvec;
-	int cmd_flag;
-	
-    set_user_nice(current,-20);
-	spin_lock_irq(rq->queue_lock);
-
-	while (!kthread_should_stop()) {
-		int res;
-
-		dev->bg_stop = false;
-		if (!req && !(req = blk_fetch_request(rq))) {
-			if (tr->background && !background_done) {
-				spin_unlock_irq(rq->queue_lock);
-				mutex_lock(&dev->lock);
-				tr->background(dev);
-				mutex_unlock(&dev->lock);
-				spin_lock_irq(rq->queue_lock);
-				/*
-				 * Do background processing just once per idle
-				 * period.
-				 */
-				background_done = !dev->bg_stop;
-				continue;
-			}
-			set_current_state(TASK_INTERRUPTIBLE);
-
-			if (kthread_should_stop())
-				set_current_state(TASK_RUNNING);
-
-			spin_unlock_irq(rq->queue_lock);
-			schedule();
-			spin_lock_irq(rq->queue_lock);
-			continue;
-		}
-    	if ((req->cmd_type != REQ_TYPE_FS) || (blk_rq_pos(req) + blk_rq_sectors(req) > get_capacity(req->rq_disk)))
-    	{
-            __blk_end_request_all(req, -EIO);
-	        req = NULL;
-		    background_done = 0;
-	        continue;
-    	}
-		spin_unlock_irq(rq->queue_lock);
-        mutex_lock(&dev->lock);
-        
-	    block = blk_rq_pos(req);
-	    data_len = 0;
-		buf = 0;
-		res = 0;
-	    cmd_flag = rq_data_dir(req);
-	    //i = 0;
-        if(cmd_flag == READ && mtd_rw_buffer)
-        {
-	        unsigned long nsect;
-            buf = mtd_rw_buffer;
-            req_check_buffer_align(req,&buf);
-            nsect = req->__data_len >> 9;
-            if( nsect > MTD_RW_SECTORS ) {
-                printk("%s..%d::nsect=%d,too large , may be error!\n",__FILE__,__LINE__, nsect );
-                nsect = MTD_RW_SECTORS;
-                while(1);
-            }
-			if(buf == mtd_rw_buffer )
-            	mutex_lock(&mtd_rw_buffer_lock);
-    		if (tr->readsect(dev, block,nsect, buf))
-    		    res = -EIO;
-            if( buf == mtd_rw_buffer ) 
-            {
-                char *p = buf;
-        	    rq_for_each_segment(bvec, req, rq_iter) 
-            	{ 
-                    memcpy( page_address(bvec->bv_page) + bvec->bv_offset , p , bvec->bv_len );
-                    flush_dcache_page(bvec->bv_page); //zyf rq_flush_dcache_pages(req);
-                    p += bvec->bv_len;
-            	}
-            	mutex_unlock(&mtd_rw_buffer_lock);
-            }
-            //rq_flush_dcache_pages(req);
-        }
-        else
-        {    
-        	rq_for_each_segment(bvec, req, rq_iter) 
-        	{
-            	//printk("%d buf = %x, lba = %llx , nsec=%x ,offset = %x\n",i,page_address(bvec->bv_page) + bvec->bv_offset,((rq_iter.bio)->bi_sector),(bvec->bv_len),(bvec->bv_offset));
-                //i++;
-                flush_dcache_page(bvec->bv_page); //zyf rq_flush_dcache_pages(req);
-                if((page_address(bvec->bv_page) + bvec->bv_offset) == (buf + data_len))
-                {
-                    data_len += bvec->bv_len;
-                }
-                else
-                {
-                    if(data_len)
-                    {
-            	        //printk("buf = %x, lba = %lx , nsec=%x \n",buf,block,data_len);
-                    	switch(cmd_flag)
-                    	{
-                    	case READ:
-                			if (tr->readsect(dev, block,data_len>>9, buf))
-                				res = -EIO;
-                    		//rq_flush_dcache_pages(req);
-                    		break;
-                    	case WRITE:
-                    		//if (!tr->writesect)
-                    		//	res = -EIO;
-                    		//rq_flush_dcache_pages(req);
-                			if (tr->writesect(dev, block,data_len>>9, buf))
-                				res = -EIO;
-                    		break;
-                    	default:
-                    		//printk(KERN_NOTICE "Unknown request %u\n", rq_data_dir(req));
-                			res = -EIO;
-                    		break;
-                    	}
-                    }
-     				block += data_len>>9;
-    				buf = (page_address(bvec->bv_page) + bvec->bv_offset);
-    				data_len = bvec->bv_len;
-                }
-        	}
-    
-            if(data_len)
-            {
-            	//printk("buf = %x, lba = %lx , nsec=%x \n",buf,block,data_len);
-            	switch(cmd_flag)
-            	{
-            	case READ:
-        			if (tr->readsect(dev, block,data_len>>9, buf))
-        				res = -EIO;
-            		//rq_flush_dcache_pages(req);
-            		break;
-            	case WRITE:
-            		//if (!tr->writesect)
-            		//	res = -EIO;
-            		//rq_flush_dcache_pages(req);
-        			if (tr->writesect(dev, block,data_len>>9, buf))
-        				res = -EIO;
-            		break;
-            	default:
-            		//printk(KERN_NOTICE "Unknown request %u\n", rq_data_dir(req));
-        			res = -EIO;
-            		break;
-            	}
-            }
-        }
-        mutex_unlock(&dev->lock);
-		spin_lock_irq(rq->queue_lock);
-		//printk("__blk_end_request_all %d\n",res);
-		__blk_end_request_all(req, res);
-		req = NULL;
-		background_done = 0;
-	}
-
-	if (req)
-		__blk_end_request_all(req, -EIO);
-
-	spin_unlock_irq(rq->queue_lock);
-
-	return 0;
-}
-#endif
 static void mtd_blktrans_request(struct request_queue *rq)
 {
 	struct mtd_blktrans_dev *dev;
@@ -648,10 +415,7 @@ int add_mtd_blktrans_dev(struct mtd_blktrans_dev *new)
 		snprintf(gd->disk_name, sizeof(gd->disk_name),
 			 "%s%d", tr->name, new->devnum);
 
-	/* 2.5 has capacity in units of 512 bytes while still
-	   having BLOCK_SIZE_BITS set to 10. Just to keep us amused. */
-	//set_capacity(gd, (new->size * tr->blksize) >> 9);
-	set_capacity(gd, (new->size >> 9) * tr->blksize);   //modify by zyf for cap>=4GB 20110120
+	set_capacity(gd, (new->size * tr->blksize) >> 9);
 
 	/* Create the request queue */
 	spin_lock_init(&new->queue_lock);
@@ -662,12 +426,6 @@ int add_mtd_blktrans_dev(struct mtd_blktrans_dev *new)
 
 	new->rq->queuedata = new;
 	blk_queue_logical_block_size(new->rq, tr->blksize);
-	
-#if (MTD_MERGE == 1)
-    blk_queue_max_hw_sectors(new->rq,MTD_RW_SECTORS);
-	//blk_queue_max_segment_size(new->rq,MTD_RW_SECTORS);
-	blk_queue_max_segments(new->rq, MTD_RW_SECTORS);// /PAGE_CACHE_SIZE
-#endif
 
 	if (tr->discard) {
 		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, new->rq);
@@ -780,10 +538,7 @@ int register_mtd_blktrans(struct mtd_blktrans_ops *tr)
 {
 	struct mtd_info *mtd;
 	int ret;
-#if(MTD_MERGE != 0)
-	mutex_init(&mtd_rw_buffer_lock);
-    mtd_rw_buffer = kmalloc(MTD_RW_SECTORS*512, GFP_KERNEL | GFP_DMA);
-#endif
+
 	/* Register the notifier if/when the first device type is
 	   registered, to prevent the link/init ordering from fucking
 	   us over. */
diff --git a/drivers/mtd/mtdblock.c b/drivers/mtd/mtdblock.c
index a82d868ea7de..3326615ad66b 100644
--- a/drivers/mtd/mtdblock.c
+++ b/drivers/mtd/mtdblock.c
@@ -28,7 +28,6 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/vmalloc.h>
-#include <linux/version.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/blktrans.h>
@@ -140,8 +139,8 @@ static int write_cached_data (struct mtdblk_dev *mtdblk)
 	return 0;
 }
 
-#if 0
-static int do_cached_write (struct mtdblk_dev *mtdblk, loff_t pos,
+
+static int do_cached_write (struct mtdblk_dev *mtdblk, unsigned long pos,
 			    int len, const char *buf)
 {
 	struct mtd_info *mtd = mtdblk->mbd.mtd;
@@ -211,7 +210,7 @@ static int do_cached_write (struct mtdblk_dev *mtdblk, loff_t pos,
 }
 
 
-static int do_cached_read (struct mtdblk_dev *mtdblk, loff_t pos,
+static int do_cached_read (struct mtdblk_dev *mtdblk, unsigned long pos,
 			   int len, char *buf)
 {
 	struct mtd_info *mtd = mtdblk->mbd.mtd;
@@ -258,14 +257,14 @@ static int do_cached_read (struct mtdblk_dev *mtdblk, loff_t pos,
 }
 
 static int mtdblock_readsect(struct mtd_blktrans_dev *dev,
-			      loff_t block,unsigned long nsect, char *buf)
+			      unsigned long block, char *buf)
 {
 	struct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);
-	return do_cached_read(mtdblk, (loff_t)block<<9, 512*nsect, buf);
+	return do_cached_read(mtdblk, block<<9, 512, buf);
 }
 
 static int mtdblock_writesect(struct mtd_blktrans_dev *dev,
-			      unsigned long block,unsigned long nsect, char *buf)
+			      unsigned long block, char *buf)
 {
 	struct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);
 	if (unlikely(!mtdblk->cache_data && mtdblk->cache_size)) {
@@ -277,45 +276,9 @@ static int mtdblock_writesect(struct mtd_blktrans_dev *dev,
 		 * return -EAGAIN sometimes, but why bother?
 		 */
 	}
-	return do_cached_write(mtdblk, (loff_t)block<<9, 512*nsect, buf);
-}
-#else
-static int mtdblock_readsect(struct mtd_blktrans_dev *dev,
-			      unsigned long block,unsigned long nsect, char *buf)
-{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
-	struct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);
-	struct mtd_info *mtd = mtdblk->mbd.mtd;
-#else
-	struct mtdblk_dev *mtdblk = mtdblks[dev->devnum];
-	struct mtd_info *mtd = mtdblk->mtd;
-#endif
-	size_t retlen,len;
-	loff_t pos = (loff_t)block*512;
-    len = 512*nsect;
-
-	DEBUG(MTD_DEBUG_LEVEL2, "mtdblock: read on \"%s\" at 0x%llx, size 0x%x\n",mtd->name, pos, len);
-	return mtd->read(mtd, pos, len, &retlen, buf);
+	return do_cached_write(mtdblk, block<<9, 512, buf);
 }
 
-static int mtdblock_writesect(struct mtd_blktrans_dev *dev,
-			      unsigned long block,unsigned long nsect, char *buf)
-{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
-	struct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);
-	struct mtd_info *mtd = mtdblk->mbd.mtd;
-#else
-	struct mtdblk_dev *mtdblk = mtdblks[dev->devnum];
-	struct mtd_info *mtd = mtdblk->mtd;
-#endif
-	size_t retlen,len;
-	loff_t pos = (loff_t)block*512;
-    len = 512*nsect;
-    
-	DEBUG(MTD_DEBUG_LEVEL2, "mtdblock: write on \"%s\" at 0x%llx, size 0x%x\n",mtd->name, pos, len);
-    return mtd->write(mtd, pos, len, &retlen, buf);
-}
-#endif
 static int mtdblock_open(struct mtd_blktrans_dev *mbd)
 {
 	struct mtdblk_dev *mtdblk = container_of(mbd, struct mtdblk_dev, mbd);
diff --git a/drivers/mtd/mtdblock_ro.c b/drivers/mtd/mtdblock_ro.c
index 1b32431af8f8..795a8c0a05b8 100644
--- a/drivers/mtd/mtdblock_ro.c
+++ b/drivers/mtd/mtdblock_ro.c
@@ -25,21 +25,21 @@
 #include <linux/mtd/blktrans.h>
 
 static int mtdblock_readsect(struct mtd_blktrans_dev *dev,
-			      unsigned long block, unsigned long nsect, char *buf)
+			      unsigned long block, char *buf)
 {
 	size_t retlen;
 
-	if (dev->mtd->read(dev->mtd, (block * 512), 512*nsect, &retlen, buf))
+	if (dev->mtd->read(dev->mtd, (block * 512), 512, &retlen, buf))
 		return 1;
 	return 0;
 }
 
 static int mtdblock_writesect(struct mtd_blktrans_dev *dev,
-			      unsigned long block, unsigned long nsect, char *buf)
+			      unsigned long block, char *buf)
 {
 	size_t retlen;
 
-	if (dev->mtd->write(dev->mtd, (block * 512), 512*nsect, &retlen, buf))
+	if (dev->mtd->write(dev->mtd, (block * 512), 512, &retlen, buf))
 		return 1;
 	return 0;
 }
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index b0ff680b0b2e..43173a335e49 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -416,12 +416,6 @@ config MTD_NAND_ATMEL_ECC_NONE
 
 endchoice
 
-config MTD_NAND_RK29
-        tristate "NAND Flash support for RK29sdk"
-        depends on ARCH_RK29
-        help
-          This enables the NAND flash controller on the RK29 SoC
-          
 config MTD_NAND_PXA3xx
 	tristate "Support for NAND flash devices on PXA3xx"
 	depends on PXA3xx || ARCH_MMP
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 8756e654f7bb..5745d831168e 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -45,7 +45,6 @@ obj-$(CONFIG_MTD_NAND_SOCRATES)		+= socrates_nand.o
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
 obj-$(CONFIG_MTD_NAND_NUC900)		+= nuc900_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
-obj-$(CONFIG_MTD_NAND_RK29)		+= rk29_nand.o
 obj-$(CONFIG_MTD_NAND_BCM_UMI)		+= bcm_umi_nand.o nand_bcm_umi.o
 obj-$(CONFIG_MTD_NAND_MPC5121_NFC)	+= mpc5121_nfc.o
 obj-$(CONFIG_MTD_NAND_RICOH)		+= r852.o
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 24bb84534440..15d71658b4f1 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -1492,15 +1492,8 @@ static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
 			else
 				ret = chip->ecc.read_page(mtd, chip, bufpoi,
 							  page);
-#ifdef CONFIG_MTD_NAND_RK29
-            extern int rk29_nand_refresh(struct mtd_info *mtd, int srcAddr);
-		    if(ret == -1)
-		        ret=rk29_nand_refresh(mtd, page<<chip->page_shift);
-#endif              
 			if (ret < 0)
-			{
 				break;
-			}
 
 			/* Transfer not aligned data */
 			if (!aligned) {
@@ -3087,8 +3080,6 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 			break;
 	}
 
-	chip->options |= busw;
-	
 	/*
 	 * Check, if buswidth is correct. Hardware drivers should set
 	 * chip correct !
diff --git a/drivers/mtd/nand/nand_bbt.c b/drivers/mtd/nand/nand_bbt.c
index ed369b102348..c27ca6affa97 100644
--- a/drivers/mtd/nand/nand_bbt.c
+++ b/drivers/mtd/nand/nand_bbt.c
@@ -1210,10 +1210,6 @@ int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
 	if (md)
 		mark_bbt_region(mtd, md);
 
-#ifdef CONFIG_MTD_NAND_RK29
-    extern void mark_reserve_region(struct mtd_info *mtd,struct nand_bbt_descr *td,struct nand_bbt_descr *md);
-    mark_reserve_region(mtd, td, md);
-#endif    
 	vfree(buf);
 	return res;
 }
@@ -1297,8 +1293,8 @@ static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
 
 static struct nand_bbt_descr bbt_main_descr = {
 	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-		| NAND_BBT_2BIT /*| NAND_BBT_VERSION */| NAND_BBT_PERCHIP,
-	.offs =0,  //8,  // meet to rk2818 nandc spare
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	8,
 	.len = 4,
 	.veroffs = 12,
 	.maxblocks = 4,
@@ -1307,8 +1303,8 @@ static struct nand_bbt_descr bbt_main_descr = {
 
 static struct nand_bbt_descr bbt_mirror_descr = {
 	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-		| NAND_BBT_2BIT /*| NAND_BBT_VERSION */| NAND_BBT_PERCHIP,
-	.offs =0,   //8,  // meet to rk2818 nandc spare
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	8,
 	.len = 4,
 	.veroffs = 12,
 	.maxblocks = 4,
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index f17b3b0c1c28..5a92c48ffe59 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -251,17 +251,6 @@ config AX88796_93CX6
 	help
 	  Select this if your platform comes with an external 93CX6 eeprom.
 
-config RK29_VMAC
-	tristate "RK29 VMAC ethernet support"
-	depends on HAS_DMA
-	select MII
-	select PHYLIB
-	select CRC32
-	help
-	  MAC device present on rockchip rk29xx 
-
-source "drivers/net/eth_mac/Kconfig"
-
 config MACE
 	tristate "MACE (Power Mac ethernet) support"
 	depends on PPC_PMAC && PPC32
@@ -1004,17 +993,6 @@ config DM9000_DEBUGLEVEL
 	  The maximum level of debugging code compiled into the DM9000
 	  driver.
 
-if DM9000
-choice
-  prompt "choose control"
-	config DM9000_USE_NAND_CONTROL
-		tristate "DM9000 with NANDC Interface"
-
-	config DM9000_USE_NOR_CONTROL
-		tristate  "DM9000 with NOR Interface"
-endchoice
-endif
-	  
 config DM9000_FORCE_SIMPLE_PHY_POLL
 	bool "Force simple NSR based PHY polling"
 	depends on DM9000
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 61fd9d2567ae..366624f7ab43 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -139,7 +139,6 @@ obj-$(CONFIG_ULTRA) += smc-ultra.o 8390.o
 obj-$(CONFIG_ULTRAMCA) += smc-mca.o 8390.o
 obj-$(CONFIG_ULTRA32) += smc-ultra32.o 8390.o
 obj-$(CONFIG_E2100) += e2100.o 8390.o
-obj-$(CONFIG_RK29_VMAC) += rk29_vmac.o
 obj-$(CONFIG_ES3210) += es3210.o 8390.o
 obj-$(CONFIG_LNE390) += lne390.o 8390.o
 obj-$(CONFIG_NE3210) += ne3210.o 8390.o
@@ -310,5 +309,3 @@ obj-$(CONFIG_CAIF) += caif/
 obj-$(CONFIG_OCTEON_MGMT_ETHERNET) += octeon/
 obj-$(CONFIG_PCH_GBE) += pch_gbe/
 obj-$(CONFIG_TILE_NET) += tile/
-
-obj-$(CONFIG_RK29_VMAC) += eth_mac/
diff --git a/drivers/net/dm9000.c b/drivers/net/dm9000.c
index 7d82334e4941..ee597e676ee5 100644
--- a/drivers/net/dm9000.c
+++ b/drivers/net/dm9000.c
@@ -38,7 +38,6 @@
 #include <asm/delay.h>
 #include <asm/irq.h>
 #include <asm/io.h>
-#include <mach/gpio.h>
 
 #include "dm9000.h"
 
@@ -136,6 +135,7 @@ typedef struct board_info {
 } board_info_t;
 
 /* debug code */
+
 #define dm9000_dbg(db, lev, msg...) do {		\
 	if ((lev) < CONFIG_DM9000_DEBUGLEVEL &&		\
 	    (lev) < db->debug_level) {			\
@@ -310,7 +310,7 @@ dm9000_read_locked(board_info_t *db, int reg)
 	unsigned long flags;
 	unsigned int ret;
 
-	spin_lock_irqsave(&db->lock, flags);	
+	spin_lock_irqsave(&db->lock, flags);
 	ret = ior(db, reg);
 	spin_unlock_irqrestore(&db->lock, flags);
 
@@ -365,9 +365,9 @@ dm9000_read_eeprom(board_info_t *db, int offset, u8 *to)
 	}
 
 	mutex_lock(&db->addr_lock);
-	
+
 	spin_lock_irqsave(&db->lock, flags);
-		
+
 	iow(db, DM9000_EPAR, offset);
 	iow(db, DM9000_EPCR, EPCR_ERPRR);
 
@@ -377,9 +377,9 @@ dm9000_read_eeprom(board_info_t *db, int offset, u8 *to)
 
 	/* delay for at-least 150uS */
 	msleep(1);
-	
+
 	spin_lock_irqsave(&db->lock, flags);
-	
+
 	iow(db, DM9000_EPCR, 0x0);
 
 	to[0] = ior(db, DM9000_EPDRL);
@@ -402,8 +402,8 @@ dm9000_write_eeprom(board_info_t *db, int offset, u8 *data)
 		return;
 
 	mutex_lock(&db->addr_lock);
-	
-	spin_lock_irqsave(&db->lock, flags);	
+
+	spin_lock_irqsave(&db->lock, flags);
 	iow(db, DM9000_EPAR, offset);
 	iow(db, DM9000_EPDRH, data[1]);
 	iow(db, DM9000_EPDRL, data[0]);
@@ -413,7 +413,7 @@ dm9000_write_eeprom(board_info_t *db, int offset, u8 *data)
 	dm9000_wait_eeprom(db);
 
 	mdelay(1);	/* wait at least 150uS to clear */
-	
+
 	spin_lock_irqsave(&db->lock, flags);
 	iow(db, DM9000_EPCR, 0);
 	spin_unlock_irqrestore(&db->lock, flags);
@@ -872,7 +872,7 @@ dm9000_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		return NETDEV_TX_BUSY;
 
 	spin_lock_irqsave(&db->lock, flags);
-	
+
 	/* Move data to DM9000 TX RAM */
 	writeb(DM9000_MWCMD, db->io_addr);
 
@@ -891,7 +891,7 @@ dm9000_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	}
 
 	spin_unlock_irqrestore(&db->lock, flags);
-	
+
 	/* free this SKB */
 	dev_kfree_skb(skb);
 
@@ -946,30 +946,20 @@ dm9000_rx(struct net_device *dev)
 	do {
 		ior(db, DM9000_MRCMDX);	/* Dummy read */
 
-		udelay(1);//add by lyx@20100713,or dm9000_rx will be error in high frequence
-
-		#if 1
-		/* Get most updated data */		
-		rxbyte = ior(db, DM9000_MRCMDX);	/* Dummy read */
-		#else
+		/* Get most updated data */
 		rxbyte = readb(db->io_data);
-		#endif
-		
+
 		/* Status check: this byte must be 0 or 1 */
 		if (rxbyte & DM9000_PKT_ERR) {
 			dev_warn(db->dev, "status check fail: %d\n", rxbyte);
-			#if 0
 			iow(db, DM9000_RCR, 0x00);	/* Stop Device */
 			iow(db, DM9000_ISR, IMR_PAR);	/* Stop INT request */
-			#else
-			dm9000_reset(db);
-			#endif			
 			return;
 		}
 
 		if (!(rxbyte & DM9000_PKT_RDY))
 			return;
-		
+
 		/* A packet ready now  & Get status/length */
 		GoodPacket = true;
 		writeb(DM9000_MRCMD, db->io_addr);
@@ -1057,7 +1047,7 @@ static irqreturn_t dm9000_interrupt(int irq, void *dev_id)
 
 	/* A real interrupt coming */
 
-	/* holders of db->lock must always block IRQs */	
+	/* holders of db->lock must always block IRQs */
 	spin_lock_irqsave(&db->lock, flags);
 
 	/* Save previous register address */
@@ -1095,7 +1085,7 @@ static irqreturn_t dm9000_interrupt(int irq, void *dev_id)
 	writeb(reg_save, db->io_addr);
 
 	spin_unlock_irqrestore(&db->lock, flags);
-	
+
 	return IRQ_HANDLED;
 }
 
@@ -1165,7 +1155,7 @@ dm9000_open(struct net_device *dev)
 	if (irqflags == IRQF_TRIGGER_NONE)
 		dev_warn(db->dev, "WARNING: no IRQ resource flags set.\n");
 
-	//irqflags |= IRQF_SHARED;
+	irqflags |= IRQF_SHARED;
 
 	/* GPIO0 on pre-activate PHY, Reg 1F is not set by reset */
 	iow(db, DM9000_GPR, 0);	/* REG_1F bit0 activate phyxcer */
@@ -1215,7 +1205,7 @@ dm9000_phy_read(struct net_device *dev, int phy_reg_unused, int reg)
 	mutex_lock(&db->addr_lock);
 
 	spin_lock_irqsave(&db->lock,flags);
-	
+
 	/* Save previous register address */
 	reg_save = readb(db->io_addr);
 
@@ -1262,7 +1252,7 @@ dm9000_phy_write(struct net_device *dev,
 	mutex_lock(&db->addr_lock);
 
 	spin_lock_irqsave(&db->lock,flags);
-	
+
 	/* Save previous register address */
 	reg_save = readb(db->io_addr);
 
@@ -1280,7 +1270,7 @@ dm9000_phy_write(struct net_device *dev,
 
 	dm9000_msleep(db, 1);		/* Wait write complete */
 
-	spin_lock_irqsave(&db->lock,flags);	
+	spin_lock_irqsave(&db->lock,flags);
 	reg_save = readb(db->io_addr);
 
 	iow(db, DM9000_EPCR, 0x0);	/* Clear phyxcer write command */
@@ -1454,29 +1444,8 @@ dm9000_probe(struct platform_device *pdev)
 
 	/* fill in parameters for net-dev structure */
 	ndev->base_addr = (unsigned long)db->io_addr;
+	ndev->irq	= db->irq_res->start;
 
-	//io init for dm9000 , modify by lyx@20100809
-	if (pdata && pdata->io_init) {
-		if (pdata->io_init()) {
-			ret = -EINVAL;
-			goto out;
-		}
-	}
-
-	if (gpio_request(pdata->irq_pin, "dm9000 interrupt")) {
-		gpio_free(pdata->irq_pin);
-		if (pdata->io_deinit)
-			pdata->io_deinit();
-		printk("[fun:%s line:%d], request gpio for net interrupt fail\n", __func__,__LINE__);
-		ret = -EINVAL;
-		goto out;
-	}	
-	gpio_pull_updown(pdata->irq_pin, pdata->irq_pin_value);
-	gpio_direction_input(pdata->irq_pin);
-
-	ndev->irq = gpio_to_irq(pdata->irq_pin);
-	//ndev->irq = db->irq_res->start;
-	
 	/* ensure at least we have a default set of IO routines */
 	dm9000_set_io(db, iosize);
 
@@ -1610,9 +1579,6 @@ dm9000_probe(struct platform_device *pdev)
 		       ndev->name, dm9000_type_to_char(db->type),
 		       db->io_addr, db->io_data, ndev->irq,
 		       ndev->dev_addr, mac_src);
-
-	dm9000_shutdown(ndev);//add by lyx@20100713, reduce power consume
-
 	return 0;
 
 out:
@@ -1680,12 +1646,6 @@ static int __devexit
 dm9000_drv_remove(struct platform_device *pdev)
 {
 	struct net_device *ndev = platform_get_drvdata(pdev);
-	struct dm9000_plat_data *pdata = pdev->dev.platform_data;
-
-	//deinit io for dm9000
-	gpio_free(pdata->irq_pin);
-	if (pdata && pdata->io_deinit)
-		pdata->io_deinit();
 
 	platform_set_drvdata(pdev, NULL);
 
diff --git a/drivers/net/enc28j60.c b/drivers/net/enc28j60.c
index cbeed3282363..2837ce209cd7 100644
--- a/drivers/net/enc28j60.c
+++ b/drivers/net/enc28j60.c
@@ -28,11 +28,9 @@
 #include <linux/skbuff.h>
 #include <linux/delay.h>
 #include <linux/spi/spi.h>
-#include <mach/gpio.h>
 
 #include "enc28j60_hw.h"
 
-#define MAC_INT_PORT	RK2818_PIN_PE2
 #define DRV_NAME	"enc28j60"
 #define DRV_VERSION	"1.01"
 
@@ -1548,10 +1546,7 @@ static int __devinit enc28j60_probe(struct spi_device *spi)
 	struct net_device *dev;
 	struct enc28j60_net *priv;
 	int ret = 0;
-	unsigned long req_flags = IRQF_TRIGGER_FALLING;
-	int gpioToIrq = gpio_to_irq (MAC_INT_PORT);
-	
-	gpio_request(MAC_INT_PORT, "DRV_NAME");
+
 	if (netif_msg_drv(&debug))
 		dev_info(&spi->dev, DRV_NAME " Ethernet driver %s loaded\n",
 			DRV_VERSION);
@@ -1590,13 +1585,7 @@ static int __devinit enc28j60_probe(struct spi_device *spi)
 	/* Board setup must set the relevant edge trigger type;
 	 * level triggers won't currently work.
 	 */
-	gpio_pull_updown(MAC_INT_PORT, GPIOPullUp);	
-	if(gpioToIrq != -1)
-		ret = request_irq(gpioToIrq, enc28j60_irq,req_flags, "DRV_NAME", priv);
-	else
-		ret = -1;
-		
-	///ret = request_irq(spi->irq, enc28j60_irq, 0, DRV_NAME, priv);
+	ret = request_irq(spi->irq, enc28j60_irq, 0, DRV_NAME, priv);
 	if (ret < 0) {
 		if (netif_msg_probe(priv))
 			dev_err(&spi->dev, DRV_NAME ": request irq %d failed "
diff --git a/drivers/net/irda/Kconfig b/drivers/net/irda/Kconfig
index eedfaa7ad535..25bb2a015e18 100644
--- a/drivers/net/irda/Kconfig
+++ b/drivers/net/irda/Kconfig
@@ -397,29 +397,6 @@ config MCS_FIR
 	  To compile it as a module, choose M here: the module will be called
 	  mcs7780.
 
-config RK_IRDA
-	tristate "rockchip rk29 IrDA"
-	depends on IRDA && RK29_SMC
-	help
-	  Say Y or M here if you want to build support for the rk29
-	  built-in IRDA interface which can support both SIR, MIR and FIR.
-
-choice
-	depends on RK_IRDA
-	prompt "irda device driver"
-config RK_IRDA_UART
-	bool "uses irda as a serial device"
-config RK_IRDA_NET
-	bool "uses irda as a network device"
-endchoice
-
-choice
-	depends on RK_IRDA
-	prompt "irda module select"
-config BU92725GUW
-	bool "bu92725guw"
-endchoice
-
 config SH_IRDA
 	tristate "SuperH IrDA driver"
 	depends on IRDA && ARCH_SHMOBILE
diff --git a/drivers/net/irda/Makefile b/drivers/net/irda/Makefile
index b7e48ca8bfe1..dfc64537f62f 100644
--- a/drivers/net/irda/Makefile
+++ b/drivers/net/irda/Makefile
@@ -39,9 +39,6 @@ obj-$(CONFIG_EP7211_DONGLE)	+= ep7211-sir.o
 obj-$(CONFIG_KINGSUN_DONGLE)	+= kingsun-sir.o
 obj-$(CONFIG_KSDAZZLE_DONGLE)	+= ksdazzle-sir.o
 obj-$(CONFIG_KS959_DONGLE)    	+= ks959-sir.o
-obj-$(CONFIG_RK_IRDA_UART)           += ir_serial.o
-obj-$(CONFIG_RK_IRDA_NET)           += rk29_ir.o
-obj-$(CONFIG_BU92725GUW)        += bu92725guw.o
 
 # The SIR helper module
 sir-dev-objs := sir_dev.o sir_dongle.o
diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig
index ca34300ae3a2..84d4608153c9 100644
--- a/drivers/net/usb/Kconfig
+++ b/drivers/net/usb/Kconfig
@@ -223,24 +223,6 @@ config USB_NET_DM9601
 	  This option adds support for Davicom DM9601 based USB 1.1
 	  10/100 Ethernet adapters.
 
-config USB_NET_DM9620
-	tristate "Davicom DM9620 based USB 1.1 10/100 ethernet devices"
-	depends on USB_USBNET
-	select CRC32
-	default y
-	help
-	  This option adds support for Davicom DM9620 based USB 1.1
-	  10/100 Ethernet adapters.
-
-config USB_NET_SR9700
-	tristate "WilLing Electrnic SR9700 based USB 2.0"
-	depends on USB_USBNET
-	select CRC32
-	default y
-	help
-	  This option adds support for Davicom SR9700 based USB 2.0
-	  10/100 Ethernet adapters.
-
 config USB_NET_SMSC75XX
 	tristate "SMSC LAN75XX based USB 2.0 gigabit ethernet devices"
 	depends on USB_USBNET
diff --git a/drivers/net/usb/Makefile b/drivers/net/usb/Makefile
index a6850ad884c7..c203fa21f6b1 100644
--- a/drivers/net/usb/Makefile
+++ b/drivers/net/usb/Makefile
@@ -11,8 +11,6 @@ obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
 obj-$(CONFIG_USB_NET_CDCETHER)	+= cdc_ether.o
 obj-$(CONFIG_USB_NET_CDC_EEM)	+= cdc_eem.o
 obj-$(CONFIG_USB_NET_DM9601)	+= dm9601.o
-obj-$(CONFIG_USB_NET_DM9620)	+= dm9620.o
-obj-$(CONFIG_USB_NET_SR9700)	+= sr9700.o
 obj-$(CONFIG_USB_NET_SMSC75XX)	+= smsc75xx.o
 obj-$(CONFIG_USB_NET_SMSC95XX)	+= smsc95xx.o
 obj-$(CONFIG_USB_NET_GL620A)	+= gl620a.o
diff --git a/drivers/net/usb/asix.h b/drivers/net/usb/asix.h
deleted file mode 100755
index eb86d24e7266..000000000000
--- a/drivers/net/usb/asix.h
+++ /dev/null
@@ -1,550 +0,0 @@
-#ifndef	__LINUX_USBNET_ASIX_H
-#define	__LINUX_USBNET_ASIX_H
-
-/*
- * Turn on this flag if the implementation of your USB host controller
- * cannot handle non-double word aligned buffer.
- * When turn on this flag, driver will fixup egress packet aligned on double
- * word boundary before deliver to USB host controller. And will Disable the
- * function "skb_reserve (skb, NET_IP_ALIGN)" to retain the buffer aligned on
- * double word alignment for ingress packets.
- */
-#define AX_FORCE_BUFF_ALIGN		1
-
-#define AX_MONITOR_MODE			0x01
-#define AX_MONITOR_LINK			0x02
-#define AX_MONITOR_MAGIC		0x04
-#define AX_MONITOR_HSFS			0x10
-
-/* AX88172 Medium Status Register values */
-#define AX_MEDIUM_FULL_DUPLEX		0x02
-#define AX_MEDIUM_TX_ABORT_ALLOW	0x04
-#define AX_MEDIUM_FLOW_CONTROL_EN	0x10
-#define AX_MCAST_FILTER_SIZE		8
-#define AX_MAX_MCAST			64
-
-#define AX_EEPROM_LEN			0x40
-
-#define AX_SWRESET_CLEAR		0x00
-#define AX_SWRESET_RR			0x01
-#define AX_SWRESET_RT			0x02
-#define AX_SWRESET_PRTE			0x04
-#define AX_SWRESET_PRL			0x08
-#define AX_SWRESET_BZ			0x10
-#define AX_SWRESET_IPRL			0x20
-#define AX_SWRESET_IPPD			0x40
-#define AX_SWRESET_IPOSC		0x0080
-#define AX_SWRESET_IPPSL_0		0x0100
-#define AX_SWRESET_IPPSL_1		0x0200
-#define AX_SWRESET_IPCOPS		0x0400
-#define AX_SWRESET_IPCOPSC		0x0800
-#define AX_SWRESET_AUTODETACH		0x1000
-#define AX_SWRESET_WOLLP		0x8000
-
-#define AX88772_IPG0_DEFAULT		0x15
-#define AX88772_IPG1_DEFAULT		0x0c
-#define AX88772_IPG2_DEFAULT		0x0E
-
-#define AX88772A_IPG0_DEFAULT		0x15
-#define AX88772A_IPG1_DEFAULT		0x16
-#define AX88772A_IPG2_DEFAULT		0x1A
-
-#define AX88772_MEDIUM_FULL_DUPLEX	0x0002
-#define AX88772_MEDIUM_RESERVED		0x0004
-#define AX88772_MEDIUM_RX_FC_ENABLE	0x0010
-#define AX88772_MEDIUM_TX_FC_ENABLE	0x0020
-#define AX88772_MEDIUM_PAUSE_FORMAT	0x0080
-#define AX88772_MEDIUM_RX_ENABLE	0x0100
-#define AX88772_MEDIUM_100MB		0x0200
-#define AX88772_MEDIUM_DEFAULT	\
-	(AX88772_MEDIUM_FULL_DUPLEX | AX88772_MEDIUM_RX_FC_ENABLE | \
-	 AX88772_MEDIUM_TX_FC_ENABLE | AX88772_MEDIUM_100MB | \
-	 AX88772_MEDIUM_RESERVED | AX88772_MEDIUM_RX_ENABLE )
-
-#define AX_CMD_SET_SW_MII		0x06
-#define AX_CMD_READ_MII_REG		0x07
-#define AX_CMD_WRITE_MII_REG		0x08
-#define AX_CMD_SET_HW_MII		0x0a
-#define AX_CMD_READ_EEPROM		0x0b
-#define AX_CMD_WRITE_EEPROM		0x0c
-#define AX_CMD_WRITE_EEPROM_EN		0x0d
-#define AX_CMD_WRITE_EEPROM_DIS		0x0e
-#define AX_CMD_WRITE_RX_CTL		0x10
-#define AX_CMD_READ_IPG012		0x11
-#define AX_CMD_WRITE_IPG0		0x12
-#define AX_CMD_WRITE_IPG1		0x13
-#define AX_CMD_WRITE_IPG2		0x14
-#define AX_CMD_WRITE_MULTI_FILTER	0x16
-#define AX_CMD_READ_NODE_ID		0x17
-#define AX_CMD_READ_PHY_ID		0x19
-#define AX_CMD_READ_MEDIUM_MODE		0x1a
-#define AX_CMD_WRITE_MEDIUM_MODE	0x1b
-#define AX_CMD_READ_MONITOR_MODE	0x1c
-#define AX_CMD_WRITE_MONITOR_MODE	0x1d
-#define AX_CMD_WRITE_GPIOS		0x1f
-#define AX_CMD_SW_RESET 		0x20
-#define AX_CMD_SW_PHY_STATUS		0x21
-#define AX_CMD_SW_PHY_SELECT		0x22
-	#define AX_PHYSEL_PSEL		(1 << 0)
-	#define AX_PHYSEL_ASEL		(1 << 1)
-	#define AX_PHYSEL_SSMII		(1 << 2)
-	#define AX_PHYSEL_SSRMII	(2 << 2)
-	#define AX_PHYSEL_SSRRMII	(3 << 2)
-	#define AX_PHYSEL_SSEN		(1 << 4)
-#define AX88772_CMD_READ_NODE_ID	0x13
-#define AX88772_CMD_WRITE_NODE_ID	0x14
-#define AX_CMD_READ_RXCOE_CTL		0x2b
-#define AX_CMD_WRITE_RXCOE_CTL		0x2c
-#define AX_CMD_READ_TXCOE_CTL		0x2d
-#define AX_CMD_WRITE_TXCOE_CTL		0x2e
-
-#define REG_LENGTH			2
-#define PHY_ID_MASK			0x1f
-
-#define AX_RXCOE_IPCE			0x0001
-#define AX_RXCOE_IPVE			0x0002
-#define AX_RXCOE_V6VE			0x0004
-#define AX_RXCOE_TCPE			0x0008
-#define AX_RXCOE_UDPE			0x0010
-#define AX_RXCOE_ICMP			0x0020
-#define AX_RXCOE_IGMP			0x0040
-#define AX_RXCOE_ICV6			0x0080
-#define AX_RXCOE_TCPV6			0x0100
-#define AX_RXCOE_UDPV6			0x0200
-#define AX_RXCOE_ICMV6			0x0400
-#define AX_RXCOE_IGMV6			0x0800
-#define AX_RXCOE_ICV6V6			0x1000
-#define AX_RXCOE_FOPC			0x8000
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
-#define AX_RXCOE_DEF_CSUM		(AX_RXCOE_IPCE | AX_RXCOE_IPVE | \
-					 AX_RXCOE_V6VE | AX_RXCOE_TCPE | \
-					 AX_RXCOE_UDPE |  AX_RXCOE_ICV6 | \
-					 AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6)
-#else
-#define AX_RXCOE_DEF_CSUM		(AX_RXCOE_IPCE | AX_RXCOE_IPVE | \
-					 AX_RXCOE_TCPE | AX_RXCOE_UDPE)
-#endif
-
-#define AX_RXCOE_64TE			0x0100
-#define AX_RXCOE_PPPOE			0x0200
-#define AX_RXCOE_RPCE			0x8000
-
-#define AX_TXCOE_IP			0x0001
-#define AX_TXCOE_TCP			0x0002
-#define AX_TXCOE_UDP			0x0004
-#define AX_TXCOE_ICMP			0x0008
-#define AX_TXCOE_IGMP			0x0010
-#define AX_TXCOE_ICV6			0x0020
-
-#define AX_TXCOE_TCPV6			0x0100
-#define AX_TXCOE_UDPV6			0x0200
-#define AX_TXCOE_ICMV6			0x0400
-#define AX_TXCOE_IGMV6			0x0800
-#define AX_TXCOE_ICV6V6			0x1000
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
-#define AX_TXCOE_DEF_CSUM		(AX_TXCOE_TCP | AX_TXCOE_UDP | \
-					 AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6)
-#else
-#define AX_TXCOE_DEF_CSUM		(AX_TXCOE_TCP | AX_TXCOE_UDP)
-#endif
-
-#define AX_TXCOE_64TE			0x0001
-#define AX_TXCOE_PPPE			0x0002
-
-#define AX88772B_MAX_BULKIN_2K		0
-#define AX88772B_MAX_BULKIN_4K		1
-#define AX88772B_MAX_BULKIN_6K		2
-#define AX88772B_MAX_BULKIN_8K		3
-#define AX88772B_MAX_BULKIN_16K		4
-#define AX88772B_MAX_BULKIN_20K		5
-#define AX88772B_MAX_BULKIN_24K		6
-#define AX88772B_MAX_BULKIN_32K		7
-struct {unsigned short size, byte_cnt,threshold;} AX88772B_BULKIN_SIZE[] =
-{
-	/* 2k */
-	{2048, 0x8000, 0x8001},
-	/* 4k */
-	{4096, 0x8100, 0x8147},
-	/* 6k */
-	{6144, 0x8200, 0x81EB},
-	/* 8k */
-	{8192, 0x8300, 0x83D7},
-	/* 16 */
-	{16384, 0x8400, 0x851E},
-	/* 20k */
-	{20480, 0x8500, 0x8666},
-	/* 24k */
-	{24576, 0x8600, 0x87AE},
-	/* 32k */
-	{32768, 0x8700, 0x8A3D},
-};
-
-
-#define AX_RX_CTL_RH1M			0x0100		/* Enable RX-Header mode 0 */
-#define AX_RX_CTL_RH2M			0x0200		/* Enable IP header in receive buffer aligned on 32-bit aligment */
-#define AX_RX_CTL_RH3M			0x0400		/* checksum value in rx header 3 */
-#define AX_RX_HEADER_DEFAULT		(AX_RX_CTL_RH1M | AX_RX_CTL_RH2M)
-
-#define AX_RX_CTL_MFB			0x0300		/* Maximum Frame size 16384bytes */
-#define AX_RX_CTL_START			0x0080		/* Ethernet MAC start */
-#define AX_RX_CTL_AP			0x0020		/* Accept physcial address from Multicast array */
-#define AX_RX_CTL_AM			0x0010	
-#define AX_RX_CTL_AB			0x0008		/* Accetp Brocadcast frames*/
-#define AX_RX_CTL_SEP			0x0004		/* Save error packets */	
-#define AX_RX_CTL_AMALL			0x0002		/* Accetp all multicast frames */
-#define AX_RX_CTL_PRO			0x0001		/* Promiscuous Mode */
-#define AX_RX_CTL_STOP			0x0000		/* Stop MAC */
-
-#define AX_MONITOR_MODE 		0x01
-#define AX_MONITOR_LINK 		0x02
-#define AX_MONITOR_MAGIC		0x04
-#define AX_MONITOR_HSFS 		0x10
-
-#define AX_MCAST_FILTER_SIZE		8
-#define AX_MAX_MCAST			64
-#define AX_INTERRUPT_BUFSIZE		8
-
-#define AX_EEPROM_LEN			0x40
-#define AX_EEPROM_MAGIC 		0xdeadbeef
-#define EEPROMMASK			0x7f
-
-/* GPIO REGISTER */
-#define AXGPIOS_GPO0EN			0X01 // 1 << 0
-#define AXGPIOS_GPO0			0X02 // 1 << 1
-#define AXGPIOS_GPO1EN			0X04 // 1 << 2
-#define AXGPIOS_GPO1			0X08 // 1 << 3
-#define AXGPIOS_GPO2EN			0X10 // 1 << 4
-#define AXGPIOS_GPO2			0X20 // 1 << 5
-#define AXGPIOS_RSE			0X80 // 1 << 7
-
-/* TX-header format */
-#define AX_TX_HDR_CPHI			0x4000
-#define AX_TX_HDR_DICF			0x8000
-
-// GMII register definitions
-#define GMII_PHY_CONTROL		0x00	// control reg
-#define GMII_PHY_STATUS			0x01	// status reg
-#define GMII_PHY_OUI			0x02	// most of the OUI bits
-#define GMII_PHY_MODEL			0x03	// model/rev bits, and rest of OUI
-#define GMII_PHY_ANAR			0x04	// AN advertisement reg
-#define GMII_PHY_ANLPAR			0x05	// AN Link Partner
-#define GMII_PHY_ANER			0x06	// AN expansion reg
-#define GMII_PHY_1000BT_CONTROL		0x09	// control reg for 1000BT
-#define GMII_PHY_1000BT_STATUS		0x0A	// status reg for 1000BT
-
-// Bit definitions: GMII Control
-#define GMII_CONTROL_RESET		0x8000	// reset bit in control reg
-#define GMII_CONTROL_LOOPBACK		0x4000	// loopback bit in control reg
-#define GMII_CONTROL_10MB		0x0000	// 10 Mbit
-#define GMII_CONTROL_100MB		0x2000	// 100Mbit
-#define GMII_CONTROL_1000MB		0x0040	// 1000Mbit
-#define GMII_CONTROL_SPEED_BITS		0x2040	// speed bit mask
-#define GMII_CONTROL_ENABLE_AUTO	0x1000	// autonegotiate enable
-#define GMII_CONTROL_POWER_DOWN		0x0800
-#define GMII_CONTROL_ISOLATE		0x0400	// islolate bit
-#define GMII_CONTROL_START_AUTO		0x0200	// restart autonegotiate
-#define GMII_CONTROL_FULL_DUPLEX	0x0100
-
-// Bit definitions: GMII Status
-#define GMII_STATUS_100MB_MASK		0xE000	// any of these indicate 100 Mbit
-#define GMII_STATUS_10MB_MASK		0x1800	// either of these indicate 10 Mbit
-#define GMII_STATUS_AUTO_DONE		0x0020	// auto negotiation complete
-#define GMII_STATUS_AUTO		0x0008	// auto negotiation is available
-#define GMII_STATUS_LINK_UP		0x0004	// link status bit
-#define GMII_STATUS_EXTENDED		0x0001	// extended regs exist
-#define GMII_STATUS_100T4		0x8000	// capable of 100BT4
-#define GMII_STATUS_100TXFD		0x4000	// capable of 100BTX full duplex
-#define GMII_STATUS_100TX		0x2000	// capable of 100BTX
-#define GMII_STATUS_10TFD		0x1000	// capable of 10BT full duplex
-#define GMII_STATUS_10T			0x0800	// capable of 10BT
-
-// Bit definitions: Auto-Negotiation Advertisement
-#define GMII_ANAR_ASYM_PAUSE		0x0800	// support asymetric pause
-#define GMII_ANAR_PAUSE			0x0400	// support pause packets
-#define GMII_ANAR_100T4			0x0200	// support 100BT4
-#define GMII_ANAR_100TXFD		0x0100	// support 100BTX full duplex
-#define GMII_ANAR_100TX			0x0080	// support 100BTX half duplex
-#define GMII_ANAR_10TFD			0x0040	// support 10BT full duplex
-#define GMII_ANAR_10T			0x0020	// support 10BT half duplex
-#define GMII_SELECTOR_FIELD		0x001F	// selector field.
-
-// Bit definitions: Auto-Negotiation Link Partner Ability
-#define GMII_ANLPAR_100T4		0x0200	// support 100BT4
-#define GMII_ANLPAR_100TXFD		0x0100	// support 100BTX full duplex
-#define GMII_ANLPAR_100TX		0x0080	// support 100BTX half duplex
-#define GMII_ANLPAR_10TFD		0x0040	// support 10BT full duplex
-#define GMII_ANLPAR_10T			0x0020	// support 10BT half duplex
-#define GMII_ANLPAR_PAUSE		0x0400	// support pause packets
-#define GMII_ANLPAR_ASYM_PAUSE		0x0800	// support asymetric pause
-#define GMII_ANLPAR_ACK			0x4000	// means LCB was successfully rx'd
-#define GMII_SELECTOR_8023		0x0001;
-
-// Bit definitions: 1000BaseT AUX Control
-#define GMII_1000_AUX_CTRL_MASTER_SLAVE		0x1000
-#define GMII_1000_AUX_CTRL_FD_CAPABLE		0x0200	// full duplex capable
-#define GMII_1000_AUX_CTRL_HD_CAPABLE		0x0100	// half duplex capable
-
-// Bit definitions: 1000BaseT AUX Status
-#define GMII_1000_AUX_STATUS_FD_CAPABLE		0x0800	// full duplex capable
-#define GMII_1000_AUX_STATUS_HD_CAPABLE 	0x0400	// half duplex capable
-
-// Cicada MII Registers
-#define GMII_AUX_CTRL_STATUS			0x1C
-#define GMII_AUX_ANEG_CPLT			0x8000
-#define GMII_AUX_FDX				0x0020
-#define GMII_AUX_SPEED_1000			0x0010
-#define GMII_AUX_SPEED_100			0x0008
-
-#ifndef ADVERTISE_PAUSE_CAP
-#define ADVERTISE_PAUSE_CAP			0x0400
-#endif
-
-#ifndef MII_STAT1000
-#define MII_STAT1000				0x000A
-#endif
-
-#ifndef LPA_1000FULL
-#define LPA_1000FULL				0x0800
-#endif
-
-// medium mode register
-#define MEDIUM_GIGA_MODE			0x0001
-#define MEDIUM_FULL_DUPLEX_MODE			0x0002
-#define MEDIUM_TX_ABORT_MODE			0x0004
-#define MEDIUM_ENABLE_125MHZ			0x0008
-#define MEDIUM_ENABLE_RX_FLOWCTRL		0x0010
-#define MEDIUM_ENABLE_TX_FLOWCTRL		0x0020
-#define MEDIUM_ENABLE_JUMBO_FRAME		0x0040
-#define MEDIUM_CHECK_PAUSE_FRAME_MODE		0x0080
-#define MEDIUM_ENABLE_RECEIVE			0x0100
-#define MEDIUM_MII_100M_MODE			0x0200
-#define MEDIUM_ENABLE_JAM_PATTERN		0x0400
-#define MEDIUM_ENABLE_STOP_BACKPRESSURE		0x0800
-#define MEDIUM_ENABLE_SUPPER_MAC_SUPPORT	0x1000
-
-/* PHY mode */
-#define PHY_MODE_MARVELL		0
-#define PHY_MODE_CICADA_FAMILY		1
-#define PHY_MODE_CICADA_V1		1
-#define PHY_MODE_AGERE_FAMILY		2
-#define PHY_MODE_AGERE_V0		2
-#define PHY_MODE_CICADA_V2		5
-#define PHY_MODE_AGERE_V0_GMII		6
-#define PHY_MODE_CICADA_V2_ASIX		9
-#define PHY_MODE_VSC8601		10
-#define PHY_MODE_RTL8211CL		12
-#define PHY_MODE_RTL8211BN		13
-#define PHY_MODE_RTL8251CL		14
-#define PHY_MODE_ATTANSIC_V0		0x40
-#define PHY_MODE_ATTANSIC_FAMILY	0x40
-#define PHY_MODE_MAC_TO_MAC_GMII	0x7C
-
-/*  */
-#define LED_MODE_MARVELL		0
-#define LED_MODE_CAMEO			1
-
-#define MARVELL_LED_CTRL		0x18
-#define MARVELL_MANUAL_LED		0x19
-
-#define PHY_IDENTIFIER			0x0002
-#define PHY_AGERE_IDENTIFIER		0x0282
-#define PHY_CICADA_IDENTIFIER		0x000f
-#define PHY_MARVELL_IDENTIFIER		0x0141
-
-#define PHY_MARVELL_STATUS		0x001b
-#define MARVELL_STATUS_HWCFG		0x0004		/* SGMII without clock */
-
-#define PHY_MARVELL_CTRL		0x0014
-#define MARVELL_CTRL_RXDELAY		0x0080
-#define MARVELL_CTRL_TXDELAY		0x0002
-
-#define PHY_CICADA_EXTPAGE		0x001f
-#define CICADA_EXTPAGE_EN		0x0001
-#define CICADA_EXTPAGE_DIS		0x0000
-
-
-struct {unsigned short value, offset; } CICADA_FAMILY_HWINIT[] =
-{
-	{0x0001, 0x001f}, {0x1c25, 0x0017}, {0x2a30, 0x001f}, {0x234c, 0x0010},
-	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0xa7fa, 0x0000},
-	{0x0012, 0x0002}, {0x3002, 0x0001}, {0x87fa, 0x0000}, {0x52b5, 0x001f},
-	{0xafac, 0x0000}, {0x000d, 0x0002}, {0x001c, 0x0001}, {0x8fac, 0x0000},
-	{0x2a30, 0x001f}, {0x0012, 0x0008}, {0x2a30, 0x001f}, {0x0400, 0x0014},
-	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0xa760, 0x0000},
-	{0x0000, 0x0002}, {0xfaff, 0x0001}, {0x8760, 0x0000}, {0x52b5, 0x001f},
-	{0xa760, 0x0000}, {0x0000, 0x0002}, {0xfaff, 0x0001}, {0x8760, 0x0000},
-	{0x52b5, 0x001f}, {0xafae, 0x0000}, {0x0004, 0x0002}, {0x0671, 0x0001},
-	{0x8fae, 0x0000}, {0x2a30, 0x001f}, {0x0012, 0x0008}, {0x0000, 0x001f},
-};
-
-struct {unsigned short value, offset; } CICADA_V2_HWINIT[] =
-{
-	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0x000f, 0x0002},
-	{0x472a, 0x0001}, {0x8fa4, 0x0000}, {0x2a30, 0x001f}, {0x0212, 0x0008},
-	{0x0000, 0x001f},
-};
-
-struct {unsigned short value, offset; } CICADA_V2_ASIX_HWINIT[] =
-{
-	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0x0012, 0x0002},
-	{0x3002, 0x0001}, {0x87fa, 0x0000}, {0x52b5, 0x001f}, {0x000f, 0x0002},
-	{0x472a, 0x0001}, {0x8fa4, 0x0000}, {0x2a30, 0x001f}, {0x0212, 0x0008},
-	{0x0000, 0x001f},
-};
-
-struct {unsigned short value, offset; } AGERE_FAMILY_HWINIT[] =
-{
-	{0x0800, 0x0000}, {0x0007, 0x0012}, {0x8805, 0x0010}, {0xb03e, 0x0011},
-	{0x8808, 0x0010}, {0xe110, 0x0011}, {0x8806, 0x0010}, {0xb03e, 0x0011},
-	{0x8807, 0x0010}, {0xff00, 0x0011}, {0x880e, 0x0010}, {0xb4d3, 0x0011},
-	{0x880f, 0x0010}, {0xb4d3, 0x0011}, {0x8810, 0x0010}, {0xb4d3, 0x0011},
-	{0x8817, 0x0010}, {0x1c00, 0x0011}, {0x300d, 0x0010}, {0x0001, 0x0011},
-	{0x0002, 0x0012},
-};
-
-struct ax88178_data {
-	u16	EepromData;
-	u16	MediaLink;
-	int	UseGpio0;
-	int	UseRgmii;
-	u8	PhyMode;
-	u8	LedMode;
-	u8	BuffaloOld;
-};
-
-enum watchdog_state {
-	AX_NOP = 0,
-	CHK_LINK,			/* Routine A */
-	CHK_CABLE_EXIST,		/* Called by A */
-	CHK_CABLE_EXIST_AGAIN,		/* Routine B */
-	PHY_POWER_UP,			/* Called by B */
-	PHY_POWER_UP_BH,
-	PHY_POWER_DOWN,
-	CHK_CABLE_STATUS,		/* Routine C */
-	WAIT_AUTONEG_COMPLETE,
-	AX_SET_RX_CFG,
-};
-
-struct ax88772b_data {
-	struct usbnet *dev;
-	struct workqueue_struct *ax_work;
-	struct work_struct check_link;
-	unsigned long time_to_chk;
-	u16 psc;
-	u8 pw_enabled;
-	u8 Event;
-	u8 checksum;
-};
-
-struct ax88772a_data {
-	struct usbnet *dev;
-	struct workqueue_struct *ax_work;
-	struct work_struct check_link;
-	unsigned long autoneg_start;
-#define AX88772B_WATCHDOG	(6 * HZ)
-	u8 Event;
-	u8 TickToExpire;
-	u8 DlyIndex;
-	u8 DlySel;
-	u16 EepromData;
-};
-
-struct ax88772_data {
-	struct usbnet *dev;
-	struct workqueue_struct *ax_work;
-	struct work_struct check_link;
-	unsigned long autoneg_start;
-	u8 Event;
-	u8 TickToExpire;
-};
-
-#define AX_RX_CHECKSUM		1
-#define AX_TX_CHECKSUM		2
-
-/* This structure cannot exceed sizeof(unsigned long [5]) AKA 20 bytes */
-struct ax8817x_data {
-	u8 multi_filter[AX_MCAST_FILTER_SIZE];
-	int (*resume) (struct usb_interface *intf);
-	int (*suspend) (struct usb_interface *intf,
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
-					pm_message_t message);
-#else
-					u32 message);
-#endif
-};
-
-struct ax88172_int_data {
-	u16 res1;
-#define AX_INT_PPLS_LINK		(1 << 0)
-#define AX_INT_SPLS_LINK		(1 << 1)
-#define AX_INT_CABOFF_UNPLUG		(1 << 7)
-	u8 link;
-	u16 res2;
-	u8 status;
-	u16 res3;
-} __attribute__ ((packed));
-
-#define AX_RXHDR_L4_ERR		(1 << 8)
-#define AX_RXHDR_L3_ERR		(1 << 9)
-
-#define AX_RXHDR_L4_TYPE_UDP		1
-#define AX_RXHDR_L4_TYPE_ICMP		2
-#define AX_RXHDR_L4_TYPE_IGMP		3
-#define AX_RXHDR_L4_TYPE_TCP		4
-#define AX_RXHDR_L4_TYPE_TCMPV6	5
-#define AX_RXHDR_L4_TYPE_MASK		7
-
-#define AX_RXHDR_L3_TYPE_IP		1
-#define AX_RXHDR_L3_TYPE_IPV6		2
-
-struct ax88772b_rx_header {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	u16	len:11,
-		res1:1,
-		crc:1,
-		mii:1,
-		runt:1,
-		mc_bc:1;
-
-	u16	len_bar:11,
-		res2:5;
-
-	u8	vlan_ind:3,
-		vlan_tag_striped:1,
-		pri:3,
-		res3:1;
-
-	u8	l4_csum_err:1,
-		l3_csum_err:1,
-		l4_type:3,
-		l3_type:2,
-		ce:1;
-#elif defined (__BIG_ENDIAN_BITFIELD)
-	u16	mc_bc:1,
-		runt:1,
-		mii:1,
-		crc:1,
-		res1:1,
-		len:11;
-
-	u16	res2:5,
-		len_bar:11;
-
-	u8	res3:1,
-		pri:3,
-		vlan_tag_striped:1,
-		vlan_ind:3;
-
-	u8	ce:1,
-		l3_type:2,
-		l4_type:3,
-		l3_csum_err:1,
-		l4_csum_err:1;
-#else
-#error	"Please fix <asm/byteorder.h>"
-#endif
-
-} __attribute__ ((packed));
-
-#endif /* __LINUX_USBNET_ASIX_H */
-
diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c
index 48c0cd144a2d..806372952782 100644
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -49,9 +49,6 @@
 
 #define DRIVER_VERSION		"22-Aug-2005"
 
-static char version[] =
-KERN_INFO "USBNET Framwork for ASIX USB Ethernet Adapter:3.2.101 Beta6"
-	" " __TIME__ " " __DATE__ "\n";
 
 /*-------------------------------------------------------------------------*/
 
@@ -248,7 +245,7 @@ void usbnet_skb_return (struct usbnet *dev, struct sk_buff *skb)
 }
 EXPORT_SYMBOL_GPL(usbnet_skb_return);
 
-
+
 /*-------------------------------------------------------------------------
  *
  * Network Device Driver (peer link to "Host Device", from USB host)
@@ -349,7 +346,7 @@ static int rx_submit (struct usbnet *dev, struct urb *urb, gfp_t flags)
 		usb_free_urb (urb);
 		return -ENOMEM;
 	}
-	//skb_reserve (skb, NET_IP_ALIGN);  //ylz++
+	skb_reserve (skb, NET_IP_ALIGN);
 
 	entry = (struct skb_data *) skb->cb;
 	entry->urb = urb;
@@ -1103,30 +1100,6 @@ netdev_tx_t usbnet_start_xmit (struct sk_buff *skb,
 			}
 		}
 	}
-	
-//$_rbox_$_modify_$_chenzhi
-//$_rbox_$_modify_$_begin
-/* data must be 4-byte aligned */
-        length = ((unsigned long)skb->data) & 0x3;
-        if (length) {
-                if (skb_cloned(skb) ||
-                    ((skb_headroom(skb) < length) &&
-                     (skb_tailroom(skb) < (4-length)))) {
-                        struct sk_buff *skb2;
-                        /* copy skb with proper alignment */
-                        skb2 = skb_copy_expand(skb, 0, 4, GFP_ATOMIC);
-                        dev_kfree_skb_any(skb);
-                        skb = skb2;
-                        if (!skb)
-                                goto drop;
-                } else {
-                        /* move data inside buffer */
-                        length = ((skb_headroom(skb) >= length) ? 0 : 4)-length;
-                        memmove(skb->data+length, skb->data, skb->len);
-                        skb_reserve(skb, length);
-                }
-        }
-//$_rbox_$_modify_$_end	
 	length = skb->len;
 
 	if (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {
@@ -1436,8 +1409,6 @@ usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)
 	net->watchdog_timeo = TX_TIMEOUT_JIFFIES;
 	net->ethtool_ops = &usbnet_ethtool_ops;
 
-	info->flags |= FLAG_AVOID_UNLINK_URBS;
-
 	// allow device-specific bind/init procedures
 	// NOTE net->name still not usable ...
 	if (info->bind) {
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 1b4a6c1b197e..e57b50b38565 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -50,20 +50,6 @@ config WM831X_POWER
 	  Say Y here to enable support for the power management unit
 	  provided by Wolfson Microelectronics WM831x PMICs.
 
-config WM831X_CHARGER_DISPLAY
-	tristate "WM831X Charger display support"
-	depends on WM831X_POWER
-	help
-	  Say Y here to enable support for the power management unit
-	  provided by Wolfson Microelectronics WM831x Charger Display.  
-
-config WM831X_WITH_BATTERY
-	tristate "WM831X battery exist"
-	depends on WM831X_POWER
-	default n
-	help
-	  WM831X battery exist.
-
 config WM8350_POWER
         tristate "WM8350 PMU support"
         depends on MFD_WM8350
@@ -71,13 +57,6 @@ config WM8350_POWER
           Say Y here to enable support for the power management unit
 	  provided by the Wolfson Microelectronics WM8350 PMIC.
 
-config BATTERY_RICOH619
-	tristate "Ricoh RC5T619 PMIC battery driver"
-	depends on MFD_RICOH619 && I2C && GENERIC_HARDIRQS
-	help
-	  Say Y to enable support for the battery control of the Ricoh RC5T619
-	  Power Management device.
-
 config TEST_POWER
 	tristate "Test power driver"
 	help
@@ -206,49 +185,6 @@ config CHARGER_PCF50633
 	help
 	 Say Y to include support for NXP PCF50633 Main Battery Charger.
 
-config BATTERY_STC3100
-	tristate "STC3100 battery driver"
-	depends on I2C && ARCH_RK29
-	help
-	  Say Y here to enable support for batteries with STC3100(I2C) chip.
-
-config BATTERY_BQ27510
-	tristate "BQ27510 battery driver"
-	select I2C_DEV_RK29
-	depends on I2C && ARCH_RK29
-	help
-	  Say Y here to enable support for batteries with BQ27510(I2C) chip.
-
-config BATTERY_BQ27541
-	tristate "BQ27541 battery driver"
-	select I2C_DEV_RK29
-	depends on I2C && ARCH_RK29
-	help
-	  Say Y here to enable support for batteries with BQ27541(I2C) chip.
-	
-config BATTERY_BQ3060
-	tristate "BQ3060 battery driver"
-	depends on I2C && ARCH_RK29
-	help
-	  Say Y here to enable support for batteries with BQ3060(I2C) chip.  
-
-config CHECK_BATT_CAPACITY
-	tristate "check the capacity in BQ27510 battery if 1000mah write capacity for BATT_CAPACITY_MAH"
-	depends on BATTERY_BQ27510 || BATTERY_BQ3060
-	default n
-
-config BATT_CAPACITY_MAH
-	depends on CHECK_BATT_CAPACITY
-	int "battery capacity (in mah)"
-	default 2200
-
-config NO_BATTERY_IC
-	tristate "no BQ27510 battery ic in board"
-	depends on BATTERY_BQ27510 || BATTERY_BQ27541 || BATTERY_BQ3060 
-	default n
-	help
-	  Say no BQ27510(I2C) chip in board .
-
 config BATTERY_JZ4740
 	tristate "Ingenic JZ4740 battery"
 	depends on MACH_JZ4740
@@ -289,13 +225,6 @@ config CHARGER_TWL4030
 	help
 	  Say Y here to enable support for TWL4030 Battery Charge Interface.
 
-config TWL6030_BCI_BATTERY
-	tristate "OMAP TWL6030 BCI Battery driver"
-	depends on TWL4030_CORE && TWL6030_GPADC
-	help
-	  Support for OMAP TWL6030 BCI Battery driver.
-	  This driver can give support for TWL6030 Battery Charge Interface.
-
 config CHARGER_GPIO
 	tristate "GPIO charger"
 	depends on GPIOLIB
@@ -306,83 +235,4 @@ config CHARGER_GPIO
 	  This driver can be build as a module. If so, the module will be
 	  called gpio-charger.
 
-config BATTERY_RK29_ADC
-	tristate "RK29 ADC Battery"
-	depends on ADC_RK29
-	help
-	  Say Y to enable support for the battery on the RK2918.
-
-config BATTERY_RK29_AC_CHARGE
-	tristate "RK29 AC CHARGE"
-	depends on BATTERY_RK29_ADC
-	help
-	  say Y to enable suspport for the AC battery charge
-
-config BATTERY_RK29_VOL3V8
-	tristate "the battery voltage is 3.8V"
-	depends on BATTERY_RK29_ADC
-	help
-          say Y to enable suspport for the battery voltage 3.8V
-
-config BATTERY_RK30_ADC
-        tristate "RK30 ADC Battery"
-        depends on ADC_RK30
-        help
-          Say Y to enable support for the battery on the RK30.
-
-config BATTERY_RK30_ADC_FAC
-        tristate "RK30 ADC Battery Factory"
-        depends on ADC_RK30
-        help
-          Say Y to enable support for the battery on the RK30.
-
-config BATTERY_RK30_AC_CHARGE
-        tristate "RK30 AC CHARGE"
-        depends on BATTERY_RK30_ADC||BATTERY_RK30_ADC_FAC
-        help
-          say Y to enable suspport for the AC battery charge
-
-config BATTERY_RK30_USB_CHARGE
-        tristate "RK30 USB CHARGE"
-        depends on BATTERY_RK30_ADC||BATTERY_RK30_ADC_FAC
-        help
-          say Y to enable suspport for the USB battery charge
-
-config BATTERY_RK30_VOL3V8
-       tristate "the battery voltage is 3.8V"
-        depends on BATTERY_RK30_ADC||BATTERY_RK30_ADC_FAC
-        help
-          say Y to enable suspport for the battery voltage 3.8V	
-	  
-config CW2015_BATTERY
-	tristate "CW2015 battery driver"
-	help
-	  Say Y to enable support for the cw2015 on the Rockchip
-
-config POWER_ON_CHARGER_DISPLAY
-	bool "Support charger display"
-
-config WM8326_VBAT_LOW_DETECTION
-	tristate "Support for WM8326 battery voltage detection."
-	default n
-
-config TWL60xx_VBAT_LOW_DETECTION
-	tristate "Support for twl60xx low battery detection."
-	default n
-	
-config POWER_RT5025
-	bool "RT5025 Pmic Chip Power Driver"
-	depends on MFD_RT5025
-	default n
-	help
-	  Enable RT5025 Power/Gauge part driver.
-
-config CHARGER_SMB347
-	tristate "Summit Microelectronics SMB347 Battery Charger"
-	depends on I2C
-	select REGMAP_I2C
-	help
-	  Say Y to include support for Summit Microelectronics SMB347
-	  Battery Charger.
-
 endif # POWER_SUPPLY
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index 8ab4962c12a9..009a90fa8ac9 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -11,7 +11,6 @@ obj-$(CONFIG_APM_POWER)		+= apm_power.o
 obj-$(CONFIG_MAX8925_POWER)	+= max8925_power.o
 obj-$(CONFIG_WM831X_BACKUP)	+= wm831x_backup.o
 obj-$(CONFIG_WM831X_POWER)	+= wm831x_power.o
-obj-$(CONFIG_WM831X_CHARGER_DISPLAY)	+= wm831x_charger_display.o
 obj-$(CONFIG_WM8350_POWER)	+= wm8350_power.o
 obj-$(CONFIG_TEST_POWER)	+= test_power.o
 
@@ -31,22 +30,9 @@ obj-$(CONFIG_BATTERY_MAX17042)	+= max17042_battery.o
 obj-$(CONFIG_BATTERY_Z2)	+= z2_battery.o
 obj-$(CONFIG_BATTERY_S3C_ADC)	+= s3c_adc_battery.o
 obj-$(CONFIG_CHARGER_PCF50633)	+= pcf50633-charger.o
-obj-$(CONFIG_BATTERY_STC3100)	+= stc3100_battery.o
-obj-$(CONFIG_BATTERY_BQ27510)	+= bq27510_battery.o
-obj-$(CONFIG_BATTERY_BQ27541)	+= bq27541_battery.o
-obj-$(CONFIG_BATTERY_BQ3060)	+= bq3060_battery.o
 obj-$(CONFIG_BATTERY_JZ4740)	+= jz4740-battery.o
 obj-$(CONFIG_BATTERY_INTEL_MID)	+= intel_mid_battery.o
 obj-$(CONFIG_CHARGER_ISP1704)	+= isp1704_charger.o
 obj-$(CONFIG_CHARGER_MAX8903)	+= max8903_charger.o
 obj-$(CONFIG_CHARGER_TWL4030)	+= twl4030_charger.o
 obj-$(CONFIG_CHARGER_GPIO)	+= gpio-charger.o
-obj-$(CONFIG_CHARGER_SMB347)	+= smb347-charger.o
-obj-$(CONFIG_TWL6030_BCI_BATTERY)	+= twl6030_bci_battery.o
-obj-$(CONFIG_BATTERY_RK29_ADC)	+= rk29_adc_battery.o
-obj-$(CONFIG_BATTERY_RK30_ADC)  += rk30_adc_battery.o
-obj-$(CONFIG_PLAT_RK)		+= rk29_charger_display.o
-obj-$(CONFIG_BATTERY_RK30_ADC_FAC)  += rk30_factory_adc_battery.o
-obj-$(CONFIG_CW2015_BATTERY)  += cw2015_battery.o
-obj-$(CONFIG_BATTERY_RICOH619)	+= ricoh619-battery.o
-obj-$(CONFIG_POWER_RT5025)	+= rt5025-power.o rt5025-battery.o rt5025-swjeita.o
diff --git a/drivers/power/smb347-charger.c b/drivers/power/smb347-charger.c
deleted file mode 100644
index ce9918e4f970..000000000000
--- a/drivers/power/smb347-charger.c
+++ /dev/null
@@ -1,515 +0,0 @@
-/*
- * smb347 battery driver
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- *
- */
-#include <linux/module.h>
-#include <linux/param.h>
-#include <linux/jiffies.h>
-#include <linux/workqueue.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/power_supply.h>
-#include <linux/idr.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <asm/unaligned.h>
-#include <mach/gpio.h>
-#include <linux/proc_fs.h>
-#include <asm/uaccess.h>
-#include <mach/board.h>
-#include <mach/iomux.h>
-#include <linux/power/smb347-charger.h>
-
-#include <linux/interrupt.h>
-#include "../usb/dwc_otg/dwc_otg_driver.h"
-
-#if 1
-#define xhc_printk(format, ...)       printk(format, ## __VA_ARGS__)
-#else 
-#define xhc_printk(format, ...)
-#endif
-
-#define SMB347_STATUS_D                 0x3d
-#define SMB347_SPEED                    (300 * 1000) 
-#define MAX_REG_INDEX                   0x3f  
-
-struct workqueue_struct *wq;
-struct smb347_device{
-        struct i2c_client *client;
-        struct delayed_work work;
-        struct smb347_info *info;
-        struct work_struct full_power_work_struct;
-        int usb_host_in;
-};
-
-
-/* Input current limit in mA */
-static const unsigned int icl_tbl[] = {
-        300,
-        500,
-        700,
-        900,
-        1200,
-        1500,
-        1800,
-        2000,
-        2200,
-        2500,
-};
-
-extern dwc_otg_device_t* g_otgdev;
-struct smb347_device * g_smb347_dev;
-static void smb347_init(struct i2c_client *client);
-
-static int smb347_read(struct i2c_client *client, const char reg, char *buf, int len)
-{
-	int ret;
-	ret = i2c_master_reg8_recv(client, reg, buf, len, SMB347_SPEED);
-	return ret; 
-}
-
-static int smb347_write(struct i2c_client *client,const char reg, char *buf, int len)
-{
-	int ret; 
-	ret = i2c_master_reg8_send(client, reg, buf, len, SMB347_SPEED);
-	return ret;
-}
-
-static int dump_smb347_reg(struct smb347_device *dev)
-{
-        int ret = 0;
-        char buf = 0;
-        int reg = 0;
-        if(!dev)
-        {
-                xhc_printk("dev is null");
-                return -1;
-        }
-	for(reg = 0; reg <= MAX_REG_INDEX; reg++)
-	{
-        	ret = i2c_master_reg8_recv(dev->client, reg, &buf, 1, SMB347_SPEED);
-		
-        	if(ret < 0)
-        	{
-                	printk("read smb137 reg error:%d\n",ret);
-        	}
-        	else
-        	{
-                	printk("reg 0x%x:0x%x\n",reg,buf);
-        	}
-	}
-
-	return 0;
-
-}
-
-static ssize_t smb_debug_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t _count)
-{
-        int temp;
-	u8 reg;
-	u8 val;
-	struct smb347_device *smb347_dev = dev_get_drvdata(dev);
-        if (sscanf(buf, "%x", &temp) != 1)
-                return -EINVAL;
-        val = temp & 0x00ff;
-	reg = temp >> 8;
-	smb347_write(smb347_dev->client, reg, &val,1);
-	
-        return _count;
-}
-
-static ssize_t smb_debug_show(struct device *dev, struct device_attribute *attr,
-			char *buf)
-{
-	struct smb347_device *smb347_dev = dev_get_drvdata(dev);
-	dump_smb347_reg(smb347_dev);
-	return 0;
-}
-
-static struct device_attribute smb_debug = 
-	__ATTR(smb_debug, S_IRUGO | S_IWUSR, smb_debug_show, smb_debug_store);
-
-int smb347_is_chg_ok(void)
-{
-        u8 reg = 0;
-	int ret = 0;
-
-        smb347_read(g_smb347_dev->client, 0x37, &reg, 1);
-        ret = (reg & 0x03);
-
-	return ret;
-}
-
-
-EXPORT_SYMBOL(smb347_is_chg_ok);
-
-int smb347_is_charging(void)
-{
-	int status = 0;//POWER_SUPPLY_STATUS_UNKNOWN;
-	u8 data = 0;
-
-	smb347_read(g_smb347_dev->client, SMB347_STATUS_D, &data, 1);
-	if (data & 0x06)
-		status = 1;
-        
-	return status;
-}
-
-EXPORT_SYMBOL(smb347_is_charging);
-
-void smb347_set_something(void)
-{
-	u8 reg;
-
-	smb347_init(g_smb347_dev->client);
-	return;
-}
-
-EXPORT_SYMBOL(smb347_set_something);
-
-void smb347_set_charging(void)
-{
-	u8 val;
-
-        val = 0x26;
-	smb347_write(g_smb347_dev->client, 0x03, &val, 1);
-
-        smb347_read(g_smb347_dev->client, 0x04, &val, 1);
-        val &= 0x7f;
-	smb347_write(g_smb347_dev->client, 0x04, &val, 1);
-
-	return;
-}
-
-EXPORT_SYMBOL(smb347_set_charging);
-
-void smb347_set_discharging(void)
-{
-	u8 val;
-
-        val = 0x20;
-	smb347_write(g_smb347_dev->client, 0x03, &val, 1);
-
-        smb347_read(g_smb347_dev->client, 0x04, &val, 1);
-        val |= 0x80;
-	smb347_write(g_smb347_dev->client, 0x04, &val, 1);
-
-	return;
-}
-
-EXPORT_SYMBOL(smb347_set_discharging);
-
-/* Convert current to register value using lookup table */
-static int current_to_hw(const unsigned int *tbl, size_t size, unsigned int val)
-{
-        size_t i;
-        for (i = 0; i < size; i++) {
-                if (val < tbl[i]) {
-                        break;
-                }
-        }
-
-        return i > 0 ? i - 1 : -EINVAL;
-}
-
-static int smb347_set_current_limits(struct smb347_device *smb_dev)
-{
-        char ret;
-        if (smb_dev->info->max_current) {
-                xhc_printk("xhc_test_smb_dev->info->max_current = %d\n", smb_dev->info->max_current);
-                ret = current_to_hw (icl_tbl, ARRAY_SIZE(icl_tbl),
-                                smb_dev->info->max_current);
-                if (ret < 0) {
-                        return ret;
-                }
-                ret = (ret << 4) + ret;
-        	ret = 0x77; //Hardcode 2000mA 2012-11-06
-                xhc_printk("ret = %x\n", ret);
-                ret = smb347_write(smb_dev->client, 0x01, &ret, 1);
-                xhc_printk("ret = %x\n", ret);
-                if (ret < 0) {
-                        return ret;
-                }
-        } 
-        return 0;
-}
-
-static void suspend_smb347(struct smb347_device *smb347_dev)
-{
-        u8 reg;
-        reg = 0x80;
-	smb347_write(smb347_dev->client,0x30,&reg,1);
-        smb347_read(smb347_dev->client, 0x02, &reg, 1);
-        reg = (reg&0x7f);
-	smb347_write(smb347_dev->client,0x02,&reg,1);
-        xhc_printk("%s\n", __func__);
-}
-
-static void active_smb347(struct smb347_device *smb347_dev)
-{
-        u8 reg;
-        reg = 0x80;
-	smb347_write(smb347_dev->client,0x30,&reg,1);
-        smb347_read(smb347_dev->client, 0x02, &reg, 1);
-        reg = (reg | 0x80);
-	smb347_write(smb347_dev->client,0x02,&reg,1);
-        xhc_printk("%s\n", __func__);
-}
-
-static int smb347_set_otg_control(struct smb347_device *smb_dev)
-{
-        char ret;
-        char reg;
-        if (smb_dev->info->otg_power_form_smb == 1) {
-                ret = smb347_read(smb_dev->client, 0x09, &reg, 1);
-                if (ret < 0) {
-                        xhc_printk("error,ret = %x\n", ret);
-                        return ret;
-                }
-        	reg &= 0xef;  
-                reg |= 0x40; 
-                reg |= 0x20;  
-	        ret = smb347_write(smb_dev->client,0x09,&reg,1);	
-        	if (ret < 0) {
-                        xhc_printk("error,ret = %x\n", ret);
-                        return ret;
-                }
-                reg = 0x76;
-        	smb347_write(smb_dev->client,0x0a,&reg,1);
-                if (ret < 0) {
-                        xhc_printk("error,ret = %x\n", ret);
-                        return ret;
-                }
-        }
-        return 0;
-}
-
-
-static void smb347_init(struct i2c_client *client)  
-{
-	u8 reg;
-        reg = 0x80;
-	smb347_write(client, 0x30, &reg, 1);
-
-        reg = 0xfd;
-	smb347_write(client, 0x00, &reg, 1);
-
-        reg = 0x77;
-	smb347_write(client, 0x01, &reg, 1);
-
-        reg = 0x26;
-	smb347_write(client, 0x03, &reg, 1);
-
-        smb347_read(client, 0x05, &reg, 1);
-        reg |= 0x80;
-	smb347_write(client, 0x05, &reg, 1);
-
-        /* close interrupt */
-        smb347_read(client, 0x38, &reg, 1);
-        smb347_read(client, 0x3a, &reg, 1);
-        reg = 0x0;
-        smb347_write(client, 0x0c, &reg, 1);
-        smb347_write(client, 0x0d, &reg, 1);
-        
-	/* set dc charge when bosh inser dc and usb */
-	smb347_read(client, 0x02, &reg, 1);
-	reg = reg & 0xfb;
-	smb347_write(client, 0x02, &reg, 1);
-
-
-        smb347_set_otg_control(g_smb347_dev);
-        smb347_set_current_limits(g_smb347_dev);
-        
-	dump_smb347_reg(g_smb347_dev);
-}
-
-static void smb347_set_current_work(struct work_struct *work)
-{
-        struct smb347_device *smb347_dev = container_of(to_delayed_work(work), struct smb347_device, work);
-        u8 reg;
-        if (g_otgdev->core_if->op_state == A_HOST && smb347_dev->usb_host_in == 0) {
-
-                xhc_printk("otg_dev->core_if->op_state = %d\n", g_otgdev->core_if->op_state);
-                if (g_smb347_dev->info->otg_power_form_smb == 1) {
-
-        	        reg = 0x7e;
-                	smb347_write(smb347_dev->client,0x0a,&reg,1);
-                } else {
-                        suspend_smb347(smb347_dev);        
-                }
-                smb347_dev->usb_host_in = 1;
-        } else if (g_otgdev->core_if->op_state != A_HOST && smb347_dev->usb_host_in == 1) {
-
-                xhc_printk("otg_dev->core_if->op_state = %d\n", g_otgdev->core_if->op_state);
-                if (g_smb347_dev->info->otg_power_form_smb == 1) {
-	                reg = 0x76;
-        	        smb347_write(smb347_dev->client,0x0a,&reg,1);
-                } else {
-                        active_smb347(smb347_dev);        
-                }
-                smb347_dev->usb_host_in = 0;
-        }
-        schedule_delayed_work(&smb347_dev->work, 100);       
-}
-
-static int smb347_battery_probe(struct i2c_client *client,
-				 const struct i2c_device_id *id)
-{
-	int ret;
-	struct smb347_device *smb347_dev;
-	struct smb347_info *info = client->dev.platform_data;;
-	
-        xhc_printk("__xhc__%s, line = %d\n", __func__, __LINE__);
-        smb347_dev = kzalloc(sizeof(struct smb347_device), GFP_KERNEL);
-        smb347_dev->usb_host_in = 0;
-        if (!smb347_dev) {
-                dev_err(&client->dev, "failed to allocate device info data\n");
-                ret = -ENOMEM;
-                return ret;
-        }
-
-        xhc_printk("__xhc__%s, line = %d\n", __func__, __LINE__);
-        i2c_set_clientdata(client, smb347_dev);
-	dev_set_drvdata(&client->dev,smb347_dev);
-        smb347_dev->client = client;
-	smb347_dev->info = info;
-	g_smb347_dev = smb347_dev;
-        wq = create_singlethread_workqueue("smb347_det");
-
-	if(info->chg_susp_pin) {
-		rk30_mux_api_set(GPIO4D1_SMCDATA9_TRACEDATA9_NAME, 0);
-		ret = gpio_request(info->chg_susp_pin, "chg susp pin");
-		if (ret != 0) {
-			gpio_free(info->chg_susp_pin);
-			xhc_printk("smb347 gpio_request chg_susp_pin error\n");
-			return -EIO;
-		}
-		gpio_direction_output(info->chg_susp_pin, 0);
-		gpio_set_value(info->chg_susp_pin, GPIO_HIGH);
-	}
-        //msleep(200);
-	if(info->chg_ctl_pin) {
-		ret = gpio_request(info->chg_ctl_pin, "chg ctl pin");
-		if (ret != 0) {
-			gpio_free(info->chg_ctl_pin);
-			xhc_printk("smb347 gpio_request chg_ctl_pin error\n");
-			return -EIO;
-		}
-                xhc_printk("__xhc__%s, line = %d\n", __func__, __LINE__);
-		gpio_direction_output(info->chg_ctl_pin, 0);
-		// gpio_set_value(info->chg_ctl_pin, GPIO_HIGH);
-	}
-
-	if(info->chg_en_pin)
-	{
-		rk30_mux_api_set(GPIO4D5_SMCDATA13_TRACEDATA13_NAME, 0);
-		ret = gpio_request(info->chg_en_pin, "chg en pin");
-		if (ret != 0) {
-			gpio_free(info->chg_en_pin);
-			xhc_printk("smb347 gpio_request chg_en_pin error\n");
-			return -EIO;
-		}
-		gpio_direction_output(info->chg_en_pin, 0);
-		gpio_set_value(info->chg_en_pin, GPIO_LOW);
-	}
-	mdelay(100);
-	smb347_init(client);
-
-	INIT_DELAYED_WORK(&smb347_dev->work,smb347_set_current_work);
-        schedule_delayed_work(&smb347_dev->work, msecs_to_jiffies(3*1000));	
-
-        ret = device_create_file(&client->dev,&smb_debug);
-	if(ret) {
-		dev_err(&client->dev, "failed to create sysfs file\n");
-		return ret;
-	}
-	
-	return 0;
-}
-
-static int smb347_battery_remove(struct i2c_client *client)
-{
-        return 0;
-}
-
-static int smb347_battery_suspend(struct i2c_client *client, pm_message_t mesg)
-{
-        xhc_printk("__xhc__%s,", __func__);
-        return 0; 
-}
-
-static int smb347_battery_resume(struct i2c_client *client)
-{
-        xhc_printk("__xhc__%s,", __func__);
-        return 0;
-}
-static  void smb347_battery_shutdown(struct i2c_client *client)
-{
-	u8 reg = 0x0e;
-	smb347_write(client,0x09,&reg,1);
-	xhc_printk("%s,----xhc----\n", __func__);
-}
-static const struct i2c_device_id smb347_id[] = {
-	{ "smb347", 0 },
-	{}
-};
-
-static struct i2c_driver smb347_battery_driver = {
-	.probe   = smb347_battery_probe,
-        .remove  = smb347_battery_remove,
-        .suspend = smb347_battery_suspend,
-        .resume  = smb347_battery_resume,
-        .shutdown = smb347_battery_shutdown,
-
-	.id_table = smb347_id,
-	.driver = {
-		.name = "smb347",
-	},
-};
-
-static int __init smb347_battery_init(void)
-{
-	int ret;
-	
-	ret = i2c_add_driver(&smb347_battery_driver);
-	if (ret)
-		xhc_printk(KERN_ERR "Unable to register smb347 driver\n");
-	
-	return ret;
-}
-
-static void __exit smb347_battery_exit(void)
-{
-        if (g_smb347_dev->info->otg_power_form_smb != 1) {
-                active_smb347(g_smb347_dev);
-        }
-	i2c_del_driver(&smb347_battery_driver);   
-}
-
-//subsys_initcall_sync(smb347_battery_init);
-subsys_initcall(smb347_battery_init);
-module_exit(smb347_battery_exit);
-
-/*
-   delay 500ms to fix the problam 
-   that sometime limit 500ma when startup when insert the hc charger 
- */
-static int __init delay_for_smb347(void)
-{
-	xhc_printk("function: %s\n", __func__);
-	mdelay(500);
-        return 0;
-}
-core_initcall(delay_for_smb347);
-
-MODULE_AUTHOR("xhc@rock-chips.com");
-MODULE_DESCRIPTION("smb347 battery monitor driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/power/test_power.c b/drivers/power/test_power.c
index 225dcbd8611f..b527c93bf2f3 100644
--- a/drivers/power/test_power.c
+++ b/drivers/power/test_power.c
@@ -188,8 +188,8 @@ struct battery_property_map {
 };
 
 static struct battery_property_map map_ac_online[] = {
-	{ 1,  "on"  },
-	{ 0,  "off" },
+	{ 0,  "on"  },
+	{ 1,  "off" },
 	{ -1, NULL  },
 };
 
diff --git a/drivers/power/wm831x_power.c b/drivers/power/wm831x_power.c
index fdf5c74f9f44..ddf8cf5f3204 100644
--- a/drivers/power/wm831x_power.c
+++ b/drivers/power/wm831x_power.c
@@ -18,111 +18,14 @@
 #include <linux/mfd/wm831x/auxadc.h>
 #include <linux/mfd/wm831x/pmu.h>
 #include <linux/mfd/wm831x/pdata.h>
-#include <linux/mfd/wm831x/irq.h>
-
-#define WM831X_DEBUG
-#undef  WM831X_DEBUG
-
-#ifdef WM831X_DEBUG
-#define	WM_BATT_DBG(x...) printk(KERN_INFO x)
-#else
-#define	WM_BATT_DBG(x...)  do {} while (0)
-#endif
-
-#define WM831X_CHG_SYSLO_SHIFT   4
-#define WM831X_CHG_SYSOK_SHIFT   0
-#define WM831X_CHG_SYSLO_MASK  ~(0x7 << 4)
-#define WM831X_CHG_SYSOK_MASK  ~(0x7 << 0)
-
-#define batt_num   52
-
-static int batt_step_table[batt_num] = {
-	3400,3420,3440,3475,3505,3525,
-	3540,3557,3570,3580,3610,
-	3630,3640,3652,3662,3672,
-	3680,3687,3693,3699,3705,
-	3710,3714,3718,3722,3726,
-	3730,3734,3738,3742,3746,
-	3750,3756,3764,3774,3786,
-	3800,3808,3817,3827,3845,
-	3950,3964,3982,4002,4026,
-	4030,4034,4055,4070,4085,4120
-};
-
-static int batt_disp_table[batt_num] = {
-	0,1,2,3,5,7,
-	9,11,13,15,17,
-	19,21,23,25,27,
-	29,31,33,35,37,
-	39,41,43,45,47,
-	49,51,53,55,57,
-	59,61,63,65,67,
-	69,71,73,75,77,
-	79,81,83,85,87,
-	89,91,93,95,97,100
-};
-
-static int batt_chg_step_table[batt_num] = {
-	3520,3525,3575,3600,3620,3644,//+160
-	3662,3670,3684,3700,3715,//+150
-	3720,3748,3756,3775,3790,//+140
-	3810,3814,3818,3822,3825,//+130
-	3830,3832,3834,3836,3837,//+120
-	3839,3841,3842,3844,3844,//+110
-	3855,3860,3864,3871,3890,//+100
-	3910,3930,3952,3977,3997,//+90
-	4030,4047,4064,4080,4096,//+80
-	4132,4144,4150,4170,4195,4200//+70
-};
-
-
-
-#define TIMER_MS_COUNTS 1000
-struct wm_batt_priv_data {
-	int online;
-	int status;
-	int health;
-	int level;
-	int temp;
-	int voltage;
-};
 
 struct wm831x_power {
 	struct wm831x *wm831x;
 	struct power_supply wall;
 	struct power_supply usb;
 	struct power_supply battery;
-	struct work_struct batt_work;
-	struct timer_list timer;
-	struct wm_batt_priv_data batt_info;
-	struct wake_lock 	syslo_wake;
-	int interval;
 };
 
-struct wm831x_power *g_wm831x_power;
-
-static int power_test_sysfs_init(void);
-extern void wm831x_batt_vol_level(struct wm831x_power *power, int batt_vol, int *level);
-static DEFINE_MUTEX(charging_mutex);
-static struct wake_lock batt_wake_lock;
-
-int wm831x_read_on_pin_status(void)
-{
-	int ret;
-	
-	if(!g_wm831x_power)
-	{
-		printk("err:%s:g_wm831x_power address is 0\n",__FUNCTION__);
-		return -1;
-	}
-	
-	ret = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_ON_PIN_CONTROL);
-	if (ret < 0)
-		return ret;
-
-	return !(ret & WM831X_ON_PIN_STS) ? 1 : 0;
-}
-
 static int wm831x_power_check_online(struct wm831x *wm831x, int supply,
 				     union power_supply_propval *val)
 {
@@ -140,54 +43,18 @@ static int wm831x_power_check_online(struct wm831x *wm831x, int supply,
 	return 0;
 }
 
-int wm831x_read_chg_status(void)
-{
-	int ret, usb_chg = 0, wall_chg = 0;
-	
-	if(!g_wm831x_power)
-	{
-		printk("err:%s:g_wm831x_power address is 0\n",__FUNCTION__);
-		return -1;
-	}
-	
-	ret = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_SYSTEM_STATUS);
-	if (ret < 0)
-		return ret;
-
-	if (ret & WM831X_PWR_USB)
-		usb_chg = 1;
-	if (ret & WM831X_PWR_WALL)
-		wall_chg = 1;
-
-	return ((usb_chg | wall_chg) ? 1 : 0);
-}
-
 static int wm831x_power_read_voltage(struct wm831x *wm831x,
 				     enum wm831x_auxadc src,
 				     union power_supply_propval *val)
 {
 	int ret;
+
 	ret = wm831x_auxadc_read_uv(wm831x, src);
 	if (ret >= 0)
 		val->intval = ret;
-	
-	return ret ;
-}
 
-int wm831x_read_batt_voltage(void)
-{
-	int ret = 0;
-	
-	if(!g_wm831x_power)
-	{
-		printk("err:%s:g_wm831x_power address is 0\n",__FUNCTION__);
-		return -1;
-	}
-	
-	ret = wm831x_auxadc_read_uv(g_wm831x_power->wm831x, WM831X_AUX_BATT);
 	return ret;
 }
-//EXPORT_SYMBOL_GPL(wm831x_get_batt_voltage);
 
 /*********************************************************************
  *		WALL Power
@@ -323,34 +190,13 @@ static struct chg_map chg_times[] = {
 	{ 510, 15 << WM831X_CHG_TIME_SHIFT },
 };
 
-static struct chg_map chg_syslos[] = {
-	{ 2800, 0 << WM831X_CHG_SYSLO_SHIFT},
-	{ 2900, 1 << WM831X_CHG_SYSLO_SHIFT},
-	{ 3000, 2 << WM831X_CHG_SYSLO_SHIFT},
-	{ 3100, 3 << WM831X_CHG_SYSLO_SHIFT},
-	{ 3200, 4 << WM831X_CHG_SYSLO_SHIFT},
-	{ 3300, 5 << WM831X_CHG_SYSLO_SHIFT},
-	{ 3400, 6 << WM831X_CHG_SYSLO_SHIFT},
-	{ 3500, 7 << WM831X_CHG_SYSLO_SHIFT},
-};
-
-static struct chg_map chg_sysoks[] = {
-	{ 2800, 0 << WM831X_CHG_SYSOK_SHIFT},
-	{ 2900, 1 << WM831X_CHG_SYSOK_SHIFT},
-	{ 3000, 2 << WM831X_CHG_SYSOK_SHIFT},
-	{ 3100, 3 << WM831X_CHG_SYSOK_SHIFT},
-	{ 3200, 4 << WM831X_CHG_SYSOK_SHIFT},
-	{ 3300, 5 << WM831X_CHG_SYSOK_SHIFT},
-	{ 3400, 6 << WM831X_CHG_SYSOK_SHIFT},
-	{ 3500, 7 << WM831X_CHG_SYSOK_SHIFT},
-};
-
 static void wm831x_battey_apply_config(struct wm831x *wm831x,
 				       struct chg_map *map, int count, int val,
 				       int *reg, const char *name,
 				       const char *units)
 {
 	int i;
+
 	for (i = 0; i < count; i++)
 		if (val == map[i].val)
 			break;
@@ -367,7 +213,7 @@ static void wm831x_config_battery(struct wm831x *wm831x)
 {
 	struct wm831x_pdata *wm831x_pdata = wm831x->dev->platform_data;
 	struct wm831x_battery_pdata *pdata;
-	int ret, reg1, reg2, reg3;
+	int ret, reg1, reg2;
 
 	if (!wm831x_pdata || !wm831x_pdata->battery) {
 		dev_warn(wm831x->dev,
@@ -379,7 +225,6 @@ static void wm831x_config_battery(struct wm831x *wm831x)
 
 	reg1 = 0;
 	reg2 = 0;
-	reg3 = 0;
 
 	if (!pdata->enable) {
 		dev_info(wm831x->dev, "Battery charger disabled\n");
@@ -413,14 +258,6 @@ static void wm831x_config_battery(struct wm831x *wm831x)
 				   pdata->timeout, &reg2,
 				   "charger timeout", "min");
 
-	wm831x_battey_apply_config(wm831x, chg_syslos, ARRAY_SIZE(chg_syslos),
-				   pdata->syslo, &reg3,
-				   "syslo voltage", "mV");
-
-	wm831x_battey_apply_config(wm831x, chg_sysoks, ARRAY_SIZE(chg_sysoks),
-				   pdata->sysok, &reg3,
-				   "sysok voltage", "mV");
-
 	ret = wm831x_reg_unlock(wm831x);
 	if (ret != 0) {
 		dev_err(wm831x->dev, "Failed to unlock registers: %d\n", ret);
@@ -432,10 +269,10 @@ static void wm831x_config_battery(struct wm831x *wm831x)
 			      WM831X_CHG_FAST_MASK |
 			      WM831X_CHG_ITERM_MASK,
 			      reg1);
-	if (ret != 0) {
+	if (ret != 0)
 		dev_err(wm831x->dev, "Failed to set charger control 1: %d\n",
 			ret);
-	}
+
 	ret = wm831x_set_bits(wm831x, WM831X_CHARGER_CONTROL_2,
 			      WM831X_CHG_OFF_MSK |
 			      WM831X_CHG_TIME_MASK |
@@ -443,18 +280,9 @@ static void wm831x_config_battery(struct wm831x *wm831x)
 			      WM831X_CHG_TRKL_ILIM_MASK |
 			      WM831X_CHG_VSEL_MASK,
 			      reg2);
-	if (ret != 0) {
+	if (ret != 0)
 		dev_err(wm831x->dev, "Failed to set charger control 2: %d\n",
 			ret);
-	}
-
-	ret = wm831x_set_bits(wm831x, WM831X_SYSVDD_CONTROL,
-				          WM831X_CHG_SYSLO_MASK |
-						  WM831X_CHG_SYSOK_MASK,
-						  reg3);
-	if (ret < 0) {
-		dev_err(wm831x->dev, "Failed to set sysvdd control reg: %d\n",ret);
-	}
 
 	wm831x_reg_lock(wm831x);
 }
@@ -476,7 +304,6 @@ static int wm831x_bat_check_status(struct wm831x *wm831x, int *status)
 	if (ret < 0)
 		return ret;
 
-
 	switch (ret & WM831X_CHG_STATE_MASK) {
 	case WM831X_CHG_STATE_OFF:
 		*status = POWER_SUPPLY_STATUS_NOT_CHARGING;
@@ -493,53 +320,10 @@ static int wm831x_bat_check_status(struct wm831x *wm831x, int *status)
 
 	return 0;
 }
-int wm831x_read_bat_charging_status(void)
-{
-	int ret, status;
-	
-	if(!g_wm831x_power)
-	{
-		printk("err:%s:g_wm831x_power address is 0\n",__FUNCTION__);
-		return -1;
-	}
-	
-	ret = wm831x_bat_check_status(g_wm831x_power->wm831x, &status);
-	if (ret < 0)
-		return ret;
-	if (status == POWER_SUPPLY_STATUS_CHARGING) 
-		return 1;
-	return 0;
-}
 
 static int wm831x_bat_check_type(struct wm831x *wm831x, int *type)
 {
 	int ret;
-#ifdef WM831X_DEBUG_0 
-	ret = wm831x_reg_read(wm831x, WM831X_POWER_STATE);
-	if (ret < 0)
-		return ret;
-	WM_BATT_DBG("%s: wm831x power status %#x\n", __FUNCTION__, ret);
-
-	ret = wm831x_reg_read(wm831x, WM831X_SYSTEM_STATUS);
-	if (ret < 0)
-		return ret;
-	WM_BATT_DBG("%s: wm831x system status %#x\n", __FUNCTION__, ret);
-
-	ret = wm831x_reg_read(wm831x, WM831X_CHARGER_CONTROL_1);
-	if (ret < 0)
-		return ret;
-	WM_BATT_DBG("%s: wm831x charger control1 %#x\n", __FUNCTION__, ret);
-
-	ret = wm831x_reg_read(wm831x, WM831X_CHARGER_CONTROL_2);
-	if (ret < 0)
-		return ret;
-	WM_BATT_DBG("%s: wm831x charger control2 %#x\n", __FUNCTION__, ret);
-
-	ret = wm831x_reg_read(wm831x, WM831X_CHARGER_STATUS);
-	if (ret < 0)
-		return ret;
-	WM_BATT_DBG("%s: wm831x charger status %#x\n\n", __FUNCTION__, ret);
-#endif
 
 	ret = wm831x_reg_read(wm831x, WM831X_CHARGER_STATUS);
 	if (ret < 0)
@@ -607,41 +391,25 @@ static int wm831x_bat_get_prop(struct power_supply *psy,
 {
 	struct wm831x_power *wm831x_power = dev_get_drvdata(psy->dev->parent);
 	struct wm831x *wm831x = wm831x_power->wm831x;
-	int  ret = 0;
+	int ret = 0;
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
 		ret = wm831x_bat_check_status(wm831x, &val->intval);
-		//val->intval = wm831x_power->batt_info.status;
 		break;
-	case POWER_SUPPLY_PROP_PRESENT:
-	//case POWER_SUPPLY_PROP_ONLINE:
-		//ret = wm831x_power_check_online(wm831x, WM831X_PWR_SRC_BATT, val);
-		val->intval = wm831x_power->batt_info.online;
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = wm831x_power_check_online(wm831x, WM831X_PWR_SRC_BATT,
+						val);
 		break;
 	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-		//ret = wm831x_power_read_voltage(wm831x, WM831X_AUX_BATT, val);
-		val->intval = wm831x_power->batt_info.voltage;//uV
+		ret = wm831x_power_read_voltage(wm831x, WM831X_AUX_BATT, val);
 		break;
 	case POWER_SUPPLY_PROP_HEALTH:
-		//ret = wm831x_bat_check_health(wm831x, &val->intval);
-		val->intval = wm831x_power->batt_info.health;
+		ret = wm831x_bat_check_health(wm831x, &val->intval);
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_TYPE:
 		ret = wm831x_bat_check_type(wm831x, &val->intval);
 		break;
-	case POWER_SUPPLY_PROP_CAPACITY:
-		//ret = wm831x_power_read_voltage(wm831x, WM831X_AUX_BATT, val);
-		//wm831x_batt_vol_level(wm831x_power, val->intval, &level);
-		//val->intval = level;
-		val->intval = wm831x_power->batt_info.level;
-		break;
-	case POWER_SUPPLY_PROP_TEMP:
-		val->intval = 0;
-		break;
-	case POWER_SUPPLY_PROP_TECHNOLOGY:
-		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
-		break;
 	default:
 		ret = -EINVAL;
 		break;
@@ -652,16 +420,12 @@ static int wm831x_bat_get_prop(struct power_supply *psy,
 
 static enum power_supply_property wm831x_bat_props[] = {
 	POWER_SUPPLY_PROP_STATUS,
-	POWER_SUPPLY_PROP_HEALTH,
-	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-	POWER_SUPPLY_PROP_CAPACITY, /* in percents! */
-	POWER_SUPPLY_PROP_TECHNOLOGY,
-	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_HEALTH,
 	POWER_SUPPLY_PROP_CHARGE_TYPE,
 };
 
-#ifdef CONFIG_WM831X_WITH_BATTERY
 static const char *wm831x_bat_irqs[] = {
 	"BATT HOT",
 	"BATT COLD",
@@ -677,18 +441,16 @@ static irqreturn_t wm831x_bat_irq(int irq, void *data)
 {
 	struct wm831x_power *wm831x_power = data;
 	struct wm831x *wm831x = wm831x_power->wm831x;
-	int irq0;
-	
-	irq0 = wm831x->irq_base + WM831X_IRQ_CHG_BATT_HOT + 1;
-	dev_crit(wm831x->dev, "battery changed: i=%d\n", irq-irq0);
-			
+
+	dev_dbg(wm831x->dev, "Battery status changed: %d\n", irq);
+
 	/* The battery charger is autonomous so we don't need to do
 	 * anything except kick user space */
 	power_supply_changed(&wm831x_power->battery);
 
 	return IRQ_HANDLED;
 }
-#endif
+
 
 /*********************************************************************
  *		Initialisation
@@ -701,8 +463,8 @@ static irqreturn_t wm831x_syslo_irq(int irq, void *data)
 
 	/* Not much we can actually *do* but tell people for
 	 * posterity, we're probably about to run out of power. */
-	dev_crit(wm831x->dev, "SYSVDD under voltage and wake lock 60s\n");
-	wake_lock_timeout(&wm831x_power->syslo_wake,60*HZ);//wait for android closing system
+	dev_crit(wm831x->dev, "SYSVDD under voltage\n");
+
 	return IRQ_HANDLED;
 }
 
@@ -711,340 +473,16 @@ static irqreturn_t wm831x_pwr_src_irq(int irq, void *data)
 	struct wm831x_power *wm831x_power = data;
 	struct wm831x *wm831x = wm831x_power->wm831x;
 
-	wake_lock_timeout(&batt_wake_lock, 30 * HZ);
 	dev_dbg(wm831x->dev, "Power source changed\n");
-	WM_BATT_DBG("%s:Power source changed\n", __FUNCTION__); 
+
 	/* Just notify for everything - little harm in overnotifying. */
 	power_supply_changed(&wm831x_power->battery);
 	power_supply_changed(&wm831x_power->usb);
 	power_supply_changed(&wm831x_power->wall);
 
-
 	return IRQ_HANDLED;
 }
 
-static void wm831x_batt_timer_handler(unsigned long data)
-{
-	struct wm831x_power *wm831x_power = (struct wm831x_power*)data;
-	schedule_work(&wm831x_power->batt_work);
-	mod_timer(&wm831x_power->timer, jiffies + msecs_to_jiffies(wm831x_power->interval));
-}
-
-void wm831x_batt_vol_level(struct wm831x_power *wm831x_power, int batt_vol, int *level)
-{
-	int i, ret, status;
-	static int chg_plus = 1000;
-	static int chg_minus = 1000;
-	static int chg_curr = 0;
-	static int chg_num = 60;
-	static int disp_plus = 1000;
-	static int disp_minus = 1000;
-	static int disp_minus2 = 1000;
-	static int disp_curr = 0;
-	static int disp_num = 50;
-	static int batt_level_all = 0;
-	static int batt_level[20];
-	static int avr_num = 0;
-	static int avr_int = 0;
-
-
-	*level = wm831x_power->batt_info.level;
-	ret = wm831x_bat_check_status(wm831x_power->wm831x, &status);
-	if (ret < 0) {
-		printk("%s: check bat status failer...err = %d\n", __FUNCTION__, ret);
-		return;
-	}
-
-	if (status == POWER_SUPPLY_STATUS_NOT_CHARGING 
-			&& batt_vol >= batt_step_table[batt_num-1]) {
-		*level = 100;
-		return;
-	}
-
-	if (status == POWER_SUPPLY_STATUS_CHARGING) 
-	{
-		disp_plus = 0;
-		disp_minus = 0;
-		disp_minus2 = 0;
-		disp_curr = 0;
-		for(i = 0; i < batt_num; i++){        
-			if(batt_vol >= batt_chg_step_table[i] && 
-					 batt_vol < batt_chg_step_table[i+1])
-				break;     
-		}
-		if(batt_vol <= batt_chg_step_table[0])
-			i = 0;
-		if(batt_vol >= batt_chg_step_table[batt_num-1])
-			i = batt_num-1;
-		if(avr_int==0){
-		       	batt_level[avr_num] = batt_disp_table[i];
-		  	batt_level_all += batt_level[avr_num];
-			avr_num++;
-			if(avr_num >= 20)
-			{
-				avr_num = 0;
-				avr_int = 1;
-			}
-			else
-			{
-				*level = batt_disp_table[i];
-				return 0;
-			}
-		}
-		else {
-			batt_level_all -= batt_level[avr_num];
-			batt_level[avr_num]=batt_disp_table[i];
-			batt_level_all += batt_level[avr_num];
-			avr_num++;
-		}
-		if(avr_num >= 20) 
-	       		avr_num = 0;
-		*level = batt_level_all/20;
-		if ((chg_plus == 1000) && (chg_minus == 1000))
-		{
-			*level = *level;
-			chg_plus = 0;
-			chg_minus = 0;
-			chg_curr = 0;
-
-		}
-		else
-		{			
-
-			if (*level >= (wm831x_power->batt_info.level+1))
-			{
-				chg_minus = 0;
-				chg_curr = 0;
-				if(*level < 85)
-					chg_num =10;
-				else
-					chg_num = 5;
-				if (++chg_plus > chg_num)
-				{
-					*level = wm831x_power->batt_info.level + 1;
-					chg_plus = 0;
-				
-				}
-				else
-				{
-					*level = wm831x_power->batt_info.level;
-				}
-			}
-			else
-			{
-				chg_plus = 0;
-				chg_minus = 0;
-				chg_curr = 0;
-				*level = wm831x_power->batt_info.level;
-			}
-		}
-		
-
-		if (*level >= 100)
-			*level = 100;
-		if (*level < 0)
-			*level = 0;
-	}
-	else 
-	{
-		chg_plus = 0;
-		chg_minus = 0;
-		chg_curr = 0;
-		for(i = 0; i < batt_num; i++){        
-			if(batt_vol >= batt_step_table[i] && 
-					 batt_vol < batt_step_table[i+1])
-				break;     
-		}
-		if(batt_vol <= batt_step_table[0])
-			i = 0;
-		if(batt_vol >= batt_step_table[batt_num-1])
-			i = batt_num-1;
-		if(avr_int==0){
-		       	batt_level[avr_num] = batt_disp_table[i];
-		  	batt_level_all += batt_level[avr_num];
-			avr_num++;
-			if(avr_num >= 20)
-			{
-				avr_num = 0;
-				avr_int = 1;
-			}
-			else
-			{
-				*level = batt_disp_table[i];
-				return 0;
-			}
-		}
-		else {
-			batt_level_all -= batt_level[avr_num];
-			batt_level[avr_num]=batt_disp_table[i];
-			batt_level_all += batt_level[avr_num];
-			avr_num++;
-		}
-		if(avr_num >= 20) 
-	       		avr_num = 0;
-		*level = batt_level_all/20;
-		if ((disp_plus == 1000) && (disp_minus == 1000))
-		{
-			*level = *level;
-			disp_plus = 0;
-			disp_minus = 0;
-			disp_minus2 =0;
-			disp_curr = 0;
-		}
-		else
-		{	
-			if(*level <= (wm831x_power ->batt_info.level -20))
-			{
-				disp_plus = 0;
-				disp_curr = 0;
-				disp_minus2 = 0;
-				disp_num = 1;
-				 if (++disp_minus > disp_num)
-				{
-					*level = wm831x_power->batt_info.level - 20;
-					disp_minus = 0;
-				}
-				else
-				{
-					*level = wm831x_power->batt_info.level;
-				}
-			}
-			else if (*level <= (wm831x_power->batt_info.level-1)) 	
-			{
-				disp_plus = 0;
-				disp_curr = 0;
-				disp_minus = 0;
-				if((*level < 17) || (*level > 85))
-					disp_num = 30;
-				else
-					disp_num = 80;
-		
-				 if (++disp_minus2 > disp_num)
-				{
-					*level = wm831x_power->batt_info.level - 1;
-					disp_minus2 = 0;
-				}
-				else
-				{
-
-					*level = wm831x_power->batt_info.level;
-				}
-			}
-			else
-			{
-				disp_plus = 0;
-				disp_minus = 0;
-				disp_minus2 = 0;
-				disp_curr = 0;
-				*level = wm831x_power->batt_info.level;
-			}
-		}
-
-		if (*level >= 100)
-			*level = 100;
-		if (*level < 0)
-			*level = 0;
-	}
-}
-
-static void wm831x_batt_work(struct work_struct *work)
-{
-	int online, status,health,level, ret; 
-    union power_supply_propval val;
-	struct wm831x_power *power = container_of(work, struct wm831x_power, batt_work);
-
-	ret = wm831x_power_check_online(power->wm831x, WM831X_PWR_SRC_BATT, &val);
-	if (ret < 0) {
-		printk("%s: check bat online failer...  err = %d\n", __FUNCTION__, ret);
-		return;
-	}
-	online = val.intval;
-
-	ret = wm831x_bat_check_status(power->wm831x, &status);
-	if (ret < 0) {
-		printk("%s: check bat status failer...  err = %d\n", __FUNCTION__, ret);
-		return;
-	}
-
-	ret = wm831x_bat_check_health(power->wm831x, &health);
-	if (ret < 0) {
-		printk("%s: check bat health failer...  err = %d\n", __FUNCTION__, ret);
-		return;
-	}
-
-	ret = wm831x_power_read_voltage(power->wm831x, WM831X_AUX_BATT, &val);
-	if (ret < 0) {
-		printk("%s: read bat voltage failer...err = %d\n", __FUNCTION__, ret);
-		return;
-	}
-	power->batt_info.voltage = val.intval;
-
-	wm831x_batt_vol_level(power, val.intval / 1000, &level);
-	//mod_timer(&power->timer, jiffies + msecs_to_jiffies(power->interval));
-
-	if (online != power->batt_info.online || status != power->batt_info.status
-			|| health != power->batt_info.health || level != power->batt_info.level)
-	{
-		power->batt_info.online = online;
-		power->batt_info.status = status;
-		power->batt_info.health = health;
-		power->batt_info.level  = level;
-
-		power_supply_changed(&power->battery);
-	}
-
-}
-
-#ifdef CONFIG_POWER_ON_CHARGER_DISPLAY
-static void wm831x_batt_check(struct wm831x_power *power)
-{
-	int online, status,health,level, ret; 
-	union power_supply_propval val;
-//	struct wm831x_power *power = container_of(work, struct wm831x_power, batt_work);
-
-	ret = wm831x_power_check_online(power->wm831x, WM831X_PWR_SRC_BATT, &val);
-	if (ret < 0) {
-		printk("%s: check bat online failer...  err = %d\n", __FUNCTION__, ret);
-		return;
-	}
-	online = val.intval;
-
-	ret = wm831x_bat_check_status(power->wm831x, &status);
-	if (ret < 0) {
-		printk("%s: check bat status failer...  err = %d\n", __FUNCTION__, ret);
-		return;
-	}
-
-	ret = wm831x_bat_check_health(power->wm831x, &health);
-	if (ret < 0) {
-		printk("%s: check bat health failer...  err = %d\n", __FUNCTION__, ret);
-		return;
-	}
-
-	ret = wm831x_power_read_voltage(power->wm831x, WM831X_AUX_BATT, &val);
-	if (ret < 0) {
-		printk("%s: read bat voltage failer...err = %d\n", __FUNCTION__, ret);
-		return;
-	}
-	power->batt_info.voltage = val.intval;
-
-	wm831x_batt_vol_level(power, val.intval / 1000, &level);
-	//mod_timer(&power->timer, jiffies + msecs_to_jiffies(power->interval));
-
-	if (online != power->batt_info.online || status != power->batt_info.status
-			|| health != power->batt_info.health || level != power->batt_info.level)
-	{
-		power->batt_info.online = online;
-		power->batt_info.status = status;
-		power->batt_info.health = health;
-		power->batt_info.level  = level;
-
-		power_supply_changed(&power->battery);
-	}
-}
-#endif
-
-
 static __devinit int wm831x_power_probe(struct platform_device *pdev)
 {
 	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);
@@ -1052,7 +490,7 @@ static __devinit int wm831x_power_probe(struct platform_device *pdev)
 	struct power_supply *usb;
 	struct power_supply *battery;
 	struct power_supply *wall;
-	int ret, irq;
+	int ret, irq, i;
 
 	power = kzalloc(sizeof(struct wm831x_power), GFP_KERNEL);
 	if (power == NULL)
@@ -1069,7 +507,6 @@ static __devinit int wm831x_power_probe(struct platform_device *pdev)
 	 * the status without enabling the charger.
 	 */
 	wm831x_config_battery(wm831x);
-	wake_lock_init(&batt_wake_lock, WAKE_LOCK_SUSPEND, "batt_lock");
 
 	wall->name = "wm831x-wall";
 	wall->type = POWER_SUPPLY_TYPE_MAINS;
@@ -1118,15 +555,12 @@ static __devinit int wm831x_power_probe(struct platform_device *pdev)
 		goto err_syslo;
 	}
 
-#ifdef CONFIG_WM831X_WITH_BATTERY
-	int i;
 	for (i = 0; i < ARRAY_SIZE(wm831x_bat_irqs); i++) {
 		irq = platform_get_irq_byname(pdev, wm831x_bat_irqs[i]);
 		ret = request_threaded_irq(irq, NULL, wm831x_bat_irq,
 					   IRQF_TRIGGER_RISING,
 					   wm831x_bat_irqs[i],
 					   power);
-		WM_BATT_DBG("%s: %s irq no %d\n", __FUNCTION__, wm831x_bat_irqs[i], irq);
 		if (ret != 0) {
 			dev_err(&pdev->dev,
 				"Failed to request %s IRQ %d: %d\n",
@@ -1134,31 +568,9 @@ static __devinit int wm831x_power_probe(struct platform_device *pdev)
 			goto err_bat_irq;
 		}
 	}
-#endif
-
-	power->interval = TIMER_MS_COUNTS;
-	power->batt_info.level = 100;
-	power->batt_info.voltage   = 4200000;
-	power->batt_info.online    = 1;
-	power->batt_info.status    = POWER_SUPPLY_STATUS_DISCHARGING;
-	power->batt_info.health    = POWER_SUPPLY_HEALTH_GOOD;
-
-	wake_lock_init(&power->syslo_wake, WAKE_LOCK_SUSPEND, "wm831x_syslo_wake");
-	INIT_WORK(&power->batt_work, wm831x_batt_work);
-	setup_timer(&power->timer, wm831x_batt_timer_handler, (unsigned long)power);
-	power->timer.expires = jiffies + msecs_to_jiffies(1000);
-	add_timer(&power->timer);
-
-	g_wm831x_power = power;
-#ifdef CONFIG_POWER_ON_CHARGER_DISPLAY
-	wm831x_batt_check(power);//xsf
-#endif
-	
-	printk("%s:wm831x_power initialized\n",__FUNCTION__);
-	power_test_sysfs_init();
+
 	return ret;
-	
-#ifdef CONFIG_WM831X_WITH_BATTERY
+
 err_bat_irq:
 	for (; i >= 0; i--) {
 		irq = platform_get_irq_byname(pdev, wm831x_bat_irqs[i]);
@@ -1166,8 +578,6 @@ static __devinit int wm831x_power_probe(struct platform_device *pdev)
 	}
 	irq = platform_get_irq_byname(pdev, "PWR SRC");
 	free_irq(irq, power);
-#endif
-
 err_syslo:
 	irq = platform_get_irq_byname(pdev, "SYSLO");
 	free_irq(irq, power);
@@ -1185,14 +595,13 @@ static __devinit int wm831x_power_probe(struct platform_device *pdev)
 static __devexit int wm831x_power_remove(struct platform_device *pdev)
 {
 	struct wm831x_power *wm831x_power = platform_get_drvdata(pdev);
-	int irq;
-#ifdef CONFIG_WM831X_WITH_BATTERY
-	int i;
+	int irq, i;
+
 	for (i = 0; i < ARRAY_SIZE(wm831x_bat_irqs); i++) {
 		irq = platform_get_irq_byname(pdev, wm831x_bat_irqs[i]);
 		free_irq(irq, wm831x_power);
 	}
-#endif
+
 	irq = platform_get_irq_byname(pdev, "PWR SRC");
 	free_irq(irq, wm831x_power);
 
@@ -1206,45 +615,19 @@ static __devexit int wm831x_power_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int wm831x_battery_suspend(struct platform_device *dev, pm_message_t state)
-{
-	struct wm831x_power *power = (struct wm831x_power *)platform_get_drvdata(dev);
-	flush_scheduled_work();
-	del_timer(&power->timer);
-	return 0;
-}
-
-static int wm831x_battery_resume(struct platform_device *dev)
-{
-	struct wm831x_power *power = (struct wm831x_power *)platform_get_drvdata(dev);
-	power->timer.expires = jiffies + msecs_to_jiffies(power->interval);
-	add_timer(&power->timer);
-	return 0;
-}
-#else
-#define wm831x_battery_suspend NULL
-#define wm831x_battery_resume  NULL
-#endif
-
 static struct platform_driver wm831x_power_driver = {
 	.probe = wm831x_power_probe,
 	.remove = __devexit_p(wm831x_power_remove),
-	.suspend = wm831x_battery_suspend,
-	.resume = wm831x_battery_resume,
 	.driver = {
 		.name = "wm831x-power",
 	},
 };
+
 static int __init wm831x_power_init(void)
 {
 	return platform_driver_register(&wm831x_power_driver);
 }
-#ifndef CONFIG_POWER_ON_CHARGER_DISPLAY
 module_init(wm831x_power_init);
-#else
-subsys_initcall(wm831x_power_init);
-#endif
 
 static void __exit wm831x_power_exit(void)
 {
@@ -1252,96 +635,6 @@ static void __exit wm831x_power_exit(void)
 }
 module_exit(wm831x_power_exit);
 
-
-static ssize_t power_prop_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	ssize_t ret = 0;
-	int level, power_status, system_status, chg_ctl1, chg_ctl2, chg_status;
-    union power_supply_propval val;
-
-	if (!g_wm831x_power)
-		return -1;
-	power_status = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_POWER_STATE);
-	if (power_status < 0)
-		return power_status;
-	//printk("wm831x power status %#x\n", ret);
-
-	system_status = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_SYSTEM_STATUS);
-	if (system_status < 0)
-		return system_status;
-	//printk("wm831x system status %#x\n", ret);
-
-	chg_ctl1 = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_CHARGER_CONTROL_1);
-	if (chg_ctl1 < 0)
-		return chg_ctl1;
-	//printk("wm831x charger control1 %#x\n", ret);
-
-	chg_ctl2 = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_CHARGER_CONTROL_2);
-	if (chg_ctl2 < 0)
-		return chg_ctl2;
-	//printk("wm831x charger control2 %#x\n", ret);
-
-	chg_status = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_CHARGER_STATUS);
-	if (chg_status < 0)
-		return chg_status;
-	//printk("wm831x charger status %#x\n", ret);
-
-	ret = wm831x_power_read_voltage(g_wm831x_power->wm831x, WM831X_AUX_BATT, &val);
-	if (ret < 0)
-		return ret;
-	wm831x_batt_vol_level(g_wm831x_power, val.intval / 1000, &level);
-	//printk("batt_vol = %d batt_level = %d\n", val.intval, level);
-	//
-	sprintf(buf, "power_status=%#x\n"
-			     "system_status=%#x\n"
-				 "chg_ctl1=%#x\n"
-				 "chg_ctl2=%#x\n"
-				 "chg_status=%#x\n"
-				 "batt_vol=%d\n"
-				 "batt_level=%d%%\n",
-				 power_status,
-				 system_status,
-				 chg_ctl1,
-				 chg_ctl2,
-				 chg_status,
-				 val.intval,
-				 level);
-	ret = strlen(buf) + 1;
-	return ret;
-}
-
-static DEVICE_ATTR(prop, 0444, power_prop_show, NULL);
-
-static struct kobject *power_test_kobj;
-
-static int power_test_sysfs_init(void)
-{
-	int ret ;
-	power_test_kobj = kobject_create_and_add("power_test_prop", NULL);
-	if (power_test_kobj == NULL) {
-		printk(KERN_ERR
-		       "power_test_sysfs_init:"\
-		       "subsystem_register failed\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-	ret = sysfs_create_file(power_test_kobj, &dev_attr_prop.attr);
-	if (ret) {
-		printk(KERN_ERR
-		       "power_test_sysfs_init:"\
-		       "sysfs_create_group failed\n");
-		goto err1;
-	}
-
-	return 0 ;
-err1:
-	kobject_del(power_test_kobj);
-err:
-	return ret ;
-}
-
-
 MODULE_DESCRIPTION("Power supply driver for WM831x PMICs");
 MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfsonmicro.com>");
 MODULE_LICENSE("GPL");
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 5ac3c8d5065a..d7ed20f293d7 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -125,17 +125,6 @@ config REGULATOR_MAX8998
 	  via I2C bus. The provided regulator is suitable for S3C6410
 	  and S5PC1XX chips to control VCC_CORE and VCC_USIM voltages.
 
-config REGULATOR_TPS65910
-	tristate "TI TPS65910/TPS65911 Power Regulators"
-	depends on MFD_TPS65910
-	help
-	  This driver supports TPS65910/TPS65911 voltage regulator chips.
-
-config REGULATOR_TPS65912
-	tristate "TI TPS65912 Power regulator"
-	depends on (MFD_TPS65912_I2C || MFD_TPS65912_SPI)
-	help
-	    This driver supports TPS65912 voltage regulator chip.
 config REGULATOR_TWL4030
 	bool "TI TWL4030/TWL5030/TWL6030/TPS659x0 PMIC"
 	depends on TWL4030_CORE
@@ -171,13 +160,6 @@ config REGULATOR_WM8994
 	  This driver provides support for the voltage regulators on the
 	  WM8994 CODEC.
 
-config REGULATOR_RICOH619
-	tristate "RICOH 619 Power regulators"
-	depends on MFD_RICOH619
-	default n
-	help
-	  This driver supports regulator driver for RICOH619 PMIC.
-
 config REGULATOR_DA903X
 	tristate "Support regulators on Dialog Semiconductor DA9030/DA9034 PMIC"
 	depends on PMIC_DA903X
@@ -266,52 +248,6 @@ config REGULATOR_TPS6507X
 	  three step-down converters and two general-purpose LDO voltage regulators.
 	  It supports TI's software based Class-2 SmartReflex implementation.
 
-config RK2818_REGULATOR_CHARGE
-	tristate "rk2818 Charger IC"
-	help
-	  Say Y to enable support for the current regulators charge on the RK2818.
-
-config RK2818_REGULATOR_LP8725
-	tristate "rk2818 pmic lp8725"
-	depends on I2C
-	help
-	  Say Y to enable support for the voltage regulators pmic lp8725 on the RK2818.
-
-config REGULATOR_ACT8891
-	tristate "Active Semi ACT8891 PMIC regulators"
-	depends on I2C
-	help
-	  Support the voltage and current regulators of the ACT8891 series of PMIC devices.
-
-config REGULATOR_ACT8931
-	tristate "Active Semi ACT8931 PMIC regulators"
-	depends on I2C
-	help
-	  Support the voltage and current regulators of the ACT8931 series of PMIC devices.
-
-config REGULATOR_ACT8846
-	tristate "Active Semi ACT8846 PMIC regulators"
-	depends on I2C
-	help
-	  Support the voltage and current regulators of the ACT8846 series of PMIC devices.
-
-config ACT8846_SUPPORT_RESET
-	tristate "ACT8846 PMIC SUPPORT RESET"
-	depends on REGULATOR_ACT8846=y
-	help
-	  Support short press key to restart.
-
-
-config RK29_PWM_REGULATOR
-	tristate "rk2918 pwm voltage regulator"
-	help
-	  Say Y to enable support for the voltage regulators charge on the RK2918.
-
-config RK30_PWM_REGULATOR
-	tristate "rk30 pwm voltage regulator for discrete dcdc or ldo"
-	help
-	  Say Y to enable support for the voltage regulators control on the RK30 .
-
 config REGULATOR_88PM8607
 	bool "Marvell 88PM8607 Power regulators"
 	depends on MFD_88PM860X=y
@@ -361,12 +297,11 @@ config REGULATOR_TPS6524X
 	  serial interface currently supported on the sequencer serial
 	  port controller.
 
-
-
-config REGULATOR_RT5025
-	bool "Richtek RT5025 PMIC Voltage regulstors"
-	depends on MFD_RT5025
+config REGULATOR_TPS65910
+	tristate "TI TPS65910 Power Regulator"
+	depends on MFD_TPS65910
 	help
-	  This driver supports voltage regulator in RT5025 PMIC chips.
+	  This driver supports TPS65910 voltage regulator chips.
+
 endif
 
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 62bfb75ef495..3932d2ec38f3 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -35,12 +35,6 @@ obj-$(CONFIG_REGULATOR_MC13892) += mc13892-regulator.o
 obj-$(CONFIG_REGULATOR_MC13XXX_CORE) +=  mc13xxx-regulator-core.o
 obj-$(CONFIG_REGULATOR_AB3100) += ab3100.o
 obj-$(CONFIG_REGULATOR_TPS6105X) += tps6105x-regulator.o
-obj-$(CONFIG_RK2818_REGULATOR_LP8725) += rk2818_lp8725.o
-obj-$(CONFIG_RK2818_REGULATOR_CHARGE) += charge-regulator.o
-obj-$(CONFIG_RK29_PWM_REGULATOR) += rk29-pwm-regulator.o
-obj-$(CONFIG_RK30_PWM_REGULATOR) += rk30-pwm-regulator.o
-
-
 obj-$(CONFIG_REGULATOR_TPS65023) += tps65023-regulator.o
 obj-$(CONFIG_REGULATOR_TPS6507X) += tps6507x-regulator.o
 obj-$(CONFIG_REGULATOR_TPS6524X) += tps6524x-regulator.o
@@ -49,11 +43,5 @@ obj-$(CONFIG_REGULATOR_ISL6271A) += isl6271a-regulator.o
 obj-$(CONFIG_REGULATOR_AB8500)	+= ab8500.o
 obj-$(CONFIG_REGULATOR_DB8500_PRCMU) += db8500-prcmu.o
 obj-$(CONFIG_REGULATOR_TPS65910) += tps65910-regulator.o
-obj-$(CONFIG_REGULATOR_TPS65912) += tps65912-regulator.o
-obj-$(CONFIG_REGULATOR_ACT8891) += act8891.o
-obj-$(CONFIG_REGULATOR_ACT8931) += act8931.o
-obj-$(CONFIG_REGULATOR_ACT8846) += act8846.o
-obj-$(CONFIG_REGULATOR_RICOH619) += ricoh619-regulator.o
-obj-$(CONFIG_REGULATOR_RT5025)	+= rt5025-regulator.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index fc8c1c3c11c2..d3e38790906e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -914,7 +914,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
-//	print_constraints(rdev);
+	print_constraints(rdev);
 out:
 	return ret;
 }
@@ -1779,43 +1779,12 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 
 	ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
 
-	if (ret < 0) {
-	int ret_volt = 0;
-	msleep(1);
-	ret_volt = _regulator_get_voltage(rdev);
-	if (ret_volt == regulator->max_uV) {
-		ret = 0;
-	} else {
-		regulator->min_uV = 0;
-		regulator->max_uV = 0;
-		ret = -1;
-	}
-  }
-
 out:
 	mutex_unlock(&rdev->mutex);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage);
 
-int regulator_set_suspend_voltage(struct regulator *regulator, int uV)
-{
-        struct regulator_dev *rdev = regulator->rdev;
-        int ret = 0;
-
-        if (rdev->desc->ops->set_suspend_voltage && uV > 0) {
-                ret = rdev->desc->ops->set_suspend_voltage(rdev, uV);
-                if (ret < 0) {
-                        printk(KERN_ERR "%s: failed to set voltage\n",
-                                __func__);
-                        return ret;
-                }
-        }
-
-        return ret;
-}
-EXPORT_SYMBOL_GPL(regulator_set_suspend_voltage);
-
 /**
  * regulator_set_voltage_time - get raise/fall time
  * @regulator: regulator source
diff --git a/drivers/regulator/tps65910-regulator.c b/drivers/regulator/tps65910-regulator.c
index 88effd49700f..425aab38981e 100644
--- a/drivers/regulator/tps65910-regulator.c
+++ b/drivers/regulator/tps65910-regulator.c
@@ -25,51 +25,45 @@
 #include <linux/gpio.h>
 #include <linux/mfd/tps65910.h>
 
+#define TPS65910_REG_VRTC		0
+#define TPS65910_REG_VIO		1
+#define TPS65910_REG_VDD1		2
+#define TPS65910_REG_VDD2		3
+#define TPS65910_REG_VDD3		4
+#define TPS65910_REG_VDIG1		5
+#define TPS65910_REG_VDIG2		6
+#define TPS65910_REG_VPLL		7
+#define TPS65910_REG_VDAC		8
+#define TPS65910_REG_VAUX1		9
+#define TPS65910_REG_VAUX2		10
+#define TPS65910_REG_VAUX33		11
+#define TPS65910_REG_VMMC		12
+
+#define TPS65911_REG_VDDCTRL		4
+#define TPS65911_REG_LDO1		5
+#define TPS65911_REG_LDO2		6
+#define TPS65911_REG_LDO3		7
+#define TPS65911_REG_LDO4		8
+#define TPS65911_REG_LDO5		9
+#define TPS65911_REG_LDO6		10
+#define TPS65911_REG_LDO7		11
+#define TPS65911_REG_LDO8		12
+
+#define TPS65910_NUM_REGULATOR		13
 #define TPS65910_SUPPLY_STATE_ENABLED	0x1
-#define EXT_SLEEP_CONTROL (TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1 |	\
-			TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2 |		\
-			TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3 |		\
-			TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP)
 
 /* supported VIO voltages in milivolts */
 static const u16 VIO_VSEL_table[] = {
 	1500, 1800, 2500, 3300,
 };
 
-/* TPS65910 VDD1 and VDD2 */
-/* value round off 12.5 is made as 12 */
-static const u16 VDD1_VSEL_table[] = {
-	   0,  600,  600,  600,  612,  625,  637,  650,
-	 662,  675,  687,  700,  712,  725,  737,  750,
-	 762,  775,  787,  800,  812,  825,  837,  850,
-	 862,  875,  887,  900,  912,  925,  937,  950,
-	 962,  975,  987, 1000, 1012, 1025, 1037, 1050,
-	1062, 1075, 1087, 1100, 1112, 1125, 1137, 1150,
-	1162, 1175, 1187, 1200, 1212, 1225, 1237, 1250,
-	1262, 1275, 1287, 1300, 1312, 1325, 1337, 1350,
-	1362, 1375, 1387, 1400, 1412, 1425, 1437, 1450,
-	1462, 1475, 1487, 1500,
-};
-
-static const u16 VDD2_VSEL_table[] = {
-	   0,  600,  600,  600,  612,  625,  637,  650,
-	 662,  675,  687,  700,  712,  725,  737,  750,
-	 762,  775,  787,  800,  812,  825,  837,  850,
-	 862,  875,  887,  900,  912,  925,  937,  950,
-	 962,  975,  987, 1000, 1012, 1025, 1037, 1050,
-	1062, 1075, 1087, 1100, 1112, 1125, 1137, 1150,
-	1162, 1175, 1187, 1200, 1212, 1225, 1237, 1250,
-	1262, 1275, 1287, 1300, 1312, 1325, 1337, 1350,
-	1362, 1375, 1387, 1400, 1412, 1425, 1437, 1450,
-	1462, 1475, 1487, 1500,
-};
+/* VSEL tables for TPS65910 specific LDOs and dcdc's */
 
-/* TPS65910 VDD3 */
+/* supported VDD3 voltages in milivolts */
 static const u16 VDD3_VSEL_table[] = {
-	1000,1400
+	5000,
 };
 
-
 /* supported VDIG1 voltages in milivolts */
 static const u16 VDIG1_VSEL_table[] = {
 	1200, 1500, 1800, 2700,
@@ -114,250 +108,169 @@ struct tps_info {
 	const char *name;
 	unsigned min_uV;
 	unsigned max_uV;
-	u8 n_voltages;
-	const u16 *voltage_table;
-	int enable_time_us;
+	u8 table_len;
+	const u16 *table;
 };
 
 static struct tps_info tps65910_regs[] = {
 	{
 		.name = "VRTC",
-		.enable_time_us = 2200,
 	},
 	{
 		.name = "VIO",
 		.min_uV = 1500000,
 		.max_uV = 3300000,
-		.n_voltages = ARRAY_SIZE(VIO_VSEL_table),
-		.voltage_table = VIO_VSEL_table,
-		.enable_time_us = 350,
+		.table_len = ARRAY_SIZE(VIO_VSEL_table),
+		.table = VIO_VSEL_table,
 	},
 	{
 		.name = "VDD1",
 		.min_uV = 600000,
-		.max_uV = 1500000,
-		.n_voltages = ARRAY_SIZE(VDD1_VSEL_table),
-		.voltage_table = VDD1_VSEL_table,
-		.enable_time_us = 350,
+		.max_uV = 4500000,
 	},
 	{
 		.name = "VDD2",
 		.min_uV = 600000,
-		.max_uV = 1500000,
-		.n_voltages = ARRAY_SIZE(VDD2_VSEL_table),
-		.voltage_table = VDD2_VSEL_table,
-		.enable_time_us = 350,
+		.max_uV = 4500000,
 	},
 	{
 		.name = "VDD3",
-		.min_uV = 1000000,
-		.max_uV = 1400000,
-		.n_voltages = ARRAY_SIZE(VDD3_VSEL_table),
-		.voltage_table = VDD3_VSEL_table,
-		.enable_time_us = 200,
+		.min_uV = 5000000,
+		.max_uV = 5000000,
+		.table_len = ARRAY_SIZE(VDD3_VSEL_table),
+		.table = VDD3_VSEL_table,
 	},
 	{
 		.name = "VDIG1",
 		.min_uV = 1200000,
 		.max_uV = 2700000,
-		.n_voltages = ARRAY_SIZE(VDIG1_VSEL_table),
-		.voltage_table = VDIG1_VSEL_table,
-		.enable_time_us = 100,
+		.table_len = ARRAY_SIZE(VDIG1_VSEL_table),
+		.table = VDIG1_VSEL_table,
 	},
 	{
 		.name = "VDIG2",
 		.min_uV = 1000000,
 		.max_uV = 1800000,
-		.n_voltages = ARRAY_SIZE(VDIG2_VSEL_table),
-		.voltage_table = VDIG2_VSEL_table,
-		.enable_time_us = 100,
+		.table_len = ARRAY_SIZE(VDIG2_VSEL_table),
+		.table = VDIG2_VSEL_table,
 	},
 	{
 		.name = "VPLL",
 		.min_uV = 1000000,
 		.max_uV = 2500000,
-		.n_voltages = ARRAY_SIZE(VPLL_VSEL_table),
-		.voltage_table = VPLL_VSEL_table,
-		.enable_time_us = 100,
+		.table_len = ARRAY_SIZE(VPLL_VSEL_table),
+		.table = VPLL_VSEL_table,
 	},
 	{
 		.name = "VDAC",
 		.min_uV = 1800000,
 		.max_uV = 2850000,
-		.n_voltages = ARRAY_SIZE(VDAC_VSEL_table),
-		.voltage_table = VDAC_VSEL_table,
-		.enable_time_us = 100,
+		.table_len = ARRAY_SIZE(VDAC_VSEL_table),
+		.table = VDAC_VSEL_table,
 	},
 	{
 		.name = "VAUX1",
 		.min_uV = 1800000,
 		.max_uV = 2850000,
-		.n_voltages = ARRAY_SIZE(VAUX1_VSEL_table),
-		.voltage_table = VAUX1_VSEL_table,
-		.enable_time_us = 100,
+		.table_len = ARRAY_SIZE(VAUX1_VSEL_table),
+		.table = VAUX1_VSEL_table,
 	},
 	{
 		.name = "VAUX2",
 		.min_uV = 1800000,
 		.max_uV = 3300000,
-		.n_voltages = ARRAY_SIZE(VAUX2_VSEL_table),
-		.voltage_table = VAUX2_VSEL_table,
-		.enable_time_us = 100,
+		.table_len = ARRAY_SIZE(VAUX2_VSEL_table),
+		.table = VAUX2_VSEL_table,
 	},
 	{
 		.name = "VAUX33",
 		.min_uV = 1800000,
 		.max_uV = 3300000,
-		.n_voltages = ARRAY_SIZE(VAUX33_VSEL_table),
-		.voltage_table = VAUX33_VSEL_table,
-		.enable_time_us = 100,
+		.table_len = ARRAY_SIZE(VAUX33_VSEL_table),
+		.table = VAUX33_VSEL_table,
 	},
 	{
 		.name = "VMMC",
 		.min_uV = 1800000,
 		.max_uV = 3300000,
-		.n_voltages = ARRAY_SIZE(VMMC_VSEL_table),
-		.voltage_table = VMMC_VSEL_table,
-		.enable_time_us = 100,
+		.table_len = ARRAY_SIZE(VMMC_VSEL_table),
+		.table = VMMC_VSEL_table,
 	},
 };
 
 static struct tps_info tps65911_regs[] = {
-	{
-		.name = "VRTC",
-		.enable_time_us = 2200,
-	},
 	{
 		.name = "VIO",
 		.min_uV = 1500000,
 		.max_uV = 3300000,
-		.n_voltages = ARRAY_SIZE(VIO_VSEL_table),
-		.voltage_table = VIO_VSEL_table,
-		.enable_time_us = 350,
+		.table_len = ARRAY_SIZE(VIO_VSEL_table),
+		.table = VIO_VSEL_table,
 	},
 	{
 		.name = "VDD1",
 		.min_uV = 600000,
 		.max_uV = 4500000,
-		.n_voltages = 73,
-		.enable_time_us = 350,
 	},
 	{
 		.name = "VDD2",
 		.min_uV = 600000,
 		.max_uV = 4500000,
-		.n_voltages = 73,
-		.enable_time_us = 350,
 	},
 	{
 		.name = "VDDCTRL",
 		.min_uV = 600000,
 		.max_uV = 1400000,
-		.n_voltages = 65,
-		.enable_time_us = 900,
 	},
 	{
 		.name = "LDO1",
 		.min_uV = 1000000,
 		.max_uV = 3300000,
-		.n_voltages = 47,
-		.enable_time_us = 420,
 	},
 	{
 		.name = "LDO2",
 		.min_uV = 1000000,
 		.max_uV = 3300000,
-		.n_voltages = 47,
-		.enable_time_us = 420,
 	},
 	{
 		.name = "LDO3",
 		.min_uV = 1000000,
 		.max_uV = 3300000,
-		.n_voltages = 24,
-		.enable_time_us = 230,
 	},
 	{
 		.name = "LDO4",
 		.min_uV = 1000000,
 		.max_uV = 3300000,
-		.n_voltages = 47,
-		.enable_time_us = 230,
 	},
 	{
 		.name = "LDO5",
 		.min_uV = 1000000,
 		.max_uV = 3300000,
-		.n_voltages = 24,
-		.enable_time_us = 230,
 	},
 	{
 		.name = "LDO6",
 		.min_uV = 1000000,
 		.max_uV = 3300000,
-		.n_voltages = 24,
-		.enable_time_us = 230,
 	},
 	{
 		.name = "LDO7",
 		.min_uV = 1000000,
 		.max_uV = 3300000,
-		.n_voltages = 24,
-		.enable_time_us = 230,
 	},
 	{
 		.name = "LDO8",
 		.min_uV = 1000000,
 		.max_uV = 3300000,
-		.n_voltages = 24,
-		.enable_time_us = 230,
 	},
 };
 
-#define EXT_CONTROL_REG_BITS(id, regs_offs, bits) (((regs_offs) << 8) | (bits))
-static unsigned int tps65910_ext_sleep_control[] = {
-	0,
-	EXT_CONTROL_REG_BITS(VIO,    1, 0),
-	EXT_CONTROL_REG_BITS(VDD1,   1, 1),
-	EXT_CONTROL_REG_BITS(VDD2,   1, 2),
-	EXT_CONTROL_REG_BITS(VDD3,   1, 3),
-	EXT_CONTROL_REG_BITS(VDIG1,  0, 1),
-	EXT_CONTROL_REG_BITS(VDIG2,  0, 2),
-	EXT_CONTROL_REG_BITS(VPLL,   0, 6),
-	EXT_CONTROL_REG_BITS(VDAC,   0, 7),
-	EXT_CONTROL_REG_BITS(VAUX1,  0, 3),
-	EXT_CONTROL_REG_BITS(VAUX2,  0, 4),
-	EXT_CONTROL_REG_BITS(VAUX33, 0, 5),
-	EXT_CONTROL_REG_BITS(VMMC,   0, 0),
-};
-
-static unsigned int tps65911_ext_sleep_control[] = {
-	0,
-	EXT_CONTROL_REG_BITS(VIO,     1, 0),
-	EXT_CONTROL_REG_BITS(VDD1,    1, 1),
-	EXT_CONTROL_REG_BITS(VDD2,    1, 2),
-	EXT_CONTROL_REG_BITS(VDDCTRL, 1, 3),
-	EXT_CONTROL_REG_BITS(LDO1,    0, 1),
-	EXT_CONTROL_REG_BITS(LDO2,    0, 2),
-	EXT_CONTROL_REG_BITS(LDO3,    0, 7),
-	EXT_CONTROL_REG_BITS(LDO4,    0, 6),
-	EXT_CONTROL_REG_BITS(LDO5,    0, 3),
-	EXT_CONTROL_REG_BITS(LDO6,    0, 0),
-	EXT_CONTROL_REG_BITS(LDO7,    0, 5),
-	EXT_CONTROL_REG_BITS(LDO8,    0, 4),
-};
-
 struct tps65910_reg {
-	struct regulator_desc *desc;
+	struct regulator_desc desc[TPS65910_NUM_REGULATOR];
 	struct tps65910 *mfd;
-	struct regulator_dev **rdev;
-	struct tps_info **info;
+	struct regulator_dev *rdev[TPS65910_NUM_REGULATOR];
+	struct tps_info *info[TPS65910_NUM_REGULATOR];
 	struct mutex mutex;
-	int num_regulators;
 	int mode;
 	int  (*get_ctrl_reg)(int);
-	unsigned int *ext_sleep_control;
-	unsigned int board_ext_control[TPS65910_NUM_REGS];
 };
 
 static inline int tps65910_read(struct tps65910_reg *pmic, u8 reg)
@@ -402,7 +315,7 @@ static int tps65910_modify_bits(struct tps65910_reg *pmic, u8 reg,
 	return err;
 }
 
-static int tps65910_pmic_reg_read(struct tps65910_reg *pmic, u8 reg)
+static int tps65910_reg_read(struct tps65910_reg *pmic, u8 reg)
 {
 	int data;
 
@@ -416,7 +329,7 @@ static int tps65910_pmic_reg_read(struct tps65910_reg *pmic, u8 reg)
 	return data;
 }
 
-static int tps65910_pmic_reg_write(struct tps65910_reg *pmic, u8 reg, u8 val)
+static int tps65910_reg_write(struct tps65910_reg *pmic, u8 reg, u8 val)
 {
 	int err;
 
@@ -507,7 +420,7 @@ static int tps65910_is_enabled(struct regulator_dev *dev)
 	if (reg < 0)
 		return reg;
 
-	value = tps65910_pmic_reg_read(pmic, reg);
+	value = tps65910_reg_read(pmic, reg);
 	if (value < 0)
 		return value;
 
@@ -540,12 +453,6 @@ static int tps65910_disable(struct regulator_dev *dev)
 	return tps65910_clear_bits(mfd, reg, TPS65910_SUPPLY_STATE_ENABLED);
 }
 
-static int tps65910_enable_time(struct regulator_dev *dev)
-{
-	struct tps65910_reg *pmic = rdev_get_drvdata(dev);
-	int id = rdev_get_id(dev);
-	return pmic->info[id]->enable_time_us;
-}
 
 static int tps65910_set_mode(struct regulator_dev *dev, unsigned int mode)
 {
@@ -580,11 +487,11 @@ static unsigned int tps65910_get_mode(struct regulator_dev *dev)
 	if (reg < 0)
 		return reg;
 
-	value = tps65910_pmic_reg_read(pmic, reg);
+	value = tps65910_reg_read(pmic, reg);
 	if (value < 0)
 		return value;
 
-	if (!(value & LDO_ST_ON_BIT))
+	if (value & LDO_ST_ON_BIT)
 		return REGULATOR_MODE_STANDBY;
 	else if (value & LDO_ST_MODE_BIT)
 		return REGULATOR_MODE_IDLE;
@@ -592,36 +499,36 @@ static unsigned int tps65910_get_mode(struct regulator_dev *dev)
 		return REGULATOR_MODE_NORMAL;
 }
 
-static int tps65910_get_voltage_dcdc_sel(struct regulator_dev *dev)
+static int tps65910_get_voltage_dcdc(struct regulator_dev *dev)
 {
 	struct tps65910_reg *pmic = rdev_get_drvdata(dev);
-	int id = rdev_get_id(dev);
+	int id = rdev_get_id(dev), voltage = 0;
 	int opvsel = 0, srvsel = 0, vselmax = 0, mult = 0, sr = 0;
 
 	switch (id) {
 	case TPS65910_REG_VDD1:
-		opvsel = tps65910_pmic_reg_read(pmic, TPS65910_VDD1_OP);
-		mult = tps65910_pmic_reg_read(pmic, TPS65910_VDD1);
+		opvsel = tps65910_reg_read(pmic, TPS65910_VDD1_OP);
+		mult = tps65910_reg_read(pmic, TPS65910_VDD1);
 		mult = (mult & VDD1_VGAIN_SEL_MASK) >> VDD1_VGAIN_SEL_SHIFT;
-		srvsel = tps65910_pmic_reg_read(pmic, TPS65910_VDD1_SR);
+		srvsel = tps65910_reg_read(pmic, TPS65910_VDD1_SR);
 		sr = opvsel & VDD1_OP_CMD_MASK;
 		opvsel &= VDD1_OP_SEL_MASK;
 		srvsel &= VDD1_SR_SEL_MASK;
 		vselmax = 75;
 		break;
 	case TPS65910_REG_VDD2:
-		opvsel = tps65910_pmic_reg_read(pmic, TPS65910_VDD2_OP);
-		mult = tps65910_pmic_reg_read(pmic, TPS65910_VDD2);
+		opvsel = tps65910_reg_read(pmic, TPS65910_VDD2_OP);
+		mult = tps65910_reg_read(pmic, TPS65910_VDD2);
 		mult = (mult & VDD2_VGAIN_SEL_MASK) >> VDD2_VGAIN_SEL_SHIFT;
-		srvsel = tps65910_pmic_reg_read(pmic, TPS65910_VDD2_SR);
+		srvsel = tps65910_reg_read(pmic, TPS65910_VDD2_SR);
 		sr = opvsel & VDD2_OP_CMD_MASK;
 		opvsel &= VDD2_OP_SEL_MASK;
 		srvsel &= VDD2_SR_SEL_MASK;
 		vselmax = 75;
 		break;
 	case TPS65911_REG_VDDCTRL:
-		opvsel = tps65910_pmic_reg_read(pmic, TPS65911_VDDCTRL_OP);
-		srvsel = tps65910_pmic_reg_read(pmic, TPS65911_VDDCTRL_SR);
+		opvsel = tps65910_reg_read(pmic, TPS65911_VDDCTRL_OP);
+		srvsel = tps65910_reg_read(pmic, TPS65911_VDDCTRL_SR);
 		sr = opvsel & VDDCTRL_OP_CMD_MASK;
 		opvsel &= VDDCTRL_OP_SEL_MASK;
 		srvsel &= VDDCTRL_SR_SEL_MASK;
@@ -639,7 +546,9 @@ static int tps65910_get_voltage_dcdc_sel(struct regulator_dev *dev)
 			srvsel = 3;
 		if (srvsel > vselmax)
 			srvsel = vselmax;
-		return srvsel - 3;
+		srvsel -= 3;
+
+		voltage = (srvsel * VDD1_2_OFFSET + VDD1_2_MIN_VOLT) * 100;
 	} else {
 
 		/* normalise to valid range*/
@@ -647,9 +556,14 @@ static int tps65910_get_voltage_dcdc_sel(struct regulator_dev *dev)
 			opvsel = 3;
 		if (opvsel > vselmax)
 			opvsel = vselmax;
-		return opvsel - 3;
+		opvsel -= 3;
+
+		voltage = (opvsel * VDD1_2_OFFSET + VDD1_2_MIN_VOLT) * 100;
 	}
-	return -EINVAL;
+
+	voltage *= mult;
+
+	return voltage;
 }
 
 static int tps65910_get_voltage(struct regulator_dev *dev)
@@ -661,7 +575,7 @@ static int tps65910_get_voltage(struct regulator_dev *dev)
 	if (reg < 0)
 		return reg;
 
-	value = tps65910_pmic_reg_read(pmic, reg);
+	value = tps65910_reg_read(pmic, reg);
 	if (value < 0)
 		return value;
 
@@ -682,7 +596,7 @@ static int tps65910_get_voltage(struct regulator_dev *dev)
 		return -EINVAL;
 	}
 
-	voltage = pmic->info[id]->voltage_table[value] * 1000;
+	voltage = pmic->info[id]->table[value] * 1000;
 
 	return voltage;
 }
@@ -700,7 +614,7 @@ static int tps65911_get_voltage(struct regulator_dev *dev)
 
 	reg = pmic->get_ctrl_reg(id);
 
-	value = tps65910_pmic_reg_read(pmic, reg);
+	value = tps65910_reg_read(pmic, reg);
 
 	switch (id) {
 	case TPS65911_REG_LDO1:
@@ -732,9 +646,8 @@ static int tps65911_get_voltage(struct regulator_dev *dev)
 		step_mv = 100;
 		break;
 	case TPS65910_REG_VIO:
-		value &= LDO_SEL_MASK;
-		value >>= LDO_SEL_SHIFT;
-		return pmic->info[id]->voltage_table[value] * 1000;
+		return pmic->info[id]->table[value] * 1000;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -742,8 +655,8 @@ static int tps65911_get_voltage(struct regulator_dev *dev)
 	return (LDO_MIN_VOLT + value * step_mv) * 1000;
 }
 
-static int tps65910_set_voltage_dcdc_sel(struct regulator_dev *dev,
-					 unsigned selector)
+static int tps65910_set_voltage_dcdc(struct regulator_dev *dev,
+				unsigned selector)
 {
 	struct tps65910_reg *pmic = rdev_get_drvdata(dev);
 	int id = rdev_get_id(dev), vsel;
@@ -751,37 +664,36 @@ static int tps65910_set_voltage_dcdc_sel(struct regulator_dev *dev,
 
 	switch (id) {
 	case TPS65910_REG_VDD1:
-		dcdc_mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;
+		dcdc_mult = (selector / VDD1_2_NUM_VOLTS) + 1;
 		if (dcdc_mult == 1)
 			dcdc_mult--;
-		vsel = (selector % VDD1_2_NUM_VOLT_FINE) + 3;
+		vsel = (selector % VDD1_2_NUM_VOLTS) + 3;
 
 		tps65910_modify_bits(pmic, TPS65910_VDD1,
 				(dcdc_mult << VDD1_VGAIN_SEL_SHIFT),
 						VDD1_VGAIN_SEL_MASK);
-		tps65910_pmic_reg_write(pmic, TPS65910_VDD1_OP, vsel);
+		tps65910_reg_write(pmic, TPS65910_VDD1_OP, vsel);
 		break;
 	case TPS65910_REG_VDD2:
-		dcdc_mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;
+		dcdc_mult = (selector / VDD1_2_NUM_VOLTS) + 1;
 		if (dcdc_mult == 1)
 			dcdc_mult--;
-		vsel = (selector % VDD1_2_NUM_VOLT_FINE) + 3;
+		vsel = (selector % VDD1_2_NUM_VOLTS) + 3;
 
 		tps65910_modify_bits(pmic, TPS65910_VDD2,
 				(dcdc_mult << VDD2_VGAIN_SEL_SHIFT),
 						VDD1_VGAIN_SEL_MASK);
-		tps65910_pmic_reg_write(pmic, TPS65910_VDD2_OP, vsel);
+		tps65910_reg_write(pmic, TPS65910_VDD2_OP, vsel);
 		break;
 	case TPS65911_REG_VDDCTRL:
-		vsel = selector + 3;
-		tps65910_pmic_reg_write(pmic, TPS65911_VDDCTRL_OP, vsel);
+		vsel = selector;
+		tps65910_reg_write(pmic, TPS65911_VDDCTRL_OP, vsel);
 	}
 
 	return 0;
 }
 
-static int tps65910_set_voltage_sel(struct regulator_dev *dev,
-				    unsigned selector)
+static int tps65910_set_voltage(struct regulator_dev *dev, unsigned selector)
 {
 	struct tps65910_reg *pmic = rdev_get_drvdata(dev);
 	int reg, id = rdev_get_id(dev);
@@ -807,8 +719,7 @@ static int tps65910_set_voltage_sel(struct regulator_dev *dev,
 	return -EINVAL;
 }
 
-static int tps65911_set_voltage_sel(struct regulator_dev *dev,
-				    unsigned selector)
+static int tps65911_set_voltage(struct regulator_dev *dev, unsigned selector)
 {
 	struct tps65910_reg *pmic = rdev_get_drvdata(dev);
 	int reg, id = rdev_get_id(dev);
@@ -828,11 +739,9 @@ static int tps65911_set_voltage_sel(struct regulator_dev *dev,
 	case TPS65911_REG_LDO6:
 	case TPS65911_REG_LDO7:
 	case TPS65911_REG_LDO8:
-		return tps65910_modify_bits(pmic, reg,
-				(selector << LDO_SEL_SHIFT), LDO3_SEL_MASK);
 	case TPS65910_REG_VIO:
 		return tps65910_modify_bits(pmic, reg,
-				(selector << LDO_SEL_SHIFT), LDO_SEL_MASK);
+				(selector << LDO_SEL_SHIFT), LDO3_SEL_MASK);
 	}
 
 	return -EINVAL;
@@ -847,9 +756,9 @@ static int tps65910_list_voltage_dcdc(struct regulator_dev *dev,
 	switch (id) {
 	case TPS65910_REG_VDD1:
 	case TPS65910_REG_VDD2:
-		mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;
+		mult = (selector / VDD1_2_NUM_VOLTS) + 1;
 		volt = VDD1_2_MIN_VOLT +
-				(selector % VDD1_2_NUM_VOLT_FINE) * VDD1_2_OFFSET;
+				(selector % VDD1_2_NUM_VOLTS) * VDD1_2_OFFSET;
 		break;
 	case TPS65911_REG_VDDCTRL:
 		volt = VDDCTRL_MIN_VOLT + (selector * VDDCTRL_OFFSET);
@@ -871,11 +780,11 @@ static int tps65910_list_voltage(struct regulator_dev *dev,
 	if (id < TPS65910_REG_VIO || id > TPS65910_REG_VMMC)
 		return -EINVAL;
 
-	if (selector >= pmic->info[id]->n_voltages)
+	if (selector >= pmic->info[id]->table_len)
 		return -EINVAL;
 	else
-		voltage = pmic->info[id]->voltage_table[selector] * 1000;
-	
+		voltage = pmic->info[id]->table[selector] * 1000;
+
 	return voltage;
 }
 
@@ -910,7 +819,7 @@ static int tps65911_list_voltage(struct regulator_dev *dev, unsigned selector)
 		step_mv = 100;
 		break;
 	case TPS65910_REG_VIO:
-		return pmic->info[id]->voltage_table[selector] * 1000;
+		return pmic->info[id]->table[selector] * 1000;
 	default:
 		return -EINVAL;
 	}
@@ -918,42 +827,15 @@ static int tps65911_list_voltage(struct regulator_dev *dev, unsigned selector)
 	return (LDO_MIN_VOLT + selector * step_mv) * 1000;
 }
 
-static int tps65910_set_voltage_dcdc_time_sel(struct regulator_dev *dev,
-		unsigned int old_selector, unsigned int new_selector)
-{
-	int id = rdev_get_id(dev);
-	int old_volt, new_volt;
-
-	old_volt = tps65910_list_voltage_dcdc(dev, old_selector);
-	if (old_volt < 0)
-		return old_volt;
-
-	new_volt = tps65910_list_voltage_dcdc(dev, new_selector);
-	if (new_volt < 0)
-		return new_volt;
-
-	/* VDD1 and VDD2 are 12.5mV/us, VDDCTRL is 100mV/20us */
-	switch (id) {
-	case TPS65910_REG_VDD1:
-	case TPS65910_REG_VDD2:
-		return DIV_ROUND_UP(abs(old_volt - new_volt)*2, 12500);
-	case TPS65911_REG_VDDCTRL:
-		return DIV_ROUND_UP(abs(old_volt - new_volt), 5000);
-	}
-	return -EINVAL;
-}
-
 /* Regulator ops (except VRTC) */
 static struct regulator_ops tps65910_ops_dcdc = {
 	.is_enabled		= tps65910_is_enabled,
 	.enable			= tps65910_enable,
 	.disable		= tps65910_disable,
-	.enable_time		= tps65910_enable_time,
 	.set_mode		= tps65910_set_mode,
 	.get_mode		= tps65910_get_mode,
-	.get_voltage_sel	= tps65910_get_voltage_dcdc_sel,
-	.set_voltage_sel	= tps65910_set_voltage_dcdc_sel,
-	.set_voltage_time_sel	= tps65910_set_voltage_dcdc_time_sel,
+	.get_voltage		= tps65910_get_voltage_dcdc,
+	.set_voltage_sel	= tps65910_set_voltage_dcdc,
 	.list_voltage		= tps65910_list_voltage_dcdc,
 };
 
@@ -961,7 +843,6 @@ static struct regulator_ops tps65910_ops_vdd3 = {
 	.is_enabled		= tps65910_is_enabled,
 	.enable			= tps65910_enable,
 	.disable		= tps65910_disable,
-	.enable_time		= tps65910_enable_time,
 	.set_mode		= tps65910_set_mode,
 	.get_mode		= tps65910_get_mode,
 	.get_voltage		= tps65910_get_voltage_vdd3,
@@ -972,11 +853,10 @@ static struct regulator_ops tps65910_ops = {
 	.is_enabled		= tps65910_is_enabled,
 	.enable			= tps65910_enable,
 	.disable		= tps65910_disable,
-	.enable_time		= tps65910_enable_time,
 	.set_mode		= tps65910_set_mode,
 	.get_mode		= tps65910_get_mode,
 	.get_voltage		= tps65910_get_voltage,
-	.set_voltage_sel	= tps65910_set_voltage_sel,
+	.set_voltage_sel	= tps65910_set_voltage,
 	.list_voltage		= tps65910_list_voltage,
 };
 
@@ -984,147 +864,13 @@ static struct regulator_ops tps65911_ops = {
 	.is_enabled		= tps65910_is_enabled,
 	.enable			= tps65910_enable,
 	.disable		= tps65910_disable,
-	.enable_time		= tps65910_enable_time,
 	.set_mode		= tps65910_set_mode,
 	.get_mode		= tps65910_get_mode,
 	.get_voltage		= tps65911_get_voltage,
-	.set_voltage_sel	= tps65911_set_voltage_sel,
+	.set_voltage_sel	= tps65911_set_voltage,
 	.list_voltage		= tps65911_list_voltage,
 };
 
-static int tps65910_set_ext_sleep_config(struct tps65910_reg *pmic,
-		int id, int ext_sleep_config)
-{
-	struct tps65910 *mfd = pmic->mfd;
-	u8 regoffs = (pmic->ext_sleep_control[id] >> 8) & 0xFF;
-	u8 bit_pos = (1 << pmic->ext_sleep_control[id] & 0xFF);
-	int ret;
-
-	/*
-	 * Regulator can not be control from multiple external input EN1, EN2
-	 * and EN3 together.
-	 */
-	if (ext_sleep_config & EXT_SLEEP_CONTROL) {
-		int en_count;
-		en_count = ((ext_sleep_config &
-				TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1) != 0);
-		en_count += ((ext_sleep_config &
-				TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2) != 0);
-		en_count += ((ext_sleep_config &
-				TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3) != 0);
-		en_count += ((ext_sleep_config &
-				TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP) != 0);
-		if (en_count > 1) {
-			dev_err(mfd->dev,
-				"External sleep control flag is not proper\n");
-			return -EINVAL;
-		}
-	}
-
-	pmic->board_ext_control[id] = ext_sleep_config;
-
-	/* External EN1 control */
-	if (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1)
-		ret = tps65910_set_bits(mfd,
-				TPS65910_EN1_LDO_ASS + regoffs, bit_pos);
-	else
-		ret = tps65910_clear_bits(mfd,
-				TPS65910_EN1_LDO_ASS + regoffs, bit_pos);
-	if (ret < 0) {
-		dev_err(mfd->dev,
-			"Error in configuring external control EN1\n");
-		return ret;
-	}
-
-	/* External EN2 control */
-	if (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2)
-		ret = tps65910_set_bits(mfd,
-				TPS65910_EN2_LDO_ASS + regoffs, bit_pos);
-	else
-		ret = tps65910_clear_bits(mfd,
-				TPS65910_EN2_LDO_ASS + regoffs, bit_pos);
-	if (ret < 0) {
-		dev_err(mfd->dev,
-			"Error in configuring external control EN2\n");
-		return ret;
-	}
-
-	/* External EN3 control for TPS65910 LDO only */
-	if ((tps65910_chip_id(mfd) == TPS65910) &&
-			(id >= TPS65910_REG_VDIG1)) {
-		if (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3)
-			ret = tps65910_set_bits(mfd,
-				TPS65910_EN3_LDO_ASS + regoffs, bit_pos);
-		else
-			ret = tps65910_clear_bits(mfd,
-				TPS65910_EN3_LDO_ASS + regoffs, bit_pos);
-		if (ret < 0) {
-			dev_err(mfd->dev,
-				"Error in configuring external control EN3\n");
-			return ret;
-		}
-	}
-
-	/* Return if no external control is selected */
-	if (!(ext_sleep_config & EXT_SLEEP_CONTROL)) {
-		/* Clear all sleep controls */
-		ret = tps65910_clear_bits(mfd,
-			TPS65910_SLEEP_KEEP_LDO_ON + regoffs, bit_pos);
-		if (!ret)
-			ret = tps65910_clear_bits(mfd,
-				TPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);
-		if (ret < 0)
-			dev_err(mfd->dev,
-				"Error in configuring SLEEP register\n");
-		return ret;
-	}
-
-	/*
-	 * For regulator that has separate operational and sleep register make
-	 * sure that operational is used and clear sleep register to turn
-	 * regulator off when external control is inactive
-	 */
-	if ((id == TPS65910_REG_VDD1) ||
-		(id == TPS65910_REG_VDD2) ||
-			((id == TPS65911_REG_VDDCTRL) &&
-				(tps65910_chip_id(mfd) == TPS65911))) {
-		int op_reg_add = pmic->get_ctrl_reg(id) + 1;
-		int sr_reg_add = pmic->get_ctrl_reg(id) + 2;
-		int opvsel = tps65910_pmic_reg_read(pmic, op_reg_add);
-		int srvsel = tps65910_pmic_reg_read(pmic, sr_reg_add);
-		if (opvsel & VDD1_OP_CMD_MASK) {
-			u8 reg_val = srvsel & VDD1_OP_SEL_MASK;
-			ret = tps65910_pmic_reg_write(pmic, op_reg_add, reg_val);
-			if (ret < 0) {
-				dev_err(mfd->dev,
-					"Error in configuring op register\n");
-				return ret;
-			}
-		}
-		ret = tps65910_pmic_reg_write(pmic, sr_reg_add, 0);
-		if (ret < 0) {
-			dev_err(mfd->dev, "Error in settting sr register\n");
-			return ret;
-		}
-	}
-
-	ret = tps65910_clear_bits(mfd,
-			TPS65910_SLEEP_KEEP_LDO_ON + regoffs, bit_pos);
-	if (!ret) {
-		if (ext_sleep_config & TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP)
-			ret = tps65910_set_bits(mfd,
-				TPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);
-		else
-			ret = tps65910_clear_bits(mfd,
-				TPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);
-	}
-	if (ret < 0)
-		dev_err(mfd->dev,
-			"Error in configuring SLEEP register\n");
-
-	return ret;
-}
-
 static __devinit int tps65910_probe(struct platform_device *pdev)
 {
 	struct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);
@@ -1139,6 +885,8 @@ static __devinit int tps65910_probe(struct platform_device *pdev)
 	if (!pmic_plat_data)
 		return -EINVAL;
 
+	reg_data = pmic_plat_data->tps65910_pmic_init_data;
+
 	pmic = kzalloc(sizeof(*pmic), GFP_KERNEL);
 	if (!pmic)
 		return -ENOMEM;
@@ -1154,64 +902,27 @@ static __devinit int tps65910_probe(struct platform_device *pdev)
 	switch(tps65910_chip_id(tps65910)) {
 	case TPS65910:
 		pmic->get_ctrl_reg = &tps65910_get_ctrl_register;
-		pmic->num_regulators = ARRAY_SIZE(tps65910_regs);
-		pmic->ext_sleep_control = tps65910_ext_sleep_control;
 		info = tps65910_regs;
 		break;
 	case TPS65911:
 		pmic->get_ctrl_reg = &tps65911_get_ctrl_register;
-		pmic->num_regulators = ARRAY_SIZE(tps65911_regs);
-		pmic->ext_sleep_control = tps65911_ext_sleep_control;
 		info = tps65911_regs;
 		break;
 	default:
 		pr_err("Invalid tps chip version\n");
-		kfree(pmic);
 		return -ENODEV;
 	}
 
-	pmic->desc = kcalloc(pmic->num_regulators,
-			sizeof(struct regulator_desc), GFP_KERNEL);
-	if (!pmic->desc) {
-		err = -ENOMEM;
-		goto err_free_pmic;
-	}
-
-	pmic->info = kcalloc(pmic->num_regulators,
-			sizeof(struct tps_info *), GFP_KERNEL);
-	if (!pmic->info) {
-		err = -ENOMEM;
-		goto err_free_desc;
-	}
-
-	pmic->rdev = kcalloc(pmic->num_regulators,
-			sizeof(struct regulator_dev *), GFP_KERNEL);
-	if (!pmic->rdev) {
-		err = -ENOMEM;
-		goto err_free_info;
-	}
-
-	for (i = 0; i < pmic->num_regulators && i < TPS65910_NUM_REGS;
-			i++, info++) {
-
-		reg_data = pmic_plat_data->tps65910_pmic_init_data[i];
-
-		/* Regulator API handles empty constraints but not NULL
-		 * constraints */
-		if (!reg_data)
-			continue;
-
+	for (i = 0; i < TPS65910_NUM_REGULATOR; i++, info++, reg_data++) {
 		/* Register the regulators */
 		pmic->info[i] = info;
 
 		pmic->desc[i].name = info->name;
 		pmic->desc[i].id = i;
-		pmic->desc[i].n_voltages = info->n_voltages;
+		pmic->desc[i].n_voltages = info->table_len;
 
 		if (i == TPS65910_REG_VDD1 || i == TPS65910_REG_VDD2) {
 			pmic->desc[i].ops = &tps65910_ops_dcdc;
-			pmic->desc[i].n_voltages = VDD1_2_NUM_VOLT_FINE *
-							VDD1_2_NUM_VOLT_COARSE;
 		} else if (i == TPS65910_REG_VDD3) {
 			if (tps65910_chip_id(tps65910) == TPS65910)
 				pmic->desc[i].ops = &tps65910_ops_vdd3;
@@ -1224,16 +935,6 @@ static __devinit int tps65910_probe(struct platform_device *pdev)
 				pmic->desc[i].ops = &tps65911_ops;
 		}
 
-		err = tps65910_set_ext_sleep_config(pmic, i,
-				pmic_plat_data->regulator_ext_sleep_control[i]);
-		/*
-		 * Failing on regulator for configuring externally control
-		 * is not a serious issue, just throw warning.
-		 */
-		if (err < 0)
-			dev_warn(tps65910->dev,
-				"Failed to initialise ext control config\n");
-
 		pmic->desc[i].type = REGULATOR_VOLTAGE;
 		pmic->desc[i].owner = THIS_MODULE;
 
@@ -1244,7 +945,7 @@ static __devinit int tps65910_probe(struct platform_device *pdev)
 				"failed to register %s regulator\n",
 				pdev->name);
 			err = PTR_ERR(rdev);
-			goto err_unregister_regulator;
+			goto err;
 		}
 
 		/* Save regulator for cleanup */
@@ -1252,64 +953,26 @@ static __devinit int tps65910_probe(struct platform_device *pdev)
 	}
 	return 0;
 
-err_unregister_regulator:
+err:
 	while (--i >= 0)
 		regulator_unregister(pmic->rdev[i]);
-	kfree(pmic->rdev);
-err_free_info:
-	kfree(pmic->info);
-err_free_desc:
-	kfree(pmic->desc);
-err_free_pmic:
+
 	kfree(pmic);
 	return err;
 }
 
 static int __devexit tps65910_remove(struct platform_device *pdev)
 {
-	struct tps65910_reg *pmic = platform_get_drvdata(pdev);
+	struct tps65910_reg *tps65910_reg = platform_get_drvdata(pdev);
 	int i;
 
-	for (i = 0; i < pmic->num_regulators; i++)
-		regulator_unregister(pmic->rdev[i]);
+	for (i = 0; i < TPS65910_NUM_REGULATOR; i++)
+		regulator_unregister(tps65910_reg->rdev[i]);
 
-	kfree(pmic->rdev);
-	kfree(pmic->info);
-	kfree(pmic->desc);
-	kfree(pmic);
+	kfree(tps65910_reg);
 	return 0;
 }
 
-static void tps65910_shutdown(struct platform_device *pdev)
-{
-	struct tps65910_reg *pmic = platform_get_drvdata(pdev);
-	int i;
-
-	/*
-	 * Before bootloader jumps to kernel, it makes sure that required
-	 * external control signals are in desired state so that given rails
-	 * can be configure accordingly.
-	 * If rails are configured to be controlled from external control
-	 * then before shutting down/rebooting the system, the external
-	 * control configuration need to be remove from the rails so that
-	 * its output will be available as per register programming even
-	 * if external controls are removed. This is require when the POR
-	 * value of the control signals are not in active state and before
-	 * bootloader initializes it, the system requires the rail output
-	 * to be active for booting.
-	 */
-	for (i = 0; i < pmic->num_regulators; i++) {
-		int err;
-		if (!pmic->rdev[i])
-			continue;
-
-		err = tps65910_set_ext_sleep_config(pmic, i, 0);
-		if (err < 0)
-			dev_err(&pdev->dev,
-				"Error in clearing external control\n");
-	}
-}
-
 static struct platform_driver tps65910_driver = {
 	.driver = {
 		.name = "tps65910-pmic",
@@ -1317,14 +980,13 @@ static struct platform_driver tps65910_driver = {
 	},
 	.probe = tps65910_probe,
 	.remove = __devexit_p(tps65910_remove),
-	.shutdown = tps65910_shutdown,
 };
 
 static int __init tps65910_init(void)
 {
 	return platform_driver_register(&tps65910_driver);
 }
-subsys_initcall_sync(tps65910_init);
+subsys_initcall(tps65910_init);
 
 static void __exit tps65910_cleanup(void)
 {
@@ -1333,6 +995,6 @@ static void __exit tps65910_cleanup(void)
 module_exit(tps65910_cleanup);
 
 MODULE_AUTHOR("Graeme Gregory <gg@slimlogic.co.uk>");
-MODULE_DESCRIPTION("TPS65910/TPS65911 voltage regulator driver");
+MODULE_DESCRIPTION("TPS6507x voltage regulator driver");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:tps65910-pmic");
diff --git a/drivers/regulator/twl-regulator.c b/drivers/regulator/twl-regulator.c
index b8c8a55bcfa0..87fe0f75a56e 100644
--- a/drivers/regulator/twl-regulator.c
+++ b/drivers/regulator/twl-regulator.c
@@ -76,25 +76,12 @@ struct twlreg_info {
 #define VREG_STATE		2
 #define VREG_VOLTAGE		3
 #define VREG_VOLTAGE_SMPS	4
-#define VREG_VOLTAGE_DVS_SMPS 3      //add
 /* TWL6030 Misc register offsets */
 #define VREG_BC_ALL		1
 #define VREG_BC_REF		2
 #define VREG_BC_PROC		3
 #define VREG_BC_CLK_RST		4
 
-/* TWL6030 LDO register values for CFG_TRANS */
-#define TWL6030_CFG_TRANS_STATE_MASK	0x03
-#define TWL6030_CFG_TRANS_STATE_OFF	0x00
-/*
- * Auto means the following:
- * SMPS:	AUTO(PWM/PFM)
- * LDO:		AMS(SLP/ACT)
- * resource:	ON
- */
-#define TWL6030_CFG_TRANS_STATE_AUTO	0x01
-#define TWL6030_CFG_TRANS_SLEEP_SHIFT	2
-
 /* TWL6030 LDO register values for CFG_STATE */
 #define TWL6030_CFG_STATE_OFF	0x00
 #define TWL6030_CFG_STATE_ON	0x01
@@ -102,9 +89,7 @@ struct twlreg_info {
 #define TWL6030_CFG_STATE_SLEEP	0x03
 #define TWL6030_CFG_STATE_GRP_SHIFT	5
 #define TWL6030_CFG_STATE_APP_SHIFT	2
-#define TWL6030_CFG_STATE_MASK		0x03
-#define TWL6030_CFG_STATE_APP_MASK	(TWL6030_CFG_STATE_MASK << \
-						TWL6030_CFG_STATE_APP_SHIFT)
+#define TWL6030_CFG_STATE_APP_MASK	(0x03 << TWL6030_CFG_STATE_APP_SHIFT)
 #define TWL6030_CFG_STATE_APP(v)	(((v) & TWL6030_CFG_STATE_APP_MASK) >>\
 						TWL6030_CFG_STATE_APP_SHIFT)
 
@@ -112,32 +97,19 @@ struct twlreg_info {
 #define SMPS_OFFSET_EN		BIT(0)
 #define SMPS_EXTENDED_EN	BIT(1)
 
-/* twl6032 SMPS EPROM values */
+/* twl6025 SMPS EPROM values */
 #define TWL6030_SMPS_OFFSET		0xB0
 #define TWL6030_SMPS_MULT		0xB3
 #define SMPS_MULTOFFSET_SMPS4	BIT(0)
 #define SMPS_MULTOFFSET_VIO	BIT(1)
 #define SMPS_MULTOFFSET_SMPS3	BIT(6)
 
-
-
-/* TWL6030 VUSB supplemental config registers */
-#define TWL6030_MISC2		0xE5
-#define TWL6030_CFG_LDO_PD2	0xF5
-
-/*
- * TWL603X SMPS has 6 bits xxxx_CFG_VOLTAGE.VSEL[5:0] to configure voltages and
- * each bit combination corresponds to a particular voltage (value 63 is
- * reserved).
- */
-#define TWL603X_SMPS_VSEL_MASK	0x3F
-#define TWL603X_SMPS_NUMBER_VOLTAGES TWL603X_SMPS_VSEL_MASK
-
 static inline int
 twlreg_read(struct twlreg_info *info, unsigned slave_subgp, unsigned offset)
 {
 	u8 value;
 	int status;
+
 	status = twl_i2c_read_u8(slave_subgp,
 			&value, info->base + offset);
 	return (status < 0) ? status : value;
@@ -189,47 +161,20 @@ static int twl6030reg_is_enabled(struct regulator_dev *rdev)
 	struct twlreg_info	*info = rdev_get_drvdata(rdev);
 	int			grp = 0, val;
 
-	if (!(info->features & TWL6032_SUBCLASS)) {
+	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
 		grp = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_GRP);
-		if (grp < 0)
-			return grp;
+	if (grp < 0)
+		return grp;
 
+	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
 		grp &= P1_GRP_6030;
-		val = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);
-		val = TWL6030_CFG_STATE_APP(val);
-	} else {
-		val = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);
-		val &= TWL6030_CFG_STATE_MASK;
+	else
 		grp = 1;
-	}
-
-	return grp && (val == TWL6030_CFG_STATE_ON);
-}
-
-static int twl6030reg_set_trans_state(struct regulator_dev *rdev,
-				      u8 shift, u8 val)
-{
-	struct twlreg_info	*info = rdev_get_drvdata(rdev);
-	int			rval;
-	u8			mask;
-
-	/* Read CFG_TRANS register of TWL6030 */
-	rval = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_TRANS);
-
-	if (rval < 0)
-		return rval;
-
-	mask = TWL6030_CFG_TRANS_STATE_MASK << shift;
-	val = (val << shift) & mask;
 
-	/* If value is already set, no need to write to reg */
-	if (val == (rval & mask))
-		return 0;
-
-	rval &= ~mask;
-	rval |= val;
+	val = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);
+	val = TWL6030_CFG_STATE_APP(val);
 
-	return twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_TRANS, rval);
+	return grp && (val == TWL6030_CFG_STATE_ON);
 }
 
 static int twl4030reg_enable(struct regulator_dev *rdev)
@@ -257,7 +202,7 @@ static int twl6030reg_enable(struct regulator_dev *rdev)
 	int			grp = 0;
 	int			ret;
 
-	if (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))
+	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
 		grp = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_GRP);
 	if (grp < 0)
 		return grp;
@@ -265,14 +210,7 @@ static int twl6030reg_enable(struct regulator_dev *rdev)
 	ret = twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE,
 			grp << TWL6030_CFG_STATE_GRP_SHIFT |
 			TWL6030_CFG_STATE_ON);
-	/*
-	 * Ensure it stays in Auto mode when we enter suspend state.
-	 * (TWL6030 in sleep mode).
-	 */
-	if (!ret)
-		ret = twl6030reg_set_trans_state(rdev,
-				TWL6030_CFG_TRANS_SLEEP_SHIFT,
-				TWL6030_CFG_TRANS_STATE_AUTO);
+
 	udelay(info->delay);
 
 	return ret;
@@ -301,7 +239,7 @@ static int twl6030reg_disable(struct regulator_dev *rdev)
 	int			grp = 0;
 	int			ret;
 
-	if (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))
+	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
 		grp = P1_GRP_6030 | P2_GRP_6030 | P3_GRP_6030;
 
 	/* For 6030, set the off state for all grps enabled */
@@ -309,11 +247,6 @@ static int twl6030reg_disable(struct regulator_dev *rdev)
 			(grp) << TWL6030_CFG_STATE_GRP_SHIFT |
 			TWL6030_CFG_STATE_OFF);
 
-	/* Ensure it remains OFF when we enter suspend (TWL6030 in sleep). */
-	if (!ret)
-		ret = twl6030reg_set_trans_state(rdev,
-				TWL6030_CFG_TRANS_SLEEP_SHIFT,
-				TWL6030_CFG_TRANS_STATE_OFF);
 	return ret;
 }
 
@@ -344,12 +277,7 @@ static int twl6030reg_get_status(struct regulator_dev *rdev)
 
 	val = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);
 
-	if (info->features & TWL6032_SUBCLASS)
-		val &= TWL6030_CFG_STATE_MASK;
-	else
-		val = TWL6030_CFG_STATE_APP(val);
-
-	switch (val) {
+	switch (TWL6030_CFG_STATE_APP(val)) {
 	case TWL6030_CFG_STATE_ON:
 		return REGULATOR_STATUS_NORMAL;
 
@@ -405,7 +333,7 @@ static int twl6030reg_set_mode(struct regulator_dev *rdev, unsigned mode)
 	int grp = 0;
 	int val;
 
-	if (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))
+	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
 		grp = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_GRP);
 
 	if (grp < 0)
@@ -429,18 +357,6 @@ static int twl6030reg_set_mode(struct regulator_dev *rdev, unsigned mode)
 	return twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE, val);
 }
 
-static int twl6030ldo_suspend_enable(struct regulator_dev *rdev)
-{
-	return twl6030reg_set_trans_state(rdev, TWL6030_CFG_TRANS_SLEEP_SHIFT,
-					TWL6030_CFG_TRANS_STATE_AUTO);
-}
-
-static int twl6030ldo_suspend_disable(struct regulator_dev *rdev)
-{
-	return twl6030reg_set_trans_state(rdev, TWL6030_CFG_TRANS_SLEEP_SHIFT,
-					TWL6030_CFG_TRANS_STATE_OFF);
-}
-
 /*----------------------------------------------------------------------*/
 
 /*
@@ -654,9 +570,6 @@ static struct regulator_ops twl6030ldo_ops = {
 	.set_mode	= twl6030reg_set_mode,
 
 	.get_status	= twl6030reg_get_status,
-
-	.set_suspend_enable	= twl6030ldo_suspend_enable,
-	.set_suspend_disable	= twl6030ldo_suspend_disable,
 };
 
 /*----------------------------------------------------------------------*/
@@ -704,9 +617,6 @@ static struct regulator_ops twl6030fixed_ops = {
 	.set_mode	= twl6030reg_set_mode,
 
 	.get_status	= twl6030reg_get_status,
-
-	.set_suspend_enable	= twl6030ldo_suspend_enable,
-	.set_suspend_disable	= twl6030ldo_suspend_disable,
 };
 
 static struct regulator_ops twl6030_fixed_resource = {
@@ -896,104 +806,7 @@ twl6030smps_set_voltage(struct regulator_dev *rdev, int min_uV, int max_uV,
 	return twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE_SMPS,
 							vsel);
 }
-//add
-#if 1
-static int twl6030dvssmps_set_voltage(struct regulator_dev *rdev, int min_uV, int max_uV,
-			unsigned int *selector)
-{
-	struct twlreg_info	*info = rdev_get_drvdata(rdev);
-	int	vsel = 0;
 
-	switch (info->flags) {
-	case 0:
-		if (min_uV == 0)
-			vsel = 0;
-		else if ((min_uV >= 600000) && (max_uV <= 1300000)) {
-			vsel = (min_uV - 600000) / 125;
-			if (vsel % 100)
-				vsel += 100;
-			vsel /= 100;
-			vsel++;
-		}
-		/* Values 1..57 for vsel are linear and can be calculated
-		 * values 58..62 are non linear.
-		 */
-		else if ((min_uV > 1900000) && (max_uV >= 2100000))
-			vsel = 62;
-		else if ((min_uV > 1800000) && (max_uV >= 1900000))
-			vsel = 61;
-		else if ((min_uV > 1500000) && (max_uV >= 1800000))
-			vsel = 60;
-		else if ((min_uV > 1350000) && (max_uV >= 1500000))
-			vsel = 59;
-		else if ((min_uV > 1300000) && (max_uV >= 1350000))
-			vsel = 58;
-		else
-			return -EINVAL;
-		break;
-	case SMPS_OFFSET_EN:
-		if (min_uV == 0)
-			vsel = 0;
-		else if ((min_uV >= 700000) && (max_uV <= 1420000)) {
-			vsel = (min_uV - 700000) / 125;
-			if (vsel % 100)
-				vsel += 100;
-			vsel /= 100;
-			vsel++;
-		}
-		/* Values 1..57 for vsel are linear and can be calculated
-		 * values 58..62 are non linear.
-		 */
-		else if ((min_uV > 1900000) && (max_uV >= 2100000))
-			vsel = 62;
-		else if ((min_uV > 1800000) && (max_uV >= 1900000))
-			vsel = 61;
-		else if ((min_uV > 1350000) && (max_uV >= 1800000))
-			vsel = 60;
-		else if ((min_uV > 1350000) && (max_uV >= 1500000))
-			vsel = 59;
-		else if ((min_uV > 1300000) && (max_uV >= 1350000))
-			vsel = 58;
-		else
-			return -EINVAL;
-		break;
-	case SMPS_EXTENDED_EN:
-		if (min_uV == 0)
-			vsel = 0;
-		else if ((min_uV >= 1852000) && (max_uV <= 4013600)) {
-			vsel = (min_uV - 1852000) / 386;
-			if (vsel % 100)
-				vsel += 100;
-			vsel /= 100;
-			vsel++;
-		}
-		break;
-	case SMPS_OFFSET_EN|SMPS_EXTENDED_EN:
-		if (min_uV == 0)
-			vsel = 0;
-		else if ((min_uV >= 2161000) && (max_uV <= 4321000)) {
-			vsel = (min_uV - 1852000) / 386;
-			if (vsel % 100)
-				vsel += 100;
-			vsel /= 100;
-			vsel++;
-		}
-		break;
-	}
-
-	*selector = vsel;
-
-	return twlreg_write(info, TWL_MODULE_PM_DVS, VREG_VOLTAGE_DVS_SMPS,
-							vsel);
-}
-
-static int twl6030dvssmps_get_voltage_sel(struct regulator_dev *rdev)
-{
-	struct twlreg_info	*info = rdev_get_drvdata(rdev);
-
-	return twlreg_read(info, TWL_MODULE_PM_DVS, VREG_VOLTAGE_DVS_SMPS);
-}
-#endif
 static int twl6030smps_get_voltage_sel(struct regulator_dev *rdev)
 {
 	struct twlreg_info	*info = rdev_get_drvdata(rdev);
@@ -1014,49 +827,16 @@ static struct regulator_ops twlsmps_ops = {
 	.set_mode		= twl6030reg_set_mode,
 
 	.get_status		= twl6030reg_get_status,
-
-	.set_suspend_enable	= twl6030ldo_suspend_enable,
-	.set_suspend_disable	= twl6030ldo_suspend_disable,
-};
-
-static struct regulator_ops twl6030_external_control_pin_ops = {
-	.enable			= twl6030reg_enable,
-	.disable		= twl6030reg_disable,
-	.is_enabled		= twl6030reg_is_enabled,
-
-	.set_mode		= twl6030reg_set_mode,
-
-	.get_status		= twl6030reg_get_status,
-
-	.set_suspend_enable	= twl6030ldo_suspend_enable,
-	.set_suspend_disable	= twl6030ldo_suspend_disable,
 };
-//add
-static struct regulator_ops twldvssmps_ops = {
-	.list_voltage		= twl6030smps_list_voltage,
-
-	.set_voltage		= twl6030dvssmps_set_voltage,
-	.get_voltage_sel	= twl6030dvssmps_get_voltage_sel,
 
-	.enable			= twl6030reg_enable,
-	.disable		= twl6030reg_disable,
-	.is_enabled		= twl6030reg_is_enabled,
-
-	.set_mode		= twl6030reg_set_mode,
-
-	.get_status		= twl6030reg_get_status,
-
-	.set_suspend_enable	= twl6030ldo_suspend_enable,
-	.set_suspend_disable	= twl6030ldo_suspend_disable,
-};
 /*----------------------------------------------------------------------*/
 
 #define TWL4030_FIXED_LDO(label, offset, mVolts, num, turnon_delay, \
 			remap_conf) \
 		TWL_FIXED_LDO(label, offset, mVolts, num, turnon_delay, \
 			remap_conf, TWL4030, twl4030fixed_ops)
-#define TWL6030_FIXED_LDO(label, offset, mVolts, turnon_delay) \
-		TWL_FIXED_LDO(label, offset, mVolts, 0x0, turnon_delay, \
+#define TWL6030_FIXED_LDO(label, offset, mVolts, num, turnon_delay) \
+		TWL_FIXED_LDO(label, offset, mVolts, num, turnon_delay, \
 			0x0, TWL6030, twl6030fixed_ops)
 
 #define TWL4030_ADJUSTABLE_LDO(label, offset, num, turnon_delay, remap_conf) { \
@@ -1076,27 +856,29 @@ static struct regulator_ops twldvssmps_ops = {
 		}, \
 	}
 
-#define TWL6030_ADJUSTABLE_LDO(label, offset, min_mVolts, max_mVolts) { \
+#define TWL6030_ADJUSTABLE_LDO(label, offset, min_mVolts, max_mVolts, num) { \
 	.base = offset, \
+	.id = num, \
 	.min_mV = min_mVolts, \
 	.max_mV = max_mVolts, \
 	.desc = { \
 		.name = #label, \
 		.id = TWL6030_REG_##label, \
-		.n_voltages = (max_mVolts - min_mVolts)/100 + 1, \
+		.n_voltages = (max_mVolts - min_mVolts)/100, \
 		.ops = &twl6030ldo_ops, \
 		.type = REGULATOR_VOLTAGE, \
 		.owner = THIS_MODULE, \
 		}, \
 	}
 
-#define TWL6032_ADJUSTABLE_LDO(label, offset, min_mVolts, max_mVolts) { \
+#define TWL6025_ADJUSTABLE_LDO(label, offset, min_mVolts, max_mVolts, num) { \
 	.base = offset, \
+	.id = num, \
 	.min_mV = min_mVolts, \
 	.max_mV = max_mVolts, \
 	.desc = { \
 		.name = #label, \
-		.id = TWL6032_REG_##label, \
+		.id = TWL6025_REG_##label, \
 		.n_voltages = ((max_mVolts - min_mVolts)/100) + 1, \
 		.ops = &twl6030ldo_ops, \
 		.type = REGULATOR_VOLTAGE, \
@@ -1121,8 +903,9 @@ static struct regulator_ops twldvssmps_ops = {
 		}, \
 	}
 
-#define TWL6030_FIXED_RESOURCE(label, offset, turnon_delay) { \
+#define TWL6030_FIXED_RESOURCE(label, offset, num, turnon_delay) { \
 	.base = offset, \
+	.id = num, \
 	.delay = turnon_delay, \
 	.desc = { \
 		.name = #label, \
@@ -1133,61 +916,21 @@ static struct regulator_ops twldvssmps_ops = {
 		}, \
 	}
 
-#define TWL6030_ADJUSTABLE_SMPS(label, offset, min_mVolts, max_mVolts) { \
-	.base = offset, \
-	.min_mV = min_mVolts, \
-	.max_mV = max_mVolts, \
-	.desc = { \
-		.name = #label, \
-		.id = TWL6030_REG_##label, \
-		.n_voltages = TWL603X_SMPS_NUMBER_VOLTAGES, \
-		.ops = &twlsmps_ops, \
-		.type = REGULATOR_VOLTAGE, \
-		.owner = THIS_MODULE, \
-		}, \
-	}
-
-#define TWL6032_ADJUSTABLE_SMPS(label, offset) { \
+#define TWL6025_ADJUSTABLE_SMPS(label, offset, num) { \
 	.base = offset, \
+	.id = num, \
 	.min_mV = 600, \
 	.max_mV = 2100, \
 	.desc = { \
 		.name = #label, \
-		.id = TWL6032_REG_##label, \
-		.n_voltages = TWL603X_SMPS_NUMBER_VOLTAGES, \
+		.id = TWL6025_REG_##label, \
+		.n_voltages = 63, \
 		.ops = &twlsmps_ops, \
 		.type = REGULATOR_VOLTAGE, \
 		.owner = THIS_MODULE, \
 		}, \
 	}
 
-#define TWL6030_EXTERNAL_CONTROL_PIN(label, offset, turnon_delay) { \
-	.base = offset, \
-	.delay = turnon_delay, \
-	.desc = { \
-		.name = #label, \
-		.id = TWL6030_REG_##label, \
-		.ops = &twl6030_external_control_pin_ops, \
-		.type = REGULATOR_VOLTAGE, \
-		.owner = THIS_MODULE, \
-		}, \
-	}
-	
-	//add
-#define TWL6032_ADJUSTABLE_DVSSMPS(label, offset) { \
-	.base = offset, \
-	.min_mV = 600, \
-	.max_mV = 2100, \
-	.desc = { \
-		.name = #label, \
-		.id = TWL6032_REG_##label, \
-		.n_voltages = TWL603X_SMPS_NUMBER_VOLTAGES, \
-		.ops = &twldvssmps_ops, \
-		.type = REGULATOR_VOLTAGE, \
-		.owner = THIS_MODULE, \
-		}, \
-	}
-
 /*
  * We list regulators here if systems need some level of
  * software control over them after boot.
@@ -1218,46 +961,32 @@ static struct twlreg_info twl_regs[] = {
 	/* 6030 REG with base as PMC Slave Misc : 0x0030 */
 	/* Turnon-delay and remap configuration values for 6030 are not
 	   verified since the specification is not public */
-	TWL6030_ADJUSTABLE_LDO(VAUX1_6030, 0x54, 1000, 3300),
-	TWL6030_ADJUSTABLE_LDO(VAUX2_6030, 0x58, 1000, 3300),
-	TWL6030_ADJUSTABLE_LDO(VAUX3_6030, 0x5c, 1000, 3300),
-	TWL6030_ADJUSTABLE_LDO(VMMC, 0x68, 1000, 3300),
-	TWL6030_ADJUSTABLE_LDO(VPP, 0x6c, 1000, 3300),
-	TWL6030_ADJUSTABLE_LDO(VUSIM, 0x74, 1000, 3300),
-	TWL6030_FIXED_LDO(VANA, 0x50, 2100, 0),
-	TWL6030_FIXED_LDO(VCXIO, 0x60, 1800, 0),
-	TWL6030_FIXED_LDO(VDAC, 0x64, 1800, 0),
-	TWL6030_FIXED_LDO(VUSB, 0x70, 3300, 0),
-	TWL6030_FIXED_RESOURCE(CLK32KG, 0x8C, 0),
-	TWL6030_FIXED_RESOURCE(CLK32KAUDIO, 0x8F, 0),
-	TWL6030_ADJUSTABLE_SMPS(VDD1, 0x22, 600, 4000),
-	TWL6030_ADJUSTABLE_SMPS(VDD2, 0x28, 600, 4000),
-	TWL6030_ADJUSTABLE_SMPS(VDD3, 0x2e, 600, 4000),
-	TWL6030_ADJUSTABLE_SMPS(VMEM, 0x34, 600, 4000),
-	TWL6030_ADJUSTABLE_SMPS(V2V1, 0x1c, 1800, 2100),
-
-	/* 6032 are renamed compared to 6030 versions */
-	TWL6032_ADJUSTABLE_LDO(LDO2, 0x54, 1000, 3300),
-	TWL6032_ADJUSTABLE_LDO(LDO4, 0x58, 1000, 3300),
-	TWL6032_ADJUSTABLE_LDO(LDO3, 0x5c, 1000, 3300),
-	TWL6032_ADJUSTABLE_LDO(LDO5, 0x68, 1000, 3300),
-	TWL6032_ADJUSTABLE_LDO(LDO1, 0x6c, 1000, 3300),
-	TWL6032_ADJUSTABLE_LDO(LDO7, 0x74, 1000, 3300),
-	TWL6032_ADJUSTABLE_LDO(LDO6, 0x60, 1000, 3300),
-	TWL6032_ADJUSTABLE_LDO(LDOLN, 0x64, 1000, 3300),
-	TWL6032_ADJUSTABLE_LDO(LDOUSB, 0x70, 1000, 3300),
-
-	TWL6032_ADJUSTABLE_SMPS(SMPS3, 0x34),
-	TWL6032_ADJUSTABLE_SMPS(SMPS4, 0x10),
-	TWL6032_ADJUSTABLE_SMPS(VIO, 0x16),
-	
-	TWL6032_ADJUSTABLE_DVSSMPS(SMPS1, 0x22),
-	TWL6032_ADJUSTABLE_DVSSMPS(SMPS2, 0x28),
-	TWL6032_ADJUSTABLE_DVSSMPS(SMPS5, 0x16),
-	
-	TWL6030_EXTERNAL_CONTROL_PIN(SYSEN, 0x83, 0),
-	TWL6030_EXTERNAL_CONTROL_PIN(REGEN1, 0x7d, 0),
-
+	TWL6030_ADJUSTABLE_LDO(VAUX1_6030, 0x54, 1000, 3300, 1),
+	TWL6030_ADJUSTABLE_LDO(VAUX2_6030, 0x58, 1000, 3300, 2),
+	TWL6030_ADJUSTABLE_LDO(VAUX3_6030, 0x5c, 1000, 3300, 3),
+	TWL6030_ADJUSTABLE_LDO(VMMC, 0x68, 1000, 3300, 4),
+	TWL6030_ADJUSTABLE_LDO(VPP, 0x6c, 1000, 3300, 5),
+	TWL6030_ADJUSTABLE_LDO(VUSIM, 0x74, 1000, 3300, 7),
+	TWL6030_FIXED_LDO(VANA, 0x50, 2100, 15, 0),
+	TWL6030_FIXED_LDO(VCXIO, 0x60, 1800, 16, 0),
+	TWL6030_FIXED_LDO(VDAC, 0x64, 1800, 17, 0),
+	TWL6030_FIXED_LDO(VUSB, 0x70, 3300, 18, 0),
+	TWL6030_FIXED_RESOURCE(CLK32KG, 0x8C, 48, 0),
+
+	/* 6025 are renamed compared to 6030 versions */
+	TWL6025_ADJUSTABLE_LDO(LDO2, 0x54, 1000, 3300, 1),
+	TWL6025_ADJUSTABLE_LDO(LDO4, 0x58, 1000, 3300, 2),
+	TWL6025_ADJUSTABLE_LDO(LDO3, 0x5c, 1000, 3300, 3),
+	TWL6025_ADJUSTABLE_LDO(LDO5, 0x68, 1000, 3300, 4),
+	TWL6025_ADJUSTABLE_LDO(LDO1, 0x6c, 1000, 3300, 5),
+	TWL6025_ADJUSTABLE_LDO(LDO7, 0x74, 1000, 3300, 7),
+	TWL6025_ADJUSTABLE_LDO(LDO6, 0x60, 1000, 3300, 16),
+	TWL6025_ADJUSTABLE_LDO(LDOLN, 0x64, 1000, 3300, 17),
+	TWL6025_ADJUSTABLE_LDO(LDOUSB, 0x70, 1000, 3300, 18),
+
+	TWL6025_ADJUSTABLE_SMPS(SMPS3, 0x34, 1),
+	TWL6025_ADJUSTABLE_SMPS(SMPS4, 0x10, 2),
+	TWL6025_ADJUSTABLE_SMPS(VIO, 0x16, 3),
 };
 
 static u8 twl_get_smps_offset(void)
@@ -1285,7 +1014,6 @@ static int __devinit twlreg_probe(struct platform_device *pdev)
 	struct regulator_init_data	*initdata;
 	struct regulation_constraints	*c;
 	struct regulator_dev		*rdev;
-	int ret;
 
 	for (i = 0, info = NULL; i < ARRAY_SIZE(twl_regs); i++) {
 		if (twl_regs[i].desc.id != pdev->id)
@@ -1321,37 +1049,24 @@ static int __devinit twlreg_probe(struct platform_device *pdev)
 	case TWL4030_REG_VINTDIG:
 		c->always_on = true;
 		break;
-	case TWL6030_REG_VUSB:
-		/* Program CFG_LDO_PD2 register and set VUSB bit */
-		ret = twl_i2c_write_u8(TWL6030_MODULE_ID0, 0x1,
-				TWL6030_CFG_LDO_PD2);
-		if (ret < 0)
-			return ret;
-
-		/* Program MISC2 register and set bit VUSB_IN_VBAT */
-		ret = twl_i2c_write_u8(TWL6030_MODULE_ID0, 0x10, TWL6030_MISC2);
-		if (ret < 0)
-			return ret;
-		break;
 	default:
 		break;
 	}
 
 	switch (pdev->id) {
-	case TWL6032_REG_SMPS3:
+	case TWL6025_REG_SMPS3:
 		if (twl_get_smps_mult() & SMPS_MULTOFFSET_SMPS3)
 			info->flags |= SMPS_EXTENDED_EN;
 		if (twl_get_smps_offset() & SMPS_MULTOFFSET_SMPS3)
 			info->flags |= SMPS_OFFSET_EN;
 		break;
-	case TWL6032_REG_SMPS4:
+	case TWL6025_REG_SMPS4:
 		if (twl_get_smps_mult() & SMPS_MULTOFFSET_SMPS4)
 			info->flags |= SMPS_EXTENDED_EN;
 		if (twl_get_smps_offset() & SMPS_MULTOFFSET_SMPS4)
 			info->flags |= SMPS_OFFSET_EN;
 		break;
-	
-	case TWL6032_REG_VIO:
+	case TWL6025_REG_VIO:
 		if (twl_get_smps_mult() & SMPS_MULTOFFSET_VIO)
 			info->flags |= SMPS_EXTENDED_EN;
 		if (twl_get_smps_offset() & SMPS_MULTOFFSET_VIO)
@@ -1404,7 +1119,7 @@ static int __init twlreg_init(void)
 {
 	return platform_driver_register(&twlreg_driver);
 }
-subsys_initcall_sync(twlreg_init);
+subsys_initcall(twlreg_init);
 
 static void __exit twlreg_exit(void)
 {
diff --git a/drivers/regulator/wm831x-dcdc.c b/drivers/regulator/wm831x-dcdc.c
index c4ac471e0832..a0982e809851 100644
--- a/drivers/regulator/wm831x-dcdc.c
+++ b/drivers/regulator/wm831x-dcdc.c
@@ -27,18 +27,6 @@
 #include <linux/mfd/wm831x/regulator.h>
 #include <linux/mfd/wm831x/pdata.h>
 
-#include <linux/delay.h>
-#include <linux/time.h>
-#include <linux/timer.h>
-#include <linux/string.h>
-
-//#include "../../arch/arm/mach-rk29/include/mach/gpio.h"
-
-//#include <linux/hrtimer.h>
-
-
-
-
 #define WM831X_BUCKV_MAX_SELECTOR 0x68
 #define WM831X_BUCKP_MAX_SELECTOR 0x66
 
@@ -47,7 +35,7 @@
 #define WM831X_DCDC_MODE_IDLE    2
 #define WM831X_DCDC_MODE_STANDBY 3
 
-//#define WM831X_DCDC_MAX_NAME 6
+#define WM831X_DCDC_MAX_NAME 6
 
 /* Register offsets in control block */
 #define WM831X_DCDC_CONTROL_1     0
@@ -59,7 +47,7 @@
 /*
  * Shared
  */
-#if 0
+
 struct wm831x_dcdc {
 	char name[WM831X_DCDC_MAX_NAME];
 	struct regulator_desc desc;
@@ -71,7 +59,6 @@ struct wm831x_dcdc {
 	int on_vsel;
 	int dvs_vsel;
 };
-#endif
 
 static int wm831x_dcdc_is_enabled(struct regulator_dev *rdev)
 {
@@ -133,6 +120,7 @@ static unsigned int wm831x_dcdc_get_mode(struct regulator_dev *rdev)
 		return REGULATOR_MODE_IDLE;
 	default:
 		BUG();
+		return -EINVAL;
 	}
 }
 
@@ -313,30 +301,9 @@ static int wm831x_buckv_set_dvs(struct regulator_dev *rdev, int state)
 
 	return 0;
 }
-//wm831x_buckv_get_voltage
-
-int wm831x_reg_read(struct wm831x *wm831x, unsigned short reg);
-static int wm831x_buckv_read_voltage(struct regulator_dev *rdev)
-{
-	int vol_read;
-	int ret;
-	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
-	struct wm831x *wm831x = dcdc->wm831x;
-	int on_reg = dcdc->base + WM831X_DCDC_ON_CONFIG;
-
-	ret = wm831x_reg_read(wm831x, on_reg);
-	if (ret < 0)
-		return ret;
-	ret &= WM831X_DC1_ON_VSEL_MASK;
-	vol_read = (ret-8)*12500 + 600000;
 
-	return vol_read;
-
-
-
-}
 static int wm831x_buckv_set_voltage(struct regulator_dev *rdev,
-				    int min_uV, int max_uV)
+				    int min_uV, int max_uV, unsigned *selector)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = dcdc->wm831x;
@@ -348,6 +315,8 @@ static int wm831x_buckv_set_voltage(struct regulator_dev *rdev,
 	if (vsel < 0)
 		return vsel;
 
+	*selector = vsel;
+
 	/* If this value is already set then do a GPIO update if we can */
 	if (dcdc->dvs_gpio && dcdc->on_vsel == vsel)
 		return wm831x_buckv_set_dvs(rdev, 0);
@@ -358,10 +327,7 @@ static int wm831x_buckv_set_voltage(struct regulator_dev *rdev,
 	/* Always set the ON status to the minimum voltage */
 	ret = wm831x_set_bits(wm831x, on_reg, WM831X_DC1_ON_VSEL_MASK, vsel);
 	if (ret < 0)
-	{
-		dcdc->on_vsel = 0;
 		return ret;
-	}
 	dcdc->on_vsel = vsel;
 
 	if (!dcdc->dvs_gpio)
@@ -412,19 +378,14 @@ static int wm831x_buckv_set_suspend_voltage(struct regulator_dev *rdev,
 	return wm831x_set_bits(wm831x, reg, WM831X_DC1_SLP_VSEL_MASK, vsel);
 }
 
-static int wm831x_buckv_get_voltage(struct regulator_dev *rdev)
+static int wm831x_buckv_get_voltage_sel(struct regulator_dev *rdev)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
-	struct wm831x *wm831x = dcdc->wm831x;
-	int on_reg = dcdc->base + WM831X_DCDC_ON_CONFIG;
-	if (dcdc->on_vsel == 0){
-	dcdc->on_vsel = wm831x_reg_read(wm831x,on_reg);
-	dcdc->on_vsel = dcdc->on_vsel & WM831X_DC1_DVS_VSEL_MASK;
-	}
+
 	if (dcdc->dvs_gpio && dcdc->dvs_gpio_state)
-		return wm831x_buckv_list_voltage(rdev, dcdc->dvs_vsel);
+		return dcdc->dvs_vsel;
 	else
-		return wm831x_buckv_list_voltage(rdev, dcdc->on_vsel);
+		return dcdc->on_vsel;
 }
 
 /* Current limit options */
@@ -432,78 +393,6 @@ static u16 wm831x_dcdc_ilim[] = {
 	125, 250, 375, 500, 625, 750, 875, 1000
 };
 
-static int wm831x_buckv_set_voltage_step(struct regulator_dev * rdev, int min_uV, int max_uV, unsigned *selector)
-{
-	int old_vol;
-	int new_min_uV,new_max_uV;
-	int diff_value,step;
-	int ret=0;
-
-	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
-	struct wm831x *wm831x = dcdc->wm831x;
-	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
-
-
-	//if(strcmp(rdev->constraints->name,"DCDC2") != 0)
-	if(strcmp(pdata->dcdc[1]->consumer_supplies[1].supply,"vcore") != 0)
-	{
-
-		ret = wm831x_buckv_set_voltage(rdev,min_uV,max_uV);
-	}
-	else
-	{
-		old_vol = wm831x_buckv_read_voltage(rdev);
-
-		new_min_uV = old_vol;
-		new_max_uV = old_vol+max_uV-min_uV;
-
-		if(old_vol > min_uV) //reduce voltage
-		{
-			diff_value = (old_vol - min_uV);
-
-			for(step = 100000; step<=diff_value; step += 100000)
-			{
-				new_min_uV = old_vol-step;
-				new_max_uV = old_vol+max_uV-min_uV-step;
-
-				ret = wm831x_buckv_set_voltage(rdev,new_min_uV,new_max_uV);
-				usleep_range(1000,1000);
-			}
-
-			if(new_min_uV > min_uV) //0<  old_vol - min_uV < 100000 ||0< new_min_uV  - min_uV < 1000000
-			{
-
-				ret = wm831x_buckv_set_voltage(rdev,min_uV,max_uV);
-				usleep_range(1000,1000);
-
-			}
-
-		}
-		else                    //rise  voltage
-		{
-			diff_value = (min_uV- old_vol);
-
-			for(step = 100000; step<=diff_value; step += 100000)
-			{
-				new_min_uV = old_vol + step;
-				new_max_uV = old_vol+max_uV-min_uV+step;
-
-				ret = wm831x_buckv_set_voltage(rdev,new_min_uV,new_max_uV);
-				usleep_range(1000,1000);
-			}
-			if(new_min_uV < min_uV)//  min_uV - old_vol < 100000 || new_min_uV - old_vol < 100000
-			{
-				ret = wm831x_buckv_set_voltage(rdev,min_uV,max_uV);
-				usleep_range(1000,1000);
-			}
-
-		}
-
-	}
-	return ret;
-
-}
-
 static int wm831x_buckv_set_current_limit(struct regulator_dev *rdev,
 					   int min_uA, int max_uA)
 {
@@ -536,20 +425,9 @@ static int wm831x_buckv_get_current_limit(struct regulator_dev *rdev)
 	return wm831x_dcdc_ilim[val & WM831X_DC1_HC_THR_MASK];
 }
 
-int wm831x_dcdc_set_suspend_enable(struct regulator_dev *rdev)
-{
-
-        return 0;
-}
-int wm831x_dcdc_set_suspend_disable(struct regulator_dev *rdev)
-{
-
-        return 0;
-}
-
 static struct regulator_ops wm831x_buckv_ops = {
-	.set_voltage = wm831x_buckv_set_voltage_step,
-	.get_voltage = wm831x_buckv_get_voltage,
+	.set_voltage = wm831x_buckv_set_voltage,
+	.get_voltage_sel = wm831x_buckv_get_voltage_sel,
 	.list_voltage = wm831x_buckv_list_voltage,
 	.set_suspend_voltage = wm831x_buckv_set_suspend_voltage,
 	.set_current_limit = wm831x_buckv_set_current_limit,
@@ -562,8 +440,6 @@ static struct regulator_ops wm831x_buckv_ops = {
 	.get_mode = wm831x_dcdc_get_mode,
 	.set_mode = wm831x_dcdc_set_mode,
 	.set_suspend_mode = wm831x_dcdc_set_suspend_mode,
-	.set_suspend_enable = wm831x_dcdc_set_suspend_enable,
-	.set_suspend_disable = wm831x_dcdc_set_suspend_disable,
 };
 
 /*
@@ -689,9 +565,8 @@ static __devinit int wm831x_buckv_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_uv_irq,
-				 IRQF_TRIGGER_RISING, dcdc->name,
-				 dcdc);
+	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,
+				   IRQF_TRIGGER_RISING, dcdc->name, dcdc);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -699,9 +574,8 @@ static __devinit int wm831x_buckv_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "HC");
-	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_oc_irq,
-				 IRQF_TRIGGER_RISING, dcdc->name,
-				 dcdc);
+	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_oc_irq,
+				   IRQF_TRIGGER_RISING, dcdc->name, dcdc);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request HC IRQ %d: %d\n",
 			irq, ret);
@@ -713,7 +587,7 @@ static __devinit int wm831x_buckv_probe(struct platform_device *pdev)
 	return 0;
 
 err_uv:
-	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
+	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
 err_regulator:
 	regulator_unregister(dcdc->regulator);
 err:
@@ -726,12 +600,11 @@ static __devinit int wm831x_buckv_probe(struct platform_device *pdev)
 static __devexit int wm831x_buckv_remove(struct platform_device *pdev)
 {
 	struct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);
-	struct wm831x *wm831x = dcdc->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "HC"), dcdc);
-	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
+	free_irq(platform_get_irq_byname(pdev, "HC"), dcdc);
+	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
 	regulator_unregister(dcdc->regulator);
 	if (dcdc->dvs_gpio)
 		gpio_free(dcdc->dvs_gpio);
@@ -763,7 +636,7 @@ static int wm831x_buckp_list_voltage(struct regulator_dev *rdev,
 }
 
 static int wm831x_buckp_set_voltage_int(struct regulator_dev *rdev, int reg,
-					int min_uV, int max_uV)
+					int min_uV, int max_uV, int *selector)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = dcdc->wm831x;
@@ -777,16 +650,20 @@ static int wm831x_buckp_set_voltage_int(struct regulator_dev *rdev, int reg,
 	if (wm831x_buckp_list_voltage(rdev, vsel) > max_uV)
 		return -EINVAL;
 
+	*selector = vsel;
+
 	return wm831x_set_bits(wm831x, reg, WM831X_DC3_ON_VSEL_MASK, vsel);
 }
 
 static int wm831x_buckp_set_voltage(struct regulator_dev *rdev,
-				    int min_uV, int max_uV, unsigned *selector)
+				    int min_uV, int max_uV,
+				    unsigned *selector)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	u16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;
 
-	return wm831x_buckp_set_voltage_int(rdev, reg, min_uV, max_uV);
+	return wm831x_buckp_set_voltage_int(rdev, reg, min_uV, max_uV,
+					    selector);
 }
 
 static int wm831x_buckp_set_suspend_voltage(struct regulator_dev *rdev,
@@ -794,11 +671,12 @@ static int wm831x_buckp_set_suspend_voltage(struct regulator_dev *rdev,
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	u16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;
+	unsigned selector;
 
-	return wm831x_buckp_set_voltage_int(rdev, reg, uV, uV);
+	return wm831x_buckp_set_voltage_int(rdev, reg, uV, uV, &selector);
 }
 
-static int wm831x_buckp_get_voltage(struct regulator_dev *rdev)
+static int wm831x_buckp_get_voltage_sel(struct regulator_dev *rdev)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = dcdc->wm831x;
@@ -809,12 +687,12 @@ static int wm831x_buckp_get_voltage(struct regulator_dev *rdev)
 	if (val < 0)
 		return val;
 
-	return wm831x_buckp_list_voltage(rdev, val & WM831X_DC3_ON_VSEL_MASK);
+	return val & WM831X_DC3_ON_VSEL_MASK;
 }
 
 static struct regulator_ops wm831x_buckp_ops = {
 	.set_voltage = wm831x_buckp_set_voltage,
-	.get_voltage = wm831x_buckp_get_voltage,
+	.get_voltage_sel = wm831x_buckp_get_voltage_sel,
 	.list_voltage = wm831x_buckp_list_voltage,
 	.set_suspend_voltage = wm831x_buckp_set_suspend_voltage,
 
@@ -825,8 +703,6 @@ static struct regulator_ops wm831x_buckp_ops = {
 	.get_mode = wm831x_dcdc_get_mode,
 	.set_mode = wm831x_dcdc_set_mode,
 	.set_suspend_mode = wm831x_dcdc_set_suspend_mode,
-	.set_suspend_enable = wm831x_dcdc_set_suspend_enable,
-	.set_suspend_disable = wm831x_dcdc_set_suspend_disable,
 };
 
 static __devinit int wm831x_buckp_probe(struct platform_device *pdev)
@@ -877,9 +753,8 @@ static __devinit int wm831x_buckp_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_uv_irq,
-				 IRQF_TRIGGER_RISING, dcdc->name,
-				 dcdc);
+	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,
+				   IRQF_TRIGGER_RISING,	dcdc->name, dcdc);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -900,11 +775,10 @@ static __devinit int wm831x_buckp_probe(struct platform_device *pdev)
 static __devexit int wm831x_buckp_remove(struct platform_device *pdev)
 {
 	struct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);
-	struct wm831x *wm831x = dcdc->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
+	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
 	regulator_unregister(dcdc->regulator);
 	kfree(dcdc);
 
@@ -1006,9 +880,9 @@ static __devinit int wm831x_boostp_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_uv_irq,
-				 IRQF_TRIGGER_RISING, dcdc->name,
-				 dcdc);
+	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,
+				   IRQF_TRIGGER_RISING, dcdc->name,
+				   dcdc);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -1029,11 +903,10 @@ static __devinit int wm831x_boostp_probe(struct platform_device *pdev)
 static __devexit int wm831x_boostp_remove(struct platform_device *pdev)
 {
 	struct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);
-	struct wm831x *wm831x = dcdc->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
+	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
 	regulator_unregister(dcdc->regulator);
 	kfree(dcdc);
 
@@ -1138,7 +1011,6 @@ static struct platform_driver wm831x_epe_driver = {
 static int __init wm831x_dcdc_init(void)
 {
 	int ret;
-	printk("%s \n", __FUNCTION__);
 	ret = platform_driver_register(&wm831x_buckv_driver);
 	if (ret != 0)
 		pr_err("Failed to register WM831x BUCKV driver: %d\n", ret);
diff --git a/drivers/regulator/wm831x-isink.c b/drivers/regulator/wm831x-isink.c
index e754528100f8..01f27c7f4236 100644
--- a/drivers/regulator/wm831x-isink.c
+++ b/drivers/regulator/wm831x-isink.c
@@ -25,9 +25,8 @@
 #include <linux/mfd/wm831x/regulator.h>
 #include <linux/mfd/wm831x/pdata.h>
 
-//#define WM831X_ISINK_MAX_NAME 7
+#define WM831X_ISINK_MAX_NAME 7
 
-#if 0
 struct wm831x_isink {
 	char name[WM831X_ISINK_MAX_NAME];
 	struct regulator_desc desc;
@@ -35,14 +34,13 @@ struct wm831x_isink {
 	struct wm831x *wm831x;
 	struct regulator_dev *regulator;
 };
-#endif
 
 static int wm831x_isink_enable(struct regulator_dev *rdev)
 {
 	struct wm831x_isink *isink = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = isink->wm831x;
 	int ret;
-	printk("%s:line=%d\n",__FUNCTION__,__LINE__);
+
 	/* We have a two stage enable: first start the ISINK... */
 	ret = wm831x_set_bits(wm831x, isink->reg, WM831X_CS1_ENA,
 			      WM831X_CS1_ENA);
@@ -54,7 +52,7 @@ static int wm831x_isink_enable(struct regulator_dev *rdev)
 			      WM831X_CS1_DRIVE);
 	if (ret != 0)
 		wm831x_set_bits(wm831x, isink->reg, WM831X_CS1_ENA, 0);
-	printk("%s:line=%d,ret=0x%x\n",__FUNCTION__,__LINE__,ret);
+
 	return ret;
 
 }
@@ -64,7 +62,7 @@ static int wm831x_isink_disable(struct regulator_dev *rdev)
 	struct wm831x_isink *isink = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = isink->wm831x;
 	int ret;
-	printk("%s:line=%d\n",__FUNCTION__,__LINE__);
+
 	ret = wm831x_set_bits(wm831x, isink->reg, WM831X_CS1_DRIVE, 0);
 	if (ret < 0)
 		return ret;
@@ -82,11 +80,11 @@ static int wm831x_isink_is_enabled(struct regulator_dev *rdev)
 	struct wm831x_isink *isink = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = isink->wm831x;
 	int ret;
-	printk("%s:line=%d\n",__FUNCTION__,__LINE__);
+
 	ret = wm831x_reg_read(wm831x, isink->reg);
 	if (ret < 0)
 		return ret;
-	
+
 	if ((ret & (WM831X_CS1_ENA | WM831X_CS1_DRIVE)) ==
 	    (WM831X_CS1_ENA | WM831X_CS1_DRIVE))
 		return 1;
@@ -160,7 +158,7 @@ static __devinit int wm831x_isink_probe(struct platform_device *pdev)
 	int ret, irq;
 
 	dev_dbg(&pdev->dev, "Probing ISINK%d\n", id + 1);
-	printk("%s:line=%d\n",__FUNCTION__,__LINE__);
+
 	if (pdata == NULL || pdata->isink[id] == NULL)
 		return -ENODEV;
 
@@ -200,10 +198,8 @@ static __devinit int wm831x_isink_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq(pdev, 0);
-	printk("%s:line=%d,irq=%d\n",__FUNCTION__,__LINE__,irq);
-	ret = wm831x_request_irq(wm831x, irq, wm831x_isink_irq,
-				 IRQF_TRIGGER_RISING, isink->name,
-				 isink);
+	ret = request_threaded_irq(irq, NULL, wm831x_isink_irq,
+				   IRQF_TRIGGER_RISING, isink->name, isink);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request ISINK IRQ %d: %d\n",
 			irq, ret);
@@ -224,11 +220,10 @@ static __devinit int wm831x_isink_probe(struct platform_device *pdev)
 static __devexit int wm831x_isink_remove(struct platform_device *pdev)
 {
 	struct wm831x_isink *isink = platform_get_drvdata(pdev);
-	struct wm831x *wm831x = isink->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	wm831x_free_irq(wm831x, platform_get_irq(pdev, 0), isink);
+	free_irq(platform_get_irq(pdev, 0), isink);
 
 	regulator_unregister(isink->regulator);
 	kfree(isink);
diff --git a/drivers/regulator/wm831x-ldo.c b/drivers/regulator/wm831x-ldo.c
index aff55c8e08b0..2220cf8defb1 100644
--- a/drivers/regulator/wm831x-ldo.c
+++ b/drivers/regulator/wm831x-ldo.c
@@ -25,7 +25,7 @@
 #include <linux/mfd/wm831x/regulator.h>
 #include <linux/mfd/wm831x/pdata.h>
 
-//#define WM831X_LDO_MAX_NAME 6
+#define WM831X_LDO_MAX_NAME 6
 
 #define WM831X_LDO_CONTROL       0
 #define WM831X_LDO_ON_CONTROL    1
@@ -34,7 +34,6 @@
 #define WM831X_ALIVE_LDO_ON_CONTROL    0
 #define WM831X_ALIVE_LDO_SLEEP_CONTROL 1
 
-#if 0
 struct wm831x_ldo {
 	char name[WM831X_LDO_MAX_NAME];
 	struct regulator_desc desc;
@@ -42,12 +41,11 @@ struct wm831x_ldo {
 	struct wm831x *wm831x;
 	struct regulator_dev *regulator;
 };
-#endif
 
 /*
  * Shared
  */
-extern int reboot_cmd_get(void);
+
 static int wm831x_ldo_is_enabled(struct regulator_dev *rdev)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
@@ -70,7 +68,7 @@ static int wm831x_ldo_enable(struct regulator_dev *rdev)
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
 	int mask = 1 << rdev_get_id(rdev);
-	//printk("%s,%x\n", __FUNCTION__,mask);
+
 	return wm831x_set_bits(wm831x, WM831X_LDO_ENABLE, mask, mask);
 }
 
@@ -79,7 +77,7 @@ static int wm831x_ldo_disable(struct regulator_dev *rdev)
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
 	int mask = 1 << rdev_get_id(rdev);
-	//printk("%s\n", __FUNCTION__);
+
 	return wm831x_set_bits(wm831x, WM831X_LDO_ENABLE, mask, 0);
 }
 
@@ -115,7 +113,8 @@ static int wm831x_gp_ldo_list_voltage(struct regulator_dev *rdev,
 }
 
 static int wm831x_gp_ldo_set_voltage_int(struct regulator_dev *rdev, int reg,
-					 int min_uV, int max_uV)
+					 int min_uV, int max_uV,
+					 unsigned *selector)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -135,16 +134,20 @@ static int wm831x_gp_ldo_set_voltage_int(struct regulator_dev *rdev, int reg,
 	if (ret < min_uV || ret > max_uV)
 		return -EINVAL;
 
+	*selector = vsel;
+
 	return wm831x_set_bits(wm831x, reg, WM831X_LDO1_ON_VSEL_MASK, vsel);
 }
 
 static int wm831x_gp_ldo_set_voltage(struct regulator_dev *rdev,
-				     int min_uV, int max_uV, unsigned *selector)
+				     int min_uV, int max_uV,
+				     unsigned *selector)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_LDO_ON_CONTROL;
-	//printk("%s base=%x,%d,%d\n", __FUNCTION__,ldo->base,min_uV,max_uV);
-	return wm831x_gp_ldo_set_voltage_int(rdev, reg, min_uV, max_uV);
+
+	return wm831x_gp_ldo_set_voltage_int(rdev, reg, min_uV, max_uV,
+					     selector);
 }
 
 static int wm831x_gp_ldo_set_suspend_voltage(struct regulator_dev *rdev,
@@ -152,11 +155,12 @@ static int wm831x_gp_ldo_set_suspend_voltage(struct regulator_dev *rdev,
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_LDO_SLEEP_CONTROL;
+	unsigned int selector;
 
-	return wm831x_gp_ldo_set_voltage_int(rdev, reg, uV, uV);
+	return wm831x_gp_ldo_set_voltage_int(rdev, reg, uV, uV, &selector);
 }
 
-static int wm831x_gp_ldo_get_voltage(struct regulator_dev *rdev)
+static int wm831x_gp_ldo_get_voltage_sel(struct regulator_dev *rdev)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -166,10 +170,10 @@ static int wm831x_gp_ldo_get_voltage(struct regulator_dev *rdev)
 	ret = wm831x_reg_read(wm831x, reg);
 	if (ret < 0)
 		return ret;
-	//printk("%s base=%x,ret=%x\n", __FUNCTION__,ldo->base,ret);
+
 	ret &= WM831X_LDO1_ON_VSEL_MASK;
 
-	return wm831x_gp_ldo_list_voltage(rdev, ret);
+	return ret;
 }
 
 static unsigned int wm831x_gp_ldo_get_mode(struct regulator_dev *rdev)
@@ -206,7 +210,7 @@ static int wm831x_gp_ldo_set_mode(struct regulator_dev *rdev,
 	int on_reg = ldo->base + WM831X_LDO_ON_CONTROL;
 	int ret;
 
-//	printk("%s base=%x,mode=%x\n", __FUNCTION__,ldo->base,mode);
+
 	switch (mode) {
 	case REGULATOR_MODE_NORMAL:
 		ret = wm831x_set_bits(wm831x, on_reg,
@@ -286,20 +290,10 @@ static unsigned int wm831x_gp_ldo_get_optimum_mode(struct regulator_dev *rdev,
 	return REGULATOR_MODE_NORMAL;
 }
 
-int wm831x_ldo_set_suspend_enable(struct regulator_dev *rdev)
-{
-
-        return 0;
-}
-int wm831x_ldo_set_suspend_disable(struct regulator_dev *rdev)
-{
-
-        return 0;
-}
 
 static struct regulator_ops wm831x_gp_ldo_ops = {
 	.list_voltage = wm831x_gp_ldo_list_voltage,
-	.get_voltage = wm831x_gp_ldo_get_voltage,
+	.get_voltage_sel = wm831x_gp_ldo_get_voltage_sel,
 	.set_voltage = wm831x_gp_ldo_set_voltage,
 	.set_suspend_voltage = wm831x_gp_ldo_set_suspend_voltage,
 	.get_mode = wm831x_gp_ldo_get_mode,
@@ -310,8 +304,6 @@ static struct regulator_ops wm831x_gp_ldo_ops = {
 	.is_enabled = wm831x_ldo_is_enabled,
 	.enable = wm831x_ldo_enable,
 	.disable = wm831x_ldo_disable,
-	.set_suspend_enable = wm831x_ldo_set_suspend_enable,
-	.set_suspend_disable = wm831x_ldo_set_suspend_disable,
 };
 
 static __devinit int wm831x_gp_ldo_probe(struct platform_device *pdev)
@@ -324,7 +316,7 @@ static __devinit int wm831x_gp_ldo_probe(struct platform_device *pdev)
 	int ret, irq;
 
 	dev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);
-//	printk("Probing LDO%d\n", id + 1);
+
 	if (pdata == NULL || pdata->ldo[id] == NULL)
 		return -ENODEV;
 
@@ -362,9 +354,9 @@ static __devinit int wm831x_gp_ldo_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = wm831x_request_irq(wm831x, irq, wm831x_ldo_uv_irq,
-				 IRQF_TRIGGER_RISING, ldo->name,
-				 ldo);
+	ret = request_threaded_irq(irq, NULL, wm831x_ldo_uv_irq,
+				   IRQF_TRIGGER_RISING, ldo->name,
+				   ldo);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -385,11 +377,10 @@ static __devinit int wm831x_gp_ldo_probe(struct platform_device *pdev)
 static __devexit int wm831x_gp_ldo_remove(struct platform_device *pdev)
 {
 	struct wm831x_ldo *ldo = platform_get_drvdata(pdev);
-	struct wm831x *wm831x = ldo->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), ldo);
+	free_irq(platform_get_irq_byname(pdev, "UV"), ldo);
 	regulator_unregister(ldo->regulator);
 	kfree(ldo);
 
@@ -427,7 +418,8 @@ static int wm831x_aldo_list_voltage(struct regulator_dev *rdev,
 }
 
 static int wm831x_aldo_set_voltage_int(struct regulator_dev *rdev, int reg,
-					 int min_uV, int max_uV)
+				       int min_uV, int max_uV,
+				       unsigned *selector)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -447,16 +439,19 @@ static int wm831x_aldo_set_voltage_int(struct regulator_dev *rdev, int reg,
 	if (ret < min_uV || ret > max_uV)
 		return -EINVAL;
 
+	*selector = vsel;
+
 	return wm831x_set_bits(wm831x, reg, WM831X_LDO7_ON_VSEL_MASK, vsel);
 }
 
 static int wm831x_aldo_set_voltage(struct regulator_dev *rdev,
-				     int min_uV, int max_uV, unsigned *selector)
+				   int min_uV, int max_uV, unsigned *selector)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_LDO_ON_CONTROL;
-	//printk("%s base=%x,min_uV=%d,%d\n", __FUNCTION__,ldo->base,min_uV,max_uV);
-	return wm831x_aldo_set_voltage_int(rdev, reg, min_uV, max_uV);
+
+	return wm831x_aldo_set_voltage_int(rdev, reg, min_uV, max_uV,
+					   selector);
 }
 
 static int wm831x_aldo_set_suspend_voltage(struct regulator_dev *rdev,
@@ -464,11 +459,12 @@ static int wm831x_aldo_set_suspend_voltage(struct regulator_dev *rdev,
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_LDO_SLEEP_CONTROL;
+	unsigned int selector;
 
-	return wm831x_aldo_set_voltage_int(rdev, reg, uV, uV);
+	return wm831x_aldo_set_voltage_int(rdev, reg, uV, uV, &selector);
 }
 
-static int wm831x_aldo_get_voltage(struct regulator_dev *rdev)
+static int wm831x_aldo_get_voltage_sel(struct regulator_dev *rdev)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -478,10 +474,10 @@ static int wm831x_aldo_get_voltage(struct regulator_dev *rdev)
 	ret = wm831x_reg_read(wm831x, reg);
 	if (ret < 0)
 		return ret;
-	printk("%s base=%x,ret=%x\n", __FUNCTION__,ldo->base,ret);
+
 	ret &= WM831X_LDO7_ON_VSEL_MASK;
 
-	return wm831x_aldo_list_voltage(rdev, ret);
+	return ret;
 }
 
 static unsigned int wm831x_aldo_get_mode(struct regulator_dev *rdev)
@@ -562,7 +558,7 @@ static int wm831x_aldo_get_status(struct regulator_dev *rdev)
 
 static struct regulator_ops wm831x_aldo_ops = {
 	.list_voltage = wm831x_aldo_list_voltage,
-	.get_voltage = wm831x_aldo_get_voltage,
+	.get_voltage_sel = wm831x_aldo_get_voltage_sel,
 	.set_voltage = wm831x_aldo_set_voltage,
 	.set_suspend_voltage = wm831x_aldo_set_suspend_voltage,
 	.get_mode = wm831x_aldo_get_mode,
@@ -572,8 +568,6 @@ static struct regulator_ops wm831x_aldo_ops = {
 	.is_enabled = wm831x_ldo_is_enabled,
 	.enable = wm831x_ldo_enable,
 	.disable = wm831x_ldo_disable,
-	.set_suspend_enable = wm831x_ldo_set_suspend_enable,
-	.set_suspend_disable = wm831x_ldo_set_suspend_disable,
 };
 
 static __devinit int wm831x_aldo_probe(struct platform_device *pdev)
@@ -586,7 +580,7 @@ static __devinit int wm831x_aldo_probe(struct platform_device *pdev)
 	int ret, irq;
 
 	dev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);
-//	printk("Probing LDO%d--\n", id + 1);
+
 	if (pdata == NULL || pdata->ldo[id] == NULL)
 		return -ENODEV;
 
@@ -624,9 +618,8 @@ static __devinit int wm831x_aldo_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = wm831x_request_irq(wm831x, irq, wm831x_ldo_uv_irq,
-				 IRQF_TRIGGER_RISING, ldo->name,
-				 ldo);
+	ret = request_threaded_irq(irq, NULL, wm831x_ldo_uv_irq,
+				   IRQF_TRIGGER_RISING, ldo->name, ldo);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -647,9 +640,8 @@ static __devinit int wm831x_aldo_probe(struct platform_device *pdev)
 static __devexit int wm831x_aldo_remove(struct platform_device *pdev)
 {
 	struct wm831x_ldo *ldo = platform_get_drvdata(pdev);
-	struct wm831x *wm831x = ldo->wm831x;
 
-	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), ldo);
+	free_irq(platform_get_irq_byname(pdev, "UV"), ldo);
 	regulator_unregister(ldo->regulator);
 	kfree(ldo);
 
@@ -682,7 +674,8 @@ static int wm831x_alive_ldo_list_voltage(struct regulator_dev *rdev,
 
 static int wm831x_alive_ldo_set_voltage_int(struct regulator_dev *rdev,
 					    int reg,
-					    int min_uV, int max_uV)
+					    int min_uV, int max_uV,
+					    unsigned *selector)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -696,16 +689,20 @@ static int wm831x_alive_ldo_set_voltage_int(struct regulator_dev *rdev,
 	if (ret < min_uV || ret > max_uV)
 		return -EINVAL;
 
+	*selector = vsel;
+
 	return wm831x_set_bits(wm831x, reg, WM831X_LDO11_ON_VSEL_MASK, vsel);
 }
 
 static int wm831x_alive_ldo_set_voltage(struct regulator_dev *rdev,
-				     int min_uV, int max_uV, unsigned *selector)
+					int min_uV, int max_uV,
+					unsigned *selector)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_ALIVE_LDO_ON_CONTROL;
 
-	return wm831x_alive_ldo_set_voltage_int(rdev, reg, min_uV, max_uV);
+	return wm831x_alive_ldo_set_voltage_int(rdev, reg, min_uV, max_uV,
+						selector);
 }
 
 static int wm831x_alive_ldo_set_suspend_voltage(struct regulator_dev *rdev,
@@ -713,11 +710,12 @@ static int wm831x_alive_ldo_set_suspend_voltage(struct regulator_dev *rdev,
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_ALIVE_LDO_SLEEP_CONTROL;
+	unsigned selector;
 
-	return wm831x_alive_ldo_set_voltage_int(rdev, reg, uV, uV);
+	return wm831x_alive_ldo_set_voltage_int(rdev, reg, uV, uV, &selector);
 }
 
-static int wm831x_alive_ldo_get_voltage(struct regulator_dev *rdev)
+static int wm831x_alive_ldo_get_voltage_sel(struct regulator_dev *rdev)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -730,7 +728,7 @@ static int wm831x_alive_ldo_get_voltage(struct regulator_dev *rdev)
 
 	ret &= WM831X_LDO11_ON_VSEL_MASK;
 
-	return wm831x_alive_ldo_list_voltage(rdev, ret);
+	return ret;
 }
 
 static int wm831x_alive_ldo_get_status(struct regulator_dev *rdev)
@@ -752,7 +750,7 @@ static int wm831x_alive_ldo_get_status(struct regulator_dev *rdev)
 
 static struct regulator_ops wm831x_alive_ldo_ops = {
 	.list_voltage = wm831x_alive_ldo_list_voltage,
-	.get_voltage = wm831x_alive_ldo_get_voltage,
+	.get_voltage_sel = wm831x_alive_ldo_get_voltage_sel,
 	.set_voltage = wm831x_alive_ldo_set_voltage,
 	.set_suspend_voltage = wm831x_alive_ldo_set_suspend_voltage,
 	.get_status = wm831x_alive_ldo_get_status,
@@ -760,8 +758,6 @@ static struct regulator_ops wm831x_alive_ldo_ops = {
 	.is_enabled = wm831x_ldo_is_enabled,
 	.enable = wm831x_ldo_enable,
 	.disable = wm831x_ldo_disable,
-	.set_suspend_enable = wm831x_ldo_set_suspend_enable,
-	.set_suspend_disable = wm831x_ldo_set_suspend_disable,
 };
 
 static __devinit int wm831x_alive_ldo_probe(struct platform_device *pdev)
@@ -774,7 +770,7 @@ static __devinit int wm831x_alive_ldo_probe(struct platform_device *pdev)
 	int ret;
 
 	dev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);
-//	printk("wm831x_alive_ldo_probe Probing LDO%d\n", id + 1);
+
 	if (pdata == NULL || pdata->ldo[id] == NULL)
 		return -ENODEV;
 
@@ -830,63 +826,9 @@ static __devexit int wm831x_alive_ldo_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static __devexit void wm831x_alive_ldo_shutdown(struct platform_device *pdev)	/*ZMF*/
-{
-	//struct wm831x_ldo *ldo = platform_get_drvdata(pdev);
-#if 0
-	//close ldo in wm831x_last_deinit()
-	struct regulator* ldo;
-
-	//if (reboot_cmd_get())
-	//	return 0;
-	printk("%s\n", __FUNCTION__);
-
-	ldo = regulator_get(NULL, "ldo1");
-	regulator_disable(ldo);			
-	regulator_put(ldo);
-	
-	ldo = regulator_get(NULL, "ldo2");
-	regulator_disable(ldo);			
-	regulator_put(ldo);
-	
-	ldo = regulator_get(NULL, "ldo3");
-	regulator_disable(ldo);			
-	regulator_put(ldo);
-	
-	ldo = regulator_get(NULL, "ldo4");
-	//regulator_disable(ldo);	
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo5");
-	regulator_disable(ldo);			
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo6");
-	regulator_disable(ldo);			
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo7");
-	regulator_disable(ldo);			
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo8");
-	//regulator_disable(ldo);			
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo9");
-	regulator_disable(ldo);			
-	regulator_put(ldo);
-
-	ldo = regulator_get(NULL, "ldo10");
-	regulator_disable(ldo);						
-	regulator_put(ldo);
-#endif
-}
-
 static struct platform_driver wm831x_alive_ldo_driver = {
 	.probe = wm831x_alive_ldo_probe,
 	.remove = __devexit_p(wm831x_alive_ldo_remove),
-	.shutdown = __devexit_p(wm831x_alive_ldo_shutdown),
 	.driver		= {
 		.name	= "wm831x-alive-ldo",
 		.owner	= THIS_MODULE,
@@ -896,7 +838,7 @@ static struct platform_driver wm831x_alive_ldo_driver = {
 static int __init wm831x_ldo_init(void)
 {
 	int ret;
-	printk("%s \n", __FUNCTION__);	
+
 	ret = platform_driver_register(&wm831x_gp_ldo_driver);
 	if (ret != 0)
 		pr_err("Failed to register WM831x GP LDO driver: %d\n", ret);
@@ -909,7 +851,8 @@ static int __init wm831x_ldo_init(void)
 	if (ret != 0)
 		pr_err("Failed to register WM831x alive LDO driver: %d\n",
 		       ret);
-    return 0;
+
+	return 0;
 }
 subsys_initcall(wm831x_ldo_init);
 
diff --git a/drivers/regulator/wm8994-regulator.c b/drivers/regulator/wm8994-regulator.c
index 348bfa844439..35b2958d5106 100644
--- a/drivers/regulator/wm8994-regulator.c
+++ b/drivers/regulator/wm8994-regulator.c
@@ -21,13 +21,10 @@
 #include <linux/gpio.h>
 #include <linux/slab.h>
 
-#include <linux/delay.h>
 #include <linux/mfd/wm8994/core.h>
 #include <linux/mfd/wm8994/registers.h>
 #include <linux/mfd/wm8994/pdata.h>
 
-#include <mach/iomux.h>
-
 struct wm8994_ldo {
 	int enable;
 	bool is_enabled;
@@ -238,13 +235,9 @@ static __devinit int wm8994_ldo_probe(struct platform_device *pdev)
 	}
 
 	ldo->wm8994 = wm8994;
-	
-	if(pdata->ldo[id].iomux_name != NULL)
-		rk29_mux_api_set(pdata->ldo[id].iomux_name, pdata->ldo[id].iomux_mode);
-	
+
 	if (pdata->ldo[id].enable && gpio_is_valid(pdata->ldo[id].enable)) {
 		ldo->enable = pdata->ldo[id].enable;
-		ldo->is_enabled = true;
 
 		ret = gpio_request(ldo->enable, "WM8994 LDO enable");
 		if (ret < 0) {
@@ -259,7 +252,6 @@ static __devinit int wm8994_ldo_probe(struct platform_device *pdev)
 				ret);
 			goto err_gpio;
 		}
-		msleep(50);
 	} else
 		ldo->is_enabled = true;
 
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index bf69ac4bdb81..27c37743e2c9 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -123,14 +123,6 @@ config RTC_INTF_ALARM_DEV
 	help
 	  Exports the alarm interface to user-space.
 
-config AUTO_WAKE_UP
-	tristate "Support auto wake up"
-	depends on RTC_INTF_ALARM_DEV
-
-config AUTO_WAKE_UP_PERIOD
-	int "auto wake up period(sec)"
-	depends on AUTO_WAKE_UP
-	default 3600
 
 config RTC_DRV_TEST
 	tristate "Test driver/device"
@@ -161,21 +153,6 @@ config RTC_DRV_88PM860X
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-88pm860x.
 
-config RTC_HYM8563
-        tristate "RK2818 or RK29 extern HYM8563 RTC"
-	depends on I2C_RK2818 || I2C_RK29 || I2C_RK30
-        help
-          If you say yes here you will get support for the
-          HYM8563 I2C RTC chip.
-          This driver can also be built as a module. If so, the module
-          will be called rtc-HYM8563.
-
-config RTC_M41T66
-	tristate "ST M41T66"
-	depends on I2C_RK2818 || I2C_RK29
-	help
-	  If you say Y here you will get support for the ST M41T66.
-
 config RTC_DRV_DS1307
 	tristate "Dallas/Maxim DS1307/37/38/39/40, ST M41T00, EPSON RX-8025"
 	help
@@ -374,16 +351,6 @@ config RTC_DRV_S35390A
 	  This driver can also be built as a module. If so the module
 	  will be called rtc-s35390a.
 
-config RTC_DRV_S35392A
-	tristate "Seiko Instruments S-35392A"
-	select BITREVERSE
-	help
-	  If you say yes here you will get support for the Seiko
-	  Instruments S-35392A.
-
-	  This driver can also be built as a module. If so the module
-	  will be called rtc-s35392a.
-
 config RTC_DRV_FM3130
 	tristate "Ramtron FM3130"
 	help
@@ -1110,26 +1077,5 @@ config RTC_DRV_PUV3
 
 	  This drive can also be built as a module. If so, the module
 	  will be called rtc-puv3.
-config  TPS65910_RTC
-	tristate "tps65910 rtc for rk"
-	depends on MFD_TPS65910
-	help
-		enable tps65910 rtc for system
-
-config  RK808_RTC
-	tristate "rk808 rtc for rk"
-	depends on MFD_RK808
-	help
-		enable rk808 rtc for system
-		
-config RTC_DRV_RC5T619
-	tristate "RICOH RC5T619 PMU RTC driver"
-	depends on MFD_RICOH619
-	default n
-	help
-	  If you say yes here you get support for the RICOH RC5T619 RTC module.
-
-	  This driver can also be built as a module. If so, the module
-	  will be called rtc-rc5t619.
 
 endif # RTC_CLASS
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 936824da423b..7d2795810431 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -15,8 +15,6 @@ rtc-core-$(CONFIG_RTC_INTF_DEV)	+= rtc-dev.o
 rtc-core-$(CONFIG_RTC_INTF_PROC) += rtc-proc.o
 rtc-core-$(CONFIG_RTC_INTF_SYSFS) += rtc-sysfs.o
 
-obj-$(CONFIG_AUTO_WAKE_UP) += auto-wake.o
-
 # Keep the list ordered.
 
 obj-$(CONFIG_RTC_DRV_88PM860X)  += rtc-88pm860x.o
@@ -93,7 +91,6 @@ obj-$(CONFIG_RTC_DRV_RV3029C2)	+= rtc-rv3029c2.o
 obj-$(CONFIG_RTC_DRV_RX8025)	+= rtc-rx8025.o
 obj-$(CONFIG_RTC_DRV_RX8581)	+= rtc-rx8581.o
 obj-$(CONFIG_RTC_DRV_S35390A)	+= rtc-s35390a.o
-obj-$(CONFIG_RTC_DRV_S35392A)	+= rtc-s35392a.o
 obj-$(CONFIG_RTC_DRV_S3C)	+= rtc-s3c.o
 obj-$(CONFIG_RTC_DRV_SA1100)	+= rtc-sa1100.o
 obj-$(CONFIG_RTC_DRV_SH)	+= rtc-sh.o
@@ -113,8 +110,3 @@ obj-$(CONFIG_RTC_DRV_VT8500)	+= rtc-vt8500.o
 obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
-obj-$(CONFIG_RTC_HYM8563)	+= rtc-HYM8563.o
-obj-$(CONFIG_RTC_M41T66)	+= rtc-m41t66.o
-obj-$(CONFIG_TPS65910_RTC)  += rtc-tps65910.o
-obj-$(CONFIG_RK808_RTC)  += rtc-rk808.o
-obj-$(CONFIG_RTC_DRV_RC5T619)	+= rtc-ricoh619.o
diff --git a/drivers/rtc/alarm.c b/drivers/rtc/alarm.c
index 3ad91d9e4299..28b0df836a30 100644
--- a/drivers/rtc/alarm.c
+++ b/drivers/rtc/alarm.c
@@ -423,7 +423,6 @@ static int alarm_suspend(struct platform_device *pdev, pm_message_t state)
 		if (rtc_current_time + 1 >= rtc_alarm_time) {
 			pr_alarm(SUSPEND, "alarm about to go off\n");
 			memset(&rtc_alarm, 0, sizeof(rtc_alarm));
-			rtc_time_to_tm(0, &rtc_alarm.time);
 			rtc_alarm.enabled = 0;
 			rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
 
@@ -449,7 +448,6 @@ static int alarm_resume(struct platform_device *pdev)
 	pr_alarm(SUSPEND, "alarm_resume(%p)\n", pdev);
 
 	memset(&alarm, 0, sizeof(alarm));
-	rtc_time_to_tm(0, &alarm.time);
 	alarm.enabled = 0;
 	rtc_set_alarm(alarm_rtc_dev, &alarm);
 
@@ -463,13 +461,6 @@ static int alarm_resume(struct platform_device *pdev)
 	return 0;
 }
 
-static void alarm_shutdown(struct platform_device *pdev)
-{
-	pr_alarm(FLOW, "alarm_shutdown(%p)\n", pdev);
-
-	rtc_alarm_irq_enable(alarm_rtc_dev, false);
-}
-
 static struct rtc_task alarm_rtc_task = {
 	.func = alarm_triggered_func
 };
@@ -529,7 +520,6 @@ static struct class_interface rtc_alarm_interface = {
 static struct platform_driver alarm_driver = {
 	.suspend = alarm_suspend,
 	.resume = alarm_resume,
-	.shutdown = alarm_shutdown,
 	.driver = {
 		.name = "alarm"
 	}
diff --git a/drivers/rtc/rtc-test.c b/drivers/rtc/rtc-test.c
index b31ce9f4b0ed..7e96254bd365 100644
--- a/drivers/rtc/rtc-test.c
+++ b/drivers/rtc/rtc-test.c
@@ -30,9 +30,7 @@ static int test_rtc_set_alarm(struct device *dev,
 static int test_rtc_read_time(struct device *dev,
 	struct rtc_time *tm)
 {
-	unsigned long time = 0xffffff;
-	rtc_time_to_tm(time, tm);
-	//rtc_time_to_tm(get_seconds(), tm);
+	rtc_time_to_tm(get_seconds(), tm);
 	return 0;
 }
 
diff --git a/drivers/rtc/rtc-tps65910.c b/drivers/rtc/rtc-tps65910.c
deleted file mode 100755
index 50eba3a7db48..000000000000
--- a/drivers/rtc/rtc-tps65910.c
+++ /dev/null
@@ -1,774 +0,0 @@
-/*
- *	Real Time Clock driver for Wolfson Microelectronics tps65910
- *
- *	Copyright (C) 2009 Wolfson Microelectronics PLC.
- *
- *  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/time.h>
-#include <linux/rtc.h>
-#include <linux/slab.h>
-#include <linux/bcd.h>
-#include <linux/interrupt.h>
-#include <linux/ioctl.h>
-#include <linux/completion.h>
-#include <linux/mfd/tps65910.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/miscdevice.h>
-
-
-/* RTC Definitions */
-/* RTC_CTRL_REG bitfields */
-#define BIT_RTC_CTRL_REG_STOP_RTC_M		0x01
-#define BIT_RTC_CTRL_REG_ROUND_30S_M		0x02
-#define BIT_RTC_CTRL_REG_AUTO_COMP_M		0x04
-#define BIT_RTC_CTRL_REG_MODE_12_24_M		0x08
-#define BIT_RTC_CTRL_REG_TEST_MODE_M		0x10
-#define BIT_RTC_CTRL_REG_SET_32_COUNTER_M	0x20
-#define BIT_RTC_CTRL_REG_GET_TIME_M		0x40
-#define BIT_RTC_CTRL_REG_RTC_V_OPT_M		0x80
-
-/* RTC_STATUS_REG bitfields */
-#define BIT_RTC_STATUS_REG_RUN_M		0x02
-#define BIT_RTC_STATUS_REG_1S_EVENT_M		0x04
-#define BIT_RTC_STATUS_REG_1M_EVENT_M		0x08
-#define BIT_RTC_STATUS_REG_1H_EVENT_M		0x10
-#define BIT_RTC_STATUS_REG_1D_EVENT_M		0x20
-#define BIT_RTC_STATUS_REG_ALARM_M		0x40
-#define BIT_RTC_STATUS_REG_POWER_UP_M		0x80
-
-/* RTC_INTERRUPTS_REG bitfields */
-#define BIT_RTC_INTERRUPTS_REG_EVERY_M		0x03
-#define BIT_RTC_INTERRUPTS_REG_IT_TIMER_M	0x04
-#define BIT_RTC_INTERRUPTS_REG_IT_ALARM_M	0x08
-
-/* DEVCTRL bitfields */
-#define BIT_RTC_PWDN				0x40
-
-/* REG_SECONDS_REG through REG_YEARS_REG is how many registers? */
-#define ALL_TIME_REGS				7
-#define ALL_ALM_REGS				6
-
-
-#define RTC_SET_TIME_RETRIES	5
-#define RTC_GET_TIME_RETRIES	5
-
-
-struct tps65910_rtc {
-	struct tps65910 *tps65910;
-	struct rtc_device *rtc;
-	unsigned int alarm_enabled:1;
-};
-
-/*
- * Read current time and date in RTC
- */
-static int tps65910_rtc_readtime(struct device *dev, struct rtc_time *tm)
-{
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(dev);
-	struct tps65910 *tps65910 = tps65910_rtc->tps65910;
-	int ret;
-	int count = 0;
-	unsigned char rtc_data[ALL_TIME_REGS + 1];
-	u8 rtc_ctl;
-
-	/*Dummy read*/	
-	ret = tps65910_reg_read(tps65910, TPS65910_RTC_CTRL);
-	
-	/* Has the RTC been programmed? */
-	ret = tps65910_reg_read(tps65910, TPS65910_RTC_CTRL);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-
-	rtc_ctl = ret & (~BIT_RTC_CTRL_REG_RTC_V_OPT_M);
-
-	ret = tps65910_reg_write(tps65910, TPS65910_RTC_CTRL, rtc_ctl);
-	if (ret < 0) {
-		dev_err(dev, "Failed to write RTC control: %d\n", ret);
-		return ret;
-	}
-
-	
-	/* Read twice to make sure we don't read a corrupt, partially
-	 * incremented, value.
-	 */
-	do {
-		ret = tps65910_bulk_read(tps65910, TPS65910_SECONDS,
-				       ALL_TIME_REGS, rtc_data);
-		if (ret != 0)
-			continue;
-
-		tm->tm_sec = bcd2bin(rtc_data[0]);
-		tm->tm_min = bcd2bin(rtc_data[1]);
-		tm->tm_hour = bcd2bin(rtc_data[2]);
-		tm->tm_mday = bcd2bin(rtc_data[3]);
-		tm->tm_mon = bcd2bin(rtc_data[4]) - 1;
-		tm->tm_year = bcd2bin(rtc_data[5]) + 100;	
-		tm->tm_wday = bcd2bin(rtc_data[6]);
-
-		dev_dbg(dev, "RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-			1900 + tm->tm_year, tm->tm_mon + 1, tm->tm_mday, tm->tm_wday,
-			tm->tm_hour, tm->tm_min, tm->tm_sec);
-		
-		return ret;
-
-	} while (++count < RTC_GET_TIME_RETRIES);
-	dev_err(dev, "Timed out reading current time\n");
-
-	return -EIO;
-
-}
-
-/*
- * Set current time and date in RTC
- */
-static int tps65910_rtc_set_time(struct device *dev, struct rtc_time *tm)
-{
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(dev);
-	struct tps65910 *tps65910 = tps65910_rtc->tps65910;
-	int ret;
-	u8 rtc_ctl;	
-	unsigned char rtc_data[ALL_TIME_REGS + 1];
-	
-	rtc_data[0] = bin2bcd(tm->tm_sec);
-	rtc_data[1] = bin2bcd(tm->tm_min);
-	rtc_data[2] = bin2bcd(tm->tm_hour);
-	rtc_data[3] = bin2bcd(tm->tm_mday);
-	rtc_data[4] = bin2bcd(tm->tm_mon + 1);
-	rtc_data[5] = bin2bcd(tm->tm_year - 100);
-	rtc_data[6] = bin2bcd(tm->tm_wday);
-
-	/*Dummy read*/	
-	ret = tps65910_reg_read(tps65910, TPS65910_RTC_CTRL);
-	
-	/* Stop RTC while updating the TC registers */
-	ret = tps65910_reg_read(tps65910, TPS65910_RTC_CTRL);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-	
-	rtc_ctl = ret & (~BIT_RTC_CTRL_REG_STOP_RTC_M);
-
-	ret = tps65910_reg_write(tps65910, TPS65910_RTC_CTRL, rtc_ctl);
-	if (ret < 0) {
-		dev_err(dev, "Failed to write RTC control: %d\n", ret);
-		return ret;
-	}
-	
-	/* update all the time registers in one shot */
-	ret = tps65910_bulk_write(tps65910, TPS65910_SECONDS,
-				       ALL_TIME_REGS, rtc_data);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC times: %d\n", ret);
-		return ret;
-	}
-	
-	/*Dummy read*/	
-	ret = tps65910_reg_read(tps65910, TPS65910_RTC_CTRL);
-	
-	/* Start RTC again */
-	ret = tps65910_reg_read(tps65910, TPS65910_RTC_CTRL);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-	
-	rtc_ctl = ret | BIT_RTC_CTRL_REG_STOP_RTC_M;
-
-	ret = tps65910_reg_write(tps65910, TPS65910_RTC_CTRL, rtc_ctl);
-	if (ret < 0) {
-		dev_err(dev, "Failed to write RTC control: %d\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-/*
- * Read alarm time and date in RTC
- */
-static int tps65910_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
-{
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(dev);
-	int ret;
-	unsigned char alrm_data[ALL_ALM_REGS + 1];
-
-	ret = tps65910_bulk_read(tps65910_rtc->tps65910, TPS65910_ALARM_SECONDS,
-			       ALL_ALM_REGS, alrm_data);
-	if (ret != 0) {
-		dev_err(dev, "Failed to read alarm time: %d\n", ret);
-		return ret;
-	}
-
-	/* some of these fields may be wildcard/"match all" */
-	alrm->time.tm_sec = bcd2bin(alrm_data[0]);
-	alrm->time.tm_min = bcd2bin(alrm_data[1]);
-	alrm->time.tm_hour = bcd2bin(alrm_data[2]);
-	alrm->time.tm_mday = bcd2bin(alrm_data[3]);
-	alrm->time.tm_mon = bcd2bin(alrm_data[4]) - 1;
-	alrm->time.tm_year = bcd2bin(alrm_data[5]) + 100;
-
-	ret = tps65910_reg_read(tps65910_rtc->tps65910, TPS65910_RTC_INTERRUPTS);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-
-	if (ret & BIT_RTC_INTERRUPTS_REG_IT_ALARM_M)
-		alrm->enabled = 1;
-	else
-		alrm->enabled = 0;
-
-	return 0;
-}
-
-static int tps65910_rtc_stop_alarm(struct tps65910_rtc *tps65910_rtc)
-{
-	tps65910_rtc->alarm_enabled = 0;
-
-	return tps65910_clear_bits(tps65910_rtc->tps65910, TPS65910_RTC_INTERRUPTS,
-			       BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
-
-}
-
-static int tps65910_rtc_start_alarm(struct tps65910_rtc *tps65910_rtc)
-{
-	tps65910_rtc->alarm_enabled = 1;
-
-	return tps65910_set_bits(tps65910_rtc->tps65910, TPS65910_RTC_INTERRUPTS,
-			       BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
-
-}
-
-static int tps65910_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
-{
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(dev);
-	int ret;
-	unsigned char alrm_data[ALL_TIME_REGS + 1];
-
-	ret = tps65910_rtc_stop_alarm(tps65910_rtc);
-	if (ret < 0) {
-		dev_err(dev, "Failed to stop alarm: %d\n", ret);
-		return ret;
-	}
-
-	alrm_data[0] = bin2bcd(alrm->time.tm_sec);
-	alrm_data[1] = bin2bcd(alrm->time.tm_min);
-	alrm_data[2] = bin2bcd(alrm->time.tm_hour);
-	alrm_data[3] = bin2bcd(alrm->time.tm_mday);
-	alrm_data[4] = bin2bcd(alrm->time.tm_mon + 1);
-	alrm_data[5] = bin2bcd(alrm->time.tm_year - 100);
-
-	ret = tps65910_bulk_write(tps65910_rtc->tps65910, TPS65910_ALARM_SECONDS,
-			       ALL_ALM_REGS, alrm_data);
-	if (ret != 0) {
-		dev_err(dev, "Failed to read alarm time: %d\n", ret);
-		return ret;
-	}
-
-	if (alrm->enabled) {
-		ret = tps65910_rtc_start_alarm(tps65910_rtc);
-		if (ret < 0) {
-			dev_err(dev, "Failed to start alarm: %d\n", ret);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int tps65910_rtc_alarm_irq_enable(struct device *dev,
-				       unsigned int enabled)
-{
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(dev);
-
-	if (enabled)
-		return tps65910_rtc_start_alarm(tps65910_rtc);
-	else
-		return tps65910_rtc_stop_alarm(tps65910_rtc);
-}
-
-static int tps65910_rtc_update_irq_enable(struct device *dev,
-				       unsigned int enabled)
-{
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(dev);
-
-	if (enabled)
-		return tps65910_set_bits(tps65910_rtc->tps65910, TPS65910_RTC_INTERRUPTS,
-			       BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
-	else
-		return tps65910_clear_bits(tps65910_rtc->tps65910, TPS65910_RTC_INTERRUPTS,
-			       BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
-}
-
-/*
- * We will just handle setting the frequency and make use the framework for
- * reading the periodic interupts.
- *
- * @freq: Current periodic IRQ freq:
- * bit 0: every second
- * bit 1: every minute
- * bit 2: every hour
- * bit 3: every day
- */
-static int tps65910_rtc_irq_set_freq(struct device *dev, int freq)
-{	
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(dev);
-	int ret;	
-	u8 rtc_ctl;	
-	
-	if (freq < 0 || freq > 3)
-		return -EINVAL;
-
-	ret = tps65910_reg_read(tps65910_rtc->tps65910, TPS65910_RTC_INTERRUPTS);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC interrupt: %d\n", ret);
-		return ret;
-	}
-	
-	rtc_ctl = ret | freq;
-	
-	ret = tps65910_reg_write(tps65910_rtc->tps65910, TPS65910_RTC_INTERRUPTS, rtc_ctl);
-	if (ret < 0) {
-		dev_err(dev, "Failed to write RTC control: %d\n", ret);
-		return ret;
-	}
-	
-	return ret;
-}
-
-static irqreturn_t tps65910_alm_irq(int irq, void *data)
-{
-	struct tps65910_rtc *tps65910_rtc = data;
-	int ret;
-	u8 rtc_ctl;
-
-	/*Dummy read -- mandatory for status register*/
-	ret = tps65910_reg_read(tps65910_rtc->tps65910, TPS65910_RTC_STATUS);
-	if (ret < 0) {
-		printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-		return ret;
-	}
-		
-	ret = tps65910_reg_read(tps65910_rtc->tps65910, TPS65910_RTC_STATUS);
-	if (ret < 0) {
-		printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-		return ret;
-	}
-	rtc_ctl = ret&0xff;
-
-	//The alarm interrupt keeps its low level, until the micro-controller write 1 in the ALARM bit of the RTC_STATUS_REG register.	
-	ret = tps65910_reg_write(tps65910_rtc->tps65910, TPS65910_RTC_STATUS,rtc_ctl);
-	if (ret < 0) {
-		printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-		return ret;
-	}
-	
-	rtc_update_irq(tps65910_rtc->rtc, 1, RTC_IRQF | RTC_AF);
-	
-	printk("%s:irq=%d,rtc_ctl=0x%x\n",__func__,irq,rtc_ctl);
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t tps65910_per_irq(int irq, void *data)
-{
-	struct tps65910_rtc *tps65910_rtc = data;
-	
-	rtc_update_irq(tps65910_rtc->rtc, 1, RTC_IRQF | RTC_UF);
-
-	//printk("%s:irq=%d\n",__func__,irq);
-	return IRQ_HANDLED;
-}
-
-static const struct rtc_class_ops tps65910_rtc_ops = {
-	.read_time = tps65910_rtc_readtime,
-	//.set_mmss = tps65910_rtc_set_mmss,
-	.set_time = tps65910_rtc_set_time,
-	.read_alarm = tps65910_rtc_readalarm,
-	.set_alarm = tps65910_rtc_setalarm,
-	.alarm_irq_enable = tps65910_rtc_alarm_irq_enable,
-	//.update_irq_enable = tps65910_rtc_update_irq_enable,
-	//.irq_set_freq = tps65910_rtc_irq_set_freq,
-};
-
-#ifdef CONFIG_PM
-/* Turn off the alarm if it should not be a wake source. */
-static int tps65910_rtc_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(&pdev->dev);
-	int ret;
-	
-	if (tps65910_rtc->alarm_enabled && device_may_wakeup(&pdev->dev))
-		ret = tps65910_rtc_start_alarm(tps65910_rtc);
-	else
-		ret = tps65910_rtc_stop_alarm(tps65910_rtc);
-
-	if (ret != 0)
-		dev_err(&pdev->dev, "Failed to update RTC alarm: %d\n", ret);
-
-	return 0;
-}
-
-/* Enable the alarm if it should be enabled (in case it was disabled to
- * prevent use as a wake source).
- */
-static int tps65910_rtc_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(&pdev->dev);
-	int ret;
-
-	if (tps65910_rtc->alarm_enabled) {
-		ret = tps65910_rtc_start_alarm(tps65910_rtc);
-		if (ret != 0)
-			dev_err(&pdev->dev,
-				"Failed to restart RTC alarm: %d\n", ret);
-	}
-
-	return 0;
-}
-
-/* Unconditionally disable the alarm */
-static int tps65910_rtc_freeze(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct tps65910_rtc *tps65910_rtc = dev_get_drvdata(&pdev->dev);
-	int ret;
-	
-	ret = tps65910_rtc_stop_alarm(tps65910_rtc);
-	if (ret != 0)
-		dev_err(&pdev->dev, "Failed to stop RTC alarm: %d\n", ret);
-
-	return 0;
-}
-#else
-#define tps65910_rtc_suspend NULL
-#define tps65910_rtc_resume NULL
-#define tps65910_rtc_freeze NULL
-#endif
-
-struct platform_device *g_pdev;
-static int tps65910_rtc_probe(struct platform_device *pdev)
-{
-	struct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);
-	struct tps65910_rtc *tps65910_rtc;
-	int per_irq;
-	int alm_irq;
-	int ret = 0;
-	u8 rtc_ctl;
-	
-	struct rtc_time tm;
-	struct rtc_time tm_def = {	//	2012.1.1 12:00:00 Saturday
-			.tm_wday = 6,
-			.tm_year = 111,
-			.tm_mon = 0,
-			.tm_mday = 1,
-			.tm_hour = 12,
-			.tm_min = 0,
-			.tm_sec = 0,
-		};
-	
-	tps65910_rtc = kzalloc(sizeof(*tps65910_rtc), GFP_KERNEL);
-	if (tps65910_rtc == NULL)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, tps65910_rtc);
-	tps65910_rtc->tps65910 = tps65910;
-	per_irq = tps65910->irq_base + TPS65910_IRQ_RTC_PERIOD;
-	alm_irq = tps65910->irq_base + TPS65910_IRQ_RTC_ALARM;
-	
-	/* Take rtc out of reset */
-	ret = tps65910_reg_read(tps65910, TPS65910_DEVCTRL);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Failed to read TPS65910_DEVCTRL: %d\n", ret);
-		return ret;
-	}
-
-	if(ret & BIT_RTC_PWDN)
-	{
-		rtc_ctl = ret & (~BIT_RTC_PWDN);
-
-		ret = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, rtc_ctl);
-		if (ret < 0) {
-			dev_err(&pdev->dev, "Failed to write RTC control: %d\n", ret);
-			return ret;
-		}
-	}
-	
-	/*start rtc default*/
-	ret = tps65910_reg_read(tps65910, TPS65910_RTC_CTRL);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-
-	if(!(ret & BIT_RTC_CTRL_REG_STOP_RTC_M))
-	{
-		rtc_ctl = ret | BIT_RTC_CTRL_REG_STOP_RTC_M;
-
-		ret = tps65910_reg_write(tps65910, TPS65910_RTC_CTRL, rtc_ctl);
-		if (ret < 0) {
-			dev_err(&pdev->dev, "Failed to write RTC control: %d\n", ret);
-			return ret;
-		}
-	}
-	
-	ret = tps65910_reg_read(tps65910, TPS65910_RTC_STATUS);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Failed to read RTC status: %d\n", ret);
-		return ret;
-	}
-		
-	/*set init time*/
-	ret = tps65910_rtc_readtime(&pdev->dev, &tm);
-	if (ret)
-	{
-		dev_err(&pdev->dev, "Failed to read RTC time\n");
-		return ret;
-	}
-	
-	ret = rtc_valid_tm(&tm);
-	if (ret) {
-		dev_err(&pdev->dev,"invalid date/time and init time\n");
-		tps65910_rtc_set_time(&pdev->dev, &tm_def); // 2011-01-01 12:00:00
-		dev_info(&pdev->dev, "set RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-				1900 + tm_def.tm_year, tm_def.tm_mon + 1, tm_def.tm_mday, tm_def.tm_wday,
-				tm_def.tm_hour, tm_def.tm_min, tm_def.tm_sec);
-	}
-
-	device_init_wakeup(&pdev->dev, 1);
-
-	tps65910_rtc->rtc = rtc_device_register("tps65910", &pdev->dev,
-					      &tps65910_rtc_ops, THIS_MODULE);
-	if (IS_ERR(tps65910_rtc->rtc)) {
-		ret = PTR_ERR(tps65910_rtc->rtc);
-		goto err;
-	}
-
-	/*request rtc and alarm irq of tps65910*/
-	ret = request_threaded_irq(per_irq, NULL, tps65910_per_irq,
-				   IRQF_TRIGGER_RISING, "RTC period",
-				   tps65910_rtc);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "Failed to request periodic IRQ %d: %d\n",
-			per_irq, ret);
-	}
-
-	ret = request_threaded_irq(alm_irq, NULL, tps65910_alm_irq,
-				   IRQF_TRIGGER_RISING, "RTC alarm",
-				   tps65910_rtc);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "Failed to request alarm IRQ %d: %d\n",
-			alm_irq, ret);
-	}
-
-	//for rtc irq test
-	//tps65910_set_bits(tps65910_rtc->tps65910, TPS65910_RTC_INTERRUPTS,
-	//			       BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
-
-	enable_irq_wake(alm_irq); // so tps65910 alarm irq can wake up system
-	g_pdev = pdev;
-	
-	printk("%s:ok\n",__func__);
-	
-	return 0;
-
-err:
-	kfree(tps65910_rtc);
-	return ret;
-}
-
-static int __devexit tps65910_rtc_remove(struct platform_device *pdev)
-{
-	struct tps65910_rtc *tps65910_rtc = platform_get_drvdata(pdev);
-	int per_irq = tps65910_rtc->tps65910->irq_base + TPS65910_IRQ_RTC_PERIOD;
-	int alm_irq = tps65910_rtc->tps65910->irq_base + TPS65910_IRQ_RTC_ALARM;
-
-	free_irq(alm_irq, tps65910_rtc);
-	free_irq(per_irq, tps65910_rtc);
-	rtc_device_unregister(tps65910_rtc->rtc);
-	kfree(tps65910_rtc);
-
-	return 0;
-}
-
-static const struct dev_pm_ops tps65910_rtc_pm_ops = {
-	.suspend = tps65910_rtc_suspend,
-	.resume = tps65910_rtc_resume,
-
-	.freeze = tps65910_rtc_freeze,
-	.thaw = tps65910_rtc_resume,
-	.restore = tps65910_rtc_resume,
-
-	.poweroff = tps65910_rtc_suspend,
-};
-
-static struct platform_driver tps65910_rtc_driver = {
-	.probe = tps65910_rtc_probe,
-	.remove = __devexit_p(tps65910_rtc_remove),
-	.driver = {
-		.name = "tps65910-rtc",
-		.pm = &tps65910_rtc_pm_ops,
-	},
-};
-
-static ssize_t rtc_tps65910_test_write(struct file *file, 
-			const char __user *buf, size_t count, loff_t *offset)
-{
-	char nr_buf[8];
-	int nr = 0, ret;
-	struct platform_device *pdev;	
-	struct rtc_time tm;
-	struct rtc_wkalrm alrm;
-	struct tps65910_rtc *tps65910_rtc;
-	
-	if(count > 3)
-		return -EFAULT;
-	ret = copy_from_user(nr_buf, buf, count);
-	if(ret < 0)
-		return -EFAULT;
-
-	sscanf(nr_buf, "%d", &nr);
-	if(nr > 5 || nr < 0)
-	{
-		printk("%s:data is error\n",__func__);
-		return -EFAULT;
-	}
-
-	if(!g_pdev)
-		return -EFAULT;
-	else
-		pdev = g_pdev;
-
-	
-	tps65910_rtc = dev_get_drvdata(&pdev->dev);
-	
-	//test rtc time
-	if(nr == 0)
-	{	
-		tm.tm_wday = 6;
-		tm.tm_year = 111;
-		tm.tm_mon = 0;
-		tm.tm_mday = 1;
-		tm.tm_hour = 12;
-		tm.tm_min = 0;
-		tm.tm_sec = 0;
-	
-		ret = tps65910_rtc_set_time(&pdev->dev, &tm); // 2011-01-01 12:00:00
-		if (ret)
-		{
-			dev_err(&pdev->dev, "Failed to set RTC time\n");
-			return -EFAULT;
-		}
-
-	}
-	
-	/*set init time*/
-	ret = tps65910_rtc_readtime(&pdev->dev, &tm);
-	if (ret)
-		dev_err(&pdev->dev, "Failed to read RTC time\n");
-	else
-		dev_info(&pdev->dev, "RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-			1900 + tm.tm_year, tm.tm_mon + 1, tm.tm_mday, tm.tm_wday,
-			tm.tm_hour, tm.tm_min, tm.tm_sec);
-		
-	if(!ret)
-	printk("%s:ok\n",__func__);
-	else
-	printk("%s:error\n",__func__);
-	
-
-	//test rtc alarm
-	if(nr == 2)
-	{
-		//2000-01-01 00:00:30
-		if(tm.tm_sec < 30)
-		{
-			alrm.time.tm_sec = tm.tm_sec+30;	
-			alrm.time.tm_min = tm.tm_min;
-		}
-		else
-		{
-			alrm.time.tm_sec = tm.tm_sec-30;
-			alrm.time.tm_min = tm.tm_min+1;
-		}
-		alrm.time.tm_hour = tm.tm_hour;
-		alrm.time.tm_mday = tm.tm_mday;
-		alrm.time.tm_mon = tm.tm_mon;
-		alrm.time.tm_year = tm.tm_year;		
-		tps65910_rtc_alarm_irq_enable(&pdev->dev, 1);
-		tps65910_rtc_setalarm(&pdev->dev, &alrm);
-
-		dev_info(&pdev->dev, "Set alarm %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-				1900 + alrm.time.tm_year, alrm.time.tm_mon + 1, alrm.time.tm_mday, alrm.time.tm_wday,
-				alrm.time.tm_hour, alrm.time.tm_min, alrm.time.tm_sec);
-	}
-
-	
-	if(nr == 3)
-	{	
-		ret = tps65910_reg_read(tps65910_rtc->tps65910, TPS65910_RTC_STATUS);
-		if (ret < 0) {
-			printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-			return ret;
-		}
-		printk("%s:ret=0x%x\n",__func__,ret&0xff);
-
-		ret = tps65910_reg_write(tps65910_rtc->tps65910, TPS65910_RTC_STATUS, ret&0xff);
-		if (ret < 0) {
-			printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-			return ret;
-		}
-	}
-
-	if(nr == 4)
-	tps65910_rtc_update_irq_enable(&pdev->dev, 1);
-
-	if(nr == 5)
-	tps65910_rtc_update_irq_enable(&pdev->dev, 0);
-	
-	return count;
-}
-
-static const struct file_operations rtc_tps65910_test_fops = {
-	.write = rtc_tps65910_test_write,
-};
-
-static struct miscdevice rtc_tps65910_test_misc = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "rtc_tps65910_test",
-	.fops = &rtc_tps65910_test_fops,
-};
-
-
-static int __init tps65910_rtc_init(void)
-{
-	misc_register(&rtc_tps65910_test_misc);
-	return platform_driver_register(&tps65910_rtc_driver);
-}
-subsys_initcall_sync(tps65910_rtc_init);
-
-static void __exit tps65910_rtc_exit(void)
-{	
-        misc_deregister(&rtc_tps65910_test_misc);
-	platform_driver_unregister(&tps65910_rtc_driver);
-}
-module_exit(tps65910_rtc_exit);
-
-MODULE_DESCRIPTION("RTC driver for the tps65910 series PMICs");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:tps65910-rtc");
diff --git a/drivers/rtc/rtc-twl.c b/drivers/rtc/rtc-twl.c
index 135087efe0eb..5e4e725440ac 100644
--- a/drivers/rtc/rtc-twl.c
+++ b/drivers/rtc/rtc-twl.c
@@ -362,6 +362,14 @@ static irqreturn_t twl_rtc_interrupt(int irq, void *rtc)
 	int res;
 	u8 rd_reg;
 
+#ifdef CONFIG_LOCKDEP
+	/* WORKAROUND for lockdep forcing IRQF_DISABLED on us, which
+	 * we don't want and can't tolerate.  Although it might be
+	 * friendlier not to borrow this thread context...
+	 */
+	local_irq_enable();
+#endif
+
 	res = twl_rtc_read_u8(&rd_reg, REG_RTC_STATUS_REG);
 	if (res)
 		goto out;
@@ -420,12 +428,24 @@ static struct rtc_class_ops twl_rtc_ops = {
 static int __devinit twl_rtc_probe(struct platform_device *pdev)
 {
 	struct rtc_device *rtc;
-	int ret = -EINVAL;
+	int ret = 0;
 	int irq = platform_get_irq(pdev, 0);
 	u8 rd_reg;
-	printk("+++ twl_rtc_probe +++\n");
+
 	if (irq <= 0)
-		goto out1;
+		return -EINVAL;
+
+	rtc = rtc_device_register(pdev->name,
+				  &pdev->dev, &twl_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		ret = PTR_ERR(rtc);
+		dev_err(&pdev->dev, "can't register RTC device, err %ld\n",
+			PTR_ERR(rtc));
+		goto out0;
+
+	}
+
+	platform_set_drvdata(pdev, rtc);
 
 	ret = twl_rtc_read_u8(&rd_reg, REG_RTC_STATUS_REG);
 	if (ret < 0)
@@ -442,6 +462,14 @@ static int __devinit twl_rtc_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto out1;
 
+	ret = request_irq(irq, twl_rtc_interrupt,
+				IRQF_TRIGGER_RISING,
+				dev_name(&rtc->dev), rtc);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "IRQ is not free.\n");
+		goto out1;
+	}
+
 	if (twl_class_is_6030()) {
 		twl6030_interrupt_unmask(TWL6030_RTC_INT_MASK,
 			REG_INT_MSK_LINE_A);
@@ -452,14 +480,14 @@ static int __devinit twl_rtc_probe(struct platform_device *pdev)
 	/* Check RTC module status, Enable if it is off */
 	ret = twl_rtc_read_u8(&rd_reg, REG_RTC_CTRL_REG);
 	if (ret < 0)
-		goto out1;
+		goto out2;
 
 	if (!(rd_reg & BIT_RTC_CTRL_REG_STOP_RTC_M)) {
 		dev_info(&pdev->dev, "Enabling TWL-RTC.\n");
 		rd_reg = BIT_RTC_CTRL_REG_STOP_RTC_M;
 		ret = twl_rtc_write_u8(rd_reg, REG_RTC_CTRL_REG);
 		if (ret < 0)
-			goto out1;
+			goto out2;
 	}
 
 	/* ensure interrupts are disabled, bootloaders can be strange */
@@ -470,35 +498,15 @@ static int __devinit twl_rtc_probe(struct platform_device *pdev)
 	/* init cached IRQ enable bits */
 	ret = twl_rtc_read_u8(&rtc_irq_bits, REG_RTC_INTERRUPTS_REG);
 	if (ret < 0)
-		goto out1;
-
-	rtc = rtc_device_register(pdev->name,
-				  &pdev->dev, &twl_rtc_ops, THIS_MODULE);
-	if (IS_ERR(rtc)) {
-		ret = PTR_ERR(rtc);
-		dev_err(&pdev->dev, "can't register RTC device, err %ld\n",
-			PTR_ERR(rtc));
-		goto out1;
-
-	}
-
-	ret = request_threaded_irq(irq, NULL, twl_rtc_interrupt,
-				   IRQF_TRIGGER_RISING,
-				   dev_name(&rtc->dev), rtc);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "IRQ is not free.\n");
 		goto out2;
-	}
-
-	if (enable_irq_wake(irq) < 0)
-		dev_warn(&pdev->dev, "Cannot enable wakeup for IRQ %d\n", irq);
 
-	platform_set_drvdata(pdev, rtc);
-	return 0;
+	return ret;
 
 out2:
-	rtc_device_unregister(rtc);
+	free_irq(irq, rtc);
 out1:
+	rtc_device_unregister(rtc);
+out0:
 	return ret;
 }
 
diff --git a/drivers/rtc/rtc-wm831x.c b/drivers/rtc/rtc-wm831x.c
index eed33532e8f7..f3c211099a14 100644
--- a/drivers/rtc/rtc-wm831x.c
+++ b/drivers/rtc/rtc-wm831x.c
@@ -428,9 +428,7 @@ static int wm831x_rtc_probe(struct platform_device *pdev)
 	int per_irq = platform_get_irq_byname(pdev, "PER");
 	int alm_irq = platform_get_irq_byname(pdev, "ALM");
 	int ret = 0;
-	struct rtc_time tm;
 
-	//printk("wm831x_rtc_probe\n");
 	wm831x_rtc = kzalloc(sizeof(*wm831x_rtc), GFP_KERNEL);
 	if (wm831x_rtc == NULL)
 		return -ENOMEM;
@@ -438,13 +436,6 @@ static int wm831x_rtc_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, wm831x_rtc);
 	wm831x_rtc->wm831x = wm831x;
 
-#ifdef CONFIG_ARCH_RK30
-	wm831x_reg_read(wm831x, WM831X_CLOCK_CONTROL_1);
-	wm831x_set_bits(wm831x, WM831X_SECURITY_KEY, 0x9716, 0x9716);  //0x4090h bit15 is encrypted, if this bit need modify, we must write 0x4008h as 0x9716 first.
-	wm831x_set_bits(wm831x, WM831X_CLOCK_CONTROL_1, 0x8700, 0x8100); //open the clk out
-	wm831x_reg_read(wm831x, WM831X_CLOCK_CONTROL_1);
-#endif
-
 	ret = wm831x_reg_read(wm831x, WM831X_RTC_CONTROL);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "Failed to read RTC control: %d\n", ret);
@@ -453,17 +444,6 @@ static int wm831x_rtc_probe(struct platform_device *pdev)
 	if (ret & WM831X_RTC_ALM_ENA)
 		wm831x_rtc->alarm_enabled = 1;
 
-	ret = wm831x_rtc_readtime(&pdev->dev, &tm);
-	if (ret < 0 || tm.tm_year < 111) {
-		if (ret)
-			dev_err(&pdev->dev, "Failed to read RTC time\n");
-		else
-			dev_err(&pdev->dev, "Invalid RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-				1900 + tm.tm_year, tm.tm_mon + 1, tm.tm_mday, tm.tm_wday,
-				tm.tm_hour, tm.tm_min, tm.tm_sec);
-		wm831x_rtc_set_mmss(&pdev->dev, 1293883200); // 2011-01-01 12:00:00
-	}
-
 	device_init_wakeup(&pdev->dev, 1);
 
 	wm831x_rtc->rtc = rtc_device_register("wm831x", &pdev->dev,
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index d3a60175e981..de35c3ad8a69 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -424,46 +424,6 @@ config SPI_NUC900
 # Add new SPI master controllers in alphabetical order above this line
 #
 
-config SPIM_RK29
-	tristate "RK SPI master controller core support"
-	depends on PLAT_RK && SPI_MASTER
-	help
-	  general driver for SPI controller core from RockChips 
-
-config SPIM0_RK29
-	bool "RK SPI0 master controller"
-	depends on SPIM_RK29
-	help
-	  enable SPI0 master controller for RK29 	 
-
-config SPIM1_RK29
-	bool "RK SPI1 master controller"
-	depends on SPIM_RK29 && !ARCH_RK2928 && !ARCH_RK3026
-	help
-	  enable SPI1 master controller for RK29 	
-
-config RK_SPIM_TEST
-	bool "RK SPIM test"
-
-config LCD_USE_SPIM_CONTROL
-	bool "Switch gpio to spim with spin lock"
-	depends on SPIM_RK29
-	help
-	  switch gpio that used for lcd to spim with spin lock.
-
-config LCD_USE_SPI0
-	bool "If lcd use spi0 to init lcd then select this item"
-	depends on SPIM_RK29 && LCD_USE_SPIM_CONTROL
-	help
-	  choose spi bus num to use.
-
-config LCD_USE_SPI1
-	bool "If lcd use spi1 to init lcd then select this item"
-	depends on SPIM_RK29 && LCD_USE_SPIM_CONTROL
-	default y if LCD_USE_SPIM_CONTROL
-	help
-	  choose spi bus num to use.
-
 config SPI_DESIGNWARE
 	tristate "DesignWare SPI controller core support"
 	depends on SPI_MASTER
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 7f1a2aee8620..0f8c69b6b19e 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -13,15 +13,13 @@ obj-$(CONFIG_SPI_ALTERA)		+= spi_altera.o
 obj-$(CONFIG_SPI_ATMEL)			+= atmel_spi.o
 obj-$(CONFIG_SPI_ATH79)			+= ath79_spi.o
 obj-$(CONFIG_SPI_BFIN)			+= spi_bfin5xx.o
-obj-$(CONFIG_SPI_BFIN_SPORT)	+= spi_bfin_sport.o
+obj-$(CONFIG_SPI_BFIN_SPORT)		+= spi_bfin_sport.o
 obj-$(CONFIG_SPI_BITBANG)		+= spi_bitbang.o
 obj-$(CONFIG_SPI_AU1550)		+= au1550_spi.o
 obj-$(CONFIG_SPI_BUTTERFLY)		+= spi_butterfly.o
-obj-$(CONFIG_SPIM_RK29)		    += rk29_spim.o
-obj-$(CONFIG_RK_SPIM_TEST)		+= spi_test.o
-obj-$(CONFIG_SPI_COLDFIRE_QSPI)	+= coldfire_qspi.o
+obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= coldfire_qspi.o
 obj-$(CONFIG_SPI_DAVINCI)		+= davinci_spi.o
-obj-$(CONFIG_SPI_DESIGNWARE)	+= dw_spi.o
+obj-$(CONFIG_SPI_DESIGNWARE)		+= dw_spi.o
 obj-$(CONFIG_SPI_DW_PCI)		+= dw_spi_midpci.o
 dw_spi_midpci-objs			:= dw_spi_pci.o dw_spi_mid.o
 obj-$(CONFIG_SPI_DW_MMIO)		+= dw_spi_mmio.o
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a93551bc5b7c..b423fe92a785 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1023,7 +1023,7 @@ int spi_bus_unlock(struct spi_master *master)
 EXPORT_SYMBOL_GPL(spi_bus_unlock);
 
 /* portable code must never pass more than 32 bytes */
-#define	SPI_BUFSIZ	max(1028,SMP_CACHE_BYTES)
+#define	SPI_BUFSIZ	max(32,SMP_CACHE_BYTES)
 
 static u8	*buf;
 
@@ -1083,7 +1083,6 @@ int spi_write_then_read(struct spi_device *spi,
 	} else
 		local_buf = buf;
 
-	memset(local_buf, 0, SPI_BUFSIZ);
 	memcpy(local_buf, txbuf, n_tx);
 	x[0].tx_buf = local_buf;
 	x[1].rx_buf = local_buf + n_tx;
diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 8797bb4f082c..11a4b5b35963 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -104,9 +104,6 @@ source "drivers/staging/iio/Kconfig"
 
 source "drivers/staging/cs5535_gpio/Kconfig"
 
-#source "drivers/staging/rk29/vivante/Kconfig"
-source "drivers/staging/rk29/ipp/Kconfig"
-
 source "drivers/staging/zram/Kconfig"
 
 source "drivers/staging/zcache/Kconfig"
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index 928ee76119ad..ae62e923e1b8 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -43,8 +43,6 @@ obj-$(CONFIG_VME_BUS)		+= vme/
 obj-$(CONFIG_DX_SEP)            += sep/
 obj-$(CONFIG_IIO)		+= iio/
 obj-$(CONFIG_CS5535_GPIO)	+= cs5535_gpio/
-#obj-$(CONFIG_VIVANTE)		+= rk29/vivante/
-obj-y            		+= rk29/ipp/
 obj-$(CONFIG_ZRAM)		+= zram/
 obj-$(CONFIG_XVMALLOC)		+= zram/
 obj-$(CONFIG_ZCACHE)		+= zcache/
diff --git a/drivers/staging/android/timed_gpio.c b/drivers/staging/android/timed_gpio.c
index 4c3e8fc63099..a64481c3e86d 100644
--- a/drivers/staging/android/timed_gpio.c
+++ b/drivers/staging/android/timed_gpio.c
@@ -20,12 +20,10 @@
 #include <linux/hrtimer.h>
 #include <linux/err.h>
 #include <linux/gpio.h>
-#include <linux/wakelock.h>
-#include <linux/delay.h>
+
 #include "timed_output.h"
 #include "timed_gpio.h"
 
-#define GPIO_TYPE   0 
 
 struct timed_gpio_data {
 	struct timed_output_dev dev;
@@ -34,40 +32,14 @@ struct timed_gpio_data {
 	unsigned 	gpio;
 	int 		max_timeout;
 	u8 		active_low;
-	int             adjust_time;
-#if (GPIO_TYPE == 1)
-	struct work_struct 	timed_gpio_work;	
-#endif
-	struct wake_lock 	irq_wake;
 };
 
-#if (GPIO_TYPE == 1)
-static void timed_gpio_work_handler(struct work_struct *work)
-{
-	struct timed_gpio_data *data =
-		container_of(work, struct timed_gpio_data, timed_gpio_work);
-	int ret = 0,i = 0;
-	//set gpio several times once error happened
-	for(i=0; i<3; i++)
-	{
-		ret = gpio_direction_output(data->gpio, data->active_low ? 1 : 0);
-		if(!ret)		
-			break;
-		printk("%s:ret=%d,fail to set gpio and set again,i=%d\n",__FUNCTION__,ret,i);
-	}
-}
-#endif
-
 static enum hrtimer_restart gpio_timer_func(struct hrtimer *timer)
 {
 	struct timed_gpio_data *data =
 		container_of(timer, struct timed_gpio_data, timer);
-		
-#if (GPIO_TYPE == 0)
+
 	gpio_direction_output(data->gpio, data->active_low ? 1 : 0);
-#else	
-	schedule_work(&data->timed_gpio_work);
-#endif	
 	return HRTIMER_NORESTART;
 }
 
@@ -88,26 +60,24 @@ static void gpio_enable(struct timed_output_dev *dev, int value)
 {
 	struct timed_gpio_data	*data =
 		container_of(dev, struct timed_gpio_data, dev);
-	int ret = 0,i = 0;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&data->lock, flags);
 
 	/* cancel previous timer and set GPIO according to value */
 	hrtimer_cancel(&data->timer);
-	//set gpio several times once error happened
-	for(i=0; i<3; i++)
-	{
-		ret = gpio_direction_output(data->gpio, data->active_low ? !value : !!value);
-		if(!ret)		
-			break;
-		printk("%s:ret=%d,fail to set gpio and set again,i=%d\n",__FUNCTION__,ret,i);
-	}
+	gpio_direction_output(data->gpio, data->active_low ? !value : !!value);
+
 	if (value > 0) {
-		value += data->adjust_time;
 		if (value > data->max_timeout)
 			value = data->max_timeout;
+
 		hrtimer_start(&data->timer,
 			ktime_set(value / 1000, (value % 1000) * 1000000),
 			HRTIMER_MODE_REL);
 	}
+
+	spin_unlock_irqrestore(&data->lock, flags);
 }
 
 static int timed_gpio_probe(struct platform_device *pdev)
@@ -155,17 +125,10 @@ static int timed_gpio_probe(struct platform_device *pdev)
 		gpio_dat->gpio = cur_gpio->gpio;
 		gpio_dat->max_timeout = cur_gpio->max_timeout;
 		gpio_dat->active_low = cur_gpio->active_low;
-		gpio_dat->adjust_time = cur_gpio->adjust_time;
 		gpio_direction_output(gpio_dat->gpio, gpio_dat->active_low);
 	}
-#if (GPIO_TYPE == 1)
-    INIT_WORK(&gpio_dat->timed_gpio_work, timed_gpio_work_handler);
-#endif    
-	platform_set_drvdata(pdev, gpio_data);
-	wake_lock_init(&gpio_data->irq_wake, WAKE_LOCK_SUSPEND, "timed_gpio_wake");
 
-	gpio_enable(&gpio_data ->dev, 100);
-	printk("%s\n",__FUNCTION__);
+	platform_set_drvdata(pdev, gpio_data);
 
 	return 0;
 }
@@ -205,7 +168,7 @@ static void __exit timed_gpio_exit(void)
 	platform_driver_unregister(&timed_gpio_driver);
 }
 
-subsys_initcall(timed_gpio_init);
+module_init(timed_gpio_init);
 module_exit(timed_gpio_exit);
 
 MODULE_AUTHOR("Mike Lockwood <lockwood@android.com>");
diff --git a/drivers/staging/android/timed_gpio.h b/drivers/staging/android/timed_gpio.h
index c8487df9a109..a0e15f8be3f7 100644
--- a/drivers/staging/android/timed_gpio.h
+++ b/drivers/staging/android/timed_gpio.h
@@ -23,7 +23,6 @@ struct timed_gpio {
 	unsigned 	gpio;
 	int		max_timeout;
 	u8 		active_low;
-	int         adjust_time;
 };
 
 struct timed_gpio_platform_data {
diff --git a/drivers/staging/hv/hv_kvp.c b/drivers/staging/hv/hv_kvp.c
index 9f8efd4c5b6b..13b0ecf7d5d6 100644
--- a/drivers/staging/hv/hv_kvp.c
+++ b/drivers/staging/hv/hv_kvp.c
@@ -201,13 +201,11 @@ kvp_respond_to_host(char *key, char *value, int error)
 	 * The windows host expects the key/value pair to be encoded
 	 * in utf16.
 	 */
-	keylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,
-				(wchar_t *) kvp_data->data.key,
-				HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2);
+	keylen = utf8s_to_utf16s(key_name, strlen(key_name),
+				(wchar_t *)kvp_data->data.key);
 	kvp_data->data.key_size = 2*(keylen + 1); /* utf16 encoding */
-	valuelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,
-				(wchar_t *) kvp_data->data.value,
-				HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2);
+	valuelen = utf8s_to_utf16s(value, strlen(value),
+				(wchar_t *)kvp_data->data.value);
 	kvp_data->data.value_size = 2*(valuelen + 1); /* utf16 encoding */
 
 	kvp_data->data.value_type = REG_SZ; /* all our values are strings */
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 559b95cf55f4..9789293a8441 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1512,104 +1512,6 @@ config SERIAL_BCM63XX_CONSOLE
 	  If you have enabled the serial port on the bcm63xx CPU
 	  you can make it the console by answering Y to this option.
 
-config SERIAL_RK29
-	bool "RockChip RK29/RK30 serial port support"
-	depends on PLAT_RK
-	select SERIAL_CORE
-
-config UART0_RK29
-	bool "Serial port 0 support"
-	depends on SERIAL_RK29
-
-config UART0_CTS_RTS_RK29
-	bool "Serial port 0 CTS/RTS support"
-	depends on UART0_RK29
-
-config UART0_DMA_RK29
-	int "Serial port 0 DMA support (EXPERIMENTAL)"
-	depends on UART0_RK29
-	default 0
-	help 
-		 1:enable dma tx
-		 2:enable dma rx
-		 3:both enable dma tx and rx 
-config UART0_WAKEUP_RK29
-	bool "Serial port 0 WAKEUP support (EXPERIMENTAL)"
-	depends on UART0_RK29
-	default 0
-
-config UART1_RK29
-	bool "Serial port 1 support"
-	depends on SERIAL_RK29
-
-config UART1_CTS_RTS_RK29
-	bool "Serial port 1 CTS/RTS support"
-	depends on UART1_RK29 && !ARCH_RK29
-
-config UART1_DMA_RK29
-	int "Serial port 1 DMA support (EXPERIMENTAL)"
-	depends on UART1_RK29
-	default 0
-	help 
-		 1:enable dma tx
-	 	 2:enable dma rx
-	 	 3:both enable dma tx and rx 
-config UART1_WAKEUP_RK29
-	bool "Serial port 1 WAKEUP support (EXPERIMENTAL)"
-	depends on UART1_RK29
-
-config UART2_RK29
-	bool "Serial port 2 support"
-	depends on SERIAL_RK29
-
-config UART2_CTS_RTS_RK29
-	bool "Serial port 2 CTS/RTS support"
-	depends on UART2_RK29 && !ARCH_RK30 && !ARCH_RK3188 && !ARCH_RK319X
-
-config UART2_DMA_RK29
-	int "Serial port 2 DMA support (EXPERIMENTAL)"
-	depends on UART2_RK29
-	default 0
-	help 
-		 1:enable dma tx
-	 	 2:enable dma rx
-	 	 3:both enable dma tx and rx 
-config UART2_WAKEUP_RK29
-	bool "Serial port 2 WAKEUP support (EXPERIMENTAL)"
-	depends on UART2_RK29
-
-config UART3_RK29
-	bool "Serial port 3 support"
-	depends on SERIAL_RK29 && !ARCH_RK2928 && !ARCH_RK3026
-
-config UART3_CTS_RTS_RK29
-	bool "Serial port 3 CTS/RTS support"
-	depends on UART3_RK29
-
-config UART3_DMA_RK29
-	int "Serial port 3 DMA support (EXPERIMENTAL)"
-	depends on UART3_RK29
-	default 0
-	help 
-		 1:enable dma tx
-	 	 2:enable dma rx
-	 	 3:both enable dma tx and rx
-config UART3_WAKEUP_RK29
-	bool "Serial port 3 WAKEUP support (EXPERIMENTAL)"
-	depends on UART3_RK29
- 
-config SERIAL_RK29_CONSOLE
-	bool "Serial console support"
-	depends on SERIAL_RK29=y
-	select SERIAL_CORE_CONSOLE
-
-config SERIAL_SC8800
-	tristate "SC8800 support"
-	depends on SPI
-	select SERIAL_CORE
-	help
-	  SC8800 spi-serial support
-
 config SERIAL_GRLIB_GAISLER_APBUART
 	tristate "GRLIB APBUART serial support"
 	depends on OF && SPARC
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 4c73acffb064..cb2628fee4c7 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -83,8 +83,6 @@ obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
 obj-$(CONFIG_SERIAL_OMAP) += omap-serial.o
 obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
-obj-$(CONFIG_SERIAL_RK29) += rk_serial.o
-obj-$(CONFIG_SERIAL_SC8800) += sc8800.o
 obj-$(CONFIG_SERIAL_TIMBERDALE)	+= timbuart.o
 obj-$(CONFIG_SERIAL_GRLIB_GAISLER_APBUART) += apbuart.o
 obj-$(CONFIG_SERIAL_ALTERA_JTAGUART) += altera_jtaguart.o
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 2a1db8c6d231..2a106a94cdd0 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -2394,11 +2394,11 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)
 	 */
 	tty_dev = tty_register_device(drv->tty_driver, uport->line, uport->dev);
 	if (likely(!IS_ERR(tty_dev))) {
-		device_set_wakeup_capable(tty_dev, 1);
-	} else {
+		device_init_wakeup(tty_dev, 1);
+		device_set_wakeup_enable(tty_dev, 0);
+	} else
 		printk(KERN_ERR "Cannot register tty device on line %d\n",
 		       uport->line);
-	}
 
 	/*
 	 * Ensure UPF_DEAD is not set.
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 94852811888a..48f1781352f1 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -168,6 +168,4 @@ source "drivers/usb/gadget/Kconfig"
 
 source "drivers/usb/otg/Kconfig"
 
-source "drivers/usb/dwc_otg/Kconfig"
-
 endif # USB_SUPPORT
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index 906a9666d752..30ddf8dc4f72 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -50,5 +50,4 @@ obj-$(CONFIG_USB_SPEEDTOUCH)	+= atm/
 obj-$(CONFIG_USB_MUSB_HDRC)	+= musb/
 obj-$(CONFIG_USB_RENESAS_USBHS)	+= renesas_usbhs/
 obj-$(CONFIG_USB_OTG_UTILS)	+= otg/
-obj-$(CONFIG_DWC_OTG)		+= dwc_otg/
 obj-$(CONFIG_USB_GADGET)	+= gadget/
diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 86167b585f84..26678cadfb21 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -704,7 +704,7 @@ int usb_get_configuration(struct usb_device *dev)
 			    "descriptor/%s: %d\n", cfgno, "start", result);
 			dev_err(ddev, "chopping to %d config(s)\n", cfgno);
 			dev->descriptor.bNumConfigurations = cfgno;
-			goto err;
+			break;
 		} else if (result < 4) {
 			dev_err(ddev, "config index %d descriptor too short "
 			    "(expected %i, got %i)\n", cfgno,
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 1a1dfe5fd2b0..9d5af9bb990c 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1580,12 +1580,8 @@ void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb, int status)
 
 	/* pass ownership to the completion handler */
 	urb->status = status;
-	if(!atomic_read(&urb->use_count)){
-		printk("%s %d\n", __func__, atomic_read(&urb->use_count));
-		return;
-	}
-	atomic_dec (&urb->use_count);
 	urb->complete (urb);
+	atomic_dec (&urb->use_count);
 	if (unlikely(atomic_read(&urb->reject)))
 		wake_up (&usb_kill_urb_queue);
 	usb_put_urb (urb);
@@ -1959,7 +1955,6 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 	}
 
 	if (!hcd->driver->bus_suspend) {
-		printk("%s,error,everest\n",__func__);
 		status = -ENOENT;
 	} else {
 		clear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index e37fdcfeb7e5..be9cac6e3b9e 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1286,7 +1286,7 @@ static void hub_disconnect(struct usb_interface *intf)
 
 	kref_put(&hub->kref, hub_release);
 }
-struct usb_hub *g_root_hub20 = NULL;
+
 static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
 	struct usb_host_interface *desc;
@@ -1346,10 +1346,7 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 		dev_dbg (&intf->dev, "couldn't kmalloc hub struct\n");
 		return -ENOMEM;
 	}
-	if(!g_root_hub20)
-	{
-		g_root_hub20 = hub;
-	}
+
 	kref_init(&hub->kref);
 	INIT_LIST_HEAD(&hub->event_list);
 	hub->intfdev = &intf->dev;
@@ -1917,11 +1914,7 @@ int usb_new_device(struct usb_device *udev)
 		add_device_randomness(udev->manufacturer,
 				      strlen(udev->manufacturer));
 
-	/* kever@rk 20111205
-	 * We don't use async suspend in rk29 usb
-	 * to make sure usb1.1 host is suspend before usb 2.0 host.
-	 */
-	//device_enable_async_suspend(&udev->dev);
+	device_enable_async_suspend(&udev->dev);
 	/* Register the device.  The device driver is responsible
 	 * for configuring the device and invoking the add-device
 	 * notifier chain (used by usbfs and possibly others).
@@ -2917,17 +2910,11 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 		udev->ttport = hdev->ttport;
 	} else if (udev->speed != USB_SPEED_HIGH
 			&& hdev->speed == USB_SPEED_HIGH) {
-			
-	/* yk@rk 20110617
-	 * parent hub has no TT would not be error in rk29
-	 */
-		#if 0
 		if (!hub->tt.hub) {
 			dev_err(&udev->dev, "parent hub has no TT\n");
 			retval = -EINVAL;
 			goto fail;
 		}
-		#endif
 		udev->tt = &hub->tt;
 		udev->ttport = port1;
 	}
@@ -3661,14 +3648,6 @@ static void hub_events(void)
         } /* end while (1) */
 }
 
-/* yk@rk 20100730 
- * disconnect all devices on root hub
- */
-void hub_disconnect_device(struct usb_hub *hub)
-{
-    	hub_port_connect_change(hub, 1, 0, 0x2);
-}
-
 static int hub_thread(void *__unused)
 {
 	/* khubd needs to be freezable to avoid intefering with USB-PERSIST
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 40744b26855f..aca160e0d943 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -112,7 +112,6 @@ config	USB_GADGET_SELECTED
 choice
 	prompt "USB Peripheral Controller"
 	depends on USB_GADGET
-	default USB_GADGET_DWC_OTG
 	help
 	   A USB device uses a controller to talk to its host.
 	   Systems should have only one such upstream link.
@@ -544,19 +543,6 @@ config USB_LANGWELL
 	default USB_GADGET
 	select USB_GADGET_SELECTED
 
-config USB_GADGET_DWC_OTG
-	boolean "Synopsys DWC OTG Controller"
-	select USB_GADGET_DUALSPEED
-	help
-	  This driver provides USB Device Controller support for the
-	  Synopsys DesignWare USB OTG Core used on the Rockchip RK28.
-
-config USB_DWC_OTG
-	tristate
-	depends on USB_GADGET_DWC_OTG
-	default USB_GADGET
-	select USB_GADGET_SELECTED
-
 config USB_GADGET_EG20T
 	tristate "Intel EG20T PCH/OKI SEMICONDUCTOR IOH(ML7213/ML7831) UDC"
 	depends on PCI
@@ -656,9 +642,9 @@ config USB_GADGET_DUALSPEED
 # USB Gadget Drivers
 #
 choice
-	bool "USB Gadget Drivers"
+	tristate "USB Gadget Drivers"
 	depends on USB_GADGET && USB_GADGET_SELECTED
-	default USB_G_ANDROID
+	default USB_ETH
 	help
 	  A Linux "Gadget Driver" talks to the USB Peripheral Controller
 	  driver through the abstract "gadget" API.  Some other operating
@@ -1079,18 +1065,4 @@ config USB_G_WEBCAM
 
 endchoice
 
-config BYPASS_INPUT_TO_HIDG
-        bool "Allow send reports form HID devices to PC"
-        depends on (USB_G_ANDROID && USB_GADGET_DWC_OTG) 
-        default n 
-        help
-	  If say "y" there will create a new gadget HIDG
-	  and HID reports form HID devices will be bypass to PC 
-
-config UMS_AS_CDROM
-       bool "Set mass storage as a virtual CDROM"
-       default n
-       help
-         Set mass storage as a virtual CDROM for drivers install.
-             
 endif # USB_GADGET
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
index c9154db1a956..1236d6f593d3 100644
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -57,10 +57,6 @@
 #include "rndis.c"
 #include "u_ether.c"
 
-#ifdef CONFIG_BYPASS_INPUT_TO_HIDG
-#include "f_hid_rk.c"
-#endif
-
 MODULE_AUTHOR("Mike Lockwood");
 MODULE_DESCRIPTION("Android Composite USB Driver");
 MODULE_LICENSE("GPL");
@@ -69,8 +65,8 @@ MODULE_VERSION("1.0");
 static const char longname[] = "Gadget Android";
 
 /* Default vendor and product IDs, overridden by userspace */
-#define VENDOR_ID		0x2207//0x18D1
-#define PRODUCT_ID		0x2910
+#define VENDOR_ID		0x18D1
+#define PRODUCT_ID		0x0001
 
 struct android_usb_function {
 	char *name;
@@ -164,7 +160,6 @@ static struct usb_configuration android_config_driver = {
 	.label		= "android",
 	.unbind		= android_unbind_config,
 	.bConfigurationValue = 1,
-	.bmAttributes = USB_CONFIG_ATT_SELFPOWER | USB_CONFIG_ATT_WAKEUP ,
 };
 
 static void android_work(struct work_struct *data)
@@ -613,12 +608,6 @@ static struct device_attribute *rndis_function_attributes[] = {
 	&dev_attr_vendorID,
 	NULL
 };
-static int rndis_function_ctrlrequest(struct android_usb_function *f,
-						struct usb_composite_dev *cdev,
-						const struct usb_ctrlrequest *c)
-{
-	return rndis_setup(cdev, c);
-}
 
 static struct android_usb_function rndis_function = {
 	.name		= "rndis",
@@ -626,7 +615,6 @@ static struct android_usb_function rndis_function = {
 	.cleanup	= rndis_function_cleanup,
 	.bind_config	= rndis_function_bind_config,
 	.unbind_config	= rndis_function_unbind_config,
-	.ctrlrequest    = rndis_function_ctrlrequest,
 	.attributes	= rndis_function_attributes,
 };
 
@@ -641,30 +629,15 @@ static int mass_storage_function_init(struct android_usb_function *f,
 {
 	struct mass_storage_function_config *config;
 	struct fsg_common *common;
-	int err,i;
-	char name[6];
+	int err;
 
 	config = kzalloc(sizeof(struct mass_storage_function_config),
 								GFP_KERNEL);
 	if (!config)
 		return -ENOMEM;
-#ifdef CONFIG_UMS_AS_CDROM  
-	config->fsg.nluns = 8;
-	config->fsg.luns[0].removable = 1;
-	config->fsg.luns[0].ro = 1;
-        config->fsg.luns[0].cdrom = 1;
-	for(i=1;i<config->fsg.nluns;i++)
-	{
-		config->fsg.luns[i].removable = 1;
-		config->fsg.luns[i].nofua = 1;
-	}
-#else
-	//printk(KERN_ERR "CONFIG_UMS_AS_CDROM is false -------------------\n");
-	config->fsg.nluns = 2;
-	config->fsg.luns[0].removable = 1;
-	config->fsg.luns[1].removable = 1;
-#endif
 
+	config->fsg.nluns = 1;
+	config->fsg.luns[0].removable = 1;
 
 	common = fsg_common_init(NULL, cdev, &config->fsg);
 	if (IS_ERR(common)) {
@@ -672,20 +645,14 @@ static int mass_storage_function_init(struct android_usb_function *f,
 		return PTR_ERR(common);
 	}
 
-	err = sysfs_create_link(&f->dev->kobj, &common->luns[0].dev.kobj,"lun");
-        if (err) {
-                kfree(config);
-                return err;
-        }
-	for(i=1;i<config->fsg.nluns;i++)
-	{
-		sprintf(name,"lun%d",i);
-        	err = sysfs_create_link(&f->dev->kobj, &common->luns[i].dev.kobj,&name);
-		if (err) {
-			kfree(config);
-			return err;
-		}
+	err = sysfs_create_link(&f->dev->kobj,
+				&common->luns[0].dev.kobj,
+				"lun");
+	if (err) {
+		kfree(config);
+		return err;
 	}
+
 	config->common = common;
 	f->config = config;
 	return 0;
@@ -719,11 +686,8 @@ static ssize_t mass_storage_inquiry_store(struct device *dev,
 	struct mass_storage_function_config *config = f->config;
 	if (size >= sizeof(config->common->inquiry_string))
 		return -EINVAL;
-	//if (sscanf(buf, "%s", config->common->inquiry_string) != 1)
-	//	return -EINVAL;
-	
-	memcpy(config->common->inquiry_string,buf,sizeof config->common->inquiry_string);
-
+	if (sscanf(buf, "%s", config->common->inquiry_string) != 1)
+		return -EINVAL;
 	return size;
 }
 
@@ -839,80 +803,6 @@ static struct android_usb_function audio_source_function = {
 	.attributes	= audio_source_function_attributes,
 };
 
-#ifdef CONFIG_BYPASS_INPUT_TO_HIDG
-
-static int hidg_function_init(struct android_usb_function *f,
-			struct usb_composite_dev *cdev)
-{
-    ghid_setup(cdev->gadget, 1);
-    return 0;
-}
-
-static void hidg_function_cleanup(struct android_usb_function *f)
-{
-    ghid_cleanup();
-    return;
-}
-
-static int hidg_function_ctrlrequest(struct android_usb_function *f,
-                            struct usb_composite_dev *cdev,
-                            const struct usb_ctrlrequest *c)
-{   
-    return hidg_ctrlrequest(cdev, c);
-}
-
-static int hidg_function_bind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-    if(my_hid_data.report_desc_length)
-        hidg_bind_config(c, &my_hid_data, 0);
-    return 0;
-}
-static int hidg_function_unbind_config(struct android_usb_function *f,
-						struct usb_configuration *c)
-{
-    return 0;
-}
-static ssize_t hidg_report_descriptor_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-    return sprintf(buf, "hid report_desc_length = %d\n", my_hid_data.report_desc_length);
-}
-
-static DEVICE_ATTR(report_descriptor, S_IRUGO | S_IWUSR, hidg_report_descriptor_show, NULL);
-
-static ssize_t hidg_bypass_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf," %s \n" ,
-	    f_hid_bypass_input_get()? "Input report bypass enable" : "Input report bypass disable");
-}
-
-static ssize_t hidg_bypass_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t size)
-{
-    int bypass;
-    sscanf(buf, "%d", &bypass);
-    f_hid_bypass_input_set(bypass);
-	return size;
-}
-
-static DEVICE_ATTR(bypass_input, S_IRUGO | S_IWUSR, hidg_bypass_show, hidg_bypass_store);
-
-static struct device_attribute *hidg_function_attributes[] = 
-                {&dev_attr_bypass_input ,&dev_attr_report_descriptor ,NULL };
-
-
-static struct android_usb_function hidg_function = {
-	.name		= "hidg",
-	.init		= hidg_function_init,
-	.cleanup	= hidg_function_cleanup,
-	.bind_config	= hidg_function_bind_config,
-	.unbind_config  = hidg_function_unbind_config,
-	.ctrlrequest    = hidg_function_ctrlrequest,
-	.attributes     = hidg_function_attributes,
-};
-#endif
 static struct android_usb_function *supported_functions[] = {
 	&adb_function,
 	&acm_function,
@@ -922,12 +812,10 @@ static struct android_usb_function *supported_functions[] = {
 	&mass_storage_function,
 	&accessory_function,
 	&audio_source_function,
-#ifdef CONFIG_BYPASS_INPUT_TO_HIDG
-	&hidg_function,
-#endif
 	NULL
 };
 
+
 static int android_init_functions(struct android_usb_function **functions,
 				  struct usb_composite_dev *cdev)
 {
@@ -1336,6 +1224,7 @@ android_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *c)
 	struct android_usb_function	*f;
 	int value = -EOPNOTSUPP;
 	unsigned long flags;
+
 	req->zero = 0;
 	req->complete = composite_setup_complete;
 	req->length = 0;
@@ -1383,9 +1272,6 @@ static void android_disconnect(struct usb_gadget *gadget)
 	   so we need to inform it when we are disconnected.
 	 */
 	acc_disconnect();
-#ifdef CONFIG_BYPASS_INPUT_TO_HIDG
-    hidg_disconnect();
-#endif
 
 	spin_lock_irqsave(&cdev->lock, flags);
 	dev->connected = 0;
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 0c6101d4423c..1d88a80086a3 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -72,7 +72,7 @@ module_param(iSerialNumber, charp, 0);
 MODULE_PARM_DESC(iSerialNumber, "SerialNumber string");
 
 static char composite_manufacturer[50];
-static int gadget_connected = 0;
+
 /*-------------------------------------------------------------------------*/
 
 /**
@@ -420,9 +420,6 @@ static int set_config(struct usb_composite_dev *cdev,
 		goto done;
 
 	cdev->config = c;
-	
-	/* reset delay status to zero every time usb reconnect */
-	cdev->delayed_status = 0;
 
 	/* Initialize all interfaces by setting them to altsetting zero. */
 	for (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {
@@ -477,9 +474,6 @@ static int set_config(struct usb_composite_dev *cdev,
 
 	/* when we return, be sure our power usage is valid */
 	power = c->bMaxPower ? (2 * c->bMaxPower) : CONFIG_USB_GADGET_VBUS_DRAW;
-
-	/* usb gadget connect flag */
-	gadget_connected = 1;
 done:
 	usb_gadget_vbus_draw(gadget, power);
 
@@ -520,7 +514,6 @@ int usb_add_config(struct usb_composite_dev *cdev,
 	/* Prevent duplicate configuration identifiers */
 	list_for_each_entry(c, &cdev->configs, list) {
 		if (c->bConfigurationValue == config->bConfigurationValue) {
-			printk("usb_add_config, already configed,everest\n");
 			status = -EBUSY;
 			goto done;
 		}
@@ -1059,17 +1052,10 @@ static void composite_disconnect(struct usb_gadget *gadget)
 		reset_config(cdev);
 	if (composite->disconnect)
 		composite->disconnect(cdev);
-	/* usb gadget connect flag */
-	gadget_connected = 0;
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
 
 /*-------------------------------------------------------------------------*/
-int get_gadget_connect_flag( void )
-{
-    return gadget_connected;
-}
-EXPORT_SYMBOL(get_gadget_connect_flag);
 
 static ssize_t composite_show_suspended(struct device *dev,
 					struct device_attribute *attr,
@@ -1383,9 +1369,6 @@ void usb_composite_setup_continue(struct usb_composite_dev *cdev)
 			composite_setup_complete(cdev->gadget->ep0, req);
 		}
 	}
-	else{
-	    WARN(cdev, "%s: Unexpected delayed status 0x%x\n", __func__, cdev->delayed_status);
-	}
 
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 23e3077a9196..9b7360ff5aa7 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -94,7 +94,7 @@ ep_matches (
 				/* bulk endpoints handle interrupt transfers,
 				 * except the toggle-quirky iso-synch kind
 				 */
-				if ('n' != tmp[2])	// == "-int"
+				if ('s' == tmp[2])	// == "-iso"
 					return 0;
 				/* for now, avoid PXA "interrupt-in";
 				 * it's documented as never using DATA1.
@@ -112,10 +112,6 @@ ep_matches (
 					return 0;
 			}
 		} else {
-#ifdef CONFIG_ARCH_RK29
-    		if (USB_ENDPOINT_XFER_INT == type)
-    		    return 0;
-#endif    		    
 			tmp = ep->name + strlen (ep->name);
 		}
 
@@ -149,7 +145,6 @@ ep_matches (
 		/* INT:  limit 64 bytes full speed, 1024 high speed */
 		if (!gadget->is_dualspeed && max > 64)
 			return 0;
-		break;
 		/* FALLTHROUGH */
 
 	case USB_ENDPOINT_XFER_ISOC:
diff --git a/drivers/usb/gadget/f_accessory.c b/drivers/usb/gadget/f_accessory.c
index ee78a24d7ad5..1df88a6bf7ec 100644
--- a/drivers/usb/gadget/f_accessory.c
+++ b/drivers/usb/gadget/f_accessory.c
@@ -1090,9 +1090,7 @@ static void acc_function_disable(struct usb_function *f)
 	DBG(cdev, "acc_function_disable\n");
 	acc_set_disconnected(dev);
 	usb_ep_disable(dev->ep_in);
-	dev->ep_in->driver_data = NULL;
 	usb_ep_disable(dev->ep_out);
-	dev->ep_out->driver_data = NULL;
 
 	/* readers may be blocked waiting for us to go online */
 	wake_up(&dev->read_wq);
diff --git a/drivers/usb/gadget/f_adb.c b/drivers/usb/gadget/f_adb.c
index f79221e3fcfa..1c0166c6df21 100644
--- a/drivers/usb/gadget/f_adb.c
+++ b/drivers/usb/gadget/f_adb.c
@@ -545,9 +545,7 @@ static void adb_function_disable(struct usb_function *f)
 	dev->online = 0;
 	dev->error = 1;
 	usb_ep_disable(dev->ep_in);
-	dev->ep_in->driver_data = NULL;
 	usb_ep_disable(dev->ep_out);
-	dev->ep_out->driver_data = NULL;
 
 	/* readers may be blocked waiting for us to go online */
 	wake_up(&dev->read_wq);
@@ -559,6 +557,8 @@ static int adb_bind_config(struct usb_configuration *c)
 {
 	struct adb_dev *dev = _adb_dev;
 
+	printk(KERN_INFO "adb_bind_config\n");
+
 	dev->cdev = c->cdev;
 	dev->function.name = "adb";
 	dev->function.descriptors = fs_adb_descs;
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index eada7597c15e..bc2f62476cbc 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -298,17 +298,6 @@
 #include "gadget_chips.h"
 
 
-#ifdef CONFIG_PLAT_RK
-/* flush after every 4 meg of writes to avoid excessive block level caching */
-#define MAX_UNFLUSHED_BYTES  (64 * 1024)// (4 * 1024 * 1024) //original value is 4MB,Modifyed by xbw at 2011-08-18
-#define MAX_UNFLUSHED_PACKETS 4//16
-
-#include <linux/power_supply.h>
-#include <linux/reboot.h>
-#include <linux/syscalls.h>
-
-#endif
-
 /*------------------------------------------------------------------------*/
 
 #define FSG_DRIVER_DESC		"Mass Storage Function"
@@ -808,13 +797,6 @@ static int do_read(struct fsg_common *common)
 			amount = min(amount, (unsigned int)PAGE_CACHE_SIZE -
 					     partial_page);
 
-		/* kever@rk
-		 * max size for dwc_otg ctonroller is 64(max pkt sizt) * 1023(pkt)
-		 * because of the DOEPTSIZ.PKTCNT has only 10 bits
-		 */
-		if((common->gadget->speed != USB_SPEED_HIGH)&&(amount >0x8000))
-		    amount = 0x8000;
-
 		/* Wait for the next buffer to become available */
 		bh = common->next_buffhd_to_fill;
 		while (bh->state != BUF_STATE_EMPTY) {
@@ -993,13 +975,6 @@ static int do_write(struct fsg_common *common)
 			amount_left_to_req -= amount;
 			if (amount_left_to_req == 0)
 				get_some_more = 0;
-				
-			/* kever@rk
-			 * max size for dwc_otg ctonroller is 64(max pkt sizt) * 1023(pkt)
-			 * because of the DOEPTSIZ.PKTCNT has only 10 bits
-			 */
-			if((common->gadget->speed != USB_SPEED_HIGH)&&(amount >0x8000))
-			    amount = 0x8000;
 
 			/*
 			 * amount is always divisible by 512, hence by
@@ -1065,15 +1040,6 @@ static int do_write(struct fsg_common *common)
 			amount_left_to_write -= nwritten;
 			common->residue -= nwritten;
 
-#ifdef MAX_UNFLUSHED_PACKETS
-			curlun->unflushed_packet ++;
-			curlun->unflushed_bytes += nwritten;
-			if( (curlun->unflushed_packet >= MAX_UNFLUSHED_PACKETS) || (curlun->unflushed_bytes >= MAX_UNFLUSHED_BYTES)) {
-				fsg_lun_fsync_sub(curlun);
-				curlun->unflushed_packet = 0;
-				curlun->unflushed_bytes = 0;
-			}
-#endif
 			/* If an error occurred, report it and its position */
 			if (nwritten < amount) {
 				curlun->sense_data = SS_WRITE_ERROR;
@@ -1974,153 +1940,6 @@ static int check_command(struct fsg_common *common, int cmnd_size,
 	return 0;
 }
 
-#ifdef CONFIG_PLAT_RK
-static void deferred_restart(struct work_struct *dummy)
-{
-	sys_sync();
-	kernel_restart("loader");
-}
-static DECLARE_WORK(restart_work, deferred_restart);
-
-typedef struct tagLoaderParam
-{
-	int	tag;
-	int	length;
-	char	parameter[1];
-	int	crc;
-} PARM_INFO;
-#define PARM_TAG			0x4D524150
-#define MSC_EXT_DBG			1
-extern int  GetParamterInfo(char * pbuf , int len);
-
-/* the buf is bh->buf,it is large enough. */
-static char * get_param_tag( char* buf , const char* tag )
-{
-	PARM_INFO	*pi;
-	int 		i;
-	char		*pp = buf+256;
-	char		*spp;
-	i = GetParamterInfo( pp , 1024 );
-	pi = (PARM_INFO*)pp;
-	if( pi->tag != PARM_TAG ){
-error_out:	
-		printk("paramter error,tag=0x%x\n" , pi->tag );
-		return NULL;
-	}
-	if( pi->length+sizeof(PARM_INFO) > i ) {
-		GetParamterInfo( pp , pi->length+sizeof(PARM_INFO)  + 511 );
-	}
-	pp = strstr( pi->parameter , tag );
-	if( !pp ) goto error_out;
-	pp += strlen(tag); // sizeof "MACHINE_MODEL:"
-	while( *pp == ' ' || *pp == '\t' ) {
-		if(pp - pi->parameter >= pi->length)
-		  break;	
-		pp++;
-	}
-	spp = pp;
-	while( *pp != 0x0d && *pp != 0x0a ) {
-		if(pp - pi->parameter >= pi->length)
-		  break;
-		pp++;
-	}
-	*pp = 0;
-	if( spp == pp ) return NULL;
-	return spp;
-}
-
-static int do_get_product_name(int ret ,char *buf)
-{
-	char		*tag = "MACHINE_MODEL:";
-	char		*pname;
-	#if MSC_EXT_DBG
-	char 		tbuf[1300];
-	if( buf == NULL )   buf = tbuf;
-	#endif
-	memset( buf , 0 , ret );
-	pname = get_param_tag( buf , tag );
-	if( pname ){
-		strcpy( buf , pname);
-	} 
-	#if MSC_EXT_DBG
-	printk("%s%s\n" , tag , buf );
-	#endif
-	return ret;
-}
-
-static int do_get_versions( int ret ,char* buf )
-{
-	/* get boot version and fireware version from cmdline
-	* bootver=2010-07-08#4.02 firmware_ver=1.0.0 // Firmware Ver:16.01.0000
-	* return format: 0x02 0x04 0x00 0x00 0x00 0x01 
-	* RK29: bootver=2011-07-18#2.05 firmware_ver=0.2.3 (==00.02.0003)
-	* for the old loader,the firmware_ver may be empty,so get the fw ver from paramter.
-	*/
-#define ASC_BCD0( c )  (((c-'0'))&0xf)
-#define ASC_BCD1( c )  (((c-'0')<<4)&0xf0)
-
-	char *ver = buf;
-	char *p_l , *p_f;
-	char		*l_tag = "bootver=";
-	char		*fw_tag = "FIRMWARE_VER:";
-	
-	#if MSC_EXT_DBG
-	char 		tbuf[1300];
-	if( ver == NULL )   ver = tbuf;
-	#endif
-	
-	memset( ver , 0x00 , ret );
-	p_l = strstr( saved_command_line , l_tag );
-	if( !p_l ) {
-	        return ret;
-	} 
-	p_l+=strlen( l_tag );
-	if( (p_l = strchr( p_l,'#')) ) {
-		p_l++;
-		if( p_l[1] == '.' ) {
-		        ver[1] = ASC_BCD0(p_l[0]);
-		        p_l+=2;
-		} else {
-		        ver[1] = ASC_BCD1(p_l[0])|ASC_BCD0(p_l[1]);
-		        p_l+=3;
-		}
-		ver[0] = ASC_BCD1(p_l[0])|ASC_BCD0(p_l[1]);
-	}
-	
-	p_f = get_param_tag( ver , fw_tag );
-	if( !p_f ) return ret;
-	
-	if( p_f[1] == '.' ) {
-	        ver[5] = ASC_BCD0(p_f[0]);
-	        p_f+=2;
-	} else {
-	        ver[5] = ASC_BCD1(p_f[0])|ASC_BCD0(p_f[1]);
-	        p_f+=3;
-	} 
-	if( p_f[1] == '.' ) {
-	        ver[4] = ASC_BCD0(p_f[0]);
-	        p_f+=2;
-	} else {
-	        ver[4] = ASC_BCD1(p_f[0])|ASC_BCD0(p_f[1]);
-	        p_f+=3;
-	} 
-	ver[2] = ASC_BCD0(p_f[0]);
-	p_f++;
-	if( p_f[0] != ' ' ){
-	        ver[2] |= ASC_BCD1(p_f[0]);
-	        p_f++;
-	}
-	// only support 2 byte version.
-	ver[3] = 0;
-
-	#if MSC_EXT_DBG
-	printk("VERSION:%02x %02x %02x %02x %02x %02x\n" , 
-		ver[0],ver[1],ver[2],ver[3],ver[4],ver[5]);
-	#endif
-	return ret;
-}
-#endif
-
 static int do_scsi_command(struct fsg_common *common)
 {
 	struct fsg_buffhd	*bh;
@@ -2128,9 +1947,6 @@ static int do_scsi_command(struct fsg_common *common)
 	int			reply = -EINVAL;
 	int			i;
 	static char		unknown[16];
-#ifdef CONFIG_PLAT_RK
-	struct fsg_common	*fsg = common;
-#endif
 
 	dump_cdb(common);
 
@@ -2321,11 +2137,7 @@ static int do_scsi_command(struct fsg_common *common)
 				      (1<<1) | (0xf<<2) | (3<<7), 1,
 				      "VERIFY");
 		if (reply == 0)
-#ifdef CONFIG_PLAT_RK
-			reply = 0; //zyf 20100302
-#else
 			reply = do_verify(common);
-#endif
 		break;
 
 	case WRITE_6:
@@ -2381,26 +2193,6 @@ static int do_scsi_command(struct fsg_common *common)
 			reply = -EINVAL;
 		}
 		break;
-#ifdef CONFIG_PLAT_RK
-	case 0xff:
-		if( fsg->cmnd[1] != 0xe0 ||
-		    fsg->cmnd[2] != 0xff || fsg->cmnd[3] != 0xff ||
-		    fsg->cmnd[4] != 0xff )
-		    break;
-		if (fsg->cmnd_size >= 6 && fsg->cmnd[5] == 0xfe) {
-			schedule_work(&restart_work);
-		}
-		else if ( fsg->cmnd[5] == 0xf3 ) {
-			fsg->data_size_from_cmnd = fsg->data_size;
-		/* get product name from parameter section */
-			reply = do_get_product_name( fsg->data_size,bh->buf );
-		}
-		else if ( fsg->cmnd[5] == 0xff ){
-			fsg->data_size_from_cmnd = fsg->data_size;
-			reply = do_get_versions( fsg->data_size,bh->buf ); 
-		}
-		break;
-#endif
 	}
 	up_read(&common->filesem);
 
@@ -2585,12 +2377,10 @@ static int do_set_interface(struct fsg_common *common, struct fsg_dev *new_fsg)
 		/* Disable the endpoints */
 		if (fsg->bulk_in_enabled) {
 			usb_ep_disable(fsg->bulk_in);
-			fsg->bulk_in->driver_data = NULL;
 			fsg->bulk_in_enabled = 0;
 		}
 		if (fsg->bulk_out_enabled) {
 			usb_ep_disable(fsg->bulk_out);
-			fsg->bulk_out->driver_data = NULL;
 			fsg->bulk_out_enabled = 0;
 		}
 
@@ -3388,131 +3178,3 @@ fsg_common_from_params(struct fsg_common *common,
 	return fsg_common_init(common, cdev, &cfg);
 }
 
-#ifdef CONFIG_USB_ANDROID_MASS_STORAGE
-
-#ifdef CONFIG_PLAT_RK
-static enum power_supply_property usb_props[] = {
-//	POWER_SUPPLY_PROP_STATUS,
-	POWER_SUPPLY_PROP_ONLINE,
-};
-
-static int usb_get_property(struct power_supply *psy,
-				enum power_supply_property psp,
-					union power_supply_propval *val)
-{
-	int ret = 0;
-
-	switch (psp) {
-	case POWER_SUPPLY_PROP_ONLINE:
-#ifndef CONFIG_DWC_OTG_HOST_ONLY
-		val->intval = get_msc_connect_flag();
-#else
-		val->intval = 0;
-#endif
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return ret;
-}
-
-static int usb_power_supply_register(struct device* parent)
-{
-	struct power_supply *ps;
-	int retval = 0;
-
-	ps = kzalloc(sizeof(*ps), GFP_KERNEL);
-	if (!ps) {
-		dev_err(parent, "failed to allocate power supply data\n");
-		retval = -ENOMEM;
-		goto out;
-	}
-	ps->name = "usb";
-	ps->type = POWER_SUPPLY_TYPE_USB;
-	ps->properties = usb_props;
-	ps->num_properties = ARRAY_SIZE(usb_props);
-	ps->get_property = usb_get_property;
-	ps->external_power_changed = NULL;
-	retval = power_supply_register(parent, ps);
-	if (retval) {
-		dev_err(parent, "failed to register battery\n");
-		goto out;
-	}
-out:
-	return retval;
-}
-#endif
-
-static struct fsg_config fsg_cfg;
-
-static int fsg_probe(struct platform_device *pdev)
-{
-	struct usb_mass_storage_platform_data *pdata = pdev->dev.platform_data;
-	int i, nluns;
-
-	printk(KERN_INFO "fsg_probe pdev: %p, pdata: %p\n", pdev, pdata);
-	if (!pdata)
-		return -1;
-
-	nluns = pdata->nluns;
-	if (nluns > FSG_MAX_LUNS)
-		nluns = FSG_MAX_LUNS;
-	fsg_cfg.nluns = nluns;
-	for (i = 0; i < nluns; i++)
-		fsg_cfg.luns[i].removable = 1;
-
-	fsg_cfg.vendor_name = pdata->vendor;
-	fsg_cfg.product_name = pdata->product;
-	fsg_cfg.release = pdata->release;
-	fsg_cfg.can_stall = 0;
-	fsg_cfg.pdev = pdev;
-
-#ifdef CONFIG_PLAT_RK
-{
-	/*
-	 * Initialize usb power supply
-	 */
-	int retval = usb_power_supply_register(&pdev->dev);
-	if (retval != 0) {
-		dev_err(&pdev->dev, "usb_power_supply_register failed\n");
-	}
-
-	return retval;
-}
-#else
-	return 0;
-#endif
-}
-
-static struct platform_driver fsg_platform_driver = {
-	.driver = { .name = FUNCTION_NAME, },
-	.probe = fsg_probe,
-};
-
-int mass_storage_bind_config(struct usb_configuration *c)
-{
-	struct fsg_common *common = fsg_common_init(NULL, c->cdev, &fsg_cfg);
-	if (IS_ERR(common))
-		return -1;
-	return fsg_add(c->cdev, c, common);
-}
-
-static struct android_usb_function mass_storage_function = {
-	.name = FUNCTION_NAME,
-	.bind_config = mass_storage_bind_config,
-};
-
-static int __init init(void)
-{
-	int		rc;
-	printk(KERN_INFO "f_mass_storage init\n");
-	rc = platform_driver_register(&fsg_platform_driver);
-	if (rc != 0)
-		return rc;
-	android_register_function(&mass_storage_function);
-	return 0;
-}module_init(init);
-
-#endif /* CONFIG_USB_ANDROID_MASS_STORAGE */
-
diff --git a/drivers/usb/gadget/f_mtp.c b/drivers/usb/gadget/f_mtp.c
index 363e7c0d0add..2829231327d4 100644
--- a/drivers/usb/gadget/f_mtp.c
+++ b/drivers/usb/gadget/f_mtp.c
@@ -82,9 +82,8 @@ struct mtp_dev {
 
 	/* synchronize access to our device file */
 	atomic_t open_excl;
-
-	atomic_t ioctl_opt_excl;   /* lock for operation */
-	atomic_t ioctl_event_excl; /* lock for event */
+	/* to enforce only one ioctl at a time */
+	atomic_t ioctl_excl;
 
 	struct list_head tx_idle;
 	struct list_head intr_idle;
@@ -349,7 +348,8 @@ static struct usb_request
 static void mtp_complete_in(struct usb_ep *ep, struct usb_request *req)
 {
 	struct mtp_dev *dev = _mtp_dev;
-	if ((req->status != 0) && (dev->state != STATE_CANCELED))
+
+	if (req->status != 0)
 		dev->state = STATE_ERROR;
 
 	mtp_req_put(dev, &dev->tx_idle, req);
@@ -362,7 +362,7 @@ static void mtp_complete_out(struct usb_ep *ep, struct usb_request *req)
 	struct mtp_dev *dev = _mtp_dev;
 
 	dev->rx_done = 1;
-	if ((req->status != 0) && (dev->state != STATE_CANCELED))
+	if (req->status != 0)
 		dev->state = STATE_ERROR;
 
 	wake_up(&dev->read_wq);
@@ -410,6 +410,15 @@ static int mtp_create_bulk_endpoints(struct mtp_dev *dev,
 	ep->driver_data = dev;		/* claim the endpoint */
 	dev->ep_out = ep;
 
+	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
+	if (!ep) {
+		DBG(cdev, "usb_ep_autoconfig for ep_out failed\n");
+		return -ENODEV;
+	}
+	DBG(cdev, "usb_ep_autoconfig for mtp ep_out got %s\n", ep->name);
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
 	ep = usb_ep_autoconfig(cdev->gadget, intr_desc);
 	if (!ep) {
 		DBG(cdev, "usb_ep_autoconfig for ep_intr failed\n");
@@ -461,7 +470,7 @@ static ssize_t mtp_read(struct file *fp, char __user *buf,
 	DBG(cdev, "mtp_read(%d)\n", count);
 
 	if (count > MTP_BULK_BUFFER_SIZE)
-        count = MTP_BULK_BUFFER_SIZE;
+		return -EINVAL;
 
 	/* we will block until we're online */
 	DBG(cdev, "mtp_read: waiting for online state\n");
@@ -495,14 +504,7 @@ static ssize_t mtp_read(struct file *fp, char __user *buf,
 	}
 
 	/* wait for a request to complete */
-	ret = wait_event_interruptible(dev->read_wq, 
-	        dev->rx_done|| (dev->state != STATE_BUSY));
-	if (dev->state == STATE_CANCELED) {
-		r = -ECANCELED;
-		if (!dev->rx_done)
-			usb_ep_dequeue(dev->ep_out, req);
-		goto done;
-	}
+	ret = wait_event_interruptible(dev->read_wq, dev->rx_done);
 	if (ret < 0) {
 		r = ret;
 		usb_ep_dequeue(dev->ep_out, req);
@@ -669,7 +671,7 @@ static void send_file_work(struct work_struct *data) {
 		req = 0;
 		ret = wait_event_interruptible(dev->write_wq,
 			(req = mtp_req_get(dev, &dev->tx_idle))
-			|| (dev->state != STATE_BUSY));
+			|| dev->state != STATE_BUSY);
 		if (dev->state == STATE_CANCELED) {
 			r = -ECANCELED;
 			break;
@@ -742,9 +744,7 @@ static void receive_file_work(struct work_struct *data)
 	filp = dev->xfer_file;
 	offset = dev->xfer_file_offset;
 	count = dev->xfer_file_length;
-	/* yk@20120509 read zero length packet */
-    if(( count&0x1ff) == 0)
-    	count ++;
+
 	DBG(cdev, "receive_file_work(%lld)\n", count);
 
 	while (count > 0 || write_req) {
@@ -780,7 +780,7 @@ static void receive_file_work(struct work_struct *data)
 		if (read_req) {
 			/* wait for our last read to complete */
 			ret = wait_event_interruptible(dev->read_wq,
-				dev->rx_done || (dev->state != STATE_BUSY));
+				dev->rx_done || dev->state != STATE_BUSY);
 			if (dev->state == STATE_CANCELED) {
 				r = -ECANCELED;
 				if (!dev->rx_done)
@@ -796,10 +796,6 @@ static void receive_file_work(struct work_struct *data)
 				/* short packet is used to signal EOF for sizes > 4 gig */
 				DBG(cdev, "got short packet\n");
 				count = 0;
-				/* yk@20120509 usb disconnect will couse short packet, 
-				 * and dev state change to STATE_OFFLINE */
-                if(dev->state != STATE_BUSY)
-                    r = -EIO;
 			}
 
 			write_req = read_req;
@@ -849,13 +845,13 @@ static long mtp_ioctl(struct file *fp, unsigned code, unsigned long value)
 	struct file *filp = NULL;
 	int ret = -EINVAL;
 
+	if (mtp_lock(&dev->ioctl_excl))
+		return -EBUSY;
 
 	switch (code) {
 	case MTP_SEND_FILE:
 	case MTP_RECEIVE_FILE:
-    case MTP_SEND_FILE_WITH_HEADER:
-        if (mtp_lock(&dev->ioctl_opt_excl))
-            return -EBUSY;
+	case MTP_SEND_FILE_WITH_HEADER:
 	{
 		struct mtp_file_range	mfr;
 		struct work_struct *work;
@@ -922,10 +918,6 @@ static long mtp_ioctl(struct file *fp, unsigned code, unsigned long value)
 	case MTP_SEND_EVENT:
 	{
 		struct mtp_event	event;
-
-        if (mtp_lock(&dev->ioctl_event_excl))
-            return -EBUSY;
-
 		/* return here so we don't change dev->state below,
 		 * which would interfere with bulk transfer state.
 		 */
@@ -945,11 +937,7 @@ static long mtp_ioctl(struct file *fp, unsigned code, unsigned long value)
 		dev->state = STATE_READY;
 	spin_unlock_irq(&dev->lock);
 out:
-    if (MTP_SEND_EVENT == code)
-        mtp_unlock(&dev->ioctl_event_excl);
-    else
-        mtp_unlock(&dev->ioctl_opt_excl);
-
+	mtp_unlock(&dev->ioctl_excl);
 	DBG(dev->cdev, "ioctl returning %d\n", ret);
 	return ret;
 }
@@ -1034,10 +1022,10 @@ static int mtp_ctrlrequest(struct usb_composite_dev *cdev,
 
 		if (ctrl->bRequest == MTP_REQ_CANCEL && w_index == 0
 				&& w_value == 0) {
-			DBG(cdev, "MTP_REQ_CANCEL %d\n", dev->state);
+			DBG(cdev, "MTP_REQ_CANCEL\n");
 
 			spin_lock_irqsave(&dev->lock, flags);
-			/*if (dev->state == STATE_BUSY)*/ {
+			if (dev->state == STATE_BUSY) {
 				dev->state = STATE_CANCELED;
 				wake_up(&dev->read_wq);
 				wake_up(&dev->write_wq);
@@ -1055,7 +1043,7 @@ static int mtp_ctrlrequest(struct usb_composite_dev *cdev,
 			status->wLength =
 				__constant_cpu_to_le16(sizeof(*status));
 
-			DBG(cdev, "MTP_REQ_GET_DEVICE_STATUS %d\n", dev->state);
+			DBG(cdev, "MTP_REQ_GET_DEVICE_STATUS\n");
 			spin_lock_irqsave(&dev->lock, flags);
 			/* device status is "busy" until we report
 			 * the cancelation to userspace
@@ -1165,8 +1153,6 @@ static int mtp_function_set_alt(struct usb_function *f,
 		return ret;
 	}
 	dev->state = STATE_READY;
-	
-	atomic_set(&dev->open_excl, 0); // solve open_excl lock problem, add by Huweiguo
 
 	/* readers may be blocked waiting for us to go online */
 	wake_up(&dev->read_wq);
@@ -1181,11 +1167,8 @@ static void mtp_function_disable(struct usb_function *f)
 	DBG(cdev, "mtp_function_disable\n");
 	dev->state = STATE_OFFLINE;
 	usb_ep_disable(dev->ep_in);
-	dev->ep_in->driver_data = NULL;
 	usb_ep_disable(dev->ep_out);
-	dev->ep_out->driver_data = NULL;
 	usb_ep_disable(dev->ep_intr);
-	dev->ep_intr->driver_data = NULL;
 
 	/* readers may be blocked waiting for us to go online */
 	wake_up(&dev->read_wq);
@@ -1241,8 +1224,7 @@ static int mtp_setup(void)
 	init_waitqueue_head(&dev->write_wq);
 	init_waitqueue_head(&dev->intr_wq);
 	atomic_set(&dev->open_excl, 0);
-	atomic_set(&dev->ioctl_opt_excl, 0);
-	atomic_set(&dev->ioctl_event_excl, 0);
+	atomic_set(&dev->ioctl_excl, 0);
 	INIT_LIST_HEAD(&dev->tx_idle);
 	INIT_LIST_HEAD(&dev->intr_idle);
 
diff --git a/drivers/usb/gadget/f_rndis.c b/drivers/usb/gadget/f_rndis.c
index 617f6f3b952d..96adf45d44c2 100644
--- a/drivers/usb/gadget/f_rndis.c
+++ b/drivers/usb/gadget/f_rndis.c
@@ -100,8 +100,6 @@ struct f_rndis {
 	atomic_t			notify_count;
 };
 
-struct f_rndis		    *g_rndis;
-
 static inline struct f_rndis *func_to_rndis(struct usb_function *f)
 {
 	return container_of(f, struct f_rndis, port.func);
@@ -404,16 +402,16 @@ static void rndis_command_complete(struct usb_ep *ep, struct usb_request *req)
 }
 
 static int
-rndis_setup(struct usb_composite_dev *cdev, const struct usb_ctrlrequest *ctrl)
+rndis_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)
 {
-	//struct f_rndis		*rndis = func_to_rndis(f);
-	//struct usb_composite_dev *cdev = f->config->cdev;
-	struct f_rndis		*rndis = g_rndis;
+	struct f_rndis		*rndis = func_to_rndis(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
 	struct usb_request	*req = cdev->req;
 	int			value = -EOPNOTSUPP;
 	u16			w_index = le16_to_cpu(ctrl->wIndex);
 	u16			w_value = le16_to_cpu(ctrl->wValue);
 	u16			w_length = le16_to_cpu(ctrl->wLength);
+
 	/* composite driver infrastructure handles everything except
 	 * CDC class messages; interface activation uses set_alt().
 	 */
@@ -454,13 +452,12 @@ rndis_setup(struct usb_composite_dev *cdev, const struct usb_ctrlrequest *ctrl)
 		break;
 
 	default:
-	   
 invalid:
 		VDBG(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",
 			ctrl->bRequestType, ctrl->bRequest,
 			w_value, w_index, w_length);
-		return -EOPNOTSUPP;
 	}
+
 	/* respond with data transfer or status phase? */
 	if (value >= 0) {
 		DBG(cdev, "rndis req%02x.%02x v%04x i%04x l%d\n",
@@ -851,9 +848,9 @@ rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
 	rndis->port.func.bind = rndis_bind;
 	rndis->port.func.unbind = rndis_unbind;
 	rndis->port.func.set_alt = rndis_set_alt;
-	//rndis->port.func.setup = rndis_setup;
+	rndis->port.func.setup = rndis_setup;
 	rndis->port.func.disable = rndis_disable;
-    g_rndis = rndis;
+
 	status = usb_add_function(c, &rndis->port.func);
 	if (status) {
 		kfree(rndis);
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index dc537f1cb06b..bcdac7c73e89 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -130,12 +130,6 @@
 #define	gadget_is_r8a66597(g)	0
 #endif
 
-#ifdef CONFIG_USB_GADGET_DWC_OTG
-#define gadget_is_dwc_otg(g)    !strcmp("dwc_otg_pcd", (g)->name)
-#else
-#define gadget_is_dwc_otg(g)    0
-#endif
-
 #ifdef CONFIG_USB_S3C_HSOTG
 #define gadget_is_s3c_hsotg(g)    (!strcmp("s3c-hsotg", (g)->name))
 #else
@@ -219,8 +213,6 @@ static inline int usb_gadget_controller_number(struct usb_gadget *gadget)
 		return 0x24;
 	else if (gadget_is_r8a66597(gadget))
 		return 0x25;
-	else if (gadget_is_dwc_otg(gadget))
-		return 0x22;
 	else if (gadget_is_s3c_hsotg(gadget))
 		return 0x26;
 	else if (gadget_is_pch(gadget))
diff --git a/drivers/usb/gadget/storage_common.c b/drivers/usb/gadget/storage_common.c
index e881ba4450c7..a872248f37df 100644
--- a/drivers/usb/gadget/storage_common.c
+++ b/drivers/usb/gadget/storage_common.c
@@ -233,10 +233,6 @@ struct fsg_lun {
 	struct file	*filp;
 	loff_t		file_length;
 	loff_t		num_sectors;
-#ifdef MAX_UNFLUSHED_PACKETS
-	unsigned int	unflushed_packet;
-	unsigned int	unflushed_bytes;
-#endif
 
 	unsigned int	initially_ro:1;
 	unsigned int	ro:1;
@@ -767,11 +763,8 @@ static ssize_t fsg_store_file(struct device *dev, struct device_attribute *attr,
 	struct rw_semaphore	*filesem = dev_get_drvdata(dev);
 	int		rc = 0;
 
-#ifdef CONFIG_PLAT_RK
-	printk("store_file: \"%s\"\n", buf);
-#endif
 
-#ifndef CONFIG_USB_G_ANDROID
+#ifndef CONFIG_USB_ANDROID_MASS_STORAGE
 	/* disabled in android because we need to allow closing the backing file
 	 * if the media was removed
 	 */
diff --git a/drivers/usb/gadget/u_ether.c b/drivers/usb/gadget/u_ether.c
index 273718441c38..51d572eae9ad 100644
--- a/drivers/usb/gadget/u_ether.c
+++ b/drivers/usb/gadget/u_ether.c
@@ -31,7 +31,6 @@
 
 #include "u_ether.h"
 
-static gfp_t g_gfp_flags;
 
 /*
  * This component encapsulates the Ethernet link glue needed to provide
@@ -254,7 +253,7 @@ rx_submit(struct eth_dev *dev, struct usb_request *req, gfp_t gfp_flags)
 	 * but on at least one, checksumming fails otherwise.  Note:
 	 * RNDIS headers involve variable numbers of LE32 values.
 	 */
-	//skb_reserve(skb, NET_IP_ALIGN);
+	skb_reserve(skb, NET_IP_ALIGN);
 
 	req->buf = skb->data;
 	req->length = size;
@@ -578,21 +577,6 @@ static netdev_tx_t eth_start_xmit(struct sk_buff *skb,
 
 		length = skb->len;
 	}
-	
-	// for tx fixup
-	{
-		struct sk_buff *tx_skb;
-		if ((unsigned long)skb->data % 4) {
-			tx_skb = alloc_skb(skb->len + NET_IP_ALIGN, g_gfp_flags);
-			if (tx_skb)
-				memcpy(skb_put(tx_skb, skb->len), skb->data, skb->len);
-			dev_kfree_skb_any(skb);
-			skb = tx_skb;
-		}
-		length = skb->len;
-	}	
-	// for tx fixup
-	
 	req->buf = skb->data;
 	req->context = skb;
 	req->complete = tx_complete;
@@ -648,8 +632,6 @@ static netdev_tx_t eth_start_xmit(struct sk_buff *skb,
 static void eth_start(struct eth_dev *dev, gfp_t gfp_flags)
 {
 	DBG(dev, "%s\n", __func__);
-	
-	g_gfp_flags = gfp_flags;
 
 	/* fill the rx queue */
 	rx_fill(dev, gfp_flags);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 0ba9e7b25828..ab085f12d570 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -91,14 +91,6 @@ config USB_EHCI_TT_NEWSCHED
 
 	  If unsure, say Y.
 
-config USB_EHCI_RK
-	bool "Rockchip EHCI HSIC support"
-	depends on USB_EHCI_HCD 
-	select USB_EHCI_ROOT_HUB_TT
-	default y
-	---help---
-		Enables support for the onchip USB controller on the RK3108.
-
 config USB_EHCI_HCD_PMC_MSP
 	tristate "EHCI support for on-chip PMC MSP71xx USB controller"
 	depends on USB_EHCI_HCD && MSP_HAS_USB
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1990062de29a..f89f77f1b339 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1292,11 +1292,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_msm_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_RK
-#include "ehci-rk.c"
-#define PLATFORM_DRIVER		ehci_rk_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_HCD_PMC_MSP
 #include "ehci-pmcmsp.c"
 #define	PLATFORM_DRIVER		ehci_hcd_msp_driver
diff --git a/drivers/usb/otg/twl6030-usb.c b/drivers/usb/otg/twl6030-usb.c
index d1732d0d10b9..cfb5aa72b196 100644
--- a/drivers/usb/otg/twl6030-usb.c
+++ b/drivers/usb/otg/twl6030-usb.c
@@ -30,12 +30,9 @@
 #include <linux/regulator/consumer.h>
 #include <linux/err.h>
 #include <linux/notifier.h>
-#include <linux/power_supply.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
 
-//#include <plat/usb.h>
-
 /* usb register definitions */
 #define USB_VENDOR_ID_LSB		0x00
 #define USB_VENDOR_ID_MSB		0x01
@@ -66,7 +63,9 @@
 #define USB_OTG_ADP_RISE		0x19
 #define USB_OTG_REVISION		0x1A
 
+/* to be moved to LDO */
 #define TWL6030_MISC2			0xE5
+#define TWL6030_CFG_LDO_PD2		0xF5
 #define TWL6030_BACKUP_REG		0xFA
 
 #define STS_HW_CONDITIONS		0x21
@@ -83,18 +82,10 @@
 /* in module TWL6030_MODULE_MAIN_CHARGE */
 
 #define CHARGERUSB_CTRL1		0x8
-#define SUSPEND_BOOT    (1 << 7)
-#define OPA_MODE        (1 << 6)
-#define HZ_MODE         (1 << 5)
-#define TERM            (1 << 4)
-
 
 #define CONTROLLER_STAT1		0x03
 #define	VBUS_DET			BIT(2)
 
-extern int get_gadget_connect_flag(void);
-
-
 struct twl6030_usb {
 	struct otg_transceiver	otg;
 	struct device		*dev;
@@ -104,18 +95,11 @@ struct twl6030_usb {
 
 	struct regulator		*usb3v3;
 
-	/* used to set vbus, in atomic path */
-	struct work_struct	set_vbus_work;
-
 	int			irq1;
 	int			irq2;
-	unsigned int		usb_cinlimit_mA;
 	u8			linkstat;
 	u8			asleep;
-	u8			prev_vbus;
 	bool			irq_enabled;
-	bool			vbus_enable;
-	bool			is_phy_suspended;
 	unsigned long		features;
 };
 
@@ -201,13 +185,8 @@ static int twl6030_phy_suspend(struct otg_transceiver *x, int suspend)
 	struct device *dev = twl->dev;
 	struct twl4030_usb_data *pdata = dev->platform_data;
 
-	if (suspend && !twl->is_phy_suspended) {
-		pdata->phy_suspend(dev, 1);
-		twl->is_phy_suspended = true;
-	} else if (!suspend && twl->is_phy_suspended) {
-		pdata->phy_suspend(dev, 0);
-		twl->is_phy_suspended = false;
-	}
+	pdata->phy_suspend(dev, suspend);
+
 	return 0;
 }
 
@@ -227,9 +206,8 @@ static int twl6030_start_srp(struct otg_transceiver *x)
 static int twl6030_usb_ldo_init(struct twl6030_usb *twl)
 {
 	char *regulator_name;
-	u8 misc2_data = 0;
 
-	if (twl->features & TWL6032_SUBCLASS)
+	if (twl->features & TWL6025_SUBCLASS)
 		regulator_name = "ldousb";
 	else
 		regulator_name = "vusb";
@@ -237,6 +215,12 @@ static int twl6030_usb_ldo_init(struct twl6030_usb *twl)
 	/* Set to OTG_REV 1.3 and turn on the ID_WAKEUP_COMP */
 	twl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x1, TWL6030_BACKUP_REG);
 
+	/* Program CFG_LDO_PD2 register and set VUSB bit */
+	twl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x1, TWL6030_CFG_LDO_PD2);
+
+	/* Program MISC2 register and set bit VUSB_IN_VBAT */
+	twl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x10, TWL6030_MISC2);
+
 	twl->usb3v3 = regulator_get(twl->dev, regulator_name);
 	if (IS_ERR(twl->usb3v3))
 		return -ENODEV;
@@ -250,11 +234,6 @@ static int twl6030_usb_ldo_init(struct twl6030_usb *twl)
 	 */
 	twl6030_writeb(twl, TWL_MODULE_USB, 0x14, USB_ID_CTRL_SET);
 
-	/* Program MISC2 register and clear bit VUSB_IN_VBAT */
-	misc2_data = twl6030_readb(twl, TWL6030_MODULE_ID0, TWL6030_MISC2);
-	misc2_data &= 0xEF;
-	twl6030_writeb(twl, TWL6030_MODULE_ID0, misc2_data, TWL6030_MISC2);
-
 	return 0;
 }
 
@@ -269,16 +248,16 @@ static ssize_t twl6030_usb_vbus_show(struct device *dev,
 
 	switch (twl->linkstat) {
 	case USB_EVENT_VBUS:
-		ret = snprintf(buf, PAGE_SIZE, "vbus\n");
-		break;
+	       ret = snprintf(buf, PAGE_SIZE, "vbus\n");
+	       break;
 	case USB_EVENT_ID:
-		ret = snprintf(buf, PAGE_SIZE, "id\n");
-		break;
+	       ret = snprintf(buf, PAGE_SIZE, "id\n");
+	       break;
 	case USB_EVENT_NONE:
-		ret = snprintf(buf, PAGE_SIZE, "none\n");
-		break;
+	       ret = snprintf(buf, PAGE_SIZE, "none\n");
+	       break;
 	default:
-		ret = snprintf(buf, PAGE_SIZE, "UNKNOWN\n");
+	       ret = snprintf(buf, PAGE_SIZE, "UNKNOWN\n");
 	}
 	spin_unlock_irqrestore(&twl->lock, flags);
 
@@ -290,107 +269,55 @@ static irqreturn_t twl6030_usb_irq(int irq, void *_twl)
 {
 	struct twl6030_usb *twl = _twl;
 	int status;
-	u8 vbus_state, hw_state, misc2_data;
-	unsigned charger_type;
+	u8 vbus_state, hw_state;
 
 	hw_state = twl6030_readb(twl, TWL6030_MODULE_ID0, STS_HW_CONDITIONS);
 
 	vbus_state = twl6030_readb(twl, TWL_MODULE_MAIN_CHARGE,
 						CONTROLLER_STAT1);
-	vbus_state = vbus_state & VBUS_DET;
-
-	/* Ignore charger events other than VBUS */
-	if (vbus_state == twl->prev_vbus)
-		return IRQ_HANDLED;
-
-	if ((vbus_state) && !(hw_state & STS_USB_ID)) {
-		/* Program MISC2 register and set bit VUSB_IN_VBAT */
-		misc2_data = twl6030_readb(twl, TWL6030_MODULE_ID0,
-						TWL6030_MISC2);
-		misc2_data |= 0x10;
-		twl6030_writeb(twl, TWL6030_MODULE_ID0, misc2_data,
-						TWL6030_MISC2);
-
-		regulator_enable(twl->usb3v3);
-		twl6030_phy_suspend(&twl->otg, 0);
-		if(0 == get_gadget_connect_flag())
-			charger_type = POWER_SUPPLY_TYPE_USB_DCP;
-		else
-			charger_type = POWER_SUPPLY_TYPE_USB;
-		
-		twl6030_phy_suspend(&twl->otg, 1);
-		if ((charger_type == POWER_SUPPLY_TYPE_USB_CDP)
-				|| (charger_type == POWER_SUPPLY_TYPE_USB)) {
-
+	if (!(hw_state & STS_USB_ID)) {
+		if (vbus_state & VBUS_DET) {
+			regulator_enable(twl->usb3v3);
+			twl->asleep = 1;
 			status = USB_EVENT_VBUS;
 			twl->otg.default_a = false;
-			twl->asleep = 1;
 			twl->otg.state = OTG_STATE_B_IDLE;
 			twl->linkstat = status;
 			twl->otg.last_event = status;
-		} else if (charger_type == POWER_SUPPLY_TYPE_USB_DCP) {
-			regulator_disable(twl->usb3v3);
-			status = USB_EVENT_CHARGER;
-			twl->usb_cinlimit_mA = 1800;
-			twl->otg.state = OTG_STATE_B_IDLE;
+			atomic_notifier_call_chain(&twl->otg.notifier,
+						status, twl->otg.gadget);
+		} else {
+			status = USB_EVENT_NONE;
 			twl->linkstat = status;
 			twl->otg.last_event = status;
-		} else {
-			regulator_disable(twl->usb3v3);
-			goto vbus_notify;
-		}
-		atomic_notifier_call_chain(&twl->otg.notifier,
-				status, &charger_type);
-	}
-	if (!vbus_state) {
-		status = USB_EVENT_NONE;
-		twl->linkstat = status;
-		twl->otg.last_event = status;
-		atomic_notifier_call_chain(&twl->otg.notifier,
-				status, twl->otg.gadget);
-		if (twl->asleep) {
-			regulator_disable(twl->usb3v3);
-			twl->asleep = 0;
-			/* Program MISC2 register and clear bit VUSB_IN_VBAT */
-			misc2_data = twl6030_readb(twl, TWL6030_MODULE_ID0,
-							TWL6030_MISC2);
-			misc2_data &= 0xEF;
-			twl6030_writeb(twl, TWL6030_MODULE_ID0, misc2_data,
-							TWL6030_MISC2);
+			atomic_notifier_call_chain(&twl->otg.notifier,
+						status, twl->otg.gadget);
+			if (twl->asleep) {
+				regulator_disable(twl->usb3v3);
+				twl->asleep = 0;
+			}
 		}
 	}
-
-vbus_notify:
 	sysfs_notify(&twl->dev->kobj, NULL, "vbus");
-	twl->prev_vbus = vbus_state;
+
 	return IRQ_HANDLED;
 }
 
 static irqreturn_t twl6030_usbotg_irq(int irq, void *_twl)
 {
-
-#ifndef CONFIG_USB_MUSB_PERIPHERAL
 	struct twl6030_usb *twl = _twl;
 	int status = USB_EVENT_NONE;
-	u8 hw_state, misc2_data;
+	u8 hw_state;
 
 	hw_state = twl6030_readb(twl, TWL6030_MODULE_ID0, STS_HW_CONDITIONS);
 
 	if (hw_state & STS_USB_ID) {
 
-		if (twl->otg.state == OTG_STATE_A_IDLE)
-			return IRQ_HANDLED;
-
-		/* Program MISC2 register and set bit VUSB_IN_VBAT */
-		misc2_data = twl6030_readb(twl, TWL6030_MODULE_ID0,
-						TWL6030_MISC2);
-		misc2_data |= 0x10;
-		twl6030_writeb(twl, TWL6030_MODULE_ID0, misc2_data,
-						TWL6030_MISC2);
 		regulator_enable(twl->usb3v3);
 		twl->asleep = 1;
-		twl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_CLR);
-		twl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_SET);
+		twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_CLR, 0x1);
+		twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_SET,
+								0x10);
 		status = USB_EVENT_ID;
 		twl->otg.default_a = true;
 		twl->otg.state = OTG_STATE_A_IDLE;
@@ -399,11 +326,12 @@ static irqreturn_t twl6030_usbotg_irq(int irq, void *_twl)
 		atomic_notifier_call_chain(&twl->otg.notifier, status,
 							twl->otg.gadget);
 	} else  {
-		twl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_CLR);
-		twl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_SET);
+		twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_CLR,
+								0x10);
+		twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_SET,
+								0x1);
 	}
-	twl6030_writeb(twl, TWL_MODULE_USB, status, USB_ID_INT_LATCH_CLR);
-#endif
+	twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_LATCH_CLR, status);
 
 	return IRQ_HANDLED;
 }
@@ -428,7 +356,7 @@ static int twl6030_enable_irq(struct otg_transceiver *x)
 {
 	struct twl6030_usb *twl = xceiv_to_twl(x);
 
-	twl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_SET);
+	twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_SET, 0x1);
 	twl6030_interrupt_unmask(0x05, REG_INT_MSK_LINE_C);
 	twl6030_interrupt_unmask(0x05, REG_INT_MSK_STS_C);
 
@@ -442,60 +370,20 @@ static int twl6030_enable_irq(struct otg_transceiver *x)
 	return 0;
 }
 
-unsigned int twl6030_get_usb_max_power(struct otg_transceiver *x)
+static int twl6030_set_vbus(struct otg_transceiver *x, bool enabled)
 {
 	struct twl6030_usb *twl = xceiv_to_twl(x);
 
-	return twl->usb_cinlimit_mA;
-}
-
-static void otg_set_vbus_work(struct work_struct *data)
-{
-	struct twl6030_usb *twl = container_of(data, struct twl6030_usb,
-								set_vbus_work);
 	/*
 	 * Start driving VBUS. Set OPA_MODE bit in CHARGERUSB_CTRL1
 	 * register. This enables boost mode.
 	 */
-	if (twl->vbus_enable)
+	if (enabled)
 		twl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE , 0x40,
 						CHARGERUSB_CTRL1);
-	else
+	 else
 		twl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE , 0x00,
 						CHARGERUSB_CTRL1);
-}
-
-static int twl6030_set_hz_mode(struct otg_transceiver *x, bool enabled)
-{
-	u8 val;
-	struct twl6030_usb *twl;
-
-	if (!x)
-		return -ENODEV;
-
-	twl = xceiv_to_twl(x);
-
-	/* set/reset USB charger in High impedence mode on VBUS */
-	val = twl6030_readb(twl, TWL_MODULE_MAIN_CHARGE,
-						CHARGERUSB_CTRL1);
-
-	if (enabled)
-		val |= HZ_MODE;
-	else
-		val &= ~HZ_MODE;
-
-	twl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE , val,
-						CHARGERUSB_CTRL1);
-
-	return 0;
-}
-
-static int twl6030_set_vbus(struct otg_transceiver *x, bool enabled)
-{
-	struct twl6030_usb *twl = xceiv_to_twl(x);
-
-	twl->vbus_enable = enabled;
-	schedule_work(&twl->set_vbus_work);
 	return 0;
 }
 
@@ -513,17 +401,6 @@ static int twl6030_set_host(struct otg_transceiver *x, struct usb_bus *host)
 	return 0;
 }
 
-static int twl6030_set_power(struct otg_transceiver *x, unsigned int mA)
-{
-	struct twl6030_usb *twl = xceiv_to_twl(x);
-
-	twl->usb_cinlimit_mA = mA;
-	if (mA && (twl->otg.last_event != USB_EVENT_NONE))
-		atomic_notifier_call_chain(&twl->otg.notifier, USB_EVENT_ENUMERATED,
-				&twl->usb_cinlimit_mA);
-	return 0;
-}
-
 static int __devinit twl6030_usb_probe(struct platform_device *pdev)
 {
 	struct twl6030_usb	*twl;
@@ -545,13 +422,10 @@ static int __devinit twl6030_usb_probe(struct platform_device *pdev)
 	twl->otg.set_host	= twl6030_set_host;
 	twl->otg.set_peripheral	= twl6030_set_peripheral;
 	twl->otg.set_vbus	= twl6030_set_vbus;
-	twl->otg.set_hz_mode	= twl6030_set_hz_mode;
 	twl->otg.init		= twl6030_phy_init;
-	twl->otg.set_power    = twl6030_set_power;
 	twl->otg.shutdown	= twl6030_phy_shutdown;
 	twl->otg.set_suspend	= twl6030_phy_suspend;
 	twl->otg.start_srp	= twl6030_start_srp;
-	twl->otg.state		= OTG_STATE_UNDEFINED;
 
 	/* init spinlock for workqueue */
 	spin_lock_init(&twl->lock);
@@ -570,9 +444,6 @@ static int __devinit twl6030_usb_probe(struct platform_device *pdev)
 
 	ATOMIC_INIT_NOTIFIER_HEAD(&twl->otg.notifier);
 
-	INIT_WORK(&twl->set_vbus_work, otg_set_vbus_work);
-
-	twl->vbus_enable = false;
 	twl->irq_enabled = true;
 	status = request_threaded_irq(twl->irq1, NULL, twl6030_usbotg_irq,
 			IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
@@ -598,7 +469,6 @@ static int __devinit twl6030_usb_probe(struct platform_device *pdev)
 	}
 
 	twl->asleep = 0;
-	twl->is_phy_suspended = true;
 	pdata->phy_init(dev);
 	twl6030_phy_suspend(&twl->otg, 0);
 	twl6030_enable_irq(&twl->otg);
@@ -624,7 +494,6 @@ static int __exit twl6030_usb_remove(struct platform_device *pdev)
 	regulator_put(twl->usb3v3);
 	pdata->phy_exit(twl->dev);
 	device_remove_file(twl->dev, &dev_attr_vbus);
-	cancel_work_sync(&twl->set_vbus_work);
 	kfree(twl);
 
 	return 0;
diff --git a/drivers/usb/serial/Kconfig b/drivers/usb/serial/Kconfig
index 0b70da3518d9..b71e309116a3 100644
--- a/drivers/usb/serial/Kconfig
+++ b/drivers/usb/serial/Kconfig
@@ -661,12 +661,4 @@ config USB_SERIAL_DEBUG
 	  To compile this driver as a module, choose M here: the
 	  module will be called usb-debug.
 
-config USB_SERIAL_USI 
- tristate "USB USI Serial driver" 
- help 
-   Say Y here if you have a USI WCDMA modem that's connected to USB. 
- 
-   To compile this driver as a module, choose M here: the module will be called 
-   module will be called option. 
-
 endif # USB_SERIAL
diff --git a/drivers/usb/serial/Makefile b/drivers/usb/serial/Makefile
index 991cc047a41a..9e536eefb32c 100644
--- a/drivers/usb/serial/Makefile
+++ b/drivers/usb/serial/Makefile
@@ -60,4 +60,3 @@ obj-$(CONFIG_USB_SERIAL_WHITEHEAT)		+= whiteheat.o
 obj-$(CONFIG_USB_SERIAL_XIRCOM)			+= keyspan_pda.o
 obj-$(CONFIG_USB_SERIAL_VIVOPAY_SERIAL)		+= vivopay-serial.o
 obj-$(CONFIG_USB_SERIAL_ZIO)			+= zio.o
-obj-$(CONFIG_USB_SERIAL_USI)			+= usiserial.o
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 93039fb2e6e3..52cd814176a7 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -80,9 +80,7 @@ static void option_instat_callback(struct urb *urb);
 #define OPTION_PRODUCT_GTM380_MODEM		0x7201
 
 #define HUAWEI_VENDOR_ID			0x12D1
-#define HUAWEI_PRODUCT_MU509                    0x1001
 #define HUAWEI_PRODUCT_E173			0x140C
-#define HUAWEI_PRODUCT_E140C                    0x140C
 #define HUAWEI_PRODUCT_K4505			0x1464
 #define HUAWEI_PRODUCT_K3765			0x1465
 #define HUAWEI_PRODUCT_K4605			0x14C6
@@ -254,7 +252,6 @@ static void option_instat_callback(struct urb *urb);
 #define ZTE_PRODUCT_CDMA_TECH			0xfffe
 #define ZTE_PRODUCT_AC8710			0xfff1
 #define ZTE_PRODUCT_AC2726			0xfff5
-#define ZTE_PRODUCT_AC100			0x0094
 #define ZTE_PRODUCT_AC8710T			0xffff
 #define ZTE_PRODUCT_MC2718			0xffe8
 #define ZTE_PRODUCT_AD3812			0xffeb
@@ -333,7 +330,6 @@ static void option_instat_callback(struct urb *urb);
 /* Haier products */
 #define HAIER_VENDOR_ID				0x201e
 #define HAIER_PRODUCT_CE100			0x2009
-#define HAIER_PRODUCT_IE701			0x1022
 
 /* Cinterion (formerly Siemens) products */
 #define SIEMENS_VENDOR_ID				0x0681
@@ -346,11 +342,6 @@ static void option_instat_callback(struct urb *urb);
 #define CINTERION_PRODUCT_EU3_P			0x0052
 #define CINTERION_PRODUCT_PH8			0x0053
 
-/* Thinkwill products */
-#define THINKWILL_VENDOR_ID 	0x19f5
-#define THINKWILL_PRODUCT_ID	0x9909
-#define	THINKWILL_MI900_PRODUCT_ID	0x9013
-
 /* Olivetti products */
 #define OLIVETTI_VENDOR_ID			0x0b3c
 #define OLIVETTI_PRODUCT_OLICARD100		0xc000
@@ -369,17 +360,6 @@ static void option_instat_callback(struct urb *urb);
 #define SAMSUNG_VENDOR_ID                       0x04e8
 #define SAMSUNG_PRODUCT_GT_B3730                0x6889
 
-/* leadcore LC1808*/
-#define LEADCORE_VENDOR_ID	0x1ab7
-#define LEADCORE_PRODUCT_LC1808	0x2200
-/**/
-#define SC8800G_VENDOR_ID	0x067b
-#define SC8800G_PRODUCT_ID	0x2303
-
-/*usi mt6229 modem*/
-#define MT6229_VENDOR_ID			0x0e8d
-#define MT6229_PRODUCT_ID			0x00a0
-
 /* YUGA products  www.yuga-info.com gavin.kx@qq.com */
 #define YUGA_VENDOR_ID				0x257A
 #define YUGA_PRODUCT_CEM600			0x1601
@@ -477,13 +457,7 @@ static void option_instat_callback(struct urb *urb);
 /* Changhong products */
 #define CHANGHONG_VENDOR_ID			0x2077
 #define CHANGHONG_PRODUCT_CH690			0x7001
-/* Strong Rising WCDMA modem*/
-#define STRONG_RISING_VENDOR_ID     0x21F5
-#define STRONG_RISING_PRODUCT_SPW9S  0x2012
-/* Strong Rising EVDO modem*/
-#define STRONG_RISING_PRODUCT_SP8J  0x2009
 
-static int viatelecom_send_setup(struct usb_serial_port *port);
 /* some devices interfaces need special handling due to a number of reasons */
 enum option_blacklist_reason {
 		OPTION_BLACKLIST_NONE = 0,
@@ -572,10 +546,6 @@ static const struct option_blacklist_info telit_le920_blacklist = {
 
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
-	{ USB_DEVICE(THINKWILL_VENDOR_ID,THINKWILL_PRODUCT_ID)},
-
-	{ USB_DEVICE(THINKWILL_VENDOR_ID,THINKWILL_MI900_PRODUCT_ID)},
-
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA_LIGHT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA_QUAD) },
@@ -605,10 +575,8 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(QUANTA_VENDOR_ID, QUANTA_PRODUCT_GLX) },
 	{ USB_DEVICE(QUANTA_VENDOR_ID, QUANTA_PRODUCT_GKE) },
 	{ USB_DEVICE(QUANTA_VENDOR_ID, QUANTA_PRODUCT_GLE) },
-	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_MU509) },
-        { USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E140C, 0xff, 0xff, 0xff) },
-	//{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E173, 0xff, 0xff, 0xff),
-	//	.driver_info = (kernel_ulong_t) &net_intf1_blacklist },
+	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E173, 0xff, 0xff, 0xff),
+		.driver_info = (kernel_ulong_t) &net_intf1_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4505, 0xff, 0xff, 0xff),
 		.driver_info = (kernel_ulong_t) &huawei_cdc12_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K3765, 0xff, 0xff, 0xff),
@@ -1219,11 +1187,6 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_CDMA_TECH, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC8710, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC2726, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xFFED, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xFFFE, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xFFEB, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xF006, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_AC100)},
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC8710T, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MC2718, 0xff, 0xff, 0xff),
 	 .driver_info = (kernel_ulong_t)&zte_mc2718_z_blacklist },
@@ -1290,97 +1253,6 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) }, /* HC28 enumerates with Siemens or Cinterion VID depending on FW revision */
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC28_MDMNET) },
 
-	{ USB_DEVICE(LEADCORE_VENDOR_ID, LEADCORE_PRODUCT_LC1808) },  //zzc
-	{ USB_DEVICE(SC8800G_VENDOR_ID,SC8800G_PRODUCT_ID)},
-	{ USB_DEVICE(OLIVETTI_VENDOR_ID, OLIVETTI_PRODUCT_OLICARD100) },
-	{ USB_DEVICE(CELOT_VENDOR_ID, CELOT_PRODUCT_CT680M) }, /* CT-650 CDMA 450 1xEVDO modem */
-
-// cmy:
-	{ USB_DEVICE(0x0685, 0x6000) },
-	{ USB_DEVICE(0x1E89, 0x1E16) },
-	{ USB_DEVICE(0x7693, 0x0001) },
-	{ USB_DEVICE(0x1D09, 0x4308) },
-	{ USB_DEVICE(0x1234, 0x0033) },
-	{ USB_DEVICE(0xFEED, 0x0001) },
-	{ USB_DEVICE(ALCATEL_VENDOR_ID, 0x0017) },
-	{ USB_DEVICE(0x1C9E, 0x9E00) },
-	{ USB_DEVICE(0x1C9E, 0xF000) },
-	{ USB_DEVICE(0x19D2, 0x1303) },
-	{ USB_DEVICE(0x19F5, 0x9013) }, // MW100
-	{ USB_DEVICE(0x21F5, 0x2008) },
-	{ USB_DEVICE(0x12D1, 0x1D09) },
-	{ USB_DEVICE(0x04CC, 0x2259) },
-	{ USB_DEVICE(0x04CC, 0x226E) },
-	{ USB_DEVICE(0x04CC, 0x225A) },
-	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x0015) },
-	{ USB_DEVICE(ALCATEL_VENDOR_ID, 0x00b7) },
-	{ USB_DEVICE(ZTE_VENDOR_ID, 0xFFFF) },
-	{ USB_DEVICE(LEADCORE_VENDOR_ID, 0x5700) },
-	{ USB_DEVICE(LEADCORE_VENDOR_ID, 0x6341) },
-	{ USB_DEVICE(0x230D, 0x000D) },
-	{ USB_DEVICE(0x0E8D, 0x00A2) },
-	{ USB_DEVICE(0x1E89, 0x1A20) },
-	{ USB_DEVICE(0x12D1, 0x1C05) },
-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE(HUAWEI_VENDOR_ID, 0x14A8) },
-	{ USB_DEVICE(0x20A6, 0x1105) },
-	{ USB_DEVICE(0x1EE8, 0x005F) }, // Onda-MSA14.4
-	{ USB_DEVICE(0x0421, 0x061E) }, // Nokia CS-11
-	{ USB_DEVICE(0x0BDB, 0x190A) },
-	{ USB_DEVICE(0x1d09, 0x1010) },
-    { USB_DEVICE(0x19D2, 0x1181) },
-	{ USB_DEVICE(0x2020, 0x1005)},//S830 3G Dongle
-    { USB_DEVICE(0x1782, 0x0002)},//U7501
-    { USB_DEVICE(0x1782, 0x4D00)},
-	{ USB_DEVICE(0x21f5, 0x2012) },//SEW290
-// cmy end
-//xxh
-   { USB_DEVICE_AND_INTERFACE_INFO(0x05c6, 0x1000, 0xff, 0xff, 0xff) },
-   { USB_DEVICE_AND_INTERFACE_INFO(0x05c6, 0x6000, 0xff, 0xff, 0xff) },
-   { USB_DEVICE_AND_INTERFACE_INFO(0x20A6, 0xF00E, 0xff, 0xff, 0xff) },
-   { USB_DEVICE_AND_INTERFACE_INFO(0x20A6, 0x1105, 0xff, 0xff, 0xff) },
-   { USB_DEVICE(0x21f5, 0x1101)},
-   { USB_DEVICE(0x230d,0x0101)},
-   { USB_DEVICE_AND_INTERFACE_INFO(0x230d, 0x1101, 0xff, 0xff, 0xff) },
-   { USB_DEVICE(0x2077,0xa000)},
-   { USB_DEVICE(0x1c9e,0x6061)},
-   { USB_DEVICE(0x1c9e,0x9605)},
-   { USB_DEVICE(0x19d2, 0x0170) },
-   { USB_DEVICE(0x19d2, 0xffe8) },
-   { USB_DEVICE(0x19D2,0x1177) },//K3770-Z
-   { USB_DEVICE(0x230D, 0x000c) },
- //  { USB_DEVICE(0x21F5, 0x2009) },
-   {USB_DEVICE(STRONG_RISING_VENDOR_ID,STRONG_RISING_PRODUCT_SP8J)},
-   {USB_DEVICE(STRONG_RISING_VENDOR_ID,STRONG_RISING_PRODUCT_SPW9S)},
-   { USB_DEVICE(0x15eb,0x0001)},
-   { USB_DEVICE(0x12d1,0x14db) },
-   { USB_DEVICE(0x15EB,0x7152)},
-   { USB_DEVICE(0x15EB,0x0001)},
-   { USB_DEVICE(0x201E,0x1022)},
-   { USB_DEVICE(0x1A8D,0x2006)},
-   { USB_DEVICE(0x1C9E,0x9915)},
-   { USB_DEVICE(0x1C9E,0x9800)},
-   { USB_DEVICE(0x05c6,0x0016)},
-   { USB_DEVICE(0x0B3C,0xC00A)},
-   { USB_DEVICE(0x230D, 0x0103)},
-   { USB_DEVICE(0x1DBC,0x0669)},
-   { USB_DEVICE(0x2020,0x4000)},
-   { USB_DEVICE(0x230D, 0x0003)},
-   { USB_DEVICE(0x230D, 0x000C)},
-   { USB_DEVICE(0x12d1,0x1506)},
-   { USB_DEVICE(0x2001,0x7D00)},//D-Link DWM-156
-   { USB_DEVICE(0x0af0,0xd157)}, 
-   { USB_DEVICE(0x0421,0x0612)},
-   { USB_DEVICE(0x19d2,0x1218)},
-   { USB_DEVICE(HAIER_VENDOR_ID, HAIER_PRODUCT_IE701)},
-   { USB_DEVICE(0x1C9E,0x9914)},
-   { USB_DEVICE(0x19d2,0x1515)},
-   { USB_DEVICE(0x1bbb,0x0012)},
-   { USB_DEVICE(0x1c9e,0x9801)},
-//xxh end
-
-
 	{ USB_DEVICE(OLIVETTI_VENDOR_ID, OLIVETTI_PRODUCT_OLICARD100) },
 	{ USB_DEVICE(CELOT_VENDOR_ID, CELOT_PRODUCT_CT680M) }, /* CT-650 CDMA 450 1xEVDO modem */
 	{ USB_DEVICE(ONDA_VENDOR_ID, ONDA_MT825UP) }, /* ONDA MT825UP modem */
@@ -1600,26 +1472,9 @@ static int option_probe(struct usb_serial *serial,
 		serial->interface->cur_altsetting->desc.bInterfaceClass != USB_CLASS_CDC_DATA)
 		return -ENODEV;
 
-	/* Don't bind network interface on mt6229, it is handled by a separate module */
-	if (serial->dev->descriptor.idVendor == MT6229_VENDOR_ID &&
-		serial->dev->descriptor.idProduct == MT6229_PRODUCT_ID)
-	{
-		printk("%s:mt6229 exit\n",__func__);
-		return -ENODEV;
-	}
-
 	data = serial->private = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
-      if ((serial->dev->descriptor.idVendor == HAIER_VENDOR_ID &&
-			  serial->dev->descriptor.idProduct == HAIER_PRODUCT_IE701)||
-			  (serial->dev->descriptor.idVendor == 0x15EB &&
-			  serial->dev->descriptor.idProduct == 0x7152)) {   
-			     
-			    data->send_setup = viatelecom_send_setup;
-				
-		 }else
-
 	data->send_setup = option_send_setup;
 	spin_lock_init(&data->susp_lock);
 	data->private = (void *)id->driver_info;
@@ -1642,13 +1497,11 @@ static void option_instat_callback(struct urb *urb)
 	struct usb_serial_port *port =  urb->context;
 	struct usb_wwan_port_private *portdata =
 					usb_get_serial_port_data(port);
-	static int err_times = 0;
 
 	dbg("%s", __func__);
 	dbg("%s: urb %p port %p has data %p", __func__, urb, port, portdata);
 
 	if (status == 0) {
-		err_times = 0;
 		struct usb_ctrlrequest *req_pkt =
 				(struct usb_ctrlrequest *)urb->transfer_buffer;
 
@@ -1682,17 +1535,9 @@ static void option_instat_callback(struct urb *urb)
 			dbg("%s: type %x req %x", __func__,
 				req_pkt->bRequestType, req_pkt->bRequest);
 		}
-	}
-	else{
-		if(status == -EPROTO && err_times++ >10){
-			err_times = 0;
-			printk("%s,recieve -71 error more than 10 times,so reset usb\n",__FUNCTION__);
-			usb_queue_reset_device(port->serial->interface);
-			return;
-		}else		
-			err("%s : error %d",__func__, status);
-	}
-	
+	} else
+		err("%s: error %d", __func__, status);
+
 	/* Resubmit urb so we continue receiving IRQ data */
 	if (status != -ESHUTDOWN && status != -ENOENT) {
 		err = usb_submit_urb(urb, GFP_ATOMIC);
@@ -1730,34 +1575,9 @@ static int option_send_setup(struct usb_serial_port *port)
 	if (portdata->rts_state)
 		val |= 0x02;
 
- return usb_control_msg(serial->dev,
-        usb_rcvctrlpipe(serial->dev, 0),
-         0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
- }
-		
-static int viatelecom_send_setup(struct usb_serial_port *port)
-{
-			struct usb_serial *serial = port->serial;
-		    struct usb_wwan_port_private *portdata = usb_get_serial_port_data(port);
-		    int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
-			dbg("%s", __func__);
-#if 0
-			usb_control_msg(serial->dev,
-		    usb_sndctrlpipe(serial->dev, 0),
-		    0x01, 0x40, 0, ifNum,
-		    NULL, 0, USB_CTRL_SET_TIMEOUT);
-			/* VIA-Telecom CBP DTR format */
-			return usb_control_msg(serial->dev,
-	        usb_sndctrlpipe(serial->dev, 0),
-		    0x01, 0x40, 1, ifNum,
-		    NULL, 0, USB_CTRL_SET_TIMEOUT);
-#else
-		/* VIA-Telecom CBP DTR format */
-		   return usb_control_msg(serial->dev,
-	       usb_sndctrlpipe(serial->dev, 0),
-		   0x01, 0x40, portdata->dtr_state? 1: 0, ifNum,
-		   NULL, 0, USB_CTRL_SET_TIMEOUT);
-#endif
+	return usb_control_msg(serial->dev,
+		usb_rcvctrlpipe(serial->dev, 0),
+		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
 }
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 2a1ad9c70af7..637dfa4efb5b 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -36,17 +36,13 @@
 #include <linux/usb/serial.h>
 #include <linux/kfifo.h>
 #include "pl2303.h"
-#include <linux/bp-auto.h>
-
 
 /*
  * Version Information
  */
 #define DRIVER_AUTHOR "Greg Kroah-Hartman, greg@kroah.com, http://www.kroah.com/linux/"
 #define DRIVER_DESC "USB Serial Driver core"
-#ifdef CONFIG_BP_AUTO
-extern int get_current_bp_id();
-#endif
+
 /* Driver structure we register with the USB core */
 static struct usb_driver usb_serial_driver = {
 	.name =		"usbserial",
@@ -57,11 +53,6 @@ static struct usb_driver usb_serial_driver = {
 	.no_dynamic_id = 	1,
 	.supports_autosuspend =	1,
 };
-#ifdef CONFIG_BP_AUTO
-static int BP_USB = 0;
-#define BP_USB_PORT     (SERIAL_TTY_MINORS - 10)
-#endif
-
 
 /* There is no MODULE_DEVICE_TABLE for usbserial.c.  Instead
    the MODULE_DEVICE_TABLE declarations in each serial driver
@@ -106,18 +97,12 @@ static struct usb_serial *get_free_serial(struct usb_serial *serial,
 {
 	unsigned int i, j;
 	int good_spot;
-	int a=0;
 
 	dbg("%s %d", __func__, num_ports);
 
 	*minor = 0;
 	mutex_lock(&table_lock);
-#ifdef CONFIG_BP_AUTO
-	if (BP_USB)
-		a= BP_USB_PORT;
-#endif
-
-	for (i = a; i < SERIAL_TTY_MINORS; ++i) {
+	for (i = 0; i < SERIAL_TTY_MINORS; ++i) {
 		if (serial_table[i])
 			continue;
 
@@ -1075,25 +1060,6 @@ int usb_serial_probe(struct usb_interface *interface,
 	} else {
 		serial->attached = 1;
 	}
-#ifdef CONFIG_BP_AUTO
-		int bp_id = get_current_bp_id();
-		if (((le16_to_cpu(dev->descriptor.idVendor) == 0x12D1 ) && (le16_to_cpu(dev->descriptor.idProduct) == 0x1001) && (bp_id == BP_ID_MU509))
-			|| ((le16_to_cpu(dev->descriptor.idVendor) == 0x19f5) && (le16_to_cpu(dev->descriptor.idProduct) == 0x9013) && (bp_id == BP_ID_MW100))			
-			|| ((le16_to_cpu(dev->descriptor.idVendor) == 0x0E8D) && (le16_to_cpu(dev->descriptor.idProduct) == 0x00A2) && (bp_id == BP_ID_MT6229))
-			|| ((le16_to_cpu(dev->descriptor.idVendor) == 0x1782) && (le16_to_cpu(dev->descriptor.idProduct) == 0x0002) && (bp_id == BP_ID_U7501))
-			|| ((le16_to_cpu(dev->descriptor.idVendor) == 0x1782) && (le16_to_cpu(dev->descriptor.idProduct) == 0x4D00) && (bp_id == BP_ID_U7501))
-			|| ((le16_to_cpu(dev->descriptor.idVendor) == 0x21f5) && (le16_to_cpu(dev->descriptor.idProduct) == 0x2012) && (bp_id == BP_ID_SEW290))
-			|| ((le16_to_cpu(dev->descriptor.idVendor) == 0x1c9e) && (le16_to_cpu(dev->descriptor.idProduct) == 0x9603) && (bp_id == BP_ID_U5501))
-			|| ((le16_to_cpu(dev->descriptor.idVendor) == 0x12d1) && (le16_to_cpu(dev->descriptor.idProduct) == 0x1506) && (bp_id == BP_ID_E1230S)) 
-		){
-			BP_USB =1;
-
-		}
-		else{
-			BP_USB = 0;
-		}
-		
-#endif
 
 	/* Avoid race with tty_open and serial_install by setting the
 	 * disconnected flag and not clearing it until all ports have been
diff --git a/drivers/usb/storage/initializers.c b/drivers/usb/storage/initializers.c
index e707d6550ec5..16b0bf055eeb 100644
--- a/drivers/usb/storage/initializers.c
+++ b/drivers/usb/storage/initializers.c
@@ -112,21 +112,7 @@ static int usb_stor_huawei_feature_init(struct us_data *us)
  * So it is  unnecessary to read its response.
  */
 static int usb_stor_huawei_scsi_init(struct us_data *us)
-{   
-    int idProduct;
-	idProduct = us->pusb_dev->descriptor.idProduct;
-	if(idProduct==0x1F01){
-	//printk("This is SCSI HUAWEI HILINK Dongle\n");
-	int result = 0;
-    int act_len = 0;
-	unsigned  char  cmd[32] =  {0x55,  0x53, 0x42,  0x43,  0x00, 0x00,  0x00, 0x00,
-	                            0x00,  0x00, 0x00,  0x00,  0x00,  0x00,  0x00, 0x11,
-	                            0x06,  0x30, 0x00,  0x00,  0x01,  0x00,  0x01, 0x00,
-	                            0x00,  0x00, 0x00,  0x00,  0x00,  0x00, 0x00};
-	 result = usb_stor_bulk_transfer_buf (us, us->send_bulk_pipe, cmd, 31, &act_len);
-	 printk("usb_stor_bulk_transfer_buf performing result is %d, transfer the actual length=%d\n", result, act_len);
-	 return result;
-	}else{
+{
 	int result = 0;
 	int act_len = 0;
 	struct bulk_cb_wrap *bcbw = (struct bulk_cb_wrap *) us->iobuf;
@@ -145,7 +131,6 @@ static int usb_stor_huawei_scsi_init(struct us_data *us)
 					US_BULK_CB_WRAP_LEN, &act_len);
 	US_DEBUGP("transfer actual length=%d, result=%d\n", act_len, result);
 	return result;
-	}
 }
 
 /*
@@ -191,30 +176,3 @@ int usb_stor_huawei_init(struct us_data *us)
 	}
 	return result;
 }
-
-int usb_stor_zte_k4505_init(struct us_data *us)
- {
-		int result = 0;
-		int act_len = 0;
-		unsigned char cmd[32] = {
-				 0x55,0x53,0x42,0x43,0x12,0x34,0x56,0x78,
-				 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x1b,
-				 0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,
-				 0x00,0x00,0x00,0x00,0x00,0x00,0x00
-				 };
-		result = usb_stor_bulk_transfer_buf (us, us->send_bulk_pipe, cmd, 31,&act_len);
-	    printk("usb_stor_bulk_transfer_buf performing result is %d, transfer the actual length=%d\n", result, act_len);
-		return (result ? 0 : -ENODEV);
-}
-
-int usb_stor_zte_init(struct us_data *us)
-{
-	     int result;
-		 result =usb_stor_control_msg(us,us->send_ctrl_pipe,
-		                                     0xA1,
-		                                     0xC0,
-		                                     0x01,0x0,NULL,0x0,1000);
-		 printk("usb_stor_zte_int result is %d\n",result);
-		 return 0;
-}
-
diff --git a/drivers/usb/storage/initializers.h b/drivers/usb/storage/initializers.h
index ec6ea761e3ba..5376d4fc76f0 100644
--- a/drivers/usb/storage/initializers.h
+++ b/drivers/usb/storage/initializers.h
@@ -48,7 +48,3 @@ int usb_stor_ucr61s2b_init(struct us_data *us);
 
 /* This places the HUAWEI usb dongles in multi-port mode */
 int usb_stor_huawei_init(struct us_data *us);
-
-int usb_stor_zte_k4505_init(struct us_data *us);
-
-int usb_stor_zte_init(struct us_data *us);
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 1fc5ab252059..12640efcf82d 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1521,55 +1521,6 @@ UNUSUAL_VENDOR_INTF(0x12d1, 0x08, 0x06, 0x50,
 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_init,
 		0),
 
-UNUSUAL_DEV(0x19d2, 0x1007, 0x0000, 0xffff,
-         "ZTE EJECT CDROM",
-         "USB MMC Storage",
-         USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_k4505_init,
-        0),
-UNUSUAL_DEV(0x19d2, 0x1175, 0x0000, 0xffff,
-          "ZTE EJECT CDROM",
-          "USB MMC Storage",
-          USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_k4505_init,
-         0),
-UNUSUAL_DEV(0x19d2, 0x0101, 0x0000, 0xffff,
-          "ZTE EJECT CDROM",
-		  "USB MMC Storage",
-          USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_k4505_init,
-         0),
-
-UNUSUAL_DEV(0x19d2, 0x1225, 0x0000, 0x0000,
-           "ZTE EJECT CDROM",
-		    "USB MMC Storage",
-	         USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_init,
-			0),
-
-UNUSUAL_DEV(0x19d2, 0x1239, 0x0000, 0x0000,
-			  "ZTE EJECT CDROM",
-	          "USB MMC Storage",
-			   USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_init,
-		     0),
-
-UNUSUAL_DEV(0x19d2, 0x1240, 0x0000, 0x0000,
-			 "ZTE EJECT CDROM",
-			 "USB MMC Storage",									
-			 USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_init,
-		    0),
-
-UNUSUAL_DEV(0x19d2, 0x1241, 0x0000, 0x0000,
-           "ZTE EJECT CDROM",
-		    "USB MMC Storage",
-		    USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_init,
-		   0),
-UNUSUAL_DEV(0x19d2, 0x1242, 0x0000, 0x0000,
-            "ZTE EJECT CDROM",
-             "USB MMC Storage",
-             USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_init,
-            0),
-UNUSUAL_DEV(0x19d2, 0x1243, 0x0000, 0x0000,
-            "ZTE EJECT CDROM",
-             "USB MMC Storage",
-             USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_init,
-           0),
 /* Reported by Vilius Bilinkevicius <vilisas AT xxx DOT lt) */
 UNUSUAL_DEV(  0x132b, 0x000b, 0x0001, 0x0001,
 		"Minolta",
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index e80f4fe57571..4c85a4b15f97 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -32,7 +32,7 @@ config VGASTATE
 config VIDEO_OUTPUT_CONTROL
 	tristate "Lowlevel video output switch controls"
 	help
-	  This framework adds support for low-level control of the video
+	  This framework adds support for low-level control of the video 
 	  output switch.
 
 menuconfig FB
@@ -684,7 +684,7 @@ config FB_STI
 	  BIOS routines contained in a ROM chip in HP PA-RISC based machines.
 	  Enabling this option will implement the linux framebuffer device
 	  using calls to the STI BIOS routines for initialisation.
-
+	
 	  If you enable this option, you will get a planar framebuffer device
 	  /dev/fb which will work on the most common HP graphic cards of the
 	  NGLE family, including the artist chips (in the 7xx and Bxxx series),
@@ -1125,36 +1125,36 @@ config FB_I810
 	select FB_CFB_IMAGEBLIT
 	select VGASTATE
 	help
-	  This driver supports the on-board graphics built in to the Intel 810
+	  This driver supports the on-board graphics built in to the Intel 810 
           and 815 chipsets.  Say Y if you have and plan to use such a board.
 
           To compile this driver as a module, choose M here: the
 	  module will be called i810fb.
 
-          For more information, please read
+          For more information, please read 
 	  <file:Documentation/fb/intel810.txt>
 
 config FB_I810_GTF
 	bool "use VESA Generalized Timing Formula"
 	depends on FB_I810
 	help
-	  If you say Y, then the VESA standard, Generalized Timing Formula
+	  If you say Y, then the VESA standard, Generalized Timing Formula 
           or GTF, will be used to calculate the required video timing values
-	  per video mode.  Since the GTF allows nondiscrete timings
+	  per video mode.  Since the GTF allows nondiscrete timings 
           (nondiscrete being a range of values as opposed to discrete being a
-          set of values), you'll be able to use any combination of horizontal
+          set of values), you'll be able to use any combination of horizontal 
 	  and vertical resolutions, and vertical refresh rates without having
 	  to specify your own timing parameters.  This is especially useful
-	  to maximize the performance of an aging display, or if you just
-          have a display with nonstandard dimensions. A VESA compliant
+	  to maximize the performance of an aging display, or if you just 
+          have a display with nonstandard dimensions. A VESA compliant 
 	  monitor is recommended, but can still work with non-compliant ones.
-	  If you need or want this, then select this option. The timings may
-	  not be compliant with Intel's recommended values. Use at your own
+	  If you need or want this, then select this option. The timings may 
+	  not be compliant with Intel's recommended values. Use at your own 
 	  risk.
 
-          If you say N, the driver will revert to discrete video timings
+          If you say N, the driver will revert to discrete video timings 
 	  using a set recommended by Intel in their documentation.
-
+  
           If unsure, say N.
 
 config FB_I810_I2C
@@ -1272,10 +1272,10 @@ config FB_MATROX_G
 	  G450/G550 secondary head and digital output are supported without
 	  additional modules.
 
-	  The driver starts in monitor mode. You must use the matroxset tool
-	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to
-	  swap primary and secondary head outputs, or to change output mode.
-	  Secondary head driver always start in 640x480 resolution and you
+	  The driver starts in monitor mode. You must use the matroxset tool 
+	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
+	  swap primary and secondary head outputs, or to change output mode.  
+	  Secondary head driver always start in 640x480 resolution and you 
 	  must use fbset to change it.
 
 	  Do not forget that second head supports only 16 and 32 bpp
@@ -1358,7 +1358,7 @@ config FB_RADEON_I2C
 	select FB_DDC
 	default y
 	help
-	  Say Y here if you want DDC/I2C support for your Radeon board.
+	  Say Y here if you want DDC/I2C support for your Radeon board. 
 
 config FB_RADEON_BACKLIGHT
 	bool "Support for backlight control"
@@ -1592,7 +1592,7 @@ config FB_NEOMAGIC
 	select VGASTATE
 	help
 	  This driver supports notebooks with NeoMagic PCI chips.
-	  Say Y if you have such a graphics card.
+	  Say Y if you have such a graphics card. 
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called neofb.
@@ -1647,7 +1647,7 @@ config FB_VOODOO1
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 	---help---
-	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or
+	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or 
 	  Voodoo2 (cvg) based graphics card.
 
 	  To compile this driver as a module, choose M here: the
@@ -2074,54 +2074,6 @@ config FB_S3C2410_DEBUG
 	  Turn on debugging messages. Note that you can set/unset at run time
 	  through sysfs
 
-config FB_RK29
-	tristate "RK29 lcd control"
-	depends on FB
-	select FB_CFB_FILLRECT
-	select FB_CFB_COPYAREA
-	select FB_CFB_IMAGEBLIT
-	---help---
-	  Framebuffer driver for RK29 Platform,select it if you using rk29
-
-config FB_WORK_IPP
-	bool "fb use ipp to scale UI or rotate video"
-	depends on FB_RK29
-	---help---
-	   this function be used scale-up UI when video, it only support RGB565 UI;
-	   it can use to rotate video .
-
-config FB_SCALING_OSD
-	bool "fb scale OSD support when video playing "
-	depends on FB_WORK_IPP
-	---help---
-	   this function be used scale-up UI when video, it only support RGB565 UI;
-
-config FB_SCALING_OSD_1080P
-	bool "fb scale OSD support when video playing in 1080P "
-	depends on FB_WORK_IPP && FB_SCALING_OSD
-	---help---
-	   this function be used scale-up UI when video, it only support RGB565 UI;
-	   should set SCALE_UI_1080P_VIDEO to 1 in android
-config FB_ROTATE_VIDEO
-	bool "fb video rotate support"
-	depends on FB_WORK_IPP
-	---help---
-		this function  can use to rotate video .
-config FB_MIRROR_X_Y
-	bool "fb video rotate support x y mirror"
-	depends on FB_ROTATE_VIDEO
-	---help---
-		this function  can use to x y mirror video .
-config CLOSE_WIN1_DYNAMIC
-	bool "close win1 dynamically when video"
-	depends on FB_RK29
-	---help---
-		this function  can close win1 when video and it have no data in fb0
-
-config FB_WIMO
-	bool "WiMo support"
-	depends on FB_RK29
-
 config FB_NUC900
         bool "NUC900 LCD framebuffer support"
         depends on FB && ARCH_W90X900
@@ -2439,14 +2391,6 @@ source "drivers/video/omap2/Kconfig"
 source "drivers/video/backlight/Kconfig"
 source "drivers/video/display/Kconfig"
 
-if ARCH_RK29
-source "drivers/video/hdmi/Kconfig"
-endif
-
-if !ARCH_RK29
-source "drivers/video/rockchip/Kconfig"
-endif
-
 if VT
 	source "drivers/video/console/Kconfig"
 endif
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 396a1ff6ef5b..8b83129e209c 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -6,21 +6,14 @@
 
 obj-$(CONFIG_VGASTATE)            += vgastate.o
 obj-y                             += fb_notify.o
-
 obj-$(CONFIG_FB)                  += fb.o
-ifdef CONFIG_MACH_RK29_2906
-fb.o: fb.uu
-	@echo "UUDE    fb.uu"
-	@uudecode fb.uu -o fb.o
-else
 fb-y                              := fbmem.o fbmon.o fbcmap.o fbsysfs.o \
                                      modedb.o fbcvt.o
 fb-objs                           := $(fb-y)
-endif
 
 obj-$(CONFIG_VT)		  += console/
 obj-$(CONFIG_LOGO)		  += logo/
-obj-y				  += backlight/ display/ hdmi/
+obj-y				  += backlight/ display/
 
 obj-$(CONFIG_FB_CFB_FILLRECT)  += cfbfillrect.o
 obj-$(CONFIG_FB_CFB_COPYAREA)  += cfbcopyarea.o
@@ -132,8 +125,6 @@ obj-$(CONFIG_FB_PNX4008_DUM)	  += pnx4008/
 obj-$(CONFIG_FB_PNX4008_DUM_RGB)  += pnx4008/
 obj-$(CONFIG_FB_IBM_GXT4500)	  += gxt4500.o
 obj-$(CONFIG_FB_PS3)		  += ps3fb.o
-obj-$(CONFIG_FB_RK29)             += rk29_fb.o
-obj-y                             += rockchip/
 obj-$(CONFIG_FB_SM501)            += sm501fb.o
 obj-$(CONFIG_FB_UDL)		  += udlfb.o
 obj-$(CONFIG_FB_XILINX)           += xilinxfb.o
diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index bf0ee0776aaa..2d93c8d61ad5 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -290,39 +290,6 @@ config BACKLIGHT_ADP5520
 	  To compile this driver as a module, choose M here: the module will
 	  be called adp5520_bl.
 
-config BACKLIGHT_RK2818_BL
-        bool "rk2818 backlight driver"
-	depends on BACKLIGHT_CLASS_DEVICE && ARCH_RK2818
-	default y
-	help
-	  rk2818 backlight support.
-	  
-config BACKLIGHT_RK29_BL
-        bool "rk backlight driver"
-	depends on BACKLIGHT_CLASS_DEVICE && PLAT_RK
-	default y
-	help
-	  rk29 backlight support.	  
-
-config FIH_TOUCHKEY_LED
-        bool "fih touch key led driver"
-	depends on BACKLIGHT_CLASS_DEVICE && ARCH_RK29
-	help
-	  fih touch key led support.
-
-config BACKLIGHT_AW9364
-        bool "aw9364 backlight driver"
-	depends on BACKLIGHT_CLASS_DEVICE
-	help
-	  aw9364 backlight support.	 
-
-config BUTTON_LIGHT
-        bool "rk29 button light driver"
-	depends on BACKLIGHT_CLASS_DEVICE
-	default n
-	help
-	  rk29 button light support.	  
- 
 config BACKLIGHT_ADP8860
 	tristate "Backlight Driver for ADP8860/ADP8861/ADP8863 using WLED"
 	depends on BACKLIGHT_CLASS_DEVICE && I2C
diff --git a/drivers/video/backlight/Makefile b/drivers/video/backlight/Makefile
index f0595828eddd..ee72adb8786e 100644
--- a/drivers/video/backlight/Makefile
+++ b/drivers/video/backlight/Makefile
@@ -33,10 +33,6 @@ obj-$(CONFIG_BACKLIGHT_SAHARA)	+= kb3886_bl.o
 obj-$(CONFIG_BACKLIGHT_WM831X)	+= wm831x_bl.o
 obj-$(CONFIG_BACKLIGHT_ADX)    += adx_bl.o
 obj-$(CONFIG_BACKLIGHT_ADP5520)	+= adp5520_bl.o
-obj-$(CONFIG_BACKLIGHT_RK29_BL)	+= rk29_backlight.o
-obj-$(CONFIG_BACKLIGHT_AW9364)	+= aw9364_bl.o
-obj-$(CONFIG_FIH_TOUCHKEY_LED)	+= fih_touchkey_led.o
-obj-$(CONFIG_BUTTON_LIGHT)	+= rk29_buttonlight.o
 obj-$(CONFIG_BACKLIGHT_ADP8860)	+= adp8860_bl.o
 obj-$(CONFIG_BACKLIGHT_ADP8870)	+= adp8870_bl.o
 obj-$(CONFIG_BACKLIGHT_88PM860X) += 88pm860x_bl.o
diff --git a/drivers/video/backlight/wm831x_bl.c b/drivers/video/backlight/wm831x_bl.c
index ca6d6b9cd2fc..d4c6eb248ff9 100644
--- a/drivers/video/backlight/wm831x_bl.c
+++ b/drivers/video/backlight/wm831x_bl.c
@@ -18,46 +18,21 @@
 #include <linux/mfd/wm831x/core.h>
 #include <linux/mfd/wm831x/pdata.h>
 #include <linux/mfd/wm831x/regulator.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-#include <linux/delay.h>
-#include <linux/ktime.h>
-#define BL_SET   255
-#define BL_MISC_VALUE 20
-#define BL_INIT_VALUE 102
+
 struct wm831x_backlight_data {
 	struct wm831x *wm831x;
 	int isink_reg;
 	int current_brightness;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	struct 	early_suspend early_suspend;
-	struct delayed_work work;
-	int suspend_flag;
-	int shutdown_flag;
-#endif
 };
-#define TS_POLL_DELAY (10000*1000*1000)
-int wm831x_bright = 0;
-int max_tp = 0;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static struct backlight_device *gwm831x_bl;
-static struct wm831x_backlight_data *gwm831x_data;
-#endif
+
 static int wm831x_backlight_set(struct backlight_device *bl, int brightness)
 {
 	struct wm831x_backlight_data *data = bl_get_data(bl);
 	struct wm831x *wm831x = data->wm831x;
-//	int power_up = !data->current_brightness && brightness;
-//	int power_down = data->current_brightness && !brightness;
-	int power_up;
-	int power_down;
+	int power_up = !data->current_brightness && brightness;
+	int power_down = data->current_brightness && !brightness;
 	int ret;
-	int bright_tp;
 
-	bright_tp =( max_tp*brightness)/BL_SET;
-	power_up =!data->current_brightness && bright_tp;
-	power_down = data->current_brightness && !bright_tp;
 	if (power_up) {
 		/* Enable the ISINK */
 		ret = wm831x_set_bits(wm831x, data->isink_reg,
@@ -88,7 +63,7 @@ static int wm831x_backlight_set(struct backlight_device *bl, int brightness)
 
 	/* Set the new brightness */
 	ret = wm831x_set_bits(wm831x, data->isink_reg,
-			      WM831X_CS1_ISEL_MASK, bright_tp);
+			      WM831X_CS1_ISEL_MASK, brightness);
 	if (ret < 0)
 		goto err;
 
@@ -119,21 +94,7 @@ static int wm831x_backlight_set(struct backlight_device *bl, int brightness)
 static int wm831x_backlight_update_status(struct backlight_device *bl)
 {
 	int brightness = bl->props.brightness;
-	if (brightness<=BL_MISC_VALUE) {
-		brightness = 8*brightness;
-	}
-	else if (brightness<=BL_INIT_VALUE) {
-		brightness = 31*brightness/41 + 145;
-	}
-	else {
-		brightness = 33*brightness/153 + 200;
-	}
 
-	if(gwm831x_data->suspend_flag == 1)
-		brightness = 0;
-	if (gwm831x_data->shutdown_flag == 1)
-		brightness = 0;
-		
 	if (bl->props.power != FB_BLANK_UNBLANK)
 		brightness = 0;
 
@@ -143,8 +104,6 @@ static int wm831x_backlight_update_status(struct backlight_device *bl)
 	if (bl->props.state & BL_CORE_SUSPENDED)
 		brightness = 0;
 
-	printk("backlight brightness=%d\n", brightness);
-
 	return wm831x_backlight_set(bl, brightness);
 }
 
@@ -154,45 +113,11 @@ static int wm831x_backlight_get_brightness(struct backlight_device *bl)
 	return data->current_brightness;
 }
 
-static struct backlight_ops wm831x_backlight_ops = {
+static const struct backlight_ops wm831x_backlight_ops = {
 	.options = BL_CORE_SUSPENDRESUME,
 	.update_status	= wm831x_backlight_update_status,
 	.get_brightness	= wm831x_backlight_get_brightness,
 };
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void wm831x_bl_work(struct work_struct *work)
-{
-	//struct wm831x_backlight_data *wm831x_data = container_of(work, struct wm831x_backlight_data,
-						   //work.work);
-	backlight_update_status(gwm831x_bl);
-}
-
-static void wm831x_bl_suspend(struct early_suspend *h)
-{
-	struct wm831x_backlight_data *wm831x_data;
-	wm831x_data = container_of(h, struct wm831x_backlight_data, early_suspend);
-	wm831x_data->suspend_flag = 1;
-
-	schedule_delayed_work(&wm831x_data->work, msecs_to_jiffies(100));		
-}
-
-
-static void wm831x_bl_resume(struct early_suspend *h)
-{
-	struct wm831x_backlight_data *wm831x_data;
-	wm831x_data = container_of(h, struct wm831x_backlight_data, early_suspend);
-	wm831x_data->suspend_flag = 0;
-	
-	schedule_delayed_work(&wm831x_data->work, msecs_to_jiffies(100));
-}
-
-#endif
-
-int rk29_backlight_ctrl(int open)
-{
-	gwm831x_data->suspend_flag = !open;
-	schedule_delayed_work(&gwm831x_data->work, 0);
-}
 
 static int wm831x_backlight_probe(struct platform_device *pdev)
 {
@@ -228,7 +153,7 @@ static int wm831x_backlight_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 	max_isel = i - 1;
-	max_tp = max_isel;
+
 	if (pdata->max_uA != wm831x_isinkv_values[max_isel])
 		dev_warn(&pdev->dev,
 			 "Maximum current is %duA not %duA as requested\n",
@@ -268,36 +193,25 @@ static int wm831x_backlight_probe(struct platform_device *pdev)
 	data->current_brightness = 0;
 	data->isink_reg = isink_reg;
 
+	props.type = BACKLIGHT_RAW;
 	props.max_brightness = max_isel;
 	bl = backlight_device_register("wm831x", &pdev->dev, data,
-				       &wm831x_backlight_ops,NULL);
+				       &wm831x_backlight_ops, &props);
 	if (IS_ERR(bl)) {
 		dev_err(&pdev->dev, "failed to register backlight\n");
 		kfree(data);
 		return PTR_ERR(bl);
 	}
 
-	bl->props.brightness = BL_INIT_VALUE;
-	bl->props.max_brightness= BL_SET;
+	bl->props.brightness = max_isel;
 
 	platform_set_drvdata(pdev, bl);
 
-#ifdef CONFIG_HAS_EARLYSUSPEND	
-	data->early_suspend.level = ~0x0;
-	data->early_suspend.suspend = wm831x_bl_suspend;
-	data->early_suspend.resume = wm831x_bl_resume;
-	register_early_suspend(&data->early_suspend);
-	INIT_DELAYED_WORK(&data->work, wm831x_bl_work);
-	gwm831x_bl = bl;
-	gwm831x_data = data;
-#endif
-
-
 	/* Disable the DCDC if it was started so we can bootstrap */
 	wm831x_set_bits(wm831x, WM831X_DCDC_ENABLE, WM831X_DC4_ENA, 0);
 
-	//backlight_update_status(bl);
-	schedule_delayed_work(&data->work, msecs_to_jiffies(100));
+
+	backlight_update_status(bl);
 
 	return 0;
 }
@@ -308,24 +222,10 @@ static int wm831x_backlight_remove(struct platform_device *pdev)
 	struct wm831x_backlight_data *data = bl_get_data(bl);
 
 	backlight_device_unregister(bl);
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	unregister_early_suspend(&data->early_suspend);
-#endif 
 	kfree(data);
 	return 0;
 }
 
-static void wm831x_backlight_shutdown(struct platform_device *pdev)
-{
-	struct backlight_device *bl = platform_get_drvdata(pdev);
-	struct wm831x_backlight_data *data = bl_get_data(bl);
-	
-	printk("enter %s\n", __func__);
-	data->shutdown_flag = 1;
-	wm831x_backlight_update_status(bl);
-	return;
-}
-
 static struct platform_driver wm831x_backlight_driver = {
 	.driver		= {
 		.name	= "wm831x-backlight",
@@ -333,7 +233,6 @@ static struct platform_driver wm831x_backlight_driver = {
 	},
 	.probe		= wm831x_backlight_probe,
 	.remove		= wm831x_backlight_remove,
-	.shutdown	= wm831x_backlight_shutdown,
 };
 
 static int __init wm831x_backlight_init(void)
diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c
index 2a1d25593e72..bf9a9b773de0 100644
--- a/drivers/video/console/fbcon.c
+++ b/drivers/video/console/fbcon.c
@@ -3578,7 +3578,7 @@ static int __init fb_console_init(void)
 	return 0;
 }
 
-subsys_initcall(fb_console_init);
+module_init(fb_console_init);
 
 #ifdef MODULE
 
diff --git a/drivers/video/display/Kconfig b/drivers/video/display/Kconfig
index 5a4d40d5c05f..f99af931d4f8 100644
--- a/drivers/video/display/Kconfig
+++ b/drivers/video/display/Kconfig
@@ -6,7 +6,6 @@ menu "Display device support"
 
 config DISPLAY_SUPPORT
 	tristate "Display panel/monitor support"
-	depends on FB_RK29 || FB_ROCKCHIP
 	---help---
 	  This framework adds support for low-level control of a display.
 	  This includes support for power.
@@ -21,8 +20,5 @@ config DISPLAY_SUPPORT
 
 comment "Display hardware drivers"
 	depends on DISPLAY_SUPPORT
-if ARCH_RK29
-source "drivers/video/display/screen/Kconfig"
-endif
-endmenu
 
+endmenu
diff --git a/drivers/video/display/Makefile b/drivers/video/display/Makefile
index 07dea7485244..c0ea832bf171 100644
--- a/drivers/video/display/Makefile
+++ b/drivers/video/display/Makefile
@@ -1,5 +1,6 @@
 # Display drivers
 
-display-objs				:= display-sys.o
+display-objs				:= display-sysfs.o
 
 obj-$(CONFIG_DISPLAY_SUPPORT)		+= display.o
+
diff --git a/drivers/video/fbmem.c b/drivers/video/fbmem.c
index b8d6aa47d53d..7a41220aebdd 100644
--- a/drivers/video/fbmem.c
+++ b/drivers/video/fbmem.c
@@ -41,10 +41,6 @@
      */
 
 #define FBPIXMAPSIZE	(1024 * 8)
-__weak int get_battery_status(void)
-{
-	return 0;
-}
 
 static DEFINE_MUTEX(registration_lock);
 struct fb_info *registered_fb[FB_MAX] __read_mostly;
@@ -358,12 +354,6 @@ static struct logo_data {
 	const struct linux_logo *logo;
 } fb_logo __read_mostly;
 
-void fb_show_charge_logo(struct linux_logo *logo)
-{
-	fb_logo.logo = logo;
-	return;
-}
-
 static void fb_rotate_logo_ud(const u8 *in, u8 *out, u32 width, u32 height)
 {
 	u32 size = width * height, i;
@@ -503,18 +493,8 @@ static int fb_show_logo_line(struct fb_info *info, int rotate,
 		fb_set_logo(info, logo, logo_new, fb_logo.depth);
 	}
 
-#ifdef CONFIG_LOGO_LOWERPOWER_WARNING
-	if(1 == get_battery_status()){
-		image.dx = (info->var.xres/2)-(logo->width)/2;
-		image.dy = (info->var.yres/2)-(logo->height)/2;
-	}else{
-		image.dx = 0;
-		image.dy = y;
-	}
-#else
 	image.dx = 0;
 	image.dy = y;
-#endif
 	image.width = logo->width;
 	image.height = logo->height;
 
@@ -678,19 +658,9 @@ int fb_prepare_logo(struct fb_info *info, int rotate)
 int fb_show_logo(struct fb_info *info, int rotate)
 {
 	int y;
-#ifdef CONFIG_LOGO_LOWERPOWER_WARNING
-	if(1 ==  get_battery_status()){
-		y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,
-				     1);
-	}else{
-		y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,
-			      num_online_cpus());
 
-	}
-#else
 	y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,
 			      num_online_cpus());
-#endif
 	y = fb_show_extra_logos(info, y, rotate);
 
 	return y;
@@ -1080,7 +1050,6 @@ fb_blank(struct fb_info *info, int blank)
 
  	return ret;
 }
-int fb_vaddr = 0;
 
 static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,
 			unsigned long arg)
diff --git a/drivers/video/logo/.gitignore b/drivers/video/logo/.gitignore
index aa9df07088af..e48355f538fa 100644
--- a/drivers/video/logo/.gitignore
+++ b/drivers/video/logo/.gitignore
@@ -1,7 +1,6 @@
 #
 # Generated files
 #
-*_bmp.c
 *_mono.c
 *_vga16.c
 *_clut224.c
diff --git a/drivers/video/logo/Kconfig b/drivers/video/logo/Kconfig
index 5a88ce8dd371..39ac49e0682c 100644
--- a/drivers/video/logo/Kconfig
+++ b/drivers/video/logo/Kconfig
@@ -27,10 +27,6 @@ config LOGO_LINUX_CLUT224
 	bool "Standard 224-color Linux logo"
 	default y
 
-config LOGO_PIPO_CLUT224
-	bool "Standard 224-pipo Linux logo"
-	default n
-	
 config LOGO_BLACKFIN_VGA16
 	bool "16-colour Blackfin Processor Linux logo"
 	depends on BLACKFIN
@@ -86,33 +82,4 @@ config LOGO_M32R_CLUT224
 	depends on M32R
 	default y
 
-config LOGO_CHARGER_CLUT224
-        bool "standard 224-color linux logo for rk2918 phone"
-        default n
-
-config LOGO_G3_CLUT224
-	bool "Standard 224-color Linux logo for g3 phone"
-	default n
-
-config LOGO_LINUX_800x480_CLUT224
-        bool "Standard 224-color 800x480 Linux logo "
-        default n
-
-config LOGO_LOWERPOWER_WARNING
-        bool "warning: lowerpower when poweron"
-        default n
-
-menuconfig LOGO_LINUX_BMP
-        bool "Bmp logo support"
-	default n
-
-config LOGO_LINUX_BMP_SUNSET
-	bool "Bmp logo sunset"
-	depends on  LOGO_LINUX_BMP
-	default n
-
-config LOGO_LINUX_BMP_ANDROID
-        bool "Bmp logo android"
-        depends on  LOGO_LINUX_BMP
-        default n
 endif # LOGO
diff --git a/drivers/video/logo/Makefile b/drivers/video/logo/Makefile
index ccae7cc38f3d..3b437813584c 100644
--- a/drivers/video/logo/Makefile
+++ b/drivers/video/logo/Makefile
@@ -4,7 +4,6 @@ obj-$(CONFIG_LOGO)			+= logo.o
 obj-$(CONFIG_LOGO_LINUX_MONO)		+= logo_linux_mono.o
 obj-$(CONFIG_LOGO_LINUX_VGA16)		+= logo_linux_vga16.o
 obj-$(CONFIG_LOGO_LINUX_CLUT224)	+= logo_linux_clut224.o
-obj-$(CONFIG_LOGO_PIPO_CLUT224)	    += logo_pipo_clut224.o
 obj-$(CONFIG_LOGO_BLACKFIN_CLUT224)	+= logo_blackfin_clut224.o
 obj-$(CONFIG_LOGO_BLACKFIN_VGA16)	+= logo_blackfin_vga16.o
 obj-$(CONFIG_LOGO_DEC_CLUT224)		+= logo_dec_clut224.o
@@ -16,13 +15,6 @@ obj-$(CONFIG_LOGO_SUPERH_MONO)		+= logo_superh_mono.o
 obj-$(CONFIG_LOGO_SUPERH_VGA16)		+= logo_superh_vga16.o
 obj-$(CONFIG_LOGO_SUPERH_CLUT224)	+= logo_superh_clut224.o
 obj-$(CONFIG_LOGO_M32R_CLUT224)		+= logo_m32r_clut224.o
-obj-$(CONFIG_LOGO_G3_CLUT224)		+= logo_g3_clut224.o
-obj-$(CONFIG_LOGO_LINUX_800x480_CLUT224)        += logo_linux_800x480_clut224.o
-obj-$(CONFIG_LOGO_LINUX_BMP_SUNSET)	+= logo_sunset_bmp.o
-obj-$(CONFIG_LOGO_LINUX_BMP_ANDROID)     += logo_android_bmp.o
-obj-$(CONFIG_LOGO_LOWERPOWER_WARNING)   += logo_linux_lowerpower_clut224.o
-
-obj-$(CONFIG_LOGO_CHARGER_CLUT224)         += logo_charger00_clut224.o logo_charger01_clut224.o logo_charger02_clut224.o logo_charger03_clut224.o logo_charger04_clut224.o logo_charger05_clut224.o logo_charger06_clut224.o logo_charger07_clut224.o logo_charger08_clut224.o 
 
 obj-$(CONFIG_SPU_BASE)			+= logo_spe_clut224.o
 
@@ -45,9 +37,6 @@ extra-y += $(call logo-cfiles,_clut224,ppm)
 # Gray 256
 extra-y += $(call logo-cfiles,_gray256,pgm)
 
-extra-y += $(call logo-cfiles,_bmp,bmp)
-
-bmptologo := scripts/bmptologo
 pnmtologo := scripts/pnmtologo
 
 # Create commands like "pnmtologo -t mono -n logo_mac_mono -o ..."
@@ -56,11 +45,6 @@ quiet_cmd_logo = LOGO    $@
 			-t $(patsubst $*_%,%,$(notdir $(basename $<))) \
 			-n $(notdir $(basename $<)) -o $@ $<
 
-quiet_cmd_bmplogo = LOGO    $@
-	cmd_bmplogo = $(bmptologo) \
-			-t $(patsubst $*_%,%,$(notdir $(basename $<))) \
-			-n $(notdir $(basename $<)) -o $@ $<
-
 $(obj)/%_mono.c: $(src)/%_mono.pbm $(pnmtologo) FORCE
 	$(call if_changed,logo)
 
@@ -73,8 +57,5 @@ $(obj)/%_clut224.c: $(src)/%_clut224.ppm $(pnmtologo) FORCE
 $(obj)/%_gray256.c: $(src)/%_gray256.pgm $(pnmtologo) FORCE
 	$(call if_changed,logo)
 
-$(obj)/%_bmp.c: $(src)/%_bmp.bmp $(bmptologo) FORCE
-	$(call if_changed,bmplogo)
-
 # Files generated that shall be removed upon make clean
-clean-files := *.o *_mono.c *_vga16.c *_clut224.c *_gray256.c *_bmp.c
+clean-files := *.o *_mono.c *_vga16.c *_clut224.c *_gray256.c
diff --git a/drivers/video/logo/logo.c b/drivers/video/logo/logo.c
index a39da141aa02..ea7a8ccc830c 100644
--- a/drivers/video/logo/logo.c
+++ b/drivers/video/logo/logo.c
@@ -25,31 +25,14 @@ static int nologo;
 module_param(nologo, bool, 0);
 MODULE_PARM_DESC(nologo, "Disables startup logo");
 
-extern const struct linux_logo logo_cruz_clut224;
-const unsigned char password[32] = {
-    0x52, 0x4b, 0x20, 0x6c,
-    0x6f, 0x67, 0x6f, 0x20,
-    0x70, 0x61, 0x73, 0x73,
-    0x77, 0x6f, 0x72, 0x64,
-
-    0x31, 0x57, 0x8d, 0xeb,
-    0x18, 0x4b, 0xa9, 0x41,
-    0xd9, 0x47, 0xea, 0x2f,
-    0x7e, 0x60, 0xb1, 0x67
-};
-
 /* logo's are marked __initdata. Use __init_refok to tell
  * modpost that it is intended that this function uses data
  * marked __initdata.
  */
-__weak int get_battery_status(void)
-{
-	return 0;
-}
 const struct linux_logo * __init_refok fb_find_logo(int depth)
 {
-        struct linux_logo *logo = NULL;
-	const struct linux_logo *m_logo = NULL;
+	const struct linux_logo *logo = NULL;
+
 	if (nologo)
 		return NULL;
 
@@ -84,14 +67,6 @@ const struct linux_logo * __init_refok fb_find_logo(int depth)
 		/* Generic Linux logo */
 		logo = &logo_linux_clut224;
 #endif
-#ifdef CONFIG_LOGO_PIPO_CLUT224
-		/* Generic Linux logo */
-		logo = &logo_pipo_clut224;
-#endif
-#ifdef CONFIG_LOGO_G3_CLUT224
-		/* Generic Linux logo */
-		logo = &logo_g3_clut224;
-#endif
 #ifdef CONFIG_LOGO_BLACKFIN_CLUT224
 		/* Blackfin Linux logo */
 		logo = &logo_blackfin_clut224;
@@ -125,43 +100,7 @@ const struct linux_logo * __init_refok fb_find_logo(int depth)
 		/* M32R Linux logo */
 		logo = &logo_m32r_clut224;
 #endif
-#ifdef CONFIG_LOGO_CRUZ_CLUT224
-                logo = &logo_cruz_clut224;
-#endif
-
-#ifdef CONFIG_LOGO_LINUX_800x480_CLUT224
-                logo = &logo_linux_800x480_clut224;
-#endif
-#ifdef CONFIG_LOGO_LOWERPOWER_WARNING
-		if( 1 ==  get_battery_status()){
-			logo = &logo_linux_lowerpower_clut224;
-		}
-#endif 
-
-		if (depth >= 24)
-		{
-			#ifdef  CONFIG_LOGO_LINUX_BMP
-			#ifdef CONFIG_LOGO_LINUX_BMP_SUNSET
-			logo = &logo_sunset_bmp;
-			#endif
-			
-			#ifdef CONFIG_LOGO_LINUX_BMP_ANDROID
-			logo = &logo_android_bmp;
-			#endif
-			
-			#endif	
-		}
-		else
-		{
-	  		logo->width = ((logo->data[0] << 8) + logo->data[1]);
-        		logo->height = ((logo->data[2] << 8) + logo->data[3]);
-        		logo->clutsize = logo->clut[0];
-        		logo->data += 4;
-        		logo->clut += 1;
-		}
 	}
-	m_logo = logo;
-	return m_logo;
-	
+	return logo;
 }
 EXPORT_SYMBOL_GPL(fb_find_logo);
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 8e1f9f8fbbae..21d816e9dfa5 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -73,30 +73,6 @@ config WM8350_WATCHDOG
 
 # ARM Architecture
 
-config RK29_WATCHDOG
-	tristate "RK29 watchdog"
-	help
-	  Watchdog timer embedded into RK29xx chips. This will reboot your
-	  system when the timeout is reached.
-
-config RK29_FEED_DOG_BY_INTE
-	bool "feed watchdog by interrupt"
-	depends on RK29_WATCHDOG
-
-config RK29_WATCHDOG_ATBOOT
-	bool "start watchdog at system boot"
-	depends on RK29_WATCHDOG
-
-config RK29_WATCHDOG_DEFAULT_TIME
-	int "set watchdog time out value (unit second)"
-	depends on RK29_WATCHDOG
-	help
-	  the real time out value is two times more than the setting value
-
-config RK29_WATCHDOG_DEBUG
-	bool "enable watchdog debug"
-	depends on RK29_WATCHDOG
-
 config ARM_SP805_WATCHDOG
 	tristate "ARM SP805 Watchdog"
 	depends on ARM_AMBA
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 78680a4341c3..ed26f7094e47 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -47,7 +47,6 @@ obj-$(CONFIG_COH901327_WATCHDOG) += coh901327_wdt.o
 obj-$(CONFIG_STMP3XXX_WATCHDOG) += stmp3xxx_wdt.o
 obj-$(CONFIG_NUC900_WATCHDOG) += nuc900_wdt.o
 obj-$(CONFIG_ADX_WATCHDOG) += adx_wdt.o
-obj-$(CONFIG_RK29_WATCHDOG) += rk29_wdt.o
 obj-$(CONFIG_TS72XX_WATCHDOG) += ts72xx_wdt.o
 obj-$(CONFIG_IMX2_WDT) += imx2_wdt.o
 
diff --git a/fs/block_dev.c b/fs/block_dev.c
index d6093f91c48c..a580028e2fb8 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -27,8 +27,6 @@
 #include <linux/kmemleak.h>
 #include <asm/uaccess.h>
 #include "internal.h"
-#include <linux/mtd/blktrans.h>
-#include <linux/mtd/mtd.h>
 
 struct bdev_inode {
 	struct block_device bdev;
@@ -1579,85 +1577,12 @@ static const struct address_space_operations def_blk_aops = {
 	.direct_IO	= blkdev_direct_IO,
 };
 
-
-ssize_t mydo_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)
-{
-    unsigned long buf_addr = (unsigned long)buf;
-    if((memcmp(filp->f_mapping->host->i_bdev->bd_disk->disk_name, "mtdblock", 8) == 0) &&(buf_addr >= 0xc0000000))// kernel mem is usb tran &&(buf_addr >= 0xc0000000)
-    {
-        struct mtd_blktrans_dev *dev;
-        struct mtd_blktrans_ops *tr;
-        struct mtd_info *mtd;
-        
-        dev = (filp->f_mapping->host->i_bdev->bd_disk->private_data);
-        mtd = dev->mtd;
-        /*if((buf_addr < 0xc0000000)&&(mtd->name[0]=='u' &&mtd->name[3]=='r' && mtd->name[4]==0)) // user part 
-        {
-            return(do_sync_read(filp, buf,len,ppos));
-        }*/
-        tr = dev->tr;
-		if (!tr->readsect)
-		{
-			return(do_sync_read(filp, buf,len,ppos));
-	    }
-        //printk("mydo_sync_read buf = 0x%lx LBA = 0x%lx len = 0x%x \n",buf, (unsigned long)(*ppos>>9),len);
-        if(tr->readsect(dev, (unsigned long)(*ppos>>9), len>>9, buf))
-        {
-            return 0 ;
-        }
-        *ppos += len;
-        return len;
-    }
-
-    else
-    {
-        return(do_sync_read(filp, buf,len,ppos));
-    }
-}
-
-ssize_t mydo_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
-{
-    unsigned long buf_addr = (unsigned long)buf;
-    if((memcmp(filp->f_mapping->host->i_bdev->bd_disk->disk_name, "mtdblock", 8) == 0) &&(buf_addr >= 0xc0000000))// kernel mem is usb tran &&(buf_addr >= 0xc0000000)
-    {
-        struct mtd_blktrans_dev *dev;
-        struct mtd_blktrans_ops *tr;
-        struct mtd_info *mtd;
-        
-        dev = (filp->f_mapping->host->i_bdev->bd_disk->private_data);
-        
-        mtd = dev->mtd;
-        /*if((buf_addr < 0xc0000000)&&(mtd->name[0]=='u' &&mtd->name[3]=='r' && mtd->name[4]==0))
-        {
-            return(do_sync_write(filp, buf,len,ppos));
-        }*/
-
-        tr = dev->tr;
-
-		if (!tr->writesect)
-			return 0;
-        //printk("mydo_sync_write buf = 0x%lx LBA = 0x%lx len = 0x%x \n",buf, (unsigned long)(*ppos>>9),len);
-        if(tr->writesect(dev, (unsigned long)(*ppos>>9), len>>9, buf))
-        {
-            return 0 ;
-        }
-        *ppos += len;
-        return len;
-    }
-
-    else
-    {
-        return(do_sync_write(filp, buf,len,ppos));
-    }
-}
-
-
 const struct file_operations def_blk_fops = {
 	.open		= blkdev_open,
 	.release	= blkdev_close,
 	.llseek		= block_llseek,
-	.read		= mydo_sync_read,
-	.write		= mydo_sync_write,
+	.read		= do_sync_read,
+	.write		= do_sync_write,
   	.aio_read	= generic_file_aio_read,
 	.aio_write	= blkdev_aio_write,
 	.mmap		= generic_file_mmap,
diff --git a/fs/buffer.c b/fs/buffer.c
index 15b53d1bda81..166028be2296 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -107,7 +107,7 @@ static int quiet_error(struct buffer_head *bh)
 static void buffer_io_error(struct buffer_head *bh)
 {
 	char b[BDEVNAME_SIZE];
-	printk(KERN_DEBUG "Buffer I/O error on device %s, logical block %Lu\n",
+	printk(KERN_ERR "Buffer I/O error on device %s, logical block %Lu\n",
 			bdevname(bh->b_bdev, b),
 			(unsigned long long)bh->b_blocknr);
 }
diff --git a/fs/cramfs/inode.c b/fs/cramfs/inode.c
index 6c929580f327..739fb59bcdc2 100644
--- a/fs/cramfs/inode.c
+++ b/fs/cramfs/inode.c
@@ -339,10 +339,8 @@ static int cramfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 	buf->f_type = CRAMFS_MAGIC;
 	buf->f_bsize = PAGE_CACHE_SIZE;
 	buf->f_blocks = CRAMFS_SB(sb)->blocks;
-	// modify by cmc for cts test
-	buf->f_bfree = 1; // 0
-	buf->f_bavail = 1; // 0
-	// end modify
+	buf->f_bfree = 0;
+	buf->f_bavail = 0;
 	buf->f_files = CRAMFS_SB(sb)->files;
 	buf->f_ffree = 0;
 	buf->f_fsid.val[0] = (u32)id;
diff --git a/fs/fat/dir.c b/fs/fat/dir.c
index 723aa9abbf52..dc563788fa89 100644
--- a/fs/fat/dir.c
+++ b/fs/fat/dir.c
@@ -98,7 +98,7 @@ static int fat__get_entry(struct inode *dir, loff_t *pos,
 
 	*bh = sb_bread(sb, phys);
 	if (*bh == NULL) {
-		fat_msg(sb, KERN_DEBUG, "Directory bread(block %llu) failed",
+		fat_msg(sb, KERN_ERR, "Directory bread(block %llu) failed",
 		       (llu)phys);
 		/* skip this block */
 		*pos = (iblock + 1) << sb->s_blocksize_bits;
diff --git a/fs/fat/fatent.c b/fs/fat/fatent.c
index ee953113a53c..2e81ac0df7e2 100644
--- a/fs/fat/fatent.c
+++ b/fs/fat/fatent.c
@@ -95,7 +95,7 @@ static int fat12_ent_bread(struct super_block *sb, struct fat_entry *fatent,
 err_brelse:
 	brelse(bhs[0]);
 err:
-	fat_msg(sb, KERN_DEBUG, "FAT read failed (blocknr %llu)", (llu)blocknr);
+	fat_msg(sb, KERN_ERR, "FAT read failed (blocknr %llu)", (llu)blocknr);
 	return -EIO;
 }
 
@@ -108,7 +108,7 @@ static int fat_ent_bread(struct super_block *sb, struct fat_entry *fatent,
 	fatent->fat_inode = MSDOS_SB(sb)->fat_inode;
 	fatent->bhs[0] = sb_bread(sb, blocknr);
 	if (!fatent->bhs[0]) {
-		fat_msg(sb, KERN_DEBUG, "FAT read failed (blocknr %llu)",
+		fat_msg(sb, KERN_ERR, "FAT read failed (blocknr %llu)",
 		       (llu)blocknr);
 		return -EIO;
 	}
@@ -348,7 +348,7 @@ int fat_ent_read(struct inode *inode, struct fat_entry *fatent, int entry)
 
 	if (entry < FAT_START_ENT || sbi->max_cluster <= entry) {
 		fatent_brelse(fatent);
-		fat_fs_error_ratelimit(sb, "invalid access to FAT (entry 0x%08x)", entry);
+		fat_fs_error(sb, "invalid access to FAT (entry 0x%08x)", entry);
 		return -EIO;
 	}
 
diff --git a/fs/fat/inode.c b/fs/fat/inode.c
index 959e2d6d6b4b..9836839e0eb4 100644
--- a/fs/fat/inode.c
+++ b/fs/fat/inode.c
@@ -1236,19 +1236,6 @@ static int fat_read_root(struct inode *inode)
 	return 0;
 }
 
-static unsigned long calc_fat_clusters(struct super_block *sb)
-{
-	struct msdos_sb_info *sbi = MSDOS_SB(sb);
-
-	/* Divide first to avoid overflow */
-	if (sbi->fat_bits != 12) {
-		unsigned long ent_per_sec = sb->s_blocksize * 8 / sbi->fat_bits;
-		return ent_per_sec * sbi->fat_length;
-	}
-
-	return sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;
-}
-
 /*
  * Read the super block of an MS-DOS FS.
  */
@@ -1295,7 +1282,7 @@ int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,
 	sb_min_blocksize(sb, 512);
 	bh = sb_bread(sb, 0);
 	if (bh == NULL) {
-		fat_msg(sb, KERN_DEBUG, "unable to read boot sector");
+		fat_msg(sb, KERN_ERR, "unable to read boot sector");
 		goto out_fail;
 	}
 
@@ -1361,7 +1348,7 @@ int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,
 		}
 		bh = sb_bread(sb, 0);
 		if (bh == NULL) {
-			fat_msg(sb, KERN_DEBUG, "unable to read boot sector"
+			fat_msg(sb, KERN_ERR, "unable to read boot sector"
 			       " (logical sector size = %lu)",
 			       sb->s_blocksize);
 			goto out_fail;
@@ -1455,7 +1442,7 @@ int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,
 		sbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;
 
 	/* check that FAT table does not overflow */
-	fat_clusters = calc_fat_clusters(sb);
+	fat_clusters = sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;
 	total_clusters = min(total_clusters, fat_clusters - FAT_START_ENT);
 	if (total_clusters > MAX_FAT(sb)) {
 		if (!silent)
diff --git a/fs/fat/namei_vfat.c b/fs/fat/namei_vfat.c
index 6ee3c367be6e..20b4ea53fdc4 100644
--- a/fs/fat/namei_vfat.c
+++ b/fs/fat/namei_vfat.c
@@ -514,8 +514,7 @@ xlate_to_uni(const unsigned char *name, int len, unsigned char *outname,
 	int charlen;
 
 	if (utf8) {
-		*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,
-				(wchar_t *) outname, FAT_LFN_LEN + 2);
+		*outlen = utf8s_to_utf16s(name, len, (wchar_t *)outname);
 		if (*outlen < 0)
 			return *outlen;
 		else if (*outlen > FAT_LFN_LEN)
diff --git a/fs/nls/nls_base.c b/fs/nls/nls_base.c
index 0eb059ec6f28..44a88a9fa2c8 100644
--- a/fs/nls/nls_base.c
+++ b/fs/nls/nls_base.c
@@ -114,57 +114,34 @@ int utf32_to_utf8(unicode_t u, u8 *s, int maxlen)
 }
 EXPORT_SYMBOL(utf32_to_utf8);
 
-static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)
-{
-	switch (endian) {
-	default:
-		*s = (wchar_t) c;
-		break;
-	case UTF16_LITTLE_ENDIAN:
-		*s = __cpu_to_le16(c);
-		break;
-	case UTF16_BIG_ENDIAN:
-		*s = __cpu_to_be16(c);
-		break;
-	}
-}
-
-int utf8s_to_utf16s(const u8 *s, int len, enum utf16_endian endian,
-		wchar_t *pwcs, int maxlen)
+int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)
 {
 	u16 *op;
 	int size;
 	unicode_t u;
 
 	op = pwcs;
-	while (len > 0 && maxlen > 0 && *s) {
+	while (*s && len > 0) {
 		if (*s & 0x80) {
 			size = utf8_to_utf32(s, len, &u);
 			if (size < 0)
 				return -EINVAL;
-			s += size;
-			len -= size;
 
 			if (u >= PLANE_SIZE) {
-				if (maxlen < 2)
-					break;
 				u -= PLANE_SIZE;
-				put_utf16(op++, SURROGATE_PAIR |
-						((u >> 10) & SURROGATE_BITS),
-						endian);
-				put_utf16(op++, SURROGATE_PAIR |
+				*op++ = (wchar_t) (SURROGATE_PAIR |
+						((u >> 10) & SURROGATE_BITS));
+				*op++ = (wchar_t) (SURROGATE_PAIR |
 						SURROGATE_LOW |
-						(u & SURROGATE_BITS),
-						endian);
-				maxlen -= 2;
+						(u & SURROGATE_BITS));
 			} else {
-				put_utf16(op++, u, endian);
-				maxlen--;
+				*op++ = (wchar_t) u;
 			}
+			s += size;
+			len -= size;
 		} else {
-			put_utf16(op++, *s++, endian);
+			*op++ = *s++;
 			len--;
-			maxlen--;
 		}
 	}
 	return op - pwcs;
diff --git a/fs/partitions/Makefile b/fs/partitions/Makefile
index 6949b185f27f..03af8eac51da 100644
--- a/fs/partitions/Makefile
+++ b/fs/partitions/Makefile
@@ -18,4 +18,3 @@ obj-$(CONFIG_IBM_PARTITION) += ibm.o
 obj-$(CONFIG_EFI_PARTITION) += efi.o
 obj-$(CONFIG_KARMA_PARTITION) += karma.o
 obj-$(CONFIG_SYSV68_PARTITION) += sysv68.o
-obj-$(CONFIG_EMMC_RK) += mtdpart.o
diff --git a/fs/partitions/check.c b/fs/partitions/check.c
index af94769ed638..811960a5ef6f 100644
--- a/fs/partitions/check.c
+++ b/fs/partitions/check.c
@@ -38,7 +38,6 @@
 #include "efi.h"
 #include "karma.h"
 #include "sysv68.h"
-#include "mtdpart.h"
 
 #ifdef CONFIG_BLK_DEV_MD
 extern void md_autodetect_dev(dev_t dev);
@@ -113,10 +112,6 @@ static int (*check_part[])(struct parsed_partitions *) = {
 #ifdef CONFIG_SYSV68_PARTITION
 	sysv68_partition,
 #endif
-#ifdef CONFIG_EMMC_RK
-       mtdpart_partition,
-#endif
-
 	NULL
 };
  
@@ -562,16 +557,7 @@ static int drop_partitions(struct gendisk *disk, struct block_device *bdev)
 	int res;
 
 	if (bdev->bd_part_count)
-	{
-	#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
-	    if(179 == MAJOR(bdev->bd_dev))
-	    {
-	        printk(KERN_INFO "%s: The sdcard partition have been using.So device busy! \n",__FUNCTION__);
-	    }
-	#endif    
-	    
 		return -EBUSY;
-	}
 	res = invalidate_partition(disk, 0);
 	if (res)
 		return res;
@@ -604,16 +590,7 @@ int rescan_partitions(struct gendisk *disk, struct block_device *bdev)
 	check_disk_size_change(disk, bdev);
 	bdev->bd_invalidated = 0;
 	if (!get_capacity(disk) || !(state = check_partition(disk, bdev)))
-	{
-	#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
-	    if(179 == MAJOR(bdev->bd_dev))
-	    {
-	        printk(KERN_INFO "%s: check partition fail. partitionAddr=%lx.\n",
-				__FUNCTION__, (unsigned long)state);
-	    }
-	 #endif   	    
 		return 0;
-	}
 	if (IS_ERR(state)) {
 		/*
 		 * I/O error reading the partition table.  If any
diff --git a/fs/partitions/msdos.c b/fs/partitions/msdos.c
index 649d27be8af8..5f79a6677c69 100644
--- a/fs/partitions/msdos.c
+++ b/fs/partitions/msdos.c
@@ -431,20 +431,12 @@ static struct {
  
 int msdos_partition(struct parsed_partitions *state)
 {
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-	const struct block_device *bdev = state->bdev;
-#endif
 	sector_t sector_size = bdev_logical_block_size(state->bdev) / 512;
 	Sector sect;
 	unsigned char *data;
 	struct partition *p;
 	struct fat_boot_sector *fb;
 	int slot;
-#ifdef CONFIG_EMMC_RK
-	//if card is emmc(flag:2 is set in 'drivers/mmc/card/block.c'), return false
-	if(state->bdev->bd_disk->flags & 2)
-		return 0;
-#endif
 
 	data = read_part_sector(state, 0, &sect);
 	if (!data)
@@ -460,13 +452,6 @@ int msdos_partition(struct parsed_partitions *state)
 		return 0;
 	}
 
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
-    if(179 == MAJOR(bdev->bd_dev))
-    {
-	    printk(KERN_INFO "\n%s..%d... ==== Begin to parse sdcard-partition.  [mmc0]\n",__FUNCTION__, __LINE__);
-	}
-#endif
-
 	/*
 	 * Now that the 55aa signature is present, this is probably
 	 * either the boot sector of a FAT filesystem or a DOS-type
@@ -476,12 +461,6 @@ int msdos_partition(struct parsed_partitions *state)
 	p = (struct partition *) (data + 0x1be);
 	for (slot = 1; slot <= 4; slot++, p++) {
 		if (p->boot_ind != 0 && p->boot_ind != 0x80) {
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
-		    if(179 == MAJOR(bdev->bd_dev))
-		    {
-			    printk(KERN_INFO "%s..%d... ==== The sdcard has not MBR.  [mmc0]\n",__FUNCTION__, __LINE__);
-			}
-#endif
 			/*
 			 * Even without a valid boot inidicator value
 			 * its still possible this is valid FAT filesystem
@@ -492,21 +471,9 @@ int msdos_partition(struct parsed_partitions *state)
 				&& fat_valid_media(fb->media)) {
 				strlcat(state->pp_buf, "\n", PAGE_SIZE);
 				put_dev_sector(sect);
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
-				if(179 == MAJOR(bdev->bd_dev))
-				{
-				    printk(KERN_INFO "%s..%d... ==== The DBR(slot=%d) is valid. [mmc0]\n",__FUNCTION__, __LINE__, slot);
-				}
-#endif
 				return 1;
 			} else {
 				put_dev_sector(sect);
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
-				if(179 == MAJOR(bdev->bd_dev))
-				{
-				    printk(KERN_INFO "%s..%d... ==== The DBR is invalid. [mmc0]\n",__FUNCTION__, __LINE__);
-				}
-#endif
 				return 0;
 			}
 		}
@@ -529,25 +496,13 @@ int msdos_partition(struct parsed_partitions *state)
 	 * First find the primary and DOS-type extended partitions.
 	 * On the second pass look inside *BSD, Unixware and Solaris partitions.
 	 */
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
-    if(179 == MAJOR(bdev->bd_dev))
-    {
-        printk(KERN_INFO "%s..%d... ==== The sdcard has MBR. [mmc0]\n", __FUNCTION__, __LINE__);
-    }
-#endif    
+
 	state->next = 5;
 	for (slot = 1 ; slot <= 4 ; slot++, p++) {
 		sector_t start = start_sect(p)*sector_size;
 		sector_t size = nr_sects(p)*sector_size;
 		if (!size)
 			continue;
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
-	    if(179 == MAJOR(bdev->bd_dev))
-	    {
-		    printk(KERN_INFO "%s..%d... ==== partition-%d, size=%luKB  [mmc0]\n",\
-		        __FUNCTION__, __LINE__, slot, size/2);
-		}
-#endif	
 		if (is_extended_partition(p)) {
 			/*
 			 * prevent someone doing mkfs or mkswap on an
@@ -557,12 +512,6 @@ int msdos_partition(struct parsed_partitions *state)
 			 */
 			sector_t n = 2;
 			n = min(size, max(sector_size, n));
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 			
-            if(179 == MAJOR(bdev->bd_dev))
-            {
-			    printk(KERN_INFO "%s...%d... ==== extend partition-%d....[mmc0]\n",__FUNCTION__, __LINE__, slot);
-			}
-#endif			
 			put_partition(state, slot, start, n);
 
 			strlcat(state->pp_buf, " <", PAGE_SIZE);
@@ -570,12 +519,6 @@ int msdos_partition(struct parsed_partitions *state)
 			strlcat(state->pp_buf, " >", PAGE_SIZE);
 			continue;
 		}
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
-		if(179 == MAJOR(bdev->bd_dev))
-		{
-		    printk(KERN_INFO "%s..%d... ==== main partition-%d....[mmc0]\n",__FUNCTION__, __LINE__, slot);
-		}
-#endif		
 		put_partition(state, slot, start, size);
 		if (SYS_IND(p) == LINUX_RAID_PARTITION)
 			state->parts[slot].flags = ADDPART_FLAG_RAID;
diff --git a/fs/proc/meminfo.c b/fs/proc/meminfo.c
index 022ccc6ad4e1..a96282781f94 100644
--- a/fs/proc/meminfo.c
+++ b/fs/proc/meminfo.c
@@ -14,9 +14,6 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include "internal.h"
-#ifdef CONFIG_PLAT_RK
-#include <mach/ddr.h>
-#endif
 
 void __attribute__((weak)) arch_report_meminfo(struct seq_file *m)
 {
@@ -108,15 +105,7 @@ static int meminfo_proc_show(struct seq_file *m, void *v)
 		"AnonHugePages:  %8lu kB\n"
 #endif
 		,
-#ifdef CONFIG_PLAT_RK
-#ifdef CONFIG_RK29_MEM_SIZE_M
-		(unsigned long)CONFIG_RK29_MEM_SIZE_M * 1024,
-#else
-		(unsigned long)ddr_get_cap() >> 10,
-#endif
-#else
 		K(i.totalram),
-#endif
 		K(i.freeram),
 		K(i.bufferram),
 		K(cached),
diff --git a/fs/yaffs2/yaffs_mtdif2.c b/fs/yaffs2/yaffs_mtdif2.c
index 9420e6ffbf92..d1643df2c381 100644
--- a/fs/yaffs2/yaffs_mtdif2.c
+++ b/fs/yaffs2/yaffs_mtdif2.c
@@ -149,13 +149,8 @@ int nandmtd2_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
 	if (local_data)
 		yaffs_release_temp_buffer(dev, data, __LINE__);
 
-#ifdef CONFIG_MTD_NAND_RK29
-	//dxj 20101221@ if return -EBADMSG then i think the page is badchunk so just set the eccResult=YAFFS_ECC_RESULT_NO_ERROR
-	if (tags && retval == -EBADMSG) {
-#else
 	if (tags && retval == -EBADMSG
 	    && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
-#endif
 		tags->ecc_result = YAFFS_ECC_RESULT_UNFIXED;
 		dev->n_ecc_unfixed++;
 	}
diff --git a/fs/yaffs2/yaffs_vfs.c b/fs/yaffs2/yaffs_vfs.c
index 1fbb7fc246c9..d5b875314005 100644
--- a/fs/yaffs2/yaffs_vfs.c
+++ b/fs/yaffs2/yaffs_vfs.c
@@ -2217,9 +2217,6 @@ static struct super_block *yaffs_internal_read_super(int yaffs_version,
 	param->n_reserved_blocks = 5;
 	param->n_caches = (options.no_cache) ? 0 : 10;
 	param->inband_tags = options.inband_tags;
-#if defined(CONFIG_ARCH_RK2818) || defined(CONFIG_ARCH_RK29)
-	param->inband_tags = 1;
-#endif
 
 #ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD
 	param->disable_lazy_load = 1;
diff --git a/include/asm-generic/gpio.h b/include/asm-generic/gpio.h
index 44238fba36a3..d494001b1226 100644
--- a/include/asm-generic/gpio.h
+++ b/include/asm-generic/gpio.h
@@ -35,12 +35,10 @@
  * platform data and other tables.
  */
 
-#ifndef gpio_is_valid
 static inline bool gpio_is_valid(int number)
 {
 	return number >= 0 && number < ARCH_NR_GPIOS;
 }
-#endif
 
 struct device;
 struct seq_file;
@@ -111,9 +109,6 @@ struct gpio_chip {
 	void			(*set)(struct gpio_chip *chip,
 						unsigned offset, int value);
 
-	int			(*pull_updown)(struct gpio_chip *chip,
-						unsigned offset, unsigned value);
-
 	int			(*to_irq)(struct gpio_chip *chip,
 						unsigned offset);
 
@@ -158,8 +153,6 @@ extern void gpio_free(unsigned gpio);
 extern int gpio_direction_input(unsigned gpio);
 extern int gpio_direction_output(unsigned gpio, int value);
 
-extern int gpio_pull_updown(unsigned gpio, unsigned value);
-
 extern int gpio_set_debounce(unsigned gpio, unsigned debounce);
 
 extern int gpio_get_value_cansleep(unsigned gpio);
diff --git a/include/linux/akm8975.h b/include/linux/akm8975.h
index e14fe064901b..6a7c43260018 100644
--- a/include/linux/akm8975.h
+++ b/include/linux/akm8975.h
@@ -6,21 +6,17 @@
 
 #include <linux/ioctl.h>
 
-#define AKM8975_I2C_NAME "ak8975"
-
 /*! \name AK8975 operation mode
  \anchor AK8975_Mode
  Defines an operation mode of the AK8975.*/
 /*! @{*/
-#define AK8975_MODE_SNG_MEASURE	0x01
-#define	AK8975_MODE_SELF_TEST	0x08
-#define	AK8975_MODE_FUSE_ACCESS	0x0F
-#define	AK8975_MODE_POWERDOWN	0x00
+#define AK8975_MODE_SNG_MEASURE   0x01
+#define	AK8975_MODE_SELF_TEST     0x08
+#define	AK8975_MODE_FUSE_ACCESS   0x0F
+#define	AK8975_MODE_POWER_DOWN    0x00
 /*! @}*/
 
-#define SENSOR_DATA_SIZE		8	/* Rx buffer size, i.e from ST1 to ST2 */
-#define RWBUF_SIZE				16	/* Read/Write buffer size.*/
-
+#define RBUFF_SIZE		8	/* Rx buffer size */
 
 /*! \name AK8975 register address
 \anchor AK8975_REG
@@ -56,34 +52,36 @@ Defines a read-only address of the fuse ROM of the AK8975.*/
 #define AKMIO                   0xA1
 
 /* IOCTLs for AKM library */
-#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x01, char*)
-#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x02, char*)
-#define ECS_IOCTL_RESET      	        _IO(AKMIO, 0x03) /* NOT used in AK8975 */
-#define ECS_IOCTL_SET_MODE              _IOW(AKMIO, 0x04, short)
-#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x05, char[SENSOR_DATA_SIZE])
-#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x06, short[12])
-#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x07, int)
-#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x08, int)
+#define ECS_IOCTL_WRITE                 _IOW(AKMIO, 0x02, char[5])
+#define ECS_IOCTL_READ                  _IOWR(AKMIO, 0x03, char[5])
+#define ECS_IOCTL_GETDATA               _IOR(AKMIO, 0x08, char[RBUFF_SIZE])
+#define ECS_IOCTL_SET_YPR               _IOW(AKMIO, 0x0C, short[12])
+#define ECS_IOCTL_GET_OPEN_STATUS       _IOR(AKMIO, 0x0D, int)
+#define ECS_IOCTL_GET_CLOSE_STATUS      _IOR(AKMIO, 0x0E, int)
 #define ECS_IOCTL_GET_DELAY             _IOR(AKMIO, 0x30, short)
-#define ECS_IOCTL_GET_PROJECT_NAME      _IOR(AKMIO, 0x0D, char[64])
-#define ECS_IOCTL_GET_MATRIX            _IOR(AKMIO, 0x0E, short [4][3][3])
-#define ECS_IOCTL_GET_PLATFORM_DATA     _IOR(AKMIO, 0x0E, struct akm8975_platform_data)
-
 
 /* IOCTLs for APPs */
-#define ECS_IOCTL_APP_SET_MODE		_IOW(AKMIO, 0x10, short)
 #define ECS_IOCTL_APP_SET_MFLAG		_IOW(AKMIO, 0x11, short)
 #define ECS_IOCTL_APP_GET_MFLAG		_IOW(AKMIO, 0x12, short)
 #define ECS_IOCTL_APP_SET_AFLAG		_IOW(AKMIO, 0x13, short)
 #define ECS_IOCTL_APP_GET_AFLAG		_IOR(AKMIO, 0x14, short)
-#define ECS_IOCTL_APP_SET_TFLAG		_IOR(AKMIO, 0x15, short)/* NOT use */
-#define ECS_IOCTL_APP_GET_TFLAG		_IOR(AKMIO, 0x16, short)/* NOT use */
-#define ECS_IOCTL_APP_RESET_PEDOMETER   _IO(AKMIO, 0x17)	/* NOT use */
 #define ECS_IOCTL_APP_SET_DELAY		_IOW(AKMIO, 0x18, short)
 #define ECS_IOCTL_APP_GET_DELAY		ECS_IOCTL_GET_DELAY
+/* Set raw magnetic vector flag */
 #define ECS_IOCTL_APP_SET_MVFLAG	_IOW(AKMIO, 0x19, short)
+/* Get raw magnetic vector flag */
 #define ECS_IOCTL_APP_GET_MVFLAG	_IOR(AKMIO, 0x1A, short)
+#define ECS_IOCTL_APP_SET_TFLAG         _IOR(AKMIO, 0x15, short)
+
+
+struct akm8975_platform_data {
+	int intr;
 
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
 
 #endif
 
diff --git a/include/linux/dm9000.h b/include/linux/dm9000.h
index 358fc8fdb42a..96e87693d933 100644
--- a/include/linux/dm9000.h
+++ b/include/linux/dm9000.h
@@ -29,12 +29,6 @@ struct dm9000_plat_data {
 	unsigned int	flags;
 	unsigned char	dev_addr[6];
 
-	//gpio init&deinit	
-    int (*io_init)(void);
-    int (*io_deinit)(void);
-	int irq_pin;
-	int irq_pin_value;
-		
 	/* allow replacement IO routines */
 
 	void	(*inblk)(void __iomem *reg, void *data, int len);
diff --git a/include/linux/export.h b/include/linux/export.h
deleted file mode 100644
index 696c0f48afc7..000000000000
--- a/include/linux/export.h
+++ /dev/null
@@ -1,89 +0,0 @@
-#ifndef _LINUX_EXPORT_H
-#define _LINUX_EXPORT_H
-/*
- * Export symbols from the kernel to modules.  Forked from module.h
- * to reduce the amount of pointless cruft we feed to gcc when only
- * exporting a simple symbol or two.
- *
- * If you feel the need to add #include <linux/foo.h> to this file
- * then you are doing something wrong and should go away silently.
- */
-
-/* Some toolchains use a `_' prefix for all user symbols. */
-#ifdef CONFIG_SYMBOL_PREFIX
-#define MODULE_SYMBOL_PREFIX CONFIG_SYMBOL_PREFIX
-#else
-#define MODULE_SYMBOL_PREFIX ""
-#endif
-
-struct kernel_symbol
-{
-	unsigned long value;
-	const char *name;
-};
-
-#ifdef MODULE
-extern struct module __this_module;
-#define THIS_MODULE (&__this_module)
-#else
-#define THIS_MODULE ((struct module *)0)
-#endif
-
-#ifdef CONFIG_MODULES
-
-#ifndef __GENKSYMS__
-#ifdef CONFIG_MODVERSIONS
-/* Mark the CRC weak since genksyms apparently decides not to
- * generate a checksums for some symbols */
-#define __CRC_SYMBOL(sym, sec)					\
-	extern void *__crc_##sym __attribute__((weak));		\
-	static const unsigned long __kcrctab_##sym		\
-	__used							\
-	__attribute__((section("___kcrctab" sec "+" #sym), unused))	\
-	= (unsigned long) &__crc_##sym;
-#else
-#define __CRC_SYMBOL(sym, sec)
-#endif
-
-/* For every exported symbol, place a struct in the __ksymtab section */
-#define __EXPORT_SYMBOL(sym, sec)				\
-	extern typeof(sym) sym;					\
-	__CRC_SYMBOL(sym, sec)					\
-	static const char __kstrtab_##sym[]			\
-	__attribute__((section("__ksymtab_strings"), aligned(1))) \
-	= MODULE_SYMBOL_PREFIX #sym;				\
-	static const struct kernel_symbol __ksymtab_##sym	\
-	__used							\
-	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\
-	= { (unsigned long)&sym, __kstrtab_##sym }
-
-#define EXPORT_SYMBOL(sym)					\
-	__EXPORT_SYMBOL(sym, "")
-
-#define EXPORT_SYMBOL_GPL(sym)					\
-	__EXPORT_SYMBOL(sym, "_gpl")
-
-#define EXPORT_SYMBOL_GPL_FUTURE(sym)				\
-	__EXPORT_SYMBOL(sym, "_gpl_future")
-
-#ifdef CONFIG_UNUSED_SYMBOLS
-#define EXPORT_UNUSED_SYMBOL(sym) __EXPORT_SYMBOL(sym, "_unused")
-#define EXPORT_UNUSED_SYMBOL_GPL(sym) __EXPORT_SYMBOL(sym, "_unused_gpl")
-#else
-#define EXPORT_UNUSED_SYMBOL(sym)
-#define EXPORT_UNUSED_SYMBOL_GPL(sym)
-#endif
-
-#endif	/* __GENKSYMS__ */
-
-#else /* !CONFIG_MODULES... */
-
-#define EXPORT_SYMBOL(sym)
-#define EXPORT_SYMBOL_GPL(sym)
-#define EXPORT_SYMBOL_GPL_FUTURE(sym)
-#define EXPORT_UNUSED_SYMBOL(sym)
-#define EXPORT_UNUSED_SYMBOL_GPL(sym)
-
-#endif /* CONFIG_MODULES */
-
-#endif /* _LINUX_EXPORT_H */
diff --git a/include/linux/fb.h b/include/linux/fb.h
index 677d0c420f54..f9d013d09bc7 100644
--- a/include/linux/fb.h
+++ b/include/linux/fb.h
@@ -19,15 +19,6 @@
 #define FBIOGETCMAP		0x4604
 #define FBIOPUTCMAP		0x4605
 #define FBIOPAN_DISPLAY		0x4606
-#define FBIOPUT_16OR32      0x4607
-#define FBIOPUT_FBPHYADD    0x4608
-#define FBIOPUT_SET_CURSOR_EN    0x4609
-#define FBIOPUT_SET_CURSOR_IMG    0x460a
-#define FBIOPUT_SET_CURSOR_POS    0x460b
-#define FBIOPUT_SET_CURSOR_CMAP    0x460c
-#define FBIOPUT_GET_CURSOR_RESOLUTION    0x460d
-#define FBIOPUT_GET_CURSOR_EN    0x460e
-
 #ifdef __KERNEL__
 #define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor_user)
 #else
@@ -49,8 +40,6 @@
 #define FBIOGET_DISPINFO        0x4618
 #define FBIO_WAITFORVSYNC	_IOW('F', 0x20, __u32)
 
-
-
 #define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
 #define FB_TYPE_PLANES			1	/* Non interleaved planes */
 #define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
diff --git a/include/linux/hdmi.h b/include/linux/hdmi.h
deleted file mode 100755
index 27958ba9c6b0..000000000000
--- a/include/linux/hdmi.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/* include/linux/hdmi.h
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
-*/
-
-#ifndef __LINUX_HDMI_CORE_H
-#define __LINUX_HDMI_CORE_H
-
-#include <linux/device.h>
-#include <linux/workqueue.h>
-#include <linux/i2c.h>
-#include <linux/completion.h>
-#include <linux/wakelock.h>
-
-extern int debug_en;
-
-#define hdmi_dbg(dev, format, arg...)		\
-do{\
-	if(debug_en == 1) \
-		dev_printk(KERN_INFO , dev , format , ## arg);\
-}while(0)
-
-
-
-typedef int 		BOOL;
-
-#define TRUE		1
-#define FALSE 		0
-#define HDMI_DISABLE   0
-#define HDMI_ENABLE    1
-
-#define MIN_SCALE		80
-/* mouse event */
-#define MOUSE_NONE			0x00
-#define MOUSE_LEFT_PRESS	0x01
-#define MOUSE_RIGHT_PRESS	0x02
-#define MOUSE_MIDDLE_PRESS	0x04
-#define HDMI_MOUSE_EVENT	MOUSE_NONE	
-/* mode */
-#define DISP_ON_LCD				0
-#define DISP_ON_HDMI			1
-#define DISP_ON_LCD_AND_HDMI	2
-/* dual display */
-#ifdef CONFIG_HDMI_DUAL_DISP
-#define DUAL_DISP_CAP		HDMI_ENABLE 
-#define HDMI_DEFAULT_MODE	DISP_ON_LCD_AND_HDMI
-#else
-#define DUAL_DISP_CAP		HDMI_DISABLE 
-#define HDMI_DEFAULT_MODE	DISP_ON_HDMI
-#endif
-/* resolution */
-#define HDMI_1920x1080p_50Hz	0
-#define HDMI_1920x1080p_60Hz	1
-#define HDMI_1280x720p_50Hz 	2
-#define HDMI_1280x720p_60Hz		3
-#define HDMI_720x576p_50Hz_4x3	4
-#define HDMI_720x576p_50Hz_16x9	5
-#define HDMI_720x480p_60Hz_4x3	6
-#define HDMI_720x480p_60Hz_16x9	7
-
-/* HDMI default resolution */
-#define HDMI_DEFAULT_RESOLUTION  HDMI_1920x1080p_50Hz
-/* I2S Fs */
-#define HDMI_I2S_Fs_44100 0
-#define HDMI_I2S_Fs_48000 2
-/* I2S default sample rate */
-#define HDMI_I2S_DEFAULT_Fs HDMI_I2S_Fs_44100
-
-
-#define HDMI_MAX_ID		32
-struct hdmi;
-struct hdmi_ops{
-	int (*set_param)(struct hdmi *);
-	int (*hdmi_precent)(struct hdmi *);
-	int (*insert)(struct hdmi *);
-	int (*remove)(struct hdmi *);
-	int (*init)(struct hdmi*);
-};
-struct hdmi {
-	int id;
-	int wait;
-	BOOL display_on;
-	BOOL plug;
-	BOOL hdcp_on;
-	BOOL param_conf;
-
-	u8 resolution;
-	u8 scale;
-	u8 scale_set;
-	u8 audio_fs;
-	int mode;
-	int dual_disp;
-	struct timer_list timer;
-	struct mutex lock;
-	struct device *dev;
-	struct delayed_work work;
-	struct completion	complete;
-	const struct hdmi_ops *ops;
-
-	unsigned long		priv[0] ____cacheline_aligned;
-};
-extern int hdmi_is_insert(void);
-extern void *hdmi_priv(struct hdmi *hdmi);
-extern struct hdmi *hdmi_register(int extra, struct device *parent);
-extern void hdmi_unregister(struct hdmi *hdmi);
-extern void hdmi_changed(struct hdmi *hdmi, int msec);
-
-extern int hdmi_switch_fb(struct hdmi *hdmi, int type);
-extern void hdmi_suspend(struct hdmi *hdmi);
-extern void hdmi_resume(struct hdmi *hdmi);
-extern struct hdmi *get_hdmi_struct(int nr);
-
-extern void hdmi_set_spk(int on);
-extern void hdmi_set_backlight(int on);
-extern int hdmi_get_scale(void);
-extern int hdmi_set_scale(int event, char *data, int len);
-extern int fb_get_video_mode(void);
-extern int display_on_hdmi(void);
-extern int hdmi_get_data(void);
-extern int hdmi_set_data(int data);
-#endif
diff --git a/include/linux/i2c-gpio.h b/include/linux/i2c-gpio.h
index 1b4ac408db7c..c1bcb1f1d73b 100644
--- a/include/linux/i2c-gpio.h
+++ b/include/linux/i2c-gpio.h
@@ -33,8 +33,6 @@ struct i2c_gpio_platform_data {
 	unsigned int	sda_is_open_drain:1;
 	unsigned int	scl_is_open_drain:1;
 	unsigned int	scl_is_output_only:1;
-	int bus_num;
-	int (*io_init)(void);
 };
 
 #endif /* _LINUX_I2C_GPIO_H */
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 2b58f67f3692..a6c652ef516d 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -61,19 +61,6 @@ extern int i2c_master_send(const struct i2c_client *client, const char *buf,
 extern int i2c_master_recv(const struct i2c_client *client, char *buf,
 			   int count);
 
-#ifdef CONFIG_PLAT_RK
-/* If everything went ok, return 'count' transmitted, else error code. */
-extern int i2c_master_normal_send(const struct i2c_client *client, const char *buf, int count, int scl_rate);
-extern int i2c_master_normal_recv(const struct i2c_client *client, char *buf, int count, int scl_rate);
-extern int i2c_master_reg8_send(const struct i2c_client *client, const char reg, const char *buf, int count, int scl_rate);
-extern int i2c_master_reg8_recv(const struct i2c_client *client, const char reg, char *buf, int count, int scl_rate);
-extern int i2c_master_reg16_send(const struct i2c_client *client, const short regs, const short *buf, int count, int scl_rate);
-extern int i2c_master_reg16_recv(const struct i2c_client *client, const short regs, short *buf, int count, int scl_rate);
-extern int i2c_suspended(struct i2c_adapter *adap);
-extern int i2c_add_device(int nr, struct i2c_board_info const *info);
-extern int i2c_check_rk610_ex(int nr);
-#endif
-
 /* Transfer num messages.
  */
 extern int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
@@ -221,7 +208,6 @@ struct i2c_client {
 	struct i2c_driver *driver;	/* and our access routines	*/
 	struct device dev;		/* the device structure		*/
 	int irq;			/* irq issued by device		*/
-	int udelay;
 	struct list_head detected;
 };
 #define to_i2c_client(d) container_of(d, struct i2c_client, dev)
@@ -273,7 +259,6 @@ struct i2c_board_info {
 	struct dev_archdata	*archdata;
 	struct device_node *of_node;
 	int		irq;
-	int		udelay;   //add by kfx
 };
 
 /**
@@ -532,13 +517,8 @@ struct i2c_msg {
 #define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
-#define I2C_M_NEED_DELAY	0x0020  // add by kfx
-#define I2C_M_REG8_DIRECT	0x0040	// add by kfx
 	__u16 len;		/* msg length				*/
 	__u8 *buf;		/* pointer to msg data			*/
-	__u32 scl_rate;  // add by kfx
-	int udelay;		//add by kfx
-	__u16 read_type;
 };
 
 /* To determine what functionality is present */
diff --git a/include/linux/i2c/twl.h b/include/linux/i2c/twl.h
index 2ff768ef5dc7..ba4f88624fcd 100644
--- a/include/linux/i2c/twl.h
+++ b/include/linux/i2c/twl.h
@@ -39,66 +39,6 @@
  * address each module uses within a given i2c slave.
  */
 
-#define PREQ1_RES_ASS_A 0x2a
-#define PREQ1_RES_ASS_B 0x2b
-#define PREQ1_RES_ASS_C 0x2c
-#define PREQ2_RES_ASS_A 0x2d
-#define PREQ3_RES_ASS_A 0x30
-#define PHOENIX_MSK_TRANSITION 0x01
-#define PHOENIX_SENS_TRANSITION 0x0b
-#define SMPS4_CFG_TRANS 0x11
-#define SMPS4_CFG_STATE 0x12
-#define SMPS4_CFG_VOLTAGE 0x14
-#define SMPS5_CFG_TRANS 0x17
-#define SMPS5_CFG_STATE 0x18
-#define SMPS5_CFG_FORCE 0x19
-#define SMPS5_CFG_VOLTAGE 0x1A
-#define SMPS5_CFG_STEP 0x1B
-#define SMPS1_CFG_TRANS 0x23
-#define SMPS1_CFG_STATE 0x24
-#define SMPS1_CFG_FORCE 0x25
-#define SMPS1_CFG_VOLTAGE 0x26
-#define SMPS1_CFG_STEP 0x27
-#define SMPS2_CFG_TRANS 0x29
-#define SMPS2_CFG_STATE 0x2a
-#define SMPS2_CFG_FORCE 0x2b
-#define SMPS2_CFG_VOLTAGE 0x2c
-#define SMPS2_CFG_STEP 0x2d
-#define VANA_CFG_TRANS 0x51
-#define VANA_CFG_STATE 0x52
-#define VANA_CFG_VOLTAGE 0x53
-#define LDO2_CFG_TRANS 0x55
-#define LDO2_CFG_STATE 0x56
-#define LDO2_CFG_VOLTAGE 0x57
-#define LDO4_CFG_TRANS 0x59
-#define LDO4_CFG_STATE 0x5a
-#define LDO4_CFG_VOLTAGE 0x5b
-#define LDO3_CFG_TRANS 0x5d
-#define LDO3_CFG_STATE 0x5e
-#define LDO3_CFG_VOLTAGE 0x5f
-#define LDO6_CFG_TRANS 0x61
-#define LDO6_CFG_STATE 0x62
-#define LDO6_CFG_VOLTAGE 0x63
-#define LDOLN_CFG_TRANS 0x65
-#define LDOLN_CFG_STATE 0x66
-#define LDOLN_CFG_VOLTAGE 0x67
-#define LDO5_CFG_TRANS 0x69
-#define LDO5_CFG_STATE 0x6A
-#define LDO5_CFG_VOLTAGE 0x6B
-#define LDO1_CFG_TRANS 0x6D
-#define LDO1_CFG_STATE 0x6E
-#define LDO1_CFG_VOLTAGE 0x6F
-#define LDOUSB_CFG_TRANS 0x71
-#define LDOUSB_CFG_STATE 0x72
-#define LDOUSB_CFG_VOLTAGE 0x73
-#define LDO7_CFG_TRANS 0x75
-#define LDO7_CFG_STATE 0x76
-#define LDO7_CFG_VOLTAGE 0x77
-#define CLK32KG_CFG_STATE  0x11
-#define CLK32KAUDIO_CFG_STATE 0x14
-#define CHARGERUSB_CTRLLIMIT2	0x10
-
-
 /* Slave 0 (i2c address 0x48) */
 #define TWL4030_MODULE_USB		0x00
 
@@ -131,8 +71,6 @@
 #define TWL4030_MODULE_PM_RECEIVER	0x15
 #define TWL4030_MODULE_RTC		0x16
 #define TWL4030_MODULE_SECURED_REG	0x17
-#define TWL6032_MODULE_CHARGER		0x18
-#define TWL6030_MODULE_SLAVE_RES	0x19
 
 #define TWL_MODULE_USB		TWL4030_MODULE_USB
 #define TWL_MODULE_AUDIO_VOICE	TWL4030_MODULE_AUDIO_VOICE
@@ -143,11 +81,7 @@
 #define TWL_MODULE_PM_RECEIVER	TWL4030_MODULE_PM_RECEIVER
 #define TWL_MODULE_RTC		TWL4030_MODULE_RTC
 #define TWL_MODULE_PWM		TWL4030_MODULE_PWM0
-#define TWL6030_MODULE_CHARGER TWL4030_MODULE_MAIN_CHARGE
-#define TWL_MODULE_PM_SLAVE_RES	TWL6030_MODULE_SLAVE_RES
-#define TWL_MODULE_PM_DVS                   0x1A  //add
 
-#define TWL6030_MODULE_GASGAUGE 0x0B
 #define TWL6030_MODULE_ID0	0x0D
 #define TWL6030_MODULE_ID1	0x0E
 #define TWL6030_MODULE_ID2	0x0F
@@ -166,7 +100,6 @@
  * Offset from TWL6030_IRQ_BASE / pdata->irq_base
  */
 #define PWR_INTR_OFFSET		0
-#define TWL_VLOW_INTR_OFFSET	6
 #define HOTDIE_INTR_OFFSET	12
 #define SMPSLDO_INTR_OFFSET	13
 #define BATDETECT_INTR_OFFSET	14
@@ -175,7 +108,6 @@
 #define GASGAUGE_INTR_OFFSET	17
 #define USBOTG_INTR_OFFSET	4
 #define CHARGER_INTR_OFFSET	2
-#define GPADCSW_INTR_OFFSET	1
 #define RSV_INTR_OFFSET		0
 
 /* INT register offsets */
@@ -215,17 +147,10 @@
 #define SW_FC				(0x1 << 2)
 #define STS_MMC			0x1
 
-#define TWL6030_MMCDEBOUNCING	0xED
-#define MMC_DEB_BYPASS			(0x1 << 7)
-#define MMC_MINS_DEB_MASK			(0xF << 3)
-#define MMC_MEXT_DEB_MASK			(0x7 << 0)
-
 #define TWL6030_CFG_INPUT_PUPD3	0xF2
 #define MMC_PU				(0x1 << 3)
 #define MMC_PD				(0x1 << 2)
 
-#define VLOW_INT_MASK			(0x1 << 2)
-
 #define TWL_SIL_TYPE(rev)		((rev) & 0x00FFFFFF)
 #define TWL_SIL_REV(rev)		((rev) >> 24)
 #define TWL_SIL_5030			0x09002F
@@ -246,7 +171,7 @@ static inline int twl_class_is_ ##class(void)	\
 TWL_CLASS_IS(4030, TWL4030_CLASS_ID)
 TWL_CLASS_IS(6030, TWL6030_CLASS_ID)
 
-#define TWL6032_SUBCLASS	BIT(4)  /* Phoenix Lite is a varient*/
+#define TWL6025_SUBCLASS	BIT(4)  /* TWL6025 has changed registers */
 
 /*
  * Read and write single 8-bit registers
@@ -263,8 +188,6 @@ int twl_i2c_read_u8(u8 mod_no, u8 *val, u8 reg);
 int twl_i2c_write(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes);
 int twl_i2c_read(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes);
 
-void twl6030_poweroff(void);
-
 int twl_get_type(void);
 int twl_get_version(void);
 
@@ -292,29 +215,6 @@ static inline int twl6030_mmc_card_detect(struct device *dev, int slot)
 	return -EIO;
 }
 #endif
-
-/******************gpadc channels*************************/
-#define GPADC_CH0 0  //Battery type, resistor value
-#define GPADC_CH1 1   //Battery temperature, NTC resistor value
-#define GPADC_CH2 2   //Audio accessory/general purpose
-#define GPADC_CH3 3   //Temperature with external diode/general
-#define GPADC_CH4 4   //Temperature measurement/general purpose
-#define GPADC_CH5 5   //General purpose
-#define GPADC_CH6 6   //General purpose
-#define GPADC_CH7 7    //System supply
-#define GPADC_CH8 8    //Backup battery
-#define GPADC_CH9 9   //External charger input
-#define GPADC_CH10 10  //VBUS
-#define GPADC_CH11 11   //VBUS DCDC output current
-#define GPADC_CH12 12    //Die temperature
-#define GPADC_CH13 13    //Die temperature
-#define GPADC_CH14 14    //USB ID line
-#define GPADC_CH15 15   //Test network
-#define GPADC_CH16 16    //Test network
-#define GPADC_CH17 17   //Battery charging current
-#define GPADC_CH18 18   //BATTERY VOLTAGE
-/*********************************************************/
-
 /*----------------------------------------------------------------------*/
 
 /*
@@ -330,11 +230,6 @@ static inline int twl6030_mmc_card_detect(struct device *dev, int slot)
 #define TWL4030_SIH_CTRL_PENDDIS_MASK	BIT(1)
 #define TWL4030_SIH_CTRL_COR_MASK	BIT(2)
 
-int twl6030_register_notifier(struct notifier_block *nb,
-				unsigned int events);
-int twl6030_unregister_notifier(struct notifier_block *nb,
-				unsigned int events);
-
 /*----------------------------------------------------------------------*/
 
 /*
@@ -555,23 +450,6 @@ int twl6030_unregister_notifier(struct notifier_block *nb,
 
 #define TWL4030_PM_MASTER_GLOBAL_TST		0xb6
 
-#define TWL6030_PHOENIX_DEV_ON			0x06
-
-/*
- * TWL6030 PM Master module register offsets (use TWL_MODULE_PM_MASTER)
- */
-
-#define TWL6030_PM_MASTER_MSK_TRANSITION	0x01
-#define TWL6030_VBATMIN_HI_THRESHOLD		0x05
-
-/*
- * PM Slave resource module register offsets (use TWL6030_MODULE_SLAVE_RES)
- */
-
-#define REG_VBATMIN_HI_CFG_STATE		0x1D
-
-#define VBATMIN_VLOW_EN				0x21
-
 /*----------------------------------------------------------------------*/
 
 /* Power bus message definitions */
@@ -644,43 +522,6 @@ int twl6030_unregister_notifier(struct notifier_block *nb,
 #define RES_MAIN_REF            28
 
 #define TOTAL_RESOURCES		28
-/* 6030 extra resources */
-#define RES_V1V29		29
-#define RES_V1V8		30
-#define RES_V2V1		31
-#define RES_VDD3		32
-#define RES_VMEM		33
-#define RES_VANA		34
-#define RES_VUAX1		35
-#define RES_VCXIO		36
-#define RES_VPP			37
-#define RES_VRTC		38
-#define RES_REGEN2		39
-#define RES_32KCLKAO		40
-#define RES_32KCLKG		41
-#define RES_32KCLKAUDIO		42
-#define RES_BIAS		43
-#define RES_VBATMIN_HI		44
-#define RES_RC6MHZ		45
-#define RES_TEMP		46
-
-/* 6032 extra resources */
-#define RES_LDOUSB		47
-#define RES_SMPS5		48
-#define RES_SMPS4		49
-#define RES_SMPS3		50
-#define RES_SMPS2		51
-#define RES_SMPS1		52
-#define RES_LDOLN		53
-#define RES_LDO7		54
-#define RES_LDO6		55
-#define RES_LDO5		56
-#define RES_LDO4		57
-#define RES_LDO3		58
-#define RES_LDO2		59
-#define RES_LDO1		60
-#define RES_VSYSMIN_HI	61
-
 /*
  * Power Bus Message Format ... these can be sent individually by Linux,
  * but are usually part of downloaded scripts that are run when various
@@ -716,20 +557,6 @@ struct twl4030_clock_init_data {
 struct twl4030_bci_platform_data {
 	int *battery_tmp_tbl;
 	unsigned int tblsize;
-
-	unsigned int monitoring_interval;
-
-	unsigned int max_charger_currentmA;
-	unsigned int max_charger_voltagemV;
-	unsigned int termination_currentmA;
-
-	unsigned int max_bat_voltagemV;
-	unsigned int low_bat_voltagemV;
-
-	unsigned int sense_resistor_mohm;
-
-	/* twl6032 */
-	unsigned long features;
 };
 
 /* TWL4030_GPIO_MAX (18) GPIOs, with interrupts */
@@ -762,7 +589,6 @@ struct twl4030_gpio_platform_data {
 
 struct twl4030_madc_platform_data {
 	int		irq_line;
-	int		features;
 };
 
 /* Boards have unique mappings of {row, col} --> keycode.
@@ -815,41 +641,21 @@ struct twl4030_script {
 struct twl4030_resconfig {
 	u8 resource;
 	u8 devgroup;	/* Processor group that Power resource belongs to */
-	/* The following are used by TWL4030 only */
 	u8 type;	/* Power resource addressed, 6 / broadcast message */
 	u8 type2;	/* Power resource addressed, 3 / broadcast message */
 	u8 remap_off;	/* off state remapping */
 	u8 remap_sleep;	/* sleep state remapping */
 };
 
-struct twl4030_system_config {
-	char *name;
-	u8 group;
-};
-
 struct twl4030_power_data {
-	struct twl4030_script **scripts;	/* used in TWL4030 only */
-	unsigned num;				/* used in TWL4030 only */
+	struct twl4030_script **scripts;
+	unsigned num;
 	struct twl4030_resconfig *resource_config;
-	struct twl4030_system_config *sys_config; /*system resources*/
 #define TWL4030_RESCONFIG_UNDEF	((u8)-1)
 };
 
-#ifdef CONFIG_TWL4030_POWER
 extern void twl4030_power_init(struct twl4030_power_data *triton2_scripts);
 extern int twl4030_remove_script(u8 flags);
-#else
-static inline void twl4030_power_init(struct twl4030_power_data *triton2_scripts) { }
-static inline int twl4030_remove_script(u8 flags) { return -EINVAL; }
-#endif
-
-#ifdef CONFIG_TWL6030_POWER
-extern void twl6030_power_init(struct twl4030_power_data *power_data,\
-					unsigned long features);
-#else
-extern inline void twl6030_power_init(struct twl4030_power_data *power_data,\
-					unsigned long features) { }
-#endif
 
 struct twl4030_codec_audio_data {
 	unsigned int digimic_delay; /* in ms */
@@ -858,26 +664,11 @@ struct twl4030_codec_audio_data {
 	unsigned int check_defaults:1;
 	unsigned int reset_registers:1;
 	unsigned int hs_extmute:1;
-	u16 hs_left_step;
-	u16 hs_right_step;
-	u16 hf_left_step;
-	u16 hf_right_step;
-	u16 ep_step;
 	void (*set_hs_extmute)(int mute);
-
-	/* twl6040 */
-	int vddhf_uV;
 };
 
 struct twl4030_codec_vibra_data {
 	unsigned int	coexist;
-
-	/* timed-output based implementations */
-	int max_timeout;
-	int initial_vibrate;
-	int (*init)(void);
-	void (*exit)(void);
-	u8  voltage_raise_speed;
 };
 
 struct twl4030_codec_data {
@@ -885,22 +676,13 @@ struct twl4030_codec_data {
 	struct twl4030_codec_audio_data		*audio;
 	struct twl4030_codec_vibra_data		*vibra;
 
-	int (*init)(void);
-	void (*exit)(void);
-
 	/* twl6040 */
 	int audpwron_gpio;	/* audio power-on gpio */
 	int naudint_irq;	/* audio interrupt */
-	unsigned int irq_base;
-	int (*get_ext_clk32k)(void);
-	void (*put_ext_clk32k)(void);
-	int (*set_ext_clk32k)(bool on);
 };
 
 struct twl4030_platform_data {
 	unsigned				irq_base, irq_end;
-	int(*pre_init)(void);
-	int(*set_init)(void);
 	struct twl4030_clock_init_data		*clock;
 	struct twl4030_bci_platform_data	*bci;
 	struct twl4030_gpio_platform_data	*gpio;
@@ -928,10 +710,6 @@ struct twl4030_platform_data {
 	struct regulator_init_data		*vintana1;
 	struct regulator_init_data		*vintana2;
 	struct regulator_init_data		*vintdig;
-	/* TWL6030 DCDC regulators */
-	struct regulator_init_data		*vdd3;
-	struct regulator_init_data		*vmem;
-	struct regulator_init_data		*v2v1;
 	/* TWL6030 LDO regulators */
 	struct regulator_init_data              *vmmc;
 	struct regulator_init_data              *vpp;
@@ -940,8 +718,7 @@ struct twl4030_platform_data {
 	struct regulator_init_data              *vcxio;
 	struct regulator_init_data              *vusb;
 	struct regulator_init_data		*clk32kg;
-	struct regulator_init_data              *clk32kaudio;
-	/* TWL6032 LDO regulators */
+	/* TWL6025 LDO regulators */
 	struct regulator_init_data		*ldo1;
 	struct regulator_init_data		*ldo2;
 	struct regulator_init_data		*ldo3;
@@ -951,21 +728,10 @@ struct twl4030_platform_data {
 	struct regulator_init_data		*ldo7;
 	struct regulator_init_data		*ldoln;
 	struct regulator_init_data		*ldousb;
-	/* TWL6032 DCDC regulators */
+	/* TWL6025 DCDC regulators */
 	struct regulator_init_data		*smps3;
 	struct regulator_init_data		*smps4;
-	struct regulator_init_data		*vio6032;
-	
-	struct regulator_init_data            *smps1; //add 
-	struct regulator_init_data            *smps2; //add 
-	struct regulator_init_data            *smps5; //add 
-	
-	/* External control pins */
-	struct regulator_init_data		*sysen;
-	struct regulator_init_data		*regen1;
-
-
-	
+	struct regulator_init_data		*vio6025;
 };
 
 /*----------------------------------------------------------------------*/
@@ -1047,33 +813,21 @@ static inline int twl4030charger_usb_en(int enable) { return 0; }
 #define TWL6030_REG_VRTC	47
 #define TWL6030_REG_CLK32KG	48
 
-/* LDOs on 6032 have different names */
-#define TWL6032_REG_LDO2	49
-#define TWL6032_REG_LDO4	50
-#define TWL6032_REG_LDO3	51
-#define TWL6032_REG_LDO5	52
-#define TWL6032_REG_LDO1	53
-#define TWL6032_REG_LDO7	54
-#define TWL6032_REG_LDO6	55
-#define TWL6032_REG_LDOLN	56
-#define TWL6032_REG_LDOUSB	57
-
-/* 6032 DCDC supplies */
-#define TWL6032_REG_SMPS3	58
-#define TWL6032_REG_SMPS4	59
-#define TWL6032_REG_VIO		60
-
-#define TWL6030_REG_CLK32KAUDIO	61
-
-/* External control pins */
-#define TWL6030_REG_SYSEN	62
-#define TWL6030_REG_REGEN1	63
-
-#define TWL6032_REG_SMPS1 64  //add 
-#define TWL6032_REG_SMPS2 65  //add 
-#define TWL6032_REG_SMPS5 66 //add 
-
-#define TWL6032_PREQ1_RES_ASS_A	0xd7
+/* LDOs on 6025 have different names */
+#define TWL6025_REG_LDO2	49
+#define TWL6025_REG_LDO4	50
+#define TWL6025_REG_LDO3	51
+#define TWL6025_REG_LDO5	52
+#define TWL6025_REG_LDO1	53
+#define TWL6025_REG_LDO7	54
+#define TWL6025_REG_LDO6	55
+#define TWL6025_REG_LDOLN	56
+#define TWL6025_REG_LDOUSB	57
+
+/* 6025 DCDC supplies */
+#define TWL6025_REG_SMPS3	58
+#define TWL6025_REG_SMPS4	59
+#define TWL6025_REG_VIO		60
 
 
 #endif /* End of __TWL4030_H */
diff --git a/include/linux/ion.h b/include/linux/ion.h
index 412ad2c5a22f..aed8349279ed 100644
--- a/include/linux/ion.h
+++ b/include/linux/ion.h
@@ -18,7 +18,6 @@
 #define _LINUX_ION_H
 
 #include <linux/types.h>
-#define ION_VERSION     "1.0"
 
 struct ion_handle;
 /**
@@ -38,14 +37,6 @@ enum ion_heap_type {
 				 are at the end of this enum */
 	ION_NUM_HEAPS,
 };
-enum ion_heap_ids {
-	ION_NOR_HEAP_ID = 0,
-	ION_CMA_HEAP_ID = 1,
-	
-	ION_VPU_ID = 16,
-	ION_CAM_ID = 17,
-	ION_UI_ID = 18,
-};
 
 #define ION_HEAP_SYSTEM_MASK		(1 << ION_HEAP_TYPE_SYSTEM)
 #define ION_HEAP_SYSTEM_CONTIG_MASK	(1 << ION_HEAP_TYPE_SYSTEM_CONTIG)
@@ -128,7 +119,6 @@ void ion_client_destroy(struct ion_client *client);
 struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 			     size_t align, unsigned int flags);
 
-struct ion_handle *ion_alloc_by_kenel(size_t len, unsigned int flags);
 /**
  * ion_free - free a handle
  * @client:	the client
@@ -137,7 +127,6 @@ struct ion_handle *ion_alloc_by_kenel(size_t len, unsigned int flags);
  * Free the provided handle.
  */
 void ion_free(struct ion_client *client, struct ion_handle *handle);
-void ion_free_by_kernel(struct ion_handle *handle);
 
 /**
  * ion_phys - returns the physical address and len of a handle
@@ -166,8 +155,6 @@ int ion_phys(struct ion_client *client, struct ion_handle *handle,
  * Map the given handle into the kernel and return a kernel address that
  * can be used to access this address.
  */
-int ion_phys_by_kernel(struct ion_handle *handle, ion_phys_addr_t *addr, size_t *len);
-struct ion_handle *ion_handle_lookup_by_addr(ion_phys_addr_t addr);
 void *ion_map_kernel(struct ion_client *client, struct ion_handle *handle);
 
 /**
@@ -298,36 +285,6 @@ struct ion_custom_data {
 	unsigned long arg;
 };
 
-struct ion_phys_data {
-	struct ion_handle *handle;
-	unsigned long phys;
-	unsigned long size;
-};
-struct ion_cacheop_data {
-#define ION_CACHE_FLUSH		0
-#define ION_CACHE_CLEAN		1
-#define ION_CACHE_INV		2
-	unsigned int type;
-	struct ion_handle *handle;
-	void *virt;
-};
-struct ion_buffer_info {
-	unsigned long phys;
-	unsigned long size;
-};
-struct ion_client_info {
-#define MAX_BUFFER_COUNT	127
-	unsigned int count;
-	unsigned long total_size;
-	struct ion_buffer_info buf[MAX_BUFFER_COUNT];
-};
-struct ion_heap_info {
-	unsigned int id;
-	unsigned long allocated_size;
-	unsigned long max_allocated;
-	unsigned long total_size;
-};
-
 #define ION_IOC_MAGIC		'I'
 
 /**
@@ -382,24 +339,6 @@ struct ion_heap_info {
  * Takes the argument of the architecture specific ioctl to call and
  * passes appropriate userdata for that ioctl
  */
-#define ION_IOC_CUSTOM			_IOWR(ION_IOC_MAGIC, 6, struct ion_custom_data)
-
-#define ION_CUSTOM_GET_PHYS		_IOWR(ION_IOC_MAGIC, 7, \
-				      		struct ion_phys_data)
-				      
-#define ION_CUSTOM_CACHE_OP		_IOWR(ION_IOC_MAGIC, 8, \
-				      		struct ion_cacheop_data) 				     
-
-#define ION_CUSTOM_GET_CLIENT_INFO	_IOWR(ION_IOC_MAGIC, 9, \
-				      		struct ion_client_info) 
-
-#define ION_CUSTOM_GET_HEAP_INFO	_IOWR(ION_IOC_MAGIC, 10, \
-				      		struct ion_heap_info) 
-/* Compatible with pmem */
-struct ion_pmem_region {
-	unsigned long offset;
-	unsigned long len;
-};
-#define ION_PMEM_GET_PHYS		_IOW('p', 1, unsigned int)
-#define ION_PMEM_CACHE_FLUSH		_IOW('p', 8, unsigned int)
+#define ION_IOC_CUSTOM		_IOWR(ION_IOC_MAGIC, 6, struct ion_custom_data)
+
 #endif /* _LINUX_ION_H */
diff --git a/include/linux/linux_logo.h b/include/linux/linux_logo.h
index 31126eb86cd4..ca5bd91d12e1 100644
--- a/include/linux/linux_logo.h
+++ b/include/linux/linux_logo.h
@@ -21,7 +21,6 @@
 #define LINUX_LOGO_VGA16	2	/* 16 colors VGA text palette */
 #define LINUX_LOGO_CLUT224	3	/* 224 colors */
 #define LINUX_LOGO_GRAY256	4	/* 256 levels grayscale */
-#define LINUX_LOGO_bmp      5  /* truecolours*/
 
 
 struct linux_logo {
@@ -32,14 +31,10 @@ struct linux_logo {
 	const unsigned char *clut;	/* LINUX_LOGO_CLUT224 only */
 	const unsigned char *data;
 };
-extern const struct linux_logo logo_linux_lowerpower_clut224;
+
 extern const struct linux_logo logo_linux_mono;
 extern const struct linux_logo logo_linux_vga16;
 extern const struct linux_logo logo_linux_clut224;
-
-#ifdef CONFIG_LOGO_PIPO_CLUT224
-extern const struct linux_logo logo_pipo_clut224;
-#endif
 extern const struct linux_logo logo_blackfin_vga16;
 extern const struct linux_logo logo_blackfin_clut224;
 extern const struct linux_logo logo_dec_clut224;
@@ -52,10 +47,6 @@ extern const struct linux_logo logo_superh_vga16;
 extern const struct linux_logo logo_superh_clut224;
 extern const struct linux_logo logo_m32r_clut224;
 extern const struct linux_logo logo_spe_clut224;
-extern const struct linux_logo logo_g3_clut224;
-extern const struct linux_logo logo_sunset_bmp;
-extern const struct linux_logo logo_android_bmp;
-extern const struct linux_logo logo_linux_800x480_clut224;
 
 extern const struct linux_logo *fb_find_logo(int depth);
 #ifdef CONFIG_FB_LOGO_EXTRA
diff --git a/include/linux/mfd/tps65910.h b/include/linux/mfd/tps65910.h
index c098040c7256..8bb85b930c07 100644
--- a/include/linux/mfd/tps65910.h
+++ b/include/linux/mfd/tps65910.h
@@ -17,9 +17,6 @@
 #ifndef __LINUX_MFD_TPS65910_H
 #define __LINUX_MFD_TPS65910_H
 
-#include <linux/gpio.h>
-#include <linux/wakelock.h>
-
 /* TPS chip id list */
 #define TPS65910			0
 #define TPS65911			1
@@ -28,10 +25,6 @@
 #define REGULATOR_LDO			0
 #define REGULATOR_DCDC			1
 
-/* I2C Slave Address 7-bit */
-#define TPS65910_I2C_ID0        0x2D /* general-purpose */
-#define TPS65910_I2C_ID1        0x12 /* Smart Reflex */
-
 /*
  * List of registers for component TPS65910
  *
@@ -250,8 +243,7 @@
 
 
 /*Registers VDD1, VDD2 voltage values definitions */
-#define VDD1_2_NUM_VOLT_FINE				73
-#define VDD1_2_NUM_VOLT_COARSE				3
+#define VDD1_2_NUM_VOLTS				73
 #define VDD1_2_MIN_VOLT					6000
 #define VDD1_2_OFFSET					125
 
@@ -277,7 +269,7 @@
 #define LDO1_SEL_MASK					0xFC
 #define LDO3_SEL_MASK					0x7C
 #define LDO_MIN_VOLT					1000
-#define LDO_MAX_VOLT					3300
+#define LDO_MAX_VOLT					3300;
 
 
 /*Register VDIG1  (0x80) register.RegisterDescription */
@@ -369,7 +361,7 @@
 #define DCDCCTRL_DCDCCKSYNC_SHIFT			0
 
 
-/*Register DEVCTRL  (0x3F) register.RegisterDescription */
+/*Register DEVCTRL  (0x80) register.RegisterDescription */
 #define DEVCTRL_RTC_PWDN_MASK				0x40
 #define DEVCTRL_RTC_PWDN_SHIFT				6
 #define DEVCTRL_CK32K_CTRL_MASK				0x20
@@ -386,7 +378,7 @@
 #define DEVCTRL_DEV_OFF_SHIFT				0
 
 
-/*Register DEVCTRL2  (0x40) register.RegisterDescription */
+/*Register DEVCTRL2  (0x80) register.RegisterDescription */
 #define DEVCTRL2_TSLOT_LENGTH_MASK			0x30
 #define DEVCTRL2_TSLOT_LENGTH_SHIFT			4
 #define DEVCTRL2_SLEEPSIG_POL_MASK			0x08
@@ -664,8 +656,6 @@
 
 
 /*Register GPIO  (0x80) register.RegisterDescription */
-#define GPIO_SLEEP_MASK                         0x80
-#define GPIO_SLEEP_SHIFT                        7
 #define GPIO_DEB_MASK                           0x10
 #define GPIO_DEB_SHIFT                          4
 #define GPIO_PUEN_MASK                          0x08
@@ -749,50 +739,19 @@
 #define TPS65910_GPIO_STS				BIT(1)
 #define TPS65910_GPIO_SET				BIT(0)
 
-/* Max number of TPS65910/11 GPIOs */
-#define TPS65910_NUM_GPIO				6
-#define TPS65911_NUM_GPIO				9
-#define TPS6591X_MAX_NUM_GPIO				9
-
-/* Regulator Index Definitions */
-#define TPS65910_REG_VRTC				0
-#define TPS65910_REG_VIO				1
-#define TPS65910_REG_VDD1				2
-#define TPS65910_REG_VDD2				3
-#define TPS65910_REG_VDD3				4
-#define TPS65910_REG_VDIG1				5
-#define TPS65910_REG_VDIG2				6
-#define TPS65910_REG_VPLL				7
-#define TPS65910_REG_VDAC				8
-#define TPS65910_REG_VAUX1				9
-#define TPS65910_REG_VAUX2				10
-#define TPS65910_REG_VAUX33				11
-#define TPS65910_REG_VMMC				12
-
-#define TPS65911_REG_VDDCTRL				4
-#define TPS65911_REG_LDO1				5
-#define TPS65911_REG_LDO2				6
-#define TPS65911_REG_LDO3				7
-#define TPS65911_REG_LDO4				8
-#define TPS65911_REG_LDO5				9
-#define TPS65911_REG_LDO6				10
-#define TPS65911_REG_LDO7				11
-#define TPS65911_REG_LDO8				12
-
-/* Max number of TPS65910/11 regulators */
-#define TPS65910_NUM_REGS				13
-
-/* External sleep controls through EN1/EN2/EN3/SLEEP inputs */
-#define TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1		0x1
-#define TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2		0x2
-#define TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3		0x4
-#define TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP		0x8
-
-
-
-
-
+/**
+ * struct tps65910_board
+ * Board platform data may be used to initialize regulators.
+ */
 
+struct tps65910_board {
+	int gpio_base;
+	int irq;
+	int irq_base;
+	int vmbch_threshold;
+	int vmbch2_threshold;
+	struct regulator_init_data *tps65910_pmic_init_data;
+};
 
 /**
  * struct tps65910 - tps65910 sub-driver chip access routines
@@ -801,17 +760,15 @@
 struct tps65910 {
 	struct device *dev;
 	struct i2c_client *i2c_client;
-	struct regmap *regmap;
 	struct mutex io_mutex;
-	struct wake_lock 	irq_wake;
 	unsigned int id;
 	int (*read)(struct tps65910 *tps65910, u8 reg, int size, void *dest);
 	int (*write)(struct tps65910 *tps65910, u8 reg, int size, void *src);
 
 	/* Client devices */
-	//struct tps65910_pmic *pmic;
-	//struct tps65910_rtc *rtc;
-	//struct tps65910_power *power;
+	struct tps65910_pmic *pmic;
+	struct tps65910_rtc *rtc;
+	struct tps65910_power *power;
 
 	/* GPIO Handling */
 	struct gpio_chip gpio;
@@ -829,45 +786,11 @@ struct tps65910_platform_data {
 	int irq_base;
 };
 
-
-/**
- * struct tps65910_board
- * Board platform data may be used to initialize regulators.
- */
-
-struct tps65910_board {
-	int gpio_base;
-	int irq;
-	int irq_base;
-	int vmbch_threshold;
-	int vmbch2_threshold;
-	bool en_gpio_sleep[TPS6591X_MAX_NUM_GPIO];
-	unsigned long regulator_ext_sleep_control[TPS65910_NUM_REGS];
-	struct regulator_init_data *tps65910_pmic_init_data[TPS65910_NUM_REGS];
-
-	/** Called before subdevices are set up */
-	int (*pre_init)(struct tps65910 *tps65910);
-	/** Called after subdevices are set up */
-	int (*post_init)(struct tps65910 *tps65910);
-	/** Called before subdevices are power down */
-	int (*last_deinit)(struct tps65910 *tps65910);
-};
-
-
 int tps65910_set_bits(struct tps65910 *tps65910, u8 reg, u8 mask);
 int tps65910_clear_bits(struct tps65910 *tps65910, u8 reg, u8 mask);
 void tps65910_gpio_init(struct tps65910 *tps65910, int gpio_base);
 int tps65910_irq_init(struct tps65910 *tps65910, int irq,
 		struct tps65910_platform_data *pdata);
-int tps65910_irq_exit(struct tps65910 *tps65910);
-int tps65910_reg_read(struct tps65910 *tps65910, u8 reg);
-int tps65910_reg_write(struct tps65910 *tps65910, u8 reg, u8 val);
-int tps65910_bulk_read(struct tps65910 *tps65910, u8 reg,
-		     int count, u8 *buf);
-int tps65910_bulk_write(struct tps65910 *tps65910, u8 reg,
-		     int count, u8 *buf);
-int tps65910_device_shutdown(void);
-
 
 static inline int tps65910_chip_id(struct tps65910 *tps65910)
 {
diff --git a/include/linux/mfd/tps65912.h b/include/linux/mfd/tps65912.h
deleted file mode 100644
index aaceab402ec5..000000000000
--- a/include/linux/mfd/tps65912.h
+++ /dev/null
@@ -1,327 +0,0 @@
-/*
- * tps65912.h  --  TI TPS6591x
- *
- * Copyright 2011 Texas Instruments Inc.
- *
- * Author: Margarita Olaya <magi@slimlogic.co.uk>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under  the terms of the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the License, or (at your
- *  option) any later version.
- *
- */
-
-#ifndef __LINUX_MFD_TPS65912_H
-#define __LINUX_MFD_TPS65912_H
-
-/* TPS regulator type list */
-#define REGULATOR_LDO		0
-#define REGULATOR_DCDC		1
-
-/*
- * List of registers for TPS65912
- */
-
-#define TPS65912_DCDC1_CTRL		0x00
-#define TPS65912_DCDC2_CTRL		0x01
-#define TPS65912_DCDC3_CTRL		0x02
-#define TPS65912_DCDC4_CTRL		0x03
-#define TPS65912_DCDC1_OP		0x04
-#define TPS65912_DCDC1_AVS		0x05
-#define TPS65912_DCDC1_LIMIT		0x06
-#define TPS65912_DCDC2_OP		0x07
-#define TPS65912_DCDC2_AVS		0x08
-#define TPS65912_DCDC2_LIMIT		0x09
-#define TPS65912_DCDC3_OP		0x0A
-#define TPS65912_DCDC3_AVS		0x0B
-#define TPS65912_DCDC3_LIMIT		0x0C
-#define TPS65912_DCDC4_OP		0x0D
-#define TPS65912_DCDC4_AVS		0x0E
-#define TPS65912_DCDC4_LIMIT		0x0F
-#define TPS65912_LDO1_OP		0x10
-#define TPS65912_LDO1_AVS		0x11
-#define TPS65912_LDO1_LIMIT		0x12
-#define TPS65912_LDO2_OP		0x13
-#define TPS65912_LDO2_AVS		0x14
-#define TPS65912_LDO2_LIMIT		0x15
-#define TPS65912_LDO3_OP		0x16
-#define TPS65912_LDO3_AVS		0x17
-#define TPS65912_LDO3_LIMIT		0x18
-#define TPS65912_LDO4_OP		0x19
-#define TPS65912_LDO4_AVS		0x1A
-#define TPS65912_LDO4_LIMIT		0x1B
-#define TPS65912_LDO5			0x1C
-#define TPS65912_LDO6			0x1D
-#define TPS65912_LDO7			0x1E
-#define TPS65912_LDO8			0x1F
-#define TPS65912_LDO9			0x20
-#define TPS65912_LDO10			0x21
-#define TPS65912_THRM			0x22
-#define TPS65912_CLK32OUT		0x23
-#define TPS65912_DEVCTRL		0x24
-#define TPS65912_DEVCTRL2		0x25
-#define TPS65912_I2C_SPI_CFG		0x26
-#define TPS65912_KEEP_ON		0x27
-#define TPS65912_KEEP_ON2		0x28
-#define TPS65912_SET_OFF1		0x29
-#define TPS65912_SET_OFF2		0x2A
-#define TPS65912_DEF_VOLT		0x2B
-#define TPS65912_DEF_VOLT_MAPPING	0x2C
-#define TPS65912_DISCHARGE		0x2D
-#define TPS65912_DISCHARGE2		0x2E
-#define TPS65912_EN1_SET1		0x2F
-#define TPS65912_EN1_SET2		0x30
-#define TPS65912_EN2_SET1		0x31
-#define TPS65912_EN2_SET2		0x32
-#define TPS65912_EN3_SET1		0x33
-#define TPS65912_EN3_SET2		0x34
-#define TPS65912_EN4_SET1		0x35
-#define TPS65912_EN4_SET2		0x36
-#define TPS65912_PGOOD			0x37
-#define TPS65912_PGOOD2			0x38
-#define TPS65912_INT_STS		0x39
-#define TPS65912_INT_MSK		0x3A
-#define TPS65912_INT_STS2		0x3B
-#define TPS65912_INT_MSK2		0x3C
-#define TPS65912_INT_STS3		0x3D
-#define TPS65912_INT_MSK3		0x3E
-#define TPS65912_INT_STS4		0x3F
-#define TPS65912_INT_MSK4		0x40
-#define TPS65912_GPIO1			0x41
-#define TPS65912_GPIO2			0x42
-#define TPS65912_GPIO3			0x43
-#define TPS65912_GPIO4			0x44
-#define TPS65912_GPIO5			0x45
-#define TPS65912_VMON			0x46
-#define TPS65912_LEDA_CTRL1		0x47
-#define TPS65912_LEDA_CTRL2		0x48
-#define TPS65912_LEDA_CTRL3		0x49
-#define TPS65912_LEDA_CTRL4		0x4A
-#define TPS65912_LEDA_CTRL5		0x4B
-#define TPS65912_LEDA_CTRL6		0x4C
-#define TPS65912_LEDA_CTRL7		0x4D
-#define TPS65912_LEDA_CTRL8		0x4E
-#define TPS65912_LEDB_CTRL1		0x4F
-#define TPS65912_LEDB_CTRL2		0x50
-#define TPS65912_LEDB_CTRL3		0x51
-#define TPS65912_LEDB_CTRL4		0x52
-#define TPS65912_LEDB_CTRL5		0x53
-#define TPS65912_LEDB_CTRL6		0x54
-#define TPS65912_LEDB_CTRL7		0x55
-#define TPS65912_LEDB_CTRL8		0x56
-#define TPS65912_LEDC_CTRL1		0x57
-#define TPS65912_LEDC_CTRL2		0x58
-#define TPS65912_LEDC_CTRL3		0x59
-#define TPS65912_LEDC_CTRL4		0x5A
-#define TPS65912_LEDC_CTRL5		0x5B
-#define TPS65912_LEDC_CTRL6		0x5C
-#define TPS65912_LEDC_CTRL7		0x5D
-#define TPS65912_LEDC_CTRL8		0x5E
-#define TPS65912_LED_RAMP_UP_TIME	0x5F
-#define TPS65912_LED_RAMP_DOWN_TIME	0x60
-#define TPS65912_LED_SEQ_EN		0x61
-#define TPS65912_LOADSWITCH		0x62
-#define TPS65912_SPARE			0x63
-#define TPS65912_VERNUM			0x64
-#define TPS6591X_MAX_REGISTER		0x64
-
-/* IRQ Definitions */
-#define TPS65912_IRQ_PWRHOLD_F		0
-#define TPS65912_IRQ_VMON		1
-#define TPS65912_IRQ_PWRON		2
-#define TPS65912_IRQ_PWRON_LP		3
-#define TPS65912_IRQ_PWRHOLD_R		4
-#define TPS65912_IRQ_HOTDIE		5
-#define TPS65912_IRQ_GPIO1_R		6
-#define TPS65912_IRQ_GPIO1_F		7
-#define TPS65912_IRQ_GPIO2_R		8
-#define TPS65912_IRQ_GPIO2_F		9
-#define TPS65912_IRQ_GPIO3_R		10
-#define TPS65912_IRQ_GPIO3_F		11
-#define TPS65912_IRQ_GPIO4_R		12
-#define TPS65912_IRQ_GPIO4_F		13
-#define TPS65912_IRQ_GPIO5_R		14
-#define TPS65912_IRQ_GPIO5_F		15
-#define TPS65912_IRQ_PGOOD_DCDC1	16
-#define TPS65912_IRQ_PGOOD_DCDC2	17
-#define TPS65912_IRQ_PGOOD_DCDC3	18
-#define TPS65912_IRQ_PGOOD_DCDC4	19
-#define TPS65912_IRQ_PGOOD_LDO1		20
-#define TPS65912_IRQ_PGOOD_LDO2		21
-#define TPS65912_IRQ_PGOOD_LDO3		22
-#define TPS65912_IRQ_PGOOD_LDO4		23
-#define TPS65912_IRQ_PGOOD_LDO5		24
-#define TPS65912_IRQ_PGOOD_LDO6		25
-#define TPS65912_IRQ_PGOOD_LDO7		26
-#define TPS65912_IRQ_PGOOD_LD08		27
-#define TPS65912_IRQ_PGOOD_LDO9		28
-#define TPS65912_IRQ_PGOOD_LDO10	29
-
-#define TPS65912_NUM_IRQ		30
-
-/* GPIO 1 and 2 Register Definitions */
-#define GPIO_SLEEP_MASK			0x80
-#define GPIO_SLEEP_SHIFT		7
-#define GPIO_DEB_MASK			0x10
-#define GPIO_DEB_SHIFT			4
-#define GPIO_CFG_MASK			0x04
-#define GPIO_CFG_SHIFT			2
-#define GPIO_STS_MASK			0x02
-#define GPIO_STS_SHIFT			1
-#define GPIO_SET_MASK			0x01
-#define GPIO_SET_SHIFT			0
-
-/* GPIO 3 Register Definitions */
-#define GPIO3_SLEEP_MASK		0x80
-#define GPIO3_SLEEP_SHIFT		7
-#define GPIO3_SEL_MASK			0x40
-#define GPIO3_SEL_SHIFT			6
-#define GPIO3_ODEN_MASK			0x20
-#define GPIO3_ODEN_SHIFT		5
-#define GPIO3_DEB_MASK			0x10
-#define GPIO3_DEB_SHIFT			4
-#define GPIO3_PDEN_MASK			0x08
-#define GPIO3_PDEN_SHIFT		3
-#define GPIO3_CFG_MASK			0x04
-#define GPIO3_CFG_SHIFT			2
-#define GPIO3_STS_MASK			0x02
-#define GPIO3_STS_SHIFT			1
-#define GPIO3_SET_MASK			0x01
-#define GPIO3_SET_SHIFT			0
-
-/* GPIO 4 Register Definitions */
-#define GPIO4_SLEEP_MASK		0x80
-#define GPIO4_SLEEP_SHIFT		7
-#define GPIO4_SEL_MASK			0x40
-#define GPIO4_SEL_SHIFT			6
-#define GPIO4_ODEN_MASK			0x20
-#define GPIO4_ODEN_SHIFT		5
-#define GPIO4_DEB_MASK			0x10
-#define GPIO4_DEB_SHIFT			4
-#define GPIO4_PDEN_MASK			0x08
-#define GPIO4_PDEN_SHIFT		3
-#define GPIO4_CFG_MASK			0x04
-#define GPIO4_CFG_SHIFT			2
-#define GPIO4_STS_MASK			0x02
-#define GPIO4_STS_SHIFT			1
-#define GPIO4_SET_MASK			0x01
-#define GPIO4_SET_SHIFT			0
-
-/* Register THERM  (0x80) register.RegisterDescription */
-#define THERM_THERM_HD_MASK		0x20
-#define THERM_THERM_HD_SHIFT		5
-#define THERM_THERM_TS_MASK		0x10
-#define THERM_THERM_TS_SHIFT		4
-#define THERM_THERM_HDSEL_MASK		0x0C
-#define THERM_THERM_HDSEL_SHIFT		2
-#define THERM_RSVD1_MASK		0x02
-#define THERM_RSVD1_SHIFT		1
-#define THERM_THERM_STATE_MASK		0x01
-#define THERM_THERM_STATE_SHIFT		0
-
-/* Register DCDCCTRL1 register.RegisterDescription */
-#define DCDCCTRL_VCON_ENABLE_MASK	0x80
-#define DCDCCTRL_VCON_ENABLE_SHIFT	7
-#define DCDCCTRL_VCON_RANGE1_MASK	0x40
-#define DCDCCTRL_VCON_RANGE1_SHIFT	6
-#define DCDCCTRL_VCON_RANGE0_MASK	0x20
-#define DCDCCTRL_VCON_RANGE0_SHIFT	5
-#define DCDCCTRL_TSTEP2_MASK		0x10
-#define DCDCCTRL_TSTEP2_SHIFT		4
-#define DCDCCTRL_TSTEP1_MASK		0x08
-#define DCDCCTRL_TSTEP1_SHIFT		3
-#define DCDCCTRL_TSTEP0_MASK		0x04
-#define DCDCCTRL_TSTEP0_SHIFT		2
-#define DCDCCTRL_DCDC1_MODE_MASK	0x02
-#define DCDCCTRL_DCDC1_MODE_SHIFT	1
-
-/* Register DCDCCTRL2 and DCDCCTRL3 register.RegisterDescription */
-#define DCDCCTRL_TSTEP2_MASK		0x10
-#define DCDCCTRL_TSTEP2_SHIFT		4
-#define DCDCCTRL_TSTEP1_MASK		0x08
-#define DCDCCTRL_TSTEP1_SHIFT		3
-#define DCDCCTRL_TSTEP0_MASK		0x04
-#define DCDCCTRL_TSTEP0_SHIFT		2
-#define DCDCCTRL_DCDC_MODE_MASK		0x02
-#define DCDCCTRL_DCDC_MODE_SHIFT	1
-#define DCDCCTRL_RSVD0_MASK		0x01
-#define DCDCCTRL_RSVD0_SHIFT		0
-
-/* Register DCDCCTRL4 register.RegisterDescription */
-#define DCDCCTRL_RAMP_TIME_MASK		0x01
-#define DCDCCTRL_RAMP_TIME_SHIFT	0
-
-/* Register DCDCx_AVS */
-#define DCDC_AVS_ENABLE_MASK		0x80
-#define DCDC_AVS_ENABLE_SHIFT		7
-#define DCDC_AVS_ECO_MASK		0x40
-#define DCDC_AVS_ECO_SHIFT		6
-
-/* Register DCDCx_LIMIT */
-#define DCDC_LIMIT_RANGE_MASK		0xC0
-#define DCDC_LIMIT_RANGE_SHIFT		6
-#define DCDC_LIMIT_MAX_SEL_MASK		0x3F
-#define DCDC_LIMIT_MAX_SEL_SHIFT	0
-
-/**
- * struct tps65912_board
- * Board platform dat may be used to initialize regulators.
- */
-struct tps65912_board {
-	int is_dcdc1_avs;
-	int is_dcdc2_avs;
-	int is_dcdc3_avs;
-	int is_dcdc4_avs;
-	int irq;
-	int irq_base;
-	int gpio_base;
-	struct regulator_init_data *tps65912_pmic_init_data;
-};
-
-/**
- * struct tps65912 - tps65912 sub-driver chip access routines
- */
-
-struct tps65912 {
-	struct device *dev;
-	/* for read/write acces */
-	struct mutex io_mutex;
-
-	/* For device IO interfaces: I2C or SPI */
-	void *control_data;
-
-	int (*read)(struct tps65912 *tps65912, u8 reg, int size, void *dest);
-	int (*write)(struct tps65912 *tps65912, u8 reg, int size, void *src);
-
-	/* Client devices */
-	struct tps65912_pmic *pmic;
-
-	/* GPIO Handling */
-	struct gpio_chip gpio;
-
-	/* IRQ Handling */
-	struct mutex irq_lock;
-	int chip_irq;
-	int irq_base;
-	int irq_num;
-	u32 irq_mask;
-};
-
-struct tps65912_platform_data {
-	int irq;
-	int irq_base;
-};
-
-unsigned int tps_chip(void);
-
-int tps65912_set_bits(struct tps65912 *tps65912, u8 reg, u8 mask);
-int tps65912_clear_bits(struct tps65912 *tps65912, u8 reg, u8 mask);
-int tps65912_reg_read(struct tps65912 *tps65912, u8 reg);
-int tps65912_reg_write(struct tps65912 *tps65912, u8 reg, u8 val);
-int tps65912_device_init(struct tps65912 *tps65912);
-void tps65912_device_exit(struct tps65912 *tps65912);
-int tps65912_irq_init(struct tps65912 *tps65912, int irq,
-			struct tps65912_platform_data *pdata);
-
-#endif /*  __LINUX_MFD_TPS65912_H */
diff --git a/include/linux/mfd/wm831x/core.h b/include/linux/mfd/wm831x/core.h
index e7efae4eb4af..0d515ee1c247 100644
--- a/include/linux/mfd/wm831x/core.h
+++ b/include/linux/mfd/wm831x/core.h
@@ -17,8 +17,6 @@
 
 #include <linux/completion.h>
 #include <linux/interrupt.h>
-#include <linux/wakelock.h>
-#include <linux/regulator/driver.h>
 
 /*
  * Register values.
@@ -239,7 +237,6 @@
 struct regulator_dev;
 
 #define WM831X_NUM_IRQ_REGS 5
-#define WM831X_IRQ_LIST	1
 
 enum wm831x_parent {
 	WM8310 = 0x8310,
@@ -263,19 +260,7 @@ struct wm831x {
 	void *control_data;
 
 	int irq;  /* Our chip IRQ */
-	int flag_suspend;
-	spinlock_t		flag_lock;
 	struct mutex irq_lock;
-	struct workqueue_struct *irq_wq;
-	struct delayed_work irq_work;
-	struct wake_lock 	irq_wake;
-	struct wake_lock 	handle_wake;
-#if WM831X_IRQ_LIST
-	struct workqueue_struct *handle_wq;
-	struct work_struct handle_work;
-	spinlock_t		work_lock;
-	struct list_head	handle_queue;
-#endif
 	unsigned int irq_base;
 	int irq_masks_cur[WM831X_NUM_IRQ_REGS];   /* Currently active value */
 	int irq_masks_cache[WM831X_NUM_IRQ_REGS]; /* Cached hardware value */
@@ -299,39 +284,6 @@ struct wm831x {
 	unsigned int locked:1;
 };
 
-#define WM831X_DCDC_MAX_NAME 6
-#define WM831X_LDO_MAX_NAME 6
-#define WM831X_ISINK_MAX_NAME 7
-
-struct wm831x_dcdc {
-        char name[WM831X_DCDC_MAX_NAME];
-        struct regulator_desc desc;
-        int base;
-        struct wm831x *wm831x;
-        struct regulator_dev *regulator;
-        int dvs_gpio;
-        int dvs_gpio_state;
-        int on_vsel;
-        int dvs_vsel;
-};
-
-struct wm831x_ldo {
-        char name[WM831X_LDO_MAX_NAME];
-        struct regulator_desc desc;
-        int base;
-        struct wm831x *wm831x;
-        struct regulator_dev *regulator;
-};
-
-struct wm831x_isink {
-        char name[WM831X_ISINK_MAX_NAME];
-        struct regulator_desc desc;
-        int reg;
-        struct wm831x *wm831x;
-        struct regulator_dev *regulator;
-};
-
-
 /* Device I/O API */
 int wm831x_reg_read(struct wm831x *wm831x, unsigned short reg);
 int wm831x_reg_write(struct wm831x *wm831x, unsigned short reg,
@@ -346,37 +298,7 @@ int wm831x_bulk_read(struct wm831x *wm831x, unsigned short reg,
 int wm831x_device_init(struct wm831x *wm831x, unsigned long id, int irq);
 void wm831x_device_exit(struct wm831x *wm831x);
 int wm831x_device_suspend(struct wm831x *wm831x);
-int wm831x_device_resume(struct wm831x *wm831x);
-int wm831x_device_shutdown(struct wm831x *wm831x);
-int wm831x_read_usb(struct wm831x *wm831x);
-int wm831x_device_restart(struct wm831x *wm831x);
 int wm831x_irq_init(struct wm831x *wm831x, int irq);
 void wm831x_irq_exit(struct wm831x *wm831x);
 
-static inline int __must_check wm831x_request_irq(struct wm831x *wm831x,
-						  unsigned int irq,
-						  irq_handler_t handler,
-						  unsigned long flags,
-						  const char *name,
-						  void *dev)
-{
-	return request_threaded_irq(irq, NULL, handler, flags, name, dev);
-}
-
-static inline void wm831x_free_irq(struct wm831x *wm831x,
-				   unsigned int irq, void *dev)
-{
-	free_irq(irq, dev);
-}
-
-static inline void wm831x_disable_irq(struct wm831x *wm831x, int irq)
-{
-	disable_irq(irq);
-}
-
-static inline void wm831x_enable_irq(struct wm831x *wm831x, int irq)
-{
-	enable_irq(irq);
-}
-
 #endif
diff --git a/include/linux/mfd/wm831x/irq.h b/include/linux/mfd/wm831x/irq.h
index 6281372d702f..3a8c97656fda 100644
--- a/include/linux/mfd/wm831x/irq.h
+++ b/include/linux/mfd/wm831x/irq.h
@@ -412,17 +412,17 @@
 #define WM831X_GP1_EINT_SHIFT                        0  /* GP1_EINT */
 #define WM831X_GP1_EINT_WIDTH                        1  /* GP1_EINT */
 
-
 /*
- * Reg (0x4017) - IRQ Config
+ * R16407 (0x4017) - IRQ Config
  */
- #define WM831X_IRQ_OD_ENABLE                         0x0002  /* CMOS/open drain */
-#define WM831X_IRQ_OD_MASK                     0x0002  /* CMOS/open drain */
-#define WM831X_IRQ_OD_SHIFT                        2 /* CMOS/open drain */
-#define WM831X_IRQ_IM_EANBLE                          0x0001  /* IM_IRQ */
-#define WM831X_IRQ_IM_MASK                     0x0001  /* IM_IRQ */
-#define WM831X_IRQ_IM_SHIFT                        0   /* IM_IRQ */
-
+#define WM831X_IRQ_OD                           0x0002  /* IRQ_OD */
+#define WM831X_IRQ_OD_MASK                      0x0002  /* IRQ_OD */
+#define WM831X_IRQ_OD_SHIFT                          1  /* IRQ_OD */
+#define WM831X_IRQ_OD_WIDTH                          1  /* IRQ_OD */
+#define WM831X_IM_IRQ                           0x0001  /* IM_IRQ */
+#define WM831X_IM_IRQ_MASK                      0x0001  /* IM_IRQ */
+#define WM831X_IM_IRQ_SHIFT                          0  /* IM_IRQ */
+#define WM831X_IM_IRQ_WIDTH                          1  /* IM_IRQ */
 
 /*
  * R16408 (0x4018) - System Interrupts Mask
diff --git a/include/linux/mfd/wm831x/pdata.h b/include/linux/mfd/wm831x/pdata.h
index ae2042ebd9bf..ff42d700293f 100644
--- a/include/linux/mfd/wm831x/pdata.h
+++ b/include/linux/mfd/wm831x/pdata.h
@@ -39,8 +39,6 @@ struct wm831x_battery_pdata {
 	int eoc_iterm;      /** End of trickle charge current, in mA */
 	int fast_ilim;      /** Fast charge current limit, in mA */
 	int timeout;        /** Charge cycle timeout, in minutes */
-	int syslo;          /** syslo threshold, in mV**/
-	int sysok;          /** sysok threshold, in mV**/
 };
 
 /**
@@ -101,23 +99,6 @@ struct wm831x_watchdog_pdata {
 	unsigned int software:1;
 };
 
-struct wm831x_gpio_keys_button {
-	/* Configuration parameters */
-	int code;		/* input event code (KEY_*, SW_*) */
-	int gpio;
-	int active_low;
-	char *desc;
-	int type;		/* input event type (EV_KEY, EV_SW) */
-	int wakeup;		/* configure the button as a wake-up source */
-	int debounce_interval;	/* debounce ticks interval in msecs */
-};
-
-struct wm831x_gpio_keys_pdata {
-	struct wm831x_gpio_keys_button *buttons;
-	int nbuttons;
-	unsigned int rep:1;		/* enable input subsystem auto repeat */
-};
-
 #define WM831X_MAX_STATUS 2
 #define WM831X_MAX_DCDC   4
 #define WM831X_MAX_EPE    2
@@ -135,14 +116,6 @@ struct wm831x_pdata {
 	int (*pre_init)(struct wm831x *wm831x);
 	/** Called after subdevices are set up */
 	int (*post_init)(struct wm831x *wm831x);
-	/** Called before subdevices are power down */
-	int (*last_deinit)(struct wm831x *wm831x);
-	//add by sxj
-	unsigned int gpio_pin_num;
-	void *settinginfo;
-	int settinginfolen;
-	int (*pin_type_init)(struct wm831x *wm831x);
-	//above add by sxj
 
 	/** Put the /IRQ line into CMOS mode */
 	bool irq_cmos;
@@ -155,9 +128,6 @@ struct wm831x_pdata {
 	struct wm831x_battery_pdata *battery;
 	struct wm831x_touch_pdata *touch;
 	struct wm831x_watchdog_pdata *watchdog;
-	//add by srt
-	struct wm831x_gpio_keys_pdata *gpio_keys;
-	//end by srt
 
 	/** LED1 = 0 and so on */
 	struct wm831x_status_pdata *status[WM831X_MAX_STATUS];
diff --git a/include/linux/mfd/wm831x/pmu.h b/include/linux/mfd/wm831x/pmu.h
index 163a31d66662..b18cbb027bc3 100644
--- a/include/linux/mfd/wm831x/pmu.h
+++ b/include/linux/mfd/wm831x/pmu.h
@@ -14,8 +14,7 @@
 
 #ifndef __MFD_WM831X_PMU_H__
 #define __MFD_WM831X_PMU_H__
-/*    rtc cntrol (0x4025) */
-#define WM831X_RTC_ALAM_ENA_MASK 0x0400
+
 /*
  * R16387 (0x4003) - Power State
  */
diff --git a/include/linux/mfd/wm8994/pdata.h b/include/linux/mfd/wm8994/pdata.h
index 8f9411d572f1..97cf4f27d647 100644
--- a/include/linux/mfd/wm8994/pdata.h
+++ b/include/linux/mfd/wm8994/pdata.h
@@ -24,10 +24,6 @@ struct wm8994_ldo_pdata {
 
 	const char *supply;
 	struct regulator_init_data *init_data;
-
-	//wm8994 LDO1_ENA and LDO2_ENA
-	char	iomux_name[50];
-	int		iomux_mode;	
 };
 
 #define WM8994_CONFIGURE_GPIO 0x10000
@@ -119,36 +115,22 @@ struct wm8958_enh_eq_cfg {
 
 struct wm8994_pdata {
 	int gpio_base;
+
 	/**
 	 * Default values for GPIOs if non-zero, WM8994_CONFIGURE_GPIO
 	 * can be used for all zero values.
 	 */
 	int gpio_defaults[WM8994_NUM_GPIO];
+
 	struct wm8994_ldo_pdata ldo[WM8994_NUM_LDO];
-	
-	int num_drc_cfgs;
-	struct wm8994_drc_cfg *drc_cfgs;
-	int num_retune_mobile_cfgs;
-	struct wm8994_retune_mobile_cfg *retune_mobile_cfgs;
-	
-	/* LINEOUT can be differential or single ended */
-	unsigned int lineout1_diff:1;
-	unsigned int lineout2_diff:1;//do not use	
-	/* Common mode feedback */
-	unsigned int lineout1fb:1;
-	unsigned int lineout2fb:1;//do not use
-
-	//If an external amplifier speakers wm8994		enable>0 disable=0
-	unsigned int PA_control_pin;
-	char	PA_iomux_name[50];
-	int		PA_iomux_mode;		
-
-
-	
-
-	
-	/** Base IRQ number for WM8994, required for IRQs */
-	int irq_base;  	//do not use
+
+	int irq_base;  /** Base IRQ number for WM8994, required for IRQs */
+
+        int num_drc_cfgs;
+        struct wm8994_drc_cfg *drc_cfgs;
+
+        int num_retune_mobile_cfgs;
+        struct wm8994_retune_mobile_cfg *retune_mobile_cfgs;
 
 	int num_mbc_cfgs;
 	struct wm8958_mbc_cfg *mbc_cfgs;
@@ -162,18 +144,26 @@ struct wm8994_pdata {
 	int num_enh_eq_cfgs;
 	struct wm8958_enh_eq_cfg *enh_eq_cfgs;
 
+        /* LINEOUT can be differential or single ended */
+        unsigned int lineout1_diff:1;
+        unsigned int lineout2_diff:1;
+
+        /* Common mode feedback */
+        unsigned int lineout1fb:1;
+        unsigned int lineout2fb:1;
+
 	/* IRQ for microphone detection if brought out directly as a
 	 * signal.
 	 */
-	int micdet_irq;//do not use
+	int micdet_irq;
 
-	/* WM8994 microphone biases: 0=0.9*AVDD1 1=0.65*AVVD1 */
-	unsigned int micbias1_lvl:1;//default 0	Do not set
-	unsigned int micbias2_lvl:1;//default 0	Do not set
+        /* WM8994 microphone biases: 0=0.9*AVDD1 1=0.65*AVVD1 */
+        unsigned int micbias1_lvl:1;
+        unsigned int micbias2_lvl:1;
 
-	/* WM8994 jack detect threashold levels, see datasheet for values */
-	unsigned int jd_scthr:2;//do not use
-	unsigned int jd_thr:2;//do not use
+        /* WM8994 jack detect threashold levels, see datasheet for values */
+        unsigned int jd_scthr:2;
+        unsigned int jd_thr:2;
 
 	/* WM8958 microphone bias configuration */
 	int micbias[2];
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index ca107853d632..6ad43554ac05 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -16,7 +16,6 @@
 struct mmc_cid {
 	unsigned int		manfid;
 	char			prod_name[8];
-	unsigned char		prv;
 	unsigned int		serial;
 	unsigned short		oemid;
 	unsigned short		year;
@@ -51,21 +50,9 @@ struct mmc_ext_csd {
 	u8			rel_sectors;
 	u8			rel_param;
 	u8			part_config;
-	u8			cache_ctrl;
-	u8			rst_n_function;
-	u8			max_packed_writes;
-	u8			max_packed_reads;
-	u8			packed_event_en;
 	unsigned int		part_time;		/* Units: ms */
 	unsigned int		sa_timeout;		/* Units: 100ns */
-	unsigned int		generic_cmd6_time;	/* Units: 10ms */
-	unsigned int        power_off_longtime;     /* Units: ms */
-	u8			power_off_notification;	/* state */
 	unsigned int		hs_max_dtr;
-	#define MMC_HIGH_26_MAX_DTR	26000000
-    #define MMC_HIGH_52_MAX_DTR	52000000
-    #define MMC_HIGH_DDR_MAX_DTR	52000000
-    #define MMC_HS200_MAX_DTR	200000000
 	unsigned int		sectors;
 	unsigned int		card_type;
 	unsigned int		hc_erase_size;		/* In sectors */
@@ -77,23 +64,10 @@ struct mmc_ext_csd {
 	unsigned long long	enhanced_area_offset;	/* Units: Byte */
 	unsigned int		enhanced_area_size;	/* Units: KB */
 	unsigned int		boot_size;		/* in bytes */
-	unsigned int		cache_size;		/* Units: KB */
-	bool			hpi_en;			/* HPI enablebit */
-	bool			hpi;			/* HPI support bit */
-	unsigned int		hpi_cmd;		/* cmd used as HPI */
-	bool			bkops;		/* background support bit */
-	bool			bkops_en;	/* background enable bit */
-	unsigned int            data_sector_size;       /* 512 bytes or 4KB */
-	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
-	unsigned int		boot_ro_lock;		/* ro lock support */
-	bool			boot_ro_lockable;
-	u8			raw_exception_status;	/* 54 */
 	u8			raw_partition_support;	/* 160 */
-	u8			raw_rpmb_size_mult;	/* 168 */
 	u8			raw_erased_mem_count;	/* 181 */
 	u8			raw_ext_csd_structure;	/* 194 */
 	u8			raw_card_type;		/* 196 */
-	u8			out_of_int_time;	/* 198 */
 	u8			raw_s_a_timeout;		/* 217 */
 	u8			raw_hc_erase_gap_size;	/* 221 */
 	u8			raw_erase_timeout_mult;	/* 223 */
@@ -102,11 +76,7 @@ struct mmc_ext_csd {
 	u8			raw_sec_erase_mult;	/* 230 */
 	u8			raw_sec_feature_support;/* 231 */
 	u8			raw_trim_mult;		/* 232 */
-	u8			raw_bkops_status;	/* 246 */
 	u8			raw_sectors[4];		/* 212 - 4 bytes */
-
-	unsigned int            feature_support;
-    #define MMC_DISCARD_FEATURE	BIT(0)                  /* CMD38 feature */
 };
 
 struct sd_scr {
@@ -156,7 +126,6 @@ struct sd_switch_caps {
 #define SD_SET_CURRENT_LIMIT_400	1
 #define SD_SET_CURRENT_LIMIT_600	2
 #define SD_SET_CURRENT_LIMIT_800	3
-#define SD_SET_CURRENT_NO_CHANGE	(-1)
 
 #define SD_MAX_CURRENT_200	(1 << SD_SET_CURRENT_LIMIT_200)
 #define SD_MAX_CURRENT_400	(1 << SD_SET_CURRENT_LIMIT_400)
@@ -188,30 +157,6 @@ struct sdio_func_tuple;
 
 #define SDIO_MAX_FUNCS		7
 
-/* The number of MMC physical partitions.  These consist of:
- * boot partitions (2), general purpose partitions (4) in MMC v4.4.
- */
-#define MMC_NUM_BOOT_PARTITION	2
-#define MMC_NUM_GP_PARTITION	4
-#define MMC_NUM_PHY_PARTITION	6
-#define MAX_MMC_PART_NAME_LEN	20
-
-/*
- * MMC Physical partitions
- */
-struct mmc_part {
-	unsigned int	size;	/* partition size (in bytes) */
-	unsigned int	part_cfg;	/* partition type */
-	char	name[MAX_MMC_PART_NAME_LEN];
-	bool	force_ro;	/* to make boot parts RO by default */
-	unsigned int	area_type;
-#define MMC_BLK_DATA_AREA_MAIN	(1<<0)
-#define MMC_BLK_DATA_AREA_BOOT	(1<<1)
-#define MMC_BLK_DATA_AREA_GP	(1<<2)
-#define MMC_BLK_DATA_AREA_RPMB	(1<<3)
-};
-
-
 /*
  * MMC device
  */
@@ -232,10 +177,6 @@ struct mmc_card {
 #define MMC_STATE_HIGHSPEED_DDR (1<<4)		/* card is in high speed mode */
 #define MMC_STATE_ULTRAHIGHSPEED (1<<5)		/* card is in ultra high speed mode */
 #define MMC_CARD_SDXC		(1<<6)		/* card is SDXC */
-#define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
-#define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
-#define MMC_STATE_DOING_BKOPS	(1<<10)		/* card is doing BKOPS */
-
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -247,10 +188,6 @@ struct mmc_card {
 #define MMC_QUIRK_DISABLE_CD	(1<<5)		/* disconnect CD/DAT[3] resistor */
 #define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */
 #define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
-#define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
-#define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
-#define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)	/* Skip secure for erase/trim */
-
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
@@ -279,31 +216,8 @@ struct mmc_card {
 	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
 
 	struct dentry		*debugfs_root;
-	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
-	unsigned int    nr_parts;
 };
 
-/*
- * This function fill contents in mmc_part.
- */
-static inline void mmc_part_add(struct mmc_card *card, unsigned int size,
-			unsigned int part_cfg, char *name, int idx, bool ro,
-			int area_type)
-{
-	card->part[card->nr_parts].size = size;
-	card->part[card->nr_parts].part_cfg = part_cfg;
-	sprintf(card->part[card->nr_parts].name, name, idx);
-	card->part[card->nr_parts].force_ro = ro;
-	card->part[card->nr_parts].area_type = area_type;
-	card->nr_parts++;
-}
-
-static inline bool mmc_large_sector(struct mmc_card *card)
-{
-	return card->ext_csd.data_sector_size == 4096;
-}
-
-
 /*
  *  The world is not perfect and supplies us with broken mmc/sdio devices.
  *  For at least some of these bugs we need a work-around.
@@ -396,17 +310,12 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
 #define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
-#define mmc_card_hs200(c)	((c)->state & MMC_STATE_HIGHSPEED_200)
-#define mmc_card_set_hs200(c)	((c)->state |= MMC_STATE_HIGHSPEED_200)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
 #define mmc_card_ddr_mode(c)	((c)->state & MMC_STATE_HIGHSPEED_DDR)
-#define mmc_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_sd_card_uhs(c) ((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
-#define mmc_card_clr_present(c)	((c)->state &= ~MMC_STATE_PRESENT)
-
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
@@ -414,7 +323,6 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 
-
 /*
  * Quirk add/remove for MMC products.
  */
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index 1b1d92dff892..b6718e549a51 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -117,7 +117,6 @@ struct mmc_data {
 
 	unsigned int		sg_len;		/* size of scatter list */
 	struct scatterlist	*sg;		/* I/O scatter list */
-	s32			host_cookie;	/* host private data */
 };
 
 struct mmc_request {
@@ -126,16 +125,13 @@ struct mmc_request {
 	struct mmc_data		*data;
 	struct mmc_command	*stop;
 
-	struct completion	completion;
+	void			*done_data;	/* completion data */
 	void			(*done)(struct mmc_request *);/* completion function */
 };
 
 struct mmc_host;
 struct mmc_card;
-struct mmc_async_req;
 
-extern struct mmc_async_req *mmc_start_req(struct mmc_host *,
-					   struct mmc_async_req *, int *);
 extern void mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
 extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
 extern int mmc_app_cmd(struct mmc_host *, struct mmc_card *);
@@ -159,7 +155,6 @@ extern int mmc_can_trim(struct mmc_card *card);
 extern int mmc_can_secure_erase_trim(struct mmc_card *card);
 extern int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
 				   unsigned int nr);
-extern unsigned int mmc_calc_max_discard(struct mmc_card *card);
 
 extern int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen);
 
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 4df54d991241..2e46d530086a 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -56,7 +56,6 @@ struct mmc_ios {
 #define MMC_TIMING_UHS_SDR50	3
 #define MMC_TIMING_UHS_SDR104	4
 #define MMC_TIMING_UHS_DDR50	5
-#define MMC_TIMING_MMC_HS200	8
 
 	unsigned char	ddr;			/* dual data rate used */
 
@@ -108,15 +107,6 @@ struct mmc_host_ops {
 	 */
 	int (*enable)(struct mmc_host *host);
 	int (*disable)(struct mmc_host *host, int lazy);
-	/*
-	 * It is optional for the host to implement pre_req and post_req in
-	 * order to support double buffering of requests (prepare one
-	 * request while another request is active).
-	 */
-	void	(*post_req)(struct mmc_host *host, struct mmc_request *req,
-			    int err);
-	void	(*pre_req)(struct mmc_host *host, struct mmc_request *req,
-			   bool is_first_req);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
 	/*
 	 * Avoid calling these three functions too often or in a "fast path",
@@ -146,32 +136,15 @@ struct mmc_host_ops {
 
 	/* optional callback for HC quirks */
 	void	(*init_card)(struct mmc_host *host, struct mmc_card *card);
-	/* Check if the card is pulling dat[0:3] low */
-	int	(*card_busy)(struct mmc_host *host);
 
-    int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
-    
 	int	(*start_signal_voltage_switch)(struct mmc_host *host, struct mmc_ios *ios);
-	/* The tuning command opcode value is different for SD and eMMC cards */
-	int	(*execute_tuning)(struct mmc_host *host,u32 opcode);
+	int	(*execute_tuning)(struct mmc_host *host);
 	void	(*enable_preset_value)(struct mmc_host *host, bool enable);
 };
 
 struct mmc_card;
 struct device;
 
-struct mmc_async_req {
-	/* active mmc request */
-	struct mmc_request	*mrq;
-	/*
-	 * Check error status of completed mmc request.
-	 * Returns 0 if success otherwise non zero.
-	 */
-	int (*err_check) (struct mmc_card *, struct mmc_async_req *);
-};
-
-#define HOST_IS_EMMC(host)	(host->unused)
-
 struct mmc_host {
 	struct device		*parent;
 	struct device		class_dev;
@@ -239,28 +212,6 @@ struct mmc_host {
 #define MMC_CAP_MAX_CURRENT_600	(1 << 28)	/* Host max current limit is 600mA */
 #define MMC_CAP_MAX_CURRENT_800	(1 << 29)	/* Host max current limit is 800mA */
 #define MMC_CAP_CMD23		(1 << 30)	/* CMD23 supported. */
-#define MMC_CAP_HW_RESET	(1 << 31)	/* Hardware reset */
-    
-        u32         caps2;      /* More host capabilities */
-#define MMC_CAP2_BOOTPART_NOACC	(1 << 0)	/* Boot partition no access */
-#define MMC_CAP2_CACHE_CTRL	(1 << 1)	/* Allow cache control */
-#define MMC_CAP2_POWEROFF_NOTIFY (1 << 2)	/* Notify poweroff supported */
-#define MMC_CAP2_NO_MULTI_READ	(1 << 3)	/* Multiblock reads don't work */
-#define MMC_CAP2_NO_SLEEP_CMD	(1 << 4)	/* Don't allow sleep command */
-#define MMC_CAP2_HS200_1_8V_SDR	(1 << 5)        /* can support */
-#define MMC_CAP2_HS200_1_2V_SDR	(1 << 6)        /* can support */
-#define MMC_CAP2_HS200		(MMC_CAP2_HS200_1_8V_SDR | \
-                     MMC_CAP2_HS200_1_2V_SDR)
-#define MMC_CAP2_BROKEN_VOLTAGE	(1 << 7)	/* Use the broken voltage */
-#define MMC_CAP2_DETECT_ON_ERR	(1 << 8)	/* On I/O err check card removal */
-#define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
-#define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
-#define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */
-#define MMC_CAP2_PACKED_RD	(1 << 12)	/* Allow packed read */
-#define MMC_CAP2_PACKED_WR	(1 << 13)	/* Allow packed write */
-#define MMC_CAP2_PACKED_CMD	(MMC_CAP2_PACKED_RD | \
-                     MMC_CAP2_PACKED_WR)
-#define MMC_CAP2_NO_PRESCAN_POWERUP (1 << 14)	/* Don't power up before scan */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
@@ -281,7 +232,6 @@ struct mmc_host {
 	unsigned int		max_req_size;	/* maximum number of bytes in one req */
 	unsigned int		max_blk_size;	/* maximum size of one mmc block */
 	unsigned int		max_blk_count;	/* maximum number of blocks in one req */
-	unsigned int		max_discard_to;	/* max. discard timeout in ms */
 
 	/* private data */
 	spinlock_t		lock;		/* lock for claim and bus ops */
@@ -317,12 +267,6 @@ struct mmc_host {
 	const struct mmc_bus_ops *bus_ops;	/* current bus driver */
 	unsigned int		bus_refs;	/* reference counter */
 
-#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
-	unsigned int		re_initialized_flags; //in order to begin the rescan ;  added by xbw@2011-04-07
-	unsigned int		doneflag; //added by xbw at 2011-08-27
-	int			(*sdmmc_host_hw_init)(void *data);
-#endif
-
 	unsigned int		bus_resume_flags;
 #define MMC_BUSRESUME_MANUAL_RESUME	(1 << 0)
 #define MMC_BUSRESUME_NEEDS_RESUME	(1 << 1)
@@ -352,7 +296,6 @@ struct mmc_host {
 		int				num_funcs;
 	} embedded_sdio_data;
 #endif
-	struct mmc_async_req	*areq;		/* active async req */
 
 	unsigned long		private[0] ____cacheline_aligned;
 };
@@ -467,14 +410,5 @@ static inline int mmc_host_cmd23(struct mmc_host *host)
 {
 	return host->caps & MMC_CAP_CMD23;
 }
-
-static inline int mmc_host_uhs(struct mmc_host *host)
-{
-	return host->caps &
-		(MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
-		 MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 |
-		 MMC_CAP_UHS_DDR50);
-}
-
 #endif
 
diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 8209cb599965..8e425ab761f0 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -51,7 +51,6 @@
 #define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
 #define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
 #define MMC_SEND_TUNING_BLOCK    19   /* adtc                    R1  */
-#define MMC_SEND_TUNING_BLOCK_HS200	21	/* adtc R1  */
 
   /* class 3 */
 #define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
@@ -270,40 +269,19 @@ struct _mmc_csd {
 /*
  * EXT_CSD fields
  */
-#define EXT_CSD_FLUSH_CACHE		32      /* W */
-#define EXT_CSD_CACHE_CTRL		33      /* R/W */
-#define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
-#define EXT_CSD_PACKED_FAILURE_INDEX	35	/* RO */
-#define EXT_CSD_PACKED_CMD_STATUS	36	/* RO */
-#define EXT_CSD_EXP_EVENTS_STATUS	54	/* RO, 2 bytes */
-#define EXT_CSD_EXP_EVENTS_CTRL		56	/* R/W, 2 bytes */
-#define EXT_CSD_DATA_SECTOR_SIZE	61	/* R */
-#define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
+
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
-#define EXT_CSD_HPI_MGMT		161	/* R/W */
-#define EXT_CSD_RST_N_FUNCTION		162	/* R/W */
-#define EXT_CSD_BKOPS_EN		163	/* R/W */
-#define EXT_CSD_BKOPS_START		164	/* W */
-#define EXT_CSD_SANITIZE_START		165     /* W */
 #define EXT_CSD_WR_REL_PARAM		166	/* RO */
-#define EXT_CSD_RPMB_MULT		168	/* RO */
-#define EXT_CSD_BOOT_WP			173	/* R/W */
 #define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
 #define EXT_CSD_PART_CONFIG		179	/* R/W */
 #define EXT_CSD_ERASED_MEM_CONT		181	/* RO */
 #define EXT_CSD_BUS_WIDTH		183	/* R/W */
 #define EXT_CSD_HS_TIMING		185	/* R/W */
-#define EXT_CSD_POWER_CLASS		187	/* R/W */
 #define EXT_CSD_REV			192	/* RO */
 #define EXT_CSD_STRUCTURE		194	/* RO */
 #define EXT_CSD_CARD_TYPE		196	/* RO */
-#define EXT_CSD_OUT_OF_INTERRUPT_TIME	198	/* RO */
 #define EXT_CSD_PART_SWITCH_TIME        199     /* RO */
-#define EXT_CSD_PWR_CL_52_195		200	/* RO */
-#define EXT_CSD_PWR_CL_26_195		201	/* RO */
-#define EXT_CSD_PWR_CL_52_360		202	/* RO */
-#define EXT_CSD_PWR_CL_26_360		203	/* RO */
 #define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
 #define EXT_CSD_S_A_TIMEOUT		217	/* RO */
 #define EXT_CSD_REL_WR_SEC_C		222	/* RO */
@@ -315,20 +293,6 @@ struct _mmc_csd {
 #define EXT_CSD_SEC_ERASE_MULT		230	/* RO */
 #define EXT_CSD_SEC_FEATURE_SUPPORT	231	/* RO */
 #define EXT_CSD_TRIM_MULT		232	/* RO */
-#define EXT_CSD_PWR_CL_200_195		236	/* RO */
-#define EXT_CSD_PWR_CL_200_360		237	/* RO */
-#define EXT_CSD_PWR_CL_DDR_52_195	238	/* RO */
-#define EXT_CSD_PWR_CL_DDR_52_360	239	/* RO */
-#define EXT_CSD_BKOPS_STATUS		246	/* RO */
-#define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
-#define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
-#define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
-#define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
-#define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
-#define EXT_CSD_MAX_PACKED_WRITES	500	/* RO */
-#define EXT_CSD_MAX_PACKED_READS	501	/* RO */
-#define EXT_CSD_BKOPS_SUPPORT		502	/* RO */
-#define EXT_CSD_HPI_FEATURES		503	/* RO */
 
 /*
  * EXT_CSD field definitions
@@ -336,18 +300,9 @@ struct _mmc_csd {
 
 #define EXT_CSD_WR_REL_PARAM_EN		(1<<2)
 
-#define EXT_CSD_BOOT_WP_B_PWR_WP_DIS	(0x40)
-#define EXT_CSD_BOOT_WP_B_PERM_WP_DIS	(0x10)
-#define EXT_CSD_BOOT_WP_B_PERM_WP_EN	(0x04)
-#define EXT_CSD_BOOT_WP_B_PWR_WP_EN	(0x01)
-
 #define EXT_CSD_PART_CONFIG_ACC_MASK	(0x7)
 #define EXT_CSD_PART_CONFIG_ACC_BOOT0	(0x1)
 #define EXT_CSD_PART_CONFIG_ACC_BOOT1	(0x2)
-#define EXT_CSD_PART_CONFIG_ACC_RPMB	(0x3)
-#define EXT_CSD_PART_CONFIG_ACC_GP0	(0x4)
-
-#define EXT_CSD_PART_SUPPORT_PART_EN	(0x1)
 
 #define EXT_CSD_CMD_SET_NORMAL		(1<<0)
 #define EXT_CSD_CMD_SET_SECURE		(1<<1)
@@ -355,16 +310,13 @@ struct _mmc_csd {
 
 #define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
 #define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
-#define EXT_CSD_CARD_TYPE_MASK	0x3F	/* Mask out reserved bits */
+#define EXT_CSD_CARD_TYPE_MASK	0xF	/* Mask out reserved bits */
 #define EXT_CSD_CARD_TYPE_DDR_1_8V  (1<<2)   /* Card can run at 52MHz */
 					     /* DDR mode @1.8V or 3V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_1_2V  (1<<3)   /* Card can run at 52MHz */
 					     /* DDR mode @1.2V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_52       (EXT_CSD_CARD_TYPE_DDR_1_8V  \
 					| EXT_CSD_CARD_TYPE_DDR_1_2V)
-#define EXT_CSD_CARD_TYPE_SDR_1_8V	(1<<4)	/* Card can run at 200MHz */
-#define EXT_CSD_CARD_TYPE_SDR_1_2V	(1<<5)	/* Card can run at 200MHz */
-                            /* SDR mode @1.2V I/O */
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
@@ -375,22 +327,6 @@ struct _mmc_csd {
 #define EXT_CSD_SEC_ER_EN	BIT(0)
 #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
 #define EXT_CSD_SEC_GB_CL_EN	BIT(4)
-#define EXT_CSD_SEC_SANITIZE	BIT(6)  /* v4.5 only */
-
-#define EXT_CSD_RST_N_EN_MASK	0x3
-#define EXT_CSD_RST_N_ENABLED	1	/* RST_n is enabled on card */
-
-#define EXT_CSD_NO_POWER_NOTIFICATION	0
-#define EXT_CSD_POWER_ON		1
-#define EXT_CSD_POWER_OFF_SHORT		2
-#define EXT_CSD_POWER_OFF_LONG		3
-
-#define EXT_CSD_PWR_CL_8BIT_MASK	0xF0	/* 8 bit PWR CLS */
-#define EXT_CSD_PWR_CL_4BIT_MASK	0x0F	/* 8 bit PWR CLS */
-#define EXT_CSD_PWR_CL_8BIT_SHIFT	4
-#define EXT_CSD_PWR_CL_4BIT_SHIFT	0
-
-#define EXT_CSD_PACKED_EVENT_EN	BIT(3)
 
 /*
  * MMC_SWITCH access modes
@@ -401,24 +337,5 @@ struct _mmc_csd {
 #define MMC_SWITCH_MODE_CLEAR_BITS	0x02	/* Clear bits which are 1 in value */
 #define MMC_SWITCH_MODE_WRITE_BYTE	0x03	/* Set target to value */
 
-
-/*
-* some limit value of SDMMC about protocol  ; Added by xbw at 2011-03-21
-*/
-#define FOD_FREQ              (300000)    //  in the identify stage, unit: hz,  max is 400Khz,
-                                       //  the least frequency is FREQ_HCLK_MAX/8
-#define SD_FPP_FREQ           (24000000)  //   normal sd freq,  25Mhz
-
-#if defined(CONFIG_ARCH_RK2928)
-//In rk2926 machine,very prone to occur data-timeout-error,the machine reduces the frequency.
-#define SDHC_FPP_FREQ         (39500000)  // SDHC in the highspeed. unit is hz,  max is 50Mhz.
-#else
-#define SDHC_FPP_FREQ         (49500000)  // SDHC in the highspeed. unit is hz,  max is 50Mhz.
-#endif
-#define MMC_FPP_FREQ          (19000000)  // MMC freq, unit is hz,   max is 20MHz
-#define MMCHS_26_FPP_FREQ     (24000000)  //  highspeed mode support 26M  HS-MMC, unit is hz, max is 26Mhz, 
-#define MMCHS_52_FPP_FREQ     (49500000)  //  highspeed support 52M HS-MMC,   unit is hz,   max is 52Mhz,
-
-
 #endif  /* MMC_MMC_PROTOCOL_H */
 
diff --git a/include/linux/mmc/sdio.h b/include/linux/mmc/sdio.h
index 26d116e96bb9..245cdacee544 100644
--- a/include/linux/mmc/sdio.h
+++ b/include/linux/mmc/sdio.h
@@ -38,7 +38,6 @@
  *      [8:0] Byte/block count
  */
 
-#define R4_18V_PRESENT (1<<24)
 #define R4_MEMORY_PRESENT (1 << 27)
 
 /*
@@ -73,15 +72,11 @@
 #define  SDIO_CCCR_REV_1_00	0	/* CCCR/FBR Version 1.00 */
 #define  SDIO_CCCR_REV_1_10	1	/* CCCR/FBR Version 1.10 */
 #define  SDIO_CCCR_REV_1_20	2	/* CCCR/FBR Version 1.20 */
-#define  SDIO_CCCR_REV_3_00	3	/* CCCR/FBR Version 3.00 */
-
 
 #define  SDIO_SDIO_REV_1_00	0	/* SDIO Spec Version 1.00 */
 #define  SDIO_SDIO_REV_1_10	1	/* SDIO Spec Version 1.10 */
 #define  SDIO_SDIO_REV_1_20	2	/* SDIO Spec Version 1.20 */
 #define  SDIO_SDIO_REV_2_00	3	/* SDIO Spec Version 2.00 */
-#define  SDIO_SDIO_REV_3_00	4	/* SDIO Spec Version 3.00 */
-
 
 #define SDIO_CCCR_SD		0x01
 
@@ -99,9 +94,7 @@
 
 #define SDIO_CCCR_IF		0x07	/* bus interface controls */
 
-#define  SDIO_BUS_WIDTH_MASK	0x03	/* data bus width setting */
 #define  SDIO_BUS_WIDTH_1BIT	0x00
-#define  SDIO_BUS_WIDTH_RESERVED 0x01
 #define  SDIO_BUS_WIDTH_4BIT	0x02
 #define  SDIO_BUS_ECSI		0x20	/* Enable continuous SPI interrupt */
 #define  SDIO_BUS_SCSI		0x40	/* Support continuous SPI interrupt */
@@ -139,33 +132,7 @@
 #define SDIO_CCCR_SPEED		0x13
 
 #define  SDIO_SPEED_SHS		0x01	/* Supports High-Speed mode */
-#define  SDIO_SPEED_BSS_SHIFT	1
-#define  SDIO_SPEED_BSS_MASK	(7<<SDIO_SPEED_BSS_SHIFT)
-#define  SDIO_SPEED_SDR12	(0<<SDIO_SPEED_BSS_SHIFT)
-#define  SDIO_SPEED_SDR25	(1<<SDIO_SPEED_BSS_SHIFT)
-#define  SDIO_SPEED_SDR50	(2<<SDIO_SPEED_BSS_SHIFT)
-#define  SDIO_SPEED_SDR104	(3<<SDIO_SPEED_BSS_SHIFT)
-#define  SDIO_SPEED_DDR50	(4<<SDIO_SPEED_BSS_SHIFT)
-#define  SDIO_SPEED_EHS		SDIO_SPEED_SDR25	/* Enable High-Speed */
-
-
-#define  SDIO_CCCR_UHS		0x14
-#define  SDIO_UHS_SDR50		0x01
-#define  SDIO_UHS_SDR104	0x02
-#define  SDIO_UHS_DDR50		0x04
-
-#define  SDIO_CCCR_DRIVE_STRENGTH 0x15
-#define  SDIO_SDTx_MASK		0x07
-#define  SDIO_DRIVE_SDTA	(1<<0)
-#define  SDIO_DRIVE_SDTC	(1<<1)
-#define  SDIO_DRIVE_SDTD	(1<<2)
-#define  SDIO_DRIVE_DTSx_MASK	0x03
-#define  SDIO_DRIVE_DTSx_SHIFT	4
-#define  SDIO_DTSx_SET_TYPE_B	(0 << SDIO_DRIVE_DTSx_SHIFT)
-#define  SDIO_DTSx_SET_TYPE_A	(1 << SDIO_DRIVE_DTSx_SHIFT)
-#define  SDIO_DTSx_SET_TYPE_C	(2 << SDIO_DRIVE_DTSx_SHIFT)
-#define  SDIO_DTSx_SET_TYPE_D	(3 << SDIO_DRIVE_DTSx_SHIFT)
-
+#define  SDIO_SPEED_EHS		0x02	/* Enable High-Speed mode */
 
 /*
  * Function Basic Registers (FBR)
diff --git a/include/linux/module.h b/include/linux/module.h
index e91cc650069a..d9ca2d5dc6d0 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -16,7 +16,6 @@
 #include <linux/kobject.h>
 #include <linux/moduleparam.h>
 #include <linux/tracepoint.h>
-#include <linux/export.h>
 
 #include <linux/percpu.h>
 #include <asm/module.h>
@@ -26,8 +25,21 @@
 /* Not Yet Implemented */
 #define MODULE_SUPPORTED_DEVICE(name)
 
+/* Some toolchains use a `_' prefix for all user symbols. */
+#ifdef CONFIG_SYMBOL_PREFIX
+#define MODULE_SYMBOL_PREFIX CONFIG_SYMBOL_PREFIX
+#else
+#define MODULE_SYMBOL_PREFIX ""
+#endif
+
 #define MODULE_NAME_LEN MAX_PARAM_PREFIX_LEN
 
+struct kernel_symbol
+{
+	unsigned long value;
+	const char *name;
+};
+
 struct modversion_info
 {
 	unsigned long crc;
@@ -84,8 +96,11 @@ void trim_init_extable(struct module *m);
 extern const struct gtype##_id __mod_##gtype##_table		\
   __attribute__ ((unused, alias(__stringify(name))))
 
+extern struct module __this_module;
+#define THIS_MODULE (&__this_module)
 #else  /* !MODULE */
 #define MODULE_GENERIC_TABLE(gtype,name)
+#define THIS_MODULE ((struct module *)0)
 #endif
 
 /* Generic info of form tag = "info" */
@@ -201,6 +216,52 @@ struct module_use {
 	struct module *source, *target;
 };
 
+#ifndef __GENKSYMS__
+#ifdef CONFIG_MODVERSIONS
+/* Mark the CRC weak since genksyms apparently decides not to
+ * generate a checksums for some symbols */
+#define __CRC_SYMBOL(sym, sec)					\
+	extern void *__crc_##sym __attribute__((weak));		\
+	static const unsigned long __kcrctab_##sym		\
+	__used							\
+	__attribute__((section("___kcrctab" sec "+" #sym), unused))	\
+	= (unsigned long) &__crc_##sym;
+#else
+#define __CRC_SYMBOL(sym, sec)
+#endif
+
+/* For every exported symbol, place a struct in the __ksymtab section */
+#define __EXPORT_SYMBOL(sym, sec)				\
+	extern typeof(sym) sym;					\
+	__CRC_SYMBOL(sym, sec)					\
+	static const char __kstrtab_##sym[]			\
+	__attribute__((section("__ksymtab_strings"), aligned(1))) \
+	= MODULE_SYMBOL_PREFIX #sym;                    	\
+	static const struct kernel_symbol __ksymtab_##sym	\
+	__used							\
+	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\
+	= { (unsigned long)&sym, __kstrtab_##sym }
+
+#define EXPORT_SYMBOL(sym)					\
+	__EXPORT_SYMBOL(sym, "")
+
+#define EXPORT_SYMBOL_GPL(sym)					\
+	__EXPORT_SYMBOL(sym, "_gpl")
+
+#define EXPORT_SYMBOL_GPL_FUTURE(sym)				\
+	__EXPORT_SYMBOL(sym, "_gpl_future")
+
+
+#ifdef CONFIG_UNUSED_SYMBOLS
+#define EXPORT_UNUSED_SYMBOL(sym) __EXPORT_SYMBOL(sym, "_unused")
+#define EXPORT_UNUSED_SYMBOL_GPL(sym) __EXPORT_SYMBOL(sym, "_unused_gpl")
+#else
+#define EXPORT_UNUSED_SYMBOL(sym)
+#define EXPORT_UNUSED_SYMBOL_GPL(sym)
+#endif
+
+#endif
+
 enum module_state
 {
 	MODULE_STATE_LIVE,
@@ -521,6 +582,11 @@ extern void module_update_tracepoints(void);
 extern int module_get_iter_tracepoints(struct tracepoint_iter *iter);
 
 #else /* !CONFIG_MODULES... */
+#define EXPORT_SYMBOL(sym)
+#define EXPORT_SYMBOL_GPL(sym)
+#define EXPORT_SYMBOL_GPL_FUTURE(sym)
+#define EXPORT_UNUSED_SYMBOL(sym)
+#define EXPORT_UNUSED_SYMBOL_GPL(sym)
 
 /* Given an address, look for it in the exception tables. */
 static inline const struct exception_table_entry *
diff --git a/include/linux/mtd/blktrans.h b/include/linux/mtd/blktrans.h
index b311f20f19a9..1bbd9f289245 100644
--- a/include/linux/mtd/blktrans.h
+++ b/include/linux/mtd/blktrans.h
@@ -58,9 +58,9 @@ struct mtd_blktrans_ops {
 
 	/* Access functions */
 	int (*readsect)(struct mtd_blktrans_dev *dev,
-		    unsigned long block,unsigned long nsect, char *buffer);
+		    unsigned long block, char *buffer);
 	int (*writesect)(struct mtd_blktrans_dev *dev,
-		     unsigned long block,unsigned long nsect, char *buffer);
+		     unsigned long block, char *buffer);
 	int (*discard)(struct mtd_blktrans_dev *dev,
 		       unsigned long block, unsigned nr_blocks);
 	void (*background)(struct mtd_blktrans_dev *dev);
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index f111406850d2..c2b9ac4fbc4a 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -48,10 +48,6 @@ extern int nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 /* unlocks specified locked blockes */
 extern int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 
-#ifdef CONFIG_MTD_NAND_RK29
-#define RK29_RESERVE_BLOCK_NUM    5
-#endif
-
 /* The maximum number of NAND chips in an array */
 #define NAND_MAX_CHIPS		8
 
diff --git a/include/linux/nls.h b/include/linux/nls.h
index 5dc635f8d79e..d47beef08dfd 100644
--- a/include/linux/nls.h
+++ b/include/linux/nls.h
@@ -43,7 +43,7 @@ enum utf16_endian {
 	UTF16_BIG_ENDIAN
 };
 
-/* nls_base.c */
+/* nls.c */
 extern int register_nls(struct nls_table *);
 extern int unregister_nls(struct nls_table *);
 extern struct nls_table *load_nls(char *);
@@ -52,8 +52,7 @@ extern struct nls_table *load_nls_default(void);
 
 extern int utf8_to_utf32(const u8 *s, int len, unicode_t *pu);
 extern int utf32_to_utf8(unicode_t u, u8 *s, int maxlen);
-extern int utf8s_to_utf16s(const u8 *s, int len,
-		enum utf16_endian endian, wchar_t *pwcs, int maxlen);
+extern int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs);
 extern int utf16s_to_utf8s(const wchar_t *pwcs, int len,
 		enum utf16_endian endian, u8 *s, int maxlen);
 
diff --git a/include/linux/power/smb347-charger.h b/include/linux/power/smb347-charger.h
deleted file mode 100644
index af0117992760..000000000000
--- a/include/linux/power/smb347-charger.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef SMB347_CHARGER_H
-#define SMB347_CHARGER_H
-
-/*
- * @chg_en_pin: charge enable pin (smb347's c4 pin)
- * @chg_ctl_pin: charge control pin (smb347's d2 pin)
- * @chg_stat_pin: charge stat pin (smb347's f5 pin)
- * @chg_susp_pin: charge usb suspend pin (smb347's d3 pin)
- * @max_current: dc and hc input current limit 
- *               can set 300ma/500ma/700ma/900ma/1200ma
- *               or 1500ma/1800ma/2000ma/2200ma/2500ma
- * @otg_power_form_smb: if otg 5v power form smb347 set 1 otherwise set 0
- */
-struct smb347_info{
-	unsigned int chg_en_pin;        
-	unsigned int chg_ctl_pin;       
-	unsigned int chg_stat_pin;	
-	unsigned int chg_susp_pin;
-        unsigned int max_current;       
-        bool    otg_power_form_smb;
-};
-
-extern int smb347_is_chg_ok(void);
-extern int smb347_is_charging(void);
-
-#endif
diff --git a/include/linux/regulator/consumer.h b/include/linux/regulator/consumer.h
index 1951ca891551..9e87c1cb7270 100644
--- a/include/linux/regulator/consumer.h
+++ b/include/linux/regulator/consumer.h
@@ -153,9 +153,6 @@ int regulator_list_voltage(struct regulator *regulator, unsigned selector);
 int regulator_is_supported_voltage(struct regulator *regulator,
 				   int min_uV, int max_uV);
 int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV);
-#ifdef CONFIG_PLAT_RK
-int regulator_set_suspend_voltage(struct regulator *regulator, int uV);
-#endif
 int regulator_set_voltage_time(struct regulator *regulator,
 			       int old_uV, int new_uV);
 int regulator_get_voltage(struct regulator *regulator);
@@ -246,13 +243,6 @@ static inline int regulator_set_voltage(struct regulator *regulator,
 	return 0;
 }
 
-#ifdef CONFIG_PLAT_RK
-static inline int regulator_set_suspend_voltage(struct regulator *regulator, int uV)
-{
-	return 0;
-}
-#endif
-
 static inline int regulator_get_voltage(struct regulator *regulator)
 {
 	return 0;
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index ad16cd614217..0d239897b2f4 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -181,10 +181,6 @@
 /* BCM63xx family SoCs */
 #define PORT_BCM63XX	89
 
-#define PORT_RK2818	90
-
-#define PORT_RK29	90
-
 /* Aeroflex Gaisler GRLIB APBUART */
 #define PORT_APBUART    90
 
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index fca9e9b494b6..bb4f5fbbbd8e 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -444,7 +444,6 @@ struct spi_transfer {
 	u8		bits_per_word;
 	u16		delay_usecs;
 	u32		speed_hz;
-	void			*state;
 
 	struct list_head transfer_list;
 };
@@ -619,21 +618,6 @@ spi_read(struct spi_device *spi, void *buf, size_t len)
 	return spi_sync(spi, &m);
 }
 
-static inline int
-spi_write_and_read(struct spi_device *spi, const void *tx_buf, void *rx_buf, size_t len)
-{
-	struct spi_transfer	t = {
-			.tx_buf		= tx_buf,
-			.rx_buf		= rx_buf,
-			.len		= len,
-		};
-	struct spi_message	m;
-
-	spi_message_init(&m);
-	spi_message_add_tail(&t, &m);
-	return spi_sync(spi, &m);
-}
-
 /* this copies txbuf and rxbuf data; for small transfers only! */
 extern int spi_write_then_read(struct spi_device *spi,
 		const void *txbuf, unsigned n_tx,
diff --git a/include/linux/sync.h b/include/linux/sync.h
index 5f493638148d..4f1993871467 100644
--- a/include/linux/sync.h
+++ b/include/linux/sync.h
@@ -16,10 +16,8 @@
 #include <linux/types.h>
 #ifdef __KERNEL__
 
-#include <linux/kref.h>
 #include <linux/ktime.h>
 #include <linux/list.h>
-#include <linux/seq_file.h>
 #include <linux/spinlock.h>
 #include <linux/wait.h>
 
@@ -41,14 +39,14 @@ struct sync_fence;
  *			 -1 if a will signabl before b
  * @free_pt:		called before sync_pt is freed
  * @release_obj:	called before sync_timeline is freed
- * @print_obj:		deprecated
- * @print_pt:		deprecated
+ * @print_obj:		print aditional debug information about sync_timeline.
+ *			  should not print a newline
+ * @print_pt:		print aditional debug information about sync_pt.
+ *			  should not print a newline
  * @fill_driver_data:	write implmentation specific driver data to data.
  *			  should return an error if there is not enough room
  *			  as specified by size.  This information is returned
  *			  to userspace by SYNC_IOC_FENCE_INFO.
- * @timeline_value_str: fill str with the value of the sync_timeline's counter
- * @pt_value_str:	fill str with the value of the sync_pt
  */
 struct sync_timeline_ops {
 	const char *driver_name;
@@ -68,27 +66,19 @@ struct sync_timeline_ops {
 	/* optional */
 	void (*release_obj)(struct sync_timeline *sync_timeline);
 
-	/* deprecated */
+	/* optional */
 	void (*print_obj)(struct seq_file *s,
 			  struct sync_timeline *sync_timeline);
 
-	/* deprecated */
+	/* optional */
 	void (*print_pt)(struct seq_file *s, struct sync_pt *sync_pt);
 
 	/* optional */
 	int (*fill_driver_data)(struct sync_pt *syncpt, void *data, int size);
-
-	/* optional */
-	void (*timeline_value_str)(struct sync_timeline *timeline, char *str,
-				   int size);
-
-	/* optional */
-	void (*pt_value_str)(struct sync_pt *pt, char *str, int size);
 };
 
 /**
  * struct sync_timeline - sync object
- * @kref:		reference count on fence.
  * @ops:		ops that define the implementaiton of the sync_timeline
  * @name:		name of the sync_timeline. Useful for debugging
  * @destoryed:		set when sync_timeline is destroyed
@@ -99,7 +89,6 @@ struct sync_timeline_ops {
  * @sync_timeline_list:	membership in global sync_timeline_list
  */
 struct sync_timeline {
-	struct kref		kref;
 	const struct sync_timeline_ops	*ops;
 	char			name[32];
 
@@ -120,7 +109,6 @@ struct sync_timeline {
  * @parent:		sync_timeline to which this sync_pt belongs
  * @child_list:		membership in sync_timeline.child_list_head
  * @active_list:	membership in sync_timeline.active_list_head
- * @signaled_list:	membership in temorary signaled_list on stack
  * @fence:		sync_fence to which the sync_pt belongs
  * @pt_list:		membership in sync_fence.pt_list_head
  * @status:		1: signaled, 0:active, <0: error
@@ -132,7 +120,6 @@ struct sync_pt {
 	struct list_head	child_list;
 
 	struct list_head	active_list;
-	struct list_head	signaled_list;
 
 	struct sync_fence	*fence;
 	struct list_head	pt_list;
@@ -146,7 +133,6 @@ struct sync_pt {
 /**
  * struct sync_fence - sync fence
  * @file:		file representing this fence
- * @kref:		referenace count on fence.
  * @name:		name of sync_fence.  Useful for debugging
  * @pt_list_head:	list of sync_pts in ths fence.  immutable once fence
  *			  is created
@@ -159,7 +145,6 @@ struct sync_pt {
  */
 struct sync_fence {
 	struct file		*file;
-	struct kref		kref;
 	char			name[32];
 
 	/* this list is immutable once the fence is created */
@@ -174,10 +159,6 @@ struct sync_fence {
 	struct list_head	sync_fence_list;
 };
 
-struct sync_fence_waiter;
-typedef void (*sync_callback_t)(struct sync_fence *fence,
-				struct sync_fence_waiter *waiter);
-
 /**
  * struct sync_fence_waiter - metadata for asynchronous waiter on a fence
  * @waiter_list:	membership in sync_fence.waiter_list_head
@@ -187,15 +168,10 @@ typedef void (*sync_callback_t)(struct sync_fence *fence,
 struct sync_fence_waiter {
 	struct list_head	waiter_list;
 
-	sync_callback_t		callback;
+	void (*callback)(struct sync_fence *fence, void *data);
+	void *callback_data;
 };
 
-static inline void sync_fence_waiter_init(struct sync_fence_waiter *waiter,
-					  sync_callback_t callback)
-{
-	waiter->callback = callback;
-}
-
 /*
  * API for sync_timeline implementers
  */
@@ -308,37 +284,24 @@ void sync_fence_install(struct sync_fence *fence, int fd);
 /**
  * sync_fence_wait_async() - registers and async wait on the fence
  * @fence:		fence to wait on
- * @waiter:		waiter callback struck
+ * @callback:		callback
+ * @callback_data	data to pass to the callback
  *
  * Returns 1 if @fence has already signaled.
  *
- * Registers a callback to be called when @fence signals or has an error.
- * @waiter should be initialized with sync_fence_waiter_init().
+ * Registers a callback to be called when @fence signals or has an error
  */
 int sync_fence_wait_async(struct sync_fence *fence,
-			  struct sync_fence_waiter *waiter);
-
-/**
- * sync_fence_cancel_async() - cancels an async wait
- * @fence:		fence to wait on
- * @waiter:		waiter callback struck
- *
- * returns 0 if waiter was removed from fence's async waiter list.
- * returns -ENOENT if waiter was not found on fence's async waiter list.
- *
- * Cancels a previously registered async wait.  Will fail gracefully if
- * @waiter was never registered or if @fence has already signaled @waiter.
- */
-int sync_fence_cancel_async(struct sync_fence *fence,
-			    struct sync_fence_waiter *waiter);
+			  void (*callback)(struct sync_fence *, void *data),
+			  void *callback_data);
 
 /**
  * sync_fence_wait() - wait on fence
  * @fence:	fence to wait on
  * @tiemout:	timeout in ms
  *
- * Wait for @fence to be signaled or have an error.  Waits indefinitely
- * if @timeout < 0
+ * Wait for @fence to be signaled or have an error.  Waits indefintly
+ * if @timeout = 0
  */
 int sync_fence_wait(struct sync_fence *fence, long timeout);
 
@@ -397,9 +360,9 @@ struct sync_fence_info_data {
 /**
  * DOC: SYNC_IOC_WAIT - wait for a fence to signal
  *
- * pass timeout in milliseconds.  Waits indefinitely timeout < 0.
+ * pass timeout in milliseconds.
  */
-#define SYNC_IOC_WAIT		_IOW(SYNC_IOC_MAGIC, 0, __s32)
+#define SYNC_IOC_WAIT		_IOW(SYNC_IOC_MAGIC, 0, __u32)
 
 /**
  * DOC: SYNC_IOC_MERGE - merge two fences
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 7a6677fe3dcb..d87f44f5b04e 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -97,10 +97,6 @@ struct otg_transceiver {
 	int	(*set_power)(struct otg_transceiver *otg,
 				unsigned mA);
 
-	/* set/reset USB charger in High impedence mode on VBUS */
-	int	(*set_hz_mode)(struct otg_transceiver *otg,
-				bool enabled);
-
 	/* effective for A-peripheral, ignored for B devices */
 	int	(*set_vbus)(struct otg_transceiver *otg,
 				bool enabled);
@@ -196,16 +192,6 @@ otg_start_hnp(struct otg_transceiver *otg)
 	return otg->start_hnp(otg);
 }
 
-/* Context: can sleep */
-static inline int
-otg_set_hz_mode(struct otg_transceiver *otg, bool enabled)
-{
-	if (otg->set_hz_mode)
-		return otg->set_hz_mode(otg, enabled);
-
-	return -EINVAL;
-}
-
 /* Context: can sleep */
 static inline int
 otg_set_vbus(struct otg_transceiver *otg, bool enabled)
diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index 11d198b4f372..76f439647c4b 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -229,22 +229,4 @@ extern void usbnet_set_msglevel(struct net_device *, u32);
 extern void usbnet_get_drvinfo(struct net_device *, struct ethtool_drvinfo *);
 extern int usbnet_nway_reset(struct net_device *net);
 
-
-#ifdef DEBUG
-#define devdbg(usbnet, fmt, arg...) \
-        printk(KERN_DEBUG "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
-#else
-#define devdbg(usbnet, fmt, arg...) \
-        ({ if (0) printk(KERN_DEBUG "%s: " fmt "\n" , (usbnet)->net->name , \
-                ## arg); 0; })
-#endif
-
-#define deverr(usbnet, fmt, arg...) \
-        printk(KERN_ERR "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
-#define devwarn(usbnet, fmt, arg...) \
-        printk(KERN_WARNING "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
-
-#define devinfo(usbnet, fmt, arg...) \
-        printk(KERN_INFO "%s: " fmt "\n" , (usbnet)->net->name , ## arg); 
-
 #endif /* __LINUX_USB_USBNET_H */
diff --git a/include/linux/videodev2.h b/include/linux/videodev2.h
index 9ca45cc7d591..eeeda13b4d53 100644
--- a/include/linux/videodev2.h
+++ b/include/linux/videodev2.h
@@ -1011,7 +1011,6 @@ struct v4l2_ext_control {
 		__s64 value64;
 		char *string;
 	};
-	__s32 rect[4];
 } __attribute__ ((packed));
 
 struct v4l2_ext_controls {
@@ -1396,24 +1395,6 @@ enum  v4l2_exposure_auto_type {
 #define V4L2_CID_IRIS_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+17)
 #define V4L2_CID_IRIS_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+18)
 
-/* ddl@rock-chips.com : Add ioctrl -  V4L2_CID_SCENE for camera scene control */
-#define V4L2_CID_CAMERA_CLASS_BASE_ROCK		(V4L2_CID_CAMERA_CLASS_BASE + 30)
-#define V4L2_CID_SCENE				(V4L2_CID_CAMERA_CLASS_BASE_ROCK+1)
-#define V4L2_CID_EFFECT				(V4L2_CID_CAMERA_CLASS_BASE_ROCK+2)
-#define V4L2_CID_FLASH				(V4L2_CID_CAMERA_CLASS_BASE_ROCK+3)
-#define V4L2_CID_FOCUS_CONTINUOUS		(V4L2_CID_CAMERA_CLASS_BASE_ROCK+4)
-#define V4L2_CID_FOCUSZONE       (V4L2_CID_CAMERA_CLASS_BASE_ROCK+5)
-#define V4L2_CID_FACEDETECT (V4L2_CID_CAMERA_CLASS_BASE_ROCK+6)
-#define V4L2_CID_HDR        (V4L2_CID_CAMERA_CLASS_BASE_ROCK+7) 
-#define V4L2_CID_ISO				(V4L2_CID_CAMERA_CLASS_BASE_ROCK + 8)
-#define V4L2_CID_ANTIBANDING		(V4L2_CID_CAMERA_CLASS_BASE_ROCK + 9)
-#define V4L2_CID_WHITEBALANCE_LOCK	(V4L2_CID_CAMERA_CLASS_BASE_ROCK + 10)
-#define V4L2_CID_EXPOSURE_LOCK		(V4L2_CID_CAMERA_CLASS_BASE_ROCK + 11)
-#define V4L2_CID_METERING_AREAS		(V4L2_CID_CAMERA_CLASS_BASE_ROCK + 12)
-#define V4L2_CID_WDR				(V4L2_CID_CAMERA_CLASS_BASE_ROCK + 13)
-#define V4L2_CID_EDGE				(V4L2_CID_CAMERA_CLASS_BASE_ROCK + 14)
-#define V4L2_CID_JPEG_EXIF			(V4L2_CID_CAMERA_CLASS_BASE_ROCK + 15)
-
 /* FM Modulator class control IDs */
 #define V4L2_CID_FM_TX_CLASS_BASE		(V4L2_CTRL_CLASS_FM_TX | 0x900)
 #define V4L2_CID_FM_TX_CLASS			(V4L2_CTRL_CLASS_FM_TX | 1)
diff --git a/include/linux/wait.h b/include/linux/wait.h
index bea7ad5f0471..3efc9f3f43a0 100644
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@ -233,8 +233,6 @@ do {									\
 		if (!ret)						\
 			break;						\
 	}								\
-	if (!ret && (condition))					\
-		ret = 1;						\
 	finish_wait(&wq, &__wait);					\
 } while (0)
 
@@ -251,9 +249,8 @@ do {									\
  * wake_up() has to be called after changing any variable that could
  * change the result of the wait condition.
  *
- * The function returns 0 if the @timeout elapsed, or the remaining
- * jiffies (at least 1) if the @condition evaluated to %true before
- * the @timeout elapsed.
+ * The function returns 0 if the @timeout elapsed, and the remaining
+ * jiffies if the condition evaluated to true before the timeout elapsed.
  */
 #define wait_event_timeout(wq, condition, timeout)			\
 ({									\
@@ -321,8 +318,6 @@ do {									\
 		ret = -ERESTARTSYS;					\
 		break;							\
 	}								\
-	if (!ret && (condition))					\
-		ret = 1;						\
 	finish_wait(&wq, &__wait);					\
 } while (0)
 
@@ -339,10 +334,9 @@ do {									\
  * wake_up() has to be called after changing any variable that could
  * change the result of the wait condition.
  *
- * Returns:
- * 0 if the @timeout elapsed, -%ERESTARTSYS if it was interrupted by
- * a signal, or the remaining jiffies (at least 1) if the @condition
- * evaluated to %true before the @timeout elapsed.
+ * The function returns 0 if the @timeout elapsed, -ERESTARTSYS if it
+ * was interrupted by a signal, and the remaining jiffies otherwise
+ * if the condition evaluated to true before the timeout elapsed.
  */
 #define wait_event_interruptible_timeout(wq, condition, timeout)	\
 ({									\
diff --git a/include/linux/wakelock.h b/include/linux/wakelock.h
index 492aa649629a..a096d24ada1d 100755
--- a/include/linux/wakelock.h
+++ b/include/linux/wakelock.h
@@ -72,7 +72,6 @@ int wake_lock_active(struct wake_lock *lock);
  * number of jiffies until all active wake locks time out.
  */
 long has_wake_lock(int type);
-void print_active_wake_locks(int type);
 
 #else
 
@@ -85,7 +84,6 @@ static inline void wake_unlock(struct wake_lock *lock) {}
 
 static inline int wake_lock_active(struct wake_lock *lock) { return 0; }
 static inline long has_wake_lock(int type) { return 0; }
-static inline void print_active_wake_locks(int type) {}
 
 #endif
 
diff --git a/include/media/soc_camera.h b/include/media/soc_camera.h
index ec7386d5a7cb..238bd334fd83 100644
--- a/include/media/soc_camera.h
+++ b/include/media/soc_camera.h
@@ -68,7 +68,6 @@ struct soc_camera_host_ops {
 	void (*remove)(struct soc_camera_device *);
 	int (*suspend)(struct soc_camera_device *, pm_message_t);
 	int (*resume)(struct soc_camera_device *);
-    int (*enum_frameinervals)(struct soc_camera_device *, struct v4l2_frmivalenum *);/* ddl@rock-chips.com :Add ioctrl - VIDIOC_ENUM_FRAMEINTERVALS for soc-camera */
 	/*
 	 * .get_formats() is called for each client device format, but
 	 * .put_formats() is only called once. Further, if any of the calls to
@@ -103,9 +102,6 @@ struct soc_camera_host_ops {
 	unsigned int (*poll)(struct file *, poll_table *);
 	const struct v4l2_queryctrl *controls;
 	int num_controls;
-
-    int (*s_stream)(struct soc_camera_device *, int enable);	/* ddl@rock-chips.com : Add stream control for host */
-
 };
 
 #define SOCAM_SENSOR_INVERT_PCLK	(1 << 0)
@@ -132,7 +128,7 @@ struct soc_camera_link {
 	struct i2c_board_info *board_info;
 	const char *module_name;
 	void *priv;
-    void *priv_usr;                        /* ddl@rock-chips.com: add priv_usr */
+
 	/* Optional regulators that have to be managed on power on/off events */
 	struct regulator_bulk_data *regulators;
 	int num_regulators;
@@ -146,7 +142,6 @@ struct soc_camera_link {
 	/* Optional callbacks to power on or off and reset the sensor */
 	int (*power)(struct device *, int);
 	int (*reset)(struct device *);
-	int (*powerdown)(struct device *, int);		/* ddl@rock-chisp.com : support sensor powerdown  */
 	/*
 	 * some platforms may support different data widths than the sensors
 	 * native ones due to different data line routing. Let the board code
@@ -217,11 +212,8 @@ struct soc_camera_ops {
 	unsigned long (*query_bus_param)(struct soc_camera_device *);
 	int (*set_bus_param)(struct soc_camera_device *, unsigned long);
 	int (*enum_input)(struct soc_camera_device *, struct v4l2_input *);
-
 	const struct v4l2_queryctrl *controls;
-	struct v4l2_querymenu *menus;                /* ddl@rock-chips.com : Add ioctrl -VIDIOC_QUERYMENU */
 	int num_controls;
-	int num_menus;      /* ddl@rock-chips.com : Add ioctrl -VIDIOC_QUERYMENU */
 };
 
 #define SOCAM_SENSE_PCLK_CHANGED	(1 << 0)
@@ -279,10 +271,6 @@ static inline struct v4l2_queryctrl const *soc_camera_find_qctrl(
 #define SOCAM_DATA_ACTIVE_HIGH		(1 << 14)
 #define SOCAM_DATA_ACTIVE_LOW		(1 << 15)
 
-#define SOCAM_MCLK_24MHZ   (1<<29)                                      /* ddl@rock-chips.com : add  */
-#define SOCAM_MCLK_27MHZ   (1<<30)
-#define SOCAM_MCLK_48MHZ   (1<<31)
-
 #define SOCAM_DATAWIDTH_MASK (SOCAM_DATAWIDTH_4 | SOCAM_DATAWIDTH_8 | \
 			      SOCAM_DATAWIDTH_9 | SOCAM_DATAWIDTH_10 | \
 			      SOCAM_DATAWIDTH_15 | SOCAM_DATAWIDTH_16)
diff --git a/include/media/v4l2-chip-ident.h b/include/media/v4l2-chip-ident.h
index 46766b61a804..b3edb67a8311 100644
--- a/include/media/v4l2-chip-ident.h
+++ b/include/media/v4l2-chip-ident.h
@@ -72,31 +72,14 @@ enum {
 	V4L2_IDENT_OV9650 = 254,
 	V4L2_IDENT_OV9655 = 255,
 	V4L2_IDENT_SOI968 = 256,
-	V4L2_IDENT_OV2655 = 257,                            /* ddl@rock-chips.com : ov2655 support */
-	V4L2_IDENT_OV2659 = 258,
-	V4L2_IDENT_OV3640 = 259,
-	V4L2_IDENT_OV5640 = 260,
-	V4L2_IDENT_OV5642 = 261,
-	V4L2_IDENT_OV7675 = 262,
-	V4L2_IDENT_OV2640 = 263,
-	V4L2_IDENT_OV9640 = 264,
-	V4L2_IDENT_OV6650 = 265,
-	V4L2_IDENT_OV9740 = 266,
-	V4L2_IDENT_OV7690 = 267,
-	V4L2_IDENT_OV3660 = 268,
+	V4L2_IDENT_OV9640 = 257,
+	V4L2_IDENT_OV6650 = 258,
+	V4L2_IDENT_OV2640 = 259,
+	V4L2_IDENT_OV9740 = 260,
 
 	/* module saa7146: reserved range 300-309 */
 	V4L2_IDENT_SAA7146 = 300,
 
-	/* Samsung sensors: reserved range 310-319 */
-	V4L2_IDENT_S5K66A = 310,							/* ddl@rock-chips.com : s5k66a support */
-	V4L2_IDENT_S5K5CA = 311,							/* ddl@rock-chips.com : s5k5ca support */
-
-	V4L2_IDENT_MTK9335ISP = 320,							/* ddl@rock-chips.com : MTK9335ISP support */
-	V4L2_IDENT_ICATCH7002_MI1040 = 321,
-	V4L2_IDENT_ICATCH7002_OV5693 =322,
-	V4L2_IDENT_ICATCH7002_OV8825 = 323, //zyt
-	V4L2_IDENT_ICATCH7002_OV2720 = 324, //zyt
 	/* Conexant MPEG encoder/decoders: reserved range 400-420 */
 	V4L2_IDENT_CX23418_843 = 403, /* Integrated A/V Decoder on the '418 */
 	V4L2_IDENT_CX23415 = 415,
@@ -307,7 +290,6 @@ enum {
 	V4L2_IDENT_MT9M001C12STM	= 45005,
 	V4L2_IDENT_MT9M111		= 45007,
 	V4L2_IDENT_MT9M112		= 45008,
-	V4L2_IDENT_MT9D112		= 45009,		/* ddl@rock-chips.com : MT9D112 support */
 	V4L2_IDENT_MT9V022IX7ATC	= 45010, /* No way to detect "normal" I77ATx */
 	V4L2_IDENT_MT9V022IX7ATM	= 45015, /* and "lead free" IA7ATx chips */
 	V4L2_IDENT_MT9T031		= 45020,
@@ -316,9 +298,6 @@ enum {
 	V4L2_IDENT_MT9V111		= 45031,
 	V4L2_IDENT_MT9V112		= 45032,
 
-	V4L2_IDENT_MT9P111		= 45033,     /* ddl@rock-chips.com : MT9P111 support */
-	V4L2_IDENT_MT9D113      = 45034,     /* ddl@rock-chips.com : MT9D113 support */
-
 	/* HV7131R CMOS sensor: just ident 46000 */
 	V4L2_IDENT_HV7131R		= 46000,
 
@@ -342,39 +321,6 @@ enum {
 	/* module upd64083: just ident 64083 */
 	V4L2_IDENT_UPD64083 = 64083,
 
-
-    V4L2_IDENT_NT99250 = 64100,    /* ddl@rock-chips.com : nt99250 support */
-    V4L2_IDENT_SID130B = 64101,      /* ddl@rock-chips.com : sid130B support */
-
-    V4L2_IDENT_GT2005 = 64110,       /* ddl@rock-chips.com : GT2005 support */
-    V4L2_IDENT_GC0307 = 64111,      /* ddl@rock-chips.com : GC0308 support */
-    V4L2_IDENT_GC0308 = 64112,      /* ddl@rock-chips.com : GC0308 support */
-    V4L2_IDENT_GC0309 = 64113,      /* ddl@rock-chips.com : GC0309 support */
-    V4L2_IDENT_GC2015 = 64114,      /* ddl@rock-chips.com : gc2015 support */
-    V4L2_IDENT_GC0329 = 64115,      /* ddl@rock-chips.com : GC0329 support */
-    V4L2_IDENT_GC2035= 64116,      /* ddl@rock-chips.com : GC0329 support */
-    V4L2_IDENT_GC0328 = 64117,
-    
-    V4L2_IDENT_SP0838 = 64120,      /* ddl@rock-chips.com : SP0838 support */
-    V4L2_IDENT_SP2518 = 64121,      /* ddl@rock-chips.com : SP2518 support */	      
-    V4L2_IDENT_SP0718 = 64122,      /* ddl@rock-chips.com : SP0718 support */
-
-    V4L2_IDENT_HI253 = 64130,      /* ddl@rock-chips.com : hi253 support */
-    V4L2_IDENT_HI704 = 64131,      /* ddl@rock-chips.com : hi704 support */    
-    
-    V4L2_IDENT_SIV120B = 64140,      /* ddl@rock-chips.com : siv120b support */
-    V4L2_IDENT_SIV121D= 64141,      /* ddl@rock-chips.com : sid130B support */
-
-
-    V4L2_IDENT_HM2057 = 64150,
-    V4L2_IDENT_HM5065 = 64151,
-
-	V4L2_IDENT_NT99160 = 64161,    /* oyyf@rock-chips.com : nt99160 support */
-	V4L2_IDENT_NT99340 = 64162,    /* oyyf@rock-chips.com : nt99340 support */
-	V4L2_IDENT_NT99252 = 64163,    /* oyyf@rock-chips.com : nt99252 support */
-	V4L2_IDENT_NT99240 = 64164,    /* oyyf@rock-chips.com : nt99252 support */
-
-
 	/* Don't just add new IDs at the end: KEEP THIS LIST ORDERED BY ID! */
 };
 
diff --git a/include/media/videobuf-core.h b/include/media/videobuf-core.h
index b02caa9088c2..90ed895e217d 100644
--- a/include/media/videobuf-core.h
+++ b/include/media/videobuf-core.h
@@ -62,13 +62,6 @@ enum videobuf_state {
 	VIDEOBUF_ERROR      = 5,
 	VIDEOBUF_IDLE       = 6,
 };
-#ifdef CONFIG_VIDEO_RK29XX_VOUT
-struct rk29_vaddr {
-	dma_addr_t 				base[2];
-	size_t 					len[2];
-};
-
-#endif
 
 struct videobuf_buffer {
 	unsigned int            i;
@@ -107,11 +100,7 @@ struct videobuf_buffer {
 
 	/* Private pointer to allow specific methods to store their data */
 	int			privsize;
-#ifdef CONFIG_VIDEO_RK29XX_VOUT
-	struct rk29_vaddr		vaddr;
-#endif
 	void                    *priv;
-	unsigned int rk_code;    /* ddl@rock-chips.com: this filed must copy to struct v4l2_buffer.reserved */
 };
 
 struct videobuf_queue_ops {
diff --git a/include/sound/asound.h b/include/sound/asound.h
index 8541613ad071..5d6074faa279 100644
--- a/include/sound/asound.h
+++ b/include/sound/asound.h
@@ -487,7 +487,6 @@ enum {
 #define SNDRV_PCM_IOCTL_READN_FRAMES	_IOR('A', 0x53, struct snd_xfern)
 #define SNDRV_PCM_IOCTL_LINK		_IOW('A', 0x60, int)
 #define SNDRV_PCM_IOCTL_UNLINK		_IO('A', 0x61)
-#define SNDRV_PCM_IOCTL_VOL		_IOW('A', 0x62, int)
 
 /*****************************************************************************
  *                                                                           *
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 40f4dd276189..e1bad1130616 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -107,8 +107,6 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_TRIGGER_PAUSE_RELEASE	4
 #define SNDRV_PCM_TRIGGER_SUSPEND	5
 #define SNDRV_PCM_TRIGGER_RESUME	6
-//add by qiuen for volume
-#define SNDRV_PCM_TRIGGER_VOLUME        7
 
 #define SNDRV_PCM_POS_XRUN		((snd_pcm_uframes_t)-1)
 
diff --git a/include/sound/soc-dai.h b/include/sound/soc-dai.h
index ed73df1d4b17..1bafe95dcf41 100644
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -172,10 +172,6 @@ struct snd_soc_dai_ops {
 		struct snd_soc_dai *);
 	int (*trigger)(struct snd_pcm_substream *, int,
 		struct snd_soc_dai *);
-
-	/* set volume,add by qiuen*/
-	void (*set_volume)(unsigned char mode,unsigned char volume);
-
 	/*
 	 * For hardware based FIFO caused delay reporting.
 	 * Optional.
diff --git a/include/sound/soc.h b/include/sound/soc.h
index d52d36fce6b6..3a4bd3a3c68d 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -258,11 +258,6 @@ enum snd_soc_compress_type {
 	SND_SOC_RBTREE_COMPRESSION
 };
 
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
-int snd_soc_incall_status(int read_or_write, int status);
-#endif	
-
-
 int snd_soc_codec_set_sysclk(struct snd_soc_codec *codec, int clk_id,
 			     unsigned int freq, int dir);
 int snd_soc_codec_set_pll(struct snd_soc_codec *codec, int pll_id, int source,
@@ -501,8 +496,6 @@ struct snd_soc_ops {
 	int (*hw_free)(struct snd_pcm_substream *);
 	int (*prepare)(struct snd_pcm_substream *);
 	int (*trigger)(struct snd_pcm_substream *, int);
-    /* set volume,add by qiuen*/
-	void (*set_volume)(unsigned char mode,unsigned char volume);
 };
 
 /* SoC cache ops */
diff --git a/init/Kconfig b/init/Kconfig
index df8ea4f32c45..4fe9168149fc 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -132,7 +132,6 @@ config HAVE_KERNEL_LZO
 
 choice
 	prompt "Kernel compression mode"
-	default KERNEL_LZO if ARCH_RK29
 	default KERNEL_GZIP
 	depends on HAVE_KERNEL_GZIP || HAVE_KERNEL_BZIP2 || HAVE_KERNEL_LZMA || HAVE_KERNEL_XZ || HAVE_KERNEL_LZO
 	help
diff --git a/init/initramfs.c b/init/initramfs.c
index d41e2d8bb340..2531811d42cb 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -461,8 +461,6 @@ static char * __init unpack_to_rootfs(char *buf, unsigned len)
 			error("junk in compressed archive");
 		if (state != Reset)
 			error("junk in compressed archive");
-		else
-			break;
 		this_header = saved_offset + my_inptr;
 		buf += my_inptr;
 		len -= my_inptr;
diff --git a/kernel/Makefile b/kernel/Makefile
index e4fd98bb7459..2d64cfcc8b42 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -101,7 +101,6 @@ obj-$(CONFIG_RING_BUFFER) += trace/
 obj-$(CONFIG_TRACEPOINTS) += trace/
 obj-$(CONFIG_SMP) += sched_cpupri.o
 obj-$(CONFIG_IRQ_WORK) += irq_work.o
-obj-$(CONFIG_CPU_PM) += cpu_pm.o
 
 obj-$(CONFIG_PERF_EVENTS) += events/
 
diff --git a/kernel/cpu_pm.c b/kernel/cpu_pm.c
deleted file mode 100644
index 249152e15308..000000000000
--- a/kernel/cpu_pm.c
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * Copyright (C) 2011 Google, Inc.
- *
- * Author:
- *	Colin Cross <ccross@android.com>
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/cpu_pm.h>
-#include <linux/module.h>
-#include <linux/notifier.h>
-#include <linux/spinlock.h>
-#include <linux/syscore_ops.h>
-
-static DEFINE_RWLOCK(cpu_pm_notifier_lock);
-static RAW_NOTIFIER_HEAD(cpu_pm_notifier_chain);
-
-static int cpu_pm_notify(enum cpu_pm_event event, int nr_to_call, int *nr_calls)
-{
-	int ret;
-
-	ret = __raw_notifier_call_chain(&cpu_pm_notifier_chain, event, NULL,
-		nr_to_call, nr_calls);
-
-	return notifier_to_errno(ret);
-}
-
-/**
- * cpu_pm_register_notifier - register a driver with cpu_pm
- * @nb: notifier block to register
- *
- * Add a driver to a list of drivers that are notified about
- * CPU and CPU cluster low power entry and exit.
- *
- * This function may sleep, and has the same return conditions as
- * raw_notifier_chain_register.
- */
-int cpu_pm_register_notifier(struct notifier_block *nb)
-{
-	unsigned long flags;
-	int ret;
-
-	write_lock_irqsave(&cpu_pm_notifier_lock, flags);
-	ret = raw_notifier_chain_register(&cpu_pm_notifier_chain, nb);
-	write_unlock_irqrestore(&cpu_pm_notifier_lock, flags);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cpu_pm_register_notifier);
-
-/**
- * cpu_pm_unregister_notifier - unregister a driver with cpu_pm
- * @nb: notifier block to be unregistered
- *
- * Remove a driver from the CPU PM notifier list.
- *
- * This function may sleep, and has the same return conditions as
- * raw_notifier_chain_unregister.
- */
-int cpu_pm_unregister_notifier(struct notifier_block *nb)
-{
-	unsigned long flags;
-	int ret;
-
-	write_lock_irqsave(&cpu_pm_notifier_lock, flags);
-	ret = raw_notifier_chain_unregister(&cpu_pm_notifier_chain, nb);
-	write_unlock_irqrestore(&cpu_pm_notifier_lock, flags);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cpu_pm_unregister_notifier);
-
-/**
- * cpm_pm_enter - CPU low power entry notifier
- *
- * Notifies listeners that a single CPU is entering a low power state that may
- * cause some blocks in the same power domain as the cpu to reset.
- *
- * Must be called on the affected CPU with interrupts disabled.  Platform is
- * responsible for ensuring that cpu_pm_enter is not called twice on the same
- * CPU before cpu_pm_exit is called. Notified drivers can include VFP
- * co-processor, interrupt controller and it's PM extensions, local CPU
- * timers context save/restore which shouldn't be interrupted. Hence it
- * must be called with interrupts disabled.
- *
- * Return conditions are same as __raw_notifier_call_chain.
- */
-int cpu_pm_enter(void)
-{
-	int nr_calls;
-	int ret = 0;
-
-	read_lock(&cpu_pm_notifier_lock);
-	ret = cpu_pm_notify(CPU_PM_ENTER, -1, &nr_calls);
-	if (ret)
-		/*
-		 * Inform listeners (nr_calls - 1) about failure of CPU PM
-		 * PM entry who are notified earlier to prepare for it.
-		 */
-		cpu_pm_notify(CPU_PM_ENTER_FAILED, nr_calls - 1, NULL);
-	read_unlock(&cpu_pm_notifier_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cpu_pm_enter);
-
-/**
- * cpm_pm_exit - CPU low power exit notifier
- *
- * Notifies listeners that a single CPU is exiting a low power state that may
- * have caused some blocks in the same power domain as the cpu to reset.
- *
- * Notified drivers can include VFP co-processor, interrupt controller
- * and it's PM extensions, local CPU timers context save/restore which
- * shouldn't be interrupted. Hence it must be called with interrupts disabled.
- *
- * Return conditions are same as __raw_notifier_call_chain.
- */
-int cpu_pm_exit(void)
-{
-	int ret;
-
-	read_lock(&cpu_pm_notifier_lock);
-	ret = cpu_pm_notify(CPU_PM_EXIT, -1, NULL);
-	read_unlock(&cpu_pm_notifier_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cpu_pm_exit);
-
-/**
- * cpm_cluster_pm_enter - CPU cluster low power entry notifier
- *
- * Notifies listeners that all cpus in a power domain are entering a low power
- * state that may cause some blocks in the same power domain to reset.
- *
- * Must be called after cpu_pm_enter has been called on all cpus in the power
- * domain, and before cpu_pm_exit has been called on any cpu in the power
- * domain. Notified drivers can include VFP co-processor, interrupt controller
- * and it's PM extensions, local CPU timers context save/restore which
- * shouldn't be interrupted. Hence it must be called with interrupts disabled.
- *
- * Must be called with interrupts disabled.
- *
- * Return conditions are same as __raw_notifier_call_chain.
- */
-int cpu_cluster_pm_enter(void)
-{
-	int nr_calls;
-	int ret = 0;
-
-	read_lock(&cpu_pm_notifier_lock);
-	ret = cpu_pm_notify(CPU_CLUSTER_PM_ENTER, -1, &nr_calls);
-	if (ret)
-		/*
-		 * Inform listeners (nr_calls - 1) about failure of CPU cluster
-		 * PM entry who are notified earlier to prepare for it.
-		 */
-		cpu_pm_notify(CPU_CLUSTER_PM_ENTER_FAILED, nr_calls - 1, NULL);
-	read_unlock(&cpu_pm_notifier_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cpu_cluster_pm_enter);
-
-/**
- * cpm_cluster_pm_exit - CPU cluster low power exit notifier
- *
- * Notifies listeners that all cpus in a power domain are exiting form a
- * low power state that may have caused some blocks in the same power domain
- * to reset.
- *
- * Must be called after cpu_pm_exit has been called on all cpus in the power
- * domain, and before cpu_pm_exit has been called on any cpu in the power
- * domain. Notified drivers can include VFP co-processor, interrupt controller
- * and it's PM extensions, local CPU timers context save/restore which
- * shouldn't be interrupted. Hence it must be called with interrupts disabled.
- *
- * Return conditions are same as __raw_notifier_call_chain.
- */
-int cpu_cluster_pm_exit(void)
-{
-	int ret;
-
-	read_lock(&cpu_pm_notifier_lock);
-	ret = cpu_pm_notify(CPU_CLUSTER_PM_EXIT, -1, NULL);
-	read_unlock(&cpu_pm_notifier_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cpu_cluster_pm_exit);
-
-#ifdef CONFIG_PM
-static int cpu_pm_suspend(void)
-{
-	int ret;
-
-	ret = cpu_pm_enter();
-	if (ret)
-		return ret;
-
-	ret = cpu_cluster_pm_enter();
-	return ret;
-}
-
-static void cpu_pm_resume(void)
-{
-	cpu_cluster_pm_exit();
-	cpu_pm_exit();
-}
-
-static struct syscore_ops cpu_pm_syscore_ops = {
-	.suspend = cpu_pm_suspend,
-	.resume = cpu_pm_resume,
-};
-
-static int cpu_pm_init(void)
-{
-	register_syscore_ops(&cpu_pm_syscore_ops);
-	return 0;
-}
-core_initcall(cpu_pm_init);
-#endif
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index 923aeca01fa7..990965ec5d0b 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -18,10 +18,6 @@
 
 #include "internals.h"
 
-#ifdef CONFIG_FIQ_DEBUGGER
-#include <mach/irqs.h>
-#endif
-
 /**
  *	irq_set_chip - set the irq chip for an irq
  *	@irq:	irq number
@@ -413,10 +409,7 @@ handle_fasteoi_irq(unsigned int irq, struct irq_desc *desc)
 	 */
 	if (unlikely(!desc->action || irqd_irq_disabled(&desc->irq_data))) {
 		desc->istate |= IRQS_PENDING;
-#ifdef CONFIG_FIQ_DEBUGGER
-		if(irq != (CONFIG_RK_DEBUG_UART + IRQ_UART0))
-#endif
-			mask_irq(desc);
+		mask_irq(desc);
 		goto out;
 	}
 
diff --git a/kernel/module.c b/kernel/module.c
index 0b428cea2dfb..a8bd2151b54c 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -1982,10 +1982,6 @@ static void layout_sections(struct module *mod, struct load_info *info)
 
 static void set_license(struct module *mod, const char *license)
 {
-#ifdef CONFIG_PLAT_RK
-	return;
-#endif
-
 	if (!license)
 		license = "unspecified";
 
@@ -2831,13 +2827,6 @@ static struct module *load_module(void __user *umod,
 	list_add_rcu(&mod->list, &modules);
 	mutex_unlock(&module_mutex);
 
-#ifdef CONFIG_RK_CONFIG
-{
-	extern int module_parse_kernel_cmdline(const char *name, const struct kernel_param *params, unsigned num);
-	module_parse_kernel_cmdline(mod->name, mod->kp, mod->num_kp);
-}
-#endif
-
 	/* Module is ready to execute: parsing args may do that. */
 	err = parse_args(mod->name, mod->args, mod->kp, mod->num_kp, NULL);
 	if (err < 0)
@@ -3409,7 +3398,6 @@ EXPORT_SYMBOL_GPL(__module_text_address);
 /* Don't grab lock, we're oopsing. */
 void print_modules(void)
 {
-#ifndef CONFIG_PLAT_RK
 	struct module *mod;
 	char buf[8];
 
@@ -3422,7 +3410,6 @@ void print_modules(void)
 	if (last_unloaded_module[0])
 		printk(" [last unloaded: %s]", last_unloaded_module);
 	printk("\n");
-#endif
 }
 
 #ifdef CONFIG_MODVERSIONS
diff --git a/kernel/params.c b/kernel/params.c
index c29d12381213..ed72e1330862 100644
--- a/kernel/params.c
+++ b/kernel/params.c
@@ -217,48 +217,6 @@ int parse_args(const char *name,
 	return 0;
 }
 
-#ifdef CONFIG_RK_CONFIG
-static int ignore_unknown(char *param, char *val)
-{
-	return 0;
-}
-
-int module_parse_kernel_cmdline(const char *name, const struct kernel_param *params, unsigned num)
-{
-	int ret;
-	unsigned i;
-	size_t name_len = strlen(name);
-	struct kernel_param new_params[num];
-	char args[strlen(saved_command_line) + 1];
-
-	if (!num)
-		return 0;
-
-	strcpy(args, saved_command_line);
-	memcpy(new_params, params, sizeof(struct kernel_param) * num);
-
-	for (i = 0; i < num; i++)
-		new_params[i].name = NULL;
-	for (i = 0; i < num; i++) {
-		char *new_name = kmalloc(strlen(params[i].name) + name_len + 2, GFP_KERNEL);
-		if (!new_name) {
-			ret = -ENOMEM;
-			goto out;
-		}
-		sprintf(new_name, "%s.%s", name, params[i].name);
-		new_params[i].name = new_name;
-	}
-
-	ret = parse_args(name, args, new_params, num, ignore_unknown);
-
-out:
-	for (i = 0; i < num; i++)
-		if (new_params[i].name)
-			kfree(new_params[i].name);
-	return ret;
-}
-#endif
-
 /* Lazy bastard, eh? */
 #define STANDARD_PARAM_DEF(name, type, format, tmptype, strtolfn)      	\
 	int param_set_##name(const char *val, const struct kernel_param *kp) \
diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig
index f16f2ff20881..b90fb99fe45f 100644
--- a/kernel/power/Kconfig
+++ b/kernel/power/Kconfig
@@ -295,18 +295,9 @@ config PM_RUNTIME_CLK
 	def_bool y
 	depends on PM_RUNTIME && HAVE_CLK
 
-config CPU_PM
-	bool
-	depends on SUSPEND || CPU_IDLE
-
 config SUSPEND_TIME
 	bool "Log time spent in suspend"
 	---help---
 	  Prints the time spent in suspend in the kernel log, and
 	  keeps statistics on the time spent in suspend in
 	  /sys/kernel/debug/suspend_time
-
-config SUSPEND_SYNC_WORKQUEUE
-	bool "Suspend sync in workqueue"
-	depends on WAKELOCK
-	default y
diff --git a/kernel/power/earlysuspend.c b/kernel/power/earlysuspend.c
index 11d476062245..b15f02eba45c 100644
--- a/kernel/power/earlysuspend.c
+++ b/kernel/power/earlysuspend.c
@@ -77,11 +77,6 @@ static void early_suspend(struct work_struct *work)
 	unsigned long irqflags;
 	int abort = 0;
 
-#ifdef CONFIG_PLAT_RK
-	if (system_state != SYSTEM_RUNNING)
-		return;
-#endif
-
 	mutex_lock(&early_suspend_lock);
 	spin_lock_irqsave(&state_lock, irqflags);
 	if (state == SUSPEND_REQUESTED)
@@ -108,14 +103,10 @@ static void early_suspend(struct work_struct *work)
 	}
 	mutex_unlock(&early_suspend_lock);
 
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-	suspend_sys_sync_queue();
-#else
 	if (debug_mask & DEBUG_SUSPEND)
 		pr_info("early_suspend: sync\n");
 
 	sys_sync();
-#endif
 abort:
 	spin_lock_irqsave(&state_lock, irqflags);
 	if (state == SUSPEND_REQUESTED_AND_SUSPENDED)
@@ -129,11 +120,6 @@ static void late_resume(struct work_struct *work)
 	unsigned long irqflags;
 	int abort = 0;
 
-#ifdef CONFIG_PLAT_RK
-	if (system_state != SYSTEM_RUNNING)
-		return;
-#endif
-
 	mutex_lock(&early_suspend_lock);
 	spin_lock_irqsave(&state_lock, irqflags);
 	if (state == SUSPENDED)
@@ -168,11 +154,6 @@ void request_suspend_state(suspend_state_t new_state)
 	unsigned long irqflags;
 	int old_sleep;
 
-#ifdef CONFIG_PLAT_RK
-	if (system_state != SYSTEM_RUNNING)
-		return;
-#endif
-
 	spin_lock_irqsave(&state_lock, irqflags);
 	old_sleep = state & SUSPEND_REQUESTED;
 	if (debug_mask & DEBUG_USER_STATE) {
diff --git a/kernel/power/power.h b/kernel/power/power.h
index ae075550a967..b6b9006480ff 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -253,11 +253,6 @@ extern struct wake_lock main_wake_lock;
 extern suspend_state_t requested_suspend_state;
 #endif
 
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-extern void suspend_sys_sync_queue(void);
-extern int suspend_sys_sync_wait(void);
-#endif
-
 #ifdef CONFIG_USER_WAKELOCK
 ssize_t wake_lock_show(struct kobject *kobj, struct kobj_attribute *attr,
 			char *buf);
diff --git a/kernel/power/process.c b/kernel/power/process.c
index 134eb87d0a5d..31338cdeafc4 100644
--- a/kernel/power/process.c
+++ b/kernel/power/process.c
@@ -17,7 +17,6 @@
 #include <linux/delay.h>
 #include <linux/workqueue.h>
 #include <linux/wakelock.h>
-#include "power.h"
 
 /* 
  * Timeout for stopping processes
@@ -118,7 +117,6 @@ static int try_to_freeze_tasks(bool sig_only)
 			printk("\n");
 			printk(KERN_ERR "Freezing of %s aborted\n",
 					sig_only ? "user space " : "tasks ");
-			print_active_wake_locks(WAKE_LOCK_SUSPEND);
 		}
 		else {
 			printk("\n");
@@ -160,12 +158,6 @@ int freeze_processes(void)
 		goto Exit;
 	printk("done.\n");
 
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-	error = suspend_sys_sync_wait();
-	if (error)
-		goto Exit;
-#endif
-
 	printk("Freezing remaining freezable tasks ... ");
 	error = try_to_freeze_tasks(false);
 	if (error)
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 0be2387569d0..f5adb6e8d0f1 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -279,13 +279,9 @@ int enter_state(suspend_state_t state)
 	if (!mutex_trylock(&pm_mutex))
 		return -EBUSY;
 
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-	suspend_sys_sync_queue();
-#else
 	printk(KERN_INFO "PM: Syncing filesystems ... ");
 	sys_sync();
 	printk("done.\n");
-#endif
 
 	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state]);
 	error = suspend_prepare();
diff --git a/kernel/power/wakelock.c b/kernel/power/wakelock.c
index a79defae30b6..81e1b7c65ca1 100644
--- a/kernel/power/wakelock.c
+++ b/kernel/power/wakelock.c
@@ -44,12 +44,6 @@ static DEFINE_SPINLOCK(list_lock);
 static LIST_HEAD(inactive_locks);
 static struct list_head active_wake_locks[WAKE_LOCK_TYPE_COUNT];
 static int current_event_num;
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-static int suspend_sys_sync_count;
-static DEFINE_SPINLOCK(suspend_sys_sync_lock);
-static struct workqueue_struct *suspend_sys_sync_work_queue;
-static DECLARE_COMPLETION(suspend_sys_sync_comp);
-#endif
 struct workqueue_struct *suspend_work_queue;
 struct wake_lock main_wake_lock;
 suspend_state_t requested_suspend_state = PM_SUSPEND_MEM;
@@ -214,33 +208,28 @@ static void expire_wake_lock(struct wake_lock *lock)
 }
 
 /* Caller must acquire the list_lock spinlock */
-static void print_active_locks_locked(int type)
+static void print_active_locks(int type)
 {
 	struct wake_lock *lock;
+	bool print_expired = true;
 
 	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
 	list_for_each_entry(lock, &active_wake_locks[type], link) {
 		if (lock->flags & WAKE_LOCK_AUTO_EXPIRE) {
 			long timeout = lock->expires - jiffies;
-			if (timeout <= 0)
+			if (timeout > 0)
+				pr_info("active wake lock %s, time left %ld\n",
+					lock->name, timeout);
+			else if (print_expired)
 				pr_info("wake lock %s, expired\n", lock->name);
-			else
-				pr_info("active wake lock %s, time left %ld.%03lu\n",
-					lock->name, timeout / HZ,
-					(timeout % HZ) * MSEC_PER_SEC / HZ);
-		} else
+		} else {
 			pr_info("active wake lock %s\n", lock->name);
+			if (!(debug_mask & DEBUG_EXPIRE))
+				print_expired = false;
+		}
 	}
 }
 
-void print_active_wake_locks(int type)
-{
-	unsigned long irqflags;
-	spin_lock_irqsave(&list_lock, irqflags);
-	print_active_locks_locked(type);
-	spin_unlock_irqrestore(&list_lock, irqflags);
-}
-
 static long has_wake_lock_locked(int type)
 {
 	struct wake_lock *lock, *n;
@@ -267,77 +256,11 @@ long has_wake_lock(int type)
 	spin_lock_irqsave(&list_lock, irqflags);
 	ret = has_wake_lock_locked(type);
 	if (ret && (debug_mask & DEBUG_WAKEUP) && type == WAKE_LOCK_SUSPEND)
-		print_active_locks_locked(type);
+		print_active_locks(type);
 	spin_unlock_irqrestore(&list_lock, irqflags);
 	return ret;
 }
 
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-static void suspend_sys_sync(struct work_struct *work)
-{
-	if (debug_mask & DEBUG_SUSPEND)
-		pr_info("PM: Syncing filesystems...\n");
-
-	sys_sync();
-
-	if (debug_mask & DEBUG_SUSPEND)
-		pr_info("sync done.\n");
-
-	spin_lock(&suspend_sys_sync_lock);
-	suspend_sys_sync_count--;
-	spin_unlock(&suspend_sys_sync_lock);
-}
-static DECLARE_WORK(suspend_sys_sync_work, suspend_sys_sync);
-
-void suspend_sys_sync_queue(void)
-{
-	int ret;
-
-	spin_lock(&suspend_sys_sync_lock);
-	ret = queue_work(suspend_sys_sync_work_queue, &suspend_sys_sync_work);
-	if (ret)
-		suspend_sys_sync_count++;
-	spin_unlock(&suspend_sys_sync_lock);
-}
-
-static bool suspend_sys_sync_abort;
-static void suspend_sys_sync_handler(unsigned long);
-static DEFINE_TIMER(suspend_sys_sync_timer, suspend_sys_sync_handler, 0, 0);
-/* value should be less then half of input event wake lock timeout value
- * which is currently set to 5*HZ (see drivers/input/evdev.c)
- */
-#define SUSPEND_SYS_SYNC_TIMEOUT (HZ/4)
-static void suspend_sys_sync_handler(unsigned long arg)
-{
-	if (suspend_sys_sync_count == 0) {
-		complete(&suspend_sys_sync_comp);
-	} else if (has_wake_lock(WAKE_LOCK_SUSPEND)) {
-		suspend_sys_sync_abort = true;
-		complete(&suspend_sys_sync_comp);
-	} else {
-		mod_timer(&suspend_sys_sync_timer, jiffies +
-				SUSPEND_SYS_SYNC_TIMEOUT);
-	}
-}
-
-int suspend_sys_sync_wait(void)
-{
-	suspend_sys_sync_abort = false;
-
-	if (suspend_sys_sync_count != 0) {
-		mod_timer(&suspend_sys_sync_timer, jiffies +
-				SUSPEND_SYS_SYNC_TIMEOUT);
-		wait_for_completion(&suspend_sys_sync_comp);
-	}
-	if (suspend_sys_sync_abort) {
-		pr_info("suspend aborted....while waiting for sys_sync\n");
-		return -EAGAIN;
-	}
-
-	return 0;
-}
-#endif /* CONFIG_SUSPEND_SYNC_WORKQUEUE */
-
 static void suspend_backoff(void)
 {
 	pr_info("suspend: too many immediate wakeups, back off\n");
@@ -358,11 +281,7 @@ static void suspend(struct work_struct *work)
 	}
 
 	entry_event_num = current_event_num;
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-	suspend_sys_sync_queue();
-#else
 	sys_sync();
-#endif
 	if (debug_mask & DEBUG_SUSPEND)
 		pr_info("suspend: enter suspend\n");
 	getnstimeofday(&ts_entry);
@@ -405,7 +324,7 @@ static void expire_wake_locks(unsigned long data)
 		pr_info("expire_wake_locks: start\n");
 	spin_lock_irqsave(&list_lock, irqflags);
 	if (debug_mask & DEBUG_SUSPEND)
-		print_active_locks_locked(WAKE_LOCK_SUSPEND);
+		print_active_locks(WAKE_LOCK_SUSPEND);
 	has_lock = has_wake_lock_locked(WAKE_LOCK_SUSPEND);
 	if (debug_mask & DEBUG_EXPIRE)
 		pr_info("expire_wake_locks: done, has_lock %ld\n", has_lock);
@@ -445,7 +364,6 @@ void wake_lock_init(struct wake_lock *lock, int type, const char *name)
 	if (name)
 		lock->name = name;
 	BUG_ON(!lock->name);
-	BUG_ON(lock->flags & WAKE_LOCK_INITIALIZED);
 
 	if (debug_mask & DEBUG_WAKE_LOCK)
 		pr_info("wake_lock_init name=%s\n", lock->name);
@@ -612,7 +530,7 @@ void wake_unlock(struct wake_lock *lock)
 		}
 		if (lock == &main_wake_lock) {
 			if (debug_mask & DEBUG_SUSPEND)
-				print_active_locks_locked(WAKE_LOCK_SUSPEND);
+				print_active_locks(WAKE_LOCK_SUSPEND);
 #ifdef CONFIG_WAKELOCK_STAT
 			update_sleep_wait_stats_locked(0);
 #endif
@@ -670,16 +588,6 @@ static int __init wakelocks_init(void)
 		goto err_platform_driver_register;
 	}
 
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-	INIT_COMPLETION(suspend_sys_sync_comp);
-	suspend_sys_sync_work_queue =
-		create_singlethread_workqueue("suspend_sys_sync");
-	if (suspend_sys_sync_work_queue == NULL) {
-		ret = -ENOMEM;
-		goto err_suspend_sys_sync_work_queue;
-	}
-#endif
-
 	suspend_work_queue = create_singlethread_workqueue("suspend");
 	if (suspend_work_queue == NULL) {
 		ret = -ENOMEM;
@@ -693,10 +601,6 @@ static int __init wakelocks_init(void)
 	return 0;
 
 err_suspend_work_queue:
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-	destroy_workqueue(suspend_sys_sync_work_queue);
-err_suspend_sys_sync_work_queue:
-#endif
 	platform_driver_unregister(&power_driver);
 err_platform_driver_register:
 	platform_device_unregister(&power_device);
@@ -716,9 +620,6 @@ static void  __exit wakelocks_exit(void)
 	remove_proc_entry("wakelocks", NULL);
 #endif
 	destroy_workqueue(suspend_work_queue);
-#ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
-	destroy_workqueue(suspend_sys_sync_work_queue);
-#endif
 	platform_driver_unregister(&power_driver);
 	platform_device_unregister(&power_device);
 	wake_lock_destroy(&suspend_backoff_lock);
diff --git a/kernel/printk.c b/kernel/printk.c
index 02f1ec6b34f3..a1d702c1313b 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -1034,28 +1034,6 @@ asmlinkage int vprintk(const char *fmt, va_list args)
 EXPORT_SYMBOL(printk);
 EXPORT_SYMBOL(vprintk);
 
-#ifdef CONFIG_PLAT_RK
-void pm_emit_log_char(char c)
-{
-	emit_log_char(c);
-}
-#endif
-
-#ifdef CONFIG_RK29_LAST_LOG
-void __init switch_log_buf(char *new_log_buf, int size)
-{
-	unsigned long flags;
-
-	if (!new_log_buf || log_buf_len > size)
-		return;
-
-	spin_lock_irqsave(&logbuf_lock, flags);
-	memcpy(new_log_buf, log_buf, min(log_buf_len, size));
-	log_buf = new_log_buf;
-	log_buf_len = size;
-	spin_unlock_irqrestore(&logbuf_lock, flags);
-}
-#endif /* CONFIG_RK29_LAST_LOG */
 #else
 
 static void call_console_drivers(unsigned start, unsigned end)
diff --git a/kernel/sched.c b/kernel/sched.c
index c4743ee8bcbc..e788b663b797 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -6477,7 +6477,7 @@ static int __cpuinit sched_cpu_active(struct notifier_block *nfb,
 				      unsigned long action, void *hcpu)
 {
 	switch (action & ~CPU_TASKS_FROZEN) {
-	case CPU_STARTING:
+	case CPU_ONLINE:
 	case CPU_DOWN_FAILED:
 		set_cpu_active((long)hcpu, true);
 		return NOTIFY_OK;
diff --git a/kernel/sys.c b/kernel/sys.c
index 01f195e96073..84e353b1820d 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -53,18 +53,6 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unistd.h>
-/***************
-*	 DEBUG
-****************/
-#define RESTART_DEBUG
-#ifdef RESTART_DEBUG
-#define restart_dbg(format, arg...) \
-	printk("RESTART_DEBUG : " format "\n" , ## arg)
-#else
-#define restart_dbg(format, arg...) do {} while (0)
-#endif
-
-
 
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
@@ -345,11 +333,6 @@ void kernel_restart_prepare(char *cmd)
  */
 void kernel_restart(char *cmd)
 {
-	/*
-	*  debug trace
-	*/
-	restart_dbg("%s->%d->cmd=%s",__FUNCTION__,__LINE__,cmd);
-	
 	kernel_restart_prepare(cmd);
 	disable_nonboot_cpus();
 	if (!cmd)
@@ -440,11 +423,6 @@ SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 	mutex_lock(&reboot_mutex);
 	switch (cmd) {
 	case LINUX_REBOOT_CMD_RESTART:
-		/*
-		*  debug trace
-		*/
-		restart_dbg("%s->%d->cmd=%x",__FUNCTION__,__LINE__,cmd);
-		
 		kernel_restart(NULL);
 		break;
 
@@ -462,11 +440,6 @@ SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 		panic("cannot halt");
 
 	case LINUX_REBOOT_CMD_POWER_OFF:
-		/*
-		*  debug trace
-		*/
-		restart_dbg("%s->%d->cmd=%x",__FUNCTION__,__LINE__,cmd);
-		
 		kernel_power_off();
 		do_exit(0);
 		break;
@@ -477,11 +450,7 @@ SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
 			break;
 		}
 		buffer[sizeof(buffer) - 1] = '\0';
-		/*
-		*  debug trace
-		*/
-		restart_dbg("%s->%d->cmd=%x args=%s",__FUNCTION__,__LINE__,cmd,buffer);
-		
+
 		kernel_restart(buffer);
 		break;
 
diff --git a/mm/bounce.c b/mm/bounce.c
index 434fb4f0c5e4..1481de68184b 100644
--- a/mm/bounce.c
+++ b/mm/bounce.c
@@ -14,7 +14,6 @@
 #include <linux/init.h>
 #include <linux/hash.h>
 #include <linux/highmem.h>
-#include <linux/bootmem.h>
 #include <asm/tlbflush.h>
 
 #include <trace/events/block.h>
@@ -27,10 +26,12 @@ static mempool_t *page_pool, *isa_page_pool;
 #ifdef CONFIG_HIGHMEM
 static __init int init_emergency_pool(void)
 {
-#ifndef CONFIG_MEMORY_HOTPLUG
-	if (max_pfn <= max_low_pfn)
+	struct sysinfo i;
+	si_meminfo(&i);
+	si_swapinfo(&i);
+
+	if (!i.totalhigh)
 		return 0;
-#endif
 
 	page_pool = mempool_create_page_pool(POOL_SIZE, 0);
 	BUG_ON(!page_pool);
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 1dabd7640446..b1b7b3d06845 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -1535,7 +1535,6 @@ int hci_register_dev(struct hci_dev *hdev)
 
 	hci_register_sysfs(hdev);
 
-#if !defined(CONFIG_MT6620) && !defined(CONFIG_MT5931_MT6622)
 	hdev->rfkill = rfkill_alloc(hdev->name, &hdev->dev,
 				RFKILL_TYPE_BLUETOOTH, &hci_rfkill_ops, hdev);
 	if (hdev->rfkill) {
@@ -1548,7 +1547,6 @@ int hci_register_dev(struct hci_dev *hdev)
 	set_bit(HCI_AUTO_OFF, &hdev->flags);
 	set_bit(HCI_SETUP, &hdev->flags);
 	queue_work(hdev->workqueue, &hdev->power_on);
-#endif
 
 	hci_notify(hdev, HCI_DEV_REG);
 
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index c266b31557c2..7f4e391e4922 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -83,7 +83,7 @@ int sysctl_tcp_ecn __read_mostly = 2;
 EXPORT_SYMBOL(sysctl_tcp_ecn);
 int sysctl_tcp_dsack __read_mostly = 1;
 int sysctl_tcp_app_win __read_mostly = 31;
-int sysctl_tcp_adv_win_scale __read_mostly = 2;
+int sysctl_tcp_adv_win_scale __read_mostly = 1;
 EXPORT_SYMBOL(sysctl_tcp_adv_win_scale);
 
 /* rfc5961 challenge ack rate limiting */
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index d64b6baa4715..1e36fb3318cb 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -931,18 +931,6 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 				   "Failed to add default virtual iface\n");
 	}
 
-	//add by lintao@rock-chips.com : register p2p0 IFTYPE_STA
-	#ifdef CONFIG_ESP8089 
-	if (local->hw.wiphy->interface_modes &(BIT(NL80211_IFTYPE_P2P_GO) | BIT(NL80211_IFTYPE_P2P_CLIENT))) {
-	    result = ieee80211_if_add(local, "p2p%d", NULL,
-		              NL80211_IFTYPE_STATION, NULL);
-		if (result)
-		    wiphy_warn(local->hw.wiphy,
-		           "Failed to add default virtual iface\n");
-	}
-	
-	#endif
-
 	rtnl_unlock();
 
 	local->network_latency_notifier.notifier_call =
diff --git a/net/netfilter/xt_qtaguid.c b/net/netfilter/xt_qtaguid.c
index 25f2cee64de5..495b62ea0b69 100644
--- a/net/netfilter/xt_qtaguid.c
+++ b/net/netfilter/xt_qtaguid.c
@@ -1108,18 +1108,13 @@ static void iface_stat_create(struct net_device *net_dev,
 	spin_lock_bh(&iface_stat_list_lock);
 	entry = get_iface_entry(ifname);
 	if (entry != NULL) {
-		bool activate = !ipv4_is_loopback(ipaddr);
 		IF_DEBUG("qtaguid: iface_stat: create(%s): entry=%p\n",
 			 ifname, entry);
 		iface_check_stats_reset_and_adjust(net_dev, entry);
-		_iface_stat_set_active(entry, net_dev, activate);
+		_iface_stat_set_active(entry, net_dev, true);
 		IF_DEBUG("qtaguid: %s(%s): "
 			 "tracking now %d on ip=%pI4\n", __func__,
-			 entry->ifname, activate, &ipaddr);
-		goto done_unlock_put;
-	} else if (ipv4_is_loopback(ipaddr)) {
-		IF_DEBUG("qtaguid: iface_stat: create(%s): "
-			 "ignore loopback dev. ip=%pI4\n", ifname, &ipaddr);
+			 entry->ifname, true, &ipaddr);
 		goto done_unlock_put;
 	}
 
@@ -1170,19 +1165,13 @@ static void iface_stat_create_ipv6(struct net_device *net_dev,
 	spin_lock_bh(&iface_stat_list_lock);
 	entry = get_iface_entry(ifname);
 	if (entry != NULL) {
-		bool activate = !(addr_type & IPV6_ADDR_LOOPBACK);
 		IF_DEBUG("qtaguid: %s(%s): entry=%p\n", __func__,
 			 ifname, entry);
 		iface_check_stats_reset_and_adjust(net_dev, entry);
-		_iface_stat_set_active(entry, net_dev, activate);
+		_iface_stat_set_active(entry, net_dev, true);
 		IF_DEBUG("qtaguid: %s(%s): "
 			 "tracking now %d on ip=%pI6c\n", __func__,
-			 entry->ifname, activate, &ifa->addr);
-		goto done_unlock_put;
-	} else if (addr_type & IPV6_ADDR_LOOPBACK) {
-		IF_DEBUG("qtaguid: %s(%s): "
-			 "ignore loopback dev. ip=%pI6c\n", __func__,
-			 ifname, &ifa->addr);
+			 entry->ifname, true, &ifa->addr);
 		goto done_unlock_put;
 	}
 
diff --git a/net/rfkill/Kconfig b/net/rfkill/Kconfig
index 0576cb0a86e8..8e12c8a2b82b 100644
--- a/net/rfkill/Kconfig
+++ b/net/rfkill/Kconfig
@@ -47,15 +47,3 @@ config RFKILL_GPIO
 	  If you say yes here you get support of a generic gpio RFKILL
 	  driver. The platform should fill in the appropriate fields in the
 	  rfkill_gpio_platform_data structure and pass that to the driver.
-
-config RFKILL_RESET
-        bool "Reset bluetooth on resume"
-        depends on RFKILL && PM
-        default n
-
-config RFKILL_RK
-        bool "Rockchips RFKILL driver"
-        depends on RFKILL
-        help
-          rockchips rfkill driver for rk29/rk30
-
diff --git a/net/rfkill/Makefile b/net/rfkill/Makefile
index 186dbab8b90b..311768783f4a 100644
--- a/net/rfkill/Makefile
+++ b/net/rfkill/Makefile
@@ -7,4 +7,3 @@ rfkill-$(CONFIG_RFKILL_INPUT)	+= input.o
 obj-$(CONFIG_RFKILL)		+= rfkill.o
 obj-$(CONFIG_RFKILL_REGULATOR)	+= rfkill-regulator.o
 obj-$(CONFIG_RFKILL_GPIO)	+= rfkill-gpio.o
-obj-$(CONFIG_RFKILL_RK)		+= rfkill-rk.o
diff --git a/net/wireless/Kconfig b/net/wireless/Kconfig
index e7f54e5df1ec..8e2a668c9230 100644
--- a/net/wireless/Kconfig
+++ b/net/wireless/Kconfig
@@ -31,7 +31,7 @@ config CFG80211
 
 config NL80211_TESTMODE
 	bool "nl80211 testmode command"
-	depends on CFG80211 && (MT5931 || MT5931_MT6622 || MTK_COMBO || MT7601 ||ESP8089)	
+	depends on CFG80211
 	help
 	  The nl80211 testmode command helps implementing things like
 	  factory calibration or validation tools for wireless chips.
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 422e6032099b..752d5425adca 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -2283,20 +2283,9 @@ static int nl80211_send_station(struct sk_buff *msg, u32 pid, u32 seq,
 	}
 	nla_nest_end(msg, sinfoattr);
 
-#if defined(CONFIG_MT6620)
-    /*
-    **patch the cfg80211 for support AP mode need STA carry the assoc request ie. 
-    **Added by xbw, Rockchip Inc.
-    */
-    if (sinfo->assoc_req_ies) {
-        NLA_PUT(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,
-                sinfo->assoc_req_ies);
-    }
-#else
 	if (sinfo->filled & STATION_INFO_ASSOC_REQ_IES)
 		NLA_PUT(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,
 			sinfo->assoc_req_ies);
-#endif
 
 	return genlmsg_end(msg, hdr);
 
diff --git a/scripts/.gitignore b/scripts/.gitignore
index 78085220ba3a..105b21f08185 100644
--- a/scripts/.gitignore
+++ b/scripts/.gitignore
@@ -3,7 +3,6 @@
 #
 conmakehash
 kallsyms
-bmptologo
 pnmtologo
 bin2c
 unifdef
diff --git a/scripts/Makefile b/scripts/Makefile
index 905d59e06bc8..df7678febf27 100644
--- a/scripts/Makefile
+++ b/scripts/Makefile
@@ -10,7 +10,6 @@
 
 hostprogs-$(CONFIG_KALLSYMS)     += kallsyms
 hostprogs-$(CONFIG_LOGO)         += pnmtologo
-hostprogs-y        += bmptologo
 hostprogs-$(CONFIG_VT)           += conmakehash
 hostprogs-$(CONFIG_IKCONFIG)     += bin2c
 hostprogs-$(BUILD_C_RECORDMCOUNT) += recordmcount
diff --git a/scripts/Makefile.build b/scripts/Makefile.build
index 056c242b96ff..a0fd5029cfe7 100644
--- a/scripts/Makefile.build
+++ b/scripts/Makefile.build
@@ -463,12 +463,3 @@ endif
 # information in a variable se we can use it in if_changed and friends.
 
 .PHONY: $(PHONY)
-
-
-# .uu -> .o
-# ---------------------------------------------------------------------------
-quiet_cmd_uudecode_o_uu = DECODE  $@
-      cmd_uudecode_o_uu = uudecode -o $@ $<
-
-$(obj)/%.o: $(src)/%.uu FORCE
-	$(call if_changed,uudecode_o_uu)
diff --git a/scripts/pnmtologo.c b/scripts/pnmtologo.c
index 92af1e58584f..5c113123ed9f 100644
--- a/scripts/pnmtologo.c
+++ b/scripts/pnmtologo.c
@@ -27,6 +27,7 @@ static const char *logoname = "linux_logo";
 static const char *outputname;
 static FILE *out;
 
+
 #define LINUX_LOGO_MONO		1	/* monochrome black/white */
 #define LINUX_LOGO_VGA16	2	/* 16 colors VGA text palette */
 #define LINUX_LOGO_CLUT224	3	/* 224 colors */
@@ -66,24 +67,6 @@ static const struct color clut_vga16[16] = {
     { 0xff, 0xff, 0xff },
 };
 
-unsigned char data_name[] = {
-	0x6C, 0x6F, 0x67,
-	0x6F, 0x5F, 0x52,
-	0x4B, 0x6C, 0x6F,
-	0x67, 0x6F, 0x5F,
-	0x64, 0x61, 0x74,
-	0x61
-};
-
-unsigned char clut_name[] = {
-	0x70, 0x70, 0x6c,
-	0x6C, 0x6F, 0x67,
-	0x6F, 0x5F, 0x52,
-	0x4B, 0x6C, 0x6F,
-	0x67, 0x6F, 0x5F,
-	0x63, 0x6C, 0x75,
-	0x74
-};
 
 static int logo_type = LINUX_LOGO_CLUT224;
 static unsigned int logo_width;
@@ -96,6 +79,7 @@ static void die(const char *fmt, ...)
     __attribute__ ((noreturn)) __attribute ((format (printf, 1, 2)));
 static void usage(void) __attribute ((noreturn));
 
+
 static unsigned int get_number(FILE *fp)
 {
     int c, val;
@@ -134,15 +118,15 @@ static unsigned int get_number255(FILE *fp, unsigned int maxval)
 
 static void read_image(void)
 {
-	FILE *fp;
-	unsigned int i, j;
-	int magic;
-	unsigned int maxval;
+    FILE *fp;
+    unsigned int i, j;
+    int magic;
+    unsigned int maxval;
 
-	/* open image file */
-	fp = fopen(filename, "r");
-	if (!fp)
-		die("Cannot open file %s: %s\n", filename, strerror(errno));
+    /* open image file */
+    fp = fopen(filename, "r");
+    if (!fp)
+	die("Cannot open file %s: %s\n", filename, strerror(errno));
 
     /* check file type and read file header */
     magic = fgetc(fp);
@@ -166,19 +150,18 @@ static void read_image(void)
 	default:
 	    die("%s is not a PNM file\n", filename);
     }
-	logo_width = get_number(fp);
-	logo_height = get_number(fp);
-
-
-	/* allocate image data */
-	logo_data = (struct color **)malloc(logo_height * sizeof(struct color *));
-	if (!logo_data)
-		die("%s\n", strerror(errno));
-	for (i = 0; i < logo_height; i++) {
-		logo_data[i] = (struct color *)malloc(logo_width * sizeof(struct color));
-		if (!logo_data[i])
-		die("%s\n", strerror(errno));
-	}
+    logo_width = get_number(fp);
+    logo_height = get_number(fp);
+
+    /* allocate image data */
+    logo_data = (struct color **)malloc(logo_height*sizeof(struct color *));
+    if (!logo_data)
+	die("%s\n", strerror(errno));
+    for (i = 0; i < logo_height; i++) {
+	logo_data[i] = malloc(logo_width*sizeof(struct color));
+	if (!logo_data[i])
+	    die("%s\n", strerror(errno));
+    }
 
     /* read image data */
     switch (magic) {
@@ -235,6 +218,48 @@ static inline int is_equal(struct color c1, struct color c2)
     return c1.red == c2.red && c1.green == c2.green && c1.blue == c2.blue;
 }
 
+static void write_header(void)
+{
+    /* open logo file */
+    if (outputname) {
+	out = fopen(outputname, "w");
+	if (!out)
+	    die("Cannot create file %s: %s\n", outputname, strerror(errno));
+    } else {
+	out = stdout;
+    }
+
+    fputs("/*\n", out);
+    fputs(" *  DO NOT EDIT THIS FILE!\n", out);
+    fputs(" *\n", out);
+    fprintf(out, " *  It was automatically generated from %s\n", filename);
+    fputs(" *\n", out);
+    fprintf(out, " *  Linux logo %s\n", logoname);
+    fputs(" */\n\n", out);
+    fputs("#include <linux/linux_logo.h>\n\n", out);
+    fprintf(out, "static unsigned char %s_data[] __initdata = {\n",
+	    logoname);
+}
+
+static void write_footer(void)
+{
+    fputs("\n};\n\n", out);
+    fprintf(out, "const struct linux_logo %s __initconst = {\n", logoname);
+    fprintf(out, "\t.type\t\t= %s,\n", logo_types[logo_type]);
+    fprintf(out, "\t.width\t\t= %d,\n", logo_width);
+    fprintf(out, "\t.height\t\t= %d,\n", logo_height);
+    if (logo_type == LINUX_LOGO_CLUT224) {
+	fprintf(out, "\t.clutsize\t= %d,\n", logo_clutsize);
+	fprintf(out, "\t.clut\t\t= %s_clut,\n", logoname);
+    }
+    fprintf(out, "\t.data\t\t= %s_data\n", logoname);
+    fputs("};\n\n", out);
+
+    /* close logo file */
+    if (outputname)
+	fclose(out);
+}
+
 static int write_hex_cnt;
 
 static void write_hex(unsigned char byte)
@@ -248,55 +273,6 @@ static void write_hex(unsigned char byte)
     write_hex_cnt++;
 }
 
-static void write_header(void)
-{
-	/* open logo file */
-	if (outputname) {
-		out = fopen(outputname, "w");
-		if (!out)
-			die("Cannot create file %s: %s\n", outputname, strerror(errno));
-	} else {
-		out = stdout;
-	}
-
-	fputs("/*\n", out);
-	fputs(" *  DO NOT EDIT THIS FILE!\n", out);
-	fputs(" *\n", out);
-	fprintf(out, " *  It was automatically generated from %s\n", filename);
-	fputs(" *\n", out);
-	fprintf(out, " *  Linux logo %s\n", logoname);
-	fputs(" */\n\n", out);
-	fputs("#include <linux/linux_logo.h>\n\n", out);
-	fprintf(out, "static unsigned char %s_data[] __initdata = {\n",
-		logoname);
-}
-
-static void write_footer(void)
-{
-	fputs("\n};\n\n", out);
-	fprintf(out, "const struct linux_logo %s __initconst = {\n", logoname);
-	fprintf(out, "\t.type\t\t= %s,\n", logo_types[logo_type]);
-
-	if (logo_type == LINUX_LOGO_CLUT224) {
-		fprintf(out, "\t.clut\t\t= &(%s_clut[%ld]),\n", logoname, sizeof(clut_name));
-		fprintf(out, "\t.data\t\t= &(%s_data[%ld])\n", logoname, sizeof(data_name) + 4);
-	} else {
-		fprintf(out, "\t.width\t\t= %d,\n", logo_width);
-		fprintf(out, "\t.height\t\t= %d,\n", logo_height);
-		if (logo_type == LINUX_LOGO_CLUT224) {
-			fprintf(out, "\t.clutsize\t= %d,\n", logo_clutsize);
-			fprintf(out, "\t.clut\t\t= %s_clut,\n", logoname);
-		}
-		fprintf(out, "\t.data\t\t= %s_data\n", logoname);
-	}
-
-	fputs("};\n\n", out);
-
-	/* close logo file */
-	if (outputname)
-		fclose(out);
-}
-
 static void write_logo_mono(void)
 {
     unsigned int i, j;
@@ -321,7 +297,6 @@ static void write_logo_mono(void)
 	}
     }
 
-
     /* write logo structure and file footer */
     write_footer();
 }
@@ -368,78 +343,48 @@ static void write_logo_vga16(void)
 
 static void write_logo_clut224(void)
 {
-	unsigned int i, j, k;
-
-	logo_clutsize = 0;
-
-	/* validate image */
-	for (i = 0; i < logo_height; i++)
-		for (j = 0; j < logo_width; j++) {
-			for (k = 0; k < logo_clutsize; k++)
-				if (is_equal(logo_data[i][j], logo_clut[k]))
-					break;
-			if (k == logo_clutsize) {
-				if (logo_clutsize == MAX_LINUX_LOGO_COLORS)
-					die("Image has more than %d colors\n"
-						"Use ppmquant(1) to reduce the number of colors\n",
-						MAX_LINUX_LOGO_COLORS);
-					logo_clut[logo_clutsize++] = logo_data[i][j];
-			}
-		}
-
-	write_hex_cnt = 0;
-
-	/* write file header */
-	write_header();
-
-	write_hex((unsigned char)(logo_width >> 8));
-	write_hex((unsigned char)logo_width);
-	write_hex((unsigned char)(logo_height >> 8));
-	write_hex((unsigned char)logo_height);
-
-	for (i = 0; i < sizeof(data_name); i++){
-		write_hex(data_name[i]);
-	}
-	write_hex((unsigned char)(logo_width >> 8));
-	write_hex((unsigned char)logo_width);
-	write_hex((unsigned char)(logo_height >> 8));
-	write_hex((unsigned char)logo_height);
-
-	/* write logo data */
-	for (i = 0; i < logo_height; i++)
-		for (j = 0; j < logo_width; j++) {
-	 		for (k = 0; k < logo_clutsize; k++)
-				if (is_equal(logo_data[i][j], logo_clut[k]))
-					break;
-			write_hex(k+32);
-		}
-
-	fputs("\n};\n\n", out);
-
-	/* write logo clut */
-	fprintf(out, "static unsigned char %s_clut[] __initdata = {\n",
-		logoname);
-
-	write_hex_cnt = 0;
+    unsigned int i, j, k;
 
-	for (i = 0; i < sizeof(clut_name); i++){
-		write_hex(clut_name[i]);
+    /* validate image */
+    for (i = 0; i < logo_height; i++)
+	for (j = 0; j < logo_width; j++) {
+	    for (k = 0; k < logo_clutsize; k++)
+		if (is_equal(logo_data[i][j], logo_clut[k]))
+		    break;
+	    if (k == logo_clutsize) {
+		if (logo_clutsize == MAX_LINUX_LOGO_COLORS)
+		    die("Image has more than %d colors\n"
+			"Use ppmquant(1) to reduce the number of colors\n",
+			MAX_LINUX_LOGO_COLORS);
+		logo_clut[logo_clutsize++] = logo_data[i][j];
+	    }
 	}
-	write_hex(logo_clutsize);
 
-	for (i = 0; i < logo_clutsize; i++) {
-		write_hex(logo_clut[i].red);
-		write_hex(logo_clut[i].green);
-		write_hex(logo_clut[i].blue);
-	}
+    /* write file header */
+    write_header();
 
-	for (i = logo_clutsize; i < (MAX_LINUX_LOGO_COLORS * 3); i++)
-	{
-		write_hex(32);
+    /* write logo data */
+    for (i = 0; i < logo_height; i++)
+	for (j = 0; j < logo_width; j++) {
+	    for (k = 0; k < logo_clutsize; k++)
+		if (is_equal(logo_data[i][j], logo_clut[k]))
+		    break;
+	    write_hex(k+32);
 	}
+    fputs("\n};\n\n", out);
+
+    /* write logo clut */
+    fprintf(out, "static unsigned char %s_clut[] __initdata = {\n",
+	    logoname);
+    write_hex_cnt = 0;
+    for (i = 0; i < logo_clutsize; i++) {
+	write_hex(logo_clut[i].red);
+	write_hex(logo_clut[i].green);
+	write_hex(logo_clut[i].blue);
+    }
 
-	/* write logo structure and file footer */
-	write_footer();
+    /* write logo structure and file footer */
+    write_footer();
 }
 
 static void write_logo_gray256(void)
diff --git a/security/commoncap.c b/security/commoncap.c
index 8bfbd1349746..ccfe568b396f 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -88,12 +88,10 @@ EXPORT_SYMBOL(cap_netlink_recv);
 int cap_capable(struct task_struct *tsk, const struct cred *cred,
 		struct user_namespace *targ_ns, int cap, int audit)
 {
-#ifdef CONFIG_ANDROID_PARANOID_NETWORK
 	if (cap == CAP_NET_RAW && in_egroup_p(AID_NET_RAW))
 		return 0;
 	if (cap == CAP_NET_ADMIN && in_egroup_p(AID_NET_ADMIN))
 		return 0;
-#endif
 
 	for (;;) {
 		/* The creator of the user namespace has all caps. */
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index 903755aeb0b3..7393551a8c47 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -1048,17 +1048,6 @@ static int snd_pcm_pause(struct snd_pcm_substream *substream, int push)
 	return snd_pcm_action(&snd_pcm_action_pause, substream, push);
 }
 
-/*
- * set volume.
- * add by qiuen
- */
-static int snd_pcm_vol(struct snd_pcm_substream *substream, int push)
-{
-	substream->number = push;
-
-	return substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_VOLUME);
-}
-
 #ifdef CONFIG_PM
 /* suspend */
 
@@ -2593,11 +2582,6 @@ static int snd_pcm_common_ioctl1(struct file *file,
 		return snd_pcm_drain(substream, file);
 	case SNDRV_PCM_IOCTL_DROP:
 		return snd_pcm_drop(substream);
-	/*add by qiuen for volume*/	
-	case SNDRV_PCM_IOCTL_VOL:
-		snd_pcm_vol(substream, (int)(unsigned long)arg);
-		return 0;
-	/**********end***********/
 	case SNDRV_PCM_IOCTL_PAUSE:
 	{
 		int res;
@@ -2610,10 +2594,6 @@ static int snd_pcm_common_ioctl1(struct file *file,
 	snd_printd("unknown ioctl = 0x%x\n", cmd);
 	return -ENOTTY;
 }
-#ifdef	CONFIG_FB_MIRRORING
-int (*audio_data_to_mirroring)(void* data,int size,int channel) = NULL;
-EXPORT_SYMBOL(audio_data_to_mirroring);
-#endif
 
 static int snd_pcm_playback_ioctl1(struct file *file,
 				   struct snd_pcm_substream *substream,
@@ -2636,13 +2616,6 @@ static int snd_pcm_playback_ioctl1(struct file *file,
 			return -EFAULT;
 		if (copy_from_user(&xferi, _xferi, sizeof(xferi)))
 			return -EFAULT;
-		#ifdef	CONFIG_FB_MIRRORING
-		
-		if(audio_data_to_mirroring!=NULL)
-		 	audio_data_to_mirroring(xferi.buf, xferi.frames*4,2);
-		
-		#endif
-
 		result = snd_pcm_lib_write(substream, xferi.buf, xferi.frames);
 		__put_user(result, &_xferi->result);
 		return result < 0 ? result : 0;
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index aab26f2a1675..8224db5f0434 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -57,7 +57,7 @@ source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
-source "sound/soc/rk29/Kconfig"
+
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
 
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 7cd623ead431..1ed61c5df2c5 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -20,4 +20,3 @@ obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
-obj-$(CONFIG_SND_SOC)	+= rk29/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 4ef07128b60c..98175a096df2 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -26,14 +26,11 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_ALC5623 if I2C
 	select SND_SOC_CQ0093VC if MFD_DAVINCI_VOICECODEC
 	select SND_SOC_CS42L51 if I2C
-	select SND_SOC_CS42L52 if I2C
 	select SND_SOC_CS4270 if I2C
 	select SND_SOC_CS4271 if SND_SOC_I2C_AND_SPI
 	select SND_SOC_CX20442
 	select SND_SOC_DA7210 if I2C
 	select SND_SOC_DFBMCS320
-	select SND_SOC_ES8323 if SND_SOC_I2C_AND_SPI
-	select SND_SOC_ES8323_PCM if SND_SOC_I2C_AND_SPI
 	select SND_SOC_JZ4740_CODEC if SOC_JZ4740
 	select SND_SOC_LM4857 if I2C
 	select SND_SOC_MAX98088 if I2C
@@ -43,8 +40,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_PCM3008
 	select SND_SOC_SGTL5000 if I2C
 	select SND_SOC_SN95031 if INTEL_SCU_IPC
-	select SND_SOC_HDMI_I2S
-	select SND_SOC_HDMI_SPDIF
+	select SND_SOC_SPDIF
 	select SND_SOC_SSM2602 if SND_SOC_I2C_AND_SPI
 	select SND_SOC_STAC9766 if SND_SOC_AC97_BUS
 	select SND_SOC_TLV320AIC23 if I2C
@@ -53,7 +49,6 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_TLV320AIC3X if I2C
 	select SND_SOC_TPA6130A2 if I2C
 	select SND_SOC_TLV320DAC33 if I2C
-	select SND_SOC_TLV320AIC3111 if I2C
 	select SND_SOC_TWL4030 if TWL4030_CORE
 	select SND_SOC_TWL6040 if TWL4030_CORE
 	select SND_SOC_UDA134X
@@ -78,20 +73,6 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_WM8776 if SND_SOC_I2C_AND_SPI
 	select SND_SOC_WM8804 if SND_SOC_I2C_AND_SPI
 	select SND_SOC_WM8900 if I2C
-	select SND_SOC_RT5621 if I2C
-	select SND_SOC_RT5631 if I2C
-	select SND_SOC_AK4396 if SPI_MASTER
-	select SND_SOC_RT5631_PHONE if I2C
-	select SND_SOC_RT5625 if I2C
-	select SND_SOC_RT5640 if I2C
-	select SND_SOC_RT3261 if I2C
-	select SND_SOC_RT3224 if I2C
-	select SND_SOC_RT5623 if I2C
-	select SND_SOC_RT5639 if I2C
-	select SND_SOC_RT5616 if I2C
-	select SND_SOC_RT5512 if I2C
-	select SND_SOC_RK610 if I2C
-	select SND_SOC_RK616 if I2C
 	select SND_SOC_WM8903 if I2C
 	select SND_SOC_WM8904 if I2C
 	select SND_SOC_WM8915 if I2C
@@ -115,7 +96,6 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_WM9705 if SND_SOC_AC97_BUS
 	select SND_SOC_WM9712 if SND_SOC_AC97_BUS
 	select SND_SOC_WM9713 if SND_SOC_AC97_BUS
-	select SND_SOC_CX2070X if SND_SOC_I2C_AND_SPI
         help
           Normally ASoC codec drivers are only built if a machine driver which
           uses them is also built since they are only usable with a machine
@@ -178,9 +158,6 @@ config SND_SOC_CQ0093VC
 config SND_SOC_CS42L51
 	tristate
 
-config SND_SOC_CS42L52
-	tristate
-
 # Cirrus Logic CS4270 Codec
 config SND_SOC_CS4270
 	tristate
@@ -214,8 +191,6 @@ config SND_SOC_DFBMCS320
 config SND_SOC_DMIC
 	tristate
 
-config SND_SOC_ES8323
-	tristate
 config SND_SOC_MAX98088
        tristate
 
@@ -235,10 +210,7 @@ config SND_SOC_SGTL5000
 config SND_SOC_SN95031
 	tristate
 
-config SND_SOC_HDMI_I2S
-	tristate
-
-config SND_SOC_HDMI_SPDIF
+config SND_SOC_SPDIF
 	tristate
 
 config SND_SOC_SSM2602
@@ -263,12 +235,6 @@ config SND_SOC_TLV320AIC3X
 config SND_SOC_TLV320DAC33
 	tristate
 
-config SND_SOC_TLV320AIC3111
-	tristate
-
-config SND_SOC_TLV320AIC326X
-	tristate
-
 config SND_SOC_TWL4030
 	select TWL4030_CODEC
 	tristate
@@ -339,42 +305,6 @@ config SND_SOC_WM8804
 config SND_SOC_WM8900
 	tristate
 
-config SND_SOC_RT5621
-	tristate
-
-config SND_SOC_RT5623
-	tristate
-
-config SND_SOC_RT5639
-	tristate
-	
-config SND_SOC_RT5616
-	tristate
-
-config SND_SOC_AK4396
-	tristate
-	
-config SND_SOC_RT5631
-	tristate
-	
-config SND_SOC_RT5631_PHONE
-	tristate
-	
-config SND_SOC_RT5625
-	tristate
-
-config SND_SOC_RT5640
-	select SND_HWDEP
-	tristate
-
-config SND_SOC_RT3224
-	select SND_HWDEP
-	tristate
-
-config SND_SOC_RT3261
-	select SND_HWDEP
-	tristate
-
 config SND_SOC_WM8903
 	tristate
 
@@ -441,18 +371,6 @@ config SND_SOC_WM9712
 config SND_SOC_WM9713
 	tristate
 
-config SND_SOC_RK1000
-	tristate
-#	depends on RK1000_CONTROL
-
-config SND_SOC_RK610
-	tristate
-	depends on MFD_RK610
-
-config SND_SOC_RK616
-	tristate
-	depends on MFD_RK616
-
 # Amp
 config SND_SOC_LM4857
 	tristate
@@ -468,16 +386,3 @@ config SND_SOC_WM2000
 
 config SND_SOC_WM9090
 	tristate
-
-config SND_SOC_RK2928
-	tristate
-	depends on ARCH_RK2928
-
-config SND_SOC_RK3026
-	tristate
-	depends on ARCH_RK3026
-
-config SND_SOC_RT5512
-       tristate
-config SND_SOC_CX2070X
-       tristate	
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index c52948c0f4a4..fd8558406ef0 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -18,8 +18,6 @@ snd-soc-cx20442-objs := cx20442.o
 snd-soc-da7210-objs := da7210.o
 snd-soc-dfbmcs320-objs := dfbmcs320.o
 snd-soc-dmic-objs := dmic.o
-snd-soc-es8323-objs := es8323.o
-snd-soc-es8323-pcm-objs := es8323_pcm.o
 snd-soc-l3-objs := l3.o
 snd-soc-max98088-objs := max98088.o
 snd-soc-max98095-objs := max98095.o
@@ -28,17 +26,14 @@ snd-soc-pcm3008-objs := pcm3008.o
 snd-soc-sgtl5000-objs := sgtl5000.o
 snd-soc-alc5623-objs := alc5623.o
 snd-soc-sn95031-objs := sn95031.o
-snd-soc-hdmi-i2s-objs := hdmi_i2s.o
-snd-soc-hdmi-spdif-objs := hdmi_spdif.o
+snd-soc-spdif-objs := spdif_transciever.o
 snd-soc-ssm2602-objs := ssm2602.o
 snd-soc-stac9766-objs := stac9766.o
 snd-soc-tlv320aic23-objs := tlv320aic23.o
 snd-soc-tlv320aic26-objs := tlv320aic26.o
 snd-soc-tlv320aic3x-objs := tlv320aic3x.o
 snd-soc-tlv320aic32x4-objs := tlv320aic32x4.o
-snd-soc-tlv320aic3111-objs := tlv320aic3111.o
 snd-soc-tlv320dac33-objs := tlv320dac33.o
-snd-soc-tlv320aic326x-objs := tlv320aic326x.o aic326x_tiload.o aic3xxx_cfw_ops.o aic3262_codec_ops.o
 snd-soc-twl4030-objs := twl4030.o
 snd-soc-twl6040-objs := twl6040.o
 snd-soc-uda134x-objs := uda134x.o
@@ -62,14 +57,6 @@ snd-soc-wm8770-objs := wm8770.o
 snd-soc-wm8776-objs := wm8776.o
 snd-soc-wm8804-objs := wm8804.o
 snd-soc-wm8900-objs := wm8900.o
-snd-soc-rt5621-objs := rt5621.o
-snd-soc-rt5623-objs := rt5623.o
-snd-soc-rt5631-objs := rt5631.o
-snd-soc-ak4396-objs := ak4396.o
-snd-soc-rt5616-objs := rt5616.o
-snd-soc-rt5631-phone-objs := rt5631_phone.o
-snd-soc-rt5625-objs := rt5625.o
-snd-soc-cs42l52-objs := cs42l52.o
 snd-soc-wm8903-objs := wm8903.o
 snd-soc-wm8904-objs := wm8904.o
 snd-soc-wm8915-objs := wm8915.o
@@ -93,18 +80,7 @@ snd-soc-wm9705-objs := wm9705.o
 snd-soc-wm9712-objs := wm9712.o
 snd-soc-wm9713-objs := wm9713.o
 snd-soc-wm-hubs-objs := wm_hubs.o
-snd-soc-rk1000-objs := rk1000_codec.o
 snd-soc-jz4740-codec-objs := jz4740.o
-snd-soc-rk610-objs := rk610_codec.o
-snd-soc-rk616-objs := rk616_codec.o
-snd-soc-rt5640-objs := rt5640.o rt5640-dsp.o rt5640_ioctl.o rt56xx_ioctl.o
-snd-soc-rt3261-objs := rt3261.o rt3261-dsp.o rt3261_ioctl.o rt_codec_ioctl.o
-snd-soc-rt3224-objs := rt3261.o rt3261_ioctl.o rt_codec_ioctl.o
-snd-soc-rk2928-objs := rk2928_codec.o
-snd-soc-rk3026-objs := rk3026_codec.o
-snd-soc-rt5639-objs := rt5639.o rt5639_ioctl.o rt56xx_ioctl.o 
-snd-soc-rt5512-objs := rt5512.o
-snd-soc-cx2070x-objs := cx2070x.o cxdebug.o cxpump.o
 
 # Amp
 snd-soc-lm4857-objs := lm4857.o
@@ -112,10 +88,7 @@ snd-soc-max9877-objs := max9877.o
 snd-soc-tpa6130a2-objs := tpa6130a2.o
 snd-soc-wm2000-objs := wm2000.o
 snd-soc-wm9090-objs := wm9090.o
-obj-$(CONFIG_SND_SOC_RT5640)    += snd-soc-rt5640.o
-obj-$(CONFIG_SND_SOC_RT3261)    += snd-soc-rt3261.o
-obj-$(CONFIG_SND_SOC_RT3224)    += snd-soc-rt3224.o
-obj-$(CONFIG_SND_SOC_RT5639)    += snd-soc-rt5639.o
+
 obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
 obj-$(CONFIG_SND_SOC_AD1836)	+= snd-soc-ad1836.o
@@ -137,8 +110,6 @@ obj-$(CONFIG_SND_SOC_CX20442)	+= snd-soc-cx20442.o
 obj-$(CONFIG_SND_SOC_DA7210)	+= snd-soc-da7210.o
 obj-$(CONFIG_SND_SOC_DFBMCS320)	+= snd-soc-dfbmcs320.o
 obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
-obj-$(CONFIG_SND_SOC_ES8323)	+= snd-soc-es8323.o
-obj-$(CONFIG_SND_SOC_ES8323_PCM)	+= snd-soc-es8323-pcm.o
 obj-$(CONFIG_SND_SOC_L3)	+= snd-soc-l3.o
 obj-$(CONFIG_SND_SOC_JZ4740_CODEC)	+= snd-soc-jz4740-codec.o
 obj-$(CONFIG_SND_SOC_MAX98088)	+= snd-soc-max98088.o
@@ -147,17 +118,14 @@ obj-$(CONFIG_SND_SOC_MAX9850)	+= snd-soc-max9850.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
 obj-$(CONFIG_SND_SOC_SGTL5000)  += snd-soc-sgtl5000.o
 obj-$(CONFIG_SND_SOC_SN95031)	+=snd-soc-sn95031.o
-obj-$(CONFIG_SND_SOC_HDMI_I2S)	+= snd-soc-hdmi-i2s.o
-obj-$(CONFIG_SND_SOC_HDMI_SPDIF)	+= snd-soc-hdmi-spdif.o
+obj-$(CONFIG_SND_SOC_SPDIF)	+= snd-soc-spdif.o
 obj-$(CONFIG_SND_SOC_SSM2602)	+= snd-soc-ssm2602.o
 obj-$(CONFIG_SND_SOC_STAC9766)	+= snd-soc-stac9766.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23)	+= snd-soc-tlv320aic23.o
 obj-$(CONFIG_SND_SOC_TLV320AIC26)	+= snd-soc-tlv320aic26.o
 obj-$(CONFIG_SND_SOC_TLV320AIC3X)	+= snd-soc-tlv320aic3x.o
 obj-$(CONFIG_SND_SOC_TVL320AIC32X4)     += snd-soc-tlv320aic32x4.o
-obj-$(CONFIG_SND_SOC_TLV320AIC3111)	+= snd-soc-tlv320aic3111.o
 obj-$(CONFIG_SND_SOC_TLV320DAC33)	+= snd-soc-tlv320dac33.o
-obj-$(CONFIG_SND_SOC_TLV320AIC326X)	+= snd-soc-tlv320aic326x.o
 obj-$(CONFIG_SND_SOC_TWL4030)	+= snd-soc-twl4030.o
 obj-$(CONFIG_SND_SOC_TWL6040)	+= snd-soc-twl6040.o
 obj-$(CONFIG_SND_SOC_UDA134X)	+= snd-soc-uda134x.o
@@ -181,14 +149,6 @@ obj-$(CONFIG_SND_SOC_WM8770)	+= snd-soc-wm8770.o
 obj-$(CONFIG_SND_SOC_WM8776)	+= snd-soc-wm8776.o
 obj-$(CONFIG_SND_SOC_WM8804)	+= snd-soc-wm8804.o
 obj-$(CONFIG_SND_SOC_WM8900)	+= snd-soc-wm8900.o
-obj-$(CONFIG_SND_SOC_RT5621)	+= snd-soc-rt5621.o
-obj-$(CONFIG_SND_SOC_RT5623)	+= snd-soc-rt5623.o
-obj-$(CONFIG_SND_SOC_AK4396)	+= snd-soc-ak4396.o
-obj-$(CONFIG_SND_SOC_RT5631)	+= snd-soc-rt5631.o
-obj-$(CONFIG_SND_SOC_RT5616)	+= snd-soc-rt5616.o
-obj-$(CONFIG_SND_SOC_RT5631_PHONE)	+= snd-soc-rt5631-phone.o
-obj-$(CONFIG_SND_SOC_RT5625)	+= snd-soc-rt5625.o
-obj-$(CONFIG_SND_SOC_CS42L52)	+= snd-soc-cs42l52.o
 obj-$(CONFIG_SND_SOC_WM8903)	+= snd-soc-wm8903.o
 obj-$(CONFIG_SND_SOC_WM8904)	+= snd-soc-wm8904.o
 obj-$(CONFIG_SND_SOC_WM8915)	+= snd-soc-wm8915.o
@@ -212,13 +172,6 @@ obj-$(CONFIG_SND_SOC_WM9705)	+= snd-soc-wm9705.o
 obj-$(CONFIG_SND_SOC_WM9712)	+= snd-soc-wm9712.o
 obj-$(CONFIG_SND_SOC_WM9713)	+= snd-soc-wm9713.o
 obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
-obj-$(CONFIG_SND_SOC_RK1000)	+= snd-soc-rk1000.o
-obj-$(CONFIG_SND_SOC_RK610)	+= snd-soc-rk610.o
-obj-$(CONFIG_SND_SOC_RK616)	+= snd-soc-rk616.o
-obj-$(CONFIG_SND_SOC_RK2928)	+= snd-soc-rk2928.o
-obj-$(CONFIG_SND_SOC_RK3026)	+= snd-soc-rk3026.o
-obj-$(CONFIG_SND_SOC_RT5512)	+= snd-soc-rt5512.o
-obj-$(CONFIG_SND_SOC_CX2070X)   += snd-soc-cx2070x.o
 
 # Amp
 obj-$(CONFIG_SND_SOC_LM4857)	+= snd-soc-lm4857.o
diff --git a/sound/soc/codecs/cs42l52.c b/sound/soc/codecs/cs42l52.c
deleted file mode 100755
index 4d6bb96c2978..000000000000
--- a/sound/soc/codecs/cs42l52.c
+++ /dev/null
@@ -1,1604 +0,0 @@
-/*
- * cs42l52.c -- CS42L52 ALSA SoC audio driver
- *
- * Copyright 2007 CirrusLogic, Inc. 
- *
- * Author: Bo Liu <Bo.Liu@cirrus.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- * Revision history
- * Nov 2007  Initial version.
- * Oct 2008  Updated to 2.6.26
- */
-
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/initval.h>
-#include <sound/tlv.h>
-#include <linux/workqueue.h>
-#include <linux/types.h>
-#include <linux/device.h>
-#include <asm/io.h>
-#include "cs42l52.h"
-#include <mach/board.h>
-//#include "cs42L52_control.h"
-
-
-#if defined (CONFIG_SND_RK29_CODEC_SOC_MASTER) 
-	#define AUTO_DETECT_DISABLE
-#else
-	//#define AUTO_DETECT_DISABLE
-	#undef AUTO_DETECT_DISABLE
-#endif
-
-//#define DEBUG
-#ifdef DEBUG
-#define SOCDBG(fmt, arg...)	printk(KERN_ERR "%s: %s() " fmt, SOC_CS42L52_NAME, __FUNCTION__, ##arg)
-#else
-#define SOCDBG(fmt, arg...)	do { } while (0)
-#endif
-#define SOCINF(fmt, args...)	printk(KERN_INFO "%s: " fmt, SOC_CS42L52_NAME,  ##args)
-#define SOCERR(fmt, args...)	printk(KERN_ERR "%s: " fmt, SOC_CS42L52_NAME,  ##args)
-
-
-
-static void soc_cs42l52_work(struct work_struct *work);
-
-static struct snd_soc_codec *cs42l52_codec;
-
-//added for suspend
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend cs42l52_early_suspend;
-#endif
-
-static struct delayed_work delaywork;
-static u8   hp_detected;
-
-/**
- * snd_soc_get_volsw - single mixer get callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to get the value of a single mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_cs42l5x_get_volsw(struct snd_kcontrol *kcontrol,
-    struct snd_ctl_elem_value *ucontrol)
-{
-    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    int reg = kcontrol->private_value & 0xff;
-    int shift = (kcontrol->private_value >> 8) & 0x0f;
-    int rshift = (kcontrol->private_value >> 12) & 0x0f;
-    int max = (kcontrol->private_value >> 16) & 0xff;
-    int mask = (1 << fls(max)) - 1;
-    int min = (kcontrol->private_value >> 24) & 0xff;
-
-    ucontrol->value.integer.value[0] =
-	((snd_soc_read(codec, reg) >> shift) - min) & mask;
-    if (shift != rshift)
-	ucontrol->value.integer.value[1] =
-	    ((snd_soc_read(codec, reg) >> rshift) - min) & mask;
-
-    return 0;
-}
-
-/**
- * snd_soc_put_volsw - single mixer put callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to set the value of a single mixer control.
- *
- * Returns 0 for success.
- */
-int snd_soc_cs42l5x_put_volsw(struct snd_kcontrol *kcontrol,
-    struct snd_ctl_elem_value *ucontrol)
-{
-SOCDBG("i am here\n");
-    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    int reg = kcontrol->private_value & 0xff;
-    int shift = (kcontrol->private_value >> 8) & 0x0f;
-    int rshift = (kcontrol->private_value >> 12) & 0x0f;
-    int max = (kcontrol->private_value >> 16) & 0xff;
-    int mask = (1 << fls(max)) - 1;
-    int min = (kcontrol->private_value >> 24) & 0xff;
-    unsigned short val, val2, val_mask;
-
-    val = ((ucontrol->value.integer.value[0] + min) & mask);
-
-    val_mask = mask << shift;
-    val = val << shift;
-    if (shift != rshift) {
-	val2 = ((ucontrol->value.integer.value[1] + min) & mask);
-	val_mask |= mask << rshift;
-	val |= val2 << rshift;
-    }
-    return snd_soc_update_bits(codec, reg, val_mask, val);
-}
-
-/**
- * snd_soc_info_volsw_2r - double mixer info callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to provide information about a double mixer control that
- * spans 2 codec registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_cs42l5x_info_volsw_2r(struct snd_kcontrol *kcontrol,
-    struct snd_ctl_elem_info *uinfo)
-{
-    int max = (kcontrol->private_value >> 8) & 0xff;
-
-    if (max == 1)
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
-    else
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-
-    uinfo->count = 2;
-    uinfo->value.integer.min = 0;
-    uinfo->value.integer.max = max;
-    return 0;
-}
-
-/**
- * snd_soc_get_volsw_2r - double mixer get callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to get the value of a double mixer control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_cs42l5x_get_volsw_2r(struct snd_kcontrol *kcontrol,
-    struct snd_ctl_elem_value *ucontrol)
-{
-    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    int reg = kcontrol->private_value & 0xff;
-    int reg2 = (kcontrol->private_value >> 24) & 0xff;
-    int max = (kcontrol->private_value >> 8) & 0xff;
-    int min = (kcontrol->private_value >> 16) & 0xff;
-    int mask = (1<<fls(max))-1;
-    int val, val2;
-
-    val = snd_soc_read(codec, reg);
-    val2 = snd_soc_read(codec, reg2);
-    ucontrol->value.integer.value[0] = (val - min) & mask;
-    ucontrol->value.integer.value[1] = (val2 - min) & mask;
-/*    
-    SOCDBG("reg[%02x:%02x] = %02x:%02x ucontrol[%02x:%02x], min = %02x, max = %02x, mask %02x\n",
-	    reg, reg2, val,val2, 
-	    ucontrol->value.integer.value[0], ucontrol->value.integer.value[1], 
-	    min, max, mask);
-*/
-    return 0;
-}
-
-/**
- * snd_soc_put_volsw_2r - double mixer set callback
- * @kcontrol: mixer control
- * @uinfo: control element information
- *
- * Callback to set the value of a double mixer control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_soc_cs42l5x_put_volsw_2r(struct snd_kcontrol *kcontrol,
-    struct snd_ctl_elem_value *ucontrol)
-{
-    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-    int reg = kcontrol->private_value & 0xff;
-    int reg2 = (kcontrol->private_value >> 24) & 0xff;
-    int max = (kcontrol->private_value >> 8) & 0xff;
-    int min = (kcontrol->private_value >> 16) & 0xff;
-    int mask = (1 << fls(max)) - 1;
-    int err;
-    unsigned short val, val2;
-
-    val = (ucontrol->value.integer.value[0] + min) & mask;
-    val2 = (ucontrol->value.integer.value[1] + min) & mask;
-
-    if ((err = snd_soc_update_bits(codec, reg, mask, val)) < 0)
-	return err;
-
-    err = snd_soc_update_bits(codec, reg2, mask, val2);
-/*
-    SOCDBG("reg[%02x:%02x] = %02x:%02x, ucontrol[%02x:%02x], min = %02x, max = %02x, mask = %02x\n",
-	    reg, reg2, val, val2, 
-	    ucontrol->value.integer.value[0], ucontrol->value.integer.value[1], 
-	    min, max, mask);
-*/
-    return err;
-}
-
-#define SOC_SINGLE_CS42L52(xname, reg, shift, max, min) \
-{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
-        .info = snd_soc_info_volsw, .get = snd_soc_cs42l5x_get_volsw,\
-        .put = snd_soc_cs42l5x_put_volsw, \
-        .private_value =  SOC_SINGLE_VALUE(reg, shift, max, min) }
-
-#define SOC_DOUBLE_CS42L52(xname, reg, shift_left, shift_right, max, min) \
-{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
-        .info = snd_soc_info_volsw, .get = snd_soc_cs42l5x_get_volsw, \
-        .put = snd_soc_cs42l5x_put_volsw, \
-        .private_value = (reg) | ((shift_left) << 8) | \
-                ((shift_right) << 12) | ((max) << 16) | ((min) << 24) }
-
-/* No shifts required */
-#define SOC_DOUBLE_R_CS42L52(xname, reg_left, reg_right, max, min) \
-{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
-        .info = snd_soc_cs42l5x_info_volsw_2r, \
-        .get = snd_soc_cs42l5x_get_volsw_2r, .put = snd_soc_cs42l5x_put_volsw_2r, \
-        .private_value = (reg_left) | ((max) << 8) | ((min) << 16) | \
-		((reg_right) << 24) }
-
-
-/*
- * CS42L52 register default value
- */
-static const u8 soc_cs42l52_reg_default[] = {
-	0x00, 0xE0, 0x01, 0x06, 0x05, /*4*/
-	0xa0, 0x00, 0x00, 0x81, /*8*/
-	0x81, 0xa5, 0x00, 0x00, /*12*/
-	0x60, 0x02, 0x00, 0x00, /*16*/
-	0x00, 0x00, 0x00, 0x00, /*20*/
-	0x00, 0x00, 0x00, 0x80, /*24*/
-	0x80, 0x00, 0x00, 0x00, /*28*/
-	0x00, 0x00, 0x88, 0x00, /*32*/
-	0x00, 0x00, 0x00, 0x00, /*36*/
-	0x00, 0x00, 0x00, 0x7f, /*40*/
-	0xc0, 0x00, 0x3f, 0x00, /*44*/
-	0x00, 0x00, 0x00, 0x00, /*48*/
-	0x00, 0x3b, 0x00, 0x5f, /*52*/
-};
-
-static inline int soc_cs42l52_read_reg_cache(struct snd_soc_codec *codec,
-		u_int reg)
-{
-	u8 *cache = codec->reg_cache;
-
-	return reg > SOC_CS42L52_REG_NUM ? -EINVAL : cache[reg];
-}
-
-static inline void soc_cs42l52_write_reg_cache(struct snd_soc_codec *codec,
-		u_int reg, u_int val)
-{
-	u8 *cache = codec->reg_cache;
-	
-	if(reg > SOC_CS42L52_REG_NUM)
-		return;
-	cache[reg] = val & 0xff;
-}
-
-static int soc_cs42l52_write(struct snd_soc_codec *codec,
-		unsigned reg, u_int val)
-{
-#if 1
-	u8 datas[2];
-	int i,num, ret = 0;
-	struct soc_codec_cs42l52 *info = (struct soc_codec_cs42l52*)codec->private_data;
-
-	datas[0] = reg & 0xff;
-	datas[1] = val & 0xff;
-	codec->num_dai = 1;
-	if(info->flags & SOC_CS42L52_ALL_IN_ONE)
-	{
-		for(i = 0; i < codec->num_dai; i++)
-		{
-			if(codec->hw_write(codec->control_data, datas, 2) != 2)
-			{
-				ret = -EIO;
-				break;
-			}
-		}
-	}
-	else
-	{
-		if(info->flags & SOC_CS42L52_CHIP_SWICTH)
-		{
-			num = info->flags & SOC_CS42L52_CHIP_MASK;
-		}
-		
-		if(codec->hw_write(codec->control_data, datas, 2) != 2)
-			ret = -EIO;
-	}
-
-	if(ret >= 0)
-		soc_cs42l52_write_reg_cache(codec, reg, val);
-
-	return ret;
-#else
-	return codec->write(codec, reg, val);
-#endif
-}
-
-static unsigned int soc_cs42l52_read(struct snd_soc_codec *codec,
-		u_int reg)
-{
-#if 1
-	u8 data;
-	if(i2c_master_reg8_recv(codec->control_data,reg,&data,1,50*1000)>0) {
-
-		if(reg!=0x31)
-			printk(" cs42l52  reg =0x%x, val=0x%x\n",reg,data);
-		return data;
-	}
-	else {
-		printk("cs42l52  read error\n");
-		return -1;
-	}
-#else
-	return codec->read(codec, reg);
-#endif	
-}
-
-struct soc_cs42l52_clk_para {
-	u32 mclk;
-	u32 rate;
-	u8 speed;
-	u8 group;
-	u8 videoclk;
-	u8 ratio;
-	u8 mclkdiv2;
-};
-
-static const struct soc_cs42l52_clk_para clk_map_table[] = {
-	/*8k*/
-	{12288000, 8000, CLK_CTL_S_QS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{18432000, 8000, CLK_CTL_S_QS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{12000000, 8000, CLK_CTL_S_QS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 0},
-	{24000000, 8000, CLK_CTL_S_QS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 1},
-	{27000000, 8000, CLK_CTL_S_QS_MODE, CLK_CTL_32K_SR, CLK_CTL_27M_MCLK, CLK_CTL_RATIO_125, 0}, /*4*/
-
-	/*11.025k*/
-	{11289600, 11025, CLK_CTL_S_QS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{16934400, 11025, CLK_CTL_S_QS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	
-	/*16k*/
-	{12288000, 16000, CLK_CTL_S_HS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{18432000, 16000, CLK_CTL_S_HS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{12000000, 16000, CLK_CTL_S_HS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 0},/*9*/
-	{24000000, 16000, CLK_CTL_S_HS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 1},
-	{27000000, 16000, CLK_CTL_S_HS_MODE, CLK_CTL_32K_SR, CLK_CTL_27M_MCLK, CLK_CTL_RATIO_125, 1},
-
-	/*22.05k*/
-	{11289600, 22050, CLK_CTL_S_HS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{16934400, 22050, CLK_CTL_S_HS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	
-	/* 32k */
-	{12288000, 32000, CLK_CTL_S_SS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},/*14*/
-	{18432000, 32000, CLK_CTL_S_SS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{12000000, 32000, CLK_CTL_S_SS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 0},
-	{24000000, 32000, CLK_CTL_S_SS_MODE, CLK_CTL_32K_SR, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 1},
-	{27000000, 32000, CLK_CTL_S_SS_MODE, CLK_CTL_32K_SR, CLK_CTL_27M_MCLK, CLK_CTL_RATIO_125, 0},
-
-	/* 44.1k */
-	{11289600, 44100, CLK_CTL_S_SS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},/*19*/
-	{16934400, 44100, CLK_CTL_S_SS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{12000000, 44100, CLK_CTL_S_SS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_136, 0},
-
-	/* 48k */
-	{12288000, 48000, CLK_CTL_S_SS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{18432000, 48000, CLK_CTL_S_SS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{12000000, 48000, CLK_CTL_S_SS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 0},
-	{24000000, 48000, CLK_CTL_S_SS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 1},/*25*/
-	{27000000, 48000, CLK_CTL_S_SS_MODE, CLK_CTL_NOT_32K, CLK_CTL_27M_MCLK, CLK_CTL_RATIO_125, 1},
-
-	/* 88.2k */
-	{11289600, 88200, CLK_CTL_S_DS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{16934400, 88200, CLK_CTL_S_DS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-
-	/* 96k */
-	{12288000, 96000, CLK_CTL_S_DS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},
-	{18432000, 96000, CLK_CTL_S_DS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_128, 0},/*30*/
-	{12000000, 96000, CLK_CTL_S_DS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 0},
-	{24000000, 96000, CLK_CTL_S_DS_MODE, CLK_CTL_NOT_32K, CLK_CTL_NOT_27M, CLK_CTL_RATIO_125, 1},
-};
-
-static int soc_cs42l52_get_clk(int mclk, int rate)
-{
-	int i , ret = 0;
-	u_int mclk1, mclk2 = 0;
-
-	for(i = 0; i < ARRAY_SIZE(clk_map_table); i++){
-		if(clk_map_table[i].rate == rate){
-			mclk1 = clk_map_table[i].mclk;
-			if(abs(mclk - mclk1) < abs(mclk - mclk2)){
-				mclk2 = mclk1;
-				ret = i;
-			}
-		}
-	}
-
-	return ret < ARRAY_SIZE(clk_map_table) ? ret : -EINVAL;
-}
-
-static const char *cs42l52_mic_bias[] = {"0.5VA", "0.6VA", "0.7VA", "0.8VA", "0.83VA", "0.91VA"};
-static const char *cs42l52_hpf_freeze[] = {"Continuous DC Subtraction", "Frozen DC Subtraction"};
-static const char *cs42l52_hpf_corner_freq[] = {"Normal", "119Hz", "236Hz", "464Hz"};
-static const char *cs42l52_adc_sum[] = {"Normal", "Sum half", "Sub half", "Inverted"};
-static const char *cs42l52_sig_polarity[] = {"Normal", "Inverted"};
-static const char *cs42l52_spk_mono_channel[] = {"ChannelA", "ChannelB"};
-static const char *cs42l52_beep_type[] = {"Off", "Single", "Multiple", "Continuous"};
-static const char *cs42l52_treble_freq[] = {"5kHz", "7kHz", "10kHz", "15kHz"};
-static const char *cs42l52_bass_freq[] = {"50Hz", "100Hz", "200Hz", "250Hz"};
-static const char *cs42l52_target_sel[] = {"Apply Specific", "Apply All"};
-static const char *cs42l52_noise_gate_delay[] = {"50ms", "100ms", "150ms", "200ms"};
-static const char *cs42l52_adc_mux[] = {"AIN1", "AIN2", "AIN3", "AIN4", "PGA"};
-static const char *cs42l52_mic_mux[] = {"MIC1", "MIC2"};
-static const char *cs42l52_stereo_mux[] = {"Mono", "Stereo"};
-static const char *cs42l52_off[] = {"On", "Off"};
-static const char *cs42l52_hpmux[] = {"Off", "On"};
-
-static const struct soc_enum soc_cs42l52_enum[] = {
-SOC_ENUM_DOUBLE(CODEC_CS42L52_ANALOG_HPF_CTL, 4, 6, 2, cs42l52_hpf_freeze), /*0*/
-SOC_ENUM_SINGLE(CODEC_CS42L52_ADC_HPF_FREQ, 0, 4, cs42l52_hpf_corner_freq),
-SOC_ENUM_SINGLE(CODEC_CS42L52_ADC_MISC_CTL, 4, 4, cs42l52_adc_sum),
-SOC_ENUM_DOUBLE(CODEC_CS42L52_ADC_MISC_CTL, 2, 3, 2, cs42l52_sig_polarity),
-SOC_ENUM_DOUBLE(CODEC_CS42L52_PB_CTL1, 2, 3, 2, cs42l52_sig_polarity),
-SOC_ENUM_SINGLE(CODEC_CS42L52_PB_CTL2, 2, 2, cs42l52_spk_mono_channel), /*5*/
-SOC_ENUM_SINGLE(CODEC_CS42L52_BEEP_TONE_CTL, 6, 4, cs42l52_beep_type),
-SOC_ENUM_SINGLE(CODEC_CS42L52_BEEP_TONE_CTL, 3, 4, cs42l52_treble_freq),
-SOC_ENUM_SINGLE(CODEC_CS42L52_BEEP_TONE_CTL, 1, 4, cs42l52_bass_freq),
-SOC_ENUM_SINGLE(CODEC_CS42L52_LIMITER_CTL2, 6, 2, cs42l52_target_sel),
-SOC_ENUM_SINGLE(CODEC_CS42L52_NOISE_GATE_CTL, 7, 2, cs42l52_target_sel), /*10*/
-SOC_ENUM_SINGLE(CODEC_CS42L52_NOISE_GATE_CTL, 0, 4, cs42l52_noise_gate_delay),
-SOC_ENUM_SINGLE(CODEC_CS42L52_ADC_PGA_A, 5, 5, cs42l52_adc_mux),
-SOC_ENUM_SINGLE(CODEC_CS42L52_ADC_PGA_B, 5, 5, cs42l52_adc_mux),
-SOC_ENUM_SINGLE(CODEC_CS42L52_MICA_CTL, 6, 2, cs42l52_mic_mux),
-SOC_ENUM_SINGLE(CODEC_CS42L52_MICB_CTL, 6, 2, cs42l52_mic_mux), /*15*/
-SOC_ENUM_SINGLE(CODEC_CS42L52_MICA_CTL, 5, 2, cs42l52_stereo_mux),
-SOC_ENUM_SINGLE(CODEC_CS42L52_MICB_CTL, 5, 2, cs42l52_stereo_mux),
-SOC_ENUM_SINGLE(CODEC_CS42L52_IFACE_CTL2, 0, 6, cs42l52_mic_bias), /*18*/
-SOC_ENUM_SINGLE(CODEC_CS42L52_PWCTL2, 0, 2, cs42l52_off),
-SOC_ENUM_SINGLE(CODEC_CS42L52_MISC_CTL, 6, 2, cs42l52_hpmux),
-SOC_ENUM_SINGLE(CODEC_CS42L52_MISC_CTL, 7, 2, cs42l52_hpmux),
-};
-
-static const struct snd_kcontrol_new soc_cs42l52_controls[] = {
-
-SOC_ENUM("Mic VA Capture Switch", soc_cs42l52_enum[18]), /*0*/
-SOC_DOUBLE("HPF Capture Switch", CODEC_CS42L52_ANALOG_HPF_CTL, 5, 7, 1, 0),
-SOC_ENUM("HPF Freeze Capture Switch", soc_cs42l52_enum[0]),
-
-SOC_DOUBLE("Analog SR Capture Switch", CODEC_CS42L52_ANALOG_HPF_CTL, 1, 3, 1, 1),
-SOC_DOUBLE("Analog ZC Capture Switch", CODEC_CS42L52_ANALOG_HPF_CTL, 0, 2, 1, 1),
-SOC_ENUM("HPF corner freq Capture Switch", soc_cs42l52_enum[1]), /*5*/
-
-SOC_SINGLE("Ganged Ctl Capture Switch", CODEC_CS42L52_ADC_MISC_CTL, 7, 1, 1), /* should be enabled init */
-SOC_ENUM("Mix/Swap Capture Switch",soc_cs42l52_enum[2]),
-SOC_ENUM("Signal Polarity Capture Switch", soc_cs42l52_enum[3]),
-
-//SOC_SINGLE("HP Analog Gain Playback Volume", CODEC_CS42L52_PB_CTL1, 5, 7, 0),    //rocky liu 
-SOC_SINGLE("Playback B=A Volume Playback Switch", CODEC_CS42L52_PB_CTL1, 4, 1, 0), /*10*/ /*should be enabled init*/ 
-SOC_ENUM("PCM Signal Polarity Playback Switch",soc_cs42l52_enum[4]),
-
-SOC_SINGLE("Digital De-Emphasis Playback Switch", CODEC_CS42L52_MISC_CTL, 2, 1, 0),
-SOC_SINGLE("Digital SR Playback Switch", CODEC_CS42L52_MISC_CTL, 1, 1, 0),
-SOC_SINGLE("Digital ZC Playback Switch", CODEC_CS42L52_MISC_CTL, 0, 1, 0),
-
-SOC_SINGLE("Spk Volume Equal Playback Switch", CODEC_CS42L52_PB_CTL2, 3, 1, 0) , /*15*/ /*should be enabled init*/
-SOC_SINGLE("Spk Mute 50/50 Playback Switch", CODEC_CS42L52_PB_CTL2, 0, 1, 0),
-SOC_ENUM("Spk Swap Channel Playback Switch", soc_cs42l52_enum[5]),
-SOC_SINGLE("Spk Full-Bridge Playback Switch", CODEC_CS42L52_PB_CTL2, 1, 1, 0),
-SOC_DOUBLE_R("Mic Gain Capture Volume", CODEC_CS42L52_MICA_CTL, CODEC_CS42L52_MICB_CTL, 0, 31, 0),
-
-SOC_DOUBLE_R("ALC SR Capture Switch", CODEC_CS42L52_PGAA_CTL, CODEC_CS42L52_PGAB_CTL, 7, 1, 1), /*20*/
-SOC_DOUBLE_R("ALC ZC Capture Switch", CODEC_CS42L52_PGAA_CTL, CODEC_CS42L52_PGAB_CTL, 6, 1, 1),
-SOC_DOUBLE_R_CS42L52("PGA Capture Volume", CODEC_CS42L52_PGAA_CTL, CODEC_CS42L52_PGAB_CTL, 0x30, 0x18),
-
-SOC_DOUBLE_R_CS42L52("Passthru Playback Volume", CODEC_CS42L52_PASSTHRUA_VOL, CODEC_CS42L52_PASSTHRUB_VOL, 0x90, 0x88),
-SOC_DOUBLE("Passthru Playback Switch", CODEC_CS42L52_MISC_CTL, 4, 5, 1, 1),
-SOC_DOUBLE_R_CS42L52("ADC Capture Volume", CODEC_CS42L52_ADCA_VOL, CODEC_CS42L52_ADCB_VOL, 0x80, 0xA0),
-SOC_DOUBLE("ADC Capture Switch", CODEC_CS42L52_ADC_MISC_CTL, 0, 1, 1, 1),
-SOC_DOUBLE_R_CS42L52("ADC Mixer Capture Volume", CODEC_CS42L52_ADCA_MIXER_VOL, CODEC_CS42L52_ADCB_MIXER_VOL, 0x7f, 0x19),
-SOC_DOUBLE_R("ADC Mixer Capture Switch", CODEC_CS42L52_ADCA_MIXER_VOL, CODEC_CS42L52_ADCB_MIXER_VOL, 7, 1, 1),
-SOC_DOUBLE_R_CS42L52("PCM Mixer Playback Volume", CODEC_CS42L52_PCMA_MIXER_VOL, CODEC_CS42L52_PCMB_MIXER_VOL, 0x7f, 0x19),
-SOC_DOUBLE_R("PCM Mixer Playback Switch", CODEC_CS42L52_PCMA_MIXER_VOL, CODEC_CS42L52_PCMB_MIXER_VOL, 7, 1, 1),
-
-SOC_SINGLE("Beep Freq", CODEC_CS42L52_BEEP_FREQ, 4, 15, 0),
-SOC_SINGLE("Beep OnTime", CODEC_CS42L52_BEEP_FREQ, 0, 15, 0), /*30*/
-SOC_SINGLE_CS42L52("Beep Volume", CODEC_CS42L52_BEEP_VOL, 0, 0x1f, 0x07),
-SOC_SINGLE("Beep OffTime", CODEC_CS42L52_BEEP_VOL, 5, 7, 0),
-SOC_ENUM("Beep Type", soc_cs42l52_enum[6]),
-SOC_SINGLE("Beep Mix Switch", CODEC_CS42L52_BEEP_TONE_CTL, 5, 1, 1),
-
-SOC_ENUM("Treble Corner Freq Playback Switch", soc_cs42l52_enum[7]), /*35*/
-SOC_ENUM("Bass Corner Freq Playback Switch",soc_cs42l52_enum[8]),
-SOC_SINGLE("Tone Control Playback Switch", CODEC_CS42L52_BEEP_TONE_CTL, 0, 1, 0),
-SOC_SINGLE("Treble Gain Playback Volume", CODEC_CS42L52_TONE_CTL, 4, 15, 1),
-SOC_SINGLE("Bass Gain Playback Volume", CODEC_CS42L52_TONE_CTL, 0, 15, 1),
-
-SOC_DOUBLE_R_CS42L52("Master Playback Volume", CODEC_CS42L52_MASTERA_VOL, CODEC_CS42L52_MASTERB_VOL,0x18, 0x18), /* koffu 40*/
-SOC_DOUBLE_R_CS42L52("HP Digital Playback Volume", CODEC_CS42L52_HPA_VOL, CODEC_CS42L52_HPB_VOL, 0xff, 0x1),
-SOC_DOUBLE("HP Digital Playback Switch", CODEC_CS42L52_PB_CTL2, 6, 7, 1, 1),
-SOC_DOUBLE_R_CS42L52("Speaker Playback Volume", CODEC_CS42L52_SPKA_VOL, CODEC_CS42L52_SPKB_VOL, 0xff, 0x1),
-SOC_DOUBLE("Speaker Playback Switch", CODEC_CS42L52_PB_CTL2, 4, 5, 1, 1),
-
-SOC_SINGLE("Limiter Max Threshold Playback Volume", CODEC_CS42L52_LIMITER_CTL1, 5, 7, 0),
-SOC_SINGLE("Limiter Cushion Threshold Playback Volume", CODEC_CS42L52_LIMITER_CTL1, 2, 7, 0),
-SOC_SINGLE("Limiter SR Playback Switch", CODEC_CS42L52_LIMITER_CTL1, 1, 1, 0), /*45*/
-SOC_SINGLE("Limiter ZC Playback Switch", CODEC_CS42L52_LIMITER_CTL1, 0, 1, 0),
-SOC_SINGLE("Limiter Playback Switch", CODEC_CS42L52_LIMITER_CTL2, 7, 1, 0),
-SOC_ENUM("Limiter Attnenuate Playback Switch", soc_cs42l52_enum[9]),
-SOC_SINGLE("Limiter Release Rate Playback Volume", CODEC_CS42L52_LIMITER_CTL2, 0, 63, 0),
-SOC_SINGLE("Limiter Attack Rate Playback Volume", CODEC_CS42L52_LIMITER_AT_RATE, 0, 63, 0), /*50*/
-
-SOC_DOUBLE("ALC Capture Switch",CODEC_CS42L52_ALC_CTL, 6, 7, 1, 0),
-SOC_SINGLE("ALC Attack Rate Capture Volume", CODEC_CS42L52_ALC_CTL, 0, 63, 0),
-SOC_SINGLE("ALC Release Rate Capture Volume", CODEC_CS42L52_ALC_RATE, 0, 63, 0),
-SOC_SINGLE("ALC Max Threshold Capture Volume", CODEC_CS42L52_ALC_THRESHOLD, 5, 7, 0),
-SOC_SINGLE("ALC Min Threshold Capture Volume", CODEC_CS42L52_ALC_THRESHOLD, 2, 7, 0), /*55*/
-
-SOC_ENUM("Noise Gate Type Capture Switch", soc_cs42l52_enum[10]),
-SOC_SINGLE("Noise Gate Capture Switch", CODEC_CS42L52_NOISE_GATE_CTL, 6, 1, 0),
-SOC_SINGLE("Noise Gate Boost Capture Switch", CODEC_CS42L52_NOISE_GATE_CTL, 5, 1, 1),
-SOC_SINGLE("Noise Gate Threshold Capture Volume", CODEC_CS42L52_NOISE_GATE_CTL, 2, 7, 0),
-SOC_ENUM("Noise Gate Delay Time Capture Switch", soc_cs42l52_enum[11]), /*60*/
-
-SOC_SINGLE("Batt Compensation Switch", CODEC_CS42L52_BATT_COMPEN, 7, 1, 0),
-SOC_SINGLE("Batt VP Monitor Switch", CODEC_CS42L52_BATT_COMPEN, 6, 1, 0),
-SOC_SINGLE("Batt VP ref", CODEC_CS42L52_BATT_COMPEN, 0, 0x0f, 0),
-SOC_SINGLE("Playback Charge Pump Freq", CODEC_CS42L52_CHARGE_PUMP, 4, 15, 0), /*64*/
-
-};
-
-static int soc_cs42l52_add_controls(struct snd_soc_codec *codec)
-{
-	int i,ret = 0;
-
-	for(i = 0; i < ARRAY_SIZE(soc_cs42l52_controls); i++)
-	{
-		ret = snd_ctl_add(codec->card,
-		snd_soc_cnew(&soc_cs42l52_controls[i], codec, NULL));
-
-		if(ret < 0)
-		{
-			SOCDBG("add cs42l52 controls failed\n");
-			break;
-		}
-	}
-	return ret;
-}
-
-static const struct snd_kcontrol_new cs42l52_adca_mux =
-SOC_DAPM_ENUM("Route", soc_cs42l52_enum[12]);
-
-static const struct snd_kcontrol_new cs42l52_adcb_mux =
-SOC_DAPM_ENUM("Route", soc_cs42l52_enum[13]);
-
-static const struct snd_kcontrol_new cs42l52_mica_mux =
-SOC_DAPM_ENUM("Route", soc_cs42l52_enum[14]);
-
-static const struct snd_kcontrol_new cs42l52_micb_mux =
-SOC_DAPM_ENUM("Route", soc_cs42l52_enum[15]);
-
-static const struct snd_kcontrol_new cs42l52_mica_stereo_mux =
-SOC_DAPM_ENUM("Route", soc_cs42l52_enum[16]);
-
-static const struct snd_kcontrol_new cs42l52_micb_stereo_mux =
-SOC_DAPM_ENUM("Route", soc_cs42l52_enum[17]);
-
-static const struct snd_kcontrol_new cs42l52_passa_switch =
-SOC_DAPM_SINGLE("Switch", CODEC_CS42L52_MISC_CTL, 6, 1, 0);
-
-static const struct snd_kcontrol_new cs42l52_passb_switch =
-SOC_DAPM_SINGLE("Switch", CODEC_CS42L52_MISC_CTL, 7, 1, 0);
-
-static const struct snd_kcontrol_new cs42l52_micbias_switch =
-SOC_DAPM_ENUM("Route", soc_cs42l52_enum[19]);
-
-static const struct snd_kcontrol_new cs42l52_hpa_mux =
-SOC_DAPM_ENUM("Route", soc_cs42l52_enum[20]);
-
-static const struct snd_kcontrol_new cs42l52_hpb_mux =
-SOC_DAPM_ENUM("Route", soc_cs42l52_enum[21]);
-
-static const struct snd_soc_dapm_widget soc_cs42l52_dapm_widgets[] = {
-
-	/* Input path */
-	SND_SOC_DAPM_ADC("ADC Left", "Capture", CODEC_CS42L52_PWCTL1, 1, 1),
-	//SND_SOC_DAPM_ADC("ADC Right", "Capture", CODEC_CS42L52_PWCTL1, 2, 1),
-
-	
-	SND_SOC_DAPM_MUX("MICA Mux Capture Switch", SND_SOC_NOPM, 0, 0, &cs42l52_mica_mux),
-	SND_SOC_DAPM_MUX("MICB Mux Capture Switch", SND_SOC_NOPM, 0, 0, &cs42l52_micb_mux),
-	SND_SOC_DAPM_MUX("MICA Stereo Mux Capture Switch", SND_SOC_NOPM, 1, 0, &cs42l52_mica_stereo_mux),
-	SND_SOC_DAPM_MUX("MICB Stereo Mux Capture Switch", SND_SOC_NOPM, 2, 0, &cs42l52_micb_stereo_mux),
-
-	SND_SOC_DAPM_MUX("ADC Mux Left Capture Switch", SND_SOC_NOPM, 1, 1, &cs42l52_adca_mux),
-	SND_SOC_DAPM_MUX("ADC Mux Right Capture Switch", SND_SOC_NOPM, 2, 1, &cs42l52_adcb_mux),
-
-
-	/* Sum switches */
-	SND_SOC_DAPM_PGA("AIN1A Switch", CODEC_CS42L52_ADC_PGA_A, 0, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("AIN2A Switch", CODEC_CS42L52_ADC_PGA_A, 1, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("AIN3A Switch", CODEC_CS42L52_ADC_PGA_A, 2, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("AIN4A Switch", CODEC_CS42L52_ADC_PGA_A, 3, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("MICA Switch" , CODEC_CS42L52_ADC_PGA_A, 4, 0, NULL, 0),
-
-	SND_SOC_DAPM_PGA("AIN1B Switch", CODEC_CS42L52_ADC_PGA_B, 0, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("AIN2B Switch", CODEC_CS42L52_ADC_PGA_B, 1, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("AIN3B Switch", CODEC_CS42L52_ADC_PGA_B, 2, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("AIN4B Switch", CODEC_CS42L52_ADC_PGA_B, 3, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("MICB Switch" , CODEC_CS42L52_ADC_PGA_B, 4, 0, NULL, 0),
-
-	/* MIC PGA Power */
-	SND_SOC_DAPM_PGA("PGA MICA", CODEC_CS42L52_PWCTL2, PWCTL2_PDN_MICA_SHIFT, 1, NULL, 0),
-	SND_SOC_DAPM_PGA("PGA MICB", CODEC_CS42L52_PWCTL2, PWCTL2_PDN_MICB_SHIFT, 1, NULL, 0),
-
-	/* MIC bias switch */
-	SND_SOC_DAPM_MUX("Mic Bias Capture Switch", SND_SOC_NOPM, 0, 0, &cs42l52_micbias_switch),
-	SND_SOC_DAPM_PGA("Mic-Bias", CODEC_CS42L52_PWCTL2, 0, 1, NULL, 0),
-
-	/* PGA Power */
-	SND_SOC_DAPM_PGA("PGA Left", CODEC_CS42L52_PWCTL1, PWCTL1_PDN_PGAA_SHIFT, 1, NULL, 0),
-	SND_SOC_DAPM_PGA("PGA Right", CODEC_CS42L52_PWCTL1, PWCTL1_PDN_PGAB_SHIFT, 1, NULL, 0),
-
-	/* Output path */
-	SND_SOC_DAPM_MUX("Passthrough Left Playback Switch", SND_SOC_NOPM, 0, 0, &cs42l52_hpa_mux),
-	SND_SOC_DAPM_MUX("Passthrough Right Playback Switch", SND_SOC_NOPM, 0, 0, &cs42l52_hpb_mux),
-
-	SND_SOC_DAPM_DAC("DAC Left", "Playback", SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_DAC("DAC Right", "Playback", SND_SOC_NOPM, 0, 0),
-
-	SND_SOC_DAPM_PGA("HP Amp Left", CODEC_CS42L52_PWCTL3, 4, 1, NULL, 0),
-	SND_SOC_DAPM_PGA("HP Amp Right", CODEC_CS42L52_PWCTL3, 6, 1, NULL, 0),
-
-	SND_SOC_DAPM_PGA("SPK Pwr Left", CODEC_CS42L52_PWCTL3, 0, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("SPK Pwr Right", CODEC_CS42L52_PWCTL3, 2, 0, NULL, 0),
-
-	SND_SOC_DAPM_OUTPUT("HPA"),
-	SND_SOC_DAPM_OUTPUT("HPB"),
-	SND_SOC_DAPM_OUTPUT("SPKA"),
-	SND_SOC_DAPM_OUTPUT("SPKB"),
-	SND_SOC_DAPM_OUTPUT("MICBIAS"),
-
-	SND_SOC_DAPM_INPUT("INPUT1A"),
-	SND_SOC_DAPM_INPUT("INPUT2A"),
-	SND_SOC_DAPM_INPUT("INPUT3A"),
-	SND_SOC_DAPM_INPUT("INPUT4A"),
-	SND_SOC_DAPM_INPUT("INPUT1B"),
-	SND_SOC_DAPM_INPUT("INPUT2B"),
-	SND_SOC_DAPM_INPUT("INPUT3B"),
-	SND_SOC_DAPM_INPUT("INPUT4B"),
-	SND_SOC_DAPM_INPUT("MICA"),
-	SND_SOC_DAPM_INPUT("MICB"),
-};
-
-static const struct snd_soc_dapm_route soc_cs42l52_audio_map[] = {
-
-	/* adc select path */
-	{"ADC Mux Left Capture Switch", "AIN1", "INPUT1A"},
-	{"ADC Mux Right Capture Switch", "AIN1", "INPUT1B"},
-	{"ADC Mux Left Capture Switch", "AIN2", "INPUT2A"},
-	{"ADC Mux Right Capture Switch", "AIN2", "INPUT2B"},
-	{"ADC Mux Left Capture Switch", "AIN3", "INPUT3A"},
-	{"ADC Mux Right Capture Switch", "AIN3", "INPUT3B"},
-	{"ADC Mux Left Capture Switch", "AIN4", "INPUT4A"},
-	{"ADC Mux Right Capture Switch", "AIN4", "INPUT4B"},
-
-	/* left capture part */
-	{"AIN1A Switch", NULL, "INPUT1A"},
-	{"AIN2A Switch", NULL, "INPUT2A"},
-	{"AIN3A Switch", NULL, "INPUT3A"},
-	{"AIN4A Switch", NULL, "INPUT4A"},
-	{"MICA Switch",  NULL, "MICA"},
-	{"PGA MICA", NULL, "MICA Switch"},
-
-	{"PGA Left", NULL, "AIN1A Switch"},
-	{"PGA Left", NULL, "AIN2A Switch"},
-	{"PGA Left", NULL, "AIN3A Switch"},
-	{"PGA Left", NULL, "AIN4A Switch"},
-	{"PGA Left", NULL, "PGA MICA"},
-
-	/* right capture part */
-	{"AIN1B Switch", NULL, "INPUT1B"},
-	{"AIN2B Switch", NULL, "INPUT2B"},
-	{"AIN3B Switch", NULL, "INPUT3B"},
-	{"AIN4B Switch", NULL, "INPUT4B"},
-	{"MICB Switch",  NULL, "MICB"},
-	{"PGA MICB", NULL, "MICB Switch"},
-
-	{"PGA Right", NULL, "AIN1B Switch"},
-	{"PGA Right", NULL, "AIN2B Switch"},
-	{"PGA Right", NULL, "AIN3B Switch"},
-	{"PGA Right", NULL, "AIN4B Switch"},
-	{"PGA Right", NULL, "PGA MICB"},
-
-	{"ADC Mux Left Capture Switch", "PGA", "PGA Left"},
-	{"ADC Mux Right Capture Switch", "PGA", "PGA Right"},
-	{"ADC Left", NULL, "ADC Mux Left Capture Switch"},
-	{"ADC Right", NULL, "ADC Mux Right Capture Switch"},
-
-	/* Mic Bias */
-	{"Mic Bias Capture Switch", "On", "PGA MICA"},
-	{"Mic Bias Capture Switch", "On", "PGA MICB"},
-	{"Mic-Bias", NULL, "Mic Bias Capture Switch"},
-	{"Mic-Bias", NULL, "Mic Bias Capture Switch"},
-	{"ADC Mux Left Capture Switch",  "PGA", "Mic-Bias"},
-	{"ADC Mux Right Capture Switch", "PGA", "Mic-Bias"},
-	{"Passthrough Left Playback Switch",  "On", "Mic-Bias"},
-	{"Passthrough Right Playback Switch", "On", "Mic-Bias"},
-
-	/* loopback path */
-	{"Passthrough Left Playback Switch",  "On",  "PGA Left"},
-	{"Passthrough Right Playback Switch", "On",  "PGA Right"},
-	{"Passthrough Left Playback Switch",  "Off", "DAC Left"},
-	{"Passthrough Right Playback Switch", "Off", "DAC Right"},
-
-	/* Output map */
-	/* Headphone */
-	{"HP Amp Left",  NULL, "Passthrough Left Playback Switch"},
-	{"HP Amp Right", NULL, "Passthrough Right Playback Switch"},
-	{"HPA", NULL, "HP Amp Left"},
-	{"HPB", NULL, "HP Amp Right"},
-
-	/* Speakers */
-	{"SPK Pwr Left",  NULL, "DAC Left"},
-	{"SPK Pwr Right", NULL, "DAC Right"},
-	{"SPKA", NULL, "SPK Pwr Left"},
-	{"SPKB", NULL, "SPK Pwr Right"},
-
-	/* terminator */
-	//{NULL, NULL, NULL},
-};
-
-static int soc_cs42l52_add_widgets(struct snd_soc_codec *soc_codec)
-{
-	snd_soc_dapm_new_controls(soc_codec, soc_cs42l52_dapm_widgets,
-				ARRAY_SIZE(soc_cs42l52_dapm_widgets));
-
-	snd_soc_dapm_add_routes(soc_codec, soc_cs42l52_audio_map,
-                        	ARRAY_SIZE(soc_cs42l52_audio_map));	
-
-	snd_soc_dapm_new_widgets(soc_codec);
-        return 0;
-}
-#if 0
-#define SOC_CS42L52_RATES ( SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 | \
-                            SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
-                            SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
-                            SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | \
-                            SNDRV_PCM_RATE_96000 )
-#else
-#define SOC_CS42L52_RATES  SNDRV_PCM_RATE_44100
-#endif
-#define SOC_CS42L52_FORMATS ( SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE | \
-                              SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_U18_3LE | \
-                              SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_U20_3LE | \
-                              SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_U24_LE )
-
-
-/*
- *----------------------------------------------------------------------------
- * Function : soc_cs42l52_set_bias_level
- * Purpose  : This function is to get triggered when dapm events occurs.
- *            
- *----------------------------------------------------------------------------
- */
-int soc_cs42l52_set_bias_level(struct snd_soc_codec *codec, enum snd_soc_bias_level level)
-{
-	u8 pwctl1 = soc_cs42l52_read(codec, CODEC_CS42L52_PWCTL1) & 0x9f;
-	u8 pwctl2 = soc_cs42l52_read(codec, CODEC_CS42L52_PWCTL2) & 0x07;
-
-	switch (level) {
-        case SND_SOC_BIAS_ON: /* full On */
-		SOCDBG("full on\n");
-		break;
-        case SND_SOC_BIAS_PREPARE: /* partial On */
-		SOCDBG("partial on\n");
-		pwctl1 &= ~(PWCTL1_PDN_CHRG | PWCTL1_PDN_CODEC);
-                soc_cs42l52_write(codec, CODEC_CS42L52_PWCTL1, pwctl1);
-                break;
-        case SND_SOC_BIAS_STANDBY: /* Off, with power */
-		SOCDBG("off with power\n");
-		pwctl1 &= ~(PWCTL1_PDN_CHRG | PWCTL1_PDN_CODEC);
-                soc_cs42l52_write(codec, CODEC_CS42L52_PWCTL1, pwctl1);
-                break;
-        case SND_SOC_BIAS_OFF: /* Off, without power */
-		SOCDBG("off without power\n");
-              soc_cs42l52_write(codec, CODEC_CS42L52_PWCTL1, pwctl1 | 0x9f);
-		soc_cs42l52_write(codec, CODEC_CS42L52_PWCTL2, pwctl2 | 0x06);
-                break;
-        }
-        codec->bias_level = level;
-
-        return 0;
-}
-
-/*
- *----------------------------------------------------------------------------
- * Function : cs42l52_power_init
- * Purpose  : This function is toinit codec to a normal status
- *   
- *----------------------------------------------------------------------------
- */
-static void cs42l52_power_init (struct snd_soc_codec *soc_codec)
-{
-	int i,ret;
-
-	SOCDBG("\n");
-	for(i = 0; i < soc_codec->num_dai; i++)
-	{
-		SOCINF("Cirrus CS42L52 codec , revision %d\n", ret & CHIP_REV_MASK);
-
-		/*set hp default volume*/
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_HPA_VOL, DEFAULT_HP_VOL);
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_HPB_VOL, DEFAULT_HP_VOL);
-
-		/*set spk default volume*/
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_SPKA_VOL, DEFAULT_SPK_VOL);
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_SPKB_VOL, DEFAULT_SPK_VOL);
-
-		/*set output default powerstate*/
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_PWCTL3, 5);
-
-#ifdef AUTO_DETECT_DISABLE
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_CLK_CTL, 
-				(soc_cs42l52_read(soc_codec, CODEC_CS42L52_CLK_CTL) 
-				 & ~CLK_CTL_AUTODECT_ENABLE));
-#else
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_CLK_CTL,
-				(soc_cs42l52_read(soc_codec, CODEC_CS42L52_CLK_CTL)
-				 |CLK_CTL_AUTODECT_ENABLE));
-#endif
-
-		/*default output stream configure*/
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_PB_CTL1, 0x60);
-		/*
-					(soc_cs42l52_read(soc_codec, CODEC_CS42L52_PB_CTL1)
-					| (PB_CTL1_HP_GAIN_07099 << PB_CTL1_HP_GAIN_SHIFT)));
-		*///rocky
-		/*
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_MISC_CTL,
-				(soc_cs42l52_read(soc_codec, CODEC_CS42L52_MISC_CTL))
-				| (MISC_CTL_DEEMPH | MISC_CTL_DIGZC | MISC_CTL_DIGSFT));
-		*/ //rocky
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_MICA_CTL,
-				(soc_cs42l52_read(soc_codec, CODEC_CS42L52_MICA_CTL)
-				| 0<<6));/*pre-amplifer 16db*/
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_MICB_CTL,
-				(soc_cs42l52_read(soc_codec, CODEC_CS42L52_MICB_CTL)
-				| 0<<6));/*pre-amplifer 16db*/
-
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_PWCTL2, 0x00);
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_ADC_PGA_A, 0x90); 
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_ADC_PGA_B, 0x90); 
-
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_MICA_CTL, 0x2c);
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_MICB_CTL, 0x2c);
-
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_NOISE_GATE_CTL, 0xe3);
-
-
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_IFACE_CTL2,
-		 	(soc_cs42l52_read(soc_codec, CODEC_CS42L52_IFACE_CTL2)
-				| 0x5));
-		
-
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_PGAA_CTL, 0x00);  //0dB PGA
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_PGAB_CTL, 0x00);  //0dB PGA
-
-		 soc_cs42l52_write(soc_codec, CODEC_CS42L52_ADC_HPF_FREQ, 0x0F);  //enable 464Hz HPF
-
-
-		hp_detected = (soc_cs42l52_read(soc_codec,CODEC_CS42L52_SPK_STATUS) &0x8);	//rocky
-
-		if(hp_detected==0)
-		{		
-			soc_cs42l52_write(soc_codec, CODEC_CS42L52_MASTERA_VOL, 0x0);
-			soc_cs42l52_write(soc_codec, CODEC_CS42L52_MASTERB_VOL, 0x0);
-		}
-		else
-		{
-			soc_cs42l52_write(soc_codec, CODEC_CS42L52_MASTERA_VOL, 0x06);
-			soc_cs42l52_write(soc_codec, CODEC_CS42L52_MASTERB_VOL, 0x06);
-		}
-		
-	
-
-	}
-
-	return;
-}
-
-/*
- *----------------------------------------------------------------------------
- * Function : soc_cs42l52_work
- * Purpose  : This function is to power on bias.
- *            
- *----------------------------------------------------------------------------
- */
-static void soc_cs42l52_work(struct work_struct *work)
-{
-	struct snd_soc_codec *codec =
-                container_of(work, struct snd_soc_codec, delayed_work.work);
-
-	soc_cs42l52_set_bias_level(codec, codec->bias_level);
-
-	return;
-}
-
-/*
- *----------------------------------------------------------------------------
- * Function : soc_cs42l52_trigger
- * Purpose  : This function is to respond to trigger.
- *            
- *----------------------------------------------------------------------------
- */
-static int soc_cs42l52_trigger(struct snd_pcm_substream *substream,
-			  int status,
-			  struct snd_soc_dai *dai)
-{	
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
-
-	SOCDBG ("substream->stream:%s status:%d\n",
-		   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "PLAYBACK":"CAPTURE", status);
-
-	if(status == 1 || status == 0){
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-			codec_dai->playback.active = status;
-		}else{
-			codec_dai->capture.active = status;
-		}
-	}
-
-	return 0;
-}
-
-/*
- *----------------------------------------------------------------------------
- * Function : soc_cs42l52_hw_params
- * Purpose  : This function is to set the hardware parameters for CS42L52.
- *            The functions set the sample rate and audio serial data word 
- *            length.
- *            
- *----------------------------------------------------------------------------
- */
-static int soc_cs42l52_hw_params(struct snd_pcm_substream *substream,
-                        struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_device *soc_dev = rtd->socdev;
-	struct snd_soc_codec *soc_codec = soc_dev->card->codec;
-	struct soc_codec_cs42l52 *info = (struct soc_codec_cs42l52*)soc_codec->private_data;
-
-	u32 clk = 0;
-	int ret = 0;
-	int index = soc_cs42l52_get_clk(info->sysclk, params_rate(params));
-
-	SOCDBG("----------sysclk=%d,rate=%d\n",info->sysclk, params_rate(params));
-
-	if(index >= 0)
-	{
-		info->sysclk = clk_map_table[index].mclk;
-		clk |= (clk_map_table[index].speed << CLK_CTL_SPEED_SHIFT) | 
-		      (clk_map_table[index].group << CLK_CTL_32K_SR_SHIFT) | 
-		      (clk_map_table[index].videoclk << CLK_CTL_27M_MCLK_SHIFT) | 
-		      (clk_map_table[index].ratio << CLK_CTL_RATIO_SHIFT) | 
-		      clk_map_table[index].mclkdiv2;
-
-#ifdef AUTO_DETECT_DISABLE
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_CLK_CTL, clk);
-#else
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_CLK_CTL, 0xa0);
-#endif
-	}
-	else{
-		SOCDBG("can't find out right mclk\n");
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-/*
- *----------------------------------------------------------------------------
- * Function : soc_cs42l52_set_sysclk
- * Purpose  : This function is to set the DAI system clock
- *            
- *----------------------------------------------------------------------------
- */
-static int soc_cs42l52_set_sysclk(struct snd_soc_dai *codec_dai,
-			int clk_id, u_int freq, int dir)
-{
-	int ret = 0;
-	struct snd_soc_codec *soc_codec = codec_dai->codec;
-	struct soc_codec_cs42l52 *info = (struct soc_codec_cs42l52*)soc_codec->private_data;
-
-	SOCDBG("info->sysclk=%dHz,freq=%d\n", info->sysclk,freq);
-
-	if((freq >= SOC_CS42L52_MIN_CLK) && (freq <= SOC_CS42L52_MAX_CLK)){
-		info->sysclk = freq;
-		SOCDBG("info->sysclk set to %d Hz\n", info->sysclk);
-	}
-	else{
-		printk("invalid paramter\n");
-		ret = -EINVAL;
-	}
-	return ret;
-}
-
-/*
- *----------------------------------------------------------------------------
- * Function : soc_cs42l52_set_fmt
- * Purpose  : This function is to set the DAI format
- *            
- *----------------------------------------------------------------------------
- */
-static int soc_cs42l52_set_fmt(struct snd_soc_dai *codec_dai,
-			u_int fmt)
-{
-	struct snd_soc_codec *soc_codec = codec_dai->codec;
-	struct soc_codec_cs42l52 *info = (struct soc_codec_cs42l52*)soc_codec->private_data;
-	int ret = 0;
-	u8 iface = 0;
-
-	/* set master/slave audio interface */
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		SOCDBG("codec dai fmt master\n");
-		iface = IFACE_CTL1_MASTER;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		SOCDBG("codec dai fmt slave\n");
-		break;
-	default:
-		SOCDBG("invaild formate\n");
-		ret = -EINVAL;
-		goto done;
-	}
-
-	 /* interface format */
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_I2S:
-		SOCDBG("codec dai fmt i2s\n");
-		iface |= (IFACE_CTL1_ADC_FMT_I2S | IFACE_CTL1_DAC_FMT_I2S);
-		break;
-	case SND_SOC_DAIFMT_RIGHT_J:
-		SOCDBG("codec dai fmt right justified\n");
-		iface |= IFACE_CTL1_DAC_FMT_RIGHT_J;
-		SOCINF("warning only playback stream support this format\n");
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		SOCDBG("codec dai fmt left justified\n");
-		iface |= (IFACE_CTL1_ADC_FMT_LEFT_J | IFACE_CTL1_DAC_FMT_LEFT_J);
-		break;
-	case SND_SOC_DAIFMT_DSP_A:
-		iface |= IFACE_CTL1_DSP_MODE_EN;
-		break;
-	case SND_SOC_DAIFMT_DSP_B:
-		SOCINF("unsupported format\n");
-		ret = -EINVAL;
-		goto done;
-	default:
-		SOCINF("invaild format\n");
-		ret = -EINVAL;
-		goto done;
-	}
-
-	/* clock inversion */
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_NF:
-		SOCDBG("codec dai fmt normal sclk\n");
-		break;
-	case SND_SOC_DAIFMT_IB_IF:
-		SOCDBG("codec dai fmt inversed sclk\n");
-		iface |= IFACE_CTL1_INV_SCLK;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		iface |= IFACE_CTL1_INV_SCLK;
-		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		break;
-	default:
-		SOCDBG("unsupported format\n");
-		ret = -EINVAL;
-	}
-
-	info->format = iface;
-done:
-	soc_cs42l52_write(soc_codec, CODEC_CS42L52_IFACE_CTL1, info->format);
-
-	return ret;
-}
-
-/*
- *----------------------------------------------------------------------------
- * Function : soc_cs42l52_digital_mute
- * Purpose  : This function is to mute DAC or not
- *            
- *----------------------------------------------------------------------------
- */
-static int soc_cs42l52_digital_mute(struct snd_soc_dai *dai, int mute)
-{
-	struct snd_soc_codec *soc_codec = dai->codec;
-	u8 mute_val = soc_cs42l52_read(soc_codec, CODEC_CS42L52_PB_CTL1) & PB_CTL1_MUTE_MASK;
-
-	SOCDBG("%d\n",mute);
-
-	if(mute) {
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_PB_CTL1, mute_val \
-			| PB_CTL1_MSTB_MUTE | PB_CTL1_MSTA_MUTE);
-	}
-	else {
-		soc_cs42l52_write(soc_codec, CODEC_CS42L52_PB_CTL1, mute_val );
-	}
-
-	return 0;
-}
-
-static struct snd_soc_dai_ops cs42l52_ops = {
-			.hw_params		= soc_cs42l52_hw_params,
-			.set_sysclk		= soc_cs42l52_set_sysclk,
-			.set_fmt		= soc_cs42l52_set_fmt,
-			.trigger		= soc_cs42l52_trigger,
-			.digital_mute	= soc_cs42l52_digital_mute,
-};
-/*
- *----------------------------------------------------------------------------
- * @struct  soc_cs42l52_dai |
- *          It is SoC Codec DAI structure which has DAI capabilities viz., 
- *          playback and capture, DAI runtime information viz. state of DAI 
- *			and pop wait state, and DAI private data. 
- *          The AIC3111 rates ranges from 8k to 192k
- *          The PCM bit format supported are 16, 20, 24 and 32 bits
- *----------------------------------------------------------------------------
- */
-struct  snd_soc_dai soc_cs42l52_dai = {
-            .name = SOC_CS42L52_NAME,
-            .playback = {
-                    .stream_name = "Playback",
-                    .channels_min = 1,
-                    .channels_max = SOC_CS42L52_DEFAULT_MAX_CHANS,
-                    .rates = SOC_CS42L52_RATES,
-                    .formats = SOC_CS42L52_FORMATS,
-            },
-            .capture = {
-                    .stream_name = "Capture",
-                    .channels_min = 1,
-                    .channels_max = SOC_CS42L52_DEFAULT_MAX_CHANS,
-                    .rates = SOC_CS42L52_RATES,
-                    .formats = SOC_CS42L52_FORMATS,
-            },
-			.ops = &cs42l52_ops,
-};
-EXPORT_SYMBOL_GPL(soc_cs42l52_dai);
-
-//added by koffu for Work
-/*
- *----------------------------------------------------------------------------
- * Function: soc_codec_detect_hp
- * Purpose : Read  CODEC_CS42L52_SPK_STATUS (Speaker Status(Address 31h)) 
- *               Indicates the status of the SPKR/HP pin.                  
- *               if (1<<3) ,  select Speaker mod , if (0<<3) , select  Headset mod;    
- *----------------------------------------------------------------------------
- */
-static void  soc_codec_detect_hp(struct work_struct *work)
-{
-
-	u8 val =  soc_cs42l52_read(cs42l52_codec,CODEC_CS42L52_SPK_STATUS);
-	val = val&0x08;
-	
-	if(val == hp_detected){
-		schedule_delayed_work(&delaywork, msecs_to_jiffies(200));
-		return;
-	}
-
-	hp_detected = val;
-	
-	if(val == 0){
-		SOCDBG("hp is detected \n");
-		soc_cs42l52_write(cs42l52_codec, CODEC_CS42L52_MASTERA_VOL, 0x00);
-		soc_cs42l52_write(cs42l52_codec, CODEC_CS42L52_MASTERB_VOL, 0x00);
-
-		soc_cs42l52_write(cs42l52_codec, CODEC_CS42L52_BEEP_TONE_CTL, 0X00);
-		soc_cs42l52_write(cs42l52_codec, CODEC_CS42L52_TONE_CTL, 0X00);		
-	}
-	else
-	{
-		SOCDBG("speaker is detected \n");
-		soc_cs42l52_write(cs42l52_codec, CODEC_CS42L52_MASTERA_VOL, 0x06);
-		soc_cs42l52_write(cs42l52_codec, CODEC_CS42L52_MASTERB_VOL, 0x06);
-
-	}
-
-	schedule_delayed_work(&delaywork, msecs_to_jiffies(200));
-
-}
-
-#if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
-static int cs42l52_i2c_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
-{	
-	struct snd_soc_codec *soc_codec;
-	struct soc_codec_cs42l52 * info;
-	struct cs42l52_platform_data *pdata = i2c->dev.platform_data;
-	int ret = 0;
-
-	soc_codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
-	if (soc_codec == NULL)
-		return -ENOMEM;
-
-	soc_codec->name = SOC_CS42L52_NAME;
-	soc_codec->owner = THIS_MODULE;
-	soc_codec->write = soc_cs42l52_write;
-	soc_codec->read = soc_cs42l52_read;
-	soc_codec->hw_write = (hw_write_t)i2c_master_send;
-	mutex_init(&soc_codec->mutex);
-	INIT_LIST_HEAD(&soc_codec->dapm_widgets);
-	INIT_LIST_HEAD(&soc_codec->dapm_paths);
-	
-	soc_codec->set_bias_level = soc_cs42l52_set_bias_level;
-	soc_codec->dai = &soc_cs42l52_dai;
-	soc_codec->dai->playback.channels_max = 2;
-	soc_codec->dai->capture.channels_max = 2;
-	soc_codec->num_dai = 1;
-	soc_codec->control_data = i2c;
-	soc_codec->dev = &i2c->dev;	
-	soc_codec->pcm_devs = 0;
-	soc_codec->pop_time = 2;
-	soc_codec->dai[0].codec = soc_codec;
-
-	soc_codec->reg_cache_size = sizeof(soc_cs42l52_reg_default);
-
-	soc_codec->reg_cache = kmemdup(soc_cs42l52_reg_default, sizeof(soc_cs42l52_reg_default), GFP_KERNEL);
-
-	info = (struct soc_codec_cs42l52 *)kmalloc(sizeof(struct soc_codec_cs42l52),GFP_KERNEL);
-	if (info == NULL) {
-		kfree(soc_codec);
-		return -ENOMEM;
-	}
-
-	info->sysclk = SOC_CS42L52_DEFAULT_CLK;
-	info->format = SOC_CS42L52_DEFAULT_FORMAT;
-
-	soc_codec->private_data =(void*)info;	
-	if(!soc_codec->reg_cache) {
-		SOCERR("%s: err out of memory\n", __FUNCTION__);
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	if (pdata->init_platform_hw)                              
-		pdata->init_platform_hw();
-
-	/*initialize codec*/
-	cs42l52_power_init(soc_codec);
-
-    INIT_DELAYED_WORK(&soc_codec->delayed_work, soc_cs42l52_work);
-
-	soc_cs42l52_dai.dev = &i2c->dev;
-	cs42l52_codec = soc_codec;
-
-	INIT_DELAYED_WORK(&delaywork, soc_codec_detect_hp);
-	schedule_delayed_work(&delaywork, msecs_to_jiffies(200));
-
-	ret = snd_soc_register_codec(soc_codec);
-	if (ret != 0) {
-		dev_err(&i2c->dev, "Failed to register codec: %d\n", ret);
-		goto err;
-	}
-
-	ret = snd_soc_register_dai(&soc_cs42l52_dai);
-	if (ret != 0) {
-		dev_err(&i2c->dev, "Failed to register DAI: %d\n", ret);
-		goto err_codec;
-	}
-
-	return ret;
-
-err_codec:
-	snd_soc_unregister_codec(soc_codec);
-err:
-	kfree(cs42l52_codec);
-	cs42l52_codec = NULL;
-	return ret;
-}
-
-static int cs42l52_i2c_remove(struct i2c_client *client)
-{
-	snd_soc_unregister_dai(&soc_cs42l52_dai);
-	snd_soc_unregister_codec(cs42l52_codec);
-
-	soc_cs42l52_set_bias_level(cs42l52_codec, SND_SOC_BIAS_OFF);
-
-	soc_cs42l52_dai.dev = NULL;
-	if(cs42l52_codec->reg_cache)		
-		kfree(cs42l52_codec->reg_cache);
-	if(cs42l52_codec->private_data)		
-		kfree(cs42l52_codec->private_data);
-	kfree(cs42l52_codec);
-	cs42l52_codec = NULL;
-
-	return 0;
-}
-
-
-static int cs42l52_i2c_shutdown(struct i2c_client *client)
-{
-	SOCDBG("i am here\n");        
-	snd_soc_unregister_dai(&soc_cs42l52_dai);
-	snd_soc_unregister_codec(cs42l52_codec);
-
-	soc_cs42l52_set_bias_level(cs42l52_codec, SND_SOC_BIAS_OFF);
-	
-	cancel_delayed_work(&delaywork);
-
-	soc_cs42l52_dai.dev = NULL;
-	if(cs42l52_codec->reg_cache)		
-		kfree(cs42l52_codec->reg_cache);
-	if(cs42l52_codec->private_data)		
-		kfree(cs42l52_codec->private_data);
-	kfree(cs42l52_codec);
-	cs42l52_codec = NULL;
-
-	return 0;
-}
-
-static const struct i2c_device_id cs42l52_i2c_id[] = {
-	{ "cs42l52", 0 },
-};
-MODULE_DEVICE_TABLE(i2c, cs42l52_i2c_id);
-
-static struct i2c_driver cs42l52_i2c_drv = {
-	.driver = {
-		.name = "CS42L52",
-		.owner = THIS_MODULE,
-	},
-	.probe =    cs42l52_i2c_probe,
-	.remove =   cs42l52_i2c_remove,
-	.shutdown =  cs42l52_i2c_shutdown,
-	.id_table = cs42l52_i2c_id,
-};
-
-#endif
-
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static int soc_cs42l52_suspend(struct early_suspend *h)
-{
-	
-	soc_cs42l52_write(cs42l52_codec, CODEC_CS42L52_PWCTL1, PWCTL1_PDN_CODEC);
-	soc_cs42l52_set_bias_level(cs42l52_codec, SND_SOC_BIAS_OFF);
-	return 0;
-}
-
-static int soc_cs42l52_resume(struct early_suspend *h)
-{
-	struct snd_soc_codec *soc_codec = cs42l52_codec;
-	struct soc_codec_cs42l52 *info = (struct soc_codec_cs42l52*) soc_codec->private_data;
-	int i, reg;
-	u8 data[2];
-	u8 *reg_cache = (u8*) soc_codec->reg_cache;
-	soc_codec->num_dai = 1;
-	/* Sync reg_cache with the hardware */
-	for(i = 0; i < soc_codec->num_dai; i++) {
-
-	    for(reg = 0; reg < ARRAY_SIZE(soc_cs42l52_reg_default); reg++) {
-		data[0] = reg;
-		data[1] = reg_cache[reg];
-		if(soc_codec->hw_write(soc_codec->control_data, data, 2) != 2)
-		    break;
-	    }
-	}
-
-	soc_cs42l52_set_bias_level(soc_codec, SND_SOC_BIAS_STANDBY);
-
-	/*charge cs42l52 codec*/
-	if(soc_codec->suspend_bias_level == SND_SOC_BIAS_ON)
-	{
-		soc_cs42l52_set_bias_level(soc_codec, SND_SOC_BIAS_PREPARE);
-		soc_codec->bias_level = SND_SOC_BIAS_ON;
-		schedule_delayed_work(&soc_codec->delayed_work, msecs_to_jiffies(1000));
-	}
-	return 0;
-
-}
-#else
-static int soc_cs42l52_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct snd_soc_device *soc_dev = (struct snd_soc_device*)platform_get_drvdata(pdev);
-	struct snd_soc_codec *soc_codec = soc_dev->card->codec;
-	
-	soc_cs42l52_write(soc_codec, CODEC_CS42L52_PWCTL1, PWCTL1_PDN_CODEC);
-	soc_cs42l52_set_bias_level(soc_codec, SND_SOC_BIAS_OFF);
-	return 0;
-}
-
-static int soc_cs42l52_resume(struct platform_device *pdev)
-{
-	struct snd_soc_device *soc_dev = (struct snd_soc_device*) platform_get_drvdata(pdev);
-	struct snd_soc_codec *soc_codec = soc_dev->card->codec;
-	struct soc_codec_cs42l52 *info = (struct soc_codec_cs42l52*) soc_codec->private_data;
-	int i, reg;
-	u8 data[2];
-	u8 *reg_cache = (u8*) soc_codec->reg_cache;
-	soc_codec->num_dai = 1;
-	/* Sync reg_cache with the hardware */
-	for(i = 0; i < soc_codec->num_dai; i++) {
-
-	    for(reg = 0; reg < ARRAY_SIZE(soc_cs42l52_reg_default); reg++) {
-		data[0] = reg;
-		data[1] = reg_cache[reg];
-		if(soc_codec->hw_write(soc_codec->control_data, data, 2) != 2)
-		    break;
-	    }
-	}
-
-	soc_cs42l52_set_bias_level(soc_codec, SND_SOC_BIAS_STANDBY);
-
-	/*charge cs42l52 codec*/
-	if(soc_codec->suspend_bias_level == SND_SOC_BIAS_ON)
-	{
-		soc_cs42l52_set_bias_level(soc_codec, SND_SOC_BIAS_PREPARE);
-		soc_codec->bias_level = SND_SOC_BIAS_ON;
-		schedule_delayed_work(&soc_codec->delayed_work, msecs_to_jiffies(1000));
-	}
-	return 0;
-
-}
-#endif
-static int soc_cs42l52_probe(struct platform_device *pdev)
-{
-	struct snd_soc_device *soc_dev = platform_get_drvdata(pdev);
-	struct snd_soc_codec *soc_codec;
-	int ret = 0;
-
-	if (cs42l52_codec == NULL) {
-		dev_err(&pdev->dev, "Codec device not registered\n");
-		return -ENODEV;
-	}
-
-	soc_dev->card->codec = cs42l52_codec;
-	soc_codec = cs42l52_codec;
-
-	ret = snd_soc_new_pcms(soc_dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
-	if(ret)
-	{
-		SOCERR("%s: add new pcms failed\n",__FUNCTION__);
-		goto pcm_err;
-	}
-
-	soc_cs42l52_add_controls(soc_codec);
-	soc_cs42l52_add_widgets(soc_codec);
-
-	ret = snd_soc_init_card(soc_dev);
-
-	INIT_DELAYED_WORK(&soc_codec->delayed_work, soc_cs42l52_work);
-
-	if(ret)
-	{
-		SOCERR("add snd card failed\n");
-		goto card_err;
-	}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND   
-	cs42l52_early_suspend.suspend =soc_cs42l52_suspend;  
-	cs42l52_early_suspend.resume =soc_cs42l52_resume;//   cs42l52_early_suspend.level = 0x2;    
-	register_early_suspend(&cs42l52_early_suspend);
-#endif
-	return ret;
-
-card_err:
-	snd_soc_free_pcms(soc_dev);
-	snd_soc_dapm_free(soc_dev);
-pcm_err:
-	return ret;
-
-}
-
-static int soc_cs42l52_remove(struct platform_device *pdev)
-{
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-
-	snd_soc_free_pcms(socdev);
-	snd_soc_dapm_free(socdev);
-#ifdef CONFIG_HAS_EARLYSUSPEND		
-	unregister_early_suspend(&cs42l52_early_suspend);
-#endif 
-	return 0;
-}
-
-struct snd_soc_codec_device soc_codec_dev_cs42l52 = {
-	.probe = soc_cs42l52_probe,
-	.remove = soc_cs42l52_remove,
-#ifndef 	CONFIG_HAS_EARLYSUSPEND
-	.suspend = soc_cs42l52_suspend,
-	.resume = soc_cs42l52_resume,
-#endif	
-};
-
-EXPORT_SYMBOL_GPL(soc_codec_dev_cs42l52);
-
-static int __init cs42l52_modinit(void)
-{
-	return i2c_add_driver(&cs42l52_i2c_drv);
-}
-module_init(cs42l52_modinit);
-
-static void __exit cs42l52_exit(void)
-{
-	i2c_del_driver(&cs42l52_i2c_drv);
-}
-module_exit(cs42l52_exit);
-
-
-
-MODULE_DESCRIPTION("ALSA SoC CS42L52 Codec");
-MODULE_AUTHOR("Bo Liu, Bo.Liu@cirrus.com, www.cirrus.com");
-MODULE_LICENSE("GPL");
-
-
-
-
-#ifdef CONFIG_PROC_FS
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-static int proc_cs42l52_show (struct seq_file *s, void *v)
-{
-	struct snd_soc_codec *codec = cs42l52_codec;
-	int reg;
-
-	seq_printf (s, "    cs42l52 registers:\n");
-	for (reg = 0; reg < 53; reg++) {
-		if (reg%10 == 0) 
-			seq_printf (s, "\n            ");
-		seq_printf (s, "0x%02x ", soc_cs42l52_read(codec, reg));
-	}
-	seq_printf (s, "\n\n");
-
-#if 0//for check cache
-	u8 *cache = codec->reg_cache;
-	seq_printf (s, "            cache:\n");
-	for (reg = 0; reg < 53; reg++) {
-		if (reg%10 == 0) 
-			seq_printf (s, "\n            ");
-		seq_printf (s, "0x%02x ", cache[reg]);
-	}
-	seq_printf (s, "\n\n");
-#endif
-
-	return 0;
-}
-
-static int proc_cs42l52_open (struct inode *inode, struct file *file)
-{
-	return single_open (file, proc_cs42l52_show, NULL);
-}
-
-static const struct file_operations proc_cs42l52_fops = {
-	.open		= proc_cs42l52_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static int __init codec_proc_init (void)
-{
-	proc_create ("cs42l52", 0, NULL, &proc_cs42l52_fops);
-	return 0;
-}
-late_initcall (codec_proc_init);
-#endif /* CONFIG_PROC_FS */
diff --git a/sound/soc/codecs/cs42l52.h b/sound/soc/codecs/cs42l52.h
deleted file mode 100755
index 1c6568c8f25e..000000000000
--- a/sound/soc/codecs/cs42l52.h
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * cs42l52.h -- CS42L52 ALSA SoC audio driver
- *
- * Copyright 2007 CirrusLogic, Inc. 
- *
- * Author: Bo Liu <Bo.Liu@cirrus.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- * Revision history
- * Nov  2007   Initial version.
- */
-
-#ifndef __CS42L52_H__
-#define __CS42L52_H__
-
-#include <linux/types.h>
-#include <sound/pcm.h>
-
-
-#define SOC_CS42L52_NAME 		"CS42L52"
-#define SOC_CS42L52_DEFAULT_CLK		12000000
-#define SOC_CS42L52_MIN_CLK		11000000
-#define SOC_CS42L52_MAX_CLK		27000000
-#define SOC_CS42L52_DEFAULT_FORMAT 	SNDRV_PCM_FMTBIT_S16_LE
-#define SOC_CS42L52_DEFAULT_MAX_CHANS	2
-#define CS42L52_SYSCLK  		1
-
-
-#define SOC_CS42L52_CHIP_SWICTH 	(1 << 17)
-#define SOC_CS42L52_ALL_IN_ONE 		(1 << 16)
-#define SOC_CS42L52_CHIP_ONE    	0x00
-#define SOC_CS42L52_CHIP_TWO    	0x01
-#define SOC_CS42L52_CHIP_THR    	0x02
-#define SOC_CS42L52_CHIP_MASK   	0x0f
-#define CS42L52_PB_PIN_INVERRTED	(1 << 3)
-#define CS42L52_PB_PIN_LOW	0
-#define CS42L52_PB_PIN_HIGN	1
-#define CS42L52_PB_ALL_ON	2
-#define CS42L52_PB_ALL_OFF      3
-
-struct soc_codec_cs42l52 {
-	void (*machine_handler)(unsigned int codec_num);
-	u_int	max_playback_stream;
-	u_int	max_capture_stream;
-	u_int 	num_dai;
-	u_int	pb_pin_sel;
-	u_int	pb_sel;
-	u_int	adc_sel1;
-	u_int   adc_sel2;
-	u_int	mic_sel;
-	u_int	sysclk;
-	u_int	format;
-	u_int	flags;
-};
-
-struct soc_codec_cs42l52_data{
-	int i2c_bus;
-	u_short i2c_addr;
-};
-/*
- *CS42L52 internal registers
- */
-#define CODEC_CS42L52_CHIP	0x01
-#define CHIP_ID   		0xE0
-#define CHIP_ID_MASK		0xF8
-#define CHIP_REV_A0		0x00
-#define CHIP_REV_A1		0x01
-#define CHIP_REV_B0		0x02
-#define CHIP_REV_MASK		0x03
-
-#define CODEC_CS42L52_PWCTL1	0x02  //0x01
-#define PWCTL1_PDN_CHRG		(1 << 7)
-#define PWCTL1_PDN_PGAB		(1 << 4)
-#define PWCTL1_PDN_PGAB_SHIFT	4
-#define PWCTL1_PDN_PGAA   	(1 << 3)
-#define PWCTL1_PDN_PGAA_SHIFT	3
-#define PWCTL1_PDN_ADCB		(1 << 2)
-#define PWCTL1_PDN_ADCB_SHIFT	2
-#define PWCTL1_PDN_ADCA   	(1 << 1)
-#define PWCTL1_PDN_ADCA_SHIFT	1
-#define PWCTL1_PDN_CODEC	(1 << 0)
-
-#define CODEC_CS42L52_PWCTL2	0x03 //0x07
-#define PWCTL2_OVRDB		(1 << 4)
-#define PWCTL2_OVRDA		(1 << 3)
-#define	PWCTL2_PDN_MICB		(1 << 2)
-#define PWCTL2_PDN_MICB_SHIFT	2
-#define PWCTL2_PDN_MICA         (1 << 1)
-#define PWCTL2_PDN_MICA_SHIFT	1
-#define PWCTL2_PDN_MICBIAS	(1 << 0)
-#define PWCTL2_PDN_MICBIAS_SHIFT	0
-
-#define CODEC_CS42L52_PWCTL3	0x04 //0x08
-#define PWCTL3_HPB_PDN_SHIFT	6
-#define PWCTL3_HPB_ON_LOW	0x00
-#define PWCTL3_HPB_ON_HIGH	0x01
-#define PWCTL3_HPB_ALWAYS_ON	0x02
-#define PWCTL3_HPB_ALWAYS_OFF	0x03
-#define PWCTL3_HPA_PDN_SHIFT    4
-#define PWCTL3_HPA_ON_LOW       0x00
-#define PWCTL3_HPA_ON_HIGH      0x01
-#define PWCTL3_HPA_ALWAYS_ON    0x02
-#define PWCTL3_HPA_ALWAYS_OFF   0x03
-#define PWCTL3_SPKB_PDN_SHIFT   2
-#define PWCTL3_SPKB_ON_LOW       0x00
-#define PWCTL3_SPKB_ON_HIGH      0x01
-#define PWCTL3_SPKB_ALWAYS_ON    0x02
-#define PWCTL3_SPKB_ALWAYS_OFF   0x03
-#define PWCTL3_SPKA_PDN_SHIFT   0
-#define PWCTL3_SPKA_ON_LOW       0x00
-#define PWCTL3_SPKA_ON_HIGH      0x01
-#define PWCTL3_SPKA_ALWAYS_ON    0x02
-#define PWCTL3_SPKA_ALWAYS_OFF   0x03
-#define DEFAULT_OUTPUT_STATE	 0x05
-#define PWCTL3_CONF_MASK	0x03
-
-
-
-#define CODEC_CS42L52_CLK_CTL 	0x05 //0xa0
-#define CLK_CTL_AUTODECT_ENABLE	(1 << 7)
-#define CLK_CTL_SPEED_SHIFT	5
-#define CLK_CTL_S_DS_MODE	0x00
-#define CLK_CTL_S_SS_MODE	0x01
-#define CLK_CTL_S_HS_MODE	0x02
-#define CLK_CTL_S_QS_MODE 	0x03
-#define CLK_CTL_32K_SR_SHIFT	4
-#define CLK_CTL_32K_SR		1
-#define CLK_CTL_NOT_32K		0
-#define CLK_CTL_27M_MCLK_SHIFT	3
-#define CLK_CTL_27M_MCLK	1
-#define CLK_CTL_NOT_27M		0
-#define CLK_CTL_RATIO_SHIFT	1
-#define CLK_CTL_RATIO_128	0x00
-#define CLK_CTL_RATIO_125	0x01
-#define CLK_CTL_RATIO_132	0x02
-#define CLK_CTL_RATIO_136	0x03
-#define CLK_CTL_MCLKDIV2	1
-#define CLK_CTL_NOT_MCLKDIV2	0
-
-
-#define CODEC_CS42L52_IFACE_CTL1 0x06 //0
-#define IFACE_CTL1_MASTER		(1 << 7)
-#define IFACE_CTL1_INV_SCLK		(1 << 6)
-#define IFACE_CTL1_ADC_FMT_I2S		(1 << 5)
-#define IFACE_CTL1_ADC_FMT_LEFT_J 	(0 << 5)
-#define IFACE_CTL1_DSP_MODE_EN		(1 << 4)
-#define IFACE_CTL1_DAC_FMT_LEFT_J 	(0 << 2)
-#define IFACE_CTL1_DAC_FMT_I2S  	(1 << 2)
-#define IFACE_CTL1_DAC_FMT_RIGHT_J 	(2 << 2)
-#define IFACE_CTL1_WL_32BIT		(0x00)
-#define IFACE_CTL1_WL_24BIT		(0x01)
-#define IFACE_CTL1_WL_20BIT		(0x02)
-#define IFACE_CTL1_WL_16BIT		(0x03)
-#define IFACE_CTL1_WL_MASK		0xFFFF
-
-
-#define CODEC_CS42L52_IFACE_CTL2 0x07 //0
-#define IFACE_CTL2_SC_MC_EQ 		(1 << 6)
-#define IFACE_CTL2_LOOPBACK		(1 << 5)
-#define IFACE_CTL2_S_MODE_OUTPUT_EN 	(0 << 4)
-#define IFACE_CTL2_S_MODE_OUTPUT_HIZ 	(1 << 4)
-#define IFACE_CTL2_HP_SW_INV		(1 << 3)
-#define IFACE_CTL2_MIC_BIAS_5X 	0x00
-#define IFACE_CTL2_MIC_BIAS_6X  0x01
-#define IFACE_CTL2_MIC_BIAS_7X	0x02
-#define IFACE_CTL2_MIC_BIAS_8X	0x03
-#define IFACE_CTL2_MIC_BIAS_83X	0x04
-#define	IFACE_CTL2_MIC_BIAS_91X	0x05
-
-#define CODEC_CS42L52_ADC_PGA_A	0x08 //0x81
-#define CODEC_CS42L52_ADC_PGA_B 0x09 //0x81
-#define ADC_SEL_SHIFT		5
-#define PGA_SEL_SHIFT           0
-#define ADC_SEL_AIN1		0x00
-#define ADC_SEL_AIN2		0x01
-#define ADC_SEL_AIN3		0x02
-#define ADC_SEL_AIN4		0x03
-#define ADC_SEL_PGA		0x04
-#define PGA_SEL_NONE		0x00
-#define PGA_SEL_AIN1		0x01
-#define PGA_SEL_AIN2		0x02
-#define PGA_SEL_AIN3		0x04
-#define PGA_SEL_AIN4		0x08
-#define PGA_SEL_MIC		0x10
-#define PGA_SEL_MIC_AIN1	0x11
-#define PGA_SEL_MIC_AIN1_AIN2	0x13
-
-#define CODEC_CS42L52_ANALOG_HPF_CTL	0x0A //0xa5
-#define HPF_CTL_ANLGSFTB		(1 << 3)
-#define HPF_CTL_ANLGSFTA                (1 << 0)
-
-
-#define CODEC_CS42L52_ADC_HPF_FREQ	0x0B //0
-#define CODEC_CS42L52_ADC_MISC_CTL	0x0C //0
-#define ADC_MISC_CTL_SOURCE_DSP		(1 << 6)
-
-
-#define CODEC_CS42L52_PB_CTL1	0x0D //0x60
-#define PB_CTL1_HP_GAIN_SHIFT	5
-#define PB_CTL1_HP_GAIN_03959	0x00
-#define PB_CTL1_HP_GAIN_04571	0x01
-#define PB_CTL1_HP_GAIN_05111	0x02
-#define PB_CTL1_HP_GAIN_06047	0x03
-#define PB_CTL1_HP_GAIN_07099	0x04
-#define PB_CTL1_HP_GAIN_08399	0x05
-#define PB_CTL1_HP_GAIN_10000 	0x06
-#define PB_CTL1_HP_GAIN_11430	0x07
-#define PB_CTL1_INV_PCMB	(1 << 3)
-#define PB_CTL1_INV_PCMA	(1 << 2)
-#define PB_CTL1_MSTB_MUTE	(1 << 1)
-#define PB_CTL1_MSTA_MUTE	(1 << 0)
-#define PB_CTL1_MUTE_MASK	0xFFFC
-
-#define CODEC_CS42L52_MISC_CTL	0x0E //0x02
-#define MISC_CTL_DEEMPH		(1 << 2)
-#define MISC_CTL_DIGSFT		(1 << 1)
-#define MISC_CTL_DIGZC		(1 << 0)
-
-
-#define CODEC_CS42L52_PB_CTL2	0x0F //0
-#define PB_CTL2_HPB_MUTE	(1 << 7)
-#define PB_CTL2_HPA_MUTE	(1 << 6)
-#define PB_CTL2_SPKB_MUTE	(1 << 5)
-#define PB_CTL2_SPKA_MUTE	(1 << 4)
-#define PB_CTL2_SPK_SWAP	(1 << 2)
-#define PB_CTL2_SPK_MONO	(1 << 1)
-#define PB_CTL2_SPK_MUTE50	(1 << 0)
-
-#define	CODEC_CS42L52_MICA_CTL	0x10 //0
-#define CODEC_CS42L52_MICB_CTL  0x11 //0
-#define	MIC_CTL_SEL_MIC1	(0 << 6)
-#define MIC_CTL_SEL_MIC2	(1 << 6)
-#define MIC_CTL_SEL_DIFF	(1 << 5)
-
-#define CODEC_CS42L52_PGAA_CTL	0x12 //0
-#define CODEC_CS42L52_PGAB_CTL 	0x13 //0
-#define PGAX_CTL_VOL_12DB	24
-#define PGAX_CTL_VOL_6DB	12 /*step size 0.5db*/
-
-#define CODEC_CS42L52_PASSTHRUA_VOL	0x14 //0
-#define CODEC_CS42L52_PASSTHRUB_VOL     0x15 //0
-
-#define CODEC_CS42L52_ADCA_VOL	0x16 //0
-#define CODEC_CS42L52_ADCB_VOL	0x17 //0
-#define ADCX_VOL_24DB		24 /*step size 1db*/
-#define ADCX_VOL_12DB		12
-#define ADCX_VOL_6DB		6
-
-#define CODEC_CS42L52_ADCA_MIXER_VOL	0x18 // 0x80
-#define CODEC_CS42L52_ADCB_MIXER_VOL	0x19 //0x80
-#define ADC_MIXER_VOL_12DB	0x18
-
-#define CODEC_CS42L52_PCMA_MIXER_VOL	0x1A //0
-#define CODEC_CS42L52_PCMB_MIXER_VOL	0x1B //0
-
-#define CODEC_CS42L52_BEEP_FREQ	0x1C //0
-#define CODEC_CS42L52_BEEP_VOL	0x1D //0
-#define BEEP_VOL_12DB	0x06
-
-
-#define CODEC_CS42L52_BEEP_TONE_CTL	0x1E //0
-
-#define CODEC_CS42L52_TONE_CTL	0x1F //0x88
-
-#define CODEC_CS42L52_MASTERA_VOL	0x20 //0
-#define CODEC_CS42L52_MASTERB_VOL	0x21 //0
-
-#define CODEC_CS42L52_HPA_VOL	0x22 //0
-#define CODEC_CS42L52_HPB_VOL	0x23 //0
-#define DEFAULT_HP_VOL	0x00
-
-#define CODEC_CS42L52_SPKA_VOL	0x24 //0
-#define CODEC_CS42L52_SPKB_VOL	0x25 //0
-#define DEFAULT_SPK_VOL	0x00
-
-#define CODEC_CS42L52_ADC_PCM_MIXER	0x26 //0
-
-#define CODEC_CS42L52_LIMITER_CTL1	0x27 //0
-#define CODEC_CS42L52_LIMITER_CTL2	0x28 //0x7f
-#define CODEC_CS42L52_LIMITER_AT_RATE	0x29 //0xc0
-
-#define CODEC_CS42L52_ALC_CTL	0x2A //0
-#define ALC_CTL_ALCB_ENABLE	(1 << 7)
-#define ALC_CTL_ALCA_ENABLE	(1 << 6)
-#define ALC_CTL_FASTEST_ATTACK	0
-
-#define CODEC_CS42L52_ALC_RATE	0x2B //0x3f
-#define ALC_SLOWEST_RELEASE	0x3F
-
-#define CODEC_CS42L52_ALC_THRESHOLD	0x2C //0
-#define ALC_MAX_RATE_SHIFT	5
-#define ALC_MIN_RATE_SHIFT	2
-#define ALC_RATE_0DB	0
-#define ALC_RATE_3DB	1
-#define ALC_RATE_6DB	2
-
-#define CODEC_CS42L52_NOISE_GATE_CTL	0x2D //0
-#define NG_ENABLE	(1 << 6)
-#define NG_THRESHOLD_SHIFT	2
-#define NG_MIN_70DB	2
-#define NG_DELAY_SHIFT	0
-#define NG_DELAY_100MS	1
-
-#define CODEC_CS42L52_CLK_STATUS	0x2E //0
-#define CODEC_CS42L52_BATT_COMPEN	0x2F //0
-
-#define CODEC_CS42L52_BATT_LEVEL	0x30 //0
-#define CODEC_CS42L52_SPK_STATUS	0x31 //0
-#define SPK_STATUS_PIN_SHIFT		3
-#define SPK_STATUS_PIN_HIGH		1
-
-#define CODEC_CS42L52_TEM_CTL	0x32 //0x3b
-#define CODEC_CS42L52_THE_FOLDBACK	0x33 //0
-#define CODEC_CS42L52_CHARGE_PUMP	0x34 //0x5f
-
-
-#define SOC_CS42L52_REG_NUM	56
-
-extern struct snd_soc_codec_device soc_codec_dev_cs42l52;
-extern struct  snd_soc_dai soc_cs42l52_dai;
-#endif
diff --git a/sound/soc/codecs/rt5631.c b/sound/soc/codecs/rt5631.c
deleted file mode 100755
index d192bff6ee8c..000000000000
--- a/sound/soc/codecs/rt5631.c
+++ /dev/null
@@ -1,2252 +0,0 @@
-/*
- * rt5631.c  --  RT5631 ALSA Soc Audio driver
- *
- * Copyright 2011 Realtek Microelectronics
- *
- * Author: flove <flove@realtek.com>
- *
- * Based on WM8753.c
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/i2c.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dapm.h>
-#include <sound/initval.h>
-#include <sound/tlv.h>
-#include "rt5631.h"
-#include <linux/timer.h>
-
-#if 0
-#define DBG(x...)	printk(x)
-#else
-#define DBG(x...)
-#endif
-/*
-1.0.25
-     add support sample rate up to 192k
-*/
-#define RT5631_VERSION "0.01 alsa 1.0.25"
-
-#define RT5631_ALC_DAC_FUNC_ENA 0	//ALC functio for DAC
-#define RT5631_ALC_ADC_FUNC_ENA 0	//ALC function for ADC
-#define RT5631_SPK_TIMER	1	//if enable this, MUST enable RT5631_EQ_FUNC_ENA first!
-
-struct rt5631_priv {
-	int codec_version;
-	int master;
-	int sysclk;
-	int dmic_used_flag;
-	int eq_mode;
-	int pll_used_flag;
-};
-#if (RT5631_SPK_TIMER == 1)
-static struct timer_list spk_timer;
-struct work_struct  spk_work;
-//static bool last_is_spk = false;	// need modify.
-static int last_is_spk = -1;	//bard 9-13
-#endif
-
-#ifdef CONFIG_MACH_RK_FAC 
-	rt5631_hdmi_ctrl=0;
-#endif
-static struct snd_soc_codec *rt5631_codec;
-struct delayed_work rt5631_delay_cap; //bard 7-16
-EXPORT_SYMBOL(rt5631_delay_cap); //bard 7-16
-static const u16 rt5631_reg[0x80];
-static int timesofbclk = 32;
-bool isPlaybackon = false, isCaptureon = false;
-
-module_param(timesofbclk, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
-MODULE_PARM_DESC(timeofbclk, "relationship between bclk and fs");
-
-static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -9435, 37, 0);
-static inline int rt5631_write(struct snd_soc_codec *codec,
-			unsigned int reg, unsigned int val)
-{
-	return snd_soc_write(codec, reg, val);
-}
-
-static inline unsigned int rt5631_read(struct snd_soc_codec *codec,
-				unsigned int reg)
-{
-	return snd_soc_read(codec, reg);
-}
-
-static int rt5631_write_mask(struct snd_soc_codec *codec,
-	unsigned int reg, unsigned int value, unsigned int mask)
-{
-	unsigned int reg_val;
-	int ret = 0;
-
-	if (!mask)
-		return 0;
-
-	if (mask != 0xffff) {
-		reg_val = rt5631_read(codec, reg);
-		reg_val &= ~mask;
-		reg_val |= (value & mask);
-		ret = rt5631_write(codec, reg, reg_val);
-	} else {
-		ret = rt5631_write(codec, reg, value);
-	}
-
-	return ret;
-}
-
-static void rt5631_write_index(struct snd_soc_codec *codec,
-		unsigned int reg, unsigned int value)
-{
-	rt5631_write(codec, RT5631_INDEX_ADD, reg);
-	rt5631_write(codec, RT5631_INDEX_DATA, value);
-	return;
-}
-
-static unsigned int rt5631_read_index(struct snd_soc_codec *codec,
-				unsigned int reg)
-{
-	unsigned int value;
-
-	rt5631_write(codec, RT5631_INDEX_ADD, reg);
-	value = rt5631_read(codec, RT5631_INDEX_DATA);
-
-	return value;
-}
-
-static void rt5631_write_index_mask(struct snd_soc_codec *codec,
-	unsigned int reg, unsigned int value, unsigned int mask)
-{
-	unsigned int reg_val;
-
-	if (!mask)
-		return;
-
-	if (mask != 0xffff) {
-		reg_val = rt5631_read_index(codec, reg);
-		reg_val &= ~mask;
-		reg_val |= (value & mask);
-		rt5631_write_index(codec, reg, reg_val);
-	} else {
-		rt5631_write_index(codec, reg, value);
-	}
-
-	return;
-}
-
-static inline int rt5631_reset(struct snd_soc_codec *codec)
-{
-	return snd_soc_write(codec, RT5631_RESET, 0);
-}
-
-struct rt5631_init_reg {
-	u8 reg;
-	u16 val;
-};
-
-#ifndef DEF_VOL
-#define DEF_VOL					0xd4//0xd4 -30dB 0xc0 0dB
-#endif
-#ifndef DEF_VOL_SPK
-#define DEF_VOL_SPK				0xc4
-#endif
-
-/*
- * speaker channel volume select SPKMIXER, 0DB by default
- * Headphone channel volume select OUTMIXER,0DB by default
- * AXO1/AXO2 channel volume select OUTMIXER,0DB by default
- * Record Mixer source from Mic1/Mic2 by default
- * Mic1/Mic2 boost 40dB by default
- * DAC_L-->OutMixer_L by default
- * DAC_R-->OutMixer_R by default
- * DAC-->SpeakerMixer
- * Speaker volume-->SPOMixer(L-->L,R-->R)
- * Speaker AMP ratio gain is 1.44X
- * HP from OutMixer,speaker out from SpeakerOut Mixer
- * enable HP zero cross
- * change Mic1 & mic2 to differential mode
- */
-static struct rt5631_init_reg init_list[] = {
-
-	{RT5631_SPK_OUT_VOL		, (DEF_VOL_SPK<<8) | DEF_VOL_SPK},//speaker channel volume select SPKMIXER,0DB by default
-	{RT5631_HP_OUT_VOL		, (DEF_VOL<<8) | DEF_VOL},//Headphone channel volume select OUTMIXER,0DB by default
-	{RT5631_MONO_AXO_1_2_VOL	, 0xE0c0},//AXO1/AXO2 channel volume select OUTMIXER,0DB by default
-	//{RT5631_STEREO_DAC_VOL_1	, 0x004C},
-	{RT5631_STEREO_DAC_VOL_2	, 0x0303},
-	{RT5631_ADC_REC_MIXER		, 0xb0f0},//Record Mixer source from Mic1 by default
-	{RT5631_ADC_CTRL_1		, 0x0004},//STEREO ADC CONTROL 1
-	{RT5631_MIC_CTRL_2		, 0x4400},//0x8800},//0x6600}, //Mic1/Mic2 boost 40DB by default
-	{RT5631_PWR_MANAG_ADD1		, 0x93e0},
-	{RT5631_SDP_CTRL        , 0x8002},
-	//increase hpo charge pump VEE
-	{RT5631_INDEX_ADD			, 0x45},
-	{RT5631_INDEX_DATA			, 0x6530},
-	
-#if RT5631_ALC_ADC_FUNC_ENA	
-
-	{RT5631_ALC_CTRL_1		, 0x060a},//ALC CONTROL 1
-	{RT5631_ALC_CTRL_2		, 0x0002},//ALC CONTROL 2
-	{RT5631_ALC_CTRL_3		, 0xe088},//ALC CONTROL 3
-	
-#endif	
-	{RT5631_OUTMIXER_L_CTRL		, 0xdfC0},//DAC_L-->OutMixer_L by default
-	{RT5631_OUTMIXER_R_CTRL		, 0xdfC0},//DAC_R-->OutMixer_R by default
-	{RT5631_AXO1MIXER_CTRL		, 0x8840},//OutMixer_L-->AXO1Mixer by default
-	{RT5631_AXO2MIXER_CTRL		, 0x8880},//OutMixer_R-->AXO2Mixer by default
-	{RT5631_SPK_MIXER_CTRL		, 0xd8d8},//DAC-->SpeakerMixer
-	{RT5631_SPK_MONO_OUT_CTRL	, 0x0c00},//Speaker volume-->SPOMixer(L-->L,R-->R)	
-	{RT5631_GEN_PUR_CTRL_REG	, 0x4e00},//Speaker AMP ratio gain is 1.27x
-#if defined(CONFIG_ADJUST_VOL_BY_CODEC)
-	{RT5631_SPK_MONO_HP_OUT_CTRL	, 0x0000},//HP from outputmixer,speaker out from SpeakerOut Mixer	
-#else
-	{RT5631_SPK_MONO_HP_OUT_CTRL	, 0x000c},//HP from DAC,speaker out from SpeakerOut Mixer
-#endif
-	{RT5631_DEPOP_FUN_CTRL_2	, 0x8000},//HP depop by register control	
-	{RT5631_INT_ST_IRQ_CTRL_2	, 0x0f18},//enable HP zero cross	
-	{RT5631_MIC_CTRL_1		, 0x8000},//set mic 1 to differnetial mode
-	{RT5631_GPIO_CTRL		, 0x0000},//set GPIO to input pin	
-//	{RT5631_JACK_DET_CTRL		, 0x4e80},//Jack detect for GPIO,high is HP,low is speaker	
-	{RT5631_JACK_DET_CTRL		, 0x4bc0},//Jack detect for GPIO,high is speaker,low is hp	
-};
-#define RT5631_INIT_REG_LEN ARRAY_SIZE(init_list)
-
-/*
- * EQ parameter
- */
-enum {
-	NORMAL,
-	CLUB,
-	DANCE,
-	LIVE,
-	POP,
-	ROCK,
-	OPPO,
-	TREBLE,
-	BASS,
-	HFREQ,	
-	SPK_FR	
-};
-
-struct hw_eq_preset {
-	u16 type;
-	u16 value[22];
-	u16 ctrl;
-};
-
-/*
- * EQ param reg : 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
- *		0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf
- * EQ control reg : 0x6e
- */
-struct hw_eq_preset hweq_preset[] = {
-	{NORMAL	, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000, 0x0000}, 0x0000},
-	{CLUB	, {0x1C10, 0x0000, 0xC1CC, 0x1E5D, 0x0699, 0xCD48,
-		0x188D, 0x0699, 0xC3B6, 0x1CD0, 0x0699, 0x0436,
-		0x0000, 0x0000, 0x0000, 0x0000}, 0x000E},
-	{DANCE	, {0x1F2C, 0x095B, 0xC071, 0x1F95, 0x0616, 0xC96E,
-		0x1B11, 0xFC91, 0xDCF2, 0x1194, 0xFAF2, 0x0436,
-		0x0000, 0x0000, 0x0000, 0x0000}, 0x000F},
-	{LIVE	, {0x1EB5, 0xFCB6, 0xC24A, 0x1DF8, 0x0E7C, 0xC883,
-		0x1C10, 0x0699, 0xDA41, 0x1561, 0x0295, 0x0436,
-		0x0000, 0x0000, 0x0000, 0x0000}, 0x000F},
-	{POP	, {0x1EB5, 0xFCB6, 0xC1D4, 0x1E5D, 0x0E23, 0xD92E,
-		0x16E6, 0xFCB6, 0x0000, 0x0969, 0xF988, 0x0436,
-		0x0000, 0x0000, 0x0000, 0x0000}, 0x000F},
-	{ROCK	, {0x1EB5, 0xFCB6, 0xC071, 0x1F95, 0x0424, 0xC30A,
-		0x1D27, 0xF900, 0x0C5D, 0x0FC7, 0x0E23, 0x0436,
-		0x0000, 0x0000, 0x0000, 0x0000}, 0x000F},
-	{OPPO	, {0x0000, 0x0000, 0xCA4A, 0x17F8, 0x0FEC, 0xCA4A,
-		0x17F8, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000, 0x0000}, 0x000F},
-	{TREBLE	, {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x188D,
-		0x1699, 0x0000, 0x0000, 0x0000}, 0x0010},
-	{BASS	, {0x1A43, 0x0C00, 0x0000, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-		0x0000, 0x0000, 0x0000, 0x0000}, 0x0001},
-	//	{HFREQ, {0x1BBC,0x0000,0xC9A4,0x1BBC,0x0000,0x2997,0x142D,0xFCB6,0xEF01,0x1BBC,0x0000,0xE835,0x0FEC,0xC66E,0x1A29,0x1CEE},0x0014},//orig
-	//{HFREQ, {0x1BBC,0x0000,0xC9A4,0x1BBC,0x0000,0x2997,0x142D,0xFCB6,0x1E97,0x08AC,0xFCB6,0xEEA6,0x095B,0xC66E,0x1A29,0x1CEE},0x0018},//roy 20120904 
-	{HFREQ, {0x1FBC,0x1D18,0x11C1,0x0B2B,0xFF1B,0x1F8D,0x09F3,0xFB54,0xEF01,0x1BBC,0x0000,0xE835,0x2298,0xC66E,0x1A29,0x1CEE},0x0014},//roy 20120914 
-	{SPK_FR,{0x1DE4,0xF405,0xC306,0x1D60,0x01F3,0x07CA,0x12AF,0xF805,0xE904,0x1C10,0x0000,0x1C8B,0x0000,0xc5e1,0x1afb,0x1d46},0x0003},
-};
-
-static int rt5631_reg_init(struct snd_soc_codec *codec)
-{
-	int i;
-
-	for (i = 0; i < RT5631_INIT_REG_LEN; i++)
-		rt5631_write(codec, init_list[i].reg, init_list[i].val);
-
-	return 0;
-}
-//bard 7-16 s
-void rt5631_adc_on(struct work_struct *work)
-{
-	int val;
-
-	val = snd_soc_read(rt5631_codec,RT5631_ADC_REC_MIXER);
-	snd_soc_write(rt5631_codec,RT5631_ADC_REC_MIXER,0xf0f0);
-
-	snd_soc_update_bits(rt5631_codec, RT5631_PWR_MANAG_ADD1,
-		PWR_ADC_L_CLK | PWR_ADC_R_CLK, 0);
-	snd_soc_update_bits(rt5631_codec, RT5631_PWR_MANAG_ADD1,
-		PWR_ADC_L_CLK | PWR_ADC_R_CLK,
-		PWR_ADC_L_CLK | PWR_ADC_R_CLK);
-	snd_soc_write(rt5631_codec,RT5631_ADC_REC_MIXER,val);
-	snd_soc_update_bits(rt5631_codec, RT5631_ADC_CTRL_1,
-				RT_L_MUTE|RT_R_MUTE,0x0);
-
-}
-//bard 7-16 e
-static const char *rt5631_spol_source_sel[] = {
-	"SPOLMIX", "MONOIN_RX", "VDAC", "DACL"};
-static const char *rt5631_spor_source_sel[] = {
-	"SPORMIX", "MONOIN_RX", "VDAC", "DACR"};
-static const char *rt5631_mono_source_sel[] = {"MONOMIX", "MONOIN_RX", "VDAC"};
-static const char *rt5631_input_mode_source_sel[] = {
-	"Single-end", "Differential"};
-static const char *rt5631_mic_boost[] = {"Bypass", "+20db", "+24db", "+30db",
-			"+35db", "+40db", "+44db", "+50db", "+52db"};
-static const char *rt5631_hpl_source_sel[] = {"LEFT HPVOL", "LEFT DAC"};
-static const char *rt5631_hpr_source_sel[] = {"RIGHT HPVOL", "RIGHT DAC"};
-static const char *rt5631_eq_sel[] = {"NORMAL", "CLUB", "DANCE", "LIVE", "POP",
-				"ROCK", "OPPO", "TREBLE", "BASS"};
-
-
-static const struct soc_enum rt5631_enum[] = {
-SOC_ENUM_SINGLE(RT5631_SPK_MONO_HP_OUT_CTRL, 14, 4, rt5631_spol_source_sel),
-SOC_ENUM_SINGLE(RT5631_SPK_MONO_HP_OUT_CTRL, 10, 4, rt5631_spor_source_sel),
-SOC_ENUM_SINGLE(RT5631_SPK_MONO_HP_OUT_CTRL, 6, 3, rt5631_mono_source_sel),
-SOC_ENUM_SINGLE(RT5631_MIC_CTRL_1, 15, 2,  rt5631_input_mode_source_sel),
-SOC_ENUM_SINGLE(RT5631_MIC_CTRL_1, 7, 2,  rt5631_input_mode_source_sel),
-SOC_ENUM_SINGLE(RT5631_MONO_INPUT_VOL, 15, 2, rt5631_input_mode_source_sel),
-SOC_ENUM_SINGLE(RT5631_MIC_CTRL_2, 12, 9, rt5631_mic_boost),
-SOC_ENUM_SINGLE(RT5631_MIC_CTRL_2, 8, 9, rt5631_mic_boost),
-SOC_ENUM_SINGLE(RT5631_SPK_MONO_HP_OUT_CTRL, 3, 2, rt5631_hpl_source_sel),
-SOC_ENUM_SINGLE(RT5631_SPK_MONO_HP_OUT_CTRL, 2, 2, rt5631_hpr_source_sel),
-SOC_ENUM_SINGLE(0, 4, 9, rt5631_eq_sel),
-};
-
-static int rt5631_dmic_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-
-	ucontrol->value.integer.value[0] = rt5631->dmic_used_flag;
-
-	return 0;
-}
-
-static void rt5631_close_dmic(struct snd_soc_codec *codec)
-{
-	rt5631_write_mask(codec, RT5631_DIG_MIC_CTRL,
-		DMIC_L_CH_MUTE | DMIC_R_CH_MUTE,
-		DMIC_L_CH_MUTE_MASK | DMIC_R_CH_MUTE_MASK);
-	rt5631_write_mask(codec, RT5631_DIG_MIC_CTRL,
-		DMIC_DIS, DMIC_ENA_MASK);
-	return;
-}
-
-static int rt5631_dmic_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-
-	if (rt5631->dmic_used_flag == ucontrol->value.integer.value[0])
-		return 0;
-
-	if (ucontrol->value.integer.value[0]) {
-		rt5631->dmic_used_flag = 1;
-	} else {
-		rt5631_close_dmic(codec);
-		rt5631->dmic_used_flag = 0;
-	}
-
-	return 0;
-}
-
-static int rt5631_eq_sel_get(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-
-	ucontrol->value.integer.value[0] = rt5631->eq_mode;
-
-	return 0;
-}
-
-static void rt5631_update_eqmode(struct snd_soc_codec *codec, int mode)
-{
-	int i;
-
-	DBG("enter rt5631_update_eqmode=========\n");
-	if (NORMAL == mode) {
-		/* In Normal mode, the EQ parameter is cleared,
-		 * and hardware LP, BP1, BP2, BP3, HP1, HP2
-		 * block control and EQ block are disabled.
-		 */
-		for (i = RT5631_EQ_BW_LOP; i <= RT5631_EQ_HPF_GAIN; i++)
-			rt5631_write_index(codec, i,
-				hweq_preset[mode].value[i]);
-		rt5631_write_mask(codec, RT5631_EQ_CTRL, 0x0000, 0x003f);
-		rt5631_write_index_mask(codec, RT5631_EQ_PRE_VOL_CTRL
-						, 0x0000, 0x8000);
-	} else {
-		/* Fill and update EQ parameter,
-		 * and EQ block are enabled.
-		 */
-		rt5631_write_index_mask(codec, RT5631_EQ_PRE_VOL_CTRL
-						, 0x8000, 0x8000);
-		rt5631_write(codec, RT5631_EQ_CTRL,
-			hweq_preset[mode].ctrl);
-		for (i = RT5631_EQ_BW_LOP; i <= RT5631_EQ_HPF_GAIN; i++)
-			rt5631_write_index(codec, i,
-				hweq_preset[mode].value[i]);
-		rt5631_write_mask(codec, RT5631_EQ_CTRL, 0x4000, 0x4000);
-	}
-
-	return;
-}
-
-static int rt5631_eq_sel_put(struct snd_kcontrol *kcontrol,
-		struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-
-	if (rt5631->eq_mode == ucontrol->value.integer.value[0])
-		return 0;
-
-	rt5631_update_eqmode(codec, ucontrol->value.enumerated.item[0]);
-	rt5631->eq_mode = ucontrol->value.integer.value[0];
-
-	return 0;
-}
-
-#if (RT5631_SPK_TIMER == 1)
-static void spk_work_handler(struct work_struct *work)
-{
-	struct snd_soc_codec *codec = rt5631_codec;
-	int is_spk = (rt5631_read(codec, 0x4a)) & 0x04;	//detect rt5631 reg4a[3], 1'b:SPK, 0'b:HP ; //bard 9-13
-	//if(last_is_spk != is_spk)
-	//	printk("%s---%s is in use.last is %s in use\n", __FUNCTION__,is_spk?"speaker":"headphone",last_is_spk?"speaker":"headphone");
-	//printk("last_is_spk=%d is_spk=%d\n",last_is_spk,is_spk);
-	if(is_spk && (last_is_spk != is_spk)){
-		rt5631_write_index_mask(codec,0x11,0x0000,0x0007);	//0db
-		rt5631_write_index(codec,0x12,0x0003);			//0db
-		rt5631_update_eqmode(codec, SPK_FR);		// SPK is in use, enable EQ mode of SPK_FR.
-	
-
-	}else if(!is_spk && (last_is_spk != is_spk)){
-	//flove071311	rt5631_update_eqmode(codec, NORMAL);		// HP is in use, enable EQ mode of NORMAL.
-		rt5631_write_index_mask(codec,0x11,0x0002,0x0003);
-		rt5631_write_index(codec,0x12,0x0007);	
-		rt5631_update_eqmode(codec,HFREQ);		
-	}
-	last_is_spk = is_spk;
-}
-
-/* timer to judge SPK or HP in use, and handle EQ issues accordingly. */
-void spk_timer_callback(unsigned long data )
-{	
-	int ret = 0;
-
-	schedule_work(&spk_work);
-
-	//DBG("Starting timer to fire in 1000ms (%ld)\n", jiffies );
-  ret = mod_timer(&spk_timer, jiffies + msecs_to_jiffies(1000));
-  if (ret) printk("Error in mod_timer\n");
-}
-#endif
-
-static const struct snd_kcontrol_new rt5631_snd_controls[] = {
-SOC_ENUM("MIC1 Mode Control",  rt5631_enum[3]),
-SOC_ENUM("MIC1 Boost", rt5631_enum[6]),
-SOC_ENUM("MIC2 Mode Control", rt5631_enum[4]),
-SOC_ENUM("MIC2 Boost", rt5631_enum[7]),
-SOC_ENUM("MONOIN Mode Control", rt5631_enum[5]),
-SOC_DOUBLE_TLV("PCM Playback Volume", RT5631_STEREO_DAC_VOL_2, 8, 0, 255, 1, dac_vol_tlv),
-SOC_DOUBLE("PCM Playback Switch", RT5631_STEREO_DAC_VOL_1, 15, 7, 1, 1),
-SOC_DOUBLE("MONOIN_RX Capture Volume", RT5631_MONO_INPUT_VOL, 8, 0, 31, 1),
-SOC_DOUBLE("AXI Capture Volume", RT5631_AUX_IN_VOL, 8, 0, 31, 1),
-SOC_SINGLE("AXO1 Playback Switch", RT5631_MONO_AXO_1_2_VOL, 15, 1, 1),
-SOC_SINGLE("AXO2 Playback Switch", RT5631_MONO_AXO_1_2_VOL, 7, 1, 1),
-SOC_DOUBLE("OUTVOL Playback Volume", RT5631_MONO_AXO_1_2_VOL, 8, 0, 31, 1),
-SOC_DOUBLE("Speaker Playback Switch", RT5631_SPK_OUT_VOL, 15, 7, 1, 1),
-SOC_DOUBLE("Speaker Playback Volume", RT5631_SPK_OUT_VOL, 8, 0, 63, 1),
-SOC_SINGLE("MONO Playback Switch", RT5631_MONO_AXO_1_2_VOL, 13, 1, 1),
-SOC_DOUBLE("HP Playback Switch", RT5631_HP_OUT_VOL, 15, 7, 1, 1),
-SOC_DOUBLE("HP Playback Volume", RT5631_HP_OUT_VOL, 8, 0, 63, 1),
-SOC_SINGLE_EXT("DMIC Capture Switch", 0, 2, 1, 0,
-	rt5631_dmic_get, rt5631_dmic_put),
-SOC_ENUM_EXT("EQ Mode", rt5631_enum[10], rt5631_eq_sel_get, rt5631_eq_sel_put),
-};
-
-static const struct snd_kcontrol_new rt5631_recmixl_mixer_controls[] = {
-SOC_DAPM_SINGLE("OUTMIXL Capture Switch", RT5631_ADC_REC_MIXER, 15, 1, 1),
-SOC_DAPM_SINGLE("MIC1_BST1 Capture Switch", RT5631_ADC_REC_MIXER, 14, 1, 1),
-SOC_DAPM_SINGLE("AXILVOL Capture Switch", RT5631_ADC_REC_MIXER, 13, 1, 1),
-SOC_DAPM_SINGLE("MONOIN_RX Capture Switch", RT5631_ADC_REC_MIXER, 12, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_recmixr_mixer_controls[] = {
-SOC_DAPM_SINGLE("MONOIN_RX Capture Switch", RT5631_ADC_REC_MIXER, 4, 1, 1),
-SOC_DAPM_SINGLE("AXIRVOL Capture Switch", RT5631_ADC_REC_MIXER, 5, 1, 1),
-SOC_DAPM_SINGLE("MIC2_BST2 Capture Switch", RT5631_ADC_REC_MIXER, 6, 1, 1),
-SOC_DAPM_SINGLE("OUTMIXR Capture Switch", RT5631_ADC_REC_MIXER, 7, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_spkmixl_mixer_controls[] = {
-SOC_DAPM_SINGLE("RECMIXL Playback Switch", RT5631_SPK_MIXER_CTRL, 15, 1, 1),
-SOC_DAPM_SINGLE("MIC1_P Playback Switch", RT5631_SPK_MIXER_CTRL, 14, 1, 1),
-SOC_DAPM_SINGLE("DACL Playback Switch", RT5631_SPK_MIXER_CTRL, 13, 1, 1),
-SOC_DAPM_SINGLE("OUTMIXL Playback Switch", RT5631_SPK_MIXER_CTRL, 12, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_spkmixr_mixer_controls[] = {
-SOC_DAPM_SINGLE("OUTMIXR Playback Switch", RT5631_SPK_MIXER_CTRL, 4, 1, 1),
-SOC_DAPM_SINGLE("DACR Playback Switch", RT5631_SPK_MIXER_CTRL, 5, 1, 1),
-SOC_DAPM_SINGLE("MIC2_P Playback Switch", RT5631_SPK_MIXER_CTRL, 6, 1, 1),
-SOC_DAPM_SINGLE("RECMIXR Playback Switch", RT5631_SPK_MIXER_CTRL, 7, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_outmixl_mixer_controls[] = {
-SOC_DAPM_SINGLE("RECMIXL Playback Switch", RT5631_OUTMIXER_L_CTRL, 15, 1, 1),
-SOC_DAPM_SINGLE("RECMIXR Playback Switch", RT5631_OUTMIXER_L_CTRL, 14, 1, 1),
-SOC_DAPM_SINGLE("DACL Playback Switch", RT5631_OUTMIXER_L_CTRL, 13, 1, 1),
-SOC_DAPM_SINGLE("MIC1_BST1 Playback Switch", RT5631_OUTMIXER_L_CTRL, 12, 1, 1),
-SOC_DAPM_SINGLE("MIC2_BST2 Playback Switch", RT5631_OUTMIXER_L_CTRL, 11, 1, 1),
-SOC_DAPM_SINGLE("MONOIN_RXP Playback Switch", RT5631_OUTMIXER_L_CTRL, 10, 1, 1),
-SOC_DAPM_SINGLE("AXILVOL Playback Switch", RT5631_OUTMIXER_L_CTRL, 9, 1, 1),
-SOC_DAPM_SINGLE("AXIRVOL Playback Switch", RT5631_OUTMIXER_L_CTRL, 8, 1, 1),
-SOC_DAPM_SINGLE("VDAC Playback Switch", RT5631_OUTMIXER_L_CTRL, 7, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_outmixr_mixer_controls[] = {
-SOC_DAPM_SINGLE("VDAC Playback Switch", RT5631_OUTMIXER_R_CTRL, 7, 1, 1),
-SOC_DAPM_SINGLE("AXIRVOL Playback Switch", RT5631_OUTMIXER_R_CTRL, 8, 1, 1),
-SOC_DAPM_SINGLE("AXILVOL Playback Switch", RT5631_OUTMIXER_R_CTRL, 9, 1, 1),
-SOC_DAPM_SINGLE("MONOIN_RXN Playback Switch", RT5631_OUTMIXER_R_CTRL, 10, 1, 1),
-SOC_DAPM_SINGLE("MIC2_BST2 Playback Switch", RT5631_OUTMIXER_R_CTRL, 11, 1, 1),
-SOC_DAPM_SINGLE("MIC1_BST1 Playback Switch", RT5631_OUTMIXER_R_CTRL, 12, 1, 1),
-SOC_DAPM_SINGLE("DACR Playback Switch", RT5631_OUTMIXER_R_CTRL, 13, 1, 1),
-SOC_DAPM_SINGLE("RECMIXR Playback Switch", RT5631_OUTMIXER_R_CTRL, 14, 1, 1),
-SOC_DAPM_SINGLE("RECMIXL Playback Switch", RT5631_OUTMIXER_R_CTRL, 15, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_AXO1MIX_mixer_controls[] = {
-SOC_DAPM_SINGLE("MIC1_BST1 Playback Switch", RT5631_AXO1MIXER_CTRL, 15 , 1, 1),
-SOC_DAPM_SINGLE("MIC2_BST2 Playback Switch", RT5631_AXO1MIXER_CTRL, 11, 1, 1),
-SOC_DAPM_SINGLE("OUTVOLL Playback Switch", RT5631_AXO1MIXER_CTRL, 7 , 1 , 1),
-SOC_DAPM_SINGLE("OUTVOLR Playback Switch", RT5631_AXO1MIXER_CTRL, 6, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_AXO2MIX_mixer_controls[] = {
-SOC_DAPM_SINGLE("MIC1_BST1 Playback Switch", RT5631_AXO2MIXER_CTRL, 15, 1, 1),
-SOC_DAPM_SINGLE("MIC2_BST2 Playback Switch", RT5631_AXO2MIXER_CTRL, 11, 1, 1),
-SOC_DAPM_SINGLE("OUTVOLL Playback Switch", RT5631_AXO2MIXER_CTRL, 7, 1, 1),
-SOC_DAPM_SINGLE("OUTVOLR Playback Switch", RT5631_AXO2MIXER_CTRL, 6, 1 , 1),
-};
-
-static const struct snd_kcontrol_new rt5631_spolmix_mixer_controls[] = {
-SOC_DAPM_SINGLE("SPKVOLL Playback Switch", RT5631_SPK_MONO_OUT_CTRL, 15, 1, 1),
-SOC_DAPM_SINGLE("SPKVOLR Playback Switch", RT5631_SPK_MONO_OUT_CTRL, 14, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_spormix_mixer_controls[] = {
-SOC_DAPM_SINGLE("SPKVOLL Playback Switch", RT5631_SPK_MONO_OUT_CTRL, 13, 1, 1),
-SOC_DAPM_SINGLE("SPKVOLR Playback Switch", RT5631_SPK_MONO_OUT_CTRL, 12, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_monomix_mixer_controls[] = {
-SOC_DAPM_SINGLE("OUTVOLL Playback Switch", RT5631_SPK_MONO_OUT_CTRL, 11, 1, 1),
-SOC_DAPM_SINGLE("OUTVOLR Playback Switch", RT5631_SPK_MONO_OUT_CTRL, 10, 1, 1),
-};
-
-static const struct snd_kcontrol_new rt5631_spol_mux_control =
-SOC_DAPM_ENUM("Route", rt5631_enum[0]);
-static const struct snd_kcontrol_new rt5631_spor_mux_control =
-SOC_DAPM_ENUM("Route", rt5631_enum[1]);
-static const struct snd_kcontrol_new rt5631_mono_mux_control =
-SOC_DAPM_ENUM("Route", rt5631_enum[2]);
-
-static const struct snd_kcontrol_new rt5631_hpl_mux_control =
-SOC_DAPM_ENUM("Route", rt5631_enum[8]);
-static const struct snd_kcontrol_new rt5631_hpr_mux_control =
-SOC_DAPM_ENUM("Route", rt5631_enum[9]);
-
-//ALC for DAC function
-#if (RT5631_ALC_DAC_FUNC_ENA == 1)
-static void rt5631_alc_enable(struct snd_soc_codec *codec,unsigned int EnableALC)
-{
-	if(EnableALC)
-	{
-		rt5631_write(codec, 0x64,0x0206);
-		rt5631_write(codec, 0x65,0x0003);
-		rt5631_write_index(codec, 0x21,0x5000);
-		rt5631_write_index(codec, 0x22,0xa480);
-		rt5631_write_index(codec, 0x23,0x0a08);
-		rt5631_write(codec, 0x0c,0x0010);
-		rt5631_write(codec, 0x66,0x650a);
-		
-	}
-	else
-	{
-		rt5631_write(codec, 0x66,0x250A);
-		rt5631_write(codec, 0x0c,0x0000);		
-	}	
-	
-}
-#endif
-
-static int spk_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	static int spkl_out_enable, spkr_out_enable;
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-
-#if (RT5631_ALC_DAC_FUNC_ENA == 1)		
-	       rt5631_alc_enable(codec, 1);
-#endif		
-
-		if (!spkl_out_enable && !strcmp(w->name, "SPKL Amp")) {
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD4,
-					PWR_SPK_L_VOL, PWR_SPK_L_VOL);
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD1,
-					PWR_CLASS_D, PWR_CLASS_D);
-			rt5631_write_mask(codec, RT5631_SPK_OUT_VOL,
-					0, RT_L_MUTE);
-			spkl_out_enable = 1;
-		}
-		if (!spkr_out_enable && !strcmp(w->name, "SPKR Amp")) {
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD4,
-					PWR_SPK_R_VOL, PWR_SPK_R_VOL);
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD1,
-					PWR_CLASS_D, PWR_CLASS_D);
-			rt5631_write_mask(codec, RT5631_SPK_OUT_VOL,
-					0, RT_R_MUTE);
-			spkr_out_enable = 1;
-		}
-		break;
-
-	case SND_SOC_DAPM_POST_PMD:
-		if (spkl_out_enable && !strcmp(w->name, "SPKL Amp")) {
-			rt5631_write_mask(codec, RT5631_SPK_OUT_VOL,
-					RT_L_MUTE, RT_L_MUTE);
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD4,
-					0, PWR_SPK_L_VOL);
-			spkl_out_enable = 0;
-		}
-		if (spkr_out_enable && !strcmp(w->name, "SPKR Amp")) {
-			rt5631_write_mask(codec, RT5631_SPK_OUT_VOL,
-					RT_R_MUTE, RT_R_MUTE);
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD4,
-					0, PWR_SPK_R_VOL);
-			spkr_out_enable = 0;
-		}
-		if (0 == spkl_out_enable && 0 == spkr_out_enable)
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD1,
-					0, PWR_CLASS_D);
-
-#if (RT5631_ALC_DAC_FUNC_ENA == 1)			
-		rt5631_alc_enable(codec, 0);
-#endif
-
-		break;
-
-	default:
-		return 0;
-	}
-
-	return 0;
-}
-
-
-static void hp_depop_mode2_onebit(struct snd_soc_codec *codec, int enable)
-{
-	unsigned int soft_vol, hp_zc;
-
-	rt5631_write_mask(codec, RT5631_DEPOP_FUN_CTRL_2, 0, EN_ONE_BIT_DEPOP);
-
-	soft_vol = rt5631_read(codec, RT5631_SOFT_VOL_CTRL);
-	rt5631_write(codec, RT5631_SOFT_VOL_CTRL, 0);
-	hp_zc = rt5631_read(codec, RT5631_INT_ST_IRQ_CTRL_2);
-	rt5631_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);
-	if (enable) {
-		rt5631_write_index(codec, RT5631_TEST_MODE_CTRL, 0x84c0);
-		rt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x309f);
-		rt5631_write_index(codec, RT5631_CP_INTL_REG2, 0x6530);
-		rt5631_write(codec, RT5631_DEPOP_FUN_CTRL_2,
-				EN_CAP_FREE_DEPOP);
-	} else {
-		rt5631_write(codec, RT5631_DEPOP_FUN_CTRL_2, 0);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(100));
-	}
-
-	rt5631_write(codec, RT5631_SOFT_VOL_CTRL, soft_vol);
-	rt5631_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc);
-
-	return;
-}
-
-static void hp_mute_unmute_depop_onebit(struct snd_soc_codec *codec, int enable)
-{
-	unsigned int soft_vol, hp_zc;
-
-	rt5631_write_mask(codec, RT5631_DEPOP_FUN_CTRL_2, 0, EN_ONE_BIT_DEPOP);
-	soft_vol = rt5631_read(codec, RT5631_SOFT_VOL_CTRL);
-	rt5631_write(codec, RT5631_SOFT_VOL_CTRL, 0);
-	hp_zc = rt5631_read(codec, RT5631_INT_ST_IRQ_CTRL_2);
-	rt5631_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);
-	if (enable) {
-		schedule_timeout_uninterruptible(msecs_to_jiffies(10));
-		rt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x307f);
-		rt5631_write_mask(codec, RT5631_HP_OUT_VOL, 0,
-				RT_L_MUTE | RT_R_MUTE);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(300));
-
-	} else {
-		rt5631_write_mask(codec, RT5631_HP_OUT_VOL,
-			RT_L_MUTE | RT_R_MUTE, RT_L_MUTE | RT_R_MUTE);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(100));
-	}
-	rt5631_write(codec, RT5631_SOFT_VOL_CTRL, soft_vol);
-	rt5631_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc);
-
-	return;
-}
-
-static void hp_depop2(struct snd_soc_codec *codec, int enable)
-{
-	unsigned int soft_vol, hp_zc;
-
-	rt5631_write_mask(codec, RT5631_DEPOP_FUN_CTRL_2,
-		EN_ONE_BIT_DEPOP, EN_ONE_BIT_DEPOP);
-	soft_vol = rt5631_read(codec, RT5631_SOFT_VOL_CTRL);
-	rt5631_write(codec, RT5631_SOFT_VOL_CTRL, 0);
-	hp_zc = rt5631_read(codec, RT5631_INT_ST_IRQ_CTRL_2);
-	rt5631_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);
-	if (enable) {
-		rt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x303e);
-		rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3,
-			PWR_CHARGE_PUMP | PWR_HP_L_AMP | PWR_HP_R_AMP,
-			PWR_CHARGE_PUMP | PWR_HP_L_AMP | PWR_HP_R_AMP);
-		rt5631_write(codec, RT5631_DEPOP_FUN_CTRL_1,
-			POW_ON_SOFT_GEN | EN_DEPOP2_FOR_HP);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(100));
-		rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3,
-			PWR_HP_DEPOP_DIS, PWR_HP_DEPOP_DIS);
-	} else {
-		rt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x303F);
-		rt5631_write(codec, RT5631_DEPOP_FUN_CTRL_1,
-			POW_ON_SOFT_GEN | EN_MUTE_UNMUTE_DEPOP |
-			PD_HPAMP_L_ST_UP | PD_HPAMP_R_ST_UP);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(75));
-		rt5631_write(codec, RT5631_DEPOP_FUN_CTRL_1,
-			POW_ON_SOFT_GEN | PD_HPAMP_L_ST_UP | PD_HPAMP_R_ST_UP);
-		rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3, 0,
-					PWR_HP_DEPOP_DIS);
-		rt5631_write(codec, RT5631_DEPOP_FUN_CTRL_1,
-			POW_ON_SOFT_GEN | EN_DEPOP2_FOR_HP |
-			PD_HPAMP_L_ST_UP | PD_HPAMP_R_ST_UP);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(80));
-		rt5631_write(codec, RT5631_DEPOP_FUN_CTRL_1, POW_ON_SOFT_GEN);
-		rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3, 0,
-			PWR_CHARGE_PUMP | PWR_HP_L_AMP | PWR_HP_R_AMP);
-	}
-
-	rt5631_write(codec, RT5631_SOFT_VOL_CTRL, soft_vol);
-	rt5631_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc);
-
-	return;
-}
-
-static void hp_mute_unmute_depop(struct snd_soc_codec *codec, int enable)
-{
-	unsigned int soft_vol, hp_zc;
-
-	rt5631_write_mask(codec, RT5631_DEPOP_FUN_CTRL_2,
-		EN_ONE_BIT_DEPOP, EN_ONE_BIT_DEPOP);
-	soft_vol = rt5631_read(codec, RT5631_SOFT_VOL_CTRL);
-	rt5631_write(codec, RT5631_SOFT_VOL_CTRL, 0);
-	hp_zc = rt5631_read(codec, RT5631_INT_ST_IRQ_CTRL_2);
-	rt5631_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);
-	if (enable) {
-		schedule_timeout_uninterruptible(msecs_to_jiffies(10));
-		rt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x302f);
-		rt5631_write(codec, RT5631_DEPOP_FUN_CTRL_1,
-			POW_ON_SOFT_GEN | EN_MUTE_UNMUTE_DEPOP |
-			EN_HP_R_M_UN_MUTE_DEPOP | EN_HP_L_M_UN_MUTE_DEPOP);
-		rt5631_write_mask(codec, RT5631_HP_OUT_VOL, 0,
-				RT_L_MUTE | RT_R_MUTE);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(160));
-	} else {
-		rt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x302f);
-		rt5631_write(codec, RT5631_DEPOP_FUN_CTRL_1,
-			POW_ON_SOFT_GEN | EN_MUTE_UNMUTE_DEPOP |
-			EN_HP_R_M_UN_MUTE_DEPOP | EN_HP_L_M_UN_MUTE_DEPOP);
-		rt5631_write_mask(codec, RT5631_HP_OUT_VOL,
-			RT_L_MUTE | RT_R_MUTE, RT_L_MUTE | RT_R_MUTE);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(150));
-	}
-
-	rt5631_write(codec, RT5631_SOFT_VOL_CTRL, soft_vol);
-	rt5631_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc);
-
-	return;
-}
-
-static int hp_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-	static bool hp_en;
-	int pu_l, pu_r;
-
-	pu_l = rt5631_read(codec, RT5631_PWR_MANAG_ADD4) & PWR_HP_L_OUT_VOL;
-	pu_r = rt5631_read(codec, RT5631_PWR_MANAG_ADD4) & PWR_HP_R_OUT_VOL;
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMD:
-		if ((pu_l && pu_r) && hp_en) {
-			if (rt5631->codec_version) {
-				hp_mute_unmute_depop_onebit(codec, 0);
-				hp_depop_mode2_onebit(codec, 0);
-			} else {
-				hp_mute_unmute_depop(codec, 0);
-				hp_depop2(codec, 0);
-			}
-			hp_en = false;
-		}
-		break;
-
-	case SND_SOC_DAPM_POST_PMU:
-		if ((pu_l && pu_r) && !hp_en) {
-			if (rt5631->codec_version) {
-				hp_depop_mode2_onebit(codec, 1);
-				hp_mute_unmute_depop_onebit(codec, 1);
-			} else {
-				hp_depop2(codec, 1);
-				hp_mute_unmute_depop(codec, 1);
-			}
-			hp_en = true;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int dac_to_hp_event(struct snd_soc_dapm_widget *w,
-		struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-	static bool hp_en;
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMD:
-		if (hp_en) {
-			if (rt5631->codec_version) {
-				hp_mute_unmute_depop_onebit(codec, 0);
-				hp_depop_mode2_onebit(codec, 0);
-			} else {
-				hp_mute_unmute_depop(codec, 0);
-				hp_depop2(codec, 0);
-			}
-			hp_en = false;
-		}
-		break;
-
-	case SND_SOC_DAPM_POST_PMU:
-		if (!hp_en) {
-			if (rt5631->codec_version) {
-				hp_depop_mode2_onebit(codec, 1);
-				hp_mute_unmute_depop_onebit(codec, 1);
-			} else {
-				hp_depop2(codec, 1);
-				hp_mute_unmute_depop(codec, 1);
-			}
-			hp_en = true;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int mic_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	int val_mic1, val_mic2;
-
-	val_mic1 = rt5631_read(codec, RT5631_PWR_MANAG_ADD2) &
-				PWR_MIC1_BOOT_GAIN;
-	val_mic2 = rt5631_read(codec, RT5631_PWR_MANAG_ADD2) &
-				PWR_MIC2_BOOT_GAIN;
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		/*
-		 * If microphone is stereo, need not copy ADC channel
-		 * If mic1 is used, copy ADC left to right
-		 * If mic2 is used, copy ADC right to left
-		 */
-		if (val_mic1 && val_mic2)
-			rt5631_write_mask(codec, RT5631_INT_ST_IRQ_CTRL_2,
-							0x0000, 0xc000);
-		else if (val_mic1)
-			rt5631_write_mask(codec, RT5631_INT_ST_IRQ_CTRL_2,
-							0x4000, 0xc000);
-		else if (val_mic2)
-			rt5631_write_mask(codec, RT5631_INT_ST_IRQ_CTRL_2,
-							0x8000, 0xc000);
-		else
-			rt5631_write_mask(codec, RT5631_INT_ST_IRQ_CTRL_2,
-							0x0000, 0xc000);
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int auxo1_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	static bool aux1_en;
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMD:
-		if (aux1_en) {
-			rt5631_write_mask(codec, RT5631_MONO_AXO_1_2_VOL,
-						RT_L_MUTE, RT_L_MUTE);
-			aux1_en = false;
-		}
-		break;
-
-	case SND_SOC_DAPM_POST_PMU:
-		if (!aux1_en) {
-			rt5631_write_mask(codec, RT5631_MONO_AXO_1_2_VOL,
-						0, RT_L_MUTE);
-			aux1_en = true;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int auxo2_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	static bool aux2_en;
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMD:
-		if (aux2_en) {
-			rt5631_write_mask(codec, RT5631_MONO_AXO_1_2_VOL,
-						RT_R_MUTE, RT_R_MUTE);
-			aux2_en = false;
-		}
-		break;
-
-	case SND_SOC_DAPM_POST_PMU:
-		if (!aux2_en) {
-			rt5631_write_mask(codec, RT5631_MONO_AXO_1_2_VOL,
-						0, RT_R_MUTE);
-			aux2_en = true;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int mono_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	static bool mono_en;
-
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMD:
-		if (mono_en) {
-			rt5631_write_mask(codec, RT5631_MONO_AXO_1_2_VOL,
-						MUTE_MONO, MUTE_MONO);
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3,
-						0, PWR_MONO_DEPOP_DIS);
-			mono_en = false;
-		}
-		break;
-
-	case SND_SOC_DAPM_POST_PMU:
-		if (!mono_en) {
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3,
-				PWR_MONO_DEPOP_DIS, PWR_MONO_DEPOP_DIS);
-			rt5631_write_mask(codec, RT5631_MONO_AXO_1_2_VOL,
-						0, MUTE_MONO);
-			mono_en = true;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-/**
- * config_common_power - control all common power of codec system
- * @pmu: power up or not
- */
-static int config_common_power(struct snd_soc_codec *codec, bool pmu)
-{
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-	unsigned int mux_val;
-
-	if (pmu) {
-		rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD1,
-			PWR_MAIN_I2S_EN | PWR_DAC_REF,
-			PWR_MAIN_I2S_EN | PWR_DAC_REF);
-		mux_val = rt5631_read(codec, RT5631_SPK_MONO_HP_OUT_CTRL);
-		//if (!(mux_val & HP_L_MUX_SEL_DAC_L))
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD1,
-				PWR_DAC_L_TO_MIXER, PWR_DAC_L_TO_MIXER);
-		//if (!(mux_val & HP_R_MUX_SEL_DAC_R))
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD1,
-				PWR_DAC_R_TO_MIXER, PWR_DAC_R_TO_MIXER);
-		if (rt5631->pll_used_flag)
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD2,
-						PWR_PLL, PWR_PLL);
-	} else if (isPlaybackon == false && isCaptureon == false){
-		rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD1, 0,
-			PWR_MAIN_I2S_EN | PWR_DAC_REF |
-			PWR_DAC_L_TO_MIXER | PWR_DAC_R_TO_MIXER);
-		if (rt5631->pll_used_flag)
-			rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD2,
-						0, PWR_PLL);
-	}
-
-	return 0;
-}
-
-static int adc_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	static bool pmu;
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMD:
-		if (pmu) {
-			isPlaybackon = false;
-			config_common_power(codec, false);
-			pmu = false;
-		}
-		break;
-
-	case SND_SOC_DAPM_PRE_PMU:
-		if (!pmu) {
-			isPlaybackon = true;
-			config_common_power(codec, true);
-			pmu = true;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int dac_event(struct snd_soc_dapm_widget *w,
-	struct snd_kcontrol *kcontrol, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	static bool pmu;
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMD:
-		if (pmu) {
-			isCaptureon = false;
-			config_common_power(codec, false);
-			pmu = false;
-		}
-		break;
-
-	case SND_SOC_DAPM_PRE_PMU:
-		if (!pmu) {
-			isCaptureon = true;
-			config_common_power(codec, true);
-			pmu = true;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static const struct snd_soc_dapm_widget rt5631_dapm_widgets[] = {
-SND_SOC_DAPM_INPUT("MIC1"),
-SND_SOC_DAPM_INPUT("MIC2"),
-SND_SOC_DAPM_INPUT("AXIL"),
-SND_SOC_DAPM_INPUT("AXIR"),
-SND_SOC_DAPM_INPUT("MONOIN_RXN"),
-SND_SOC_DAPM_INPUT("MONOIN_RXP"),
-
-SND_SOC_DAPM_MICBIAS("Mic Bias1", RT5631_PWR_MANAG_ADD2, 3, 0),
-SND_SOC_DAPM_MICBIAS("Mic Bias2", RT5631_PWR_MANAG_ADD2, 2, 0),
-
-SND_SOC_DAPM_PGA_E("Mic1 Boost", RT5631_PWR_MANAG_ADD2, 5, 0, NULL, 0,
-		mic_event, SND_SOC_DAPM_POST_PMU),
-SND_SOC_DAPM_PGA_E("Mic2 Boost", RT5631_PWR_MANAG_ADD2, 4, 0, NULL, 0,
-		mic_event, SND_SOC_DAPM_POST_PMU),
-SND_SOC_DAPM_PGA("MONOIN_RXP Boost", RT5631_PWR_MANAG_ADD4, 7, 0, NULL, 0),
-SND_SOC_DAPM_PGA("MONOIN_RXN Boost", RT5631_PWR_MANAG_ADD4, 6, 0, NULL, 0),
-SND_SOC_DAPM_PGA("AXIL Boost", RT5631_PWR_MANAG_ADD4, 9, 0, NULL, 0),
-SND_SOC_DAPM_PGA("AXIR Boost", RT5631_PWR_MANAG_ADD4, 8, 0, NULL, 0),
-SND_SOC_DAPM_MIXER("MONO_IN", SND_SOC_NOPM, 0, 0, NULL, 0),
-
-SND_SOC_DAPM_MIXER("RECMIXL Mixer", RT5631_PWR_MANAG_ADD2, 11, 0,
-		&rt5631_recmixl_mixer_controls[0],
-		ARRAY_SIZE(rt5631_recmixl_mixer_controls)),
-SND_SOC_DAPM_MIXER("RECMIXR Mixer", RT5631_PWR_MANAG_ADD2, 10, 0,
-		&rt5631_recmixr_mixer_controls[0],
-		ARRAY_SIZE(rt5631_recmixr_mixer_controls)),
-SND_SOC_DAPM_MIXER("ADC Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
-
-SND_SOC_DAPM_ADC_E("Left ADC", "Left ADC HIFI Capture",
-		RT5631_PWR_MANAG_ADD1, 11, 0,
-		adc_event, SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_PRE_PMU),
-SND_SOC_DAPM_ADC_E("Right ADC", "Right ADC HIFI Capture",
-		RT5631_PWR_MANAG_ADD1, 10, 0,
-		adc_event, SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_PRE_PMU),
-SND_SOC_DAPM_DAC_E("Left DAC", "Left DAC HIFI Playback",
-		RT5631_PWR_MANAG_ADD1, 9, 0,
-		dac_event, SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_PRE_PMU),
-SND_SOC_DAPM_DAC_E("Right DAC", "Right DAC HIFI Playback",
-		RT5631_PWR_MANAG_ADD1, 8, 0,
-		dac_event, SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_PRE_PMU),
-SND_SOC_DAPM_DAC("Voice DAC", "Voice DAC Mono Playback", SND_SOC_NOPM, 0, 0),
-SND_SOC_DAPM_PGA("Voice DAC Boost", SND_SOC_NOPM, 0, 0, NULL, 0),
-
-SND_SOC_DAPM_MIXER("SPKMIXL Mixer", RT5631_PWR_MANAG_ADD2, 13, 0,
-		&rt5631_spkmixl_mixer_controls[0],
-		ARRAY_SIZE(rt5631_spkmixl_mixer_controls)),
-SND_SOC_DAPM_MIXER("OUTMIXL Mixer", RT5631_PWR_MANAG_ADD2, 15, 0,
-		&rt5631_outmixl_mixer_controls[0],
-		ARRAY_SIZE(rt5631_outmixl_mixer_controls)),
-SND_SOC_DAPM_MIXER("OUTMIXR Mixer", RT5631_PWR_MANAG_ADD2, 14, 0,
-		&rt5631_outmixr_mixer_controls[0],
-		ARRAY_SIZE(rt5631_outmixr_mixer_controls)),
-SND_SOC_DAPM_MIXER("SPKMIXR Mixer", RT5631_PWR_MANAG_ADD2, 12, 0,
-		&rt5631_spkmixr_mixer_controls[0],
-		ARRAY_SIZE(rt5631_spkmixr_mixer_controls)),
-
-SND_SOC_DAPM_PGA("Left SPK Vol", RT5631_PWR_MANAG_ADD4, 15, 0, NULL, 0),
-SND_SOC_DAPM_PGA("Right SPK Vol", RT5631_PWR_MANAG_ADD4, 14, 0, NULL, 0),
-SND_SOC_DAPM_PGA_E("Left HP Vol", RT5631_PWR_MANAG_ADD4, 11, 0, NULL, 0,
-		hp_event, SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
-SND_SOC_DAPM_PGA_E("Right HP Vol", RT5631_PWR_MANAG_ADD4, 10, 0, NULL, 0,
-		hp_event, SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
-
-SND_SOC_DAPM_PGA_E("Left DAC_HP", SND_SOC_NOPM, 0, 0, NULL, 0,
-	dac_to_hp_event, SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
-SND_SOC_DAPM_PGA_E("Right DAC_HP", SND_SOC_NOPM, 0, 0, NULL, 0,
-	dac_to_hp_event, SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
-
-SND_SOC_DAPM_PGA("Left Out Vol", RT5631_PWR_MANAG_ADD4, 13, 0, NULL, 0),
-SND_SOC_DAPM_PGA("Right Out Vol", RT5631_PWR_MANAG_ADD4, 12, 0, NULL, 0),
-
-SND_SOC_DAPM_MIXER_E("AXO1MIX Mixer", RT5631_PWR_MANAG_ADD3, 11, 0,
-		&rt5631_AXO1MIX_mixer_controls[0],
-		ARRAY_SIZE(rt5631_AXO1MIX_mixer_controls),
-		auxo1_event, SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
-SND_SOC_DAPM_MIXER("SPOLMIX Mixer", SND_SOC_NOPM, 0, 0,
-		&rt5631_spolmix_mixer_controls[0],
-		ARRAY_SIZE(rt5631_spolmix_mixer_controls)),
-SND_SOC_DAPM_MIXER("MONOMIX Mixer", RT5631_PWR_MANAG_ADD3, 9, 0,
-		&rt5631_monomix_mixer_controls[0],
-		ARRAY_SIZE(rt5631_monomix_mixer_controls)),
-SND_SOC_DAPM_MIXER("SPORMIX Mixer", SND_SOC_NOPM, 0, 0,
-		&rt5631_spormix_mixer_controls[0],
-		ARRAY_SIZE(rt5631_spormix_mixer_controls)),
-SND_SOC_DAPM_MIXER_E("AXO2MIX Mixer", RT5631_PWR_MANAG_ADD3, 10, 0,
-		&rt5631_AXO2MIX_mixer_controls[0],
-		ARRAY_SIZE(rt5631_AXO2MIX_mixer_controls),
-		auxo2_event, SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
-
-SND_SOC_DAPM_MUX("SPOL Mux", SND_SOC_NOPM, 0, 0, &rt5631_spol_mux_control),
-SND_SOC_DAPM_MUX("SPOR Mux", SND_SOC_NOPM, 0, 0, &rt5631_spor_mux_control),
-SND_SOC_DAPM_MUX("Mono Mux", SND_SOC_NOPM, 0, 0, &rt5631_mono_mux_control),
-SND_SOC_DAPM_MUX("HPL Mux", SND_SOC_NOPM, 0, 0, &rt5631_hpl_mux_control),
-SND_SOC_DAPM_MUX("HPR Mux", SND_SOC_NOPM, 0, 0, &rt5631_hpr_mux_control),
-
-SND_SOC_DAPM_PGA_E("Mono Amp", RT5631_PWR_MANAG_ADD3, 7, 0, NULL, 0,
-		mono_event, SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
-SND_SOC_DAPM_PGA_E("SPKL Amp", SND_SOC_NOPM, 0, 0, NULL, 0,
-		spk_event, SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),
-SND_SOC_DAPM_PGA_E("SPKR Amp", SND_SOC_NOPM, 1, 0, NULL, 0,
-		spk_event, SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),
-
-SND_SOC_DAPM_OUTPUT("AUXO1"),
-SND_SOC_DAPM_OUTPUT("AUXO2"),
-SND_SOC_DAPM_OUTPUT("SPOL"),
-SND_SOC_DAPM_OUTPUT("SPOR"),
-SND_SOC_DAPM_OUTPUT("HPOL"),
-SND_SOC_DAPM_OUTPUT("HPOR"),
-SND_SOC_DAPM_OUTPUT("MONO"),
-};
-
-
-static const struct snd_soc_dapm_route audio_map[] = {
-	{"Mic1 Boost", NULL, "MIC1"},
-	{"Mic2 Boost", NULL, "MIC2"},
-	{"MONOIN_RXP Boost", NULL, "MONOIN_RXP"},
-	{"MONOIN_RXN Boost", NULL, "MONOIN_RXN"},
-	{"AXIL Boost", NULL, "AXIL"},
-	{"AXIR Boost", NULL, "AXIR"},
-
-	{"MONO_IN", NULL, "MONOIN_RXP Boost"},
-	{"MONO_IN", NULL, "MONOIN_RXN Boost"},
-
-	{"RECMIXL Mixer", "OUTMIXL Capture Switch", "OUTMIXL Mixer"},
-	{"RECMIXL Mixer", "MIC1_BST1 Capture Switch", "Mic1 Boost"},
-	{"RECMIXL Mixer", "AXILVOL Capture Switch", "AXIL Boost"},
-	{"RECMIXL Mixer", "MONOIN_RX Capture Switch", "MONO_IN"},
-
-	{"RECMIXR Mixer", "OUTMIXR Capture Switch", "OUTMIXR Mixer"},
-	{"RECMIXR Mixer", "MIC2_BST2 Capture Switch", "Mic2 Boost"},
-	{"RECMIXR Mixer", "AXIRVOL Capture Switch", "AXIR Boost"},
-	{"RECMIXR Mixer", "MONOIN_RX Capture Switch", "MONO_IN"},
-
-	{"ADC Mixer", NULL, "RECMIXL Mixer"},
-	{"ADC Mixer", NULL, "RECMIXR Mixer"},
-	{"Left ADC", NULL, "ADC Mixer"},
-	{"Right ADC", NULL, "ADC Mixer"},
-
-	{"Voice DAC Boost", NULL, "Voice DAC"},
-
-	{"SPKMIXL Mixer", "RECMIXL Playback Switch", "RECMIXL Mixer"},
-	{"SPKMIXL Mixer", "MIC1_P Playback Switch", "MIC1"},
-	{"SPKMIXL Mixer", "DACL Playback Switch", "Left DAC"},
-	{"SPKMIXL Mixer", "OUTMIXL Playback Switch", "OUTMIXL Mixer"},
-
-	{"SPKMIXR Mixer", "OUTMIXR Playback Switch", "OUTMIXR Mixer"},
-	{"SPKMIXR Mixer", "DACR Playback Switch", "Right DAC"},
-	{"SPKMIXR Mixer", "MIC2_P Playback Switch", "MIC2"},
-	{"SPKMIXR Mixer", "RECMIXR Playback Switch", "RECMIXR Mixer"},
-
-	{"OUTMIXL Mixer", "RECMIXL Playback Switch", "RECMIXL Mixer"},
-	{"OUTMIXL Mixer", "RECMIXR Playback Switch", "RECMIXR Mixer"},
-	{"OUTMIXL Mixer", "DACL Playback Switch", "Left DAC"},
-	{"OUTMIXL Mixer", "MIC1_BST1 Playback Switch", "Mic1 Boost"},
-	{"OUTMIXL Mixer", "MIC2_BST2 Playback Switch", "Mic2 Boost"},
-	{"OUTMIXL Mixer", "MONOIN_RXP Playback Switch", "MONOIN_RXP Boost"},
-	{"OUTMIXL Mixer", "AXILVOL Playback Switch", "AXIL Boost"},
-	{"OUTMIXL Mixer", "AXIRVOL Playback Switch", "AXIR Boost"},
-	{"OUTMIXL Mixer", "VDAC Playback Switch", "Voice DAC Boost"},
-
-	{"OUTMIXR Mixer", "RECMIXL Playback Switch", "RECMIXL Mixer"},
-	{"OUTMIXR Mixer", "RECMIXR Playback Switch", "RECMIXR Mixer"},
-	{"OUTMIXR Mixer", "DACR Playback Switch", "Right DAC"},
-	{"OUTMIXR Mixer", "MIC1_BST1 Playback Switch", "Mic1 Boost"},
-	{"OUTMIXR Mixer", "MIC2_BST2 Playback Switch", "Mic2 Boost"},
-	{"OUTMIXR Mixer", "MONOIN_RXN Playback Switch", "MONOIN_RXN Boost"},
-	{"OUTMIXR Mixer", "AXILVOL Playback Switch", "AXIL Boost"},
-	{"OUTMIXR Mixer", "AXIRVOL Playback Switch", "AXIR Boost"},
-	{"OUTMIXR Mixer", "VDAC Playback Switch", "Voice DAC Boost"},
-
-	{"Left SPK Vol",  NULL, "SPKMIXL Mixer"},
-	{"Right SPK Vol",  NULL, "SPKMIXR Mixer"},
-	{"Left HP Vol",  NULL, "OUTMIXL Mixer"},
-	{"Left Out Vol",  NULL, "OUTMIXL Mixer"},
-	{"Right Out Vol",  NULL, "OUTMIXR Mixer"},
-	{"Right HP Vol",  NULL, "OUTMIXR Mixer"},
-
-	{"AXO1MIX Mixer", "MIC1_BST1 Playback Switch", "Mic1 Boost"},
-	{"AXO1MIX Mixer", "OUTVOLL Playback Switch", "Left Out Vol"},
-	{"AXO1MIX Mixer", "OUTVOLR Playback Switch", "Right Out Vol"},
-	{"AXO1MIX Mixer", "MIC2_BST2 Playback Switch", "Mic2 Boost"},
-
-	{"AXO2MIX Mixer", "MIC1_BST1 Playback Switch", "Mic1 Boost"},
-	{"AXO2MIX Mixer", "OUTVOLL Playback Switch", "Left Out Vol"},
-	{"AXO2MIX Mixer", "OUTVOLR Playback Switch", "Right Out Vol"},
-	{"AXO2MIX Mixer", "MIC2_BST2 Playback Switch", "Mic2 Boost"},
-
-	{"SPOLMIX Mixer", "SPKVOLL Playback Switch", "Left SPK Vol"},
-	{"SPOLMIX Mixer", "SPKVOLR Playback Switch", "Right SPK Vol"},
-
-	{"SPORMIX Mixer", "SPKVOLL Playback Switch", "Left SPK Vol"},
-	{"SPORMIX Mixer", "SPKVOLR Playback Switch", "Right SPK Vol"},
-
-	{"MONOMIX Mixer", "OUTVOLL Playback Switch", "Left Out Vol"},
-	{"MONOMIX Mixer", "OUTVOLR Playback Switch", "Right Out Vol"},
-
-	{"SPOL Mux", "SPOLMIX", "SPOLMIX Mixer"},
-	{"SPOL Mux", "MONOIN_RX", "MONO_IN"},
-	{"SPOL Mux", "VDAC", "Voice DAC Boost"},
-	{"SPOL Mux", "DACL", "Left DAC"},
-
-	{"SPOR Mux", "SPORMIX", "SPORMIX Mixer"},
-	{"SPOR Mux", "MONOIN_RX", "MONO_IN"},
-	{"SPOR Mux", "VDAC", "Voice DAC Boost"},
-	{"SPOR Mux", "DACR", "Right DAC"},
-
-	{"Mono Mux", "MONOMIX", "MONOMIX Mixer"},
-	{"Mono Mux", "MONOIN_RX", "MONO_IN"},
-	{"Mono Mux", "VDAC", "Voice DAC Boost"},
-
-	{"Right DAC_HP", "NULL", "Right DAC"},
-	{"Left DAC_HP", "NULL", "Left DAC"},
-
-	{"HPL Mux", "LEFT HPVOL", "Left HP Vol"},
-	{"HPL Mux", "LEFT DAC", "Left DAC_HP"},
-	{"HPR Mux", "RIGHT HPVOL", "Right HP Vol"},
-	{"HPR Mux", "RIGHT DAC", "Right DAC_HP"},
-
-	{"SPKL Amp", NULL, "SPOL Mux"},
-	{"SPKR Amp", NULL, "SPOR Mux"},
-	{"Mono Amp", NULL, "Mono Mux"},
-
-	{"AUXO1", NULL, "AXO1MIX Mixer"},
-	{"AUXO2", NULL, "AXO2MIX Mixer"},
-	{"SPOL", NULL, "SPKL Amp"},
-	{"SPOR", NULL, "SPKR Amp"},
-
-	{"HPOL", NULL, "HPL Mux"},
-	{"HPOR", NULL, "HPR Mux"},
-
-	{"MONO", NULL, "Mono Amp"}
-};
-
-static int rt5631_add_widgets(struct snd_soc_codec *codec)
-{
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-
-	snd_soc_dapm_new_controls(dapm, rt5631_dapm_widgets,
-			ARRAY_SIZE(rt5631_dapm_widgets));
-	snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
-
-	return 0;
-}
-
-static int voltab[2][16] = 
-{
-    //spk
-    {0x27, 0x1b, 0x18, 0x15, 0x13, 0x11, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06},
-    //hp
-    {0x1f, 0x1c, 0x1a, 0x18, 0x16, 0x14, 0x12, 0x10, 0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},
-};
-static int gvolume = 0;
-
-#if 1
-static int get_vol(int max, int min, int stage_num, int stage)
-{
-	int ret, step=((max-min)<<8)/(stage_num-1);
-	if(stage==stage_num-1)
-		ret=min;
-	else if(stage==0)
-		ret=max;
-	else {
-		ret=(stage_num-stage-1) * step;
-		ret >>= 8;
-		ret = min+ret;
-	}
-	DBG("%s(): ret=%02x, max=0x%02x, min=0x%02x, stage_num=%d, stage=%d\n", 
-		__FUNCTION__, 
-		ret,
-		max,
-		min,
-		stage_num,
-		stage);
-	return ret;
-}
-
-static void rt5631_set_volume(int vollevel)
-{
-	struct snd_soc_codec *codec = rt5631_codec;
-	int tmpvol1, tmpvol2;
-
-	//DBG("rt5631_set_volume = %d\n", vollevel);
-    
-	if (vollevel > 15) vollevel = 8;
-	gvolume = vollevel;
-	
-//	tmpvol1 = voltab[0][vollevel];
-//	tmpvol2 = voltab[1][vollevel];
-	tmpvol1=get_vol(0x27, DEF_VOL_SPK&0x3f, 16, vollevel);
-	tmpvol2=get_vol(0x1f, DEF_VOL&0x1f, 16, vollevel);
-
-	if(vollevel == 0){
-		rt5631_write_mask(codec, RT5631_SPK_OUT_VOL, 0x8080, 0x8080);
-		rt5631_write_mask(codec, RT5631_HP_OUT_VOL, 0x8080, 0x8080);
-	}
-//	else{
-//		rt5631_write_mask(codec, RT5631_SPK_OUT_VOL, 0x00, 0x8080);
-//		rt5631_write_mask(codec, RT5631_HP_OUT_VOL, 0x00, 0x8080);
-//	}
-
-	rt5631_write_mask(codec, RT5631_SPK_OUT_VOL, ((tmpvol1<<8)|tmpvol1), 0x3f3f);
-	rt5631_write_mask(codec, RT5631_HP_OUT_VOL,  ((tmpvol2<<8)|tmpvol2), 0x3f3f);
-}
-
-static void rt5631_set_eq(int on)
-{
-	struct snd_soc_codec *codec = rt5631_codec;
-	unsigned int Reg0C;
-
-	Reg0C = rt5631_read(codec, RT5631_STEREO_DAC_VOL_1);
-	DBG("------- rt5631_set_eq: read Reg0C = 0x%04x\n", Reg0C);
-
-	Reg0C &= 0xFF80;
-	if(on) { 
-		Reg0C |= 0x10;
-	} else {
-		Reg0C |= 0x00;
-	}
-
-	DBG("------- rt5631_set_eq: write Reg0C = 0x%04x\n", Reg0C);
-	rt5631_write(codec, RT5631_STEREO_DAC_VOL_1, Reg0C);
-}
-
-#else
-
-static void rt5631_set_volume(int vollevel)
-{
-	struct snd_soc_codec *codec = rt5631_codec;
-	u8 tmpvol1, tmpvol2;
-	u16 spk_vol, hp_vol;
-
-	DBG("rt5631_set_volume = %d\n", vollevel);
-    
-	if (vollevel > 15) vollevel = 8;
-	gvolume = vollevel;
-	
-	tmpvol1 = voltab[0][vollevel];
-	tmpvol2 = voltab[1][vollevel];
-
-	spk_vol = snd_soc_read(codec, RT5631_SPK_OUT_VOL);
-	hp_vol  = snd_soc_read(codec, RT5631_HP_OUT_VOL);
-
-	DBG("\n\nold value: 0x%04x, 0x%04x\n", spk_vol & 0x3F3F, hp_vol & 0x3F3F);
-	DBG("new value: 0x%04x\n", (tmpvol1<<8)|tmpvol1, (tmpvol2<<8)|tmpvol2);
-
-	spk_vol &= 0x3C3C;
-	spk_vol |= (tmpvol1<<8)|tmpvol1;
-	hp_vol	&= 0x3C3C;
-	hp_vol  |= (tmpvol2<<8)|tmpvol2;
-
-	snd_soc_write(codec, RT5631_SPK_OUT_VOL, spk_vol);
-	snd_soc_write(codec, RT5631_HP_OUT_VOL , hp_vol);
-}
-
-#endif
-struct coeff_clk_div {
-	u32 mclk;
-	u32 bclk;
-	u32 rate;
-	u16 reg_val;
-};
-
-/* PLL divisors yes*/
-struct pll_div {
-	u32 pll_in;
-	u32 pll_out;
-	u16 reg_val;
-};
-
-static const struct pll_div codec_master_pll_div[] = {
-	{2048000,  8192000,  0x0ea0},
-	{3686400,  8192000,  0x4e27},
-	{12000000,  8192000,  0x456b},
-	{13000000,  8192000,  0x495f},
-	{13100000,  8192000,  0x0320},
-	{2048000,  11289600,  0xf637},
-	{3686400,  11289600,  0x2f22},
-	{12000000,  11289600,  0x3e2f},
-	{13000000,  11289600,  0x4d5b},
-	{13100000,  11289600,  0x363b},
-	{2048000,  16384000,  0x1ea0},
-	{3686400,  16384000,  0x9e27},
-	{12000000,  16384000,  0x452b},
-	{13000000,  16384000,  0x542f},
-	{13100000,  16384000,  0x03a0},
-	{2048000,  16934400,  0xe625},
-	{3686400,  16934400,  0x9126},
-	{12000000,  16934400,  0x4d2c},
-	{13000000,  16934400,  0x742f},
-	{13100000,  16934400,  0x3c27},
-	{2048000,  22579200,  0x2aa0},
-	{3686400,  22579200,  0x2f20},
-	{12000000,  22579200,  0x7e2f},
-	{13000000,  22579200,  0x742f},
-	{13100000,  22579200,  0x3c27},
-	{2048000,  24576000,  0x2ea0},
-	{3686400,  24576000,  0xee27},
-	{12000000,  24576000,  0x2915},
-	{13000000,  24576000,  0x772e},
-	{13100000,  24576000,  0x0d20},
-	{26000000,  24576000,  0x2027},
-	{26000000,  22579200,  0x392f},
-	{24576000,  22579200,  0x0921},
-	{24576000,  24576000,  0x02a0},
-};
-
-static const struct pll_div codec_slave_pll_div[] = {
-	{256000,  2048000,  0x46f0},
-	{256000,  4096000,  0x3ea0},
-	{352800,	 5644800,  0x3ea0},
-	{512000,	 8192000,  0x3ea0},
-	{1024000,  8192000,  0x46f0},
-	{705600,  11289600,  0x3ea0},
-	{1024000,  16384000,  0x3ea0},
-	{1411200,  22579200,  0x3ea0},
-	{1536000,  24576000,  0x3ea0},
-	{2048000,  16384000,  0x1ea0},
-	{2822400,  22579200,  0x1ea0},
-	{2822400,  45158400,  0x5ec0},
-	{5644800,  45158400,  0x46f0},
-	{3072000,  24576000,  0x1ea0},
-	{3072000,  49152000,  0x5ec0},
-	{6144000,  49152000,  0x46f0},
-	{705600,  11289600,  0x3ea0},
-	{705600,  8467200,  0x3ab0},
-	{24576000,  24576000,  0x02a0},
-	{1411200,  11289600,  0x1690},
-	{2822400,  11289600,  0x0a90},
-	{1536000,  12288000,  0x1690},
-	{3072000,  12288000,  0x0a90},
-};
-
-struct coeff_clk_div coeff_div[] = {
-	/* sysclk is 256fs */
-	{2048000,  8000 * 32,  8000, 0x1000},
-	{2048000,  8000 * 64,  8000, 0x0000},
-	{2822400,  11025 * 32,  11025,  0x1000},
-	{2822400,  11025 * 64,  11025,  0x0000},
-	{4096000,  16000 * 32,  16000,  0x1000},
-	{4096000,  16000 * 64,  16000,  0x0000},
-	{5644800,  22050 * 32,  22050,  0x1000},
-	{5644800,  22050 * 64,  22050,  0x0000},
-	{8192000,  32000 * 32,  32000,  0x1000},
-	{8192000,  32000 * 64,  32000,  0x0000},
-	{11289600,  44100 * 32,  44100,  0x1000},
-	{11289600,  44100 * 64,  44100,  0x0000},
-	{12288000,  48000 * 32,  48000,  0x1000},
-	{12288000,  48000 * 64,  48000,  0x0000},
-	{22579200,  88200 * 32,  88200,  0x1000},
-	{22579200,  88200 * 64,  88200,  0x0000},
-	{24576000,  96000 * 32,  96000,  0x1000},
-	{24576000,  96000 * 64,  96000,  0x0000},
-	{22579200,  176400 * 32,  176400,  0x1000},
-	{22579200,  176400 * 64,  176400,  0x0000},
-	{24576000,  192000 * 32,  192000,  0x1000},
-	{24576000,  162000 * 64,  192000,  0x0000},
-	/* sysclk is 512fs */
-	{4096000,  8000 * 32,  8000, 0x3000},
-	{4096000,  8000 * 64,  8000, 0x2000},
-	{5644800,  11025 * 32,  11025, 0x3000},
-	{5644800,  11025 * 64,  11025, 0x2000},
-	{8192000,  16000 * 32,  16000, 0x3000},
-	{8192000,  16000 * 64,  16000, 0x2000},
-	{11289600,  22050 * 32,  22050, 0x3000},
-	{11289600,  22050 * 64,  22050, 0x2000},
-	{16384000,  32000 * 32,  32000, 0x3000},
-	{16384000,  32000 * 64,  32000, 0x2000},
-	{22579200,  44100 * 32,  44100, 0x3000},
-	{22579200,  44100 * 64,  44100, 0x2000},
-	{24576000,  48000 * 32,  48000, 0x3000},
-	{24576000,  48000 * 64,  48000, 0x2000},
-	{45158400,  88200 * 32,  88200, 0x3000},
-	{45158400,  88200 * 64,  88200, 0x2000},
-	{49152000,  96000 * 32,  96000, 0x3000},
-	{49152000,  96000 * 64,  96000, 0x2000},
-	/* sysclk is 24.576Mhz or 22.5792Mhz */
-	{24576000,  8000 * 32,  8000,  0x7080},
-	{24576000,  8000 * 64,  8000,  0x6080},
-	{24576000,  16000 * 32,  16000,  0x5080},
-	{24576000,  16000 * 64,  16000,  0x4080},
-	{24576000,  24000 * 32,  24000,  0x5000},
-	{24576000,  24000 * 64,  24000,  0x4000},
-	{24576000,  32000 * 32,  32000,  0x3080},
-	{24576000,  32000 * 64,  32000,  0x2080},
-	{22579200,  11025 * 32,  11025,  0x7000},
-	{22579200,  11025 * 64,  11025,  0x6000},
-	{22579200,  22050 * 32,  22050,  0x5000},
-	{22579200,  22050 * 64,  22050,  0x4000},
-};
-
-static int get_coeff(int mclk, int rate, int timesofbclk)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
-		if (coeff_div[i].mclk == mclk && coeff_div[i].rate == rate &&
-			(coeff_div[i].bclk / coeff_div[i].rate) == timesofbclk)
-			return i;
-	}
-	return -EINVAL;
-}
-
-static int get_coeff_in_slave_mode(int mclk, int rate)
-{
-	return get_coeff(mclk, rate, timesofbclk);
-}
-
-static int get_coeff_in_master_mode(int mclk, int rate, int bclk)
-{
-	return get_coeff(mclk, rate, (bclk / rate));
-}
-
-static void rt5631_set_dmic_params(struct snd_soc_codec *codec,
-	struct snd_pcm_hw_params *params)
-{
-	int rate;
-
-	rt5631_write_mask(codec, RT5631_GPIO_CTRL,
-		GPIO_PIN_FUN_SEL_GPIO_DIMC | GPIO_DMIC_FUN_SEL_DIMC,
-		GPIO_PIN_FUN_SEL_MASK | GPIO_DMIC_FUN_SEL_MASK);
-	rt5631_write_mask(codec, RT5631_DIG_MIC_CTRL, DMIC_ENA, DMIC_ENA_MASK);
-	rt5631_write_mask(codec, RT5631_DIG_MIC_CTRL,
-		DMIC_L_CH_LATCH_FALLING | DMIC_R_CH_LATCH_RISING,
-		DMIC_L_CH_LATCH_MASK|DMIC_R_CH_LATCH_MASK);
-
-	rate = params_rate(params);
-	switch (rate) {
-	case 44100:
-	case 48000:
-		rt5631_write_mask(codec, RT5631_DIG_MIC_CTRL,
-			DMIC_CLK_CTRL_TO_32FS, DMIC_CLK_CTRL_MASK);
-		break;
-
-	case 32000:
-	case 22050:
-		rt5631_write_mask(codec, RT5631_DIG_MIC_CTRL,
-			DMIC_CLK_CTRL_TO_64FS, DMIC_CLK_CTRL_MASK);
-		break;
-
-	case 16000:
-	case 11025:
-	case 8000:
-		rt5631_write_mask(codec, RT5631_DIG_MIC_CTRL,
-			DMIC_CLK_CTRL_TO_128FS, DMIC_CLK_CTRL_MASK);
-		break;
-
-	default:
-		break;
-	}
-
-	rt5631_write_mask(codec, RT5631_DIG_MIC_CTRL,
-		DMIC_L_CH_UNMUTE | DMIC_R_CH_UNMUTE,
-		DMIC_L_CH_MUTE_MASK | DMIC_R_CH_MUTE_MASK);
-
-	return;
-}
-
-static int rt5631_hifi_pcm_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct snd_soc_codec *codec = rtd->codec;
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-	int stream = substream->stream, rate = params_rate(params), coeff;
-	unsigned int iface = 0;
-
-	pr_debug("enter %s\n", __func__);
-
-	if (!rt5631->master)
-		coeff = get_coeff_in_slave_mode(rt5631->sysclk, rate);
-	else
-		coeff = get_coeff_in_master_mode(rt5631->sysclk, rate,
-					rate * timesofbclk);
-	if (coeff < 0)
-		pr_err("%s: get coeff err!\n", __func__);
-
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S16_LE:
-		break;
-	case SNDRV_PCM_FORMAT_S20_3LE:
-		iface |= SDP_I2S_DL_20;
-		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		iface |= SDP_I2S_DL_24;
-		break;
-	case SNDRV_PCM_FORMAT_S8:
-		iface |= SDP_I2S_DL_8;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (SNDRV_PCM_STREAM_CAPTURE == stream) {
-		if (rt5631->dmic_used_flag)
-			rt5631_set_dmic_params(codec, params);
-	}
-
-	rt5631_write_mask(codec, RT5631_SDP_CTRL, iface, SDP_I2S_DL_MASK);
-
-	if (coeff >= 0)
-		rt5631_write(codec, RT5631_STEREO_AD_DA_CLK_CTRL,
-					coeff_div[coeff].reg_val);
-
-	return 0;
-}
-
-static int rt5631_hifi_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,
-						unsigned int fmt)
-{
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-	unsigned int iface = 0;
-
-	pr_debug("enter %s\n", __func__);
-
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		rt5631->master = 1;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		iface |= SDP_MODE_SEL_SLAVE;
-		rt5631->master = 0;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_I2S:
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		iface |= SDP_I2S_DF_LEFT;
-		break;
-	case SND_SOC_DAIFMT_DSP_A:
-		iface |= SDP_I2S_DF_PCM_A;
-		break;
-	case SND_SOC_DAIFMT_DSP_B:
-		iface  |= SDP_I2S_DF_PCM_B;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_NF:
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		iface |= SDP_I2S_BCLK_POL_CTRL;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	rt5631_write(codec, RT5631_SDP_CTRL, iface);
-
-	return 0;
-}
-
-static int rt5631_hifi_codec_set_dai_sysclk(struct snd_soc_dai *codec_dai,
-				int clk_id, unsigned int freq, int dir)
-{
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-
-	DBG("enter %s, syclk=%d\n", __func__, freq);
-	if ((freq >= (256 * 8000)) && (freq <= (512 * 96000))) {
-		rt5631->sysclk = freq;
-		return 0;
-	}
-
-	pr_info("unsupported sysclk freq %u for audio i2s\n", freq);
-	pr_info("set sysclk to 24.576Mhz by default\n");
-
-	rt5631->sysclk = 24576000;
-	return 0;
-}
-
-static int rt5631_codec_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,
-		int source, unsigned int freq_in, unsigned int freq_out)
-{
-	struct snd_soc_codec *codec = codec_dai->codec;
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-	int i, ret = -EINVAL;
-
-	DBG(KERN_DEBUG "enter %s\n", __func__);
-
-	if (!freq_in || !freq_out)
-		return 0;
-
-	if (rt5631->master) {
-		for (i = 0; i < ARRAY_SIZE(codec_master_pll_div); i++)
-			if (freq_in == codec_master_pll_div[i].pll_in &&
-			freq_out == codec_master_pll_div[i].pll_out) {
-				rt5631_write(codec, RT5631_PLL_CTRL,
-					codec_master_pll_div[i].reg_val);
-				schedule_timeout_uninterruptible(
-					msecs_to_jiffies(20));
-				rt5631_write(codec, RT5631_GLOBAL_CLK_CTRL,
-					SYSCLK_SOUR_SEL_PLL);
-				rt5631->pll_used_flag = 1;
-				ret = 0;
-				break;
-			}
-	} else {
-		for (i = 0; i < ARRAY_SIZE(codec_slave_pll_div); i++)
-			if (freq_in == codec_slave_pll_div[i].pll_in &&
-			freq_out == codec_slave_pll_div[i].pll_out) {
-				rt5631_write(codec, RT5631_PLL_CTRL,
-					codec_slave_pll_div[i].reg_val);
-				schedule_timeout_uninterruptible(
-					msecs_to_jiffies(20));
-				rt5631_write(codec, RT5631_GLOBAL_CLK_CTRL,
-					SYSCLK_SOUR_SEL_PLL |
-					PLLCLK_SOUR_SEL_BITCLK);
-				rt5631->pll_used_flag = 1;
-				ret = 0;
-				break;
-			}
-	}
-
-	return ret;
-}
-
-#if defined(CONFIG_ADJUST_VOL_BY_CODEC)
-static int rt5631_trigger(struct snd_pcm_substream *substream, int status, struct snd_soc_dai *dai)
-{
-	//DBG("rt5631_trigger\n");
-	if(status == SNDRV_PCM_TRIGGER_VOLUME){
-		//DBG("rt5631_trigger: vol = %d\n", substream->number);
-		if(substream->number < 100){
-			rt5631_set_volume(substream->number);
-		} else {
-			if(substream->number == 100) { // eq off
-				DBG("---------- eq off\n");
-				rt5631_set_eq(0);
-			} else { // eq on   +6dB
-				DBG("---------- eq on\n");
-				rt5631_set_eq(1);
-			}
-		}		
-	}
-
-	return 0;
-}
-#endif
-
-static ssize_t rt5631_index_reg_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	#define IDX_REG_FMT "%02x: %04x\n"
-	#define IDX_REG_LEN 9
-	unsigned int val;
-	int cnt = 0, i;
-
-	cnt += sprintf(buf, "RT5631 index register\n");
-	for (i = 0; i < 0x55; i++) {
-		if (cnt + IDX_REG_LEN >= PAGE_SIZE - 1)
-			break;
-		val = rt5631_read_index(rt5631_codec, i);
-		if (!val)
-			continue;
-		cnt += sprintf(buf + cnt, IDX_REG_FMT, i, val);
-	}
-
-	if (cnt >= PAGE_SIZE)
-		cnt = PAGE_SIZE - 1;
-
-	return cnt;
-}
-static DEVICE_ATTR(index_reg, 0444, rt5631_index_reg_show, NULL);
-
-#define RT5631_STEREO_RATES SNDRV_PCM_RATE_8000_192000
-#define RT5631_FORMAT	(SNDRV_PCM_FMTBIT_S16_LE | \
-			SNDRV_PCM_FMTBIT_S20_3LE | \
-			SNDRV_PCM_FMTBIT_S24_LE | \
-			SNDRV_PCM_FMTBIT_S8)
-
-struct snd_soc_dai_ops rt5631_ops = {
-	.hw_params = rt5631_hifi_pcm_params,
-	.set_fmt = rt5631_hifi_codec_set_dai_fmt,
-	.set_sysclk = rt5631_hifi_codec_set_dai_sysclk,
-	.set_pll = rt5631_codec_set_dai_pll,
-#if defined(CONFIG_ADJUST_VOL_BY_CODEC)
-    .trigger = rt5631_trigger,
-#endif
-};
-
-struct snd_soc_dai_driver rt5631_dai[] = {
-	{
-		.name = "RT5631 HiFi",
-		.playback = {
-			.stream_name = "HIFI Playback",
-			.channels_min = 1,
-			.channels_max = 2,
-			.rates = RT5631_STEREO_RATES,
-			.formats = RT5631_FORMAT,
-		},
-		.capture = {
-			.stream_name = "HIFI Capture",
-			.channels_min = 1,
-			.channels_max = 2,
-			.rates = RT5631_STEREO_RATES,
-			.formats = RT5631_FORMAT,
-		},
-		.ops = &rt5631_ops,
-	},
-};
-EXPORT_SYMBOL_GPL(rt5631_dai);
-
-static int rt5631_set_bias_level(struct snd_soc_codec *codec,
-			enum snd_soc_bias_level level)
-{
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-		break;
-
-	case SND_SOC_BIAS_PREPARE:
-		rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3,
-			PWR_VREF | PWR_MAIN_BIAS, PWR_VREF | PWR_MAIN_BIAS);
-		rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD2,
-			PWR_MICBIAS1_VOL | PWR_MICBIAS2_VOL,
-			PWR_MICBIAS1_VOL | PWR_MICBIAS2_VOL);
-		break;
-
-	case SND_SOC_BIAS_STANDBY:
-	//	rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD2, 0,
-	//		PWR_MICBIAS1_VOL | PWR_MICBIAS2_VOL);
-		printk("standby rt5631\n");
-		rt5631_write(codec, RT5631_PWR_MANAG_ADD1, 0x0000);
-		rt5631_write(codec, RT5631_PWR_MANAG_ADD2, 0x0000);
-		rt5631_write(codec, RT5631_PWR_MANAG_ADD3, 0x0000);
-		rt5631_write(codec, RT5631_PWR_MANAG_ADD4, 0x0000);		
-		break;
-
-	case SND_SOC_BIAS_OFF:
-		rt5631_write_mask(codec, RT5631_SPK_OUT_VOL,
-			RT_L_MUTE | RT_R_MUTE, RT_L_MUTE | RT_R_MUTE);
-		rt5631_write_mask(codec, RT5631_HP_OUT_VOL,
-			RT_L_MUTE | RT_R_MUTE, RT_L_MUTE | RT_R_MUTE);
-		rt5631_write(codec, RT5631_PWR_MANAG_ADD1, 0x0000);
-		rt5631_write(codec, RT5631_PWR_MANAG_ADD2, 0x0000);
-		rt5631_write(codec, RT5631_PWR_MANAG_ADD3, 0x0000);
-		rt5631_write(codec, RT5631_PWR_MANAG_ADD4, 0x0000);
-		break;
-
-	default:
-		break;
-	}
-	codec->dapm.bias_level = level;
-
-	return 0;
-}
-
-static int rt5631_probe(struct snd_soc_codec *codec)
-{
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-	unsigned int val;
-	int ret;
-	ret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_I2C);
-	if (ret != 0) {
-		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
-		return ret;
-	}
-	codec->cache_bypass = 1;
-
-	val = rt5631_read_index(codec, RT5631_ADDA_MIXER_INTL_REG3);
-	if (val & 0x0002)
-		rt5631->codec_version = 1;
-	else
-		rt5631->codec_version = 0;
-
-	rt5631_reset(codec);
-	rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3,
-		PWR_VREF | PWR_MAIN_BIAS, PWR_VREF | PWR_MAIN_BIAS);
-	schedule_timeout_uninterruptible(msecs_to_jiffies(80));
-	rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3, PWR_FAST_VREF_CTRL,
-					PWR_FAST_VREF_CTRL);
-	rt5631_reg_init(codec);
-
-	/* power off ClassD auto Recovery */
-	if (rt5631->codec_version)
-		rt5631_write_mask(codec, RT5631_INT_ST_IRQ_CTRL_2,
-					0x2000, 0x2000);
-	else
-		rt5631_write_mask(codec, RT5631_INT_ST_IRQ_CTRL_2,
-					0, 0x2000);
-
-	codec->dapm.bias_level = SND_SOC_BIAS_STANDBY;
-	rt5631_codec = codec;
-
-#if (RT5631_SPK_TIMER == 1)
-	/* Timer module installing */
-	setup_timer( &spk_timer, spk_timer_callback, 0 );
-	DBG( "Starting timer to fire in 5s (%ld)\n", jiffies );
-	ret = mod_timer( &spk_timer, jiffies + msecs_to_jiffies(5000) );
-	if (ret) printk("Error in mod_timer\n");
-
-	INIT_WORK(&spk_work, spk_work_handler);
-#endif
-//bard 7-16 s
-	INIT_DELAYED_WORK(&rt5631_delay_cap,rt5631_adc_on);
-//bard 7-16 e
-	snd_soc_add_controls(codec, rt5631_snd_controls,
-		ARRAY_SIZE(rt5631_snd_controls));
-	rt5631_add_widgets(codec);
-
-	ret = device_create_file(codec->dev, &dev_attr_index_reg);
-	if (ret != 0) {
-		dev_err(codec->dev,
-			"Failed to create index_reg sysfs files: %d\n", ret);
-		return ret;
-	}
-
-	DBG("RT5631 initial ok!\n");
-
-	return 0;
-}
-
-static int rt5631_remove(struct snd_soc_codec *codec)
-{
-
-
-#if (RT5631_SPK_TIMER == 1)	
-	/* Timermoduleuninstalling */
-	int ret;
-	ret = del_timer(&spk_timer);
-	if(ret) printk("The timer is still in use...\n");
-	DBG("Timer module uninstalling\n");
-#endif
-
-
-	rt5631_set_bias_level(codec, SND_SOC_BIAS_OFF);
-	return 0;
-}
-
-static int rt5631_suspend(struct snd_soc_codec *codec, pm_message_t state)
-{
-	rt5631_set_bias_level(codec, SND_SOC_BIAS_OFF);
-	return 0;
-}
-
-static int rt5631_resume(struct snd_soc_codec *codec)
-{
-	struct rt5631_priv *rt5631 = snd_soc_codec_get_drvdata(codec);
-
-	rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3,
-		PWR_VREF | PWR_MAIN_BIAS, PWR_VREF | PWR_MAIN_BIAS);
-	schedule_timeout_uninterruptible(msecs_to_jiffies(110));
-	rt5631_write_mask(codec, RT5631_PWR_MANAG_ADD3,
-		PWR_FAST_VREF_CTRL, PWR_FAST_VREF_CTRL);
-	rt5631_reg_init(codec);
-
-	/* power off ClassD auto Recovery */
-	if (rt5631->codec_version)
-		rt5631_write_mask(codec, RT5631_INT_ST_IRQ_CTRL_2,
-					0x2000, 0x2000);
-	else
-		rt5631_write_mask(codec, RT5631_INT_ST_IRQ_CTRL_2,
-					0, 0x2000);
-
-#if (RT5631_SPK_TIMER == 1)
-		//last_is_spk = !last_is_spk;	//wired~, update eqmode right here by spk_timer.
-		last_is_spk = -1;	//wired~, update eqmode right here by spk_timer. //bard 9-13
-#endif
-
-	return 0;
-}
-
-#ifdef CONFIG_MACH_RK_FAC
-void rt5631_codec_set_spk(bool on)
-{
-	struct snd_soc_codec *codec = rt5631_codec;	
-	if(rt5631_hdmi_ctrl)
-	{
-		DBG("%s: %d\n", __func__, on);
-		
-		if(!codec)
-			return;
-		mutex_lock(&codec->mutex);
-		if(on){
-			DBG("snd_soc_dapm_enable_pin\n");
-			snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-			snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-		}
-		else{
-			DBG("snd_soc_dapm_disable_pin\n");
-			snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-			snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-		}
-	
-		snd_soc_dapm_sync(&codec->dapm);
-		mutex_unlock(&codec->mutex);
-	}
-	return;
-}
-#else
-void codec_set_spk(bool on)
-{
-	struct snd_soc_codec *codec = rt5631_codec;
-
-	DBG("%s: %d\n", __func__, on);
-
-	if(!codec)
-		return;
-	mutex_lock(&codec->mutex);
-	if(on){
-		DBG("snd_soc_dapm_enable_pin\n");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_enable_pin(&codec->dapm, "Ext Spk");
-	}
-	else{
-		DBG("snd_soc_dapm_disable_pin\n");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Headphone Jack");
-		snd_soc_dapm_disable_pin(&codec->dapm, "Ext Spk");
-	}
-
-	snd_soc_dapm_sync(&codec->dapm);
-	mutex_unlock(&codec->mutex);
-	return;
-}
-#endif 
-
-/*
- * detect short current for mic1
- */
-int rt5631_ext_mic_detect(void)
-{
-	struct snd_soc_codec *codec = rt5631_codec;
-	int det;
-
-	rt5631_write_mask(codec, RT5631_MIC_CTRL_2, MICBIAS1_S_C_DET_ENA,
-				MICBIAS1_S_C_DET_MASK);
-	det = rt5631_read(codec, RT5631_INT_ST_IRQ_CTRL_2) & 0x0001;
-	rt5631_write_mask(codec, RT5631_INT_ST_IRQ_CTRL_2, 0x0001, 0x00001);
-
-	return det;
-}
-EXPORT_SYMBOL_GPL(rt5631_ext_mic_detect);
-
-static struct snd_soc_codec_driver soc_codec_dev_rt5631 = {
-	.probe = rt5631_probe,
-	.remove = rt5631_remove,
-	.suspend = rt5631_suspend,
-	.resume = rt5631_resume,
-	.set_bias_level = rt5631_set_bias_level,
-	.reg_cache_size = ARRAY_SIZE(rt5631_reg),
-	.reg_word_size = sizeof(u16),
-	.reg_cache_default = rt5631_reg,
-	.reg_cache_step = 1,
-};
-
-void rt5631_shutdown(struct i2c_client *client)
-{
-	rt5631_set_bias_level(rt5631_codec, SND_SOC_BIAS_OFF);
-}
-
-
-static const struct i2c_device_id rt5631_i2c_id[] = {
-	{ "rt5631", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, rt5631_i2c_id);
-
-static int rt5631_i2c_probe(struct i2c_client *i2c,
-		    const struct i2c_device_id *id)
-{
-	struct rt5631_priv *rt5631;
-	int ret;
-
-	printk("RT5631 Audio Codec %s\n", RT5631_VERSION);
-
-	rt5631 = kzalloc(sizeof(struct rt5631_priv), GFP_KERNEL);
-	if (NULL == rt5631)
-		return -ENOMEM;
-
-	i2c_set_clientdata(i2c, rt5631);
-
-	ret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5631,
-			rt5631_dai, ARRAY_SIZE(rt5631_dai));
-	if (ret < 0)
-		kfree(rt5631);
-#ifdef CONFIG_MACH_RK_FAC             
-  	rt5631_hdmi_ctrl=1;
-#endif 
-
-	return ret;
-}
-
-static __devexit int rt5631_i2c_remove(struct i2c_client *client)
-{
-	snd_soc_unregister_codec(&client->dev);
-	kfree(i2c_get_clientdata(client));
-	return 0;
-}
-
-struct i2c_driver rt5631_i2c_driver = {
-	.driver = {
-		.name = "RT5631",
-		.owner = THIS_MODULE,
-	},
-	.probe = rt5631_i2c_probe,
-	.remove   = __devexit_p(rt5631_i2c_remove),
-	.id_table = rt5631_i2c_id,
-	.shutdown = rt5631_shutdown,
-};
-
-static int __init rt5631_modinit(void)
-{
-	return i2c_add_driver(&rt5631_i2c_driver);
-}
-module_init(rt5631_modinit);
-
-static void __exit rt5631_modexit(void)
-{
-	i2c_del_driver(&rt5631_i2c_driver);
-}
-module_exit(rt5631_modexit);
-
-MODULE_DESCRIPTION("ASoC RT5631 driver");
-MODULE_AUTHOR("flove <flove@realtek.com>");
-MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/rt5631.h b/sound/soc/codecs/rt5631.h
deleted file mode 100644
index e9bad16e40c8..000000000000
--- a/sound/soc/codecs/rt5631.h
+++ /dev/null
@@ -1,570 +0,0 @@
-#ifndef __RTCODEC5631_H__
-#define __RTCODEC5631_H__
-
-
-#define RT5631_RESET				0x00
-#define RT5631_SPK_OUT_VOL			0x02
-#define RT5631_HP_OUT_VOL			0x04
-#define RT5631_MONO_AXO_1_2_VOL		0x06
-#define RT5631_AUX_IN_VOL			0x0A
-#define RT5631_STEREO_DAC_VOL_1		0x0C
-#define RT5631_MIC_CTRL_1			0x0E
-#define RT5631_STEREO_DAC_VOL_2		0x10
-#define RT5631_ADC_CTRL_1			0x12
-#define RT5631_ADC_REC_MIXER			0x14
-#define RT5631_ADC_CTRL_2			0x16
-#define RT5631_OUTMIXER_L_CTRL			0x1A
-#define RT5631_OUTMIXER_R_CTRL			0x1C
-#define RT5631_AXO1MIXER_CTRL			0x1E
-#define RT5631_AXO2MIXER_CTRL			0x20
-#define RT5631_MIC_CTRL_2			0x22
-#define RT5631_DIG_MIC_CTRL			0x24
-#define RT5631_MONO_INPUT_VOL			0x26
-#define RT5631_SPK_MIXER_CTRL			0x28
-#define RT5631_SPK_MONO_OUT_CTRL		0x2A
-#define RT5631_SPK_MONO_HP_OUT_CTRL		0x2C
-#define RT5631_SDP_CTRL				0x34
-#define RT5631_STEREO_AD_DA_CLK_CTRL		0x38
-#define RT5631_PWR_MANAG_ADD1		0x3A
-#define RT5631_PWR_MANAG_ADD2		0x3B
-#define RT5631_PWR_MANAG_ADD3		0x3C
-#define RT5631_PWR_MANAG_ADD4		0x3E
-#define RT5631_GEN_PUR_CTRL_REG		0x40
-#define RT5631_GLOBAL_CLK_CTRL			0x42
-#define RT5631_PLL_CTRL				0x44
-#define RT5631_INT_ST_IRQ_CTRL_1		0x48
-#define RT5631_INT_ST_IRQ_CTRL_2		0x4A
-#define RT5631_GPIO_CTRL			0x4C
-#define RT5631_MISC_CTRL			0x52
-#define RT5631_DEPOP_FUN_CTRL_1		0x54
-#define RT5631_DEPOP_FUN_CTRL_2		0x56
-#define RT5631_JACK_DET_CTRL			0x5A
-#define RT5631_SOFT_VOL_CTRL			0x5C
-#define RT5631_ALC_CTRL_1			0x64
-#define RT5631_ALC_CTRL_2			0x65
-#define RT5631_ALC_CTRL_3			0x66
-#define RT5631_PSEUDO_SPATL_CTRL		0x68
-#define RT5631_INDEX_ADD			0x6A
-#define RT5631_INDEX_DATA			0x6C
-#define RT5631_EQ_CTRL				0x6E
-#define RT5631_VENDOR_ID1			0x7C
-#define RT5631_VENDOR_ID2			0x7E
-
-/* Index of Codec Private Register definition */
-#define RT5631_EQ_BW_LOP			0x00
-#define RT5631_EQ_GAIN_LOP			0x01
-#define RT5631_EQ_FC_BP1			0x02
-#define RT5631_EQ_BW_BP1			0x03
-#define RT5631_EQ_GAIN_BP1			0x04
-#define RT5631_EQ_FC_BP2			0x05
-#define RT5631_EQ_BW_BP2			0x06
-#define RT5631_EQ_GAIN_BP2			0x07
-#define RT5631_EQ_FC_BP3			0x08
-#define RT5631_EQ_BW_BP3			0x09
-#define RT5631_EQ_GAIN_BP3			0x0a
-#define RT5631_EQ_BW_HIP			0x0b
-#define RT5631_EQ_GAIN_HIP			0x0c
-#define RT5631_EQ_HPF_A1			0x0d
-#define RT5631_EQ_HPF_A2			0x0e
-#define RT5631_EQ_HPF_GAIN			0x0f
-#define RT5631_EQ_PRE_VOL_CTRL			0x11
-#define RT5631_EQ_POST_VOL_CTRL		0x12
-#define RT5631_TEST_MODE_CTRL			0x39
-#define RT5631_CP_INTL_REG2			0x45
-#define RT5631_ADDA_MIXER_INTL_REG3		0x52
-#define RT5631_SPK_INTL_CTRL			0x56
-
-
-/* global definition */
-#define RT_L_MUTE				(0x1 << 15)
-#define RT_R_MUTE				(0x1 << 7)
-
-/* Speaker Output Control(0x02) */
-#define SPK_L_VOL_SEL_MASK			(0x1 << 14)
-#define SPK_L_VOL_SEL_VMID			(0x0 << 14)
-#define SPK_L_VOL_SEL_SPKMIX_L			(0x1 << 14)
-#define SPK_R_VOL_SEL_MASK			(0x1 << 6)
-#define SPK_R_VOL_SEL_VMID			(0x0 << 6)
-#define SPK_R_VOL_SEL_SPKMIX_R			(0x1 << 6)
-
-/* Headphone Output Control(0x04) */
-#define HP_L_VOL_SEL_MASK			(0x1 << 14)
-#define HP_L_VOL_SEL_VMID			(0x0 << 14)
-#define HP_L_VOL_SEL_OUTMIX_L			(0x1 << 14)
-#define HP_R_VOL_SEL_MASK			(0x1 << 6)
-#define HP_R_VOL_SEL_VMID			(0x0 << 6)
-#define HP_R_VOL_SEL_OUTMIX_R			(0x1 << 6)
-
-/* Output Control for AUXOUT/MONO(0x06) */
-#define AUXOUT_1_VOL_SEL_MASK			(0x1 << 14)
-#define AUXOUT_1_VOL_SEL_VMID			(0x0 << 14)
-#define AUXOUT_1_VOL_SEL_OUTMIX_L		(0x1 << 14)
-#define MUTE_MONO				(0x1 << 13)
-#define AUXOUT_2_VOL_SEL_MASK			(0x1 << 6)
-#define AUXOUT_2_VOL_SEL_VMID			(0x0 << 6)
-#define AUXOUT_2_VOL_SEL_OUTMIX_R		(0x1 << 6)
-
-/* Microphone Input Control 1(0x0E) */
-#define MIC1_DIFF_INPUT_CTRL			(0x1 << 15)
-#define MIC2_DIFF_INPUT_CTRL			(0x1 << 7)
-
-/* ADC Recording Mixer Control(0x14) */
-#define M_OUTMIXER_L_TO_RECMIXER_L		(0x1 << 15)
-#define M_MIC1_TO_RECMIXER_L			(0x1 << 14)
-#define M_AXIL_TO_RECMIXER_L			(0x1 << 13)
-#define M_MONO_IN_TO_RECMIXER_L		(0x1 << 12)
-#define M_OUTMIXER_R_TO_RECMIXER_R		(0x1 << 7)
-#define M_MIC2_TO_RECMIXER_R			(0x1 << 6)
-#define M_AXIR_TO_RECMIXER_R			(0x1 << 5)
-#define M_MONO_IN_TO_RECMIXER_R		(0x1 << 4)
-
-/* Left Output Mixer Control(0x1A) */
-#define M_RECMIXER_L_TO_OUTMIXER_L		(0x1 << 15)
-#define M_RECMIXER_R_TO_OUTMIXER_L		(0x1 << 14)
-#define M_DAC_L_TO_OUTMIXER_L			(0x1 << 13)
-#define M_MIC1_TO_OUTMIXER_L			(0x1 << 12)
-#define M_MIC2_TO_OUTMIXER_L			(0x1 << 11)
-#define M_MONO_IN_P_TO_OUTMIXER_L		(0x1 << 10)
-#define M_AXIL_TO_OUTMIXER_L			(0x1 << 9)
-#define M_AXIR_TO_OUTMIXER_L			(0x1 << 8)
-
-/* Right Output Mixer Control(0x1C) */
-#define M_RECMIXER_L_TO_OUTMIXER_R		(0x1 << 15)
-#define M_RECMIXER_R_TO_OUTMIXER_R		(0x1 << 14)
-#define M_DAC_R_TO_OUTMIXER_R			(0x1 << 13)
-#define M_MIC1_TO_OUTMIXER_R			(0x1 << 12)
-#define M_MIC2_TO_OUTMIXER_R			(0x1 << 11)
-#define M_MONO_IN_N_TO_OUTMIXER_R		(0x1 << 10)
-#define M_AXIL_TO_OUTMIXER_R			(0x1 << 9)
-#define M_AXIR_TO_OUTMIXER_R			(0x1 << 8)
-
-/* Lout Mixer Control(0x1E) */
-#define M_MIC1_TO_AXO1MIXER			(0x1 << 15)
-#define M_MIC2_TO_AXO1MIXER			(0x1 << 11)
-#define M_OUTMIXER_L_TO_AXO1MIXER		(0x1 << 7)
-#define M_OUTMIXER_R_TO_AXO1MIXER		(0x1 << 6)
-
-/* Rout Mixer Control(0x20) */
-#define M_MIC1_TO_AXO2MIXER			(0x1 << 15)
-#define M_MIC2_TO_AXO2MIXER			(0x1 << 11)
-#define M_OUTMIXER_L_TO_AXO2MIXER		(0x1 << 7)
-#define M_OUTMIXER_R_TO_AXO2MIXER		(0x1 << 6)
-
-/* Micphone Input Control 2(0x22) */
-#define MIC_BIAS_90_PRECNET_AVDD 1
-#define MIC_BIAS_75_PRECNET_AVDD 2
-
-#define MIC1_BOOST_CTRL_MASK			(0xf << 12)
-#define MIC1_BOOST_CTRL_BYPASS		(0x0 << 12)
-#define MIC1_BOOST_CTRL_20DB			(0x1 << 12)
-#define MIC1_BOOST_CTRL_24DB			(0x2 << 12)
-#define MIC1_BOOST_CTRL_30DB			(0x3 << 12)
-#define MIC1_BOOST_CTRL_35DB			(0x4 << 12)
-#define MIC1_BOOST_CTRL_40DB			(0x5 << 12)
-#define MIC1_BOOST_CTRL_34DB			(0x6 << 12)
-#define MIC1_BOOST_CTRL_50DB			(0x7 << 12)
-#define MIC1_BOOST_CTRL_52DB			(0x8 << 12)
-
-#define MIC2_BOOST_CTRL_MASK			(0xf << 8)
-#define MIC2_BOOST_CTRL_BYPASS		(0x0 << 8)
-#define MIC2_BOOST_CTRL_20DB			(0x1 << 8)
-#define MIC2_BOOST_CTRL_24DB			(0x2 << 8)
-#define MIC2_BOOST_CTRL_30DB			(0x3 << 8)
-#define MIC2_BOOST_CTRL_35DB			(0x4 << 8)
-#define MIC2_BOOST_CTRL_40DB			(0x5 << 8)
-#define MIC2_BOOST_CTRL_34DB			(0x6 << 8)
-#define MIC2_BOOST_CTRL_50DB			(0x7 << 8)
-#define MIC2_BOOST_CTRL_52DB			(0x8 << 8)
-
-#define MICBIAS1_VOLT_CTRL_MASK		(0x1 << 7)
-#define MICBIAS1_VOLT_CTRL_90P			(0x0 << 7)
-#define MICBIAS1_VOLT_CTRL_75P			(0x1 << 7)
-
-#define MICBIAS1_S_C_DET_MASK			(0x1 << 6)
-#define MICBIAS1_S_C_DET_DIS			(0x0 << 6)
-#define MICBIAS1_S_C_DET_ENA			(0x1 << 6)
-
-#define MICBIAS1_SHORT_CURR_DET_MASK		(0x3 << 4)
-#define MICBIAS1_SHORT_CURR_DET_600UA	(0x0 << 4)
-#define MICBIAS1_SHORT_CURR_DET_1500UA	(0x1 << 4)
-#define MICBIAS1_SHORT_CURR_DET_2000UA	(0x2 << 4)
-
-#define MICBIAS2_VOLT_CTRL_MASK		(0x1 << 3)
-#define MICBIAS2_VOLT_CTRL_90P			(0x0 << 3)
-#define MICBIAS2_VOLT_CTRL_75P			(0x1 << 3)
-
-#define MICBIAS2_S_C_DET_MASK			(0x1 << 2)
-#define MICBIAS2_S_C_DET_DIS			(0x0 << 2)
-#define MICBIAS2_S_C_DET_ENA			(0x1 << 2)
-
-#define MICBIAS2_SHORT_CURR_DET_MASK		(0x3)
-#define MICBIAS2_SHORT_CURR_DET_600UA	(0x0)
-#define MICBIAS2_SHORT_CURR_DET_1500UA	(0x1)
-#define MICBIAS2_SHORT_CURR_DET_2000UA	(0x2)
-
-
-/* Digital Microphone Control(0x24) */
-#define DMIC_ENA_MASK				(0x1 << 15)
-/* DMIC_ENA: DMIC to ADC Digital filter */
-#define DMIC_ENA				(0x1 << 15)
-/* DMIC_DIS: ADC mixer to ADC Digital filter */
-#define DMIC_DIS					(0x0 << 15)
-
-#define DMIC_L_CH_MUTE_MASK			(0x1 << 13)
-#define DMIC_L_CH_UNMUTE			(0x0 << 13)
-#define DMIC_L_CH_MUTE				(0x1 << 13)
-
-#define DMIC_R_CH_MUTE_MASK			(0x1 << 12)
-#define DMIC_R_CH_UNMUTE			(0x0 << 12)
-#define DMIC_R_CH_MUTE				(0x1 << 12)
-
-#define DMIC_L_CH_LATCH_MASK			(0x1 << 9)
-#define DMIC_L_CH_LATCH_RISING			(0x1 << 9)
-#define DMIC_L_CH_LATCH_FALLING		(0x0 << 9)
-
-#define DMIC_R_CH_LATCH_MASK			(0x1 << 8)
-#define DMIC_R_CH_LATCH_RISING		(0x1 << 8)
-#define DMIC_R_CH_LATCH_FALLING		(0x0 << 8)
-
-#define DMIC_CLK_CTRL_MASK			(0x3 << 4)
-#define DMIC_CLK_CTRL_TO_128FS			(0x0 << 4)
-#define DMIC_CLK_CTRL_TO_64FS			(0x1 << 4)
-#define DMIC_CLK_CTRL_TO_32FS			(0x2 << 4)
-
-/* Speaker Mixer Control(0x28) */
-#define M_RECMIXER_L_TO_SPKMIXER_L		(0x1 << 15)
-#define M_MIC1_P_TO_SPKMIXER_L		(0x1 << 14)
-#define M_DAC_L_TO_SPKMIXER_L			(0x1 << 13)
-#define M_OUTMIXER_L_TO_SPKMIXER_L		(0x1 << 12)
-
-#define M_RECMIXER_R_TO_SPKMIXER_R		(0x1 << 7)
-#define M_MIC2_P_TO_SPKMIXER_R		(0x1 << 6)
-#define M_DAC_R_TO_SPKMIXER_R			(0x1 << 5)
-#define M_OUTMIXER_R_TO_SPKMIXER_R		(0x1 << 4)
-
-/* Speaker/Mono Output Control(0x2A) */
-#define M_SPKVOL_L_TO_SPOL_MIXER		(0x1 << 15)
-#define M_SPKVOL_R_TO_SPOL_MIXER		(0x1 << 14)
-#define M_SPKVOL_L_TO_SPOR_MIXER		(0x1 << 13)
-#define M_SPKVOL_R_TO_SPOR_MIXER		(0x1 << 12)
-#define M_OUTVOL_L_TO_MONOMIXER		(0x1 << 11)
-#define M_OUTVOL_R_TO_MONOMIXER		(0x1 << 10)
-
-/* Speaker/Mono/HP Output Control(0x2C) */
-#define SPK_L_MUX_SEL_MASK			(0x3 << 14)
-#define SPK_L_MUX_SEL_SPKMIXER_L		(0x0 << 14)
-#define SPK_L_MUX_SEL_MONO_IN			(0x1 << 14)
-#define SPK_L_MUX_SEL_DAC_L			(0x3 << 14)
-
-#define SPK_R_MUX_SEL_MASK			(0x3 << 10)
-#define SPK_R_MUX_SEL_SPKMIXER_R		(0x0 << 10)
-#define SPK_R_MUX_SEL_MONO_IN			(0x1 << 10)
-#define SPK_R_MUX_SEL_DAC_R			(0x3 << 10)
-
-#define MONO_MUX_SEL_MASK			(0x3 << 6)
-#define MONO_MUX_SEL_MONOMIXER		(0x0 << 6)
-#define MONO_MUX_SEL_MONO_IN			(0x1 << 6)
-
-#define HP_L_MUX_SEL_MASK			(0x1 << 3)
-#define HP_L_MUX_SEL_HPVOL_L			(0x0 << 3)
-#define HP_L_MUX_SEL_DAC_L			(0x1 << 3)
-
-#define HP_R_MUX_SEL_MASK			(0x1 << 2)
-#define HP_R_MUX_SEL_HPVOL_R			(0x0 << 2)
-#define HP_R_MUX_SEL_DAC_R			(0x1 << 2)
-
-/* Stereo I2S Serial Data Port Control(0x34) */
-#define SDP_MODE_SEL_MASK			(0x1 << 15)
-#define SDP_MODE_SEL_MASTER			(0x0 << 15)
-#define SDP_MODE_SEL_SLAVE			(0x1 << 15)
-
-#define SDP_ADC_CPS_SEL_MASK			(0x3 << 10)
-#define SDP_ADC_CPS_SEL_OFF			(0x0 << 10)
-#define SDP_ADC_CPS_SEL_U_LAW			(0x1 << 10)
-#define SDP_ADC_CPS_SEL_A_LAW			(0x2 << 10)
-
-#define SDP_DAC_CPS_SEL_MASK			(0x3 << 8)
-#define SDP_DAC_CPS_SEL_OFF			(0x0 << 8)
-#define SDP_DAC_CPS_SEL_U_LAW			(0x1 << 8)
-#define SDP_DAC_CPS_SEL_A_LAW			(0x2 << 8)
-/* 0:Normal 1:Invert */
-#define SDP_I2S_BCLK_POL_CTRL			(0x1 << 7)
-/* 0:Normal 1:Invert */
-#define SDP_DAC_R_INV				(0x1 << 6)
-/* 0:ADC data appear at left phase of LRCK
- * 1:ADC data appear at right phase of LRCK
- */
-#define SDP_ADC_DATA_L_R_SWAP			(0x1 << 5)
-/* 0:DAC data appear at left phase of LRCK
- * 1:DAC data appear at right phase of LRCK
- */
-#define SDP_DAC_DATA_L_R_SWAP			(0x1 << 4)
-
-/* Data Length Slection */
-#define SDP_I2S_DL_MASK			(0x3 << 2)
-#define SDP_I2S_DL_16				(0x0 << 2)
-#define SDP_I2S_DL_20				(0x1 << 2)
-#define SDP_I2S_DL_24				(0x2 << 2)
-#define SDP_I2S_DL_8				(0x3 << 2)
-
-/* PCM Data Format Selection */
-#define SDP_I2S_DF_MASK			(0x3)
-#define SDP_I2S_DF_I2S				(0x0)
-#define SDP_I2S_DF_LEFT				(0x1)
-#define SDP_I2S_DF_PCM_A			(0x2)
-#define SDP_I2S_DF_PCM_B			(0x3)
-
-/* Stereo AD/DA Clock Control(0x38h) */
-#define I2S_PRE_DIV_MASK			(0x7 << 13)
-#define I2S_PRE_DIV_1				(0x0 << 13)
-#define I2S_PRE_DIV_2				(0x1 << 13)
-#define I2S_PRE_DIV_4				(0x2 << 13)
-#define I2S_PRE_DIV_8				(0x3 << 13)
-#define I2S_PRE_DIV_16				(0x4 << 13)
-#define I2S_PRE_DIV_32				(0x5 << 13)
-/* CLOCK RELATIVE OF BCLK AND LCRK */
-#define I2S_LRCK_SEL_N_BCLK_MASK		(0x1 << 12)
-#define I2S_LRCK_SEL_64_BCLK			(0x0 << 12) /* 64FS */
-#define I2S_LRCK_SEL_32_BCLK			(0x1 << 12) /* 32FS */
-
-#define DAC_OSR_SEL_MASK			(0x3 << 10)
-#define DAC_OSR_SEL_128FS			(0x3 << 10)
-#define DAC_OSR_SEL_64FS			(0x3 << 10)
-#define DAC_OSR_SEL_32FS			(0x3 << 10)
-#define DAC_OSR_SEL_16FS			(0x3 << 10)
-
-#define ADC_OSR_SEL_MASK			(0x3 << 8)
-#define ADC_OSR_SEL_128FS			(0x3 << 8)
-#define ADC_OSR_SEL_64FS			(0x3 << 8)
-#define ADC_OSR_SEL_32FS			(0x3 << 8)
-#define ADC_OSR_SEL_16FS			(0x3 << 8)
-
-#define ADDA_FILTER_CLK_SEL_256FS		(0 << 7) /* 256FS */
-#define ADDA_FILTER_CLK_SEL_384FS		(1 << 7) /* 384FS */
-
-/* Power managment addition 1 (0x3A) */
-#define PWR_MAIN_I2S_EN			(0x1 << 15)
-#define PWR_CLASS_D				(0x1 << 12)
-#define PWR_ADC_L_CLK				(0x1 << 11)
-#define PWR_ADC_R_CLK				(0x1 << 10)
-#define PWR_DAC_L_CLK				(0x1 << 9)
-#define PWR_DAC_R_CLK				(0x1 << 8)
-#define PWR_DAC_REF				(0x1 << 7)
-#define PWR_DAC_L_TO_MIXER			(0x1 << 6)
-#define PWR_DAC_R_TO_MIXER			(0x1 << 5)
-
-/* Power managment addition 2 (0x3B) */
-#define PWR_OUTMIXER_L				(0x1 << 15)
-#define PWR_OUTMIXER_R				(0x1 << 14)
-#define PWR_SPKMIXER_L				(0x1 << 13)
-#define PWR_SPKMIXER_R				(0x1 << 12)
-#define PWR_RECMIXER_L				(0x1 << 11)
-#define PWR_RECMIXER_R				(0x1 << 10)
-#define PWR_MIC1_BOOT_GAIN			(0x1 << 5)
-#define PWR_MIC2_BOOT_GAIN			(0x1 << 4)
-#define PWR_MICBIAS1_VOL			(0x1 << 3)
-#define PWR_MICBIAS2_VOL			(0x1 << 2)
-#define PWR_PLL					(0x1 << 1)
-
-/* Power managment addition 3(0x3C) */
-#define PWR_VREF				(0x1 << 15)
-#define PWR_FAST_VREF_CTRL			(0x1 << 14)
-#define PWR_MAIN_BIAS				(0x1 << 13)
-#define PWR_AXO1MIXER				(0x1 << 11)
-#define PWR_AXO2MIXER				(0x1 << 10)
-#define PWR_MONOMIXER				(0x1 << 9)
-#define PWR_MONO_DEPOP_DIS			(0x1 << 8)
-#define PWR_MONO_AMP_EN			(0x1 << 7)
-#define PWR_CHARGE_PUMP			(0x1 << 4)
-#define PWR_HP_L_AMP				(0x1 << 3)
-#define PWR_HP_R_AMP				(0x1 << 2)
-#define PWR_HP_DEPOP_DIS			(0x1 << 1)
-#define PWR_HP_AMP_DRIVING			(0x1)
-
-/* Power managment addition 4(0x3E) */
-#define PWR_SPK_L_VOL				(0x1 << 15)
-#define PWR_SPK_R_VOL				(0x1 << 14)
-#define PWR_LOUT_VOL				(0x1 << 13)
-#define PWR_ROUT_VOL				(0x1 << 12)
-#define PWR_HP_L_OUT_VOL			(0x1 << 11)
-#define PWR_HP_R_OUT_VOL			(0x1 << 10)
-#define PWR_AXIL_IN_VOL			(0x1 << 9)
-#define PWR_AXIR_IN_VOL			(0x1 << 8)
-#define PWR_MONO_IN_P_VOL			(0x1 << 7)
-#define PWR_MONO_IN_N_VOL			(0x1 << 6)
-
-/* General Purpose Control Register(0x40) */
-#define SPK_AMP_AUTO_RATIO_EN			(0x1 << 15)
-
-#define SPK_AMP_RATIO_CTRL_MASK		(0x7 << 12)
-#define SPK_AMP_RATIO_CTRL_2_34		(0x0 << 12) /* 7.40DB */
-#define SPK_AMP_RATIO_CTRL_1_99		(0x1 << 12) /* 5.99DB */
-#define SPK_AMP_RATIO_CTRL_1_68		(0x2 << 12) /* 4.50DB */
-#define SPK_AMP_RATIO_CTRL_1_56		(0x3 << 12) /* 3.86DB */
-#define SPK_AMP_RATIO_CTRL_1_44		(0x4 << 12) /* 3.16DB */
-#define SPK_AMP_RATIO_CTRL_1_27		(0x5 << 12) /* 2.10DB */
-#define SPK_AMP_RATIO_CTRL_1_09		(0x6 << 12) /* 0.80DB */
-#define SPK_AMP_RATIO_CTRL_1_00		(0x7 << 12) /* 0.00DB */
-
-#define STEREO_DAC_HI_PASS_FILT_EN		(0x1 << 11)
-#define STEREO_ADC_HI_PASS_FILT_EN		(0x1 << 10)
-/* Select ADC Wind Filter Clock type */
-#define ADC_WIND_FILT_MASK			(0x3 << 4)
-#define ADC_WIND_FILT_8_16_32K			(0x0 << 4) /* 8/16/32k */
-#define ADC_WIND_FILT_11_22_44K		(0x1 << 4) /* 11/22/44k */
-#define ADC_WIND_FILT_12_24_48K		(0x2 << 4) /* 12/24/48k */
-#define ADC_WIND_FILT_EN			(0x1 << 3)
-/* SelectADC Wind Filter Corner Frequency */
-#define ADC_WIND_CNR_FREQ_MASK		(0x7 << 0)
-#define ADC_WIND_CNR_FREQ_82_113_122		(0x0 << 0) /* 82/113/122 Hz */
-#define ADC_WIND_CNR_FREQ_102_141_153	(0x1 << 0) /* 102/141/153 Hz */
-#define ADC_WIND_CNR_FREQ_131_180_156	(0x2 << 0) /* 131/180/156 Hz */
-#define ADC_WIND_CNR_FREQ_163_225_245	(0x3 << 0) /* 163/225/245 Hz */
-#define ADC_WIND_CNR_FREQ_204_281_306	(0x4 << 0) /* 204/281/306 Hz */
-#define ADC_WIND_CNR_FREQ_261_360_392	(0x5 << 0) /* 261/360/392 Hz */
-#define ADC_WIND_CNR_FREQ_327_450_490	(0x6 << 0) /* 327/450/490 Hz */
-#define ADC_WIND_CNR_FREQ_408_563_612	(0x7 << 0) /* 408/563/612 Hz */
-
-/* Global Clock Control Register(0x42) */
-#define SYSCLK_SOUR_SEL_MASK			(0x1 << 14)
-#define SYSCLK_SOUR_SEL_MCLK			(0x0 << 14)
-#define SYSCLK_SOUR_SEL_PLL			(0x1 << 14)
-#define SYSCLK_SOUR_SEL_PLL_TCK		(0x2 << 14)
-
-#define PLLCLK_SOUR_SEL_MCLK			(0x0 << 12)
-#define PLLCLK_SOUR_SEL_BITCLK			(0x1 << 12)
-
-#define PLLCLK_PRE_DIV1				(0x0 << 11)
-#define PLLCLK_PRE_DIV2				(0x1 << 11)
-
-/* PLL Control(0x44) */
-#define PLL_CTRL_M_VAL(m)			((m)&0xf)
-#define PLL_CTRL_K_VAL(k)			(((k)&0x7) << 4)
-#define PLL_CTRL_N_VAL(n)			(((n)&0xff) << 8)
-
-/* GPIO Pin Configuration(0x4C) */
-#define GPIO_PIN_FUN_SEL_MASK			(0x1 << 15)
-#define GPIO_PIN_FUN_SEL_IRQ			(0x1 << 15)
-#define GPIO_PIN_FUN_SEL_GPIO_DIMC		(0x0 << 15)
-
-#define GPIO_DMIC_FUN_SEL_MASK		(0x1 << 3)
-#define GPIO_DMIC_FUN_SEL_DIMC		(0x1 << 3) /* GPIO pin SELECT DMIC */
-#define GPIO_DMIC_FUN_SEL_GPIO		(0x0 << 3) /* GPIO PIN SELECT GPIO */
-
-#define GPIO_PIN_CON_MASK			(0x1 << 2)
-#define GPIO_PIN_SET_INPUT			(0x0 << 2)
-#define GPIO_PIN_SET_OUTPUT			(0x1 << 2)
-
-/* De-POP function Control 1(0x54) */
-#define POW_ON_SOFT_GEN			(0x1 << 15)
-#define EN_MUTE_UNMUTE_DEPOP			(0x1 << 14)
-#define EN_DEPOP2_FOR_HP			(0x1 << 7)
-/* Power Down HPAMP_L Starts Up Signal */
-#define PD_HPAMP_L_ST_UP			(0x1 << 5)
-/* Power Down HPAMP_R Starts Up Signal */
-#define PD_HPAMP_R_ST_UP			(0x1 << 4)
-/* Enable left HP mute/unmute depop */
-#define EN_HP_L_M_UN_MUTE_DEPOP		(0x1 << 1)
-/* Enable right HP mute/unmute depop */
-#define EN_HP_R_M_UN_MUTE_DEPOP		(0x1 << 0)
-
-/* De-POP Fnction Control(0x56) */
-#define EN_ONE_BIT_DEPOP			(0x1 << 15)
-#define EN_CAP_FREE_DEPOP			(0x1 << 14)
-
-/* Jack Detect Control Register(0x5A) */
-#define JD_USE_MASK				(0x3 << 14)
-#define JD_USE_JD2				(0x3 << 14)
-#define JD_USE_JD1				(0x2 << 14)
-#define JD_USE_GPIO				(0x1 << 14)
-#define JD_OFF					(0x0 << 14)
-/* JD trigger enable for HP */
-#define JD_HP_EN				(0x1 << 11)
-#define JD_HP_TRI_MASK				(0x1 << 10)
-#define JD_HP_TRI_HI				(0x1 << 10)
-#define JD_HP_TRI_LO				(0x1 << 10)
-/* JD trigger enable for speaker LP/LN */
-#define JD_SPK_L_EN				(0x1 << 9)
-#define JD_SPK_L_TRI_MASK			(0x1 << 8)
-#define JD_SPK_L_TRI_HI				(0x1 << 8)
-#define JD_SPK_L_TRI_LO				(0x0 << 8)
-/* JD trigger enable for speaker RP/RN */
-#define JD_SPK_R_EN				(0x1 << 7)
-#define JD_SPK_R_TRI_MASK			(0x1 << 6)
-#define JD_SPK_R_TRI_HI				(0x1 << 6)
-#define JD_SPK_R_TRI_LO				(0x0 << 6)
-/* JD trigger enable for monoout */
-#define JD_MONO_EN				(0x1 << 5)
-#define JD_MONO_TRI_MASK			(0x1 << 4)
-#define JD_MONO_TRI_HI				(0x1 << 4)
-#define JD_MONO_TRI_LO				(0x0 << 4)
-/* JD trigger enable for Lout */
-#define JD_AUX_1_EN				(0x1 << 3)
-#define JD_AUX_1_MASK				(0x1 << 2)
-#define JD_AUX_1_TRI_HI				(0x1 << 2)
-#define JD_AUX_1_TRI_LO				(0x0 << 2)
-/* JD trigger enable for Rout */
-#define JD_AUX_2_EN				(0x1 << 1)
-#define JD_AUX_2_MASK				(0x1 << 0)
-#define JD_AUX_2_TRI_HI				(0x1 << 0)
-#define JD_AUX_2_TRI_LO				(0x0 << 0)
-
-/* ALC CONTROL 1(0x64) */
-#define ALC_ATTACK_RATE_MASK			(0x1F << 8)
-#define ALC_RECOVERY_RATE_MASK		(0x1F << 0)
-
-/* ALC CONTROL 2(0x65) */
-/* select Compensation gain for Noise gate function */
-#define ALC_COM_NOISE_GATE_MASK		(0xF << 0)
-
-/* ALC CONTROL 3(0x66) */
-#define ALC_FUN_MASK				(0x3 << 14)
-#define ALC_FUN_DIS				(0x0 << 14)
-#define ALC_ENA_DAC_PATH			(0x1 << 14)
-#define ALC_ENA_ADC_PATH			(0x3 << 14)
-#define ALC_PARA_UPDATE			(0x1 << 13)
-#define ALC_LIMIT_LEVEL_MASK			(0x1F << 8)
-#define ALC_NOISE_GATE_FUN_MASK		(0x1 << 7)
-#define ALC_NOISE_GATE_FUN_DIS			(0x0 << 7)
-#define ALC_NOISE_GATE_FUN_ENA		(0x1 << 7)
-/* ALC noise gate hold data function */
-#define ALC_NOISE_GATE_H_D_MASK		(0x1 << 6)
-#define ALC_NOISE_GATE_H_D_DIS		(0x0 << 6)
-#define ALC_NOISE_GATE_H_D_ENA		(0x1 << 6)
-
-/* Psedueo Stereo & Spatial Effect Block Control(0x68) */
-#define SPATIAL_CTRL_EN				(0x1 << 15)
-#define ALL_PASS_FILTER_EN			(0x1 << 14)
-#define PSEUDO_STEREO_EN			(0x1 << 13)
-#define STEREO_EXPENSION_EN			(0x1 << 12)
-/* 3D gain parameter */
-#define GAIN_3D_PARA_MASK			(0x3 << 6)
-#define GAIN_3D_PARA_1_00			(0x0 << 6) /* 3D gain 1.0 */
-#define GAIN_3D_PARA_1_50			(0x1 << 6) /* 3D gain 1.5 */
-#define GAIN_3D_PARA_2_00			(0x2 << 6) /* 3D gain 2.0 */
-/* 3D ratio parameter */
-#define RATIO_3D_MASK				(0x3 << 4)
-#define RATIO_3D_0_0				(0x0 << 4) /* 3D ratio 0.0 */
-#define RATIO_3D_0_66				(0x1 << 4) /* 3D ratio 0.66 */
-#define RATIO_3D_1_0				(0x2 << 4) /* 3D ratio 1.0 */
-/* select samplerate for all pass filter */
-#define APF_FUN_SLE_MASK			(0x3 << 0)
-#define APF_FUN_SEL_48K			(0x3 << 0)
-#define APF_FUN_SEL_44_1K			(0x2 << 0)
-#define APF_FUN_SEL_32K			(0x1 << 0)
-#define APF_FUN_DIS				(0x0 << 0)
-
-/* EQ CONTROL 1(0x6E) */
-#define HW_EQ_PATH_SEL_MASK			(0x1 << 15)
-#define HW_EQ_PATH_SEL_DAC			(0x0 << 15)
-#define HW_EQ_PATH_SEL_ADC			(0x1 << 15)
-#define HW_EQ_UPDATE_CTRL			(0x1 << 14)
-
-#define EN_HW_EQ_HPF2				(0x1 << 5)
-#define EN_HW_EQ_HPF1				(0x1 << 4)
-#define EN_HW_EQ_BP3				(0x1 << 3)
-#define EN_HW_EQ_BP2				(0x1 << 2)
-#define EN_HW_EQ_BP1				(0x1 << 1)
-#define EN_HW_EQ_LPF				(0x1 << 0)
-
-#endif /* __RTCODEC5631_H__ */
diff --git a/sound/soc/codecs/wm8900.c b/sound/soc/codecs/wm8900.c
index 4d6c4621e7fb..449ea09a193d 100644
--- a/sound/soc/codecs/wm8900.c
+++ b/sound/soc/codecs/wm8900.c
@@ -23,28 +23,18 @@
 #include <linux/delay.h>
 #include <linux/pm.h>
 #include <linux/i2c.h>
+#include <linux/spi/spi.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
-#include <sound/soc-dapm.h>
 #include <sound/initval.h>
 #include <sound/tlv.h>
-#include <mach/gpio.h>
-#include <mach/irqs.h>
-#include <mach/rk29_iomap.h>
 
 #include "wm8900.h"
 
-
-#if 0
-#define	WM8900_DBG(x...)	printk(KERN_INFO x)
-#else
-#define	WM8900_DBG(x...)
-#endif
-
 /* WM8900 register space */
 #define WM8900_REG_RESET	0x0
 #define WM8900_REG_ID		0x0
@@ -123,8 +113,8 @@
 #define WM8900_REG_CLOCKING1_BCLK_MASK  (~0x01e)
 #define WM8900_REG_CLOCKING1_OPCLK_MASK (~0x7000)
 
-#define WM8900_REG_CLOCKING2_ADC_CLKDIV 0x1c
-#define WM8900_REG_CLOCKING2_DAC_CLKDIV 0xe0
+#define WM8900_REG_CLOCKING2_ADC_CLKDIV 0xe0
+#define WM8900_REG_CLOCKING2_DAC_CLKDIV 0x1c
 
 #define WM8900_REG_DACCTRL_MUTE          0x004
 #define WM8900_REG_DACCTRL_DAC_SB_FILT   0x100
@@ -146,38 +136,9 @@
 #define WM8900_REG_HPCTL1_HP_SHORT2      0x04
 
 #define WM8900_LRC_MASK 0xfc00
-#define SPK_CON 		RK29_PIN6_PB6
-
-#define WM8900_NO_POWEROFF /* Do not close codec except suspend or poweroff */
-
-#define WM8900_IS_SHUTDOWN	0
-#define WM8900_IS_STARTUP	1
-
-#define WM8900_WORK_NULL	0
-#define WM8900_WORK_POWERDOWN_PLAYBACK	1
-#define WM8900_WORK_POWERDOWN_CAPTURE	2
-#define WM8900_WORK_POWERDOWN_PLAYBACK_CAPTURE	3
-#define WM8900_WORK_HW_SET 4
-
-static void wm8900_work(struct work_struct *work);
-
-static struct workqueue_struct *wm8900_workq;
-static DECLARE_DELAYED_WORK(delayed_work, wm8900_work);
-static int wm8900_current_status = WM8900_IS_SHUTDOWN, wm8900_work_type = WM8900_WORK_NULL;
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-static struct snd_soc_codec_driver soc_codec_dev_wm8900;
-#endif
-static struct snd_soc_codec *wm8900_codec;
-static bool isSPKon = true;
 
 struct wm8900_priv {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	enum snd_soc_control_type control_type;
-#endif
-	struct snd_soc_codec codec;
-
-	u16 reg_cache[WM8900_MAXREG];
 
 	u32 fll_in; /* FLL input frequency */
 	u32 fll_out; /* FLL output frequency */
@@ -219,11 +180,7 @@ static const u16 wm8900_reg_defaults[WM8900_MAXREG] = {
 	/* Remaining registers all zero */
 };
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 static int wm8900_volatile_register(struct snd_soc_codec *codec, unsigned int reg)
-#else
-static int wm8900_volatile_register(unsigned int reg)
-#endif
 {
 	switch (reg) {
 	case WM8900_REG_ID:
@@ -235,144 +192,430 @@ static int wm8900_volatile_register(unsigned int reg)
 
 static void wm8900_reset(struct snd_soc_codec *codec)
 {
-	WM8900_DBG("Enter:%s, %d, codec=%p\n", __FUNCTION__, __LINE__,codec);
-
 	snd_soc_write(codec, WM8900_REG_RESET, 0);
 
 	memcpy(codec->reg_cache, wm8900_reg_defaults,
 	       sizeof(wm8900_reg_defaults));
 }
 
-void codec_set_spk(bool on)
+static int wm8900_hp_event(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
 {
-	isSPKon = on;
-	if (on) {
-#ifdef SPK_CON
-		gpio_set_value(SPK_CON, GPIO_HIGH);
-#endif
-	} else {
-#ifdef SPK_CON
-		gpio_set_value(SPK_CON, GPIO_LOW);
-#endif
-	}
-}
+	struct snd_soc_codec *codec = w->codec;
+	u16 hpctl1 = snd_soc_read(codec, WM8900_REG_HPCTL1);
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		/* Clamp headphone outputs */
+		hpctl1 = WM8900_REG_HPCTL1_HP_CLAMP_IP |
+			WM8900_REG_HPCTL1_HP_CLAMP_OP;
+		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
+		break;
+
+	case SND_SOC_DAPM_POST_PMU:
+		/* Enable the input stage */
+		hpctl1 &= ~WM8900_REG_HPCTL1_HP_CLAMP_IP;
+		hpctl1 |= WM8900_REG_HPCTL1_HP_SHORT |
+			WM8900_REG_HPCTL1_HP_SHORT2 |
+			WM8900_REG_HPCTL1_HP_IPSTAGE_ENA;
+		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
+
+		msleep(400);
+
+		/* Enable the output stage */
+		hpctl1 &= ~WM8900_REG_HPCTL1_HP_CLAMP_OP;
+		hpctl1 |= WM8900_REG_HPCTL1_HP_OPSTAGE_ENA;
+		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
+
+		/* Remove the shorts */
+		hpctl1 &= ~WM8900_REG_HPCTL1_HP_SHORT2;
+		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
+		hpctl1 &= ~WM8900_REG_HPCTL1_HP_SHORT;
+		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
+		break;
 
-EXPORT_SYMBOL_GPL(codec_set_spk);
+	case SND_SOC_DAPM_PRE_PMD:
+		/* Short the output */
+		hpctl1 |= WM8900_REG_HPCTL1_HP_SHORT;
+		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
 
-static void wm8900_powerdown(void)
-{
-	printk("Power down wm8900\n");
-#ifndef WM8900_NO_POWEROFF
-	gpio_set_value(RK29_PIN1_PD6, GPIO_LOW);
-#endif
+		/* Disable the output stage */
+		hpctl1 &= ~WM8900_REG_HPCTL1_HP_OPSTAGE_ENA;
+		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
 
-	snd_soc_write(wm8900_codec, WM8900_REG_POWER1, 0x210D);
+		/* Clamp the outputs and power down input */
+		hpctl1 |= WM8900_REG_HPCTL1_HP_CLAMP_IP |
+			WM8900_REG_HPCTL1_HP_CLAMP_OP;
+		hpctl1 &= ~WM8900_REG_HPCTL1_HP_IPSTAGE_ENA;
+		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
+		break;
 
-	if (wm8900_current_status != WM8900_IS_SHUTDOWN) {
-#ifdef SPK_CON
-		gpio_set_value(SPK_CON, GPIO_LOW);
-#endif
-		msleep(20);
-		snd_soc_write(wm8900_codec, WM8900_REG_RESET, 0);
-		wm8900_current_status = WM8900_IS_SHUTDOWN;
+	case SND_SOC_DAPM_POST_PMD:
+		/* Disable everything */
+		snd_soc_write(codec, WM8900_REG_HPCTL1, 0);
+		break;
+
+	default:
+		BUG();
 	}
+
+	return 0;
 }
 
-static void wm8900_set_hw(struct snd_soc_codec *codec)
-{
-	u16 reg;
+static const DECLARE_TLV_DB_SCALE(out_pga_tlv, -5700, 100, 0);
 
-	if (wm8900_current_status & WM8900_IS_STARTUP)
-		return;
-
-	printk("Power up wm8900\n");
-//CLK , PATH, VOL,POW.
-	
-	snd_soc_write(codec, WM8900_REG_HPCTL1, 0x30);
-	snd_soc_write(codec, WM8900_REG_POWER1, 0x0100);
-	snd_soc_write(codec, WM8900_REG_POWER3, 0x60);
-	snd_soc_write(codec, WM8900_REG_POWER1, 0x0101);
-	msleep(400);
-	snd_soc_write(codec, WM8900_REG_POWER1, 0x0109);
-	snd_soc_write(codec, WM8900_REG_ADDCTL, 0x02);
-	snd_soc_write(codec, WM8900_REG_POWER1, 0x09);
-	snd_soc_write(codec, WM8900_REG_POWER3, 0xEF);
-	snd_soc_write(codec, WM8900_REG_DACCTRL, WM8900_REG_DACCTRL_MUTE);
-	snd_soc_write(codec, WM8900_REG_LOUTMIXCTL1, 0x150);
-	snd_soc_write(codec, WM8900_REG_ROUTMIXCTL1, 0x150);
-
-	snd_soc_write(codec, WM8900_REG_HPCTL1, 0xB0);
-	snd_soc_write(codec, WM8900_REG_HPCTL1, 0xF0);
-	snd_soc_write(codec, WM8900_REG_HPCTL1, 0xC0);
-
-	//for recorder
-	snd_soc_write(codec, WM8900_REG_POWER1, 0x210D);
-	snd_soc_write(codec, WM8900_REG_POWER2, 0xC1AF);
-
-	snd_soc_write(codec, WM8900_REG_LADC_DV, 0x01C0);
-	snd_soc_write(codec, WM8900_REG_RADC_DV, 0x01C0);
-
-	snd_soc_write(codec, WM8900_REG_INCTL, 0x0040);
-
-	snd_soc_write(codec, WM8900_REG_LINVOL, 0x011A);
-	snd_soc_write(codec, WM8900_REG_RINVOL, 0x011A);
-	snd_soc_write(codec, WM8900_REG_INBOOSTMIX1, 0x0042);
-	snd_soc_write(codec, WM8900_REG_INBOOSTMIX2, 0x0042);
-	snd_soc_write(codec, WM8900_REG_ADCPATH, 0x0055);
+static const DECLARE_TLV_DB_SCALE(out_mix_tlv, -1500, 300, 0);
 
-	reg = snd_soc_read(codec, WM8900_REG_DACCTRL);
+static const DECLARE_TLV_DB_SCALE(in_boost_tlv, -1200, 600, 0);
 
-	reg &= ~WM8900_REG_DACCTRL_MUTE;
-	snd_soc_write(codec, WM8900_REG_DACCTRL, reg);
+static const DECLARE_TLV_DB_SCALE(in_pga_tlv, -1200, 100, 0);
 
-	snd_soc_write(codec, WM8900_REG_LOUT1CTL, 0x130);
-	snd_soc_write(codec, WM8900_REG_ROUT1CTL, 0x130);
+static const DECLARE_TLV_DB_SCALE(dac_boost_tlv, 0, 600, 0);
 
-	/* Turn up vol slowly, for HP out pop noise */
+static const DECLARE_TLV_DB_SCALE(dac_tlv, -7200, 75, 1);
 
-	for (reg = 0; reg <= 0x33; reg += 0x10) {
-			snd_soc_write(codec, WM8900_REG_LOUT2CTL, 0x100 + reg);
-			snd_soc_write(codec, WM8900_REG_ROUT2CTL, 0x100 + reg);
-			msleep(5);
-	}
-	snd_soc_write(codec, WM8900_REG_LOUT2CTL, 0x133);
-	snd_soc_write(codec, WM8900_REG_ROUT2CTL, 0x133);
+static const DECLARE_TLV_DB_SCALE(adc_svol_tlv, -3600, 300, 0);
 
-	msleep(20);
+static const DECLARE_TLV_DB_SCALE(adc_tlv, -7200, 75, 1);
 
-#ifdef SPK_CON
-	if (isSPKon) {
-		gpio_set_value(SPK_CON, GPIO_HIGH);
-	}
-#endif
-#ifndef WM8900_NO_POWEROFF
-	msleep(350);
-	gpio_set_value(RK29_PIN1_PD6, GPIO_HIGH);
-#endif
-	wm8900_current_status |= WM8900_IS_STARTUP;
-}
+static const char *mic_bias_level_txt[] = { "0.9*AVDD", "0.65*AVDD" };
+
+static const struct soc_enum mic_bias_level =
+SOC_ENUM_SINGLE(WM8900_REG_INCTL, 8, 2, mic_bias_level_txt);
+
+static const char *dac_mute_rate_txt[] = { "Fast", "Slow" };
+
+static const struct soc_enum dac_mute_rate =
+SOC_ENUM_SINGLE(WM8900_REG_DACCTRL, 7, 2, dac_mute_rate_txt);
+
+static const char *dac_deemphasis_txt[] = {
+	"Disabled", "32kHz", "44.1kHz", "48kHz"
+};
+
+static const struct soc_enum dac_deemphasis =
+SOC_ENUM_SINGLE(WM8900_REG_DACCTRL, 4, 4, dac_deemphasis_txt);
+
+static const char *adc_hpf_cut_txt[] = {
+	"Hi-fi mode", "Voice mode 1", "Voice mode 2", "Voice mode 3"
+};
+
+static const struct soc_enum adc_hpf_cut =
+SOC_ENUM_SINGLE(WM8900_REG_ADCCTRL, 5, 4, adc_hpf_cut_txt);
+
+static const char *lr_txt[] = {
+	"Left", "Right"
+};
+
+static const struct soc_enum aifl_src =
+SOC_ENUM_SINGLE(WM8900_REG_AUDIO1, 15, 2, lr_txt);
+
+static const struct soc_enum aifr_src =
+SOC_ENUM_SINGLE(WM8900_REG_AUDIO1, 14, 2, lr_txt);
+
+static const struct soc_enum dacl_src =
+SOC_ENUM_SINGLE(WM8900_REG_AUDIO2, 15, 2, lr_txt);
+
+static const struct soc_enum dacr_src =
+SOC_ENUM_SINGLE(WM8900_REG_AUDIO2, 14, 2, lr_txt);
+
+static const char *sidetone_txt[] = {
+	"Disabled", "Left ADC", "Right ADC"
+};
+
+static const struct soc_enum dacl_sidetone =
+SOC_ENUM_SINGLE(WM8900_REG_SIDETONE, 2, 3, sidetone_txt);
+
+static const struct soc_enum dacr_sidetone =
+SOC_ENUM_SINGLE(WM8900_REG_SIDETONE, 0, 3, sidetone_txt);
+
+static const struct snd_kcontrol_new wm8900_snd_controls[] = {
+SOC_ENUM("Mic Bias Level", mic_bias_level),
+
+SOC_SINGLE_TLV("Left Input PGA Volume", WM8900_REG_LINVOL, 0, 31, 0,
+	       in_pga_tlv),
+SOC_SINGLE("Left Input PGA Switch", WM8900_REG_LINVOL, 6, 1, 1),
+SOC_SINGLE("Left Input PGA ZC Switch", WM8900_REG_LINVOL, 7, 1, 0),
+
+SOC_SINGLE_TLV("Right Input PGA Volume", WM8900_REG_RINVOL, 0, 31, 0,
+	       in_pga_tlv),
+SOC_SINGLE("Right Input PGA Switch", WM8900_REG_RINVOL, 6, 1, 1),
+SOC_SINGLE("Right Input PGA ZC Switch", WM8900_REG_RINVOL, 7, 1, 0),
+
+SOC_SINGLE("DAC Soft Mute Switch", WM8900_REG_DACCTRL, 6, 1, 1),
+SOC_ENUM("DAC Mute Rate", dac_mute_rate),
+SOC_SINGLE("DAC Mono Switch", WM8900_REG_DACCTRL, 9, 1, 0),
+SOC_ENUM("DAC Deemphasis", dac_deemphasis),
+SOC_SINGLE("DAC Sigma-Delta Modulator Clock Switch", WM8900_REG_DACCTRL,
+	   12, 1, 0),
+
+SOC_SINGLE("ADC HPF Switch", WM8900_REG_ADCCTRL, 8, 1, 0),
+SOC_ENUM("ADC HPF Cut-Off", adc_hpf_cut),
+SOC_DOUBLE("ADC Invert Switch", WM8900_REG_ADCCTRL, 1, 0, 1, 0),
+SOC_SINGLE_TLV("Left ADC Sidetone Volume", WM8900_REG_SIDETONE, 9, 12, 0,
+	       adc_svol_tlv),
+SOC_SINGLE_TLV("Right ADC Sidetone Volume", WM8900_REG_SIDETONE, 5, 12, 0,
+	       adc_svol_tlv),
+SOC_ENUM("Left Digital Audio Source", aifl_src),
+SOC_ENUM("Right Digital Audio Source", aifr_src),
+
+SOC_SINGLE_TLV("DAC Input Boost Volume", WM8900_REG_AUDIO2, 10, 4, 0,
+	       dac_boost_tlv),
+SOC_ENUM("Left DAC Source", dacl_src),
+SOC_ENUM("Right DAC Source", dacr_src),
+SOC_ENUM("Left DAC Sidetone", dacl_sidetone),
+SOC_ENUM("Right DAC Sidetone", dacr_sidetone),
+SOC_DOUBLE("DAC Invert Switch", WM8900_REG_DACCTRL, 1, 0, 1, 0),
+
+SOC_DOUBLE_R_TLV("Digital Playback Volume",
+		 WM8900_REG_LDAC_DV, WM8900_REG_RDAC_DV,
+		 1, 96, 0, dac_tlv),
+SOC_DOUBLE_R_TLV("Digital Capture Volume",
+		 WM8900_REG_LADC_DV, WM8900_REG_RADC_DV, 1, 119, 0, adc_tlv),
+
+SOC_SINGLE_TLV("LINPUT3 Bypass Volume", WM8900_REG_LOUTMIXCTL1, 4, 7, 0,
+	       out_mix_tlv),
+SOC_SINGLE_TLV("RINPUT3 Bypass Volume", WM8900_REG_ROUTMIXCTL1, 4, 7, 0,
+	       out_mix_tlv),
+SOC_SINGLE_TLV("Left AUX Bypass Volume", WM8900_REG_AUXOUT_CTL, 4, 7, 0,
+	       out_mix_tlv),
+SOC_SINGLE_TLV("Right AUX Bypass Volume", WM8900_REG_AUXOUT_CTL, 0, 7, 0,
+	       out_mix_tlv),
+
+SOC_SINGLE_TLV("LeftIn to RightOut Mixer Volume", WM8900_REG_BYPASS1, 0, 7, 0,
+	       out_mix_tlv),
+SOC_SINGLE_TLV("LeftIn to LeftOut Mixer Volume", WM8900_REG_BYPASS1, 4, 7, 0,
+	       out_mix_tlv),
+SOC_SINGLE_TLV("RightIn to LeftOut Mixer Volume", WM8900_REG_BYPASS2, 0, 7, 0,
+	       out_mix_tlv),
+SOC_SINGLE_TLV("RightIn to RightOut Mixer Volume", WM8900_REG_BYPASS2, 4, 7, 0,
+	       out_mix_tlv),
+
+SOC_SINGLE_TLV("IN2L Boost Volume", WM8900_REG_INBOOSTMIX1, 0, 3, 0,
+	       in_boost_tlv),
+SOC_SINGLE_TLV("IN3L Boost Volume", WM8900_REG_INBOOSTMIX1, 4, 3, 0,
+	       in_boost_tlv),
+SOC_SINGLE_TLV("IN2R Boost Volume", WM8900_REG_INBOOSTMIX2, 0, 3, 0,
+	       in_boost_tlv),
+SOC_SINGLE_TLV("IN3R Boost Volume", WM8900_REG_INBOOSTMIX2, 4, 3, 0,
+	       in_boost_tlv),
+SOC_SINGLE_TLV("Left AUX Boost Volume", WM8900_REG_AUXBOOST, 4, 3, 0,
+	       in_boost_tlv),
+SOC_SINGLE_TLV("Right AUX Boost Volume", WM8900_REG_AUXBOOST, 0, 3, 0,
+	       in_boost_tlv),
+
+SOC_DOUBLE_R_TLV("LINEOUT1 Volume", WM8900_REG_LOUT1CTL, WM8900_REG_ROUT1CTL,
+	       0, 63, 0, out_pga_tlv),
+SOC_DOUBLE_R("LINEOUT1 Switch", WM8900_REG_LOUT1CTL, WM8900_REG_ROUT1CTL,
+	     6, 1, 1),
+SOC_DOUBLE_R("LINEOUT1 ZC Switch", WM8900_REG_LOUT1CTL, WM8900_REG_ROUT1CTL,
+	     7, 1, 0),
+
+SOC_DOUBLE_R_TLV("LINEOUT2 Volume",
+		 WM8900_REG_LOUT2CTL, WM8900_REG_ROUT2CTL,
+		 0, 63, 0, out_pga_tlv),
+SOC_DOUBLE_R("LINEOUT2 Switch",
+	     WM8900_REG_LOUT2CTL, WM8900_REG_ROUT2CTL, 6, 1, 1),
+SOC_DOUBLE_R("LINEOUT2 ZC Switch",
+	     WM8900_REG_LOUT2CTL, WM8900_REG_ROUT2CTL, 7, 1, 0),
+SOC_SINGLE("LINEOUT2 LP -12dB", WM8900_REG_LOUTMIXCTL1,
+	   0, 1, 1),
+
+};
+
+static const struct snd_kcontrol_new wm8900_dapm_loutput2_control =
+SOC_DAPM_SINGLE("LINEOUT2L Switch", WM8900_REG_POWER3, 6, 1, 0);
+
+static const struct snd_kcontrol_new wm8900_dapm_routput2_control =
+SOC_DAPM_SINGLE("LINEOUT2R Switch", WM8900_REG_POWER3, 5, 1, 0);
+
+static const struct snd_kcontrol_new wm8900_loutmix_controls[] = {
+SOC_DAPM_SINGLE("LINPUT3 Bypass Switch", WM8900_REG_LOUTMIXCTL1, 7, 1, 0),
+SOC_DAPM_SINGLE("AUX Bypass Switch", WM8900_REG_AUXOUT_CTL, 7, 1, 0),
+SOC_DAPM_SINGLE("Left Input Mixer Switch", WM8900_REG_BYPASS1, 7, 1, 0),
+SOC_DAPM_SINGLE("Right Input Mixer Switch", WM8900_REG_BYPASS2, 3, 1, 0),
+SOC_DAPM_SINGLE("DACL Switch", WM8900_REG_LOUTMIXCTL1, 8, 1, 0),
+};
+
+static const struct snd_kcontrol_new wm8900_routmix_controls[] = {
+SOC_DAPM_SINGLE("RINPUT3 Bypass Switch", WM8900_REG_ROUTMIXCTL1, 7, 1, 0),
+SOC_DAPM_SINGLE("AUX Bypass Switch", WM8900_REG_AUXOUT_CTL, 3, 1, 0),
+SOC_DAPM_SINGLE("Left Input Mixer Switch", WM8900_REG_BYPASS1, 3, 1, 0),
+SOC_DAPM_SINGLE("Right Input Mixer Switch", WM8900_REG_BYPASS2, 7, 1, 0),
+SOC_DAPM_SINGLE("DACR Switch", WM8900_REG_ROUTMIXCTL1, 8, 1, 0),
+};
+
+static const struct snd_kcontrol_new wm8900_linmix_controls[] = {
+SOC_DAPM_SINGLE("LINPUT2 Switch", WM8900_REG_INBOOSTMIX1, 2, 1, 1),
+SOC_DAPM_SINGLE("LINPUT3 Switch", WM8900_REG_INBOOSTMIX1, 6, 1, 1),
+SOC_DAPM_SINGLE("AUX Switch", WM8900_REG_AUXBOOST, 6, 1, 1),
+SOC_DAPM_SINGLE("Input PGA Switch", WM8900_REG_ADCPATH, 6, 1, 0),
+};
+
+static const struct snd_kcontrol_new wm8900_rinmix_controls[] = {
+SOC_DAPM_SINGLE("RINPUT2 Switch", WM8900_REG_INBOOSTMIX2, 2, 1, 1),
+SOC_DAPM_SINGLE("RINPUT3 Switch", WM8900_REG_INBOOSTMIX2, 6, 1, 1),
+SOC_DAPM_SINGLE("AUX Switch", WM8900_REG_AUXBOOST, 2, 1, 1),
+SOC_DAPM_SINGLE("Input PGA Switch", WM8900_REG_ADCPATH, 2, 1, 0),
+};
+
+static const struct snd_kcontrol_new wm8900_linpga_controls[] = {
+SOC_DAPM_SINGLE("LINPUT1 Switch", WM8900_REG_INCTL, 6, 1, 0),
+SOC_DAPM_SINGLE("LINPUT2 Switch", WM8900_REG_INCTL, 5, 1, 0),
+SOC_DAPM_SINGLE("LINPUT3 Switch", WM8900_REG_INCTL, 4, 1, 0),
+};
+
+static const struct snd_kcontrol_new wm8900_rinpga_controls[] = {
+SOC_DAPM_SINGLE("RINPUT1 Switch", WM8900_REG_INCTL, 2, 1, 0),
+SOC_DAPM_SINGLE("RINPUT2 Switch", WM8900_REG_INCTL, 1, 1, 0),
+SOC_DAPM_SINGLE("RINPUT3 Switch", WM8900_REG_INCTL, 0, 1, 0),
+};
+
+static const char *wm9700_lp_mux[] = { "Disabled", "Enabled" };
+
+static const struct soc_enum wm8900_lineout2_lp_mux =
+SOC_ENUM_SINGLE(WM8900_REG_LOUTMIXCTL1, 1, 2, wm9700_lp_mux);
+
+static const struct snd_kcontrol_new wm8900_lineout2_lp =
+SOC_DAPM_ENUM("Route", wm8900_lineout2_lp_mux);
+
+static const struct snd_soc_dapm_widget wm8900_dapm_widgets[] = {
+
+/* Externally visible pins */
+SND_SOC_DAPM_OUTPUT("LINEOUT1L"),
+SND_SOC_DAPM_OUTPUT("LINEOUT1R"),
+SND_SOC_DAPM_OUTPUT("LINEOUT2L"),
+SND_SOC_DAPM_OUTPUT("LINEOUT2R"),
+SND_SOC_DAPM_OUTPUT("HP_L"),
+SND_SOC_DAPM_OUTPUT("HP_R"),
+
+SND_SOC_DAPM_INPUT("RINPUT1"),
+SND_SOC_DAPM_INPUT("LINPUT1"),
+SND_SOC_DAPM_INPUT("RINPUT2"),
+SND_SOC_DAPM_INPUT("LINPUT2"),
+SND_SOC_DAPM_INPUT("RINPUT3"),
+SND_SOC_DAPM_INPUT("LINPUT3"),
+SND_SOC_DAPM_INPUT("AUX"),
+
+SND_SOC_DAPM_VMID("VMID"),
+
+/* Input */
+SND_SOC_DAPM_MIXER("Left Input PGA", WM8900_REG_POWER2, 3, 0,
+		   wm8900_linpga_controls,
+		   ARRAY_SIZE(wm8900_linpga_controls)),
+SND_SOC_DAPM_MIXER("Right Input PGA", WM8900_REG_POWER2, 2, 0,
+		   wm8900_rinpga_controls,
+		   ARRAY_SIZE(wm8900_rinpga_controls)),
+
+SND_SOC_DAPM_MIXER("Left Input Mixer", WM8900_REG_POWER2, 5, 0,
+		   wm8900_linmix_controls,
+		   ARRAY_SIZE(wm8900_linmix_controls)),
+SND_SOC_DAPM_MIXER("Right Input Mixer", WM8900_REG_POWER2, 4, 0,
+		   wm8900_rinmix_controls,
+		   ARRAY_SIZE(wm8900_rinmix_controls)),
+
+SND_SOC_DAPM_MICBIAS("Mic Bias", WM8900_REG_POWER1, 4, 0),
+
+SND_SOC_DAPM_ADC("ADCL", "Left HiFi Capture", WM8900_REG_POWER2, 1, 0),
+SND_SOC_DAPM_ADC("ADCR", "Right HiFi Capture", WM8900_REG_POWER2, 0, 0),
+
+/* Output */
+SND_SOC_DAPM_DAC("DACL", "Left HiFi Playback", WM8900_REG_POWER3, 1, 0),
+SND_SOC_DAPM_DAC("DACR", "Right HiFi Playback", WM8900_REG_POWER3, 0, 0),
+
+SND_SOC_DAPM_PGA_E("Headphone Amplifier", WM8900_REG_POWER3, 7, 0, NULL, 0,
+		   wm8900_hp_event,
+		   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+		   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+
+SND_SOC_DAPM_PGA("LINEOUT1L PGA", WM8900_REG_POWER2, 8, 0, NULL, 0),
+SND_SOC_DAPM_PGA("LINEOUT1R PGA", WM8900_REG_POWER2, 7, 0, NULL, 0),
+
+SND_SOC_DAPM_MUX("LINEOUT2 LP", SND_SOC_NOPM, 0, 0, &wm8900_lineout2_lp),
+SND_SOC_DAPM_PGA("LINEOUT2L PGA", WM8900_REG_POWER3, 6, 0, NULL, 0),
+SND_SOC_DAPM_PGA("LINEOUT2R PGA", WM8900_REG_POWER3, 5, 0, NULL, 0),
+
+SND_SOC_DAPM_MIXER("Left Output Mixer", WM8900_REG_POWER3, 3, 0,
+		   wm8900_loutmix_controls,
+		   ARRAY_SIZE(wm8900_loutmix_controls)),
+SND_SOC_DAPM_MIXER("Right Output Mixer", WM8900_REG_POWER3, 2, 0,
+		   wm8900_routmix_controls,
+		   ARRAY_SIZE(wm8900_routmix_controls)),
+};
+
+/* Target, Path, Source */
+static const struct snd_soc_dapm_route audio_map[] = {
+/* Inputs */
+{"Left Input PGA", "LINPUT1 Switch", "LINPUT1"},
+{"Left Input PGA", "LINPUT2 Switch", "LINPUT2"},
+{"Left Input PGA", "LINPUT3 Switch", "LINPUT3"},
+
+{"Right Input PGA", "RINPUT1 Switch", "RINPUT1"},
+{"Right Input PGA", "RINPUT2 Switch", "RINPUT2"},
+{"Right Input PGA", "RINPUT3 Switch", "RINPUT3"},
+
+{"Left Input Mixer", "LINPUT2 Switch", "LINPUT2"},
+{"Left Input Mixer", "LINPUT3 Switch", "LINPUT3"},
+{"Left Input Mixer", "AUX Switch", "AUX"},
+{"Left Input Mixer", "Input PGA Switch", "Left Input PGA"},
+
+{"Right Input Mixer", "RINPUT2 Switch", "RINPUT2"},
+{"Right Input Mixer", "RINPUT3 Switch", "RINPUT3"},
+{"Right Input Mixer", "AUX Switch", "AUX"},
+{"Right Input Mixer", "Input PGA Switch", "Right Input PGA"},
+
+{"ADCL", NULL, "Left Input Mixer"},
+{"ADCR", NULL, "Right Input Mixer"},
+
+/* Outputs */
+{"LINEOUT1L", NULL, "LINEOUT1L PGA"},
+{"LINEOUT1L PGA", NULL, "Left Output Mixer"},
+{"LINEOUT1R", NULL, "LINEOUT1R PGA"},
+{"LINEOUT1R PGA", NULL, "Right Output Mixer"},
+
+{"LINEOUT2L PGA", NULL, "Left Output Mixer"},
+{"LINEOUT2 LP", "Disabled", "LINEOUT2L PGA"},
+{"LINEOUT2 LP", "Enabled", "Left Output Mixer"},
+{"LINEOUT2L", NULL, "LINEOUT2 LP"},
+
+{"LINEOUT2R PGA", NULL, "Right Output Mixer"},
+{"LINEOUT2 LP", "Disabled", "LINEOUT2R PGA"},
+{"LINEOUT2 LP", "Enabled", "Right Output Mixer"},
+{"LINEOUT2R", NULL, "LINEOUT2 LP"},
+
+{"Left Output Mixer", "LINPUT3 Bypass Switch", "LINPUT3"},
+{"Left Output Mixer", "AUX Bypass Switch", "AUX"},
+{"Left Output Mixer", "Left Input Mixer Switch", "Left Input Mixer"},
+{"Left Output Mixer", "Right Input Mixer Switch", "Right Input Mixer"},
+{"Left Output Mixer", "DACL Switch", "DACL"},
+
+{"Right Output Mixer", "RINPUT3 Bypass Switch", "RINPUT3"},
+{"Right Output Mixer", "AUX Bypass Switch", "AUX"},
+{"Right Output Mixer", "Left Input Mixer Switch", "Left Input Mixer"},
+{"Right Output Mixer", "Right Input Mixer Switch", "Right Input Mixer"},
+{"Right Output Mixer", "DACR Switch", "DACR"},
+
+/* Note that the headphone output stage needs to be connected
+ * externally to LINEOUT2 via DC blocking capacitors.  Other
+ * configurations are not supported.
+ *
+ * Note also that left and right headphone paths are treated as a
+ * mono path.
+ */
+{"Headphone Amplifier", NULL, "LINEOUT2 LP"},
+{"Headphone Amplifier", NULL, "LINEOUT2 LP"},
+{"HP_L", NULL, "Headphone Amplifier"},
+{"HP_R", NULL, "Headphone Amplifier"},
+};
 
-static void wm8900_work(struct work_struct *work)
+static int wm8900_add_widgets(struct snd_soc_codec *codec)
 {
-        WM8900_DBG("Enter::wm8900_work : wm8900_work_type = %d\n", wm8900_work_type);
-
-        switch (wm8900_work_type) {
-        case WM8900_WORK_POWERDOWN_PLAYBACK :
-                break;
-        case WM8900_WORK_POWERDOWN_CAPTURE:
-                snd_soc_write(wm8900_codec, WM8900_REG_POWER1, 0x210D);
-                break;
-        case WM8900_WORK_POWERDOWN_PLAYBACK_CAPTURE:
-                wm8900_powerdown();
-                break;
-        case WM8900_WORK_HW_SET:
-                wm8900_set_hw(wm8900_codec);
-                break;
-        default:
-                break;
-        }
-
-        wm8900_work_type = WM8900_WORK_NULL;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	snd_soc_dapm_new_controls(dapm, wm8900_dapm_widgets,
+				  ARRAY_SIZE(wm8900_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+
+	return 0;
 }
 
 static int wm8900_hw_params(struct snd_pcm_substream *substream,
@@ -380,16 +623,9 @@ static int wm8900_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_dai *dai)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	struct snd_soc_codec *codec = rtd->codec;
-#else
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_codec *codec = socdev->card->codec;
-#endif
 	u16 reg;
 
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-
 	reg = snd_soc_read(codec, WM8900_REG_AUDIO1) & ~0x60;
 
 	switch (params_format(params)) {
@@ -410,6 +646,17 @@ static int wm8900_hw_params(struct snd_pcm_substream *substream,
 
 	snd_soc_write(codec, WM8900_REG_AUDIO1, reg);
 
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		reg = snd_soc_read(codec, WM8900_REG_DACCTRL);
+
+		if (params_rate(params) <= 24000)
+			reg |= WM8900_REG_DACCTRL_DAC_SB_FILT;
+		else
+			reg &= ~WM8900_REG_DACCTRL_DAC_SB_FILT;
+
+		snd_soc_write(codec, WM8900_REG_DACCTRL, reg);
+	}
+
 	return 0;
 }
 
@@ -433,10 +680,8 @@ static int fll_factors(struct _fll_div *fll_div, unsigned int Fref,
 	unsigned int K, Ndiv, Nmod, target;
 	unsigned int div;
 
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-
 	BUG_ON(!Fout);
-        
+
 	/* The FLL must run at 90-100MHz which is then scaled down to
 	 * the output value by FLLCLK_DIV. */
 	target = Fout;
@@ -499,8 +744,6 @@ static int wm8900_set_fll(struct snd_soc_codec *codec,
 	struct _fll_div fll_div;
 	unsigned int reg;
 
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-
 	if (wm8900->fll_in == freq_in && wm8900->fll_out == freq_out)
 		return 0;
 
@@ -568,9 +811,6 @@ static int wm8900_set_fll(struct snd_soc_codec *codec,
 static int wm8900_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,
 		int source, unsigned int freq_in, unsigned int freq_out)
 {
-
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-
 	return wm8900_set_fll(codec_dai->codec, pll_id, freq_in, freq_out);
 }
 
@@ -580,8 +820,6 @@ static int wm8900_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
 	struct snd_soc_codec *codec = codec_dai->codec;
 	unsigned int reg;
 
-	WM8900_DBG("Enter:%s, %d, div_id=%d, div=%d \n", __FUNCTION__, __LINE__, div_id, div);
-
 	switch (div_id) {
 	case WM8900_BCLK_DIV:
 		reg = snd_soc_read(codec, WM8900_REG_CLOCKING1);
@@ -632,8 +870,6 @@ static int wm8900_set_dai_fmt(struct snd_soc_dai *codec_dai,
 	struct snd_soc_codec *codec = codec_dai->codec;
 	unsigned int clocking1, aif1, aif3, aif4;
 
-	WM8900_DBG("Enter:%s, %d, fmt=0x%08X \n", __FUNCTION__, __LINE__, fmt);
-
 	clocking1 = snd_soc_read(codec, WM8900_REG_CLOCKING1);
 	aif1 = snd_soc_read(codec, WM8900_REG_AUDIO1);
 	aif3 = snd_soc_read(codec, WM8900_REG_AUDIO3);
@@ -743,139 +979,24 @@ static int wm8900_set_dai_fmt(struct snd_soc_dai *codec_dai,
 
 static int wm8900_digital_mute(struct snd_soc_dai *codec_dai, int mute)
 {
-	WM8900_DBG("Enter:%s, %d , mute = %d \n", __FUNCTION__, __LINE__, mute);
-
-	return 0;
-}
-
-static int wm8900_startup(struct snd_pcm_substream *substream,
-			  struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	struct snd_soc_codec *codec = rtd->codec;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-#else
-	struct snd_soc_device *socdev = rtd->socdev;
-	struct snd_soc_codec *codec = socdev->card->codec;
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
-#endif
-
-	WM8900_DBG("Enter::%s----%d substream->stream:%s \n",__FUNCTION__,__LINE__,
-		   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "PLAYBACK":"CAPTURE");
-
-	cancel_delayed_work_sync(&delayed_work);
-	wm8900_work_type = WM8900_WORK_NULL;
-
-	wm8900_set_hw(codec);
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE ||
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	     codec_dai->capture_active) {
-#else
-	     codec_dai->capture.active) {
-#endif
-		snd_soc_write(codec, WM8900_REG_POWER1, 0x211D);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	} else if (!codec_dai->capture_active) {
-#else
-	} else if (!codec_dai->capture.active) {
-#endif
-		snd_soc_write(codec, WM8900_REG_POWER1, 0x210D);
-	}
-
-	return 0;
-}
-
-static void wm8900_shutdown(struct snd_pcm_substream *substream,
-			    struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-#else
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
-#endif
-
-	WM8900_DBG("Enter::%s----%d substream->stream:%s \n",__FUNCTION__,__LINE__,
-		   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "PLAYBACK":"CAPTURE");
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
-	    wm8900_work_type == WM8900_WORK_NULL) {
-		cancel_delayed_work_sync(&delayed_work);
-		wm8900_work_type = WM8900_WORK_POWERDOWN_CAPTURE;
-		queue_delayed_work(wm8900_workq, &delayed_work,
-			msecs_to_jiffies(3000));
-	}
-#ifdef WM8900_NO_POWEROFF
-	return; /* Let codec not going to power off for pop noise */
-#endif
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	if (!codec_dai->capture_active && !codec_dai->playback_active) {
-#else
-	if (!codec_dai->capture.active && !codec_dai->playback.active) {
-#endif
-
-		cancel_delayed_work_sync(&delayed_work);
-		wm8900_work_type = WM8900_WORK_NULL;
-
-		/* If codec is already shutdown, return */
-		if (wm8900_current_status == WM8900_IS_SHUTDOWN)
-			return;
-
-		WM8900_DBG("Is going to power down wm8900\n");
-
-		wm8900_work_type = WM8900_WORK_POWERDOWN_PLAYBACK_CAPTURE;
-
-		/* If codec is useless, queue work to close it */
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			queue_delayed_work(wm8900_workq, &delayed_work,
-				msecs_to_jiffies(1000));
-		} else {
-			queue_delayed_work(wm8900_workq, &delayed_work,
-				msecs_to_jiffies(3000));
-		}
-	}
-}
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 reg;
 
-static int wm8900_trigger(struct snd_pcm_substream *substream,
-			  int status,
-			  struct snd_soc_dai *dai)
-{	
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-#else
-	struct snd_soc_dai_link *machine = rtd->dai;
-	struct snd_soc_dai *codec_dai = machine->codec_dai;
-#endif
+	reg = snd_soc_read(codec, WM8900_REG_DACCTRL);
 
-	WM8900_DBG("Enter::%s----%d status = %d substream->stream:%s \n",__FUNCTION__, __LINE__, status,
-		   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "PLAYBACK":"CAPTURE");	
+	if (mute)
+		reg |= WM8900_REG_DACCTRL_MUTE;
+	else
+		reg &= ~WM8900_REG_DACCTRL_MUTE;
 
-	if(status == 1 || status == 0){
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-			codec_dai->playback_active = status;
-#else
-			codec_dai->playback.active = status;
-#endif
-		}else{
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-			codec_dai->capture_active = status;
-#else
-			codec_dai->capture.active = status;
-#endif
-		}
-	}
+	snd_soc_write(codec, WM8900_REG_DACCTRL, reg);
 
 	return 0;
 }
 
-#define WM8900_RATES SNDRV_PCM_RATE_44100
+#define WM8900_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+		      SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
+		      SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
 
 #define WM8900_PCM_FORMATS \
 	(SNDRV_PCM_FORMAT_S16_LE | SNDRV_PCM_FORMAT_S20_3LE | \
@@ -887,17 +1008,10 @@ static struct snd_soc_dai_ops wm8900_dai_ops = {
 	.set_pll	= wm8900_set_dai_pll,
 	.set_fmt	= wm8900_set_dai_fmt,
 	.digital_mute	= wm8900_digital_mute,
-	.startup	= wm8900_startup,
-	.shutdown	= wm8900_shutdown,
-	.trigger	= wm8900_trigger,
 };
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 static struct snd_soc_dai_driver wm8900_dai = {
-#else
-struct snd_soc_dai wm8900_dai = {
-#endif
-	.name = "WM8900 HiFi",
+	.name = "wm8900-hifi",
 	.playback = {
 		.stream_name = "HiFi Playback",
 		.channels_min = 1,
@@ -914,23 +1028,12 @@ struct snd_soc_dai wm8900_dai = {
 	 },
 	.ops = &wm8900_dai_ops,
 };
-EXPORT_SYMBOL_GPL(wm8900_dai);
 
 static int wm8900_set_bias_level(struct snd_soc_codec *codec,
 				 enum snd_soc_bias_level level)
 {
 	u16 reg;
 
-	WM8900_DBG("Enter:%s, %d, level=0x%08X \n", __FUNCTION__, __LINE__, level);
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	codec->dapm.bias_level = level;
-#else
-	codec->bias_level = level;
-#endif
-	return 0;
-#if 0
-
 	switch (level) {
 	case SND_SOC_BIAS_ON:
 		/* Enable thermal shutdown */
@@ -947,7 +1050,7 @@ static int wm8900_set_bias_level(struct snd_soc_codec *codec,
 
 	case SND_SOC_BIAS_STANDBY:
 		/* Charge capacitors if initial power up */
-		if (codec->bias_level == SND_SOC_BIAS_OFF) {
+		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
 			/* STARTUP_BIAS_ENA on */
 			snd_soc_write(codec, WM8900_REG_POWER1,
 				     WM8900_REG_POWER1_STARTUP_BIAS_ENA);
@@ -1015,44 +1118,21 @@ static int wm8900_set_bias_level(struct snd_soc_codec *codec,
 			     WM8900_REG_POWER2_SYSCLK_ENA);
 		break;
 	}
-
-	codec->bias_level = level;
+	codec->dapm.bias_level = level;
 	return 0;
-#endif
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 static int wm8900_suspend(struct snd_soc_codec *codec, pm_message_t state)
-#else
-static int wm8900_suspend(struct platform_device *pdev, pm_message_t state)
-#endif
 {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_codec *codec = socdev->card->codec;
-#endif
 	struct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);
 	int fll_out = wm8900->fll_out;
 	int fll_in  = wm8900->fll_in;
 	int ret;
 
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-
-	cancel_delayed_work_sync(&delayed_work);
-	wm8900_work_type = WM8900_WORK_NULL;
-
-#ifdef WM8900_NO_POWEROFF
-	wm8900_powerdown();
-#endif
-
 	/* Stop the FLL in an orderly fashion */
 	ret = wm8900_set_fll(codec, 0, 0, 0);
 	if (ret != 0) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 		dev_err(codec->dev, "Failed to stop FLL\n");
-#else
-		dev_err(&pdev->dev, "Failed to stop FLL\n");
-#endif
 		return ret;
 	}
 
@@ -1064,23 +1144,20 @@ static int wm8900_suspend(struct platform_device *pdev, pm_message_t state)
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 static int wm8900_resume(struct snd_soc_codec *codec)
-#else
-static int wm8900_resume(struct platform_device *pdev)
-#endif
 {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_codec *codec = socdev->card->codec;
-#endif
 	struct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);
+	u16 *cache;
+	int i, ret;
 
+	cache = kmemdup(codec->reg_cache, sizeof(wm8900_reg_defaults),
+			GFP_KERNEL);
+
+	wm8900_reset(codec);
 	wm8900_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 
 	/* Restart the FLL? */
 	if (wm8900->fll_out) {
-		int ret;
 		int fll_out = wm8900->fll_out;
 		int fll_in  = wm8900->fll_in;
 
@@ -1089,80 +1166,36 @@ static int wm8900_resume(struct platform_device *pdev)
 
 		ret = wm8900_set_fll(codec, 0, fll_in, fll_out);
 		if (ret != 0) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 			dev_err(codec->dev, "Failed to restart FLL\n");
-#else
-			dev_err(&pdev->dev, "Failed to restart FLL\n");
-#endif
 			return ret;
 		}
 	}
 
-#ifdef WM8900_NO_POWEROFF
-	if (wm8900_current_status == WM8900_IS_SHUTDOWN) {
-
-		cancel_delayed_work_sync(&delayed_work);
-		wm8900_work_type = WM8900_WORK_HW_SET;
-		queue_delayed_work(wm8900_workq, &delayed_work,
-		                   msecs_to_jiffies(1000));
-	}
-#endif
+	if (cache) {
+		for (i = 0; i < WM8900_MAXREG; i++)
+			snd_soc_write(codec, i, cache[i]);
+		kfree(cache);
+	} else
+		dev_err(codec->dev, "Unable to allocate register cache\n");
 
 	return 0;
 }
 
-#if 0
-static __devinit int wm8900_i2c_probe(struct i2c_client *i2c,
-				      const struct i2c_device_id *id)
+static int wm8900_probe(struct snd_soc_codec *codec)
 {
-	struct wm8900_priv *wm8900;
-	struct snd_soc_codec *codec;
-	unsigned int reg;
-	int ret;
-
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-        
-	wm8900 = kzalloc(sizeof(struct wm8900_priv), GFP_KERNEL);
-	if (wm8900 == NULL)
-		return -ENOMEM;
-
-	codec = &wm8900->codec;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	snd_soc_codec_set_drvdata(codec, wm8900);
-	codec->reg_cache = &wm8900->reg_cache[0];
-	codec->reg_cache_size = WM8900_MAXREG;
-#endif
-
-	mutex_init(&codec->mutex);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	INIT_LIST_HEAD(&codec->dapm_widgets);
-	INIT_LIST_HEAD(&codec->dapm_paths);
-#endif
-
-	codec->name = "WM8900";
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	codec->owner = THIS_MODULE;
-	codec->dai = &wm8900_dai;
-#endif
-	codec->num_dai = 1;
-	codec->control_data = i2c;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	codec->set_bias_level = wm8900_set_bias_level;
-	codec->volatile_register = wm8900_volatile_register;
-#endif
-	codec->dev = &i2c->dev;
+	struct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0, reg;
 
-	ret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_I2C);
+	ret = snd_soc_codec_set_cache_io(codec, 8, 16, wm8900->control_type);
 	if (ret != 0) {
-		dev_err(&i2c->dev, "Failed to set cache I/O: %d\n", ret);
-		goto err;
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
 	}
 
 	reg = snd_soc_read(codec, WM8900_REG_ID);
 	if (reg != 0x8900) {
-		dev_err(&i2c->dev, "Device is not a WM8900 - ID %x\n", reg);
-		ret = -ENODEV;
-		goto err;
+		dev_err(codec->dev, "Device is not a WM8900 - ID %x\n", reg);
+		return -ENODEV;
 	}
 
 	wm8900_reset(codec);
@@ -1170,51 +1203,101 @@ static __devinit int wm8900_i2c_probe(struct i2c_client *i2c,
 	/* Turn the chip on */
 	wm8900_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	wm8900_dai.dev = &i2c->dev;
-#endif
+	/* Latch the volume update bits */
+	snd_soc_write(codec, WM8900_REG_LINVOL,
+		      snd_soc_read(codec, WM8900_REG_LINVOL) | 0x100);
+	snd_soc_write(codec, WM8900_REG_RINVOL,
+		      snd_soc_read(codec, WM8900_REG_RINVOL) | 0x100);
+	snd_soc_write(codec, WM8900_REG_LOUT1CTL,
+		      snd_soc_read(codec, WM8900_REG_LOUT1CTL) | 0x100);
+	snd_soc_write(codec, WM8900_REG_ROUT1CTL,
+		      snd_soc_read(codec, WM8900_REG_ROUT1CTL) | 0x100);
+	snd_soc_write(codec, WM8900_REG_LOUT2CTL,
+		      snd_soc_read(codec, WM8900_REG_LOUT2CTL) | 0x100);
+	snd_soc_write(codec, WM8900_REG_ROUT2CTL,
+		      snd_soc_read(codec, WM8900_REG_ROUT2CTL) | 0x100);
+	snd_soc_write(codec, WM8900_REG_LDAC_DV,
+		      snd_soc_read(codec, WM8900_REG_LDAC_DV) | 0x100);
+	snd_soc_write(codec, WM8900_REG_RDAC_DV,
+		      snd_soc_read(codec, WM8900_REG_RDAC_DV) | 0x100);
+	snd_soc_write(codec, WM8900_REG_LADC_DV,
+		      snd_soc_read(codec, WM8900_REG_LADC_DV) | 0x100);
+	snd_soc_write(codec, WM8900_REG_RADC_DV,
+		      snd_soc_read(codec, WM8900_REG_RADC_DV) | 0x100);
+
+	/* Set the DAC and mixer output bias */
+	snd_soc_write(codec, WM8900_REG_OUTBIASCTL, 0x81);
+
+	snd_soc_add_controls(codec, wm8900_snd_controls,
+				ARRAY_SIZE(wm8900_snd_controls));
+	wm8900_add_widgets(codec);
 
-	wm8900_codec = codec;
+	return 0;
+}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	ret = snd_soc_register_codec(&i2c->dev,
-			&soc_codec_dev_wm8900, &wm8900_dai, 1);
-#else
-	ret = snd_soc_register_codec(codec);
-#endif
-	if (ret != 0) {
-		dev_err(&i2c->dev, "Failed to register codec: %d\n", ret);
-		goto err;
-	}
+/* power down chip */
+static int wm8900_remove(struct snd_soc_codec *codec)
+{
+	wm8900_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	ret = snd_soc_register_dai(&wm8900_dai);
-	if (ret != 0) {
-		dev_err(&i2c->dev, "Failed to register DAI: %d\n", ret);
-		goto err_codec;
-	}
-#endif
+static struct snd_soc_codec_driver soc_codec_dev_wm8900 = {
+	.probe =	wm8900_probe,
+	.remove =	wm8900_remove,
+	.suspend =	wm8900_suspend,
+	.resume =	wm8900_resume,
+	.set_bias_level = wm8900_set_bias_level,
+	.volatile_register = wm8900_volatile_register,
+	.reg_cache_size = ARRAY_SIZE(wm8900_reg_defaults),
+	.reg_word_size = sizeof(u16),
+	.reg_cache_default = wm8900_reg_defaults,
+};
 
-	return ret;
+#if defined(CONFIG_SPI_MASTER)
+static int __devinit wm8900_spi_probe(struct spi_device *spi)
+{
+	struct wm8900_priv *wm8900;
+	int ret;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-err_codec:
-	snd_soc_unregister_codec(codec);
-#endif
-err:
-	kfree(wm8900);
-	wm8900_codec = NULL;
+	wm8900 = kzalloc(sizeof(struct wm8900_priv), GFP_KERNEL);
+	if (wm8900 == NULL)
+		return -ENOMEM;
+
+	wm8900->control_type = SND_SOC_SPI;
+	spi_set_drvdata(spi, wm8900);
+
+	ret = snd_soc_register_codec(&spi->dev,
+			&soc_codec_dev_wm8900, &wm8900_dai, 1);
+	if (ret < 0)
+		kfree(wm8900);
 	return ret;
 }
-#else
+
+static int __devexit wm8900_spi_remove(struct spi_device *spi)
+{
+	snd_soc_unregister_codec(&spi->dev);
+	kfree(spi_get_drvdata(spi));
+	return 0;
+}
+
+static struct spi_driver wm8900_spi_driver = {
+	.driver = {
+		.name	= "wm8900-codec",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm8900_spi_probe,
+	.remove		= __devexit_p(wm8900_spi_remove),
+};
+#endif /* CONFIG_SPI_MASTER */
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 static __devinit int wm8900_i2c_probe(struct i2c_client *i2c,
 				      const struct i2c_device_id *id)
 {
 	struct wm8900_priv *wm8900;
 	int ret;
 
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-
 	wm8900 = kzalloc(sizeof(struct wm8900_priv), GFP_KERNEL);
 	if (wm8900 == NULL)
 		return -ENOMEM;
@@ -1224,41 +1307,18 @@ static __devinit int wm8900_i2c_probe(struct i2c_client *i2c,
 
 	ret =  snd_soc_register_codec(&i2c->dev,
 			&soc_codec_dev_wm8900, &wm8900_dai, 1);
-	if (ret < 0) {
-		dev_err(&i2c->dev, "Failed to register codec: %d\n", ret);
+	if (ret < 0)
 		kfree(wm8900);
-	}
 	return ret;
 }
-#endif
 
 static __devexit int wm8900_i2c_remove(struct i2c_client *client)
 {
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	snd_soc_unregister_codec(&client->dev);
 	kfree(i2c_get_clientdata(client));
-#else
-	snd_soc_unregister_dai(&wm8900_dai);
-	snd_soc_unregister_codec(wm8900_codec);
-
-	wm8900_set_bias_level(wm8900_codec, SND_SOC_BIAS_OFF);
-
-	wm8900_dai.dev = NULL;
-	kfree(snd_soc_codec_get_drvdata(wm8900_codec));
-	wm8900_codec = NULL;
-#endif
-
 	return 0;
 }
 
-void wm8900_i2c_shutdown(struct i2c_client *client)
-{
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-	wm8900_powerdown();
-}
-
 static const struct i2c_device_id wm8900_i2c_id[] = {
 	{ "wm8900", 0 },
 	{ }
@@ -1267,140 +1327,44 @@ MODULE_DEVICE_TABLE(i2c, wm8900_i2c_id);
 
 static struct i2c_driver wm8900_i2c_driver = {
 	.driver = {
-		.name = "WM8900",
+		.name = "wm8900-codec",
 		.owner = THIS_MODULE,
 	},
-	.probe = wm8900_i2c_probe,
-	.remove = __devexit_p(wm8900_i2c_remove),
-	.shutdown = wm8900_i2c_shutdown,
+	.probe =    wm8900_i2c_probe,
+	.remove =   __devexit_p(wm8900_i2c_remove),
 	.id_table = wm8900_i2c_id,
 };
+#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-static int wm8900_probe(struct snd_soc_codec *codec)
-{
-	struct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);
-	int ret;
-	wm8900_codec = codec;
-
-	ret = snd_soc_codec_set_cache_io(codec, 8, 16, wm8900->control_type);
-	if (ret != 0) {
-		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
-		return ret;
-	}
-#else
-static int wm8900_probe(struct platform_device *pdev)
+static int __init wm8900_modinit(void)
 {
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_codec *codec;
 	int ret = 0;
-#endif
-
-#ifndef WM8900_NO_POWEROFF
-	gpio_set_value(RK29_PIN1_PD6, GPIO_LOW);
-#endif
-
-	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
-        
-	if (!wm8900_codec) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-		dev_err(codec->dev, "I2C client not yet instantiated\n");
-#else
-		dev_err(&pdev->dev, "I2C client not yet instantiated\n");
-#endif
-		return -ENODEV;
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	ret = i2c_add_driver(&wm8900_i2c_driver);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to register wm8900 I2C driver: %d\n",
+		       ret);
 	}
-
-#if defined(SPK_CON)
-	gpio_request(SPK_CON,NULL);
-	gpio_direction_output(SPK_CON, GPIO_LOW);
 #endif
-
-	codec = wm8900_codec;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-	socdev->card->codec = codec;
-
-	/* Register pcms */
-	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
-	if (ret < 0) {
-		dev_err(codec->dev, "Failed to register new PCMs\n");
-		dev_err(&pdev->dev, "Failed to register new PCMs\n");
-		goto pcm_err;
+#if defined(CONFIG_SPI_MASTER)
+	ret = spi_register_driver(&wm8900_spi_driver);
+	if (ret != 0) {
+		printk(KERN_ERR "Failed to register wm8900 SPI driver: %d\n",
+		       ret);
 	}
 #endif
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38))
-	wm8900_workq = create_freezable_workqueue("wm8900");
-#else
-	wm8900_workq = create_freezeable_workqueue("wm8900");
-#endif
-	if (wm8900_workq == NULL) {
-		kfree(codec);
-		return -ENOMEM;
-	}
-
-#ifdef WM8900_NO_POWEROFF
-	wm8900_set_hw(codec);
-#endif
-
 	return ret;
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
-pcm_err:
-	return ret;
-#endif
-}
-
-/* power down chip */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-static int wm8900_remove(struct snd_soc_codec *codec)
-{
-	wm8900_set_bias_level(codec, SND_SOC_BIAS_OFF);
-	return 0;
-}
-#else
-static int wm8900_remove(struct platform_device *pdev)
-{
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-
-	snd_soc_free_pcms(socdev);
-	snd_soc_dapm_free(socdev);
-
-	return 0;
-}
-#endif
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-static struct snd_soc_codec_driver soc_codec_dev_wm8900 = {
-	.probe =	wm8900_probe,
-	.remove =	wm8900_remove,
-	.suspend =	wm8900_suspend,
-	.resume =	wm8900_resume,
-	.set_bias_level = wm8900_set_bias_level,
-	.volatile_register = wm8900_volatile_register,
-	.reg_cache_size = ARRAY_SIZE(wm8900_reg_defaults),
-	.reg_word_size = sizeof(u16),
-	.reg_cache_default = wm8900_reg_defaults,
-};
-#else
-struct snd_soc_codec_device soc_codec_dev_wm8900 = {
-	.probe = 	wm8900_probe,
-	.remove = 	wm8900_remove,
-	.suspend = 	wm8900_suspend,
-	.resume =	wm8900_resume,
-};
-EXPORT_SYMBOL_GPL(soc_codec_dev_wm8900);
-#endif
-
-static int __init wm8900_modinit(void)
-{
-	return i2c_add_driver(&wm8900_i2c_driver);
 }
 module_init(wm8900_modinit);
 
 static void __exit wm8900_exit(void)
 {
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 	i2c_del_driver(&wm8900_i2c_driver);
+#endif
+#if defined(CONFIG_SPI_MASTER)
+	spi_unregister_driver(&wm8900_spi_driver);
+#endif
 }
 module_exit(wm8900_exit);
 
diff --git a/sound/soc/codecs/wm8988.c b/sound/soc/codecs/wm8988.c
index 89bbc7dd242e..d7170f1381aa 100644
--- a/sound/soc/codecs/wm8988.c
+++ b/sound/soc/codecs/wm8988.c
@@ -25,23 +25,10 @@
 #include <sound/pcm_params.h>
 #include <sound/tlv.h>
 #include <sound/soc.h>
-#include <sound/soc-dapm.h>
 #include <sound/initval.h>
 
-#include <mach/iomux.h>
-#include <mach/gpio.h>
-
 #include "wm8988.h"
 
-#include <linux/proc_fs.h>
-#include <linux/gpio.h>
-
-#if 0
-#define DBG(x...) printk(KERN_INFO x)
-#else
-#define DBG(x...) do { } while (0)
-#endif
-
 /*
  * wm8988 register cache
  * We can't read the WM8988 register space when we
@@ -66,8 +53,6 @@ struct wm8988_priv {
 	unsigned int sysclk;
 	enum snd_soc_control_type control_type;
 	struct snd_pcm_hw_constraint_list *sysclk_constraints;
-	int is_startup;		// gModify.Add
-	int is_biason;
 };
 
 
@@ -205,8 +190,6 @@ static int wm8988_lrc_control(struct snd_soc_dapm_widget *w,
 	else
 		adctl2 |= 0x4;
 
-	DBG("Enter::%s----%d, adctl2 = %x\n",__FUNCTION__,__LINE__,adctl2);
-	
 	return snd_soc_write(codec, WM8988_ADCTL2, adctl2);
 }
 
@@ -307,9 +290,8 @@ static const struct snd_soc_dapm_widget wm8988_dapm_widgets[] = {
 	SND_SOC_DAPM_ADC("Right ADC", "Right Capture", WM8988_PWR1, 2, 0),
 	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", WM8988_PWR1, 3, 0),
 
-	/* gModify.Cmmt Implement when suspend/startup */
-	/*SND_SOC_DAPM_DAC("Right DAC", "Right Playback", WM8988_PWR2, 7, 0),*/
-	/*SND_SOC_DAPM_DAC("Left DAC", "Left Playback", WM8988_PWR2, 8, 0),*/
+	SND_SOC_DAPM_DAC("Right DAC", "Right Playback", WM8988_PWR2, 7, 0),
+	SND_SOC_DAPM_DAC("Left DAC", "Left Playback", WM8988_PWR2, 8, 0),
 
 	SND_SOC_DAPM_MIXER("Left Mixer", SND_SOC_NOPM, 0, 0,
 		&wm8988_left_mixer_controls[0],
@@ -495,7 +477,7 @@ static struct snd_pcm_hw_constraint_list constraints_112896 = {
 };
 
 static unsigned int rates_12[] = {
-	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,
+	8000, 11025, 12000, 16000, 22050, 2400, 32000, 41100, 48000,
 	48000, 88235, 96000,
 };
 
@@ -513,8 +495,6 @@ static int wm8988_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 	struct snd_soc_codec *codec = codec_dai->codec;
 	struct wm8988_priv *wm8988 = snd_soc_codec_get_drvdata(codec);
 
-    DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
-		
 	switch (freq) {
 	case 11289600:
 	case 18432000:
@@ -595,8 +575,6 @@ static int wm8988_set_dai_fmt(struct snd_soc_dai *codec_dai,
 		return -EINVAL;
 	}
 
-	DBG("Enter::%s----%d  iface=%x\n",__FUNCTION__,__LINE__,iface);
-
 	snd_soc_write(codec, WM8988_IFACE, iface);
 	return 0;
 }
@@ -607,17 +585,6 @@ static int wm8988_pcm_startup(struct snd_pcm_substream *substream,
 	struct snd_soc_codec *codec = dai->codec;
 	struct wm8988_priv *wm8988 = snd_soc_codec_get_drvdata(codec);
 
-	if (!wm8988->is_startup) {
-		wm8988->is_startup = 1;
-		snd_soc_write(codec, WM8988_PWR1, 0xfc);
-		gpio_direction_output(RK29_PIN6_PB5, GPIO_LOW);
-		mdelay(100);		// Discharge C310
-		snd_soc_write(codec, WM8988_PWR2, 0x1e0);
-		gpio_direction_output(RK29_PIN6_PB5, GPIO_HIGH);
-	}
-
-	DBG("Enter::%s----%d  wm8988->sysclk=%d\n",__FUNCTION__,__LINE__,wm8988->sysclk); 
-
 	/* The set of sample rates that can be supported depends on the
 	 * MCLK supplied to the CODEC - enforce this.
 	 */
@@ -672,8 +639,6 @@ static int wm8988_pcm_hw_params(struct snd_pcm_substream *substream,
 		break;
 	}
 
-	DBG("Enter::%s----%d  iface=%x srate =%x rate=%d\n",__FUNCTION__,__LINE__,iface,srate,params_rate(params));
-
 	/* set iface & srate */
 	snd_soc_write(codec, WM8988_IFACE, iface);
 	if (coeff >= 0)
@@ -688,8 +653,6 @@ static int wm8988_mute(struct snd_soc_dai *dai, int mute)
 	struct snd_soc_codec *codec = dai->codec;
 	u16 mute_reg = snd_soc_read(codec, WM8988_ADCDAC) & 0xfff7;
 
-	DBG("Enter::%s----%d--mute=%d\n",__FUNCTION__,__LINE__,mute);
-
 	if (mute)
 		snd_soc_write(codec, WM8988_ADCDAC, mute_reg | 0x8);
 	else
@@ -700,22 +663,13 @@ static int wm8988_mute(struct snd_soc_dai *dai, int mute)
 static int wm8988_set_bias_level(struct snd_soc_codec *codec,
 				 enum snd_soc_bias_level level)
 {
-	struct wm8988_priv *wm8988 = snd_soc_codec_get_drvdata(codec);
 	u16 pwr_reg = snd_soc_read(codec, WM8988_PWR1) & ~0x1c1;
 
-	DBG("Enter::%s----%d level =%d\n",__FUNCTION__,__LINE__,level);
-
 	switch (level) {
 	case SND_SOC_BIAS_ON:
-		wm8988->is_biason = 1;
 		break;
 
 	case SND_SOC_BIAS_PREPARE:
-		if (wm8988->is_startup && wm8988->is_biason) {
-			snd_soc_write(codec, WM8988_PWR2, 0x0);
-			wm8988->is_startup = 0;
-			wm8988->is_biason = 0;
-		}
 		/* VREF, VMID=2x50k, digital enabled */
 		snd_soc_write(codec, WM8988_PWR1, pwr_reg | 0x00c0);
 		break;
@@ -755,7 +709,7 @@ static struct snd_soc_dai_ops wm8988_ops = {
 };
 
 static struct snd_soc_dai_driver wm8988_dai = {
-	.name = "WM8988 HiFi",
+	.name = "wm8988-hifi",
 	.playback = {
 		.stream_name = "Playback",
 		.channels_min = 1,
@@ -776,8 +730,6 @@ static struct snd_soc_dai_driver wm8988_dai = {
 
 static int wm8988_suspend(struct snd_soc_codec *codec, pm_message_t state)
 {
-	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
-
 	wm8988_set_bias_level(codec, SND_SOC_BIAS_OFF);
 	return 0;
 }
@@ -788,8 +740,6 @@ static int wm8988_resume(struct snd_soc_codec *codec)
 	u8 data[2];
 	u16 *cache = codec->reg_cache;
 
-	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
-
 	/* Sync reg_cache with the hardware */
 	for (i = 0; i < WM8988_NUM_REG; i++) {
 		if (i == WM8988_RESET)
@@ -798,30 +748,12 @@ static int wm8988_resume(struct snd_soc_codec *codec)
 		data[1] = cache[i] & 0x00ff;
 		codec->hw_write(codec->control_data, data, 2);
 	}
-	
-	//snd_soc_write(codec, WM8988_PWR1, 0xfc);
-	//snd_soc_write(codec, WM8988_PWR2, 0x1e0);
 
 	wm8988_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 
 	return 0;
 }
 
-static struct snd_soc_codec *wm8988_codec;
-
-static int entry_read(char *page, char **start, off_t off,
-		int count, int *eof, void *data)
-{
-	int len;
-
-	snd_soc_write(wm8988_codec, WM8988_PWR1, 0x0000);
-	snd_soc_write(wm8988_codec, WM8988_PWR2, 0x0000);
-
-	len = sprintf(page, "wm8988 suspend...\n");
-
-	return len ;
-}
-
 static int wm8988_probe(struct snd_soc_codec *codec)
 {
 	struct wm8988_priv *wm8988 = snd_soc_codec_get_drvdata(codec);
@@ -829,13 +761,6 @@ static int wm8988_probe(struct snd_soc_codec *codec)
 	int ret = 0;
 	u16 reg;
 
-	if (codec == NULL) {
-		dev_err(codec->dev, "Codec device not registered\n");
-		return -ENODEV;
-	}
-
-	wm8988_codec = codec;
-
 	ret = snd_soc_codec_set_cache_io(codec, 7, 9, wm8988->control_type);
 	if (ret < 0) {
 		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
@@ -848,14 +773,6 @@ static int wm8988_probe(struct snd_soc_codec *codec)
 		return ret;
 	}
 
-#if 0
-		/*disable speaker */
-		gpio_request(RK2818_PIN_PF7, "WM8988");	
-		rk2818_mux_api_set(GPIOE_SPI1_FLASH_SEL_NAME, IOMUXA_GPIO1_A3B7);
-		gpio_direction_output(RK2818_PIN_PF7,GPIO_HIGH);
-		
-#endif
-
 	/* set the update bits (we always update left then right) */
 	reg = snd_soc_read(codec, WM8988_RADC);
 	snd_soc_write(codec, WM8988_RADC, reg | 0x100);
@@ -866,40 +783,7 @@ static int wm8988_probe(struct snd_soc_codec *codec)
 	reg = snd_soc_read(codec, WM8988_ROUT2V);
 	snd_soc_write(codec, WM8988_ROUT2V, reg | 0x0100);
 	reg = snd_soc_read(codec, WM8988_RINVOL);
-	snd_soc_write(codec, WM8988_RINVOL, reg | 0x0100); 
-	
-	snd_soc_write(codec, WM8988_LOUTM1, 0x120); 
-	snd_soc_write(codec, WM8988_ROUTM2, 0x120);  
-	snd_soc_write(codec, WM8988_LOUTM2, 0x0070);
-	snd_soc_write(codec, WM8988_ROUTM1, 0x0070);
-//tcl miaozh modify	
-//	snd_soc_write(codec, WM8988_LOUT1V, 0x017f); 
-//	snd_soc_write(codec, WM8988_ROUT1V, 0x017f);
-	snd_soc_write(codec, WM8988_LOUT1V, 0x017a); 
-	snd_soc_write(codec, WM8988_ROUT1V, 0x017a);
-	
-	snd_soc_write(codec, WM8988_LDAC, 0xfa/*0xff*/);  // Change max by zhansb@110415
-	snd_soc_write(codec, WM8988_RDAC, 0x1fa/*0x1ff*/);//vol set 
-
-	//TCL lgw add 20110412
-	snd_soc_write(codec, WM8988_LINVOL,  0x0117);
-	snd_soc_write(codec, WM8988_RINVOL,  0x0117);
-
-	snd_soc_write(codec, WM8988_ADCTL2, 0x0184);
-
-	snd_soc_write(codec, WM8988_LADC, 0x01ec);
-	snd_soc_write(codec, WM8988_RADC, 0x01ec);
-	
-	snd_soc_write(codec, WM8988_ADCIN,  0x0140);
-	snd_soc_write(codec, WM8988_LADCIN, 0x00f0);//0x00e0
-	snd_soc_write(codec, WM8988_RADCIN, 0x0);//0x00e0
-	//lgw end
-	
-	snd_soc_write(codec, WM8988_SRATE,0x100);  ///SET MCLK/8
-	//snd_soc_write(codec, WM8988_PWR1, 0x1cc);  ///(0x80|0x40|0x20|0x08|0x04|0x10|0x02));
-	//TCL lgw modify 20110412
-	//snd_soc_write(codec, WM8988_PWR1, 0xfc);
- 	//snd_soc_write(codec, WM8988_PWR2, 0x1e0);  //power r l out1
+	snd_soc_write(codec, WM8988_RINVOL, reg | 0x0100);
 
 	wm8988_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
 
@@ -908,7 +792,6 @@ static int wm8988_probe(struct snd_soc_codec *codec)
 	snd_soc_dapm_new_controls(dapm, wm8988_dapm_widgets,
 				  ARRAY_SIZE(wm8988_dapm_widgets));
 	snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
-	create_proc_read_entry("wm8988_suspend", 0644, NULL, entry_read, NULL);
 
 	return 0;
 }
@@ -959,7 +842,7 @@ static int __devexit wm8988_spi_remove(struct spi_device *spi)
 
 static struct spi_driver wm8988_spi_driver = {
 	.driver = {
-		.name	= "WM8988",
+		.name	= "wm8988-codec",
 		.owner	= THIS_MODULE,
 	},
 	.probe		= wm8988_spi_probe,
@@ -1003,7 +886,7 @@ MODULE_DEVICE_TABLE(i2c, wm8988_i2c_id);
 
 static struct i2c_driver wm8988_i2c_driver = {
 	.driver = {
-		.name = "WM8988",
+		.name = "wm8988-codec",
 		.owner = THIS_MODULE,
 	},
 	.probe =    wm8988_i2c_probe,
diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c
index 351e98749c51..1f7616d03fff 100644
--- a/sound/soc/codecs/wm8994.c
+++ b/sound/soc/codecs/wm8994.c
@@ -29,8 +29,6 @@
 #include <sound/initval.h>
 #include <sound/tlv.h>
 #include <trace/events/asoc.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
 
 #include <linux/mfd/wm8994/core.h>
 #include <linux/mfd/wm8994/registers.h>
@@ -40,38 +38,9 @@
 #include "wm8994.h"
 #include "wm_hubs.h"
 
-#define WM8994_PROC
-#ifdef WM8994_PROC
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/vmalloc.h>
-char debug_write_read = 0;
-#endif
-
-#if 1
-#define DBG(x...) printk(KERN_INFO x)
-#else
-#define DBG(x...) do { } while (0)
-#endif
-
-#if 0
-#define DBG_CLK(x...) printk(KERN_INFO x)
-#else
-#define DBG_CLK(x...) do { } while (0)
-#endif
-
-#if 0
-#define DBG_INFO(x...) dev_info(x)
-#else
-#define DBG_INFO(x...) do { } while (0)
-#endif
-
-
 #define WM8994_NUM_DRC 3
 #define WM8994_NUM_EQ  3
 
-static struct snd_soc_codec *wm8994_codec;
-
 static int wm8994_drc_base[] = {
 	WM8994_AIF1_DRC1_1,
 	WM8994_AIF1_DRC2_1,
@@ -148,27 +117,15 @@ static int wm8994_write(struct snd_soc_codec *codec, unsigned int reg,
 	unsigned int value)
 {
 	int ret;
-//	if(reg == 0x3 || reg == 0x208)
-//		debug_write_read = 1;
 
 	BUG_ON(reg > WM8994_MAX_REGISTER);
-#ifdef WM8994_PROC		
-	if(debug_write_read != 0)		
-		printk("%s:0x%04x = 0x%04x\n",__FUNCTION__,reg,value);
-#endif
+
 	if (!wm8994_volatile(codec, reg)) {
 		ret = snd_soc_cache_write(codec, reg, value);
 		if (ret != 0)
 			dev_err(codec->dev, "Cache write to %x failed: %d\n",
 				reg, ret);
-		else
-#ifdef WM8994_PROC		
-	if(debug_write_read != 0)				
-			DBG("snd_soc_cache_write:0x%04x = 0x%04x\n",reg,value);
-#endif	
 	}
-//	if(reg == 0x3 || reg == 0x208)
-//		debug_write_read = 0;
 
 	return wm8994_reg_write(codec->control_data, reg, value);
 }
@@ -180,48 +137,19 @@ static unsigned int wm8994_read(struct snd_soc_codec *codec,
 	int ret;
 
 	BUG_ON(reg > WM8994_MAX_REGISTER);
-		
+
 	if (!wm8994_volatile(codec, reg) && wm8994_readable(codec, reg) &&
 	    reg < codec->driver->reg_cache_size) {
 		ret = snd_soc_cache_read(codec, reg, &val);
 		if (ret >= 0)
-		{	
-#ifdef WM8994_PROC			
-		if(debug_write_read != 0)			
-			DBG("snd_soc_cache_read:0x%04x = 0x%04x\n",reg,val);
-#endif	
 			return val;
-		}	
 		else
 			dev_err(codec->dev, "Cache read from %x failed: %d\n",
 				reg, ret);
 	}
-	val = wm8994_reg_read(codec->control_data, reg);
-#ifdef WM8994_PROC			
-	if(debug_write_read != 0)			
-		printk("%s:0x%04x = 0x%04x\n",__FUNCTION__,reg,val);	
-#endif
-	return val;
-}
 
-int wm8994_set_status(void)
-{
-	struct wm8994_priv *wm8994 = NULL;
-//	DBG("%s::%d\n",__FUNCTION__,__LINE__);
-
-	if(wm8994_codec == NULL )
-		return -1;
-	
-	wm8994 = snd_soc_codec_get_drvdata(wm8994_codec);
-
-	if(wm8994 == NULL)
-		return -1;
-	
-	return snd_soc_test_bits(wm8994_codec, WM8994_POWER_MANAGEMENT_1,
-			WM8994_MICB2_ENA ,
-			WM8994_MICB2_ENA);
+	return wm8994_reg_read(codec->control_data, reg);
 }
-EXPORT_SYMBOL_GPL(wm8994_set_status);
 
 static int configure_aif_clock(struct snd_soc_codec *codec, int aif)
 {
@@ -263,13 +191,13 @@ static int configure_aif_clock(struct snd_soc_codec *codec, int aif)
 		rate /= 2;
 		reg1 |= WM8994_AIF1CLK_DIV;
 
-		DBG_INFO(codec->dev, "Dividing AIF%d clock to %dHz\n",
+		dev_dbg(codec->dev, "Dividing AIF%d clock to %dHz\n",
 			aif + 1, rate);
 	}
 
 	if (rate && rate < 3000000)
-		dev_dbg(codec->dev, "AIF%dCLK is %dHz, should be >=3MHz for optimal performance\n",
-			 aif + 1, rate);//dev_warn
+		dev_warn(codec->dev, "AIF%dCLK is %dHz, should be >=3MHz for optimal performance\n",
+			 aif + 1, rate);
 
 	wm8994->aifclk[aif] = rate;
 
@@ -303,7 +231,7 @@ static int configure_clock(struct snd_soc_codec *codec)
 		new = WM8994_SYSCLK_SRC;
 	else
 		new = 0;
-	
+
 	old = snd_soc_read(codec, WM8994_CLOCKING_1) & WM8994_SYSCLK_SRC;
 
 	/* If there's no change then we're done. */
@@ -698,7 +626,7 @@ SOC_SINGLE("AIF1DAC2 3D Stereo Switch", WM8994_AIF1_DAC2_FILTERS_2,
 SOC_SINGLE_TLV("AIF2DAC 3D Stereo Volume", WM8994_AIF2_DAC_FILTERS_2,
 	       10, 15, 0, wm8994_3d_tlv),
 SOC_SINGLE("AIF2DAC 3D Stereo Switch", WM8994_AIF2_DAC_FILTERS_2,
-	   8, 1, 0),	   
+	   8, 1, 0),
 };
 
 static const struct snd_kcontrol_new wm8994_eq_controls[] = {
@@ -744,8 +672,7 @@ static int clk_sys_event(struct snd_soc_dapm_widget *w,
 			 struct snd_kcontrol *kcontrol, int event)
 {
 	struct snd_soc_codec *codec = w->codec;
-//	DBG("%s::%d\n",__FUNCTION__,__LINE__);
-	
+
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 		return configure_clock(codec);
@@ -826,7 +753,6 @@ static int late_enable_ev(struct snd_soc_dapm_widget *w,
 {
 	struct snd_soc_codec *codec = w->codec;
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
-//	DBG("%s::%d\n",__FUNCTION__,__LINE__);
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
@@ -841,13 +767,6 @@ static int late_enable_ev(struct snd_soc_dapm_widget *w,
 					    WM8994_AIF2CLK_ENA_MASK,
 					    WM8994_AIF2CLK_ENA);
 			wm8994->aif2clk_enable = 0;
-			//add
-			snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_3,
-				0x30a0,
-				0x30a0);
-			snd_soc_update_bits(codec, WM8994_CLOCKING_1,
-					    WM8994_SYSCLK_SRC,
-					    WM8994_SYSCLK_SRC);			
 		}
 		break;
 	}
@@ -863,26 +782,18 @@ static int late_disable_ev(struct snd_soc_dapm_widget *w,
 {
 	struct snd_soc_codec *codec = w->codec;
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
-	DBG("%s::%d event = %d active = %d\n",__FUNCTION__,__LINE__,event,codec->active);
-	
-	if(codec->active)
-	{
-		DBG("%s::%d codec is %s\n",__FUNCTION__,__LINE__,codec->active?"active":"inactive");
-		return 0;
-	}
+
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMD:
 		if (wm8994->aif1clk_disable) {
 			snd_soc_update_bits(codec, WM8994_AIF1_CLOCKING_1,
 					    WM8994_AIF1CLK_ENA_MASK, 0);
 			wm8994->aif1clk_disable = 0;
-			wm8994->aif1clk_enable = 1;
 		}
 		if (wm8994->aif2clk_disable) {
 			snd_soc_update_bits(codec, WM8994_AIF2_CLOCKING_1,
 					    WM8994_AIF2CLK_ENA_MASK, 0);
 			wm8994->aif2clk_disable = 0;
-			//wm8994->aif2clk_enable = 1;
 		}
 		break;
 	}
@@ -890,61 +801,6 @@ static int late_disable_ev(struct snd_soc_dapm_widget *w,
 	return 0;
 }
 
-static int wm8994_PA_event(struct snd_soc_dapm_widget *w,
-			  struct snd_kcontrol *control, int event)
-{
-	struct snd_soc_codec *codec = w->codec;
-	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
-	struct wm8994_pdata *pdata = wm8994->pdata;
-//	DBG("Enter %s::%s---%d\n",__FILE__,__FUNCTION__,__LINE__);
-
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		DBG("wm8994_PA_event PA enable\n");
-		gpio_set_value(pdata->PA_control_pin,GPIO_HIGH);	
-		break;
-
-	case SND_SOC_DAPM_PRE_PMD:
-		DBG("wm8994_PA_event PA disable\n");
-		gpio_set_value(pdata->PA_control_pin,GPIO_LOW);
-		break;
-
-	default:
-	//	BUG();
-		break;
-	}
-
-	return 0;
-}
-
-int lineout_event(struct snd_soc_dapm_widget *w,
-			  struct snd_kcontrol *control, int event)
-{
-//	struct snd_soc_codec *codec = w->codec;
-//	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
-//	struct wm8994_pdata *pdata = wm8994->pdata;
-	
-//	printk("Enter %s::%s---%d\n",__FILE__,__FUNCTION__,__LINE__);
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		printk("wm8994 is incall status\n");
-		snd_soc_incall_status(1,1);
-		break;
-
-	case SND_SOC_DAPM_PRE_PMD:
-		printk("wm8994 exit incall status\n");
-		snd_soc_incall_status(1,0);
-		break;
-
-	default:
-		BUG();
-		break;
-	}
-#endif
-	return 0;
-}
-
 static int aif1clk_ev(struct snd_soc_dapm_widget *w,
 		      struct snd_kcontrol *kcontrol, int event)
 {
@@ -1399,7 +1255,7 @@ SND_SOC_DAPM_AIF_IN_E("AIF2DACL", NULL, 0,
 SND_SOC_DAPM_AIF_IN_E("AIF2DACR", NULL, 0,
 		      WM8994_POWER_MANAGEMENT_5, 12, 0, wm8958_aif_ev,
 		      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
-     
+
 SND_SOC_DAPM_AIF_IN("AIF1DACDAT", "AIF1 Playback", 0, SND_SOC_NOPM, 0, 0),
 SND_SOC_DAPM_AIF_IN("AIF2DACDAT", "AIF2 Playback", 0, SND_SOC_NOPM, 0, 0),
 SND_SOC_DAPM_AIF_OUT("AIF1ADCDAT", "AIF1 Capture", 0, SND_SOC_NOPM, 0, 0),
@@ -1410,7 +1266,7 @@ SND_SOC_DAPM_MUX("AIF2DAC Mux", SND_SOC_NOPM, 0, 0, &aif2dac_mux),
 SND_SOC_DAPM_MUX("AIF2ADC Mux", SND_SOC_NOPM, 0, 0, &aif2adc_mux),
 
 SND_SOC_DAPM_AIF_IN("AIF3DACDAT", "AIF3 Playback", 0, SND_SOC_NOPM, 0, 0),
-SND_SOC_DAPM_AIF_IN("AIF3ADCDAT", "AIF3 Capture", 0, SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_AIF_OUT("AIF3ADCDAT", "AIF3 Capture", 0, SND_SOC_NOPM, 0, 0),
 
 SND_SOC_DAPM_SUPPLY("TOCLK", WM8994_CLOCKING_1, 4, 0, NULL, 0),
 
@@ -1432,7 +1288,7 @@ SND_SOC_DAPM_MUX("Right Headphone Mux", SND_SOC_NOPM, 0, 0, &hpr_mux),
 SND_SOC_DAPM_MIXER("SPKL", WM8994_POWER_MANAGEMENT_3, 8, 0,
 		   left_speaker_mixer, ARRAY_SIZE(left_speaker_mixer)),
 SND_SOC_DAPM_MIXER("SPKR", WM8994_POWER_MANAGEMENT_3, 9, 0,
-		   right_speaker_mixer, ARRAY_SIZE(right_speaker_mixer)),		   
+		   right_speaker_mixer, ARRAY_SIZE(right_speaker_mixer)),
 
 SND_SOC_DAPM_POST("Debug log", post_ev),
 };
@@ -1600,16 +1456,14 @@ static const struct snd_soc_dapm_route intercon[] = {
 	{ "AIF2ADCDAT", NULL, "AIF2ADC Mux" },
 
 	/* AIF3 output */
-	{ "AIF3ADC Mux", "AIF1ADCDAT", "AIF1ADC1L" },
-	{ "AIF3ADC Mux", "AIF1ADCDAT", "AIF1ADC1R" },
-	{ "AIF3ADC Mux", "AIF1ADCDAT", "AIF1ADC2L" },
-	{ "AIF3ADC Mux", "AIF1ADCDAT", "AIF1ADC2R" },
-	{ "AIF3ADC Mux", "AIF2ADCDAT", "AIF2ADCL" },
-	{ "AIF3ADC Mux", "AIF2ADCDAT", "AIF2ADCR" },
-	{ "AIF3ADC Mux", "AIF2DACDAT", "AIF2DACL" },
-	{ "AIF3ADC Mux", "AIF2DACDAT", "AIF2DACR" },
-	
-	{ "AIF3ADCDAT", NULL, "AIF3ADC Mux" },
+	{ "AIF3ADCDAT", "AIF1ADCDAT", "AIF1ADC1L" },
+	{ "AIF3ADCDAT", "AIF1ADCDAT", "AIF1ADC1R" },
+	{ "AIF3ADCDAT", "AIF1ADCDAT", "AIF1ADC2L" },
+	{ "AIF3ADCDAT", "AIF1ADCDAT", "AIF1ADC2R" },
+	{ "AIF3ADCDAT", "AIF2ADCDAT", "AIF2ADCL" },
+	{ "AIF3ADCDAT", "AIF2ADCDAT", "AIF2ADCR" },
+	{ "AIF3ADCDAT", "AIF2DACDAT", "AIF2DACL" },
+	{ "AIF3ADCDAT", "AIF2DACDAT", "AIF2DACR" },
 
 	/* Sidetone */
 	{ "Left Sidetone", "ADC/DMIC1", "ADCL Mux" },
@@ -1629,14 +1483,6 @@ static const struct snd_soc_dapm_route intercon[] = {
 
 	{ "Left Headphone Mux", "DAC", "DAC1L" },
 	{ "Right Headphone Mux", "DAC", "DAC1R" },
-	
-//	{ "IN1L PGA", NULL , "MICBIAS2" },
-	{ "IN1R PGA", NULL , "MICBIAS1" },
-//	{ "MICBIAS2", NULL , "IN1LP"},//headset
-//	{ "MICBIAS2", NULL , "IN1LN"},
-	{ "MICBIAS1", NULL , "IN1RP"},//mainMIC
-	{ "MICBIAS1", NULL , "IN1RN"},
-	
 };
 
 static const struct snd_soc_dapm_route wm8994_lateclk_revd_intercon[] = {
@@ -1688,34 +1534,6 @@ static const struct snd_soc_dapm_route wm8958_intercon[] = {
 	{ "AIF3ADC Mux", "Mono PCM", "Mono PCM Out Mux" },
 };
 
-static const struct snd_soc_dapm_route wm8994_PA_intercon[] = {
-
-	{ "PA Driver", NULL,"SPKL Driver"},
-//	{ "PA Driver", NULL,"SPKR Driver"},	
-	
-	{ "SPKOUTLP", NULL, "PA Driver" },
-	{ "SPKOUTLN", NULL, "PA Driver" },
-//	{ "SPKOUTRP", NULL, "PA Driver" },
-//	{ "SPKOUTRN", NULL, "PA Driver" },	
-};
-
-static const struct snd_soc_dapm_widget wm8994_PA_dapm_widgets[] = {
-SND_SOC_DAPM_SPK("PA Driver", wm8994_PA_event),
-};
-/*
-static const struct snd_soc_dapm_route wm8994_lineout_status_intercon[] = {
-	{ "LINEOUT1N STATUS", NULL,"LINEOUT1N Driver"},
-	{ "LINEOUT1P STATUS", NULL,"LINEOUT1P Driver"},	
-
-	{ "LINEOUT1N", NULL, "LINEOUT1N STATUS" },
-	{ "LINEOUT1P", NULL, "LINEOUT1P STATUS" },
-};
-
-static const struct snd_soc_dapm_widget wm8994_lineout_status_dapm_widgets[] = {
-SND_SOC_DAPM_LINE("LINEOUT1N Driver", lineout_event),
-SND_SOC_DAPM_LINE("LINEOUT1P Driver", lineout_event),	
-};
-*/
 /* The size in bits of the FLL divide multiplied by 10
  * to allow rounding later */
 #define FIXED_FLL_SIZE ((1 << 16) * 10)
@@ -1734,7 +1552,7 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 	u64 Kpart;
 	unsigned int K, Ndiv, Nmod;
 
-	DBG_CLK("FLL input=%dHz, output=%dHz\n", freq_in, freq_out);
+	pr_debug("FLL input=%dHz, output=%dHz\n", freq_in, freq_out);
 
 	/* Scale the input frequency down to <= 13.5MHz */
 	fll->clk_ref_div = 0;
@@ -1745,7 +1563,7 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 		if (fll->clk_ref_div > 3)
 			return -EINVAL;
 	}
-	DBG_CLK("CLK_REF_DIV=%d, Fref=%dHz\n", fll->clk_ref_div, freq_in);
+	pr_debug("CLK_REF_DIV=%d, Fref=%dHz\n", fll->clk_ref_div, freq_in);
 
 	/* Scale the output to give 90MHz<=Fvco<=100MHz */
 	fll->outdiv = 3;
@@ -1755,7 +1573,7 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 			return -EINVAL;
 	}
 	freq_out *= fll->outdiv + 1;
-	DBG_CLK("OUTDIV=%d, Fvco=%dHz\n", fll->outdiv, freq_out);
+	pr_debug("OUTDIV=%d, Fvco=%dHz\n", fll->outdiv, freq_out);
 
 	if (freq_in > 1000000) {
 		fll->fll_fratio = 0;
@@ -1772,14 +1590,14 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 		fll->fll_fratio = 4;
 		freq_in *= 16;
 	}
-	DBG_CLK("FLL_FRATIO=%d, Fref=%dHz\n", fll->fll_fratio, freq_in);
+	pr_debug("FLL_FRATIO=%d, Fref=%dHz\n", fll->fll_fratio, freq_in);
 
 	/* Now, calculate N.K */
 	Ndiv = freq_out / freq_in;
 
 	fll->n = Ndiv;
 	Nmod = freq_out % freq_in;
-	DBG_CLK("Nmod=%d\n", Nmod);
+	pr_debug("Nmod=%d\n", Nmod);
 
 	/* Calculate fractional part - scale up so we can round. */
 	Kpart = FIXED_FLL_SIZE * (long long)Nmod;
@@ -1794,7 +1612,7 @@ static int wm8994_get_fll_config(struct fll_div *fll,
 	/* Move down to proper range now rounding is done */
 	fll->k = K / 10;
 
-	DBG_CLK("N=%x K=%x\n", fll->n, fll->k);
+	pr_debug("N=%x K=%x\n", fll->n, fll->k);
 
 	return 0;
 }
@@ -1823,7 +1641,6 @@ static int _wm8994_set_fll(struct snd_soc_codec *codec, int id, int src,
 		id = 1;
 		break;
 	default:
-		printk("%s:__ id = %d\n",__FUNCTION__,id);
 		return -EINVAL;
 	}
 
@@ -1831,10 +1648,7 @@ static int _wm8994_set_fll(struct snd_soc_codec *codec, int id, int src,
 	case 0:
 		/* Allow no source specification when stopping */
 		if (freq_out)
-		{
-			printk("%s:__ src = %d && freq_out = %d\n",__FUNCTION__,src,freq_out);	
 			return -EINVAL;
-		}	
 		src = wm8994->fll[id].src;
 		break;
 	case WM8994_FLL_SRC_MCLK1:
@@ -1843,7 +1657,6 @@ static int _wm8994_set_fll(struct snd_soc_codec *codec, int id, int src,
 	case WM8994_FLL_SRC_BCLK:
 		break;
 	default:
-		printk("%s:__ src = %d\n",__FUNCTION__,src);
 		return -EINVAL;
 	}
 
@@ -1950,7 +1763,7 @@ static int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,
 	case WM8994_SYSCLK_MCLK1:
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK1;
 		wm8994->mclk[0] = freq;
-		DBG_INFO(dai->dev, "AIF%d using MCLK1 at %uHz\n",
+		dev_dbg(dai->dev, "AIF%d using MCLK1 at %uHz\n",
 			dai->id, freq);
 		break;
 
@@ -1958,18 +1771,18 @@ static int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,
 		/* TODO: Set GPIO AF */
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK2;
 		wm8994->mclk[1] = freq;
-		DBG_INFO(dai->dev, "AIF%d using MCLK2 at %uHz\n",
+		dev_dbg(dai->dev, "AIF%d using MCLK2 at %uHz\n",
 			dai->id, freq);
 		break;
 
 	case WM8994_SYSCLK_FLL1:
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_FLL1;
-		DBG_INFO(dai->dev, "AIF%d using FLL1\n", dai->id);
+		dev_dbg(dai->dev, "AIF%d using FLL1\n", dai->id);
 		break;
 
 	case WM8994_SYSCLK_FLL2:
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_FLL2;
-		DBG_INFO(dai->dev, "AIF%d using FLL2\n", dai->id);
+		dev_dbg(dai->dev, "AIF%d using FLL2\n", dai->id);
 		break;
 
 	case WM8994_SYSCLK_OPCLK:
@@ -2005,7 +1818,6 @@ static int wm8994_set_bias_level(struct snd_soc_codec *codec,
 {
 	struct wm8994 *control = codec->control_data;
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
-//	DBG("Enter %s::%s---%d\n",__FILE__,__FUNCTION__,__LINE__);
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
@@ -2018,7 +1830,6 @@ static int wm8994_set_bias_level(struct snd_soc_codec *codec,
 		break;
 
 	case SND_SOC_BIAS_STANDBY:
-		printk("standby wm8994\n");
 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
 			pm_runtime_get_sync(codec->dev);
 
@@ -2263,7 +2074,6 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_codec *codec = dai->codec;
 	struct wm8994 *control = codec->control_data;
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
-	int rate = params_rate(params);
 	int aif1_reg;
 	int aif2_reg;
 	int bclk_reg;
@@ -2277,10 +2087,6 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 	int id = dai->id - 1;
 
 	int i, cur_val, best_val, bclk_rate, best;
-	
-	//snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
-		//	WM8994_MICB2_ENA ,
-		//	WM8994_MICB2_ENA);
 
 	switch (dai->id) {
 	case 1:
@@ -2295,10 +2101,6 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 			lrclk_reg = WM8994_AIF1ADC_LRCLK;
 			dev_dbg(codec->dev, "AIF1 using split LRCLK\n");
 		}
-		//add		
-		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,
-				WM8994_AIF2DACL_ENA_MASK | WM8994_AIF2DACR_ENA_MASK,
-				0);		
 		break;
 	case 2:
 		aif1_reg = WM8994_AIF2_CONTROL_1;
@@ -2312,23 +2114,6 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 			lrclk_reg = WM8994_AIF2ADC_LRCLK;
 			dev_dbg(codec->dev, "AIF2 using split LRCLK\n");
 		}
-		//add
-		rate = 8000;
-	//	wm8994_set_bias_level(codec,SND_SOC_BIAS_PREPARE);
-	//	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_2,
-	//			WM8994_IN2R_ENA | WM8994_IN2L_ENA | WM8994_MIXINR_ENA | WM8994_MIXINL_ENA,
-	//			WM8994_IN2R_ENA| WM8994_IN2L_ENA| WM8994_MIXINR_ENA | WM8994_MIXINL_ENA);	
-	//	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_3,
-	//			0x30a0,
-	//			0x30a0);
-	//	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_4,
-	//			0x3303,
-	//			0x3303);
-		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,
-				WM8994_AIF2DACL_ENA_MASK | WM8994_AIF2DACR_ENA_MASK,
-				1 << WM8994_AIF2DACL_ENA_SHIFT| 1<<WM8994_AIF2DACR_ENA_SHIFT);
-		
-
 		break;
 	case 3:
 		switch (control->type) {
@@ -2342,7 +2127,7 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	bclk_rate = rate * 4;
+	bclk_rate = params_rate(params) * 4;
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
 		bclk_rate *= 16;
@@ -2365,14 +2150,14 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 
 	/* Try to find an appropriate sample rate; look for an exact match. */
 	for (i = 0; i < ARRAY_SIZE(srs); i++)
-		if (srs[i].rate == rate)
+		if (srs[i].rate == params_rate(params))
 			break;
 	if (i == ARRAY_SIZE(srs))
 		return -EINVAL;
 	rate_val |= srs[i].val << WM8994_AIF1_SR_SHIFT;
 
-	DBG_INFO(dai->dev, "Sample rate is %dHz\n", srs[i].rate);
-	DBG_INFO(dai->dev, "AIF%dCLK is %dHz, target BCLK %dHz\n",
+	dev_dbg(dai->dev, "Sample rate is %dHz\n", srs[i].rate);
+	dev_dbg(dai->dev, "AIF%dCLK is %dHz, target BCLK %dHz\n",
 		dai->id, wm8994->aifclk[id], bclk_rate);
 
 	if (params_channels(params) == 1 &&
@@ -2386,17 +2171,17 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 
 	/* AIFCLK/fs ratio; look for a close match in either direction */
 	best = 0;
-	best_val = abs((fs_ratios[0] * rate)
+	best_val = abs((fs_ratios[0] * params_rate(params))
 		       - wm8994->aifclk[id]);
 	for (i = 1; i < ARRAY_SIZE(fs_ratios); i++) {
-		cur_val = abs((fs_ratios[i] * rate)
+		cur_val = abs((fs_ratios[i] * params_rate(params))
 			      - wm8994->aifclk[id]);
 		if (cur_val >= best_val)
 			continue;
 		best = i;
 		best_val = cur_val;
 	}
-	DBG_INFO(dai->dev, "Selected AIF%dCLK/fs = %d\n",
+	dev_dbg(dai->dev, "Selected AIF%dCLK/fs = %d\n",
 		dai->id, fs_ratios[best]);
 	rate_val |= best;
 
@@ -2413,12 +2198,12 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		best = i;
 	}
 	bclk_rate = wm8994->aifclk[id] * 10 / bclk_divs[best];
-	DBG_INFO(dai->dev, "Using BCLK_DIV %d for actual BCLK %dHz\n",
+	dev_dbg(dai->dev, "Using BCLK_DIV %d for actual BCLK %dHz\n",
 		bclk_divs[best], bclk_rate);
 	bclk |= best << WM8994_AIF1_BCLK_DIV_SHIFT;
 
-	lrclk = bclk_rate / rate;
-	DBG_INFO(dai->dev, "Using LRCLK rate %d for actual LRCLK %dHz\n",
+	lrclk = bclk_rate / params_rate(params);
+	dev_dbg(dai->dev, "Using LRCLK rate %d for actual LRCLK %dHz\n",
 		lrclk, bclk_rate / lrclk);
 
 	snd_soc_update_bits(codec, aif1_reg, WM8994_AIF1_WL_MASK, aif1);
@@ -2432,12 +2217,12 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		switch (dai->id) {
 		case 1:
-			wm8994->dac_rates[0] = rate;
+			wm8994->dac_rates[0] = params_rate(params);
 			wm8994_set_retune_mobile(codec, 0);
 			wm8994_set_retune_mobile(codec, 1);
 			break;
 		case 2:
-			wm8994->dac_rates[1] = rate;
+			wm8994->dac_rates[1] = params_rate(params);
 			wm8994_set_retune_mobile(codec, 2);
 			break;
 		}
@@ -2638,15 +2423,7 @@ static int wm8994_suspend(struct snd_soc_codec *codec, pm_message_t state)
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = codec->control_data;
 	int i, ret;
-	
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
-	DBG("on wm8994.c wm8994_suspend\n");
-	if(snd_soc_incall_status(0,0))
-	{
-		DBG("incalling  cannot suspend\n");
-		return 0;
-	}
-#endif
+
 	switch (control->type) {
 	case WM8994:
 		snd_soc_update_bits(codec, WM8994_MICBIAS, WM8994_MICD_ENA, 0);
@@ -2677,15 +2454,6 @@ static int wm8994_resume(struct snd_soc_codec *codec)
 	struct wm8994 *control = codec->control_data;
 	int i, ret;
 	unsigned int val, mask;
-	
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
-	printk("on wm8994.c wm8994_resume\n");
-	if(snd_soc_incall_status(0,0))
-	{
-		DBG("incalling cannot resume\n");
-		return 0;
-	}
-#endif
 
 	if (wm8994->revision < 4) {
 		/* force a HW read */
@@ -2873,7 +2641,7 @@ static void wm8994_handle_pdata(struct wm8994_priv *wm8994)
 	else
 		snd_soc_add_controls(wm8994->codec, wm8994_eq_controls,
 				     ARRAY_SIZE(wm8994_eq_controls));
-	
+
 	for (i = 0; i < ARRAY_SIZE(pdata->micbias); i++) {
 		if (pdata->micbias[i]) {
 			snd_soc_write(codec, WM8958_MICBIAS1 + i,
@@ -2941,41 +2709,6 @@ int wm8994_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,
 }
 EXPORT_SYMBOL_GPL(wm8994_mic_detect);
 
-int wm8994_headset_mic_detect(bool headset_status)
-{
-	struct wm8994_priv *wm8994 = NULL;
-	int jack_type = 0;
-	printk("%s::%d\n",__FUNCTION__,__LINE__);
-	
-	if(wm8994_codec == NULL)
-		return -1;
-	wm8994 = snd_soc_codec_get_drvdata(wm8994_codec);
-	if(wm8994 == NULL)
-		return -1;
-	if(headset_status)
-	{
-		while(wm8994_codec->dapm.bias_level == SND_SOC_BIAS_OFF)
-		{
-			printk("----------wm8994 unnot standby-----------------\n");
-			msleep(300);
-		}
-		
-		snd_soc_update_bits(wm8994_codec, WM8994_POWER_MANAGEMENT_1,
-			WM8994_MICB2_ENA ,
-			WM8994_MICB2_ENA);		
-		
-		msleep(400);
-	}
-	else
-	{// headset is out,disable MIC2 Bias
-		printk("headset is out,disable Mic2 Bias\n");
-		snd_soc_update_bits(wm8994_codec, WM8994_POWER_MANAGEMENT_1,
-			WM8994_MICB2_ENA,
-			0);		
-	}
-	return jack_type;
-}
-EXPORT_SYMBOL(wm8994_headset_mic_detect);
 static irqreturn_t wm8994_mic_irq(int irq, void *data)
 {
 	struct wm8994_priv *priv = data;
@@ -3116,56 +2849,13 @@ static irqreturn_t wm8958_mic_irq(int irq, void *data)
 out:
 	return IRQ_HANDLED;
 }
-#ifdef CONFIG_HDMI
-#include <linux/hdmi.h>
-void codec_set_spk(bool on)
-{
-        struct snd_soc_codec *codec = wm8994_codec;
-
-        DBG("%s: %d\n", __func__, on);
-
-        if(!codec)
-                return;
-
-        if(on){
-                DBG("snd_soc_dapm_enable_pin\n");
-                snd_soc_dapm_enable_pin(&codec->dapm, "Ext Left Spk");
-                snd_soc_dapm_enable_pin(&codec->dapm, "Ext Right Spk");
-                snd_soc_dapm_enable_pin(&codec->dapm, "Headset Stereophone");
-        }
-        else{
-
-                DBG("snd_soc_dapm_disable_pin\n");
-                snd_soc_dapm_disable_pin(&codec->dapm, "Ext Left Spk");
-                snd_soc_dapm_disable_pin(&codec->dapm, "Ext Right Spk");
-                snd_soc_dapm_disable_pin(&codec->dapm, "Headset Stereophone");
-        }
-
-        snd_soc_dapm_sync(&codec->dapm);
-
-        return;
-}
-static struct hdmi_codec_driver hdmi_codec_driver = {
-    .hdmi_get_spk = NULL,
-    .hdmi_set_spk = codec_set_spk,
-};
-#endif 
-
-#ifdef WM8994_PROC	
-static int wm8994_proc_init(void);
-#endif
 
 static int wm8994_codec_probe(struct snd_soc_codec *codec)
 {
 	struct wm8994 *control;
 	struct wm8994_priv *wm8994;
-	struct wm8994_pdata *pdata;
 	struct snd_soc_dapm_context *dapm = &codec->dapm;
 	int ret, i;
-	
-#ifdef WM8994_PROC	
-	wm8994_proc_init();
-#endif
 
 	codec->control_data = dev_get_drvdata(codec->dev->parent);
 	control = codec->control_data;
@@ -3176,10 +2866,8 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	snd_soc_codec_set_drvdata(codec, wm8994);
 
 	wm8994->pdata = dev_get_platdata(codec->dev->parent);
-	pdata = wm8994->pdata;
 	wm8994->codec = codec;
-	wm8994_codec = codec;
-	
+
 	if (wm8994->pdata && wm8994->pdata->micdet_irq)
 		wm8994->micdet_irq = wm8994->pdata->micdet_irq;
 	else if (wm8994->pdata && wm8994->pdata->irq_base)
@@ -3371,7 +3059,7 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	wm8994_update_class_w(codec);
 
 	wm8994_handle_pdata(wm8994);
-	
+
 	wm_hubs_add_analogue_controls(codec);
 	snd_soc_add_controls(codec, wm8994_snd_controls,
 			     ARRAY_SIZE(wm8994_snd_controls));
@@ -3422,7 +3110,7 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	}
 		
 
-	wm_hubs_add_analogue_routes(codec, 1, 0);
+	wm_hubs_add_analogue_routes(codec, 0, 0);
 	snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
 
 	switch (control->type) {
@@ -3431,7 +3119,6 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 					ARRAY_SIZE(wm8994_intercon));
 
 		if (wm8994->revision < 4) {
-			printk("wm8994->revision = %d\n",wm8994->revision);
 			snd_soc_dapm_add_routes(dapm, wm8994_revd_intercon,
 						ARRAY_SIZE(wm8994_revd_intercon));
 			snd_soc_dapm_add_routes(dapm, wm8994_lateclk_revd_intercon,
@@ -3457,35 +3144,7 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 		wm8958_dsp2_init(codec);
 		break;
 	}
-	
-	if(pdata ->PA_control_pin)
-	{
-		DBG_INFO(codec->dev,"Add the PA control route\n");
-		snd_soc_dapm_new_controls(dapm, wm8994_PA_dapm_widgets,
-				  ARRAY_SIZE(wm8994_PA_dapm_widgets));	
-		snd_soc_dapm_add_routes(dapm, wm8994_PA_intercon, 
-				ARRAY_SIZE(wm8994_PA_intercon));
-		if(pdata->PA_iomux_name != NULL)
-			rk29_mux_api_set(pdata->PA_iomux_name, pdata->PA_iomux_mode);
-		gpio_request(pdata->PA_control_pin, "wm8994_PA_ctrl");				
-		gpio_direction_output(pdata->PA_control_pin,GPIO_LOW);
-	}
-	else
-		dev_info(codec->dev, "have not pa control\n");	
-
-	//lineout off
-//	snd_soc_dapm_new_controls(dapm, wm8994_lineout_status_dapm_widgets,
-//				 ARRAY_SIZE(wm8994_lineout_status_dapm_widgets));	
-//	snd_soc_dapm_add_routes(dapm, wm8994_lineout_status_intercon, 
-//				ARRAY_SIZE(wm8994_lineout_status_intercon));
-	#ifdef CONFIG_HDMI
-		hdmi_codec_driver.name = "wm8994";
-		ret = hdmi_codec_register(&hdmi_codec_driver);
-		if (ret != 0) {
-			printk("Failed to register HDMI_codec: %d\n", ret);
-    }
-	#endif
-	
+
 	return 0;
 
 err_irq:
@@ -3503,8 +3162,7 @@ static int  wm8994_codec_remove(struct snd_soc_codec *codec)
 {
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = codec->control_data;
-	struct wm8994_pdata *pdata = wm8994->pdata;
-	
+
 	wm8994_set_bias_level(codec, SND_SOC_BIAS_OFF);
 
 	pm_runtime_disable(codec->dev);
@@ -3532,8 +3190,6 @@ static int  wm8994_codec_remove(struct snd_soc_codec *codec)
 		release_firmware(wm8994->mbc_vss);
 	if (wm8994->enh_eq)
 		release_firmware(wm8994->enh_eq);
-	if (gpio_is_valid(pdata->PA_control_pin))
-		gpio_free(pdata->PA_control_pin);
 	kfree(wm8994->retune_mobile_texts);
 	kfree(wm8994->drc_texts);
 	kfree(wm8994);
@@ -3596,354 +3252,3 @@ MODULE_DESCRIPTION("ASoC WM8994 driver");
 MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfsonmicro.com>");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:wm8994-codec");
-
-//=====================================================================
-//Proc
-#ifdef WM8994_PROC
-void mainMIC_to_BB_to_earpiece(void)
-{
-	DBG("%s::%d\n",__FUNCTION__,__LINE__);
-
-//	wm8994_write(wm8994_codec,0x0000,0x0000);
-//	wm8994_write(wm8994_codec,0x0001,0x0023);
-//	wm8994_write(wm8994_codec,0x0200,0x0000);
-//	wm8994_write(wm8994_codec,0x0222,0x0000);
-//	wm8994_write(wm8994_codec,0x0223,0x0400);
-//	wm8994_write(wm8994_codec,0x0220,0x0005);
-//	wm8994_write(wm8994_codec,0x0208,0x000a);
-//	wm8994_write(wm8994_codec,0x0210,0x0073);
-//	wm8994_write(wm8994_codec,0x0200,0x0011);
-
-	wm8994_write(wm8994_codec,0x0034,0x0004);
-	wm8994_write(wm8994_codec,0x002b,0x0007);
-	wm8994_write(wm8994_codec,0x002e,0x0081);
-	
-//	wm8994_write(wm8994_codec,0x0601,0x0001);
-//	wm8994_write(wm8994_codec,0x0610,0x01c0);
-//	wm8994_write(wm8994_codec,0x0611,0x01c0);
-	wm8994_write(wm8994_codec,0x0033,0x0018);
-//	wm8994_write(wm8994_codec,0x0031,0x0000);
-//	wm8994_write(wm8994_codec,0x004c,0x9f25);
-//	wm8994_write(wm8994_codec,0x0001,0x0833);
-	
-//	wm8994_write(wm8994_codec,0x0020,0x0179);
-//	wm8994_write(wm8994_codec,0x0021,0x0179);
-}
-void BT_BB(void)
-{//
-	DBG("%s::%d\n",__FUNCTION__,__LINE__);
-#if 0
-//	wm8994_reg_write(wm8994_codec->control_data,0x0,  0x0);
-	msleep(50);
-
-	wm8994_reg_write(wm8994_codec->control_data,0x01,  0x0023);
-	wm8994_reg_write(wm8994_codec->control_data,0x200, 0x0000);
-	msleep(50);
-//CLK
-	//AIF2CLK use FLL2
-    //BT CLK = 8000
-    //8KHz, BCLK=8KHz*64=512KHz, Fout=2.048MHz
-    
-	wm8994_reg_write(wm8994_codec->control_data,0x241, 0x2b00);
-	wm8994_reg_write(wm8994_codec->control_data,0x242, 0xfb5b);
-	wm8994_reg_write(wm8994_codec->control_data,0x243, 0x00e0);
-	wm8994_reg_write(wm8994_codec->control_data,0x240, 0x0005);    //FLL2_ENA = 1  \u8fd9\u8fb9\u5f97\u5230\u7684FLL CLK\u5e94\u8be5=2.048M
-
-	wm8994_reg_write(wm8994_codec->control_data,0x204, 0x0018);    // AIF2CLK_SRC=10 use FLL2 AIF2CLK_ENA=0
-	wm8994_reg_write(wm8994_codec->control_data,0x208, 0x000F);    // DSP_FS1CLK_ENA = 1 DSP_FS2CLK_ENA = 1 DSP_FSINTCLK_ENA =1 SYSCLK_SRC=AIF1CLK
-	wm8994_reg_write(wm8994_codec->control_data,0x211, 0x0003);    // AIF2_SR[3:0]=0 8k   AIF2CLK_RATE [3:0]=3 256\u5206\u9891    Fout = 8000 * 256 = 2.048MHz
-
-	wm8994_reg_write(wm8994_codec->control_data,0x312, 0x3000);    // AIF2 Master/Slave(312H): 7000  AIF2_TRI=0, AIF2_MSTR=1, AIF2_CLK_FRC=0, AIF2_LRCLK_FRC=0
-	msleep(30);
-	wm8994_reg_write(wm8994_codec->control_data,0x312, 0x7000);
-	wm8994_reg_write(wm8994_codec->control_data,0x313, 0x0020);    // AIF2 BCLK DIV--------AIF1CLK/2
-	wm8994_reg_write(wm8994_codec->control_data,0x314, 0x0080);    // AIF2 ADCLRCK DIV-----BCLK/128
-	wm8994_reg_write(wm8994_codec->control_data,0x315, 0x0080);
-	wm8994_reg_write(wm8994_codec->control_data,0x310, 0x0118);    // DSP/PCM; 16bits; ADC L channel = R channel;MODE A
-
-	wm8994_reg_write(wm8994_codec->control_data,0x204, 0x0019);    // AIF2CLK_SRC=10 use FLL2 AIF2CLK_ENA=1
-	
-//GPIO
-	wm8994_reg_write(wm8994_codec->control_data,0x702, 0x2100);//BCLK2
-	wm8994_reg_write(wm8994_codec->control_data,0x703, 0x2100);//DACLRCLK2
-	wm8994_reg_write(wm8994_codec->control_data,0x704, 0xA100);//DACDAT2
-	wm8994_reg_write(wm8994_codec->control_data,0x707, 0xA100);//DACDAT3
-	wm8994_reg_write(wm8994_codec->control_data,0x708, 0x2100);//ADCDAT3
-	wm8994_reg_write(wm8994_codec->control_data,0x709, 0x2100);//LRCLK3
-	wm8994_reg_write(wm8994_codec->control_data,0x70A, 0x2100);//BCLK3
-	wm8994_reg_write(wm8994_codec->control_data,0x06,  0x000A);
-//1010  bit_0 AIF1DACDAT=DACDAT1 bit_1 AIF2DACDAT=GPIO8/DACDAT3 bit_2 GPIO7/ADCDAT2=AIF2ADCDAT2 bit_3 GPIO9/ADCDAT3=AIF2ADCDAT2
-//path
-	
-    //listen   IN2RP/IN2LP to MIXIN to ADC to DAC2 to AIF2
-	wm8994_reg_write(wm8994_codec->control_data,0x28,   0x00C0);   //IN2LP_TO_IN2L IN2LN_TO_IN2L
-	wm8994_reg_write(wm8994_codec->control_data,0x29,   0x0100);   //IN2L_TO_MIXINL   BB
-	wm8994_reg_write(wm8994_codec->control_data,0x2A,   0x0100);   //IN2R_TO_MIXINR
-	wm8994_reg_write(wm8994_codec->control_data,0x604,  0x0010);   //ADC1_TO_DAC2L
-	wm8994_reg_write(wm8994_codec->control_data,0x605,  0x0010);   //ADC1_TO_DAC2R
-//	wm8994_reg_write(wm8994_codec->control_data,0x29,   0x0130);//IN1L_TO_MIXINL   MIC
-//	wm8994_reg_write(wm8994_codec->control_data,0x2A,   0x0130);//IN1R_TO_MIXINR
-    //say   AIF2DACL to DACL to MIXOUTL to LINEOUT
-    //\u6309\u952e\u97f3 AIF1ADCR to DACR to MIXOUTR to SPKMIXR
-	wm8994_reg_write(wm8994_codec->control_data,0x601,  0x0004);   //AIF2DACL_TO_DAC1L
-	wm8994_reg_write(wm8994_codec->control_data,0x602,  0x0001);   //AIF1DAC1R_TO_DAC1R
-	wm8994_reg_write(wm8994_codec->control_data,0x2D,   0x0001);   //DAC1L_TO_MIXOUTL
-	wm8994_reg_write(wm8994_codec->control_data,0x2E,   0x0001);   //DAC1R_TO_MIXOUTR
-	wm8994_reg_write(wm8994_codec->control_data,0x34,   0x0001);   //MIXOUTL_TO_LINEOUT1P
-	wm8994_reg_write(wm8994_codec->control_data,0x36,   0x0004);   //MIXOUTR_TO_SPKMIXR
-	wm8994_reg_write(wm8994_codec->control_data,0x24,   0x0009);   //SPKMIXR_TO_SPKOUTL   SPKMIXR_TO_SPKOUTR
-	
-//volume
-	wm8994_reg_write(wm8994_codec->control_data,0x19,   0x011F);   // IN2L volume
-	wm8994_reg_write(wm8994_codec->control_data,0x20,   0x017F);   // MIXOUTL volume
-	wm8994_reg_write(wm8994_codec->control_data,0x0500, 0x017F);   // AIF2 ADC Left Volume
-	wm8994_reg_write(wm8994_codec->control_data,0x0501, 0x0100);   // AIF2 ADC Right Volume mute
-	wm8994_reg_write(wm8994_codec->control_data,0x1E,   0x0006);   //LINEOUT2N_MUTE=UN-MUTE  LINEOUT2P_MUTE=UN-MUTE
-
-	wm8994_reg_write(wm8994_codec->control_data,0x22,   0x0000);
-	wm8994_reg_write(wm8994_codec->control_data,0x23,   0x0100);
-	wm8994_reg_write(wm8994_codec->control_data,0x610, 0x01C0);//DAC1L
-	wm8994_reg_write(wm8994_codec->control_data,0x611, 0x01C0);//DAC1R
-	wm8994_reg_write(wm8994_codec->control_data,0x612, 0x01C0);//DAC2L
-	wm8994_reg_write(wm8994_codec->control_data,0x613, 0x01C0);//DAC2R
-
-	wm8994_reg_write(wm8994_codec->control_data,0x603, 0x000C);//ADC1_DAC2_VOL[3:0] 1100 0DB
-	wm8994_reg_write(wm8994_codec->control_data,0x620, 0x0000);
-	wm8994_reg_write(wm8994_codec->control_data,0x420, 0x0000);
-//other
-	wm8994_reg_write(wm8994_codec->control_data,0x4C,   0x9F25);
-	wm8994_reg_write(wm8994_codec->control_data,0x60,   0x00EE);
-	msleep(5);
-//power
-	wm8994_reg_write(wm8994_codec->control_data,0x01,   0x3033);
-	wm8994_reg_write(wm8994_codec->control_data,0x02,   0x63A0);
-	wm8994_reg_write(wm8994_codec->control_data,0x03,   0x33F0);
-	wm8994_reg_write(wm8994_codec->control_data,0x04,   0x3303);
-	wm8994_reg_write(wm8994_codec->control_data,0x05,   0x3303);
-#endif	
-//	wm8994_write(wm8994_codec,0x0,  0x0);
-//	msleep(50);
-
-//	wm8994_write(wm8994_codec,0x01,  0x0023);
-//	wm8994_write(wm8994_codec,0x200, 0x0000);
-//	msleep(50);
-//CLK
-	//AIF2CLK use FLL2
-    //BT CLK = 8000
-    //8KHz, BCLK=8KHz*64=512KHz, Fout=2.048MHz
-    
-//	wm8994_write(wm8994_codec,0x241, 0x2b00);
-//	wm8994_write(wm8994_codec,0x242, 0xfb5b);
-//	wm8994_write(wm8994_codec,0x243, 0x00e0);
-//	wm8994_write(wm8994_codec,0x240, 0x0005);    //FLL2_ENA = 1  \u8fd9\u8fb9\u5f97\u5230\u7684FLL CLK\u5e94\u8be5=2.048M
-
-//	wm8994_write(wm8994_codec,0x204, 0x0018);    // AIF2CLK_SRC=10 use FLL2 AIF2CLK_ENA=0
-//	wm8994_write(wm8994_codec,0x208, 0x000F);    // DSP_FS1CLK_ENA = 1 DSP_FS2CLK_ENA = 1 DSP_FSINTCLK_ENA =1 SYSCLK_SRC=AIF1CLK
-//	wm8994_write(wm8994_codec,0x211, 0x0003);    // AIF2_SR[3:0]=0 8k   AIF2CLK_RATE [3:0]=3 256\u5206\u9891    Fout = 8000 * 256 = 2.048MHz
-
-//	wm8994_write(wm8994_codec,0x312, 0x3000);    // AIF2 Master/Slave(312H): 7000  AIF2_TRI=0, AIF2_MSTR=1, AIF2_CLK_FRC=0, AIF2_LRCLK_FRC=0
-//	msleep(30);
-//	wm8994_write(wm8994_codec,0x312, 0x7000);
-//	wm8994_write(wm8994_codec,0x313, 0x0020);    // AIF2 BCLK DIV--------AIF1CLK/2
-//	wm8994_write(wm8994_codec,0x314, 0x0080);    // AIF2 ADCLRCK DIV-----BCLK/128
-//	wm8994_write(wm8994_codec,0x315, 0x0080);
-//	wm8994_write(wm8994_codec,0x310, 0x0118);    // DSP/PCM; 16bits; ADC L channel = R channel;MODE A
-
-//	wm8994_write(wm8994_codec,0x204, 0x0019);    // AIF2CLK_SRC=10 use FLL2 AIF2CLK_ENA=1
-	
-//GPIO
-//	wm8994_write(wm8994_codec,0x702, 0x2100);//BCLK2
-//	wm8994_write(wm8994_codec,0x703, 0x2100);//DACLRCLK2
-//	wm8994_write(wm8994_codec,0x704, 0xA100);//DACDAT2
-//	wm8994_write(wm8994_codec,0x707, 0xA100);//DACDAT3
-//	wm8994_write(wm8994_codec,0x708, 0x2100);//ADCDAT3
-//	wm8994_write(wm8994_codec,0x709, 0x2100);//LRCLK3
-//	wm8994_write(wm8994_codec,0x70A, 0x2100);//BCLK3
-//	wm8994_write(wm8994_codec,0x06,  0x000A);
-//1010  bit_0 AIF1DACDAT=DACDAT1 bit_1 AIF2DACDAT=GPIO8/DACDAT3 bit_2 GPIO7/ADCDAT2=AIF2ADCDAT2 bit_3 GPIO9/ADCDAT3=AIF2ADCDAT2
-//path
-	
-    //listen   IN2RP/IN2LP to MIXIN to ADC to DAC2 to AIF2
-	wm8994_write(wm8994_codec,0x28,   0x00C0);   //IN2LP_TO_IN2L IN2LN_TO_IN2L
-	wm8994_write(wm8994_codec,0x29,   0x0100);   //IN2L_TO_MIXINL   BB
-	wm8994_write(wm8994_codec,0x2A,   0x0100);   //IN2R_TO_MIXINR
-	wm8994_write(wm8994_codec,0x604,  0x0010);   //ADC1_TO_DAC2L
-	wm8994_write(wm8994_codec,0x605,  0x0010);   //ADC1_TO_DAC2R
-//	wm8994_reg_write(wm8994_codec->control_data,0x29,   0x0130);//IN1L_TO_MIXINL   MIC
-//	wm8994_reg_write(wm8994_codec->control_data,0x2A,   0x0130);//IN1R_TO_MIXINR
-    //say   AIF2DACL to DACL to MIXOUTL to LINEOUT
-    //\u6309\u952e\u97f3 AIF1ADCR to DACR to MIXOUTR to SPKMIXR
-	wm8994_write(wm8994_codec,0x601,  0x0004);   //AIF2DACL_TO_DAC1L
-//	wm8994_write(wm8994_codec,0x602,  0x0001);   //AIF1DAC1R_TO_DAC1R
-	wm8994_write(wm8994_codec,0x2D,   0x0001);   //DAC1L_TO_MIXOUTL
-//	wm8994_write(wm8994_codec,0x2E,   0x0001);   //DAC1R_TO_MIXOUTR
-	wm8994_write(wm8994_codec,0x34,   0x0001);   //MIXOUTL_TO_LINEOUT1P
-//	wm8994_write(wm8994_codec,0x36,   0x0004);   //MIXOUTR_TO_SPKMIXR
-	wm8994_write(wm8994_codec,0x24,   0x0009);   //SPKMIXR_TO_SPKOUTL   SPKMIXR_TO_SPKOUTR
-	/*
-//volume
-	wm8994_write(wm8994_codec,0x19,   0x011F);   // IN2L volume
-	wm8994_write(wm8994_codec,0x20,   0x017F);   // MIXOUTL volume
-	wm8994_write(wm8994_codec,0x0500, 0x017F);   // AIF2 ADC Left Volume
-	wm8994_write(wm8994_codec,0x0501, 0x0100);   // AIF2 ADC Right Volume mute
-	wm8994_write(wm8994_codec,0x1E,   0x0006);   //LINEOUT2N_MUTE=UN-MUTE  LINEOUT2P_MUTE=UN-MUTE
-
-	wm8994_write(wm8994_codec,0x22,   0x0000);
-	wm8994_write(wm8994_codec,0x23,   0x0100);
-	wm8994_write(wm8994_codec,0x610, 0x01C0);//DAC1L
-	wm8994_write(wm8994_codec,0x611, 0x01C0);//DAC1R
-	wm8994_write(wm8994_codec,0x612, 0x01C0);//DAC2L
-	wm8994_write(wm8994_codec,0x613, 0x01C0);//DAC2R
-
-	wm8994_write(wm8994_codec,0x603, 0x000C);//ADC1_DAC2_VOL[3:0] 1100 0DB
-	wm8994_write(wm8994_codec,0x620, 0x0000);
-	wm8994_write(wm8994_codec,0x420, 0x0000);*/
-//other
-//	wm8994_write(wm8994_codec,0x4C,   0x9F25);
-//	wm8994_write(wm8994_codec,0x60,   0x00EE);
-//	msleep(5);
-//power
-//	wm8994_write(wm8994_codec,0x01,   0x0003);
-//	wm8994_write(wm8994_codec,0x02,   0x63A0);
-//	wm8994_write(wm8994_codec,0x03,   0x30a0);
-//	wm8994_write(wm8994_codec,0x04,   0x3303);
-//	wm8994_write(wm8994_codec,0x05,   0x3003);
-
-}
-
-static ssize_t wm8994_proc_write(struct file *file, const char __user *buffer,
-			   unsigned long len, void *data)
-{
-	char *cookie_pot; 
-	char *p;
-	int reg;
-	int value;
-	
-	cookie_pot = (char *)vmalloc( len );
-	if (!cookie_pot) 
-	{
-		return -ENOMEM;
-	} 
-	else 
-	{
-		if (copy_from_user( cookie_pot, buffer, len )) 
-			return -EFAULT;
-	}
-
-	switch(cookie_pot[0])
-	{
-	case 'd':
-	case 'D':
-		debug_write_read ++;
-		debug_write_read %= 2;
-		if(debug_write_read != 0)
-			printk("Debug read and write reg on\n");
-		else	
-			printk("Debug read and write reg off\n");	
-		break;	
-	case 'r':
-	case 'R':
-		printk("Read reg debug\n");		
-		if(cookie_pot[1] ==':')
-		{
-			debug_write_read = 1;
-			strsep(&cookie_pot,":");
-			while((p=strsep(&cookie_pot,",")))
-			{
-				reg = simple_strtol(p,NULL,16);
-				value = wm8994_reg_read(wm8994_codec->control_data,reg);
-				printk("wm8994_read:0x%04x = 0x%04x\n",reg,value);
-			}
-			debug_write_read = 0;
-			printk("\n");
-		}
-		else
-		{
-			printk("Error Read reg debug.\n");
-			printk("For example: echo 'r:22,23,24,25'>wm8994_ts\n");
-		}
-		break;
-	case 'w':
-	case 'W':
-		printk("Write reg debug\n");		
-		if(cookie_pot[1] ==':')
-		{
-			debug_write_read = 1;
-			strsep(&cookie_pot,":");
-			while((p=strsep(&cookie_pot,"=")))
-			{
-				reg = simple_strtol(p,NULL,16);
-				p=strsep(&cookie_pot,",");
-				value = simple_strtol(p,NULL,16);
-				wm8994_reg_write(wm8994_codec->control_data,reg,value);
-				printk("wm8994_write:0x%04x = 0x%04x\n",reg,value);
-			}
-			debug_write_read = 0;
-			printk("\n");
-		}
-		else
-		{
-			printk("Error Write reg debug.\n");
-			printk("For example: w:22=0,23=0,24=0,25=0\n");
-		}
-		break;
-	case 'p'://enable pa
-	//	gpio_request(RK29_PIN6_PD3, NULL);			 	
-	//	gpio_direction_output(RK29_PIN6_PD3,GPIO_HIGH); 			
-	//	gpio_free(RK29_PIN6_PD3);
-		break;
-
-	case 'a':
-		printk("Dump reg \n");		
-
-		for(reg = 0; reg < 0x621; reg++)
-		{
-			value = wm8994_reg_read(wm8994_codec->control_data,reg);
-			printk("wm8994_read:0x%04x = 0x%04x\n",reg,value);
-		}
-
-		break;		
-	case 'b':
-		BT_BB();
-		break;
-	case 'c':
-		mainMIC_to_BB_to_earpiece();
-		break;
-	default:
-		printk("Help for wm8994_ts .\n-->The Cmd list: \n");
-		printk("-->'d&&D' Open or Off the debug\n");
-		printk("-->'r&&R' Read reg debug,Example: echo 'r:22,23,24,25'>wm8994_ts\n");
-		printk("-->'w&&W' Write reg debug,Example: echo 'w:22=0,23=0,24=0,25=0'>wm8994_ts\n");
-		break;
-	}
-
-	return len;
-}
-static const struct file_operations wm8994_proc_fops = {
-	.owner		= THIS_MODULE,
-	//.open		= snd_mem_proc_open,
-	//.read		= seq_read,
-//#ifdef CONFIG_PCI
-//	.write		= wm8994_proc_write,
-//#endif
-	//.llseek	= seq_lseek,
-	//.release	= single_release,
-};
-
-static int wm8994_proc_init(void)
-{
-	struct proc_dir_entry *wm8994_proc_entry;
-	wm8994_proc_entry = create_proc_entry("driver/wm8994_ts", 0777, NULL);
-	if(wm8994_proc_entry != NULL)
-	{
-		wm8994_proc_entry->write_proc = wm8994_proc_write;
-		return -1;
-	}
-	else
-	{
-		printk("create proc error !\n");
-	}
-	return 0;
-}
-
-#endif
diff --git a/sound/soc/codecs/wm8994.h b/sound/soc/codecs/wm8994.h
index 1eef4d3d18bc..0a1db04b73bd 100644
--- a/sound/soc/codecs/wm8994.h
+++ b/sound/soc/codecs/wm8994.h
@@ -140,11 +140,6 @@ struct wm8994_priv {
 	const struct firmware *mbc;
 	const struct firmware *mbc_vss;
 	const struct firmware *enh_eq;
-
-	unsigned int lineout_status:1;
 };
 
-int lineout_event(struct snd_soc_dapm_widget *w,
-			  struct snd_kcontrol *control, int event);
-
 #endif
diff --git a/sound/soc/codecs/wm_hubs.c b/sound/soc/codecs/wm_hubs.c
index caff8376b57c..8712a9f6d6ec 100644
--- a/sound/soc/codecs/wm_hubs.c
+++ b/sound/soc/codecs/wm_hubs.c
@@ -26,7 +26,6 @@
 #include <sound/tlv.h>
 
 #include "wm8993.h"
-#include "wm8994.h"
 #include "wm_hubs.h"
 
 const DECLARE_TLV_DB_SCALE(wm_hubs_spkmix_tlv, -300, 300, 0);
@@ -77,10 +76,10 @@ static void wait_for_dc_servo(struct snd_soc_codec *codec, unsigned int op)
 
 	do {
 		count++;
-		msleep(100);
+		msleep(1);
 		reg = snd_soc_read(codec, WM8993_DC_SERVO_0);
 		dev_dbg(codec->dev, "DC servo: %x\n", reg);
-	} while (reg & op && count < 4);
+	} while (reg & op && count < 400);
 
 	if (reg & op)
 		dev_err(codec->dev, "Timed out waiting for DC Servo %x\n",
@@ -213,14 +212,6 @@ static int wm8993_put_dc_servo(struct snd_kcontrol *kcontrol,
 }
 
 static const struct snd_kcontrol_new analogue_snd_controls[] = {
-//for mic mute		
-SOC_SINGLE_TLV("Main Mic Capture Volume", WM8993_RIGHT_LINE_INPUT_1_2_VOLUME, 0, 31, 0,
-		  inpga_tlv),
-SOC_SINGLE("Main Mic Capture Switch", WM8993_RIGHT_LINE_INPUT_1_2_VOLUME, 7, 1, 1),		
-SOC_SINGLE("Headset Mic Capture Switch", WM8993_LEFT_LINE_INPUT_1_2_VOLUME, 7, 1, 1),		
-SOC_SINGLE_TLV("Headset Mic Capture Volume", WM8993_LEFT_LINE_INPUT_1_2_VOLUME, 0, 31, 0,
-       inpga_tlv),		
-//end	
 SOC_SINGLE_TLV("IN1L Volume", WM8993_LEFT_LINE_INPUT_1_2_VOLUME, 0, 31, 0,
 	       inpga_tlv),
 SOC_SINGLE("IN1L Switch", WM8993_LEFT_LINE_INPUT_1_2_VOLUME, 7, 1, 1),
@@ -304,9 +295,7 @@ SOC_DOUBLE_R("Output ZC Switch", WM8993_LEFT_OPGA_VOLUME,
 	     WM8993_RIGHT_OPGA_VOLUME, 7, 1, 0),
 
 SOC_SINGLE("Earpiece Switch", WM8993_HPOUT2_VOLUME, 5, 1, 1),
-SOC_SINGLE_TLV("HPOUT2 Volume", WM8993_HPOUT2_VOLUME, 4, 1, 1, earpiece_tlv),
-SOC_DOUBLE_R_TLV("Earpiece Volume", WM8993_LEFT_OPGA_VOLUME, 
-		WM8993_RIGHT_OPGA_VOLUME, 0, 63, 0, outpga_tlv),
+SOC_SINGLE_TLV("Earpiece Volume", WM8993_HPOUT2_VOLUME, 4, 1, 1, earpiece_tlv),
 
 SOC_SINGLE_TLV("SPKL Input Volume", WM8993_SPKMIXL_ATTENUATION,
 	       5, 1, 1, wm_hubs_spkmix_tlv),
@@ -417,19 +406,6 @@ static int hp_event(struct snd_soc_dapm_widget *w,
 
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
-		snd_soc_update_bits(codec, WM8993_LEFT_OUTPUT_VOLUME,
-					WM8993_HPOUT1_VU ,
-					0 | 0);
-		snd_soc_update_bits(codec, WM8993_RIGHT_OUTPUT_VOLUME,
-					WM8993_HPOUT1_VU ,
-					0 | 0);
-		snd_soc_update_bits(codec, WM8993_LEFT_OUTPUT_VOLUME,
-					WM8993_HPOUT1_VU ,
-					WM8993_HPOUT1_VU );
-		snd_soc_update_bits(codec, WM8993_RIGHT_OUTPUT_VOLUME,
-					WM8993_HPOUT1_VU ,
-					WM8993_HPOUT1_VU );
-					
 		snd_soc_update_bits(codec, WM8993_CHARGE_PUMP_1,
 				    WM8993_CP_ENA, WM8993_CP_ENA);
 
@@ -677,17 +653,10 @@ SND_SOC_DAPM_MIXER("LINEOUT2N Mixer", SND_SOC_NOPM, 0, 0,
 SND_SOC_DAPM_MIXER("LINEOUT2P Mixer", SND_SOC_NOPM, 0, 0,
 		   line2p_mix, ARRAY_SIZE(line2p_mix)),
 
-//SND_SOC_DAPM_PGA("LINEOUT1N Driver", WM8993_POWER_MANAGEMENT_3, 13, 0,
-//		 NULL, 0),
-//SND_SOC_DAPM_PGA("LINEOUT1P Driver", WM8993_POWER_MANAGEMENT_3, 12, 0,
-//		 NULL, 0),
-SND_SOC_DAPM_PGA_E("LINEOUT1N Driver", WM8993_POWER_MANAGEMENT_3, 13, 0,
-		 NULL, 0,
-		 lineout_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
-SND_SOC_DAPM_PGA_E("LINEOUT1P Driver", WM8993_POWER_MANAGEMENT_3, 12, 0,
-		 NULL, 0,
-		 lineout_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
-		 
+SND_SOC_DAPM_PGA("LINEOUT1N Driver", WM8993_POWER_MANAGEMENT_3, 13, 0,
+		 NULL, 0),
+SND_SOC_DAPM_PGA("LINEOUT1P Driver", WM8993_POWER_MANAGEMENT_3, 12, 0,
+		 NULL, 0),
 SND_SOC_DAPM_PGA("LINEOUT2N Driver", WM8993_POWER_MANAGEMENT_3, 11, 0,
 		 NULL, 0),
 SND_SOC_DAPM_PGA("LINEOUT2P Driver", WM8993_POWER_MANAGEMENT_3, 10, 0,
diff --git a/sound/soc/soc-cache.c b/sound/soc/soc-cache.c
index d6af67fb39f7..039b9532b270 100644
--- a/sound/soc/soc-cache.c
+++ b/sound/soc/soc-cache.c
@@ -165,7 +165,6 @@ static unsigned int do_i2c_read(struct snd_soc_codec *codec,
 	xfer[0].flags = 0;
 	xfer[0].len = reglen;
 	xfer[0].buf = reg;
-	xfer[0].scl_rate = 100 * 1000;
 
 	/* Read data */
 	xfer[1].addr = client->addr;
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bebc1bee6087..e2bfe1d69e74 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1032,21 +1032,6 @@ static struct snd_pcm_ops soc_pcm_ops = {
 	.pointer	= soc_pcm_pointer,
 };
 
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
-int snd_soc_incall_status(int read_or_write, int status)
-{
-	static int now_status = 0;
-	if(read_or_write == 1)
-	{//write
-		now_status = status;
-	}
-
-	return now_status;
-}
-EXPORT_SYMBOL_GPL(snd_soc_incall_status);
-#endif
-
-
 #ifdef CONFIG_PM_SLEEP
 /* powers down audio subsystem for suspend */
 int snd_soc_suspend(struct device *dev)
@@ -1054,14 +1039,7 @@ int snd_soc_suspend(struct device *dev)
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	struct snd_soc_codec *codec;
 	int i;
-	
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
-	if(snd_soc_incall_status(0,0))
-	{
-		printk("card is incall cannot into suspend\n");
-		return 0;
-	}
-#endif	
+
 	/* If the initialization of this soc device failed, there is no codec
 	 * associated with it. Just bail out in this case.
 	 */
@@ -1211,7 +1189,6 @@ static void soc_resume_deferred(struct work_struct *work)
 		 * left with bias OFF or STANDBY and suspended so we must now
 		 * resume.  Otherwise the suspend was suppressed.
 		 */
-
 		if (codec->driver->resume && codec->suspended) {
 			switch (codec->dapm.bias_level) {
 			case SND_SOC_BIAS_STANDBY:
@@ -1282,14 +1259,7 @@ int snd_soc_resume(struct device *dev)
 {
 	struct snd_soc_card *card = dev_get_drvdata(dev);
 	int i, ac97_control = 0;
-	
-#ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
-	if(snd_soc_incall_status(0,0))
-	{
-		printk("card is incall cannot into suspend\n");
-		return 0;
-	}
-#endif
+
 	/* AC97 devices might have other drivers hanging off them so
 	 * need to resume immediately.  Other drivers don't have that
 	 * problem and may take a substantial amount of time to resume
@@ -1318,7 +1288,7 @@ EXPORT_SYMBOL_GPL(snd_soc_resume);
 
 static struct snd_soc_dai_ops null_dai_ops = {
 };
-#define CODEC_NAME_CMP
+
 static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 {
 	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
@@ -1327,14 +1297,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 	struct snd_soc_platform *platform;
 	struct snd_soc_dai *codec_dai, *cpu_dai;
 	const char *platform_name;
-#ifdef CODEC_NAME_CMP
-	char *p_codec_name;
-	char *p_dai_codec_name;
-	char tmp_codec_name[50];
-	char tmp_dai_codec_name[50];
-	p_codec_name = tmp_codec_name;
-	p_dai_codec_name = tmp_dai_codec_name;
-#endif	
+
 	if (rtd->complete)
 		return 1;
 	dev_dbg(card->dev, "binding %s at idx %d\n", dai_link->name, num);
@@ -1361,15 +1324,7 @@ static int soc_bind_dai_link(struct snd_soc_card *card, int num)
 
 	/* no, then find CODEC from registered CODECs*/
 	list_for_each_entry(codec, &codec_list, list) {
-#ifdef CODEC_NAME_CMP
-		strcpy(p_codec_name,codec->name);
-		strcpy(p_dai_codec_name,dai_link->codec_name);		
-#endif		
-		if (!strcmp(codec->name, dai_link->codec_name) 
-#ifdef CODEC_NAME_CMP			
-		||	!strcmp(strsep(&p_codec_name,"."), strsep(&p_dai_codec_name,"."))
-#endif
-			) {
+		if (!strcmp(codec->name, dai_link->codec_name)) {
 			rtd->codec = codec;
 
 			/* CODEC found, so find CODEC DAI from registered DAIs from this CODEC*/
@@ -3174,7 +3129,7 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r_sx);
 int snd_soc_put_volsw_2r_sx(struct snd_kcontrol *kcontrol,
 			struct snd_ctl_elem_value *ucontrol)
 {
-	/*struct soc_mixer_control *mc =
+	struct soc_mixer_control *mc =
 		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	unsigned int mask = (1<<mc->shift)-1;
@@ -3202,31 +3157,6 @@ int snd_soc_put_volsw_2r_sx(struct snd_kcontrol *kcontrol,
 			return ret;
 	}
 
-	return 0;*/		//sxj modify, this function have bug
-
-	struct soc_mixer_control *mc =
-         (struct soc_mixer_control *)kcontrol->private_value;
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int mask = (1<<mc->shift)-1;
-	int min = mc->min;
-	int ret;
-	unsigned int val, valr, oval, ovalr;
-
-	val = ((ucontrol->value.integer.value[0]+min) & 0xff);
-	val &= mask;
-	valr = ((ucontrol->value.integer.value[1]+min) & 0xff);
-	valr &= mask;
-
-	ret = 0;
-	ret = snd_soc_update_bits_locked(codec, mc->reg, mask, val);
-	if(ret < 0)
-		return ret;
-
-	ret = snd_soc_update_bits_locked(codec, mc->rreg, mask, valr);
-
-	if(ret < 0)
-		return ret;
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r_sx);
-- 
2.35.3

