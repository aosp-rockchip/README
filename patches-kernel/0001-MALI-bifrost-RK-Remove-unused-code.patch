From 24ba51b3b8b0e90ab525d4354199259c98bd9471 Mon Sep 17 00:00:00 2001
From: Finley Xiao <finley.xiao@rock-chips.com>
Date: Tue, 26 Jun 2018 18:00:59 +0800
Subject: [PATCH] MALI: bifrost: RK: Remove unused code

Change-Id: I992a0a37ee369bdc2d62d25417ea771c554034ec
Signed-off-by: Finley Xiao <finley.xiao@rock-chips.com>
---
 .../platform/rk/mali_kbase_config_rk.c        | 269 ------------------
 1 file changed, 269 deletions(-)

diff --git a/drivers/gpu/arm/bifrost_for_linux/platform/rk/mali_kbase_config_rk.c b/drivers/gpu/arm/bifrost_for_linux/platform/rk/mali_kbase_config_rk.c
index 324cf75df6a2..b10b8a9ade35 100755
--- a/drivers/gpu/arm/bifrost_for_linux/platform/rk/mali_kbase_config_rk.c
+++ b/drivers/gpu/arm/bifrost_for_linux/platform/rk/mali_kbase_config_rk.c
@@ -451,272 +451,3 @@ static void kbase_platform_rk_remove_sysfs_files(struct device *dev)
 	device_remove_file(dev, &dev_attr_utilisation);
 }
 
-static int rockchip_get_efuse_value(struct device_node *np, char *porp_name,
-				    int *value)
-{
-	struct nvmem_cell *cell;
-	unsigned char *buf;
-	size_t len;
-
-	cell = of_nvmem_cell_get(np, porp_name);
-	if (IS_ERR(cell))
-		return PTR_ERR(cell);
-
-	buf = (unsigned char *)nvmem_cell_read(cell, &len);
-
-	nvmem_cell_put(cell);
-
-	if (IS_ERR(buf))
-		return PTR_ERR(buf);
-
-	if (buf[0] == LEAKAGE_INVALID)
-		return -EINVAL;
-
-	*value = buf[0];
-
-	kfree(buf);
-
-	return 0;
-}
-
-static int rockchip_get_volt_sel_table(struct device_node *np, char *porp_name,
-				       struct volt_sel_table **table)
-{
-	struct volt_sel_table *sel_table;
-	const struct property *prop;
-	int count, i;
-
-	prop = of_find_property(np, porp_name, NULL);
-	if (!prop)
-		return -EINVAL;
-
-	if (!prop->value)
-		return -ENODATA;
-
-	count = of_property_count_u32_elems(np, porp_name);
-	if (count < 0)
-		return -EINVAL;
-
-	if (count % 3)
-		return -EINVAL;
-
-	sel_table = kzalloc(sizeof(*sel_table) * (count / 3 + 1), GFP_KERNEL);
-	if (!sel_table)
-		return -ENOMEM;
-
-	for (i = 0; i < count / 3; i++) {
-		of_property_read_u32_index(np, porp_name, 3 * i,
-					   &sel_table[i].min);
-		of_property_read_u32_index(np, porp_name, 3 * i + 1,
-					   &sel_table[i].max);
-		of_property_read_u32_index(np, porp_name, 3 * i + 2,
-					   &sel_table[i].sel);
-	}
-	sel_table[i].min = 0;
-	sel_table[i].max = 0;
-	sel_table[i].sel = LEAKAGE_TABLE_END;
-
-	*table = sel_table;
-
-	return 0;
-}
-
-static int rockchip_get_volt_sel(struct device_node *np, char *name,
-				 int value, int *sel)
-{
-	struct volt_sel_table *table;
-	int i, j = -1, ret;
-
-	ret = rockchip_get_volt_sel_table(np, name, &table);
-	if (ret)
-		return -EINVAL;
-
-	for (i = 0; table[i].sel != LEAKAGE_TABLE_END; i++) {
-		if (value >= table[i].min)
-			j = i;
-	}
-	if (j != -1)
-		*sel = table[j].sel;
-	else
-		ret = -EINVAL;
-
-	kfree(table);
-
-	return ret;
-}
-
-static int rockchip_parse_pvtm_config(struct device_node *np,
-				      struct pvtm_config *pvtm)
-{
-	if (!of_find_property(np, "rockchip,pvtm-voltage-sel", NULL))
-		return -EINVAL;
-	if (of_property_read_u32(np, "rockchip,pvtm-freq", &pvtm->freq))
-		return -EINVAL;
-	if (of_property_read_u32(np, "rockchip,pvtm-volt", &pvtm->volt))
-		return -EINVAL;
-	if (of_property_read_u32_array(np, "rockchip,pvtm-ch", pvtm->ch, 2))
-		return -EINVAL;
-	if (of_property_read_u32(np, "rockchip,pvtm-sample-time",
-				 &pvtm->sample_time))
-		return -EINVAL;
-	if (of_property_read_u32(np, "rockchip,pvtm-number", &pvtm->num))
-		return -EINVAL;
-	if (of_property_read_u32(np, "rockchip,pvtm-error", &pvtm->err))
-		return -EINVAL;
-	if (of_property_read_u32(np, "rockchip,pvtm-ref-temp", &pvtm->ref_temp))
-		return -EINVAL;
-	if (of_property_read_u32_array(np, "rockchip,pvtm-temp-prop",
-				       pvtm->temp_prop, 2))
-		return -EINVAL;
-	if (of_property_read_string(np, "rockchip,pvtm-thermal-zone",
-				    &pvtm->tz_name))
-		return -EINVAL;
-	pvtm->tz = thermal_zone_get_zone_by_name(pvtm->tz_name);
-	if (IS_ERR(pvtm->tz))
-		return -EINVAL;
-	if (!pvtm->tz->ops->get_temp)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int rockchip_get_pvtm_specific_value(struct device *dev,
-					    struct device_node *np,
-					    struct clk *clk,
-					    struct regulator *reg,
-					    int *target_value)
-{
-	struct pvtm_config *pvtm;
-	unsigned long old_freq;
-	unsigned int old_volt;
-	int cur_temp, diff_temp;
-	int cur_value, total_value, avg_value, diff_value;
-	int min_value, max_value;
-	int ret = 0, i = 0, retry = 2;
-
-	pvtm = kzalloc(sizeof(*pvtm), GFP_KERNEL);
-	if (!pvtm)
-		return -ENOMEM;
-
-	ret = rockchip_parse_pvtm_config(np, pvtm);
-	if (ret)
-		goto pvtm_value_out;
-
-	old_freq = clk_get_rate(clk);
-	old_volt = regulator_get_voltage(reg);
-
-	/*
-	 * Set pvtm_freq to the lowest frequency in dts,
-	 * so change frequency first.
-	 */
-	ret = clk_set_rate(clk, pvtm->freq * 1000);
-	if (ret) {
-		dev_err(dev, "Failed to set pvtm freq\n");
-		goto pvtm_value_out;
-	}
-
-	ret = regulator_set_voltage(reg, pvtm->volt, pvtm->volt);
-	if (ret) {
-		dev_err(dev, "Failed to set pvtm_volt\n");
-		goto restore_clk;
-	}
-
-	/* The first few values may be fluctuant, if error is too big, retry*/
-	while (retry--) {
-		total_value = 0;
-		min_value = INT_MAX;
-		max_value = 0;
-
-		for (i = 0; i < pvtm->num; i++) {
-			cur_value = rockchip_get_pvtm_value(pvtm->ch[0],
-							    pvtm->ch[1],
-							    pvtm->sample_time);
-			if (!cur_value)
-				goto resetore_volt;
-			if (cur_value < min_value)
-				min_value = cur_value;
-			if (cur_value > max_value)
-				max_value = cur_value;
-			total_value += cur_value;
-		}
-		if (max_value - min_value < pvtm->err)
-			break;
-	}
-	avg_value = total_value / pvtm->num;
-
-	/*
-	 * As pvtm is influenced by temperature, compute difference between
-	 * current temperature and reference temperature
-	 */
-	pvtm->tz->ops->get_temp(pvtm->tz, &cur_temp);
-	diff_temp = (cur_temp / 1000 - pvtm->ref_temp);
-	diff_value = diff_temp *
-		(diff_temp < 0 ? pvtm->temp_prop[0] : pvtm->temp_prop[1]);
-	*target_value = avg_value + diff_value;
-
-	dev_info(dev, "temp=%d, pvtm=%d (%d + %d)\n",
-		 cur_temp, *target_value, avg_value, diff_value);
-
-resetore_volt:
-	regulator_set_voltage(reg, old_volt, old_volt);
-restore_clk:
-	clk_set_rate(clk, old_freq);
-pvtm_value_out:
-	kfree(pvtm);
-
-	return ret;
-}
-
-void kbase_platform_rk_set_opp_info(struct kbase_device *kbdev)
-{
-	struct device_node *np;
-	char name[MAX_PROP_NAME_LEN];
-	int pvmt_value, leakage;
-	int lkg_volt_sel, pvtm_volt_sel, volt_sel = -1;
-	int err = 0;
-
-	if (!kbdev)
-		return;
-
-	if (IS_ERR_OR_NULL(kbdev->regulator))
-		return;
-	if (IS_ERR_OR_NULL(kbdev->clock))
-		return;
-
-	np = of_parse_phandle(kbdev->dev->of_node, "operating-points-v2", 0);
-	if (!np) {
-		dev_warn(kbdev->dev, "OPP-v2 not supported\n");
-		return;
-	}
-
-	err = rockchip_get_efuse_value(np, "gpu_leakage", &leakage);
-	if (!err) {
-		dev_info(kbdev->dev, "leakage=%d\n", leakage);
-		err = rockchip_get_volt_sel(np, "rockchip,leakage-voltage-sel",
-					    leakage, &lkg_volt_sel);
-		if (!err) {
-			dev_info(kbdev->dev, "leakage-sel=%d\n", lkg_volt_sel);
-			volt_sel = lkg_volt_sel;
-		}
-	}
-
-	err = rockchip_get_pvtm_specific_value(kbdev->dev, np, kbdev->clock,
-					       kbdev->regulator,
-					       &pvmt_value);
-	if (!err) {
-		err = rockchip_get_volt_sel(np, "rockchip,pvtm-voltage-sel",
-					    pvmt_value, &pvtm_volt_sel);
-		if (!err) {
-			dev_info(kbdev->dev, "pvtm-sel=%d\n", pvtm_volt_sel);
-			if (volt_sel < 0 || volt_sel > pvtm_volt_sel)
-				volt_sel = pvtm_volt_sel;
-		}
-	}
-
-	if (volt_sel >= 0) {
-		snprintf(name, MAX_PROP_NAME_LEN, "L%d", volt_sel);
-		err = dev_pm_opp_set_prop_name(kbdev->dev, name);
-		if (err)
-			dev_err(kbdev->dev, "Failed to set prop name\n");
-	}
-}
-- 
2.35.3

