From e595dd26f174ca5fc049d09b6a671258b9130c6d Mon Sep 17 00:00:00 2001
From: chenyifu <chenyf@rock-chips.com>
Date: Fri, 26 Sep 2014 10:30:20 +0800
Subject: [PATCH] rk312x mipi: mipi driver for rk312x-sdk

  1. Remove uboot code from the kernel.
  2. This version just finishes the function of mipi.
     The codingstype will be improved in next version.
---
 drivers/video/rockchip/screen/lcd_mipi.c      |    3 +-
 .../rockchip/transmitter/rk32_mipi_dsi.c      | 1119 +++++++----------
 .../rockchip/transmitter/rk32_mipi_dsi.h      |   15 +-
 3 files changed, 492 insertions(+), 645 deletions(-)

diff --git a/drivers/video/rockchip/screen/lcd_mipi.c b/drivers/video/rockchip/screen/lcd_mipi.c
index 67d9094aa88d..7293efde858b 100755
--- a/drivers/video/rockchip/screen/lcd_mipi.c
+++ b/drivers/video/rockchip/screen/lcd_mipi.c
@@ -182,7 +182,8 @@ int rk_mipi_screen(void)
 	u8 dcs[16] = {0}, rk_dsi_num;
 	rk_dsi_num = gmipi_screen->mipi_dsi_num;
 	if(gmipi_screen->screen_init == 0){
-	
+		rk_mipi_screen_pwr_enable(gmipi_screen);
+		
 		dsi_enable_hs_clk(0,1);
 		if(rk_dsi_num == 2){
 			dsi_enable_hs_clk(1, 1);
diff --git a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
index 392bbf42dc4d..923c648d4413 100755
--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
@@ -24,23 +24,9 @@
 #define CONFIG_MIPI_DSI_LINUX	0
 #endif
 #define DWC_DSI_VERSION			0x3133302A
+#define DWC_DSI_VERSION_RK312x		0x3132312A
+#define DWC_DSI_VERSION_ERR		-1
 
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-#include <asm/io.h>
-#include <errno.h>
-#include <lcd.h>
-#include <div64.h>
-#include <linux/ctype.h>
-#include <linux/math64.h>
-#include "mipi_dsi.h"
-#include "rk32_mipi_dsi.h"
-#include "mipi_dsi.h"
-#include <asm/arch/rkplat.h>
-#include <fdtdec.h>
-#include <linux/fb.h>
-#include <linux/rk_screen.h>
-#include <malloc.h>
-#else
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
@@ -63,15 +49,7 @@
 #include <linux/rockchip/iomap.h>
 #include <linux/rockchip/cpu.h>
 
-#endif
-#ifdef CONFIG_RK32_MIPI_DSI
 #define	MIPI_DBG(x...)	//printk(KERN_INFO x)
-#elif defined CONFIG_RK_3288_DSI_UBOOT
-#define	MIPI_DBG(x...)	//printf( x)
-#define	printk(x...)	//printf( x)
-#else
-#define	MIPI_DBG(x...)  
-#endif
 
 #ifdef CONFIG_MIPI_DSI_LINUX
 #define	MIPI_TRACE(x...)	//printk(KERN_INFO x)
@@ -103,57 +81,15 @@ static int rk32_mipi_dsi_enable_hs_clk(void *arg, u32 enable);
 static int rk32_mipi_dsi_enable_video_mode(void *arg, u32 enable);
 static int rk32_mipi_dsi_enable_command_mode(void *arg, u32 enable);
 static int rk32_mipi_dsi_is_enable(void *arg, u32 enable);
-//static int rk32_mipi_power_down_DDR(void);
-//static int rk32_mipi_power_up_DDR(void);
+static int rk32_mipi_power_down_DDR(void);
+static int rk32_mipi_power_up_DDR(void);
 int rk_mipi_screen_standby(u8 enable);
 
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-DECLARE_GLOBAL_DATA_PTR;
-extern int rk_mipi_screen_probe(void);
-extern void writel_relaxed(uint32 val, uint32 addr);
-#define msleep(a) udelay(a * 1000)
-/* 
-dsihost0:
-clocks = <&clk_gates5 15>, <&clk_gates16 4>;
-clock-names = "clk_mipi_24m", "pclk_mipi_dsi";
-
-dsihost1:
-clocks = <&clk_gates5 15>, <&clk_gates16 5>;
-clock-names = "clk_mipi_24m", "pclk_mipi_dsi";
-
-*/
-int rk32_mipi_dsi_clk_enable(struct dsi *dsi)
-{
-	u32 val;
-	val = 0x80000000;//bit31~bit16 
-	writel(val, RK3288_CRU_PHYS + 0x174); /*24M*/
-	if(dsi->dsi_id == 0)
-		val = (1 << 20);
-	else
-		val = (1 << 21);
-	writel(val, RK3288_CRU_PHYS + 0x1a0); /*pclk*/
-	return 0;
-}
-int rk32_mipi_dsi_clk_disable(struct dsi *dsi)
-{
-	u32 val;
-	if(dsi->dsi_id == 0)
-		val = (1 << 20)|(1 << 4);
-	else
-		val = (1 << 21)|(1 << 5);
-	writel(val, RK3288_CRU_PHYS + 0x1a0); /*pclk*/
-	
-	val = 0x80008000;//bit31~bit16 
-	writel(val, RK3288_CRU_PHYS + 0x174); /*24M*/
-	return 0;
-}
-
-#endif
 static int rk32_dsi_read_reg(struct dsi *dsi, u16 reg, u32 *pval)
 {
-	if(cpu_is_rk3288())
+	if (dsi->ops.id == DWC_DSI_VERSION)
 		*pval = __raw_readl(dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
-	else if(cpu_is_rk312x()){
+	else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
 		if(reg >= MIPI_DSI_HOST_OFFSET)
 			*pval = __raw_readl(dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
 		else if(reg >= MIPI_DSI_PHY_OFFSET)
@@ -164,9 +100,9 @@ static int rk32_dsi_read_reg(struct dsi *dsi, u16 reg, u32 *pval)
 
 static int rk32_dsi_write_reg(struct dsi *dsi, u16 reg, u32 *pval)
 {
-	if(cpu_is_rk3288())
+	if (dsi->ops.id == DWC_DSI_VERSION)
 		__raw_writel(*pval, dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
-	else if(cpu_is_rk312x()){
+	else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
 		if(reg >= MIPI_DSI_HOST_OFFSET)
 			__raw_writel(*pval, dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
 		else if(reg >= MIPI_DSI_PHY_OFFSET)
@@ -259,13 +195,9 @@ static int rk32_dwc_phy_test_wr(struct dsi *dsi, unsigned char test_code, unsign
 static int rk32_phy_power_up(struct dsi *dsi)
 {
     //enable ref clock
-    #ifdef CONFIG_RK_3288_DSI_UBOOT
-    rk32_mipi_dsi_clk_enable(dsi);
-    #else
     clk_prepare_enable(dsi->phy.refclk); 
     clk_prepare_enable(dsi->dsi_pclk);
     clk_prepare_enable(dsi->dsi_pd);
-    #endif
     udelay(10);
 
 	switch(dsi->host.lane) {
@@ -291,6 +223,210 @@ static int rk32_phy_power_up(struct dsi *dsi)
 	
 	return 0;
 }
+
+static int rk312x_mipi_dsi_phy_set_gotp(struct dsi *dsi, u32 offset, int n) 
+{
+	u32 val = 0, temp = 0, Tlpx = 0;
+	u32 ddr_clk = dsi->phy.ddr_clk;
+	u32 Ttxbyte_clk = dsi->phy.Ttxbyte_clk;
+	u32 Tsys_clk = dsi->phy.Tsys_clk;
+	u32 Ttxclkesc = dsi->phy.Ttxclkesc;
+	printk("%s : ddr_clk %d\n",__func__, ddr_clk);
+	switch(offset) {
+		case DPHY_CLOCK_OFFSET:
+			MIPI_DBG("******set DPHY_CLOCK_OFFSET gotp******\n");
+			break;
+		case DPHY_LANE0_OFFSET:
+			MIPI_DBG("******set DPHY_LANE0_OFFSET gotp******\n");
+			break;
+		case DPHY_LANE1_OFFSET:
+			MIPI_DBG("******set DPHY_LANE1_OFFSET gotp******\n");
+			break;
+		case DPHY_LANE2_OFFSET:
+			MIPI_DBG("******set DPHY_LANE2_OFFSET gotp******\n");
+			break;
+		case DPHY_LANE3_OFFSET:
+			MIPI_DBG("******set DPHY_LANE3_OFFSET gotp******\n");
+			break;
+		default:
+			break;					
+	}
+	
+	if(ddr_clk < 110 * MHz)
+		val = 0;
+	else if(ddr_clk < 150 * MHz)
+		val = 1;
+	else if(ddr_clk < 200 * MHz)
+		val = 2;
+	else if(ddr_clk < 250 * MHz)
+		val = 3;
+	else if(ddr_clk < 300 * MHz)
+		val = 4;
+	else if(ddr_clk < 400 * MHz)
+		val = 5;		
+	else if(ddr_clk < 500 * MHz)
+		val = 6;		
+	else if(ddr_clk < 600 * MHz)
+		val = 7;		
+	else if(ddr_clk < 700 * MHz)
+		val = 8;
+	else if(ddr_clk < 800 * MHz)
+		val = 9;		
+	else if(ddr_clk <= 1000 * MHz)
+		val = 10;
+	printk("%s reg_ths_settle = 0x%x\n",__func__, val);
+	rk32_dsi_set_bits(dsi, val, reg_ths_settle + offset);
+	
+	if(ddr_clk < 110 * MHz)
+		val = 0x20;
+	else if(ddr_clk < 150 * MHz)
+		val = 0x06;
+	else if(ddr_clk < 200 * MHz)
+		val = 0x18;
+	else if(ddr_clk < 250 * MHz)
+		val = 0x05;
+	else if(ddr_clk < 300 * MHz)
+		val = 0x51;
+	else if(ddr_clk < 400 * MHz)
+		val = 0x64;		
+	else if(ddr_clk < 500 * MHz)
+		val = 0x59;		
+	else if(ddr_clk < 600 * MHz)
+		val = 0x6a;		
+	else if(ddr_clk < 700 * MHz)
+		val = 0x3e;
+	else if(ddr_clk < 800 * MHz)
+		val = 0x21;
+	else if(ddr_clk <= 1000 * MHz)
+		val = 0x09;
+	printk("%s reg_hs_ths_prepare = 0x%x\n",__func__, val);
+	rk32_dsi_set_bits(dsi, val, reg_hs_ths_prepare + offset);
+
+	if(offset != DPHY_CLOCK_OFFSET) {
+	
+		if(ddr_clk < 110 * MHz)
+			val = 2;
+		else if(ddr_clk < 150 * MHz)
+			val = 3;
+		else if(ddr_clk < 200 * MHz)
+			val = 4;
+		else if(ddr_clk < 250 * MHz)
+			val = 5;
+		else if(ddr_clk < 300 * MHz)
+			val = 6;
+		else if(ddr_clk < 400 * MHz)
+			val = 7;		
+		else if(ddr_clk < 500 * MHz)
+			val = 7;		
+		else if(ddr_clk < 600 * MHz)
+			val = 8;		
+		else if(ddr_clk < 700 * MHz)
+			val = 8;
+		else if(ddr_clk < 800 * MHz)
+			val = 9;		
+		else if(ddr_clk <= 1000 * MHz)
+			val = 9;	
+	} else {
+	
+		if(ddr_clk < 110 * MHz)
+			val = 0x16;
+		else if(ddr_clk < 150 * MHz)
+			val = 0x16;
+		else if(ddr_clk < 200 * MHz)
+			val = 0x17;
+		else if(ddr_clk < 250 * MHz)
+			val = 0x17;
+		else if(ddr_clk < 300 * MHz)
+			val = 0x18;
+		else if(ddr_clk < 400 * MHz)
+			val = 0x19;		
+		else if(ddr_clk < 500 * MHz)
+			val = 0x1b;		
+		else if(ddr_clk < 600 * MHz)
+			val = 0x1d;		
+		else if(ddr_clk < 700 * MHz)
+			val = 0x1e;
+		else if(ddr_clk < 800 * MHz)
+			val = 0x1f;		
+		else if(ddr_clk <= 1000 * MHz)
+			val = 0x20;	
+	}	
+	printk("%s reg_hs_the_zero = 0x%x\n",__func__, val);
+	rk32_dsi_set_bits(dsi, val, reg_hs_the_zero + offset);
+	
+	if(ddr_clk < 110 * MHz)
+		val = 0x22;
+	else if(ddr_clk < 150 * MHz)
+		val = 0x45;
+	else if(ddr_clk < 200 * MHz)
+		val = 0x0b;
+	else if(ddr_clk < 250 * MHz)
+		val = 0x16;
+	else if(ddr_clk < 300 * MHz)
+		val = 0x2c;
+	else if(ddr_clk < 400 * MHz)
+		val = 0x33;		
+	else if(ddr_clk < 500 * MHz)
+		val = 0x4e;		
+	else if(ddr_clk < 600 * MHz)
+		val = 0x3a;		
+	else if(ddr_clk < 700 * MHz)
+		val = 0x6a;
+	else if(ddr_clk < 800 * MHz)
+		val = 0x29;		
+	else if(ddr_clk <= 1000 * MHz)
+		val = 0x21;   //0x27
+		
+	printk("%s reg_hs_ths_trail = 0x%x\n",__func__, val);
+
+	rk32_dsi_set_bits(dsi, val, reg_hs_ths_trail + offset);
+	val = 120000 / Ttxbyte_clk + 1;
+	MIPI_DBG("reg_hs_ths_exit: %d, %d\n", val, val*Ttxbyte_clk/1000);
+	rk32_dsi_set_bits(dsi, val, reg_hs_ths_exit + offset);
+	
+	if(offset == DPHY_CLOCK_OFFSET) {
+		val = (60000 + 52*dsi->phy.UI) / Ttxbyte_clk + 1;
+		MIPI_DBG("reg_hs_tclk_post: %d, %d\n", val, val*Ttxbyte_clk/1000);
+		rk32_dsi_set_bits(dsi, val, reg_hs_tclk_post + offset);
+		val = 10*dsi->phy.UI / Ttxbyte_clk + 1;
+		MIPI_DBG("reg_hs_tclk_pre: %d, %d\n", val, val*Ttxbyte_clk/1000);	
+		rk32_dsi_set_bits(dsi, val, reg_hs_tclk_pre + offset);
+	}
+
+	val = 1010000000 / Tsys_clk + 1;
+	MIPI_DBG("reg_hs_twakup: %d, %d\n", val, val*Tsys_clk/1000);
+	if(val > 0x3ff) {
+		val = 0x2ff;
+		MIPI_DBG("val is too large, 0x3ff is the largest\n");	
+	}
+	temp = (val >> 8) & 0x03;
+	val &= 0xff;	
+	rk32_dsi_set_bits(dsi, temp, reg_hs_twakup_h + offset);	
+	rk32_dsi_set_bits(dsi, val, reg_hs_twakup_l + offset);
+	
+	if(Ttxclkesc > 50000) {
+		val = 2*Ttxclkesc;
+		MIPI_DBG("Ttxclkesc:%d\n", Ttxclkesc);
+	}
+	val = val / Ttxbyte_clk;
+	Tlpx = val*Ttxbyte_clk;
+	MIPI_DBG("reg_hs_tlpx: %d, %d\n", val, Tlpx);
+	val -= 2;
+	rk32_dsi_set_bits(dsi, val, reg_hs_tlpx + offset);
+	
+	Tlpx = 2*Ttxclkesc;
+	val = 4*Tlpx / Ttxclkesc;
+	MIPI_DBG("reg_hs_tta_go: %d, %d\n", val, val*Ttxclkesc);
+	rk32_dsi_set_bits(dsi, val, reg_hs_tta_go + offset);
+	val = 3 * Tlpx / 2 / Ttxclkesc;
+	MIPI_DBG("reg_hs_tta_sure: %d, %d\n", val, val*Ttxclkesc);	
+	rk32_dsi_set_bits(dsi, val, reg_hs_tta_sure + offset);
+	val = 5 * Tlpx / Ttxclkesc;
+	MIPI_DBG("reg_hs_tta_wait: %d, %d\n", val, val*Ttxclkesc);
+	rk32_dsi_set_bits(dsi, val, reg_hs_tta_wait + offset);
+	return 0;
+}
+
 static void rk312x_mipi_dsi_set_hs_clk(struct dsi *dsi) 
 {
 	rk32_dsi_set_bits(dsi, dsi->phy.prediv, reg_prediv);
@@ -301,14 +437,12 @@ static void rk312x_mipi_dsi_set_hs_clk(struct dsi *dsi)
 static int rk312x_phy_power_up(struct dsi *dsi)
 {
 	//enable ref clock
-	#ifdef CONFIG_RK_3288_DSI_UBOOT
-	rk32_mipi_dsi_clk_enable(dsi);
-	#else
 	rk312x_mipi_dsi_set_hs_clk(dsi);
 	clk_prepare_enable(dsi->phy.refclk); 
 	clk_prepare_enable(dsi->dsi_pclk);
-	//clk_prepare_enable(dsi->dsi_pd);
-	#endif
+	clk_prepare_enable(dsi->dsi_host_pclk);
+	clk_prepare_enable(dsi->h2p_hclk);
+	clk_prepare_enable(dsi->dsi_pd);
 	udelay(10);
     
 	rk32_dsi_set_bits(dsi, 0xe4, DPHY_REGISTER1);
@@ -340,9 +474,9 @@ static int rk312x_phy_power_up(struct dsi *dsi)
 
 static int rk_phy_power_up(struct dsi *dsi) 
 {
-	if(cpu_is_rk3288())
+	if (dsi->ops.id == DWC_DSI_VERSION)
 		rk32_phy_power_up(dsi);
-	else if(cpu_is_rk312x())
+	else if (dsi->ops.id == DWC_DSI_VERSION_RK312x)
 		rk312x_phy_power_up(dsi);
 	return 0;
 }
@@ -350,37 +484,30 @@ static int rk_phy_power_up(struct dsi *dsi)
 static int rk32_phy_power_down(struct dsi *dsi)
 {
     rk32_dsi_set_bits(dsi, 0, phy_shutdownz);
-    #ifdef CONFIG_RK_3288_DSI_UBOOT
-    rk32_mipi_dsi_clk_disable(dsi);
-    #else
     clk_disable_unprepare(dsi->phy.refclk); 
     clk_disable_unprepare(dsi->dsi_pclk);
     clk_disable_unprepare(dsi->dsi_pd);
-    #endif
     return 0;
 }
 
 static int rk312x_phy_power_down(struct dsi *dsi)
 {
-    #ifdef CONFIG_RK_3288_DSI_UBOOT
-    rk32_mipi_dsi_clk_disable(dsi);
-    #else
-    
     rk32_dsi_set_bits(dsi, 0x01, DPHY_REGISTER0);
     rk32_dsi_set_bits(dsi, 0xe3, DPHY_REGISTER1);
     
     clk_disable_unprepare(dsi->phy.refclk); 
     clk_disable_unprepare(dsi->dsi_pclk);
-   // clk_disable_unprepare(dsi->dsi_pd);
-    #endif
+	clk_disable_unprepare(dsi->dsi_host_pclk);
+	clk_disable_unprepare(dsi->h2p_hclk);
+    clk_disable_unprepare(dsi->dsi_pd);
     return 0;
 }
 
 static int rk_phy_power_down(struct dsi *dsi) 
 {
-	if(cpu_is_rk3288())
+	if (dsi->ops.id == DWC_DSI_VERSION)
 		rk32_phy_power_down(dsi);
-	else if(cpu_is_rk312x())
+	else if (dsi->ops.id == DWC_DSI_VERSION_RK312x)
 		rk312x_phy_power_down(dsi);
 	return 0;
 }
@@ -453,290 +580,93 @@ static int rk32_phy_init(struct dsi *dsi)
 	else if(ddr_clk < 360 * MHz)
 		val = 0x15; 
 	else if(ddr_clk < 400 * MHz)
-		val = 0x25;
-	else if(ddr_clk < 450 * MHz)
-		val = 0x06; 
-	else if(ddr_clk < 500 * MHz)
-		val = 0x16;
-	else if(ddr_clk < 550 * MHz)
-		val = 0x07;
-	else if(ddr_clk < 600 * MHz)
-		val = 0x17;
-	else if(ddr_clk < 650 * MHz)
-		val = 0x08;
-	else if(ddr_clk < 700 * MHz)
-		val = 0x18;
-	else if(ddr_clk < 750 * MHz)
-		val = 0x09;
-	else if(ddr_clk < 800 * MHz)
-		val = 0x19;
-	else if(ddr_clk < 850 * MHz)
-		val = 0x29;
-	else if(ddr_clk < 900 * MHz)
-		val = 0x39;
-	else if(ddr_clk < 950 * MHz)
-		val = 0x0a;
-	else if(ddr_clk < 1000 * MHz)
-		val = 0x1a;
-	else if(ddr_clk < 1050 * MHz)
-		val = 0x2a;
-	else if(ddr_clk < 1100* MHz)
-		val = 0x3a;
-	else if(ddr_clk < 1150* MHz)
-		val = 0x0b;
-	else if(ddr_clk < 1200 * MHz)
-		val = 0x1b;
-	else if(ddr_clk < 1250 * MHz)
-		val = 0x2b;
-	else if(ddr_clk < 1300 * MHz)
-		val = 0x3b;
-	else if(ddr_clk < 1350 * MHz)
-		val = 0x0c;
-	else if(ddr_clk < 1400* MHz)
-		val = 0x1c;
-	else if(ddr_clk < 1450* MHz)
-		val = 0x2c;
-	else if(ddr_clk <= 1500* MHz)
-		val = 0x3c;
-
-	test_data[0] = val << 1;
-	rk32_dwc_phy_test_wr(dsi, code_hs_rx_lane0, test_data, 1);
-
-	test_data[0] = prediv- 1;
-	rk32_dwc_phy_test_wr(dsi, code_pll_input_div_rat, test_data, 1);
-	mdelay(2);
-	test_data[0] = (fbdiv - 1) & 0x1f; 
-	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
-	mdelay(2);
-	test_data[0] = (fbdiv - 1) >> 5 | 0x80; 
-	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
-	mdelay(2);
-	test_data[0] = 0x30;
-	rk32_dwc_phy_test_wr(dsi, code_pll_input_loop_div_rat, test_data, 1);
-	mdelay(2);
-
-	test_data[0] = 0x4d;
-	rk32_dwc_phy_test_wr(dsi, 0x20, test_data, 1);
-	
-	test_data[0] = 0x3d;
-	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1);
-	
-	test_data[0] = 0xdf;
-	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1); 	
-	
-	test_data[0] =  0x7;
-	rk32_dwc_phy_test_wr(dsi, 0x22, test_data, 1);
-
-	test_data[0] = 0x80 | 0x7;
-	rk32_dwc_phy_test_wr(dsi, 0x22, test_data, 1);
-
-	test_data[0] = 0x80 | 15;
-	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanerequsetstatetime, test_data, 1);
-
-	test_data[0] = 0x80 | 85;
-	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanepreparestatetime, test_data, 1);
-
-	test_data[0] = 0x40 | 10;
-	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanehszerostatetime, test_data, 1);
-
-    return 0;
-}
-static int rk321x_mipi_dsi_phy_set_gotp(struct dsi *dsi, u32 offset, int n) 
-{
-	u32 val = 0, temp = 0, Tlpx = 0;
-	u32 ddr_clk = dsi->phy.ddr_clk;
-	u32 Ttxbyte_clk = dsi->phy.Ttxbyte_clk;
-	u32 Tsys_clk = dsi->phy.Tsys_clk;
-	u32 Ttxclkesc = dsi->phy.Ttxclkesc;
-	
-	switch(offset) {
-		case DPHY_CLOCK_OFFSET:
-			MIPI_DBG("******set DPHY_CLOCK_OFFSET gotp******\n");
-			break;
-		case DPHY_LANE0_OFFSET:
-			MIPI_DBG("******set DPHY_LANE0_OFFSET gotp******\n");
-			break;
-		case DPHY_LANE1_OFFSET:
-			MIPI_DBG("******set DPHY_LANE1_OFFSET gotp******\n");
-			break;
-		case DPHY_LANE2_OFFSET:
-			MIPI_DBG("******set DPHY_LANE2_OFFSET gotp******\n");
-			break;
-		case DPHY_LANE3_OFFSET:
-			MIPI_DBG("******set DPHY_LANE3_OFFSET gotp******\n");
-			break;
-		default:
-			break;					
-	}
-	
-	if(ddr_clk < 110 * MHz)
-		val = 0;
-	else if(ddr_clk < 150 * MHz)
-		val = 1;
-	else if(ddr_clk < 200 * MHz)
-		val = 2;
-	else if(ddr_clk < 250 * MHz)
-		val = 3;
-	else if(ddr_clk < 300 * MHz)
-		val = 4;
-	else if(ddr_clk < 400 * MHz)
-		val = 5;		
-	else if(ddr_clk < 500 * MHz)
-		val = 6;		
-	else if(ddr_clk < 600 * MHz)
-		val = 7;		
-	else if(ddr_clk < 700 * MHz)
-		val = 8;
-	else if(ddr_clk < 800 * MHz)
-		val = 9;		
-	else if(ddr_clk <= 1000 * MHz)
-		val = 10;	
-	rk32_dsi_set_bits(dsi, val, reg_ths_settle + offset);
-	
-	if(ddr_clk < 110 * MHz)
-		val = 0x20;
-	else if(ddr_clk < 150 * MHz)
-		val = 0x06;
-	else if(ddr_clk < 200 * MHz)
-		val = 0x18;
-	else if(ddr_clk < 250 * MHz)
-		val = 0x05;
-	else if(ddr_clk < 300 * MHz)
-		val = 0x51;
-	else if(ddr_clk < 400 * MHz)
-		val = 0x64;		
-	else if(ddr_clk < 500 * MHz)
-		val = 0x59;		
-	else if(ddr_clk < 600 * MHz)
-		val = 0x6a;		
-	else if(ddr_clk < 700 * MHz)
-		val = 0x3e;
-	else if(ddr_clk < 800 * MHz)
-		val = 0x21;
-	else if(ddr_clk <= 1000 * MHz)
-		val = 0x09;
-	rk32_dsi_set_bits(dsi, val, reg_hs_ths_prepare + offset);
-
-	if(offset != DPHY_CLOCK_OFFSET) {
-	
-		if(ddr_clk < 110 * MHz)
-			val = 2;
-		else if(ddr_clk < 150 * MHz)
-			val = 3;
-		else if(ddr_clk < 200 * MHz)
-			val = 4;
-		else if(ddr_clk < 250 * MHz)
-			val = 5;
-		else if(ddr_clk < 300 * MHz)
-			val = 6;
-		else if(ddr_clk < 400 * MHz)
-			val = 7;		
-		else if(ddr_clk < 500 * MHz)
-			val = 7;		
-		else if(ddr_clk < 600 * MHz)
-			val = 8;		
-		else if(ddr_clk < 700 * MHz)
-			val = 8;
-		else if(ddr_clk < 800 * MHz)
-			val = 9;		
-		else if(ddr_clk <= 1000 * MHz)
-			val = 9;	
-	} else {
-	
-		if(ddr_clk < 110 * MHz)
-			val = 0x16;
-		else if(ddr_clk < 150 * MHz)
-			val = 0x16;
-		else if(ddr_clk < 200 * MHz)
-			val = 0x17;
-		else if(ddr_clk < 250 * MHz)
-			val = 0x17;
-		else if(ddr_clk < 300 * MHz)
-			val = 0x18;
-		else if(ddr_clk < 400 * MHz)
-			val = 0x19;		
-		else if(ddr_clk < 500 * MHz)
-			val = 0x1b;		
-		else if(ddr_clk < 600 * MHz)
-			val = 0x1d;		
-		else if(ddr_clk < 700 * MHz)
-			val = 0x1e;
-		else if(ddr_clk < 800 * MHz)
-			val = 0x1f;		
-		else if(ddr_clk <= 1000 * MHz)
-			val = 0x20;	
-	}				
-	rk32_dsi_set_bits(dsi, val, reg_hs_the_zero + offset);
-	
-	if(ddr_clk < 110 * MHz)
-		val = 0x22;
-	else if(ddr_clk < 150 * MHz)
-		val = 0x45;
-	else if(ddr_clk < 200 * MHz)
-		val = 0x0b;
-	else if(ddr_clk < 250 * MHz)
-		val = 0x16;
-	else if(ddr_clk < 300 * MHz)
-		val = 0x2c;
-	else if(ddr_clk < 400 * MHz)
-		val = 0x33;		
+		val = 0x25;
+	else if(ddr_clk < 450 * MHz)
+		val = 0x06; 
 	else if(ddr_clk < 500 * MHz)
-		val = 0x4e;		
+		val = 0x16;
+	else if(ddr_clk < 550 * MHz)
+		val = 0x07;
 	else if(ddr_clk < 600 * MHz)
-		val = 0x3a;		
+		val = 0x17;
+	else if(ddr_clk < 650 * MHz)
+		val = 0x08;
 	else if(ddr_clk < 700 * MHz)
-		val = 0x6a;
+		val = 0x18;
+	else if(ddr_clk < 750 * MHz)
+		val = 0x09;
 	else if(ddr_clk < 800 * MHz)
-		val = 0x29;		
-	else if(ddr_clk <= 1000 * MHz)
-		val = 0x21;   //0x27
+		val = 0x19;
+	else if(ddr_clk < 850 * MHz)
+		val = 0x29;
+	else if(ddr_clk < 900 * MHz)
+		val = 0x39;
+	else if(ddr_clk < 950 * MHz)
+		val = 0x0a;
+	else if(ddr_clk < 1000 * MHz)
+		val = 0x1a;
+	else if(ddr_clk < 1050 * MHz)
+		val = 0x2a;
+	else if(ddr_clk < 1100* MHz)
+		val = 0x3a;
+	else if(ddr_clk < 1150* MHz)
+		val = 0x0b;
+	else if(ddr_clk < 1200 * MHz)
+		val = 0x1b;
+	else if(ddr_clk < 1250 * MHz)
+		val = 0x2b;
+	else if(ddr_clk < 1300 * MHz)
+		val = 0x3b;
+	else if(ddr_clk < 1350 * MHz)
+		val = 0x0c;
+	else if(ddr_clk < 1400* MHz)
+		val = 0x1c;
+	else if(ddr_clk < 1450* MHz)
+		val = 0x2c;
+	else if(ddr_clk <= 1500* MHz)
+		val = 0x3c;
 
-	rk32_dsi_set_bits(dsi, val, reg_hs_ths_trail + offset);
-	val = 120000 / Ttxbyte_clk + 1;
-	MIPI_DBG("reg_hs_ths_exit: %d, %d\n", val, val*Ttxbyte_clk/1000);
-	rk32_dsi_set_bits(dsi, val, reg_hs_ths_exit + offset);
-	
-	if(offset == DPHY_CLOCK_OFFSET) {
-		val = (60000 + 52*dsi->phy.UI) / Ttxbyte_clk + 1;
-		MIPI_DBG("reg_hs_tclk_post: %d, %d\n", val, val*Ttxbyte_clk/1000);
-		rk32_dsi_set_bits(dsi, val, reg_hs_tclk_post + offset);
-		val = 10*dsi->phy.UI / Ttxbyte_clk + 1;
-		MIPI_DBG("reg_hs_tclk_pre: %d, %d\n", val, val*Ttxbyte_clk/1000);	
-		rk32_dsi_set_bits(dsi, val, reg_hs_tclk_pre + offset);
-	}
+	test_data[0] = val << 1;
+	rk32_dwc_phy_test_wr(dsi, code_hs_rx_lane0, test_data, 1);
 
-	val = 1010000000 / Tsys_clk + 1;
-	MIPI_DBG("reg_hs_twakup: %d, %d\n", val, val*Tsys_clk/1000);
-	if(val > 0x3ff) {
-		val = 0x2ff;
-		MIPI_DBG("val is too large, 0x3ff is the largest\n");	
-	}
-	temp = (val >> 8) & 0x03;
-	val &= 0xff;	
-	rk32_dsi_set_bits(dsi, temp, reg_hs_twakup_h + offset);	
-	rk32_dsi_set_bits(dsi, val, reg_hs_twakup_l + offset);
+	test_data[0] = prediv- 1;
+	rk32_dwc_phy_test_wr(dsi, code_pll_input_div_rat, test_data, 1);
+	mdelay(2);
+	test_data[0] = (fbdiv - 1) & 0x1f; 
+	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
+	mdelay(2);
+	test_data[0] = (fbdiv - 1) >> 5 | 0x80; 
+	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
+	mdelay(2);
+	test_data[0] = 0x30;
+	rk32_dwc_phy_test_wr(dsi, code_pll_input_loop_div_rat, test_data, 1);
+	mdelay(2);
+
+	test_data[0] = 0x4d;
+	rk32_dwc_phy_test_wr(dsi, 0x20, test_data, 1);
 	
-	if(Ttxclkesc > 50000) {
-		val = 2*Ttxclkesc;
-		MIPI_DBG("Ttxclkesc:%d\n", Ttxclkesc);
-	}
-	val = val / Ttxbyte_clk;
-	Tlpx = val*Ttxbyte_clk;
-	MIPI_DBG("reg_hs_tlpx: %d, %d\n", val, Tlpx);
-	val -= 2;
-	rk32_dsi_set_bits(dsi, val, reg_hs_tlpx + offset);
+	test_data[0] = 0x3d;
+	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1);
 	
-	Tlpx = 2*Ttxclkesc;
-	val = 4*Tlpx / Ttxclkesc;
-	MIPI_DBG("reg_hs_tta_go: %d, %d\n", val, val*Ttxclkesc);
-	rk32_dsi_set_bits(dsi, val, reg_hs_tta_go + offset);
-	val = 3 * Tlpx / 2 / Ttxclkesc;
-	MIPI_DBG("reg_hs_tta_sure: %d, %d\n", val, val*Ttxclkesc);	
-	rk32_dsi_set_bits(dsi, val, reg_hs_tta_sure + offset);
-	val = 5 * Tlpx / Ttxclkesc;
-	MIPI_DBG("reg_hs_tta_wait: %d, %d\n", val, val*Ttxclkesc);
-	rk32_dsi_set_bits(dsi, val, reg_hs_tta_wait + offset);
-	return 0;
+	test_data[0] = 0xdf;
+	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1); 	
+	
+	test_data[0] =  0x7;
+	rk32_dwc_phy_test_wr(dsi, 0x22, test_data, 1);
+
+	test_data[0] = 0x80 | 0x7;
+	rk32_dwc_phy_test_wr(dsi, 0x22, test_data, 1);
+
+	test_data[0] = 0x80 | 15;
+	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanerequsetstatetime, test_data, 1);
+
+	test_data[0] = 0x80 | 85;
+	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanepreparestatetime, test_data, 1);
+
+	test_data[0] = 0x40 | 10;
+	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanehszerostatetime, test_data, 1);
+
+    return 0;
 }
 
 static int rk312x_phy_init(struct dsi *dsi, int n)
@@ -764,27 +694,42 @@ static int rk312x_phy_init(struct dsi *dsi, int n)
 
 	switch(dsi->host.lane) {
 		case 4:
-			rk321x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE3_OFFSET, n);
+			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE3_OFFSET, n);
 		case 3:
-			rk321x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE2_OFFSET, n);
+			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE2_OFFSET, n);
 		case 2:
-			rk321x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE1_OFFSET, n);
+			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE1_OFFSET, n);
 		case 1:
-			rk321x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE0_OFFSET, n);
-			rk321x_mipi_dsi_phy_set_gotp(dsi, DPHY_CLOCK_OFFSET, n);
+			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE0_OFFSET, n);
+			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_CLOCK_OFFSET, n);
 			break;
 		default:
 			break;	
-	}	
+	}
+/*
+	rk32_dsi_set_bits(dsi, 0x00e4, reg1_phy);
+	rk32_dsi_set_bits(dsi, 0x007d, reg0_phy);
+	udelay(1000);
+	rk32_dsi_set_bits(dsi, 0x00e0, reg1_phy);
+	rk32_dsi_set_bits(dsi, 0x001e, reg20_phy);
+	udelay(1000);
+	rk32_dsi_set_bits(dsi, 0x001f, reg20_phy);
+
+	rk32_dsi_set_bits(dsi, 0x0063, reg10_phy);
+	*/
+	
+	rk32_dsi_set_bits(dsi, 0x06, reg5_phy);
+	rk32_dsi_set_bits(dsi, 0x6, reg10_4_6_phy);
+	rk32_dsi_set_bits(dsi, 0x9, regb_phy);
 	return 0;
 
 }
 
 static int rk_phy_init(struct dsi *dsi)
 {
-	if(cpu_is_rk3288())
+	if (dsi->ops.id == DWC_DSI_VERSION)
 		rk32_phy_init(dsi);
-	else if(cpu_is_rk312x())
+	else if (dsi->ops.id == DWC_DSI_VERSION_RK312x)
 		rk312x_phy_init(dsi, 4);
 	return 0;
 }
@@ -863,13 +808,22 @@ static int rk32_mipi_dsi_host_init(struct dsi *dsi)
 		default:
 			break;
 	}
-	
-	rk32_dsi_set_bits(dsi, 1, hsync_active_low);
-	rk32_dsi_set_bits(dsi, 1, vsync_active_low);
-	
-	rk32_dsi_set_bits(dsi, 0, dataen_active_low);
-	rk32_dsi_set_bits(dsi, 0, colorm_active_low);
-	rk32_dsi_set_bits(dsi, 0, shutd_active_low);
+	if (dsi->ops.id == DWC_DSI_VERSION) {
+		rk32_dsi_set_bits(dsi, 1, hsync_active_low);
+		rk32_dsi_set_bits(dsi, 1, vsync_active_low);
+		
+		rk32_dsi_set_bits(dsi, 0, dataen_active_low);
+		rk32_dsi_set_bits(dsi, 0, colorm_active_low);
+		rk32_dsi_set_bits(dsi, 0, shutd_active_low);
+	} else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
+		rk32_dsi_set_bits(dsi, !screen->pin_hsync, hsync_active_low);
+		rk32_dsi_set_bits(dsi, !screen->pin_vsync, vsync_active_low);
+		
+		rk32_dsi_set_bits(dsi, screen->pin_den, dataen_active_low);
+		rk32_dsi_set_bits(dsi, 1, colorm_active_low);
+		rk32_dsi_set_bits(dsi, 1, shutd_active_low);
+
+	}
 	
 	rk32_dsi_set_bits(dsi, dsi->host.video_mode, vid_mode_type);	  //burst mode
 	
@@ -921,6 +875,10 @@ static int rk32_mipi_dsi_host_init(struct dsi *dsi)
 					screen->hsync_len + screen->right_margin) \
 						/ dsi->phy.Ttxbyte_clk, vid_hline_time);	
 	}
+	MIPI_DBG("dsi->phy.Tpclk = %d\n", dsi->phy.Tpclk);
+	MIPI_DBG("screen->left_margin = %d\n", screen->left_margin);
+	MIPI_DBG("dsi->phy.Ttxbyte_clk = %d\n", dsi->phy.Ttxbyte_clk);
+	MIPI_DBG("screen->hsync_len = %d\n", screen->hsync_len);
     rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->left_margin) / dsi->phy.Ttxbyte_clk, 
 					vid_hbp_time);
 	rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->hsync_len) / dsi->phy.Ttxbyte_clk, 
@@ -958,7 +916,7 @@ static int rk32_mipi_dsi_host_init(struct dsi *dsi)
 	rk32_dsi_set_bits(dsi, 1, lp_vfp_en);
 	rk32_dsi_set_bits(dsi, 1, lp_vbp_en);
 	rk32_dsi_set_bits(dsi, 1, lp_vsa_en);
-
+	
 	//rk32_dsi_set_bits(dsi, 1, frame_bta_ack_en);
 	rk32_dsi_set_bits(dsi, 1, phy_enableclk);
 	rk32_dsi_set_bits(dsi, 0, phy_tx_triggers);
@@ -988,23 +946,29 @@ static int rk_mipi_dsi_init(void *arg, u32 n)
 		MIPI_TRACE("dsi number and mipi type not match!\n");
 	    return -1;
     }
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-	dsi->phy.Tpclk = div_u64(1000000000000llu, screen->pixclock);
-	dsi->phy.ref_clk = 24*MHZ;
-#else
+
 	dsi->phy.Tpclk = rk_fb_get_prmry_screen_pixclock();
 
 	if(dsi->phy.refclk)
 		dsi->phy.ref_clk = clk_get_rate(dsi->phy.refclk) ;
-#endif
+	if (dsi->ops.id == DWC_DSI_VERSION_RK312x)
+		dsi->phy.ref_clk = dsi->phy.ref_clk / 2;// 1/2 of input refclk
+	
 	dsi->phy.sys_clk = dsi->phy.ref_clk;
 
 	printk("dsi->phy.sys_clk =%d\n",dsi->phy.sys_clk );
+	if (dsi->ops.id == DWC_DSI_VERSION) {
+		if((screen->hs_tx_clk <= 90 * MHz) || (screen->hs_tx_clk >= 1500 * MHz))
+			dsi->phy.ddr_clk = 1500 * MHz;    //default is 1.5HGz
+		else
+			dsi->phy.ddr_clk = screen->hs_tx_clk;   
+	} else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
+		if((screen->hs_tx_clk <= 80 * MHz) || (screen->hs_tx_clk >= 1000 * MHz))
+			dsi->phy.ddr_clk = 1000 * MHz;    //default is 1GHz
+		else
+			dsi->phy.ddr_clk = screen->hs_tx_clk;   
 
-	if((screen->hs_tx_clk <= 90 * MHz) || (screen->hs_tx_clk >= 1500 * MHz))
-		dsi->phy.ddr_clk = 1500 * MHz;    //default is 1.5HGz
-	else
-		dsi->phy.ddr_clk = screen->hs_tx_clk;   
+	}
 
 	if(n != 0) 
 		dsi->phy.ddr_clk = n;
@@ -1021,9 +985,12 @@ static int rk_mipi_dsi_init(void *arg, u32 n)
 			break;
 	}
 
+	
+
 	MIPI_DBG("prediv:%d, fbdiv:%d,dsi->phy.ddr_clk:%d\n", dsi->phy.prediv, dsi->phy.fbdiv,dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv);
 
 	dsi->phy.ddr_clk = dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv;	
+
 	MIPI_DBG("dsi->phy.ddr_clk =%d\n",dsi->phy.ddr_clk);
 	dsi->phy.txbyte_clk = dsi->phy.ddr_clk / 8;
 	
@@ -1054,7 +1021,8 @@ static int rk_mipi_dsi_init(void *arg, u32 n)
 	MIPI_DBG("txbyte_clk:%d, Ttxbyte_clk:%d\n", dsi->phy.txbyte_clk, 
 				dsi->phy.Ttxbyte_clk);
 	MIPI_DBG("txclkesc:%d, Ttxclkesc:%d\n", dsi->phy.txclkesc, dsi->phy.Ttxclkesc);
-	
+
+	mdelay(10);
 	rk_phy_power_up(dsi);
 	rk32_mipi_dsi_host_power_up(dsi);
 	rk_phy_init(dsi);
@@ -1115,20 +1083,11 @@ static int rk32_mipi_dsi_send_packet(void *arg, unsigned char cmds[], u32 length
 		MIPI_TRACE("gen_cmd_full\n");
 		return -1;
 	}
-#ifdef CONFIG_MIPI_DSI_LINUX
 	regs = kmalloc(0x400, GFP_KERNEL);
 	if(!regs) {
 		printk("request regs fail!\n");
 		return -ENOMEM;
 	}
-#endif
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-	regs = calloc(1, 0x400);
-	if(!regs) {
-		printf("request regs fail!\n");
-		return -ENOMEM;
-	}
-#endif
 	memcpy(regs,cmds,length);
 	
 	liTmp	= length - 2;
@@ -1257,57 +1216,59 @@ static int rk32_mipi_dsi_send_packet(void *arg, unsigned char cmds[], u32 length
 		udelay(10);
 	}
 	udelay(10);
-#ifdef CONFIG_MIPI_DSI_LINUX
 	kfree(regs);
-#endif
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-	free(regs);
-#endif
 	return 0;
 }
 
 static int rk32_mipi_dsi_read_dcs_packet(void *arg, unsigned char *data1, u32 n)
 {
-	struct dsi *dsi = arg;
-	//DCS READ 
-	//unsigned char *regs = data;
-	unsigned char regs[2];
-	u32 data = 0;
-	int type = 0x06;
-	regs[0] = LPDT;
-	regs[1] = 0x0a;
-	n = n - 1;
-
-				
-	rk32_dsi_set_bits(dsi, regs[0], dcs_sr_0p_tx);
-	
-	/* if(type == DTYPE_GEN_SWRITE_0P)
-		data = (dsi->vid << 6) | (n << 4) | type;
-	else 
-		data = (dsi->vid << 6) | ((n-1) << 4) | type;*/
-
-	data |= regs[1] << 8 | type;
-	// if(n == 2)
-	//    data |= regs[1] << 16;
-
-	MIPI_DBG("write GEN_HDR:%08x\n", data);
-	rk32_dsi_set_bits(dsi, data, GEN_HDR);
-	msleep(100);
-    
-	// rk32_dsi_set_bits(dsi, regs[0], gen_sr_0p_tx);
-
-	printk("rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
-	msleep(100);
-
-	//  rk32_dsi_set_bits(dsi, regs[0], max_rd_pkt_size);
-	
-	msleep(100);
-	// printk("_____rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
-	
-	msleep(100);
-	return 0;
+	 struct dsi *dsi = arg;
+	 //DCS READ
+	 //unsigned char *regs = data;
+	 unsigned char regs[2];
+	 u32 data = 0;
+	 int type = 0x06;
+	 regs[0] = LPDT;
+	 regs[1] = 0x0a;
+	 n = n - 1;
+
+	   
+	 rk32_dsi_set_bits(dsi, regs[0], dcs_sr_0p_tx);
+	 
+	 /* if(type == DTYPE_GEN_SWRITE_0P)
+	  data = (dsi->vid << 6) | (n << 4) | type;
+	 else
+	  data = (dsi->vid << 6) | ((n-1) << 4) | type;*/
+
+	 data |= regs[1] << 8 | type;
+	 // if(n == 2)
+	 // data |= regs[1] << 16;
+
+	 printk("write GEN_HDR:%08x\n", data);
+	 
+	 rk32_dsi_set_bits(dsi, 0xFFFF, bta_to_cnt);
+	 rk32_dsi_set_bits(dsi, 1, bta_en);
+	 rk32_dsi_set_bits(dsi, data, GEN_HDR);
+	 //msleep(1);
+	 udelay(20);
+	   
+	 // rk32_dsi_set_bits(dsi, regs[0], gen_sr_0p_tx);
+
+	 printk("rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
+	 rk32_dsi_set_bits(dsi, 0, bta_en);
+
+	 //msleep(100);
+
+	 // rk32_dsi_set_bits(dsi, regs[0], max_rd_pkt_size);
+	 
+	 //msleep(100);
+	 // printk("_____rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
+	 
+	 //msleep(100);
+ return 0;
 }
 
+
 static int rk32_mipi_dsi_power_up(void *arg)
 {
 	struct dsi *dsi = arg;
@@ -1647,27 +1608,7 @@ static irqreturn_t rk32_mipi_dsi_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 #endif
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-int rk32_dsi_sync(void)
-{
-	/*
-		After the core reset, DPI waits for the first VSYNC active transition to start signal sampling, including
-		pixel data, and preventing image transmission in the middle of a frame.
-	*/
-    dsi_is_enable(0, 0);
-    if (rk_mipi_get_dsi_num() ==2)
-	dsi_is_enable(1, 0); 
 
-    dsi_enable_video_mode(0, 1);
-    dsi_enable_video_mode(1, 1);
-
-    dsi_is_enable(0, 1);
-    if (rk_mipi_get_dsi_num() ==2)
-	dsi_is_enable(1, 1);
-    return 0;
-}
-
-#endif
 #if 0
 static int dwc_phy_test_rd(struct dsi *dsi, unsigned char test_code)
 {
@@ -1686,7 +1627,6 @@ static int dwc_phy_test_rd(struct dsi *dsi, unsigned char test_code)
 static int rk32_dsi_enable(void)
 {
 	MIPI_DBG("rk32_dsi_enable-------\n");
-	
 	rk_fb_get_prmry_screen(dsi0->screen.screen);
 	dsi0->screen.lcdc_id = dsi0->screen.screen->lcdc_id;
 	rk32_init_phy_mode(dsi0->screen.lcdc_id);
@@ -1706,7 +1646,8 @@ static int rk32_dsi_enable(void)
 		dsi_is_enable(1, 0);  
 
 	dsi_enable_video_mode(0, 1);
-	dsi_enable_video_mode(1, 1);
+	if (rk_mipi_get_dsi_num() ==2)
+		dsi_enable_video_mode(1, 1);
 
 	dsi_is_enable(0, 1);
 	if (rk_mipi_get_dsi_num() ==2)
@@ -1719,12 +1660,10 @@ static int rk32_dsi_enable(void)
 static int rk32_dsi_disable(void)
 {
 	MIPI_DBG("rk32_dsi_disable-------\n");
-	
-	rk_mipi_screen_standby(1); 
+	rk_mipi_screen_standby(1);
 	dsi_power_off(0);
-	if (rk_mipi_get_dsi_num() ==2)
+	if (rk_mipi_get_dsi_num() == 2)
 		dsi_power_off(1);
-
 	return 0;
 }
 
@@ -1742,7 +1681,7 @@ static void rk32_init_phy_mode(int lcdc_id)
 
 	MIPI_DBG("rk32_init_phy_mode----------lcdc_id=%d\n",lcdc_id);
 	
-	if(cpu_is_rk312x())
+	if (dsi0->ops.id == DWC_DSI_VERSION_RK312x)
 		return;
 	
 	//D-PHY mode select
@@ -1771,153 +1710,6 @@ static void rk32_init_phy_mode(int lcdc_id)
 	}
 }
 
-#ifdef CONFIG_RK_3288_DSI_UBOOT
-#ifdef CONFIG_OF_LIBFDT
-int rk_dsi_host_parse_dt(const void *blob, struct dsi *dsi)
-{
-	int node;
-
-	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_DSIHOST);
-	if(node<0) {
-		printf("mipi dts get node failed, node = %d.\n", node);
-		return -1;
-	}
-
-	do{
-		if(fdtdec_get_int(blob, node, "rockchip,prop", -1) != dsi->dsi_id){
-			node = fdtdec_next_compatible(blob, node, COMPAT_ROCKCHIP_DSIHOST);
-			if(node<0) {
-				printf("mipi dts get node failed, node = %d.\n", node);
-				return -1;
-			}
-		}else{
-			break;
-		}
-	}while(1);
-	
-	//fdtdec_get_addr_size(blob,node,"reg",&length);
-	dsi->host.membase = (void __iomem *)fdtdec_get_int(blob, node, "reg", -1);
-	//fdt_getprop(blob, node, "reg", &length);
-	MIPI_DBG("dsi->host.membase 0x%08lx.\n",(unsigned long)dsi->host.membase);
-	return 0;
-}
-#endif /* #ifdef CONFIG_OF_LIBFDT */
-
-int rk32_mipi_enable(vidinfo_t *vid)
-{
-	int ret = 0;
-	struct dsi *dsi;
-	struct mipi_dsi_ops *ops;
-	struct rk_screen *screen;
-	struct mipi_dsi_screen *dsi_screen;
-	static int id = 0;
-
-	rk_mipi_screen_probe();
-
-	do{
-		dsi = calloc(1, sizeof(struct dsi));
-		if(!dsi) {
-		  MIPI_DBG("request struct dsi.%d fail!\n",id);
-		  return -ENOMEM;
-		}
-
-		dsi->dsi_id = id;
-#ifdef CONFIG_OF_LIBFDT
-		rk_dsi_host_parse_dt(gd->fdt_blob,dsi);
-#endif /* #ifdef CONFIG_OF_LIBFDT */
-		screen = calloc(1, sizeof(struct rk_screen));
-		if(!screen) {
-		  MIPI_DBG("request struct rk_screen fail!\n");
-		}
-		//rk_fb_get_prmry_screen(screen);
-		ops = &dsi->ops;
-		ops->dsi = dsi;
-		ops->id = DWC_DSI_VERSION,
-		ops->get_id = rk32_mipi_dsi_get_id,
-		ops->dsi_send_packet = rk32_mipi_dsi_send_packet;
-		ops->dsi_read_dcs_packet = rk32_mipi_dsi_read_dcs_packet,
-		ops->dsi_enable_video_mode = rk32_mipi_dsi_enable_video_mode,
-		ops->dsi_enable_command_mode = rk32_mipi_dsi_enable_command_mode,
-		ops->dsi_enable_hs_clk = rk32_mipi_dsi_enable_hs_clk,
-		ops->dsi_is_active = rk32_mipi_dsi_is_active,
-		ops->dsi_is_enable= rk32_mipi_dsi_is_enable,
-		ops->power_up = rk32_mipi_dsi_power_up,
-		ops->power_down = rk32_mipi_dsi_power_down,
-		ops->dsi_init = rk_mipi_dsi_init,
-
-		dsi_screen = &dsi->screen;
-		dsi_screen->type = screen->type = vid->screen_type;
-		dsi_screen->face = screen->face = vid->lcd_face;
-		//dsi_screen->lcdc_id = screen->lcdc_id;
-		//dsi_screen->screen_id = screen->screen_id;
-		//printf("xjh:vid->vl_freq %d vid->real_freq %d\n",vid->vl_freq, vid->real_freq);
-		//dsi_screen->pixclock = screen->mode.pixclock = vid->vl_freq *MHZ ;
-		dsi_screen->pixclock = screen->mode.pixclock = vid->real_freq;
-		dsi_screen->left_margin = screen->mode.left_margin = vid->vl_hbpd;
-		dsi_screen->right_margin = screen->mode.right_margin = vid->vl_hfpd;
-		dsi_screen->hsync_len = screen->mode.hsync_len = vid->vl_hspw;
-		dsi_screen->upper_margin = screen->mode.upper_margin = vid->vl_vbpd;
-		dsi_screen->lower_margin = screen->mode.lower_margin = vid->vl_vfpd;
-		dsi_screen->vsync_len = screen->mode.vsync_len = vid->vl_vspw;
-		dsi_screen->x_res = screen->mode.xres = vid->vl_width;
-		dsi_screen->y_res = screen->mode.yres = vid->vl_height;
-		//dsi_screen->pin_hsync = screen->pin_hsync;
-	    	//dsi_screen->pin_vsync = screen->pin_vsync;
-		//dsi_screen->pin_den = screen->pin_den;
-		//dsi_screen->pin_dclk = screen->pin_dclk;
-		dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
-		//  dsi_screen->dsi_video_mode = screen->dsi_video_mode; //no sure
-		dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
-		dsi_screen->hs_tx_clk = rk_mipi_get_dsi_clk();	
-		dsi_screen->lcdc_id = 1;
-		dsi->dsi_id = id++;//of_alias_get_id(pdev->dev.of_node, "dsi");
-		sprintf(ops->name, "rk_mipi_dsi.%d", dsi->dsi_id);
-
-		ret = rk_mipi_dsi_probe(dsi);
-		if(ret) {
-		  MIPI_DBG("rk mipi_dsi probe fail!\n");
-		  MIPI_DBG("%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
-		}	
-		
-		if(id == 1){
-		  rk32_init_phy_mode(dsi_screen->lcdc_id);
-		  //rk_fb_trsm_ops_register(&trsm_dsi_ops, SCREEN_MIPI);
-		  dsi0 = dsi;
-		}else{   
-		  dsi1 = dsi;
-		}
-	    	//if(vid->screen_type == SCREEN_DUAL_MIPI){
-	    	if( rk_mipi_get_dsi_num() == 2 ){
-	    	    if(id==2)
-			break;
-	    	}else
-	    	    break;
-
-	}while(1);
-	
-	rk32_dsi_enable();
-	
-#if 0
-
-	int reg = 0;
-	
-    // printf("MIPI HOST dump regs\n");
-     for(reg=0x0;reg<0xc4;){
-	// printf("reg[0x%04x]=0x%08x ",reg,
-	// __raw_readl(dsi0->host.membase + reg));
-	 __raw_readl(dsi0->host.membase + reg);
-	 reg+=4;
-//	 if(reg%16 == 0)
-//		 printf("\n");
-     }
-     
-	MIPI_DBG("rk mipi_dsi probe success!\n");
-	MIPI_DBG("%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
-	#endif
-	return 0;
-	
-}
-#endif
 #ifdef CONFIG_MIPI_DSI_LINUX
 static int rk32_mipi_power_down_DDR(void)
 {	
@@ -1940,6 +1732,27 @@ static int rk32_mipi_power_up_DDR(void)
 	return 0;
 }
 
+struct dsi_type {
+	char * label;
+	u32 dsi_id;
+};
+
+static struct dsi_type dsi_rk312x = {
+	.label = "rk312-dsi",
+	.dsi_id = DWC_DSI_VERSION_RK312x,
+};
+
+static struct dsi_type dsi_rk32 = {
+	.label = "rk32-dsi",
+	.dsi_id = DWC_DSI_VERSION,
+};
+
+static const struct of_device_id of_rk_mipi_dsi_match[] = {
+	{ .compatible = "rockchip,rk32-dsi", .data = &dsi_rk32},
+	{ .compatible = "rockchip,rk312x-dsi", .data = &dsi_rk312x},
+	{ /* Sentinel */ } 
+}; 
+
 static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 {
 	int ret = 0; 
@@ -1949,21 +1762,31 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	struct rk_screen *screen;
 	struct mipi_dsi_screen *dsi_screen;
 	struct resource *res_host, *res_phy;
- 
+	const struct dsi_type *data;
+ 	const struct of_device_id *of_id =
+		of_match_device(of_rk_mipi_dsi_match, &pdev->dev);
+	if (!of_id) {
+		dev_err(&pdev->dev, "failed to match device\n");
+		return -ENODEV;
+	}
+	data = of_id->data;
+
 	dsi = devm_kzalloc(&pdev->dev, sizeof(struct dsi), GFP_KERNEL);
 	if(!dsi) {
 		dev_err(&pdev->dev,"request struct dsi fail!\n");
 		return -ENOMEM;
 	}
+	dsi->ops.id = data->dsi_id;
+	printk(KERN_INFO "%s\n", data->label);
 
-	if(cpu_is_rk3288()){
+	if (dsi->ops.id == DWC_DSI_VERSION) {
 		res_host = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 		dsi->host.membase = devm_request_and_ioremap(&pdev->dev, res_host);
 		if (!dsi->host.membase){
 			dev_err(&pdev->dev, "get resource mipi host membase fail!\n");
 			return -ENOMEM;
 		}
-	}else if(cpu_is_rk312x()){
+	}else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
 		res_host = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_dsi_host");
 		dsi->host.membase = devm_request_and_ioremap(&pdev->dev, res_host);
 		if (!dsi->host.membase){
@@ -1971,7 +1794,7 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 			return -ENOMEM;
 		}
 		res_phy = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_dsi_phy");
-		dsi->phy.membase = devm_request_and_ioremap(&pdev->dev, res_host);
+		dsi->phy.membase = devm_request_and_ioremap(&pdev->dev, res_phy);
 		if (!dsi->phy.membase){
 			dev_err(&pdev->dev, "get resource mipi phy membase fail!\n");
 			return -ENOMEM;
@@ -1983,18 +1806,32 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "get clk_mipi_24m clock fail\n");
 		return PTR_ERR(dsi->phy.refclk);
 	}
-	
+
+	/* Get the mipi phy pclk */
 	dsi->dsi_pclk = devm_clk_get(&pdev->dev, "pclk_mipi_dsi");
 	if (unlikely(IS_ERR(dsi->dsi_pclk))) {
 		dev_err(&pdev->dev, "get pclk_mipi_dsi clock fail\n");
 		return PTR_ERR(dsi->dsi_pclk);
 	}
-	if(cpu_is_rk3288()){
-		dsi->dsi_pd = devm_clk_get(&pdev->dev, "pd_mipi_dsi");
-		if (unlikely(IS_ERR(dsi->dsi_pd))) {
-			dev_err(&pdev->dev, "get pd_mipi_dsi clock fail\n");
-			return PTR_ERR(dsi->dsi_pd);
+	
+	if(dsi->ops.id == DWC_DSI_VERSION_RK312x) {
+		/* Get the mipi host pclk */
+		dsi->dsi_host_pclk = devm_clk_get(&pdev->dev, "pclk_mipi_dsi_host");
+		if (unlikely(IS_ERR(dsi->dsi_host_pclk))) {
+			dev_err(&pdev->dev, "get pclk_mipi_dsi_host clock fail\n");
+			return PTR_ERR(dsi->dsi_host_pclk);
 		}
+		/* Get the pd_vio AHB h2p bridge clock */
+		dsi->h2p_hclk = devm_clk_get(&pdev->dev, "hclk_vio_h2p");
+		if (unlikely(IS_ERR(dsi->h2p_hclk))) {
+			dev_err(&pdev->dev, "get hclk_vio_h2p clock fail\n");
+			return PTR_ERR(dsi->h2p_hclk);
+		}		
+	}
+	dsi->dsi_pd = devm_clk_get(&pdev->dev, "pd_mipi_dsi");
+	if (unlikely(IS_ERR(dsi->dsi_pd))) {
+		dev_err(&pdev->dev, "get pd_mipi_dsi clock fail\n");
+		return PTR_ERR(dsi->dsi_pd);
 	}
 	dsi->host.irq = platform_get_irq(pdev, 0);
 	if (dsi->host.irq < 0) {
@@ -2021,7 +1858,7 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	dsi->pdev = pdev;
 	ops = &dsi->ops;
 	ops->dsi = dsi;
-	ops->id = DWC_DSI_VERSION,
+
 	ops->get_id = rk32_mipi_dsi_get_id,
 	ops->dsi_send_packet = rk32_mipi_dsi_send_packet;
 	ops->dsi_read_dcs_packet = rk32_mipi_dsi_read_dcs_packet,
@@ -2096,8 +1933,11 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
     if(support_uboot_display()){
 	    clk_prepare_enable(dsi->phy.refclk); 
 	    clk_prepare_enable(dsi->dsi_pclk);
-	    if(cpu_is_rk3288())
-		    clk_prepare_enable(dsi->dsi_pd);
+		if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
+			clk_prepare_enable(dsi->dsi_host_pclk);
+			clk_prepare_enable(dsi->h2p_hclk);
+		}
+	clk_prepare_enable(dsi->dsi_pd);
 	    udelay(10);
     }
 	dev_info(&pdev->dev,"rk mipi_dsi probe success!\n");
@@ -2106,13 +1946,6 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	return ret;
 }
 
-#ifdef CONFIG_OF
-static const struct of_device_id of_rk_mipi_dsi_match[] = {
-	{ .compatible = "rockchip,rk32-dsi" }, 
-	{ /* Sentinel */ } 
-}; 
-#endif
-
 static struct platform_driver rk32_mipi_dsi_driver = {
 	.probe		= rk32_mipi_dsi_probe,
 	.driver		= {
diff --git a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
index 32a47161b9d3..b2c223d442c4 100755
--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
@@ -173,17 +173,28 @@ drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 #define lane_en_2 					DSI_DPHY_BITS(0x00, 1, 4)
 #define lane_en_1 					DSI_DPHY_BITS(0x00, 1, 3)
 #define lane_en_0 					DSI_DPHY_BITS(0x00, 1, 2)
+#define reg0_phy 					DSI_DPHY_BITS(0x00, 8, 0)
 
 #define reg_da_ppfc 				DSI_DPHY_BITS(0x04, 1, 4)
 #define reg_da_syncrst 				DSI_DPHY_BITS(0x04, 1, 2)
 #define reg_da_ldopd 				DSI_DPHY_BITS(0x04, 1, 1)
 #define reg_da_pllpd 				DSI_DPHY_BITS(0x04, 1, 0)
+#define reg1_phy 				DSI_DPHY_BITS(0x04, 8, 0)
+#define reg5_phy 				DSI_DPHY_BITS(0x14, 3, 0)
+#define reg5_3_phy 				DSI_DPHY_BITS(0x14, 1, 3)
+#define reg5_7_phy 				DSI_DPHY_BITS(0x14, 1, 7)
+#define reg8_phy 				DSI_DPHY_BITS(0x20, 4, 0)
 
 #define reg_fbdiv_8 				DSI_DPHY_BITS(0x0c, 1, 5)
 #define reg_prediv 					DSI_DPHY_BITS(0x0c, 5, 0)
 #define reg_fbdiv 					DSI_DPHY_BITS(0x10, 8, 0)
+#define reg9_phy 				DSI_DPHY_BITS(0x24, 8, 0)
+#define reg10_phy 				DSI_DPHY_BITS(0X40, 8, 0)
+#define reg10_4_6_phy			DSI_DPHY_BITS(0X40, 3, 4)
+#define regb_phy 				DSI_DPHY_BITS(0X2c, 4, 0)
 
 #define reg_dig_rstn 				DSI_DPHY_BITS(0X80, 1, 0)
+#define reg20_phy 				DSI_DPHY_BITS(0X80, 8, 0)
 
 #define DPHY_CLOCK_OFFSET			REG_ADDR(0X0100)
 #define DPHY_LANE0_OFFSET			REG_ADDR(0X0180)
@@ -287,7 +298,9 @@ struct dsi {
 	struct mipi_dsi_ops ops;
 	struct mipi_dsi_screen screen;
 #ifdef CONFIG_MIPI_DSI_LINUX
-	struct clk	*dsi_pclk;
+	struct clk	*dsi_pclk;		// for mipi phy
+	struct clk	*dsi_host_pclk;	// for mipi host
+	struct clk	*h2p_hclk;
 	struct clk	*dsi_pd;
 #endif
     struct dentry *debugfs_dir;
-- 
2.35.3

