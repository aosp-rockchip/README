From 25a17ad43e7575e2e20b48d5133cdac81f31d5bb Mon Sep 17 00:00:00 2001
From: "dalon.zhang" <dalon.zhang@rock-chips.com>
Date: Wed, 18 May 2016 10:18:05 +0800
Subject: [PATCH] camsys driver: v0.0x21.2: compatible with kernel4.4

Change-Id: Iaecb657f51729571e4b19445e2abcf42f50cc30f
Signed-off-by: dalon.zhang <dalon.zhang@rock-chips.com>
---
 drivers/iommu/rk-iommu.c                      |    2 +
 drivers/media/Kconfig                         |    2 +
 drivers/media/Makefile                        |    2 +
 drivers/media/video/Kconfig                   |    4 +-
 drivers/media/video/rk_camsys/Kconfig         |    4 +-
 drivers/media/video/rk_camsys/Makefile        |    2 +-
 drivers/media/video/rk_camsys/camsys_cif.c    |  590 ++--
 drivers/media/video/rk_camsys/camsys_cif.h    |   39 +-
 drivers/media/video/rk_camsys/camsys_drv.c    | 2857 +++++++++--------
 drivers/media/video/rk_camsys/camsys_gpio.h   |   29 +-
 .../media/video/rk_camsys/camsys_internal.h   |  479 +--
 drivers/media/video/rk_camsys/camsys_marvin.c | 1507 +++++----
 drivers/media/video/rk_camsys/camsys_marvin.h |   97 +-
 .../video/rk_camsys/camsys_mipicsi_phy.c      |  444 +--
 .../video/rk_camsys/camsys_mipicsi_phy.h      |    7 +-
 .../media/video/rk_camsys/camsys_soc_priv.c   |   93 +-
 .../media/video/rk_camsys/camsys_soc_priv.h   |   28 +-
 .../media/video/rk_camsys/camsys_soc_rk3288.c |  610 ++--
 .../media/video/rk_camsys/camsys_soc_rk3288.h |  136 +-
 .../media/video/rk_camsys/camsys_soc_rk3366.c |  241 ++
 .../media/video/rk_camsys/camsys_soc_rk3366.h |  119 +
 .../media/video/rk_camsys/camsys_soc_rk3368.c |  393 +--
 .../media/video/rk_camsys/camsys_soc_rk3368.h |   46 +-
 .../media/video/rk_camsys/camsys_soc_rk3399.c |  389 +++
 .../media/video/rk_camsys/camsys_soc_rk3399.h |  175 +
 .../video/rk_camsys/ext_flashled_drv/Kconfig  |    2 +-
 .../rk_camsys/ext_flashled_drv/flashlight.c   |  211 +-
 include/linux/rockchip-iovmm.h                |    2 +
 28 files changed, 4959 insertions(+), 3551 deletions(-)
 create mode 100644 drivers/media/video/rk_camsys/camsys_soc_rk3366.c
 create mode 100644 drivers/media/video/rk_camsys/camsys_soc_rk3366.h
 create mode 100644 drivers/media/video/rk_camsys/camsys_soc_rk3399.c
 create mode 100644 drivers/media/video/rk_camsys/camsys_soc_rk3399.h

diff --git a/drivers/iommu/rk-iommu.c b/drivers/iommu/rk-iommu.c
index 0520d2c63405..e2ae0d813caf 100644
--- a/drivers/iommu/rk-iommu.c
+++ b/drivers/iommu/rk-iommu.c
@@ -1223,6 +1223,8 @@ static const struct of_device_id iommu_dt_ids[] = {
 	{ .compatible = HEVC_IOMMU_COMPATIBLE_NAME},
 	{ .compatible = VPU_IOMMU_COMPATIBLE_NAME},
 	{ .compatible = ISP_IOMMU_COMPATIBLE_NAME},
+	{ .compatible = ISP0_IOMMU_COMPATIBLE_NAME},
+	{ .compatible = ISP1_IOMMU_COMPATIBLE_NAME},
 	{ .compatible = VOP_IOMMU_COMPATIBLE_NAME},
 	{ .compatible = VDEC_IOMMU_COMPATIBLE_NAME},
 	{ /* end */ }
diff --git a/drivers/media/Kconfig b/drivers/media/Kconfig
index 3ef3d6c6bbf8..c7dbbd9d4a26 100644
--- a/drivers/media/Kconfig
+++ b/drivers/media/Kconfig
@@ -216,5 +216,7 @@ config MEDIA_ATTACH
 source "drivers/media/i2c/Kconfig"
 source "drivers/media/tuners/Kconfig"
 source "drivers/media/dvb-frontends/Kconfig"
+source "drivers/media/video/rk_camsys/Kconfig"
+source "drivers/media/video/Kconfig"
 
 endif # MEDIA_SUPPORT
diff --git a/drivers/media/Makefile b/drivers/media/Makefile
index e608bbce0c35..8b8ae168d80b 100644
--- a/drivers/media/Makefile
+++ b/drivers/media/Makefile
@@ -30,4 +30,6 @@ obj-y += rc/
 
 obj-y += common/ platform/ pci/ usb/ mmc/ firewire/
 obj-$(CONFIG_VIDEO_DEV) += radio/
+obj-$(CONFIG_CAMSYS_DRV) += video/rk_camsys/
+obj-$(CONFIG_ROCK_CHIP_SOC_CAMERA) += video/
 
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index a26568d9804c..19d3e88c1833 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -1,13 +1,13 @@
 config ROCK_CHIP_SOC_CAMERA
 	tristate "rockchip supported soc cameras "
-	default y
+	default n
 	
 menu "rockchip camera sensor interface driver"
 	depends on ROCK_CHIP_SOC_CAMERA
 
 	config ROCKCHIP_CAMERA_SENSOR_INTERFACE
 		tristate "rockchip camera sensor interface driver"
-		default y
+		default n
 		
 	config RK30_CAMERA_ONEFRAME
 		tristate "rk30_camera_oneframe"
diff --git a/drivers/media/video/rk_camsys/Kconfig b/drivers/media/video/rk_camsys/Kconfig
index bd2b7e7bc970..efd3715d94f5 100755
--- a/drivers/media/video/rk_camsys/Kconfig
+++ b/drivers/media/video/rk_camsys/Kconfig
@@ -1,6 +1,6 @@
 config CAMSYS_DRV
 	tristate "camsys driver "
-	default y
+	default n
 	
 menu "RockChip camera system driver"
 	depends on CAMSYS_DRV
@@ -9,7 +9,7 @@ source "drivers/media/video/rk_camsys/ext_flashled_drv/Kconfig"
 	
 config CAMSYS_MRV
 	tristate "camsys driver for marvin isp "
-	default y
+	default n
 	---help---
 
 config CAMSYS_CIF
diff --git a/drivers/media/video/rk_camsys/Makefile b/drivers/media/video/rk_camsys/Makefile
index e522ca1e2891..14a5cc46a765 100755
--- a/drivers/media/video/rk_camsys/Makefile
+++ b/drivers/media/video/rk_camsys/Makefile
@@ -2,7 +2,7 @@
 # Makefile for rockchip camsys driver
 #
 obj-$(CONFIG_CAMSYS_DRV) += camsys_drv.o 
-obj-$(CONFIG_CAMSYS_MRV) += camsys_marvin.o camsys_mipicsi_phy.o camsys_soc_priv.o camsys_soc_rk3288.o camsys_soc_rk3368.o
+obj-$(CONFIG_CAMSYS_MRV) += camsys_marvin.o camsys_mipicsi_phy.o camsys_soc_priv.o camsys_soc_rk3288.o camsys_soc_rk3368.o camsys_soc_rk3366.o camsys_soc_rk3399.o
 obj-$(CONFIG_CAMSYS_CIF) += camsys_cif.o
 obj-y					 += ext_flashled_drv/
 
diff --git a/drivers/media/video/rk_camsys/camsys_cif.c b/drivers/media/video/rk_camsys/camsys_cif.c
index fb75953b3fb5..22753b3f50f4 100755
--- a/drivers/media/video/rk_camsys/camsys_cif.c
+++ b/drivers/media/video/rk_camsys/camsys_cif.c
@@ -3,24 +3,24 @@
 static const char miscdev_cif0_name[] = CAMSYS_CIF0_DEVNAME;
 static const char miscdev_cif1_name[] = CAMSYS_CIF1_DEVNAME;
 
-static int camsys_cif_iomux_cb(camsys_extdev_t *extdev,void *ptr)
+static int camsys_cif_iomux_cb(camsys_extdev_t *extdev, void *ptr)
 {
-    unsigned int cif_vol_sel;
-#if 0    
+	unsigned int cif_vol_sel;
+#if 0
     if (extdev->dev_cfg & CAMSYS_DEVCFG_FLASHLIGHT) {
-        iomux_set(ISP_FLASH_TRIG);  
-        if (extdev->fl.fl.io != 0xffffffff) {
-            iomux_set(ISP_FL_TRIG);
-        }
-    } 
+		iomux_set(ISP_FLASH_TRIG);
+		if (extdev->fl.fl.io != 0xffffffff) {
+			iomux_set(ISP_FL_TRIG);
+		}
+	}
 
     if (extdev->dev_cfg & CAMSYS_DEVCFG_PREFLASHLIGHT) {
-        iomux_set(ISP_PRELIGHT_TRIG);
+		iomux_set(ISP_PRELIGHT_TRIG);
     }
-    
+
     if (extdev->dev_cfg & CAMSYS_DEVCFG_SHUTTER) {
-        iomux_set(ISP_SHUTTER_OPEN);
-        iomux_set(ISP_SHUTTER_TRIG);
+		iomux_set(ISP_SHUTTER_OPEN);
+		iomux_set(ISP_SHUTTER_TRIG);
     }
 
     iomux_set(CIF0_CLKOUT);
@@ -32,323 +32,353 @@ static int camsys_cif_iomux_cb(camsys_extdev_t *extdev,void *ptr)
     char state_str[20] = {0};
 
     struct device *dev = &(extdev->pdev->dev);
-    
+
     if (extdev->phy.type == CamSys_Phy_Cif) {
-        if ((extdev->phy.info.cif.fmt >= CamSys_Fmt_Raw_8b)&& (extdev->phy.info.cif.fmt <= CamSys_Fmt_Raw_12b)) {
+		if ((extdev->phy.info.cif.fmt >= CamSys_Fmt_Raw_8b) &&
+			(extdev->phy.info.cif.fmt <= CamSys_Fmt_Raw_12b)) {
 
-           strcpy(state_str,"isp_dvp8bit");
+			strcpy(state_str, "isp_dvp8bit");
 
-        }
+		}
 
-        if ((extdev->phy.info.cif.fmt >= CamSys_Fmt_Raw_10b)&& (extdev->phy.info.cif.fmt <= CamSys_Fmt_Raw_12b)) {
-           strcpy(state_str,"isp_dvp10bit");
-        }
+		if ((extdev->phy.info.cif.fmt >= CamSys_Fmt_Raw_10b) &&
+			(extdev->phy.info.cif.fmt <= CamSys_Fmt_Raw_12b)) {
+			strcpy(state_str, "isp_dvp10bit");
+		}
 
-        if (extdev->phy.info.cif.fmt == CamSys_Fmt_Raw_12b) {
-           strcpy(state_str,"isp_dvp12bit");
+		if (extdev->phy.info.cif.fmt == CamSys_Fmt_Raw_12b) {
+			strcpy(state_str, "isp_dvp12bit");
 
-        }
-    }else{
-           strcpy(state_str,"default");
+		}
+	} else {
+		strcpy(state_str, "default");
     }
 
-    //mux CIF0_CLKOUT
+    /*mux CIF0_CLKOUT*/
 
     pinctrl = devm_pinctrl_get(dev);
     if (IS_ERR(pinctrl)) {
-        camsys_err("%s:Get pinctrl failed!\n",__func__);
-        return -1;
+		camsys_err("%s:Get pinctrl failed!\n", __func__);
+		return -1;
     }
     state = pinctrl_lookup_state(pinctrl,
-                         state_str);
-    if (IS_ERR(state)){
-        dev_err(dev, "%s:could not get %s pinstate\n",__func__,state_str);
-        return -1;
-        }
+								state_str);
+	if (IS_ERR(state)) {
+		dev_err(dev,
+			"%s:could not get %s pinstate\n",
+			__func__, state_str);
+		return -1;
+	}
 
     if (!IS_ERR(state)) {
-        retval = pinctrl_select_state(pinctrl, state);
-        if (retval){
-            dev_err(dev,
-                "%s:could not set %s pins\n",__func__,state_str);
-                return -1;
-
-                }
+		retval = pinctrl_select_state(pinctrl, state);
+		if (retval) {
+			dev_err(dev,
+				"%s:could not set %s pins\n",
+				__func__, state_str);
+				return -1;
+
+			}
     }
 
-    //set 1.8v vol domain for rk32
-    __raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);
-   __raw_writel(0xffffffff, RK_GRF_VIRT+0x01d4);   
+    /*set 1.8v vol domain for rk32*/
+	__raw_writel(((1<<1)|(1<<(1+16))), RK_GRF_VIRT+0x0380);
+	__raw_writel(0xffffffff,  RK_GRF_VIRT+0x01d4);
 
-    //set cif vol domain
+    /*set cif vol domain*/
     if (extdev->phy.type == CamSys_Phy_Cif) {
 
-        #if 0
-        if (!IS_ERR_OR_NULL(extdev->dovdd.ldo)) {
-            if (extdev->dovdd.max_uv >= 25000000) {
-                __raw_writel(((1<<1)|(1<<(1+16))),RK30_GRF_BASE+0x018c);
-            } else {
-                __raw_writel((1<<(1+16)),RK30_GRF_BASE+0x018c);
-            }
-        } else {
-            __raw_writel(((1<<1)|(1<<(1+16))),RK30_GRF_BASE+0x018c);
-        }
-        #else
-
-        //set 1.8v vol domain
-        __raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);
-        #endif
-        
-        //set driver strength
-      //  __raw_writel(0xffffffff, RK_GRF_VIRT+0x01dc);   
-    }
-    
-                
+		#if 0
+		if (!IS_ERR_OR_NULL(extdev->dovdd.ldo)) {
+			if (extdev->dovdd.max_uv >= 25000000) {
+				__raw_writel(((1<<1)|(1<<(1+16))),
+					RK30_GRF_BASE+0x018c);
+			} else {
+				__raw_writel((1<<(1+16)), RK30_GRF_BASE+0x018c);
+			}
+		} else {
+			 __raw_writel(((1<<1)|(1<<(1+16))),
+					RK30_GRF_BASE+0x018c);
+		}
+		#else
+
+		/*set 1.8v vol domain*/
+		__raw_writel(((1<<1)|(1<<(1+16))), RK_GRF_VIRT+0x0380);
+		#endif
+
+		/*set driver strength*/
+		/*  __raw_writel(0xffffffff,  RK_GRF_VIRT+0x01dc);*/
+	}
+
     return 0;
 }
-static int camsys_cif_clkin_cb(void *ptr, unsigned int on)
+static int camsys_cif_clkin_cb(void *ptr,  unsigned int on)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    camsys_cif_clk_t *clk = (camsys_cif_clk_t*)camsys_dev->clk;
-    
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	camsys_cif_clk_t *clk = (camsys_cif_clk_t *)camsys_dev->clk;
+
     spin_lock(&clk->lock);
-    if (on && !clk->in_on) {        
-        clk_prepare_enable(clk->aclk_cif);
-    	clk_prepare_enable(clk->hclk_cif);
-    	clk_prepare_enable(clk->cif_clk_in);
-    	
-        clk->in_on = true;
-        camsys_trace(1, "%s clock in turn on",dev_name(camsys_dev->miscdev.this_device));
+	if (on && !clk->in_on) {
+		clk_prepare_enable(clk->aclk_cif);
+		clk_prepare_enable(clk->hclk_cif);
+		clk_prepare_enable(clk->cif_clk_in);
+
+		clk->in_on = true;
+		camsys_trace(1,  "%s clock in turn on",
+			dev_name(camsys_dev->miscdev.this_device));
     } else if (!on && clk->in_on) {
-    	clk_disable_unprepare(clk->hclk_cif);
-    	clk_disable_unprepare(clk->cif_clk_in);    	
-    	clk_disable_unprepare(clk->pd_cif);
-        clk->in_on = false;
-        camsys_trace(1, "%s clock in turn off",dev_name(camsys_dev->miscdev.this_device));
-    }
-    spin_unlock(&clk->lock);
-    return 0;
+		clk_disable_unprepare(clk->hclk_cif);
+		clk_disable_unprepare(clk->cif_clk_in);
+		clk_disable_unprepare(clk->pd_cif);
+		clk->in_on = false;
+		camsys_trace(1,  "%s clock in turn off",
+			dev_name(camsys_dev->miscdev.this_device));
+	}
+	spin_unlock(&clk->lock);
+	return 0;
 }
 
-static int camsys_cif_clkout_cb(void *ptr, unsigned int on,unsigned int clkin)
+static int camsys_cif_clkout_cb(void *ptr, unsigned int on, unsigned int clkin)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    camsys_cif_clk_t *clk = (camsys_cif_clk_t*)camsys_dev->clk;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	camsys_cif_clk_t *clk = (camsys_cif_clk_t *)camsys_dev->clk;
     struct clk *cif_clk_out_div;
-    
-    
-    spin_lock(&clk->lock);
-    if (on && (clk->out_on != on)) {        
-        clk_prepare_enable(clk->cif_clk_out);
-        clk_set_rate(clk->cif_clk_out,clkin);
-    	
-        clk->out_on = on;
-        camsys_trace(1, "%s clock out(rate: %dHz) turn on",dev_name(camsys_dev->miscdev.this_device),
-                    clk->out_on);
-    } else if (!on && clk->out_on) {
-        if (strcmp(dev_name(camsys_dev->miscdev.this_device),miscdev_cif1_name)==0) {
-            cif_clk_out_div =  clk_get(NULL, "cif1_out_div");
-        } else{
-            cif_clk_out_div =  clk_get(NULL, "cif0_out_div");
-            if(IS_ERR_OR_NULL(cif_clk_out_div)) {
-                cif_clk_out_div =  clk_get(NULL, "cif_out_div");
-            }
-        }
-
-        if(!IS_ERR_OR_NULL(cif_clk_out_div)) {
-            clk_set_parent(clk->cif_clk_out, cif_clk_out_div);
-            clk_put(cif_clk_out_div);
-        } else {
-            camsys_warn("%s clock out may be not off!", dev_name(camsys_dev->miscdev.this_device));
-        }
-        clk_disable_unprepare(clk->cif_clk_out);
-        clk->out_on = 0;
-
-        camsys_trace(1, "%s clock out turn off",dev_name(camsys_dev->miscdev.this_device));
-    }
-    spin_unlock(&clk->lock);
-
-    {
-  //  __raw_writel(0x00, CRU_PCLK_REG30+RK30_CRU_BASE);
-    }
 
-    return 0;
+	spin_lock(&clk->lock);
+	if (on && (clk->out_on != on)) {
+		clk_prepare_enable(clk->cif_clk_out);
+		clk_set_rate(clk->cif_clk_out, clkin);
+
+		clk->out_on = on;
+		camsys_trace(1,  "%s clock out(rate: %dHz) turn on",
+			dev_name(camsys_dev->miscdev.this_device),
+					clk->out_on);
+	} else if (!on && clk->out_on) {
+		if (strcmp(dev_name(camsys_dev->miscdev.this_device),
+			miscdev_cif1_name) == 0) {
+			cif_clk_out_div =  clk_get(NULL,  "cif1_out_div");
+		} else{
+			cif_clk_out_div =  clk_get(NULL,  "cif0_out_div");
+			if (IS_ERR_OR_NULL(cif_clk_out_div)) {
+				cif_clk_out_div =
+					clk_get(NULL,  "cif_out_div");
+			}
+		}
+
+		if (!IS_ERR_OR_NULL(cif_clk_out_div)) {
+			clk_set_parent(clk->cif_clk_out,  cif_clk_out_div);
+			clk_put(cif_clk_out_div);
+		} else {
+			camsys_warn("%s clock out may be not off!",
+				dev_name(camsys_dev->miscdev.this_device));
+		}
+		clk_disable_unprepare(clk->cif_clk_out);
+		clk->out_on = 0;
+
+		camsys_trace(1,  "%s clock out turn off",
+			dev_name(camsys_dev->miscdev.this_device));
+	}
+	spin_unlock(&clk->lock);
+
+	/*  __raw_writel(0x00,  CRU_PCLK_REG30+RK30_CRU_BASE);*/
+
+	return 0;
 }
 
-static irqreturn_t camsys_cif_irq(int irq, void *data)
+static irqreturn_t camsys_cif_irq(int irq,  void *data)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)data;
+    camsys_dev_t *camsys_dev = (camsys_dev_t *)data;
     camsys_irqstas_t *irqsta;
     camsys_irqpool_t *irqpool;
-    unsigned int intsta,frmsta;
+    unsigned int intsta, frmsta;
 
-    intsta = __raw_readl(camsys_dev->devmems.registermem->vir_base + CIF_INITSTA);
-    frmsta = __raw_readl(camsys_dev->devmems.registermem->vir_base + CIF_FRAME_STATUS);
-   printk("get oneframe,intsta = 0x%x \n",intsta);
- 
-    if (intsta & 0x200) {
-        __raw_writel(0x200,camsys_dev->devmems.registermem->vir_base + CIF_INITSTA);
-        __raw_writel(0xf000,camsys_dev->devmems.registermem->vir_base + CIF_CTRL);
-    }
+    intsta = __raw_readl(camsys_dev->devmems.registermem->vir_base +
+		CIF_INITSTA);
+    frmsta = __raw_readl(camsys_dev->devmems.registermem->vir_base +
+		CIF_FRAME_STATUS);
+   printk("get oneframe, intsta = 0x%x \n", intsta);
 
-    if (intsta &0x01) {
-        __raw_writel(0x01,camsys_dev->devmems.registermem->vir_base + CIF_INITSTA);
-        __raw_writel(0x02,camsys_dev->devmems.registermem->vir_base + CIF_FRAME_STATUS);
-        __raw_writel(0xf001,camsys_dev->devmems.registermem->vir_base + CIF_CTRL);
-    }    
-    
-    spin_lock(&camsys_dev->irq.lock);
-    list_for_each_entry(irqpool, &camsys_dev->irq.irq_pool, list) {
-        spin_lock(&irqpool->lock);
-        if (!list_empty(&irqpool->deactive)) {
-            irqsta = list_first_entry(&irqpool->deactive, camsys_irqstas_t, list);
-            irqsta->sta.mis = intsta;
-            irqsta->sta.ris = intsta;
-            list_del_init(&irqsta->list);            
-            list_add_tail(&irqsta->list,&irqpool->active);
-            irqsta = list_first_entry(&irqpool->active, camsys_irqstas_t, list);
-            //wake_up_all(&camsys_dev->irq.irq_done);
-            wake_up(&irqpool->done);
-        }
-        spin_unlock(&irqpool->lock);
-    }
-    spin_unlock(&camsys_dev->irq.lock);
-   
-    return IRQ_HANDLED;
+    if (intsta & 0x200) {
+		__raw_writel(0x200,
+			camsys_dev->devmems.registermem->vir_base +
+			CIF_INITSTA);
+		__raw_writel(0xf000,
+			camsys_dev->devmems.registermem->vir_base +
+			CIF_CTRL);
+	}
+
+	if (intsta &0x01) {
+		__raw_writel(0x01,
+			camsys_dev->devmems.registermem->vir_base +
+			CIF_INITSTA);
+		__raw_writel(0x02,
+			camsys_dev->devmems.registermem->vir_base +
+			CIF_FRAME_STATUS);
+		__raw_writel(0xf001,
+			camsys_dev->devmems.registermem->vir_base +
+			CIF_CTRL);
+	}
+
+	spin_lock(&camsys_dev->irq.lock);
+	list_for_each_entry(irqpool,  &camsys_dev->irq.irq_pool,  list) {
+		spin_lock(&irqpool->lock);
+		if (!list_empty(&irqpool->deactive)) {
+			irqsta = list_first_entry
+				(&irqpool->deactive,  camsys_irqstas_t,  list);
+			irqsta->sta.mis = intsta;
+			irqsta->sta.ris = intsta;
+			list_del_init(&irqsta->list);
+			list_add_tail(&irqsta->list, &irqpool->active);
+			irqsta = list_first_entry
+				(&irqpool->active,  camsys_irqstas_t,  list);
+			/*wake_up_all(&camsys_dev->irq.irq_done);*/
+			wake_up(&irqpool->done);
+		}
+		spin_unlock(&irqpool->lock);
+	}
+	spin_unlock(&camsys_dev->irq.lock);
+
+	return IRQ_HANDLED;
 }
 
 static int camsys_cif_remove(struct platform_device *pdev)
 {
-    camsys_dev_t *camsys_dev = platform_get_drvdata(pdev);
-    camsys_cif_clk_t *cif_clk;
-    
-    if (camsys_dev->clk != NULL) {
-        cif_clk = (camsys_cif_clk_t*)camsys_dev->clk;
-        if (cif_clk->out_on) 
-            camsys_cif_clkout_cb(camsys_dev->clk, 0,0);
-        if (cif_clk->in_on)
-            camsys_cif_clkin_cb(camsys_dev->clk, 0);
-
-        if (cif_clk->pd_cif)
-            clk_put(cif_clk->pd_cif);
-        if (cif_clk->aclk_cif)
-            clk_put(cif_clk->aclk_cif);
-        if (cif_clk->hclk_cif)
-            clk_put(cif_clk->hclk_cif);
-        if (cif_clk->cif_clk_in)
-            clk_put(cif_clk->cif_clk_in);
-        if (cif_clk->cif_clk_out)
-            clk_put(cif_clk->cif_clk_out);
-    
-        kfree(cif_clk);
-        cif_clk = NULL;
-    }
-
-    return 0;
+	camsys_dev_t *camsys_dev = platform_get_drvdata(pdev);
+	camsys_cif_clk_t *cif_clk;
+
+	if (camsys_dev->clk != NULL) {
+		cif_clk = (camsys_cif_clk_t *)camsys_dev->clk;
+		if (cif_clk->out_on)
+			camsys_cif_clkout_cb(camsys_dev->clk, 0, 0);
+		if (cif_clk->in_on)
+			camsys_cif_clkin_cb(camsys_dev->clk, 0);
+
+		if (cif_clk->pd_cif)
+			clk_put(cif_clk->pd_cif);
+		if (cif_clk->aclk_cif)
+			clk_put(cif_clk->aclk_cif);
+		if (cif_clk->hclk_cif)
+			clk_put(cif_clk->hclk_cif);
+		if (cif_clk->cif_clk_in)
+			clk_put(cif_clk->cif_clk_in);
+		if (cif_clk->cif_clk_out)
+			clk_put(cif_clk->cif_clk_out);
+
+		kfree(cif_clk);
+		cif_clk = NULL;
+	}
+
+	return 0;
 }
 
 int camsys_cif_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev)
 {
-    int err = 0;   
-    camsys_cif_clk_t *cif_clk;
-
-    //Irq init
-    err = request_irq(camsys_dev->irq.irq_id, camsys_cif_irq, 0, CAMSYS_CIF_IRQNAME,camsys_dev);
-    if (err) {
-        camsys_err("request irq for %s failed",CAMSYS_CIF_IRQNAME);
-        goto end;
-    }
-
-    //Clk and Iomux init
-    cif_clk = kzalloc(sizeof(camsys_cif_clk_t),GFP_KERNEL);
-    if (cif_clk == NULL) {
-        camsys_err("Allocate camsys_cif_clk_t failed!");
-        err = -EINVAL;
-        goto end;
-    }
-    
-    if (strcmp(dev_name(&pdev->dev),CAMSYS_PLATFORM_CIF1_NAME) == 0) {
-        cif_clk->aclk_cif = devm_clk_get(&pdev->dev, "g_aclk_vip");
-        cif_clk->hclk_cif = devm_clk_get(&pdev->dev, "g_hclk_vip");
-        cif_clk->cif_clk_in = devm_clk_get(&pdev->dev, "g_pclkin_cif");
-        cif_clk->cif_clk_out = devm_clk_get(&pdev->dev, "clk_cif_out");
-        spin_lock_init(&cif_clk->lock);
-        cif_clk->in_on = false;
-        cif_clk->out_on = false;
-    } else {           
-        cif_clk->aclk_cif = devm_clk_get(&pdev->dev, "g_aclk_vip");
-        cif_clk->hclk_cif = devm_clk_get(&pdev->dev, "g_hclk_vip");
-        cif_clk->cif_clk_in = devm_clk_get(&pdev->dev, "g_pclkin_ci");
-        cif_clk->cif_clk_out = devm_clk_get(&pdev->dev, "clk_cif_out");
-        spin_lock_init(&cif_clk->lock);
-        cif_clk->in_on = false;
-        cif_clk->out_on = false;
-    }
-
- //   clk_prepare_enable(cif_clk->aclk_cif);
- //   clk_prepare_enable(cif_clk->hclk_cif);
- //   clk_prepare_enable(cif_clk->cif_clk_in);
- //   clk_prepare_enable(cif_clk->cif_clk_out);
-
-
-    
-    camsys_dev->clk = (void*)cif_clk;
-    camsys_dev->clkin_cb = camsys_cif_clkin_cb;
-    camsys_dev->clkout_cb = camsys_cif_clkout_cb;
-    camsys_dev->iomux = camsys_cif_iomux_cb;
-    
-    //Misc device init
-    camsys_dev->miscdev.minor = MISC_DYNAMIC_MINOR;
-    if (strcmp(dev_name(&pdev->dev),CAMSYS_PLATFORM_CIF1_NAME) == 0) {
-        camsys_dev->miscdev.name = miscdev_cif1_name;
-        camsys_dev->miscdev.nodename = miscdev_cif1_name;        
-    } else {
-        camsys_dev->miscdev.name = miscdev_cif0_name;
-        camsys_dev->miscdev.nodename = miscdev_cif0_name;
-    }
-    camsys_dev->miscdev.fops = &camsys_fops;
-    err = misc_register(&camsys_dev->miscdev);
-    if (err < 0) {
-        camsys_trace(1,"Register /dev/%s misc device failed",camsys_dev->miscdev.name);
-        goto misc_register_failed;
-    } else {
-        camsys_trace(1,"Register /dev/%s misc device success",camsys_dev->miscdev.name);
-    }
-
-    //Variable init
-    if (strcmp(dev_name(&pdev->dev),CAMSYS_PLATFORM_CIF1_NAME) == 0) {
-        camsys_dev->dev_id = CAMSYS_DEVID_CIF_1;
-    } else {
-        camsys_dev->dev_id = CAMSYS_DEVID_CIF_0;
-    }
-    camsys_dev->platform_remove = camsys_cif_remove;
-
-    return 0;
+	int err = 0;
+	camsys_cif_clk_t *cif_clk;
+
+    /*Irq init*/
+	err = request_irq(camsys_dev->irq.irq_id,
+		camsys_cif_irq,  0,  CAMSYS_CIF_IRQNAME,
+		camsys_dev);
+	if (err) {
+		camsys_err("request irq for %s failed", CAMSYS_CIF_IRQNAME);
+		goto end;
+	}
+
+    /*Clk and Iomux init*/
+	cif_clk = kzalloc(sizeof(camsys_cif_clk_t), GFP_KERNEL);
+	if (cif_clk == NULL) {
+		camsys_err("Allocate camsys_cif_clk_t failed!");
+		err = -EINVAL;
+		goto end;
+	}
+
+	if (strcmp(dev_name(&pdev->dev), CAMSYS_PLATFORM_CIF1_NAME) == 0) {
+		cif_clk->aclk_cif = devm_clk_get(&pdev->dev,  "g_aclk_vip");
+		cif_clk->hclk_cif = devm_clk_get(&pdev->dev,  "g_hclk_vip");
+		cif_clk->cif_clk_in = devm_clk_get(&pdev->dev,  "g_pclkin_cif");
+		cif_clk->cif_clk_out = devm_clk_get(&pdev->dev,  "clk_cif_out");
+		spin_lock_init(&cif_clk->lock);
+		cif_clk->in_on = false;
+		cif_clk->out_on = false;
+	} else {
+		cif_clk->aclk_cif = devm_clk_get(&pdev->dev,  "g_aclk_vip");
+		cif_clk->hclk_cif = devm_clk_get(&pdev->dev,  "g_hclk_vip");
+		cif_clk->cif_clk_in = devm_clk_get(&pdev->dev,  "g_pclkin_ci");
+		cif_clk->cif_clk_out = devm_clk_get(&pdev->dev,  "clk_cif_out");
+		spin_lock_init(&cif_clk->lock);
+		cif_clk->in_on = false;
+		cif_clk->out_on = false;
+	}
+
+	/*
+	*clk_prepare_enable(cif_clk->aclk_cif);
+	clk_prepare_enable(cif_clk->hclk_cif);
+	clk_prepare_enable(cif_clk->cif_clk_in);
+	clk_prepare_enable(cif_clk->cif_clk_out);
+	*/
+
+	camsys_dev->clk = (void *)cif_clk;
+	camsys_dev->clkin_cb = camsys_cif_clkin_cb;
+	camsys_dev->clkout_cb = camsys_cif_clkout_cb;
+	camsys_dev->iomux = camsys_cif_iomux_cb;
+
+    /*Misc device init*/
+	camsys_dev->miscdev.minor = MISC_DYNAMIC_MINOR;
+	if (strcmp(dev_name(&pdev->dev), CAMSYS_PLATFORM_CIF1_NAME) == 0) {
+	    camsys_dev->miscdev.name = miscdev_cif1_name;
+	    camsys_dev->miscdev.nodename = miscdev_cif1_name;
+	} else {
+	    camsys_dev->miscdev.name = miscdev_cif0_name;
+	    camsys_dev->miscdev.nodename = miscdev_cif0_name;
+	}
+	camsys_dev->miscdev.fops = &camsys_fops;
+	err = misc_register(&camsys_dev->miscdev);
+	if (err < 0) {
+	    camsys_trace(1,
+			"Register /dev/%s misc device failed",
+			camsys_dev->miscdev.name);
+	    goto misc_register_failed;
+	} else {
+	    camsys_trace(1,
+			"Register /dev/%s misc device success",
+			camsys_dev->miscdev.name);
+	}
+
+	/*Variable init*/
+	if (strcmp(dev_name(&pdev->dev), CAMSYS_PLATFORM_CIF1_NAME) == 0) {
+		camsys_dev->dev_id = CAMSYS_DEVID_CIF_1;
+	} else {
+	    camsys_dev->dev_id = CAMSYS_DEVID_CIF_0;
+	}
+	camsys_dev->platform_remove = camsys_cif_remove;
+
+	return 0;
 
 misc_register_failed:
-    if (!IS_ERR(camsys_dev->miscdev.this_device)) {
-        misc_deregister(&camsys_dev->miscdev);
-    }
+	if (!IS_ERR(camsys_dev->miscdev.this_device)) {
+		misc_deregister(&camsys_dev->miscdev);
+	}
+
+	if (cif_clk) {
+
+		if (cif_clk->pd_cif)
+			clk_put(cif_clk->pd_cif);
+		if (cif_clk->aclk_cif)
+			clk_put(cif_clk->aclk_cif);
+		if (cif_clk->hclk_cif)
+			clk_put(cif_clk->hclk_cif);
+		if (cif_clk->cif_clk_in)
+			clk_put(cif_clk->cif_clk_in);
+		if (cif_clk->cif_clk_out)
+			clk_put(cif_clk->cif_clk_out);
+
+		kfree(cif_clk);
+		cif_clk = NULL;
+	}
 
-    if (cif_clk) {
-
-        if (cif_clk->pd_cif)
-            clk_put(cif_clk->pd_cif);
-        if (cif_clk->aclk_cif)
-            clk_put(cif_clk->aclk_cif);
-        if (cif_clk->hclk_cif)
-            clk_put(cif_clk->hclk_cif);
-        if (cif_clk->cif_clk_in)
-            clk_put(cif_clk->cif_clk_in);
-        if (cif_clk->cif_clk_out)
-            clk_put(cif_clk->cif_clk_out);
-    
-        kfree(cif_clk);
-        cif_clk = NULL;
-    }
-    
 end:
-    return err;
+	return err;
 }
 EXPORT_SYMBOL_GPL(camsys_cif_probe_cb);
 
diff --git a/drivers/media/video/rk_camsys/camsys_cif.h b/drivers/media/video/rk_camsys/camsys_cif.h
index 61f662656550..6506766cc8f4 100755
--- a/drivers/media/video/rk_camsys/camsys_cif.h
+++ b/drivers/media/video/rk_camsys/camsys_cif.h
@@ -15,44 +15,49 @@
 #define CRU_PCLK_REG30                           0xbc
 
 
-#if defined(CONFIG_ARCH_RK3066B) || defined(CONFIG_ARCH_RK3188) || defined(CONFIG_ARCH_ROCKCHIP)
-//GRF_IO_CON3                        0x100
+#if defined(CONFIG_ARCH_RK3066B) || defined(CONFIG_ARCH_RK3188) \
+	|| defined(CONFIG_ARCH_ROCKCHIP)
+/*GRF_IO_CON3                        0x100*/
 #define CIF_DRIVER_STRENGTH_2MA            (0x00 << 12)
 #define CIF_DRIVER_STRENGTH_4MA            (0x01 << 12)
 #define CIF_DRIVER_STRENGTH_8MA            (0x02 << 12)
 #define CIF_DRIVER_STRENGTH_12MA           (0x03 << 12)
 #define CIF_DRIVER_STRENGTH_MASK           (0x03 << 28)
 
-//GRF_IO_CON4                        0x104
+/*GRF_IO_CON4                        0x104*/
 #define CIF_CLKOUT_AMP_3V3                 (0x00 << 10)
 #define CIF_CLKOUT_AMP_1V8                 (0x01 << 10)
 #define CIF_CLKOUT_AMP_MASK                (0x01 << 26)
 
-#define write_grf_reg(addr, val)           __raw_writel(val, addr+RK_GRF_VIRT)
-#define read_grf_reg(addr)                 __raw_readl(addr+RK_GRF_VIRT)
-#define mask_grf_reg(addr, msk, val)       write_grf_reg(addr,(val)|((~(msk))&read_grf_reg(addr)))
+#define write_grf_reg(addr, val)           \
+	__raw_writel(val, addr+RK_GRF_VIRT)
+#define read_grf_reg(addr)                 \
+	__raw_readl(addr+RK_GRF_VIRT)
+#define mask_grf_reg(addr, msk, val)       \
+	write_grf_reg(addr, (val)|((~(msk))&read_grf_reg(addr)))
 #else
-#define write_grf_reg(addr, val)  
+#define write_grf_reg(addr, val)
 #define read_grf_reg(addr)                 0
-#define mask_grf_reg(addr, msk, val)	
+#define mask_grf_reg(addr, msk, val)
 #endif
 
 
 typedef struct camsys_cif_clk_s {
 	struct clk *pd_cif;
 	struct clk *aclk_cif;
-    struct clk *hclk_cif;
-    struct clk *cif_clk_in;
-    bool in_on;
-    
-    struct clk *cif_clk_out;
-    unsigned int out_on;
-    
-    spinlock_t lock;    
+	struct clk *hclk_cif;
+	struct clk *cif_clk_in;
+	bool in_on;
+
+	struct clk *cif_clk_out;
+	unsigned int out_on;
+
+	spinlock_t lock;
 } camsys_cif_clk_t;
 
 
-int camsys_cif_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev);
+int camsys_cif_probe_cb(
+struct platform_device *pdev, camsys_dev_t *camsys_dev);
 
 #endif
 
diff --git a/drivers/media/video/rk_camsys/camsys_drv.c b/drivers/media/video/rk_camsys/camsys_drv.c
index 33be480983c3..bbfa0516b209 100755
--- a/drivers/media/video/rk_camsys/camsys_drv.c
+++ b/drivers/media/video/rk_camsys/camsys_drv.c
@@ -7,9 +7,8 @@
 #include "camsys_soc_priv.h"
 #include "ext_flashled_drv/rk_ext_fshled_ctl.h"
 
-unsigned int camsys_debug=1;
+unsigned int camsys_debug = 1;
 module_param(camsys_debug, int, S_IRUGO|S_IWUSR);
-
 static int drv_version = CAMSYS_DRIVER_VERSION;
 module_param(drv_version, int, S_IRUGO);
 static int head_version = CAMSYS_HEAD_VERSION;
@@ -17,752 +16,838 @@ module_param(head_version, int, S_IRUGO);
 
 
 typedef struct camsys_devs_s {
-    spinlock_t lock;
-    struct list_head devs;
+	spinlock_t lock;
+	struct list_head devs;
 } camsys_devs_t;
 
 static camsys_devs_t camsys_devs;
 
-static int camsys_i2c_write(camsys_i2c_info_t *i2cinfo, camsys_dev_t *camsys_dev)
+static int camsys_i2c_write(camsys_i2c_info_t *i2cinfo, camsys_dev_t
+	*camsys_dev)
 {
-    int err = 0,i,j;
-    unsigned char buf[8],*bufp;
-    unsigned short msg_times,totallen,onelen;
-    struct i2c_msg msg[1];
-    struct i2c_adapter *adapter;
-    
-    adapter = i2c_get_adapter(i2cinfo->bus_num);
-    if (adapter == NULL) {
-        camsys_err("Get %d i2c adapter is failed!",i2cinfo->bus_num);
-        err = -EINVAL;
-        goto end;
-    }
-    
-    if (i2cinfo->i2cbuf_directly) {
-        if (camsys_dev->devmems.i2cmem == NULL) {
-            camsys_err("%s has not i2c mem, it isn't support i2c buf write!",dev_name(camsys_dev->miscdev.this_device));
-            err = -EINVAL;
-            goto end;
-        }
-        totallen = (i2cinfo->i2cbuf_bytes&0xffff);
-        onelen = (i2cinfo->i2cbuf_bytes&0xffff0000)>>16;
-        msg_times = totallen/onelen;
-        if (totallen > camsys_dev->devmems.i2cmem->size) {
-            camsys_err("Want to write 0x%x bytes, i2c memory(size: 0x%x) is overlap",totallen,camsys_dev->devmems.i2cmem->size);
-            err = -EINVAL;
-            goto end;
-        }
-        bufp = (unsigned char*)camsys_dev->devmems.i2cmem->vir_base;        
-    } else {
-        for (i=0; i<i2cinfo->reg_size; i++) {
-            buf[i] = (i2cinfo->reg_addr>>((i2cinfo->reg_size-1-i)*8))&0xff;
-        }
-        for (j=0; j<i2cinfo->val_size; j++) {
-            buf[i+j] = (i2cinfo->val>>((i2cinfo->val_size-1-j)*8))&0xff;  /* ddl@rock-chips.com: v0.a.0 */
-        }
-        bufp = buf;
-        onelen = i2cinfo->val_size + i2cinfo->reg_size;
-        msg_times = 1;
-    }
-    
-	err = -EAGAIN;    
-    msg->addr = (i2cinfo->slave_addr>>1);
-    msg->flags = 0;
-    msg->scl_rate = i2cinfo->speed;
-   // msg->read_type = 0; 
-    msg->len = onelen;
-    for (i=0; i<msg_times; i++) {        
-        msg->buf = bufp+i*onelen;        
-		err = i2c_transfer(adapter, msg, 1);    	
+	int err = 0, i, j;
+	unsigned char buf[8], *bufp;
+	unsigned short msg_times, totallen, onelen;
+	struct i2c_msg msg[1];
+	struct i2c_adapter *adapter;
+
+	adapter = i2c_get_adapter(i2cinfo->bus_num);
+	if (adapter == NULL) {
+		camsys_err("Get %d i2c adapter is failed!", i2cinfo->bus_num);
+		err = -EINVAL;
+		goto end;
+	}
+
+	if (i2cinfo->i2cbuf_directly) {
+		if (camsys_dev->devmems.i2cmem == NULL) {
+			camsys_err("%s has not i2c mem, it isn't support i2c buf write!",
+				dev_name(camsys_dev->miscdev.this_device));
+			err = -EINVAL;
+			goto end;
+		}
+		totallen = (i2cinfo->i2cbuf_bytes & 0xffff);
+		onelen = (i2cinfo->i2cbuf_bytes & 0xffff0000)>>16;
+		msg_times = totallen/onelen;
+		if (totallen > camsys_dev->devmems.i2cmem->size) {
+			camsys_err(
+				"Want to write 0x%x bytes, i2c memory(size: 0x%x) is overlap",
+				totallen, camsys_dev->devmems.i2cmem->size);
+			err = -EINVAL;
+			goto end;
+		}
+		bufp = (unsigned char *)camsys_dev->devmems.i2cmem->vir_base;
+	} else {
+		for (i = 0; i < i2cinfo->reg_size; i++) {
+			buf[i] = (i2cinfo->reg_addr >>
+					((i2cinfo->reg_size-1-i)*8))&0xff;
+		}
+		for (j = 0; j < i2cinfo->val_size; j++) {
+			/* ddl@rock-chips.com: v0.a.0 */
+			buf[i+j] = (i2cinfo->val >>
+					((i2cinfo->val_size-1-j)*8))&0xff;
+		}
+		bufp = buf;
+		onelen = i2cinfo->val_size + i2cinfo->reg_size;
+		msg_times = 1;
+	}
+
+	err = -EAGAIN;
+	msg->addr = (i2cinfo->slave_addr >> 1);
+	msg->flags = 0;
+	msg->len = onelen;
+	for (i = 0; i < msg_times; i++) {
+		msg->buf = bufp + i * onelen;
+		err = i2c_transfer(adapter, msg, 1);
 		if (err < 0) {
-            camsys_err("i2c write dev(addr:0x%x) failed!",i2cinfo->slave_addr);
+			camsys_err("i2c write dev(addr:0x%x) failed!,err = %d",
+				i2cinfo->slave_addr, err);
 			udelay(10);
 		}
-    }
+	}
 
 end:
-    return err;
+	return err;
 }
 
-static int camsys_i2c_read(camsys_i2c_info_t *i2cinfo, camsys_dev_t *camsys_dev)
+static int camsys_i2c_read(
+camsys_i2c_info_t *i2cinfo, camsys_dev_t *camsys_dev)
 {
-    int err = 0,i,retry=2,tmp, num_msg;
-    unsigned char buf[8];
-    struct i2c_msg msg[2];
-    struct i2c_adapter *adapter;
-    
-    adapter = i2c_get_adapter(i2cinfo->bus_num);
-    if (adapter == NULL) {
-        camsys_err("Get %d i2c adapter is failed!",i2cinfo->bus_num);
-        err = -EINVAL;
-        goto end;
-    } 
+	int err = 0, i, retry = 2, tmp, num_msg;
+	unsigned char buf[8];
+	struct i2c_msg msg[2];
+	struct i2c_adapter *adapter;
+
+	adapter = i2c_get_adapter(i2cinfo->bus_num);
+	if (adapter == NULL) {
+		camsys_err("Get %d i2c adapter is failed!", i2cinfo->bus_num);
+		err = -EINVAL;
+		goto end;
+	}
 
 	num_msg = 0;
-	if (i2cinfo->reg_size) {                /* ddl@rock-chips.com: v0.a.0 */
-	    for (i=0; i<i2cinfo->reg_size; i++) {
-	        buf[i] = (i2cinfo->reg_addr>>((i2cinfo->reg_size-1-i)*8))&0xff;
-	    }
-		
-	    msg[0].addr = (i2cinfo->slave_addr>>1);
+	if (i2cinfo->reg_size) {
+		for (i = 0; i < i2cinfo->reg_size; i++) {
+		buf[i] = (i2cinfo->reg_addr>>((i2cinfo->reg_size-1-i)*8))&0xff;
+		}
+
+		msg[0].addr = (i2cinfo->slave_addr>>1);
 		msg[0].flags = 0;
-		msg[0].scl_rate = i2cinfo->speed;
-		//msg[0].read_type = 0;
-	    msg[0].buf = buf;
-	    msg[0].len = i2cinfo->reg_size;
+		msg[0].buf = buf;
+		msg[0].len = i2cinfo->reg_size;
 		num_msg++;
 	}
-    
-    msg[1].addr = (i2cinfo->slave_addr>>1);
+
+	msg[1].addr = (i2cinfo->slave_addr>>1);
 	msg[1].flags = I2C_M_RD;
-	msg[1].scl_rate = i2cinfo->speed;
-//	msg[1].read_type = 0;
-    msg[1].buf = buf;
-    msg[1].len = (unsigned short)i2cinfo->val_size;
-	err = -EAGAIN;    
+	msg[1].buf = buf;
+	msg[1].len = (unsigned short)i2cinfo->val_size;
+	err = -EAGAIN;
 	num_msg++;
 
-	while ((retry-- > 0) && (err < 0)) {						 /* ddl@rock-chips.com :  Transfer again if transent is failed	 */
-		if (num_msg==1) {			
+	while ((retry-- > 0) && (err < 0)) {
+		if (num_msg == 1) {
 			err = i2c_transfer(adapter, &msg[1], num_msg);
 		} else {
 			err = i2c_transfer(adapter, msg, num_msg);
 		}
-	
+
 		if (err >= 0) {
-            err = 0;
+				err = 0;
 		} else {
-			camsys_err("i2c read dev(addr:0x%x) failed,try again-%d!",i2cinfo->slave_addr,retry);
+			camsys_err("i2c read dev(addr:0x%x) failed,try"
+				"again-%d!", i2cinfo->slave_addr, retry);
 			udelay(10);
 		}
 	}
 
+	if (err == 0) {
+		i2cinfo->val = 0x00;
+		for (i = 0; i < i2cinfo->val_size; i++) {
+			tmp = buf[i];
+			i2cinfo->val |= (tmp<<((i2cinfo->val_size-1-i)*8));
+		}
+	}
 
-    if (err==0) { 
-        i2cinfo->val = 0x00;
-        for(i=0; i<i2cinfo->val_size; i++) {
-            tmp = buf[i];
-            i2cinfo->val |= (tmp<<((i2cinfo->val_size-1-i)*8));
-        }
-    }
-    
 end:
-    return err;
+	return err;
 }
 
-
-static int camsys_extdev_register(camsys_devio_name_t *devio, camsys_dev_t *camsys_dev)
+static int camsys_extdev_register(camsys_devio_name_t *devio, camsys_dev_t
+	*camsys_dev)
 {
-    int err = 0,i;
-    camsys_extdev_t *extdev;
-    camsys_regulator_info_t *regulator_info;
-    camsys_regulator_t *regulator;
-    camsys_gpio_info_t *gpio_info;
-    camsys_gpio_t *gpio;
-    
-    if ((devio->dev_id & CAMSYS_DEVID_EXTERNAL) == 0) {
-        err = -EINVAL;
-        camsys_err("dev_id: 0x%x is not support for camsys!",devio->dev_id);
-        goto end;
-    }  
-
-    extdev = camsys_find_extdev(devio->dev_id, camsys_dev);
-    if (extdev != NULL) {
-        if (strcmp(extdev->dev_name, devio->dev_name) == 0) {
-            err = 0;
-        } else {
-            err = -EINVAL;    /* ddl@rock-chips.com: v0.0x13.0 */
-            camsys_warn("Extdev(dev_id: 0x%x dev_name: %s) has been registered in %s!",
-                extdev->dev_id, extdev->dev_name,dev_name(camsys_dev->miscdev.this_device));
-        }
-        goto end;
-    }
-
-    extdev = kzalloc(sizeof(camsys_extdev_t),GFP_KERNEL);
-    if (extdev == NULL) {
-        camsys_err("alloc camsys_extdev_t failed!");
-        err = -ENOMEM;
-        goto end;
-    }
-    
-    extdev->dev_cfg = devio->dev_cfg;
-    extdev->fl.fl.active = devio->fl.fl.active;
-    extdev->fl.ext_fsh_dev = NULL;
-    //should register external flash device ?
-    if(strlen(devio->fl.fl_drv_name) && (strcmp(devio->fl.fl_drv_name,"Internal") != 0)
-        && (strcmp(devio->fl.fl_drv_name,"NC") != 0)){
-        //register flash device
-        extdev->fl.ext_fsh_dev = camsys_register_ext_fsh_dev(&devio->fl);
-        if(extdev->fl.ext_fsh_dev == NULL){
-            camsys_err("register ext flash %s failed!",devio->fl.fl_drv_name);
-            err = -EINVAL;
-            goto fail;
-        }
-    }
-    regulator_info = &devio->avdd;
-    regulator = &extdev->avdd;
-    for (i=(CamSys_Vdd_Start_Tag+1); i<CamSys_Vdd_End_Tag; i++) {
-        if (strcmp(regulator_info->name,"NC")) {
-            regulator->ldo = regulator_get(NULL,regulator_info->name);
-            if (IS_ERR_OR_NULL(regulator->ldo)) {
-                camsys_err("Get %s regulator for dev_id 0x%x failed!",regulator_info->name,devio->dev_id);
-                err = -EINVAL;
-                goto fail;
-            }
-            
-            regulator->min_uv = regulator_info->min_uv;
-            regulator->max_uv = regulator_info->max_uv;
-            camsys_trace(1,"Get %s regulator(min: %duv  max: %duv) for dev_id 0x%x success",
-                        regulator_info->name,regulator->min_uv,regulator->max_uv,
-                        devio->dev_id);
-        } else {
-            regulator->ldo = NULL;
-            regulator->min_uv = 0;
-            regulator->max_uv = 0;
-        }
-
-        regulator++;
-        regulator_info++;
-    }
-
-    gpio_info = &devio->pwrdn;
-    gpio = &extdev->pwrdn;
-    for (i=(CamSys_Gpio_Start_Tag+1); i<CamSys_Gpio_End_Tag; i++) {
-        if (strcmp(gpio_info->name,"NC")) {
-            gpio->io = camsys_gpio_get(gpio_info->name);
-            if (gpio->io < 0) {
-                camsys_err("Get %s gpio for dev_id 0x%x failed!",gpio_info->name,devio->dev_id);
-                err = -EINVAL;
-                goto fail;
-            }
-            if (gpio_request(gpio->io,"camsys_gpio")<0) {
-                camsys_err("Request %s(%d) failed",gpio_info->name,gpio->io);
-            }
-            gpio->active = gpio_info->active;
-            camsys_trace(1,"Get %s(%d) gpio(active: %d) for dev_id 0x%x success!",
-                        gpio_info->name,gpio->io,gpio->active,devio->dev_id);
-        } else {
-            gpio->io = 0xffffffff;
-            gpio->active = 0xffffffff;
-        }
-
-        gpio++;
-        gpio_info++;
-    }
-
-    extdev->pdev = camsys_dev->pdev;
-    extdev->phy = devio->phy;
-    extdev->clk = devio->clk;
-    extdev->dev_id = devio->dev_id;
-    //spin_lock(&camsys_dev->lock);
-    mutex_lock(&camsys_dev->extdevs.mut);
-    list_add_tail(&extdev->list, &camsys_dev->extdevs.list);
-    //spin_unlock(&camsys_dev->lock);
-    mutex_unlock(&camsys_dev->extdevs.mut);
-
-    camsys_dev->iomux(extdev, (void*)camsys_dev);
-
-    memcpy(extdev->dev_name,devio->dev_name, sizeof(extdev->dev_name));
-    camsys_trace(1,"Extdev(dev_id: 0x%x  dev_name: %s) register success",
-        extdev->dev_id,
-        extdev->dev_name);
-
-    return 0;
+	int err = 0, i;
+	camsys_extdev_t *extdev;
+	camsys_regulator_info_t *regulator_info;
+	camsys_regulator_t *regulator;
+	camsys_gpio_info_t *gpio_info;
+	camsys_gpio_t *gpio;
+
+	if ((devio->dev_id & CAMSYS_DEVID_EXTERNAL) == 0) {
+		err = -EINVAL;
+		camsys_err("dev_id: 0x%x is not support for camsys!",
+			devio->dev_id);
+		goto end;
+	}
+
+	extdev = camsys_find_extdev(devio->dev_id, camsys_dev);
+	if (extdev != NULL) {
+		if (strcmp(extdev->dev_name, devio->dev_name) == 0) {
+			err = 0;
+		} else {
+			err = -EINVAL;
+			camsys_warn(
+				"Extdev(dev_id: 0x%x dev_name: %s) has been registered in %s!",
+				extdev->dev_id,
+				extdev->dev_name,
+				dev_name(camsys_dev->miscdev.this_device));
+		}
+		goto end;
+	}
+
+	extdev = kzalloc(sizeof(camsys_extdev_t), GFP_KERNEL);
+	if (extdev == NULL) {
+		camsys_err("alloc camsys_extdev_t failed!");
+		err = -ENOMEM;
+		goto end;
+	}
+
+	extdev->dev_cfg = devio->dev_cfg;
+	extdev->fl.fl.active = devio->fl.fl.active;
+	extdev->fl.ext_fsh_dev = NULL;
+
+	if (strlen(devio->fl.fl_drv_name) &&
+		(strcmp(devio->fl.fl_drv_name, "Internal") != 0)
+		&& (strcmp(devio->fl.fl_drv_name, "NC") != 0)) {
+
+		extdev->fl.ext_fsh_dev =
+			camsys_register_ext_fsh_dev(&devio->fl);
+		if (extdev->fl.ext_fsh_dev == NULL) {
+			camsys_err("register ext flash %s failed!",
+				devio->fl.fl_drv_name);
+			err = -EINVAL;
+			goto fail;
+		}
+	}
+	regulator_info = &devio->avdd;
+	regulator = &extdev->avdd;
+	for (i = (CamSys_Vdd_Start_Tag+1); i < CamSys_Vdd_End_Tag; i++) {
+		if (strcmp(regulator_info->name, "NC")) {
+			regulator->ldo =
+				regulator_get(NULL, regulator_info->name);
+			if (IS_ERR_OR_NULL(regulator->ldo)) {
+				camsys_err(
+					"Get %s regulator for dev_id 0x%x failed!",
+					regulator_info->name, devio->dev_id);
+				err = -EINVAL;
+				goto fail;
+			}
+
+			regulator->min_uv = regulator_info->min_uv;
+			regulator->max_uv = regulator_info->max_uv;
+			camsys_trace(1,
+				"Get %s regulator(min: %duv  max: %duv) for dev_id 0x%x success",
+				regulator_info->name, regulator->min_uv,
+				regulator->max_uv,
+				devio->dev_id);
+		} else {
+			regulator->ldo = NULL;
+			regulator->min_uv = 0;
+			regulator->max_uv = 0;
+		}
+
+		regulator++;
+		regulator_info++;
+	}
+
+	gpio_info = &devio->pwrdn;
+	gpio = &extdev->pwrdn;
+	for (i = (CamSys_Gpio_Start_Tag+1); i < CamSys_Gpio_End_Tag; i++) {
+		if (strcmp(gpio_info->name, "NC")) {
+			gpio->io = camsys_gpio_get(gpio_info->name);
+			if (gpio->io < 0) {
+				camsys_err(
+					"Get %s gpio for dev_id 0x%x failed!",
+					gpio_info->name,
+					devio->dev_id);
+				err = -EINVAL;
+				goto fail;
+			}
+			if (gpio_request(gpio->io, "camsys_gpio") < 0) {
+				camsys_err("Request %s(%d) failed",
+					gpio_info->name, gpio->io);
+			}
+			gpio->active = gpio_info->active;
+			camsys_trace(1,
+				"Get %s(%d) gpio(active: %d) for dev_id 0x%x success!",
+				gpio_info->name, gpio->io,
+				gpio->active, devio->dev_id);
+		} else {
+			gpio->io = 0xffffffff;
+			gpio->active = 0xffffffff;
+		}
+
+		gpio++;
+		gpio_info++;
+	}
+
+	extdev->pdev = camsys_dev->pdev;
+	extdev->phy = devio->phy;
+	extdev->clk = devio->clk;
+	extdev->dev_id = devio->dev_id;
+	mutex_lock(&camsys_dev->extdevs.mut);
+	list_add_tail(&extdev->list, &camsys_dev->extdevs.list);
+	mutex_unlock(&camsys_dev->extdevs.mut);
+
+	camsys_dev->iomux(extdev, (void *)camsys_dev);
+
+	memcpy(extdev->dev_name, devio->dev_name, sizeof(extdev->dev_name));
+	camsys_trace(1, "Extdev(dev_id: 0x%x  dev_name: %s) register success",
+		extdev->dev_id,
+		extdev->dev_name);
+
+	return 0;
 fail:
-    if (extdev) { 
-        kfree(extdev);
-        extdev = NULL;
-    }
+	if (extdev) {
+		kfree(extdev);
+		extdev = NULL;
+	}
 end:
-    
-    return err;
+
+	return err;
 }
 
-static int camsys_extdev_deregister(unsigned int dev_id, camsys_dev_t *camsys_dev, bool all)
+static int camsys_extdev_deregister(unsigned int dev_id, camsys_dev_t
+	*camsys_dev, bool all)
 {
-    int err = 0,i;
-    camsys_extdev_t *extdev;
-    camsys_regulator_t *regulator;
-    camsys_gpio_t *gpio;
-
-    if (all == false) {
-        if ((dev_id & CAMSYS_DEVID_EXTERNAL) == 0) {
-            err = -EINVAL;
-            camsys_err("dev_id: 0x%x is not support for %s!",dev_id, dev_name(camsys_dev->miscdev.this_device));
-            goto end;
-        }
-
-        extdev = camsys_find_extdev(dev_id, camsys_dev);
-        if (extdev == NULL) {
-            err = -EINVAL;
-            camsys_warn("Extdev(dev_id: 0x%x) isn't registered in %s!",
-                dev_id, dev_name(camsys_dev->miscdev.this_device));
-            goto end;
-        }
-
-        regulator = &extdev->avdd;
-        for (i=(CamSys_Vdd_Start_Tag+1); i<CamSys_Vdd_End_Tag; i++) {
-            if (!IS_ERR_OR_NULL(regulator->ldo)) {
-                while(regulator_is_enabled(regulator->ldo)>0)	
-		            regulator_disable(regulator->ldo);
-		        regulator_put(regulator->ldo);
-            }
-            regulator++;
-        }
-
-        gpio = &extdev->pwrdn;
-        for (i=(CamSys_Gpio_Start_Tag+1); i<CamSys_Gpio_End_Tag; i++) {
-            if (gpio->io!=0xffffffff) {                    
-                gpio_free(gpio->io);
-            }
-            gpio++;
-        }
-
-        if(extdev->fl.ext_fsh_dev != NULL){
-            camsys_deregister_ext_fsh_dev(extdev->fl.ext_fsh_dev);
-        }
-        //spin_lock(&camsys_dev->lock);
-        mutex_lock(&camsys_dev->extdevs.mut);
-        list_del_init(&extdev->list);
-        list_del_init(&extdev->active);
-        //spin_unlock(&camsys_dev->lock);
-        mutex_unlock(&camsys_dev->extdevs.mut);
-        
-        camsys_trace(1,"Extdev(dev_id: 0x%x) is deregister success", extdev->dev_id);
-        kfree(extdev);
-        extdev = NULL;
-        
-    } else {
-        //spin_lock(&camsys_dev->lock);
-        mutex_lock(&camsys_dev->extdevs.mut);
-        while (!list_empty(&camsys_dev->extdevs.list)) {
-
-            extdev = list_first_entry(&camsys_dev->extdevs.list, camsys_extdev_t, list);
-            if (extdev) {
-                regulator = &extdev->avdd;
-                for (i=(CamSys_Vdd_Start_Tag+1); i<CamSys_Vdd_End_Tag; i++) {
-                    if (!IS_ERR(regulator->ldo)) {
-                        while(regulator_is_enabled(regulator->ldo)>0)	
-    			            regulator_disable(regulator->ldo);
-    			        regulator_put(regulator->ldo);
-                    }
-                    regulator++; 
-                }
-
-                gpio = &extdev->pwrdn;
-                for (i=(CamSys_Gpio_Start_Tag+1); i<CamSys_Gpio_End_Tag; i++) {
-                    if (gpio->io!=0xffffffff) {                    
-                        gpio_free(gpio->io);
-                    }
-                    gpio++;
-                }
-
-                if(extdev->fl.ext_fsh_dev != NULL){
-                    camsys_deregister_ext_fsh_dev(extdev->fl.ext_fsh_dev);
-                }
-                camsys_trace(1,"Extdev(dev_id: 0x%x) is deregister success", extdev->dev_id);
-                list_del_init(&extdev->list);
-                list_del_init(&extdev->active);
-                kfree(extdev);
-                extdev=NULL;
-            }
-        }
-        //spin_unlock(&camsys_dev->lock);        
-        mutex_unlock(&camsys_dev->extdevs.mut);
-        camsys_trace(1, "All extdev is deregister success!");
-    }
-    
-
-end:    
-    return err;
+	int err = 0, i;
+	camsys_extdev_t *extdev;
+	camsys_regulator_t *regulator;
+	camsys_gpio_t *gpio;
+
+	if (all == false) {
+		if ((dev_id & CAMSYS_DEVID_EXTERNAL) == 0) {
+			err = -EINVAL;
+			camsys_err("dev_id: 0x%x is not support for %s!",
+				dev_id,
+				dev_name(camsys_dev->miscdev.this_device));
+			goto end;
+		}
+
+		extdev = camsys_find_extdev(dev_id, camsys_dev);
+		if (extdev == NULL) {
+			err = -EINVAL;
+			camsys_warn("Extdev(dev_id: 0x%x) isn't registered in %s!",
+				dev_id,
+				dev_name(camsys_dev->miscdev.this_device));
+			goto end;
+		}
+
+		regulator = &extdev->avdd;
+		for (i = (CamSys_Vdd_Start_Tag + 1);
+			i < CamSys_Vdd_End_Tag; i++) {
+			if (!IS_ERR_OR_NULL(regulator->ldo)) {
+				while (regulator_is_enabled(regulator->ldo) > 0)
+					regulator_disable(regulator->ldo);
+				regulator_put(regulator->ldo);
+			}
+			regulator++;
+		}
+
+		gpio = &extdev->pwrdn;
+		for (i = (CamSys_Gpio_Start_Tag + 1);
+			i < CamSys_Gpio_End_Tag; i++) {
+			if (gpio->io != 0xffffffff) {
+				gpio_free(gpio->io);
+			}
+			gpio++;
+		}
+
+		if (extdev->fl.ext_fsh_dev != NULL) {
+			camsys_deregister_ext_fsh_dev(extdev->fl.ext_fsh_dev);
+		}
+		/* spin_lock(&camsys_dev->lock); */
+		mutex_lock(&camsys_dev->extdevs.mut);
+		list_del_init(&extdev->list);
+		list_del_init(&extdev->active);
+		/* spin_unlock(&camsys_dev->lock); */
+		mutex_unlock(&camsys_dev->extdevs.mut);
+
+		camsys_trace(1, "Extdev(dev_id: 0x%x) is deregister success",
+			extdev->dev_id);
+		kfree(extdev);
+		extdev = NULL;
+
+	} else {
+		/* spin_lock(&camsys_dev->lock); */
+		mutex_lock(&camsys_dev->extdevs.mut);
+		while (!list_empty(&camsys_dev->extdevs.list)) {
+			extdev = list_first_entry(&camsys_dev->extdevs.list,
+				camsys_extdev_t,
+				list);
+			if (extdev) {
+				regulator = &extdev->avdd;
+				for (i = (CamSys_Vdd_Start_Tag+1);
+					i < CamSys_Vdd_End_Tag; i++) {
+					if (!IS_ERR(regulator->ldo)) {
+						while (
+							regulator_is_enabled(
+							regulator->ldo) > 0)
+							regulator_disable(
+							regulator->ldo);
+						regulator_put(
+							regulator->ldo);
+					}
+					regulator++;
+				}
+
+				gpio = &extdev->pwrdn;
+				for (i = (CamSys_Gpio_Start_Tag+1);
+					i < CamSys_Gpio_End_Tag; i++) {
+					if (gpio->io != 0xffffffff) {
+						gpio_free(gpio->io);
+					}
+					gpio++;
+				}
+
+				if (extdev->fl.ext_fsh_dev != NULL) {
+					camsys_deregister_ext_fsh_dev(
+						extdev->fl.ext_fsh_dev);
+				}
+				camsys_trace(1,
+					"Extdev(dev_id: 0x%x) is deregister success",
+					extdev->dev_id);
+				list_del_init(&extdev->list);
+				list_del_init(&extdev->active);
+				kfree(extdev);
+				extdev = NULL;
+			}
+		}
+		/* spin_unlock(&camsys_dev->lock); */
+		mutex_unlock(&camsys_dev->extdevs.mut);
+		camsys_trace(1, "All extdev is deregister success!");
+	}
+
+end:
+	return err;
 
 }
+static int camsys_sysctl_external(camsys_sysctrl_t *devctl,
+	camsys_dev_t *camsys_dev)
+{
+	int i;
+	int err = 0;
+	camsys_extdev_t *extdev, *extdev2;
+
+	/* External */
+	for (i = 0; i < 8; i++) {
+		if ((devctl->dev_mask & (1<<(i+24))) == 0)
+			continue;
+
+		extdev = camsys_find_extdev((1 << (i+24)), camsys_dev);
+		if (extdev == NULL)
+			camsys_err("Can not find dev_id 0x%x device in %s!",
+			(1<<(i+24)),
+			dev_name(camsys_dev->miscdev.this_device));
+
+		camsys_sysctl_extdev(
+			extdev, devctl, camsys_dev);
+
+		if (devctl->ops == CamSys_ClkIn) {
+			if (devctl->on) {
+				list_add_tail(&extdev->active,
+					&camsys_dev->extdevs.active);
+			} else {
+				if (list_empty(
+					&camsys_dev->extdevs.active))
+					continue;
+
+				list_for_each_entry(extdev2,
+					&camsys_dev->extdevs.active,
+					active) {
+					if (extdev2 == extdev) {
+						list_del_init(&extdev->active);
+						break;
+					}
+				}
+			}
+		} else if (devctl->ops == CamSys_Flash_Trigger) {
+			err = camsys_ext_fsh_ctrl(extdev->fl.ext_fsh_dev,
+				devctl->rev[0], devctl->on);
+		}
+	}
 
+	return 0;
+}
 static int camsys_sysctl(camsys_sysctrl_t *devctl, camsys_dev_t *camsys_dev)
 {
-    int i;
-    int err = 0;    
-    camsys_extdev_t *extdev,*extdev2;
+	int err = 0;
 
-    //spin_lock(&camsys_dev->lock);
-    mutex_lock(&camsys_dev->extdevs.mut);
-	if(devctl->ops == 0xaa){
+	/* spin_lock(&camsys_dev->lock); */
+	mutex_lock(&camsys_dev->extdevs.mut);
+	if (devctl->ops == 0xaa) {
 		dump_stack();
 		return 0;
 	}
-    //Internal 
-    if (camsys_dev->dev_id & devctl->dev_mask) {
-        switch (devctl->ops)
-        {
-            case CamSys_ClkIn:
-            {
-                camsys_dev->clkin_cb(camsys_dev,devctl->on);
-                break;
-            }
-
-            case CamSys_Rst:
-            {
-                camsys_dev->reset_cb(camsys_dev, devctl->on);
-                break;
-            } 
-            case CamSys_Flash_Trigger:
-            {
-                camsys_dev->flash_trigger_cb(camsys_dev,devctl->rev[0], devctl->on);
-                break;
-            }
-            case CamSys_IOMMU:
-            {
-                if(camsys_dev->iommu_cb(camsys_dev, devctl) < 0){
-                    err = -1;
-                    }
-                break;
-            }
-            default:
-                break;
-
-        }
-    }
-
-    //External
-    for (i=0; i<8; i++) {
-        if (devctl->dev_mask & (1<<(i+24))) {
-            extdev = camsys_find_extdev((1<<(i+24)), camsys_dev);
-            if (extdev) {
-                camsys_sysctl_extdev(extdev, devctl, camsys_dev);
-
-                if (devctl->ops == CamSys_ClkIn) {
-                    if (devctl->on) {
-                        list_add_tail(&extdev->active,&camsys_dev->extdevs.active);
-                    } else {
-                        if (!list_empty(&camsys_dev->extdevs.active)) {    /* ddla@rock-chips.com: v0.0.7 */
-                            list_for_each_entry(extdev2, &camsys_dev->extdevs.active, active) {
-                                if (extdev2 == extdev) {
-                                    list_del_init(&extdev->active);
-                                    break;
-                                }
-                            }
-                        }
-                    }
-                }else if(devctl->ops == CamSys_Flash_Trigger){
-                    err = camsys_ext_fsh_ctrl(extdev->fl.ext_fsh_dev,devctl->rev[0],devctl->on);
-                }
-                
-            } else {
-                camsys_err("Can not find dev_id 0x%x device in %s!", (1<<(i+24)), dev_name(camsys_dev->miscdev.this_device));
-            }
-        }
-    }
-
-    //spin_unlock(&camsys_dev->lock);
-    mutex_unlock(&camsys_dev->extdevs.mut);
-    return err;
+	/* Internal */
+	if (camsys_dev->dev_id & devctl->dev_mask) {
+		switch (devctl->ops) {
+		case CamSys_ClkIn: {
+			camsys_dev->clkin_cb(camsys_dev, devctl->on);
+			break;
+		}
+
+		case CamSys_Rst: {
+			camsys_dev->reset_cb(camsys_dev, devctl->on);
+			break;
+		}
+		case CamSys_Flash_Trigger: {
+			camsys_dev->flash_trigger_cb(
+				camsys_dev, devctl->rev[0], devctl->on);
+			break;
+		}
+		case CamSys_IOMMU: {
+			if (camsys_dev->iommu_cb(camsys_dev, devctl) < 0) {
+				err = -1;
+			}
+			break;
+		}
+		default:
+			break;
+
+		}
+	}
+
+	camsys_sysctl_external(devctl, camsys_dev);
+
+	/* spin_unlock(&camsys_dev->lock); */
+	mutex_unlock(&camsys_dev->extdevs.mut);
+	return err;
 }
-static int camsys_phy_ops (camsys_extdev_t *extdev, camsys_sysctrl_t *devctl, void *ptr)
+
+static int camsys_phy_ops(camsys_extdev_t *extdev, camsys_sysctrl_t *devctl,
+	void *ptr)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    camsys_mipiphy_t *mipiphy;
-    int err = 0;
-    
-    if (extdev->phy.type == CamSys_Phy_Mipi) {
-        mipiphy = (camsys_mipiphy_t*)devctl->rev;
-        if (devctl->on == 0) {
-            mipiphy->phy_index = extdev->phy.info.mipi.phy_index;
-            mipiphy->bit_rate = 0;
-            mipiphy->data_en_bit = 0x00;
-        } else {
-            if ((mipiphy->bit_rate == 0) || (mipiphy->data_en_bit == 0)) {
-                *mipiphy = extdev->phy.info.mipi;
-            }
-            if (mipiphy->phy_index != extdev->phy.info.mipi.phy_index) {
-                camsys_warn("mipiphy->phy_index(%d) != extdev->phy.info.mipi.phy_index(%d)!",
-                    mipiphy->phy_index,extdev->phy.info.mipi.phy_index);
-                mipiphy->phy_index = extdev->phy.info.mipi.phy_index;
-                
-            }
-        }
-        err = camsys_dev->mipiphy[mipiphy->phy_index].ops(ptr,mipiphy);
-        if (err < 0) {
-            camsys_err("extdev(0x%x) mipi phy ops config failed!",extdev->dev_id);
-        }
-    }
-
-    return err;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	camsys_mipiphy_t *mipiphy;
+	int err = 0;
+
+	if (extdev->phy.type == CamSys_Phy_Mipi) {
+		mipiphy = (camsys_mipiphy_t *)devctl->rev;
+		if (devctl->on == 0) {
+			mipiphy->phy_index = extdev->phy.info.mipi.phy_index;
+			mipiphy->bit_rate = 0;
+			mipiphy->data_en_bit = 0x00;
+		} else {
+			if ((mipiphy->bit_rate == 0) ||
+				(mipiphy->data_en_bit == 0)) {
+				*mipiphy = extdev->phy.info.mipi;
+			}
+			if (mipiphy->phy_index !=
+				extdev->phy.info.mipi.phy_index) {
+				camsys_warn(
+					"mipiphy->phy_index(%d) != "
+					"extdev->phy.info.mipi.phy_index(%d)!",
+				mipiphy->phy_index,
+				extdev->phy.info.mipi.phy_index);
+				mipiphy->phy_index =
+					extdev->phy.info.mipi.phy_index;
+			}
+		}
+		err = camsys_dev->mipiphy[mipiphy->phy_index].ops(ptr, mipiphy);
+		if (err < 0) {
+			camsys_err("extdev(0x%x) mipi phy ops config failed!",
+				extdev->dev_id);
+		}
+	}
+
+	return err;
 }
-static int camsys_irq_connect(camsys_irqcnnt_t *irqcnnt, camsys_dev_t *camsys_dev)
+
+static int camsys_irq_connect(camsys_irqcnnt_t *irqcnnt, camsys_dev_t
+	*camsys_dev)
 {
-    int err = 0,i;
-    camsys_irqpool_t *irqpool; 
-    unsigned long int flags;
-
-    if ((irqcnnt->mis != MRV_ISP_MIS) &&
-        (irqcnnt->mis != MRV_MIPI_MIS) &&
-        (irqcnnt->mis != MRV_MI_MIS) &&
-        (irqcnnt->mis != MRV_JPG_MIS) &&
-        (irqcnnt->mis != MRV_JPG_ERR_MIS)) {
-
-        camsys_err("this thread(pid: %d) irqcnnt->mis(0x%x) is invalidate, irq connect failed!",
-            irqcnnt->pid, irqcnnt->mis);
-
-        err = -EINVAL;
-        goto end;
-    }   
-
-    spin_lock_irqsave(&camsys_dev->irq.lock,flags);
-    if (!list_empty(&camsys_dev->irq.irq_pool)) {
-        list_for_each_entry(irqpool, &camsys_dev->irq.irq_pool, list) {
-            if (irqpool->pid == irqcnnt->pid) {
-                camsys_warn("this thread(pid: %d) had been connect irq!",current->pid);
-                spin_unlock(&camsys_dev->irq.lock);
-                goto end;
-            }
-        }
-    }
-    spin_unlock_irqrestore(&camsys_dev->irq.lock,flags);
-    
-    irqpool = kzalloc(sizeof(camsys_irqpool_t),GFP_KERNEL);
-    if (irqpool) {
-        spin_lock_init(&irqpool->lock);
-        irqpool->pid = irqcnnt->pid;
-        irqpool->timeout = irqcnnt->timeout;
-        irqpool->mis = irqcnnt->mis;
-        irqpool->icr = irqcnnt->icr;
-        INIT_LIST_HEAD(&irqpool->active);
-        INIT_LIST_HEAD(&irqpool->deactive);
-        init_waitqueue_head(&irqpool->done);
-        for (i=0; i<CAMSYS_IRQPOOL_NUM; i++) {
-            list_add_tail(&irqpool->pool[i].list, &irqpool->deactive);
-        }
-    }
-    
-    spin_lock_irqsave(&camsys_dev->irq.lock,flags);
-    //camsys_dev->irq.timeout = irqcnnt->timeout;
-    list_add_tail(&irqpool->list, &camsys_dev->irq.irq_pool);
-    spin_unlock_irqrestore(&camsys_dev->irq.lock,flags);
-    camsys_trace(1, "Thread(pid: %d) connect %s irq success! mis: 0x%x icr: 0x%x ", irqpool->pid, dev_name(camsys_dev->miscdev.this_device),
-        irqpool->mis,irqpool->icr);
+	int err = 0, i;
+	camsys_irqpool_t *irqpool;
+	unsigned long int flags;
+
+	if ((irqcnnt->mis != MRV_ISP_MIS) &&
+		(irqcnnt->mis != MRV_MIPI_MIS) &&
+		(irqcnnt->mis != MRV_MI_MIS) &&
+		(irqcnnt->mis != MRV_JPG_MIS) &&
+		(irqcnnt->mis != MRV_JPG_ERR_MIS)) {
+
+		camsys_err("this thread(pid: %d) irqcnnt->mis(0x%x) is invalidate,"
+			"irq connect failed!",
+			irqcnnt->pid, irqcnnt->mis);
+
+		err = -EINVAL;
+		goto end;
+	}
+
+	spin_lock_irqsave(&camsys_dev->irq.lock, flags);
+	if (!list_empty(&camsys_dev->irq.irq_pool)) {
+		list_for_each_entry(irqpool, &camsys_dev->irq.irq_pool, list) {
+			if (irqpool->pid == irqcnnt->pid) {
+				camsys_warn("this thread(pid: %d) had been connect irq!",
+					current->pid);
+				spin_unlock(&camsys_dev->irq.lock);
+				goto end;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&camsys_dev->irq.lock, flags);
+
+	irqpool = kzalloc(sizeof(camsys_irqpool_t), GFP_KERNEL);
+	if (irqpool) {
+		spin_lock_init(&irqpool->lock);
+		irqpool->pid = irqcnnt->pid;
+		irqpool->timeout = irqcnnt->timeout;
+		irqpool->mis = irqcnnt->mis;
+		irqpool->icr = irqcnnt->icr;
+		INIT_LIST_HEAD(&irqpool->active);
+		INIT_LIST_HEAD(&irqpool->deactive);
+		init_waitqueue_head(&irqpool->done);
+		for (i = 0;
+			i < CAMSYS_IRQPOOL_NUM;
+			i++) {
+			list_add_tail(&irqpool->pool[i].list,
+				&irqpool->deactive);
+		}
+	}
+
+	spin_lock_irqsave(&camsys_dev->irq.lock, flags);
+	list_add_tail(&irqpool->list, &camsys_dev->irq.irq_pool);
+	spin_unlock_irqrestore(&camsys_dev->irq.lock, flags);
+	camsys_trace(1,
+		"Thread(pid: %d) connect %s irq success! mis: 0x%x icr: 0x%x",
+		irqpool->pid, dev_name(camsys_dev->miscdev.this_device),
+		irqpool->mis, irqpool->icr);
 
 end:
-    return err;
+	return err;
 }
 static int active_list_isnot_empty(camsys_irqpool_t *irqpool)
 {
-    int err;
-    unsigned long int flags;
-    
-    spin_lock_irqsave(&irqpool->lock,flags);
-    err = list_empty(&irqpool->active);
-    spin_unlock_irqrestore(&irqpool->lock,flags);
-
-    return !err;
-    
+	int err;
+	unsigned long int flags;
+
+	spin_lock_irqsave(&irqpool->lock, flags);
+	err = list_empty(&irqpool->active);
+	spin_unlock_irqrestore(&irqpool->lock, flags);
+
+	return !err;
 }
 static int camsys_irq_wait(camsys_irqsta_t *irqsta, camsys_dev_t *camsys_dev)
 {
-    int err = 0;
-    bool find_pool = false;
-    camsys_irqstas_t *irqstas;
-    camsys_irqpool_t *irqpool;
-    unsigned long int flags;
-    
-    spin_lock_irqsave(&camsys_dev->irq.lock,flags);
-    if (!list_empty(&camsys_dev->irq.irq_pool)) {
-        list_for_each_entry(irqpool, &camsys_dev->irq.irq_pool, list) {
-            if (irqpool->pid == current->pid) {
-                find_pool = true;
-                break;
-            }
-        }
-    }
-    spin_unlock_irqrestore(&camsys_dev->irq.lock,flags);
-
-    if (find_pool == false) {
-        camsys_err("this thread(pid: %d) hasn't been connect irq, so wait irq failed!",current->pid);
-        err = -EINVAL;
-        goto end;
-    }
-    
-    
-    spin_lock_irqsave(&irqpool->lock,flags);
-    if (!list_empty(&irqpool->active)) {
-        irqstas = list_first_entry(&irqpool->active, camsys_irqstas_t, list);
-        *irqsta = irqstas->sta;
-        list_del_init(&irqstas->list);
-        list_add_tail(&irqstas->list,&irqpool->deactive);
-        spin_unlock_irqrestore(&irqpool->lock,flags);
-    } else {
-        spin_unlock_irqrestore(&irqpool->lock,flags);
-        
-        wait_event_interruptible_timeout(irqpool->done,
-            active_list_isnot_empty(irqpool),
-            usecs_to_jiffies(irqpool->timeout));
-
-        if (irqpool->pid == current->pid) {
-            if (active_list_isnot_empty(irqpool)) {
-                spin_lock_irqsave(&irqpool->lock,flags);
-                irqstas = list_first_entry(&irqpool->active, camsys_irqstas_t, list);
-                *irqsta = irqstas->sta;
-                list_del_init(&irqstas->list);
-                list_add_tail(&irqstas->list,&irqpool->deactive);
-                spin_unlock_irqrestore(&irqpool->lock,flags);
-            } else {
-                err = -EAGAIN;
-            }
-        } else {
-            camsys_warn("Thread(pid: %d) has been disconnect!",current->pid);
-            err = -EAGAIN;
-        }
-    }
-
-    if (err == 0) {
-        camsys_trace(3,"Thread(pid: %d) has been wake up for irq(mis: 0x%x ris:0x%x)!",
-                     current->pid, irqsta->mis, irqsta->ris);
-    }
+	int err = 0;
+	bool find_pool = false;
+	camsys_irqstas_t *irqstas;
+	camsys_irqpool_t *irqpool;
+	unsigned long int flags;
+
+	spin_lock_irqsave(&camsys_dev->irq.lock, flags);
+	if (!list_empty(&camsys_dev->irq.irq_pool)) {
+		list_for_each_entry(irqpool, &camsys_dev->irq.irq_pool, list) {
+			if (irqpool->pid == current->pid) {
+				find_pool = true;
+				break;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&camsys_dev->irq.lock, flags);
+
+	if (find_pool == false) {
+		camsys_err(
+			"this thread(pid: %d) hasn't been connect irq, so wait irq failed!",
+			current->pid);
+		err = -EINVAL;
+		goto end;
+	}
+
+	spin_lock_irqsave(&irqpool->lock, flags);
+	if (!list_empty(&irqpool->active)) {
+		irqstas = list_first_entry(&irqpool->active,
+			camsys_irqstas_t, list);
+		*irqsta = irqstas->sta;
+		list_del_init(&irqstas->list);
+		list_add_tail(&irqstas->list, &irqpool->deactive);
+		spin_unlock_irqrestore(&irqpool->lock, flags);
+	} else {
+		spin_unlock_irqrestore(&irqpool->lock, flags);
+
+		wait_event_interruptible_timeout(irqpool->done,
+			active_list_isnot_empty(irqpool),
+			usecs_to_jiffies(irqpool->timeout));
+
+		if (irqpool->pid == current->pid) {
+			if (active_list_isnot_empty(irqpool)) {
+				spin_lock_irqsave(&irqpool->lock, flags);
+				irqstas = list_first_entry(
+					&irqpool->active,
+					camsys_irqstas_t, list);
+				*irqsta = irqstas->sta;
+				list_del_init(&irqstas->list);
+				list_add_tail(
+					&irqstas->list,
+					&irqpool->deactive);
+				spin_unlock_irqrestore(&irqpool->lock, flags);
+			} else {
+				err = -EAGAIN;
+			}
+		} else {
+			camsys_warn(
+				"Thread(pid: %d) has been disconnect!",
+				current->pid);
+			err = -EAGAIN;
+		}
+	}
+
+	if (err == 0) {
+		camsys_trace(3,
+			"Thread(pid: %d) has been wake up for irq(mis: 0x%x ris:0x%x)!",
+			current->pid, irqsta->mis, irqsta->ris);
+	}
 
 end:
-    return err;
+	return err;
 }
 
-static int camsys_irq_disconnect(camsys_irqcnnt_t *irqcnnt, camsys_dev_t *camsys_dev, bool all)
+static int camsys_irq_disconnect(camsys_irqcnnt_t *irqcnnt, camsys_dev_t
+*camsys_dev, bool all)
 {
-    int err = 0;
-    bool find_pool = false;
-    camsys_irqpool_t *irqpool;    
-    unsigned long int flags;
-    
-    if (all == false) {
-        spin_lock_irqsave(&camsys_dev->irq.lock,flags);
-		if (!list_empty(&camsys_dev->irq.irq_pool)) {
-            list_for_each_entry(irqpool, &camsys_dev->irq.irq_pool, list) {
-                if (irqpool->pid == irqcnnt->pid) {
-                    find_pool = true;
-                    irqpool->pid = 0;
-                    break;
-                }
-            }
-        }
-        spin_unlock_irqrestore(&camsys_dev->irq.lock,flags);
-
-        if (find_pool == false) {
-            camsys_err("this thread(pid: %d) have not been connect irq!, disconnect failed",current->pid);         
-        } else {
-            wake_up_all(&irqpool->done);
-        }
-
-        camsys_trace(1, "Thread(pid: %d) disconnect %s irq success!", irqcnnt->pid, dev_name(camsys_dev->miscdev.this_device));
-   } else {
-        spin_lock_irqsave(&camsys_dev->irq.lock,flags);
-        while (!list_empty(&camsys_dev->irq.irq_pool)) {
-            irqpool = list_first_entry(&camsys_dev->irq.irq_pool, camsys_irqpool_t, list);
-            list_del_init(&irqpool->list);
-            irqpool->pid = 0;
-            wake_up_all(&irqpool->done);
-            kfree(irqpool);
-            irqpool = NULL;
-        }
-        spin_unlock_irqrestore(&camsys_dev->irq.lock,flags);
-
-        camsys_trace(1, "All thread disconnect %s irq success!", dev_name(camsys_dev->miscdev.this_device));
-   }
-
-
-    return err;
+	int err = 0;
+	bool find_pool = false;
+	camsys_irqpool_t *irqpool;
+	unsigned long int flags;
+
+	if (all == false) {
+		spin_lock_irqsave(&camsys_dev->irq.lock, flags);
+	if (!list_empty(&camsys_dev->irq.irq_pool)) {
+		list_for_each_entry(irqpool, &camsys_dev->irq.irq_pool, list) {
+			if (irqpool->pid == irqcnnt->pid) {
+				find_pool = true;
+				irqpool->pid = 0;
+				break;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&camsys_dev->irq.lock, flags);
+
+	if (find_pool == false) {
+		camsys_err(
+			"this thread(pid: %d) have not been connect irq!"
+			"disconnect failed",
+			current->pid);
+	} else {
+		wake_up_all(&irqpool->done);
+	}
+
+	camsys_trace(1, "Thread(pid: %d) disconnect %s irq success!",
+		irqcnnt->pid,
+		dev_name(camsys_dev->miscdev.this_device));
+	} else {
+	spin_lock_irqsave(&camsys_dev->irq.lock, flags);
+	while (!list_empty(&camsys_dev->irq.irq_pool)) {
+		irqpool = list_first_entry(&camsys_dev->irq.irq_pool,
+					camsys_irqpool_t, list);
+		list_del_init(&irqpool->list);
+		irqpool->pid = 0;
+		wake_up_all(&irqpool->done);
+		kfree(irqpool);
+		irqpool = NULL;
+	}
+	spin_unlock_irqrestore(&camsys_dev->irq.lock, flags);
+
+	camsys_trace(1, "All thread disconnect %s irq success!",
+		dev_name(camsys_dev->miscdev.this_device));
+	}
+
+	return err;
 }
 
-static int camsys_querymem (camsys_dev_t *camsys_dev,  camsys_querymem_t *qmem)
+static int camsys_querymem(camsys_dev_t *camsys_dev,  camsys_querymem_t *qmem)
 {
-    int err = 0;
-    
-    if (qmem->mem_type == CamSys_Mmap_RegisterMem) {
-        if (camsys_dev->devmems.registermem == NULL) {
-            camsys_err("%s register memory isn't been register!", dev_name(camsys_dev->miscdev.this_device));
-            err = -EINVAL;
-            goto end;
-        }
-
-        qmem->mem_size = camsys_dev->devmems.registermem->size;
-        qmem->mem_offset = CamSys_Mmap_RegisterMem*PAGE_SIZE;
-    } else if (qmem->mem_type == CamSys_Mmap_I2cMem) {
-        if (camsys_dev->devmems.i2cmem== NULL) {
-            camsys_err("%s i2c memory isn't been register!", dev_name(camsys_dev->miscdev.this_device));
-            err = -EINVAL;
-            goto end;
-        }
-
-        qmem->mem_size = camsys_dev->devmems.i2cmem->size;
-        qmem->mem_offset = CamSys_Mmap_I2cMem*PAGE_SIZE;
-    } else {
-        camsys_err("%d memory type have not in %s memory list",qmem->mem_type,dev_name(camsys_dev->miscdev.this_device));
-        err = -EINVAL;
-        goto end;
-    }
-    
-
-    return 0;
-end: 
-    return err;
+	int err = 0;
+
+	if (qmem->mem_type == CamSys_Mmap_RegisterMem) {
+		if (camsys_dev->devmems.registermem == NULL) {
+			camsys_err("%s register memory isn't been register!",
+				dev_name(camsys_dev->miscdev.this_device));
+			err = -EINVAL;
+			goto end;
+		}
+
+		qmem->mem_size = camsys_dev->devmems.registermem->size;
+		qmem->mem_offset = CamSys_Mmap_RegisterMem*PAGE_SIZE;
+	} else if (qmem->mem_type == CamSys_Mmap_I2cMem) {
+		if (camsys_dev->devmems.i2cmem == NULL) {
+			camsys_err("%s i2c memory isn't been register!",
+				dev_name(camsys_dev->miscdev.this_device));
+			err = -EINVAL;
+			goto end;
+		}
+
+		qmem->mem_size = camsys_dev->devmems.i2cmem->size;
+		qmem->mem_offset = CamSys_Mmap_I2cMem*PAGE_SIZE;
+	} else {
+		camsys_err(
+			"%d memory type have not in %s memory list",
+			qmem->mem_type,
+			dev_name(camsys_dev->miscdev.this_device));
+		err = -EINVAL;
+		goto end;
+	}
+
+	return 0;
+end:
+	return err;
 }
 static int camsys_open(struct inode *inode, struct file *file)
 {
-    int err = 0;
-    int minor = iminor(inode);
-    camsys_dev_t *camsys_dev;
-    unsigned int i,phycnt;
-
-    spin_lock(&camsys_devs.lock);
-    list_for_each_entry(camsys_dev, &camsys_devs.devs, list) {
-        if (camsys_dev->miscdev.minor == minor) {
-            file->private_data = (void*)(camsys_dev);
-            break;
-        }
-    }
-    spin_unlock(&camsys_devs.lock);
-
-    //zyc add
-    INIT_LIST_HEAD(&camsys_dev->extdevs.active);
-    
-    if (camsys_dev->mipiphy != NULL) {
-        phycnt = camsys_dev->mipiphy[0].phycnt;
-         
-        for (i=0; i<phycnt; i++) {
-            if (camsys_dev->mipiphy[i].clkin_cb != NULL) {
-                camsys_dev->mipiphy[i].clkin_cb(camsys_dev,1);
-            }
-        }
-    }
-
-    
-    if (file->private_data == NULL) {
-        camsys_err("Cann't find camsys_dev!");
-        err = -ENODEV;
-        goto end;
-    } else {     
-        camsys_trace(1,"%s(%p) is opened!",dev_name(camsys_dev->miscdev.this_device),camsys_dev);
-    }
+	int err = 0;
+	int minor = iminor(inode);
+	camsys_dev_t *camsys_dev;
+	unsigned int i, phycnt;
+
+	spin_lock(&camsys_devs.lock);
+	list_for_each_entry(camsys_dev, &camsys_devs.devs, list) {
+		if (camsys_dev->miscdev.minor == minor) {
+			file->private_data = (void *)(camsys_dev);
+			break;
+		}
+	}
+	spin_unlock(&camsys_devs.lock);
+
+	INIT_LIST_HEAD(&camsys_dev->extdevs.active);
+
+	if (camsys_dev->mipiphy != NULL) {
+		phycnt = camsys_dev->mipiphy[0].phycnt;
+
+		for (i = 0; i < phycnt; i++) {
+			if (camsys_dev->mipiphy[i].clkin_cb != NULL) {
+				camsys_dev->mipiphy[i].clkin_cb(camsys_dev, 1);
+			}
+		}
+	}
+
+
+	if (file->private_data == NULL) {
+		camsys_err("Cann't find camsys_dev!");
+		err = -ENODEV;
+		goto end;
+	} else {
+		camsys_trace(1,
+			"%s(%p) is opened!",
+			dev_name(camsys_dev->miscdev.this_device), camsys_dev);
+	}
 
 end:
-    return err;
+	return err;
 }
 
 static int camsys_release(struct inode *inode, struct file *file)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)file->private_data;
-    unsigned int i,phycnt;
-    
-    camsys_irq_disconnect(NULL,camsys_dev, true);
-
-    if (camsys_dev->mipiphy != NULL) {
-        phycnt = camsys_dev->mipiphy[0].phycnt;
-         
-        for (i=0; i<phycnt; i++) {
-            if (camsys_dev->mipiphy[i].clkin_cb != NULL) {
-                camsys_dev->mipiphy[i].clkin_cb(camsys_dev,0);
-            }
-        }
-    }
-
-    camsys_trace(1,"%s(%p) is closed",dev_name(camsys_dev->miscdev.this_device),camsys_dev);
-
-    return 0;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)file->private_data;
+	unsigned int i, phycnt;
+
+	camsys_irq_disconnect(NULL, camsys_dev, true);
+
+	if (camsys_dev->mipiphy != NULL) {
+		phycnt = camsys_dev->mipiphy[0].phycnt;
+
+		for (i = 0; i < phycnt; i++) {
+			if (camsys_dev->mipiphy[i].clkin_cb != NULL) {
+				camsys_dev->mipiphy[i].clkin_cb(camsys_dev, 0);
+			}
+		}
+	}
+
+	camsys_trace(1,
+		"%s(%p) is closed",
+		dev_name(camsys_dev->miscdev.this_device),
+		camsys_dev);
+
+	return 0;
 }
 
 /*
@@ -770,422 +855,456 @@ static int camsys_release(struct inode *inode, struct file *file)
 */
 
 typedef struct camsys_querymem_s_32 {
-    camsys_mmap_type_t      mem_type;
-    unsigned int           mem_offset;
-
-    unsigned int            mem_size;
+	camsys_mmap_type_t mem_type;
+	unsigned int mem_offset;
+	unsigned int mem_size;
 } camsys_querymem_32_t;
 
-#define CAMSYS_QUREYMEM_32          _IOR(CAMSYS_IOC_MAGIC,  11, camsys_querymem_32_t)
+#define CAMSYS_QUREYMEM_32	\
+	_IOR(CAMSYS_IOC_MAGIC, 11, camsys_querymem_32_t)
 
-static long camsys_ioctl_compat(struct file *filp,unsigned int cmd, unsigned long arg)
+static long camsys_ioctl_compat(struct file *filp, unsigned int cmd, unsigned
+	long arg)
 {
 	long err = 0;
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)filp->private_data; 
-    
-	if (_IOC_TYPE(cmd) != CAMSYS_IOC_MAGIC) { 
-        camsys_err("ioctl type(%c!=%c) is invalidate\n",_IOC_TYPE(cmd),CAMSYS_IOC_MAGIC);
-        err = -ENOTTY;
-        goto end;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)filp->private_data;
+
+	if (_IOC_TYPE(cmd) != CAMSYS_IOC_MAGIC) {
+		camsys_err(
+			"ioctl type(%c!=%c) is invalidate\n",
+			_IOC_TYPE(cmd), CAMSYS_IOC_MAGIC);
+		err = -ENOTTY;
+		goto end;
 	}
 	if (_IOC_NR(cmd) > CAMSYS_IOC_MAXNR) {
-        camsys_err("ioctl index(%d>%d) is invalidate\n",_IOC_NR(cmd),CAMSYS_IOC_MAXNR);
-        err = -ENOTTY;
-        goto end;
+		camsys_err("ioctl index(%d>%d) is invalidate\n",
+			_IOC_NR(cmd), CAMSYS_IOC_MAXNR);
+		err = -ENOTTY;
+		goto end;
 	}
 
-    if (_IOC_DIR(cmd) & _IOC_READ)
-        err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));	
-    else if (_IOC_DIR(cmd) & _IOC_WRITE)
-        err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-
-    if (err) {
-        camsys_err("ioctl(0x%x) operation not permitted for %s",cmd,dev_name(camsys_dev->miscdev.this_device));
-        err = -EFAULT;
-        goto end;
-    }
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(
+			VERIFY_WRITE,
+			(void __user *)arg,
+			 _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(
+			VERIFY_READ,
+			(void __user *)arg,
+			_IOC_SIZE(cmd));
+
+	if (err) {
+		camsys_err(
+			"ioctl(0x%x) operation not permitted for %s",
+			cmd, dev_name(camsys_dev->miscdev.this_device));
+		err = -EFAULT;
+		goto end;
+	}
 
 	switch (cmd) {
 
-	    case CAMSYS_VERCHK:
-	    {
-	        camsys_version_t camsys_ver;
-	        
-            camsys_ver.drv_ver = CAMSYS_DRIVER_VERSION;
-            camsys_ver.head_ver = CAMSYS_HEAD_VERSION;
-            if (copy_to_user((void __user *)arg,(void*)&camsys_ver, sizeof(camsys_version_t)))
-                return -EFAULT;
-            break;
-	    }
-	    case CAMSYS_QUREYIOMMU:
-	    {
-            int iommu_enabled = 0;
-            #ifdef CONFIG_ROCKCHIP_IOMMU
-				struct device_node * vpu_node =NULL;
-				int vpu_iommu_enabled = 0;
-                vpu_node = of_find_node_by_name(NULL, "vpu_service");
-				if(vpu_node){
-					of_property_read_u32(vpu_node, "iommu_enabled", &vpu_iommu_enabled);
-					of_property_read_u32(camsys_dev->pdev->dev.of_node, "rockchip,isp,iommu_enable", &iommu_enabled);
-					of_node_put(vpu_node);
-					if(iommu_enabled != vpu_iommu_enabled){
-						camsys_err("iommu status not consistent,check the dts file ! isp:%d,vpu:%d",iommu_enabled,vpu_iommu_enabled);
-						return -EFAULT;
-					}
-				}
-			#endif
-            if (copy_to_user((void __user *)arg,(void*)&iommu_enabled, sizeof(iommu_enabled)))
-                return -EFAULT;
-            break;
-	    }
-	    case CAMSYS_I2CRD:
-	    {
-	        camsys_i2c_info_t i2cinfo;
-	        
-            if (copy_from_user((void*)&i2cinfo,(void __user *)arg, sizeof(camsys_i2c_info_t))) 
-                return -EFAULT;
-
-            err = camsys_i2c_read(&i2cinfo,camsys_dev);
-            if (err==0) {
-                if (copy_to_user((void __user *)arg,(void*)&i2cinfo, sizeof(camsys_i2c_info_t)))
-                    return -EFAULT;
-            }
-            break;
-	    }
-
-	    case CAMSYS_I2CWR:
-	    {
-            camsys_i2c_info_t i2cinfo;
-	        
-            if (copy_from_user((void*)&i2cinfo,(void __user *)arg, sizeof(camsys_i2c_info_t))) 
-                return -EFAULT;
-
-            err = camsys_i2c_write(&i2cinfo,camsys_dev);
-            break;
-	    }
-
-        case CAMSYS_SYSCTRL:
-        {
-            camsys_sysctrl_t devctl;
-
-            if (copy_from_user((void*)&devctl,(void __user *)arg, sizeof(camsys_sysctrl_t))) 
-                return -EFAULT;
-
-            err = camsys_sysctl(&devctl, camsys_dev);
-            if ((err==0) && (devctl.ops == CamSys_IOMMU)){
-                if (copy_to_user((void __user *)arg,(void*)&devctl, sizeof(camsys_sysctrl_t))) 
-                    return -EFAULT;
-            }
-            break;
-        }
-
-        case CAMSYS_REGRD:
-        {
-
-            break;
-        }
-
-        case CAMSYS_REGWR:
-        {
-
-            break;
-        }
-
-        case CAMSYS_REGISTER_DEVIO:
-        {
-            camsys_devio_name_t devio;
-
-            if (copy_from_user((void*)&devio,(void __user *)arg, sizeof(camsys_devio_name_t))) 
-                return -EFAULT;
-
-            err = camsys_extdev_register(&devio,camsys_dev);
-            break;
-        }
-
-        case CAMSYS_DEREGISTER_DEVIO:
-        {
-            unsigned int dev_id;
-
-            if (copy_from_user((void*)&dev_id,(void __user *)arg, sizeof(unsigned int)))
-                return -EFAULT;
-
-            err = camsys_extdev_deregister(dev_id, camsys_dev, false);
-            break;
-        }
-
-        case CAMSYS_IRQCONNECT:
-        {
-            camsys_irqcnnt_t irqcnnt;
-
-            if (copy_from_user((void*)&irqcnnt,(void __user *)arg, sizeof(camsys_irqcnnt_t))) 
-                return -EFAULT;
-            
-            err = camsys_irq_connect(&irqcnnt, camsys_dev);
-            
-            break;
-        }
-
-        case CAMSYS_IRQWAIT:
-        {
-            camsys_irqsta_t irqsta;
-
-            err = camsys_irq_wait(&irqsta, camsys_dev);
-            if (err==0) {
-                if (copy_to_user((void __user *)arg,(void*)&irqsta, sizeof(camsys_irqsta_t))) 
-                    return -EFAULT;
-            }
-            break;
-        }
-
-        case CAMSYS_IRQDISCONNECT:
-        {
-            camsys_irqcnnt_t irqcnnt;
-
-            if (copy_from_user((void*)&irqcnnt,(void __user *)arg, sizeof(camsys_irqcnnt_t))) 
-                return -EFAULT;
-            err = camsys_irq_disconnect(&irqcnnt,camsys_dev,false);
-			break;
-        }
-
-		case CAMSYS_QUREYMEM_32:
-       	{
-            camsys_querymem_t qmem;
-			camsys_querymem_32_t qmem32;
-
-            if (copy_from_user((void*)&qmem32,(void __user *)arg, sizeof(camsys_querymem_32_t))) 
-                return -EFAULT;
-
-			qmem.mem_type = qmem32.mem_type;
-            err = camsys_querymem(camsys_dev,&qmem);
-            if (err == 0) {
-				qmem32.mem_offset = (unsigned int)qmem.mem_offset;
-				qmem32.mem_size = qmem.mem_size;
-                if (copy_to_user((void __user *)arg,(void*)&qmem32, sizeof(camsys_querymem_32_t))) 
-                    return -EFAULT;
-            }
-            break;
+	case CAMSYS_VERCHK: {
+		camsys_version_t camsys_ver;
+
+		camsys_ver.drv_ver = CAMSYS_DRIVER_VERSION;
+		camsys_ver.head_ver = CAMSYS_HEAD_VERSION;
+		if (copy_to_user((void __user *)arg,
+			(void *)&camsys_ver,
+			sizeof(camsys_version_t)))
+			return -EFAULT;
+	}
+	case CAMSYS_QUREYIOMMU: {
+		int iommu_enabled = 0;
+		struct device_node *vpu_node = NULL;
+		int vpu_iommu_enabled = 0;
+
+		vpu_node = of_find_node_by_name(NULL, "vpu_service");
+		if (vpu_node) {
+			of_property_read_u32(vpu_node,
+				"iommu_enabled", &vpu_iommu_enabled);
+			of_property_read_u32(camsys_dev->pdev->dev.of_node,
+				"rockchip,isp,iommu_enable", &iommu_enabled);
+			of_node_put(vpu_node);
+			if (iommu_enabled != vpu_iommu_enabled) {
+				camsys_err(
+					"iommu status not consistent,"
+					"check the dts file !isp:%d,vpu:%d",
+					iommu_enabled, vpu_iommu_enabled);
+					return -EFAULT;
+			}
+		}
+
+
+		if (copy_to_user((void __user *)arg,
+			(void *)&iommu_enabled,
+			sizeof(iommu_enabled)))
+			return -EFAULT;
+
+		break;
+	}
+	case CAMSYS_I2CRD: {
+		camsys_i2c_info_t i2cinfo;
+
+		if (copy_from_user((void *)&i2cinfo,
+			(void __user *)arg,
+			sizeof(camsys_i2c_info_t)))
+			return -EFAULT;
+
+		err = camsys_i2c_read(&i2cinfo, camsys_dev);
+		if (err == 0) {
+			if (copy_to_user((void __user *)arg, (void *)&i2cinfo,
+				sizeof(camsys_i2c_info_t)))
+				return -EFAULT;
+		}
+		break;
+	}
+
+	case CAMSYS_I2CWR: {
+		camsys_i2c_info_t i2cinfo;
+
+		if (copy_from_user((void *)&i2cinfo, (void __user *)arg,
+			sizeof(camsys_i2c_info_t)))
+			return -EFAULT;
+
+		err = camsys_i2c_write(&i2cinfo, camsys_dev);
+		break;
+	}
+
+	case CAMSYS_SYSCTRL: {
+		camsys_sysctrl_t devctl;
+
+		if (copy_from_user((void *)&devctl, (void __user *)arg,
+			sizeof(camsys_sysctrl_t)))
+			return -EFAULT;
+
+		err = camsys_sysctl(&devctl, camsys_dev);
+		if ((err == 0) && (devctl.ops == CamSys_IOMMU)) {
+			if (copy_to_user((void __user *)arg, (void *)&devctl,
+				sizeof(camsys_sysctrl_t)))
+				return -EFAULT;
+		}
+		break;
+	}
+
+	case CAMSYS_REGRD: {
+		break;
+	}
+
+	case CAMSYS_REGWR: {
+		break;
+	}
+
+	case CAMSYS_REGISTER_DEVIO: {
+		camsys_devio_name_t devio;
+
+		if (copy_from_user((void *)&devio, (void __user *)arg,
+			sizeof(camsys_devio_name_t)))
+			return -EFAULT;
+
+		err = camsys_extdev_register(&devio, camsys_dev);
+		break;
+	}
+
+	case CAMSYS_DEREGISTER_DEVIO: {
+		unsigned int dev_id;
+
+		if (copy_from_user((void *)&dev_id, (void __user *)arg,
+			sizeof(unsigned int)))
+			return -EFAULT;
+
+		err = camsys_extdev_deregister(dev_id, camsys_dev, false);
+		break;
+	}
+
+	case CAMSYS_IRQCONNECT: {
+		camsys_irqcnnt_t irqcnnt;
+
+		if (copy_from_user((void *)&irqcnnt, (void __user *)arg,
+			sizeof(camsys_irqcnnt_t)))
+			return -EFAULT;
+
+		err = camsys_irq_connect(&irqcnnt, camsys_dev);
+
+		break;
+	}
+
+	case CAMSYS_IRQWAIT: {
+		camsys_irqsta_t irqsta;
+
+		err = camsys_irq_wait(&irqsta, camsys_dev);
+		if (err == 0) {
+			if (copy_to_user((void __user *)arg, (void *)&irqsta,
+				sizeof(camsys_irqsta_t)))
+				return -EFAULT;
+		}
+		break;
+	}
+
+	case CAMSYS_IRQDISCONNECT: {
+		camsys_irqcnnt_t irqcnnt;
+
+		if (copy_from_user((void *)&irqcnnt, (void __user *)arg,
+			sizeof(camsys_irqcnnt_t)))
+			return -EFAULT;
+		err = camsys_irq_disconnect(&irqcnnt, camsys_dev, false);
+		break;
+	}
+
+	case CAMSYS_QUREYMEM_32: {
+		camsys_querymem_t qmem;
+		camsys_querymem_32_t qmem32;
+
+		if (copy_from_user((void *)&qmem32, (void __user *)arg,
+			sizeof(camsys_querymem_32_t)))
+			return -EFAULT;
+
+		qmem.mem_type = qmem32.mem_type;
+		err = camsys_querymem(camsys_dev, &qmem);
+		if (err == 0) {
+			qmem32.mem_offset = (unsigned int)qmem.mem_offset;
+			qmem32.mem_size = qmem.mem_size;
+			if (copy_to_user((void __user *)arg, (void *)&qmem32,
+				sizeof(camsys_querymem_32_t)))
+				return -EFAULT;
 		}
-        default :
-            break;
+		break;
+	}
+	default:
+		break;
 	}
 
-end:	
+end:
 	return err;
 
 }
 
-static long camsys_ioctl(struct file *filp,unsigned int cmd, unsigned long arg)
+static long camsys_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	long err = 0;
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)filp->private_data; 
-    
-	if (_IOC_TYPE(cmd) != CAMSYS_IOC_MAGIC) { 
-        camsys_err("ioctl type(%c!=%c) is invalidate\n",_IOC_TYPE(cmd),CAMSYS_IOC_MAGIC);
-        err = -ENOTTY;
-        goto end;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)filp->private_data;
+
+	if (_IOC_TYPE(cmd) != CAMSYS_IOC_MAGIC) {
+		camsys_err("ioctl type(%c!=%c) is invalidate\n",
+			_IOC_TYPE(cmd), CAMSYS_IOC_MAGIC);
+		err = -ENOTTY;
+		goto end;
 	}
 	if (_IOC_NR(cmd) > CAMSYS_IOC_MAXNR) {
-        camsys_err("ioctl index(%d>%d) is invalidate\n",_IOC_NR(cmd),CAMSYS_IOC_MAXNR);
-        err = -ENOTTY;
-        goto end;
+		camsys_err("ioctl index(%d>%d) is invalidate\n",
+			_IOC_NR(cmd), CAMSYS_IOC_MAXNR);
+		err = -ENOTTY;
+		goto end;
 	}
 
-    if (_IOC_DIR(cmd) & _IOC_READ)
-        err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));	
-    else if (_IOC_DIR(cmd) & _IOC_WRITE)
-        err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
-
-    if (err) {
-        camsys_err("ioctl(0x%x) operation not permitted for %s",cmd,dev_name(camsys_dev->miscdev.this_device));
-        err = -EFAULT;
-        goto end;
-    }
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE,
+			(void __user *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ,
+			(void __user *)arg, _IOC_SIZE(cmd));
+
+	if (err) {
+		camsys_err("ioctl(0x%x) operation not permitted for %s",
+			cmd, dev_name(camsys_dev->miscdev.this_device));
+		err = -EFAULT;
+		goto end;
+	}
 
 	switch (cmd) {
+	case CAMSYS_VERCHK: {
+		camsys_version_t camsys_ver;
+
+		camsys_ver.drv_ver = CAMSYS_DRIVER_VERSION;
+		camsys_ver.head_ver = CAMSYS_HEAD_VERSION;
+		if (copy_to_user((void __user *)arg, (void *)&camsys_ver,
+			sizeof(camsys_version_t)))
+			return -EFAULT;
+		break;
+	}
+	case CAMSYS_QUREYIOMMU: {
+		int iommu_enabled = 0;
+		struct device_node *vpu_node = NULL;
+		int vpu_iommu_enabled = 0;
+
+		vpu_node = of_find_node_by_name(NULL, "vpu_service");
+		if (vpu_node) {
+			of_property_read_u32(vpu_node,
+				"iommu_enabled", &vpu_iommu_enabled);
+			of_property_read_u32(camsys_dev->pdev->dev.of_node,
+				"rockchip,isp,iommu_enable", &iommu_enabled);
+			of_node_put(vpu_node);
+			if (iommu_enabled != vpu_iommu_enabled) {
+				camsys_err(
+					"iommu status not consistent,"
+					"check the dts file !isp:%d,vpu:%d",
+					iommu_enabled, vpu_iommu_enabled);
+				return -EFAULT;
+			}
+		}
 
-	    case CAMSYS_VERCHK:
-	    {
-	        camsys_version_t camsys_ver;
-	        
-            camsys_ver.drv_ver = CAMSYS_DRIVER_VERSION;
-            camsys_ver.head_ver = CAMSYS_HEAD_VERSION;
-            if (copy_to_user((void __user *)arg,(void*)&camsys_ver, sizeof(camsys_version_t)))
-                return -EFAULT;
-            break;
-	    }
-	    case CAMSYS_QUREYIOMMU:
-	    {
-            int iommu_enabled = 0;
-            #ifdef CONFIG_ROCKCHIP_IOMMU
-				struct device_node * vpu_node =NULL;
-				int vpu_iommu_enabled = 0;
-                vpu_node = of_find_node_by_name(NULL, "vpu_service");
-				if(vpu_node){
-					of_property_read_u32(vpu_node, "iommu_enabled", &vpu_iommu_enabled);
-					of_property_read_u32(camsys_dev->pdev->dev.of_node, "rockchip,isp,iommu_enable", &iommu_enabled);
-					of_node_put(vpu_node);
-					if(iommu_enabled != vpu_iommu_enabled){
-						camsys_err("iommu status not consistent,check the dts file ! isp:%d,vpu:%d",iommu_enabled,vpu_iommu_enabled);
-						return -EFAULT;
-					}
-				}
-			#endif
-            if (copy_to_user((void __user *)arg,(void*)&iommu_enabled, sizeof(iommu_enabled)))
-                return -EFAULT;
-            break;
-	    }
-	    case CAMSYS_I2CRD:
-	    {
-	        camsys_i2c_info_t i2cinfo;
-	        
-            if (copy_from_user((void*)&i2cinfo,(void __user *)arg, sizeof(camsys_i2c_info_t))) 
-                return -EFAULT;
-
-            err = camsys_i2c_read(&i2cinfo,camsys_dev);
-            if (err==0) {
-                if (copy_to_user((void __user *)arg,(void*)&i2cinfo, sizeof(camsys_i2c_info_t)))
-                    return -EFAULT;
-            }
-            break;
-	    }
-
-	    case CAMSYS_I2CWR:
-	    {
-            camsys_i2c_info_t i2cinfo;
-	        
-            if (copy_from_user((void*)&i2cinfo,(void __user *)arg, sizeof(camsys_i2c_info_t))) 
-                return -EFAULT;
-
-            err = camsys_i2c_write(&i2cinfo,camsys_dev);
-            break;
-	    }
-
-        case CAMSYS_SYSCTRL:
-        {
-            camsys_sysctrl_t devctl;
-
-            if (copy_from_user((void*)&devctl,(void __user *)arg, sizeof(camsys_sysctrl_t))) 
-                return -EFAULT;
-
-            err = camsys_sysctl(&devctl, camsys_dev);
-            if ((err==0) && (devctl.ops == CamSys_IOMMU)){
-                if (copy_to_user((void __user *)arg,(void*)&devctl, sizeof(camsys_sysctrl_t))) 
-                    return -EFAULT;
-            }
-            break;
-        }
-
-        case CAMSYS_REGRD:
-        {
-
-            break;
-        }
-
-        case CAMSYS_REGWR:
-        {
-
-            break;
-        }
-
-        case CAMSYS_REGISTER_DEVIO:
-        {
-            camsys_devio_name_t devio;
-
-            if (copy_from_user((void*)&devio,(void __user *)arg, sizeof(camsys_devio_name_t))) 
-                return -EFAULT;
-
-            err = camsys_extdev_register(&devio,camsys_dev);
-            break;
-        }
-
-        case CAMSYS_DEREGISTER_DEVIO:
-        {
-            unsigned int dev_id;
-
-            if (copy_from_user((void*)&dev_id,(void __user *)arg, sizeof(unsigned int)))
-                return -EFAULT;
-
-            err = camsys_extdev_deregister(dev_id, camsys_dev, false);
-            break;
-        }
-
-        case CAMSYS_IRQCONNECT:
-        {
-            camsys_irqcnnt_t irqcnnt;
-
-            if (copy_from_user((void*)&irqcnnt,(void __user *)arg, sizeof(camsys_irqcnnt_t))) 
-                return -EFAULT;
-            
-            err = camsys_irq_connect(&irqcnnt, camsys_dev);
-            
-            break;
-        }
-
-        case CAMSYS_IRQWAIT:
-        {
-            camsys_irqsta_t irqsta;
-
-            err = camsys_irq_wait(&irqsta, camsys_dev);
-            if (err==0) {
-                if (copy_to_user((void __user *)arg,(void*)&irqsta, sizeof(camsys_irqsta_t))) 
-                    return -EFAULT;
-            }
-            break;
-        }
-
-        case CAMSYS_IRQDISCONNECT:
-        {
-            camsys_irqcnnt_t irqcnnt;
-
-            if (copy_from_user((void*)&irqcnnt,(void __user *)arg, sizeof(camsys_irqcnnt_t))) 
-                return -EFAULT;
-            err = camsys_irq_disconnect(&irqcnnt,camsys_dev,false);
-			break;
-        }
-
-        
-        case CAMSYS_QUREYMEM:
-        {
-            camsys_querymem_t qmem;
-
-            if (copy_from_user((void*)&qmem,(void __user *)arg, sizeof(camsys_querymem_t))) 
-                return -EFAULT;
-            
-            err = camsys_querymem(camsys_dev,&qmem);
-            if (err == 0) {
-                if (copy_to_user((void __user *)arg,(void*)&qmem, sizeof(camsys_querymem_t))) 
-                    return -EFAULT;
-            }
-            break;
-        }
-		
-        default :
-            break;
-	}
-
-end:	
-	return err;
+		if (copy_to_user((void __user *)arg, (void *)&iommu_enabled,
+			sizeof(iommu_enabled)))
+			return -EFAULT;
+		break;
+	}
+	case CAMSYS_I2CRD: {
+		camsys_i2c_info_t i2cinfo;
+
+		if (copy_from_user((void *)&i2cinfo, (void __user *)arg,
+			sizeof(camsys_i2c_info_t)))
+			return -EFAULT;
+
+		err = camsys_i2c_read(&i2cinfo, camsys_dev);
+		if (err == 0) {
+			if (copy_to_user((void __user *)arg, (void *)&i2cinfo,
+				sizeof(camsys_i2c_info_t)))
+				return -EFAULT;
+		}
+		break;
+	}
 
-}
+	case CAMSYS_I2CWR: {
+		camsys_i2c_info_t i2cinfo;
+
+		if (copy_from_user((void *)&i2cinfo, (void __user *)arg,
+			sizeof(camsys_i2c_info_t)))
+			return -EFAULT;
+
+		err = camsys_i2c_write(&i2cinfo, camsys_dev);
+		break;
+	}
+
+	case CAMSYS_SYSCTRL: {
+		camsys_sysctrl_t devctl;
+
+		if (copy_from_user((void *)&devctl, (void __user *)arg,
+			sizeof(camsys_sysctrl_t)))
+			return -EFAULT;
+
+		err = camsys_sysctl(&devctl, camsys_dev);
+		if ((err == 0) && (devctl.ops == CamSys_IOMMU)) {
+			if (copy_to_user((void __user *)arg, (void *)&devctl,
+				sizeof(camsys_sysctrl_t)))
+				return -EFAULT;
+		}
+		break;
+	}
+
+	case CAMSYS_REGRD: {
+
+		break;
+	}
+
+	case CAMSYS_REGWR: {
+
+		break;
+	}
+
+	case CAMSYS_REGISTER_DEVIO:
+	{
+		camsys_devio_name_t devio;
+
+		if (copy_from_user((void *)&devio, (void __user *)arg,
+			sizeof(camsys_devio_name_t)))
+			return -EFAULT;
+
+		err = camsys_extdev_register(&devio, camsys_dev);
+		break;
+	}
+
+	case CAMSYS_DEREGISTER_DEVIO:
+	{
+		unsigned int dev_id;
+
+		if (copy_from_user((void *)&dev_id,
+			(void __user *)arg,
+			sizeof(unsigned int)))
+			return -EFAULT;
+
+		err = camsys_extdev_deregister(dev_id, camsys_dev, false);
+		break;
+	}
+
+	case CAMSYS_IRQCONNECT:
+	{
+		camsys_irqcnnt_t irqcnnt;
+
+		if (copy_from_user((void *)&irqcnnt, (void __user *)arg,
+			sizeof(camsys_irqcnnt_t)))
+			return -EFAULT;
+
+		err = camsys_irq_connect(&irqcnnt, camsys_dev);
 
+		break;
+	}
+
+	case CAMSYS_IRQWAIT:
+	{
+		camsys_irqsta_t irqsta;
+
+		err = camsys_irq_wait(&irqsta, camsys_dev);
+		if (err == 0) {
+			if (copy_to_user((void __user *)arg, (void *)&irqsta,
+				sizeof(camsys_irqsta_t)))
+				return -EFAULT;
+		}
+		break;
+	}
+
+	case CAMSYS_IRQDISCONNECT:
+	{
+		camsys_irqcnnt_t irqcnnt;
 
+		if (copy_from_user((void *)&irqcnnt, (void __user *)arg,
+			sizeof(camsys_irqcnnt_t)))
+			return -EFAULT;
+		err = camsys_irq_disconnect(&irqcnnt, camsys_dev, false);
+		break;
+	}
+
+	case CAMSYS_QUREYMEM:
+	{
+		camsys_querymem_t qmem;
+
+		if (copy_from_user((void *)&qmem, (void __user *)arg,
+			sizeof(camsys_querymem_t)))
+			return -EFAULT;
+
+		err = camsys_querymem(camsys_dev, &qmem);
+		if (err == 0) {
+			if (copy_to_user((void __user *)arg, (void *)&qmem,
+				sizeof(camsys_querymem_t)))
+				return -EFAULT;
+		}
+		break;
+	}
+
+	default:
+		break;
+	}
+
+end:
+	return err;
+
+}
 /*
  * VMA operations.
  */
 static void camsys_vm_open(struct vm_area_struct *vma)
 {
-    camsys_meminfo_t *meminfo = (camsys_meminfo_t*)vma->vm_private_data;
+	camsys_meminfo_t *meminfo = (camsys_meminfo_t *)vma->vm_private_data;
 
-    meminfo->vmas++;
-    return;
+	meminfo->vmas++;
+	return;
 }
 
 static void camsys_vm_close(struct vm_area_struct *vma)
 {
-    camsys_meminfo_t *meminfo = (camsys_meminfo_t*)vma->vm_private_data;
+	camsys_meminfo_t *meminfo = (camsys_meminfo_t *)vma->vm_private_data;
 
-    meminfo->vmas--;
-    return;
+	meminfo->vmas--;
+	return;
 }
 
 static const struct vm_operations_struct camsys_vm_ops = {
@@ -1195,354 +1314,378 @@ static const struct vm_operations_struct camsys_vm_ops = {
 
 int camsys_mmap(struct file *flip, struct vm_area_struct *vma)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)flip->private_data;
-	unsigned long addr, start, size;    
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)flip->private_data;
+	unsigned long addr, start, size;
 	camsys_mmap_type_t mem_type;
-	camsys_meminfo_t *meminfo;		
+	camsys_meminfo_t *meminfo;
 	int ret = 0;
 
-    mem_type = vma->vm_pgoff;     
-    
-    if (mem_type == CamSys_Mmap_RegisterMem) {
-        if (camsys_dev->devmems.registermem != NULL) {
-            meminfo = camsys_dev->devmems.registermem;
-        } else {
-            camsys_err("this camsys device has not register mem!");
-            ret = -EINVAL;
-            goto done;
-        }
-    } else if (mem_type == CamSys_Mmap_I2cMem) {
-        if (camsys_dev->devmems.i2cmem != NULL) {
-            meminfo = camsys_dev->devmems.i2cmem;
-        } else {
-            camsys_err("this camsys device has not i2c mem!");
-            ret = -EINVAL;
-            goto done;
-        }
-    } else {
-        camsys_err("mmap buffer type %d is invalidate!",mem_type);
-        ret = -EINVAL;
-        goto done;
-    }
-    
-    size = vma->vm_end - vma->vm_start;
-    if (size > meminfo->size) {
-        ret = -ENOMEM;
-        camsys_err("mmap size(0x%lx) > memory size(0x%x), so failed!",size,meminfo->size);
-        goto done;
-    }
-    
+	mem_type = vma->vm_pgoff;
+
+	if (mem_type == CamSys_Mmap_RegisterMem) {
+		if (camsys_dev->devmems.registermem != NULL) {
+			meminfo = camsys_dev->devmems.registermem;
+		} else {
+			camsys_err("this camsys device has not register mem!");
+			ret = -EINVAL;
+			goto done;
+		}
+	} else if (mem_type == CamSys_Mmap_I2cMem) {
+		if (camsys_dev->devmems.i2cmem != NULL) {
+			meminfo = camsys_dev->devmems.i2cmem;
+		} else {
+			camsys_err("this camsys device has not i2c mem!");
+			ret = -EINVAL;
+			goto done;
+		}
+	} else {
+		camsys_err("mmap buffer type %d is invalidate!", mem_type);
+		ret = -EINVAL;
+		goto done;
+	}
+
+	size = vma->vm_end - vma->vm_start;
+	if (size > meminfo->size) {
+		ret = -ENOMEM;
+		camsys_err(
+			"mmap size(0x%lx) > memory size(0x%x), so failed!",
+			size, meminfo->size);
+		goto done;
+	}
+
 	start = vma->vm_start;
-	addr = __phys_to_pfn(meminfo->phy_base);    
-	
-    if (remap_pfn_range(vma, start, addr,size,pgprot_noncached(vma->vm_page_prot))) { 
-        
-        ret = -EAGAIN;
-        goto done;
-    }
-    
-    vma->vm_ops = &camsys_vm_ops;
-    vma->vm_flags |= VM_IO;
-    vma->vm_flags |=VM_ACCOUNT;//same as VM_RESERVED;
-    vma->vm_private_data = (void*)meminfo;
-    camsys_vm_open(vma);
+	addr = __phys_to_pfn(meminfo->phy_base);
+
+	if (remap_pfn_range(vma, start,
+		addr, size, pgprot_noncached(vma->vm_page_prot))) {
+		ret = -EAGAIN;
+		goto done;
+	}
+
+	vma->vm_ops = &camsys_vm_ops;
+	vma->vm_flags |= VM_IO;
+	vma->vm_flags |= VM_ACCOUNT;
+	vma->vm_private_data = (void *)meminfo;
+	camsys_vm_open(vma);
 
 done:
 	return ret;
 }
 
 struct file_operations camsys_fops = {
-	.owner =            THIS_MODULE,
-    .open =             camsys_open,
-    .release =          camsys_release,
+	.owner =			THIS_MODULE,
+	.open =			 camsys_open,
+	.release =		  camsys_release,
 	.unlocked_ioctl =   camsys_ioctl,
-	.mmap =             camsys_mmap,
+	.mmap =			 camsys_mmap,
 	.compat_ioctl = camsys_ioctl_compat,
 };
 
-static int camsys_platform_probe(struct platform_device *pdev){
-    int err = 0;
+static int camsys_platform_probe(struct platform_device *pdev)
+{
+	int err = 0;
 	camsys_dev_t *camsys_dev;
-    struct resource register_res ;
-    struct device *dev = &pdev->dev;
-    unsigned long i2cmem;
+	struct resource register_res;
+	struct device *dev = &pdev->dev;
+	unsigned long i2cmem;
 	camsys_meminfo_t *meminfo;
-    unsigned int irq_id;
-    
-    err = of_address_to_resource(dev->of_node, 0, &register_res);
-    if (err < 0){
-        camsys_err("Get register resource from %s platform device failed!",pdev->name);
-        err = -ENODEV;
-        goto fail_end;
-    }
-
-    //map irqs
-    irq_id = irq_of_parse_and_map(dev->of_node, 0);
-    if (irq_id < 0) {
-        camsys_err("Get irq resource from %s platform device failed!",pdev->name);
-        err = -ENODEV;
-        goto fail_end;
-    }
-
-    camsys_dev = (camsys_dev_t*)devm_kzalloc(&pdev->dev,sizeof(camsys_dev_t), GFP_KERNEL);
-    if (camsys_dev == NULL) {
-        camsys_err("Allocate camsys_dev for %s platform device failed",pdev->name);
-        err = -ENOMEM;
-        goto fail_end;
-    }
-
-    //spin_lock_init(&camsys_dev->lock);
-    mutex_init(&camsys_dev->extdevs.mut);
-    INIT_LIST_HEAD(&camsys_dev->extdevs.list);
-    INIT_LIST_HEAD(&camsys_dev->extdevs.active);
-    INIT_LIST_HEAD(&camsys_dev->list);
-    
-
-    //IRQ init
-    camsys_dev->irq.irq_id = irq_id;  
-    spin_lock_init(&camsys_dev->irq.lock);
-    INIT_LIST_HEAD(&camsys_dev->irq.irq_pool); 
-    //init_waitqueue_head(&camsys_dev->irq.irq_done);
-    
-    INIT_LIST_HEAD(&camsys_dev->devmems.memslist);
-
-    // get soc operation
-    camsys_dev->soc = (void*)camsys_soc_get();
-    if (camsys_dev->soc == NULL) {
-        err = -ENODEV;
-        goto fail_end;
-    }
-
-    //Register mem init
-    meminfo = kzalloc(sizeof(camsys_meminfo_t),GFP_KERNEL);
-    if (meminfo == NULL) {
-        err = -ENOMEM;
-        goto request_mem_fail;
-    }
-
-    meminfo->vir_base = (unsigned long)devm_ioremap_resource(dev, &register_res);
-    if (!meminfo->vir_base){
-        camsys_err("%s ioremap %s failed",dev_name(&pdev->dev), CAMSYS_REGISTER_MEM_NAME);
-        err = -ENXIO;
-        goto request_mem_fail;
-    }
-	rk_isp_base = meminfo->vir_base;
-    strlcpy(meminfo->name, CAMSYS_REGISTER_MEM_NAME,sizeof(meminfo->name));
-    meminfo->phy_base = register_res.start;
-    meminfo->size = register_res.end - register_res.start + 1;  
-    list_add_tail(&meminfo->list, &camsys_dev->devmems.memslist);
-
-
-    //I2c mem init
-    i2cmem = __get_free_page(GFP_KERNEL);
-    if (i2cmem == 0) {
-        camsys_err("Allocate i2cmem failed!");
-        err = -ENOMEM;
-        goto request_mem_fail;
-    }
-    SetPageReserved(virt_to_page(i2cmem));
-    
-    meminfo = kzalloc(sizeof(camsys_meminfo_t),GFP_KERNEL);
-    if (meminfo == NULL) {
-        err = -ENOMEM;
-        goto request_mem_fail;
-    }
-    strlcpy(meminfo->name,CAMSYS_I2C_MEM_NAME,sizeof(meminfo->name));
-    meminfo->vir_base = i2cmem;
-    meminfo->phy_base = virt_to_phys((void*)i2cmem);
-    meminfo->size = PAGE_SIZE;
-    list_add_tail(&meminfo->list, &camsys_dev->devmems.memslist);
-
-    {
-        unsigned int *tmpp;
-
-        tmpp = (unsigned int*)meminfo->vir_base;
-        *tmpp = 0xfa561243;
-    }
-
-    //Special init
-
-    {        
-        if (camsys_mipiphy_probe_cb(pdev, camsys_dev) <0) {
-            camsys_err("Mipi phy probe failed!");
-        }
-    }
-
-#if 0
-    if (strcmp(dev_name(&pdev->dev),CAMSYS_PLATFORM_MARVIN_NAME) == 0) {
-        #if (defined(CONFIG_CAMSYS_MRV))
-        camsys_mrv_probe_cb(pdev, camsys_dev);        
-        #else
-        camsys_err("Marvin controller camsys driver haven't been complie!!!");
-        #endif
-    } else {
-        #if (defined(CONFIG_CAMSYS_CIF))
-        camsys_cif_probe_cb(pdev,camsys_dev);
-        #else
-        camsys_err("CIF controller camsys driver haven't been complie!!!");
-        #endif
-    }
-#else
-        #if (defined(CONFIG_CAMSYS_MRV))
-        camsys_mrv_probe_cb(pdev, camsys_dev);        
-        #elif (defined(CONFIG_CAMSYS_CIF))
-        camsys_cif_probe_cb(pdev,camsys_dev);
-        #else
-        camsys_err("camsys driver haven't been complie!!!");
-        #endif
-#endif
-    camsys_trace(1, "%s memory:",dev_name(&pdev->dev));
-    list_for_each_entry(meminfo, &camsys_dev->devmems.memslist, list) {
-        if (strcmp(meminfo->name,CAMSYS_I2C_MEM_NAME) == 0) {
-            camsys_dev->devmems.i2cmem = meminfo;
-            camsys_trace(1,"    I2c memory (phy: 0x%lx vir: 0x%lx size: 0x%x)",
-                        meminfo->phy_base,meminfo->vir_base,meminfo->size);
-        }
-        if (strcmp(meminfo->name,CAMSYS_REGISTER_MEM_NAME) == 0) {
-            camsys_dev->devmems.registermem = meminfo;
-            camsys_trace(1,"    Register memory (phy: 0x%lx vir: 0x%lx size: 0x%x)",
-                        meminfo->phy_base,meminfo->vir_base,meminfo->size);
-        }
-    }
-
-
-    camsys_dev->phy_cb = camsys_phy_ops;
-    camsys_dev->pdev    =   pdev;
-
-    platform_set_drvdata(pdev,(void*)camsys_dev);
-    //Camsys_devs list add    
-    spin_lock(&camsys_devs.lock);    
-    list_add_tail(&camsys_dev->list, &camsys_devs.devs);
-    spin_unlock(&camsys_devs.lock);
-
-    camsys_init_ext_fsh_module();  
-    camsys_trace(1, "Probe %s device success ", dev_name(&pdev->dev));
-    return 0;
+	unsigned int irq_id;
+	const char *compatible = NULL;
+
+	err = of_property_read_string(dev->of_node, "compatible", &compatible);
+	if (err < 0) {
+		camsys_err("get compatible failed!");
+	} else {
+		camsys_trace(1, "compatible is %s\n", compatible);
+	}
+	if (strstr(compatible, "rk3368"))
+		CHIP_TYPE = 3368;
+	else if (strstr(compatible, "rk3288"))
+		CHIP_TYPE = 3288;
+	else if (strstr(compatible, "rk3366"))
+		CHIP_TYPE = 3366;
+	else if (strstr(compatible, "rk3399"))
+		CHIP_TYPE = 3399;
+
+	camsys_soc_init(CHIP_TYPE);
+
+	err = of_address_to_resource(dev->of_node, 0, &register_res);
+	if (err < 0) {
+		camsys_err(
+			"Get register resource from %s platform device failed!",
+			pdev->name);
+		err = -ENODEV;
+		goto fail_end;
+	}
+
+	/* map irqs */
+	irq_id = irq_of_parse_and_map(dev->of_node, 0);
+	if (irq_id < 0) {
+		camsys_err("Get irq resource from %s platform device failed!",
+			pdev->name);
+		err = -ENODEV;
+		goto fail_end;
+	}
+
+	camsys_dev = (camsys_dev_t *)devm_kzalloc(&pdev->dev,
+		sizeof(camsys_dev_t),
+		GFP_KERNEL);
+	if (camsys_dev == NULL) {
+		camsys_err("Allocate camsys_dev for %s platform device failed",
+			pdev->name);
+		err = -ENOMEM;
+		goto fail_end;
+	}
+
+	/* spin_lock_init(&camsys_dev->lock); */
+	mutex_init(&camsys_dev->extdevs.mut);
+	INIT_LIST_HEAD(&camsys_dev->extdevs.list);
+	INIT_LIST_HEAD(&camsys_dev->extdevs.active);
+	INIT_LIST_HEAD(&camsys_dev->list);
+
+	/* IRQ init */
+	camsys_dev->irq.irq_id = irq_id;
+	spin_lock_init(&camsys_dev->irq.lock);
+	INIT_LIST_HEAD(&camsys_dev->irq.irq_pool);
+	/* init_waitqueue_head(&camsys_dev->irq.irq_done); */
+
+	INIT_LIST_HEAD(&camsys_dev->devmems.memslist);
+
+	/* get soc operation */
+	camsys_dev->soc = (void *)camsys_soc_get();
+	if (camsys_dev->soc == NULL) {
+		err = -ENODEV;
+		goto fail_end;
+	}
+
+	/* Register mem init */
+	meminfo = kzalloc(sizeof(camsys_meminfo_t), GFP_KERNEL);
+	if (meminfo == NULL) {
+		err = -ENOMEM;
+		goto request_mem_fail;
+	}
+
+	meminfo->vir_base =
+		(unsigned long)devm_ioremap_resource(dev, &register_res);
+	if (!meminfo->vir_base) {
+		camsys_err("%s ioremap %s failed",
+			dev_name(&pdev->dev),
+			CAMSYS_REGISTER_MEM_NAME);
+		err = -ENXIO;
+		goto request_mem_fail;
+	}
+	camsys_dev->rk_isp_base = meminfo->vir_base;
+
+	strlcpy(meminfo->name, CAMSYS_REGISTER_MEM_NAME, sizeof(meminfo->name));
+	meminfo->phy_base = register_res.start;
+	meminfo->size = register_res.end - register_res.start + 1;
+	list_add_tail(&meminfo->list, &camsys_dev->devmems.memslist);
+
+	/* I2c mem init */
+	i2cmem = __get_free_page(GFP_KERNEL);
+	if (i2cmem == 0) {
+		camsys_err("Allocate i2cmem failed!");
+		err = -ENOMEM;
+		goto request_mem_fail;
+	}
+	SetPageReserved(virt_to_page(i2cmem));
+
+	meminfo = kzalloc(sizeof(camsys_meminfo_t), GFP_KERNEL);
+	if (meminfo == NULL) {
+		err = -ENOMEM;
+		goto request_mem_fail;
+	}
+	strlcpy(meminfo->name, CAMSYS_I2C_MEM_NAME, sizeof(meminfo->name));
+	meminfo->vir_base = i2cmem;
+	meminfo->phy_base = virt_to_phys((void *)i2cmem);
+	meminfo->size = PAGE_SIZE;
+	list_add_tail(&meminfo->list, &camsys_dev->devmems.memslist);
+
+	{
+		unsigned int *tmpp;
+
+		tmpp = (unsigned int *)meminfo->vir_base;
+		*tmpp = 0xfa561243;
+	}
+
+	/* Special init */
+	{
+		if (camsys_mipiphy_probe_cb(pdev, camsys_dev) < 0) {
+			camsys_err("Mipi phy probe failed!");
+		}
+	}
+
+	#if (defined(CONFIG_CAMSYS_MRV))
+	camsys_mrv_probe_cb(pdev, camsys_dev);
+	#elif (defined(CONFIG_CAMSYS_CIF))
+	camsys_cif_probe_cb(pdev, camsys_dev);
+	#else
+	camsys_err("camsys driver haven't been complie!!!");
+	#endif
+
+	camsys_trace(1,
+		"%s memory:", dev_name(&pdev->dev));
+	list_for_each_entry(meminfo, &camsys_dev->devmems.memslist, list) {
+		if (strcmp(meminfo->name, CAMSYS_I2C_MEM_NAME) == 0) {
+			camsys_dev->devmems.i2cmem = meminfo;
+			camsys_trace(1,
+				"	I2c memory (phy: 0x%lx vir: 0x%lx size: 0x%x)",
+				meminfo->phy_base,
+				meminfo->vir_base,
+				meminfo->size);
+		}
+		if (strcmp(meminfo->name, CAMSYS_REGISTER_MEM_NAME) == 0) {
+			camsys_dev->devmems.registermem = meminfo;
+			camsys_trace(1,
+				"	Register memory (phy: 0x%lx vir: 0x%lx size: 0x%x)",
+				meminfo->phy_base,
+				meminfo->vir_base,
+				meminfo->size);
+		}
+	}
+
+	camsys_dev->phy_cb = camsys_phy_ops;
+	camsys_dev->pdev	=   pdev;
+
+	platform_set_drvdata(pdev, (void *)camsys_dev);
+	/* Camsys_devs list add */
+	spin_lock(&camsys_devs.lock);
+	list_add_tail(&camsys_dev->list, &camsys_devs.devs);
+	spin_unlock(&camsys_devs.lock);
+
+	camsys_init_ext_fsh_module();
+	camsys_trace(1, "Probe %s device success ", dev_name(&pdev->dev));
+	return 0;
 request_mem_fail:
-    if (camsys_dev != NULL) {
-    
-        while(!list_empty(&camsys_dev->devmems.memslist)) {
-            meminfo = list_first_entry(&camsys_dev->devmems.memslist, camsys_meminfo_t, list);
-            if (meminfo) {
-                list_del_init(&meminfo->list);
-                if (strcmp(meminfo->name,CAMSYS_REGISTER_MEM_NAME)==0) {
-                    iounmap((void __iomem *)meminfo->vir_base);
-                    release_mem_region(meminfo->phy_base,meminfo->size);
-                } else if (strcmp(meminfo->name,CAMSYS_I2C_MEM_NAME)==0) {
-                    kfree((void*)meminfo->vir_base);
-                }
-                kfree(meminfo);
-                meminfo = NULL;
-            }
-        } 
-    
-        kfree(camsys_dev);
-        camsys_dev = NULL;
-    }
-fail_end:
-    return -1;
+	if (camsys_dev != NULL) {
+		while (!list_empty(&camsys_dev->devmems.memslist)) {
+			meminfo = list_first_entry(
+				&camsys_dev->devmems.memslist,
+				camsys_meminfo_t, list);
+			if (!meminfo)
+				continue;
+
+			list_del_init(&meminfo->list);
+			if (strcmp(meminfo->name,
+				CAMSYS_REGISTER_MEM_NAME) == 0) {
+				iounmap((void __iomem *)meminfo->vir_base);
+				release_mem_region(
+					meminfo->phy_base,
+					meminfo->size);
+			} else if (strcmp(meminfo->name,
+				CAMSYS_I2C_MEM_NAME) == 0) {
+				kfree((void *)meminfo->vir_base);
+			}
+			kfree(meminfo);
+			meminfo = NULL;
+		}
 
-    
+		kfree(camsys_dev);
+		camsys_dev = NULL;
+	}
+fail_end:
+	return -1;
 }
 static int  camsys_platform_remove(struct platform_device *pdev)
 {
-    camsys_dev_t *camsys_dev = platform_get_drvdata(pdev);
-    camsys_meminfo_t *meminfo;
-    
-    if (camsys_dev) {
-
-        //Mem deinit
-        while(!list_empty(&camsys_dev->devmems.memslist)) {
-            meminfo = list_first_entry(&camsys_dev->devmems.memslist, camsys_meminfo_t, list);
-            if (meminfo) {
-                list_del_init(&meminfo->list);
-                if (strcmp(meminfo->name,CAMSYS_REGISTER_MEM_NAME)==0) {
-                    iounmap((void __iomem *)meminfo->vir_base);
-                    release_mem_region(meminfo->phy_base,meminfo->size);
-                } else if (strcmp(meminfo->name,CAMSYS_I2C_MEM_NAME)==0) {
-                    kfree((void*)meminfo->vir_base);
-                }
-                kfree(meminfo);
-                meminfo = NULL;
-            }
-        }        
-
-        //Irq deinit
-        if (camsys_dev->irq.irq_id) {
-            free_irq(camsys_dev->irq.irq_id, camsys_dev);
-            camsys_irq_disconnect(NULL,camsys_dev,true);
-        }
-
-        //Extdev deinit
-        if (!list_empty(&camsys_dev->extdevs.list)) {
-            camsys_extdev_deregister(0,camsys_dev,true);
-        }
-        if (camsys_dev->mipiphy != NULL) {
-            camsys_dev->mipiphy->remove(pdev);
-        }
-        if (camsys_dev->cifphy.remove)
-            camsys_dev->cifphy.remove(pdev);
-        camsys_dev->platform_remove(pdev);
-
-        misc_deregister(&camsys_dev->miscdev);
-        
-        spin_lock(&camsys_devs.lock);
-        list_del_init(&camsys_dev->list);
-        spin_unlock(&camsys_devs.lock);
-
-        camsys_deinit_ext_fsh_module();
-
-        kfree(camsys_dev);
-        camsys_dev=NULL;
-    } else {
-        camsys_err("This platform device havn't obtain camsys_dev!");
-    }
-
-    return 0;
+	camsys_dev_t *camsys_dev = platform_get_drvdata(pdev);
+	camsys_meminfo_t *meminfo;
+
+	if (camsys_dev) {
+		while (!list_empty(&camsys_dev->devmems.memslist)) {
+			meminfo = list_first_entry(
+				&camsys_dev->devmems.memslist,
+				camsys_meminfo_t, list);
+			if (meminfo)
+				continue;
+
+			list_del_init(&meminfo->list);
+			if (strcmp(meminfo->name,
+				CAMSYS_REGISTER_MEM_NAME) == 0) {
+				iounmap((void __iomem *)meminfo->vir_base);
+				release_mem_region(meminfo->phy_base,
+					meminfo->size);
+			} else if (strcmp(meminfo->name,
+				CAMSYS_I2C_MEM_NAME) == 0) {
+				kfree((void *)meminfo->vir_base);
+			}
+			kfree(meminfo);
+			meminfo = NULL;
+		}
+		if (camsys_dev->irq.irq_id) {
+			free_irq(camsys_dev->irq.irq_id, camsys_dev);
+			camsys_irq_disconnect(NULL, camsys_dev, true);
+		}
+
+		if (!list_empty(&camsys_dev->extdevs.list)) {
+			camsys_extdev_deregister(0, camsys_dev, true);
+		}
+		if (camsys_dev->mipiphy != NULL) {
+			camsys_dev->mipiphy->remove(pdev);
+		}
+		if (camsys_dev->cifphy.remove)
+			camsys_dev->cifphy.remove(pdev);
+		camsys_dev->platform_remove(pdev);
+
+		misc_deregister(&camsys_dev->miscdev);
+
+		spin_lock(&camsys_devs.lock);
+		list_del_init(&camsys_dev->list);
+		spin_unlock(&camsys_devs.lock);
+
+		camsys_deinit_ext_fsh_module();
+
+		kfree(camsys_dev);
+		camsys_dev = NULL;
+	} else {
+		camsys_err("This platform device havn't obtain camsys_dev!");
+	}
+
+	return 0;
 }
 
 
 static const struct of_device_id cif_of_match[] = {
-    { .compatible = "rockchip,isp" },
+	{ .compatible = "rockchip,isp" },
 };
 MODULE_DEVICE_TABLE(of, cif_of_match);
 
-static struct platform_driver camsys_platform_driver =
-{
-    .driver 	= {
-        .name	= CAMSYS_PLATFORM_DRV_NAME,
-        .of_match_table = of_match_ptr(cif_of_match),
-    },
-    .probe		= camsys_platform_probe,
-    .remove		= (camsys_platform_remove),
+static struct platform_driver camsys_platform_driver = {
+	.driver = {
+		.name = CAMSYS_PLATFORM_DRV_NAME,
+		.of_match_table = of_match_ptr(cif_of_match),
+	},
+	.probe = camsys_platform_probe,
+	.remove = (camsys_platform_remove),
 };
 
 MODULE_ALIAS(CAMSYS_PLATFORM_DRV_NAME);
-static int __init camsys_platform_init(void)  
+static int __init camsys_platform_init(void)
 {
-    printk("CamSys driver version: v%d.%d.%d,  CamSys head file version: v%d.%d.%d\n",
-        (CAMSYS_DRIVER_VERSION&0xff0000)>>16, (CAMSYS_DRIVER_VERSION&0xff00)>>8,
-        CAMSYS_DRIVER_VERSION&0xff,
-        (CAMSYS_HEAD_VERSION&0xff0000)>>16, (CAMSYS_HEAD_VERSION&0xff00)>>8,
-        CAMSYS_HEAD_VERSION&0xff);
-
-    spin_lock_init(&camsys_devs.lock);
-    INIT_LIST_HEAD(&camsys_devs.devs);
-    camsys_soc_init();
-    platform_driver_register(&camsys_platform_driver);
-   // platform_driver_probe(&camsys_platform_driver, camsys_platform_probe_new);
-    
-    return 0;
-}  
-  
-static void __exit camsys_platform_exit(void)  
+	printk("CamSys driver version: v%d.%d.%d, "
+		"CamSys head file version: v%d.%d.%d\n",
+		(CAMSYS_DRIVER_VERSION&0xff0000) >> 16,
+		(CAMSYS_DRIVER_VERSION&0xff00) >> 8,
+		CAMSYS_DRIVER_VERSION&0xff,
+		(CAMSYS_HEAD_VERSION&0xff0000) >> 16,
+		(CAMSYS_HEAD_VERSION&0xff00) >> 8,
+		CAMSYS_HEAD_VERSION&0xff);
+
+	spin_lock_init(&camsys_devs.lock);
+	INIT_LIST_HEAD(&camsys_devs.devs);
+	platform_driver_register(&camsys_platform_driver);
+
+	return 0;
+}
+
+static void __exit camsys_platform_exit(void)
 {
-    platform_driver_unregister(&camsys_platform_driver);
-    camsys_soc_deinit();
-} 
+	platform_driver_unregister(&camsys_platform_driver);
+	camsys_soc_deinit();
+}
 
-module_init(camsys_platform_init);		
-module_exit(camsys_platform_exit);	
+module_init(camsys_platform_init);
+module_exit(camsys_platform_exit);
 
 MODULE_DESCRIPTION("RockChip Camera System");
 MODULE_AUTHOR("<ddl@rock-chips>");
diff --git a/drivers/media/video/rk_camsys/camsys_gpio.h b/drivers/media/video/rk_camsys/camsys_gpio.h
index fb49b8155af6..88602af39e99 100755
--- a/drivers/media/video/rk_camsys/camsys_gpio.h
+++ b/drivers/media/video/rk_camsys/camsys_gpio.h
@@ -9,8 +9,8 @@
 
 static inline unsigned int camsys_gpio_group_pin(unsigned char *io_name)
 {
-	unsigned char *pin_char;
-	unsigned char pin;
+	char *pin_char = NULL;
+	int pin = -1;
 
 	if (strstr(io_name, "PA")) {
 		pin_char = strstr(io_name, "PA");
@@ -37,7 +37,7 @@ static inline unsigned int camsys_gpio_group_pin(unsigned char *io_name)
 
 static inline unsigned int camsys_gpio_group(unsigned char *io_name)
 {
-	unsigned int group;
+	unsigned int group = 0;
 
 	if (strstr(io_name, "PIN0"))
 		group = 0;
@@ -62,29 +62,22 @@ static inline unsigned int camsys_gpio_group(unsigned char *io_name)
 
 static inline unsigned int camsys_gpio_get(unsigned char *io_name)
 {
-	unsigned int gpio;
-	unsigned int group;
-	unsigned int group_pin;
+	unsigned int gpio = 0;
+	unsigned int group = 0;
+	int group_pin = 0;
 #if (defined(CONFIG_ARCH_RK3066B) || defined(CONFIG_ARCH_RK3188) ||\
 		defined(CONFIG_ARCH_RK319X) || defined(CONFIG_ARCH_ROCKCHIP))
 	if (strstr(io_name, "RK30_")) {
 		gpio = RK30_PIN0_PA0;
 		group = camsys_gpio_group(io_name);
 		group_pin = camsys_gpio_group_pin(io_name);
-		if (group >= GPIO_BANKS) {
+		if (group_pin == -1)
 			gpio = 0xffffffff;
-		} else {
-			if (cpu_is_rk3288()) {
-				/* bank 0 only has 24 pins ,not 32 pins */
-				if (group > 0) {
-					gpio += 24 + (group - 1) * NUM_GROUP
-							+ group_pin;
-				} else {
-					gpio += group_pin;
-				}
-			} else {
+		else {
+			if (group >= GPIO_BANKS)
+				gpio = 0xffffffff;
+			else
 				gpio += group * NUM_GROUP + group_pin;
-			}
 		}
 	}
 #endif
diff --git a/drivers/media/video/rk_camsys/camsys_internal.h b/drivers/media/video/rk_camsys/camsys_internal.h
index 4154acf7ba4f..b77949f4d520 100755
--- a/drivers/media/video/rk_camsys/camsys_internal.h
+++ b/drivers/media/video/rk_camsys/camsys_internal.h
@@ -6,21 +6,21 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/device.h>
-#include <linux/kernel.h>	
+#include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/io.h>
-#include <linux/fs.h>	
+#include <linux/fs.h>
 #include <linux/interrupt.h>
 #include <linux/errno.h>
 #include <linux/err.h>
-#include <linux/types.h>	
+#include <linux/types.h>
 #include <linux/proc_fs.h>
-#include <linux/fcntl.h>	
+#include <linux/fcntl.h>
 #include <linux/clk.h>
 #include <linux/seq_file.h>
 #include <linux/cdev.h>
-#include <linux/miscdevice.h> 
+#include <linux/miscdevice.h>
 #include <linux/version.h>
 #include <linux/device.h>
 #include <linux/platform_device.h>
@@ -29,17 +29,10 @@
 #include <linux/regulator/machine.h>
 #include <linux/log2.h>
 #include <linux/gpio.h>
-//#include <mach/io.h>
-//#include <mach/gpio.h>
-//#include <mach/iomux.h>
-//#include <mach/cru.h>
 #include <linux/rockchip/cpu.h>
 #include <linux/rockchip/iomap.h>
 #include <linux/rockchip/grf.h>
-//#include <asm/gpio.h>
-//#include <asm/system.h>	
 #include <asm/uaccess.h>
-
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/pinctrl/consumer.h>
@@ -50,10 +43,8 @@
 #include <media/camsys_head.h>
 #include <linux/rockchip-iovmm.h>
 
-
-
 /*
-*               C A M S Y S   D R I V E R   V E R S I O N 
+*               C A M S Y S   D R I V E R   V E R S I O N
 *
 *v0.0.1:
 *        1) test version;
@@ -68,16 +59,19 @@
 *v0.0.6:
 *        1) iomux d0 d1 for cif phy raw10 in rk319x after i2c operated;
 *        2) check mis value in camsys_irq_connect;
-*        3) add soft rest callback;
+		3) add soft rest callback;
 *v0.7.0:
-*        1) check extdev is activate or not before delete from camsys_dev active list;
+		1) check extdev is activate or not before delete from
+		camsys_dev active list;
 *v0.8.0:
-*        1) fix deregister a unregister extdev oops in camsys_extdev_deregister;
+		1) fix deregister a unregister extdev oops
+		in camsys_extdev_deregister;
 *v0.9.0: 1) set isp freq to 210M
 *v0.a.0: 
-*        1) fix camsys_i2c_write and camsys_i2c_write can't support reg_size=0;
+		1) fix camsys_i2c_write and camsys_i2c_write
+		can't support reg_size=0;
 *v0.b.0:
-		 1) control ddr freq by marvin self other than by clk unit. 
+		1) control ddr freq by marvin self other than by clk unit.
 *v0.c.0:
 *        1) add flash_trigger_out control
 *v0.d.0:
@@ -85,49 +79,63 @@
 *v0.e.0:
 *        1) isp_clk 208.8M for 1lane, isp_clk 416.6M for 2lane;
 *v0.f.0:
-		 1) mi_mis register may read erro, this may cause mistaken mi frame_end irqs.  
+		1) mi_mis register may read erro, this may cause
+		mistaken mi frame_end irqs.
 *v0.0x10.0:
-		 1) add flash_prelight control.		
+		1) add flash_prelight control.
 *v0.0x11.0:
-         1) raise qos of isp up to the same as lcdc. 
+		1) raise qos of isp up to the same as lcdc.
 *v0.0x12.0:
-         1) support iommu. 
+		1) support iommu.
 *v0.0x13.0:
-         1) camsys_extdev_register return failed when this dev_id has been registered;
-         2) add support JPG irq connect;
+		1) camsys_extdev_register return failed when this
+		dev_id has been registered;
+		2) add support JPG irq connect;
 *v0.0x14.0:
-         1) camsys_extdev_register return -EBUSY when this dev_id has been registered;
+		1) camsys_extdev_register return -EBUSY when this
+		dev_id has been registered;
 *v0.0x15.0:
-         1) check extdev name when dev_id has been registered;
+		1) check extdev name when dev_id has been registered;
 *v0.0x16.0:
-		 1) enable or disable IOMMU just depending on CONFIG_ROCKCHIP_IOMMU. 
+		1) enable or disable IOMMU just depending
+		on CONFIG_ROCKCHIP_IOMMU.
 *v0.0x17.0:
-		 1) isp iommu status depend on vpu iommu status.
+		1) isp iommu status depend on vpu iommu status.
 *v0.0x18.0:
-         1) add flashlight RT8547 driver
-         2) support torch mode
+		1) add flashlight RT8547 driver
+		2) support torch mode
 *v0.0x19.0:
-         1) set CONFIG_CAMSYS_DRV disable as default,enable in defconfig file if needed.
+		1) set CONFIG_CAMSYS_DRV disable as default,
+		enable in defconfig file if needed.
 *v0.0x1a.0:
-		 1) vpu_node changed from "vpu_service" to "rockchip,vpu_sub"
+		1) vpu_node changed from "vpu_service" to "rockchip,vpu_sub"
 *v0.0x1b.0:
-		 1) use of_find_node_by_name to get vpu node instead of of_find_compatible_node
+		1) use of_find_node_by_name to get vpu node
+		instead of of_find_compatible_node
 *v0.0x1c.0:
-         1) support rk3368. 
+		1) support rk3368.
 *v0.0x1d.0:
-         1) enable aclk_rga for rk3368, otherwise, isp reset will cause system halted.
+		1) enable aclk_rga for rk3368, otherwise,
+		isp reset will cause system halted.
 *v0.0x1e.0:
-         1) dts remove aclk_rga, change aclk_isp from <clk_gates17 0> to <&clk_gates16 0>.
-         2) add rl3369 pd_isp enable/disable.
+		1) dts remove aclk_rga, change aclk_isp
+		from <clk_gates17 0> to <&clk_gates16 0>.
+		2) add rl3369 pd_isp enable/disable.
 *v0.0x1f.0:
-		 1) GPIO(gpio7 GPIO_B5) is EBUSY when register after factory reset, but after power on ,it's normal.
+		1) GPIO(gpio7 GPIO_B5) is EBUSY
+		when register after factory reset,
+		but after power on ,it's normal.
 *v0.0x20.0:
-         1) rk3368 camera: hold vio0 noc clock during the camera work, fixed isp iommu stall failed.
+		1) rk3368 camera: hold vio0 noc clock during the camera work,
+		fixed isp iommu stall failed.
 *v0.0x21.0:
-         1) add isp-dvp-d4d11 iomux support.
+		1) add isp-dvp-d4d11 iomux support.
+*v0.0x21.1:
+		1) support rk3368-sheep kernel ver4.4.
+*v0.0x21.2:
+		1) support rk3399.
 */
-#define CAMSYS_DRIVER_VERSION                   KERNEL_VERSION(0,0x21,0)
-
+#define CAMSYS_DRIVER_VERSION                   KERNEL_VERSION(0, 0x21, 2)
 
 #define CAMSYS_PLATFORM_DRV_NAME                "RockChip-CamSys"
 #define CAMSYS_PLATFORM_MARVIN_NAME             "Platform_MarvinDev"
@@ -140,246 +148,265 @@
 
 #define CAMSYS_REGISTER_MEM_NAME                CAMSYS_REGISTER_RES_NAME
 #define CAMSYS_I2C_MEM_NAME                     "CamSys_I2cMem"
-#define CAMSYS_MIPIPHY_MEM_NAME                 CAMSYS_REGISTER_MIPIPHY_RES_NAME
+#define CAMSYS_MIPIPHY_MEM_NAME                 \
+	CAMSYS_REGISTER_MIPIPHY_RES_NAME
 
-#define CAMSYS_NAMELEN_MIN(a)                   ((strlen(a)>(CAMSYS_NAME_LEN-1))?(CAMSYS_NAME_LEN-1):strlen(a))
+#define CAMSYS_NAMELEN_MIN(a)                   \
+	((strlen(a) > (CAMSYS_NAME_LEN-1))?(CAMSYS_NAME_LEN-1):strlen(a))
 #define CAMSYS_IRQPOOL_NUM                      128
 
 extern unsigned int camsys_debug;
 
-#define camsys_trace(level, msg,...) \
+#define camsys_trace(level, msg, ...) \
 	do { \
 		if (camsys_debug >= level) \
-			printk("D%d:%s(%d): " msg "\n",level, __FUNCTION__,__LINE__, ## __VA_ARGS__); \
+			printk("D%d:%s(%d): " msg "\n", level,\
+			__FUNCTION__, __LINE__, ## __VA_ARGS__); \
 	} while (0)
 
-#define camsys_warn(msg,...)  printk(KERN_ERR "W:%s(%d): " msg "\n", __FUNCTION__,__LINE__, ## __VA_ARGS__)
-#define camsys_err(msg,...)   printk(KERN_ERR "E:%s(%d): " msg "\n", __FUNCTION__,__LINE__, ## __VA_ARGS__)
-
+#define camsys_warn(msg, ...)  \
+	printk(KERN_ERR "W:%s(%d): " msg "\n", __FUNCTION__,\
+	__LINE__, ## __VA_ARGS__)
+#define camsys_err(msg, ...)   \
+	printk(KERN_ERR "E:%s(%d): " msg "\n", __FUNCTION__,\
+	__LINE__, ## __VA_ARGS__)
 
 typedef struct camsys_irqstas_s {
-    camsys_irqsta_t       sta;
-    struct list_head      list;
+	camsys_irqsta_t       sta;
+	struct list_head      list;
 } camsys_irqstas_t;
 
 typedef struct camsys_irqpool_s {
-    pid_t                 pid;
-    unsigned int          timeout;             //us
-    unsigned int          mis;
-    unsigned int          icr;
-    
-
-    spinlock_t            lock;                       // lock for list
-    camsys_irqstas_t      pool[CAMSYS_IRQPOOL_NUM];
-    struct list_head      active;
-    struct list_head      deactive;
-
-    struct list_head      list;
-
-    wait_queue_head_t     done;
+	pid_t                 pid;
+	unsigned int          timeout;/* us */
+	unsigned int          mis;
+	unsigned int          icr;
+	spinlock_t            lock;/* lock for list */
+	camsys_irqstas_t      pool[CAMSYS_IRQPOOL_NUM];
+	struct list_head      active;
+	struct list_head      deactive;
+
+	struct list_head      list;
+
+	wait_queue_head_t     done;
 } camsys_irqpool_t;
 
 typedef struct camsys_irq_s {
-    unsigned int          irq_id;
-
-    spinlock_t            lock;             //lock for timeout and irq_connect in ioctl
-    //unsigned int          timeout;
-    
-    //wait_queue_head_t     irq_done;
-
-    struct list_head      irq_pool;
+	unsigned int          irq_id;
+	/* lock for timeout and irq_connect in ioctl */
+	spinlock_t            lock;
+	struct list_head      irq_pool;
 } camsys_irq_t;
 
 typedef struct camsys_meminfo_s {
-    unsigned char name[32];
-    unsigned long phy_base;
-    unsigned long vir_base;
-    unsigned int size;
-    unsigned int vmas;
-
-    struct list_head list;
-    
+	unsigned char name[32];
+	unsigned long phy_base;
+	unsigned long vir_base;
+	unsigned int size;
+	unsigned int vmas;
+	struct list_head list;
 } camsys_meminfo_t;
 
 typedef struct camsys_devmems_s {
-    camsys_meminfo_t *registermem;
-    camsys_meminfo_t *i2cmem;
-    struct list_head memslist;
+	camsys_meminfo_t *registermem;
+	camsys_meminfo_t *i2cmem;
+	struct list_head memslist;
 } camsys_devmems_t;
 
 typedef struct camsys_regulator_s {
-    struct regulator  *ldo;
-    int               min_uv;
-    int               max_uv;
+	struct regulator  *ldo;
+	int               min_uv;
+	int               max_uv;
 } camsys_regulator_t;
 
 typedef struct camsys_gpio_s {
-    unsigned int      io;
-    unsigned int      active;
+	unsigned int      io;
+	unsigned int      active;
 } camsys_gpio_t;
 typedef struct camsys_flash_s {
-    camsys_gpio_t        fl;
-    camsys_gpio_t        fl_en;
-    void*   ext_fsh_dev;            
-    //flash call back
+	camsys_gpio_t        fl;
+	camsys_gpio_t        fl_en;
+	void *ext_fsh_dev;
 } camsys_flash_t;
 typedef struct camsys_extdev_s {
-    unsigned char            dev_name[CAMSYS_NAME_LEN];
-    unsigned int             dev_id;
-    camsys_regulator_t       avdd;
-    camsys_regulator_t       dovdd;
-    camsys_regulator_t       dvdd;
-    camsys_regulator_t       afvdd;
-    
-    camsys_gpio_t            pwrdn;
-    camsys_gpio_t            rst;
-    camsys_gpio_t            afpwr;
-    camsys_gpio_t            afpwrdn;
+	unsigned char            dev_name[CAMSYS_NAME_LEN];
+	unsigned int             dev_id;
+	camsys_regulator_t       avdd;
+	camsys_regulator_t       dovdd;
+	camsys_regulator_t       dvdd;
+	camsys_regulator_t       afvdd;
+	camsys_gpio_t            pwrdn;
+	camsys_gpio_t            rst;
+	camsys_gpio_t            afpwr;
+	camsys_gpio_t            afpwrdn;
 	camsys_gpio_t            pwren;
-
-    camsys_flash_t           fl;
-
-    camsys_extdev_phy_t      phy;
-    camsys_extdev_clk_t      clk;
-    
-    unsigned int             dev_cfg;
-
-    struct platform_device *pdev;
-    
-    struct list_head         list;
-    struct list_head         active;
+	camsys_flash_t           fl;
+	camsys_extdev_phy_t      phy;
+	camsys_extdev_clk_t      clk;
+	unsigned int             dev_cfg;
+	struct platform_device *pdev;
+	struct list_head         list;
+	struct list_head         active;
 } camsys_extdev_t;
 
-typedef struct camsys_phyinfo_s {
-    unsigned int             phycnt;
-    void                     *clk;
-    camsys_meminfo_t         *reg;    
-
-    int (*clkin_cb)(void *ptr, unsigned int on);
-    int (*ops) (void *ptr, camsys_mipiphy_t *phy);
-    int (*remove)(struct platform_device *pdev);
+	typedef struct camsys_phyinfo_s {
+	unsigned int             phycnt;
+	void                     *clk;
+	camsys_meminfo_t         *reg;
+	int (*clkin_cb)(void *ptr, unsigned int on);
+	int (*ops)(void *ptr, camsys_mipiphy_t *phy);
+	int (*remove)(struct platform_device *pdev);
 } camsys_phyinfo_t;
 
 typedef struct camsys_exdevs_s {
-    struct mutex          mut;
-    struct list_head      list;
-    struct list_head      active;
+	struct mutex          mut;
+	struct list_head      list;
+	struct list_head      active;
 } camsys_exdevs_t;
 
 typedef struct camsys_dev_s {
-    unsigned int          dev_id;	  
+	unsigned int          dev_id;
+	camsys_irq_t          irq;
+	camsys_devmems_t      devmems;
+	struct miscdevice     miscdev;
+	void                  *clk;
+	camsys_phyinfo_t      *mipiphy;
+	camsys_phyinfo_t      cifphy;
 
-    camsys_irq_t          irq;
-    camsys_devmems_t      devmems;
-    struct miscdevice     miscdev;  
-    void                  *clk;
+	camsys_exdevs_t       extdevs;
+	struct list_head      list;
+	struct platform_device *pdev;
 
-    camsys_phyinfo_t      *mipiphy;
-    camsys_phyinfo_t      cifphy;
-
-    camsys_exdevs_t       extdevs;    
-    struct list_head      list;
-    struct platform_device *pdev;
-
-    void                  *soc;
+	void                  *soc;
 
 	camsys_meminfo_t     *csiphy_reg;
-
-    int (*clkin_cb)(void *ptr, unsigned int on);
-    int (*clkout_cb)(void *ptr,unsigned int on,unsigned int clk);
-    int (*reset_cb)(void *ptr, unsigned int on);
-    int (*phy_cb) (camsys_extdev_t *extdev, camsys_sysctrl_t *devctl, void* ptr);
-    int (*iomux)(camsys_extdev_t *extdev,void *ptr);
-    int (*platform_remove)(struct platform_device *pdev);
-    int (*flash_trigger_cb)(void *ptr,int mode , unsigned int on);
-    int (*iommu_cb)(void *ptr,camsys_sysctrl_t *devctl);
+	camsys_meminfo_t     *dsiphy_reg;
+	camsys_meminfo_t     *isp0_reg;
+
+	unsigned long         rk_grf_base;
+	unsigned long         rk_cru_base;
+	unsigned long         rk_isp_base;
+
+	int (*clkin_cb)(void *ptr, unsigned int on);
+	int (*clkout_cb)(void *ptr, unsigned int on, unsigned int clk);
+	int (*reset_cb)(void *ptr, unsigned int on);
+
+	int (*phy_cb)
+		(camsys_extdev_t *extdev,
+		camsys_sysctrl_t *devctl, void *ptr);
+	int (*iomux)(camsys_extdev_t *extdev, void *ptr);
+	int (*platform_remove)(struct platform_device *pdev);
+	int (*flash_trigger_cb)(void *ptr, int mode, unsigned int on);
+	int (*iommu_cb)(void *ptr, camsys_sysctrl_t *devctl);
 } camsys_dev_t;
 
 
-static inline camsys_extdev_t* camsys_find_extdev(unsigned int dev_id, camsys_dev_t *camsys_dev)
+static inline camsys_extdev_t *camsys_find_extdev(
+unsigned int dev_id, camsys_dev_t *camsys_dev)
 {
-    camsys_extdev_t *extdev;
-
-    if (!list_empty(&camsys_dev->extdevs.list)) {
-        list_for_each_entry(extdev, &camsys_dev->extdevs.list, list) {
-            if (extdev->dev_id == dev_id) {
-                return extdev;
-            }
-        }
-    }    
-    return NULL;
+	camsys_extdev_t *extdev;
+
+	if (!list_empty(&camsys_dev->extdevs.list)) {
+		list_for_each_entry(extdev,
+			&camsys_dev->extdevs.list, list) {
+			if (extdev->dev_id == dev_id) {
+				return extdev;
+			}
+		}
+	}
+	return NULL;
 }
 
-static inline camsys_meminfo_t* camsys_find_devmem(char *name, camsys_dev_t *camsys_dev)
+static inline camsys_meminfo_t *camsys_find_devmem(
+char *name, camsys_dev_t *camsys_dev)
 {
-    camsys_meminfo_t *devmem;
-
-    if (!list_empty(&camsys_dev->devmems.memslist)) {
-        list_for_each_entry(devmem, &camsys_dev->devmems.memslist, list) {
-            if (strcmp(devmem->name, name) == 0) {
-                return devmem;
-            }
-        }
-    }
-    camsys_err("%s memory have not been find in %s!",name,dev_name(camsys_dev->miscdev.this_device));
-    return NULL;
+	camsys_meminfo_t *devmem;
+
+	if (!list_empty(&camsys_dev->devmems.memslist)) {
+		list_for_each_entry(devmem,
+			&camsys_dev->devmems.memslist, list) {
+			if (strcmp(devmem->name, name) == 0) {
+				return devmem;
+			}
+		}
+	}
+	camsys_err("%s memory have not been find in %s!",
+		name, dev_name(camsys_dev->miscdev.this_device));
+	return NULL;
 }
 
-
-static inline int camsys_sysctl_extdev(camsys_extdev_t *extdev, camsys_sysctrl_t *devctl, camsys_dev_t *camsys_dev)
+static inline int camsys_sysctl_extdev(
+camsys_extdev_t *extdev, camsys_sysctrl_t *devctl, camsys_dev_t *camsys_dev)
 {
-    int err = 0;
-    camsys_regulator_t *regulator;
-    camsys_gpio_t *gpio;
-    
-    if ((devctl->ops>CamSys_Vdd_Start_Tag) && (devctl->ops < CamSys_Vdd_End_Tag)) {
-        regulator = &extdev->avdd;
-        regulator += devctl->ops-1;
-        
-        if (!IS_ERR_OR_NULL(regulator->ldo)) {
-            if (devctl->on) {
-                err = regulator_set_voltage(regulator->ldo,regulator->min_uv,regulator->max_uv);
-                err |= regulator_enable(regulator->ldo);
-                camsys_trace(1,"Sysctl %d success, regulator set (%d,%d) uv!",devctl->ops, regulator->min_uv,regulator->max_uv);
-            } else {
-                while(regulator_is_enabled(regulator->ldo)>0)	
-			        regulator_disable(regulator->ldo);
-			    camsys_trace(1,"Sysctl %d success, regulator off!",devctl->ops);
-            }
-        } else {
-            //camsys_err("Sysctl %d failed, because regulator ldo is NULL!",devctl->ops);
-            err = -EINVAL;
-            goto end;
-        }
-    } else if ((devctl->ops>CamSys_Gpio_Start_Tag) && (devctl->ops < CamSys_Gpio_End_Tag)) {
-        gpio = &extdev->pwrdn;
-        gpio += devctl->ops - CamSys_Gpio_Start_Tag -1;
-
-        if (gpio->io != 0xffffffff) {
-            if (devctl->on) {
-                gpio_direction_output(gpio->io, gpio->active);
-                gpio_set_value(gpio->io, gpio->active);
-                camsys_trace(1,"Sysctl %d success, gpio(%d) set %d",devctl->ops, gpio->io, gpio->active);
-            } else {
-                gpio_direction_output(gpio->io, !gpio->active);
-                gpio_set_value(gpio->io, !gpio->active);
-                camsys_trace(1,"Sysctl %d success, gpio(%d) set %d",devctl->ops, gpio->io, !gpio->active);
-            }
-        } else {
-            camsys_err("Sysctl %d failed, because gpio is NULL!",devctl->ops);
-            err = -EINVAL;
-            goto end;
-        }
-    } else if (devctl->ops == CamSys_ClkIn) {
-        if (camsys_dev->clkout_cb)
-            camsys_dev->clkout_cb(camsys_dev,devctl->on,extdev->clk.in_rate);        
-    } else if (devctl->ops == CamSys_Phy) {
-        if (camsys_dev->phy_cb)
-            (camsys_dev->phy_cb)(extdev,devctl,(void*)camsys_dev);
-    }
+	int err = 0;
+	camsys_regulator_t *regulator;
+	camsys_gpio_t *gpio;
+
+	if ((devctl->ops > CamSys_Vdd_Start_Tag) &&
+		(devctl->ops < CamSys_Vdd_End_Tag)) {
+		regulator = &extdev->avdd;
+		regulator += devctl->ops-1;
+
+		if (!IS_ERR_OR_NULL(regulator->ldo)) {
+			if (devctl->on) {
+				err = regulator_set_voltage(
+					regulator->ldo, regulator->min_uv,
+					regulator->max_uv);
+				err |= regulator_enable(regulator->ldo);
+				camsys_trace(1,
+					"Sysctl %d success, regulator set (%d,%d) uv!",
+					devctl->ops, regulator->min_uv,
+					regulator->max_uv);
+			} else {
+				while (regulator_is_enabled(regulator->ldo) > 0)
+					regulator_disable(regulator->ldo);
+				camsys_trace(1,
+					"Sysctl %d success, regulator off!",
+					devctl->ops);
+			}
+		} else {
+			err = -EINVAL;
+			goto end;
+		}
+	} else if ((devctl->ops > CamSys_Gpio_Start_Tag) &&
+		(devctl->ops < CamSys_Gpio_End_Tag)) {
+		gpio = &extdev->pwrdn;
+		gpio += devctl->ops - CamSys_Gpio_Start_Tag -1;
+
+		if (gpio->io != 0xffffffff) {
+			if (devctl->on) {
+				gpio_direction_output(gpio->io, gpio->active);
+				gpio_set_value(gpio->io, gpio->active);
+				camsys_trace(1,
+					"Sysctl %d success, gpio(%d) set %d",
+					devctl->ops, gpio->io, gpio->active);
+			} else {
+				gpio_direction_output(gpio->io, !gpio->active);
+				gpio_set_value(gpio->io, !gpio->active);
+				camsys_trace(1,
+					"Sysctl %d success, gpio(%d) set %d",
+					devctl->ops, gpio->io, !gpio->active);
+			}
+		} else {
+			camsys_err("Sysctl %d failed, because gpio is NULL!",
+				devctl->ops);
+			err = -EINVAL;
+			goto end;
+		}
+	} else if (devctl->ops == CamSys_ClkIn) {
+		if (camsys_dev->clkout_cb)
+			camsys_dev->clkout_cb
+				(camsys_dev, devctl->on,
+				extdev->clk.in_rate);
+	} else if (devctl->ops == CamSys_Phy) {
+		if (camsys_dev->phy_cb)
+			(camsys_dev->phy_cb)
+				(extdev, devctl,
+				(void *)camsys_dev);
+	}
 
 end:
-    return err;
+	return err;
 }
 
 extern struct file_operations camsys_fops;
diff --git a/drivers/media/video/rk_camsys/camsys_marvin.c b/drivers/media/video/rk_camsys/camsys_marvin.c
index abad592f54af..0018aed10c21 100755
--- a/drivers/media/video/rk_camsys/camsys_marvin.c
+++ b/drivers/media/video/rk_camsys/camsys_marvin.c
@@ -2,683 +2,990 @@
 #include "camsys_soc_priv.h"
 #include "camsys_gpio.h"
 
-#include <linux/rockchip/common.h> 
+#include <linux/rockchip/common.h>
 #include <dt-bindings/clock/rk_system_status.h>
 #include <linux/rockchip_ion.h>
 #include <linux/file.h>
+#include <linux/pm_runtime.h>
 
 extern int rockchip_set_system_status(unsigned long status);
 extern int rockchip_clear_system_status(unsigned long status);
 
 static const char miscdev_name[] = CAMSYS_MARVIN_DEVNAME;
 
-
-static int camsys_mrv_iomux_cb(camsys_extdev_t *extdev,void *ptr)
+static int camsys_mrv_iomux_cb(camsys_extdev_t *extdev, void *ptr)
 {
-    struct pinctrl      *pinctrl;
-    struct pinctrl_state    *state;
-    int retval = 0;
-    char state_str[20] = {0};
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    struct device *dev = &(extdev->pdev->dev);
-    camsys_soc_priv_t *soc;
-
-    // DVP IO Config
-    
-    if (extdev->phy.type == CamSys_Phy_Cif) {
-
-        switch (extdev->phy.info.cif.fmt)
-        {
-            case CamSys_Fmt_Raw_8b:
-            case CamSys_Fmt_Yuv420_8b:
-            case CamSys_Fmt_Yuv422_8b:
-            {
-                if (extdev->phy.info.cif.cifio == CamSys_SensorBit0_CifBit0) {
-                    strcpy(state_str,"isp_dvp8bit0");
-                } else if (extdev->phy.info.cif.cifio == CamSys_SensorBit0_CifBit2) {
-                    strcpy(state_str,"isp_dvp8bit2");
-                } else if (extdev->phy.info.cif.cifio == CamSys_SensorBit0_CifBit4) {
-                    strcpy(state_str,"isp_dvp8bit4");
-                }else {
-                    camsys_err("extdev->phy.info.cif.cifio: 0x%x is invalidate!", extdev->phy.info.cif.cifio);
-                    goto fail;
-                }
-
-                break;
-            }
-
-            case CamSys_Fmt_Raw_10b:
-            {
-                strcpy(state_str,"isp_dvp10bit");
-                break;
-            }
-
-            case CamSys_Fmt_Raw_12b:
-            {
-                strcpy(state_str,"isp_dvp12bit");
-                break;
-            }
-
-            default:
-            {
-                camsys_err("extdev->phy.info.cif.fmt: 0x%x is invalidate!",extdev->phy.info.cif.fmt);
-                goto fail;
-            }
-        }        
-    } else {
-        if (extdev->dev_cfg & CAMSYS_DEVCFG_FLASHLIGHT) {
-            if (extdev->dev_cfg & CAMSYS_DEVCFG_PREFLASHLIGHT) {
-                strcpy(state_str,"isp_mipi_fl_prefl");
-            } else {
-                strcpy(state_str,"isp_mipi_fl");
-            }
-            {
-                //mux triggerout as gpio
-            //get gpio index
-                int flash_trigger_io ;
-                enum of_gpio_flags flags;
-                flash_trigger_io = of_get_named_gpio_flags(camsys_dev->pdev->dev.of_node, "rockchip,gpios", 0, &flags);
-                if(gpio_is_valid(flash_trigger_io)){
-                    flash_trigger_io = of_get_named_gpio_flags(camsys_dev->pdev->dev.of_node, "rockchip,gpios", 0, &flags);
-                    gpio_request(flash_trigger_io,"camsys_gpio");
-                    gpio_direction_output(flash_trigger_io, (~(extdev->fl.fl.active) & 0x1));
-                }
-            }			
-        } else {
-            strcpy(state_str,"default");
-        }
-    }
-
-    camsys_trace(1,"marvin pinctrl select: %s", state_str);
-    
-    pinctrl = devm_pinctrl_get(dev);
-    if (IS_ERR(pinctrl)) {
-        camsys_err("devm_pinctrl_get failed!");
-        goto fail;
-    }
-    state = pinctrl_lookup_state(pinctrl,
-                         state_str);
-    if (IS_ERR(state)){
-        camsys_err("pinctrl_lookup_state failed!");
-        goto fail;
-    }
-
-    if (!IS_ERR(state)) {
-        retval = pinctrl_select_state(pinctrl, state);
-        if (retval){
-            camsys_err("pinctrl_select_state failed!");
-            goto fail;
-        }
-    }
-
-    if (camsys_dev->soc) {
-        soc = (camsys_soc_priv_t*)camsys_dev->soc;
-        if (soc->soc_cfg) {
-            (soc->soc_cfg)(Cif_IoDomain_Cfg,(void*)&extdev->dovdd.min_uv);
-            (soc->soc_cfg)(Clk_DriverStrength_Cfg,(void*)&extdev->clk.driver_strength);
-        } else {
-            camsys_err("camsys_dev->soc->soc_cfg is NULL!");
-        }
-    } else {
-        camsys_err("camsys_dev->soc is NULL!");
-    }
-    
-    return 0;
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*state;
+	int retval = 0;
+	char state_str[20] = {0};
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	struct device *dev = &(extdev->pdev->dev);
+	camsys_soc_priv_t *soc;
+
+	/* DVP IO Config */
+
+	if (extdev->phy.type == CamSys_Phy_Cif) {
+		switch (extdev->phy.info.cif.fmt) {
+		case CamSys_Fmt_Raw_8b:
+		case CamSys_Fmt_Yuv420_8b:
+		case CamSys_Fmt_Yuv422_8b:{
+			if (extdev->phy.info.cif.cifio ==
+				CamSys_SensorBit0_CifBit0) {
+				strcpy(state_str, "isp_dvp8bit0");
+			} else if (extdev->phy.info.cif.cifio ==
+			CamSys_SensorBit0_CifBit2) {
+				strcpy(state_str, "isp_dvp8bit2");
+			} else if (extdev->phy.info.cif.cifio ==
+			CamSys_SensorBit0_CifBit4) {
+				strcpy(state_str, "isp_dvp8bit4");
+			} else {
+				camsys_err("extdev->phy.info.cif.cifio:0x%x is invalidate!",
+					extdev->phy.info.cif.cifio);
+				goto fail;
+			}
+
+			break;
+		}
+
+		case CamSys_Fmt_Raw_10b:{
+			strcpy(state_str, "isp_dvp10bit");
+			break;
+		}
+
+		case CamSys_Fmt_Raw_12b:{
+			strcpy(state_str, "isp_dvp12bit");
+			break;
+		}
+
+		default:{
+			camsys_err("extdev->phy.info.cif.fmt: 0x%x is invalidate!",
+				extdev->phy.info.cif.fmt);
+			goto fail;
+		}
+		}
+	} else {
+		if (extdev->dev_cfg & CAMSYS_DEVCFG_FLASHLIGHT) {
+			if (extdev->dev_cfg & CAMSYS_DEVCFG_PREFLASHLIGHT) {
+				strcpy(state_str, "isp_mipi_fl_prefl");
+			} else {
+				strcpy(state_str, "isp_mipi_fl");
+			}
+			{
+				/*mux triggerout as gpio*/
+				/*get gpio index*/
+				int flash_trigger_io;
+				enum of_gpio_flags flags;
+
+				flash_trigger_io =
+					of_get_named_gpio_flags(
+					camsys_dev->pdev->dev.of_node,
+					"rockchip,gpios", 0, &flags);
+				if (gpio_is_valid(flash_trigger_io)) {
+					flash_trigger_io =
+						of_get_named_gpio_flags(
+						camsys_dev->pdev->dev.of_node,
+						"rockchip,gpios", 0, &flags);
+					gpio_request(flash_trigger_io,
+						"camsys_gpio");
+					gpio_direction_output(
+						flash_trigger_io,
+						(~(extdev->fl.fl.active) &
+						0x1));
+				}
+			}
+		} else {
+			if (CHIP_TYPE == 3399) {
+				strcpy(state_str, "cif_clkout");
+			} else {
+				strcpy(state_str, "default");
+			}
+		}
+	}
+
+	camsys_trace(1, "marvin pinctrl select: %s", state_str);
+
+	pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(pinctrl)) {
+		camsys_err("devm_pinctrl_get failed!");
+		goto fail;
+	}
+	state = pinctrl_lookup_state(pinctrl,
+							state_str);
+	if (IS_ERR(state)) {
+		camsys_err("pinctrl_lookup_state failed!");
+		goto fail;
+	}
+
+	if (!IS_ERR(state)) {
+		retval = pinctrl_select_state(pinctrl, state);
+		if (retval) {
+			camsys_err("pinctrl_select_state failed!");
+			goto fail;
+		}
+	}
+
+	if (camsys_dev->soc) {
+		soc = (camsys_soc_priv_t *)camsys_dev->soc;
+		if (soc->soc_cfg) {
+			(soc->soc_cfg)(camsys_dev, Cif_IoDomain_Cfg,
+				(void *)&extdev->dovdd.min_uv);
+			(soc->soc_cfg)(camsys_dev, Clk_DriverStrength_Cfg,
+				(void *)&extdev->clk.driver_strength);
+		} else {
+			camsys_err("camsys_dev->soc->soc_cfg is NULL!");
+		}
+	} else {
+		camsys_err("camsys_dev->soc is NULL!");
+	}
+
+	return 0;
 fail:
-    return -1;
+	return -1;
 }
 
-static int camsys_mrv_flash_trigger_cb(void *ptr,int mode,unsigned int on)
+static int camsys_mrv_flash_trigger_cb(void *ptr, int mode, unsigned int on)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    struct device *dev = &(camsys_dev->pdev->dev);
-    int flash_trigger_io ;
-    struct pinctrl      *pinctrl;
-    struct pinctrl_state    *state;
-    char state_str[20] = {0};
-    int retval = 0;
-    enum of_gpio_flags flags;
-    camsys_extdev_t *extdev = NULL;
-	
-    if(!on){
-        strcpy(state_str,"isp_flash_as_gpio");
-        pinctrl = devm_pinctrl_get(dev);
-        if (IS_ERR(pinctrl)) {
-            camsys_err("devm_pinctrl_get failed!");
-        }
-        state = pinctrl_lookup_state(pinctrl,
-                             state_str);
-        if (IS_ERR(state)){
-            camsys_err("pinctrl_lookup_state failed!");
-        }
-
-        if (!IS_ERR(state)) {
-            retval = pinctrl_select_state(pinctrl, state);
-            if (retval){
-                camsys_err("pinctrl_select_state failed!");
-            }
-
-        }
-
-        //get gpio index
-        flash_trigger_io = of_get_named_gpio_flags(camsys_dev->pdev->dev.of_node, "rockchip,gpios", 0, &flags);
-        if(gpio_is_valid(flash_trigger_io)){
-            flash_trigger_io = of_get_named_gpio_flags(camsys_dev->pdev->dev.of_node, "rockchip,gpios", 0, &flags);
-            gpio_request(flash_trigger_io,"camsys_gpio");
-            //get flash io active pol
-            if (!list_empty(&camsys_dev->extdevs.list)) {
-                list_for_each_entry(extdev, &camsys_dev->extdevs.list, list) {
-                    if (extdev->dev_cfg & CAMSYS_DEVCFG_FLASHLIGHT) {
-                        gpio_direction_output(flash_trigger_io, (~(extdev->fl.fl.active) & 0x1));
-                    }
-                }
-            }    
-        }
-    }else{
-        strcpy(state_str,"isp_flash_as_trigger_out");
-        pinctrl = devm_pinctrl_get(dev);
-        if (IS_ERR(pinctrl)) {
-            camsys_err("devm_pinctrl_get failed!");
-        }
-        state = pinctrl_lookup_state(pinctrl,
-                             state_str);
-        if (IS_ERR(state)){
-            camsys_err("pinctrl_lookup_state failed!");
-        }
-
-        if (!IS_ERR(state)) {
-            retval = pinctrl_select_state(pinctrl, state);
-            if (retval){
-                camsys_err("pinctrl_select_state failed!");
-            }
-
-        }
-    }
-    return retval;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	struct device *dev = &(camsys_dev->pdev->dev);
+	int flash_trigger_io;
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*state;
+	char state_str[20] = {0};
+	int retval = 0;
+	enum of_gpio_flags flags;
+	camsys_extdev_t *extdev = NULL;
+
+	if (!on) {
+		strcpy(state_str, "isp_flash_as_gpio");
+		pinctrl = devm_pinctrl_get(dev);
+		if (IS_ERR(pinctrl)) {
+			camsys_err("devm_pinctrl_get failed!");
+		}
+		state = pinctrl_lookup_state(pinctrl, state_str);
+		if (IS_ERR(state)) {
+			camsys_err("pinctrl_lookup_state failed!");
+		}
+
+		if (!IS_ERR(state)) {
+			retval = pinctrl_select_state(pinctrl, state);
+			if (retval) {
+				camsys_err("pinctrl_select_state failed!");
+			}
+		}
+
+		/*get gpio index*/
+		flash_trigger_io = of_get_named_gpio_flags(
+			camsys_dev->pdev->dev.of_node,
+				"rockchip,gpios", 0, &flags);
+		if (gpio_is_valid(flash_trigger_io)) {
+			flash_trigger_io = of_get_named_gpio_flags(
+				camsys_dev->pdev->dev.of_node,
+				"rockchip,gpios", 0, &flags);
+			gpio_request(flash_trigger_io, "camsys_gpio");
+			/*get flash io active pol*/
+			if (!list_empty(&camsys_dev->extdevs.list)) {
+				list_for_each_entry(
+					extdev, &camsys_dev->extdevs.list,
+					list) {
+					if (extdev->dev_cfg &
+						CAMSYS_DEVCFG_FLASHLIGHT) {
+						gpio_direction_output(
+							flash_trigger_io,
+							(~(extdev->fl.fl.active)
+							& 0x1));
+					}
+				}
+			}
+		}
+	} else{
+		strcpy(state_str, "isp_flash_as_trigger_out");
+		pinctrl = devm_pinctrl_get(dev);
+		if (IS_ERR(pinctrl)) {
+			camsys_err("devm_pinctrl_get failed!");
+		}
+		state = pinctrl_lookup_state(pinctrl,
+								state_str);
+		if (IS_ERR(state)) {
+			camsys_err("pinctrl_lookup_state failed!");
+		}
+
+		if (!IS_ERR(state)) {
+			retval = pinctrl_select_state(pinctrl, state);
+			if (retval) {
+				camsys_err("pinctrl_select_state failed!");
+			}
+
+		}
+	}
+	return retval;
 }
-static struct device *rockchip_get_sysmmu_device_by_compatible(const char *compt)
+static struct device *rockchip_get_sysmmu_device_by_compatible(
+const char *compt)
 {
 	struct device_node *dn = NULL;
 	struct platform_device *pd = NULL;
-	struct device *ret = NULL ;
+	struct device *ret = NULL;
 
-	dn = of_find_compatible_node(NULL,NULL,compt);
-	if(!dn)
-	{
-		printk("can't find device node %s \r\n",compt);
+	dn = of_find_compatible_node(NULL, NULL, compt);
+	if (!dn) {
+		camsys_err("can't find device node %s \r\n", compt);
 		return NULL;
 	}
-	
+
 	pd = of_find_device_by_node(dn);
-	if(!pd)
-	{	
-		printk("can't find platform device in device node %s \r\n",compt);
-		return  NULL;
+	if (!pd) {
+		camsys_err(
+			"can't find platform device in device node %s \r\n",
+			compt);
+		return	NULL;
 	}
 	ret = &pd->dev;
-	
+
 	return ret;
 
 }
 #ifdef CONFIG_IOMMU_API
-static inline void platform_set_sysmmu(struct device *iommu, struct device *dev)
+static inline void platform_set_sysmmu(
+struct device *iommu, struct device *dev)
 {
 	dev->archdata.iommu = iommu;
 }
 #else
-static inline void platform_set_sysmmu(struct device *iommu, struct device *dev)
+static inline void platform_set_sysmmu(
+struct device *iommu, struct device *dev)
 {
 }
 #endif
 
 
-static int camsys_mrv_iommu_cb(void *ptr,camsys_sysctrl_t *devctl)
+static int camsys_mrv_iommu_cb(void *ptr, camsys_sysctrl_t *devctl)
 {
-    struct device *iommu_dev = NULL,*dev = NULL;
-    struct file *file = NULL;
-    struct ion_client *client = NULL;
-    struct ion_handle *handle = NULL;
-    camsys_iommu_t *iommu = NULL;
-    int ret = 0,iommu_enabled = 0;
-    camsys_dev_t * camsys_dev = (camsys_dev_t *)ptr;
-
-    of_property_read_u32(camsys_dev->pdev->dev.of_node, "rockchip,isp,iommu_enable", &iommu_enabled);
-    if(iommu_enabled != 1){
-        camsys_err("isp iommu have not been enabled!\n");
-        ret = -1;
-        goto iommu_end;
-    }
-    iommu_dev = rockchip_get_sysmmu_device_by_compatible(ISP_IOMMU_COMPATIBLE_NAME);
-    if(!iommu_dev){
-        camsys_err("get iommu device erro!\n");
-        ret = -1;
-        goto iommu_end;
-    }
-    dev = &(camsys_dev->pdev->dev);
-    iommu = (camsys_iommu_t *)(devctl->rev);
-    file = fget(iommu->client_fd);
-    if(!file){
-        camsys_err("get client_fd file erro!\n");
-        ret = -1;
-        goto iommu_end;
-    }
-    
-    client = file->private_data;
-    
-    if(!client){
-        camsys_err("get ion_client erro!\n");
-        ret = -1;
-        goto iommu_end;
-    }
-    
-    fput(file);
-
-    handle = ion_import_dma_buf(client,iommu->map_fd);
-
-    camsys_trace(1,"map fd %d ,client fd %d\n",iommu->map_fd,iommu->client_fd);
-    if(!handle){
-        camsys_err("get ion_handle erro!\n");
-        ret = -1;
-        goto iommu_end;
-    }
-    if(devctl->on){
-        platform_set_sysmmu(iommu_dev,dev);
-        ret = rockchip_iovmm_activate(dev);
-        
-        ret = ion_map_iommu(dev,client,handle,&(iommu->linear_addr),&(iommu->len));
-        
-    }else{
-        ion_unmap_iommu(dev,client,handle);
-        platform_set_sysmmu(iommu_dev,dev);
-        rockchip_iovmm_deactivate(dev);
-    }
+	struct device *iommu_dev = NULL, *dev = NULL;
+	struct file *file = NULL;
+	struct ion_client *client = NULL;
+	struct ion_handle *handle = NULL;
+	camsys_iommu_t *iommu = NULL;
+	int ret = 0, iommu_enabled = 0;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+
+	of_property_read_u32(camsys_dev->pdev->dev.of_node,
+		"rockchip,isp,iommu_enable", &iommu_enabled);
+	if (iommu_enabled != 1) {
+		camsys_err("isp iommu have not been enabled!\n");
+		ret = -1;
+		goto iommu_end;
+	}
+
+	if (strstr(camsys_dev->miscdev.name, "camsys_marvin1")) {
+		iommu_dev =
+			rockchip_get_sysmmu_device_by_compatible
+				(ISP1_IOMMU_COMPATIBLE_NAME);
+	} else{
+		if (CHIP_TYPE == 3399) {
+			iommu_dev =
+				rockchip_get_sysmmu_device_by_compatible
+					(ISP0_IOMMU_COMPATIBLE_NAME);
+		} else{
+			iommu_dev =
+				rockchip_get_sysmmu_device_by_compatible
+					(ISP_IOMMU_COMPATIBLE_NAME);
+		}
+	}
+
+	if (!iommu_dev) {
+		camsys_err("get iommu device erro!\n");
+		ret = -1;
+		goto iommu_end;
+	}
+	dev = &(camsys_dev->pdev->dev);
+	iommu = (camsys_iommu_t *)(devctl->rev);
+	file = fget(iommu->client_fd);
+	if (!file) {
+		camsys_err("get client_fd file erro!\n");
+		ret = -1;
+		goto iommu_end;
+	}
+
+	client = file->private_data;
+
+	if (!client) {
+		camsys_err("get ion_client erro!\n");
+		ret = -1;
+		goto iommu_end;
+	}
+
+	fput(file);
+
+	handle = ion_import_dma_buf(client, iommu->map_fd);
+
+	camsys_trace(1, "map fd %d ,client fd %d\n",
+		iommu->map_fd, iommu->client_fd);
+	if (!handle) {
+		camsys_err("get ion_handle erro!\n");
+		ret = -1;
+		goto iommu_end;
+	}
+	if (devctl->on) {
+		platform_set_sysmmu(iommu_dev, dev);
+		ret = rockchip_iovmm_activate(dev);
+		ret = ion_map_iommu(dev, client, handle,
+			&(iommu->linear_addr), &(iommu->len));
+	} else{
+		ion_unmap_iommu(dev, client, handle);
+		platform_set_sysmmu(iommu_dev, dev);
+		rockchip_iovmm_deactivate(dev);
+	}
 iommu_end:
-    return ret;
+	return ret;
 }
-static int camsys_mrv_reset_cb(void *ptr,unsigned int on)
+static int camsys_mrv_reset_cb(void *ptr, unsigned int on)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    camsys_soc_priv_t *soc;
-
-
-    if (camsys_dev->soc) {
-        soc = (camsys_soc_priv_t*)camsys_dev->soc;
-        if (soc->soc_cfg) {
-            (soc->soc_cfg)(Isp_SoftRst,(void*)(unsigned long)on);
-        } else {
-            camsys_err("camsys_dev->soc->soc_cfg is NULL!");
-        }
-    } else {
-        camsys_err("camsys_dev->soc is NULL!");
-    }
-    
-    return 0;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	camsys_soc_priv_t *soc;
+
+	if (camsys_dev->soc) {
+		soc = (camsys_soc_priv_t *)camsys_dev->soc;
+		if (soc->soc_cfg) {
+			(soc->soc_cfg)
+				(camsys_dev, Isp_SoftRst,
+				(void *)(unsigned long)on);
+		} else {
+			camsys_err("camsys_dev->soc->soc_cfg is NULL!");
+		}
+	} else {
+		camsys_err("camsys_dev->soc is NULL!");
+	}
+
+	return 0;
 }
 
 static int camsys_mrv_clkin_cb(void *ptr, unsigned int on)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    camsys_mrv_clk_t *clk = (camsys_mrv_clk_t*)camsys_dev->clk;
-    unsigned long isp_clk;
-	
-    if (on && !clk->in_on) {
-		rockchip_set_system_status(SYS_STATUS_ISP);
-
-		if (on == 1) {
-		    isp_clk = 210000000;           
-		} else {
-		    isp_clk = 420000000;            
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	camsys_mrv_clk_t *clk = (camsys_mrv_clk_t *)camsys_dev->clk;
+	unsigned long isp_clk;
+
+	if (CHIP_TYPE == 3399) {
+		if (on && !clk->in_on) {
+			/* rockchip_set_system_status(SYS_STATUS_ISP); */
+			if (on == 1)
+				isp_clk = 210000000;
+			else
+				isp_clk = 210000000;
+
+			if (strstr(camsys_dev->miscdev.name,
+				"camsys_marvin1")) {
+				clk_set_rate(clk->clk_isp1, isp_clk);
+				clk_prepare_enable(clk->hclk_isp1_noc);
+				clk_prepare_enable(clk->hclk_isp1_wrapper);
+				clk_prepare_enable(clk->aclk_isp1_noc);
+				clk_prepare_enable(clk->aclk_isp1_wrapper);
+				clk_prepare_enable(clk->clk_isp1);
+
+				clk_prepare_enable(clk->cif_clk_out);
+				clk_prepare_enable(clk->pclk_dphy_ref);
+				clk_prepare_enable(clk->pclk_dphytxrx);
+
+				clk_prepare_enable(clk->pclkin_isp);
+			} else{
+				clk_set_rate(clk->clk_isp0, isp_clk);
+				clk_prepare_enable(clk->hclk_isp0_noc);
+				clk_prepare_enable(clk->hclk_isp0_wrapper);
+				clk_prepare_enable(clk->aclk_isp0_noc);
+				clk_prepare_enable(clk->aclk_isp0_wrapper);
+				clk_prepare_enable(clk->clk_isp0);
+				clk_prepare_enable(clk->cif_clk_out);
+				clk_prepare_enable(clk->pclk_dphyrx);
+				clk_prepare_enable(clk->pclk_dphy_ref);
+			}
+
+		clk_set_rate(clk->clk_isp0, isp_clk);
+		clk_set_rate(clk->clk_isp1, isp_clk);
+
+		clk->in_on = true;
+
+		camsys_trace(1, "%s clock(f: %ld Hz) in turn on",
+			dev_name(camsys_dev->miscdev.this_device), isp_clk);
+		camsys_mrv_reset_cb(ptr, 1);
+		udelay(100);
+		camsys_mrv_reset_cb(ptr, 0);
+		} else if (!on && clk->in_on) {
+			if (strstr(camsys_dev->miscdev.name,
+				"camsys_marvin1")) {
+				clk_disable_unprepare(clk->hclk_isp1_noc);
+				clk_disable_unprepare(clk->hclk_isp1_wrapper);
+				clk_disable_unprepare(clk->aclk_isp1_noc);
+				clk_disable_unprepare(clk->aclk_isp1_wrapper);
+				clk_disable_unprepare(clk->clk_isp1);
+
+				clk_disable_unprepare(clk->cif_clk_out);
+				clk_disable_unprepare(clk->pclk_dphytxrx);
+				clk_disable_unprepare(clk->pclk_dphy_ref);
+
+				clk_disable_unprepare(clk->pclkin_isp);
+
+			} else{
+				clk_disable_unprepare(clk->hclk_isp0_noc);
+				clk_disable_unprepare(clk->hclk_isp0_wrapper);
+				clk_disable_unprepare(clk->aclk_isp0_noc);
+				clk_disable_unprepare(clk->aclk_isp0_wrapper);
+				clk_disable_unprepare(clk->clk_isp0);
+
+				clk_disable_unprepare(clk->cif_clk_out);
+				clk_disable_unprepare(clk->pclk_dphyrx);
+				clk_disable_unprepare(clk->pclk_dphy_ref);
+			}
+
+		/* rockchip_clear_system_status(SYS_STATUS_ISP); */
+		clk->in_on = false;
+		camsys_trace(1, "%s clock in turn off",
+			dev_name(camsys_dev->miscdev.this_device));
 		}
-
-		clk_set_rate(clk->isp,isp_clk);
-        clk_set_rate(clk->isp_jpe, isp_clk);
-
-		clk_prepare_enable(clk->pd_isp);
-        clk_prepare_enable(clk->aclk_isp);
-        clk_prepare_enable(clk->hclk_isp);
-        clk_prepare_enable(clk->isp);
-        clk_prepare_enable(clk->isp_jpe);
-        clk_prepare_enable(clk->pclkin_isp); 
-		if(CHIP_TYPE == 3368){
-
+	} else{
+		if (on && !clk->in_on) {
+			/* rockchip_set_system_status(SYS_STATUS_ISP); */
+
+		if (on == 1)
+			isp_clk = 210000000;
+		else
+			isp_clk = 420000000;
+
+		clk_set_rate(clk->isp, isp_clk);
+		clk_set_rate(clk->isp_jpe, isp_clk);
+
+		/* clk_prepare_enable(clk->pd_isp); */
+		clk_prepare_enable(clk->aclk_isp);
+		clk_prepare_enable(clk->hclk_isp);
+		clk_prepare_enable(clk->isp);
+		clk_prepare_enable(clk->isp_jpe);
+		clk_prepare_enable(clk->pclkin_isp);
+		if (CHIP_TYPE == 3368 || CHIP_TYPE == 3366) {
 			clk_prepare_enable(clk->cif_clk_out);
 			clk_prepare_enable(clk->pclk_dphyrx);
-			clk_prepare_enable(clk->clk_vio0_noc);
-		}else{
-			clk_prepare_enable(clk->clk_mipi_24m);		
-		}
-        clk->in_on = true;
-
-        camsys_trace(1, "%s clock(f: %ld Hz) in turn on",dev_name(camsys_dev->miscdev.this_device),isp_clk);
-        camsys_mrv_reset_cb(ptr,1);
-        udelay(100);
-        camsys_mrv_reset_cb(ptr,0);
-        
-    } else if (!on && clk->in_on) {
-
-        clk_disable_unprepare(clk->aclk_isp);
-        clk_disable_unprepare(clk->hclk_isp);
-        clk_disable_unprepare(clk->isp);
-        clk_disable_unprepare(clk->isp_jpe);
-        clk_disable_unprepare(clk->pclkin_isp);
-		if(CHIP_TYPE == 3368){
-	        clk_disable_unprepare(clk->cif_clk_out);
+			if (CHIP_TYPE == 3368)
+				clk_prepare_enable(clk->clk_vio0_noc);
+		} else{
+			clk_prepare_enable(clk->clk_mipi_24m);
+		}
+			clk->in_on = true;
+
+		camsys_trace(1, "%s clock(f: %ld Hz) in turn on",
+			dev_name(camsys_dev->miscdev.this_device), isp_clk);
+		camsys_mrv_reset_cb(ptr, 1);
+		udelay(100);
+		camsys_mrv_reset_cb(ptr, 0);
+		} else if (!on && clk->in_on) {
+		clk_disable_unprepare(clk->aclk_isp);
+		clk_disable_unprepare(clk->hclk_isp);
+		clk_disable_unprepare(clk->isp);
+		clk_disable_unprepare(clk->isp_jpe);
+		clk_disable_unprepare(clk->pclkin_isp);
+		if (CHIP_TYPE == 3368 || CHIP_TYPE == 3366) {
+			clk_disable_unprepare(clk->cif_clk_out);
 			clk_disable_unprepare(clk->pclk_dphyrx);
-			clk_disable_unprepare(clk->clk_vio0_noc);
+			if (CHIP_TYPE == 3368)
+				clk_disable_unprepare(clk->clk_vio0_noc);
+		} else{
+			clk_disable_unprepare(clk->clk_mipi_24m);
+		}
+		/* clk_disable_unprepare(clk->pd_isp); */
 
-		}else{
-	        clk_disable_unprepare(clk->clk_mipi_24m); 
+		/* rockchip_clear_system_status(SYS_STATUS_ISP); */
+		clk->in_on = false;
+		camsys_trace(1, "%s clock in turn off",
+			dev_name(camsys_dev->miscdev.this_device));
 		}
-		clk_disable_unprepare(clk->pd_isp);
+	}
 
-		rockchip_clear_system_status(SYS_STATUS_ISP);
-        clk->in_on = false;
-        camsys_trace(1, "%s clock in turn off",dev_name(camsys_dev->miscdev.this_device));
-    }
-    
-    return 0;
+	return 0;
 }
-static int camsys_mrv_clkout_cb(void *ptr, unsigned int on,unsigned int inclk)
+
+static int camsys_mrv_clkout_cb(void *ptr, unsigned int on, unsigned int inclk)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    camsys_mrv_clk_t *clk = (camsys_mrv_clk_t*)camsys_dev->clk;
-    
-    mutex_lock(&clk->lock);
-    if (on && (clk->out_on != on)) {  
-
-        clk_set_rate(clk->cif_clk_out,inclk);
-        clk_prepare_enable(clk->cif_clk_out);
-        
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	camsys_mrv_clk_t *clk = (camsys_mrv_clk_t *)camsys_dev->clk;
+
+	mutex_lock(&clk->lock);
+	if (on && (clk->out_on != on)) {
+
+		pm_runtime_get_sync(&camsys_dev->pdev->dev);
+
+		clk_set_rate(clk->cif_clk_out, inclk);
+		clk_prepare_enable(clk->cif_clk_out);
 		clk->out_on = on;
-        camsys_trace(1, "%s clock out(rate: %dHz) turn on",dev_name(camsys_dev->miscdev.this_device),
-                    inclk);
-    } else if (!on && clk->out_on) {
-        if(!IS_ERR_OR_NULL(clk->cif_clk_pll)) {
-            clk_set_parent(clk->cif_clk_out, clk->cif_clk_pll);
-        } else {
-            camsys_warn("%s clock out may be not off!", dev_name(camsys_dev->miscdev.this_device));
-        }
+		camsys_trace(1, "camsys %s clock out(rate: %dHz) turn on",
+			dev_name(camsys_dev->miscdev.this_device),
+					inclk);
+	} else if (!on && clk->out_on) {
+		if (!IS_ERR_OR_NULL(clk->cif_clk_pll)) {
+			clk_set_parent(clk->cif_clk_out,
+				clk->cif_clk_pll);
+		} else {
+			camsys_warn("%s clock out may be not off!",
+				dev_name(camsys_dev->miscdev.this_device));
+		}
 
-        clk_disable_unprepare( clk->cif_clk_out);
+		clk_disable_unprepare(clk->cif_clk_out);
 
-        clk->out_on = 0;
+		pm_runtime_disable(&camsys_dev->pdev->dev);
+		clk->out_on = 0;
 
-        camsys_trace(1, "%s clock out turn off",dev_name(camsys_dev->miscdev.this_device));
-    }
-    mutex_unlock(&clk->lock);    
+		camsys_trace(1, "%s clock out turn off",
+			dev_name(camsys_dev->miscdev.this_device));
+	}
+	mutex_unlock(&clk->lock);
 
-    return 0;
+	return 0;
 }
 static irqreturn_t camsys_mrv_irq(int irq, void *data)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)data;
-    camsys_irqstas_t *irqsta;
-    camsys_irqpool_t *irqpool;
-    unsigned int isp_mis,mipi_mis,mi_mis,*mis,jpg_mis,jpg_err_mis;
-	
-	unsigned int mi_ris,mi_imis;
-
-    isp_mis = __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_ISP_MIS));
-    mipi_mis = __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_MIPI_MIS));
-    jpg_mis = __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_JPG_MIS));
-    jpg_err_mis = __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_JPG_ERR_MIS));
-	mi_mis = __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_MI_MIS));
-#if 1	
-	mi_ris =  __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_MI_RIS));
-	mi_imis = __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_MI_IMIS));
-	while((mi_ris & mi_imis) != mi_mis){
-		camsys_trace(2,"mi_mis status erro,mi_mis 0x%x,mi_ris 0x%x,imis 0x%x\n",mi_mis,mi_ris,mi_imis);
-		mi_mis = __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_MI_MIS));
-		mi_ris =  __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_MI_RIS));
-    	mi_imis = __raw_readl((void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_MI_IMIS));
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)data;
+	camsys_irqstas_t *irqsta;
+	camsys_irqpool_t *irqpool;
+	unsigned int isp_mis, mipi_mis, mi_mis, *mis, jpg_mis, jpg_err_mis;
+	unsigned int mi_ris, mi_imis;
+
+	isp_mis = __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_ISP_MIS));
+	mipi_mis = __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_MIPI_MIS));
+	jpg_mis = __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_JPG_MIS));
+	jpg_err_mis = __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_JPG_ERR_MIS));
+	mi_mis = __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_MI_MIS));
+
+	mi_ris =  __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_MI_RIS));
+	mi_imis = __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_MI_IMIS));
+	while ((mi_ris & mi_imis) != mi_mis) {
+	camsys_trace(2, "mi_mis status erro,mi_mis 0x%x,"
+				"mi_ris 0x%x,imis 0x%x\n",
+				mi_mis, mi_ris, mi_imis);
+	mi_mis = __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_MI_MIS));
+	mi_ris =  __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_MI_RIS));
+	mi_imis = __raw_readl((void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_MI_IMIS));
 	}
 
-#endif
+	__raw_writel(isp_mis, (void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_ISP_ICR));
+	__raw_writel(mipi_mis, (void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_MIPI_ICR));
+	__raw_writel(jpg_mis, (void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_JPG_ICR));
+	__raw_writel(jpg_err_mis, (void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_JPG_ERR_ICR));
+	__raw_writel(mi_mis, (void volatile *)
+				(camsys_dev->devmems.registermem->vir_base +
+				MRV_MI_ICR));
+
+	spin_lock(&camsys_dev->irq.lock);
+	if (!list_empty(&camsys_dev->irq.irq_pool)) {
+		list_for_each_entry(irqpool, &camsys_dev->irq.irq_pool, list) {
+			if (irqpool->pid != 0) {
+				switch (irqpool->mis) {
+				case MRV_ISP_MIS:
+				{
+					mis = &isp_mis;
+					break;
+				}
+
+				case MRV_MIPI_MIS:
+				{
+					mis = &mipi_mis;
+					break;
+				}
+				case MRV_MI_MIS:
+				{
+					mis = &mi_mis;
+					break;
+				}
+
+				case MRV_JPG_MIS:
+				{
+					mis = &jpg_mis;
+					break;
+				}
+
+				case MRV_JPG_ERR_MIS:
+				{
+					mis = &jpg_err_mis;
+					break;
+				}
+
+				default:
+				{
+					camsys_trace(2,
+						"Thread(pid:%d) irqpool mis(%d) is invalidate",
+						irqpool->pid, irqpool->mis);
+					goto end;
+				}
+				}
+
+				if (*mis != 0) {
+					spin_lock(&irqpool->lock);
+					if (!list_empty(&irqpool->deactive)) {
+						irqsta =
+							list_first_entry(
+							&irqpool->deactive,
+							camsys_irqstas_t,
+							list);
+						irqsta->sta.mis = *mis;
+						list_del_init(&irqsta->list);
+						list_add_tail(&irqsta->list,
+							&irqpool->active);
+						wake_up(&irqpool->done);
+					}
+					spin_unlock(&irqpool->lock);
+				}
+			}
+		}
+	}
+end:
+	spin_unlock(&camsys_dev->irq.lock);
 
-    __raw_writel(isp_mis, (void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_ISP_ICR)); 
-    __raw_writel(mipi_mis, (void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_MIPI_ICR)); 
-    __raw_writel(jpg_mis, (void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_JPG_ICR));
-    __raw_writel(jpg_err_mis, (void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_JPG_ERR_ICR));
-	__raw_writel(mi_mis, (void volatile *)(camsys_dev->devmems.registermem->vir_base + MRV_MI_ICR)); 
-
-    spin_lock(&camsys_dev->irq.lock);
-    if (!list_empty(&camsys_dev->irq.irq_pool)) {
-        list_for_each_entry(irqpool, &camsys_dev->irq.irq_pool, list) {
-            if (irqpool->pid != 0) {
-                switch(irqpool->mis)
-                {
-                    case MRV_ISP_MIS:
-                    {
-                        mis = &isp_mis;
-                        break;
-                    }
-
-                    case MRV_MIPI_MIS:
-                    {
-                        mis = &mipi_mis;
-                        break;
-                    }
-                    case MRV_MI_MIS:
-                    {
-                        mis = &mi_mis;
-                        break;
-                    }
-
-                    case MRV_JPG_MIS:
-                    {
-                        mis = &jpg_mis;
-                        break;
-                    }
-
-                    case MRV_JPG_ERR_MIS:
-                    {
-                        mis = &jpg_err_mis;
-                        break;
-                    }
-
-                    default:     
-                    {
-                        camsys_trace(2,"Thread(pid:%d) irqpool mis(%d) is invalidate",irqpool->pid,irqpool->mis);
-                        goto end;
-                    }
-                }
-
-                if (*mis != 0) {
-                    spin_lock(&irqpool->lock);
-                    if (!list_empty(&irqpool->deactive)) {
-                        irqsta = list_first_entry(&irqpool->deactive, camsys_irqstas_t, list);
-                        irqsta->sta.mis = *mis;                                                 
-                        list_del_init(&irqsta->list);            
-                        list_add_tail(&irqsta->list,&irqpool->active);                        
-                        wake_up(&irqpool->done);
-                    }
-                    spin_unlock(&irqpool->lock);
-                }
-            }
-        }
-    }
-end:    
-    spin_unlock(&camsys_dev->irq.lock);
-
-    return IRQ_HANDLED;
+	return IRQ_HANDLED;
 }
+
 static int camsys_mrv_remove_cb(struct platform_device *pdev)
 {
-    camsys_dev_t *camsys_dev = platform_get_drvdata(pdev);
-    camsys_mrv_clk_t *mrv_clk=NULL;
-
-    if (camsys_dev->clk != NULL) {
-
-        mrv_clk = (camsys_mrv_clk_t*)camsys_dev->clk;
-        if (mrv_clk->out_on)
-            camsys_mrv_clkout_cb(mrv_clk,0,0);
-        if (mrv_clk->in_on)
-            camsys_mrv_clkin_cb(mrv_clk,0);
-    
-        if (!IS_ERR_OR_NULL(mrv_clk->pd_isp)) {
-		 	devm_clk_put(&pdev->dev,mrv_clk->pd_isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->aclk_isp)) {
-            devm_clk_put(&pdev->dev,mrv_clk->aclk_isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->hclk_isp)) {
-            devm_clk_put(&pdev->dev,mrv_clk->hclk_isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->isp)) {
-            devm_clk_put(&pdev->dev,mrv_clk->isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->isp_jpe)) {
-            devm_clk_put(&pdev->dev,mrv_clk->isp_jpe);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->pclkin_isp)) {
-            devm_clk_put(&pdev->dev,mrv_clk->pclkin_isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->cif_clk_out)) {
-            devm_clk_put(&pdev->dev,mrv_clk->cif_clk_out);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->clk_vio0_noc)) {
-            devm_clk_put(&pdev->dev,mrv_clk->clk_vio0_noc);
-        }
-
-        kfree(mrv_clk);
-        mrv_clk = NULL;
-    }
-
-    return 0;
+	camsys_dev_t *camsys_dev = platform_get_drvdata(pdev);
+	camsys_mrv_clk_t *mrv_clk = NULL;
+
+	if (camsys_dev->clk != NULL) {
+
+		mrv_clk = (camsys_mrv_clk_t *)camsys_dev->clk;
+		if (mrv_clk->out_on)
+			camsys_mrv_clkout_cb(mrv_clk, 0, 0);
+		if (mrv_clk->in_on)
+			camsys_mrv_clkin_cb(mrv_clk, 0);
+
+		if (!IS_ERR_OR_NULL(mrv_clk->pd_isp)) {
+			devm_clk_put(&pdev->dev, mrv_clk->pd_isp);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->aclk_isp)) {
+			devm_clk_put(&pdev->dev, mrv_clk->aclk_isp);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->hclk_isp)) {
+			devm_clk_put(&pdev->dev, mrv_clk->hclk_isp);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->isp)) {
+			devm_clk_put(&pdev->dev, mrv_clk->isp);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->isp_jpe)) {
+			devm_clk_put(&pdev->dev, mrv_clk->isp_jpe);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->pclkin_isp)) {
+			devm_clk_put(&pdev->dev, mrv_clk->pclkin_isp);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->cif_clk_out)) {
+			devm_clk_put(&pdev->dev, mrv_clk->cif_clk_out);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->clk_vio0_noc)) {
+			devm_clk_put(&pdev->dev, mrv_clk->clk_vio0_noc);
+		}
+
+		if (!IS_ERR_OR_NULL(mrv_clk->hclk_isp0_noc)) {
+			devm_clk_put(&pdev->dev, mrv_clk->hclk_isp0_noc);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->hclk_isp0_wrapper)) {
+			devm_clk_put(&pdev->dev, mrv_clk->hclk_isp0_wrapper);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->hclk_isp1_noc)) {
+			devm_clk_put(&pdev->dev, mrv_clk->hclk_isp1_noc);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->hclk_isp1_wrapper)) {
+			devm_clk_put(&pdev->dev, mrv_clk->hclk_isp1_wrapper);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->aclk_isp0_noc)) {
+			devm_clk_put(&pdev->dev, mrv_clk->aclk_isp0_noc);
+		}
+
+		if (!IS_ERR_OR_NULL(mrv_clk->aclk_isp0_wrapper)) {
+			devm_clk_put(&pdev->dev, mrv_clk->aclk_isp0_wrapper);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->aclk_isp1_noc)) {
+			devm_clk_put(&pdev->dev, mrv_clk->aclk_isp1_noc);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->aclk_isp1_wrapper)) {
+			devm_clk_put(&pdev->dev, mrv_clk->aclk_isp1_wrapper);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->clk_isp0)) {
+			devm_clk_put(&pdev->dev, mrv_clk->clk_isp0);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->clk_isp1)) {
+			devm_clk_put(&pdev->dev, mrv_clk->clk_isp1);
+		}
+		if (!IS_ERR_OR_NULL(mrv_clk->pclkin_isp1)) {
+			devm_clk_put(&pdev->dev, mrv_clk->pclkin_isp1);
+		}
+		if (CHIP_TYPE == 3399)
+			pm_runtime_disable(&pdev->dev);
+		kfree(mrv_clk);
+		mrv_clk = NULL;
+	}
+
+	return 0;
 }
 int camsys_mrv_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev)
 {
-    int err = 0;   
-    camsys_mrv_clk_t *mrv_clk=NULL;
-    
-	err = request_irq(camsys_dev->irq.irq_id, camsys_mrv_irq, IRQF_SHARED, CAMSYS_MARVIN_IRQNAME,camsys_dev);
-    if (err) {
-        camsys_err("request irq for %s failed",CAMSYS_MARVIN_IRQNAME);
-        goto end;
-    }
-
-    //Clk and Iomux init
-    mrv_clk = kzalloc(sizeof(camsys_mrv_clk_t),GFP_KERNEL);
-    if (mrv_clk == NULL) {
-        camsys_err("Allocate camsys_mrv_clk_t failed!");
-        err = -EINVAL;
-        goto clk_failed;
-    }
-    if(CHIP_TYPE == 3368){
-	    mrv_clk->pd_isp = devm_clk_get(&pdev->dev, "pd_isp");
-	    mrv_clk->aclk_isp = devm_clk_get(&pdev->dev, "aclk_isp");
-	    mrv_clk->hclk_isp = devm_clk_get(&pdev->dev, "hclk_isp");
-	    mrv_clk->isp = devm_clk_get(&pdev->dev, "clk_isp");
-	    mrv_clk->isp_jpe = devm_clk_get(&pdev->dev, "clk_isp_jpe");
-	    mrv_clk->pclkin_isp = devm_clk_get(&pdev->dev, "pclkin_isp");
-	    mrv_clk->cif_clk_out = devm_clk_get(&pdev->dev, "clk_cif_out");
-	    mrv_clk->cif_clk_pll = devm_clk_get(&pdev->dev, "clk_cif_pll");
-	    mrv_clk->pclk_dphyrx = devm_clk_get(&pdev->dev, "pclk_dphyrx");    
-	    mrv_clk->clk_vio0_noc = devm_clk_get(&pdev->dev, "clk_vio0_noc");
-
-		if (IS_ERR_OR_NULL(mrv_clk->aclk_isp) || IS_ERR_OR_NULL(mrv_clk->hclk_isp) ||
-	        IS_ERR_OR_NULL(mrv_clk->isp) || IS_ERR_OR_NULL(mrv_clk->isp_jpe) || IS_ERR_OR_NULL(mrv_clk->pclkin_isp) || 
-	        IS_ERR_OR_NULL(mrv_clk->cif_clk_out) || IS_ERR_OR_NULL(mrv_clk->pclk_dphyrx)||
-	        IS_ERR_OR_NULL(mrv_clk->pd_isp) || IS_ERR_OR_NULL(mrv_clk->clk_vio0_noc)) {
-	        camsys_err("Get %s clock resouce failed!\n",miscdev_name);
-	        err = -EINVAL;
-	        goto clk_failed;
-	    }
-    }else{
-	    mrv_clk->pd_isp = devm_clk_get(&pdev->dev, "pd_isp");
-	    mrv_clk->aclk_isp = devm_clk_get(&pdev->dev, "aclk_isp");
-	    mrv_clk->hclk_isp = devm_clk_get(&pdev->dev, "hclk_isp");
-	    mrv_clk->isp = devm_clk_get(&pdev->dev, "clk_isp");
-	    mrv_clk->isp_jpe = devm_clk_get(&pdev->dev, "clk_isp_jpe");
-	    mrv_clk->pclkin_isp = devm_clk_get(&pdev->dev, "pclkin_isp");
-	    mrv_clk->cif_clk_out = devm_clk_get(&pdev->dev, "clk_cif_out");
-	    mrv_clk->cif_clk_pll = devm_clk_get(&pdev->dev, "clk_cif_pll");
-	    mrv_clk->clk_mipi_24m = devm_clk_get(&pdev->dev,"clk_mipi_24m"); 
-	    
-		if (IS_ERR_OR_NULL(mrv_clk->pd_isp) || IS_ERR_OR_NULL(mrv_clk->aclk_isp) || IS_ERR_OR_NULL(mrv_clk->hclk_isp) ||
-	        IS_ERR_OR_NULL(mrv_clk->isp) || IS_ERR_OR_NULL(mrv_clk->isp_jpe) || IS_ERR_OR_NULL(mrv_clk->pclkin_isp) || 
-	        IS_ERR_OR_NULL(mrv_clk->cif_clk_out) || IS_ERR_OR_NULL(mrv_clk->clk_mipi_24m)) {
-	        camsys_err("Get %s clock resouce failed!\n",miscdev_name);
-	        err = -EINVAL;
-	        goto clk_failed;
-	    }
+	int err = 0;
+	camsys_mrv_clk_t *mrv_clk = NULL;
+	const char *compatible = NULL;
+
+	err = request_irq(camsys_dev->irq.irq_id, camsys_mrv_irq,
+					IRQF_SHARED, CAMSYS_MARVIN_IRQNAME,
+					camsys_dev);
+	if (err) {
+		camsys_err("request irq for %s failed", CAMSYS_MARVIN_IRQNAME);
+		goto end;
 	}
-    clk_set_rate(mrv_clk->isp,210000000);
-    clk_set_rate(mrv_clk->isp_jpe, 210000000);
-    
-    mutex_init(&mrv_clk->lock);
-    
-    mrv_clk->in_on = false;
-    mrv_clk->out_on = 0;
-        
-    camsys_dev->clk = (void*)mrv_clk;
-    camsys_dev->clkin_cb = camsys_mrv_clkin_cb;
-    camsys_dev->clkout_cb = camsys_mrv_clkout_cb;
-    camsys_dev->reset_cb = camsys_mrv_reset_cb;
-    camsys_dev->iomux = camsys_mrv_iomux_cb;
-    camsys_dev->flash_trigger_cb = camsys_mrv_flash_trigger_cb;
-    camsys_dev->iommu_cb = camsys_mrv_iommu_cb;
-    
-    camsys_dev->miscdev.minor = MISC_DYNAMIC_MINOR;
-    camsys_dev->miscdev.name = miscdev_name;
-    camsys_dev->miscdev.nodename = miscdev_name;
-    camsys_dev->miscdev.fops = &camsys_fops;
-
-    err = misc_register(&camsys_dev->miscdev);
-    if (err < 0) {
-        camsys_err("misc register %s failed!",miscdev_name);
-        goto misc_register_failed;
-    }   
-
-    //Variable init
-    camsys_dev->dev_id = CAMSYS_DEVID_MARVIN;
-    camsys_dev->platform_remove = camsys_mrv_remove_cb;
-   
-   	 
-    return 0;
-misc_register_failed:
-    if (!IS_ERR_OR_NULL(camsys_dev->miscdev.this_device)) {
-        misc_deregister(&camsys_dev->miscdev);
-    }
 
-clk_failed:
-    if (mrv_clk != NULL) {
-        if (!IS_ERR_OR_NULL(mrv_clk->pd_isp)) {
-            clk_put(mrv_clk->pd_isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->aclk_isp)) {
-            clk_put(mrv_clk->aclk_isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->hclk_isp)) {
-            clk_put(mrv_clk->hclk_isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->isp)) {
-            clk_put(mrv_clk->isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->isp_jpe)) {
-            clk_put(mrv_clk->isp_jpe);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->pclkin_isp)) {
-            clk_put(mrv_clk->pclkin_isp);
-        }
-        if (!IS_ERR_OR_NULL(mrv_clk->cif_clk_out)) {
-            clk_put(mrv_clk->cif_clk_out);
-        }
-		if(CHIP_TYPE == 3368){
-	        if (!IS_ERR_OR_NULL(mrv_clk->pclk_dphyrx)) {
-	            clk_put(mrv_clk->pclk_dphyrx);
-	        }
-		if (!IS_ERR_OR_NULL(mrv_clk->clk_vio0_noc)) {
-			clk_put(mrv_clk->clk_vio0_noc);
+	/* Clk and Iomux init */
+	mrv_clk = kzalloc(sizeof(camsys_mrv_clk_t), GFP_KERNEL);
+	if (mrv_clk == NULL) {
+		camsys_err("Allocate camsys_mrv_clk_t failed!");
+		err = -EINVAL;
+		goto clk_failed;
+	}
+	if (CHIP_TYPE == 3368 || CHIP_TYPE == 3366) {
+		/* mrv_clk->pd_isp = devm_clk_get(&pdev->dev, "pd_isp"); */
+		mrv_clk->aclk_isp	 = devm_clk_get(&pdev->dev, "aclk_isp");
+		mrv_clk->hclk_isp	 = devm_clk_get(&pdev->dev, "hclk_isp");
+		mrv_clk->isp		 = devm_clk_get(&pdev->dev, "clk_isp");
+		mrv_clk->isp_jpe     = devm_clk_get(&pdev->dev, "clk_isp_jpe");
+		mrv_clk->pclkin_isp  = devm_clk_get(&pdev->dev, "pclkin_isp");
+		mrv_clk->cif_clk_out = devm_clk_get(&pdev->dev, "clk_cif_out");
+		mrv_clk->cif_clk_pll = devm_clk_get(&pdev->dev, "clk_cif_pll");
+		mrv_clk->pclk_dphyrx = devm_clk_get(&pdev->dev, "pclk_dphyrx");
+		if (CHIP_TYPE == 3368) {
+			mrv_clk->clk_vio0_noc =
+				devm_clk_get(&pdev->dev, "clk_vio0_noc");
+			if (IS_ERR_OR_NULL(mrv_clk->clk_vio0_noc)) {
+				camsys_err("Get %s clock resouce failed!\n",
+					miscdev_name);
+				err = -EINVAL;
+				goto clk_failed;
+			}
+
 		}
+
+		if (IS_ERR_OR_NULL(mrv_clk->aclk_isp)	 ||
+			IS_ERR_OR_NULL(mrv_clk->hclk_isp)	 ||
+			IS_ERR_OR_NULL(mrv_clk->isp)		 ||
+			IS_ERR_OR_NULL(mrv_clk->isp_jpe)	 ||
+			IS_ERR_OR_NULL(mrv_clk->pclkin_isp)  ||
+			IS_ERR_OR_NULL(mrv_clk->cif_clk_out) ||
+			IS_ERR_OR_NULL(mrv_clk->pclk_dphyrx)) {
+			camsys_err("Get %s clock resouce failed!\n",
+				miscdev_name);
+			err = -EINVAL;
+			goto clk_failed;
+		}
+
+		clk_set_rate(mrv_clk->isp, 210000000);
+		clk_set_rate(mrv_clk->isp_jpe, 210000000);
+
+	} else if (CHIP_TYPE == 3399) {
+
+		pm_runtime_enable(&pdev->dev);
+		mrv_clk->hclk_isp0_noc	   =
+			devm_clk_get(&pdev->dev, "hclk_isp0_noc");
+		mrv_clk->hclk_isp0_wrapper =
+			devm_clk_get(&pdev->dev, "hclk_isp0_wrapper");
+		mrv_clk->aclk_isp0_noc	   =
+			devm_clk_get(&pdev->dev, "aclk_isp0_noc");
+		mrv_clk->aclk_isp0_wrapper =
+			devm_clk_get(&pdev->dev, "aclk_isp0_wrapper");
+		mrv_clk->clk_isp0		   =
+			devm_clk_get(&pdev->dev, "clk_isp0");
+		mrv_clk->cif_clk_out	   =
+			devm_clk_get(&pdev->dev, "clk_cif_out");
+		mrv_clk->cif_clk_pll	   =
+			devm_clk_get(&pdev->dev, "clk_cif_pll");
+		mrv_clk->pclk_dphyrx	   =
+			devm_clk_get(&pdev->dev, "pclk_dphyrx");
+		mrv_clk->pclk_dphy_ref	   =
+			devm_clk_get(&pdev->dev, "pclk_dphy_ref");
+
+		mrv_clk->hclk_isp1_noc	   =
+			devm_clk_get(&pdev->dev, "hclk_isp1_noc");
+		mrv_clk->hclk_isp1_wrapper =
+			devm_clk_get(&pdev->dev, "hclk_isp1_wrapper");
+		mrv_clk->aclk_isp1_noc	   =
+			devm_clk_get(&pdev->dev, "aclk_isp1_noc");
+		mrv_clk->aclk_isp1_wrapper =
+			devm_clk_get(&pdev->dev, "aclk_isp1_wrapper");
+		mrv_clk->pclkin_isp        =
+			devm_clk_get(&pdev->dev, "pclk_isp1");
+
+		mrv_clk->clk_isp1		   =
+			devm_clk_get(&pdev->dev, "clk_isp1");
+		mrv_clk->pclk_dphytxrx	   =
+			devm_clk_get(&pdev->dev, "pclk_dphytxrx");
+
+		if (IS_ERR_OR_NULL(mrv_clk->hclk_isp0_noc)       ||
+			IS_ERR_OR_NULL(mrv_clk->hclk_isp0_wrapper)   ||
+			IS_ERR_OR_NULL(mrv_clk->aclk_isp0_noc)       ||
+			IS_ERR_OR_NULL(mrv_clk->aclk_isp0_wrapper)   ||
+			IS_ERR_OR_NULL(mrv_clk->clk_isp0)            ||
+			IS_ERR_OR_NULL(mrv_clk->cif_clk_out)		 ||
+			IS_ERR_OR_NULL(mrv_clk->cif_clk_pll)         ||
+			IS_ERR_OR_NULL(mrv_clk->pclk_dphyrx)) {
+			camsys_err("Get %s clock resouce failed!\n",
+				miscdev_name);
+			err = -EINVAL;
+			goto clk_failed;
+		}
+
+		err = of_property_read_string(pdev->dev.of_node,
+			"compatible", &compatible);
+		if (err < 0) {
+			camsys_err("get compatible failed!");
+		} else {
+			camsys_trace(1, "compatible is %s\n", compatible);
+		}
+		if (strstr(compatible, "isp1")) {
+			clk_set_rate(mrv_clk->clk_isp1, 210000000);
+		} else{
+			clk_set_rate(mrv_clk->clk_isp0, 210000000);
+		}
+
+	} else{
+		mrv_clk->pd_isp		  =
+			devm_clk_get(&pdev->dev, "pd_isp");
+		mrv_clk->aclk_isp	  =
+			devm_clk_get(&pdev->dev, "aclk_isp");
+		mrv_clk->hclk_isp	  =
+			devm_clk_get(&pdev->dev, "hclk_isp");
+		mrv_clk->isp		  =
+			devm_clk_get(&pdev->dev, "clk_isp");
+		mrv_clk->isp_jpe	  =
+			devm_clk_get(&pdev->dev, "clk_isp_jpe");
+		mrv_clk->pclkin_isp   =
+			devm_clk_get(&pdev->dev, "pclkin_isp");
+		mrv_clk->cif_clk_out  =
+			devm_clk_get(&pdev->dev, "clk_cif_out");
+		mrv_clk->cif_clk_pll  =
+			devm_clk_get(&pdev->dev, "clk_cif_pll");
+		mrv_clk->clk_mipi_24m =
+			devm_clk_get(&pdev->dev, "clk_mipi_24m");
+
+		if (IS_ERR_OR_NULL(mrv_clk->pd_isp)		 ||
+			IS_ERR_OR_NULL(mrv_clk->aclk_isp)	 ||
+			IS_ERR_OR_NULL(mrv_clk->hclk_isp)	 ||
+			IS_ERR_OR_NULL(mrv_clk->isp)		 ||
+			IS_ERR_OR_NULL(mrv_clk->isp_jpe)	 ||
+			IS_ERR_OR_NULL(mrv_clk->pclkin_isp)  ||
+			IS_ERR_OR_NULL(mrv_clk->cif_clk_out) ||
+			IS_ERR_OR_NULL(mrv_clk->clk_mipi_24m)) {
+			camsys_err("Get %s clock resouce failed!\n",
+				miscdev_name);
+			err = -EINVAL;
+			goto clk_failed;
+		}
+
+		clk_set_rate(mrv_clk->isp, 210000000);
+		clk_set_rate(mrv_clk->isp_jpe, 210000000);
+	}
+
+
+	mutex_init(&mrv_clk->lock);
+
+	mrv_clk->in_on = false;
+	mrv_clk->out_on = 0;
+
+	camsys_dev->clk = (void *)mrv_clk;
+	camsys_dev->clkin_cb = camsys_mrv_clkin_cb;
+	camsys_dev->clkout_cb = camsys_mrv_clkout_cb;
+	camsys_dev->reset_cb = camsys_mrv_reset_cb;
+	camsys_dev->iomux = camsys_mrv_iomux_cb;
+	camsys_dev->flash_trigger_cb = camsys_mrv_flash_trigger_cb;
+	camsys_dev->iommu_cb = camsys_mrv_iommu_cb;
+
+	camsys_dev->miscdev.minor = MISC_DYNAMIC_MINOR;
+	camsys_dev->miscdev.name = miscdev_name;
+	camsys_dev->miscdev.nodename = miscdev_name;
+	camsys_dev->miscdev.fops = &camsys_fops;
+
+	if (CHIP_TYPE == 3399) {
+		if (strstr(compatible, "isp1")) {
+			camsys_dev->miscdev.name = "camsys_marvin1";
+			camsys_dev->miscdev.nodename = "camsys_marvin1";
 		}
+	}
+
+	err = misc_register(&camsys_dev->miscdev);
+	if (err < 0) {
+		camsys_err("misc register %s failed!", miscdev_name);
+		goto misc_register_failed;
+	}
+	/* Variable init */
+	camsys_dev->dev_id = CAMSYS_DEVID_MARVIN;
+	camsys_dev->platform_remove = camsys_mrv_remove_cb;
+
+	return 0;
+misc_register_failed:
+	if (!IS_ERR_OR_NULL(camsys_dev->miscdev.this_device))
+		misc_deregister(&camsys_dev->miscdev);
+
+clk_failed:
+	if (mrv_clk != NULL) {
+		if (!IS_ERR_OR_NULL(mrv_clk->pd_isp))
+			clk_put(mrv_clk->pd_isp);
+
+		if (!IS_ERR_OR_NULL(mrv_clk->aclk_isp))
+			clk_put(mrv_clk->aclk_isp);
+
+		if (!IS_ERR_OR_NULL(mrv_clk->hclk_isp))
+			clk_put(mrv_clk->hclk_isp);
+
+		if (!IS_ERR_OR_NULL(mrv_clk->isp))
+			clk_put(mrv_clk->isp);
+
+		if (!IS_ERR_OR_NULL(mrv_clk->isp_jpe))
+			clk_put(mrv_clk->isp_jpe);
+
+		if (!IS_ERR_OR_NULL(mrv_clk->pclkin_isp))
+			clk_put(mrv_clk->pclkin_isp);
+
+		if (!IS_ERR_OR_NULL(mrv_clk->cif_clk_out))
+			clk_put(mrv_clk->cif_clk_out);
+
+	if (CHIP_TYPE == 3368 || CHIP_TYPE == 3366) {
+		if (!IS_ERR_OR_NULL(mrv_clk->pclk_dphyrx))
+			clk_put(mrv_clk->pclk_dphyrx);
+
+		if (!IS_ERR_OR_NULL(mrv_clk->clk_vio0_noc))
+		clk_put(mrv_clk->clk_vio0_noc);
+	}
+
+		kfree(mrv_clk);
+		mrv_clk = NULL;
+	}
 
-        kfree(mrv_clk);
-        mrv_clk = NULL;
-    }
-    
 end:
-    return err;
+	return err;
 }
 EXPORT_SYMBOL_GPL(camsys_mrv_probe_cb);
 
diff --git a/drivers/media/video/rk_camsys/camsys_marvin.h b/drivers/media/video/rk_camsys/camsys_marvin.h
index 31a0fc79e680..e30db8547932 100755
--- a/drivers/media/video/rk_camsys/camsys_marvin.h
+++ b/drivers/media/video/rk_camsys/camsys_marvin.h
@@ -5,66 +5,77 @@
 
 #define CAMSYS_MARVIN_IRQNAME                   "MarvinIrq"
 
-
-
 #define MRV_ISP_BASE                            0x400
-#define MRV_ISP_RIS                             (MRV_ISP_BASE+0x1c0)
-#define MRV_ISP_MIS                             (MRV_ISP_BASE+0x1c4)
-#define MRV_ISP_ICR                             (MRV_ISP_BASE+0x1c8)
+#define MRV_ISP_RIS                             (MRV_ISP_BASE + 0x1c0)
+#define MRV_ISP_MIS                             (MRV_ISP_BASE + 0x1c4)
+#define MRV_ISP_ICR                             (MRV_ISP_BASE + 0x1c8)
 
 #define MRV_MIPI_BASE                           0x1C00
-#define MRV_MIPI_MIS                            (MRV_MIPI_BASE+0x10)
-#define MRV_MIPI_ICR                            (MRV_MIPI_BASE+0x14)
+#define MRV_MIPI_MIS                            (MRV_MIPI_BASE + 0x10)
+#define MRV_MIPI_ICR                            (MRV_MIPI_BASE + 0x14)
 
 #define MRV_MI_BASE                             (0x1400)
 
-#define MRV_MI_MP_Y_OFFS_CNT_START                   (MRV_MI_BASE+0x14)
-#define MRV_MI_INIT                   (MRV_MI_BASE+0x4)
-#define MRV_MI_MP_Y_BASE_AD                   (MRV_MI_BASE+0x8)
-#define MRV_MI_Y_BASE_AD_SHD                   (MRV_MI_BASE+0x78)
-#define MRV_MI_Y_OFFS_CNT_SHD                   (MRV_MI_BASE+0x80)
-#define MRV_MI_IMIS                              (MRV_MI_BASE+0xf8)
-#define MRV_MI_RIS                              (MRV_MI_BASE+0xfc)
-#define MRV_MI_MIS                              (MRV_MI_BASE+0x100)
-#define MRV_MI_ICR                              (MRV_MI_BASE+0x104)
+#define MRV_MI_MP_Y_OFFS_CNT_START                   (MRV_MI_BASE + 0x14)
+#define MRV_MI_INIT                   (MRV_MI_BASE + 0x4)
+#define MRV_MI_MP_Y_BASE_AD                   (MRV_MI_BASE + 0x8)
+#define MRV_MI_Y_BASE_AD_SHD                   (MRV_MI_BASE + 0x78)
+#define MRV_MI_Y_OFFS_CNT_SHD                   (MRV_MI_BASE + 0x80)
+#define MRV_MI_IMIS                              (MRV_MI_BASE + 0xf8)
+#define MRV_MI_RIS                              (MRV_MI_BASE + 0xfc)
+#define MRV_MI_MIS                              (MRV_MI_BASE + 0x100)
+#define MRV_MI_ICR                              (MRV_MI_BASE + 0x104)
 
 #define MRV_FLASH_CONFIG                        (0x664)
 
 #define MRV_JPG_BASE                             (0x1800)
-#define MRV_JPG_ERR_RIS                          (MRV_JPG_BASE+0x6C)
-#define MRV_JPG_ERR_MIS                          (MRV_JPG_BASE+0x70)
-#define MRV_JPG_ERR_ICR                          (MRV_JPG_BASE+0x74)
-#define MRV_JPG_MIS                              (MRV_JPG_BASE+0x84)
-#define MRV_JPG_RIS                              (MRV_JPG_BASE+0x80)
-#define MRV_JPG_ICR                              (MRV_JPG_BASE+0x88)
-
-typedef enum IO_USE_TYPE_e{
-    USE_AS_GPIO,
-    USE_AS_ISP_INTERNAL,
-}IO_USE_TYPE_t;
+#define MRV_JPG_ERR_RIS                          (MRV_JPG_BASE + 0x6C)
+#define MRV_JPG_ERR_MIS                          (MRV_JPG_BASE + 0x70)
+#define MRV_JPG_ERR_ICR                          (MRV_JPG_BASE + 0x74)
+#define MRV_JPG_MIS                              (MRV_JPG_BASE + 0x84)
+#define MRV_JPG_RIS                              (MRV_JPG_BASE + 0x80)
+#define MRV_JPG_ICR                              (MRV_JPG_BASE + 0x88)
+
+typedef enum IO_USE_TYPE_e {
+	USE_AS_GPIO,
+	USE_AS_ISP_INTERNAL,
+} IO_USE_TYPE_t;
 
 typedef struct camsys_mrv_clk_s {
-    struct clk      *pd_isp;
-    struct clk      *hclk_isp;
-    struct clk      *aclk_isp;
-    struct clk      *isp;
-    struct clk      *isp_jpe;
-    struct clk      *pclkin_isp;
-    struct clk      *clk_mipi_24m;
-    struct clk      *clk_vio0_noc;
-    bool             in_on;
-
-    struct clk      *cif_clk_out;
-    struct clk      *cif_clk_pll;
+	struct clk      *pd_isp;
+	struct clk      *hclk_isp;
+	struct clk      *aclk_isp;
+	struct clk      *isp;
+	struct clk      *isp_jpe;
+	struct clk      *pclkin_isp;
+	struct clk      *clk_mipi_24m;
+	struct clk      *clk_vio0_noc;
+	bool             in_on;
+
+	struct clk      *cif_clk_out;
+	struct clk      *cif_clk_pll;
 	struct clk		*pclk_dphyrx;
-	
-    unsigned int     out_on;
 
-    struct mutex     lock;
+	unsigned int     out_on;
+
+	struct clk      *hclk_isp0_noc;
+	struct clk      *hclk_isp0_wrapper;
+	struct clk      *hclk_isp1_noc;
+	struct clk      *hclk_isp1_wrapper;
+	struct clk      *aclk_isp0_noc;
+	struct clk      *aclk_isp0_wrapper;
+	struct clk      *aclk_isp1_noc;
+	struct clk      *aclk_isp1_wrapper;
+	struct clk      *clk_isp0;
+	struct clk      *clk_isp1;
+	struct clk      *pclkin_isp1;
+	struct clk      *pclk_dphy_ref;
+	struct clk      *pclk_dphytxrx;
+
+	struct mutex     lock;
 } camsys_mrv_clk_t;
 
 int camsys_mrv_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev);
 
 #endif
 
-
diff --git a/drivers/media/video/rk_camsys/camsys_mipicsi_phy.c b/drivers/media/video/rk_camsys/camsys_mipicsi_phy.c
index 8094b7e654be..a19b5c4fba15 100755
--- a/drivers/media/video/rk_camsys/camsys_mipicsi_phy.c
+++ b/drivers/media/video/rk_camsys/camsys_mipicsi_phy.c
@@ -8,216 +8,280 @@ unsigned long rk_isp_base;
 
 static int camsys_mipiphy_clkin_cb(void *ptr, unsigned int on)
 {
-    camsys_mipiphy_clk_t *clk;
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    unsigned int i,phycnt;
-    
-    if (camsys_dev->mipiphy != NULL) {
-        phycnt = camsys_dev->mipiphy[0].phycnt;
-         
-        for (i=0; i<phycnt; i++) {
-            if (camsys_dev->mipiphy[i].clk != NULL) {
-                clk = (camsys_mipiphy_clk_t*)camsys_dev->mipiphy[i].clk;
-                if (on && !clk->on) {
-                    if (!IS_ERR_OR_NULL(clk->hclk))
-                        clk_prepare_enable(clk->hclk);  
-                    clk->on = on;
-                } else if (!on && clk->on) {
-                    if (!IS_ERR_OR_NULL(clk->hclk))
-                        clk_disable_unprepare(clk->hclk);                    
-                    clk->on = on;
-                }
-            }
-        }
-    }
-    if (on)
-        camsys_trace(1, "%s mipi phy clk in turn on",dev_name(camsys_dev->miscdev.this_device));
-    else 
-        camsys_trace(1, "%s mipi phy clk in turn off",dev_name(camsys_dev->miscdev.this_device));
-    
-    return 0;
+	camsys_mipiphy_clk_t *clk;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	unsigned int i, phycnt;
+
+	if (camsys_dev->mipiphy != NULL) {
+		phycnt = camsys_dev->mipiphy[0].phycnt;
+
+		for (i = 0; i < phycnt; i++) {
+			if (camsys_dev->mipiphy[i].clk != NULL) {
+				clk = (camsys_mipiphy_clk_t *)
+					camsys_dev->mipiphy[i].clk;
+				if (on && !clk->on) {
+					if (!IS_ERR_OR_NULL(clk->hclk))
+						clk_prepare_enable(clk->hclk);
+					clk->on = on;
+				} else if (!on && clk->on) {
+					if (!IS_ERR_OR_NULL(clk->hclk))
+						clk_disable_unprepare
+						(clk->hclk);
+					clk->on = on;
+				}
+			}
+		}
+	}
+	if (on)
+		camsys_trace(1, "%s mipi phy clk in turn on",
+		dev_name(camsys_dev->miscdev.this_device));
+	else
+		camsys_trace(1, "%s mipi phy clk in turn off",
+		dev_name(camsys_dev->miscdev.this_device));
+
+	return 0;
 }
 
-static int camsys_mipiphy_ops (void * ptr, camsys_mipiphy_t *phy)
+static int camsys_mipiphy_ops(void *ptr, camsys_mipiphy_t *phy)
 {
-    camsys_dev_t *camsys_dev = (camsys_dev_t*)ptr;
-    camsys_mipiphy_soc_para_t para;
-    camsys_soc_priv_t *soc;
-    
-    if (camsys_dev->soc) {
-        soc = (camsys_soc_priv_t*)camsys_dev->soc;
-        if (soc->soc_cfg) { 
-            para.camsys_dev = camsys_dev;
-            para.phy = phy;
-            (soc->soc_cfg)(Mipi_Phy_Cfg,(void*)&para);
-        } else {
-            camsys_err("camsys_dev->soc->soc_cfg is NULL!");
-        }
-    } else {
-        camsys_err("camsys_dev->soc is NULL!");
-    }
-    
-    return 0;
+	camsys_dev_t *camsys_dev = (camsys_dev_t *)ptr;
+	camsys_mipiphy_soc_para_t para;
+	camsys_soc_priv_t *soc;
+
+	if (camsys_dev->soc) {
+		soc = (camsys_soc_priv_t *)camsys_dev->soc;
+		if (soc->soc_cfg) {
+			para.camsys_dev = camsys_dev;
+			para.phy = phy;
+			(soc->soc_cfg)(camsys_dev, Mipi_Phy_Cfg, (void *)&para);
+		} else {
+			camsys_err("camsys_dev->soc->soc_cfg is NULL!");
+		}
+	} else {
+		camsys_err("camsys_dev->soc is NULL!");
+	}
+
+	return 0;
 }
 
 static int camsys_mipiphy_remove_cb(struct platform_device *pdev)
 {
-    camsys_dev_t *camsys_dev = platform_get_drvdata(pdev);
-    camsys_mipiphy_clk_t *phyclk;
-    unsigned int i;
-    
-    if (camsys_dev->mipiphy != NULL) {
-        for (i=0; i<camsys_dev->mipiphy[0].phycnt; i++) {
-            if (camsys_dev->mipiphy[i].reg != NULL) {
-                if (camsys_dev->mipiphy[i].reg->vir_base != 0) {
-                    iounmap((void __iomem *)camsys_dev->mipiphy[i].reg->vir_base);
-                    camsys_dev->mipiphy[i].reg->vir_base = 0;
-                }
-                kfree(camsys_dev->mipiphy[i].reg);
-                camsys_dev->mipiphy[i].reg = NULL;
-            }
-
-            if (camsys_dev->mipiphy[i].clk != NULL) {
-                phyclk = (camsys_mipiphy_clk_t*)camsys_dev->mipiphy[i].clk;
-                devm_clk_put(&pdev->dev,phyclk->hclk);
-
-                kfree(camsys_dev->mipiphy[i].clk);
-                camsys_dev->mipiphy[i].clk = NULL;
-            }
-        }
-    }
-	if(CHIP_TYPE == 3368){
-		if(camsys_dev->csiphy_reg != NULL){
+	camsys_dev_t *camsys_dev = platform_get_drvdata(pdev);
+	camsys_mipiphy_clk_t *phyclk;
+	unsigned int i = 0;
+	unsigned long vir_base = camsys_dev->mipiphy[i].reg->vir_base;
+
+	if (camsys_dev->mipiphy != NULL) {
+		for (i = 0; i < camsys_dev->mipiphy[0].phycnt; i++) {
+			if (camsys_dev->mipiphy[i].reg != NULL) {
+				if (camsys_dev->mipiphy[i].reg->vir_base != 0) {
+					iounmap((void __iomem *)vir_base);
+					vir_base = 0;
+				}
+				kfree(camsys_dev->mipiphy[i].reg);
+				camsys_dev->mipiphy[i].reg = NULL;
+			}
+
+			if (camsys_dev->mipiphy[i].clk != NULL) {
+				phyclk =
+					(camsys_mipiphy_clk_t *)
+					camsys_dev->mipiphy[i].clk;
+				devm_clk_put(&pdev->dev, phyclk->hclk);
+
+				kfree(camsys_dev->mipiphy[i].clk);
+				camsys_dev->mipiphy[i].clk = NULL;
+			}
+		}
+	}
+	if (CHIP_TYPE == 3368 || CHIP_TYPE == 3366 || CHIP_TYPE == 3399) {
+		if (camsys_dev->csiphy_reg != NULL) {
 			kfree(camsys_dev->csiphy_reg);
 			camsys_dev->csiphy_reg = NULL;
 		}
+
+		if (camsys_dev->dsiphy_reg != NULL) {
+			kfree(camsys_dev->dsiphy_reg);
+			camsys_dev->dsiphy_reg = NULL;
+		}
 	}
 
-    return 0;
+	return 0;
 }
-int camsys_mipiphy_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev)
+
+int camsys_mipiphy_probe_cb(
+struct platform_device *pdev, camsys_dev_t *camsys_dev)
 {
-    struct device *dev = &pdev->dev;
-    camsys_meminfo_t *meminfo;
-    camsys_phyinfo_t *mipiphy;
-    unsigned int mipiphy_cnt,phyreg[2];
-    char str[31];
-    struct clk* clk;
-    camsys_mipiphy_clk_t *phyclk;
-    int err,i;
+	struct device *dev = &pdev->dev;
+	camsys_meminfo_t *meminfo;
+	camsys_phyinfo_t *mipiphy;
+	unsigned int mipiphy_cnt, phyreg[2];
+	char str[31];
+	struct clk *clk;
+	camsys_mipiphy_clk_t *phyclk;
+	int err, i;
 	struct device_node *node;
-	const char *compatible = NULL;
-
-	err = of_property_read_string(dev->of_node->parent,"compatible",&compatible);	
-    if (err < 0) {
-        camsys_err("get compatible failed!");
-    } else {
-        camsys_trace(1, "compatible is %s\n",compatible);
-    }
-	if(strstr(compatible, "rk3368"))
-		CHIP_TYPE = 3368;
-	else if(strstr(compatible, "rk3288"))
-		CHIP_TYPE = 3288;
-	
-    err = of_property_read_u32(dev->of_node,"rockchip,isp,mipiphy",&mipiphy_cnt);
-    if (err < 0) {
-        camsys_err("get property(rockchip,isp,mipiphy) failed!");
-        goto fail;
-    } else {
-        camsys_trace(2, "%s have %d mipi phy\n",dev_name(&pdev->dev),mipiphy_cnt);
-    }
-    
-    mipiphy = kzalloc(sizeof(camsys_phyinfo_t)*mipiphy_cnt,GFP_KERNEL);
-    if (mipiphy == NULL) {
-        err = -ENOMEM;
-        camsys_err("malloc camsys_phyinfo_t failed!");
-        goto fail;
-    }
-
-    camsys_dev->mipiphy = mipiphy;
-
-    memset(str,0x00,sizeof(str));
-    for (i=0; i<mipiphy_cnt; i++) {
-        meminfo = NULL;
-        sprintf(str,"rockchip,isp,mipiphy%d,reg",i);
-        if (of_property_read_u32_array(dev->of_node,str,phyreg,2) == 0) {
-            meminfo = kzalloc(sizeof(camsys_meminfo_t),GFP_KERNEL);
-            if (meminfo == NULL) {                
-                camsys_err("malloc camsys_meminfo_t for mipiphy%d failed!",i);                
-            } else {
-                meminfo->vir_base = (unsigned long)ioremap(phyreg[0],phyreg[1]);
-                if (!meminfo->vir_base){
-                    camsys_err("%s ioremap %s failed",dev_name(&pdev->dev), str);                    
-                } else {
-                    strlcpy(meminfo->name, CAMSYS_MIPIPHY_MEM_NAME,sizeof(meminfo->name));
-                    meminfo->phy_base = phyreg[0];
-                    meminfo->size = phyreg[1];
-                }
-               
-                camsys_dev->mipiphy[i].reg = meminfo;
-            }
-        }
-
-        memset(str,sizeof(str),0x00);
-        sprintf(str,"hclk_mipiphy%d",i);
-
-        clk = devm_clk_get(&pdev->dev, str);
-        if (!IS_ERR_OR_NULL(clk)) {
-            phyclk = kzalloc(sizeof(camsys_mipiphy_clk_t),GFP_KERNEL);
-            if (phyclk == NULL) {
-                camsys_err("malloc camsys_mipiphy_clk_t for %s failed!",str);
-            } else {
-                phyclk->hclk = clk;
-            }
-
-            camsys_dev->mipiphy[i].clk = (void*)phyclk;
-        }
-
-        camsys_dev->mipiphy[i].phycnt = mipiphy_cnt;
-        camsys_dev->mipiphy[i].clkin_cb = camsys_mipiphy_clkin_cb;
-        camsys_dev->mipiphy[i].ops = camsys_mipiphy_ops;
-        camsys_dev->mipiphy[i].remove = camsys_mipiphy_remove_cb;
-
-        if (meminfo != NULL) {
-            camsys_trace(1,"%s mipi phy%d probe success(reg_phy: 0x%lx  reg_vir: 0x%lx  size: 0x%x)",
-                dev_name(&pdev->dev), i,meminfo->phy_base,meminfo->vir_base, meminfo->size);
-        } else {
-            camsys_trace(1,"%s mipi phy%d probe success(reg_phy: 0x%x  reg_vir: 0x%x  size: 0x%x)",
-                dev_name(&pdev->dev), i,0,0,0);
-        }
-
-    }   
-
-	if(CHIP_TYPE == 3368){
-		camsys_dev->csiphy_reg = kzalloc(sizeof(camsys_meminfo_t),GFP_KERNEL);
-	    if (camsys_dev->csiphy_reg == NULL) {                
-		    camsys_err("malloc camsys_meminfo_t for csiphy_reg failed!"); 
+
+	err = of_property_read_u32(dev->of_node,
+		"rockchip,isp,mipiphy", &mipiphy_cnt);
+	if (err < 0) {
+		camsys_err("get property(rockchip,isp,mipiphy) failed!");
+		goto fail;
+	} else {
+		camsys_trace(2, "%s have %d mipi phy\n",
+			dev_name(&pdev->dev), mipiphy_cnt);
+	}
+
+	mipiphy = kzalloc(sizeof(camsys_phyinfo_t)*mipiphy_cnt, GFP_KERNEL);
+	if (mipiphy == NULL) {
+		err = -ENOMEM;
+		camsys_err("malloc camsys_phyinfo_t failed!");
+		goto fail;
+	}
+
+	camsys_dev->mipiphy = mipiphy;
+
+	memset(str, 0x00, sizeof(str));
+	for (i = 0; i < mipiphy_cnt; i++) {
+		meminfo = NULL;
+		sprintf(str, "rockchip,isp,mipiphy%d,reg", i);
+		if (of_property_read_u32_array(
+				dev->of_node, str, phyreg, 2
+				) == 0
+			) {
+			meminfo = kzalloc(sizeof(camsys_meminfo_t), GFP_KERNEL);
+			if (meminfo == NULL) {
+				camsys_err(
+				"malloc camsys_meminfo_t for mipiphy%d failed!",
+				i);
+			} else {
+				meminfo->vir_base =
+					(unsigned long)
+					ioremap(phyreg[0], phyreg[1]);
+				if (!meminfo->vir_base) {
+					camsys_err("%s ioremap %s failed",
+						dev_name(&pdev->dev), str);
+				} else {
+					strlcpy(meminfo->name,
+						CAMSYS_MIPIPHY_MEM_NAME,
+						sizeof(meminfo->name));
+					meminfo->phy_base = phyreg[0];
+					meminfo->size = phyreg[1];
+				}
+				camsys_dev->mipiphy[i].reg = meminfo;
+			}
+		}
+
+		memset(str, sizeof(str), 0x00);
+		sprintf(str, "hclk_mipiphy%d", i);
+
+		clk = devm_clk_get(&pdev->dev, str);
+		if (!IS_ERR_OR_NULL(clk)) {
+			phyclk =
+				kzalloc(sizeof(camsys_mipiphy_clk_t),
+				GFP_KERNEL);
+			if (phyclk == NULL) {
+				camsys_err("malloc camsys_mipiphy_clk_t for %s failed!",
+					str);
+			} else {
+				phyclk->hclk = clk;
+			}
+
+			camsys_dev->mipiphy[i].clk = (void *)phyclk;
 		}
-		if (of_property_read_u32_array(dev->of_node,"rockchip,isp,csiphy,reg",phyreg,2) == 0) {
-			camsys_dev->csiphy_reg->vir_base = (unsigned long)ioremap(phyreg[0],phyreg[1]);
-	        if (!camsys_dev->csiphy_reg->vir_base){
-		        camsys_err("%s ioremap %s failed",dev_name(&pdev->dev), "rockchip,isp,csiphy,reg");                    
-	        } else {
-	        camsys_trace(1,"csiphy vir addr=0x%lx",camsys_dev->csiphy_reg->vir_base);
-		        strlcpy(camsys_dev->csiphy_reg->name, "Csi-DPHY",sizeof(camsys_dev->csiphy_reg->name));
-		        camsys_dev->csiphy_reg->phy_base = phyreg[0];
-		        camsys_dev->csiphy_reg->size = phyreg[1];
-	    	}
+
+		camsys_dev->mipiphy[i].phycnt = mipiphy_cnt;
+		camsys_dev->mipiphy[i].clkin_cb = camsys_mipiphy_clkin_cb;
+		camsys_dev->mipiphy[i].ops = camsys_mipiphy_ops;
+		camsys_dev->mipiphy[i].remove = camsys_mipiphy_remove_cb;
+
+		if (meminfo != NULL) {
+			camsys_trace(1, "%s mipi phy%d probe success "
+				"(reg_phy: 0x%lx  reg_vir: 0x%lx  size: 0x%x)\n",
+				dev_name(&pdev->dev), i, meminfo->phy_base,
+				meminfo->vir_base, meminfo->size);
+		} else {
+			camsys_trace(1, "%s mipi phy%d probe success "
+				"(reg_phy: 0x%x  reg_vir: 0x%x  size: 0x%x)\n",
+				dev_name(&pdev->dev), i, 0, 0, 0);
 		}
-		//get cru base
-	    node = of_parse_phandle(dev->of_node, "rockchip,cru", 0);
-	    rk_cru_base = (unsigned long)of_iomap(node, 0);
-		camsys_trace(1,"rk_cru_base=0x%lx",rk_cru_base);
-		//get grf base
-	    node = of_parse_phandle(dev->of_node, "rockchip,grf", 0);
-	    rk_grf_base = (unsigned long)of_iomap(node, 0);
-		camsys_trace(1,"rk_grf_base=0x%lx",rk_grf_base);
+
 	}
-	
-    return 0;
+
+	if (CHIP_TYPE == 3368 || CHIP_TYPE == 3366 || CHIP_TYPE == 3399) {
+
+		if (CHIP_TYPE == 3399) {
+			camsys_dev->dsiphy_reg =
+				kzalloc(sizeof(camsys_meminfo_t), GFP_KERNEL);
+			if (camsys_dev->dsiphy_reg == NULL) {
+				camsys_err("malloc camsys_meminfo_t for dsiphy_reg failed!");
+			}
+
+			if (of_property_read_u32_array(
+					dev->of_node,
+					"rockchip,isp,dsiphy,reg", phyreg, 2
+					) == 0
+				) {
+					camsys_dev->dsiphy_reg->vir_base =
+						(unsigned long)
+						ioremap(phyreg[0], phyreg[1]);
+				if (!camsys_dev->dsiphy_reg->vir_base) {
+					camsys_err("%s ioremap %s failed",
+						dev_name(&pdev->dev),
+						"rockchip,isp,dsiphy,reg");
+				} else {
+				strlcpy(camsys_dev->dsiphy_reg->name,
+					"Dsi-DPHY",
+					sizeof(camsys_dev->dsiphy_reg->name));
+				camsys_dev->dsiphy_reg->phy_base = phyreg[0];
+				camsys_dev->dsiphy_reg->size = phyreg[1];
+				}
+			}
+
+	} else {
+			camsys_dev->csiphy_reg =
+				kzalloc(sizeof(camsys_meminfo_t), GFP_KERNEL);
+			if (camsys_dev->csiphy_reg == NULL) {
+				camsys_err("malloc camsys_meminfo_t for csiphy_reg failed!");
+			}
+
+			if (of_property_read_u32_array(
+					dev->of_node,
+					"rockchip,isp,csiphy,reg", phyreg, 2
+					) == 0
+				) {
+				camsys_dev->csiphy_reg->vir_base =
+					(unsigned long)
+					ioremap(phyreg[0], phyreg[1]);
+				if (!camsys_dev->csiphy_reg->vir_base) {
+					camsys_err("%s ioremap %s failed",
+						dev_name(&pdev->dev),
+						"rockchip,isp,csiphy,reg");
+				} else {
+					strlcpy(camsys_dev->csiphy_reg->name,
+					"Csi-DPHY",
+					sizeof(camsys_dev->csiphy_reg->name));
+					camsys_dev->csiphy_reg->phy_base =
+						phyreg[0];
+					camsys_dev->csiphy_reg->size =
+						phyreg[1];
+				}
+			}
+		}
+
+		/* get cru base */
+		node = of_parse_phandle(dev->of_node, "rockchip,cru", 0);
+		camsys_dev->rk_cru_base = (unsigned long)of_iomap(node, 0);
+		camsys_trace(1, "rk_cru_base=0x%lx", camsys_dev->rk_cru_base);
+		/* get grf base */
+		node = of_parse_phandle(dev->of_node, "rockchip,grf", 0);
+		camsys_dev->rk_grf_base = (unsigned long)of_iomap(node, 0);
+		camsys_trace(1, "rk_grf_base=0x%lx", camsys_dev->rk_grf_base);
+	}
+
+	return 0;
 
 fail:
 
-    return err;
+	return err;
 }
 
diff --git a/drivers/media/video/rk_camsys/camsys_mipicsi_phy.h b/drivers/media/video/rk_camsys/camsys_mipicsi_phy.h
index 08f1bc520186..0be00a1c97df 100755
--- a/drivers/media/video/rk_camsys/camsys_mipicsi_phy.h
+++ b/drivers/media/video/rk_camsys/camsys_mipicsi_phy.h
@@ -4,10 +4,11 @@
 #include "camsys_internal.h"
 
 typedef struct camsys_mipiphy_clk_s {
-    struct clk* hclk;
+	struct clk *hclk;
 
-    unsigned int on;
+	unsigned int on;
 } camsys_mipiphy_clk_t;
 
-int camsys_mipiphy_probe_cb(struct platform_device *pdev, camsys_dev_t *camsys_dev);
+int camsys_mipiphy_probe_cb
+(struct platform_device *pdev, camsys_dev_t *camsys_dev);
 #endif
diff --git a/drivers/media/video/rk_camsys/camsys_soc_priv.c b/drivers/media/video/rk_camsys/camsys_soc_priv.c
index f4ca967ab5a2..82698a62931d 100755
--- a/drivers/media/video/rk_camsys/camsys_soc_priv.c
+++ b/drivers/media/video/rk_camsys/camsys_soc_priv.c
@@ -2,56 +2,69 @@
 #include "camsys_soc_priv.h"
 
 
-static camsys_soc_priv_t* camsys_soc_p;
+static camsys_soc_priv_t *camsys_soc_p;
 
-extern int camsys_rk3288_cfg (camsys_soc_cfg_t cfg_cmd, void* cfg_para);
-extern int camsys_rk3368_cfg (camsys_soc_cfg_t cfg_cmd, void* cfg_para);
-
-camsys_soc_priv_t* camsys_soc_get(void)
+extern int camsys_rk3288_cfg(
+	camsys_dev_t *camsys_dev, camsys_soc_cfg_t cfg_cmd, void *cfg_para);
+extern int camsys_rk3368_cfg(
+	camsys_dev_t *camsys_dev, camsys_soc_cfg_t cfg_cmd, void *cfg_para);
+extern int camsys_rk3366_cfg(
+	camsys_dev_t *camsys_dev, camsys_soc_cfg_t cfg_cmd, void *cfg_para);
+extern int camsys_rk3399_cfg(
+	camsys_dev_t *camsys_dev, camsys_soc_cfg_t cfg_cmd, void *cfg_para);
+camsys_soc_priv_t *camsys_soc_get(void)
 {
-    if (camsys_soc_p != NULL) {
-        return camsys_soc_p;
-    } else {
-        return NULL;
-    }
+	if (camsys_soc_p != NULL) {
+		return camsys_soc_p;
+	} else {
+		return NULL;
+	}
 }
 
-int camsys_soc_init(void)
-{    
-    camsys_soc_p = kzalloc(sizeof(camsys_soc_priv_t),GFP_KERNEL);
-    if (camsys_soc_p == NULL) {
-        camsys_err("malloc camsys_soc_priv_t failed!");
-        goto fail;
-    }
-
-#ifdef CONFIG_ARM64
-	strlcpy(camsys_soc_p->name,"camsys_rk3368",31);
-	camsys_soc_p->soc_cfg = camsys_rk3368_cfg;
-	camsys_err("camsys_soc_init exit!");
-#else
-	if (cpu_is_rk3288()) {
-	        strlcpy(camsys_soc_p->name,"camsys_rk3288",31);
-        camsys_soc_p->soc_cfg = camsys_rk3288_cfg;	
-	} else {
-		camsys_err("camsys isn't support soc: 0x%lx!",rockchip_soc_id);
+int camsys_soc_init(unsigned int chip_type)
+{
+	camsys_soc_p = kzalloc(sizeof(camsys_soc_priv_t), GFP_KERNEL);
+	if (camsys_soc_p == NULL) {
+		camsys_err("malloc camsys_soc_priv_t failed!");
 		goto fail;
 	}
-#endif
 
-    return 0;
+	if (chip_type == 3368) {
+		strlcpy(camsys_soc_p->name, "camsys_rk3368", 31);
+		camsys_soc_p->soc_cfg = camsys_rk3368_cfg;
+		camsys_err("camsys_soc_init exit!");
+	} else if (chip_type == 3288) {
+		if (cpu_is_rk3288()) {
+			strlcpy(camsys_soc_p->name, "camsys_rk3288", 31);
+			camsys_soc_p->soc_cfg = camsys_rk3288_cfg;
+		} else {
+			camsys_err("camsys isn't support soc!");
+			goto fail;
+		}
+	} else if (chip_type == 3366) {
+		strlcpy(camsys_soc_p->name, "camsys_rk3366", 31);
+		camsys_soc_p->soc_cfg = camsys_rk3366_cfg;
+		camsys_err("camsys_soc_init exit!");
+	} else if (chip_type == 3399) {
+		strlcpy(camsys_soc_p->name, "camsys_rk3399", 31);
+		camsys_soc_p->soc_cfg = camsys_rk3399_cfg;
+		camsys_err("camsys_soc_init exit!");
+	}
+
+	return 0;
 fail:
-    if (camsys_soc_p != NULL) {
-        kfree(camsys_soc_p);
-        camsys_soc_p = NULL;
-    }
-    return -1;
+	if (camsys_soc_p != NULL) {
+		kfree(camsys_soc_p);
+		camsys_soc_p = NULL;
+	}
+	return -1;
 }
 
 int camsys_soc_deinit(void)
 {
-    if (camsys_soc_p != NULL) {
-        kfree(camsys_soc_p);
-        camsys_soc_p = NULL;
-    }
-    return 0;
+	if (camsys_soc_p != NULL) {
+		kfree(camsys_soc_p);
+		camsys_soc_p = NULL;
+	}
+	return 0;
 }
diff --git a/drivers/media/video/rk_camsys/camsys_soc_priv.h b/drivers/media/video/rk_camsys/camsys_soc_priv.h
index 707d2e6d0616..730e6281dca2 100755
--- a/drivers/media/video/rk_camsys/camsys_soc_priv.h
+++ b/drivers/media/video/rk_camsys/camsys_soc_priv.h
@@ -4,27 +4,31 @@
 #include "camsys_internal.h"
 
 typedef struct camsys_mipiphy_soc_para_s {
-    camsys_dev_t        *camsys_dev;
-    camsys_mipiphy_t    *phy;
+	camsys_dev_t        *camsys_dev;
+	camsys_mipiphy_t    *phy;
 } camsys_mipiphy_soc_para_t;
 
-
 typedef enum camsys_soc_cfg_e {
-    Clk_DriverStrength_Cfg = 0,
-    Cif_IoDomain_Cfg,
-    Mipi_Phy_Cfg,
+	Clk_DriverStrength_Cfg = 0,
+	Cif_IoDomain_Cfg,
+	Mipi_Phy_Cfg,
 
-    Isp_SoftRst,
+	Isp_SoftRst,
 } camsys_soc_cfg_t;
 
 typedef struct camsys_soc_priv_s {
-    char name[32];
-    int (*soc_cfg)(camsys_soc_cfg_t cfg_cmd, void* cfg_para);
-    
+	char name[32];
+
+	int (*soc_cfg)
+		(camsys_dev_t *camsys_dev,
+		camsys_soc_cfg_t cfg_cmd,
+		void *cfg_para
+		);
+
 } camsys_soc_priv_t;
 
-extern camsys_soc_priv_t* camsys_soc_get(void);
-extern int camsys_soc_init(void);
+extern camsys_soc_priv_t *camsys_soc_get(void);
+extern int camsys_soc_init(unsigned int);
 extern int camsys_soc_deinit(void);
 
 extern unsigned long rk_grf_base;
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3288.c b/drivers/media/video/rk_camsys/camsys_soc_rk3288.c
index e27b68182e61..8477864235fe 100755
--- a/drivers/media/video/rk_camsys/camsys_soc_rk3288.c
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3288.c
@@ -4,280 +4,388 @@
 
 
 struct mipiphy_hsfreqrange_s {
-    unsigned int range_l;
-    unsigned int range_h;
-    unsigned char cfg_bit;
+	unsigned int range_l;
+	unsigned int range_h;
+	unsigned char cfg_bit;
 };
 
 static struct mipiphy_hsfreqrange_s mipiphy_hsfreqrange[] = {
-    {80,90,0x00},
-    {90,100,0x10},
-    {100,110,0x20},
-    {110,130,0x01},
-    {130,140,0x11},
-    {140,150,0x21},
-    {150,170,0x02},
-    {170,180,0x12},
-    {180,200,0x22},
-    {200,220,0x03},
-    {220,240,0x13},
-    {240,250,0x23},
-    {250,270,0x4},
-    {270,300,0x14},
-    {300,330,0x5},
-    {330,360,0x15},
-    {360,400,0x25},
-    {400,450,0x06},
-    {450,500,0x16},
-    {500,550,0x07},
-    {550,600,0x17},
-    {600,650,0x08},
-    {650,700,0x18},
-    {700,750,0x09},
-    {750,800,0x19},
-    {800,850,0x29},
-    {850,900,0x39},
-    {900,950,0x0a},
-    {950,1000,0x1a}
-    
+	{80, 90, 0x00},
+	{90, 100, 0x10},
+	{100, 110, 0x20},
+	{110, 130, 0x01},
+	{130, 140, 0x11},
+	{140, 150, 0x21},
+	{150, 170, 0x02},
+	{170, 180, 0x12},
+	{180, 200, 0x22},
+	{200, 220, 0x03},
+	{220, 240, 0x13},
+	{240, 250, 0x23},
+	{250, 270, 0x4},
+	{270, 300, 0x14},
+	{300, 330, 0x5},
+	{330, 360, 0x15},
+	{360, 400, 0x25},
+	{400, 450, 0x06},
+	{450, 500, 0x16},
+	{500, 550, 0x07},
+	{550, 600, 0x17},
+	{600, 650, 0x08},
+	{650, 700, 0x18},
+	{700, 750, 0x09},
+	{750, 800, 0x19},
+	{800, 850, 0x29},
+	{850, 900, 0x39},
+	{900, 950, 0x0a},
+	{950, 1000, 0x1a}
+
 };
 
 
-static int camsys_rk3288_mipiphy0_wr_reg(unsigned char addr, unsigned char data)
+static int camsys_rk3288_mipiphy0_wr_reg(
+unsigned char addr, unsigned char data)
 {
-    //TESTCLK=1
-    write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK);
-    //TESTEN =1,TESTDIN=addr
-    write_grf_reg(GRF_SOC_CON14_OFFSET,(( addr << DPHY_RX0_TESTDIN_OFFSET) |DPHY_RX0_TESTDIN_MASK | DPHY_RX0_TESTEN| DPHY_RX0_TESTEN_MASK)); 
-    //TESTCLK=0
-	write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK); 
-  
-    if(data != 0xff){ //write data ?
-    	//TESTEN =0,TESTDIN=data
-        write_grf_reg(GRF_SOC_CON14_OFFSET, (( data << DPHY_RX0_TESTDIN_OFFSET)|DPHY_RX0_TESTDIN_MASK |DPHY_RX0_TESTEN_MASK)); 
-
-        //TESTCLK=1
-        write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK); 
-    }
-    return 0;
+    /*TESTCLK=1*/
+	write_grf_reg(GRF_SOC_CON14_OFFSET,
+	    DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK);
+    /*TESTEN =1,TESTDIN=addr*/
+	write_grf_reg(GRF_SOC_CON14_OFFSET,
+		((addr << DPHY_RX0_TESTDIN_OFFSET)
+		|DPHY_RX0_TESTDIN_MASK | DPHY_RX0_TESTEN|
+		DPHY_RX0_TESTEN_MASK));
+    /*TESTCLK=0*/
+	write_grf_reg(GRF_SOC_CON14_OFFSET,
+		DPHY_RX0_TESTCLK_MASK);
+
+	if (data != 0xff) { /*write data ?*/
+		/*TESTEN =0,TESTDIN=data*/
+		write_grf_reg(GRF_SOC_CON14_OFFSET,
+			((data << DPHY_RX0_TESTDIN_OFFSET)
+			| DPHY_RX0_TESTDIN_MASK | DPHY_RX0_TESTEN_MASK));
+
+		/*TESTCLK=1*/
+		write_grf_reg(GRF_SOC_CON14_OFFSET,
+			DPHY_RX0_TESTCLK_MASK |
+			DPHY_RX0_TESTCLK);
+	}
+	return 0;
 }
 #if 0
 static int camsys_rk3288_mipiphy0_rd_reg(unsigned char addr)
 {
-    return read_grf_reg(GRF_SOC_STATUS21);
+	return read_grf_reg(GRF_SOC_STATUS21);
 }
 #endif
-static int camsys_rk3288_mipiphy1_wr_reg(unsigned int phy_virt,unsigned char addr, unsigned char data)
+static int camsys_rk3288_mipiphy1_wr_reg(
+unsigned int phy_virt, unsigned char addr, unsigned char data)
 {
-    
-    write_csihost_reg(CSIHOST_PHY_TEST_CTRL1,(0x00010000|addr));    //TESTEN =1,TESTDIN=addr
-    write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000000);         //TESTCLK=0
-    write_csihost_reg(CSIHOST_PHY_TEST_CTRL1,(0x00000000|data));    //TESTEN =0,TESTDIN=data
-    write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002);         //TESTCLK=1 
-
-    return 0;
+	/*TESTEN =1,TESTDIN=addr*/
+	write_csihost_reg(CSIHOST_PHY_TEST_CTRL1, (0x00010000|addr));
+	/*TESTCLK=0*/
+	write_csihost_reg(CSIHOST_PHY_TEST_CTRL0, 0x00000000);
+	/*TESTEN =0,TESTDIN=data*/
+	write_csihost_reg(CSIHOST_PHY_TEST_CTRL1, (0x00000000|data));
+	/*TESTCLK=1*/
+	write_csihost_reg(CSIHOST_PHY_TEST_CTRL0, 0x00000002);
+
+	return 0;
 }
 
-static int camsys_rk3288_mipiphy1_rd_reg(unsigned int phy_virt,unsigned char addr)
+static int camsys_rk3288_mipiphy1_rd_reg(
+unsigned int phy_virt, unsigned char addr)
 {
-    return (read_csihost_reg(((CSIHOST_PHY_TEST_CTRL1)&0xff00))>>8);
+	return (read_csihost_reg
+			(((CSIHOST_PHY_TEST_CTRL1)&0xff00)) >> 8);
 }
 
-static int camsys_rk3288_mipihpy_cfg (camsys_mipiphy_soc_para_t *para)
-{    
-    unsigned char hsfreqrange=0xff,i;
-    struct mipiphy_hsfreqrange_s *hsfreqrange_p;
-    unsigned int phy_virt, phy_index;
-    unsigned int *base;
-
-    phy_index = para->phy->phy_index;
-    if (para->camsys_dev->mipiphy[phy_index].reg!=NULL) {
-        phy_virt  = para->camsys_dev->mipiphy[phy_index].reg->vir_base;
-    } else {
-        phy_virt = 0x00;
-    }
-    
-    if ((para->phy->bit_rate == 0) || (para->phy->data_en_bit == 0)) {
-        if (para->phy->phy_index == 0) {
-            base = (unsigned int *)para->camsys_dev->devmems.registermem->vir_base;
-            *(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL)/4) &= ~(0x0f<<8);
-            camsys_trace(1, "mipi phy 0 standby!");
-        } else if (para->phy->phy_index == 1) {
-            write_csihost_reg(CSIHOST_PHY_SHUTDOWNZ,0x00000000);           //SHUTDOWNZ=0
-            write_csihost_reg(CSIHOST_DPHY_RSTZ,0x00000000);               //RSTZ=0
-
-            camsys_trace(1, "mipi phy 1 standby!");
-        }
-
-        return 0;
-    }
-    
-    
-    hsfreqrange_p = mipiphy_hsfreqrange;
-    for (i=0; i<(sizeof(mipiphy_hsfreqrange)/sizeof(struct mipiphy_hsfreqrange_s)); i++) {
-
-        if ((para->phy->bit_rate > hsfreqrange_p->range_l) && (para->phy->bit_rate <= hsfreqrange_p->range_h)) {
-            hsfreqrange = hsfreqrange_p->cfg_bit;
-            break;
-        }
-        hsfreqrange_p++;
-    }
-
-    if (hsfreqrange == 0xff) {
-        camsys_err("mipi phy config bitrate %d Mbps isn't supported!",para->phy->bit_rate);
-        hsfreqrange = 0x00;
-    }
-    hsfreqrange <<= 1;
-    
-    if (para->phy->phy_index == 0) {
-        write_grf_reg(GRF_SOC_CON6_OFFSET, MIPI_PHY_DPHYSEL_OFFSET_MASK | (para->phy->phy_index<<MIPI_PHY_DPHYSEL_OFFSET_BIT)); 
-
-        //  set lane num
-        write_grf_reg(GRF_SOC_CON10_OFFSET, DPHY_RX0_ENABLE_MASK | (para->phy->data_en_bit << DPHY_RX0_ENABLE_OFFSET_BITS)); 
-        //  set lan turndisab as 1
-        write_grf_reg(GRF_SOC_CON10_OFFSET, DPHY_RX0_TURN_DISABLE_MASK | (0xf << DPHY_RX0_TURN_DISABLE_OFFSET_BITS));
-        write_grf_reg(GRF_SOC_CON10_OFFSET, (0x0<<4)|(0xf<<20));
-        //  set lan turnrequest as 0   
-        write_grf_reg(GRF_SOC_CON15_OFFSET, DPHY_RX0_TURN_REQUEST_MASK | (0x0 << DPHY_RX0_TURN_REQUEST_OFFSET_BITS));
-
-        //phy start
-        {
-            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK); //TESTCLK=1              
-            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLR_MASK |DPHY_RX0_TESTCLR);   //TESTCLR=1
-            udelay(100);
-            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLR_MASK); //TESTCLR=0  zyc
-            udelay(100);
-
-            //set clock lane
-            camsys_rk3288_mipiphy0_wr_reg(0x34,0x15);
-            if (para->phy->data_en_bit >= 0x00)  
-                camsys_rk3288_mipiphy0_wr_reg(0x44,hsfreqrange);         
-            if (para->phy->data_en_bit >= 0x01) 
-                camsys_rk3288_mipiphy0_wr_reg(0x54,hsfreqrange);
-            if (para->phy->data_en_bit >= 0x04) { 
-                camsys_rk3288_mipiphy0_wr_reg(0x84,hsfreqrange);
-                camsys_rk3288_mipiphy0_wr_reg(0x94,hsfreqrange);
-            }
-
-            //Normal operation
-            camsys_rk3288_mipiphy0_wr_reg(0x0,-1);        
-            write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX0_TESTCLK_MASK |DPHY_RX0_TESTCLK);    //TESTCLK=1     
-            write_grf_reg(GRF_SOC_CON14_OFFSET, (DPHY_RX0_TESTEN_MASK));                     //TESTEN =0 
-        }
-
-        base = (unsigned int *)para->camsys_dev->devmems.registermem->vir_base;
-        *(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL)/4) |= (0x0f<<8);
-        
-    } else if (para->phy->phy_index == 1){
-        
-        write_grf_reg(GRF_SOC_CON6_OFFSET, MIPI_PHY_DPHYSEL_OFFSET_MASK | (para->phy->phy_index<<MIPI_PHY_DPHYSEL_OFFSET_BIT));         
-        write_grf_reg(GRF_SOC_CON6_OFFSET, DSI_CSI_TESTBUS_SEL_MASK | (1<<DSI_CSI_TESTBUS_SEL_OFFSET_BIT)); 
-
-        write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_RX1_SRC_SEL_ISP | DPHY_RX1_SRC_SEL_MASK); 
-        write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_TX1RX1_SLAVEZ | DPHY_TX1RX1_MASTERSLAVEZ_MASK); 
-        write_grf_reg(GRF_SOC_CON14_OFFSET, DPHY_TX1RX1_BASEDIR_REC | DPHY_TX1RX1_BASEDIR_OFFSET); 
-
-        //  set lane num
-        write_grf_reg(GRF_SOC_CON9_OFFSET, DPHY_TX1RX1_ENABLE_MASK | (para->phy->data_en_bit << DPHY_TX1RX1_ENABLE_OFFSET_BITS)); 
-        //  set lan turndisab as 1
-        write_grf_reg(GRF_SOC_CON9_OFFSET, DPHY_TX1RX1_TURN_DISABLE_MASK | (0xf << DPHY_TX1RX1_TURN_DISABLE_OFFSET_BITS));
-        //  set lan turnrequest as 0   
-        write_grf_reg(GRF_SOC_CON15_OFFSET, DPHY_TX1RX1_TURN_REQUEST_MASK | (0x0 << DPHY_TX1RX1_TURN_REQUEST_OFFSET_BITS));
-
-        //phy1 start
-        {
-            write_csihost_reg(CSIHOST_PHY_SHUTDOWNZ,0x00000000);           //SHUTDOWNZ=0
-            write_csihost_reg(CSIHOST_DPHY_RSTZ,0x00000000);               //RSTZ=0
-            write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002);          //TESTCLK=1
-            write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000003);          //TESTCLR=1 TESTCLK=1  
-            udelay(100);
-            write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002);          //TESTCLR=0 TESTCLK=1
-            udelay(100);
-   
-            //set clock lane
-            camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x34,0x15);
-            if (para->phy->data_en_bit >= 0x00)  
-                camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x44,hsfreqrange);         
-            if (para->phy->data_en_bit >= 0x01) 
-                camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x54,hsfreqrange);
-            if (para->phy->data_en_bit >= 0x04) { 
-                camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x84,hsfreqrange);
-                camsys_rk3288_mipiphy1_wr_reg(phy_virt,0x94,hsfreqrange);
-            }
-
-            camsys_rk3288_mipiphy1_rd_reg(phy_virt,0x0);
-            write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002);       //TESTCLK=1
-            write_csihost_reg(CSIHOST_PHY_TEST_CTRL1,0x00000000);       //TESTEN =0
-            write_csihost_reg(CSIHOST_PHY_SHUTDOWNZ,0x00000001);        //SHUTDOWNZ=1
-            write_csihost_reg(CSIHOST_DPHY_RSTZ,0x00000001);            //RSTZ=1
-        }
-    } else {
-        camsys_err("mipi phy index %d is invalidate!",para->phy->phy_index);
-        goto fail;
-    }
-
-    camsys_trace(1, "mipi phy(%d) turn on(lane: 0x%x  bit_rate: %dMbps)",para->phy->phy_index,para->phy->data_en_bit, para->phy->bit_rate);
-
-
-    return 0;
+static int camsys_rk3288_mipihpy_cfg(
+camsys_mipiphy_soc_para_t *para)
+{
+	unsigned char hsfreqrange = 0xff, i;
+	struct mipiphy_hsfreqrange_s *hsfreqrange_p;
+	unsigned int phy_virt, phy_index;
+	unsigned int *base;
+
+	phy_index = para->phy->phy_index;
+	if (para->camsys_dev->mipiphy[phy_index].reg != NULL) {
+		phy_virt  =
+		para->camsys_dev->mipiphy[phy_index].reg->vir_base;
+	} else {
+		phy_virt = 0x00;
+	}
+
+	if ((para->phy->bit_rate == 0) ||
+		(para->phy->data_en_bit == 0)) {
+		if (para->phy->phy_index == 0) {
+			base =
+				(unsigned int *)
+				para->camsys_dev->devmems.registermem->vir_base;
+			*(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL)/4)
+				&= ~(0x0f<<8);
+			camsys_trace(1, "mipi phy 0 standby!");
+		} else if (para->phy->phy_index == 1) {
+			/*SHUTDOWNZ=0*/
+			write_csihost_reg
+				(CSIHOST_PHY_SHUTDOWNZ, 0x00000000);
+			/*RSTZ=0*/
+			write_csihost_reg(CSIHOST_DPHY_RSTZ, 0x00000000);
+
+			camsys_trace(1, "mipi phy 1 standby!");
+		}
+
+		return 0;
+	}
+
+	hsfreqrange_p = mipiphy_hsfreqrange;
+	for (i = 0;
+		i <
+			(sizeof(mipiphy_hsfreqrange)/
+			sizeof(struct mipiphy_hsfreqrange_s));
+		i++) {
+
+		if ((para->phy->bit_rate > hsfreqrange_p->range_l) &&
+			(para->phy->bit_rate <= hsfreqrange_p->range_h)) {
+			hsfreqrange = hsfreqrange_p->cfg_bit;
+			break;
+		}
+		hsfreqrange_p++;
+	}
+
+	if (hsfreqrange == 0xff) {
+		camsys_err("mipi phy config bitrate %d Mbps isn't supported!",
+			para->phy->bit_rate);
+		hsfreqrange = 0x00;
+	}
+	hsfreqrange <<= 1;
+
+	if (para->phy->phy_index == 0) {
+		write_grf_reg(GRF_SOC_CON6_OFFSET,
+					MIPI_PHY_DPHYSEL_OFFSET_MASK
+					| (para->phy->phy_index
+					<< MIPI_PHY_DPHYSEL_OFFSET_BIT));
+
+		/*  set lane num*/
+		write_grf_reg(GRF_SOC_CON10_OFFSET,
+					DPHY_RX0_ENABLE_MASK
+					| (para->phy->data_en_bit
+					<< DPHY_RX0_ENABLE_OFFSET_BITS));
+		/*  set lan turndisab as 1*/
+		write_grf_reg(GRF_SOC_CON10_OFFSET,
+					DPHY_RX0_TURN_DISABLE_MASK
+					| (0xf
+					<< DPHY_RX0_TURN_DISABLE_OFFSET_BITS));
+		write_grf_reg(GRF_SOC_CON10_OFFSET,
+					(0x0<<4)|(0xf<<20));
+		/*  set lan turnrequest as 0 */
+		write_grf_reg(GRF_SOC_CON15_OFFSET,
+					DPHY_RX0_TURN_REQUEST_MASK
+					| (0x0
+					<< DPHY_RX0_TURN_REQUEST_OFFSET_BITS));
+
+		/*phy start*/
+		{
+			/*TESTCLK=1  */
+			write_grf_reg(GRF_SOC_CON14_OFFSET,
+						DPHY_RX0_TESTCLK_MASK
+						| DPHY_RX0_TESTCLK);
+			/*TESTCLR=1*/
+			write_grf_reg(GRF_SOC_CON14_OFFSET,
+						DPHY_RX0_TESTCLR_MASK
+						| DPHY_RX0_TESTCLR);
+			udelay(100);
+			 /*TESTCLR=0  zyc*/
+			write_grf_reg(GRF_SOC_CON14_OFFSET,
+						DPHY_RX0_TESTCLR_MASK);
+			udelay(100);
+
+			/*set clock lane*/
+			camsys_rk3288_mipiphy0_wr_reg
+				(0x34, 0x15);
+			if (para->phy->data_en_bit >= 0x00)
+				camsys_rk3288_mipiphy0_wr_reg
+					(0x44, hsfreqrange);
+			if (para->phy->data_en_bit >= 0x01)
+				camsys_rk3288_mipiphy0_wr_reg(
+					0x54, hsfreqrange);
+			if (para->phy->data_en_bit >= 0x04) {
+				camsys_rk3288_mipiphy0_wr_reg
+					(0x84, hsfreqrange);
+				camsys_rk3288_mipiphy0_wr_reg
+					(0x94, hsfreqrange);
+			}
+
+			/*Normal operation*/
+			camsys_rk3288_mipiphy0_wr_reg(0x0, -1);
+		    /*TESTCLK=1*/
+			write_grf_reg(GRF_SOC_CON14_OFFSET,
+					DPHY_RX0_TESTCLK_MASK
+					| DPHY_RX0_TESTCLK);
+			/*TESTEN =0 */
+			write_grf_reg(GRF_SOC_CON14_OFFSET,
+					(DPHY_RX0_TESTEN_MASK));
+		}
+
+		base =
+			(unsigned int *)
+			para->camsys_dev->devmems.registermem->vir_base;
+		*(base + (MRV_MIPI_BASE + MRV_MIPI_CTRL)/4)
+			|= (0x0f<<8);
+
+	} else if (para->phy->phy_index == 1) {
+
+		write_grf_reg(GRF_SOC_CON6_OFFSET,
+					MIPI_PHY_DPHYSEL_OFFSET_MASK
+					| (para->phy->phy_index
+					<< MIPI_PHY_DPHYSEL_OFFSET_BIT));
+		write_grf_reg(GRF_SOC_CON6_OFFSET,
+					DSI_CSI_TESTBUS_SEL_MASK
+					| (1
+					<< DSI_CSI_TESTBUS_SEL_OFFSET_BIT));
+
+		write_grf_reg(GRF_SOC_CON14_OFFSET,
+					DPHY_RX1_SRC_SEL_ISP
+					| DPHY_RX1_SRC_SEL_MASK);
+		write_grf_reg(GRF_SOC_CON14_OFFSET,
+					DPHY_TX1RX1_SLAVEZ
+					| DPHY_TX1RX1_MASTERSLAVEZ_MASK);
+		write_grf_reg(GRF_SOC_CON14_OFFSET,
+					DPHY_TX1RX1_BASEDIR_REC
+					| DPHY_TX1RX1_BASEDIR_OFFSET);
+
+		/*  set lane num*/
+		write_grf_reg(GRF_SOC_CON9_OFFSET,
+					DPHY_TX1RX1_ENABLE_MASK
+					| (para->phy->data_en_bit
+					<< DPHY_TX1RX1_ENABLE_OFFSET_BITS));
+		/*  set lan turndisab as 1*/
+		write_grf_reg(GRF_SOC_CON9_OFFSET,
+				DPHY_TX1RX1_TURN_DISABLE_MASK
+				| (0xf
+				<< DPHY_TX1RX1_TURN_DISABLE_OFFSET_BITS));
+		/*  set lan turnrequest as 0 */
+		write_grf_reg(GRF_SOC_CON15_OFFSET,
+				DPHY_TX1RX1_TURN_REQUEST_MASK
+				| (0x0
+				<< DPHY_TX1RX1_TURN_REQUEST_OFFSET_BITS));
+
+		/*phy1 start*/
+		{
+			/*SHUTDOWNZ=0*/
+			write_csihost_reg(CSIHOST_PHY_SHUTDOWNZ, 0x00000000);
+			/*RSTZ=0*/
+			write_csihost_reg(CSIHOST_DPHY_RSTZ, 0x00000000);
+			/*TESTCLK=1*/
+			write_csihost_reg(CSIHOST_PHY_TEST_CTRL0, 0x00000002);
+			/*TESTCLR=1 TESTCLK=1*/
+			write_csihost_reg(CSIHOST_PHY_TEST_CTRL0, 0x00000003);
+			udelay(100);
+			/*TESTCLR=0 TESTCLK=1*/
+			write_csihost_reg(CSIHOST_PHY_TEST_CTRL0, 0x00000002);
+			udelay(100);
+
+			/*set clock lane*/
+			camsys_rk3288_mipiphy1_wr_reg
+				(phy_virt, 0x34, 0x15);
+			if (para->phy->data_en_bit >= 0x00)
+				camsys_rk3288_mipiphy1_wr_reg
+					(phy_virt, 0x44, hsfreqrange);
+			if (para->phy->data_en_bit >= 0x01)
+				camsys_rk3288_mipiphy1_wr_reg
+					(phy_virt, 0x54, hsfreqrange);
+			if (para->phy->data_en_bit >= 0x04) {
+				camsys_rk3288_mipiphy1_wr_reg
+					(phy_virt, 0x84, hsfreqrange);
+				camsys_rk3288_mipiphy1_wr_reg
+					(phy_virt, 0x94, hsfreqrange);
+			}
+
+			camsys_rk3288_mipiphy1_rd_reg
+				(phy_virt, 0x0);
+			/*TESTCLK=1*/
+			write_csihost_reg
+				(CSIHOST_PHY_TEST_CTRL0, 0x00000002);
+			/*TESTEN =0*/
+			write_csihost_reg
+				(CSIHOST_PHY_TEST_CTRL1, 0x00000000);
+			/*SHUTDOWNZ=1*/
+			write_csihost_reg
+				(CSIHOST_PHY_SHUTDOWNZ, 0x00000001);
+			/*RSTZ=1*/
+			write_csihost_reg
+				(CSIHOST_DPHY_RSTZ, 0x00000001);
+		}
+	} else {
+		camsys_err("mipi phy index %d is invalidate!",
+			para->phy->phy_index);
+		goto fail;
+	}
+
+	camsys_trace(1, "mipi phy(%d) turn on(lane: 0x%x  bit_rate: %dMbps)",
+			para->phy->phy_index,
+			para->phy->data_en_bit,
+			para->phy->bit_rate);
+
+	return 0;
 
 fail:
-    return -1;
+	return -1;
 }
 
-int camsys_rk3288_cfg (camsys_soc_cfg_t cfg_cmd, void* cfg_para)
+int camsys_rk3288_cfg(
+camsys_dev_t *camsys_dev, camsys_soc_cfg_t cfg_cmd, void *cfg_para)
 {
-    unsigned int *para_int;
-    
-    switch (cfg_cmd)
-    {
-        case Clk_DriverStrength_Cfg:
-        {
-            para_int = (unsigned int*)cfg_para;
-            __raw_writel((((*para_int)&0x03)<<3)|(0x03<<3), RK_GRF_VIRT+0x01d4);
-            break;
-        }
-
-        case Cif_IoDomain_Cfg:
-        {
-            para_int = (unsigned int*)cfg_para;
-            if (*para_int < 28000000) {
-                __raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);    // 1.8v IO
-            } else {
-                __raw_writel(((0<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);    // 3.3v IO
-            }
-            break;
-        }
-
-        case Mipi_Phy_Cfg:
-        {
-            camsys_rk3288_mipihpy_cfg((camsys_mipiphy_soc_para_t*)cfg_para);
-            break;
-        }
-
-        case Isp_SoftRst:         /* ddl@rock-chips.com: v0.d.0 */
-        {
-            unsigned int reset;
-            reset = (unsigned int)cfg_para;
-
-            if (reset == 1)
-                cru_writel(0x40004000,0x1d0);
-            else 
-                cru_writel(0x40000000,0x1d0);
-            camsys_trace(1, "Isp_SoftRst: %d",reset);
-            break;
-        }
-
-        default:
-        {
-            camsys_warn("cfg_cmd: 0x%x isn't support",cfg_cmd);
-            break;
-        }
-
-    }
-
-    return 0;
-
-
+	unsigned int *para_int;
+
+	switch (cfg_cmd) {
+	case Clk_DriverStrength_Cfg: {
+		para_int = (unsigned int *)cfg_para;
+		__raw_writel((((*para_int) & 0x03) << 3)|(0x03 << 3),
+			RK_GRF_VIRT + 0x01d4);
+		break;
+	}
+
+	case Cif_IoDomain_Cfg: {
+		para_int = (unsigned int *)cfg_para;
+		if (*para_int < 28000000) {
+			/* 1.8v IO*/
+			__raw_writel
+				(((1 << 1) | (1 << (1 + 16))),
+				RK_GRF_VIRT + 0x0380);
+		} else {
+			/* 3.3v IO*/
+			__raw_writel
+				(((0 << 1) | (1 << (1 + 16))),
+				RK_GRF_VIRT + 0x0380);
+		}
+		break;
+	}
+
+	case Mipi_Phy_Cfg: {
+		camsys_rk3288_mipihpy_cfg
+			((camsys_mipiphy_soc_para_t *)cfg_para);
+		break;
+	}
+
+	case Isp_SoftRst: {        /* ddl@rock-chips.com: v0.d.0 */
+		unsigned int reset;
+
+		reset = (unsigned int)cfg_para;
+
+		if (reset == 1)
+			cru_writel(0x40004000, 0x1d0);
+		else
+			cru_writel(0x40000000, 0x1d0);
+			camsys_trace(1, "Isp_SoftRst: %d", reset);
+		break;
+	}
+
+	default: {
+		camsys_warn("cfg_cmd: 0x%x isn't support", cfg_cmd);
+		break;
+	}
+	}
+
+	return 0;
 }
 #endif /* CONFIG_ARM */
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3288.h b/drivers/media/video/rk_camsys/camsys_soc_rk3288.h
index 6899cca5bbd5..254b30a09a43 100755
--- a/drivers/media/video/rk_camsys/camsys_soc_rk3288.h
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3288.h
@@ -3,81 +3,87 @@
 
 #include "camsys_internal.h"
 
-//MARVIN REGISTER
+/*MARVIN REGISTER*/
 #define MRV_MIPI_BASE                           0x1C00
 #define MRV_MIPI_CTRL                           0x00
 
-//GRF_SOC_CON14
-//bit 0     dphy_rx0_testclr
-//bit 1     dphy_rx0_testclk
-//bit 2     dphy_rx0_testen
-//bit 3:10 dphy_rx0_testdin
+/*
+*GRF_SOC_CON14
+*bit 0     dphy_rx0_testclr
+*bit 1     dphy_rx0_testclk
+*bit 2     dphy_rx0_testen
+*bit 3:10 dphy_rx0_testdin
+*/
 #define GRF_SOC_CON14_OFFSET    (0x027c)
-#define DPHY_RX0_TESTCLR_MASK   (0x1<<16)
-#define DPHY_RX0_TESTCLK_MASK   (0x1<<17)
-#define DPHY_RX0_TESTEN_MASK    (0x1<<18)
-#define DPHY_RX0_TESTDIN_MASK   (0xff<<19)
-
-#define DPHY_RX0_TESTCLR    (1<<0)
-#define DPHY_RX0_TESTCLK    (1<<1)
-#define DPHY_RX0_TESTEN     (1<<2)
+#define DPHY_RX0_TESTCLR_MASK   (0x1 << 16)
+#define DPHY_RX0_TESTCLK_MASK   (0x1 << 17)
+#define DPHY_RX0_TESTEN_MASK    (0x1 << 18)
+#define DPHY_RX0_TESTDIN_MASK   (0xff << 19)
+
+#define DPHY_RX0_TESTCLR    (0x1 << 0)
+#define DPHY_RX0_TESTCLK    (0x1 << 1)
+#define DPHY_RX0_TESTEN     (0x1 << 2)
 #define DPHY_RX0_TESTDIN_OFFSET    (3)
 
-#define DPHY_TX1RX1_ENABLECLK_MASK   (0x1<<28)
-#define DPHY_RX1_SRC_SEL_MASK        (0x1<<29)
-#define DPHY_TX1RX1_MASTERSLAVEZ_MASK (0x1<<30)
-#define DPHY_TX1RX1_BASEDIR_OFFSET  (0x1<<31)
-
-#define DPHY_TX1RX1_ENABLECLK           (0x1<<12)
-#define DPHY_TX1RX1_DISABLECLK          (0x0<<12)
-#define DPHY_RX1_SRC_SEL_ISP          (0x1<<13)
-#define DPHY_TX1RX1_SLAVEZ            (0x0<<14)
-#define DPHY_TX1RX1_BASEDIR_REC       (0x1<<15)
-
-
-
-//GRF_SOC_CON6
-//bit 0 grf_con_disable_isp
-//bit 1 grf_con_isp_dphy_sel  1'b0 mipi phy rx0
+#define DPHY_TX1RX1_ENABLECLK_MASK   (0x1 << 28)
+#define DPHY_RX1_SRC_SEL_MASK        (0x1 << 29)
+#define DPHY_TX1RX1_MASTERSLAVEZ_MASK (0x1 << 30)
+#define DPHY_TX1RX1_BASEDIR_OFFSET  (0x1 << 31)
+
+#define DPHY_TX1RX1_ENABLECLK           (0x1 << 12)
+#define DPHY_TX1RX1_DISABLECLK          (0x0 << 12)
+#define DPHY_RX1_SRC_SEL_ISP          (0x1 << 13)
+#define DPHY_TX1RX1_SLAVEZ            (0x0 << 14)
+#define DPHY_TX1RX1_BASEDIR_REC       (0x1 << 15)
+
+/*
+*GRF_SOC_CON6
+*bit 0 grf_con_disable_isp
+*bit 1 grf_con_isp_dphy_sel  1'b0 mipi phy rx0
+*/
 #define GRF_SOC_CON6_OFFSET    (0x025c)
-#define MIPI_PHY_DISABLE_ISP_MASK       (0x1<<16)
-#define MIPI_PHY_DISABLE_ISP            (0x0<<0)
+#define MIPI_PHY_DISABLE_ISP_MASK       (0x1 << 16)
+#define MIPI_PHY_DISABLE_ISP            (0x0 << 0)
 
-#define DSI_CSI_TESTBUS_SEL_MASK        (0x1<<30)
+#define DSI_CSI_TESTBUS_SEL_MASK        (0x1 << 30)
 #define DSI_CSI_TESTBUS_SEL_OFFSET_BIT  (14)
 
-
-#define MIPI_PHY_DPHYSEL_OFFSET_MASK (0x1<<17)
+#define MIPI_PHY_DPHYSEL_OFFSET_MASK (0x1 << 17)
 #define MIPI_PHY_DPHYSEL_OFFSET_BIT (0x1)
 
-//GRF_SOC_CON10
-//bit12:15 grf_dphy_rx0_enable
-//bit 0:3 turn disable
+/*
+*GRF_SOC_CON10
+*bit12:15 grf_dphy_rx0_enable
+*bit 0:3 turn disable
+*/
 #define GRF_SOC_CON10_OFFSET                (0x026c)
-#define DPHY_RX0_TURN_DISABLE_MASK          (0xf<<16)
+#define DPHY_RX0_TURN_DISABLE_MASK          (0xf << 16)
 #define DPHY_RX0_TURN_DISABLE_OFFSET_BITS   (0x0)
-#define DPHY_RX0_ENABLE_MASK                (0xf<<28)
+#define DPHY_RX0_ENABLE_MASK                (0xf << 28)
 #define DPHY_RX0_ENABLE_OFFSET_BITS         (12)
 
-//GRF_SOC_CON9
-//bit12:15 grf_dphy_rx0_enable
-//bit 0:3 turn disable
+/*
+*GRF_SOC_CON9
+*bit12:15 grf_dphy_rx0_enable
+*bit 0:3 turn disable
+*/
 #define GRF_SOC_CON9_OFFSET                (0x0268)
-#define DPHY_TX1RX1_TURN_DISABLE_MASK          (0xf<<16)
+#define DPHY_TX1RX1_TURN_DISABLE_MASK          (0xf << 16)
 #define DPHY_TX1RX1_TURN_DISABLE_OFFSET_BITS   (0x0)
-#define DPHY_TX1RX1_ENABLE_MASK                (0xf<<28)
+#define DPHY_TX1RX1_ENABLE_MASK                (0xf << 28)
 #define DPHY_TX1RX1_ENABLE_OFFSET_BITS         (12)
 
-//GRF_SOC_CON15
-//bit 0:3   turn request
-#define GRF_SOC_CON15_OFFSET                (0x03a4) 
-#define DPHY_RX0_TURN_REQUEST_MASK          (0xf<<16)
+/*
+*GRF_SOC_CON15
+*bit 0:3   turn request
+*/
+#define GRF_SOC_CON15_OFFSET                (0x03a4)
+#define DPHY_RX0_TURN_REQUEST_MASK          (0xf << 16)
 #define DPHY_RX0_TURN_REQUEST_OFFSET_BITS   (0x0)
 
-#define DPHY_TX1RX1_TURN_REQUEST_MASK          (0xf<<20)
+#define DPHY_TX1RX1_TURN_REQUEST_MASK          (0xf << 20)
 #define DPHY_TX1RX1_TURN_REQUEST_OFFSET_BITS   (0x0)
 
-//
 #define GRF_SOC_STATUS21                  (0x2D4)
 
 #define CSIHOST_PHY_TEST_CTRL0            (0x30)
@@ -92,21 +98,29 @@
 #define CSIHOST_ERR1                      (0x20)
 #define CSIHOST_ERR2                      (0x24)
 
-
-#define write_grf_reg(addr, val)           __raw_writel(val, addr+RK_GRF_VIRT)
-#define read_grf_reg(addr)                 __raw_readl(addr+RK_GRF_VIRT)
-#define mask_grf_reg(addr, msk, val)       write_grf_reg(addr,(val)|((~(msk))&read_grf_reg(addr)))
+#define write_grf_reg(addr, val)           \
+	__raw_writel(val, addr + RK_GRF_VIRT)
+#define read_grf_reg(addr)                 \
+	__raw_readl(addr + RK_GRF_VIRT)
+#define mask_grf_reg(addr, msk, val)       \
+	write_grf_reg(addr, (val) | ((~(msk)) & read_grf_reg(addr)))
 #ifdef CONFIG_ARM64
-#define cru_writel(v, o)	do {writel(v, RK_CRU_VIRT + (o));} \
+#define cru_writel(v, o)	\
+	do {writel(v, RK_CRU_VIRT + (o)); } \
 				while (0)
 
-#define write_csihost_reg(addr, val)       __raw_writel(val, addr+(void __force __iomem *)(phy_virt))
-#define read_csihost_reg(addr)             __raw_readl(addr+(void __force __iomem *)(phy_virt))
+#define write_csihost_reg(addr, val)       \
+	__raw_writel(val, addr + (void __force __iomem *)(phy_virt))
+#define read_csihost_reg(addr)             \
+	__raw_readl(addr + (void __force __iomem *)(phy_virt))
 #else
-#define cru_writel(v, o)	do {writel(v, RK_CRU_VIRT + (o)); dsb();} \
+#define cru_writel(v, o)	\
+	do {writel(v, RK_CRU_VIRT + (o)); dsb(); } \
 				while (0)
 
-#define write_csihost_reg(addr, val)       __raw_writel(val, addr+IOMEM(phy_virt))
-#define read_csihost_reg(addr)             __raw_readl(addr+IOMEM(phy_virt))
+#define write_csihost_reg(addr, val)       \
+	__raw_writel(val, addr + IOMEM(phy_virt))
+#define read_csihost_reg(addr)             \
+	__raw_readl(addr + IOMEM(phy_virt))
 #endif
 #endif
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3366.c b/drivers/media/video/rk_camsys/camsys_soc_rk3366.c
new file mode 100644
index 000000000000..60c9c062ef3c
--- /dev/null
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3366.c
@@ -0,0 +1,241 @@
+#ifdef CONFIG_ARM64
+#include "camsys_soc_priv.h"
+#include "camsys_soc_rk3366.h"
+
+struct mipiphy_hsfreqrange_s {
+	unsigned int range_l;
+	unsigned int range_h;
+	unsigned char cfg_bit;
+};
+
+static struct mipiphy_hsfreqrange_s mipiphy_hsfreqrange[] = {
+	{80, 110, 0x00},
+	{110, 150, 0x01},
+	{150, 200, 0x02},
+	{200, 250, 0x03},
+	{250, 300, 0x04},
+	{300, 400, 0x05},
+	{400, 500, 0x06},
+	{500, 600, 0x07},
+	{600, 700, 0x08},
+	{700, 800, 0x09},
+	{800, 1000, 0x10},
+	{1000, 1200, 0x11},
+	{1200, 1400, 0x12},
+	{1400, 1600, 0x13},
+	{1600, 1800, 0x14}
+};
+
+#if 0
+static int camsys_rk3368_mipiphy_wr_reg(
+unsigned long phy_virt, unsigned char addr, unsigned char data)
+{
+	/*TESTEN =1,TESTDIN=addr */
+	write_csihost_reg(CSIHOST_PHY_TEST_CTRL1, (0x00010000 | addr));
+	/*TESTCLK=0 */
+	write_csihost_reg(CSIHOST_PHY_TEST_CTRL0, 0x00000000);
+	udelay(10);
+	/*TESTEN =0,TESTDIN=data */
+	write_csihost_reg(CSIHOST_PHY_TEST_CTRL1, (0x00000000 | data));
+	/*TESTCLK=1 */
+	write_csihost_reg(CSIHOST_PHY_TEST_CTRL0, 0x00000002);
+	udelay(10);
+
+	return 0;
+}
+
+static int camsys_rk3368_mipiphy_rd_reg(
+unsigned long phy_virt, unsigned char addr)
+{
+	return (read_csihost_reg(((CSIHOST_PHY_TEST_CTRL1) & 0xff00))>>8);
+}
+
+static int camsys_rk3368_csiphy_wr_reg(
+unsigned long csiphy_virt, unsigned char addr, unsigned char data)
+{
+	write_csiphy_reg(addr, data);
+	return 0;
+}
+
+static int camsys_rk3368_csiphy_rd_reg(
+unsigned long csiphy_virt, unsigned char addr)
+{
+	return read_csiphy_reg(addr);
+}
+#endif
+static int camsys_rk3366_mipihpy_cfg(
+camsys_mipiphy_soc_para_t *para)
+{
+	unsigned char hsfreqrange = 0xff, i;
+	struct mipiphy_hsfreqrange_s *hsfreqrange_p;
+	unsigned long phy_virt, phy_index;
+	unsigned long base;
+	unsigned long csiphy_virt;
+
+	phy_index = para->phy->phy_index;
+	if (para->camsys_dev->mipiphy[phy_index].reg != NULL) {
+		phy_virt  = para->camsys_dev->mipiphy[phy_index].reg->vir_base;
+	} else {
+		phy_virt = 0x00;
+	}
+	if (para->camsys_dev->csiphy_reg != NULL) {
+		csiphy_virt =
+			(unsigned long)para->camsys_dev->csiphy_reg->vir_base;
+	} else {
+		csiphy_virt = 0x00;
+	}
+	if ((para->phy->bit_rate == 0) ||
+		(para->phy->data_en_bit == 0)) {
+		if (para->phy->phy_index == 0) {
+			base =
+				(unsigned long)
+				para->camsys_dev->devmems.registermem->vir_base;
+			*((unsigned int *)
+				(base + (MRV_MIPI_BASE + MRV_MIPI_CTRL)))
+				&= ~(0x0f << 8);
+			camsys_trace(1, "mipi phy 0 standby!");
+		}
+
+		return 0;
+	}
+
+	hsfreqrange_p = mipiphy_hsfreqrange;
+	for (i = 0;
+		i <
+			(sizeof(mipiphy_hsfreqrange)/
+			sizeof(struct mipiphy_hsfreqrange_s));
+		i++) {
+
+		if ((para->phy->bit_rate > hsfreqrange_p->range_l) &&
+			(para->phy->bit_rate <= hsfreqrange_p->range_h)) {
+			hsfreqrange = hsfreqrange_p->cfg_bit;
+			break;
+		}
+		hsfreqrange_p++;
+	}
+
+	if (hsfreqrange == 0xff) {
+		camsys_err("mipi phy config bitrate %d Mbps isn't supported!",
+			para->phy->bit_rate);
+		hsfreqrange = 0x00;
+	}
+
+	if (para->phy->phy_index == 0) {
+		/* isp select */
+		/*write_grf_reg
+			(GRF_SOC_CON6_OFFSET, ISP_MIPI_CSI_HOST_SEL_OFFSET_MASK
+			| (1 << ISP_MIPI_CSI_HOST_SEL_OFFSET_BIT));
+		*/
+		/* phy start */
+		write_csiphy_reg
+			((MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET + 0x100),
+			hsfreqrange |
+			(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+			+ 0x100) & (~0xf)));
+
+		if (para->phy->data_en_bit > 0x00) {
+			write_csiphy_reg((MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+				+ 0x180), hsfreqrange |
+			(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+				+ 0x180) & (~0xf)));
+		}
+		if (para->phy->data_en_bit > 0x02) {
+			write_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+				+ 0x200, hsfreqrange |
+			(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+				+ 0x200) & (~0xf)));
+		}
+		if (para->phy->data_en_bit > 0x04) {
+			write_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+				+ 0x280, hsfreqrange |
+			(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+				+ 0x280) & (~0xf)));
+			write_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+				+ 0x300, hsfreqrange |
+			(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+				+ 0x300) & (~0xf)));
+		}
+
+		/*set data lane num and enable clock lane */
+		write_csiphy_reg(0x00, ((para->phy->data_en_bit << 2)
+			| (0x1 << 6) | 0x1));
+
+		base =
+			(unsigned long)
+			para->camsys_dev->devmems.registermem->vir_base;
+		*((unsigned int *)(base + (MRV_MIPI_BASE + MRV_MIPI_CTRL)))
+				&= ~(0x0f << 8);
+	} else {
+		camsys_err("mipi phy index %d is invalidate!",
+			para->phy->phy_index);
+		goto fail;
+	}
+
+	camsys_trace(1, "mipi phy(%d) turn on(lane: 0x%x  bit_rate: %dMbps)",
+	para->phy->phy_index, para->phy->data_en_bit, para->phy->bit_rate);
+
+	return 0;
+
+fail:
+	return -1;
+}
+
+#define MRV_AFM_BASE		0x0000
+#define VI_IRCL			0x0014
+int camsys_rk3366_cfg(
+camsys_dev_t *camsys_dev, camsys_soc_cfg_t cfg_cmd, void *cfg_para)
+{
+	unsigned int *para_int;
+
+	switch (cfg_cmd) {
+	case Clk_DriverStrength_Cfg: {
+		para_int = (unsigned int *)cfg_para;
+		__raw_writel((((*para_int) & 0x03) << 3) | (0x03 << 3),
+		(void *)(camsys_dev->rk_grf_base + 0x204));
+		/* set 0xffffffff to max all */
+		break;
+	}
+
+	case Cif_IoDomain_Cfg: {
+		para_int = (unsigned int *)cfg_para;
+		if (*para_int < 28000000) {
+			/* 1.8v IO */
+			__raw_writel(((1 << 1) | (1 << (1 + 16))),
+			(void *)(camsys_dev->rk_grf_base + 0x0900));
+		} else {
+			/* 3.3v IO */
+			__raw_writel(((0 << 1) | (1 << (1 + 16))),
+			(void *)(camsys_dev->rk_grf_base + 0x0900));
+		}
+		break;
+	}
+
+	case Mipi_Phy_Cfg: {
+		camsys_rk3366_mipihpy_cfg
+			((camsys_mipiphy_soc_para_t *)cfg_para);
+		break;
+	}
+
+	case Isp_SoftRst: /* ddl@rock-chips.com: v0.d.0 */ {
+		unsigned long reset;
+		reset = (unsigned long)cfg_para;
+		if (reset == 1)
+			__raw_writel(0x80, (void *)(camsys_dev->rk_isp_base +
+				MRV_AFM_BASE + VI_IRCL));
+		else
+			__raw_writel(0x00, (void *)(camsys_dev->rk_isp_base +
+				MRV_AFM_BASE + VI_IRCL));
+			camsys_trace(1, "Isp self soft rst: %ld", reset);
+		break;
+	}
+
+	default: {
+		camsys_warn("cfg_cmd: 0x%x isn't support", cfg_cmd);
+		break;
+	}
+
+	}
+
+	return 0;
+}
+#endif /* CONFIG_ARM64 */
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3366.h b/drivers/media/video/rk_camsys/camsys_soc_rk3366.h
new file mode 100644
index 000000000000..3128d0f7396a
--- /dev/null
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3366.h
@@ -0,0 +1,119 @@
+#ifndef __RKCAMSYS_SOC_RK3366_H__
+#define __RKCAMSYS_SOC_RK3366_H__
+
+#include "camsys_internal.h"
+
+/*MARVIN REGISTER*/
+#define MRV_MIPI_BASE                           0x1C00
+#define MRV_MIPI_CTRL                           0x00
+
+/*
+*#define CSIHOST_PHY_TEST_CTRL0_OFFSET 0x0030
+#define DPHY_TX1RX1_TESTCLR    (1<<0)
+#define DPHY_TX1RX1_TESTCLK    (1<<1)
+
+#define CSIHOST_PHY_TEST_CTRL1_OFFSET 0x0034
+#define DPHY_TX1RX1_TESTDIN_OFFSET_BITS    (0)
+#define DPHY_TX1RX1_TESTDOUT_OFFSET_BITS    (8)
+#define DPHY_TX1RX1_TESTEN    (16)
+*/
+
+#define GRF_SOC_STATUS21                  (0x2D4)
+
+#define CSIHOST_PHY_TEST_CTRL0            (0x30)
+#define CSIHOST_PHY_TEST_CTRL1            (0x34)
+#define CSIHOST_N_LANES                   (0x04)
+#define CSIHOST_PHY_SHUTDOWNZ             (0x08)
+#define CSIHOST_CSI2_RESETN               (0x10)
+#define CSIHOST_DPHY_RSTZ                 (0x0c)
+#define CSIHOST_PHY_STATE                 (0x14)
+#define CSIHOST_DATA_IDS1                 (0x18)
+#define CSIHOST_DATA_IDS2                 (0x1C)
+#define CSIHOST_ERR1                      (0x20)
+#define CSIHOST_ERR2                      (0x24)
+
+/*
+*GRF_SOC_CON6
+*dphy_rx_forcerxmode 11:8
+*isp_mipi_csi_host_sel:1
+*disable_isp:0
+*bit 0 grf_con_disable_isp
+*bit 1 isp_mipi_csi_host_sel  1'b0: mipi csi host
+*/
+#define GRF_SOC_CON6_OFFSET    (0x0418)
+/*bit 0*/
+#define MIPI_PHY_DISABLE_ISP_MASK       (0x1 << 16)
+#define MIPI_PHY_DISABLE_ISP            (0x0 << 0)
+/*bit 1*/
+#define ISP_MIPI_CSI_HOST_SEL_OFFSET_MASK       (0x1 << 17)
+#define ISP_MIPI_CSI_HOST_SEL_OFFSET_BIT       (0x1)
+/*bit 6*/
+#define DPHY_RX_CLK_INV_SEL_MASK  (0x1 << 22)
+#define DPHY_RX_CLK_INV_SEL   (0x1 << 6)
+/*bit 11:8*/
+#define DPHY_RX_FORCERXMODE_OFFSET_MASK     (0xF << 24)
+#define DPHY_RX_FORCERXMODE_OFFSET_BITS   (8)
+
+/*GRF_SOC_CON7*/
+/*dphy_tx0_forcerxmode*/
+#define GRF_SOC_CON7_OFFSET  (0x041c)
+/*bit 10:7*/
+#define FORCETXSTOPMODE_OFFSET_BITS   (7)
+#define FORCETXSTOPMODE_MASK   (0xF << 23)
+
+#define DPHY_TX0_FORCERXMODE   (6)
+#define DPHY_TX0_FORCERXMODE_MASK   (0x01 << 22)
+/*bit 5*/
+#define LANE0_TURNDISABLE_BITS  (5)
+#define LANE0_TURNDISABLE_MASK  (0x01 << 21)
+
+#define GRF_SOC_STATUS13  (0x04b4)
+/*dphy_rx_rxclkactivehs*/
+/*dphy_rx_direction*/
+/*dphy_rx_ulpsactivenot_0...3*/
+
+/*LOW POWER MODE SET*/
+/*base*/
+#define MIPI_CSI_DPHY_CTRL_LANE_ENABLE_OFFSET  (0x00)
+#define MIPI_CSI_DPHY_CTRL_LANE_ENABLE_OFFSET_BIT  (2)
+
+#define MIPI_CSI_DPHY_CTRL_PWRCTL_OFFSET  (0x04)
+#define MIPI_CSI_DPHY_CTRL_DIG_RST_OFFSET  (0x80)
+#define MIPI_CSI_DPHY_CTRL_SIG_INV_OFFSET   (0x84)
+
+/*Configure the count time of the THS-SETTLE by protocol.*/
+#define MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET  (0x00)
+/*MSB enable for pin_rxdatahs_
+*1: enable
+*0: disable
+*/
+#define MIPI_CSI_DPHY_LANEX_MSB_EN_OFFSET  (0x38)
+
+#define CSIHOST_N_LANES_OFFSET 0x04
+#define CSIHOST_N_LANES_OFFSET_BIT (0)
+
+#define write_grf_reg(addr, val)           \
+	__raw_writel(val, (void *)(addr + para->camsys_dev->rk_grf_base))
+#define read_grf_reg(addr)                 \
+	__raw_readl((void *)(addr + para->camsys_dev->rk_grf_base))
+#define mask_grf_reg(addr, msk, val)       \
+	write_grf_reg(addr, (val) | ((~(msk)) & read_grf_reg(addr)))
+
+#define write_cru_reg(addr, val)           \
+	__raw_writel(val, (void *)(addr + para->camsys_dev->rk_cru_base))
+
+/*#define cru_writel(v, o)	do {writel(v, RK_CRU_VIRT + (o)); dsb();} \
+*				while (0)
+*/
+
+#define write_csihost_reg(addr, val)       \
+	__raw_writel(val, (void *)(addr + phy_virt))
+#define read_csihost_reg(addr)             \
+	__raw_readl((void *)(addr + phy_virt))
+/*csi phy*/
+#define write_csiphy_reg(addr, val)       \
+	__raw_writel(val, (void *)(addr + csiphy_virt))
+#define read_csiphy_reg(addr)             \
+	__raw_readl((void *)(addr + csiphy_virt))
+
+#endif
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3368.c b/drivers/media/video/rk_camsys/camsys_soc_rk3368.c
index b534386a65fc..d7c05d3d5573 100644
--- a/drivers/media/video/rk_camsys/camsys_soc_rk3368.c
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3368.c
@@ -4,32 +4,32 @@
 
 
 struct mipiphy_hsfreqrange_s {
-    unsigned int range_l;
-    unsigned int range_h;
-    unsigned char cfg_bit;
+	unsigned int range_l;
+	unsigned int range_h;
+	unsigned char cfg_bit;
 };
 
 static struct mipiphy_hsfreqrange_s mipiphy_hsfreqrange[] = {
-    {80,110,0x00},
-    {110,150,0x01},
-    {150,200,0x02},
-    {200,250,0x03},
-    {250,300,0x04},
-    {300,400,0x05},
-    {400,500,0x06},
-    {500,600,0x07},
-    {600,700,0x08},
-    {700,800,0x09},
-    {800,1000,0x10},
-    {1000,1200,0x11},
-    {1200,1400,0x12},
-    {1400,1600,0x13},
-    {1600,1800,0x14}
-    
+	{80, 110, 0x00},
+	{110, 150, 0x01},
+	{150, 200, 0x02},
+	{200, 250, 0x03},
+	{250, 300, 0x04},
+	{300, 400, 0x05},
+	{400, 500, 0x06},
+	{500, 600, 0x07},
+	{600, 700, 0x08},
+	{700, 800, 0x09},
+	{800, 1000, 0x10},
+	{1000, 1200, 0x11},
+	{1200, 1400, 0x12},
+	{1400, 1600, 0x13},
+	{1600, 1800, 0x14}
 };
 
 #if 0
-static int camsys_rk3368_mipiphy_wr_reg(unsigned long phy_virt, unsigned char addr, unsigned char data)
+static int camsys_rk3368_mipiphy_wr_reg
+(unsigned long phy_virt, unsigned char addr, unsigned char data)
 {
 	/*TESTEN =1,TESTDIN=addr */
 	write_csihost_reg(CSIHOST_PHY_TEST_CTRL1, (0x00010000 | addr));
@@ -45,239 +45,196 @@ static int camsys_rk3368_mipiphy_wr_reg(unsigned long phy_virt, unsigned char ad
 	return 0;
 }
 
-static int camsys_rk3368_mipiphy_rd_reg(unsigned long phy_virt,unsigned char addr)
+static int camsys_rk3368_mipiphy_rd_reg
+(unsigned long phy_virt, unsigned char addr)
 {
-    return (read_csihost_reg(((CSIHOST_PHY_TEST_CTRL1)&0xff00))>>8);
+	return (read_csihost_reg(((CSIHOST_PHY_TEST_CTRL1)&0xff00))>>8);
 }
 
-static int camsys_rk3368_csiphy_wr_reg(unsigned long csiphy_virt, unsigned char addr, unsigned char data)
+static int camsys_rk3368_csiphy_wr_reg
+(unsigned long csiphy_virt, unsigned char addr, unsigned char data)
 {
-	write_csiphy_reg(addr,data);
+	write_csiphy_reg(addr, data);
 	return 0;
 }
 
-static int camsys_rk3368_csiphy_rd_reg(unsigned long csiphy_virt,unsigned char addr)
+static int camsys_rk3368_csiphy_rd_reg
+(unsigned long csiphy_virt, unsigned char addr)
 {
 	return read_csiphy_reg(addr);
 }
 #endif
-static int camsys_rk3368_mipihpy_cfg (camsys_mipiphy_soc_para_t *para)
-{ 
-    unsigned char hsfreqrange=0xff,i;
-    struct mipiphy_hsfreqrange_s *hsfreqrange_p;
-    unsigned long phy_virt, phy_index;
-    unsigned long base;
+static int camsys_rk3368_mipihpy_cfg(camsys_mipiphy_soc_para_t *para)
+{
+	unsigned char hsfreqrange = 0xff, i;
+	struct mipiphy_hsfreqrange_s *hsfreqrange_p;
+	unsigned long phy_virt, phy_index;
+	unsigned long base;
 	unsigned long csiphy_virt;
 
-    phy_index = para->phy->phy_index;
-    if (para->camsys_dev->mipiphy[phy_index].reg!=NULL) {
-        phy_virt  = para->camsys_dev->mipiphy[phy_index].reg->vir_base;
-    } else {
-        phy_virt = 0x00;
-    }
-    if(para->camsys_dev->csiphy_reg!=NULL){
-		csiphy_virt = (unsigned long)para->camsys_dev->csiphy_reg->vir_base;
-	}else {
+	phy_index = para->phy->phy_index;
+	if (para->camsys_dev->mipiphy[phy_index].reg != NULL) {
+		phy_virt = para->camsys_dev->mipiphy[phy_index].reg->vir_base;
+	} else {
+		phy_virt = 0x00;
+	}
+	if (para->camsys_dev->csiphy_reg != NULL) {
+		csiphy_virt =
+		(unsigned long)para->camsys_dev->csiphy_reg->vir_base;
+	} else {
 		csiphy_virt = 0x00;
 	}
-    if ((para->phy->bit_rate == 0) || (para->phy->data_en_bit == 0)) {
-        if (para->phy->phy_index == 0) {
-			camsys_trace(1, ">>>>>>>>>>>>>>>>para->phy->phy_index==0");	
-            base = (unsigned long)para->camsys_dev->devmems.registermem->vir_base;
-            *((unsigned int*)(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL))) &= ~(0x0f<<8);
-            camsys_trace(1, "mipi phy 0 standby!");		
-        } else if (para->phy->phy_index == 1) {
-			/*TODO*/
-        }
-
-        return 0;
-    }
-    
-    hsfreqrange_p = mipiphy_hsfreqrange;
-    for (i=0; i<(sizeof(mipiphy_hsfreqrange)/sizeof(struct mipiphy_hsfreqrange_s)); i++) {
-
-        if ((para->phy->bit_rate > hsfreqrange_p->range_l) && (para->phy->bit_rate <= hsfreqrange_p->range_h)) {
-            hsfreqrange = hsfreqrange_p->cfg_bit;
-            break;
-        }
-        hsfreqrange_p++;
-    }
-
-    if (hsfreqrange == 0xff) {
-        camsys_err("mipi phy config bitrate %d Mbps isn't supported!",para->phy->bit_rate);
-        hsfreqrange = 0x00;
-    }
-	/* hsfreqrange <<= 1; */
-
-    if (para->phy->phy_index == 0) {
-
-		/*isp select */
-        write_grf_reg(GRF_SOC_CON6_OFFSET, ISP_MIPI_CSI_HOST_SEL_OFFSET_MASK | (1<<ISP_MIPI_CSI_HOST_SEL_OFFSET_BIT)); 
-
-		/*phy start */
-        {
-			/*set clock lane */
-			/*write_csiphy_reg(0x34,0x00); */
-			
-            write_csiphy_reg((MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x100),hsfreqrange|(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x100)&(~0xf)));
-
-			if(para->phy->data_en_bit > 0x00){
-				write_csiphy_reg((MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x180),hsfreqrange|(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x180)&(~0xf)));//lane0			
-			}
-			if(para->phy->data_en_bit > 0x02){
-				write_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x200,hsfreqrange|(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x200)&(~0xf)));//lane1			
-			}
-			if(para->phy->data_en_bit > 0x04){
-				write_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x280,hsfreqrange|(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x280)&(~0xf)));//lane2			
-				write_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x300,hsfreqrange|(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x300)&(~0xf)));	//lane3				
-			}
+	if ((para->phy->bit_rate == 0) ||
+		(para->phy->data_en_bit == 0)) {
+		if (para->phy->phy_index == 0) {
+			base =
+			(unsigned long)
+			para->camsys_dev->devmems.registermem->vir_base;
+			*((unsigned int *)
+				(base + (MRV_MIPI_BASE + MRV_MIPI_CTRL)))
+				&= ~(0x0f << 8);
+			camsys_trace(1, "mipi phy 0 standby!");
+		}
 
-			/*set data lane num and enable clock lane */
-			write_csiphy_reg( 0x00, ((para->phy->data_en_bit << 2)|(0x1<<6)|0x1));
-			//base = (unsigned long)para->camsys_dev->devmems.registermem->vir_base;
-			//*((unsigned int*)(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL))) =( 0x1|((/*para->phy->data_en_bit*/0x0)<<12)|0x1<<18);
+		return 0;
+	}
 
-        }
-		camsys_trace(1,"vir_base=0x%lx",(unsigned long)para->camsys_dev->devmems.registermem->vir_base);		
+	hsfreqrange_p = mipiphy_hsfreqrange;
+	for (i = 0;
+		i < (sizeof(mipiphy_hsfreqrange)/
+			sizeof(struct mipiphy_hsfreqrange_s));
+		i++) {
 
-        base = (unsigned long)para->camsys_dev->devmems.registermem->vir_base;
-        *((unsigned int*)(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL))) &= ~(0x0f<<8);
-        camsys_trace(1,"val:0x%x",*((unsigned int*)(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL))));
-    }
-#if 0	
-	else if (para->phy->phy_index == 1){
-		
-		//csihost select
-        write_grf_reg(GRF_SOC_CON6_OFFSET, ISP_MIPI_CSI_HOST_SEL_OFFSET_MASK | (0<<ISP_MIPI_CSI_HOST_SEL_OFFSET_BIT)); 
-		  
-		write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002); 		 //TESTCLK=1
-		write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000003); 		 //TESTCLR=1 TESTCLK=1	
-		udelay(100);
-		write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002); 		 //TESTCLR=0 TESTCLK=1
-		udelay(100);
+		if ((para->phy->bit_rate > hsfreqrange_p->range_l) &&
+			(para->phy->bit_rate <= hsfreqrange_p->range_h)) {
+			hsfreqrange = hsfreqrange_p->cfg_bit;
+			break;
+		}
+		hsfreqrange_p++;
+	}
 
-		//set lane num, csi phy
-		camsys_rk3368_mipiphy_wr_reg(phy_virt, MIPI_CSI_DPHY_CTRL_LANE_ENABLE_OFFSET<<2, para->phy->data_en_bit << MIPI_CSI_DPHY_CTRL_LANE_ENABLE_OFFSET_BIT);
+	if (hsfreqrange == 0xff) {
+		camsys_err("mipi phy config bitrate %d Mbps isn't supported!",
+			para->phy->bit_rate);
+		hsfreqrange = 0x00;
+	}
 
-		//set clock lane
-		camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x100)<<2,0x00);
-		//MSB enable
-		//camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_MSB_EN_OFFSET+0x100)<<2,0x40); 		
-		if(para->phy->data_en_bit > 0x00){
-			camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x180)<<2,hsfreqrange);//lane0
-			//MSB enable
-			//camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_MSB_EN_OFFSET+0x180)<<2,0x40);
-		}
-		if(para->phy->data_en_bit > 0x02){
-			camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x200)<<2,hsfreqrange);//lane1
-			//MSB enable
-			//camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_MSB_EN_OFFSET+0x200)<<2,0x40);
-		}
-		if(para->phy->data_en_bit > 0x04){
-			camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x280)<<2,hsfreqrange);//lane2
-			//MSB enable
-			//camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_MSB_EN_OFFSET+0x280)<<2,0x40);
-			camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET+0x300)<<2,hsfreqrange); //lane3 
-			//MSB enable
-			//camsys_rk3368_mipiphy_wr_reg(phy_virt, (MIPI_CSI_DPHY_LANEX_MSB_EN_OFFSET+0x300)<<2,0x40);
-		}
+	if (para->phy->phy_index == 0) {
+	/* isp select */
+	write_grf_reg(GRF_SOC_CON6_OFFSET, ISP_MIPI_CSI_HOST_SEL_OFFSET_MASK
+				| (1 << ISP_MIPI_CSI_HOST_SEL_OFFSET_BIT));
+
+	/* phy start */
+	write_csiphy_reg((MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET + 0x100),
+		hsfreqrange |
+		(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+		+ 0x100) & (~0xf)));
+
+	if (para->phy->data_en_bit > 0x00) {
+		write_csiphy_reg((MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+			+ 0x180), hsfreqrange |
+			(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+			+ 0x180) & (~0xf)));
+	}
+	if (para->phy->data_en_bit > 0x02) {
+		write_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+			+ 0x200, hsfreqrange |
+			(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+			+ 0x200) & (~0xf)));
+	}
+	if (para->phy->data_en_bit > 0x04) {
+		write_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+			+ 0x280, hsfreqrange |
+			(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+			+ 0x280) & (~0xf)));
+		write_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+			+ 0x300, hsfreqrange |
+			(read_csiphy_reg(MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET
+			+ 0x300) & (~0xf)));
+	}
 
-		
-		//set active lane num, csi host
-		if(para->phy->data_en_bit > 0x00){
-			write_csihost_reg(CSIHOST_N_LANES_OFFSET, 0x00);//one lane active
-		}else if(para->phy->data_en_bit > 0x01){
-			write_csihost_reg(CSIHOST_N_LANES_OFFSET, 0x01);//two lane active
-		}else if(para->phy->data_en_bit > 0x04){
-			write_csihost_reg(CSIHOST_N_LANES_OFFSET, 0x02);// three lane active
-		}else if(para->phy->data_en_bit > 0x08){
-			write_csihost_reg(CSIHOST_N_LANES_OFFSET, 0x03);//foure lane active
-		}
-		camsys_rk3368_mipiphy_rd_reg(phy_virt,0x0);
-		write_csihost_reg(CSIHOST_PHY_TEST_CTRL0,0x00000002);  //TESTCLK=1			
-		write_csihost_reg(CSIHOST_PHY_TEST_CTRL1,0x00000000); //TESTCLR=0	
-        write_csihost_reg(CSIHOST_PHY_SHUTDOWNZ,0x00000001);  //SHUTDOWNZ=1
-        write_csihost_reg(CSIHOST_DPHY_RSTZ,0x00000001);  //RSTZ=1	
-        write_csihost_reg(CSIHOST_CSI2_RESETN,0x00000001);  //RESETN=1	       
-    }
-#endif
-    else {
-        camsys_err("mipi phy index %d is invalidate!",para->phy->phy_index);
-        goto fail;
-    }
+	/*set data lane num and enable clock lane */
+	write_csiphy_reg(0x00, ((para->phy->data_en_bit << 2)
+					| (0x1 << 6) | 0x1));
+
+	base = (unsigned long)para->camsys_dev->devmems.registermem->vir_base;
+	*((unsigned int *)(base + (MRV_MIPI_BASE + MRV_MIPI_CTRL)))
+							&= ~(0x0f << 8);
+	} else {
+		camsys_err("mipi phy index %d is invalidate!",
+			para->phy->phy_index);
+		goto fail;
+	}
 
-    camsys_trace(1, "mipi phy(%d) turn on(lane: 0x%x  bit_rate: %dMbps)",para->phy->phy_index,para->phy->data_en_bit, para->phy->bit_rate);
+	camsys_trace(1, "mipi phy(%d) turn on(lane: 0x%x  bit_rate: %dMbps)",
+		para->phy->phy_index,
+		para->phy->data_en_bit, para->phy->bit_rate);
 
-    return 0;
+	return 0;
 
 fail:
-    return -1;
+	return -1;
 }
 
 #define MRV_AFM_BASE		0x0000
-#define VI_IRCL				0x0014
-int camsys_rk3368_cfg (camsys_soc_cfg_t cfg_cmd, void* cfg_para)
+#define VI_IRCL			0x0014
+int camsys_rk3368_cfg(
+camsys_dev_t *camsys_dev, camsys_soc_cfg_t cfg_cmd, void *cfg_para)
 {
-    unsigned int *para_int;
-    
-    switch (cfg_cmd)
-    {
-        case Clk_DriverStrength_Cfg:
-        {
-            para_int = (unsigned int*)cfg_para;
-			__raw_writel((((*para_int)&0x03)<<3)|(0x03<<3), (void*)(rk_grf_base+0x204));
-            //__raw_writel(0xffffffff, rk_grf_base+0x204);
-            break;
-        }
+	unsigned int *para_int;
+
+	switch (cfg_cmd) {
+	case Clk_DriverStrength_Cfg: {
+		para_int = (unsigned int *)cfg_para;
+		__raw_writel((((*para_int) & 0x03) << 3) | (0x03 << 3),
+				(void *)(camsys_dev->rk_grf_base + 0x204));
+		/* set 0xffffffff to max all */
+		break;
+	}
 
-        case Cif_IoDomain_Cfg:
-        {
-            para_int = (unsigned int*)cfg_para;
-            if (*para_int < 28000000) {
-                __raw_writel(((1<<1)|(1<<(1+16))),(void*)(rk_grf_base+0x0900));    // 1.8v IO
-            } else {
-                __raw_writel(((0<<1)|(1<<(1+16))),(void*)(rk_grf_base+0x0900));    // 3.3v IO
-            }
-            break;
-        }
+	case Cif_IoDomain_Cfg: {
+		para_int = (unsigned int *)cfg_para;
+		if (*para_int < 28000000) {
+			/* 1.8v IO */
+			__raw_writel(((1 << 1) | (1 << (1 + 16))),
+				(void *)(camsys_dev->rk_grf_base + 0x0900));
+		} else {
+			/* 3.3v IO */
+			__raw_writel(((0 << 1) | (1 << (1 + 16))),
+				(void *)(camsys_dev->rk_grf_base + 0x0900));
+			}
+		break;
+	}
+
+	case Mipi_Phy_Cfg: {
+		camsys_rk3368_mipihpy_cfg
+			((camsys_mipiphy_soc_para_t *)cfg_para);
+		break;
+	}
+
+	case Isp_SoftRst: {/* ddl@rock-chips.com: v0.d.0 */
+		unsigned long reset;
 
-        case Mipi_Phy_Cfg:
-        {
-            camsys_rk3368_mipihpy_cfg((camsys_mipiphy_soc_para_t*)cfg_para);
-            break;
-        }
+		reset = (unsigned long)cfg_para;
 
-        case Isp_SoftRst:         /* ddl@rock-chips.com: v0.d.0 */
-        {
-            unsigned long reset;
-            reset = (unsigned long)cfg_para;
-			#if 0
-            if (reset == 1)
-                write_cru_reg(0x318,0x40004000);
-            else 
-                write_cru_reg(0x318,0x40000000);
-            camsys_trace(1, "Isp_SoftRst: %d",reset);
-			#endif
-			if (reset == 1)
-				__raw_writel(0x80,
-					     (void*)(rk_isp_base + MRV_AFM_BASE +
-					     VI_IRCL));
-			else
-				__raw_writel(0x00,
-					     (void*)(rk_isp_base + MRV_AFM_BASE +
-					     VI_IRCL));
+		if (reset == 1)
+			__raw_writel(0x80, (void *)(camsys_dev->rk_isp_base +
+			MRV_AFM_BASE + VI_IRCL));
+		else
+			__raw_writel(0x00, (void *)(camsys_dev->rk_isp_base +
+			MRV_AFM_BASE + VI_IRCL));
 			camsys_trace(1, "Isp self soft rst: %ld", reset);
-            break;
-        }
+			break;
+		}
 
-        default:
-        {
-            camsys_warn("cfg_cmd: 0x%x isn't support",cfg_cmd);
-            break;
-        }
+	default:
+	{
+		camsys_warn("cfg_cmd: 0x%x isn't support", cfg_cmd);
+		break;
+	}
 
-    }
+	}
 
-    return 0;
+	return 0;
 }
 #endif /* CONFIG_ARM64 */
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3368.h b/drivers/media/video/rk_camsys/camsys_soc_rk3368.h
index 47efb19d2fcf..12ec006284e3 100644
--- a/drivers/media/video/rk_camsys/camsys_soc_rk3368.h
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3368.h
@@ -8,7 +8,7 @@
 #define MRV_MIPI_CTRL                           0x00
 
 /*
-#define CSIHOST_PHY_TEST_CTRL0_OFFSET 0x0030
+*#define CSIHOST_PHY_TEST_CTRL0_OFFSET 0x0030
 #define DPHY_TX1RX1_TESTCLR    (1<<0)
 #define DPHY_TX1RX1_TESTCLK    (1<<1)
 
@@ -42,16 +42,16 @@
 */
 #define GRF_SOC_CON6_OFFSET    (0x0418)
 /*bit 0*/
-#define MIPI_PHY_DISABLE_ISP_MASK       (0x1<<16)
-#define MIPI_PHY_DISABLE_ISP            (0x0<<0)
+#define MIPI_PHY_DISABLE_ISP_MASK       (0x1 << 16)
+#define MIPI_PHY_DISABLE_ISP            (0x0 << 0)
 /*bit 1*/
-#define ISP_MIPI_CSI_HOST_SEL_OFFSET_MASK       (0x1<<17)
+#define ISP_MIPI_CSI_HOST_SEL_OFFSET_MASK       (0x1 << 17)
 #define ISP_MIPI_CSI_HOST_SEL_OFFSET_BIT       (0x1)
 /*bit 6*/
-#define DPHY_RX_CLK_INV_SEL_MASK  (0x1<<22)
-#define DPHY_RX_CLK_INV_SEL   (0x1<<6)
+#define DPHY_RX_CLK_INV_SEL_MASK  (0x1 << 22)
+#define DPHY_RX_CLK_INV_SEL   (0x1 << 6)
 /*bit 11:8*/
-#define DPHY_RX_FORCERXMODE_OFFSET_MASK     (0xF<<24)
+#define DPHY_RX_FORCERXMODE_OFFSET_MASK     (0xF << 24)
 #define DPHY_RX_FORCERXMODE_OFFSET_BITS   (8)
 
 /*GRF_SOC_CON7*/
@@ -59,13 +59,13 @@
 #define GRF_SOC_CON7_OFFSET  (0x041c)
 /*bit 10:7*/
 #define FORCETXSTOPMODE_OFFSET_BITS   (7)
-#define FORCETXSTOPMODE_MASK   (0xF<<23)
+#define FORCETXSTOPMODE_MASK   (0xF << 23)
 
 #define DPHY_TX0_FORCERXMODE   (6)
-#define DPHY_TX0_FORCERXMODE_MASK   (0x01<<22)
+#define DPHY_TX0_FORCERXMODE_MASK   (0x01 << 22)
 /*bit 5*/
 #define LANE0_TURNDISABLE_BITS  (5)
-#define LANE0_TURNDISABLE_MASK  (0x01<<21)
+#define LANE0_TURNDISABLE_MASK  (0x01 << 21)
 
 #define GRF_SOC_STATUS13  (0x04b4)
 /*dphy_rx_rxclkactivehs*/
@@ -92,20 +92,28 @@
 #define CSIHOST_N_LANES_OFFSET 0x04
 #define CSIHOST_N_LANES_OFFSET_BIT (0)
 
-#define write_grf_reg(addr, val)           __raw_writel(val, (void*)(addr+rk_grf_base)) //__raw_writel(val, addr+RK_GRF_VIRT)
-#define read_grf_reg(addr)                 __raw_readl((void*)(addr+rk_grf_base)) //__raw_readl(addr+RK_GRF_VIRT)
-#define mask_grf_reg(addr, msk, val)       write_grf_reg(addr,(val)|((~(msk))&read_grf_reg(addr)))
+#define write_grf_reg(addr, val)           \
+	__raw_writel(val, (void *)(addr + para->camsys_dev->rk_grf_base))
+#define read_grf_reg(addr)                 \
+	__raw_readl((void *)(addr + para->camsys_dev->rk_grf_base))
+#define mask_grf_reg(addr, msk, val)       \
+	write_grf_reg(addr, (val) | ((~(msk)) & read_grf_reg(addr)))
 
-#define write_cru_reg(addr, val)           __raw_writel(val, (void*)(addr+rk_cru_base))
+#define write_cru_reg(addr, val)           \
+	__raw_writel(val, (void *)(addr + para->camsys_dev->rk_cru_base))
 
 /*#define cru_writel(v, o)	do {writel(v, RK_CRU_VIRT + (o)); dsb();} \
-				while (0)
+*				while (0)
 */
 
-#define write_csihost_reg(addr, val)       __raw_writel(val, (void*)(addr+phy_virt))//__raw_writel(val, addr+IOMEM(phy_virt))
-#define read_csihost_reg(addr)             __raw_readl((void*)(addr+phy_virt))//__raw_readl(addr+IOMEM(phy_virt))
+#define write_csihost_reg(addr, val)       \
+	__raw_writel(val, (void *)(addr + phy_virt))
+#define read_csihost_reg(addr)             \
+	__raw_readl((void *)(addr + phy_virt))
 /*csi phy*/
-#define write_csiphy_reg(addr, val)       __raw_writel(val, (void*)(addr+csiphy_virt))//__raw_writel(val, addr+IOMEM(csiphy_virt))
-#define read_csiphy_reg(addr)             __raw_readl((void*)(addr+csiphy_virt))//__raw_readl(addr+IOMEM(csiphy_virt))
+#define write_csiphy_reg(addr, val)       \
+	__raw_writel(val, (void *)(addr + csiphy_virt))
+#define read_csiphy_reg(addr)             \
+	__raw_readl((void *)(addr + csiphy_virt))
 
 #endif
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3399.c b/drivers/media/video/rk_camsys/camsys_soc_rk3399.c
new file mode 100644
index 000000000000..856b9e8bbd35
--- /dev/null
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3399.c
@@ -0,0 +1,389 @@
+#ifdef CONFIG_ARM64
+#include "camsys_soc_priv.h"
+#include "camsys_soc_rk3399.h"
+
+struct mipiphy_hsfreqrange_s {
+	unsigned int range_l;
+	unsigned int range_h;
+	unsigned char cfg_bit;
+};
+
+static struct mipiphy_hsfreqrange_s mipiphy_hsfreqrange[] = {
+	{80, 110, 0x00},
+	{110, 150, 0x01},
+	{150, 200, 0x02},
+	{200, 250, 0x03},
+	{250, 300, 0x04},
+	{300, 400, 0x05},
+	{400, 500, 0x06},
+	{500, 600, 0x07},
+	{600, 700, 0x08},
+	{700, 800, 0x09},
+	{800, 1000, 0x10},
+	{1000, 1200, 0x11},
+	{1200, 1400, 0x12},
+	{1400, 1600, 0x13},
+	{1600, 1800, 0x14}
+};
+
+#if 0
+static int camsys_rk3399_mipiphy0_rd_reg(unsigned char addr)
+{
+    return read_grf_reg(0x0e2a4);
+}
+#endif
+
+static int camsys_rk3399_mipiphy0_wr_reg
+(camsys_mipiphy_soc_para_t *para, unsigned char addr, unsigned char data)
+{
+	/*TESTCLK=1*/
+	write_grf_reg(GRF_SOC_CON25_OFFSET, DPHY_RX0_TESTCLK_MASK |
+				(1 << DPHY_RX0_TESTCLK_BIT));
+	/*TESTEN =1,TESTDIN=addr*/
+	write_grf_reg(GRF_SOC_CON25_OFFSET,
+				((addr << DPHY_RX0_TESTDIN_BIT) |
+				DPHY_RX0_TESTDIN_MASK |
+				(1 << DPHY_RX0_TESTEN_BIT) |
+				DPHY_RX0_TESTEN_MASK));
+	/*TESTCLK=0*/
+	write_grf_reg(GRF_SOC_CON25_OFFSET, DPHY_RX0_TESTCLK_MASK);
+
+	if (data != 0xff) { /*write data ?*/
+		/*TESTEN =0,TESTDIN=data*/
+		write_grf_reg(GRF_SOC_CON25_OFFSET,
+					((data << DPHY_RX0_TESTDIN_BIT) |
+					DPHY_RX0_TESTDIN_MASK |
+					DPHY_RX0_TESTEN_MASK));
+
+		/*TESTCLK=1*/
+		write_grf_reg(GRF_SOC_CON25_OFFSET, DPHY_RX0_TESTCLK_MASK |
+					(1 << DPHY_RX0_TESTCLK_BIT));
+	}
+	return 0;
+}
+
+static int camsys_rk3399_mipiphy1_wr_reg
+(unsigned long dsiphy_virt, unsigned char addr, unsigned char data)
+{
+	/*TESTEN =1,TESTDIN=addr*/
+	write_dsihost_reg(DSIHOST_PHY_TEST_CTRL1, (0x00010000 | addr));
+	/*TESTCLK=0*/
+	write_dsihost_reg(DSIHOST_PHY_TEST_CTRL0, 0x00000000);
+	/*TESTEN =0,TESTDIN=data*/
+	write_dsihost_reg(DSIHOST_PHY_TEST_CTRL1, (0x00000000 | data));
+	/*TESTCLK=1 */
+	write_dsihost_reg(DSIHOST_PHY_TEST_CTRL0, 0x00000002);
+
+	return 0;
+}
+/*
+static int camsys_rk3399_mipiphy1_rd_reg
+(unsigned long dsiphy_virt,unsigned char addr)
+{
+    return (read_dsihost_reg(((DSIHOST_PHY_TEST_CTRL1)&0xff00))>>8);
+}*/
+
+static int camsys_rk3399_mipihpy_cfg
+(camsys_mipiphy_soc_para_t *para)
+{
+	unsigned char hsfreqrange = 0xff, i;
+	struct mipiphy_hsfreqrange_s *hsfreqrange_p;
+	unsigned long phy_virt, phy_index;
+	unsigned long base;
+	unsigned long csiphy_virt;
+	unsigned long dsiphy_virt;
+	unsigned long vir_base = 0;
+
+	phy_index = para->phy->phy_index;
+	if (para->camsys_dev->mipiphy[phy_index].reg != NULL) {
+		phy_virt  = para->camsys_dev->mipiphy[phy_index].reg->vir_base;
+	} else {
+		phy_virt = 0x00;
+	}
+	if (para->camsys_dev->csiphy_reg != NULL) {
+		csiphy_virt =
+			(unsigned long)para->camsys_dev->csiphy_reg->vir_base;
+	} else {
+		csiphy_virt = 0x00;
+	}
+	if (para->camsys_dev->dsiphy_reg != NULL) {
+		dsiphy_virt =
+			(unsigned long)para->camsys_dev->dsiphy_reg->vir_base;
+	} else {
+		dsiphy_virt = 0x00;
+	}
+
+	if ((para->phy->bit_rate == 0) ||
+		(para->phy->data_en_bit == 0)) {
+		if (para->phy->phy_index == 0) {
+			base =
+			(para->camsys_dev->devmems.registermem->vir_base);
+			*((unsigned int *)
+				(base + (MRV_MIPI_BASE + MRV_MIPI_CTRL)))
+				&= ~(0x0f << 8);
+		camsys_trace(1, "mipi phy 0 standby!");
+		}
+
+		return 0;
+	}
+
+	hsfreqrange_p = mipiphy_hsfreqrange;
+	for (i = 0;
+		i < (sizeof(mipiphy_hsfreqrange)/
+			sizeof(struct mipiphy_hsfreqrange_s));
+		i++) {
+		if ((para->phy->bit_rate > hsfreqrange_p->range_l) &&
+			(para->phy->bit_rate <= hsfreqrange_p->range_h)) {
+			hsfreqrange = hsfreqrange_p->cfg_bit;
+			break;
+		}
+		hsfreqrange_p++;
+	}
+
+	if (hsfreqrange == 0xff) {
+		camsys_err("mipi phy config bitrate %d Mbps isn't supported!",
+			para->phy->bit_rate);
+		hsfreqrange = 0x00;
+	}
+	hsfreqrange <<= 1;
+	if (para->phy->phy_index == 0) {
+		if (strstr(para->camsys_dev->miscdev.name, "camsys_marvin1")) {
+			camsys_err("miscdev.name = %s,mipi phy index %d is invalidate\n",
+				para->camsys_dev->miscdev.name,
+				para->phy->phy_index);
+			goto fail;
+		}
+
+		write_grf_reg(GRF_SOC_CON21_OFFSET,
+					DPHY_RX0_FORCERXMODE_MASK |
+					(0x0 << DPHY_RX0_FORCERXMODE_BIT) |
+					DPHY_RX0_FORCETXSTOPMODE_MASK |
+					(0x0 << DPHY_RX0_FORCETXSTOPMODE_BIT));
+
+		/*  set lane num*/
+		write_grf_reg(GRF_SOC_CON21_OFFSET,
+			DPHY_RX0_ENABLE_MASK |
+			(para->phy->data_en_bit << DPHY_RX0_ENABLE_BIT));
+
+		/*  set lan turndisab as 1*/
+		write_grf_reg(GRF_SOC_CON21_OFFSET,
+			DPHY_RX0_TURNDISABLE_MASK |
+			(0xf << DPHY_RX0_TURNDISABLE_BIT));
+		write_grf_reg(GRF_SOC_CON21_OFFSET, (0x0<<4) | (0xf<<20));
+
+		/*  set lan turnrequest as 0 */
+		write_grf_reg(GRF_SOC_CON9_OFFSET,
+			DPHY_RX0_TURNREQUEST_MASK |
+			(0x0 << DPHY_RX0_TURNREQUEST_BIT));
+
+		/*phy start*/
+		{
+			write_grf_reg(GRF_SOC_CON25_OFFSET,
+				DPHY_RX0_TESTCLK_MASK |
+				(0x1 << DPHY_RX0_TESTCLK_BIT)); /*TESTCLK=1 */
+			write_grf_reg(GRF_SOC_CON25_OFFSET,
+				DPHY_RX0_TESTCLR_MASK |
+				(0x1 << DPHY_RX0_TESTCLR_BIT));   /*TESTCLR=1*/
+			udelay(100);
+			/*TESTCLR=0  zyc*/
+			write_grf_reg(GRF_SOC_CON25_OFFSET,
+				DPHY_RX0_TESTCLR_MASK);
+			udelay(100);
+
+			/*set clock lane*/
+			camsys_rk3399_mipiphy0_wr_reg
+				(para, 0x34, 0x15);
+
+			if (para->phy->data_en_bit >= 0x00) {
+				camsys_rk3399_mipiphy0_wr_reg
+					(para, 0x44, hsfreqrange);
+			}
+			if (para->phy->data_en_bit >= 0x01)
+				camsys_rk3399_mipiphy0_wr_reg
+				(para, 0x54, hsfreqrange);
+			if (para->phy->data_en_bit >= 0x04) {
+				camsys_rk3399_mipiphy0_wr_reg
+					(para, 0x84, hsfreqrange);
+				camsys_rk3399_mipiphy0_wr_reg
+					(para, 0x94, hsfreqrange);
+			}
+			/*Normal operation*/
+			camsys_rk3399_mipiphy0_wr_reg(para, 0x0, -1);
+			write_grf_reg(GRF_SOC_CON25_OFFSET,
+				DPHY_RX0_TESTCLK_MASK |
+				(1 << DPHY_RX0_TESTCLK_BIT));    /*TESTCLK=1*/
+			/*TESTEN =0 */
+			write_grf_reg(GRF_SOC_CON25_OFFSET,
+				(DPHY_RX0_TESTEN_MASK));
+		}
+
+		base = (para->camsys_dev->devmems.registermem->vir_base);
+		*((unsigned int *)(base + (MRV_MIPI_BASE+MRV_MIPI_CTRL))) |=
+			(0x0f<<8);
+
+    } else if (para->phy->phy_index == 1) {
+
+		if (!strstr(para->camsys_dev->miscdev.name, "camsys_marvin1")) {
+			camsys_err
+				("miscdev.name = %s,mipi phy index %d is invalidate\n",
+				para->camsys_dev->miscdev.name,
+				para->phy->phy_index);
+			goto fail;
+		}
+
+		write_grf_reg(GRF_SOC_CON23_OFFSET,
+			DPHY_RX0_FORCERXMODE_MASK |
+			(0x0 << DPHY_RX0_FORCERXMODE_BIT) |
+			DPHY_RX0_FORCETXSTOPMODE_MASK |
+			(0x0 << DPHY_RX0_FORCETXSTOPMODE_BIT));
+		write_grf_reg(GRF_SOC_CON24_OFFSET,
+			DPHY_TX1RX1_MASTERSLAVEZ_MASK |
+			(0x0 << DPHY_TX1RX1_MASTERSLAVEZ_BIT) |
+			DPHY_TX1RX1_BASEDIR_MASK |
+			(0x1 << DPHY_TX1RX1_BASEDIR_BIT) |
+			DPHY_RX1_MASK | 0x0 << DPHY_RX1_SEL_BIT);
+
+
+		/*	set lane num*/
+		write_grf_reg(GRF_SOC_CON23_OFFSET,
+			DPHY_TX1RX1_ENABLE_MASK |
+			(para->phy->data_en_bit << DPHY_TX1RX1_ENABLE_BIT));
+
+		/*	set lan turndisab as 1*/
+		write_grf_reg(GRF_SOC_CON23_OFFSET,
+			DPHY_TX1RX1_TURNDISABLE_MASK |
+			(0xf << DPHY_TX1RX1_TURNDISABLE_BIT));
+		write_grf_reg(GRF_SOC_CON23_OFFSET, (0x0<<4)|(0xf<<20));
+
+		/*	set lan turnrequest as 0*/
+		write_grf_reg(GRF_SOC_CON24_OFFSET,
+			DPHY_TX1RX1_TURNREQUEST_MASK |
+			(0x0 << DPHY_TX1RX1_TURNREQUEST_BIT));
+		/*phy1 start*/
+		{
+			int res_val = 0;
+			res_val = read_dsihost_reg(DSIHOST_PHY_SHUTDOWNZ);
+			res_val &= 0xfffffffe;
+			/*SHUTDOWNZ=0*/
+			write_dsihost_reg(DSIHOST_PHY_SHUTDOWNZ, res_val);
+
+			vir_base = (unsigned long)ioremap(0xff910000, 0x10000);
+			/*__raw_writel(0x60000, (void*)(0x1c00+vir_base));*/
+
+			res_val = 0;
+			res_val = read_dsihost_reg(DSIHOST_DPHY_RSTZ);
+			res_val &= 0xfffffffd;
+			/*RSTZ=0*/
+			write_dsihost_reg(DSIHOST_DPHY_RSTZ, res_val);
+			/*TESTCLK=1*/
+			write_dsihost_reg(DSIHOST_PHY_TEST_CTRL0, 0x00000002);
+			/*TESTCLR=1 TESTCLK=1 */
+			write_dsihost_reg(DSIHOST_PHY_TEST_CTRL0, 0x00000003);
+			udelay(100);
+			/*TESTCLR=0 TESTCLK=1*/
+			write_dsihost_reg(DSIHOST_PHY_TEST_CTRL0, 0x00000002);
+			udelay(100);
+
+			/*set clock lane*/
+			camsys_rk3399_mipiphy1_wr_reg
+				(dsiphy_virt, 0x34, 0x15);
+			if (para->phy->data_en_bit >= 0x00)
+				camsys_rk3399_mipiphy1_wr_reg
+				(dsiphy_virt, 0x44, hsfreqrange);
+			if (para->phy->data_en_bit >= 0x01)
+				camsys_rk3399_mipiphy1_wr_reg
+				(dsiphy_virt, 0x54, hsfreqrange);
+			if (para->phy->data_en_bit >= 0x04) {
+				camsys_rk3399_mipiphy1_wr_reg
+					(dsiphy_virt, 0x84, hsfreqrange);
+				camsys_rk3399_mipiphy1_wr_reg
+					(dsiphy_virt, 0x94, hsfreqrange);
+			}
+
+			/*camsys_rk3399_mipiphy1_rd_reg(dsiphy_virt,0x0);*/
+			/*TESTCLK=1*/
+			write_dsihost_reg(DSIHOST_PHY_TEST_CTRL0, 0x00000002);
+			/*TESTEN =0*/
+			write_dsihost_reg(DSIHOST_PHY_TEST_CTRL1, 0x00000000);
+			/*SHUTDOWNZ=1*/
+			write_dsihost_reg(DSIHOST_PHY_SHUTDOWNZ, 0x00000001);
+			/*__raw_writel(0x60f00, (void*)(0x1c00+vir_base));*/
+			/*RSTZ=1*/
+			write_dsihost_reg(DSIHOST_DPHY_RSTZ, 0x00000001);
+		}
+
+	} else {
+		camsys_err("mipi phy index %d is invalidate!",
+			para->phy->phy_index);
+		goto fail;
+	}
+
+	camsys_trace(1, "mipi phy(%d) turn on(lane: 0x%x  bit_rate: %dMbps)",
+		para->phy->phy_index, para->phy->data_en_bit,
+		para->phy->bit_rate);
+
+	return 0;
+
+fail:
+	return -1;
+}
+
+#define MRV_AFM_BASE		0x0000
+#define VI_IRCL			0x0014
+int camsys_rk3399_cfg
+(camsys_dev_t *camsys_dev, camsys_soc_cfg_t cfg_cmd, void *cfg_para)
+{
+	unsigned int *para_int;
+
+	switch (cfg_cmd) {
+	case Clk_DriverStrength_Cfg: {
+		para_int = (unsigned int *)cfg_para;
+		__raw_writel((((*para_int) & 0x03) << 3) | (0x03 << 3),
+		(void *)(camsys_dev->rk_grf_base + 0x204));
+		/* set 0xffffffff to max all */
+		break;
+	}
+
+	case Cif_IoDomain_Cfg: {
+		para_int = (unsigned int *)cfg_para;
+		if (*para_int < 28000000) {
+			/* 1.8v IO */
+			__raw_writel(((1 << 1) | (1 << (1 + 16))),
+			(void *)(camsys_dev->rk_grf_base + 0x0900));
+		} else {
+			/* 3.3v IO */
+			__raw_writel(((0 << 1) | (1 << (1 + 16))),
+			(void *)(camsys_dev->rk_grf_base + 0x0900));
+		}
+		break;
+	}
+
+	case Mipi_Phy_Cfg: {
+		camsys_rk3399_mipihpy_cfg
+			((camsys_mipiphy_soc_para_t *)cfg_para);
+		break;
+	}
+
+	case Isp_SoftRst: /* ddl@rock-chips.com: v0.d.0 */ {
+		unsigned long reset;
+		reset = (unsigned long)cfg_para;
+
+		if (reset == 1)
+			__raw_writel(0x80, (void *)(camsys_dev->rk_isp_base +
+			MRV_AFM_BASE + VI_IRCL));
+		else
+			__raw_writel(0x00, (void *)(camsys_dev->rk_isp_base +
+			MRV_AFM_BASE + VI_IRCL));
+		break;
+	}
+
+	default: {
+		camsys_warn("cfg_cmd: 0x%x isn't support", cfg_cmd);
+		break;
+	}
+
+	}
+
+	return 0;
+}
+#endif /* CONFIG_ARM64 */
diff --git a/drivers/media/video/rk_camsys/camsys_soc_rk3399.h b/drivers/media/video/rk_camsys/camsys_soc_rk3399.h
new file mode 100644
index 000000000000..cb7c28a4c385
--- /dev/null
+++ b/drivers/media/video/rk_camsys/camsys_soc_rk3399.h
@@ -0,0 +1,175 @@
+#ifndef __RKCAMSYS_SOC_RK3399_H__
+#define __RKCAMSYS_SOC_RK3399_H__
+
+#include "camsys_internal.h"
+
+/*MARVIN REGISTER*/
+#define MRV_MIPI_BASE                           0x1C00
+#define MRV_MIPI_CTRL                           0x00
+
+/*
+*#define CSIHOST_PHY_TEST_CTRL0_OFFSET 0x0030
+#define DPHY_TX1RX1_TESTCLR    (1<<0)
+#define DPHY_TX1RX1_TESTCLK    (1<<1)
+
+#define CSIHOST_PHY_TEST_CTRL1_OFFSET 0x0034
+#define DPHY_TX1RX1_TESTDIN_OFFSET_BITS    (0)
+#define DPHY_TX1RX1_TESTDOUT_OFFSET_BITS    (8)
+#define DPHY_TX1RX1_TESTEN    (16)
+*/
+
+#define GRF_SOC_STATUS21                  (0x2D4)
+
+#define CSIHOST_PHY_TEST_CTRL0            (0x30)
+#define CSIHOST_PHY_TEST_CTRL1            (0x34)
+#define CSIHOST_N_LANES                   (0x04)
+#define CSIHOST_PHY_SHUTDOWNZ             (0x08)
+#define CSIHOST_CSI2_RESETN               (0x10)
+#define CSIHOST_DPHY_RSTZ                 (0x0c)
+#define CSIHOST_PHY_STATE                 (0x14)
+#define CSIHOST_DATA_IDS1                 (0x18)
+#define CSIHOST_DATA_IDS2                 (0x1C)
+#define CSIHOST_ERR1                      (0x20)
+#define CSIHOST_ERR2                      (0x24)
+
+/*
+*GRF_SOC_CON6
+*dphy_rx_forcerxmode 11:8
+*isp_mipi_csi_host_sel:1
+*disable_isp:0
+*bit 0 grf_con_disable_isp
+*bit 1 isp_mipi_csi_host_sel  1'b0: mipi csi host
+*/
+#define GRF_SOC_CON6_OFFSET    (0x0418)
+/*bit 0*/
+#define MIPI_PHY_DISABLE_ISP_MASK       (0x1 << 16)
+#define MIPI_PHY_DISABLE_ISP            (0x0 << 0)
+/*bit 1*/
+#define ISP_MIPI_CSI_HOST_SEL_OFFSET_MASK       (0x1 << 17)
+#define ISP_MIPI_CSI_HOST_SEL_OFFSET_BIT       (0x1)
+/*bit 6*/
+#define DPHY_RX_CLK_INV_SEL_MASK  (0x1 << 22)
+#define DPHY_RX_CLK_INV_SEL   (0x1 << 6)
+/*bit 11:8*/
+#define DPHY_RX_FORCERXMODE_OFFSET_MASK     (0xF << 24)
+#define DPHY_RX_FORCERXMODE_OFFSET_BITS   (8)
+
+/*GRF_SOC_CON7*/
+/*dphy_tx0_forcerxmode*/
+#define GRF_SOC_CON7_OFFSET  (0x041c)
+/*bit 10:7*/
+#define FORCETXSTOPMODE_OFFSET_BITS   (7)
+#define FORCETXSTOPMODE_MASK   (0xF << 23)
+
+#define DPHY_TX0_FORCERXMODE   (6)
+#define DPHY_TX0_FORCERXMODE_MASK   (0x01 << 22)
+/*bit 5*/
+#define LANE0_TURNDISABLE_BITS  (5)
+#define LANE0_TURNDISABLE_MASK  (0x01 << 21)
+
+#define GRF_SOC_STATUS13  (0x04b4)
+
+#define GRF_SOC_CON9_OFFSET        (0x6224)
+#define DPHY_RX0_TURNREQUEST_MASK        (0xF << 16)
+#define DPHY_RX0_TURNREQUEST_BIT         (0)
+
+#define GRF_SOC_CON21_OFFSET        (0x6254)
+#define DPHY_RX0_FORCERXMODE_MASK	(0xF << 20)
+#define DPHY_RX0_FORCERXMODE_BIT		(4)
+#define DPHY_RX0_FORCETXSTOPMODE_MASK	(0xF << 24)
+#define DPHY_RX0_FORCETXSTOPMODE_BIT	(8)
+#define DPHY_RX0_TURNDISABLE_MASK        (0xF << 28)
+#define DPHY_RX0_TURNDISABLE_BIT		(12)
+#define DPHY_RX0_ENABLE_MASK        (0xF << 16)
+#define DPHY_RX0_ENABLE_BIT         (0)
+
+#define GRF_SOC_CON23_OFFSET        (0x625c)
+#define DPHY_TX1RX1_TURNDISABLE_MASK        (0xF << 28)
+#define DPHY_TX1RX1_TURNDISABLE_BIT         (12)
+#define DPHY_TX1RX1_FORCERXMODE_MASK	(0xF << 20)
+#define DPHY_TX1RX1_FORCERXMODE_BIT			(4)
+#define DPHY_TX1RX1_FORCETXSTOPMODE_MASK	(0xF << 24)
+#define DPHY_TX1RX1_FORCETXSTOPMODE_BIT		(8)
+#define DPHY_TX1RX1_ENABLE_MASK        (0xF << 16)
+#define DPHY_TX1RX1_ENABLE_BIT         (0)
+
+#define GRF_SOC_CON24_OFFSET			(0x6260)
+#define DPHY_TX1RX1_MASTERSLAVEZ_MASK	(0x1 << 23)
+#define DPHY_TX1RX1_MASTERSLAVEZ_BIT	(7)
+#define DPHY_TX1RX1_BASEDIR_MASK		(0x1 << 21)
+#define DPHY_TX1RX1_BASEDIR_BIT			(5)
+#define DPHY_RX1_MASK					(0x1 << 20)
+#define DPHY_RX1_SEL_BIT				(4)
+
+#define DPHY_TX1RX1_TURNREQUEST_MASK    (0xF << 16)
+#define DPHY_TX1RX1_TURNREQUEST_BIT     (0)
+
+#define GRF_SOC_CON25_OFFSET        (0x6264)
+#define DPHY_RX0_TESTCLK_MASK        (0x1 << 25)
+#define DPHY_RX0_TESTCLK_BIT         (9)
+#define DPHY_RX0_TESTCLR_MASK        (0x1 << 26)
+#define DPHY_RX0_TESTCLR_BIT         (10)
+#define DPHY_RX0_TESTDIN_MASK		 (0xFF << 16)
+#define DPHY_RX0_TESTDIN_BIT		 (0)
+#define DPHY_RX0_TESTEN_MASK		 (0x1 << 24)
+#define DPHY_RX0_TESTEN_BIT			 (8)
+
+/*dphy_rx_rxclkactivehs*/
+/*dphy_rx_direction*/
+/*dphy_rx_ulpsactivenot_0...3*/
+
+/*LOW POWER MODE SET*/
+/*base*/
+#define MIPI_CSI_DPHY_CTRL_LANE_ENABLE_OFFSET  (0x00)
+#define MIPI_CSI_DPHY_CTRL_LANE_ENABLE_OFFSET_BIT  (2)
+
+#define MIPI_CSI_DPHY_CTRL_PWRCTL_OFFSET  (0x04)
+#define MIPI_CSI_DPHY_CTRL_DIG_RST_OFFSET  (0x80)
+#define MIPI_CSI_DPHY_CTRL_SIG_INV_OFFSET   (0x84)
+
+/*Configure the count time of the THS-SETTLE by protocol.*/
+#define MIPI_CSI_DPHY_LANEX_THS_SETTLE_OFFSET  (0x00)
+/*MSB enable for pin_rxdatahs_
+*1: enable
+*0: disable
+*/
+#define MIPI_CSI_DPHY_LANEX_MSB_EN_OFFSET  (0x38)
+
+#define CSIHOST_N_LANES_OFFSET 0x04
+#define CSIHOST_N_LANES_OFFSET_BIT (0)
+
+#define DSIHOST_PHY_SHUTDOWNZ             (0x00a0)
+#define DSIHOST_DPHY_RSTZ                 (0x00a0)
+#define DSIHOST_PHY_TEST_CTRL0            (0x00b4)
+#define DSIHOST_PHY_TEST_CTRL1            (0x00b8)
+
+#define write_grf_reg(addr, val)           \
+	__raw_writel(val, (void *)(addr + para->camsys_dev->rk_grf_base))
+#define read_grf_reg(addr)                 \
+	__raw_readl((void *)(addr + para->camsys_dev->rk_grf_base))
+#define mask_grf_reg(addr, msk, val)       \
+	write_grf_reg(addr, (val) | ((~(msk)) & read_grf_reg(addr)))
+
+#define write_cru_reg(addr, val)           \
+	__raw_writel(val, (void *)(addr + para->camsys_dev->rk_cru_base))
+
+/*#define cru_writel(v, o)	do {writel(v, RK_CRU_VIRT + (o)); dsb();} \
+*				while (0)
+*/
+
+#define write_csihost_reg(addr, val)       \
+	__raw_writel(val, (void *)(addr + phy_virt))
+#define read_csihost_reg(addr)             \
+	__raw_readl((void *)(addr + phy_virt))
+/*csi phy*/
+#define write_csiphy_reg(addr, val)       \
+	__raw_writel(val, (void *)(addr + csiphy_virt))
+#define read_csiphy_reg(addr)             \
+	__raw_readl((void *)(addr + csiphy_virt))
+
+#define write_dsihost_reg(addr, val)       \
+	__raw_writel(val, (void *)(addr + dsiphy_virt))
+#define read_dsihost_reg(addr)             \
+	__raw_readl((void *)(addr + dsiphy_virt))
+
+#endif
diff --git a/drivers/media/video/rk_camsys/ext_flashled_drv/Kconfig b/drivers/media/video/rk_camsys/ext_flashled_drv/Kconfig
index 29d4f7d2992a..370ee54b73e0 100755
--- a/drivers/media/video/rk_camsys/ext_flashled_drv/Kconfig
+++ b/drivers/media/video/rk_camsys/ext_flashled_drv/Kconfig
@@ -1,6 +1,6 @@
 config FLASHLIGHT
 	bool "Flashlight Support"
-	default y
+	default n
 	help
 	  This option enables the led sysfs class in /sys/class/flashlight.
 
diff --git a/drivers/media/video/rk_camsys/ext_flashled_drv/flashlight.c b/drivers/media/video/rk_camsys/ext_flashled_drv/flashlight.c
index f63a65f8d440..e0f9a85cc4ec 100755
--- a/drivers/media/video/rk_camsys/ext_flashled_drv/flashlight.c
+++ b/drivers/media/video/rk_camsys/ext_flashled_drv/flashlight.c
@@ -17,191 +17,6 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 
-static const char const *flashlight_type_string[] = {
-	[FLASHLIGHT_TYPE_XENON] = "Xenon",
-	[FLASHLIGHT_TYPE_LED] = "LED",
-	[FLASHLIFHT_TYPE_BULB] = "Bulb",
-};
-
-static const char const *flashlight_mode_string[] = {
-	[FLASHLIGHT_MODE_OFF] = "Off",
-	[FLASHLIGHT_MODE_TORCH] = "Torch",
-	[FLASHLIGHT_MODE_FLASH] = "Flash",
-	[FLASHLIGHT_MODE_MIXED] = "Mixed",
-};
-
-static ssize_t flashlight_show_name(struct device *dev,
-				    struct device_attribute *attr, char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%s\n",
-		       flashlight_dev->props.alias_name ?
-		       flashlight_dev->props.alias_name : "anonymous");
-}
-
-static ssize_t flashlight_show_type(struct device *dev,
-				    struct device_attribute *attr, char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%s\n",
-		       flashlight_type_string[flashlight_dev->props.type]);
-}
-
-static ssize_t flashlight_show_mode(struct device *dev,
-				    struct device_attribute *attr, char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%s\n",
-		       flashlight_mode_string[flashlight_dev->props.mode]);
-}
-
-static ssize_t flashlight_show_torch_max_brightness(struct device *dev,
-						    struct device_attribute
-						    *attr, char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%d\n", flashlight_dev->props.torch_max_brightness);
-}
-
-static ssize_t flashlight_show_strobe_max_brightness(struct device *dev,
-						     struct device_attribute
-						     *attr, char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%d\n",
-		       flashlight_dev->props.strobe_max_brightness);
-}
-
-static ssize_t flashlight_show_color_temperature(struct device *dev,
-						 struct device_attribute *attr,
-						 char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%d\n", flashlight_dev->props.color_temperature);
-}
-
-static ssize_t flashlight_show_strobe_delay(struct device *dev,
-					    struct device_attribute *attr,
-					    char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%d\n", flashlight_dev->props.strobe_delay);
-}
-
-static ssize_t flashlight_store_strobe_timeout(struct device *dev,
-					       struct device_attribute *attr,
-					       const char *buf, size_t count)
-{
-	int rc;
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-	long timeout;
-
-	rc = kstrtol(buf, 0, &timeout);
-	if (rc)
-		return rc;
-	rc = flashlight_dev->ops->set_strobe_timeout(flashlight_dev, timeout);
-	if (rc == 0)
-		rc = count;
-	return rc;
-}
-
-static ssize_t flashlight_show_strobe_timeout(struct device *dev,
-					      struct device_attribute *attr,
-					      char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%d\n", flashlight_dev->props.strobe_timeout);
-}
-
-static ssize_t flashlight_store_torch_brightness(struct device *dev,
-						 struct device_attribute *attr,
-						 const char *buf, size_t count)
-{
-	int rc;
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-	long brightness;
-
-	rc = kstrtol(buf, 0, &brightness);
-	if (rc)
-		return rc;
-
-	rc = -ENXIO;
-
-	mutex_lock(&flashlight_dev->ops_lock);
-	if (flashlight_dev->ops && flashlight_dev->ops->set_torch_brightness) {
-		if (brightness > flashlight_dev->props.torch_max_brightness)
-			rc = -EINVAL;
-		else {
-			pr_debug("flashlight: set torch brightness to %ld\n",
-				 brightness);
-			flashlight_dev->props.torch_brightness = brightness;
-			flashlight_dev->ops->
-			    set_torch_brightness(flashlight_dev, brightness);
-			rc = count;
-		}
-	}
-	mutex_unlock(&flashlight_dev->ops_lock);
-
-	return rc;
-}
-
-static ssize_t flashlight_show_torch_brightness(struct device *dev,
-						struct device_attribute *attr,
-						char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%d\n", flashlight_dev->props.torch_brightness);
-}
-
-static ssize_t flashlight_store_strobe_brightness(struct device *dev,
-						  struct device_attribute *attr,
-						  const char *buf, size_t count)
-{
-	int rc;
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-	long brightness;
-
-	rc = kstrtol(buf, 0, &brightness);
-	if (rc)
-		return rc;
-
-	rc = -ENXIO;
-
-	mutex_lock(&flashlight_dev->ops_lock);
-	if (flashlight_dev->ops && flashlight_dev->ops->set_strobe_brightness) {
-		if (brightness > flashlight_dev->props.strobe_max_brightness)
-			rc = -EINVAL;
-		else {
-			pr_debug("flashlight: set strobe brightness to %ld\n",
-				 brightness);
-			flashlight_dev->props.strobe_brightness = brightness;
-			flashlight_dev->ops->
-			    set_strobe_brightness(flashlight_dev, brightness);
-			rc = count;
-		}
-	}
-	mutex_unlock(&flashlight_dev->ops_lock);
-	return rc;
-}
-
-static ssize_t flashlight_show_strobe_brightness(struct device *dev,
-						 struct device_attribute *attr,
-						 char *buf)
-{
-	struct flashlight_device *flashlight_dev = to_flashlight_device(dev);
-
-	return sprintf(buf, "%d\n", flashlight_dev->props.strobe_brightness);
-}
-
 static struct class *flashlight_class;
 
 static int flashlight_suspend(struct device *dev, pm_message_t state)
@@ -229,30 +44,6 @@ static void flashlight_device_release(struct device *dev)
 	kfree(flashlight_dev);
 }
 
-static struct device_attribute flashlight_device_attributes[] = {
-	__ATTR(name, 0444, flashlight_show_name, NULL),
-	__ATTR(type, 0444, flashlight_show_type, NULL),
-	__ATTR(mode, 0444, flashlight_show_mode, NULL),
-	__ATTR(torch_max_brightness, 0444,
-	       flashlight_show_torch_max_brightness, NULL),
-	__ATTR(strobe_max_brightness, 0444,
-	       flashlight_show_strobe_max_brightness, NULL),
-	__ATTR(color_temperature, 0444,
-	       flashlight_show_color_temperature, NULL),
-	__ATTR(strobe_delay, 0444,
-	       flashlight_show_strobe_delay, NULL),
-	__ATTR(strobe_timeout, 0644,
-	       flashlight_show_strobe_timeout,
-	       flashlight_store_strobe_timeout),
-	__ATTR(torch_brightness, 0644,
-	       flashlight_show_torch_brightness,
-	       flashlight_store_torch_brightness),
-	__ATTR(strobe_brightness, 0644,
-	       flashlight_show_strobe_brightness,
-	       flashlight_store_strobe_brightness),
-	__ATTR_NULL,
-};
-
 /**
  * flashlight_device_register - create and register a new object of
  *   flashlight_device class.
@@ -530,7 +321,7 @@ static int __init flashlight_class_init(void)
 		       PTR_ERR(flashlight_class));
 		return PTR_ERR(flashlight_class);
 	}
-	flashlight_class->dev_attrs = flashlight_device_attributes;
+
 	flashlight_class->suspend = flashlight_suspend;
 	flashlight_class->resume = flashlight_resume;
 	return 0;
diff --git a/include/linux/rockchip-iovmm.h b/include/linux/rockchip-iovmm.h
index ab7f8bb61f0f..73e2ff159e86 100644
--- a/include/linux/rockchip-iovmm.h
+++ b/include/linux/rockchip-iovmm.h
@@ -14,6 +14,8 @@
 #define IEP_IOMMU_COMPATIBLE_NAME "rockchip,iep_mmu"
 #define VIP_IOMMU_COMPATIBLE_NAME "rockchip,vip_mmu"
 #define ISP_IOMMU_COMPATIBLE_NAME "rockchip,isp_mmu"
+#define ISP0_IOMMU_COMPATIBLE_NAME "rockchip,isp0_mmu"
+#define ISP1_IOMMU_COMPATIBLE_NAME "rockchip,isp1_mmu"
 #define VOPB_IOMMU_COMPATIBLE_NAME "rockchip,vopb_mmu"
 #define VOPL_IOMMU_COMPATIBLE_NAME "rockchip,vopl_mmu"
 #define VOP_IOMMU_COMPATIBLE_NAME	"rockchip,vop_mmu"
-- 
2.35.3

