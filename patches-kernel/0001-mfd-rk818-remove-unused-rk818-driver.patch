From e64bab1c123956ed2f9ab4a2d7f442d83e7e8ae3 Mon Sep 17 00:00:00 2001
From: Tao Huang <huangtao@rock-chips.com>
Date: Thu, 31 May 2018 10:25:08 +0800
Subject: [PATCH] mfd: rk818: remove unused rk818 driver

Change-Id: I4390e73f0e4ab6e723ed3a44e93e891204044d85
Signed-off-by: Tao Huang <huangtao@rock-chips.com>
---
 drivers/mfd/rk818-irq.c   |  246 -------
 drivers/mfd/rk818.c       | 1429 -------------------------------------
 drivers/rtc/rtc-rk818.c   |  833 ---------------------
 include/linux/mfd/rk818.h |  200 ------
 4 files changed, 2708 deletions(-)
 delete mode 100755 drivers/mfd/rk818-irq.c
 delete mode 100755 drivers/mfd/rk818.c
 delete mode 100755 drivers/rtc/rtc-rk818.c
 delete mode 100755 include/linux/mfd/rk818.h

diff --git a/drivers/mfd/rk818-irq.c b/drivers/mfd/rk818-irq.c
deleted file mode 100755
index 7315fa1e3d60..000000000000
--- a/drivers/mfd/rk818-irq.c
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * rk818-irq.c 
- *
- * Author: zhangqing <zhangqing@rock-chips.com>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under  the terms of the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the License, or (at your
- *  option) any later version.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/bug.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/mfd/rk818.h>
-#include <linux/wakelock.h>
-#include <linux/kthread.h>
-#include <linux/irqdomain.h>
-#include <linux/regmap.h>
-
-
-static inline int irq_to_rk818_irq(struct rk818 *rk818,
-							int irq)
-{
-	return (irq - rk818->chip_irq);
-}
-
-/*
- * This is a threaded IRQ handler so can access I2C/SPI.  Since all
- * interrupts are clear on read the IRQ line will be reasserted and
- * the physical IRQ will be handled again if another interrupt is
- * asserted while we run - in the normal course of events this is a
- * rare occurrence so we save I2C/SPI reads.  We're also assuming that
- * it's rare to get lots of interrupts firing simultaneously so try to
- * minimise I/O.
- */
-static irqreturn_t rk818_irq(int irq, void *irq_data)
-{
-	struct rk818 *rk818 = irq_data;
-	u32 irq_sts;
-	u32 irq_mask;
-	u8 reg;
-	int i, cur_irq;
-	//printk(" rk818 irq %d \n",irq);	
-	wake_lock(&rk818->irq_wake);	
-	rk818_i2c_read(rk818, RK818_INT_STS_REG1, 1, &reg);
-	irq_sts = reg;
-	rk818_i2c_read(rk818, RK818_INT_STS_REG2, 1, &reg);
-	irq_sts |= reg << 8;
-	
-	rk818_i2c_read(rk818, RK818_INT_STS_MSK_REG1, 1, &reg);
-	irq_mask = reg;
-	rk818_i2c_read(rk818, RK818_INT_STS_MSK_REG2, 1, &reg);
-	irq_mask |= reg << 8;
-
-	irq_sts &= ~irq_mask;
-
-	if (!irq_sts)
-	{
-		wake_unlock(&rk818->irq_wake);
-		return IRQ_NONE;
-	}
-
-	for (i = 0; i < rk818->irq_num; i++) {
-
-		if (!(irq_sts & (1 << i)))
-			continue;
-
-		cur_irq = irq_find_mapping(rk818->irq_domain, i);
-
-                if (cur_irq)
-                	handle_nested_irq(cur_irq);
-	}
-
-	/* Write the STS register back to clear IRQs we handled */
-	reg = irq_sts & 0xFF;
-	irq_sts >>= 8;
-	rk818_i2c_write(rk818, RK818_INT_STS_REG1, 1, reg);
-	reg = irq_sts & 0xFF;
-	rk818_i2c_write(rk818, RK818_INT_STS_REG2, 1, reg);
-	wake_unlock(&rk818->irq_wake);
-	return IRQ_HANDLED;
-}
-
-static void rk818_irq_lock(struct irq_data *data)
-{
-	struct rk818 *rk818 = irq_data_get_irq_chip_data(data);
-
-	mutex_lock(&rk818->irq_lock);
-}
-
-static void rk818_irq_sync_unlock(struct irq_data *data)
-{
-	struct rk818 *rk818 = irq_data_get_irq_chip_data(data);
-	u32 reg_mask;
-	u8 reg;
-
-	rk818_i2c_read(rk818, RK818_INT_STS_MSK_REG1, 1, &reg);
-	reg_mask = reg;
-	rk818_i2c_read(rk818, RK818_INT_STS_MSK_REG2, 1, &reg);
-	reg_mask |= reg << 8;
-
-	if (rk818->irq_mask != reg_mask) {
-		reg = rk818->irq_mask & 0xff;
-//		rk818_i2c_write(rk818, RK818_INT_STS_MSK_REG1, 1, reg);
-		reg = rk818->irq_mask >> 8 & 0xff;
-//		rk818_i2c_write(rk818, RK818_INT_STS_MSK_REG2, 1, reg);
-	}
-	mutex_unlock(&rk818->irq_lock);
-}
-
-static void rk818_irq_enable(struct irq_data *data)
-{
-	struct rk818 *rk818 = irq_data_get_irq_chip_data(data);
-
-	rk818->irq_mask &= ~( 1 << irq_to_rk818_irq(rk818, data->irq));
-}
-
-static void rk818_irq_disable(struct irq_data *data)
-{
-	struct rk818 *rk818 = irq_data_get_irq_chip_data(data);
-
-	rk818->irq_mask |= ( 1 << irq_to_rk818_irq(rk818, data->irq));
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int rk818_irq_set_wake(struct irq_data *data, unsigned int enable)
-{
-	struct rk818 *rk818 = irq_data_get_irq_chip_data(data);
-	return irq_set_irq_wake(rk818->chip_irq, enable);
-}
-#else
-#define rk818_irq_set_wake NULL
-#endif
-
-static struct irq_chip rk818_irq_chip = {
-	.name = "rk818",
-	.irq_bus_lock = rk818_irq_lock,
-	.irq_bus_sync_unlock = rk818_irq_sync_unlock,
-	.irq_disable = rk818_irq_disable,
-	.irq_enable = rk818_irq_enable,
-	.irq_set_wake = rk818_irq_set_wake,
-};
-
-static int rk818_irq_domain_map(struct irq_domain *d, unsigned int irq,
-					irq_hw_number_t hw)
-{
-	struct rk818 *rk818 = d->host_data;
-
-	irq_set_chip_data(irq, rk818);
-	irq_set_chip_and_handler(irq, &rk818_irq_chip, handle_edge_irq);
-	irq_set_nested_thread(irq, 1);
-#ifdef CONFIG_ARM
-	set_irq_flags(irq, IRQF_VALID);
-#else
-	irq_set_noprobe(irq);
-#endif
-	return 0;
-}
-
-static struct irq_domain_ops rk818_irq_domain_ops = {
-	.map = rk818_irq_domain_map,
-};
-
-int rk818_irq_init(struct rk818 *rk818, int irq,struct rk818_board *pdata)
-{
-	struct irq_domain *domain;
-	int ret,val,irq_type,flags;
-	u8 reg;
-
-//	printk("%s,line=%d\n", __func__,__LINE__);	
-	if (!irq) {
-		dev_warn(rk818->dev, "No interrupt support, no core IRQ\n");
-		return 0;
-	}
-
-	/* Clear unattended interrupts */
-	rk818_i2c_read(rk818, RK818_INT_STS_REG1, 1, &reg);
-	rk818_i2c_write(rk818, RK818_INT_STS_REG1, 1, reg);
-	rk818_i2c_read(rk818, RK818_INT_STS_REG2, 1, &reg);
-	rk818_i2c_write(rk818, RK818_INT_STS_REG2, 1, reg);
-	rk818_i2c_read(rk818, RK818_RTC_STATUS_REG, 1, &reg);	
-	rk818_i2c_write(rk818, RK818_RTC_STATUS_REG, 1, reg);//clear alarm and timer interrupt
-
-	/* Mask top level interrupts */
-	rk818->irq_mask = 0xFFFFFF;
-	mutex_init(&rk818->irq_lock);	
-	wake_lock_init(&rk818->irq_wake, WAKE_LOCK_SUSPEND, "rk818_irq_wake");
-	rk818->irq_num = RK818_NUM_IRQ;
-	rk818->irq_gpio = pdata->irq_gpio;
-	if (rk818->irq_gpio && !rk818->chip_irq) {
-		rk818->chip_irq = gpio_to_irq(rk818->irq_gpio);
-
-		if (rk818->irq_gpio) {
-			ret = gpio_request(rk818->irq_gpio, "rk818_pmic_irq");
-			if (ret < 0) {
-				dev_err(rk818->dev,
-					"Failed to request gpio %d with ret:"
-					"%d\n",	rk818->irq_gpio, ret);
-				return IRQ_NONE;
-			}
-			gpio_direction_input(rk818->irq_gpio);
-			val = gpio_get_value(rk818->irq_gpio);
-			if (val){
-				irq_type = IRQ_TYPE_LEVEL_LOW;
-				flags = IRQF_TRIGGER_FALLING;
-			}
-			else{
-				irq_type = IRQ_TYPE_LEVEL_HIGH;
-				flags = IRQF_TRIGGER_RISING;
-			}
-			gpio_free(rk818->irq_gpio);
-			pr_info("%s: rk818_pmic_irq=%x\n", __func__, val);
-		}
-	}
-	
-	domain = irq_domain_add_linear(NULL, RK818_NUM_IRQ,
-					&rk818_irq_domain_ops, rk818);
-	if (!domain) {
-		dev_err(rk818->dev, "could not create irq domain\n");
-		return -ENODEV;
-	}
-	rk818->irq_domain = domain;
-
-	ret = request_threaded_irq(rk818->chip_irq, NULL, rk818_irq, flags | IRQF_ONESHOT, "rk818", rk818);
-
-	irq_set_irq_type(rk818->chip_irq, irq_type);
-	enable_irq_wake(rk818->chip_irq);
-	if (ret != 0)
-		dev_err(rk818->dev, "Failed to request IRQ: %d\n", ret);
-	
-	return ret;
-}
-
-int rk818_irq_exit(struct rk818 *rk818)
-{
-	if (rk818->chip_irq)
-		free_irq(rk818->chip_irq, rk818);
-	return 0;
-}
diff --git a/drivers/mfd/rk818.c b/drivers/mfd/rk818.c
deleted file mode 100755
index 0da49fbfa3c3..000000000000
--- a/drivers/mfd/rk818.c
+++ /dev/null
@@ -1,1429 +0,0 @@
-/*
- * Regulator driver for rk818 PMIC chip for rk31xx
- *
- * Based on rk818.c that is work by zhangqing<zhangqing@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-
-#include <linux/bug.h>
-#include <linux/err.h>
-#include <linux/i2c.h>
-#include <linux/kernel.h>
-#include <linux/regulator/driver.h>
-#include <linux/mfd/rk818.h>
-#include <linux/mfd/core.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/mutex.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/of_irq.h>
-#include <linux/of_gpio.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/regulator/of_regulator.h>
-#include <linux/regulator/driver.h>
-#include <linux/regulator/machine.h>
-#include <linux/regmap.h>
-#include <linux/syscore_ops.h>
-
-
-#if 0
-#define DBG(x...)	printk(KERN_INFO x)
-#else
-#define DBG(x...)
-#endif
-#if 1
-#define DBG_INFO(x...)	printk(KERN_INFO x)
-#else
-#define DBG_INFO(x...)
-#endif
-#define PM_CONTROL
-
-struct rk818 *g_rk818;
-
-static struct mfd_cell rk818s[] = {
-	{
-		.name = "rk818-rtc",
-	},
-
-	{
-		.name = "rk818-battery",
-	},
-	/*	{
-		.name = "rk818-power",
-	},	
-	*/
-};
-
-#define BUCK_VOL_MASK 0x3f
-#define LDO_VOL_MASK 0x3f
-#define LDO9_VOL_MASK 0x1f
-#define BOOST_VOL_MASK 0xe0
-
-#define VOL_MIN_IDX 0x00
-#define VOL_MAX_IDX 0x3f
-#define RK818_I2C_ADDR_RATE  200*1000
-
-const static int buck_set_vol_base_addr[] = {
-	RK818_BUCK1_ON_REG,
-	RK818_BUCK2_ON_REG,
-	RK818_BUCK3_CONFIG_REG,
-	RK818_BUCK4_ON_REG,
-};
-const static int buck_set_slp_vol_base_addr[] = {
-	RK818_BUCK1_SLP_REG,
-	RK818_BUCK2_SLP_REG,
-	RK818_BUCK3_CONFIG_REG,
-	RK818_BUCK4_SLP_VSEL_REG,
-};
-const static int buck_contr_base_addr[] = {
-	RK818_BUCK1_CONFIG_REG,
- 	RK818_BUCK2_CONFIG_REG,
- 	RK818_BUCK3_CONFIG_REG,
- 	RK818_BUCK4_CONFIG_REG,
-};
-#define rk818_BUCK_SET_VOL_REG(x) (buck_set_vol_base_addr[x])
-#define rk818_BUCK_CONTR_REG(x) (buck_contr_base_addr[x])
-#define rk818_BUCK_SET_SLP_VOL_REG(x) (buck_set_slp_vol_base_addr[x])
-
-
-const static int ldo_set_vol_base_addr[] = {
-	RK818_LDO1_ON_VSEL_REG,
-	RK818_LDO2_ON_VSEL_REG,
-	RK818_LDO3_ON_VSEL_REG,
-	RK818_LDO4_ON_VSEL_REG, 
-	RK818_LDO5_ON_VSEL_REG, 
-	RK818_LDO6_ON_VSEL_REG, 
-	RK818_LDO7_ON_VSEL_REG, 
-	RK818_LDO8_ON_VSEL_REG, 
-	RK818_BOOST_LDO9_ON_VSEL_REG, 
-};
-const static int ldo_set_slp_vol_base_addr[] = {
-	RK818_LDO1_SLP_VSEL_REG,
-	RK818_LDO2_SLP_VSEL_REG,
-	RK818_LDO3_SLP_VSEL_REG,
-	RK818_LDO4_SLP_VSEL_REG, 
-	RK818_LDO5_SLP_VSEL_REG, 
-	RK818_LDO6_SLP_VSEL_REG, 
-	RK818_LDO7_SLP_VSEL_REG, 
-	RK818_LDO8_SLP_VSEL_REG, 
-	RK818_BOOST_LDO9_SLP_VSEL_REG, 
-};
-
-#define rk818_LDO_SET_VOL_REG(x) (ldo_set_vol_base_addr[x])
-#define rk818_LDO_SET_SLP_VOL_REG(x) (ldo_set_slp_vol_base_addr[x])
-
-const static int buck_voltage_map[] = {
-	  712,  725,  737,  750, 762,  775,  787,  800,
-	  812,  825,  837,  850,862,  875,  887,  900,  912,
-	  925,  937,  950, 962,  975,  987, 1000, 1012, 1025, 
-	  1037, 1050,1062, 1075, 1087, 1100, 1112, 1125, 1137, 
-	  1150,1162, 1175, 1187, 1200, 1212, 1225, 1237, 1250,
-	  1262, 1275, 1287, 1300, 1312, 1325, 1337, 1350,1362, 
-	  1375, 1387, 1400, 1412, 1425, 1437, 1450,1462, 1475, 
-	  1487, 1500,
-};
-
-const static int buck4_voltage_map[] = {
-           1800, 1900, 2000, 2100, 2200,  2300,  2400, 2500, 2600,
-          2700, 2800, 2900, 3000, 3100, 3200,3300, 3400,3500,3600,
-};
-
-const static int ldo_voltage_map[] = {
-	  1800, 1900, 2000, 2100, 2200,  2300,  2400, 2500, 2600, 
-	  2700, 2800, 2900, 3000, 3100, 3200,3300, 3400, 
-};
-const static int ldo3_voltage_map[] = {
-	 800, 900, 1000, 1100, 1200,  1300, 1400, 1500, 1600, 
-	 1700, 1800, 1900,  2000,2100,  2200,  2500,
-};
-const static int ldo6_voltage_map[] = {
-	 800, 900, 1000, 1100, 1200,  1300, 1400, 1500, 1600, 
-	 1700, 1800, 1900,  2000,2100,  2200,  2300,2400,2500,
-};
-const static int boost_voltage_map[] = {
-	 4700,4800,4900,5000,5100,5200,5300,5400,
-};
-
-static int rk818_ldo_list_voltage(struct regulator_dev *dev, unsigned index)
-{
-	int ldo= rdev_get_id(dev) - RK818_LDO1;
-	if (ldo == 2){
-	if (index >= ARRAY_SIZE(ldo3_voltage_map))
-		return -EINVAL;
-	return 1000 * ldo3_voltage_map[index];
-	}
-	else if (ldo == 5 || ldo ==6){
-	if (index >= ARRAY_SIZE(ldo6_voltage_map))
-		return -EINVAL;
-	return 1000 * ldo6_voltage_map[index];
-	}
-	else{
-	if (index >= ARRAY_SIZE(ldo_voltage_map))
-		return -EINVAL;
-	return 1000 * ldo_voltage_map[index];
-	}
-}
-static int rk818_ldo_is_enabled(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) - RK818_LDO1;	
-	u16 val;
-
-	if (ldo == 8){
-		val = rk818_reg_read(rk818, RK818_DCDC_EN_REG);  //ldo9
-		if (val < 0)
-			return val;
-		if (val & (1 << 5))
-			return 1;
-		else
-			return 0; 
-	}
-	val = rk818_reg_read(rk818, RK818_LDO_EN_REG);
-	if (val < 0)
-		return val;
-	if (val & (1 << ldo))
-		return 1;
-	else
-		return 0; 		
-}
-static int rk818_ldo_enable(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) - RK818_LDO1;
-
-	if (ldo == 8)
-		 rk818_set_bits(rk818, RK818_DCDC_EN_REG, 1 << 5, 1 << 5); //ldo9
-	else if (ldo ==9)
-		rk818_set_bits(rk818, RK818_DCDC_EN_REG, 1 << 6, 1 << 6); //ldo10 switch
-	else
-	 	rk818_set_bits(rk818, RK818_LDO_EN_REG, 1 << ldo, 1 << ldo);
-
-	 return 0;	
-}
-static int rk818_ldo_disable(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) - RK818_LDO1;
-
-	if (ldo == 8)
-		 rk818_set_bits(rk818, RK818_DCDC_EN_REG, 1 << 5, 1 << 0); //ldo9
-	else if(ldo ==9)
-		rk818_set_bits(rk818, RK818_DCDC_EN_REG, 1 << 6, 1 << 0); //ldo10 switch
-	else
-	 	rk818_set_bits(rk818, RK818_LDO_EN_REG, 1 << ldo, 0);
-
-	 return 0;
-}
-static int rk818_ldo_get_voltage(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) - RK818_LDO1;
-	u16 reg = 0;
-	int val;
-	
-	if  (ldo ==9){
-		reg = rk818_reg_read(rk818,rk818_BUCK_SET_VOL_REG(3));
-		reg &= BUCK_VOL_MASK;
-		val = 1000 * buck4_voltage_map[reg];		
-	}
-	else{
-		reg = rk818_reg_read(rk818,rk818_LDO_SET_VOL_REG(ldo));
-		if (ldo == 8){
-			reg &= LDO9_VOL_MASK;
-		}
-		else
-			reg &= LDO_VOL_MASK;
-	
-		if (ldo ==2){
-			val = 1000 * ldo3_voltage_map[reg];	
-		}
-		else if (ldo == 5 || ldo ==6){
-			val = 1000 * ldo6_voltage_map[reg];	
-		}
-		else{
-			val = 1000 * ldo_voltage_map[reg];	
-		}
-	}
-	return val;
-}
-static int rk818_ldo_suspend_enable(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) - RK818_LDO1;
-
-	if (ldo == 8)
-		return rk818_set_bits(rk818, RK818_SLEEP_SET_OFF_REG1, 1 << 5, 0); //ldo9
-	else if (ldo ==9)
-		return rk818_set_bits(rk818, RK818_SLEEP_SET_OFF_REG1, 1 << 6, 0); //ldo10 switch
-	else
-		return rk818_set_bits(rk818, RK818_SLEEP_SET_OFF_REG2, 1 << ldo, 0);
-	
-}
-static int rk818_ldo_suspend_disable(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) - RK818_LDO1;
-	
-	if (ldo == 8)
-		return rk818_set_bits(rk818, RK818_SLEEP_SET_OFF_REG1, 1 << 5, 1 << 5); //ldo9
-	else if (ldo ==9)
-		return rk818_set_bits(rk818, RK818_SLEEP_SET_OFF_REG1, 1 << 6, 1 << 6); //ldo10 switch
-	else
-		return rk818_set_bits(rk818, RK818_SLEEP_SET_OFF_REG2, 1 << ldo, 1 << ldo);
-
-}
-
-int rk818_ldo_slp_enable(int ldo_id)
-{
-	int ldo = ldo_id - 1;
-
-	if (ldo == 8)
-		return rk818_set_bits(g_rk818, RK818_SLEEP_SET_OFF_REG1,
-				      1 << 5, 0); /*ldo9*/
-	else if (ldo == 9)
-		return rk818_set_bits(g_rk818, RK818_SLEEP_SET_OFF_REG1,
-				      1 << 6, 0); /*ldo10 switch*/
-	else
-		return rk818_set_bits(g_rk818, RK818_SLEEP_SET_OFF_REG2,
-				      1 << ldo, 0);
-}
-
-int rk818_ldo_slp_disable(int ldo_id)
-{
-	int ldo = ldo_id - 1;
-
-	if (ldo == 8)
-		return rk818_set_bits(g_rk818, RK818_SLEEP_SET_OFF_REG1,
-				      1 << 5, 1 << 5); /*ldo9*/
-	else if (ldo == 9)
-		return rk818_set_bits(g_rk818, RK818_SLEEP_SET_OFF_REG1,
-				      1 << 6, 1 << 6); /*ldo10 switch*/
-	else
-		return rk818_set_bits(g_rk818, RK818_SLEEP_SET_OFF_REG2,
-				      1 << ldo, 1 << ldo);
-}
-
-static int rk818_ldo_set_sleep_voltage(struct regulator_dev *dev,
-					    int uV)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) - RK818_LDO1;
-	const int *vol_map = ldo_voltage_map;
-	int min_vol = uV / 1000;
-	u16 val;
-	int ret = 0,num =0;
-	
-	if (ldo ==2){
-	vol_map = ldo3_voltage_map;	
-	num = 15;
-	}
-	else if (ldo == 5 || ldo ==6){
-	vol_map = ldo6_voltage_map;		
-	num = 17;
-	}
-	else {
-	num = 16;
-	}
-	
-	if (min_vol < vol_map[0] ||
-	    min_vol > vol_map[num])
-		return -EINVAL;
-
-	for (val = 0; val <= num; val++){
-		if (vol_map[val] >= min_vol)
-			break;	
-        }
-
-	if (ldo == 8){
-		ret = rk818_set_bits(rk818, rk818_LDO_SET_SLP_VOL_REG(ldo),LDO9_VOL_MASK, val);
-	}
-	else
-		ret = rk818_set_bits(rk818, rk818_LDO_SET_SLP_VOL_REG(ldo),LDO_VOL_MASK, val);
-	
-	return ret;
-}
-
-static int rk818_ldo_set_voltage(struct regulator_dev *dev,
-				  int min_uV, int max_uV,unsigned *selector)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int ldo= rdev_get_id(dev) - RK818_LDO1;
-	const int *vol_map;
-	int min_vol = min_uV / 1000;
-	u16 val;
-	int ret = 0,num =0;
-	
-	if (ldo ==2){
-	vol_map = ldo3_voltage_map;	
-	num = 15;
-	}
-	else if (ldo == 5 || ldo ==6){
-	vol_map = ldo6_voltage_map;		
-	num = 17;
-	}
-	else {
-	vol_map = ldo_voltage_map;
-	num = 16;
-	}
-	
-	if (min_vol < vol_map[0] ||
-	    min_vol > vol_map[num])
-		return -EINVAL;
-
-	for (val = 0; val <= num; val++){
-		if (vol_map[val] >= min_vol)
-			break;	
-        }
-
-	if (ldo == 8){
-		ret = rk818_set_bits(rk818, rk818_LDO_SET_VOL_REG(ldo),LDO9_VOL_MASK, val);
-	}
-	else
-		ret = rk818_set_bits(rk818, rk818_LDO_SET_VOL_REG(ldo),LDO_VOL_MASK, val);
-	
-	return ret;
-
-}
-
-static struct regulator_ops rk818_ldo_ops = {
-	.set_voltage = rk818_ldo_set_voltage,
-	.get_voltage = rk818_ldo_get_voltage,
-	.list_voltage = rk818_ldo_list_voltage,
-	.is_enabled = rk818_ldo_is_enabled,
-	.enable = rk818_ldo_enable,
-	.disable = rk818_ldo_disable,
-	.set_suspend_enable =rk818_ldo_suspend_enable,
-	.set_suspend_disable =rk818_ldo_suspend_disable,
-	.set_suspend_voltage = rk818_ldo_set_sleep_voltage,	
-};
-
-static int rk818_dcdc_list_voltage(struct regulator_dev *dev, unsigned selector)
-{
-	int volt;
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-
-	if (selector < 0x0 ||selector > BUCK_VOL_MASK )
-		return -EINVAL;
-
-	switch (buck) {
-	case 0:
-	case 1:
-		volt = 712500 + selector * 12500;
-		break;
-	case 3:
-		volt = 1800000 + selector * 100000;
-		break;
-	case 2:
-		volt = 1200000;
-		break;
-	default:
-		BUG();
-		return -EINVAL;
-	}
-
-	return  volt ;
-}
-static int rk818_dcdc_is_enabled(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-	u16 val;
-	
-	val = rk818_reg_read(rk818, RK818_DCDC_EN_REG);
-	if (val < 0)
-		return val;
-	if (val & (1 << buck))
-		return 1;
-	else
-		return 0; 	
-}
-static int rk818_dcdc_enable(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-
-	return rk818_set_bits(rk818, RK818_DCDC_EN_REG, 1 << buck, 1 << buck);
-
-}
-static int rk818_dcdc_disable(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-	
-	 return rk818_set_bits(rk818, RK818_DCDC_EN_REG, 1 << buck , 0);
-}
-static int rk818_dcdc_get_voltage(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-	u16 reg = 0;
-	int val;
-
-	reg = rk818_reg_read(rk818,rk818_BUCK_SET_VOL_REG(buck));
-	
-	reg &= BUCK_VOL_MASK;
-    	val = rk818_dcdc_list_voltage(dev,reg);
-	return val;
-}
-static int rk818_dcdc_select_min_voltage(struct regulator_dev *dev,
-					   int min_uV, int max_uV ,int buck)
-{
-	u16 vsel =0;
-	
-	if (buck == 0 || buck ==  1){
-		if (min_uV < 712500)
-		vsel = 0;
-		else if (min_uV <= 1500000)
-		vsel = ((min_uV - 712500) / 12500) ;
-		else
-		return -EINVAL;
-	}
-	else if (buck ==3){
-		if (min_uV < 1800000)
-		vsel = 0;
-		else if (min_uV <= 3300000)
-		vsel = ((min_uV - 1800000) / 100000) ;
-		else
-		return -EINVAL;
-	}
-	if (rk818_dcdc_list_voltage(dev, vsel) > max_uV)
-		return -EINVAL;
-	return vsel;
-}
-
-static int rk818_dcdc_set_voltage(struct regulator_dev *dev,
-				  int min_uV, int max_uV,unsigned *selector)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-	u16 val;
-	int ret = 0;
-
-	if (buck ==2){
-		return 0;
-	}else if (buck==3){
-		val = rk818_dcdc_select_min_voltage(dev,min_uV,max_uV,buck);	
-		ret = rk818_set_bits(rk818, rk818_BUCK_SET_VOL_REG(buck), BUCK_VOL_MASK, val);
-	}
-	val = rk818_dcdc_select_min_voltage(dev,min_uV,max_uV,buck);
-	ret = rk818_set_bits(rk818, rk818_BUCK_SET_VOL_REG(buck), BUCK_VOL_MASK, val);
-	return ret;
-}
-static int rk818_dcdc_set_sleep_voltage(struct regulator_dev *dev,
-					    int uV)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-	u16 val;
-	int ret = 0;
-
-	if (buck ==2){
-	return 0;
-	}else{
-	val = rk818_dcdc_select_min_voltage(dev,uV,uV,buck);
-	ret = rk818_set_bits(rk818, rk818_BUCK_SET_SLP_VOL_REG(buck) , BUCK_VOL_MASK, val);
-	}
-	return ret;
-}
-static unsigned int rk818_dcdc_get_mode(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-	u16 mask = 0x80;
-	u16 val;
-	val = rk818_reg_read(rk818, rk818_BUCK_SET_VOL_REG(buck));
-        if (val < 0) {
-                return val;
-        }
-	val=val & mask;
-	if (val== mask)
-		return REGULATOR_MODE_FAST;
-	else
-		return REGULATOR_MODE_NORMAL;
-
-}
-static int rk818_dcdc_set_mode(struct regulator_dev *dev, unsigned int mode)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-	u16 mask = 0x80;
-	switch(mode)
-	{
-	case REGULATOR_MODE_FAST:
-		return rk818_set_bits(rk818, rk818_BUCK_SET_VOL_REG(buck), mask, mask);
-	case REGULATOR_MODE_NORMAL:
-		return rk818_set_bits(rk818, rk818_BUCK_SET_VOL_REG(buck), mask, 0);
-	default:
-		printk("error:pmu_rk818 only powersave and pwm mode\n");
-		return -EINVAL;
-	}
-
-}
-static int rk818_dcdc_set_voltage_time_sel(struct regulator_dev *dev,   unsigned int old_selector,
-				     unsigned int new_selector)
-{
-	int old_volt, new_volt;
-	
-	old_volt = rk818_dcdc_list_voltage(dev, old_selector);
-	if (old_volt < 0)
-		return old_volt;
-	
-	new_volt = rk818_dcdc_list_voltage(dev, new_selector);
-	if (new_volt < 0)
-		return new_volt;
-
-	return DIV_ROUND_UP(abs(old_volt - new_volt)*2, 2500);
-}
-
-static int rk818_dcdc_suspend_enable(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-
-	return rk818_set_bits(rk818, RK818_SLEEP_SET_OFF_REG1, 1 << buck, 0);
-
-}
-static int rk818_dcdc_suspend_disable(struct regulator_dev *dev)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-	
-	 return rk818_set_bits(rk818, RK818_SLEEP_SET_OFF_REG1, 1 << buck , 1 << buck);
-}
-static int rk818_dcdc_set_suspend_mode(struct regulator_dev *dev, unsigned int mode)
-{
-	struct rk818 *rk818 = rdev_get_drvdata(dev);
-	int buck = rdev_get_id(dev) - RK818_DCDC1;
-	u16 mask = 0x80;
-
-	switch(mode)
-	{
-	case REGULATOR_MODE_FAST:
-		return rk818_set_bits(rk818, (rk818_BUCK_SET_VOL_REG(buck) + 0x01), mask, mask);
-	case REGULATOR_MODE_NORMAL:
-		return rk818_set_bits(rk818, (rk818_BUCK_SET_VOL_REG(buck) + 0x01), mask, 0);
-	default:
-		printk("error:pmu_rk818 only powersave and pwm mode\n");
-		return -EINVAL;
-	}
-
-}
-static struct regulator_ops rk818_dcdc_ops = { 
-	.set_voltage = rk818_dcdc_set_voltage,
-	.get_voltage = rk818_dcdc_get_voltage,
-	.list_voltage= rk818_dcdc_list_voltage,
-	.is_enabled = rk818_dcdc_is_enabled,
-	.enable = rk818_dcdc_enable,
-	.disable = rk818_dcdc_disable,
-	.get_mode = rk818_dcdc_get_mode,
-	.set_mode = rk818_dcdc_set_mode,
-	.set_suspend_enable =rk818_dcdc_suspend_enable,
-	.set_suspend_disable =rk818_dcdc_suspend_disable,
-	.set_suspend_mode = rk818_dcdc_set_suspend_mode,
-	.set_suspend_voltage = rk818_dcdc_set_sleep_voltage,
-	.set_voltage_time_sel = rk818_dcdc_set_voltage_time_sel,
-};
-static struct regulator_desc regulators[] = {
-
-        {
-		.name = "RK818_DCDC1",
-		.id = 0,
-		.ops = &rk818_dcdc_ops,
-		.n_voltages = ARRAY_SIZE(buck_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_DCDC2",
-		.id = 1,
-		.ops = &rk818_dcdc_ops,
-		.n_voltages = ARRAY_SIZE(buck_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_DCDC3",
-		.id = 2,
-		.ops = &rk818_dcdc_ops,
-		.n_voltages = ARRAY_SIZE(buck4_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_DCDC4",
-		.id = 3,
-		.ops = &rk818_dcdc_ops,
-		.n_voltages = ARRAY_SIZE(buck4_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-
-	{
-		.name = "RK818_LDO1",
-		.id =4,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_LDO2",
-		.id = 5,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_LDO3",
-		.id = 6,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo3_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_LDO4",
-		.id = 7,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-
-	{
-		.name = "RK818_LDO5",
-		.id =8,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_LDO6",
-		.id = 9,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo6_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_LDO7",
-		.id = 10,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo6_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_LDO8",
-		.id = 11,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_LDO9",
-		.id = 12,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(ldo_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	{
-		.name = "RK818_LDO10",
-		.id = 13,
-		.ops = &rk818_ldo_ops,
-		.n_voltages = ARRAY_SIZE(buck4_voltage_map),
-		.type = REGULATOR_VOLTAGE,
-		.owner = THIS_MODULE,
-	},
-	
-};
-
-/*
- *
- */
- int rk818_i2c_read(struct rk818 *rk818, char reg, int count,u8 *dest)
-{
-	struct i2c_client *i2c = rk818->i2c;
-
-      int ret;
-    struct i2c_adapter *adap;
-    struct i2c_msg msgs[2];
-
-    if(!i2c)
-		return ret;
-
-	if (count != 1)
-		return -EIO;  
-  
-    adap = i2c->adapter;		
-    
-    msgs[0].addr = i2c->addr;
-    msgs[0].buf = &reg;
-    msgs[0].flags = 0;
-    msgs[0].len = 1;
-    msgs[0].scl_rate = 200*1000;
-    
-    msgs[1].buf = dest;
-    msgs[1].addr = i2c->addr;
-    msgs[1].flags =  I2C_M_RD;
-    msgs[1].len = count;
-    msgs[1].scl_rate = RK818_I2C_ADDR_RATE;
-
-    ret = i2c_transfer(adap, msgs, 2);
-
-	DBG("***run in %s %x  % x\n",__FUNCTION__,i2c->addr,msgs[0].buf);
-    return 0;
-}
-
-int rk818_i2c_write(struct rk818 *rk818, char reg, int count,  const u8 src)
-{
-	int ret=-1;
-	struct i2c_client *i2c = rk818->i2c;
-	struct i2c_adapter *adap;
-	struct i2c_msg msg;
-	char tx_buf[2];
-
-	if(!i2c)
-		return ret;
-	if (count != 1)
-		return -EIO;
-    
-	adap = i2c->adapter;		
-	tx_buf[0] = reg;
-	tx_buf[1] = src;
-	
-	msg.addr = i2c->addr;
-	msg.buf = &tx_buf[0];
-	msg.len = 1 +1;
-	msg.flags = i2c->flags;   
-	msg.scl_rate = RK818_I2C_ADDR_RATE;	
-
-	ret = i2c_transfer(adap, &msg, 1);
-	return ret;	
-}
-
-u8 rk818_reg_read(struct rk818 *rk818, u8 reg)
-{
-	u8 val = 0;
-
-	mutex_lock(&rk818->io_lock);
-
-	rk818_i2c_read(rk818, reg, 1, &val);
-
-	DBG("reg read 0x%02x -> 0x%02x\n", (int)reg, (unsigned)val&0xff);
-
-	mutex_unlock(&rk818->io_lock);
-
-	return val & 0xff;	
-}
-EXPORT_SYMBOL_GPL(rk818_reg_read);
-
-int rk818_reg_write(struct rk818 *rk818, u8 reg, u8 val)
-{
-	int err =0;
-
-	mutex_lock(&rk818->io_lock);
-
-	err = rk818_i2c_write(rk818, reg, 1,val);
-	if (err < 0)
-		dev_err(rk818->dev, "Write for reg 0x%x failed\n", reg);
-
-	mutex_unlock(&rk818->io_lock);
-	return err;
-}
-EXPORT_SYMBOL_GPL(rk818_reg_write);
-
- int rk818_set_bits(struct rk818 *rk818, u8 reg, u8 mask, u8 val)
-{
-	u8 tmp;
-	int ret;
-
-	mutex_lock(&rk818->io_lock);
-
-	ret = rk818_i2c_read(rk818, reg, 1, &tmp);
-	DBG("1 reg read 0x%02x -> 0x%02x\n", (int)reg, (unsigned)tmp&0xff);
-	tmp = (tmp & ~mask) | val;
-	if (ret == 0) {
-		ret = rk818_i2c_write(rk818, reg, 1, tmp);
-		DBG("reg write 0x%02x -> 0x%02x\n", (int)reg, (unsigned)val&0xff);
-	}
-	rk818_i2c_read(rk818, reg, 1, &tmp);
-	DBG("2 reg read 0x%02x -> 0x%02x\n", (int)reg, (unsigned)tmp&0xff);
-	mutex_unlock(&rk818->io_lock);
-
-	return 0;//ret;	
-}
-EXPORT_SYMBOL_GPL(rk818_set_bits);
-
-int rk818_clear_bits(struct rk818 *rk818, u8 reg, u8 mask)
-{
-	u8 data;
-	int err;
-
-	mutex_lock(&rk818->io_lock);
-	err = rk818_i2c_read(rk818, reg, 1, &data);
-	if (err <0) {
-		dev_err(rk818->dev, "read from reg %x failed\n", reg);
-		goto out;
-	}
-
-	data &= ~mask;
-	err = rk818_i2c_write(rk818, reg, 1, data);
-	if (err <0)
-		dev_err(rk818->dev, "write to reg %x failed\n", reg);
-
-out:
-	mutex_unlock(&rk818->io_lock);
-	return err;
-}
-EXPORT_SYMBOL_GPL(rk818_clear_bits);
-
-#if 1
-static ssize_t rk818_test_store(struct kobject *kobj, struct kobj_attribute *attr,
-                                const char *buf, size_t n)
-{
-    u32 getdata[8];
-    u8 regAddr;
-    u8 data;
-    char cmd;
-    const char *buftmp = buf;
-    struct rk818 *rk818 = g_rk818;
-    /**
-     * W Addr(8Bit) regAddr(8Bit) data0(8Bit) data1(8Bit) data2(8Bit) data3(8Bit)
-     * 		:data can be less than 4 byte
-     * R regAddr(8Bit)
-     * C gpio_name(poweron/powerhold/sleep/boot0/boot1) value(H/L)
-     */
-	sscanf(buftmp, "%c ", &cmd);
-	printk("------zhangqing: get cmd = %c\n", cmd);
-	switch (cmd) {
-	case 'w':
-		sscanf(buftmp, "%c %x %x ", &cmd, &getdata[0], &getdata[1]);
-		regAddr = (u8)(getdata[0] & 0xff);
-		data = (u8)(getdata[1] & 0xff);
-		printk("get value = %x\n", data);
-
-		rk818_i2c_write(rk818, regAddr, 1, data);
-		rk818_i2c_read(rk818, regAddr, 1, &data);
-		printk("%x   %x\n", getdata[1], data);
-		break;
-	case 'r':
-		sscanf(buftmp, "%c %x ", &cmd, &getdata[0]);
-		printk("CMD : %c %x\n", cmd, getdata[0]);
-
-		regAddr = (u8)(getdata[0] & 0xff);
-		rk818_i2c_read(rk818, regAddr, 1, &data);
-		printk("%x %x\n", getdata[0], data);
-		break;
-	default:
-		printk("Unknown command\n");
-		break;
-	}
-	return n;
-
-}
-static ssize_t rk818_test_show(struct kobject *kobj, struct kobj_attribute *attr,
-                               char *buf)
-{
-   char *s = buf;
-    buf = "hello";
-    return sprintf(s, "%s\n", buf);
-
-}
-
-static struct kobject *rk818_kobj;
-struct rk818_attribute {
-	struct attribute	attr;
-	ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
-			char *buf);
-	ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
-			const char *buf, size_t n);
-};
-
-static struct rk818_attribute rk818_attrs[] = {
-	/*     node_name	permision		show_func	store_func */
-	__ATTR(rk818_test,	S_IRUGO | S_IWUSR,	rk818_test_show,	rk818_test_store),
-};
-#endif
-
-#if 0
-static irqreturn_t rk818_vbat_lo_irq(int irq, void *data)
-{
-        printk("rk818 vbat low %s:irq=%d\n",__func__,irq);
-	rk818_set_bits(g_rk818,0x4c,(0x1 << 1),(0x1 <<1));
-	rk_send_wakeup_key();
-        return IRQ_HANDLED;
-}
-#endif
-
-#ifdef CONFIG_OF
-static struct of_device_id rk818_of_match[] = {
-	{ .compatible = "rockchip,rk818"},
-	{ },
-};
-MODULE_DEVICE_TABLE(of, rk818_of_match);
-#endif
-
-#ifdef CONFIG_OF
-static struct of_regulator_match rk818_reg_matches[] = {
-	{ .name = "rk818_dcdc1", .driver_data = (void *)0 },
-	{ .name = "rk818_dcdc2", .driver_data = (void *)1 },
-	{ .name = "rk818_dcdc3", .driver_data = (void *)2 },
-	{ .name = "rk818_dcdc4", .driver_data = (void *)3 },
-	{ .name = "rk818_ldo1", .driver_data = (void *)4 },
-	{ .name = "rk818_ldo2", .driver_data = (void *)5 },
-	{ .name = "rk818_ldo3", .driver_data = (void *)6 },
-	{ .name = "rk818_ldo4", .driver_data = (void *)7 },
-	{ .name = "rk818_ldo5", .driver_data = (void *)8 },
-	{ .name = "rk818_ldo6", .driver_data = (void *)9 },
-	{ .name = "rk818_ldo7", .driver_data = (void *)10 },
-	{ .name = "rk818_ldo8", .driver_data = (void *)11 },
-	{ .name = "rk818_ldo9", .driver_data = (void *)12 },
-	{ .name = "rk818_ldo10", .driver_data = (void *)13 },
-};
-
-static struct rk818_board *rk818_parse_dt(struct rk818 *rk818)
-{
-	struct rk818_board *pdata;
-	struct device_node *regs,*rk818_pmic_np;
-	int i, count;
-
-	rk818_pmic_np = of_node_get(rk818->dev->of_node);
-	if (!rk818_pmic_np) {
-		printk("could not find pmic sub-node\n");
-		return NULL;
-	}
-
-	regs = of_find_node_by_name(rk818_pmic_np, "regulators");
-	if (!regs)
-		return NULL;
-
-	count = of_regulator_match(rk818->dev, regs, rk818_reg_matches,
-				   rk818_NUM_REGULATORS);
-	of_node_put(regs);
-	if ((count < 0) || (count > rk818_NUM_REGULATORS))
-		return NULL;
-
-	pdata = devm_kzalloc(rk818->dev, sizeof(*pdata), GFP_KERNEL);
-	if (!pdata)
-		return NULL;
-
-	for (i = 0; i < count; i++) {
-		if (!rk818_reg_matches[i].init_data || !rk818_reg_matches[i].of_node)
-			continue;
-
-		pdata->rk818_init_data[i] = rk818_reg_matches[i].init_data;
-		pdata->of_node[i] = rk818_reg_matches[i].of_node;
-	}
-	pdata->irq = rk818->chip_irq;
-	pdata->irq_base = -1;
-	
-	pdata->irq_gpio = of_get_named_gpio(rk818_pmic_np,"gpios",0);
-		if (!gpio_is_valid(pdata->irq_gpio)) {
-			printk("invalid gpio: %d\n",  pdata->irq_gpio);
-			return NULL;
-		}
-
-	pdata->pmic_sleep_gpio = of_get_named_gpio(rk818_pmic_np,"gpios",1);
-			if (!gpio_is_valid(pdata->pmic_sleep_gpio)) {
-				printk("invalid gpio: %d\n",  pdata->pmic_sleep_gpio);
-		}
-	pdata->pmic_sleep = true;
-	pdata->pm_off = of_property_read_bool(rk818_pmic_np,"rk818,system-power-controller");
-		
-	return pdata;
-}
-
-#else
-static struct rk818_board *rk818_parse_dt(struct i2c_client *i2c)
-{
-	return NULL;
-}
-#endif
-
-static void rk818_shutdown(void)
-{
-	int ret;
-	struct rk818 *rk818 = g_rk818;
-
-	pr_info("%s\n", __func__);
-	ret = rk818_set_bits(rk818, RK818_INT_STS_MSK_REG1,(0x3<<5),(0x3<<5)); //close rtc int when power off
-	ret = rk818_clear_bits(rk818, RK818_RTC_INT_REG,(0x3<<2)); //close rtc int when power off
-	/*disable otg_en*/
-	ret = rk818_clear_bits(rk818, RK818_DCDC_EN_REG, (0x1<<7));
-
-	mutex_lock(&rk818->io_lock);
-	mdelay(100);
-}
-
-static struct syscore_ops rk818_syscore_ops = {
-	.shutdown = rk818_shutdown,
-};
-
-void rk818_device_shutdown(void)
-{
-	int ret, i;
-	u8 reg = 0;
-	struct rk818 *rk818 = g_rk818;
-
-	for (i = 0; i < 10; i++) {
-		pr_info("%s\n", __func__);
-		ret = rk818_i2c_read(rk818, RK818_DEVCTRL_REG, 1, &reg);
-		if (ret < 0)
-			continue;
-		ret = rk818_i2c_write(rk818, RK818_DEVCTRL_REG, 1,
-				     (reg | (0x1 << 0)));
-		if (ret < 0) {
-			pr_err("rk818 power off error!\n");
-			continue;
-		}
-	}
-	while(1) wfi();
-}
-EXPORT_SYMBOL_GPL(rk818_device_shutdown);
-
-__weak void  rk818_device_suspend(void) {}
-__weak void  rk818_device_resume(void) {}
-#ifdef CONFIG_PM
-static int rk818_suspend(struct i2c_client *i2c, pm_message_t mesg)
-{
-	int ret, val;
-	struct rk818 *rk818 = g_rk818;
-
-	rk818_device_suspend();
-	/************set vbat low 3v4 to irq**********/
-	val = rk818_reg_read(rk818, RK818_VB_MON_REG);
-	val &= (~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK));
-	val |= (RK818_VBAT_LOW_3V4 | EN_VBAT_LOW_IRQ);
-	ret = rk818_reg_write(rk818, RK818_VB_MON_REG, val);
-	if (ret < 0) {
-		pr_err("Unable to write RK818_VB_MON_REG reg\n");
-		return ret;
-	}
-	/*enable low irq*/
-	rk818_set_bits(rk818, 0x4d, (0x1 << 1), (0x0 << 1));
-	return 0;
-}
-
-static int rk818_resume(struct i2c_client *i2c)
-{
-	int ret, val;
-	struct rk818 *rk818 = g_rk818;
-
-	rk818_device_resume();
-	/********set vbat low 3v0 to shutdown**********/
-	val = rk818_reg_read(rk818, RK818_VB_MON_REG);
-	val &= (~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK));
-	val |= (RK818_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN);
-	ret = rk818_reg_write(rk818, RK818_VB_MON_REG, val);
-	if (ret < 0) {
-		pr_err("Unable to write RK818_VB_MON_REG reg\n");
-		return ret;
-	}
-	/*disable low irq*/
-	rk818_set_bits(rk818, 0x4d, (0x1 << 1), (0x1 << 1));
-
-	return 0;
-}
-#else
-static int rk818_suspend(struct i2c_client *i2c, pm_message_t mesg)
-{		
-	return 0;
-}
-
-static int rk818_resume(struct i2c_client *i2c)
-{
-	return 0;
-}
-#endif
-
-static int rk818_pre_init(struct rk818 *rk818)
-{
-	int ret,val;
-	printk("%s,line=%d\n", __func__,__LINE__);
-
-	ret = rk818_set_bits(rk818, 0xa1, (0xF<<0),(0x7));
-	ret = rk818_set_bits(rk818, 0xa1,(0x7<<4),(0x7<<4)); //close charger when usb low then 3.4V
-	ret = rk818_set_bits(rk818, 0x52,(0x1<<1),(0x1<<1)); //no action when vref
-	ret = rk818_set_bits(rk818, 0x52,(0x1<<0),(0x1<<0)); //enable HDMI 5V
-
-	/*******enable switch and boost***********/
-	val = rk818_reg_read(rk818,RK818_DCDC_EN_REG);
-	val |= (0x3 << 5);    //enable switch1/2
-	val |= (0x1 << 4);    //enable boost
-	ret = rk818_reg_write(rk818,RK818_DCDC_EN_REG,val);
-	if (ret <0) {
-		printk(KERN_ERR "Unable to write RK818_DCDC_EN_REG reg\n");
-		return ret;
-	}
-	/****************************************/
-	/****************set vbat low **********/
-	val = rk818_reg_read(rk818,RK818_VB_MON_REG);
-	val &=(~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK));
-	val |= (RK818_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN);
-	ret = rk818_reg_write(rk818,RK818_VB_MON_REG,val);
-	if (ret <0) {
-		printk(KERN_ERR "Unable to write RK818_VB_MON_REG reg\n");
-		return ret;
-	}
-	/**************************************/
-
-	/**********mask int****************/
-
-	val = rk818_reg_read(rk818,RK818_INT_STS_MSK_REG1);
-	val |= (0x1<<0); //mask vout_lo_int
-	ret = rk818_reg_write(rk818,RK818_INT_STS_MSK_REG1,val);
-	if (ret <0) {
-		printk(KERN_ERR "Unable to write RK818_INT_STS_MSK_REG1 reg\n");
-		return ret;
-	}
-
-	/**********************************/
-	/**********enable clkout2****************/
-	ret = rk818_reg_write(rk818,RK818_CLK32OUT_REG,0x01);
-	if (ret <0) {
-		printk(KERN_ERR "Unable to write RK818_CLK32OUT_REG reg\n");
-		return ret;
-	}
-	/**********************************/
-	ret = rk818_clear_bits(rk818, RK818_INT_STS_MSK_REG1,(0x3<<5)); //open rtc int when power on
-	ret = rk818_set_bits(rk818, RK818_RTC_INT_REG,(0x1<<3),(0x1<<3)); //open rtc int when power on
-
-	/*****disable otg when in sleep mode****/
-	val = rk818_reg_read(rk818, RK818_SLEEP_SET_OFF_REG1);
-	val |= (0x1 << 7);
-	ret =  rk818_reg_write(rk818, RK818_SLEEP_SET_OFF_REG1, val);
-	if (ret < 0) {
-		pr_err("Unable to write RK818_SLEEP_SET_OFF_REG1 reg\n");
-		return ret;
-	}
-
-	/*************** improve efficiency **********************/
-	ret =  rk818_reg_write(rk818, RK818_BUCK2_CONFIG_REG, 0x1c);
-	if (ret < 0) {
-		pr_err("Unable to write RK818_BUCK2_CONFIG_REG reg\n");
-		return ret;
-	}
-
-	ret =  rk818_reg_write(rk818, RK818_BUCK4_CONFIG_REG, 0x04);
-	if (ret < 0) {
-		pr_err("Unable to write RK818_BUCK4_CONFIG_REG reg\n");
-		return ret;
-	}
-
-	return 0;
-}
- 
-static int  rk818_i2c_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
-{
-	struct rk818 *rk818;	
-	struct rk818_board *pdev;
-	const struct of_device_id *match;
-	struct regulator_config config = { };
-	struct regulator_dev *rk818_rdev;
-	struct regulator_init_data *reg_data;
-	const char *rail_name = NULL;
-	int ret, i = 0;
-	
-	printk("%s,line=%d\n", __func__,__LINE__);
-
-	if (i2c->dev.of_node) {
-		match = of_match_device(rk818_of_match, &i2c->dev);
-		if (!match) {
-			dev_err(&i2c->dev,"Failed to find matching dt id\n");
-			return -EINVAL;
-		}
-	}
-
-	rk818 = devm_kzalloc(&i2c->dev,sizeof(struct rk818), GFP_KERNEL);
-	if (rk818 == NULL) {
-		ret = -ENOMEM;		
-		goto err;
-	}
-	rk818->i2c = i2c;
-	rk818->dev = &i2c->dev;
-	i2c_set_clientdata(i2c, rk818);
-	
-	mutex_init(&rk818->io_lock);	
-
-	ret = rk818_reg_read(rk818,0x2f);
-	if ((ret < 0) || (ret == 0xff)){
-		printk("The device is not rk818 %d\n",ret);
-		goto err;
-	}
-
-	ret = rk818_pre_init(rk818);
-	if (ret < 0){
-		printk("The rk818_pre_init failed %d\n",ret);
-		goto err;
-	}
-
-	if (rk818->dev->of_node)
-		pdev = rk818_parse_dt(rk818);
-	
-	/******************************set sleep vol & dcdc mode******************/
-	#ifdef CONFIG_OF
-	rk818->pmic_sleep_gpio = pdev->pmic_sleep_gpio;
-	if (rk818->pmic_sleep_gpio) {
-			ret = gpio_request(rk818->pmic_sleep_gpio, "rk818_pmic_sleep");
-			if (ret < 0) {
-				dev_err(rk818->dev,"Failed to request gpio %d with ret:""%d\n",	rk818->pmic_sleep_gpio, ret);
-				return IRQ_NONE;
-			}
-			gpio_direction_output(rk818->pmic_sleep_gpio,0);
-			ret = gpio_get_value(rk818->pmic_sleep_gpio);
-			gpio_free(rk818->pmic_sleep_gpio);
-			pr_info("%s: rk818_pmic_sleep=%x\n", __func__, ret);
-	}	
-	#endif
-	/**********************************************************/
-	
-	if (pdev) {
-		rk818->num_regulators = rk818_NUM_REGULATORS;
-		rk818->rdev = kcalloc(rk818_NUM_REGULATORS,sizeof(struct regulator_dev *), GFP_KERNEL);
-		if (!rk818->rdev) {
-			return -ENOMEM;
-		}
-		/* Instantiate the regulators */
-		for (i = 0; i < rk818_NUM_REGULATORS; i++) {
-		reg_data = pdev->rk818_init_data[i];
-		if (!reg_data)
-			continue;
-		config.dev = rk818->dev;
-		config.driver_data = rk818;
-		if (rk818->dev->of_node)
-			config.of_node = pdev->of_node[i];
-		if (reg_data && reg_data->constraints.name)
-				rail_name = reg_data->constraints.name;
-			else
-				rail_name = regulators[i].name;
-			reg_data->supply_regulator = rail_name;
-	
-		config.init_data =reg_data;
-
-		rk818_rdev = regulator_register(&regulators[i],&config);
-		if (IS_ERR(rk818_rdev)) {
-			printk("failed to register %d regulator\n",i);
-		goto err;
-		}
-		rk818->rdev[i] = rk818_rdev;
-		}
-	}
-
-	rk818->irq_gpio = pdev->irq_gpio;
-	ret = rk818_irq_init(rk818, rk818->irq_gpio, pdev);
-	if (ret < 0)
-		goto err;
-
-	ret = mfd_add_devices(rk818->dev, -1,
-			      rk818s, ARRAY_SIZE(rk818s),
-			      NULL, 0,NULL);
-	#if 0	
-	/********************vbat low int**************/
-	vlow_irq = irq_create_mapping(rk818->irq_domain, RK818_IRQ_VB_LO);
-	 ret = devm_request_threaded_irq(&i2c->dev,vlow_irq, NULL, rk818_vbat_lo_irq,
-                                   IRQF_ONESHOT, "rk818_vbatlow",
-                                   rk818);
-        if (ret != 0) {
-                dev_err(rk818->dev, "Failed to request periodic IRQ %d: %d\n",
-                        vlow_irq+ RK818_IRQ_VB_LO, ret);
-
-        }
-	#endif
-	/*********************************************/
-	
-	g_rk818 = rk818;
-	if (pdev->pm_off && !pm_power_off) {
-		pm_power_off = rk818_device_shutdown;
-	}
-
-	#if 1
-	rk818_kobj = kobject_create_and_add("rk818", NULL);
-	if (!rk818_kobj)
-		return -ENOMEM;
-	for (i = 0; i < ARRAY_SIZE(rk818_attrs); i++) {
-		ret = sysfs_create_file(rk818_kobj, &rk818_attrs[i].attr);
-		if (ret != 0) {
-			printk("create index %d error\n", i);
-			return ret;
-		}
-	}
-	#endif
-	
-	register_syscore_ops(&rk818_syscore_ops);
-
-	return 0;
-
-err:
-	mfd_remove_devices(rk818->dev);
-	return ret;	
-
-}
-
-static int  rk818_i2c_remove(struct i2c_client *i2c)
-{
-	struct rk818 *rk818 = i2c_get_clientdata(i2c);
-	int i;
-
-	unregister_syscore_ops(&rk818_syscore_ops);
-	for (i = 0; i < rk818->num_regulators; i++)
-		if (rk818->rdev[i])
-			regulator_unregister(rk818->rdev[i]);
-	i2c_set_clientdata(i2c, NULL);
-
-	return 0;
-}
-
-static const struct i2c_device_id rk818_i2c_id[] = {
-       { "rk818", 0 },
-       { }
-};
-
-MODULE_DEVICE_TABLE(i2c, rk818_i2c_id);
-
-static struct i2c_driver rk818_i2c_driver = {
-	.driver = {
-		.name = "rk818",
-		.owner = THIS_MODULE,
-		.of_match_table =of_match_ptr(rk818_of_match),
-	},
-	.probe    = rk818_i2c_probe,
-	.remove   = rk818_i2c_remove,
-	.id_table = rk818_i2c_id,
-	#ifdef CONFIG_PM
-	.suspend	= rk818_suspend,
-	.resume		= rk818_resume,
-	#endif
-};
-
-static int __init rk818_module_init(void)
-{
-	int ret;
-	ret = i2c_add_driver(&rk818_i2c_driver);
-	if (ret != 0)
-		pr_err("Failed to register I2C driver: %d\n", ret);
-	return ret;
-}
-
-subsys_initcall_sync(rk818_module_init);
-
-static void __exit rk818_module_exit(void)
-{
-	i2c_del_driver(&rk818_i2c_driver);
-}
-module_exit(rk818_module_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("zhangqing <zhangqing@rock-chips.com>");
-MODULE_DESCRIPTION("rk818 PMIC driver");
-
diff --git a/drivers/rtc/rtc-rk818.c b/drivers/rtc/rtc-rk818.c
deleted file mode 100755
index 5ad4cb66787b..000000000000
--- a/drivers/rtc/rtc-rk818.c
+++ /dev/null
@@ -1,833 +0,0 @@
-/*
- *	Real Time Clock driver for  rk818
- *
- *  Author: zhangqing <zhangqing@rock-chips.com>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/time.h>
-#include <linux/rtc.h>
-#include <linux/slab.h>
-#include <linux/bcd.h>
-#include <linux/interrupt.h>
-#include <linux/ioctl.h>
-#include <linux/completion.h>
-#include <linux/mfd/rk818.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/miscdevice.h>
-#include <linux/irqdomain.h>
-
-
-/* RTC Definitions */
-/* RTC_CTRL_REG bitfields */
-#define BIT_RTC_CTRL_REG_STOP_RTC_M		0x01
-#define BIT_RTC_CTRL_REG_ROUND_30S_M		0x02
-#define BIT_RTC_CTRL_REG_AUTO_COMP_M		0x04
-#define BIT_RTC_CTRL_REG_MODE_12_24_M		0x08
-#define BIT_RTC_CTRL_REG_TEST_MODE_M		0x10
-#define BIT_RTC_CTRL_REG_SET_32_COUNTER_M	0x20
-#define BIT_RTC_CTRL_REG_GET_TIME_M		0x40
-#define BIT_RTC_CTRL_REG_RTC_V_OPT_M		0x80
-
-/* RTC_STATUS_REG bitfields */
-#define BIT_RTC_STATUS_REG_RUN_M		0x02
-#define BIT_RTC_STATUS_REG_1S_EVENT_M		0x04
-#define BIT_RTC_STATUS_REG_1M_EVENT_M		0x08
-#define BIT_RTC_STATUS_REG_1H_EVENT_M		0x10
-#define BIT_RTC_STATUS_REG_1D_EVENT_M		0x20
-#define BIT_RTC_STATUS_REG_ALARM_M		0x40
-#define BIT_RTC_STATUS_REG_POWER_UP_M		0x80
-
-/* RTC_INTERRUPTS_REG bitfields */
-#define BIT_RTC_INTERRUPTS_REG_EVERY_M		0x03
-#define BIT_RTC_INTERRUPTS_REG_IT_TIMER_M	0x04
-#define BIT_RTC_INTERRUPTS_REG_IT_ALARM_M	0x08
-
-/* DEVCTRL bitfields */
-#define BIT_RTC_PWDN				0x40
-
-/* REG_SECONDS_REG through REG_YEARS_REG is how many registers? */
-#define ALL_TIME_REGS				7
-#define ALL_ALM_REGS				6
-
-
-#define RTC_SET_TIME_RETRIES	5
-#define RTC_GET_TIME_RETRIES	5
-
-
-struct rk818_rtc {
-	struct rk818 *rk818;
-	struct rtc_device *rtc;
-	unsigned int alarm_enabled:1;
-};
-
-/*
- * Read current time and date in RTC
- */
-static int rk818_rtc_readtime(struct device *dev, struct rtc_time *tm)
-{
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(dev);
-	struct rk818 *rk818 = rk818_rtc->rk818;
-	int ret;
-	//int count = 0;
-	unsigned char rtc_data[ALL_TIME_REGS + 1];
-	u8 rtc_ctl;
-
-	/*Dummy read*/	
-	ret = rk818_reg_read(rk818, RK818_RTC_CTRL_REG);
-	
-	/* Has the RTC been programmed? */
-	ret = rk818_reg_read(rk818, RK818_RTC_CTRL_REG);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-
-	rtc_ctl = ret & (~BIT_RTC_CTRL_REG_RTC_V_OPT_M);
-
-	ret = rk818_reg_write(rk818, RK818_RTC_CTRL_REG, rtc_ctl);
-	if (ret < 0) {
-		dev_err(dev, "Failed to write RTC control: %d\n", ret);
-		return ret;
-	}
-
-#if 0	
-	/* Read twice to make sure we don't read a corrupt, partially
-	 * incremented, value.
-	 */
-	do {
-		ret = rk818_bulk_read(rk818, RK818_SECONDS_REG,
-				       ALL_TIME_REGS, rtc_data);
-		if (ret != 0)
-			continue;
-
-		tm->tm_sec = bcd2bin(rtc_data[0]);
-		tm->tm_min = bcd2bin(rtc_data[1]);
-		tm->tm_hour = bcd2bin(rtc_data[2]) ;
-		tm->tm_mday = bcd2bin(rtc_data[3]);
-		tm->tm_mon = bcd2bin(rtc_data[4]) - 1;
-		tm->tm_year = bcd2bin(rtc_data[5]) + 100;	
-		tm->tm_wday = bcd2bin(rtc_data[6]);
-
-		printk( "RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-			1900 + tm->tm_year, tm->tm_mon + 1, tm->tm_mday, tm->tm_wday,
-			tm->tm_hour, tm->tm_min, tm->tm_sec);
-		
-		return ret;
-
-	} while (++count < RTC_GET_TIME_RETRIES);
-	dev_err(dev, "Timed out reading current time\n");
-#else
-	rtc_data[0] = rk818_reg_read(rk818,0x00);
-	rtc_data[1] = rk818_reg_read(rk818,0x01);
-	rtc_data[2] = rk818_reg_read(rk818,0x02);
-	rtc_data[3] = rk818_reg_read(rk818,0x03);
-	rtc_data[4] = rk818_reg_read(rk818,0x04);
-	rtc_data[5] = rk818_reg_read(rk818,0x05);
-	rtc_data[6] = rk818_reg_read(rk818,0x06);
-	
-	 tm->tm_sec = bcd2bin(rtc_data[0]);
-         tm->tm_min = bcd2bin(rtc_data[1]);
-         tm->tm_hour = bcd2bin(rtc_data[2]) ;
-         tm->tm_mday = bcd2bin(rtc_data[3]);
-         tm->tm_mon = bcd2bin(rtc_data[4]) - 1;
-         tm->tm_year = bcd2bin(rtc_data[5]) + 100;       
-         tm->tm_wday = bcd2bin(rtc_data[6]);
-
-	  dev_dbg(dev, "RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-                        1900 + tm->tm_year, tm->tm_mon + 1, tm->tm_mday, tm->tm_wday,tm->tm_hour , tm->tm_min, tm->tm_sec);
-
-#endif
-	return 0;
-
-}
-
-/*
- * Set current time and date in RTC
- */
-static int rk818_rtc_set_time(struct device *dev, struct rtc_time *tm)
-{
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(dev);
-	struct rk818 *rk818 = rk818_rtc->rk818;
-	int ret;
-	u8 rtc_ctl;	
-	unsigned char rtc_data[ALL_TIME_REGS + 1];
-	
-	rtc_data[0] = bin2bcd(tm->tm_sec);
-	rtc_data[1] = bin2bcd(tm->tm_min);
-	rtc_data[2] = bin2bcd(tm->tm_hour );
-	rtc_data[3] = bin2bcd(tm->tm_mday);
-	rtc_data[4] = bin2bcd(tm->tm_mon + 1);
-	rtc_data[5] = bin2bcd(tm->tm_year - 100);
-	rtc_data[6] = bin2bcd(tm->tm_wday);
-
-	 dev_dbg(dev, "set RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-                        1900 + tm->tm_year, tm->tm_mon + 1, tm->tm_mday, tm->tm_wday,tm->tm_hour , tm->tm_min, tm->tm_sec);
-
-	/*Dummy read*/	
-	ret = rk818_reg_read(rk818, RK818_RTC_CTRL_REG);
-	
-	/* Stop RTC while updating the TC registers */
-	ret = rk818_reg_read(rk818, RK818_RTC_CTRL_REG);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-	
-	rtc_ctl = ret | (BIT_RTC_CTRL_REG_STOP_RTC_M);
-
-	ret = rk818_reg_write(rk818, RK818_RTC_CTRL_REG, rtc_ctl);
-	if (ret < 0) {
-		dev_err(dev, "Failed to write RTC control: %d\n", ret);
-		return ret;
-	}
-#if 0	
-	/* update all the time registers in one shot */
-	ret = rk818_bulk_write(rk818, RK818_SECONDS_REG,
-				       ALL_TIME_REGS, rtc_data);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC times: %d\n", ret);
-		return ret;
-	}
-#else
-	rk818_reg_write(rk818,0x00,rtc_data[0]);
-	rk818_reg_write(rk818,0x01,rtc_data[1]);
-	rk818_reg_write(rk818,0x02,rtc_data[2]);
-	rk818_reg_write(rk818,0x03,rtc_data[3]);
-	rk818_reg_write(rk818,0x04,rtc_data[4]);
-	rk818_reg_write(rk818,0x05,rtc_data[5]);
-	rk818_reg_write(rk818,0x06,rtc_data[6]);
-
-#endif	
-	/*Dummy read*/	
-	ret = rk818_reg_read(rk818, RK818_RTC_CTRL_REG);
-	
-	/* Start RTC again */
-	ret = rk818_reg_read(rk818, RK818_RTC_CTRL_REG);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-	
-	rtc_ctl = ret &(~ BIT_RTC_CTRL_REG_STOP_RTC_M);
-
-	ret = rk818_reg_write(rk818, RK818_RTC_CTRL_REG, rtc_ctl);
-	if (ret < 0) {
-		dev_err(dev, "Failed to write RTC control: %d\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-/*
- * Read alarm time and date in RTC
- */
-static int rk818_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
-{
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(dev);
-	int ret;
-	unsigned char alrm_data[ALL_ALM_REGS + 1];
-#if 0
-	ret = rk818_bulk_read(rk818_rtc->rk818, RK818_ALARM_SECONDS_REG,
-			       ALL_ALM_REGS, alrm_data);
-	if (ret != 0) {
-		dev_err(dev, "Failed to read alarm time: %d\n", ret);
-		return ret;
-	}
-#else
-	alrm_data[0] = rk818_reg_read(rk818_rtc->rk818,0x08);
-        alrm_data[1] = rk818_reg_read(rk818_rtc->rk818,0x09);
-        alrm_data[2] = rk818_reg_read(rk818_rtc->rk818,0x0a);
-        alrm_data[3] = rk818_reg_read(rk818_rtc->rk818,0x0b);
-        alrm_data[4] = rk818_reg_read(rk818_rtc->rk818,0x0c);
-        alrm_data[5] = rk818_reg_read(rk818_rtc->rk818,0x0d);
-
-	
-#endif
-	/* some of these fields may be wildcard/"match all" */
-	alrm->time.tm_sec = bcd2bin(alrm_data[0]);
-	alrm->time.tm_min = bcd2bin(alrm_data[1]);
-	alrm->time.tm_hour = bcd2bin(alrm_data[2]);
-	alrm->time.tm_mday = bcd2bin(alrm_data[3]);
-	alrm->time.tm_mon = bcd2bin(alrm_data[4]) - 1;
-	alrm->time.tm_year = bcd2bin(alrm_data[5]) + 100;
-
-	ret = rk818_reg_read(rk818_rtc->rk818, RK818_RTC_INT_REG);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-  	dev_dbg(dev,"alrm read RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-                        1900 + alrm->time.tm_year, alrm->time.tm_mon + 1, alrm->time.tm_mday, alrm->time.tm_wday, alrm->time.tm_hour, alrm->time.tm_min, alrm->time.tm_sec);
-
-
-
-	if (ret & BIT_RTC_INTERRUPTS_REG_IT_ALARM_M)
-		alrm->enabled = 1;
-	else
-		alrm->enabled = 0;
-
-	return 0;
-}
-
-static int rk818_rtc_stop_alarm(struct rk818_rtc *rk818_rtc)
-{
-	rk818_rtc->alarm_enabled = 0;
-
-	return rk818_clear_bits(rk818_rtc->rk818, RK818_RTC_INT_REG,
-			       BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
-
-}
-
-static int rk818_rtc_start_alarm(struct rk818_rtc *rk818_rtc)
-{
-	rk818_rtc->alarm_enabled = 1;
-
-	return rk818_set_bits(rk818_rtc->rk818, RK818_RTC_INT_REG,
-			       BIT_RTC_INTERRUPTS_REG_IT_ALARM_M,BIT_RTC_INTERRUPTS_REG_IT_ALARM_M);
-
-}
-
-static int rk818_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
-{
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(dev);
-	int ret;
-	unsigned char alrm_data[ALL_TIME_REGS + 1];
-	
-	ret = rk818_rtc_stop_alarm(rk818_rtc);
-	if (ret < 0) {
-		dev_err(dev, "Failed to stop alarm: %d\n", ret);
-		return ret;
-	}
-
-	 dev_dbg(dev,"alrm set RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-                        1900 + alrm->time.tm_year, alrm->time.tm_mon + 1, alrm->time.tm_mday, alrm->time.tm_wday, alrm->time.tm_hour, alrm->time.tm_min, alrm->time.tm_sec);
-
-	alrm_data[0] = bin2bcd(alrm->time.tm_sec);
-	alrm_data[1] = bin2bcd(alrm->time.tm_min);
-	alrm_data[2] = bin2bcd(alrm->time.tm_hour );
-	alrm_data[3] = bin2bcd(alrm->time.tm_mday);
-	alrm_data[4] = bin2bcd(alrm->time.tm_mon + 1);
-	alrm_data[5] = bin2bcd(alrm->time.tm_year - 100);
-#if 0
-	ret = rk818_bulk_write(rk818_rtc->rk818, RK818_ALARM_SECONDS_REG,
-			       ALL_ALM_REGS, alrm_data);
-	if (ret != 0) {
-		dev_err(dev, "Failed to read alarm time: %d\n", ret);
-		return ret;
-	}
-#else
-	 rk818_reg_write(rk818_rtc->rk818,0x08,alrm_data[0]);
-        rk818_reg_write(rk818_rtc->rk818,0x09,alrm_data[1]);
-        rk818_reg_write(rk818_rtc->rk818,0x0a,alrm_data[2]);
-        rk818_reg_write(rk818_rtc->rk818,0x0b,alrm_data[3]);
-        rk818_reg_write(rk818_rtc->rk818,0x0c,alrm_data[4]);
-        rk818_reg_write(rk818_rtc->rk818,0x0d,alrm_data[5]);
-
-#endif
-	if (alrm->enabled) {
-		ret = rk818_rtc_start_alarm(rk818_rtc);
-		if (ret < 0) {
-			dev_err(dev, "Failed to start alarm: %d\n", ret);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int rk818_rtc_alarm_irq_enable(struct device *dev,
-				       unsigned int enabled)
-{
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(dev);
-
-	if (enabled)
-		return rk818_rtc_start_alarm(rk818_rtc);
-	else
-		return rk818_rtc_stop_alarm(rk818_rtc);
-}
-
-static int rk818_rtc_update_irq_enable(struct device *dev,
-				       unsigned int enabled)
-{
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(dev);
-
-	if (enabled)
-		return rk818_set_bits(rk818_rtc->rk818, RK818_RTC_INT_REG,
-			       BIT_RTC_INTERRUPTS_REG_IT_TIMER_M,BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
-	else
-		return rk818_clear_bits(rk818_rtc->rk818, RK818_RTC_INT_REG,
-			       BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
-}
-
-/*
- * We will just handle setting the frequency and make use the framework for
- * reading the periodic interupts.
- *
- * @freq: Current periodic IRQ freq:
- * bit 0: every second
- * bit 1: every minute
- * bit 2: every hour
- * bit 3: every day
- */
-#if 0
-static int rk818_rtc_irq_set_freq(struct device *dev, int freq)
-{	
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(dev);
-	int ret;	
-	u8 rtc_ctl;	
-	
-	if (freq < 0 || freq > 3)
-		return -EINVAL;
-
-	ret = rk818_reg_read(rk818_rtc->rk818, RK818_RTC_INT_REG);
-	if (ret < 0) {
-		dev_err(dev, "Failed to read RTC interrupt: %d\n", ret);
-		return ret;
-	}
-	
-	rtc_ctl = ret | freq;
-	
-	ret = rk818_reg_write(rk818_rtc->rk818, RK818_RTC_INT_REG, rtc_ctl);
-	if (ret < 0) {
-		dev_err(dev, "Failed to write RTC control: %d\n", ret);
-		return ret;
-	}
-	
-	return ret;
-}
-#endif
-
-static irqreturn_t rk818_alm_irq(int irq, void *data)
-{
-	struct rk818_rtc *rk818_rtc = data;
-	int ret;
-	u8 rtc_ctl;
-	
-	/*Dummy read -- mandatory for status register*/
-	ret = rk818_reg_read(rk818_rtc->rk818, RK818_RTC_STATUS_REG);
-	if (ret < 0) {
-		printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-		return ret;
-	}
-		
-	ret = rk818_reg_read(rk818_rtc->rk818, RK818_RTC_STATUS_REG);
-	if (ret < 0) {
-		printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-		return ret;
-	}
-	rtc_ctl = ret&0xff;
-
-	//The alarm interrupt keeps its low level, until the micro-controller write 1 in the ALARM bit of the RTC_STATUS_REG register.	
-	ret = rk818_reg_write(rk818_rtc->rk818, RK818_RTC_STATUS_REG,rtc_ctl);
-	if (ret < 0) {
-		printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-		return ret;
-	}
-	
-	rtc_update_irq(rk818_rtc->rtc, 1, RTC_IRQF | RTC_AF);
-	
-	printk("%s:irq=%d,rtc_ctl=0x%x\n",__func__,irq,rtc_ctl);
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t rk818_per_irq(int irq, void *data)
-{
-	struct rk818_rtc *rk818_rtc = data;
-	
-	rtc_update_irq(rk818_rtc->rtc, 1, RTC_IRQF | RTC_UF);
-
-	//printk("%s:irq=%d\n",__func__,irq);
-	return IRQ_HANDLED;
-}
-
-static const struct rtc_class_ops rk818_rtc_ops = {
-	.read_time = rk818_rtc_readtime,
-	//.set_mmss = rk818_rtc_set_mmss,
-	.set_time = rk818_rtc_set_time,
-	.read_alarm = rk818_rtc_readalarm,
-	.set_alarm = rk818_rtc_setalarm,
-	.alarm_irq_enable = rk818_rtc_alarm_irq_enable,
-	//.update_irq_enable = rk818_rtc_update_irq_enable,
-	//.irq_set_freq = rk818_rtc_irq_set_freq,
-};
-
-#ifdef CONFIG_PM
-/* Turn off the alarm if it should not be a wake source. */
-static int rk818_rtc_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(&pdev->dev);
-	int ret;
-	
-	if (rk818_rtc->alarm_enabled && device_may_wakeup(&pdev->dev))
-		ret = rk818_rtc_start_alarm(rk818_rtc);
-	else
-		ret = rk818_rtc_stop_alarm(rk818_rtc);
-
-	if (ret < 0)
-		dev_err(&pdev->dev, "Failed to update RTC alarm: %d\n", ret);
-
-	return 0;
-}
-
-/* Enable the alarm if it should be enabled (in case it was disabled to
- * prevent use as a wake source).
- */
-static int rk818_rtc_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(&pdev->dev);
-	int ret;
-
-	if (rk818_rtc->alarm_enabled) {
-		ret = rk818_rtc_start_alarm(rk818_rtc);
-		if (ret < 0)
-			dev_err(&pdev->dev,
-				"Failed to restart RTC alarm: %d\n", ret);
-	}
-
-	return 0;
-}
-
-/* Unconditionally disable the alarm */
-static int rk818_rtc_freeze(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct rk818_rtc *rk818_rtc = dev_get_drvdata(&pdev->dev);
-	int ret;
-	
-	ret = rk818_rtc_stop_alarm(rk818_rtc);
-	if (ret < 0)
-		dev_err(&pdev->dev, "Failed to stop RTC alarm: %d\n", ret);
-
-	return 0;
-}
-#else
-#define rk818_rtc_suspend NULL
-#define rk818_rtc_resume NULL
-#define rk818_rtc_freeze NULL
-#endif
-extern struct rk818 *g_rk818;
-struct platform_device *rk818_pdev;
-struct rtc_time rk818_tm_def = {	//	2012.1.1 12:00:00 Saturday
-			.tm_wday = 6,
-			.tm_year = 112,
-			.tm_mon = 0,
-			.tm_mday = 1,
-			.tm_hour = 12,
-			.tm_min = 0,
-			.tm_sec = 0,
-};
-
-static int rk818_rtc_probe(struct platform_device *pdev)
-{
-	struct rk818 *rk818 = dev_get_drvdata(pdev->dev.parent);
-	struct rk818_rtc *rk818_rtc;
-	struct rtc_time tm;
-	int per_irq;
-	int alm_irq;
-	int ret = 0;
-	u8 rtc_ctl;
-
-	printk("%s,line=%d\n", __func__,__LINE__);
-
-	rk818_rtc = devm_kzalloc(&pdev->dev,sizeof(*rk818_rtc), GFP_KERNEL);
-	if (rk818_rtc == NULL)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, rk818_rtc);
-	rk818_rtc->rk818 = rk818;
-	
-	/* Take rtc out of reset */
-	/*
-	ret = rk818_reg_read(rk818, RK818_DEVCTRL);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Failed to read RK818_DEVCTRL: %d\n", ret);
-		return ret;
-	}
-	
-	if(ret & BIT_RTC_PWDN)
-	{
-		rtc_ctl = ret & (~BIT_RTC_PWDN);
-
-		ret = rk818_reg_write(rk818, RK818_DEVCTRL, rtc_ctl);
-		if (ret < 0) {
-			dev_err(&pdev->dev, "Failed to write RTC control: %d\n", ret);
-			return ret;
-		}
-	}
-	*/
-	/*start rtc default*/
-	ret = rk818_reg_read(rk818, RK818_RTC_CTRL_REG);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Failed to read RTC control: %d\n", ret);
-		return ret;
-	}
-	rtc_ctl = ret & (~BIT_RTC_CTRL_REG_STOP_RTC_M);
-
-	ret = rk818_reg_write(rk818, RK818_RTC_CTRL_REG, rtc_ctl);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Failed to write RTC control: %d\n", ret);
-			return ret;
-		}
-	
-	ret = rk818_reg_read(rk818, RK818_RTC_STATUS_REG);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Failed to read RTC status: %d\n", ret);
-		return ret;
-	}
-	rk818_reg_write(rk818,RK818_RTC_STATUS_REG,0xfe);	
-	/*set init time*/
-
-	ret = rk818_rtc_readtime(&pdev->dev, &tm);
-	if (ret<0)
-	{
-		dev_err(&pdev->dev, "Failed to read RTC time\n");
-		return ret;
-	}
-
-	ret = rtc_valid_tm(&tm);
-	if (ret) {
-	dev_err(&pdev->dev,"invalid date/time and init time\n");
-		rk818_rtc_set_time(&pdev->dev, &rk818_tm_def); // 2012-01-01 12:00:00
-//		DBG( "set RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",1900 + tm_def.tm_year, tm_def.tm_mon + 1, tm_def.tm_mday, tm_def.tm_wday,tm_def.tm_hour, tm_def.tm_min, tm_def.tm_sec);
-	}
-
-	device_init_wakeup(&pdev->dev, 1);
-
-	rk818_rtc->rtc = rtc_device_register("rk818", &pdev->dev,
-					      &rk818_rtc_ops, THIS_MODULE);
-	if (IS_ERR(rk818_rtc->rtc)) {
-		ret = PTR_ERR(rk818_rtc->rtc);
-		goto err;
-	}
-	
-	per_irq = irq_create_mapping(rk818->irq_domain, RK818_IRQ_RTC_PERIOD);
-	alm_irq = irq_create_mapping(rk818->irq_domain, RK818_IRQ_RTC_ALARM);	
-
-	/*request rtc and alarm irq of rk818*/
-	ret = devm_request_threaded_irq(rk818->dev,per_irq, NULL, rk818_per_irq,
-				   IRQF_TRIGGER_RISING, "RTC period",
-				   rk818_rtc);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "Failed to request periodic IRQ %d: %d\n",
-			per_irq, ret);
-	}
-
-	ret = devm_request_threaded_irq(rk818->dev,alm_irq, NULL, rk818_alm_irq,
-				   IRQF_TRIGGER_RISING, "RTC alarm",
-				   rk818_rtc);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "Failed to request alarm IRQ %d: %d\n",
-			alm_irq, ret);
-	}
-
-	//for rtc irq test
-	/*
-	rk818_set_bits(rk818_rtc->rk818, RK818_RTC_STATUS_REG,(0x1<< 6),(0x1 <<6));
-	rk818_set_bits(rk818_rtc->rk818, RK818_RTC_INT_REG,0x0c,0x0c);
-	rk818_set_bits(rk818_rtc->rk818,RK818_INT_STS_REG1,(0x3 << 5),(0x3 <<5));
-	rk818_set_bits(rk818_rtc->rk818, RK818_INT_STS_MSK_REG1,(0x3 <<5),0);
-*/
-
-//	enable_irq_wake(alm_irq); // so rk818 alarm irq can wake up system
-	rk818_pdev = pdev;
-	
-	printk("%s:ok\n",__func__);
-	
-	return 0;
-
-err:
-	return ret;
-}
-
-static int  rk818_rtc_remove(struct platform_device *pdev)
-{
-	struct rk818_rtc *rk818_rtc = platform_get_drvdata(pdev);
-	int per_irq = rk818_rtc->rk818->irq_base + RK818_IRQ_RTC_PERIOD;
-	int alm_irq = rk818_rtc->rk818->irq_base + RK818_IRQ_RTC_ALARM;
-
-	free_irq(alm_irq, rk818_rtc);
-	free_irq(per_irq, rk818_rtc);
-	rtc_device_unregister(rk818_rtc->rtc);
-
-	return 0;
-}
-
-static const struct dev_pm_ops rk818_rtc_pm_ops = {
-	.suspend = rk818_rtc_suspend,
-	.resume = rk818_rtc_resume,
-
-	.freeze = rk818_rtc_freeze,
-	.thaw = rk818_rtc_resume,
-	.restore = rk818_rtc_resume,
-
-	.poweroff = rk818_rtc_suspend,
-};
-
-static struct platform_driver rk818_rtc_driver = {
-	.probe = rk818_rtc_probe,
-	.remove = rk818_rtc_remove,
-	.driver = {
-		.name = "rk818-rtc",
-		.pm = &rk818_rtc_pm_ops,
-	},
-};
-
-static ssize_t rtc_rk818_test_write(struct file *file, 
-			const char __user *buf, size_t count, loff_t *offset)
-{
-	char nr_buf[8];
-	int nr = 0, ret;
-	struct platform_device *pdev;	
-	struct rtc_time tm;
-	struct rtc_wkalrm alrm;
-	struct rk818_rtc *rk818_rtc;
-	
-	if(count > 3)
-		return -EFAULT;
-	ret = copy_from_user(nr_buf, buf, count);
-	if(ret < 0)
-		return -EFAULT;
-
-	sscanf(nr_buf, "%d", &nr);
-	if(nr > 5 || nr < 0)
-	{
-		printk("%s:data is error\n",__func__);
-		return -EFAULT;
-	}
-
-	if(!rk818_pdev)
-		return -EFAULT;
-	else
-		pdev = rk818_pdev;
-
-	
-	rk818_rtc = dev_get_drvdata(&pdev->dev);
-	
-	//test rtc time
-	if(nr == 0)
-	{	
-		tm.tm_wday = 6;
-		tm.tm_year = 111;
-		tm.tm_mon = 0;
-		tm.tm_mday = 1;
-		tm.tm_hour = 12;
-		tm.tm_min = 0;
-		tm.tm_sec = 0;
-	
-		ret = rk818_rtc_set_time(&pdev->dev, &tm); // 2011-01-01 12:00:00
-		if (ret)
-		{
-			dev_err(&pdev->dev, "Failed to set RTC time\n");
-			return -EFAULT;
-		}
-
-	}
-	
-	/*set init time*/
-	ret = rk818_rtc_readtime(&pdev->dev, &tm);
-	if (ret)
-		dev_err(&pdev->dev, "Failed to read RTC time\n");
-	else
-		dev_info(&pdev->dev, "RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-			1900 + tm.tm_year, tm.tm_mon + 1, tm.tm_mday, tm.tm_wday,
-			tm.tm_hour, tm.tm_min, tm.tm_sec);
-		
-	if(!ret)
-	printk("%s:ok\n",__func__);
-	else
-	printk("%s:error\n",__func__);
-	
-
-	//test rtc alarm
-	if(nr == 2)
-	{
-		//2000-01-01 00:00:30
-		if(tm.tm_sec < 30)
-		{
-			alrm.time.tm_sec = tm.tm_sec+30;	
-			alrm.time.tm_min = tm.tm_min;
-		}
-		else
-		{
-			alrm.time.tm_sec = tm.tm_sec-30;
-			alrm.time.tm_min = tm.tm_min+1;
-		}
-		alrm.time.tm_hour = tm.tm_hour;
-		alrm.time.tm_mday = tm.tm_mday;
-		alrm.time.tm_mon = tm.tm_mon;
-		alrm.time.tm_year = tm.tm_year;		
-		rk818_rtc_alarm_irq_enable(&pdev->dev, 1);
-		rk818_rtc_setalarm(&pdev->dev, &alrm);
-
-		dev_info(&pdev->dev, "Set alarm %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
-				1900 + alrm.time.tm_year, alrm.time.tm_mon + 1, alrm.time.tm_mday, alrm.time.tm_wday,
-				alrm.time.tm_hour, alrm.time.tm_min, alrm.time.tm_sec);
-	}
-
-	
-	if(nr == 3)
-	{	
-		ret = rk818_reg_read(rk818_rtc->rk818, RK818_RTC_STATUS_REG);
-		if (ret < 0) {
-			printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-			return ret;
-		}
-		printk("%s:ret=0x%x\n",__func__,ret&0xff);
-
-		ret = rk818_reg_write(rk818_rtc->rk818, RK818_RTC_STATUS_REG, ret&0xff);
-		if (ret < 0) {
-			printk("%s:Failed to read RTC status: %d\n", __func__, ret);
-			return ret;
-		}
-	}
-
-	if(nr == 4)
-	rk818_rtc_update_irq_enable(&pdev->dev, 1);
-
-	if(nr == 5)
-	rk818_rtc_update_irq_enable(&pdev->dev, 0);
-	
-	return count;
-}
-
-static const struct file_operations rtc_rk818_test_fops = {
-	.write = rtc_rk818_test_write,
-};
-
-static struct miscdevice rtc_rk818_test_misc = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "rtc_rk818_test",
-	.fops = &rtc_rk818_test_fops,
-};
-
-
-static int __init rk818_rtc_init(void)
-{
-	misc_register(&rtc_rk818_test_misc);
-	return platform_driver_register(&rk818_rtc_driver);
-}
-subsys_initcall_sync(rk818_rtc_init);
-
-static void __exit rk818_rtc_exit(void)
-{	
-        misc_deregister(&rtc_rk818_test_misc);
-	platform_driver_unregister(&rk818_rtc_driver);
-}
-module_exit(rk818_rtc_exit);
-
-MODULE_DESCRIPTION("RTC driver for the rk818 series PMICs");
-MODULE_AUTHOR("ZHANGQING <zhanqging@rock-chips.com>");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:rk818-rtc");
diff --git a/include/linux/mfd/rk818.h b/include/linux/mfd/rk818.h
deleted file mode 100755
index bdcc3c6d32e4..000000000000
--- a/include/linux/mfd/rk818.h
+++ /dev/null
@@ -1,200 +0,0 @@
-/* include/linux/regulator/rk818.h
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#ifndef __LINUX_REGULATOR_rk818_H
-#define __LINUX_REGULATOR_rk818_H
-
-#include <linux/regulator/machine.h>
-#include <linux/wakelock.h>
-#include <linux/power_supply.h>
-//#include <linux/power/rk818_battery.h>
-
-//#define RK818_START 30
-
-#define RK818_DCDC1  0                     //(0+RK818_START) 
-
-#define RK818_LDO1 4                //(4+RK818_START)
-
-#define RK818_SECONDS_REG 0x00
-#define RK818_MINUTES_REG 0x01
-#define RK818_HOURS_REG 0x02
-#define RK818_DAYS_REG 0x03
-#define RK818_MONTHS_REG 0x04
-#define RK818_YEARS_REG 0x05
-#define RK818_WEEKS_REG 0x06
-#define RK818_ALARM_SECONDS_REG 0x07
-#define RK818_ALARM_MINUTES_REG 0x08
-#define RK818_ALARM_HOURS_REG 0x09
-#define RK818_ALARM_DAYS_REG 0x0a
-#define RK818_ALARM_MONTHS_REG 0x0b
-#define RK818_ALARM_YEARS_REG 0x0c
-#define RK818_RTC_CTRL_REG 0x10
-#define RK818_RTC_STATUS_REG 0x11
-#define RK818_RTC_INT_REG 0x12
-#define RK818_RTC_COMP_LSB_REG 0x13
-#define RK818_RTC_COMP_MSB_REG 0x14
-#define RK818_CLK32OUT_REG 0x20
-#define RK818_VB_MON_REG 0x21
-#define RK818_THERMAL_REG 0x22
-#define RK818_DCDC_EN_REG 0x23
-#define RK818_LDO_EN_REG 0x24
-#define RK818_SLEEP_SET_OFF_REG1 0x25
-#define RK818_SLEEP_SET_OFF_REG2 0x26
-#define RK818_DCDC_UV_STS_REG 0x27
-#define RK818_DCDC_UV_ACT_REG 0x28
-#define RK818_LDO_UV_STS_REG 0x29
-#define RK818_LDO_UV_ACT_REG 0x2a
-#define RK818_DCDC_PG_REG 0x2b
-#define RK818_LDO_PG_REG 0x2c
-#define RK818_VOUT_MON_TDB_REG 0x2d
-#define RK818_BUCK1_CONFIG_REG 0x2e
-#define RK818_BUCK1_ON_REG 0x2f
-#define RK818_BUCK1_SLP_REG 0x30
-#define RK818_BUCK2_CONFIG_REG 0x32
-#define RK818_BUCK2_ON_REG 0x33
-#define RK818_BUCK2_SLP_REG 0x34
-#define RK818_BUCK3_CONFIG_REG 0x36
-#define RK818_BUCK4_CONFIG_REG 0x37
-#define RK818_BUCK4_ON_REG 0x38
-#define RK818_BUCK4_SLP_VSEL_REG 0x39
-#define RK818_BOOST_CONFIG_REG 0x3a
-#define RK818_LDO1_ON_VSEL_REG 0x3b
-#define RK818_LDO1_SLP_VSEL_REG 0x3c
-#define RK818_LDO2_ON_VSEL_REG 0x3d
-#define RK818_LDO2_SLP_VSEL_REG 0x3e
-#define RK818_LDO3_ON_VSEL_REG 0x3f
-#define RK818_LDO3_SLP_VSEL_REG 0x40
-#define RK818_LDO4_ON_VSEL_REG 0x41
-#define RK818_LDO4_SLP_VSEL_REG 0x42
-#define RK818_LDO5_ON_VSEL_REG 0x43
-#define RK818_LDO5_SLP_VSEL_REG 0x44
-#define RK818_LDO6_ON_VSEL_REG 0x45
-#define RK818_LDO6_SLP_VSEL_REG 0x46
-#define RK818_LDO7_ON_VSEL_REG 0x47
-#define RK818_LDO7_SLP_VSEL_REG 0x48
-#define RK818_LDO8_ON_VSEL_REG 0x49
-#define RK818_LDO8_SLP_VSEL_REG 0x4a
-#define RK818_BOOST_LDO9_ON_VSEL_REG 0x54
-#define RK818_BOOST_LDO9_SLP_VSEL_REG 0x55
-#define RK818_DEVCTRL_REG 0x4b
-#define RK818_INT_STS_REG1 0X4c
-#define RK818_INT_STS_MSK_REG1 0X4d
-#define RK818_INT_STS_REG2 0X4e
-#define RK818_INT_STS_MSK_REG2 0X4f
-#define RK818_IO_POL_REG 0X50
-
-/* IRQ Definitions */
-#define RK818_IRQ_VOUT_LO			0
-#define RK818_IRQ_VB_LO				1
-#define RK818_IRQ_PWRON				2
-#define RK818_IRQ_PWRON_LP				3
-#define RK818_IRQ_HOTDIE				4
-#define RK818_IRQ_RTC_ALARM				5
-#define RK818_IRQ_RTC_PERIOD				6
-#define RK818_IRQ_USB_OV				7
-#define RK818_IRQ_PLUG_IN				8
-#define RK818_IRQ_PLUG_OUT				9
-#define RK818_IRQ_CHG_OK				10
-#define RK818_IRQ_CHG_TE				11
-#define RK818_IRQ_CHG_TS1				12
-#define RK818_IRQ_TS2				13
-#define RK818_IRQ_CHG_CVTLIM		14
-#define RK818_IRQ_DISCHG_ILIM				6
-
-#define RK818_NUM_IRQ  16
-
-#define rk818_NUM_REGULATORS 14
-struct rk818;
-
-
-#define RK818_VBAT_LOW_2V8  0x00
-#define RK818_VBAT_LOW_2V9  0x01
-#define RK818_VBAT_LOW_3V0  0x02
-#define RK818_VBAT_LOW_3V1  0x03
-#define RK818_VBAT_LOW_3V2  0x04
-#define RK818_VBAT_LOW_3V3  0x05
-#define RK818_VBAT_LOW_3V4  0x06
-#define RK818_VBAT_LOW_3V5  0x07
-#define VBAT_LOW_VOL_MASK (0x07 << 0)
-#define EN_VABT_LOW_SHUT_DOWN (0x00 << 4)
-#define EN_VBAT_LOW_IRQ (0x1 <<4 )
-#define VBAT_LOW_ACT_MASK (0x1 << 4)
-
-struct rk818_board {
-	int irq;
-	int irq_base;
-	int irq_gpio;
-	int wakeup;
-	struct regulator_init_data *rk818_init_data[rk818_NUM_REGULATORS];
-	struct device_node *of_node[rk818_NUM_REGULATORS];
-	int pmic_sleep_gpio; /* */
-	unsigned int dcdc_slp_voltage[3]; /* buckx_voltage in uV */
-	bool pmic_sleep;
-	unsigned int ldo_slp_voltage[7];
-	bool pm_off;
-};
-
-struct rk818_regulator_subdev {
-	int id;
-	struct regulator_init_data *initdata;
-};
-
-struct rk818 {
-	struct device *dev;
-	struct mutex io_lock;
-	struct i2c_client *i2c;
-	int num_regulators;
-	struct regulator_dev **rdev;
-	struct wake_lock 	irq_wake;
-	struct mutex irq_lock;
-	int irq_base;
-	int irq_num;
-	int chip_irq;
-	int irq_gpio;
-	int wakeup;
-	u32 irq_mask;
-	struct irq_domain *irq_domain;
-	int (*read)(struct rk818 *rk818, u8 reg, int size, void *dest);
-	int (*write)(struct rk818 *rk818, u8 reg, int size, void *src);
-	struct battery_platform_data *battery_data;
-	int pmic_sleep_gpio; /* */
-	unsigned int dcdc_slp_voltage[3]; /* buckx_voltage in uV */
-	bool pmic_sleep;
-	unsigned int ldo_slp_voltage[7];
-};
-
-struct rk818_platform_data {
-	int num_regulators;
-	struct rk818_regulator_subdev *regulators;
-	struct battery_platform_data *battery_data;
-	int irq;
-	int irq_base;
-	struct irq_domain *irq_domain;
-};
-
-int rk818_irq_init(struct rk818 *rk818, int irq,struct rk818_board *pdata);
-int rk818_i2c_read(struct rk818 *rk818, char reg, int count,u8 *dest);
-//int rk818_i2c_read(struct i2c_client *i2c, char reg, int count,u16 *dest);
-// int rk818_i2c_read(struct rk818 *rk818 , u8 reg, int bytes,void *dest); 
-int rk818_i2c_write(struct rk818 *rk818, char reg, int count, const u8 src);
-int rk818_set_bits(struct rk818 *rk818, u8 reg, u8 mask, u8 val);
-int rk818_clear_bits(struct rk818 *rk818, u8 reg, u8 mask);
-u8 rk818_reg_read(struct rk818 *rk818, u8 reg);
-int rk818_reg_write(struct rk818 *rk818, u8 reg, u8 val);
-int rk818_bulk_read(struct rk818 *rk818, u8 reg,
-		     int count, u8 *buf);
-int rk818_bulk_write(struct rk818 *rk818, u8 reg,
-		     int count, u8 *buf);
-void rk818_device_shutdown(void);
-
-#endif
-
-- 
2.35.3

