From e4809e730476cb2d60451f0f908e10419adfabe0 Mon Sep 17 00:00:00 2001
From: Zheng Yang <zhengyang@rock-chips.com>
Date: Mon, 1 Feb 2016 18:24:45 +0800
Subject: [PATCH] video: rockchip: hdmi: fix code style following the 4.4
 kernel rule

Change-Id: I685ff16f652cc32343316c26cafd5feaf29efe40
Signed-off-by: Zheng Yang <zhengyang@rock-chips.com>
---
 .../video/rockchip/hdmi/rockchip-hdmi-cec.c   |   21 +-
 .../video/rockchip/hdmi/rockchip-hdmi-core.c  |   31 +-
 .../video/rockchip/hdmi/rockchip-hdmi-edid.c  |   55 +-
 .../video/rockchip/hdmi/rockchip-hdmi-lcdc.c  |   25 +-
 .../video/rockchip/hdmi/rockchip-hdmi-sysfs.c |   29 +-
 drivers/video/rockchip/hdmi/rockchip-hdmi.h   |   10 +-
 .../hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c    |    5 +-
 .../hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h    |    2 +-
 .../rockchip-hdmiv1/rockchip_hdmiv1_cec.c     |   17 +-
 .../rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c    |   32 +-
 .../rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h    |   96 +-
 .../hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c |   25 +-
 .../hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h |  168 +--
 .../hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c    |   38 +-
 .../rockchip-hdmiv2/rockchip_hdmiv2_cec.c     |    5 +-
 .../rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c    |   30 +-
 .../hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c |   61 +-
 .../hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h | 1151 +++++++++--------
 18 files changed, 901 insertions(+), 900 deletions(-)

diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c
index 474449ecdbbe..f8f3d3d096d3 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-cec.c
@@ -16,8 +16,7 @@ static struct cec_device *cec_dev;
 
 static int cecreadframe(struct cec_framedata *frame)
 {
-	if (frame == NULL || !cec_dev ||
-	    cec_dev->readframe == NULL || !cec_dev->enable)
+	if (!frame || !cec_dev || !cec_dev->readframe || !cec_dev->enable)
 		return -1;
 	else
 		return cec_dev->readframe(cec_dev->hdmi, frame);
@@ -25,7 +24,7 @@ static int cecreadframe(struct cec_framedata *frame)
 
 static int cecsendframe(struct cec_framedata *frame)
 {
-	if (frame == NULL || !cec_dev || cec_dev->readframe == NULL)
+	if (!frame || !cec_dev || !cec_dev->readframe)
 		return -1;
 	else
 		return cec_dev->sendframe(cec_dev->hdmi, frame);
@@ -47,7 +46,7 @@ static void cecworkfunc(struct work_struct *work)
 		cecreadframe(&list_node->cecframe);
 		if (cec_dev->enable) {
 			mutex_lock(&cec_dev->cec_lock);
-			list_add_tail(&(list_node->framelist),
+			list_add_tail(&list_node->framelist,
 				      &cec_dev->ceclist);
 			sysfs_notify(&cec_dev->device.this_device->kobj,
 				     NULL, "stat");
@@ -120,7 +119,7 @@ static ssize_t cec_enable_store(struct device *dev,
 {
 	int ret;
 
-	ret = kstrtoint(buf, 0, &(cec_dev->enable));
+	ret = kstrtoint(buf, 0, &cec_dev->enable);
 	return count;
 }
 
@@ -136,7 +135,7 @@ static ssize_t cec_phy_store(struct device *dev,
 {
 	int ret;
 
-	ret = kstrtoint(buf, 0, &(cec_dev->address_phy));
+	ret = kstrtoint(buf, 0, &cec_dev->address_phy);
 	return count;
 }
 
@@ -152,7 +151,7 @@ static ssize_t cec_logic_store(struct device *dev,
 {
 	int ret;
 
-	ret = kstrtoint(buf, 0, &(cec_dev->address_logic));
+	ret = kstrtoint(buf, 0, &cec_dev->address_logic);
 	return count;
 }
 
@@ -207,10 +206,10 @@ static long cec_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		ret = copy_from_user(&cec_dev->enable, argp, sizeof(int));
 		break;
 	case HDMI_IOCTL_CECPHY:
-		ret = copy_to_user(argp, &(cec_dev->address_phy), sizeof(int));
+		ret = copy_to_user(argp, &cec_dev->address_phy, sizeof(int));
 		break;
 	case HDMI_IOCTL_CECLOGIC:
-		ret = copy_to_user(argp, &(cec_dev->address_logic),
+		ret = copy_to_user(argp, &cec_dev->address_logic,
 				   sizeof(int));
 		break;
 	case HDMI_IOCTL_CECREAD:
@@ -228,7 +227,7 @@ static long cec_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	case HDMI_IOCTL_CECCLEARLA:
 		break;
 	case HDMI_IOCTL_CECWAKESTATE:
-		ret = copy_to_user(argp, &(cec_dev->hdmi->sleep), sizeof(int));
+		ret = copy_to_user(argp, &cec_dev->hdmi->sleep, sizeof(int));
 		break;
 
 	default:
@@ -265,7 +264,7 @@ int rockchip_hdmi_cec_init(struct hdmi *hdmi,
 	cec_dev->readframe = readframe;
 	cec_dev->setceclogicaddr = setceclogicaddr;
 	cec_dev->workqueue = create_singlethread_workqueue("hdmi-cec");
-	if (cec_dev->workqueue == NULL) {
+	if (!cec_dev->workqueue) {
 		pr_err("HDMI CEC: create workqueue failed.\n");
 		return -1;
 	}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c
index 8a4fa4816500..1696c0405965 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-core.c
@@ -54,7 +54,7 @@ static void hdmi_send_uevent(struct hdmi *hdmi, int uevent)
 
 	envp[0] = "INTERFACE=HDMI";
 	envp[1] = kmalloc(32, GFP_KERNEL);
-	if (envp[1] == NULL)
+	if (!envp[1])
 		return;
 	sprintf(envp[1], "SCREEN=%d", hdmi->ddev->property);
 	envp[2] = NULL;
@@ -78,7 +78,7 @@ static inline void hdmi_wq_set_audio(struct hdmi *hdmi)
 
 static void hdmi_wq_set_video(struct hdmi *hdmi)
 {
-	struct hdmi_video *video = &(hdmi->video);
+	struct hdmi_video *video = &hdmi->video;
 	int	deepcolor;
 
 	DBG("%s\n", __func__);
@@ -146,14 +146,14 @@ static void hdmi_wq_parse_edid(struct hdmi *hdmi)
 {
 	struct hdmi_edid *pedid;
 
-	int rc = HDMI_ERROR_SUCESS, extendblock = 0, i, trytimes;
+	int rc = HDMI_ERROR_SUCCESS, extendblock = 0, i, trytimes;
 
-	if (hdmi == NULL)
+	if (!hdmi)
 		return;
 
 	DBG("%s\n", __func__);
 
-	pedid = &(hdmi->edid);
+	pedid = &hdmi->edid;
 	fb_destroy_modelist(&pedid->modelist);
 	memset(pedid, 0, sizeof(struct hdmi_edid));
 	INIT_LIST_HEAD(&pedid->modelist);
@@ -164,7 +164,7 @@ static void hdmi_wq_parse_edid(struct hdmi *hdmi)
 		goto out;
 	}
 
-	if (hdmi->ops->getedid == NULL) {
+	if (!hdmi->ops->getedid) {
 		rc = HDMI_ERROR_FALSE;
 		goto out;
 	}
@@ -195,7 +195,7 @@ static void hdmi_wq_parse_edid(struct hdmi *hdmi)
 
 	for (i = 1; (i < extendblock + 1) && (i < HDMI_MAX_EDID_BLOCK); i++) {
 		pedid->raw[i] = kmalloc(HDMI_EDID_BLOCK_SIZE, GFP_KERNEL);
-		if (pedid->raw[i] == NULL) {
+		if (!pedid->raw[i]) {
 			dev_err(hdmi->dev,
 				"[%s] can not allocate memory for edid buff.\n",
 				__func__);
@@ -243,7 +243,7 @@ static void hdmi_wq_insert(struct hdmi *hdmi)
 		/*hdmi->autoset = 0;*/
 		hdmi_wq_set_video(hdmi);
 		#ifdef CONFIG_SWITCH
-		switch_set_state(&(hdmi->switchdev), 1);
+		switch_set_state(&hdmi->switchdev, 1);
 		#endif
 		hdmi_wq_set_audio(hdmi);
 		hdmi_wq_set_output(hdmi, hdmi->mute);
@@ -271,7 +271,7 @@ static void hdmi_wq_remove(struct hdmi *hdmi)
 		rk_fb_switch_screen(&screen, 0, hdmi->lcdc->id);
 	}
 	#ifdef CONFIG_SWITCH
-	switch_set_state(&(hdmi->switchdev), 0);
+	switch_set_state(&hdmi->switchdev, 0);
 	#endif
 	list_for_each_safe(pos, n, &hdmi->edid.modelist) {
 		list_del(pos);
@@ -443,7 +443,6 @@ static void hdmi_work_queue(struct work_struct *work)
 			hdmi->ops->hdcp_auth2nd(hdmi);
 		break;
 	default:
-		pr_err("HDMI: hdmi_work_queue() unkown event\n");
 		break;
 	}
 
@@ -464,7 +463,7 @@ struct hdmi *rockchip_hdmi_register(struct hdmi_property *property,
 	char name[32];
 	int i;
 
-	if (property == NULL || ops == NULL) {
+	if (!property || !ops) {
 		pr_err("HDMI: %s invalid parameter\n", __func__);
 		return NULL;
 	}
@@ -528,12 +527,12 @@ struct hdmi *rockchip_hdmi_register(struct hdmi_property *property,
 	memset(name, 0, 32);
 	sprintf(name, "hdmi-%s", hdmi->property->name);
 	hdmi->workqueue = create_singlethread_workqueue(name);
-	if (hdmi->workqueue == NULL) {
+	if (!hdmi->workqueue) {
 		pr_err("HDMI,: create workqueue failed.\n");
 		goto err_create_wq;
 	}
 	hdmi->ddev = hdmi_register_display_sysfs(hdmi, NULL);
-	if (hdmi->ddev == NULL) {
+	if (!hdmi->ddev) {
 		pr_err("HDMI : register display sysfs failed.\n");
 		goto err_register_display;
 	}
@@ -547,7 +546,7 @@ struct hdmi *rockchip_hdmi_register(struct hdmi_property *property,
 		memset((char *)hdmi->switchdev.name, 0, 32);
 		sprintf((char *)hdmi->switchdev.name, "hdmi%d", hdmi->id);
 	}
-	switch_dev_register(&(hdmi->switchdev));
+	switch_dev_register(&hdmi->switchdev);
 	#endif
 
 	ref_info[i].hdmi = hdmi;
@@ -567,7 +566,7 @@ void rockchip_hdmi_unregister(struct hdmi *hdmi)
 		flush_workqueue(hdmi->workqueue);
 		destroy_workqueue(hdmi->workqueue);
 		#ifdef CONFIG_SWITCH
-		switch_dev_unregister(&(hdmi->switchdev));
+		switch_dev_unregister(&hdmi->switchdev);
 		#endif
 		hdmi_unregister_display_sysfs(hdmi);
 		fb_destroy_modelist(&hdmi->edid.modelist);
@@ -598,7 +597,7 @@ int hdmi_config_audio(struct hdmi_audio	*audio)
 	int i;
 	struct hdmi *hdmi;
 
-	if (audio == NULL)
+	if (!audio)
 		return HDMI_ERROR_FALSE;
 
 	for (i = 0; i < HDMI_MAX_ID; i++) {
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c
index 4c86d2461120..1025433ebcd8 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-edid.c
@@ -55,8 +55,8 @@ static int hdmi_edid_parse_dtd(unsigned char *block, struct fb_videomode *mode)
 		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
 	if (VSYNC_POSITIVE)
 		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
-	mode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *
-				     (V_ACTIVE + V_BLANKING));
+	mode->refresh = PIXEL_CLOCK / ((H_ACTIVE + H_BLANKING) *
+				       (V_ACTIVE + V_BLANKING));
 	if (INTERLACED) {
 		mode->yres *= 2;
 		mode->upper_margin *= 2;
@@ -68,7 +68,7 @@ static int hdmi_edid_parse_dtd(unsigned char *block, struct fb_videomode *mode)
 
 	EDBG("<<<<<<<<Detailed Time>>>>>>>>>\n");
 	EDBG("%d KHz Refresh %d Hz",
-	     PIXEL_CLOCK/1000, mode->refresh);
+	     PIXEL_CLOCK / 1000, mode->refresh);
 	EDBG("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
 	     H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
 	EDBG("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
@@ -83,7 +83,7 @@ int hdmi_edid_parse_base(unsigned char *buf,
 {
 	int rc = E_HDMI_EDID_SUCCESS;
 
-	if (buf == NULL || extend_num == NULL)
+	if (!buf || !extend_num)
 		return E_HDMI_EDID_PARAM;
 
 	*extend_num = buf[0x7e];
@@ -114,7 +114,7 @@ int hdmi_edid_parse_base(unsigned char *buf,
 	}
 
 	pedid->specs = kzalloc(sizeof(*pedid->specs), GFP_KERNEL);
-	if (pedid->specs == NULL)
+	if (!pedid->specs)
 		return E_HDMI_EDID_NOMEMORY;
 
 	fb_edid_to_monspecs(buf, pedid->specs);
@@ -152,17 +152,18 @@ static int hdmi_edid_parse_cea_sad(unsigned char *buf, struct hdmi_edid *pedid)
 	int i, count;
 
 	count = buf[0] & 0x1F;
-	pedid->audio = kmalloc((count/3)*sizeof(struct hdmi_audio), GFP_KERNEL);
-	if (pedid->audio == NULL)
+	pedid->audio = kmalloc((count / 3) * sizeof(struct hdmi_audio),
+			       GFP_KERNEL);
+	if (!pedid->audio)
 		return E_HDMI_EDID_NOMEMORY;
 
-	pedid->audio_num = count/3;
+	pedid->audio_num = count / 3;
 	for (i = 0; i < pedid->audio_num; i++) {
-		pedid->audio[i].type = (buf[1 + i*3] >> 3) & 0x0F;
-		pedid->audio[i].channel = (buf[1 + i*3] & 0x07) + 1;
-		pedid->audio[i].rate = buf[1 + i*3 + 1];
+		pedid->audio[i].type = (buf[1 + i * 3] >> 3) & 0x0F;
+		pedid->audio[i].channel = (buf[1 + i * 3] & 0x07) + 1;
+		pedid->audio[i].rate = buf[1 + i * 3 + 1];
 		if (pedid->audio[i].type == HDMI_AUDIO_LPCM)
-			pedid->audio[i].word_length = buf[1 + i*3 + 2];
+			pedid->audio[i].word_length = buf[1 + i * 3 + 2];
 	}
 	return E_HDMI_EDID_SUCCESS;
 }
@@ -257,6 +258,7 @@ static int hdmi_edid_parse_3dinfo(unsigned char *buf, struct list_head *head)
 
 	return 0;
 }
+
 static int hdmi_edmi_parse_vsdb(unsigned char *buf, struct hdmi_edid *pedid,
 				int cur_offset, int IEEEOUI)
 {
@@ -268,7 +270,7 @@ static int hdmi_edmi_parse_vsdb(unsigned char *buf, struct hdmi_edid *pedid,
 		pedid->sink_hdmi = 1;
 		pedid->cecaddress = buf[cur_offset + 5];
 		pedid->cecaddress |= buf[cur_offset + 4] << 8;
-		EDBG("[CEA] CEC Physical addres is 0x%08x.\n",
+		EDBG("[CEA] CEC Physical address is 0x%08x.\n",
 		     pedid->cecaddress);
 		if (count > 6)
 			pedid->deepcolor = (buf[cur_offset + 6] >> 3) & 0x0F;
@@ -305,19 +307,19 @@ static int hdmi_edmi_parse_vsdb(unsigned char *buf, struct hdmi_edid *pedid,
 				buf[cur_offset + 5] * 5000000;
 			EDBG("[CEA] maxtmdsclock is %d.\n",
 			     pedid->maxtmdsclock);
-			pedid->scdc_present = buf[cur_offset+6] >> 7;
+			pedid->scdc_present = buf[cur_offset + 6] >> 7;
 			pedid->rr_capable =
-				(buf[cur_offset+6]&0x40) >> 6;
+				(buf[cur_offset + 6] & 0x40) >> 6;
 			pedid->lte_340mcsc_scramble =
-				(buf[cur_offset+6]&0x08) >> 3;
+				(buf[cur_offset + 6] & 0x08) >> 3;
 			pedid->independent_view =
-				(buf[cur_offset+6]&0x04) >> 2;
+				(buf[cur_offset + 6] & 0x04) >> 2;
 			pedid->dual_view =
-				(buf[cur_offset+6]&0x02) >> 1;
+				(buf[cur_offset + 6] & 0x02) >> 1;
 			pedid->osd_disparity_3d =
-				buf[cur_offset+6] & 0x01;
+				buf[cur_offset + 6] & 0x01;
 			pedid->deepcolor_420 =
-				(buf[cur_offset+7] & 0x7) << 1;
+				(buf[cur_offset + 7] & 0x7) << 1;
 			break;
 		default:
 			pr_info("hf_vsdb_version = %d\n",
@@ -367,7 +369,7 @@ static int hdmi_edid_parse_extensions_cea(unsigned char *buf,
 	unsigned int ddc_offset, native_dtd_num, cur_offset = 4;
 	unsigned int tag, IEEEOUI = 0, count, i;
 
-	if (buf == NULL)
+	if (!buf)
 		return E_HDMI_EDID_PARAM;
 
 	/* Check ces extension version */
@@ -440,7 +442,7 @@ static int hdmi_edid_parse_extensions_cea(unsigned char *buf,
 				break;
 			case 0x0f:
 				EDBG("[CEA] YCBCR 4:2:0 Capability Map Data\n");
-				hdmi_edid_parse_yuv420cmdb(&buf[cur_offset+2],
+				hdmi_edid_parse_yuv420cmdb(&buf[cur_offset + 2],
 							   count,
 							   &pedid->modelist);
 				pedid->ycbcr420 = 1;
@@ -453,13 +455,12 @@ static int hdmi_edid_parse_extensions_cea(unsigned char *buf,
 		}
 		cur_offset += (buf[cur_offset] & 0x1F) + 1;
 	}
-#if 1
-{
+
 	/* Parse DTD */
 	struct fb_videomode *vmode =
 		kmalloc(sizeof(struct fb_videomode), GFP_KERNEL);
 
-	if (vmode == NULL)
+	if (!vmode)
 		return E_HDMI_EDID_SUCCESS;
 	while (ddc_offset < HDMI_EDID_BLOCK_SIZE - 2) {
 		if (!buf[ddc_offset] && !buf[ddc_offset + 1])
@@ -470,7 +471,7 @@ static int hdmi_edid_parse_extensions_cea(unsigned char *buf,
 		ddc_offset += 18;
 	}
 	kfree(vmode);
-}
+
 #endif
 	return E_HDMI_EDID_SUCCESS;
 }
@@ -479,7 +480,7 @@ int hdmi_edid_parse_extensions(unsigned char *buf, struct hdmi_edid *pedid)
 {
 	int rc;
 
-	if (buf == NULL || pedid == NULL)
+	if (!buf || !pedid)
 		return E_HDMI_EDID_PARAM;
 
 	/* Checksum */
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c
index 1842f3f5f39d..9228fd134387 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-lcdc.c
@@ -778,7 +778,7 @@ static int hdmi_set_info(struct rk_screen *screen, struct hdmi *hdmi)
 	int i, vic;
 	struct fb_videomode *mode;
 
-	if (screen == NULL || hdmi == NULL)
+	if (!screen || !hdmi)
 		return HDMI_ERROR_FALSE;
 
 	if (hdmi->vic == 0)
@@ -816,7 +816,7 @@ static int hdmi_set_info(struct rk_screen *screen, struct hdmi *hdmi)
 			screen->face = hdmi_mode[i].interface;
 	}
 	screen->pixelrepeat = hdmi_mode[i].pixelrepeat - 1;
-	mode = (struct fb_videomode *)&(hdmi_mode[i].mode);
+	mode = (struct fb_videomode *)&hdmi_mode[i].mode;
 
 	screen->mode = *mode;
 	if (hdmi->video.format_3d == HDMI_3D_FRAME_PACKING) {
@@ -906,11 +906,12 @@ int hdmi_find_best_mode(struct hdmi *hdmi, int vic)
 			return hdmi->property->defaultmode;
 	}
 
-	if (modelist != NULL)
+	if (modelist)
 		return modelist->vic;
 	else
 		return 0;
 }
+
 /**
  * hdmi_set_lcdc: switch lcdc mode to required video mode
  * @hdmi:
@@ -1026,7 +1027,7 @@ static int hdmi_add_videomode(const struct fb_videomode *mode,
 	int i, found = 0;
 
 	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-		m = (struct fb_videomode *)&(hdmi_mode[i].mode);
+		m = (struct fb_videomode *)&hdmi_mode[i].mode;
 		if (fb_mode_is_equal(m, mode)) {
 			found = 1;
 			break;
@@ -1111,7 +1112,7 @@ static void hdmi_sort_modelist(struct hdmi_edid *edid, int feature)
 					modelist->mode.flag = 1;
 
 				compare = 1;
-				m = (struct fb_videomode *)&(modelist->mode);
+				m = (struct fb_videomode *)&modelist->mode;
 				list_for_each(pos_new, &head_new) {
 					modelist_new =
 					list_entry(pos_new,
@@ -1151,7 +1152,7 @@ static void hdmi_sort_modelist(struct hdmi_edid *edid, int feature)
 /**
  * hdmi_ouputmode_select - select hdmi transmitter output mode: hdmi or dvi?
  * @hdmi: handle of hdmi
- * @edid_ok: get EDID data success or not, HDMI_ERROR_SUCESS means success.
+ * @edid_ok: get EDID data success or not, HDMI_ERROR_SUCCESS means success.
  */
 int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok)
 {
@@ -1160,7 +1161,7 @@ int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok)
 	struct fb_videomode *modedb = NULL, *mode = NULL;
 	int i, pixclock, feature = hdmi->property->feature;
 
-	if (edid_ok != HDMI_ERROR_SUCESS) {
+	if (edid_ok != HDMI_ERROR_SUCCESS) {
 		dev_err(hdmi->dev, "warning: EDID error, assume sink as HDMI !!!!");
 		hdmi->edid.status = -1;
 		hdmi->edid.sink_hdmi = 1;
@@ -1202,7 +1203,7 @@ int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok)
 		}
 
 		for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-			mode = (struct fb_videomode *)&(hdmi_mode[i].mode);
+			mode = (struct fb_videomode *)&hdmi_mode[i].mode;
 			if (modedb) {
 				if ((mode->pixclock < specs->dclkmin) ||
 				    (mode->pixclock > specs->dclkmax) ||
@@ -1255,7 +1256,7 @@ int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok)
 		hdmi_sort_modelist(&hdmi->edid, hdmi->property->feature);
 	}
 
-	return HDMI_ERROR_SUCESS;
+	return HDMI_ERROR_SUCCESS;
 }
 
 /**
@@ -1270,7 +1271,7 @@ int hdmi_videomode_to_vic(struct fb_videomode *vmode)
 	int i = 0;
 
 	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-		mode = (struct fb_videomode *)&(hdmi_mode[i].mode);
+		mode = (struct fb_videomode *)&hdmi_mode[i].mode;
 		if (vmode->vmode == mode->vmode &&
 		    vmode->refresh == mode->refresh &&
 		    vmode->xres == mode->xres &&
@@ -1302,7 +1303,7 @@ const struct hdmi_video_timing *hdmi_vic2timing(int vic)
 
 	for (i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
 		if (hdmi_mode[i].vic == vic || hdmi_mode[i].vic_2nd == vic)
-			return &(hdmi_mode[i]);
+			return &hdmi_mode[i];
 	}
 	return NULL;
 }
@@ -1364,6 +1365,6 @@ void hdmi_init_modelist(struct hdmi *hdmi)
 		    hdmi_mode[i].mode.xres == 720 &&
 		    (hdmi_mode[i].mode.vmode & FB_VMODE_INTERLACED))
 			continue;
-		hdmi_add_videomode(&(hdmi_mode[i].mode), head);
+		hdmi_add_videomode(&hdmi_mode[i].mode, head);
 	}
 }
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c b/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c
index 5449f50617a7..94812c17c51a 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi-sysfs.c
@@ -51,7 +51,7 @@ static int hdmi_set_mode(struct rk_display_device *device,
 			container_of(mode, struct display_modelist, mode);
 	int vic = 0;
 
-	if (mode == NULL) {
+	if (!mode) {
 		hdmi->autoset = 1;
 		vic = hdmi_find_best_mode(hdmi, 0);
 	} else {
@@ -73,13 +73,13 @@ static int hdmi_get_mode(struct rk_display_device *device,
 	struct hdmi *hdmi = device->priv_data;
 	struct fb_videomode *vmode;
 
-	if (mode == NULL)
+	if (!mode)
 		return -1;
 
 	if (hdmi->vic) {
 		vmode = (struct fb_videomode *)
 			hdmi_vic_to_videomode(hdmi->vic);
-		if (unlikely(vmode == NULL))
+		if (unlikely(!vmode))
 			return -1;
 		*mode = *vmode;
 		if (hdmi->vic & HDMI_VIDEO_YUV420)
@@ -167,7 +167,7 @@ static int hdmi_get_edidaudioinfo(struct rk_display_device *device,
 	memset(audioinfo, 0x00, len);
 	/*printk("hdmi:edid: audio_num: %d\n", hdmi->edid.audio_num);*/
 	for (i = 0; i < hdmi->edid.audio_num; i++) {
-		audio = &(hdmi->edid.audio[i]);
+		audio = &hdmi->edid.audio[i];
 		if (audio->type < 1 || audio->type > HDMI_AUDIO_WMA_PRO) {
 			pr_info("audio type: unsupported.");
 			continue;
@@ -175,7 +175,7 @@ static int hdmi_get_edidaudioinfo(struct rk_display_device *device,
 		size = strlen(audioformatstr[audio->type]);
 		memcpy(audioinfo, audioformatstr[audio->type], size);
 		audioinfo[size] = ',';
-		audioinfo += (size+1);
+		audioinfo += (size + 1);
 	}
 	return 0;
 }
@@ -247,7 +247,6 @@ static int hdmi_set_color(struct rk_display_device *device,
 		if (hdmi->colorimetry != value)
 			hdmi->colorimetry = value;
 	} else {
-		pr_err("%s unkown event\n", __func__);
 		return -1;
 	}
 	if (hdmi->hotplug == HDMI_HPD_ACTIVED)
@@ -300,12 +299,12 @@ static int hdmi_get_monspecs(struct rk_display_device *device,
 		return -1;
 
 	if (hdmi->edid.specs)
-		*monspecs = *(hdmi->edid.specs);
+		*monspecs = *hdmi->edid.specs;
 	return 0;
 }
 
 /**
- * hdmi_show_sink_info: show hdmi sink device infomation
+ * hdmi_show_sink_info: show hdmi sink device information
  * @hdmi: handle of hdmi
  */
 static int hdmi_show_sink_info(struct hdmi *hdmi, char *buf, int len)
@@ -407,7 +406,7 @@ static int hdmi_show_sink_info(struct hdmi *hdmi, char *buf, int len)
 	lens += snprintf(buf + lens, PAGE_SIZE - lens,
 			 "\nSupport audio type:");
 	for (i = 0; i < hdmi->edid.audio_num; i++) {
-		audio = &(hdmi->edid.audio[i]);
+		audio = &hdmi->edid.audio[i];
 		switch (audio->type) {
 		case HDMI_AUDIO_LPCM:
 			lens += snprintf(buf + lens, PAGE_SIZE - lens,
@@ -467,7 +466,7 @@ static int hdmi_show_sink_info(struct hdmi *hdmi, char *buf, int len)
 			break;
 		default:
 			lens += snprintf(buf + lens, PAGE_SIZE - lens,
-					 " Unkown");
+					 " Unknown");
 			break;
 		}
 		lens += snprintf(buf + lens, PAGE_SIZE - lens,
@@ -497,7 +496,7 @@ static int hdmi_show_sink_info(struct hdmi *hdmi, char *buf, int len)
 			lens += snprintf(buf + lens, PAGE_SIZE - lens,
 					 " 192000");
 		lens += snprintf(buf + lens, PAGE_SIZE - lens,
-				 "\nSupport audio word lenght:");
+				 "\nSupport audio word length:");
 		if (audio->rate & HDMI_AUDIO_WORD_LENGTH_16bit)
 			lens += snprintf(buf + lens, PAGE_SIZE - lens,
 					 " 16bit");
@@ -520,9 +519,9 @@ static int hdmi_get_debug(struct rk_display_device *device, char *buf)
 
 	if (!hdmi)
 		return 0;
-	len += snprintf(buf+len, PAGE_SIZE - len, "EDID status:%s\n",
+	len += snprintf(buf + len, PAGE_SIZE - len, "EDID status:%s\n",
 			hdmi->edid.status ? "False" : "Okay");
-	len += snprintf(buf+len, PAGE_SIZE - len, "Raw Data:");
+	len += snprintf(buf + len, PAGE_SIZE - len, "Raw Data:");
 	for (i = 0; i < HDMI_MAX_EDID_BLOCK; i++) {
 		if (!hdmi->edid.raw[i])
 			break;
@@ -531,11 +530,11 @@ static int hdmi_get_debug(struct rk_display_device *device, char *buf)
 			if (j % 16 == 0)
 				len += snprintf(buf + len,
 						PAGE_SIZE - len, "\n");
-			len += snprintf(buf+len, PAGE_SIZE - len, "0x%02x, ",
+			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02x, ",
 					buff[j]);
 		}
 	}
-	len += snprintf(buf+len, PAGE_SIZE, "\n");
+	len += snprintf(buf + len, PAGE_SIZE, "\n");
 	if (!hdmi->edid.status)
 		len += hdmi_show_sink_info(hdmi, buf, len);
 	return len;
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmi.h b/drivers/video/rockchip/hdmi/rockchip-hdmi.h
index 5f1460a0832b..e061fd6e3948 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmi.h
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmi.h
@@ -9,17 +9,17 @@
 #endif
 
 #define HDMI_VIDEO_NORMAL				0
-#define HDMI_VIDEO_DMT					(1 << 9)
-#define HDMI_VIDEO_YUV420				(1 << 10)
+#define HDMI_VIDEO_DMT					BIT(9)
+#define HDMI_VIDEO_YUV420				BIT(10)
 #define HDMI_VIC_MASK					(0xFF)
 #define HDMI_TYPE_MASK					(0xFF << 8)
 #define HDMI_MAX_ID					4
 
-#define HDMI_UBOOT_NOT_INIT				(1 << 16)
+#define HDMI_UBOOT_NOT_INIT				BIT(16)
 #define HDMI_UBOOT_VIC_MASK				0xFFFF
 
 /* HDMI video information code according CEA-861-F */
-enum hdmi_video_infomation_code {
+enum hdmi_video_information_code {
 	HDMI_640X480P_60HZ = 1,
 	HDMI_720X480P_60HZ_4_3,
 	HDMI_720X480P_60HZ_16_9,
@@ -247,7 +247,7 @@ enum hdmi_mute_status {
 
 /* HDMI Error Code */
 enum hdmi_error_code {
-	HDMI_ERROR_SUCESS = 0,
+	HDMI_ERROR_SUCCESS = 0,
 	HDMI_ERROR_FALSE,
 	HDMI_ERROR_I2C,
 	HDMI_ERROR_EDID,
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c
index 9ce83b6b4d88..c2b80280a0bf 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.c
@@ -204,6 +204,7 @@ static struct hdmi_property rockchip_hdmiv1_property = {
 	.videosrc = DISPLAY_SOURCE_LCDC0,
 	.display = DISPLAY_MAIN,
 };
+
 static struct hdmi_ops rockchip_hdmiv1_ops;
 
 #if defined(CONFIG_OF)
@@ -262,7 +263,6 @@ static int rockchip_hdmiv1_parse_dt(struct hdmi_dev *hdmi_dev)
 MODULE_DEVICE_TABLE(of, rockchip_hdmiv1_dt_ids);
 #endif
 
-
 static int rockchip_hdmiv1_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -321,7 +321,7 @@ static int rockchip_hdmiv1_probe(struct platform_device *pdev)
 						    SUPPORT_480I_576I;
 	hdmi_dev->hdmi = rockchip_hdmi_register(&rockchip_hdmiv1_property,
 						&rockchip_hdmiv1_ops);
-	if (hdmi_dev->hdmi == NULL) {
+	if (!hdmi_dev->hdmi) {
 		dev_err(&pdev->dev, "register hdmi device failed\n");
 		ret = -ENOMEM;
 		goto failed;
@@ -415,7 +415,6 @@ static void rockchip_hdmiv1_shutdown(struct platform_device *pdev)
 	dev_info(hdmi_drv->dev, "rk hdmi shut down.\n");
 }
 
-
 static struct platform_driver rockchip_hdmiv1_driver = {
 	.probe = rockchip_hdmiv1_probe,
 	.remove = rockchip_hdmiv1_remove,
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h
index 7926ff8684a9..488f80980595 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1.h
@@ -29,7 +29,7 @@ struct hdmi_dev {
 	int			enable;
 	unsigned char		clk_disable;
 	unsigned char		clk_on;
-	spinlock_t		reg_lock;
+	spinlock_t		reg_lock;	/* lock for clk */
 
 	unsigned int		tmdsclk;
 	unsigned int		pixelrepeat;
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c
index b9c7db7c7b5b..6fdff1d5cef2 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_cec.c
@@ -18,7 +18,7 @@ static int rockchip_hdmiv1_cec_read_frame(struct hdmi *hdmi,
 	char *data = (char *)frame;
 	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
 
-	if (frame == NULL)
+	if (!frame)
 		return -1;
 
 	hdmi_readl(hdmi_dev, CEC_RX_LENGTH, &length);
@@ -69,7 +69,7 @@ static int rockchip_hdmiv1_cec_send_frame(struct hdmi *hdmi,
 	CECDBG("end wait bus free,start tx,busfree=%d\n", cec.busfree);
 	/*Start TX*/
 	cec.tx_done = 0;
-	hdmi_writel(hdmi_dev, CEC_CTRL, m_BUSFREETIME_ENABLE|m_START_TX);
+	hdmi_writel(hdmi_dev, CEC_CTRL, m_BUSFREETIME_ENABLE | m_START_TX);
 	if (wait_event_interruptible_timeout(cec.wait,
 					     cec.tx_done != 0,
 					     msecs_to_jiffies(100)))
@@ -88,17 +88,6 @@ void rockchip_hdmiv1_cec_setcecla(struct hdmi *hdmi, int ceclgaddr)
 {
 	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
 
-	/*for(i = 0; i < 3; i++) {
-		if(Cec_Ping(la_player[i]) == 1) {
-			cec.address_logic = la_player[i];
-			break;
-		}
-	}
-	if(i == 3)
-		return -1;
-	//Broadcast our physical address.
-	GPIO_CecSendMessage(CECOP_GET_MENU_LANGUAGE,CEC_LOGADDR_TV);
-	msleep(100);*/
 	CECDBG("CEC: %s\n", __func__);
 	hdmi_writel(hdmi_dev, CEC_LOGICADDR, ceclgaddr);
 }
@@ -150,7 +139,7 @@ void rockchip_hdmiv1_cec_init(struct hdmi *hdmi)
 		hdmi_writel(hdmi_dev, CEC_TX_INT, 0xFF);
 		hdmi_writel(hdmi_dev, CEC_RX_INT, 0xFF);
 
-		CECDBG(KERN_ERR "CEC: rockchip_hdmiv1_cec_init sucess\n");
+		CECDBG(KERN_ERR "CEC: rockchip_hdmiv1_cec_init success\n");
 		rockchip_hdmi_cec_init(hdmi,
 				       rockchip_hdmiv1_cec_send_frame,
 				       rockchip_hdmiv1_cec_read_frame,
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c
index c8f80e5cfcaa..6032fdc8fce0 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.c
@@ -15,7 +15,7 @@ static struct hdcp *hdcp;
 
 static void hdcp_work_queue(struct work_struct *work);
 
-#define AUTH_TIMEOUT (2*HZ)
+#define AUTH_TIMEOUT (2 * HZ)
 static struct timer_list auth_timer;
 static int timer_state;
 
@@ -85,7 +85,7 @@ static void rockchip_hdmiv1_hdcp_disable(struct hdmi_dev *hdmi_dev)
 			     m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_SYS);
 	}
 
-	/* Diable HDCP Interrupt*/
+	/* Disable HDCP Interrupt */
 	hdmi_writel(hdmi_dev, HDCP_INT_MASK1, 0x00);
 	/* Stop and Reset HDCP*/
 	hdmi_msk_reg(hdmi_dev, HDCP_CTRL1,
@@ -146,7 +146,7 @@ static int rockchip_hdmiv1_hdcp_start_authentication(struct hdmi_dev *hdmi_dev)
 	int tmds_clk;
 
 	tmds_clk = hdmi_dev->tmdsclk;
-	if (hdcp->keys == NULL) {
+	if (!hdcp->keys) {
 		HDCP_WARN("HDCP: key is not loaded\n");
 		return HDCP_KEY_ERR;
 	}
@@ -175,7 +175,7 @@ static int rockchip_hdmiv1_hdcp_start_authentication(struct hdmi_dev *hdmi_dev)
 		retry++;
 	}
 	/*Config DDC bus clock: ddc_clk = reg_clk/4*(reg 0x4c 0x4b)*/
-	retry = hdmi_dev->hclk_rate/(HDCP_DDC_CLK << 2);
+	retry = hdmi_dev->hclk_rate / (HDCP_DDC_CLK << 2);
 	hdmi_writel(hdmi_dev, DDC_CLK_L, retry & 0xFF);
 	hdmi_writel(hdmi_dev, DDC_CLK_H, (retry >> 8) & 0xFF);
 	hdmi_writel(hdmi_dev, HDCP_CTRL2, 0x67);
@@ -399,6 +399,7 @@ static void hdcp_wq_start_authentication(void)
 		hdcp->hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
 	}
 }
+
 #if 0
 /*-----------------------------------------------------------------------------
  * Function: hdcp_wq_check_bksv
@@ -426,10 +427,10 @@ static void hdcp_wq_check_bksv(void)
 }
 #endif
 /*-----------------------------------------------------------------------------
- * Function: hdcp_wq_authentication_sucess
+ * Function: hdcp_wq_authentication_success
  *-----------------------------------------------------------------------------
  */
-static void hdcp_wq_authentication_sucess(void)
+static void hdcp_wq_authentication_success(void)
 {
 	hdcp->auth_state = 1;
 	if (timer_state == 1) {
@@ -539,11 +540,11 @@ static void hdcp_work_queue(struct work_struct *work)
 			HDCP_WARN("HDCP: Ri check failure\n");
 			hdcp_wq_authentication_failure();
 		} else if (event == HDCP_AUTH_PASS_EVENT) {
-			hdcp_wq_authentication_sucess();
+			hdcp_wq_authentication_success();
 		}
 		break;
 	default:
-		HDCP_WARN("HDCP: error - unknow HDCP state\n");
+		HDCP_WARN("HDCP: error - unknown HDCP state\n");
 		break;
 	}
 	kfree(hdcp_w);
@@ -671,13 +672,13 @@ static void hdcp_load_keys_cb(const struct firmware *fw, void *context)
 		}
 		hdcp->invalidkeys =
 			kmalloc(fw->size - HDCP_KEY_SIZE, GFP_KERNEL);
-		if (hdcp->invalidkeys == NULL) {
+		if (!hdcp->invalidkeys) {
 			pr_err("HDCP: can't allocated space for invalid keys\n");
 			return;
 		}
 		memcpy(hdcp->invalidkeys, fw->data +
 		       HDCP_KEY_SIZE, fw->size - HDCP_KEY_SIZE);
-		hdcp->invalidkey = (fw->size - HDCP_KEY_SIZE)/5;
+		hdcp->invalidkey = (fw->size - HDCP_KEY_SIZE) / 5;
 		HDCP_WARN("HDCP: loaded hdcp invalid key success\n");
 	}
 }
@@ -699,7 +700,7 @@ static ssize_t hdcp_enable_write(struct device *device,
 {
 	int enable;
 
-	if (hdcp == NULL)
+	if (!hdcp)
 		return -EINVAL;
 	if (kstrtoint(buf, 0, &enable))
 		return -EINVAL;
@@ -721,7 +722,7 @@ static ssize_t hdcp_enable_write(struct device *device,
 	return count;
 }
 
-static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR,
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR,
 			 hdcp_enable_read, hdcp_enable_write);
 
 static ssize_t hdcp_trytimes_read(struct device *device,
@@ -741,7 +742,7 @@ static ssize_t hdcp_trytimes_wrtie(struct device *device,
 {
 	int trytimes;
 
-	if (hdcp == NULL)
+	if (!hdcp)
 		return -EINVAL;
 	if (kstrtoint(buf, 0, &trytimes))
 		return -EINVAL;
@@ -750,8 +751,7 @@ static ssize_t hdcp_trytimes_wrtie(struct device *device,
 	return count;
 }
 
-
-static DEVICE_ATTR(trytimes, S_IRUGO|S_IWUSR,
+static DEVICE_ATTR(trytimes, S_IRUGO | S_IWUSR,
 			 hdcp_trytimes_read, hdcp_trytimes_wrtie);
 static struct miscdevice mdev;
 
@@ -792,7 +792,7 @@ int rockchip_hdmiv1_hdcp_init(struct hdmi *hdmi)
 			goto error3;
 	}
 	hdcp->workqueue = create_singlethread_workqueue("hdcp");
-	if (hdcp->workqueue == NULL) {
+	if (!hdcp->workqueue) {
 		HDCP_WARN("HDCP,: create workqueue failed.\n");
 		goto error4;
 	}
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h
index 3fea4c627529..49d1737d06c1 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hdcp.h
@@ -7,8 +7,8 @@
 
 /* Status / error codes */
 #define HDCP_OK			0
-#define HDCP_KEY_ERR	1
-#define HDCP_KSV_ERR	2
+#define HDCP_KEY_ERR		1
+#define HDCP_KSV_ERR		2
 #define HDCP_KEY_VALID		3
 #define HDCP_KEY_INVALID	4
 
@@ -24,14 +24,14 @@
 #define HDCP_WORKQUEUE_SRC	(0x8 << HDCP_SRC_SHIFT)
 
 /* Event */
-#define HDCP_ENABLE_CTL			(HDCP_IOCTL_SRC		| 0)
-#define HDCP_DISABLE_CTL		(HDCP_IOCTL_SRC		| 1)
-#define HDCP_START_FRAME_EVENT	(HDCP_HDMI_SRC		| 2)
-#define HDCP_STOP_FRAME_EVENT	(HDCP_HDMI_SRC		| 3)
-#define HDCP_KSV_LIST_RDY_EVENT	(HDCP_IRQ_SRC		| 4)
-#define HDCP_FAIL_EVENT			(HDCP_IRQ_SRC		| 5)
-#define HDCP_AUTH_PASS_EVENT	(HDCP_IRQ_SRC		| 6)
-#define HDCP_AUTH_REATT_EVENT	(HDCP_WORKQUEUE_SRC	| 7)
+#define HDCP_ENABLE_CTL		(HDCP_IOCTL_SRC	| 0)
+#define HDCP_DISABLE_CTL	(HDCP_IOCTL_SRC	| 1)
+#define HDCP_START_FRAME_EVENT	(HDCP_HDMI_SRC	| 2)
+#define HDCP_STOP_FRAME_EVENT	(HDCP_HDMI_SRC	| 3)
+#define HDCP_KSV_LIST_RDY_EVENT	(HDCP_IRQ_SRC	| 4)
+#define HDCP_FAIL_EVENT		(HDCP_IRQ_SRC	| 5)
+#define HDCP_AUTH_PASS_EVENT	(HDCP_IRQ_SRC	| 6)
+#define HDCP_AUTH_REATT_EVENT	(HDCP_WORKQUEUE_SRC | 7)
 
 /* Key size */
 #define HDCP_KEY_SIZE			308
@@ -44,14 +44,14 @@
 
 /* HDCP Regs */
 #define HDCP_CTRL1				0x52
-	#define m_AUTH_START		(1 << 7)
-	#define m_BKSV_VALID		(1 << 6)
-	#define m_BKSV_INVALID		(1 << 5)
-	#define m_ENCRYPT_ENABLE	(1 << 4)
-	#define m_AUTH_STOP			(1 << 3)
-	#define m_ADVANED_ENABLE	(1 << 2)
-	#define m_HDMI_DVI			(1 << 1)
-	#define m_HDCP_RESET		(1 << 0)
+	#define m_AUTH_START		BIT(7)
+	#define m_BKSV_VALID		BIT(6)
+	#define m_BKSV_INVALID		BIT(5)
+	#define m_ENCRYPT_ENABLE	BIT(4)
+	#define m_AUTH_STOP		BIT(3)
+	#define m_ADVANED_ENABLE	BIT(2)
+	#define m_HDMI_DVI		BIT(1)
+	#define m_HDCP_RESET		BIT(0)
 
 	#define v_AUTH_START(n)		(n << 7)
 	#define v_BKSV_VALID(n)		(n << 6)
@@ -63,13 +63,13 @@
 	#define v_HDCP_RESET(n)		(n << 0)
 
 #define HDCP_CTRL2				0x53
-	#define m_DISABLE_127_CHECK				(1 << 7)
-	#define m_SKIP_BKSV_CHECK				(1 << 6)
-	#define m_ENABLE_PJ_CHECK				(1 << 5)
-	#define m_DISABLE_DEVICE_NUMBER_CHECK	(1 << 4)
-	#define m_DELAY_RI_1_CLK				(1 << 3)
-	#define m_USE_PRESET_AN					(1 << 2)
-	#define m_KEY_COMBINATION				(3 << 0)
+	#define m_DISABLE_127_CHECK			BIT(7)
+	#define m_SKIP_BKSV_CHECK			BIT(6)
+	#define m_ENABLE_PJ_CHECK			BIT(5)
+	#define m_DISABLE_DEVICE_NUMBER_CHECK		BIT(4)
+	#define m_DELAY_RI_1_CLK			BIT(3)
+	#define m_USE_PRESET_AN				BIT(2)
+	#define m_KEY_COMBINATION			(BIT(1) | BIT(0))
 
 	#define v_DISABLE_127_CHECK(n)			(n << 7)
 	#define v_SKIP_BKSV_CHECK(n)			(n << 6)
@@ -80,23 +80,23 @@
 	#define v_KEY_COMBINATION(n)			(n << 0)
 
 #define HDCP_KEY_STATUS			0x54
-	#define m_KEY_READY			(1 << 0)
+	#define m_KEY_READY			BIT(0)
 
 #define HDCP_CTRL_SOFT			0x57
-	#define m_DISABLE_127_CHECK				(1 << 7)
-	#define m_SKIP_BKSV_CHECK				(1 << 6)
-	#define m_NOT_AUTHENTICATED				(1 << 5)
-	#define m_ENCRYPTED						(1 << 4)
-	#define m_ADVANCED_CIPHER				(1 << 3)
+	#define m_DISABLE_127_CHECK			BIT(7)
+	#define m_SKIP_BKSV_CHECK			BIT(6)
+	#define m_NOT_AUTHENTICATED			BIT(5)
+	#define m_ENCRYPTED				BIT(4)
+	#define m_ADVANCED_CIPHER			BIT(3)
 
 #define HDCP_BCAPS_RX			0x58
 #define HDCP_TIMER_100MS		0x63
 #define HDCP_TIMER_5S			0x64
 #define HDCP_ERROR				0x65
-	#define m_DDC_NO_ACK		(1 << 3)
-	#define m_PJ_MISMACH		(1 << 2)
-	#define m_RI_MISMACH		(1 << 1)
-	#define m_BKSV_WRONG		(1 << 0)
+	#define m_DDC_NO_ACK		BIT(3)
+	#define m_PJ_MISMACH		BIT(2)
+	#define m_RI_MISMACH		BIT(1)
+	#define m_BKSV_WRONG		BIT(0)
 
 #define HDCP_KSV_BYTE0			0x66
 #define HDCP_KSV_BYTE1			0x67
@@ -114,21 +114,21 @@
 
 #define HDCP_INT_MASK1			0xc2
 #define HDCP_INT_STATUS1		0xc3
-	#define m_INT_HDCP_ERR		(1 << 7)
-	#define m_INT_BKSV_READY	(1 << 6)
-	#define m_INT_BKSV_UPDATE	(1 << 5)
-	#define m_INT_AUTH_SUCCESS	(1 << 4)
-	#define m_INT_AUTH_READY	(1 << 3)
+	#define m_INT_HDCP_ERR		BIT(7)
+	#define m_INT_BKSV_READY	BIT(6)
+	#define m_INT_BKSV_UPDATE	BIT(5)
+	#define m_INT_AUTH_SUCCESS	BIT(4)
+	#define m_INT_AUTH_READY	BIT(3)
 
 #define HDCP_INT_MASK2			0xc4
 #define HDCP_INT_STATUS2		0xc5
-	#define m_INT_SOFT_MODE_READY			(1 << 7)
-	#define m_INT_AUTH_M0_REDAY				(1 << 6)
-	#define m_INT_1st_FRAME_ARRIVE			(1 << 5)
-	#define m_INT_AN_READY					(1 << 4)
-	#define m_INT_ENCRYPTED					(1 << 2)
-	#define m_INT_NOT_ENCRYPTED_AVMUTE		(1 << 1)
-	#define m_INT_NOT_ENCRYPTED_AVUNMUTE	(1 << 0)
+	#define m_INT_SOFT_MODE_READY			BIT(7)
+	#define m_INT_AUTH_M0_REDAY			BIT(6)
+	#define m_INT_1st_FRAME_ARRIVE			BIT(5)
+	#define m_INT_AN_READY				BIT(4)
+	#define m_INT_ENCRYPTED				BIT(2)
+	#define m_INT_NOT_ENCRYPTED_AVMUTE		BIT(1)
+	#define m_INT_NOT_ENCRYPTED_AVUNMUTE	BIT(0)
 
 enum hdcp_states {
 	HDCP_DISABLED,
@@ -163,7 +163,7 @@ struct hdcp {
 	struct hdcp_keys *keys;
 	int invalidkey;
 	char *invalidkeys;
-	struct mutex lock;
+	struct mutex lock;	/* use for workqueue */
 	struct completion	complete;
 	struct workqueue_struct *workqueue;
 
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c
index 919234b154a6..ac87b3c9ff56 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.c
@@ -81,7 +81,7 @@ static void rockchip_hdmiv1_set_pwr_mode(struct hdmi *hdmi_drv, int mode)
 		hdmi_writel(hdmi_dev, PHY_SYS_CTL, 0x17);
 		break;
 	default:
-		dev_info(hdmi_drv->dev, "unkown rk3036 hdmi pwr mode %d\n",
+		dev_info(hdmi_drv->dev, "unknown rk3036 hdmi pwr mode %d\n",
 			 mode);
 	}
 
@@ -109,7 +109,6 @@ int rockchip_hdmiv1_insert(struct hdmi *hdmi_drv)
 	return 0;
 }
 
-
 int rockchip_hdmiv1_read_edid(struct hdmi *hdmi_drv, int block, u8 *buf)
 {
 	u32 c = 0;
@@ -173,7 +172,7 @@ int rockchip_hdmiv1_read_edid(struct hdmi *hdmi_drv, int block, u8 *buf)
 			if ((checksum & 0xff) == 0) {
 				ret = 0;
 				dev_info(hdmi_drv->dev,
-					 "[%s] edid read sucess\n", __func__);
+					 "[%s] edid read success\n", __func__);
 				break;
 			}
 		}
@@ -339,7 +338,7 @@ static int rockchip_hdmiv1_video_csc(struct hdmi *hdmi_drv,
 
 	coeff = coeff_csc[csc_mode];
 	for (i = 0; i < 24; i++)
-		hdmi_writel(hdmi_dev, VIDEO_CSC_COEF+i, coeff[i]);
+		hdmi_writel(hdmi_dev, VIDEO_CSC_COEF + i, coeff[i]);
 
 	value = v_SOF_DISABLE | csc_enable | v_COLOR_DEPTH_NOT_INDICATED(1);
 	hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
@@ -355,7 +354,7 @@ static int rockchip_hdmiv1_video_csc(struct hdmi *hdmi_drv,
 			coeff = coeff_csc[3];
 			for (i = 0; i < 24; i++)
 				hdmi_writel(hdmi_dev,
-					    VIDEO_CSC_COEF+i, coeff[i]);
+					    VIDEO_CSC_COEF + i, coeff[i]);
 
 			value = v_SOF_DISABLE | v_CSC_ENABLE;
 			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
@@ -384,7 +383,7 @@ static int rockchip_hdmiv1_video_csc(struct hdmi *hdmi_drv,
 			}
 			for (i = 0; i < 24; i++)
 				hdmi_writel(hdmi_dev,
-					    VIDEO_CSC_COEF+i, coeff[i]);
+					    VIDEO_CSC_COEF + i, coeff[i]);
 
 			value = v_SOF_DISABLE | v_CSC_ENABLE;
 			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
@@ -401,7 +400,7 @@ static int rockchip_hdmiv1_video_csc(struct hdmi *hdmi_drv,
 			coeff = coeff_csc[5];
 			for (i = 0; i < 24; i++)
 				hdmi_writel(hdmi_dev,
-					    VIDEO_CSC_COEF+i, coeff[i]);
+					    VIDEO_CSC_COEF + i, coeff[i]);
 
 			value = v_SOF_DISABLE | v_CSC_ENABLE;
 			hdmi_writel(hdmi_dev, VIDEO_CONTRL3, value);
@@ -550,7 +549,7 @@ static int rockchip_hdmiv1_config_video(struct hdmi *hdmi_drv,
 
 	dev_dbg(hdmi_drv->dev, "[%s]\n", __func__);
 
-	if (vpara == NULL) {
+	if (!vpara) {
 		dev_err(hdmi_drv->dev, "[%s] input parameter error\n",
 			__func__);
 		return -1;
@@ -562,7 +561,7 @@ static int rockchip_hdmiv1_config_video(struct hdmi *hdmi_drv,
 	}
 
 	mode = (struct fb_videomode *)hdmi_vic_to_videomode(vpara->vic);
-	if (mode == NULL) {
+	if (!mode) {
 		dev_err(hdmi_drv->dev, "[%s] not found vic %d\n", __func__,
 			vpara->vic);
 		return -ENOENT;
@@ -694,10 +693,10 @@ static int rockchip_hdmiv1_config_video(struct hdmi *hdmi_drv,
 						   HDMI_VIDEO_FORMAT_NORMAL);
 		}
 		dev_info(hdmi_drv->dev,
-			 "[%s] sucess output HDMI.\n", __func__);
+			 "[%s] success output HDMI.\n", __func__);
 	} else {
 		dev_info(hdmi_drv->dev,
-			 "[%s] sucess output DVI.\n", __func__);
+			 "[%s] success output DVI.\n", __func__);
 	}
 
 	/* rk3028a */
@@ -885,7 +884,7 @@ int rockchip_hdmiv1_removed(struct hdmi *hdmi_drv)
 	rockchip_hdmiv1_control_output(hdmi_drv, -1);
 	rockchip_hdmiv1_set_pwr_mode(hdmi_drv, LOWER_PWR);
 
-	return HDMI_ERROR_SUCESS;
+	return HDMI_ERROR_SUCCESS;
 }
 
 static int rockchip_hdmiv1_enable(struct hdmi *hdmi_drv)
@@ -971,7 +970,7 @@ void rockchip_hdmiv1_dev_init_ops(struct hdmi_ops *ops)
 
 int rockchip_hdmiv1_initial(struct hdmi *hdmi_drv)
 {
-	int rc = HDMI_ERROR_SUCESS;
+	int rc = HDMI_ERROR_SUCCESS;
 	struct hdmi_dev *hdmi_dev = hdmi_drv->property->priv;
 
 	hdmi_dev->pwr_mode = NORMAL;
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h
index 6117a3cc1c0b..aca4958cc261 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv1/rockchip_hdmiv1_hw.h
@@ -8,6 +8,7 @@ enum PWR_MODE {
 	NORMAL,
 	LOWER_PWR,
 };
+
 enum {
 	OUTPUT_DVI = 0,
 	OUTPUT_HDMI
@@ -25,13 +26,13 @@ enum {
 	AUTO_CSC_ENABLE	/* enable auto csc*/
 };
 
-
 /* Color Limit Range */
 enum {
 	COLOR_LIMIT_RANGE_0_255,	/* Color Limit Range 0 To 255*/
 	COLOR_LIMIT_RANGE_16_235,	/* Color Limit Range 16 To 235*/
 };
-/* Color Space Convertion Mode */
+
+/* Color Space Conversion Mode */
 enum {
 	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,/* YCbCr 16-235 input to RGB
 					     * 0-255 output according BT601
@@ -58,7 +59,6 @@ enum {
 					     */
 };
 
-
 #define AUTO_DEFINE_CSC
 #ifdef RK616_USE_MCLK_12M
 #define HDMI_SYS_FREG_CLK        12000000
@@ -66,52 +66,53 @@ enum {
 #define HDMI_SYS_FREG_CLK        11289600
 #endif
 
-#define HDMI_SCL_RATE            (100*1000)
+#define HDMI_SCL_RATE            (100 * 1000)
 #define DDC_BUS_FREQ_L			0x4b
 #define DDC_BUS_FREQ_H			0x4c
 
 #define SYS_CTRL			0x00
-#define m_RST_ANALOG		(1 << 6)
+#define m_RST_ANALOG		BIT(6)
 #define v_RST_ANALOG		(0 << 6)
-#define v_NOT_RST_ANALOG	(1 << 6)
+#define v_NOT_RST_ANALOG	BIT(6)
 
-#define m_RST_DIGITAL		(1 << 5)
+#define m_RST_DIGITAL		BIT(5)
 #define v_RST_DIGITAL		(0 << 5)
-#define v_NOT_RST_DIGITAL	(1 << 5)
+#define v_NOT_RST_DIGITAL	BIT(5)
 
-#define m_REG_CLK_INV		(1 << 4)
+#define m_REG_CLK_INV		BIT(4)
 #define v_REG_CLK_NOT_INV	(0 << 4)
-#define v_REG_CLK_INV		(1 << 4)
-#define m_VCLK_INV		(1 << 3)
+#define v_REG_CLK_INV		BIT(4)
+#define m_VCLK_INV		BIT(3)
 #define v_VCLK_NOT_INV		(0 << 3)
-#define v_VCLK_INV		(1 << 3)
-#define m_REG_CLK_SOURCE	(1 << 2)
+#define v_VCLK_INV		BIT(3)
+#define m_REG_CLK_SOURCE	BIT(2)
 #define v_REG_CLK_SOURCE_TMDS	(0 << 2)
-#define v_REG_CLK_SOURCE_SYS	(1 << 2)
-#define m_POWER			(1 << 1)
+#define v_REG_CLK_SOURCE_SYS	BIT(2)
+#define m_POWER			BIT(1)
 #define v_PWR_ON		(0 << 1)
-#define v_PWR_OFF		(1 << 1)
-#define m_INT_POL		(1 << 0)
+#define v_PWR_OFF		BIT(1)
+#define m_INT_POL		BIT(0)
 #define v_INT_POL_HIGH		1
 #define v_INT_POL_LOW		0
 
 #define VIDEO_CONTRL1			0x01
 #define m_VIDEO_INPUT_FORMAT	(7 << 1)
-#define m_DE_SOURCE		(1 << 0)
+#define m_DE_SOURCE		BIT(0)
 enum {
 	VIDEO_INPUT_SDR_RGB444 = 0,
 	VIDEO_INPUT_DDR_RGB444 = 5,
 	VIDEO_INPUT_DDR_YCBCR422 = 6
 };
+
 #define v_VIDEO_INPUT_FORMAT(n)	(n << 1)
 #define v_DE_EXTERNAL		1
-#define v_DE_INTERANL		0
+#define v_DE_INTERNAL		0
 
 #define VIDEO_CONTRL2			0x02
 #define m_VIDEO_OUTPUT_COLOR	(3 << 6)
 #define m_VIDEO_INPUT_BITS	(3 << 4)
-#define m_VIDEO_INPUT_CSP	(1 << 0)
-#define v_VIDEO_OUTPUT_COLOR(n) (((n)&0x3) << 6)
+#define m_VIDEO_INPUT_CSP	BIT(0)
+#define v_VIDEO_OUTPUT_COLOR(n) (((n) & 0x3) << 6)
 #define v_VIDEO_INPUT_BITS(n)	(n << 4)
 #define v_VIDEO_INPUT_CSP(n)	(n << 0)
 
@@ -121,35 +122,35 @@ enum {
 	VIDEO_INPUT_REVERT,
 	VIDEO_INPUT_8BITS
 };
+
 #define VIDEO_CONTRL			0x03
-#define m_VIDEO_AUTO_CSC		(1 << 7)
+#define m_VIDEO_AUTO_CSC		BIT(7)
 #define v_VIDEO_AUTO_CSC(n)		(n << 7)
-#define m_VIDEO_C0_C2_SWAP		(1 << 0)
+#define m_VIDEO_C0_C2_SWAP		BIT(0)
 #define v_VIDEO_C0_C2_SWAP(n)		(n << 0)
 
-
 #define VIDEO_CONTRL3			0x04
-#define m_COLOR_DEPTH_NOT_INDICATED (1 << 4)
-#define m_SOF			(1 << 3)
-#define m_COLOR_RANGE		(1 << 2)
-#define m_CSC			(1 << 0)
+#define m_COLOR_DEPTH_NOT_INDICATED BIT(4)
+#define m_SOF			BIT(3)
+#define m_COLOR_RANGE		BIT(2)
+#define m_CSC			BIT(0)
 #define v_COLOR_DEPTH_NOT_INDICATED(n) ((n) << 4) /* 1: Force GCP CD[3:0] zero
 						   * 0: GCP CD[3:0] according
 						   *    color depth
 						   */
 #define v_SOF_ENABLE		(0 << 3)
-#define v_SOF_DISABLE		(1 << 3)
-#define v_COLOR_RANGE_FULL	(1 << 2)
+#define v_SOF_DISABLE		BIT(3)
+#define v_COLOR_RANGE_FULL	BIT(2)
 #define v_COLOR_RANGE_LIMITED	(0 << 2)
 #define v_CSC_ENABLE		1
 #define v_CSC_DISABLE		0
 
 #define AV_MUTE				0x05
-#define m_AVMUTE_CLEAR		(1 << 7)
-#define m_AVMUTE_ENABLE		(1 << 6)
-#define m_AUDIO_PD		(1 << 2)
-#define m_AUDIO_MUTE		(1 << 1)
-#define m_VIDEO_BLACK		(1 << 0)
+#define m_AVMUTE_CLEAR		BIT(7)
+#define m_AVMUTE_ENABLE		BIT(6)
+#define m_AUDIO_PD		BIT(2)
+#define m_AUDIO_MUTE		BIT(1)
+#define m_VIDEO_BLACK		BIT(0)
 #define v_AVMUTE_CLEAR(n)	(n << 7)
 #define v_AVMUTE_ENABLE(n)	(n << 6)
 #define v_AUDIO_PD(n)		(n << 2)
@@ -178,23 +179,25 @@ enum {
 
 #define VIDEO_CSC_COEF			0x18
 
-
 #define AUDIO_CTRL1			0x35
 enum {
 	CTS_SOURCE_INTERNAL = 0,
 	CTS_SOURCE_EXTERNAL
 };
+
 #define v_CTS_SOURCE(n)		(n << 7)
 enum {
 	DOWNSAMPLE_DISABLE = 0,
 	DOWNSAMPLE_1_2,
 	DOWNSAMPLE_1_4
 };
+
 #define v_DOWN_SAMPLE(n)	(n << 5)
 enum {
 	AUDIO_SOURCE_IIS = 0,
 	AUDIO_SOURCE_SPDIF
 };
+
 #define v_AUDIO_SOURCE(n)	(n << 3)
 #define v_MCLK_ENABLE(n)	(n << 2)
 enum {
@@ -203,6 +206,7 @@ enum {
 	MCLK_384FS,
 	MCLK_512FS
 };
+
 #define v_MCLK_RATIO(n)		(n)
 
 #define AUDIO_SAMPLE_RATE		0x37
@@ -223,12 +227,14 @@ enum {
 	I2S_CHANNEL_5_6 = 7,
 	I2S_CHANNEL_7_8 = 0xf
 };
+
 #define v_I2S_CHANNEL(n)	((n) << 2)
 enum {
 	I2S_STANDARD = 0,
 	I2S_LEFT_JUSTIFIED,
 	I2S_RIGHT_JUSTIFIED
 };
+
 #define v_I2S_MODE(n)		(n)
 
 #define AUDIO_I2S_MAP			0x39
@@ -244,9 +250,9 @@ enum {
 #define N_192K		0x6000
 
 #define AUDIO_CHANNEL_STATUS		0x3e
-	#define m_AUDIO_STATUS_NLPCM		(1 << 7)
-	#define m_AUDIO_STATUS_USE		(1 << 6)
-	#define m_AUDIO_STATUS_COPYRIGHT	(1 << 5)
+	#define m_AUDIO_STATUS_NLPCM		BIT(7)
+	#define m_AUDIO_STATUS_USE		BIT(6)
+	#define m_AUDIO_STATUS_COPYRIGHT	BIT(5)
 	#define m_AUDIO_STATUS_ADDITION		(3 << 2)
 	#define m_AUDIO_STATUS_CLK_ACCURACY	(2 << 0)
 
@@ -267,13 +273,12 @@ enum {
 #define EDID_FIFO_OFFSET		0x4f
 #define EDID_FIFO_ADDR			0x50
 
-
 #define PACKET_SEND_MANUAL		0x9c
 #define PACKET_SEND_AUTO		0x9d
-	#define m_PACKET_GCP_EN		(1 << 7)
-	#define m_PACKET_MSI_EN		(1 << 6) /* MPEG Source InfoFrame */
-	#define m_PACKET_SDI_EN		(1 << 5) /* Source product descriptor */
-	#define m_PACKET_VSI_EN		(1 << 4) /* HDMI Vendor Specific
+	#define m_PACKET_GCP_EN		BIT(7)
+	#define m_PACKET_MSI_EN		BIT(6) /* MPEG Source InfoFrame */
+	#define m_PACKET_SDI_EN		BIT(5) /* Source product descriptor */
+	#define m_PACKET_VSI_EN		BIT(4) /* HDMI Vendor Specific
 						  * InfoFrame
 						  */
 	#define v_PACKET_GCP_EN(n)	((n & 1) << 7)
@@ -288,6 +293,7 @@ enum {
 	INFOFRAME_AVI = 0x06,
 	INFOFRAME_AAI = 0x08,
 };
+
 #define CONTROL_PACKET_ADDR		0xa0
 #define SIZE_VSI_INFOFRAME		0x0A	/* 10 bytes */
 #define SIZE_AVI_INFOFRAME		0x11	/* 14 bytes */
@@ -297,17 +303,20 @@ enum {
 	AVI_COLOR_MODE_YCBCR422,
 	AVI_COLOR_MODE_YCBCR444
 };
+
 enum {
 	AVI_COLORIMETRY_NO_DATA = 0,
 	AVI_COLORIMETRY_SMPTE_170M,
 	AVI_COLORIMETRY_ITU709,
 	AVI_COLORIMETRY_EXTENDED
 };
+
 enum {
 	AVI_CODED_FRAME_ASPECT_NO_DATA,
 	AVI_CODED_FRAME_ASPECT_4_3,
 	AVI_CODED_FRAME_ASPECT_16_9
 };
+
 enum {
 	ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME = 0x08,
 	ACTIVE_ASPECT_RATE_4_3,
@@ -316,48 +325,48 @@ enum {
 };
 
 #define HDCP_CTRL			0x52
-#define m_HDMI_DVI		(1 << 1)
+#define m_HDMI_DVI		BIT(1)
 #define v_HDMI_DVI(n)		(n << 1)
 
 #define INTERRUPT_MASK1			0xc0
 #define INTERRUPT_STATUS1		0xc1
-#define	m_INT_ACTIVE_VSYNC	(1 << 5)
-#define m_INT_EDID_READY	(1 << 2)
+#define	m_INT_ACTIVE_VSYNC	BIT(5)
+#define m_INT_EDID_READY	BIT(2)
 
 #define INTERRUPT_MASK2			0xc2
 #define INTERRUPT_STATUS2		0xc3
-#define m_INT_HDCP_ERR		(1 << 7)
-#define m_INT_BKSV_FLAG		(1 << 6)
-#define m_INT_HDCP_OK		(1 << 4)
+#define m_INT_HDCP_ERR		BIT(7)
+#define m_INT_BKSV_FLAG		BIT(6)
+#define m_INT_HDCP_OK		BIT(4)
 
 #define HDMI_STATUS			0xc8
-	#define m_HOTPLUG	(1 << 7)
-	#define m_MASK_INT_HOTPLUG	(1 << 5)
-	#define m_INT_HOTPLUG		(1 << 1)
+	#define m_HOTPLUG	BIT(7)
+	#define m_MASK_INT_HOTPLUG	BIT(5)
+	#define m_INT_HOTPLUG		BIT(1)
 	#define v_MASK_INT_HOTPLUG(n)	((n & 0x1) << 5)
 
 #define HDMI_COLORBAR                   0xc9
 
 #define PHY_SYNC			0xce	/* sync phy parameter */
 #define PHY_SYS_CTL			0xe0
-#define m_TMDS_CLK_SOURCE	(1 << 5)
+#define m_TMDS_CLK_SOURCE	BIT(5)
 #define v_TMDS_FROM_PLL		(0 << 5)
-#define v_TMDS_FROM_GEN		(1 << 5)
-#define m_PHASE_CLK		(1 << 4)
+#define v_TMDS_FROM_GEN		BIT(5)
+#define m_PHASE_CLK		BIT(4)
 #define v_DEFAULT_PHASE		(0 << 4)
-#define v_SYNC_PHASE		(1 << 4)
-#define m_TMDS_CURRENT_PWR	(1 << 3)
+#define v_SYNC_PHASE		BIT(4)
+#define m_TMDS_CURRENT_PWR	BIT(3)
 #define v_TURN_ON_CURRENT	(0 << 3)
-#define v_CAT_OFF_CURRENT	(1 << 3)
-#define m_BANDGAP_PWR		(1 << 2)
+#define v_CAT_OFF_CURRENT	BIT(3)
+#define m_BANDGAP_PWR		BIT(2)
 #define v_BANDGAP_PWR_UP	(0 << 2)
-#define v_BANDGAP_PWR_DOWN	(1 << 2)
-#define m_PLL_PWR		(1 << 1)
+#define v_BANDGAP_PWR_DOWN	BIT(2)
+#define m_PLL_PWR		BIT(1)
 #define v_PLL_PWR_UP		(0 << 1)
-#define v_PLL_PWR_DOWN		(1 << 1)
-#define m_TMDS_CHG_PWR		(1 << 0)
+#define v_PLL_PWR_DOWN		BIT(1)
+#define m_TMDS_CHG_PWR		BIT(0)
 #define v_TMDS_CHG_PWR_UP	(0 << 0)
-#define v_TMDS_CHG_PWR_DOWN	(1 << 0)
+#define v_TMDS_CHG_PWR_DOWN	BIT(0)
 
 #define PHY_CHG_PWR			0xe1
 #define v_CLK_CHG_PWR(n)	((n & 1) << 3)
@@ -380,14 +389,13 @@ enum {
 #define PHY_PRE_DIV_RATIO		0xed
 #define v_PRE_DIV_RATIO(n)	(n & 0x1f)
 
-
 /*-----START----- HDMI CEC CTRL------START------*/
 #define CEC_CTRL		0xd0
-	#define m_ADJUST_FOR_HISENSE	(1 << 6)
-	#define m_REJECT_RX_BROADCAST	(1 << 5)
-	#define m_BUSFREETIME_ENABLE	(1 << 2)
-	#define m_REJECT_RX				(1 << 1)
-	#define m_START_TX				(1 << 0)
+	#define m_ADJUST_FOR_HISENSE	BIT(6)
+	#define m_REJECT_RX_BROADCAST	BIT(5)
+	#define m_BUSFREETIME_ENABLE	BIT(2)
+	#define m_REJECT_RX				BIT(1)
+	#define m_START_TX				BIT(0)
 
 #define CEC_DATA		0xd1
 #define CEC_TX_OFFSET	0xd2
@@ -397,15 +405,15 @@ enum {
 #define CEC_TX_LENGTH	0xd6
 #define CEC_RX_LENGTH	0xd7
 #define CEC_TX_INT_MASK	0xd8
-	#define m_TX_DONE			(1 << 3)
-	#define m_TX_NOACK			(1 << 2)
-	#define m_TX_BROADCAST_REJ	(1 << 1)
-	#define m_TX_BUSNOTFREE		(1 << 0)
+	#define m_TX_DONE			BIT(3)
+	#define m_TX_NOACK			BIT(2)
+	#define m_TX_BROADCAST_REJ		BIT(1)
+	#define m_TX_BUSNOTFREE			BIT(0)
 
 #define CEC_RX_INT_MASK 0xd9
-	#define m_RX_LA_ERR			(1 << 4)
-	#define m_RX_GLITCH			(1 << 3)
-	#define m_RX_DONE			(1 << 0)
+	#define m_RX_LA_ERR			BIT(4)
+	#define m_RX_GLITCH			BIT(3)
+	#define m_RX_DONE			BIT(0)
 
 #define CEC_TX_INT		0xda
 #define CEC_RX_INT		0xdb
@@ -414,7 +422,6 @@ enum {
 #define CEC_LOGICADDR		0xde
 /*------END------ HDMI CEC CTRL------END-------*/
 
-
 static inline int hdmi_readl(struct hdmi_dev *hdmi_dev,
 			     u16 offset,
 			     u32 *val)
@@ -447,6 +454,7 @@ static inline int hdmi_msk_reg(struct hdmi_dev *hdmi_dev,
 		       hdmi_dev->regbase + (offset) * 0x04);
 	return ret;
 }
+
 static inline void rockchip_hdmiv1_reset_pclk(void)
 {
 	writel_relaxed(0x00010001, RK_CRU_VIRT + 0x128);
@@ -454,8 +462,6 @@ static inline void rockchip_hdmiv1_reset_pclk(void)
 	writel_relaxed(0x00010000, RK_CRU_VIRT + 0x128);
 }
 
-
-
 void rockchip_hdmiv1_dev_init_ops(struct hdmi_ops *ops);
 int rockchip_hdmiv1_initial(struct hdmi *hdmi);
 void rockchip_hdmiv1_irq(struct hdmi *hdmi);
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c
index 6cbf9b4b9b86..f82100c83406 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2.c
@@ -19,7 +19,7 @@
 #include "rockchip_hdmiv2.h"
 #include "rockchip_hdmiv2_hw.h"
 
-#define HDMI_SEL_LCDC(x)	((((x)&1)<<4)|(1<<20))
+#define HDMI_SEL_LCDC(x)	((((x) & 1) << 4) | (1 << 20))
 #define grf_writel(v, offset)	writel_relaxed(v, RK_GRF_VIRT + offset)
 
 static struct hdmi_dev *hdmi_dev;
@@ -63,7 +63,7 @@ static int hdmi_regs_ctrl_show(struct seq_file *s, void *v)
 		for (j = hdmi_reg_table[i].reg_base;
 		     j <= hdmi_reg_table[i].reg_end; j++) {
 			val = hdmi_readl(hdmi_dev, j);
-			if ((j - hdmi_reg_table[i].reg_base)%16 == 0)
+			if ((j - hdmi_reg_table[i].reg_base) % 16 == 0)
 				seq_printf(s, "\n>>>hdmi_ctl %04x:", j);
 			seq_printf(s, " %02x", val);
 		}
@@ -200,11 +200,11 @@ void ext_pll_set_27m_out(void)
 				  0x1d);
 }
 
-#define HDMI_PD_ON		(1 << 0)
-#define HDMI_PCLK_ON		(1 << 1)
-#define HDMI_HDCPCLK_ON		(1 << 2)
-#define HDMI_CECCLK_ON		(1 << 3)
-#define HDMI_EXT_PHY_CLK_ON	(1 << 4)
+#define HDMI_PD_ON		BIT(0)
+#define HDMI_PCLK_ON		BIT(1)
+#define HDMI_HDCPCLK_ON		BIT(2)
+#define HDMI_CECCLK_ON		BIT(3)
+#define HDMI_EXT_PHY_CLK_ON	BIT(4)
 
 static int rockchip_hdmiv2_clk_enable(struct hdmi_dev *hdmi_dev)
 {
@@ -237,7 +237,7 @@ static int rockchip_hdmiv2_clk_enable(struct hdmi_dev *hdmi_dev)
 	}
 
 	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0) {
-		if (hdmi_dev->pclk == NULL) {
+		if (!hdmi_dev->pclk) {
 			hdmi_dev->pclk =
 				devm_clk_get(hdmi_dev->dev, "pclk_hdmi");
 			if (IS_ERR(hdmi_dev->pclk)) {
@@ -251,7 +251,7 @@ static int rockchip_hdmiv2_clk_enable(struct hdmi_dev *hdmi_dev)
 	}
 
 	if ((hdmi_dev->clk_on & HDMI_HDCPCLK_ON) == 0) {
-		if (hdmi_dev->hdcp_clk == NULL) {
+		if (!hdmi_dev->hdcp_clk) {
 			hdmi_dev->hdcp_clk =
 				devm_clk_get(hdmi_dev->dev, "hdcp_clk_hdmi");
 			if (IS_ERR(hdmi_dev->hdcp_clk)) {
@@ -266,7 +266,7 @@ static int rockchip_hdmiv2_clk_enable(struct hdmi_dev *hdmi_dev)
 
 	if ((rk_hdmi_property.feature & SUPPORT_CEC) &&
 	    (hdmi_dev->clk_on & HDMI_CECCLK_ON) == 0) {
-		if (hdmi_dev->cec_clk == NULL) {
+		if (!hdmi_dev->cec_clk) {
 			hdmi_dev->cec_clk =
 				devm_clk_get(hdmi_dev->dev, "cec_clk_hdmi");
 			if (IS_ERR(hdmi_dev->cec_clk)) {
@@ -286,19 +286,19 @@ static int rockchip_hdmiv2_clk_disable(struct hdmi_dev *hdmi_dev)
 	if (hdmi_dev->clk_on == 0)
 		return 0;
 
-	if ((hdmi_dev->clk_on & HDMI_PD_ON) && (hdmi_dev->pd != NULL)) {
+	if ((hdmi_dev->clk_on & HDMI_PD_ON) && (hdmi_dev->pd)) {
 		clk_disable_unprepare(hdmi_dev->pd);
 		hdmi_dev->clk_on &= ~HDMI_PD_ON;
 	}
 
 	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) &&
-	    (hdmi_dev->pclk != NULL)) {
+	    (hdmi_dev->pclk)) {
 		clk_disable_unprepare(hdmi_dev->pclk);
 		hdmi_dev->clk_on &= ~HDMI_PCLK_ON;
 	}
 
 	if ((hdmi_dev->clk_on & HDMI_HDCPCLK_ON) &&
-	    (hdmi_dev->hdcp_clk != NULL)) {
+	    (hdmi_dev->hdcp_clk)) {
 		clk_disable_unprepare(hdmi_dev->hdcp_clk);
 		hdmi_dev->clk_on &= ~HDMI_HDCPCLK_ON;
 	}
@@ -388,7 +388,7 @@ static void rockchip_hdmiv2_irq_work_func(struct work_struct *work)
 	if (hdmi_dev->enable) {
 		rockchip_hdmiv2_dev_irq(0, hdmi_dev);
 		queue_delayed_work(hdmi_dev->workqueue,
-				   &(hdmi_dev->delay_work),
+				   &hdmi_dev->delay_work,
 				   msecs_to_jiffies(50));
 	}
 }
@@ -464,9 +464,9 @@ static int rockchip_hdmiv2_parse_dt(struct hdmi_dev *hdmi_dev)
 	}
 
 	of_property_read_string(np, "rockchip,vendor",
-				&(hdmi_dev->vendor_name));
+				&hdmi_dev->vendor_name);
 	of_property_read_string(np, "rockchip,product",
-				&(hdmi_dev->product_name));
+				&hdmi_dev->product_name);
 	if (!of_property_read_u32(np, "rockchip,deviceinfo", &val))
 		hdmi_dev->deviceinfo = val & 0xff;
 
@@ -595,7 +595,7 @@ static int rockchip_hdmiv2_probe(struct platform_device *pdev)
 	}
 	hdmi_dev->hdmi =
 		rockchip_hdmi_register(&rk_hdmi_property, &rk_hdmi_ops);
-	if (hdmi_dev->hdmi == NULL) {
+	if (!hdmi_dev->hdmi) {
 		dev_err(&pdev->dev, "register hdmi device failed\n");
 		ret = -ENOMEM;
 		goto failed1;
@@ -646,13 +646,13 @@ static int rockchip_hdmiv2_probe(struct platform_device *pdev)
 #else
 	hdmi_dev->workqueue =
 		create_singlethread_workqueue("rockchip hdmiv2 irq");
-	INIT_DELAYED_WORK(&(hdmi_dev->delay_work),
+	INIT_DELAYED_WORK(&hdmi_dev->delay_work,
 			  rockchip_hdmiv2_irq_work_func);
 	rockchip_hdmiv2_irq_work_func(NULL);
 
 #endif
 	rk_display_device_enable(hdmi_dev->hdmi->ddev);
-	dev_info(&pdev->dev, "rockchip hdmiv2 probe sucess.\n");
+	dev_info(&pdev->dev, "rockchip hdmiv2 probe success.\n");
 	return 0;
 
 failed1:
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c
index c51e42ddd0b0..3c546d5fdfe4 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_cec.c
@@ -21,7 +21,7 @@ static int rockchip_hdmiv2_cec_readframe(struct hdmi *hdmi,
 	int i, count;
 	char *data = (char *)frame;
 
-	if (frame == NULL)
+	if (!frame)
 		return -1;
 	count = hdmi_readl(hdmi_dev, CEC_RX_CNT);
 	CECDBG("%s count %d\n", __func__, count);
@@ -34,7 +34,6 @@ static int rockchip_hdmiv2_cec_readframe(struct hdmi *hdmi,
 	return 0;
 }
 
-
 void rockchip_hdmiv2_cec_setcecla(struct hdmi *hdmi, int ceclgaddr)
 {
 	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
@@ -44,7 +43,7 @@ void rockchip_hdmiv2_cec_setcecla(struct hdmi *hdmi, int ceclgaddr)
 		return;
 	val = 1 << ceclgaddr;
 	hdmi_writel(hdmi_dev, CEC_ADDR_L, val & 0xff);
-	hdmi_writel(hdmi_dev, CEC_ADDR_H, val>>8);
+	hdmi_writel(hdmi_dev, CEC_ADDR_H, val >> 8);
 }
 
 static int rockchip_hdmiv2_cec_sendframe(struct hdmi *hdmi,
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c
index b6d989e21712..b0f7774a119e 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hdcp.c
@@ -80,12 +80,12 @@ void sha_processblock(struct sha_t *sha)
 	/* Initialize the first 16 words in the array W */
 	for (t = 0; t < 80; t++) {
 		if (t < 16) {
-			W[t] = ((unsigned) sha->mblock[t * 4 + 0]) << 24;
-			W[t] |= ((unsigned) sha->mblock[t * 4 + 1]) << 16;
-			W[t] |= ((unsigned) sha->mblock[t * 4 + 2]) << 8;
-			W[t] |= ((unsigned) sha->mblock[t * 4 + 3]) << 0;
+			W[t] = ((unsigned)sha->mblock[t * 4 + 0]) << 24;
+			W[t] |= ((unsigned)sha->mblock[t * 4 + 1]) << 16;
+			W[t] |= ((unsigned)sha->mblock[t * 4 + 2]) << 8;
+			W[t] |= ((unsigned)sha->mblock[t * 4 + 3]) << 0;
 		} else {
-			A = W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16];
+			A = W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16];
 			W[t] = shacircularshift(1, A);
 		}
 	}
@@ -211,7 +211,7 @@ static int hdcpverify_ksv(const u8 *data, u32 size)
 	u32 i = 0;
 	struct sha_t sha;
 
-	if ((data == NULL) || (size < (HEADER + SHAMAX))) {
+	if ((!data) || (size < (HEADER + SHAMAX))) {
 		pr_err("invalid input data");
 		return false;
 	}
@@ -224,7 +224,7 @@ static int hdcpverify_ksv(const u8 *data, u32 size)
 	}
 
 	for (i = 0; i < SHAMAX; i++) {
-		if (data[size - SHAMAX + i] != (u8) (sha.mdigest[i / 4]
+		if (data[size - SHAMAX + i] != (u8)(sha.mdigest[i / 4]
 				>> ((i % 4) * 8))) {
 			pr_err("SHA digest does not match");
 			return false;
@@ -344,7 +344,7 @@ static void hdcp_load_key(struct hdmi *hdmi, struct hdcp_keys *key)
 		value = hdmi_readl(hdmi_dev, HDCPREG_RMSTS);
 	} while ((value & m_DPK_WR_OK_STS) == 0);
 
-	if (hdcp->seeds != NULL) {
+	if (hdcp->seeds) {
 		hdmi_writel(hdmi_dev, HDCPREG_RMCTL, 1);
 		hdmi_writel(hdmi_dev, HDCPREG_SEED1, hdcp->seeds[0]);
 		hdmi_writel(hdmi_dev, HDCPREG_SEED0, hdcp->seeds[1]);
@@ -375,7 +375,7 @@ static void hdcp_load_keys_cb(const struct firmware *fw,
 {
 	struct hdmi *hdmi = (struct hdmi *)context;
 
-	if (fw == NULL) {
+	if (!fw) {
 		pr_info("HDCP: firmware is not loaded\n");
 		return;
 	}
@@ -548,9 +548,9 @@ static ssize_t hdcp_enable_write(struct device *device,
 {
 	int enable;
 
-	if (hdcp == NULL)
+	if (!hdcp)
 		return -EINVAL;
-	if (hdcp->keys == NULL) {
+	if (!hdcp->keys) {
 		pr_err("HDCP: key is not loaded\n");
 		return -EINVAL;
 	}
@@ -567,7 +567,7 @@ static ssize_t hdcp_enable_write(struct device *device,
 
 	return count;
 }
-static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR,
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR,
 		   hdcp_enable_read, hdcp_enable_write);
 
 static ssize_t hdcp_trytimes_read(struct device *device,
@@ -587,7 +587,7 @@ static ssize_t hdcp_trytimes_wrtie(struct device *device,
 {
 	int trytimes;
 
-	if (hdcp == NULL)
+	if (!hdcp)
 		return -EINVAL;
 
 	if (kstrtoint(buf, 0, &trytimes))
@@ -598,7 +598,7 @@ static ssize_t hdcp_trytimes_wrtie(struct device *device,
 
 	return count;
 }
-static DEVICE_ATTR(trytimes, S_IRUGO|S_IWUSR,
+static DEVICE_ATTR(trytimes, S_IRUGO | S_IWUSR,
 		   hdcp_trytimes_read, hdcp_trytimes_wrtie);
 
 static int hdcp_init(struct hdmi *hdmi)
@@ -667,7 +667,7 @@ static int hdcp_init(struct hdmi *hdmi)
 void rockchip_hdmiv2_hdcp_init(struct hdmi *hdmi)
 {
 	pr_info("%s", __func__);
-	if (hdcp == NULL)
+	if (!hdcp)
 		hdcp_init(hdmi);
 	else
 		hdcp_load_key(hdmi, hdcp->keys);
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c
index 8d96fc75a0de..b22eaa3f2796 100755
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.c
@@ -252,7 +252,7 @@ static void rockchip_hdmiv2_i2cm_clk_init(struct hdmi_dev *hdmi_dev)
 {
 	int value;
 
-	/* Set DDC I2C CLK which devided from DDC_CLK. */
+	/* Set DDC I2C CLK which divided from DDC_CLK. */
 	value = i2c_count(24000, EDID_I2C_MIN_SS_SCL_HIGH_TIME);
 	hdmi_writel(hdmi_dev, I2CM_SS_SCL_HCNT_0_ADDR,
 		    value & 0xff);
@@ -278,7 +278,6 @@ static void rockchip_hdmiv2_scdc_set_source_version(struct hdmi_dev *hdmi_dev,
 	rockchip_hdmiv2_i2cm_write_data(hdmi_dev, version, SCDC_SOURCE_VER);
 }
 
-
 static void rockchip_hdmiv2_scdc_read_request(struct hdmi_dev *hdmi_dev,
 					      int enable)
 {
@@ -294,7 +293,6 @@ static void rockchip_hdmiv2_scdc_update_read(struct hdmi_dev *hdmi_dev)
 		     m_I2CM_READ_UPDATE, v_I2CM_READ_UPDATE(1));
 }
 
-
 static int rockchip_hdmiv2_scdc_get_scambling_status(struct hdmi_dev *hdmi_dev)
 {
 	int val;
@@ -833,12 +831,12 @@ static int rockchip_hdmiv2_video_framecomposer(struct hdmi *hdmi_drv,
 		     v_HSYNC_POL(hsync_pol));
 
 	timing = (struct hdmi_video_timing *)hdmi_vic2timing(vpara->vic);
-	if (timing == NULL) {
+	if (!timing) {
 		dev_err(hdmi_drv->dev,
 			"[%s] not found vic %d\n", __func__, vpara->vic);
 		return -ENOENT;
 	}
-	mode = &(timing->mode);
+	mode = &timing->mode;
 	if (vpara->color_input == HDMI_COLOR_YCBCR420)
 		tmdsclk = mode->pixclock / 2;
 	else if (vpara->format_3d == HDMI_3D_FRAME_PACKING)
@@ -1002,23 +1000,7 @@ static int rockchip_hdmiv2_video_framecomposer(struct hdmi *hdmi_drv,
 	 * worst case: tmdsClock == 25MHz => config <= 19
 	 */
 	hdmi_writel(hdmi_dev, FC_EXCTRLSPAC,
-		    (hdmi_dev->tmdsclk/1000) * 50 / (256 * 512));
-#if 0
-	if (!hdmi_drv->uboot)
-		hdmi_msk_reg(hdmi_dev, MC_SWRSTZREQ,
-			     m_TMDS_SWRST, v_TMDS_SWRST(0));
-
-	/*Set PreambleFilter*/
-	for (i = 0; i < 3; i++) {
-		value = (i + 1) * 11;
-		if (i == 0)		/*channel 0*/
-			hdmi_writel(hdmi_dev, FC_CH0PREAM, value);
-		else if (i == 1)	/*channel 1*/
-			hdmi_writel(hdmi_dev, FC_CH1PREAM, value & 0x3f);
-		else if (i == 2)	/*channel 2*/
-			hdmi_writel(hdmi_dev, FC_CH2PREAM, value & 0x3f);
-	}
-#endif
+		    (hdmi_dev->tmdsclk / 1000) * 50 / (256 * 512));
 
 	hdmi_writel(hdmi_dev, FC_PRCONF,
 		    v_FC_PR_FACTOR(timing->pixelrepeat) |
@@ -1356,7 +1338,6 @@ static int rockchip_hdmiv2_video_csc(struct hdmi_dev *hdmi_dev,
 	return 0;
 }
 
-
 static int hdmi_dev_detect_hotplug(struct hdmi *hdmi)
 {
 	struct hdmi_dev *hdmi_dev = hdmi->property->priv;
@@ -1381,7 +1362,7 @@ static int hdmi_dev_read_edid(struct hdmi *hdmi, int block, unsigned char *buff)
 
 	rockchip_hdmiv2_i2cm_reset(hdmi_dev);
 
-	/* Set DDC I2C CLK which devided from DDC_CLK to 100KHz. */
+	/* Set DDC I2C CLK which divided from DDC_CLK to 100KHz. */
 	rockchip_hdmiv2_i2cm_clk_init(hdmi_dev);
 
 	/* Enable I2C interrupt for reading edid */
@@ -1617,7 +1598,7 @@ static int hdmi_dev_config_video(struct hdmi *hdmi, struct hdmi_video *vpara)
 		vpara->color_input = HDMI_COLOR_RGB_0_255;
 
 	if (!hdmi->uboot) {
-		/* befor configure video, we power off phy */
+		/* before configure video, we power off phy */
 		if (hdmi_dev->soctype != HDMI_SOC_RK322X) {
 			hdmi_msk_reg(hdmi_dev, PHY_CONF0,
 				     m_PDDQ_SIG | m_TXPWRON_SIG,
@@ -1681,9 +1662,9 @@ static int hdmi_dev_config_video(struct hdmi *hdmi, struct hdmi_video *vpara)
 					    vpara->vic,
 					    HDMI_VIDEO_FORMAT_NORMAL);
 		}
-		dev_info(hdmi->dev, "[%s] sucess output HDMI.\n", __func__);
+		dev_info(hdmi->dev, "[%s] success output HDMI.\n", __func__);
 	} else {
-		dev_info(hdmi->dev, "[%s] sucess output DVI.\n", __func__);
+		dev_info(hdmi->dev, "[%s] success output DVI.\n", __func__);
 	}
 
 	if (!hdmi->uboot)
@@ -1701,8 +1682,8 @@ static void hdmi_dev_config_aai(struct hdmi_dev *hdmi_dev,
 	 * Type Refer to Stream Head for HDMI
 	 */
 	hdmi_msk_reg(hdmi_dev, FC_AUDICONF0,
-		     m_FC_CHN_CNT | m_FC_CODING_TYEP,
-		     v_FC_CHN_CNT(audio->channel-1) | v_FC_CODING_TYEP(0));
+		     m_FC_CHN_CNT | m_FC_CODING_TYPE,
+		     v_FC_CHN_CNT(audio->channel - 1) | v_FC_CODING_TYPE(0));
 
 	/* Set both Audio Sample Size and Sample Frequency
 	 * Refer to Stream Head for HDMI
@@ -1747,7 +1728,7 @@ static int hdmi_dev_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
 		else
 			N = N_32K_LOWCLK;
 		/*div a num to avoid the value is exceed 2^32(int)*/
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk/1000, 32);
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 32);
 		break;
 	case HDMI_AUDIO_FS_44100:
 		mclk_fs = FS_128;
@@ -1759,7 +1740,7 @@ static int hdmi_dev_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
 		else
 			N = N_441K_LOWCLK;
 
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk/100, 441);
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 100, 441);
 		break;
 	case HDMI_AUDIO_FS_48000:
 		mclk_fs = FS_128;
@@ -1771,7 +1752,7 @@ static int hdmi_dev_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
 		else
 			N = N_48K_LOWCLK;
 
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk/1000, 48);
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 48);
 		break;
 	case HDMI_AUDIO_FS_88200:
 		mclk_fs = FS_128;
@@ -1783,7 +1764,7 @@ static int hdmi_dev_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
 		else
 			N = N_882K_LOWCLK;
 
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk/100, 882);
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 100, 882);
 		break;
 	case HDMI_AUDIO_FS_96000:
 		mclk_fs = FS_128;
@@ -1795,7 +1776,7 @@ static int hdmi_dev_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
 		else
 			N = N_96K_LOWCLK;
 
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk/1000, 96);
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 96);
 		break;
 	case HDMI_AUDIO_FS_176400:
 		mclk_fs = FS_128;
@@ -1807,7 +1788,7 @@ static int hdmi_dev_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
 		else
 			N = N_1764K_LOWCLK;
 
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk/100, 1764);
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 100, 1764);
 		break;
 	case HDMI_AUDIO_FS_192000:
 		mclk_fs = FS_128;
@@ -1819,7 +1800,7 @@ static int hdmi_dev_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
 		else
 			N = N_192K_LOWCLK;
 
-		CTS = CALC_CTS(N, hdmi_dev->tmdsclk/1000, 192);
+		CTS = CALC_CTS(N, hdmi_dev->tmdsclk / 1000, 192);
 		break;
 	default:
 		dev_err(hdmi_dev->hdmi->dev,
@@ -1977,7 +1958,7 @@ static int hdmi_dev_insert(struct hdmi *hdmi)
 	HDMIDBG("%s\n", __func__);
 	if (!hdmi->uboot)
 		hdmi_writel(hdmi_dev, MC_CLKDIS, m_HDCPCLK_DISABLE);
-	return HDMI_ERROR_SUCESS;
+	return HDMI_ERROR_SUCCESS;
 }
 
 static int hdmi_dev_remove(struct hdmi *hdmi)
@@ -1989,7 +1970,7 @@ static int hdmi_dev_remove(struct hdmi *hdmi)
 		hdmi->ops->hdcp_power_off_cb(hdmi);
 	rockchip_hdmiv2_powerdown(hdmi_dev);
 	hdmi_dev->tmdsclk = 0;
-	return HDMI_ERROR_SUCESS;
+	return HDMI_ERROR_SUCCESS;
 }
 
 static int hdmi_dev_enable(struct hdmi *hdmi)
@@ -2062,7 +2043,7 @@ void rockchip_hdmiv2_dev_initial(struct hdmi_dev *hdmi_dev)
 		if (hdmi->hotplug != HDMI_HPD_ACTIVED)
 			hdmi->uboot = 0;
 	}
-	/*mute unnecessary interrrupt, only enable hpd*/
+	/*mute unnecessary interrupt, only enable hpd*/
 	hdmi_writel(hdmi_dev, IH_MUTE_FC_STAT0, 0xff);
 	hdmi_writel(hdmi_dev, IH_MUTE_FC_STAT1, 0xff);
 	hdmi_writel(hdmi_dev, IH_MUTE_FC_STAT2, 0xff);
@@ -2074,7 +2055,7 @@ void rockchip_hdmiv2_dev_initial(struct hdmi_dev *hdmi_dev)
 	hdmi_writel(hdmi_dev, IH_MUTE_I2CMPHY_STAT0, 0xff);
 	hdmi_writel(hdmi_dev, IH_MUTE_AHBDMAAUD_STAT0, 0xff);
 
-	/* disable hdcp interrup */
+	/* disable hdcp interrupt */
 	hdmi_writel(hdmi_dev, A_APIINTMSK, 0xff);
 	hdmi_writel(hdmi_dev, PHY_MASK, 0xf1);
 
diff --git a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h
index de301bf3ba7f..ad85e6a6c1b6 100644
--- a/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h
+++ b/drivers/video/rockchip/hdmi/rockchip-hdmiv2/rockchip_hdmiv2_hw.h
@@ -15,7 +15,7 @@ enum {
 	OUTPUT_HDMI,
 };
 
-/* Color Space Convertion Mode */
+/* Color Space Conversion Mode */
 enum {
 	CSC_RGB_0_255_TO_RGB_16_235_8BIT,	/* RGB 0-255 input to RGB
 						 * 16-235 output that is 8bit
@@ -67,7 +67,7 @@ enum {
 						 */
 };
 
-#define HDMI_SCL_RATE		(100*1000)
+#define HDMI_SCL_RATE		(100 * 1000)
 #define DDC_I2C_EDID_ADDR	0x50	/* 0xA0/2 = 0x50 */
 #define DDC_I2C_SEG_ADDR	0x30	/* 0x60/2 = 0x30 */
 #define DDC_I2C_SCDC_ADDR	0x54	/* 0xa8/2 = 0x54 */
@@ -82,18 +82,18 @@ enum {
 #define PRODUCT_ID1			0x0003
 
 #define CONFIG0_ID			0x0004
-#define m_PREPEN		(1 << 7)
-#define m_AUDSPDIF		(1 << 5)
-#define m_AUDI2S		(1 << 4)
-#define m_HDMI14		(1 << 3)
-#define m_CSC			(1 << 2)
-#define m_CEC			(1 << 1)
-#define m_HDCP			(1 << 0)
+#define m_PREPEN		BIT(7)
+#define m_AUDSPDIF		BIT(5)
+#define m_AUDI2S		BIT(4)
+#define m_HDMI14		BIT(3)
+#define m_CSC			BIT(2)
+#define m_CEC			BIT(1)
+#define m_HDCP			BIT(0)
 
 #define CONFIG1_ID			0x0005
-#define m_HDCP22		(1 << 6)
-#define m_HDMI20		(1 << 5)
-#define m_CONFAPB		(1 << 1)
+#define m_HDCP22		BIT(6)
+#define m_HDMI20		BIT(5)
+#define m_CONFAPB		BIT(1)
 
 #define CONFIG2_ID			0x0006
 enum PHYTYPE {
@@ -106,164 +106,164 @@ enum PHYTYPE {
 };
 
 #define CONFIG3_ID			0x0007
-#define m_AHB_AUD_DMA		(1 << 1)
-#define m_GP_AUD		(1 << 0)
+#define m_AHB_AUD_DMA		BIT(1)
+#define m_GP_AUD		BIT(0)
 
 /* Interrupt Registers */
 #define INTERRUPT_BASE                  0x0100
 
 #define IH_FC_STAT0			0x0100
-#define m_AUD_INFOFRAME		(1 << 7)
-#define m_AUD_CONTENT_PROTECT	(1 << 6)
-#define m_AUD_HBR		(1 << 5)
-#define m_AUD_SAMPLE		(1 << 2)
-#define m_AUD_CLK_REGEN		(1 << 1)
-#define m_NULL_PACKET		(1 << 0)
+#define m_AUD_INFOFRAME		BIT(7)
+#define m_AUD_CONTENT_PROTECT	BIT(6)
+#define m_AUD_HBR		BIT(5)
+#define m_AUD_SAMPLE		BIT(2)
+#define m_AUD_CLK_REGEN		BIT(1)
+#define m_NULL_PACKET		BIT(0)
 
 #define IH_FC_STAT1			0x0101
-#define m_GMD			(1 << 7)
-#define m_ISCR1			(1 << 6)
-#define m_ISCR2			(1 << 5)
-#define m_VSD			(1 << 4)
-#define m_SPD			(1 << 3)
-#define m_AVI_INFOFRAME		(1 << 1)
-#define m_GCP			(1 << 0)
+#define m_GMD			BIT(7)
+#define m_ISCR1			BIT(6)
+#define m_ISCR2			BIT(5)
+#define m_VSD			BIT(4)
+#define m_SPD			BIT(3)
+#define m_AVI_INFOFRAME		BIT(1)
+#define m_GCP			BIT(0)
 
-#define v_AVI_INFOFRAME(n)	(((n)&0x01) << 1)
+#define v_AVI_INFOFRAME(n)	(((n) & 0x01) << 1)
 
 #define IH_FC_STAT2			0x0102
-#define m_LOWPRIO_OVERFLOW	(1 << 1)
-#define m_HIGHPRIO_OVERFLOW	(1 << 0)
+#define m_LOWPRIO_OVERFLOW	BIT(1)
+#define m_HIGHPRIO_OVERFLOW	BIT(0)
 
 #define IH_AS_SATA0			0x0103
-#define m_FIFO_UNDERRUN		(1 << 4)
-#define m_FIFO_OVERRUN		(1 << 3)
-#define m_AUD_FIFO_UDFLOW_THR	(1 << 2)
-#define m_AUD_FIFO_UDFLOW	(1 << 1)
-#define m_AUD_FIFO_OVERFLOW	(1 << 0)
+#define m_FIFO_UNDERRUN		BIT(4)
+#define m_FIFO_OVERRUN		BIT(3)
+#define m_AUD_FIFO_UDFLOW_THR	BIT(2)
+#define m_AUD_FIFO_UDFLOW	BIT(1)
+#define m_AUD_FIFO_OVERFLOW	BIT(0)
 
 #define IH_PHY_STAT0			0x0104
-#define m_RX_SENSE3		(1 << 5)
-#define m_RX_SENSE2		(1 << 4)
-#define m_RX_SENSE1		(1 << 3)
-#define m_RX_SENSE0		(1 << 2)
-#define m_TX_PHY_LOCK		(1 << 1)
-#define m_HPD			(1 << 0)
+#define m_RX_SENSE3		BIT(5)
+#define m_RX_SENSE2		BIT(4)
+#define m_RX_SENSE1		BIT(3)
+#define m_RX_SENSE0		BIT(2)
+#define m_TX_PHY_LOCK		BIT(1)
+#define m_HPD			BIT(0)
 
 #define IH_I2CM_STAT0			0x0105
-#define m_SCDC_READREQ		(1 << 2)
-#define m_I2CM_DONE		(1 << 1)
-#define m_I2CM_ERROR		(1 << 0)
+#define m_SCDC_READREQ		BIT(2)
+#define m_I2CM_DONE		BIT(1)
+#define m_I2CM_ERROR		BIT(0)
 
 #define IH_CEC_STAT0			0x0106
-#define m_WAKEUP		(1 << 6)
-#define m_ERR_FOLLOW		(1 << 5)
-#define m_ERR_INITIATOR		(1 << 4)
-#define m_ARB_LOST		(1 << 3)
-#define m_NACK			(1 << 2)
-#define m_EOM			(1 << 1)
-#define m_DONE			(1 << 0)
+#define m_WAKEUP		BIT(6)
+#define m_ERR_FOLLOW		BIT(5)
+#define m_ERR_INITIATOR		BIT(4)
+#define m_ARB_LOST		BIT(3)
+#define m_NACK			BIT(2)
+#define m_EOM			BIT(1)
+#define m_DONE			BIT(0)
 
 #define IH_VP_STAT0			0x0107
-#define m_FIFOFULL_REPET	(1 << 7)
-#define m_FIFOEMPTY_REPET	(1 << 6)
-#define m_FIFOFULL_PACK		(1 << 5)
-#define m_FIFOEMPTY_PACK	(1 << 4)
-#define m_FIFOFULL_REMAP	(1 << 3)
-#define m_FIFOEMPTY_REMAP	(1 << 2)
-#define m_FIFOFULL_BYPASS	(1 << 1)
-#define m_FIFOEMPTY_BYPASS	(1 << 0)
+#define m_FIFOFULL_REPET	BIT(7)
+#define m_FIFOEMPTY_REPET	BIT(6)
+#define m_FIFOFULL_PACK		BIT(5)
+#define m_FIFOEMPTY_PACK	BIT(4)
+#define m_FIFOFULL_REMAP	BIT(3)
+#define m_FIFOEMPTY_REMAP	BIT(2)
+#define m_FIFOFULL_BYPASS	BIT(1)
+#define m_FIFOEMPTY_BYPASS	BIT(0)
 
 #define IH_I2CMPHY_STAT0		0x0108
-#define m_I2CMPHY_DONE		(1 << 1)
-#define m_I2CMPHY_ERR		(1 << 0)
+#define m_I2CMPHY_DONE		BIT(1)
+#define m_I2CMPHY_ERR		BIT(0)
 
 #define IH_AHBDMAAUD_STAT0		0x0109
-#define m_AUDDMA_INT_BUFOVERRUN	(1 << 6)
-#define m_AUDDMA_INT_ERR	(1 << 5)
-#define m_AUDDMA_INT_LOST	(1 << 4)
-#define m_AUDDMA_INT_RETRYSPLIT (1 << 3)
-#define m_AUDDMA_INT_DONE	(1 << 2)
-#define m_AUDDMA_INT_BUFFULL	(1 << 1)
-#define m_AUDDMA_INT_BUFEMPTY	(1 << 0)
+#define m_AUDDMA_INT_BUFOVERRUN	BIT(6)
+#define m_AUDDMA_INT_ERR	BIT(5)
+#define m_AUDDMA_INT_LOST	BIT(4)
+#define m_AUDDMA_INT_RETRYSPLIT BIT(3)
+#define m_AUDDMA_INT_DONE	BIT(2)
+#define m_AUDDMA_INT_BUFFULL	BIT(1)
+#define m_AUDDMA_INT_BUFEMPTY	BIT(0)
 
 #define IH_DECODE			0x0170
-#define m_IH_FC_STAT0		(1 << 7)
-#define m_IH_FC_STAT1		(1 << 6)
-#define m_IH_FC_STAT2_VP	(1 << 5)
-#define m_IH_AS_STAT0		(1 << 4)
-#define m_IH_PHY		(1 << 3)
-#define m_IH_I2CM_STAT0		(1 << 2)
-#define m_IH_CEC_STAT0		(1 << 1)
-#define m_IH_AHBDMAAUD_STAT0	(1 << 0)
+#define m_IH_FC_STAT0		BIT(7)
+#define m_IH_FC_STAT1		BIT(6)
+#define m_IH_FC_STAT2_VP	BIT(5)
+#define m_IH_AS_STAT0		BIT(4)
+#define m_IH_PHY		BIT(3)
+#define m_IH_I2CM_STAT0		BIT(2)
+#define m_IH_CEC_STAT0		BIT(1)
+#define m_IH_AHBDMAAUD_STAT0	BIT(0)
 
 #define IH_MUTE_FC_STAT0		0x0180
-#define m_AUDI_MUTE		(1 << 7)
-#define m_ACP_MUTE		(1 << 6)
-#define m_DST_MUTE		(1 << 4)
-#define m_OBA_MUTE		(1 << 3)
-#define m_AUDS_MUTE		(1 << 2)
-#define m_ACR_MUTE		(1 << 1)
-#define m_NULL_MUTE		(1 << 0)
+#define m_AUDI_MUTE		BIT(7)
+#define m_ACP_MUTE		BIT(6)
+#define m_DST_MUTE		BIT(4)
+#define m_OBA_MUTE		BIT(3)
+#define m_AUDS_MUTE		BIT(2)
+#define m_ACR_MUTE		BIT(1)
+#define m_NULL_MUTE		BIT(0)
 
 #define IH_MUTE_FC_STAT1		0x0181
-#define m_GMD_MUTE		(1 << 7)
-#define m_ISCR1_MUTE		(1 << 6)
-#define m_ISCR2_MUTE		(1 << 5)
-#define m_VSD_MUTE		(1 << 4)
-#define m_SPD_MUTE		(1 << 3)
-#define m_AVI_MUTE		(1 << 1)
-#define m_GCP_MUTE		(1 << 0)
+#define m_GMD_MUTE		BIT(7)
+#define m_ISCR1_MUTE		BIT(6)
+#define m_ISCR2_MUTE		BIT(5)
+#define m_VSD_MUTE		BIT(4)
+#define m_SPD_MUTE		BIT(3)
+#define m_AVI_MUTE		BIT(1)
+#define m_GCP_MUTE		BIT(0)
 
 #define IH_MUTE_FC_STAT2		0x0182
-#define m_LPRIO_OVERFLOW_MUTE	(1 << 1)
-#define m_HPRIO_OVERFLOW_MUTE	(1 << 0)
+#define m_LPRIO_OVERFLOW_MUTE	BIT(1)
+#define m_HPRIO_OVERFLOW_MUTE	BIT(0)
 
 #define IH_MUTE_AS_STAT0		0x0183
-#define m_FIFO_UNDERRUN_MUTE	(1 << 4)
-#define m_FIFO_OVERRUN_MUTE	(1 << 3)
-#define m_AUD_FIFO_UDF_THR_MUTE	(1 << 2)
-#define m_AUD_FIFO_UDF_MUTE	(1 << 1)
-#define m_AUD_FIFO_OVF_MUTE	(1 << 0)
+#define m_FIFO_UNDERRUN_MUTE	BIT(4)
+#define m_FIFO_OVERRUN_MUTE	BIT(3)
+#define m_AUD_FIFO_UDF_THR_MUTE	BIT(2)
+#define m_AUD_FIFO_UDF_MUTE	BIT(1)
+#define m_AUD_FIFO_OVF_MUTE	BIT(0)
 
 #define IH_MUTE_PHY_STAT0		0x0184
-#define m_RX_SENSE3_MUTE	(1 << 5)
-#define m_RX_SENSE2_MUTE	(1 << 4)
-#define m_RX_SENSE1_MUTE	(1 << 3)
-#define m_RX_SENSE0_MUTE	(1 << 2)
-#define m_TX_PHY_LOCK_MUTE	(1 << 1)
-#define m_HPD_MUTE		(1 << 0)
+#define m_RX_SENSE3_MUTE	BIT(5)
+#define m_RX_SENSE2_MUTE	BIT(4)
+#define m_RX_SENSE1_MUTE	BIT(3)
+#define m_RX_SENSE0_MUTE	BIT(2)
+#define m_TX_PHY_LOCK_MUTE	BIT(1)
+#define m_HPD_MUTE		BIT(0)
 
 #define IH_MUTE_I2CM_STAT0		0x0185
-#define m_SCDC_READREQ_MUTE	(1 << 2)
-#define v_SCDC_READREQ_MUTE(n)	(((n)&0x01) << 2)
-#define m_I2CM_DONE_MUTE	(1 << 1)
-#define v_I2CM_DONE_MUTE(n)	(((n)&0x01) << 1)
-#define m_I2CM_ERR_MUTE		(1 << 0)
-#define v_I2CM_ERR_MUTE(n)	(((n)&0x01) << 0)
+#define m_SCDC_READREQ_MUTE	BIT(2)
+#define v_SCDC_READREQ_MUTE(n)	(((n) & 0x01) << 2)
+#define m_I2CM_DONE_MUTE	BIT(1)
+#define v_I2CM_DONE_MUTE(n)	(((n) & 0x01) << 1)
+#define m_I2CM_ERR_MUTE		BIT(0)
+#define v_I2CM_ERR_MUTE(n)	(((n) & 0x01) << 0)
 
 #define IH_MUTE_CEC_STAT0		0x0186
-#define m_WAKEUP_MUTE		(1 << 6)
-#define m_ERR_FOLLOW_MUTE	(1 << 5)
-#define m_ERR_INITIATOR_MUTE	(1 << 4)
-#define m_ARB_LOST_MUTE		(1 << 3)
-#define m_NACK_MUTE		(1 << 2)
-#define m_EOM_MUTE		(1 << 1)
-#define m_DONE_MUTE		(1 << 0)
+#define m_WAKEUP_MUTE		BIT(6)
+#define m_ERR_FOLLOW_MUTE	BIT(5)
+#define m_ERR_INITIATOR_MUTE	BIT(4)
+#define m_ARB_LOST_MUTE		BIT(3)
+#define m_NACK_MUTE		BIT(2)
+#define m_EOM_MUTE		BIT(1)
+#define m_DONE_MUTE		BIT(0)
 
 #define IH_MUTE_VP_STAT0		0x0187
-#define m_FIFOFULL_REP_MUTE	(1 << 7)
-#define m_FIFOEMPTY_REP_MUTE	(1 << 6)
-#define m_FIFOFULL_PACK_MUTE	(1 << 5)
-#define m_FIFOEMPTY_PACK_MUTE	(1 << 4)
-#define m_FIFOFULL_REMAP_MUTE	(1 << 3)
-#define m_FIFOEMPTY_REMAP_MUTE	(1 << 2)
-#define m_FIFOFULL_BYP_MUTE	(1 << 1)
-#define m_FIFOEMPTY_BYP_MUTE	(1 << 0)
+#define m_FIFOFULL_REP_MUTE	BIT(7)
+#define m_FIFOEMPTY_REP_MUTE	BIT(6)
+#define m_FIFOFULL_PACK_MUTE	BIT(5)
+#define m_FIFOEMPTY_PACK_MUTE	BIT(4)
+#define m_FIFOFULL_REMAP_MUTE	BIT(3)
+#define m_FIFOEMPTY_REMAP_MUTE	BIT(2)
+#define m_FIFOFULL_BYP_MUTE	BIT(1)
+#define m_FIFOEMPTY_BYP_MUTE	BIT(0)
 
 #define IH_MUTE_I2CMPHY_STAT0		0x0188
-#define m_I2CMPHY_DONE_MUTE	(1 << 1)
-#define m_I2CMPHY_ERR_MUTE	(1 << 0)
+#define m_I2CMPHY_DONE_MUTE	BIT(1)
+#define m_I2CMPHY_ERR_MUTE	BIT(0)
 
 #define IH_MUTE_AHBDMAAUD_STAT0		0x0189
 #define IH_MUTE				0x01ff
@@ -272,8 +272,8 @@ enum PHYTYPE {
 #define VIDEO_SAMPLER_BASE		0x0200
 
 #define TX_INVID0			0x0200
-#define m_INTERNAL_DE_GEN	(1 << 7)
-#define v_INTERNAL_DE_GEN(n)	(((n)&0x01) << 7)
+#define m_INTERNAL_DE_GEN	BIT(7)
+#define v_INTERNAL_DE_GEN(n)	(((n) & 0x01) << 7)
 enum VIDEO_MODE {
 	VIDEO_RGB444_8BIT = 0x01,
 	VIDEO_RGB444_10BIT = 0x03,
@@ -287,16 +287,17 @@ enum VIDEO_MODE {
 	VIDEO_YCBCR422_10BIT = 0x14,
 	VIDEO_YCBCR422_8BIT = 0x16
 };
+
 #define m_VIDEO_MAPPING		(0x1f << 0)
-#define v_VIDEO_MAPPING(n)	((n)&0x1f)
+#define v_VIDEO_MAPPING(n)	((n) & 0x1f)
 
 #define TX_INSTUFFING			0x0201
-#define m_BCBDATA_STUFF		(1 << 2)
-#define v_BCBDATA_STUFF(n)	(((n)&0x01) << 2)
-#define m_RCRDATA_STUFF		(1 << 1)
-#define v_RCRDATA_STUFF(n)	(((n)&0x01) << 1)
-#define m_GYDATA_STUFF		(1 << 0)
-#define v_GYDATA_STUFF(n)	(((n)&0x01) << 0)
+#define m_BCBDATA_STUFF		BIT(2)
+#define v_BCBDATA_STUFF(n)	(((n) & 0x01) << 2)
+#define m_RCRDATA_STUFF		BIT(1)
+#define v_RCRDATA_STUFF(n)	(((n) & 0x01) << 1)
+#define m_GYDATA_STUFF		BIT(0)
+#define v_GYDATA_STUFF(n)	(((n) & 0x01) << 0)
 
 #define TX_GYDATA0			0x0202
 #define TX_GYDATA1			0x0203
@@ -319,8 +320,9 @@ enum COLOR_DEPTH {
 	COLOR_DEPTH_36BIT,
 	COLOR_DEPTH_48BIT
 };
+
 #define m_COLOR_DEPTH		(0x0f << 4)
-#define v_COLOR_DEPTH(n)	(((n)&0x0f) << 4)
+#define v_COLOR_DEPTH(n)	(((n) & 0x0f) << 4)
 enum PIXEL_REPET {
 	NO_PIXEL_REPET = 0,
 	PIXEL_SENT_2TIMES,
@@ -333,24 +335,26 @@ enum PIXEL_REPET {
 	PIXEL_SENT_9TIMES,
 	PIXEL_SENT_10TIMES
 };
+
 #define m_DESIRED_PR_FACTOR	(0x0f << 0)
-#define v_DESIRED_PR_FACTOR(n)	(((n)&0x0f) << 0)
+#define v_DESIRED_PR_FACTOR(n)	(((n) & 0x0f) << 0)
 
 #define VP_STUFF			0x0802
-#define m_IDEFAULT_PHASE	(1 << 5)
-#define v_IDEFAULT_PHASE(n)	(((n)&0x01) << 5)
-#define m_IFIX_PP_TO_LAST	(1 << 4)
-#define m_ICX_GOTO_P0_ST	(1 << 3)
+#define m_IDEFAULT_PHASE	BIT(5)
+#define v_IDEFAULT_PHASE(n)	(((n) & 0x01) << 5)
+#define m_IFIX_PP_TO_LAST	BIT(4)
+#define m_ICX_GOTO_P0_ST	BIT(3)
 enum {
 	DIRECT_MODE = 0,
 	STUFFING_MODE
 };
-#define m_YCC422_STUFFING	(1 << 2)
-#define v_YCC422_STUFFING(n)	(((n)&0x01) << 2)
-#define m_PP_STUFFING		(1 << 1)
-#define v_PP_STUFFING(n)	(((n)&0x01) << 1)
-#define m_PR_STUFFING		(1 << 0)
-#define v_PR_STUFFING(n)	(((n)&0x01) << 0)
+
+#define m_YCC422_STUFFING	BIT(2)
+#define v_YCC422_STUFFING(n)	(((n) & 0x01) << 2)
+#define m_PP_STUFFING		BIT(1)
+#define v_PP_STUFFING(n)	(((n) & 0x01) << 1)
+#define m_PR_STUFFING		BIT(0)
+#define v_PR_STUFFING(n)	(((n) & 0x01) << 0)
 
 #define VP_REMAP			0x0803
 enum YCC422_SIZE {
@@ -358,85 +362,87 @@ enum YCC422_SIZE {
 	YCC422_20BIT,
 	YCC422_24BIT
 };
+
 #define m_YCC422_SIZE		(0x03 << 0)
-#define v_YCC422_SIZE(n)	(((n)&0x03) << 0)
+#define v_YCC422_SIZE(n)	(((n) & 0x03) << 0)
 
 #define VP_CONF				0x0804
-#define m_BYPASS_EN		(1 << 6)
-#define v_BYPASS_EN(n)		(((n)&0x01) << 6)
-#define m_PIXEL_PACK_EN		(1 << 5)
-#define v_PIXEL_PACK_EN(n)	(((n)&0x01) << 5)
-#define m_PIXEL_REPET_EN	(1 << 4)
-#define v_PIXEL_REPET_EN(n)	(((n)&0x01) << 4)
-#define m_YCC422_EN		(1 << 3)
-#define v_YCC422_EN(n)		(((n)&0x01) << 3)
-#define m_BYPASS_SEL		(1 << 2)
-#define v_BYPASS_SEL(n)		(((n)&0x01) << 2)
+#define m_BYPASS_EN		BIT(6)
+#define v_BYPASS_EN(n)		(((n) & 0x01) << 6)
+#define m_PIXEL_PACK_EN		BIT(5)
+#define v_PIXEL_PACK_EN(n)	(((n) & 0x01) << 5)
+#define m_PIXEL_REPET_EN	BIT(4)
+#define v_PIXEL_REPET_EN(n)	(((n) & 0x01) << 4)
+#define m_YCC422_EN		BIT(3)
+#define v_YCC422_EN(n)		(((n) & 0x01) << 3)
+#define m_BYPASS_SEL		BIT(2)
+#define v_BYPASS_SEL(n)		(((n) & 0x01) << 2)
 enum {
 	OUT_FROM_PIXEL_PACKING = 0,
 	OUT_FROM_YCC422_REMAP,
 	OUT_FROM_8BIT_BYPASS
 };
+
 #define m_OUTPUT_SEL		(0x03 << 0)
-#define v_OUTPUT_SEL(n)		((n&0x03) << 0)
+#define v_OUTPUT_SEL(n)		((n & 0x03) << 0)
 
 #define VP_MASK				0x0807
-#define m_OINTFULL_REPET	(1 << 7)
-#define m_OINTEMPTY_REPET	(1 << 6)
-#define m_OINTFULL_PACK		(1 << 5)
-#define m_OINTEMPTY_PACK	(1 << 4)
-#define m_OINTFULL_REMAP	(1 << 3)
-#define m_OINTEMPTY_REMAP	(1 << 2)
-#define m_OINTFULL_BYPASS	(1 << 1)
-#define m_OINTEMPTY_BYPASS	(1 << 0)
+#define m_OINTFULL_REPET	BIT(7)
+#define m_OINTEMPTY_REPET	BIT(6)
+#define m_OINTFULL_PACK		BIT(5)
+#define m_OINTEMPTY_PACK	BIT(4)
+#define m_OINTFULL_REMAP	BIT(3)
+#define m_OINTEMPTY_REMAP	BIT(2)
+#define m_OINTFULL_BYPASS	BIT(1)
+#define m_OINTEMPTY_BYPASS	BIT(0)
 
 /* Frame Composer Registers */
 #define FRAME_COMPOSER_BASE		0x1000
 
 #define	FC_INVIDCONF			0x1000
-#define m_FC_HDCP_KEEPOUT	(1 << 7)
-#define v_FC_HDCP_KEEPOUT(n)	(((n)&0x01) << 7)
-#define m_FC_VSYNC_POL		(1 << 6)
-#define v_FC_VSYNC_POL(n)	(((n)&0x01) << 6)
-#define m_FC_HSYNC_POL		(1 << 5)
-#define v_FC_HSYNC_POL(n)	(((n)&0x01) << 5)
-#define m_FC_DE_POL		(1 << 4)
-#define v_FC_DE_POL(n)		(((n)&0x01) << 4)
-#define m_FC_HDMI_DVI		(1 << 3)
-#define v_FC_HDMI_DVI(n)	(((n)&0x01) << 3)
-#define m_FC_VBLANK		(1 << 1)
-#define v_FC_VBLANK(n)		(((n)&0x01) << 1)
-#define m_FC_INTERLACE_MODE	(1 << 0)
-#define v_FC_INTERLACE_MODE(n)	(((n)&0x01) << 0)
+#define m_FC_HDCP_KEEPOUT	BIT(7)
+#define v_FC_HDCP_KEEPOUT(n)	(((n) & 0x01) << 7)
+#define m_FC_VSYNC_POL		BIT(6)
+#define v_FC_VSYNC_POL(n)	(((n) & 0x01) << 6)
+#define m_FC_HSYNC_POL		BIT(5)
+#define v_FC_HSYNC_POL(n)	(((n) & 0x01) << 5)
+#define m_FC_DE_POL		BIT(4)
+#define v_FC_DE_POL(n)		(((n) & 0x01) << 4)
+#define m_FC_HDMI_DVI		BIT(3)
+#define v_FC_HDMI_DVI(n)	(((n) & 0x01) << 3)
+#define m_FC_VBLANK		BIT(1)
+#define v_FC_VBLANK(n)		(((n) & 0x01) << 1)
+#define m_FC_INTERLACE_MODE	BIT(0)
+#define v_FC_INTERLACE_MODE(n)	(((n) & 0x01) << 0)
 
 #define	FC_INHACTIV0			0x1001
 
 #define	FC_INHACTIV1			0x1002
 #define v_FC_HACTIVE1(n)	((n) & 0x3f)
-#define m_FC_H_ACTIVE_13	(1 << 5)
-#define v_FC_H_ACTIVE_13(n)	(((n)&0x01) << 5)
-#define m_FC_H_ACTIVE_12	(1 << 4)
-#define v_FC_H_ACTIVE_12(n)	(((n)&0x01) << 4)
+#define m_FC_H_ACTIVE_13	BIT(5)
+#define v_FC_H_ACTIVE_13(n)	(((n) & 0x01) << 5)
+#define m_FC_H_ACTIVE_12	BIT(4)
+#define v_FC_H_ACTIVE_12(n)	(((n) & 0x01) << 4)
 #define m_FC_H_ACTIVE		(0x0f << 0)
-#define v_FC_H_ACTIVE(n)	(((n)&0x0f) << 0)
+#define v_FC_H_ACTIVE(n)	(((n) & 0x0f) << 0)
 
 #define	FC_INHBLANK0			0x1003
 
 #define	FC_INHBLANK1			0x1004
 #define v_FC_HBLANK1(n)		((n) & 0x1f)
 #define m_FC_H_BLANK_12_11	(0x07 << 2)
-#define v_FC_H_BLANK_12_11(n)	(((n)&0x07) << 2)
+#define v_FC_H_BLANK_12_11(n)	(((n) & 0x07) << 2)
 #define m_FC_H_BLANK		(0x03 << 0)
-#define v_FC_H_BLANK(n)		(((n)&0x03) << 0)
+#define v_FC_H_BLANK(n)		(((n) & 0x03) << 0)
 
 #define	FC_INVACTIV0			0x1005
 
 #define	FC_INVACTIV1			0x1006
 #define v_FC_VACTIVE1(n)	((n) & 0x1f)
 #define m_FC_V_ACTIVE_12_11	(0x03 << 3)
-#define v_FC_V_ACTIVE_12_11(n)	(((n)&0x03) << 3)
+#define v_FC_V_ACTIVE_12_11(n)	(((n) & 0x03) << 3)
 #define m_FC_V_ACTIVE		(0x07 << 0)
-#define v_FC_V_ACTIVE(n)	(((n)&0x07) << 0)
+#define v_FC_V_ACTIVE(n)	(((n) & 0x07) << 0)
 
 #define	FC_INVBLANK			0x1007
 #define	FC_HSYNCINDELAY0		0x1008
@@ -444,18 +450,18 @@ enum {
 #define	FC_HSYNCINDELAY1		0x1009
 #define v_FC_HSYNCINDEAY1(n)	((n) & 0x1f)
 #define m_FC_H_SYNCFP_12_11	(0x03 << 3)
-#define v_FC_H_SYNCFP_12_11(n)	(((n)&0x03) << 3)
+#define v_FC_H_SYNCFP_12_11(n)	(((n) & 0x03) << 3)
 #define m_FC_H_SYNCFP		(0x07 << 0)
-#define v_FC_H_SYNCFP(n)	(((n)&0x07) << 0)
+#define v_FC_H_SYNCFP(n)	(((n) & 0x07) << 0)
 
 #define	FC_HSYNCINWIDTH0		0x100a
 
 #define	FC_HSYNCINWIDTH1		0x100b
 #define v_FC_HSYNCWIDTH1(n)	((n) & 0x03)
-#define m_FC_HSYNC_9		(1 << 1)
-#define v_FC_HSYNC_9(n)		(((n)&0x01) << 1)
-#define m_FC_HSYNC		(1 << 0)
-#define v_FC_HSYNC(n)		(((n)&0x01) << 0)
+#define m_FC_HSYNC_9		BIT(1)
+#define v_FC_HSYNC_9(n)		(((n) & 0x01) << 1)
+#define m_FC_HSYNC		BIT(0)
+#define v_FC_HSYNC(n)		(((n) & 0x01) << 0)
 
 #define	FC_VSYNCINDELAY			0x100c
 #define	FC_VSYNCINWIDTH			0x100d
@@ -475,24 +481,26 @@ enum YCC_QUAN_RANGE {
 	YQ_FULL_RANGE,
 	RESERVED,
 };
+
 #define m_FC_YQ			(0x03 << 2)
-#define v_FC_YQ(n)		(((n)&0x03) << 2)
+#define v_FC_YQ(n)		(((n) & 0x03) << 2)
 enum IT_CONTENT_TYPE {
 	CN_GRAPHICS = 0,
 	CN_PHOTO,
 	CN_CINEMA,
 	CN_GAME,
 };
+
 #define m_FC_CN			(0x03 << 0)
-#define v_FC_CN(n)		(((n)&0x03) << 0)
+#define v_FC_CN(n)		(((n) & 0x03) << 0)
 
 #define	FC_GCP				0x1018
-#define m_FC_DEFAULT_PHASE	(1 << 2)
-#define v_FC_DEFAULT_PHASE(n)	(((n)&0x01) << 2)
-#define m_FC_SET_AVMUTE		(1 << 1)
-#define v_FC_SET_AVMUTE(n)	(((n)&0x01) << 1)
-#define m_FC_CLR_AVMUTE		(1 << 0)
-#define v_FC_CLR_AVMUTE(n)	(((n)&0x01) << 0)
+#define m_FC_DEFAULT_PHASE	BIT(2)
+#define v_FC_DEFAULT_PHASE(n)	(((n) & 0x01) << 2)
+#define m_FC_SET_AVMUTE		BIT(1)
+#define v_FC_SET_AVMUTE(n)	(((n) & 0x01) << 1)
+#define m_FC_CLR_AVMUTE		BIT(0)
+#define v_FC_CLR_AVMUTE(n)	(((n) & 0x01) << 0)
 
 enum {
 	AVI_COLOR_MODE_RGB = 0,
@@ -500,23 +508,27 @@ enum {
 	AVI_COLOR_MODE_YCBCR444,
 	AVI_COLOR_MODE_YCBCR420
 };
+
 enum {
 	AVI_COLORIMETRY_NO_DATA = 0,
 	AVI_COLORIMETRY_SMPTE_170M,
 	AVI_COLORIMETRY_ITU709,
 	AVI_COLORIMETRY_EXTENDED
 };
+
 enum {
 	AVI_CODED_FRAME_ASPECT_NO_DATA,
 	AVI_CODED_FRAME_ASPECT_4_3,
 	AVI_CODED_FRAME_ASPECT_16_9
 };
+
 enum {
 	ACTIVE_ASPECT_RATE_DEFAULT = 0x08,
 	ACTIVE_ASPECT_RATE_4_3,
 	ACTIVE_ASPECT_RATE_16_9,
 	ACTIVE_ASPECT_RATE_14_9
 };
+
 enum {
 	AVI_QUANTIZATION_RANGE_DEFAULT = 0,
 	AVI_QUANTIZATION_RANGE_LIMITED,
@@ -524,40 +536,40 @@ enum {
 };
 
 #define	FC_AVICONF0			0x1019
-#define m_FC_RGC_YCC_2		(1 << 7)	/* use for HDMI2.0 TX */
-#define v_FC_RGC_YCC_2(n)	(((n)&0x01) << 7)
-#define m_FC_ACTIV_FORMAT	(1 << 6)
-#define v_FC_ACTIV_FORMAT(n)	(((n)&0x01) << 6)
+#define m_FC_RGC_YCC_2		BIT(7)	/* use for HDMI2.0 TX */
+#define v_FC_RGC_YCC_2(n)	(((n) & 0x01) << 7)
+#define m_FC_ACTIV_FORMAT	BIT(6)
+#define v_FC_ACTIV_FORMAT(n)	(((n) & 0x01) << 6)
 #define m_FC_SCAN_INFO		(0x03 << 4)
-#define v_FC_SCAN_INFO(n)	(((n)&0x03) << 4)
+#define v_FC_SCAN_INFO(n)	(((n) & 0x03) << 4)
 #define m_FC_BAR_FORMAT		(0x03 << 2)
-#define v_FC_BAR_FORMAT(n)	(((n)&0x03) << 2)
+#define v_FC_BAR_FORMAT(n)	(((n) & 0x03) << 2)
 #define m_FC_RGC_YCC		(0x03 << 0)
-#define v_FC_RGC_YCC(n)		(((n)&0x03) << 0)
+#define v_FC_RGC_YCC(n)		(((n) & 0x03) << 0)
 
 #define	FC_AVICONF1			0x101a
 #define m_FC_COLORIMETRY	(0x03 << 6)
-#define v_FC_COLORIMETRY(n)	(((n)&0x03) << 6)
+#define v_FC_COLORIMETRY(n)	(((n) & 0x03) << 6)
 #define m_FC_PIC_ASPEC_RATIO	(0x03 << 4)
-#define v_FC_PIC_ASPEC_RATIO(n)	(((n)&0x03) << 4)
+#define v_FC_PIC_ASPEC_RATIO(n)	(((n) & 0x03) << 4)
 #define m_FC_ACT_ASPEC_RATIO	(0x0f << 0)
-#define v_FC_ACT_ASPEC_RATIO(n)	(((n)&0x0f) << 0)
+#define v_FC_ACT_ASPEC_RATIO(n)	(((n) & 0x0f) << 0)
 
 #define	FC_AVICONF2			0x101b
-#define m_FC_IT_CONTENT		(1 << 7)
-#define v_FC_IT_CONTENT(n)	(((n)&0x01) << 7)
+#define m_FC_IT_CONTENT		BIT(7)
+#define v_FC_IT_CONTENT(n)	(((n) & 0x01) << 7)
 #define m_FC_EXT_COLORIMETRY	(0x07 << 4)
-#define v_FC_EXT_COLORIMETRY(n)	(((n)&0x07) << 4)
+#define v_FC_EXT_COLORIMETRY(n)	(((n) & 0x07) << 4)
 #define m_FC_QUAN_RANGE		(0x03 << 2)
-#define v_FC_QUAN_RANGE(n)	(((n)&0x03) << 2)
+#define v_FC_QUAN_RANGE(n)	(((n) & 0x03) << 2)
 #define m_FC_NUN_PIC_SCALE	(0x03 << 0)
-#define v_FC_NUN_PIC_SCALE(n)	(((n)&0x03) << 0)
+#define v_FC_NUN_PIC_SCALE(n)	(((n) & 0x03) << 0)
 
 #define	FC_AVIVID			0x101c
-#define m_FC_AVIVID_H		(1 << 7)	/* use for HDMI2.0 TX */
-#define v_FC_AVIVID_H(n)	(((n)&0x01) << 7)
+#define m_FC_AVIVID_H		BIT(7)	/* use for HDMI2.0 TX */
+#define v_FC_AVIVID_H(n)	(((n) & 0x01) << 7)
 #define m_FC_AVIVID		(0x7f << 0)
-#define v_FC_AVIVID(n)		(((n)&0x7f) << 0)
+#define v_FC_AVIVID(n)		(((n) & 0x7f) << 0)
 
 #define	FC_AVIETB0			0x101d
 #define	FC_AVIETB1			0x101e
@@ -570,25 +582,25 @@ enum {
 
 #define	FC_AUDICONF0			0x1025
 #define m_FC_CHN_CNT		(0x07 << 4)
-#define v_FC_CHN_CNT(n)		(((n)&0x07) << 4)
-#define m_FC_CODING_TYEP	(0x0f << 0)
-#define v_FC_CODING_TYEP(n)	(((n)&0x0f) << 0)
+#define v_FC_CHN_CNT(n)		(((n) & 0x07) << 4)
+#define m_FC_CODING_TYPE	(0x0f << 0)
+#define v_FC_CODING_TYPE(n)	(((n) & 0x0f) << 0)
 
 #define	FC_AUDICONF1			0x1026
 #define m_FC_SAMPLE_SIZE	(0x03 << 4)
-#define v_FC_SAMPLE_SIZE(n)	(((n)&0x03) << 4)
+#define v_FC_SAMPLE_SIZE(n)	(((n) & 0x03) << 4)
 #define m_FC_SAMPLE_FREQ	(0x07 << 0)
-#define v_FC_SAMPLE_FREQ(n)	(((n)&0x07) << 0)
+#define v_FC_SAMPLE_FREQ(n)	(((n) & 0x07) << 0)
 
 #define	FC_AUDICONF2			0x1027
 
 #define	FC_AUDICONF3			0x1028
 #define m_FC_LFE_PBL		(0x03 << 5)	/*only use for HDMI1.4 TX*/
-#define v_FC_LFE_PBL(n)		(((n)&0x03) << 5)
-#define m_FC_DM_INH		(1 << 4)
-#define v_FC_DM_INH(n)		(((n)&0x01) << 4)
+#define v_FC_LFE_PBL(n)		(((n) & 0x03) << 5)
+#define m_FC_DM_INH		BIT(4)
+#define v_FC_DM_INH(n)		(((n) & 0x01) << 4)
 #define m_FC_LSV		(0x0f << 0)
-#define v_FC_LSV(n)		(((n)&0x0f) << 0)
+#define v_FC_LSV(n)		(((n) & 0x0f) << 0)
 
 #define	FC_VSDIEEEID2			0x1029
 #define	FC_VSDSIZE			0x102a
@@ -601,9 +613,9 @@ enum {
 
 #define	FC_AUDSCONF			0x1063
 #define m_AUD_PACK_SAMPFIT	(0x0f << 4)
-#define v_AUD_PACK_SAMPFIT(n)	(((n)&0x0f) << 4)
-#define m_AUD_PACK_LAYOUT	(1 << 0)
-#define v_AUD_PACK_LAYOUT(n)	(((n)&0x01) << 0)
+#define v_AUD_PACK_SAMPFIT(n)	(((n) & 0x0f) << 4)
+#define m_AUD_PACK_LAYOUT	BIT(0)
+#define v_AUD_PACK_LAYOUT(n)	(((n) & 0x01) << 0)
 
 #define	FC_AUDSSTAT			0x1064
 #define	FC_AUDSV			0x1065
@@ -628,12 +640,13 @@ enum {
 	AUDIO_192K	= 0xe,
 	AUDIO_768K	= 0x9,
 };
+
 #define m_AUDIO_SAMPLE_RATE		(0x0f << 0)
-#define v_AUDIO_SAMPLE_RATE(n)	(((n)&0x0f) << 0)
+#define v_AUDIO_SAMPLE_RATE(n)	(((n) & 0x0f) << 0)
 #define m_AUDIO_ORI_SAMPLE_RATE		(0x0f << 4)
-#define v_AUDIO_ORI_SAMPLE_RATE(n)	(((~n)&0x0f) << 4)
+#define v_AUDIO_ORI_SAMPLE_RATE(n)	(((~n) & 0x0f) << 4)
 #define m_AUDIO_WORD_LENGTH		(0x0f << 0)
-#define v_AUDIO_WORD_LENGTH(n)	(((n)&0x0f) << 0)
+#define v_AUDIO_WORD_LENGTH(n)	(((n) & 0x0f) << 0)
 
 #define	FC_CTRLQHIGH			0x1073
 #define	FC_CTRLQLOW			0x1074
@@ -644,41 +657,41 @@ enum {
 #define	FC_ISCR2_15			0x10a3	/* 15~0 */
 
 #define	FC_DATAUTO0			0x10b3
-#define m_SPD_AUTO		(1 << 4)
-#define v_SPD_AUTO(n)		(((n)&0x01) << 4)
-#define m_VSD_AUTO		(1 << 3)
-#define v_VSD_AUTO(n)		(((n)&0x01) << 3)
-#define m_ISCR2_AUTO		(1 << 2)
-#define v_ISCR2_AUTO(n)		(((n)&0x01) << 2)
-#define m_ISCR1_AUTO		(1 << 1)
-#define v_ISCR1_AUTO(n)		(((n)&0x01) << 1)
-#define m_ACP_AUTO		(1 << 0)
-#define v_ACP_AUTO(n)		(((n)&0x01) << 0)
+#define m_SPD_AUTO		BIT(4)
+#define v_SPD_AUTO(n)		(((n) & 0x01) << 4)
+#define m_VSD_AUTO		BIT(3)
+#define v_VSD_AUTO(n)		(((n) & 0x01) << 3)
+#define m_ISCR2_AUTO		BIT(2)
+#define v_ISCR2_AUTO(n)		(((n) & 0x01) << 2)
+#define m_ISCR1_AUTO		BIT(1)
+#define v_ISCR1_AUTO(n)		(((n) & 0x01) << 1)
+#define m_ACP_AUTO		BIT(0)
+#define v_ACP_AUTO(n)		(((n) & 0x01) << 0)
 
 #define	FC_DATAUTO1			0x10b4
 #define	FC_DATAUTO2			0x10b5
 
 #define	FC_DATMAN			0x10b6
-#define m_SPD_MAN		(1 << 4)
-#define v_SPD_MAN(n)		(((n)&0x01) << 4)
-#define m_VSD_MAN		(1 << 3)
-#define v_VSD_MAN(n)		(((n)&0x01) << 3)
-#define m_ISCR2_MAN		(1 << 2)
-#define v_ISCR2_MAN(n)		(((n)&0x01) << 2)
-#define m_ISCR1_MAN		(1 << 1)
-#define v_ISCR1_MAN(n)		(((n)&0x01) << 1)
-#define m_ACP_MAN		(1 << 0)
-#define v_ACP_MAN(n)		(((n)&0x01) << 0)
+#define m_SPD_MAN		BIT(4)
+#define v_SPD_MAN(n)		(((n) & 0x01) << 4)
+#define m_VSD_MAN		BIT(3)
+#define v_VSD_MAN(n)		(((n) & 0x01) << 3)
+#define m_ISCR2_MAN		BIT(2)
+#define v_ISCR2_MAN(n)		(((n) & 0x01) << 2)
+#define m_ISCR1_MAN		BIT(1)
+#define v_ISCR1_MAN(n)		(((n) & 0x01) << 1)
+#define m_ACP_MAN		BIT(0)
+#define v_ACP_MAN(n)		(((n) & 0x01) << 0)
 
 #define	FC_DATAUTO3			0x10b7
-	#define m_AVI_AUTO		(1 << 3)
-	#define v_AVI_AUTO(n)		(((n)&0x01) << 3)
-	#define m_GCP_AUTO		(1 << 2)
-	#define v_GCP_AUTO(n)		(((n)&0x01) << 2)
-	#define m_AAI_AUTO		(1 << 1)
-	#define v_AAI_AUTO(n)		(((n)&0x01) << 1)
-	#define m_ACR_AUTO		(1 << 0)
-	#define v_ACR_AUTO(n)		(((n)&0x01) << 0)
+	#define m_AVI_AUTO		BIT(3)
+	#define v_AVI_AUTO(n)		(((n) & 0x01) << 3)
+	#define m_GCP_AUTO		BIT(2)
+	#define v_GCP_AUTO(n)		(((n) & 0x01) << 2)
+	#define m_AAI_AUTO		BIT(1)
+	#define v_AAI_AUTO(n)		(((n) & 0x01) << 1)
+	#define m_ACR_AUTO		BIT(0)
+	#define v_ACR_AUTO(n)		(((n) & 0x01) << 0)
 #define	FC_RDRB0			0x10b8
 #define	FC_RDRB1			0x10b9
 #define	FC_RDRB2			0x10ba
@@ -697,15 +710,15 @@ enum {
 
 #define	FC_PRCONF			0x10e0
 #define m_FC_PR_FACTOR		(0x0f << 4)
-#define v_FC_PR_FACTOR(n)	(((n)&0x0f) << 4)
+#define v_FC_PR_FACTOR(n)	(((n) & 0x0f) << 4)
 #define m_FC_PR_FACTOR_OUT	(0x0f)
 #define v_FC_PR_FACTOR_OUT(n)	((n) & 0x0f)
 
 #define	FC_SCRAMBLER_CTRL		0x10e1
-#define m_FC_SCRAMBLE_UCP	(1 << 4)
-#define v_FC_SCRAMBLE_UCP(n)	(((n)&0x01) << 4)
-#define m_FC_SCRAMBLE_EN	(1 << 0)
-#define v_FC_SCRAMBLE_EN(n)	(((n)&0x01) << 0)
+#define m_FC_SCRAMBLE_UCP	BIT(4)
+#define v_FC_SCRAMBLE_UCP(n)	(((n) & 0x01) << 4)
+#define m_FC_SCRAMBLE_EN	BIT(0)
+#define v_FC_SCRAMBLE_EN(n)	(((n) & 0x01) << 0)
 
 #define	FC_GMD_STAT			0x1100
 #define	FC_GMD_EN			0x1101
@@ -715,10 +728,10 @@ enum {
 #define	FC_GMD_PB0			0x1105	/*0~27*/
 
 #define FC_DBGFORCE			0x1200
-#define m_FC_FORCEAUDIO		(1 << 4)
-#define v_FC_FORCEAUDIO(n)	(((n)&0x01) << 4)
-#define m_FC_FORCEVIDEO		(1 << 0)
-#define v_FC_FORCEVIDEO(n)	(((n)&0x01) << 0)
+#define m_FC_FORCEAUDIO		BIT(4)
+#define v_FC_FORCEAUDIO(n)	(((n) & 0x01) << 4)
+#define m_FC_FORCEVIDEO		BIT(0)
+#define v_FC_FORCEVIDEO(n)	(((n) & 0x01) << 0)
 
 #define	FC_DBGAUD0CH0			0x1201	/* aud0~aud2 ch0 */
 #define	FC_DBGAUD0CH1			0x1204	/* aud0~aud2 ch1 */
@@ -736,30 +749,30 @@ enum {
 #define HDMI_SOURCE_PHY_BASE		0x3000
 
 #define PHY_CONF0			0x3000
-#define m_POWER_DOWN_EN		(1 << 7)/* no use */
-#define v_POWER_DOWN_EN(n)	(((n)&0x01) << 7)
-#define m_TMDS_EN		(1 << 6)/* no use */
-#define v_TMDS_EN(n)		(((n)&0x01) << 6)
-#define	m_SVSRET_SIG		(1 << 5)/* depend on PHY_MHL_COMB0=1 */
-#define v_SVSRET_SIG(n)		(((n)&0x01) << 5)
-#define m_PDDQ_SIG		(1 << 4)
+#define m_POWER_DOWN_EN		BIT(7)/* no use */
+#define v_POWER_DOWN_EN(n)	(((n) & 0x01) << 7)
+#define m_TMDS_EN		BIT(6)/* no use */
+#define v_TMDS_EN(n)		(((n) & 0x01) << 6)
+#define	m_SVSRET_SIG		BIT(5)/* depend on PHY_MHL_COMB0=1 */
+#define v_SVSRET_SIG(n)		(((n) & 0x01) << 5)
+#define m_PDDQ_SIG		BIT(4)
 /*1: power down phy; 0: power on phy */
-#define v_PDDQ_SIG(n)		(((n)&0x01) << 4)
-#define m_TXPWRON_SIG		(1 << 3)
+#define v_PDDQ_SIG(n)		(((n) & 0x01) << 4)
+#define m_TXPWRON_SIG		BIT(3)
 /*1: power on transmitter; 0: power down transmitter */
-#define v_TXPWRON_SIG(n)	(((n)&0x01) << 3)
-#define m_ENHPD_RXSENSE_SIG	(1 << 2)
+#define v_TXPWRON_SIG(n)	(((n) & 0x01) << 3)
+#define m_ENHPD_RXSENSE_SIG	BIT(2)
 /*1: enable detect hdp & rx sense */
-#define v_ENHPD_RXSENSE_SIG(n)	(((n)&0x01) << 2)
-#define m_SEL_DATAEN_POL	(1 << 1)
-#define v_SEL_DATAEN_POL(n)	(((n)&0x01) << 1)
-#define m_SEL_INTERFACE		(1 << 0)
-#define v_SEL_INTERFACE(n)	(((n)&0x01) << 0)
+#define v_ENHPD_RXSENSE_SIG(n)	(((n) & 0x01) << 2)
+#define m_SEL_DATAEN_POL	BIT(1)
+#define v_SEL_DATAEN_POL(n)	(((n) & 0x01) << 1)
+#define m_SEL_INTERFACE		BIT(0)
+#define v_SEL_INTERFACE(n)	(((n) & 0x01) << 0)
 
 #define PHY_TST0			0x3001
-#define m_TEST_CLR_SIG		(1 << 5)
-#define m_TEST_EN_SIG		(1 << 4)
-#define m_TEST_CLK_SIG		(1 << 0)
+#define m_TEST_CLR_SIG		BIT(5)
+#define m_TEST_EN_SIG		BIT(4)
+#define m_TEST_CLK_SIG		BIT(0)
 
 #define PHY_TST1			0x3002
 #define PHY_TST2			0x3003
@@ -767,18 +780,18 @@ enum {
 #define PHY_INI0			0x3005
 #define PHY_MASK			0x3006
 #define PHY_POL0			0x3007
-#define m_PHY_RX_SENSE3		(1 << 7)
-#define v_PHY_TX_SENSE3(n)	(((n)&0x01) << 7)
-#define m_PHY_RX_SENSE2		(1 << 6)
-#define v_PHY_TX_SENSE2(n)      (((n)&0x01) << 6)
-#define m_PHY_RX_SENSE1		(1 << 5)
-#define v_PHY_TX_SENSE1(n)      (((n)&0x01) << 5)
-#define m_PHY_RX_SENSE0		(1 << 4)
-#define v_PHY_TX_SENSE0(n)      (((n)&0x01) << 4)
-#define m_PHY_HPD		(1 << 1)
-#define v_PHY_HPD		(((n)&0x01) << 1)
-#define m_PHY_LOCK		(1 << 0)
-#define v_PHY_LOCK(n)		(((n)&0x01) << 0)
+#define m_PHY_RX_SENSE3		BIT(7)
+#define v_PHY_TX_SENSE3(n)	(((n) & 0x01) << 7)
+#define m_PHY_RX_SENSE2		BIT(6)
+#define v_PHY_TX_SENSE2(n)      (((n) & 0x01) << 6)
+#define m_PHY_RX_SENSE1		BIT(5)
+#define v_PHY_TX_SENSE1(n)      (((n) & 0x01) << 5)
+#define m_PHY_RX_SENSE0		BIT(4)
+#define v_PHY_TX_SENSE0(n)      (((n) & 0x01) << 4)
+#define m_PHY_HPD		BIT(1)
+#define v_PHY_HPD		(((n) & 0x01) << 1)
+#define m_PHY_LOCK		BIT(0)
+#define v_PHY_LOCK(n)		(((n) & 0x01) << 0)
 
 #define PHY_PCLFREQ0			0x3008
 #define PHY_PCLFREQ1			0x3009
@@ -801,38 +814,38 @@ enum {
 #define	PHY_I2CM_DATAI_0		0x3025
 
 #define	PHY_I2CM_OPERATION		0x3026
-#define m_PHY_I2CM_WRITE	(1 << 4)
-#define m_PHY_I2CM_READ		(1 << 0)
+#define m_PHY_I2CM_WRITE	BIT(4)
+#define m_PHY_I2CM_READ		BIT(0)
 
 #define	PHY_I2CM_INT			0x3027
-#define m_PHY_I2CM_DONE_INT_POL	(1 << 3)
-#define v_PHY_I2CM_DONE_INT_POL(n) (((n)&0x01) << 3)
-#define m_PHY_I2CM_DONE_MASK	(1 << 2)
-#define v_PHY_I2CM_DONE_MASK(n)	(((n)&0x01) << 2)
-#define m_PHY_I2CM_DONE_INT	(1 << 1)
-#define m_PHY_I2CM_DONE_STATUS	(1 << 0)
+#define m_PHY_I2CM_DONE_INT_POL	BIT(3)
+#define v_PHY_I2CM_DONE_INT_POL(n) (((n) & 0x01) << 3)
+#define m_PHY_I2CM_DONE_MASK	BIT(2)
+#define v_PHY_I2CM_DONE_MASK(n)	(((n) & 0x01) << 2)
+#define m_PHY_I2CM_DONE_INT	BIT(1)
+#define m_PHY_I2CM_DONE_STATUS	BIT(0)
 
 #define	PHY_I2CM_CTLINT			0x3028
-#define m_PHY_I2CM_NACK_POL	(1 << 7)
-#define v_PHY_I2CM_NACK_POL(n)	(((n)&0x01) << 7)
-#define m_PHY_I2CM_NACK_MASK	(1 << 6)
-#define v_PHY_I2CM_NACK_MASK(n)	(((n)&0x01) << 6)
-#define m_PHY_I2CM_NACK_INT	(1 << 5)
-#define m_PHY_I2CM_NACK_STATUS	(1 << 4)
-#define m_PHY_I2CM_ARB_POL	(1 << 3)
-#define v_PHY_I2CM_ARB_POL(n)	(((n)&0x01) << 3)
-#define m_PHY_I2CM_ARB_MASK	(1 << 2)
-#define v_PHY_I2CM_ARB_MASK(n)	(((n)&0x01) << 2)
-#define m_PHY_I2CM_ARB_INT	(1 << 1)
-#define m_PHY_I2CM_ARB_STATUS	(1 << 0)
+#define m_PHY_I2CM_NACK_POL	BIT(7)
+#define v_PHY_I2CM_NACK_POL(n)	(((n) & 0x01) << 7)
+#define m_PHY_I2CM_NACK_MASK	BIT(6)
+#define v_PHY_I2CM_NACK_MASK(n)	(((n) & 0x01) << 6)
+#define m_PHY_I2CM_NACK_INT	BIT(5)
+#define m_PHY_I2CM_NACK_STATUS	BIT(4)
+#define m_PHY_I2CM_ARB_POL	BIT(3)
+#define v_PHY_I2CM_ARB_POL(n)	(((n) & 0x01) << 3)
+#define m_PHY_I2CM_ARB_MASK	BIT(2)
+#define v_PHY_I2CM_ARB_MASK(n)	(((n) & 0x01) << 2)
+#define m_PHY_I2CM_ARB_INT	BIT(1)
+#define m_PHY_I2CM_ARB_STATUS	BIT(0)
 
 #define	PHY_I2CM_DIV			0x3029
-#define m_PHY_I2CM_FAST_STD	(1 << 3)
-#define v_PHY_I2CM_FAST_STD(n)	(((n)&0x01) << 3)
+#define m_PHY_I2CM_FAST_STD	BIT(3)
+#define v_PHY_I2CM_FAST_STD(n)	(((n) & 0x01) << 3)
 
 #define	PHY_I2CM_SOFTRSTZ		0x302a
-#define m_PHY_I2CM_SOFTRST	(1 << 0)
-#define v_PHY_I2CM_SOFTRST(n)	(((n)&0x01) << 0)
+#define m_PHY_I2CM_SOFTRST	BIT(0)
+#define v_PHY_I2CM_SOFTRST(n)	(((n) & 0x01) << 0)
 
 #define	PHY_I2CM_SS_SCL_HCNT_1_ADDR	0x302b
 #define	PHY_I2CM_SS_SCL_HCNT_0_ADDR	0x302c
@@ -848,22 +861,24 @@ enum {
 #define AUDIO_SAMPLER_BASE		0x3100
 
 #define AUD_CONF0			0x3100
-#define m_SW_AUD_FIFO_RST	(1 << 7)
-#define v_SW_AUD_FIFO_RST(n)	(((n)&0x01) << 7)
+#define m_SW_AUD_FIFO_RST	BIT(7)
+#define v_SW_AUD_FIFO_RST(n)	(((n) & 0x01) << 7)
 enum {
 	AUDIO_SPDIF_GPA = 0,
 	AUDIO_I2S
 };
-#define m_I2S_SEL		(1 << 5)
-#define v_I2S_SEL(n)		(((n)&0x01) << 5)
+
+#define m_I2S_SEL		BIT(5)
+#define v_I2S_SEL(n)		(((n) & 0x01) << 5)
 enum {
 	I2S_CHANNEL_1_2 = 1,
 	I2S_CHANNEL_3_4 = 3,
 	I2S_CHANNEL_5_6 = 7,
 	I2S_CHANNEL_7_8 = 0xf
 };
+
 #define m_I2S_IN_EN		(0x0f << 0)
-#define v_I2S_IN_EN(n)		(((n)&0x0f) << 0)
+#define v_I2S_IN_EN(n)		(((n) & 0x0f) << 0)
 
 #define AUD_CONF1			0x3101
 enum I2S_MODE {
@@ -873,8 +888,9 @@ enum I2S_MODE {
 	I2S_BURST_1_MODE,
 	I2S_BURST_2_MODE
 };
+
 #define m_I2S_MODE		(0x07 << 5)
-#define v_I2S_MODE(n)		(((n)&0x07) << 5)
+#define v_I2S_MODE(n)		(((n) & 0x07) << 5)
 enum I2S_WIDTH {
 	I2S_16BIT_SAMPLE = 16,
 	I2S_17BIT_SAMPLE,
@@ -886,26 +902,27 @@ enum I2S_WIDTH {
 	I2S_23BIT_SAMPLE,
 	I2S_24BIT_SAMPLE,
 };
+
 #define m_I2S_WIDTH		(0x1f << 0)
-#define v_I2S_WIDTH(n)		(((n)&0x1f) << 0)
+#define v_I2S_WIDTH(n)		(((n) & 0x1f) << 0)
 
 #define AUD_INT				0x3102
 #define AUD_SPDIFINT			0x3302
-#define m_FIFO_EMPTY_MASK	(1 << 3)
-#define v_FIFO_EMPTY_MASK(n)	(((n)&0x01) << 3)
-#define m_FIFO_FULL_MASK	(1 << 2)
-#define v_FIFO_FULL_MASK(n)	(((n)&0x01) << 2)
+#define m_FIFO_EMPTY_MASK	BIT(3)
+#define v_FIFO_EMPTY_MASK(n)	(((n) & 0x01) << 3)
+#define m_FIFO_FULL_MASK	BIT(2)
+#define v_FIFO_FULL_MASK(n)	(((n) & 0x01) << 2)
 
 #define AUD_CONF2			0x3103
-#define m_NLPCM_EN		(1 << 1)
-#define v_NLPCM_EN(n)		(((n)&0x01) << 1)
-#define m_HBR_EN		(1 << 0)
-#define v_HBR_EN(n)		(((n)&0x01) << 0)
+#define m_NLPCM_EN		BIT(1)
+#define v_NLPCM_EN(n)		(((n) & 0x01) << 1)
+#define m_HBR_EN		BIT(0)
+#define v_HBR_EN(n)		(((n) & 0x01) << 0)
 
 #define AUD_INT1			0x3104
 #define AUD_SPDIFINT1			0x3303
-#define m_FIFO_OVERRUN_MASK	(1 << 4)
-#define v_FIFO_OVERRUN_MASK(n)	(((n)&0x01) << 4)
+#define m_FIFO_OVERRUN_MASK	BIT(4)
+#define v_FIFO_OVERRUN_MASK(n)	(((n) & 0x01) << 4)
 
 /***************N-CTS Table**************/
 /*	TMDS LOWCLK:	<=148.5M	*/
@@ -940,10 +957,10 @@ enum I2S_WIDTH {
 #define AUD_N2				0x3201
 
 #define AUD_N3				0x3202
-#define m_NCTS_ATOMIC_WR	(1 << 7)
-#define v_NCTS_ATOMIC_WR(n)	(((n)&0x01) << 7)
+#define m_NCTS_ATOMIC_WR	BIT(7)
+#define v_NCTS_ATOMIC_WR(n)	(((n) & 0x01) << 7)
 #define m_AUD_N3		(0x0f << 0)
-#define v_AUD_N3(n)		(((n)&0x0f) << 0)
+#define v_AUD_N3(n)		(((n) & 0x0f) << 0)
 
 #define AUD_CTS1			0x3203
 #define AUD_CTS2			0x3204
@@ -958,12 +975,13 @@ enum {
 	N_SHIFT_256,
 	N_SHIFT_OTHERS_128
 };
+
 #define m_N_SHIFT		(0x07 << 5)
-#define v_N_SHIFT(n)		(((n)&0x07) << 5)
-#define m_CTS_MANUAL		(1 << 4)
-#define v_CTS_MANUAL(n)		(((n)&0x01) << 4)
+#define v_N_SHIFT(n)		(((n) & 0x07) << 5)
+#define m_CTS_MANUAL		BIT(4)
+#define v_CTS_MANUAL(n)		(((n) & 0x01) << 4)
 #define m_AUD_CTS3		(0x0f << 0)
-#define v_AUD_CTS3(n)		(((n)&0x0f) << 0)
+#define v_AUD_CTS3(n)		(((n) & 0x0f) << 0)
 
 #define AUD_INPUTCLKFS			0x3206
 enum {
@@ -973,24 +991,26 @@ enum {
 	FS_64 = 4,
 	FS_OTHERS_128
 };
+
 #define m_LFS_FACTOR		(0x07 << 0)
-#define v_LFS_FACTOR(n)		(((n)&0x07) << 0)
+#define v_LFS_FACTOR(n)		(((n) & 0x07) << 0)
 
 #define AUD_SPDIF0			0x3300
-#define m_SW_SAUD_FIFO_RST	(1 << 7)
-#define v_SW_SAUD_FIFO_RST(n)	(((n)&0x01) << 7)
+#define m_SW_SAUD_FIFO_RST	BIT(7)
+#define v_SW_SAUD_FIFO_RST(n)	(((n) & 0x01) << 7)
 
 #define AUD_SPDIF1			0x3301
 enum {
 	PCM_LINEAR = 0,
 	PCM_NONLINEAR
 };
-#define m_SET_NLPCM		(1 << 7)
-#define v_SET_NLPCM(n)		(((n)&0x01) << 7)
-#define m_SPDIF_HBR_MODE	(1 << 6)
-#define v_SPDIF_HBR_MODE(n)	(((n)&0x01) << 6)
+
+#define m_SET_NLPCM		BIT(7)
+#define v_SET_NLPCM(n)		(((n) & 0x01) << 7)
+#define m_SPDIF_HBR_MODE	BIT(6)
+#define v_SPDIF_HBR_MODE(n)	(((n) & 0x01) << 6)
 #define m_SPDIF_WIDTH		(0x1f << 0)
-#define v_SPDIF_WIDTH(n)	(((n)&0x1f) << 0)
+#define v_SPDIF_WIDTH(n)	(((n) & 0x1f) << 0)
 
 /* Generic Parallel Audio Interface Registers */
 #define GP_AUDIO_INTERFACE_BASE		0x3500
@@ -1024,91 +1044,91 @@ enum {
 #define MAIN_CONTROLLER_BASE		0x4000
 
 #define MC_CLKDIS			0x4001
-#define m_HDCPCLK_DISABLE	(1 << 6)
-#define v_HDCPCLK_DISABLE(n)	(((n)&0x01) << 6)
-#define m_CECCLK_DISABLE	(1 << 5)
-#define v_CECCLK_DISABLE(n)	(((n)&0x01) << 5)
-#define m_CSCCLK_DISABLE	(1 << 4)
-#define v_CSCCLK_DISABLE(n)	(((n)&0x01) << 4)
-#define m_AUDCLK_DISABLE        (1 << 3)
-#define v_AUDCLK_DISABLE(n)     (((n)&0x01) << 3)
-#define m_PREPCLK_DISABLE	(1 << 2)
-#define v_PREPCLK_DISABLE(n)	(((n)&0x01) << 2)
-#define m_TMDSCLK_DISABLE	(1 << 1)
-#define v_TMDSCLK_DISABLE(n)	(((n)&0x01) << 1)
-#define m_PIXELCLK_DISABLE	(1 << 0)
-#define v_PIXELCLK_DISABLE(n)	(((n)&0x01) << 0)
+#define m_HDCPCLK_DISABLE	BIT(6)
+#define v_HDCPCLK_DISABLE(n)	(((n) & 0x01) << 6)
+#define m_CECCLK_DISABLE	BIT(5)
+#define v_CECCLK_DISABLE(n)	(((n) & 0x01) << 5)
+#define m_CSCCLK_DISABLE	BIT(4)
+#define v_CSCCLK_DISABLE(n)	(((n) & 0x01) << 4)
+#define m_AUDCLK_DISABLE        BIT(3)
+#define v_AUDCLK_DISABLE(n)     (((n) & 0x01) << 3)
+#define m_PREPCLK_DISABLE	BIT(2)
+#define v_PREPCLK_DISABLE(n)	(((n) & 0x01) << 2)
+#define m_TMDSCLK_DISABLE	BIT(1)
+#define v_TMDSCLK_DISABLE(n)	(((n) & 0x01) << 1)
+#define m_PIXELCLK_DISABLE	BIT(0)
+#define v_PIXELCLK_DISABLE(n)	(((n) & 0x01) << 0)
 
 #define MC_SWRSTZREQ			0x4002
-#define m_IGPA_SWRST		(1 << 7)
-#define v_IGPA_SWRST(n)		(((n)&0x01) << 7)
-#define m_CEC_SWRST		(1 << 6)
-#define v_CEC_SWRST(n)		(((n)&0x01) << 6)
-#define m_ISPDIF_SWRST          (1 << 4)
-#define v_ISPDIF_SWRST(n)       (((n)&0x01) << 4)
-#define m_II2S_SWRST            (1 << 3)
-#define v_II2S_SWRST(n)         (((n)&0x01) << 3)
-#define m_PREP_SWRST            (1 << 2)
-#define v_PREP_SWRST(n)         (((n)&0x01) << 2)
-#define m_TMDS_SWRST		(1 << 1)
-#define v_TMDS_SWRST(n)		(((n)&0x01) << 1)
-#define m_PIXEL_SWRST           (1 << 0)
-#define v_PIXEL_SWRST(n)        (((n)&0x01) << 0)
+#define m_IGPA_SWRST		BIT(7)
+#define v_IGPA_SWRST(n)		(((n) & 0x01) << 7)
+#define m_CEC_SWRST		BIT(6)
+#define v_CEC_SWRST(n)		(((n) & 0x01) << 6)
+#define m_ISPDIF_SWRST          BIT(4)
+#define v_ISPDIF_SWRST(n)       (((n) & 0x01) << 4)
+#define m_II2S_SWRST            BIT(3)
+#define v_II2S_SWRST(n)         (((n) & 0x01) << 3)
+#define m_PREP_SWRST            BIT(2)
+#define v_PREP_SWRST(n)         (((n) & 0x01) << 2)
+#define m_TMDS_SWRST		BIT(1)
+#define v_TMDS_SWRST(n)		(((n) & 0x01) << 1)
+#define m_PIXEL_SWRST           BIT(0)
+#define v_PIXEL_SWRST(n)        (((n) & 0x01) << 0)
 
 #define MC_OPCTRL			0x4003
-#define m_HDCP_BLOCK_BYP	(1 << 0)
-#define v_HDCP_BLOCK_BYP(n)	(((n)&0x01) << 0)
+#define m_HDCP_BLOCK_BYP	BIT(0)
+#define v_HDCP_BLOCK_BYP(n)	(((n) & 0x01) << 0)
 
 #define MC_FLOWCTRL			0x4004
-#define m_FEED_THROUGH_OFF      (1 << 0)
-#define v_FEED_THROUGH_OFF(n)   (((n)&0x01) << 0)
+#define m_FEED_THROUGH_OFF      BIT(0)
+#define v_FEED_THROUGH_OFF(n)   (((n) & 0x01) << 0)
 
 #define MC_PHYRSTZ			0x4005
-#define m_PHY_RSTZ		(1 << 0)
-#define v_PHY_RSTZ(n)		(((n)&0x01) << 0)
+#define m_PHY_RSTZ		BIT(0)
+#define v_PHY_RSTZ(n)		(((n) & 0x01) << 0)
 
 #define MC_LOCKONCLOCK			0x4006
-#define m_IGPACLK_ON		(1 << 7)
-#define v_IGPACLK_ON(n)		(((n)&0x01) << 7)
-#define m_PCLK_ON		(1 << 6)
-#define v_PCLK_ON(n)		(((n)&0x01) << 6)
-#define m_TMDSCLK_ON            (1 << 5)
-#define v_TMDSCLK_ON(n)         (((n)&0x01) << 5)
-#define m_PREPCLK_ON            (1 << 4)
-#define v_PREPCLK_ON(n)         (((n)&0x01) << 4)
-#define m_I2SCLK_ON		(1 << 3)
-#define v_I2SCLK_ON(n)		(((n)&0x01) << 3)
-#define m_SPDIFCLK_ON           (1 << 2)
-#define v_SPDIFCLK_ON(n)	(((n)&0x01) << 2)
-#define m_CECCLK_ON		(1 << 0)
-#define v_CECCLK_ON(n)		(((n)&0x01) << 0)
+#define m_IGPACLK_ON		BIT(7)
+#define v_IGPACLK_ON(n)		(((n) & 0x01) << 7)
+#define m_PCLK_ON		BIT(6)
+#define v_PCLK_ON(n)		(((n) & 0x01) << 6)
+#define m_TMDSCLK_ON            BIT(5)
+#define v_TMDSCLK_ON(n)         (((n) & 0x01) << 5)
+#define m_PREPCLK_ON            BIT(4)
+#define v_PREPCLK_ON(n)         (((n) & 0x01) << 4)
+#define m_I2SCLK_ON		BIT(3)
+#define v_I2SCLK_ON(n)		(((n) & 0x01) << 3)
+#define m_SPDIFCLK_ON           BIT(2)
+#define v_SPDIFCLK_ON(n)	(((n) & 0x01) << 2)
+#define m_CECCLK_ON		BIT(0)
+#define v_CECCLK_ON(n)		(((n) & 0x01) << 0)
 
 #define MC_HEACPHY_RST			0x4007
-#define m_HEAC_PHY_RST		(1 << 0)
-#define v_HEAC_PHY_RST(n)	(((n)&0x01) << 0)
+#define m_HEAC_PHY_RST		BIT(0)
+#define v_HEAC_PHY_RST(n)	(((n) & 0x01) << 0)
 
 #define MC_LOCKONCLOCK_2		0x4009
-#define m_AHB_AUD_DMA_CLK       (1 << 0)
-#define v_AHB_AUD_DMA_CLK(n)    (((n)&0x01) << 0)
+#define m_AHB_AUD_DMA_CLK       BIT(0)
+#define v_AHB_AUD_DMA_CLK(n)    (((n) & 0x01) << 0)
 
 #define MC_SWRSTZREQ_2			0x400a
-#define m_AHB_AUD_DMA_RST       (1 << 7)
-#define v_AHB_AUD_DMA_RST(n)    (((n)&0x01) << 7)
+#define m_AHB_AUD_DMA_RST       BIT(7)
+#define v_AHB_AUD_DMA_RST(n)    (((n) & 0x01) << 7)
 
 /* Color Space Converter Registers */
 #define COLOR_SPACE_CONVERTER_BASE	0x4100
 
 #define	CSC_CFG				0x4100
 #define m_CSC_INTPMODE		(0x03 << 4)
-#define v_CSC_INTPMODE(n)	(((n)&0x03) << 4)
+#define v_CSC_INTPMODE(n)	(((n) & 0x03) << 4)
 #define m_CSC_DECIMODE		(0x03 << 0)
-#define v_CSC_DECIMODE(n)	(((n)&0x03) << 0)
+#define v_CSC_DECIMODE(n)	(((n) & 0x03) << 0)
 
 #define	CSC_SCALE			0x4101
 #define m_CSC_COLOR_DEPTH	(0x0f << 4)
-#define v_CSC_COLOR_DEPTH(n)	(((n)&0x0f) << 4)
+#define v_CSC_COLOR_DEPTH(n)	(((n) & 0x0f) << 4)
 #define m_CSC_SCALE		(0x03 << 0)
-#define v_CSC_SCALE(n)		(((n)&0x03) << 0)
+#define v_CSC_SCALE(n)		(((n) & 0x03) << 0)
 
 #define	CSC_COEF_A1_MSB			0x4102
 #define	CSC_COEF_A1_LSB			0x4103
@@ -1141,38 +1161,38 @@ enum {
 #define HDCP_ENCRYPTION_ENGINE_BASE	0x5000
 
 #define	A_HDCPCFG0			0x5000
-#define m_HDCP_ENHANCE_LIKE	(1 << 7)
-#define v_HDCP_ENHANCE_LIKE(n)	(((n)&0x01) << 7)
-#define m_I2C_FAST_MODE		(1 << 6)
-#define v_I2C_FAST_MODE(n)	(((n)&0x01) << 6)
-#define m_ENCRYPT_BYPASS	(1 << 5)
-#define v_ENCRYPT_BYPASS(n)	(((n)&0x01) << 5)
-#define m_SYNC_RI_CHECK		(1 << 4)
-#define v_SYNC_RI_CHECK(n)	(((n)&0x01) << 4)
-#define m_AVMUTE		(1 << 3)
-#define m_RX_DETECT		(1 << 2)
-#define v_RX_DETECT(n)		(((n)&0x01) << 2)
-#define m_FEATURE11_EN		(1 << 1)
-#define v_FEATURE11_EN(n)	(((n)&0x01) << 1)
-#define m_HDMI_DVI		(1 << 0)
-#define v_HDMI_DVI(n)		(((n)&0x01) << 0)
+#define m_HDCP_ENHANCE_LIKE	BIT(7)
+#define v_HDCP_ENHANCE_LIKE(n)	(((n) & 0x01) << 7)
+#define m_I2C_FAST_MODE		BIT(6)
+#define v_I2C_FAST_MODE(n)	(((n) & 0x01) << 6)
+#define m_ENCRYPT_BYPASS	BIT(5)
+#define v_ENCRYPT_BYPASS(n)	(((n) & 0x01) << 5)
+#define m_SYNC_RI_CHECK		BIT(4)
+#define v_SYNC_RI_CHECK(n)	(((n) & 0x01) << 4)
+#define m_AVMUTE		BIT(3)
+#define m_RX_DETECT		BIT(2)
+#define v_RX_DETECT(n)		(((n) & 0x01) << 2)
+#define m_FEATURE11_EN		BIT(1)
+#define v_FEATURE11_EN(n)	(((n) & 0x01) << 1)
+#define m_HDMI_DVI		BIT(0)
+#define v_HDMI_DVI(n)		(((n) & 0x01) << 0)
 
 #define	A_HDCPCFG1			0x5001
-#define m_HDCP_LOCK		(1 << 4)
-#define v_HDCP_LOCK(n)		(((n)&0x01) << 4)
-#define m_SHA1_CHECK_DISABLE	(1 << 3)
-#define v_SHA1_CHECK_DISBALE(n)	(((n)&0x01) << 3)
-#define m_PH2UPSHFTENC		(1 << 2)
-#define v_PH2UPSHFTENC(n)	(((n)&0x01) << 2)
-#define m_ENCRYPT_DISBALE	(1 << 1)
-#define v_ENCRYPT_DISBALE(n)	(((n)&0x01) << 1)
-#define m_HDCP_SW_RST		(1 << 0)
-#define v_HDCP_SW_RST(n)	(((n)&0x01) << 0)
+#define m_HDCP_LOCK		BIT(4)
+#define v_HDCP_LOCK(n)		(((n) & 0x01) << 4)
+#define m_SHA1_CHECK_DISABLE	BIT(3)
+#define v_SHA1_CHECK_DISBALE(n)	(((n) & 0x01) << 3)
+#define m_PH2UPSHFTENC		BIT(2)
+#define v_PH2UPSHFTENC(n)	(((n) & 0x01) << 2)
+#define m_ENCRYPT_DISBALE	BIT(1)
+#define v_ENCRYPT_DISBALE(n)	(((n) & 0x01) << 1)
+#define m_HDCP_SW_RST		BIT(0)
+#define v_HDCP_SW_RST(n)	(((n) & 0x01) << 0)
 
 #define	A_HDCPOBS0			0x5002
 #define m_STATE_AUTH		(0x0f << 4)
 #define m_SUB_STATE_AUTH	(0x07 << 1)
-#define m_STATE_HDCP_ENGAGED	(1 << 0)
+#define m_STATE_HDCP_ENGAGED	BIT(0)
 
 #define	A_HDCPOBS1			0x5003
 #define m_STATE_OESS		(0x07 << 3)
@@ -1183,56 +1203,56 @@ enum {
 #define m_STATE_EESS		(0x07 << 0)
 
 #define	A_HDCPOBS3			0x5005
-#define m_BCAP_REPEATER		(1 << 6)
-#define m_BCAP_KSVFIFO_READY	(1 << 5)
-#define m_BCAP_FAST_I2C		(1 << 4)
-#define m_BCAP_HDMI_MODE	(1 << 2)
-#define m_BCAP_FEATURES11	(1 << 1)
-#define m_BCAP_FAST_REAUTH	(1 << 0)
+#define m_BCAP_REPEATER		BIT(6)
+#define m_BCAP_KSVFIFO_READY	BIT(5)
+#define m_BCAP_FAST_I2C		BIT(4)
+#define m_BCAP_HDMI_MODE	BIT(2)
+#define m_BCAP_FEATURES11	BIT(1)
+#define m_BCAP_FAST_REAUTH	BIT(0)
 
 #define	A_APIINTCLR			0x5006
 #define	A_APIINTSTAT			0x5007
 #define	A_APIINTMSK			0x5008
-#define m_HDCP_ENGAGED		(1 << 7)
-#define m_HDCP_FAILED		(1 << 6)
-#define m_HDCP_I2C_NOACK	(1 << 4)
-#define m_HDCP_LOST_ARBI	(1 << 3)
-#define m_KEEP_ERR_INT		(1 << 2)
-#define m_KSVSHA1_CALC_INT	(1 << 1)
-#define m_KSV_ACCESS_INT	(1 << 0)
-#define v_HDCP_ENGAGED(n)	(((n)&0x01) << 7)
-#define v_HDCP_FAILED(n)	(((n)&0x01) << 6)
-#define v_HDCP_I2C_NOACK(n)	(((n)&0x01) << 4)
-#define v_HDCP_LOST_ARBI(n)	(((n)&0x01) << 3)
-#define v_KEEP_ERR_INT(n)	(((n)&0x01) << 1)
-#define v_KSVSHA1_CALC_INT(n)	(((n)&0x01) << 1)
-#define v_KSV_ACCESS_INT(n)	(((n)&0x01) << 0)
+#define m_HDCP_ENGAGED		BIT(7)
+#define m_HDCP_FAILED		BIT(6)
+#define m_HDCP_I2C_NOACK	BIT(4)
+#define m_HDCP_LOST_ARBI	BIT(3)
+#define m_KEEP_ERR_INT		BIT(2)
+#define m_KSVSHA1_CALC_INT	BIT(1)
+#define m_KSV_ACCESS_INT	BIT(0)
+#define v_HDCP_ENGAGED(n)	(((n) & 0x01) << 7)
+#define v_HDCP_FAILED(n)	(((n) & 0x01) << 6)
+#define v_HDCP_I2C_NOACK(n)	(((n) & 0x01) << 4)
+#define v_HDCP_LOST_ARBI(n)	(((n) & 0x01) << 3)
+#define v_KEEP_ERR_INT(n)	(((n) & 0x01) << 1)
+#define v_KSVSHA1_CALC_INT(n)	(((n) & 0x01) << 1)
+#define v_KSV_ACCESS_INT(n)	(((n) & 0x01) << 0)
 
 #define	A_VIDPOLCFG			0x5009
 #define m_UNENCRYT_CONF		(0x03 << 5)
-#define v_UNENCRYT_CONF(n)	(((n)&0x03) << 5)
-#define m_DATAEN_POL		(1 << 4)
-#define v_DATAEN_POL(n)		(((n)&0x01) << 4)
-#define m_VSYNC_POL		(1 << 3)
-#define v_VSYNC_POL(n)		(((n)&0x01) << 3)
-#define m_HSYNC_POL		(1 << 1)
-#define v_HSYNC_POL(n)		(((n)&0x01) << 1)
+#define v_UNENCRYT_CONF(n)	(((n) & 0x03) << 5)
+#define m_DATAEN_POL		BIT(4)
+#define v_DATAEN_POL(n)		(((n) & 0x01) << 4)
+#define m_VSYNC_POL		BIT(3)
+#define v_VSYNC_POL(n)		(((n) & 0x01) << 3)
+#define m_HSYNC_POL		BIT(1)
+#define v_HSYNC_POL(n)		(((n) & 0x01) << 1)
 
 #define	A_OESSWCFG			0x500a
 #define	A_COREVERLSB			0x5014
 #define	A_COREVERMSB			0x5015
 
 #define	A_KSVMEMCTRL			0x5016
-#define m_SHA1_FAIL		(1 << 3)
-#define v_SHA1_FAIL(n)		(((n)&0x01) << 3)
-#define m_KSV_UPDATE		(1 << 2)
-#define v_KSV_UPDATE(n)		(((n)&0x01) << 2)
-#define m_KSV_MEM_ACCESS	(1 << 1)
-#define m_KSV_MEM_REQ		(1 << 0)
-#define v_KSV_MEM_REQ(n)	(((n)&0x01) << 0)
+#define m_SHA1_FAIL		BIT(3)
+#define v_SHA1_FAIL(n)		(((n) & 0x01) << 3)
+#define m_KSV_UPDATE		BIT(2)
+#define v_KSV_UPDATE(n)		(((n) & 0x01) << 2)
+#define m_KSV_MEM_ACCESS	BIT(1)
+#define m_KSV_MEM_REQ		BIT(0)
+#define v_KSV_MEM_REQ(n)	(((n) & 0x01) << 0)
 
 #define	HDCP_BSTATUS_0			0x5020
-#define m_MAX_DEVS_EXCEEDED	(1 << 7)
+#define m_MAX_DEVS_EXCEEDED	BIT(7)
 #define m_DEVICE_COUNT		(0x7f << 0)
 
 #define	HDCP_BSTATUS_1			0x5021
@@ -1263,8 +1283,8 @@ enum {
 #define HDCP_AN_BASE			0x7805
 
 #define	HDCPREG_ANCONF			0x7805
-#define m_OAN_BYPASS		(1 << 0)
-#define v_OAN_BYPASS(n)		(((n)&0x01) << 0)
+#define m_OAN_BYPASS		BIT(0)
+#define v_OAN_BYPASS(n)		(((n) & 0x01) << 0)
 
 #define	HDCPREG_AN0			0x7806
 #define	HDCPREG_AN1			0x7807
@@ -1279,11 +1299,11 @@ enum {
 #define ENCRYPTED_DPK_EMBEDDED_BASE	0x780e
 
 #define	HDCPREG_RMCTL			0x780e
-#define m_DPK_DECRYPT_EN	(1 << 0)
-#define v_DPK_DECRYPT_EN(n)	(((n)&0x01) << 0)
+#define m_DPK_DECRYPT_EN	BIT(0)
+#define v_DPK_DECRYPT_EN(n)	(((n) & 0x01) << 0)
 
 #define	HDCPREG_RMSTS			0x780f
-#define m_DPK_WR_OK_STS		(1 << 6)
+#define m_DPK_WR_OK_STS		BIT(6)
 #define m_DPK_DATA_INDEX	(0x3f << 6)
 
 #define	HDCPREG_SEED0			0x7810
@@ -1299,46 +1319,46 @@ enum {
 #define HDCP2REG_BASE			0x7900
 #define HDCP2REG_ID			0x7900
 #define HDCP2REG_CTRL			0x7904
-	#define m_HDCP2_HDP_OVR_VAL	(1 << 5)
-	#define m_HDCP2_HDP_OVR_EN	(1 << 4)
-	#define m_HDCP2_FORCE		(1 << 2)
-	#define m_HDCP2_OVR_EN		(1 << 1)
-	#define m_HDCP2_SWITCH_EN	(1 << 0)
-
-	#define v_HDCP2_HDP_OVR_VAL(n)	(((n)&0x01) << 5)
-	#define v_HDCP2_HDP_OVR_EN(n)	(((n)&0x01) << 4)
-	#define v_HDCP2_FORCE(n)	(((n)&0x01) << 2)
-	#define v_HDCP2_OVR_EN(n)	(((n)&0x01) << 1)
-	#define v_HDCP2_SWITCH_EN(n)	(((n)&0x01) << 0)
+	#define m_HDCP2_HDP_OVR_VAL	BIT(5)
+	#define m_HDCP2_HDP_OVR_EN	BIT(4)
+	#define m_HDCP2_FORCE		BIT(2)
+	#define m_HDCP2_OVR_EN		BIT(1)
+	#define m_HDCP2_SWITCH_EN	BIT(0)
+
+	#define v_HDCP2_HDP_OVR_VAL(n)	(((n) & 0x01) << 5)
+	#define v_HDCP2_HDP_OVR_EN(n)	(((n) & 0x01) << 4)
+	#define v_HDCP2_FORCE(n)	(((n) & 0x01) << 2)
+	#define v_HDCP2_OVR_EN(n)	(((n) & 0x01) << 1)
+	#define v_HDCP2_SWITCH_EN(n)	(((n) & 0x01) << 0)
 #define HDCP2REG_CTRL1			0x7905
 	#define m_HDCP2_CD_VAL		(0xf << 4)
-	#define m_HDCP2_CD_EN		(1 << 3)
-	#define m_HDCP2_AVMUTE_OVR_VAL	(1 << 1)
-	#define m_HDCP2_AVMUTE_OVR_EN	(1 << 0)
-
-	#define v_HDCP2_CD_VAL(n)		(((n)&0x0f) << 4)
-	#define v_HDCP2_CD_EN(n)		(((n)&0x01) << 3)
-	#define v_HDCP2_AVMUTE_OVR_VAL(n)	(((n)&0x01) << 1)
-	#define v_HDCP2_AVMUTE_OVR_EN(n)	(((n)&0x01) << 0)
+	#define m_HDCP2_CD_EN		BIT(3)
+	#define m_HDCP2_AVMUTE_OVR_VAL	BIT(1)
+	#define m_HDCP2_AVMUTE_OVR_EN	BIT(0)
+
+	#define v_HDCP2_CD_VAL(n)		(((n) & 0x0f) << 4)
+	#define v_HDCP2_CD_EN(n)		(((n) & 0x01) << 3)
+	#define v_HDCP2_AVMUTE_OVR_VAL(n)	(((n) & 0x01) << 1)
+	#define v_HDCP2_AVMUTE_OVR_EN(n)	(((n) & 0x01) << 0)
 #define HDCP2REG_STAS			0x7908
 #define HDCP2REG_MASK			0x790c
 #define HDCP2REG_STAT			0x790d
 #define HDCP2REG_MUTE			0x790e
-	#define m_HDCP2_CAPABLE		(1 << 0)
-	#define m_HDCP2_NOTCAPABLE	(1 << 1)
-	#define m_HDCP2_AUTH_LOST	(1 << 2)
-	#define m_HDCP2_AUTH_OK		(1 << 3)
-	#define m_HDCP2_AUTH_FAIL	(1 << 4)
-	#define m_HDCP2_DECRYPTED_CHG	(1 << 5)
+	#define m_HDCP2_CAPABLE		BIT(0)
+	#define m_HDCP2_NOTCAPABLE	BIT(1)
+	#define m_HDCP2_AUTH_LOST	BIT(2)
+	#define m_HDCP2_AUTH_OK		BIT(3)
+	#define m_HDCP2_AUTH_FAIL	BIT(4)
+	#define m_HDCP2_DECRYPTED_CHG	BIT(5)
 
 /* CEC Engine Registers */
 #define CEC_ENGINE_BASE			0x7d00
 
 #define	CEC_CTRL			0x7d00
-	#define m_CEC_STANBY		(1 << 4)
-	#define m_CEC_BC_NCK		(1 << 3)
+	#define m_CEC_STANBY		BIT(4)
+	#define m_CEC_BC_NCK		BIT(3)
 	#define m_CEC_FRAME_TYPE	(3 << 1)
-	#define m_CEC_SEND		(1 << 0)
+	#define m_CEC_SEND		BIT(0)
 	#define v_CEC_STANBY(n)		((n & 0x1) << 4)
 	#define v_CEC_BC_NCK(n)		((n & 0x1) << 3)
 	#define v_CEC_FRAME_TYPE(n)	((n & 0x3) << 1)
@@ -1362,44 +1382,45 @@ enum {
 #define	I2CM_DATAI			0x7e03
 
 #define I2CM_OPERATION			0x7e04
-#define m_I2CM_WR		(1 << 4)
-#define v_I2CM_WR(n)		(((n)&0x01) << 4)
-#define m_I2CM_RD8_EXT		(1 << 3)
-#define v_I2CM_RD8_EXT(n)	(((n)&0x01) << 3)
-#define m_I2CM_RD8		(1 << 2)
-#define v_I2CM_RD8(n)		(((n)&0x01) << 2)
-#define m_I2CM_RD_EXT		(1 << 1)
-#define v_I2CM_RD_EXT(n)	(((n)&0x01) << 1)
-#define m_I2CM_RD		(1 << 0)
-#define v_I2CM_RD(n)		(((n)&0x01) << 0)
+#define m_I2CM_WR		BIT(4)
+#define v_I2CM_WR(n)		(((n) & 0x01) << 4)
+#define m_I2CM_RD8_EXT		BIT(3)
+#define v_I2CM_RD8_EXT(n)	(((n) & 0x01) << 3)
+#define m_I2CM_RD8		BIT(2)
+#define v_I2CM_RD8(n)		(((n) & 0x01) << 2)
+#define m_I2CM_RD_EXT		BIT(1)
+#define v_I2CM_RD_EXT(n)	(((n) & 0x01) << 1)
+#define m_I2CM_RD		BIT(0)
+#define v_I2CM_RD(n)		(((n) & 0x01) << 0)
 
 #define	I2CM_INT			0x7e05
-#define m_I2CM_RD_REQ_MASK	(1 << 6)
-#define v_I2CM_RD_REQ_MASK(n)	(((n)&0x01) << 6)
-#define m_I2CM_DONE_MASK	(1 << 2)
-#define v_I2CM_DONE_MASK(n)	(((n)&0x01) << 2)
+#define m_I2CM_RD_REQ_MASK	BIT(6)
+#define v_I2CM_RD_REQ_MASK(n)	(((n) & 0x01) << 6)
+#define m_I2CM_DONE_MASK	BIT(2)
+#define v_I2CM_DONE_MASK(n)	(((n) & 0x01) << 2)
 
 #define	I2CM_CTLINT			0x7e06
-#define m_I2CM_NACK_MASK	(1 << 6)
-#define v_I2CM_NACK_MASK(n)	(((n)&0x01) << 6)
-#define m_I2CM_ARB_MASK		(1 << 2)
-#define v_I2CM_ARB_MASK(n)	(((n)&0x01) << 2)
+#define m_I2CM_NACK_MASK	BIT(6)
+#define v_I2CM_NACK_MASK(n)	(((n) & 0x01) << 6)
+#define m_I2CM_ARB_MASK		BIT(2)
+#define v_I2CM_ARB_MASK(n)	(((n) & 0x01) << 2)
 
 #define	I2CM_DIV			0x7e07
 enum {
 	STANDARD_MODE = 0,
 	FAST_MODE
 };
-#define m_I2CM_FAST_STD_MODE	(1 << 3)
-#define v_I2CM_FAST_STD_MODE(n)	(((n)&0x01) << 3)
+
+#define m_I2CM_FAST_STD_MODE	BIT(3)
+#define v_I2CM_FAST_STD_MODE(n)	(((n) & 0x01) << 3)
 
 #define	I2CM_SEGADDR			0x7e08
 #define m_I2CM_SEG_ADDR		(0x7f << 0)
-#define v_I2CM_SEG_ADDR(n)	(((n)&0x7f) << 0)
+#define v_I2CM_SEG_ADDR(n)	(((n) & 0x7f) << 0)
 
 #define	I2CM_SOFTRSTZ			0x7e09
-#define m_I2CM_SOFTRST		(1 << 0)
-#define v_I2CM_SOFTRST(n)	(((n)&0x01) << 0)
+#define m_I2CM_SOFTRST		BIT(0)
+#define v_I2CM_SOFTRST(n)	(((n) & 0x01) << 0)
 
 #define	I2CM_SEGPTR			0x7e0a
 #define	I2CM_SS_SCL_HCNT_1_ADDR		0x7e0b
@@ -1413,12 +1434,12 @@ enum {
 #define	I2CM_SDA_HOLD			0x7e13
 
 #define	I2CM_SCDC_READ_UPDATE		0x7e14
-#define m_I2CM_UPRD_VSYNC_EN	(1 << 5)
-#define v_I2CM_UPRD_VSYNC_EN(n) (((n)&0x01) << 5)
-#define m_I2CM_READ_REQ_EN	(1 << 4)
-#define v_I2CM_READ_REQ_EN(n)	(((n)&0x01) << 4)
-#define m_I2CM_READ_UPDATE	(1 << 0)
-#define v_I2CM_READ_UPDATE(n)	(((n)&0x01) << 0)
+#define m_I2CM_UPRD_VSYNC_EN	BIT(5)
+#define v_I2CM_UPRD_VSYNC_EN(n) (((n) & 0x01) << 5)
+#define m_I2CM_READ_REQ_EN	BIT(4)
+#define v_I2CM_READ_REQ_EN(n)	(((n) & 0x01) << 4)
+#define m_I2CM_READ_UPDATE	BIT(0)
+#define v_I2CM_READ_UPDATE(n)	(((n) & 0x01) << 0)
 
 #define	I2CM_READ_BUFF0			0x7e20	/* buff0~buff7 */
 #define	I2CM_SCDC_UPDATE0		0x7e30
@@ -1434,22 +1455,25 @@ enum {
 	PREP_DIV_BY_125,	/* 10 bits */
 	PREP_DIV_BY_1,		/* 8 bits */
 };
+
 #define m_PREP_DIV		(0x03 << 13)
-#define v_PREP_DIV(n)		(((n)&0x03) << 13)
+#define v_PREP_DIV(n)		(((n) & 0x03) << 13)
 enum {
 	TMDS_DIV_BY_1 = 0,
 	TMDS_DIV_NOT_USED,
 	TMDS_DIV_BY_3,
 	TMDS_DIV_BY_4,
 };
+
 #define m_TMDS_CNTRL		(0x03 << 11)
-#define v_TMDS_CNTRL(n)		(((n)&0x03) << 11)
+#define v_TMDS_CNTRL(n)		(((n) & 0x03) << 11)
 enum OPMODE {
 	OP_HDMI_14 = 0,
 	OP_HDMI_20,
 };
+
 #define m_OPMODE		(0x03 << 9)
-#define v_OPMODE(n)		(((n)&0x03) << 9)
+#define v_OPMODE(n)		(((n) & 0x03) << 9)
 enum {
 	FBDIV2_BY_1 = 1,
 	FBDIV2_BY_2,
@@ -1458,53 +1482,56 @@ enum {
 	FBDIV2_BY_5,
 	FBDIV2_BY_6,
 };
+
 #define m_FBDIV2_CNTRL		(0x07 << 6)
-#define v_FBDIV2_CNTRL(n)	(((n)&0x07) << 6)
+#define v_FBDIV2_CNTRL(n)	(((n) & 0x07) << 6)
 enum {
 	FBDIV1_BY_1 = 0,
 	FBDIV1_BY_2,
 	FBDIV1_BY_3,
 	FBDIV1_BY_4,
 };
+
 #define m_FBDIV1_CNTRL		(0x03 << 4)
-#define v_FBDIV1_CNTRL(n)	(((n)&0x03) << 4)
+#define v_FBDIV1_CNTRL(n)	(((n) & 0x03) << 4)
 enum {
 	REF_DIV_BY_1 = 0,
 	REF_DIV_BY_2,
 	REF_DIV_NOT_USED,
 	REF_DIV_BY_4,
 };
+
 #define m_REF_CNTRL		(0x03 << 2)
-#define v_REF_CNTRL(n)		(((n)&0x03) << 2)
+#define v_REF_CNTRL(n)		(((n) & 0x03) << 2)
 #define m_MPLL_N_CNTRL		(0x03 << 0)
-#define v_MPLL_N_CNTRL(n)	(((n)&0x03) << 0)
+#define v_MPLL_N_CNTRL(n)	(((n) & 0x03) << 0)
 
 #define PHYTX_CLKSYMCTRL		0x09
 #define v_OVERRIDE(n)		(0x01 << 15)
 #define m_SLOPEBOOST		(0x03 << 4)
-#define v_SLOPEBOOST(n)		(((n)&0x03) << 4)
+#define v_SLOPEBOOST(n)		(((n) & 0x03) << 4)
 #define m_TX_SYMON		(0x01 << 3)
-#define v_TX_SYMON(n)		(((n)&0x01) << 3)
+#define v_TX_SYMON(n)		(((n) & 0x01) << 3)
 #define m_PREEMPHASIS		(0x03 << 1)
-#define v_PREEMPHASIS(n)	(((n)&0x03) << 1)
+#define v_PREEMPHASIS(n)	(((n) & 0x03) << 1)
 #define m_CLK_SYMON		(0x01 << 0)
-#define v_CLK_SYMON(n)		(((n)&0x01) << 0)
+#define v_CLK_SYMON(n)		(((n) & 0x01) << 0)
 
 #define PHYTX_VLEVCTRL			0x0e
 #define m_SUP_TXLVL		(0x1f << 5)
-#define v_SUP_TXLVL(n)		(((n)&0x1f) << 5)
+#define v_SUP_TXLVL(n)		(((n) & 0x1f) << 5)
 #define m_SUP_CLKLVL		(0x1f << 0)
-#define v_SUP_CLKLVL(n)		(((n)&0x1f) << 0)
+#define v_SUP_CLKLVL(n)		(((n) & 0x1f) << 0)
 
 #define PHYTX_PLLCURRCTRL		0x10
 #define m_MPLL_PROP_CNTRL	(0x07 << 3)
-#define v_MPLL_PROP_CNTRL(n)	(((n)&0x07) << 3)
+#define v_MPLL_PROP_CNTRL(n)	(((n) & 0x07) << 3)
 #define m_MPLL_INT_CNTRL	(0x07 << 0)
-#define v_MPLL_INT_CNTRL(n)	(((n)&0x07) << 0)
+#define v_MPLL_INT_CNTRL(n)	(((n) & 0x07) << 0)
 
 #define PHYTX_PLLGMPCTRL		0x15
 #define m_MPLL_GMP_CNTRL	(0x03 << 0)
-#define v_MPLL_GMP_CNTRL(n)	(((n)&0x03) << 0)
+#define v_MPLL_GMP_CNTRL(n)	(((n) & 0x03) << 0)
 
 enum TERM_RESIS {
 	R50_OHMS = 0,
@@ -1516,10 +1543,10 @@ enum TERM_RESIS {
 	R200_OHMS,
 	ROPEN_CIRCUIT,
 };
+
 #define PHYTX_TERM_RESIS		0x19
 #define m_TX_TERM		(0x07 << 0)
-#define v_TX_TERM(n)		(((n)&0x07) << 0)
-
+#define v_TX_TERM(n)		(((n) & 0x07) << 0)
 
 struct phy_mpll_config_tab {
 	u32 pix_clock;
@@ -1619,7 +1646,7 @@ struct phy_mpll_config_tab {
 
 #define EXT_PHY_TERM_RESIS_AUTO		0xf4
 	#define EXT_PHY_AUTO_R50_OHMS			0
-	#define EXT_PHY_AUTO_R75_OHMS			(1 << 2)
+	#define EXT_PHY_AUTO_R75_OHMS			BIT(2)
 	#define EXT_PHY_AUTO_R100_OHMS			(2 << 2)
 	#define EXT_PHY_AUTO_ROPEN_CIRCUIT		(3 << 2)
 
@@ -1653,6 +1680,7 @@ struct ext_pll_config_tab {
 	u8	ppll_nf;
 	u8	ppll_no;
 };
+
 /*
 * HDMI TX PHY Define End
 */
@@ -1687,6 +1715,7 @@ static inline int hdmi_msk_reg(struct hdmi_dev *hdmi_dev,
 		       hdmi_dev->regbase + (offset) * 0x04);
 	return ret;
 }
+
 irqreturn_t rockchip_hdmiv2_dev_irq(int irq, void *priv);
 void rockchip_hdmiv2_dev_init_ops(struct hdmi_ops *ops);
 void rockchip_hdmiv2_dev_initial(struct hdmi_dev *hdmi_dev);
-- 
2.35.3

