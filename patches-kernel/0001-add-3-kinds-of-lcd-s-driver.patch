From 6c4d74ed5c2815458e7c3c5ce97c1a2433b1cfd4 Mon Sep 17 00:00:00 2001
From: hhb <hhb@rock-chips.com>
Date: Wed, 23 Mar 2011 16:31:27 +0800
Subject: [PATCH] add 3 kinds of lcd's driver

---
 drivers/video/display/screen/Kconfig          |   8 +
 drivers/video/display/screen/Makefile         |   5 +-
 .../video/display/screen/lcd_ips1p5680_v1_e.c | 239 ++++++++
 .../video/display/screen/lcd_ls035y8dx02a.c   | 344 +++++++++++
 .../display/screen/lcd_mcu_tft480800_25_e.c   | 556 ++++++++++++++++++
 .../display/screen/lcd_rgb_tft480800_25_e.c   | 548 +++++++++++++++++
 6 files changed, 1699 insertions(+), 1 deletion(-)
 create mode 100644 drivers/video/display/screen/lcd_ips1p5680_v1_e.c
 create mode 100755 drivers/video/display/screen/lcd_ls035y8dx02a.c
 create mode 100644 drivers/video/display/screen/lcd_mcu_tft480800_25_e.c
 create mode 100644 drivers/video/display/screen/lcd_rgb_tft480800_25_e.c

diff --git a/drivers/video/display/screen/Kconfig b/drivers/video/display/screen/Kconfig
index 03541cff8bd2..36b9c2f54b08 100755
--- a/drivers/video/display/screen/Kconfig
+++ b/drivers/video/display/screen/Kconfig
@@ -17,6 +17,10 @@ config LCD_HSD100PXN
 	  bool "RGB Hannstar HSD100PXN(1024X768)"
 config LCD_B101AW06
 	  bool "RGB Hannstar B101AW06(1024X600)"
+config LCD_RGB_TFT480800_25_E
+	  bool "RGB TFT480800_25_E(480X800)"
+config LCD_LS035Y8DX02A
+	  bool "RGB LS035Y8DX02A(480X800)"
 config LCD_A060SE02
     bool "MCU A060SE02"
 config LCD_S1D13521
@@ -25,6 +29,10 @@ config LCD_NT35582
 	bool "MCU NT35582"
 config LCD_NT35580
 	bool "MCU NT35580"
+config LCD_IPS1P5680_V1_E
+	bool "MCU IPS1P5680_V1_E"
+config LCD_MCU_TFT480800_25_E
+	bool "MCU TFT480800_25_E"
 config LCD_ILI9803_CPT4_3
 	bool "RGB lcd_ILI9803_CPT4_3"	
 config LCD_ANX7150_720P
diff --git a/drivers/video/display/screen/Makefile b/drivers/video/display/screen/Makefile
index b7540d54ce4d..6040ec96142c 100755
--- a/drivers/video/display/screen/Makefile
+++ b/drivers/video/display/screen/Makefile
@@ -21,4 +21,7 @@ obj-$(CONFIG_LCD_HSD100PXN) += lcd_hsd100pxn.o
 obj-$(CONFIG_LCD_B101AW06) += lcd_B101AW06.o
 obj-$(CONFIG_LCD_ANX7150_720P) += lcd_anx7150_720p.o
 obj-$(CONFIG_LCD_ILI9803_CPT4_3) += lcd_ili9803_cpt4_3.o
-
+obj-$(CONFIG_LCD_RGB_TFT480800_25_E) += lcd_rgb_tft480800_25_e.o
+obj-$(CONFIG_LCD_LS035Y8DX02A) += lcd_ls035y8dx02a.o
+obj-$(CONFIG_LCD_IPS1P5680_V1_E) += lcd_ips1p5680_v1_e.o
+obj-$(CONFIG_LCD_MCU_TFT480800_25_E) += lcd_mcu_tft480800_25_e.o
diff --git a/drivers/video/display/screen/lcd_ips1p5680_v1_e.c b/drivers/video/display/screen/lcd_ips1p5680_v1_e.c
new file mode 100644
index 000000000000..031256f76aac
--- /dev/null
+++ b/drivers/video/display/screen/lcd_ips1p5680_v1_e.c
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2011 ROCKCHIP, Inc.
+ *
+ * author: hhb@rock-chips.com
+ * creat date: 2011-03-07 
+ * route:drivers/video/display/screen/lcd_ips1p5680_v1_e.c - driver for rk29 phone sdk
+ * station:haven't been tested in any hardware platform
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_MCU
+#define OUT_FACE		OUT_P565
+
+/* Timing */
+#define H_PW			1
+#define H_BP		    1
+#define H_VD			320
+#define H_FP			5
+
+#define V_PW			1
+#define V_BP			1
+#define V_VD			480
+#define V_FP			1
+
+#define LCD_WIDTH       320           //need modify
+#define LCD_HEIGHT      480
+
+#define LCDC_ACLK       150000000     //29 lcdc axi DMA ÆµÂÊ
+
+#define P_WR            27
+#define USE_FMARK       0             //2  ÊÇ·ñÊ¹ÓÃFMK (0:²»Ö§³Ö 1:ºáÆÁÖ§³Ö 2:ºáÊúÆÁ¶ŒÖ§³Ö)
+#define FRMRATE         60            //MCUÆÁµÄË¢ÐÂÂÊ (FMKÓÐÐ§Ê±ÓÃ)
+
+
+/* Other */
+#define DCLK_POL		0
+#define SWAP_RB			0
+
+
+/* define lcd command */
+#define ENTER_SLEEP_MODE        0x10
+#define EXIT_SLEEP_MODE         0x11
+#define SET_COLUMN_ADDRESS      0x2a
+#define SET_PAGE_ADDRESS        0x2b
+#define WRITE_MEMORY_START      0x2c
+#define SET_DISPLAY_ON          0x29
+#define SET_DISPLAY_OFF         0x28
+#define SET_ADDRESS_MODE        0x36
+#define SET_PIXEL_FORMAT        0x3a
+
+
+/* initialize the lcd registers to make it function noamally*/
+
+int lcd_init(void)
+{
+    int i =0;
+    mcu_ioctl(MCU_SETBYPASS, 1);
+    msleep(5);
+    mcu_ioctl(MCU_WRCMD, SET_ADDRESS_MODE);  //set address normal mode
+    mcu_ioctl(MCU_WRDATA, 0);
+    mcu_ioctl(MCU_WRCMD, SET_PIXEL_FORMAT);  //set 16 bits per pixel
+    mcu_ioctl(MCU_WRDATA, 0x55);
+    mcu_ioctl(MCU_WRCMD, EXIT_SLEEP_MODE);  //set lcd exit sleep mode,because the lcd is in sleep mode when power on
+    msleep(1000*6 / FRMRATE + 10);            //wait for about 6 frames' time
+    mcu_ioctl(MCU_WRCMD, SET_DISPLAY_ON);   //set display on
+    msleep(1000/FRMRATE);
+    
+    /*init lcd internal ram,so lcd won't display randomly*/
+    mcu_ioctl(MCU_WRCMD, SET_COLUMN_ADDRESS);
+	mcu_ioctl(MCU_WRDATA, 0);
+	mcu_ioctl(MCU_WRDATA, 0);
+	mcu_ioctl(MCU_WRDATA, (LCD_WIDTH >> 8) & 0x0003);
+	mcu_ioctl(MCU_WRDATA, LCD_WIDTH & 0x00ff);
+	msleep(10);
+	mcu_ioctl(MCU_WRCMD, SET_PAGE_ADDRESS);
+	mcu_ioctl(MCU_WRDATA, 0);
+	mcu_ioctl(MCU_WRDATA, 0);
+	mcu_ioctl(MCU_WRDATA, (LCD_HEIGHT >> 8) & 0x0003);
+	mcu_ioctl(MCU_WRDATA, LCD_HEIGHT & 0x00ff);
+	msleep(10);
+	mcu_ioctl(MCU_WRCMD, WRITE_MEMORY_START);
+
+	for(i = 0; i < LCD_WIDTH*LCD_HEIGHT; i++)
+	{
+	        mcu_ioctl(MCU_WRDATA, 0x00000000);
+	}
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return 0;
+}
+
+/* set lcd to sleep mode or not */
+
+int lcd_standby(u32 enable)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+    if(enable) {
+        mcu_ioctl(MCU_WRCMD, ENTER_SLEEP_MODE);
+    } else {
+        mcu_ioctl(MCU_WRCMD, EXIT_SLEEP_MODE);
+    }
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+
+    return 0;
+}
+
+/* set lcd to write memory mode, so the lcdc of RK29xx can send the fb content to the lcd internal ram in hold mode*/
+
+int lcd_refresh(u32 arg)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+    switch(arg)
+    {
+		case REFRESH_PRE:   //start to write the image data to lcd ram
+			mcu_ioctl(MCU_WRCMD, SET_COLUMN_ADDRESS);  //set
+			mcu_ioctl(MCU_WRDATA, 0);
+			mcu_ioctl(MCU_WRDATA, 0);
+			mcu_ioctl(MCU_WRDATA, (LCD_WIDTH >> 8) & 0x0003);
+			mcu_ioctl(MCU_WRDATA, LCD_WIDTH & 0x00ff);
+			msleep(10);
+			mcu_ioctl(MCU_WRCMD, SET_PAGE_ADDRESS);
+			mcu_ioctl(MCU_WRDATA, 0);
+			mcu_ioctl(MCU_WRDATA, 0);
+			mcu_ioctl(MCU_WRDATA, (LCD_HEIGHT >> 8) & 0x0003);
+			mcu_ioctl(MCU_WRDATA, LCD_HEIGHT & 0x00ff);
+			msleep(10);
+			mcu_ioctl(MCU_WRCMD, WRITE_MEMORY_START);
+			break;
+
+		case REFRESH_END:   //set display on
+			mcu_ioctl(MCU_WRCMD, SET_DISPLAY_ON);
+			break;
+
+		default:
+			break;
+    }
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+
+    return 0;
+}
+
+
+/* not used */
+
+int lcd_scandir(u32 dir)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+    
+//   mcu_ioctl(MCU_WRCMD, SET_DISPLAY_OFF);
+   
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return 0;
+}
+
+
+/* not used */
+
+int lcd_disparea(u32 area)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return (0);
+}
+
+
+/* set real information about lcd which we use in this harware platform */
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    screen->width = LCD_WIDTH;
+    screen->height = LCD_HEIGHT;
+
+    /* Timing */
+    screen->lcdc_aclk = LCDC_ACLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	screen->mcu_wrperiod = P_WR;
+	screen->mcu_usefmk = USE_FMARK;
+    screen->mcu_frmrate = FRMRATE;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = lcd_init;
+    screen->standby = lcd_standby;
+    screen->scandir = lcd_scandir;
+    screen->refresh = lcd_refresh;
+    screen->disparea = lcd_disparea;
+}
+
+
+
+
+
+
diff --git a/drivers/video/display/screen/lcd_ls035y8dx02a.c b/drivers/video/display/screen/lcd_ls035y8dx02a.c
new file mode 100755
index 000000000000..1b2f4c6cda48
--- /dev/null
+++ b/drivers/video/display/screen/lcd_ls035y8dx02a.c
@@ -0,0 +1,344 @@
+/*
+ * Copyright (C) 2011 ROCKCHIP, Inc.
+ *
+ * author: hhb@rock-chips.com
+ * creat date: 2011-03-22
+ * route:drivers/video/display/screen/lcd_ls035y8dx02a.c - driver for rk29 phone sdk
+ * station:haven't been tested in any hardware platform
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define OUT_CLK			26	//***27
+#define LCDC_ACLK       150000000     //29 lcdc axi DMA Ƶ��           //rk29
+
+/* Timing */
+#define H_PW			16 //8
+#define H_BP			24//6
+#define H_VD			480//320	//***800 
+#define H_FP			16//60
+
+#define V_PW			2//12
+#define V_BP			2// 4
+#define V_VD			800//480	//***480
+#define V_FP			4//40
+
+#define LCD_WIDTH       800    //need modify   //rk29
+#define LCD_HEIGHT      480
+
+/* Other */
+#define DCLK_POL		1             //0 
+#define SWAP_RB			0
+
+static struct rk29lcd_info *gLcd_info = NULL;
+int lcd_init(void);
+int lcd_standby(u32 enable);
+/*
+#define RXD_PORT	    RK2818_PIN_PB7
+#define TXD_PORT        RK2818_PIN_PB6    //gLcd_info->txd_pin
+#define CLK_PORT        RK2818_PIN_PB5    //gLcd_info->clk_pin
+#define CS_PORT         RK2818_PIN_PB4    // gLcd_info->cs_pin
+*/
+#define RXD_PORT        1
+#define TXD_PORT        gLcd_info->txd_pin
+#define CLK_PORT        gLcd_info->clk_pin
+#define CS_PORT         gLcd_info->cs_pin
+
+#define CS_OUT()        gpio_direction_output(CS_PORT, 1)
+#define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
+#define CS_CLR()        gpio_set_value(CS_PORT, GPIO_LOW)
+#define CLK_OUT()       gpio_direction_output(CLK_PORT, 0) 
+#define CLK_SET()       gpio_set_value(CLK_PORT, GPIO_HIGH)
+#define CLK_CLR()       gpio_set_value(CLK_PORT, GPIO_LOW)
+#define TXD_OUT()       gpio_direction_output(TXD_PORT, 1)   
+#define TXD_SET()       gpio_set_value(TXD_PORT, GPIO_HIGH)
+#define TXD_CLR()       gpio_set_value(TXD_PORT, GPIO_LOW)
+#define RXD_IN()        gpio_direction_input(RXD_PORT)
+#define RXD_GET()	    gpio_get_value(RXD_PORT)
+
+#define DRVDelayUs(i)   udelay(i*4)
+
+u32 spi_screenreg_get(u32 Addr)
+{
+    u32 i, data = 0;
+    u32 control_bit;
+
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    DRVDelayUs(2);
+    DRVDelayUs(2);
+
+    CS_SET();
+    TXD_SET();
+    CLK_CLR();
+    DRVDelayUs(30);
+
+        CS_CLR();
+        control_bit = 0x0000;
+        Addr = (control_bit | Addr);
+        printk("addr is 0x%x \n", Addr); 
+        for(i = 0; i < 9; i++)  //reg
+        {
+                if(Addr &(1<<(8-i)))
+                        TXD_SET();
+                else
+                        TXD_CLR();
+
+                // \u6a21\u62dfCLK
+                CLK_SET();
+                DRVDelayUs(2);
+                CLK_CLR();
+                DRVDelayUs(2);
+        }
+
+        CS_SET();
+        TXD_SET();
+        CLK_CLR();		
+        DRVDelayUs(10);
+		
+        CS_CLR();	
+        for(i = 0; i < 9; i++)
+        {
+                CLK_SET();
+                DRVDelayUs(2);
+                CLK_CLR();
+                if(RXD_GET())
+                {
+                	data |= 1<<(8-i);
+                }
+                else
+                {
+                	data &= ~(1<<(8-i));
+                }
+                DRVDelayUs(2);        		
+        }
+        CS_SET();
+        CLK_CLR();
+        TXD_CLR();
+        DRVDelayUs(30);
+        
+	return data;
+}
+
+void spi_screenreg_set(u32 Addr, u32 Data0, u32 Data1)
+{
+
+
+    u32 i;
+    u32 control_bit;
+
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    DRVDelayUs(2);
+    DRVDelayUs(2);
+
+    CS_SET();
+    TXD_SET();
+    CLK_CLR();
+    DRVDelayUs(30);
+
+        CS_CLR();
+        control_bit = 0x0000;
+        Addr = (control_bit | Addr);
+        //printk("addr is 0x%x \n", Addr); 
+        for(i = 0; i < 9; i++)  //reg
+        {
+                if(Addr &(1<<(8-i)))
+                        TXD_SET();
+                else
+                        TXD_CLR();
+
+                // \u6a21\u62dfCLK
+                CLK_SET();
+                DRVDelayUs(2);
+                CLK_CLR();
+                DRVDelayUs(2);
+        }
+
+        CS_SET();
+        TXD_SET();
+        CLK_CLR();		
+        DRVDelayUs(10);
+
+	 if(0xffff == Data0)
+		return;
+		
+        CS_CLR();
+ 
+        control_bit = 0x0100;
+        Data0 = (control_bit | Data0);
+        //printk("data0 is 0x%x \n", Data); 
+        for(i = 0; i < 9; i++)  //data
+        {
+                if(Data0 &(1<<(8-i)))
+                        TXD_SET();
+                else
+                        TXD_CLR();
+
+                // \u6a21\u62dfCLK
+                CLK_SET();
+                DRVDelayUs(2);
+                CLK_CLR();
+                DRVDelayUs(2);
+        }
+
+        CS_SET();
+        CLK_CLR();
+        TXD_CLR();
+        DRVDelayUs(10);
+
+	 if(0xffff == Data1)
+		return;
+		
+        CS_CLR();
+ 
+        control_bit = 0x0100;
+        Data1 = (control_bit | Data1);
+        //printk("data1 is 0x%x \n", Data); 
+        for(i = 0; i < 9; i++)  //data
+        {
+                if(Data1 &(1<<(8-i)))
+                        TXD_SET();
+                else
+                        TXD_CLR();
+
+                // \u6a21\u62dfCLK
+                CLK_SET();
+                DRVDelayUs(2);
+                CLK_CLR();
+                DRVDelayUs(2);
+        }
+
+        CS_SET();
+        CLK_CLR();
+        TXD_CLR();
+        DRVDelayUs(30);
+}
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
+{
+	//printk("lcd_hx8357 set_lcd_info \n"); 
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+ 
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+    screen->width = LCD_WIDTH;    //rk29
+    screen->height = LCD_HEIGHT;  //rk29
+
+    /* Timing */
+    screen->lcdc_aclk = LCDC_ACLK;  //rk29
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;		/*>2*/ 
+	screen->right_margin = H_FP;	/*>2*/ 
+	screen->hsync_len = H_PW;		/*>2*/ //***all > 326, 4<PW+BP<15, 
+	screen->upper_margin = V_BP;	/*>2*/ 
+	screen->lower_margin = V_FP;	/*>2*/ 
+	screen->vsync_len = V_PW;		/*>6*/ 
+
+	/* Pin polarity */
+	screen->pin_hsync = 0; 
+	screen->pin_vsync = 0; 
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = lcd_init;
+    screen->standby = lcd_standby;
+    if(lcd_info)
+        gLcd_info = lcd_info;
+}
+
+int lcd_init(void)
+{ 
+	volatile u32 data;
+   // rk2818_mux_api_set(GPIOB_SPI0_MMC0_NAME,IOMUXA_GPIO0_B567);
+   // rk2818_mux_api_set(GPIOB4_SPI0CS0_MMC0D4_NAME,IOMUXA_GPIO0_B4);
+    //gpio_pull_updown(RK2818_PIN_PB7, GPIOPullUp);
+    if(gLcd_info)
+		{printk("lcd init11111111111111111111111111...\n");
+        gLcd_info->io_init();}
+	printk("lcd init22222222222222222222222222...\n");
+	printk("lcd init...\n");
+	spi_screenreg_set(0x29, 0xffff, 0xffff);
+	spi_screenreg_set(0x11, 0xffff, 0xffff);
+	
+	mdelay(150);
+	spi_screenreg_set(0x36, 0x0000, 0xffff);	
+	//while(1)
+	{	
+		data = spi_screenreg_get(0x0a);	
+		printk("------------liuylcd init reg 0x0a=0x%x \n", spi_screenreg_get(0x0a));
+		data = spi_screenreg_get(0x0b);
+		printk("------------liuylcd init reg 0x0b=0x%x \n", spi_screenreg_get(0x0b));
+		data = spi_screenreg_get(0x0c);
+		printk("------------liuylcd init reg 0x0c=0x%x \n", spi_screenreg_get(0x0c));
+		data = spi_screenreg_get(0x0d);
+		printk("------------liuylcd init reg 0x0d=0x%x \n", spi_screenreg_get(0x0d));
+		data = spi_screenreg_get(0x0f);
+		printk("------------liuylcd init reg 0x0f=0x%x \n", spi_screenreg_get(0x0f));
+	}	
+	spi_screenreg_set(0x3a, 0x0070, 0xffff);
+	spi_screenreg_set(0xb0, 0x0000, 0xffff);
+	spi_screenreg_set(0xb8, 0x0001, 0xffff);
+	spi_screenreg_set(0xb9, 0x0001, 0x00ff);
+	spi_screenreg_set(0xb0, 0x0003, 0xffff);
+	
+    if(gLcd_info)
+        gLcd_info->io_deinit();
+
+    return 0;
+}
+
+int lcd_standby(u32 enable)	//***enable =1 means suspend, 0 means resume 
+{
+
+    if(gLcd_info)
+       gLcd_info->io_init();
+	printk("lcd standby\n");
+	if(enable) {
+		printk("lcd standby...enable =1 means suspend\n");
+		spi_screenreg_set(0x10, 0xffff, 0xffff);
+		mdelay(120);
+		spi_screenreg_set(0x28, 0xffff, 0xffff);
+	} else { 
+		printk("lcd standby...0 means resume\n");
+		spi_screenreg_set(0x29, 0xffff, 0xffff);
+		spi_screenreg_set(0x11, 0xffff, 0xffff);
+		//mdelay(150);
+	}
+
+    if(gLcd_info)
+       gLcd_info->io_deinit();
+    return 0;
+}
+
diff --git a/drivers/video/display/screen/lcd_mcu_tft480800_25_e.c b/drivers/video/display/screen/lcd_mcu_tft480800_25_e.c
new file mode 100644
index 000000000000..bcbfd0be3a2a
--- /dev/null
+++ b/drivers/video/display/screen/lcd_mcu_tft480800_25_e.c
@@ -0,0 +1,556 @@
+/*
+ * Copyright (C) 2011 ROCKCHIP, Inc.
+ *
+ * author: hhb@rock-chips.com
+ * creat date: 2011-03-11
+ * route:drivers/video/display/screen/lcd_mcu_tft480800_25_e.c - driver for rk29 phone sdk
+ * station:haven't been tested in any hardware platform
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include "screen.h"
+
+/* Base */
+#define OUT_TYPE		SCREEN_MCU
+#define OUT_FACE		OUT_P888
+
+/* Timing */
+#define H_PW			1
+#define H_BP		    1
+#define H_VD			480
+#define H_FP			5
+
+#define V_PW			1
+#define V_BP			1
+#define V_VD			800
+#define V_FP			1
+
+#define LCD_WIDTH       480           //need modify
+#define LCD_HEIGHT      800
+
+#define LCDC_ACLK       150000000     //29 lcdc axi DMA ÆµÂÊ
+
+#define P_WR            27
+#define USE_FMARK       0             //2  ÊÇ·ñÊ¹ÓÃFMK (0:²»Ö§³Ö 1:ºáÆÁÖ§³Ö 2:ºáÊúÆÁ¶ŒÖ§³Ö)
+#define FRMRATE         60            //MCUÆÁµÄË¢ÐÂÂÊ (FMKÓÐÐ§Ê±ÓÃ)
+
+
+/* Other */
+#define DCLK_POL		0
+#define SWAP_RB			0
+
+
+/* define lcd command */
+#define ENTER_SLEEP_MODE        0x10
+#define EXIT_SLEEP_MODE         0x11
+#define SET_COLUMN_ADDRESS      0x2a
+#define SET_PAGE_ADDRESS        0x2b
+#define WRITE_MEMORY_START      0x2c
+#define SET_DISPLAY_ON          0x29
+#define SET_DISPLAY_OFF         0x28
+#define SET_ADDRESS_MODE        0x36
+#define SET_PIXEL_FORMAT        0x3a
+
+
+#define WMLCDCOM(command)       mcu_ioctl(MCU_WRCMD,command)
+#define WMLCDDATA(data)         mcu_ioctl(MCU_WRDATA,data)
+
+
+
+
+/* initialize the lcd registers to make it function noamally*/
+
+int lcd_init(void)
+{
+    int k = 0;
+    mcu_ioctl(MCU_SETBYPASS, 1);
+    
+#if 1  //HX8369-A
+
+    WMLCDCOM(0xB9);  // SET password
+	WMLCDDATA(0xFF);
+	WMLCDDATA(0x83);
+	WMLCDDATA(0x69);
+
+	WMLCDCOM(0xB0);  //Enable internal oscillator
+	WMLCDDATA(0x01);
+    WMLCDDATA(0x0B);
+
+
+    WMLCDCOM(0xB1);  //Set Power
+    WMLCDDATA(0x85);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x34);
+	WMLCDDATA(0x0A);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x0F);
+	WMLCDDATA(0x0F);
+	WMLCDDATA(0x2A);
+	WMLCDDATA(0x32);
+	WMLCDDATA(0x3F);
+	WMLCDDATA(0x3F);
+	WMLCDDATA(0x01); //update VBIAS
+	WMLCDDATA(0x23);
+	WMLCDDATA(0x01);
+	WMLCDDATA(0xE6);
+	WMLCDDATA(0xE6);
+	WMLCDDATA(0xE6);
+	WMLCDDATA(0xE6);
+	WMLCDDATA(0xE6);
+
+
+	WMLCDCOM(0xB2);  // SET Display  480x800
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x20);
+	WMLCDDATA(0x05);
+	WMLCDDATA(0x05);
+	WMLCDDATA(0x70);  //70
+	WMLCDDATA(0x00); //00
+	WMLCDDATA(0xFF); //FF
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x00); //1
+	WMLCDDATA(0x03);
+	WMLCDDATA(0x03);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x01);
+
+
+
+	WMLCDCOM(0xB4);    // SET Display  480x800
+	WMLCDDATA(0x00);   //00
+	WMLCDDATA(0x18);   //18
+	WMLCDDATA(0x80);   //80
+	WMLCDDATA(0x06);
+	WMLCDDATA(0x02);
+
+	WMLCDCOM(0xB6);    // SET VCOM
+	WMLCDDATA(0x3A);   // Update VCOM
+	WMLCDDATA(0x3A);
+
+
+	/************CABC test ***************/
+
+	WMLCDCOM(0X51);//Write Display Brightness
+	WMLCDDATA(0Xff);//DBV[7:0]=0XE4
+	msleep(20);
+
+	/*
+	WMLCDCOM(0XC9);//SETCABC
+	WMLCDDATA(0X5F);//PWM_DIV="110" PWM_CLK 64·ÖÆµ INVPULS="1"
+	WMLCDDATA(0X7F);//WMLCDDATA(0X7F);
+	WMLCDDATA(0X20);//PWM_EPERIOD
+	WMLCDDATA(0X00);//SAVEPOWER[6:0]
+	WMLCDDATA(0X20);//DIM_FRAM[6:0]
+	WMLCDDATA(0X00);//
+	WMLCDDATA(0X03);//CABC_FLM
+	WMLCDDATA(0X20);//
+	msleep(20);
+	*/
+
+	WMLCDCOM(0X53);//WRITE CTRL DISPLAY
+	WMLCDDATA(0X24);//WMLCDDATA(0X26)  BCTRL="1" BL="1" DD="1"/"0"
+	msleep(20);
+
+	WMLCDCOM(0X55);
+	WMLCDDATA(0X02);//STILL PICTURE
+	msleep(20);
+
+	//WMLCDCOM(0X5E);//Write CABC minimum brightness (5Eh)
+	//WMLCDDATA(0X00);//CMB[7:0=0X00
+	//msleep(20);
+
+
+    /***************************************/
+
+    WMLCDCOM(0x2A);  //set window
+    WMLCDDATA(0x00);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x0);
+	WMLCDDATA(0xF0);
+
+	WMLCDCOM(0x2B);
+    WMLCDDATA(0x00);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x01);
+	WMLCDDATA(0x40);
+
+	WMLCDCOM(0xD5);  //Set GIP
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x04);
+	WMLCDDATA(0x03);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x01);
+	WMLCDDATA(0x05);
+	WMLCDDATA(0x28);
+    WMLCDDATA(0x70);
+	WMLCDDATA(0x01);
+	WMLCDDATA(0x03);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x40);
+	WMLCDDATA(0x06);
+	WMLCDDATA(0x51);
+	WMLCDDATA(0x07);
+	WMLCDDATA(0x00);
+    WMLCDDATA(0x00);
+	WMLCDDATA(0x41);
+	WMLCDDATA(0x06);
+	WMLCDDATA(0x50);
+	WMLCDDATA(0x07);
+	WMLCDDATA(0x07);
+	WMLCDDATA(0x0F);
+	WMLCDDATA(0x04);
+	WMLCDDATA(0x00);
+
+
+    //Gamma2.2
+	WMLCDCOM(0xE0);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x13);
+	WMLCDDATA(0x19);
+	WMLCDDATA(0x38);
+	WMLCDDATA(0x3D);
+	WMLCDDATA(0x3F);
+	WMLCDDATA(0x28);
+	WMLCDDATA(0x46);
+	WMLCDDATA(0x07);
+	WMLCDDATA(0x0D);
+	WMLCDDATA(0x0E);
+	WMLCDDATA(0x12);
+	WMLCDDATA(0x15);
+	WMLCDDATA(0x12);
+	WMLCDDATA(0x14);
+	WMLCDDATA(0x0F);
+	WMLCDDATA(0x17);
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x13);
+	WMLCDDATA(0x19);
+	WMLCDDATA(0x38);
+	WMLCDDATA(0x3D);
+	WMLCDDATA(0x3F);
+	WMLCDDATA(0x28);
+	WMLCDDATA(0x46);
+	WMLCDDATA(0x07);
+	WMLCDDATA(0x0D);
+	WMLCDDATA(0x0E);
+	WMLCDDATA(0x12);
+	WMLCDDATA(0x15);
+	WMLCDDATA(0x12);
+	WMLCDDATA(0x14);
+	WMLCDDATA(0x0F);
+	WMLCDDATA(0x17);
+	msleep(10);
+
+	//DGC Setting
+	WMLCDCOM(0xC1);
+	WMLCDDATA(0x01);
+
+	//R
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x04);
+	WMLCDDATA(0x11);
+	WMLCDDATA(0x19);
+	WMLCDDATA(0x20);
+	WMLCDDATA(0x29);
+	WMLCDDATA(0x30);
+	WMLCDDATA(0x37);
+	WMLCDDATA(0x40);
+	WMLCDDATA(0x4A);
+	WMLCDDATA(0x52);
+	WMLCDDATA(0x59);
+	WMLCDDATA(0x60);
+	WMLCDDATA(0x68);
+	WMLCDDATA(0x70);
+	WMLCDDATA(0x79);
+	WMLCDDATA(0x81);
+	WMLCDDATA(0x89);
+	WMLCDDATA(0x91);
+	WMLCDDATA(0x99);
+	WMLCDDATA(0xA1);
+	WMLCDDATA(0xA8);
+	WMLCDDATA(0xB0);
+	WMLCDDATA(0xB8);
+	WMLCDDATA(0xC1);
+	WMLCDDATA(0xC9);
+	WMLCDDATA(0xD0);
+	WMLCDDATA(0xD8);
+	WMLCDDATA(0xE1);
+	WMLCDDATA(0xE8);
+	WMLCDDATA(0xF1);
+	WMLCDDATA(0xF8);
+	WMLCDDATA(0xFF);
+	WMLCDDATA(0x31);
+	WMLCDDATA(0x9C);
+	WMLCDDATA(0x57);
+	WMLCDDATA(0xED);
+	WMLCDDATA(0x57);
+	WMLCDDATA(0x7F);
+	WMLCDDATA(0x61);
+	WMLCDDATA(0xAD);
+	WMLCDDATA(0xC0);
+//G
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x04);
+	WMLCDDATA(0x11);
+	WMLCDDATA(0x19);
+	WMLCDDATA(0x20);
+	WMLCDDATA(0x29);
+	WMLCDDATA(0x30);
+	WMLCDDATA(0x37);
+	WMLCDDATA(0x40);
+	WMLCDDATA(0x4A);
+	WMLCDDATA(0x52);
+	WMLCDDATA(0x59);
+	WMLCDDATA(0x60);
+	WMLCDDATA(0x68);
+	WMLCDDATA(0x70);
+	WMLCDDATA(0x79);
+	WMLCDDATA(0x81);
+	WMLCDDATA(0x89);
+	WMLCDDATA(0x91);
+	WMLCDDATA(0x99);
+	WMLCDDATA(0xA1);
+	WMLCDDATA(0xA8);
+	WMLCDDATA(0xB0);
+	WMLCDDATA(0xB8);
+	WMLCDDATA(0xC1);
+	WMLCDDATA(0xC9);
+	WMLCDDATA(0xD0);
+	WMLCDDATA(0xD8);
+	WMLCDDATA(0xE1);
+	WMLCDDATA(0xE8);
+	WMLCDDATA(0xF1);
+	WMLCDDATA(0xF8);
+	WMLCDDATA(0xFF);
+	WMLCDDATA(0x31);
+	WMLCDDATA(0x9C);
+	WMLCDDATA(0x57);
+	WMLCDDATA(0xED);
+	WMLCDDATA(0x57);
+	WMLCDDATA(0x7F);
+	WMLCDDATA(0x61);
+	WMLCDDATA(0xAD);
+	WMLCDDATA(0xC0);
+    //B
+	WMLCDDATA(0x00);
+	WMLCDDATA(0x04);
+	WMLCDDATA(0x11);
+	WMLCDDATA(0x19);
+	WMLCDDATA(0x20);
+	WMLCDDATA(0x29);
+	WMLCDDATA(0x30);
+	WMLCDDATA(0x37);
+	WMLCDDATA(0x40);
+	WMLCDDATA(0x4A);
+	WMLCDDATA(0x52);
+	WMLCDDATA(0x59);
+	WMLCDDATA(0x60);
+	WMLCDDATA(0x68);
+	WMLCDDATA(0x70);
+	WMLCDDATA(0x79);
+	WMLCDDATA(0x81);
+	WMLCDDATA(0x89);
+	WMLCDDATA(0x91);
+	WMLCDDATA(0x99);
+	WMLCDDATA(0xA1);
+	WMLCDDATA(0xA8);
+	WMLCDDATA(0xB0);
+	WMLCDDATA(0xB8);
+	WMLCDDATA(0xC1);
+	WMLCDDATA(0xC9);
+	WMLCDDATA(0xD0);
+	WMLCDDATA(0xD8);
+	WMLCDDATA(0xE1);
+	WMLCDDATA(0xE8);
+	WMLCDDATA(0xF1);
+	WMLCDDATA(0xF8);
+	WMLCDDATA(0xFF);
+	WMLCDDATA(0x31);
+	WMLCDDATA(0x9C);
+	WMLCDDATA(0x57);
+	WMLCDDATA(0xED);
+	WMLCDDATA(0x57);
+	WMLCDDATA(0x7F);
+	WMLCDDATA(0x61);
+	WMLCDDATA(0xAD);
+	WMLCDDATA(0xC0);
+	WMLCDCOM(0x2D);//Look up table
+
+	for(k = 0; k < 64; k++) //RED
+	{
+        WMLCDDATA(8*k);
+	}
+	for(k = 0; k < 64; k++) //GREEN
+	{
+	    WMLCDDATA(4*k);
+	}
+	for(k = 0; k < 64; k++) //BLUE
+	{
+        WMLCDDATA(8*k);
+	}
+
+	msleep(10);
+	WMLCDCOM(SET_PIXEL_FORMAT);   //pixel format setting
+	WMLCDDATA(0x77);
+
+	WMLCDCOM(EXIT_SLEEP_MODE);
+	msleep(120);
+
+	WMLCDCOM(SET_DISPLAY_ON);     //Display on
+	WMLCDCOM(WRITE_MEMORY_START);
+
+#endif
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return 0;
+}
+
+/* set lcd to sleep mode or not */
+
+int lcd_standby(u32 enable)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+    if(enable) {
+        mcu_ioctl(MCU_WRCMD, ENTER_SLEEP_MODE);
+        msleep(10);
+    } else {
+        mcu_ioctl(MCU_WRCMD, EXIT_SLEEP_MODE);
+        msleep(20);
+    }
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+
+    return 0;
+}
+
+/* set lcd to write memory mode, so the lcdc of RK29xx can send the fb content to the lcd internal ram in hold mode*/
+
+int lcd_refresh(u32 arg)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+    switch(arg)
+    {
+		case REFRESH_PRE:   //start to write the image data to lcd ram
+			mcu_ioctl(MCU_WRCMD, SET_COLUMN_ADDRESS);  //set
+			mcu_ioctl(MCU_WRDATA, 0);
+			mcu_ioctl(MCU_WRDATA, 0);
+			mcu_ioctl(MCU_WRDATA, (LCD_WIDTH >> 8) & 0x00ff);
+			mcu_ioctl(MCU_WRDATA, LCD_WIDTH & 0x00ff);
+			msleep(1);
+			mcu_ioctl(MCU_WRCMD, SET_PAGE_ADDRESS);
+			mcu_ioctl(MCU_WRDATA, 0);
+			mcu_ioctl(MCU_WRDATA, 0);
+			mcu_ioctl(MCU_WRDATA, (LCD_HEIGHT >> 8) & 0x00ff);
+			mcu_ioctl(MCU_WRDATA, LCD_HEIGHT & 0x00ff);
+			msleep(1);
+			mcu_ioctl(MCU_WRCMD, WRITE_MEMORY_START);
+			break;
+
+		case REFRESH_END:   //set display on
+			mcu_ioctl(MCU_WRCMD, SET_DISPLAY_ON);
+			break;
+
+		default:
+			break;
+    }
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+
+    return 0;
+}
+
+
+/* not used */
+
+int lcd_scandir(u32 dir)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+
+//  mcu_ioctl(MCU_WRCMD, SET_DISPLAY_OFF);
+
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return 0;
+}
+
+
+/* not used */
+
+int lcd_disparea(u32 area)
+{
+    mcu_ioctl(MCU_SETBYPASS, 1);
+    mcu_ioctl(MCU_SETBYPASS, 0);
+    return (0);
+}
+
+
+/* set real information about lcd which we use in this harware platform */
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info)
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    screen->width = LCD_WIDTH;
+    screen->height = LCD_HEIGHT;
+
+    /* Timing */
+    screen->lcdc_aclk = LCDC_ACLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	screen->mcu_wrperiod = P_WR;
+	screen->mcu_usefmk = USE_FMARK;
+    screen->mcu_frmrate = FRMRATE;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = lcd_init;
+    screen->standby = lcd_standby;
+    screen->scandir = lcd_scandir;
+    screen->refresh = lcd_refresh;
+    screen->disparea = lcd_disparea;
+}
+
+
+
+
+
+
diff --git a/drivers/video/display/screen/lcd_rgb_tft480800_25_e.c b/drivers/video/display/screen/lcd_rgb_tft480800_25_e.c
new file mode 100644
index 000000000000..0b5500e60939
--- /dev/null
+++ b/drivers/video/display/screen/lcd_rgb_tft480800_25_e.c
@@ -0,0 +1,548 @@
+/*
+ * Copyright (C) 2011 ROCKCHIP, Inc.
+ *
+ * author: hhb@rock-chips.com
+ * creat date: 2011-03-11
+ * route:drivers/video/display/screen/lcd_rgb_tft480800_25_e.c - driver for rk29 phone sdk
+ * station:haven't been tested in any hardware platform
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "screen.h"
+
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_P888
+#define OUT_CLK			23000000
+#define LCDC_ACLK       150000000     //29 lcdc axi DMA Ƶ��
+
+/* Timing */
+#define H_PW			1
+#define H_BP			120
+#define H_VD			800
+#define H_FP			20
+
+#define V_PW			1
+#define V_BP			20
+#define V_VD			480
+#define V_FP			4
+
+#define LCD_WIDTH       800    //need modify
+#define LCD_HEIGHT      480
+
+/* Other */
+#define DCLK_POL		1
+#define SWAP_RB			0
+
+
+/* define spi write command and data interface function */
+
+#define SIMULATION_SPI 1
+#ifdef SIMULATION_SPI
+
+    #define TXD_PORT        gLcd_info->txd_pin
+	#define CLK_PORT        gLcd_info->clk_pin
+	#define CS_PORT         gLcd_info->cs_pin
+	#define LCD_RST_PORT    1
+
+	#define CS_OUT()        gpio_direction_output(CS_PORT, 0)
+	#define CS_SET()        gpio_set_value(CS_PORT, GPIO_HIGH)
+	#define CS_CLR()        gpio_set_value(CS_PORT, GPIO_LOW)
+	#define CLK_OUT()       gpio_direction_output(CLK_PORT, 0)
+	#define CLK_SET()       gpio_set_value(CLK_PORT, GPIO_HIGH)
+	#define CLK_CLR()       gpio_set_value(CLK_PORT, GPIO_LOW)
+	#define TXD_OUT()       gpio_direction_output(TXD_PORT, 0)
+	#define TXD_SET()       gpio_set_value(TXD_PORT, GPIO_HIGH)
+	#define TXD_CLR()       gpio_set_value(TXD_PORT, GPIO_LOW)
+    #define LCD_RST_OUT()  gpio_direction_output(LCD_RST_PORT, 0)
+    #define LCD_RST(i)      gpio_set_value(LCD_RST_PORT, i)
+
+	#define bits_9 1
+	#ifdef bits_9  //9bits
+	#define LCDSPI_InitCMD(cmd)    spi_write_9bit(0, cmd)
+	#define LCDSPI_InitDAT(dat)    spi_write_9bit(1, dat)
+	#else  //16bits
+	#define LCDSPI_InitCMD(cmd)
+	#define LCDSPI_InitDAT(dat)
+	#endif
+	#define Lcd_EnvidOnOff(i)
+
+#else
+
+	#define bits_9 1
+	#ifdef bits_9  //9bits
+	#define LCDSPI_InitCMD(cmd)
+	#define LCDSPI_InitDAT(dat)
+	#else  //16bits
+	#define LCDSPI_InitCMD(cmd)
+	#define LCDSPI_InitDAT(dat)
+	#endif
+
+#endif
+
+
+/* define lcd command */
+#define ENTER_SLEEP_MODE        0x10
+#define EXIT_SLEEP_MODE         0x11
+#define SET_COLUMN_ADDRESS      0x2a
+#define SET_PAGE_ADDRESS        0x2b
+#define WRITE_MEMORY_START      0x2c
+#define SET_DISPLAY_ON          0x29
+#define SET_DISPLAY_OFF         0x28
+#define SET_ADDRESS_MODE        0x36
+#define SET_PIXEL_FORMAT        0x3a
+
+
+#define DRVDelayUs(i)   udelay(i*2)
+
+static struct rk29lcd_info *gLcd_info = NULL;
+int lcd_init(void);
+int lcd_standby(u32 enable);
+
+
+/* spi write a data frame,type mean command or data */
+int spi_write_9bit(u32 type, u32 value)
+{
+    u32 i = 0;
+
+    if(type != 0 && type != 1)
+    {
+    	return -1;
+    }
+    /*make a data frame of 9 bits,the 8th bit  0:mean command,1:mean data*/
+    value &= 0xff;
+    value &= (type << 8);
+
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    DRVDelayUs(2);
+    DRVDelayUs(2);
+
+    CS_SET();
+    TXD_SET();
+    CLK_SET();
+    DRVDelayUs(2);
+
+	CS_CLR();
+	for(i = 0; i < 9; i++)  //reg
+	{
+		if(value & (1 << (8-i)))
+        {
+			TXD_SET();
+		}
+        else
+        {
+			TXD_CLR();
+        }
+
+		CLK_CLR();
+		DRVDelayUs(2);
+		CLK_SET();
+		DRVDelayUs(2);
+	}
+
+	CS_SET();
+	CLK_CLR();
+	TXD_CLR();
+	DRVDelayUs(2);
+    return 0;
+}
+
+
+int lcd_init(void)
+{
+    if(gLcd_info)
+        gLcd_info->io_init();
+#if 1
+    TXD_OUT();
+    CLK_OUT();
+    CS_OUT();
+    CS_SET();
+    TXD_SET();
+    CLK_SET();
+    LCD_RST_OUT();
+	LCD_RST(1);
+	msleep(10);
+	LCD_RST(0);
+	msleep(100);
+	LCD_RST(1);
+	msleep(100);
+#endif
+
+#if 1
+
+	LCDSPI_InitCMD(0xB9);  // SET password
+	LCDSPI_InitDAT(0xFF);
+	LCDSPI_InitDAT(0x83);
+	LCDSPI_InitDAT(0x69);
+
+    LCDSPI_InitCMD(0xB1);  //Set Power
+    LCDSPI_InitDAT(0x85);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x34);
+	LCDSPI_InitDAT(0x07);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x0F);
+	LCDSPI_InitDAT(0x0F);
+	LCDSPI_InitDAT(0x2A);
+	LCDSPI_InitDAT(0x32);
+	LCDSPI_InitDAT(0x3F);
+	LCDSPI_InitDAT(0x3F);
+	LCDSPI_InitDAT(0x01); //update VBIAS
+	LCDSPI_InitDAT(0x3A);
+	LCDSPI_InitDAT(0x01);
+	LCDSPI_InitDAT(0xE6);
+	LCDSPI_InitDAT(0xE6);
+	LCDSPI_InitDAT(0xE6);
+	LCDSPI_InitDAT(0xE6);
+	LCDSPI_InitDAT(0xE6);
+
+
+
+	LCDSPI_InitCMD(0xB2);  // SET Display  480x800
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x28);  //23
+	LCDSPI_InitDAT(0x05); //03
+	LCDSPI_InitDAT(0x05);  //03
+	LCDSPI_InitDAT(0x70);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0xFF);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x03);
+	LCDSPI_InitDAT(0x03);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x01);
+
+
+	LCDSPI_InitCMD(0xB4);  // SET Display  480x800
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x18);
+	LCDSPI_InitDAT(0x80);
+	LCDSPI_InitDAT(0x06);
+	LCDSPI_InitDAT(0x02);
+
+
+
+	LCDSPI_InitCMD(0xB6);  // SET VCOM
+	LCDSPI_InitDAT(0x42);  // Update VCOM
+	LCDSPI_InitDAT(0x42);
+
+
+
+	LCDSPI_InitCMD(0xD5);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x04);
+	LCDSPI_InitDAT(0x03);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x01);
+	LCDSPI_InitDAT(0x05);
+	LCDSPI_InitDAT(0x28);
+    LCDSPI_InitDAT(0x70);
+	LCDSPI_InitDAT(0x01);
+	LCDSPI_InitDAT(0x03);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x40);
+	LCDSPI_InitDAT(0x06);
+	LCDSPI_InitDAT(0x51);
+	LCDSPI_InitDAT(0x07);
+	LCDSPI_InitDAT(0x00);
+    LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x41);
+	LCDSPI_InitDAT(0x06);
+	LCDSPI_InitDAT(0x50);
+	LCDSPI_InitDAT(0x07);
+	LCDSPI_InitDAT(0x07);
+	LCDSPI_InitDAT(0x0F);
+	LCDSPI_InitDAT(0x04);
+	LCDSPI_InitDAT(0x00);
+
+
+ ///Gamma2.2
+	LCDSPI_InitCMD(0xE0);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x13);
+	LCDSPI_InitDAT(0x19);
+	LCDSPI_InitDAT(0x38);
+	LCDSPI_InitDAT(0x3D);
+	LCDSPI_InitDAT(0x3F);
+	LCDSPI_InitDAT(0x28);
+	LCDSPI_InitDAT(0x46);
+	LCDSPI_InitDAT(0x07);
+	LCDSPI_InitDAT(0x0D);
+	LCDSPI_InitDAT(0x0E);
+	LCDSPI_InitDAT(0x12);
+	LCDSPI_InitDAT(0x15);
+	LCDSPI_InitDAT(0x12);
+	LCDSPI_InitDAT(0x14);
+	LCDSPI_InitDAT(0x0F);
+	LCDSPI_InitDAT(0x17);
+	LCDSPI_InitDAT(0x00);
+	LCDSPI_InitDAT(0x13);
+	LCDSPI_InitDAT(0x19);
+	LCDSPI_InitDAT(0x38);
+	LCDSPI_InitDAT(0x3D);
+	LCDSPI_InitDAT(0x3F);
+	LCDSPI_InitDAT(0x28);
+	LCDSPI_InitDAT(0x46);
+	LCDSPI_InitDAT(0x07);
+	LCDSPI_InitDAT(0x0D);
+	LCDSPI_InitDAT(0x0E);
+	LCDSPI_InitDAT(0x12);
+	LCDSPI_InitDAT(0x15);
+	LCDSPI_InitDAT(0x12);
+	LCDSPI_InitDAT(0x14);
+	LCDSPI_InitDAT(0x0F);
+	LCDSPI_InitDAT(0x17);
+
+
+	msleep(10);
+
+///DGC Setting
+	LCDSPI_InitCMD(0xC1);
+	LCDSPI_InitDAT(0x01);
+//R
+	LCDSPI_InitDAT(0x04);
+	LCDSPI_InitDAT(0x13);
+	LCDSPI_InitDAT(0x1a);
+	LCDSPI_InitDAT(0x20);
+	LCDSPI_InitDAT(0x27);
+	LCDSPI_InitDAT(0x2c);
+	LCDSPI_InitDAT(0x32);
+	LCDSPI_InitDAT(0x36);
+	LCDSPI_InitDAT(0x3f);
+	LCDSPI_InitDAT(0x47);
+	LCDSPI_InitDAT(0x50);
+	LCDSPI_InitDAT(0x59);
+	LCDSPI_InitDAT(0x60);
+	LCDSPI_InitDAT(0x68);
+	LCDSPI_InitDAT(0x71);
+	LCDSPI_InitDAT(0x7B);
+	LCDSPI_InitDAT(0x82);
+	LCDSPI_InitDAT(0x89);
+	LCDSPI_InitDAT(0x91);
+	LCDSPI_InitDAT(0x98);
+	LCDSPI_InitDAT(0xA0);
+	LCDSPI_InitDAT(0xA8);
+	LCDSPI_InitDAT(0xB0);
+	LCDSPI_InitDAT(0xB8);
+	LCDSPI_InitDAT(0xC1);
+	LCDSPI_InitDAT(0xC9);
+	LCDSPI_InitDAT(0xD0);
+	LCDSPI_InitDAT(0xD7);
+	LCDSPI_InitDAT(0xE0);
+	LCDSPI_InitDAT(0xE7);
+	LCDSPI_InitDAT(0xEF);
+	LCDSPI_InitDAT(0xF7);
+	LCDSPI_InitDAT(0xFE);
+	LCDSPI_InitDAT(0xCF);
+	LCDSPI_InitDAT(0x52);
+	LCDSPI_InitDAT(0x34);
+	LCDSPI_InitDAT(0xF8);
+	LCDSPI_InitDAT(0x51);
+	LCDSPI_InitDAT(0xF5);
+	LCDSPI_InitDAT(0x9D);
+	LCDSPI_InitDAT(0x75);
+	LCDSPI_InitDAT(0x00);
+//G
+	LCDSPI_InitDAT(0x04);
+	LCDSPI_InitDAT(0x13);
+	LCDSPI_InitDAT(0x1a);
+	LCDSPI_InitDAT(0x20);
+	LCDSPI_InitDAT(0x27);
+	LCDSPI_InitDAT(0x2c);
+	LCDSPI_InitDAT(0x32);
+	LCDSPI_InitDAT(0x36);
+	LCDSPI_InitDAT(0x3f);
+	LCDSPI_InitDAT(0x47);
+	LCDSPI_InitDAT(0x50);
+	LCDSPI_InitDAT(0x59);
+	LCDSPI_InitDAT(0x60);
+	LCDSPI_InitDAT(0x68);
+	LCDSPI_InitDAT(0x71);
+	LCDSPI_InitDAT(0x7B);
+	LCDSPI_InitDAT(0x82);
+	LCDSPI_InitDAT(0x89);
+	LCDSPI_InitDAT(0x91);
+	LCDSPI_InitDAT(0x98);
+	LCDSPI_InitDAT(0xA0);
+	LCDSPI_InitDAT(0xA8);
+	LCDSPI_InitDAT(0xB0);
+	LCDSPI_InitDAT(0xB8);
+	LCDSPI_InitDAT(0xC1);
+	LCDSPI_InitDAT(0xC9);
+	LCDSPI_InitDAT(0xD0);
+	LCDSPI_InitDAT(0xD7);
+	LCDSPI_InitDAT(0xE0);
+	LCDSPI_InitDAT(0xE7);
+	LCDSPI_InitDAT(0xEF);
+	LCDSPI_InitDAT(0xF7);
+	LCDSPI_InitDAT(0xFE);
+	LCDSPI_InitDAT(0xCF);
+	LCDSPI_InitDAT(0x52);
+	LCDSPI_InitDAT(0x34);
+	LCDSPI_InitDAT(0xF8);
+	LCDSPI_InitDAT(0x51);
+	LCDSPI_InitDAT(0xF5);
+	LCDSPI_InitDAT(0x9D);
+	LCDSPI_InitDAT(0x75);
+	LCDSPI_InitDAT(0x00);
+//B
+	LCDSPI_InitDAT(0x04);
+	LCDSPI_InitDAT(0x13);
+	LCDSPI_InitDAT(0x1a);
+	LCDSPI_InitDAT(0x20);
+	LCDSPI_InitDAT(0x27);
+	LCDSPI_InitDAT(0x2c);
+	LCDSPI_InitDAT(0x32);
+	LCDSPI_InitDAT(0x36);
+	LCDSPI_InitDAT(0x3f);
+	LCDSPI_InitDAT(0x47);
+	LCDSPI_InitDAT(0x50);
+	LCDSPI_InitDAT(0x59);
+	LCDSPI_InitDAT(0x60);
+	LCDSPI_InitDAT(0x68);
+	LCDSPI_InitDAT(0x71);
+	LCDSPI_InitDAT(0x7B);
+	LCDSPI_InitDAT(0x82);
+	LCDSPI_InitDAT(0x89);
+	LCDSPI_InitDAT(0x91);
+	LCDSPI_InitDAT(0x98);
+	LCDSPI_InitDAT(0xA0);
+	LCDSPI_InitDAT(0xA8);
+	LCDSPI_InitDAT(0xB0);
+	LCDSPI_InitDAT(0xB8);
+	LCDSPI_InitDAT(0xC1);
+	LCDSPI_InitDAT(0xC9);
+	LCDSPI_InitDAT(0xD0);
+	LCDSPI_InitDAT(0xD7);
+	LCDSPI_InitDAT(0xE0);
+	LCDSPI_InitDAT(0xE7);
+	LCDSPI_InitDAT(0xEF);
+	LCDSPI_InitDAT(0xF7);
+	LCDSPI_InitDAT(0xFE);
+	LCDSPI_InitDAT(0xCF);
+	LCDSPI_InitDAT(0x52);
+	LCDSPI_InitDAT(0x34);
+	LCDSPI_InitDAT(0xF8);
+	LCDSPI_InitDAT(0x51);
+	LCDSPI_InitDAT(0xF5);
+	LCDSPI_InitDAT(0x9D);
+	LCDSPI_InitDAT(0x75);
+	LCDSPI_InitDAT(0x00);
+
+	msleep(10);
+
+
+    //LCDSPI_InitCMD(0x36);
+    //LCDSPI_InitDAT(0x80);   //µ÷Õû36HÖÐµÄ²ÎÊý¿ÉÒÔÊµÏÖGATEºÍSOURCEµÄ·­×ª
+
+    LCDSPI_InitCMD(SET_PIXEL_FORMAT);
+    LCDSPI_InitDAT(0x77);
+
+    LCDSPI_InitCMD(EXIT_SLEEP_MODE);
+    msleep(120);
+
+	LCDSPI_InitCMD(SET_DISPLAY_ON);
+
+	LCDSPI_InitCMD(WRITE_MEMORY_START);
+#endif
+
+    if(gLcd_info)
+        gLcd_info->io_deinit();
+
+    return 0;
+}
+
+int lcd_standby(u32 enable)
+{
+    if(gLcd_info)
+        gLcd_info->io_init();
+
+	if(enable) {
+		Lcd_EnvidOnOff(0);  //RGB TIMENG OFF
+		LCDSPI_InitCMD(ENTER_SLEEP_MODE);
+		Lcd_EnvidOnOff(1);  //RGB TIMENG ON
+		msleep(200);
+		Lcd_EnvidOnOff(0);  //RGB TIMENG OFF
+		msleep(100);
+	} else {
+		//LCD_RESET();
+		LCDSPI_InitCMD(EXIT_SLEEP_MODE);
+		msleep(200);
+		Lcd_EnvidOnOff(1);  //RGB TIMENG ON
+		msleep(200);
+	}
+
+    if(gLcd_info)
+        gLcd_info->io_deinit();
+
+    return 0;
+}
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    screen->width = LCD_WIDTH;
+    screen->height = LCD_HEIGHT;
+
+    /* Timing */
+    screen->lcdc_aclk = LCDC_ACLK;
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = lcd_init;
+    screen->standby = lcd_standby;
+    if(lcd_info)
+        gLcd_info = lcd_info;
+}
+
+
+
-- 
2.35.3

