From ecf80461d23d8fe9910379b334c6657a9257ff8e Mon Sep 17 00:00:00 2001
From: yzq <yzq@rock-chips.com>
Date: Mon, 20 Aug 2012 10:29:14 +0800
Subject: [PATCH] rk2928 hdmi: remove unnecessary files and update low power
 mode

---
 .../hdmi/chips/rk2928/rk2928_hdmi_hw.c        |  12 +-
 .../hdmi/chips/rk2928/rk2928_hdmi_hw.hbak     | 497 ------------------
 drivers/video/rockchip/hdmi/rk_hdmi_core.c    | 254 ---------
 3 files changed, 6 insertions(+), 757 deletions(-)
 delete mode 100755 drivers/video/rockchip/hdmi/chips/rk2928/rk2928_hdmi_hw.hbak
 delete mode 100755 drivers/video/rockchip/hdmi/rk_hdmi_core.c

diff --git a/drivers/video/rockchip/hdmi/chips/rk2928/rk2928_hdmi_hw.c b/drivers/video/rockchip/hdmi/chips/rk2928/rk2928_hdmi_hw.c
index fb1c0686cbef..b5dd18054bff 100755
--- a/drivers/video/rockchip/hdmi/chips/rk2928/rk2928_hdmi_hw.c
+++ b/drivers/video/rockchip/hdmi/chips/rk2928/rk2928_hdmi_hw.c
@@ -55,12 +55,12 @@ static void rk2928_hdmi_set_pwr_mode(int mode)
 	case LOWER_PWR:
 		rk2928_hdmi_av_mute(0);
 	   	rk2928_hdmi_sys_power_down();
-		HDMIWrReg(0xe0, 0x0a);
-	    HDMIWrReg(0xe1, 0x03);
-	    HDMIWrReg(0xe2, 0x99);
-	    HDMIWrReg(0xe3, 0x0f);
-		HDMIWrReg(0xe4, 0x00);
-		HDMIWrReg(0xec, 0x02);
+		HDMIWrReg(0xe0, 0x3a);
+	    HDMIWrReg(0xe1, 0x00);
+	    HDMIWrReg(0xe2, 0x00);
+	    HDMIWrReg(0xe3, 0x00);
+		HDMIWrReg(0xe4, 0x03);
+		HDMIWrReg(0xec, 0x03);
 		break;
 	default:
 	    hdmi_dbg(hdmi->dev,"unkown rk2928 hdmi pwr mode %d\n",mode);
diff --git a/drivers/video/rockchip/hdmi/chips/rk2928/rk2928_hdmi_hw.hbak b/drivers/video/rockchip/hdmi/chips/rk2928/rk2928_hdmi_hw.hbak
deleted file mode 100755
index fe06fe040278..000000000000
--- a/drivers/video/rockchip/hdmi/chips/rk2928/rk2928_hdmi_hw.hbak
+++ /dev/null
@@ -1,497 +0,0 @@
-#ifndef __RK2928_HDMI_HW_H__
-#define __RK2928_HDMI_HW_H__
-
-
-//0x00
-#define INT_POL       1
-#define SYS_PWR_ON    0
-#define SYS_PWR_OFF   1
-#define PHY_CLK       0
-#define SYS_CLK       1
-
-#define MCLK_FS       0x01    //256fs
-//0x01
-// INPUT_VIDEO_FORMAT
-#define RGB_YUV444          0x00
-#define DDR_RGB444_YUV444   0x05
-#define DDR_YUV422          0x06
-
-//0x02
-//video output format
-#define RGB444              0x00
-#define YUV444              0x01
-#define YUV422              0x02
-
-//DATA WIDTH
-#define DATA_12BIT          0X00
-#define DATA_10BIT          0X01
-#define DATA_8BIT           0X03
-
-//0X04
-//1:after 0:not After 1st sof for external DE sample
-#define DE_AFTER_SOF        0
-#define DE_NOAFTER_SOF      1
-
-#define CSC_ENABLE          0
-#define CSC_DISABLE         1
-
-//0X05
-#define CLEAR_AVMUTE(x)        (x)<<7
-#define SET_AVMUTE(x)          (x)<<6
-#define AUDIO_MUTE(x)          (x)<<1
-#define VIDEO_BLACK(x)         (x)<<0    //1:black 0:normal
-
-//0x08
-#define VSYNC_POL(x)            (x)<<3   //0:Negative 1:Positive
-#define HSYNC_POL(x)            (x)<<2      //0:Negative 1:Positive
-#define INTER_PROGRESSIVE(x)    (x)<<1  //0: progressive 1:interlace
-#define VIDEO_SET_ENABLE(x)     (x)<<0  //0:disable 1: enable
-
-/*          0xe1        */  
-//Main-driver strength :0000~1111: the strength from low to high
-#define M_DRIVER_STR(x)         (((x)&0xf)<<4)
-//Pre-driver strength  :00~11: the strength from low to high
-#define P_DRIVER_STR(x)         (((x)&3)<<2)
-//TX driver enable  1: enable   0: disable
-#define TX_DRIVER_EN(x)         (((x)&1)<<1)
-/*          0xe2        */ 
-//Pre-emphasis strength 00~11: the strength from 0 to high
-#define P_EMPHASIS_STR(x)       (((x)&3)<<4)
-//Power down TMDS driver      1: power down. 0: not
-#define PWR_DOWN_TMDS(x)        (((x)&1)<<0)
-/*          0xe3        */ 
-//PLL out enable.   Just for test. need set to 1â€™b0
-#define PLL_OUT_EN(x)           (((x)&1)<<7)
-/*          0xe4        */
-// Band-Gap power down  11: power down  00: not
-#define BAND_PWR(x)             (((x)&3)<<0)
-/*          0xe5        */ 
-//PLL disable   1: disable  0: enable
-#define PLL_PWR(x)              (((x)&1)<<4)
-//  PLL reset   1: reset    0: not
-#define PLL_RST(x)              (((x)&1)<<3)
-//PHY TMDS channels reset   1: reset    0: not
-#define TMDS_RST(x)             (((x)&1)<<2)
-/*          0xe7        */ 
-// PLL LDO power down   1: power down   0: not
-#define PLL_LDO_PWR(x)      (((x)&1)<<2) 
-
-enum PWR_MODE{
-    NORMAL,
-    LOWER_PWR,
-};
-
-#if 0
-/* HDMI_SYS_CONTROL */
-#define SYS_CTRL	0x0
-
-enum {
-	PWR_SAVE_MODE_A = 1,
-	PWR_SAVE_MODE_B = 2,
-	PWR_SAVE_MODE_D = 4,
-	PWR_SAVE_MODE_E = 8
-};
-#define m_PWR_SAVE_MODE		0xF0
-#define v_PWR_SAVE_MODE(n)	(n << 4)
-#define PLL_B_RESET			(1 << 3)
-
-#define N_32K 		0x1000
-#define N_441K 		0x1880
-#define N_882K 		0x3100
-#define N_1764K 	0x6200
-#define N_48K 		0x1800
-#define N_96K		0x3000
-#define N_192K 		0x6000
-
-#define LR_SWAP_N3			0x04
-#define N_2					0x08
-#define N_1					0x0c
-
-#define AUDIO_CTRL1			0x28
-#define AUDIO_CTRL2 		0x2c
-#define I2S_AUDIO_CTRL		0x30
-enum {
-	I2S_MODE_STANDARD = 0,
-	I2S_MODE_RIGHT_JUSTIFIED,
-	I2S_MODE_LEFT_JUSTIFIED
-};
-#define v_I2S_MODE(n)		n
-enum {
-	I2S_CHANNEL_1_2 = 1,
-	I2S_CHANNEL_3_4 = 3,
-	I2S_CHANNEL_5_6 = 7,
-	I2S_CHANNEL_7_8 = 0xf
-};
-#define v_I2S_CHANNEL(n)	( (n) << 2 )
-
-#define I2S_INPUT_SWAP		0x40
-
-#define SRC_NUM_AUDIO_LEN	0x50
-
-/* HDMI_AV_CTRL1*/
-#define AV_CTRL1	0x54
-enum {
-	AUDIO_32K	= 0x3,
-	AUDIO_441K	= 0x0,
-	AUDIO_48K	= 0x2,
-	AUDIO_882K	= 0x8,
-	AUDIO_96K	= 0xa,
-	AUDIO_1764K	= 0xc,
-	AUDIO_192K	= 0xe,
-};
-#define m_AUDIO_SAMPLE_RATE		0xF0
-#define v_AUDIO_SAMPLE_RATE(n)	(n << 4)
-#define m_INPUT_VIDEO_MODE			(7 << 1)
-#define v_INPUT_VIDEO_MODE(n)		(n << 1)
-enum {
-	INTERNAL_DE = 0,
-	EXTERNAL_DE
-};
-#define m_DE_SIGNAL_SELECT			(1 << 0)
-
-/* HDMI_AV_CTRL2 */
-#define AV_CTRL2	0xec
-#define m_CSC_ENABLE				(1 << 0)
-#define v_CSC_ENABLE(n)				(n)
-
-/* HDMI_VIDEO_CTRL1 */
-#define VIDEO_CTRL1	0x58
-
-#define m_VIDEO_OUTPUT_MODE		(0x3 << 6)
-#define v_VIDEO_OUTPUT_MODE(n)	(n << 6)
-enum {
-	VIDEO_INPUT_DEPTH_12BIT = 0,
-	VIDEO_INPUT_DEPTH_10BIT = 0x1,
-	VIDEO_INPUT_DEPTH_8BIT = 0x3
-};
-#define m_VIDEO_INPUT_DEPTH		(3 << 4)
-#define v_VIDEO_INPUT_DEPTH(n)	(n << 4)
-enum {
-	VIDEO_EMBEDDED_SYNC_LOCATION_0 = 0,
-	VIDEO_EMBEDDED_SYNC_LOCATION_1,
-	VIDEO_EMBEDDED_SYNC_LOCATION_2
-};
-#define m_VIDEO_EMBEDDED_SYNC_LOCATION		(3 << 2)
-#define VIDEO_EMBEDDED_SYNC_LOCATION(n)		(n << 2)
-#define m_VIDEO_INPUT_COLOR_MODE			(1 << 0)
-
-/* DEEP_COLOR_MODE */
-#define DEEP_COLOR_MODE	0x5c
-enum{
-	TMDS_CLOCK_MODE_8BIT = 0,
-	TMDS_CLOKK_MODE_10BIT,
-	TMDS_CLOKK_MODE_12BIT
-};
-#define TMDS_CLOCK_MODE_MASK	0x3 << 6
-#define TMDS_CLOCK_MODE(n)		(n) << 6
-
-/* VIDEO_CTRL2 */
-#define VIDEO_SETTING2	0x114
-#define m_UNMUTE					(1 << 7)
-#define m_MUTE						(1 << 6)
-#define m_AUDIO_RESET				(1 << 2)
-#define m_NOT_SEND_AUDIO			(1 << 1)
-#define m_NOT_SEND_VIDEO			(1 << 0)
-#define AV_UNMUTE					(1 << 7)		// Unmute video and audio, send normal video and audio data
-#define AV_MUTE						(1 << 6)		// Mute video and audio, send black video data and silent audio data
-#define AUDIO_CAPTURE_RESET			(1 << 2)		// Reset audio process logic, only available in pwr_e mode.
-#define NOT_SEND_AUDIO				(1 << 1)		// Send silent audio data
-#define NOT_SEND_VIDEO				(1 << 0)		// Send black video data
-
-/* Color Space Convertion Parameter*/
-#define CSC_PARA_C0_H	0x60
-#define CSC_PARA_C0_L	0x64
-#define CSC_PARA_C1_H	0x68
-#define CSC_PARA_C1_L	0x6c
-#define CSC_PARA_C2_H	0x70
-#define CSC_PARA_C2_L	0x74
-#define CSC_PARA_C3_H	0x78
-#define CSC_PARA_C3_L	0x7c
-#define CSC_PARA_C4_H	0x80
-#define CSC_PARA_C4_L	0x84
-#define CSC_PARA_C5_H	0x88
-#define CSC_PARA_C5_L	0x8c
-#define CSC_PARA_C6_H	0x90
-#define CSC_PARA_C6_L	0x94
-#define CSC_PARA_C7_H	0x98
-#define CSC_PARA_C7_L	0x9c
-#define CSC_PARA_C8_H	0xa0
-#define CSC_PARA_C8_L	0xa4
-#define CSC_PARA_C9_H	0xa8
-#define CSC_PARA_C9_L	0xac
-#define CSC_PARA_C10_H	0xac
-#define CSC_PARA_C10_L	0xb4
-#define CSC_PARA_C11_H	0xb8
-#define CSC_PARA_C11_L	0xbc
-
-#define CSC_CONFIG1		0x34c
-#define m_CSC_MODE			(1 << 7)
-#define m_CSC_COEF_MODE 	(0xF << 3)	//Only used in auto csc mode
-#define m_CSC_STATUS		(1 << 2)
-#define m_CSC_VID_SELECT	(1 << 1)
-#define m_CSC_BRSWAP_DIABLE	(1)
-
-enum {
-	CSC_MODE_MANUAL	= 0,
-	CSC_MODE_AUTO
-};
-#define v_CSC_MODE(n)			(n << 7)
-enum {
-	COE_SDTV_LIMITED_RANGE = 0x08,
-	COE_SDTV_FULL_RANGE = 0x04,
-	COE_HDTV_60Hz = 0x2,
-	COE_HDTV_50Hz = 0x1
-};
-#define v_CSC_COE_MODE(n)		(n << 3)
-enum {
-	CSC_INPUT_VID_5_19 = 0,
-	CSC_INPUT_VID_28_29
-};
-#define v_CSC_VID_SELECT(n)		(n << 1)
-#define v_CSC_BRSWAP_DIABLE(n)	(n)
-#endif
-/* CONTROL_PACKET_BUF_INDEX */
-#define CONTROL_PACKET_BUF_INDEX	0x17c
-enum {
-	INFOFRAME_AVI = 0x06,
-	INFOFRAME_AAI = 0x08
-};
-#define CONTROL_PACKET_HB0			0x180
-#define CONTROL_PACKET_HB1			0x184
-#define CONTROL_PACKET_HB2			0x188
-#define CONTROL_PACKET_PB_ADDR		0x18c
-#define SIZE_AVI_INFOFRAME			0x11	// 17 bytes
-#define SIZE_AUDIO_INFOFRAME		0x0F	// 15 bytes
-enum {
-	AVI_COLOR_MODE_RGB = 0,
-	AVI_COLOR_MODE_YCBCR422,
-	AVI_COLOR_MODE_YCBCR444
-};
-enum {
-	AVI_COLORIMETRY_NO_DATA = 0,
-	AVI_COLORIMETRY_SMPTE_170M,
-	AVI_COLORIMETRY_ITU709,
-	AVI_COLORIMETRY_EXTENDED
-};
-enum {
-	AVI_CODED_FRAME_ASPECT_NO_DATA,
-	AVI_CODED_FRAME_ASPECT_4_3,
-	AVI_CODED_FRAME_ASPECT_16_9
-};
-enum {
-	ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME = 0x08,
-	ACTIVE_ASPECT_RATE_4_3,
-	ACTIVE_ASPECT_RATE_16_9,
-	ACTIVE_ASPECT_RATE_14_9
-};
-#if 0
-/* External Video Parameter Setting*/
-#define EXT_VIDEO_PARA			0xC0
-#define m_VSYNC_OFFSET			(0xF << 4)
-#define m_VSYNC_POLARITY		(1 << 3)
-#define m_HSYNC_POLARITY		(1 << 2)
-#define m_INTERLACE				(1 << 1)
-#define m_EXT_VIDEO_ENABLE		(1 << 0)
-
-#define v_VSYNC_OFFSET(n)		(n << 4)
-#define v_VSYNC_POLARITY(n)		(n << 3)
-#define v_HSYNC_POLARITY(n)		(n << 2)
-#define v_INTERLACE(n)			(n << 1)
-#define v_EXT_VIDEO_ENABLE(n)	(n << 0) 
-
-#define EXT_VIDEO_PARA_HTOTAL_L		0xC4
-#define EXT_VIDEO_PARA_HTOTAL_H		0xC8
-#define EXT_VIDEO_PARA_HBLANK_L		0xCC
-#define EXT_VIDEO_PARA_HBLANK_H		0xD0
-#define EXT_VIDEO_PARA_HDELAY_L		0xD4
-#define EXT_VIDEO_PARA_HDELAY_H		0xD8
-#define EXT_VIDEO_PARA_HSYNCWIDTH_L	0xDC
-#define EXT_VIDEO_PARA_HSYNCWIDTH_H	0xE0
-
-#define EXT_VIDEO_PARA_VTOTAL_L		0xE4
-#define EXT_VIDEO_PARA_VTOTAL_H		0xE8
-#define EXT_VIDEO_PARA_VBLANK_L		0xF4
-#define EXT_VIDEO_PARA_VDELAY		0xF8
-#define EXT_VIDEO_PARA_VSYNCWIDTH	0xFC
-
-#define PHY_PLL_SPEED				0x158
-	#define v_TEST_EN(n)			(n << 6)
-	#define v_PLLA_BYPASS(n)		(n << 4)
-	#define v_PLLB_SPEED(n)			(n << 2)
-	#define v_PLLA_SPEED(n)			(n)
-	enum {
-		PLL_SPEED_LOWEST = 0,
-		PLL_SPEED_MIDLOW,
-		PLL_SPEED_MIDHIGH,
-		PLL_SPEED_HIGHEST
-	};
-
-#define PHY_PLL_17					0x15c		// PLL A & B config bit 17
-	#define v_PLLA_BIT17(n)			(n << 2)
-	#define v_PLLB_BIT17(n)			(n << 1)
-	
-#define PHY_BGR						0x160
-	#define v_BGR_DISCONNECT(n)		(n << 7)
-	#define v_BGR_V_OFFSET(n)		(n << 4)
-	#define v_BGR_I_OFFSET(n)		(n)
-
-#define PHY_PLLA_1					0x164
-#define PHY_PLLA_2					0x168
-#define PHY_PLLB_1					0x16c
-#define PHY_PLLB_2					0x170
-
-#define PHY_DRIVER_PREEMPHASIS		0x174
-	#define v_TMDS_SWING(n)			(n << 4)
-	#define v_PRE_EMPHASIS(n)		(n)
-	
-#define PHY_PLL_16_AML				0x178		// PLL A & B config bit 16 and AML control
-	#define v_PLLA_BIT16(n)			(n << 5)
-	#define v_PLLB_BIT16(n)			(n << 4)
-	#define v_AML(n)				(n)
-#endif
-/* Interrupt Setting */
-#define INTR_MASK1					0xc0
-#define INTR_STATUS1				0xc1
-	#define m_INT_HOTPLUG				(1 << 7)
-	#define m_INT_VSYNC					(1 << 5)
-	#define m_INT_EDID_READY			(1 << 2)
-
-#define INTR_MASK2					0xc2
-#define INTR_STATUS2				0xc3
-	#define m_INT_HDCP_ERR				(1 << 7)	// HDCP error detected
-	#define m_INT_BKSV_RPRDY			(1 << 6)	// BKSV list ready from repeater
-	#define m_INT_AUTH_DONE				(1 << 4)	// HDCP authentication done
-
-#if 0
-#define DDC_READ_FIFO_ADDR			0x200
-#define DDC_BUS_FREQ_L				0x204
-#define DDC_BUS_FREQ_H				0x208
-#define DDC_BUS_CTRL				0x2dc
-#define DDC_I2C_LEN					0x278
-#define DDC_I2C_OFFSET				0x280
-#define DDC_I2C_CTRL				0x284
-#define DDC_I2C_READ_BUF0			0x288
-#define DDC_I2C_READ_BUF1			0x28c
-#define DDC_I2C_READ_BUF2			0x290
-#define DDC_I2C_READ_BUF3			0x294
-#define DDC_I2C_WRITE_BUF0			0x298
-#define DDC_I2C_WRITE_BUF1			0x29c
-#define DDC_I2C_WRITE_BUF2			0x2a0
-#define DDC_I2C_WRITE_BUF3			0x2a4
-#define DDC_I2C_WRITE_BUF4			0x2ac
-#define DDC_I2C_WRITE_BUF5			0x2b0
-#define DDC_I2C_WRITE_BUF6			0x2b4
-
-#endif
-#define EDID_SEGMENT_POINTER		0x4d
-#define EDID_WORD_ADDR				0x4e
-#define EDID_FIFO_ADDR				0x4f
-
-#define PIN_STATUS				0xc8
-#define m_HOTPLUG_STATUS			(1 << 7)
-#define m_DDCSDA_STATUS 		(1 << 5)
-#define m_DDCSCL_STATUS 		(1 << 4)
-#if 0
-/* HDCP_CTRL */
-#define HDCP_CTRL		0x2bc
-	enum {
-		OUTPUT_DVI = 0,
-		OUTPUT_HDMI
-	};
-	#define m_HDCP_AUTH_START			(1 << 7)	// start hdcp
-	#define m_HDCP_BKSV_PASS			(1 << 6)	// bksv valid
-	#define m_HDCP_BKSV_FAILED			(1 << 5)	// bksv invalid
-	#define m_HDCP_FRAMED_ENCRYPED		(1 << 4)
-	#define m_HDCP_AUTH_STOP			(1 << 3)	// stop hdcp
-	#define m_HDCP_ADV_CIPHER			(1 << 2)	// advanced cipher mode
-	#define m_HDMI_DVI					(1 << 1)
-	#define m_HDCP_RESET				(1 << 0)	// reset hdcp
-	#define v_HDCP_AUTH_START(n)		(n << 7)
-	#define v_HDCP_BKSV_PASS(n)			(n << 6)
-	#define v_HDCP_BKSV_FAILED(n)		(n << 5)
-	#define v_HDCP_FRAMED_ENCRYPED(n)	(n << 4)
-	#define v_HDCP_AUTH_STOP(n)			(n << 3)
-	#define v_HDCP_ADV_CIPHER(n)		(n << 2)
-	#define v_HDMI_DVI(n)				(n << 1)
-	#define v_HDCP_RESET(n)				(n << 0)
-#define HDCP_CTRL2		0x340
-
-/* HDCP Key Memory Access Control */
-#define HDCP_KEY_ACCESS_CTRL1	0x338
-#define HDCP_KEY_ACCESS_CTRL2	0x33c
-	#define m_LOAD_FACSIMILE_HDCP_KEY	(1 << 1)
-	#define m_LOAD_HDCP_KEY				(1 << 0)
-/* HDCP Key Memory Control */
-#define HDCP_KEY_MEM_CTRL	0x348
-	#define m_USE_KEY1		(1 << 6)
-	#define m_USE_KEY2		(1 << 5)
-	#define m_LOAD_AKSV		(1 << 4)
-	#define m_KSV_SELECTED	(1 << 3)
-	#define m_KSV_VALID		(1 << 2)
-	#define m_KEY_VALID		(1 << 1)
-	#define m_KEY_READY		(1 << 0)
-	#define v_USE_KEY1(n)	(n << 6)
-	#define v_USE_KEY2(n)	(n << 5)
-	#define v_LOAD_AKSV(n)	(n << 4)
-
-/* HDCP B device capacity */
-#define HDCP_BCAPS				0x2f8
-	#define m_HDMI_RECEIVED			(1 << 7) //If HDCP receiver support HDMI, this bit must be 1.
-	#define m_REPEATER				(1 << 6)
-	#define m_KSV_FIFO_READY		(1 << 5)
-	#define m_DDC_FAST				(1 << 4)
-	#define m_1_1_FEATURE			(1 << 1)
-	#define m_FAST_REAUTHENTICATION	(1 << 0) //For HDMI, this function is supported whether this bit is enabled or not.
-
-/* HDCP KSV Value */
-#define HDCP_KSV_BYTE0			0x2fc
-#define HDCP_KSV_BYTE1			0x300
-#define HDCP_KSV_BYTE2			0x304
-#define HDCP_KSV_BYTE3			0x308
-#define HDCP_KSV_BYTE4			0x30c
-
-/* HDCP error status */
-#define HDCP_ERROR				0x320
-
-/* HDCP 100 ms timer */
-#define HDCP_TIMER_100MS		0x324
-/* HDCP 5s timer */
-#define HDCP_TIMER_5S			0x328
-
-/* HDCP Key ram address */
-#define HDCP_RAM_KEY_KSV1		0x400
-#define HDCP_RAM_KEY_KSV2		0x407
-#define HDCP_RAM_KEY_PRIVATE	0x40e
-#define HDCP_KEY_LENGTH			0x13C
-
-
-#define HDCP_ENABLE_HW_AUTH		// Enable hardware authentication mode	
-#define HDMI_INTERANL_CLK_DIV	0x19
-
-#define HDMIRdReg(addr)						__raw_readl(hdmi->regbase + addr)
-#define HDMIWrReg(addr, val)        		__raw_writel((val), hdmi->regbase + addr);
-#define HDMIMskReg(temp, addr, msk, val)	\
-	temp = __raw_readl(hdmi->regbase + addr) & (0xFF - (msk)) ; \
-	__raw_writel(temp | ( (val) & (msk) ),  hdmi->regbase + addr); 
-
-
-
-/* Color Space Convertion Mode */
-enum {
-	CSC_RGB_0_255_TO_ITU601_16_235 = 0,	//RGB 0-255 input to YCbCr 16-235 output according BT601
-	CSC_RGB_0_255_TO_ITU709_16_235,		//RGB 0-255 input to YCbCr 16-235 output accroding BT709
-	CSC_ITU601_16_235_TO_RGB_16_235,	//YCbCr 16-235 input to RGB 16-235 output according BT601
-	CSC_ITU709_16_235_TO_RGB_16_235,	//YCbCr 16-235 input to RGB 16-235 output according BT709
-	CSC_ITU601_16_235_TO_RGB_0_255,		//YCbCr 16-235 input to RGB 0-255 output according BT601
-	CSC_ITU709_16_235_TO_RGB_0_255		//YCbCr 16-235 input to RGB 0-255 output according BT709
-};
-#endif
-extern int rk2928_hdmi_initial(void);
-extern int rk2928_hdmi_detect_hotplug(void);
-extern int rk2928_hdmi_read_edid(int block, unsigned char *buff);
-extern int rk2928_hdmi_removed(void);
-extern int rk2928_hdmi_config_video(struct hdmi_video_para *vpara);
-extern int rk2928_hdmi_config_audio(struct hdmi_audio *audio);
-extern void rk2928_hdmi_control_output(int enable);
-
-#endif
diff --git a/drivers/video/rockchip/hdmi/rk_hdmi_core.c b/drivers/video/rockchip/hdmi/rk_hdmi_core.c
deleted file mode 100755
index 1b17185b6da9..000000000000
--- a/drivers/video/rockchip/hdmi/rk_hdmi_core.c
+++ /dev/null
@@ -1,254 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/module.h>
-#include <linux/err.h>
-#include <linux/slab.h>
-#include <linux/hdmi.h>
-#include <linux/input.h>
-
-
-struct class *hdmi_class;
-struct hdmi_id_ref_info {
-	struct hdmi *hdmi;
-	int id;
-	int ref;
-}ref_info[HDMI_MAX_ID];
-#ifdef CONFIG_SYSFS
-
-extern int hdmi_create_attrs(struct hdmi *hdmi);
-extern void hdmi_remove_attrs(struct hdmi *hdmi);
-
-#else
-
-static inline int hdmi_create_attrs(struct hdmi *hdmi)
-{ return 0; }
-static inline void hdmi_remove_attrs(struct hdmi *hdmi) {}
-
-#endif /* CONFIG_SYSFS */
-static void __hdmi_changed(struct hdmi *hdmi)
-{
-	int precent;
-	
-	mutex_lock(&hdmi->lock);
-	precent = hdmi->ops->hdmi_precent(hdmi);
-	if(precent && (hdmi->mode == DISP_ON_LCD) && hdmi->display_on){
-		if(hdmi->ops->insert(hdmi) == 0){
-			hdmi->mode = hdmi->display_on;
-			kobject_uevent(&hdmi->dev->kobj, KOBJ_CHANGE);
-		}
-		else
-			hdmi_dbg(hdmi->dev, "insert error\n");
-        hdmi_set_backlight(hdmi->display_on==DISP_ON_HDMI?HDMI_DISABLE: HDMI_ENABLE);
-
-	}
-	else if(precent &&(hdmi->mode != hdmi->display_on)&& hdmi->display_on){
-	    hdmi->mode = hdmi->display_on;
-        hdmi_set_backlight(hdmi->display_on==DISP_ON_HDMI?HDMI_DISABLE: HDMI_ENABLE); 
-	}
-	else if((!precent || !hdmi->display_on) && hdmi->mode != DISP_ON_LCD){
-		if(hdmi->ops->remove(hdmi) == 0){
-			hdmi->mode = DISP_ON_LCD;
-			hdmi_set_backlight(HDMI_ENABLE);
-			kobject_uevent(&hdmi->dev->kobj, KOBJ_CHANGE);
-		}
-		else
-			hdmi_dbg(hdmi->dev, "remove error\n");
-	}
-	mutex_unlock(&hdmi->lock);
-	return;
-}
-
-void hdmi_changed(struct hdmi *hdmi, int msec)
-{	
-	schedule_delayed_work(&hdmi->work, msecs_to_jiffies(msec));
-	return;
-}
-void hdmi_suspend(struct hdmi *hdmi)
-{
-	del_timer(&hdmi->timer);
-	flush_delayed_work(&hdmi->work);
-	if(hdmi->mode != DISP_ON_LCD){
-		hdmi->ops->remove(hdmi);
-		hdmi->mode = DISP_ON_LCD;
-	}
-	return;
-}
-void hdmi_resume(struct hdmi *hdmi)
-{
-	mod_timer(&hdmi->timer, jiffies + msecs_to_jiffies(10));
-	return;
-}
-
-static void hdmi_changed_work(struct work_struct *work)
-{
-	struct hdmi *hdmi = container_of(work, struct hdmi,
-						work.work);
-	
-	__hdmi_changed(hdmi);
-	return;
-}
-
-void *hdmi_priv(struct hdmi *hdmi)
-{
-	return (void *)hdmi->priv;
-}
-static void hdmi_detect_timer(unsigned long data)
-{
-	struct hdmi *hdmi = (struct hdmi*)data;
-	
-	int precent =  hdmi->ops->hdmi_precent(hdmi);
-
-	if((precent && hdmi->mode == DISP_ON_LCD) ||
-			(!precent && hdmi->mode != DISP_ON_LCD))
-		hdmi_changed(hdmi, 100);
-	mod_timer(&hdmi->timer, jiffies + msecs_to_jiffies(200));
-}
-struct hdmi *hdmi_register(int extra, struct device *parent)
-{
-	int rc = 0, i;
-	char name[8];
-	struct hdmi *hdmi = kzalloc(sizeof(struct hdmi)+ extra, GFP_KERNEL);
-
-	if(!hdmi)
-		return NULL;
-	for(i = 0; i < HDMI_MAX_ID; i++) 
-	{
-		if(ref_info[i].ref == 0)
-		{
-			ref_info[i].ref = 1;
-			hdmi->id = i;
-			break;
-		}
-	}
-	if(i == HDMI_MAX_ID)
-	{
-		kfree(hdmi);
-		return NULL;
-	}
-	sprintf(name, "hdmi-%d", hdmi->id);
-	
-	hdmi->dev = device_create(hdmi_class, parent, 0,
-				 "%s", name);
-	if (IS_ERR(hdmi->dev)) {
-		rc = PTR_ERR(hdmi->dev);
-		goto dev_create_failed;
-	}
-
-	dev_set_drvdata(hdmi->dev, hdmi);
-	ref_info[i].hdmi = hdmi;
-
-	INIT_DELAYED_WORK(&hdmi->work, hdmi_changed_work);
-
-	rc = hdmi_create_attrs(hdmi);
-	if (rc)
-		goto create_attrs_failed;
-
-	goto success;
-
-create_attrs_failed:
-	device_unregister(hdmi->dev);
-dev_create_failed:
-	hdmi_remove_attrs(hdmi);
-	kfree(hdmi);
-	return NULL;
-success:
-	mutex_init(&hdmi->lock);
-	setup_timer(&hdmi->timer, hdmi_detect_timer,(unsigned long)hdmi);
-	mod_timer(&hdmi->timer, jiffies + msecs_to_jiffies(200));
-	return hdmi;
-}
-void hdmi_unregister(struct hdmi *hdmi)
-{
-	int id;
-
-	if(!hdmi)
-		return;
-	id = hdmi->id;
-	del_timer(&hdmi->timer);
-	flush_scheduled_work();
-	hdmi_remove_attrs(hdmi);
-	device_unregister(hdmi->dev);
-
-	kfree(hdmi);
-	hdmi = NULL;
-	ref_info[id].ref = 0;
-	ref_info[id].hdmi = NULL;
-}
-struct hdmi *get_hdmi_struct(int nr)
-{
-	if(ref_info[nr].ref == 0)
-		return NULL;
-	else
-		return ref_info[nr].hdmi;
-}
-int hdmi_is_insert(void)
-{
-	struct hdmi *hdmi = get_hdmi_struct(0);
-
-	if(hdmi && hdmi->ops && hdmi->ops->hdmi_precent)
-		return hdmi->ops->hdmi_precent(hdmi);
-	else
-		return 0;
-}
-int hdmi_get_scale(void)
-{
-	struct hdmi* hdmi = get_hdmi_struct(0);
-	if(!hdmi)
-		return 100;
-	else if(hdmi->mode != DISP_ON_LCD)
-		return hdmi->scale;
-	else
-	    return 100;
-}
-
-int hdmi_set_scale(int event, char *data, int len)
-{
-	int result;
-	struct hdmi* hdmi = get_hdmi_struct(0);
-
-	if(!hdmi)
-		return -1;
-	if(len != 4)
-		return -1;
-	if(fb_get_video_mode() || hdmi->mode == DISP_ON_LCD)
-		return -1;
-
-	result = data[0] | data[1]<<1 | data[2]<<2;
-	if(event != MOUSE_NONE && (result & event) != event)
-		return -1;
-
-	hdmi->scale += data[3];
-	
-	hdmi->scale = (hdmi->scale>100)?100:hdmi->scale;
-	hdmi->scale = (hdmi->scale<MIN_SCALE)?MIN_SCALE:hdmi->scale;
-	return 0;	
-}
-
-static int __init hdmi_class_init(void)
-{
-	int i;
-	
-	hdmi_class = class_create(THIS_MODULE, "hdmi");
-
-	if (IS_ERR(hdmi_class))
-		return PTR_ERR(hdmi_class);
-	for(i = 0; i < HDMI_MAX_ID; i++) {
-		ref_info[i].id = i;
-		ref_info[i].ref = 0;
-		ref_info[i].hdmi = NULL;
-	}
-	return 0;
-}
-
-static void __exit hdmi_class_exit(void)
-{
-	class_destroy(hdmi_class);
-}
-EXPORT_SYMBOL(hdmi_changed);
-EXPORT_SYMBOL(hdmi_register);
-EXPORT_SYMBOL(hdmi_unregister);
-EXPORT_SYMBOL(get_hdmi_struct);
-
-subsys_initcall(hdmi_class_init);
-module_exit(hdmi_class_exit);
-
-- 
2.35.3

