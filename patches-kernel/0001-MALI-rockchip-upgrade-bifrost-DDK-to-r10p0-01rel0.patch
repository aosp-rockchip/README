From 4a1507af5a64e14f527be298fc701abfc31634f3 Mon Sep 17 00:00:00 2001
From: Zhen Chen <chenzhen@rock-chips.com>
Date: Sun, 25 Feb 2018 19:04:54 +0800
Subject: [PATCH] MALI: rockchip: upgrade bifrost DDK to r10p0-01rel0

in addition,
resolve all the conflicts;
rename all the configs and macros that have a same name in midgard/;
fix a compiling error.

Change-Id: I5abc8c925049e087c59b66da57c82aac3092be71
Signed-off-by: Zhen Chen <chenzhen@rock-chips.com>
---
 drivers/gpu/arm/bifrost/Kbuild                |   24 +-
 drivers/gpu/arm/bifrost/Kconfig               |   40 +-
 drivers/gpu/arm/bifrost/Makefile              |   18 +-
 drivers/gpu/arm/bifrost/Makefile.kbase        |   14 +-
 drivers/gpu/arm/bifrost/Mconfig               |  207 +++
 drivers/gpu/arm/bifrost/backend/gpu/Kbuild    |   14 +-
 .../backend/gpu/mali_kbase_backend_config.h   |   15 +-
 .../gpu/mali_kbase_cache_policy_backend.c     |   15 +-
 .../gpu/mali_kbase_cache_policy_backend.h     |   15 +-
 .../gpu/mali_kbase_debug_job_fault_backend.c  |   15 +-
 .../bifrost/backend/gpu/mali_kbase_devfreq.c  |   24 +-
 .../bifrost/backend/gpu/mali_kbase_devfreq.h  |   15 +-
 .../backend/gpu/mali_kbase_device_hw.c        |   15 +-
 .../backend/gpu/mali_kbase_device_internal.h  |   15 +-
 .../arm/bifrost/backend/gpu/mali_kbase_gpu.c  |   22 +-
 .../backend/gpu/mali_kbase_gpuprops_backend.c |   15 +-
 .../backend/gpu/mali_kbase_instr_backend.c    |   15 +-
 .../backend/gpu/mali_kbase_instr_defs.h       |   15 +-
 .../backend/gpu/mali_kbase_instr_internal.h   |   15 +-
 .../backend/gpu/mali_kbase_irq_internal.h     |   15 +-
 .../backend/gpu/mali_kbase_irq_linux.c        |   15 +-
 .../bifrost/backend/gpu/mali_kbase_jm_as.c    |   15 +-
 .../bifrost/backend/gpu/mali_kbase_jm_defs.h  |   15 +-
 .../bifrost/backend/gpu/mali_kbase_jm_hw.c    |  124 +-
 .../backend/gpu/mali_kbase_jm_internal.h      |   15 +-
 .../bifrost/backend/gpu/mali_kbase_jm_rb.c    |   15 +-
 .../bifrost/backend/gpu/mali_kbase_jm_rb.h    |   15 +-
 .../backend/gpu/mali_kbase_js_affinity.c      |   15 +-
 .../backend/gpu/mali_kbase_js_affinity.h      |   15 +-
 .../backend/gpu/mali_kbase_js_backend.c       |   35 +-
 .../backend/gpu/mali_kbase_js_internal.h      |   15 +-
 .../backend/gpu/mali_kbase_mmu_hw_direct.c    |   15 +-
 .../backend/gpu/mali_kbase_mmu_hw_direct.h    |   15 +-
 .../backend/gpu/mali_kbase_pm_always_on.c     |   15 +-
 .../backend/gpu/mali_kbase_pm_always_on.h     |   15 +-
 .../backend/gpu/mali_kbase_pm_backend.c       |   99 +-
 .../bifrost/backend/gpu/mali_kbase_pm_ca.c    |   15 +-
 .../bifrost/backend/gpu/mali_kbase_pm_ca.h    |   15 +-
 .../backend/gpu/mali_kbase_pm_ca_devfreq.c    |   15 +-
 .../backend/gpu/mali_kbase_pm_ca_devfreq.h    |   15 +-
 .../backend/gpu/mali_kbase_pm_ca_fixed.c      |   15 +-
 .../backend/gpu/mali_kbase_pm_ca_fixed.h      |   15 +-
 .../backend/gpu/mali_kbase_pm_coarse_demand.c |   15 +-
 .../backend/gpu/mali_kbase_pm_coarse_demand.h |   15 +-
 .../bifrost/backend/gpu/mali_kbase_pm_defs.h  |   15 +-
 .../backend/gpu/mali_kbase_pm_demand.c        |   15 +-
 .../backend/gpu/mali_kbase_pm_demand.h        |   15 +-
 .../backend/gpu/mali_kbase_pm_driver.c        |   43 +-
 .../backend/gpu/mali_kbase_pm_internal.h      |   36 +-
 .../backend/gpu/mali_kbase_pm_metrics.c       |   15 +-
 .../backend/gpu/mali_kbase_pm_policy.c        |   15 +-
 .../backend/gpu/mali_kbase_pm_policy.h        |   15 +-
 .../arm/bifrost/backend/gpu/mali_kbase_time.c |   15 +-
 .../arm/bifrost/backend/gpu/mali_kbase_time.h |   15 +-
 drivers/gpu/arm/bifrost/build.bp              |   95 ++
 drivers/gpu/arm/bifrost/docs/Doxyfile         |   18 +-
 .../bifrost/docs/policy_operation_diagram.dot |   15 +-
 .../gpu/arm/bifrost/docs/policy_overview.dot  |   15 +-
 drivers/gpu/arm/bifrost/ipa/Kbuild            |   14 +-
 drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.c  |   61 +-
 drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.h  |   15 +-
 .../arm/bifrost/ipa/mali_kbase_ipa_debugfs.c  |   61 +-
 .../arm/bifrost/ipa/mali_kbase_ipa_debugfs.h  |   29 +-
 .../arm/bifrost/ipa/mali_kbase_ipa_simple.c   |   64 +-
 .../arm/bifrost/ipa/mali_kbase_ipa_simple.h   |   15 +-
 .../ipa/mali_kbase_ipa_vinstr_common.c        |   35 +-
 .../ipa/mali_kbase_ipa_vinstr_common.h        |   33 +-
 .../bifrost/ipa/mali_kbase_ipa_vinstr_g71.c   |  186 ++-
 .../arm/bifrost/mali_base_hwconfig_features.h |  195 ++-
 .../arm/bifrost/mali_base_hwconfig_issues.h   |   98 +-
 drivers/gpu/arm/bifrost/mali_base_kernel.h    |  202 +--
 drivers/gpu/arm/bifrost/mali_base_mem_priv.h  |   15 +-
 .../bifrost/mali_base_vendor_specific_func.h  |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase.h          |   81 +-
 .../arm/bifrost/mali_kbase_10969_workaround.c |   15 +-
 .../arm/bifrost/mali_kbase_10969_workaround.h |   15 +-
 .../arm/bifrost/mali_kbase_as_fault_debugfs.c |   15 +-
 .../arm/bifrost/mali_kbase_as_fault_debugfs.h |   15 +-
 .../gpu/arm/bifrost/mali_kbase_cache_policy.c |   15 +-
 .../gpu/arm/bifrost/mali_kbase_cache_policy.h |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_config.c   |   25 +-
 drivers/gpu/arm/bifrost/mali_kbase_config.h   |   68 +-
 .../arm/bifrost/mali_kbase_config_defaults.h  |   68 +-
 drivers/gpu/arm/bifrost/mali_kbase_context.c  |   27 +-
 drivers/gpu/arm/bifrost/mali_kbase_context.h  |   15 +-
 .../gpu/arm/bifrost/mali_kbase_core_linux.c   | 1268 +++--------------
 .../gpu/arm/bifrost/mali_kbase_ctx_sched.c    |   15 +-
 .../gpu/arm/bifrost/mali_kbase_ctx_sched.h    |   17 +-
 drivers/gpu/arm/bifrost/mali_kbase_debug.c    |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_debug.h    |   15 +-
 .../arm/bifrost/mali_kbase_debug_job_fault.c  |   15 +-
 .../arm/bifrost/mali_kbase_debug_job_fault.h  |   15 +-
 .../arm/bifrost/mali_kbase_debug_mem_view.c   |   17 +-
 .../arm/bifrost/mali_kbase_debug_mem_view.h   |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_defs.h     |   96 +-
 drivers/gpu/arm/bifrost/mali_kbase_device.c   |   16 +-
 .../arm/bifrost/mali_kbase_disjoint_events.c  |   15 +-
 .../gpu/arm/bifrost/mali_kbase_dma_fence.c    |   15 +-
 .../gpu/arm/bifrost/mali_kbase_dma_fence.h    |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_event.c    |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_fence.c    |   24 +-
 drivers/gpu/arm/bifrost/mali_kbase_fence.h    |   15 +-
 .../gpu/arm/bifrost/mali_kbase_fence_defs.h   |   22 +-
 drivers/gpu/arm/bifrost/mali_kbase_gator.h    |   15 +-
 .../gpu/arm/bifrost/mali_kbase_gator_api.c    |   19 +-
 .../gpu/arm/bifrost/mali_kbase_gator_api.h    |   15 +-
 .../bifrost/mali_kbase_gator_hwcnt_names.h    |   19 +-
 .../mali_kbase_gator_hwcnt_names_thex.h       |   15 +-
 .../mali_kbase_gator_hwcnt_names_tkax.h       |  296 ++++
 .../mali_kbase_gator_hwcnt_names_tmix.h       |   15 +-
 .../mali_kbase_gator_hwcnt_names_tnox.h       |  296 ++++
 .../mali_kbase_gator_hwcnt_names_tsix.h       |   15 +-
 .../mali_kbase_gator_hwcnt_names_ttrx.h       |  296 ++++
 drivers/gpu/arm/bifrost/mali_kbase_gpu_id.h   |   20 +-
 .../bifrost/mali_kbase_gpu_memory_debugfs.c   |   15 +-
 .../bifrost/mali_kbase_gpu_memory_debugfs.h   |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_gpuprops.c |   81 +-
 drivers/gpu/arm/bifrost/mali_kbase_gpuprops.h |   27 +-
 .../arm/bifrost/mali_kbase_gpuprops_types.h   |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_gwt.c      |  286 ++++
 drivers/gpu/arm/bifrost/mali_kbase_gwt.h      |   55 +
 drivers/gpu/arm/bifrost/mali_kbase_hw.c       |   61 +-
 drivers/gpu/arm/bifrost/mali_kbase_hw.h       |   15 +-
 .../arm/bifrost/mali_kbase_hwaccess_backend.h |   15 +-
 .../arm/bifrost/mali_kbase_hwaccess_defs.h    |   15 +-
 .../bifrost/mali_kbase_hwaccess_gpuprops.h    |   15 +-
 .../arm/bifrost/mali_kbase_hwaccess_instr.h   |   15 +-
 .../gpu/arm/bifrost/mali_kbase_hwaccess_jm.h  |   15 +-
 .../gpu/arm/bifrost/mali_kbase_hwaccess_pm.h  |   15 +-
 .../arm/bifrost/mali_kbase_hwaccess_time.h    |   15 +-
 .../gpu/arm/bifrost/mali_kbase_hwcnt_reader.h |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_ioctl.h    |  143 +-
 drivers/gpu/arm/bifrost/mali_kbase_jd.c       |  274 +---
 .../gpu/arm/bifrost/mali_kbase_jd_debugfs.c   |   16 +-
 .../gpu/arm/bifrost/mali_kbase_jd_debugfs.h   |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_jm.c       |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_jm.h       |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_js.c       |   54 +-
 drivers/gpu/arm/bifrost/mali_kbase_js.h       |   56 +-
 .../gpu/arm/bifrost/mali_kbase_js_ctx_attr.c  |   15 +-
 .../gpu/arm/bifrost/mali_kbase_js_ctx_attr.h  |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_js_defs.h  |   17 +-
 drivers/gpu/arm/bifrost/mali_kbase_linux.h    |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_mem.c      |  357 +++--
 drivers/gpu/arm/bifrost/mali_kbase_mem.h      |  127 +-
 .../gpu/arm/bifrost/mali_kbase_mem_linux.c    |  232 +--
 .../gpu/arm/bifrost/mali_kbase_mem_linux.h    |   15 +-
 .../gpu/arm/bifrost/mali_kbase_mem_lowlevel.h |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_mem_pool.c |   29 +-
 .../arm/bifrost/mali_kbase_mem_pool_debugfs.c |   15 +-
 .../arm/bifrost/mali_kbase_mem_pool_debugfs.h |   15 +-
 .../bifrost/mali_kbase_mem_profile_debugfs.c  |   15 +-
 .../bifrost/mali_kbase_mem_profile_debugfs.h  |   15 +-
 .../mali_kbase_mem_profile_debugfs_buf_size.h |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_mmu.c      |  295 +++-
 drivers/gpu/arm/bifrost/mali_kbase_mmu_hw.h   |   15 +-
 .../arm/bifrost/mali_kbase_mmu_mode_aarch64.c |   15 +-
 .../arm/bifrost/mali_kbase_mmu_mode_lpae.c    |   15 +-
 .../arm/bifrost/mali_kbase_platform_fake.c    |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_pm.c       |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_pm.h       |   15 +-
 .../bifrost/mali_kbase_profiling_gator_api.h  |   15 +-
 .../bifrost/mali_kbase_regs_history_debugfs.c |   15 +-
 .../bifrost/mali_kbase_regs_history_debugfs.h |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_replay.c   |   31 +-
 drivers/gpu/arm/bifrost/mali_kbase_smc.c      |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_smc.h      |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_softjobs.c |   60 +-
 drivers/gpu/arm/bifrost/mali_kbase_strings.c  |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_strings.h  |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_sync.h     |   15 +-
 .../gpu/arm/bifrost/mali_kbase_sync_android.c |   15 +-
 .../gpu/arm/bifrost/mali_kbase_sync_common.c  |   15 +-
 .../gpu/arm/bifrost/mali_kbase_sync_file.c    |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_tlstream.c |   25 +-
 drivers/gpu/arm/bifrost/mali_kbase_tlstream.h |   23 +-
 .../gpu/arm/bifrost/mali_kbase_trace_defs.h   |   15 +-
 .../arm/bifrost/mali_kbase_trace_timeline.c   |   15 +-
 .../arm/bifrost/mali_kbase_trace_timeline.h   |   15 +-
 .../bifrost/mali_kbase_trace_timeline_defs.h  |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_uku.h      |  532 -------
 drivers/gpu/arm/bifrost/mali_kbase_utility.c  |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_utility.h  |   15 +-
 drivers/gpu/arm/bifrost/mali_kbase_vinstr.c   |   18 +-
 drivers/gpu/arm/bifrost/mali_kbase_vinstr.h   |   41 +-
 .../gpu/arm/bifrost/mali_linux_kbase_trace.h  |   15 +-
 drivers/gpu/arm/bifrost/mali_linux_trace.h    |   15 +-
 drivers/gpu/arm/bifrost/mali_malisw.h         |   15 +-
 drivers/gpu/arm/bifrost/mali_midg_coherency.h |   15 +-
 drivers/gpu/arm/bifrost/mali_midg_regmap.h    |   23 +-
 drivers/gpu/arm/bifrost/mali_timeline.h       |   15 +-
 drivers/gpu/arm/bifrost/mali_uk.h             |   15 +-
 drivers/gpu/arm/bifrost/platform/Kconfig      |   14 +-
 .../arm/bifrost/platform/devicetree/Kbuild    |   14 +-
 .../devicetree/mali_kbase_config_devicetree.c |   23 +-
 .../devicetree/mali_kbase_config_platform.h   |   50 +-
 .../devicetree/mali_kbase_runtime_pm.c        |   21 +-
 .../platform/mali_kbase_platform_common.h     |   26 -
 .../gpu/arm/bifrost/platform/vexpress/Kbuild  |   15 +-
 .../vexpress/mali_kbase_config_platform.h     |   52 +-
 .../vexpress/mali_kbase_config_vexpress.c     |   38 +-
 .../vexpress/mali_kbase_cpu_vexpress.c        |  279 ----
 .../vexpress/mali_kbase_cpu_vexpress.h        |   38 -
 .../bifrost/platform/vexpress_1xv7_a57/Kbuild |   14 +-
 .../mali_kbase_config_platform.h              |   50 +-
 .../mali_kbase_config_vexpress.c              |   36 +-
 .../platform/vexpress_6xvirtex7_10mhz/Kbuild  |   14 +-
 .../mali_kbase_config_platform.h              |   52 +-
 .../mali_kbase_config_vexpress.c              |   38 +-
 .../mali_kbase_cpu_vexpress.c                 |   71 -
 .../mali_kbase_cpu_vexpress.h                 |   28 -
 .../arm/bifrost/platform_dummy/mali_ukk_os.h  |   15 +-
 .../gpu/arm/bifrost/protected_mode_switcher.h |   15 +-
 drivers/gpu/arm/bifrost/sconscript            |   23 +-
 drivers/gpu/arm/bifrost/tests/Kbuild          |   14 +-
 drivers/gpu/arm/bifrost/tests/Kconfig         |   14 +-
 .../bifrost/tests/include/kutf/kutf_helpers.h |  217 +--
 .../tests/include/kutf/kutf_helpers_user.h    |   64 +-
 .../arm/bifrost/tests/include/kutf/kutf_mem.h |   15 +-
 .../tests/include/kutf/kutf_resultset.h       |   92 +-
 .../bifrost/tests/include/kutf/kutf_suite.h   |  113 +-
 .../bifrost/tests/include/kutf/kutf_utils.h   |   15 +-
 drivers/gpu/arm/bifrost/tests/kutf/Kbuild     |   14 +-
 drivers/gpu/arm/bifrost/tests/kutf/Kconfig    |   14 +-
 drivers/gpu/arm/bifrost/tests/kutf/Makefile   |   14 +-
 .../gpu/arm/bifrost/tests/kutf/kutf_helpers.c |  777 +---------
 .../bifrost/tests/kutf/kutf_helpers_user.c    |  132 +-
 drivers/gpu/arm/bifrost/tests/kutf/kutf_mem.c |   16 +-
 .../arm/bifrost/tests/kutf/kutf_resultset.c   |  113 +-
 .../gpu/arm/bifrost/tests/kutf/kutf_suite.c   |  631 +++-----
 .../gpu/arm/bifrost/tests/kutf/kutf_utils.c   |   15 +-
 drivers/gpu/arm/bifrost/tests/kutf/sconscript |   14 +-
 .../bifrost/tests/mali_kutf_irq_test/Kbuild   |   14 +-
 .../bifrost/tests/mali_kutf_irq_test/Kconfig  |   14 +-
 .../bifrost/tests/mali_kutf_irq_test/Makefile |   14 +-
 .../mali_kutf_irq_test_main.c                 |   15 +-
 .../tests/mali_kutf_irq_test/sconscript       |   14 +-
 drivers/gpu/arm/bifrost/tests/sconscript      |   14 +-
 .../arm/bifrost/thirdparty/mali_kbase_mmap.c  |  321 +++++
 239 files changed, 6680 insertions(+), 6125 deletions(-)
 create mode 100644 drivers/gpu/arm/bifrost/Mconfig
 create mode 100644 drivers/gpu/arm/bifrost/build.bp
 create mode 100644 drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tkax.h
 create mode 100644 drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tnox.h
 create mode 100644 drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_ttrx.h
 create mode 100644 drivers/gpu/arm/bifrost/mali_kbase_gwt.c
 create mode 100644 drivers/gpu/arm/bifrost/mali_kbase_gwt.h
 delete mode 100644 drivers/gpu/arm/bifrost/mali_kbase_uku.h
 delete mode 100644 drivers/gpu/arm/bifrost/platform/mali_kbase_platform_common.h
 delete mode 100644 drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_cpu_vexpress.c
 delete mode 100644 drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_cpu_vexpress.h
 delete mode 100644 drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c
 delete mode 100644 drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.h
 create mode 100644 drivers/gpu/arm/bifrost/thirdparty/mali_kbase_mmap.c

diff --git a/drivers/gpu/arm/bifrost/Kbuild b/drivers/gpu/arm/bifrost/Kbuild
index 531b92126b98..4b001c67ab69 100644
--- a/drivers/gpu/arm/bifrost/Kbuild
+++ b/drivers/gpu/arm/bifrost/Kbuild
@@ -6,14 +6,21 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
 
 # Driver version string which is returned to userspace via an ioctl
-MALI_RELEASE_NAME ?= "r8p0-01rel0"
+MALI_RELEASE_NAME ?= "r10p0-01rel0"
 
 # Paths required for build
 KBASE_PATH = $(src)
@@ -31,7 +38,6 @@ MALI_KERNEL_TEST_API ?= 0
 MALI_ERROR_INJECT_ON ?= 0
 MALI_MOCK_TEST ?= 0
 MALI_COVERAGE ?= 0
-MALI_INSTRUMENTATION_LEVEL ?= 0
 CONFIG_MALI_PLATFORM_NAME ?= "devicetree"
 # This workaround is for what seems to be a compiler bug we observed in
 # GCC 4.7 on AOSP 4.3.  The bug caused an intermittent failure compiling
@@ -53,7 +59,6 @@ DEFINES = \
 	-DMALI_ERROR_INJECT_ON=$(MALI_ERROR_INJECT_ON) \
 	-DMALI_MOCK_TEST=$(MALI_MOCK_TEST) \
 	-DMALI_COVERAGE=$(MALI_COVERAGE) \
-	-DMALI_INSTRUMENTATION_LEVEL=$(MALI_INSTRUMENTATION_LEVEL) \
 	-DMALI_RELEASE_NAME=\"$(MALI_RELEASE_NAME)\" \
 	-DMALI_GCC_WORKAROUND_MIDCOM_4598=$(MALI_GCC_WORKAROUND_MIDCOM_4598)
 
@@ -111,10 +116,13 @@ SRC := \
 	mali_kbase_tlstream.c \
 	mali_kbase_strings.c \
 	mali_kbase_as_fault_debugfs.c \
-	mali_kbase_regs_history_debugfs.c
-
+	mali_kbase_regs_history_debugfs.c \
+	thirdparty/mali_kbase_mmap.c
 
 
+ifeq ($(CONFIG_MALI_JOB_DUMP),y)
+	SRC += mali_kbase_gwt.c
+endif
 
 ifeq ($(MALI_UNIT_TEST),1)
 	SRC += mali_kbase_tlstream_test.c
diff --git a/drivers/gpu/arm/bifrost/Kconfig b/drivers/gpu/arm/bifrost/Kconfig
index 7c70914e3900..075998977066 100644
--- a/drivers/gpu/arm/bifrost/Kconfig
+++ b/drivers/gpu/arm/bifrost/Kconfig
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 
 menuconfig MALI_BIFROST
@@ -61,13 +67,13 @@ config MALI_BIFROST_DEVFREQ
 
 config MALI_BIFROST_DMA_FENCE
 	bool "DMA_BUF fence support for Mali"
-	depends on MALI_BIFROST && !KDS
+	depends on MALI_BIFROST
 	default n
 	help
 	  Support DMA_BUF fences for Mali.
 
-	  This option should only be enabled if KDS is not present and
-	  the Linux Kernel has built in support for DMA_BUF fences.
+	  This option should only be enabled if the Linux Kernel has built in
+	  support for DMA_BUF fences.
 
 config MALI_PLATFORM_NAME
 	depends on MALI_BIFROST
@@ -174,6 +180,16 @@ config MALI_BIFROST_SYSTEM_TRACE
 	  minimal overhead when not in use. Enable only if you know what
 	  you are doing.
 
+config MALI_JOB_DUMPING
+	bool "Enable system level support needed for job dumping"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default n
+	help
+	  Choose this option to enable system level support needed for
+	  job dumping.	This is typically used for instrumentation but has
+	  minimal overhead when not in use. Enable only if you know what
+	  you are doing.
+
 config MALI_2MB_ALLOC
 	bool "Attempt to allocate 2MB pages"
 	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
@@ -187,11 +203,15 @@ config MALI_2MB_ALLOC
 
 config MALI_PWRSOFT_765
 	bool "PWRSOFT-765 ticket"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
 	default n
 	help
-	  PWRSOFT-765 fixes devfreq cooling devices issues. However, they are
-	  not merged in mainline kernel yet. So this define helps to guard those
-	  parts of the code.
+	  PWRSOFT-765 fixes devfreq cooling devices issues. The fix was merged
+	  in kernel v4.10, however if backported into the kernel then this
+	  option must be manually selected.
+
+	  If using kernel >= v4.10 then say N, otherwise if devfreq cooling
+	  changes have been backported say Y to avoid compilation errors.
 
 source "drivers/gpu/arm/bifrost/platform/Kconfig"
 # source "drivers/gpu/arm/bifrost/tests/Kconfig"
diff --git a/drivers/gpu/arm/bifrost/Makefile b/drivers/gpu/arm/bifrost/Makefile
index 26522d566dd0..cfe6fc34ad29 100644
--- a/drivers/gpu/arm/bifrost/Makefile
+++ b/drivers/gpu/arm/bifrost/Makefile
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 
 KDIR ?= /lib/modules/$(shell uname -r)/build
@@ -19,7 +25,6 @@ KDIR ?= /lib/modules/$(shell uname -r)/build
 BUSLOG_PATH_RELATIVE = $(CURDIR)/../../../..
 UMP_PATH_RELATIVE = $(CURDIR)/../../../base/ump
 KBASE_PATH_RELATIVE = $(CURDIR)
-KDS_PATH_RELATIVE = $(CURDIR)/../../../..
 EXTRA_SYMBOLS = $(UMP_PATH_RELATIVE)/src/Module.symvers
 
 ifeq ($(MALI_UNIT_TEST), 1)
@@ -31,9 +36,6 @@ ifeq ($(CONFIG_MALI_FPGA_BUS_LOGGER),y)
 EXTRA_SYMBOLS += $(BUSLOG_PATH_RELATIVE)/drivers/base/bus_logger/Module.symvers
 endif
 
-# GPL driver supports KDS
-EXTRA_SYMBOLS += $(KDS_PATH_RELATIVE)/drivers/base/kds/Module.symvers
-
 # we get the symbols from modules using KBUILD_EXTRA_SYMBOLS to prevent warnings about unknown functions
 all:
 	$(MAKE) -C $(KDIR) M=$(CURDIR) EXTRA_CFLAGS="-I$(CURDIR)/../../../../include -I$(CURDIR)/../../../../tests/include $(SCONS_CFLAGS)" $(SCONS_CONFIGS) KBUILD_EXTRA_SYMBOLS="$(EXTRA_SYMBOLS)" modules
diff --git a/drivers/gpu/arm/bifrost/Makefile.kbase b/drivers/gpu/arm/bifrost/Makefile.kbase
index 2bef9c25eaeb..d7898cb3d1a5 100644
--- a/drivers/gpu/arm/bifrost/Makefile.kbase
+++ b/drivers/gpu/arm/bifrost/Makefile.kbase
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 EXTRA_CFLAGS += -I$(ROOT) -I$(KBASE_PATH) -I$(OSK_PATH)/src/linux/include -I$(KBASE_PATH)/platform_$(PLATFORM)
 
diff --git a/drivers/gpu/arm/bifrost/Mconfig b/drivers/gpu/arm/bifrost/Mconfig
new file mode 100644
index 000000000000..47a744ba8fcf
--- /dev/null
+++ b/drivers/gpu/arm/bifrost/Mconfig
@@ -0,0 +1,207 @@
+#
+# (C) COPYRIGHT 2012-2017 ARM Limited. All rights reserved.
+#
+# This program is free software and is provided to you under the terms of the
+# GNU General Public License version 2 as published by the Free Software
+# Foundation, and any use by you of this program is subject to the terms
+# of such GNU licence.
+#
+# A copy of the licence is included with the program, and can also be obtained
+# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+# Boston, MA  02110-1301, USA.
+#
+#
+
+
+menuconfig MALI_BIFROST
+	bool "Mali Midgard series support"
+	default y
+	help
+	  Enable this option to build support for a ARM Mali Midgard GPU.
+
+	  To compile this driver as a module, choose M here:
+	  this will generate a single module, called mali_kbase.
+
+config MALI_BIFROST_GATOR_SUPPORT
+	bool "Streamline support via Gator"
+	depends on MALI_BIFROST
+	default y if INSTRUMENTATION_STREAMLINE_OLD
+	default n
+	help
+	  Adds diagnostic support for use with the ARM Streamline Performance Analyzer.
+	  You will need the Gator device driver already loaded before loading this driver when enabling
+	  Streamline debug support.
+	  This is a legacy interface required by older versions of Streamline.
+
+config MALI_BIFROST_DVFS
+	bool "Enable legacy DVFS"
+	depends on MALI_BIFROST && !MALI_BIFROST_DEVFREQ
+	default n
+	help
+	  Choose this option to enable legacy DVFS in the Mali Midgard DDK.
+
+config MALI_BIFROST_ENABLE_TRACE
+	bool "Enable kbase tracing"
+	depends on MALI_BIFROST
+	default n
+	help
+	  Enables tracing in kbase.  Trace log available through
+	  the "mali_trace" debugfs file, when the CONFIG_DEBUG_FS is enabled
+
+config MALI_BIFROST_DEVFREQ
+	bool "devfreq support for Mali"
+	depends on MALI_BIFROST
+	default y if PLATFORM_JUNO
+	default y if PLATFORM_CUSTOM
+	help
+	  Support devfreq for Mali.
+
+	  Using the devfreq framework and, by default, the simpleondemand
+	  governor, the frequency of Mali will be dynamically selected from the
+	  available OPPs.
+
+config MALI_BIFROST_DMA_FENCE
+	bool "DMA_BUF fence support for Mali"
+	depends on MALI_BIFROST
+	default n
+	help
+	  Support DMA_BUF fences for Mali.
+
+	  This option should only be enabled if the Linux Kernel has built in
+	  support for DMA_BUF fences.
+
+config MALI_PLATFORM_NAME
+	depends on MALI_BIFROST
+	string "Platform name"
+	default "arndale" if PLATFORM_ARNDALE
+	default "arndale_octa" if PLATFORM_ARNDALE_OCTA
+	default "rk" if PLATFORM_FIREFLY
+	default "hisilicon" if PLATFORM_HIKEY960
+	default "vexpress" if PLATFORM_VEXPRESS
+	default "devicetree"
+	help
+	  Enter the name of the desired platform configuration directory to
+	  include in the build. 'platform/$(MALI_PLATFORM_NAME)/Kbuild' must
+	  exist.
+
+config MALI_MOCK_TEST
+	bool
+	depends on MALI_BIFROST && !RELEASE
+	default y
+
+# MALI_BIFROST_EXPERT configuration options
+
+menuconfig MALI_BIFROST_EXPERT
+	depends on MALI_BIFROST
+	bool "Enable Expert Settings"
+	default y
+	help
+	  Enabling this option and modifying the default settings may produce a driver with performance or
+	  other limitations.
+
+config MALI_CORESTACK
+	bool "Support controlling power to the GPU core stack"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default n
+	help
+	  Enabling this feature on supported GPUs will let the driver powering
+	  on/off the GPU core stack independently without involving the Power
+	  Domain Controller. This should only be enabled on platforms which
+	  integration of the PDC to the Mali GPU is known to be problematic.
+	  This feature is currently only supported on t-Six and t-HEx GPUs.
+
+	  If unsure, say N.
+
+config MALI_BIFROST_PRFCNT_SET_SECONDARY
+	bool "Use secondary set of performance counters"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default n
+	help
+	  Select this option to use secondary set of performance counters. Kernel
+	  features that depend on an access to the primary set of counters may
+	  become unavailable. Enabling this option will prevent power management
+	  from working optimally and may cause instrumentation tools to return
+	  bogus results.
+
+	  If unsure, say N.
+
+config MALI_BIFROST_DEBUG
+	bool "Debug build"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default y if DEBUG
+	default n
+	help
+	  Select this option for increased checking and reporting of errors.
+
+config MALI_BIFROST_FENCE_DEBUG
+	bool "Debug sync fence usage"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default y if MALI_BIFROST_DEBUG
+	help
+	  Select this option to enable additional checking and reporting on the
+	  use of sync fences in the Mali driver.
+
+	  This will add a 3s timeout to all sync fence waits in the Mali
+	  driver, so that when work for Mali has been waiting on a sync fence
+	  for a long time a debug message will be printed, detailing what fence
+	  is causing the block, and which dependent Mali atoms are blocked as a
+	  result of this.
+
+	  The timeout can be changed at runtime through the js_soft_timeout
+	  device attribute, where the timeout is specified in milliseconds.
+
+config MALI_BIFROST_ERROR_INJECT
+	bool "Error injection"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT && NO_MALI
+	default n
+	help
+	  Enables insertion of errors to test module failure and recovery mechanisms.
+
+config MALI_ERROR_INJECT_RANDOM
+	bool "Random error injection"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT && NO_MALI && MALI_BIFROST_ERROR_INJECT
+	default n
+	help
+	  Injected errors are random, rather than user-driven.
+
+config MALI_BIFROST_TRACE_TIMELINE
+	bool "Timeline tracing"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default n
+	help
+	  Enables timeline tracing through the kernel tracepoint system.
+
+config MALI_BIFROST_SYSTEM_TRACE
+	bool "Enable system event tracing support"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default n
+	help
+	  Choose this option to enable system trace events for each
+	  kbase event.	This is typically used for debugging but has
+	  minimal overhead when not in use. Enable only if you know what
+	  you are doing.
+
+config MALI_2MB_ALLOC
+	bool "Attempt to allocate 2MB pages"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default n
+	help
+	  Rather than allocating all GPU memory page-by-page, attempt to
+	  allocate 2MB pages from the kernel. This reduces TLB pressure and
+	  helps to prevent memory fragmentation.
+
+	  If in doubt, say N
+
+config MALI_FPGA_BUS_LOGGER
+	bool "Enable bus log integration"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default n
+
+config MALI_PWRSOFT_765
+	bool "PWRSOFT-765 ticket"
+	depends on MALI_BIFROST && MALI_BIFROST_EXPERT
+	default n
+	help
+	  PWRSOFT-765 fixes devfreq cooling devices issues. However, they are
+	  not merged in mainline kernel yet. So this define helps to guard those
+	  parts of the code.
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/Kbuild b/drivers/gpu/arm/bifrost/backend/gpu/Kbuild
index 5eeba1b14710..be255c65a5fc 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/Kbuild
+++ b/drivers/gpu/arm/bifrost/backend/gpu/Kbuild
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 BACKEND += \
 	backend/gpu/mali_kbase_cache_policy_backend.c \
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_backend_config.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_backend_config.h
index c8ae87eb84a2..196a776f7f9d 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_backend_config.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_backend_config.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Backend specific configuration
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_cache_policy_backend.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_cache_policy_backend.c
index fef9a2cb743e..49567f785d2c 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_cache_policy_backend.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_cache_policy_backend.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include "backend/gpu/mali_kbase_cache_policy_backend.h"
 #include <backend/gpu/mali_kbase_device_internal.h>
 
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_cache_policy_backend.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_cache_policy_backend.h
index fe9869109a82..f78ada74f605 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_cache_policy_backend.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_cache_policy_backend.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 #ifndef _KBASE_CACHE_POLICY_BACKEND_H_
 #define _KBASE_CACHE_POLICY_BACKEND_H_
 
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_debug_job_fault_backend.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_debug_job_fault_backend.c
index 7851ea6466c7..c9c463eb458d 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_debug_job_fault_backend.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_debug_job_fault_backend.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 #include <backend/gpu/mali_kbase_device_internal.h>
 #include "mali_kbase_debug_job_fault.h"
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_devfreq.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_devfreq.c
index 99b39cafb62a..7e3c456bafbb 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_devfreq.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_devfreq.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 #include <mali_kbase_tlstream.h>
 #include <mali_kbase_config_defaults.h>
@@ -214,6 +219,9 @@ static int kbase_devfreq_init_freq_table(struct kbase_device *kbdev,
 		opp = dev_pm_opp_find_freq_floor(kbdev->dev, &freq);
 		if (IS_ERR(opp))
 			break;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+		dev_pm_opp_put(opp);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0) */
 
 		dp->freq_table[i] = freq;
 	}
@@ -347,6 +355,12 @@ int kbase_devfreq_init(struct kbase_device *kbdev)
 	if (kbase_devfreq_init_freq_table(kbdev, dp))
 		return -EFAULT;
 
+	if (dp->max_state > 0) {
+		/* Record the maximum frequency possible */
+		kbdev->gpu_props.props.core_props.gpu_freq_khz_max =
+			dp->freq_table[0] / 1000;
+	};
+
 	err = kbase_devfreq_init_core_mask_table(kbdev);
 	if (err)
 		return err;
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_devfreq.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_devfreq.h
index c0bf8b15b3bc..0634038c5fee 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_devfreq.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_devfreq.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _BASE_DEVFREQ_H_
 #define _BASE_DEVFREQ_H_
 
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_device_hw.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_device_hw.c
index 17f253308ffc..adc72b7805cb 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_device_hw.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_device_hw.c
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  *
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_device_internal.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_device_internal.h
index 5b20445932fb..729256ec6ce3 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_device_internal.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_device_internal.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Backend-specific HW access device APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_gpu.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_gpu.c
index a7c3a77d8ac8..3897a9fd9baf 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_gpu.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_gpu.c
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * Register-based HW access backend APIs
  */
@@ -34,6 +39,10 @@ int kbase_backend_early_init(struct kbase_device *kbdev)
 	if (err)
 		return err;
 
+	err = kbase_pm_runtime_init(kbdev);
+	if (err)
+		goto fail_runtime_pm;
+
 	/* Ensure we can access the GPU registers */
 	kbase_pm_register_access_enable(kbdev);
 
@@ -56,6 +65,8 @@ int kbase_backend_early_init(struct kbase_device *kbdev)
 fail_pm:
 	kbase_release_interrupts(kbdev);
 fail_interrupts:
+	kbase_pm_runtime_term(kbdev);
+fail_runtime_pm:
 	kbasep_platform_device_term(kbdev);
 
 	return err;
@@ -65,6 +76,7 @@ void kbase_backend_early_term(struct kbase_device *kbdev)
 {
 	kbase_hwaccess_pm_term(kbdev);
 	kbase_release_interrupts(kbdev);
+	kbase_pm_runtime_term(kbdev);
 	kbasep_platform_device_term(kbdev);
 }
 
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_gpuprops_backend.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_gpuprops_backend.c
index b395325b556b..02dc1ea0061f 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_gpuprops_backend.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_gpuprops_backend.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Base kernel property query backend APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_backend.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_backend.c
index 8084d054cc5b..43a380e53c60 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_backend.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_backend.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * GPU backend instrumentation APIs.
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_defs.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_defs.h
index 4794672da8f0..fb55d2d56f2c 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_defs.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_defs.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Backend-specific instrumentation definitions
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_internal.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_internal.h
index e96aeae786e1..608379e4ca0f 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_internal.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_instr_internal.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Backend-specific HW access instrumentation APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_irq_internal.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_irq_internal.h
index 8781561e73d0..ca3c048b637a 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_irq_internal.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_irq_internal.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Backend specific IRQ APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_irq_linux.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_irq_linux.c
index d0666c86cf59..e68deaf3f41e 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_irq_linux.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_irq_linux.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 #include <backend/gpu/mali_kbase_device_internal.h>
 #include <backend/gpu/mali_kbase_irq_internal.h>
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_as.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_as.c
index c660c80341f4..4c991522eaf1 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_as.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_as.c
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * Register backend context / address space management
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_defs.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_defs.h
index 08a7400e66d5..27a6ca0d871b 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_defs.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_defs.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * Register-based HW access backend specific definitions
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_hw.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_hw.c
index cbca5eac82f1..63a0dcdb1fb3 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_hw.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_hw.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Base kernel job manager APIs
  */
@@ -235,10 +240,8 @@ void kbase_job_done(struct kbase_device *kbdev, u32 done)
 	int i;
 	u32 count = 0;
 	ktime_t end_timestamp = ktime_get();
-	struct kbasep_js_device_data *js_devdata;
 
 	KBASE_DEBUG_ASSERT(kbdev);
-	js_devdata = &kbdev->js_data;
 
 	KBASE_TRACE_ADD(kbdev, JM_IRQ, NULL, NULL, 0, done);
 
@@ -747,7 +750,7 @@ void kbase_job_slot_ctx_priority_check_locked(struct kbase_context *kctx,
 
 		if (katom->sched_priority > priority) {
 			if (!stop_sent)
-				KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITY_CHANGE(
+				KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITIZED(
 						target_katom);
 
 			kbase_job_slot_softstop(kbdev, js, katom);
@@ -756,92 +759,43 @@ void kbase_job_slot_ctx_priority_check_locked(struct kbase_context *kctx,
 	}
 }
 
-struct zap_reset_data {
-	/* The stages are:
-	 * 1. The timer has never been called
-	 * 2. The zap has timed out, all slots are soft-stopped - the GPU reset
-	 *    will happen. The GPU has been reset when
-	 *    kbdev->hwaccess.backend.reset_waitq is signalled
-	 *
-	 * (-1 - The timer has been cancelled)
-	 */
-	int stage;
-	struct kbase_device *kbdev;
-	struct hrtimer timer;
-	spinlock_t lock; /* protects updates to stage member */
-};
-
-static enum hrtimer_restart zap_timeout_callback(struct hrtimer *timer)
-{
-	struct zap_reset_data *reset_data = container_of(timer,
-						struct zap_reset_data, timer);
-	struct kbase_device *kbdev = reset_data->kbdev;
-	unsigned long flags;
-
-	spin_lock_irqsave(&reset_data->lock, flags);
-
-	if (reset_data->stage == -1)
-		goto out;
-
-#if KBASE_GPU_RESET_EN
-	if (kbase_prepare_to_reset_gpu(kbdev)) {
-		dev_err(kbdev->dev, "Issueing GPU soft-reset because jobs failed to be killed (within %d ms) as part of context termination (e.g. process exit)\n",
-								ZAP_TIMEOUT);
-		kbase_reset_gpu(kbdev);
-	}
-#endif /* KBASE_GPU_RESET_EN */
-	reset_data->stage = 2;
-
- out:
-	spin_unlock_irqrestore(&reset_data->lock, flags);
-
-	return HRTIMER_NORESTART;
-}
-
 void kbase_jm_wait_for_zero_jobs(struct kbase_context *kctx)
 {
 	struct kbase_device *kbdev = kctx->kbdev;
-	struct zap_reset_data reset_data;
-	unsigned long flags;
+	unsigned long timeout = msecs_to_jiffies(ZAP_TIMEOUT);
 
-	hrtimer_init_on_stack(&reset_data.timer, CLOCK_MONOTONIC,
-							HRTIMER_MODE_REL);
-	reset_data.timer.function = zap_timeout_callback;
+	timeout = wait_event_timeout(kctx->jctx.zero_jobs_wait,
+			kctx->jctx.job_nr == 0, timeout);
 
-	spin_lock_init(&reset_data.lock);
+	if (timeout != 0)
+		timeout = wait_event_timeout(
+			kctx->jctx.sched_info.ctx.is_scheduled_wait,
+			!kbase_ctx_flag(kctx, KCTX_SCHEDULED),
+			timeout);
 
-	reset_data.kbdev = kbdev;
-	reset_data.stage = 1;
+	/* Neither wait timed out; all done! */
+	if (timeout != 0)
+		goto exit;
 
-	hrtimer_start(&reset_data.timer, HR_TIMER_DELAY_MSEC(ZAP_TIMEOUT),
-							HRTIMER_MODE_REL);
-
-	/* Wait for all jobs to finish, and for the context to be not-scheduled
-	 * (due to kbase_job_zap_context(), we also guarentee it's not in the JS
-	 * policy queue either */
-	wait_event(kctx->jctx.zero_jobs_wait, kctx->jctx.job_nr == 0);
-	wait_event(kctx->jctx.sched_info.ctx.is_scheduled_wait,
-		   !kbase_ctx_flag(kctx, KCTX_SCHEDULED));
-
-	spin_lock_irqsave(&reset_data.lock, flags);
-	if (reset_data.stage == 1) {
-		/* The timer hasn't run yet - so cancel it */
-		reset_data.stage = -1;
+#if KBASE_GPU_RESET_EN
+	if (kbase_prepare_to_reset_gpu(kbdev)) {
+		dev_err(kbdev->dev,
+			"Issueing GPU soft-reset because jobs failed to be killed (within %d ms) as part of context termination (e.g. process exit)\n",
+			ZAP_TIMEOUT);
+		kbase_reset_gpu(kbdev);
 	}
-	spin_unlock_irqrestore(&reset_data.lock, flags);
 
-	hrtimer_cancel(&reset_data.timer);
-
-	if (reset_data.stage == 2) {
-		/* The reset has already started.
-		 * Wait for the reset to complete
-		 */
-		wait_event(kbdev->hwaccess.backend.reset_wait,
-				atomic_read(&kbdev->hwaccess.backend.reset_gpu)
-						== KBASE_RESET_GPU_NOT_PENDING);
-	}
-	destroy_hrtimer_on_stack(&reset_data.timer);
+	/* Wait for the reset to complete */
+	wait_event(kbdev->hwaccess.backend.reset_wait,
+			atomic_read(&kbdev->hwaccess.backend.reset_gpu)
+			== KBASE_RESET_GPU_NOT_PENDING);
+#else
+	dev_warn(kbdev->dev,
+		"Jobs failed to be killed (within %d ms) as part of context termination (e.g. process exit)\n",
+		ZAP_TIMEOUT);
 
+#endif
+exit:
 	dev_dbg(kbdev->dev, "Zap: Finished Context %p", kctx);
 
 	/* Ensure that the signallers of the waitqs have finished */
@@ -874,8 +828,6 @@ int kbase_job_slot_init(struct kbase_device *kbdev)
 	if (NULL == kbdev->hwaccess.backend.reset_workq)
 		return -EINVAL;
 
-	KBASE_DEBUG_ASSERT(0 ==
-		object_is_on_stack(&kbdev->hwaccess.backend.reset_work));
 	INIT_WORK(&kbdev->hwaccess.backend.reset_work,
 						kbasep_reset_timeout_worker);
 
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_internal.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_internal.h
index 1f382b3c1af4..d71a9edab94f 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_internal.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_internal.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Job Manager backend-specific low-level APIs.
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_rb.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_rb.c
index a41e7b5b7afb..ee93d4eb9522 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_rb.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_rb.c
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * Register-based HW access backend specific APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_rb.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_rb.h
index 1e0e05ad3ea4..456700814ee9 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_rb.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_jm_rb.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * Register-based HW access backend specific APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_affinity.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_affinity.c
index 54d8ddd80097..c937eca8c166 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_affinity.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_affinity.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Base kernel affinity manager APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_affinity.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_affinity.h
index 35d9781ae092..dbabd94564c7 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_affinity.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_affinity.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Affinity Manager internal APIs.
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_backend.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_backend.c
index d392fa2a85d9..f09a26423951 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_backend.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_backend.c
@@ -1,21 +1,26 @@
 /*
  *
- * (C) COPYRIGHT 2014-2016 ARM Limited. All rights reserved.
+ * (C) COPYRIGHT 2014-2017 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the
  * GNU General Public License version 2 as published by the Free Software
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * Register-based HW access backend specific job scheduler APIs
  */
@@ -25,14 +30,6 @@
 #include <backend/gpu/mali_kbase_jm_internal.h>
 #include <backend/gpu/mali_kbase_js_internal.h>
 
-/*
- * Define for when dumping is enabled.
- * This should not be based on the instrumentation level as whether dumping is
- * enabled for a particular level is down to the integrator. However this is
- * being used for now as otherwise the cinstr headers would be needed.
- */
-#define CINSTR_DUMPING_ENABLED (2 == MALI_INSTRUMENTATION_LEVEL)
-
 /*
  * Hold the runpool_mutex for this
  */
@@ -119,7 +116,7 @@ static enum hrtimer_restart timer_callback(struct hrtimer *timer)
 			if (!kbase_hw_has_issue(kbdev, BASE_HW_ISSUE_5736)) {
 				u32 ticks = atom->ticks++;
 
-#if !CINSTR_DUMPING_ENABLED
+#ifndef CONFIG_MALI_JOB_DUMP
 				u32 soft_stop_ticks, hard_stop_ticks,
 								gpu_reset_ticks;
 				if (atom->core_req & BASE_JD_REQ_ONLY_COMPUTE) {
@@ -209,8 +206,8 @@ static enum hrtimer_restart timer_callback(struct hrtimer *timer)
 					 */
 					reset_needed = true;
 				}
-#else				/* !CINSTR_DUMPING_ENABLED */
-				/* NOTE: During CINSTR_DUMPING_ENABLED, we use
+#else				/* !CONFIG_MALI_JOB_DUMP */
+				/* NOTE: During CONFIG_MALI_JOB_DUMP, we use
 				 * the alternate timeouts, which makes the hard-
 				 * stop and GPU reset timeout much longer. We
 				 * also ensure that we don't soft-stop at all.
@@ -219,7 +216,7 @@ static enum hrtimer_restart timer_callback(struct hrtimer *timer)
 					/* Job has been scheduled for at least
 					 * js_devdata->soft_stop_ticks. We do
 					 * not soft-stop during
-					 * CINSTR_DUMPING_ENABLED, however.
+					 * CONFIG_MALI_JOB_DUMP, however.
 					 */
 					dev_dbg(kbdev->dev, "Soft-stop");
 				} else if (ticks ==
@@ -248,7 +245,7 @@ static enum hrtimer_restart timer_callback(struct hrtimer *timer)
 					 */
 					reset_needed = true;
 				}
-#endif				/* !CINSTR_DUMPING_ENABLED */
+#endif				/* !CONFIG_MALI_JOB_DUMP */
 			}
 		}
 	}
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_internal.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_internal.h
index 3f53779c6747..6576e55d2e39 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_internal.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_js_internal.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * Register-based HW access backend specific job scheduler APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_mmu_hw_direct.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_mmu_hw_direct.c
index aa1817c8bca9..ad27202c8f08 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_mmu_hw_direct.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_mmu_hw_direct.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/bitops.h>
 
 #include <mali_kbase.h>
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_mmu_hw_direct.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_mmu_hw_direct.h
index c02253c6acc3..1f76eeda2324 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_mmu_hw_direct.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_mmu_hw_direct.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Interface file for the direct implementation for MMU hardware access
  *
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_always_on.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_always_on.c
index 0614348e935a..2ed7dfdde6cc 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_always_on.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_always_on.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * "Always on" power management policy
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_always_on.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_always_on.h
index f9d244b01bc2..d61d0d0e3640 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_always_on.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_always_on.h
@@ -8,16 +8,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * "Always on" power management policy
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_backend.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_backend.c
index cd8932650ed5..8ff607d3c5fd 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_backend.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_backend.c
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * GPU backend implementation of base kernel power management APIs
  */
@@ -32,6 +37,57 @@
 
 static void kbase_pm_gpu_poweroff_wait_wq(struct work_struct *data);
 
+int kbase_pm_runtime_init(struct kbase_device *kbdev)
+{
+	struct kbase_pm_callback_conf *callbacks;
+
+	callbacks = (struct kbase_pm_callback_conf *)POWER_MANAGEMENT_CALLBACKS;
+	if (callbacks) {
+		kbdev->pm.backend.callback_power_on =
+					callbacks->power_on_callback;
+		kbdev->pm.backend.callback_power_off =
+					callbacks->power_off_callback;
+		kbdev->pm.backend.callback_power_suspend =
+					callbacks->power_suspend_callback;
+		kbdev->pm.backend.callback_power_resume =
+					callbacks->power_resume_callback;
+		kbdev->pm.callback_power_runtime_init =
+					callbacks->power_runtime_init_callback;
+		kbdev->pm.callback_power_runtime_term =
+					callbacks->power_runtime_term_callback;
+		kbdev->pm.backend.callback_power_runtime_on =
+					callbacks->power_runtime_on_callback;
+		kbdev->pm.backend.callback_power_runtime_off =
+					callbacks->power_runtime_off_callback;
+		kbdev->pm.backend.callback_power_runtime_idle =
+					callbacks->power_runtime_idle_callback;
+
+		if (callbacks->power_runtime_init_callback)
+			return callbacks->power_runtime_init_callback(kbdev);
+		else
+			return 0;
+	}
+
+	kbdev->pm.backend.callback_power_on = NULL;
+	kbdev->pm.backend.callback_power_off = NULL;
+	kbdev->pm.backend.callback_power_suspend = NULL;
+	kbdev->pm.backend.callback_power_resume = NULL;
+	kbdev->pm.callback_power_runtime_init = NULL;
+	kbdev->pm.callback_power_runtime_term = NULL;
+	kbdev->pm.backend.callback_power_runtime_on = NULL;
+	kbdev->pm.backend.callback_power_runtime_off = NULL;
+	kbdev->pm.backend.callback_power_runtime_idle = NULL;
+
+	return 0;
+}
+
+void kbase_pm_runtime_term(struct kbase_device *kbdev)
+{
+	if (kbdev->pm.callback_power_runtime_term) {
+		kbdev->pm.callback_power_runtime_term(kbdev);
+	}
+}
+
 void kbase_pm_register_access_enable(struct kbase_device *kbdev)
 {
 	struct kbase_pm_callback_conf *callbacks;
@@ -59,7 +115,6 @@ void kbase_pm_register_access_disable(struct kbase_device *kbdev)
 int kbase_hwaccess_pm_init(struct kbase_device *kbdev)
 {
 	int ret = 0;
-	struct kbase_pm_callback_conf *callbacks;
 
 	KBASE_DEBUG_ASSERT(kbdev != NULL);
 
@@ -81,38 +136,6 @@ int kbase_hwaccess_pm_init(struct kbase_device *kbdev)
 	kbdev->pm.backend.gpu_in_desired_state = true;
 	init_waitqueue_head(&kbdev->pm.backend.gpu_in_desired_state_wait);
 
-	callbacks = (struct kbase_pm_callback_conf *)POWER_MANAGEMENT_CALLBACKS;
-	if (callbacks) {
-		kbdev->pm.backend.callback_power_on =
-					callbacks->power_on_callback;
-		kbdev->pm.backend.callback_power_off =
-					callbacks->power_off_callback;
-		kbdev->pm.backend.callback_power_suspend =
-					callbacks->power_suspend_callback;
-		kbdev->pm.backend.callback_power_resume =
-					callbacks->power_resume_callback;
-		kbdev->pm.callback_power_runtime_init =
-					callbacks->power_runtime_init_callback;
-		kbdev->pm.callback_power_runtime_term =
-					callbacks->power_runtime_term_callback;
-		kbdev->pm.backend.callback_power_runtime_on =
-					callbacks->power_runtime_on_callback;
-		kbdev->pm.backend.callback_power_runtime_off =
-					callbacks->power_runtime_off_callback;
-		kbdev->pm.backend.callback_power_runtime_idle =
-					callbacks->power_runtime_idle_callback;
-	} else {
-		kbdev->pm.backend.callback_power_on = NULL;
-		kbdev->pm.backend.callback_power_off = NULL;
-		kbdev->pm.backend.callback_power_suspend = NULL;
-		kbdev->pm.backend.callback_power_resume = NULL;
-		kbdev->pm.callback_power_runtime_init = NULL;
-		kbdev->pm.callback_power_runtime_term = NULL;
-		kbdev->pm.backend.callback_power_runtime_on = NULL;
-		kbdev->pm.backend.callback_power_runtime_off = NULL;
-		kbdev->pm.backend.callback_power_runtime_idle = NULL;
-	}
-
 	/* Initialise the metrics subsystem */
 	ret = kbasep_pm_metrics_init(kbdev);
 	if (ret)
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca.c
index c17db8be8877..7be810004056 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Base kernel core availability APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca.h
index ee9e751f2d79..2b005c9fe4e3 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Base kernel core availability APIs
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_devfreq.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_devfreq.c
index 66bf660cffb6..4bb4c400efe7 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_devfreq.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_devfreq.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * A core availability policy implementing core mask selection from devfreq OPPs
  *
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_devfreq.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_devfreq.h
index 7ab3cd4d8460..f67ec650c981 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_devfreq.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_devfreq.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * A core availability policy for use with devfreq, where core masks are
  * associated with OPPs.
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_fixed.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_fixed.c
index 864612d31f9b..1eea7e877f61 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_fixed.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_fixed.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * A power policy implementing fixed core availability
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_fixed.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_fixed.h
index a763155cb703..68a2eac4a121 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_fixed.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_ca_fixed.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * A power policy implementing fixed core availability
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_coarse_demand.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_coarse_demand.c
index f891fa225a89..602e175dbbb9 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_coarse_demand.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_coarse_demand.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * "Coarse Demand" power management policy
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_coarse_demand.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_coarse_demand.h
index 749d305eee9a..f2b49eb4bcac 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_coarse_demand.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_coarse_demand.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * "Coarse Demand" power management policy
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_defs.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_defs.h
index 564fbda1116a..36492c68e1a2 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_defs.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_defs.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Backend-specific Power Manager definitions
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_demand.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_demand.c
index 81322fd0dd17..e0edddc2504d 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_demand.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_demand.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * A simple demand based power management policy
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_demand.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_demand.h
index c0c84b6e9189..5ee182463bd4 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_demand.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_demand.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * A simple demand based power management policy
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_driver.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_driver.c
index 707f71a79a77..e9089e35afd6 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_driver.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_driver.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Base kernel Power Management hardware control
  */
@@ -304,10 +309,8 @@ u64 kbase_pm_get_present_cores(struct kbase_device *kbdev,
 		return kbdev->gpu_props.props.raw_props.shader_present;
 	case KBASE_PM_CORE_TILER:
 		return kbdev->gpu_props.props.raw_props.tiler_present;
-#ifdef CONFIG_MALI_CORESTACK
 	case KBASE_PM_CORE_STACK:
 		return kbdev->gpu_props.props.raw_props.stack_present;
-#endif /* CONFIG_MALI_CORESTACK */
 	default:
 		break;
 	}
@@ -585,7 +588,7 @@ u64 kbase_pm_core_stack_mask(u64 cores)
 		if (test_bit(i, (unsigned long *)&cores)) {
 			/* Every core which ID >= 16 is filled to stacks 4-7
 			 * instead of 0-3 */
-			size_t const stack_num = (i > 16) ?
+			size_t const stack_num = (i >= 16) ?
 				(i % NUM_CORES_PER_STACK) + 4 :
 				(i % NUM_CORES_PER_STACK);
 			set_bit(stack_num, (unsigned long *)&stack_mask);
@@ -1229,15 +1232,25 @@ static void kbase_pm_hw_issues_detect(struct kbase_device *kbdev)
 	kbdev->hw_quirks_mmu = kbase_reg_read(kbdev,
 			GPU_CONTROL_REG(L2_MMU_CONFIG), NULL);
 
-	/* Limit read ID width for AXI */
-	kbdev->hw_quirks_mmu &= ~(L2_MMU_CONFIG_LIMIT_EXTERNAL_READS);
-	kbdev->hw_quirks_mmu |= (DEFAULT_ARID_LIMIT & 0x3) <<
+
+	/* Limit read & write ID width for AXI */
+	if (kbase_hw_has_feature(kbdev, BASE_HW_FEATURE_3BIT_EXT_RW_L2_MMU_CONFIG)) {
+		kbdev->hw_quirks_mmu &= ~(L2_MMU_CONFIG_3BIT_LIMIT_EXTERNAL_READS);
+		kbdev->hw_quirks_mmu |= (DEFAULT_3BIT_ARID_LIMIT & 0x7) <<
+				L2_MMU_CONFIG_3BIT_LIMIT_EXTERNAL_READS_SHIFT;
+
+		kbdev->hw_quirks_mmu &= ~(L2_MMU_CONFIG_3BIT_LIMIT_EXTERNAL_WRITES);
+		kbdev->hw_quirks_mmu |= (DEFAULT_3BIT_AWID_LIMIT & 0x7) <<
+				L2_MMU_CONFIG_3BIT_LIMIT_EXTERNAL_WRITES_SHIFT;
+	} else {
+		kbdev->hw_quirks_mmu &= ~(L2_MMU_CONFIG_LIMIT_EXTERNAL_READS);
+		kbdev->hw_quirks_mmu |= (DEFAULT_ARID_LIMIT & 0x3) <<
 				L2_MMU_CONFIG_LIMIT_EXTERNAL_READS_SHIFT;
 
-	/* Limit write ID width for AXI */
-	kbdev->hw_quirks_mmu &= ~(L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES);
-	kbdev->hw_quirks_mmu |= (DEFAULT_AWID_LIMIT & 0x3) <<
+		kbdev->hw_quirks_mmu &= ~(L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES);
+		kbdev->hw_quirks_mmu |= (DEFAULT_AWID_LIMIT & 0x3) <<
 				L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES_SHIFT;
+	}
 
 	if (kbdev->system_coherency == COHERENCY_ACE) {
 		/* Allow memory configuration disparity to be ignored, we
@@ -1297,6 +1310,8 @@ static void kbase_pm_hw_issues_detect(struct kbase_device *kbdev)
 		}
 	}
 
+	if (kbase_hw_has_feature(kbdev, BASE_HW_FEATURE_TLS_HASHING))
+		kbdev->hw_quirks_sc |= SC_TLS_HASH_ENABLE;
 
 	if (!kbdev->hw_quirks_jm)
 		kbdev->hw_quirks_jm = kbase_reg_read(kbdev,
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_internal.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_internal.h
index 9fbe094541c5..d7afc6173a2d 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_internal.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_internal.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Power management API definitions used internally by GPU backend
  */
@@ -410,15 +415,30 @@ void kbase_pm_release_gpu_cycle_counter_nolock(struct kbase_device *kbdev);
  */
 void kbase_pm_wait_for_poweroff_complete(struct kbase_device *kbdev);
 
+/**
+ * kbase_pm_runtime_init - Initialize runtime-pm for Mali GPU platform device
+ *
+ * Setup the power management callbacks and initialize/enable the runtime-pm
+ * for the Mali GPU platform device, using the callback function. This must be
+ * called before the kbase_pm_register_access_enable() function.
+ *
+ * @kbdev: The kbase device structure for the device (must be a valid pointer)
+ */
+int kbase_pm_runtime_init(struct kbase_device *kbdev);
+
+/**
+ * kbase_pm_runtime_term - Disable runtime-pm for Mali GPU platform device
+ *
+ * @kbdev: The kbase device structure for the device (must be a valid pointer)
+ */
+void kbase_pm_runtime_term(struct kbase_device *kbdev);
+
 /**
  * kbase_pm_register_access_enable - Enable access to GPU registers
  *
  * Enables access to the GPU registers before power management has powered up
  * the GPU with kbase_pm_powerup().
  *
- * Access to registers should be done using kbase_os_reg_read()/write() at this
- * stage, not kbase_reg_read()/write().
- *
  * This results in the power management callbacks provided in the driver
  * configuration to get called to turn on power and/or clocks to the GPU. See
  * kbase_pm_callback_conf.
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_metrics.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_metrics.c
index ba13bcd8b291..a7781c5cccab 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_metrics.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_metrics.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Metrics for power management
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_policy.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_policy.c
index b98c68d9a42a..18a06d833169 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_policy.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_policy.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Power policy API implementations
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_policy.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_policy.h
index 611a90e66e65..852fedd346ba 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_policy.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_pm_policy.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Power policy API definitions
  */
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_time.c b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_time.c
index 0068e1091f4c..cd0c534ffc1f 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_time.c
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_time.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 #include <mali_kbase_hwaccess_time.h>
 #include <backend/gpu/mali_kbase_device_internal.h>
diff --git a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_time.h b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_time.h
index 0559b2f7097d..c17a23f560a4 100644
--- a/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_time.h
+++ b/drivers/gpu/arm/bifrost/backend/gpu/mali_kbase_time.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_BACKEND_TIME_H_
 #define _KBASE_BACKEND_TIME_H_
 
diff --git a/drivers/gpu/arm/bifrost/build.bp b/drivers/gpu/arm/bifrost/build.bp
new file mode 100644
index 000000000000..936d5dca8f4a
--- /dev/null
+++ b/drivers/gpu/arm/bifrost/build.bp
@@ -0,0 +1,95 @@
+/*
+ * Copyright:
+ * ----------------------------------------------------------------------------
+ * This confidential and proprietary software may be used only as authorized
+ * by a licensing agreement from ARM Limited.
+ *      (C) COPYRIGHT 2017 ARM Limited, ALL RIGHTS RESERVED
+ * The entire notice above must be reproduced on all authorized copies and
+ * copies may only be made to the extent permitted by a licensing agreement
+ * from ARM Limited.
+ * ----------------------------------------------------------------------------
+ */
+
+bob_defaults {
+    name: "mali_kbase_shared_config_defaults",
+    no_mali: {
+        kbuild_options: ["CONFIG_MALI_BIFROST_NO_MALI=y"],
+    },
+    mali_corestack: {
+        kbuild_options: ["CONFIG_MALI_CORESTACK=y"],
+    },
+    mali_devfreq: {
+        kbuild_options: ["CONFIG_MALI_BIFROST_DEVFREQ=y"],
+    },
+
+    defaults: ["kernel_defaults"],
+}
+
+bob_kernel_module {
+    name: "mali_kbase",
+    srcs: [
+        "*.c",
+        "*.h",
+        "Kbuild",
+        "backend/gpu/*.c",
+        "backend/gpu/*.h",
+        "backend/gpu/Kbuild",
+        "ipa/*.c",
+        "ipa/*.h",
+        "ipa/Kbuild",
+        "platform/*.h",
+        "platform/*/*.c",
+        "platform/*/*.h",
+        "platform/*/Kbuild",
+        "thirdparty/*.c",
+    ],
+    kbuild_options: [
+        "CONFIG_MALI_KUTF=n",
+        "CONFIG_MALI_MIDGARD=m",
+        "CONFIG_MALI_NO_MALI_DEFAULT_GPU={{.gpu}}",
+        "CONFIG_MALI_PLATFORM_NAME={{.mali_platform_name}}",
+        "MALI_KERNEL_TEST_API={{.unit_test_code}}",
+        "MALI_MOCK_TEST={{.mali_mock_test}}",
+        "MALI_UNIT_TEST={{.unit_test_code}}",
+    ],
+    cinstr_job_dump: {
+        kbuild_options: ["CONFIG_MALI_JOB_DUMP=y"],
+    },
+    mali_debug: {
+        kbuild_options: ["CONFIG_MALI_BIFROST_DEBUG=y"],
+    },
+    mali_gator_support: {
+        kbuild_options: ["CONFIG_MALI_BIFROST_GATOR_SUPPORT=y"],
+    },
+    mali_system_trace: {
+        kbuild_options: ["CONFIG_MALI_BIFROST_SYSTEM_TRACE=y"],
+    },
+    mali_error_inject: {
+        kbuild_options: ["CONFIG_MALI_BIFROST_ERROR_INJECT=y"],
+    },
+    mali_error_inject_random: {
+        kbuild_options: ["CONFIG_MALI_ERROR_INJECT_RANDOM=y"],
+    },
+    mali_trace_timeline: {
+        kbuild_options: ["CONFIG_MALI_BIFROST_TRACE_TIMELINE=y"],
+    },
+    mali_prfcnt_set_secondary: {
+        kbuild_options: ["CONFIG_MALI_BIFROST_PRFCNT_SET_SECONDARY=y"],
+    },
+    mali_fpga_bus_logger: {
+        kbuild_options: ["CONFIG_MALI_FPGA_BUS_LOGGER=y"],
+    },
+    mali_midgard_dvfs: {
+        kbuild_options: ["CONFIG_MALI_BIFROST_DVFS=y"],
+    },
+    mali_2mb_alloc: {
+        kbuild_options: ["CONFIG_MALI_2MB_ALLOC=y"],
+    },
+    mali_mock_test: {
+        srcs: ["tests/internal/src/mock/mali_kbase_pm_driver_mock.c"],
+    },
+    ump: {
+        extra_symbols: ["ump"],
+    },
+    defaults: ["mali_kbase_shared_config_defaults"],
+}
diff --git a/drivers/gpu/arm/bifrost/docs/Doxyfile b/drivers/gpu/arm/bifrost/docs/Doxyfile
index 35ff2f1ce4a0..cea7bd9a1730 100644
--- a/drivers/gpu/arm/bifrost/docs/Doxyfile
+++ b/drivers/gpu/arm/bifrost/docs/Doxyfile
@@ -1,17 +1,23 @@
 #
-# (C) COPYRIGHT 2011-2013, 2015 ARM Limited. All rights reserved.
+# (C) COPYRIGHT 2011-2013, 2015, 2017 ARM Limited. All rights reserved.
 #
 # This program is free software and is provided to you under the terms of the
 # GNU General Public License version 2 as published by the Free Software
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 
 ##############################################################################
@@ -64,7 +70,7 @@ FILE_PATTERNS          +=
 # The EXCLUDE tag can be used to specify files and/or directories that should
 # excluded from the INPUT source files. This way you can easily exclude a
 # subdirectory from a directory tree whose root is specified with the INPUT tag.
-EXCLUDE                += ../../kernel/drivers/gpu/arm/midgard/platform ../../kernel/drivers/gpu/arm/midgard/platform_dummy ../../kernel/drivers/gpu/arm/midgard/scripts ../../kernel/drivers/gpu/arm/midgard/tests ../../kernel/drivers/gpu/arm/midgard/Makefile ../../kernel/drivers/gpu/arm/midgard/Makefile.kbase ../../kernel/drivers/gpu/arm/midgard/Kbuild ../../kernel/drivers/gpu/arm/midgard/Kconfig ../../kernel/drivers/gpu/arm/midgard/sconscript ../../kernel/drivers/gpu/arm/midgard/docs ../../kernel/drivers/gpu/arm/midgard/pm_test_script.sh ../../kernel/drivers/gpu/arm/midgard/mali_uk.h ../../kernel/drivers/gpu/arm/midgard/Makefile
+EXCLUDE                += ../../kernel/drivers/gpu/arm/midgard/platform ../../kernel/drivers/gpu/arm/midgard/platform_dummy ../../kernel/drivers/gpu/arm/midgard/scripts ../../kernel/drivers/gpu/arm/midgard/tests ../../kernel/drivers/gpu/arm/midgard/Makefile ../../kernel/drivers/gpu/arm/midgard/Makefile.kbase ../../kernel/drivers/gpu/arm/midgard/Kbuild ../../kernel/drivers/gpu/arm/midgard/Kconfig ../../kernel/drivers/gpu/arm/midgard/sconscript ../../kernel/drivers/gpu/arm/midgard/docs ../../kernel/drivers/gpu/arm/midgard/mali_uk.h ../../kernel/drivers/gpu/arm/midgard/Makefile
 
 
 # If the value of the INPUT tag contains directories, you can use the
diff --git a/drivers/gpu/arm/bifrost/docs/policy_operation_diagram.dot b/drivers/gpu/arm/bifrost/docs/policy_operation_diagram.dot
index 7ae05c2f8ded..a15b55811482 100644
--- a/drivers/gpu/arm/bifrost/docs/policy_operation_diagram.dot
+++ b/drivers/gpu/arm/bifrost/docs/policy_operation_diagram.dot
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 digraph policy_objects_diagram {
 	rankdir=LR;
 	size="12,8";
diff --git a/drivers/gpu/arm/bifrost/docs/policy_overview.dot b/drivers/gpu/arm/bifrost/docs/policy_overview.dot
index 159b993b7d61..6b8733593191 100644
--- a/drivers/gpu/arm/bifrost/docs/policy_overview.dot
+++ b/drivers/gpu/arm/bifrost/docs/policy_overview.dot
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 digraph policy_objects_diagram {
 	rankdir=LR
 	size="6,6"
diff --git a/drivers/gpu/arm/bifrost/ipa/Kbuild b/drivers/gpu/arm/bifrost/ipa/Kbuild
index 831fa83c6a8e..e06d2eac4aa1 100644
--- a/drivers/gpu/arm/bifrost/ipa/Kbuild
+++ b/drivers/gpu/arm/bifrost/ipa/Kbuild
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 bifrost_kbase-y += \
 	ipa/mali_kbase_ipa_simple.o \
diff --git a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.c b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.c
index d6332b55e970..d95a8971d6e2 100644
--- a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.c
+++ b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.c
@@ -7,13 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
-
-
 #include <linux/thermal.h>
 #include <linux/devfreq_cooling.h>
 #include <linux/of.h>
@@ -109,6 +114,10 @@ static struct device_node *get_model_dt_node(struct kbase_ipa_model *model)
 	snprintf(compat_string, sizeof(compat_string), "arm,%s",
 		 model->ops->name);
 
+	/* of_find_compatible_node() will call of_node_put() on the root node,
+	 * so take a reference on it first.
+	 */
+	of_node_get(model->kbdev->dev->of_node);
 	model_dt_node = of_find_compatible_node(model->kbdev->dev->of_node,
 						NULL, compat_string);
 	if (!model_dt_node && !model->missing_dt_node_warning) {
@@ -130,6 +139,10 @@ int kbase_ipa_model_add_param_s32(struct kbase_ipa_model *model,
 	char *origin;
 
 	err = of_property_read_u32_array(model_dt_node, name, addr, num_elems);
+	/* We're done with model_dt_node now, so drop the reference taken in
+	 * get_model_dt_node()/of_find_compatible_node().
+	 */
+	of_node_put(model_dt_node);
 
 	if (err && dt_required) {
 		memset(addr, 0, sizeof(s32) * num_elems);
@@ -177,6 +190,12 @@ int kbase_ipa_model_add_param_string(struct kbase_ipa_model *model,
 
 	err = of_property_read_string(model_dt_node, name,
 				      &string_prop_value);
+
+	/* We're done with model_dt_node now, so drop the reference taken in
+	 * get_model_dt_node()/of_find_compatible_node().
+	 */
+	of_node_put(model_dt_node);
+
 	if (err && dt_required) {
 		strncpy(addr, "", size - 1);
 		dev_warn(model->kbdev->dev,
@@ -198,7 +217,6 @@ int kbase_ipa_model_add_param_string(struct kbase_ipa_model *model,
 
 	err = kbase_ipa_model_param_add(model, name, addr, size,
 					PARAM_TYPE_STRING);
-
 	return err;
 }
 
@@ -325,8 +343,11 @@ int kbase_ipa_init(struct kbase_device *kbdev)
 		ops = kbase_ipa_model_ops_find(kbdev, model_name);
 		kbdev->ipa.configured_model = kbase_ipa_init_model(kbdev, ops);
 		if (!kbdev->ipa.configured_model) {
-			err = -EINVAL;
-			goto end;
+			dev_warn(kbdev->dev,
+				"Failed to initialize ipa-model: \'%s\'\n"
+				"Falling back on default model\n",
+				model_name);
+			kbdev->ipa.configured_model = default_model;
 		}
 	} else {
 		kbdev->ipa.configured_model = default_model;
@@ -390,7 +411,7 @@ static u32 kbase_scale_dynamic_power(const u32 c, const u32 freq,
 	const u64 v2fc = (u64) c * (u64) v2f;
 
 	/* Range: 0 < v2fc / 1000 < 2^13 mW */
-	return v2fc / 1000;
+	return div_u64(v2fc, 1000);
 }
 
 /**
@@ -419,7 +440,7 @@ u32 kbase_scale_static_power(const u32 c, const u32 voltage)
 	const u64 v3c_big = (u64) c * (u64) v3;
 
 	/* Range: 0 < v3c_big / 1000000 < 2^13 mW */
-	return v3c_big / 1000000;
+	return div_u64(v3c_big, 1000000);
 }
 
 static struct kbase_ipa_model *get_current_model(struct kbase_device *kbdev)
@@ -455,7 +476,8 @@ static u32 get_static_power_locked(struct kbase_device *kbdev,
 	return power;
 }
 
-#ifdef CONFIG_MALI_PWRSOFT_765
+#if defined(CONFIG_MALI_PWRSOFT_765) || \
+	LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
 static unsigned long kbase_get_static_power(struct devfreq *df,
 					    unsigned long voltage)
 #else
@@ -464,7 +486,8 @@ static unsigned long kbase_get_static_power(unsigned long voltage)
 {
 	struct kbase_ipa_model *model;
 	u32 power = 0;
-#ifdef CONFIG_MALI_PWRSOFT_765
+#if defined(CONFIG_MALI_PWRSOFT_765) || \
+	LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
 	struct kbase_device *kbdev = dev_get_drvdata(&df->dev);
 #else
 	struct kbase_device *kbdev = kbase_find_device(-1);
@@ -477,14 +500,16 @@ static unsigned long kbase_get_static_power(unsigned long voltage)
 
 	mutex_unlock(&kbdev->ipa.lock);
 
-#ifndef CONFIG_MALI_PWRSOFT_765
+#if !(defined(CONFIG_MALI_PWRSOFT_765) || \
+	LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
 	kbase_release_device(kbdev);
 #endif
 
 	return power;
 }
 
-#ifdef CONFIG_MALI_PWRSOFT_765
+#if defined(CONFIG_MALI_PWRSOFT_765) || \
+	LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
 static unsigned long kbase_get_dynamic_power(struct devfreq *df,
 					     unsigned long freq,
 					     unsigned long voltage)
@@ -496,7 +521,8 @@ static unsigned long kbase_get_dynamic_power(unsigned long freq,
 	struct kbase_ipa_model *model;
 	u32 power_coeff = 0, power = 0;
 	int err = 0;
-#ifdef CONFIG_MALI_PWRSOFT_765
+#if defined(CONFIG_MALI_PWRSOFT_765) || \
+	LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
 	struct kbase_device *kbdev = dev_get_drvdata(&df->dev);
 #else
 	struct kbase_device *kbdev = kbase_find_device(-1);
@@ -517,7 +543,8 @@ static unsigned long kbase_get_dynamic_power(unsigned long freq,
 
 	mutex_unlock(&kbdev->ipa.lock);
 
-#ifndef CONFIG_MALI_PWRSOFT_765
+#if !(defined(CONFIG_MALI_PWRSOFT_765) || \
+	LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
 	kbase_release_device(kbdev);
 #endif
 
@@ -557,7 +584,7 @@ int kbase_get_real_power(struct devfreq *df, u32 *power,
 		unsigned long total_time = max(status->total_time, 1ul);
 		u64 busy_time = min(status->busy_time, total_time);
 
-		*power = ((u64) *power * (u64) busy_time) / total_time;
+		*power = div_u64((u64) *power * (u64) busy_time, total_time);
 	}
 
 	*power += get_static_power_locked(kbdev, model, voltage);
diff --git a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.h b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.h
index 67478fe911ea..e087d2348763 100644
--- a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.h
+++ b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_IPA_H_
 #define _KBASE_IPA_H_
 
diff --git a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_debugfs.c b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_debugfs.c
index eafc14009ddc..029023c6036b 100644
--- a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_debugfs.c
+++ b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_debugfs.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/debugfs.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
@@ -56,14 +61,18 @@ static int param_int_set(void *data, u64 val)
 	struct kbase_ipa_model_param *param = data;
 	struct kbase_ipa_model *model = param->model;
 	s64 sval = (s64) val;
+	s32 old_val;
 	int err = 0;
 
 	if (sval < S32_MIN || sval > S32_MAX)
 		return -ERANGE;
 
 	mutex_lock(&param->model->kbdev->ipa.lock);
+	old_val = *param->addr.s32p;
 	*param->addr.s32p = val;
 	err = kbase_ipa_model_recalculate(model);
+	if (err < 0)
+		*param->addr.s32p = old_val;
 	mutex_unlock(&param->model->kbdev->ipa.lock);
 
 	return err;
@@ -92,6 +101,7 @@ static ssize_t param_string_set(struct file *file, const char __user *user_buf,
 {
 	struct kbase_ipa_model_param *param = file->private_data;
 	struct kbase_ipa_model *model = param->model;
+	char *old_str = NULL;
 	ssize_t ret = count;
 	size_t buf_size;
 	int err;
@@ -103,6 +113,12 @@ static ssize_t param_string_set(struct file *file, const char __user *user_buf,
 		goto end;
 	}
 
+	old_str = kstrndup(param->addr.str, param->size, GFP_KERNEL);
+	if (!old_str) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
 	buf_size = min(param->size - 1, count);
 	if (copy_from_user(param->addr.str, user_buf, buf_size)) {
 		ret = -EFAULT;
@@ -112,10 +128,13 @@ static ssize_t param_string_set(struct file *file, const char __user *user_buf,
 	param->addr.str[buf_size] = '\0';
 
 	err = kbase_ipa_model_recalculate(model);
-	if (err < 0)
+	if (err < 0) {
 		ret = err;
+		strlcpy(param->addr.str, old_str, param->size);
+	}
 
 end:
+	kfree(old_str);
 	mutex_unlock(&model->kbdev->ipa.lock);
 
 	return ret;
@@ -142,6 +161,12 @@ int kbase_ipa_model_param_add(struct kbase_ipa_model *model, const char *name,
 	/* 'name' is stack-allocated for array elements, so copy it into
 	 * heap-allocated storage */
 	param->name = kstrdup(name, GFP_KERNEL);
+
+	if (!param->name) {
+		kfree(param);
+		return -ENOMEM;
+	}
+
 	param->addr.voidp = addr;
 	param->size = size;
 	param->type = type;
@@ -207,6 +232,30 @@ static void kbase_ipa_model_debugfs_init(struct kbase_ipa_model *model)
 	}
 }
 
+void kbase_ipa_model_param_set_s32(struct kbase_ipa_model *model,
+	const char *name, s32 val)
+{
+	struct kbase_ipa_model_param *param;
+
+	mutex_lock(&model->kbdev->ipa.lock);
+
+	list_for_each_entry(param, &model->params, link) {
+		if (!strcmp(param->name, name)) {
+			if (param->type == PARAM_TYPE_S32) {
+				*param->addr.s32p = val;
+			} else {
+				dev_err(model->kbdev->dev,
+					"Wrong type for %s parameter %s\n",
+					model->ops->name, param->name);
+			}
+			break;
+		}
+	}
+
+	mutex_unlock(&model->kbdev->ipa.lock);
+}
+KBASE_EXPORT_TEST_API(kbase_ipa_model_param_set_s32);
+
 void kbase_ipa_debugfs_init(struct kbase_device *kbdev)
 {
 	mutex_lock(&kbdev->ipa.lock);
diff --git a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_debugfs.h b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_debugfs.h
index ec06e2096f94..a983d9c14216 100644
--- a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_debugfs.h
+++ b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_debugfs.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_IPA_DEBUGFS_H_
 #define _KBASE_IPA_DEBUGFS_H_
 
@@ -31,6 +36,20 @@ int kbase_ipa_model_param_add(struct kbase_ipa_model *model, const char *name,
 			      enum kbase_ipa_model_param_type type);
 void kbase_ipa_model_param_free_all(struct kbase_ipa_model *model);
 
+/**
+ * kbase_ipa_model_param_set_s32 - Set an integer model parameter
+ *
+ * @model:	pointer to IPA model
+ * @name:	name of corresponding debugfs entry
+ * @val:	new value of the parameter
+ *
+ * This function is only exposed for use by unit tests running in
+ * kernel space. Normally it is expected that parameter values will
+ * instead be set via debugfs.
+ */
+void kbase_ipa_model_param_set_s32(struct kbase_ipa_model *model,
+	const char *name, s32 val);
+
 #else /* CONFIG_DEBUG_FS */
 
 static inline int kbase_ipa_model_param_add(struct kbase_ipa_model *model,
diff --git a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_simple.c b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_simple.c
index de6c3e6ef7a8..639ade266e14 100644
--- a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_simple.c
+++ b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_simple.c
@@ -7,14 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
+#include <uapi/linux/thermal.h>
 #include <linux/thermal.h>
 #ifdef CONFIG_DEVFREQ_THERMAL
 #include <linux/devfreq_cooling.h>
@@ -46,7 +52,7 @@ static int dummy_temp;
 
 static int kbase_simple_power_model_get_dummy_temp(
 	struct thermal_zone_device *tz,
-	int *dummy_temp)
+	int *temp)
 {
 	*temp = ACCESS_ONCE(dummy_temp);
 	return 0;
@@ -91,7 +97,7 @@ struct kbase_ipa_model_simple_data {
 	u32 dynamic_coefficient;
 	u32 static_coefficient;
 	s32 ts[4];
-	char tz_name[16];
+	char tz_name[THERMAL_NAME_LENGTH];
 	struct thermal_zone_device *gpu_tz;
 	struct task_struct *poll_temperature_thread;
 	int current_temperature;
@@ -113,10 +119,10 @@ struct kbase_ipa_model_simple_data {
 static u32 calculate_temp_scaling_factor(s32 ts[4], s64 t)
 {
 	/* Range: -2^24 < t2 < 2^24 m(Deg^2) */
-	const s64 t2 = (t * t) / 1000;
+	const s64 t2 = div_s64((t * t), 1000);
 
 	/* Range: -2^31 < t3 < 2^31 m(Deg^3) */
-	const s64 t3 = (t * t2) / 1000;
+	const s64 t3 = div_s64((t * t2), 1000);
 
 	/*
 	 * Sum the parts. t^[1-3] are in m(Deg^N), but the coefficients are in
@@ -129,7 +135,7 @@ static u32 calculate_temp_scaling_factor(s32 ts[4], s64 t)
 			  + ts[0] * 1000; /* +/- 2^41 */
 
 	/* Range: -2^60 < res_unclamped < 2^60 */
-	s64 res_unclamped = res_big / 1000;
+	s64 res_unclamped = div_s64(res_big, 1000);
 
 	/* Clamp to range of 0x to 10x the static power */
 	return clamp(res_unclamped, (s64) 0, (s64) 10000000);
@@ -192,7 +198,7 @@ static int model_static_coeff(struct kbase_ipa_model *model, u32 *coeffp)
 	 * 0 <= static_coefficient < 2^28.
 	 */
 	coeff_big = (u64) model_data->static_coefficient * (u64) temp_scaling_factor;
-	*coeffp = coeff_big / 1000000;
+	*coeffp = div_u64(coeff_big, 1000000);
 
 	return 0;
 }
@@ -283,20 +289,43 @@ static int kbase_simple_power_model_recalculate(struct kbase_ipa_model *model)
 			(struct kbase_ipa_model_simple_data *)model->model_data;
 	struct thermal_zone_device *tz;
 
+	lockdep_assert_held(&model->kbdev->ipa.lock);
+
 	if (!strnlen(model_data->tz_name, sizeof(model_data->tz_name))) {
-		tz = NULL;
+		model_data->gpu_tz = NULL;
 	} else {
-		tz = thermal_zone_get_zone_by_name(model_data->tz_name);
+		char tz_name[THERMAL_NAME_LENGTH];
+
+		strlcpy(tz_name, model_data->tz_name, sizeof(tz_name));
+
+		/* Release ipa.lock so that thermal_list_lock is not acquired
+		 * with ipa.lock held, thereby avoid lock ordering violation
+		 * lockdep warning. The warning comes as a chain of locks
+		 * ipa.lock --> thermal_list_lock --> tz->lock gets formed
+		 * on registering devfreq cooling device when probe method
+		 * of mali platform driver is invoked.
+		 */
+		mutex_unlock(&model->kbdev->ipa.lock);
+		tz = thermal_zone_get_zone_by_name(tz_name);
+		mutex_lock(&model->kbdev->ipa.lock);
 
 		if (IS_ERR_OR_NULL(tz)) {
 			pr_warn_ratelimited("Error %ld getting thermal zone \'%s\', not yet ready?\n",
-					    PTR_ERR(tz), model_data->tz_name);
-			tz = NULL;
+					    PTR_ERR(tz), tz_name);
 			return -EPROBE_DEFER;
 		}
-	}
 
-	ACCESS_ONCE(model_data->gpu_tz) = tz;
+		/* Check if another thread raced against us & updated the
+		 * thermal zone name string. Update the gpu_tz pointer only if
+		 * the name string did not change whilst we retrieved the new
+		 * thermal_zone_device pointer, otherwise model_data->tz_name &
+		 * model_data->gpu_tz would become inconsistent with each other.
+		 * The below check will succeed only for the thread which last
+		 * updated the name string.
+		 */
+		if (strncmp(tz_name, model_data->tz_name, sizeof(tz_name)) == 0)
+			model_data->gpu_tz = tz;
+	}
 
 	return 0;
 }
@@ -320,3 +349,4 @@ struct kbase_ipa_model_ops kbase_simple_ipa_model_ops = {
 		.get_static_coeff = &model_static_coeff,
 		.do_utilization_scaling_in_framework = true,
 };
+KBASE_EXPORT_TEST_API(kbase_simple_ipa_model_ops);
diff --git a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_simple.h b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_simple.h
index 23cd55f5867d..84534e07ec55 100644
--- a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_simple.h
+++ b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_simple.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_IPA_SIMPLE_H_
 #define _KBASE_IPA_SIMPLE_H_
 
diff --git a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_common.c b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_common.c
index d3964d0d3c73..b9a9e573607e 100644
--- a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_common.c
+++ b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_common.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include "mali_kbase_ipa_vinstr_common.h"
 
 #if MALI_UNIT_TEST
@@ -24,6 +29,8 @@ static ktime_t dummy_time;
 #ifdef ktime_get
 #undef ktime_get
 #endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)
 #define ktime_get() (ACCESS_ONCE(dummy_time))
 
 void kbase_ipa_set_dummy_time(ktime_t t)
@@ -31,6 +38,16 @@ void kbase_ipa_set_dummy_time(ktime_t t)
 	ACCESS_ONCE(dummy_time) = t;
 }
 KBASE_EXPORT_TEST_API(kbase_ipa_set_dummy_time);
+#else
+#define ktime_get() (READ_ONCE(dummy_time))
+
+void kbase_ipa_set_dummy_time(ktime_t t)
+{
+	WRITE_ONCE(dummy_time, t);
+}
+KBASE_EXPORT_TEST_API(kbase_ipa_set_dummy_time);
+
+#endif
 
 #endif /* MALI_UNIT_TEST */
 
@@ -85,7 +102,7 @@ s64 kbase_ipa_sum_all_shader_cores(
 	/* Range: -2^54 < ret < 2^54 */
 	ret *= coeff;
 
-	return ret / 1000000;
+	return div_s64(ret, 1000000);
 }
 
 s64 kbase_ipa_single_counter(
@@ -99,7 +116,7 @@ s64 kbase_ipa_single_counter(
 	const s64 multiplied = (s64) counter_value * (s64) coeff;
 
 	/* Range: -2^29 < return < 2^29 */
-	return multiplied / 1000000;
+	return div_s64(multiplied, 1000000);
 }
 
 int kbase_ipa_attach_vinstr(struct kbase_ipa_model_vinstr_data *model_data)
@@ -173,7 +190,7 @@ int kbase_ipa_vinstr_dynamic_coeff(struct kbase_ipa_model *model, u32 *coeffp,
 		s32 coeff, group_energy;
 
 		coeff = model_data->group_values[i];
-		group_energy = group->op(model_data, coeff, group->counter);
+		group_energy = group->op(model_data, coeff, group->counter_block_offset);
 
 		energy = kbase_ipa_add_saturate(energy, group_energy);
 	}
@@ -199,7 +216,7 @@ int kbase_ipa_vinstr_dynamic_coeff(struct kbase_ipa_model *model, u32 *coeffp,
 	/* Range: 2^20 < num_cycles < 2^40 mCycles */
 	num_cycles = (u64) current_freq * (u64) time_since_last_sample_ms;
 	/* Range: 2^10 < num_cycles < 2^30 Cycles */
-	num_cycles /= 1000000;
+	num_cycles = div_u64(num_cycles, 1000000);
 
 	/* num_cycles should never be 0 in _normal_ usage (because we expect
 	 * frequencies on the order of MHz and >10ms polling intervals), but
diff --git a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_common.h b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_common.h
index 25b36c8e3089..7233642add78 100644
--- a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_common.h
+++ b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_common.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_IPA_VINSTR_COMMON_H_
 #define _KBASE_IPA_VINSTR_COMMON_H_
 
@@ -69,21 +74,22 @@ struct kbase_ipa_model_vinstr_data {
  *                      Coefficients are interpreted as fractions where the
  *                      denominator is 1000000.
  * @op:                 which operation to be performed on the counter values
- * @counter:            counter used to calculate energy for IPA group
+ * @counter_block_offset:  block offset in bytes of the counter used to calculate energy for IPA group
  */
 struct kbase_ipa_group {
 	char name[KBASE_IPA_MAX_GROUP_NAME_LEN + 1];
 	s32 default_value;
 	s64 (*op)(struct kbase_ipa_model_vinstr_data *, s32, u32);
-	u32 counter;
+	u32 counter_block_offset;
 };
 
-/*
+/**
  * sum_all_shader_cores() - sum a counter over all cores
  * @model_data		pointer to model data
  * @coeff		model coefficient. Unity is ~2^20, so range approx
  * +/- 4.0: -2^22 < coeff < 2^22
-
+ * @counter     offset in bytes of the counter used to calculate energy for IPA group
+ *
  * Calculate energy estimation based on hardware counter `counter'
  * across all shader cores.
  *
@@ -93,12 +99,13 @@ s64 kbase_ipa_sum_all_shader_cores(
 	struct kbase_ipa_model_vinstr_data *model_data,
 	s32 coeff, u32 counter);
 
-/*
+/**
  * sum_single_counter() - sum a single counter
  * @model_data		pointer to model data
  * @coeff		model coefficient. Unity is ~2^20, so range approx
  * +/- 4.0: -2^22 < coeff < 2^22
-
+ * @counter     offset in bytes of the counter used to calculate energy for IPA group
+ *
  * Calculate energy estimation based on hardware counter `counter'.
  *
  * Return: Counter value. Range: -2^34 < ret < 2^34
@@ -107,7 +114,7 @@ s64 kbase_ipa_single_counter(
 	struct kbase_ipa_model_vinstr_data *model_data,
 	s32 coeff, u32 counter);
 
-/*
+/**
  * attach_vinstr() - attach a vinstr_buffer to an IPA model.
  * @model_data		pointer to model data
  *
@@ -119,7 +126,7 @@ s64 kbase_ipa_single_counter(
  */
 int kbase_ipa_attach_vinstr(struct kbase_ipa_model_vinstr_data *model_data);
 
-/*
+/**
  * detach_vinstr() - detach a vinstr_buffer from an IPA model.
  * @model_data		pointer to model data
  *
diff --git a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_g71.c b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_g71.c
index 81f6fddbd79b..d07fb36d901e 100644
--- a/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_g71.c
+++ b/drivers/gpu/arm/bifrost/ipa/mali_kbase_ipa_vinstr_g71.c
@@ -7,13 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
-
-
 #include <linux/thermal.h>
 
 #include "mali_kbase_ipa_vinstr_common.h"
@@ -21,54 +26,169 @@
 #include "mali_kbase_ipa_debugfs.h"
 
 
-#define JM_BASE    (0 * KBASE_IPA_NR_BYTES_PER_BLOCK)
-#define TILER_BASE (1 * KBASE_IPA_NR_BYTES_PER_BLOCK)
-#define MMU_BASE   (2 * KBASE_IPA_NR_BYTES_PER_BLOCK)
-#define SC0_BASE   (3 * KBASE_IPA_NR_BYTES_PER_BLOCK)
-
-#define GPU_ACTIVE       (JM_BASE    + KBASE_IPA_NR_BYTES_PER_CNT *  6)
-#define TILER_ACTIVE     (TILER_BASE + KBASE_IPA_NR_BYTES_PER_CNT * 45)
-#define L2_ANY_LOOKUP    (MMU_BASE   + KBASE_IPA_NR_BYTES_PER_CNT * 25)
-#define FRAG_ACTIVE      (SC0_BASE   + KBASE_IPA_NR_BYTES_PER_CNT *  4)
-#define EXEC_CORE_ACTIVE (SC0_BASE   + KBASE_IPA_NR_BYTES_PER_CNT * 26)
-#define EXEC_INSTR_COUNT (SC0_BASE   + KBASE_IPA_NR_BYTES_PER_CNT * 28)
-#define TEX_COORD_ISSUE  (SC0_BASE   + KBASE_IPA_NR_BYTES_PER_CNT * 40)
-#define VARY_SLOT_32     (SC0_BASE   + KBASE_IPA_NR_BYTES_PER_CNT * 50)
-#define VARY_SLOT_16     (SC0_BASE   + KBASE_IPA_NR_BYTES_PER_CNT * 51)
-#define BEATS_RD_LSC     (SC0_BASE   + KBASE_IPA_NR_BYTES_PER_CNT * 56)
-#define BEATS_WR_LSC     (SC0_BASE   + KBASE_IPA_NR_BYTES_PER_CNT * 61)
-#define BEATS_WR_TIB     (SC0_BASE   + KBASE_IPA_NR_BYTES_PER_CNT * 62)
+/* Performance counter blocks base offsets */
+#define JM_BASE             (0 * KBASE_IPA_NR_BYTES_PER_BLOCK)
+#define TILER_BASE          (1 * KBASE_IPA_NR_BYTES_PER_BLOCK)
+#define MEMSYS_BASE         (2 * KBASE_IPA_NR_BYTES_PER_BLOCK)
+#define SC0_BASE_ONE_MEMSYS (3 * KBASE_IPA_NR_BYTES_PER_BLOCK)
+#define SC0_BASE_TWO_MEMSYS (4 * KBASE_IPA_NR_BYTES_PER_BLOCK)
+
+/* JM counter block offsets */
+#define JM_GPU_ACTIVE (KBASE_IPA_NR_BYTES_PER_CNT *  6)
+
+/* Tiler counter block offsets */
+#define TILER_ACTIVE (KBASE_IPA_NR_BYTES_PER_CNT * 45)
+
+/* MEMSYS counter block offsets */
+#define MEMSYS_L2_ANY_LOOKUP (KBASE_IPA_NR_BYTES_PER_CNT * 25)
+
+/* SC counter block offsets */
+#define SC_FRAG_ACTIVE      (KBASE_IPA_NR_BYTES_PER_CNT *  4)
+#define SC_EXEC_CORE_ACTIVE (KBASE_IPA_NR_BYTES_PER_CNT * 26)
+#define SC_EXEC_INSTR_COUNT (KBASE_IPA_NR_BYTES_PER_CNT * 28)
+#define SC_TEX_COORD_ISSUE  (KBASE_IPA_NR_BYTES_PER_CNT * 40)
+#define SC_VARY_SLOT_32     (KBASE_IPA_NR_BYTES_PER_CNT * 50)
+#define SC_VARY_SLOT_16     (KBASE_IPA_NR_BYTES_PER_CNT * 51)
+#define SC_BEATS_RD_LSC     (KBASE_IPA_NR_BYTES_PER_CNT * 56)
+#define SC_BEATS_WR_LSC     (KBASE_IPA_NR_BYTES_PER_CNT * 61)
+#define SC_BEATS_WR_TIB     (KBASE_IPA_NR_BYTES_PER_CNT * 62)
+
+/** Maximum number of cores for which a single Memory System block of performance counters is present. */
+#define KBASE_G71_SINGLE_MEMSYS_MAX_NUM_CORES ((u8)4)
+
+
+/**
+ * get_jm_counter() - get performance counter offset inside the Job Manager block
+ * @model_data:            pointer to GPU model data.
+ * @counter_block_offset:  offset in bytes of the performance counter inside the Job Manager block.
+ *
+ * Return: Block offset in bytes of the required performance counter.
+ */
+static u32 kbase_g71_power_model_get_jm_counter(struct kbase_ipa_model_vinstr_data *model_data,
+                                                u32 counter_block_offset)
+{
+	return JM_BASE + counter_block_offset;
+}
 
+/**
+ * get_memsys_counter() - get peformance counter offset inside the Memory System block
+ * @model_data:            pointer to GPU model data.
+ * @counter_block_offset:  offset in bytes of the performance counter inside the (first) Memory System block.
+ *
+ * Return: Block offset in bytes of the required performance counter.
+ */
+static u32 kbase_g71_power_model_get_memsys_counter(struct kbase_ipa_model_vinstr_data *model_data,
+                                                    u32 counter_block_offset)
+{
+	/* The base address of Memory System performance counters is always the same, although their number
+	 * may vary based on the number of cores. For the moment it's ok to return a constant.
+	 */
+	return MEMSYS_BASE + counter_block_offset;
+}
+
+/**
+ * get_sc_counter() - get performance counter offset inside the Shader Cores block
+ * @model_data:            pointer to GPU model data.
+ * @counter_block_offset:  offset in bytes of the performance counter inside the (first) Shader Cores block.
+ *
+ * Return: Block offset in bytes of the required performance counter.
+ */
+static u32 kbase_g71_power_model_get_sc_counter(struct kbase_ipa_model_vinstr_data *model_data,
+                                                u32 counter_block_offset)
+{
+	const u32 sc_base = model_data->kbdev->gpu_props.num_cores <= KBASE_G71_SINGLE_MEMSYS_MAX_NUM_CORES ?
+	                    SC0_BASE_ONE_MEMSYS :
+	                    SC0_BASE_TWO_MEMSYS;
+
+	return sc_base + counter_block_offset;
+}
+
+/**
+ * memsys_single_counter() - calculate energy for a single Memory System performance counter.
+ * @model_data:            pointer to GPU model data.
+ * @coeff:                 default value of coefficient for IPA group.
+ * @counter_block_offset:  offset in bytes of the counter inside the block it belongs to.
+ *
+ * Return: Energy estimation for a single Memory System performance counter.
+ */
+static s64 kbase_g71_memsys_single_counter(
+    struct kbase_ipa_model_vinstr_data *model_data,
+    s32 coeff,
+    u32 counter_block_offset)
+{
+	return kbase_ipa_single_counter(model_data, coeff,
+	                                kbase_g71_power_model_get_memsys_counter(model_data, counter_block_offset));
+}
+
+/**
+ * sum_all_shader_cores() - calculate energy for a Shader Cores performance counter for all cores.
+ * @model_data:            pointer to GPU model data.
+ * @coeff:                 default value of coefficient for IPA group.
+ * @counter_block_offset:  offset in bytes of the counter inside the block it belongs to.
+ *
+ * Return: Energy estimation for a Shader Cores performance counter for all cores.
+ */
+static s64 kbase_g71_sum_all_shader_cores(
+    struct kbase_ipa_model_vinstr_data *model_data,
+    s32 coeff,
+    u32 counter_block_offset)
+{
+	return kbase_ipa_sum_all_shader_cores(model_data, coeff,
+	                                      kbase_g71_power_model_get_sc_counter(model_data, counter_block_offset));
+}
+
+/**
+ * jm_single_counter() - calculate energy for a single Job Manager performance counter.
+ * @model_data:            pointer to GPU model data.
+ * @coeff:                 default value of coefficient for IPA group.
+ * @counter_block_offset:  offset in bytes of the counter inside the block it belongs to.
+ *
+ * Return: Energy estimation for a single Job Manager performance counter.
+ */
+static s64 kbase_g71_jm_single_counter(
+    struct kbase_ipa_model_vinstr_data *model_data,
+    s32 coeff,
+    u32 counter_block_offset)
+{
+	return kbase_ipa_single_counter(model_data, coeff,
+	                                kbase_g71_power_model_get_jm_counter(model_data, counter_block_offset));
+}
+
+/** Table of IPA group definitions.
+ *
+ * For each IPA group, this table defines a function to access the given performance block counter (or counters,
+ * if the operation needs to be iterated on multiple blocks) and calculate energy estimation.
+ */
 static const struct kbase_ipa_group ipa_groups_def[] = {
 	{
 		.name = "l2_access",
 		.default_value = 526300,
-		.op = kbase_ipa_single_counter,
-		.counter = L2_ANY_LOOKUP,
+		.op = kbase_g71_memsys_single_counter,
+		.counter_block_offset = MEMSYS_L2_ANY_LOOKUP,
 	},
 	{
 		.name = "exec_instr_count",
 		.default_value = 301100,
-		.op = kbase_ipa_sum_all_shader_cores,
-		.counter = EXEC_INSTR_COUNT,
+		.op = kbase_g71_sum_all_shader_cores,
+		.counter_block_offset = SC_EXEC_INSTR_COUNT,
 	},
 	{
 		.name = "tex_issue",
 		.default_value = 197400,
-		.op = kbase_ipa_sum_all_shader_cores,
-		.counter = TEX_COORD_ISSUE,
+		.op = kbase_g71_sum_all_shader_cores,
+		.counter_block_offset = SC_TEX_COORD_ISSUE,
 	},
 	{
 		.name = "tile_wb",
 		.default_value = -156400,
-		.op = kbase_ipa_sum_all_shader_cores,
-		.counter = BEATS_WR_TIB,
+		.op = kbase_g71_sum_all_shader_cores,
+		.counter_block_offset = SC_BEATS_WR_TIB,
 	},
 	{
 		.name = "gpu_active",
 		.default_value = 115800,
-		.op = kbase_ipa_single_counter,
-		.counter = GPU_ACTIVE,
+		.op = kbase_g71_jm_single_counter,
+		.counter_block_offset = JM_GPU_ACTIVE,
 	},
 };
 
@@ -99,7 +219,7 @@ static int kbase_g71_power_model_init(struct kbase_ipa_model *model)
 			goto exit;
 	}
 
-	model_data->scaling_factor = 15000;
+	model_data->scaling_factor = 5;
 	err = kbase_ipa_model_add_param_s32(model, "scale",
 					    &model_data->scaling_factor,
 					    1, false);
diff --git a/drivers/gpu/arm/bifrost/mali_base_hwconfig_features.h b/drivers/gpu/arm/bifrost/mali_base_hwconfig_features.h
index 219586d4d2da..e0eebd872eb9 100644
--- a/drivers/gpu/arm/bifrost/mali_base_hwconfig_features.h
+++ b/drivers/gpu/arm/bifrost/mali_base_hwconfig_features.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /* AUTOMATICALLY GENERATED FILE. If you want to amend the issues/features,
  * please update base/tools/hwconfig_generator/hwc_{issues,features}.py
  * For more information see base/tools/hwconfig_generator/README
@@ -53,6 +58,8 @@ enum base_hw_feature {
 	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
 	BASE_HW_FEATURE_AARCH64_MMU,
 	BASE_HW_FEATURE_TLS_HASHING,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
+	BASE_HW_FEATURE_3BIT_EXT_RW_L2_MMU_CONFIG,
 	BASE_HW_FEATURE_END
 };
 
@@ -63,6 +70,7 @@ static const enum base_hw_feature base_hw_features_generic[] = {
 static const enum base_hw_feature base_hw_features_t60x[] = {
 	BASE_HW_FEATURE_LD_ST_LEA_TEX,
 	BASE_HW_FEATURE_LINEAR_FILTER_FLOAT,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_V4,
 	BASE_HW_FEATURE_END
 };
@@ -71,6 +79,7 @@ static const enum base_hw_feature base_hw_features_t62x[] = {
 	BASE_HW_FEATURE_LD_ST_LEA_TEX,
 	BASE_HW_FEATURE_LINEAR_FILTER_FLOAT,
 	BASE_HW_FEATURE_ATTR_AUTO_TYPE_INFERRAL,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_V4,
 	BASE_HW_FEATURE_END
 };
@@ -82,6 +91,7 @@ static const enum base_hw_feature base_hw_features_t72x[] = {
 	BASE_HW_FEATURE_INTERPIPE_REG_ALIASING,
 	BASE_HW_FEATURE_OPTIMIZED_COVERAGE_MASK,
 	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_WORKGROUP_ROUND_MULTIPLE_OF_4,
 	BASE_HW_FEATURE_WARPING,
 	BASE_HW_FEATURE_V4,
@@ -103,6 +113,7 @@ static const enum base_hw_feature base_hw_features_t76x[] = {
 	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
 	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
 	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_END
 };
 
@@ -123,6 +134,7 @@ static const enum base_hw_feature base_hw_features_tFxx[] = {
 	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
 	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
 	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_END
 };
 
@@ -145,6 +157,7 @@ static const enum base_hw_feature base_hw_features_t83x[] = {
 	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
 	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
 	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_END
 };
 
@@ -167,6 +180,7 @@ static const enum base_hw_feature base_hw_features_t82x[] = {
 	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
 	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
 	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_END
 };
 
@@ -189,6 +203,7 @@ static const enum base_hw_feature base_hw_features_tMIx[] = {
 	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
 	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
 	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_FLUSH_REDUCTION,
 	BASE_HW_FEATURE_PROTECTED_MODE,
 	BASE_HW_FEATURE_COHERENCY_REG,
@@ -214,6 +229,7 @@ static const enum base_hw_feature base_hw_features_tHEx[] = {
 	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
 	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
 	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_FLUSH_REDUCTION,
 	BASE_HW_FEATURE_PROTECTED_MODE,
 	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
@@ -241,6 +257,7 @@ static const enum base_hw_feature base_hw_features_tSIx[] = {
 	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
 	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
 	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_FLUSH_REDUCTION,
 	BASE_HW_FEATURE_PROTECTED_MODE,
 	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
@@ -268,6 +285,7 @@ static const enum base_hw_feature base_hw_features_tDVx[] = {
 	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
 	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
 	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
 	BASE_HW_FEATURE_FLUSH_REDUCTION,
 	BASE_HW_FEATURE_PROTECTED_MODE,
 	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
@@ -275,8 +293,175 @@ static const enum base_hw_feature base_hw_features_tDVx[] = {
 	BASE_HW_FEATURE_END
 };
 
+static const enum base_hw_feature base_hw_features_tNOx[] = {
+	BASE_HW_FEATURE_JOBCHAIN_DISAMBIGUATION,
+	BASE_HW_FEATURE_PWRON_DURING_PWROFF_TRANS,
+	BASE_HW_FEATURE_XAFFINITY,
+	BASE_HW_FEATURE_WARPING,
+	BASE_HW_FEATURE_INTERPIPE_REG_ALIASING,
+	BASE_HW_FEATURE_32_BIT_UNIFORM_ADDRESS,
+	BASE_HW_FEATURE_ATTR_AUTO_TYPE_INFERRAL,
+	BASE_HW_FEATURE_BRNDOUT_CC,
+	BASE_HW_FEATURE_BRNDOUT_KILL,
+	BASE_HW_FEATURE_LD_ST_LEA_TEX,
+	BASE_HW_FEATURE_LD_ST_TILEBUFFER,
+	BASE_HW_FEATURE_LINEAR_FILTER_FLOAT,
+	BASE_HW_FEATURE_MRT,
+	BASE_HW_FEATURE_MSAA_16X,
+	BASE_HW_FEATURE_NEXT_INSTRUCTION_TYPE,
+	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
+	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
+	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
+	BASE_HW_FEATURE_FLUSH_REDUCTION,
+	BASE_HW_FEATURE_PROTECTED_MODE,
+	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
+	BASE_HW_FEATURE_COHERENCY_REG,
+	BASE_HW_FEATURE_AARCH64_MMU,
+	BASE_HW_FEATURE_TLS_HASHING,
+	BASE_HW_FEATURE_3BIT_EXT_RW_L2_MMU_CONFIG,
+	BASE_HW_FEATURE_END
+};
 
+static const enum base_hw_feature base_hw_features_tGOx[] = {
+	BASE_HW_FEATURE_JOBCHAIN_DISAMBIGUATION,
+	BASE_HW_FEATURE_PWRON_DURING_PWROFF_TRANS,
+	BASE_HW_FEATURE_XAFFINITY,
+	BASE_HW_FEATURE_WARPING,
+	BASE_HW_FEATURE_INTERPIPE_REG_ALIASING,
+	BASE_HW_FEATURE_32_BIT_UNIFORM_ADDRESS,
+	BASE_HW_FEATURE_ATTR_AUTO_TYPE_INFERRAL,
+	BASE_HW_FEATURE_BRNDOUT_CC,
+	BASE_HW_FEATURE_BRNDOUT_KILL,
+	BASE_HW_FEATURE_LD_ST_LEA_TEX,
+	BASE_HW_FEATURE_LD_ST_TILEBUFFER,
+	BASE_HW_FEATURE_LINEAR_FILTER_FLOAT,
+	BASE_HW_FEATURE_MRT,
+	BASE_HW_FEATURE_MSAA_16X,
+	BASE_HW_FEATURE_NEXT_INSTRUCTION_TYPE,
+	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
+	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
+	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
+	BASE_HW_FEATURE_FLUSH_REDUCTION,
+	BASE_HW_FEATURE_PROTECTED_MODE,
+	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
+	BASE_HW_FEATURE_COHERENCY_REG,
+	BASE_HW_FEATURE_AARCH64_MMU,
+	BASE_HW_FEATURE_TLS_HASHING,
+	BASE_HW_FEATURE_3BIT_EXT_RW_L2_MMU_CONFIG,
+	BASE_HW_FEATURE_END
+};
 
+static const enum base_hw_feature base_hw_features_tKAx[] = {
+	BASE_HW_FEATURE_JOBCHAIN_DISAMBIGUATION,
+	BASE_HW_FEATURE_PWRON_DURING_PWROFF_TRANS,
+	BASE_HW_FEATURE_XAFFINITY,
+	BASE_HW_FEATURE_WARPING,
+	BASE_HW_FEATURE_INTERPIPE_REG_ALIASING,
+	BASE_HW_FEATURE_32_BIT_UNIFORM_ADDRESS,
+	BASE_HW_FEATURE_ATTR_AUTO_TYPE_INFERRAL,
+	BASE_HW_FEATURE_BRNDOUT_CC,
+	BASE_HW_FEATURE_BRNDOUT_KILL,
+	BASE_HW_FEATURE_LD_ST_LEA_TEX,
+	BASE_HW_FEATURE_LD_ST_TILEBUFFER,
+	BASE_HW_FEATURE_LINEAR_FILTER_FLOAT,
+	BASE_HW_FEATURE_MRT,
+	BASE_HW_FEATURE_MSAA_16X,
+	BASE_HW_FEATURE_NEXT_INSTRUCTION_TYPE,
+	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
+	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
+	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_FLUSH_REDUCTION,
+	BASE_HW_FEATURE_PROTECTED_MODE,
+	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
+	BASE_HW_FEATURE_COHERENCY_REG,
+	BASE_HW_FEATURE_AARCH64_MMU,
+	BASE_HW_FEATURE_END
+};
+
+static const enum base_hw_feature base_hw_features_tTRx[] = {
+	BASE_HW_FEATURE_JOBCHAIN_DISAMBIGUATION,
+	BASE_HW_FEATURE_PWRON_DURING_PWROFF_TRANS,
+	BASE_HW_FEATURE_XAFFINITY,
+	BASE_HW_FEATURE_WARPING,
+	BASE_HW_FEATURE_INTERPIPE_REG_ALIASING,
+	BASE_HW_FEATURE_32_BIT_UNIFORM_ADDRESS,
+	BASE_HW_FEATURE_ATTR_AUTO_TYPE_INFERRAL,
+	BASE_HW_FEATURE_BRNDOUT_CC,
+	BASE_HW_FEATURE_BRNDOUT_KILL,
+	BASE_HW_FEATURE_LD_ST_LEA_TEX,
+	BASE_HW_FEATURE_LD_ST_TILEBUFFER,
+	BASE_HW_FEATURE_LINEAR_FILTER_FLOAT,
+	BASE_HW_FEATURE_MRT,
+	BASE_HW_FEATURE_MSAA_16X,
+	BASE_HW_FEATURE_NEXT_INSTRUCTION_TYPE,
+	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
+	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
+	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_FLUSH_REDUCTION,
+	BASE_HW_FEATURE_PROTECTED_MODE,
+	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
+	BASE_HW_FEATURE_COHERENCY_REG,
+	BASE_HW_FEATURE_AARCH64_MMU,
+	BASE_HW_FEATURE_END
+};
 
+static const enum base_hw_feature base_hw_features_tBOx[] = {
+	BASE_HW_FEATURE_JOBCHAIN_DISAMBIGUATION,
+	BASE_HW_FEATURE_PWRON_DURING_PWROFF_TRANS,
+	BASE_HW_FEATURE_XAFFINITY,
+	BASE_HW_FEATURE_WARPING,
+	BASE_HW_FEATURE_INTERPIPE_REG_ALIASING,
+	BASE_HW_FEATURE_32_BIT_UNIFORM_ADDRESS,
+	BASE_HW_FEATURE_ATTR_AUTO_TYPE_INFERRAL,
+	BASE_HW_FEATURE_BRNDOUT_CC,
+	BASE_HW_FEATURE_BRNDOUT_KILL,
+	BASE_HW_FEATURE_LD_ST_LEA_TEX,
+	BASE_HW_FEATURE_LD_ST_TILEBUFFER,
+	BASE_HW_FEATURE_LINEAR_FILTER_FLOAT,
+	BASE_HW_FEATURE_MRT,
+	BASE_HW_FEATURE_MSAA_16X,
+	BASE_HW_FEATURE_NEXT_INSTRUCTION_TYPE,
+	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
+	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
+	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_FLUSH_REDUCTION,
+	BASE_HW_FEATURE_PROTECTED_MODE,
+	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
+	BASE_HW_FEATURE_COHERENCY_REG,
+	BASE_HW_FEATURE_AARCH64_MMU,
+	BASE_HW_FEATURE_END
+};
+
+static const enum base_hw_feature base_hw_features_tEGx[] = {
+	BASE_HW_FEATURE_JOBCHAIN_DISAMBIGUATION,
+	BASE_HW_FEATURE_PWRON_DURING_PWROFF_TRANS,
+	BASE_HW_FEATURE_XAFFINITY,
+	BASE_HW_FEATURE_WARPING,
+	BASE_HW_FEATURE_INTERPIPE_REG_ALIASING,
+	BASE_HW_FEATURE_32_BIT_UNIFORM_ADDRESS,
+	BASE_HW_FEATURE_ATTR_AUTO_TYPE_INFERRAL,
+	BASE_HW_FEATURE_BRNDOUT_CC,
+	BASE_HW_FEATURE_BRNDOUT_KILL,
+	BASE_HW_FEATURE_LD_ST_LEA_TEX,
+	BASE_HW_FEATURE_LD_ST_TILEBUFFER,
+	BASE_HW_FEATURE_LINEAR_FILTER_FLOAT,
+	BASE_HW_FEATURE_MRT,
+	BASE_HW_FEATURE_MSAA_16X,
+	BASE_HW_FEATURE_NEXT_INSTRUCTION_TYPE,
+	BASE_HW_FEATURE_OUT_OF_ORDER_EXEC,
+	BASE_HW_FEATURE_T7XX_PAIRING_RULES,
+	BASE_HW_FEATURE_TEST4_DATUM_MODE,
+	BASE_HW_FEATURE_THREAD_GROUP_SPLIT,
+	BASE_HW_FEATURE_FLUSH_REDUCTION,
+	BASE_HW_FEATURE_PROTECTED_MODE,
+	BASE_HW_FEATURE_PROTECTED_DEBUG_MODE,
+	BASE_HW_FEATURE_COHERENCY_REG,
+	BASE_HW_FEATURE_AARCH64_MMU,
+	BASE_HW_FEATURE_TLS_HASHING,
+	BASE_HW_FEATURE_3BIT_EXT_RW_L2_MMU_CONFIG,
+	BASE_HW_FEATURE_END
+};
 
 #endif /* _BASE_HWCONFIG_FEATURES_H_ */
diff --git a/drivers/gpu/arm/bifrost/mali_base_hwconfig_issues.h b/drivers/gpu/arm/bifrost/mali_base_hwconfig_issues.h
index 1c5ee496ac85..7b70e7a82b6f 100644
--- a/drivers/gpu/arm/bifrost/mali_base_hwconfig_issues.h
+++ b/drivers/gpu/arm/bifrost/mali_base_hwconfig_issues.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /* AUTOMATICALLY GENERATED FILE. If you want to amend the issues/features,
  * please update base/tools/hwconfig_generator/hwc_{issues,features}.py
  * For more information see base/tools/hwconfig_generator/README
@@ -1101,7 +1106,6 @@ static const enum base_hw_issue base_hw_issues_model_tSIx[] = {
 
 static const enum base_hw_issue base_hw_issues_tDVx_r0p0[] = {
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_11054,
 	BASE_HW_ISSUE_TMIX_8133,
 	BASE_HW_ISSUE_TSIX_1116,
 	BASE_HW_ISSUE_END
@@ -1115,12 +1119,94 @@ static const enum base_hw_issue base_hw_issues_model_tDVx[] = {
 	BASE_HW_ISSUE_END
 };
 
+static const enum base_hw_issue base_hw_issues_tNOx_r0p0[] = {
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
 
+static const enum base_hw_issue base_hw_issues_model_tNOx[] = {
+	BASE_HW_ISSUE_5736,
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
 
+static const enum base_hw_issue base_hw_issues_tGOx_r0p0[] = {
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
 
+static const enum base_hw_issue base_hw_issues_model_tGOx[] = {
+	BASE_HW_ISSUE_5736,
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
 
+static const enum base_hw_issue base_hw_issues_tKAx_r0p0[] = {
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
 
+static const enum base_hw_issue base_hw_issues_model_tKAx[] = {
+	BASE_HW_ISSUE_5736,
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
 
+static const enum base_hw_issue base_hw_issues_tTRx_r0p0[] = {
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
 
+static const enum base_hw_issue base_hw_issues_model_tTRx[] = {
+	BASE_HW_ISSUE_5736,
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
+
+static const enum base_hw_issue base_hw_issues_tBOx_r0p0[] = {
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
+
+static const enum base_hw_issue base_hw_issues_model_tBOx[] = {
+	BASE_HW_ISSUE_5736,
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
+
+static const enum base_hw_issue base_hw_issues_tEGx_r0p0[] = {
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
+
+static const enum base_hw_issue base_hw_issues_model_tEGx[] = {
+	BASE_HW_ISSUE_5736,
+	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_TMIX_8133,
+	BASE_HW_ISSUE_TSIX_1116,
+	BASE_HW_ISSUE_END
+};
 
 #endif /* _BASE_HWCONFIG_ISSUES_H_ */
diff --git a/drivers/gpu/arm/bifrost/mali_base_kernel.h b/drivers/gpu/arm/bifrost/mali_base_kernel.h
index 6f5c68e288cd..e6b568fba520 100644
--- a/drivers/gpu/arm/bifrost/mali_base_kernel.h
+++ b/drivers/gpu/arm/bifrost/mali_base_kernel.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Base structures shared with the kernel.
  */
@@ -24,12 +29,6 @@
 #ifndef _BASE_KERNEL_H_
 #define _BASE_KERNEL_H_
 
-/* Support UK10_2 IOCTLS */
-#define BASE_LEGACY_UK10_2_SUPPORT 1
-
-/* Support UK10_4 IOCTLS */
-#define BASE_LEGACY_UK10_4_SUPPORT 1
-
 typedef struct base_mem_handle {
 	struct {
 		u64 handle;
@@ -52,7 +51,7 @@ typedef struct base_mem_handle {
 #define BASE_JD_SOFT_EVENT_SET             ((unsigned char)1)
 #define BASE_JD_SOFT_EVENT_RESET           ((unsigned char)0)
 
-#define BASE_GPU_NUM_TEXTURE_FEATURES_REGISTERS 3
+#define BASE_GPU_NUM_TEXTURE_FEATURES_REGISTERS 4
 
 #define BASE_MAX_COHERENT_GROUPS 16
 
@@ -64,12 +63,14 @@ typedef struct base_mem_handle {
 #error assert macro not defined!
 #endif
 
-#if defined PAGE_MASK
+#if defined(PAGE_MASK) && defined(PAGE_SHIFT)
+#define LOCAL_PAGE_SHIFT PAGE_SHIFT
 #define LOCAL_PAGE_LSB ~PAGE_MASK
 #else
 #include <osu/mali_osu.h>
 
 #if defined OSU_CONFIG_CPU_PAGE_SIZE_LOG2
+#define LOCAL_PAGE_SHIFT OSU_CONFIG_CPU_PAGE_SIZE_LOG2
 #define LOCAL_PAGE_LSB ((1ul << OSU_CONFIG_CPU_PAGE_SIZE_LOG2) - 1)
 #else
 #error Failed to find page size
@@ -136,6 +137,10 @@ typedef u32 base_mem_alloc_flags;
 	 * RESERVED: (1U << 7)
 	 * RESERVED: (1U << 8)
 	 */
+#define BASE_MEM_RESERVED_BIT_5 ((base_mem_alloc_flags)1 << 5)
+#define BASE_MEM_RESERVED_BIT_6 ((base_mem_alloc_flags)1 << 6)
+#define BASE_MEM_RESERVED_BIT_7 ((base_mem_alloc_flags)1 << 7)
+#define BASE_MEM_RESERVED_BIT_8 ((base_mem_alloc_flags)1 << 8)
 
 /* Grow backing store on GPU Page Fault
  */
@@ -185,14 +190,21 @@ typedef u32 base_mem_alloc_flags;
  * Bit 19 is reserved.
  *
  * Do not remove, use the next unreserved bit for new flags
- **/
+ */
 #define BASE_MEM_RESERVED_BIT_19 ((base_mem_alloc_flags)1 << 19)
 
+/**
+ * Memory starting from the end of the initial commit is aligned to 'extent'
+ * pages, where 'extent' must be a power of 2 and no more than
+ * BASE_MEM_TILER_ALIGN_TOP_EXTENT_MAX_PAGES
+ */
+#define BASE_MEM_TILER_ALIGN_TOP ((base_mem_alloc_flags)1 << 20)
+
 /* Number of bits used as flags for base memory management
  *
  * Must be kept in sync with the base_mem_alloc_flags flags
  */
-#define BASE_MEM_FLAGS_NR_BITS 20
+#define BASE_MEM_FLAGS_NR_BITS 21
 
 /* A mask for all output bits, excluding IN/OUT bits.
  */
@@ -210,6 +222,22 @@ typedef u32 base_mem_alloc_flags;
 	(BASE_MEM_DONT_NEED | BASE_MEM_COHERENT_SYSTEM | \
 	 BASE_MEM_COHERENT_LOCAL)
 
+
+/* A mask of all currently reserved flags
+ */
+#define BASE_MEM_FLAGS_RESERVED \
+	(BASE_MEM_RESERVED_BIT_5 | BASE_MEM_RESERVED_BIT_6 | \
+		BASE_MEM_RESERVED_BIT_7 | BASE_MEM_RESERVED_BIT_8 | \
+		BASE_MEM_RESERVED_BIT_19)
+
+/* A mask of all the flags that can be returned via the base_mem_get_flags()
+ * interface.
+ */
+#define BASE_MEM_FLAGS_QUERYABLE \
+	(BASE_MEM_FLAGS_INPUT_MASK & ~(BASE_MEM_SAME_VA | \
+		BASE_MEM_COHERENT_SYSTEM_REQUIRED | BASE_MEM_DONT_NEED | \
+		BASE_MEM_IMPORT_SHARED | BASE_MEM_FLAGS_RESERVED))
+
 /**
  * enum base_mem_import_type - Memory types supported by @a base_mem_import
  *
@@ -283,6 +311,14 @@ struct base_mem_import_user_buffer {
 /* Mask to detect 4GB boundary alignment */
 #define BASE_MEM_MASK_4GB  0xfffff000UL
 
+/**
+ * Limit on the 'extent' parameter for an allocation with the
+ * BASE_MEM_TILER_ALIGN_TOP flag set
+ *
+ * This is the same as the maximum limit for a Buffer Descriptor's chunk size
+ */
+#define BASE_MEM_TILER_ALIGN_TOP_EXTENT_MAX_PAGES \
+		((2ull * 1024ull * 1024ull) >> (LOCAL_PAGE_SHIFT))
 
 /* Bit mask of cookies used for for memory allocation setup */
 #define KBASE_COOKIE_MASK  ~1UL /* bit 0 is reserved */
@@ -510,7 +546,8 @@ typedef u32 base_jd_core_req;
  * The first pre_dep object must be configured for the external resouces to use,
  * the second pre_dep object can be used to create other dependencies.
  *
- * This bit may not be used in combination with BASE_JD_REQ_EVENT_COALESCE.
+ * This bit may not be used in combination with BASE_JD_REQ_EVENT_COALESCE and
+ * BASE_JD_REQ_SOFT_EVENT_WAIT.
  */
 #define BASE_JD_REQ_EXTERNAL_RESOURCES   ((base_jd_core_req)1 << 8)
 
@@ -1264,9 +1301,9 @@ typedef struct base_dump_cpu_gpu_counters {
  * Architecture, but is <b>necessary for OpenCL's clGetDeviceInfo() function</b>.
  *
  * The GPU properties are obtained by a call to
- * _mali_base_get_gpu_props(). This simply returns a pointer to a const
+ * base_get_gpu_props(). This simply returns a pointer to a const
  * base_gpu_props structure. It is constant for the life of a base
- * context. Multiple calls to _mali_base_get_gpu_props() to a base context
+ * context. Multiple calls to base_get_gpu_props() to a base context
  * return the same pointer to a constant structure. This avoids cache pollution
  * of the common data.
  *
@@ -1275,96 +1312,6 @@ typedef struct base_dump_cpu_gpu_counters {
  * base_context.
  *
  *
- * @section sec_base_user_api_gpuprops_config Platform Config Compile-time Properties
- *
- * The Platform Config File sets up gpu properties that are specific to a
- * certain platform. Properties that are 'Implementation Defined' in the
- * Midgard Architecture spec are placed here.
- *
- * @note Reference configurations are provided for Midgard Implementations, such as
- * the Mali-T600 family. The customer need not repeat this information, and can select one of
- * these reference configurations. For example, VA_BITS, PA_BITS and the
- * maximum number of samples per pixel might vary between Midgard Implementations, but
- * \b not for platforms using the Mali-T604. This information is placed in
- * the reference configuration files.
- *
- * The System Integrator creates the following structure:
- * - platform_XYZ
- * - platform_XYZ/plat
- * - platform_XYZ/plat/plat_config.h
- *
- * They then edit plat_config.h, using the example plat_config.h files as a
- * guide.
- *
- * At the very least, the customer must set @ref CONFIG_GPU_CORE_TYPE, and will
- * receive a helpful \#error message if they do not do this correctly. This
- * selects the Reference Configuration for the Midgard Implementation. The rationale
- * behind this decision (against asking the customer to write \#include
- * <gpus/mali_t600.h> in their plat_config.h) is as follows:
- * - This mechanism 'looks' like a regular config file (such as Linux's
- * .config)
- * - It is difficult to get wrong in a way that will produce strange build
- * errors:
- *  - They need not know where the mali_t600.h, other_midg_gpu.h etc. files are stored - and
- *  so they won't accidentally pick another file with 'mali_t600' in its name
- *  - When the build doesn't work, the System Integrator may think the DDK is
- *  doesn't work, and attempt to fix it themselves:
- *   - For the @ref CONFIG_GPU_CORE_TYPE mechanism, the only way to get past the
- *   error is to set @ref CONFIG_GPU_CORE_TYPE, and this is what the \#error tells
- *   you.
- *   - For a \#include mechanism, checks must still be made elsewhere, which the
- *   System Integrator may try working around by setting \#defines (such as
- *   VA_BITS) themselves in their plat_config.h. In the  worst case, they may
- *   set the prevention-mechanism \#define of
- *   "A_CORRECT_MIDGARD_CORE_WAS_CHOSEN".
- *   - In this case, they would believe they are on the right track, because
- *   the build progresses with their fix, but with errors elsewhere.
- *
- * However, there is nothing to prevent the customer using \#include to organize
- * their own configurations files hierarchically.
- *
- * The mechanism for the header file processing is as follows:
- *
- * @dot
-   digraph plat_config_mechanism {
-	   rankdir=BT
-	   size="6,6"
-
-       "mali_base.h";
-	   "gpu/mali_gpu.h";
-
-	   node [ shape=box ];
-	   {
-	       rank = same; ordering = out;
-
-		   "gpu/mali_gpu_props.h";
-		   "base/midg_gpus/mali_t600.h";
-		   "base/midg_gpus/other_midg_gpu.h";
-	   }
-	   { rank = same; "plat/plat_config.h"; }
-	   {
-	       rank = same;
-		   "gpu/mali_gpu.h" [ shape=box ];
-		   gpu_chooser [ label="" style="invisible" width=0 height=0 fixedsize=true ];
-		   select_gpu [ label="Mali-T600 | Other\n(select_gpu.h)" shape=polygon,sides=4,distortion=0.25 width=3.3 height=0.99 fixedsize=true ] ;
-	   }
-	   node [ shape=box ];
-	   { rank = same; "plat/plat_config.h"; }
-	   { rank = same; "mali_base.h"; }
-
-	   "mali_base.h" -> "gpu/mali_gpu.h" -> "gpu/mali_gpu_props.h";
-	   "mali_base.h" -> "plat/plat_config.h" ;
-	   "mali_base.h" -> select_gpu ;
-
-	   "plat/plat_config.h" -> gpu_chooser [style="dotted,bold" dir=none weight=4] ;
-	   gpu_chooser -> select_gpu [style="dotted,bold"] ;
-
-	   select_gpu -> "base/midg_gpus/mali_t600.h" ;
-	   select_gpu -> "base/midg_gpus/other_midg_gpu.h" ;
-   }
-   @enddot
- *
- *
  * @section sec_base_user_api_gpuprops_kernel Kernel Operation
  *
  * During Base Context Create time, user-side makes a single kernel call:
@@ -1403,7 +1350,7 @@ typedef struct base_dump_cpu_gpu_counters {
  * @{
  */
 
-#define BASE_GPU_NUM_TEXTURE_FEATURES_REGISTERS 3
+#define BASE_GPU_NUM_TEXTURE_FEATURES_REGISTERS 4
 
 #define BASE_MAX_COHERENT_GROUPS 16
 
@@ -1435,23 +1382,10 @@ struct mali_base_gpu_core_props {
 
 	u16 padding;
 
-	/**
-	 * This property is deprecated since it has not contained the real current
-	 * value of GPU clock speed. It is kept here only for backwards compatibility.
-	 * For the new ioctl interface, it is ignored and is treated as a padding
-	 * to keep the structure of the same size and retain the placement of its
-	 * members.
-	 */
-	u32 gpu_speed_mhz;
-
-	/**
-	 * @usecase GPU clock max/min speed is required for computing best/worst case
-	 * in tasks as job scheduling ant irq_throttling. (It is not specified in the
-	 *  Midgard Architecture).
-	 * Also, GPU clock max speed is used for OpenCL's clGetDeviceInfo() function.
+	/* The maximum GPU frequency. Reported to applications by
+	 * clGetDeviceInfo()
 	 */
 	u32 gpu_freq_khz_max;
-	u32 gpu_freq_khz_min;
 
 	/**
 	 * Size of the shader program counter, in bits.
@@ -1599,7 +1533,7 @@ struct gpu_raw_gpu_props {
 	u32 js_present;
 	u32 js_features[GPU_MAX_JOB_SLOTS];
 	u32 tiler_features;
-	u32 texture_features[3];
+	u32 texture_features[BASE_GPU_NUM_TEXTURE_FEATURES_REGISTERS];
 
 	u32 gpu_id;
 
@@ -1616,7 +1550,7 @@ struct gpu_raw_gpu_props {
 };
 
 /**
- * Return structure for _mali_base_get_gpu_props().
+ * Return structure for base_get_gpu_props().
  *
  * NOTE: the raw_props member in this data structure contains the register
  * values from which the value of the other members are derived. The derived
@@ -1624,7 +1558,7 @@ struct gpu_raw_gpu_props {
  * of the layout of the registers.
  *
  */
-typedef struct mali_base_gpu_props {
+typedef struct base_gpu_props {
 	struct mali_base_gpu_core_props core_props;
 	struct mali_base_gpu_l2_cache_props l2_props;
 	u64 unused_1; /* keep for backwards compatibility */
@@ -1766,20 +1700,6 @@ typedef struct base_jd_replay_payload {
 	base_jd_core_req fragment_core_req;
 } base_jd_replay_payload;
 
-#ifdef BASE_LEGACY_UK10_2_SUPPORT
-typedef struct base_jd_replay_payload_uk10_2 {
-	u64 tiler_jc_list;
-	u64 fragment_jc;
-	u64 tiler_heap_free;
-	u16 fragment_hierarchy_mask;
-	u16 tiler_hierarchy_mask;
-	u32 hierarchy_default_weight;
-	u16 tiler_core_req;
-	u16 fragment_core_req;
-	u8 padding[4];
-} base_jd_replay_payload_uk10_2;
-#endif /* BASE_LEGACY_UK10_2_SUPPORT */
-
 /**
  * @brief An entry in the linked list of job chains to be replayed. This must
  *        be in GPU memory.
diff --git a/drivers/gpu/arm/bifrost/mali_base_mem_priv.h b/drivers/gpu/arm/bifrost/mali_base_mem_priv.h
index 4a98a72cc37a..52c8a4f7d2d8 100644
--- a/drivers/gpu/arm/bifrost/mali_base_mem_priv.h
+++ b/drivers/gpu/arm/bifrost/mali_base_mem_priv.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #ifndef _BASE_MEM_PRIV_H_
 #define _BASE_MEM_PRIV_H_
 
diff --git a/drivers/gpu/arm/bifrost/mali_base_vendor_specific_func.h b/drivers/gpu/arm/bifrost/mali_base_vendor_specific_func.h
index be454a216a39..5e8add8838f2 100644
--- a/drivers/gpu/arm/bifrost/mali_base_vendor_specific_func.h
+++ b/drivers/gpu/arm/bifrost/mali_base_vendor_specific_func.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 #ifndef _BASE_VENDOR_SPEC_FUNC_H_
 #define _BASE_VENDOR_SPEC_FUNC_H_
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase.h b/drivers/gpu/arm/bifrost/mali_kbase.h
index 369a2d4706fe..f9cc148c9969 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #ifndef _KBASE_H_
 #define _KBASE_H_
 
@@ -24,14 +29,12 @@
 
 #include <mali_kbase_debug.h>
 
-#include <asm/page.h>
-
 #include <linux/atomic.h>
 #include <linux/highmem.h>
 #include <linux/hrtimer.h>
 #include <linux/ktime.h>
 #include <linux/list.h>
-#include <linux/mm_types.h>
+#include <linux/mm.h>
 #include <linux/mutex.h>
 #include <linux/rwsem.h>
 #include <linux/sched.h>
@@ -45,7 +48,6 @@
 #include <linux/workqueue.h>
 
 #include "mali_base_kernel.h"
-#include <mali_kbase_uku.h>
 #include <mali_kbase_linux.h>
 
 /*
@@ -113,6 +115,49 @@ struct kbase_context *
 kbase_create_context(struct kbase_device *kbdev, bool is_compat);
 void kbase_destroy_context(struct kbase_context *kctx);
 
+
+/**
+ * kbase_get_unmapped_area() - get an address range which is currently
+ *                             unmapped.
+ * @filp: File operations associated with kbase device.
+ * @addr: CPU mapped address (set to 0 since MAP_FIXED mapping is not allowed
+ *        as Mali GPU driver decides about the mapping).
+ * @len: Length of the address range.
+ * @pgoff: Page offset within the GPU address space of the kbase context.
+ * @flags: Flags for the allocation.
+ *
+ * Finds the unmapped address range which satisfies requirements specific to
+ * GPU and those provided by the call parameters.
+ *
+ * 1) Requirement for allocations greater than 2MB:
+ * - alignment offset is set to 2MB and the alignment mask to 2MB decremented
+ * by 1.
+ *
+ * 2) Requirements imposed for the shader memory alignment:
+ * - alignment is decided by the number of GPU pc bits which can be read from
+ * GPU properties of the device associated with this kbase context; alignment
+ * offset is set to this value in bytes and the alignment mask to the offset
+ * decremented by 1.
+ * - allocations must not to be at 4GB boundaries. Such cases are indicated
+ * by the flag KBASE_REG_GPU_NX not being set (check the flags of the kbase
+ * region). 4GB boundaries can be checked against @ref BASE_MEM_MASK_4GB.
+ *
+ * 3) Requirements imposed for tiler memory alignment, cases indicated by
+ * the flag @ref KBASE_REG_TILER_ALIGN_TOP (check the flags of the kbase
+ * region):
+ * - alignment offset is set to the difference between the kbase region
+ * extent (converted from the original value in pages to bytes) and the kbase
+ * region initial_commit (also converted from the original value in pages to
+ * bytes); alignment mask is set to the kbase region extent in bytes and
+ * decremented by 1.
+ *
+ * Return: if successful, address of the unmapped area aligned as required;
+ *         error code (negative) in case of failure;
+ */
+unsigned long kbase_get_unmapped_area(struct file *filp,
+		const unsigned long addr, const unsigned long len,
+		const unsigned long pgoff, const unsigned long flags);
+
 int kbase_jd_init(struct kbase_context *kctx);
 void kbase_jd_exit(struct kbase_context *kctx);
 
@@ -222,10 +267,6 @@ int kbase_device_trace_buffer_install(
 		struct kbase_context *kctx, u32 *tb, size_t size);
 void kbase_device_trace_buffer_uninstall(struct kbase_context *kctx);
 
-/* api to be ported per OS, only need to do the raw register access */
-void kbase_os_reg_write(struct kbase_device *kbdev, u16 offset, u32 value);
-u32 kbase_os_reg_read(struct kbase_device *kbdev, u16 offset);
-
 void kbasep_as_do_poke(struct work_struct *work);
 
 /** Returns the name associated with a Mali exception code
@@ -546,20 +587,6 @@ void kbasep_trace_clear(struct kbase_device *kbdev);
 /** PRIVATE - do not use directly. Use KBASE_TRACE_DUMP() instead */
 void kbasep_trace_dump(struct kbase_device *kbdev);
 
-#ifdef CONFIG_MALI_BIFROST_DEBUG
-/**
- * kbase_set_driver_inactive - Force driver to go inactive
- * @kbdev:    Device pointer
- * @inactive: true if driver should go inactive, false otherwise
- *
- * Forcing the driver inactive will cause all future IOCTLs to wait until the
- * driver is made active again. This is intended solely for the use of tests
- * which require that no jobs are running while the test executes.
- */
-void kbase_set_driver_inactive(struct kbase_device *kbdev, bool inactive);
-#endif /* CONFIG_MALI_BIFROST_DEBUG */
-
-
 #if defined(CONFIG_DEBUG_FS) && !defined(CONFIG_MALI_BIFROST_NO_MALI)
 
 /* kbase_io_history_init - initialize data struct for register access history
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_10969_workaround.c b/drivers/gpu/arm/bifrost/mali_kbase_10969_workaround.c
index 6b3559d93351..e0e40a9292e8 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_10969_workaround.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_10969_workaround.c
@@ -7,13 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
-
-
 #include <linux/dma-mapping.h>
 #include <mali_kbase.h>
 #include <mali_kbase_10969_workaround.h>
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_10969_workaround.h b/drivers/gpu/arm/bifrost/mali_kbase_10969_workaround.h
index 099a29861672..624dc4a86b52 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_10969_workaround.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_10969_workaround.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_10969_WORKAROUND_
 #define _KBASE_10969_WORKAROUND_
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_as_fault_debugfs.c b/drivers/gpu/arm/bifrost/mali_kbase_as_fault_debugfs.c
index cc729d416858..f57eb7c25492 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_as_fault_debugfs.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_as_fault_debugfs.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/debugfs.h>
 
 #include <mali_kbase.h>
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_as_fault_debugfs.h b/drivers/gpu/arm/bifrost/mali_kbase_as_fault_debugfs.h
index 66387e1c3f6a..58d7fcf030a4 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_as_fault_debugfs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_as_fault_debugfs.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_AS_FAULT_DEBUG_FS_H
 #define _KBASE_AS_FAULT_DEBUG_FS_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_cache_policy.c b/drivers/gpu/arm/bifrost/mali_kbase_cache_policy.c
index 1d11de67aa80..18444b8a9c63 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_cache_policy.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_cache_policy.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Cache Policy API.
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_cache_policy.h b/drivers/gpu/arm/bifrost/mali_kbase_cache_policy.h
index 0c18bdb357b0..8a1e5291bf5f 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_cache_policy.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_cache_policy.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Cache Policy API.
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_config.c b/drivers/gpu/arm/bifrost/mali_kbase_config.c
index fb615ae02ead..ce7070d1d634 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_config.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_config.c
@@ -1,22 +1,27 @@
 /*
  *
- * (C) COPYRIGHT 2011-2015 ARM Limited. All rights reserved.
+ * (C) COPYRIGHT 2011-2015,2017 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the
  * GNU General Public License version 2 as published by the Free Software
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include <mali_kbase.h>
 #include <mali_kbase_defs.h>
 #include <mali_kbase_config_defaults.h>
@@ -41,11 +46,3 @@ void kbasep_platform_device_term(struct kbase_device *kbdev)
 		platform_funcs_p->platform_term_func(kbdev);
 }
 
-int kbase_cpuprops_get_default_clock_speed(u32 * const clock_speed)
-{
-	KBASE_DEBUG_ASSERT(NULL != clock_speed);
-
-	*clock_speed = 100;
-	return 0;
-}
-
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_config.h b/drivers/gpu/arm/bifrost/mali_kbase_config.h
index 212e3b14d96c..1637fcbc4d29 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_config.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_config.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_config.h
  * Configuration API and Attributes for KBase
@@ -25,10 +30,10 @@
 #ifndef _KBASE_CONFIG_H_
 #define _KBASE_CONFIG_H_
 
-#include <asm/page.h>
-
+#include <linux/mm.h>
 #include <mali_malisw.h>
 #include <mali_kbase_backend_config.h>
+#include <linux/rbtree.h>
 
 /**
  * @addtogroup base_api
@@ -45,8 +50,6 @@
  * @{
  */
 
-#include <linux/rbtree.h>
-
 /* Forward declaration of struct kbase_device */
 struct kbase_device;
 
@@ -208,41 +211,6 @@ struct kbase_pm_callback_conf {
 	int (*power_runtime_idle_callback)(struct kbase_device *kbdev);
 };
 
-/**
- * kbase_cpuprops_get_default_clock_speed - default for CPU_SPEED_FUNC
- * @clock_speed - see  kbase_cpu_clk_speed_func for details on the parameters
- *
- * Returns 0 on success, negative error code otherwise.
- *
- * Default implementation of CPU_SPEED_FUNC. This function sets clock_speed
- * to 100, so will be an underestimate for any real system.
- */
-int kbase_cpuprops_get_default_clock_speed(u32 * const clock_speed);
-
-/**
- * kbase_cpu_clk_speed_func - Type of the function pointer for CPU_SPEED_FUNC
- * @param clock_speed - pointer to store the current CPU clock speed in MHz
- *
- * Returns 0 on success, otherwise negative error code.
- *
- * This is mainly used to implement OpenCL's clGetDeviceInfo().
- */
-typedef int (*kbase_cpu_clk_speed_func) (u32 *clock_speed);
-
-/**
- * kbase_gpu_clk_speed_func - Type of the function pointer for GPU_SPEED_FUNC
- * @param clock_speed - pointer to store the current GPU clock speed in MHz
- *
- * Returns 0 on success, otherwise negative error code.
- * When an error is returned the caller assumes maximum GPU speed stored in
- * gpu_freq_khz_max.
- *
- * If the system timer is not available then this function is required
- * for the OpenCL queue profiling to return correct timing information.
- *
- */
-typedef int (*kbase_gpu_clk_speed_func) (u32 *clock_speed);
-
 #ifdef CONFIG_OF
 struct kbase_platform_config {
 };
@@ -304,18 +272,6 @@ int kbasep_platform_device_init(struct kbase_device *kbdev);
  */
 void kbasep_platform_device_term(struct kbase_device *kbdev);
 
-
-/**
- * kbase_platform_early_init - Early initialisation of the platform code
- *
- * This function will be called when the module is loaded to perform any
- * early initialisation required by the platform code. Such as reading
- * platform specific device tree entries for the GPU.
- *
- * Return: 0 for success, any other fail causes module initialisation to fail
- */
-int kbase_platform_early_init(void);
-
 #ifndef CONFIG_OF
 /**
  * kbase_platform_register - Register a platform device for the GPU
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_config_defaults.h b/drivers/gpu/arm/bifrost/mali_kbase_config_defaults.h
index 69079e7d9680..dbb4f977bb33 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_config_defaults.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_config_defaults.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /**
  * @file mali_kbase_config_defaults.h
  *
@@ -74,6 +79,35 @@ enum {
 	KBASE_AID_4  = 0x1
 };
 
+enum {
+	/**
+	 * Use unrestricted Address ID width on the AXI bus.
+	 * Restricting ID width will reduce performance & bus load due to GPU.
+	 */
+	KBASE_3BIT_AID_32 = 0x0,
+
+	/* Restrict GPU to 7/8 of maximum Address ID count. */
+	KBASE_3BIT_AID_28 = 0x1,
+
+	/* Restrict GPU to 3/4 of maximum Address ID count. */
+	KBASE_3BIT_AID_24 = 0x2,
+
+	/* Restrict GPU to 5/8 of maximum Address ID count. */
+	KBASE_3BIT_AID_20 = 0x3,
+
+	/* Restrict GPU to 1/2 of maximum Address ID count.  */
+	KBASE_3BIT_AID_16 = 0x4,
+
+	/* Restrict GPU to 3/8 of maximum Address ID count. */
+	KBASE_3BIT_AID_12 = 0x5,
+
+	/* Restrict GPU to 1/4 of maximum Address ID count. */
+	KBASE_3BIT_AID_8  = 0x6,
+
+	/* Restrict GPU to 1/8 of maximum Address ID count. */
+	KBASE_3BIT_AID_4  = 0x7
+};
+
 /**
  * Default setting for read Address ID limiting on AXI bus.
  *
@@ -100,6 +134,22 @@ enum {
  */
 #define DEFAULT_AWID_LIMIT KBASE_AID_32
 
+/**
+ * Default setting for read Address ID limiting on AXI bus.
+ *
+ * Default value: KBASE_3BIT_AID_32 (no limit). Note hardware implementation
+ * may limit to a lower value.
+ */
+#define DEFAULT_3BIT_ARID_LIMIT KBASE_3BIT_AID_32
+
+/**
+ * Default setting for write Address ID limiting on AXI.
+ *
+ * Default value: KBASE_3BIT_AID_32 (no limit). Note hardware implementation
+ * may limit to a lower value.
+ */
+#define DEFAULT_3BIT_AWID_LIMIT KBASE_3BIT_AID_32
+
 /**
  * Default UMP device mapping. A UMP_DEVICE_<device>_SHIFT value which
  * defines which UMP device this GPU should be mapped to.
@@ -222,5 +272,13 @@ enum {
  */
 #define PLATFORM_POWER_DOWN_ONLY (0)
 
+/*
+ * Maximum frequency (in kHz) that the GPU can be clocked. For some platforms
+ * this isn't available, so we simply define a dummy value here. If devfreq
+ * is enabled the value will be read from there, otherwise this should be
+ * overridden by defining GPU_FREQ_KHZ_MAX in the platform file.
+ */
+#define DEFAULT_GPU_FREQ_KHZ_MAX (5000)
+
 #endif /* _KBASE_CONFIG_DEFAULTS_H_ */
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_context.c b/drivers/gpu/arm/bifrost/mali_kbase_context.c
index 17821fee6cba..d873f9feea30 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_context.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_context.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Base kernel context APIs
  */
@@ -59,6 +64,11 @@ kbase_create_context(struct kbase_device *kbdev, bool is_compat)
 	atomic_set(&kctx->refcount, 0);
 	if (is_compat)
 		kbase_ctx_flag_set(kctx, KCTX_COMPAT);
+#if defined(CONFIG_64BIT)
+	else
+		kbase_ctx_flag_set(kctx, KCTX_FORCE_SAME_VA);
+#endif /* !defined(CONFIG_64BIT) */
+
 #ifdef CONFIG_MALI_BIFROST_TRACE_TIMELINE
 	kctx->timeline.owner_tgid = task_tgid_nr(current);
 #endif
@@ -114,9 +124,6 @@ kbase_create_context(struct kbase_device *kbdev, bool is_compat)
 
 	INIT_LIST_HEAD(&kctx->waiting_soft_jobs);
 	spin_lock_init(&kctx->waiting_soft_jobs_lock);
-#ifdef CONFIG_KDS
-	INIT_LIST_HEAD(&kctx->waiting_kds_resource);
-#endif
 	err = kbase_dma_fence_init(kctx);
 	if (err)
 		goto free_event;
@@ -296,8 +303,6 @@ void kbase_destroy_context(struct kbase_context *kctx)
 
 	kbase_jd_exit(kctx);
 
-	kbase_pm_context_idle(kbdev);
-
 	kbase_dma_fence_term(kctx);
 
 	mutex_lock(&kbdev->mmu_hw_mutex);
@@ -318,6 +323,8 @@ void kbase_destroy_context(struct kbase_context *kctx)
 	WARN_ON(atomic_read(&kctx->nonmapped_pages) != 0);
 
 	vfree(kctx);
+
+	kbase_pm_context_idle(kbdev);
 }
 KBASE_EXPORT_SYMBOL(kbase_destroy_context);
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_context.h b/drivers/gpu/arm/bifrost/mali_kbase_context.h
index a3f5bb0ce0da..431f9e5aa6de 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_context.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_context.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_CONTEXT_H_
 #define _KBASE_CONTEXT_H_
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_core_linux.c b/drivers/gpu/arm/bifrost/mali_kbase_core_linux.c
index 844572c5f3c9..a65d0a60fa44 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_core_linux.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_core_linux.c
@@ -7,17 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 #include <mali_kbase_config_defaults.h>
-#include <mali_kbase_uku.h>
 #include <mali_midg_regmap.h>
 #include <mali_kbase_gator.h>
 #include <mali_kbase_mem_linux.h>
@@ -45,6 +49,10 @@
 #include <backend/gpu/mali_kbase_device_internal.h>
 #include "mali_kbase_ioctl.h"
 
+#ifdef CONFIG_MALI_JOB_DUMP
+#include "mali_kbase_gwt.h"
+#endif
+
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/poll.h>
@@ -64,12 +72,12 @@
 #include <linux/mman.h>
 #include <linux/version.h>
 #include <mali_kbase_hw.h>
-#include <platform/mali_kbase_platform_common.h>
 #if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 #include <mali_kbase_sync.h>
 #endif /* CONFIG_SYNC || CONFIG_SYNC_FILE */
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/log2.h>
 
 #include <mali_kbase_config.h>
 
@@ -89,21 +97,12 @@
 #define MMU_IRQ_TAG	1
 #define GPU_IRQ_TAG	2
 
-#if MALI_UNIT_TEST
-static struct kbase_exported_test_data shared_kernel_test_data;
-EXPORT_SYMBOL(shared_kernel_test_data);
-#endif /* MALI_UNIT_TEST */
-
 static int kbase_dev_nr;
 
 static DEFINE_MUTEX(kbase_dev_list_lock);
 static LIST_HEAD(kbase_dev_list);
 
 #define KERNEL_SIDE_DDK_VERSION_STRING "K:" MALI_RELEASE_NAME "(GPL)"
-static inline void __compile_time_asserts(void)
-{
-	CSTD_COMPILE_TIME_ASSERT(sizeof(KERNEL_SIDE_DDK_VERSION_STRING) <= KBASE_GET_VERSION_BUFFER_SIZE);
-}
 
 static int kbase_api_handshake(struct kbase_context *kctx,
 		struct kbase_ioctl_version_check *version)
@@ -152,7 +151,9 @@ enum mali_error {
 enum {
 	inited_mem = (1u << 0),
 	inited_js = (1u << 1),
-	inited_pm_runtime_init = (1u << 2),
+	/* Bit number 2 was earlier assigned to the runtime-pm initialization
+	 * stage (which has been merged with the backend_early stage).
+	 */
 #ifdef CONFIG_MALI_BIFROST_DEVFREQ
 	inited_devfreq = (1u << 3),
 #endif /* CONFIG_MALI_BIFROST_DEVFREQ */
@@ -177,742 +178,6 @@ enum {
 	inited_ctx_sched = (1u << 22)
 };
 
-
-#ifdef CONFIG_MALI_BIFROST_DEBUG
-#define INACTIVE_WAIT_MS (5000)
-
-void kbase_set_driver_inactive(struct kbase_device *kbdev, bool inactive)
-{
-	kbdev->driver_inactive = inactive;
-	wake_up(&kbdev->driver_inactive_wait);
-
-	/* Wait for any running IOCTLs to complete */
-	if (inactive)
-		msleep(INACTIVE_WAIT_MS);
-}
-KBASE_EXPORT_TEST_API(kbase_set_driver_inactive);
-#endif /* CONFIG_MALI_BIFROST_DEBUG */
-
-/**
- * kbase_legacy_dispatch - UKK dispatch function
- *
- * This is the dispatch function for the legacy UKK ioctl interface. No new
- * ioctls should be added to this function, see kbase_ioctl instead.
- *
- * @kctx: The kernel context structure
- * @args: Pointer to the data structure passed from/to user space
- * @args_size: Size of the data structure
- */
-static int kbase_legacy_dispatch(struct kbase_context *kctx,
-		void * const args, u32 args_size)
-{
-	struct kbase_device *kbdev;
-	union uk_header *ukh = args;
-	u32 id;
-	int ret = 0;
-
-	KBASE_DEBUG_ASSERT(ukh != NULL);
-
-	kbdev = kctx->kbdev;
-	id = ukh->id;
-	ukh->ret = MALI_ERROR_NONE; /* Be optimistic */
-
-#ifdef CONFIG_MALI_BIFROST_DEBUG
-	wait_event(kbdev->driver_inactive_wait,
-			kbdev->driver_inactive == false);
-#endif /* CONFIG_MALI_BIFROST_DEBUG */
-
-	if (UKP_FUNC_ID_CHECK_VERSION == id) {
-		struct uku_version_check_args *version_check;
-		struct kbase_ioctl_version_check version;
-
-		if (args_size != sizeof(struct uku_version_check_args)) {
-			ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			return 0;
-		}
-		version_check = (struct uku_version_check_args *)args;
-		version.minor = version_check->minor;
-		version.major = version_check->major;
-
-		kbase_api_handshake(kctx, &version);
-
-		version_check->minor = version.minor;
-		version_check->major = version.major;
-		ukh->ret = MALI_ERROR_NONE;
-		return 0;
-	}
-
-	/* block calls until version handshake */
-	if (kctx->api_version == 0)
-		return -EINVAL;
-
-	if (!atomic_read(&kctx->setup_complete)) {
-		struct kbase_uk_set_flags *kbase_set_flags;
-
-		/* setup pending, try to signal that we'll do the setup,
-		 * if setup was already in progress, err this call
-		 */
-		if (atomic_cmpxchg(&kctx->setup_in_progress, 0, 1) != 0)
-			return -EINVAL;
-
-		/* if unexpected call, will stay stuck in setup mode
-		 * (is it the only call we accept?)
-		 */
-		if (id != KBASE_FUNC_SET_FLAGS)
-			return -EINVAL;
-
-		kbase_set_flags = (struct kbase_uk_set_flags *)args;
-
-		/* if not matching the expected call, stay in setup mode */
-		if (sizeof(*kbase_set_flags) != args_size)
-			goto bad_size;
-
-		/* if bad flags, will stay stuck in setup mode */
-		if (kbase_context_set_create_flags(kctx,
-				kbase_set_flags->create_flags) != 0)
-			ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-
-		atomic_set(&kctx->setup_complete, 1);
-		return 0;
-	}
-
-	/* setup complete, perform normal operation */
-	switch (id) {
-	case KBASE_FUNC_MEM_JIT_INIT:
-		{
-			struct kbase_uk_mem_jit_init *jit_init = args;
-
-			if (sizeof(*jit_init) != args_size)
-				goto bad_size;
-
-			if (kbase_region_tracker_init_jit(kctx,
-					jit_init->va_pages))
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			break;
-		}
-	case KBASE_FUNC_MEM_ALLOC:
-		{
-			struct kbase_uk_mem_alloc *mem = args;
-			struct kbase_va_region *reg;
-
-			if (sizeof(*mem) != args_size)
-				goto bad_size;
-
-#if defined(CONFIG_64BIT)
-			if (!kbase_ctx_flag(kctx, KCTX_COMPAT)) {
-				/* force SAME_VA if a 64-bit client */
-				mem->flags |= BASE_MEM_SAME_VA;
-			}
-#endif
-
-			reg = kbase_mem_alloc(kctx, mem->va_pages,
-					mem->commit_pages, mem->extent,
-					&mem->flags, &mem->gpu_va);
-			mem->va_alignment = 0;
-
-			if (!reg)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			break;
-		}
-	case KBASE_FUNC_MEM_IMPORT: {
-			struct kbase_uk_mem_import *mem_import = args;
-			void __user *phandle;
-
-			if (sizeof(*mem_import) != args_size)
-				goto bad_size;
-#ifdef CONFIG_COMPAT
-			if (kbase_ctx_flag(kctx, KCTX_COMPAT))
-				phandle = compat_ptr(mem_import->phandle);
-			else
-#endif
-				phandle = u64_to_user_ptr(mem_import->phandle);
-
-			if (mem_import->type == BASE_MEM_IMPORT_TYPE_INVALID) {
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-				break;
-			}
-
-			if (kbase_mem_import(kctx,
-					(enum base_mem_import_type)
-					mem_import->type,
-					phandle,
-					0,
-					&mem_import->gpu_va,
-					&mem_import->va_pages,
-					&mem_import->flags)) {
-				mem_import->type = BASE_MEM_IMPORT_TYPE_INVALID;
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			}
-			break;
-	}
-	case KBASE_FUNC_MEM_ALIAS: {
-			struct kbase_uk_mem_alias *alias = args;
-			struct base_mem_aliasing_info __user *user_ai;
-			struct base_mem_aliasing_info *ai;
-
-			if (sizeof(*alias) != args_size)
-				goto bad_size;
-
-			if (alias->nents > 2048) {
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-				break;
-			}
-			if (!alias->nents) {
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-				break;
-			}
-
-#ifdef CONFIG_COMPAT
-			if (kbase_ctx_flag(kctx, KCTX_COMPAT))
-				user_ai = compat_ptr(alias->ai);
-			else
-#endif
-				user_ai = u64_to_user_ptr(alias->ai);
-
-			ai = vmalloc(sizeof(*ai) * alias->nents);
-
-			if (!ai) {
-				ukh->ret = MALI_ERROR_OUT_OF_MEMORY;
-				break;
-			}
-
-			if (copy_from_user(ai, user_ai,
-					   sizeof(*ai) * alias->nents)) {
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-				goto copy_failed;
-			}
-
-			alias->gpu_va = kbase_mem_alias(kctx, &alias->flags,
-							alias->stride,
-							alias->nents, ai,
-							&alias->va_pages);
-			if (!alias->gpu_va) {
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-				goto no_alias;
-			}
-no_alias:
-copy_failed:
-			vfree(ai);
-			break;
-		}
-	case KBASE_FUNC_MEM_COMMIT:
-		{
-			struct kbase_uk_mem_commit *commit = args;
-			int ret;
-
-			if (sizeof(*commit) != args_size)
-				goto bad_size;
-
-			ret = kbase_mem_commit(kctx, commit->gpu_addr,
-					commit->pages);
-
-			ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			commit->result_subcode =
-				BASE_BACKING_THRESHOLD_ERROR_INVALID_ARGUMENTS;
-
-			if (ret == 0) {
-				ukh->ret = MALI_ERROR_NONE;
-				commit->result_subcode =
-					BASE_BACKING_THRESHOLD_OK;
-			} else if (ret == -ENOMEM) {
-				commit->result_subcode =
-					BASE_BACKING_THRESHOLD_ERROR_OOM;
-			}
-
-			break;
-		}
-
-	case KBASE_FUNC_MEM_QUERY:
-		{
-			struct kbase_uk_mem_query *query = args;
-
-			if (sizeof(*query) != args_size)
-				goto bad_size;
-
-			if (kbase_mem_query(kctx, query->gpu_addr,
-					query->query, &query->value) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			else
-				ukh->ret = MALI_ERROR_NONE;
-			break;
-		}
-		break;
-
-	case KBASE_FUNC_MEM_FLAGS_CHANGE:
-		{
-			struct kbase_uk_mem_flags_change *fc = args;
-
-			if (sizeof(*fc) != args_size)
-				goto bad_size;
-
-			if (kbase_mem_flags_change(kctx, fc->gpu_va,
-					fc->flags, fc->mask) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-
-			break;
-		}
-	case KBASE_FUNC_MEM_FREE:
-		{
-			struct kbase_uk_mem_free *mem = args;
-
-			if (sizeof(*mem) != args_size)
-				goto bad_size;
-
-			if (kbase_mem_free(kctx, mem->gpu_addr) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			break;
-		}
-
-	case KBASE_FUNC_JOB_SUBMIT:
-		{
-			struct kbase_uk_job_submit *job = args;
-			char __user *user_buf;
-
-			if (sizeof(*job) != args_size)
-				goto bad_size;
-
-#ifdef CONFIG_COMPAT
-			if (kbase_ctx_flag(kctx, KCTX_COMPAT))
-				user_buf = compat_ptr(job->addr);
-			else
-#endif
-				user_buf = u64_to_user_ptr(job->addr);
-
-			if (kbase_jd_submit(kctx, user_buf,
-						job->nr_atoms,
-						job->stride,
-						false) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			break;
-		}
-
-	case KBASE_FUNC_SYNC:
-		{
-			struct kbase_uk_sync_now *sn = args;
-
-			if (sizeof(*sn) != args_size)
-				goto bad_size;
-
-			if (kbase_sync_now(kctx, &sn->sset.basep_sset) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			break;
-		}
-
-	case KBASE_FUNC_DISJOINT_QUERY:
-		{
-			struct kbase_uk_disjoint_query *dquery = args;
-
-			if (sizeof(*dquery) != args_size)
-				goto bad_size;
-
-			/* Get the disjointness counter value. */
-			dquery->counter = kbase_disjoint_event_get(kctx->kbdev);
-			break;
-		}
-
-	case KBASE_FUNC_POST_TERM:
-		{
-			kbase_event_close(kctx);
-			break;
-		}
-
-	case KBASE_FUNC_HWCNT_SETUP:
-		{
-			struct kbase_uk_hwcnt_setup *setup = args;
-
-			if (sizeof(*setup) != args_size)
-				goto bad_size;
-
-			mutex_lock(&kctx->vinstr_cli_lock);
-			if (kbase_vinstr_legacy_hwc_setup(kbdev->vinstr_ctx,
-					&kctx->vinstr_cli, setup) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			mutex_unlock(&kctx->vinstr_cli_lock);
-			break;
-		}
-
-	case KBASE_FUNC_HWCNT_DUMP:
-		{
-			/* args ignored */
-			mutex_lock(&kctx->vinstr_cli_lock);
-			if (kbase_vinstr_hwc_dump(kctx->vinstr_cli,
-					BASE_HWCNT_READER_EVENT_MANUAL) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			mutex_unlock(&kctx->vinstr_cli_lock);
-			break;
-		}
-
-	case KBASE_FUNC_HWCNT_CLEAR:
-		{
-			/* args ignored */
-			mutex_lock(&kctx->vinstr_cli_lock);
-			if (kbase_vinstr_hwc_clear(kctx->vinstr_cli) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			mutex_unlock(&kctx->vinstr_cli_lock);
-			break;
-		}
-
-	case KBASE_FUNC_HWCNT_READER_SETUP:
-		{
-			struct kbase_uk_hwcnt_reader_setup *setup = args;
-
-			if (sizeof(*setup) != args_size)
-				goto bad_size;
-
-			mutex_lock(&kctx->vinstr_cli_lock);
-			if (kbase_vinstr_hwcnt_reader_setup(kbdev->vinstr_ctx,
-					setup) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			mutex_unlock(&kctx->vinstr_cli_lock);
-			break;
-		}
-
-	case KBASE_FUNC_GPU_PROPS_REG_DUMP:
-		{
-			struct kbase_uk_gpuprops *setup = args;
-
-			if (sizeof(*setup) != args_size)
-				goto bad_size;
-
-			if (kbase_gpuprops_uk_get_props(kctx, setup) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			break;
-		}
-	case KBASE_FUNC_FIND_CPU_OFFSET:
-		{
-			struct kbase_uk_find_cpu_offset *find = args;
-
-			if (sizeof(*find) != args_size)
-				goto bad_size;
-
-			if (find->gpu_addr & ~PAGE_MASK) {
-				dev_warn(kbdev->dev, "kbase_legacy_dispatch case KBASE_FUNC_FIND_CPU_OFFSET: find->gpu_addr: passed parameter is invalid");
-				goto out_bad;
-			}
-
-			if (find->size > SIZE_MAX || find->cpu_addr > ULONG_MAX) {
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			} else {
-				int err;
-
-				err = kbasep_find_enclosing_cpu_mapping_offset(
-						kctx,
-						find->cpu_addr,
-						find->size,
-						&find->offset);
-
-				if (err)
-					ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			}
-			break;
-		}
-	case KBASE_FUNC_GET_VERSION:
-		{
-			struct kbase_uk_get_ddk_version *get_version = (struct kbase_uk_get_ddk_version *)args;
-
-			if (sizeof(*get_version) != args_size)
-				goto bad_size;
-
-			/* version buffer size check is made in compile time assert */
-			memcpy(get_version->version_buffer, KERNEL_SIDE_DDK_VERSION_STRING, sizeof(KERNEL_SIDE_DDK_VERSION_STRING));
-			get_version->version_string_size = sizeof(KERNEL_SIDE_DDK_VERSION_STRING);
-			break;
-		}
-
-	case KBASE_FUNC_STREAM_CREATE:
-		{
-#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
-			struct kbase_uk_stream_create *screate = (struct kbase_uk_stream_create *)args;
-
-			if (sizeof(*screate) != args_size)
-				goto bad_size;
-
-			if (strnlen(screate->name, sizeof(screate->name)) >= sizeof(screate->name)) {
-				/* not NULL terminated */
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-				break;
-			}
-
-			if (kbase_sync_fence_stream_create(screate->name,
-							   &screate->fd) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			else
-				ukh->ret = MALI_ERROR_NONE;
-#else /* CONFIG_SYNC || CONFIG_SYNC_FILE */
-			ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-#endif /* CONFIG_SYNC || CONFIG_SYNC_FILE */
-			break;
-		}
-	case KBASE_FUNC_FENCE_VALIDATE:
-		{
-#if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
-			struct kbase_uk_fence_validate *fence_validate = (struct kbase_uk_fence_validate *)args;
-
-			if (sizeof(*fence_validate) != args_size)
-				goto bad_size;
-
-			if (kbase_sync_fence_validate(fence_validate->fd) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			else
-				ukh->ret = MALI_ERROR_NONE;
-#endif /* CONFIG_SYNC || CONFIG_SYNC_FILE */
-			break;
-		}
-
-	case KBASE_FUNC_SET_TEST_DATA:
-		{
-#if MALI_UNIT_TEST
-			struct kbase_uk_set_test_data *set_data = args;
-
-			shared_kernel_test_data = set_data->test_data;
-			shared_kernel_test_data.kctx = (uintptr_t)kctx;
-			shared_kernel_test_data.mm = (uintptr_t)current->mm;
-			ukh->ret = MALI_ERROR_NONE;
-#endif /* MALI_UNIT_TEST */
-			break;
-		}
-
-	case KBASE_FUNC_INJECT_ERROR:
-		{
-#ifdef CONFIG_MALI_BIFROST_ERROR_INJECT
-			unsigned long flags;
-			struct kbase_error_params params = ((struct kbase_uk_error_params *)args)->params;
-
-			/*mutex lock */
-			spin_lock_irqsave(&kbdev->reg_op_lock, flags);
-			if (job_atom_inject_error(&params) != 0)
-				ukh->ret = MALI_ERROR_OUT_OF_MEMORY;
-			else
-				ukh->ret = MALI_ERROR_NONE;
-			spin_unlock_irqrestore(&kbdev->reg_op_lock, flags);
-			/*mutex unlock */
-#endif /* CONFIG_MALI_BIFROST_ERROR_INJECT */
-			break;
-		}
-
-	case KBASE_FUNC_MODEL_CONTROL:
-		{
-#ifdef CONFIG_MALI_BIFROST_NO_MALI
-			unsigned long flags;
-			struct kbase_model_control_params params =
-					((struct kbase_uk_model_control_params *)args)->params;
-
-			/*mutex lock */
-			spin_lock_irqsave(&kbdev->reg_op_lock, flags);
-			if (gpu_model_control(kbdev->model, &params) != 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			else
-				ukh->ret = MALI_ERROR_NONE;
-			spin_unlock_irqrestore(&kbdev->reg_op_lock, flags);
-			/*mutex unlock */
-#endif /* CONFIG_MALI_BIFROST_NO_MALI */
-			break;
-		}
-
-	case KBASE_FUNC_GET_PROFILING_CONTROLS:
-		{
-			struct kbase_uk_profiling_controls *controls =
-					(struct kbase_uk_profiling_controls *)args;
-			u32 i;
-
-			if (sizeof(*controls) != args_size)
-				goto bad_size;
-
-			for (i = FBDUMP_CONTROL_MIN; i < FBDUMP_CONTROL_MAX; i++)
-				controls->profiling_controls[i] =
-					kbdev->kbase_profiling_controls[i];
-
-			break;
-		}
-
-	/* used only for testing purposes; these controls are to be set by gator through gator API */
-	case KBASE_FUNC_SET_PROFILING_CONTROLS:
-		{
-			struct kbase_uk_profiling_controls *controls =
-					(struct kbase_uk_profiling_controls *)args;
-			u32 i;
-
-			if (sizeof(*controls) != args_size)
-				goto bad_size;
-
-			for (i = FBDUMP_CONTROL_MIN; i < FBDUMP_CONTROL_MAX; i++)
-				_mali_profiling_control(i, controls->profiling_controls[i]);
-
-			break;
-		}
-
-	case KBASE_FUNC_DEBUGFS_MEM_PROFILE_ADD:
-		{
-			struct kbase_uk_debugfs_mem_profile_add *add_data =
-					(struct kbase_uk_debugfs_mem_profile_add *)args;
-			char *buf;
-			char __user *user_buf;
-
-			if (sizeof(*add_data) != args_size)
-				goto bad_size;
-
-			if (add_data->len > KBASE_MEM_PROFILE_MAX_BUF_SIZE) {
-				dev_err(kbdev->dev, "buffer too big\n");
-				goto out_bad;
-			}
-
-#ifdef CONFIG_COMPAT
-			if (kbase_ctx_flag(kctx, KCTX_COMPAT))
-				user_buf = compat_ptr(add_data->buf);
-			else
-#endif
-				user_buf = u64_to_user_ptr(add_data->buf);
-
-			buf = kmalloc(add_data->len, GFP_KERNEL);
-			if (ZERO_OR_NULL_PTR(buf))
-				goto out_bad;
-
-			if (0 != copy_from_user(buf, user_buf, add_data->len)) {
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-				kfree(buf);
-				goto out_bad;
-			}
-
-			if (kbasep_mem_profile_debugfs_insert(kctx, buf,
-							add_data->len)) {
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-				goto out_bad;
-			}
-
-			break;
-		}
-
-#ifdef CONFIG_MALI_BIFROST_NO_MALI
-	case KBASE_FUNC_SET_PRFCNT_VALUES:
-		{
-
-			struct kbase_uk_prfcnt_values *params =
-			  ((struct kbase_uk_prfcnt_values *)args);
-			gpu_model_set_dummy_prfcnt_sample(params->data,
-					params->size);
-
-			break;
-		}
-#endif /* CONFIG_MALI_BIFROST_NO_MALI */
-#ifdef BASE_LEGACY_UK10_4_SUPPORT
-	case KBASE_FUNC_TLSTREAM_ACQUIRE_V10_4:
-		{
-			struct kbase_uk_tlstream_acquire_v10_4 *tlstream_acquire
-					= args;
-			int ret;
-
-			if (sizeof(*tlstream_acquire) != args_size)
-				goto bad_size;
-
-			ret = kbase_tlstream_acquire(
-						kctx, 0);
-			if (ret < 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			else
-				tlstream_acquire->fd = ret;
-			break;
-		}
-#endif /* BASE_LEGACY_UK10_4_SUPPORT */
-	case KBASE_FUNC_TLSTREAM_ACQUIRE:
-		{
-			struct kbase_uk_tlstream_acquire *tlstream_acquire =
-				args;
-			int ret;
-
-			if (sizeof(*tlstream_acquire) != args_size)
-				goto bad_size;
-
-			if (tlstream_acquire->flags & ~BASE_TLSTREAM_FLAGS_MASK)
-				goto out_bad;
-
-			ret = kbase_tlstream_acquire(
-					kctx, tlstream_acquire->flags);
-			if (ret < 0)
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-			else
-				tlstream_acquire->fd = ret;
-			break;
-		}
-	case KBASE_FUNC_TLSTREAM_FLUSH:
-		{
-			struct kbase_uk_tlstream_flush *tlstream_flush =
-				args;
-
-			if (sizeof(*tlstream_flush) != args_size)
-				goto bad_size;
-
-			kbase_tlstream_flush_streams();
-			break;
-		}
-#if MALI_UNIT_TEST
-	case KBASE_FUNC_TLSTREAM_TEST:
-		{
-			struct kbase_uk_tlstream_test *tlstream_test = args;
-
-			if (sizeof(*tlstream_test) != args_size)
-				goto bad_size;
-
-			kbase_tlstream_test(
-					tlstream_test->tpw_count,
-					tlstream_test->msg_delay,
-					tlstream_test->msg_count,
-					tlstream_test->aux_msg);
-			break;
-		}
-	case KBASE_FUNC_TLSTREAM_STATS:
-		{
-			struct kbase_uk_tlstream_stats *tlstream_stats = args;
-
-			if (sizeof(*tlstream_stats) != args_size)
-				goto bad_size;
-
-			kbase_tlstream_stats(
-					&tlstream_stats->bytes_collected,
-					&tlstream_stats->bytes_generated);
-			break;
-		}
-#endif /* MALI_UNIT_TEST */
-
-	case KBASE_FUNC_GET_CONTEXT_ID:
-		{
-			struct kbase_uk_context_id *info = args;
-
-			info->id = kctx->id;
-			break;
-		}
-
-	case KBASE_FUNC_SOFT_EVENT_UPDATE:
-		{
-			struct kbase_uk_soft_event_update *update = args;
-
-			if (sizeof(*update) != args_size)
-				goto bad_size;
-
-			if (((update->new_status != BASE_JD_SOFT_EVENT_SET) &&
-			    (update->new_status != BASE_JD_SOFT_EVENT_RESET)) ||
-			    (update->flags != 0))
-				goto out_bad;
-
-			if (kbase_soft_event_update(kctx, update->evt,
-						update->new_status))
-				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
-
-			break;
-		}
-
-	default:
-		dev_err(kbdev->dev, "unknown ioctl %u\n", id);
-		goto out_bad;
-	}
-
-	return ret;
-
- bad_size:
-	dev_err(kbdev->dev, "Wrong syscall size (%d) for %08x\n", args_size, id);
- out_bad:
-	return -EINVAL;
-}
-
 static struct kbase_device *to_kbase_device(struct device *dev)
 {
 	return dev_get_drvdata(dev);
@@ -1065,6 +330,55 @@ static const struct file_operations kbase_infinite_cache_fops = {
 	.read = read_ctx_infinite_cache,
 };
 
+static ssize_t write_ctx_force_same_va(struct file *f, const char __user *ubuf,
+		size_t size, loff_t *off)
+{
+	struct kbase_context *kctx = f->private_data;
+	int err;
+	bool value;
+
+	err = kstrtobool_from_user(ubuf, size, &value);
+	if (err)
+		return err;
+
+	if (value) {
+#if defined(CONFIG_64BIT)
+		/* 32-bit clients cannot force SAME_VA */
+		if (kbase_ctx_flag(kctx, KCTX_COMPAT))
+			return -EINVAL;
+		kbase_ctx_flag_set(kctx, KCTX_FORCE_SAME_VA);
+#else /* defined(CONFIG_64BIT) */
+		/* 32-bit clients cannot force SAME_VA */
+		return -EINVAL;
+#endif /* defined(CONFIG_64BIT) */
+	} else {
+		kbase_ctx_flag_clear(kctx, KCTX_FORCE_SAME_VA);
+	}
+
+	return size;
+}
+
+static ssize_t read_ctx_force_same_va(struct file *f, char __user *ubuf,
+		size_t size, loff_t *off)
+{
+	struct kbase_context *kctx = f->private_data;
+	char buf[32];
+	int count;
+	bool value;
+
+	value = kbase_ctx_flag(kctx, KCTX_FORCE_SAME_VA);
+
+	count = scnprintf(buf, sizeof(buf), "%s\n", value ? "Y" : "N");
+
+	return simple_read_from_buffer(ubuf, size, off, buf, count);
+}
+
+static const struct file_operations kbase_force_same_va_fops = {
+	.open = simple_open,
+	.write = write_ctx_force_same_va,
+	.read = read_ctx_force_same_va,
+};
+
 static int kbase_open(struct inode *inode, struct file *filp)
 {
 	struct kbase_device *kbdev = NULL;
@@ -1104,7 +418,9 @@ static int kbase_open(struct inode *inode, struct file *filp)
 	}
 
 	debugfs_create_file("infinite_cache", 0644, kctx->kctx_dentry,
-			    kctx, &kbase_infinite_cache_fops);
+			kctx, &kbase_infinite_cache_fops);
+	debugfs_create_file("force_same_va", S_IRUSR | S_IWUSR,
+			kctx->kctx_dentry, kctx, &kbase_force_same_va_fops);
 
 	mutex_init(&kctx->mem_profile_lock);
 
@@ -1192,33 +508,6 @@ static int kbase_release(struct inode *inode, struct file *filp)
 	return 0;
 }
 
-#define CALL_MAX_SIZE 536
-
-static long kbase_legacy_ioctl(struct file *filp, unsigned int cmd,
-		unsigned long arg)
-{
-	u64 msg[(CALL_MAX_SIZE + 7) >> 3] = { 0xdeadbeefdeadbeefull };	/* alignment fixup */
-	u32 size = _IOC_SIZE(cmd);
-	struct kbase_context *kctx = filp->private_data;
-
-	if (size > CALL_MAX_SIZE)
-		return -ENOTTY;
-
-	if (0 != copy_from_user(&msg, (void __user *)arg, size)) {
-		dev_err(kctx->kbdev->dev, "failed to copy ioctl argument into kernel space\n");
-		return -EFAULT;
-	}
-
-	if (kbase_legacy_dispatch(kctx, &msg, size) != 0)
-		return -EFAULT;
-
-	if (0 != copy_to_user((void __user *)arg, &msg, size)) {
-		dev_err(kctx->kbdev->dev, "failed to copy results of UK call back to user space\n");
-		return -EFAULT;
-	}
-	return 0;
-}
-
 static int kbase_api_set_flags(struct kbase_context *kctx,
 		struct kbase_ioctl_set_flags *flags)
 {
@@ -1284,12 +573,11 @@ static int kbase_api_mem_alloc(struct kbase_context *kctx,
 	u64 flags = alloc->in.flags;
 	u64 gpu_va;
 
-#if defined(CONFIG_64BIT)
-	if (!kbase_ctx_flag(kctx, KCTX_COMPAT)) {
+	if ((!kbase_ctx_flag(kctx, KCTX_COMPAT)) &&
+			kbase_ctx_flag(kctx, KCTX_FORCE_SAME_VA)) {
 		/* force SAME_VA if a 64-bit client */
 		flags |= BASE_MEM_SAME_VA;
 	}
-#endif
 
 	reg = kbase_mem_alloc(kctx, alloc->in.va_pages,
 			alloc->in.commit_pages,
@@ -1441,6 +729,17 @@ static int kbase_api_mem_find_cpu_offset(struct kbase_context *kctx,
 			&find->out.offset);
 }
 
+static int kbase_api_mem_find_gpu_start_and_offset(struct kbase_context *kctx,
+		union kbase_ioctl_mem_find_gpu_start_and_offset *find)
+{
+	return kbasep_find_enclosing_gpu_mapping_start_and_offset(
+			kctx,
+			find->in.gpu_addr,
+			find->in.size,
+			&find->out.start,
+			&find->out.offset);
+}
+
 static int kbase_api_get_context_id(struct kbase_context *kctx,
 		struct kbase_ioctl_get_context_id *info)
 {
@@ -1478,6 +777,9 @@ static int kbase_api_mem_alias(struct kbase_context *kctx,
 	if (alias->in.nents == 0 || alias->in.nents > 2048)
 		return -EINVAL;
 
+	if (alias->in.stride > (U64_MAX / 2048))
+		return -EINVAL;
+
 	ai = vmalloc(sizeof(*ai) * alias->in.nents);
 	if (!ai)
 		return -ENOMEM;
@@ -1616,6 +918,74 @@ static int kbase_api_soft_event_update(struct kbase_context *kctx,
 	return kbase_soft_event_update(kctx, update->event, update->new_status);
 }
 
+static int kbase_api_sticky_resource_map(struct kbase_context *kctx,
+		struct kbase_ioctl_sticky_resource_map *map)
+{
+	int ret;
+	u64 i;
+	u64 gpu_addr[BASE_EXT_RES_COUNT_MAX];
+
+	if (!map->count || map->count > BASE_EXT_RES_COUNT_MAX)
+		return -EOVERFLOW;
+
+	ret = copy_from_user(gpu_addr, u64_to_user_ptr(map->address),
+			sizeof(u64) * map->count);
+
+	if (ret != 0)
+		return -EFAULT;
+
+	kbase_gpu_vm_lock(kctx);
+
+	for (i = 0; i < map->count; i++) {
+		if (!kbase_sticky_resource_acquire(kctx, gpu_addr[i])) {
+			/* Invalid resource */
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	if (ret != 0) {
+		while (i > 0) {
+			i--;
+			kbase_sticky_resource_release(kctx, NULL, gpu_addr[i]);
+		}
+	}
+
+	kbase_gpu_vm_unlock(kctx);
+
+	return ret;
+}
+
+static int kbase_api_sticky_resource_unmap(struct kbase_context *kctx,
+		struct kbase_ioctl_sticky_resource_unmap *unmap)
+{
+	int ret;
+	u64 i;
+	u64 gpu_addr[BASE_EXT_RES_COUNT_MAX];
+
+	if (!unmap->count || unmap->count > BASE_EXT_RES_COUNT_MAX)
+		return -EOVERFLOW;
+
+	ret = copy_from_user(gpu_addr, u64_to_user_ptr(unmap->address),
+			sizeof(u64) * unmap->count);
+
+	if (ret != 0)
+		return -EFAULT;
+
+	kbase_gpu_vm_lock(kctx);
+
+	for (i = 0; i < unmap->count; i++) {
+		if (!kbase_sticky_resource_release(kctx, NULL, gpu_addr[i])) {
+			/* Invalid resource, but we keep going anyway */
+			ret = -EINVAL;
+		}
+	}
+
+	kbase_gpu_vm_unlock(kctx);
+
+	return ret;
+}
+
 #if MALI_UNIT_TEST
 static int kbase_api_tlstream_test(struct kbase_context *kctx,
 		struct kbase_ioctl_tlstream_test *test)
@@ -1697,20 +1067,6 @@ static long kbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	struct kbase_device *kbdev = kctx->kbdev;
 	void __user *uarg = (void __user *)arg;
 
-	/* The UK ioctl values overflow the cmd field causing the type to be
-	 * incremented
-	 */
-	if (_IOC_TYPE(cmd) == LINUX_UK_BASE_MAGIC+2)
-		return kbase_legacy_ioctl(filp, cmd, arg);
-
-	/* The UK version check IOCTL doesn't overflow the cmd field, so is
-	 * handled separately here
-	 */
-	if (cmd == _IOC(_IOC_READ|_IOC_WRITE, LINUX_UK_BASE_MAGIC,
-				UKP_FUNC_ID_CHECK_VERSION,
-				sizeof(struct uku_version_check_args)))
-		return kbase_legacy_ioctl(filp, cmd, arg);
-
 	/* Only these ioctls are available until setup is complete */
 	switch (cmd) {
 		KBASE_HANDLE_IOCTL_INOUT(KBASE_IOCTL_VERSION_CHECK,
@@ -1769,6 +1125,9 @@ static long kbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		KBASE_HANDLE_IOCTL_INOUT(KBASE_IOCTL_MEM_FIND_CPU_OFFSET,
 				kbase_api_mem_find_cpu_offset,
 				union kbase_ioctl_mem_find_cpu_offset);
+		KBASE_HANDLE_IOCTL_INOUT(KBASE_IOCTL_MEM_FIND_GPU_START_AND_OFFSET,
+				kbase_api_mem_find_gpu_start_and_offset,
+				union kbase_ioctl_mem_find_gpu_start_and_offset);
 		KBASE_HANDLE_IOCTL_OUT(KBASE_IOCTL_GET_CONTEXT_ID,
 				kbase_api_get_context_id,
 				struct kbase_ioctl_get_context_id);
@@ -1804,6 +1163,21 @@ static long kbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		KBASE_HANDLE_IOCTL_IN(KBASE_IOCTL_SOFT_EVENT_UPDATE,
 				kbase_api_soft_event_update,
 				struct kbase_ioctl_soft_event_update);
+#ifdef CONFIG_MALI_JOB_DUMP
+		KBASE_HANDLE_IOCTL(KBASE_IOCTL_CINSTR_GWT_START,
+				kbase_gpu_gwt_start);
+		KBASE_HANDLE_IOCTL(KBASE_IOCTL_CINSTR_GWT_STOP,
+				kbase_gpu_gwt_stop);
+		KBASE_HANDLE_IOCTL_INOUT(KBASE_IOCTL_CINSTR_GWT_DUMP,
+				kbase_gpu_gwt_dump,
+				union kbase_ioctl_cinstr_gwt_dump);
+#endif
+		KBASE_HANDLE_IOCTL_IN(KBASE_IOCTL_STICKY_RESOURCE_MAP,
+				kbase_api_sticky_resource_map,
+				struct kbase_ioctl_sticky_resource_map);
+		KBASE_HANDLE_IOCTL_IN(KBASE_IOCTL_STICKY_RESOURCE_UNMAP,
+				kbase_api_sticky_resource_unmap,
+				struct kbase_ioctl_sticky_resource_unmap);
 
 #if MALI_UNIT_TEST
 		KBASE_HANDLE_IOCTL_IN(KBASE_IOCTL_TLSTREAM_TEST,
@@ -1890,242 +1264,6 @@ static int kbase_check_flags(int flags)
 	return 0;
 }
 
-
-/**
- * align_and_check - Align the specified pointer to the provided alignment and
- *                   check that it is still in range.
- * @gap_end:        Highest possible start address for allocation (end of gap in
- *                  address space)
- * @gap_start:      Start address of current memory area / gap in address space
- * @info:           vm_unmapped_area_info structure passed to caller, containing
- *                  alignment, length and limits for the allocation
- * @is_shader_code: True if the allocation is for shader code (which has
- *                  additional alignment requirements)
- *
- * Return: true if gap_end is now aligned correctly and is still in range,
- *         false otherwise
- */
-static bool align_and_check(unsigned long *gap_end, unsigned long gap_start,
-		struct vm_unmapped_area_info *info, bool is_shader_code)
-{
-	/* Compute highest gap address at the desired alignment */
-	(*gap_end) -= info->length;
-	(*gap_end) -= (*gap_end - info->align_offset) & info->align_mask;
-
-	if (is_shader_code) {
-		/* Check for 4GB boundary */
-		if (0 == (*gap_end & BASE_MEM_MASK_4GB))
-			(*gap_end) -= (info->align_offset ? info->align_offset :
-					info->length);
-		if (0 == ((*gap_end + info->length) & BASE_MEM_MASK_4GB))
-			(*gap_end) -= (info->align_offset ? info->align_offset :
-					info->length);
-
-		if (!(*gap_end & BASE_MEM_MASK_4GB) || !((*gap_end +
-				info->length) & BASE_MEM_MASK_4GB))
-			return false;
-	}
-
-
-	if ((*gap_end < info->low_limit) || (*gap_end < gap_start))
-		return false;
-
-
-	return true;
-}
-
-/* The following function is taken from the kernel and just
- * renamed. As it's not exported to modules we must copy-paste it here.
- */
-
-static unsigned long kbase_unmapped_area_topdown(struct vm_unmapped_area_info
-		*info, bool is_shader_code)
-{
-	struct mm_struct *mm = current->mm;
-	struct vm_area_struct *vma;
-	unsigned long length, low_limit, high_limit, gap_start, gap_end;
-
-	/* Adjust search length to account for worst case alignment overhead */
-	length = info->length + info->align_mask;
-	if (length < info->length)
-		return -ENOMEM;
-
-	/*
-	 * Adjust search limits by the desired length.
-	 * See implementation comment at top of unmapped_area().
-	 */
-	gap_end = info->high_limit;
-	if (gap_end < length)
-		return -ENOMEM;
-	high_limit = gap_end - length;
-
-	if (info->low_limit > high_limit)
-		return -ENOMEM;
-	low_limit = info->low_limit + length;
-
-	/* Check highest gap, which does not precede any rbtree node */
-	gap_start = mm->highest_vm_end;
-	if (gap_start <= high_limit) {
-		if (align_and_check(&gap_end, gap_start, info, is_shader_code))
-			return gap_end;
-	}
-
-	/* Check if rbtree root looks promising */
-	if (RB_EMPTY_ROOT(&mm->mm_rb))
-		return -ENOMEM;
-	vma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);
-	if (vma->rb_subtree_gap < length)
-		return -ENOMEM;
-
-	while (true) {
-		/* Visit right subtree if it looks promising */
-		gap_start = vma->vm_prev ? vma->vm_prev->vm_end : 0;
-		if (gap_start <= high_limit && vma->vm_rb.rb_right) {
-			struct vm_area_struct *right =
-				rb_entry(vma->vm_rb.rb_right,
-					 struct vm_area_struct, vm_rb);
-			if (right->rb_subtree_gap >= length) {
-				vma = right;
-				continue;
-			}
-		}
-
-check_current:
-		/* Check if current node has a suitable gap */
-		gap_end = vma->vm_start;
-		if (gap_end < low_limit)
-			return -ENOMEM;
-		if (gap_start <= high_limit && gap_end - gap_start >= length) {
-			/* We found a suitable gap. Clip it with the original
-			 * high_limit. */
-			if (gap_end > info->high_limit)
-				gap_end = info->high_limit;
-
-			if (align_and_check(&gap_end, gap_start, info,
-					is_shader_code))
-				return gap_end;
-		}
-
-		/* Visit left subtree if it looks promising */
-		if (vma->vm_rb.rb_left) {
-			struct vm_area_struct *left =
-				rb_entry(vma->vm_rb.rb_left,
-					 struct vm_area_struct, vm_rb);
-			if (left->rb_subtree_gap >= length) {
-				vma = left;
-				continue;
-			}
-		}
-
-		/* Go back up the rbtree to find next candidate node */
-		while (true) {
-			struct rb_node *prev = &vma->vm_rb;
-			if (!rb_parent(prev))
-				return -ENOMEM;
-			vma = rb_entry(rb_parent(prev),
-				       struct vm_area_struct, vm_rb);
-			if (prev == vma->vm_rb.rb_right) {
-				gap_start = vma->vm_prev ?
-					vma->vm_prev->vm_end : 0;
-				goto check_current;
-			}
-		}
-	}
-
-	return -ENOMEM;
-}
-
-static unsigned long kbase_get_unmapped_area(struct file *filp,
-		const unsigned long addr, const unsigned long len,
-		const unsigned long pgoff, const unsigned long flags)
-{
-	/* based on get_unmapped_area, but simplified slightly due to that some
-	 * values are known in advance */
-	struct kbase_context *kctx = filp->private_data;
-	struct mm_struct *mm = current->mm;
-	struct vm_unmapped_area_info info;
-	unsigned long align_offset = 0;
-	unsigned long align_mask = 0;
-	unsigned long high_limit = mm->mmap_base;
-	unsigned long low_limit = PAGE_SIZE;
-	int cpu_va_bits = BITS_PER_LONG;
-	int gpu_pc_bits =
-	      kctx->kbdev->gpu_props.props.core_props.log2_program_counter_size;
-	bool is_shader_code = false;
-	unsigned long ret;
-
-	/* err on fixed address */
-	if ((flags & MAP_FIXED) || addr)
-		return -EINVAL;
-
-#ifdef CONFIG_64BIT
-	/* too big? */
-	if (len > TASK_SIZE - SZ_2M)
-		return -ENOMEM;
-
-	if (!kbase_ctx_flag(kctx, KCTX_COMPAT)) {
-
-		if (kbase_hw_has_feature(kctx->kbdev,
-						BASE_HW_FEATURE_33BIT_VA)) {
-			high_limit = kctx->same_va_end << PAGE_SHIFT;
-		} else {
-			high_limit = min_t(unsigned long, mm->mmap_base,
-					(kctx->same_va_end << PAGE_SHIFT));
-			if (len >= SZ_2M) {
-				align_offset = SZ_2M;
-				align_mask = SZ_2M - 1;
-			}
-		}
-
-		low_limit = SZ_2M;
-	} else {
-		cpu_va_bits = 32;
-	}
-#endif /* CONFIG_64BIT */
-	if ((PFN_DOWN(BASE_MEM_COOKIE_BASE) <= pgoff) &&
-		(PFN_DOWN(BASE_MEM_FIRST_FREE_ADDRESS) > pgoff)) {
-			int cookie = pgoff - PFN_DOWN(BASE_MEM_COOKIE_BASE);
-
-			if (!kctx->pending_regions[cookie])
-				return -EINVAL;
-
-			if (!(kctx->pending_regions[cookie]->flags &
-							KBASE_REG_GPU_NX)) {
-				if (cpu_va_bits > gpu_pc_bits) {
-					align_offset = 1ULL << gpu_pc_bits;
-					align_mask = align_offset - 1;
-					is_shader_code = true;
-				}
-			}
-#ifndef CONFIG_64BIT
-	} else {
-		return current->mm->get_unmapped_area(filp, addr, len, pgoff,
-						      flags);
-#endif
-	}
-
-	info.flags = 0;
-	info.length = len;
-	info.low_limit = low_limit;
-	info.high_limit = high_limit;
-	info.align_offset = align_offset;
-	info.align_mask = align_mask;
-
-	ret = kbase_unmapped_area_topdown(&info, is_shader_code);
-
-	if (IS_ERR_VALUE(ret) && high_limit == mm->mmap_base &&
-			high_limit < (kctx->same_va_end << PAGE_SHIFT)) {
-		/* Retry above mmap_base */
-		info.low_limit = mm->mmap_base;
-		info.high_limit = min_t(u64, TASK_SIZE,
-					(kctx->same_va_end << PAGE_SHIFT));
-
-		ret = kbase_unmapped_area_topdown(&info, is_shader_code);
-	}
-
-	return ret;
-}
-
 static const struct file_operations kbase_fops = {
 	.owner = THIS_MODULE,
 	.open = kbase_open,
@@ -2139,18 +1277,6 @@ static const struct file_operations kbase_fops = {
 	.get_unmapped_area = kbase_get_unmapped_area,
 };
 
-#ifndef CONFIG_MALI_BIFROST_NO_MALI
-void kbase_os_reg_write(struct kbase_device *kbdev, u16 offset, u32 value)
-{
-	writel(value, kbdev->reg + offset);
-}
-
-u32 kbase_os_reg_read(struct kbase_device *kbdev, u16 offset)
-{
-	return readl(kbdev->reg + offset);
-}
-#endif /* !CONFIG_MALI_BIFROST_NO_MALI */
-
 /**
  * show_policy - Show callback for the power_policy sysfs file.
  *
@@ -3170,6 +2296,8 @@ static ssize_t kbase_show_gpuinfo(struct device *dev,
 		  .name = "Mali-G72" },
 		{ .id = GPU_ID2_PRODUCT_TSIX >> GPU_ID_VERSION_PRODUCT_ID_SHIFT,
 		  .name = "Mali-G51" },
+		{ .id = GPU_ID2_PRODUCT_TNOX >> GPU_ID_VERSION_PRODUCT_ID_SHIFT,
+		  .name = "Mali-TNOx" },
 	};
 	const char *product_name = "(Unknown Mali GPU)";
 	struct kbase_device *kbdev;
@@ -3906,7 +3034,7 @@ static int power_control_init(struct platform_device *pdev)
 	}
 #endif /* LINUX_VERSION_CODE >= 3, 12, 0 */
 
-	kbdev->clock = clk_get(kbdev->dev, "clk_mali");
+	kbdev->clock = of_clk_get(kbdev->dev->of_node, 0);
 	if (IS_ERR_OR_NULL(kbdev->clock)) {
 		err = PTR_ERR(kbdev->clock);
 		kbdev->clock = NULL;
@@ -4324,10 +3452,6 @@ static int kbase_platform_device_remove(struct platform_device *pdev)
 		kbase_debug_job_fault_dev_term(kbdev);
 		kbdev->inited_subsys &= ~inited_job_fault;
 	}
-	if (kbdev->inited_subsys & inited_vinstr) {
-		kbase_vinstr_term(kbdev->vinstr_ctx);
-		kbdev->inited_subsys &= ~inited_vinstr;
-	}
 
 #ifdef CONFIG_MALI_BIFROST_DEVFREQ
 	if (kbdev->inited_subsys & inited_devfreq) {
@@ -4336,6 +3460,11 @@ static int kbase_platform_device_remove(struct platform_device *pdev)
 	}
 #endif
 
+	if (kbdev->inited_subsys & inited_vinstr) {
+		kbase_vinstr_term(kbdev->vinstr_ctx);
+		kbdev->inited_subsys &= ~inited_vinstr;
+	}
+
 	if (kbdev->inited_subsys & inited_backend_late) {
 		kbase_backend_late_term(kbdev);
 		kbdev->inited_subsys &= ~inited_backend_late;
@@ -4369,11 +3498,6 @@ static int kbase_platform_device_remove(struct platform_device *pdev)
 		kbdev->inited_subsys &= ~inited_mem;
 	}
 
-	if (kbdev->inited_subsys & inited_pm_runtime_init) {
-		kbdev->pm.callback_power_runtime_term(kbdev);
-		kbdev->inited_subsys &= ~inited_pm_runtime_init;
-	}
-
 	if (kbdev->inited_subsys & inited_ctx_sched) {
 		kbase_ctx_sched_term(kbdev);
 		kbdev->inited_subsys &= ~inited_ctx_sched;
@@ -4433,14 +3557,6 @@ static int kbase_platform_device_probe(struct platform_device *pdev)
 	const struct list_head *dev_list;
 	int err = 0;
 
-#ifdef CONFIG_OF
-	err = kbase_platform_early_init();
-	if (err) {
-		dev_err(&pdev->dev, "Early platform initialization failed\n");
-		kbase_platform_device_remove(pdev);
-		return err;
-	}
-#endif
 	kbdev = kbase_device_alloc();
 	if (!kbdev) {
 		dev_err(&pdev->dev, "Allocate device failed\n");
@@ -4506,10 +3622,15 @@ static int kbase_platform_device_probe(struct platform_device *pdev)
 
 	kbase_disjoint_init(kbdev);
 
-	/* obtain min/max configured gpu frequencies */
+	/* obtain max configured gpu frequency, if devfreq is enabled then
+	 * this will be overridden by the highest operating point found
+	 */
 	core_props = &(kbdev->gpu_props.props.core_props);
-	core_props->gpu_freq_khz_min = GPU_FREQ_KHZ_MIN;
+#ifdef GPU_FREQ_KHZ_MAX
 	core_props->gpu_freq_khz_max = GPU_FREQ_KHZ_MAX;
+#else
+	core_props->gpu_freq_khz_max = DEFAULT_GPU_FREQ_KHZ_MAX;
+#endif
 
 	err = kbase_device_init(kbdev);
 	if (err) {
@@ -4528,17 +3649,6 @@ static int kbase_platform_device_probe(struct platform_device *pdev)
 	}
 	kbdev->inited_subsys |= inited_ctx_sched;
 
-	if (kbdev->pm.callback_power_runtime_init) {
-		err = kbdev->pm.callback_power_runtime_init(kbdev);
-		if (err) {
-			dev_err(kbdev->dev,
-				"Runtime PM initialization failed\n");
-			kbase_platform_device_remove(pdev);
-			return err;
-		}
-		kbdev->inited_subsys |= inited_pm_runtime_init;
-	}
-
 	err = kbase_mem_init(kbdev);
 	if (err) {
 		dev_err(kbdev->dev, "Memory subsystem initialization failed\n");
@@ -4885,10 +3995,6 @@ static int __init kbase_driver_init(void)
 {
 	int ret;
 
-	ret = kbase_platform_early_init();
-	if (ret)
-		return ret;
-
 	ret = kbase_platform_register();
 	if (ret)
 		return ret;
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_ctx_sched.c b/drivers/gpu/arm/bifrost/mali_kbase_ctx_sched.c
index e2f7baabad43..85a6afdb4ef3 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_ctx_sched.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_ctx_sched.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 #include <mali_kbase_config_defaults.h>
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_ctx_sched.h b/drivers/gpu/arm/bifrost/mali_kbase_ctx_sched.h
index 2330d48c8e51..400ee623055d 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_ctx_sched.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_ctx_sched.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_CTX_SCHED_H_
 #define _KBASE_CTX_SCHED_H_
 
@@ -28,7 +33,7 @@
  * The initial implementation of the Context Scheduler does not schedule
  * contexts. Instead it relies on the Job Scheduler to make decisions of
  * when to schedule/evict contexts if address spaces are starved. In the
- * future, once an interface between the CS and JS have been devised to
+ * future, once an interface between the CS and JS has been devised to
  * provide enough information about how each context is consuming GPU resources,
  * those decisions can be made in the CS itself, thereby reducing duplicated
  * code.
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_debug.c b/drivers/gpu/arm/bifrost/mali_kbase_debug.c
index fb57ac2e31ad..118f787fb74c 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_debug.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_debug.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include <mali_kbase.h>
 
 static struct kbasep_debug_assert_cb kbasep_debug_assert_registered_cb = {
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_debug.h b/drivers/gpu/arm/bifrost/mali_kbase_debug.h
index 31b754c5507b..f33413908405 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_debug.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_debug.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #ifndef _KBASE_DEBUG_H
 #define _KBASE_DEBUG_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_debug_job_fault.c b/drivers/gpu/arm/bifrost/mali_kbase_debug_job_fault.c
index f29430ddf8f9..d2c09d6658f2 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_debug_job_fault.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_debug_job_fault.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 #include <linux/spinlock.h>
 #include <mali_kbase_hwaccess_jm.h>
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_debug_job_fault.h b/drivers/gpu/arm/bifrost/mali_kbase_debug_job_fault.h
index a2bf8983c37c..f5ab0a44c1d4 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_debug_job_fault.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_debug_job_fault.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_DEBUG_JOB_FAULT_H
 #define _KBASE_DEBUG_JOB_FAULT_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_debug_mem_view.c b/drivers/gpu/arm/bifrost/mali_kbase_debug_mem_view.c
index aa271566e917..d2c57cab1177 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_debug_mem_view.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_debug_mem_view.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Debugfs interface to dump the memory visible to the GPU
  */
@@ -299,7 +304,7 @@ void kbase_debug_mem_view_init(struct file *kctx_file)
 {
 	struct kbase_context *kctx = kctx_file->private_data;
 
-	debugfs_create_file("mem_view", S_IRUGO, kctx->kctx_dentry, kctx_file,
+	debugfs_create_file("mem_view", S_IRUSR, kctx->kctx_dentry, kctx_file,
 			&kbase_debug_mem_view_fops);
 }
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_debug_mem_view.h b/drivers/gpu/arm/bifrost/mali_kbase_debug_mem_view.h
index 20ab51a776c6..886ca9448cf5 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_debug_mem_view.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_debug_mem_view.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_DEBUG_MEM_VIEW_H
 #define _KBASE_DEBUG_MEM_VIEW_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_defs.h b/drivers/gpu/arm/bifrost/mali_kbase_defs.h
index d957c1461440..c53d9eb002a4 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_defs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_defs.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_defs.h
  *
@@ -34,6 +39,7 @@
 #include <mali_kbase_mmu_hw.h>
 #include <mali_kbase_instr_defs.h>
 #include <mali_kbase_pm.h>
+#include <mali_kbase_gpuprops_types.h>
 #include <protected_mode_switcher.h>
 
 #include <linux/atomic.h>
@@ -47,10 +53,6 @@
 #endif
 
 
-#ifdef CONFIG_KDS
-#include <linux/kds.h>
-#endif				/* CONFIG_KDS */
-
 #if defined(CONFIG_SYNC)
 #include <sync.h>
 #else
@@ -439,12 +441,9 @@ struct kbase_jd_atom {
 	u32 device_nr;
 	u64 affinity;
 	u64 jc;
+	/* Copy of data read from the user space buffer that jc points to */
+	void *softjob_data;
 	enum kbase_atom_coreref_state coreref_state;
-#ifdef CONFIG_KDS
-	struct list_head node;
-	struct kds_resource_set *kds_rset;
-	bool kds_dep_satisfied;
-#endif				/* CONFIG_KDS */
 #if defined(CONFIG_SYNC)
 	/* Stores either an input or output fence, depending on soft-job type */
 	struct sync_fence *fence;
@@ -521,10 +520,6 @@ struct kbase_jd_atom {
 	/* Note: refer to kbasep_js_atom_retained_state, which will take a copy of some of the following members */
 	enum base_jd_event_code event_code;
 	base_jd_core_req core_req;	    /**< core requirements */
-	/** Job Slot to retry submitting to if submission from IRQ handler failed
-	 *
-	 * NOTE: see if this can be unified into the another member e.g. the event */
-	int retry_submit_on_slot;
 
 	u32 ticks;
 	/* JS atom priority with respect to other atoms on its kctx. */
@@ -655,9 +650,6 @@ struct kbase_jd_context {
 	u32 *tb;
 	size_t tb_wrap_offset;
 
-#ifdef CONFIG_KDS
-	struct kds_callback kds_cb;
-#endif				/* CONFIG_KDS */
 #ifdef CONFIG_GPU_TRACEPOINTS
 	atomic_t work_id;
 #endif
@@ -1287,6 +1279,14 @@ struct kbase_device {
 
 	/* Current serialization mode. See KBASE_SERIALIZE_* for details */
 	u8 serialize_jobs;
+
+#ifdef CONFIG_MALI_JOB_DUMP
+	/* Used to backup status of job serialization mode
+	 * when we use GWT and restore when GWT is disabled.
+	 * GWT uses full serialization mode.
+	 */
+	u8 backup_serialize_jobs;
+#endif
 };
 
 /**
@@ -1343,6 +1343,14 @@ struct jsctx_queue {
  * context, to disable use of implicit dma-buf fences. This is used to avoid
  * potential synchronization deadlocks.
  *
+ * @KCTX_FORCE_SAME_VA: Set when BASE_MEM_SAME_VA should be forced on memory
+ * allocations. For 64-bit clients it is enabled by default, and disabled by
+ * default on 32-bit clients. Being able to clear this flag is only used for
+ * testing purposes of the custom zone allocation on 64-bit user-space builds,
+ * where we also require more control than is available through e.g. the JIT
+ * allocation mechanism. However, the 64-bit user-space client must still
+ * reserve a JIT region using KBASE_IOCTL_MEM_JIT_INIT
+ *
  * All members need to be separate bits. This enum is intended for use in a
  * bitmask where multiple values get OR-ed together.
  */
@@ -1358,6 +1366,7 @@ enum kbase_context_flags {
 	KCTX_SCHEDULED = 1U << 8,
 	KCTX_DYING = 1U << 9,
 	KCTX_NO_IMPLICIT_SYNC = 1U << 10,
+	KCTX_FORCE_SAME_VA = 1U << 11,
 };
 
 struct kbase_sub_alloc {
@@ -1420,9 +1429,6 @@ struct kbase_context {
 
 	struct list_head waiting_soft_jobs;
 	spinlock_t waiting_soft_jobs_lock;
-#ifdef CONFIG_KDS
-	struct list_head waiting_kds_resource;
-#endif
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	struct {
 		struct list_head waiting_resource;
@@ -1545,8 +1551,50 @@ struct kbase_context {
 
 	/* Current age count, used to determine age for newly submitted atoms */
 	u32 age_count;
+
+#ifdef CONFIG_MALI_JOB_DUMP
+	/* Used for tracking GPU writes.
+	 * (protected by kbase_context.reg_lock)
+	 */
+	bool gwt_enabled;
+
+	/* Simple sticky bit flag to know if GWT was ever enabled
+	 * (protected by kbase_context.reg_lock)
+	 */
+	bool gwt_was_enabled;
+
+	/* Current list of GPU writes.
+	 * (protected by kbase_context.reg_lock)
+	 */
+	struct list_head gwt_current_list;
+
+	 /* Snapshot of list of GPU writes for sending to user space. */
+	struct list_head gwt_snapshot_list;
+
+#endif
+};
+
+#ifdef CONFIG_MALI_JOB_DUMP
+/**
+ * struct kbasep_gwt_list_element - Structure used to collect GPU
+ *                                  write faults.
+ * @link:                           List head for adding write faults.
+ * @handle:                         The handle for the modified region.
+ * @offset:                         The offset in pages of the modified
+ *                                  part of the region.
+ * @num_pages:                      The number of pages modified.
+ *
+ * Using this structure all GPU write faults are stored in a list.
+ */
+struct kbasep_gwt_list_element {
+	struct list_head link;
+	u64 handle;
+	u64 offset;
+	u64 num_pages;
 };
 
+#endif
+
 /**
  * struct kbase_ctx_ext_res_meta - Structure which binds an external resource
  *                                 to a @kbase_context.
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_device.c b/drivers/gpu/arm/bifrost/mali_kbase_device.c
index 2d11f11f3be0..8aaf4065dd6c 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_device.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_device.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Base kernel device APIs
  */
@@ -94,7 +99,6 @@ static int kbase_device_as_init(struct kbase_device *kbdev, int i)
 			destroy_workqueue(kbdev->as[i].pf_wq);
 			return -EINVAL;
 		}
-		KBASE_DEBUG_ASSERT(!object_is_on_stack(poke_work));
 		INIT_WORK(poke_work, kbasep_as_do_poke);
 
 		hrtimer_init(poke_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_disjoint_events.c b/drivers/gpu/arm/bifrost/mali_kbase_disjoint_events.c
index f70bcccf4050..68eb4ed0715d 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_disjoint_events.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_disjoint_events.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Base kernel disjoint events helper functions
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_dma_fence.c b/drivers/gpu/arm/bifrost/mali_kbase_dma_fence.c
index 8a571266534b..9af59bb56d1c 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_dma_fence.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_dma_fence.c
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /* Include mali_kbase_dma_fence.h before checking for CONFIG_MALI_BIFROST_DMA_FENCE as
  * it will be set there.
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_dma_fence.h b/drivers/gpu/arm/bifrost/mali_kbase_dma_fence.h
index b02ea9774c4f..1adb4fa00469 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_dma_fence.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_dma_fence.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_DMA_FENCE_H_
 #define _KBASE_DMA_FENCE_H_
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_event.c b/drivers/gpu/arm/bifrost/mali_kbase_event.c
index 188148645f37..e290fceea6cd 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_event.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_event.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include <mali_kbase.h>
 #include <mali_kbase_debug.h>
 #include <mali_kbase_tlstream.h>
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_fence.c b/drivers/gpu/arm/bifrost/mali_kbase_fence.c
index fcb373372596..ac8272c900bb 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_fence.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_fence.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/atomic.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
@@ -176,8 +181,13 @@ kbase_fence_add_callback(struct kbase_jd_atom *katom,
 	err = dma_fence_add_callback(fence, &kbase_fence_cb->fence_cb,
 				     callback);
 	if (err == -ENOENT) {
-		/* Fence signaled, clear the error and return */
-		err = 0;
+		/* Fence signaled, get the completion result */
+		err = dma_fence_get_status(fence);
+
+		/* remap success completion to err code */
+		if (err == 1)
+			err = 0;
+
 		kfree(kbase_fence_cb);
 	} else if (err) {
 		kfree(kbase_fence_cb);
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_fence.h b/drivers/gpu/arm/bifrost/mali_kbase_fence.h
index 9f59d30a1e2e..25d2a933e118 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_fence.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_fence.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_FENCE_H_
 #define _KBASE_FENCE_H_
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_fence_defs.h b/drivers/gpu/arm/bifrost/mali_kbase_fence_defs.h
index d2d7c436918c..a19d7e0aff1c 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_fence_defs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_fence_defs.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_FENCE_DEFS_H_
 #define _KBASE_FENCE_DEFS_H_
 
@@ -39,11 +44,18 @@
 #define dma_fence_is_signaled(a) fence_is_signaled(a)
 #define dma_fence_add_callback(a, b, c) fence_add_callback(a, b, c)
 #define dma_fence_remove_callback(a, b) fence_remove_callback(a, b)
+#define dma_fence_get_status(a) (fence_is_signaled(a) ? (a)->status ?: 1 : 0)
 
 #else
 
 #include <linux/dma-fence.h>
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 11, 0))
+#define dma_fence_get_status(a) (dma_fence_is_signaled(a) ? \
+	(a)->status ?: 1 \
+	: 0)
+#endif
+
 #endif /* < 4.10.0 */
 
 #endif /* CONFIG_MALI_BIFROST_DMA_FENCE || CONFIG_SYNC_FILE */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator.h b/drivers/gpu/arm/bifrost/mali_kbase_gator.h
index 87697b15d986..aeaf439d3097 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gator.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /* NB taken from gator  */
 /*
  * List of possible actions to be controlled by DS-5 Streamline.
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator_api.c b/drivers/gpu/arm/bifrost/mali_kbase_gator_api.c
index 860e10159fb3..2fa68067050a 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gator_api.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator_api.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include "mali_kbase.h"
 #include "mali_kbase_hw.h"
 #include "mali_kbase_mem_linux.h"
@@ -68,6 +73,10 @@ const char * const *kbase_gator_hwcnt_init_names(uint32_t *total_counters)
 			hardware_counters = hardware_counters_mali_tSIx;
 			count = ARRAY_SIZE(hardware_counters_mali_tSIx);
 			break;
+		case GPU_ID2_PRODUCT_TNOX:
+			hardware_counters = hardware_counters_mali_tNOx;
+			count = ARRAY_SIZE(hardware_counters_mali_tNOx);
+			break;
 		default:
 			hardware_counters = NULL;
 			count = 0;
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator_api.h b/drivers/gpu/arm/bifrost/mali_kbase_gator_api.h
index ef9ac0f7b633..bd0589ed6c1a 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gator_api.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator_api.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_GATOR_API_H_
 #define _KBASE_GATOR_API_H_
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names.h b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names.h
index 24103e292453..b048db8bf834 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_GATOR_HWCNT_NAMES_H_
 #define _KBASE_GATOR_HWCNT_NAMES_H_
 
@@ -2162,6 +2167,10 @@ static const char * const hardware_counters_mali_t88x[] = {
 
 #include "mali_kbase_gator_hwcnt_names_tsix.h"
 
+#include "mali_kbase_gator_hwcnt_names_tnox.h"
+
+#include "mali_kbase_gator_hwcnt_names_tkax.h"
 
+#include "mali_kbase_gator_hwcnt_names_ttrx.h"
 
 #endif
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_thex.h b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_thex.h
index 15fd4efdc6ca..af00a6acb09b 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_thex.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_thex.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * This header was autogenerated, it should not be edited.
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tkax.h b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tkax.h
new file mode 100644
index 000000000000..1c1f6693bfb5
--- /dev/null
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tkax.h
@@ -0,0 +1,296 @@
+/*
+ *
+ * (C) COPYRIGHT 2016-2017 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ */
+
+/*
+ * This header was autogenerated, it should not be edited.
+ */
+
+#ifndef _KBASE_GATOR_HWCNT_NAMES_TKAX_H_
+#define _KBASE_GATOR_HWCNT_NAMES_TKAX_H_
+
+static const char * const hardware_counters_mali_tKAx[] = {
+	/* Performance counters for the Job Manager */
+	"",
+	"",
+	"",
+	"",
+	"TKAx_MESSAGES_SENT",
+	"TKAx_MESSAGES_RECEIVED",
+	"TKAx_GPU_ACTIVE",
+	"TKAx_IRQ_ACTIVE",
+	"TKAx_JS0_JOBS",
+	"TKAx_JS0_TASKS",
+	"TKAx_JS0_ACTIVE",
+	"",
+	"TKAx_JS0_WAIT_READ",
+	"TKAx_JS0_WAIT_ISSUE",
+	"TKAx_JS0_WAIT_DEPEND",
+	"TKAx_JS0_WAIT_FINISH",
+	"TKAx_JS1_JOBS",
+	"TKAx_JS1_TASKS",
+	"TKAx_JS1_ACTIVE",
+	"",
+	"TKAx_JS1_WAIT_READ",
+	"TKAx_JS1_WAIT_ISSUE",
+	"TKAx_JS1_WAIT_DEPEND",
+	"TKAx_JS1_WAIT_FINISH",
+	"TKAx_JS2_JOBS",
+	"TKAx_JS2_TASKS",
+	"TKAx_JS2_ACTIVE",
+	"",
+	"TKAx_JS2_WAIT_READ",
+	"TKAx_JS2_WAIT_ISSUE",
+	"TKAx_JS2_WAIT_DEPEND",
+	"TKAx_JS2_WAIT_FINISH",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+
+	/* Performance counters for the Tiler */
+	"",
+	"",
+	"",
+	"",
+	"TKAx_TILER_ACTIVE",
+	"TKAx_JOBS_PROCESSED",
+	"TKAx_TRIANGLES",
+	"TKAx_LINES",
+	"TKAx_POINTS",
+	"TKAx_FRONT_FACING",
+	"TKAx_BACK_FACING",
+	"TKAx_PRIM_VISIBLE",
+	"TKAx_PRIM_CULLED",
+	"TKAx_PRIM_CLIPPED",
+	"TKAx_PRIM_SAT_CULLED",
+	"TKAx_BIN_ALLOC_INIT",
+	"TKAx_BIN_ALLOC_OVERFLOW",
+	"TKAx_BUS_READ",
+	"",
+	"TKAx_BUS_WRITE",
+	"TKAx_LOADING_DESC",
+	"TKAx_IDVS_POS_SHAD_REQ",
+	"TKAx_IDVS_POS_SHAD_WAIT",
+	"TKAx_IDVS_POS_SHAD_STALL",
+	"TKAx_IDVS_POS_FIFO_FULL",
+	"TKAx_PREFETCH_STALL",
+	"TKAx_VCACHE_HIT",
+	"TKAx_VCACHE_MISS",
+	"TKAx_VCACHE_LINE_WAIT",
+	"TKAx_VFETCH_POS_READ_WAIT",
+	"TKAx_VFETCH_VERTEX_WAIT",
+	"TKAx_VFETCH_STALL",
+	"TKAx_PRIMASSY_STALL",
+	"TKAx_BBOX_GEN_STALL",
+	"TKAx_IDVS_VBU_HIT",
+	"TKAx_IDVS_VBU_MISS",
+	"TKAx_IDVS_VBU_LINE_DEALLOCATE",
+	"TKAx_IDVS_VAR_SHAD_REQ",
+	"TKAx_IDVS_VAR_SHAD_STALL",
+	"TKAx_BINNER_STALL",
+	"TKAx_ITER_STALL",
+	"TKAx_COMPRESS_MISS",
+	"TKAx_COMPRESS_STALL",
+	"TKAx_PCACHE_HIT",
+	"TKAx_PCACHE_MISS",
+	"TKAx_PCACHE_MISS_STALL",
+	"TKAx_PCACHE_EVICT_STALL",
+	"TKAx_PMGR_PTR_WR_STALL",
+	"TKAx_PMGR_PTR_RD_STALL",
+	"TKAx_PMGR_CMD_WR_STALL",
+	"TKAx_WRBUF_ACTIVE",
+	"TKAx_WRBUF_HIT",
+	"TKAx_WRBUF_MISS",
+	"TKAx_WRBUF_NO_FREE_LINE_STALL",
+	"TKAx_WRBUF_NO_AXI_ID_STALL",
+	"TKAx_WRBUF_AXI_STALL",
+	"",
+	"",
+	"",
+	"TKAx_UTLB_TRANS",
+	"TKAx_UTLB_TRANS_HIT",
+	"TKAx_UTLB_TRANS_STALL",
+	"TKAx_UTLB_TRANS_MISS_DELAY",
+	"TKAx_UTLB_MMU_REQ",
+
+	/* Performance counters for the Shader Core */
+	"",
+	"",
+	"",
+	"",
+	"TKAx_FRAG_ACTIVE",
+	"TKAx_FRAG_PRIMITIVES",
+	"TKAx_FRAG_PRIM_RAST",
+	"TKAx_FRAG_FPK_ACTIVE",
+	"TKAx_FRAG_STARVING",
+	"TKAx_FRAG_WARPS",
+	"TKAx_FRAG_PARTIAL_WARPS",
+	"TKAx_FRAG_QUADS_RAST",
+	"TKAx_FRAG_QUADS_EZS_TEST",
+	"TKAx_FRAG_QUADS_EZS_UPDATE",
+	"TKAx_FRAG_QUADS_EZS_KILL",
+	"TKAx_FRAG_LZS_TEST",
+	"TKAx_FRAG_LZS_KILL",
+	"TKAx_WARP_REG_SIZE_64",
+	"TKAx_FRAG_PTILES",
+	"TKAx_FRAG_TRANS_ELIM",
+	"TKAx_QUAD_FPK_KILLER",
+	"TKAx_FULL_QUAD_WARPS",
+	"TKAx_COMPUTE_ACTIVE",
+	"TKAx_COMPUTE_TASKS",
+	"TKAx_COMPUTE_WARPS",
+	"TKAx_COMPUTE_STARVING",
+	"TKAx_EXEC_CORE_ACTIVE",
+	"TKAx_EXEC_ACTIVE",
+	"TKAx_EXEC_INSTR_COUNT",
+	"TKAx_EXEC_INSTR_DIVERGED",
+	"TKAx_EXEC_INSTR_STARVING",
+	"TKAx_ARITH_INSTR_SINGLE_FMA",
+	"TKAx_ARITH_INSTR_DOUBLE",
+	"TKAx_ARITH_INSTR_MSG",
+	"TKAx_ARITH_INSTR_MSG_ONLY",
+	"TKAx_TEX_MSGI_NUM_QUADS",
+	"TKAx_TEX_DFCH_NUM_PASSES",
+	"TKAx_TEX_DFCH_NUM_PASSES_MISS",
+	"TKAx_TEX_DFCH_NUM_PASSES_MIP_MAP",
+	"TKAx_TEX_TIDX_NUM_SPLIT_MIP_MAP",
+	"TKAx_TEX_TFCH_NUM_LINES_FETCHED",
+	"TKAx_TEX_TFCH_NUM_LINES_FETCHED_BLOCK",
+	"TKAx_TEX_TFCH_NUM_OPERATIONS",
+	"TKAx_TEX_FILT_NUM_OPERATIONS",
+	"TKAx_LS_MEM_READ_FULL",
+	"TKAx_LS_MEM_READ_SHORT",
+	"TKAx_LS_MEM_WRITE_FULL",
+	"TKAx_LS_MEM_WRITE_SHORT",
+	"TKAx_LS_MEM_ATOMIC",
+	"TKAx_VARY_INSTR",
+	"TKAx_VARY_SLOT_32",
+	"TKAx_VARY_SLOT_16",
+	"TKAx_ATTR_INSTR",
+	"TKAx_ARITH_INSTR_FP_MUL",
+	"TKAx_BEATS_RD_FTC",
+	"TKAx_BEATS_RD_FTC_EXT",
+	"TKAx_BEATS_RD_LSC",
+	"TKAx_BEATS_RD_LSC_EXT",
+	"TKAx_BEATS_RD_TEX",
+	"TKAx_BEATS_RD_TEX_EXT",
+	"TKAx_BEATS_RD_OTHER",
+	"TKAx_BEATS_WR_LSC_WB",
+	"TKAx_BEATS_WR_TIB",
+	"TKAx_BEATS_WR_LSC_OTHER",
+
+	/* Performance counters for the Memory System */
+	"",
+	"",
+	"",
+	"",
+	"TKAx_MMU_REQUESTS",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"TKAx_L2_RD_MSG_IN",
+	"TKAx_L2_RD_MSG_IN_STALL",
+	"TKAx_L2_WR_MSG_IN",
+	"TKAx_L2_WR_MSG_IN_STALL",
+	"TKAx_L2_SNP_MSG_IN",
+	"TKAx_L2_SNP_MSG_IN_STALL",
+	"TKAx_L2_RD_MSG_OUT",
+	"TKAx_L2_RD_MSG_OUT_STALL",
+	"TKAx_L2_WR_MSG_OUT",
+	"TKAx_L2_ANY_LOOKUP",
+	"TKAx_L2_READ_LOOKUP",
+	"TKAx_L2_WRITE_LOOKUP",
+	"TKAx_L2_EXT_SNOOP_LOOKUP",
+	"TKAx_L2_EXT_READ",
+	"TKAx_L2_EXT_READ_NOSNP",
+	"TKAx_L2_EXT_READ_UNIQUE",
+	"TKAx_L2_EXT_READ_BEATS",
+	"TKAx_L2_EXT_AR_STALL",
+	"TKAx_L2_EXT_AR_CNT_Q1",
+	"TKAx_L2_EXT_AR_CNT_Q2",
+	"TKAx_L2_EXT_AR_CNT_Q3",
+	"TKAx_L2_EXT_RRESP_0_127",
+	"TKAx_L2_EXT_RRESP_128_191",
+	"TKAx_L2_EXT_RRESP_192_255",
+	"TKAx_L2_EXT_RRESP_256_319",
+	"TKAx_L2_EXT_RRESP_320_383",
+	"TKAx_L2_EXT_WRITE",
+	"TKAx_L2_EXT_WRITE_NOSNP_FULL",
+	"TKAx_L2_EXT_WRITE_NOSNP_PTL",
+	"TKAx_L2_EXT_WRITE_SNP_FULL",
+	"TKAx_L2_EXT_WRITE_SNP_PTL",
+	"TKAx_L2_EXT_WRITE_BEATS",
+	"TKAx_L2_EXT_W_STALL",
+	"TKAx_L2_EXT_AW_CNT_Q1",
+	"TKAx_L2_EXT_AW_CNT_Q2",
+	"TKAx_L2_EXT_AW_CNT_Q3",
+	"TKAx_L2_EXT_SNOOP",
+	"TKAx_L2_EXT_SNOOP_STALL",
+	"TKAx_L2_EXT_SNOOP_RESP_CLEAN",
+	"TKAx_L2_EXT_SNOOP_RESP_DATA",
+	"TKAx_L2_EXT_SNOOP_INTERNAL",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+};
+
+#endif /* _KBASE_GATOR_HWCNT_NAMES_TKAX_H_ */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tmix.h b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tmix.h
index 8a215f723570..233ffbec416e 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tmix.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tmix.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * This header was autogenerated, it should not be edited.
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tnox.h b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tnox.h
new file mode 100644
index 000000000000..fbb5080f6779
--- /dev/null
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tnox.h
@@ -0,0 +1,296 @@
+/*
+ *
+ * (C) COPYRIGHT 2016-2017 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ */
+
+/*
+ * This header was autogenerated, it should not be edited.
+ */
+
+#ifndef _KBASE_GATOR_HWCNT_NAMES_TNOX_H_
+#define _KBASE_GATOR_HWCNT_NAMES_TNOX_H_
+
+static const char * const hardware_counters_mali_tNOx[] = {
+	/* Performance counters for the Job Manager */
+	"",
+	"",
+	"",
+	"",
+	"TNOx_MESSAGES_SENT",
+	"TNOx_MESSAGES_RECEIVED",
+	"TNOx_GPU_ACTIVE",
+	"TNOx_IRQ_ACTIVE",
+	"TNOx_JS0_JOBS",
+	"TNOx_JS0_TASKS",
+	"TNOx_JS0_ACTIVE",
+	"",
+	"TNOx_JS0_WAIT_READ",
+	"TNOx_JS0_WAIT_ISSUE",
+	"TNOx_JS0_WAIT_DEPEND",
+	"TNOx_JS0_WAIT_FINISH",
+	"TNOx_JS1_JOBS",
+	"TNOx_JS1_TASKS",
+	"TNOx_JS1_ACTIVE",
+	"",
+	"TNOx_JS1_WAIT_READ",
+	"TNOx_JS1_WAIT_ISSUE",
+	"TNOx_JS1_WAIT_DEPEND",
+	"TNOx_JS1_WAIT_FINISH",
+	"TNOx_JS2_JOBS",
+	"TNOx_JS2_TASKS",
+	"TNOx_JS2_ACTIVE",
+	"",
+	"TNOx_JS2_WAIT_READ",
+	"TNOx_JS2_WAIT_ISSUE",
+	"TNOx_JS2_WAIT_DEPEND",
+	"TNOx_JS2_WAIT_FINISH",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+
+	/* Performance counters for the Tiler */
+	"",
+	"",
+	"",
+	"",
+	"TNOx_TILER_ACTIVE",
+	"TNOx_JOBS_PROCESSED",
+	"TNOx_TRIANGLES",
+	"TNOx_LINES",
+	"TNOx_POINTS",
+	"TNOx_FRONT_FACING",
+	"TNOx_BACK_FACING",
+	"TNOx_PRIM_VISIBLE",
+	"TNOx_PRIM_CULLED",
+	"TNOx_PRIM_CLIPPED",
+	"TNOx_PRIM_SAT_CULLED",
+	"TNOx_BIN_ALLOC_INIT",
+	"TNOx_BIN_ALLOC_OVERFLOW",
+	"TNOx_BUS_READ",
+	"",
+	"TNOx_BUS_WRITE",
+	"TNOx_LOADING_DESC",
+	"TNOx_IDVS_POS_SHAD_REQ",
+	"TNOx_IDVS_POS_SHAD_WAIT",
+	"TNOx_IDVS_POS_SHAD_STALL",
+	"TNOx_IDVS_POS_FIFO_FULL",
+	"TNOx_PREFETCH_STALL",
+	"TNOx_VCACHE_HIT",
+	"TNOx_VCACHE_MISS",
+	"TNOx_VCACHE_LINE_WAIT",
+	"TNOx_VFETCH_POS_READ_WAIT",
+	"TNOx_VFETCH_VERTEX_WAIT",
+	"TNOx_VFETCH_STALL",
+	"TNOx_PRIMASSY_STALL",
+	"TNOx_BBOX_GEN_STALL",
+	"TNOx_IDVS_VBU_HIT",
+	"TNOx_IDVS_VBU_MISS",
+	"TNOx_IDVS_VBU_LINE_DEALLOCATE",
+	"TNOx_IDVS_VAR_SHAD_REQ",
+	"TNOx_IDVS_VAR_SHAD_STALL",
+	"TNOx_BINNER_STALL",
+	"TNOx_ITER_STALL",
+	"TNOx_COMPRESS_MISS",
+	"TNOx_COMPRESS_STALL",
+	"TNOx_PCACHE_HIT",
+	"TNOx_PCACHE_MISS",
+	"TNOx_PCACHE_MISS_STALL",
+	"TNOx_PCACHE_EVICT_STALL",
+	"TNOx_PMGR_PTR_WR_STALL",
+	"TNOx_PMGR_PTR_RD_STALL",
+	"TNOx_PMGR_CMD_WR_STALL",
+	"TNOx_WRBUF_ACTIVE",
+	"TNOx_WRBUF_HIT",
+	"TNOx_WRBUF_MISS",
+	"TNOx_WRBUF_NO_FREE_LINE_STALL",
+	"TNOx_WRBUF_NO_AXI_ID_STALL",
+	"TNOx_WRBUF_AXI_STALL",
+	"",
+	"",
+	"",
+	"TNOx_UTLB_TRANS",
+	"TNOx_UTLB_TRANS_HIT",
+	"TNOx_UTLB_TRANS_STALL",
+	"TNOx_UTLB_TRANS_MISS_DELAY",
+	"TNOx_UTLB_MMU_REQ",
+
+	/* Performance counters for the Shader Core */
+	"",
+	"",
+	"",
+	"",
+	"TNOx_FRAG_ACTIVE",
+	"TNOx_FRAG_PRIMITIVES",
+	"TNOx_FRAG_PRIM_RAST",
+	"TNOx_FRAG_FPK_ACTIVE",
+	"TNOx_FRAG_STARVING",
+	"TNOx_FRAG_WARPS",
+	"TNOx_FRAG_PARTIAL_WARPS",
+	"TNOx_FRAG_QUADS_RAST",
+	"TNOx_FRAG_QUADS_EZS_TEST",
+	"TNOx_FRAG_QUADS_EZS_UPDATE",
+	"TNOx_FRAG_QUADS_EZS_KILL",
+	"TNOx_FRAG_LZS_TEST",
+	"TNOx_FRAG_LZS_KILL",
+	"TNOx_WARP_REG_SIZE_64",
+	"TNOx_FRAG_PTILES",
+	"TNOx_FRAG_TRANS_ELIM",
+	"TNOx_QUAD_FPK_KILLER",
+	"TNOx_FULL_QUAD_WARPS",
+	"TNOx_COMPUTE_ACTIVE",
+	"TNOx_COMPUTE_TASKS",
+	"TNOx_COMPUTE_WARPS",
+	"TNOx_COMPUTE_STARVING",
+	"TNOx_EXEC_CORE_ACTIVE",
+	"TNOx_EXEC_ACTIVE",
+	"TNOx_EXEC_INSTR_COUNT",
+	"TNOx_EXEC_INSTR_DIVERGED",
+	"TNOx_EXEC_INSTR_STARVING",
+	"TNOx_ARITH_INSTR_SINGLE_FMA",
+	"TNOx_ARITH_INSTR_DOUBLE",
+	"TNOx_ARITH_INSTR_MSG",
+	"TNOx_ARITH_INSTR_MSG_ONLY",
+	"TNOx_TEX_MSGI_NUM_QUADS",
+	"TNOx_TEX_DFCH_NUM_PASSES",
+	"TNOx_TEX_DFCH_NUM_PASSES_MISS",
+	"TNOx_TEX_DFCH_NUM_PASSES_MIP_MAP",
+	"TNOx_TEX_TIDX_NUM_SPLIT_MIP_MAP",
+	"TNOx_TEX_TFCH_NUM_LINES_FETCHED",
+	"TNOx_TEX_TFCH_NUM_LINES_FETCHED_BLOCK",
+	"TNOx_TEX_TFCH_NUM_OPERATIONS",
+	"TNOx_TEX_FILT_NUM_OPERATIONS",
+	"TNOx_LS_MEM_READ_FULL",
+	"TNOx_LS_MEM_READ_SHORT",
+	"TNOx_LS_MEM_WRITE_FULL",
+	"TNOx_LS_MEM_WRITE_SHORT",
+	"TNOx_LS_MEM_ATOMIC",
+	"TNOx_VARY_INSTR",
+	"TNOx_VARY_SLOT_32",
+	"TNOx_VARY_SLOT_16",
+	"TNOx_ATTR_INSTR",
+	"TNOx_ARITH_INSTR_FP_MUL",
+	"TNOx_BEATS_RD_FTC",
+	"TNOx_BEATS_RD_FTC_EXT",
+	"TNOx_BEATS_RD_LSC",
+	"TNOx_BEATS_RD_LSC_EXT",
+	"TNOx_BEATS_RD_TEX",
+	"TNOx_BEATS_RD_TEX_EXT",
+	"TNOx_BEATS_RD_OTHER",
+	"TNOx_BEATS_WR_LSC_WB",
+	"TNOx_BEATS_WR_TIB",
+	"TNOx_BEATS_WR_LSC_OTHER",
+
+	/* Performance counters for the Memory System */
+	"",
+	"",
+	"",
+	"",
+	"TNOx_MMU_REQUESTS",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"TNOx_L2_RD_MSG_IN",
+	"TNOx_L2_RD_MSG_IN_STALL",
+	"TNOx_L2_WR_MSG_IN",
+	"TNOx_L2_WR_MSG_IN_STALL",
+	"TNOx_L2_SNP_MSG_IN",
+	"TNOx_L2_SNP_MSG_IN_STALL",
+	"TNOx_L2_RD_MSG_OUT",
+	"TNOx_L2_RD_MSG_OUT_STALL",
+	"TNOx_L2_WR_MSG_OUT",
+	"TNOx_L2_ANY_LOOKUP",
+	"TNOx_L2_READ_LOOKUP",
+	"TNOx_L2_WRITE_LOOKUP",
+	"TNOx_L2_EXT_SNOOP_LOOKUP",
+	"TNOx_L2_EXT_READ",
+	"TNOx_L2_EXT_READ_NOSNP",
+	"TNOx_L2_EXT_READ_UNIQUE",
+	"TNOx_L2_EXT_READ_BEATS",
+	"TNOx_L2_EXT_AR_STALL",
+	"TNOx_L2_EXT_AR_CNT_Q1",
+	"TNOx_L2_EXT_AR_CNT_Q2",
+	"TNOx_L2_EXT_AR_CNT_Q3",
+	"TNOx_L2_EXT_RRESP_0_127",
+	"TNOx_L2_EXT_RRESP_128_191",
+	"TNOx_L2_EXT_RRESP_192_255",
+	"TNOx_L2_EXT_RRESP_256_319",
+	"TNOx_L2_EXT_RRESP_320_383",
+	"TNOx_L2_EXT_WRITE",
+	"TNOx_L2_EXT_WRITE_NOSNP_FULL",
+	"TNOx_L2_EXT_WRITE_NOSNP_PTL",
+	"TNOx_L2_EXT_WRITE_SNP_FULL",
+	"TNOx_L2_EXT_WRITE_SNP_PTL",
+	"TNOx_L2_EXT_WRITE_BEATS",
+	"TNOx_L2_EXT_W_STALL",
+	"TNOx_L2_EXT_AW_CNT_Q1",
+	"TNOx_L2_EXT_AW_CNT_Q2",
+	"TNOx_L2_EXT_AW_CNT_Q3",
+	"TNOx_L2_EXT_SNOOP",
+	"TNOx_L2_EXT_SNOOP_STALL",
+	"TNOx_L2_EXT_SNOOP_RESP_CLEAN",
+	"TNOx_L2_EXT_SNOOP_RESP_DATA",
+	"TNOx_L2_EXT_SNOOP_INTERNAL",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+};
+
+#endif /* _KBASE_GATOR_HWCNT_NAMES_TNOX_H_ */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tsix.h b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tsix.h
index fb6a1437a1f6..552db5732239 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tsix.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_tsix.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * This header was autogenerated, it should not be edited.
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_ttrx.h b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_ttrx.h
new file mode 100644
index 000000000000..d1bb02a72fc3
--- /dev/null
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gator_hwcnt_names_ttrx.h
@@ -0,0 +1,296 @@
+/*
+ *
+ * (C) COPYRIGHT 2016-2017 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ */
+
+/*
+ * This header was autogenerated, it should not be edited.
+ */
+
+#ifndef _KBASE_GATOR_HWCNT_NAMES_TTRX_H_
+#define _KBASE_GATOR_HWCNT_NAMES_TTRX_H_
+
+static const char * const hardware_counters_mali_tTRx[] = {
+	/* Performance counters for the Job Manager */
+	"",
+	"",
+	"",
+	"",
+	"TTRx_MESSAGES_SENT",
+	"TTRx_MESSAGES_RECEIVED",
+	"TTRx_GPU_ACTIVE",
+	"TTRx_IRQ_ACTIVE",
+	"TTRx_JS0_JOBS",
+	"TTRx_JS0_TASKS",
+	"TTRx_JS0_ACTIVE",
+	"",
+	"TTRx_JS0_WAIT_READ",
+	"TTRx_JS0_WAIT_ISSUE",
+	"TTRx_JS0_WAIT_DEPEND",
+	"TTRx_JS0_WAIT_FINISH",
+	"TTRx_JS1_JOBS",
+	"TTRx_JS1_TASKS",
+	"TTRx_JS1_ACTIVE",
+	"",
+	"TTRx_JS1_WAIT_READ",
+	"TTRx_JS1_WAIT_ISSUE",
+	"TTRx_JS1_WAIT_DEPEND",
+	"TTRx_JS1_WAIT_FINISH",
+	"TTRx_JS2_JOBS",
+	"TTRx_JS2_TASKS",
+	"TTRx_JS2_ACTIVE",
+	"",
+	"TTRx_JS2_WAIT_READ",
+	"TTRx_JS2_WAIT_ISSUE",
+	"TTRx_JS2_WAIT_DEPEND",
+	"TTRx_JS2_WAIT_FINISH",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+
+	/* Performance counters for the Tiler */
+	"",
+	"",
+	"",
+	"",
+	"TTRx_TILER_ACTIVE",
+	"TTRx_JOBS_PROCESSED",
+	"TTRx_TRIANGLES",
+	"TTRx_LINES",
+	"TTRx_POINTS",
+	"TTRx_FRONT_FACING",
+	"TTRx_BACK_FACING",
+	"TTRx_PRIM_VISIBLE",
+	"TTRx_PRIM_CULLED",
+	"TTRx_PRIM_CLIPPED",
+	"TTRx_PRIM_SAT_CULLED",
+	"TTRx_BIN_ALLOC_INIT",
+	"TTRx_BIN_ALLOC_OVERFLOW",
+	"TTRx_BUS_READ",
+	"",
+	"TTRx_BUS_WRITE",
+	"TTRx_LOADING_DESC",
+	"",
+	"",
+	"",
+	"",
+	"TTRx_PREFETCH_STALL",
+	"TTRx_VCACHE_HIT",
+	"TTRx_VCACHE_MISS",
+	"TTRx_VCACHE_LINE_WAIT",
+	"TTRx_VFETCH_POS_READ_WAIT",
+	"TTRx_VFETCH_VERTEX_WAIT",
+	"TTRx_VFETCH_STALL",
+	"TTRx_PRIMASSY_STALL",
+	"TTRx_BBOX_GEN_STALL",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"TTRx_BINNER_STALL",
+	"TTRx_ITER_STALL",
+	"TTRx_COMPRESS_MISS",
+	"TTRx_COMPRESS_STALL",
+	"TTRx_PCACHE_HIT",
+	"TTRx_PCACHE_MISS",
+	"TTRx_PCACHE_MISS_STALL",
+	"TTRx_PCACHE_EVICT_STALL",
+	"TTRx_PMGR_PTR_WR_STALL",
+	"TTRx_PMGR_PTR_RD_STALL",
+	"TTRx_PMGR_CMD_WR_STALL",
+	"TTRx_WRBUF_ACTIVE",
+	"TTRx_WRBUF_HIT",
+	"TTRx_WRBUF_MISS",
+	"TTRx_WRBUF_NO_FREE_LINE_STALL",
+	"TTRx_WRBUF_NO_AXI_ID_STALL",
+	"TTRx_WRBUF_AXI_STALL",
+	"",
+	"",
+	"",
+	"TTRx_UTLB_TRANS",
+	"TTRx_UTLB_TRANS_HIT",
+	"TTRx_UTLB_TRANS_STALL",
+	"TTRx_UTLB_TRANS_MISS_DELAY",
+	"TTRx_UTLB_MMU_REQ",
+
+	/* Performance counters for the Shader Core */
+	"",
+	"",
+	"",
+	"",
+	"TTRx_FRAG_ACTIVE",
+	"TTRx_FRAG_PRIMITIVES",
+	"TTRx_FRAG_PRIM_RAST",
+	"TTRx_FRAG_FPK_ACTIVE",
+	"TTRx_FRAG_STARVING",
+	"TTRx_FRAG_WARPS",
+	"TTRx_FRAG_PARTIAL_WARPS",
+	"TTRx_FRAG_QUADS_RAST",
+	"TTRx_FRAG_QUADS_EZS_TEST",
+	"TTRx_FRAG_QUADS_EZS_UPDATE",
+	"TTRx_FRAG_QUADS_EZS_KILL",
+	"TTRx_FRAG_LZS_TEST",
+	"TTRx_FRAG_LZS_KILL",
+	"",
+	"TTRx_FRAG_PTILES",
+	"TTRx_FRAG_TRANS_ELIM",
+	"TTRx_QUAD_FPK_KILLER",
+	"",
+	"TTRx_COMPUTE_ACTIVE",
+	"TTRx_COMPUTE_TASKS",
+	"TTRx_COMPUTE_WARPS",
+	"TTRx_COMPUTE_STARVING",
+	"TTRx_EXEC_CORE_ACTIVE",
+	"TTRx_EXEC_ACTIVE",
+	"TTRx_EXEC_INSTR_COUNT",
+	"TTRx_EXEC_INSTR_DIVERGED",
+	"TTRx_EXEC_INSTR_STARVING",
+	"TTRx_ARITH_INSTR_SINGLE_FMA",
+	"TTRx_ARITH_INSTR_DOUBLE",
+	"TTRx_ARITH_INSTR_MSG",
+	"TTRx_ARITH_INSTR_MSG_ONLY",
+	"TTRx_TEX_INSTR",
+	"TTRx_TEX_INSTR_MIPMAP",
+	"TTRx_TEX_INSTR_COMPRESSED",
+	"TTRx_TEX_INSTR_3D",
+	"TTRx_TEX_INSTR_TRILINEAR",
+	"TTRx_TEX_COORD_ISSUE",
+	"TTRx_TEX_COORD_STALL",
+	"TTRx_TEX_STARVE_CACHE",
+	"TTRx_TEX_STARVE_FILTER",
+	"TTRx_LS_MEM_READ_FULL",
+	"TTRx_LS_MEM_READ_SHORT",
+	"TTRx_LS_MEM_WRITE_FULL",
+	"TTRx_LS_MEM_WRITE_SHORT",
+	"TTRx_LS_MEM_ATOMIC",
+	"TTRx_VARY_INSTR",
+	"TTRx_VARY_SLOT_32",
+	"TTRx_VARY_SLOT_16",
+	"TTRx_ATTR_INSTR",
+	"TTRx_ARITH_INSTR_FP_MUL",
+	"TTRx_BEATS_RD_FTC",
+	"TTRx_BEATS_RD_FTC_EXT",
+	"TTRx_BEATS_RD_LSC",
+	"TTRx_BEATS_RD_LSC_EXT",
+	"TTRx_BEATS_RD_TEX",
+	"TTRx_BEATS_RD_TEX_EXT",
+	"TTRx_BEATS_RD_OTHER",
+	"TTRx_BEATS_WR_LSC",
+	"TTRx_BEATS_WR_TIB",
+	"",
+
+	/* Performance counters for the Memory System */
+	"",
+	"",
+	"",
+	"",
+	"TTRx_MMU_REQUESTS",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"TTRx_L2_RD_MSG_IN",
+	"TTRx_L2_RD_MSG_IN_STALL",
+	"TTRx_L2_WR_MSG_IN",
+	"TTRx_L2_WR_MSG_IN_STALL",
+	"TTRx_L2_SNP_MSG_IN",
+	"TTRx_L2_SNP_MSG_IN_STALL",
+	"TTRx_L2_RD_MSG_OUT",
+	"TTRx_L2_RD_MSG_OUT_STALL",
+	"TTRx_L2_WR_MSG_OUT",
+	"TTRx_L2_ANY_LOOKUP",
+	"TTRx_L2_READ_LOOKUP",
+	"TTRx_L2_WRITE_LOOKUP",
+	"TTRx_L2_EXT_SNOOP_LOOKUP",
+	"TTRx_L2_EXT_READ",
+	"TTRx_L2_EXT_READ_NOSNP",
+	"TTRx_L2_EXT_READ_UNIQUE",
+	"TTRx_L2_EXT_READ_BEATS",
+	"TTRx_L2_EXT_AR_STALL",
+	"TTRx_L2_EXT_AR_CNT_Q1",
+	"TTRx_L2_EXT_AR_CNT_Q2",
+	"TTRx_L2_EXT_AR_CNT_Q3",
+	"TTRx_L2_EXT_RRESP_0_127",
+	"TTRx_L2_EXT_RRESP_128_191",
+	"TTRx_L2_EXT_RRESP_192_255",
+	"TTRx_L2_EXT_RRESP_256_319",
+	"TTRx_L2_EXT_RRESP_320_383",
+	"TTRx_L2_EXT_WRITE",
+	"TTRx_L2_EXT_WRITE_NOSNP_FULL",
+	"TTRx_L2_EXT_WRITE_NOSNP_PTL",
+	"TTRx_L2_EXT_WRITE_SNP_FULL",
+	"TTRx_L2_EXT_WRITE_SNP_PTL",
+	"TTRx_L2_EXT_WRITE_BEATS",
+	"TTRx_L2_EXT_W_STALL",
+	"TTRx_L2_EXT_AW_CNT_Q1",
+	"TTRx_L2_EXT_AW_CNT_Q2",
+	"TTRx_L2_EXT_AW_CNT_Q3",
+	"TTRx_L2_EXT_SNOOP",
+	"TTRx_L2_EXT_SNOOP_STALL",
+	"TTRx_L2_EXT_SNOOP_RESP_CLEAN",
+	"TTRx_L2_EXT_SNOOP_RESP_DATA",
+	"TTRx_L2_EXT_SNOOP_INTERNAL",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+	"",
+};
+
+#endif /* _KBASE_GATOR_HWCNT_NAMES_TTRX_H_ */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gpu_id.h b/drivers/gpu/arm/bifrost/mali_kbase_gpu_id.h
index 2d368dfaf644..4052e2fd0768 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gpu_id.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gpu_id.h
@@ -7,13 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
-
-
 #ifndef _KBASE_GPU_ID_H_
 #define _KBASE_GPU_ID_H_
 
@@ -102,6 +107,11 @@
 #define GPU_ID2_PRODUCT_THEX              GPU_ID2_MODEL_MAKE(6u, 1)
 #define GPU_ID2_PRODUCT_TSIX              GPU_ID2_MODEL_MAKE(7u, 0)
 #define GPU_ID2_PRODUCT_TDVX              GPU_ID2_MODEL_MAKE(7u, 3)
+#define GPU_ID2_PRODUCT_TNOX              GPU_ID2_MODEL_MAKE(7u, 1)
+#define GPU_ID2_PRODUCT_TGOX              GPU_ID2_MODEL_MAKE(7u, 2)
+#define GPU_ID2_PRODUCT_TKAX              GPU_ID2_MODEL_MAKE(8u, 0)
+#define GPU_ID2_PRODUCT_TTRX              GPU_ID2_MODEL_MAKE(8u, 1)
+#define GPU_ID2_PRODUCT_TBOX              GPU_ID2_MODEL_MAKE(8u, 2)
 
 /* Values for GPU_ID_VERSION_STATUS field for PRODUCT_ID GPU_ID_PI_T60X */
 #define GPU_ID_S_15DEV0                   0x1
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gpu_memory_debugfs.c b/drivers/gpu/arm/bifrost/mali_kbase_gpu_memory_debugfs.c
index 6df0a1cb1264..2fd033280359 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gpu_memory_debugfs.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gpu_memory_debugfs.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 
 #ifdef CONFIG_DEBUG_FS
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gpu_memory_debugfs.h b/drivers/gpu/arm/bifrost/mali_kbase_gpu_memory_debugfs.h
index 7045693eb910..28a871a0da4f 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gpu_memory_debugfs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gpu_memory_debugfs.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_gpu_memory_debugfs.h
  * Header file for gpu_memory entry in debugfs
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gpuprops.c b/drivers/gpu/arm/bifrost/mali_kbase_gpuprops.c
index 4130810f1038..9a9ce2d9e661 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gpuprops.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gpuprops.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Base kernel property query APIs
  */
@@ -24,7 +29,6 @@
 #include <mali_kbase.h>
 #include <mali_midg_regmap.h>
 #include <mali_kbase_gpuprops.h>
-#include <mali_kbase_config_defaults.h>
 #include <mali_kbase_hwaccess_gpuprops.h>
 #include "mali_kbase_ioctl.h"
 #include <linux/clk.h>
@@ -43,54 +47,6 @@
 #define KBASE_UBFX32(value, offset, size) \
 	(((u32)(value) >> (u32)(offset)) & (u32)((1ULL << (u32)(size)) - 1))
 
-int kbase_gpuprops_uk_get_props(struct kbase_context *kctx, struct kbase_uk_gpuprops * const kbase_props)
-{
-	kbase_gpu_clk_speed_func get_gpu_speed_mhz;
-	u32 gpu_speed_mhz;
-	int rc = 1;
-
-	KBASE_DEBUG_ASSERT(NULL != kctx);
-	KBASE_DEBUG_ASSERT(NULL != kbase_props);
-
-	/* Current GPU speed is requested from the system integrator via the GPU_SPEED_FUNC function.
-	 * If that function fails, or the function is not provided by the system integrator, we report the maximum
-	 * GPU speed as specified by GPU_FREQ_KHZ_MAX.
-	 */
-	get_gpu_speed_mhz = (kbase_gpu_clk_speed_func) GPU_SPEED_FUNC;
-	if (get_gpu_speed_mhz != NULL) {
-		rc = get_gpu_speed_mhz(&gpu_speed_mhz);
-#ifdef CONFIG_MALI_BIFROST_DEBUG
-		/* Issue a warning message when the reported GPU speed falls outside the min/max range */
-		if (rc == 0) {
-			u32 gpu_speed_khz = gpu_speed_mhz * 1000;
-
-			if (gpu_speed_khz < kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_min ||
-					gpu_speed_khz > kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_max)
-				dev_warn(kctx->kbdev->dev, "GPU Speed is outside of min/max range (got %lu Khz, min %lu Khz, max %lu Khz)\n",
-						(unsigned long)gpu_speed_khz,
-						(unsigned long)kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_min,
-						(unsigned long)kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_max);
-		}
-#endif				/* CONFIG_MALI_BIFROST_DEBUG */
-	}
-	if (kctx->kbdev->clock) {
-		gpu_speed_mhz = clk_get_rate(kctx->kbdev->clock) / 1000000;
-		rc = 0;
-	}
-	if (rc != 0)
-		gpu_speed_mhz = kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_max / 1000;
-
-	kctx->kbdev->gpu_props.props.core_props.gpu_speed_mhz = gpu_speed_mhz;
-
-	memcpy(&kbase_props->props, &kctx->kbdev->gpu_props.props, sizeof(kbase_props->props));
-
-	/* Before API 8.2 they expect L3 cache info here, which was always 0 */
-	if (kctx->api_version < KBASE_API_VERSION(8, 2))
-		kbase_props->props.raw_props.suspend_size = 0;
-
-	return 0;
-}
-
 static void kbase_gpuprops_construct_coherent_groups(base_gpu_props * const props)
 {
 	struct mali_base_gpu_coherent_group *current_group;
@@ -195,13 +151,9 @@ static void kbase_gpuprops_get_props(base_gpu_props * const gpu_props, struct kb
 	gpu_props->raw_props.l2_present =
 		((u64) regdump.l2_present_hi << 32) +
 		regdump.l2_present_lo;
-#ifdef CONFIG_MALI_CORESTACK
 	gpu_props->raw_props.stack_present =
 		((u64) regdump.stack_present_hi << 32) +
 		regdump.stack_present_lo;
-#else /* CONFIG_MALI_CORESTACK */
-	gpu_props->raw_props.stack_present = 0;
-#endif /* CONFIG_MALI_CORESTACK */
 
 	for (i = 0; i < GPU_MAX_JOB_SLOTS; i++)
 		gpu_props->raw_props.js_features[i] = regdump.js_features[i];
@@ -336,6 +288,9 @@ void kbase_gpuprops_set_features(struct kbase_device *kbdev)
 	 */
 	gpu_props->raw_props.coherency_mode = regdump.coherency_features |
 		COHERENCY_FEATURE_BIT(COHERENCY_NONE);
+
+	if (!kbase_hw_has_feature(kbdev, BASE_HW_FEATURE_THREAD_GROUP_SPLIT))
+		gpu_props->thread_props.max_thread_group_split = 0;
 }
 
 static struct {
@@ -344,19 +299,18 @@ static struct {
 	int size;
 } gpu_property_mapping[] = {
 #define PROP(name, member) \
-	{KBASE_GPUPROP_ ## name, offsetof(struct mali_base_gpu_props, member), \
-		sizeof(((struct mali_base_gpu_props *)0)->member)}
+	{KBASE_GPUPROP_ ## name, offsetof(struct base_gpu_props, member), \
+		sizeof(((struct base_gpu_props *)0)->member)}
 	PROP(PRODUCT_ID,                  core_props.product_id),
 	PROP(VERSION_STATUS,              core_props.version_status),
 	PROP(MINOR_REVISION,              core_props.minor_revision),
 	PROP(MAJOR_REVISION,              core_props.major_revision),
-	PROP(GPU_SPEED_MHZ,               core_props.gpu_speed_mhz),
 	PROP(GPU_FREQ_KHZ_MAX,            core_props.gpu_freq_khz_max),
-	PROP(GPU_FREQ_KHZ_MIN,            core_props.gpu_freq_khz_min),
 	PROP(LOG2_PROGRAM_COUNTER_SIZE,   core_props.log2_program_counter_size),
 	PROP(TEXTURE_FEATURES_0,          core_props.texture_features[0]),
 	PROP(TEXTURE_FEATURES_1,          core_props.texture_features[1]),
 	PROP(TEXTURE_FEATURES_2,          core_props.texture_features[2]),
+	PROP(TEXTURE_FEATURES_3,          core_props.texture_features[3]),
 	PROP(GPU_AVAILABLE_MEMORY_SIZE,   core_props.gpu_available_memory_size),
 
 	PROP(L2_LOG2_LINE_SIZE,           l2_props.log2_line_size),
@@ -404,6 +358,7 @@ static struct {
 	PROP(RAW_TEXTURE_FEATURES_0,      raw_props.texture_features[0]),
 	PROP(RAW_TEXTURE_FEATURES_1,      raw_props.texture_features[1]),
 	PROP(RAW_TEXTURE_FEATURES_2,      raw_props.texture_features[2]),
+	PROP(RAW_TEXTURE_FEATURES_3,      raw_props.texture_features[3]),
 	PROP(RAW_GPU_ID,                  raw_props.gpu_id),
 	PROP(RAW_THREAD_MAX_THREADS,      raw_props.thread_max_threads),
 	PROP(RAW_THREAD_MAX_WORKGROUP_SIZE,
@@ -438,7 +393,7 @@ static struct {
 int kbase_gpuprops_populate_user_buffer(struct kbase_device *kbdev)
 {
 	struct kbase_gpu_props *kprops = &kbdev->gpu_props;
-	struct mali_base_gpu_props *props = &kprops->props;
+	struct base_gpu_props *props = &kprops->props;
 	u32 count = ARRAY_SIZE(gpu_property_mapping);
 	u32 i;
 	u32 size = 0;
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gpuprops.h b/drivers/gpu/arm/bifrost/mali_kbase_gpuprops.h
index 57b3eaf9cd53..37d9c08770bf 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gpuprops.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gpuprops.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_gpuprops.h
  * Base kernel property query APIs
@@ -49,18 +54,6 @@ void kbase_gpuprops_set(struct kbase_device *kbdev);
  */
 void kbase_gpuprops_set_features(struct kbase_device *kbdev);
 
-/**
- * @brief Provide GPU properties to userside through UKU call.
- *
- * Fill the struct kbase_uk_gpuprops with values from GPU configuration registers.
- *
- * @param kctx		The struct kbase_context structure
- * @param kbase_props	A copy of the struct kbase_uk_gpuprops structure from userspace
- *
- * @return 0 on success. Any other value indicates failure.
- */
-int kbase_gpuprops_uk_get_props(struct kbase_context *kctx, struct kbase_uk_gpuprops * const kbase_props);
-
 /**
  * kbase_gpuprops_populate_user_buffer - Populate the GPU properties buffer
  * @kbdev: The kbase device
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gpuprops_types.h b/drivers/gpu/arm/bifrost/mali_kbase_gpuprops_types.h
index 10794fc27318..a3ddec79bee7 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_gpuprops_types.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gpuprops_types.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_gpuprops_types.h
  * Base kernel property query APIs
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gwt.c b/drivers/gpu/arm/bifrost/mali_kbase_gwt.c
new file mode 100644
index 000000000000..2caab877a447
--- /dev/null
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gwt.c
@@ -0,0 +1,286 @@
+/*
+ *
+ * (C) COPYRIGHT 2010-2017 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ */
+
+#include "mali_kbase_gwt.h"
+#include <linux/list_sort.h>
+
+static inline void kbase_gpu_gwt_setup_page_permission(
+				struct kbase_context *kctx,
+				unsigned long flag,
+				struct rb_node *node)
+{
+	struct rb_node *rbnode = node;
+
+	while (rbnode) {
+		struct kbase_va_region *reg;
+		int err = 0;
+
+		reg = rb_entry(rbnode, struct kbase_va_region, rblink);
+		if (reg->nr_pages && !(reg->flags & KBASE_REG_FREE) &&
+					(reg->flags & KBASE_REG_GPU_WR)) {
+			err = kbase_mmu_update_pages(kctx, reg->start_pfn,
+					kbase_get_gpu_phy_pages(reg),
+					reg->gpu_alloc->nents,
+					reg->flags & flag);
+			if (err)
+				dev_warn(kctx->kbdev->dev, "kbase_mmu_update_pages failure\n");
+		}
+
+		rbnode = rb_next(rbnode);
+	}
+}
+
+static void kbase_gpu_gwt_setup_pages(struct kbase_context *kctx,
+					unsigned long flag)
+{
+	kbase_gpu_gwt_setup_page_permission(kctx, flag,
+				rb_first(&(kctx->reg_rbtree_same)));
+	kbase_gpu_gwt_setup_page_permission(kctx, flag,
+				rb_first(&(kctx->reg_rbtree_exec)));
+	kbase_gpu_gwt_setup_page_permission(kctx, flag,
+				rb_first(&(kctx->reg_rbtree_custom)));
+}
+
+
+int kbase_gpu_gwt_start(struct kbase_context *kctx)
+{
+	kbase_gpu_vm_lock(kctx);
+	if (kctx->gwt_enabled) {
+		kbase_gpu_vm_unlock(kctx);
+		return -EBUSY;
+	}
+
+	INIT_LIST_HEAD(&kctx->gwt_current_list);
+	INIT_LIST_HEAD(&kctx->gwt_snapshot_list);
+
+	/* If GWT is enabled using new vector dumping format
+	 * from user space, back up status of the job serialization flag and
+	 * use full serialisation of jobs for dumping.
+	 * Status will be restored on end of dumping in gwt_stop.
+	 */
+	kctx->kbdev->backup_serialize_jobs = kctx->kbdev->serialize_jobs;
+	kctx->kbdev->serialize_jobs = KBASE_SERIALIZE_INTRA_SLOT |
+						KBASE_SERIALIZE_INTER_SLOT;
+
+	/* Mark gwt enabled before making pages read only in case a
+	   write page fault is triggered while we're still in this loop.
+	   (kbase_gpu_vm_lock() doesn't prevent this!)
+	*/
+	kctx->gwt_enabled = true;
+	kctx->gwt_was_enabled = true;
+
+	kbase_gpu_gwt_setup_pages(kctx, ~KBASE_REG_GPU_WR);
+
+	kbase_gpu_vm_unlock(kctx);
+	return 0;
+}
+
+int kbase_gpu_gwt_stop(struct kbase_context *kctx)
+{
+	struct kbasep_gwt_list_element *pos, *n;
+
+	kbase_gpu_vm_lock(kctx);
+	if (!kctx->gwt_enabled) {
+		kbase_gpu_vm_unlock(kctx);
+		return -EINVAL;
+	}
+
+	list_for_each_entry_safe(pos, n, &kctx->gwt_current_list, link) {
+		list_del(&pos->link);
+		kfree(pos);
+	}
+
+	list_for_each_entry_safe(pos, n, &kctx->gwt_snapshot_list, link) {
+		list_del(&pos->link);
+		kfree(pos);
+	}
+
+	kctx->kbdev->serialize_jobs = kctx->kbdev->backup_serialize_jobs;
+
+	kbase_gpu_gwt_setup_pages(kctx, ~0UL);
+
+	kctx->gwt_enabled = false;
+	kbase_gpu_vm_unlock(kctx);
+	return 0;
+}
+
+
+int list_cmp_function(void *priv, struct list_head *a, struct list_head *b)
+{
+	struct kbasep_gwt_list_element *elementA = container_of(a,
+				struct kbasep_gwt_list_element, link);
+	struct kbasep_gwt_list_element *elementB = container_of(b,
+				struct kbasep_gwt_list_element, link);
+
+	CSTD_UNUSED(priv);
+
+	if (elementA->handle > elementB->handle)
+		return 1;
+	else if ((elementA->handle == elementB->handle) &&
+			(elementA->offset > elementB->offset))
+		return 1;
+	else
+		return -1;
+}
+
+void kbase_gpu_gwt_collate(struct kbase_context *kctx,
+		struct list_head *snapshot_list)
+{
+	struct kbasep_gwt_list_element *pos, *n;
+	struct kbasep_gwt_list_element *collated = NULL;
+
+	/* sort the list */
+	list_sort(NULL, snapshot_list, list_cmp_function);
+
+	/* Combine contiguous areas from same region */
+	list_for_each_entry_safe(pos, n, snapshot_list, link) {
+		if (NULL == collated ||
+				collated->handle != pos->handle ||
+				collated->offset + collated->num_pages !=
+						pos->offset) {
+			/* This is the first time through, a new region or
+			 * is not contiguous - start collating to this element
+			 */
+			collated = pos;
+		} else {
+			/* contiguous so merge */
+			collated->num_pages += pos->num_pages;
+			/* remove element from list */
+			list_del(&pos->link);
+			kfree(pos);
+		}
+	}
+}
+
+int kbase_gpu_gwt_dump(struct kbase_context *kctx,
+			union kbase_ioctl_cinstr_gwt_dump *gwt_dump)
+{
+	const u32 ubuf_size = gwt_dump->in.len;
+	u32 ubuf_count = 0;
+	__user void *user_handles = (__user void *)
+			(uintptr_t)gwt_dump->in.handle_buffer;
+	__user void *user_offsets = (__user void *)
+			(uintptr_t)gwt_dump->in.offset_buffer;
+	__user void *user_sizes = (__user void *)
+			(uintptr_t)gwt_dump->in.size_buffer;
+
+	kbase_gpu_vm_lock(kctx);
+
+	if (!kctx->gwt_enabled) {
+		kbase_gpu_vm_unlock(kctx);
+		/* gwt_dump shouldn't be called when gwt is disabled */
+		return -EPERM;
+	}
+
+	if (!gwt_dump->in.len || !gwt_dump->in.handle_buffer
+			|| !gwt_dump->in.offset_buffer
+			|| !gwt_dump->in.size_buffer) {
+		kbase_gpu_vm_unlock(kctx);
+		/* We don't have any valid user space buffer to copy the
+		 * write modified addresses.
+		 */
+		return -EINVAL;
+	}
+
+	if (list_empty(&kctx->gwt_snapshot_list) &&
+			!list_empty(&kctx->gwt_current_list)) {
+
+		list_replace_init(&kctx->gwt_current_list,
+					&kctx->gwt_snapshot_list);
+
+		/* We have collected all write faults so far
+		 * and they will be passed on to user space.
+		 * Reset the page flags state to allow collection of
+		 * further write faults.
+		 */
+		kbase_gpu_gwt_setup_pages(kctx, ~KBASE_REG_GPU_WR);
+
+		/* Sort and combine consecutive pages in the dump list*/
+		kbase_gpu_gwt_collate(kctx, &kctx->gwt_snapshot_list);
+	}
+
+	while ((!list_empty(&kctx->gwt_snapshot_list))) {
+		u64 handle_buffer[32];
+		u64 offset_buffer[32];
+		u64 num_page_buffer[32];
+		u32 count = 0;
+		int err;
+		struct kbasep_gwt_list_element *dump_info, *n;
+
+		list_for_each_entry_safe(dump_info, n,
+				&kctx->gwt_snapshot_list, link) {
+			handle_buffer[count] = dump_info->handle;
+			offset_buffer[count] = dump_info->offset;
+			num_page_buffer[count] = dump_info->num_pages;
+			count++;
+			list_del(&dump_info->link);
+			kfree(dump_info);
+			if (ARRAY_SIZE(handle_buffer) == count ||
+					ubuf_size == (ubuf_count + count))
+				break;
+		}
+
+		if (count) {
+			err = copy_to_user((user_handles +
+						(ubuf_count * sizeof(u64))),
+					(void *)handle_buffer,
+					count * sizeof(u64));
+			if (err) {
+				dev_err(kctx->kbdev->dev, "Copy to user failure\n");
+				kbase_gpu_vm_unlock(kctx);
+				return err;
+			}
+			err = copy_to_user((user_offsets +
+						(ubuf_count * sizeof(u64))),
+					(void *)offset_buffer,
+					count * sizeof(u64));
+			if (err) {
+				dev_err(kctx->kbdev->dev, "Copy to user failure\n");
+				kbase_gpu_vm_unlock(kctx);
+				return err;
+			}
+			err = copy_to_user((user_sizes +
+						(ubuf_count * sizeof(u64))),
+					(void *)num_page_buffer,
+					count * sizeof(u64));
+			if (err) {
+				dev_err(kctx->kbdev->dev, "Copy to user failure\n");
+				kbase_gpu_vm_unlock(kctx);
+				return err;
+			}
+
+			ubuf_count += count;
+		}
+
+		if (ubuf_count == ubuf_size)
+			break;
+	}
+
+	if (!list_empty(&kctx->gwt_snapshot_list))
+		gwt_dump->out.more_data_available = 1;
+	else
+		gwt_dump->out.more_data_available = 0;
+
+	gwt_dump->out.no_of_addr_collected = ubuf_count;
+	kbase_gpu_vm_unlock(kctx);
+	return 0;
+}
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_gwt.h b/drivers/gpu/arm/bifrost/mali_kbase_gwt.h
new file mode 100644
index 000000000000..7e7746e64915
--- /dev/null
+++ b/drivers/gpu/arm/bifrost/mali_kbase_gwt.h
@@ -0,0 +1,55 @@
+/*
+ *
+ * (C) COPYRIGHT 2010-2017 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ */
+
+#if !defined(_KBASE_GWT_H)
+#define _KBASE_GWT_H
+
+#include <mali_kbase.h>
+#include <mali_kbase_ioctl.h>
+
+/**
+ * kbase_gpu_gwt_start - Start the GPU write tracking
+ * @kctx: Pointer to kernel context
+ *
+ * @return 0 on success, error on failure.
+ */
+int kbase_gpu_gwt_start(struct kbase_context *kctx);
+
+/**
+ * kbase_gpu_gwt_stop - Stop the GPU write tracking
+ * @kctx: Pointer to kernel context
+ *
+ * @return 0 on success, error on failure.
+ */
+int kbase_gpu_gwt_stop(struct kbase_context *kctx);
+
+/**
+ * kbase_gpu_gwt_dump - Pass page address of faulting addresses to user space.
+ * @kctx:	Pointer to kernel context
+ * @gwt_dump:	User space data to be passed.
+ *
+ * @return 0 on success, error on failure.
+ */
+int kbase_gpu_gwt_dump(struct kbase_context *kctx,
+			union kbase_ioctl_cinstr_gwt_dump *gwt_dump);
+
+#endif /* _KBASE_GWT_H */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hw.c b/drivers/gpu/arm/bifrost/mali_kbase_hw.c
index eb8368ccee5e..286cc954ccbc 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hw.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hw.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Run-time work-arounds helpers
  */
@@ -51,6 +56,21 @@ void kbase_hw_set_features_mask(struct kbase_device *kbdev)
 		case GPU_ID2_PRODUCT_TDVX:
 			features = base_hw_features_tDVx;
 			break;
+		case GPU_ID2_PRODUCT_TNOX:
+			features = base_hw_features_tNOx;
+			break;
+		case GPU_ID2_PRODUCT_TGOX:
+			features = base_hw_features_tGOx;
+			break;
+		case GPU_ID2_PRODUCT_TKAX:
+			features = base_hw_features_tKAx;
+			break;
+		case GPU_ID2_PRODUCT_TTRX:
+			features = base_hw_features_tTRx;
+			break;
+		case GPU_ID2_PRODUCT_TBOX:
+			features = base_hw_features_tBOx;
+			break;
 		default:
 			features = base_hw_features_generic;
 			break;
@@ -150,9 +170,25 @@ static const enum base_hw_issue *kbase_hw_get_issues_for_new_id(
 		 {{GPU_ID2_VERSION_MAKE(0, 0, 0), base_hw_issues_tDVx_r0p0},
 		  {U32_MAX, NULL} } },
 
+		{GPU_ID2_PRODUCT_TNOX,
+		 {{GPU_ID2_VERSION_MAKE(0, 0, 0), base_hw_issues_tNOx_r0p0},
+		  {U32_MAX, NULL} } },
+
+		{GPU_ID2_PRODUCT_TGOX,
+		 {{GPU_ID2_VERSION_MAKE(0, 0, 0), base_hw_issues_tGOx_r0p0},
+		  {U32_MAX, NULL} } },
 
+		{GPU_ID2_PRODUCT_TKAX,
+		 {{GPU_ID2_VERSION_MAKE(0, 0, 0), base_hw_issues_tKAx_r0p0},
+		  {U32_MAX, NULL} } },
 
+		{GPU_ID2_PRODUCT_TTRX,
+		 {{GPU_ID2_VERSION_MAKE(0, 0, 0), base_hw_issues_tTRx_r0p0},
+		  {U32_MAX, NULL} } },
 
+		{GPU_ID2_PRODUCT_TBOX,
+		 {{GPU_ID2_VERSION_MAKE(0, 0, 0), base_hw_issues_tBOx_r0p0},
+		  {U32_MAX, NULL} } },
 	};
 
 	u32 gpu_id = kbdev->gpu_props.props.raw_props.gpu_id;
@@ -370,6 +406,21 @@ int kbase_hw_set_issues_mask(struct kbase_device *kbdev)
 			case GPU_ID2_PRODUCT_TDVX:
 				issues = base_hw_issues_model_tDVx;
 				break;
+			case GPU_ID2_PRODUCT_TNOX:
+				issues = base_hw_issues_model_tNOx;
+				break;
+			case GPU_ID2_PRODUCT_TGOX:
+				issues = base_hw_issues_model_tGOx;
+				break;
+			case GPU_ID2_PRODUCT_TKAX:
+				issues = base_hw_issues_model_tKAx;
+				break;
+			case GPU_ID2_PRODUCT_TTRX:
+				issues = base_hw_issues_model_tTRx;
+				break;
+			case GPU_ID2_PRODUCT_TBOX:
+				issues = base_hw_issues_model_tBOx;
+				break;
 			default:
 				dev_err(kbdev->dev,
 					"Unknown GPU ID %x", gpu_id);
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hw.h b/drivers/gpu/arm/bifrost/mali_kbase_hw.h
index 754250ce968d..f386b1624317 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hw.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hw.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file
  * Run-time work-arounds helpers
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_backend.h b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_backend.h
index b09be99e6b4e..dde4965c426a 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_backend.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_backend.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * HW access backend common APIs
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_defs.h b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_defs.h
index 0acf297192fd..dd25746d8434 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_defs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_defs.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /**
  * @file mali_kbase_hwaccess_gpu_defs.h
  * HW access common definitions
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_gpuprops.h b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_gpuprops.h
index cf8a8131c22e..b8ab0dc268f3 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_gpuprops.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_gpuprops.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /**
  * Base kernel property query backend APIs
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_instr.h b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_instr.h
index 5de2b7535bb4..d180e39253bd 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_instr.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_instr.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * HW Access instrumentation common APIs
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_jm.h b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_jm.h
index 750fda2cd81d..8b3d7e20f609 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_jm.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_jm.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * HW access job manager common APIs
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_pm.h b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_pm.h
index 71c7d495c40a..4598d8099765 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_pm.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_pm.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /**
  * @file mali_kbase_hwaccess_pm.h
  * HW access power manager common APIs
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_time.h b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_time.h
index b9fe8e669c63..72a476a447a1 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_time.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hwaccess_time.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /**
  *
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_hwcnt_reader.h b/drivers/gpu/arm/bifrost/mali_kbase_hwcnt_reader.h
index cf7bf1b35dc5..10706b8d2548 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_hwcnt_reader.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_hwcnt_reader.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_HWCNT_READER_H_
 #define _KBASE_HWCNT_READER_H_
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_ioctl.h b/drivers/gpu/arm/bifrost/mali_kbase_ioctl.h
index e7c1daee470b..a8fe9cd9edde 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_ioctl.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_ioctl.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_IOCTL_H_
 #define _KBASE_IOCTL_H_
 
@@ -26,6 +31,22 @@ extern "C" {
 
 #define KBASE_IOCTL_TYPE 0x80
 
+/*
+ * 11.1:
+ * - Add BASE_MEM_TILER_ALIGN_TOP under base_mem_alloc_flags
+ * 11.2:
+ * - KBASE_MEM_QUERY_FLAGS can return KBASE_REG_PF_GROW and KBASE_REG_SECURE,
+ *   which some user-side clients prior to 11.2 might fault if they received
+ *   them
+ * 11.3:
+ * - New ioctls KBASE_IOCTL_STICKY_RESOURCE_MAP and
+ *   KBASE_IOCTL_STICKY_RESOURCE_UNMAP
+ * 11.4:
+ * - New ioctl KBASE_IOCTL_MEM_FIND_GPU_START_AND_OFFSET
+ */
+#define BASE_UK_VERSION_MAJOR 11
+#define BASE_UK_VERSION_MINOR 4
+
 #ifdef ANDROID
 /* Android's definition of ioctl is incorrect, specifying the type argument as
  * 'int'. This creates a warning when using _IOWR (as the top bit is set). Work
@@ -246,6 +267,7 @@ struct kbase_ioctl_disjoint_query {
  * struct kbase_ioctl_get_ddk_version - Query the kernel version
  * @version_buffer: Buffer to receive the kernel version string
  * @size: Size of the buffer
+ * @padding: Padding
  *
  * The ioctl will return the number of bytes written into version_buffer
  * (which includes a NULL byte) or a negative error code
@@ -253,6 +275,7 @@ struct kbase_ioctl_disjoint_query {
 struct kbase_ioctl_get_ddk_version {
 	__u64 version_buffer;
 	__u32 size;
+	__u32 padding;
 };
 
 #define KBASE_IOCTL_GET_DDK_VERSION \
@@ -472,10 +495,12 @@ struct kbase_ioctl_fence_validate {
  * struct kbase_ioctl_get_profiling_controls - Get the profiling controls
  * @count: The size of @buffer in u32 words
  * @buffer: The buffer to receive the profiling controls
+ * @padding: Padding
  */
 struct kbase_ioctl_get_profiling_controls {
 	__u64 buffer;
 	__u32 count;
+	__u32 padding;
 };
 
 #define KBASE_IOCTL_GET_PROFILING_CONTROLS \
@@ -513,7 +538,106 @@ struct kbase_ioctl_soft_event_update {
 #define KBASE_IOCTL_SOFT_EVENT_UPDATE \
 	_IOW(KBASE_IOCTL_TYPE, 28, struct kbase_ioctl_soft_event_update)
 
-/* IOCTLs 29-32 are reserved */
+/**
+ * struct kbase_ioctl_sticky_resource_map - Permanently map an external resource
+ * @count: Number of resources
+ * @address: Array of u64 GPU addresses of the external resources to map
+ */
+struct kbase_ioctl_sticky_resource_map {
+	__u64 count;
+	__u64 address;
+};
+
+#define KBASE_IOCTL_STICKY_RESOURCE_MAP \
+	_IOW(KBASE_IOCTL_TYPE, 29, struct kbase_ioctl_sticky_resource_map)
+
+/**
+ * struct kbase_ioctl_sticky_resource_map - Unmap a resource mapped which was
+ *                                          previously permanently mapped
+ * @count: Number of resources
+ * @address: Array of u64 GPU addresses of the external resources to unmap
+ */
+struct kbase_ioctl_sticky_resource_unmap {
+	__u64 count;
+	__u64 address;
+};
+
+#define KBASE_IOCTL_STICKY_RESOURCE_UNMAP \
+	_IOW(KBASE_IOCTL_TYPE, 30, struct kbase_ioctl_sticky_resource_unmap)
+
+/**
+ * union kbase_ioctl_mem_find_gpu_start_and_offset - Find the start address of
+ *                                                   the GPU memory region for
+ *                                                   the given gpu address and
+ *                                                   the offset of that address
+ *                                                   into the region
+ *
+ * @gpu_addr: GPU virtual address
+ * @size: Size in bytes within the region
+ * @start: Address of the beginning of the memory region enclosing @gpu_addr
+ *         for the length of @offset bytes
+ * @offset: The offset from the start of the memory region to @gpu_addr
+ *
+ * @in: Input parameters
+ * @out: Output parameters
+ */
+union kbase_ioctl_mem_find_gpu_start_and_offset {
+	struct {
+		__u64 gpu_addr;
+		__u64 size;
+	} in;
+	struct {
+		__u64 start;
+		__u64 offset;
+	} out;
+};
+
+#define KBASE_IOCTL_MEM_FIND_GPU_START_AND_OFFSET \
+	_IOWR(KBASE_IOCTL_TYPE, 31, union kbase_ioctl_mem_find_gpu_start_and_offset)
+
+/* IOCTL 32 is free for use */
+
+#define KBASE_IOCTL_CINSTR_GWT_START \
+	_IO(KBASE_IOCTL_TYPE, 33)
+
+#define KBASE_IOCTL_CINSTR_GWT_STOP \
+	_IO(KBASE_IOCTL_TYPE, 34)
+
+/**
+ * union kbase_ioctl_gwt_dump - Used to collect all GPU write fault addresses.
+ * @handle_buffer: Address of buffer to hold handles of modified areas.
+ * @offset_buffer: Address of buffer to hold offset size of modified areas
+ *                 (in pages)
+ * @size_buffer: Address of buffer to hold size of modified areas (in pages)
+ * @len: Number of addresses the buffers can hold.
+ * @more_data_available: Status indicating if more addresses are available.
+ * @no_of_addr_collected: Number of addresses collected into addr_buffer.
+ *
+ * @in: Input parameters
+ * @out: Output parameters
+ * This structure is used when performing a call to dump GPU write fault
+ * addresses.
+ */
+union kbase_ioctl_cinstr_gwt_dump {
+	struct {
+		__u64 handle_buffer;
+		__u64 offset_buffer;
+		__u64 size_buffer;
+		__u32 len;
+		__u32 padding;
+
+	} in;
+	struct {
+		__u32 no_of_addr_collected;
+		__u8 more_data_available;
+		__u8 padding[27];
+	} out;
+};
+
+#define KBASE_IOCTL_CINSTR_GWT_DUMP \
+	_IOWR(KBASE_IOCTL_TYPE, 35, union kbase_ioctl_cinstr_gwt_dump)
+
+/* IOCTLs 36-41 are reserved */
 
 /***************
  * test ioctls *
@@ -570,9 +694,9 @@ struct kbase_ioctl_tlstream_stats {
 #define KBASE_GPUPROP_VERSION_STATUS			2
 #define KBASE_GPUPROP_MINOR_REVISION			3
 #define KBASE_GPUPROP_MAJOR_REVISION			4
-#define KBASE_GPUPROP_GPU_SPEED_MHZ			5
+/* 5 previously used for GPU speed */
 #define KBASE_GPUPROP_GPU_FREQ_KHZ_MAX			6
-#define KBASE_GPUPROP_GPU_FREQ_KHZ_MIN			7
+/* 7 previously used for minimum GPU speed */
 #define KBASE_GPUPROP_LOG2_PROGRAM_COUNTER_SIZE		8
 #define KBASE_GPUPROP_TEXTURE_FEATURES_0		9
 #define KBASE_GPUPROP_TEXTURE_FEATURES_1		10
@@ -651,6 +775,9 @@ struct kbase_ioctl_tlstream_stats {
 #define KBASE_GPUPROP_COHERENCY_GROUP_14		78
 #define KBASE_GPUPROP_COHERENCY_GROUP_15		79
 
+#define KBASE_GPUPROP_TEXTURE_FEATURES_3		80
+#define KBASE_GPUPROP_RAW_TEXTURE_FEATURES_3		81
+
 #ifdef __cpluscplus
 }
 #endif
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_jd.c b/drivers/gpu/arm/bifrost/mali_kbase_jd.c
index 144ebfcdfc59..be3592674fb3 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_jd.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_jd.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #if defined(CONFIG_DMA_SHARED_BUFFER)
 #include <linux/dma-buf.h>
 #endif				/* defined(CONFIG_DMA_SHARED_BUFFER) */
@@ -24,7 +29,6 @@
 #include <linux/compat.h>
 #endif
 #include <mali_kbase.h>
-#include <mali_kbase_uku.h>
 #include <linux/random.h>
 #include <linux/version.h>
 #include <linux/ratelimit.h>
@@ -106,7 +110,7 @@ static int jd_run_atom(struct kbase_jd_atom *katom)
 	return kbasep_js_add_job(kctx, katom);
 }
 
-#if defined(CONFIG_KDS) || defined(CONFIG_MALI_BIFROST_DMA_FENCE)
+#if defined(CONFIG_MALI_BIFROST_DMA_FENCE)
 void kbase_jd_dep_clear_locked(struct kbase_jd_atom *katom)
 {
 	struct kbase_device *kbdev;
@@ -139,91 +143,8 @@ void kbase_jd_dep_clear_locked(struct kbase_jd_atom *katom)
 }
 #endif
 
-#ifdef CONFIG_KDS
-
-/* Add the katom to the kds waiting list.
- * Atoms must be added to the waiting list after a successful call to kds_async_waitall.
- * The caller must hold the kbase_jd_context.lock */
-
-static void kbase_jd_kds_waiters_add(struct kbase_jd_atom *katom)
-{
-	struct kbase_context *kctx;
-
-	KBASE_DEBUG_ASSERT(katom);
-
-	kctx = katom->kctx;
-
-	list_add_tail(&katom->node, &kctx->waiting_kds_resource);
-}
-
-/* Remove the katom from the kds waiting list.
- * Atoms must be removed from the waiting list before a call to kds_resource_set_release_sync.
- * The supplied katom must first have been added to the list with a call to kbase_jd_kds_waiters_add.
- * The caller must hold the kbase_jd_context.lock */
-
-static void kbase_jd_kds_waiters_remove(struct kbase_jd_atom *katom)
-{
-	KBASE_DEBUG_ASSERT(katom);
-	list_del(&katom->node);
-}
-
-static void kds_dep_clear(void *callback_parameter, void *callback_extra_parameter)
-{
-	struct kbase_jd_atom *katom;
-	struct kbase_jd_context *ctx;
-
-	katom = (struct kbase_jd_atom *)callback_parameter;
-	KBASE_DEBUG_ASSERT(katom);
-
-	ctx = &katom->kctx->jctx;
-
-	/* If KDS resource has already been satisfied (e.g. due to zapping)
-	 * do nothing.
-	 */
-	mutex_lock(&ctx->lock);
-	if (!katom->kds_dep_satisfied) {
-		katom->kds_dep_satisfied = true;
-		kbase_jd_dep_clear_locked(katom);
-	}
-	mutex_unlock(&ctx->lock);
-}
-
-static void kbase_cancel_kds_wait_job(struct kbase_jd_atom *katom)
-{
-	KBASE_DEBUG_ASSERT(katom);
-
-	/* Prevent job_done_nolock from being called twice on an atom when
-	 *  there is a race between job completion and cancellation */
-
-	if (katom->status == KBASE_JD_ATOM_STATE_QUEUED) {
-		/* Wait was cancelled - zap the atom */
-		katom->event_code = BASE_JD_EVENT_JOB_CANCELLED;
-		if (jd_done_nolock(katom, NULL))
-			kbase_js_sched_all(katom->kctx->kbdev);
-	}
-}
-#endif				/* CONFIG_KDS */
-
 void kbase_jd_free_external_resources(struct kbase_jd_atom *katom)
 {
-#ifdef CONFIG_KDS
-	if (katom->kds_rset) {
-		struct kbase_jd_context *jctx = &katom->kctx->jctx;
-
-		/*
-		 * As the atom is no longer waiting, remove it from
-		 * the waiting list.
-		 */
-
-		mutex_lock(&jctx->lock);
-		kbase_jd_kds_waiters_remove(katom);
-		mutex_unlock(&jctx->lock);
-
-		/* Release the kds resource or cancel if zapping */
-		kds_resource_set_release_sync(&katom->kds_rset);
-	}
-#endif				/* CONFIG_KDS */
-
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	/* Flush dma-fence workqueue to ensure that any callbacks that may have
 	 * been queued are done before continuing.
@@ -240,12 +161,6 @@ static void kbase_jd_post_external_resources(struct kbase_jd_atom *katom)
 	KBASE_DEBUG_ASSERT(katom);
 	KBASE_DEBUG_ASSERT(katom->core_req & BASE_JD_REQ_EXTERNAL_RESOURCES);
 
-#ifdef CONFIG_KDS
-	/* Prevent the KDS resource from triggering the atom in case of zapping */
-	if (katom->kds_rset)
-		katom->kds_dep_satisfied = true;
-#endif				/* CONFIG_KDS */
-
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	kbase_dma_fence_signal(katom);
 #endif /* CONFIG_MALI_BIFROST_DMA_FENCE */
@@ -281,11 +196,6 @@ static int kbase_jd_pre_external_resources(struct kbase_jd_atom *katom, const st
 {
 	int err_ret_val = -EINVAL;
 	u32 res_no;
-#ifdef CONFIG_KDS
-	u32 kds_res_count = 0;
-	struct kds_resource **kds_resources = NULL;
-	unsigned long *kds_access_bitmap = NULL;
-#endif				/* CONFIG_KDS */
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	struct kbase_dma_fence_resv_info info = {
 		.dma_fence_resv_count = 0,
@@ -332,25 +242,6 @@ static int kbase_jd_pre_external_resources(struct kbase_jd_atom *katom, const st
 		err_ret_val = -EINVAL;
 		goto early_err_out;
 	}
-#ifdef CONFIG_KDS
-	/* assume we have to wait for all */
-	KBASE_DEBUG_ASSERT(0 != katom->nr_extres);
-	kds_resources = kmalloc_array(katom->nr_extres, sizeof(struct kds_resource *), GFP_KERNEL);
-
-	if (!kds_resources) {
-		err_ret_val = -ENOMEM;
-		goto early_err_out;
-	}
-
-	KBASE_DEBUG_ASSERT(0 != katom->nr_extres);
-	kds_access_bitmap = kcalloc(BITS_TO_LONGS(katom->nr_extres),
-				    sizeof(unsigned long),
-				    GFP_KERNEL);
-	if (!kds_access_bitmap) {
-		err_ret_val = -ENOMEM;
-		goto early_err_out;
-	}
-#endif				/* CONFIG_KDS */
 
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	if (implicit_sync) {
@@ -401,12 +292,7 @@ static int kbase_jd_pre_external_resources(struct kbase_jd_atom *katom, const st
 		}
 
 		alloc = kbase_map_external_resource(katom->kctx, reg,
-				current->mm
-#ifdef CONFIG_KDS
-				, &kds_res_count, kds_resources,
-				kds_access_bitmap, exclusive
-#endif
-				);
+				current->mm);
 		if (!alloc) {
 			err_ret_val = -EINVAL;
 			goto failed_loop;
@@ -434,36 +320,12 @@ static int kbase_jd_pre_external_resources(struct kbase_jd_atom *katom, const st
 		katom->extres[res_no].alloc = alloc;
 	}
 	/* successfully parsed the extres array */
-	/* drop the vm lock before we call into kds */
+	/* drop the vm lock now */
 	kbase_gpu_vm_unlock(katom->kctx);
 
 	/* Release the processes mmap lock */
 	up_read(&current->mm->mmap_sem);
 
-#ifdef CONFIG_KDS
-	if (kds_res_count) {
-		int wait_failed;
-
-		/* We have resources to wait for with kds */
-		katom->kds_dep_satisfied = false;
-
-		wait_failed = kds_async_waitall(&katom->kds_rset,
-				&katom->kctx->jctx.kds_cb, katom, NULL,
-				kds_res_count, kds_access_bitmap,
-				kds_resources);
-
-		if (wait_failed)
-			goto failed_kds_setup;
-		else
-			kbase_jd_kds_waiters_add(katom);
-	} else {
-		/* Nothing to wait for, so kds dep met */
-		katom->kds_dep_satisfied = true;
-	}
-	kfree(kds_resources);
-	kfree(kds_access_bitmap);
-#endif				/* CONFIG_KDS */
-
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	if (implicit_sync) {
 		if (info.dma_fence_resv_count) {
@@ -486,24 +348,6 @@ static int kbase_jd_pre_external_resources(struct kbase_jd_atom *katom, const st
 
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 failed_dma_fence_setup:
-#ifdef CONFIG_KDS
-	/* If we are here, dma_fence setup failed but KDS didn't.
-	 * Revert KDS setup if any.
-	 */
-	if (kds_res_count) {
-		mutex_unlock(&katom->kctx->jctx.lock);
-		kds_resource_set_release_sync(&katom->kds_rset);
-		mutex_lock(&katom->kctx->jctx.lock);
-
-		kbase_jd_kds_waiters_remove(katom);
-		katom->kds_dep_satisfied = true;
-	}
-#endif /* CONFIG_KDS */
-#endif /* CONFIG_MALI_BIFROST_DMA_FENCE */
-#ifdef CONFIG_KDS
-failed_kds_setup:
-#endif
-#if defined(CONFIG_KDS) || defined(CONFIG_MALI_BIFROST_DMA_FENCE)
 	/* Lock the processes mmap lock */
 	down_read(&current->mm->mmap_sem);
 
@@ -526,10 +370,6 @@ static int kbase_jd_pre_external_resources(struct kbase_jd_atom *katom, const st
  early_err_out:
 	kfree(katom->extres);
 	katom->extres = NULL;
-#ifdef CONFIG_KDS
-	kfree(kds_resources);
-	kfree(kds_access_bitmap);
-#endif				/* CONFIG_KDS */
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	if (implicit_sync) {
 		kfree(info.resv_objs);
@@ -559,15 +399,6 @@ static inline void jd_resolve_dep(struct list_head *out_list,
 
 		if (katom->event_code != BASE_JD_EVENT_DONE &&
 			(dep_type != BASE_JD_DEP_TYPE_ORDER)) {
-#ifdef CONFIG_KDS
-			if (!dep_atom->kds_dep_satisfied) {
-				/* Just set kds_dep_satisfied to true. If the callback happens after this then it will early out and
-				 * do nothing. If the callback doesn't happen then kbase_jd_post_external_resources will clean up
-				 */
-				dep_atom->kds_dep_satisfied = true;
-			}
-#endif
-
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 			kbase_dma_fence_cancel_callbacks(dep_atom);
 #endif
@@ -576,7 +407,7 @@ static inline void jd_resolve_dep(struct list_head *out_list,
 			KBASE_DEBUG_ASSERT(dep_atom->status !=
 						KBASE_JD_ATOM_STATE_UNUSED);
 
-			if ((dep_atom->core_req & BASE_JD_REQ_SOFT_REPLAY)
+			if ((dep_atom->core_req & BASE_JD_REQ_SOFT_JOB_TYPE)
 					!= BASE_JD_REQ_SOFT_REPLAY) {
 				dep_atom->will_fail_event_code =
 					dep_atom->event_code;
@@ -617,10 +448,6 @@ static inline void jd_resolve_dep(struct list_head *out_list,
 			}
 #endif /* CONFIG_MALI_BIFROST_DMA_FENCE */
 
-#ifdef CONFIG_KDS
-			dep_satisfied = dep_satisfied && dep_atom->kds_dep_satisfied;
-#endif
-
 			if (dep_satisfied) {
 				dep_atom->in_jd_list = true;
 				list_add_tail(&dep_atom->jd_item, out_list);
@@ -756,10 +583,6 @@ static void jd_try_submitting_deps(struct list_head *out_list,
 					dep_satisfied = false;
 				}
 #endif /* CONFIG_MALI_BIFROST_DMA_FENCE */
-#ifdef CONFIG_KDS
-				dep_satisfied = dep_satisfied &&
-						dep_atom->kds_dep_satisfied;
-#endif
 
 				if (dep0_valid && dep1_valid && dep_satisfied) {
 					dep_atom->in_jd_list = true;
@@ -997,6 +820,7 @@ bool jd_submit_atom(struct kbase_context *kctx, const struct base_jd_atom_v2 *us
 	katom->x_pre_dep = NULL;
 	katom->x_post_dep = NULL;
 	katom->will_fail_event_code = BASE_JD_EVENT_NOT_STARTED;
+	katom->softjob_data = NULL;
 
 	/* Implicitly sets katom->protected_state.enter as well. */
 	katom->protected_state.exit = KBASE_ATOM_EXIT_PROTECTED_CHECK;
@@ -1004,12 +828,6 @@ bool jd_submit_atom(struct kbase_context *kctx, const struct base_jd_atom_v2 *us
 	katom->age = kctx->age_count++;
 
 	INIT_LIST_HEAD(&katom->jd_item);
-#ifdef CONFIG_KDS
-	/* Start by assuming that the KDS dependencies are satisfied,
-	 * kbase_jd_pre_external_resources will correct this if there are dependencies */
-	katom->kds_dep_satisfied = true;
-	katom->kds_rset = NULL;
-#endif				/* CONFIG_KDS */
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	kbase_fence_dep_count_set(katom, -1);
 #endif
@@ -1185,6 +1003,16 @@ bool jd_submit_atom(struct kbase_context *kctx, const struct base_jd_atom_v2 *us
 		goto out;
 	}
 
+	/* Reject fence wait soft-job atoms accessing external resources */
+	if ((katom->core_req & BASE_JD_REQ_EXTERNAL_RESOURCES) &&
+			 ((katom->core_req & BASE_JD_REQ_SOFT_JOB_TYPE) == BASE_JD_REQ_SOFT_FENCE_WAIT)) {
+		dev_warn(kctx->kbdev->dev,
+				"Rejecting fence wait soft-job atom accessing external resources");
+		katom->event_code = BASE_JD_EVENT_JOB_INVALID;
+		ret = jd_done_nolock(katom, NULL);
+		goto out;
+	}
+
 	if (katom->core_req & BASE_JD_REQ_EXTERNAL_RESOURCES) {
 		/* handle what we need to do to access the external resources */
 		if (kbase_jd_pre_external_resources(katom, user_atom) != 0) {
@@ -1227,14 +1055,6 @@ bool jd_submit_atom(struct kbase_context *kctx, const struct base_jd_atom_v2 *us
 		ret = false;
 		goto out;
 	}
-#ifdef CONFIG_KDS
-	if (!katom->kds_dep_satisfied) {
-		/* Queue atom due to KDS dependency */
-		ret = false;
-		goto out;
-	}
-#endif				/* CONFIG_KDS */
-
 
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	if (kbase_fence_dep_count_read(katom) != -1) {
@@ -1322,12 +1142,6 @@ int kbase_jd_submit(struct kbase_context *kctx,
 			break;
 		}
 
-#ifdef BASE_LEGACY_UK10_2_SUPPORT
-		if (KBASE_API_VERSION(10, 3) > kctx->api_version)
-			user_atom.core_req = (u32)(user_atom.compat_core_req
-					      & 0x7fff);
-#endif /* BASE_LEGACY_UK10_2_SUPPORT */
-
 		user_addr = (void __user *)((uintptr_t) user_addr + stride);
 
 		mutex_lock(&jctx->lock);
@@ -1673,7 +1487,6 @@ void kbase_jd_done(struct kbase_jd_atom *katom, int slot_nr,
 #endif
 
 	WARN_ON(work_pending(&katom->work));
-	KBASE_DEBUG_ASSERT(0 == object_is_on_stack(&katom->work));
 	INIT_WORK(&katom->work, kbase_jd_done_worker);
 	queue_work(kctx->jctx.job_done_wq, &katom->work);
 }
@@ -1698,7 +1511,6 @@ void kbase_jd_cancel(struct kbase_device *kbdev, struct kbase_jd_atom *katom)
 
 	katom->event_code = BASE_JD_EVENT_JOB_CANCELLED;
 
-	KBASE_DEBUG_ASSERT(0 == object_is_on_stack(&katom->work));
 	INIT_WORK(&katom->work, jd_cancel_worker);
 	queue_work(kctx->jctx.job_done_wq, &katom->work);
 }
@@ -1732,24 +1544,6 @@ void kbase_jd_zap_context(struct kbase_context *kctx)
 	}
 
 
-#ifdef CONFIG_KDS
-
-	/* For each job waiting on a kds resource, cancel the wait and force the job to
-	 * complete early, this is done so that we don't leave jobs outstanding waiting
-	 * on kds resources which may never be released when contexts are zapped, resulting
-	 * in a hang.
-	 *
-	 * Note that we can safely iterate over the list as the struct kbase_jd_context lock is held,
-	 * this prevents items being removed when calling job_done_nolock in kbase_cancel_kds_wait_job.
-	 */
-
-	list_for_each(entry, &kctx->waiting_kds_resource) {
-		katom = list_entry(entry, struct kbase_jd_atom, node);
-
-		kbase_cancel_kds_wait_job(katom);
-	}
-#endif
-
 #ifdef CONFIG_MALI_BIFROST_DMA_FENCE
 	kbase_dma_fence_cancel_all_atoms(kctx);
 #endif
@@ -1772,9 +1566,6 @@ int kbase_jd_init(struct kbase_context *kctx)
 {
 	int i;
 	int mali_err = 0;
-#ifdef CONFIG_KDS
-	int err;
-#endif				/* CONFIG_KDS */
 
 	KBASE_DEBUG_ASSERT(kctx);
 
@@ -1809,24 +1600,12 @@ int kbase_jd_init(struct kbase_context *kctx)
 
 	spin_lock_init(&kctx->jctx.tb_lock);
 
-#ifdef CONFIG_KDS
-	err = kds_callback_init(&kctx->jctx.kds_cb, 0, kds_dep_clear);
-	if (0 != err) {
-		mali_err = -EINVAL;
-		goto out2;
-	}
-#endif				/* CONFIG_KDS */
-
 	kctx->jctx.job_nr = 0;
 	INIT_LIST_HEAD(&kctx->completed_jobs);
 	atomic_set(&kctx->work_count, 0);
 
 	return 0;
 
-#ifdef CONFIG_KDS
- out2:
-	destroy_workqueue(kctx->jctx.job_done_wq);
-#endif				/* CONFIG_KDS */
  out1:
 	return mali_err;
 }
@@ -1837,9 +1616,6 @@ void kbase_jd_exit(struct kbase_context *kctx)
 {
 	KBASE_DEBUG_ASSERT(kctx);
 
-#ifdef CONFIG_KDS
-	kds_callback_term(&kctx->jctx.kds_cb);
-#endif				/* CONFIG_KDS */
 	/* Work queue is emptied by this */
 	destroy_workqueue(kctx->jctx.job_done_wq);
 }
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_jd_debugfs.c b/drivers/gpu/arm/bifrost/mali_kbase_jd_debugfs.c
index fed4ad5816ab..2dda5fbf286f 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_jd_debugfs.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_jd_debugfs.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifdef CONFIG_DEBUG_FS
 
 #include <linux/seq_file.h>
@@ -24,6 +29,7 @@
 #if defined(CONFIG_SYNC) || defined(CONFIG_SYNC_FILE)
 #include <mali_kbase_sync.h>
 #endif
+#include <mali_kbase_ioctl.h>
 
 struct kbase_jd_debugfs_depinfo {
 	u8 id;
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_jd_debugfs.h b/drivers/gpu/arm/bifrost/mali_kbase_jd_debugfs.h
index fae32919b22f..ce0cb61f8c27 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_jd_debugfs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_jd_debugfs.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /**
  * @file mali_kbase_jd_debugfs.h
  * Header file for job dispatcher-related entries in debugfs
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_jm.c b/drivers/gpu/arm/bifrost/mali_kbase_jm.c
index 0c5c6a6f78cb..3b16e6f73fe7 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_jm.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_jm.c
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * HW access job manager common APIs
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_jm.h b/drivers/gpu/arm/bifrost/mali_kbase_jm.h
index a74ee24c8058..c468ea4d20a5 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_jm.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_jm.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 /*
  * Job manager common APIs
  */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_js.c b/drivers/gpu/arm/bifrost/mali_kbase_js.c
index 677e438aedfa..649bb7ea3267 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_js.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_js.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /*
  * Job Scheduler Implementation
  */
@@ -140,13 +145,11 @@ static void kbase_js_sync_timers(struct kbase_device *kbdev)
 bool kbasep_js_runpool_retain_ctx_nolock(struct kbase_device *kbdev,
 		struct kbase_context *kctx)
 {
-	struct kbasep_js_device_data *js_devdata;
 	bool result = false;
 	int as_nr;
 
 	KBASE_DEBUG_ASSERT(kbdev != NULL);
 	KBASE_DEBUG_ASSERT(kctx != NULL);
-	js_devdata = &kbdev->js_data;
 
 	lockdep_assert_held(&kbdev->hwaccess_lock);
 
@@ -1093,9 +1096,6 @@ bool kbasep_js_add_job(struct kbase_context *kctx,
 	KBASE_DEBUG_ASSERT(js_kctx_info->ctx.nr_jobs < U32_MAX);
 	++(js_kctx_info->ctx.nr_jobs);
 
-	/* Setup any scheduling information */
-	kbasep_js_clear_job_retry_submit(atom);
-
 	/* Lock for state available during IRQ */
 	spin_lock_irqsave(&kbdev->hwaccess_lock, flags);
 
@@ -1146,9 +1146,8 @@ bool kbasep_js_add_job(struct kbase_context *kctx,
 	if (!kbase_ctx_flag(kctx, KCTX_SCHEDULED)) {
 		if (kbase_ctx_flag(kctx, KCTX_DYING)) {
 			/* A job got added while/after kbase_job_zap_context()
-			 * was called on a non-scheduled context (e.g. KDS
-			 * dependency resolved). Kill that job by killing the
-			 * context. */
+			 * was called on a non-scheduled context. Kill that job
+			 * by killing the context. */
 			kbasep_js_runpool_requeue_or_kill_ctx(kbdev, kctx,
 					false);
 		} else if (js_kctx_info->ctx.nr_jobs == 1) {
@@ -1174,13 +1173,11 @@ void kbasep_js_remove_job(struct kbase_device *kbdev,
 		struct kbase_context *kctx, struct kbase_jd_atom *atom)
 {
 	struct kbasep_js_kctx_info *js_kctx_info;
-	struct kbasep_js_device_data *js_devdata;
 
 	KBASE_DEBUG_ASSERT(kbdev != NULL);
 	KBASE_DEBUG_ASSERT(kctx != NULL);
 	KBASE_DEBUG_ASSERT(atom != NULL);
 
-	js_devdata = &kbdev->js_data;
 	js_kctx_info = &kctx->jctx.sched_info;
 
 	KBASE_TRACE_ADD_REFCOUNT(kbdev, JS_REMOVE_JOB, kctx, atom, atom->jc,
@@ -1196,15 +1193,12 @@ bool kbasep_js_remove_cancelled_job(struct kbase_device *kbdev,
 {
 	unsigned long flags;
 	struct kbasep_js_atom_retained_state katom_retained_state;
-	struct kbasep_js_device_data *js_devdata;
 	bool attr_state_changed;
 
 	KBASE_DEBUG_ASSERT(kbdev != NULL);
 	KBASE_DEBUG_ASSERT(kctx != NULL);
 	KBASE_DEBUG_ASSERT(katom != NULL);
 
-	js_devdata = &kbdev->js_data;
-
 	kbasep_js_atom_retained_state_copy(&katom_retained_state, katom);
 	kbasep_js_remove_job(kbdev, kctx, katom);
 
@@ -1227,11 +1221,9 @@ bool kbasep_js_runpool_retain_ctx(struct kbase_device *kbdev,
 		struct kbase_context *kctx)
 {
 	unsigned long flags;
-	struct kbasep_js_device_data *js_devdata;
 	bool result;
 
 	KBASE_DEBUG_ASSERT(kbdev != NULL);
-	js_devdata = &kbdev->js_data;
 
 	mutex_lock(&kbdev->mmu_hw_mutex);
 	spin_lock_irqsave(&kbdev->hwaccess_lock, flags);
@@ -1301,22 +1293,13 @@ static kbasep_js_release_result kbasep_js_run_jobs_after_ctx_and_atom_release(
 	lockdep_assert_held(&js_devdata->runpool_mutex);
 	lockdep_assert_held(&kbdev->hwaccess_lock);
 
-	if (js_devdata->nr_user_contexts_running != 0) {
-		bool retry_submit = false;
-		int retry_jobslot = 0;
-
-		if (katom_retained_state)
-			retry_submit = kbasep_js_get_atom_retry_submit_slot(
-					katom_retained_state, &retry_jobslot);
+	if (js_devdata->nr_user_contexts_running != 0 && runpool_ctx_attr_change) {
+		/* A change in runpool ctx attributes might mean we can
+		 * run more jobs than before  */
+		result = KBASEP_JS_RELEASE_RESULT_SCHED_ALL;
 
-		if (runpool_ctx_attr_change || retry_submit) {
-			/* A change in runpool ctx attributes might mean we can
-			 * run more jobs than before  */
-			result = KBASEP_JS_RELEASE_RESULT_SCHED_ALL;
-
-			KBASE_TRACE_ADD_SLOT(kbdev, JD_DONE_TRY_RUN_NEXT_JOB,
-						kctx, NULL, 0u, retry_jobslot);
-		}
+		KBASE_TRACE_ADD_SLOT(kbdev, JD_DONE_TRY_RUN_NEXT_JOB,
+					kctx, NULL, 0u, 0);
 	}
 	return result;
 }
@@ -2280,7 +2263,6 @@ void kbase_js_unpull(struct kbase_context *kctx, struct kbase_jd_atom *katom)
 
 	kbase_job_check_leave_disjoint(kctx->kbdev, katom);
 
-	KBASE_DEBUG_ASSERT(0 == object_is_on_stack(&katom->work));
 	INIT_WORK(&katom->work, js_return_worker);
 	queue_work(kctx->jctx.job_done_wq, &katom->work);
 }
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_js.h b/drivers/gpu/arm/bifrost/mali_kbase_js.h
index ddada8e468a1..aa930b9d83f6 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_js.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_js.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_js.h
  * Job Scheduler APIs.
@@ -666,37 +671,6 @@ static inline void kbasep_js_clear_submit_allowed(struct kbasep_js_device_data *
 	js_devdata->runpool_irq.submit_allowed &= clear_mask;
 }
 
-/**
- * @brief Manage the 'retry_submit_on_slot' part of a kbase_jd_atom
- */
-static inline void kbasep_js_clear_job_retry_submit(struct kbase_jd_atom *atom)
-{
-	atom->retry_submit_on_slot = KBASEP_JS_RETRY_SUBMIT_SLOT_INVALID;
-}
-
-/**
- * Mark a slot as requiring resubmission by carrying that information on a
- * completing atom.
- *
- * @note This can ASSERT in debug builds if the submit slot has been set to
- * something other than the current value for @a js. This is because you might
- * be unintentionally stopping more jobs being submitted on the old submit
- * slot, and that might cause a scheduling-hang.
- *
- * @note If you can guarantee that the atoms for the original slot will be
- * submitted on some other slot, then call kbasep_js_clear_job_retry_submit()
- * first to silence the ASSERT.
- */
-static inline void kbasep_js_set_job_retry_submit_slot(struct kbase_jd_atom *atom, int js)
-{
-	KBASE_DEBUG_ASSERT(0 <= js && js <= BASE_JM_MAX_NR_SLOTS);
-	KBASE_DEBUG_ASSERT((atom->retry_submit_on_slot ==
-					KBASEP_JS_RETRY_SUBMIT_SLOT_INVALID)
-				|| (atom->retry_submit_on_slot == js));
-
-	atom->retry_submit_on_slot = js;
-}
-
 /**
  * Create an initial 'invalid' atom retained state, that requires no
  * atom-related work to be done on releasing with
@@ -706,7 +680,6 @@ static inline void kbasep_js_atom_retained_state_init_invalid(struct kbasep_js_a
 {
 	retained_state->event_code = BASE_JD_EVENT_NOT_STARTED;
 	retained_state->core_req = KBASEP_JS_ATOM_RETAINED_STATE_CORE_REQ_INVALID;
-	retained_state->retry_submit_on_slot = KBASEP_JS_RETRY_SUBMIT_SLOT_INVALID;
 }
 
 /**
@@ -717,7 +690,6 @@ static inline void kbasep_js_atom_retained_state_copy(struct kbasep_js_atom_reta
 {
 	retained_state->event_code = katom->event_code;
 	retained_state->core_req = katom->core_req;
-	retained_state->retry_submit_on_slot = katom->retry_submit_on_slot;
 	retained_state->sched_priority = katom->sched_priority;
 	retained_state->device_nr = katom->device_nr;
 }
@@ -753,14 +725,6 @@ static inline bool kbasep_js_atom_retained_state_is_valid(const struct kbasep_js
 	return (bool) (katom_retained_state->core_req != KBASEP_JS_ATOM_RETAINED_STATE_CORE_REQ_INVALID);
 }
 
-static inline bool kbasep_js_get_atom_retry_submit_slot(const struct kbasep_js_atom_retained_state *katom_retained_state, int *res)
-{
-	int js = katom_retained_state->retry_submit_on_slot;
-
-	*res = js;
-	return (bool) (js >= 0);
-}
-
 /**
  * @brief Variant of kbasep_js_runpool_lookup_ctx() that can be used when the
  * context is guaranteed to be already previously retained.
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_js_ctx_attr.c b/drivers/gpu/arm/bifrost/mali_kbase_js_ctx_attr.c
index 321506ada835..6fd908aceb66 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_js_ctx_attr.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_js_ctx_attr.c
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 #include <mali_kbase.h>
 #include <mali_kbase_config.h>
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_js_ctx_attr.h b/drivers/gpu/arm/bifrost/mali_kbase_js_ctx_attr.h
index ce9183326a57..be781e60c822 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_js_ctx_attr.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_js_ctx_attr.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_js_ctx_attr.h
  * Job Scheduler Context Attribute APIs
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_js_defs.h b/drivers/gpu/arm/bifrost/mali_kbase_js_defs.h
index 0b4890d6b50e..8c8aa68fbc98 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_js_defs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_js_defs.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_js.h
  * Job Scheduler Type Definitions
@@ -334,8 +339,6 @@ struct kbasep_js_atom_retained_state {
 	base_jd_core_req core_req;
 	/* priority */
 	int sched_priority;
-	/** Job Slot to retry submitting to if submission from IRQ handler failed */
-	int retry_submit_on_slot;
 	/* Core group atom was executed on */
 	u32 device_nr;
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_linux.h b/drivers/gpu/arm/bifrost/mali_kbase_linux.h
index 6d1e61fd41e0..003ac9e68a76 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_linux.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_linux.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_linux.h
  * Base kernel APIs, Linux implementation.
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem.c b/drivers/gpu/arm/bifrost/mali_kbase_mem.c
index a105b15d641c..b457c5215616 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_mem.c
  * Base kernel memory APIs
@@ -31,6 +36,7 @@
 #include <linux/bug.h>
 #include <linux/compat.h>
 #include <linux/version.h>
+#include <linux/log2.h>
 
 #include <mali_kbase_config.h>
 #include <mali_kbase.h>
@@ -231,7 +237,10 @@ struct kbase_va_region *kbase_region_tracker_find_region_base_address(struct kba
 KBASE_EXPORT_TEST_API(kbase_region_tracker_find_region_base_address);
 
 /* Find region meeting given requirements */
-static struct kbase_va_region *kbase_region_tracker_find_region_meeting_reqs(struct kbase_context *kctx, struct kbase_va_region *reg_reqs, size_t nr_pages, size_t align)
+static struct kbase_va_region *kbase_region_tracker_find_region_meeting_reqs(
+		struct kbase_context *kctx, struct kbase_va_region *reg_reqs,
+		size_t nr_pages, size_t align_offset, size_t align_mask,
+		u64 *out_start_pfn)
 {
 	struct rb_node *rbnode = NULL;
 	struct kbase_va_region *reg = NULL;
@@ -239,7 +248,6 @@ static struct kbase_va_region *kbase_region_tracker_find_region_meeting_reqs(str
 
 	/* Note that this search is a linear search, as we do not have a target
 	   address in mind, so does not benefit from the rbtree search */
-
 	rbtree = kbase_reg_flags_to_rbtree(kctx, reg_reqs);
 
 	rbnode = rb_first(rbtree);
@@ -249,12 +257,23 @@ static struct kbase_va_region *kbase_region_tracker_find_region_meeting_reqs(str
 		if ((reg->nr_pages >= nr_pages) &&
 				(reg->flags & KBASE_REG_FREE)) {
 			/* Check alignment */
-			u64 start_pfn = (reg->start_pfn + align - 1) & ~(align - 1);
+			u64 start_pfn = reg->start_pfn;
+
+			/* When align_offset == align, this sequence is
+			 * equivalent to:
+			 *   (start_pfn + align_mask) & ~(align_mask)
+			 *
+			 * Otherwise, it aligns to n*align + offset, for the
+			 * lowest value n that makes this still >start_pfn */
+			start_pfn += align_mask;
+			start_pfn -= (start_pfn - align_offset) & (align_mask);
 
 			if ((start_pfn >= reg->start_pfn) &&
 					(start_pfn <= (reg->start_pfn + reg->nr_pages - 1)) &&
-					((start_pfn + nr_pages - 1) <= (reg->start_pfn + reg->nr_pages - 1)))
+					((start_pfn + nr_pages - 1) <= (reg->start_pfn + reg->nr_pages - 1))) {
+				*out_start_pfn = start_pfn;
 				return reg;
+			}
 		}
 		rbnode = rb_next(rbnode);
 	}
@@ -425,7 +444,7 @@ int kbase_add_va_region(struct kbase_context *kctx,
 		align = 1;
 
 	/* must be a power of 2 */
-	KBASE_DEBUG_ASSERT((align & (align - 1)) == 0);
+	KBASE_DEBUG_ASSERT(is_power_of_2(align));
 	KBASE_DEBUG_ASSERT(nr_pages > 0);
 
 	/* Path 1: Map a specific address. Find the enclosing region, which *must* be free. */
@@ -458,38 +477,44 @@ int kbase_add_va_region(struct kbase_context *kctx,
 		goto exit;
 	}
 
-	/* Path 2: Map any free address which meets the requirements.  */
-	{
+	/* Path 2: Map any free address which meets the requirements.
+	 *
+	 * Depending on the zone the allocation request is for
+	 * we might need to retry it. */
+	do {
 		u64 start_pfn;
+		size_t align_offset = align;
+		size_t align_mask = align - 1;
+
+		if ((reg->flags & KBASE_REG_TILER_ALIGN_TOP)) {
+			WARN(align > 1,
+					"kbase_add_va_region with align %lx might not be honored for KBASE_REG_TILER_ALIGN_TOP memory",
+					(unsigned long)align);
+			align_mask  = reg->extent - 1;
+			align_offset = reg->extent - reg->initial_commit;
+		}
+
+		tmp = kbase_region_tracker_find_region_meeting_reqs(kctx, reg,
+				nr_pages, align_offset, align_mask,
+				&start_pfn);
+		if (tmp) {
+			err = kbase_insert_va_region_nolock(kctx, reg, tmp,
+					start_pfn, nr_pages);
+			break;
+		}
 
 		/*
-		 * Depending on the zone the allocation request is for
-		 * we might need to retry it.
+		 * If the allocation is not from the same zone as JIT
+		 * then don't retry, we're out of VA and there is
+		 * nothing which can be done about it.
 		 */
-		do {
-			tmp = kbase_region_tracker_find_region_meeting_reqs(
-					kctx, reg, nr_pages, align);
-			if (tmp) {
-				start_pfn = (tmp->start_pfn + align - 1) &
-						~(align - 1);
-				err = kbase_insert_va_region_nolock(kctx, reg,
-						tmp, start_pfn, nr_pages);
-				break;
-			}
-
-			/*
-			 * If the allocation is not from the same zone as JIT
-			 * then don't retry, we're out of VA and there is
-			 * nothing which can be done about it.
-			 */
-			if ((reg->flags & KBASE_REG_ZONE_MASK) !=
-					KBASE_REG_ZONE_CUSTOM_VA)
-				break;
-		} while (kbase_jit_evict(kctx));
+		if ((reg->flags & KBASE_REG_ZONE_MASK) !=
+				KBASE_REG_ZONE_CUSTOM_VA)
+			break;
+	} while (kbase_jit_evict(kctx));
 
-		if (!tmp)
-			err = -ENOMEM;
-	}
+	if (!tmp)
+		err = -ENOMEM;
 
  exit:
 	return err;
@@ -829,6 +854,8 @@ struct kbase_va_region *kbase_alloc_free_region(struct kbase_context *kctx, u64
 	new_reg->start_pfn = start_pfn;
 	new_reg->nr_pages = nr_pages;
 
+	INIT_LIST_HEAD(&new_reg->jit_node);
+
 	return new_reg;
 }
 
@@ -902,6 +929,12 @@ int kbase_gpu_mmap(struct kbase_context *kctx, struct kbase_va_region *reg, u64
 	size_t i = 0;
 	unsigned long attr;
 	unsigned long mask = ~KBASE_REG_MEMATTR_MASK;
+	unsigned long gwt_mask = ~0;
+
+#ifdef CONFIG_MALI_JOB_DUMP
+	if (kctx->gwt_enabled)
+		gwt_mask = ~KBASE_REG_GPU_WR;
+#endif
 
 	if ((kctx->kbdev->system_coherency == COHERENCY_ACE) &&
 		(reg->flags & KBASE_REG_SHARE_BOTH))
@@ -929,7 +962,7 @@ int kbase_gpu_mmap(struct kbase_context *kctx, struct kbase_va_region *reg, u64
 						reg->start_pfn + (i * stride),
 						alloc->imported.alias.aliased[i].alloc->pages + alloc->imported.alias.aliased[i].offset,
 						alloc->imported.alias.aliased[i].length,
-						reg->flags);
+						reg->flags & gwt_mask);
 				if (err)
 					goto bad_insert;
 
@@ -939,7 +972,7 @@ int kbase_gpu_mmap(struct kbase_context *kctx, struct kbase_va_region *reg, u64
 					reg->start_pfn + i * stride,
 					kctx->aliasing_sink_page,
 					alloc->imported.alias.aliased[i].length,
-					(reg->flags & mask) | attr);
+					(reg->flags & mask & gwt_mask) | attr);
 
 				if (err)
 					goto bad_insert;
@@ -949,7 +982,7 @@ int kbase_gpu_mmap(struct kbase_context *kctx, struct kbase_va_region *reg, u64
 		err = kbase_mmu_insert_pages(kctx, reg->start_pfn,
 				kbase_get_gpu_phy_pages(reg),
 				kbase_reg_current_backed_size(reg),
-				reg->flags);
+				reg->flags & gwt_mask);
 		if (err)
 			goto bad_insert;
 		kbase_mem_phy_alloc_gpu_mapped(reg->gpu_alloc);
@@ -1085,6 +1118,36 @@ int kbasep_find_enclosing_cpu_mapping_offset(
 
 KBASE_EXPORT_TEST_API(kbasep_find_enclosing_cpu_mapping_offset);
 
+int kbasep_find_enclosing_gpu_mapping_start_and_offset(struct kbase_context *kctx,
+		u64 gpu_addr, size_t size, u64 *start, u64 *offset)
+{
+	struct kbase_va_region *region;
+
+	kbase_gpu_vm_lock(kctx);
+
+	region = kbase_region_tracker_find_region_enclosing_address(kctx, gpu_addr);
+
+	if (!region) {
+		kbase_gpu_vm_unlock(kctx);
+		return -EINVAL;
+	}
+
+	*start = region->start_pfn << PAGE_SHIFT;
+
+	*offset = gpu_addr - *start;
+
+	if (((region->start_pfn + region->nr_pages) << PAGE_SHIFT) < (gpu_addr + size)) {
+		kbase_gpu_vm_unlock(kctx);
+		return -EINVAL;
+	}
+
+	kbase_gpu_vm_unlock(kctx);
+
+	return 0;
+}
+
+KBASE_EXPORT_TEST_API(kbasep_find_enclosing_gpu_mapping_start_and_offset);
+
 void kbase_sync_single(struct kbase_context *kctx,
 		struct tagged_addr t_cpu_pa, struct tagged_addr t_gpu_pa,
 		off_t offset, size_t size, enum kbase_sync_type sync_fn)
@@ -1268,6 +1331,11 @@ int kbase_mem_free_region(struct kbase_context *kctx, struct kbase_va_region *re
 	KBASE_DEBUG_ASSERT(NULL != reg);
 	lockdep_assert_held(&kctx->reg_lock);
 
+	if (reg->flags & KBASE_REG_JIT) {
+		dev_warn(reg->kctx->kbdev->dev, "Attempt to free JIT memory!\n");
+		return -EINVAL;
+	}
+
 	/*
 	 * Unlink the physical allocation before unmaking it evictable so
 	 * that the allocation isn't grown back to its last backed size
@@ -1413,6 +1481,9 @@ int kbase_update_region_flags(struct kbase_context *kctx,
 		reg->flags |= KBASE_REG_SHARE_IN;
 	}
 
+	if (flags & BASE_MEM_TILER_ALIGN_TOP)
+		reg->flags |= KBASE_REG_TILER_ALIGN_TOP;
+
 	/* Set up default MEMATTR usage */
 	if (kctx->kbdev->system_coherency == COHERENCY_ACE &&
 		(reg->flags & KBASE_REG_SHARE_BOTH)) {
@@ -1431,7 +1502,6 @@ int kbase_alloc_phy_pages_helper(
 	size_t nr_pages_requested)
 {
 	int new_page_count __maybe_unused;
-	size_t old_page_count = alloc->nents;
 	size_t nr_left = nr_pages_requested;
 	int res;
 	struct kbase_context *kctx;
@@ -1440,6 +1510,11 @@ int kbase_alloc_phy_pages_helper(
 	KBASE_DEBUG_ASSERT(alloc->type == KBASE_MEM_TYPE_NATIVE);
 	KBASE_DEBUG_ASSERT(alloc->imported.kctx);
 
+	if (alloc->reg) {
+		if (nr_pages_requested > alloc->reg->nr_pages - alloc->nents)
+			goto invalid_request;
+	}
+
 	kctx = alloc->imported.kctx;
 
 	if (nr_pages_requested == 0)
@@ -1454,7 +1529,7 @@ int kbase_alloc_phy_pages_helper(
 	 * allocation is visible to the OOM killer */
 	kbase_process_page_usage_inc(kctx, nr_pages_requested);
 
-	tp = alloc->pages + old_page_count;
+	tp = alloc->pages + alloc->nents;
 
 #ifdef CONFIG_MALI_2MB_ALLOC
 	/* Check if we have enough pages requested so we can allocate a large
@@ -1564,15 +1639,6 @@ int kbase_alloc_phy_pages_helper(
 			goto alloc_failed;
 	}
 
-	/*
-	 * Request a zone cache update, this scans only the new pages an
-	 * appends their information to the zone cache. if the update
-	 * fails then clear the cache so we fall-back to doing things
-	 * page by page.
-	 */
-	if (kbase_zone_cache_update(alloc, old_page_count) != 0)
-		kbase_zone_cache_clear(alloc);
-
 	KBASE_TLSTREAM_AUX_PAGESALLOC(
 			kctx->id,
 			(u64)new_page_count);
@@ -1586,7 +1652,7 @@ int kbase_alloc_phy_pages_helper(
 	if (nr_left != nr_pages_requested)
 		kbase_mem_pool_free_pages(&kctx->lp_mem_pool,
 				  nr_pages_requested - nr_left,
-				  alloc->pages + old_page_count,
+				  alloc->pages + alloc->nents,
 				  false,
 				  false);
 
@@ -1595,6 +1661,7 @@ int kbase_alloc_phy_pages_helper(
 	kbase_atomic_sub_pages(nr_pages_requested,
 			       &kctx->kbdev->memdev.used_pages);
 
+invalid_request:
 	return -ENOMEM;
 }
 
@@ -1650,15 +1717,6 @@ int kbase_free_phy_pages_helper(
 		start_free++;
 	}
 
-	/*
-	 * Clear the zone cache, we don't expect JIT allocations to be
-	 * shrunk in parts so there is no point trying to optimize for that
-	 * by scanning for the changes caused by freeing this memory and
-	 * updating the existing cache entries.
-	 */
-	kbase_zone_cache_clear(alloc);
-
-
 	while (nr_pages_to_free) {
 		if (is_huge_head(*start_free)) {
 			/* This is a 2MB entry, so free all the 512 pages that
@@ -1846,8 +1904,13 @@ bool kbase_check_alloc_flags(unsigned long flags)
 	if ((flags & (BASE_MEM_PROT_CPU_WR | BASE_MEM_PROT_GPU_WR)) == 0)
 		return false;
 
-	/* GPU cannot be writing to GPU executable memory and cannot grow the memory on page fault. */
-	if ((flags & BASE_MEM_PROT_GPU_EX) && (flags & (BASE_MEM_PROT_GPU_WR | BASE_MEM_GROW_ON_GPF)))
+	/* GPU executable memory cannot:
+	 * - Be written by the GPU
+	 * - Be grown on GPU page fault
+	 * - Have the top of its initial commit aligned to 'extent' */
+	if ((flags & BASE_MEM_PROT_GPU_EX) && (flags &
+			(BASE_MEM_PROT_GPU_WR | BASE_MEM_GROW_ON_GPF |
+			BASE_MEM_TILER_ALIGN_TOP)))
 		return false;
 
 	/* GPU should have at least read or write access otherwise there is no
@@ -1859,6 +1922,12 @@ bool kbase_check_alloc_flags(unsigned long flags)
 	if ((flags & BASE_MEM_IMPORT_SHARED) == BASE_MEM_IMPORT_SHARED)
 		return false;
 
+	/* Should not combine BASE_MEM_COHERENT_LOCAL with
+	 * BASE_MEM_COHERENT_SYSTEM */
+	if ((flags & (BASE_MEM_COHERENT_LOCAL | BASE_MEM_COHERENT_SYSTEM)) ==
+			(BASE_MEM_COHERENT_LOCAL | BASE_MEM_COHERENT_SYSTEM))
+		return false;
+
 	return true;
 }
 
@@ -1880,6 +1949,10 @@ bool kbase_check_import_flags(unsigned long flags)
 	if (flags & BASE_MEM_GROW_ON_GPF)
 		return false;
 
+	/* Imported memory cannot be aligned to the end of its initial commit */
+	if (flags & BASE_MEM_TILER_ALIGN_TOP)
+		return false;
+
 	/* GPU should have at least read or write access otherwise there is no
 	   reason for importing. */
 	if ((flags & (BASE_MEM_PROT_GPU_RD | BASE_MEM_PROT_GPU_WR)) == 0)
@@ -1892,6 +1965,89 @@ bool kbase_check_import_flags(unsigned long flags)
 	return true;
 }
 
+int kbase_check_alloc_sizes(struct kbase_context *kctx, unsigned long flags,
+		u64 va_pages, u64 commit_pages, u64 large_extent)
+{
+	struct device *dev = kctx->kbdev->dev;
+	int gpu_pc_bits = kctx->kbdev->gpu_props.props.core_props.log2_program_counter_size;
+	u64 gpu_pc_pages_max = 1ULL << gpu_pc_bits >> PAGE_SHIFT;
+	struct kbase_va_region test_reg;
+
+	/* kbase_va_region's extent member can be of variable size, so check against that type */
+	test_reg.extent = large_extent;
+
+#define KBASE_MSG_PRE "GPU allocation attempted with "
+
+	if (0 == va_pages) {
+		dev_warn(dev, KBASE_MSG_PRE "0 va_pages!");
+		return -EINVAL;
+	}
+
+	if (va_pages > (U64_MAX / PAGE_SIZE)) {
+		/* 64-bit address range is the max */
+		dev_warn(dev, KBASE_MSG_PRE "va_pages==%lld larger than 64-bit address range!",
+				(unsigned long long)va_pages);
+		return -ENOMEM;
+	}
+
+	/* Note: commit_pages is checked against va_pages during
+	 * kbase_alloc_phy_pages() */
+
+	/* Limit GPU executable allocs to GPU PC size */
+	if ((flags & BASE_MEM_PROT_GPU_EX) && (va_pages > gpu_pc_pages_max)) {
+		dev_warn(dev, KBASE_MSG_PRE "BASE_MEM_PROT_GPU_EX and va_pages==%lld larger than GPU PC range %lld",
+				(unsigned long long)va_pages,
+				(unsigned long long)gpu_pc_pages_max);
+
+		return -EINVAL;
+	}
+
+	if ((flags & (BASE_MEM_GROW_ON_GPF | BASE_MEM_TILER_ALIGN_TOP)) &&
+			test_reg.extent == 0) {
+		dev_warn(dev, KBASE_MSG_PRE "BASE_MEM_GROW_ON_GPF or BASE_MEM_TILER_ALIGN_TOP but extent == 0\n");
+		return -EINVAL;
+	}
+
+	if (!(flags & (BASE_MEM_GROW_ON_GPF | BASE_MEM_TILER_ALIGN_TOP)) &&
+			test_reg.extent != 0) {
+		dev_warn(dev, KBASE_MSG_PRE "neither BASE_MEM_GROW_ON_GPF nor BASE_MEM_TILER_ALIGN_TOP set but extent != 0\n");
+		return -EINVAL;
+	}
+
+	/* BASE_MEM_TILER_ALIGN_TOP memory has a number of restrictions */
+	if (flags & BASE_MEM_TILER_ALIGN_TOP) {
+#define KBASE_MSG_PRE_FLAG KBASE_MSG_PRE "BASE_MEM_TILER_ALIGN_TOP and "
+		unsigned long small_extent;
+
+		if (large_extent > BASE_MEM_TILER_ALIGN_TOP_EXTENT_MAX_PAGES) {
+			dev_warn(dev, KBASE_MSG_PRE_FLAG "extent==%lld pages exceeds limit %lld",
+					(unsigned long long)large_extent,
+					BASE_MEM_TILER_ALIGN_TOP_EXTENT_MAX_PAGES);
+			return -EINVAL;
+		}
+		/* For use with is_power_of_2, which takes unsigned long, so
+		 * must ensure e.g. on 32-bit kernel it'll fit in that type */
+		small_extent = (unsigned long)large_extent;
+
+		if (!is_power_of_2(small_extent)) {
+			dev_warn(dev, KBASE_MSG_PRE_FLAG "extent==%ld not a non-zero power of 2",
+					small_extent);
+			return -EINVAL;
+		}
+
+		if (commit_pages > large_extent) {
+			dev_warn(dev, KBASE_MSG_PRE_FLAG "commit_pages==%ld exceeds extent==%ld",
+					(unsigned long)commit_pages,
+					(unsigned long)large_extent);
+			return -EINVAL;
+		}
+#undef KBASE_MSG_PRE_FLAG
+	}
+
+	return 0;
+#undef KBASE_MSG_PRE
+}
+
 /**
  * @brief Acquire the per-context region list lock
  */
@@ -2120,6 +2276,7 @@ static void kbase_jit_destroy_worker(struct work_struct *work)
 		mutex_unlock(&kctx->jit_evict_lock);
 
 		kbase_gpu_vm_lock(kctx);
+		reg->flags &= ~KBASE_REG_JIT;
 		kbase_mem_free_region(kctx, reg);
 		kbase_gpu_vm_unlock(kctx);
 	} while (1);
@@ -2245,6 +2402,8 @@ struct kbase_va_region *kbase_jit_allocate(struct kbase_context *kctx,
 		if (!reg)
 			goto out_unlocked;
 
+		reg->flags |= KBASE_REG_JIT;
+
 		mutex_lock(&kctx->jit_evict_lock);
 		list_add(&reg->jit_node, &kctx->jit_active_head);
 		mutex_unlock(&kctx->jit_evict_lock);
@@ -2316,8 +2475,10 @@ bool kbase_jit_evict(struct kbase_context *kctx)
 	}
 	mutex_unlock(&kctx->jit_evict_lock);
 
-	if (reg)
+	if (reg) {
+		reg->flags &= ~KBASE_REG_JIT;
 		kbase_mem_free_region(kctx, reg);
+	}
 
 	return (reg != NULL);
 }
@@ -2342,6 +2503,7 @@ void kbase_jit_term(struct kbase_context *kctx)
 				struct kbase_va_region, jit_node);
 		list_del(&walker->jit_node);
 		mutex_unlock(&kctx->jit_evict_lock);
+		walker->flags &= ~KBASE_REG_JIT;
 		kbase_mem_free_region(kctx, walker);
 		mutex_lock(&kctx->jit_evict_lock);
 	}
@@ -2352,6 +2514,7 @@ void kbase_jit_term(struct kbase_context *kctx)
 				struct kbase_va_region, jit_node);
 		list_del(&walker->jit_node);
 		mutex_unlock(&kctx->jit_evict_lock);
+		walker->flags &= ~KBASE_REG_JIT;
 		kbase_mem_free_region(kctx, walker);
 		mutex_lock(&kctx->jit_evict_lock);
 	}
@@ -2373,6 +2536,7 @@ static int kbase_jd_user_buf_map(struct kbase_context *kctx,
 	struct device *dev;
 	unsigned long offset;
 	unsigned long local_size;
+	unsigned long gwt_mask = ~0;
 
 	alloc = reg->gpu_alloc;
 	pa = kbase_get_gpu_phy_pages(reg);
@@ -2441,10 +2605,14 @@ static int kbase_jd_user_buf_map(struct kbase_context *kctx,
 	}
 
 	alloc->nents = pinned_pages;
+#ifdef CONFIG_MALI_JOB_DUMP
+	if (kctx->gwt_enabled)
+		gwt_mask = ~KBASE_REG_GPU_WR;
+#endif
 
 	err = kbase_mmu_insert_pages(kctx, reg->start_pfn, pa,
 			kbase_reg_current_backed_size(reg),
-			reg->flags);
+			reg->flags & gwt_mask);
 	if (err == 0)
 		return 0;
 
@@ -2598,35 +2766,9 @@ static void kbase_jd_umm_unmap(struct kbase_context *kctx,
 }
 #endif				/* CONFIG_DMA_SHARED_BUFFER */
 
-#if (defined(CONFIG_KDS) && defined(CONFIG_UMP)) \
-		|| defined(CONFIG_DMA_SHARED_BUFFER_USES_KDS)
-static void add_kds_resource(struct kds_resource *kds_res,
-		struct kds_resource **kds_resources, u32 *kds_res_count,
-		unsigned long *kds_access_bitmap, bool exclusive)
-{
-	u32 i;
-
-	for (i = 0; i < *kds_res_count; i++) {
-		/* Duplicate resource, ignore */
-		if (kds_resources[i] == kds_res)
-			return;
-	}
-
-	kds_resources[*kds_res_count] = kds_res;
-	if (exclusive)
-		set_bit(*kds_res_count, kds_access_bitmap);
-	(*kds_res_count)++;
-}
-#endif
-
 struct kbase_mem_phy_alloc *kbase_map_external_resource(
 		struct kbase_context *kctx, struct kbase_va_region *reg,
-		struct mm_struct *locked_mm
-#ifdef CONFIG_KDS
-		, u32 *kds_res_count, struct kds_resource **kds_resources,
-		unsigned long *kds_access_bitmap, bool exclusive
-#endif
-		)
+		struct mm_struct *locked_mm)
 {
 	int err;
 
@@ -2647,34 +2789,10 @@ struct kbase_mem_phy_alloc *kbase_map_external_resource(
 	}
 	break;
 	case KBASE_MEM_TYPE_IMPORTED_UMP: {
-#if defined(CONFIG_KDS) && defined(CONFIG_UMP)
-		if (kds_res_count) {
-			struct kds_resource *kds_res;
-
-			kds_res = ump_dd_kds_resource_get(
-					reg->gpu_alloc->imported.ump_handle);
-			if (kds_res)
-				add_kds_resource(kds_res, kds_resources,
-						kds_res_count,
-						kds_access_bitmap, exclusive);
-		}
-#endif				/*defined(CONFIG_KDS) && defined(CONFIG_UMP) */
 		break;
 	}
 #ifdef CONFIG_DMA_SHARED_BUFFER
 	case KBASE_MEM_TYPE_IMPORTED_UMM: {
-#ifdef CONFIG_DMA_SHARED_BUFFER_USES_KDS
-		if (kds_res_count) {
-			struct kds_resource *kds_res;
-
-			kds_res = get_dma_buf_kds_resource(
-					reg->gpu_alloc->imported.umm.dma_buf);
-			if (kds_res)
-				add_kds_resource(kds_res, kds_resources,
-						kds_res_count,
-						kds_access_bitmap, exclusive);
-		}
-#endif
 		reg->gpu_alloc->imported.umm.current_mapping_usage_count++;
 		if (1 == reg->gpu_alloc->imported.umm.current_mapping_usage_count) {
 			err = kbase_jd_umm_map(kctx, reg);
@@ -2782,12 +2900,7 @@ struct kbase_ctx_ext_res_meta *kbase_sticky_resource_acquire(
 		 * Fill in the metadata object and acquire a reference
 		 * for the physical resource.
 		 */
-		meta->alloc = kbase_map_external_resource(kctx, reg, NULL
-#ifdef CONFIG_KDS
-				, NULL, NULL,
-				NULL, false
-#endif
-				);
+		meta->alloc = kbase_map_external_resource(kctx, reg, NULL);
 
 		if (!meta->alloc)
 			goto fail_map;
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem.h b/drivers/gpu/arm/bifrost/mali_kbase_mem.h
index 9d98947390f6..f67255121f5e 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_mem.h
  * Base kernel memory APIs
@@ -30,9 +35,6 @@
 #endif
 
 #include <linux/kref.h>
-#ifdef CONFIG_KDS
-#include <linux/kds.h>
-#endif				/* CONFIG_KDS */
 #ifdef CONFIG_UMP
 #include <linux/ump.h>
 #endif				/* CONFIG_UMP */
@@ -129,8 +131,6 @@ struct kbase_mem_phy_alloc {
 
 	unsigned long properties;
 
-	struct list_head       zone_cache;
-
 	/* member in union valid based on @a type */
 	union {
 #ifdef CONFIG_UMP
@@ -238,6 +238,9 @@ struct kbase_va_region {
 
 	u64 start_pfn;		/* The PFN in GPU space */
 	size_t nr_pages;
+	/* Initial commit, for aligning the start address and correctly growing
+	 * KBASE_REG_TILER_ALIGN_TOP regions */
+	size_t initial_commit;
 
 /* Free region */
 #define KBASE_REG_FREE              (1ul << 0)
@@ -289,6 +292,13 @@ struct kbase_va_region {
  * Do not remove, use the next unreserved bit for new flags */
 #define KBASE_REG_RESERVED_BIT_22   (1ul << 22)
 
+/* The top of the initial commit is aligned to extent pages.
+ * Extent must be a power of 2 */
+#define KBASE_REG_TILER_ALIGN_TOP   (1ul << 23)
+
+/* Memory is handled by JIT - user space should not be able to free it */
+#define KBASE_REG_JIT               (1ul << 24)
+
 #define KBASE_REG_ZONE_SAME_VA      KBASE_REG_ZONE(0)
 
 /* only used with 32-bit clients */
@@ -320,9 +330,6 @@ struct kbase_va_region {
 	struct kbase_mem_phy_alloc *cpu_alloc; /* the one alloc object we mmap to the CPU when mapping this region */
 	struct kbase_mem_phy_alloc *gpu_alloc; /* the one alloc object we mmap to the GPU when mapping this region */
 
-	/* non-NULL if this memory object is a kds_resource */
-	struct kds_resource *kds_res;
-
 	/* List head used to store the region in the JIT allocation pool */
 	struct list_head jit_node;
 };
@@ -406,7 +413,6 @@ static inline struct kbase_mem_phy_alloc *kbase_alloc_create(size_t nr_pages, en
 	alloc->pages = (void *)(alloc + 1);
 	INIT_LIST_HEAD(&alloc->mappings);
 	alloc->type = type;
-	INIT_LIST_HEAD(&alloc->zone_cache);
 
 	if (type == KBASE_MEM_TYPE_IMPORTED_USER_BUF)
 		alloc->imported.user_buf.dma_addrs =
@@ -441,7 +447,6 @@ static inline int kbase_reg_prepare_native(struct kbase_va_region *reg,
 		reg->gpu_alloc = kbase_mem_phy_alloc_get(reg->cpu_alloc);
 	}
 
-	INIT_LIST_HEAD(&reg->jit_node);
 	reg->flags &= ~KBASE_REG_FREE;
 	return 0;
 }
@@ -674,6 +679,25 @@ int kbase_add_va_region(struct kbase_context *kctx, struct kbase_va_region *reg,
 bool kbase_check_alloc_flags(unsigned long flags);
 bool kbase_check_import_flags(unsigned long flags);
 
+/**
+ * kbase_check_alloc_sizes - check user space sizes parameters for an
+ *                           allocation
+ *
+ * @kctx:         kbase context
+ * @flags:        The flags passed from user space
+ * @va_pages:     The size of the requested region, in pages.
+ * @commit_pages: Number of pages to commit initially.
+ * @extent:       Number of pages to grow by on GPU page fault and/or alignment
+ *                (depending on flags)
+ *
+ * Makes checks on the size parameters passed in from user space for a memory
+ * allocation call, with respect to the flags requested.
+ *
+ * Return: 0 if sizes are valid for these flags, negative error code otherwise
+ */
+int kbase_check_alloc_sizes(struct kbase_context *kctx, unsigned long flags,
+		u64 va_pages, u64 commit_pages, u64 extent);
+
 /**
  * kbase_update_region_flags - Convert user space flags to kernel region flags
  *
@@ -710,6 +734,9 @@ int kbase_mmu_insert_single_page(struct kbase_context *kctx, u64 vpfn,
 					unsigned long flags);
 
 int kbase_mmu_teardown_pages(struct kbase_context *kctx, u64 vpfn, size_t nr);
+int kbase_mmu_update_pages_no_flush(struct kbase_context *kctx, u64 vpfn,
+					struct tagged_addr *phys, size_t nr,
+					unsigned long flags);
 int kbase_mmu_update_pages(struct kbase_context *kctx, u64 vpfn,
 			   struct tagged_addr *phys, size_t nr,
 			   unsigned long flags);
@@ -864,6 +891,32 @@ int kbasep_find_enclosing_cpu_mapping_offset(
 		struct kbase_context *kctx,
 		unsigned long uaddr, size_t size, u64 *offset);
 
+/**
+ * kbasep_find_enclosing_gpu_mapping_start_and_offset() - Find the address of
+ * the start of GPU virtual memory region which encloses @gpu_addr for the
+ * @size length in bytes
+ *
+ * Searches for the memory region in GPU virtual memory space which contains
+ * the region defined by the @gpu_addr and @size, where @gpu_addr is the
+ * beginning and @size the length in bytes of the provided region. If found,
+ * the location of the start address of the GPU virtual memory region is
+ * passed in @start pointer and the location of the offset of the region into
+ * the GPU virtual memory region is passed in @offset pointer.
+ *
+ * @kctx:	The kernel base context within which the memory is searched.
+ * @gpu_addr:	GPU virtual address for which the region is sought; defines
+ *              the beginning of the provided region.
+ * @size:       The length (in bytes) of the provided region for which the
+ *              GPU virtual memory region is sought.
+ * @start:      Pointer to the location where the address of the start of
+ *              the found GPU virtual memory region is.
+ * @offset:     Pointer to the location where the offset of @gpu_addr into
+ *              the found GPU virtual memory region is.
+ */
+int kbasep_find_enclosing_gpu_mapping_start_and_offset(
+		struct kbase_context *kctx,
+		u64 gpu_addr, size_t size, u64 *start, u64 *offset);
+
 enum hrtimer_restart kbasep_as_poke_timer_callback(struct hrtimer *timer);
 void kbase_as_poking_timer_retain_atom(struct kbase_device *kbdev, struct kbase_context *kctx, struct kbase_jd_atom *katom);
 void kbase_as_poking_timer_release_atom(struct kbase_device *kbdev, struct kbase_context *kctx, struct kbase_jd_atom *katom);
@@ -1040,22 +1093,13 @@ void kbase_jit_term(struct kbase_context *kctx);
  * @kctx:              kbase context.
  * @reg:               The region to map.
  * @locked_mm:         The mm_struct which has been locked for this operation.
- * @kds_res_count:     The number of KDS resources.
- * @kds_resources:     Array of KDS resources.
- * @kds_access_bitmap: Access bitmap for KDS.
- * @exclusive:         If the KDS resource requires exclusive access.
  *
  * Return: The physical allocation which backs the region on success or NULL
  * on failure.
  */
 struct kbase_mem_phy_alloc *kbase_map_external_resource(
 		struct kbase_context *kctx, struct kbase_va_region *reg,
-		struct mm_struct *locked_mm
-#ifdef CONFIG_KDS
-		, u32 *kds_res_count, struct kds_resource **kds_resources,
-		unsigned long *kds_access_bitmap, bool exclusive
-#endif
-		);
+		struct mm_struct *locked_mm);
 
 /**
  * kbase_unmap_external_resource - Unmap an external resource from the GPU.
@@ -1106,37 +1150,4 @@ bool kbase_sticky_resource_release(struct kbase_context *kctx,
  */
 void kbase_sticky_resource_term(struct kbase_context *kctx);
 
-/**
- * kbase_zone_cache_update - Update the memory zone cache after new pages have
- * been added.
- * @alloc:        The physical memory allocation to build the cache for.
- * @start_offset: Offset to where the new pages start.
- *
- * Updates an existing memory zone cache, updating the counters for the
- * various zones.
- * If the memory allocation doesn't already have a zone cache assume that
- * one isn't created and thus don't do anything.
- *
- * Return: Zero cache was updated, negative error code on error.
- */
-int kbase_zone_cache_update(struct kbase_mem_phy_alloc *alloc,
-		size_t start_offset);
-
-/**
- * kbase_zone_cache_build - Build the memory zone cache.
- * @alloc:        The physical memory allocation to build the cache for.
- *
- * Create a new zone cache for the provided physical memory allocation if
- * one doesn't already exist, if one does exist then just return.
- *
- * Return: Zero if the zone cache was created, negative error code on error.
- */
-int kbase_zone_cache_build(struct kbase_mem_phy_alloc *alloc);
-
-/**
- * kbase_zone_cache_clear - Clear the memory zone cache.
- * @alloc:        The physical memory allocation to clear the cache on.
- */
-void kbase_zone_cache_clear(struct kbase_mem_phy_alloc *alloc);
-
 #endif				/* _KBASE_MEM_H_ */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem_linux.c b/drivers/gpu/arm/bifrost/mali_kbase_mem_linux.c
index 842444c9b0bd..4e6668e62477 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem_linux.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem_linux.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_mem_linux.c
  * Base kernel memory APIs, Linux implementation.
@@ -44,6 +49,7 @@
 #include <mali_kbase_mem_linux.h>
 #include <mali_kbase_config_defaults.h>
 #include <mali_kbase_tlstream.h>
+#include <mali_kbase_ioctl.h>
 
 static int kbase_tracking_page_setup(struct kbase_context *kctx, struct vm_area_struct *vma);
 
@@ -85,7 +91,6 @@ struct kbase_va_region *kbase_mem_alloc(struct kbase_context *kctx,
 		u64 *gpu_va)
 {
 	int zone;
-	int gpu_pc_bits;
 	struct kbase_va_region *reg;
 	struct device *dev;
 
@@ -96,17 +101,6 @@ struct kbase_va_region *kbase_mem_alloc(struct kbase_context *kctx,
 	dev = kctx->kbdev->dev;
 	*gpu_va = 0; /* return 0 on failure */
 
-	gpu_pc_bits = kctx->kbdev->gpu_props.props.core_props.log2_program_counter_size;
-
-	if (0 == va_pages) {
-		dev_warn(dev, "kbase_mem_alloc called with 0 va_pages!");
-		goto bad_size;
-	}
-
-	if (va_pages > (U64_MAX / PAGE_SIZE))
-		/* 64-bit address range is the max */
-		goto bad_size;
-
 	if (!kbase_check_alloc_flags(*flags)) {
 		dev_warn(dev,
 				"kbase_mem_alloc called with bad flags (%llx)",
@@ -125,10 +119,8 @@ struct kbase_va_region *kbase_mem_alloc(struct kbase_context *kctx,
 		*flags &= ~BASE_MEM_COHERENT_SYSTEM;
 	}
 
-	/* Limit GPU executable allocs to GPU PC size */
-	if ((*flags & BASE_MEM_PROT_GPU_EX) &&
-	    (va_pages > (1ULL << gpu_pc_bits >> PAGE_SHIFT)))
-		goto bad_ex_size;
+	if (kbase_check_alloc_sizes(kctx, *flags, va_pages, commit_pages, extent))
+		goto bad_sizes;
 
 	/* find out which VA zone to use */
 	if (*flags & BASE_MEM_SAME_VA)
@@ -152,10 +144,13 @@ struct kbase_va_region *kbase_mem_alloc(struct kbase_context *kctx,
 		goto prepare_failed;
 	}
 
-	if (*flags & BASE_MEM_GROW_ON_GPF)
+	if (*flags & (BASE_MEM_GROW_ON_GPF|BASE_MEM_TILER_ALIGN_TOP)) {
+		/* kbase_check_alloc_sizes() already checks extent is valid for
+		 * assigning to reg->extent */
 		reg->extent = extent;
-	else
+	} else {
 		reg->extent = 0;
+	}
 
 	if (kbase_alloc_phy_pages(reg, va_pages, commit_pages) != 0) {
 		dev_warn(dev, "Failed to allocate %lld pages (va_pages=%lld)",
@@ -163,6 +158,7 @@ struct kbase_va_region *kbase_mem_alloc(struct kbase_context *kctx,
 				(unsigned long long)va_pages);
 		goto no_mem;
 	}
+	reg->initial_commit = commit_pages;
 
 	kbase_gpu_vm_lock(kctx);
 
@@ -241,9 +237,8 @@ struct kbase_va_region *kbase_mem_alloc(struct kbase_context *kctx,
 prepare_failed:
 	kfree(reg);
 no_region:
-bad_ex_size:
+bad_sizes:
 bad_flags:
-bad_size:
 	return NULL;
 }
 KBASE_EXPORT_TEST_API(kbase_mem_alloc);
@@ -303,6 +298,23 @@ int kbase_mem_query(struct kbase_context *kctx, u64 gpu_addr, int query, u64 * c
 			*out |= BASE_MEM_COHERENT_SYSTEM;
 		if (KBASE_REG_SHARE_IN & reg->flags)
 			*out |= BASE_MEM_COHERENT_LOCAL;
+		if (kctx->api_version >= KBASE_API_VERSION(11, 2)) {
+			/* Prior to 11.2, these were known about by user-side
+			 * but we did not return them. Returning some of these
+			 * caused certain clients that were not expecting them
+			 * to fail, so we omit all of them as a special-case
+			 * for compatibility reasons */
+			if (KBASE_REG_PF_GROW & reg->flags)
+				*out |= BASE_MEM_GROW_ON_GPF;
+			if (KBASE_REG_SECURE & reg->flags)
+				*out |= BASE_MEM_SECURE;
+		}
+		if (KBASE_REG_TILER_ALIGN_TOP & reg->flags)
+			*out |= BASE_MEM_TILER_ALIGN_TOP;
+
+		WARN(*out & ~BASE_MEM_FLAGS_QUERYABLE,
+				"BASE_MEM_FLAGS_QUERYABLE needs updating\n");
+		*out &= BASE_MEM_FLAGS_QUERYABLE;
 		break;
 	}
 	default:
@@ -455,100 +467,6 @@ void kbase_mem_evictable_deinit(struct kbase_context *kctx)
 	unregister_shrinker(&kctx->reclaim);
 }
 
-struct kbase_mem_zone_cache_entry {
-	/* List head used to link the cache entry to the memory allocation. */
-	struct list_head zone_node;
-	/* The zone the cacheline is for. */
-	struct zone *zone;
-	/* The number of pages in the allocation which belong to this zone. */
-	u64 count;
-};
-
-static bool kbase_zone_cache_builder(struct kbase_mem_phy_alloc *alloc,
-		size_t start_offset)
-{
-	struct kbase_mem_zone_cache_entry *cache = NULL;
-	size_t i;
-	int ret = 0;
-
-	for (i = start_offset; i < alloc->nents; i++) {
-		struct page *p = phys_to_page(as_phys_addr_t(alloc->pages[i]));
-		struct zone *zone = page_zone(p);
-		bool create = true;
-
-		if (cache && (cache->zone == zone)) {
-			/*
-			 * Fast path check as most of the time adjacent
-			 * pages come from the same zone.
-			 */
-			create = false;
-		} else {
-			/*
-			 * Slow path check, walk all the cache entries to see
-			 * if we already know about this zone.
-			 */
-			list_for_each_entry(cache, &alloc->zone_cache, zone_node) {
-				if (cache->zone == zone) {
-					create = false;
-					break;
-				}
-			}
-		}
-
-		/* This zone wasn't found in the cache, create an entry for it */
-		if (create) {
-			cache = kmalloc(sizeof(*cache), GFP_KERNEL);
-			if (!cache) {
-				ret = -ENOMEM;
-				goto bail;
-			}
-			cache->zone = zone;
-			cache->count = 0;
-			list_add(&cache->zone_node, &alloc->zone_cache);
-		}
-
-		cache->count++;
-	}
-	return 0;
-
-bail:
-	return ret;
-}
-
-int kbase_zone_cache_update(struct kbase_mem_phy_alloc *alloc,
-		size_t start_offset)
-{
-	/*
-	 * Bail if the zone cache is empty, only update the cache if it
-	 * existed in the first place.
-	 */
-	if (list_empty(&alloc->zone_cache))
-		return 0;
-
-	return kbase_zone_cache_builder(alloc, start_offset);
-}
-
-int kbase_zone_cache_build(struct kbase_mem_phy_alloc *alloc)
-{
-	/* Bail if the zone cache already exists */
-	if (!list_empty(&alloc->zone_cache))
-		return 0;
-
-	return kbase_zone_cache_builder(alloc, 0);
-}
-
-void kbase_zone_cache_clear(struct kbase_mem_phy_alloc *alloc)
-{
-	struct kbase_mem_zone_cache_entry *walker;
-
-	while(!list_empty(&alloc->zone_cache)){
-		walker = list_first_entry(&alloc->zone_cache,
-				struct kbase_mem_zone_cache_entry, zone_node);
-		list_del(&walker->zone_node);
-		kfree(walker);
-	}
-}
-
 /**
  * kbase_mem_evictable_mark_reclaim - Mark the pages as reclaimable.
  * @alloc: The physical allocation
@@ -556,32 +474,7 @@ void kbase_zone_cache_clear(struct kbase_mem_phy_alloc *alloc)
 static void kbase_mem_evictable_mark_reclaim(struct kbase_mem_phy_alloc *alloc)
 {
 	struct kbase_context *kctx = alloc->imported.kctx;
-	struct kbase_mem_zone_cache_entry *zone_cache;
 	int __maybe_unused new_page_count;
-	int err;
-
-	/* Attempt to build a zone cache of tracking */
-	err = kbase_zone_cache_build(alloc);
-	if (err == 0) {
-		/* Bulk update all the zones */
-		list_for_each_entry(zone_cache, &alloc->zone_cache, zone_node) {
-			zone_page_state_add(zone_cache->count,
-					zone_cache->zone, NR_SLAB_RECLAIMABLE);
-		}
-	} else {
-		/* Fall-back to page by page updates */
-		int i;
-
-		for (i = 0; i < alloc->nents; i++) {
-			struct page *p;
-			struct zone *zone;
-
-			p = phys_to_page(as_phys_addr_t(alloc->pages[i]));
-			zone = page_zone(p);
-
-			zone_page_state_add(1, zone, NR_SLAB_RECLAIMABLE);
-		}
-	}
 
 	kbase_process_page_usage_dec(kctx, alloc->nents);
 	new_page_count = kbase_atomic_sub_pages(alloc->nents,
@@ -601,9 +494,7 @@ static
 void kbase_mem_evictable_unmark_reclaim(struct kbase_mem_phy_alloc *alloc)
 {
 	struct kbase_context *kctx = alloc->imported.kctx;
-	struct kbase_mem_zone_cache_entry *zone_cache;
 	int __maybe_unused new_page_count;
-	int err;
 
 	new_page_count = kbase_atomic_add_pages(alloc->nents,
 						&kctx->used_pages);
@@ -611,31 +502,9 @@ void kbase_mem_evictable_unmark_reclaim(struct kbase_mem_phy_alloc *alloc)
 
 	/* Increase mm counters so that the allocation is accounted for
 	 * against the process and thus is visible to the OOM killer,
-	 * then remove it from the reclaimable accounting. */
+	 */
 	kbase_process_page_usage_inc(kctx, alloc->nents);
 
-	/* Attempt to build a zone cache of tracking */
-	err = kbase_zone_cache_build(alloc);
-	if (err == 0) {
-		/* Bulk update all the zones */
-		list_for_each_entry(zone_cache, &alloc->zone_cache, zone_node) {
-			zone_page_state_add(-zone_cache->count,
-					zone_cache->zone, NR_SLAB_RECLAIMABLE);
-		}
-	} else {
-		/* Fall-back to page by page updates */
-		int i;
-
-		for (i = 0; i < alloc->nents; i++) {
-			struct page *p;
-			struct zone *zone;
-
-			p = phys_to_page(as_phys_addr_t(alloc->pages[i]));
-			zone = page_zone(p);
-			zone_page_state_add(-1, zone, NR_SLAB_RECLAIMABLE);
-		}
-	}
-
 	KBASE_TLSTREAM_AUX_PAGESALLOC(
 			kctx->id,
 			(u64)new_page_count);
@@ -1440,10 +1309,9 @@ int kbase_mem_import(struct kbase_context *kctx, enum base_mem_import_type type,
 	KBASE_DEBUG_ASSERT(va_pages);
 	KBASE_DEBUG_ASSERT(flags);
 
-#ifdef CONFIG_64BIT
-	if (!kbase_ctx_flag(kctx, KCTX_COMPAT))
+	if ((!kbase_ctx_flag(kctx, KCTX_COMPAT)) &&
+			kbase_ctx_flag(kctx, KCTX_FORCE_SAME_VA))
 		*flags |= BASE_MEM_SAME_VA;
-#endif
 
 	if (!kbase_check_import_flags(*flags)) {
 		dev_warn(kctx->kbdev->dev,
@@ -2182,8 +2050,10 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 
 	dev_dbg(dev, "kbase_mmap\n");
 
-	/* strip away corresponding VM_MAY% flags to the VM_% flags requested */
-	vma->vm_flags &= ~((vma->vm_flags & (VM_READ | VM_WRITE)) << 4);
+	if (!(vma->vm_flags & VM_READ))
+		vma->vm_flags &= ~VM_MAYREAD;
+	if (!(vma->vm_flags & VM_WRITE))
+		vma->vm_flags &= ~VM_MAYWRITE;
 
 	if (0 == nr_pages) {
 		err = -EINVAL;
@@ -2259,9 +2129,9 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 			}
 
 			if ((vma->vm_flags & VM_READ &&
-			     !(reg->flags & KBASE_REG_CPU_RD)) ||
-			    (vma->vm_flags & VM_WRITE &&
-			     !(reg->flags & KBASE_REG_CPU_WR))) {
+					!(reg->flags & KBASE_REG_CPU_RD)) ||
+					(vma->vm_flags & VM_WRITE &&
+					!(reg->flags & KBASE_REG_CPU_WR))) {
 				/* VM flags inconsistent with region flags */
 				err = -EPERM;
 				dev_err(dev, "%s:%d inconsistent VM flags\n",
@@ -2272,6 +2142,12 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 #ifdef CONFIG_DMA_SHARED_BUFFER
 			if (KBASE_MEM_TYPE_IMPORTED_UMM ==
 							reg->cpu_alloc->type) {
+				if (0 != (vma->vm_pgoff - reg->start_pfn)) {
+					err = -EINVAL;
+					dev_warn(dev, "%s:%d attempt to do a partial map in a dma_buf: non-zero offset to dma_buf mapping!\n",
+						__FILE__, __LINE__);
+					goto out_unlock;
+				}
 				err = dma_buf_mmap(
 					reg->cpu_alloc->imported.umm.dma_buf,
 					vma, vma->vm_pgoff - reg->start_pfn);
@@ -2608,7 +2484,7 @@ void *kbase_va_alloc(struct kbase_context *kctx, u32 size, struct kbase_hwc_dma_
 	page_array = kbase_get_cpu_phy_pages(reg);
 
 	for (i = 0; i < pages; i++)
-		page_array[i] = as_tagged(dma_pa + (i << PAGE_SHIFT));
+		page_array[i] = as_tagged(dma_pa + ((dma_addr_t)i << PAGE_SHIFT));
 
 	reg->cpu_alloc->nents = pages;
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem_linux.h b/drivers/gpu/arm/bifrost/mali_kbase_mem_linux.h
index db35f62a7431..301fdc33ea1e 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem_linux.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem_linux.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_mem_linux.h
  * Base kernel memory APIs, Linux implementation.
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem_lowlevel.h b/drivers/gpu/arm/bifrost/mali_kbase_mem_lowlevel.h
index f4e88491327e..0c2b70bcfbf5 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem_lowlevel.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem_lowlevel.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #ifndef _KBASE_MEM_LOWLEVEL_H
 #define _KBASE_MEM_LOWLEVEL_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem_pool.c b/drivers/gpu/arm/bifrost/mali_kbase_mem_pool.c
index 696730ac5b2b..574f1d51cccf 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem_pool.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem_pool.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
@@ -70,8 +75,6 @@ static void kbase_mem_pool_add_locked(struct kbase_mem_pool *pool,
 	list_add(&p->lru, &pool->page_list);
 	pool->cur_size++;
 
-	zone_page_state_add(1, page_zone(p), NR_SLAB_RECLAIMABLE);
-
 	pool_dbg(pool, "added page\n");
 }
 
@@ -85,14 +88,8 @@ static void kbase_mem_pool_add(struct kbase_mem_pool *pool, struct page *p)
 static void kbase_mem_pool_add_list_locked(struct kbase_mem_pool *pool,
 		struct list_head *page_list, size_t nr_pages)
 {
-	struct page *p;
-
 	lockdep_assert_held(&pool->pool_lock);
 
-	list_for_each_entry(p, page_list, lru) {
-		zone_page_state_add(1, page_zone(p), NR_SLAB_RECLAIMABLE);
-	}
-
 	list_splice(page_list, &pool->page_list);
 	pool->cur_size += nr_pages;
 
@@ -120,8 +117,6 @@ static struct page *kbase_mem_pool_remove_locked(struct kbase_mem_pool *pool)
 	list_del_init(&p->lru);
 	pool->cur_size--;
 
-	zone_page_state_add(-1, page_zone(p), NR_SLAB_RECLAIMABLE);
-
 	pool_dbg(pool, "removed page\n");
 
 	return p;
@@ -639,10 +634,6 @@ void kbase_mem_pool_free_pages(struct kbase_mem_pool *pool, size_t nr_pages,
 
 		p = phys_to_page(as_phys_addr_t(pages[i]));
 
-		if (reclaimed)
-			zone_page_state_add(-1, page_zone(p),
-					NR_SLAB_RECLAIMABLE);
-
 		kbase_mem_pool_free_page(pool, p);
 		pages[i] = as_tagged(0);
 	}
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem_pool_debugfs.c b/drivers/gpu/arm/bifrost/mali_kbase_mem_pool_debugfs.c
index 319cf2568aba..4b4eeb32d2c1 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem_pool_debugfs.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem_pool_debugfs.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem_pool_debugfs.h b/drivers/gpu/arm/bifrost/mali_kbase_mem_pool_debugfs.h
index 496eaf3f1e1a..990d91c8fbe7 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem_pool_debugfs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem_pool_debugfs.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_MEM_POOL_DEBUGFS_H
 #define _KBASE_MEM_POOL_DEBUGFS_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs.c b/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs.c
index d58fd8d62fde..d4f8433f4087 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 
 #ifdef CONFIG_DEBUG_FS
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs.h b/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs.h
index a1dc2e0b165b..1462247c3bca 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_mem_profile_debugfs.h
  * Header file for mem profiles entries in debugfs
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs_buf_size.h b/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs_buf_size.h
index 82f0702974c2..cb968f65fc5c 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs_buf_size.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mem_profile_debugfs_buf_size.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /**
  * @file mali_kbase_mem_profile_debugfs_buf_size.h
  * Header file for the size of the buffer to accumulate the histogram report text in
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mmu.c b/drivers/gpu/arm/bifrost/mali_kbase_mmu.c
index c63269aed53c..f8979d9841da 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mmu.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mmu.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_mmu.c
  * Base kernel MMU management.
@@ -99,16 +104,207 @@ static void kbase_mmu_report_fault_and_kill(struct kbase_context *kctx,
 		struct kbase_as *as, const char *reason_str);
 
 
-static size_t make_multiple(size_t minimum, size_t multiple)
+/**
+ * reg_grow_calc_extra_pages() - Calculate the number of backed pages to add to
+ *                               a region on a GPU page fault
+ *
+ * @reg:           The region that will be backed with more pages
+ * @fault_rel_pfn: PFN of the fault relative to the start of the region
+ *
+ * This calculates how much to increase the backing of a region by, based on
+ * where a GPU page fault occurred and the flags in the region.
+ *
+ * This can be more than the minimum number of pages that would reach
+ * @fault_rel_pfn, for example to reduce the overall rate of page fault
+ * interrupts on a region, or to ensure that the end address is aligned.
+ *
+ * Return: the number of backed pages to increase by
+ */
+static size_t reg_grow_calc_extra_pages(struct kbase_va_region *reg, size_t fault_rel_pfn)
 {
-	size_t remainder = minimum % multiple;
+	size_t multiple = reg->extent;
+	size_t reg_current_size = kbase_reg_current_backed_size(reg);
+	size_t minimum_extra = fault_rel_pfn - reg_current_size + 1;
+	size_t remainder;
+
+	if (!multiple) {
+		dev_warn(reg->kctx->kbdev->dev,
+				"VA Region 0x%llx extent was 0, allocator needs to set this properly for KBASE_REG_PF_GROW\n",
+				((unsigned long long)reg->start_pfn) << PAGE_SHIFT);
+		return minimum_extra;
+	}
+
+	/* Calculate the remainder to subtract from minimum_extra to make it
+	 * the desired (rounded down) multiple of the extent.
+	 * Depending on reg's flags, the base used for calculating multiples is
+	 * different */
+	if (reg->flags & KBASE_REG_TILER_ALIGN_TOP) {
+		/* multiple is based from the top of the initial commit, which
+		 * has been allocated in such a way that (start_pfn +
+		 * initial_commit) is already aligned to multiple. Hence the
+		 * pfn for the end of committed memory will also be aligned to
+		 * multiple */
+		size_t initial_commit = reg->initial_commit;
+
+		if (fault_rel_pfn < initial_commit) {
+			/* this case is just to catch in case it's been
+			 * recommitted by userspace to be smaller than the
+			 * initial commit */
+			minimum_extra = initial_commit - reg_current_size;
+			remainder = 0;
+		} else {
+			/* same as calculating (fault_rel_pfn - initial_commit + 1) */
+			size_t pages_after_initial = minimum_extra + reg_current_size - initial_commit;
+
+			remainder = pages_after_initial % multiple;
+		}
+	} else {
+		/* multiple is based from the current backed size, even if the
+		 * current backed size/pfn for end of committed memory are not
+		 * themselves aligned to multiple */
+		remainder = minimum_extra % multiple;
+	}
 
 	if (remainder == 0)
-		return minimum;
+		return minimum_extra;
+
+	return minimum_extra + multiple - remainder;
+}
+
+#ifdef CONFIG_MALI_JOB_DUMP
+static void kbase_gpu_mmu_handle_write_faulting_as(struct kbase_context *kctx,
+				struct kbase_device *kbdev,
+				struct kbase_as *faulting_as,
+				u64 start_pfn, size_t nr, u32 op)
+{
+	mutex_lock(&kbdev->mmu_hw_mutex);
+
+	kbase_mmu_hw_clear_fault(kbdev, faulting_as, kctx,
+			KBASE_MMU_FAULT_TYPE_PAGE);
+	kbase_mmu_hw_do_operation(kbdev, faulting_as, kctx, start_pfn,
+			nr, op, 1);
+
+	mutex_unlock(&kbdev->mmu_hw_mutex);
+
+	kbase_mmu_hw_enable_fault(kbdev, faulting_as, kctx,
+			KBASE_MMU_FAULT_TYPE_PAGE);
+}
+
+static void kbase_gpu_mmu_handle_write_fault(struct kbase_context *kctx,
+			struct kbase_as *faulting_as)
+{
+	struct kbasep_gwt_list_element *pos;
+	struct kbase_va_region *region;
+	struct kbase_device *kbdev;
+	u64 fault_pfn, pfn_offset;
+	u32 op;
+	int ret;
+	int as_no;
+
+	as_no = faulting_as->number;
+	kbdev = container_of(faulting_as, struct kbase_device, as[as_no]);
+	fault_pfn = faulting_as->fault_addr >> PAGE_SHIFT;
+
+	kbase_gpu_vm_lock(kctx);
+
+	/* Find region and check if it should be writable. */
+	region = kbase_region_tracker_find_region_enclosing_address(kctx,
+			faulting_as->fault_addr);
+	if (!region || region->flags & KBASE_REG_FREE) {
+		kbase_gpu_vm_unlock(kctx);
+		kbase_mmu_report_fault_and_kill(kctx, faulting_as,
+				"Memory is not mapped on the GPU");
+		return;
+	}
+
+	if (!(region->flags & KBASE_REG_GPU_WR)) {
+		kbase_gpu_vm_unlock(kctx);
+		kbase_mmu_report_fault_and_kill(kctx, faulting_as,
+				"Region does not have write permissions");
+		return;
+	}
+
+	/* Capture handle and offset of the faulting write location
+	 * for job dumping if write tracking is enabled.
+	 */
+	if (kctx->gwt_enabled) {
+		u64 page_addr = faulting_as->fault_addr & PAGE_MASK;
+		u64 offset = (page_addr >> PAGE_SHIFT) - region->start_pfn;
+		u64 handle = region->start_pfn << PAGE_SHIFT;
+		bool found = false;
+
+		if (KBASE_MEM_TYPE_IMPORTED_UMM == region->cpu_alloc->type)
+			handle |= BIT(0);
+
+		/* Check if this write was already handled. */
+		list_for_each_entry(pos, &kctx->gwt_current_list, link) {
+			if (handle == pos->handle &&
+					offset >= pos->offset &&
+					offset < pos->offset + pos->num_pages) {
+				found = true;
+				break;
+			}
+		}
+
+		if (!found) {
+			pos = kmalloc(sizeof(*pos), GFP_KERNEL);
+			if (pos) {
+				pos->handle = handle;
+				pos->offset = offset;
+				pos->num_pages = 1;
+				list_add(&pos->link, &kctx->gwt_current_list);
+			} else {
+				dev_warn(kbdev->dev, "kmalloc failure");
+			}
+		}
+	}
+
+	pfn_offset = fault_pfn - region->start_pfn;
+	/* Now make this faulting page writable to GPU. */
+	ret = kbase_mmu_update_pages_no_flush(kctx, fault_pfn,
+				&kbase_get_gpu_phy_pages(region)[pfn_offset],
+				1, region->flags);
+
+	/* flush L2 and unlock the VA (resumes the MMU) */
+	if (kbase_hw_has_issue(kbdev, BASE_HW_ISSUE_6367))
+		op = AS_COMMAND_FLUSH;
+	else
+		op = AS_COMMAND_FLUSH_PT;
+
+	kbase_gpu_mmu_handle_write_faulting_as(kctx, kbdev, faulting_as,
+			fault_pfn, 1, op);
 
-	return minimum + multiple - remainder;
+	kbase_gpu_vm_unlock(kctx);
 }
 
+static void kbase_gpu_mmu_handle_permission_fault(struct kbase_context *kctx,
+			struct kbase_as	*faulting_as)
+{
+	u32 fault_status;
+
+	fault_status = faulting_as->fault_status;
+
+	switch (fault_status & AS_FAULTSTATUS_ACCESS_TYPE_MASK) {
+	case AS_FAULTSTATUS_ACCESS_TYPE_ATOMIC:
+	case AS_FAULTSTATUS_ACCESS_TYPE_WRITE:
+		kbase_gpu_mmu_handle_write_fault(kctx, faulting_as);
+		break;
+	case AS_FAULTSTATUS_ACCESS_TYPE_EX:
+		kbase_mmu_report_fault_and_kill(kctx, faulting_as,
+				"Execute Permission fault");
+		break;
+	case AS_FAULTSTATUS_ACCESS_TYPE_READ:
+		kbase_mmu_report_fault_and_kill(kctx, faulting_as,
+				"Read Permission fault");
+		break;
+	default:
+		kbase_mmu_report_fault_and_kill(kctx, faulting_as,
+				"Unknown Permission fault");
+		break;
+	}
+}
+#endif
+
 void page_fault_worker(struct work_struct *data)
 {
 	u64 fault_pfn;
@@ -158,6 +354,17 @@ void page_fault_worker(struct work_struct *data)
 		break;
 
 	case AS_FAULTSTATUS_EXCEPTION_CODE_PERMISSION_FAULT:
+#ifdef CONFIG_MALI_JOB_DUMP
+		/* If GWT was ever enabled then we need to handle
+		 * write fault pages even if the feature was disabled later.
+		 */
+		if (kctx->gwt_was_enabled) {
+			kbase_gpu_mmu_handle_permission_fault(kctx,
+							faulting_as);
+			goto fault_done;
+		}
+#endif
+
 		kbase_mmu_report_fault_and_kill(kctx, faulting_as,
 				"Permission failure");
 		goto fault_done;
@@ -266,15 +473,10 @@ void page_fault_worker(struct work_struct *data)
 		goto fault_done;
 	}
 
-	new_pages = make_multiple(fault_rel_pfn -
-			kbase_reg_current_backed_size(region) + 1,
-			region->extent);
+	new_pages = reg_grow_calc_extra_pages(region, fault_rel_pfn);
 
 	/* cap to max vsize */
-	if (new_pages + kbase_reg_current_backed_size(region) >
-			region->nr_pages)
-		new_pages = region->nr_pages -
-				kbase_reg_current_backed_size(region);
+	new_pages = min(new_pages, region->nr_pages - kbase_reg_current_backed_size(region));
 
 	if (0 == new_pages) {
 		mutex_lock(&kbdev->mmu_hw_mutex);
@@ -377,6 +579,25 @@ void page_fault_worker(struct work_struct *data)
 		/* reenable this in the mask */
 		kbase_mmu_hw_enable_fault(kbdev, faulting_as, kctx,
 					 KBASE_MMU_FAULT_TYPE_PAGE);
+
+#ifdef CONFIG_MALI_JOB_DUMP
+		if (kctx->gwt_enabled) {
+			/* GWT also tracks growable regions. */
+			struct kbasep_gwt_list_element *pos;
+
+			pos = kmalloc(sizeof(*pos), GFP_KERNEL);
+			if (pos) {
+				pos->handle = region->start_pfn << PAGE_SHIFT;
+				pos->offset = pfn_offset;
+				pos->num_pages = new_pages;
+				list_add(&pos->link,
+					&kctx->gwt_current_list);
+
+			} else {
+				dev_warn(kbdev->dev, "kmalloc failure");
+			}
+		}
+#endif
 		kbase_gpu_vm_unlock(kctx);
 	} else {
 		/* failed to extend, handle as a normal PF */
@@ -838,9 +1059,16 @@ int kbase_mmu_insert_pages_no_flush(struct kbase_context *kctx,
 				u64 *target = &pgd_page[ofs];
 
 				/* Fail if the current page is a valid ATE entry
+				 * unless gwt_was_enabled as in that case all
+				 * pages will be valid from when
+				 * kbase_gpu_gwt_start() cleared the gpu
+				 * write flag.
 				 */
-				KBASE_DEBUG_ASSERT(0 == (*target & 1UL));
-
+#ifdef CONFIG_MALI_JOB_DUMP
+				if (!kctx->gwt_was_enabled)
+#endif
+					KBASE_DEBUG_ASSERT
+						(0 == (*target & 1UL));
 				kctx->kbdev->mmu_mode->entry_set_ate(target,
 						phys[i], flags, cur_level);
 			}
@@ -1202,13 +1430,12 @@ KBASE_EXPORT_TEST_API(kbase_mmu_teardown_pages);
  * already held by the caller. Refer to kbasep_js_runpool_release_ctx() for more
  * information.
  */
-int kbase_mmu_update_pages(struct kbase_context *kctx, u64 vpfn,
-			   struct tagged_addr *phys, size_t nr,
-			   unsigned long flags)
+int kbase_mmu_update_pages_no_flush(struct kbase_context *kctx, u64 vpfn,
+					struct tagged_addr *phys, size_t nr,
+					unsigned long flags)
 {
 	phys_addr_t pgd;
 	u64 *pgd_page;
-	size_t requested_nr = nr;
 	struct kbase_mmu_mode const *mmu_mode;
 	int err;
 
@@ -1224,9 +1451,6 @@ int kbase_mmu_update_pages(struct kbase_context *kctx, u64 vpfn,
 
 	mmu_mode = kctx->kbdev->mmu_mode;
 
-	dev_warn(kctx->kbdev->dev, "kbase_mmu_update_pages(): updating page share flags on GPU PFN 0x%llx from phys %p, %zu pages",
-			vpfn, phys, nr);
-
 	while (nr) {
 		unsigned int i;
 		unsigned int index = vpfn & 0x1FF;
@@ -1278,12 +1502,21 @@ int kbase_mmu_update_pages(struct kbase_context *kctx, u64 vpfn,
 	}
 
 	mutex_unlock(&kctx->mmu_lock);
-	kbase_mmu_flush_invalidate(kctx, vpfn, requested_nr, true);
 	return 0;
 
 fail_unlock:
 	mutex_unlock(&kctx->mmu_lock);
-	kbase_mmu_flush_invalidate(kctx, vpfn, requested_nr, true);
+	return err;
+}
+
+int kbase_mmu_update_pages(struct kbase_context *kctx, u64 vpfn,
+			   struct tagged_addr *phys, size_t nr,
+			   unsigned long flags)
+{
+	int err;
+
+	err = kbase_mmu_update_pages_no_flush(kctx, vpfn, phys, nr, flags);
+	kbase_mmu_flush_invalidate(kctx, vpfn, nr, true);
 	return err;
 }
 
@@ -2114,14 +2347,10 @@ void kbase_mmu_interrupt_process(struct kbase_device *kbdev, struct kbase_contex
 		 * We need to switch to UNMAPPED mode - but we do this in a
 		 * worker so that we can sleep
 		 */
-		KBASE_DEBUG_ASSERT(0 == object_is_on_stack(&as->work_busfault));
-		WARN_ON(work_pending(&as->work_busfault));
-		queue_work(as->pf_wq, &as->work_busfault);
+		WARN_ON(!queue_work(as->pf_wq, &as->work_busfault));
 		atomic_inc(&kbdev->faults_pending);
 	} else {
-		KBASE_DEBUG_ASSERT(0 == object_is_on_stack(&as->work_pagefault));
-		WARN_ON(work_pending(&as->work_pagefault));
-		queue_work(as->pf_wq, &as->work_pagefault);
+		WARN_ON(!queue_work(as->pf_wq, &as->work_pagefault));
 		atomic_inc(&kbdev->faults_pending);
 	}
 }
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mmu_hw.h b/drivers/gpu/arm/bifrost/mali_kbase_mmu_hw.h
index 986e959e9a0c..92aa55dc2b35 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mmu_hw.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mmu_hw.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /**
  * @file
  * Interface file for accessing MMU hardware functionality
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mmu_mode_aarch64.c b/drivers/gpu/arm/bifrost/mali_kbase_mmu_mode_aarch64.c
index 0fb717b67af9..4bb2628c9251 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mmu_mode_aarch64.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mmu_mode_aarch64.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include "mali_kbase.h"
 #include "mali_midg_regmap.h"
 #include "mali_kbase_defs.h"
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_mmu_mode_lpae.c b/drivers/gpu/arm/bifrost/mali_kbase_mmu_mode_lpae.c
index f080fdc0be88..bc8da6348772 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_mmu_mode_lpae.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_mmu_mode_lpae.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include "mali_kbase.h"
 #include "mali_midg_regmap.h"
 #include "mali_kbase_defs.h"
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_platform_fake.c b/drivers/gpu/arm/bifrost/mali_kbase_platform_fake.c
index 0152b35f711b..fbb090e6c21f 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_platform_fake.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_platform_fake.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/errno.h>
 #include <linux/export.h>
 #include <linux/ioport.h>
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_pm.c b/drivers/gpu/arm/bifrost/mali_kbase_pm.c
index 97d543464c28..da56f0af2f86 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_pm.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_pm.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_pm.c
  * Base kernel power management APIs
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_pm.h b/drivers/gpu/arm/bifrost/mali_kbase_pm.h
index 37fa2479df74..8de17e1aca59 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_pm.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_pm.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_kbase_pm.h
  * Power management API definitions
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_profiling_gator_api.h b/drivers/gpu/arm/bifrost/mali_kbase_profiling_gator_api.h
index 7fb674eded37..15bca79fd64d 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_profiling_gator_api.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_profiling_gator_api.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /**
  * @file mali_kbase_profiling_gator_api.h
  * Model interface
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_regs_history_debugfs.c b/drivers/gpu/arm/bifrost/mali_kbase_regs_history_debugfs.c
index 9e73f9f4999e..4bcb7bdb3da2 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_regs_history_debugfs.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_regs_history_debugfs.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include "mali_kbase.h"
 
 #include "mali_kbase_regs_history_debugfs.h"
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_regs_history_debugfs.h b/drivers/gpu/arm/bifrost/mali_kbase_regs_history_debugfs.h
index fbb36b3f22e4..8cc11010a92b 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_regs_history_debugfs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_regs_history_debugfs.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /**
  * Header file for register access history support via debugfs
  *
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_replay.c b/drivers/gpu/arm/bifrost/mali_kbase_replay.c
index 9f4dc372770d..ddef76c30f82 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_replay.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_replay.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /**
  * @file mali_kbase_replay.c
  * Replay soft job handlers
@@ -772,22 +777,6 @@ static int kbasep_replay_parse_payload(struct kbase_context *kctx,
 		return -EINVAL;
 	}
 
-#ifdef BASE_LEGACY_UK10_2_SUPPORT
-	if (KBASE_API_VERSION(10, 3) > replay_atom->kctx->api_version) {
-		base_jd_replay_payload_uk10_2 *payload_uk10_2;
-		u16 tiler_core_req;
-		u16 fragment_core_req;
-
-		payload_uk10_2 = (base_jd_replay_payload_uk10_2 *) payload;
-		memcpy(&tiler_core_req, &payload_uk10_2->tiler_core_req,
-				sizeof(tiler_core_req));
-		memcpy(&fragment_core_req, &payload_uk10_2->fragment_core_req,
-				sizeof(fragment_core_req));
-		payload->tiler_core_req = (u32)(tiler_core_req & 0x7fff);
-		payload->fragment_core_req = (u32)(fragment_core_req & 0x7fff);
-	}
-#endif /* BASE_LEGACY_UK10_2_SUPPORT */
-
 #ifdef CONFIG_MALI_BIFROST_DEBUG
 	dev_dbg(kctx->kbdev->dev, "kbasep_replay_parse_payload: payload=%p\n", payload);
 	dev_dbg(kctx->kbdev->dev, "Payload structure:\n"
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_smc.c b/drivers/gpu/arm/bifrost/mali_kbase_smc.c
index 43175c85988f..2176479959a5 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_smc.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_smc.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifdef CONFIG_ARM64
 
 #include <mali_kbase.h>
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_smc.h b/drivers/gpu/arm/bifrost/mali_kbase_smc.h
index 9bff3d2e8b4d..221eb21a8c7f 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_smc.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_smc.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #ifndef _KBASE_SMC_H_
 #define _KBASE_SMC_H_
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_softjobs.c b/drivers/gpu/arm/bifrost/mali_kbase_softjobs.c
index cafc789ea253..0c20f66f0137 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_softjobs.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_softjobs.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include <mali_kbase.h>
 
 #if defined(CONFIG_DMA_SHARED_BUFFER)
@@ -521,8 +526,7 @@ static inline void free_user_buffer(struct kbase_debug_copy_buffer *buffer)
 
 static void kbase_debug_copy_finish(struct kbase_jd_atom *katom)
 {
-	struct kbase_debug_copy_buffer *buffers =
-			(struct kbase_debug_copy_buffer *)(uintptr_t)katom->jc;
+	struct kbase_debug_copy_buffer *buffers = katom->softjob_data;
 	unsigned int i;
 	unsigned int nr = katom->nr_extres;
 
@@ -560,7 +564,7 @@ static void kbase_debug_copy_finish(struct kbase_jd_atom *katom)
 	kbase_gpu_vm_unlock(katom->kctx);
 	kfree(buffers);
 
-	katom->jc = 0;
+	katom->softjob_data = NULL;
 }
 
 static int kbase_debug_copy_prepare(struct kbase_jd_atom *katom)
@@ -578,10 +582,9 @@ static int kbase_debug_copy_prepare(struct kbase_jd_atom *katom)
 	buffers = kcalloc(nr, sizeof(*buffers), GFP_KERNEL);
 	if (!buffers) {
 		ret = -ENOMEM;
-		katom->jc = 0;
 		goto out_cleanup;
 	}
-	katom->jc = (u64)(uintptr_t)buffers;
+	katom->softjob_data = buffers;
 
 	user_buffers = kmalloc_array(nr, sizeof(*user_buffers), GFP_KERNEL);
 
@@ -853,10 +856,12 @@ static int kbase_mem_copy_from_extres(struct kbase_context *kctx,
 
 static int kbase_debug_copy(struct kbase_jd_atom *katom)
 {
-	struct kbase_debug_copy_buffer *buffers =
-			(struct kbase_debug_copy_buffer *)(uintptr_t)katom->jc;
+	struct kbase_debug_copy_buffer *buffers = katom->softjob_data;
 	unsigned int i;
 
+	if (WARN_ON(!buffers))
+		return -EINVAL;
+
 	for (i = 0; i < katom->nr_extres; i++) {
 		int res = kbase_mem_copy_from_extres(katom->kctx, &buffers[i]);
 
@@ -910,8 +915,7 @@ static int kbase_jit_allocate_prepare(struct kbase_jd_atom *katom)
 		goto free_info;
 	}
 
-	/* Replace the user pointer with our kernel allocated info structure */
-	katom->jc = (u64)(uintptr_t) info;
+	katom->softjob_data = info;
 	katom->jit_blocked = false;
 
 	lockdep_assert_held(&kctx->jctx.lock);
@@ -933,7 +937,6 @@ static int kbase_jit_allocate_prepare(struct kbase_jd_atom *katom)
 free_info:
 	kfree(info);
 fail:
-	katom->jc = 0;
 	return ret;
 }
 
@@ -958,7 +961,12 @@ static int kbase_jit_allocate_process(struct kbase_jd_atom *katom)
 		katom->jit_blocked = false;
 	}
 
-	info = (struct base_jit_alloc_info *) (uintptr_t) katom->jc;
+	info = katom->softjob_data;
+
+	if (WARN_ON(!info)) {
+		katom->event_code = BASE_JD_EVENT_JOB_INVALID;
+		return 0;
+	}
 
 	/* The JIT ID is still in use so fail the allocation */
 	if (kctx->jit_alloc[info->id]) {
@@ -1061,7 +1069,7 @@ static void kbase_jit_allocate_finish(struct kbase_jd_atom *katom)
 		katom->jit_blocked = false;
 	}
 
-	info = (struct base_jit_alloc_info *) (uintptr_t) katom->jc;
+	info = katom->softjob_data;
 	/* Free the info structure */
 	kfree(info);
 }
@@ -1184,11 +1192,7 @@ static int kbase_ext_res_prepare(struct kbase_jd_atom *katom)
 	 */
 	ext_res->count = count;
 
-	/*
-	 * Replace the user pointer with our kernel allocated
-	 * ext_res structure.
-	 */
-	katom->jc = (u64)(uintptr_t) ext_res;
+	katom->softjob_data = ext_res;
 
 	return 0;
 
@@ -1204,7 +1208,7 @@ static void kbase_ext_res_process(struct kbase_jd_atom *katom, bool map)
 	int i;
 	bool failed = false;
 
-	ext_res = (struct base_external_resource_list *) (uintptr_t) katom->jc;
+	ext_res = katom->softjob_data;
 	if (!ext_res)
 		goto failed_jc;
 
@@ -1240,13 +1244,13 @@ static void kbase_ext_res_process(struct kbase_jd_atom *katom, bool map)
 	return;
 
 failed_loop:
-	while (--i > 0) {
-		u64 gpu_addr;
-
-		gpu_addr = ext_res->ext_res[i].ext_resource &
+	while (i > 0) {
+		u64 const gpu_addr = ext_res->ext_res[i - 1].ext_resource &
 				~BASE_EXT_RES_ACCESS_EXCLUSIVE;
 
 		kbase_sticky_resource_release(katom->kctx, NULL, gpu_addr);
+
+		--i;
 	}
 
 	katom->event_code = BASE_JD_EVENT_JOB_INVALID;
@@ -1260,7 +1264,7 @@ static void kbase_ext_res_finish(struct kbase_jd_atom *katom)
 {
 	struct base_external_resource_list *ext_res;
 
-	ext_res = (struct base_external_resource_list *) (uintptr_t) katom->jc;
+	ext_res = katom->softjob_data;
 	/* Free the info structure */
 	kfree(ext_res);
 }
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_strings.c b/drivers/gpu/arm/bifrost/mali_kbase_strings.c
index c98762cec244..22caa4a6d814 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_strings.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_strings.c
@@ -7,13 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
-
-
 #include "mali_kbase_strings.h"
 
 #define KBASE_DRV_NAME "mali"
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_strings.h b/drivers/gpu/arm/bifrost/mali_kbase_strings.h
index 41b8fdbec6a4..d2f1825314fe 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_strings.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_strings.h
@@ -7,13 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 extern const char kbase_drv_name[];
 extern const char kbase_timeline_name[];
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_sync.h b/drivers/gpu/arm/bifrost/mali_kbase_sync.h
index ca855b8d1b53..550e0232856a 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_sync.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_sync.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /**
  * @file mali_kbase_sync.h
  *
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_sync_android.c b/drivers/gpu/arm/bifrost/mali_kbase_sync_android.c
index e4528e2b9f25..41f740a7bc8c 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_sync_android.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_sync_android.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Code for supporting explicit Android fences (CONFIG_SYNC)
  * Known to be good for kernels 4.5 and earlier.
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_sync_common.c b/drivers/gpu/arm/bifrost/mali_kbase_sync_common.c
index 457def296684..9520f5ac3b5e 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_sync_common.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_sync_common.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * @file mali_kbase_sync_common.c
  *
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_sync_file.c b/drivers/gpu/arm/bifrost/mali_kbase_sync_file.c
index 509c0666f10f..0fcb5078d782 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_sync_file.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_sync_file.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /*
  * Code for supporting explicit Linux fences (CONFIG_SYNC_FILE)
  * Introduced in kernel 4.9.
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_tlstream.c b/drivers/gpu/arm/bifrost/mali_kbase_tlstream.c
index d01aa23b206e..926d6b631469 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_tlstream.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_tlstream.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/anon_inodes.h>
 #include <linux/atomic.h>
 #include <linux/file.h>
@@ -144,7 +149,7 @@ enum tl_msg_id_obj {
 	KBASE_TL_ATTRIB_ATOM_CONFIG,
 	KBASE_TL_ATTRIB_ATOM_PRIORITY,
 	KBASE_TL_ATTRIB_ATOM_STATE,
-	KBASE_TL_ATTRIB_ATOM_PRIORITY_CHANGE,
+	KBASE_TL_ATTRIB_ATOM_PRIORITIZED,
 	KBASE_TL_ATTRIB_ATOM_JIT,
 	KBASE_TL_ATTRIB_AS_CONFIG,
 	KBASE_TL_EVENT_LPU_SOFTSTOP,
@@ -453,8 +458,8 @@ static const struct tp_desc tp_desc_obj[] = {
 		"atom,state"
 	},
 	{
-		KBASE_TL_ATTRIB_ATOM_PRIORITY_CHANGE,
-		__stringify(KBASE_TL_ATTRIB_ATOM_PRIORITY_CHANGE),
+		KBASE_TL_ATTRIB_ATOM_PRIORITIZED,
+		__stringify(KBASE_TL_ATTRIB_ATOM_PRIORITIZED),
 		"atom caused priority change",
 		"@p",
 		"atom"
@@ -2208,9 +2213,9 @@ void __kbase_tlstream_tl_attrib_atom_state(void *atom, u32 state)
 	kbasep_tlstream_msgbuf_release(TL_STREAM_TYPE_OBJ, flags);
 }
 
-void __kbase_tlstream_tl_attrib_atom_priority_change(void *atom)
+void __kbase_tlstream_tl_attrib_atom_prioritized(void *atom)
 {
-	const u32     msg_id = KBASE_TL_ATTRIB_ATOM_PRIORITY_CHANGE;
+	const u32     msg_id = KBASE_TL_ATTRIB_ATOM_PRIORITIZED;
 	const size_t  msg_size =
 		sizeof(msg_id) + sizeof(u64) + sizeof(atom);
 	unsigned long flags;
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_tlstream.h b/drivers/gpu/arm/bifrost/mali_kbase_tlstream.h
index c0a1117d5f25..f4369014d219 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_tlstream.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_tlstream.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #if !defined(_KBASE_TLSTREAM_H)
 #define _KBASE_TLSTREAM_H
 
@@ -134,7 +139,7 @@ void __kbase_tlstream_tl_attrib_atom_config(
 		void *atom, u64 jd, u64 affinity, u32 config);
 void __kbase_tlstream_tl_attrib_atom_priority(void *atom, u32 prio);
 void __kbase_tlstream_tl_attrib_atom_state(void *atom, u32 state);
-void __kbase_tlstream_tl_attrib_atom_priority_change(void *atom);
+void __kbase_tlstream_tl_attrib_atom_prioritized(void *atom);
 void __kbase_tlstream_tl_attrib_atom_jit(
 		void *atom, u64 edit_addr, u64 new_addr);
 void __kbase_tlstream_tl_attrib_as_config(
@@ -480,13 +485,13 @@ extern atomic_t kbase_tlstream_enabled;
 	__TRACE_IF_ENABLED_LATENCY(tl_attrib_atom_state, atom, state)
 
 /**
- * KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITY_CHANGE - atom caused priority change
+ * KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITIZED - atom was prioritized
  * @atom:  name of the atom object
  *
  * Function emits a timeline message signalling priority change
  */
-#define KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITY_CHANGE(atom) \
-	__TRACE_IF_ENABLED_LATENCY(tl_attrib_atom_priority_change, atom)
+#define KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITIZED(atom) \
+	__TRACE_IF_ENABLED_LATENCY(tl_attrib_atom_prioritized, atom)
 
 /**
  * KBASE_TLSTREAM_TL_ATTRIB_ATOM_JIT - jit happened on atom
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_trace_defs.h b/drivers/gpu/arm/bifrost/mali_kbase_trace_defs.h
index e2e0544208ce..32fffe0d80a9 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_trace_defs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_trace_defs.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /* ***** IMPORTANT: THIS IS NOT A NORMAL HEADER FILE         *****
  * *****            DO NOT INCLUDE DIRECTLY                  *****
  * *****            THE LACK OF HEADER GUARDS IS INTENTIONAL ***** */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline.c b/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline.c
index d9854749f45b..d6b6f5c31d5c 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include <mali_kbase.h>
 #include <mali_kbase_jm.h>
 #include <mali_kbase_hwaccess_jm.h>
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline.h b/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline.h
index 4b517f396f8c..306da6d3cb80 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #if !defined(_KBASE_TRACE_TIMELINE_H)
 #define _KBASE_TRACE_TIMELINE_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline_defs.h b/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline_defs.h
index 156a95a67f4a..114bcac541e9 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline_defs.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_trace_timeline_defs.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /* ***** IMPORTANT: THIS IS NOT A NORMAL HEADER FILE         *****
  * *****            DO NOT INCLUDE DIRECTLY                  *****
  * *****            THE LACK OF HEADER GUARDS IS INTENTIONAL ***** */
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_uku.h b/drivers/gpu/arm/bifrost/mali_kbase_uku.h
deleted file mode 100644
index cf8ee0572dc5..000000000000
--- a/drivers/gpu/arm/bifrost/mali_kbase_uku.h
+++ /dev/null
@@ -1,532 +0,0 @@
-/*
- *
- * (C) COPYRIGHT 2008-2017 ARM Limited. All rights reserved.
- *
- * This program is free software and is provided to you under the terms of the
- * GNU General Public License version 2 as published by the Free Software
- * Foundation, and any use by you of this program is subject to the terms
- * of such GNU licence.
- *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
- *
- */
-
-
-
-
-
-#ifndef _KBASE_UKU_H_
-#define _KBASE_UKU_H_
-
-#include "mali_uk.h"
-#include "mali_base_kernel.h"
-
-/* This file needs to support being included from kernel and userside (which use different defines) */
-#if defined(CONFIG_MALI_BIFROST_ERROR_INJECT) || MALI_ERROR_INJECT_ON
-#define SUPPORT_MALI_ERROR_INJECT
-#endif /* defined(CONFIG_MALI_BIFROST_ERROR_INJECT) || MALI_ERROR_INJECT_ON */
-#if defined(CONFIG_MALI_BIFROST_NO_MALI)
-#define SUPPORT_MALI_NO_MALI
-#elif defined(MALI_BIFROST_NO_MALI)
-#if MALI_BIFROST_NO_MALI
-#define SUPPORT_MALI_NO_MALI
-#endif
-#endif
-
-#if defined(SUPPORT_MALI_NO_MALI) || defined(SUPPORT_MALI_ERROR_INJECT)
-#include "backend/gpu/mali_kbase_model_dummy.h"
-#endif
-
-#include "mali_kbase_gpuprops_types.h"
-
-/*
- * 10.1:
- * - Do mmap in kernel for SAME_VA memory allocations rather then
- *   calling back into the kernel as a 2nd stage of the allocation request.
- *
- * 10.2:
- * - Add KBASE_FUNC_MEM_JIT_INIT which allows clients to request a custom VA
- *   region for use with JIT (ignored on 32-bit platforms)
- *
- * 10.3:
- * - base_jd_core_req typedef-ed to u32 (instead of to u16)
- * - two flags added: BASE_JD_REQ_SKIP_CACHE_STAT / _END
- *
- * 10.4:
- * - Removed KBASE_FUNC_EXT_BUFFER_LOCK used only in internal tests
- *
- * 10.5:
- * - Reverted to performing mmap in user space so that tools like valgrind work.
- *
- * 10.6:
- * - Add flags input variable to KBASE_FUNC_TLSTREAM_ACQUIRE
- */
-#define BASE_UK_VERSION_MAJOR 10
-#define BASE_UK_VERSION_MINOR 6
-
-#define LINUX_UK_BASE_MAGIC 0x80
-
-struct kbase_uk_mem_alloc {
-	union uk_header header;
-	/* IN */
-	u64 va_pages;
-	u64 commit_pages;
-	u64 extent;
-	/* IN/OUT */
-	u64 flags;
-	/* OUT */
-	u64 gpu_va;
-	u16 va_alignment;
-	u8  padding[6];
-};
-
-struct kbase_uk_mem_free {
-	union uk_header header;
-	/* IN */
-	u64 gpu_addr;
-	/* OUT */
-};
-
-struct kbase_uk_mem_alias {
-	union uk_header header;
-	/* IN/OUT */
-	u64 flags;
-	/* IN */
-	u64 stride;
-	u64 nents;
-	u64 ai;
-	/* OUT */
-	u64         gpu_va;
-	u64         va_pages;
-};
-
-struct kbase_uk_mem_import {
-	union uk_header header;
-	/* IN */
-	u64 phandle;
-	u32 type;
-	u32 padding;
-	/* IN/OUT */
-	u64         flags;
-	/* OUT */
-	u64 gpu_va;
-	u64         va_pages;
-};
-
-struct kbase_uk_mem_flags_change {
-	union uk_header header;
-	/* IN */
-	u64 gpu_va;
-	u64 flags;
-	u64 mask;
-};
-
-struct kbase_uk_job_submit {
-	union uk_header header;
-	/* IN */
-	u64 addr;
-	u32 nr_atoms;
-	u32 stride;		/* bytes between atoms, i.e. sizeof(base_jd_atom_v2) */
-	/* OUT */
-};
-
-struct kbase_uk_post_term {
-	union uk_header header;
-};
-
-struct kbase_uk_sync_now {
-	union uk_header header;
-
-	/* IN */
-	struct base_syncset sset;
-
-	/* OUT */
-};
-
-struct kbase_uk_hwcnt_setup {
-	union uk_header header;
-
-	/* IN */
-	u64 dump_buffer;
-	u32 jm_bm;
-	u32 shader_bm;
-	u32 tiler_bm;
-	u32 unused_1; /* keep for backwards compatibility */
-	u32 mmu_l2_bm;
-	u32 padding;
-	/* OUT */
-};
-
-/**
- * struct kbase_uk_hwcnt_reader_setup - User/Kernel space data exchange structure
- * @header:       UK structure header
- * @buffer_count: requested number of dumping buffers
- * @jm_bm:        counters selection bitmask (JM)
- * @shader_bm:    counters selection bitmask (Shader)
- * @tiler_bm:     counters selection bitmask (Tiler)
- * @mmu_l2_bm:    counters selection bitmask (MMU_L2)
- * @fd:           dumping notification file descriptor
- *
- * This structure sets up HWC dumper/reader for this context.
- * Multiple instances can be created for single context.
- */
-struct kbase_uk_hwcnt_reader_setup {
-	union uk_header header;
-
-	/* IN */
-	u32 buffer_count;
-	u32 jm_bm;
-	u32 shader_bm;
-	u32 tiler_bm;
-	u32 mmu_l2_bm;
-
-	/* OUT */
-	s32 fd;
-};
-
-struct kbase_uk_hwcnt_dump {
-	union uk_header header;
-};
-
-struct kbase_uk_hwcnt_clear {
-	union uk_header header;
-};
-
-struct kbase_uk_fence_validate {
-	union uk_header header;
-	/* IN */
-	s32 fd;
-	u32 padding;
-	/* OUT */
-};
-
-struct kbase_uk_stream_create {
-	union uk_header header;
-	/* IN */
-	char name[32];
-	/* OUT */
-	s32 fd;
-	u32 padding;
-};
-
-struct kbase_uk_gpuprops {
-	union uk_header header;
-
-	/* IN */
-	struct mali_base_gpu_props props;
-	/* OUT */
-};
-
-struct kbase_uk_mem_query {
-	union uk_header header;
-	/* IN */
-	u64 gpu_addr;
-#define KBASE_MEM_QUERY_COMMIT_SIZE  1
-#define KBASE_MEM_QUERY_VA_SIZE      2
-#define KBASE_MEM_QUERY_FLAGS        3
-	u64         query;
-	/* OUT */
-	u64         value;
-};
-
-struct kbase_uk_mem_commit {
-	union uk_header header;
-	/* IN */
-	u64 gpu_addr;
-	u64         pages;
-	/* OUT */
-	u32 result_subcode;
-	u32 padding;
-};
-
-struct kbase_uk_find_cpu_offset {
-	union uk_header header;
-	/* IN */
-	u64 gpu_addr;
-	u64 cpu_addr;
-	u64 size;
-	/* OUT */
-	u64 offset;
-};
-
-#define KBASE_GET_VERSION_BUFFER_SIZE 64
-struct kbase_uk_get_ddk_version {
-	union uk_header header;
-	/* OUT */
-	char version_buffer[KBASE_GET_VERSION_BUFFER_SIZE];
-	u32 version_string_size;
-	u32 padding;
-};
-
-struct kbase_uk_disjoint_query {
-	union uk_header header;
-	/* OUT */
-	u32 counter;
-	u32 padding;
-};
-
-struct kbase_uk_set_flags {
-	union uk_header header;
-	/* IN */
-	u32 create_flags;
-	u32 padding;
-};
-
-#if MALI_UNIT_TEST
-#define TEST_ADDR_COUNT 4
-#define KBASE_TEST_BUFFER_SIZE 128
-struct kbase_exported_test_data {
-	u64 test_addr[TEST_ADDR_COUNT];		/**< memory address */
-	u32 test_addr_pages[TEST_ADDR_COUNT];		/**<  memory size in pages */
-	u64 kctx;				/**<  base context created by process */
-	u64 mm;				/**< pointer to process address space */
-	u8 buffer1[KBASE_TEST_BUFFER_SIZE];   /**<  unit test defined parameter */
-	u8 buffer2[KBASE_TEST_BUFFER_SIZE];   /**<  unit test defined parameter */
-};
-
-struct kbase_uk_set_test_data {
-	union uk_header header;
-	/* IN */
-	struct kbase_exported_test_data test_data;
-};
-
-#endif				/* MALI_UNIT_TEST */
-
-#ifdef SUPPORT_MALI_ERROR_INJECT
-struct kbase_uk_error_params {
-	union uk_header header;
-	/* IN */
-	struct kbase_error_params params;
-};
-#endif				/* SUPPORT_MALI_ERROR_INJECT */
-
-#ifdef SUPPORT_MALI_NO_MALI
-struct kbase_uk_model_control_params {
-	union uk_header header;
-	/* IN */
-	struct kbase_model_control_params params;
-};
-#endif				/* SUPPORT_MALI_NO_MALI */
-
-struct kbase_uk_profiling_controls {
-	union uk_header header;
-	u32 profiling_controls[FBDUMP_CONTROL_MAX];
-};
-
-struct kbase_uk_debugfs_mem_profile_add {
-	union uk_header header;
-	u32 len;
-	u32 padding;
-	u64 buf;
-};
-
-struct kbase_uk_context_id {
-	union uk_header header;
-	/* OUT */
-	int id;
-};
-
-/**
- * struct kbase_uk_tlstream_acquire - User/Kernel space data exchange structure
- * @header: UK structure header
- * @flags:  timeline stream flags
- * @fd:     timeline stream file descriptor
- *
- * This structure is used when performing a call to acquire kernel side timeline
- * stream file descriptor.
- */
-struct kbase_uk_tlstream_acquire {
-	union uk_header header;
-	/* IN */
-	u32 flags;
-	/* OUT */
-	s32  fd;
-};
-
-/**
- * struct kbase_uk_tlstream_acquire_v10_4 - User/Kernel space data exchange
- *                                          structure
- * @header: UK structure header
- * @fd:     timeline stream file descriptor
- *
- * This structure is used when performing a call to acquire kernel side timeline
- * stream file descriptor.
- */
-struct kbase_uk_tlstream_acquire_v10_4 {
-	union uk_header header;
-	/* IN */
-	/* OUT */
-	s32  fd;
-};
-
-/**
- * struct kbase_uk_tlstream_flush - User/Kernel space data exchange structure
- * @header: UK structure header
- *
- * This structure is used when performing a call to flush kernel side
- * timeline streams.
- */
-struct kbase_uk_tlstream_flush {
-	union uk_header header;
-	/* IN */
-	/* OUT */
-};
-
-#if MALI_UNIT_TEST
-/**
- * struct kbase_uk_tlstream_test - User/Kernel space data exchange structure
- * @header:    UK structure header
- * @tpw_count: number of trace point writers in each context
- * @msg_delay: time delay between tracepoints from one writer in milliseconds
- * @msg_count: number of trace points written by one writer
- * @aux_msg:   if non-zero aux messages will be included
- *
- * This structure is used when performing a call to start timeline stream test
- * embedded in kernel.
- */
-struct kbase_uk_tlstream_test {
-	union uk_header header;
-	/* IN */
-	u32 tpw_count;
-	u32 msg_delay;
-	u32 msg_count;
-	u32 aux_msg;
-	/* OUT */
-};
-
-/**
- * struct kbase_uk_tlstream_stats - User/Kernel space data exchange structure
- * @header:          UK structure header
- * @bytes_collected: number of bytes read by user
- * @bytes_generated: number of bytes generated by tracepoints
- *
- * This structure is used when performing a call to obtain timeline stream
- * statistics.
- */
-struct kbase_uk_tlstream_stats {
-	union uk_header header; /**< UK structure header. */
-	/* IN */
-	/* OUT */
-	u32 bytes_collected;
-	u32 bytes_generated;
-};
-#endif /* MALI_UNIT_TEST */
-
-/**
- * struct struct kbase_uk_prfcnt_value for the KBASE_FUNC_SET_PRFCNT_VALUES ioctl
- * @header:          UK structure header
- * @data:            Counter samples for the dummy model
- * @size:............Size of the counter sample data
- */
-struct kbase_uk_prfcnt_values {
-	union uk_header header;
-	/* IN */
-	u32 *data;
-	u32 size;
-};
-
-/**
- * struct kbase_uk_soft_event_update - User/Kernel space data exchange structure
- * @header:     UK structure header
- * @evt:        the GPU address containing the event
- * @new_status: the new event status, must be either BASE_JD_SOFT_EVENT_SET or
- *              BASE_JD_SOFT_EVENT_RESET
- * @flags:      reserved for future uses, must be set to 0
- *
- * This structure is used to update the status of a software event. If the
- * event's status is set to BASE_JD_SOFT_EVENT_SET, any job currently waiting
- * on this event will complete.
- */
-struct kbase_uk_soft_event_update {
-	union uk_header header;
-	/* IN */
-	u64 evt;
-	u32 new_status;
-	u32 flags;
-};
-
-/**
- * struct kbase_uk_mem_jit_init - User/Kernel space data exchange structure
- * @header:     UK structure header
- * @va_pages:   Number of virtual pages required for JIT
- *
- * This structure is used when requesting initialization of JIT.
- */
-struct kbase_uk_mem_jit_init {
-	union uk_header header;
-	/* IN */
-	u64 va_pages;
-};
-
-enum kbase_uk_function_id {
-	KBASE_FUNC_MEM_ALLOC = (UK_FUNC_ID + 0),
-	KBASE_FUNC_MEM_IMPORT = (UK_FUNC_ID + 1),
-	KBASE_FUNC_MEM_COMMIT = (UK_FUNC_ID + 2),
-	KBASE_FUNC_MEM_QUERY = (UK_FUNC_ID + 3),
-	KBASE_FUNC_MEM_FREE = (UK_FUNC_ID + 4),
-	KBASE_FUNC_MEM_FLAGS_CHANGE = (UK_FUNC_ID + 5),
-	KBASE_FUNC_MEM_ALIAS = (UK_FUNC_ID + 6),
-
-	/* UK_FUNC_ID + 7 not in use since BASE_LEGACY_UK6_SUPPORT dropped */
-
-	KBASE_FUNC_SYNC  = (UK_FUNC_ID + 8),
-
-	KBASE_FUNC_POST_TERM = (UK_FUNC_ID + 9),
-
-	KBASE_FUNC_HWCNT_SETUP = (UK_FUNC_ID + 10),
-	KBASE_FUNC_HWCNT_DUMP = (UK_FUNC_ID + 11),
-	KBASE_FUNC_HWCNT_CLEAR = (UK_FUNC_ID + 12),
-
-	KBASE_FUNC_GPU_PROPS_REG_DUMP = (UK_FUNC_ID + 14),
-
-	KBASE_FUNC_FIND_CPU_OFFSET = (UK_FUNC_ID + 15),
-
-	KBASE_FUNC_GET_VERSION = (UK_FUNC_ID + 16),
-	KBASE_FUNC_SET_FLAGS = (UK_FUNC_ID + 18),
-
-	KBASE_FUNC_SET_TEST_DATA = (UK_FUNC_ID + 19),
-	KBASE_FUNC_INJECT_ERROR = (UK_FUNC_ID + 20),
-	KBASE_FUNC_MODEL_CONTROL = (UK_FUNC_ID + 21),
-
-	/* UK_FUNC_ID + 22 not in use since BASE_LEGACY_UK8_SUPPORT dropped */
-
-	KBASE_FUNC_FENCE_VALIDATE = (UK_FUNC_ID + 23),
-	KBASE_FUNC_STREAM_CREATE = (UK_FUNC_ID + 24),
-	KBASE_FUNC_GET_PROFILING_CONTROLS = (UK_FUNC_ID + 25),
-	KBASE_FUNC_SET_PROFILING_CONTROLS = (UK_FUNC_ID + 26),
-					    /* to be used only for testing
-					    * purposes, otherwise these controls
-					    * are set through gator API */
-
-	KBASE_FUNC_DEBUGFS_MEM_PROFILE_ADD = (UK_FUNC_ID + 27),
-	KBASE_FUNC_JOB_SUBMIT = (UK_FUNC_ID + 28),
-	KBASE_FUNC_DISJOINT_QUERY = (UK_FUNC_ID + 29),
-
-	KBASE_FUNC_GET_CONTEXT_ID = (UK_FUNC_ID + 31),
-
-	KBASE_FUNC_TLSTREAM_ACQUIRE_V10_4 = (UK_FUNC_ID + 32),
-#if MALI_UNIT_TEST
-	KBASE_FUNC_TLSTREAM_TEST = (UK_FUNC_ID + 33),
-	KBASE_FUNC_TLSTREAM_STATS = (UK_FUNC_ID + 34),
-#endif /* MALI_UNIT_TEST */
-	KBASE_FUNC_TLSTREAM_FLUSH = (UK_FUNC_ID + 35),
-
-	KBASE_FUNC_HWCNT_READER_SETUP = (UK_FUNC_ID + 36),
-
-#ifdef SUPPORT_MALI_NO_MALI
-	KBASE_FUNC_SET_PRFCNT_VALUES = (UK_FUNC_ID + 37),
-#endif
-
-	KBASE_FUNC_SOFT_EVENT_UPDATE = (UK_FUNC_ID + 38),
-
-	KBASE_FUNC_MEM_JIT_INIT = (UK_FUNC_ID + 39),
-
-	KBASE_FUNC_TLSTREAM_ACQUIRE = (UK_FUNC_ID + 40),
-
-	KBASE_FUNC_MAX
-};
-
-#endif				/* _KBASE_UKU_H_ */
-
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_utility.c b/drivers/gpu/arm/bifrost/mali_kbase_utility.c
index be474ff87401..3ea234aabeec 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_utility.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_utility.c
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include <mali_kbase.h>
 
 bool kbasep_list_member_of(const struct list_head *base, struct list_head *entry)
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_utility.h b/drivers/gpu/arm/bifrost/mali_kbase_utility.h
index fd7252dab0de..d36285e26a68 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_utility.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_utility.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #ifndef _KBASE_UTILITY_H
 #define _KBASE_UTILITY_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_vinstr.c b/drivers/gpu/arm/bifrost/mali_kbase_vinstr.c
index 9c5b2e46c0e5..e7d33da7bc77 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_vinstr.c
+++ b/drivers/gpu/arm/bifrost/mali_kbase_vinstr.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/anon_inodes.h>
 #include <linux/atomic.h>
 #include <linux/hrtimer.h>
@@ -33,6 +38,9 @@
 #include <mali_kbase_hwcnt_reader.h>
 #include <mali_kbase_mem_linux.h>
 #include <mali_kbase_tlstream.h>
+#ifdef CONFIG_MALI_BIFROST_NO_MALI
+#include <backend/gpu/mali_kbase_model_dummy.h>
+#endif
 
 /*****************************************************************************/
 
diff --git a/drivers/gpu/arm/bifrost/mali_kbase_vinstr.h b/drivers/gpu/arm/bifrost/mali_kbase_vinstr.h
index 6207d25aef06..af7c7b68aa26 100644
--- a/drivers/gpu/arm/bifrost/mali_kbase_vinstr.h
+++ b/drivers/gpu/arm/bifrost/mali_kbase_vinstr.h
@@ -1,24 +1,28 @@
 /*
  *
- * (C) COPYRIGHT 2015-2016 ARM Limited. All rights reserved.
+ * (C) COPYRIGHT 2015-2017 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the
  * GNU General Public License version 2 as published by the Free Software
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KBASE_VINSTR_H_
 #define _KBASE_VINSTR_H_
 
-#include <mali_kbase.h>
 #include <mali_kbase_hwcnt_reader.h>
 
 /*****************************************************************************/
@@ -26,6 +30,29 @@
 struct kbase_vinstr_context;
 struct kbase_vinstr_client;
 
+struct kbase_uk_hwcnt_setup {
+	/* IN */
+	u64 dump_buffer;
+	u32 jm_bm;
+	u32 shader_bm;
+	u32 tiler_bm;
+	u32 unused_1; /* keep for backwards compatibility */
+	u32 mmu_l2_bm;
+	u32 padding;
+	/* OUT */
+};
+
+struct kbase_uk_hwcnt_reader_setup {
+	/* IN */
+	u32 buffer_count;
+	u32 jm_bm;
+	u32 shader_bm;
+	u32 tiler_bm;
+	u32 mmu_l2_bm;
+
+	/* OUT */
+	s32 fd;
+};
 /*****************************************************************************/
 
 /**
diff --git a/drivers/gpu/arm/bifrost/mali_linux_kbase_trace.h b/drivers/gpu/arm/bifrost/mali_linux_kbase_trace.h
index 5d6b4021d626..da2ffaffccc7 100644
--- a/drivers/gpu/arm/bifrost/mali_linux_kbase_trace.h
+++ b/drivers/gpu/arm/bifrost/mali_linux_kbase_trace.h
@@ -7,15 +7,20 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
-
-
 #if !defined(_TRACE_MALI_KBASE_H) || defined(TRACE_HEADER_MULTI_READ)
 #define _TRACE_MALI_KBASE_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_linux_trace.h b/drivers/gpu/arm/bifrost/mali_linux_trace.h
index 2be06a552768..0741dfcab575 100644
--- a/drivers/gpu/arm/bifrost/mali_linux_trace.h
+++ b/drivers/gpu/arm/bifrost/mali_linux_trace.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #if !defined(_TRACE_MALI_H) || defined(TRACE_HEADER_MULTI_READ)
 #define _TRACE_MALI_H
 
diff --git a/drivers/gpu/arm/bifrost/mali_malisw.h b/drivers/gpu/arm/bifrost/mali_malisw.h
index 99452933eab4..f17bd5edf7e1 100644
--- a/drivers/gpu/arm/bifrost/mali_malisw.h
+++ b/drivers/gpu/arm/bifrost/mali_malisw.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /**
  * Kernel-wide include for common macros and types.
  */
diff --git a/drivers/gpu/arm/bifrost/mali_midg_coherency.h b/drivers/gpu/arm/bifrost/mali_midg_coherency.h
index a509cbd5f175..29d5df38c92b 100644
--- a/drivers/gpu/arm/bifrost/mali_midg_coherency.h
+++ b/drivers/gpu/arm/bifrost/mali_midg_coherency.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _MIDG_COHERENCY_H_
 #define _MIDG_COHERENCY_H_
 
diff --git a/drivers/gpu/arm/bifrost/mali_midg_regmap.h b/drivers/gpu/arm/bifrost/mali_midg_regmap.h
index 554ed8dcb3eb..5e83ee87242c 100644
--- a/drivers/gpu/arm/bifrost/mali_midg_regmap.h
+++ b/drivers/gpu/arm/bifrost/mali_midg_regmap.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _MIDGARD_REGMAP_H_
 #define _MIDGARD_REGMAP_H_
 
@@ -92,6 +97,7 @@
 #define TEXTURE_FEATURES_0      0x0B0	/* (RO) Support flags for indexed texture formats 0..31 */
 #define TEXTURE_FEATURES_1      0x0B4	/* (RO) Support flags for indexed texture formats 32..63 */
 #define TEXTURE_FEATURES_2      0x0B8	/* (RO) Support flags for indexed texture formats 64..95 */
+#define TEXTURE_FEATURES_3      0x0BC	/* (RO) Support flags for texture order */
 
 #define TEXTURE_FEATURES_REG(n) GPU_CONTROL_REG(TEXTURE_FEATURES_0 + ((n) << 2))
 
@@ -557,6 +563,13 @@
 #define L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES_OCTANT      (0x1 << L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES_SHIFT)
 #define L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES_QUARTER     (0x2 << L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES_SHIFT)
 #define L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES_HALF        (0x3 << L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES_SHIFT)
+
+#define L2_MMU_CONFIG_3BIT_LIMIT_EXTERNAL_READS_SHIFT      (12)
+#define L2_MMU_CONFIG_3BIT_LIMIT_EXTERNAL_READS            (0x7 << L2_MMU_CONFIG_LIMIT_EXTERNAL_READS_SHIFT)
+
+#define L2_MMU_CONFIG_3BIT_LIMIT_EXTERNAL_WRITES_SHIFT     (15)
+#define L2_MMU_CONFIG_3BIT_LIMIT_EXTERNAL_WRITES           (0x7 << L2_MMU_CONFIG_LIMIT_EXTERNAL_WRITES_SHIFT)
+
 /* End L2_MMU_CONFIG register */
 
 /* THREAD_* registers */
diff --git a/drivers/gpu/arm/bifrost/mali_timeline.h b/drivers/gpu/arm/bifrost/mali_timeline.h
index bd5f6614b6bb..d0deeadf479f 100644
--- a/drivers/gpu/arm/bifrost/mali_timeline.h
+++ b/drivers/gpu/arm/bifrost/mali_timeline.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #undef TRACE_SYSTEM
 #define TRACE_SYSTEM mali_timeline
 
diff --git a/drivers/gpu/arm/bifrost/mali_uk.h b/drivers/gpu/arm/bifrost/mali_uk.h
index 841d03fb5873..961a4a5c63eb 100644
--- a/drivers/gpu/arm/bifrost/mali_uk.h
+++ b/drivers/gpu/arm/bifrost/mali_uk.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_uk.h
  * Types and definitions that are common across OSs for both the user
diff --git a/drivers/gpu/arm/bifrost/platform/Kconfig b/drivers/gpu/arm/bifrost/platform/Kconfig
index 38835d3d1531..ef9fb963ecf5 100644
--- a/drivers/gpu/arm/bifrost/platform/Kconfig
+++ b/drivers/gpu/arm/bifrost/platform/Kconfig
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 
 
diff --git a/drivers/gpu/arm/bifrost/platform/devicetree/Kbuild b/drivers/gpu/arm/bifrost/platform/devicetree/Kbuild
index d40d7982ff04..ce637fbb5ef7 100644
--- a/drivers/gpu/arm/bifrost/platform/devicetree/Kbuild
+++ b/drivers/gpu/arm/bifrost/platform/devicetree/Kbuild
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 mali_kbase-y += \
 	$(MALI_PLATFORM_DIR)/mali_kbase_config_devicetree.o \
diff --git a/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_config_devicetree.c b/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_config_devicetree.c
index 29ccc29e4125..ccefddf882fd 100644
--- a/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_config_devicetree.c
+++ b/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_config_devicetree.c
@@ -7,22 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase_config.h>
 
-int kbase_platform_early_init(void)
-{
-	/* Nothing needed at this stage */
-	return 0;
-}
-
 static struct kbase_platform_config dummy_platform_config;
 
 struct kbase_platform_config *kbase_get_platform_config(void)
@@ -30,6 +29,7 @@ struct kbase_platform_config *kbase_get_platform_config(void)
 	return &dummy_platform_config;
 }
 
+#ifndef CONFIG_OF
 int kbase_platform_register(void)
 {
 	return 0;
@@ -38,3 +38,4 @@ int kbase_platform_register(void)
 void kbase_platform_unregister(void)
 {
 }
+#endif
diff --git a/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_config_platform.h b/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_config_platform.h
index 2ceca34945b9..5990313308fa 100644
--- a/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_config_platform.h
+++ b/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_config_platform.h
@@ -7,52 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
  *
- */
-
-
-
-/**
- * Maximum frequency GPU will be clocked at. Given in kHz.
- * This must be specified as there is no default value.
- *
- * Attached value: number in kHz
- * Default value: NA
- */
-#define GPU_FREQ_KHZ_MAX (5000)
-/**
- * Minimum frequency GPU will be clocked at. Given in kHz.
- * This must be specified as there is no default value.
- *
- * Attached value: number in kHz
- * Default value: NA
- */
-#define GPU_FREQ_KHZ_MIN (5000)
-
-/**
- * CPU_SPEED_FUNC - A pointer to a function that calculates the CPU clock
- *
- * CPU clock speed of the platform is in MHz - see kbase_cpu_clk_speed_func
- * for the function prototype.
- *
- * Attached value: A kbase_cpu_clk_speed_func.
- * Default Value:  NA
- */
-#define CPU_SPEED_FUNC (NULL)
-
-/**
- * GPU_SPEED_FUNC - A pointer to a function that calculates the GPU clock
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
  *
- * GPU clock speed of the platform in MHz - see kbase_gpu_clk_speed_func
- * for the function prototype.
+ * SPDX-License-Identifier: GPL-2.0
  *
- * Attached value: A kbase_gpu_clk_speed_func.
- * Default Value:  NA
  */
-#define GPU_SPEED_FUNC (NULL)
 
 /**
  * Power management configuration
diff --git a/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_runtime_pm.c b/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_runtime_pm.c
index 9fe37c8d835e..c5f3ad70f438 100644
--- a/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_runtime_pm.c
+++ b/drivers/gpu/arm/bifrost/platform/devicetree/mali_kbase_runtime_pm.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <mali_kbase.h>
 #include <mali_kbase_defs.h>
 #include <linux/pm_runtime.h>
@@ -50,7 +55,8 @@ static void pm_callback_power_off(struct kbase_device *kbdev)
 	pm_runtime_put_autosuspend(kbdev->dev);
 }
 
-int kbase_device_runtime_init(struct kbase_device *kbdev)
+#ifdef KBASE_PM_RUNTIME
+static int kbase_device_runtime_init(struct kbase_device *kbdev)
 {
 	int ret = 0;
 
@@ -70,11 +76,12 @@ int kbase_device_runtime_init(struct kbase_device *kbdev)
 	return ret;
 }
 
-void kbase_device_runtime_disable(struct kbase_device *kbdev)
+static void kbase_device_runtime_disable(struct kbase_device *kbdev)
 {
 	dev_dbg(kbdev->dev, "kbase_device_runtime_disable\n");
 	pm_runtime_disable(kbdev->dev);
 }
+#endif
 
 static int pm_callback_runtime_on(struct kbase_device *kbdev)
 {
diff --git a/drivers/gpu/arm/bifrost/platform/mali_kbase_platform_common.h b/drivers/gpu/arm/bifrost/platform/mali_kbase_platform_common.h
deleted file mode 100644
index 7cb3be7f78ce..000000000000
--- a/drivers/gpu/arm/bifrost/platform/mali_kbase_platform_common.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- *
- * (C) COPYRIGHT 2010-2013 ARM Limited. All rights reserved.
- *
- * This program is free software and is provided to you under the terms of the
- * GNU General Public License version 2 as published by the Free Software
- * Foundation, and any use by you of this program is subject to the terms
- * of such GNU licence.
- *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
- *
- */
-
-
-
-/**
- * @brief Entry point to transfer control to a platform for early initialization
- *
- * This function is called early on in the initialization during execution of
- * @ref kbase_driver_init.
- *
- * @return Zero to indicate success non-zero for failure.
- */
-int kbase_platform_early_init(void);
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress/Kbuild b/drivers/gpu/arm/bifrost/platform/vexpress/Kbuild
index d9d5e9085231..6780e4c9433b 100644
--- a/drivers/gpu/arm/bifrost/platform/vexpress/Kbuild
+++ b/drivers/gpu/arm/bifrost/platform/vexpress/Kbuild
@@ -6,14 +6,19 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 mali_kbase-y += \
 	$(MALI_PLATFORM_DIR)/mali_kbase_config_vexpress.o \
-	$(MALI_PLATFORM_DIR)/mali_kbase_cpu_vexpress.o \
 	mali_kbase_platform_fake.o
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_config_platform.h b/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_config_platform.h
index 02835f129aa3..fac3cd52182f 100644
--- a/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_config_platform.h
+++ b/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_config_platform.h
@@ -7,54 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
  *
- */
-
-
-
-#include "mali_kbase_cpu_vexpress.h"
-
-/**
- * Maximum frequency GPU will be clocked at. Given in kHz.
- * This must be specified as there is no default value.
- *
- * Attached value: number in kHz
- * Default value: NA
- */
-#define GPU_FREQ_KHZ_MAX kbase_get_platform_max_freq()
-/**
- * Minimum frequency GPU will be clocked at. Given in kHz.
- * This must be specified as there is no default value.
- *
- * Attached value: number in kHz
- * Default value: NA
- */
-#define GPU_FREQ_KHZ_MIN kbase_get_platform_min_freq()
-
-/**
- * CPU_SPEED_FUNC - A pointer to a function that calculates the CPU clock
- *
- * CPU clock speed of the platform is in MHz - see kbase_cpu_clk_speed_func
- * for the function prototype.
- *
- * Attached value: A kbase_cpu_clk_speed_func.
- * Default Value:  NA
- */
-#define CPU_SPEED_FUNC (&kbase_get_vexpress_cpu_clock_speed)
-
-/**
- * GPU_SPEED_FUNC - A pointer to a function that calculates the GPU clock
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
  *
- * GPU clock speed of the platform in MHz - see kbase_gpu_clk_speed_func
- * for the function prototype.
+ * SPDX-License-Identifier: GPL-2.0
  *
- * Attached value: A kbase_gpu_clk_speed_func.
- * Default Value:  NA
  */
-#define GPU_SPEED_FUNC (NULL)
 
 /**
  * Power management configuration
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_config_vexpress.c b/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_config_vexpress.c
index 15ce2bc5eea5..d165ce262814 100644
--- a/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_config_vexpress.c
+++ b/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_config_vexpress.c
@@ -1,31 +1,33 @@
 /*
  *
- * (C) COPYRIGHT 2011-2016 ARM Limited. All rights reserved.
+ * (C) COPYRIGHT 2011-2017 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the
  * GNU General Public License version 2 as published by the Free Software
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include <linux/ioport.h>
 #include <mali_kbase.h>
 #include <mali_kbase_defs.h>
 #include <mali_kbase_config.h>
-#include "mali_kbase_cpu_vexpress.h"
 #include "mali_kbase_config_platform.h"
 
-#define HARD_RESET_AT_POWER_OFF 0
-
 #ifndef CONFIG_OF
 static struct kbase_io_resources io_resources = {
 	.job_irq_number = 68,
@@ -46,17 +48,6 @@ static int pm_callback_power_on(struct kbase_device *kbdev)
 
 static void pm_callback_power_off(struct kbase_device *kbdev)
 {
-#if HARD_RESET_AT_POWER_OFF
-	/* Cause a GPU hard reset to test whether we have actually idled the GPU
-	 * and that we properly reconfigure the GPU on power up.
-	 * Usually this would be dangerous, but if the GPU is working correctly it should
-	 * be completely safe as the GPU should not be active at this point.
-	 * However this is disabled normally because it will most likely interfere with
-	 * bus logging etc.
-	 */
-	KBASE_TRACE_ADD(kbdev, CORE_GPU_HARD_RESET, NULL, NULL, 0u, 0);
-	kbase_os_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_HARD_RESET);
-#endif
 }
 
 struct kbase_pm_callback_conf pm_callbacks = {
@@ -76,10 +67,3 @@ struct kbase_platform_config *kbase_get_platform_config(void)
 {
 	return &versatile_platform_config;
 }
-
-
-int kbase_platform_early_init(void)
-{
-	/* Nothing needed at this stage */
-	return 0;
-}
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_cpu_vexpress.c b/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_cpu_vexpress.c
deleted file mode 100644
index 4665f98cbbe4..000000000000
--- a/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_cpu_vexpress.c
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- *
- * (C) COPYRIGHT 2011-2016 ARM Limited. All rights reserved.
- *
- * This program is free software and is provided to you under the terms of the
- * GNU General Public License version 2 as published by the Free Software
- * Foundation, and any use by you of this program is subject to the terms
- * of such GNU licence.
- *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
- *
- */
-
-
-
-#include <linux/io.h>
-#include <mali_kbase.h>
-#include "mali_kbase_cpu_vexpress.h"
-
-#define HZ_IN_MHZ (1000000)
-
-#define CORETILE_EXPRESS_A9X4_SCC_START	(0x100E2000)
-#define MOTHERBOARD_SYS_CFG_START	(0x10000000)
-#define SYS_CFGDATA_OFFSET		(0x000000A0)
-#define SYS_CFGCTRL_OFFSET		(0x000000A4)
-#define SYS_CFGSTAT_OFFSET		(0x000000A8)
-
-#define SYS_CFGCTRL_START_BIT_VALUE		(1 << 31)
-#define READ_REG_BIT_VALUE			(0 << 30)
-#define DCC_DEFAULT_BIT_VALUE			(0 << 26)
-#define SYS_CFG_OSC_FUNC_BIT_VALUE		(1 << 20)
-#define SITE_DEFAULT_BIT_VALUE			(1 << 16)
-#define BOARD_STACK_POS_DEFAULT_BIT_VALUE	(0 << 12)
-#define DEVICE_DEFAULT_BIT_VALUE		(2 <<  0)
-#define SYS_CFG_COMPLETE_BIT_VALUE		(1 <<  0)
-#define SYS_CFG_ERROR_BIT_VALUE			(1 <<  1)
-
-#define FEED_REG_BIT_MASK			(0x0F)
-#define FCLK_PA_DIVIDE_BIT_SHIFT		(0x03)
-#define FCLK_PB_DIVIDE_BIT_SHIFT		(0x07)
-#define FCLK_PC_DIVIDE_BIT_SHIFT		(0x0B)
-#define AXICLK_PA_DIVIDE_BIT_SHIFT		(0x0F)
-#define AXICLK_PB_DIVIDE_BIT_SHIFT		(0x13)
-
-/* the following three values used for reading
- * HBI value of the LogicTile daughterboard */
-#define VE_MOTHERBOARD_PERIPHERALS_SMB_CS7 (0x10000000)
-#define VE_SYS_PROC_ID1_OFFSET (0x00000088)
-#define VE_LOGIC_TILE_HBI_MASK (0x00000FFF)
-
-#define IS_SINGLE_BIT_SET(val, pos) (val&(1<<pos))
-
-/**
- * Values used for determining the GPU frequency based on the LogicTile type
- * Used by the function kbase_get_platform_logic_tile_type
- */
-#define VE_VIRTEX6_GPU_FREQ_MIN 5000
-#define VE_VIRTEX6_GPU_FREQ_MAX 5000
-#define VE_VIRTEX7_GPU_FREQ_MIN 40000
-#define VE_VIRTEX7_GPU_FREQ_MAX 40000
-#define VE_DEFAULT_GPU_FREQ_MIN 5000
-#define VE_DEFAULT_GPU_FREQ_MAX 5000
-
-
-#define CPU_CLOCK_SPEED_UNDEFINED (0)
-
-static u32 cpu_clock_speed = CPU_CLOCK_SPEED_UNDEFINED;
-
-static DEFINE_RAW_SPINLOCK(syscfg_lock);
-/**
- * kbase_get_vendor_specific_cpu_clock_speed -Retrieves the CPU clock speed
- * @cpu_clock - the value of CPU clock speed in MHz
- *
- * Returns 0 on success, error code otherwise.
- *
- * The implementation is platform specific.
-*/
-int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock)
-{
-	int err = 0;
-	u32 reg_val = 0;
-	u32 osc2_value = 0;
-	u32 pa_divide = 0;
-	u32 pb_divide = 0;
-	u32 pc_divide = 0;
-	void __iomem *syscfg_reg = NULL;
-	void __iomem *scc_reg = NULL;
-
-	if (CPU_CLOCK_SPEED_UNDEFINED != cpu_clock_speed) {
-		*cpu_clock = cpu_clock_speed;
-		return 0;
-	}
-
-	/* Init the value in case something goes wrong */
-	*cpu_clock = 0;
-
-	/* Map CPU register into virtual memory */
-	syscfg_reg = ioremap(MOTHERBOARD_SYS_CFG_START, 0x1000);
-	if (syscfg_reg == NULL) {
-		err = -EIO;
-		goto syscfg_reg_map_failed;
-	}
-
-	scc_reg = ioremap(CORETILE_EXPRESS_A9X4_SCC_START, 0x1000);
-	if (scc_reg == NULL) {
-		err = -EIO;
-		goto scc_reg_map_failed;
-	}
-
-	raw_spin_lock(&syscfg_lock);
-
-	/* Read SYS regs - OSC2 */
-	reg_val = readl(syscfg_reg + SYS_CFGCTRL_OFFSET);
-
-	/* Check if there is any other undergoing request */
-	if (reg_val & SYS_CFGCTRL_START_BIT_VALUE) {
-		err = -EBUSY;
-		goto ongoing_request;
-	}
-	/* Reset the CGFGSTAT reg */
-	writel(0, (syscfg_reg + SYS_CFGSTAT_OFFSET));
-
-	writel(SYS_CFGCTRL_START_BIT_VALUE | READ_REG_BIT_VALUE |
-			DCC_DEFAULT_BIT_VALUE |
-			SYS_CFG_OSC_FUNC_BIT_VALUE |
-			SITE_DEFAULT_BIT_VALUE |
-			BOARD_STACK_POS_DEFAULT_BIT_VALUE |
-			DEVICE_DEFAULT_BIT_VALUE,
-			(syscfg_reg + SYS_CFGCTRL_OFFSET));
-	/* Wait for the transaction to complete */
-	while (!(readl(syscfg_reg + SYS_CFGSTAT_OFFSET) &
-			SYS_CFG_COMPLETE_BIT_VALUE))
-		;
-	/* Read SYS_CFGSTAT Register to get the status of submitted
-	 * transaction */
-	reg_val = readl(syscfg_reg + SYS_CFGSTAT_OFFSET);
-
-	if (reg_val & SYS_CFG_ERROR_BIT_VALUE) {
-		/* Error while setting register */
-		err = -EIO;
-		goto set_reg_error;
-	}
-
-	osc2_value = readl(syscfg_reg + SYS_CFGDATA_OFFSET);
-	/* Read the SCC CFGRW0 register */
-	reg_val = readl(scc_reg);
-
-	/*
-	 * Select the appropriate feed:
-	 * CFGRW0[0] - CLKOB
-	 * CFGRW0[1] - CLKOC
-	 * CFGRW0[2] - FACLK (CLK)B FROM AXICLK PLL)
-	 */
-	/* Calculate the  FCLK */
-	if (IS_SINGLE_BIT_SET(reg_val, 0)) {
-		/* CFGRW0[0] - CLKOB */
-		/* CFGRW0[6:3] */
-		pa_divide = ((reg_val & (FEED_REG_BIT_MASK <<
-				FCLK_PA_DIVIDE_BIT_SHIFT)) >>
-				FCLK_PA_DIVIDE_BIT_SHIFT);
-		/* CFGRW0[10:7] */
-		pb_divide = ((reg_val & (FEED_REG_BIT_MASK <<
-				FCLK_PB_DIVIDE_BIT_SHIFT)) >>
-				FCLK_PB_DIVIDE_BIT_SHIFT);
-		*cpu_clock = osc2_value * (pa_divide + 1) / (pb_divide + 1);
-	} else if (IS_SINGLE_BIT_SET(reg_val, 1)) {
-		/* CFGRW0[1] - CLKOC */
-		/* CFGRW0[6:3] */
-		pa_divide = ((reg_val & (FEED_REG_BIT_MASK <<
-				FCLK_PA_DIVIDE_BIT_SHIFT)) >>
-				FCLK_PA_DIVIDE_BIT_SHIFT);
-		/* CFGRW0[14:11] */
-		pc_divide = ((reg_val & (FEED_REG_BIT_MASK <<
-				FCLK_PC_DIVIDE_BIT_SHIFT)) >>
-				FCLK_PC_DIVIDE_BIT_SHIFT);
-		*cpu_clock = osc2_value * (pa_divide + 1) / (pc_divide + 1);
-	} else if (IS_SINGLE_BIT_SET(reg_val, 2)) {
-		/* CFGRW0[2] - FACLK */
-		/* CFGRW0[18:15] */
-		pa_divide = ((reg_val & (FEED_REG_BIT_MASK <<
-				AXICLK_PA_DIVIDE_BIT_SHIFT)) >>
-				AXICLK_PA_DIVIDE_BIT_SHIFT);
-		/* CFGRW0[22:19] */
-		pb_divide = ((reg_val & (FEED_REG_BIT_MASK <<
-				AXICLK_PB_DIVIDE_BIT_SHIFT)) >>
-				AXICLK_PB_DIVIDE_BIT_SHIFT);
-		*cpu_clock = osc2_value * (pa_divide + 1) / (pb_divide + 1);
-	} else {
-		err = -EIO;
-	}
-
-set_reg_error:
-ongoing_request:
-	raw_spin_unlock(&syscfg_lock);
-	*cpu_clock /= HZ_IN_MHZ;
-
-	if (!err)
-		cpu_clock_speed = *cpu_clock;
-
-	iounmap(scc_reg);
-
-scc_reg_map_failed:
-	iounmap(syscfg_reg);
-
-syscfg_reg_map_failed:
-
-	return err;
-}
-
-/**
- * kbase_get_platform_logic_tile_type -  determines which LogicTile type
- * is used by Versatile Express
- *
- * When platform_config build parameter is specified as vexpress, i.e.,
- * platform_config=vexpress, GPU frequency may vary dependent on the
- * particular platform. The GPU frequency depends on the LogicTile type.
- *
- * This function determines which LogicTile type is used by the platform by
- * reading the HBI value of the daughterboard which holds the LogicTile:
- *
- * 0x217 HBI0217 Virtex-6
- * 0x192 HBI0192 Virtex-5
- * 0x247 HBI0247 Virtex-7
- *
- * Return: HBI value of the logic tile daughterboard, zero if not accessible
- */
-static u32 kbase_get_platform_logic_tile_type(void)
-{
-	void __iomem *syscfg_reg = NULL;
-	u32 sys_procid1 = 0;
-
-	syscfg_reg = ioremap(VE_MOTHERBOARD_PERIPHERALS_SMB_CS7 + VE_SYS_PROC_ID1_OFFSET, 4);
-	if (NULL != syscfg_reg) {
-		sys_procid1 = readl(syscfg_reg);
-		iounmap(syscfg_reg);
-	}
-
-	return sys_procid1 & VE_LOGIC_TILE_HBI_MASK;
-}
-
-u32 kbase_get_platform_min_freq(void)
-{
-	u32 ve_logic_tile = kbase_get_platform_logic_tile_type();
-
-	switch (ve_logic_tile) {
-	case 0x217:
-		/* Virtex 6, HBI0217 */
-		return VE_VIRTEX6_GPU_FREQ_MIN;
-	case 0x247:
-		/* Virtex 7, HBI0247 */
-		return VE_VIRTEX7_GPU_FREQ_MIN;
-	default:
-		/* all other logic tiles, i.e., Virtex 5 HBI0192
-		 * or unsuccessful reading from the platform -
-		 * fall back to some default value */
-		return VE_DEFAULT_GPU_FREQ_MIN;
-	}
-}
-
-u32 kbase_get_platform_max_freq(void)
-{
-	u32 ve_logic_tile = kbase_get_platform_logic_tile_type();
-
-	switch (ve_logic_tile) {
-	case 0x217:
-		/* Virtex 6, HBI0217 */
-		return VE_VIRTEX6_GPU_FREQ_MAX;
-	case 0x247:
-		/* Virtex 7, HBI0247 */
-		return VE_VIRTEX7_GPU_FREQ_MAX;
-	default:
-		/* all other logic tiles, i.e., Virtex 5 HBI0192
-		 * or unsuccessful reading from the platform -
-		 * fall back to some default value */
-		return VE_DEFAULT_GPU_FREQ_MAX;
-	}
-}
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_cpu_vexpress.h b/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_cpu_vexpress.h
deleted file mode 100644
index da865698133a..000000000000
--- a/drivers/gpu/arm/bifrost/platform/vexpress/mali_kbase_cpu_vexpress.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- *
- * (C) COPYRIGHT 2012-2013, 2015-2016 ARM Limited. All rights reserved.
- *
- * This program is free software and is provided to you under the terms of the
- * GNU General Public License version 2 as published by the Free Software
- * Foundation, and any use by you of this program is subject to the terms
- * of such GNU licence.
- *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
- *
- */
-
-
-
-
-
-#ifndef _KBASE_CPU_VEXPRESS_H_
-#define _KBASE_CPU_VEXPRESS_H_
-
-/**
- * Versatile Express implementation of @ref kbase_cpu_clk_speed_func.
- */
-int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock);
-
-/**
- * Get the minimum GPU frequency for the attached logic tile
- */
-u32 kbase_get_platform_min_freq(void);
-
-/**
- * Get the maximum GPU frequency for the attached logic tile
- */
-u32 kbase_get_platform_max_freq(void);
-
-#endif				/* _KBASE_CPU_VEXPRESS_H_ */
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/Kbuild b/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/Kbuild
index df87c74f43ba..51b408efd48a 100644
--- a/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/Kbuild
+++ b/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/Kbuild
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 mali_kbase-y += \
 	$(MALI_PLATFORM_DIR)/mali_kbase_config_vexpress.o \
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/mali_kbase_config_platform.h b/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/mali_kbase_config_platform.h
index 0efbf3962f98..fac3cd52182f 100644
--- a/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/mali_kbase_config_platform.h
+++ b/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/mali_kbase_config_platform.h
@@ -7,52 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
  *
- */
-
-
-
-/**
- * Maximum frequency GPU will be clocked at. Given in kHz.
- * This must be specified as there is no default value.
- *
- * Attached value: number in kHz
- * Default value: NA
- */
-#define GPU_FREQ_KHZ_MAX 5000
-/**
- * Minimum frequency GPU will be clocked at. Given in kHz.
- * This must be specified as there is no default value.
- *
- * Attached value: number in kHz
- * Default value: NA
- */
-#define GPU_FREQ_KHZ_MIN 5000
-
-/**
- * CPU_SPEED_FUNC - A pointer to a function that calculates the CPU clock
- *
- * CPU clock speed of the platform is in MHz - see kbase_cpu_clk_speed_func
- * for the function prototype.
- *
- * Attached value: A kbase_cpu_clk_speed_func.
- * Default Value:  NA
- */
-#define CPU_SPEED_FUNC (&kbase_cpuprops_get_default_clock_speed)
-
-/**
- * GPU_SPEED_FUNC - A pointer to a function that calculates the GPU clock
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
  *
- * GPU clock speed of the platform in MHz - see kbase_gpu_clk_speed_func
- * for the function prototype.
+ * SPDX-License-Identifier: GPL-2.0
  *
- * Attached value: A kbase_gpu_clk_speed_func.
- * Default Value:  NA
  */
-#define GPU_SPEED_FUNC (NULL)
 
 /**
  * Power management configuration
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/mali_kbase_config_vexpress.c b/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/mali_kbase_config_vexpress.c
index 3ff0930fb4a3..efca0a5b3493 100644
--- a/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/mali_kbase_config_vexpress.c
+++ b/drivers/gpu/arm/bifrost/platform/vexpress_1xv7_a57/mali_kbase_config_vexpress.c
@@ -1,27 +1,30 @@
 /*
  *
- * (C) COPYRIGHT 2011-2014 ARM Limited. All rights reserved.
+ * (C) COPYRIGHT 2011-2014, 2017 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the
  * GNU General Public License version 2 as published by the Free Software
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/ioport.h>
 #include <mali_kbase.h>
 #include <mali_kbase_defs.h>
 #include <mali_kbase_config.h>
 
-#define HARD_RESET_AT_POWER_OFF 0
-
 #ifndef CONFIG_OF
 static struct kbase_io_resources io_resources = {
 	.job_irq_number = 68,
@@ -41,17 +44,6 @@ static int pm_callback_power_on(struct kbase_device *kbdev)
 
 static void pm_callback_power_off(struct kbase_device *kbdev)
 {
-#if HARD_RESET_AT_POWER_OFF
-	/* Cause a GPU hard reset to test whether we have actually idled the GPU
-	 * and that we properly reconfigure the GPU on power up.
-	 * Usually this would be dangerous, but if the GPU is working correctly it should
-	 * be completely safe as the GPU should not be active at this point.
-	 * However this is disabled normally because it will most likely interfere with
-	 * bus logging etc.
-	 */
-	KBASE_TRACE_ADD(kbdev, CORE_GPU_HARD_RESET, NULL, NULL, 0u, 0);
-	kbase_os_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_HARD_RESET);
-#endif
 }
 
 struct kbase_pm_callback_conf pm_callbacks = {
@@ -71,9 +63,3 @@ struct kbase_platform_config *kbase_get_platform_config(void)
 {
 	return &versatile_platform_config;
 }
-
-int kbase_platform_early_init(void)
-{
-	/* Nothing needed at this stage */
-	return 0;
-}
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/Kbuild b/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/Kbuild
index d9d5e9085231..e07709c9b1a5 100644
--- a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/Kbuild
+++ b/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/Kbuild
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 mali_kbase-y += \
 	$(MALI_PLATFORM_DIR)/mali_kbase_config_vexpress.o \
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_platform.h b/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_platform.h
index dbdf21e009f9..fac3cd52182f 100644
--- a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_platform.h
+++ b/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_platform.h
@@ -7,54 +7,18 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
  *
- */
-
-
-
-#include "mali_kbase_cpu_vexpress.h"
-
-/**
- * Maximum frequency GPU will be clocked at. Given in kHz.
- * This must be specified as there is no default value.
- *
- * Attached value: number in kHz
- * Default value: NA
- */
-#define GPU_FREQ_KHZ_MAX 10000
-/**
- * Minimum frequency GPU will be clocked at. Given in kHz.
- * This must be specified as there is no default value.
- *
- * Attached value: number in kHz
- * Default value: NA
- */
-#define GPU_FREQ_KHZ_MIN 10000
-
-/**
- * CPU_SPEED_FUNC - A pointer to a function that calculates the CPU clock
- *
- * CPU clock speed of the platform is in MHz - see kbase_cpu_clk_speed_func
- * for the function prototype.
- *
- * Attached value: A kbase_cpu_clk_speed_func.
- * Default Value:  NA
- */
-#define CPU_SPEED_FUNC (&kbase_get_vexpress_cpu_clock_speed)
-
-/**
- * GPU_SPEED_FUNC - A pointer to a function that calculates the GPU clock
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
  *
- * GPU clock speed of the platform in MHz - see kbase_gpu_clk_speed_func
- * for the function prototype.
+ * SPDX-License-Identifier: GPL-2.0
  *
- * Attached value: A kbase_gpu_clk_speed_func.
- * Default Value:  NA
  */
-#define GPU_SPEED_FUNC (NULL)
 
 /**
  * Power management configuration
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c b/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c
index 76ffe4a1e59e..b6714b95b776 100644
--- a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c
+++ b/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c
@@ -1,29 +1,31 @@
 /*
  *
- * (C) COPYRIGHT 2011-2014 ARM Limited. All rights reserved.
+ * (C) COPYRIGHT 2011-2014, 2017 ARM Limited. All rights reserved.
  *
  * This program is free software and is provided to you under the terms of the
  * GNU General Public License version 2 as published by the Free Software
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 #include <linux/ioport.h>
 #include <mali_kbase.h>
 #include <mali_kbase_defs.h>
 #include <mali_kbase_config.h>
-#include "mali_kbase_cpu_vexpress.h"
-
-#define HARD_RESET_AT_POWER_OFF 0
 
 #ifndef CONFIG_OF
 static struct kbase_io_resources io_resources = {
@@ -44,17 +46,6 @@ static int pm_callback_power_on(struct kbase_device *kbdev)
 
 static void pm_callback_power_off(struct kbase_device *kbdev)
 {
-#if HARD_RESET_AT_POWER_OFF
-	/* Cause a GPU hard reset to test whether we have actually idled the GPU
-	 * and that we properly reconfigure the GPU on power up.
-	 * Usually this would be dangerous, but if the GPU is working correctly it should
-	 * be completely safe as the GPU should not be active at this point.
-	 * However this is disabled normally because it will most likely interfere with
-	 * bus logging etc.
-	 */
-	KBASE_TRACE_ADD(kbdev, CORE_GPU_HARD_RESET, NULL, NULL, 0u, 0);
-	kbase_os_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_HARD_RESET);
-#endif
 }
 
 struct kbase_pm_callback_conf pm_callbacks = {
@@ -74,10 +65,3 @@ struct kbase_platform_config *kbase_get_platform_config(void)
 {
 	return &versatile_platform_config;
 }
-
-int kbase_platform_early_init(void)
-{
-	/* Nothing needed at this stage */
-	return 0;
-}
-
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c b/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c
deleted file mode 100644
index 816dff49835f..000000000000
--- a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- *
- * (C) COPYRIGHT 2011-2013 ARM Limited. All rights reserved.
- *
- * This program is free software and is provided to you under the terms of the
- * GNU General Public License version 2 as published by the Free Software
- * Foundation, and any use by you of this program is subject to the terms
- * of such GNU licence.
- *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
- *
- */
-
-
-
-
-
-#include <linux/io.h>
-#include <mali_kbase.h>
-#include "mali_kbase_cpu_vexpress.h"
-
-#define HZ_IN_MHZ					    (1000000)
-
-#define CORETILE_EXPRESS_A9X4_SCC_START	(0x100E2000)
-#define MOTHERBOARD_SYS_CFG_START		(0x10000000)
-#define SYS_CFGDATA_OFFSET				(0x000000A0)
-#define SYS_CFGCTRL_OFFSET				(0x000000A4)
-#define SYS_CFGSTAT_OFFSET				(0x000000A8)
-
-#define SYS_CFGCTRL_START_BIT_VALUE		  (1 << 31)
-#define READ_REG_BIT_VALUE				  (0 << 30)
-#define DCC_DEFAULT_BIT_VALUE			  (0 << 26)
-#define SYS_CFG_OSC_FUNC_BIT_VALUE		  (1 << 20)
-#define SITE_DEFAULT_BIT_VALUE			  (1 << 16)
-#define BOARD_STACK_POS_DEFAULT_BIT_VALUE (0 << 12)
-#define DEVICE_DEFAULT_BIT_VALUE	      (2 <<  0)
-#define SYS_CFG_COMPLETE_BIT_VALUE		  (1 <<  0)
-#define SYS_CFG_ERROR_BIT_VALUE			  (1 <<  1)
-
-#define FEED_REG_BIT_MASK				(0x0F)
-#define FCLK_PA_DIVIDE_BIT_SHIFT		(0x03)
-#define FCLK_PB_DIVIDE_BIT_SHIFT		(0x07)
-#define FCLK_PC_DIVIDE_BIT_SHIFT		(0x0B)
-#define AXICLK_PA_DIVIDE_BIT_SHIFT		(0x0F)
-#define AXICLK_PB_DIVIDE_BIT_SHIFT		(0x13)
-
-#define IS_SINGLE_BIT_SET(val, pos)		(val&(1<<pos))
-
-#define CPU_CLOCK_SPEED_UNDEFINED 0
-
-#define CPU_CLOCK_SPEED_6XV7 50
-
-static u32 cpu_clock_speed = CPU_CLOCK_SPEED_UNDEFINED;
-
-static DEFINE_RAW_SPINLOCK(syscfg_lock);
-/**
- * kbase_get_vendor_specific_cpu_clock_speed
- * @brief  Retrieves the CPU clock speed.
- *         The implementation is platform specific.
- * @param[out]    cpu_clock - the value of CPU clock speed in MHz
- * @return        0 on success, 1 otherwise
-*/
-int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock)
-{
-	/* TODO: MIDBASE-2873 - Provide runtime detection of CPU clock freq for 6XV7 board */
-	*cpu_clock = CPU_CLOCK_SPEED_6XV7;
-
-	return 0;
-}
diff --git a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.h b/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.h
deleted file mode 100644
index 23647ccb0871..000000000000
--- a/drivers/gpu/arm/bifrost/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- *
- * (C) COPYRIGHT 2012-2013, 2015 ARM Limited. All rights reserved.
- *
- * This program is free software and is provided to you under the terms of the
- * GNU General Public License version 2 as published by the Free Software
- * Foundation, and any use by you of this program is subject to the terms
- * of such GNU licence.
- *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
- *
- */
-
-
-
-
-
-#ifndef _KBASE_CPU_VEXPRESS_H_
-#define _KBASE_CPU_VEXPRESS_H_
-
-/**
- * Versatile Express implementation of @ref kbase_cpu_clk_speed_func.
- */
-int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock);
-
-#endif				/* _KBASE_CPU_VEXPRESS_H_ */
diff --git a/drivers/gpu/arm/bifrost/platform_dummy/mali_ukk_os.h b/drivers/gpu/arm/bifrost/platform_dummy/mali_ukk_os.h
index 5fa9b39c4bc0..ef1ec708edef 100644
--- a/drivers/gpu/arm/bifrost/platform_dummy/mali_ukk_os.h
+++ b/drivers/gpu/arm/bifrost/platform_dummy/mali_ukk_os.h
@@ -7,16 +7,21 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
 
 
-
-
 /**
  * @file mali_ukk_os.h
  * Types and definitions that are common for Linux OSs for the kernel side of the
diff --git a/drivers/gpu/arm/bifrost/protected_mode_switcher.h b/drivers/gpu/arm/bifrost/protected_mode_switcher.h
index 5dc2f3ba8cf6..8778d812aea0 100644
--- a/drivers/gpu/arm/bifrost/protected_mode_switcher.h
+++ b/drivers/gpu/arm/bifrost/protected_mode_switcher.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _PROTECTED_MODE_SWITCH_H_
 #define _PROTECTED_MODE_SWITCH_H_
 
diff --git a/drivers/gpu/arm/bifrost/sconscript b/drivers/gpu/arm/bifrost/sconscript
index e738dd7a3869..eae28f4011e9 100644
--- a/drivers/gpu/arm/bifrost/sconscript
+++ b/drivers/gpu/arm/bifrost/sconscript
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 import sys
 Import('env')
@@ -27,6 +33,7 @@ kbase_src = [
 	Glob('internal/*/*.c'),
 	Glob('ipa/*.c'),
 	Glob('platform/%s/*.c' % env['platform_config']),
+	Glob('thirdparty/*.c'),
 ]
 
 if env['platform_config']=='juno_soc':
@@ -46,20 +53,12 @@ make_args = env.kernel_get_config_defines(ret_list = True) + [
 	'MALI_RELEASE_NAME=%s' % env['mali_release_name'],
 	'MALI_MOCK_TEST=%s' % mock_test,
 	'MALI_CUSTOMER_RELEASE=%s' % env['release'],
-	'MALI_INSTRUMENTATION_LEVEL=%s' % env['instr'],
 	'MALI_COVERAGE=%s' % env['coverage'],
 ]
 
 kbase = env.BuildKernelModule('$STATIC_LIB_PATH/mali_kbase.ko', kbase_src,
                               make_args = make_args)
 
-# Add a dependency on kds.ko.
-# Only necessary when KDS is not built into the kernel.
-#
-if env['os'] != 'android':
-	if not env.KernelConfigEnabled("CONFIG_KDS"):
-		env.Depends(kbase, '$STATIC_LIB_PATH/kds.ko')
-
 # need Module.symvers from ump.ko build
 if int(env['ump']) == 1:
 	env.Depends(kbase, '$STATIC_LIB_PATH/ump.ko')
diff --git a/drivers/gpu/arm/bifrost/tests/Kbuild b/drivers/gpu/arm/bifrost/tests/Kbuild
index b4bed0473439..df16a77a7f66 100644
--- a/drivers/gpu/arm/bifrost/tests/Kbuild
+++ b/drivers/gpu/arm/bifrost/tests/Kbuild
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 obj-$(CONFIG_MALI_KUTF) += kutf/
 obj-$(CONFIG_MALI_IRQ_LATENCY) += mali_kutf_irq_test/
diff --git a/drivers/gpu/arm/bifrost/tests/Kconfig b/drivers/gpu/arm/bifrost/tests/Kconfig
index da0515c065de..fa91aea4ac5c 100644
--- a/drivers/gpu/arm/bifrost/tests/Kconfig
+++ b/drivers/gpu/arm/bifrost/tests/Kconfig
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 source "drivers/gpu/arm/midgard/tests/kutf/Kconfig"
 source "drivers/gpu/arm/midgard/tests/mali_kutf_irq_test/Kconfig"
diff --git a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_helpers.h b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_helpers.h
index 3f1dfc244d30..15e168c2385b 100644
--- a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_helpers.h
+++ b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_helpers.h
@@ -7,210 +7,71 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KERNEL_UTF_HELPERS_H_
 #define _KERNEL_UTF_HELPERS_H_
 
 /* kutf_helpers.h
  * Test helper functions for the kernel UTF test infrastructure.
  *
- * This collection of helper functions are provided as 'stock' implementation
- * helpers for certain features of kutf. Tests can implement common/boilerplate
- * functionality using these, whilst still providing them the option of
- * implementing completely custom functions themselves to use those kutf
- * features.
+ * These functions provide methods for enqueuing/dequeuing lines of text sent
+ * by user space. They are used to implement the transfer of "userdata" from
+ * user space to kernel.
  */
 
 #include <kutf/kutf_suite.h>
-#include <kutf/kutf_mem.h>
-#include <linux/wait.h>
-
-/**
- * enum kutf_helper_textbuf_flag - flags for textbufs
- * @KUTF_HELPER_TEXTBUF_FLAG_DYING:	Test is dying, textbuf should not allow
- *                                      writes, nor block on empty.
- */
-enum kutf_helper_textbuf_flag {
-	KUTF_HELPER_TEXTBUF_FLAG_DYING = (1u << 0),
-};
 
 /**
- * struct kutf_helper_textbuf_line - Structure representing a line of text
+ * kutf_helper_input_dequeue() - Dequeue a line sent by user space
+ * @context:    KUTF context
+ * @str_size:   Pointer to an integer to receive the size of the string
  *
- * The string itself is stored immediately after this.
+ * If no line is available then this function will wait (interruptibly) until
+ * a line is available.
  *
- * @node:		List node for the textbuf's textbuf_list
- * @str_size:		Length of the string buffer, including the \0 terminator
- * @str:		'Flexible array' for the string representing the line
+ * Return: The line dequeued, ERR_PTR(-EINTR) if interrupted or NULL on end
+ * of data.
  */
-struct kutf_helper_textbuf_line {
-	struct list_head node;
-	int str_size;
-	char str[];
-};
+char *kutf_helper_input_dequeue(struct kutf_context *context, size_t *str_size);
 
 /**
- * struct kutf_helper_textbuf - Structure to representing sequential lines of
- *                              text
- * @lock:		mutex to hold whilst accessing the structure
- * @nr_user_clients:	Number of userspace clients connected via an open()
- *                      call
- * @mempool:		mempool for allocating lines
- * @scratchpad:		scratch area for receiving text of size max_line_size
- * @used_bytes:		number of valid bytes in the scratchpad
- * @prev_pos:		Previous position userspace has accessed
- * @prev_line_pos:	Previous start of line position userspace has accessed
- * @textbuf_list:	List head to store all the lines of text
- * @max_line_size:	Maximum size in memory allowed for a line of text
- * @max_nr_lines:	Maximum number of lines permitted in this textbuf
- * @nr_lines:		Number of entries in textbuf_list
- * @flags:		Flags indicating state of the textbuf, using values
- *                      from enum kutf_helper_textbuf_flag
- * @user_opened_wq:	Waitq for when there's at least one userspace client
- *                      connected to the textbuf via an open() call
- * @not_full_wq:	Waitq for when the textbuf can be enqueued into/can
- *                      consume data from userspace
- * @not_empty_wq:	Waitq for when the textbuf can be dequeued from/can
- *                      produce data for userspace
- */
-
-struct kutf_helper_textbuf {
-	struct mutex lock;
-	int nr_user_clients;
-	struct kutf_mempool *mempool;
-	char *scratchpad;
-	int used_bytes;
-	loff_t prev_pos;
-	loff_t prev_line_pos;
-	struct list_head textbuf_list;
-	int max_line_size;
-	int max_nr_lines;
-	int nr_lines;
-	unsigned long flags;
-	wait_queue_head_t user_opened_wq;
-	wait_queue_head_t not_full_wq;
-	wait_queue_head_t not_empty_wq;
-
-};
-
-/* stock callbacks for userspace to read from/write to the 'data' file as a
- * textbuf */
-extern struct kutf_userdata_ops kutf_helper_textbuf_userdata_ops;
-
-/**
- * kutf_helper_textbuf_init() - init a textbuf for use as a 'data' file
- *                              consumer/producer
- * @textbuf:		textbuf to initialize
- * @mempool:		mempool to allocate from
- * @max_line_size:	maximum line size expected to/from userspace
- * @max_nr_lines:	maximum number of lines to expect to/from userspace
- *
- * Initialize a textbuf so that it can consume writes made to the 'data' file,
- * and produce reads for userspace on the 'data' file. Tests may then read the
- * lines written by userspace, or fill the buffer so it may be read back by
- * userspace.
- *
- * The caller should write the @textbuf pointer into the kutf_context's
- * userdata_producer_priv or userdata_consumer_priv member during fixture
- * creation.
+ * kutf_helper_input_enqueue() - Enqueue a line sent by user space
+ * @context:   KUTF context
+ * @str:       The user space address of the line
+ * @size:      The length in bytes of the string
  *
- * Usually a test will have separate textbufs for userspace to write to and
- * read from. Using the same one for both will echo back to the user what they
- * are writing.
+ * This function will use copy_from_user to copy the string out of user space.
+ * The string need not be NULL-terminated (@size should not include the NULL
+ * termination).
  *
- * Lines are understood as being separated by the '\n' character, but no '\n'
- * characters will be observed by the test
+ * As a special case @str==NULL and @size==0 is valid to mark the end of input,
+ * but callers should use kutf_helper_input_enqueue_end_of_data() instead.
  *
- * @max_line_size puts an upper bound on the size of lines in a textbuf,
- * including the \0 terminator. Lines exceeding this will be truncated,
- * effectively ignoring incoming data until the next '\n'
- *
- * Combining this with @max_nr_lines puts an upper bound on the size of the
- * file read in
- *
- * Return:		0 on success, or negative value on error.
+ * Return: 0 on success, -EFAULT if the line cannot be copied from user space,
+ * -ENOMEM if out of memory.
  */
-int kutf_helper_textbuf_init(struct kutf_helper_textbuf *textbuf,
-		struct kutf_mempool *mempool, int max_line_size,
-		int max_nr_lines);
+int kutf_helper_input_enqueue(struct kutf_context *context,
+		const char __user *str, size_t size);
 
 /**
- * kutf_helper_textbuf_wait_for_user() - wait for userspace to open the 'data'
- *                                       file
- * @textbuf:		textbuf to wait on
- *
- * This can be used to synchronize with userspace so that subsequent calls to
- * kutf_helper_textbuf_dequeue() and kutf_helper_textbuf_enqueue() should
- * succeed.
- *
- * Waiting is done on a timeout.
- *
- * There is of course no guarantee that userspace will keep the file open after
- * this, but any error in the dequeue/enqueue functions afterwards can be
- * treated as such rather than "we're still waiting for userspace to begin"
- *
- * Return:		0 if waited successfully, -ETIMEDOUT if we exceeded the
- *                      timeout, or some other negative value if there was an
- *                      error during waiting.
- */
-
-int kutf_helper_textbuf_wait_for_user(struct kutf_helper_textbuf *textbuf);
-
-
-/**
- * kutf_helper_textbuf_dequeue() - dequeue a line from a textbuf
- * @textbuf:		textbuf dequeue a line as a string from
- * @str_size:		pointer to storage to receive the size of the string,
- *                      which includes the '\0' terminator, or NULL if not
- *                      required
- *
- * Dequeue (remove) a line from the start of the textbuf as a string, and
- * return it.
- *
- * If no lines are available, then this will block until a line has been
- * submitted. If a userspace client is not connected and there are no remaining
- * lines, then this function returns NULL instead.
- *
- * The memory for the string comes from the kutf_mempool given during
- * initialization of the textbuf, and shares the same lifetime as it.
- *
- * Return:		pointer to the next line of the textbuf. NULL indicated
- *                      all userspace clients disconnected. An error value to be
- *                      checked with IS_ERR() family of functions if a signal or
- *                      some other error occurred
- */
-char *kutf_helper_textbuf_dequeue(struct kutf_helper_textbuf *textbuf,
-		int *str_size);
-
-/**
- * kutf_helper_textbuf_enqueue() - enqueue a line to a textbuf
- * @textbuf:		textbuf to enqueue a line as a string to
- * @enqueue_str:	pointer to the string to enqueue to the textbuf
- * @buf_max_size:	maximum size of the buffer holding @enqueue_str
- *
- * Enqueue (add) a line to the end of a textbuf as a string.
- *
- * The caller should avoid placing '\n' characters in their strings, as these
- * will not be split into multiple lines.
- *
- * A copy of the string will be made into the textbuf, so @enqueue_str can be
- * freed immediately after if.the caller wishes to do so.
- *
- * If the maximum amount of lines has been reached, then this will block until
- * a line has been removed to make space. If a userspace client is not
- * connected and there is no space available, then this function returns
- * -EBUSY.
+ * kutf_helper_input_enqueue_end_of_data() - Signal no more data is to be sent
+ * @context:    KUTF context
  *
- * Return:		0 on success, or negative value on error
+ * After this function has been called, kutf_helper_input_dequeue() will always
+ * return NULL.
  */
-int kutf_helper_textbuf_enqueue(struct kutf_helper_textbuf *textbuf,
-		char *enqueue_str, int buf_max_size);
+void kutf_helper_input_enqueue_end_of_data(struct kutf_context *context);
 
 #endif	/* _KERNEL_UTF_HELPERS_H_ */
diff --git a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_helpers_user.h b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_helpers_user.h
index 759bf717c7cd..3b1300e1ce6f 100644
--- a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_helpers_user.h
+++ b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_helpers_user.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KERNEL_UTF_HELPERS_USER_H_
 #define _KERNEL_UTF_HELPERS_USER_H_
 
@@ -80,18 +85,16 @@ enum kutf_helper_err {
 };
 
 
-/* textbuf Send named NAME=value pair, u64 value
+/* Send named NAME=value pair, u64 value
  *
  * NAME must match [A-Z0-9_]\+ and can be up to MAX_VAL_NAME_LEN characters long
  *
- * This is assuming the kernel-side test is using the 'textbuf' helpers
- *
  * Any failure will be logged on the suite's current test fixture
  *
  * Returns 0 on success, non-zero on failure
  */
-int kutf_helper_textbuf_send_named_u64(struct kutf_context *context,
-		struct kutf_helper_textbuf *textbuf, char *val_name, u64 val);
+int kutf_helper_send_named_u64(struct kutf_context *context,
+		const char *val_name, u64 val);
 
 /* Get the maximum length of a string that can be represented as a particular
  * NAME="value" pair without string-value truncation in the kernel's buffer
@@ -101,53 +104,48 @@ int kutf_helper_textbuf_send_named_u64(struct kutf_context *context,
  * without having the string value truncated. Any string longer than this will
  * be truncated at some point during communication to this size.
  *
- * The calculation is valid both for sending strings of val_str_len to kernel,
- * and for receiving a string that was originally val_str_len from the kernel.
- *
- * It is assumed that valname is a valid name for
- * kutf_test_helpers_textbuf_send_named_str(), and no checking will be made to
+ * It is assumed that val_name is a valid name for
+ * kutf_helper_send_named_str(), and no checking will be made to
  * ensure this.
  *
  * Returns the maximum string length that can be represented, or a negative
  * value if the NAME="value" encoding itself wouldn't fit in kern_buf_sz
  */
-int kutf_helper_textbuf_max_str_len_for_kern(char *val_name, int kern_buf_sz);
+int kutf_helper_max_str_len_for_kern(const char *val_name, int kern_buf_sz);
 
-/* textbuf Send named NAME="str" pair
+/* Send named NAME="str" pair
  *
  * no escaping allowed in str. Any of the following characters will terminate
  * the string: '"' '\\' '\n'
  *
  * NAME must match [A-Z0-9_]\+ and can be up to MAX_VAL_NAME_LEN characters long
  *
- * This is assuming the kernel-side test is using the 'textbuf' helpers
- *
  * Any failure will be logged on the suite's current test fixture
  *
  * Returns 0 on success, non-zero on failure */
-int kutf_helper_textbuf_send_named_str(struct kutf_context *context,
-		struct kutf_helper_textbuf *textbuf, char *val_name,
-		char *val_str);
+int kutf_helper_send_named_str(struct kutf_context *context,
+		const char *val_name, const char *val_str);
 
-/* textbuf Receive named NAME=value pair
+/* Receive named NAME=value pair
  *
  * This can receive u64 and string values - check named_val->type
  *
  * If you are not planning on dynamic handling of the named value's name and
- * type, then kutf_test_helpers_textbuf_receive_check_val() is more useful as a
+ * type, then kutf_helper_receive_check_val() is more useful as a
  * convenience function.
  *
  * String members of named_val will come from memory allocated on the fixture's mempool
  *
- * Returns 0 on success. Negative value on failure to receive from the 'data'
+ * Returns 0 on success. Negative value on failure to receive from the 'run'
  * file, positive value indicates an enum kutf_helper_err value for correct
  * reception of data but invalid parsing */
-int kutf_helper_textbuf_receive_named_val(struct kutf_helper_named_val *named_val,
-		struct kutf_helper_textbuf *textbuf);
+int kutf_helper_receive_named_val(
+		struct kutf_context *context,
+		struct kutf_helper_named_val *named_val);
 
-/* textbuf Receive and validate NAME=value pair
+/* Receive and validate NAME=value pair
  *
- * As with kutf_test_helpers_textbuf_receive_named_val, but validate that the
+ * As with kutf_helper_receive_named_val, but validate that the
  * name and type are as expected, as a convenience for a common pattern found
  * in tests.
  *
@@ -168,9 +166,11 @@ int kutf_helper_textbuf_receive_named_val(struct kutf_helper_named_val *named_va
  *
  * The rationale behind this is that we'd prefer to continue the rest of the
  * test with failures propagated, rather than hitting a timeout */
-int kutf_helper_textbuf_receive_check_val(struct kutf_helper_named_val *named_val,
-		struct kutf_context *context, struct kutf_helper_textbuf *textbuf,
-		char *expect_val_name, enum kutf_helper_valtype expect_val_type);
+int kutf_helper_receive_check_val(
+		struct kutf_helper_named_val *named_val,
+		struct kutf_context *context,
+		const char *expect_val_name,
+		enum kutf_helper_valtype expect_val_type);
 
 /* Output a named value to kmsg */
 void kutf_helper_output_named_val(struct kutf_helper_named_val *named_val);
diff --git a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_mem.h b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_mem.h
index 584c9dd4bc13..988559de1edf 100644
--- a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_mem.h
+++ b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_mem.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KERNEL_UTF_MEM_H_
 #define _KERNEL_UTF_MEM_H_
 
diff --git a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_resultset.h b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_resultset.h
index 1cc85f1b7a46..49ebeb4ec546 100644
--- a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_resultset.h
+++ b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_resultset.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KERNEL_UTF_RESULTSET_H_
 #define _KERNEL_UTF_RESULTSET_H_
 
@@ -42,7 +47,12 @@
  * @KUTF_RESULT_FATAL:		The test result failed with a fatal error.
  * @KUTF_RESULT_ABORT:		The test result failed due to a non-UTF
  *                              assertion failure.
- * @KUTF_RESULT_COUNT:		The current number of possible status messages.
+ * @KUTF_RESULT_USERDATA:	User data is ready to be read,
+ *                              this is not seen outside the kernel
+ * @KUTF_RESULT_USERDATA_WAIT:	Waiting for user data to be sent,
+ *                              this is not seen outside the kernel
+ * @KUTF_RESULT_TEST_FINISHED:	The test has finished, no more results will
+ *                              be produced. This is not seen outside kutf
  */
 enum kutf_result_status {
 	KUTF_RESULT_BENCHMARK = -3,
@@ -57,7 +67,9 @@ enum kutf_result_status {
 	KUTF_RESULT_FATAL   = 5,
 	KUTF_RESULT_ABORT   = 6,
 
-	KUTF_RESULT_COUNT
+	KUTF_RESULT_USERDATA      = 7,
+	KUTF_RESULT_USERDATA_WAIT = 8,
+	KUTF_RESULT_TEST_FINISHED = 9
 };
 
 /* The maximum size of a kutf_result_status result when
@@ -68,6 +80,9 @@ enum kutf_result_status {
 #ifdef __KERNEL__
 
 #include <kutf/kutf_mem.h>
+#include <linux/wait.h>
+
+struct kutf_context;
 
 /**
  * struct kutf_result - Represents a single test result.
@@ -81,41 +96,86 @@ struct kutf_result {
 	const char                  *message;
 };
 
+/**
+ * KUTF_RESULT_SET_WAITING_FOR_INPUT - Test is waiting for user data
+ *
+ * This flag is set within a struct kutf_result_set whenever the test is blocked
+ * waiting for user data. Attempts to dequeue results when this flag is set
+ * will cause a dummy %KUTF_RESULT_USERDATA_WAIT result to be produced. This
+ * is used to output a warning message and end of file.
+ */
+#define KUTF_RESULT_SET_WAITING_FOR_INPUT 1
+
+/**
+ * struct kutf_result_set - Represents a set of results.
+ * @results:	List head of a struct kutf_result list for storing the results
+ * @waitq:	Wait queue signalled whenever new results are added.
+ * @flags:	Flags see %KUTF_RESULT_SET_WAITING_FOR_INPUT
+ */
+struct kutf_result_set {
+	struct list_head          results;
+	wait_queue_head_t         waitq;
+	int                       flags;
+};
+
 /**
  * kutf_create_result_set() - Create a new result set
  *                            to which results can be added.
  *
- * Return: The created resultset.
+ * Return: The created result set.
  */
 struct kutf_result_set *kutf_create_result_set(void);
 
 /**
- * kutf_add_result() - Add a result to the end of an existing resultset.
+ * kutf_add_result() - Add a result to the end of an existing result set.
  *
- * @mempool:	The memory pool to allocate the result storage from.
- * @set:	The resultset to add the result to.
+ * @context:	The kutf context
  * @status:	The result status to add.
  * @message:	The result message to add.
+ *
+ * Return: 0 if the result is successfully added. -ENOMEM if allocation fails.
  */
-void kutf_add_result(struct kutf_mempool *mempool, struct kutf_result_set *set,
+int kutf_add_result(struct kutf_context *context,
 		enum kutf_result_status status, const char *message);
 
 /**
- * kutf_remove_result() - Remove a result from the head of a resultset.
- * @set:	The resultset.
+ * kutf_remove_result() - Remove a result from the head of a result set.
+ * @set:	The result set.
+ *
+ * This function will block until there is a result to read. The wait is
+ * interruptible, so this function will return with an ERR_PTR if interrupted.
  *
- * Return: result or NULL if there are no further results in the resultset.
+ * Return: result or ERR_PTR if interrupted
  */
 struct kutf_result *kutf_remove_result(
 		struct kutf_result_set *set);
 
 /**
- * kutf_destroy_result_set() - Free a previously created resultset.
+ * kutf_destroy_result_set() - Free a previously created result set.
  *
  * @results:	The result set whose resources to free.
  */
 void kutf_destroy_result_set(struct kutf_result_set *results);
 
+/**
+ * kutf_set_waiting_for_input() - The test is waiting for userdata
+ *
+ * @set: The result set to update
+ *
+ * Causes the result set to always have results and return a fake
+ * %KUTF_RESULT_USERDATA_WAIT result.
+ */
+void kutf_set_waiting_for_input(struct kutf_result_set *set);
+
+/**
+ * kutf_clear_waiting_for_input() - The test is no longer waiting for userdata
+ *
+ * @set: The result set to update
+ *
+ * Cancels the effect of kutf_set_waiting_for_input()
+ */
+void kutf_clear_waiting_for_input(struct kutf_result_set *set);
+
 #endif	/* __KERNEL__ */
 
 #endif	/* _KERNEL_UTF_RESULTSET_H_ */
diff --git a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_suite.h b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_suite.h
index cba2b2d84d62..8d75f506f9eb 100644
--- a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_suite.h
+++ b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_suite.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KERNEL_UTF_SUITE_H_
 #define _KERNEL_UTF_SUITE_H_
 
@@ -27,10 +32,17 @@
  */
 
 #include <linux/kref.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
 
 #include <kutf/kutf_mem.h>
 #include <kutf/kutf_resultset.h>
 
+/* Arbitrary maximum size to prevent user space allocating too much kernel
+ * memory
+ */
+#define KUTF_MAX_LINE_LENGTH (1024u)
+
 /**
  * Pseudo-flag indicating an absence of any specified test class. Note that
  * tests should not be annotated with this constant as it is simply a zero
@@ -149,24 +161,42 @@ union kutf_callback_data {
 };
 
 /**
- * struct kutf_userdata_ops- Structure defining methods to exchange data
- *                           with userspace via the 'data' file
- * @open:		Function used to notify when the 'data' file was opened
- * @release:		Function used to notify when the 'data' file was closed
- * @notify_ended:	Function used to notify when the test has ended.
- * @consumer:		Function used to consume writes from userspace
- * @producer:		Function used to produce data for userspace to read
+ * struct kutf_userdata_line - A line of user data to be returned to the user
+ * @node:   struct list_head to link this into a list
+ * @str:    The line of user data to return to user space
+ * @size:   The number of bytes within @str
+ */
+struct kutf_userdata_line {
+	struct list_head node;
+	char *str;
+	size_t size;
+};
+
+/**
+ * KUTF_USERDATA_WARNING_OUTPUT - Flag specifying that a warning has been output
  *
- * All ops can be NULL.
- */
-struct kutf_userdata_ops {
-	int (*open)(void *priv);
-	void (*release)(void *priv);
-	void (*notify_ended)(void *priv);
-	ssize_t (*consumer)(void *priv, const char  __user *userbuf,
-			size_t userbuf_len, loff_t *ppos);
-	ssize_t (*producer)(void *priv, char  __user *userbuf,
-			size_t userbuf_len, loff_t *ppos);
+ * If user space reads the "run" file while the test is waiting for user data,
+ * then the framework will output a warning message and set this flag within
+ * struct kutf_userdata. A subsequent read will then simply return an end of
+ * file condition rather than outputting the warning again. The upshot of this
+ * is that simply running 'cat' on a test which requires user data will produce
+ * the warning followed by 'cat' exiting due to EOF - which is much more user
+ * friendly than blocking indefinitely waiting for user data.
+ */
+#define KUTF_USERDATA_WARNING_OUTPUT  1
+
+/**
+ * struct kutf_userdata - Structure holding user data
+ * @flags:       See %KUTF_USERDATA_WARNING_OUTPUT
+ * @input_head:  List of struct kutf_userdata_line containing user data
+ *               to be read by the kernel space test.
+ * @input_waitq: Wait queue signalled when there is new user data to be
+ *               read by the kernel space test.
+ */
+struct kutf_userdata {
+	unsigned long flags;
+	struct list_head input_head;
+	wait_queue_head_t input_waitq;
 };
 
 /**
@@ -185,13 +215,8 @@ struct kutf_userdata_ops {
  * @status:		The status of the currently running fixture.
  * @expected_status:	The expected status on exist of the currently
  *                      running fixture.
- * @userdata_consumer_priv:	Parameter to pass into kutf_userdata_ops
- *                              consumer function. Must not be NULL if a
- *                              consumer function was specified
- * @userdata_producer_priv:	Parameter to pass into kutf_userdata_ops
- *                              producer function. Must not be NULL if a
- *                              producer function was specified
- * @userdata_dentry:	The debugfs file for userdata exchange
+ * @work:		Work item to enqueue onto the work queue to run the test
+ * @userdata:		Structure containing the user data for the test to read
  */
 struct kutf_context {
 	struct kref                     kref;
@@ -205,9 +230,9 @@ struct kutf_context {
 	struct kutf_result_set          *result_set;
 	enum kutf_result_status         status;
 	enum kutf_result_status         expected_status;
-	void                            *userdata_consumer_priv;
-	void                            *userdata_producer_priv;
-	struct dentry                   *userdata_dentry;
+
+	struct work_struct              work;
+	struct kutf_userdata            userdata;
 };
 
 /**
@@ -391,30 +416,6 @@ void kutf_add_test_with_filters_and_data(
 		unsigned int filters,
 		union kutf_callback_data test_data);
 
-/**
- * kutf_add_test_with_filters_data_and_userdata() - Add a test to a kernel test suite with filters and setup for
- *                                                  receiving data from userside
- * @suite:		The suite to add the test to.
- * @id:			The ID of the test.
- * @name:		The name of the test.
- * @execute:		Callback to the test function to run.
- * @filters:		A set of filtering flags, assigning test categories.
- * @test_data:		Test specific callback data, provided during the
- *			running of the test in the kutf_context
- * @userdata_ops:	Callbacks to use for sending and receiving data to
- *			userspace. A copy of the struct kutf_userdata_ops is
- *			taken. Each callback can be NULL.
- *
- */
-void kutf_add_test_with_filters_data_and_userdata(
-		struct kutf_suite *suite,
-		unsigned int id,
-		const char *name,
-		void (*execute)(struct kutf_context *context),
-		unsigned int filters,
-		union kutf_callback_data test_data,
-		struct kutf_userdata_ops *userdata_ops);
-
 
 /* ============================================================================
 	Test functions
diff --git a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_utils.h b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_utils.h
index c458c1f73802..25b8285500d7 100644
--- a/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_utils.h
+++ b/drivers/gpu/arm/bifrost/tests/include/kutf/kutf_utils.h
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #ifndef _KERNEL_UTF_UTILS_H_
 #define _KERNEL_UTF_UTILS_H_
 
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/Kbuild b/drivers/gpu/arm/bifrost/tests/kutf/Kbuild
index 97f80057224f..2531d41ca28d 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/Kbuild
+++ b/drivers/gpu/arm/bifrost/tests/kutf/Kbuild
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 ccflags-y += -I$(src)/../include
 
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/Kconfig b/drivers/gpu/arm/bifrost/tests/kutf/Kconfig
index 6a87bdbf746e..0cdb474c06a3 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/Kconfig
+++ b/drivers/gpu/arm/bifrost/tests/kutf/Kconfig
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 
 config MALI_KUTF
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/Makefile b/drivers/gpu/arm/bifrost/tests/kutf/Makefile
index 010c92ca39b9..d848e8774bd0 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/Makefile
+++ b/drivers/gpu/arm/bifrost/tests/kutf/Makefile
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 # linux build system bootstrap for out-of-tree module
 
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/kutf_helpers.c b/drivers/gpu/arm/bifrost/tests/kutf/kutf_helpers.c
index 793d58c789ff..cab5add6d93c 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/kutf_helpers.c
+++ b/drivers/gpu/arm/bifrost/tests/kutf/kutf_helpers.c
@@ -7,19 +7,22 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /* Kernel UTF test helpers */
 #include <kutf/kutf_helpers.h>
 
-/* 10s timeout for user thread to open the 'data' file once the test is started */
-#define USERDATA_WAIT_TIMEOUT_MS 10000
 #include <linux/err.h>
 #include <linux/jiffies.h>
 #include <linux/sched.h>
@@ -27,742 +30,100 @@
 #include <linux/wait.h>
 #include <linux/uaccess.h>
 
+static DEFINE_SPINLOCK(kutf_input_lock);
 
-int kutf_helper_textbuf_init(struct kutf_helper_textbuf *textbuf,
-		struct kutf_mempool *mempool, int max_line_size,
-		int max_nr_lines)
-{
-	textbuf->scratchpad = kutf_mempool_alloc(mempool, max_line_size);
-
-	if (!textbuf->scratchpad)
-		return -ENOMEM;
-
-	mutex_init(&textbuf->lock);
-	textbuf->nr_user_clients = 0;
-	textbuf->mempool = mempool;
-	textbuf->used_bytes = 0;
-	textbuf->prev_pos = 0;
-	textbuf->prev_line_pos = 0;
-	INIT_LIST_HEAD(&textbuf->textbuf_list);
-	textbuf->max_line_size = max_line_size;
-	textbuf->max_nr_lines = max_nr_lines;
-	textbuf->nr_lines = 0;
-	textbuf->flags = 0ul;
-	init_waitqueue_head(&textbuf->user_opened_wq);
-	init_waitqueue_head(&textbuf->not_full_wq);
-	init_waitqueue_head(&textbuf->not_empty_wq);
-
-	return 0;
-}
-EXPORT_SYMBOL(kutf_helper_textbuf_init);
-
-/**
- * kutf_helper_textbuf_open() - Notify that userspace has opened the 'data'
- *                              file for a textbuf
- *
- * @priv:		private pointer from a kutf_userdata_exchange, which
- *                      should be a pointer to a struct kutf_helper_textbuf
- *
- * Return:		0 on success, or negative value on error.
- */
-static int kutf_helper_textbuf_open(void *priv)
-{
-	struct kutf_helper_textbuf *textbuf = priv;
-	int ret;
-
-	ret = mutex_lock_interruptible(&textbuf->lock);
-	if (ret)
-		return -ERESTARTSYS;
-
-	++(textbuf->nr_user_clients);
-	wake_up(&textbuf->user_opened_wq);
-
-	mutex_unlock(&textbuf->lock);
-	return ret;
-}
-
-/**
- * kutf_helper_textbuf_release() - Notify that userspace has closed the 'data'
- *                                 file for a textbuf
- *
- * @priv:		private pointer from a kutf_userdata_exchange, which
- *                      should be a pointer to a struct kutf_helper_textbuf
- */
-static void kutf_helper_textbuf_release(void *priv)
-{
-	struct kutf_helper_textbuf *textbuf = priv;
-
-	/* Shouldn't use interruptible variants here because if a signal is
-	 * pending, we can't abort and restart the call */
-	mutex_lock(&textbuf->lock);
-
-	--(textbuf->nr_user_clients);
-	if (!textbuf->nr_user_clients) {
-		/* All clients disconnected, wakeup kernel-side waiters */
-		wake_up(&textbuf->not_full_wq);
-		wake_up(&textbuf->not_empty_wq);
-	}
-
-	mutex_unlock(&textbuf->lock);
-}
-
-/**
- * kutf_helper_textbuf_notify_test_ended() - Notify that the test has ended
- *
- * @priv:		private pointer from a kutf_userdata_exchange, which
- *                      should be a pointer to a struct kutf_helper_textbuf
- *
- * After this call, userspace should be allowed to finish remaining reads but
- * not make new ones, and not be allowed to make new writes.
- */
-static void kutf_helper_textbuf_notify_test_ended(void *priv)
-{
-	struct kutf_helper_textbuf *textbuf = priv;
-
-	/* Shouldn't use interruptible variants here because if a signal is
-	 * pending, we can't abort and restart the call */
-	mutex_lock(&textbuf->lock);
-
-	textbuf->flags |= KUTF_HELPER_TEXTBUF_FLAG_DYING;
-
-	/* Consumers waiting due to being full should wake up and abort */
-	wake_up(&textbuf->not_full_wq);
-	/* Producers waiting due to being empty should wake up and abort */
-	wake_up(&textbuf->not_empty_wq);
-
-	mutex_unlock(&textbuf->lock);
-}
-
-/* Collect text in a textbuf scratchpad up to (but excluding) specified
- * newline_off, and add it as a textbuf_line
- *
- * newline_off is permissible to be at the character after the end of the
- * scratchpad (i.e. equal to textbuf->max_line_size), for handling when the
- * line was longer than the size of the scratchpad. Nevertheless, the resulting
- * size of the line is kept at textbuf->max_line_size, including the '\0'
- * terminator. That is, the string length will be textbuf->max_line_size-1.
- *
- * Remaining characters strictly after newline_off are moved to the beginning
- * of the scratchpad, to allow space for a longer line to be collected. This
- * means the character specified at newline_off will be removed from/no longer
- * be within the valid region of the scratchpad
- *
- * Returns number of bytes the scratchpad was shortened by, or an error
- * otherwise
- */
-static size_t collect_line(struct kutf_helper_textbuf *textbuf, int newline_off)
-{
-	/* '\n' terminator will be replaced as '\0' */
-	int str_buf_size;
-	struct kutf_helper_textbuf_line *textbuf_line;
-	char *str_start;
-	int bytes_remain;
-	char *scratch = textbuf->scratchpad;
-	int nextline_off;
-
-	str_buf_size = newline_off + 1;
-	if (str_buf_size > textbuf->max_line_size)
-		str_buf_size = textbuf->max_line_size;
-
-	/* String is stored immediately after the line */
-	textbuf_line = kutf_mempool_alloc(textbuf->mempool, str_buf_size + sizeof(struct kutf_helper_textbuf_line));
-	if (!textbuf_line)
-		return -ENOMEM;
-
-	str_start = &textbuf_line->str[0];
-
-	/* Copy in string, excluding the terminating '\n' character, replacing
-	 * it with '\0' */
-	strncpy(str_start, scratch, str_buf_size - 1);
-	str_start[str_buf_size-1] = '\0';
-	textbuf_line->str_size = str_buf_size;
-
-	/* Append to the textbuf */
-	list_add_tail(&textbuf_line->node, &textbuf->textbuf_list);
-	++(textbuf->nr_lines);
-
-	/* Move the rest of the scratchpad to the start */
-	nextline_off = newline_off + 1;
-	if (nextline_off > textbuf->used_bytes)
-		nextline_off =  textbuf->used_bytes;
-
-	bytes_remain = textbuf->used_bytes - nextline_off;
-	memmove(scratch, scratch + nextline_off, bytes_remain);
-	textbuf->used_bytes = bytes_remain;
-
-	/* Wakeup anyone blocked on empty */
-	wake_up(&textbuf->not_empty_wq);
-
-	return nextline_off;
-}
-
-/* Buffer size for truncating a string to its newline.
- * Allocated on the stack, so keep it moderately small (within PAGE_SIZE) */
-#define TRUNCATE_BUF_SZ 512
-
-/* Discard input from a userbuf up to a newline, then collect what was in the
- * scratchpad into a new textbuf line */
-static ssize_t collect_longline_truncate(struct kutf_helper_textbuf *textbuf,
-		const char  __user *userbuf, size_t userbuf_len)
-{
-	ssize_t bytes_processed = 0;
-
-	while (userbuf_len > 0) {
-		int userbuf_copy_sz = userbuf_len;
-		size_t res;
-		char *newline_ptr;
-		char truncate_buf[TRUNCATE_BUF_SZ];
-
-		if (userbuf_len > TRUNCATE_BUF_SZ)
-			userbuf_copy_sz = TRUNCATE_BUF_SZ;
-		else
-			userbuf_copy_sz = (int)userbuf_len;
-
-		/* copy what we can */
-		res = copy_from_user(truncate_buf, userbuf, userbuf_copy_sz);
-		if (res == userbuf_copy_sz)
-			return -EFAULT;
-		userbuf_copy_sz -= res;
-
-		/* Search for newline in what was copied */
-		newline_ptr = strnchr(truncate_buf, userbuf_copy_sz, '\n');
-
-		if (newline_ptr) {
-			ssize_t sres;
-			/* Newline found: collect scratchpad and exit out */
-			int newline_off = newline_ptr - truncate_buf;
-
-			sres = collect_line(textbuf, textbuf->used_bytes);
-			if (sres < 0)
-				return sres;
-
-			bytes_processed += newline_off + 1;
-			break;
-		}
-
-		/* Newline not yet found: advance to the next part to copy */
-		userbuf += userbuf_copy_sz;
-		userbuf_len -= userbuf_copy_sz;
-		bytes_processed += userbuf_copy_sz;
-	}
-
-	return bytes_processed;
-}
-
-/**
- * kutf_helper_textbuf_consume() - 'data' file consumer function for writing to
- *                                 a textbuf
- * @priv:		private pointer from a kutf_userdata_exchange, which
- *                      should be a pointer to a struct kutf_helper_textbuf to
- *                      write into
- * @userbuf:		the userspace buffer to read from
- * @userbuf_len:	size of the userspace buffer
- * @ppos:		the current position in the buffer
- *
- * This consumer function is used as a write consumer for the 'data' file,
- * receiving data that has been written to the 'data' file by userspace. It
- * will read from the userspace buffer @userbuf and separates it into '\n'
- * delimited lines for the textbuf pointed to by @priv .
- *
- * If there is insufficient space in textbuf, then it will block until there is
- * space - for example, a kernel-side test calls
- * kutf_helper_textbuf_dequeue(). Since this is expected to be called in the
- * context of a syscall, the call can only be cancelled by sending an
- * appropriate signal to the userspace process.
- *
- * The current position @ppos is advanced by the number of bytes successfully
- * read.
- *
- * Return:		the number of bytes read, or negative value on error.
- */
-static ssize_t kutf_helper_textbuf_consume(void *priv,
-		const char  __user *userbuf, size_t userbuf_len, loff_t *ppos)
+static bool pending_input(struct kutf_context *context)
 {
-	struct kutf_helper_textbuf *textbuf = priv;
-	int userbuf_copy_sz;
-	char *next_newline_ptr;
-	size_t bytes_processed = 0;
-	int newdata_off;
-	ssize_t ret;
-
-	ret = mutex_lock_interruptible(&textbuf->lock);
-	if (ret)
-		return -ERESTARTSYS;
-
-	/* Validate input */
-	if (*ppos < 0) {
-		ret = -EINVAL;
-		goto out_unlock;
-	}
-	if (!userbuf_len) {
-		ret = 0;
-		goto out_unlock;
-	}
-
-	while (textbuf->nr_lines >= textbuf->max_nr_lines &&
-			!(textbuf->flags & KUTF_HELPER_TEXTBUF_FLAG_DYING)) {
-		/* Block on kernel-side dequeue making space available
-		 * NOTE: should also handle O_NONBLOCK */
-		mutex_unlock(&textbuf->lock);
-		ret = wait_event_interruptible(textbuf->not_full_wq,
-				(textbuf->nr_lines < textbuf->max_nr_lines ||
-				(textbuf->flags & KUTF_HELPER_TEXTBUF_FLAG_DYING)));
-		if (ret)
-			return -ERESTARTSYS;
-		ret = mutex_lock_interruptible(&textbuf->lock);
-		if (ret)
-			return -ERESTARTSYS;
-	}
-
-	if (textbuf->flags & KUTF_HELPER_TEXTBUF_FLAG_DYING) {
-		ret = -ENODEV;
-		goto out_unlock;
-	}
-
-	if (textbuf->prev_pos != *ppos && textbuf->used_bytes) {
-		/* Seeking causes a new line to occur:
-		 * Truncate what data was there into a textbuf-line, and reset
-		 * the buffer */
-		ret = collect_line(textbuf, textbuf->used_bytes);
-		if (ret < 0)
-			goto finish;
-	} else if (textbuf->used_bytes >= (textbuf->max_line_size - 1)) {
-		/* Line too long discard input until we find a '\n' */
-		ret = collect_longline_truncate(textbuf, userbuf, userbuf_len);
-
-		if (ret < 0)
-			goto finish;
-
-		/* Update userbuf with how much was processed, which may be the
-		 * entire buffer now */
-		userbuf += ret;
-		userbuf_len -= ret;
-		bytes_processed += ret;
-
-		/* If there's buffer remaining and we fault later (e.g. can't
-		 * read or OOM) ensure ppos is updated */
-		*ppos += ret;
-
-		/* recheck in case entire buffer processed */
-		if (!userbuf_len)
-			goto finish;
-	}
-
-	/* An extra line may've been added, ensure we don't overfill */
-	if (textbuf->nr_lines >= textbuf->max_nr_lines)
-		goto finish_noerr;
-
-	userbuf_copy_sz = userbuf_len;
-
-	/* Copy in as much as we can */
-	if (userbuf_copy_sz > textbuf->max_line_size - textbuf->used_bytes)
-		userbuf_copy_sz = textbuf->max_line_size - textbuf->used_bytes;
-
-	ret = copy_from_user(textbuf->scratchpad + textbuf->used_bytes, userbuf, userbuf_copy_sz);
-	if (ret == userbuf_copy_sz) {
-		ret = -EFAULT;
-		goto finish;
-	}
-	userbuf_copy_sz -= ret;
-
-	newdata_off = textbuf->used_bytes;
-	textbuf->used_bytes += userbuf_copy_sz;
-
-	while (textbuf->used_bytes && textbuf->nr_lines < textbuf->max_nr_lines) {
-		int new_bytes_remain = textbuf->used_bytes - newdata_off;
-		/* Find a new line - only the new part should be checked */
-		next_newline_ptr = strnchr(textbuf->scratchpad + newdata_off, new_bytes_remain, '\n');
-
-		if (next_newline_ptr) {
-			int newline_off = next_newline_ptr - textbuf->scratchpad;
-
-			/* if found, collect up to it, then memmove the rest */
-			/* reset positions and see if we can fill any further */
-			/* repeat until run out of data or line is filled */
-			ret = collect_line(textbuf, newline_off);
+	bool input_pending;
 
-			/* If filled up or OOM, rollback the remaining new
-			 * data. Instead we'll try to grab it next time we're
-			 * called */
-			if (textbuf->nr_lines >= textbuf->max_nr_lines || ret < 0)
-				textbuf->used_bytes = newdata_off;
+	spin_lock(&kutf_input_lock);
 
-			if (ret < 0)
-				goto finish;
+	input_pending = !list_empty(&context->userdata.input_head);
 
-			/* Fix up ppos etc in case we'll be ending the loop */
-			*ppos += ret - newdata_off;
-			bytes_processed += ret - newdata_off;
-			newdata_off = 0;
-		} else {
-			/* there's bytes left, but no new-line, so try to fill up next time */
-			*ppos += new_bytes_remain;
-			bytes_processed += new_bytes_remain;
-			break;
-		}
-	}
-
-finish_noerr:
-	ret = bytes_processed;
-finish:
-	textbuf->prev_pos = *ppos;
-out_unlock:
-	mutex_unlock(&textbuf->lock);
+	spin_unlock(&kutf_input_lock);
 
-	return ret;
+	return input_pending;
 }
 
-/**
- * kutf_helper_textbuf_produce() - 'data' file producer function for reading
- *                                 from a textbuf
- * @priv:		private pointer from a kutf_userdata_exchange, which
- *                      should be a pointer to a struct kutf_helper_textbuf to
- *                      read from
- * @userbuf:		the userspace buffer to write to
- * @userbuf_len:	size of the userspace buffer
- * @ppos:		the current position in the buffer
- *
- * This producer function is used as a read producer for the 'data' file,
- * allowing userspace to read from the 'data' file. It will write to the
- * userspace buffer @userbuf, taking lines from the textbuf pointed to by
- * @priv, separating each line with '\n'.
- *
- * If there is no data in the textbuf, then it will block until some appears -
- * for example, a kernel-side test calls kutf_helper_textbuf_enqueue(). Since
- * this is expected to be called in the context of a syscall, the call can only
- * be cancelled by sending an appropriate signal to the userspace process.
- *
- * The current position @ppos is advanced by the number of bytes successfully
- * written.
- *
- * Return:		the number of bytes written, or negative value on error
- */
-static ssize_t kutf_helper_textbuf_produce(void *priv, char  __user *userbuf,
-		size_t userbuf_len, loff_t *ppos)
+char *kutf_helper_input_dequeue(struct kutf_context *context, size_t *str_size)
 {
-	struct kutf_helper_textbuf *textbuf = priv;
-	loff_t pos_offset;
-	struct kutf_helper_textbuf_line *line = NULL;
-	int line_start_pos;
-	size_t bytes_processed = 0;
-	ssize_t ret;
-	int copy_length;
-
-	ret = mutex_lock_interruptible(&textbuf->lock);
-	if (ret)
-		return -ERESTARTSYS;
-
-	/* Validate input */
-	if (*ppos < 0) {
-		ret = -EINVAL;
-		goto finish;
-	}
-	if (!userbuf_len) {
-		ret = 0;
-		goto finish;
-	}
-
-	/* Seeking to before the beginning of the line will have the effect of
-	 * resetting the position to the start of the current data, since we've
-	 * already discarded previous data */
-	if (*ppos < textbuf->prev_line_pos)
-		textbuf->prev_line_pos = *ppos;
-
-	while (!line) {
-		int needs_wake = 0;
-
-		pos_offset = *ppos - textbuf->prev_line_pos;
-		line_start_pos = 0;
-
-		/* Find the line for the offset, emptying the textbuf as we go */
-		while (!list_empty(&textbuf->textbuf_list)) {
-			int line_end_pos;
+	struct kutf_userdata_line *line;
 
-			line = list_first_entry(&textbuf->textbuf_list, struct kutf_helper_textbuf_line, node);
+	spin_lock(&kutf_input_lock);
 
-			/* str_size used in line_end_pos because lines implicitly have
-			 * a '\n', but we count the '\0' string terminator as that */
-			line_end_pos = line_start_pos + line->str_size;
-
-			if (pos_offset < line_end_pos)
-				break;
-
-			line_start_pos += line->str_size;
-			/* Only discard a line when we're sure it's finished
-			 * with, to avoid awkward rollback conditions if we've
-			 * had to block */
-			list_del(&line->node);
-			--(textbuf->nr_lines);
-			line = NULL;
-			needs_wake = 1;
-		}
+	while (list_empty(&context->userdata.input_head)) {
+		int err;
 
-		/* Update the start of the line pos for next time we're called */
-		textbuf->prev_line_pos += line_start_pos;
+		kutf_set_waiting_for_input(context->result_set);
 
-		/* If space was freed up, wake waiters */
-		if (needs_wake)
-			wake_up(&textbuf->not_full_wq);
-;
-		if (!line) {
-			/* Only check before waiting, to ensure if the test
-			 * does the last enqueue and immediately finishes, then
-			 * we'll go back round the loop to receive the line
-			 * instead of just dying straight away */
-			if (textbuf->flags & KUTF_HELPER_TEXTBUF_FLAG_DYING) {
-				/* Indicate EOF rather than an error */
-				ret = 0;
-				goto finish;
-			}
+		spin_unlock(&kutf_input_lock);
 
-			/* No lines found, block for new ones
-			 * NOTE: should also handle O_NONBLOCK */
-			mutex_unlock(&textbuf->lock);
-			ret = wait_event_interruptible(textbuf->not_empty_wq,
-					(textbuf->nr_lines > 0 ||
-					(textbuf->flags & KUTF_HELPER_TEXTBUF_FLAG_DYING)));
+		err = wait_event_interruptible(context->userdata.input_waitq,
+				pending_input(context));
 
-			/* signals here are not restartable */
-			if (ret)
-				return ret;
-			ret = mutex_lock_interruptible(&textbuf->lock);
-			if (ret)
-				return ret;
-		}
+		if (err)
+			return ERR_PTR(-EINTR);
 
+		spin_lock(&kutf_input_lock);
 	}
 
-
-	/* Find offset within the line, guaranteed to be within line->str_size */
-	pos_offset -= line_start_pos;
-
-	while (userbuf_len && line) {
-		/* Copy at most to the end of string, excluding terminator */
-		copy_length = line->str_size - 1 - pos_offset;
-		if (copy_length > userbuf_len)
-			copy_length = userbuf_len;
-
-		if (copy_length) {
-			ret = copy_to_user(userbuf, &line->str[pos_offset], copy_length);
-			if (ret == copy_length) {
-				ret = -EFAULT;
-				goto finish;
-			}
-			copy_length -= ret;
-
-			userbuf += copy_length;
-			userbuf_len -= copy_length;
-			bytes_processed += copy_length;
-			*ppos += copy_length;
-			if (ret)
-				goto finish_noerr;
-		}
-
-		/* Add terminator if one was needed */
-		if (userbuf_len) {
-			copy_length = 1;
-			ret = copy_to_user(userbuf, "\n", copy_length);
-			if (ret == copy_length) {
-				ret = -EFAULT;
-				goto finish;
-			}
-			copy_length -= ret;
-
-			userbuf += copy_length;
-			userbuf_len -= copy_length;
-			bytes_processed += copy_length;
-			*ppos += copy_length;
-		} else {
-			/* string wasn't completely copied this time - try to
-			 * finish it next call */
-			break;
-		}
-
-		/* Line Completed - only now can safely delete it */
-		textbuf->prev_line_pos += line->str_size;
+	line = list_first_entry(&context->userdata.input_head,
+			struct kutf_userdata_line, node);
+	if (line->str) {
+		/*
+		 * Unless it is the end-of-input marker,
+		 * remove it from the list
+		 */
 		list_del(&line->node);
-		--(textbuf->nr_lines);
-		line = NULL;
-		/* Space freed up, wake up waiters */
-		wake_up(&textbuf->not_full_wq);
-
-		/* Pick the next line  */
-		if (!list_empty(&textbuf->textbuf_list)) {
-			line = list_first_entry(&textbuf->textbuf_list, struct kutf_helper_textbuf_line, node);
-			pos_offset = 0;
-		}
-		/* if no more lines, we've copied at least some bytes, so only
-		 * need to block on new lines the next time we're called */
 	}
 
-finish_noerr:
-	ret = bytes_processed;
-finish:
-	mutex_unlock(&textbuf->lock);
+	spin_unlock(&kutf_input_lock);
 
-	return ret;
+	if (str_size)
+		*str_size = line->size;
+	return line->str;
 }
 
-int kutf_helper_textbuf_wait_for_user(struct kutf_helper_textbuf *textbuf)
+int kutf_helper_input_enqueue(struct kutf_context *context,
+		const char __user *str, size_t size)
 {
-	int err;
-	unsigned long now;
-	unsigned long timeout_jiffies = msecs_to_jiffies(USERDATA_WAIT_TIMEOUT_MS);
-	unsigned long time_end;
-	int ret = 0;
-
-	/* Mutex locking using non-interruptible variants, since a signal to
-	 * the user process will generally have to wait until we finish the
-	 * test, because we can't restart the test. The exception is where
-	 * we're blocked on a waitq */
-	mutex_lock(&textbuf->lock);
+	struct kutf_userdata_line *line;
 
-	now = jiffies;
-	time_end = now + timeout_jiffies;
-
-	while (!textbuf->nr_user_clients && time_before_eq(now, time_end)) {
-		unsigned long time_to_wait = time_end - now;
-		/* No users yet, block or timeout */
-		mutex_unlock(&textbuf->lock);
-		/* Use interruptible here - in case we block for a long time
-		 * and want to kill the user process */
-		err = wait_event_interruptible_timeout(textbuf->user_opened_wq,
-				(textbuf->nr_user_clients > 0), time_to_wait);
-		/* Any error is not restartable due to how kutf runs tests */
-		if (err < 0)
-			return -EINTR;
-		mutex_lock(&textbuf->lock);
+	line = kutf_mempool_alloc(&context->fixture_pool,
+			sizeof(*line) + size + 1);
+	if (!line)
+		return -ENOMEM;
+	if (str) {
+		unsigned long bytes_not_copied;
 
-		now = jiffies;
+		line->size = size;
+		line->str = (void *)(line + 1);
+		bytes_not_copied = copy_from_user(line->str, str, size);
+		if (bytes_not_copied != 0)
+			return -EFAULT;
+		/* Zero terminate the string */
+		line->str[size] = '\0';
+	} else {
+		/* This is used to mark the end of input */
+		WARN_ON(size);
+		line->size = 0;
+		line->str = NULL;
 	}
-	if (!textbuf->nr_user_clients)
-		ret = -ETIMEDOUT;
-
-	mutex_unlock(&textbuf->lock);
-
-	return ret;
-}
-EXPORT_SYMBOL(kutf_helper_textbuf_wait_for_user);
-
-char *kutf_helper_textbuf_dequeue(struct kutf_helper_textbuf *textbuf,
-		int *str_size)
-{
-	struct kutf_helper_textbuf_line *line;
-	char *ret = NULL;
-
-	/* Mutex locking using non-interruptible variants, since a signal to
-	 * the user process will generally have to wait until we finish the
-	 * test, because we can't restart the test. The exception is where
-	 * we're blocked on a waitq */
-	mutex_lock(&textbuf->lock);
-
-	while (list_empty(&textbuf->textbuf_list)) {
-		int err;
 
-		if (!textbuf->nr_user_clients) {
-			/* No user-side clients - error */
-			goto out;
-		}
+	spin_lock(&kutf_input_lock);
 
-		/* No lines found, block for new ones from user-side consumer */
-		mutex_unlock(&textbuf->lock);
-		/* Use interruptible here - in case we block for a long time
-		 * and want to kill the user process */
-		err = wait_event_interruptible(textbuf->not_empty_wq,
-				(textbuf->nr_lines > 0 || !textbuf->nr_user_clients));
-		/* Any error is not restartable due to how kutf runs tests */
-		if (err)
-			return ERR_PTR(-EINTR);
-		mutex_lock(&textbuf->lock);
-	}
+	list_add_tail(&line->node, &context->userdata.input_head);
 
-	line = list_first_entry(&textbuf->textbuf_list, struct kutf_helper_textbuf_line, node);
-	list_del(&line->node);
-	--(textbuf->nr_lines);
-	/* Space freed up, wake up waiters */
-	wake_up(&textbuf->not_full_wq);
+	kutf_clear_waiting_for_input(context->result_set);
 
-	if (str_size)
-		*str_size = line->str_size;
+	spin_unlock(&kutf_input_lock);
 
-	ret = &line->str[0];
+	wake_up(&context->userdata.input_waitq);
 
-out:
-	mutex_unlock(&textbuf->lock);
-	return ret;
+	return 0;
 }
-EXPORT_SYMBOL(kutf_helper_textbuf_dequeue);
 
-int kutf_helper_textbuf_enqueue(struct kutf_helper_textbuf *textbuf,
-		char *enqueue_str, int buf_max_size)
+void kutf_helper_input_enqueue_end_of_data(struct kutf_context *context)
 {
-	struct kutf_helper_textbuf_line *textbuf_line;
-	int str_size = strnlen(enqueue_str, buf_max_size) + 1;
-	char *str_start;
-	int ret = 0;
-
-	/* Mutex locking using non-interruptible variants, since a signal to
-	 * the user process will generally have to wait until we finish the
-	 * test, because we can't restart the test. The exception is where
-	 * we're blocked on a waitq */
-	mutex_lock(&textbuf->lock);
-
-	if (str_size > textbuf->max_line_size)
-		str_size = textbuf->max_line_size;
-
-	while (textbuf->nr_lines >= textbuf->max_nr_lines) {
-		if (!textbuf->nr_user_clients) {
-			/* No user-side clients - error */
-			ret = -EBUSY;
-			goto out;
-		}
-
-		/* Block on user-side producer making space available */
-		mutex_unlock(&textbuf->lock);
-		/* Use interruptible here - in case we block for a long time
-		 * and want to kill the user process */
-		ret = wait_event_interruptible(textbuf->not_full_wq,
-				(textbuf->nr_lines < textbuf->max_nr_lines || !textbuf->nr_user_clients));
-		/* Any error is not restartable due to how kutf runs tests */
-		if (ret)
-			return -EINTR;
-		mutex_lock(&textbuf->lock);
-	}
-
-	/* String is stored immediately after the line */
-	textbuf_line = kutf_mempool_alloc(textbuf->mempool, str_size + sizeof(struct kutf_helper_textbuf_line));
-	if (!textbuf_line) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	str_start = &textbuf_line->str[0];
-
-	/* Copy in string */
-	strncpy(str_start, enqueue_str, str_size);
-	/* Enforce the '\0' termination */
-	str_start[str_size-1] = '\0';
-	textbuf_line->str_size = str_size;
-
-	/* Append to the textbuf */
-	list_add_tail(&textbuf_line->node, &textbuf->textbuf_list);
-	++(textbuf->nr_lines);
-
-	/* Wakeup anyone blocked on empty */
-	wake_up(&textbuf->not_empty_wq);
-
-out:
-	mutex_unlock(&textbuf->lock);
-	return ret;
+	kutf_helper_input_enqueue(context, NULL, 0);
 }
-EXPORT_SYMBOL(kutf_helper_textbuf_enqueue);
-
-
-struct kutf_userdata_ops kutf_helper_textbuf_userdata_ops = {
-	.open = kutf_helper_textbuf_open,
-	.release = kutf_helper_textbuf_release,
-	.notify_ended = kutf_helper_textbuf_notify_test_ended,
-	.consumer = kutf_helper_textbuf_consume,
-	.producer = kutf_helper_textbuf_produce,
-};
-EXPORT_SYMBOL(kutf_helper_textbuf_userdata_ops);
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/kutf_helpers_user.c b/drivers/gpu/arm/bifrost/tests/kutf/kutf_helpers_user.c
index cf3b00563c5f..108fa82d9b21 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/kutf_helpers_user.c
+++ b/drivers/gpu/arm/bifrost/tests/kutf/kutf_helpers_user.c
@@ -7,20 +7,27 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /* Kernel UTF test helpers that mirror those for kutf-userside */
 #include <kutf/kutf_helpers_user.h>
+#include <kutf/kutf_helpers.h>
 #include <kutf/kutf_utils.h>
 
 #include <linux/err.h>
 #include <linux/slab.h>
+#include <linux/export.h>
 
 const char *valtype_names[] = {
 	"INVALID",
@@ -48,7 +55,7 @@ static const char *get_val_type_name(enum kutf_helper_valtype valtype)
  *
  * - Has between 1 and KUTF_HELPER_MAX_VAL_NAME_LEN characters before the \0 terminator
  * - And, each char is in the character set [A-Z0-9_] */
-static int validate_val_name(char *val_str, int str_len)
+static int validate_val_name(const char *val_str, int str_len)
 {
 	int i = 0;
 
@@ -81,24 +88,44 @@ static int validate_val_name(char *val_str, int str_len)
  *
  * That is, before any '\\', '\n' or '"' characters. This is so we don't have
  * to escape the string */
-static int find_quoted_string_valid_len(char *str)
+static int find_quoted_string_valid_len(const char *str)
 {
 	char *ptr;
 	const char *check_chars = "\\\n\"";
 
 	ptr = strpbrk(str, check_chars);
 	if (ptr)
-		return ptr-str;
+		return (int)(ptr-str);
+
+	return (int)strlen(str);
+}
+
+static int kutf_helper_userdata_enqueue(struct kutf_context *context,
+		const char *str)
+{
+	char *str_copy;
+	size_t len;
+	int err;
+
+	len = strlen(str)+1;
+
+	str_copy = kutf_mempool_alloc(&context->fixture_pool, len);
+	if (!str_copy)
+		return -ENOMEM;
+
+	strcpy(str_copy, str);
 
-	return strlen(str);
+	err = kutf_add_result(context, KUTF_RESULT_USERDATA, str_copy);
+
+	return err;
 }
 
 #define MAX_U64_HEX_LEN 16
 /* (Name size) + ("=0x" size) + (64-bit hex value size) + (terminator) */
 #define NAMED_U64_VAL_BUF_SZ (KUTF_HELPER_MAX_VAL_NAME_LEN + 3 + MAX_U64_HEX_LEN + 1)
 
-int kutf_helper_textbuf_send_named_u64(struct kutf_context *context,
-		struct kutf_helper_textbuf *textbuf, char *val_name, u64 val)
+int kutf_helper_send_named_u64(struct kutf_context *context,
+		const char *val_name, u64 val)
 {
 	int ret = 1;
 	char msgbuf[NAMED_U64_VAL_BUF_SZ];
@@ -117,9 +144,8 @@ int kutf_helper_textbuf_send_named_u64(struct kutf_context *context,
 				val_name, NAMED_U64_VAL_BUF_SZ, ret);
 		goto out_err;
 	}
-	msgbuf[NAMED_U64_VAL_BUF_SZ-1] = '\0';
 
-	ret = kutf_helper_textbuf_enqueue(textbuf, msgbuf, NAMED_U64_VAL_BUF_SZ);
+	ret = kutf_helper_userdata_enqueue(context, msgbuf);
 	if (ret) {
 		errmsg = kutf_dsprintf(&context->fixture_pool,
 				"Failed to send u64 value named '%s': send returned %d",
@@ -132,33 +158,31 @@ int kutf_helper_textbuf_send_named_u64(struct kutf_context *context,
 	kutf_test_fail(context, errmsg);
 	return ret;
 }
-EXPORT_SYMBOL(kutf_helper_textbuf_send_named_u64);
+EXPORT_SYMBOL(kutf_helper_send_named_u64);
 
 #define NAMED_VALUE_SEP "="
 #define NAMED_STR_START_DELIM NAMED_VALUE_SEP "\""
 #define NAMED_STR_END_DELIM "\""
 
-int kutf_helper_textbuf_max_str_len_for_kern(char *val_name,
+int kutf_helper_max_str_len_for_kern(const char *val_name,
 		int kern_buf_sz)
 {
-	int val_name_len = strlen(val_name);
-	int start_delim_len = strlen(NAMED_STR_START_DELIM);
-	int max_msg_len = kern_buf_sz - 1;
+	const int val_name_len = strlen(val_name);
+	const int start_delim_len = strlen(NAMED_STR_START_DELIM);
+	const int end_delim_len = strlen(NAMED_STR_END_DELIM);
+	int max_msg_len = kern_buf_sz;
 	int max_str_len;
 
-	/* We do not include the end delimiter. Providing there is a line
-	 * ending character when sending the message, the end delimiter can be
-	 * truncated off safely to allow proper NAME="value" reception when
-	 * value's length is too long */
-	max_str_len = max_msg_len - val_name_len - start_delim_len;
+	max_str_len = max_msg_len - val_name_len - start_delim_len -
+		end_delim_len;
 
 	return max_str_len;
 }
-EXPORT_SYMBOL(kutf_helper_textbuf_max_str_len_for_kern);
+EXPORT_SYMBOL(kutf_helper_max_str_len_for_kern);
 
-int kutf_helper_textbuf_send_named_str(struct kutf_context *context,
-		struct kutf_helper_textbuf *textbuf, char *val_name,
-		char *val_str)
+int kutf_helper_send_named_str(struct kutf_context *context,
+		const char *val_name,
+		const char *val_str)
 {
 	int val_str_len;
 	int str_buf_sz;
@@ -215,7 +239,7 @@ int kutf_helper_textbuf_send_named_str(struct kutf_context *context,
 	/* Terminator */
 	*copy_ptr = '\0';
 
-	ret = kutf_helper_textbuf_enqueue(textbuf, str_buf, str_buf_sz);
+	ret = kutf_helper_userdata_enqueue(context, str_buf);
 
 	if (ret) {
 		errmsg = kutf_dsprintf(&context->fixture_pool,
@@ -232,12 +256,13 @@ int kutf_helper_textbuf_send_named_str(struct kutf_context *context,
 	kfree(str_buf);
 	return ret;
 }
-EXPORT_SYMBOL(kutf_helper_textbuf_send_named_str);
+EXPORT_SYMBOL(kutf_helper_send_named_str);
 
-int kutf_helper_textbuf_receive_named_val(struct kutf_helper_named_val *named_val,
-		struct kutf_helper_textbuf *textbuf)
+int kutf_helper_receive_named_val(
+		struct kutf_context *context,
+		struct kutf_helper_named_val *named_val)
 {
-	int recv_sz;
+	size_t recv_sz;
 	char *recv_str;
 	char *search_ptr;
 	char *name_str = NULL;
@@ -246,15 +271,13 @@ int kutf_helper_textbuf_receive_named_val(struct kutf_helper_named_val *named_va
 	enum kutf_helper_valtype type = KUTF_HELPER_VALTYPE_INVALID;
 	char *strval = NULL;
 	u64 u64val = 0;
-	int orig_recv_sz;
 	int err = KUTF_HELPER_ERR_INVALID_VALUE;
 
-	recv_str = kutf_helper_textbuf_dequeue(textbuf, &recv_sz);
+	recv_str = kutf_helper_input_dequeue(context, &recv_sz);
 	if (!recv_str)
 		return -EBUSY;
 	else if (IS_ERR(recv_str))
 		return PTR_ERR(recv_str);
-	orig_recv_sz = recv_sz;
 
 	/* Find the '=', grab the name and validate it */
 	search_ptr = strnchr(recv_str, recv_sz, NAMED_VALUE_SEP[0]);
@@ -271,7 +294,8 @@ int kutf_helper_textbuf_receive_named_val(struct kutf_helper_named_val *named_va
 		}
 	}
 	if (!name_str) {
-		pr_err("Invalid name part for recevied string '%s'\n", recv_str);
+		pr_err("Invalid name part for received string '%s'\n",
+				recv_str);
 		return KUTF_HELPER_ERR_INVALID_NAME;
 	}
 
@@ -299,24 +323,6 @@ int kutf_helper_textbuf_receive_named_val(struct kutf_helper_named_val *named_va
 				pr_err("String value contains invalid characters in rest of received string '%s'\n", recv_str);
 				err = KUTF_HELPER_ERR_CHARS_AFTER_VAL;
 			}
-		} else if (orig_recv_sz == textbuf->max_line_size) {
-			/* No end-delimiter found, but the line is at
-			 * the max line size. Assume that before
-			 * truncation the line had a closing delimiter
-			 * anyway */
-			strval_len = strlen(recv_str);
-			/* Validate the string to ensure it contains no quotes */
-			if (strval_len == find_quoted_string_valid_len(recv_str)) {
-				strval = recv_str;
-
-				/* Move to the end of the string */
-				recv_str += strval_len;
-				recv_sz -= strval_len;
-				type = KUTF_HELPER_VALTYPE_STR;
-			} else {
-				pr_err("String value contains invalid characters in rest of received string '%s'\n", recv_str);
-				err = KUTF_HELPER_ERR_CHARS_AFTER_VAL;
-			}
 		} else {
 			pr_err("End of string delimiter not found in rest of received string '%s'\n", recv_str);
 			err = KUTF_HELPER_ERR_NO_END_DELIMITER;
@@ -357,8 +363,8 @@ int kutf_helper_textbuf_receive_named_val(struct kutf_helper_named_val *named_va
 		named_val->u.val_str = strval;
 		break;
 	default:
-		pr_err("Unreachable, fix textbuf_receive_named_val\n");
-		/* Coding error, report as though 'data' file failed */
+		pr_err("Unreachable, fix kutf_helper_receive_named_val\n");
+		/* Coding error, report as though 'run' file failed */
 		return -EINVAL;
 	}
 
@@ -367,16 +373,18 @@ int kutf_helper_textbuf_receive_named_val(struct kutf_helper_named_val *named_va
 
 	return KUTF_HELPER_ERR_NONE;
 }
-EXPORT_SYMBOL(kutf_helper_textbuf_receive_named_val);
+EXPORT_SYMBOL(kutf_helper_receive_named_val);
 
 #define DUMMY_MSG "<placeholder due to test fail>"
-int kutf_helper_textbuf_receive_check_val(struct kutf_helper_named_val *named_val,
-		struct kutf_context *context, struct kutf_helper_textbuf *textbuf,
-		char *expect_val_name, enum kutf_helper_valtype expect_val_type)
+int kutf_helper_receive_check_val(
+		struct kutf_helper_named_val *named_val,
+		struct kutf_context *context,
+		const char *expect_val_name,
+		enum kutf_helper_valtype expect_val_type)
 {
 	int err;
 
-	err = kutf_helper_textbuf_receive_named_val(named_val, textbuf);
+	err = kutf_helper_receive_named_val(context, named_val);
 	if (err < 0) {
 		const char *msg = kutf_dsprintf(&context->fixture_pool,
 				"Failed to receive value named '%s'",
@@ -438,7 +446,7 @@ int kutf_helper_textbuf_receive_check_val(struct kutf_helper_named_val *named_va
 	/* But at least allow the caller to continue in the test with failures */
 	return 0;
 }
-EXPORT_SYMBOL(kutf_helper_textbuf_receive_check_val);
+EXPORT_SYMBOL(kutf_helper_receive_check_val);
 
 void kutf_helper_output_named_val(struct kutf_helper_named_val *named_val)
 {
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/kutf_mem.c b/drivers/gpu/arm/bifrost/tests/kutf/kutf_mem.c
index a75e15fde05f..fd98beaeb84a 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/kutf_mem.c
+++ b/drivers/gpu/arm/bifrost/tests/kutf/kutf_mem.c
@@ -7,18 +7,24 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /* Kernel UTF memory management functions */
 
 #include <linux/list.h>
 #include <linux/slab.h>
+#include <linux/export.h>
 
 #include <kutf/kutf_mem.h>
 
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/kutf_resultset.c b/drivers/gpu/arm/bifrost/tests/kutf/kutf_resultset.c
index 5bd04969fd55..94ecfa4421e1 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/kutf_resultset.c
+++ b/drivers/gpu/arm/bifrost/tests/kutf/kutf_resultset.c
@@ -7,29 +7,33 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /* Kernel UTF result management functions */
 
 #include <linux/list.h>
 #include <linux/slab.h>
 #include <linux/printk.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/err.h>
 
+#include <kutf/kutf_suite.h>
 #include <kutf/kutf_resultset.h>
 
-/**
- * struct kutf_result_set - Represents a set of results.
- * @results:	Pointer to the linked list where the results are stored.
- */
-struct kutf_result_set {
-	struct list_head          results;
-};
+/* Lock to protect all result structures */
+static DEFINE_SPINLOCK(kutf_result_lock);
 
 struct kutf_result_set *kutf_create_result_set(void)
 {
@@ -42,6 +46,8 @@ struct kutf_result_set *kutf_create_result_set(void)
 	}
 
 	INIT_LIST_HEAD(&set->results);
+	init_waitqueue_head(&set->waitq);
+	set->flags = 0;
 
 	return set;
 
@@ -49,11 +55,12 @@ struct kutf_result_set *kutf_create_result_set(void)
 	return NULL;
 }
 
-void kutf_add_result(struct kutf_mempool *mempool,
-		struct kutf_result_set *set,
+int kutf_add_result(struct kutf_context *context,
 		enum kutf_result_status status,
 		const char *message)
 {
+	struct kutf_mempool *mempool = &context->fixture_pool;
+	struct kutf_result_set *set = context->result_set;
 	/* Create the new result */
 	struct kutf_result *new_result;
 
@@ -62,14 +69,22 @@ void kutf_add_result(struct kutf_mempool *mempool,
 	new_result = kutf_mempool_alloc(mempool, sizeof(*new_result));
 	if (!new_result) {
 		pr_err("Result allocation failed\n");
-		return;
+		return -ENOMEM;
 	}
 
 	INIT_LIST_HEAD(&new_result->node);
 	new_result->status = status;
 	new_result->message = message;
 
+	spin_lock(&kutf_result_lock);
+
 	list_add_tail(&new_result->node, &set->results);
+
+	spin_unlock(&kutf_result_lock);
+
+	wake_up(&set->waitq);
+
+	return 0;
 }
 
 void kutf_destroy_result_set(struct kutf_result_set *set)
@@ -80,16 +95,70 @@ void kutf_destroy_result_set(struct kutf_result_set *set)
 	kfree(set);
 }
 
+static bool kutf_has_result(struct kutf_result_set *set)
+{
+	bool has_result;
+
+	spin_lock(&kutf_result_lock);
+	if (set->flags & KUTF_RESULT_SET_WAITING_FOR_INPUT)
+		/* Pretend there are results if waiting for input */
+		has_result = true;
+	else
+		has_result = !list_empty(&set->results);
+	spin_unlock(&kutf_result_lock);
+
+	return has_result;
+}
+
 struct kutf_result *kutf_remove_result(struct kutf_result_set *set)
 {
-	if (!list_empty(&set->results)) {
-		struct kutf_result *ret;
+	struct kutf_result *result = NULL;
+	int ret;
+
+	do {
+		ret = wait_event_interruptible(set->waitq,
+				kutf_has_result(set));
+
+		if (ret)
+			return ERR_PTR(ret);
+
+		spin_lock(&kutf_result_lock);
+
+		if (!list_empty(&set->results)) {
+			result = list_first_entry(&set->results,
+					struct kutf_result,
+					node);
+			list_del(&result->node);
+		} else if (set->flags & KUTF_RESULT_SET_WAITING_FOR_INPUT) {
+			/* Return a fake result */
+			static struct kutf_result waiting = {
+				.status = KUTF_RESULT_USERDATA_WAIT
+			};
+			result = &waiting;
+		}
+		/* If result == NULL then there was a race with the event
+		 * being removed between the check in kutf_has_result and
+		 * the lock being obtained. In this case we retry
+		 */
+
+		spin_unlock(&kutf_result_lock);
+	} while (result == NULL);
+
+	return result;
+}
 
-		ret = list_first_entry(&set->results, struct kutf_result, node);
-		list_del(&ret->node);
-		return ret;
-	}
+void kutf_set_waiting_for_input(struct kutf_result_set *set)
+{
+	spin_lock(&kutf_result_lock);
+	set->flags |= KUTF_RESULT_SET_WAITING_FOR_INPUT;
+	spin_unlock(&kutf_result_lock);
 
-	return NULL;
+	wake_up(&set->waitq);
 }
 
+void kutf_clear_waiting_for_input(struct kutf_result_set *set)
+{
+	spin_lock(&kutf_result_lock);
+	set->flags &= ~KUTF_RESULT_SET_WAITING_FOR_INPUT;
+	spin_unlock(&kutf_result_lock);
+}
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/kutf_suite.c b/drivers/gpu/arm/bifrost/tests/kutf/kutf_suite.c
index ad30cc86a3b0..1c350bb339fb 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/kutf_suite.c
+++ b/drivers/gpu/arm/bifrost/tests/kutf/kutf_suite.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /* Kernel UTF suite, test and fixture management including user to kernel
  * interaction */
 
@@ -27,12 +32,14 @@
 #include <linux/fs.h>
 #include <linux/version.h>
 #include <linux/atomic.h>
+#include <linux/sched.h>
 
 #include <generated/autoconf.h>
 
 #include <kutf/kutf_suite.h>
 #include <kutf/kutf_resultset.h>
 #include <kutf/kutf_utils.h>
+#include <kutf/kutf_helpers.h>
 
 #if defined(CONFIG_DEBUG_FS)
 
@@ -61,8 +68,6 @@ struct kutf_application {
  * @variant_list:	List head to store all the variants which can run on
  *                      this function
  * @dir:		debugfs directory for this test function
- * @userdata_ops:	Callbacks to use for sending and receiving data to
- *                      userspace.
  */
 struct kutf_test_function {
 	struct kutf_suite  *suite;
@@ -73,7 +78,6 @@ struct kutf_test_function {
 	struct list_head   node;
 	struct list_head   variant_list;
 	struct dentry      *dir;
-	struct kutf_userdata_ops userdata_ops;
 };
 
 /**
@@ -83,17 +87,16 @@ struct kutf_test_function {
  * @fixture_index:	Index of this fixture
  * @node:		List node for variant_list
  * @dir:		debugfs directory for this test fixture
- * @nr_running:		Current count of user-clients running this fixture
  */
 struct kutf_test_fixture {
 	struct kutf_test_function *test_func;
 	unsigned int              fixture_index;
 	struct list_head          node;
 	struct dentry             *dir;
-	atomic_t                  nr_running;
 };
 
-struct dentry *base_dir;
+static struct dentry *base_dir;
+static struct workqueue_struct *kutf_workq;
 
 /**
  * struct kutf_convert_table - Structure which keeps test results
@@ -183,26 +186,6 @@ static void kutf_set_result(struct kutf_context *context,
 static void kutf_set_expected_result(struct kutf_context *context,
 		enum kutf_result_status expected_status);
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
-/* Pre 3.4.0 kernels don't have the simple_open helper */
-
-/**
- * simple_open() - Helper for file opening which stores the inode private data
- *                 into the file private data
- * @inode:	File entry representation
- * @file:	A specific opening of the file
- *
- * Return: always 0; if inode private data do not exist, the file will not
- *         be assigned private data
- */
-static int simple_open(struct inode *inode, struct file *file)
-{
-	if (inode->i_private)
-		file->private_data = inode->i_private;
-	return 0;
-}
-#endif
-
 /**
  * kutf_result_to_string() - Converts a KUTF result into a string
  * @result_str:      Output result string
@@ -251,263 +234,6 @@ static const struct file_operations kutf_debugfs_const_string_ops = {
 	.llseek  = default_llseek,
 };
 
-/**
- * kutf_debugfs_data_open() Debugfs open callback for the "data" entry.
- * @inode:	inode of the opened file
- * @file:	Opened file to read from
- *
- * This function notifies the userdata callbacks that the userdata file has
- * been opened, for tracking purposes.
- *
- * It is called on both the context's userdata_consumer_priv and
- * userdata_producer_priv.
- *
- * This takes a refcount on the kutf_context
- *
- * Return: 0 on success
- */
-static int kutf_debugfs_data_open(struct inode *inode, struct file *file)
-{
-	struct kutf_context *test_context = inode->i_private;
-	struct kutf_test_fixture *test_fix = test_context->test_fix;
-	struct kutf_test_function *test_func = test_fix->test_func;
-	int err;
-
-	simple_open(inode, file);
-
-	/* This is not an error */
-	if (!test_func->userdata_ops.open)
-		goto out_no_ops;
-
-	/* This is safe here - the 'data' file is only openable whilst the
-	 * initial refcount is still present, and the initial refcount is only
-	 * dropped strictly after the 'data' file is removed */
-	kutf_context_get(test_context);
-
-	if (test_context->userdata_consumer_priv) {
-		err = test_func->userdata_ops.open(test_context->userdata_consumer_priv);
-		if (err)
-			goto out_consumer_fail;
-	}
-
-	if (test_context->userdata_producer_priv) {
-		err = test_func->userdata_ops.open(test_context->userdata_producer_priv);
-		if (err)
-			goto out_producer_fail;
-	}
-
-out_no_ops:
-	return 0;
-
-out_producer_fail:
-	if (test_func->userdata_ops.release && test_context->userdata_consumer_priv)
-		test_func->userdata_ops.release(test_context->userdata_consumer_priv);
-out_consumer_fail:
-	kutf_context_put(test_context);
-
-	return err;
-}
-
-
-/**
- * kutf_debugfs_data_read() Debugfs read callback for the "data" entry.
- * @file:	Opened file to read from
- * @buf:	User buffer to write the data into
- * @len:	Amount of data to read
- * @ppos:	Offset into file to read from
- *
- * This function allows user and kernel to exchange extra data necessary for
- * the test fixture.
- *
- * The data is read from the first struct kutf_context running the fixture
- *
- * Return: Number of bytes read
- */
-static ssize_t kutf_debugfs_data_read(struct file *file, char __user *buf,
-		size_t len, loff_t *ppos)
-{
-	struct kutf_context *test_context = file->private_data;
-	struct kutf_test_fixture *test_fix = test_context->test_fix;
-	struct kutf_test_function *test_func = test_fix->test_func;
-	ssize_t (*producer)(void *private, char  __user *userbuf,
-			size_t userbuf_len, loff_t *ppos);
-	ssize_t count;
-
-	producer = test_func->userdata_ops.producer;
-	/* Can only read if there's a producer callback */
-	if (!producer)
-		return -ENODEV;
-
-	count = producer(test_context->userdata_producer_priv, buf, len, ppos);
-
-	return count;
-}
-
-/**
- * kutf_debugfs_data_write() Debugfs write callback for the "data" entry.
- * @file:	Opened file to write to
- * @buf:	User buffer to read the data from
- * @len:	Amount of data to write
- * @ppos:	Offset into file to write to
- *
- * This function allows user and kernel to exchange extra data necessary for
- * the test fixture.
- *
- * The data is added to the first struct kutf_context running the fixture
- *
- * Return: Number of bytes written
- */
-static ssize_t kutf_debugfs_data_write(struct file *file,
-		const char __user *buf, size_t len, loff_t *ppos)
-{
-	struct kutf_context *test_context = file->private_data;
-	struct kutf_test_fixture *test_fix = test_context->test_fix;
-	struct kutf_test_function *test_func = test_fix->test_func;
-	ssize_t (*consumer)(void *private, const char  __user *userbuf,
-			size_t userbuf_len, loff_t *ppos);
-	ssize_t count;
-
-	consumer = test_func->userdata_ops.consumer;
-	/* Can only write if there's a consumer callback */
-	if (!consumer)
-		return -ENODEV;
-
-	count = consumer(test_context->userdata_consumer_priv, buf, len, ppos);
-
-	return count;
-}
-
-
-/**
- * kutf_debugfs_data_release() - Debugfs release callback for the "data" entry.
- * @inode:	File entry representation
- * @file:	A specific opening of the file
- *
- * This function notifies the userdata callbacks that the userdata file has
- * been closed, for tracking purposes.
- *
- * It is called on both the context's userdata_consumer_priv and
- * userdata_producer_priv.
- *
- * It also drops the refcount on the kutf_context that was taken during
- * kutf_debugfs_data_open()
- */
-static int kutf_debugfs_data_release(struct inode *inode, struct file *file)
-{
-	struct kutf_context *test_context = file->private_data;
-	struct kutf_test_fixture *test_fix = test_context->test_fix;
-	struct kutf_test_function *test_func = test_fix->test_func;
-
-	if (!test_func->userdata_ops.release)
-		return 0;
-
-	if (test_context->userdata_consumer_priv)
-		test_func->userdata_ops.release(test_context->userdata_consumer_priv);
-	if (test_context->userdata_producer_priv)
-		test_func->userdata_ops.release(test_context->userdata_producer_priv);
-
-	kutf_context_put(test_context);
-
-	return 0;
-}
-
-
-static const struct file_operations kutf_debugfs_data_ops = {
-	.owner = THIS_MODULE,
-	.open = kutf_debugfs_data_open,
-	.read = kutf_debugfs_data_read,
-	.write = kutf_debugfs_data_write,
-	.release = kutf_debugfs_data_release,
-	.llseek  = default_llseek,
-};
-
-/**
- * userdata_init() - Initialize userspace data exchange for a test, if
- *                   specified by that test
- * @test_context:	Test context
- *
- * Note that this allows new refcounts to be made on test_context by userspace
- * threads opening the 'data' file.
- *
- * Return: 0 on success, negative value corresponding to error code in failure
- *         and kutf result will be set appropriately to indicate the error
- */
-static int userdata_init(struct kutf_context *test_context)
-{
-	struct kutf_test_fixture *test_fix = test_context->test_fix;
-	struct kutf_test_function *test_func = test_fix->test_func;
-	int err = 0;
-	struct dentry *userdata_dentry;
-
-	/* Valid to have neither a producer or consumer, which is the case for
-	 * tests not requiring usersdata */
-	if ((!test_func->userdata_ops.consumer) && (!test_func->userdata_ops.producer))
-		return err;
-
-	if (test_func->userdata_ops.consumer && !test_context->userdata_consumer_priv) {
-		kutf_test_fatal(test_context,
-				"incorrect test setup - userdata consumer provided without private data");
-		return -EFAULT;
-	}
-
-	if (test_func->userdata_ops.producer && !test_context->userdata_producer_priv) {
-		kutf_test_fatal(test_context,
-				"incorrect test setup - userdata producer provided without private data");
-		return -EFAULT;
-	}
-
-	userdata_dentry = debugfs_create_file("data", S_IROTH, test_fix->dir,
-			test_context, &kutf_debugfs_data_ops);
-
-	if (!userdata_dentry) {
-		pr_err("Failed to create debugfs file \"data\" when running fixture\n");
-		/* Not using Fatal (which stops other tests running),
-		 * nor Abort (which indicates teardown should not be done) */
-		kutf_test_fail(test_context,
-				"failed to create 'data' file for userside data exchange");
-
-		/* Error code is discarded by caller, but consistent with other
-		 * debugfs_create_file failures */
-		err = -EEXIST;
-	} else {
-		test_context->userdata_dentry = userdata_dentry;
-	}
-
-
-	return err;
-}
-
-/**
- * userdata_term() - Terminate userspace data exchange for a test, if specified
- *                   by that test
- * @test_context:	Test context
- *
- * Note This also prevents new refcounts being made on @test_context by userspace
- * threads opening the 'data' file for this test. Any existing open file descriptors
- * to the 'data' file will still be safe to use by userspace.
- */
-static void userdata_term(struct kutf_context *test_context)
-{
-	struct kutf_test_fixture *test_fix = test_context->test_fix;
-	struct kutf_test_function *test_func = test_fix->test_func;
-	void (*notify_ended)(void *priv) = test_func->userdata_ops.notify_ended;
-
-	/* debugfs_remove() is safe when parameter is error or NULL */
-	debugfs_remove(test_context->userdata_dentry);
-
-	/* debugfs_remove() doesn't kill any currently open file descriptors on
-	 * this file, and such fds are still safe to use providing test_context
-	 * is properly refcounted */
-
-	if (notify_ended) {
-		if (test_context->userdata_consumer_priv)
-			notify_ended(test_context->userdata_consumer_priv);
-		if (test_context->userdata_producer_priv)
-			notify_ended(test_context->userdata_producer_priv);
-	}
-
-}
-
 /**
  * kutf_add_explicit_result() - Check if an explicit result needs to be added
  * @context:	KUTF test context
@@ -563,75 +289,75 @@ static void kutf_add_explicit_result(struct kutf_context *context)
 	}
 }
 
+static void kutf_run_test(struct work_struct *data)
+{
+	struct kutf_context *test_context = container_of(data,
+			struct kutf_context, work);
+	struct kutf_suite *suite = test_context->suite;
+	struct kutf_test_function *test_func;
+
+	test_func = test_context->test_fix->test_func;
+
+	/*
+	 * Call the create fixture function if required before the
+	 * fixture is run
+	 */
+	if (suite->create_fixture)
+		test_context->fixture = suite->create_fixture(test_context);
+
+	/* Only run the test if the fixture was created (if required) */
+	if ((suite->create_fixture && test_context->fixture) ||
+			(!suite->create_fixture)) {
+		/* Run this fixture */
+		test_func->execute(test_context);
+
+		if (suite->remove_fixture)
+			suite->remove_fixture(test_context);
+
+		kutf_add_explicit_result(test_context);
+	}
+
+	kutf_add_result(test_context, KUTF_RESULT_TEST_FINISHED, NULL);
+
+	kutf_context_put(test_context);
+}
+
 /**
  * kutf_debugfs_run_open() Debugfs open callback for the "run" entry.
  * @inode:	inode of the opened file
  * @file:	Opened file to read from
  *
- * This function retrieves the test fixture data that is associated with the
- * opened file and works back to get the test, suite and application so
- * it can then run the test that is associated with the file entry.
+ * This function creates a KUTF context and queues it onto a workqueue to be
+ * run asynchronously. The resulting file descriptor can be used to communicate
+ * userdata to the test and to read back the results of the test execution.
  *
  * Return: 0 on success
  */
 static int kutf_debugfs_run_open(struct inode *inode, struct file *file)
 {
 	struct kutf_test_fixture *test_fix = inode->i_private;
-	struct kutf_test_function *test_func = test_fix->test_func;
-	struct kutf_suite *suite = test_func->suite;
 	struct kutf_context *test_context;
 	int err = 0;
 
-	/* For the moment, only one user-client should be attempting to run
-	 * this at a time. This simplifies how we lookup the kutf_context when
-	 * using the 'data' file.
-	 * Removing this restriction would require a rewrite of the mechanism
-	 * of the 'data' file to pass data in, perhaps 'data' created here and
-	 * based upon userspace thread's pid */
-	if (atomic_inc_return(&test_fix->nr_running) != 1) {
-		err = -EBUSY;
-		goto finish;
-	}
-
 	test_context = kutf_create_context(test_fix);
 	if (!test_context) {
-		err = -ENODEV;
+		err = -ENOMEM;
 		goto finish;
 	}
 
 	file->private_data = test_context;
 
-	/*
-	 *  Call the create fixture function if required before the
-	 * fixture is run
-	 */
-	if (suite->create_fixture)
-		test_context->fixture = suite->create_fixture(test_context);
-
-	/* Only run the test if the fixture was created (if required) */
-	if ((suite->create_fixture && test_context->fixture) ||
-			(!suite->create_fixture)) {
-		int late_err;
-		/* Setup any userdata exchange */
-		late_err = userdata_init(test_context);
-
-		if (!late_err)
-			/* Run this fixture */
-			test_func->execute(test_context);
-
-		userdata_term(test_context);
-
-		if (suite->remove_fixture)
-			suite->remove_fixture(test_context);
+	/* This reference is release by the kutf_run_test */
+	kutf_context_get(test_context);
 
-		kutf_add_explicit_result(test_context);
-	}
+	queue_work(kutf_workq, &test_context->work);
 
 finish:
-	atomic_dec(&test_fix->nr_running);
 	return err;
 }
 
+#define USERDATA_WARNING_MESSAGE "WARNING: This test requires userdata\n"
+
 /**
  * kutf_debugfs_run_read() - Debugfs read callback for the "run" entry.
  * @file:	Opened file to read from
@@ -639,8 +365,14 @@ static int kutf_debugfs_run_open(struct inode *inode, struct file *file)
  * @len:	Amount of data to read
  * @ppos:	Offset into file to read from
  *
- * This function emits the results which where logged during the opening of
- * the file kutf_debugfs_run_open.
+ * This function emits the results of the test, blocking until they are
+ * available.
+ *
+ * If the test involves user data then this will also return user data records
+ * to user space. If the test is waiting for user data then this function will
+ * output a message (to make the likes of 'cat' display it), followed by
+ * returning 0 to mark the end of file.
+ *
  * Results will be emitted one at a time, once all the results have been read
  * 0 will be returned to indicate there is no more data.
  *
@@ -653,68 +385,153 @@ static ssize_t kutf_debugfs_run_read(struct file *file, char __user *buf,
 	struct kutf_result *res;
 	unsigned long bytes_not_copied;
 	ssize_t bytes_copied = 0;
+	char *kutf_str_ptr = NULL;
+	size_t kutf_str_len = 0;
+	size_t message_len = 0;
+	char separator = ':';
+	char terminator = '\n';
 
-	/* Note: This code assumes a result is read completely */
 	res = kutf_remove_result(test_context->result_set);
-	if (res) {
-		char *kutf_str_ptr = NULL;
-		unsigned int kutf_str_len = 0;
-		unsigned int message_len = 0;
-		char separator = ':';
-		char terminator = '\n';
-
-		kutf_result_to_string(&kutf_str_ptr, res->status);
-		if (kutf_str_ptr)
-			kutf_str_len = strlen(kutf_str_ptr);
-
-		if (res->message)
-			message_len = strlen(res->message);
-
-		if ((kutf_str_len + 1 + message_len + 1) > len) {
-			pr_err("Not enough space in user buffer for a single result");
+
+	if (IS_ERR(res))
+		return PTR_ERR(res);
+
+	/*
+	 * Handle 'fake' results - these results are converted to another
+	 * form before being returned from the kernel
+	 */
+	switch (res->status) {
+	case KUTF_RESULT_TEST_FINISHED:
+		return 0;
+	case KUTF_RESULT_USERDATA_WAIT:
+		if (test_context->userdata.flags &
+				KUTF_USERDATA_WARNING_OUTPUT) {
+			/*
+			 * Warning message already output,
+			 * signal end-of-file
+			 */
 			return 0;
 		}
 
-		/* First copy the result string */
-		if (kutf_str_ptr) {
-			bytes_not_copied = copy_to_user(&buf[0], kutf_str_ptr,
-							kutf_str_len);
-			bytes_copied += kutf_str_len - bytes_not_copied;
-			if (bytes_not_copied)
-				goto exit;
+		message_len = sizeof(USERDATA_WARNING_MESSAGE)-1;
+		if (message_len > len)
+			message_len = len;
+
+		bytes_not_copied = copy_to_user(buf,
+				USERDATA_WARNING_MESSAGE,
+				message_len);
+		if (bytes_not_copied != 0)
+			return -EFAULT;
+		test_context->userdata.flags |= KUTF_USERDATA_WARNING_OUTPUT;
+		return message_len;
+	case KUTF_RESULT_USERDATA:
+		message_len = strlen(res->message);
+		if (message_len > len-1) {
+			message_len = len-1;
+			pr_warn("User data truncated, read not long enough\n");
+		}
+		bytes_not_copied = copy_to_user(buf, res->message,
+				message_len);
+		if (bytes_not_copied != 0) {
+			pr_warn("Failed to copy data to user space buffer\n");
+			return -EFAULT;
+		}
+		/* Finally the terminator */
+		bytes_not_copied = copy_to_user(&buf[message_len],
+				&terminator, 1);
+		if (bytes_not_copied != 0) {
+			pr_warn("Failed to copy data to user space buffer\n");
+			return -EFAULT;
 		}
+		return message_len+1;
+	default:
+		/* Fall through - this is a test result */
+		break;
+	}
 
-		/* Then the separator */
-		bytes_not_copied = copy_to_user(&buf[bytes_copied],
-						&separator, 1);
-		bytes_copied += 1 - bytes_not_copied;
+	/* Note: This code assumes a result is read completely */
+	kutf_result_to_string(&kutf_str_ptr, res->status);
+	if (kutf_str_ptr)
+		kutf_str_len = strlen(kutf_str_ptr);
+
+	if (res->message)
+		message_len = strlen(res->message);
+
+	if ((kutf_str_len + 1 + message_len + 1) > len) {
+		pr_err("Not enough space in user buffer for a single result");
+		return 0;
+	}
+
+	/* First copy the result string */
+	if (kutf_str_ptr) {
+		bytes_not_copied = copy_to_user(&buf[0], kutf_str_ptr,
+						kutf_str_len);
+		bytes_copied += kutf_str_len - bytes_not_copied;
 		if (bytes_not_copied)
 			goto exit;
+	}
 
-		/* Finally Next copy the result string */
-		if (res->message) {
-			bytes_not_copied = copy_to_user(&buf[bytes_copied],
-							res->message, message_len);
-			bytes_copied += message_len - bytes_not_copied;
-			if (bytes_not_copied)
-				goto exit;
-		}
+	/* Then the separator */
+	bytes_not_copied = copy_to_user(&buf[bytes_copied],
+					&separator, 1);
+	bytes_copied += 1 - bytes_not_copied;
+	if (bytes_not_copied)
+		goto exit;
 
-		/* Finally the terminator */
+	/* Finally Next copy the result string */
+	if (res->message) {
 		bytes_not_copied = copy_to_user(&buf[bytes_copied],
-						&terminator, 1);
-		bytes_copied += 1 - bytes_not_copied;
+						res->message, message_len);
+		bytes_copied += message_len - bytes_not_copied;
+		if (bytes_not_copied)
+			goto exit;
 	}
+
+	/* Finally the terminator */
+	bytes_not_copied = copy_to_user(&buf[bytes_copied],
+					&terminator, 1);
+	bytes_copied += 1 - bytes_not_copied;
+
 exit:
 	return bytes_copied;
 }
 
+/**
+ * kutf_debugfs_run_write() Debugfs write callback for the "run" entry.
+ * @file:	Opened file to write to
+ * @buf:	User buffer to read the data from
+ * @len:	Amount of data to write
+ * @ppos:	Offset into file to write to
+ *
+ * This function allows user and kernel to exchange extra data necessary for
+ * the test fixture.
+ *
+ * The data is added to the first struct kutf_context running the fixture
+ *
+ * Return: Number of bytes written
+ */
+static ssize_t kutf_debugfs_run_write(struct file *file,
+		const char __user *buf, size_t len, loff_t *ppos)
+{
+	int ret = 0;
+	struct kutf_context *test_context = file->private_data;
+
+	if (len > KUTF_MAX_LINE_LENGTH)
+		return -EINVAL;
+
+	ret = kutf_helper_input_enqueue(test_context, buf, len);
+	if (ret < 0)
+		return ret;
+
+	return len;
+}
+
 /**
  * kutf_debugfs_run_release() - Debugfs release callback for the "run" entry.
  * @inode:	File entry representation
  * @file:	A specific opening of the file
  *
- * Release any resources that where created during the opening of the file
+ * Release any resources that were created during the opening of the file
  *
  * Note that resources may not be released immediately, that might only happen
  * later when other users of the kutf_context release their refcount.
@@ -725,6 +542,8 @@ static int kutf_debugfs_run_release(struct inode *inode, struct file *file)
 {
 	struct kutf_context *test_context = file->private_data;
 
+	kutf_helper_input_enqueue_end_of_data(test_context);
+
 	kutf_context_put(test_context);
 	return 0;
 }
@@ -733,6 +552,7 @@ static const struct file_operations kutf_debugfs_run_ops = {
 	.owner = THIS_MODULE,
 	.open = kutf_debugfs_run_open,
 	.read = kutf_debugfs_run_read,
+	.write = kutf_debugfs_run_write,
 	.release = kutf_debugfs_run_release,
 	.llseek  = default_llseek,
 };
@@ -763,7 +583,6 @@ static int create_fixture_variant(struct kutf_test_function *test_func,
 
 	test_fix->test_func = test_func;
 	test_fix->fixture_index = fixture_index;
-	atomic_set(&test_fix->nr_running, 0);
 
 	snprintf(name, sizeof(name), "%d", fixture_index);
 	test_fix->dir = debugfs_create_dir(name, test_func->dir);
@@ -783,8 +602,14 @@ static int create_fixture_variant(struct kutf_test_function *test_func,
 		goto fail_file;
 	}
 
-	tmp = debugfs_create_file("run", S_IROTH, test_fix->dir, test_fix,
-				  &kutf_debugfs_run_ops);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	tmp = debugfs_create_file_unsafe(
+#else
+	tmp = debugfs_create_file(
+#endif
+			"run", 0600, test_fix->dir,
+			test_fix,
+			&kutf_debugfs_run_ops);
 	if (!tmp) {
 		pr_err("Failed to create debugfs file \"run\" when adding fixture\n");
 		/* Might not be the right error, we don't get it passed back to us */
@@ -813,14 +638,13 @@ static void kutf_remove_test_variant(struct kutf_test_fixture *test_fix)
 	kfree(test_fix);
 }
 
-void kutf_add_test_with_filters_data_and_userdata(
+void kutf_add_test_with_filters_and_data(
 		struct kutf_suite *suite,
 		unsigned int id,
 		const char *name,
 		void (*execute)(struct kutf_context *context),
 		unsigned int filters,
-		union kutf_callback_data test_data,
-		struct kutf_userdata_ops *userdata_ops)
+		union kutf_callback_data test_data)
 {
 	struct kutf_test_function *test_func;
 	struct dentry *tmp;
@@ -873,7 +697,6 @@ void kutf_add_test_with_filters_data_and_userdata(
 	test_func->suite = suite;
 	test_func->execute = execute;
 	test_func->test_data = test_data;
-	memcpy(&test_func->userdata_ops, userdata_ops, sizeof(*userdata_ops));
 
 	list_add(&test_func->node, &suite->test_list);
 	return;
@@ -885,27 +708,6 @@ void kutf_add_test_with_filters_data_and_userdata(
 fail_alloc:
 	return;
 }
-EXPORT_SYMBOL(kutf_add_test_with_filters_data_and_userdata);
-
-void kutf_add_test_with_filters_and_data(
-		struct kutf_suite *suite,
-		unsigned int id,
-		const char *name,
-		void (*execute)(struct kutf_context *context),
-		unsigned int filters,
-		union kutf_callback_data test_data)
-{
-	struct kutf_userdata_ops userdata_ops = {
-		.open = NULL,
-		.release = NULL,
-		.consumer = NULL,
-		.producer = NULL,
-	};
-
-	kutf_add_test_with_filters_data_and_userdata(suite, id, name, execute,
-			filters, test_data, &userdata_ops);
-}
-
 EXPORT_SYMBOL(kutf_add_test_with_filters_and_data);
 
 void kutf_add_test_with_filters(
@@ -1150,7 +952,7 @@ static struct kutf_context *kutf_create_context(
 
 	new_context->result_set = kutf_create_result_set();
 	if (!new_context->result_set) {
-		pr_err("Failed to create resultset");
+		pr_err("Failed to create result set");
 		goto fail_result_set;
 	}
 
@@ -1165,9 +967,12 @@ static struct kutf_context *kutf_create_context(
 	new_context->fixture_index = test_fix->fixture_index;
 	new_context->fixture_name = NULL;
 	new_context->test_data = test_fix->test_func->test_data;
-	new_context->userdata_consumer_priv = NULL;
-	new_context->userdata_producer_priv = NULL;
-	new_context->userdata_dentry = NULL;
+
+	new_context->userdata.flags = 0;
+	INIT_LIST_HEAD(&new_context->userdata.input_head);
+	init_waitqueue_head(&new_context->userdata.input_waitq);
+
+	INIT_WORK(&new_context->work, kutf_run_test);
 
 	kref_init(&new_context->kref);
 
@@ -1227,8 +1032,7 @@ static void kutf_test_log_result(
 		context->status = new_status;
 
 	if (context->expected_status != new_status)
-		kutf_add_result(&context->fixture_pool, context->result_set,
-				new_status, message);
+		kutf_add_result(context, new_status, message);
 }
 
 void kutf_test_log_result_external(
@@ -1344,18 +1148,18 @@ EXPORT_SYMBOL(kutf_test_abort);
  */
 static int __init init_kutf_core(void)
 {
-	int ret;
+	kutf_workq = alloc_workqueue("kutf workq", WQ_UNBOUND, 1);
+	if (!kutf_workq)
+		return -ENOMEM;
 
 	base_dir = debugfs_create_dir("kutf_tests", NULL);
 	if (!base_dir) {
-		ret = -ENODEV;
-		goto exit_dir;
+		destroy_workqueue(kutf_workq);
+		kutf_workq = NULL;
+		return -ENOMEM;
 	}
 
 	return 0;
-
-exit_dir:
-	return ret;
 }
 
 /**
@@ -1366,6 +1170,9 @@ static int __init init_kutf_core(void)
 static void __exit exit_kutf_core(void)
 {
 	debugfs_remove_recursive(base_dir);
+
+	if (kutf_workq)
+		destroy_workqueue(kutf_workq);
 }
 
 #else	/* defined(CONFIG_DEBUG_FS) */
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/kutf_utils.c b/drivers/gpu/arm/bifrost/tests/kutf/kutf_utils.c
index a429a2dbf788..7f5ac517fdb4 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/kutf_utils.c
+++ b/drivers/gpu/arm/bifrost/tests/kutf/kutf_utils.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 /* Kernel UTF utility functions */
 
 #include <linux/mutex.h>
diff --git a/drivers/gpu/arm/bifrost/tests/kutf/sconscript b/drivers/gpu/arm/bifrost/tests/kutf/sconscript
index d7f112448e42..98f64468dac9 100644
--- a/drivers/gpu/arm/bifrost/tests/kutf/sconscript
+++ b/drivers/gpu/arm/bifrost/tests/kutf/sconscript
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 Import('kutf_env')
 
diff --git a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Kbuild b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Kbuild
index 0cd9cebe9d8b..ca8c51273b4c 100644
--- a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Kbuild
+++ b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Kbuild
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 ccflags-y += -I$(src)/../include -I$(src)/../../../ -I$(src)/../../ -I$(src)/../../backend/gpu -I$(srctree)/drivers/staging/android
 
diff --git a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Kconfig b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Kconfig
index 4caa8ec8a0e2..78283307713d 100644
--- a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Kconfig
+++ b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Kconfig
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 config MALI_IRQ_LATENCY
  tristate "Mali GPU IRQ latency measurement"
diff --git a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Makefile b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Makefile
index ced37b08e532..d7dd5880f418 100644
--- a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Makefile
+++ b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/Makefile
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 # linux build system bootstrap for out-of-tree module
 
diff --git a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/mali_kutf_irq_test_main.c b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/mali_kutf_irq_test_main.c
index c9cc4447cf37..5013a9d7cf89 100644
--- a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/mali_kutf_irq_test_main.c
+++ b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/mali_kutf_irq_test_main.c
@@ -7,14 +7,19 @@
  * Foundation, and any use by you of this program is subject to the terms
  * of such GNU licence.
  *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
  *
  */
 
-
-
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
diff --git a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/sconscript b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/sconscript
index b06d9ea32924..2be566b29abe 100644
--- a/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/sconscript
+++ b/drivers/gpu/arm/bifrost/tests/mali_kutf_irq_test/sconscript
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 import os
 Import('env')
diff --git a/drivers/gpu/arm/bifrost/tests/sconscript b/drivers/gpu/arm/bifrost/tests/sconscript
index 04584117ccef..0bd24a5e3f35 100644
--- a/drivers/gpu/arm/bifrost/tests/sconscript
+++ b/drivers/gpu/arm/bifrost/tests/sconscript
@@ -6,12 +6,18 @@
 # Foundation, and any use by you of this program is subject to the terms
 # of such GNU licence.
 #
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can access it online at
+# http://www.gnu.org/licenses/gpl-2.0.html.
+#
+# SPDX-License-Identifier: GPL-2.0
 #
 #
-
 
 Import ('env')
 
diff --git a/drivers/gpu/arm/bifrost/thirdparty/mali_kbase_mmap.c b/drivers/gpu/arm/bifrost/thirdparty/mali_kbase_mmap.c
new file mode 100644
index 000000000000..1690da43a0c3
--- /dev/null
+++ b/drivers/gpu/arm/bifrost/thirdparty/mali_kbase_mmap.c
@@ -0,0 +1,321 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, you can access it online at
+ * http://www.gnu.org/licenses/gpl-2.0.html.
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ *//*
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ */
+
+#include "linux/mman.h"
+#include "../mali_kbase.h"
+
+/* mali_kbase_mmap.c
+ *
+ * This file contains Linux specific implementation of
+ * kbase_get_unmapped_area() interface.
+ */
+
+
+/**
+ * align_and_check() - Align the specified pointer to the provided alignment and
+ *                     check that it is still in range.
+ * @gap_end:        Highest possible start address for allocation (end of gap in
+ *                  address space)
+ * @gap_start:      Start address of current memory area / gap in address space
+ * @info:           vm_unmapped_area_info structure passed to caller, containing
+ *                  alignment, length and limits for the allocation
+ * @is_shader_code: True if the allocation is for shader code (which has
+ *                  additional alignment requirements)
+ *
+ * Return: true if gap_end is now aligned correctly and is still in range,
+ *         false otherwise
+ */
+static bool align_and_check(unsigned long *gap_end, unsigned long gap_start,
+		struct vm_unmapped_area_info *info, bool is_shader_code)
+{
+	/* Compute highest gap address at the desired alignment */
+	(*gap_end) -= info->length;
+	(*gap_end) -= (*gap_end - info->align_offset) & info->align_mask;
+
+	if (is_shader_code) {
+		/* Check for 4GB boundary */
+		if (0 == (*gap_end & BASE_MEM_MASK_4GB))
+			(*gap_end) -= (info->align_offset ? info->align_offset :
+					info->length);
+		if (0 == ((*gap_end + info->length) & BASE_MEM_MASK_4GB))
+			(*gap_end) -= (info->align_offset ? info->align_offset :
+					info->length);
+
+		if (!(*gap_end & BASE_MEM_MASK_4GB) || !((*gap_end +
+				info->length) & BASE_MEM_MASK_4GB))
+			return false;
+	}
+
+
+	if ((*gap_end < info->low_limit) || (*gap_end < gap_start))
+		return false;
+
+
+	return true;
+}
+
+/**
+ * kbase_unmapped_area_topdown() - allocates new areas top-down from
+ *                                 below the stack limit.
+ * @info:              Information about the memory area to allocate.
+ * @is_shader_code:    Boolean which denotes whether the allocated area is
+ *                      intended for the use by shader core in which case a
+ *                      special alignment requirements apply.
+ *
+ * The unmapped_area_topdown() function in the Linux kernel is not exported
+ * using EXPORT_SYMBOL_GPL macro. To allow us to call this function from a
+ * module and also make use of the fact that some of the requirements for
+ * the unmapped area are known in advance, we implemented an extended version
+ * of this function and prefixed it with 'kbase_'.
+ *
+ * The difference in the call parameter list comes from the fact that
+ * kbase_unmapped_area_topdown() is called with additional parameter which
+ * is provided to denote whether the allocation is for a shader core memory
+ * or not. This is significant since the executable shader core memory has
+ * additional alignment requirements.
+ *
+ * The modification of the original Linux function lies in how the computation
+ * of the highest gap address at the desired alignment is performed once the
+ * gap with desirable properties is found. For this purpose a special function
+ * is introduced (@ref align_and_check()) which beside computing the gap end
+ * at the desired alignment also performs additional alignment check for the
+ * case when the memory is executable shader core memory. For such case, it is
+ * ensured that the gap does not end on a 4GB boundary.
+ *
+ * Return: address of the found gap end (high limit) if area is found;
+ *         -ENOMEM if search is unsuccessful
+*/
+
+static unsigned long kbase_unmapped_area_topdown(struct vm_unmapped_area_info
+		*info, bool is_shader_code)
+{
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	unsigned long length, low_limit, high_limit, gap_start, gap_end;
+
+	/* Adjust search length to account for worst case alignment overhead */
+	length = info->length + info->align_mask;
+	if (length < info->length)
+		return -ENOMEM;
+
+	/*
+	 * Adjust search limits by the desired length.
+	 * See implementation comment at top of unmapped_area().
+	 */
+	gap_end = info->high_limit;
+	if (gap_end < length)
+		return -ENOMEM;
+	high_limit = gap_end - length;
+
+	if (info->low_limit > high_limit)
+		return -ENOMEM;
+	low_limit = info->low_limit + length;
+
+	/* Check highest gap, which does not precede any rbtree node */
+	gap_start = mm->highest_vm_end;
+	if (gap_start <= high_limit) {
+		if (align_and_check(&gap_end, gap_start, info, is_shader_code))
+			return gap_end;
+	}
+
+	/* Check if rbtree root looks promising */
+	if (RB_EMPTY_ROOT(&mm->mm_rb))
+		return -ENOMEM;
+	vma = rb_entry(mm->mm_rb.rb_node, struct vm_area_struct, vm_rb);
+	if (vma->rb_subtree_gap < length)
+		return -ENOMEM;
+
+	while (true) {
+		/* Visit right subtree if it looks promising */
+		gap_start = vma->vm_prev ? vma->vm_prev->vm_end : 0;
+		if (gap_start <= high_limit && vma->vm_rb.rb_right) {
+			struct vm_area_struct *right =
+				rb_entry(vma->vm_rb.rb_right,
+					 struct vm_area_struct, vm_rb);
+			if (right->rb_subtree_gap >= length) {
+				vma = right;
+				continue;
+			}
+		}
+
+check_current:
+		/* Check if current node has a suitable gap */
+		gap_end = vma->vm_start;
+		if (gap_end < low_limit)
+			return -ENOMEM;
+		if (gap_start <= high_limit && gap_end - gap_start >= length) {
+			/* We found a suitable gap. Clip it with the original
+			 * high_limit. */
+			if (gap_end > info->high_limit)
+				gap_end = info->high_limit;
+
+			if (align_and_check(&gap_end, gap_start, info,
+					is_shader_code))
+				return gap_end;
+		}
+
+		/* Visit left subtree if it looks promising */
+		if (vma->vm_rb.rb_left) {
+			struct vm_area_struct *left =
+				rb_entry(vma->vm_rb.rb_left,
+					 struct vm_area_struct, vm_rb);
+			if (left->rb_subtree_gap >= length) {
+				vma = left;
+				continue;
+			}
+		}
+
+		/* Go back up the rbtree to find next candidate node */
+		while (true) {
+			struct rb_node *prev = &vma->vm_rb;
+
+			if (!rb_parent(prev))
+				return -ENOMEM;
+			vma = rb_entry(rb_parent(prev),
+				       struct vm_area_struct, vm_rb);
+			if (prev == vma->vm_rb.rb_right) {
+				gap_start = vma->vm_prev ?
+					vma->vm_prev->vm_end : 0;
+				goto check_current;
+			}
+		}
+	}
+
+	return -ENOMEM;
+}
+
+
+/* This function is based on Linux kernel's arch_get_unmapped_area, but
+ * simplified slightly. Modifications come from the fact that some values
+ * about the memory area are known in advance.
+ */
+unsigned long kbase_get_unmapped_area(struct file *filp,
+		const unsigned long addr, const unsigned long len,
+		const unsigned long pgoff, const unsigned long flags)
+{
+	struct kbase_context *kctx = filp->private_data;
+	struct mm_struct *mm = current->mm;
+	struct vm_unmapped_area_info info;
+	unsigned long align_offset = 0;
+	unsigned long align_mask = 0;
+	unsigned long high_limit = mm->mmap_base;
+	unsigned long low_limit = PAGE_SIZE;
+	int cpu_va_bits = BITS_PER_LONG;
+	int gpu_pc_bits =
+	      kctx->kbdev->gpu_props.props.core_props.log2_program_counter_size;
+	bool is_shader_code = false;
+	unsigned long ret;
+
+	/* err on fixed address */
+	if ((flags & MAP_FIXED) || addr)
+		return -EINVAL;
+
+#ifdef CONFIG_64BIT
+	/* too big? */
+	if (len > TASK_SIZE - SZ_2M)
+		return -ENOMEM;
+
+	if (!kbase_ctx_flag(kctx, KCTX_COMPAT)) {
+
+		if (kbase_hw_has_feature(kctx->kbdev,
+						BASE_HW_FEATURE_33BIT_VA)) {
+			high_limit = kctx->same_va_end << PAGE_SHIFT;
+		} else {
+			high_limit = min_t(unsigned long, mm->mmap_base,
+					(kctx->same_va_end << PAGE_SHIFT));
+			if (len >= SZ_2M) {
+				align_offset = SZ_2M;
+				align_mask = SZ_2M - 1;
+			}
+		}
+
+		low_limit = SZ_2M;
+	} else {
+		cpu_va_bits = 32;
+	}
+#endif /* CONFIG_64BIT */
+	if ((PFN_DOWN(BASE_MEM_COOKIE_BASE) <= pgoff) &&
+		(PFN_DOWN(BASE_MEM_FIRST_FREE_ADDRESS) > pgoff)) {
+			int cookie = pgoff - PFN_DOWN(BASE_MEM_COOKIE_BASE);
+			struct kbase_va_region *reg =
+					kctx->pending_regions[cookie];
+
+			if (!reg)
+				return -EINVAL;
+
+			if (!(reg->flags & KBASE_REG_GPU_NX)) {
+				if (cpu_va_bits > gpu_pc_bits) {
+					align_offset = 1ULL << gpu_pc_bits;
+					align_mask = align_offset - 1;
+					is_shader_code = true;
+				}
+			} else if (reg->flags & KBASE_REG_TILER_ALIGN_TOP) {
+				unsigned long extent_bytes =
+				     (unsigned long)(reg->extent << PAGE_SHIFT);
+				/* kbase_check_alloc_sizes() already satisfies
+				 * these checks, but they're here to avoid
+				 * maintenance hazards due to the assumptions
+				 * involved */
+				WARN_ON(reg->extent > (ULONG_MAX >> PAGE_SHIFT));
+				WARN_ON(reg->initial_commit > (ULONG_MAX >> PAGE_SHIFT));
+				WARN_ON(!is_power_of_2(extent_bytes));
+				align_mask = extent_bytes - 1;
+				align_offset =
+				      extent_bytes - (reg->initial_commit << PAGE_SHIFT);
+			}
+#ifndef CONFIG_64BIT
+	} else {
+		return current->mm->get_unmapped_area(filp, addr, len, pgoff,
+						      flags);
+#endif
+	}
+
+	info.flags = 0;
+	info.length = len;
+	info.low_limit = low_limit;
+	info.high_limit = high_limit;
+	info.align_offset = align_offset;
+	info.align_mask = align_mask;
+
+	ret = kbase_unmapped_area_topdown(&info, is_shader_code);
+
+	if (IS_ERR_VALUE(ret) && high_limit == mm->mmap_base &&
+			high_limit < (kctx->same_va_end << PAGE_SHIFT)) {
+		/* Retry above mmap_base */
+		info.low_limit = mm->mmap_base;
+		info.high_limit = min_t(u64, TASK_SIZE,
+					(kctx->same_va_end << PAGE_SHIFT));
+
+		ret = kbase_unmapped_area_topdown(&info, is_shader_code);
+	}
+
+	return ret;
+}
-- 
2.35.3

