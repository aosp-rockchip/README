From 0466588abc16e48b274ea978d653a008ca964d8a Mon Sep 17 00:00:00 2001
From: chenyifu <chenyf@rock-chips.com>
Date: Fri, 26 Sep 2014 16:56:05 +0800
Subject: [PATCH] rk312x mipi:improve CodingStype of mipi driver code

---
 drivers/video/rockchip/screen/lcd_mipi.c      |  798 ++++----
 .../rockchip/transmitter/rk32_mipi_dsi.c      | 1726 ++++++++---------
 .../rockchip/transmitter/rk32_mipi_dsi.h      |  227 +--
 3 files changed, 1312 insertions(+), 1439 deletions(-)

diff --git a/drivers/video/rockchip/screen/lcd_mipi.c b/drivers/video/rockchip/screen/lcd_mipi.c
index 7293efde858b..d9d35d2650e3 100755
--- a/drivers/video/rockchip/screen/lcd_mipi.c
+++ b/drivers/video/rockchip/screen/lcd_mipi.c
@@ -34,58 +34,53 @@
 #endif
 
 #ifdef CONFIG_RK_3288_DSI_UBOOT
-#define	MIPI_SCREEN_DBG(x...)	//printf(x)
+#define	MIPI_SCREEN_DBG(x...)	/* printf(x) */
 #elif defined CONFIG_LCD_MIPI
-#define	MIPI_SCREEN_DBG(x...)	//printk(KERN_ERR x)
+#define	MIPI_SCREEN_DBG(x...)	/* printk(KERN_ERR x) */
 #else
-#define	MIPI_SCREEN_DBG(x...)  
+#define	MIPI_SCREEN_DBG(x...)
 #endif
 #ifdef CONFIG_RK_3288_DSI_UBOOT
 DECLARE_GLOBAL_DATA_PTR;
 #define msleep(a) udelay(a * 1000)
-#define	printk(x...)	//printf(x)
+#define	printk(x...)	/* printf(x) */
 #endif
 static struct mipi_screen *gmipi_screen;
 
 static void rk_mipi_screen_pwr_disable(struct mipi_screen *screen)
-{   
-	if(screen->lcd_en_gpio != INVALID_GPIO){
+{
+	if (screen->lcd_en_gpio != INVALID_GPIO) {
 		gpio_direction_output(screen->lcd_en_gpio, !screen->lcd_en_atv_val);
 		msleep(screen->lcd_en_delay);
-	}
-	else{
+	} else{
 		MIPI_SCREEN_DBG("lcd_en_gpio is null");
 	}
-	
-	if(screen->lcd_rst_gpio != INVALID_GPIO){
+
+	if (screen->lcd_rst_gpio != INVALID_GPIO) {
 
 		gpio_direction_output(screen->lcd_rst_gpio, !screen->lcd_rst_atv_val);
 		msleep(screen->lcd_rst_delay);
-	}
-	else{
+	} else {
 		MIPI_SCREEN_DBG("lcd_rst_gpio is null");
-	}    
+	}
 }
 
 static void rk_mipi_screen_pwr_enable(struct mipi_screen *screen)
-{   
-
-	if(screen->lcd_en_gpio != INVALID_GPIO){
+{
+	if (screen->lcd_en_gpio != INVALID_GPIO) {
 		gpio_direction_output(screen->lcd_en_gpio, !screen->lcd_en_atv_val);
 		msleep(screen->lcd_en_delay);
 		gpio_direction_output(screen->lcd_en_gpio, screen->lcd_en_atv_val);
 		msleep(screen->lcd_en_delay);
-	}
-	else
+	} else
 		MIPI_SCREEN_DBG("lcd_en_gpio is null\n");
-	
-	if(screen->lcd_rst_gpio != INVALID_GPIO){
+
+	if (screen->lcd_rst_gpio != INVALID_GPIO) {
 		gpio_direction_output(screen->lcd_rst_gpio, !screen->lcd_rst_atv_val);
 		msleep (screen->lcd_rst_delay);
 		gpio_direction_output(screen->lcd_rst_gpio, screen->lcd_rst_atv_val);
 		msleep(screen->lcd_rst_delay);
-	}
-	else
+	} else
 		MIPI_SCREEN_DBG("lcd_rst_gpio is null\n");
 }
 
@@ -96,8 +91,8 @@ static void rk_mipi_screen_cmd_init(struct mipi_screen *screen)
 	struct list_head *screen_pos;
 	struct mipi_dcs_cmd_ctr_list  *dcs_cmd;
 #ifdef CONFIG_RK_3288_DSI_UBOOT
-	cmds = calloc(1,0x400);
-	if(!cmds) {
+	cmds = calloc(1, 0x400);
+	if (!cmds) {
 		printf("request cmds fail!\n");
 		return;
 	}
@@ -105,67 +100,52 @@ static void rk_mipi_screen_cmd_init(struct mipi_screen *screen)
 
 #ifdef CONFIG_LCD_MIPI
 	cmds = kmalloc(0x400, GFP_KERNEL);
-	if(!cmds) {
+	if (!cmds) {
 		printk("request cmds fail!\n");
 		return ;
 	}
 #endif
-		
-	list_for_each(screen_pos, &screen->cmdlist_head){
-	
+	list_for_each(screen_pos, &screen->cmdlist_head) {
 		dcs_cmd = list_entry(screen_pos, struct mipi_dcs_cmd_ctr_list, list);
 		len = dcs_cmd->dcs_cmd.cmd_len + 1;
-		
-		for( i = 1; i < len ; i++){
+		for (i = 1; i < len ; i++) {
 			cmds[i] = dcs_cmd->dcs_cmd.cmds[i-1];
 		}
-		MIPI_SCREEN_DBG("dcs_cmd.name:%s\n",dcs_cmd->dcs_cmd.name);
-		if(dcs_cmd->dcs_cmd.type == LPDT){
+		MIPI_SCREEN_DBG("dcs_cmd.name:%s\n", dcs_cmd->dcs_cmd.name);
+		if (dcs_cmd->dcs_cmd.type == LPDT) {
 			cmds[0] = LPDT;
-			if(dcs_cmd->dcs_cmd.dsi_id == 0){
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n",__LINE__);                
+			if (dcs_cmd->dcs_cmd.dsi_id == 0) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n", __LINE__);
 				dsi_send_packet(0, cmds, len);
-			}
-			else if (dcs_cmd->dcs_cmd.dsi_id == 1){
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n",__LINE__);
+			} else if (dcs_cmd->dcs_cmd.dsi_id == 1) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n", __LINE__);
 				dsi_send_packet(1, cmds, len);
-			}
-			else if (dcs_cmd->dcs_cmd.dsi_id == 2){
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n",__LINE__);
+			} else if (dcs_cmd->dcs_cmd.dsi_id == 2) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n", __LINE__);
 				dsi_send_packet(0, cmds, len);
 				dsi_send_packet(1, cmds, len);
-			}
-			else{
-			    MIPI_SCREEN_DBG("dsi is err.\n");
+			} else {
+				MIPI_SCREEN_DBG("dsi is err.\n");
 			}
 			msleep(dcs_cmd->dcs_cmd.delay);
-			
-		}
-		else if(dcs_cmd->dcs_cmd.type == HSDT){
+		} else if (dcs_cmd->dcs_cmd.type == HSDT) {
 			cmds[0] = HSDT;
-			if(dcs_cmd->dcs_cmd.dsi_id == 0){
-			
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n",__LINE__); 
+			if (dcs_cmd->dcs_cmd.dsi_id == 0) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 0 line=%d\n", __LINE__);
 				dsi_send_packet(0, cmds, len);
-			}
-			else if (dcs_cmd->dcs_cmd.dsi_id == 1){
-			
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n",__LINE__);
+			} else if (dcs_cmd->dcs_cmd.dsi_id == 1) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 1 line=%d\n", __LINE__);
 				dsi_send_packet(1, cmds, len);
-			}
-			else if (dcs_cmd->dcs_cmd.dsi_id == 2){
-				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n",__LINE__); 
+			} else if (dcs_cmd->dcs_cmd.dsi_id == 2) {
+				MIPI_SCREEN_DBG("dcs_cmd.dsi_id == 2 line=%d\n", __LINE__);
 				dsi_send_packet(0, cmds, len);
 				dsi_send_packet(1, cmds, len);
-			}
-			else{
+			} else {
 				MIPI_SCREEN_DBG("dsi is err.");
 			}
 			msleep(dcs_cmd->dcs_cmd.delay);
-			
-		}
-		else
-		    MIPI_SCREEN_DBG("cmd type err.\n");
+		} else
+			MIPI_SCREEN_DBG("cmd type err.\n");
 	}
 
 #ifdef CONFIG_RK_3288_DSI_UBOOT
@@ -174,370 +154,353 @@ static void rk_mipi_screen_cmd_init(struct mipi_screen *screen)
 #ifdef CONFIG_LCD_MIPI
 	kfree(cmds);
 #endif
-
 }
 
-int rk_mipi_screen(void) 
+int rk_mipi_screen(void)
 {
 	u8 dcs[16] = {0}, rk_dsi_num;
 	rk_dsi_num = gmipi_screen->mipi_dsi_num;
-	if(gmipi_screen->screen_init == 0){
+	if (gmipi_screen->screen_init == 0) {
 		rk_mipi_screen_pwr_enable(gmipi_screen);
-		
-		dsi_enable_hs_clk(0,1);
-		if(rk_dsi_num == 2){
+		dsi_enable_hs_clk(0, 1);
+		if (rk_dsi_num == 2) {
 			dsi_enable_hs_clk(1, 1);
 		}
-		
-		dsi_enable_video_mode(0,0);
-		if(rk_dsi_num == 2){
-			dsi_enable_video_mode(1,0);
-		} 
-		
+
+		dsi_enable_video_mode(0, 0);
+		if (rk_dsi_num == 2) {
+			dsi_enable_video_mode(1, 0);
+		}
+
 		dsi_enable_command_mode(0, 1);
-		if(rk_dsi_num == 2){
+		if (rk_dsi_num == 2) {
 			dsi_enable_command_mode(1, 1);
-		} 
-		
+		}
+
 		dcs[0] = LPDT;
 		dcs[1] = DTYPE_DCS_SWRITE_0P;
-		dcs[2] = dcs_exit_sleep_mode; 
+		dcs[2] = dcs_exit_sleep_mode;
 		dsi_send_packet(0, dcs, 3);
-		if(rk_dsi_num ==2)   
+		if (rk_dsi_num == 2)
 			dsi_send_packet(1, dcs, 3);
-		
+
 		msleep(20);
-		
+
 		dcs[0] = LPDT;
 		dcs[1] = DTYPE_DCS_SWRITE_0P;
-		dcs[2] = dcs_set_display_on; 
+		dcs[2] = dcs_set_display_on;
 		dsi_send_packet(0, dcs, 3);
-		if(rk_dsi_num ==2)
-	        dsi_send_packet(1, dcs, 3); 
+		if (rk_dsi_num == 2)
+			dsi_send_packet(1, dcs, 3);
 
 		msleep(20);
-		
-		dsi_enable_command_mode(0,0);
-		if(rk_dsi_num == 2){
-			dsi_enable_command_mode(1,0);
-		} 
-
-		dsi_enable_video_mode(0,1);
-		if(rk_dsi_num == 2){
-			dsi_enable_video_mode(1,1);
-		} 
-	}
-	else{
+
+		dsi_enable_command_mode(0, 0);
+		if (rk_dsi_num == 2) {
+			dsi_enable_command_mode(1, 0);
+		}
+
+		dsi_enable_video_mode(0, 1);
+		if (rk_dsi_num == 2) {
+			dsi_enable_video_mode(1, 1);
+		}
+	} else {
 		rk_mipi_screen_pwr_enable(gmipi_screen);
 
-		dsi_enable_hs_clk(0,1);
-		if(rk_dsi_num == 2){
+		dsi_enable_hs_clk(0, 1);
+		if (rk_dsi_num == 2) {
 			dsi_enable_hs_clk(1, 1);
 		}
 
-		dsi_enable_video_mode(0,0);
-		if(rk_dsi_num == 2){
-			dsi_enable_video_mode(1,0);
-		} 
-		
+		dsi_enable_video_mode(0, 0);
+		if (rk_dsi_num == 2) {
+			dsi_enable_video_mode(1, 0);
+		}
+
 		dsi_enable_command_mode(0, 1);
-		if(rk_dsi_num == 2){
+		if (rk_dsi_num == 2) {
 			dsi_enable_command_mode(1, 1);
-		} 
+		}
 
 		rk_mipi_screen_cmd_init(gmipi_screen);
 
-		dsi_enable_command_mode(0,0);
-		if(rk_dsi_num == 2){
-			dsi_enable_command_mode(1,0);
-		} 
+		dsi_enable_command_mode(0, 0);
+		if (rk_dsi_num == 2) {
+			dsi_enable_command_mode(1, 0);
+		}
 
-		dsi_enable_video_mode(0,1);
-		if(rk_dsi_num == 2){
-			dsi_enable_video_mode(1,1);
-		} 
+		dsi_enable_video_mode(0, 1);
+		if (rk_dsi_num == 2) {
+			dsi_enable_video_mode(1, 1);
+		}
 	}
-	
+
 	MIPI_SCREEN_DBG("++++++++++++++++%s:%d\n", __func__, __LINE__);
 	return 0;
 }
 
-int rk_mipi_screen_standby(u8 enable) 
+int rk_mipi_screen_standby(u8 enable)
 {
 	u8 dcs[16] = {0}, rk_dsi_num;
 	rk_dsi_num = gmipi_screen->mipi_dsi_num;
 
-	if(dsi_is_active(0) != 1) 
+	if (dsi_is_active(0) != 1)
 		return -1;
-	
-	if(rk_dsi_num ==2)
-		if((dsi_is_active(0) != 1) ||(dsi_is_active(1) != 1))
+
+	if (rk_dsi_num == 2)
+		if ((dsi_is_active(0) != 1) || (dsi_is_active(1) != 1))
 			return -1;
-	
-	if(enable) {
-		/*below is changeable*/
+
+	if (enable) {
+		/* below is changeable */
 		dcs[0] = LPDT;
 		dcs[1] = DTYPE_DCS_SWRITE_0P;
-		dcs[2] = dcs_set_display_off; 
+		dcs[2] = dcs_set_display_off;
 		dsi_send_packet(0, dcs, 3);
-		if(rk_dsi_num ==2)   
+		if (rk_dsi_num == 2)
 			dsi_send_packet(1, dcs, 3);
-		
+
 		msleep(30);
-		
+
 		dcs[0] = LPDT;
 		dcs[1] = DTYPE_DCS_SWRITE_0P;
-		dcs[2] = dcs_enter_sleep_mode; 
+		dcs[2] = dcs_enter_sleep_mode;
 		dsi_send_packet(0, dcs, 3);
-		if(rk_dsi_num ==2)
-			dsi_send_packet(1, dcs, 3);   
+		if (rk_dsi_num == 2)
+			dsi_send_packet(1, dcs, 3);
 
 		msleep(100);
 		rk_mipi_screen_pwr_disable(gmipi_screen);
 		MIPI_SCREEN_DBG("++++enable++++++++++++%s:%d\n", __func__, __LINE__);
-	}
-	else {
+	} else {
 		rk_mipi_screen();
 	}
-    return 0;
+	return 0;
 }
 #ifdef CONFIG_LCD_MIPI
 static int rk_mipi_screen_init_dt(struct mipi_screen *screen)
 {
 	struct device_node *childnode, *grandchildnode, *root;
-	struct mipi_dcs_cmd_ctr_list  *dcs_cmd;
+	struct mipi_dcs_cmd_ctr_list *dcs_cmd;
 	struct list_head *pos;
 	struct property *prop;
 	enum of_gpio_flags flags;
 	u32 value, i, debug, gpio, ret, cmds[25], length;
 
 	memset(screen, 0, sizeof(*screen));
-	
+
 	INIT_LIST_HEAD(&screen->cmdlist_head);
 
 	childnode = of_find_node_by_name(NULL, "mipi_dsi_init");
-	if(!childnode ){
+	if (!childnode) {
 		MIPI_SCREEN_DBG("%s: Can not get child => mipi_init.\n", __func__);
-	}
-	else{
+	} else {
 		ret = of_property_read_u32(childnode, "rockchip,screen_init", &value);
 		if (ret) {
 			MIPI_SCREEN_DBG("%s: Can not read property: screen_init.\n", __func__);
-		} 
-		else {
-			if((value != 0) && (value != 1) ){
+		} else {
+			if ((value != 0) && (value != 1)) {
 				printk("err: rockchip,mipi_dsi_init not match.\n");
 				return -1;
-			}else
+			} else
 				screen->screen_init = value ;
-			
-			MIPI_SCREEN_DBG("%s: lcd->screen_init = %d.\n", __func__, screen->screen_init ); 
+
+			MIPI_SCREEN_DBG("%s: lcd->screen_init = %d.\n", __func__, screen->screen_init);
 		}
-		
+
 		ret = of_property_read_u32(childnode, "rockchip,dsi_lane", &value);
 		if (ret) {
 			MIPI_SCREEN_DBG("%s: Can not read property: dsi_lane.\n", __func__);
 		} else {
 			screen->dsi_lane = value;
-			MIPI_SCREEN_DBG("%s: mipi_lcd->dsi_lane = %d.\n", __func__, screen->dsi_lane ); 
-		} 
-	
+			MIPI_SCREEN_DBG("%s: mipi_lcd->dsi_lane = %d.\n", __func__, screen->dsi_lane);
+		}
+
 		ret = of_property_read_u32(childnode, "rockchip,dsi_hs_clk", &value);
 		if (ret) {
 			MIPI_SCREEN_DBG("%s: Can not read property: dsi_hs_clk.\n", __func__);
 		} else {
-			if((value <= 90) || (value >= 1500)){
+			if ((value <= 90) || (value >= 1500)) {
 				printk("err: rockchip,hs_tx_clk not match.");
 				return -1;
-			}else
+			} else {
 				screen->hs_tx_clk = value*MHz;
-		
-			MIPI_SCREEN_DBG("%s: lcd->screen->hs_tx_clk = %d.\n", __func__, screen->hs_tx_clk ); 
-		} 
-		
+			}
+
+			MIPI_SCREEN_DBG("%s: lcd->screen->hs_tx_clk = %d.\n", __func__, screen->hs_tx_clk);
+		}
+
 		ret = of_property_read_u32(childnode, "rockchip,mipi_dsi_num", &value);
 		if (ret) {
-		    MIPI_SCREEN_DBG("%s: Can not read property: mipi_dsi_num.\n", __func__);
+			MIPI_SCREEN_DBG("%s: Can not read property: mipi_dsi_num.\n", __func__);
 		} else {
-			if((value != 1) && (value != 2) ){
+			if ((value != 1) && (value != 2)) {
 				printk("err: rockchip,mipi_dsi_num not match.\n");
 				return -1;
-			}
-			else
+			} else {
 				screen->mipi_dsi_num = value ;
-	
-			MIPI_SCREEN_DBG("%s: lcd->screen.mipi_dsi_num = %d.\n", __func__, screen->mipi_dsi_num ); 
-		}  
+			}
+
+			MIPI_SCREEN_DBG("%s: lcd->screen.mipi_dsi_num = %d.\n", __func__, screen->mipi_dsi_num);
+		}
 	}
 
 	childnode = of_find_node_by_name(NULL, "mipi_power_ctr");
-	if(!childnode ){
+	if (!childnode) {
 		screen->lcd_rst_gpio = INVALID_GPIO;
 		screen->lcd_en_gpio = INVALID_GPIO;
 		MIPI_SCREEN_DBG("%s: Can not get child => mipi_power_ctr.\n", __func__);
-	}
-	else{
+	} else {
 		grandchildnode = of_get_child_by_name(childnode, "mipi_lcd_rst");
-		if (!grandchildnode){
+		if (!grandchildnode) {
 			screen->lcd_rst_gpio = INVALID_GPIO;
 			MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_rst.\n", __func__);
-		}
-		else{
+		} else {
 			ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
-			if (ret){
+			if (ret) {
 				MIPI_SCREEN_DBG("%s: Can not read property: delay.\n", __func__);
-			} 
-			else {
+			} else {
 				screen->lcd_rst_delay = value;
-				MIPI_SCREEN_DBG("%s: lcd->screen->lcd_rst_delay = %d.\n", __func__, screen->lcd_rst_delay );     
-			} 
-			
+				MIPI_SCREEN_DBG("%s: lcd->screen->lcd_rst_delay = %d.\n", __func__, screen->lcd_rst_delay);
+			}
+
 			gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
-			if (!gpio_is_valid(gpio)){
+			if (!gpio_is_valid(gpio)) {
 				MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
-			} 
-			
-			ret = gpio_request(gpio,"mipi_lcd_rst");
+			}
+
+			ret = gpio_request(gpio, "mipi_lcd_rst");
 			if (ret) {
 				screen->lcd_rst_gpio = INVALID_GPIO;
-				MIPI_SCREEN_DBG("request mipi_lcd_rst gpio fail:%d\n",gpio);
+				MIPI_SCREEN_DBG("request mipi_lcd_rst gpio fail:%d\n", gpio);
 				return -1;
 			}
-			
+
 			screen->lcd_rst_gpio = gpio;
-			screen->lcd_rst_atv_val = (flags == GPIO_ACTIVE_HIGH)? 1:0; 
-			
-			MIPI_SCREEN_DBG("lcd->lcd_rst_gpio=%d,dsi->lcd_rst_atv_val=%d\n",screen->lcd_rst_gpio,screen->lcd_rst_atv_val);
-		} 
+			screen->lcd_rst_atv_val = (flags == GPIO_ACTIVE_HIGH) ? 1:0;
+
+			MIPI_SCREEN_DBG("lcd->lcd_rst_gpio=%d,dsi->lcd_rst_atv_val=%d\n", screen->lcd_rst_gpio, screen->lcd_rst_atv_val);
+		}
 
 		grandchildnode = of_get_child_by_name(childnode, "mipi_lcd_en");
-		if (!grandchildnode){
+		if (!grandchildnode) {
 			screen->lcd_en_gpio = INVALID_GPIO;
 			MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en.\n", __func__);
-		} 
-		else {
+		} else {
 			ret = of_property_read_u32(grandchildnode, "rockchip,delay", &value);
-			if (ret){
+			if (ret) {
 				MIPI_SCREEN_DBG("%s: Can not read property: mipi_lcd_en-delay.\n", __func__);
-			} 
-			else {
+			} else {
 				screen->lcd_en_delay = value;
-				MIPI_SCREEN_DBG("%s: lcd->screen.lcd_en_delay = %d.\n", __func__, screen->lcd_en_delay ); 
-			} 
-			
+				MIPI_SCREEN_DBG("%s: lcd->screen.lcd_en_delay = %d.\n", __func__, screen->lcd_en_delay);
+			}
+
 			gpio = of_get_named_gpio_flags(grandchildnode, "rockchip,gpios", 0, &flags);
-			if (!gpio_is_valid(gpio)){
+			if (!gpio_is_valid(gpio)) {
 				MIPI_SCREEN_DBG("rest: Can not read property: %s->gpios.\n", __func__);
 			}
 
-			ret = gpio_request(gpio,"mipi_lcd_en");
+			ret = gpio_request(gpio, "mipi_lcd_en");
 			if (ret) {
 				screen->lcd_en_gpio = INVALID_GPIO;
-				MIPI_SCREEN_DBG("request mipi_lcd_en gpio fail:%d\n",gpio);
+				MIPI_SCREEN_DBG("request mipi_lcd_en gpio fail:%d\n", gpio);
 				return -1;
 			}
 			screen->lcd_en_gpio = gpio;
-			screen->lcd_en_atv_val= (flags == GPIO_ACTIVE_HIGH)? 1:0; 
-			MIPI_SCREEN_DBG("dsi->lcd_en_gpio=%d, dsi->screen.lcd_en_atv_val=%d\n",screen->lcd_en_gpio,screen->lcd_en_atv_val);
+			screen->lcd_en_atv_val = (flags == GPIO_ACTIVE_HIGH) ? 1:0;
+			MIPI_SCREEN_DBG("dsi->lcd_en_gpio=%d, dsi->screen.lcd_en_atv_val=%d\n", screen->lcd_en_gpio, screen->lcd_en_atv_val);
 		}
 	}
 
-	root= of_find_node_by_name(NULL,"screen-on-cmds");
+	root = of_find_node_by_name(NULL, "screen-on-cmds");
 	if (!root) {
-	    MIPI_SCREEN_DBG("can't find screen-on-cmds node\n");
-	}
-	else{
-		for_each_child_of_node(root, childnode){
+		MIPI_SCREEN_DBG("can't find screen-on-cmds node\n");
+	} else {
+		for_each_child_of_node(root, childnode) {
 			dcs_cmd = kmalloc(sizeof(struct mipi_dcs_cmd_ctr_list), GFP_KERNEL);
 			strcpy(dcs_cmd->dcs_cmd.name, childnode->name);
-			
+
 			prop = of_find_property(childnode, "rockchip,cmd", &length);
-			if (!prop){
+			if (!prop) {
 				MIPI_SCREEN_DBG("Can not read property: cmds\n");
 				return -EINVAL;
 			}
 
-			MIPI_SCREEN_DBG("\n childnode->name =%s:length=%d\n",childnode->name,(length / sizeof(u32)));
-			
+			MIPI_SCREEN_DBG("\n childnode->name =%s:length=%d\n", childnode->name, (length / sizeof(u32)));
+
 			ret = of_property_read_u32_array(childnode,  "rockchip,cmd", cmds, (length / sizeof(u32)));
-			if(ret < 0) {
-				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmds\n", __func__,childnode->name);
+			if (ret < 0) {
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmds\n", __func__, childnode->name);
 				return ret;
-			}
-			else{
-				dcs_cmd->dcs_cmd.cmd_len =  length / sizeof(u32) ;
-				
-				for(i = 0; i < (length / sizeof(u32)); i++){   
-					MIPI_SCREEN_DBG("cmd[%d]=%02x£¬",i+1,cmds[i]);
+			} else {
+				dcs_cmd->dcs_cmd.cmd_len =  length / sizeof(u32);
+				for (i = 0; i < (length / sizeof(u32)); i++) {
+					MIPI_SCREEN_DBG("cmd[%d]=%02x£¬", i+1, cmds[i]);
 					dcs_cmd->dcs_cmd.cmds[i] = cmds[i];
 				}
-				
-				MIPI_SCREEN_DBG("dcs_cmd->dcs_cmd.cmd_len=%d\n",dcs_cmd->dcs_cmd.cmd_len);
+
+				MIPI_SCREEN_DBG("dcs_cmd->dcs_cmd.cmd_len=%d\n", dcs_cmd->dcs_cmd.cmd_len);
 			}
 			ret = of_property_read_u32(childnode, "rockchip,dsi_id", &value);
-			if(ret){
-				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__,childnode->name);
-			}
-			else{
-				if(screen->mipi_dsi_num ==1 ){
-					if(value != 0) {
+			if (ret) {
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__, childnode->name);
+			} else {
+				if (screen->mipi_dsi_num == 1) {
+					if (value != 0) {
 						printk("err: rockchip,dsi_id not match.\n");
-					}
-					else
+					} else {
 						dcs_cmd->dcs_cmd.dsi_id = value;
-				}
-				else {
-					if((value < 0) || ( value > 2)) 
+					}
+				} else {
+					if ((value < 0) || (value > 2))
 						printk("err: rockchip,dsi_id not match.\n");
 					else
 						dcs_cmd->dcs_cmd.dsi_id = value;
 				}
 			}
-			 
+
 			ret = of_property_read_u32(childnode, "rockchip,cmd_type", &value);
-			if(ret){
-			    MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__,childnode->name);
-			}
-			else{
-			    if((value != 0) && (value != 1)){
-			        printk("err: rockchip, cmd_type not match.\n");
-			    }
-			    else
-			        dcs_cmd->dcs_cmd.type = value;
+			if (ret) {
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_type\n", __func__, childnode->name);
+			} else {
+				if ((value != 0) && (value != 1)) {
+					printk("err: rockchip, cmd_type not match.\n");
+				} else {
+					dcs_cmd->dcs_cmd.type = value;
+				}
 			}
 
 			ret = of_property_read_u32(childnode, "rockchip,cmd_delay", &value);
-			if(ret)
-			    MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_delay\n", __func__,childnode->name);
+			if (ret)
+				MIPI_SCREEN_DBG("%s: Can not read property: %s--->cmd_delay\n", __func__, childnode->name);
 			else
-			    dcs_cmd->dcs_cmd.delay = value;
+				dcs_cmd->dcs_cmd.delay = value;
 
 			list_add_tail(&dcs_cmd->list, &screen->cmdlist_head);
 		}
 	}
 	ret = of_property_read_u32(root, "rockchip,cmd_debug", &debug);
-	if(ret){
+	if (ret) {
 		MIPI_SCREEN_DBG("%s: Can not read property: rockchip,cmd_debug.\n", __func__);
-	}
-	else{
+	} else {
 		if (debug) {
 			list_for_each(pos, &screen->cmdlist_head) {
 				dcs_cmd = list_entry(pos, struct mipi_dcs_cmd_ctr_list, list);
 				printk("\n dcs_name:%s,dcs_type:%d,side_id:%d,cmd_len:%d,delay:%d\n\n",
 					dcs_cmd->dcs_cmd.name,
-					dcs_cmd->dcs_cmd.type, 
+					dcs_cmd->dcs_cmd.type,
 					dcs_cmd->dcs_cmd.dsi_id,
 					dcs_cmd->dcs_cmd.cmd_len,
 					dcs_cmd->dcs_cmd.delay);
-				for(i=0; i < (dcs_cmd->dcs_cmd.cmd_len) ;i++){
-					printk("[%d]=%02x,",i+1,dcs_cmd->dcs_cmd.cmds[i]);
+				for (i = 0; i < (dcs_cmd->dcs_cmd.cmd_len); i++) {
+					printk("[%d]=%02x,", i+1, dcs_cmd->dcs_cmd.cmds[i]);
 				}
 			}
-		}
-		else
+		} else {
 			MIPI_SCREEN_DBG("---close cmd debug---\n");
+		}
 	}
-	return 0; 
+	return 0;
 }
 #endif
 int rk_mipi_get_dsi_num(void)
@@ -557,7 +520,7 @@ EXPORT_SYMBOL(rk_mipi_get_dsi_lane);
 
 int rk_mipi_get_dsi_clk(void)
 {
-    return gmipi_screen->hs_tx_clk;
+	return gmipi_screen->hs_tx_clk;
 }
 #ifdef CONFIG_LCD_MIPI
 EXPORT_SYMBOL(rk_mipi_get_dsi_clk);
@@ -566,189 +529,189 @@ EXPORT_SYMBOL(rk_mipi_get_dsi_clk);
 #ifdef CONFIG_OF_LIBFDT
 static int rk_mipi_screen_init_dt(struct mipi_screen *screen)
 {
-    struct mipi_dcs_cmd_ctr_list  *dcs_cmd;
-    u32 i,cmds[20];
-    int length;
-    int err;
-    int node;
-    const void *blob;
-    struct fdt_gpio_state gpio_val;
-    int noffset;
-    
-    INIT_LIST_HEAD(&screen->cmdlist_head);
-
-    blob = gd->fdt_blob;//getenv_hex("fdtaddr", 0);
-    node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_INIT);
-    if(node < 0){
-    	MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_INIT\n");
-    }
-    screen->screen_init = fdtdec_get_int(blob, node, "rockchip,screen_init", -1);
-    if(screen->screen_init < 0){
-    	MIPI_SCREEN_DBG("Can not get screen_init\n");
-    }
-    screen->dsi_lane = fdtdec_get_int(blob, node, "rockchip,dsi_lane", -1);
-    if(screen->dsi_lane < 0){
-    	MIPI_SCREEN_DBG("Can not get dsi_lane\n");
-    }
-    screen->hs_tx_clk= fdtdec_get_int(blob, node, "rockchip,dsi_hs_clk", -1);
-    if(screen->hs_tx_clk < 0){
-    	MIPI_SCREEN_DBG("Can not get dsi_hs_clk\n");
-    }else{
-    	screen->hs_tx_clk = screen->hs_tx_clk*MHZ;
-    }
-    screen->mipi_dsi_num= fdtdec_get_int(blob, node, "rockchip,mipi_dsi_num", -1);
-    if(screen->mipi_dsi_num < 0){
-    	MIPI_SCREEN_DBG("Can't get mipi_dsi_num\n");
-    }
-    #if 0   
-    node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
-    if(node < 0){
-    	printf("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
-    }
-    #endif
+	struct mipi_dcs_cmd_ctr_list *dcs_cmd;
+	u32 i, cmds[20];
+	int length;
+	int err;
+	int node;
+	const void *blob;
+	struct fdt_gpio_state gpio_val;
+	int noffset;
+
+	INIT_LIST_HEAD(&screen->cmdlist_head);
+
+	blob = gd->fdt_blob; /* getenv_hex("fdtaddr", 0); */
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_INIT);
+	if (node < 0) {
+		MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_INIT\n");
+	}
+	screen->screen_init = fdtdec_get_int(blob, node, "rockchip,screen_init", -1);
+	if (screen->screen_init < 0) {
+		MIPI_SCREEN_DBG("Can not get screen_init\n");
+	}
+	screen->dsi_lane = fdtdec_get_int(blob, node, "rockchip,dsi_lane", -1);
+	if (screen->dsi_lane < 0) {
+		MIPI_SCREEN_DBG("Can not get dsi_lane\n");
+	}
+	screen->hs_tx_clk = fdtdec_get_int(blob, node, "rockchip,dsi_hs_clk", -1);
+	if (screen->hs_tx_clk < 0) {
+		MIPI_SCREEN_DBG("Can not get dsi_hs_clk\n");
+	} else {
+		screen->hs_tx_clk = screen->hs_tx_clk*MHZ;
+	}
+	screen->mipi_dsi_num = fdtdec_get_int(blob, node, "rockchip,mipi_dsi_num", -1);
+	if (screen->mipi_dsi_num < 0) {
+		MIPI_SCREEN_DBG("Can't get mipi_dsi_num\n");
+	}
+#if 0
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
+	if (node < 0) {
+		printf("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
+	}
+#endif
 
 #if 0
-    /*get the lcd rst status*/    
-//    handle = fdt_getprop_u32_default(blob, "/mipi_power_ctr", "mipi_lcd_rst", -1);
-//    node = fdt_node_offset_by_phandle(blob, handle);
-    node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
-    if(node < 0){
-        printf("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
-    }else{
-        subnode = fdtdec_next_compatible_subnode(blob, node,
+/*get the lcd rst status
+	handle = fdt_getprop_u32_default(blob, "/mipi_power_ctr", "mipi_lcd_rst", -1);
+	node = fdt_node_offset_by_phandle(blob, handle);
+*/
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
+	if (node < 0) {
+		printf("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
+	} else {
+		subnode = fdtdec_next_compatible_subnode(blob, node,
 				COMPAT_ROCKCHIP_MIPI_LCD_RST, &depth);
-	if (subnode <=0) {
-	    screen->lcd_rst_gpio = INVALID_GPIO;
-	    printf("Can't get pin of mipi_lcd_rst\n");
+		if (subnode <= 0) {
+			screen->lcd_rst_gpio = INVALID_GPIO;
+			printf("Can't get pin of mipi_lcd_rst\n");
+		} else {
+			err = fdtdec_decode_gpio(blob, subnode, "rockchip,gpios", &gpio_val);
+			gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
+			if (err < 0) {
+				screen->lcd_rst_gpio = INVALID_GPIO;
+				printf("Can't find GPIO rst\n");
+			} else {
+				screen->lcd_rst_gpio = gpio_val.gpio;
+				screen->lcd_rst_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
+			}
+			screen->lcd_rst_delay = fdtdec_get_int(blob, subnode, "rockchip,delay", -1);
+			if (screen->lcd_rst_delay < 0) {
+				printf("Can't get delay of rst delay\n");
+			}
+			printf("Get lcd rst gpio and delay successfully!\n");
+		}
+	}
+#endif
+	/* get the lcd rst & en status */
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
+	if (node < 0) {
+		MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
 	} else {
-	   err = fdtdec_decode_gpio(blob, subnode, "rockchip,gpios", &gpio_val);
-	   gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
-	    if(err < 0){    
-		screen->lcd_rst_gpio = INVALID_GPIO;
-		printf("Can't find GPIO rst\n");
-	    }else{
-		screen->lcd_rst_gpio = gpio_val.gpio;
-		screen->lcd_rst_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
-	    }	    
-	    screen->lcd_rst_delay = fdtdec_get_int(blob, subnode, "rockchip,delay", -1);
-	    if(screen->lcd_rst_delay < 0){
-		printf("Can't get delay of rst delay\n");
-	    }
-	    printf("Get lcd rst gpio and delay successfully!\n");
+#if 0
+		noffset = fdt_first_subnode(blob, node);
+		const char *name = fdt_get_name(blob, noffset, NULL);
+		printf("XJH_DEBUG1:%s\n", name);
+		noffset = fdt_next_subnode(blob, noffset);
+		const char *name1 = fdt_get_name(blob, noffset, NULL);
+		printf("XJH_DEBUG2:%s\n", name1);
+#endif
+		for (noffset = fdt_first_subnode(blob, node);
+		noffset >= 0;
+		noffset = fdt_next_subnode(blob, noffset)) {
+			if (0 == fdt_node_check_compatible(blob, noffset, "rockchip,lcd_rst")) {
+				err = fdtdec_decode_gpio(blob, noffset, "rockchip,gpios", &gpio_val);
+				gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
+				if (err < 0) {
+					screen->lcd_rst_gpio = INVALID_GPIO;
+					MIPI_SCREEN_DBG("Can't find GPIO rst\n");
+				} else {
+					screen->lcd_rst_gpio = gpio_val.gpio;
+					screen->lcd_rst_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
+				}
+				screen->lcd_rst_delay = fdtdec_get_int(blob, noffset, "rockchip,delay", -1);
+				if (screen->lcd_rst_delay < 0) {
+					MIPI_SCREEN_DBG("Can't get delay of rst delay\n");
+				}
+				MIPI_SCREEN_DBG("Get lcd rst gpio and delay successfully!\n");
+			}
+			if (0 == fdt_node_check_compatible(blob, noffset, "rockchip,lcd_en")) {
+				err = fdtdec_decode_gpio(blob, noffset, "rockchip,gpios", &gpio_val);
+				gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
+				if (err < 0) {
+					screen->lcd_en_gpio = INVALID_GPIO;
+					MIPI_SCREEN_DBG("Can't find GPIO en\n");
+				} else {
+					screen->lcd_en_gpio = gpio_val.gpio;
+					screen->lcd_en_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
+				}
+				screen->lcd_en_delay = fdtdec_get_int(blob, noffset, "rockchip,delay", -1);
+				if (screen->lcd_en_delay < 0) {
+					MIPI_SCREEN_DBG("Can't get delay of lcd_en delay\n");
+				}
+				MIPI_SCREEN_DBG("Get lcd en gpio and delay successfully:delay %d!\n", screen->lcd_en_delay);
+			}
+		}
 	}
-    }
-    #endif
-	/*get the lcd rst & en status*/
-    node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_PWR);
-    if(node < 0){
-        MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_PWR\n");
-    }else{	
-	#if 0
-	noffset = fdt_first_subnode(blob,node);
-	const char *name = fdt_get_name(blob, noffset, NULL);
-	printf("XJH_DEBUG1:%s\n",name);
-	noffset = fdt_next_subnode(blob,noffset);
-	const char *name1 = fdt_get_name(blob, noffset, NULL);
-	printf("XJH_DEBUG2:%s\n",name1);	
-        #endif
-	for (noffset = fdt_first_subnode(blob,node);
-	     noffset >= 0;
-	     noffset = fdt_next_subnode(blob, noffset)) {
-	    if ( 0 == fdt_node_check_compatible(blob, noffset, "rockchip,lcd_rst")){
-                err = fdtdec_decode_gpio(blob, noffset, "rockchip,gpios", &gpio_val);
-                gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
-                if(err < 0){    
-                    screen->lcd_rst_gpio = INVALID_GPIO;
-                    MIPI_SCREEN_DBG("Can't find GPIO rst\n");
-                }else{
-                    screen->lcd_rst_gpio = gpio_val.gpio;
-                    screen->lcd_rst_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
-	        }	    
-	        screen->lcd_rst_delay = fdtdec_get_int(blob, noffset, "rockchip,delay", -1);
-	        if(screen->lcd_rst_delay < 0){
-		    MIPI_SCREEN_DBG("Can't get delay of rst delay\n");
-	        }
-	        MIPI_SCREEN_DBG("Get lcd rst gpio and delay successfully!\n");
-	    }
-	    if ( 0 == fdt_node_check_compatible(blob, noffset, "rockchip,lcd_en")){
-	    
-	        err = fdtdec_decode_gpio(blob, noffset, "rockchip,gpios", &gpio_val);
-	         gpio_val.gpio = rk_gpio_base_to_bank(gpio_val.gpio & RK_GPIO_BANK_MASK) | (gpio_val.gpio & RK_GPIO_PIN_MASK);
-	        if(err < 0){    
-	            screen->lcd_en_gpio = INVALID_GPIO;
-	            MIPI_SCREEN_DBG("Can't find GPIO en\n");
-                }else{
-                    screen->lcd_en_gpio = gpio_val.gpio;
-                    screen->lcd_en_atv_val = !(gpio_val.flags & OF_GPIO_ACTIVE_LOW);
-		}	     
-		screen->lcd_en_delay = fdtdec_get_int(blob, noffset, "rockchip,delay", -1);
-		if(screen->lcd_en_delay < 0){
-		 MIPI_SCREEN_DBG("Can't get delay of lcd_en delay\n");
+
+	/*get the initial command list*/
+	node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_SONCMDS);
+	if (node < 0) {
+		MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_SONCMDS\n");
+	} else {
+		for (noffset = fdt_first_subnode(blob, node);
+		noffset >= 0;
+		noffset = fdt_next_subnode(blob, noffset)) {
+
+			MIPI_SCREEN_DBG("build MIPI LCD init cmd tables\n");
+			/*
+			subnode = fdtdec_next_compatible_subnode(blob, node,
+					COMPAT_ROCKCHIP_MIPI_ONCMDS, &depth);
+			if (noffset < 0)
+				break;
+			*/
+			dcs_cmd = calloc(1, sizeof(struct mipi_dcs_cmd_ctr_list));
+			/* node = fdt_node_offset_by_phandle(blob, handle); */
+			strcpy(dcs_cmd->dcs_cmd.name, fdt_get_name(blob, noffset, NULL));
+			MIPI_SCREEN_DBG("%s\n", dcs_cmd->dcs_cmd.name);
+			dcs_cmd->dcs_cmd.type = fdtdec_get_int(blob, noffset, "rockchip,cmd_type", -1);
+			MIPI_SCREEN_DBG("dcs_cmd.type=%02x\n", dcs_cmd->dcs_cmd.type);
+			dcs_cmd->dcs_cmd.dsi_id = fdtdec_get_int(blob, noffset, "rockchip,dsi_id", -1);
+			MIPI_SCREEN_DBG("dcs_cmd.dsi_id=%02x\n", dcs_cmd->dcs_cmd.dsi_id);
+			fdt_getprop(blob, noffset, "rockchip,cmd", &length);
+			dcs_cmd->dcs_cmd.cmd_len = length / sizeof(u32) ;
+			err = fdtdec_get_int_array(blob, noffset, "rockchip,cmd", cmds, dcs_cmd->dcs_cmd.cmd_len);
+			MIPI_SCREEN_DBG("length=%d,cmd_len = %d  err = %d\n", length, dcs_cmd->dcs_cmd.cmd_len, err);
+			for (i = 0; i < (length / sizeof(u32)); i++) {
+				MIPI_SCREEN_DBG("cmd[%d]=0x%08x, ", i+1, cmds[i]);
+				dcs_cmd->dcs_cmd.cmds[i] = cmds[i];
+			}
+			MIPI_SCREEN_DBG("\n");
+			dcs_cmd->dcs_cmd.delay = fdtdec_get_int(blob, noffset, "rockchip,cmd_delay", -1);
+			MIPI_SCREEN_DBG("dcs_cmd.delay=%d\n", dcs_cmd->dcs_cmd.delay);
+			list_add_tail(&dcs_cmd->list, &screen->cmdlist_head);
 		}
-		MIPI_SCREEN_DBG("Get lcd en gpio and delay successfully:delay %d!\n",screen->lcd_en_delay);
-	    }
 	}
-    }
-
-    /*get the initial command list*/
-    node = fdtdec_next_compatible(blob, 0, COMPAT_ROCKCHIP_MIPI_SONCMDS);
-    if(node < 0){
-        MIPI_SCREEN_DBG("Can not get node of COMPAT_ROCKCHIP_MIPI_SONCMDS\n");
-    }else{
-           for (noffset = fdt_first_subnode(blob,node);
-                 noffset >= 0;
-		 noffset = fdt_next_subnode(blob, noffset)) {
-
-            MIPI_SCREEN_DBG("build MIPI LCD init cmd tables\n");
-	   // subnode = fdtdec_next_compatible_subnode(blob, node,
-	   //			COMPAT_ROCKCHIP_MIPI_ONCMDS, &depth);
-	   // if (noffset < 0)
-	//	break;
-            dcs_cmd = calloc(1,sizeof(struct mipi_dcs_cmd_ctr_list));
-	   //node = fdt_node_offset_by_phandle(blob, handle);
-            strcpy(dcs_cmd->dcs_cmd.name, fdt_get_name(blob, noffset, NULL));
-	    MIPI_SCREEN_DBG("%s\n",dcs_cmd->dcs_cmd.name);
-	    dcs_cmd->dcs_cmd.type = fdtdec_get_int(blob, noffset, "rockchip,cmd_type", -1);
-	    MIPI_SCREEN_DBG("dcs_cmd.type=%02x\n",dcs_cmd->dcs_cmd.type);
-	    dcs_cmd->dcs_cmd.dsi_id = fdtdec_get_int(blob, noffset, "rockchip,dsi_id", -1);
-	    MIPI_SCREEN_DBG("dcs_cmd.dsi_id=%02x\n",dcs_cmd->dcs_cmd.dsi_id);
-	    fdt_getprop(blob, noffset, "rockchip,cmd", &length);
-	    dcs_cmd->dcs_cmd.cmd_len =	length / sizeof(u32) ;
-	    err = fdtdec_get_int_array(blob, noffset, "rockchip,cmd", cmds, dcs_cmd->dcs_cmd.cmd_len);
-	    MIPI_SCREEN_DBG("length=%d,cmd_len = %d  err = %d\n",length,dcs_cmd->dcs_cmd.cmd_len,err);
-	    for(i = 0; i < (length / sizeof(u32)); i++){   
-	       MIPI_SCREEN_DBG("cmd[%d]=0x%08x, ",i+1,cmds[i]);
-	       dcs_cmd->dcs_cmd.cmds[i] = cmds[i];
-	    }	    
-	    MIPI_SCREEN_DBG("\n");
-	    dcs_cmd->dcs_cmd.delay = fdtdec_get_int(blob, noffset, "rockchip,cmd_delay", -1);
-	    MIPI_SCREEN_DBG("dcs_cmd.delay=%d\n",dcs_cmd->dcs_cmd.delay);
-	    list_add_tail(&dcs_cmd->list, &screen->cmdlist_head);
-        }
-    }
-
-    return 0; 
+	return 0;
 }
 #endif /* CONFIG_OF_LIBFDT */
 
 int rk_mipi_screen_probe(void)
 {
-    int ret = 0;
-    gmipi_screen = calloc(1, sizeof(struct mipi_screen));
-	if(!gmipi_screen) {
+	int ret = 0;
+	gmipi_screen = calloc(1, sizeof(struct mipi_screen));
+	if (!gmipi_screen) {
 		printf("request struct screen fail!\n");
 		return -ENOMEM;
 	}
 #ifdef CONFIG_OF_LIBFDT
 	ret = rk_mipi_screen_init_dt(gmipi_screen);
-	if(ret < 0){
+	if (ret < 0) {
 		printf(" rk_mipi_screen_init_dt fail!\n");
 		return -1;
 	}
 #endif /* CONFIG_OF_LIBFDT */
 
-//    MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
-
+	MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
 	return 0;
 }
 
@@ -756,22 +719,21 @@ int rk_mipi_screen_probe(void)
 #ifdef CONFIG_LCD_MIPI
 static int __init rk_mipi_screen_probe(struct platform_device *pdev)
 {
-	static int ret = 0;
+	static int ret;
 
 	gmipi_screen = devm_kzalloc(&pdev->dev, sizeof(struct mipi_screen), GFP_KERNEL);
-	if(!gmipi_screen) {
-		dev_err(&pdev->dev,"request struct screen fail!\n");
+	if (!gmipi_screen) {
+		dev_err(&pdev->dev, "request struct screen fail!\n");
 		return -ENOMEM;
 	}
-	
+
 	ret = rk_mipi_screen_init_dt(gmipi_screen);
-	if(ret < 0){
-		dev_err(&pdev->dev," rk_mipi_screen_init_dt fail!\n");
+	if (ret < 0) {
+		dev_err(&pdev->dev, " rk_mipi_screen_init_dt fail!\n");
 		return -1;
 	}
-	
-	MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
 
+	MIPI_SCREEN_DBG("---rk_mipi_screen_probe--end\n");
 	return 0;
 }
 
diff --git a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
index 923c648d4413..e2f0cbe5a3b1 100755
--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c
@@ -3,7 +3,7 @@
  * drivers/video/display/transmitter/rk32_mipi_dsi.c
  * author: libing@rock-chips.com
  * create date: 2014-04-10
- * debug /sys/kernel/debug/mipidsi* 
+ * debug /sys/kernel/debug/mipidsi*
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
  * may be copied, distributed, and modified under those terms.
@@ -14,7 +14,7 @@
  * GNU General Public License for more details.
  */
 
-//config
+/* config */
 #ifndef CONFIG_RK32_MIPI_DSI
 #include <common.h>
 #endif
@@ -49,18 +49,17 @@
 #include <linux/rockchip/iomap.h>
 #include <linux/rockchip/cpu.h>
 
-#define	MIPI_DBG(x...)	//printk(KERN_INFO x)
+#define	MIPI_DBG(x...)	/* printk(KERN_INFO x) */
 
 #ifdef CONFIG_MIPI_DSI_LINUX
-#define	MIPI_TRACE(x...)	//printk(KERN_INFO x)
+#define	MIPI_TRACE(x...)	/* printk(KERN_INFO x) */
 #else
 #define	MIPI_TRACE(...)    \
-	do\
-	{\
+	do {\
 		printf(__VA_ARGS__);\
 		printf("\n");\
-	}while(0);
-	
+	} while (0);
+
 #endif
 
 /*
@@ -90,9 +89,9 @@ static int rk32_dsi_read_reg(struct dsi *dsi, u16 reg, u32 *pval)
 	if (dsi->ops.id == DWC_DSI_VERSION)
 		*pval = __raw_readl(dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
 	else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
-		if(reg >= MIPI_DSI_HOST_OFFSET)
+		if (reg >= MIPI_DSI_HOST_OFFSET)
 			*pval = __raw_readl(dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
-		else if(reg >= MIPI_DSI_PHY_OFFSET)
+		else if (reg >= MIPI_DSI_PHY_OFFSET)
 			*pval = __raw_readl(dsi->phy.membase + (reg - MIPI_DSI_PHY_OFFSET));
 	}
 	return 0;
@@ -103,10 +102,10 @@ static int rk32_dsi_write_reg(struct dsi *dsi, u16 reg, u32 *pval)
 	if (dsi->ops.id == DWC_DSI_VERSION)
 		__raw_writel(*pval, dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
 	else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
-		if(reg >= MIPI_DSI_HOST_OFFSET)
+		if (reg >= MIPI_DSI_HOST_OFFSET)
 			__raw_writel(*pval, dsi->host.membase + (reg - MIPI_DSI_HOST_OFFSET));
-		else if(reg >= MIPI_DSI_PHY_OFFSET)
-			__raw_writel(*pval, dsi->phy.membase + (reg - MIPI_DSI_PHY_OFFSET));	
+		else if (reg >= MIPI_DSI_PHY_OFFSET)
+			__raw_writel(*pval, dsi->phy.membase + (reg - MIPI_DSI_PHY_OFFSET));
 	}
 	return 0;
 }
@@ -117,43 +116,41 @@ static int rk32_dsi_get_bits(struct dsi *dsi, u32 reg)
 	u32 bits = (reg >> 8) & 0xff;
 	u16 reg_addr = (reg >> 16) & 0xffff;
 	u8 offset = reg & 0xff;
-	
-	if(bits < 32)
+
+	if (bits < 32)
 		bits = (1 << bits) - 1;
 	else
 		bits = 0xffffffff;
-	
+
 	rk32_dsi_read_reg(dsi, reg_addr, &val);
 	val >>= offset;
 	val &= bits;
-	
 	return val;
 }
 
-static int rk32_dsi_set_bits(struct dsi *dsi, u32 data, u32 reg) 
+static int rk32_dsi_set_bits(struct dsi *dsi, u32 data, u32 reg)
 {
-	static u32 val = 0;
+	static u32 val;
 	u32 bits = (reg >> 8) & 0xff;
 	u16 reg_addr = (reg >> 16) & 0xffff;
 	u8 offset = reg & 0xff;
-	
-	if(bits < 32)
+
+	if (bits < 32)
 		bits = (1 << bits) - 1;
 	else
 		bits = 0xffffffff;
 
-	if(bits != 0xffffffff)
+	if (bits != 0xffffffff)
 		rk32_dsi_read_reg(dsi, reg_addr, &val);
 
 	val &= ~(bits << offset);
 	val |= (data & bits) << offset;
 	rk32_dsi_write_reg(dsi, reg_addr, &val);
 
-	if(data > bits) {
-		MIPI_TRACE("%s error reg_addr:0x%04x, offset:%d, bits:0x%04x, value:0x%04x\n", 
+	if (data > bits) {
+		MIPI_TRACE("%s error reg_addr:0x%04x, offset:%d, bits:0x%04x, value:0x%04x\n",
 				__func__, reg_addr, offset, bits, data);
 	}
-	
 	return 0;
 }
 #if 0
@@ -167,7 +164,7 @@ static int rk32_dwc_phy_test_rd(struct dsi *dsi, unsigned char test_code)
 	rk32_dsi_set_bits(dsi, 0, phy_testen);;
 
 	rk32_dsi_set_bits(dsi, 0, phy_testen);
-	val = rk32_dsi_get_bits(dsi,phy_testdout);
+	val = rk32_dsi_get_bits(dsi, phy_testdout);
 	rk32_dsi_set_bits(dsi, 1, phy_testclk);
 	rk32_dsi_set_bits(dsi, 0, phy_testclk);
 
@@ -177,13 +174,13 @@ static int rk32_dwc_phy_test_rd(struct dsi *dsi, unsigned char test_code)
 static int rk32_dwc_phy_test_wr(struct dsi *dsi, unsigned char test_code, unsigned char *test_data, unsigned char size)
 {
 	int i = 0;
-	
-	MIPI_DBG("test_code=0x%x,test_data=0x%x\n", test_code,test_data[0]);
+
+	MIPI_DBG("test_code=0x%x,test_data=0x%x\n", test_code, test_data[0]);
 	rk32_dsi_set_bits(dsi, 0x10000 | test_code, PHY_TEST_CTRL1);
 	rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
 	rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
 
-	for(i = 0; i < size; i++) {
+	for (i = 0; i < size; i++) {
 		rk32_dsi_set_bits(dsi, test_data[i], PHY_TEST_CTRL1);
 		rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
 		rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
@@ -194,217 +191,215 @@ static int rk32_dwc_phy_test_wr(struct dsi *dsi, unsigned char test_code, unsign
 
 static int rk32_phy_power_up(struct dsi *dsi)
 {
-    //enable ref clock
-    clk_prepare_enable(dsi->phy.refclk); 
-    clk_prepare_enable(dsi->dsi_pclk);
-    clk_prepare_enable(dsi->dsi_pd);
-    udelay(10);
-
-	switch(dsi->host.lane) {
-		case 4:
-			rk32_dsi_set_bits(dsi, 3, n_lanes);
-			break;
-		case 3:
-			rk32_dsi_set_bits(dsi, 2, n_lanes);
-			break;
-		case 2:
-			rk32_dsi_set_bits(dsi, 1, n_lanes);
-			break;
-		case 1:
-			rk32_dsi_set_bits(dsi, 0, n_lanes);
-			break;
-		default:
-			break;	
+	/* enable ref clock */
+	clk_prepare_enable(dsi->phy.refclk);
+	clk_prepare_enable(dsi->dsi_pclk);
+	clk_prepare_enable(dsi->dsi_pd);
+	udelay(10);
+
+	switch (dsi->host.lane) {
+	case 4:
+		rk32_dsi_set_bits(dsi, 3, n_lanes);
+		break;
+	case 3:
+		rk32_dsi_set_bits(dsi, 2, n_lanes);
+		break;
+	case 2:
+		rk32_dsi_set_bits(dsi, 1, n_lanes);
+		break;
+	case 1:
+		rk32_dsi_set_bits(dsi, 0, n_lanes);
+		break;
+	default:
+		break;
 	}
 	rk32_dsi_set_bits(dsi, 1, phy_shutdownz);
-	rk32_dsi_set_bits(dsi, 1, phy_rstz);  
+	rk32_dsi_set_bits(dsi, 1, phy_rstz);
 	rk32_dsi_set_bits(dsi, 1, phy_enableclk);
 	rk32_dsi_set_bits(dsi, 1, phy_forcepll);
-	
+
 	return 0;
 }
 
-static int rk312x_mipi_dsi_phy_set_gotp(struct dsi *dsi, u32 offset, int n) 
+static int rk312x_mipi_dsi_phy_set_gotp(struct dsi *dsi, u32 offset, int n)
 {
 	u32 val = 0, temp = 0, Tlpx = 0;
 	u32 ddr_clk = dsi->phy.ddr_clk;
 	u32 Ttxbyte_clk = dsi->phy.Ttxbyte_clk;
 	u32 Tsys_clk = dsi->phy.Tsys_clk;
 	u32 Ttxclkesc = dsi->phy.Ttxclkesc;
-	printk("%s : ddr_clk %d\n",__func__, ddr_clk);
-	switch(offset) {
-		case DPHY_CLOCK_OFFSET:
-			MIPI_DBG("******set DPHY_CLOCK_OFFSET gotp******\n");
-			break;
-		case DPHY_LANE0_OFFSET:
-			MIPI_DBG("******set DPHY_LANE0_OFFSET gotp******\n");
-			break;
-		case DPHY_LANE1_OFFSET:
-			MIPI_DBG("******set DPHY_LANE1_OFFSET gotp******\n");
-			break;
-		case DPHY_LANE2_OFFSET:
-			MIPI_DBG("******set DPHY_LANE2_OFFSET gotp******\n");
-			break;
-		case DPHY_LANE3_OFFSET:
-			MIPI_DBG("******set DPHY_LANE3_OFFSET gotp******\n");
-			break;
-		default:
-			break;					
+	printk("%s : ddr_clk %d\n", __func__, ddr_clk);
+	switch (offset) {
+	case DPHY_CLOCK_OFFSET:
+		MIPI_DBG("******set DPHY_CLOCK_OFFSET gotp******\n");
+		break;
+	case DPHY_LANE0_OFFSET:
+		MIPI_DBG("******set DPHY_LANE0_OFFSET gotp******\n");
+		break;
+	case DPHY_LANE1_OFFSET:
+		MIPI_DBG("******set DPHY_LANE1_OFFSET gotp******\n");
+		break;
+	case DPHY_LANE2_OFFSET:
+		MIPI_DBG("******set DPHY_LANE2_OFFSET gotp******\n");
+		break;
+	case DPHY_LANE3_OFFSET:
+		MIPI_DBG("******set DPHY_LANE3_OFFSET gotp******\n");
+		break;
+	default:
+		break;
 	}
-	
-	if(ddr_clk < 110 * MHz)
+
+	if (ddr_clk < 110 * MHz)
 		val = 0;
-	else if(ddr_clk < 150 * MHz)
+	else if (ddr_clk < 150 * MHz)
 		val = 1;
-	else if(ddr_clk < 200 * MHz)
+	else if (ddr_clk < 200 * MHz)
 		val = 2;
-	else if(ddr_clk < 250 * MHz)
+	else if (ddr_clk < 250 * MHz)
 		val = 3;
-	else if(ddr_clk < 300 * MHz)
+	else if (ddr_clk < 300 * MHz)
 		val = 4;
-	else if(ddr_clk < 400 * MHz)
-		val = 5;		
-	else if(ddr_clk < 500 * MHz)
-		val = 6;		
-	else if(ddr_clk < 600 * MHz)
-		val = 7;		
-	else if(ddr_clk < 700 * MHz)
+	else if (ddr_clk < 400 * MHz)
+		val = 5;
+	else if (ddr_clk < 500 * MHz)
+		val = 6;
+	else if (ddr_clk < 600 * MHz)
+		val = 7;
+	else if (ddr_clk < 700 * MHz)
 		val = 8;
-	else if(ddr_clk < 800 * MHz)
-		val = 9;		
-	else if(ddr_clk <= 1000 * MHz)
+	else if (ddr_clk < 800 * MHz)
+		val = 9;
+	else if (ddr_clk <= 1000 * MHz)
 		val = 10;
-	printk("%s reg_ths_settle = 0x%x\n",__func__, val);
+	printk("%s reg_ths_settle = 0x%x\n", __func__, val);
 	rk32_dsi_set_bits(dsi, val, reg_ths_settle + offset);
-	
-	if(ddr_clk < 110 * MHz)
+
+	if (ddr_clk < 110 * MHz)
 		val = 0x20;
-	else if(ddr_clk < 150 * MHz)
+	else if (ddr_clk < 150 * MHz)
 		val = 0x06;
-	else if(ddr_clk < 200 * MHz)
+	else if (ddr_clk < 200 * MHz)
 		val = 0x18;
-	else if(ddr_clk < 250 * MHz)
+	else if (ddr_clk < 250 * MHz)
 		val = 0x05;
-	else if(ddr_clk < 300 * MHz)
+	else if (ddr_clk < 300 * MHz)
 		val = 0x51;
-	else if(ddr_clk < 400 * MHz)
-		val = 0x64;		
-	else if(ddr_clk < 500 * MHz)
-		val = 0x59;		
-	else if(ddr_clk < 600 * MHz)
-		val = 0x6a;		
-	else if(ddr_clk < 700 * MHz)
+	else if (ddr_clk < 400 * MHz)
+		val = 0x64;
+	else if (ddr_clk < 500 * MHz)
+		val = 0x59;
+	else if (ddr_clk < 600 * MHz)
+		val = 0x6a;
+	else if (ddr_clk < 700 * MHz)
 		val = 0x3e;
-	else if(ddr_clk < 800 * MHz)
+	else if (ddr_clk < 800 * MHz)
 		val = 0x21;
-	else if(ddr_clk <= 1000 * MHz)
+	else if (ddr_clk <= 1000 * MHz)
 		val = 0x09;
-	printk("%s reg_hs_ths_prepare = 0x%x\n",__func__, val);
+	printk("%s reg_hs_ths_prepare = 0x%x\n", __func__, val);
 	rk32_dsi_set_bits(dsi, val, reg_hs_ths_prepare + offset);
 
-	if(offset != DPHY_CLOCK_OFFSET) {
-	
-		if(ddr_clk < 110 * MHz)
+	if (offset != DPHY_CLOCK_OFFSET) {
+		if (ddr_clk < 110 * MHz)
 			val = 2;
-		else if(ddr_clk < 150 * MHz)
+		else if (ddr_clk < 150 * MHz)
 			val = 3;
-		else if(ddr_clk < 200 * MHz)
+		else if (ddr_clk < 200 * MHz)
 			val = 4;
-		else if(ddr_clk < 250 * MHz)
+		else if (ddr_clk < 250 * MHz)
 			val = 5;
-		else if(ddr_clk < 300 * MHz)
+		else if (ddr_clk < 300 * MHz)
 			val = 6;
-		else if(ddr_clk < 400 * MHz)
-			val = 7;		
-		else if(ddr_clk < 500 * MHz)
-			val = 7;		
-		else if(ddr_clk < 600 * MHz)
-			val = 8;		
-		else if(ddr_clk < 700 * MHz)
+		else if (ddr_clk < 400 * MHz)
+			val = 7;
+		else if (ddr_clk < 500 * MHz)
+			val = 7;
+		else if (ddr_clk < 600 * MHz)
+			val = 8;
+		else if (ddr_clk < 700 * MHz)
 			val = 8;
-		else if(ddr_clk < 800 * MHz)
-			val = 9;		
-		else if(ddr_clk <= 1000 * MHz)
-			val = 9;	
+		else if (ddr_clk < 800 * MHz)
+			val = 9;
+		else if (ddr_clk <= 1000 * MHz)
+			val = 9;
 	} else {
-	
-		if(ddr_clk < 110 * MHz)
+		if (ddr_clk < 110 * MHz)
 			val = 0x16;
-		else if(ddr_clk < 150 * MHz)
+		else if (ddr_clk < 150 * MHz)
 			val = 0x16;
-		else if(ddr_clk < 200 * MHz)
+		else if (ddr_clk < 200 * MHz)
 			val = 0x17;
-		else if(ddr_clk < 250 * MHz)
+		else if (ddr_clk < 250 * MHz)
 			val = 0x17;
-		else if(ddr_clk < 300 * MHz)
+		else if (ddr_clk < 300 * MHz)
 			val = 0x18;
-		else if(ddr_clk < 400 * MHz)
-			val = 0x19;		
-		else if(ddr_clk < 500 * MHz)
-			val = 0x1b;		
-		else if(ddr_clk < 600 * MHz)
-			val = 0x1d;		
-		else if(ddr_clk < 700 * MHz)
+		else if (ddr_clk < 400 * MHz)
+			val = 0x19;
+		else if (ddr_clk < 500 * MHz)
+			val = 0x1b;
+		else if (ddr_clk < 600 * MHz)
+			val = 0x1d;
+		else if (ddr_clk < 700 * MHz)
 			val = 0x1e;
-		else if(ddr_clk < 800 * MHz)
-			val = 0x1f;		
-		else if(ddr_clk <= 1000 * MHz)
-			val = 0x20;	
-	}	
-	printk("%s reg_hs_the_zero = 0x%x\n",__func__, val);
+		else if (ddr_clk < 800 * MHz)
+			val = 0x1f;
+		else if (ddr_clk <= 1000 * MHz)
+			val = 0x20;
+	}
+	printk("%s reg_hs_the_zero = 0x%x\n", __func__, val);
 	rk32_dsi_set_bits(dsi, val, reg_hs_the_zero + offset);
-	
-	if(ddr_clk < 110 * MHz)
+
+	if (ddr_clk < 110 * MHz)
 		val = 0x22;
-	else if(ddr_clk < 150 * MHz)
+	else if (ddr_clk < 150 * MHz)
 		val = 0x45;
-	else if(ddr_clk < 200 * MHz)
+	else if (ddr_clk < 200 * MHz)
 		val = 0x0b;
-	else if(ddr_clk < 250 * MHz)
+	else if (ddr_clk < 250 * MHz)
 		val = 0x16;
-	else if(ddr_clk < 300 * MHz)
+	else if (ddr_clk < 300 * MHz)
 		val = 0x2c;
-	else if(ddr_clk < 400 * MHz)
-		val = 0x33;		
-	else if(ddr_clk < 500 * MHz)
-		val = 0x4e;		
-	else if(ddr_clk < 600 * MHz)
-		val = 0x3a;		
-	else if(ddr_clk < 700 * MHz)
+	else if (ddr_clk < 400 * MHz)
+		val = 0x33;
+	else if (ddr_clk < 500 * MHz)
+		val = 0x4e;
+	else if (ddr_clk < 600 * MHz)
+		val = 0x3a;
+	else if (ddr_clk < 700 * MHz)
 		val = 0x6a;
-	else if(ddr_clk < 800 * MHz)
-		val = 0x29;		
-	else if(ddr_clk <= 1000 * MHz)
-		val = 0x21;   //0x27
-		
-	printk("%s reg_hs_ths_trail = 0x%x\n",__func__, val);
+	else if (ddr_clk < 800 * MHz)
+		val = 0x29;
+	else if (ddr_clk <= 1000 * MHz)
+		val = 0x21;	/* 0x27 */
+
+	printk("%s reg_hs_ths_trail = 0x%x\n", __func__, val);
 
 	rk32_dsi_set_bits(dsi, val, reg_hs_ths_trail + offset);
 	val = 120000 / Ttxbyte_clk + 1;
 	MIPI_DBG("reg_hs_ths_exit: %d, %d\n", val, val*Ttxbyte_clk/1000);
 	rk32_dsi_set_bits(dsi, val, reg_hs_ths_exit + offset);
-	
-	if(offset == DPHY_CLOCK_OFFSET) {
+
+	if (offset == DPHY_CLOCK_OFFSET) {
 		val = (60000 + 52*dsi->phy.UI) / Ttxbyte_clk + 1;
 		MIPI_DBG("reg_hs_tclk_post: %d, %d\n", val, val*Ttxbyte_clk/1000);
 		rk32_dsi_set_bits(dsi, val, reg_hs_tclk_post + offset);
 		val = 10*dsi->phy.UI / Ttxbyte_clk + 1;
-		MIPI_DBG("reg_hs_tclk_pre: %d, %d\n", val, val*Ttxbyte_clk/1000);	
+		MIPI_DBG("reg_hs_tclk_pre: %d, %d\n", val, val*Ttxbyte_clk/1000);
 		rk32_dsi_set_bits(dsi, val, reg_hs_tclk_pre + offset);
 	}
 
 	val = 1010000000 / Tsys_clk + 1;
 	MIPI_DBG("reg_hs_twakup: %d, %d\n", val, val*Tsys_clk/1000);
-	if(val > 0x3ff) {
+	if (val > 0x3ff) {
 		val = 0x2ff;
-		MIPI_DBG("val is too large, 0x3ff is the largest\n");	
+		MIPI_DBG("val is too large, 0x3ff is the largest\n");
 	}
 	temp = (val >> 8) & 0x03;
-	val &= 0xff;	
-	rk32_dsi_set_bits(dsi, temp, reg_hs_twakup_h + offset);	
+	val &= 0xff;
+	rk32_dsi_set_bits(dsi, temp, reg_hs_twakup_h + offset);
 	rk32_dsi_set_bits(dsi, val, reg_hs_twakup_l + offset);
-	
-	if(Ttxclkesc > 50000) {
+
+	if (Ttxclkesc > 50000) {
 		val = 2*Ttxclkesc;
 		MIPI_DBG("Ttxclkesc:%d\n", Ttxclkesc);
 	}
@@ -413,13 +408,13 @@ static int rk312x_mipi_dsi_phy_set_gotp(struct dsi *dsi, u32 offset, int n)
 	MIPI_DBG("reg_hs_tlpx: %d, %d\n", val, Tlpx);
 	val -= 2;
 	rk32_dsi_set_bits(dsi, val, reg_hs_tlpx + offset);
-	
+
 	Tlpx = 2*Ttxclkesc;
 	val = 4*Tlpx / Ttxclkesc;
 	MIPI_DBG("reg_hs_tta_go: %d, %d\n", val, val*Ttxclkesc);
 	rk32_dsi_set_bits(dsi, val, reg_hs_tta_go + offset);
 	val = 3 * Tlpx / 2 / Ttxclkesc;
-	MIPI_DBG("reg_hs_tta_sure: %d, %d\n", val, val*Ttxclkesc);	
+	MIPI_DBG("reg_hs_tta_sure: %d, %d\n", val, val*Ttxclkesc);
 	rk32_dsi_set_bits(dsi, val, reg_hs_tta_sure + offset);
 	val = 5 * Tlpx / Ttxclkesc;
 	MIPI_DBG("reg_hs_tta_wait: %d, %d\n", val, val*Ttxclkesc);
@@ -427,7 +422,7 @@ static int rk312x_mipi_dsi_phy_set_gotp(struct dsi *dsi, u32 offset, int n)
 	return 0;
 }
 
-static void rk312x_mipi_dsi_set_hs_clk(struct dsi *dsi) 
+static void rk312x_mipi_dsi_set_hs_clk(struct dsi *dsi)
 {
 	rk32_dsi_set_bits(dsi, dsi->phy.prediv, reg_prediv);
 	rk32_dsi_set_bits(dsi, dsi->phy.fbdiv & 0xff, reg_fbdiv);
@@ -436,43 +431,43 @@ static void rk312x_mipi_dsi_set_hs_clk(struct dsi *dsi)
 
 static int rk312x_phy_power_up(struct dsi *dsi)
 {
-	//enable ref clock
+	/* enable ref clock */
 	rk312x_mipi_dsi_set_hs_clk(dsi);
-	clk_prepare_enable(dsi->phy.refclk); 
+	clk_prepare_enable(dsi->phy.refclk);
 	clk_prepare_enable(dsi->dsi_pclk);
 	clk_prepare_enable(dsi->dsi_host_pclk);
 	clk_prepare_enable(dsi->h2p_hclk);
 	clk_prepare_enable(dsi->dsi_pd);
 	udelay(10);
-    
+
 	rk32_dsi_set_bits(dsi, 0xe4, DPHY_REGISTER1);
-	switch(dsi->host.lane) {
-		case 4:
-			rk32_dsi_set_bits(dsi, 1, lane_en_3);
-		case 3:
-			rk32_dsi_set_bits(dsi, 1, lane_en_2);
-		case 2:
-			rk32_dsi_set_bits(dsi, 1, lane_en_1);
-		case 1:
-			rk32_dsi_set_bits(dsi, 1, lane_en_0);
-			rk32_dsi_set_bits(dsi, 1, lane_en_ck);
-			break;
-		default:
-			break;  
+	switch (dsi->host.lane) {
+	case 4:
+		rk32_dsi_set_bits(dsi, 1, lane_en_3);
+	case 3:
+		rk32_dsi_set_bits(dsi, 1, lane_en_2);
+	case 2:
+		rk32_dsi_set_bits(dsi, 1, lane_en_1);
+	case 1:
+		rk32_dsi_set_bits(dsi, 1, lane_en_0);
+		rk32_dsi_set_bits(dsi, 1, lane_en_ck);
+		break;
+	default:
+		break;
 	}
-    
+
 	rk32_dsi_set_bits(dsi, 0xe0, DPHY_REGISTER1);
 	udelay(10);
-    
+
 	rk32_dsi_set_bits(dsi, 0x1e, DPHY_REGISTER20);
 	rk32_dsi_set_bits(dsi, 0x1f, DPHY_REGISTER20);
 
 	rk32_dsi_set_bits(dsi, 1, phy_enableclk);
-	
+
 	return 0;
 }
 
-static int rk_phy_power_up(struct dsi *dsi) 
+static int rk_phy_power_up(struct dsi *dsi)
 {
 	if (dsi->ops.id == DWC_DSI_VERSION)
 		rk32_phy_power_up(dsi);
@@ -483,27 +478,27 @@ static int rk_phy_power_up(struct dsi *dsi)
 
 static int rk32_phy_power_down(struct dsi *dsi)
 {
-    rk32_dsi_set_bits(dsi, 0, phy_shutdownz);
-    clk_disable_unprepare(dsi->phy.refclk); 
-    clk_disable_unprepare(dsi->dsi_pclk);
-    clk_disable_unprepare(dsi->dsi_pd);
-    return 0;
+	rk32_dsi_set_bits(dsi, 0, phy_shutdownz);
+	clk_disable_unprepare(dsi->phy.refclk);
+	clk_disable_unprepare(dsi->dsi_pclk);
+	clk_disable_unprepare(dsi->dsi_pd);
+	return 0;
 }
 
 static int rk312x_phy_power_down(struct dsi *dsi)
 {
-    rk32_dsi_set_bits(dsi, 0x01, DPHY_REGISTER0);
-    rk32_dsi_set_bits(dsi, 0xe3, DPHY_REGISTER1);
-    
-    clk_disable_unprepare(dsi->phy.refclk); 
-    clk_disable_unprepare(dsi->dsi_pclk);
+	rk32_dsi_set_bits(dsi, 0x01, DPHY_REGISTER0);
+	rk32_dsi_set_bits(dsi, 0xe3, DPHY_REGISTER1);
+
+	clk_disable_unprepare(dsi->phy.refclk);
+	clk_disable_unprepare(dsi->dsi_pclk);
 	clk_disable_unprepare(dsi->dsi_host_pclk);
 	clk_disable_unprepare(dsi->h2p_hclk);
-    clk_disable_unprepare(dsi->dsi_pd);
-    return 0;
+	clk_disable_unprepare(dsi->dsi_pd);
+	return 0;
 }
 
-static int rk_phy_power_down(struct dsi *dsi) 
+static int rk_phy_power_down(struct dsi *dsi)
 {
 	if (dsi->ops.id == DWC_DSI_VERSION)
 		rk32_phy_power_down(dsi);
@@ -516,126 +511,126 @@ static int rk32_phy_init(struct dsi *dsi)
 {
 	u32 val = 0 , ddr_clk = 0, fbdiv = 0, prediv = 0;
 	unsigned char test_data[2] = {0};
-	
+
 	ddr_clk	= dsi->phy.ddr_clk;
 	prediv	= dsi->phy.prediv;
 	fbdiv	= dsi->phy.fbdiv;
 
-	if(ddr_clk < 200 * MHz)
+	if (ddr_clk < 200 * MHz)
 		val = 0x0;
-	else if(ddr_clk < 300 * MHz)
+	else if (ddr_clk < 300 * MHz)
 		val = 0x1;
-	else if(ddr_clk < 500 * MHz)
+	else if (ddr_clk < 500 * MHz)
 		val = 0x2;
-	else if(ddr_clk < 700 * MHz)
+	else if (ddr_clk < 700 * MHz)
 		val = 0x3;
-	else if(ddr_clk < 900 * MHz)
+	else if (ddr_clk < 900 * MHz)
 		val = 0x4;
-	else if(ddr_clk < 1100 * MHz)
-		val = 0x5; 
-	else if(ddr_clk < 1300 * MHz)
+	else if (ddr_clk < 1100 * MHz)
+		val = 0x5;
+	else if (ddr_clk < 1300 * MHz)
 		val = 0x6;
-	else if(ddr_clk <= 1500 * MHz)
+	else if (ddr_clk <= 1500 * MHz)
 		val = 0x7;
-	
+
 	test_data[0] = 0x80 | val << 3 | 0x3;
 	rk32_dwc_phy_test_wr(dsi, 0x10, test_data, 1);
-	
+
 	test_data[0] = 0x8;
-	rk32_dwc_phy_test_wr(dsi, 0x11, test_data, 1); 
-	
+	rk32_dwc_phy_test_wr(dsi, 0x11, test_data, 1);
+
 	test_data[0] = 0x80 | 0x40;
-	rk32_dwc_phy_test_wr(dsi, 0x12, test_data, 1); 
-	
-	if(ddr_clk < 90 * MHz)
+	rk32_dwc_phy_test_wr(dsi, 0x12, test_data, 1);
+
+	if (ddr_clk < 90 * MHz)
 		val = 0x01;
-	else if(ddr_clk < 100 * MHz)
+	else if (ddr_clk < 100 * MHz)
 		val = 0x10;
-	else if(ddr_clk < 110 * MHz)
+	else if (ddr_clk < 110 * MHz)
 		val = 0x20;
-	else if(ddr_clk < 130 * MHz)
+	else if (ddr_clk < 130 * MHz)
 		val = 0x01;
-	else if(ddr_clk < 140 * MHz)
+	else if (ddr_clk < 140 * MHz)
 		val = 0x11;
-	else if(ddr_clk < 150 * MHz)
-		val = 0x21; 
-	else if(ddr_clk < 170 * MHz)
+	else if (ddr_clk < 150 * MHz)
+		val = 0x21;
+	else if (ddr_clk < 170 * MHz)
 		val = 0x02;
-	else if(ddr_clk < 180 * MHz)
+	else if (ddr_clk < 180 * MHz)
 		val = 0x12;
-	else if(ddr_clk < 200 * MHz)
+	else if (ddr_clk < 200 * MHz)
 		val = 0x22;
-	else if(ddr_clk < 220 * MHz)
+	else if (ddr_clk < 220 * MHz)
 		val = 0x03;
-	else if(ddr_clk < 240 * MHz)
+	else if (ddr_clk < 240 * MHz)
 		val = 0x13;
-	else if(ddr_clk < 250 * MHz)
+	else if (ddr_clk < 250 * MHz)
 		val = 0x23;
-	else if(ddr_clk < 270 * MHz)
-		val = 0x04; 
-	else if(ddr_clk < 300 * MHz)
+	else if (ddr_clk < 270 * MHz)
+		val = 0x04;
+	else if (ddr_clk < 300 * MHz)
 		val = 0x14;
-	else if(ddr_clk < 330 * MHz)
+	else if (ddr_clk < 330 * MHz)
 		val = 0x05;
-	else if(ddr_clk < 360 * MHz)
-		val = 0x15; 
-	else if(ddr_clk < 400 * MHz)
+	else if (ddr_clk < 360 * MHz)
+		val = 0x15;
+	else if (ddr_clk < 400 * MHz)
 		val = 0x25;
-	else if(ddr_clk < 450 * MHz)
-		val = 0x06; 
-	else if(ddr_clk < 500 * MHz)
+	else if (ddr_clk < 450 * MHz)
+		val = 0x06;
+	else if (ddr_clk < 500 * MHz)
 		val = 0x16;
-	else if(ddr_clk < 550 * MHz)
+	else if (ddr_clk < 550 * MHz)
 		val = 0x07;
-	else if(ddr_clk < 600 * MHz)
+	else if (ddr_clk < 600 * MHz)
 		val = 0x17;
-	else if(ddr_clk < 650 * MHz)
+	else if (ddr_clk < 650 * MHz)
 		val = 0x08;
-	else if(ddr_clk < 700 * MHz)
+	else if (ddr_clk < 700 * MHz)
 		val = 0x18;
-	else if(ddr_clk < 750 * MHz)
+	else if (ddr_clk < 750 * MHz)
 		val = 0x09;
-	else if(ddr_clk < 800 * MHz)
+	else if (ddr_clk < 800 * MHz)
 		val = 0x19;
-	else if(ddr_clk < 850 * MHz)
+	else if (ddr_clk < 850 * MHz)
 		val = 0x29;
-	else if(ddr_clk < 900 * MHz)
+	else if (ddr_clk < 900 * MHz)
 		val = 0x39;
-	else if(ddr_clk < 950 * MHz)
+	else if (ddr_clk < 950 * MHz)
 		val = 0x0a;
-	else if(ddr_clk < 1000 * MHz)
+	else if (ddr_clk < 1000 * MHz)
 		val = 0x1a;
-	else if(ddr_clk < 1050 * MHz)
+	else if (ddr_clk < 1050 * MHz)
 		val = 0x2a;
-	else if(ddr_clk < 1100* MHz)
+	else if (ddr_clk < 1100 * MHz)
 		val = 0x3a;
-	else if(ddr_clk < 1150* MHz)
+	else if (ddr_clk < 1150 * MHz)
 		val = 0x0b;
-	else if(ddr_clk < 1200 * MHz)
+	else if (ddr_clk < 1200 * MHz)
 		val = 0x1b;
-	else if(ddr_clk < 1250 * MHz)
+	else if (ddr_clk < 1250 * MHz)
 		val = 0x2b;
-	else if(ddr_clk < 1300 * MHz)
+	else if (ddr_clk < 1300 * MHz)
 		val = 0x3b;
-	else if(ddr_clk < 1350 * MHz)
+	else if (ddr_clk < 1350 * MHz)
 		val = 0x0c;
-	else if(ddr_clk < 1400* MHz)
+	else if (ddr_clk < 1400 * MHz)
 		val = 0x1c;
-	else if(ddr_clk < 1450* MHz)
+	else if (ddr_clk < 1450 * MHz)
 		val = 0x2c;
-	else if(ddr_clk <= 1500* MHz)
+	else if (ddr_clk <= 1500 * MHz)
 		val = 0x3c;
 
 	test_data[0] = val << 1;
 	rk32_dwc_phy_test_wr(dsi, code_hs_rx_lane0, test_data, 1);
 
-	test_data[0] = prediv- 1;
+	test_data[0] = prediv - 1;
 	rk32_dwc_phy_test_wr(dsi, code_pll_input_div_rat, test_data, 1);
 	mdelay(2);
-	test_data[0] = (fbdiv - 1) & 0x1f; 
+	test_data[0] = (fbdiv - 1) & 0x1f;
 	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
 	mdelay(2);
-	test_data[0] = (fbdiv - 1) >> 5 | 0x80; 
+	test_data[0] = (fbdiv - 1) >> 5 | 0x80;
 	rk32_dwc_phy_test_wr(dsi, code_pll_loop_div_rat, test_data, 1);
 	mdelay(2);
 	test_data[0] = 0x30;
@@ -644,13 +639,13 @@ static int rk32_phy_init(struct dsi *dsi)
 
 	test_data[0] = 0x4d;
 	rk32_dwc_phy_test_wr(dsi, 0x20, test_data, 1);
-	
+
 	test_data[0] = 0x3d;
 	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1);
-	
+
 	test_data[0] = 0xdf;
-	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1); 	
-	
+	rk32_dwc_phy_test_wr(dsi, 0x21, test_data, 1);
+
 	test_data[0] =  0x7;
 	rk32_dwc_phy_test_wr(dsi, 0x22, test_data, 1);
 
@@ -666,12 +661,12 @@ static int rk32_phy_init(struct dsi *dsi)
 	test_data[0] = 0x40 | 10;
 	rk32_dwc_phy_test_wr(dsi, code_hstxdatalanehszerostatetime, test_data, 1);
 
-    return 0;
+	return 0;
 }
 
 static int rk312x_phy_init(struct dsi *dsi, int n)
 {
-	//DPHY init
+	/* DPHY init */
 	rk32_dsi_set_bits(dsi, 0x11, DSI_DPHY_BITS(0x06<<2, 32, 0));
 	rk32_dsi_set_bits(dsi, 0x11, DSI_DPHY_BITS(0x07<<2, 32, 0));
 	rk32_dsi_set_bits(dsi, 0xcc, DSI_DPHY_BITS(0x09<<2, 32, 0));
@@ -680,31 +675,31 @@ static int rk312x_phy_init(struct dsi *dsi, int n)
 	dsi_set_bits(0x84, DSI_DPHY_BITS(0x0a<<2, 32, 0));
 #endif
 
-	/*reg1[4] 0: enable a function of "pll phase for serial data being captured 
-				 inside analog part" 
-		  1: disable it 
-	  we disable it here because reg5[6:4] is not compatible with the HS speed.		
+	/*reg1[4] 0: enable a function of "pll phase for serial data being captured
+				 inside analog part"
+		  1: disable it
+	we disable it here because reg5[6:4] is not compatible with the HS speed.
 	*/
 
-	if(dsi->phy.ddr_clk >= 800*MHz) {
+	if (dsi->phy.ddr_clk >= 800*MHz) {
 		rk32_dsi_set_bits(dsi, 0x30, DSI_DPHY_BITS(0x05<<2, 32, 0));
 	} else {
 		rk32_dsi_set_bits(dsi, 1, reg_da_ppfc);
 	}
 
-	switch(dsi->host.lane) {
-		case 4:
-			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE3_OFFSET, n);
-		case 3:
-			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE2_OFFSET, n);
-		case 2:
-			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE1_OFFSET, n);
-		case 1:
-			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE0_OFFSET, n);
-			rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_CLOCK_OFFSET, n);
-			break;
-		default:
-			break;	
+	switch	(dsi->host.lane) {
+	case 4:
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE3_OFFSET, n);
+	case 3:
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE2_OFFSET, n);
+	case 2:
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE1_OFFSET, n);
+	case 1:
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_LANE0_OFFSET, n);
+		rk312x_mipi_dsi_phy_set_gotp(dsi, DPHY_CLOCK_OFFSET, n);
+		break;
+	default:
+		break;
 	}
 /*
 	rk32_dsi_set_bits(dsi, 0x00e4, reg1_phy);
@@ -717,7 +712,7 @@ static int rk312x_phy_init(struct dsi *dsi, int n)
 
 	rk32_dsi_set_bits(dsi, 0x0063, reg10_phy);
 	*/
-	
+
 	rk32_dsi_set_bits(dsi, 0x06, reg5_phy);
 	rk32_dsi_set_bits(dsi, 0x6, reg10_4_6_phy);
 	rk32_dsi_set_bits(dsi, 0x9, regb_phy);
@@ -734,194 +729,180 @@ static int rk_phy_init(struct dsi *dsi)
 	return 0;
 }
 
-static int rk32_mipi_dsi_host_power_up(struct dsi *dsi) 
+static int rk32_mipi_dsi_host_power_up(struct dsi *dsi)
 {
 	int ret = 0;
 	u32 val;
 
-	//disable all interrupt            
+	/* disable all interrupt */
 	rk32_dsi_set_bits(dsi, 0x1fffff, INT_MKS0);
 	rk32_dsi_set_bits(dsi, 0x3ffff, INT_MKS1);
 
 	rk32_mipi_dsi_is_enable(dsi, 1);
-	
+
 	val = 10;
-	while(!rk32_dsi_get_bits(dsi, phylock) && val--) {
+	while (!rk32_dsi_get_bits(dsi, phylock) && val--) {
 		udelay(10);
 	};
-	
-	if(val == 0) {
+
+	if (val == 0) {
 		ret = -1;
-		MIPI_TRACE("%s:phylock fail.\n", __func__);	
+		MIPI_TRACE("%s:phylock fail.\n", __func__);
 	}
-	
+
 	val = 10;
-	while(!rk32_dsi_get_bits(dsi, phystopstateclklane) && val--) {
+	while (!rk32_dsi_get_bits(dsi, phystopstateclklane) && val--) {
 		udelay(10);
 	};
-	
+
 	return ret;
 }
 
-
-
-
-static int rk32_mipi_dsi_host_power_down(struct dsi *dsi) 
-{	
+static int rk32_mipi_dsi_host_power_down(struct dsi *dsi)
+{
 	rk32_mipi_dsi_enable_video_mode(dsi, 0);
 	rk32_mipi_dsi_enable_hs_clk(dsi, 0);
 	rk32_mipi_dsi_is_enable(dsi, 0);
 	return 0;
 }
 
-
-
-static int rk32_mipi_dsi_host_init(struct dsi *dsi) 
+static int rk32_mipi_dsi_host_init(struct dsi *dsi)
 {
 	u32 val = 0, bytes_px = 0;
 	struct mipi_dsi_screen *screen = &dsi->screen;
 	u32 decimals = dsi->phy.Ttxbyte_clk, temp = 0, i = 0;
-	u32 m = 1, lane = dsi->host.lane, Tpclk = dsi->phy.Tpclk, 
+	u32 m = 1, lane = dsi->host.lane, Tpclk = dsi->phy.Tpclk,
 			Ttxbyte_clk = dsi->phy.Ttxbyte_clk;
 
 	rk32_dsi_set_bits(dsi, dsi->host.lane - 1, n_lanes);
 	rk32_dsi_set_bits(dsi, dsi->vid, dpi_vcid);
-	
-	switch(screen->face) {
-		case OUT_P888:
-			rk32_dsi_set_bits(dsi, 5, dpi_color_coding);
-			bytes_px = 3;
-			break;
-		
-		case OUT_D888_P666:
-		
-		case OUT_P666:
-			rk32_dsi_set_bits(dsi, 3, dpi_color_coding);
-			rk32_dsi_set_bits(dsi, 1, en18_loosely);
-			bytes_px = 3;
-			break;
-		
-		case OUT_P565:
-			rk32_dsi_set_bits(dsi, 0, dpi_color_coding);
-			bytes_px = 2;
-		
-		default:
-			break;
+
+	switch (screen->face) {
+	case OUT_P888:
+		rk32_dsi_set_bits(dsi, 5, dpi_color_coding);
+		bytes_px = 3;
+		break;
+	case OUT_D888_P666:
+	case OUT_P666:
+		rk32_dsi_set_bits(dsi, 3, dpi_color_coding);
+		rk32_dsi_set_bits(dsi, 1, en18_loosely);
+		bytes_px = 3;
+		break;
+	case OUT_P565:
+		rk32_dsi_set_bits(dsi, 0, dpi_color_coding);
+		bytes_px = 2;
+	default:
+		break;
 	}
 	if (dsi->ops.id == DWC_DSI_VERSION) {
 		rk32_dsi_set_bits(dsi, 1, hsync_active_low);
 		rk32_dsi_set_bits(dsi, 1, vsync_active_low);
-		
+
 		rk32_dsi_set_bits(dsi, 0, dataen_active_low);
 		rk32_dsi_set_bits(dsi, 0, colorm_active_low);
 		rk32_dsi_set_bits(dsi, 0, shutd_active_low);
 	} else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
 		rk32_dsi_set_bits(dsi, !screen->pin_hsync, hsync_active_low);
 		rk32_dsi_set_bits(dsi, !screen->pin_vsync, vsync_active_low);
-		
+
 		rk32_dsi_set_bits(dsi, screen->pin_den, dataen_active_low);
 		rk32_dsi_set_bits(dsi, 1, colorm_active_low);
 		rk32_dsi_set_bits(dsi, 1, shutd_active_low);
-
 	}
-	
-	rk32_dsi_set_bits(dsi, dsi->host.video_mode, vid_mode_type);	  //burst mode
-	
-	switch(dsi->host.video_mode) {
-	
-		case VM_BM:
-		    if(screen->type == SCREEN_DUAL_MIPI)
-			    rk32_dsi_set_bits(dsi, screen->x_res / 2 + 4, vid_pkt_size);
-			 else
-			    rk32_dsi_set_bits(dsi, screen->x_res, vid_pkt_size);
-			break;
-			
-		case VM_NBMWSE:
-		
-		case VM_NBMWSP:
-			for(i = 8; i < 32; i++){
-				temp = i * lane * Tpclk % Ttxbyte_clk;
-				if(decimals > temp) {
-					decimals = temp;
-					m = i;
-				}
-				if(decimals == 0)
-					break;
+
+	rk32_dsi_set_bits(dsi, dsi->host.video_mode, vid_mode_type); /* burst mode */
+
+	switch (dsi->host.video_mode) {
+	case VM_BM:
+		if (screen->type == SCREEN_DUAL_MIPI)
+			rk32_dsi_set_bits(dsi, screen->x_res / 2 + 4, vid_pkt_size);
+		else
+			rk32_dsi_set_bits(dsi, screen->x_res, vid_pkt_size);
+		break;
+	case VM_NBMWSE:
+	case VM_NBMWSP:
+		for (i = 8; i < 32; i++) {
+			temp = i * lane * Tpclk % Ttxbyte_clk;
+			if (decimals > temp) {
+				decimals = temp;
+				m = i;
 			}
+			if (decimals == 0)
+				break;
+		}
 
-			rk32_dsi_set_bits(dsi, screen->x_res / m + 1, num_chunks);
-			rk32_dsi_set_bits(dsi, m, vid_pkt_size);
-			temp = m * lane * Tpclk / Ttxbyte_clk - m * bytes_px;
-			MIPI_DBG("%s:%d, %d\n", __func__, m, temp);
-		
-			if(temp >= 12) 
-				rk32_dsi_set_bits(dsi, temp - 12, null_pkt_size);
-				
-			break;
-			
-		default:
-		
-			break;
-	}	
+		rk32_dsi_set_bits(dsi, screen->x_res / m + 1, num_chunks);
+		rk32_dsi_set_bits(dsi, m, vid_pkt_size);
+		temp = m * lane * Tpclk / Ttxbyte_clk - m * bytes_px;
+		MIPI_DBG("%s:%d, %d\n", __func__, m, temp);
 
-	//rk32_dsi_set_bits(dsi, 0, CMD_MODE_CFG << 16);
-	if(screen->type == SCREEN_MIPI){
-		rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->x_res + screen->left_margin + 
+		if (temp >= 12)
+			rk32_dsi_set_bits(dsi, temp - 12, null_pkt_size);
+		break;
+	default:
+		break;
+	}
+
+	/* rk32_dsi_set_bits(dsi, 0, CMD_MODE_CFG << 16); */
+	if (screen->type == SCREEN_MIPI) {
+		rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->x_res + screen->left_margin +
 					screen->hsync_len + screen->right_margin) \
 						/ dsi->phy.Ttxbyte_clk, vid_hline_time);
-	}
-	else{
-		rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->x_res + 8 + screen->left_margin + 
+	} else {
+		rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->x_res + 8 + screen->left_margin +
 					screen->hsync_len + screen->right_margin) \
-						/ dsi->phy.Ttxbyte_clk, vid_hline_time);	
+						/ dsi->phy.Ttxbyte_clk, vid_hline_time);
 	}
 	MIPI_DBG("dsi->phy.Tpclk = %d\n", dsi->phy.Tpclk);
 	MIPI_DBG("screen->left_margin = %d\n", screen->left_margin);
 	MIPI_DBG("dsi->phy.Ttxbyte_clk = %d\n", dsi->phy.Ttxbyte_clk);
 	MIPI_DBG("screen->hsync_len = %d\n", screen->hsync_len);
-    rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->left_margin) / dsi->phy.Ttxbyte_clk, 
+	rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->left_margin) / dsi->phy.Ttxbyte_clk,
 					vid_hbp_time);
-	rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->hsync_len) / dsi->phy.Ttxbyte_clk, 
+	rk32_dsi_set_bits(dsi, dsi->phy.Tpclk * (screen->hsync_len) / dsi->phy.Ttxbyte_clk,
 					vid_hsa_time);
-    
+
 	rk32_dsi_set_bits(dsi, screen->y_res , vid_active_lines);
 	rk32_dsi_set_bits(dsi, screen->lower_margin, vid_vfp_lines);
 	rk32_dsi_set_bits(dsi, screen->upper_margin, vid_vbp_lines);
 	rk32_dsi_set_bits(dsi, screen->vsync_len, vid_vsa_lines);
-	
+
 	dsi->phy.txclkesc = 20 * MHz;
 	val = dsi->phy.txbyte_clk / dsi->phy.txclkesc + 1;
 	dsi->phy.txclkesc = dsi->phy.txbyte_clk / val;
 	rk32_dsi_set_bits(dsi, val, TX_ESC_CLK_DIVISION);
-	
+
 	rk32_dsi_set_bits(dsi, 10, TO_CLK_DIVISION);
-    rk32_dsi_set_bits(dsi, 1000, hstx_to_cnt); //no sure
-	rk32_dsi_set_bits(dsi, 1000, lprx_to_cnt);	
+	rk32_dsi_set_bits(dsi, 1000, hstx_to_cnt); /* no sure */
+	rk32_dsi_set_bits(dsi, 1000, lprx_to_cnt);
 	rk32_dsi_set_bits(dsi, 100, phy_stop_wait_time);
 
-	//rk32_dsi_set_bits(dsi, 0, outvact_lpcmd_time);   //byte
-	//rk32_dsi_set_bits(dsi, 0, invact_lpcmd_time);
-		
+	/*
+	rk32_dsi_set_bits(dsi, 0, outvact_lpcmd_time);
+	rk32_dsi_set_bits(dsi, 0, invact_lpcmd_time);
+	*/
 	rk32_dsi_set_bits(dsi, 20, phy_hs2lp_time);
-	rk32_dsi_set_bits(dsi, 16, phy_lp2hs_time);	
-
-	// rk32_dsi_set_bits(dsi, 87, phy_hs2lp_time_clk_lane); //no sure
-	//  rk32_dsi_set_bits(dsi, 25, phy_hs2hs_time_clk_lane); //no sure
-
+	rk32_dsi_set_bits(dsi, 16, phy_lp2hs_time);
+	/*
+	rk32_dsi_set_bits(dsi, 87, phy_hs2lp_time_clk_lane);
+	rk32_dsi_set_bits(dsi, 25, phy_hs2hs_time_clk_lane);
+	*/
 	rk32_dsi_set_bits(dsi, 10000, max_rd_time);
 
 	rk32_dsi_set_bits(dsi, 1, lp_hfp_en);
-	//rk32_dsi_set_bits(dsi, 1, lp_hbp_en); //no sure
+	/* rk32_dsi_set_bits(dsi, 1, lp_hbp_en); */
 	rk32_dsi_set_bits(dsi, 1, lp_vact_en);
 	rk32_dsi_set_bits(dsi, 1, lp_vfp_en);
 	rk32_dsi_set_bits(dsi, 1, lp_vbp_en);
 	rk32_dsi_set_bits(dsi, 1, lp_vsa_en);
-	
-	//rk32_dsi_set_bits(dsi, 1, frame_bta_ack_en);
+
+	/* rk32_dsi_set_bits(dsi, 1, frame_bta_ack_en); */
 	rk32_dsi_set_bits(dsi, 1, phy_enableclk);
 	rk32_dsi_set_bits(dsi, 0, phy_tx_triggers);
-	//rk32_dsi_set_bits(dsi, 1, phy_txexitulpslan);
-	//rk32_dsi_set_bits(dsi, 1, phy_txexitulpsclk);
+	/*
+	rk32_dsi_set_bits(dsi, 1, phy_txexitulpslan);
+	rk32_dsi_set_bits(dsi, 1, phy_txexitulpsclk);
+	*/
 	return 0;
 }
 
@@ -933,92 +914,89 @@ static int rk_mipi_dsi_init(void *arg, u32 n)
 	u32 decimals = 1000, i = 0, pre = 0;
 	struct dsi *dsi = arg;
 	struct mipi_dsi_screen *screen = &dsi->screen;
-	
-	if(!screen)
+
+	if (!screen)
 		return -1;
-	
-	if((screen->type != SCREEN_MIPI) && (screen->type != SCREEN_DUAL_MIPI) ) {
+
+	if ((screen->type != SCREEN_MIPI) && (screen->type != SCREEN_DUAL_MIPI)) {
 		MIPI_TRACE("only mipi dsi lcd is supported!\n");
 		return -1;
 	}
 
-	if(((screen->type == SCREEN_DUAL_MIPI) && (rk_mipi_get_dsi_num() == 1)) ||  ((screen->type == SCREEN_MIPI) && (rk_mipi_get_dsi_num() == 2))){
+	if (((screen->type == SCREEN_DUAL_MIPI) && (rk_mipi_get_dsi_num() == 1)) || ((screen->type == SCREEN_MIPI) && (rk_mipi_get_dsi_num() == 2))) {
 		MIPI_TRACE("dsi number and mipi type not match!\n");
-	    return -1;
-    }
+		return -1;
+	}
 
 	dsi->phy.Tpclk = rk_fb_get_prmry_screen_pixclock();
 
-	if(dsi->phy.refclk)
+	if (dsi->phy.refclk)
 		dsi->phy.ref_clk = clk_get_rate(dsi->phy.refclk) ;
 	if (dsi->ops.id == DWC_DSI_VERSION_RK312x)
-		dsi->phy.ref_clk = dsi->phy.ref_clk / 2;// 1/2 of input refclk
-	
+		dsi->phy.ref_clk = dsi->phy.ref_clk / 2; /* 1/2 of input refclk */
+
 	dsi->phy.sys_clk = dsi->phy.ref_clk;
 
-	printk("dsi->phy.sys_clk =%d\n",dsi->phy.sys_clk );
+	printk("dsi->phy.sys_clk =%d\n", dsi->phy.sys_clk);
 	if (dsi->ops.id == DWC_DSI_VERSION) {
-		if((screen->hs_tx_clk <= 90 * MHz) || (screen->hs_tx_clk >= 1500 * MHz))
-			dsi->phy.ddr_clk = 1500 * MHz;    //default is 1.5HGz
+		if ((screen->hs_tx_clk <= 90 * MHz) || (screen->hs_tx_clk >= 1500 * MHz))
+			dsi->phy.ddr_clk = 1500 * MHz; /* default is 1.5HGz */
 		else
-			dsi->phy.ddr_clk = screen->hs_tx_clk;   
+			dsi->phy.ddr_clk = screen->hs_tx_clk;
 	} else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
-		if((screen->hs_tx_clk <= 80 * MHz) || (screen->hs_tx_clk >= 1000 * MHz))
-			dsi->phy.ddr_clk = 1000 * MHz;    //default is 1GHz
+		if ((screen->hs_tx_clk <= 80 * MHz) || (screen->hs_tx_clk >= 1000 * MHz))
+			dsi->phy.ddr_clk = 1000 * MHz; /* default is 1GHz */
 		else
-			dsi->phy.ddr_clk = screen->hs_tx_clk;   
-
+			dsi->phy.ddr_clk = screen->hs_tx_clk;
 	}
 
-	if(n != 0) 
+	if (n != 0)
 		dsi->phy.ddr_clk = n;
 
 	decimals = dsi->phy.ref_clk;
-	for(i = 1; i < 6; i++) {
+	for (i = 1; i < 6; i++) {
 		pre = dsi->phy.ref_clk / i;
-		if((decimals > (dsi->phy.ddr_clk % pre)) && (dsi->phy.ddr_clk / pre < 512)) {
+		if ((decimals > (dsi->phy.ddr_clk % pre)) && (dsi->phy.ddr_clk / pre < 512)) {
 			decimals = dsi->phy.ddr_clk % pre;
 			dsi->phy.prediv = i;
 			dsi->phy.fbdiv = dsi->phy.ddr_clk / pre;
-		}	
-		if(decimals == 0) 
+		}
+		if (decimals == 0)
 			break;
 	}
 
-	
-
-	MIPI_DBG("prediv:%d, fbdiv:%d,dsi->phy.ddr_clk:%d\n", dsi->phy.prediv, dsi->phy.fbdiv,dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv);
+	MIPI_DBG("prediv:%d, fbdiv:%d,dsi->phy.ddr_clk:%d\n", dsi->phy.prediv, dsi->phy.fbdiv, dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv);
 
-	dsi->phy.ddr_clk = dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv;	
+	dsi->phy.ddr_clk = dsi->phy.ref_clk / dsi->phy.prediv * dsi->phy.fbdiv;
 
-	MIPI_DBG("dsi->phy.ddr_clk =%d\n",dsi->phy.ddr_clk);
+	MIPI_DBG("dsi->phy.ddr_clk =%d\n", dsi->phy.ddr_clk);
 	dsi->phy.txbyte_clk = dsi->phy.ddr_clk / 8;
-	
-	dsi->phy.txclkesc = 20 * MHz;        // < 20MHz
+
+	dsi->phy.txclkesc = 20 * MHz; /* < 20MHz */
 	dsi->phy.txclkesc = dsi->phy.txbyte_clk / (dsi->phy.txbyte_clk / dsi->phy.txclkesc + 1);
 
 	dsi->phy.pclk = div_u64(1000000000000llu, dsi->phy.Tpclk);
 	dsi->phy.Ttxclkesc = div_u64(1000000000000llu, dsi->phy.txclkesc);
 	dsi->phy.Tsys_clk = div_u64(1000000000000llu, dsi->phy.sys_clk);
 	dsi->phy.Tddr_clk = div_u64(1000000000000llu, dsi->phy.ddr_clk);
-	dsi->phy.Ttxbyte_clk = div_u64(1000000000000llu, dsi->phy.txbyte_clk);	
+	dsi->phy.Ttxbyte_clk = div_u64(1000000000000llu, dsi->phy.txbyte_clk);
 
 	dsi->phy.UI = dsi->phy.Tddr_clk;
 	dsi->vid = 0;
-	
-	if(screen->dsi_lane > 0 && screen->dsi_lane <= 4)
+
+	if (screen->dsi_lane > 0 && screen->dsi_lane <= 4)
 		dsi->host.lane = screen->dsi_lane;
 	else
 		dsi->host.lane = 4;
-		
+
 	dsi->host.video_mode = VM_BM;
-	
-	MIPI_DBG("UI:%d\n", dsi->phy.UI);	
+
+	MIPI_DBG("UI:%d\n", dsi->phy.UI);
 	MIPI_DBG("ref_clk:%d\n", dsi->phy.ref_clk);
 	MIPI_DBG("pclk:%d, Tpclk:%d\n", dsi->phy.pclk, dsi->phy.Tpclk);
 	MIPI_DBG("sys_clk:%d, Tsys_clk:%d\n", dsi->phy.sys_clk, dsi->phy.Tsys_clk);
 	MIPI_DBG("ddr_clk:%d, Tddr_clk:%d\n", dsi->phy.ddr_clk, dsi->phy.Tddr_clk);
-	MIPI_DBG("txbyte_clk:%d, Ttxbyte_clk:%d\n", dsi->phy.txbyte_clk, 
+	MIPI_DBG("txbyte_clk:%d, Ttxbyte_clk:%d\n", dsi->phy.txbyte_clk,
 				dsi->phy.Ttxbyte_clk);
 	MIPI_DBG("txclkesc:%d, Ttxclkesc:%d\n", dsi->phy.txclkesc, dsi->phy.Ttxclkesc);
 
@@ -1027,7 +1005,7 @@ static int rk_mipi_dsi_init(void *arg, u32 n)
 	rk32_mipi_dsi_host_power_up(dsi);
 	rk_phy_init(dsi);
 	rk32_mipi_dsi_host_init(dsi);
-	
+
 	return 0;
 }
 
@@ -1036,7 +1014,6 @@ static int rk32_mipi_dsi_is_enable(void *arg, u32 enable)
 	struct dsi *dsi = arg;
 
 	rk32_dsi_set_bits(dsi, enable, shutdownz);
-
 	return 0;
 }
 
@@ -1045,7 +1022,6 @@ static int rk32_mipi_dsi_enable_video_mode(void *arg, u32 enable)
 	struct dsi *dsi = arg;
 
 	rk32_dsi_set_bits(dsi, !enable, cmd_video_mode);
-
 	return 0;
 }
 
@@ -1054,14 +1030,13 @@ static int rk32_mipi_dsi_enable_command_mode(void *arg, u32 enable)
 	struct dsi *dsi = arg;
 
 	rk32_dsi_set_bits(dsi, enable, cmd_video_mode);
-
 	return 0;
 }
 
 static int rk32_mipi_dsi_enable_hs_clk(void *arg, u32 enable)
 {
 	struct dsi *dsi = arg;
-	
+
 	rk32_dsi_set_bits(dsi, enable, phy_txrequestclkhs);
 	return 0;
 }
@@ -1069,7 +1044,7 @@ static int rk32_mipi_dsi_enable_hs_clk(void *arg, u32 enable)
 static int rk32_mipi_dsi_is_active(void *arg)
 {
 	struct dsi *dsi = arg;
-	
+
 	return rk32_dsi_get_bits(dsi, shutdownz);
 }
 
@@ -1079,139 +1054,115 @@ static int rk32_mipi_dsi_send_packet(void *arg, unsigned char cmds[], u32 length
 	unsigned char *regs;
 	u32 type, liTmp = 0, i = 0, j = 0, data = 0;
 
-	if(rk32_dsi_get_bits(dsi, gen_cmd_full) == 1) {
+	if (rk32_dsi_get_bits(dsi, gen_cmd_full) == 1) {
 		MIPI_TRACE("gen_cmd_full\n");
 		return -1;
 	}
 	regs = kmalloc(0x400, GFP_KERNEL);
-	if(!regs) {
+	if (!regs) {
 		printk("request regs fail!\n");
 		return -ENOMEM;
 	}
-	memcpy(regs,cmds,length);
-	
-	liTmp	= length - 2;
-	type	= regs[1];
-	
-	switch(type)
-	{
-		case DTYPE_DCS_SWRITE_0P:
-			rk32_dsi_set_bits(dsi, regs[0], dcs_sw_0p_tx);
-			data = regs[2] << 8 | type;
-			break;
-		
-		case DTYPE_DCS_SWRITE_1P:
-			rk32_dsi_set_bits(dsi, regs[0], dcs_sw_1p_tx);
-			data = regs[2] << 8 | type;
-			data |= regs[3] << 16;
-			break;
-		    
-		case DTYPE_DCS_LWRITE: 
-			rk32_dsi_set_bits(dsi, regs[0], dcs_lw_tx);
-		
-			for(i = 0; i < liTmp; i++){
-			    regs[i] = regs[i+2];
-		    }
-		
-			for(i = 0; i < liTmp; i++) {
-				j = i % 4;
-				
-				data |= regs[i] << (j * 8);
-				if(j == 3 || ((i + 1) == liTmp)) {
-					if(rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
-						MIPI_TRACE("gen_pld_w_full :%d\n", i);
-						break;
-					}
-					
-					rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
-					MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
-					data = 0;
+	memcpy(regs, cmds, length);
+
+	liTmp = length - 2;
+	type = regs[1];
+
+	switch (type) {
+	case DTYPE_DCS_SWRITE_0P:
+		rk32_dsi_set_bits(dsi, regs[0], dcs_sw_0p_tx);
+		data = regs[2] << 8 | type;
+		break;
+	case DTYPE_DCS_SWRITE_1P:
+		rk32_dsi_set_bits(dsi, regs[0], dcs_sw_1p_tx);
+		data = regs[2] << 8 | type;
+		data |= regs[3] << 16;
+		break;
+	case DTYPE_DCS_LWRITE:
+		rk32_dsi_set_bits(dsi, regs[0], dcs_lw_tx);
+		for (i = 0; i < liTmp; i++) {
+			regs[i] = regs[i+2];
+		}
+		for (i = 0; i < liTmp; i++) {
+			j = i % 4;
+			data |= regs[i] << (j * 8);
+			if (j == 3 || ((i + 1) == liTmp)) {
+				if (rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+					MIPI_TRACE("gen_pld_w_full :%d\n", i);
+					break;
 				}
+				rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
+				MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+				data = 0;
 			}
-			
-			data = type;	
-			data |= (liTmp & 0xffff) << 8;
-			
-			break;
-			
-		case DTYPE_GEN_LWRITE:
-			rk32_dsi_set_bits(dsi, regs[0], gen_lw_tx);
-			
-			for(i = 0; i < liTmp; i++){
-				regs[i] = regs[i+2];
-			}
-			
-			for(i = 0; i < liTmp; i++) {
-				j = i % 4;
-				
-				data |= regs[i] << (j * 8);
-				if(j == 3 || ((i + 1) == liTmp)) {
-					if(rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
-						MIPI_TRACE("gen_pld_w_full :%d\n", i);
-						break;
-					}
-					
-					rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
-					MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
-					data = 0;
+		}
+		data = type;
+		data |= (liTmp & 0xffff) << 8;
+		break;
+	case DTYPE_GEN_LWRITE:
+		rk32_dsi_set_bits(dsi, regs[0], gen_lw_tx);
+		for (i = 0; i < liTmp; i++) {
+			regs[i] = regs[i+2];
+		}
+		for (i = 0; i < liTmp; i++) {
+			j = i % 4;
+			data |= regs[i] << (j * 8);
+			if (j == 3 || ((i + 1) == liTmp)) {
+				if (rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+					MIPI_TRACE("gen_pld_w_full :%d\n", i);
+					break;
 				}
+				rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
+				MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+				data = 0;
 			}
-		
-			data = (dsi->vid << 6) | type;		
-			data |= (liTmp & 0xffff) << 8;
-			break;
-	
-		case DTYPE_GEN_SWRITE_2P:
-			
-			rk32_dsi_set_bits(dsi, regs[0], gen_sw_2p_tx);
-			for(i = 0; i < liTmp; i++){
-			    regs[i] = regs[i+2];
-			}
-			
-			for(i = 0; i < liTmp; i++) {
-				j = i % 4;
-				data |= regs[i] << (j * 8);
-				if(j == 3 || ((i + 1) == liTmp)) {
-					if(rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
-						MIPI_TRACE("gen_pld_w_full :%d\n", i);
-						break;
-					}
-					
-					rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
-					MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
-					data = 0;
+		}
+		data = (dsi->vid << 6) | type;
+		data |= (liTmp & 0xffff) << 8;
+		break;
+	case DTYPE_GEN_SWRITE_2P:
+		rk32_dsi_set_bits(dsi, regs[0], gen_sw_2p_tx);
+		for (i = 0; i < liTmp; i++) {
+			regs[i] = regs[i+2];
+		}
+		for (i = 0; i < liTmp; i++) {
+			j = i % 4;
+			data |= regs[i] << (j * 8);
+			if (j == 3 || ((i + 1) == liTmp)) {
+				if (rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) {
+					MIPI_TRACE("gen_pld_w_full :%d\n", i);
+					break;
 				}
+				rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA);
+				MIPI_DBG("write GEN_PLD_DATA:%d, %08x\n", i, data);
+				data = 0;
 			}
-			data = type;		
-			data |= (liTmp & 0xffff) << 8;
-
-			break;
-			
-		case DTYPE_GEN_SWRITE_1P:
-			rk32_dsi_set_bits(dsi, regs[0], gen_sw_1p_tx);
-			data = type;
-			data |= regs[2] << 8;
-			data |= regs[3] << 16;
-			break;
-			
-		case DTYPE_GEN_SWRITE_0P:
-			rk32_dsi_set_bits(dsi, regs[0], gen_sw_0p_tx);
-			data =  type;
-			data |= regs[2] << 8;
-			break;
-
-		default:
-		   printk("0x%x:this type not suppport!\n",type);
-			
+		}
+		data = type;
+		data |= (liTmp & 0xffff) << 8;
+		break;
+	case DTYPE_GEN_SWRITE_1P:
+		rk32_dsi_set_bits(dsi, regs[0], gen_sw_1p_tx);
+		data = type;
+		data |= regs[2] << 8;
+		data |= regs[3] << 16;
+		break;
+	case DTYPE_GEN_SWRITE_0P:
+		rk32_dsi_set_bits(dsi, regs[0], gen_sw_0p_tx);
+		data =  type;
+		data |= regs[2] << 8;
+		break;
+	default:
+		printk("0x%x:this type not suppport!\n", type);
 	}
 
 	MIPI_DBG("%d command sent in %s size:%d\n", __LINE__, regs[0] ? "LP mode" : "HS mode", liTmp);
-	
+
 	MIPI_DBG("write GEN_HDR:%08x\n", data);
 	rk32_dsi_set_bits(dsi, data, GEN_HDR);
-	
+
 	i = 10;
-	while(!rk32_dsi_get_bits(dsi, gen_cmd_empty) && i--) {
+	while (!rk32_dsi_get_bits(dsi, gen_cmd_empty) && i--) {
 		MIPI_DBG(".");
 		udelay(10);
 	}
@@ -1222,57 +1173,41 @@ static int rk32_mipi_dsi_send_packet(void *arg, unsigned char cmds[], u32 length
 
 static int rk32_mipi_dsi_read_dcs_packet(void *arg, unsigned char *data1, u32 n)
 {
-	 struct dsi *dsi = arg;
-	 //DCS READ
-	 //unsigned char *regs = data;
-	 unsigned char regs[2];
-	 u32 data = 0;
-	 int type = 0x06;
-	 regs[0] = LPDT;
-	 regs[1] = 0x0a;
-	 n = n - 1;
-
-	   
-	 rk32_dsi_set_bits(dsi, regs[0], dcs_sr_0p_tx);
-	 
-	 /* if(type == DTYPE_GEN_SWRITE_0P)
-	  data = (dsi->vid << 6) | (n << 4) | type;
-	 else
-	  data = (dsi->vid << 6) | ((n-1) << 4) | type;*/
-
-	 data |= regs[1] << 8 | type;
-	 // if(n == 2)
-	 // data |= regs[1] << 16;
-
-	 printk("write GEN_HDR:%08x\n", data);
-	 
-	 rk32_dsi_set_bits(dsi, 0xFFFF, bta_to_cnt);
-	 rk32_dsi_set_bits(dsi, 1, bta_en);
-	 rk32_dsi_set_bits(dsi, data, GEN_HDR);
-	 //msleep(1);
-	 udelay(20);
-	   
-	 // rk32_dsi_set_bits(dsi, regs[0], gen_sr_0p_tx);
-
-	 printk("rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
-	 rk32_dsi_set_bits(dsi, 0, bta_en);
-
-	 //msleep(100);
-
-	 // rk32_dsi_set_bits(dsi, regs[0], max_rd_pkt_size);
-	 
-	 //msleep(100);
-	 // printk("_____rk32_mipi_dsi_read_dcs_packet==0x%x\n",rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
-	 
-	 //msleep(100);
- return 0;
-}
+	struct dsi *dsi = arg;
+	unsigned char regs[2];
+	u32 data = 0;
+	int type = 0x06;
+	regs[0] = LPDT;
+	regs[1] = 0x0a;
+	n = n - 1;
+
+	rk32_dsi_set_bits(dsi, regs[0], dcs_sr_0p_tx);
+	/*
+	if(type == DTYPE_GEN_SWRITE_0P)
+		data = (dsi->vid << 6) | (n << 4) | type;
+	else
+		data = (dsi->vid << 6) | ((n-1) << 4) | type;
+	*/
+
+	data |= regs[1] << 8 | type;
 
+	printk("write GEN_HDR:%08x\n", data);
+
+	rk32_dsi_set_bits(dsi, 0xFFFF, bta_to_cnt);
+	rk32_dsi_set_bits(dsi, 1, bta_en);
+	rk32_dsi_set_bits(dsi, data, GEN_HDR);
+	udelay(20);
+
+	printk("rk32_mipi_dsi_read_dcs_packet==0x%x\n", rk32_dsi_get_bits(dsi, GEN_PLD_DATA));
+	rk32_dsi_set_bits(dsi, 0, bta_en);
+
+	return 0;
+}
 
 static int rk32_mipi_dsi_power_up(void *arg)
 {
 	struct dsi *dsi = arg;
-	
+
 	rk32_phy_power_up(dsi);
 	rk32_mipi_dsi_host_power_up(dsi);
 	return 0;
@@ -1283,7 +1218,7 @@ static int rk32_mipi_dsi_power_down(void *arg)
 	struct dsi *dsi = arg;
 	struct mipi_dsi_screen *screen = &dsi->screen;
 
-	if(!screen)
+	if (!screen)
 		return -1;
 
 	rk32_mipi_dsi_host_power_down(dsi);
@@ -1297,9 +1232,8 @@ static int rk32_mipi_dsi_get_id(void *arg)
 {
 	u32 id = 0;
 	struct dsi *dsi = arg;
-	
-	id	= rk32_dsi_get_bits(dsi, VERSION);
-	
+
+	id = rk32_dsi_get_bits(dsi, VERSION);
 	return id;
 }
 
@@ -1307,15 +1241,13 @@ static int rk32_mipi_dsi_get_id(void *arg)
 static int rk_mipi_dsi_probe(struct dsi *dsi)
 {
 	int ret = 0;
-	
+
 	register_dsi_ops(dsi->dsi_id, &dsi->ops);
-	
 	ret = dsi_probe_current_chip(dsi->dsi_id);
-	if(ret) {
+	if (ret) {
 		MIPI_TRACE("mipi dsi probe fail\n");
 		return -ENODEV;
 	}
-
 	return 0;
 }
 
@@ -1334,113 +1266,106 @@ int reg_proc_write(struct file *file, const char __user *buff, size_t count, lof
 	char command = 0;
 	u64 regs_val = 0;
 	memset(buf, 0, count);
-	ret = copy_from_user((void*)buf, buff, count);
+	ret = copy_from_user((void *)buf, buff, count);
 	data = strstr(data, "-");
-	if(data == NULL)
+	if (data == NULL)
 		goto reg_proc_write_exit;
 	command = *(++data);
-	switch(command) {
-		case 'w':
-			while(1) {
-				data = strstr(data, "0x");
-				if(data == NULL)
-					goto reg_proc_write_exit;
-
-				sscanf(data, "0x%llx", &regs_val);
-				if((regs_val & 0xffff00000000ULL) == 0)
-					goto reg_proc_write_exit;
-				read_val = regs_val & 0xffffffff;
-				printk("regs_val=0x%llx\n",regs_val);
-				rk32_dsi_write_reg(dsi0, regs_val >> 32, &read_val);
-				rk32_dsi_read_reg(dsi0, regs_val >> 32, &read_val);
-				regs_val &= 0xffffffff;
-				if(read_val != regs_val)
-					MIPI_TRACE("%s fail:0x%08x\n", __func__, read_val);					
-				data += 3;
-				msleep(1);	
+	switch (command) {
+	case 'w':
+		while (1) {
+			data = strstr(data, "0x");
+			if (data == NULL)
+				goto reg_proc_write_exit;
+			sscanf(data, "0x%llx", &regs_val);
+			if ((regs_val & 0xffff00000000ULL) == 0)
+				goto reg_proc_write_exit;
+			read_val = regs_val & 0xffffffff;
+			printk("regs_val=0x%llx\n", regs_val);
+			rk32_dsi_write_reg(dsi0, regs_val >> 32, &read_val);
+			rk32_dsi_read_reg(dsi0, regs_val >> 32, &read_val);
+			regs_val &= 0xffffffff;
+			if (read_val != regs_val)
+				MIPI_TRACE("%s fail:0x%08x\n", __func__, read_val);
+			data += 3;
+			msleep(1);
+		}
+		break;
+	case 'r':
+		data = strstr(data, "0x");
+		if (data == NULL) {
+			goto reg_proc_write_exit;
+		}
+		sscanf(data, "0x%llx", &regs_val);
+		rk32_dsi_read_reg(dsi0, (u16)regs_val, &read_val);
+		MIPI_TRACE("*%04x : %08x\n", (u16)regs_val, read_val);
+		msleep(1);
+		break;
+	case 's':
+		while (*(++data) == ' ')
+			;
+		sscanf(data, "%d", &read_val);
+		if (read_val == 11)
+			read_val = 11289600;
+		else
+			read_val *= MHz;
+		break;
+	case 'd':
+	case 'g':
+	case 'c':
+		while (*(++data) == ' ')
+			;
+		i = 0;
+		MIPI_TRACE("****%d:%d\n", data-buf, count);
+		do {
+			if (i > 31) {
+				MIPI_TRACE("payload entry is larger than 32\n");
+				break;
 			}
-		
-			break;
-		case 'r':
-				data = strstr(data, "0x");
-				if(data == NULL){
-					goto reg_proc_write_exit;
-				}
-				sscanf(data, "0x%llx", &regs_val);
-				rk32_dsi_read_reg(dsi0, (u16)regs_val, &read_val);
-				MIPI_TRACE("*%04x : %08x\n", (u16)regs_val, read_val);
-				msleep(1);	
-			break;	
-	
-		case 's':
-				while(*(++data) == ' ');
-				sscanf(data, "%d", &read_val);
-				if(read_val == 11)
-					read_val = 11289600;
-				else	
-					read_val *= MHz;
-
-				//rk32_mipi_dsi_init_lite(dsi);
-			break;
-		case 'd':
-		case 'g':
-		case 'c':
-				while(*(++data) == ' ');
-				i = 0;
-				MIPI_TRACE("****%d:%d\n", data-buf, count);
-				
-				do {
-					if(i > 31) {
-						MIPI_TRACE("payload entry is larger than 32\n");
-						break;
-					}	
-					sscanf(data, "%x,", (unsigned int *)(str + i));   //-c 1,29,02,03,05,06,> pro
-					data = strstr(data, ",");
-					if(data == NULL)
-						break;
-					data++;	
-					i++;
-				} while(1);
-				read_val = i;
-				
-				i = 2;
-				while(i--) {
-					msleep(10);
-					if(command == 'd')
-						rk32_mipi_dsi_send_packet(dsi0, str, read_val);
-					else
-						rk32_mipi_dsi_send_packet(dsi0, str, read_val);
-				}	
-				i = 1;
-				while(i--) {
-					msleep(1000);
-				}
-			break;
-
-		default:
-			break;
+			sscanf(data, "%x,", (unsigned int *)(str + i)); /* -c 1,29,02,03,05,06,> pro */
+			data = strstr(data, ",");
+			if (data == NULL)
+				break;
+			data++;
+			i++;
+		} while (1);
+		read_val = i;
+		i = 2;
+		while (i--) {
+			msleep(10);
+			if (command == 'd')
+				rk32_mipi_dsi_send_packet(dsi0, str, read_val);
+			else
+				rk32_mipi_dsi_send_packet(dsi0, str, read_val);
+		}
+		i = 1;
+		while (i--) {
+			msleep(1000);
+		}
+		break;
+	default:
+		break;
 	}
 
 reg_proc_write_exit:
 	kfree(buf);
 	msleep(20);
- 	return count;
+	return count;
 }
 
-int reg_proc_read(struct file *file, char __user *buff, size_t count, 
+int reg_proc_read(struct file *file, char __user *buff, size_t count,
 					loff_t *offp)
 {
 	int i = 0;
 	u32 val = 0;
 
-    for(i = VERSION; i < (VERSION + (0xdc<<16)); i += 4<<16) {
+	for (i = VERSION; i < (VERSION + (0xdc << 16)); i += 4<<16) {
 		val = rk32_dsi_get_bits(dsi0, i);
 		MIPI_TRACE("%04x: %08x\n", i>>16, val);
 		msleep(1);
 	}
 
 	MIPI_TRACE("\n");
-
 	return -1;
 }
 
@@ -1451,18 +1376,17 @@ int reg_proc_open(struct inode *inode, struct file *file)
 
 int reg_proc_close(struct inode *inode, struct file *file)
 {
-	return 0; 
+	return 0;
 }
 
 struct file_operations reg_proc_fops = {
-	.owner  = THIS_MODULE,
-	.open   = reg_proc_open,
-	.release= reg_proc_close,
-	.write  = reg_proc_write,
-	.read   = reg_proc_read,
+	.owner = THIS_MODULE,
+	.open = reg_proc_open,
+	.release = reg_proc_close,
+	.write = reg_proc_write,
+	.read = reg_proc_read,
 };
 
-
 int reg_proc_write1(struct file *file, const char __user *buff, size_t count, loff_t *offp)
 {
 	int ret = -1, i = 0;
@@ -1473,112 +1397,105 @@ int reg_proc_write1(struct file *file, const char __user *buff, size_t count, lo
 	char command = 0;
 	u64 regs_val = 0;
 	memset(buf, 0, count);
-	ret = copy_from_user((void*)buf, buff, count);
-	
+	ret = copy_from_user((void *)buf, buff, count);
+
 	data = strstr(data, "-");
-	if(data == NULL)
+	if (data == NULL)
 		goto reg_proc_write_exit;
 	command = *(++data);
-	
-	switch(command) {
-		case 'w':
-			while(1) {
-		
-				data = strstr(data, "0x");
-				if(data == NULL)
-					goto reg_proc_write_exit;
-				sscanf(data, "0x%llx", &regs_val);
-				if((regs_val & 0xffff00000000ULL) == 0)
-					goto reg_proc_write_exit;
-				read_val = regs_val & 0xffffffff;
-				rk32_dsi_write_reg(dsi1, regs_val >> 32, &read_val);
-				rk32_dsi_read_reg(dsi1, regs_val >> 32, &read_val);
-				regs_val &= 0xffffffff;
-				if(read_val != regs_val)
-					MIPI_TRACE("%s fail:0x%08x\n", __func__, read_val);	
-				
-				data += 3;
-				msleep(1);	
+
+	switch (command) {
+	case 'w':
+		while (1) {
+			data = strstr(data, "0x");
+			if (data == NULL)
+				goto reg_proc_write_exit;
+			sscanf(data, "0x%llx", &regs_val);
+			if ((regs_val & 0xffff00000000ULL) == 0)
+				goto reg_proc_write_exit;
+			read_val = regs_val & 0xffffffff;
+			rk32_dsi_write_reg(dsi1, regs_val >> 32, &read_val);
+			rk32_dsi_read_reg(dsi1, regs_val >> 32, &read_val);
+			regs_val &= 0xffffffff;
+			if (read_val != regs_val)
+				MIPI_TRACE("%s fail:0x%08x\n", __func__, read_val);
+			data += 3;
+			msleep(1);
+		}
+		break;
+	case 'r':
+		data = strstr(data, "0x");
+		if (data == NULL)
+			goto reg_proc_write_exit;
+		sscanf(data, "0x%llx", &regs_val);
+		rk32_dsi_read_reg(dsi1, (u16)regs_val, &read_val);
+		MIPI_TRACE("*%04x : %08x\n", (u16)regs_val, read_val);
+		msleep(1);
+		break;
+	case 's':
+		while (*(++data) == ' ')
+			;
+		sscanf(data, "%d", &read_val);
+		if (read_val == 11)
+			read_val = 11289600;
+		else
+			read_val *= MHz;
+		break;
+	case 'd':
+	case 'g':
+	case 'c':
+		while (*(++data) == ' ')
+			;
+		i = 0;
+		MIPI_TRACE("****%d:%d\n", data-buf, count);
+		do {
+			if (i > 31) {
+				MIPI_TRACE("payload entry is larger than 32\n");
+				break;
 			}
-		
-			break;
-		case 'r':
-				data = strstr(data, "0x");
-				if(data == NULL)
-					goto reg_proc_write_exit;
-				sscanf(data, "0x%llx", &regs_val);
-				rk32_dsi_read_reg(dsi1, (u16)regs_val, &read_val);
-				MIPI_TRACE("*%04x : %08x\n", (u16)regs_val, read_val);
-				msleep(1);	
-			break;	
-	
-		case 's':
-				while(*(++data) == ' ');
-				sscanf(data, "%d", &read_val);
-				if(read_val == 11)
-					read_val = 11289600;
-				else	
-					read_val *= MHz;
-
-				//rk32_mipi_dsi_init_lite(dsi);
-			break;
-		case 'd':
-		case 'g':
-		case 'c':
-				while(*(++data) == ' ');
-				i = 0;
-				MIPI_TRACE("****%d:%d\n", data-buf, count);
-				
-				do {
-					if(i > 31) {
-						MIPI_TRACE("payload entry is larger than 32\n");
-						break;
-					}	
-					sscanf(data, "%x,", (unsigned int *)(str + i));   //-c 1,29,02,03,05,06,> pro
-					data = strstr(data, ",");
-					if(data == NULL)
-						break;
-					data++;	
-					i++;
-				} while(1);
-				read_val = i;
-				
-				i = 2;
-				while(i--) {
-					msleep(10);
-					if(command == 'd')
-						rk32_mipi_dsi_send_packet(dsi1, str, read_val);
-					else
-						rk32_mipi_dsi_send_packet(dsi1, str, read_val);
-				}	
-				i = 1;
-				while(i--) {
-					msleep(1000);
-				}
-			break;
-	
-		default:
-			break;
+			sscanf(data, "%x,", (unsigned int *)(str + i)); /* -c 1,29,02,03,05,06,> pro */
+			data = strstr(data, ",");
+			if (data == NULL)
+				break;
+			data++;
+			i++;
+		} while (1);
+		read_val = i;
+		i = 2;
+		while (i--) {
+			msleep(10);
+			if (command == 'd')
+				rk32_mipi_dsi_send_packet(dsi1, str, read_val);
+			else
+				rk32_mipi_dsi_send_packet(dsi1, str, read_val);
+		}
+		i = 1;
+		while (i--) {
+			msleep(1000);
+		}
+		break;
+	default:
+		break;
 	}
 
 reg_proc_write_exit:
 	kfree(buf);
 	msleep(20);
- 	return count;
+	return count;
 }
 
-int reg_proc_read1(struct file *file, char __user *buff, size_t count, 
+int reg_proc_read1(struct file *file, char __user *buff, size_t count,
 					loff_t *offp)
 {
 	int i = 0;
 	u32 val = 0;
-	
-	for(i = VERSION; i < (VERSION + (0xdc<<16)); i += 4<<16) {
+
+	for (i = VERSION; i < (VERSION + (0xdc<<16)); i += 4<<16) {
 		val = rk32_dsi_get_bits(dsi1, i);
 		MIPI_TRACE("%04x: %08x\n", i>>16, val);
 		msleep(1);
 	}
-	
+
 	MIPI_TRACE("\n");
 	return -1;
 }
@@ -1594,14 +1511,14 @@ int reg_proc_close1(struct inode *inode, struct file *file)
 }
 
 struct file_operations reg_proc_fops1 = {
-	.owner  = THIS_MODULE,
-	.open   = reg_proc_open1,
-	.release= reg_proc_close1,
-	.write  = reg_proc_write1,
-	.read   = reg_proc_read1,
+	.owner = THIS_MODULE,
+	.open = reg_proc_open1,
+	.release = reg_proc_close1,
+	.write = reg_proc_write1,
+	.read = reg_proc_read1,
 };
 #endif
-#if 0//def CONFIG_MIPI_DSI_LINUX
+#if 0/* def CONFIG_MIPI_DSI_LINUX */
 static irqreturn_t rk32_mipi_dsi_irq_handler(int irq, void *data)
 {
 	printk("-------rk32_mipi_dsi_irq_handler-------\n");
@@ -1612,16 +1529,14 @@ static irqreturn_t rk32_mipi_dsi_irq_handler(int irq, void *data)
 #if 0
 static int dwc_phy_test_rd(struct dsi *dsi, unsigned char test_code)
 {
-    int val = 0;
+	int val = 0;
 
-    rk32_dsi_set_bits(dsi, 0x10000 | test_code, PHY_TEST_CTRL1);
-    rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
-    rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
+	rk32_dsi_set_bits(dsi, 0x10000 | test_code, PHY_TEST_CTRL1);
+	rk32_dsi_set_bits(dsi, 0x2, PHY_TEST_CTRL0);
+	rk32_dsi_set_bits(dsi, 0x0, PHY_TEST_CTRL0);
 
 	val = rk32_dsi_get_bits(dsi, PHY_TEST_CTRL1);
-
-
-    return val;
+	return val;
 }
 #endif
 static int rk32_dsi_enable(void)
@@ -1630,9 +1545,9 @@ static int rk32_dsi_enable(void)
 	rk_fb_get_prmry_screen(dsi0->screen.screen);
 	dsi0->screen.lcdc_id = dsi0->screen.screen->lcdc_id;
 	rk32_init_phy_mode(dsi0->screen.lcdc_id);
-	
+
 	dsi_init(0, 0);
-	if (rk_mipi_get_dsi_num() ==2)
+	if (rk_mipi_get_dsi_num() == 2)
 		dsi_init(1, 0);
 
 	rk_mipi_screen_standby(0);
@@ -1642,17 +1557,16 @@ static int rk32_dsi_enable(void)
 		pixel data, and preventing image transmission in the middle of a frame.
 	*/
 	dsi_is_enable(0, 0);
-	if (rk_mipi_get_dsi_num() ==2)
-		dsi_is_enable(1, 0);  
+	if (rk_mipi_get_dsi_num() == 2)
+		dsi_is_enable(1, 0);
 
 	dsi_enable_video_mode(0, 1);
-	if (rk_mipi_get_dsi_num() ==2)
+	if (rk_mipi_get_dsi_num() == 2)
 		dsi_enable_video_mode(1, 1);
 
 	dsi_is_enable(0, 1);
-	if (rk_mipi_get_dsi_num() ==2)
+	if (rk_mipi_get_dsi_num() == 2)
 		dsi_is_enable(1, 1);
-
 	return 0;
 }
 
@@ -1667,8 +1581,7 @@ static int rk32_dsi_disable(void)
 	return 0;
 }
 
-static struct rk_fb_trsm_ops trsm_dsi_ops = 
-{
+static struct rk_fb_trsm_ops trsm_dsi_ops = {
 	.enable = rk32_dsi_enable,
 	.disable = rk32_dsi_disable,
 	.dsp_pwr_on = rk32_mipi_power_up_DDR,
@@ -1676,35 +1589,30 @@ static struct rk_fb_trsm_ops trsm_dsi_ops =
 };
 #endif
 static void rk32_init_phy_mode(int lcdc_id)
-{ 
+{
 	int val0 = 0, val1 = 0;
 
-	MIPI_DBG("rk32_init_phy_mode----------lcdc_id=%d\n",lcdc_id);
-	
+	MIPI_DBG("rk32_init_phy_mode----------lcdc_id=%d\n", lcdc_id);
+
 	if (dsi0->ops.id == DWC_DSI_VERSION_RK312x)
 		return;
-	
-	//D-PHY mode select
-	if( rk_mipi_get_dsi_num() ==1 ){
-	
-		if(lcdc_id == 1)
-			//val0 =0x1 << 25 | 0x1 << 9;
-			val0 = 0x1 << 22 | 0x1 << 6;  //1'b1: VOP LIT output to DSI host0;1'b0: VOP BIG output to DSI host0
-		else
-			val0 = 0x1 << 22 | 0x0 << 6; 
 
+	/* D-PHY mode select */
+	if (rk_mipi_get_dsi_num() == 1) {
+		if (lcdc_id == 1)
+			/* 1'b1: VOP LIT output to DSI host0;1'b0: VOP BIG output to DSI host0 */
+			val0 = 0x1 << 22 | 0x1 << 6;
+		else
+			val0 = 0x1 << 22 | 0x0 << 6;
 		writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
-	}
-	else{
-		if(lcdc_id == 1){
-			val0 = 0x1 << 25 | 0x1 <<  9 | 0x1 << 22 | 0x1 <<  6; 
-			val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14; 
-		}
-		else{
-			val0 = 0x1 << 25 | 0x0 <<  9 | 0x1 << 22 | 0x0 << 14; 
-			val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14; 
+	} else {
+		if (lcdc_id == 1) {
+			val0 = 0x1 << 25 | 0x1 <<  9 | 0x1 << 22 | 0x1 <<  6;
+			val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14;
+		} else {
+			val0 = 0x1 << 25 | 0x0 <<  9 | 0x1 << 22 | 0x0 << 14;
+			val1 = 0x1 << 31 | 0x1 << 30 | 0x0 << 15 | 0x1 << 14;
 		}
-
 		writel_relaxed(val0, RK_GRF_VIRT + RK3288_GRF_SOC_CON6);
 		writel_relaxed(val1, RK_GRF_VIRT + RK3288_GRF_SOC_CON14);
 	}
@@ -1712,28 +1620,28 @@ static void rk32_init_phy_mode(int lcdc_id)
 
 #ifdef CONFIG_MIPI_DSI_LINUX
 static int rk32_mipi_power_down_DDR(void)
-{	
-	dsi_is_enable(0, 0);	
-	if (rk_mipi_get_dsi_num() ==2)	    
-		dsi_is_enable(1, 0);  		
-	return 0;   
+{
+	dsi_is_enable(0, 0);
+	if (rk_mipi_get_dsi_num() == 2)
+		dsi_is_enable(1, 0);
+	return 0;
 }
 
 static int rk32_mipi_power_up_DDR(void)
-{	
-	dsi_is_enable(0, 0);	
-	if (rk_mipi_get_dsi_num() ==2)	    
-		dsi_is_enable(1, 0);     		
-	dsi_enable_video_mode(0, 1);	
-	dsi_enable_video_mode(1, 1);		
-	dsi_is_enable(0, 1);	
-	if (rk_mipi_get_dsi_num() ==2)	    
-		dsi_is_enable(1, 1);	
+{
+	dsi_is_enable(0, 0);
+	if (rk_mipi_get_dsi_num() == 2)
+		dsi_is_enable(1, 0);
+	dsi_enable_video_mode(0, 1);
+	dsi_enable_video_mode(1, 1);
+	dsi_is_enable(0, 1);
+	if (rk_mipi_get_dsi_num() == 2)
+		dsi_is_enable(1, 1);
 	return 0;
 }
 
 struct dsi_type {
-	char * label;
+	char *label;
 	u32 dsi_id;
 };
 
@@ -1750,21 +1658,21 @@ static struct dsi_type dsi_rk32 = {
 static const struct of_device_id of_rk_mipi_dsi_match[] = {
 	{ .compatible = "rockchip,rk32-dsi", .data = &dsi_rk32},
 	{ .compatible = "rockchip,rk312x-dsi", .data = &dsi_rk312x},
-	{ /* Sentinel */ } 
-}; 
+	{ /* Sentinel */ }
+};
 
 static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 {
-	int ret = 0; 
-	static int id = 0;
+	int ret = 0;
+	static int id;
 	struct dsi *dsi;
 	struct mipi_dsi_ops *ops;
 	struct rk_screen *screen;
 	struct mipi_dsi_screen *dsi_screen;
 	struct resource *res_host, *res_phy;
 	const struct dsi_type *data;
- 	const struct of_device_id *of_id =
-		of_match_device(of_rk_mipi_dsi_match, &pdev->dev);
+	const struct of_device_id *of_id =
+			of_match_device(of_rk_mipi_dsi_match, &pdev->dev);
 	if (!of_id) {
 		dev_err(&pdev->dev, "failed to match device\n");
 		return -ENODEV;
@@ -1772,8 +1680,8 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	data = of_id->data;
 
 	dsi = devm_kzalloc(&pdev->dev, sizeof(struct dsi), GFP_KERNEL);
-	if(!dsi) {
-		dev_err(&pdev->dev,"request struct dsi fail!\n");
+	if (!dsi) {
+		dev_err(&pdev->dev, "request struct dsi fail!\n");
 		return -ENOMEM;
 	}
 	dsi->ops.id = data->dsi_id;
@@ -1782,26 +1690,26 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	if (dsi->ops.id == DWC_DSI_VERSION) {
 		res_host = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 		dsi->host.membase = devm_request_and_ioremap(&pdev->dev, res_host);
-		if (!dsi->host.membase){
+		if (!dsi->host.membase) {
 			dev_err(&pdev->dev, "get resource mipi host membase fail!\n");
 			return -ENOMEM;
 		}
-	}else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
+	} else if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
 		res_host = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_dsi_host");
 		dsi->host.membase = devm_request_and_ioremap(&pdev->dev, res_host);
-		if (!dsi->host.membase){
+		if (!dsi->host.membase) {
 			dev_err(&pdev->dev, "get resource mipi host membase fail!\n");
 			return -ENOMEM;
 		}
 		res_phy = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mipi_dsi_phy");
 		dsi->phy.membase = devm_request_and_ioremap(&pdev->dev, res_phy);
-		if (!dsi->phy.membase){
+		if (!dsi->phy.membase) {
 			dev_err(&pdev->dev, "get resource mipi phy membase fail!\n");
 			return -ENOMEM;
 		}
 	}
-	
-	dsi->phy.refclk  = devm_clk_get(&pdev->dev, "clk_mipi_24m"); 
+
+	dsi->phy.refclk  = devm_clk_get(&pdev->dev, "clk_mipi_24m");
 	if (unlikely(IS_ERR(dsi->phy.refclk))) {
 		dev_err(&pdev->dev, "get clk_mipi_24m clock fail\n");
 		return PTR_ERR(dsi->phy.refclk);
@@ -1813,8 +1721,8 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "get pclk_mipi_dsi clock fail\n");
 		return PTR_ERR(dsi->dsi_pclk);
 	}
-	
-	if(dsi->ops.id == DWC_DSI_VERSION_RK312x) {
+
+	if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
 		/* Get the mipi host pclk */
 		dsi->dsi_host_pclk = devm_clk_get(&pdev->dev, "pclk_mipi_dsi_host");
 		if (unlikely(IS_ERR(dsi->dsi_host_pclk))) {
@@ -1826,7 +1734,7 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 		if (unlikely(IS_ERR(dsi->h2p_hclk))) {
 			dev_err(&pdev->dev, "get hclk_vio_h2p clock fail\n");
 			return PTR_ERR(dsi->h2p_hclk);
-		}		
+		}
 	}
 	dsi->dsi_pd = devm_clk_get(&pdev->dev, "pd_mipi_dsi");
 	if (unlikely(IS_ERR(dsi->dsi_pd))) {
@@ -1838,19 +1746,20 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "no irq resource?\n");
 		return dsi->host.irq;
 	}
-	
-	//ret = request_irq(dsi->host.irq, rk32_mipi_dsi_irq_handler, 0,dev_name(&pdev->dev), dsi);
-	//if(ret) {
-	//	dev_err(&pdev->dev, "request mipi_dsi irq fail\n");
-	//	return -EINVAL;
-	//}
-	printk("dsi->host.irq =%d\n",dsi->host.irq); 
+	/*
+	ret = request_irq(dsi->host.irq, rk32_mipi_dsi_irq_handler, 0,dev_name(&pdev->dev), dsi);
+	if (ret) {
+		dev_err(&pdev->dev, "request mipi_dsi irq fail\n");
+		return -EINVAL;
+	}
+	*/
+	printk("dsi->host.irq =%d\n", dsi->host.irq);
 
 	disable_irq(dsi->host.irq);
 
 	screen = devm_kzalloc(&pdev->dev, sizeof(struct rk_screen), GFP_KERNEL);
-	if(!screen) {
-		dev_err(&pdev->dev,"request struct rk_screen fail!\n");
+	if (!screen) {
+		dev_err(&pdev->dev, "request struct rk_screen fail!\n");
 		return -1;
 	}
 	rk_fb_get_prmry_screen(screen);
@@ -1866,7 +1775,7 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	ops->dsi_enable_command_mode = rk32_mipi_dsi_enable_command_mode,
 	ops->dsi_enable_hs_clk = rk32_mipi_dsi_enable_hs_clk,
 	ops->dsi_is_active = rk32_mipi_dsi_is_active,
-	ops->dsi_is_enable= rk32_mipi_dsi_is_enable,
+	ops->dsi_is_enable = rk32_mipi_dsi_is_enable,
 	ops->power_up = rk32_mipi_dsi_power_up,
 	ops->power_down = rk32_mipi_dsi_power_down,
 	ops->dsi_init = rk_mipi_dsi_init,
@@ -1891,11 +1800,10 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	dsi_screen->pin_den = screen->pin_den;
 	dsi_screen->pin_dclk = screen->pin_dclk;
 	dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
-//  dsi_screen->dsi_video_mode = screen->dsi_video_mode; //no sure
+	/* dsi_screen->dsi_video_mode = screen->dsi_video_mode; */
 	dsi_screen->dsi_lane = rk_mipi_get_dsi_lane();
-	dsi_screen->hs_tx_clk = rk_mipi_get_dsi_clk();  
-	//dsi_screen->lcdc_id = 1;
-
+	dsi_screen->hs_tx_clk = rk_mipi_get_dsi_clk();
+	/* dsi_screen->lcdc_id = 1; */
 
 	dsi->dsi_id = id++;
 
@@ -1903,57 +1811,55 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, dsi);
 
 	ret = rk_mipi_dsi_probe(dsi);
-	if(ret) {
-		dev_err(&pdev->dev,"rk mipi_dsi probe fail!\n");
-		dev_err(&pdev->dev,"%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
+	if (ret) {
+		dev_err(&pdev->dev, "rk mipi_dsi probe fail!\n");
+		dev_err(&pdev->dev, "%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
 		return -1;
-	}	
-
-	if(id == 1){
+	}
 
-		//if(!support_uboot_display())
-		//	rk32_init_phy_mode(dsi_screen->lcdc_id);
+	if (id == 1) {
+		/*
+		if(!support_uboot_display())
+			rk32_init_phy_mode(dsi_screen->lcdc_id);
+		*/
 		rk_fb_trsm_ops_register(&trsm_dsi_ops, SCREEN_MIPI);
-	
-#ifdef MIPI_DSI_REGISTER_IO        
-		debugfs_create_file("mipidsi0", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi, 
+#ifdef MIPI_DSI_REGISTER_IO
+		debugfs_create_file("mipidsi0", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi,
 							&reg_proc_fops);
 #endif
 		dsi0 = dsi;
-	}else{   
+	} else {
 		dsi1 = dsi;
-
-#ifdef MIPI_DSI_REGISTER_IO  
-        debugfs_create_file("mipidsi1", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi, 
+#ifdef MIPI_DSI_REGISTER_IO
+		debugfs_create_file("mipidsi1", S_IFREG | S_IRUGO, dsi->debugfs_dir, dsi,
 							&reg_proc_fops1);
 #endif
-
 	}
 
-    if(support_uboot_display()){
-	    clk_prepare_enable(dsi->phy.refclk); 
-	    clk_prepare_enable(dsi->dsi_pclk);
+	if (support_uboot_display()) {
+		clk_prepare_enable(dsi->phy.refclk);
+		clk_prepare_enable(dsi->dsi_pclk);
 		if (dsi->ops.id == DWC_DSI_VERSION_RK312x) {
 			clk_prepare_enable(dsi->dsi_host_pclk);
 			clk_prepare_enable(dsi->h2p_hclk);
 		}
-	clk_prepare_enable(dsi->dsi_pd);
-	    udelay(10);
-    }
-	dev_info(&pdev->dev,"rk mipi_dsi probe success!\n");
-	dev_info(&pdev->dev,"%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
-	
+		clk_prepare_enable(dsi->dsi_pd);
+		udelay(10);
+	}
+	dev_info(&pdev->dev, "rk mipi_dsi probe success!\n");
+	dev_info(&pdev->dev, "%s\n", RK_MIPI_DSI_VERSION_AND_TIME);
+
 	return ret;
 }
 
 static struct platform_driver rk32_mipi_dsi_driver = {
-	.probe		= rk32_mipi_dsi_probe,
-	.driver		= {
-		.name	= "rk32-mipi",
-		.owner	= THIS_MODULE,
+	.probe = rk32_mipi_dsi_probe,
+	.driver = {
+		.name = "rk32-mipi",
+		.owner = THIS_MODULE,
 #ifdef CONFIG_OF
 		.of_match_table	= of_rk_mipi_dsi_match,
-#endif		
+#endif
 	},
 };
 
diff --git a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
index b2c223d442c4..923cf84c6a12 100755
--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
@@ -10,8 +10,8 @@ drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 #define RK_GRF_VIRT			RKIO_GRF_PHYS
 #define RK3288_CRU_PHYS			RKIO_CRU_PHYS
 
-#define RK3288_GRF_SOC_CON6             GRF_SOC_CON6
-#define RK3288_GRF_SOC_CON14            GRF_SOC_CON14
+#define RK3288_GRF_SOC_CON6		GRF_SOC_CON6
+#define RK3288_GRF_SOC_CON14		GRF_SOC_CON14
 #else
 #include <linux/rockchip/grf.h>
 #endif
@@ -20,41 +20,41 @@ drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 
 #define MIPI_DSI_HOST_OFFSET	0x1000
 
-//function bits definition    register addr | bits | offest
+/* function bits definition    register addr | bits | offest */
 #define REG_ADDR(a)			((a) << 16)
 #define REG_BITS(a)			((a) << 8)
 #define BITS_OFFSET(a)		(a)
 #define DSI_HOST_BITS(addr, bits, bit_offset)  (REG_ADDR((addr)+MIPI_DSI_HOST_OFFSET) \
-		| REG_BITS(bits) | BITS_OFFSET(bit_offset))  
+		| REG_BITS(bits) | BITS_OFFSET(bit_offset))
 #define DSI_DPHY_BITS(addr, bits, bit_offset)  (REG_ADDR((addr)+MIPI_DSI_PHY_OFFSET) \
-		| REG_BITS(bits) | BITS_OFFSET(bit_offset))		
+		| REG_BITS(bits) | BITS_OFFSET(bit_offset))
 
-//DWC_DSI_VERSION_0x3133302A
+/* DWC_DSI_VERSION_0x3133302A */
 #define VERSION 					DSI_HOST_BITS(0x000, 32, 0)
 #define shutdownz 					DSI_HOST_BITS(0x004, 1, 0)
 #define TO_CLK_DIVISION 			DSI_HOST_BITS(0x008, 8, 8)
 #define TX_ESC_CLK_DIVISION 		DSI_HOST_BITS(0x008, 8, 0)
 #define dpi_vcid					DSI_HOST_BITS(0x00c, 2, 0)
 #define en18_loosely 				DSI_HOST_BITS(0x010, 1, 8)
-#define dpi_color_coding 			DSI_HOST_BITS(0x010, 4, 0)        //need modify in code
+#define dpi_color_coding 			DSI_HOST_BITS(0x010, 4, 0)	/* need modify in code */
 #define colorm_active_low 			DSI_HOST_BITS(0x014, 1, 4)
 #define shutd_active_low  			DSI_HOST_BITS(0x014, 1, 3)
 #define hsync_active_low  			DSI_HOST_BITS(0x014, 1, 2)
 #define vsync_active_low  			DSI_HOST_BITS(0x014, 1, 1)
 #define dataen_active_low  			DSI_HOST_BITS(0x014, 1, 0)
-#define outvact_lpcmd_time  		DSI_HOST_BITS(0x018, 8, 16)   //attence
+#define outvact_lpcmd_time  		DSI_HOST_BITS(0x018, 8, 16)	/* attence */
 #define invact_lpcmd_time 			DSI_HOST_BITS(0x018, 8, 0)
-//#define dbi_vcid					DSI_HOST_BITS(0x01c, 2, 0)
+/* #define dbi_vcid					DSI_HOST_BITS(0x01c, 2, 0) */
 #define crc_rx_en 					DSI_HOST_BITS(0x02c, 1, 4)
 #define ecc_rx_en 					DSI_HOST_BITS(0x02c, 1, 3)
 #define bta_en 						DSI_HOST_BITS(0x02c, 1, 2)
 #define eotp_rx_en 					DSI_HOST_BITS(0x02c, 1, 1)
 #define eotp_tx_en 					DSI_HOST_BITS(0x02c, 1, 0)
-#define gen_vid_rx 					DSI_HOST_BITS(0x030, 2, 0) 
+#define gen_vid_rx 					DSI_HOST_BITS(0x030, 2, 0)
 #define cmd_video_mode 				DSI_HOST_BITS(0x034, 1, 0)
-#define vpg_orientation             DSI_HOST_BITS(0x038, 1, 24) 
-#define vpg_mode                    DSI_HOST_BITS(0x038, 1, 20) 
-#define vpg_en                      DSI_HOST_BITS(0x038, 1, 16) 
+#define vpg_orientation             DSI_HOST_BITS(0x038, 1, 24)
+#define vpg_mode                    DSI_HOST_BITS(0x038, 1, 20)
+#define vpg_en                      DSI_HOST_BITS(0x038, 1, 16)
 #define lp_cmd_en  					DSI_HOST_BITS(0x038, 1, 15)
 #define frame_bta_ack_en 			DSI_HOST_BITS(0x038, 1, 14)
 #define lp_hfp_en 					DSI_HOST_BITS(0x038, 1, 13)
@@ -88,92 +88,95 @@ drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 #define gen_sw_0p_tx 				DSI_HOST_BITS(0x068, 1, 8)
 #define ack_rqst_en 				DSI_HOST_BITS(0x068, 1, 1)
 #define tear_fx_en 					DSI_HOST_BITS(0x068, 1, 0)
-#define GEN_HDR						DSI_HOST_BITS(0x06c, 32, 0)    
-#define GEN_PLD_DATA				DSI_HOST_BITS(0x070, 32, 0)	  //need modify
+#define GEN_HDR						DSI_HOST_BITS(0x06c, 32, 0)
+#define GEN_PLD_DATA				DSI_HOST_BITS(0x070, 32, 0)
 #define gen_rd_cmd_busy  			DSI_HOST_BITS(0x074, 1, 6)
 #define gen_pld_r_full 				DSI_HOST_BITS(0x074, 1, 5)
 #define gen_pld_r_empty 			DSI_HOST_BITS(0x074, 1, 4)
-#define gen_pld_w_full 				DSI_HOST_BITS(0x074, 1, 3)     //800byte    write GEN_PLD_DATA
+#define gen_pld_w_full 				DSI_HOST_BITS(0x074, 1, 3)	/* 800byte    write GEN_PLD_DATA */
 #define gen_pld_w_empty				DSI_HOST_BITS(0x074, 1, 2)
-#define gen_cmd_full 				DSI_HOST_BITS(0x074, 1, 1)     //20   write GEN_HDR
+#define gen_cmd_full 				DSI_HOST_BITS(0x074, 1, 1)	/* 20   write GEN_HDR */
 #define gen_cmd_empty 				DSI_HOST_BITS(0x074, 1, 0)
-#define hstx_to_cnt 				DSI_HOST_BITS(0x078, 16, 16)   //need modify
+#define hstx_to_cnt 				DSI_HOST_BITS(0x078, 16, 16)
 #define lprx_to_cnt 				DSI_HOST_BITS(0x078, 16, 0)
-#define hs_rd_to_cnt 				DSI_HOST_BITS(0x07c, 16, 0)     //new(read)
-#define lp_rd_to_cnt 				DSI_HOST_BITS(0x080, 16, 0)		//new(read)
-#define presp_to_mode 				DSI_HOST_BITS(0x084, 1, 24)		//new
-#define hs_wr_to_cnt 				DSI_HOST_BITS(0x084, 16, 0)		//new
-#define lp_wr_to_cnt 				DSI_HOST_BITS(0x088, 16, 0)		//new
-#define bta_to_cnt 					DSI_HOST_BITS(0x08c, 16, 0)		//new
-//#define send_3d_cfg 				DSI_HOST_BITS(0x090, 1, 16)		//new
-//#define right_first 				DSI_HOST_BITS(0x090, 1, 5)		//new
-//#define second_vsync 				DSI_HOST_BITS(0x090, 1, 4)		//new
-//#define format_3d 					DSI_HOST_BITS(0x090, 2, 2)		//new
-//#define mode_3d		 				DSI_HOST_BITS(0x090, 2, 0)		//new
-#define auto_clklane_ctrl 			DSI_HOST_BITS(0x094, 1, 1)		//new
+#define hs_rd_to_cnt 				DSI_HOST_BITS(0x07c, 16, 0)
+#define lp_rd_to_cnt 				DSI_HOST_BITS(0x080, 16, 0)
+#define presp_to_mode 				DSI_HOST_BITS(0x084, 1, 24)
+#define hs_wr_to_cnt 				DSI_HOST_BITS(0x084, 16, 0)
+#define lp_wr_to_cnt 				DSI_HOST_BITS(0x088, 16, 0)
+#define bta_to_cnt 					DSI_HOST_BITS(0x08c, 16, 0)
+/*
+#define send_3d_cfg 				DSI_HOST_BITS(0x090, 1, 16)
+#define right_first 				DSI_HOST_BITS(0x090, 1, 5)
+#define second_vsync 				DSI_HOST_BITS(0x090, 1, 4)
+#define format_3d 					DSI_HOST_BITS(0x090, 2, 2)
+#define mode_3d		 				DSI_HOST_BITS(0x090, 2, 0)
+*/
+#define auto_clklane_ctrl 			DSI_HOST_BITS(0x094, 1, 1)
 #define phy_txrequestclkhs 			DSI_HOST_BITS(0x094, 1, 0)
-#define phy_hs2lp_time_clk_lane     DSI_HOST_BITS(0x098, 10, 16) 
-#define phy_hs2hs_time_clk_lane     DSI_HOST_BITS(0x098, 10, 0) 
+#define phy_hs2lp_time_clk_lane			DSI_HOST_BITS(0x098, 10, 16)
+#define phy_hs2hs_time_clk_lane			DSI_HOST_BITS(0x098, 10, 0)
 #define phy_hs2lp_time 				DSI_HOST_BITS(0x09c, 8, 24)
 #define phy_lp2hs_time 				DSI_HOST_BITS(0x09c, 8, 16)
 #define max_rd_time 				DSI_HOST_BITS(0x09c, 15, 0)
-#define phy_forcepll 				DSI_HOST_BITS(0x0a0, 1, 3)		//new Dependency: DSI_HOST_FPGA = 0. Otherwise, this bit is reserved.
+/* new Dependency: DSI_HOST_FPGA = 0. Otherwise, this bit is reserved. */
+#define phy_forcepll 				DSI_HOST_BITS(0x0a0, 1, 3)
 #define phy_enableclk 				DSI_HOST_BITS(0x0a0, 1, 2)
-#define phy_rstz 					DSI_HOST_BITS(0x0a0, 1, 1) 
-#define phy_shutdownz 				DSI_HOST_BITS(0x0a0, 1, 0) 
+#define phy_rstz 				DSI_HOST_BITS(0x0a0, 1, 1)
+#define phy_shutdownz 				DSI_HOST_BITS(0x0a0, 1, 0)
 #define phy_stop_wait_time 			DSI_HOST_BITS(0x0a4, 8, 8)
-#define n_lanes 					DSI_HOST_BITS(0x0a4, 2, 0)
+#define n_lanes					DSI_HOST_BITS(0x0a4, 2, 0)
 #define phy_txexitulpslan 			DSI_HOST_BITS(0x0a8, 1, 3)
 #define phy_txrequlpslan 			DSI_HOST_BITS(0x0a8, 1, 2)
 #define phy_txexitulpsclk 			DSI_HOST_BITS(0x0a8, 1, 1)
 #define phy_txrequlpsclk 			DSI_HOST_BITS(0x0a8, 1, 0)
 #define phy_tx_triggers 			DSI_HOST_BITS(0x0ac, 4, 0)
 
-#define phystopstateclklane 		DSI_HOST_BITS(0x0b0, 1, 2)
-#define phylock 					DSI_HOST_BITS(0x0b0, 1, 0)
-#define phy_testclk 				DSI_HOST_BITS(0x0b4, 1, 1)
-#define phy_testclr 				DSI_HOST_BITS(0x0b4, 1, 0)
-#define phy_testen  				DSI_HOST_BITS(0x0b8, 1, 16)
-#define phy_testdout 				DSI_HOST_BITS(0x0b8, 8, 8)
-#define phy_testdin 				DSI_HOST_BITS(0x0b8, 8, 0)
+#define phystopstateclklane			DSI_HOST_BITS(0x0b0, 1, 2)
+#define phylock					DSI_HOST_BITS(0x0b0, 1, 0)
+#define phy_testclk				DSI_HOST_BITS(0x0b4, 1, 1)
+#define phy_testclr				DSI_HOST_BITS(0x0b4, 1, 0)
+#define phy_testen				DSI_HOST_BITS(0x0b8, 1, 16)
+#define phy_testdout				DSI_HOST_BITS(0x0b8, 8, 8)
+#define phy_testdin				DSI_HOST_BITS(0x0b8, 8, 0)
 
 #define PHY_TEST_CTRL1 				DSI_HOST_BITS(0x0b8, 17, 0)
-#define PHY_TEST_CTRL0              DSI_HOST_BITS(0x0b4, 2, 0)
+#define PHY_TEST_CTRL0				DSI_HOST_BITS(0x0b4, 2, 0)
 
 #define INT_ST0 					DSI_HOST_BITS(0x0bc, 21, 0)
 #define INT_ST1 					DSI_HOST_BITS(0x0c0, 18, 0)
 #define INT_MKS0 					DSI_HOST_BITS(0x0c4, 21, 0)
-#define INT_MKS1 					DSI_HOST_BITS(0x0c8, 18, 0) 
-#define INT_FORCE0 					DSI_HOST_BITS(0x0d8, 21, 0) 
-#define INT_FORCE1 					DSI_HOST_BITS(0x0dc, 18, 0) 
+#define INT_MKS1 					DSI_HOST_BITS(0x0c8, 18, 0)
+#define INT_FORCE0 					DSI_HOST_BITS(0x0d8, 21, 0)
+#define INT_FORCE1 					DSI_HOST_BITS(0x0dc, 18, 0)
 
-#define code_hs_rx_clock            0x34
-#define code_hs_rx_lane0            0x44
-#define code_hs_rx_lane1            0x54
-#define code_hs_rx_lane2            0x84
-#define code_hs_rx_lane3            0x94
+#define code_hs_rx_clock		0x34
+#define code_hs_rx_lane0		0x44
+#define code_hs_rx_lane1		0x54
+#define code_hs_rx_lane2		0x84
+#define code_hs_rx_lane3		0x94
 
-#define code_pll_input_div_rat      0x17
-#define code_pll_loop_div_rat       0x18 
-#define code_pll_input_loop_div_rat 0x19 
+#define code_pll_input_div_rat		0x17
+#define code_pll_loop_div_rat		0x18
+#define code_pll_input_loop_div_rat	0x19
 
-#define code_hstxdatalanerequsetstatetime   0x70
-#define code_hstxdatalanepreparestatetime   0x71
-#define code_hstxdatalanehszerostatetime    0x72
+#define code_hstxdatalanerequsetstatetime	0x70
+#define code_hstxdatalanepreparestatetime	0x71
+#define code_hstxdatalanehszerostatetime	0x72
 
-//rk312x MIPI DSI DPHY REGISTERS
+/* rk312x MIPI DSI DPHY REGISTERS */
 #define DPHY_REGISTER0				DSI_DPHY_BITS(0x00, 32, 0)
 #define DPHY_REGISTER1				DSI_DPHY_BITS(0x04, 32, 0)
 #define DPHY_REGISTER3				DSI_DPHY_BITS(0x0c, 32, 0)
 #define DPHY_REGISTER4				DSI_DPHY_BITS(0x10, 32, 0)
 #define DPHY_REGISTER20				DSI_DPHY_BITS(0X80, 32, 0)
 
-#define lane_en_ck 					DSI_DPHY_BITS(0x00, 1, 6)
-#define lane_en_3 					DSI_DPHY_BITS(0x00, 1, 5)
-#define lane_en_2 					DSI_DPHY_BITS(0x00, 1, 4)
-#define lane_en_1 					DSI_DPHY_BITS(0x00, 1, 3)
-#define lane_en_0 					DSI_DPHY_BITS(0x00, 1, 2)
-#define reg0_phy 					DSI_DPHY_BITS(0x00, 8, 0)
+#define lane_en_ck 				DSI_DPHY_BITS(0x00, 1, 6)
+#define lane_en_3 				DSI_DPHY_BITS(0x00, 1, 5)
+#define lane_en_2 				DSI_DPHY_BITS(0x00, 1, 4)
+#define lane_en_1 				DSI_DPHY_BITS(0x00, 1, 3)
+#define lane_en_0 				DSI_DPHY_BITS(0x00, 1, 2)
+#define reg0_phy 				DSI_DPHY_BITS(0x00, 8, 0)
 
 #define reg_da_ppfc 				DSI_DPHY_BITS(0x04, 1, 4)
 #define reg_da_syncrst 				DSI_DPHY_BITS(0x04, 1, 2)
@@ -186,11 +189,11 @@ drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 #define reg8_phy 				DSI_DPHY_BITS(0x20, 4, 0)
 
 #define reg_fbdiv_8 				DSI_DPHY_BITS(0x0c, 1, 5)
-#define reg_prediv 					DSI_DPHY_BITS(0x0c, 5, 0)
-#define reg_fbdiv 					DSI_DPHY_BITS(0x10, 8, 0)
+#define reg_prediv 				DSI_DPHY_BITS(0x0c, 5, 0)
+#define reg_fbdiv 				DSI_DPHY_BITS(0x10, 8, 0)
 #define reg9_phy 				DSI_DPHY_BITS(0x24, 8, 0)
 #define reg10_phy 				DSI_DPHY_BITS(0X40, 8, 0)
-#define reg10_4_6_phy			DSI_DPHY_BITS(0X40, 3, 4)
+#define reg10_4_6_phy				DSI_DPHY_BITS(0X40, 3, 4)
 #define regb_phy 				DSI_DPHY_BITS(0X2c, 4, 0)
 
 #define reg_dig_rstn 				DSI_DPHY_BITS(0X80, 1, 0)
@@ -203,72 +206,74 @@ drivers/video/rockchip/transmitter/rk32_mipi_dsi.h
 #define DPHY_LANE3_OFFSET			REG_ADDR(0X0300)
 
 #define reg_ths_settle				DSI_DPHY_BITS(0x0000, 4, 0)
-#define reg_hs_tlpx					DSI_DPHY_BITS(0x0014, 6, 0)
+#define reg_hs_tlpx				DSI_DPHY_BITS(0x0014, 6, 0)
 #define reg_hs_ths_prepare			DSI_DPHY_BITS(0x0018, 7, 0)
 #define reg_hs_the_zero				DSI_DPHY_BITS(0x001c, 6, 0)
 #define reg_hs_ths_trail			DSI_DPHY_BITS(0x0020, 7, 0)
 #define reg_hs_ths_exit				DSI_DPHY_BITS(0x0024, 5, 0)
 #define reg_hs_tclk_post			DSI_DPHY_BITS(0x0028, 4, 0)
-#define reserved					DSI_DPHY_BITS(0x002c, 1, 0)
+#define reserved				DSI_DPHY_BITS(0x002c, 1, 0)
 #define reg_hs_twakup_h				DSI_DPHY_BITS(0x0030, 2, 0)
 #define reg_hs_twakup_l				DSI_DPHY_BITS(0x0034, 8, 0)
 #define reg_hs_tclk_pre				DSI_DPHY_BITS(0x0038, 4, 0)
 #define reg_hs_tta_go				DSI_DPHY_BITS(0x0040, 6, 0)
 #define reg_hs_tta_sure				DSI_DPHY_BITS(0x0044, 6, 0)
 #define reg_hs_tta_wait				DSI_DPHY_BITS(0x0048, 6, 0)
-//end of rk312x MIPI DSI DPHY REGISTERS
+/* end of rk312x MIPI DSI DPHY REGISTERS */
 
-//global operation timing parameter
+/* global operation timing parameter */
 struct gotp_m {
-	//time uint is ns
+	/* time uint is ns */
 	u32 min;
 	u32 value;
 	u32 max;
 };
 
-//default time unit is ns 
-//Unit Interval, equal to the duration of any HS state on the Clock Lane
+/*
+ * default time unit is ns
+ * Unit Interval, equal to the duration of any HS state on the Clock Lane
+*/
 struct gotp {
-	u32 CLK_MISS;    			//min:no    max:60
-	u32 CLK_POST;    			//min:60 ns + 52*UI    max:no
-	u32 CLK_PRE;     			//min:8*UI    max:no
-	u32 CLK_PREPARE;  			//min:38    max:95
-	u32 CLK_SETTLE;    			//min:95    max:300
-	u32 CLK_TERM_EN;    		//min:Time for Dn to reach VTERM-EN    max:38
-	u32 CLK_TRAIL;    			//min:60    max:no
-	u32 CLK_ZERO;    			//min:300 - CLK_PREPARE    max:no
-	u32 D_TERM_EN;    			//min:Time for Dn to reach VTERM-EN    max:35 ns + 4*UI
-	u32 EOT;    				//min:no    max:105 ns + n*12*UI
-	u32 HS_EXIT;    			//min:100    max:no
-	u32 HS_PREPARE;    			//min:40 ns + 4*UI     max:85 ns + 6*UI	
-	u32 HS_ZERO;    			//min:145 ns + 10*UI - HS_PREPARE    max:no
-	u32 HS_SETTLE;    			//min:85 ns + 6*UI     max:145 ns + 10*UI
-	u32 HS_SKIP;    			//min:40    max:55 ns + 4*UI
-	u32 HS_TRAIL;    			//min: max( n*8*UI, 60 ns + n*4*UI )    max:no
-	u32 NIT;    				//min:100us    max:no
-	u32 LPX;    				//min:50    max:no
-	u32 TA_GET;    				//min:5*TLPX    
-	u32 TA_GO;    				//min:4*TLPX    	
-	u32 TA_SURE;    			//min:TLPX    max:2*TLPX
-	u32 WAKEUP;    				//min:1ms    max:no
+	u32 CLK_MISS;		/* min:no    max:60 */
+	u32 CLK_POST;		/* min:60 ns + 52*UI    max:no */
+	u32 CLK_PRE;		/* min:8*UI    max:no */
+	u32 CLK_PREPARE;	/* min:38    max:95 */
+	u32 CLK_SETTLE;		/* min:95    max:300 */
+	u32 CLK_TERM_EN;	/* min:Time for Dn to reach VTERM-EN    max:38 */
+	u32 CLK_TRAIL;		/* min:60    max:no */
+	u32 CLK_ZERO;		/* min:300 - CLK_PREPARE    max:no */
+	u32 D_TERM_EN;		/* min:Time for Dn to reach VTERM-EN    max:35 ns + 4*UI */
+	u32 EOT;		/* min:no    max:105 ns + n*12*UI */
+	u32 HS_EXIT;		/* min:100    max:no */
+	u32 HS_PREPARE;		/* min:40 ns + 4*UI     max:85 ns + 6*UI */
+	u32 HS_ZERO;		/* min:145 ns + 10*UI - HS_PREPARE    max:no */
+	u32 HS_SETTLE;		/* min:85 ns + 6*UI     max:145 ns + 10*UI */
+	u32 HS_SKIP;		/* min:40    max:55 ns + 4*UI */
+	u32 HS_TRAIL;		/* min: max( n*8*UI, 60 ns + n*4*UI )    max:no */
+	u32 NIT;		/* min:100us    max:no */
+	u32 LPX;		/* min:50    max:no */
+	u32 TA_GET;		/* min:5*TLPX */
+	u32 TA_GO;		/* min:4*TLPX */
+	u32 TA_SURE;		/* min:TLPX    max:2*TLPX */
+	u32 WAKEUP;		/* min:1ms    max:no */
 };
 
 struct dsi_phy {
 	u32 UI;
-	u32 ref_clk;     	//input_clk
-	u32 ddr_clk;		//data bit clk
-	u32 txbyte_clk;		//1/8 of ddr_clk
-	u32 sys_clk;		//
-	u32 pclk;			//
+	u32 ref_clk;		/* input_clk */
+	u32 ddr_clk;		/* data bit clk */
+	u32 txbyte_clk;		/* 1/8 of ddr_clk */
+	u32 sys_clk;
+	u32 pclk;
 	u32 txclkesc;
-	
-	u32 Tddr_clk;		//ps
-	u32 Ttxbyte_clk;   	//ps
-	u32 Tsys_clk;   	//ps
-	u32 Tpclk;   		//ps
-	u32 Ttxclkesc;		//ps
 
-	struct clk	*refclk; 
+	u32 Tddr_clk;		/* ps */
+	u32 Ttxbyte_clk;	/* ps */
+	u32 Tsys_clk;		/* ps */
+	u32 Tpclk;		/* ps */
+	u32 Ttxclkesc;		/* ps */
+
+	struct clk	*refclk;
 	unsigned long iobase;
 	void __iomem *membase;
 	u16 prediv;
@@ -298,8 +303,8 @@ struct dsi {
 	struct mipi_dsi_ops ops;
 	struct mipi_dsi_screen screen;
 #ifdef CONFIG_MIPI_DSI_LINUX
-	struct clk	*dsi_pclk;		// for mipi phy
-	struct clk	*dsi_host_pclk;	// for mipi host
+	struct clk	*dsi_pclk; /* for mipi phy */
+	struct clk	*dsi_host_pclk; /* for mipi host */
 	struct clk	*h2p_hclk;
 	struct clk	*dsi_pd;
 #endif
-- 
2.35.3

