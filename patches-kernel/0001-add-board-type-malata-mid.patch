From d43633e88d79c477b7096e0b15375c13a81029d0 Mon Sep 17 00:00:00 2001
From: kfx <kfx@rock-chips.com>
Date: Wed, 26 Jan 2011 17:24:53 +0800
Subject: [PATCH] add board type: malata(mid)

---
 arch/arm/configs/rk29_malata_defconfig        | 1967 +++++
 arch/arm/mach-rk29/Kconfig                    |    5 +
 arch/arm/mach-rk29/Makefile                   |    1 +
 arch/arm/mach-rk29/board-malata.c             | 1884 +++++
 arch/arm/mach-rk29/include/mach/board.h       |   23 +
 arch/arm/mach-rk29/include/mach/rk29_camera.h |    1 +
 drivers/input/keyboard/Kconfig                |    7 +-
 drivers/input/keyboard/Makefile               |    1 +
 drivers/input/keyboard/synaptics_so340010.c   |  459 ++
 drivers/input/touchscreen/Kconfig             |   27 +
 drivers/input/touchscreen/Makefile            |    1 +
 drivers/input/touchscreen/malata.h            |   76 +
 drivers/input/touchscreen/sintek_3FA16.c      |  514 ++
 drivers/media/video/Kconfig                   |    7 +-
 drivers/media/video/Makefile                  |    1 +
 drivers/media/video/s5k6aa.c                  | 6363 +++++++++++++++++
 drivers/media/video/s5k6aa.h                  |   10 +
 drivers/power/Kconfig                         |   11 +-
 drivers/power/Makefile                        |    3 +-
 drivers/power/bq3060_battery.c                |  505 ++
 drivers/video/display/screen/Kconfig          |    2 +
 drivers/video/display/screen/Makefile         |    1 +
 drivers/video/display/screen/lcd_B101AW06.c   |   76 +
 include/media/v4l2-chip-ident.h               |    1 +
 sound/soc/codecs/wm8900.c                     |   29 +-
 25 files changed, 11966 insertions(+), 9 deletions(-)
 create mode 100644 arch/arm/configs/rk29_malata_defconfig
 create mode 100755 arch/arm/mach-rk29/board-malata.c
 create mode 100755 drivers/input/keyboard/synaptics_so340010.c
 create mode 100755 drivers/input/touchscreen/malata.h
 create mode 100755 drivers/input/touchscreen/sintek_3FA16.c
 create mode 100755 drivers/media/video/s5k6aa.c
 create mode 100755 drivers/media/video/s5k6aa.h
 create mode 100755 drivers/power/bq3060_battery.c
 create mode 100755 drivers/video/display/screen/lcd_B101AW06.c

diff --git a/arch/arm/configs/rk29_malata_defconfig b/arch/arm/configs/rk29_malata_defconfig
new file mode 100644
index 000000000000..b941a2e30152
--- /dev/null
+++ b/arch/arm/configs/rk29_malata_defconfig
@@ -0,0 +1,1967 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32.27
+# Wed Jan 26 16:33:21 2011
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_USER_SCHED is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+# CONFIG_CGROUP_NS is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=5
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+# CONFIG_ELF_CORE is not set
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_RK2818 is not set
+CONFIG_ARCH_RK29=y
+CONFIG_WIFI_CONTROL_FUNC=y
+# CONFIG_MACH_RK29SDK is not set
+# CONFIG_MACH_RK29WINACCORD is not set
+# CONFIG_MACH_RK29_AIGO is not set
+CONFIG_MACH_RK29_MALATA=y
+CONFIG_RK29_MEM_SIZE_M=512
+
+#
+# RK29 VPU (Video Processing Unit) support
+#
+CONFIG_RK29_VPU=y
+# CONFIG_RK29_VPU_DEBUG is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+CONFIG_ARM_THUMBEE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+CONFIG_ARM_GIC=y
+CONFIG_PL330=y
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+CONFIG_CONSOLE_EARLYSUSPEND=y
+# CONFIG_FB_EARLYSUSPEND is not set
+# CONFIG_APM_EMULATION is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+# CONFIG_BT_BNEP is not set
+# CONFIG_BT_HIDP is not set
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+CONFIG_BT_HCIBCM4325=y
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_CFG80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+
+#
+# Some wireless drivers require a rate control algorithm
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+# CONFIG_RFKILL_PM is not set
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND is not set
+CONFIG_MTD_RKNAND=y
+CONFIG_MTD_NAND_RK29XX=y
+CONFIG_RKFTL_PAGECACHE_SIZE=64
+CONFIG_MTD_RKNAND_BUFFER=y
+# CONFIG_MTD_NAND_RK29XX_DEBUG is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_ANDROID_PMEM=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_UID_STAT is not set
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_APANIC is not set
+# CONFIG_STE is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+CONFIG_RK29_VMAC=y
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+CONFIG_WLAN_80211=y
+# CONFIG_WIFI_NONE is not set
+CONFIG_BCM4329=y
+# CONFIG_MV8686 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_INPUT_KEYRESET=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYS_RK29=y
+CONFIG_SYNAPTICS_SO340010=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_XPT2046_SPI_NOCHOOSE=y
+# CONFIG_TOUCHSCREEN_XPT2046_SPI is not set
+# CONFIG_TOUCHSCREEN_XPT2046_CBN_SPI is not set
+# CONFIG_TOUCHSCREEN_XPT2046_320X480_SPI is not set
+# CONFIG_TOUCHSCREEN_XPT2046_320X480_CBN_SPI is not set
+# CONFIG_TOUCHSCREEN_IT7250 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_HANNSTAR_P1003 is not set
+CONFIG_HANNSTAR_MAX_X=1024
+CONFIG_HANNSTAR_MAX_Y=600
+# CONFIG_HANNSTAR_DEBUG is not set
+CONFIG_SINTEK_3FA16=y
+# CONFIG_EETI_EGALAX is not set
+# CONFIG_TOUCHSCREEN_IT7260 is not set
+# CONFIG_INPUT_MISC is not set
+CONFIG_INPUT_GPIO=y
+CONFIG_G_SENSOR_DEVICE=y
+# CONFIG_GS_MMA7660 is not set
+CONFIG_GS_MMA8452=y
+# CONFIG_INPUT_JOGBALL is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_RK29=y
+CONFIG_UART0_RK29=y
+CONFIG_UART0_CTS_RTS_RK29=y
+CONFIG_UART1_RK29=y
+CONFIG_UART2_RK29=y
+CONFIG_UART2_CTS_RTS_RK29=y
+# CONFIG_UART3_RK29 is not set
+CONFIG_SERIAL_RK29_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_RK29=y
+
+#
+# Now, there are four I2C interfaces selected by developer.
+#
+CONFIG_I2C0_RK29=y
+CONFIG_I2C1_RK29=y
+CONFIG_I2C2_RK29=y
+CONFIG_I2C3_RK29=y
+CONFIG_I2C_DEV_RK29=y
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+CONFIG_ADC=y
+# CONFIG_ADC_RK28 is not set
+CONFIG_ADC_RK29=y
+# CONFIG_SPI_FPGA is not set
+# CONFIG_HEADSET_DET is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_GPIO_PCA9554 is not set
+# CONFIG_IOEXTEND_TCA6424 is not set
+CONFIG_EXPANDED_GPIO_NUM=0
+CONFIG_EXPANDED_GPIO_IRQ_NUM=0
+# CONFIG_EXPAND_GPIO_SOFT_INTERRUPT is not set
+CONFIG_SPI_FPGA_GPIO_NUM=96
+CONFIG_SPI_FPGA_GPIO_IRQ_NUM=16
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_STC3100 is not set
+# CONFIG_BATTERY_BQ27510 is not set
+CONFIG_BATTERY_BQ3060=y
+# CONFIG_CHECK_BATT_CAPACITY is not set
+# CONFIG_NO_BATTERY_IC is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_RK2818_REGULATOR_CHARGE is not set
+# CONFIG_RK2818_REGULATOR_LP8725 is not set
+CONFIG_RK29_PWM_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+CONFIG_SOC_CAMERA=y
+# CONFIG_SOC_CAMERA_MT9M001 is not set
+# CONFIG_SOC_CAMERA_MT9M111 is not set
+# CONFIG_SOC_CAMERA_MT9T031 is not set
+# CONFIG_SOC_CAMERA_MT9V022 is not set
+# CONFIG_SOC_CAMERA_TW9910 is not set
+# CONFIG_SOC_CAMERA_PLATFORM is not set
+# CONFIG_SOC_CAMERA_OV772X is not set
+# CONFIG_SOC_CAMERA_OV7675 is not set
+# CONFIG_SOC_CAMERA_OV2655 is not set
+# CONFIG_SOC_CAMERA_OV2659 is not set
+# CONFIG_SOC_CAMERA_OV9650 is not set
+# CONFIG_SOC_CAMERA_OV3640 is not set
+# CONFIG_SOC_CAMERA_OV5642 is not set
+CONFIG_SOC_CAMERA_S5K6AA=y
+# CONFIG_VIDEO_SH_MOBILE_CEU is not set
+CONFIG_VIDEO_RK29=y
+CONFIG_VIDEO_RK29_WORK_ONEFRAME=y
+# CONFIG_VIDEO_RK29_WORK_PINGPONG is not set
+CONFIG_VIDEO_RK29_WORK_IPP=y
+# CONFIG_VIDEO_RK29_WORK_NOT_IPP is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_SMS_SIANO_MDTV is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_RK2818 is not set
+CONFIG_FB_RK29=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_RK29_BL=y
+
+#
+# Display device support
+#
+CONFIG_DISPLAY_SUPPORT=y
+
+#
+# Display hardware drivers
+#
+# CONFIG_LCD_NULL is not set
+# CONFIG_LCD_TD043MGEA1 is not set
+# CONFIG_LCD_HX8357 is not set
+# CONFIG_LCD_TJ048NC01CA is not set
+# CONFIG_LCD_HL070VM4AU is not set
+# CONFIG_LCD_HSD070IDW1 is not set
+# CONFIG_LCD_HSD100PXN is not set
+CONFIG_LCD_B101AW06=y
+# CONFIG_LCD_A060SE02 is not set
+# CONFIG_LCD_S1D13521 is not set
+# CONFIG_LCD_NT35582 is not set
+# CONFIG_LCD_NT35580 is not set
+# CONFIG_LCD_ANX7150_720P is not set
+
+#
+# HDMI support
+#
+CONFIG_HDMI=y
+CONFIG_ANX7150=y
+# CONFIG_ANX9030 is not set
+# CONFIG_HDMI_DEBUG is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_RK29_SOC=y
+CONFIG_SND_RK29_SOC_I2S=y
+# CONFIG_SND_RK29_SOC_I2S_2CH is not set
+CONFIG_SND_RK29_SOC_I2S_8CH=y
+# CONFIG_SND_RK29_SOC_WM8988 is not set
+CONFIG_SND_RK29_SOC_WM8900=y
+# CONFIG_SND_RK29_CODEC_SOC_MASTER is not set
+CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WM8900=y
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+CONFIG_USB_OTG_BLACKLIST_HUB=y
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+CONFIG_USB_GADGET_DWC_OTG=y
+CONFIG_USB_DWC_OTG=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_ANDROID=y
+# CONFIG_USB_ANDROID_ACM is not set
+CONFIG_USB_ANDROID_ADB=y
+CONFIG_USB_ANDROID_MASS_STORAGE=y
+# CONFIG_USB_ANDROID_RNDIS is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_USB11_HOST=y
+CONFIG_USB11_HOST_EN=y
+CONFIG_USB20_HOST=y
+CONFIG_USB20_HOST_EN=y
+CONFIG_USB20_OTG=y
+# CONFIG_DWC_OTG_HOST_ONLY is not set
+CONFIG_DWC_OTG_DEVICE_ONLY=y
+CONFIG_DWC_CONN_EN=y
+# CONFIG_DWC_OTG_DEBUG is not set
+CONFIG_DWC_OTG=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+CONFIG_MMC_EMBEDDED_SDIO=y
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_SDMMC_RK29=y
+
+#
+# Now, there are two SDMMC controllers selected, SDMMC0 and SDMMC1.
+#
+CONFIG_SDMMC0_RK29=y
+# CONFIG_EMMC_RK29 is not set
+CONFIG_SDMMC1_RK29=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_AT91 is not set
+# CONFIG_MMC_ATMELMCI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+CONFIG_RTC_HYM8563=y
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_S35392A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+
+#
+# Qualcomm MSM Camera And Video
+#
+
+#
+# Camera Sensor Selection
+#
+# CONFIG_DST is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_PLAN9AUTH is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_FB_UDL is not set
+
+#
+# RAR Register Driver
+#
+# CONFIG_RAR_REGISTER is not set
+# CONFIG_IIO is not set
+
+#
+# DSP
+#
+# CONFIG_RK2818_DSP is not set
+
+#
+# RK1000 control
+#
+# CONFIG_RK1000_CONTROL is not set
+
+#
+# rk2818 POWER CONTROL
+#
+# CONFIG_RK2818_POWER is not set
+
+#
+# GPU Vivante
+#
+CONFIG_VIVANTE=y
+
+#
+# IPP
+#
+CONFIG_RK29_IPP=y
+
+#
+# CMMB
+#
+# CONFIG_CMMB is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/arm/mach-rk29/Kconfig b/arch/arm/mach-rk29/Kconfig
index 738aa46e29e9..c87ef2d7b4c3 100644
--- a/arch/arm/mach-rk29/Kconfig
+++ b/arch/arm/mach-rk29/Kconfig
@@ -23,6 +23,11 @@ config MACH_RK29_AIGO
         help
 	  Support for the ROCKCHIP Board For Rk29 Aigo.
 	  
+config MACH_RK29_MALATA
+	depends on ARCH_RK29
+	bool "ROCKCHIP Board Rk29 For Malata"
+        help
+	  Support for the ROCKCHIP Board For Rk29 Malata.
 endchoice
 
 config RK29_MEM_SIZE_M
diff --git a/arch/arm/mach-rk29/Makefile b/arch/arm/mach-rk29/Makefile
index 65ffd7031aa8..85f69c512e3d 100755
--- a/arch/arm/mach-rk29/Makefile
+++ b/arch/arm/mach-rk29/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_RK29_VPU) += vpu.o vpu_mem.o
 obj-$(CONFIG_MACH_RK29SDK) += board-rk29sdk.o board-rk29sdk-key.o board-rk29sdk-rfkill.o
 obj-$(CONFIG_MACH_RK29WINACCORD) += board-rk29-winaccord.o board-rk29sdk-key.o
 obj-$(CONFIG_MACH_RK29_AIGO) += board-rk29-aigo.o board-rk29aigo-key.o board-rk29sdk-rfkill.o
+obj-$(CONFIG_MACH_RK29_MALATA) += board-malata.o board-rk29sdk-key.o board-rk29sdk-rfkill.o
diff --git a/arch/arm/mach-rk29/board-malata.c b/arch/arm/mach-rk29/board-malata.c
new file mode 100755
index 000000000000..0f7f67c0b38b
--- /dev/null
+++ b/arch/arm/mach-rk29/board-malata.c
@@ -0,0 +1,1884 @@
+/* arch/arm/mach-rk29/board-rk29.c
+ *
+ * Copyright (C) 2010 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/mmc/host.h>
+#include <linux/android_pmem.h>
+#include <linux/usb/android_composite.h>
+
+#include <mach/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/gic.h>
+
+#include <mach/iomux.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <mach/rk29_iomap.h>
+#include <mach/board.h>
+#include <mach/rk29_nand.h>
+#include <mach/rk29_camera.h>                          /* ddl@rock-chips.com : camera support */
+#include <media/soc_camera.h>                               /* ddl@rock-chips.com : camera support */
+#include <mach/vpu_mem.h>
+
+#include <linux/regulator/rk29-pwm-regulator.h>
+#include <linux/regulator/machine.h>
+
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+
+#include "devices.h"
+#include "../../../drivers/input/touchscreen/xpt2046_cbn_ts.h"
+
+
+/* Set memory size of pmem */
+#ifdef CONFIG_RK29_MEM_SIZE_M
+#define SDRAM_SIZE          (CONFIG_RK29_MEM_SIZE_M * SZ_1M)
+#else
+#define SDRAM_SIZE          SZ_512M
+#endif
+#define PMEM_GPU_SIZE       SZ_64M
+#define PMEM_UI_SIZE        SZ_32M
+#define PMEM_VPU_SIZE       SZ_64M
+#define PMEM_CAM_SIZE       0x01300000
+#ifdef CONFIG_VIDEO_RK29_WORK_IPP
+#define MEM_CAMIPP_SIZE     SZ_4M
+#else
+#define MEM_CAMIPP_SIZE     0
+#endif
+#define MEM_FB_SIZE         (3*SZ_2M)
+
+#define PMEM_GPU_BASE       ((u32)RK29_SDRAM_PHYS + SDRAM_SIZE - PMEM_GPU_SIZE)
+#define PMEM_UI_BASE        (PMEM_GPU_BASE - PMEM_UI_SIZE)
+#define PMEM_VPU_BASE       (PMEM_UI_BASE - PMEM_VPU_SIZE)
+#define PMEM_CAM_BASE       (PMEM_VPU_BASE - PMEM_CAM_SIZE)
+#define MEM_CAMIPP_BASE     (PMEM_CAM_BASE - MEM_CAMIPP_SIZE)
+#define MEM_FB_BASE         (MEM_CAMIPP_BASE - MEM_FB_SIZE)
+#define LINUX_SIZE          (MEM_FB_BASE - RK29_SDRAM_PHYS)
+
+extern struct sys_timer rk29_timer;
+
+int rk29_nand_io_init(void)
+{
+    return 0;
+}
+
+struct rk29_nand_platform_data rk29_nand_data = {
+    .width      = 1,     /* data bus width in bytes */
+    .hw_ecc     = 1,     /* hw ecc 0: soft ecc */
+    .num_flash    = 1,
+    .io_init   = rk29_nand_io_init,
+};
+
+#ifdef CONFIG_FB_RK29
+/*****************************************************************************************
+ * lcd  devices
+ * author: zyw@rock-chips.com
+ *****************************************************************************************/
+//#ifdef  CONFIG_LCD_TD043MGEA1
+#define LCD_TXD_PIN          INVALID_GPIO
+#define LCD_CLK_PIN          INVALID_GPIO
+#define LCD_CS_PIN           INVALID_GPIO
+/*****************************************************************************************
+* frame buffe  devices
+* author: zyw@rock-chips.com
+*****************************************************************************************/
+#define FB_ID                       0
+#define FB_DISPLAY_ON_PIN           RK29_PIN6_PD0
+#define FB_LCD_STANDBY_PIN          RK29_PIN6_PD1
+#define FB_LCD_CABC_EN_PIN          RK29_PIN6_PD2
+#define FB_MCU_FMK_PIN              INVALID_GPIO
+
+#define FB_DISPLAY_ON_VALUE         GPIO_HIGH
+#define FB_LCD_STANDBY_VALUE        GPIO_HIGH
+
+//#endif
+static int rk29_lcd_io_init(void)
+{
+    int ret = 0;
+    return ret;
+}
+
+static int rk29_lcd_io_deinit(void)
+{
+    int ret = 0;
+    return ret;
+}
+
+struct rk29lcd_info rk29_lcd_info = {
+    .txd_pin  = LCD_TXD_PIN,
+    .clk_pin = LCD_CLK_PIN,
+    .cs_pin = LCD_CS_PIN,
+    .io_init   = rk29_lcd_io_init,
+    .io_deinit = rk29_lcd_io_deinit,
+};
+
+
+static int rk29_fb_io_init(struct rk29_fb_setting_info *fb_setting)
+{
+    int ret = 0;
+    if(fb_setting->mcu_fmk_en && (FB_MCU_FMK_PIN != INVALID_GPIO))
+    {
+        ret = gpio_request(FB_MCU_FMK_PIN, NULL);
+        if(ret != 0)
+        {
+            gpio_free(FB_MCU_FMK_PIN);
+            printk(">>>>>> FB_MCU_FMK_PIN gpio_request err \n ");
+        }
+        gpio_direction_input(FB_MCU_FMK_PIN);
+    }
+    if(fb_setting->disp_on_en && (FB_DISPLAY_ON_PIN != INVALID_GPIO))
+    {
+        ret = gpio_request(FB_DISPLAY_ON_PIN, NULL);
+        if(ret != 0)
+        {
+            gpio_free(FB_DISPLAY_ON_PIN);
+            printk(">>>>>> FB_DISPLAY_ON_PIN gpio_request err \n ");
+        }
+    }
+
+    if(fb_setting->disp_on_en && (FB_LCD_STANDBY_PIN != INVALID_GPIO))
+    {
+        ret = gpio_request(FB_LCD_STANDBY_PIN, NULL);
+        if(ret != 0)
+        {
+            gpio_free(FB_LCD_STANDBY_PIN);
+            printk(">>>>>> FB_LCD_STANDBY_PIN gpio_request err \n ");
+        }
+    }
+
+    if(FB_LCD_CABC_EN_PIN != INVALID_GPIO)
+    {
+        ret = gpio_request(FB_LCD_CABC_EN_PIN, NULL);
+        if(ret != 0)
+        {
+            gpio_free(FB_LCD_CABC_EN_PIN);
+            printk(">>>>>> FB_LCD_CABC_EN_PIN gpio_request err \n ");
+        }
+        gpio_direction_output(FB_LCD_CABC_EN_PIN, 0);
+        gpio_set_value(FB_LCD_CABC_EN_PIN, GPIO_LOW);
+    }
+
+    return ret;
+}
+
+struct rk29fb_info rk29_fb_info = {
+    .fb_id   = FB_ID,
+    .disp_on_pin = FB_DISPLAY_ON_PIN,
+    .disp_on_value = FB_DISPLAY_ON_VALUE,
+    .standby_pin = FB_LCD_STANDBY_PIN,
+    .standby_value = FB_LCD_STANDBY_VALUE,
+    .mcu_fmk_pin = FB_MCU_FMK_PIN,
+    .lcd_info = &rk29_lcd_info,
+    .io_init   = rk29_fb_io_init,
+};
+
+/* rk29 fb resource */
+struct resource rk29_fb_resource[] = {
+	[0] = {
+        .name  = "lcdc reg",
+		.start = RK29_LCDC_PHYS,
+		.end   = RK29_LCDC_PHYS + RK29_LCDC_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+	    .name  = "lcdc irq",
+		.start = IRQ_LCDC,
+		.end   = IRQ_LCDC,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+	    .name   = "win1 buf",
+        .start  = MEM_FB_BASE,
+        .end    = MEM_FB_BASE + MEM_FB_SIZE,
+        .flags  = IORESOURCE_MEM,
+    },
+};
+
+/*platform_device*/
+struct platform_device rk29_device_fb = {
+	.name		  = "rk29-fb",
+	.id		  = 4,
+	.num_resources	  = ARRAY_SIZE(rk29_fb_resource),
+	.resource	  = rk29_fb_resource,
+	.dev            = {
+		.platform_data  = &rk29_fb_info,
+	}
+};
+#endif
+
+static struct android_pmem_platform_data android_pmem_pdata = {
+	.name		= "pmem",
+	.start		= PMEM_UI_BASE,
+	.size		= PMEM_UI_SIZE,
+	.no_allocator	= 0,
+	.cached		= 1,
+};
+
+static struct platform_device android_pmem_device = {
+	.name		= "android_pmem",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &android_pmem_pdata,
+	},
+};
+
+
+static struct android_pmem_platform_data android_pmem_cam_pdata = {
+	.name		= "pmem_cam",
+	.start		= PMEM_CAM_BASE,
+	.size		= PMEM_CAM_SIZE,
+	.no_allocator	= 1,
+	.cached		= 1,
+};
+
+static struct platform_device android_pmem_cam_device = {
+	.name		= "android_pmem",
+	.id		= 1,
+	.dev		= {
+		.platform_data = &android_pmem_cam_pdata,
+	},
+};
+
+
+static struct vpu_mem_platform_data vpu_mem_pdata = {
+	.name		= "vpu_mem",
+	.start		= PMEM_VPU_BASE,
+	.size		= PMEM_VPU_SIZE,
+	.cached		= 1,
+};
+
+static struct platform_device rk29_vpu_mem_device = {
+	.name		= "vpu_mem",
+	.id		    = 2,
+	.dev		= {
+	.platform_data = &vpu_mem_pdata,
+	},
+};
+
+
+/*HANNSTAR_P1003 touch*/
+#if defined (CONFIG_HANNSTAR_P1003)
+#define TOUCH_RESET_PIN RK29_PIN6_PC3
+#define TOUCH_INT_PIN   RK29_PIN0_PA2
+
+int p1003_init_platform_hw(void)
+{
+    if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
+      gpio_free(TOUCH_RESET_PIN);
+      printk("p1003_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+
+    if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+      gpio_free(TOUCH_INT_PIN);
+      printk("p1003_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+    gpio_pull_updown(TOUCH_INT_PIN, 1);
+    gpio_direction_output(TOUCH_RESET_PIN, 0);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+
+    return 0;
+}
+
+
+struct p1003_platform_data p1003_info = {
+  .model= 1003,
+  .init_platform_hw= p1003_init_platform_hw,
+
+};
+#endif
+#if defined (CONFIG_SINTEK_3FA16)
+#define TOUCH_RESET_PIN RK29_PIN6_PC3
+#define TOUCH_INT_PIN   RK29_PIN0_PA2
+
+int sintek_init_platform_hw(void)
+{
+    if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
+      gpio_free(TOUCH_RESET_PIN);
+      printk("p1003_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+
+    if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+      gpio_free(TOUCH_INT_PIN);
+      printk("p1003_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+    gpio_pull_updown(TOUCH_INT_PIN, 1);
+    gpio_direction_output(TOUCH_RESET_PIN, 0);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+
+    return 0;
+}
+
+
+struct sintek_platform_data sintek_touch_info = {
+  .model= 1003,
+  .init_platform_hw= sintek_init_platform_hw,
+
+};
+#endif
+
+#if defined (CONFIG_SYNAPTICS_SO340010)
+
+#define TOUCHPAD_INT_PIN	RK29_PIN4_PD5
+
+int synaptics_init_platform_hw(void)
+{
+	if(gpio_request(TOUCHPAD_INT_PIN,NULL) != 0){
+	  gpio_free(TOUCHPAD_INT_PIN);
+	  printk("p1003_init_platform_hw gpio_request error\n");
+	  return -EIO;
+	}
+	gpio_pull_updown(TOUCHPAD_INT_PIN, 1);
+	return 0;
+}
+
+
+struct synaptics_platform_data synaptics_touchkey_info = {
+  .model= 1003,
+  .init_platform_hw= synaptics_init_platform_hw,
+
+};
+#endif
+
+/*MMA8452 gsensor*/
+#if defined (CONFIG_GS_MMA8452)
+#define MMA8452_INT_PIN   RK29_PIN0_PA3
+
+int mma8452_init_platform_hw(void)
+{
+
+    if(gpio_request(MMA8452_INT_PIN,NULL) != 0){
+      gpio_free(MMA8452_INT_PIN);
+      printk("mma8452_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+    gpio_pull_updown(MMA8452_INT_PIN, 1);
+    return 0;
+}
+
+
+struct mma8452_platform_data mma8452_info = {
+  .model= 8452,
+  .swap_xy = 0,
+  .init_platform_hw= mma8452_init_platform_hw,
+
+};
+#endif
+
+
+
+/*****************************************************************************************
+ * i2c devices
+ * author: kfx@rock-chips.com
+*****************************************************************************************/
+static int rk29_i2c0_io_init(void)
+{
+	rk29_mux_api_set(GPIO2B7_I2C0SCL_NAME, GPIO2L_I2C0_SCL);
+	rk29_mux_api_set(GPIO2B6_I2C0SDA_NAME, GPIO2L_I2C0_SDA);
+	return 0;
+}
+
+static int rk29_i2c1_io_init(void)
+{
+	rk29_mux_api_set(GPIO1A7_I2C1SCL_NAME, GPIO1L_I2C1_SCL);
+	rk29_mux_api_set(GPIO1A6_I2C1SDA_NAME, GPIO1L_I2C1_SDA);
+	return 0;
+}
+static int rk29_i2c2_io_init(void)
+{
+	rk29_mux_api_set(GPIO5D4_I2C2SCL_NAME, GPIO5H_I2C2_SCL);
+	rk29_mux_api_set(GPIO5D3_I2C2SDA_NAME, GPIO5H_I2C2_SDA);
+	return 0;
+}
+
+static int rk29_i2c3_io_init(void)
+{
+	rk29_mux_api_set(GPIO2B5_UART3RTSN_I2C3SCL_NAME, GPIO2L_I2C3_SCL);
+	rk29_mux_api_set(GPIO2B4_UART3CTSN_I2C3SDA_NAME, GPIO2L_I2C3_SDA);
+	return 0;
+}
+
+struct rk29_i2c_platform_data default_i2c0_data = {
+	.bus_num    = 0,
+	.flags      = 0,
+	.slave_addr = 0xff,
+	.scl_rate  = 400*1000,
+	.mode 		= I2C_MODE_IRQ,
+	.io_init = rk29_i2c0_io_init,
+};
+
+struct rk29_i2c_platform_data default_i2c1_data = {
+	.bus_num    = 1,
+	.flags      = 0,
+	.slave_addr = 0xff,
+	.scl_rate  = 400*1000,
+	.mode 		= I2C_MODE_POLL,
+	.io_init = rk29_i2c1_io_init,
+};
+
+struct rk29_i2c_platform_data default_i2c2_data = {
+	.bus_num    = 2,
+	.flags      = 0,
+	.slave_addr = 0xff,
+	.scl_rate  = 400*1000,
+	.mode 		= I2C_MODE_IRQ,
+	.io_init = rk29_i2c2_io_init,
+};
+
+struct rk29_i2c_platform_data default_i2c3_data = {
+	.bus_num    = 3,
+	.flags      = 0,
+	.slave_addr = 0xff,
+	.scl_rate  = 400*1000,
+	.mode 		= I2C_MODE_POLL,
+	.io_init = rk29_i2c3_io_init,
+};
+
+#ifdef CONFIG_I2C0_RK29
+static struct i2c_board_info __initdata board_i2c0_devices[] = {
+#if defined (CONFIG_RK1000_CONTROL)
+	{
+		.type    		= "rk1000_control",
+		.addr           = 0x40,
+		.flags			= 0,
+	},
+#endif
+#if defined (CONFIG_SND_SOC_RK1000)
+	{
+		.type    		= "rk1000_i2c_codec",
+		.addr           = 0x60,
+		.flags			= 0,
+	},
+#endif
+#if defined (CONFIG_SND_SOC_WM8900)
+	{
+		.type    		= "wm8900",
+		.addr           = 0x1A,
+		.flags			= 0,
+	},
+#endif
+#if defined (CONFIG_BATTERY_STC3100)
+	{
+		.type    		= "stc3100",
+		.addr           = 0x70,
+		.flags			= 0,
+	},
+#endif
+#if  defined (CONFIG_RTC_HYM8563)
+	{
+		.type			= "rtc_hym8563",
+		.addr			= 0x51,
+		.flags			= 0,
+		///.irq 		   = RK2818_PIN_PA4,
+	},
+#endif
+
+#if defined (CONFIG_BATTERY_BQ27510)
+	{
+		.type    		= "bq27510",
+		.addr           = 0x55,
+		.flags			= 0,
+	},
+#endif
+#if  defined(CONFIG_BATTERY_BQ3060)
+	{
+		.type    		= "bq3060",
+		.addr           = 0x0b,
+		.flags		= I2C_M_IGNORE_NAK,
+	},
+#endif
+#if defined (CONFIG_GS_MMA8452)
+    {
+      .type           = "gs_mma8452",
+      .addr           = 0x1c,
+      .flags          = 0,
+      .irq            = MMA8452_INT_PIN,
+      .platform_data  = &mma8452_info,
+    },
+#endif
+#if defined (CONFIG_SENSORS_AK8973)
+	{
+		.type    		= "ak8973",
+		.addr           = 0x1d,
+		.flags			= 0,
+		.irq			= RK29_PIN0_PA4,
+	},
+#endif
+#if defined (CONFIG_SENSORS_AK8975)
+	{
+		.type    		= "ak8975",
+		.addr           = 0x1d,
+		.flags			= 0,
+		.irq			= RK29_PIN0_PA4,
+	},
+#endif
+};
+#endif
+
+#ifdef CONFIG_I2C1_RK29
+static struct i2c_board_info __initdata board_i2c1_devices[] = {
+#if defined (CONFIG_RK1000_CONTROL1)
+	{
+		.type			= "rk1000_control",
+		.addr			= 0x40,
+		.flags			= 0,
+	},
+#endif
+#if defined (CONFIG_ANX7150)
+    {
+		.type           = "anx7150",
+        .addr           = 0x39,             //0x39, 0x3d
+        .flags          = 0,
+        .irq            = RK29_PIN1_PD7,
+    },
+#endif
+
+};
+#endif
+
+#ifdef CONFIG_I2C2_RK29
+static struct i2c_board_info __initdata board_i2c2_devices[] = {
+#if defined (CONFIG_HANNSTAR_P1003)
+    {
+      .type           = "p1003_touch",
+      .addr           = 0x04,
+      .flags          = 0,
+      .irq            = RK29_PIN0_PA2,
+      .platform_data  = &p1003_info,
+    },
+#endif
+#if defined (CONFIG_SINTEK_3FA16)
+  {
+     .type 		  = "sintek_touch",
+     .addr 		  = 0x5c,
+     .flags		  = I2C_M_IGNORE_NAK,
+     .irq			  = RK29_PIN0_PA2,
+     .platform_data  = &sintek_touch_info,
+  },
+
+#endif 
+};
+#endif
+
+#ifdef CONFIG_I2C3_RK29
+static struct i2c_board_info __initdata board_i2c3_devices[] = {
+
+#if defined (CONFIG_SYNAPTICS_SO340010)
+  {
+     .type 		  = "synaptics_touchkey",
+     .addr 		  = 0x2c,
+     .flags		  = 0,
+     .irq		  = RK29_PIN4_PD5,
+     .platform_data  = &synaptics_touchkey_info,
+  },
+
+#endif 
+};
+#endif
+
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_VIDEO_RK29
+#if defined(CONFIG_SOC_CAMERA_OV5642)
+#define SENSOR_NAME_0 RK29_CAM_SENSOR_NAME_OV5642			/* back camera sensor */
+#define SENSOR_IIC_ADDR_0 	    0x78
+#define SENSOR_IIC_ADAPTER_ID_0    1
+#define SENSOR_POWER_PIN_0         INVALID_GPIO
+#define SENSOR_RESET_PIN_0         INVALID_GPIO
+#define SENSOR_POWERDN_PIN_0       RK29_PIN6_PB7
+#define SENSOR_FALSH_PIN_0         INVALID_GPIO
+#define SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
+#define SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
+#define SENSOR_POWERDNACTIVE_LEVEL_0 RK29_CAM_POWERDNACTIVE_H
+#define SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_L
+#else
+#define SENSOR_NAME_0 			""/* back camera sensor */
+#define SENSOR_IIC_ADDR_0		0x00
+#define SENSOR_IIC_ADAPTER_ID_0    1
+#define SENSOR_POWER_PIN_0		   INVALID_GPIO
+#define SENSOR_RESET_PIN_0		   INVALID_GPIO
+#define SENSOR_POWERDN_PIN_0       INVALID_GPIO
+#define SENSOR_FALSH_PIN_0         INVALID_GPIO
+#define SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
+#define SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
+#define SENSOR_POWERDNACTIVE_LEVEL_0 RK29_CAM_POWERDNACTIVE_H
+#define SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_L
+
+#endif
+
+#if defined(CONFIG_SOC_CAMERA_OV2659)
+#define SENSOR_NAME_1 RK29_CAM_SENSOR_NAME_OV2659			/* front camera sensor */
+#define SENSOR_IIC_ADDR_1 	    0x60
+#define SENSOR_IIC_ADAPTER_ID_1    1
+#define SENSOR_POWER_PIN_1         INVALID_GPIO
+#define SENSOR_RESET_PIN_1         INVALID_GPIO
+#define SENSOR_POWERDN_PIN_1       RK29_PIN5_PD7
+#define SENSOR_FALSH_PIN_1         INVALID_GPIO
+#define SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_L
+#define SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
+#define SENSOR_POWERDNACTIVE_LEVEL_1 RK29_CAM_POWERDNACTIVE_H
+#define SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
+#endif
+#if defined(CONFIG_SOC_CAMERA_S5K6AA)
+#define SENSOR_NAME_1 RK29_CAM_SENSOR_NAME_S5K6AA			/*importek mu763 camera sensor */
+#define SENSOR_IIC_ADDR_1		0x78
+#define SENSOR_IIC_ADAPTER_ID_1    1
+#define SENSOR_POWER_PIN_1		   RK29_PIN5_PD7
+#define SENSOR_RESET_PIN_1		   INVALID_GPIO
+#define SENSOR_POWERDN_PIN_1       RK29_PIN5_PD7
+#define SENSOR_FALSH_PIN_1         INVALID_GPIO
+#define SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_H
+#define SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
+#define SENSOR_POWERDNACTIVE_LEVEL_1 RK29_CAM_POWERDNACTIVE_H
+#define SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
+#endif 
+
+static int rk29_sensor_io_init(void);
+static int rk29_sensor_io_deinit(int sensor);
+static int rk29_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd,int on);
+
+struct rk29camera_platform_data rk29_camera_platform_data = {
+    .io_init = rk29_sensor_io_init,
+    .io_deinit = rk29_sensor_io_deinit,
+    .sensor_ioctrl = rk29_sensor_ioctrl,
+    .gpio_res = {
+        {
+            .gpio_reset = SENSOR_RESET_PIN_0,
+            .gpio_power = SENSOR_POWER_PIN_0,
+            .gpio_powerdown = SENSOR_POWERDN_PIN_0,
+            .gpio_flash = SENSOR_FALSH_PIN_0,
+            .gpio_flag = (SENSOR_POWERACTIVE_LEVEL_0|SENSOR_RESETACTIVE_LEVEL_0|SENSOR_POWERDNACTIVE_LEVEL_0|SENSOR_FLASHACTIVE_LEVEL_0),
+            .gpio_init = 0,
+            .dev_name = SENSOR_NAME_0,
+        }, {
+            .gpio_reset = SENSOR_RESET_PIN_1,
+            .gpio_power = SENSOR_POWER_PIN_1,
+            .gpio_powerdown = SENSOR_POWERDN_PIN_1,
+            .gpio_flash = SENSOR_FALSH_PIN_1,
+            .gpio_flag = (SENSOR_POWERACTIVE_LEVEL_1|SENSOR_RESETACTIVE_LEVEL_1|SENSOR_POWERDNACTIVE_LEVEL_1|SENSOR_FLASHACTIVE_LEVEL_1),
+            .gpio_init = 0,
+            .dev_name = SENSOR_NAME_1,
+        }
+    },
+	#ifdef CONFIG_VIDEO_RK29_WORK_IPP
+	.meminfo = {
+	    .name  = "camera_ipp_mem",
+		.start = MEM_CAMIPP_BASE,
+		.size   = MEM_CAMIPP_SIZE,
+	}
+	#endif
+};
+
+static int rk29_sensor_io_init(void)
+{
+    int ret = 0, i;
+    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
+	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO;
+	unsigned int camera_ioflag;
+
+    for (i=0; i<2; i++) {
+        camera_reset = rk29_camera_platform_data.gpio_res[i].gpio_reset;
+        camera_power = rk29_camera_platform_data.gpio_res[i].gpio_power;
+		camera_powerdown = rk29_camera_platform_data.gpio_res[i].gpio_powerdown;
+        camera_flash = rk29_camera_platform_data.gpio_res[i].gpio_flash;
+		camera_ioflag = rk29_camera_platform_data.gpio_res[i].gpio_flag;
+		rk29_camera_platform_data.gpio_res[i].gpio_init = 0;
+
+        if (camera_power != INVALID_GPIO) {
+            ret = gpio_request(camera_power, "camera power");
+            if (ret)
+				goto sensor_io_int_loop_end;
+			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_POWERACTIVE_MASK;
+            gpio_set_value(camera_reset, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+            gpio_direction_output(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+
+			//printk("\n%s....power pin(%d) init success(0x%x)  \n",__FUNCTION__,camera_power,(((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+
+        }
+
+        if (camera_reset != INVALID_GPIO) {
+            ret = gpio_request(camera_reset, "camera reset");
+            if (ret)
+				goto sensor_io_int_loop_end;
+			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_RESETACTIVE_MASK;
+            gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+            gpio_direction_output(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+
+			//printk("\n%s....reset pin(%d) init success(0x%x)\n",__FUNCTION__,camera_reset,((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+
+        }
+
+		if (camera_powerdown != INVALID_GPIO) {
+            ret = gpio_request(camera_powerdown, "camera powerdown");
+            if (ret)
+				goto sensor_io_int_loop_end;
+			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_POWERDNACTIVE_MASK;
+            gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+            gpio_direction_output(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+
+			//printk("\n%s....powerdown pin(%d) init success(0x%x) \n",__FUNCTION__,camera_powerdown,((camera_ioflag&RK29_CAM_POWERDNACTIVE_BITPOS)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+
+        }
+
+		if (camera_flash != INVALID_GPIO) {
+            ret = gpio_request(camera_flash, "camera flash");
+            if (ret)
+				goto sensor_io_int_loop_end;
+			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_FLASHACTIVE_MASK;
+            gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+            gpio_direction_output(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+
+			//printk("\n%s....flash pin(%d) init success(0x%x) \n",__FUNCTION__,camera_flash,((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+
+        }
+		continue;
+sensor_io_int_loop_end:
+		rk29_sensor_io_deinit(i);
+		continue;
+    }
+
+    return 0;
+}
+
+static int rk29_sensor_io_deinit(int sensor)
+{
+    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
+	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO;
+
+    camera_reset = rk29_camera_platform_data.gpio_res[sensor].gpio_reset;
+    camera_power = rk29_camera_platform_data.gpio_res[sensor].gpio_power;
+	camera_powerdown = rk29_camera_platform_data.gpio_res[sensor].gpio_powerdown;
+    camera_flash = rk29_camera_platform_data.gpio_res[sensor].gpio_flash;
+
+	if (rk29_camera_platform_data.gpio_res[sensor].gpio_init & RK29_CAM_POWERACTIVE_MASK) {
+	    if (camera_power != INVALID_GPIO) {
+	        gpio_direction_input(camera_power);
+	        gpio_free(camera_power);
+	    }
+	}
+
+	if (rk29_camera_platform_data.gpio_res[sensor].gpio_init & RK29_CAM_RESETACTIVE_MASK) {
+	    if (camera_reset != INVALID_GPIO)  {
+	        gpio_direction_input(camera_reset);
+	        gpio_free(camera_reset);
+	    }
+	}
+
+	if (rk29_camera_platform_data.gpio_res[sensor].gpio_init & RK29_CAM_POWERDNACTIVE_MASK) {
+	    if (camera_powerdown != INVALID_GPIO)  {
+	        gpio_direction_input(camera_powerdown);
+	        gpio_free(camera_powerdown);
+	    }
+	}
+
+	if (rk29_camera_platform_data.gpio_res[sensor].gpio_init & RK29_CAM_FLASHACTIVE_MASK) {
+	    if (camera_flash != INVALID_GPIO)  {
+	        gpio_direction_input(camera_flash);
+	        gpio_free(camera_flash);
+	    }
+	}
+
+	rk29_camera_platform_data.gpio_res[sensor].gpio_init = 0;
+    return 0;
+}
+static int rk29_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd, int on)
+{
+    unsigned int camera_power=INVALID_GPIO,camera_reset=INVALID_GPIO, camera_powerdown=INVALID_GPIO,camera_flash = INVALID_GPIO;
+	unsigned int camera_ioflag,camera_io_init;
+	int ret = RK29_CAM_IO_SUCCESS;
+
+    if(rk29_camera_platform_data.gpio_res[0].dev_name &&  (strcmp(rk29_camera_platform_data.gpio_res[0].dev_name, dev_name(dev)) == 0)) {
+		camera_power = rk29_camera_platform_data.gpio_res[0].gpio_power;
+		camera_reset = rk29_camera_platform_data.gpio_res[0].gpio_reset;
+        camera_powerdown = rk29_camera_platform_data.gpio_res[0].gpio_powerdown;
+		camera_flash = rk29_camera_platform_data.gpio_res[0].gpio_flash;
+		camera_ioflag = rk29_camera_platform_data.gpio_res[0].gpio_flag;
+		camera_io_init = rk29_camera_platform_data.gpio_res[0].gpio_init;
+    } else if (rk29_camera_platform_data.gpio_res[1].dev_name && (strcmp(rk29_camera_platform_data.gpio_res[1].dev_name, dev_name(dev)) == 0)) {
+    	camera_power = rk29_camera_platform_data.gpio_res[1].gpio_power;
+        camera_reset = rk29_camera_platform_data.gpio_res[1].gpio_reset;
+        camera_powerdown = rk29_camera_platform_data.gpio_res[1].gpio_powerdown;
+		camera_flash = rk29_camera_platform_data.gpio_res[1].gpio_flash;
+		camera_ioflag = rk29_camera_platform_data.gpio_res[1].gpio_flag;
+		camera_io_init = rk29_camera_platform_data.gpio_res[1].gpio_init;
+    }
+
+ 	switch (cmd)
+ 	{
+ 		case Cam_Power:
+		{
+			if (camera_power != INVALID_GPIO)  {
+				if (camera_io_init & RK29_CAM_POWERACTIVE_MASK) {
+			        if (on) {
+			        	gpio_set_value(camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+						//printk("\n%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,dev_name(dev), camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+						msleep(10);
+					} else {
+						gpio_set_value(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+						//printk("\n%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,dev_name(dev), camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+					}
+				} else {
+					ret = RK29_CAM_EIO_REQUESTFAIL;
+					printk("\n%s..%s..ResetPin=%d request failed!\n",__FUNCTION__,dev_name(dev),camera_reset);
+				}
+		    } else {
+				ret = RK29_CAM_EIO_INVALID;
+		    }
+			break;
+		}
+		case Cam_Reset:
+		{
+			if (camera_reset != INVALID_GPIO) {
+				if (camera_io_init & RK29_CAM_RESETACTIVE_MASK) {
+					if (on) {
+			        	gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+			        	//printk("\n%s..%s..ResetPin=%d ..PinLevel = %x \n",__FUNCTION__,dev_name(dev),camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+					} else {
+						gpio_set_value(camera_reset,(((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+		        		//printk("\n%s..%s..ResetPin= %d..PinLevel = %x   \n",__FUNCTION__,dev_name(dev), camera_reset, (((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+			        }
+				} else {
+					ret = RK29_CAM_EIO_REQUESTFAIL;
+					printk("\n%s..%s..ResetPin=%d request failed!\n",__FUNCTION__,dev_name(dev),camera_reset);
+				}
+		    } else {
+				ret = RK29_CAM_EIO_INVALID;
+		    }
+			break;
+		}
+
+		case Cam_PowerDown:
+		{
+			if (camera_powerdown != INVALID_GPIO) {
+				if (camera_io_init & RK29_CAM_POWERDNACTIVE_MASK) {
+					if (on) {
+			        	gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+			        	//printk("\n%s..%s..PowerDownPin=%d ..PinLevel = %x \n",__FUNCTION__,dev_name(dev),camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+					} else {
+						gpio_set_value(camera_powerdown,(((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+		        		//printk("\n%s..%s..PowerDownPin= %d..PinLevel = %x   \n",__FUNCTION__,dev_name(dev), camera_powerdown, (((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+			        }
+				} else {
+					ret = RK29_CAM_EIO_REQUESTFAIL;
+					printk("\n%s..%s..PowerDownPin=%d request failed!\n",__FUNCTION__,dev_name(dev),camera_powerdown);
+				}
+		    } else {
+				ret = RK29_CAM_EIO_INVALID;
+		    }
+			break;
+		}
+
+		case Cam_Flash:
+		{
+			if (camera_flash != INVALID_GPIO) {
+				if (camera_io_init & RK29_CAM_FLASHACTIVE_MASK) {
+					if (on) {
+			        	gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+			        	//printk("\n%s..%s..FlashPin=%d ..PinLevel = %x \n",__FUNCTION__,dev_name(dev),camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+					} else {
+						gpio_set_value(camera_flash,(((~camera_ioflag)&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+		        		//printk("\n%s..%s..FlashPin= %d..PinLevel = %x   \n",__FUNCTION__,dev_name(dev), camera_flash, (((~camera_ioflag)&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+			        }
+				} else {
+					ret = RK29_CAM_EIO_REQUESTFAIL;
+					printk("\n%s..%s..FlashPin=%d request failed!\n",__FUNCTION__,dev_name(dev),camera_flash);
+				}
+		    } else {
+				ret = RK29_CAM_EIO_INVALID;
+		    }
+			break;
+		}
+
+		default:
+		{
+			printk("%s cmd(0x%x) is unknown!\n",__FUNCTION__, cmd);
+			break;
+		}
+ 	}
+    return ret;
+}
+static int rk29_sensor_power(struct device *dev, int on)
+{
+	rk29_sensor_ioctrl(dev,Cam_Power,on);
+    return 0;
+}
+static int rk29_sensor_reset(struct device *dev)
+{
+	rk29_sensor_ioctrl(dev,Cam_Reset,1);
+	msleep(2);
+	rk29_sensor_ioctrl(dev,Cam_Reset,0);
+	return 0;
+}
+static int rk29_sensor_powerdown(struct device *dev, int on)
+{
+	return rk29_sensor_ioctrl(dev,Cam_PowerDown,on);
+}
+#if (SENSOR_IIC_ADDR_0 != 0x00)
+static struct i2c_board_info rk29_i2c_cam_info_0[] = {
+	{
+		I2C_BOARD_INFO(SENSOR_NAME_0, SENSOR_IIC_ADDR_0>>1)
+	},
+};
+
+struct soc_camera_link rk29_iclink_0 = {
+	.bus_id		= RK29_CAM_PLATFORM_DEV_ID,
+	.power		= rk29_sensor_power,
+	.powerdown  = rk29_sensor_powerdown,
+	.board_info	= &rk29_i2c_cam_info_0[0],
+	.i2c_adapter_id	= SENSOR_IIC_ADAPTER_ID_0,
+	.module_name	= SENSOR_NAME_0,
+};
+
+/*platform_device : soc-camera need  */
+struct platform_device rk29_soc_camera_pdrv_0 = {
+	.name	= "soc-camera-pdrv",
+	.id	= 0,
+	.dev	= {
+		.init_name = SENSOR_NAME_0,
+		.platform_data = &rk29_iclink_0,
+	},
+};
+#endif
+static struct i2c_board_info rk29_i2c_cam_info_1[] = {
+	{
+		I2C_BOARD_INFO(SENSOR_NAME_1, SENSOR_IIC_ADDR_1>>1)
+	},
+};
+
+struct soc_camera_link rk29_iclink_1 = {
+	.bus_id		= RK29_CAM_PLATFORM_DEV_ID,
+	.power		= rk29_sensor_power,
+	.powerdown  = rk29_sensor_powerdown,
+	.board_info	= &rk29_i2c_cam_info_1[0],
+	.i2c_adapter_id	= SENSOR_IIC_ADAPTER_ID_1,
+	.module_name	= SENSOR_NAME_1,
+};
+
+/*platform_device : soc-camera need  */
+struct platform_device rk29_soc_camera_pdrv_1 = {
+	.name	= "soc-camera-pdrv",
+	.id	= 1,
+	.dev	= {
+		.init_name = SENSOR_NAME_1,
+		.platform_data = &rk29_iclink_1,
+	},
+};
+
+
+static u64 rockchip_device_camera_dmamask = 0xffffffffUL;
+struct resource rk29_camera_resource[] = {
+	[0] = {
+		.start = RK29_VIP_PHYS,
+		.end   = RK29_VIP_PHYS + RK29_VIP_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_VIP,
+		.end   = IRQ_VIP,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+/*platform_device : */
+struct platform_device rk29_device_camera = {
+	.name		  = RK29_CAM_DRV_NAME,
+	.id		  = RK29_CAM_PLATFORM_DEV_ID,               /* This is used to put cameras on this interface */
+	.num_resources	  = ARRAY_SIZE(rk29_camera_resource),
+	.resource	  = rk29_camera_resource,
+	.dev            = {
+		.dma_mask = &rockchip_device_camera_dmamask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data  = &rk29_camera_platform_data,
+	}
+};
+#endif
+/*****************************************************************************************
+ * backlight  devices
+ * author: nzy@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+ /*
+ GPIO1B5_PWM0_NAME,       GPIO1L_PWM0
+ GPIO5D2_PWM1_UART1SIRIN_NAME,  GPIO5H_PWM1
+ GPIO2A3_SDMMC0WRITEPRT_PWM2_NAME,   GPIO2L_PWM2
+ GPIO1A5_EMMCPWREN_PWM3_NAME,     GPIO1L_PWM3
+ */
+
+#define PWM_ID            0
+#define PWM_MUX_NAME      GPIO1B5_PWM0_NAME
+#define PWM_MUX_MODE      GPIO1L_PWM0
+#define PWM_MUX_MODE_GPIO GPIO1L_GPIO1B5
+#define PWM_EFFECT_VALUE  1
+
+//#define LCD_DISP_ON_PIN
+
+#ifdef  LCD_DISP_ON_PIN
+#define BL_EN_MUX_NAME    GPIOF34_UART3_SEL_NAME
+#define BL_EN_MUX_MODE    IOMUXB_GPIO1_B34
+
+#define BL_EN_PIN         GPIO0L_GPIO0A5
+#define BL_EN_VALUE       GPIO_HIGH
+#endif
+static int rk29_backlight_io_init(void)
+{
+    int ret = 0;
+
+    rk29_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
+	#ifdef  LCD_DISP_ON_PIN
+    rk29_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
+
+    ret = gpio_request(BL_EN_PIN, NULL);
+    if(ret != 0)
+    {
+        gpio_free(BL_EN_PIN);
+    }
+
+    gpio_direction_output(BL_EN_PIN, 0);
+    gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+	#endif
+    return ret;
+}
+
+static int rk29_backlight_io_deinit(void)
+{
+    int ret = 0;
+    #ifdef  LCD_DISP_ON_PIN
+    gpio_free(BL_EN_PIN);
+    #endif
+    rk29_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
+    return ret;
+}
+struct rk29_bl_info rk29_bl_info = {
+    .pwm_id   = PWM_ID,
+    .bl_ref   = PWM_EFFECT_VALUE,
+    .io_init   = rk29_backlight_io_init,
+    .io_deinit = rk29_backlight_io_deinit,
+};
+#endif
+/*****************************************************************************************
+* pwm voltage regulator devices
+******************************************************************************************/
+#if defined (CONFIG_RK29_PWM_REGULATOR)
+
+#define REGULATOR_PWM_ID					2
+#define REGULATOR_PWM_MUX_NAME      		GPIO2A3_SDMMC0WRITEPRT_PWM2_NAME
+#define REGULATOR_PWM_MUX_MODE      					GPIO2L_PWM2
+#define REGULATOR_PWM_MUX_MODE_GPIO 				GPIO2L_GPIO2A3
+#define REGULATOR_PWM_GPIO				RK29_PIN2_PA3
+
+static struct regulator_consumer_supply pwm_consumers[] = {
+	{
+		.supply = "vcore",
+	}
+};
+
+static struct regulator_init_data rk29_pwm_regulator_data = {
+	.constraints = {
+		.name = "PWM2",
+		.min_uV =  950000,
+		.max_uV = 1400000,
+		.apply_uV = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(pwm_consumers),
+	.consumer_supplies = pwm_consumers,
+};
+
+static struct pwm_platform_data rk29_regulator_pwm_platform_data = {
+	.pwm_id = REGULATOR_PWM_ID,
+	.pwm_gpio = REGULATOR_PWM_GPIO,
+	//.pwm_iomux_name[] = REGULATOR_PWM_MUX_NAME;
+	.pwm_iomux_name = REGULATOR_PWM_MUX_NAME,
+	.pwm_iomux_pwm = REGULATOR_PWM_MUX_MODE,
+	.pwm_iomux_gpio = REGULATOR_PWM_MUX_MODE_GPIO,
+	.init_data  = &rk29_pwm_regulator_data,
+};
+
+static struct platform_device rk29_device_pwm_regulator = {
+	.name = "pwm-voltage-regulator",
+	.id   = -1,
+	.dev  = {
+		.platform_data = &rk29_regulator_pwm_platform_data,
+	},
+};
+
+#endif
+
+/*****************************************************************************************
+ * SDMMC devices
+*****************************************************************************************/
+#ifdef CONFIG_SDMMC0_RK29
+static int rk29_sdmmc0_cfg_gpio(void)
+{
+	rk29_mux_api_set(GPIO1D1_SDMMC0CMD_NAME, GPIO1H_SDMMC0_CMD);
+	rk29_mux_api_set(GPIO1D0_SDMMC0CLKOUT_NAME, GPIO1H_SDMMC0_CLKOUT);
+	rk29_mux_api_set(GPIO1D2_SDMMC0DATA0_NAME, GPIO1H_SDMMC0_DATA0);
+	rk29_mux_api_set(GPIO1D3_SDMMC0DATA1_NAME, GPIO1H_SDMMC0_DATA1);
+	rk29_mux_api_set(GPIO1D4_SDMMC0DATA2_NAME, GPIO1H_SDMMC0_DATA2);
+	rk29_mux_api_set(GPIO1D5_SDMMC0DATA3_NAME, GPIO1H_SDMMC0_DATA3);
+	rk29_mux_api_set(GPIO2A2_SDMMC0DETECTN_NAME, GPIO2L_SDMMC0_DETECT_N);
+	rk29_mux_api_set(GPIO5D5_SDMMC0PWREN_NAME, GPIO5H_GPIO5D5);   ///GPIO5H_SDMMC0_PWR_EN);  ///GPIO5H_GPIO5D5);
+	gpio_request(RK29_PIN5_PD5,"sdmmc");
+	gpio_set_value(RK29_PIN5_PD5,GPIO_HIGH);
+	mdelay(100);
+	gpio_set_value(RK29_PIN5_PD5,GPIO_LOW);
+	return 0;
+}
+
+#define CONFIG_SDMMC0_USE_DMA
+struct rk29_sdmmc_platform_data default_sdmmc0_data = {
+	.host_ocr_avail = (MMC_VDD_25_26|MMC_VDD_26_27|MMC_VDD_27_28|MMC_VDD_28_29|MMC_VDD_29_30|
+					   MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|
+					   MMC_VDD_33_34|MMC_VDD_34_35| MMC_VDD_35_36),
+	.host_caps 	= (MMC_CAP_4_BIT_DATA|MMC_CAP_MMC_HIGHSPEED|MMC_CAP_SD_HIGHSPEED),
+	.io_init = rk29_sdmmc0_cfg_gpio,
+	.dma_name = "sd_mmc",
+#ifdef CONFIG_SDMMC0_USE_DMA
+	.use_dma  = 1,
+#else
+	.use_dma = 0,
+#endif
+};
+#endif
+#ifdef CONFIG_SDMMC1_RK29
+#define CONFIG_SDMMC1_USE_DMA
+static int rk29_sdmmc1_cfg_gpio(void)
+{
+	rk29_mux_api_set(GPIO1C2_SDMMC1CMD_NAME, GPIO1H_SDMMC1_CMD);
+	rk29_mux_api_set(GPIO1C7_SDMMC1CLKOUT_NAME, GPIO1H_SDMMC1_CLKOUT);
+	rk29_mux_api_set(GPIO1C3_SDMMC1DATA0_NAME, GPIO1H_SDMMC1_DATA0);
+	rk29_mux_api_set(GPIO1C4_SDMMC1DATA1_NAME, GPIO1H_SDMMC1_DATA1);
+	rk29_mux_api_set(GPIO1C5_SDMMC1DATA2_NAME, GPIO1H_SDMMC1_DATA2);
+	rk29_mux_api_set(GPIO1C6_SDMMC1DATA3_NAME, GPIO1H_SDMMC1_DATA3);
+	//rk29_mux_api_set(GPIO1C0_UART0CTSN_SDMMC1DETECTN_NAME, GPIO1H_SDMMC1_DETECT_N);
+	return 0;
+}
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+static int rk29sdk_wifi_status(struct device *dev);
+static int rk29sdk_wifi_status_register(void (*callback)(int card_presend, void *dev_id), void *dev_id);
+#endif
+
+#define RK29SDK_WIFI_SDIO_CARD_DETECT_N    RK29_PIN1_PD6
+
+struct rk29_sdmmc_platform_data default_sdmmc1_data = {
+	.host_ocr_avail = (MMC_VDD_25_26|MMC_VDD_26_27|MMC_VDD_27_28|MMC_VDD_28_29|
+					   MMC_VDD_29_30|MMC_VDD_30_31|MMC_VDD_31_32|
+					   MMC_VDD_32_33|MMC_VDD_33_34),
+	.host_caps 	= (MMC_CAP_4_BIT_DATA|MMC_CAP_SDIO_IRQ|
+				   MMC_CAP_MMC_HIGHSPEED|MMC_CAP_SD_HIGHSPEED),
+	.io_init = rk29_sdmmc1_cfg_gpio,
+	.dma_name = "sdio",
+#ifdef CONFIG_SDMMC1_USE_DMA
+	.use_dma  = 1,
+#else
+	.use_dma = 0,
+#endif
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+        .status = rk29sdk_wifi_status,
+        .register_status_notify = rk29sdk_wifi_status_register,
+#endif
+#if 0
+        .detect_irq = RK29SDK_WIFI_SDIO_CARD_DETECT_N,
+#endif
+};
+#endif
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+#define RK29SDK_WIFI_BT_GPIO_POWER_N       RK29_PIN5_PD6
+#define RK29SDK_WIFI_GPIO_RESET_N          RK29_PIN6_PC0
+#define RK29SDK_BT_GPIO_RESET_N            RK29_PIN6_PC4
+
+static int rk29sdk_wifi_cd = 0;   /* wifi virtual 'card detect' status */
+static void (*wifi_status_cb)(int card_present, void *dev_id);
+static void *wifi_status_cb_devid;
+int rk29sdk_wifi_power_state = 0;
+int rk29sdk_bt_power_state = 0;
+
+static int rk29sdk_wifi_status(struct device *dev)
+{
+        return rk29sdk_wifi_cd;
+}
+
+static int rk29sdk_wifi_status_register(void (*callback)(int card_present, void *dev_id), void *dev_id)
+{
+        if(wifi_status_cb)
+                return -EAGAIN;
+        wifi_status_cb = callback;
+        wifi_status_cb_devid = dev_id;
+        return 0;
+}
+
+static int rk29sdk_wifi_bt_gpio_control_init(void)
+{
+    if (gpio_request(RK29SDK_WIFI_BT_GPIO_POWER_N, "wifi_bt_power")) {
+           pr_info("%s: request wifi_bt power gpio failed\n", __func__);
+           return -1;
+    }
+
+    if (gpio_request(RK29SDK_WIFI_GPIO_RESET_N, "wifi reset")) {
+           pr_info("%s: request wifi reset gpio failed\n", __func__);
+           gpio_free(RK29SDK_WIFI_BT_GPIO_POWER_N);
+           return -1;
+    }
+
+    if (gpio_request(RK29SDK_BT_GPIO_RESET_N, "bt reset")) {
+          pr_info("%s: request bt reset gpio failed\n", __func__);
+          gpio_free(RK29SDK_WIFI_GPIO_RESET_N);
+          return -1;
+    }
+
+    gpio_direction_output(RK29SDK_WIFI_BT_GPIO_POWER_N, GPIO_LOW);
+    gpio_direction_output(RK29SDK_WIFI_GPIO_RESET_N,    GPIO_LOW);
+    gpio_direction_output(RK29SDK_BT_GPIO_RESET_N,      GPIO_LOW);
+
+    pr_info("%s: init finished\n",__func__);
+
+    return 0;
+}
+
+static int rk29sdk_wifi_power(int on)
+{
+        pr_info("%s: %d\n", __func__, on);
+        if (on){
+                gpio_set_value(RK29SDK_WIFI_BT_GPIO_POWER_N, on);
+                mdelay(100);
+                pr_info("wifi turn on power\n");
+        }else{
+                if (!rk29sdk_bt_power_state){
+                        gpio_set_value(RK29SDK_WIFI_BT_GPIO_POWER_N, on);
+                        mdelay(100);
+                        pr_info("wifi shut off power\n");
+                }else
+                {
+                        pr_info("wifi shouldn't shut off power, bt is using it!\n");
+                }
+
+        }
+
+        rk29sdk_wifi_power_state = on;
+        return 0;
+}
+
+static int rk29sdk_wifi_reset_state;
+static int rk29sdk_wifi_reset(int on)
+{
+        pr_info("%s: %d\n", __func__, on);
+        gpio_set_value(RK29SDK_WIFI_GPIO_RESET_N, on);
+        mdelay(100);
+        rk29sdk_wifi_reset_state = on;
+        return 0;
+}
+
+static int rk29sdk_wifi_set_carddetect(int val)
+{
+        pr_info("%s:%d\n", __func__, val);
+        rk29sdk_wifi_cd = val;
+        if (wifi_status_cb){
+                wifi_status_cb(val, wifi_status_cb_devid);
+        }else {
+                pr_warning("%s, nobody to notify\n", __func__);
+        }
+        return 0;
+}
+
+static struct wifi_platform_data rk29sdk_wifi_control = {
+        .set_power = rk29sdk_wifi_power,
+        .set_reset = rk29sdk_wifi_reset,
+        .set_carddetect = rk29sdk_wifi_set_carddetect,
+};
+static struct platform_device rk29sdk_wifi_device = {
+        .name = "bcm4329_wlan",
+        .id = 1,
+        .dev = {
+                .platform_data = &rk29sdk_wifi_control,
+         },
+};
+#endif
+
+
+/* bluetooth rfkill device */
+static struct platform_device rk29sdk_rfkill = {
+        .name = "rk29sdk_rfkill",
+        .id = -1,
+};
+
+
+#ifdef CONFIG_VIVANTE
+static struct resource resources_gpu[] = {
+    [0] = {
+		.name 	= "gpu_irq",
+        .start 	= IRQ_GPU,
+        .end    = IRQ_GPU,
+        .flags  = IORESOURCE_IRQ,
+    },
+    [1] = {
+		.name = "gpu_base",
+        .start  = RK29_GPU_PHYS,
+        .end    = RK29_GPU_PHYS + RK29_GPU_PHYS_SIZE,
+        .flags  = IORESOURCE_MEM,
+    },
+    [2] = {
+		.name = "gpu_mem",
+        .start  = PMEM_GPU_BASE,
+        .end    = PMEM_GPU_BASE + PMEM_GPU_SIZE,
+        .flags  = IORESOURCE_MEM,
+    },
+};
+struct platform_device rk29_device_gpu = {
+    .name             = "galcore",
+    .id               = 0,
+    .num_resources    = ARRAY_SIZE(resources_gpu),
+    .resource         = resources_gpu,
+};
+#endif
+#ifdef CONFIG_KEYS_RK29
+extern struct rk29_keys_platform_data rk29_keys_pdata;
+static struct platform_device rk29_device_keys = {
+	.name		= "rk29-keypad",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &rk29_keys_pdata,
+	},
+};
+#endif
+
+static void __init rk29_board_iomux_init(void)
+{
+	#ifdef CONFIG_UART0_RK29
+	rk29_mux_api_set(GPIO1B7_UART0SOUT_NAME, GPIO1L_UART0_SOUT);
+	rk29_mux_api_set(GPIO1B6_UART0SIN_NAME, GPIO1L_UART0_SIN);
+	#ifdef CONFIG_UART0_CTS_RTS_RK29
+	rk29_mux_api_set(GPIO1C1_UART0RTSN_SDMMC1WRITEPRT_NAME, GPIO1H_UART0_RTS_N);
+	rk29_mux_api_set(GPIO1C0_UART0CTSN_SDMMC1DETECTN_NAME, GPIO1H_UART0_CTS_N);
+	#endif
+	#endif
+	#ifdef CONFIG_UART1_RK29
+	rk29_mux_api_set(GPIO2A5_UART1SOUT_NAME, GPIO2L_UART1_SOUT);
+	rk29_mux_api_set(GPIO2A4_UART1SIN_NAME, GPIO2L_UART1_SIN);
+	#endif
+	#ifdef CONFIG_UART2_RK29
+	rk29_mux_api_set(GPIO2B1_UART2SOUT_NAME, GPIO2L_UART2_SOUT);
+	rk29_mux_api_set(GPIO2B0_UART2SIN_NAME, GPIO2L_UART2_SIN);
+	#ifdef CONFIG_UART2_CTS_RTS_RK29
+	rk29_mux_api_set(GPIO2A7_UART2RTSN_NAME, GPIO2L_UART2_RTS_N);
+	rk29_mux_api_set(GPIO2A6_UART2CTSN_NAME, GPIO2L_UART2_CTS_N);
+	#endif
+	#endif
+	#ifdef CONFIG_UART3_RK29
+	rk29_mux_api_set(GPIO2B3_UART3SOUT_NAME, GPIO2L_UART3_SOUT);
+	rk29_mux_api_set(GPIO2B2_UART3SIN_NAME, GPIO2L_UART3_SIN);
+	#ifdef CONFIG_UART3_CTS_RTS_RK29
+	rk29_mux_api_set(GPIO2B5_UART3RTSN_I2C3SCL_NAME, GPIO2L_UART3_RTS_N);
+	rk29_mux_api_set(GPIO2B4_UART3CTSN_I2C3SDA_NAME, GPIO2L_UART3_CTS_N);
+	#endif
+	#endif
+	#ifdef CONFIG_SPIM0_RK29
+    rk29_mux_api_set(GPIO2C0_SPI0CLK_NAME, GPIO2H_SPI0_CLK);
+	rk29_mux_api_set(GPIO2C1_SPI0CSN0_NAME, GPIO2H_SPI0_CSN0);
+	rk29_mux_api_set(GPIO2C2_SPI0TXD_NAME, GPIO2H_SPI0_TXD);
+	rk29_mux_api_set(GPIO2C3_SPI0RXD_NAME, GPIO2H_SPI0_RXD);
+    #endif
+    #ifdef CONFIG_SPIM1_RK29
+    rk29_mux_api_set(GPIO2C4_SPI1CLK_NAME, GPIO2H_SPI1_CLK);
+	rk29_mux_api_set(GPIO2C5_SPI1CSN0_NAME, GPIO2H_SPI1_CSN0);
+	rk29_mux_api_set(GPIO2C6_SPI1TXD_NAME, GPIO2H_SPI1_TXD);
+	rk29_mux_api_set(GPIO2C7_SPI1RXD_NAME, GPIO2H_SPI1_RXD);
+    #endif
+	#ifdef CONFIG_RK29_VMAC
+    rk29_mux_api_set(GPIO4C0_RMIICLKOUT_RMIICLKIN_NAME, GPIO4H_RMII_CLKOUT);
+    rk29_mux_api_set(GPIO4C1_RMIITXEN_MIITXEN_NAME, GPIO4H_RMII_TX_EN);
+    rk29_mux_api_set(GPIO4C2_RMIITXD1_MIITXD1_NAME, GPIO4H_RMII_TXD1);
+    rk29_mux_api_set(GPIO4C3_RMIITXD0_MIITXD0_NAME, GPIO4H_RMII_TXD0);
+    rk29_mux_api_set(GPIO4C4_RMIIRXERR_MIIRXERR_NAME, GPIO4H_RMII_RX_ERR);
+    rk29_mux_api_set(GPIO4C5_RMIICSRDVALID_MIIRXDVALID_NAME, GPIO4H_RMII_CSR_DVALID);
+    rk29_mux_api_set(GPIO4C6_RMIIRXD1_MIIRXD1_NAME, GPIO4H_RMII_RXD1);
+    rk29_mux_api_set(GPIO4C7_RMIIRXD0_MIIRXD0_NAME, GPIO4H_RMII_RXD0);
+
+	rk29_mux_api_set(GPIO0A7_MIIMDCLK_NAME, GPIO0L_MII_MDCLK);
+	rk29_mux_api_set(GPIO0A6_MIIMD_NAME, GPIO0L_MII_MD);
+	#endif
+	#ifdef CONFIG_RK29_PWM_REGULATOR
+	rk29_mux_api_set(REGULATOR_PWM_MUX_NAME,REGULATOR_PWM_MUX_MODE);
+	#endif
+}
+
+static struct platform_device *devices[] __initdata = {
+#ifdef CONFIG_UART1_RK29
+	&rk29_device_uart1,
+#endif
+#ifdef CONFIG_UART0_RK29
+	&rk29_device_uart0,
+#endif
+#ifdef CONFIG_UART2_RK29
+	&rk29_device_uart2,
+#endif
+
+#ifdef CONFIG_RK29_PWM_REGULATOR
+	&rk29_device_pwm_regulator,
+#endif
+#ifdef CONFIG_SPIM0_RK29
+    &rk29xx_device_spi0m,
+#endif
+#ifdef CONFIG_SPIM1_RK29
+    &rk29xx_device_spi1m,
+#endif
+#ifdef CONFIG_ADC_RK29
+	&rk29_device_adc,
+#endif
+#ifdef CONFIG_I2C0_RK29
+	&rk29_device_i2c0,
+#endif
+#ifdef CONFIG_I2C1_RK29
+	&rk29_device_i2c1,
+#endif
+#ifdef CONFIG_I2C2_RK29
+	&rk29_device_i2c2,
+#endif
+#ifdef CONFIG_I2C3_RK29
+	&rk29_device_i2c3,
+#endif
+
+#ifdef CONFIG_SND_RK29_SOC_I2S_2CH
+        &rk29_device_iis_2ch,
+#endif
+#ifdef CONFIG_SND_RK29_SOC_I2S_8CH
+        &rk29_device_iis_8ch,
+#endif
+
+#ifdef CONFIG_KEYS_RK29
+	&rk29_device_keys,
+#endif
+#ifdef CONFIG_SDMMC0_RK29
+	&rk29_device_sdmmc0,
+#endif
+#ifdef CONFIG_SDMMC1_RK29
+	&rk29_device_sdmmc1,
+#endif
+
+#ifdef CONFIG_MTD_NAND_RK29XX
+	&rk29xx_device_nand,
+#endif
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+        &rk29sdk_wifi_device,
+#endif
+
+#ifdef CONFIG_BT
+        &rk29sdk_rfkill,
+#endif
+
+#ifdef CONFIG_MTD_NAND_RK29
+	&rk29_device_nand,
+#endif
+
+#ifdef CONFIG_FB_RK29
+	&rk29_device_fb,
+#endif
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+	&rk29_device_backlight,
+#endif
+#ifdef CONFIG_RK29_VMAC
+	&rk29_device_vmac,
+#endif
+#ifdef CONFIG_VIVANTE
+	&rk29_device_gpu,
+#endif
+#ifdef CONFIG_VIDEO_RK29
+ 	&rk29_device_camera,      /* ddl@rock-chips.com : camera support  */
+ 	#if (SENSOR_IIC_ADDR_0 != 0x00)
+ 	&rk29_soc_camera_pdrv_0,
+ 	#endif
+ 	&rk29_soc_camera_pdrv_1,
+ 	&android_pmem_cam_device,
+#endif
+	&android_pmem_device,
+	&rk29_vpu_mem_device,
+#ifdef CONFIG_USB20_OTG
+	&rk29_device_usb20_otg,
+#endif
+#ifdef CONFIG_USB20_HOST
+	&rk29_device_usb20_host,
+#endif
+#ifdef CONFIG_USB11_HOST
+	&rk29_device_usb11_host,
+#endif
+#ifdef CONFIG_USB_ANDROID
+	&android_usb_device,
+	&usb_mass_storage_device,
+#endif
+#ifdef CONFIG_RK29_IPP
+	&rk29_device_ipp,
+#endif
+};
+
+/*****************************************************************************************
+ * spi devices
+ * author: cmc@rock-chips.com
+ *****************************************************************************************/
+static int rk29_vmac_register_set(void)
+{
+	//config rk29 vmac as rmii, 100MHz
+	u32 value= readl(RK29_GRF_BASE + 0xbc);
+	value = (value & 0xfff7ff) | (0x400);
+	writel(value, RK29_GRF_BASE + 0xbc);
+	return 0;
+}
+
+static int rk29_rmii_io_init(void)
+{
+	int err;
+
+	//phy power gpio
+	err = gpio_request(RK29_PIN6_PB0, "phy_power_en");
+	if (err) {
+		gpio_free(RK29_PIN6_PB0);
+		printk("-------request RK29_PIN6_PB0 fail--------\n");
+		return -1;
+	}
+	//phy power down
+	gpio_direction_output(RK29_PIN6_PB0, GPIO_LOW);
+	gpio_set_value(RK29_PIN6_PB0, GPIO_LOW);
+
+	return 0;
+}
+
+static int rk29_rmii_io_deinit(void)
+{
+	//phy power down
+	gpio_direction_output(RK29_PIN6_PB0, GPIO_LOW);
+	gpio_set_value(RK29_PIN6_PB0, GPIO_LOW);
+	//free
+	gpio_free(RK29_PIN6_PB0);
+	return 0;
+}
+
+static int rk29_rmii_power_control(int enable)
+{
+	if (enable) {
+		//enable phy power
+		gpio_direction_output(RK29_PIN6_PB0, GPIO_HIGH);
+		gpio_set_value(RK29_PIN6_PB0, GPIO_HIGH);
+	}
+	else {
+		gpio_direction_output(RK29_PIN6_PB0, GPIO_LOW);
+		gpio_set_value(RK29_PIN6_PB0, GPIO_LOW);
+	}
+	return 0;
+}
+
+struct rk29_vmac_platform_data rk29_vmac_pdata = {
+	.vmac_register_set = rk29_vmac_register_set,
+	.rmii_io_init = rk29_rmii_io_init,
+	.rmii_io_deinit = rk29_rmii_io_deinit,
+	.rmii_power_control = rk29_rmii_power_control,
+};
+
+/*****************************************************************************************
+ * spi devices
+ * author: cmc@rock-chips.com
+ *****************************************************************************************/
+#define SPI_CHIPSELECT_NUM 2
+struct spi_cs_gpio rk29xx_spi0_cs_gpios[SPI_CHIPSELECT_NUM] = {
+    {
+		.name = "spi0 cs0",
+		.cs_gpio = RK29_PIN2_PC1,
+		.cs_iomux_name = NULL,
+	},
+	{
+		.name = "spi0 cs1",
+		.cs_gpio = RK29_PIN1_PA4,
+		.cs_iomux_name = GPIO1A4_EMMCWRITEPRT_SPI0CS1_NAME,//if no iomux,set it NULL
+		.cs_iomux_mode = GPIO1L_SPI0_CSN1,
+	}
+};
+
+struct spi_cs_gpio rk29xx_spi1_cs_gpios[SPI_CHIPSELECT_NUM] = {
+    {
+		.name = "spi1 cs0",
+		.cs_gpio = RK29_PIN2_PC5,
+		.cs_iomux_name = NULL,
+	},
+	{
+		.name = "spi1 cs1",
+		.cs_gpio = RK29_PIN1_PA3,
+		.cs_iomux_name = GPIO1A3_EMMCDETECTN_SPI1CS1_NAME,//if no iomux,set it NULL
+		.cs_iomux_mode = GPIO1L_SPI1_CSN1,
+	}
+};
+
+static int spi_io_init(struct spi_cs_gpio *cs_gpios, int cs_num)
+{
+#if 1
+	int i,j,ret;
+
+	//cs
+	if (cs_gpios) {
+		for (i=0; i<cs_num; i++) {
+			rk29_mux_api_set(cs_gpios[i].cs_iomux_name, cs_gpios[i].cs_iomux_mode);
+			ret = gpio_request(cs_gpios[i].cs_gpio, cs_gpios[i].name);
+			if (ret) {
+				for (j=0;j<i;j++) {
+					gpio_free(cs_gpios[j].cs_gpio);
+					//rk29_mux_api_mode_resume(cs_gpios[j].cs_iomux_name);
+				}
+				printk("[fun:%s, line:%d], gpio request err\n", __func__, __LINE__);
+				return -1;
+			}
+			gpio_direction_output(cs_gpios[i].cs_gpio, GPIO_HIGH);
+		}
+	}
+#endif
+	return 0;
+}
+
+static int spi_io_deinit(struct spi_cs_gpio *cs_gpios, int cs_num)
+{
+#if 1
+	int i;
+
+	if (cs_gpios) {
+		for (i=0; i<cs_num; i++) {
+			gpio_free(cs_gpios[i].cs_gpio);
+			//rk29_mux_api_mode_resume(cs_gpios[i].cs_iomux_name);
+		}
+	}
+#endif
+	return 0;
+}
+
+static int spi_io_fix_leakage_bug(void)
+{
+#if 0
+	gpio_direction_output(RK29_PIN2_PC1, GPIO_LOW);
+#endif
+	return 0;
+}
+
+static int spi_io_resume_leakage_bug(void)
+{
+#if 0
+	gpio_direction_output(RK29_PIN2_PC1, GPIO_HIGH);
+#endif
+	return 0;
+}
+
+struct rk29xx_spi_platform_data rk29xx_spi0_platdata = {
+	.num_chipselect = SPI_CHIPSELECT_NUM,
+	.chipselect_gpios = rk29xx_spi0_cs_gpios,
+	.io_init = spi_io_init,
+	.io_deinit = spi_io_deinit,
+	.io_fix_leakage_bug = spi_io_fix_leakage_bug,
+	.io_resume_leakage_bug = spi_io_resume_leakage_bug,
+};
+
+struct rk29xx_spi_platform_data rk29xx_spi1_platdata = {
+	.num_chipselect = SPI_CHIPSELECT_NUM,
+	.chipselect_gpios = rk29xx_spi1_cs_gpios,
+	.io_init = spi_io_init,
+	.io_deinit = spi_io_deinit,
+	.io_fix_leakage_bug = spi_io_fix_leakage_bug,
+	.io_resume_leakage_bug = spi_io_resume_leakage_bug,
+};
+
+/*****************************************************************************************
+ * xpt2046 touch panel
+ * author: cmc@rock-chips.com
+ *****************************************************************************************/
+#define XPT2046_GPIO_INT           RK29_PIN0_PA3
+#define DEBOUNCE_REPTIME  3
+
+#if defined(CONFIG_TOUCHSCREEN_XPT2046_320X480_SPI)
+static struct xpt2046_platform_data xpt2046_info = {
+	.model			= 2046,
+	.keep_vref_on 	= 1,
+	.swap_xy		= 0,
+	.x_min			= 0,
+	.x_max			= 320,
+	.y_min			= 0,
+	.y_max			= 480,
+	.debounce_max		= 7,
+	.debounce_rep		= DEBOUNCE_REPTIME,
+	.debounce_tol		= 20,
+	.gpio_pendown		= XPT2046_GPIO_INT,
+	.penirq_recheck_delay_usecs = 1,
+};
+#elif defined(CONFIG_TOUCHSCREEN_XPT2046_320X480_CBN_SPI)
+static struct xpt2046_platform_data xpt2046_info = {
+	.model			= 2046,
+	.keep_vref_on 	= 1,
+	.swap_xy		= 0,
+	.x_min			= 0,
+	.x_max			= 320,
+	.y_min			= 0,
+	.y_max			= 480,
+	.debounce_max		= 7,
+	.debounce_rep		= DEBOUNCE_REPTIME,
+	.debounce_tol		= 20,
+	.gpio_pendown		= XPT2046_GPIO_INT,
+	.penirq_recheck_delay_usecs = 1,
+};
+#elif defined(CONFIG_TOUCHSCREEN_XPT2046_SPI)
+static struct xpt2046_platform_data xpt2046_info = {
+	.model			= 2046,
+	.keep_vref_on 	= 1,
+	.swap_xy		= 1,
+	.x_min			= 0,
+	.x_max			= 800,
+	.y_min			= 0,
+	.y_max			= 480,
+	.debounce_max		= 7,
+	.debounce_rep		= DEBOUNCE_REPTIME,
+	.debounce_tol		= 20,
+	.gpio_pendown		= XPT2046_GPIO_INT,
+
+	.penirq_recheck_delay_usecs = 1,
+};
+#elif defined(CONFIG_TOUCHSCREEN_XPT2046_CBN_SPI)
+static struct xpt2046_platform_data xpt2046_info = {
+	.model			= 2046,
+	.keep_vref_on 	= 1,
+	.swap_xy		= 1,
+	.x_min			= 0,
+	.x_max			= 800,
+	.y_min			= 0,
+	.y_max			= 480,
+	.debounce_max		= 7,
+	.debounce_rep		= DEBOUNCE_REPTIME,
+	.debounce_tol		= 20,
+	.gpio_pendown		= XPT2046_GPIO_INT,
+
+	.penirq_recheck_delay_usecs = 1,
+};
+#endif
+
+static struct spi_board_info board_spi_devices[] = {
+#if defined(CONFIG_TOUCHSCREEN_XPT2046_320X480_SPI) || defined(CONFIG_TOUCHSCREEN_XPT2046_320X480_CBN_SPI)\
+    ||defined(CONFIG_TOUCHSCREEN_XPT2046_SPI) || defined(CONFIG_TOUCHSCREEN_XPT2046_CBN_SPI)
+	{
+		.modalias	= "xpt2046_ts",
+		.chip_select	= 0,
+		.max_speed_hz	= 125 * 1000 * 26,/* (max sample rate @ 3V) * (cmd + data + overhead) */
+		.bus_num	= 0,
+		.irq = XPT2046_GPIO_INT,
+		.platform_data = &xpt2046_info,
+	},
+#endif
+};
+
+
+static void __init rk29_gic_init_irq(void)
+{
+	gic_dist_init(0, (void __iomem *)RK29_GICPERI_BASE, 32);
+	gic_cpu_init(0, (void __iomem *)RK29_GICCPU_BASE);
+}
+
+static void __init machine_rk29_init_irq(void)
+{
+	rk29_gic_init_irq();
+	rk29_gpio_init();
+}
+
+#define POWER_ON_PIN RK29_PIN4_PA4
+static void rk29_pm_power_off(void)
+{
+	printk(KERN_ERR "rk29_pm_power_off start...\n");
+	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
+	while (1);
+}
+
+static void __init machine_rk29_board_init(void)
+{
+	rk29_board_iomux_init();
+
+	gpio_request(POWER_ON_PIN,"poweronpin");
+	gpio_set_value(POWER_ON_PIN, GPIO_HIGH);
+	gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
+	pm_power_off = rk29_pm_power_off;
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+                rk29sdk_wifi_bt_gpio_control_init();
+#endif
+
+		platform_add_devices(devices, ARRAY_SIZE(devices));
+#ifdef CONFIG_I2C0_RK29
+	i2c_register_board_info(default_i2c0_data.bus_num, board_i2c0_devices,
+			ARRAY_SIZE(board_i2c0_devices));
+#endif
+#ifdef CONFIG_I2C1_RK29
+	i2c_register_board_info(default_i2c1_data.bus_num, board_i2c1_devices,
+			ARRAY_SIZE(board_i2c1_devices));
+#endif
+#ifdef CONFIG_I2C2_RK29
+	i2c_register_board_info(default_i2c2_data.bus_num, board_i2c2_devices,
+			ARRAY_SIZE(board_i2c2_devices));
+#endif
+#ifdef CONFIG_I2C3_RK29
+	i2c_register_board_info(default_i2c3_data.bus_num, board_i2c3_devices,
+			ARRAY_SIZE(board_i2c3_devices));
+#endif
+
+	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
+}
+
+static void __init machine_rk29_fixup(struct machine_desc *desc, struct tag *tags,
+					char **cmdline, struct meminfo *mi)
+{
+	mi->nr_banks = 1;
+	mi->bank[0].start = RK29_SDRAM_PHYS;
+	mi->bank[0].node = PHYS_TO_NID(RK29_SDRAM_PHYS);
+	mi->bank[0].size = LINUX_SIZE;
+}
+
+static void __init machine_rk29_mapio(void)
+{
+	rk29_map_common_io();
+	rk29_clock_init();
+	rk29_iomux_init();
+}
+
+MACHINE_START(RK29, "RK29board")
+	/* UART for LL DEBUG */
+	.phys_io	= RK29_UART1_PHYS,
+	.io_pg_offst	= ((RK29_UART1_BASE) >> 18) & 0xfffc,
+	.boot_params	= RK29_SDRAM_PHYS + 0x88000,
+	.fixup		= machine_rk29_fixup,
+	.map_io		= machine_rk29_mapio,
+	.init_irq	= machine_rk29_init_irq,
+	.init_machine	= machine_rk29_board_init,
+	.timer		= &rk29_timer,
+MACHINE_END
diff --git a/arch/arm/mach-rk29/include/mach/board.h b/arch/arm/mach-rk29/include/mach/board.h
index a971ffe2b6e6..46317ec0ad28 100755
--- a/arch/arm/mach-rk29/include/mach/board.h
+++ b/arch/arm/mach-rk29/include/mach/board.h
@@ -140,6 +140,29 @@ struct eeti_egalax_platform_data{
     int     (*eeti_egalax_platform_wakeup)(void);
     void    (*exit_platform_hw)(void);
 };
+
+/*sintex touch*/
+struct sintek_platform_data {
+	u16 	model;
+
+	int 	(*get_pendown_state)(void);
+	int 	(*init_platform_hw)(void);
+	int 	(*sintek_platform_sleep)(void);
+	int 	(*sintek_platform_wakeup)(void);
+	void	(*exit_platform_hw)(void);
+};
+
+/*synaptics  touch*/
+struct synaptics_platform_data {
+	u16 	model;
+	
+	int 	(*get_pendown_state)(void);
+	int 	(*init_platform_hw)(void);
+	int 	(*sintek_platform_sleep)(void);
+	int 	(*sintek_platform_wakeup)(void);
+	void	(*exit_platform_hw)(void);
+};
+
 struct mma8452_platform_data {
     u16     model;
 	u16     swap_xy;
diff --git a/arch/arm/mach-rk29/include/mach/rk29_camera.h b/arch/arm/mach-rk29/include/mach/rk29_camera.h
index 4e2bb358f7cf..21cecffd001b 100644
--- a/arch/arm/mach-rk29/include/mach/rk29_camera.h
+++ b/arch/arm/mach-rk29/include/mach/rk29_camera.h
@@ -37,6 +37,7 @@
 #define RK29_CAM_SENSOR_NAME_OV2659 "ov2659"
 #define RK29_CAM_SENSOR_NAME_OV3640 "ov3640"
 #define RK29_CAM_SENSOR_NAME_OV5642 "ov5642"
+#define RK29_CAM_SENSOR_NAME_S5K6AA "s5k6aa"
 
 #define RK29_CAM_POWERACTIVE_BITPOS	0x00
 #define RK29_CAM_POWERACTIVE_MASK	(1<<RK29_CAM_POWERACTIVE_BITPOS)
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index eae1a07310fc..fa189912158d 100755
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -17,7 +17,12 @@ config KEYS_RK29
 	default y
 	help
 		rk29 keyboard drivers(gpio and adc)
-
+config SYNAPTICS_SO340010
+	tristate "Synaptics So340010 TouchPad KEY"
+	depends on ARCH_RK29
+	default y
+	help
+	   "Synaptics So340010 Touch Key (I2C) driver"
 config KEYBOARD_AAED2000
 	tristate "AAED-2000 keyboard"
 	depends on MACH_AAED2000
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index afbeafdb2385..69f3d3627316 100755
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -41,4 +41,5 @@ obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
 obj-$(CONFIG_KEYBOARD_RK28ADC)		+= rk2818_adckey.o
 obj-$(CONFIG_KEYBOARD_RK28ADC_IT50)		+= rk2818_adckey_t50.o
 obj-$(CONFIG_HEADSET_KEY)		+= rk2818_hskey.o
+obj-$(CONFIG_SYNAPTICS_SO340010)        += synaptics_so340010.o
 
diff --git a/drivers/input/keyboard/synaptics_so340010.c b/drivers/input/keyboard/synaptics_so340010.c
new file mode 100755
index 000000000000..cd607ee7c1fd
--- /dev/null
+++ b/drivers/input/keyboard/synaptics_so340010.c
@@ -0,0 +1,459 @@
+/****************************************************************************************
+ * driver/input/touchscreen/hannstar_Synaptics.c
+ *Copyright 	:ROCKCHIP  Inc
+ *Author	: 	sfm
+ *Date		:  2010.2.5
+ *This driver use for rk28 chip extern touchscreen. Use i2c IF ,the chip is Hannstar
+ *description
+ ********************************************************************************************/
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/earlysuspend.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/async.h>
+#include <mach/gpio.h>
+#include <linux/irq.h>
+#include <mach/board.h>
+
+
+#define SO340010_REG_GENERAL_CONFIG 	0x0001
+#define SO340010_REG_GPIO_STATE			0x0108
+#define SO340010_REG_BUTTON_STATE 	0x0109
+#define SO340010_REG_GPIO_CTRL			0x000E
+#define SO340010_REG_GPIO_CTRL_DIR		0x0F00
+#define SO340010_REG_GPIO_CTRL_DATA		0x000F
+#define SO340010_REG_LED_ENABLE			0x0022
+#define SO340010_REG_LED_EFFECT_PERIOD	0x0023
+#define SO340010_REG_LED_CTRL1			0x0024
+#define SO340010_REG_LED_CTRL1_LED0_EFFECT		0x001F
+#define SO340010_REG_LED_CTRL1_LED0_BRIGHTNESS	0x0E00
+#define SO340010_REG_LED_CTRL1_LED1_EFFECT		0x000E
+#define SO340010_REG_LED_CTRL1_LED1_BRIGHTNESS	0x1F00
+#define SO340010_REG_LED_CONTROL_2		0x0025
+#define SO340010_REG_LED_CTRL2_LED2_EFFECT		0x001F
+#define SO340010_REG_LED_CTRL2_LED2_BRIGHTNESS	0x0E00
+#define SO340010_REG_LED_CTRL2_LED3_EFFECT		0x000E
+#define SO340010_REG_LED_CTRL2_LED3_BRIGHTNESS	0x1F00
+#define SO340010_REG_NUM				74
+#define SO340010_IIC_SPEED		100*1000
+
+#define PACKGE_BUFLEN		10
+#define KEY0			0x1
+#define KEY1 		0x2
+#define KEY2 		0x4
+#define KEY3 		0x8
+#define KEY_ALL			(KEY0 | KEY1 | KEY2 | KEY3)
+#define SYN_340010_KEY_MAXNUM		4
+
+#if 0
+#define DBG(x...) printk(KERN_INFO x)
+#else
+#define DBG(x...) do { } while (0)
+#endif
+
+struct so340010_kbd_info {	
+	unsigned int	key_mask;	
+	int 			key_code; 
+};
+static struct so340010_kbd_info key_table[SYN_340010_KEY_MAXNUM] = { 
+	{ KEY3, KEY_BACK }, 
+	{ KEY2, KEY_MENU }, 
+	{ KEY1, KEY_HOME }, 
+	{ KEY0, KEY_SEARCH },
+};
+static int key_num = sizeof(key_table)/sizeof(key_table[0]);
+
+struct so340010_register {	
+	unsigned short address; 
+	const short  value;
+};
+
+static struct so340010_register so340010_register_init_table[] = {	
+#if 0
+	{ 0x0000,  0x0007  }, 
+	{ 0x0001,  0x0020  }, 
+	{ 0x0004,  0x000F  }, 
+	{ 0x0010,  0xA0A0  }, 
+	{ 0x0011,  0xA0A0  },
+#else
+	{ 0x0000,  0x0700  }, 
+	{ 0x0100,  0x2000  }, 
+	{ 0x0400,  0x0F00  }, 
+	{ 0x1000,  0xA0A0  }, 
+	{ 0x1100,  0xA0A0  },
+#endif
+#if (defined(CONFIG_KEYBOARD_SO340010_LED) || defined(CONFIG_KEYBOARD_SO340010_LED_FRAMEWORK))	
+	{ 0x0022,  0x000f  }, 	
+	{ 0x0023,  0x0000  }, 
+	{ 0x0024,  0x0f0f  }, 	/* Brightness value 0 ~ 31*/	
+	{ 0x0025,  0x1616  }, 
+#endif
+};
+
+/*
+ * Common code for bq3060 devices read
+ */
+static int Synaptics_touchkey_read(struct i2c_client *client, unsigned short  reg, unsigned short  buf[], unsigned len)
+{
+	int ret; 	
+	struct i2c_adapter *adap=client->adapter;
+	struct i2c_msg msg;
+	char tx_buf[2];
+	
+	tx_buf[0] = reg & 0xff;
+	tx_buf[1] = (reg>>8) & 0xff;
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = 2;
+	msg.buf = (char *)tx_buf;
+	msg.scl_rate = SO340010_IIC_SPEED;
+
+	ret = i2c_transfer(adap, &msg, 1);
+	if(ret < 0)
+		printk("[%s]: i2c read error\n",__FUNCTION__);
+	
+	msg.addr = client->addr;
+	msg.flags = client->flags | I2C_M_RD;
+	msg.len = 2*len ;
+	msg.buf = (char *)buf;
+	msg.scl_rate = SO340010_IIC_SPEED;
+
+	ret = i2c_transfer(adap, &msg, 1);
+	
+	//return 0;
+	//ret = i2c_master_reg16_recv(client, reg, buf, len, 100*1000);
+	if(ret < 0)
+		printk("[%s]: i2c read error\n",__FUNCTION__);
+	return ret; 
+}
+
+static int Synaptics_touchkey_write(struct i2c_client *client, unsigned short  reg, const short   buf[], unsigned len)
+{
+
+	int ret; 
+	//return 0;
+	ret = i2c_master_reg16_send(client, reg, buf, (int)len, 100*1000);
+	if(ret < 0)
+		printk("[%s]: i2c write error\n",__FUNCTION__);
+	return ret;
+}
+
+
+
+struct point_data {	
+	short status;	
+	short x;	
+	short y;
+    short z;
+};
+
+
+
+struct tk_Synaptics {
+	struct input_dev	*input;
+	char			phys[32];
+	struct delayed_work	work;
+	struct workqueue_struct *wq;
+
+	struct i2c_client	*client;
+	int    g_code;
+	int		gpio;
+	u16			model;
+	spinlock_t 	lock;
+	bool		pendown;
+	bool 	 	status;
+	int			irq;
+	int         init_flag;
+	int 		has_relative_report;
+	int			(*get_pendown_state)(void);
+	void		(*clear_penirq)(void);
+};
+
+int Synaptics_get_pendown_state(void)
+{
+	return 0;
+}
+
+#if 0 
+static void Synaptics_report_event(struct tk_Synaptics *tk,struct multitouch_event *tc)
+{
+	struct input_dev *input = tk->input;
+    int cid;
+
+    cid = tc->contactid;
+    if (tk->status) {
+        input_report_abs(input, ABS_X, tc->point_data[cid].x);
+        input_report_abs(input, ABS_Y, tc->point_data[cid].y);
+        input_sync(input);
+    }
+    if(tk->pendown != tk->status){
+        tk->pendown = tk->status;
+        input_report_key(input, BTN_TOUCH, tk->status);
+        input_sync(input);
+       
+    }
+}
+#endif
+
+static  void Synaptics_check_firmwork(struct tk_Synaptics *tk)
+{
+	int data=0;
+    short buf[6];
+	int i;
+	for (i = 0; i < sizeof(so340010_register_init_table)/sizeof(so340010_register_init_table[0]); i++) {		
+		if (Synaptics_touchkey_write(tk->client, so340010_register_init_table[i].address, &so340010_register_init_table[i].value, 1) < 0) {	
+				printk("[%s]: config touch key error\n",__FUNCTION__);	
+		}	
+		DBG("[%s]: config touch key i=%d\n",__FUNCTION__,i);	
+	}	
+	data = Synaptics_touchkey_read(tk->client,0x0901/*0x0109*/,buf,1);
+	if (data<0) {
+		printk( "error reading current\n");
+		return ;
+	}
+	DBG("Synaptics_read_values = %x\n",buf[0]);
+	
+	#if 0
+	for (i = 0; i < sizeof(so340010_register_init_table)/sizeof(so340010_register_init_table[0]); i++) {		
+		if (Synaptics_touchkey_read(tk->client, so340010_register_init_table[i].address, buf, 1) < 0) {	
+				printk("[%s]: read config  touch key error\n",__FUNCTION__);	
+		}	
+		printk("[-->%s]: buf[0]=%x\n",__FUNCTION__,buf[0]);
+	}
+	
+	if ( Synaptics_touchkey_read(tk->client, SO340010_REG_BUTTON_STATE, buf,1) < 0) 	
+		printk("[%s]: config touch key error\n",__FUNCTION__);	
+	
+	printk("[-->%s]: buf[0]=%x buf[1]=%x\n",__FUNCTION__,buf[0],buf[1]);
+	#endif
+}
+
+
+
+static inline int Synaptics_read_values(struct tk_Synaptics *tk)  ///, struct multitouch_event *tc)
+{
+	int data=0;
+	short buf;
+	int i;
+	data = Synaptics_touchkey_read(tk->client,0X0B01/*0x010b*/,&buf,1);
+	if (data<0) {
+		printk( "error reading current\n");
+		return 0;
+	}
+	DBG("Synaptics_read_values = %x\n",buf);
+	
+	data = Synaptics_touchkey_read(tk->client,0X0901/*0x0108*/,&buf,1);
+	if (data<0) {
+		printk( "error reading current\n");
+		return 0;
+	}
+	DBG("Synaptics_read_values = %x\n",buf);
+	buf = buf>>8;
+	if(buf == 0)
+		goto exit_ret;
+	for(i=0;i<SYN_340010_KEY_MAXNUM;i++){
+		if(buf == key_table[i].key_mask)
+			break;
+	}
+	tk->g_code = key_table[i].key_code;
+	input_report_key(tk->input, tk->g_code, 1);
+	input_sync(tk->input);
+	input_report_key(tk->input, tk->g_code, 0);
+	input_sync(tk->input);	
+exit_ret:	
+	if(!gpio_get_value(tk->gpio)){   	
+    	Synaptics_check_firmwork(tk);
+    }
+    return 10;
+    	
+}
+
+
+static void Synaptics_work(struct work_struct *work)
+{
+	struct tk_Synaptics *tk =
+		container_of(to_delayed_work(work), struct tk_Synaptics, work);
+	//struct multitouch_event *tc = &tk->mt_event;
+	DBG("Enter:%s %d\n",__FUNCTION__,__LINE__);
+	if(tk->init_flag == 1){
+		tk->init_flag = 0;
+		Synaptics_check_firmwork(tk);
+		return;	
+	}
+		
+	if( Synaptics_read_values(tk)<0)  //,tc)<0)
+	{
+		printk("-->%s Synaptics_read_values error  line=%d\n",__FUNCTION__,__LINE__);
+		goto out ;
+	}
+    	//Synaptics_report_event(tk,tc);
+out:               
+	//if (tk->pendown){
+	//	schedule_delayed_work(&tk->work, msecs_to_jiffies(8));
+	//	tk->pendown = 0;
+	//}
+	//else{
+		enable_irq(tk->irq);
+	//}
+
+}
+
+
+static irqreturn_t Synaptics_irq(int irq, void *handle)
+{
+	struct tk_Synaptics *tk = handle;
+	unsigned long flags;
+	DBG("Enter:%s %d\n",__FUNCTION__,__LINE__);
+	spin_lock_irqsave(&tk->lock,flags);
+	if (!tk->get_pendown_state || likely(tk->get_pendown_state())) {
+		disable_irq_nosync(tk->irq);
+		schedule_delayed_work(&tk->work,msecs_to_jiffies(20));
+	}
+	spin_unlock_irqrestore(&tk->lock,flags);
+	return IRQ_HANDLED;
+}
+
+static void Synaptics_free_irq(struct tk_Synaptics *tk)
+{
+	free_irq(tk->irq, tk);
+	if (cancel_delayed_work_sync(&tk->work)) {
+		/*
+		 * Work was pending, therefore we need to enable
+		 * IRQ here to balance the disable_irq() done in the
+		 * interrupt handler.
+		 */
+		enable_irq(tk->irq);
+	}
+}
+
+static int __devinit synaptics_touchkey_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	struct tk_Synaptics *tk;
+	struct synaptics_platform_data *pdata = pdata = client->dev.platform_data;
+	struct input_dev *input_dev;
+	int err,i;
+	//short reg,buff;	
+	if (!pdata) {
+		dev_err(&client->dev, "platform data is required!\n");
+		return -EINVAL;
+	}
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -EIO;
+	tk = kzalloc(sizeof(struct tk_Synaptics), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!tk || !input_dev) {
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+	tk->client = client;
+	tk->irq = client->irq;
+	tk->input = input_dev;
+	///tk->init_flag = 1;
+	//tk->wq = create_rt_workqueue("Synaptics_wq");
+	INIT_DELAYED_WORK(&tk->work, Synaptics_work);
+	snprintf(tk->phys, sizeof(tk->phys), "%s/input0", dev_name(&client->dev));
+	input_dev->name = "synaptics_touchkey";
+	input_dev->phys = tk->phys;
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->evbit[0] = BIT_MASK(EV_ABS)|BIT_MASK(EV_KEY)|BIT_MASK(EV_SYN);
+	set_bit(EV_KEY, input_dev->evbit);
+	for (i = 0; i < key_num; i++) {		
+		set_bit(key_table[i].key_code,input_dev->keybit);	
+	}
+	if (pdata->init_platform_hw)
+		pdata->init_platform_hw();
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_free_irq;
+	i2c_set_clientdata(client, tk);
+	
+	//reg = 0x3000;
+	//buff = 0x0001;
+	//Synaptics_touchkey_write(client,reg,&buff, 2);
+	//mdelay(500);
+	Synaptics_check_firmwork(tk);
+	///schedule_delayed_work(&tk->work,msecs_to_jiffies(8*1000));
+	tk->gpio = tk->irq;
+	if (!tk->irq) {
+		dev_dbg(&tk->client->dev, "no IRQ?\n");
+		return -ENODEV;
+	}else{
+		tk->irq = gpio_to_irq(tk->irq);
+	}
+	err = request_irq(tk->irq, Synaptics_irq, IRQF_TRIGGER_FALLING,client->dev.driver->name, tk);
+	if (err < 0) {
+		dev_err(&client->dev, "irq %d busy?\n", tk->irq);
+		goto err_free_mem;
+	}
+	if (err < 0)
+		goto err_free_irq;
+	return 0;
+ err_free_irq:
+	Synaptics_free_irq(tk);
+	if (pdata->exit_platform_hw)
+		pdata->exit_platform_hw();
+ err_free_mem:
+	input_free_device(input_dev);
+	kfree(tk);
+	return err;
+}
+
+static int __devexit Synaptics_remove(struct i2c_client *client)
+{
+	struct tk_Synaptics *tk = i2c_get_clientdata(client);
+	struct synaptics_platform_data *pdata = client->dev.platform_data;
+
+	Synaptics_free_irq(tk);
+
+	if (pdata->exit_platform_hw)
+		pdata->exit_platform_hw();
+
+	input_unregister_device(tk->input);
+	kfree(tk);
+
+	return 0;
+}
+
+static struct i2c_device_id synaptics_touchkey_idtable[] = {
+	{ "synaptics_touchkey", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, sintek_idtable);
+
+static struct i2c_driver synaptics_touchkey_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "synaptics_touchkey"
+	},
+	.id_table	= synaptics_touchkey_idtable,
+	.probe		= synaptics_touchkey_probe,
+	.remove		= __devexit_p(Synaptics_remove),
+};
+
+static void __init synaptics_touchkey_init_async(void *unused, async_cookie_t cookie)
+{
+	DBG("--------> %s <-------------\n",__func__);
+	i2c_add_driver(&synaptics_touchkey_driver);
+}
+
+static int __init synaptics_touchkey_init(void)
+{
+	async_schedule(synaptics_touchkey_init_async, NULL);
+	return 0;
+}
+
+static void __exit synaptics_touchkey_exit(void)
+{
+	return i2c_del_driver(&synaptics_touchkey_driver);
+}
+module_init(synaptics_touchkey_init);
+module_exit(synaptics_touchkey_exit);
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index db1b56378487..4d89856c9793 100755
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -603,6 +603,33 @@ config HANNSTAR_P1003
 		help
         	  RK29 hannstar touch debug
 
+config SINTEK_3FA16
+ 	 tristate "Sintek 3FA16  touchscreen"
+        depends on I2C2_RK29
+        help
+          RK29 Sintek touch
+
+        config HANNSTAR_MAX_X
+                int "Sintek touch x max"
+                depends on SINTEK_3FA16
+                default 1024
+                help
+                  RK29 hannstar touch max X size
+
+        config HANNSTAR_MAX_Y
+                int "Sintek touch Y max"
+                depends on SINTEK_3FA16
+                default 600
+                help
+                  RK29 hannstar touch max Y size
+
+
+        config HANNSTAR_DEBUG
+                bool "Sintek debug"
+                depends on SINTEK_3FA16
+                default n
+                help
+                  RK29 hannstar touch debug
 config EETI_EGALAX
         tristate "EETI_EGALAX touchscreen panel support"
         depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index e336151393eb..5ba46466857b 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -51,4 +51,5 @@ obj-$(CONFIG_TOUCHSCREEN_IT7250) += ctp_it7250.o
 obj-$(CONFIG_RK28_I2C_TS_NTP070)	+= ntp070.o
 obj-$(CONFIG_HANNSTAR_P1003)		+= hannstar_p1003.o
 obj-$(CONFIG_TOUCHSCREEN_IT7260)		+= it7260_ts.o
+obj-$(CONFIG_SINTEK_3FA16)	+=  sintek_3FA16.o
 obj-$(CONFIG_EETI_EGALAX)		+= eeti_egalax_i2c.o
diff --git a/drivers/input/touchscreen/malata.h b/drivers/input/touchscreen/malata.h
new file mode 100755
index 000000000000..0fb2a047f02e
--- /dev/null
+++ b/drivers/input/touchscreen/malata.h
@@ -0,0 +1,76 @@
+/*
+ *  "MALATA" Cypress touchscreen driver
+ *
+ *  Copyright (C) 2008 LocoLabs LLC
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+ #define VERSION_1
+#ifdef VERSION_1
+/* I2C slave address */
+#define MALATA_I2C_SLAVE_ADDR		0x5c
+
+/* I2C registers */
+#define MALATA_TOUCH_NUM			0x00
+#define MALATA_TOUCH_OLD_NUM			0x01
+#define MALATA_DATA_INFO			0x02
+#define MALATA_POS_X0_LO			0x02 	/* 16-bit register, MSB */
+#define MALATA_POS_X0_HI			0x03 	/* 16-bit register, LSB */
+#define MALATA_POS_Y0_LO			0x04 	/* 16-bit register, MSB */
+#define MALATA_POS_Y0_HI			0x05 	/* 16-bit register, LSB */
+#define MALATA_POS_X1_LO			0x06 	/* 16-bit register, MSB */
+#define MALATA_POS_X1_HI			0x07 	/* 16-bit register, LSB */
+#define MALATA_POS_Y1_LO			0x08 	/* 16-bit register, MSB */
+#define MALATA_POS_Y1_HI			0x09 	/* 16-bit register, LSB */
+#define MALATA_POS_PRESSURE			0x12
+#define MALATA_DATA_END				0x12
+#define MALATA_POWER_MODE			0x14
+#define MALATA_INT_MODE				0x15
+#define MALATA_SPECOP				0x37
+#define MALATA_EEPROM_READ			0x01
+#define MALATA_EEPROM_WRITE			0x02
+#define MALATA_EEPROM_READ_ADDR			0x38	/* 16-bit register */
+#define MALATA_RESOLUTION_X_LO			0x3d 	/* 8-bit register */
+#define MALATA_RESOLUTION_X_HI			0x01 	/* 8-bit register */
+#define MALATA_RESOLUTION_Y_LO			0x3f 	/* 8-bit register */
+#define MALATA_RESOLUTION_Y_HI			0x01 	/* 8-bit register */
+
+#else
+
+#define MALATA_I2C_SLAVE_ADDR		0x34
+
+/* I2C registers */
+#define MALATA_TOUCH-NUM			0x00
+#define MALATA_DATA_INFO			0x00
+#define MALATA_POS_X0_LO			0x03 	/* 16-bit register, MSB */
+#define MALATA_POS_X0_HI			0x04 	/* 16-bit register, LSB */
+#define MALATA_POS_Y0_LO			0x05 	/* 16-bit register, MSB */
+#define MALATA_POS_Y0_HI			0x06 	/* 16-bit register, LSB */
+#define MALATA_POS_X1_LO			0x09 	/* 16-bit register, MSB */
+#define MALATA_POS_X1_HI			0x0a 	/* 16-bit register, LSB */
+#define MALATA_POS_Y1_LO			0x0b 	/* 16-bit register, MSB */
+#define MALATA_POS_Y1_HI			0x0c 	/* 16-bit register, LSB */
+#define MALATA_DATA_END				0x0c
+
+#endif
+
+
+#define MALATA_IRQ_PERIOD		(26 * 1000000) /* ns delay between interrupts */
+
+struct malata_data {
+	struct i2c_client		*client;
+	struct workqueue_struct		*workq;
+	struct input_dev		*input;
+	struct hrtimer    		timer;
+	int				irq;
+	u32 				dx;
+	u32 				dy;
+	u32				width;
+	u16				x0;
+	u16				y0;
+	u16				x1;
+	u16				y1;
+	u8				z;
+};
diff --git a/drivers/input/touchscreen/sintek_3FA16.c b/drivers/input/touchscreen/sintek_3FA16.c
new file mode 100755
index 000000000000..50b34a2ce616
--- /dev/null
+++ b/drivers/input/touchscreen/sintek_3FA16.c
@@ -0,0 +1,514 @@
+/****************************************************************************************
+ * driver/input/touchscreen/hannstar_p1003.c
+ *Copyright 	:ROCKCHIP  Inc
+ *Author	: 	sfm
+ *Date		:  2010.2.5
+ *This driver use for rk28 chip extern touchscreen. Use i2c IF ,the chip is Hannstar
+ *description
+ ********************************************************************************************/
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/earlysuspend.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/async.h>
+#include <mach/gpio.h>
+#include <linux/irq.h>
+#include <mach/board.h>
+#include "malata.h"
+
+
+#define MAX_SUPPORT_POINT	2// //  4
+#define PACKGE_BUFLEN		10
+
+#if 0
+#define DBG(x...) printk(KERN_INFO x)
+#else
+#define DBG(x...) do { } while (0)
+#endif
+//#define Singltouch_Mode
+#define SAKURA_DBG                  0
+#if SAKURA_DBG 
+#define sakura_dbg_msg(fmt,...)       do {                                      \
+                                   printk("sakura dbg msg------>"                       \
+                                          " (func-->%s ; line-->%d) " fmt, __func__, __LINE__ , ##__VA_ARGS__); \
+                                  } while(0)
+#define sakura_dbg_report_key_msg(fmt,...)      do{                                                     \
+                                                    printk("sakura report " fmt,##__VA_ARGS__);          \
+                                                }while(0)
+#else
+#define sakura_dbg_msg(fmt,...)       do {} while(0)
+#define sakura_dbg_report_key_msg(fmt,...)      do{}while(0)
+#endif
+struct point_data {	
+	short status;	
+	short x;	
+	short y;
+    short z;
+};
+
+struct multitouch_event{
+	struct point_data point_data[MAX_SUPPORT_POINT];
+	int contactid;
+    int validtouch;
+};
+
+struct ts_p1003 {
+	struct input_dev	*input;
+	char			phys[32];
+	struct delayed_work	work;
+	struct workqueue_struct *wq;	
+	struct i2c_client	*client;
+    struct multitouch_event mt_event;
+	u16			model;
+	spinlock_t 	lock;
+	bool		pendown;
+	bool 	 	status;
+	int			irq;
+	int         delayed_work_tp;
+	int 		has_relative_report;
+	int			(*get_pendown_state)(void);
+	void		(*clear_penirq)(void);
+};
+
+int p1003_get_pendown_state(void)
+{
+	return 0;
+}
+
+static void p1003_report_event(struct ts_p1003 *ts,struct multitouch_event *tc)
+{
+	struct input_dev *input = ts->input;
+    int i,pandown = 0;
+	dev_dbg(&ts->client->dev, "UP\n");
+	DBG("Enter:%s %d\n",__FUNCTION__,__LINE__);	
+    for(i=0; i<MAX_SUPPORT_POINT;i++){			
+        if(tc->point_data[i].status >= 0){
+            pandown |= tc->point_data[i].status;
+            input_report_abs(input, ABS_MT_TRACKING_ID, i);							
+            input_report_abs(input, ABS_MT_TOUCH_MAJOR, tc->point_data[i].status);				
+            input_report_abs(input, ABS_MT_WIDTH_MAJOR, 0);	
+            input_report_abs(input, ABS_MT_POSITION_X, tc->point_data[i].x);				
+            input_report_abs(input, ABS_MT_POSITION_Y, tc->point_data[i].y);				
+            input_mt_sync(input);	
+
+            sakura_dbg_report_key_msg("ABS_MT_TRACKING_ID = %x, ABS_MT_TOUCH_MAJOR = %x\n ABS_MT_POSITION_X = %x, ABS_MT_POSITION_Y = %x\n",i,tc->point_data[i].status,tc->point_data[i].x,tc->point_data[i].y);
+#if defined(CONFIG_HANNSTAR_DEBUG)
+			//printk("hannstar p1003 Px = [%d],Py = [%d] \n",tc->point_data[i].x,tc->point_data[i].y);
+#endif
+
+            if(tc->point_data[i].status == 0)					
+            	tc->point_data[i].status--;			
+        }
+        
+    }	
+
+    ts->pendown = pandown;
+    input_sync(input);
+}
+
+#if defined (Singltouch_Mode)
+static void p1003_report_single_event(struct ts_p1003 *ts,struct multitouch_event *tc)
+{
+	struct input_dev *input = ts->input;
+    int cid;
+
+    cid = tc->contactid;
+    if (ts->status) {
+        input_report_abs(input, ABS_X, tc->point_data[cid].x);
+        input_report_abs(input, ABS_Y, tc->point_data[cid].y);
+        input_sync(input);
+    }
+    if(ts->pendown != ts->status){
+        ts->pendown = ts->status;
+        input_report_key(input, BTN_TOUCH, ts->status);
+        input_sync(input);
+        sakura_dbg_report_key_msg("%s x =0x%x,y = 0x%x \n",ts->status?"down":"up",tc->point_data[cid].x,tc->point_data[cid].y);
+    }
+}
+#endif
+
+static inline int p1003_check_firmwork(struct ts_p1003 *ts)
+{
+    int data;
+    char buf[10];
+	data = i2c_master_reg8_recv(ts->client, 26, buf, 6, 100*1000);
+	if(data < 0){
+		dev_err(&ts->client->dev, "i2c io error %d \n", data);
+		return data;
+	}
+	//printk("sintek reg[0] = %x ,reg[1] = %x, reg[2] = %x, reg[3] = %x\n" , buf[0],buf[1],buf[2],buf[3]);
+	//printk("sintek reg[4] = %x ,reg[5] = %x, reg[6] = %x, reg[7] = %x\n" , buf[4],buf[5],buf[6],buf[7]);
+	buf[0] = 0xa4; /*automatically jump sleep mode*/
+	//buf[0] =  0x0;
+	data = i2c_master_reg8_send(ts->client, MALATA_POWER_MODE, buf, 1, 100*1000);
+	if(data < 0){
+		printk("i2c io error %d line=%d\n", data,__LINE__);
+		return data;
+	}
+	buf[0] = 0x03;
+	data = i2c_master_reg8_send(ts->client, MALATA_SPECOP, buf, 1, 100*1000);
+	if(data < 0){
+		printk( "i2c io error %d line=%d\n", data,__LINE__);
+		return data;
+	}
+	#if 0
+	buf[0] = 0x80;
+	data = i2c_master_reg8_send(ts->client, MALATA_INT_MODE, buf, 1, 200*1000);
+	if(data < 0){
+		printk( "i2c io error %d line=%d\n", data,__LINE__);
+		return data;
+	}
+	#endif
+	data = i2c_master_reg8_recv(ts->client, MALATA_DATA_INFO, buf, 4, 100*1000);
+	if(data < 0){
+		printk( "i2c io error %d line=%d\n", data,__LINE__);
+		return data;
+	}
+	//printk("sintek reg[0] = %x ,reg[1] = %x, reg[2] = %x, reg[3] = %x\n" , buf[0],buf[1],buf[2],buf[3]);
+	//printk("sintek reg[4] = %x ,reg[5] = %x, reg[6] = %x, reg[7] = %x\n" , buf[4],buf[5],buf[6],buf[7]);
+    return data;
+}
+
+#define DATA_START	MALATA_DATA_INFO
+#define DATA_END	MALATA_DATA_END
+#define DATA_LEN	(DATA_END - DATA_START)
+#define DATA_OFF(x) ((x) - DATA_START)
+
+
+static inline int p1003_read_values(struct ts_p1003 *ts, struct multitouch_event *tc)
+{
+       int data=0;
+       char buf[10];
+	data = i2c_master_reg8_recv(ts->client, 0x00, buf, 10, 100*1000);
+	if(data < 0){
+		printk("-->%s i2c io error %d line=%d\n",__FUNCTION__, data,__LINE__);
+		return data;
+	}
+#if 0
+	if(buf[0]==0xff){
+		printk("MALATA_TOUCH_NUM is 0xff full\n");
+		return -1;
+	}
+#endif
+	///printk("MALATA_TOUCH_NUM = %x\n",buf[0]);
+	if(buf[0] == 1)
+	{
+		ts->pendown = 1;
+		tc->point_data[0].status = 1;
+		tc->point_data[1].status = 0;
+	}
+	else if (buf[0] == 2){
+		ts->pendown = 1;
+		tc->point_data[0].status = 1;
+		tc->point_data[1].status = 1;
+	}
+	else {
+		ts->pendown = 0;
+		tc->point_data[0].status = 0;
+		tc->point_data[1].status = 0;
+		//return 1;
+	}
+	//data = i2c_master_reg8_recv(ts->client, DATA_START, buf, DATA_LEN, 100*1000);
+	//if(data < 0){
+		//printk("-->%s i2c io error %d line=%d\n",__FUNCTION__, data,__LINE__);
+		//return data;
+	//}
+	tc->point_data[0].x = buf[DATA_OFF(MALATA_POS_X0_HI+2)] << 8;
+	tc->point_data[0].x |= buf[DATA_OFF(MALATA_POS_X0_LO+2)];
+	tc->point_data[0].y = buf[DATA_OFF(MALATA_POS_Y0_HI+2) ]<< 8;
+	tc->point_data[0].y |= buf[DATA_OFF(MALATA_POS_Y0_LO+2)];
+	tc->point_data[1].x = buf[DATA_OFF(MALATA_POS_X1_HI+2) ]<< 8;
+	tc->point_data[1].x |= buf[DATA_OFF(MALATA_POS_X1_LO+2)];
+	tc->point_data[1].y = buf[DATA_OFF(MALATA_POS_Y1_HI+2) ]<< 8;
+	tc->point_data[1].y |= buf[DATA_OFF(MALATA_POS_Y1_LO+2)];
+	//printk("sintek tc->point_data[0].x= %d tc->point_data[0].y=%d\n ",tc->point_data[0].x,tc->point_data[0].y);
+	//printk("sintek tc->point_data[1].x= %d tc->point_data[1].y=%d\n ",tc->point_data[1].x,tc->point_data[1].y);
+//	tc->point_data[0].status = 0;
+//	tc->point_data[1].status = 0;
+//	if (tc->point_data[0].x ||tc->point_data[0].y)
+//		tc->point_data[0].status = 1;
+//	if (tc->point_data[1].x ||tc->point_data[1].y)
+//		tc->point_data[1].status = 1;
+    return 10;
+}
+
+
+static void p1003_work(struct work_struct *work)
+{
+	struct ts_p1003 *ts =
+		container_of(to_delayed_work(work), struct ts_p1003, work);
+	struct multitouch_event *tc = &ts->mt_event;
+#if 0   
+   int data;
+    char buf[10];	
+	buf[0] = 0x03;
+	DBG("Enter:%s %d\n",__FUNCTION__,__LINE__);
+	if(ts->delayed_work_tp == 1){
+		data = i2c_master_reg8_send(ts->client, MALATA_SPECOP, buf, 1, 100*1000);
+		if(data < 0){
+			printk( "i2c io error %d line=%d\n", data,__LINE__);
+		}
+		ts->delayed_work_tp = 0;
+		return ;
+		}
+	#endif
+		if( p1003_read_values(ts,tc)<0)
+		{
+			printk("-->%s p1003_read_values error  line=%d\n",__FUNCTION__,__LINE__);
+			goto out ;
+		}
+
+#if defined (Singltouch_Mode)
+    p1003_report_single_event(ts,tc);
+#else
+    p1003_report_event(ts,tc);
+#endif
+
+out:               
+	if (ts->pendown){
+		schedule_delayed_work(&ts->work, msecs_to_jiffies(21));
+		ts->pendown = 0;
+	}
+	else{
+		enable_irq(ts->irq);
+	}
+
+}
+
+static irqreturn_t p1003_irq(int irq, void *handle)
+{
+	struct ts_p1003 *ts = handle;
+	unsigned long flags;
+	DBG("Enter:%s %d\n",__FUNCTION__,__LINE__);
+	
+	spin_lock_irqsave(&ts->lock,flags);
+	if (!ts->get_pendown_state || likely(ts->get_pendown_state())) {
+		disable_irq_nosync(ts->irq);
+		schedule_delayed_work(&ts->work,msecs_to_jiffies(2));
+	}
+	spin_unlock_irqrestore(&ts->lock,flags);
+	return IRQ_HANDLED;
+}
+
+static void p1003_free_irq(struct ts_p1003 *ts)
+{
+	free_irq(ts->irq, ts);
+	if (cancel_delayed_work_sync(&ts->work)) {
+		/*
+		 * Work was pending, therefore we need to enable
+		 * IRQ here to balance the disable_irq() done in the
+		 * interrupt handler.
+		 */
+		enable_irq(ts->irq);
+	}
+}
+
+static void Sintek_work_delay(struct work_struct *work)
+{
+	struct ts_p1003 *ts = container_of(to_delayed_work(work), struct ts_p1003, work);
+	int data;
+    char buf[10];	
+	buf[0] = 0x03;
+	data = i2c_master_reg8_send(ts->client, MALATA_SPECOP, buf, 1, 100*1000);
+	if(data < 0)
+		printk( "i2c io error %d line=%d\n", data,__LINE__);
+	return;
+}
+struct ts_p1003  *ts_pub;
+static ssize_t pc1003_touchdebug_show(struct device *dev,struct device_attribute *attr,char *_buf)
+{
+	// struct 	ts_p103 *ts  = dev_get_drvdata(dev);
+	 int data;
+   char buf[10];	
+	 buf[0] = 0x03;
+	 printk("Enter:%s %d\n",__FUNCTION__,__LINE__);
+	 printk("Touchscreen correct!!\n");
+	 data = i2c_master_reg8_send(ts_pub->client, MALATA_SPECOP, buf, 1, 100*1000);
+		 if(data < 0){
+			printk( "i2c io error %d line=%d\n", data,__LINE__);
+	 }
+	 return sprintf(_buf, "successful\n");
+}
+
+static DEVICE_ATTR(touchdebug, 0666, pc1003_touchdebug_show, NULL);
+
+static int __devinit sintek_touch_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	struct ts_p1003 *ts;
+	struct p1003_platform_data *pdata = pdata = client->dev.platform_data;
+	struct input_dev *input_dev;
+	int err;
+		printk(">--------%s\n",__FUNCTION__);
+	if (!pdata) {
+		dev_err(&client->dev, "platform data is required!\n");
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -EIO;
+
+	ts = kzalloc(sizeof(struct ts_p1003), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!ts || !input_dev) {
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	ts->client = client;
+	ts->irq = client->irq;
+	ts->input = input_dev;
+	ts->status =0 ;// fjp add by 2010-9-30
+	ts->pendown = 0; // fjp add by 2010-10-06
+	ts->delayed_work_tp = 0; ///1;
+	//ts->wq = create_rt_workqueue("p1003_wq");
+	INIT_DELAYED_WORK(&ts->work, p1003_work);
+
+	ts->model             = pdata->model;
+
+	snprintf(ts->phys, sizeof(ts->phys),
+		 "%s/input0", dev_name(&client->dev));
+
+	input_dev->name = "p1003 Touchscreen";
+	input_dev->phys = ts->phys;
+	input_dev->id.bustype = BUS_I2C;
+
+#if defined (Singltouch_Mode)
+	set_bit(EV_SYN, input_dev->evbit);
+	set_bit(EV_KEY, input_dev->evbit);
+	set_bit(BTN_TOUCH, input_dev->keybit);
+	set_bit(BTN_2, input_dev->keybit);
+	set_bit(EV_ABS, input_dev->evbit);
+	input_set_abs_params(input_dev,ABS_X,0,CONFIG_HANNSTAR_MAX_X,0,0);
+	input_set_abs_params(input_dev,ABS_Y,0,CONFIG_HANNSTAR_MAX_Y,0,0);
+#else
+	ts->has_relative_report = 0;
+	input_dev->evbit[0] = BIT_MASK(EV_ABS)|BIT_MASK(EV_KEY)|BIT_MASK(EV_SYN);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_dev->keybit[BIT_WORD(BTN_2)] = BIT_MASK(BTN_2); //jaocbchen for dual
+	input_set_abs_params(input_dev, ABS_X, 7, 1020/*CONFIG_HANNSTAR_MAX_X*/, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 10, 586/* CONFIG_HANNSTAR_MAX_Y*/, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_TOOL_WIDTH, 0, 15, 0, 0);
+	input_set_abs_params(input_dev, ABS_HAT0X, 7, 1020/*CONFIG_HANNSTAR_MAX_X*/, 0, 0);
+	input_set_abs_params(input_dev, ABS_HAT0Y, 10,586/* CONFIG_HANNSTAR_MAX_Y*/, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X,7, 1020/*CONFIG_HANNSTAR_MAX_X*/, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 10, 586/* CONFIG_HANNSTAR_MAX_Y*/, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TRACKING_ID, 0, 10, 0, 0);   
+#endif
+
+	if (pdata->init_platform_hw)
+		pdata->init_platform_hw();
+
+	
+#if 0
+	err = set_irq_type(ts->irq,IRQ_TYPE_LEVEL_LOW);
+	if (err < 0) {
+		dev_err(&client->dev, "irq %d busy?\n", ts->irq);
+		goto err_free_mem;
+	}
+	if (err < 0)
+		goto err_free_irq;
+#endif
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_free_irq;
+
+	i2c_set_clientdata(client, ts);
+
+	p1003_check_firmwork(ts);
+	//schedule_delayed_work(&ts->work, msecs_to_jiffies(8 * 1000));	
+	if (!ts->irq) {
+		dev_dbg(&ts->client->dev, "no IRQ?\n");
+		return -ENODEV;
+	}else{
+		ts->irq = gpio_to_irq(ts->irq);
+	}
+
+	err = request_irq(ts->irq, p1003_irq, IRQF_TRIGGER_LOW,
+			client->dev.driver->name, ts);
+	
+	if (err < 0) {
+		dev_err(&client->dev, "irq %d busy?\n", ts->irq);
+		goto err_free_mem;
+	}
+
+	
+	if (err < 0)
+		goto err_free_irq;
+	ts_pub = ts;
+	err = device_create_file(&ts->client->dev,&dev_attr_touchdebug);
+	if(err)
+		printk("%s->%d cannot create status attribute\n",__FUNCTION__,__LINE__);
+	return 0;
+
+ err_free_irq:
+	p1003_free_irq(ts);
+	if (pdata->exit_platform_hw)
+		pdata->exit_platform_hw();
+ err_free_mem:
+	input_free_device(input_dev);
+	kfree(ts);
+	return err;
+}
+
+static int __devexit p1003_remove(struct i2c_client *client)
+{
+	struct ts_p1003 *ts = i2c_get_clientdata(client);
+	struct p1003_platform_data *pdata = client->dev.platform_data;
+
+	p1003_free_irq(ts);
+
+	if (pdata->exit_platform_hw)
+		pdata->exit_platform_hw();
+
+	input_unregister_device(ts->input);
+	kfree(ts);
+
+	return 0;
+}
+
+static struct i2c_device_id sintek_idtable[] = {
+	{ "sintek_touch", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, sintek_idtable);
+
+static struct i2c_driver sintek_touch_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "sintek_touch"
+	},
+	.id_table	= sintek_idtable,
+	.probe		= sintek_touch_probe,
+	.remove		= __devexit_p(p1003_remove),
+};
+
+static void __init sintek_touch_init_async(void *unused, async_cookie_t cookie)
+{
+	printk("--------> %s <-------------\n",__func__);
+	i2c_add_driver(&sintek_touch_driver);
+}
+
+static int __init sintek_touch_init(void)
+{
+	async_schedule(sintek_touch_init_async, NULL);
+	return 0;
+}
+
+static void __exit sintek_touch_exit(void)
+{
+	return i2c_del_driver(&sintek_touch_driver);
+}
+module_init(sintek_touch_init);
+module_exit(sintek_touch_exit);
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 1d1932181db6..d53b66fdfc40 100755
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -895,6 +895,12 @@ config SOC_CAMERA_OV5642
 	depends on SOC_CAMERA && I2C
 	help
 	  This is a ov5642 camera driver	
+
+config SOC_CAMERA_S5K6AA
+	tristate "Samsung S5K6AA MIPI CSI-2 (importek mu736asa)"
+	depends on SOC_CAMERA && I2C
+	help
+	  This is a samsung S5K6AA mobile camera driver
 choice
 	prompt "OV5642 Module Focus select"
 	depends on SOC_CAMERA_OV5642
@@ -1076,7 +1082,6 @@ config USB_SE401
 	  module will be called se401.
 
 source "drivers/media/video/sn9c102/Kconfig"
-
 config USB_STV680
 	tristate "USB STV680 (Pencam) Camera support"
 	depends on VIDEO_V4L1
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 01e90112e541..df120ba2667d 100755
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -84,6 +84,7 @@ obj-$(CONFIG_SOC_CAMERA_OV2659)		+= ov2659.o
 obj-$(CONFIG_SOC_CAMERA_OV9650)		+= ov9650.o
 obj-$(CONFIG_SOC_CAMERA_OV3640)		+= ov3640.o
 obj-$(CONFIG_SOC_CAMERA_OV5642)		+= ov5642.o
+obj-$(CONFIG_SOC_CAMERA_S5K6AA)		+= s5k6aa.o
 
 # And now the v4l2 drivers:
 
diff --git a/drivers/media/video/s5k6aa.c b/drivers/media/video/s5k6aa.c
new file mode 100755
index 000000000000..b5d28123c613
--- /dev/null
+++ b/drivers/media/video/s5k6aa.c
@@ -0,0 +1,6363 @@
+/*
+ * Driver for OV5642 CMOS Image Sensor from OmniVision
+ *
+ * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/videodev2.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/log2.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/circ_buf.h>
+#include <linux/miscdevice.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/soc_camera.h>
+#include <mach/rk29_camera.h>
+#include <linux/delay.h>
+#include "s5k6aa.h"
+
+#define _CONS(a,b) a##b
+#define CONS(a,b) _CONS(a,b)
+
+#define __STR(x) #x
+#define _STR(x) __STR(x)
+#define STR(x) _STR(x)
+
+/* Sensor Driver Configuration */
+#define SENSOR_NAME s5k6aa
+#define SENSOR_V4L2_IDENT V4L2_IDENT_S5K66A
+#define SENSOR_ID 0x06aa
+#define SENSOR_MIN_WIDTH    640
+#define SENSOR_MIN_HEIGHT   480
+#define SENSOR_MAX_WIDTH    1280
+#define SENSOR_MAX_HEIGHT   1024
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_PIX_FMT_YUYV
+
+#define CONFIG_SENSOR_WhiteBalance	0
+#define CONFIG_SENSOR_Brightness	0
+#define CONFIG_SENSOR_Contrast      0
+#define CONFIG_SENSOR_Saturation    0
+#define CONFIG_SENSOR_Effect        0
+#define CONFIG_SENSOR_Scene         0
+#define CONFIG_SENSOR_DigitalZoom   0
+#define CONFIG_SENSOR_Focus         0
+#define CONFIG_SENSOR_Exposure      0
+#define CONFIG_SENSOR_Flash         0
+#define CONFIG_SENSOR_Mirror        0
+#define CONFIG_SENSOR_Flip          0
+
+#define CONFIG_SENSOR_I2C_SPEED     100000       /* Hz */
+
+#define CONFIG_SENSOR_TR      0
+#define CONFIG_SENSOR_DEBUG	  0
+
+#define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
+#define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)
+
+#define MIN(x,y)   ((x<y) ? x: y)
+#define MAX(x,y)    ((x>y) ? x: y)
+
+#if (CONFIG_SENSOR_TR)
+	#define SENSOR_TR(format, ...)      printk(format, ## __VA_ARGS__)
+#else
+	#define SENSOR_TR(format, ...)
+#endif
+
+#if (CONFIG_SENSOR_DEBUG)
+        #define SENSOR_DG(format, ...)      printk(format, ## __VA_ARGS__)
+#else
+        #define SENSOR_DG(format, ...)
+#endif
+
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_HIGH |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
+#define COLOR_TEMPERATURE_CLOUDY_DN  6500
+#define COLOR_TEMPERATURE_CLOUDY_UP    8000
+#define COLOR_TEMPERATURE_CLEARDAY_DN  5000
+#define COLOR_TEMPERATURE_CLEARDAY_UP    6500
+#define COLOR_TEMPERATURE_OFFICE_DN     3500
+#define COLOR_TEMPERATURE_OFFICE_UP     5000
+#define COLOR_TEMPERATURE_HOME_DN       2500
+#define COLOR_TEMPERATURE_HOME_UP       3500
+
+struct reginfo
+{
+    u16 reg;
+    u16 val;
+};
+
+/* init 640X480 SVGA */
+static struct reginfo sensor_init_data[] =
+{
+	{0xFCFC, 0xD000},  // change page to D000 page
+	{0x0010, 0x0001},  // Reset
+	{0x1030, 0x0000},  // Clear host interrupt so main will wait
+	{0x0014, 0x0001},  // ARM go
+	{SEQUENCE_WAIT_MS, 50},
+	{0x1000, 0x0001},
+	{SEQUENCE_WAIT_MS, 10},
+	{0x0028, 0x7000}, 	// start add MSW
+	{0x002A, 0x1d60}, 	// start add LSW
+	{0x0F12, 0xb570},
+	{0x0F12, 0x4928},
+	{0x0F12, 0x4828},
+	{0x0F12, 0x2205},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf922},
+	{0x0F12, 0x4927},
+	{0x0F12, 0x2002},
+	{0x0F12, 0x83c8},
+	{0x0F12, 0x2001},
+	{0x0F12, 0x3120},
+	{0x0F12, 0x8088},
+	{0x0F12, 0x4925},
+	{0x0F12, 0x4826},
+	{0x0F12, 0x2204},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf917},
+	{0x0F12, 0x4925},
+	{0x0F12, 0x4825},
+	{0x0F12, 0x2206},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf912},
+	{0x0F12, 0x4924},
+	{0x0F12, 0x4825},
+	{0x0F12, 0x2207},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf90d},
+	{0x0F12, 0x4924},
+	{0x0F12, 0x4824},
+	{0x0F12, 0x2208},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf908},
+	{0x0F12, 0x4923},
+	{0x0F12, 0x4824},
+	{0x0F12, 0x2209},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf903},
+	{0x0F12, 0x4923},
+	{0x0F12, 0x4823},
+	{0x0F12, 0x60c1},
+	{0x0F12, 0x6882},
+	{0x0F12, 0x1a51},
+	{0x0F12, 0x8201},
+	{0x0F12, 0x4c22},
+	{0x0F12, 0x2607},
+	{0x0F12, 0x6821},
+	{0x0F12, 0x0736},
+	{0x0F12, 0x42b1},
+	{0x0F12, 0xda05},
+	{0x0F12, 0x4820},
+	{0x0F12, 0x22d8},
+	{0x0F12, 0x1c05},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8fa},
+	{0x0F12, 0x6025},
+	{0x0F12, 0x68a1},
+	{0x0F12, 0x42b1},
+	{0x0F12, 0xda07},
+	{0x0F12, 0x481b},
+	{0x0F12, 0x2224},
+	{0x0F12, 0x3824},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8f1},
+	{0x0F12, 0x4819},
+	{0x0F12, 0x3824},
+	{0x0F12, 0x60a0},
+	{0x0F12, 0x4d18},
+	{0x0F12, 0x6d29},
+	{0x0F12, 0x42b1},
+	{0x0F12, 0xda07},
+	{0x0F12, 0x4815},
+	{0x0F12, 0x228f},
+	{0x0F12, 0x00d2},
+	{0x0F12, 0x30d8},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8e3},
+	{0x0F12, 0x652c},
+	{0x0F12, 0xbc70},
+	{0x0F12, 0xbc08},
+	{0x0F12, 0x4718},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1f53},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x127b},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0398},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x1e4d},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x890d},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1e73},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x27a9},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1e91},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x27c5},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1ef7},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x285f},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1eb3},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x28ff},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x206c},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x04ac},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x06cc},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x23a4},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0704},
+	{0x0F12, 0x7000},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0x484d},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8bb},
+	{0x0F12, 0x4a4d},
+	{0x0F12, 0x4b4d},
+	{0x0F12, 0x8811},
+	{0x0F12, 0x885b},
+	{0x0F12, 0x8852},
+	{0x0F12, 0x4359},
+	{0x0F12, 0x1889},
+	{0x0F12, 0x4288},
+	{0x0F12, 0xd800},
+	{0x0F12, 0x1c08},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xbc10},
+	{0x0F12, 0xbc08},
+	{0x0F12, 0x4718},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8b1},
+	{0x0F12, 0x4944},
+	{0x0F12, 0x8989},
+	{0x0F12, 0x4348},
+	{0x0F12, 0x0200},
+	{0x0F12, 0x0c00},
+	{0x0F12, 0x2101},
+	{0x0F12, 0x0349},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8b0},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7ed},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8b2},
+	{0x0F12, 0x6821},
+	{0x0F12, 0x0409},
+	{0x0F12, 0x0c09},
+	{0x0F12, 0x1a40},
+	{0x0F12, 0x493a},
+	{0x0F12, 0x6849},
+	{0x0F12, 0x4281},
+	{0x0F12, 0xd800},
+	{0x0F12, 0x1c08},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8af},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7dc},
+	{0x0F12, 0xb570},
+	{0x0F12, 0x6801},
+	{0x0F12, 0x040d},
+	{0x0F12, 0x0c2d},
+	{0x0F12, 0x6844},
+	{0x0F12, 0x4833},
+	{0x0F12, 0x8981},
+	{0x0F12, 0x1c28},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf893},
+	{0x0F12, 0x8060},
+	{0x0F12, 0x4932},
+	{0x0F12, 0x69c9},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8a6},
+	{0x0F12, 0x1c01},
+	{0x0F12, 0x80a0},
+	{0x0F12, 0x0228},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8a9},
+	{0x0F12, 0x0400},
+	{0x0F12, 0x0c00},
+	{0x0F12, 0x8020},
+	{0x0F12, 0x492d},
+	{0x0F12, 0x2300},
+	{0x0F12, 0x5ec9},
+	{0x0F12, 0x4288},
+	{0x0F12, 0xda02},
+	{0x0F12, 0x20ff},
+	{0x0F12, 0x3001},
+	{0x0F12, 0x8020},
+	{0x0F12, 0xbc70},
+	{0x0F12, 0xbc08},
+	{0x0F12, 0x4718},
+	{0x0F12, 0xb570},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0x4828},
+	{0x0F12, 0x4926},
+	{0x0F12, 0x7803},
+	{0x0F12, 0x6a8a},
+	{0x0F12, 0x2b00},
+	{0x0F12, 0xd100},
+	{0x0F12, 0x6a0a},
+	{0x0F12, 0x4d20},
+	{0x0F12, 0x2b00},
+	{0x0F12, 0x68a8},
+	{0x0F12, 0xd100},
+	{0x0F12, 0x6868},
+	{0x0F12, 0x6823},
+	{0x0F12, 0x8dc9},
+	{0x0F12, 0x434a},
+	{0x0F12, 0x0a12},
+	{0x0F12, 0x429a},
+	{0x0F12, 0xd30d},
+	{0x0F12, 0x4d20},
+	{0x0F12, 0x26ff},
+	{0x0F12, 0x8828},
+	{0x0F12, 0x3601},
+	{0x0F12, 0x43b0},
+	{0x0F12, 0x8028},
+	{0x0F12, 0x6820},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf884},
+	{0x0F12, 0x6020},
+	{0x0F12, 0x8828},
+	{0x0F12, 0x4330},
+	{0x0F12, 0x8028},
+	{0x0F12, 0xe7da},
+	{0x0F12, 0x1c0a},
+	{0x0F12, 0x4342},
+	{0x0F12, 0x0a12},
+	{0x0F12, 0x429a},
+	{0x0F12, 0xd304},
+	{0x0F12, 0x0218},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf871},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7f4},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7f2},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x4913},
+	{0x0F12, 0x8fc8},
+	{0x0F12, 0x2800},
+	{0x0F12, 0xd007},
+	{0x0F12, 0x2000},
+	{0x0F12, 0x87c8},
+	{0x0F12, 0x8f88},
+	{0x0F12, 0x4c11},
+	{0x0F12, 0x2800},
+	{0x0F12, 0xd002},
+	{0x0F12, 0x2008},
+	{0x0F12, 0x8020},
+	{0x0F12, 0xe77e},
+	{0x0F12, 0x480d},
+	{0x0F12, 0x3060},
+	{0x0F12, 0x8900},
+	{0x0F12, 0x2800},
+	{0x0F12, 0xd103},
+	{0x0F12, 0x480c},
+	{0x0F12, 0x2101},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf864},
+	{0x0F12, 0x2010},
+	{0x0F12, 0x8020},
+	{0x0F12, 0xe7f2},
+	{0x0F12, 0x0000},
+	{0x0F12, 0xf4b0},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x2058},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x1554},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0080},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x046c},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0468},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x1100},
+	{0x0F12, 0xd000},
+	{0x0F12, 0x01b8},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x044e},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0450},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x9ce7},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xf004},
+	{0x0F12, 0xe51f},
+	{0x0F12, 0x9fb8},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x88df},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x275d},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x1ed3},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x26f9},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x4027},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x9f03},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xf004},
+	{0x0F12, 0xe51f},
+	{0x0F12, 0xa144},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x285f},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x2001},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0xe848},
+	{0x0F12, 0x0001},
+	{0x0F12, 0xe848},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x0500},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x002A, 0x0e3a},  // #awbb_Alpha_Comp_Mode
+	{0x0F12, 0x02C2},
+	{0x002A, 0x112a},  //#senHal_SenRegsModes3_pSenModesRegsArray3[8]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1132},  //#senHal_SenRegsModes3_pSenModesRegsArray3[12]
+	{0x0F12, 0x0000},
+	{0x002A, 0x113e},  //#senHal_SenRegsModes3_pSenModesRegsArray3[18]
+	{0x0F12, 0x0000},
+	{0x002A, 0x115c},  //#senHal_SenRegsModes3_pSenModesRegsArray3[33]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1164},  //#senHal_SenRegsModes3_pSenModesRegsArray3[37]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1174},  //#senHal_SenRegsModes3_pSenModesRegsArray3[45]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1178},  //#senHal_SenRegsModes3_pSenModesRegsArray3[47]
+	{0x0F12, 0x0000},
+	{0x002A, 0x077a},  //#msm_uOffsetNoBin[0][0]
+	{0x0F12, 0x0000},  //#msm_uOffsetNoBin[0][1]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[1][0]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[1][1]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[2][0]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[2][1]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[3][0]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[3][1]
+	{0x0F12, 0x0000},
+	{0x002A, 0x07a2},  //#msm_sAnalogOffset[0]
+	{0x0F12, 0x0000}, 	 //#msm_sAnalogOffset[1]
+	{0x0F12, 0x0000}, 	 //#msm_sAnalogOffset[2]
+	{0x0F12, 0x0000}, 	 //#msm_sAnalogOffset[3]
+	{0x0F12, 0x0000},
+	{0x002A, 0x07b6},  //#msm_NonLinearOfsOutput[0]
+	{0x0F12, 0x0000}, 	 //#msm_NonLinearOfsOutput[1]
+	{0x0F12, 0x0002}, 	 //#msm_NonLinearOfsOutput[2]
+	{0x0F12, 0x0004}, 	 //#msm_NonLinearOfsOutput[3]
+	{0x0F12, 0x0004}, 	 //#msm_NonLinearOfsOutput[4]
+	{0x0F12, 0x0005}, 	 //#msm_NonLinearOfsOutput[5]
+	{0x0F12, 0x0005},
+	{0x002A, 0x0712},
+	{0x0F12, 0x0149},
+	{0x0F12, 0x011B},
+	{0x0F12, 0x0120},
+	{0x0F12, 0x00EF},
+	{0x0F12, 0x00C3},
+	{0x0F12, 0x00D2},
+	{0x0F12, 0x00DC},
+	{0x0F12, 0x00B8},
+	{0x0F12, 0x0106},
+	{0x0F12, 0x00DE},
+	{0x0F12, 0x00E3},
+	{0x0F12, 0x00CC},
+	{0x0F12, 0x00BD},
+	{0x0F12, 0x00E1},
+	{0x0F12, 0x00D8},
+	{0x0F12, 0x00D0},
+	{0x0F12, 0x00BE},
+	{0x0F12, 0x00EC},
+	{0x0F12, 0x00EA},
+	{0x0F12, 0x00F2},
+	{0x0F12, 0x00BE},
+	{0x0F12, 0x00EB},
+	{0x0F12, 0x00E5},
+	{0x0F12, 0x00F9},
+	{0x0F12, 0x0100},  //0x00BE
+	{0x0F12, 0x00D5},
+	{0x0F12, 0x00D8},
+	{0x0F12, 0x00E6},
+	{0x0F12, 0x00FD},
+	{0x0F12, 0x00F7},
+	{0x0F12, 0x00F3},
+	{0x0F12, 0x00FF},
+	{0x002A, 0x075A},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x02A1},
+	{0x0F12, 0x0225},
+	{0x0F12, 0x000D},
+	{0x0F12, 0x000D},
+	{0x0028, 0x7000},
+	{0x002A, 0x04C8}, //	GammaLutRGBIndoor
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x0015},
+	{0x0F12, 0x0034},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x00ED},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0201},
+	{0x0F12, 0x0276},
+	{0x0F12, 0x0307},
+	{0x0F12, 0x0362},
+	{0x0F12, 0x03A9},
+	{0x0F12, 0x03D5},
+	{0x0F12, 0x03F4},
+	{0x0F12, 0x03FF},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x0015},
+	{0x0F12, 0x0034},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x00ED},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0201},
+	{0x0F12, 0x0276},
+	{0x0F12, 0x0307},
+	{0x0F12, 0x0362},
+	{0x0F12, 0x03A9},
+	{0x0F12, 0x03D5},
+	{0x0F12, 0x03F4},
+	{0x0F12, 0x03FF},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x0015},
+	{0x0F12, 0x0034},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x00ED},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0201},
+	{0x0F12, 0x0276},
+	{0x0F12, 0x0307},
+	{0x0F12, 0x0362},
+	{0x0F12, 0x03A9},
+	{0x0F12, 0x03D5},
+	{0x0F12, 0x03F4},
+	{0x0F12, 0x03FF},
+	{0x002A, 0x1000},	//	param_end	SARR_usGammaLutRGBIndoor
+	{0x0F12, 0x0036},
+	{0x002A, 0x108E},   // SAAR_IllumType
+	{0x0F12, 0x00C0},
+	{0x0F12, 0x00E7},
+	{0x0F12, 0x00F9},
+	{0x0F12, 0x0142},
+	{0x0F12, 0x0179},
+	{0x0F12, 0x01A4},
+	{0x0F12, 0x01B8},   //SAAR_IllumF
+	{0x0F12, 0x0112},
+	{0x0F12, 0x0122},
+	{0x0F12, 0x0136},
+	{0x0F12, 0x00F6},
+	{0x0F12, 0x0100},
+	{0x0F12, 0x00FE},
+	{0x0F12, 0x0100},
+	{0x002A, 0x1AC8},
+	{0x0F12, 0x0000},   //	param_start	TVAR_wbt_pBaseCcms
+	{0x002A, 0x23A4},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F}, //	param_end	TVAR_wbt_pBaseCcms
+	{0x002A, 0x2380}, //	param_start	TVAR_wbt_pOutdoorCcm
+	{0x0F12, 0x01AF},
+	{0x0F12, 0xFFD5},
+	{0x0F12, 0x001D},
+	{0x0F12, 0x0080},
+	{0x0F12, 0x00BA},
+	{0x0F12, 0xFF61},
+	{0x0F12, 0xFF21},
+	{0x0F12, 0x0164},
+	{0x0F12, 0xFF96},
+	{0x0F12, 0xFF0F},
+	{0x0F12, 0x019A},
+	{0x0F12, 0x0117},
+	{0x0F12, 0xFFE8},
+	{0x0F12, 0x0041},
+	{0x0F12, 0x01C8},
+	{0x0F12, 0x0173},
+	{0x0F12, 0xFF35},
+	{0x0F12, 0x013C},   //	param_end	TVAR_wbt_pOutdoorCcm
+	{0x002A, 0x06DA},
+	{0x0F12, 0x00BF},
+	{0x0F12, 0x00E6},
+	{0x0F12, 0x00F2},
+	{0x0F12, 0x0143},
+	{0x0F12, 0x0178},
+	{0x0F12, 0x01A3},  //	param_start	SARR_uNormBrInDoor
+	{0x002A, 0x07E8},
+	{0x0F12, 0x000A},
+	{0x0F12, 0x0019},
+	{0x0F12, 0x007D},
+	{0x0F12, 0x01F4},
+	{0x0F12, 0x1388},
+#if 0//renn
+	{0x002A, 0x07D0},
+	{0x0F12, 0x0030},
+	{0x0F12, 0x0046},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x0205},
+	{0x0F12, 0x02BC},
+	{0x002A, 0x07E6},
+	{0x0F12, 0x0001},
+	{0x002A, 0x0828},
+	{0x0F12, 0x000B},        //TVAR_afit_pBaseVals[0]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[1]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[2]
+	{0x0F12, 0xFFAA}, 	 //TVAR_afit_pBaseVals[3]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[4]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[5]
+	{0x0F12, 0x0032}, 	 //TVAR_afit_pBaseVals[6]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[7]
+	{0x0F12, 0x00FF}, 	 //TVAR_afit_pBaseVals[8]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[9]
+	{0x0F12, 0x0004}, 	 //TVAR_afit_pBaseVals[10]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[11]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[12]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[13]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[14]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[15]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[16]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[17]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[18]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[19]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[20]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[21]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[22]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[23]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[24]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[25]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[26]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[27]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[28]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[29]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[30]
+	{0x0F12, 0x054C}, 	 //TVAR_afit_pBaseVals[31]
+	{0x0F12, 0x0A4C}, 	 //TVAR_afit_pBaseVals[32]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[33]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[34]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[35]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[36]
+	{0x0F12, 0x2828}, 	 //TVAR_afit_pBaseVals[37]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[38]
+	{0x0F12, 0x0230}, 	 //TVAR_afit_pBaseVals[39]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[40]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[41]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[42]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[43]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[44]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[45]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[46]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[47]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[48]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[49]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[50]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[51]
+	{0x0F12, 0x0400}, 	 //TVAR_afit_pBaseVals[52]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[53]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[54]
+	{0x0F12, 0x0A00}, 	 //TVAR_afit_pBaseVals[55]
+	{0x0F12, 0x100A}, 	 //TVAR_afit_pBaseVals[56]
+	{0x0F12, 0x0150}, 	 //TVAR_afit_pBaseVals[57]
+	{0x0F12, 0x0130}, 	 //TVAR_afit_pBaseVals[58]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[59]
+	{0x0F12, 0x8032},   //805A	 //TVAR_afit_pBaseVals[60]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[61]
+	{0x0F12, 0x001C}, 	 //TVAR_afit_pBaseVals[62]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[63]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[64]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[65]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[66]
+	{0x0F12, 0x000C}, 	 //TVAR_afit_pBaseVals[67]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[68]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[69]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[70]
+	{0x0F12, 0x00A0}, 	 //TVAR_afit_pBaseVals[71]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[72]
+	{0x0F12, 0x0004}, 	 //TVAR_afit_pBaseVals[73]
+	{0x0F12, 0x0012}, 	 //TVAR_afit_pBaseVals[74]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[75]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[76]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[77]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[78]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[79]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[80]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[81]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[82]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[83]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[84]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[85]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[86]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[87]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[88]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[89]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[90]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[91]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[92]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[93]
+	{0x0F12, 0x053D}, 	 //TVAR_afit_pBaseVals[94]
+	{0x0F12, 0x0A3D}, 	 //TVAR_afit_pBaseVals[95]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[96]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[97]
+	{0x0F12, 0x0C23}, 	 //TVAR_afit_pBaseVals[98]
+	{0x0F12, 0x230C}, 	 //TVAR_afit_pBaseVals[99]
+	{0x0F12, 0x1919}, 	 //TVAR_afit_pBaseVals[100]
+	{0x0F12, 0x0303}, 	 //TVAR_afit_pBaseVals[101]
+	{0x0F12, 0x0220}, 	 //TVAR_afit_pBaseVals[102]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[103]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[104]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[105]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[106]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[107]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[108]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[109]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[110]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[111]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[112]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[113]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[114]
+	{0x0F12, 0x0400}, 	 //TVAR_afit_pBaseVals[115]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[116]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[117]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[118]
+	{0x0F12, 0x1008}, 	 //TVAR_afit_pBaseVals[119]
+	{0x0F12, 0x0160}, 	 //TVAR_afit_pBaseVals[120]
+	{0x0F12, 0x0150}, 	 //TVAR_afit_pBaseVals[121]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[122]
+	{0x0F12, 0x803C},   //8064	 //TVAR_afit_pBaseVals[123]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[124]
+	{0x0F12, 0x0016}, 	 //TVAR_afit_pBaseVals[125]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[126]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[127]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[128]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[129]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[130]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[131]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[132]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[133]
+	{0x0F12, 0x0050}, 	 //TVAR_afit_pBaseVals[134]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[135]
+	{0x0F12, 0x0003}, 	 //TVAR_afit_pBaseVals[136]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[137]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[138]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[139]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[140]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[141]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[142]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[143]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[144]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[145]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[146]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[147]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[148]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[149]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[150]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[151]  {0x0010, 0x0001},
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[152]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[153]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[154]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[155]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[156]
+	{0x0F12, 0x050A}, 	 //TVAR_afit_pBaseVals[157]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[158]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[159]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[160]
+	{0x0F12, 0x1946}, 	 //TVAR_afit_pBaseVals[161]
+	{0x0F12, 0x4619}, 	 //TVAR_afit_pBaseVals[162]
+	{0x0F12, 0x0F0F}, 	 //TVAR_afit_pBaseVals[163]
+	{0x0F12, 0x0606}, 	 //TVAR_afit_pBaseVals[164]
+	{0x0F12, 0x020F}, 	 //TVAR_afit_pBaseVals[165]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[166]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[167]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[168]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[169]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[170]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[171]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[172]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[173]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[174]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[175]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[176]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[177]
+	{0x0F12, 0x0404}, 	 //TVAR_afit_pBaseVals[178]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[179]
+	{0x0F12, 0x0402}, 	 //TVAR_afit_pBaseVals[180]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[181]
+	{0x0F12, 0x1006}, 	 //TVAR_afit_pBaseVals[182]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[183]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[184]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[185]
+	{0x0F12, 0x8046},  //0x8067	 //TVAR_afit_pBaseVals[186]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[187]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[188]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[189]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[190]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[191]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[192]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[193]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[194]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[195]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[196]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[197]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[198]
+	{0x0F12, 0x0003}, 	 //TVAR_afit_pBaseVals[199]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[200]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[201]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[202]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[203]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[204]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[205]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[206]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[207]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[208]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[209]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[210]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[211]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[212]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[213]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[214]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[215]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[216]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[217]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[218]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[219]
+	{0x0F12, 0x0505}, 	 //TVAR_afit_pBaseVals[220]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[221]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[222]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[223]
+	{0x0F12, 0x1946}, 	 //TVAR_afit_pBaseVals[224]
+	{0x0F12, 0x4619}, 	 //TVAR_afit_pBaseVals[225]
+	{0x0F12, 0x0F0F}, 	 //TVAR_afit_pBaseVals[226]
+	{0x0F12, 0x0606}, 	 //TVAR_afit_pBaseVals[227]
+	{0x0F12, 0x020F}, 	 //TVAR_afit_pBaseVals[228]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[229]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[230]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[231]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[232]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[233]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[234]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[235]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[236]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[237]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[238]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[239]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[240]
+	{0x0F12, 0x0404}, 	 //TVAR_afit_pBaseVals[241]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[242]
+	{0x0F12, 0x0402}, 	 //TVAR_afit_pBaseVals[243]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[244]
+	{0x0F12, 0x1006}, 	 //TVAR_afit_pBaseVals[245]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[246]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[247]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[248]
+	{0x0F12, 0x8046}, 	  //0x806B	 //TVAR_afit_pBaseVals[249]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[250]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[251]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[252]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[253]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[254]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[255]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[256]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[257]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[258]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[259]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[260]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[261]
+	{0x0F12, 0x0003}, 	 //TVAR_afit_pBaseVals[262]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[263]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[264]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[265]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[266]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[267]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[268]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[269]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[270]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[271]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[272]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[273]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[274]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[275]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[276]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[277]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[278]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[279]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[280]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[281]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[282]
+	{0x0F12, 0x0505}, 	 //TVAR_afit_pBaseVals[283]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[284]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[285]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[286]
+	{0x0F12, 0x1946}, 	 //TVAR_afit_pBaseVals[287]
+	{0x0F12, 0x4619}, 	 //TVAR_afit_pBaseVals[288]
+	{0x0F12, 0x0F0F}, 	 //TVAR_afit_pBaseVals[289]
+	{0x0F12, 0x0606}, 	 //TVAR_afit_pBaseVals[290]
+	{0x0F12, 0x020F}, 	 //TVAR_afit_pBaseVals[291]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[292]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[293]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[294]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[295]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[296]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[297]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[298]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[299]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[300]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[301]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[302]
+	{0x0F12, 0x0303}, 	 //TVAR_afit_pBaseVals[303]
+	{0x0F12, 0x0707}, 	 //TVAR_afit_pBaseVals[304]
+	{0x0F12, 0x0303}, 	 //TVAR_afit_pBaseVals[305]
+	{0x0F12, 0x0806}, 	 //TVAR_afit_pBaseVals[306]
+	{0x0F12, 0x0004}, 	 //TVAR_afit_pBaseVals[307]
+	{0x0F12, 0x1006}, 	 //TVAR_afit_pBaseVals[308]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[309]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[310]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[311]
+	{0x0F12, 0x8046},    //0x806B //TVAR_afit_pBaseVals[312]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[313]
+	{0x0F12, 0x0000},      ////TVAR_afit_pBaseVals[314]  	param_end	TVAR_afit_pBaseVals
+	{0x0F12, 0x03FC},
+	{0x0F12, 0x03FF},
+	{0x0F12, 0x0500},
+	{0x0F12, 0x0400},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0300},
+	{0x0F12, 0x0002},
+	{0x0F12, 0x0300},
+	{0x0F12, 0x0203},
+	{0x0F12, 0x0003},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0204},
+	{0x0F12, 0x0000},
+	{0x0F12, 0xFDD6},
+	{0x0F12, 0x43C1},
+	{0x0F12, 0xF0FA},
+	{0x0F12, 0x0001},  //	param_end	afit_pConstBaseVals
+	{0x002A, 0x06d4},  //#TVAR_wbt_pOutdoorCcm
+	{0x0F12, 0x2380},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06cc},  //#TVAR_wbt_pBaseCcms
+	{0x0F12, 0x23A4},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06e8},  //#TVAR_wbt_pBaseCcmsAddr[0]
+	{0x0F12, 0x23A4},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06EC},  //#TVAR_wbt_pBaseCcmsAddr[1]
+	{0x0F12, 0x23C8},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06f0},  //#TVAR_wbt_pBaseCcmsAddr[2]
+	{0x0F12, 0x23EC},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06f4},  //#TVAR_wbt_pBaseCcmsAddr[3]
+	{0x0F12, 0x2410},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06f8},  //#TVAR_wbt_pBaseCcmsAddr[4]
+	{0x0F12, 0x2434},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06fc},  //#TVAR_wbt_pBaseCcmsAddr[5]
+	{0x0F12, 0x2458},
+	{0x0F12, 0x7000},  // End tuning part
+#endif
+
+	{0x0028, 0x7000},
+	{0x002A, 0x0400},  //50h2
+	{0x0F12, 0x005f},
+	{0x002A, 0x03dc},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x0001},
+	{0x0028, 0xd000}, 	//add current
+	{0x002A, 0x1082},
+	{0x0F12, 0x03ff},
+	{0x0F12, 0x03ff},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0fff},
+	{0xFCFC, 0x7000},
+	{0x0488, 0x1A04},
+	{0x048C, 0x56B8},
+	{0x0498, 0x0500},
+	{0x049A, 0x0500},
+	{0x049C, 0x0200},
+	{0x1000, 0x0043},
+	{0x0400, 0x007F},
+	{0x01B8, 0x4e20},
+	{0x01BA, 0x0000},
+	{0x01C6, 0x0001},
+	{0x01CC, 0x1388},
+	{0x01CE, 0x1388},
+	{0x01D0, 0x1388},
+	{0x01E0, 0x0001},
+	//PREVIEW CONFIGURATION 0
+	{0x0242, 0x0280},  // 640
+	{0x0244, 0x01e0},  // 480
+	{0x0246, 0x0005},  // FULL YUV 422
+	{0x024E, 0x0000},  // Use 1st system clock(0x01CC 01CE 01D0)
+	{0x0248, 0x1388},  // Max output rate, divided by 4 (12MHz)0bb8
+	{0x024A, 0x1388},  // Min output rate, divided by 4 (3MHz)
+	{0x024C, 0x0042},  // PVI configuration by default
+	{0x0252, 0x0001},  // Frame rate quality
+	{0x0250, 0x0000},  // Frame rate type
+	{0x0254, 0x029a},  // Required frame time ???
+	{0x0256, 0x01b0},  // Minimal frame time for dynamic FR
+	{0x0262, 0x0001},  //mirror
+	{0x0264, 0x0001},  //mirror
+	//previer run
+	{0x021C, 0x0000},  // Index number of active preview configuration
+	{0x0220, 0x0001},  // Output is enabled after configuration change
+	{0x01F8, 0x0001},  // Start sending a new configuration
+	{0x021E, 0x0001},  // Synchronize FW with new preview configuration
+	{0x01F0, 0x0001},  // Enable preview output
+	{0x01F2, 0x0001},  // Synchronize FW with enable preview request
+	//capture CONFIGURATION 0
+	{0x030c, 0x0000},   //1280 1024
+	{0x030e, 0x0500},
+	{0x0310, 0x0400},
+	{0x0312, 0x0005},
+	{0x0314, 0x1388},
+	{0x0316, 0x1388},
+	{0x0318, 0x0042},
+	{0x031a, 0x0000},
+	{0x031c, 0x0000},//timetype
+	{0x031e, 0x0002},
+	{0x0320, 0x07d0},
+	{0x0322, 0x03e8},
+	//input config
+	{0x020A, 0x0500},  // Preview zoom window width
+	{0x020C, 0x0400},  // Preview zoom window heigh
+	{0x01FA, 0x0500},  // Preview window width
+	{0x01FC, 0x0400},  // Preview window heigh
+	{0x01FE, 0x0000},  // Preview input window X offset
+	{0x0200, 0x0000},  // Preview input window Y offset
+	{0x021A, 0x0001},  // Synchronize FW with input values
+
+	//Capture-B
+	 {SEQUENCE_FAST_SETMODE_START, 0},
+	 {0xFCFC, 0x7000},
+	{0x021C, 0x0000},  // Index number of active preview configuration
+	{0x0220, 0x0001},  // Output is enabled after configuration change
+	{0x01F8, 0x0001},  // Start sending a new configuration
+	{0x021E, 0x0001},  // Synchronize FW with new preview configuration
+
+	{SEQUENCE_WAIT_MS, 1000},
+	{SEQUENCE_WAIT_MS, 500},   //ledebug
+	{SEQUENCE_END, 0x00}
+};
+
+/* 1600X1200 UXGA */
+static struct reginfo sensor_uxga[] =
+{
+	{SEQUENCE_END,0x00}
+};
+
+/* 1280X1024 SXGA */
+static struct reginfo sensor_sxga[] =
+{
+	/*
+	    {0xFCFC, 0xD000}, // change page to D000 page
+	    {0x0010, 0x0001}, // Reset
+	    {0x1030, 0x0000}, // Clear host interrupt so main will wait
+	    {0x0014, 0x0001}, // ARM go
+	    {SEQUENCE_WAIT_MS, 100},
+	    {0x1000, 0x0001}, // Set host interrupt so main start run
+	    {SEQUENCE_WAIT_MS, 10},
+
+	//clk Settings
+	    {0xFCFC, 0x7000}, // change page to 7000 page
+	    {0x01B8, 0x2EE0}, // 12M, Input clock (lower 16 bits)
+	    {0x01BA, 0x0000}, // 12M, Input clock (upper 16 bits)
+	    {0x01C6, 0x0001}, // We need 1 PVI set of system/output clock
+	    {0x01C8, 0x0000}, // We don't need MIPI configuration
+	    {0x01CC, 0x0BB8}, // 1st system clock, div by 4
+	    {0x01CE, 0x02EE}, // 1st system clock minimal output freq.
+	    {0x01D0, 0x0BB8}, // 1st system clock maximal output freq.
+	    {0x01E0, 0x0001}, // FW update and initialization
+	    {SEQUENCE_WAIT_MS, 100},
+
+	//PREVIEW CONFIGURATION 0
+	    {0x0242, 0x0500}, // 1280
+	    {0x0244, 0x02D0}, // 720
+	    {0x0246, 0x0005}, // FULL YUV 422
+	    {0x024E, 0x0000}, // Use 1st system clock(0x01CC, 0x01CE, 0x01D0)
+	    {0x0248, 0x0BB8}, // Max output rate, divided by 4 (12MHz)
+	    {0x024A, 0x02EE}, // Min output rate, divided by 4 (3MHz)
+	    {0x024C, 0x0042}, // PVI configuration by default
+	    {0x0252, 0x0000}, // Frame rate quality
+	    {0x0250, 0x0000}, // Frame rate type
+	    {0x0254, 0x00D0}, // Required frame time ???
+	    {0x0256, 0x0000}, // Minimal frame time for dynamic FR
+
+	//PREVIEW
+	    {0x021C, 0x0000}, // Index number of active preview configuration
+	    {0x0220, 0x0001}, // Output is enabled after configuration change
+	    {0x01F8, 0x0001}, // Start sending a new configuration
+	    {0x021E, 0x0001}, // Synchronize FW with new preview configuration
+	    {SEQUENCE_WAIT_MS, 100},
+	    {0x01F0, 0x0001}, // Enable preview output
+	    {0x01F2, 0x0001}, // Synchronize FW with enable preview request
+	    {SEQUENCE_WAIT_MS, 100},
+
+	// change InPut
+	    {0x020A, 0x0500}, // Preview zoom window width
+	    {0x020C, 0x02D0}, // Preview zoom window heigh
+	    {0x01FA, 0x0500}, // Preview window width
+	    {0x01FC, 0x02D0}, // Preview window heigh
+	    {0x01FE, 0x0000}, // Preview input window X offset
+	    {0x0200, 0x0000}, // Preview input window Y offset
+	    {0x021A, 0x0001}, // Synchronize FW with input values
+
+	    {SEQUENCE_WAIT_MS, 1000},
+	    {SEQUENCE_END, 0x00}
+	*/
+#if	0
+	{0xFCFC, 0xD000},  // change page to D000 page
+	{0x0010, 0x0001},  // Reset
+	{0x1030, 0x0000},  // Clear host interrupt so main will wait
+	{0x0014, 0x0001},  // ARM go
+	{SEQUENCE_WAIT_MS, 100},
+	{0x1000, 0x0001},
+	{SEQUENCE_WAIT_MS, 10},
+	{0xFCFC, 0x7000},
+	{0x0488, 0x1A04},
+	{0x048C, 0x56B8},
+	{0x0498, 0x0500},
+	{0x049A, 0x0500},
+	{0x049C, 0x0200},
+	{0x1000, 0x0050},
+	{0x0400, 0x007F},
+	{0x01B8, 0x2EE0},
+	{0x01BA, 0x0000},
+	{0x01C6, 0x0001},
+	{0x01CC, 0x0bb8},
+	{0x01CE, 0x0bb8},
+	{0x01D0, 0x0bb8},
+	{0x01E0, 0x0001},
+	//PREVIEW CONFIGURATION 0
+	//{0x0242, 0x0500},  // 1280
+	//{0x0244, 0x02D0},  // 720
+	{0x0242, 0x0500},  // 1280
+	{0x0244, 0x02D0},  // 720
+	{0x0246, 0x0005},  // FULL YUV 422
+	{0x024E, 0x0000},  // Use 1st system clock(0x01CC 01CE 01D0)
+	{0x0248, 0x0bb8},  // Max output rate, divided by 4 (12MHz)
+	{0x024A, 0x0bb8},  // Min output rate, divided by 4 (3MHz)
+	{0x024C, 0x0042},  // PVI configuration by default
+	{0x0252, 0x0002},  // Frame rate quality
+	{0x0250, 0x0000},  // Frame rate type
+	{0x0254, 0x09c4},  // Required frame time ???
+	{0x0256, 0x0000},  // Minimal frame time for dynamic FR
+	//previer run
+	{0x021C, 0x0000},  // Index number of active preview configuration
+	{0x0220, 0x0001},  // Output is enabled after configuration change
+	{0x01F8, 0x0001},  // Start sending a new configuration
+	{0x021E, 0x0001},  // Synchronize FW with new preview configuration
+	{0x01F0, 0x0001},  // Enable preview output
+	{0x01F2, 0x0001},  // Synchronize FW with enable preview request
+	//input config
+	{0x020A, 0x0500},  // Preview zoom window width
+	{0x020C, 0x02D0},  // Preview zoom window heigh
+	{0x01FA, 0x0500},  // Preview window width
+	{0x01FC, 0x02D0},  // Preview window heigh
+	{0x01FE, 0x0000},  // Preview input window X offset
+	{0x0200, 0x0000},  // Preview input window Y offset
+	{0x021A, 0x0001},  // Synchronize FW with input values
+	    {SEQUENCE_WAIT_MS, 50},   //ledebug
+	    {SEQUENCE_END, 0x00}
+#endif //renn
+	{0xFCFC, 0xD000},  // change page to D000 page
+	{0x0010, 0x0001},  // Reset
+	{0x1030, 0x0000},  // Clear host interrupt so main will wait
+	{0x0014, 0x0001},  // ARM go
+	{SEQUENCE_WAIT_MS, 100},
+	{0x1000, 0x0001},
+	{SEQUENCE_WAIT_MS, 10},
+#if 0    //  dsp process
+	{0x0028, 0x7000}, 	// start add MSW
+	{0x002A, 0x1d60}, 	// start add LSW
+	{0x0F12, 0xb570},
+	{0x0F12, 0x4928},
+	{0x0F12, 0x4828},
+	{0x0F12, 0x2205},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf922},
+	{0x0F12, 0x4927},
+	{0x0F12, 0x2002},
+	{0x0F12, 0x83c8},
+	{0x0F12, 0x2001},
+	{0x0F12, 0x3120},
+	{0x0F12, 0x8088},
+	{0x0F12, 0x4925},
+	{0x0F12, 0x4826},
+	{0x0F12, 0x2204},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf917},
+	{0x0F12, 0x4925},
+	{0x0F12, 0x4825},
+	{0x0F12, 0x2206},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf912},
+	{0x0F12, 0x4924},
+	{0x0F12, 0x4825},
+	{0x0F12, 0x2207},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf90d},
+	{0x0F12, 0x4924},
+	{0x0F12, 0x4824},
+	{0x0F12, 0x2208},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf908},
+	{0x0F12, 0x4923},
+	{0x0F12, 0x4824},
+	{0x0F12, 0x2209},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf903},
+	{0x0F12, 0x4923},
+	{0x0F12, 0x4823},
+	{0x0F12, 0x60c1},
+	{0x0F12, 0x6882},
+	{0x0F12, 0x1a51},
+	{0x0F12, 0x8201},
+	{0x0F12, 0x4c22},
+	{0x0F12, 0x2607},
+	{0x0F12, 0x6821},
+	{0x0F12, 0x0736},
+	{0x0F12, 0x42b1},
+	{0x0F12, 0xda05},
+	{0x0F12, 0x4820},
+	{0x0F12, 0x22d8},
+	{0x0F12, 0x1c05},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8fa},
+	{0x0F12, 0x6025},
+	{0x0F12, 0x68a1},
+	{0x0F12, 0x42b1},
+	{0x0F12, 0xda07},
+	{0x0F12, 0x481b},
+	{0x0F12, 0x2224},
+	{0x0F12, 0x3824},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8f1},
+	{0x0F12, 0x4819},
+	{0x0F12, 0x3824},
+	{0x0F12, 0x60a0},
+	{0x0F12, 0x4d18},
+	{0x0F12, 0x6d29},
+	{0x0F12, 0x42b1},
+	{0x0F12, 0xda07},
+
+	{0x0F12, 0x4815},
+	{0x0F12, 0x228f},
+	{0x0F12, 0x00d2},
+	{0x0F12, 0x30d8},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8e3},
+	{0x0F12, 0x652c},
+	{0x0F12, 0xbc70},
+	{0x0F12, 0xbc08},
+	{0x0F12, 0x4718},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1f53},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x127b},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0398},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x1e4d},
+
+	{0x0F12, 0x7000},
+	{0x0F12, 0x890d},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1e73},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x27a9},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1e91},
+	{0x0F12, 0x7000},
+
+	{0x0F12, 0x27c5},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1ef7},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x285f},
+
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1eb3},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x28ff},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x206c},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x04ac},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x06cc},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x23a4},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0704},
+	{0x0F12, 0x7000},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0x484d},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8bb},
+	{0x0F12, 0x4a4d},
+	{0x0F12, 0x4b4d},
+	{0x0F12, 0x8811},
+	{0x0F12, 0x885b},
+	{0x0F12, 0x8852},
+	{0x0F12, 0x4359},
+	{0x0F12, 0x1889},
+	{0x0F12, 0x4288},
+
+	{0x0F12, 0xd800},
+	{0x0F12, 0x1c08},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xbc10},
+	{0x0F12, 0xbc08},
+	{0x0F12, 0x4718},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8b1},
+	{0x0F12, 0x4944},
+	{0x0F12, 0x8989},
+	{0x0F12, 0x4348},
+	{0x0F12, 0x0200},
+	{0x0F12, 0x0c00},
+	{0x0F12, 0x2101},
+	{0x0F12, 0x0349},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8b0},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7ed},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8b2},
+	{0x0F12, 0x6821},
+	{0x0F12, 0x0409},
+	{0x0F12, 0x0c09},
+	{0x0F12, 0x1a40},
+	{0x0F12, 0x493a},
+	{0x0F12, 0x6849},
+	{0x0F12, 0x4281},
+	{0x0F12, 0xd800},
+	{0x0F12, 0x1c08},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8af},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7dc},
+	{0x0F12, 0xb570},
+	{0x0F12, 0x6801},
+	{0x0F12, 0x040d},
+	{0x0F12, 0x0c2d},
+	{0x0F12, 0x6844},
+	{0x0F12, 0x4833},
+	{0x0F12, 0x8981},
+	{0x0F12, 0x1c28},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf893},
+	{0x0F12, 0x8060},
+	{0x0F12, 0x4932},
+	{0x0F12, 0x69c9},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8a6},
+	{0x0F12, 0x1c01},
+	{0x0F12, 0x80a0},
+	{0x0F12, 0x0228},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8a9},
+	{0x0F12, 0x0400},
+	{0x0F12, 0x0c00},
+	{0x0F12, 0x8020},
+	{0x0F12, 0x492d},
+	{0x0F12, 0x2300},
+	{0x0F12, 0x5ec9},
+	{0x0F12, 0x4288},
+	{0x0F12, 0xda02},
+	{0x0F12, 0x20ff},
+	{0x0F12, 0x3001},
+	{0x0F12, 0x8020},
+	{0x0F12, 0xbc70},
+	{0x0F12, 0xbc08},
+	{0x0F12, 0x4718},
+	{0x0F12, 0xb570},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0x4828},
+	{0x0F12, 0x4926},
+	{0x0F12, 0x7803},
+	{0x0F12, 0x6a8a},
+	{0x0F12, 0x2b00},
+	{0x0F12, 0xd100},
+	{0x0F12, 0x6a0a},
+	{0x0F12, 0x4d20},
+	{0x0F12, 0x2b00},
+	{0x0F12, 0x68a8},
+	{0x0F12, 0xd100},
+	{0x0F12, 0x6868},
+	{0x0F12, 0x6823},
+	{0x0F12, 0x8dc9},
+	{0x0F12, 0x434a},
+	{0x0F12, 0x0a12},
+	{0x0F12, 0x429a},
+	{0x0F12, 0xd30d},
+	{0x0F12, 0x4d20},
+	{0x0F12, 0x26ff},
+	{0x0F12, 0x8828},
+	{0x0F12, 0x3601},
+	{0x0F12, 0x43b0},
+	{0x0F12, 0x8028},
+	{0x0F12, 0x6820},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf884},
+	{0x0F12, 0x6020},
+	{0x0F12, 0x8828},
+	{0x0F12, 0x4330},
+	{0x0F12, 0x8028},
+	{0x0F12, 0xe7da},
+	{0x0F12, 0x1c0a},
+	{0x0F12, 0x4342},
+	{0x0F12, 0x0a12},
+	{0x0F12, 0x429a},
+	{0x0F12, 0xd304},
+	{0x0F12, 0x0218},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf871},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7f4},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7f2},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x4913},
+	{0x0F12, 0x8fc8},
+	{0x0F12, 0x2800},
+	{0x0F12, 0xd007},
+	{0x0F12, 0x2000},
+	{0x0F12, 0x87c8},
+	{0x0F12, 0x8f88},
+	{0x0F12, 0x4c11},
+	{0x0F12, 0x2800},
+	{0x0F12, 0xd002},
+
+	{0x0F12, 0x2008},
+	{0x0F12, 0x8020},
+	{0x0F12, 0xe77e},
+	{0x0F12, 0x480d},
+	{0x0F12, 0x3060},
+	{0x0F12, 0x8900},
+	{0x0F12, 0x2800},
+	{0x0F12, 0xd103},
+	{0x0F12, 0x480c},
+	{0x0F12, 0x2101},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf864},
+	{0x0F12, 0x2010},
+	{0x0F12, 0x8020},
+	{0x0F12, 0xe7f2},
+	{0x0F12, 0x0000},
+	{0x0F12, 0xf4b0},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x2058},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x1554},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0080},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x046c},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0468},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x1100},
+	{0x0F12, 0xd000},
+	{0x0F12, 0x01b8},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x044e},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0450},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x9ce7},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xf004},
+	{0x0F12, 0xe51f},
+	{0x0F12, 0x9fb8},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x88df},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x275d},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x1ed3},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x26f9},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x4027},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x9f03},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xf004},
+	{0x0F12, 0xe51f},
+	{0x0F12, 0xa144},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x285f},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x2001},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0xe848},
+	{0x0F12, 0x0001},
+	{0x0F12, 0xe848},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x0500},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x002A, 0x0e3a},  // #awbb_Alpha_Comp_Mode
+	{0x0F12, 0x02C2},
+	{0x002A, 0x112a},  //#senHal_SenRegsModes3_pSenModesRegsArray3[8]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1132},  //#senHal_SenRegsModes3_pSenModesRegsArray3[12]
+	{0x0F12, 0x0000},
+	{0x002A, 0x113e},  //#senHal_SenRegsModes3_pSenModesRegsArray3[18]
+	{0x0F12, 0x0000},
+	{0x002A, 0x115c},  //#senHal_SenRegsModes3_pSenModesRegsArray3[33]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1164},  //#senHal_SenRegsModes3_pSenModesRegsArray3[37]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1174},  //#senHal_SenRegsModes3_pSenModesRegsArray3[45]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1178},  //#senHal_SenRegsModes3_pSenModesRegsArray3[47]
+	{0x0F12, 0x0000},
+	{0x002A, 0x077a},  //#msm_uOffsetNoBin[0][0]
+	{0x0F12, 0x0000},  //#msm_uOffsetNoBin[0][1]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[1][0]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[1][1]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[2][0]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[2][1]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[3][0]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[3][1]
+	{0x0F12, 0x0000},
+	{0x002A, 0x07a2},  //#msm_sAnalogOffset[0]
+	{0x0F12, 0x0000}, 	 //#msm_sAnalogOffset[1]
+	{0x0F12, 0x0000}, 	 //#msm_sAnalogOffset[2]
+	{0x0F12, 0x0000}, 	 //#msm_sAnalogOffset[3]
+	{0x0F12, 0x0000},
+	{0x002A, 0x07b6},  //#msm_NonLinearOfsOutput[0]
+	{0x0F12, 0x0000}, 	 //#msm_NonLinearOfsOutput[1]
+	{0x0F12, 0x0002}, 	 //#msm_NonLinearOfsOutput[2]
+	{0x0F12, 0x0004}, 	 //#msm_NonLinearOfsOutput[3]
+	{0x0F12, 0x0004}, 	 //#msm_NonLinearOfsOutput[4]
+	{0x0F12, 0x0005}, 	 //#msm_NonLinearOfsOutput[5]
+	{0x0F12, 0x0005},
+	{0x002A, 0x0712},
+	{0x0F12, 0x0149},
+	{0x0F12, 0x011B},
+	{0x0F12, 0x0120},
+	{0x0F12, 0x00EF},
+	{0x0F12, 0x00C3},
+	{0x0F12, 0x00D2},
+	{0x0F12, 0x00DC},
+	{0x0F12, 0x00B8},
+	{0x0F12, 0x0106},
+	{0x0F12, 0x00DE},
+	{0x0F12, 0x00E3},
+	{0x0F12, 0x00CC},
+	{0x0F12, 0x00BD},
+	{0x0F12, 0x00E1},
+	{0x0F12, 0x00D8},
+	{0x0F12, 0x00D0},
+	{0x0F12, 0x00BE},
+	{0x0F12, 0x00EC},
+	{0x0F12, 0x00EA},
+	{0x0F12, 0x00F2},
+	{0x0F12, 0x00BE},
+	{0x0F12, 0x00EB},
+	{0x0F12, 0x00E5},
+	{0x0F12, 0x00F9},
+	{0x0F12, 0x0100},  //0x00BE
+	{0x0F12, 0x00D5},
+	{0x0F12, 0x00D8},
+	{0x0F12, 0x00E6},
+	{0x0F12, 0x00FD},
+	{0x0F12, 0x00F7},
+	{0x0F12, 0x00F3},
+	{0x0F12, 0x00FF},
+	{0x002A, 0x075A},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x02A1},
+	{0x0F12, 0x0225},
+	{0x0F12, 0x000D},
+	{0x0F12, 0x000D},
+	{0x002A, 0x247C},
+	{0x0F12, 0x0164},	//TVAR_ash_pGAS[0]   0128  //018C
+	{0x0F12, 0x0122},	//TVAR_ash_pGAS[1]   00F6  //0147
+	{0x0F12, 0x00E4},	//TVAR_ash_pGAS[2]   00C7  //010E
+	{0x0F12, 0x00B8},	//TVAR_ash_pGAS[3]   00B7  //00E5
+	{0x0F12, 0x009D},	//TVAR_ash_pGAS[4]   00AA  //00C5
+	{0x0F12, 0x008D},	//TVAR_ash_pGAS[5]   009D  //00B0
+	{0x0F12, 0x0083},	//TVAR_ash_pGAS[6]   0097  //00A7
+	{0x0F12, 0x0088},	//TVAR_ash_pGAS[7]   0097  //00AA
+	{0x0F12, 0x009C},	//TVAR_ash_pGAS[8]   009E  //00B8
+	{0x0F12, 0x00BB},	//TVAR_ash_pGAS[9]   00A9  //00D1
+	{0x0F12, 0x00E5},	//TVAR_ash_pGAS[10]  00B4  //00F7
+	{0x0F12, 0x0121},	//TVAR_ash_pGAS[11]  00CA  //0130
+	{0x0F12, 0x0169},	//TVAR_ash_pGAS[12]  0105  //016F
+	{0x0F12, 0x0138},	//TVAR_ash_pGAS[13]  00DA  //0148
+	{0x0F12, 0x00FB},	//TVAR_ash_pGAS[14]  00B4  //010A
+	{0x0F12, 0x00B9},	//TVAR_ash_pGAS[15]  0099  //00D2
+	{0x0F12, 0x008C},	//TVAR_ash_pGAS[16]  0089  //00AB
+	{0x0F12, 0x006E},	//TVAR_ash_pGAS[17]  0077  //008F
+	{0x0F12, 0x005B},	//TVAR_ash_pGAS[18]  006A  //007B
+	{0x0F12, 0x0053},	//TVAR_ash_pGAS[19]  0063  //0073
+	{0x0F12, 0x0059},	//TVAR_ash_pGAS[20]  0064  //0075
+	{0x0F12, 0x006B},	//TVAR_ash_pGAS[21]  006D  //0085
+	{0x0F12, 0x0086},	//TVAR_ash_pGAS[22]  007B  //009D
+	{0x0F12, 0x00B1},	//TVAR_ash_pGAS[23]  008B  //00C1
+	{0x0F12, 0x00E9},	//TVAR_ash_pGAS[24]  009C  //00F7
+	{0x0F12, 0x012F},	//TVAR_ash_pGAS[25]  00BD  //0134
+	{0x0F12, 0x0111},	//TVAR_ash_pGAS[26]  00A4  //0111
+	{0x0F12, 0x00D1},	//TVAR_ash_pGAS[27]  0093  //00D5
+	{0x0F12, 0x0094},	//TVAR_ash_pGAS[28]  0079  //00A1
+	{0x0F12, 0x0069},	//TVAR_ash_pGAS[29]  0063  //007B
+	{0x0F12, 0x004A},	//TVAR_ash_pGAS[30]  004F  //005F
+	{0x0F12, 0x0036},	//TVAR_ash_pGAS[31]  0040  //004B
+	{0x0F12, 0x002C},	//TVAR_ash_pGAS[32]  0039  //0043
+	{0x0F12, 0x0032},	//TVAR_ash_pGAS[33]  003B  //0046
+	{0x0F12, 0x0042},	//TVAR_ash_pGAS[34]  0044  //0057
+	{0x0F12, 0x0060},	//TVAR_ash_pGAS[35]  0054  //0072
+	{0x0F12, 0x008A},	//TVAR_ash_pGAS[36]  006A  //0093
+	{0x0F12, 0x00C0},	//TVAR_ash_pGAS[37]  0081  //00C7
+	{0x0F12, 0x0103},	//TVAR_ash_pGAS[38]  009B  //00FD
+	{0x0F12, 0x00F9},	//TVAR_ash_pGAS[39]  008D  //00EA
+	{0x0F12, 0x00B7},	//TVAR_ash_pGAS[40]  007E  //00B1
+	{0x0F12, 0x007E},	//TVAR_ash_pGAS[41]  005F  //0080
+	{0x0F12, 0x0054},	//TVAR_ash_pGAS[42]  0046  //005A
+	{0x0F12, 0x0033},	//TVAR_ash_pGAS[43]  0032  //003D
+	{0x0F12, 0x001B},	//TVAR_ash_pGAS[44]  0023  //0029
+	{0x0F12, 0x0013},	//TVAR_ash_pGAS[45]  001C  //0021
+	{0x0F12, 0x0018},	//TVAR_ash_pGAS[46]  001E  //0025
+	{0x0F12, 0x002A},	//TVAR_ash_pGAS[47]  0026  //0036
+	{0x0F12, 0x004A},	//TVAR_ash_pGAS[48]  0038  //0051
+	{0x0F12, 0x0075},	//TVAR_ash_pGAS[49]  004F  //0074
+	{0x0F12, 0x00AC},	//TVAR_ash_pGAS[50]  006A  //00A3
+	{0x0F12, 0x00F0},	//TVAR_ash_pGAS[51]  0088  //00DA
+	{0x0F12, 0x00EF},	//TVAR_ash_pGAS[52]  0081  //00D2
+	{0x0F12, 0x00AE},	//TVAR_ash_pGAS[53]  0070  //009B
+	{0x0F12, 0x0076},	//TVAR_ash_pGAS[54]  004F  //006B
+	{0x0F12, 0x004A},	//TVAR_ash_pGAS[55]  0034  //0043
+	{0x0F12, 0x0025},	//TVAR_ash_pGAS[56]  001F  //0027
+	{0x0F12, 0x000D},	//TVAR_ash_pGAS[57]  0010  //0013
+	{0x0F12, 0x0004},	//TVAR_ash_pGAS[58]  0009  //000A
+	{0x0F12, 0x000A},	//TVAR_ash_pGAS[59]  000B  //000F
+	{0x0F12, 0x001E},	//TVAR_ash_pGAS[60]  0015  //0021
+	{0x0F12, 0x003F},	//TVAR_ash_pGAS[61]  0026  //003D
+	{0x0F12, 0x006C},	//TVAR_ash_pGAS[62]  0040  //0060
+	{0x0F12, 0x00A7},	//TVAR_ash_pGAS[63]  005D  //0091
+	{0x0F12, 0x00EA},	//TVAR_ash_pGAS[64]  007E  //00C2
+	{0x0F12, 0x00F6},	//TVAR_ash_pGAS[65]  007C  //00C6
+	{0x0F12, 0x00B3},	//TVAR_ash_pGAS[66]  0068  //0094
+	{0x0F12, 0x007B},	//TVAR_ash_pGAS[67]  0047  //0063
+	{0x0F12, 0x004C},	//TVAR_ash_pGAS[68]  002C  //003B
+	{0x0F12, 0x0024},	//TVAR_ash_pGAS[69]  0017  //001E
+	{0x0F12, 0x000B},	//TVAR_ash_pGAS[70]  0007  //0009
+	{0x0F12, 0x0000},	//TVAR_ash_pGAS[71]  0000  //0000
+	{0x0F12, 0x0007},	//TVAR_ash_pGAS[72]  0002  //0006
+
+	{0x0F12, 0x001E},	//TVAR_ash_pGAS[73]  000D  //0019
+	{0x0F12, 0x0041},	//TVAR_ash_pGAS[74]  0020  //0035
+	{0x0F12, 0x0071},	//TVAR_ash_pGAS[75]  003A  //005A
+	{0x0F12, 0x00AD},	//TVAR_ash_pGAS[76]  0059  //0089
+	{0x0F12, 0x00F3},	//TVAR_ash_pGAS[77]  007E  //00BA
+	{0x0F12, 0x010B},	//TVAR_ash_pGAS[78]  007E  //00C8
+	{0x0F12, 0x00C6},	//TVAR_ash_pGAS[79]  006A  //0095
+	{0x0F12, 0x0089},	//TVAR_ash_pGAS[80]  0048  //0063
+	{0x0F12, 0x0058},	//TVAR_ash_pGAS[81]  002D  //003D
+	{0x0F12, 0x0032},	//TVAR_ash_pGAS[82]  0018  //0020
+	{0x0F12, 0x0017},	//TVAR_ash_pGAS[83]  0008  //000D
+	{0x0F12, 0x000D},	//TVAR_ash_pGAS[84]  0001  //0004
+	{0x0F12, 0x0015},	//TVAR_ash_pGAS[85]  0003  //0009
+	{0x0F12, 0x002D},	//TVAR_ash_pGAS[86]  000E  //001C
+	{0x0F12, 0x0053},	//TVAR_ash_pGAS[87]  0021  //0038
+	{0x0F12, 0x0085},	//TVAR_ash_pGAS[88]  003D  //005F
+	{0x0F12, 0x00C4},	//TVAR_ash_pGAS[89]  0060  //008E
+	{0x0F12, 0x010B},	//TVAR_ash_pGAS[90]  0086  //00BE
+	{0x0F12, 0x012F},	//TVAR_ash_pGAS[91]  0087  //00D7
+	{0x0F12, 0x00E7},	//TVAR_ash_pGAS[92]  0073  //00A1
+	{0x0F12, 0x00A7},	//TVAR_ash_pGAS[93]  0051  //006E
+	{0x0F12, 0x0073},	//TVAR_ash_pGAS[94]  0036  //0049
+	{0x0F12, 0x004E},	//TVAR_ash_pGAS[95]  0022  //002D
+	{0x0F12, 0x0033},	//TVAR_ash_pGAS[96]  0013  //001B
+	{0x0F12, 0x002A},	//TVAR_ash_pGAS[97]  000B  //0014
+	{0x0F12, 0x0032},	//TVAR_ash_pGAS[98]  000D  //001A
+	{0x0F12, 0x004B},	//TVAR_ash_pGAS[99]  0019  //002C
+	{0x0F12, 0x0072},	//TVAR_ash_pGAS[100] 002C  //0048
+	{0x0F12, 0x00A7},	//TVAR_ash_pGAS[101] 004A  //006C
+	{0x0F12, 0x00E9},	//TVAR_ash_pGAS[102] 006F  //009D
+	{0x0F12, 0x0133},	//TVAR_ash_pGAS[103] 0093  //00D1
+	{0x0F12, 0x0162},	//TVAR_ash_pGAS[104] 0099  //00F3
+	{0x0F12, 0x0110},	//TVAR_ash_pGAS[105] 0086  //00B9
+	{0x0F12, 0x00CE},	//TVAR_ash_pGAS[106] 0066  //0086
+	{0x0F12, 0x009B},	//TVAR_ash_pGAS[107] 004A  //0063
+	{0x0F12, 0x0078},	//TVAR_ash_pGAS[108] 0035  //0047
+	{0x0F12, 0x0060},	//TVAR_ash_pGAS[109] 0025  //0034
+	{0x0F12, 0x0057},	//TVAR_ash_pGAS[110] 001E  //002E
+	{0x0F12, 0x0061},	//TVAR_ash_pGAS[111] 0021  //0034
+	{0x0F12, 0x0079},	//TVAR_ash_pGAS[112] 002C  //0046
+	{0x0F12, 0x00A2},	//TVAR_ash_pGAS[113] 0041  //0062
+	{0x0F12, 0x00D8},	//TVAR_ash_pGAS[114] 0061  //0087
+	{0x0F12, 0x011E},	//TVAR_ash_pGAS[115] 0087  //00B8
+	{0x0F12, 0x016E},	//TVAR_ash_pGAS[116] 00A8  //00F2
+	{0x0F12, 0x01A8},	//TVAR_ash_pGAS[117] 00B8  //011D
+	{0x0F12, 0x014D},	//TVAR_ash_pGAS[118] 00A1  //00E5
+	{0x0F12, 0x0104},	//TVAR_ash_pGAS[119] 0084  //00B0
+	{0x0F12, 0x00D5},	//TVAR_ash_pGAS[120] 0069  //0089
+	{0x0F12, 0x00B3},	//TVAR_ash_pGAS[121] 0054  //006F
+	{0x0F12, 0x009B},	//TVAR_ash_pGAS[122] 0044  //005D
+	{0x0F12, 0x0095},	//TVAR_ash_pGAS[123] 003E  //0057
+	{0x0F12, 0x009E},	//TVAR_ash_pGAS[124] 0040  //005D
+	{0x0F12, 0x00B7},	//TVAR_ash_pGAS[125] 004C  //006E
+	{0x0F12, 0x00E1},	//TVAR_ash_pGAS[126] 0063  //008B
+	{0x0F12, 0x0119},	//TVAR_ash_pGAS[127] 0083  //00B3
+	{0x0F12, 0x0166},	//TVAR_ash_pGAS[128] 00A8  //00E6
+	{0x0F12, 0x01C6},	//TVAR_ash_pGAS[129] 00C9  //0129
+	{0x0F12, 0x01F1},	//TVAR_ash_pGAS[130] 00EE  //013E
+	{0x0F12, 0x0199},	//TVAR_ash_pGAS[131] 00C4  //010D
+	{0x0F12, 0x014D},	//TVAR_ash_pGAS[132] 00AB  //00D8
+	{0x0F12, 0x011A},	//TVAR_ash_pGAS[133] 0091  //00B2
+	{0x0F12, 0x00F5},	//TVAR_ash_pGAS[134] 007B  //0096
+	{0x0F12, 0x00DD},	//TVAR_ash_pGAS[135] 006D  //0084
+	{0x0F12, 0x00D8},	//TVAR_ash_pGAS[136] 0066  //007E
+	{0x0F12, 0x00E4},	//TVAR_ash_pGAS[137] 0068  //0083
+	{0x0F12, 0x00FB},	//TVAR_ash_pGAS[138] 0075  //0096
+	{0x0F12, 0x0128},	//TVAR_ash_pGAS[139] 008E  //00B3
+	{0x0F12, 0x0166},	//TVAR_ash_pGAS[140] 00AF  //00DB
+	{0x0F12, 0x01BC},	//TVAR_ash_pGAS[141] 00D0  //0117
+	{0x0F12, 0x0228},	//TVAR_ash_pGAS[142] 00F7  //0151
+	{0x0F12, 0x0133},	//TVAR_ash_pGAS[143] 00E3  //014A
+	{0x0F12, 0x00F7},	//TVAR_ash_pGAS[144] 00AB  //0108
+	{0x0F12, 0x00BF},	//TVAR_ash_pGAS[145] 0086  //00D7
+	{0x0F12, 0x0097},	//TVAR_ash_pGAS[146] 0081  //00B5
+	{0x0F12, 0x0081},	//TVAR_ash_pGAS[147] 0078  //009E
+	{0x0F12, 0x0074},	//TVAR_ash_pGAS[148] 0071  //0090
+	{0x0F12, 0x006A},	//TVAR_ash_pGAS[149] 006B  //0089
+	{0x0F12, 0x006B},	//TVAR_ash_pGAS[150] 0069  //0089
+	{0x0F12, 0x007B},	//TVAR_ash_pGAS[151] 006A  //0090
+	{0x0F12, 0x008F},	//TVAR_ash_pGAS[152] 006E  //00A0
+	{0x0F12, 0x00B1},	//TVAR_ash_pGAS[153] 0071  //00B8
+	{0x0F12, 0x00E4},	//TVAR_ash_pGAS[154] 007D  //00E6
+	{0x0F12, 0x0128},	//TVAR_ash_pGAS[155] 00B0  //011F
+	{0x0F12, 0x010B},	//TVAR_ash_pGAS[156] 0096  //010B
+	{0x0F12, 0x00D4},	//TVAR_ash_pGAS[157] 0071  //00CE
+	{0x0F12, 0x0098},	//TVAR_ash_pGAS[158] 0061  //00A4
+	{0x0F12, 0x006F},	//TVAR_ash_pGAS[159] 005B  //0085
+	{0x0F12, 0x0056},	//TVAR_ash_pGAS[160] 0051  //0073
+	{0x0F12, 0x0045},	//TVAR_ash_pGAS[161] 0049  //0064
+	{0x0F12, 0x003D},	//TVAR_ash_pGAS[162] 0043  //005D
+	{0x0F12, 0x0040},	//TVAR_ash_pGAS[163] 0042  //005E
+	{0x0F12, 0x004D},	//TVAR_ash_pGAS[164] 0044  //0066
+	{0x0F12, 0x0060},	//TVAR_ash_pGAS[165] 004C  //0076
+	{0x0F12, 0x0081},	//TVAR_ash_pGAS[166] 0051  //008F
+	{0x0F12, 0x00B0},	//TVAR_ash_pGAS[167] 0056  //00B7
+	{0x0F12, 0x00EB},	//TVAR_ash_pGAS[168] 006F  //00EB
+	{0x0F12, 0x00EC},	//TVAR_ash_pGAS[169] 006B  //00D7
+	{0x0F12, 0x00B0},	//TVAR_ash_pGAS[170] 005B  //00A3
+	{0x0F12, 0x007C},	//TVAR_ash_pGAS[171] 004E  //007C
+	{0x0F12, 0x0054},	//TVAR_ash_pGAS[172] 0043  //0061
+	{0x0F12, 0x0039},	//TVAR_ash_pGAS[173] 0037  //004C
+	{0x0F12, 0x0029},	//TVAR_ash_pGAS[174] 002E  //003F
+	{0x0F12, 0x001E},	//TVAR_ash_pGAS[175] 0029  //0038
+	{0x0F12, 0x0021},	//TVAR_ash_pGAS[176] 0028  //003A
+	{0x0F12, 0x002D},	//TVAR_ash_pGAS[177] 002B  //0044
+	{0x0F12, 0x0044},	//TVAR_ash_pGAS[178] 0033  //0056
+	{0x0F12, 0x0064},	//TVAR_ash_pGAS[179] 003D  //006D
+	{0x0F12, 0x008F},	//TVAR_ash_pGAS[180] 0046  //0091
+	{0x0F12, 0x00C8},	//TVAR_ash_pGAS[181] 0056  //00BD
+	{0x0F12, 0x00D6},	//TVAR_ash_pGAS[182] 0058  //00B7
+	{0x0F12, 0x009B},	//TVAR_ash_pGAS[183] 004C  //0086
+	{0x0F12, 0x0068},	//TVAR_ash_pGAS[184] 003B  //0062
+	{0x0F12, 0x0043},	//TVAR_ash_pGAS[185] 002E  //0046
+	{0x0F12, 0x0026},	//TVAR_ash_pGAS[186] 0022  //0031
+	{0x0F12, 0x0013},	//TVAR_ash_pGAS[187] 0019  //0022
+	{0x0F12, 0x000B},	//TVAR_ash_pGAS[188] 0014  //001C
+	{0x0F12, 0x000E},	//TVAR_ash_pGAS[189] 0014  //001E
+	{0x0F12, 0x001C},	//TVAR_ash_pGAS[190] 0017  //0029
+	{0x0F12, 0x0033},	//TVAR_ash_pGAS[191] 0020  //003B
+	{0x0F12, 0x0054},	//TVAR_ash_pGAS[192] 002C  //0055
+	{0x0F12, 0x0080},	//TVAR_ash_pGAS[193] 0039  //0076
+	{0x0F12, 0x00B9},	//TVAR_ash_pGAS[194] 004A  //00A0
+	{0x0F12, 0x00D1},	//TVAR_ash_pGAS[195] 004F  //00A1
+	{0x0F12, 0x0094},	//TVAR_ash_pGAS[196] 0043  //0074
+	{0x0F12, 0x0061},	//TVAR_ash_pGAS[197] 002F  //0050
+	{0x0F12, 0x003B},	//TVAR_ash_pGAS[198] 0022  //0033
+	{0x0F12, 0x001C},	//TVAR_ash_pGAS[199] 0015  //001E
+	{0x0F12, 0x0008},	//TVAR_ash_pGAS[200] 000C  //000F
+	{0x0F12, 0x0001},	//TVAR_ash_pGAS[201] 0007  //0009
+	{0x0F12, 0x0004},	//TVAR_ash_pGAS[202] 0007  //000B
+	{0x0F12, 0x0012},	//TVAR_ash_pGAS[203] 000B  //0017
+	{0x0F12, 0x002B},	//TVAR_ash_pGAS[204] 0016  //002A
+	{0x0F12, 0x0050},	//TVAR_ash_pGAS[205] 0023  //0044
+	{0x0F12, 0x007E},	//TVAR_ash_pGAS[206] 0032  //0066
+	{0x0F12, 0x00B6},	//TVAR_ash_pGAS[207] 0046  //008C
+	{0x0F12, 0x00D6},	//TVAR_ash_pGAS[208] 004C  //0098
+	{0x0F12, 0x0098},	//TVAR_ash_pGAS[209] 003E  //006D
+	{0x0F12, 0x0067},	//TVAR_ash_pGAS[210] 002a  //0049
+	{0x0F12, 0x003D},	//TVAR_ash_pGAS[211] 001C  //002B
+	{0x0F12, 0x001D},	//TVAR_ash_pGAS[212] 000F  //0016
+	{0x0F12, 0x0009},	//TVAR_ash_pGAS[213] 0006  //0006
+	{0x0F12, 0x0000},	//TVAR_ash_pGAS[214] 0001  //0000
+	{0x0F12, 0x0004},	//TVAR_ash_pGAS[215] 0002  //0004
+	{0x0F12, 0x0014},	//TVAR_ash_pGAS[216] 0007  //0010
+	{0x0F12, 0x002F},	//TVAR_ash_pGAS[217] 0013  //0023
+	{0x0F12, 0x0057},	//TVAR_ash_pGAS[218] 0021  //003E
+	{0x0F12, 0x0085},	//TVAR_ash_pGAS[219] 0032  //0060
+	{0x0F12, 0x00C1},	//TVAR_ash_pGAS[220] 0048  //0085
+	{0x0F12, 0x00EA},	//TVAR_ash_pGAS[221] 004D  //0098
+	{0x0F12, 0x00AA},	//TVAR_ash_pGAS[222] 0040  //006E
+	{0x0F12, 0x0076},	//TVAR_ash_pGAS[223] 002C  //0048
+	{0x0F12, 0x004B},	//TVAR_ash_pGAS[224] 001E  //002C
+	{0x0F12, 0x002A},	//TVAR_ash_pGAS[225] 0011  //0018
+	{0x0F12, 0x0015},	//TVAR_ash_pGAS[226] 0008  //0009
+	{0x0F12, 0x000C},	//TVAR_ash_pGAS[227] 0004  //0003
+	{0x0F12, 0x0012},	//TVAR_ash_pGAS[228] 0004  //0006
+	{0x0F12, 0x0024},	//TVAR_ash_pGAS[229] 000A  //0012
+	{0x0F12, 0x0041},	//TVAR_ash_pGAS[230] 0017  //0026
+	{0x0F12, 0x006A},	//TVAR_ash_pGAS[231] 0026  //0042
+	{0x0F12, 0x009C},	//TVAR_ash_pGAS[232] 0039  //0063
+	{0x0F12, 0x00D9},	//TVAR_ash_pGAS[233] 0051  //0089
+	{0x0F12, 0x010A},	//TVAR_ash_pGAS[234] 0054  //00A3
+	{0x0F12, 0x00C9},	//TVAR_ash_pGAS[235] 0048  //0076
+	{0x0F12, 0x0092},	//TVAR_ash_pGAS[236] 0034  //0051
+	{0x0F12, 0x0065},	//TVAR_ash_pGAS[237] 0026  //0035
+	{0x0F12, 0x0045},	//TVAR_ash_pGAS[238] 001A  //0021
+	{0x0F12, 0x002E},	//TVAR_ash_pGAS[239] 0012  //0013
+	{0x0F12, 0x0027},	//TVAR_ash_pGAS[240] 000D  //000E
+	{0x0F12, 0x002E},	//TVAR_ash_pGAS[241] 000E  //0012
+	{0x0F12, 0x0041},	//TVAR_ash_pGAS[242] 0014  //001E
+	{0x0F12, 0x005F},	//TVAR_ash_pGAS[243] 0021  //0032
+
+	{0x0F12, 0x008A},	//TVAR_ash_pGAS[244] 0033  //004D
+	{0x0F12, 0x00BF},	//TVAR_ash_pGAS[245] 0048  //006F
+	{0x0F12, 0x00FE},	//TVAR_ash_pGAS[246] 005C  //0097
+	{0x0F12, 0x0137},	//TVAR_ash_pGAS[247] 0063  //00B7
+	{0x0F12, 0x00EF},	//TVAR_ash_pGAS[248] 0057  //0089
+	{0x0F12, 0x00B4},	//TVAR_ash_pGAS[249] 0045  //0062
+	{0x0F12, 0x0089},	//TVAR_ash_pGAS[250] 0036  //0048
+	{0x0F12, 0x006C},	//TVAR_ash_pGAS[251] 002B  //0034
+	{0x0F12, 0x0058},	//TVAR_ash_pGAS[252] 0022  //0028
+	{0x0F12, 0x0051},	//TVAR_ash_pGAS[253] 001E  //0023
+	{0x0F12, 0x0059},	//TVAR_ash_pGAS[254] 001F  //0027
+	{0x0F12, 0x006B},	//TVAR_ash_pGAS[255] 0026  //0033
+	{0x0F12, 0x008B},	//TVAR_ash_pGAS[256] 0034  //0047
+	{0x0F12, 0x00B7},	//TVAR_ash_pGAS[257] 0047  //0061
+	{0x0F12, 0x00EE},	//TVAR_ash_pGAS[258] 005D  //0085
+	{0x0F12, 0x0135},	//TVAR_ash_pGAS[259] 0070  //00B1
+	{0x0F12, 0x0175},	//TVAR_ash_pGAS[260] 007C  //00DE
+	{0x0F12, 0x0123},	//TVAR_ash_pGAS[261] 006B  //00AA
+	{0x0F12, 0x00E3},	//TVAR_ash_pGAS[262] 005C  //0082
+	{0x0F12, 0x00BB},	//TVAR_ash_pGAS[263] 004E  //0067
+	{0x0F12, 0x00A0},	//TVAR_ash_pGAS[264] 0043  //0055
+	{0x0F12, 0x008E},	//TVAR_ash_pGAS[265] 003B  //0049
+	{0x0F12, 0x008A},	//TVAR_ash_pGAS[266] 0037  //0044
+	{0x0F12, 0x0091},	//TVAR_ash_pGAS[267] 0039  //0048
+	{0x0F12, 0x00A5},	//TVAR_ash_pGAS[268] 0040  //0054
+	{0x0F12, 0x00C4},	//TVAR_ash_pGAS[269] 0050  //0066
+	{0x0F12, 0x00F1},	//TVAR_ash_pGAS[270] 0064  //0083
+	{0x0F12, 0x012F},	//TVAR_ash_pGAS[271] 007A  //00A8
+	{0x0F12, 0x0183},	//TVAR_ash_pGAS[272] 008D  //00E0
+	{0x0F12, 0x01B5},	//TVAR_ash_pGAS[273] 00AD  //00FE
+	{0x0F12, 0x0163},	//TVAR_ash_pGAS[274] 0088  //00CC
+	{0x0F12, 0x0124},	//TVAR_ash_pGAS[275] 007B  //00A2
+	{0x0F12, 0x00F8},	//TVAR_ash_pGAS[276] 006D  //0085
+	{0x0F12, 0x00DA},	//TVAR_ash_pGAS[277] 0062  //0072
+	{0x0F12, 0x00C9},	//TVAR_ash_pGAS[278] 005B  //0066
+	{0x0F12, 0x00C4},	//TVAR_ash_pGAS[279] 0057  //0062
+	{0x0F12, 0x00CE},	//TVAR_ash_pGAS[280] 005A  //0065
+	{0x0F12, 0x00E1},	//TVAR_ash_pGAS[281] 0061  //0072
+	{0x0F12, 0x0103},	//TVAR_ash_pGAS[282] 0073  //0085
+	{0x0F12, 0x0136},	//TVAR_ash_pGAS[283] 0088  //00A2
+	{0x0F12, 0x017F},	//TVAR_ash_pGAS[284] 009E  //00D0
+	{0x0F12, 0x01E0},	//TVAR_ash_pGAS[285] 00BB  //0103
+	{0x0F12, 0x0148},	//TVAR_ash_pGAS[286] 00F3  //0153
+	{0x0F12, 0x0108},	//TVAR_ash_pGAS[287] 00B8  //010D
+	{0x0F12, 0x00C8},	//TVAR_ash_pGAS[288] 008D  //00D8
+	{0x0F12, 0x009F},	//TVAR_ash_pGAS[289] 0082  //00B3
+	{0x0F12, 0x0082},	//TVAR_ash_pGAS[290] 0077  //009A
+	{0x0F12, 0x0073},	//TVAR_ash_pGAS[291] 006E  //008A
+	{0x0F12, 0x0068},	//TVAR_ash_pGAS[292] 0069  //0083
+	{0x0F12, 0x006C},	//TVAR_ash_pGAS[293] 006A  //0087
+	{0x0F12, 0x007E},	//TVAR_ash_pGAS[294] 0071  //0095
+	{0x0F12, 0x009B},	//TVAR_ash_pGAS[295] 007B  //00AC
+	{0x0F12, 0x00C2},	//TVAR_ash_pGAS[296] 0086  //00CF
+	{0x0F12, 0x0100},	//TVAR_ash_pGAS[297] 0098  //0106
+	{0x0F12, 0x014D},	//TVAR_ash_pGAS[298] 00D3  //0149
+	{0x0F12, 0x0121},	//TVAR_ash_pGAS[299] 00A4  //0116
+	{0x0F12, 0x00E6},	//TVAR_ash_pGAS[300] 007E  //00D6
+	{0x0F12, 0x00A4},	//TVAR_ash_pGAS[301] 006A  //00A8
+	{0x0F12, 0x0078},	//TVAR_ash_pGAS[302] 0060  //0087
+	{0x0F12, 0x005A},	//TVAR_ash_pGAS[303] 0053  //0071
+	{0x0F12, 0x0046},	//TVAR_ash_pGAS[304] 0048  //0061
+	{0x0F12, 0x003E},	//TVAR_ash_pGAS[305] 0044  //005B
+	{0x0F12, 0x0043},	//TVAR_ash_pGAS[306] 0045  //005E
+	{0x0F12, 0x0052},	//TVAR_ash_pGAS[307] 004C  //006D
+	{0x0F12, 0x006B},	//TVAR_ash_pGAS[308] 0059  //0083
+	{0x0F12, 0x0093},	//TVAR_ash_pGAS[309] 0066  //00A4
+	{0x0F12, 0x00C9},	//TVAR_ash_pGAS[310] 006F  //00D5
+	{0x0F12, 0x010D},	//TVAR_ash_pGAS[311] 008C  //0113
+	{0x0F12, 0x0103},	//TVAR_ash_pGAS[312] 007A  //00E6
+	{0x0F12, 0x00C3},	//TVAR_ash_pGAS[313] 0069  //00AE
+	{0x0F12, 0x0089},	//TVAR_ash_pGAS[314] 0058  //0084
+	{0x0F12, 0x005E},	//TVAR_ash_pGAS[315] 004A  //0065
+	{0x0F12, 0x003E},	//TVAR_ash_pGAS[316] 003A  //004D
+	{0x0F12, 0x002A},	//TVAR_ash_pGAS[317] 002F  //003D
+	{0x0F12, 0x001F},	//TVAR_ash_pGAS[318] 0029  //0037
+	{0x0F12, 0x0023},	//TVAR_ash_pGAS[319] 002a  //003B
+	{0x0F12, 0x0032},	//TVAR_ash_pGAS[320] 0031  //004B
+	{0x0F12, 0x004E},	//TVAR_ash_pGAS[321] 003F  //0063
+	{0x0F12, 0x0074},	//TVAR_ash_pGAS[322] 004F  //0080
+	{0x0F12, 0x00A5},	//TVAR_ash_pGAS[323] 005C  //00AB
+	{0x0F12, 0x00E6},	//TVAR_ash_pGAS[324] 006F  //00DF
+	{0x0F12, 0x00EF},	//TVAR_ash_pGAS[325] 0068  //00C5
+	{0x0F12, 0x00AD},	//TVAR_ash_pGAS[326] 005C  //0092
+	{0x0F12, 0x0076},	//TVAR_ash_pGAS[327] 0047  //006B
+	{0x0F12, 0x004D},	//TVAR_ash_pGAS[328] 0037  //004B
+	{0x0F12, 0x002C},	//TVAR_ash_pGAS[329] 0027  //0034
+	{0x0F12, 0x0015},	//TVAR_ash_pGAS[330] 001B  //0023
+	{0x0F12, 0x000C},	//TVAR_ash_pGAS[331] 0015  //001C
+	{0x0F12, 0x0010},	//TVAR_ash_pGAS[332] 0016  //0020
+	{0x0F12, 0x001F},	//TVAR_ash_pGAS[333] 001C  //002E
+	{0x0F12, 0x003B},	//TVAR_ash_pGAS[334] 0029  //0047
+	{0x0F12, 0x0061},	//TVAR_ash_pGAS[335] 003A  //0066
+	{0x0F12, 0x0092},	//TVAR_ash_pGAS[336] 004B  //008C
+	{0x0F12, 0x00D2},	//TVAR_ash_pGAS[337] 005E  //00BB
+	{0x0F12, 0x00E8},	//TVAR_ash_pGAS[338] 0060  //00B0
+	{0x0F12, 0x00A8},	//TVAR_ash_pGAS[339] 0053  //0081
+	{0x0F12, 0x0071},	//TVAR_ash_pGAS[340] 003B  //005A
+	{0x0F12, 0x0046},	//TVAR_ash_pGAS[341] 002a  //0039
+	{0x0F12, 0x0023},	//TVAR_ash_pGAS[342] 001A  //0021
+	{0x0F12, 0x000B},	//TVAR_ash_pGAS[343] 000D  //0010
+	{0x0F12, 0x0002},	//TVAR_ash_pGAS[344] 0007  //0009
+	{0x0F12, 0x0005},	//TVAR_ash_pGAS[345] 0007  //000C
+	{0x0F12, 0x0014},	//TVAR_ash_pGAS[346] 000D  //001B
+	{0x0F12, 0x0030},	//TVAR_ash_pGAS[347] 001A  //0033
+	{0x0F12, 0x0058},	//TVAR_ash_pGAS[348] 002B  //0050
+	{0x0F12, 0x008A},	//TVAR_ash_pGAS[349] 003D  //0078
+	{0x0F12, 0x00C8},	//TVAR_ash_pGAS[350] 0053  //00A1
+	{0x0F12, 0x00EF},	//TVAR_ash_pGAS[351] 005C  //00A8
+	{0x0F12, 0x00AD},	//TVAR_ash_pGAS[352] 004E  //007B
+	{0x0F12, 0x0077},	//TVAR_ash_pGAS[353] 0036  //0054
+	{0x0F12, 0x0048},	//TVAR_ash_pGAS[354] 0023  //0032
+	{0x0F12, 0x0023},	//TVAR_ash_pGAS[355] 0014  //0019
+	{0x0F12, 0x000B},	//TVAR_ash_pGAS[356] 0007  //0008
+	{0x0F12, 0x0000},	//TVAR_ash_pGAS[357] 0000  //0000
+	{0x0F12, 0x0003},	//TVAR_ash_pGAS[358] 0000  //0004
+	{0x0F12, 0x0013},	//TVAR_ash_pGAS[359] 0006  //0012
+	{0x0F12, 0x0030},	//TVAR_ash_pGAS[360] 0012  //0028
+	{0x0F12, 0x0059},	//TVAR_ash_pGAS[361] 0023  //0046
+	{0x0F12, 0x008A},	//TVAR_ash_pGAS[362] 0034  //006B
+	{0x0F12, 0x00CA},	//TVAR_ash_pGAS[363] 004C  //0093
+	{0x0F12, 0x0104},	//TVAR_ash_pGAS[364] 005E  //00A9
+	{0x0F12, 0x00C0},	//TVAR_ash_pGAS[365] 004F  //007C
+	{0x0F12, 0x0087},	//TVAR_ash_pGAS[366] 0037  //0054
+	{0x0F12, 0x0057},	//TVAR_ash_pGAS[367] 0024  //0034
+	{0x0F12, 0x0031},	//TVAR_ash_pGAS[368] 0015  //001B
+	{0x0F12, 0x0018},	//TVAR_ash_pGAS[369] 0008  //000A
+	{0x0F12, 0x000C},	//TVAR_ash_pGAS[370] 0001  //0002
+	{0x0F12, 0x0010},	//TVAR_ash_pGAS[371] 0000  //0004
+	{0x0F12, 0x0020},	//TVAR_ash_pGAS[372] 0005  //0012
+	{0x0F12, 0x003D},	//TVAR_ash_pGAS[373] 0010  //0027
+	{0x0F12, 0x0067},	//TVAR_ash_pGAS[374] 0021  //0045
+	{0x0F12, 0x009A},	//TVAR_ash_pGAS[375] 0033  //0069
+	{0x0F12, 0x00D9},	//TVAR_ash_pGAS[376] 004A  //0090
+	{0x0F12, 0x0126},	//TVAR_ash_pGAS[377] 0064  //00B4
+	{0x0F12, 0x00E1},	//TVAR_ash_pGAS[378] 0056  //0086
+	{0x0F12, 0x00A3},	//TVAR_ash_pGAS[379] 003F  //005C
+	{0x0F12, 0x0071},	//TVAR_ash_pGAS[380] 002C  //003C
+	{0x0F12, 0x004C},	//TVAR_ash_pGAS[381] 001D  //0024
+	{0x0F12, 0x0031},	//TVAR_ash_pGAS[382] 0011  //0014
+	{0x0F12, 0x0025},	//TVAR_ash_pGAS[383] 0008  //000D
+	{0x0F12, 0x0029},	//TVAR_ash_pGAS[384] 0006  //000F
+	{0x0F12, 0x003A},	//TVAR_ash_pGAS[385] 000B  //001B
+	{0x0F12, 0x0057},	//TVAR_ash_pGAS[386] 0015  //002F
+	{0x0F12, 0x0081},	//TVAR_ash_pGAS[387] 0025  //004B
+	{0x0F12, 0x00B4},	//TVAR_ash_pGAS[388] 0038  //006E
+	{0x0F12, 0x00F4},	//TVAR_ash_pGAS[389] 004B  //0097
+	{0x0F12, 0x0154},	//TVAR_ash_pGAS[390] 0072  //00CA
+	{0x0F12, 0x0107},	//TVAR_ash_pGAS[391] 0064  //0098
+	{0x0F12, 0x00C6},	//TVAR_ash_pGAS[392] 004E  //006E
+	{0x0F12, 0x0095},	//TVAR_ash_pGAS[393] 003B  //0050
+	{0x0F12, 0x0074},	//TVAR_ash_pGAS[394] 002C  //0037
+	{0x0F12, 0x005A},	//TVAR_ash_pGAS[395] 001F  //0027
+	{0x0F12, 0x004F},	//TVAR_ash_pGAS[396] 0018  //0020
+	{0x0F12, 0x0053},	//TVAR_ash_pGAS[397] 0015  //0022
+	{0x0F12, 0x0062},	//TVAR_ash_pGAS[398] 0018  //002D
+	{0x0F12, 0x007F},	//TVAR_ash_pGAS[399] 0022  //0042
+	{0x0F12, 0x00A8},	//TVAR_ash_pGAS[400] 0032  //005B
+	{0x0F12, 0x00DC},	//TVAR_ash_pGAS[401] 0044  //0080
+	{0x0F12, 0x0120},	//TVAR_ash_pGAS[402] 0054  //00AA
+	{0x0F12, 0x0193},	//TVAR_ash_pGAS[403] 0089  //00F0
+	{0x0F12, 0x013B},	//TVAR_ash_pGAS[404] 0077  //00BA
+	{0x0F12, 0x00F6},	//TVAR_ash_pGAS[405] 0065  //008E
+	{0x0F12, 0x00C9},	//TVAR_ash_pGAS[406] 0052  //006F
+	{0x0F12, 0x00A8},	//TVAR_ash_pGAS[407] 0043  //0058
+	{0x0F12, 0x0090},	//TVAR_ash_pGAS[408] 0037  //0048
+	{0x0F12, 0x0086},	//TVAR_ash_pGAS[409] 002F  //0041
+	{0x0F12, 0x008A},	//TVAR_ash_pGAS[410] 002C  //0042
+	{0x0F12, 0x0099},	//TVAR_ash_pGAS[411] 002F  //004C
+	{0x0F12, 0x00B5},	//TVAR_ash_pGAS[412] 0038  //005F
+	{0x0F12, 0x00DD},	//TVAR_ash_pGAS[413] 0048  //007A
+	{0x0F12, 0x0117},	//TVAR_ash_pGAS[414] 0058  //009D
+	{0x0F12, 0x0166},	//TVAR_ash_pGAS[415] 0068  //00D2
+	{0x0F12, 0x01D6},	//TVAR_ash_pGAS[416] 00BC  //0112
+	{0x0F12, 0x017D},	//TVAR_ash_pGAS[417] 0092  //00DD
+	{0x0F12, 0x0138},	//TVAR_ash_pGAS[418] 0082  //00AF
+	{0x0F12, 0x0108},	//TVAR_ash_pGAS[419] 006F  //008F
+	{0x0F12, 0x00E3},	//TVAR_ash_pGAS[420] 0061  //0077
+	{0x0F12, 0x00CD},	//TVAR_ash_pGAS[421] 0055  //0066
+	{0x0F12, 0x00C2},	//TVAR_ash_pGAS[422] 004E  //005F
+	{0x0F12, 0x00C7},	//TVAR_ash_pGAS[423] 004A  //005F
+	{0x0F12, 0x00D4},	//TVAR_ash_pGAS[424] 004C  //006A
+	{0x0F12, 0x00F1},	//TVAR_ash_pGAS[425] 0056  //007C
+	{0x0F12, 0x011F},	//TVAR_ash_pGAS[426] 0066  //0097
+	{0x0F12, 0x015F},	//TVAR_ash_pGAS[427] 0073  //00C2
+	{0x0F12, 0x01B7},	//TVAR_ash_pGAS[428] 008B  //00F2
+	{0x0F12, 0x00D1},	//TVAR_ash_pGAS[429] 0087  //00EE
+	{0x0F12, 0x00A9},	//TVAR_ash_pGAS[430] 0069  //00C2
+	{0x0F12, 0x0080},	//TVAR_ash_pGAS[431] 0053  //009B
+	{0x0F12, 0x0064},	//TVAR_ash_pGAS[432] 0052  //0085
+	{0x0F12, 0x0055},	//TVAR_ash_pGAS[433] 0050  //0074
+	{0x0F12, 0x004E},	//TVAR_ash_pGAS[434] 0050  //006A
+	{0x0F12, 0x0047},	//TVAR_ash_pGAS[435] 004F  //0067
+	{0x0F12, 0x004B},	//TVAR_ash_pGAS[436] 0052  //006B
+	{0x0F12, 0x005E},	//TVAR_ash_pGAS[437] 0057  //0076
+	{0x0F12, 0x0077},	//TVAR_ash_pGAS[438] 005D  //0089
+	{0x0F12, 0x0094},	//TVAR_ash_pGAS[439] 0060  //00A3
+	{0x0F12, 0x00BF},	//TVAR_ash_pGAS[440] 0068  //00CE
+	{0x0F12, 0x00F1},	//TVAR_ash_pGAS[441] 0090  //0102
+	{0x0F12, 0x00BB},	//TVAR_ash_pGAS[442] 0050  //00C2
+	{0x0F12, 0x0095},	//TVAR_ash_pGAS[443] 003F  //0097
+	{0x0F12, 0x0067},	//TVAR_ash_pGAS[444] 003A  //0076
+	{0x0F12, 0x0049},	//TVAR_ash_pGAS[445] 003A  //0062
+	{0x0F12, 0x0036},	//TVAR_ash_pGAS[446] 0035  //0054
+	{0x0F12, 0x002C},	//TVAR_ash_pGAS[447] 0033  //004B
+	{0x0F12, 0x0027},	//TVAR_ash_pGAS[448] 0033  //0047
+	{0x0F12, 0x002E},	//TVAR_ash_pGAS[449] 0036  //004C
+	{0x0F12, 0x003C},	//TVAR_ash_pGAS[450] 003B  //0057
+	{0x0F12, 0x004F},	//TVAR_ash_pGAS[451] 0043  //006A
+	{0x0F12, 0x006F},	//TVAR_ash_pGAS[452] 0048  //0084
+	{0x0F12, 0x0097},	//TVAR_ash_pGAS[453] 004A  //00AE
+	{0x0F12, 0x00C7},	//TVAR_ash_pGAS[454] 005D  //00DF
+	{0x0F12, 0x00A5},	//TVAR_ash_pGAS[455] 002D  //009A
+	{0x0F12, 0x0079},	//TVAR_ash_pGAS[456] 002D  //0075
+	{0x0F12, 0x0052},	//TVAR_ash_pGAS[457] 002B  //0058
+	{0x0F12, 0x0036},	//TVAR_ash_pGAS[458] 0029  //0045
+	{0x0F12, 0x0023},	//TVAR_ash_pGAS[459] 0023  //0039
+	{0x0F12, 0x0017},	//TVAR_ash_pGAS[460] 0020  //002F
+	{0x0F12, 0x0012},	//TVAR_ash_pGAS[461] 001F  //002C
+	{0x0F12, 0x0017},	//TVAR_ash_pGAS[462] 0023  //0030
+	{0x0F12, 0x0024},	//TVAR_ash_pGAS[463] 0027  //003D
+	{0x0F12, 0x0039},	//TVAR_ash_pGAS[464] 002F  //0050
+	{0x0F12, 0x0055},	//TVAR_ash_pGAS[465] 0036  //0067
+	{0x0F12, 0x007A},	//TVAR_ash_pGAS[466] 003A  //008B
+	{0x0F12, 0x00A8},	//TVAR_ash_pGAS[467] 0043  //00B4
+	{0x0F12, 0x0097},	//TVAR_ash_pGAS[468] 001F  //0080
+	{0x0F12, 0x0069},	//TVAR_ash_pGAS[469] 0023  //005E
+	{0x0F12, 0x0045},	//TVAR_ash_pGAS[470] 001D  //0044
+	{0x0F12, 0x002B},	//TVAR_ash_pGAS[471] 001A  //0032
+	{0x0F12, 0x0018},	//TVAR_ash_pGAS[472] 0015  //0024
+	{0x0F12, 0x000B},	//TVAR_ash_pGAS[473] 0012  //001A
+	{0x0F12, 0x0006},	//TVAR_ash_pGAS[474] 0010  //0017
+	{0x0F12, 0x000A},	//TVAR_ash_pGAS[475] 0013  //001B
+	{0x0F12, 0x0017},	//TVAR_ash_pGAS[476] 0017  //0027
+	{0x0F12, 0x002B},	//TVAR_ash_pGAS[477] 001E  //0039
+	{0x0F12, 0x0047},	//TVAR_ash_pGAS[478] 0025  //004F
+	{0x0F12, 0x006B},	//TVAR_ash_pGAS[479] 002B  //006E
+	{0x0F12, 0x0097},	//TVAR_ash_pGAS[480] 0034  //0092
+	{0x0F12, 0x0092},	//TVAR_ash_pGAS[481] 0017  //006E
+	{0x0F12, 0x0065},	//TVAR_ash_pGAS[482] 001B  //004F
+	{0x0F12, 0x0042},	//TVAR_ash_pGAS[483] 0015  //0037
+	{0x0F12, 0x0028},	//TVAR_ash_pGAS[484] 0011  //0023
+	{0x0F12, 0x0013},	//TVAR_ash_pGAS[485] 000B  //0016
+	{0x0F12, 0x0005},	//TVAR_ash_pGAS[486] 0008  //000C
+	{0x0F12, 0x0000},	//TVAR_ash_pGAS[487] 0006  //0008
+	{0x0F12, 0x0004},	//TVAR_ash_pGAS[488] 0008  //000C
+	{0x0F12, 0x000F},	//TVAR_ash_pGAS[489] 000B  //0017
+	{0x0F12, 0x0025},	//TVAR_ash_pGAS[490] 0012  //0028
+	{0x0F12, 0x0040},	//TVAR_ash_pGAS[491] 0018  //003D
+	{0x0F12, 0x0064},	//TVAR_ash_pGAS[492] 001E  //005B
+	{0x0F12, 0x008F},	//TVAR_ash_pGAS[493] 0028  //007A
+	{0x0F12, 0x0098},	//TVAR_ash_pGAS[494] 0014  //0068
+	{0x0F12, 0x006A},	//TVAR_ash_pGAS[495] 0016  //004A
+	{0x0F12, 0x004A},	//TVAR_ash_pGAS[496] 0011  //0032
+	{0x0F12, 0x002E},	//TVAR_ash_pGAS[497] 000C  //001D
+	{0x0F12, 0x0016},	//TVAR_ash_pGAS[498] 0007  //0011
+	{0x0F12, 0x0007},	//TVAR_ash_pGAS[499] 0002  //0005
+	{0x0F12, 0x0000},	//TVAR_ash_pGAS[500] 0000  //0000
+	{0x0F12, 0x0004},	//TVAR_ash_pGAS[501] 0001  //0005
+	{0x0F12, 0x0011},	//TVAR_ash_pGAS[502] 0005  //000F
+	{0x0F12, 0x0026},	//TVAR_ash_pGAS[503] 000A  //001E
+	{0x0F12, 0x0042},	//TVAR_ash_pGAS[504] 000F  //0033
+	{0x0F12, 0x0064},	//TVAR_ash_pGAS[505] 0014  //004E
+	{0x0F12, 0x008F},	//TVAR_ash_pGAS[506] 001E  //006C
+	{0x0F12, 0x00A9},	//TVAR_ash_pGAS[507] 0015  //006C
+	{0x0F12, 0x007B},	//TVAR_ash_pGAS[508] 0016  //004C
+	{0x0F12, 0x0057},	//TVAR_ash_pGAS[509] 0011  //0033
+	{0x0F12, 0x0039},	//TVAR_ash_pGAS[510] 000D  //0020
+	{0x0F12, 0x0021},	//TVAR_ash_pGAS[511] 0007  //0013
+	{0x0F12, 0x0012},	//TVAR_ash_pGAS[512] 0003  //0008
+	{0x0F12, 0x000C},	//TVAR_ash_pGAS[513] 0000  //0003
+	{0x0F12, 0x0010},	//TVAR_ash_pGAS[514] 0000  //0006
+	{0x0F12, 0x001D},	//TVAR_ash_pGAS[515] 0002  //000E
+	{0x0F12, 0x0031},	//TVAR_ash_pGAS[516] 0007  //001C
+	{0x0F12, 0x004E},	//TVAR_ash_pGAS[517] 000C  //0032
+	{0x0F12, 0x0071},	//TVAR_ash_pGAS[518] 0010  //004B
+	{0x0F12, 0x009C},	//TVAR_ash_pGAS[519] 0019  //0067
+	{0x0F12, 0x00C6},	//TVAR_ash_pGAS[520] 0019  //0076
+	{0x0F12, 0x0097},	//TVAR_ash_pGAS[521] 001C  //0055
+	{0x0F12, 0x006E},	//TVAR_ash_pGAS[522] 0016  //003A
+	{0x0F12, 0x004E},	//TVAR_ash_pGAS[523] 0012  //0028
+	{0x0F12, 0x0038},	//TVAR_ash_pGAS[524] 000D  //001A
+	{0x0F12, 0x0028},	//TVAR_ash_pGAS[525] 0009  //0010
+	{0x0F12, 0x0022},	//TVAR_ash_pGAS[526] 0005  //000C
+	{0x0F12, 0x0027},	//TVAR_ash_pGAS[527] 0003  //000E
+	{0x0F12, 0x0034},	//TVAR_ash_pGAS[528] 0005  //0016
+	{0x0F12, 0x0047},	//TVAR_ash_pGAS[529] 0009  //0022
+	{0x0F12, 0x0064},	//TVAR_ash_pGAS[530] 000D  //0035
+	{0x0F12, 0x0088},	//TVAR_ash_pGAS[531] 0011  //004F
+	{0x0F12, 0x00B3},	//TVAR_ash_pGAS[532] 0017  //006C
+	{0x0F12, 0x00EB},	//TVAR_ash_pGAS[533] 0024  //0089
+	{0x0F12, 0x00B3},	//TVAR_ash_pGAS[534] 0026  //0066
+	{0x0F12, 0x008A},	//TVAR_ash_pGAS[535] 0021  //0049
+	{0x0F12, 0x006C},	//TVAR_ash_pGAS[536] 001D  //0037
+	{0x0F12, 0x005A},	//TVAR_ash_pGAS[537] 0018  //002A
+	{0x0F12, 0x004B},	//TVAR_ash_pGAS[538] 0014  //0020
+	{0x0F12, 0x0047},	//TVAR_ash_pGAS[539] 000F  //001C
+	{0x0F12, 0x004C},	//TVAR_ash_pGAS[540] 000D  //001E
+	{0x0F12, 0x0057},	//TVAR_ash_pGAS[541] 000E  //0024
+	{0x0F12, 0x006A},	//TVAR_ash_pGAS[542] 0012  //0030
+	{0x0F12, 0x0086},	//TVAR_ash_pGAS[543] 0016  //0042
+	{0x0F12, 0x00A9},	//TVAR_ash_pGAS[544] 0019  //005D
+	{0x0F12, 0x00D9},	//TVAR_ash_pGAS[545] 001B  //007D
+	{0x0F12, 0x011D},	//TVAR_ash_pGAS[546] 0036  //00A9
+	{0x0F12, 0x00DE},	//TVAR_ash_pGAS[547] 0035  //0084
+	{0x0F12, 0x00B2},	//TVAR_ash_pGAS[548] 0032  //0066
+	{0x0F12, 0x0097},	//TVAR_ash_pGAS[549] 002E  //0052
+	{0x0F12, 0x0087},	//TVAR_ash_pGAS[550] 002a  //0045
+	{0x0F12, 0x007A},	//TVAR_ash_pGAS[551] 0026  //003B
+	{0x0F12, 0x0077},	//TVAR_ash_pGAS[552] 0021  //0036
+	{0x0F12, 0x007A},	//TVAR_ash_pGAS[553] 001F  //0038
+	{0x0F12, 0x0086},	//TVAR_ash_pGAS[554] 001F  //003E
+	{0x0F12, 0x0098},	//TVAR_ash_pGAS[555] 0024  //004A
+	{0x0F12, 0x00B3},	//TVAR_ash_pGAS[556] 0027  //005E
+	{0x0F12, 0x00DA},	//TVAR_ash_pGAS[557] 002a  //0077
+	{0x0F12, 0x0112},	//TVAR_ash_pGAS[558] 0028  //009E
+	{0x0F12, 0x0149},	//TVAR_ash_pGAS[559] 005C  //00BC
+	{0x0F12, 0x0114},	//TVAR_ash_pGAS[560] 004A  //009C
+	{0x0F12, 0x00EB},	//TVAR_ash_pGAS[561] 0049  //007D
+	{0x0F12, 0x00CE},	//TVAR_ash_pGAS[562] 0046  //0069
+	{0x0F12, 0x00B9},	//TVAR_ash_pGAS[563] 0041  //005A
+	{0x0F12, 0x00AD},	//TVAR_ash_pGAS[564] 003E  //0052
+	{0x0F12, 0x00A8},	//TVAR_ash_pGAS[565] 003A  //004C
+	{0x0F12, 0x00AF},	//TVAR_ash_pGAS[566] 0037  //004D
+	{0x0F12, 0x00B8},	//TVAR_ash_pGAS[567] 0037  //0054
+	{0x0F12, 0x00CB},	//TVAR_ash_pGAS[568] 003B  //0060
+	{0x0F12, 0x00EC},	//TVAR_ash_pGAS[569] 003F  //0072
+	{0x0F12, 0x0119},	//TVAR_ash_pGAS[570] 0040  //0093
+	{0x0F12, 0x0153},	//TVAR_ash_pGAS[571] 0041  //00B6
+	{0x002A, 0x0F12},
+	{0x0F12, 0x02BC},
+	{0x0F12, 0x0347},
+	{0x002A, 0x0704},
+	{0x0F12, 0x00BF},
+	{0x0F12, 0x00E6},
+	{0x0F12, 0x00F2},
+	{0x0F12, 0x0143},
+	{0x0F12, 0x0178},
+	{0x0F12, 0x01A3},
+	{0x0F12, 0x01B5},
+	{0x002A, 0x0754},  //#TVAR_ash_pGAS
+	{0x0F12, 0x247C},
+	{0x0F12, 0x7000},
+	{0x002A, 0x0C50},
+	{0x0F12, 0x03AE},  //03BE	//awbb_IndoorGrZones_m_BGrid[0]            03C6
+	{0x0F12, 0x03DB},  //03EB	//awbb_IndoorGrZones_m_BGrid[1]            03F3
+	{0x0F12, 0x0399},  //03A9	//awbb_IndoorGrZones_m_BGrid[2]            03B1
+	{0x0F12, 0x03DB},  //03EB	//awbb_IndoorGrZones_m_BGrid[3]            03F3
+	{0x0F12, 0x0382},  //0392	//awbb_IndoorGrZones_m_BGrid[4]            039A
+	{0x0F12, 0x03DB},  //03EB	//awbb_IndoorGrZones_m_BGrid[5]            03F3
+	{0x0F12, 0x036B},  //037B	//awbb_IndoorGrZones_m_BGrid[6]            0383
+	{0x0F12, 0x03CE},  //03DE	//awbb_IndoorGrZones_m_BGrid[7]            03E6
+	{0x0F12, 0x034E},  //035E	//awbb_IndoorGrZones_m_BGrid[8]            0366
+	{0x0F12, 0x03BD},  //03CD	//awbb_IndoorGrZones_m_BGrid[9]            03D5
+	{0x0F12, 0x0330},  //0340	//awbb_IndoorGrZones_m_BGrid[10]           0348
+	{0x0F12, 0x03A8},  //03B8	//awbb_IndoorGrZones_m_BGrid[11]           03C0
+	{0x0F12, 0x0316},  //0326	//awbb_IndoorGrZones_m_BGrid[12]           032E
+	{0x0F12, 0x0391},  //03A1	//awbb_IndoorGrZones_m_BGrid[13]           03A9
+	{0x0F12, 0x02FA},  //030A	//awbb_IndoorGrZones_m_BGrid[14]           0312
+	{0x0F12, 0x0376},  //0386	//awbb_IndoorGrZones_m_BGrid[15]           038E
+	{0x0F12, 0x02E0},  //02F0	//awbb_IndoorGrZones_m_BGrid[16]           02F8
+	{0x0F12, 0x035D},  //036D	//awbb_IndoorGrZones_m_BGrid[17]           0375
+	{0x0F12, 0x02CC},  //02DC	//awbb_IndoorGrZones_m_BGrid[18]           02E4
+	{0x0F12, 0x0344},  //0354	//awbb_IndoorGrZones_m_BGrid[19]           035C
+	{0x0F12, 0x02B7},  //02C7	//awbb_IndoorGrZones_m_BGrid[20]           02CF
+	{0x0F12, 0x032F},  //033F	//awbb_IndoorGrZones_m_BGrid[21]           0347
+	{0x0F12, 0x02A7},  //02B7	//awbb_IndoorGrZones_m_BGrid[22]           02BF
+	{0x0F12, 0x0318},  //0328	//awbb_IndoorGrZones_m_BGrid[23]           0330
+	{0x0F12, 0x0296},  //02A6	//awbb_IndoorGrZones_m_BGrid[24]           02AE
+	{0x0F12, 0x0301},  //0311	//awbb_IndoorGrZones_m_BGrid[25]           0319
+	{0x0F12, 0x0286},  //0296	//awbb_IndoorGrZones_m_BGrid[26]           029E
+	{0x0F12, 0x02ED},  //02FD	//awbb_IndoorGrZones_m_BGrid[27]           0305
+	{0x0F12, 0x0279},  //0289	//awbb_IndoorGrZones_m_BGrid[28]           0291
+	{0x0F12, 0x02DB},  //02EB	//awbb_IndoorGrZones_m_BGrid[29]           02F3
+	{0x0F12, 0x026C},  //027C	//awbb_IndoorGrZones_m_BGrid[30]           0284
+	{0x0F12, 0x02CD},  //02DD	//awbb_IndoorGrZones_m_BGrid[31]           02E5
+	{0x0F12, 0x025E},  //026E	//awbb_IndoorGrZones_m_BGrid[32]           0276
+	{0x0F12, 0x02BF},  //02CF	//awbb_IndoorGrZones_m_BGrid[33]           02D7
+	{0x0F12, 0x0252},  //0262	//awbb_IndoorGrZones_m_BGrid[34]           026A
+	{0x0F12, 0x02B2},  //02C2	//awbb_IndoorGrZones_m_BGrid[35]           02CA
+	{0x0F12, 0x0249},  //0259	//awbb_IndoorGrZones_m_BGrid[36]           0261
+	{0x0F12, 0x02A7},  //02B7	//awbb_IndoorGrZones_m_BGrid[37]           02BF
+	{0x0F12, 0x023B},  //024B	//awbb_IndoorGrZones_m_BGrid[38]           0253
+	{0x0F12, 0x029B},  //02AB	//awbb_IndoorGrZones_m_BGrid[39]           02B3
+	{0x0F12, 0x0231},  //0241	//awbb_IndoorGrZones_m_BGrid[40]           0249
+	{0x0F12, 0x028D},  //029D	//awbb_IndoorGrZones_m_BGrid[41]           02A5
+	{0x0F12, 0x0227},  //0237	//awbb_IndoorGrZones_m_BGrid[42]           023F
+	{0x0F12, 0x0281},  //0291	//awbb_IndoorGrZones_m_BGrid[43]           0299
+	{0x0F12, 0x021D},  //022D	//awbb_IndoorGrZones_m_BGrid[44]           0235
+	{0x0F12, 0x0277},  //0287	//awbb_IndoorGrZones_m_BGrid[45]           028F
+	{0x0F12, 0x0216},  //0226	//awbb_IndoorGrZones_m_BGrid[46]           022E
+	{0x0F12, 0x026E},  //027E	//awbb_IndoorGrZones_m_BGrid[47]           0286
+	{0x0F12, 0x020C},  //021C	//awbb_IndoorGrZones_m_BGrid[48]           0224
+	{0x0F12, 0x0263},  //0273	//awbb_IndoorGrZones_m_BGrid[49]           027B
+	{0x0F12, 0x0204},  //0214	//awbb_IndoorGrZones_m_BGrid[50]           021C
+	{0x0F12, 0x0257},  //0267	//awbb_IndoorGrZones_m_BGrid[51]           026F
+	{0x0F12, 0x01F7},  //0207	//awbb_IndoorGrZones_m_BGrid[52]           020F
+	{0x0F12, 0x024A},  //025A	//awbb_IndoorGrZones_m_BGrid[53]           0262
+	{0x0F12, 0x01E4},  //01F4	//awbb_IndoorGrZones_m_BGrid[54]           01FC
+	{0x0F12, 0x023D},  //024D	//awbb_IndoorGrZones_m_BGrid[55]           0255
+	{0x0F12, 0x01CC},  //01DC	//awbb_IndoorGrZones_m_BGrid[56]           01F3
+	{0x0F12, 0x022A},  //023A	//awbb_IndoorGrZones_m_BGrid[57]           0242
+	{0x0F12, 0x01E5},  //01F5	//awbb_IndoorGrZones_m_BGrid[58]           01FD
+	{0x0F12, 0x020E},  //021E	//awbb_IndoorGrZones_m_BGrid[59]           0226
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[60]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[61]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[62]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[63]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[64]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[65]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[66]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[67]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[68]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[69]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[70]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[71]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[72]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[73]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[74]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[75]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[76]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[77]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[78]           0000
+	{0x0F12, 0x0000},  //0000	//awbb_IndoorGrZones_m_BGrid[79]           0000
+	{0x002a, 0x0cf0},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0000},
+	{0x002A, 0x0cf8},  //#awbb_IndoorGrZones_m_Boffs
+	{0x0F12, 0x00f7}, //EC
+	{0x0F12, 0x0000},
+	{0x002A, 0x0D84},
+	{0x0F12, 0x0406},  //0406	//awbb_LowBrGrZones_m_BGrid[0] 0406
+	{0x0F12, 0x0467},  //0467	//awbb_LowBrGrZones_m_BGrid[1] 0467
+	{0x0F12, 0x0371},  //0371	//awbb_LowBrGrZones_m_BGrid[2] 0371
+	{0x0F12, 0x04B0},  //04B0	//awbb_LowBrGrZones_m_BGrid[3] 04B0
+	{0x0F12, 0x02E5},  //02E5	//awbb_LowBrGrZones_m_BGrid[4] 02E5
+	{0x0F12, 0x0481},  //0481	//awbb_LowBrGrZones_m_BGrid[5] 0481
+	{0x0F12, 0x0298},  //0298	//awbb_LowBrGrZones_m_BGrid[6] 0298
+	{0x0F12, 0x042E},  //042E	//awbb_LowBrGrZones_m_BGrid[7] 042E
+	{0x0F12, 0x0260},  //0260	//awbb_LowBrGrZones_m_BGrid[8] 0260
+	{0x0F12, 0x03DE},  //03DE	//awbb_LowBrGrZones_m_BGrid[9] 03DE
+	{0x0F12, 0x022F},  //022F	//awbb_LowBrGrZones_m_BGrid[10]022F
+	{0x0F12, 0x0391},  //0391	//awbb_LowBrGrZones_m_BGrid[11]0391
+	{0x0F12, 0x0201},  //0201	//awbb_LowBrGrZones_m_BGrid[12]0201
+	{0x0F12, 0x034D},  //034D	//awbb_LowBrGrZones_m_BGrid[13]034D
+	{0x0F12, 0x01DA},  //01DA	//awbb_LowBrGrZones_m_BGrid[14]01DA
+	{0x0F12, 0x0310},  //0310	//awbb_LowBrGrZones_m_BGrid[15]0310
+	{0x0F12, 0x01B3},  //01B3	//awbb_LowBrGrZones_m_BGrid[16]01B3
+	{0x0F12, 0x02D4},  //02D4	//awbb_LowBrGrZones_m_BGrid[17]02D4
+	{0x0F12, 0x018F},  //018F	//awbb_LowBrGrZones_m_BGrid[18]018F
+	{0x0F12, 0x0297},  //0297	//awbb_LowBrGrZones_m_BGrid[19]0297
+	{0x0F12, 0x0181},  //0181	//awbb_LowBrGrZones_m_BGrid[20]0181
+	{0x0F12, 0x0271},  //0271	//awbb_LowBrGrZones_m_BGrid[21]0271
+	{0x0F12, 0x0181},  //0181	//awbb_LowBrGrZones_m_BGrid[22]0181
+	{0x0F12, 0x022A},  //022A	//awbb_LowBrGrZones_m_BGrid[23]022A
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[24]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[25]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[26]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[27]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[28]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[29]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[30]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[31]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[32]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[33]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[34]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[35]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[36]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[37]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[38]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[39]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[40]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[41]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[42]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[43]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[44]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[45]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[46]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[47]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[48]0000
+	{0x0F12, 0x0000},  //0000	//awbb_LowBrGrZones_m_BGrid[49]0000
+	{0x002A, 0x0de8},  //#awbb_LowBrGrZones_m_GridStep
+	{0x0F12, 0x0006},
+	{0x0F12, 0x0000},
+	{0x002A, 0x0df0},  //#awbb_LowBrGrZones_m_Boffs
+	{0x0F12, 0x0081},
+	{0x0F12, 0x0000},
+	{0x002A, 0x0D08},
+	{0x0F12, 0x0257},  //02C5  //0349  //035E	//awbb_OutdoorGrZones_m_BGrid[0] 036B
+	{0x0F12, 0x0287},  //032D  //0363  //0378	//awbb_OutdoorGrZones_m_BGrid[1] 0385
+	{0x0F12, 0x0245},  //02B2  //032C  //0341	//awbb_OutdoorGrZones_m_BGrid[2] 034E
+	{0x0F12, 0x0287},  //0315  //036E  //0383	//awbb_OutdoorGrZones_m_BGrid[3] 0390
+	{0x0F12, 0x0237},  //02A0  //030F  //0324	//awbb_OutdoorGrZones_m_BGrid[4] 0331
+	{0x0F12, 0x027D},  //02FE  //036E  //0383	//awbb_OutdoorGrZones_m_BGrid[5] 0390
+	{0x0F12, 0x022A},  //0290  //02F3  //0308	//awbb_OutdoorGrZones_m_BGrid[6] 0315
+	{0x0F12, 0x0270},  //02E9  //035C  //0371	//awbb_OutdoorGrZones_m_BGrid[7] 037E
+	{0x0F12, 0x0220},  //0280  //02D8  //02ED	//awbb_OutdoorGrZones_m_BGrid[8] 02FA
+	{0x0F12, 0x0263},  //02D7  //0343  //0358	//awbb_OutdoorGrZones_m_BGrid[9] 0365
+	{0x0F12, 0x0217},  //0274  //02C5  //02DA	//awbb_OutdoorGrZones_m_BGrid[10]02E7
+	{0x0F12, 0x0256},  //02C7  //032D  //0342	//awbb_OutdoorGrZones_m_BGrid[11]034F
+	{0x0F12, 0x020F},  //0266  //02B2  //02C7	//awbb_OutdoorGrZones_m_BGrid[12]02D4
+	{0x0F12, 0x024A},  //02B9  //0315  //032A	//awbb_OutdoorGrZones_m_BGrid[13]0337
+	{0x0F12, 0x020F},  //0259  //02A0  //02B5	//awbb_OutdoorGrZones_m_BGrid[14]02C2
+	{0x0F12, 0x023E},  //02AF  //02FE  //0313	//awbb_OutdoorGrZones_m_BGrid[15]0320
+	{0x0F12, 0x0000},  //024F  //0290  //02A5	//awbb_OutdoorGrZones_m_BGrid[16]02B2
+	{0x0F12, 0x0000},  //02A3  //02E9  //02FB	//awbb_OutdoorGrZones_m_BGrid[17]0308
+	{0x0F12, 0x0000},  //0241  //0280  //0295	//awbb_OutdoorGrZones_m_BGrid[18]02A2
+	{0x0F12, 0x0000},  //0297  //02D7  //02EB	//awbb_OutdoorGrZones_m_BGrid[19]02F8
+	{0x0F12, 0x0000},  //0235  //0274  //0289	//awbb_OutdoorGrZones_m_BGrid[20]0296
+	{0x0F12, 0x0000},  //0287  //02C7  //02DB	//awbb_OutdoorGrZones_m_BGrid[21]02E8
+	{0x0F12, 0x0000},  //022C  //0266  //027B	//awbb_OutdoorGrZones_m_BGrid[22]0288
+	{0x0F12, 0x0000},  //027C  //02B9  //02CC	//awbb_OutdoorGrZones_m_BGrid[23]02D9
+	{0x0F12, 0x0000},  //0222  //0259  //026E	//awbb_OutdoorGrZones_m_BGrid[24]027B
+	{0x0F12, 0x0000},  //0271  //02AF  //02C0	//awbb_OutdoorGrZones_m_BGrid[25]02CD
+	{0x0F12, 0x0000},  //021A  //024F  //0260	//awbb_OutdoorGrZones_m_BGrid[26]026D
+	{0x0F12, 0x0000},  //026A  //02A3  //02B3	//awbb_OutdoorGrZones_m_BGrid[27]02C0
+	{0x0F12, 0x0000},  //0213  //0241  //0256	//awbb_OutdoorGrZones_m_BGrid[28]0263
+	{0x0F12, 0x0000},  //0261  //0297  //02A7	//awbb_OutdoorGrZones_m_BGrid[29]02B4
+	{0x0F12, 0x0000},  //0209  //0235  //024A	//awbb_OutdoorGrZones_m_BGrid[30]0257
+	{0x0F12, 0x0000},  //0254  //0287  //029C	//awbb_OutdoorGrZones_m_BGrid[31]02A9
+	{0x0F12, 0x0000},  //01FE  //022C  //023F	//awbb_OutdoorGrZones_m_BGrid[32]024C
+	{0x0F12, 0x0000},  //0248  //027C  //028D	//awbb_OutdoorGrZones_m_BGrid[33]029A
+	{0x0F12, 0x0000},  //01F0  //0222  //0234	//awbb_OutdoorGrZones_m_BGrid[34]0241
+	{0x0F12, 0x0000},  //023A  //0271  //0283	//awbb_OutdoorGrZones_m_BGrid[35]0290
+	{0x0F12, 0x0000},  //01D4  //021A  //022C	//awbb_OutdoorGrZones_m_BGrid[36]0239
+	{0x0F12, 0x0000},  //0228  //026A  //0279	//awbb_OutdoorGrZones_m_BGrid[37]0286
+	{0x0F12, 0x0000},  //01EB  //0213  //0225	//awbb_OutdoorGrZones_m_BGrid[38]0232
+	{0x0F12, 0x0000},  //0209  //0261  //0271	//awbb_OutdoorGrZones_m_BGrid[39]027E
+	{0x0F12, 0x0000},  //0000  //0209  //021A	//awbb_OutdoorGrZones_m_BGrid[40]0227
+	{0x0F12, 0x0000},  //0000  //0254  //0266	//awbb_OutdoorGrZones_m_BGrid[41]0273
+	{0x0F12, 0x0000},  //0000  //01FE  //0210	//awbb_OutdoorGrZones_m_BGrid[42]021D
+	{0x0F12, 0x0000},  //0000  //0248  //0259	//awbb_OutdoorGrZones_m_BGrid[43]0266
+	{0x0F12, 0x0000},  //0000  //01F0  //0205	//awbb_OutdoorGrZones_m_BGrid[44]0212
+	{0x0F12, 0x0000},  //0000  //023A  //024A	//awbb_OutdoorGrZones_m_BGrid[45]0257
+	{0x0F12, 0x0000},  //0000  //01D4  //01E9	//awbb_OutdoorGrZones_m_BGrid[46]0202
+	{0x0F12, 0x0000},  //0000  //0228  //0239	//awbb_OutdoorGrZones_m_BGrid[47]0246
+	{0x0F12, 0x0000},  //0000  //01EB  //01F8	//awbb_OutdoorGrZones_m_BGrid[48]0209
+	{0x0F12, 0x0000},  //0000  //0209  //021E	//awbb_OutdoorGrZones_m_BGrid[49]022B
+	{0x002A, 0x0d6c},  //#awbb_OutdoorGrZones_m_GridStep
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0000},
+	{0x002A, 0x0d74},  //#awbb_OutdoorGrZones_m_Boffs
+	{0x0F12, 0x0222}, //0195 //0145 //013d //0131
+	{0x0F12, 0x0000},
+	{0x002A, 0x0e00},  //#awbb_CrclLowT_R_c
+	{0x0F12, 0x03cf}, //034A
+	{0x0F12, 0x0000},
+	{0x002A, 0x0e04},  //#awbb_CrclLowT_B_c
+	{0x0F12, 0x012e}, //0176
+	{0x0F12, 0x0000},
+	{0x002A, 0x0e08},  //#awbb_CrclLowT_Rad_c
+	{0x0F12, 0xdf21}, //67C3 //6fc3 //71B8
+	{0x0F12, 0x0000},
+	{0x002A, 0x0E1A},
+	{0x0F12, 0x0135}, //012F
+	{0x0F12, 0x0120},
+	{0x002A, 0x04C8}, //	param_start	SARR_usGammaLutRGBIndoor
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x0015},
+	{0x0F12, 0x0034},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x00ED},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0201},
+	{0x0F12, 0x0276},
+	{0x0F12, 0x0307},
+	{0x0F12, 0x0362},
+	{0x0F12, 0x03A9},
+	{0x0F12, 0x03D5},
+	{0x0F12, 0x03F4},
+	{0x0F12, 0x03FF},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x0015},
+	{0x0F12, 0x0034},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x00ED},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0201},
+	{0x0F12, 0x0276},
+	{0x0F12, 0x0307},
+	{0x0F12, 0x0362},
+	{0x0F12, 0x03A9},
+	{0x0F12, 0x03D5},
+	{0x0F12, 0x03F4},
+	{0x0F12, 0x03FF},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x0015},
+	{0x0F12, 0x0034},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x00ED},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0201},
+	{0x0F12, 0x0276},
+	{0x0F12, 0x0307},
+	{0x0F12, 0x0362},
+	{0x0F12, 0x03A9},
+	{0x0F12, 0x03D5},
+	{0x0F12, 0x03F4},
+	{0x0F12, 0x03FF},
+	{0x002A, 0x1000},	//	param_end	SARR_usGammaLutRGBIndoor
+	{0x0F12, 0x0036},
+	{0x002A, 0x108E},   // SAAR_IllumType
+	{0x0F12, 0x00C0},
+	{0x0F12, 0x00E7},
+	{0x0F12, 0x00F9},
+	{0x0F12, 0x0142},
+	{0x0F12, 0x0179},
+	{0x0F12, 0x01A4},
+	{0x0F12, 0x01B8},   //SAAR_IllumF
+	{0x0F12, 0x0112},
+	{0x0F12, 0x0122},
+	{0x0F12, 0x0136},
+	{0x0F12, 0x00F6},
+	{0x0F12, 0x0100},
+	{0x0F12, 0x00FE},
+	{0x0F12, 0x0100},
+	{0x002A, 0x1AC8},
+	{0x0F12, 0x0000},   //	param_start	TVAR_wbt_pBaseCcms
+	{0x002A, 0x23A4},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F}, //	param_end	TVAR_wbt_pBaseCcms
+	{0x002A, 0x2380}, //	param_start	TVAR_wbt_pOutdoorCcm
+	{0x0F12, 0x01AF},
+	{0x0F12, 0xFFD5},
+	{0x0F12, 0x001D},
+	{0x0F12, 0x0080},
+	{0x0F12, 0x00BA},
+	{0x0F12, 0xFF61},
+	{0x0F12, 0xFF21},
+	{0x0F12, 0x0164},
+	{0x0F12, 0xFF96},
+	{0x0F12, 0xFF0F},
+	{0x0F12, 0x019A},
+	{0x0F12, 0x0117},
+	{0x0F12, 0xFFE8},
+	{0x0F12, 0x0041},
+	{0x0F12, 0x01C8},
+	{0x0F12, 0x0173},
+	{0x0F12, 0xFF35},
+	{0x0F12, 0x013C},   //	param_end	TVAR_wbt_pOutdoorCcm
+	{0x002A, 0x06DA},
+	{0x0F12, 0x00BF},
+	{0x0F12, 0x00E6},
+	{0x0F12, 0x00F2},
+	{0x0F12, 0x0143},
+	{0x0F12, 0x0178},
+	{0x0F12, 0x01A3},  //	param_start	SARR_uNormBrInDoor
+	{0x002A, 0x07E8},
+	{0x0F12, 0x000A},
+	{0x0F12, 0x0019},
+	{0x0F12, 0x007D},
+	{0x0F12, 0x01F4},
+	{0x0F12, 0x1388},
+
+	{0x002A, 0x07D0},
+	{0x0F12, 0x0030},
+	{0x0F12, 0x0046},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x0205},
+	{0x0F12, 0x02BC},
+	{0x002A, 0x07E6},
+	{0x0F12, 0x0001},
+	{0x002A, 0x0828},
+	{0x0F12, 0x000B},        //TVAR_afit_pBaseVals[0]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[1]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[2]
+	{0x0F12, 0xFFAA}, 	 //TVAR_afit_pBaseVals[3]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[4]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[5]
+	{0x0F12, 0x0032}, 	 //TVAR_afit_pBaseVals[6]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[7]
+	{0x0F12, 0x00FF}, 	 //TVAR_afit_pBaseVals[8]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[9]
+	{0x0F12, 0x0004}, 	 //TVAR_afit_pBaseVals[10]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[11]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[12]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[13]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[14]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[15]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[16]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[17]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[18]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[19]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[20]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[21]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[22]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[23]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[24]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[25]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[26]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[27]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[28]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[29]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[30]
+	{0x0F12, 0x054C}, 	 //TVAR_afit_pBaseVals[31]
+	{0x0F12, 0x0A4C}, 	 //TVAR_afit_pBaseVals[32]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[33]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[34]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[35]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[36]
+	{0x0F12, 0x2828}, 	 //TVAR_afit_pBaseVals[37]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[38]
+
+	{0x0F12, 0x0230}, 	 //TVAR_afit_pBaseVals[39]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[40]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[41]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[42]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[43]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[44]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[45]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[46]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[47]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[48]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[49]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[50]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[51]
+	{0x0F12, 0x0400}, 	 //TVAR_afit_pBaseVals[52]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[53]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[54]
+	{0x0F12, 0x0A00}, 	 //TVAR_afit_pBaseVals[55]
+	{0x0F12, 0x100A}, 	 //TVAR_afit_pBaseVals[56]
+	{0x0F12, 0x0150}, 	 //TVAR_afit_pBaseVals[57]
+	{0x0F12, 0x0130}, 	 //TVAR_afit_pBaseVals[58]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[59]
+	{0x0F12, 0x8032},   //805A	 //TVAR_afit_pBaseVals[60]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[61]
+	{0x0F12, 0x001C}, 	 //TVAR_afit_pBaseVals[62]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[63]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[64]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[65]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[66]
+	{0x0F12, 0x000C}, 	 //TVAR_afit_pBaseVals[67]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[68]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[69]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[70]
+	{0x0F12, 0x00A0}, 	 //TVAR_afit_pBaseVals[71]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[72]
+	{0x0F12, 0x0004}, 	 //TVAR_afit_pBaseVals[73]
+	{0x0F12, 0x0012}, 	 //TVAR_afit_pBaseVals[74]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[75]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[76]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[77]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[78]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[79]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[80]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[81]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[82]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[83]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[84]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[85]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[86]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[87]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[88]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[89]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[90]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[91]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[92]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[93]
+	{0x0F12, 0x053D}, 	 //TVAR_afit_pBaseVals[94]
+	{0x0F12, 0x0A3D}, 	 //TVAR_afit_pBaseVals[95]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[96]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[97]
+	{0x0F12, 0x0C23}, 	 //TVAR_afit_pBaseVals[98]
+	{0x0F12, 0x230C}, 	 //TVAR_afit_pBaseVals[99]
+	{0x0F12, 0x1919}, 	 //TVAR_afit_pBaseVals[100]
+	{0x0F12, 0x0303}, 	 //TVAR_afit_pBaseVals[101]
+	{0x0F12, 0x0220}, 	 //TVAR_afit_pBaseVals[102]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[103]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[104]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[105]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[106]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[107]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[108]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[109]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[110]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[111]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[112]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[113]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[114]
+	{0x0F12, 0x0400}, 	 //TVAR_afit_pBaseVals[115]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[116]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[117]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[118]
+	{0x0F12, 0x1008}, 	 //TVAR_afit_pBaseVals[119]
+	{0x0F12, 0x0160}, 	 //TVAR_afit_pBaseVals[120]
+	{0x0F12, 0x0150}, 	 //TVAR_afit_pBaseVals[121]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[122]
+	{0x0F12, 0x803C},   //8064	 //TVAR_afit_pBaseVals[123]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[124]
+	{0x0F12, 0x0016}, 	 //TVAR_afit_pBaseVals[125]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[126]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[127]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[128]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[129]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[130]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[131]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[132]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[133]
+	{0x0F12, 0x0050}, 	 //TVAR_afit_pBaseVals[134]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[135]
+	{0x0F12, 0x0003}, 	 //TVAR_afit_pBaseVals[136]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[137]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[138]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[139]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[140]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[141]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[142]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[143]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[144]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[145]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[146]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[147]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[148]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[149]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[150]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[151]  {0x0010, 0x0001},
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[152]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[153]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[154]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[155]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[156]
+	{0x0F12, 0x050A}, 	 //TVAR_afit_pBaseVals[157]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[158]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[159]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[160]
+	{0x0F12, 0x1946}, 	 //TVAR_afit_pBaseVals[161]
+	{0x0F12, 0x4619}, 	 //TVAR_afit_pBaseVals[162]
+	{0x0F12, 0x0F0F}, 	 //TVAR_afit_pBaseVals[163]
+	{0x0F12, 0x0606}, 	 //TVAR_afit_pBaseVals[164]
+	{0x0F12, 0x020F}, 	 //TVAR_afit_pBaseVals[165]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[166]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[167]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[168]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[169]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[170]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[171]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[172]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[173]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[174]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[175]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[176]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[177]
+	{0x0F12, 0x0404}, 	 //TVAR_afit_pBaseVals[178]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[179]
+	{0x0F12, 0x0402}, 	 //TVAR_afit_pBaseVals[180]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[181]
+	{0x0F12, 0x1006}, 	 //TVAR_afit_pBaseVals[182]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[183]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[184]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[185]
+	{0x0F12, 0x8046},  //0x8067	 //TVAR_afit_pBaseVals[186]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[187]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[188]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[189]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[190]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[191]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[192]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[193]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[194]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[195]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[196]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[197]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[198]
+	{0x0F12, 0x0003}, 	 //TVAR_afit_pBaseVals[199]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[200]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[201]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[202]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[203]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[204]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[205]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[206]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[207]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[208]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[209]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[210]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[211]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[212]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[213]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[214]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[215]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[216]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[217]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[218]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[219]
+	{0x0F12, 0x0505}, 	 //TVAR_afit_pBaseVals[220]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[221]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[222]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[223]
+	{0x0F12, 0x1946}, 	 //TVAR_afit_pBaseVals[224]
+	{0x0F12, 0x4619}, 	 //TVAR_afit_pBaseVals[225]
+	{0x0F12, 0x0F0F}, 	 //TVAR_afit_pBaseVals[226]
+	{0x0F12, 0x0606}, 	 //TVAR_afit_pBaseVals[227]
+	{0x0F12, 0x020F}, 	 //TVAR_afit_pBaseVals[228]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[229]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[230]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[231]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[232]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[233]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[234]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[235]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[236]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[237]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[238]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[239]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[240]
+	{0x0F12, 0x0404}, 	 //TVAR_afit_pBaseVals[241]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[242]
+	{0x0F12, 0x0402}, 	 //TVAR_afit_pBaseVals[243]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[244]
+	{0x0F12, 0x1006}, 	 //TVAR_afit_pBaseVals[245]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[246]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[247]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[248]
+	{0x0F12, 0x8046}, 	  //0x806B	 //TVAR_afit_pBaseVals[249]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[250]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[251]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[252]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[253]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[254]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[255]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[256]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[257]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[258]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[259]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[260]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[261]
+	{0x0F12, 0x0003}, 	 //TVAR_afit_pBaseVals[262]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[263]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[264]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[265]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[266]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[267]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[268]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[269]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[270]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[271]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[272]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[273]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[274]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[275]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[276]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[277]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[278]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[279]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[280]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[281]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[282]
+	{0x0F12, 0x0505}, 	 //TVAR_afit_pBaseVals[283]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[284]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[285]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[286]
+	{0x0F12, 0x1946}, 	 //TVAR_afit_pBaseVals[287]
+	{0x0F12, 0x4619}, 	 //TVAR_afit_pBaseVals[288]
+	{0x0F12, 0x0F0F}, 	 //TVAR_afit_pBaseVals[289]
+	{0x0F12, 0x0606}, 	 //TVAR_afit_pBaseVals[290]
+	{0x0F12, 0x020F}, 	 //TVAR_afit_pBaseVals[291]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[292]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[293]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[294]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[295]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[296]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[297]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[298]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[299]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[300]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[301]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[302]
+	{0x0F12, 0x0303}, 	 //TVAR_afit_pBaseVals[303]
+	{0x0F12, 0x0707}, 	 //TVAR_afit_pBaseVals[304]
+	{0x0F12, 0x0303}, 	 //TVAR_afit_pBaseVals[305]
+	{0x0F12, 0x0806}, 	 //TVAR_afit_pBaseVals[306]
+	{0x0F12, 0x0004}, 	 //TVAR_afit_pBaseVals[307]
+	{0x0F12, 0x1006}, 	 //TVAR_afit_pBaseVals[308]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[309]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[310]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[311]
+	{0x0F12, 0x8046},    //0x806B //TVAR_afit_pBaseVals[312]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[313]
+	{0x0F12, 0x0000},      ////TVAR_afit_pBaseVals[314]  	param_end	TVAR_afit_pBaseVals
+	{0x0F12, 0x03FC},
+	{0x0F12, 0x03FF},
+	{0x0F12, 0x0500},
+	{0x0F12, 0x0400},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0300},
+	{0x0F12, 0x0002},
+	{0x0F12, 0x0300},
+	{0x0F12, 0x0203},
+	{0x0F12, 0x0003},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0204},
+	{0x0F12, 0x0000},
+	{0x0F12, 0xFDD6},
+	{0x0F12, 0x43C1},
+	{0x0F12, 0xF0FA},
+	{0x0F12, 0x0001},  //	param_end	afit_pConstBaseVals
+	{0x002A, 0x06d4},  //#TVAR_wbt_pOutdoorCcm
+	{0x0F12, 0x2380},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06cc},  //#TVAR_wbt_pBaseCcms
+	{0x0F12, 0x23A4},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06e8},  //#TVAR_wbt_pBaseCcmsAddr[0]
+	{0x0F12, 0x23A4},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06EC},  //#TVAR_wbt_pBaseCcmsAddr[1]
+	{0x0F12, 0x23C8},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06f0},  //#TVAR_wbt_pBaseCcmsAddr[2]
+	{0x0F12, 0x23EC},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06f4},  //#TVAR_wbt_pBaseCcmsAddr[3]
+	{0x0F12, 0x2410},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06f8},  //#TVAR_wbt_pBaseCcmsAddr[4]
+	{0x0F12, 0x2434},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06fc},  //#TVAR_wbt_pBaseCcmsAddr[5]
+	{0x0F12, 0x2458},
+	{0x0F12, 0x7000},  // End tuning part
+
+#endif
+	{0x0028, 0x7000},
+	{0x002A, 0x0400},  //50h2
+	{0x0F12, 0x005f},
+	{0x002A, 0x03dc},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x0001},
+
+	{0x0028, 0xd000}, 	//add current
+	{0x002A, 0x1082},
+	{0x0F12, 0x03ff},
+	{0x0F12, 0x03ff},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0fff},
+	{0xFCFC, 0x7000},
+	{0x0488, 0x1A04},
+	{0x048C, 0x56B8},
+	{0x0498, 0x0500},
+	{0x049A, 0x0500},
+	{0x049C, 0x0200},
+	{0x1000, 0x0050},
+	{0x0400, 0x007F},
+	{0x01B8, 0x4e20},
+	{0x01BA, 0x0000},
+	{0x01C6, 0x0001},
+	{0x01CC, 0x1388},
+	{0x01CE, 0x1388},
+	{0x01D0, 0x1388},
+	{0x01E0, 0x0001},
+	//PREVIEW CONFIGURATION 0
+	{0x0242, 0x0500},  // 1280
+	{0x0244, 0x0400},  // 1024
+	{0x0246, 0x0005},  // FULL YUV 422
+	{0x024E, 0x0000},  // Use 1st system clock(0x01CC 01CE 01D0)
+	{0x0248, 0x1388},  // Max output rate, divided by 4 (12MHz)0bb8
+	{0x024A, 0x1388},  // Min output rate, divided by 4 (3MHz)
+	{0x024C, 0x0042},  // PVI configuration by default
+	{0x0252, 0x0002},  // Frame rate quality
+	{0x0250, 0x0000},  // Frame rate type
+	{0x0254, 0x0800},  // Required frame time ???
+	{0x0256, 0x0000},  // Minimal frame time for dynamic FR
+	{0x0262, 0x0001},  //mirror
+	{0x0264, 0x0001},  //mirror
+	//previer run
+	{0x021C, 0x0000},  // Index number of active preview configuration
+	{0x0220, 0x0001},  // Output is enabled after configuration change
+	{0x01F8, 0x0001},  // Start sending a new configuration
+	{0x021E, 0x0001},  // Synchronize FW with new preview configuration
+	{0x01F0, 0x0001},  // Enable preview output
+	{0x01F2, 0x0001},  // Synchronize FW with enable preview request
+	//input config
+	{0x020A, 0x0500},  // Preview zoom window width
+	{0x020C, 0x0400},  // Preview zoom window heigh
+	{0x01FA, 0x0500},  // Preview window width
+	{0x01FC, 0x0400},  // Preview window heigh
+	{0x01FE, 0x0000},  // Preview input window X offset
+	{0x0200, 0x0000},  // Preview input window Y offset
+	{0x021A, 0x0001},  // Synchronize FW with input values
+
+	//Capture-B
+	{SEQUENCE_FAST_SETMODE_START, 0},
+	{0xFCFC, 0x7000},
+	{0x0224, 0x0000},  // Index number of active preview configuration
+	{0x01F8, 0x0001},  // Start sending a new configuration
+	{0x0226, 0x0001},  // Index number of active preview configuration
+	{0x01F4, 0x0001},  // Start sending a new configuration
+	{0x01F6, 0x0001},  // Enable preview output
+	{SEQUENCE_WAIT_MS, 1000},
+	{SEQUENCE_FAST_SETMODE_END, 0},
+
+	{SEQUENCE_WAIT_MS, 500},   //ledebug
+	{SEQUENCE_END, 0x00}
+};
+
+/* 800X600 SVGA*/
+static struct reginfo sensor_svga[] =
+{
+    {SEQUENCE_END, 0x0},
+};
+
+/* 640X480 VGA */
+static struct reginfo sensor_vga[] =
+{
+	{0xFCFC, 0xD000},  // change page to D000 page
+	{0x0010, 0x0001},  // Reset
+	{0x1030, 0x0000},  // Clear host interrupt so main will wait
+	{0x0014, 0x0001},  // ARM go
+	{SEQUENCE_WAIT_MS, 50},
+	{0x1000, 0x0001},
+	{SEQUENCE_WAIT_MS, 10},
+	{0x0028, 0x7000}, 	// start add MSW
+	{0x002A, 0x1d60}, 	// start add LSW
+	{0x0F12, 0xb570},
+	{0x0F12, 0x4928},
+	{0x0F12, 0x4828},
+	{0x0F12, 0x2205},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf922},
+	{0x0F12, 0x4927},
+	{0x0F12, 0x2002},
+	{0x0F12, 0x83c8},
+	{0x0F12, 0x2001},
+	{0x0F12, 0x3120},
+	{0x0F12, 0x8088},
+	{0x0F12, 0x4925},
+	{0x0F12, 0x4826},
+	{0x0F12, 0x2204},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf917},
+	{0x0F12, 0x4925},
+	{0x0F12, 0x4825},
+	{0x0F12, 0x2206},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf912},
+	{0x0F12, 0x4924},
+	{0x0F12, 0x4825},
+	{0x0F12, 0x2207},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf90d},
+	{0x0F12, 0x4924},
+	{0x0F12, 0x4824},
+	{0x0F12, 0x2208},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf908},
+	{0x0F12, 0x4923},
+	{0x0F12, 0x4824},
+	{0x0F12, 0x2209},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf903},
+	{0x0F12, 0x4923},
+	{0x0F12, 0x4823},
+	{0x0F12, 0x60c1},
+	{0x0F12, 0x6882},
+	{0x0F12, 0x1a51},
+	{0x0F12, 0x8201},
+	{0x0F12, 0x4c22},
+	{0x0F12, 0x2607},
+	{0x0F12, 0x6821},
+	{0x0F12, 0x0736},
+	{0x0F12, 0x42b1},
+	{0x0F12, 0xda05},
+	{0x0F12, 0x4820},
+	{0x0F12, 0x22d8},
+	{0x0F12, 0x1c05},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8fa},
+	{0x0F12, 0x6025},
+	{0x0F12, 0x68a1},
+	{0x0F12, 0x42b1},
+	{0x0F12, 0xda07},
+	{0x0F12, 0x481b},
+	{0x0F12, 0x2224},
+	{0x0F12, 0x3824},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8f1},
+	{0x0F12, 0x4819},
+	{0x0F12, 0x3824},
+	{0x0F12, 0x60a0},
+	{0x0F12, 0x4d18},
+	{0x0F12, 0x6d29},
+	{0x0F12, 0x42b1},
+	{0x0F12, 0xda07},
+	{0x0F12, 0x4815},
+	{0x0F12, 0x228f},
+	{0x0F12, 0x00d2},
+	{0x0F12, 0x30d8},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8e3},
+	{0x0F12, 0x652c},
+	{0x0F12, 0xbc70},
+	{0x0F12, 0xbc08},
+	{0x0F12, 0x4718},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1f53},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x127b},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0398},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x1e4d},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x890d},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1e73},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x27a9},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1e91},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x27c5},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1ef7},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x285f},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x1eb3},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x28ff},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x206c},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x04ac},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x06cc},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x23a4},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0704},
+	{0x0F12, 0x7000},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0x484d},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8bb},
+	{0x0F12, 0x4a4d},
+	{0x0F12, 0x4b4d},
+	{0x0F12, 0x8811},
+	{0x0F12, 0x885b},
+	{0x0F12, 0x8852},
+	{0x0F12, 0x4359},
+	{0x0F12, 0x1889},
+	{0x0F12, 0x4288},
+	{0x0F12, 0xd800},
+	{0x0F12, 0x1c08},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xbc10},
+	{0x0F12, 0xbc08},
+	{0x0F12, 0x4718},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8b1},
+	{0x0F12, 0x4944},
+	{0x0F12, 0x8989},
+	{0x0F12, 0x4348},
+	{0x0F12, 0x0200},
+	{0x0F12, 0x0c00},
+	{0x0F12, 0x2101},
+	{0x0F12, 0x0349},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8b0},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7ed},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8b2},
+	{0x0F12, 0x6821},
+	{0x0F12, 0x0409},
+	{0x0F12, 0x0c09},
+	{0x0F12, 0x1a40},
+	{0x0F12, 0x493a},
+	{0x0F12, 0x6849},
+	{0x0F12, 0x4281},
+	{0x0F12, 0xd800},
+	{0x0F12, 0x1c08},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8af},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7dc},
+	{0x0F12, 0xb570},
+	{0x0F12, 0x6801},
+	{0x0F12, 0x040d},
+	{0x0F12, 0x0c2d},
+	{0x0F12, 0x6844},
+	{0x0F12, 0x4833},
+	{0x0F12, 0x8981},
+	{0x0F12, 0x1c28},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf893},
+	{0x0F12, 0x8060},
+	{0x0F12, 0x4932},
+	{0x0F12, 0x69c9},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8a6},
+	{0x0F12, 0x1c01},
+	{0x0F12, 0x80a0},
+	{0x0F12, 0x0228},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf8a9},
+	{0x0F12, 0x0400},
+	{0x0F12, 0x0c00},
+	{0x0F12, 0x8020},
+	{0x0F12, 0x492d},
+	{0x0F12, 0x2300},
+	{0x0F12, 0x5ec9},
+	{0x0F12, 0x4288},
+	{0x0F12, 0xda02},
+	{0x0F12, 0x20ff},
+	{0x0F12, 0x3001},
+	{0x0F12, 0x8020},
+	{0x0F12, 0xbc70},
+	{0x0F12, 0xbc08},
+	{0x0F12, 0x4718},
+	{0x0F12, 0xb570},
+	{0x0F12, 0x1c04},
+	{0x0F12, 0x4828},
+	{0x0F12, 0x4926},
+	{0x0F12, 0x7803},
+	{0x0F12, 0x6a8a},
+	{0x0F12, 0x2b00},
+	{0x0F12, 0xd100},
+	{0x0F12, 0x6a0a},
+	{0x0F12, 0x4d20},
+	{0x0F12, 0x2b00},
+	{0x0F12, 0x68a8},
+	{0x0F12, 0xd100},
+	{0x0F12, 0x6868},
+	{0x0F12, 0x6823},
+	{0x0F12, 0x8dc9},
+	{0x0F12, 0x434a},
+	{0x0F12, 0x0a12},
+	{0x0F12, 0x429a},
+	{0x0F12, 0xd30d},
+	{0x0F12, 0x4d20},
+	{0x0F12, 0x26ff},
+	{0x0F12, 0x8828},
+	{0x0F12, 0x3601},
+	{0x0F12, 0x43b0},
+	{0x0F12, 0x8028},
+	{0x0F12, 0x6820},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf884},
+	{0x0F12, 0x6020},
+	{0x0F12, 0x8828},
+	{0x0F12, 0x4330},
+	{0x0F12, 0x8028},
+	{0x0F12, 0xe7da},
+	{0x0F12, 0x1c0a},
+	{0x0F12, 0x4342},
+	{0x0F12, 0x0a12},
+	{0x0F12, 0x429a},
+	{0x0F12, 0xd304},
+	{0x0F12, 0x0218},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf871},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7f4},
+	{0x0F12, 0x6020},
+	{0x0F12, 0xe7f2},
+	{0x0F12, 0xb510},
+	{0x0F12, 0x4913},
+	{0x0F12, 0x8fc8},
+	{0x0F12, 0x2800},
+	{0x0F12, 0xd007},
+	{0x0F12, 0x2000},
+	{0x0F12, 0x87c8},
+	{0x0F12, 0x8f88},
+	{0x0F12, 0x4c11},
+	{0x0F12, 0x2800},
+	{0x0F12, 0xd002},
+	{0x0F12, 0x2008},
+	{0x0F12, 0x8020},
+	{0x0F12, 0xe77e},
+	{0x0F12, 0x480d},
+	{0x0F12, 0x3060},
+	{0x0F12, 0x8900},
+	{0x0F12, 0x2800},
+	{0x0F12, 0xd103},
+	{0x0F12, 0x480c},
+	{0x0F12, 0x2101},
+	{0x0F12, 0xf000},
+	{0x0F12, 0xf864},
+	{0x0F12, 0x2010},
+	{0x0F12, 0x8020},
+	{0x0F12, 0xe7f2},
+	{0x0F12, 0x0000},
+	{0x0F12, 0xf4b0},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x2058},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x1554},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0080},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x046c},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0468},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x1100},
+	{0x0F12, 0xd000},
+	{0x0F12, 0x01b8},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x044e},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x0450},
+	{0x0F12, 0x7000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x9ce7},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xf004},
+	{0x0F12, 0xe51f},
+	{0x0F12, 0x9fb8},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x88df},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x275d},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x1ed3},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x26f9},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x4027},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x9f03},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xf004},
+	{0x0F12, 0xe51f},
+	{0x0F12, 0xa144},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x285f},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x4778},
+	{0x0F12, 0x46c0},
+	{0x0F12, 0xc000},
+	{0x0F12, 0xe59f},
+	{0x0F12, 0xff1c},
+	{0x0F12, 0xe12f},
+	{0x0F12, 0x2001},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0xe848},
+	{0x0F12, 0x0001},
+	{0x0F12, 0xe848},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x0500},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x002A, 0x0e3a},  // #awbb_Alpha_Comp_Mode
+	{0x0F12, 0x02C2},
+	{0x002A, 0x112a},  //#senHal_SenRegsModes3_pSenModesRegsArray3[8]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1132},  //#senHal_SenRegsModes3_pSenModesRegsArray3[12]
+	{0x0F12, 0x0000},
+	{0x002A, 0x113e},  //#senHal_SenRegsModes3_pSenModesRegsArray3[18]
+	{0x0F12, 0x0000},
+	{0x002A, 0x115c},  //#senHal_SenRegsModes3_pSenModesRegsArray3[33]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1164},  //#senHal_SenRegsModes3_pSenModesRegsArray3[37]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1174},  //#senHal_SenRegsModes3_pSenModesRegsArray3[45]
+	{0x0F12, 0x0000},
+	{0x002A, 0x1178},  //#senHal_SenRegsModes3_pSenModesRegsArray3[47]
+	{0x0F12, 0x0000},
+	{0x002A, 0x077a},  //#msm_uOffsetNoBin[0][0]
+	{0x0F12, 0x0000},  //#msm_uOffsetNoBin[0][1]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[1][0]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[1][1]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[2][0]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[2][1]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[3][0]
+	{0x0F12, 0x0000}, 	//#msm_uOffsetNoBin[3][1]
+	{0x0F12, 0x0000},
+	{0x002A, 0x07a2},  //#msm_sAnalogOffset[0]
+	{0x0F12, 0x0000}, 	 //#msm_sAnalogOffset[1]
+	{0x0F12, 0x0000}, 	 //#msm_sAnalogOffset[2]
+	{0x0F12, 0x0000}, 	 //#msm_sAnalogOffset[3]
+	{0x0F12, 0x0000},
+	{0x002A, 0x07b6},  //#msm_NonLinearOfsOutput[0]
+	{0x0F12, 0x0000}, 	 //#msm_NonLinearOfsOutput[1]
+	{0x0F12, 0x0002}, 	 //#msm_NonLinearOfsOutput[2]
+	{0x0F12, 0x0004}, 	 //#msm_NonLinearOfsOutput[3]
+	{0x0F12, 0x0004}, 	 //#msm_NonLinearOfsOutput[4]
+	{0x0F12, 0x0005}, 	 //#msm_NonLinearOfsOutput[5]
+	{0x0F12, 0x0005},
+	{0x002A, 0x0712},
+	{0x0F12, 0x0149},
+	{0x0F12, 0x011B},
+	{0x0F12, 0x0120},
+	{0x0F12, 0x00EF},
+	{0x0F12, 0x00C3},
+	{0x0F12, 0x00D2},
+	{0x0F12, 0x00DC},
+	{0x0F12, 0x00B8},
+	{0x0F12, 0x0106},
+	{0x0F12, 0x00DE},
+	{0x0F12, 0x00E3},
+	{0x0F12, 0x00CC},
+	{0x0F12, 0x00BD},
+	{0x0F12, 0x00E1},
+	{0x0F12, 0x00D8},
+	{0x0F12, 0x00D0},
+	{0x0F12, 0x00BE},
+	{0x0F12, 0x00EC},
+	{0x0F12, 0x00EA},
+	{0x0F12, 0x00F2},
+	{0x0F12, 0x00BE},
+	{0x0F12, 0x00EB},
+	{0x0F12, 0x00E5},
+	{0x0F12, 0x00F9},
+	{0x0F12, 0x0100},  //0x00BE
+	{0x0F12, 0x00D5},
+	{0x0F12, 0x00D8},
+	{0x0F12, 0x00E6},
+	{0x0F12, 0x00FD},
+	{0x0F12, 0x00F7},
+	{0x0F12, 0x00F3},
+	{0x0F12, 0x00FF},
+	{0x002A, 0x075A},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x02A1},
+	{0x0F12, 0x0225},
+	{0x0F12, 0x000D},
+	{0x0F12, 0x000D},
+	{0x0028, 0x7000},
+	{0x002A, 0x04C8}, //	GammaLutRGBIndoor
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x0015},
+	{0x0F12, 0x0034},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x00ED},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0201},
+	{0x0F12, 0x0276},
+	{0x0F12, 0x0307},
+	{0x0F12, 0x0362},
+	{0x0F12, 0x03A9},
+	{0x0F12, 0x03D5},
+	{0x0F12, 0x03F4},
+	{0x0F12, 0x03FF},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x0015},
+	{0x0F12, 0x0034},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x00ED},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0201},
+	{0x0F12, 0x0276},
+	{0x0F12, 0x0307},
+	{0x0F12, 0x0362},
+	{0x0F12, 0x03A9},
+	{0x0F12, 0x03D5},
+	{0x0F12, 0x03F4},
+	{0x0F12, 0x03FF},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0004},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x0015},
+	{0x0F12, 0x0034},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x00ED},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0201},
+	{0x0F12, 0x0276},
+	{0x0F12, 0x0307},
+	{0x0F12, 0x0362},
+	{0x0F12, 0x03A9},
+	{0x0F12, 0x03D5},
+	{0x0F12, 0x03F4},
+	{0x0F12, 0x03FF},
+	{0x002A, 0x1000},	//	param_end	SARR_usGammaLutRGBIndoor
+	{0x0F12, 0x0036},
+	{0x002A, 0x108E},   // SAAR_IllumType
+	{0x0F12, 0x00C0},
+	{0x0F12, 0x00E7},
+	{0x0F12, 0x00F9},
+	{0x0F12, 0x0142},
+	{0x0F12, 0x0179},
+	{0x0F12, 0x01A4},
+	{0x0F12, 0x01B8},   //SAAR_IllumF
+	{0x0F12, 0x0112},
+	{0x0F12, 0x0122},
+	{0x0F12, 0x0136},
+	{0x0F12, 0x00F6},
+	{0x0F12, 0x0100},
+	{0x0F12, 0x00FE},
+	{0x0F12, 0x0100},
+	{0x002A, 0x1AC8},
+	{0x0F12, 0x0000},   //	param_start	TVAR_wbt_pBaseCcms
+	{0x002A, 0x23A4},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F},
+	{0x0F12, 0x0213},
+	{0x0F12, 0xFF95},
+	{0x0F12, 0xFFF6},
+	{0x0F12, 0x0067},
+	{0x0F12, 0x0118},
+	{0x0F12, 0xFF1F},
+	{0x0F12, 0xFF0A},
+	{0x0F12, 0x01A9},
+	{0x0F12, 0xFF6E},
+	{0x0F12, 0xFECE},
+	{0x0F12, 0x01C7},
+	{0x0F12, 0x012E},
+	{0x0F12, 0xFFE9},
+	{0x0F12, 0x0009},
+	{0x0F12, 0x01FD},
+	{0x0F12, 0x015B},
+	{0x0F12, 0xFF0C},
+	{0x0F12, 0x014F}, //	param_end	TVAR_wbt_pBaseCcms
+	{0x002A, 0x2380}, //	param_start	TVAR_wbt_pOutdoorCcm
+	{0x0F12, 0x01AF},
+	{0x0F12, 0xFFD5},
+	{0x0F12, 0x001D},
+	{0x0F12, 0x0080},
+	{0x0F12, 0x00BA},
+	{0x0F12, 0xFF61},
+	{0x0F12, 0xFF21},
+	{0x0F12, 0x0164},
+	{0x0F12, 0xFF96},
+	{0x0F12, 0xFF0F},
+	{0x0F12, 0x019A},
+	{0x0F12, 0x0117},
+	{0x0F12, 0xFFE8},
+	{0x0F12, 0x0041},
+	{0x0F12, 0x01C8},
+	{0x0F12, 0x0173},
+	{0x0F12, 0xFF35},
+	{0x0F12, 0x013C},   //	param_end	TVAR_wbt_pOutdoorCcm
+	{0x002A, 0x06DA},
+	{0x0F12, 0x00BF},
+	{0x0F12, 0x00E6},
+	{0x0F12, 0x00F2},
+	{0x0F12, 0x0143},
+	{0x0F12, 0x0178},
+	{0x0F12, 0x01A3},  //	param_start	SARR_uNormBrInDoor
+	{0x002A, 0x07E8},
+	{0x0F12, 0x000A},
+	{0x0F12, 0x0019},
+	{0x0F12, 0x007D},
+	{0x0F12, 0x01F4},
+	{0x0F12, 0x1388},
+#if 0//renn
+	{0x002A, 0x07D0},
+	{0x0F12, 0x0030},
+	{0x0F12, 0x0046},
+	{0x0F12, 0x0088},
+	{0x0F12, 0x0205},
+	{0x0F12, 0x02BC},
+	{0x002A, 0x07E6},
+	{0x0F12, 0x0001},
+	{0x002A, 0x0828},
+	{0x0F12, 0x000B},        //TVAR_afit_pBaseVals[0]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[1]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[2]
+	{0x0F12, 0xFFAA}, 	 //TVAR_afit_pBaseVals[3]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[4]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[5]
+	{0x0F12, 0x0032}, 	 //TVAR_afit_pBaseVals[6]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[7]
+	{0x0F12, 0x00FF}, 	 //TVAR_afit_pBaseVals[8]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[9]
+	{0x0F12, 0x0004}, 	 //TVAR_afit_pBaseVals[10]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[11]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[12]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[13]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[14]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[15]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[16]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[17]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[18]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[19]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[20]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[21]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[22]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[23]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[24]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[25]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[26]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[27]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[28]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[29]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[30]
+	{0x0F12, 0x054C}, 	 //TVAR_afit_pBaseVals[31]
+	{0x0F12, 0x0A4C}, 	 //TVAR_afit_pBaseVals[32]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[33]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[34]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[35]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[36]
+	{0x0F12, 0x2828}, 	 //TVAR_afit_pBaseVals[37]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[38]
+	{0x0F12, 0x0230}, 	 //TVAR_afit_pBaseVals[39]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[40]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[41]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[42]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[43]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[44]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[45]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[46]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[47]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[48]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[49]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[50]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[51]
+	{0x0F12, 0x0400}, 	 //TVAR_afit_pBaseVals[52]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[53]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[54]
+	{0x0F12, 0x0A00}, 	 //TVAR_afit_pBaseVals[55]
+	{0x0F12, 0x100A}, 	 //TVAR_afit_pBaseVals[56]
+	{0x0F12, 0x0150}, 	 //TVAR_afit_pBaseVals[57]
+	{0x0F12, 0x0130}, 	 //TVAR_afit_pBaseVals[58]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[59]
+	{0x0F12, 0x8032},   //805A	 //TVAR_afit_pBaseVals[60]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[61]
+	{0x0F12, 0x001C}, 	 //TVAR_afit_pBaseVals[62]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[63]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[64]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[65]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[66]
+	{0x0F12, 0x000C}, 	 //TVAR_afit_pBaseVals[67]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[68]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[69]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[70]
+	{0x0F12, 0x00A0}, 	 //TVAR_afit_pBaseVals[71]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[72]
+	{0x0F12, 0x0004}, 	 //TVAR_afit_pBaseVals[73]
+	{0x0F12, 0x0012}, 	 //TVAR_afit_pBaseVals[74]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[75]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[76]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[77]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[78]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[79]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[80]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[81]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[82]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[83]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[84]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[85]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[86]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[87]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[88]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[89]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[90]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[91]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[92]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[93]
+	{0x0F12, 0x053D}, 	 //TVAR_afit_pBaseVals[94]
+	{0x0F12, 0x0A3D}, 	 //TVAR_afit_pBaseVals[95]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[96]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[97]
+	{0x0F12, 0x0C23}, 	 //TVAR_afit_pBaseVals[98]
+	{0x0F12, 0x230C}, 	 //TVAR_afit_pBaseVals[99]
+	{0x0F12, 0x1919}, 	 //TVAR_afit_pBaseVals[100]
+	{0x0F12, 0x0303}, 	 //TVAR_afit_pBaseVals[101]
+	{0x0F12, 0x0220}, 	 //TVAR_afit_pBaseVals[102]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[103]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[104]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[105]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[106]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[107]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[108]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[109]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[110]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[111]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[112]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[113]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[114]
+	{0x0F12, 0x0400}, 	 //TVAR_afit_pBaseVals[115]
+	{0x0F12, 0x0200}, 	 //TVAR_afit_pBaseVals[116]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[117]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[118]
+	{0x0F12, 0x1008}, 	 //TVAR_afit_pBaseVals[119]
+	{0x0F12, 0x0160}, 	 //TVAR_afit_pBaseVals[120]
+	{0x0F12, 0x0150}, 	 //TVAR_afit_pBaseVals[121]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[122]
+	{0x0F12, 0x803C},   //8064	 //TVAR_afit_pBaseVals[123]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[124]
+	{0x0F12, 0x0016}, 	 //TVAR_afit_pBaseVals[125]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[126]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[127]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[128]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[129]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[130]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[131]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[132]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[133]
+	{0x0F12, 0x0050}, 	 //TVAR_afit_pBaseVals[134]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[135]
+	{0x0F12, 0x0003}, 	 //TVAR_afit_pBaseVals[136]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[137]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[138]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[139]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[140]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[141]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[142]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[143]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[144]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[145]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[146]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[147]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[148]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[149]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[150]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[151]  {0x0010, 0x0001},
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[152]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[153]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[154]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[155]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[156]
+	{0x0F12, 0x050A}, 	 //TVAR_afit_pBaseVals[157]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[158]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[159]
+	{0x0F12, 0x0203}, 	 //TVAR_afit_pBaseVals[160]
+	{0x0F12, 0x1946}, 	 //TVAR_afit_pBaseVals[161]
+	{0x0F12, 0x4619}, 	 //TVAR_afit_pBaseVals[162]
+	{0x0F12, 0x0F0F}, 	 //TVAR_afit_pBaseVals[163]
+	{0x0F12, 0x0606}, 	 //TVAR_afit_pBaseVals[164]
+	{0x0F12, 0x020F}, 	 //TVAR_afit_pBaseVals[165]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[166]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[167]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[168]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[169]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[170]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[171]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[172]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[173]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[174]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[175]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[176]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[177]
+	{0x0F12, 0x0404}, 	 //TVAR_afit_pBaseVals[178]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[179]
+	{0x0F12, 0x0402}, 	 //TVAR_afit_pBaseVals[180]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[181]
+	{0x0F12, 0x1006}, 	 //TVAR_afit_pBaseVals[182]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[183]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[184]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[185]
+	{0x0F12, 0x8046},  //0x8067	 //TVAR_afit_pBaseVals[186]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[187]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[188]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[189]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[190]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[191]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[192]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[193]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[194]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[195]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[196]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[197]
+	{0x0F12, 0x000A}, 	 //TVAR_afit_pBaseVals[198]
+	{0x0F12, 0x0003}, 	 //TVAR_afit_pBaseVals[199]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[200]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[201]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[202]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[203]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[204]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[205]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[206]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[207]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[208]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[209]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[210]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[211]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[212]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[213]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[214]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[215]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[216]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[217]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[218]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[219]
+	{0x0F12, 0x0505}, 	 //TVAR_afit_pBaseVals[220]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[221]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[222]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[223]
+	{0x0F12, 0x1946}, 	 //TVAR_afit_pBaseVals[224]
+	{0x0F12, 0x4619}, 	 //TVAR_afit_pBaseVals[225]
+	{0x0F12, 0x0F0F}, 	 //TVAR_afit_pBaseVals[226]
+	{0x0F12, 0x0606}, 	 //TVAR_afit_pBaseVals[227]
+	{0x0F12, 0x020F}, 	 //TVAR_afit_pBaseVals[228]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[229]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[230]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[231]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[232]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[233]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[234]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[235]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[236]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[237]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[238]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[239]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[240]
+	{0x0F12, 0x0404}, 	 //TVAR_afit_pBaseVals[241]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[242]
+	{0x0F12, 0x0402}, 	 //TVAR_afit_pBaseVals[243]
+	{0x0F12, 0x0002}, 	 //TVAR_afit_pBaseVals[244]
+	{0x0F12, 0x1006}, 	 //TVAR_afit_pBaseVals[245]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[246]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[247]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[248]
+	{0x0F12, 0x8046}, 	  //0x806B	 //TVAR_afit_pBaseVals[249]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[250]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[251]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[252]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[253]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[254]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[255]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[256]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[257]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[258]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[259]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[260]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[261]
+	{0x0F12, 0x0003}, 	 //TVAR_afit_pBaseVals[262]
+	{0x0F12, 0x0019}, 	 //TVAR_afit_pBaseVals[263]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[264]
+	{0x0F12, 0x0064}, 	 //TVAR_afit_pBaseVals[265]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[266]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[267]
+	{0x0F12, 0x0000}, 	 //TVAR_afit_pBaseVals[268]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[269]
+	{0x0F12, 0x000F}, 	 //TVAR_afit_pBaseVals[270]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[271]
+	{0x0F12, 0x03FF}, 	 //TVAR_afit_pBaseVals[272]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[273]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[274]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[275]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[276]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[277]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[278]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[279]
+	{0x0F12, 0x0028}, 	 //TVAR_afit_pBaseVals[280]
+	{0x0F12, 0x0106}, 	 //TVAR_afit_pBaseVals[281]
+	{0x0F12, 0x006F}, 	 //TVAR_afit_pBaseVals[282]
+	{0x0F12, 0x0505}, 	 //TVAR_afit_pBaseVals[283]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[284]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[285]
+	{0x0F12, 0x0202}, 	 //TVAR_afit_pBaseVals[286]
+	{0x0F12, 0x1946}, 	 //TVAR_afit_pBaseVals[287]
+	{0x0F12, 0x4619}, 	 //TVAR_afit_pBaseVals[288]
+	{0x0F12, 0x0F0F}, 	 //TVAR_afit_pBaseVals[289]
+	{0x0F12, 0x0606}, 	 //TVAR_afit_pBaseVals[290]
+	{0x0F12, 0x020F}, 	 //TVAR_afit_pBaseVals[291]
+	{0x0F12, 0x0480}, 	 //TVAR_afit_pBaseVals[292]
+	{0x0F12, 0x0804}, 	 //TVAR_afit_pBaseVals[293]
+	{0x0F12, 0x030A}, 	 //TVAR_afit_pBaseVals[294]
+	{0x0F12, 0x1403}, 	 //TVAR_afit_pBaseVals[295]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[296]
+	{0x0F12, 0x0014}, 	 //TVAR_afit_pBaseVals[297]
+	{0x0F12, 0x0500}, 	 //TVAR_afit_pBaseVals[298]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[299]
+	{0x0F12, 0x1414}, 	 //TVAR_afit_pBaseVals[300]
+	{0x0F12, 0x0A0A}, 	 //TVAR_afit_pBaseVals[301]
+	{0x0F12, 0x0005}, 	 //TVAR_afit_pBaseVals[302]
+	{0x0F12, 0x0303}, 	 //TVAR_afit_pBaseVals[303]
+	{0x0F12, 0x0707}, 	 //TVAR_afit_pBaseVals[304]
+	{0x0F12, 0x0303}, 	 //TVAR_afit_pBaseVals[305]
+	{0x0F12, 0x0806}, 	 //TVAR_afit_pBaseVals[306]
+	{0x0F12, 0x0004}, 	 //TVAR_afit_pBaseVals[307]
+	{0x0F12, 0x1006}, 	 //TVAR_afit_pBaseVals[308]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[309]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[310]
+	{0x0F12, 0x0100}, 	 //TVAR_afit_pBaseVals[311]
+	{0x0F12, 0x8046},    //0x806B //TVAR_afit_pBaseVals[312]
+	{0x0F12, 0x0180}, 	 //TVAR_afit_pBaseVals[313]
+	{0x0F12, 0x0000},      ////TVAR_afit_pBaseVals[314]  	param_end	TVAR_afit_pBaseVals
+	{0x0F12, 0x03FC},
+	{0x0F12, 0x03FF},
+	{0x0F12, 0x0500},
+	{0x0F12, 0x0400},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0300},
+	{0x0F12, 0x0002},
+	{0x0F12, 0x0300},
+	{0x0F12, 0x0203},
+	{0x0F12, 0x0003},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0204},
+	{0x0F12, 0x0000},
+	{0x0F12, 0xFDD6},
+	{0x0F12, 0x43C1},
+	{0x0F12, 0xF0FA},
+	{0x0F12, 0x0001},  //	param_end	afit_pConstBaseVals
+	{0x002A, 0x06d4},  //#TVAR_wbt_pOutdoorCcm
+	{0x0F12, 0x2380},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06cc},  //#TVAR_wbt_pBaseCcms
+	{0x0F12, 0x23A4},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06e8},  //#TVAR_wbt_pBaseCcmsAddr[0]
+	{0x0F12, 0x23A4},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06EC},  //#TVAR_wbt_pBaseCcmsAddr[1]
+	{0x0F12, 0x23C8},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06f0},  //#TVAR_wbt_pBaseCcmsAddr[2]
+	{0x0F12, 0x23EC},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06f4},  //#TVAR_wbt_pBaseCcmsAddr[3]
+	{0x0F12, 0x2410},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06f8},  //#TVAR_wbt_pBaseCcmsAddr[4]
+	{0x0F12, 0x2434},
+	{0x0F12, 0x7000},
+	{0x002A, 0x06fc},  //#TVAR_wbt_pBaseCcmsAddr[5]
+	{0x0F12, 0x2458},
+	{0x0F12, 0x7000},  // End tuning part
+#endif
+
+	{0x0028, 0x7000},
+	{0x002A, 0x0400},  //50h2
+	{0x0F12, 0x005f},
+	{0x002A, 0x03dc},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x0001},
+	{0x0028, 0xd000}, 	//add current
+	{0x002A, 0x1082},
+	{0x0F12, 0x03ff},
+	{0x0F12, 0x03ff},
+	{0x0F12, 0x0155},
+	{0x0F12, 0x0fff},
+	{0xFCFC, 0x7000},
+	{0x0488, 0x1A04},
+	{0x048C, 0x56B8},
+	{0x0498, 0x0500},
+	{0x049A, 0x0500},
+	{0x049C, 0x0200},
+	{0x1000, 0x0043},
+	{0x0400, 0x007F},
+	{0x01B8, 0x4e20},
+	{0x01BA, 0x0000},
+	{0x01C6, 0x0001},
+	{0x01CC, 0x1388},
+	{0x01CE, 0x1388},
+	{0x01D0, 0x1388},
+	{0x01E0, 0x0001},
+	//PREVIEW CONFIGURATION 0
+	{0x0242, 0x0280},  // 640
+	{0x0244, 0x01e0},  // 480
+	{0x0246, 0x0005},  // FULL YUV 422
+	{0x024E, 0x0000},  // Use 1st system clock(0x01CC 01CE 01D0)
+	{0x0248, 0x1388},  // Max output rate, divided by 4 (12MHz)0bb8
+	{0x024A, 0x1388},  // Min output rate, divided by 4 (3MHz)
+	{0x024C, 0x0042},  // PVI configuration by default
+	{0x0252, 0x0001},  // Frame rate quality
+	{0x0250, 0x0000},  // Frame rate type
+	{0x0254, 0x029a},  // Required frame time ???
+	{0x0256, 0x01b0},  // Minimal frame time for dynamic FR
+	{0x0262, 0x0001},  //mirror
+	{0x0264, 0x0001},  //mirror
+	//previer run
+	{0x021C, 0x0000},  // Index number of active preview configuration
+	{0x0220, 0x0001},  // Output is enabled after configuration change
+	{0x01F8, 0x0001},  // Start sending a new configuration
+	{0x021E, 0x0001},  // Synchronize FW with new preview configuration
+	{0x01F0, 0x0001},  // Enable preview output
+	{0x01F2, 0x0001},  // Synchronize FW with enable preview request
+	//capture CONFIGURATION 0
+	{0x030c, 0x0000},   //1280 1024
+	{0x030e, 0x0500},
+	{0x0310, 0x0400},
+	{0x0312, 0x0005},
+	{0x0314, 0x1388},
+	{0x0316, 0x1388},
+	{0x0318, 0x0042},
+	{0x031a, 0x0000},
+	{0x031c, 0x0000},//timetype
+	{0x031e, 0x0002},
+	{0x0320, 0x07d0},
+	{0x0322, 0x03e8},
+	//input config
+	{0x020A, 0x0500},  // Preview zoom window width
+	{0x020C, 0x0400},  // Preview zoom window heigh
+	{0x01FA, 0x0500},  // Preview window width
+	{0x01FC, 0x0400},  // Preview window heigh
+	{0x01FE, 0x0000},  // Preview input window X offset
+	{0x0200, 0x0000},  // Preview input window Y offset
+	{0x021A, 0x0001},  // Synchronize FW with input values
+
+	//Capture-B
+	 {SEQUENCE_FAST_SETMODE_START, 0},
+	 {0xFCFC, 0x7000},
+	{0x021C, 0x0000},  // Index number of active preview configuration
+	{0x0220, 0x0001},  // Output is enabled after configuration change
+	{0x01F8, 0x0001},  // Start sending a new configuration
+	{0x021E, 0x0001},  // Synchronize FW with new preview configuration
+
+	{SEQUENCE_WAIT_MS, 1000},
+	{SEQUENCE_WAIT_MS, 500},   //ledebug
+	{SEQUENCE_END, 0x00}
+};
+
+/* 352X288 CIF */
+static struct reginfo sensor_cif[] =
+{
+    {SEQUENCE_END, 0x0},
+};
+
+/* 320*240 QVGA */
+static  struct reginfo sensor_qvga[] =
+{
+    {SEQUENCE_END, 0x0},
+};
+
+/* 176X144 QCIF*/
+static struct reginfo sensor_qcif[] =
+{
+    {SEQUENCE_END, 0x0},
+};
+#if 0
+/* 160X120 QQVGA*/
+static struct reginfo s5k6aa_qqvga[] =
+{
+
+    {0x300E, 0x34},
+    {0x3011, 0x01},
+    {0x3012, 0x10},
+    {0x302a, 0x02},
+    {0x302b, 0xE6},
+    {0x306f, 0x14},
+    {0x3362, 0x90},
+
+    {0x3070, 0x5d},
+    {0x3072, 0x5d},
+    {0x301c, 0x07},
+    {0x301d, 0x07},
+
+    {0x3020, 0x01},
+    {0x3021, 0x18},
+    {0x3022, 0x00},
+    {0x3023, 0x06},
+    {0x3024, 0x06},
+    {0x3025, 0x58},
+    {0x3026, 0x02},
+    {0x3027, 0x61},
+    {0x3088, 0x00},
+    {0x3089, 0xa0},
+    {0x308a, 0x00},
+    {0x308b, 0x78},
+    {0x3316, 0x64},
+    {0x3317, 0x25},
+    {0x3318, 0x80},
+    {0x3319, 0x08},
+    {0x331a, 0x0a},
+    {0x331b, 0x07},
+    {0x331c, 0x80},
+    {0x331d, 0x38},
+    {0x3100, 0x00},
+    {0x3302, 0x11},
+
+    {SEQUENCE_END, 0x0},
+};
+
+
+
+static  struct reginfo s5k6aa_Sharpness_auto[] =
+{
+    {SEQUENCE_END, 0x00},
+};
+
+static  struct reginfo s5k6aa_Sharpness1[] =
+{
+    {0x3306, 0x08},
+    {0x3371, 0x00}
+};
+
+static  struct reginfo s5k6aa_Sharpness2[][3] =
+{
+    //Sharpness 2
+    {0x3306, 0x08},
+    {0x3371, 0x01},
+};
+
+static  struct reginfo s5k6aa_Sharpness3[] =
+{
+    //default
+    {0x3306, 0x08},
+    {0x332d, 0x02},
+};
+static  struct reginfo s5k6aa_Sharpness4[]=
+{
+    //Sharpness 4
+    {0x3306, 0x08},
+    {0x332d, 0x03},
+};
+
+static  struct reginfo s5k6aa_Sharpness5[] =
+{
+    //Sharpness 5
+    {0x3306, 0x08},
+    {0x332d, 0x04},
+};
+#endif
+
+static  struct reginfo sensor_ClrFmt_YUYV[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_ClrFmt_UYVY[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+#if CONFIG_SENSOR_WhiteBalance
+static  struct reginfo sensor_WhiteB_Auto[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static  struct reginfo sensor_WhiteB_Cloudy[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static  struct reginfo sensor_WhiteB_ClearDay[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+/* Office Colour Temperature : 3500K - 5000K  */
+static  struct reginfo sensor_WhiteB_TungstenLamp1[]=
+{
+    {SEQUENCE_END, 0x00}
+
+};
+/* Home Colour Temperature : 2500K - 3500K  */
+static  struct reginfo sensor_WhiteB_TungstenLamp2[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+static struct reginfo *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,
+    sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,
+};
+#endif
+
+#if CONFIG_SENSOR_Brightness
+static  struct reginfo sensor_Brightness0[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Brightness1[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Brightness2[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Brightness3[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Brightness4[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Brightness5[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+static struct reginfo *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,
+    sensor_Brightness4, sensor_Brightness5,NULL,
+};
+
+#endif
+
+#if CONFIG_SENSOR_Effect
+static  struct reginfo sensor_Effect_Normal[] =
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Effect_WandB[] =
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Effect_Sepia[] =
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Effect_Negative[] =
+{
+    {SEQUENCE_END, 0x00}
+};
+static  struct reginfo sensor_Effect_Bluish[] =
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Effect_Green[] =
+{
+    {SEQUENCE_END, 0x00}
+};
+static struct reginfo *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_WandB, sensor_Effect_Negative,sensor_Effect_Sepia,
+    sensor_Effect_Bluish, sensor_Effect_Green,NULL,
+};
+#endif
+#if CONFIG_SENSOR_Exposure
+static  struct reginfo sensor_Exposure0[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Exposure1[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Exposure2[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Exposure3[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Exposure4[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Exposure5[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Exposure6[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static struct reginfo *sensor_ExposureSeqe[] = {sensor_Exposure0, sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,
+    sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,NULL,
+};
+#endif
+#if CONFIG_SENSOR_Saturation
+static  struct reginfo sensor_Saturation0[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Saturation1[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Saturation2[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+static struct reginfo *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};
+
+#endif
+#if CONFIG_SENSOR_Contrast
+static  struct reginfo sensor_Contrast0[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Contrast1[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Contrast2[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Contrast3[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Contrast4[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+
+static  struct reginfo sensor_Contrast5[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_Contrast6[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+static struct reginfo *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,
+    sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,
+};
+
+#endif
+#if CONFIG_SENSOR_Mirror
+static  struct reginfo sensor_MirrorOn[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_MirrorOff[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+static struct reginfo *sensor_MirrorSeqe[] = {sensor_MirrorOff, sensor_MirrorOn,NULL,};
+#endif
+#if CONFIG_SENSOR_Flip
+static  struct reginfo sensor_FlipOn[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_FlipOff[]=
+{
+    {SEQUENCE_END, 0x00}
+};
+static struct reginfo *sensor_FlipSeqe[] = {sensor_FlipOff, sensor_FlipOn,NULL,};
+
+#endif
+#if CONFIG_SENSOR_Scene
+static  struct reginfo sensor_SceneAuto[] =
+{
+    {SEQUENCE_END, 0x00}
+};
+
+static  struct reginfo sensor_SceneNight[] =
+{
+    {SEQUENCE_END, 0x00}
+};
+static struct reginfo *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight,NULL,};
+
+#endif
+#if CONFIG_SENSOR_DigitalZoom
+static struct reginfo sensor_Zoom0[] =
+{
+    {SEQUENCE_END, 0x0},
+};
+
+static struct reginfo sensor_Zoom1[] =
+{
+     {SEQUENCE_END, 0x0},
+};
+
+static struct reginfo sensor_Zoom2[] =
+{
+    {SEQUENCE_END, 0x0},
+};
+
+
+static struct reginfo sensor_Zoom3[] =
+{
+    {SEQUENCE_END, 0x0},
+};
+static struct reginfo *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL,};
+#endif
+static const struct v4l2_querymenu sensor_menus[] =
+{
+	#if CONFIG_SENSOR_WhiteBalance
+    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 0,  .name = "auto",  .reserved = 0, }, {  .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 1, .name = "incandescent",  .reserved = 0,},
+    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 2,  .name = "fluorescent", .reserved = 0,}, {  .id = V4L2_CID_DO_WHITE_BALANCE, .index = 3,  .name = "daylight", .reserved = 0,},
+    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 4,  .name = "cloudy-daylight", .reserved = 0,},
+    #endif
+
+	#if CONFIG_SENSOR_Effect
+    { .id = V4L2_CID_EFFECT,  .index = 0,  .name = "none",  .reserved = 0, }, {  .id = V4L2_CID_EFFECT,  .index = 1, .name = "mono",  .reserved = 0,},
+    { .id = V4L2_CID_EFFECT,  .index = 2,  .name = "negative", .reserved = 0,}, {  .id = V4L2_CID_EFFECT, .index = 3,  .name = "sepia", .reserved = 0,},
+    { .id = V4L2_CID_EFFECT,  .index = 4, .name = "posterize", .reserved = 0,} ,{ .id = V4L2_CID_EFFECT,  .index = 5,  .name = "aqua", .reserved = 0,},
+    #endif
+
+	#if CONFIG_SENSOR_Scene
+    { .id = V4L2_CID_SCENE,  .index = 0, .name = "auto", .reserved = 0,} ,{ .id = V4L2_CID_SCENE,  .index = 1,  .name = "night", .reserved = 0,},
+    #endif
+
+	#if CONFIG_SENSOR_Flash
+    { .id = V4L2_CID_FLASH,  .index = 0,  .name = "off",  .reserved = 0, }, {  .id = V4L2_CID_FLASH,  .index = 1, .name = "auto",  .reserved = 0,},
+    { .id = V4L2_CID_FLASH,  .index = 2,  .name = "on", .reserved = 0,}, {  .id = V4L2_CID_FLASH, .index = 3,  .name = "torch", .reserved = 0,},
+    #endif
+};
+
+static const struct v4l2_queryctrl sensor_controls[] =
+{
+	#if CONFIG_SENSOR_WhiteBalance
+    {
+        .id		= V4L2_CID_DO_WHITE_BALANCE,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "White Balance Control",
+        .minimum	= 0,
+        .maximum	= 4,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Brightness
+	{
+        .id		= V4L2_CID_BRIGHTNESS,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Brightness Control",
+        .minimum	= -3,
+        .maximum	= 2,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Effect
+	{
+        .id		= V4L2_CID_EFFECT,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "Effect Control",
+        .minimum	= 0,
+        .maximum	= 5,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+
+	#if CONFIG_SENSOR_Exposure
+	{
+        .id		= V4L2_CID_EXPOSURE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Exposure Control",
+        .minimum	= 0,
+        .maximum	= 6,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+
+	#if CONFIG_SENSOR_Saturation
+	{
+        .id		= V4L2_CID_SATURATION,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Saturation Control",
+        .minimum	= 0,
+        .maximum	= 2,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Contrast
+	{
+        .id		= V4L2_CID_CONTRAST,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Contrast Control",
+        .minimum	= -3,
+        .maximum	= 3,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+
+	#if CONFIG_SENSOR_Mirror
+	{
+        .id		= V4L2_CID_HFLIP,
+        .type		= V4L2_CTRL_TYPE_BOOLEAN,
+        .name		= "Mirror Control",
+        .minimum	= 0,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 1,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Flip
+	{
+        .id		= V4L2_CID_VFLIP,
+        .type		= V4L2_CTRL_TYPE_BOOLEAN,
+        .name		= "Flip Control",
+        .minimum	= 0,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 1,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Scene
+    {
+        .id		= V4L2_CID_SCENE,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "Scene Control",
+        .minimum	= 0,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_DigitalZoom
+    {
+        .id		= V4L2_CID_ZOOM_RELATIVE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "DigitalZoom Control",
+        .minimum	= -1,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 0,
+    }, {
+        .id		= V4L2_CID_ZOOM_ABSOLUTE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "DigitalZoom Control",
+        .minimum	= 0,
+        .maximum	= 3,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Focus
+	{
+        .id		= V4L2_CID_FOCUS_RELATIVE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Focus Control",
+        .minimum	= -1,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 0,
+    }, {
+        .id		= V4L2_CID_FOCUS_ABSOLUTE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Focus Control",
+        .minimum	= 0,
+        .maximum	= 255,
+        .step		= 1,
+        .default_value = 125,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Flash
+	{
+        .id		= V4L2_CID_FLASH,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "Flash Control",
+        .minimum	= 0,
+        .maximum	= 3,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+};
+
+static int sensor_probe(struct i2c_client *client, const struct i2c_device_id *did);
+static int sensor_video_probe(struct soc_camera_device *icd, struct i2c_client *client);
+static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+static int sensor_g_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
+static int sensor_s_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
+static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);
+static int sensor_resume(struct soc_camera_device *icd);
+static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);
+static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);
+
+static struct soc_camera_ops sensor_ops =
+{
+    .suspend                     = sensor_suspend,
+    .resume                       = sensor_resume,
+    .set_bus_param		= sensor_set_bus_param,
+    .query_bus_param	= sensor_query_bus_param,
+    .controls		= sensor_controls,
+    .menus                         = sensor_menus,
+    .num_controls		= ARRAY_SIZE(sensor_controls),
+    .num_menus		= ARRAY_SIZE(sensor_menus),
+};
+
+#define COL_FMT(_name, _depth, _fourcc, _colorspace) \
+	{ .name = _name, .depth = _depth, .fourcc = _fourcc, \
+	.colorspace = _colorspace }
+
+#define JPG_FMT(_name, _depth, _fourcc) \
+	COL_FMT(_name, _depth, _fourcc, V4L2_COLORSPACE_JPEG)
+
+static const struct soc_camera_data_format sensor_colour_formats[] = {
+	JPG_FMT(SENSOR_NAME_STRING(YUYV), 16, V4L2_PIX_FMT_YUYV),
+};
+
+typedef struct sensor_info_priv_s
+{
+    int whiteBalance;
+    int brightness;
+    int contrast;
+    int saturation;
+    int effect;
+    int scene;
+    int digitalzoom;
+    int focus;
+    int flash;
+    int exposure;
+    unsigned char mirror;                                        /* HFLIP */
+    unsigned char flip;                                          /* VFLIP */
+    unsigned int winseqe_cur_addr;
+	unsigned int pixfmt;
+
+} sensor_info_priv_t;
+
+struct sensor
+{
+    struct v4l2_subdev subdev;
+    struct i2c_client *client;
+    sensor_info_priv_t info_priv;
+    int model;	/* V4L2_IDENT_OV* codes from v4l2-chip-ident.h */
+};
+
+static struct sensor* to_sensor(const struct i2c_client *client)
+{
+    return container_of(i2c_get_clientdata(client), struct sensor, subdev);
+}
+
+/* sensor register write */
+static int sensor_write(struct i2c_client *client, u16 reg, u16 val)
+{
+    u8 buf[4];
+    struct i2c_msg msg[1];
+    int err = 0;
+
+	if(reg != SEQUENCE_WAIT_MS) {
+    	buf[0] = reg >> 8;
+    	buf[1] = reg & 0xFF;
+    	buf[2] = val>> 8;
+    	buf[3] = val & 0xFF;
+
+    	msg->addr = client->addr;
+    	msg->flags = client->flags;
+    	msg->buf = buf;
+    	msg->len = sizeof(buf);
+    	msg->scl_rate = CONFIG_SENSOR_I2C_SPEED;         /* ddl@rock-chips.com : 100kHz */
+    	msg->read_type = 0;               /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */
+
+    	err = i2c_transfer(client->adapter, msg, 1);
+		if (err < 0) {
+			SENSOR_TR("%s write reg(0x%x val:0x%x) failed!",SENSOR_NAME_STRING(),reg,val);
+		}
+	} else {
+   	 	msleep(val);
+	}
+
+    return err;
+}
+
+/* sensor register read */
+static int sensor_read(struct i2c_client *client, u16 reg, u16 *val)
+{
+	u8 buf[2];
+	struct i2c_msg msg[2];
+	int err = 0;
+
+	buf[0] = (u8)reg >> 8;
+	buf[1] = (u8)reg & 0xFF;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = buf;
+	msg[0].len = sizeof(buf);
+	msg[0].scl_rate = CONFIG_SENSOR_I2C_SPEED;       /* ddl@rock-chips.com : 100kHz */
+	msg[0].read_type = 2;   /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags|I2C_M_RD;
+	msg[1].buf = buf;
+	msg[1].len = sizeof(buf);
+	msg[1].scl_rate = CONFIG_SENSOR_I2C_SPEED;                       /* ddl@rock-chips.com : 100kHz */
+	msg[1].read_type = 2;                             /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	if(err >= 0) {
+		*val = (buf[0] << 8)|(buf[1] & 0xFF);
+		SENSOR_DG("%s read reg(0x%x val:0x%x) success\n",SENSOR_NAME_STRING(),reg,*val);
+		return 0;
+	} else {
+		SENSOR_TR("%s read reg(0x%x) failed!",SENSOR_NAME_STRING(),reg);
+	}
+
+	return err;
+}
+
+/* write a array of registers  */
+static int sensor_write_array(struct i2c_client *client, struct reginfo *regarray)
+{
+    int err, cnt;
+    int i = 0;
+    u16 val00;
+
+	cnt = 0;
+    while (regarray[i].reg != SEQUENCE_END) {
+        err = sensor_write(client, regarray[i].reg, regarray[i].val);
+        if (err < 0) {
+            if (cnt-- > 0) {
+			    SENSOR_TR("%s..write failed current reg:0x%x, Write array again !\n", SENSOR_NAME_STRING(),regarray[i].reg);
+				i = 0;
+				continue;
+            } else {
+                SENSOR_TR("%s..write array failed!!!\n", SENSOR_NAME_STRING());
+                return -EPERM;
+            }
+        } else {
+            sensor_read(client, regarray[i].reg, &val00);
+            if (val00 != regarray[i].val) {
+            	SENSOR_TR("%s write reg(0x%x val:0x%x) fail\n",SENSOR_NAME_STRING(),regarray[i].reg,val00);	
+            }	
+        }
+        	
+        	
+        i++;
+    }
+    return 0;
+}
+
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+    struct i2c_client *client = sd->priv;
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct sensor *sensor = to_sensor(client);
+	const struct v4l2_queryctrl *qctrl;
+    u16 value;
+    int ret,pid = 0;
+
+    SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
+	#if 0
+    /* soft reset */
+    ret = sensor_write(client, 0x001a, 0x0011);
+    if (ret != 0)
+    {
+        SENSOR_TR("%s soft reset sensor failed\n",SENSOR_NAME_STRING());
+        ret = -ENODEV;
+		goto sensor_INIT_ERR;
+    }
+
+    mdelay(5);  //delay 5 microseconds
+
+
+	/* check if it is an sensor sensor */
+    ret = sensor_read(client, 0x015a, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id high byte failed\n");
+        ret = -ENODEV;
+        goto sensor_INIT_ERR;
+    }
+    pid = value;
+    SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+    if (pid == SENSOR_ID) {
+        sensor->model = SENSOR_V4L2_IDENT;
+    } else {
+        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+        ret = -ENODEV;
+        goto sensor_INIT_ERR;
+    }
+	#endif
+
+    ret = sensor_write_array(client, sensor_init_data);
+    if (ret != 0)
+    {
+        SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
+        goto sensor_INIT_ERR;
+    }
+
+    icd->user_width = SENSOR_INIT_WIDTH;
+    icd->user_height = SENSOR_INIT_HEIGHT;
+    sensor->info_priv.winseqe_cur_addr  = (int)SENSOR_INIT_WINSEQADR;
+	sensor->info_priv.pixfmt = SENSOR_INIT_PIXFMT;
+
+    /* sensor sensor information for initialization  */
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
+	if (qctrl)
+    	sensor->info_priv.whiteBalance = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_BRIGHTNESS);
+	if (qctrl)
+    	sensor->info_priv.brightness = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
+	if (qctrl)
+    	sensor->info_priv.effect = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EXPOSURE);
+	if (qctrl)
+        sensor->info_priv.exposure = qctrl->default_value;
+
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SATURATION);
+	if (qctrl)
+        sensor->info_priv.saturation = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_CONTRAST);
+	if (qctrl)
+        sensor->info_priv.contrast = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_HFLIP);
+	if (qctrl)
+        sensor->info_priv.mirror = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_VFLIP);
+	if (qctrl)
+        sensor->info_priv.flip = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SCENE);
+	if (qctrl)
+        sensor->info_priv.scene = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
+	if (qctrl)
+        sensor->info_priv.digitalzoom = qctrl->default_value;
+
+    /* ddl@rock-chips.com : if sensor support auto focus and flash, programer must run focus and flash code  */
+	#if CONFIG_SENSOR_Focus
+    sensor_set_focus();
+    qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FOCUS_ABSOLUTE);
+	if (qctrl)
+        sensor->info_priv.focus = qctrl->default_value;
+	#endif
+
+	#if CONFIG_SENSOR_Flash
+	sensor_set_flash();
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FLASH);
+	if (qctrl)
+        sensor->info_priv.flash = qctrl->default_value;
+    #endif
+
+    SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),__FUNCTION__,icd->user_width,icd->user_height);
+
+    return 0;
+sensor_INIT_ERR:
+    return ret;
+}
+
+static int sensor_deactivate(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = sd->priv;
+
+	SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
+
+	/* ddl@rock-chips.com : all sensor output pin must change to input for other sensor */
+
+	return 0;
+}
+
+static  struct reginfo sensor_power_down_sequence[]=
+{
+    {SEQUENCE_END,0x00}
+};
+static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)
+{
+    int ret;
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct soc_camera_link *icl;
+
+
+    if (pm_msg.event == PM_EVENT_SUSPEND)
+    {
+        SENSOR_DG("\n %s Enter Suspend.. \n", SENSOR_NAME_STRING());
+        ret = sensor_write_array(client, sensor_power_down_sequence) ;
+        if (ret != 0)
+        {
+            SENSOR_TR("\n %s..%s WriteReg Fail.. \n", SENSOR_NAME_STRING(),__FUNCTION__);
+            return ret;
+        }
+        else
+        {
+            icl = to_soc_camera_link(icd);
+            if (icl->power) {
+                ret = icl->power(icd->pdev, 0);
+                if (ret < 0) {
+				    SENSOR_TR("\n %s suspend fail for turn on power!\n", SENSOR_NAME_STRING());
+                    return -EINVAL;
+                }
+            }
+        }
+    }
+    else
+    {
+        SENSOR_TR("\n %s cann't suppout Suspend..\n",SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+    return 0;
+}
+
+static int sensor_resume(struct soc_camera_device *icd)
+{
+    struct soc_camera_link *icl;
+    int ret;
+
+    icl = to_soc_camera_link(icd);
+    if (icl->power) {
+        ret = icl->power(icd->pdev, 1);
+        if (ret < 0) {
+			SENSOR_TR("\n %s resume fail for turn on power!\n", SENSOR_NAME_STRING());
+            return -EINVAL;
+        }
+    }
+
+	SENSOR_DG("\n %s Enter Resume.. \n", SENSOR_NAME_STRING());
+
+    return 0;
+
+}
+
+static int sensor_set_bus_param(struct soc_camera_device *icd,
+                                unsigned long flags)
+{
+    return 0;
+}
+
+static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
+{
+    struct soc_camera_link *icl = to_soc_camera_link(icd);
+    unsigned long flags = SENSOR_BUS_PARAM;
+
+    return soc_camera_apply_sensor_flags(icl, flags);
+}
+
+static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+{
+    struct i2c_client *client = sd->priv;
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct sensor *sensor = to_sensor(client);
+    struct v4l2_pix_format *pix = &f->fmt.pix;
+
+    pix->width		= icd->user_width;
+    pix->height		= icd->user_height;
+    pix->pixelformat	= sensor->info_priv.pixfmt;
+    pix->field		= V4L2_FIELD_NONE;
+    pix->colorspace		= V4L2_COLORSPACE_JPEG;
+
+    return 0;
+}
+static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+{
+    struct i2c_client *client = sd->priv;
+    struct sensor *sensor = to_sensor(client);
+    struct v4l2_pix_format *pix = &f->fmt.pix;
+    struct reginfo *winseqe_set_addr=NULL;
+    int ret=0, set_w,set_h;
+
+	if (sensor->info_priv.pixfmt != pix->pixelformat) {
+		switch (pix->pixelformat)
+		{
+			case V4L2_PIX_FMT_YUYV:
+			{
+				winseqe_set_addr = sensor_ClrFmt_YUYV;
+				break;
+			}
+			case V4L2_PIX_FMT_UYVY:
+			{
+				winseqe_set_addr = sensor_ClrFmt_UYVY;
+				break;
+			}
+			default:
+				break;
+		}
+		if (winseqe_set_addr != NULL) {
+            sensor_write_array(client, winseqe_set_addr);
+			sensor->info_priv.pixfmt = pix->pixelformat;
+
+			SENSOR_DG("%s Pixelformat(0x%x) set success!\n", SENSOR_NAME_STRING(),pix->pixelformat);
+		} else {
+			SENSOR_TR("%s Pixelformat(0x%x) is invalidate!\n", SENSOR_NAME_STRING(),pix->pixelformat);
+		}
+	}
+
+    set_w = pix->width;
+    set_h = pix->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && (sensor_qcif[0].reg != SEQUENCE_END))
+	{
+		winseqe_set_addr = sensor_qcif;
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && (sensor_qvga[0].reg != SEQUENCE_END))
+    {
+        winseqe_set_addr = sensor_qvga;
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && (sensor_cif[0].reg != SEQUENCE_END))
+    {
+        winseqe_set_addr = sensor_cif;
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && (sensor_vga[0].reg != SEQUENCE_END))
+    {
+        winseqe_set_addr = sensor_vga;
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && (sensor_svga[0].reg != SEQUENCE_END))
+    {
+        winseqe_set_addr = sensor_svga;
+        set_w = 800;
+        set_h = 600;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && (sensor_sxga[0].reg != SEQUENCE_END))
+    {
+        winseqe_set_addr = sensor_sxga;
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else
+    {
+        winseqe_set_addr = SENSOR_INIT_WINSEQADR;               /* ddl@rock-chips.com : Sensor output smallest size if  isn't support app  */
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;
+		ret = -1;
+		SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,pix->width,pix->height);
+    }
+
+    if ((int)winseqe_set_addr  != sensor->info_priv.winseqe_cur_addr)
+    {
+        ret |= sensor_write_array(client, winseqe_set_addr);
+        if (ret != 0) {
+            SENSOR_TR("%s set format capability failed\n", SENSOR_NAME_STRING());
+            goto sensor_s_fmt_end;
+        }
+
+        sensor->info_priv.winseqe_cur_addr  = (int)winseqe_set_addr;
+
+
+        SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),__FUNCTION__,set_w,set_h);
+    }
+    else
+    {
+        SENSOR_TR("\n %s .. Current Format is validate. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),set_w,set_h);
+    }
+
+	pix->width = set_w;
+    pix->height = set_h;
+
+sensor_s_fmt_end:
+    return ret;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+{
+    struct v4l2_pix_format *pix = &f->fmt.pix;
+	int set_w,set_h;
+    bool bayer = pix->pixelformat == V4L2_PIX_FMT_UYVY ||
+        pix->pixelformat == V4L2_PIX_FMT_YUYV;
+
+    /*
+    * With Bayer format enforce even side lengths, but let the user play
+    * with the starting pixel
+    */
+
+    if (pix->height > SENSOR_MAX_HEIGHT)
+        pix->height = SENSOR_MAX_HEIGHT;
+    else if (pix->height < SENSOR_MIN_HEIGHT)
+        pix->height = SENSOR_MIN_HEIGHT;
+    else if (bayer)
+        pix->height = ALIGN(pix->height, 2);
+
+    if (pix->width > SENSOR_MAX_WIDTH)
+        pix->width = SENSOR_MAX_WIDTH;
+    else if (pix->width < SENSOR_MIN_WIDTH)
+        pix->width = SENSOR_MIN_WIDTH;
+    else if (bayer)
+        pix->width = ALIGN(pix->width, 2);
+
+
+    return 0;
+}
+
+ static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
+{
+    struct i2c_client *client = sd->priv;
+
+    if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
+        return -EINVAL;
+
+    if (id->match.addr != client->addr)
+        return -ENODEV;
+
+    id->ident = SENSOR_V4L2_IDENT;      /* ddl@rock-chips.com :  Return s5k6aa  identifier */
+    id->revision = 0;
+
+    return 0;
+}
+#if CONFIG_SENSOR_Brightness
+static int sensor_set_brightness(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_BrightnessSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_BrightnessSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Effect
+static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_EffectSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_EffectSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Exposure
+static int sensor_set_exposure(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_ExposureSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_ExposureSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Saturation
+static int sensor_set_saturation(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_SaturationSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_SaturationSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Contrast
+static int sensor_set_contrast(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_ContrastSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_ContrastSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Mirror
+static int sensor_set_mirror(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_MirrorSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_MirrorSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Flip
+static int sensor_set_flip(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_FlipSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_FlipSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Scene
+static int sensor_set_scene(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_SceneSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_SceneSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_WhiteBalance
+static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_WhiteBalanceSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_WhiteBalanceSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_DigitalZoom
+static int sensor_set_digitalzoom(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int *value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct sensor *sensor = to_sensor(client);
+	const struct v4l2_queryctrl *qctrl_info;
+    int digitalzoom_cur, digitalzoom_total;
+
+	qctrl_info = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
+	if (qctrl_info)
+		return -EINVAL;
+
+    digitalzoom_cur = sensor->info_priv.digitalzoom;
+    digitalzoom_total = qctrl_info->maximum;
+
+    if ((*value > 0) && (digitalzoom_cur >= digitalzoom_total))
+    {
+        SENSOR_TR("%s digitalzoom is maximum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
+        return -EINVAL;
+    }
+
+    if  ((*value < 0) && (digitalzoom_cur <= qctrl_info->minimum))
+    {
+        SENSOR_TR("%s digitalzoom is minimum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
+        return -EINVAL;
+    }
+
+    if ((*value > 0) && ((digitalzoom_cur + *value) > digitalzoom_total))
+    {
+        *value = digitalzoom_total - digitalzoom_cur;
+    }
+
+    if ((*value < 0) && ((digitalzoom_cur + *value) < 0))
+    {
+        *value = 0 - digitalzoom_cur;
+    }
+
+    digitalzoom_cur += *value;
+
+    if (sensor_ZoomSeqe[digitalzoom_cur] != NULL)
+    {
+        if (sensor_write_array(client, sensor_ZoomSeqe[digitalzoom_cur]) != 0)
+        {
+            SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+            return -EINVAL;
+        }
+        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, *value);
+        return 0;
+    }
+
+    return -EINVAL;
+}
+#endif
+static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+    struct i2c_client *client = sd->priv;
+    struct sensor *sensor = to_sensor(client);
+    const struct v4l2_queryctrl *qctrl;
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
+        return -EINVAL;
+    }
+
+    switch (ctrl->id)
+    {
+        case V4L2_CID_BRIGHTNESS:
+            {
+                ctrl->value = sensor->info_priv.brightness;
+                break;
+            }
+        case V4L2_CID_SATURATION:
+            {
+                ctrl->value = sensor->info_priv.saturation;
+                break;
+            }
+        case V4L2_CID_CONTRAST:
+            {
+                ctrl->value = sensor->info_priv.contrast;
+                break;
+            }
+        case V4L2_CID_DO_WHITE_BALANCE:
+            {
+                ctrl->value = sensor->info_priv.whiteBalance;
+                break;
+            }
+        case V4L2_CID_EXPOSURE:
+            {
+                ctrl->value = sensor->info_priv.exposure;
+                break;
+            }
+        case V4L2_CID_HFLIP:
+            {
+                ctrl->value = sensor->info_priv.mirror;
+                break;
+            }
+        case V4L2_CID_VFLIP:
+            {
+                ctrl->value = sensor->info_priv.flip;
+                break;
+            }
+        default :
+                break;
+    }
+    return 0;
+}
+
+
+
+static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+    struct i2c_client *client = sd->priv;
+    struct sensor *sensor = to_sensor(client);
+    struct soc_camera_device *icd = client->dev.platform_data;
+    const struct v4l2_queryctrl *qctrl;
+
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
+        return -EINVAL;
+    }
+
+    switch (ctrl->id)
+    {
+#if CONFIG_SENSOR_Brightness
+        case V4L2_CID_BRIGHTNESS:
+            {
+                if (ctrl->value != sensor->info_priv.brightness)
+                {
+                    if (sensor_set_brightness(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.brightness = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Exposure
+        case V4L2_CID_EXPOSURE:
+            {
+                if (ctrl->value != sensor->info_priv.exposure)
+                {
+                    if (sensor_set_exposure(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.exposure = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Saturation
+        case V4L2_CID_SATURATION:
+            {
+                if (ctrl->value != sensor->info_priv.saturation)
+                {
+                    if (sensor_set_saturation(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.saturation = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Contrast
+        case V4L2_CID_CONTRAST:
+            {
+                if (ctrl->value != sensor->info_priv.contrast)
+                {
+                    if (sensor_set_contrast(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.contrast = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_WhiteBalance
+        case V4L2_CID_DO_WHITE_BALANCE:
+            {
+                if (ctrl->value != sensor->info_priv.whiteBalance)
+                {
+                    if (sensor_set_whiteBalance(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.whiteBalance = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Mirror
+        case V4L2_CID_HFLIP:
+            {
+                if (ctrl->value != sensor->info_priv.mirror)
+                {
+                    if (sensor_set_mirror(icd, qctrl,ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.mirror = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Flip
+        case V4L2_CID_VFLIP:
+            {
+                if (ctrl->value != sensor->info_priv.flip)
+                {
+                    if (sensor_set_flip(icd, qctrl,ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.flip = ctrl->value;
+                }
+                break;
+            }
+#endif
+        default:
+            break;
+    }
+
+    return 0;
+}
+static int sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)
+{
+    const struct v4l2_queryctrl *qctrl;
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct sensor *sensor = to_sensor(client);
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
+        return -EINVAL;
+    }
+
+    switch (ext_ctrl->id)
+    {
+        case V4L2_CID_SCENE:
+            {
+                ext_ctrl->value = sensor->info_priv.scene;
+                break;
+            }
+        case V4L2_CID_EFFECT:
+            {
+                ext_ctrl->value = sensor->info_priv.effect;
+                break;
+            }
+        case V4L2_CID_ZOOM_ABSOLUTE:
+            {
+                ext_ctrl->value = sensor->info_priv.digitalzoom;
+                break;
+            }
+        case V4L2_CID_ZOOM_RELATIVE:
+            {
+                return -EINVAL;
+            }
+        case V4L2_CID_FOCUS_ABSOLUTE:
+            {
+                ext_ctrl->value = sensor->info_priv.focus;
+                break;
+            }
+        case V4L2_CID_FOCUS_RELATIVE:
+            {
+                return -EINVAL;
+            }
+        case V4L2_CID_FLASH:
+            {
+                ext_ctrl->value = sensor->info_priv.flash;
+                break;
+            }
+        default :
+            break;
+    }
+    return 0;
+}
+static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)
+{
+    const struct v4l2_queryctrl *qctrl;
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct sensor *sensor = to_sensor(client);
+    int val_offset;
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
+        return -EINVAL;
+    }
+
+	val_offset = 0;
+    switch (ext_ctrl->id)
+    {
+#if CONFIG_SENSOR_Scene
+        case V4L2_CID_SCENE:
+            {
+                if (ext_ctrl->value != sensor->info_priv.scene)
+                {
+                    if (sensor_set_scene(icd, qctrl,ext_ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.scene = ext_ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Effect
+        case V4L2_CID_EFFECT:
+            {
+                if (ext_ctrl->value != sensor->info_priv.effect)
+                {
+                    if (sensor_set_effect(icd, qctrl,ext_ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.effect= ext_ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_DigitalZoom
+        case V4L2_CID_ZOOM_ABSOLUTE:
+            {
+                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
+                    return -EINVAL;
+
+                if (ext_ctrl->value != sensor->info_priv.digitalzoom)
+                {
+                    val_offset = ext_ctrl->value -sensor->info_priv.digitalzoom;
+
+                    if (sensor_set_digitalzoom(icd, qctrl,&val_offset) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.digitalzoom += val_offset;
+
+                    SENSOR_DG("%s digitalzoom is %x\n",SENSOR_NAME_STRING(),  sensor->info_priv.digitalzoom);
+                }
+
+                break;
+            }
+        case V4L2_CID_ZOOM_RELATIVE:
+            {
+                if (ext_ctrl->value)
+                {
+                    if (sensor_set_digitalzoom(icd, qctrl,&ext_ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.digitalzoom += ext_ctrl->value;
+
+                    SENSOR_DG("%s digitalzoom is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.digitalzoom);
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Focus
+        case V4L2_CID_FOCUS_ABSOLUTE:
+            {
+                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
+                    return -EINVAL;
+
+                if (ext_ctrl->value != sensor->info_priv.focus)
+                {
+                    val_offset = ext_ctrl->value -sensor->info_priv.focus;
+
+                    sensor->info_priv.focus += val_offset;
+                }
+
+                break;
+            }
+        case V4L2_CID_FOCUS_RELATIVE:
+            {
+                if (ext_ctrl->value)
+                {
+                    sensor->info_priv.focus += ext_ctrl->value;
+
+                    SENSOR_DG("%s focus is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.focus);
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Flash
+        case V4L2_CID_FLASH:
+            {
+                sensor->info_priv.flash = ext_ctrl->value;
+
+                SENSOR_DG("%s flash is %x\n",SENSOR_NAME_STRING(), sensor->info_priv.flash);
+                break;
+            }
+#endif
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
+{
+    struct i2c_client *client = sd->priv;
+    struct soc_camera_device *icd = client->dev.platform_data;
+    int i, error_cnt=0, error_idx=-1;
+
+
+    for (i=0; i<ext_ctrl->count; i++) {
+        if (sensor_g_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
+            error_cnt++;
+            error_idx = i;
+        }
+    }
+
+    if (error_cnt > 1)
+        error_idx = ext_ctrl->count;
+
+    if (error_idx != -1) {
+        ext_ctrl->error_idx = error_idx;
+        return -EINVAL;
+    } else {
+        return 0;
+    }
+}
+
+static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
+{
+    struct i2c_client *client = sd->priv;
+    struct soc_camera_device *icd = client->dev.platform_data;
+    int i, error_cnt=0, error_idx=-1;
+
+
+    for (i=0; i<ext_ctrl->count; i++) {
+        if (sensor_s_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
+            error_cnt++;
+            error_idx = i;
+        }
+    }
+
+    if (error_cnt > 1)
+        error_idx = ext_ctrl->count;
+
+    if (error_idx != -1) {
+        ext_ctrl->error_idx = error_idx;
+        return -EINVAL;
+    } else {
+        return 0;
+    }
+}
+
+/* Interface active, can use i2c. If it fails, it can indeed mean, that
+ * this wasn't our capture interface, so, we wait for the right one */
+static int sensor_video_probe(struct soc_camera_device *icd,
+			       struct i2c_client *client)
+{
+    u16 value;
+    int ret,pid = 0;
+    struct sensor *sensor = to_sensor(client);
+
+    /* We must have a parent by now. And it cannot be a wrong one.
+     * So this entire test is completely redundant. */
+    if (!icd->dev.parent ||
+	    to_soc_camera_host(icd->dev.parent)->nr != icd->iface)
+		return -ENODEV;
+	#if 0
+    /* soft reset */
+    ret = sensor_write(client, 0x001a, 0x0011);
+    if (ret != 0)
+    {
+        SENSOR_TR("%s soft reset sensor failed\n",SENSOR_NAME_STRING());
+        ret = -ENODEV;
+	goto sensor_video_probe_err;
+    }
+
+    mdelay(5);  //delay 5 microseconds
+
+	/* check if it is an sensor sensor */
+	sensor_write(client, 0xFCFC, 0x7000);
+    ret = sensor_read(client, 0x015a, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id high byte failed\n");
+        ret = -ENODEV;
+        goto sensor_video_probe_err;
+    }
+    pid = value;
+    SENSOR_DG("\n %s .. pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+    if (pid == SENSOR_ID) {
+        sensor->model = SENSOR_V4L2_IDENT;
+    } else {
+        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+        ret = -ENODEV;
+        goto sensor_video_probe_err;
+    }
+    #endif
+
+    icd->formats = sensor_colour_formats;
+    icd->num_formats = ARRAY_SIZE(sensor_colour_formats);
+
+    return 0;
+
+sensor_video_probe_err:
+
+    return ret;
+}
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
+	switch (cmd)
+	{
+		case RK29_CAM_SUBDEV_DEACTIVATE:
+		{
+			sensor_deactivate(sd);
+			break;
+		}
+		default:
+			break;
+	}
+
+	return 0;
+
+}
+static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
+	.init		= sensor_init,
+	.g_ctrl		= sensor_g_control,
+	.s_ctrl		= sensor_s_control,
+	.g_ext_ctrls          = sensor_g_ext_controls,
+	.s_ext_ctrls          = sensor_s_ext_controls,
+	.g_chip_ident	= sensor_g_chip_ident,
+	.ioctl = sensor_ioctl,
+};
+
+static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
+	.s_fmt		= sensor_s_fmt,
+	.g_fmt		= sensor_g_fmt,
+	.try_fmt	= sensor_try_fmt,
+};
+
+static struct v4l2_subdev_ops sensor_subdev_ops = {
+	.core	= &sensor_subdev_core_ops,
+	.video = &sensor_subdev_video_ops,
+};
+
+static int sensor_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+    struct sensor *sensor;
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+    struct soc_camera_link *icl;
+    int ret;
+
+    SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
+    if (!icd) {
+        dev_err(&client->dev, "%s: missing soc-camera data!\n",SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+
+    icl = to_soc_camera_link(icd);
+    if (!icl) {
+        dev_err(&client->dev, "%s driver needs platform data\n", SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+
+    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+        dev_warn(&adapter->dev,
+        	 "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
+        return -EIO;
+    }
+
+    sensor = kzalloc(sizeof(struct sensor), GFP_KERNEL);
+    if (!sensor)
+        return -ENOMEM;
+
+    v4l2_i2c_subdev_init(&sensor->subdev, client, &sensor_subdev_ops);
+
+    /* Second stage probe - when a capture adapter is there */
+    icd->ops		= &sensor_ops;
+    icd->y_skip_top		= 0;
+
+    ret = sensor_video_probe(icd, client);
+    if (ret) {
+        icd->ops = NULL;
+        i2c_set_clientdata(client, NULL);
+        kfree(sensor);
+    }
+    SENSOR_DG("\n%s..%s..%d  ret = %x \n",__FUNCTION__,__FILE__,__LINE__,ret);
+    return ret;
+}
+
+static int sensor_remove(struct i2c_client *client)
+{
+    struct sensor *sensor = to_sensor(client);
+    struct soc_camera_device *icd = client->dev.platform_data;
+
+    icd->ops = NULL;
+    i2c_set_clientdata(client, NULL);
+    client->driver = NULL;
+    kfree(sensor);
+
+    return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{SENSOR_NAME_STRING(), 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+static struct i2c_driver sensor_i2c_driver = {
+	.driver = {
+		.name = SENSOR_NAME_STRING(),
+	},
+	.probe		= sensor_probe,
+	.remove		= sensor_remove,
+	.id_table	= sensor_id,
+};
+
+static int __init sensor_mod_init(void)
+{
+    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());
+    return i2c_add_driver(&sensor_i2c_driver);
+}
+
+static void __exit sensor_mod_exit(void)
+{
+    i2c_del_driver(&sensor_i2c_driver);
+}
+
+device_initcall_sync(sensor_mod_init);
+module_exit(sensor_mod_exit);
+
+MODULE_DESCRIPTION(SENSOR_NAME_STRING(Camera sensor driver));
+MODULE_AUTHOR("ddl <kernel@rock-chips>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/media/video/s5k6aa.h b/drivers/media/video/s5k6aa.h
new file mode 100755
index 000000000000..17cced1a1c33
--- /dev/null
+++ b/drivers/media/video/s5k6aa.h
@@ -0,0 +1,10 @@
+#ifndef __S5K6AA_H__
+#define __S5K6AA_H__
+
+#define SEQUENCE_WAIT_MS                (0xFFFE)
+#define SEQUENCE_END                    (0xFFFF)
+#define SEQUENCE_FAST_SETMODE_START     (0xFFFD)
+#define SEQUENCE_FAST_SETMODE_END       (0xFFFC)
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 0b5e176a9162..bbf6420263dd 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -121,10 +121,15 @@ config BATTERY_BQ27510
 	depends on I2C && ARCH_RK29
 	help
 	  Say Y here to enable support for batteries with BQ27510(I2C) chip.
-	  
+	
+config BATTERY_BQ3060
+	tristate "BQ3060 battery driver"
+	depends on I2C && ARCH_RK29
+	help
+	  Say Y here to enable support for batteries with BQ3060(I2C) chip.  
 config CHECK_BATT_CAPACITY
 	tristate "check the capacity in BQ27510 battery if 1000mah write capacity for BATT_CAPACITY_MAH"
-	depends on BATTERY_BQ27510
+	depends on BATTERY_BQ27510 || BATTERY_BQ3060
 	default n
 
 config BATT_CAPACITY_MAH
@@ -134,7 +139,7 @@ config BATT_CAPACITY_MAH
 		
 config NO_BATTERY_IC
 	tristate "no BQ27510 battery ic in board"
-	depends on BATTERY_BQ27510
+	depends on BATTERY_BQ27510 || BATTERY_BQ3060 
 	default n
 	help
 	  Say no BQ27510(I2C) chip in board .
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index c33ce7acca9d..7ee1cf1914d3 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -31,4 +31,5 @@ obj-$(CONFIG_BATTERY_MAX17040)	+= max17040_battery.o
 obj-$(CONFIG_CHARGER_PCF50633)	+= pcf50633-charger.o
 obj-$(CONFIG_BATTERY_RK2818)	+= rk2818_battery.o
 obj-$(CONFIG_BATTERY_STC3100)	+= stc3100_battery.o
-obj-$(CONFIG_BATTERY_BQ27510)	+= bq27510_battery.o
\ No newline at end of file
+obj-$(CONFIG_BATTERY_BQ27510)	+= bq27510_battery.o
+obj-$(CONFIG_BATTERY_BQ3060)   += bq3060_battery.o
diff --git a/drivers/power/bq3060_battery.c b/drivers/power/bq3060_battery.c
new file mode 100755
index 000000000000..edaf8810449b
--- /dev/null
+++ b/drivers/power/bq3060_battery.c
@@ -0,0 +1,505 @@
+/*
+ * bq3060 battery driver
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/jiffies.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/idr.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <asm/unaligned.h>
+#include <mach/gpio.h>
+
+#define DRIVER_VERSION			"1.1.0"
+
+#define BQ3060_REG_TEMP		0x08
+#define BQ3060_REG_VOLT		0x09
+#define BQ3060_REG_AI			0x0a   ///0x14
+#define BQ3060_REG_STATUS		0x16
+#define BQ3060_REG_TTE			0x06 ///0x16
+#define BQ3060_REG_TTF			0x05 //0x18
+#define BQ3060_REG_TTECP		0x12 //0x26
+#define BQ3060_REG_DESIGNCAPACITY	0x18 //0x26
+
+#define BQ3060_REG_RSOC		0x0B /* Relative State-of-Charge */
+#define BQ3060_FLAG_CHGS		BIT(7)
+
+#define BQ3060_REG_CAPACITY	0x0f  ///0x0E
+#define BQ3060_FLAG_DSC		BIT(0)
+#define BQ3060_FLAG_FC			BIT(9)
+
+#define bq3060_SPEED 			200 * 1000
+
+#define DC_CHECK_PIN			RK29_PIN4_PA1
+
+/* manufacturer access defines */
+#define MANUFACTURER_ACCESS_STATUS 0x0006
+#define MANUFACTURER_ACCESS_SLEEP 0x0011
+
+/* battery status value bits */
+#define BATTERY_DISCHARGING		0x40
+#define BATTERY_FULL_CHARGED		0x20
+#define BATTERY_FULL_DISCHARGED 	0x10
+
+
+#if 0
+#define DBG(x...) printk(KERN_INFO x)
+#else
+#define DBG(x...) do { } while (0)
+#endif
+
+/* If the system has several batteries we need a different name for each
+ * of them...
+ */
+static DEFINE_MUTEX(battery_mutex);
+
+struct bq3060_device_info {
+	struct device 		*dev;
+	struct power_supply	bat;
+	struct power_supply	ac;
+	struct power_supply	usb;
+	struct delayed_work work;
+	unsigned int interval;
+	struct i2c_client	*client;
+};
+
+static enum power_supply_property bq3060_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	//POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+	//POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,
+	//POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+};
+
+static enum power_supply_property rk29_ac_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+
+/*
+ * Common code for bq3060 devices read
+ */
+static int bq3060_read(struct i2c_client *client, u8 reg, u8 buf[], unsigned len)
+{
+	struct i2c_adapter *adap=client->adapter;
+	struct i2c_msg msgs[2];
+	int ret;
+	char reg_buf = reg;
+	
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].len = 1;
+	msgs[0].buf = &reg_buf;
+	msgs[0].scl_rate = bq3060_SPEED;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = (char *)buf;
+	msgs[1].scl_rate = bq3060_SPEED;
+
+	ret = i2c_transfer(adap, msgs, 2);
+
+	return (ret == 2)? len : ret;
+}
+static int bq3060_write(struct i2c_client *client, u8 reg, u8 const buf[], unsigned len)
+{
+	int ret; 
+	///return 0;
+	ret = i2c_master_reg8_send(client, reg, buf, (int)len, bq3060_SPEED);
+	return ret;
+}
+/*
+ * Return the battery temperature in tenths of degree Celsius
+ * Or < 0 if something fails.
+ */
+static int bq3060_battery_temperature(struct bq3060_device_info *di)
+{
+	int ret;
+	int temp = 0;
+	u8 buf[2];
+	ret = bq3060_read(di->client,BQ3060_REG_TEMP,buf,2);
+	if (ret<0) {
+		dev_err(di->dev, "error reading temperature\n");
+		return ret;
+	}
+	temp = get_unaligned_le16(buf);
+	temp = temp - 2731;
+	//#if CONFIG_NO_BATTERY_IC
+	temp = 258;
+	//#endif
+	DBG("Enter:%s %d--temp = %d\n",__FUNCTION__,__LINE__,temp);
+	return temp;
+}
+
+/*
+ * Return the battery Voltage in milivolts
+ * Or < 0 if something fails.
+ */
+static int bq3060_battery_voltage(struct bq3060_device_info *di)
+{
+	int ret;
+	u8 buf[2];
+	int volt = 0;
+
+	ret = bq3060_read(di->client,BQ3060_REG_VOLT,buf,2); 
+	if (ret<0) {
+		dev_err(di->dev, "error reading voltage\n");
+		return ret;
+	}
+	volt = get_unaligned_le16(buf);
+	volt = volt;
+	DBG("Enter:%s %d--volt = %d\n",__FUNCTION__,__LINE__,volt);
+	return volt;
+}
+
+/*
+ * Return the battery average current
+ * Note that current can be negative signed as well
+ * Or 0 if something fails.
+ */
+static int bq3060_battery_current(struct bq3060_device_info *di)
+{
+	int ret;
+	int curr = 0;
+	u8 buf[2];
+
+	ret = bq3060_read(di->client,BQ3060_REG_AI,buf,2);
+	if (ret<0) {
+		dev_err(di->dev, "error reading current\n");
+		return 0;
+	}
+
+	curr = get_unaligned_le16(buf);
+	if(curr>0x8000){
+		curr = 0xFFFF^(curr-1);
+	}
+	curr = curr * 1000;
+	DBG("Enter:%s %d--curr = %d\n",__FUNCTION__,__LINE__,curr);
+	return curr;
+}
+
+/*
+ * Return the battery Relative State-of-Charge
+ * Or < 0 if something fails.
+ */
+static int bq3060_battery_capacity(struct bq3060_device_info *di)
+{
+	int ret;
+	int rsoc = 0;
+	#if 1
+	int designcapacity=0;
+	#endif
+	u8 buf[2];
+	
+	ret = bq3060_read(di->client,BQ3060_REG_CAPACITY,buf,2); 
+	if (ret<0) {
+		dev_err(di->dev, "error reading relative State-of-Charge\n");
+		return ret;
+	}
+	rsoc = get_unaligned_le16(buf);
+	DBG("Enter:%s %d--capacity = %d\n",__FUNCTION__,__LINE__,rsoc);
+	#if CONFIG_NO_BATTERY_IC
+	rsoc = 100;
+	#endif
+	#if 1
+	ret = bq3060_read(di->client,BQ3060_REG_DESIGNCAPACITY,buf,2);
+	designcapacity = get_unaligned_le16(buf);
+	DBG("Enter:%s %d--designcapacity = %d\n",__FUNCTION__,__LINE__,designcapacity);
+	#endif
+	
+	if((rsoc<150)|(designcapacity<=200))
+		return 0;
+	rsoc = ((rsoc - 100)*100) / (designcapacity -200);
+	if(rsoc>100)
+		rsoc = 100;
+	DBG("Enter:%s %d--capacity = %d\n",__FUNCTION__,__LINE__,rsoc);	
+	return rsoc;
+}
+
+static int bq3060_battery_status(struct bq3060_device_info *di,
+				  union power_supply_propval *val)
+{
+	u8 buf[2];
+	int flags = 0;
+	int status;
+	int ret;
+
+	ret = bq3060_read(di->client,BQ3060_REG_STATUS, buf, 2);
+	if (ret < 0) {
+		dev_err(di->dev, "error reading flags\n");
+		return ret;
+	}
+	flags = get_unaligned_le16(buf);
+	DBG("Enter:%s %d--flags = %x\n",__FUNCTION__,__LINE__,flags);
+	if (flags & 0x20 )
+		status = POWER_SUPPLY_STATUS_FULL;
+	else if (flags & 0x40 )
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+	else
+		status = POWER_SUPPLY_STATUS_CHARGING;
+
+	val->intval = status;
+	return status;
+}
+
+/*
+ * Read a time register.
+ * Return < 0 if something fails.
+ */
+static int bq3060_battery_time(struct bq3060_device_info *di, int reg,
+				union power_supply_propval *val)
+{
+	u8 buf[2];
+	int tval = 0;
+	int ret;
+
+	ret = bq3060_read(di->client,reg,buf,2);
+	if (ret<0) {
+		dev_err(di->dev, "error reading register %02x\n", reg);
+		return ret;
+	}
+	tval = get_unaligned_le16(buf);
+	DBG("Enter:%s %d--tval=%d\n",__FUNCTION__,__LINE__,tval);
+	if (tval == 65535)
+		return -ENODATA;
+
+	val->intval = tval * 60;
+	DBG("Enter:%s %d val->intval = %d\n",__FUNCTION__,__LINE__,val->intval);
+	return 0;
+}
+
+#define to_bq3060_device_info(x) container_of((x), \
+				struct bq3060_device_info, bat);
+
+static int bq3060_battery_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	int ret = 0;
+	struct bq3060_device_info *di = to_bq3060_device_info(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = 1;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = bq3060_battery_status(di, val);
+		if(val->intval < 0)
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:		
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;		
+		break;	
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval =1;// bq3060_battery_voltage(di);
+	
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = bq3060_battery_current(di);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = bq3060_battery_capacity(di);
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = bq3060_battery_temperature(di);
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:		
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION; 	
+		break;		
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		ret = bq3060_battery_time(di, BQ3060_REG_TTE, val);
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:
+		ret = bq3060_battery_time(di, BQ3060_REG_TTECP, val);
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		ret = bq3060_battery_time(di, BQ3060_REG_TTF, val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk29_ac_get_property(struct power_supply *psy,
+			enum power_supply_property psp,
+			union power_supply_propval *val)
+{
+	int ret = 0;
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (psy->type == POWER_SUPPLY_TYPE_MAINS){
+			if(gpio_get_value(DC_CHECK_PIN))
+				val->intval = 0;
+			else
+				val->intval = 1;	
+		}
+		DBG("%s:%d val->intval = %d\n",__FUNCTION__,__LINE__,val->intval);
+		break;
+		
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static void bq3060_powersupply_init(struct bq3060_device_info *di)
+{
+	di->bat.name = "battery";
+	di->bat.type = POWER_SUPPLY_TYPE_BATTERY;
+	di->bat.properties = bq3060_battery_props;
+	di->bat.num_properties = ARRAY_SIZE(bq3060_battery_props);
+	di->bat.get_property = bq3060_battery_get_property;
+
+	di->ac.name = "ac";
+	di->ac.type = POWER_SUPPLY_TYPE_MAINS;
+	di->ac.properties = rk29_ac_props;
+	di->ac.num_properties = ARRAY_SIZE(rk29_ac_props);
+	di->ac.get_property = rk29_ac_get_property;
+
+	di->usb.name = "usb";
+	di->usb.type = POWER_SUPPLY_TYPE_USB;
+	di->usb.properties = rk29_ac_props;
+	di->usb.num_properties = ARRAY_SIZE(rk29_ac_props);
+	di->usb.get_property = bq3060_battery_get_property;
+}
+
+
+static void bq3060_battery_update_status(struct bq3060_device_info *di)
+{
+	power_supply_changed(&di->bat);
+}
+
+static void bq3060_battery_work(struct work_struct *work)
+{
+	struct bq3060_device_info *di = container_of(work, struct bq3060_device_info, work.work); 
+	bq3060_battery_update_status(di);
+	/* reschedule for the next time */
+	schedule_delayed_work(&di->work, di->interval);
+}
+
+static int bq3060_battery_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	struct bq3060_device_info *di;
+	int retval = 0;
+	
+	u8 buf[2];
+	 
+	di = kzalloc(sizeof(*di), GFP_KERNEL);
+	if (!di) {
+		dev_err(&client->dev, "failed to allocate device info data\n");
+		retval = -ENOMEM;
+		goto batt_failed_2;
+	}
+	i2c_set_clientdata(client, di);
+	di->dev = &client->dev;
+	di->bat.name = "bq3060-battery";
+	di->client = client;
+	/* 4 seconds between monotor runs interval */
+	di->interval = msecs_to_jiffies(1 * 1000);
+	
+	gpio_request(DC_CHECK_PIN,"dc_check");
+	gpio_direction_input(DC_CHECK_PIN);
+	bq3060_powersupply_init(di);
+	buf[0] = 0x41;
+	buf[1] = 0x00;
+	bq3060_write(di->client,0x00,buf,2);
+	buf[0] = 0x21;
+	buf[1] = 0x00;
+	bq3060_write(di->client,0x00,buf,2);
+	retval = power_supply_register(&client->dev, &di->bat);
+	if (retval) {
+		dev_err(&client->dev, "failed to register battery\n");
+		goto batt_failed_4;
+	}
+	//retval = power_supply_register(&client->dev, &di->usb);
+	if (retval) {
+		dev_err(&client->dev, "failed to register usb battery\n");
+		goto batt_failed_4;
+	}
+	retval = power_supply_register(&client->dev, &di->ac);
+	if (retval) {
+		dev_err(&client->dev, "failed to register ac adapter\n");
+		goto batt_failed_4;
+	}
+	INIT_DELAYED_WORK(&di->work, bq3060_battery_work);
+	schedule_delayed_work(&di->work, di->interval);
+	dev_info(&client->dev, "support ver. %s enabled\n", DRIVER_VERSION);
+
+	return 0;
+
+batt_failed_4:
+	kfree(di);
+batt_failed_2:
+	return retval;
+}
+
+static int bq3060_battery_remove(struct i2c_client *client)
+{
+	struct bq3060_device_info *di = i2c_get_clientdata(client);
+
+	power_supply_unregister(&di->bat);
+	kfree(di->bat.name);
+	kfree(di);
+	return 0;
+}
+
+/*
+ * Module stuff
+ */
+
+static const struct i2c_device_id bq3060_id[] = {
+	{ "bq3060", 0 },
+};
+
+static struct i2c_driver bq3060_battery_driver = {
+	.driver = {
+		.name = "bq3060-battery",
+	},
+	.probe = bq3060_battery_probe,
+	.remove = bq3060_battery_remove,
+	.id_table = bq3060_id,
+};
+
+static int __init bq3060_battery_init(void)
+{
+	int ret;
+
+	ret = i2c_add_driver(&bq3060_battery_driver);
+	if (ret)
+		printk(KERN_ERR "Unable to register bq3060 driver\n");
+	return ret;
+}
+module_init(bq3060_battery_init);
+
+static void __exit bq3060_battery_exit(void)
+{
+	i2c_del_driver(&bq3060_battery_driver);
+}
+module_exit(bq3060_battery_exit);
+
+MODULE_AUTHOR("Rockchip");
+MODULE_DESCRIPTION("bq3060 battery monitor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/display/screen/Kconfig b/drivers/video/display/screen/Kconfig
index 6de4a8beda7c..f5159feebc29 100755
--- a/drivers/video/display/screen/Kconfig
+++ b/drivers/video/display/screen/Kconfig
@@ -15,6 +15,8 @@ config LCD_HSD070IDW1
     bool "RGB Hannstar800x480"
 config LCD_HSD100PXN
 	  bool "RGB Hannstar HSD100PXN(1024X768)"
+config LCD_B101AW06
+	  bool "RGB Hannstar B101AW06(1024X600)"
 config LCD_A060SE02
     bool "MCU A060SE02"
 config LCD_S1D13521
diff --git a/drivers/video/display/screen/Makefile b/drivers/video/display/screen/Makefile
index a9e8fdf4f238..e1dbd7288331 100755
--- a/drivers/video/display/screen/Makefile
+++ b/drivers/video/display/screen/Makefile
@@ -18,5 +18,6 @@ obj-$(CONFIG_HDMI_ANX7150) += hdmi_anx7150.o
 
 obj-$(CONFIG_LCD_HX8357) += lcd_hx8357.o
 obj-$(CONFIG_LCD_HSD100PXN) += lcd_hsd100pxn.o
+obj-$(CONFIG_LCD_B101AW06) += lcd_B101AW06.o
 obj-$(CONFIG_LCD_ANX7150_720P) += lcd_anx7150_720p.o
 
diff --git a/drivers/video/display/screen/lcd_B101AW06.c b/drivers/video/display/screen/lcd_B101AW06.c
new file mode 100755
index 000000000000..e0000cacba2c
--- /dev/null
+++ b/drivers/video/display/screen/lcd_B101AW06.c
@@ -0,0 +1,76 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include "../../rk29_fb.h"
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "screen.h"
+
+
+/* Base */
+#define OUT_TYPE		SCREEN_RGB
+#define OUT_FACE		OUT_D888_P666
+#define OUT_CLK			 45000000
+#define LCDC_ACLK        312000000           //29 lcdc axi DMA 
+
+/* Timing */
+#define H_PW			10
+#define H_BP			80
+#define H_VD			1024
+#define H_FP			100
+
+#define V_PW			10
+#define V_BP			10
+#define V_VD			600
+#define V_FP			18
+
+#define LCD_WIDTH       202
+#define LCD_HEIGHT      152
+/* Other */
+#define DCLK_POL		0
+#define SWAP_RB			0
+
+
+void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
+{
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = H_VD;
+    screen->y_res = V_VD;
+
+    screen->width = LCD_WIDTH;
+    screen->height = LCD_HEIGHT;
+
+    /* Timing */
+    screen->lcdc_aclk = LCDC_ACLK;
+    screen->pixclock = OUT_CLK;
+	screen->left_margin = H_BP;
+	screen->right_margin = H_FP;
+	screen->hsync_len = H_PW;
+	screen->upper_margin = V_BP;
+	screen->lower_margin = V_FP;
+	screen->vsync_len = V_PW;
+
+	/* Pin polarity */
+	screen->pin_hsync = 0;
+	screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = NULL;
+    screen->standby = NULL;
+}
+
+
+
diff --git a/include/media/v4l2-chip-ident.h b/include/media/v4l2-chip-ident.h
index 9ef00c42ada1..478a5ed2d8a1 100644
--- a/include/media/v4l2-chip-ident.h
+++ b/include/media/v4l2-chip-ident.h
@@ -72,6 +72,7 @@ enum {
 
 	/* module saa7146: reserved range 300-309 */
 	V4L2_IDENT_SAA7146 = 300,
+	V4L2_IDENT_S5K66A = 350,							/* ddl@rock-chips.com : s5k66a support */
 
 	/* Conexant MPEG encoder/decoders: reserved range 400-420 */
 	V4L2_IDENT_CX23418_843 = 403, /* Integrated A/V Decoder on the '418 */
diff --git a/sound/soc/codecs/wm8900.c b/sound/soc/codecs/wm8900.c
index 6f991b228974..e2da7621d0fc 100644
--- a/sound/soc/codecs/wm8900.c
+++ b/sound/soc/codecs/wm8900.c
@@ -31,6 +31,9 @@
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
 #include <sound/tlv.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <mach/rk29_iomap.h>
 
 #include "wm8900.h"
 
@@ -142,7 +145,9 @@
 #define WM8900_REG_HPCTL1_HP_SHORT2      0x04
 
 #define WM8900_LRC_MASK 0xfc00
-
+#ifdef CONFIG_MACH_RK29_MALATA
+#define SPK_CON 		RK29_PIN6_PB6
+#endif
 struct snd_soc_codec_device soc_codec_dev_wm8900;
 
 struct wm8900_priv {
@@ -1070,7 +1075,18 @@ static int wm8900_digital_mute(struct snd_soc_dai *codec_dai, int mute)
 
 	return 0;
 }
-
+#ifdef CONFIG_MACH_RK29_MALATA
+static int wm8900_trigger(struct snd_pcm_substream *substream, int trigger)
+{	
+	WM8900_DBG("Enter::%s----%d trigger = %d\n",__FUNCTION__,__LINE__, trigger);	
+	if(trigger == 1){		
+		gpio_set_value(SPK_CON, GPIO_HIGH);
+	}	else{		
+		gpio_set_value(SPK_CON, GPIO_LOW);
+	}	
+	return 0;
+}
+#endif
 #define WM8900_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
 		      SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
 		      SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
@@ -1085,6 +1101,9 @@ static struct snd_soc_dai_ops wm8900_dai_ops = {
 	.set_pll	= wm8900_set_dai_pll,
 	.set_fmt	= wm8900_set_dai_fmt,
 	.digital_mute	= wm8900_digital_mute,
+#ifdef CONFIG_MACH_RK29_MALATA	
+	.trigger = wm8900_trigger,
+#endif
 };
 
 struct snd_soc_dai wm8900_dai = {
@@ -1450,7 +1469,11 @@ static int wm8900_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "I2C client not yet instantiated\n");
 		return -ENODEV;
 	}
-
+#ifdef CONFIG_MACH_RK29_MALATA
+	gpio_request(SPK_CON,"spk_con");
+	gpio_set_value(SPK_CON, GPIO_LOW);
+	gpio_direction_output(SPK_CON, GPIO_LOW);
+#endif
 	codec = wm8900_codec;
 	socdev->card->codec = codec;
 
-- 
2.35.3

