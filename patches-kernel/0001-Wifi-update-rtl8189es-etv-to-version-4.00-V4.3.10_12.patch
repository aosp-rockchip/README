From 4e4e6cf51adf8c955f19f1f494c5cc917096f64d Mon Sep 17 00:00:00 2001
From: gwl <gwl@rock-chips.com>
Date: Mon, 13 Oct 2014 11:38:26 +0800
Subject: [PATCH] Wifi: update rtl8189es/etv to version
 4.00(V4.3.10_12447.20141008).

---
 .../wireless/rockchip_wlan/rtl8189es/Makefile |   307 +-
 .../rockchip_wlan/rtl8189es/core/rtw_ap.c     |   118 +-
 .../rtl8189es/core/rtw_beamforming.c          |     4 +-
 .../rockchip_wlan/rtl8189es/core/rtw_br_ext.c |    77 +-
 .../rockchip_wlan/rtl8189es/core/rtw_bt_mp.c  |     8 +-
 .../rockchip_wlan/rtl8189es/core/rtw_btcoex.c |    71 +-
 .../rockchip_wlan/rtl8189es/core/rtw_cmd.c    |   403 +-
 .../rockchip_wlan/rtl8189es/core/rtw_debug.c  |   709 +-
 .../rtl8189es/core/rtw_ieee80211.c            |   222 +-
 .../rockchip_wlan/rtl8189es/core/rtw_iol.c    |     4 +-
 .../rockchip_wlan/rtl8189es/core/rtw_mem.c    |   103 +
 .../rockchip_wlan/rtl8189es/core/rtw_mlme.c   |   324 +-
 .../rtl8189es/core/rtw_mlme_ext.c             |   685 +-
 .../rockchip_wlan/rtl8189es/core/rtw_mp.c     |   375 +-
 .../rtl8189es/core/rtw_mp_ioctl.c             |     6 +-
 .../rockchip_wlan/rtl8189es/core/rtw_odm.c    |   157 +-
 .../rockchip_wlan/rtl8189es/core/rtw_p2p.c    |    42 +-
 .../rtl8189es/core/rtw_pwrctrl.c              |   171 +-
 .../rockchip_wlan/rtl8189es/core/rtw_recv.c   |   417 +-
 .../rtl8189es/core/rtw_security.c             |    14 +-
 .../rockchip_wlan/rtl8189es/core/rtw_sreset.c |    16 +-
 .../rtl8189es/core/rtw_sta_mgt.c              |    46 +-
 .../rockchip_wlan/rtl8189es/core/rtw_tdls.c   |     2 -
 .../rockchip_wlan/rtl8189es/core/rtw_vht.c    |     5 +-
 .../rtl8189es/core/rtw_wlan_util.c            |   902 +-
 .../rockchip_wlan/rtl8189es/core/rtw_xmit.c   |   352 +-
 .../rtl8189es/hal/HalPwrSeqCmd.c              |     2 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.c    |    52 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.h    |     7 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.c    |    52 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.h    |     7 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.c    |    72 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.h    |     7 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.c    |    67 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.h    |     7 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8723a1Ant.c    |    50 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.c    |   110 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.h    |     7 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.c    |  1475 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.h    |    49 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.c    |  1200 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.h    |    46 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.c    |    60 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.h    |     7 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.c    |    64 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.h    |     7 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.c    |   669 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.h    |    21 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.c    |   229 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.h    |    16 +-
 .../hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.c |  4398 +++++
 .../hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.h |   207 +
 .../hal/OUTSRC-BTCoexist/HalBtcOutSrc.h       |   125 +-
 .../hal/OUTSRC-BTCoexist/Mp_Precomp.h         |     1 +
 .../rtl8189es/hal/OUTSRC/HalPhyRf.c           |     6 +-
 .../rtl8189es/hal/OUTSRC/Mp_Precomp.h         |    24 +
 .../rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.c   |   880 +
 .../rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.h   |   146 +
 .../rockchip_wlan/rtl8189es/hal/OUTSRC/odm.c  | 14206 ----------------
 .../rtl8189es/hal/OUTSRC/odm_debug.c          |   629 -
 .../rtl8189es/hal/OUTSRC/odm_debug.h          |   892 -
 .../rtl8189es/hal/OUTSRC/odm_reg.h            |   122 -
 .../rtl8189es/hal/OUTSRC/phydm.c              |  2397 +++
 .../rtl8189es/hal/OUTSRC/{odm.h => phydm.h}   |   884 +-
 .../rtl8189es/hal/OUTSRC/phydm_ACS.c          |   213 +
 .../rtl8189es/hal/OUTSRC/phydm_ACS.h          |    61 +
 .../rtl8189es/hal/OUTSRC/phydm_AntDect.c      |  1206 ++
 .../rtl8189es/hal/OUTSRC/phydm_AntDect.h      |    76 +
 .../OUTSRC/{odm_AntDiv.c => phydm_AntDiv.c}   |   783 +-
 .../OUTSRC/{odm_AntDiv.h => phydm_AntDiv.h}   |   111 +-
 .../rtl8189es/hal/OUTSRC/phydm_CfoTracking.c  |   357 +
 .../rtl8189es/hal/OUTSRC/phydm_CfoTracking.h  |    68 +
 .../rtl8189es/hal/OUTSRC/phydm_DIG.c          |  2023 +++
 .../rtl8189es/hal/OUTSRC/phydm_DIG.h          |   309 +
 .../hal/OUTSRC/phydm_DynamicBBPowerSaving.c   |   218 +
 .../hal/OUTSRC/phydm_DynamicBBPowerSaving.h   |    63 +
 .../hal/OUTSRC/phydm_DynamicTxPower.c         |   882 +
 .../hal/OUTSRC/phydm_DynamicTxPower.h         |    89 +
 .../hal/OUTSRC/phydm_EdcaTurboCheck.c         |  1915 +++
 .../hal/OUTSRC/phydm_EdcaTurboCheck.h         |   152 +
 .../{odm_HWConfig.c => phydm_HWConfig.c}      |   328 +-
 .../{odm_HWConfig.h => phydm_HWConfig.h}      |     8 +-
 .../rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.c |   197 +
 .../rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.h |    49 +
 .../rtl8189es/hal/OUTSRC/phydm_PathDiv.c      |  1585 ++
 .../rtl8189es/hal/OUTSRC/phydm_PathDiv.h      |   193 +
 .../hal/OUTSRC/phydm_PowerTracking.c          |   687 +
 .../hal/OUTSRC/phydm_PowerTracking.h          |   248 +
 .../rtl8189es/hal/OUTSRC/phydm_RXHP.c         |  1685 ++
 .../rtl8189es/hal/OUTSRC/phydm_RXHP.h         |   105 +
 .../rtl8189es/hal/OUTSRC/phydm_RaInfo.c       |  1595 ++
 .../rtl8189es/hal/OUTSRC/phydm_RaInfo.h       |   167 +
 ..._RegDefine11AC.h => phydm_RegDefine11AC.h} |    21 +-
 ...dm_RegDefine11N.h => phydm_RegDefine11N.h} |    37 +-
 .../rtl8189es/hal/OUTSRC/phydm_debug.c        |   873 +
 .../rtl8189es/hal/OUTSRC/phydm_debug.h        |   202 +
 .../{odm_interface.c => phydm_interface.c}    |   211 +-
 .../{odm_interface.h => phydm_interface.h}    |    64 +-
 .../OUTSRC/{odm_precomp.h => phydm_precomp.h} |    59 +-
 .../rtl8189es/hal/OUTSRC/phydm_reg.h          |   208 +
 .../hal/OUTSRC/{odm_types.h => phydm_types.h} |   154 +-
 .../OUTSRC/rtl8188e/Hal8188ERateAdaptive.c    |    37 +-
 .../hal/OUTSRC/rtl8188e/Hal8188EReg.h         |     5 +-
 .../hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.c    |  1748 +-
 .../hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.h    |    34 +-
 .../hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.c    |  8114 ++++-----
 .../hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.h    |    59 +-
 .../hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.c   |   591 +-
 .../hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.h   |    13 +-
 .../hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.c    |   676 +-
 .../hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.h    |    21 +-
 .../hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c      |    90 +-
 .../hal/OUTSRC/rtl8188e/HalPhyRf_8188e.h      |     6 +-
 .../hal/OUTSRC/rtl8188e/Mp_Precomp.h          |    24 +
 .../{odm_RTL8188E.c => phydm_RTL8188E.c}      |    13 +-
 .../{odm_RTL8188E.h => phydm_RTL8188E.h}      |     0
 ...egConfig8188E.c => phydm_RegConfig8188E.c} |    18 +-
 ...egConfig8188E.h => phydm_RegConfig8188E.h} |     0
 .../rockchip_wlan/rtl8189es/hal/hal_btcoex.c  |   838 +-
 .../rockchip_wlan/rtl8189es/hal/hal_com.c     |  5009 +++++-
 .../rtl8189es/hal/hal_com_phycfg.c            |    60 +-
 .../rockchip_wlan/rtl8189es/hal/hal_dm.c      |   196 +
 .../rockchip_wlan/rtl8189es/hal/hal_dm.h      |    26 +
 .../rockchip_wlan/rtl8189es/hal/hal_intf.c    |   104 +-
 .../rtl8189es/hal/rtl8188e/rtl8188e_cmd.c     |   339 +-
 .../rtl8189es/hal/rtl8188e/rtl8188e_dm.c      |   108 +-
 .../hal/rtl8188e/rtl8188e_hal_init.c          |  1991 ++-
 .../rtl8189es/hal/rtl8188e/rtl8188e_mp.c      |     6 +-
 .../rtl8189es/hal/rtl8188e/rtl8188e_phycfg.c  |    37 +-
 .../rtl8189es/hal/rtl8188e/rtl8188e_rxdesc.c  |    20 +-
 .../rtl8189es/hal/rtl8188e/rtl8188e_xmit.c    |    17 +
 .../hal/rtl8188e/sdio/rtl8189es_xmit.c        |    94 +-
 .../hal/rtl8188e/sdio/sdio_halinit.c          |  1726 +-
 .../rtl8189es/include/Hal8188EPhyReg.h        |     1 +
 .../rtl8189es/include/Hal8192CPhyReg.h        |     1 +
 .../rtl8189es/include/Hal8192DPhyReg.h        |     3 +-
 .../rtl8189es/include/Hal8192EPhyCfg.h        |     3 +-
 .../rtl8189es/include/Hal8192EPhyReg.h        |     7 +-
 .../rtl8189es/include/Hal8812PhyReg.h         |     5 +
 .../rtl8189es/include/Hal8812PwrSeq.h         |     4 +-
 .../rtl8189es/include/autoconf.h              |   631 +-
 .../rtl8189es/include/drv_conf.h              |    29 +
 .../rtl8189es/include/drv_types.h             |   219 +-
 .../rtl8189es/include/gspi_hal.h              |     2 +-
 .../rtl8189es/include/gspi_ops.h              |    18 +-
 .../rtl8189es/include/hal_btcoex.h            |    16 +-
 .../rockchip_wlan/rtl8189es/include/hal_com.h |    60 +
 .../rtl8189es/include/hal_com_h2c.h           |    43 +-
 .../rtl8189es/include/hal_com_phycfg.h        |     4 +-
 .../rtl8189es/include/hal_com_reg.h           |    63 +-
 .../rtl8189es/include/hal_data.h              |    47 +-
 .../rtl8189es/include/hal_gspi.h              |    32 +
 .../rtl8189es/include/hal_intf.h              |    32 +-
 .../rockchip_wlan/rtl8189es/include/hal_pg.h  |     8 +-
 .../rtl8189es/include/ieee80211.h             |    13 +-
 .../rtl8189es/include/linux/wireless.h        |     8 +-
 .../rtl8189es/include/osdep_intf.h            |     8 +-
 .../rtl8189es/include/osdep_service.h         |    10 +-
 .../rtl8189es/include/osdep_service_linux.h   |     2 +
 .../rockchip_wlan/rtl8189es/include/pci_hal.h |     4 +
 .../rockchip_wlan/rtl8189es/include/pci_ops.h |    10 +
 .../rtl8189es/include/rtl8188e_cmd.h          |    11 +-
 .../rtl8189es/include/rtl8188e_hal.h          |    39 +-
 .../rtl8189es/include/rtl8188e_led.h          |     2 +-
 .../rtl8189es/include/rtl8188e_recv.h         |     2 +-
 .../rtl8189es/include/rtl8188e_spec.h         |     6 +-
 .../rtl8189es/include/rtl8188e_xmit.h         |    26 +-
 .../rtl8189es/include/rtl8192c_cmd.h          |     1 +
 .../rtl8189es/include/rtl8192c_hal.h          |     9 +-
 .../rtl8189es/include/rtl8192c_recv.h         |     4 +-
 .../rtl8189es/include/rtl8192c_spec.h         |    22 +-
 .../rtl8189es/include/rtl8192c_xmit.h         |    12 +-
 .../rtl8189es/include/rtl8192d_cmd.h          |    30 +-
 .../rtl8189es/include/rtl8192d_hal.h          |     5 +-
 .../rtl8189es/include/rtl8192d_recv.h         |     2 +
 .../rtl8189es/include/rtl8192d_spec.h         |     5 +-
 .../rtl8189es/include/rtl8192d_xmit.h         |    12 +-
 .../rtl8189es/include/rtl8192e_cmd.h          |    35 +-
 .../rtl8189es/include/rtl8192e_hal.h          |    81 +-
 .../rtl8189es/include/rtl8192e_recv.h         |    41 +-
 .../rtl8189es/include/rtl8192e_spec.h         |    75 +-
 .../rtl8189es/include/rtl8192e_xmit.h         |    80 +-
 .../rtl8189es/include/rtl8723a_cmd.h          |     6 +-
 .../rtl8189es/include/rtl8723a_hal.h          |    12 +-
 .../rtl8189es/include/rtl8723a_spec.h         |     4 +-
 .../rtl8189es/include/rtl8723a_xmit.h         |     2 +-
 .../rtl8189es/include/rtl8723b_cmd.h          |    58 +-
 .../rtl8189es/include/rtl8723b_hal.h          |    26 +-
 .../rtl8189es/include/rtl8723b_led.h          |     0
 .../rtl8189es/include/rtl8723b_recv.h         |   127 +-
 .../rtl8189es/include/rtl8723b_spec.h         |    18 +-
 .../rtl8189es/include/rtl8723b_xmit.h         |   168 +-
 .../rtl8189es/include/rtl8812a_cmd.h          |     8 +-
 .../rtl8189es/include/rtl8812a_hal.h          |    15 -
 .../rtl8189es/include/rtl8812a_recv.h         |     6 +
 .../rtl8189es/include/rtl8812a_spec.h         |    16 +-
 .../rtl8189es/include/rtl8812a_xmit.h         |    13 +-
 .../rtl8189es/include/rtl8821a_spec.h         |     9 +-
 .../rtl8189es/include/rtw_android.h           |    17 +
 .../rockchip_wlan/rtl8189es/include/rtw_ap.h  |     3 +-
 .../rtl8189es/include/rtw_bt_mp.h             |     2 +-
 .../rtl8189es/include/rtw_btcoex.h            |     9 +-
 .../rockchip_wlan/rtl8189es/include/rtw_cmd.h |    34 +-
 .../rtl8189es/include/rtw_debug.h             |    50 +-
 .../rtl8189es/include/rtw_eeprom.h            |     2 +-
 .../rtl8189es/include/rtw_event.h             |     4 +
 .../rockchip_wlan/rtl8189es/include/rtw_ht.h  |    81 +-
 .../rockchip_wlan/rtl8189es/include/rtw_io.h  |     5 +
 .../rockchip_wlan/rtl8189es/include/rtw_mem.h |    38 +
 .../rtl8189es/include/rtw_mlme.h              |    53 +-
 .../rtl8189es/include/rtw_mlme_ext.h          |   102 +-
 .../rockchip_wlan/rtl8189es/include/rtw_mp.h  |    73 +-
 .../rtl8189es/include/rtw_mp_phy_regdef.h     |     9 +-
 .../rockchip_wlan/rtl8189es/include/rtw_odm.h |     5 +-
 .../rtl8189es/include/rtw_pwrctrl.h           |    21 +-
 .../rtl8189es/include/rtw_recv.h              |    33 +-
 .../rtl8189es/include/rtw_security.h          |     4 +-
 .../rtl8189es/include/rtw_version.h           |     2 +-
 .../rtl8189es/include/rtw_wifi_regd.h         |     8 +-
 .../rtl8189es/include/rtw_xmit.h              |    87 +-
 .../rtl8189es/include/sdio_hal.h              |     4 +
 .../rtl8189es/include/sdio_ops.h              |    13 +
 .../rtl8189es/include/usb_ops_linux.h         |    15 +
 .../rockchip_wlan/rtl8189es/include/wifi.h    |     1 +
 .../rtl8189es/include/xmit_osdep.h            |     4 +
 .../os_dep/linux/custom_gpio_linux.c          |    37 +-
 .../rtl8189es/os_dep/linux/ioctl_cfg80211.c   |   385 +-
 .../linux}/ioctl_cfg80211.h                   |     6 +-
 .../rtl8189es/os_dep/linux/ioctl_linux.c      |  1313 +-
 .../rtl8189es/os_dep/linux/mlme_linux.c       |    43 +-
 .../rtl8189es/os_dep/linux/os_intfs.c         |   391 +-
 .../rtl8189es/os_dep/linux/recv_linux.c       |    35 +-
 .../rtl8189es/os_dep/linux/rtw_android.c      |   201 +-
 .../rtl8189es/os_dep/linux/rtw_cfgvendor.c    |  1319 ++
 .../rtl8189es/os_dep/linux/rtw_cfgvendor.h    |   246 +
 .../rtl8189es/os_dep/linux/rtw_proc.c         |   433 +-
 .../rtl8189es/os_dep/linux/rtw_proc.h         |    12 +-
 .../rtl8189es/os_dep/linux/sdio_intf.c        |   639 +-
 .../rtl8189es/os_dep/linux/wifi_regd.c        |    90 +-
 .../rtl8189es/os_dep/linux/wifi_version.h     |     2 +-
 .../rtl8189es/os_dep/linux/xmit_linux.c       |   168 +-
 .../rtl8189es/os_dep/osdep_service.c          |    67 +-
 .../platform/platform_ARM_SUNnI_sdio.c        |     2 -
 243 files changed, 50549 insertions(+), 31752 deletions(-)
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/Makefile
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mem.c
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mlme_ext.c
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_xmit.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/Mp_Precomp.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.h
 delete mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm.c
 delete mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_debug.c
 delete mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_debug.h
 delete mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_reg.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm.c
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm.h => phydm.h} (70%)
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_ACS.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_ACS.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDect.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDect.h
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_AntDiv.c => phydm_AntDiv.c} (72%)
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_AntDiv.h => phydm_AntDiv.h} (64%)
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_CfoTracking.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_CfoTracking.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DIG.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DIG.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicBBPowerSaving.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicBBPowerSaving.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicTxPower.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicTxPower.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_EdcaTurboCheck.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_EdcaTurboCheck.h
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_HWConfig.c => phydm_HWConfig.c} (88%)
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_HWConfig.h => phydm_HWConfig.h} (93%)
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PathDiv.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PathDiv.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PowerTracking.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PowerTracking.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RXHP.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RXHP.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RaInfo.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RaInfo.h
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_RegDefine11AC.h => phydm_RegDefine11AC.h} (68%)
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_RegDefine11N.h => phydm_RegDefine11N.h} (84%)
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_debug.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_debug.h
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_interface.c => phydm_interface.c} (73%)
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_interface.h => phydm_interface.h} (81%)
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_precomp.h => phydm_precomp.h} (83%)
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_reg.h
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/{odm_types.h => phydm_types.h} (61%)
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Mp_Precomp.h
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/{odm_RTL8188E.c => phydm_RTL8188E.c} (95%)
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/{odm_RTL8188E.h => phydm_RTL8188E.h} (100%)
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/{odm_RegConfig8188E.c => phydm_RegConfig8188E.c} (93%)
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/{odm_RegConfig8188E.h => phydm_RegConfig8188E.h} (100%)
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_dm.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_dm.h
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_reg.h
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_data.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_gspi.h
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_hal.h
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_ops.h
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_hal.h
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_led.h
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_recv.h
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_spec.h
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_xmit.h
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mem.h
 rename drivers/net/wireless/rockchip_wlan/rtl8189es/{include => os_dep/linux}/ioctl_cfg80211.h (94%)
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_cfgvendor.c
 create mode 100644 drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_cfgvendor.h

diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/Makefile b/drivers/net/wireless/rockchip_wlan/rtl8189es/Makefile
old mode 100644
new mode 100755
index bff1789adb07..92d9b26d7702
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/Makefile
@@ -1,5 +1,5 @@
 EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
-EXTRA_CFLAGS += -O1 -Wframe-larger-than=1200
+EXTRA_CFLAGS += -O1
 #EXTRA_CFLAGS += -O3
 #EXTRA_CFLAGS += -Wall
 #EXTRA_CFLAGS += -Wextra
@@ -47,26 +47,32 @@ CONFIG_BT_COEXIST = n
 CONFIG_RTL8192CU_REDEFINE_1X1 = n
 CONFIG_INTEL_WIDI = n
 CONFIG_WAPI_SUPPORT = n
-CONFIG_EFUSE_CONFIG_FILE = n
+CONFIG_EFUSE_CONFIG_FILE = y
 CONFIG_EXT_CLK = n
 CONFIG_TRAFFIC_PROTECT = y
 CONFIG_LOAD_PHY_PARA_FROM_FILE = y
 CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY = n
 CONFIG_CALIBRATE_TX_POWER_TO_MAX = n
-CONFIG_ODM_ADAPTIVITY = n
-CONFIG_FIND_BEST_CHANNEL = n
+CONFIG_RTW_ADAPTIVITY_EN = disable
+CONFIG_RTW_ADAPTIVITY_MODE = normal
+CONFIG_SKIP_SIGNAL_SCALE_MAPPING = n
+CONFIG_80211W = n
 CONFIG_REDUCE_TX_CPU_LOADING = n
+CONFIG_BR_EXT = y
+CONFIG_ANTENNA_DIVERSITY = n
 ######################## Wake On Lan ##########################
-CONFIG_WOWLAN = y
-CONFIG_GPIO_WAKEUP = y
+CONFIG_WOWLAN = n
+CONFIG_GPIO_WAKEUP = n
+CONFIG_WAKEUP_GPIO_IDX = default
 CONFIG_PNO_SUPPORT = n
 CONFIG_PNO_SET_DEBUG = n
 CONFIG_AP_WOWLAN = n
 ######### Notify SDIO Host Keep Power During Syspend ##########
-CONFIG_RTW_SDIO_PM_KEEP_POWER = y
+CONFIG_RTW_SDIO_PM_KEEP_POWER = n
 ###################### Platform Related #######################
 CONFIG_PLATFORM_I386_PC = n
 CONFIG_PLATFORM_ANDROID_X86 = n
+CONFIG_PLATFORM_ANDROID_INTEL_X86 = n
 CONFIG_PLATFORM_JB_X86 = n
 CONFIG_PLATFORM_ARM_S3C2K4 = n
 CONFIG_PLATFORM_ARM_PXA2XX = n
@@ -86,14 +92,13 @@ CONFIG_PLATFORM_TEGRA4_DALMORE = n
 CONFIG_PLATFORM_ARM_TCC8900 = n
 CONFIG_PLATFORM_ARM_TCC8920 = n
 CONFIG_PLATFORM_ARM_TCC8920_JB42 = n
-CONFIG_PLATFORM_ARM_RK2818 = n
+CONFIG_PLATFORM_ARM_RK2818 = y
 CONFIG_PLATFORM_ARM_RK3066 = n
-CONFIG_PLATFORM_ARM_RK3188 = y
+CONFIG_PLATFORM_ARM_RK3188 = n
 CONFIG_PLATFORM_ARM_URBETTER = n
 CONFIG_PLATFORM_ARM_TI_PANDA = n
 CONFIG_PLATFORM_MIPS_JZ4760 = n
 CONFIG_PLATFORM_DMP_PHILIPS = n
-CONFIG_PLATFORM_TI_DM365 = n
 CONFIG_PLATFORM_MSTAR_TITANIA12 = n
 CONFIG_PLATFORM_MSTAR = n
 CONFIG_PLATFORM_SZEBOOK = n
@@ -107,6 +112,9 @@ CONFIG_PLATFORM_ARM_RTD299X = n
 CONFIG_PLATFORM_ARM_SPREADTRUM_6820 = n
 CONFIG_PLATFORM_ARM_SPREADTRUM_8810 = n
 CONFIG_PLATFORM_ARM_WMT = n
+CONFIG_PLATFORM_TI_DM365 = n
+CONFIG_PLATFORM_MOZART = n
+CONFIG_PLATFORM_RTK119X = n
 ###############################################################
 
 CONFIG_DRVEXT_MODULE = n
@@ -140,6 +148,7 @@ _OS_INTFS_FILES :=	os_dep/osdep_service.o \
 			os_dep/linux/mlme_linux.o \
 			os_dep/linux/recv_linux.o \
 			os_dep/linux/ioctl_cfg80211.o \
+			os_dep/linux/rtw_cfgvendor.o \
 			os_dep/linux/wifi_regd.o \
 			os_dep/linux/rtw_android.o \
 			os_dep/linux/rtw_proc.o
@@ -159,16 +168,28 @@ _HAL_INTFS_FILES :=	hal/hal_intf.o \
 			hal/hal_com.o \
 			hal/hal_com_phycfg.o \
 			hal/hal_phy.o \
+			hal/hal_dm.o \
 			hal/hal_btcoex.o \
 			hal/hal_hci/hal_$(HCI_NAME).o \
 			hal/led/hal_$(HCI_NAME)_led.o
-			
-_OUTSRC_FILES := hal/OUTSRC/odm_debug.o	\
-		hal/OUTSRC/odm_AntDiv.o\
-		hal/OUTSRC/odm_interface.o\
-		hal/OUTSRC/odm_HWConfig.o\
-		hal/OUTSRC/odm.o\
-		hal/OUTSRC/HalPhyRf.o
+
+_OUTSRC_FILES := hal/OUTSRC/phydm_debug.o	\
+		hal/OUTSRC/phydm_AntDiv.o\
+		hal/OUTSRC/phydm_interface.o\
+		hal/OUTSRC/phydm_HWConfig.o\
+		hal/OUTSRC/phydm.o\
+		hal/OUTSRC/HalPhyRf.o\
+		hal/OUTSRC/phydm_EdcaTurboCheck.o\
+		hal/OUTSRC/phydm_DIG.o\
+		hal/OUTSRC/phydm_PathDiv.o\
+		hal/OUTSRC/phydm_RaInfo.o\
+		hal/OUTSRC/phydm_DynamicBBPowerSaving.o\
+		hal/OUTSRC/phydm_PowerTracking.o\
+		hal/OUTSRC/phydm_DynamicTxPower.o\
+		hal/OUTSRC/PhyDM_Adaptivity.o\
+		hal/OUTSRC/phydm_CfoTracking.o\
+		hal/OUTSRC/phydm_NoiseMonitor.o\
+		hal/OUTSRC/phydm_ACS.o
 
 EXTRA_CFLAGS += -I$(src)/platform
 _PLATFORM_FILES := platform/platform_ops.o
@@ -186,10 +207,11 @@ _OUTSRC_FILES += hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.o \
 				hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.o \
 				hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.o \
 				hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.o \
-				hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.o
+				hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.o \
+				hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.o
 endif
-		
-########### HAL_RTL8192C #################################										
+
+########### HAL_RTL8192C #################################
 
 ifeq ($(CONFIG_RTL8192C), y)
 RTL871X = rtl8192c
@@ -214,7 +236,7 @@ _HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
 			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
 			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_led.o \
 			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_xmit.o \
-			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o	
+			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o
 
 _HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops_linux.o
 
@@ -223,7 +245,7 @@ ifeq ($(CONFIG_MP_INCLUDED), y)
 _HAL_INTFS_FILES += hal/$(RTL871X)/$(RTL871X)_mp.o
 endif
 
-_OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/odm_RTL8192C.o\
+_OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/phydm_RTL8192C.o\
 								hal/OUTSRC/$(RTL871X)/HalDMOutSrc8192C_CE.o
 
 ifeq ($(CONFIG_USB_HCI), y)
@@ -271,10 +293,10 @@ ifeq ($(CONFIG_MP_INCLUDED), y)
 _HAL_INTFS_FILES += hal/$(RTL871X)/$(RTL871X)_mp.o
 endif
 
-_OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/odm_RTL8192D.o\
+_OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/phydm_RTL8192D.o\
 								hal/OUTSRC/$(RTL871X)/HalDMOutSrc8192D_CE.o
 
-								
+
 ifeq ($(CONFIG_USB_HCI), y)
 _OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/Hal8192DUFWImg_CE.o \
 								hal/OUTSRC/$(RTL871X)/Hal8192DUPHYImg_CE.o \
@@ -311,7 +333,7 @@ _HAL_INTFS_FILES += hal/HalPwrSeqCmd.o \
 				hal/$(RTL871X)/Hal8723PwrSeq.o\
 				hal/$(RTL871X)/$(RTL871X)_xmit.o \
 				hal/$(RTL871X)/$(RTL871X)_sreset.o
-				
+
 _HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
 			hal/$(RTL871X)/$(RTL871X)_phycfg.o \
 			hal/$(RTL871X)/$(RTL871X)_rf6052.o \
@@ -322,7 +344,7 @@ _HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
 			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_led.o \
 			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_xmit.o \
 			hal/$(RTL871X)/$(HCI_NAME)/rtl$(MODULE_NAME)_recv.o
-			
+
 ifeq ($(CONFIG_SDIO_HCI), y)
 _HAL_INTFS_FILES += hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_ops.o
 else
@@ -357,7 +379,7 @@ endif
 _OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/HalHWImg8723A_BB.o\
 								hal/OUTSRC/$(RTL871X)/HalHWImg8723A_MAC.o\
 								hal/OUTSRC/$(RTL871X)/HalHWImg8723A_RF.o\
-								hal/OUTSRC/$(RTL871X)/odm_RegConfig8723A.o
+								hal/OUTSRC/$(RTL871X)/phydm_RegConfig8723A.o
 
 _OUTSRC_FILES += hal/OUTSRC/rtl8192c/HalDMOutSrc8192C_CE.o
 
@@ -373,6 +395,10 @@ ifeq ($(CONFIG_SDIO_HCI), y)
 MODULE_NAME = 8189es
 endif
 
+ifeq ($(CONFIG_GSPI_HCI), y)
+MODULE_NAME = 8189es
+endif
+
 ifeq ($(CONFIG_USB_HCI), y)
 MODULE_NAME = 8188eu
 endif
@@ -410,7 +436,7 @@ endif
 
 ifeq ($(CONFIG_MP_INCLUDED), y)
 _HAL_INTFS_FILES += hal/$(RTL871X)/$(RTL871X)_mp.o
-endif			
+endif
 
 #hal/OUTSRC/$(RTL871X)/Hal8188EFWImg_CE.o
 _OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/HalHWImg8188E_MAC.o\
@@ -418,9 +444,9 @@ _OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/HalHWImg8188E_MAC.o\
 		hal/OUTSRC/$(RTL871X)/HalHWImg8188E_RF.o\
 		hal/OUTSRC/$(RTL871X)/HalHWImg8188E_FW.o\
 		hal/OUTSRC/$(RTL871X)/HalPhyRf_8188e.o\
-		hal/OUTSRC/$(RTL871X)/odm_RegConfig8188E.o\
+		hal/OUTSRC/$(RTL871X)/phydm_RegConfig8188E.o\
 		hal/OUTSRC/$(RTL871X)/Hal8188ERateAdaptive.o\
-		hal/OUTSRC/$(RTL871X)/odm_RTL8188E.o
+		hal/OUTSRC/$(RTL871X)/phydm_RTL8188E.o
 
 endif
 
@@ -476,8 +502,8 @@ _OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/HalHWImg8192E_MAC.o\
 		hal/OUTSRC/$(RTL871X)/HalHWImg8192E_RF.o\
 		hal/OUTSRC/$(RTL871X)/HalHWImg8192E_FW.o\
 		hal/OUTSRC/$(RTL871X)/HalPhyRf_8192e.o\
-		hal/OUTSRC/$(RTL871X)/odm_RegConfig8192E.o\
-		hal/OUTSRC/$(RTL871X)/odm_RTL8192E.o
+		hal/OUTSRC/$(RTL871X)/phydm_RegConfig8192E.o\
+		hal/OUTSRC/$(RTL871X)/phydm_RTL8192E.o
 
 endif
 
@@ -533,13 +559,9 @@ _OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/HalHWImg8812A_FW.o\
 		hal/OUTSRC/$(RTL871X)/HalHWImg8812A_MAC.o\
 		hal/OUTSRC/$(RTL871X)/HalHWImg8812A_BB.o\
 		hal/OUTSRC/$(RTL871X)/HalHWImg8812A_RF.o\
-		hal/OUTSRC/$(RTL871X)/HalHWImg8812A_TestChip_FW.o\
-		hal/OUTSRC/$(RTL871X)/HalHWImg8812A_TestChip_MAC.o\
-		hal/OUTSRC/$(RTL871X)/HalHWImg8812A_TestChip_BB.o\
-		hal/OUTSRC/$(RTL871X)/HalHWImg8812A_TestChip_RF.o\
 		hal/OUTSRC/$(RTL871X)/HalPhyRf_8812A.o\
-		hal/OUTSRC/$(RTL871X)/odm_RegConfig8812A.o\
-		hal/OUTSRC/$(RTL871X)/odm_RTL8812A.o
+		hal/OUTSRC/$(RTL871X)/phydm_RegConfig8812A.o\
+		hal/OUTSRC/$(RTL871X)/phydm_RTL8812A.o
 endif
 
 ifeq ($(CONFIG_RTL8821A), y)
@@ -564,14 +586,12 @@ _OUTSRC_FILES += hal/OUTSRC/rtl8821a/HalHWImg8821A_FW.o\
 		hal/OUTSRC/rtl8821a/HalHWImg8821A_MAC.o\
 		hal/OUTSRC/rtl8821a/HalHWImg8821A_BB.o\
 		hal/OUTSRC/rtl8821a/HalHWImg8821A_RF.o\
-		hal/OUTSRC/rtl8821a/HalHWImg8821A_TestChip_MAC.o\
-		hal/OUTSRC/rtl8821a/HalHWImg8821A_TestChip_BB.o\
-		hal/OUTSRC/rtl8821a/HalHWImg8821A_TestChip_RF.o\
 		hal/OUTSRC/rtl8812a/HalPhyRf_8812A.o\
 		hal/OUTSRC/rtl8821a/HalPhyRf_8821A.o\
-		hal/OUTSRC/rtl8821a/odm_RegConfig8821A.o\
-		hal/OUTSRC/rtl8821a/odm_RTL8821A.o
-endif	
+		hal/OUTSRC/rtl8821a/phydm_RegConfig8821A.o\
+		hal/OUTSRC/rtl8821a/phydm_RTL8821A.o\
+		hal/OUTSRC/rtl8821a/PhyDM_IQK_8821A.o
+endif
 
 
 endif
@@ -602,7 +622,7 @@ _HAL_INTFS_FILES +=	hal/$(RTL871X)/$(RTL871X)_hal_init.o \
 			hal/$(RTL871X)/$(RTL871X)_dm.o \
 			hal/$(RTL871X)/$(RTL871X)_rxdesc.o \
 			hal/$(RTL871X)/$(RTL871X)_cmd.o \
-			
+
 
 _HAL_INTFS_FILES +=	\
 			hal/$(RTL871X)/$(HCI_NAME)/$(HCI_NAME)_halinit.o \
@@ -625,20 +645,20 @@ _OUTSRC_FILES += hal/OUTSRC/$(RTL871X)/HalHWImg8723B_BB.o\
 								hal/OUTSRC/$(RTL871X)/HalHWImg8723B_RF.o\
 								hal/OUTSRC/$(RTL871X)/HalHWImg8723B_FW.o\
 								hal/OUTSRC/$(RTL871X)/HalHWImg8723B_MP.o\
-								hal/OUTSRC/$(RTL871X)/odm_RegConfig8723B.o\
+								hal/OUTSRC/$(RTL871X)/phydm_RegConfig8723B.o\
 								hal/OUTSRC/$(RTL871X)/HalPhyRf_8723B.o\
-								hal/OUTSRC/$(RTL871X)/odm_RTL8723B.o
+								hal/OUTSRC/$(RTL871X)/phydm_RTL8723B.o
 
 endif
 
-########### AUTO_CFG  #################################	
-		
+########### AUTO_CFG  #################################
+
 ifeq ($(CONFIG_AUTOCFG_CP), y)
 
-ifeq ($(CONFIG_MULTIDRV), y)	
+ifeq ($(CONFIG_MULTIDRV), y)
 $(shell cp $(TopDIR)/autoconf_multidrv_$(HCI_NAME)_linux.h $(TopDIR)/include/autoconf.h)
 else
-ifeq ($(CONFIG_RTL8188E)$(CONFIG_SDIO_HCI),yy) 
+ifeq ($(CONFIG_RTL8188E)$(CONFIG_SDIO_HCI),yy)
 $(shell cp $(TopDIR)/autoconf_rtl8189e_$(HCI_NAME)_linux.h $(TopDIR)/include/autoconf.h)
 else
 $(shell cp $(TopDIR)/autoconf_$(RTL871X)_$(HCI_NAME)_linux.h $(TopDIR)/include/autoconf.h)
@@ -692,6 +712,14 @@ endif
 
 ifeq ($(CONFIG_EFUSE_CONFIG_FILE), y)
 EXTRA_CFLAGS += -DCONFIG_EFUSE_CONFIG_FILE
+ifeq ($(MODULE_NAME), 8189es)
+EXTRA_CFLAGS += -DEFUSE_MAP_PATH=\"/system/etc/wifi/wifi_efuse_8189e.map\"
+else ifeq ($(MODULE_NAME), 8723bs)
+EXTRA_CFLAGS += -DEFUSE_MAP_PATH=\"/system/etc/wifi/wifi_efuse_8723bs.map\"
+else
+EXTRA_CFLAGS += -DEFUSE_MAP_PATH=\"/system/etc/wifi/wifi_efuse_$(MODULE_NAME).map\"
+endif
+EXTRA_CFLAGS += -DWIFIMAC_PATH=\"/data/wifimac.txt\"
 endif
 
 ifeq ($(CONFIG_EXT_CLK), y)
@@ -704,6 +732,8 @@ endif
 
 ifeq ($(CONFIG_LOAD_PHY_PARA_FROM_FILE), y)
 EXTRA_CFLAGS += -DCONFIG_LOAD_PHY_PARA_FROM_FILE
+#EXTRA_CFLAGS += -DREALTEK_CONFIG_PATH=\"/lib/firmware/\"
+EXTRA_CFLAGS += -DREALTEK_CONFIG_PATH=\"\"
 endif
 
 ifeq ($(CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY), y)
@@ -714,8 +744,24 @@ ifeq ($(CONFIG_CALIBRATE_TX_POWER_TO_MAX), y)
 EXTRA_CFLAGS += -DCONFIG_CALIBRATE_TX_POWER_TO_MAX
 endif
 
-ifeq ($(CONFIG_ODM_ADAPTIVITY), y)
-EXTRA_CFLAGS += -DCONFIG_ODM_ADAPTIVITY
+ifeq ($(CONFIG_RTW_ADAPTIVITY_EN), disable)
+EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_EN=0
+else ifeq ($(CONFIG_RTW_ADAPTIVITY_EN), enable)
+EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_EN=1
+endif
+
+ifeq ($(CONFIG_RTW_ADAPTIVITY_MODE), normal)
+EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_MODE=0
+else ifeq ($(CONFIG_RTW_ADAPTIVITY_MODE), carrier_sense)
+EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_MODE=1
+endif
+
+ifeq ($(CONFIG_SKIP_SIGNAL_SCALE_MAPPING), y)
+EXTRA_CFLAGS += -DCONFIG_SKIP_SIGNAL_SCALE_MAPPING
+endif
+
+ifeq ($(CONFIG_80211W), y)
+EXTRA_CFLAGS += -DCONFIG_IEEE80211W
 endif
 
 ifeq ($(CONFIG_WOWLAN), y)
@@ -743,20 +789,31 @@ ifeq ($(CONFIG_GPIO_WAKEUP), y)
 EXTRA_CFLAGS += -DCONFIG_GPIO_WAKEUP
 endif
 
+ifneq ($(CONFIG_WAKEUP_GPIO_IDX), default)
+EXTRA_CFLAGS += -DWAKEUP_GPIO_IDX=$(CONFIG_WAKEUP_GPIO_IDX)
+endif
+
 ifeq ($(CONFIG_RTW_SDIO_PM_KEEP_POWER), y)
 ifeq ($(CONFIG_SDIO_HCI), y)
 EXTRA_CFLAGS += -DCONFIG_RTW_SDIO_PM_KEEP_POWER
 endif
 endif
 
-ifeq ($(CONFIG_FIND_BEST_CHANNEL), y)
-EXTRA_CFLAGS += -DCONFIG_FIND_BEST_CHANNEL
-endif
-
 ifeq ($(CONFIG_REDUCE_TX_CPU_LOADING), y)
 EXTRA_CFLAGS += -DCONFIG_REDUCE_TX_CPU_LOADING
 endif
 
+ifeq ($(CONFIG_BR_EXT), y)
+BR_NAME = br0
+EXTRA_CFLAGS += -DCONFIG_BR_EXT
+EXTRA_CFLAGS += '-DCONFIG_BR_EXT_BRNAME="'$(BR_NAME)'"'
+endif
+
+ifeq ($(CONFIG_ANTENNA_DIVERSITY), y)
+EXTRA_CFLAGS += -DCONFIG_ANTENNA_DIVERSITY
+endif
+
+
 ifeq ($(CONFIG_PLATFORM_I386_PC), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
@@ -768,20 +825,6 @@ MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
 INSTALL_PREFIX :=
 endif
 
-ifeq ($(CONFIG_PLATFORM_ARM_WMT), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
-EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
-EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
-ifeq ($(CONFIG_SDIO_HCI), y)
-_PLATFORM_FILES += platform/platform_ARM_WMT_sdio.o
-endif
-ARCH := arm
-CROSS_COMPILE := arm_1103_le-
-KSRC := $(shell pwd)/../../../../
-MODULE_NAME :=8189es_kk
-endif
-
 ifeq ($(CONFIG_PLATFORM_ACTIONS_ATM702X), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ACTIONS_ATM702X
 #ARCH := arm
@@ -826,6 +869,19 @@ KSRC := /media/DATA-2/android-x86/ics-x86_20120130/out/target/product/generic_x8
 MODULE_NAME :=wlan
 endif
 
+ifeq ($(CONFIG_PLATFORM_ANDROID_INTEL_X86), y)
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_ANDROID_INTEL_X86
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_INTEL_BYT
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID
+EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
+EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
+EXTRA_CFLAGS += -DCONFIG_P2P_IPS
+EXTRA_CFLAGS += -DCONFIG_SKIP_SIGNAL_SCALE_MAPPING
+ifeq ($(CONFIG_SDIO_HCI), y)
+EXTRA_CFLAGS += -DCONFIG_RESUME_IN_WORKQUEUE
+endif
+endif
+
 ifeq ($(CONFIG_PLATFORM_JB_X86), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
@@ -938,7 +994,7 @@ KSRC ?= /lib/modules/2.6.31-770-g0e46b52/source
 endif
 
 ifeq ($(CONFIG_PLATFORM_FS_MX61), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN 
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 ARCH := arm
 CROSS_COMPILE := /home/share/CusEnv/FreeScale/arm-eabi-4.4.3/bin/arm-eabi-
 KSRC ?= /home/share/CusEnv/FreeScale/FS_kernel_env
@@ -956,10 +1012,24 @@ endif
 
 ifeq ($(CONFIG_PLATFORM_TI_DM365), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_TI_DM365
+EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_RX
+EXTRA_CFLAGS += -DCONFIG_SINGLE_XMIT_BUF -DCONFIG_SINGLE_RECV_BUF
 ARCH := arm
-CROSS_COMPILE := /home/cnsd4/Appro/mv_pro_5.0/montavista/pro/devkit/arm/v5t_le/bin/arm_v5t_le-
+#CROSS_COMPILE := /home/cnsd4/Appro/mv_pro_5.0/montavista/pro/devkit/arm/v5t_le/bin/arm_v5t_le-
+#KSRC := /home/cnsd4/Appro/mv_pro_5.0/montavista/pro/devkit/lsp/ti-davinci/linux-dm365
+CROSS_COMPILE := /opt/montavista/pro5.0/devkit/arm/v5t_le/bin/arm-linux-
+KSRC:= /home/vivotek/lsp/DM365/kernel_platform/kernel/linux-2.6.18
+KERNELOUTPUT := ${PRODUCTDIR}/tmp
 KVER  := 2.6.18
-KSRC := /home/cnsd4/Appro/mv_pro_5.0/montavista/pro/devkit/lsp/ti-davinci/linux-dm365
+endif
+
+ifeq ($(CONFIG_PLATFORM_MOZART), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MOZART
+ARCH := arm
+CROSS_COMPILE := /home/vivotek/lsp/mozart3v2/Mozart3e_Toolchain/build_arm_nofpu/usr/bin/arm-linux-
+KVER  := $(shell uname -r)
+KSRC:= /opt/Vivotek/lsp/mozart3v2/kernel_platform/kernel/mozart_kernel-1.17
+KERNELOUTPUT := /home/pink/sample/ODM/IP8136W-VINT/tmp/kernel
 endif
 
 ifeq ($(CONFIG_PLATFORM_TEGRA3_CARDHU), y)
@@ -1017,28 +1087,34 @@ MODULE_NAME := wlan
 endif
 
 ifeq ($(CONFIG_PLATFORM_ARM_RK2818), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS -DCONFIG_MINIMAL_MEMORY_USAGE
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS
+ifeq ($(CONFIG_SDIO_HCI), y)
+EXTRA_CFLAGS += -DCONFIG_RESUME_IN_WORKQUEUE
+endif
 ARCH := arm
 CROSS_COMPILE := /usr/src/release_fae_version/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
 KSRC := /usr/src/release_fae_version/kernel25_A7_281x
-MODULE_NAME := wlan
+MODULE_NAME := 8189es
 endif
 
 ifeq ($(CONFIG_PLATFORM_ARM_RK3188), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS -DCONFIG_MINIMAL_MEMORY_USAGE
-#EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
-EXTRA_CFLAGS += -DRTW_SUPPORT_PLATFORM_SHUTDOWN
-EXTRA_CFLAGS += -DRTW_USE_CFG80211_STA_EVENT
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS
+# default setting for Android 4.1, 4.2, 4.3, 4.4
+EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
 EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
-EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211
+# default setting for Power control
+EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
+EXTRA_CFLAGS += -DRTW_SUPPORT_PLATFORM_SHUTDOWN
+# default setting for Special function
 EXTRA_CFLAGS += -DCONFIG_P2P_IPS
 ARCH := arm
 CROSS_COMPILE := /home/android_sdk/Rockchip/Rk3188/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
 KSRC := /home/android_sdk/Rockchip/Rk3188/kernel
-MODULE_NAME := 8189es
+MODULE_NAME := wlan
 endif
 
 ifeq ($(CONFIG_PLATFORM_ARM_RK3066), y)
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_RK3066
 EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
@@ -1083,7 +1159,7 @@ endif
 ifeq ($(CONFIG_PLATFORM_SZEBOOK), y)
 EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
 ARCH:=arm
-CROSS_COMPILE:=/opt/crosstool2/bin/armeb-unknown-linux-gnueabi- 
+CROSS_COMPILE:=/opt/crosstool2/bin/armeb-unknown-linux-gnueabi-
 KVER:= 2.6.31.6
 KSRC:= ../code/linux-2.6.31.6-2020/
 endif
@@ -1195,7 +1271,7 @@ EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
 # default setting for Android 4.1, 4.2
 EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
 EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
-EXTRA_CFLAGS += -DCONFIG_P2P_IPS
+EXTRA_CFLAGS += -DCONFIG_P2P_IPS -DCONFIG_QOS_OPTIMIZATION
 
 EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
 ifeq ($(CONFIG_USB_HCI), y)
@@ -1207,13 +1283,17 @@ _PLATFORM_FILES += platform/platform_ARM_SUNnI_sdio.o
 endif
 
 ARCH := arm
-CROSS_COMPILE := /home/android_sdk/Allwinner/a23/android-jb42/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
-KVER  := 3.4.39
-KSRC :=/home/android_sdk/Allwinner/a23/android-jb42/lichee/linux-3.4
+# ===Cross compile setting for Android 4.2 SDK ===
+#CROSS_COMPILE := /home/android_sdk/Allwinner/a23/android-jb42/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
+#KSRC :=/home/android_sdk/Allwinner/a23/android-jb42/lichee/linux-3.4
+# ===Cross compile setting for Android 4.4 SDK ===
+CROSS_COMPILE := /home/isaac/inet-a23-android4.4/A23_4.4/lichee/out/android/common/buildroot/external-toolchain/bin/arm-linux-gnueabi-
+KSRC :=/home/isaac/inet-a23-android4.4/A23_4.4/lichee/linux-3.4
 endif
 
 ifeq ($(CONFIG_PLATFORM_ACTIONS_ATV5201), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ACTIONS_ATV5201
+EXTRA_CFLAGS += -DCONFIG_SDIO_DISABLE_RXFIFO_POLLING_LOOP
 ARCH := mips
 CROSS_COMPILE := mipsel-linux-gnu-
 KVER  := $(KERNEL_VER)
@@ -1259,7 +1339,53 @@ _PLATFORM_FILES += platform/platform_sprd_sdio.o
 endif
 endif
 
-ifeq ($(CONFIG_MULTIDRV), y)	
+ifeq ($(CONFIG_PLATFORM_ARM_WMT), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
+EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
+EXTRA_CFLAGS += -DCONFIG_PLATFORM_OPS
+ifeq ($(CONFIG_SDIO_HCI), y)
+_PLATFORM_FILES += platform/platform_ARM_WMT_sdio.o
+endif
+ARCH := arm
+CROSS_COMPILE := /home/android_sdk/WonderMedia/wm8880-android4.4/toolchain/arm_201103_gcc4.5.2/mybin/arm_1103_le-
+KSRC := /home/android_sdk/WonderMedia/wm8880-android4.4/kernel4.4/
+MODULE_NAME :=8189es_kk
+endif
+
+ifeq ($(CONFIG_PLATFORM_RTK119X), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+#EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_SUN7I
+EXTRA_CFLAGS += -DCONFIG_TRAFFIC_PROTECT
+# default setting for Android 4.1, 4.2
+EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE
+EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT
+#EXTRA_CFLAGS += -DCONFIG_P2P_IPS -DCONFIG_QOS_OPTIMIZATION
+EXTRA_CFLAGS += -DCONFIG_QOS_OPTIMIZATION
+
+#EXTRA_CFLAGS += -DCONFIG_#PLATFORM_OPS
+ifeq ($(CONFIG_USB_HCI), y)
+EXTRA_CFLAGS += -DCONFIG_USE_USB_BUFFER_ALLOC_TX
+#_PLATFORM_FILES += platform/platform_ARM_SUNxI_usb.o
+endif
+ifeq ($(CONFIG_SDIO_HCI), y)
+_PLATFORM_FILES += platform/platform_ARM_SUNnI_sdio.o
+endif
+
+ARCH := arm
+
+# ==== Cross compile setting for Android 4.4 SDK =====
+#CROSS_COMPILE := arm-linux-gnueabihf-
+KVER  := 3.10.24
+#KSRC :=/home/android_sdk/Allwinner/a20/android-kitkat44/lichee/linux-3.4
+CROSS_COMPILE := /home/realtek/software_phoenix/phoenix/toolchain/usr/local/arm-2013.11/bin/arm-linux-gnueabihf-
+KSRC := /home/realtek/software_phoenix/linux-kernel
+MODULE_NAME := 8192eu
+
+endif
+
+
+ifeq ($(CONFIG_MULTIDRV), y)
 
 ifeq ($(CONFIG_SDIO_HCI), y)
 MODULE_NAME := rtw_sdio
@@ -1276,6 +1402,7 @@ endif
 
 endif
 
+USER_MODULE_NAME ?=
 ifneq ($(USER_MODULE_NAME),)
 MODULE_NAME := $(USER_MODULE_NAME)
 endif
@@ -1315,7 +1442,7 @@ $(MODULE_NAME)-$(CONFIG_INTEL_WIDI) += core/rtw_intel_widi.o
 
 $(MODULE_NAME)-$(CONFIG_WAPI_SUPPORT) += core/rtw_wapi.o	\
 					core/rtw_wapi_sms4.o
-					
+
 $(MODULE_NAME)-y += $(_OS_INTFS_FILES)
 $(MODULE_NAME)-y += $(_HAL_INTFS_FILES)
 $(MODULE_NAME)-y += $(_OUTSRC_FILES)
@@ -1365,7 +1492,7 @@ config_r:
 
 clean:
 	cd hal/OUTSRC/ ; rm -fr */*.mod.c */*.mod */*.o */.*.cmd */*.ko
-	cd hal/OUTSRC/ ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko 
+	cd hal/OUTSRC/ ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
 	cd hal/led ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
 	cd hal ; rm -fr */*/*.mod.c */*/*.mod */*/*.o */*/.*.cmd */*/*.ko
 	cd hal ; rm -fr */*.mod.c */*.mod */*.o */.*.cmd */*.ko
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_ap.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_ap.c
index cb5c55302f08..ca634367f4fe 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_ap.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_ap.c
@@ -71,9 +71,9 @@ void free_mlme_ap_info(_adapter *padapter)
 
 	//free bc/mc sta_info
 	psta = rtw_get_bcmc_stainfo(padapter);	
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+	//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	
 
 	_rtw_spinlock_free(&pmlmepriv->bcn_update_lock);
@@ -405,9 +405,9 @@ void	expire_timeout_chk(_adapter *padapter)
 				
 				_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
 				
-				_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
+				//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
 				rtw_free_stainfo(padapter, psta);
-				_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
+				//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
 				
 				_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
 			}	
@@ -877,8 +877,6 @@ void update_bmc_sta(_adapter *padapter)
 	if(psta)
 	{
 		psta->aid = 0;//default set to 0
-		//psta->mac_id = psta->aid+4;	
-		psta->mac_id = psta->aid + 1;//mac_id=1 for bc/mc stainfo
 
 		pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
 
@@ -992,33 +990,46 @@ void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta)
 		//check if sta supports rx ampdu
 		phtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;
 
-		//check if sta support s Short GI 20M
-		if((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20))
-		{
-			phtpriv_sta->sgi_20m = _TRUE;
+		phtpriv_sta->rx_ampdu_min_spacing = (phtpriv_sta->ht_cap.ampdu_params_info&IEEE80211_HT_CAP_AMPDU_DENSITY)>>2;
+	
+		// bwmode
+		if((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH))
+		{			
+			psta->bw_mode = CHANNEL_WIDTH_40;
 		}
-		//check if sta support s Short GI 40M
-		if((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_40))
+		else
+		{			
+			psta->bw_mode = CHANNEL_WIDTH_20;
+		}		
+
+		if(pmlmeext->cur_bwmode < psta->bw_mode)
 		{
-			phtpriv_sta->sgi_40m = _TRUE;
+			psta->bw_mode = pmlmeext->cur_bwmode;
 		}
 
-		// bwmode
-		if((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH))
+		phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
+
+
+		//check if sta support s Short GI 20M 
+		if((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20))
 		{
-			phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
-			psta->bw_mode = CHANNEL_WIDTH_40;
+			phtpriv_sta->sgi_20m = _TRUE;
 		}
-		else
+		
+		//check if sta support s Short GI 40M 
+		if((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_40))
 		{
-			psta->bw_mode = CHANNEL_WIDTH_20;
+			if(psta->bw_mode == CHANNEL_WIDTH_40) //according to psta->bw_mode
+				phtpriv_sta->sgi_40m = _TRUE;
+			else
+				phtpriv_sta->sgi_40m = _FALSE;
 		}
 
 		psta->qos_option = _TRUE;
 
 		// B0 Config LDPC Coding Capability
 		if (TEST_FLAG(phtpriv_ap->ldpc_cap, LDPC_HT_ENABLE_TX) && 
-			GET_HT_CAPABILITY_ELE_LDPC_CAP((u8 *)(&phtpriv_sta->ht_cap)))
+			GET_HT_CAP_ELE_LDPC_CAP((u8 *)(&phtpriv_sta->ht_cap)))
 		{
 			SET_FLAG(cur_ldpc_cap, (LDPC_HT_ENABLE_TX | LDPC_HT_CAP_TX));
 			DBG_871X("Enable HT Tx LDPC for STA(%d)\n",psta->aid);
@@ -1026,7 +1037,7 @@ void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta)
 
 		// B7 B8 B9 Config STBC setting
 		if (TEST_FLAG(phtpriv_ap->stbc_cap, STBC_HT_ENABLE_TX) &&
-			GET_HT_CAPABILITY_ELE_RX_STBC((u8 *)(&phtpriv_sta->ht_cap)))
+			GET_HT_CAP_ELE_RX_STBC((u8 *)(&phtpriv_sta->ht_cap)))
 		{
 			SET_FLAG(cur_stbc_cap, (STBC_HT_ENABLE_TX | STBC_HT_CAP_TX) );
 			DBG_871X("Enable HT Tx STBC for STA(%d)\n",psta->aid);
@@ -1720,9 +1731,14 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 	if(p && ie_len>0)
 	{
 		u8 rf_type=0;
-		HT_CAP_AMPDU_FACTOR max_rx_ampdu_factor=0;
+		HT_CAP_AMPDU_FACTOR max_rx_ampdu_factor=MAX_AMPDU_FACTOR_64K;
 		struct rtw_ieee80211_ht_cap *pht_cap = (struct rtw_ieee80211_ht_cap *)(p+2);
 
+		if (0) {
+			DBG_871X(FUNC_ADPT_FMT" HT_CAP_IE from upper layer:\n", FUNC_ADPT_ARG(padapter));
+			dump_ht_cap_ie_content(RTW_DBGDUMP, p+2, ie_len);
+		}
+
 		pHT_caps_ie=p;
 
 		ht_cap = _TRUE;
@@ -1730,6 +1746,7 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 
 		rtw_ht_use_default_setting(padapter);
 
+		/* Update HT Capabilities Info field */
 		if (pmlmepriv->htpriv.sgi_20m == _FALSE)
 			pht_cap->cap_info &= ~(IEEE80211_HT_CAP_SGI_20);
 
@@ -1751,8 +1768,9 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 			pht_cap->cap_info &= ~(IEEE80211_HT_CAP_RX_STBC_3R);
 		}
 
+		/* Update A-MPDU Parameters field */
 		pht_cap->ampdu_params_info &= ~(IEEE80211_HT_CAP_AMPDU_FACTOR|IEEE80211_HT_CAP_AMPDU_DENSITY);
-		
+
 		if((psecuritypriv->wpa_pairwise_cipher & WPA_CIPHER_CCMP) ||
 			(psecuritypriv->wpa2_pairwise_cipher & WPA_CIPHER_CCMP))
 		{
@@ -1766,11 +1784,25 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 		rtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor);
 		pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_FACTOR & max_rx_ampdu_factor); //set  Max Rx AMPDU size  to 64K
 
-		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-		if(rf_type == RF_1T1R)
-		{			
-			pht_cap->supp_mcs_set[0] = 0xff;
-			pht_cap->supp_mcs_set[1] = 0x0;
+		/* Update Supported MCS Set field */
+		{
+			int i;
+
+			rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+
+			/* RX MCS Bitmask */
+			switch(rf_type)
+			{
+				case RF_1T1R:
+				case RF_1T2R: //?
+					set_mcs_rate_by_mask(HT_CAP_ELE_RX_MCS_MAP(pht_cap), MCS_RATE_1R);
+					break;
+				case RF_2T2R:
+				default:
+					set_mcs_rate_by_mask(HT_CAP_ELE_RX_MCS_MAP(pht_cap), MCS_RATE_2R);
+			}
+			for (i = 0; i < 10; i++)
+				*(HT_CAP_ELE_RX_MCS_MAP(pht_cap)+i) &= padapter->mlmeextpriv.default_supported_mcs_set[i];
 		}
 
 #ifdef CONFIG_BEAMFORMING
@@ -1800,7 +1832,11 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 #endif //CONFIG_BEAMFORMING
 
 		_rtw_memcpy(&pmlmepriv->htpriv.ht_cap, p+2, ie_len);
-		
+
+		if (0) {
+			DBG_871X(FUNC_ADPT_FMT" HT_CAP_IE driver masked:\n", FUNC_ADPT_ARG(padapter));
+			dump_ht_cap_ie_content(RTW_DBGDUMP, p+2, ie_len);
+		}
 	}
 
 	//parsing HT_INFO_IE
@@ -2363,7 +2399,7 @@ static void update_bcn_vendor_spec_ie(_adapter *padapter, u8*oui)
 	
 }
 
-void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
+void _update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx, const char *tag)
 {
 	_irqL irqL;
 	struct mlme_priv *pmlmepriv;
@@ -2441,6 +2477,8 @@ void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
 	if(tx)
 	{
 		//send_beacon(padapter);//send_beacon must execute on TSR level
+		if (0)
+			DBG_871X(FUNC_ADPT_FMT" ie_id:%u - %s\n", FUNC_ADPT_ARG(padapter), ie_id, tag);
 		set_tx_beacon_cmd(padapter);
 	}
 #else
@@ -2879,6 +2917,10 @@ u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reaso
 		issue_deauth(padapter, psta->hwaddr, reason);
 	}
 
+#ifdef CONFIG_BEAMFORMING
+	beamforming_wk_cmd(padapter, BEAMFORMING_CTRL_LEAVE, psta->hwaddr, ETH_ALEN, 1);
+#endif
+
 	psta->htpriv.agg_enable_bitmap = 0x0;//reset
 	psta->htpriv.candidate_tid_bitmap = 0x0;//reset
 
@@ -2912,9 +2954,9 @@ u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reaso
 
 	beacon_updated = bss_cap_update_on_sta_leave(padapter, psta);
 
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);					
+	//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);					
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	
 
 	return beacon_updated;
@@ -2969,12 +3011,10 @@ int rtw_sta_flush(_adapter *padapter)
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(padapter->pnetdev));
-
 	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		return ret;
 
-
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(padapter->pnetdev));
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
@@ -3175,13 +3215,14 @@ void start_ap_mode(_adapter *padapter)
 	for(i=0; i<NUM_STA; i++)
 		pstapriv->sta_aid[i] = NULL;
 
+/* to avoid memory leak issue, don't set to NULL directly
 	pmlmepriv->wps_beacon_ie = NULL;	
 	pmlmepriv->wps_probe_resp_ie = NULL;
 	pmlmepriv->wps_assoc_resp_ie = NULL;
 	
 	pmlmepriv->p2p_beacon_ie = NULL;
 	pmlmepriv->p2p_probe_resp_ie = NULL;
-
+*/
 	
 	//for ACL 
 	_rtw_init_listhead(&(pacl_list->acl_node_q.queue));
@@ -3209,6 +3250,7 @@ void stop_ap_mode(_adapter *padapter)
 
 	pmlmepriv->update_bcn = _FALSE;
 	pmlmeext->bstart_bss = _FALSE;
+	padapter->netif_up = _FALSE;
 	//_rtw_spinlock_free(&pmlmepriv->bcn_update_lock);
 	
 	//reset and init security priv , this can refine with rtw_reset_securitypriv
@@ -3244,9 +3286,9 @@ void stop_ap_mode(_adapter *padapter)
 	rtw_free_all_stainfo(padapter);
 	
 	psta = rtw_get_bcmc_stainfo(padapter);
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+	//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	
 	rtw_init_bcmc_stainfo(padapter);	
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_beamforming.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_beamforming.c
index a3b44c3f503a..8d8c614e7b82 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_beamforming.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_beamforming.c
@@ -330,7 +330,7 @@ BOOLEAN	issue_ht_ndpa_packet(PADAPTER Adapter, u8 *ra, CHANNEL_WIDTH bw, u8 qidx
 	update_mgntframe_attrib(Adapter, pattrib);
 
 	if (qidx == BCN_QUEUE_INX)
-		pattrib->qsel = 0x10;
+		pattrib->qsel = QSLT_BEACON;
 	pattrib->rate = MGN_MCS8;
 	pattrib->bwmode = bw;
 	pattrib->order = 1;
@@ -412,7 +412,7 @@ BOOLEAN	issue_vht_ndpa_packet(PADAPTER Adapter, u8 *ra, u16 aid, CHANNEL_WIDTH b
 	update_mgntframe_attrib(Adapter, pattrib);
 
 	if (qidx == BCN_QUEUE_INX)
-		pattrib->qsel = 0x10;
+		pattrib->qsel = QSLT_BEACON;
 	pattrib->rate = MGN_VHT2SS_MCS0;
 	pattrib->bwmode = bw;
 	pattrib->subtype = WIFI_NDPA;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_br_ext.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_br_ext.c
index 88a517a68d7d..f90f790a31d8 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_br_ext.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_br_ext.c
@@ -247,7 +247,7 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 		if (len >= 8) {
 			mac = scan_tlv(&data[8], len-8, 1, 1);
 			if (mac) {
-				_DEBUG_INFO("Router Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
+				DBG_871X("Router Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
 					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);	
@@ -259,7 +259,7 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 		if (len >= 16) {
 			mac = scan_tlv(&data[16], len-16, 1, 1);
 			if (mac) {
-				_DEBUG_INFO("Router Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
+				DBG_871X("Router Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
 					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);			
@@ -271,7 +271,7 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 		if (len >= 24) {
 			mac = scan_tlv(&data[24], len-24, 1, 1);
 			if (mac) {		
-				_DEBUG_INFO("Neighbor Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
+				DBG_871X("Neighbor Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
 					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);	
@@ -283,7 +283,7 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 		if (len >= 24) {
 			mac = scan_tlv(&data[24], len-24, 2, 1);
 			if (mac) {
-				_DEBUG_INFO("Neighbor Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
+				DBG_871X("Neighbor Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
 					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);		
@@ -295,7 +295,7 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 		if (len >= 40) {
 			mac = scan_tlv(&data[40], len-40, 2, 1);
 			if (mac) {				
-				_DEBUG_INFO("Redirect,  replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
+				DBG_871X("Redirect,  replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
 					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);	
@@ -439,7 +439,7 @@ static int __nat25_db_network_lookup_and_replace(_adapter *priv,
 				atomic_inc(&db->use_count);
 
 #ifdef CL_IPV6_PASS
-				DEBUG_INFO("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	
+				DBG_871X("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	
 							"%02x%02x%02x%02x%02x%02x\n",				
 					db->macAddr[0],
 					db->macAddr[1],
@@ -465,7 +465,7 @@ static int __nat25_db_network_lookup_and_replace(_adapter *priv,
 					db->networkAddr[15],
 					db->networkAddr[16]);
 #else				
-				DEBUG_INFO("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
+				DBG_871X("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
 					db->macAddr[0],
 					db->macAddr[1],
 					db->macAddr[2],
@@ -815,7 +815,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 					//in class A, B, C, host address is all zero or all one is illegal
 					if (iph->saddr == 0)
 						return 0;
-					DEBUG_INFO("NAT25: Insert IP, SA=%08x, DA=%08x\n", iph->saddr, iph->daddr);
+					DBG_871X("NAT25: Insert IP, SA=%08x, DA=%08x\n", iph->saddr, iph->daddr);
 					__nat25_generate_ipv4_network_addr(networkAddr, &iph->saddr);
 					//record source IP address and , source mac address into db
 					__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
@@ -826,7 +826,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 			case NAT25_LOOKUP:
 				{
-					DEBUG_INFO("NAT25: Lookup IP, SA=%08x, DA=%08x\n", iph->saddr, iph->daddr);
+					DBG_871X("NAT25: Lookup IP, SA=%08x, DA=%08x\n", iph->saddr, iph->daddr);
 #ifdef SUPPORT_TX_MCAST2UNI
 					if (priv->pshare->rf_ft_var.mc2u_disable ||
 							((((OPMODE & (WIFI_STATION_STATE|WIFI_ASOC_STATE))
@@ -840,12 +840,12 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 						if (!__nat25_db_network_lookup_and_replace(priv, skb, networkAddr)) {
 							if (*((unsigned char *)&iph->daddr + 3) == 0xff) {
 								// L2 is unicast but L3 is broadcast, make L2 bacome broadcast
-								DEBUG_INFO("NAT25: Set DA as boardcast\n");
+								DBG_871X("NAT25: Set DA as boardcast\n");
 								memset(skb->data, 0xff, ETH_ALEN);
 							}
 							else {
 								// forward unknow IP packet to upper TCP/IP
-								DEBUG_INFO("NAT25: Replace DA with BR's MAC\n");
+								DBG_871X("NAT25: Replace DA with BR's MAC\n");
 								if ( (*(u32 *)priv->br_mac) == 0 && (*(u16 *)(priv->br_mac+4)) == 0 ) {
 									void netdev_br_init(struct net_device *netdev);
 									printk("Re-init netdev_br_init() due to br_mac==0!\n");
@@ -885,7 +885,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 			case NAT25_INSERT:
 				{
-					DEBUG_INFO("NAT25: Insert ARP, MAC=%02x%02x%02x%02x%02x%02x\n", arp_ptr[0],
+					DBG_871X("NAT25: Insert ARP, MAC=%02x%02x%02x%02x%02x%02x\n", arp_ptr[0],
 						arp_ptr[1], arp_ptr[2], arp_ptr[3], arp_ptr[4], arp_ptr[5]);
 
 					// change to ARP sender mac address to wlan STA address
@@ -904,7 +904,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 			case NAT25_LOOKUP:
 				{
-					DEBUG_INFO("NAT25: Lookup ARP\n");
+					DBG_871X("NAT25: Lookup ARP\n");
 
 					arp_ptr += arp->ar_hln;
 					sender = (unsigned int *)arp_ptr;
@@ -930,8 +930,9 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 	/*---------------------------------------------------*/
 	/*         Handle IPX and Apple Talk frame           */
 	/*---------------------------------------------------*/
-	else if((protocol == __constant_htons(ETH_P_IPX)) ||
-		(protocol <= __constant_htons(ETH_FRAME_LEN)))
+	else if((protocol == __constant_htons(ETH_P_IPX)) || 
+		(protocol == __constant_htons(ETH_P_ATALK)) ||
+		(protocol == __constant_htons(ETH_P_AARP)))
 	{
 		unsigned char ipx_header[2] = {0xFF, 0xFF};
 		struct ipxhdr	*ipx = NULL;
@@ -941,14 +942,14 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 		if(protocol == __constant_htons(ETH_P_IPX))
 		{
-			DEBUG_INFO("NAT25: Protocol=IPX (Ethernet II)\n");
+			DBG_871X("NAT25: Protocol=IPX (Ethernet II)\n");
 			ipx = (struct ipxhdr *)framePtr;
 		}
-		else if(protocol <= __constant_htons(ETH_FRAME_LEN))
+		else //if(protocol <= __constant_htons(ETH_FRAME_LEN))
 		{
 			if(!memcmp(ipx_header, framePtr, 2))
 			{
-				DEBUG_INFO("NAT25: Protocol=IPX (Ethernet 802.3)\n");
+				DBG_871X("NAT25: Protocol=IPX (Ethernet 802.3)\n");
 				ipx = (struct ipxhdr *)framePtr;
 			}
 			else
@@ -968,7 +969,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 					{
 						framePtr += 5;	// eliminate the SNAP header
 
-						DEBUG_INFO("NAT25: Protocol=IPX (Ethernet SNAP)\n");
+						DBG_871X("NAT25: Protocol=IPX (Ethernet SNAP)\n");
 						ipx = (struct ipxhdr *)framePtr;
 					}
 					else if(!memcmp(aarp_snap_id, framePtr, 5))
@@ -996,18 +997,14 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 					if(!memcmp(ipx_header, framePtr, 2))
 					{
-						DEBUG_INFO("NAT25: Protocol=IPX (Ethernet 802.2)\n");
+						DBG_871X("NAT25: Protocol=IPX (Ethernet 802.2)\n");
 						ipx = (struct ipxhdr *)framePtr;
 					}
 					else
 						return -1;
 				}
-				else
-					return -1;
 			}
 		}
-		else
-			return -1;
 
 		/*   IPX   */
 		if(ipx != NULL)
@@ -1017,14 +1014,14 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 				case NAT25_CHECK:
 					if(!memcmp(skb->data+ETH_ALEN, ipx->ipx_source.node, ETH_ALEN))
 					{
-						DEBUG_INFO("NAT25: Check IPX skb_copy\n");
+						DBG_871X("NAT25: Check IPX skb_copy\n");
 						return 0;
 					}
 					return -1;
 
 				case NAT25_INSERT:
 					{
-						DEBUG_INFO("NAT25: Insert IPX, Dest=%08x,%02x%02x%02x%02x%02x%02x,%04x Source=%08x,%02x%02x%02x%02x%02x%02x,%04x\n",
+						DBG_871X("NAT25: Insert IPX, Dest=%08x,%02x%02x%02x%02x%02x%02x,%04x Source=%08x,%02x%02x%02x%02x%02x%02x,%04x\n",
 							ipx->ipx_dest.net,
 							ipx->ipx_dest.node[0],
 							ipx->ipx_dest.node[1],
@@ -1044,7 +1041,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 						if(!memcmp(skb->data+ETH_ALEN, ipx->ipx_source.node, ETH_ALEN))
 						{
-							DEBUG_INFO("NAT25: Use IPX Net, and Socket as network addr\n");
+							DBG_871X("NAT25: Use IPX Net, and Socket as network addr\n");
 
 							__nat25_generate_ipx_network_addr_with_socket(networkAddr, &ipx->ipx_source.net, &ipx->ipx_source.sock);
 
@@ -1066,7 +1063,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 					{
                                                 if(!memcmp(GET_MY_HWADDR(priv), ipx->ipx_dest.node, ETH_ALEN))
 						{
-							DEBUG_INFO("NAT25: Lookup IPX, Modify Destination IPX Node addr\n");
+							DBG_871X("NAT25: Lookup IPX, Modify Destination IPX Node addr\n");
 
 							__nat25_generate_ipx_network_addr_with_socket(networkAddr, &ipx->ipx_dest.net, &ipx->ipx_dest.sock);
 
@@ -1109,7 +1106,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 						// change to AARP source mac address to wlan STA address
                                                 memcpy(ea->hw_src, GET_MY_HWADDR(priv), ETH_ALEN);
 
-						DEBUG_INFO("NAT25: Insert AARP, Source=%d,%d Destination=%d,%d\n",
+						DBG_871X("NAT25: Insert AARP, Source=%d,%d Destination=%d,%d\n",
 							ea->pa_src_net,
 							ea->pa_src_node,
 							ea->pa_dst_net,
@@ -1125,7 +1122,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 				case NAT25_LOOKUP:
 					{
-						DEBUG_INFO("NAT25: Lookup AARP, Source=%d,%d Destination=%d,%d\n",
+						DBG_871X("NAT25: Lookup AARP, Source=%d,%d Destination=%d,%d\n",
 							ea->pa_src_net,
 							ea->pa_src_node,
 							ea->pa_dst_net,
@@ -1155,7 +1152,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 				case NAT25_INSERT:
 					{
-						DEBUG_INFO("NAT25: Insert DDP, Source=%d,%d Destination=%d,%d\n",
+						DBG_871X("NAT25: Insert DDP, Source=%d,%d Destination=%d,%d\n",
 							ddp->deh_snet,
 							ddp->deh_snode,
 							ddp->deh_dnet,
@@ -1171,7 +1168,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 				case NAT25_LOOKUP:
 					{
-						DEBUG_INFO("NAT25: Lookup DDP, Source=%d,%d Destination=%d,%d\n",
+						DBG_871X("NAT25: Lookup DDP, Source=%d,%d Destination=%d,%d\n",
 							ddp->deh_snet,
 							ddp->deh_snode,
 							ddp->deh_dnet,
@@ -1248,7 +1245,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 							if(__nat25_add_pppoe_tag(skb, tag) < 0)
 								return -1;
 
-							DEBUG_INFO("NAT25: Insert PPPoE, forward %s packet\n",
+							DBG_871X("NAT25: Insert PPPoE, forward %s packet\n",
 											(ph->code == PADI_CODE ? "PADI" : "PADR"));
 						}
 						else { // not add relay tag
@@ -1269,7 +1266,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 				}
 				else	// session phase
 				{
-						DEBUG_INFO("NAT25: Insert PPPoE, insert session packet to %s\n", skb->dev->name);
+						DBG_871X("NAT25: Insert PPPoE, insert session packet to %s\n", skb->dev->name);
 
 						__nat25_generate_pppoe_network_addr(networkAddr, skb->data, &(ph->sid));
 
@@ -1327,7 +1324,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 						if (offset > 0)
 							tag->tag_len = htons(tagLen-MAGIC_CODE_LEN-RTL_RELAY_TAG_LEN);
 
-						DEBUG_INFO("NAT25: Lookup PPPoE, forward %s Packet from %s\n",
+						DBG_871X("NAT25: Lookup PPPoE, forward %s Packet from %s\n",
 							(ph->code == PADO_CODE ? "PADO" : "PADS"),	skb->dev->name);
 					}
 					else { // not add relay tag
@@ -1342,7 +1339,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 				else {
 					if(ph->sid != 0)
 					{
-						DEBUG_INFO("NAT25: Lookup PPPoE, lookup session packet from %s\n", skb->dev->name);
+						DBG_871X("NAT25: Lookup PPPoE, lookup session packet from %s\n", skb->dev->name);
 						__nat25_generate_pppoe_network_addr(networkAddr, skb->data+ETH_ALEN, &(ph->sid));
 
 						__nat25_db_network_lookup_and_replace(priv, skb, networkAddr);
@@ -1426,7 +1423,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 
 			case NAT25_INSERT:
 				{
-					DEBUG_INFO("NAT25: Insert IP, SA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x,"
+					DBG_871X("NAT25: Insert IP, SA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x,"
 									" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n", 
 						iph->saddr.s6_addr16[0],iph->saddr.s6_addr16[1],iph->saddr.s6_addr16[2],iph->saddr.s6_addr16[3],
 						iph->saddr.s6_addr16[4],iph->saddr.s6_addr16[5],iph->saddr.s6_addr16[6],iph->saddr.s6_addr16[7],
@@ -1455,7 +1452,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 				return 0;
 
 			case NAT25_LOOKUP:
-				DEBUG_INFO("NAT25: Lookup IP, SA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x,"
+				DBG_871X("NAT25: Lookup IP, SA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x,"
 								" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n", 
 						iph->saddr.s6_addr16[0],iph->saddr.s6_addr16[1],iph->saddr.s6_addr16[2],iph->saddr.s6_addr16[3],
 						iph->saddr.s6_addr16[4],iph->saddr.s6_addr16[5],iph->saddr.s6_addr16[6],iph->saddr.s6_addr16[7],
@@ -1571,7 +1568,7 @@ void mac_clone(_adapter *priv, unsigned char *addr)
 	struct sockaddr sa;
 
 	memcpy(sa.sa_data, addr, ETH_ALEN);
-	DEBUG_INFO("MAC Clone: Addr=%02x%02x%02x%02x%02x%02x\n",
+	DBG_871X("MAC Clone: Addr=%02x%02x%02x%02x%02x%02x\n",
 		addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
 	rtl8192cd_set_hwaddr(priv->dev, &sa);
 }
@@ -1650,7 +1647,7 @@ void dhcp_flag_bcast(_adapter *priv, struct sk_buff *skb)
 						{
 							register int sum = 0;
 
-							DEBUG_INFO("DHCP: change flag of DHCP request to broadcast.\n");
+							DBG_871X("DHCP: change flag of DHCP request to broadcast.\n");
 							// or BROADCAST flag
 							dhcph->flags |= htons(BROADCAST_FLAG);
 							// recalculate checksum
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_bt_mp.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_bt_mp.c
index 63fbf9e40373..73f2105beced 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_bt_mp.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_bt_mp.c
@@ -107,10 +107,6 @@ mptbt_CheckC2hFrame(
 	return c2hStatus;
 }
 
-#if defined(CONFIG_RTL8723A)
-extern s32 FillH2CCmd(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
-#endif
-
 BT_CTRL_STATUS
 mptbt_SendH2c(
 	PADAPTER	Adapter,
@@ -140,7 +136,7 @@ mptbt_SendH2c(
 			pMptCtx->MptBtC2hEvent = _FALSE;
 
 #if defined(CONFIG_RTL8723A)
-			FillH2CCmd(Adapter, 70, h2cCmdLen, (pu1Byte)pH2c);
+			rtw_hal_fill_h2c_cmd(Adapter, 70, h2cCmdLen, (pu1Byte)pH2c);
 #elif defined(CONFIG_RTL8723B)
 			rtl8723b_set_FwBtMpOper_cmd(Adapter, pH2c->opCode, pH2c->opCodeVer, pH2c->reqNum, pH2c->buf);
 #endif
@@ -529,7 +525,7 @@ MPTBT_FwC2hBtMpCtrl(
 	
 	if(Adapter->bBTFWReady == _FALSE || Adapter->registrypriv.mp_mode == 0 )
 	{	
-		DBG_8192C("Ignore C2H BT MP Info since not in MP mode \n");
+		//DBG_8192C("Ignore C2H BT MP Info since not in MP mode \n");
 		return;
 	}
 	if( length > 32 || length < 3 )
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_btcoex.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_btcoex.c
index 43ebaf7ea491..157b8757066a 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_btcoex.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_btcoex.c
@@ -28,9 +28,19 @@ void rtw_btcoex_Initialize(PADAPTER padapter)
 	hal_btcoex_Initialize(padapter);
 }
 
-void rtw_btcoex_HAL_Initialize(PADAPTER padapter)
+void rtw_btcoex_PowerOnSetting(PADAPTER padapter)
 {
-	hal_btcoex_InitHwConfig(padapter);
+	hal_btcoex_PowerOnSetting(padapter);
+}
+
+void rtw_btcoex_PreLoadFirmware(PADAPTER padapter)
+{
+	hal_btcoex_PreLoadFirmware(padapter);
+}
+
+void rtw_btcoex_HAL_Initialize(PADAPTER padapter, u8 bWifiOnly)
+{
+	hal_btcoex_InitHwConfig(padapter, bWifiOnly);
 }
 
 void rtw_btcoex_IpsNotify(PADAPTER padapter, u8 type)
@@ -150,9 +160,9 @@ void rtw_btcoex_HaltNotify(PADAPTER padapter)
 	hal_btcoex_HaltNotify(padapter);
 }
 
-void rtw_btcoex_SwitchGntBt(PADAPTER padapter)
+void rtw_btcoex_SwitchBtTRxMask(PADAPTER padapter)
 {
-	hal_btcoex_SwitchGntBt(padapter);	
+	hal_btcoex_SwitchBtTRxMask(padapter);	
 }
 
 void rtw_btcoex_Switch(PADAPTER padapter, u8 enable)
@@ -240,9 +250,9 @@ void rtw_btcoex_SetChipType(PADAPTER padapter, u8 chipType)
 	hal_btcoex_SetChipType(padapter, chipType);
 }
 
-void rtw_btcoex_SetPGAntNum(PADAPTER padapter, u8 antNum, u8 antInverse)
+void rtw_btcoex_SetPGAntNum(PADAPTER padapter, u8 antNum)
 {
-	hal_btcoex_SetPgAntNum(padapter, antNum, antInverse);
+	hal_btcoex_SetPgAntNum(padapter, antNum);
 }
 
 u8 rtw_btcoex_GetPGAntNum(PADAPTER padapter)
@@ -250,6 +260,11 @@ u8 rtw_btcoex_GetPGAntNum(PADAPTER padapter)
 	return hal_btcoex_GetPgAntNum(padapter);
 }
 
+void rtw_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath)
+{
+	hal_btcoex_SetSingleAntPath(padapter, singleAntPath);
+}
+
 u32 rtw_btcoex_GetRaMask(PADAPTER padapter)
 {
 	return hal_btcoex_GetRaMask(padapter);
@@ -291,15 +306,53 @@ u8 rtw_btcoex_IsBtLinkExist(PADAPTER padapter)
 void rtw_btcoex_RejectApAggregatedPacket(PADAPTER padapter, u8 enable)
 {
 	struct mlme_ext_info *pmlmeinfo;
-	struct sta_info *psta;
 
 	pmlmeinfo = &padapter->mlmeextpriv.mlmext_info;
-	psta = rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv));
 
 	if (_TRUE == enable)
 	{
+		struct sta_info *psta = NULL;
+
 		pmlmeinfo->bAcceptAddbaReq = _FALSE;
-		send_delba(padapter, 0, psta->hwaddr);
+
+		if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
+			psta = rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv));
+			if (psta)
+				send_delba(padapter, 0, psta->hwaddr);
+		} else if ((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) {
+			_irqL irqL;
+			_list *phead, *plist;
+			u8 peer_num = 0;
+			char peers[NUM_STA];
+			struct sta_priv *pstapriv = &padapter->stapriv;
+			int i;
+
+			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+
+			phead = &pstapriv->asoc_list;
+			plist = get_next(phead);
+
+			while ((rtw_end_of_queue_search(phead, plist)) == _FALSE) {
+				int stainfo_offset;
+				
+				psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
+				plist = get_next(plist);
+
+				stainfo_offset = rtw_stainfo_offset(pstapriv, psta);
+				if (stainfo_offset_valid(stainfo_offset))
+					peers[peer_num++] = stainfo_offset;
+			}
+	
+			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+
+			if (peer_num) {
+				for (i = 0; i < peer_num; i++) {
+					psta = rtw_get_stainfo_by_offset(pstapriv, peers[i]);
+					if (psta)
+						send_delba(padapter, 0, psta->hwaddr);
+				}
+			}
+		}
 	}
 	else
 	{
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_cmd.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_cmd.c
index 0f9068e3b4f2..bf9d31c6c37c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_cmd.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_cmd.c
@@ -209,6 +209,9 @@ since only spin_lock is used.
 ISR/Call-Back functions can't call this sub-function.
 
 */
+#ifdef DBG_CMD_QUEUE
+extern u8 dump_cmd_id;
+#endif
 
 sint	_rtw_enqueue_cmd(_queue *queue, struct cmd_obj *obj)
 {
@@ -219,11 +222,52 @@ _func_enter_;
 	if (obj == NULL)
 		goto exit;
 
+	if(obj->cmdsz > MAX_CMDSZ ){
+		DBG_871X("%s failed due to obj->cmdsz(%d) > MAX_CMDSZ(%d) \n",__FUNCTION__, obj->cmdsz,MAX_CMDSZ);
+		goto exit;
+	}
 	//_enter_critical_bh(&queue->lock, &irqL);
 	_enter_critical(&queue->lock, &irqL);	
 
 	rtw_list_insert_tail(&obj->list, &queue->queue);
 
+	#ifdef DBG_CMD_QUEUE
+	if(dump_cmd_id){
+		printk("%s===> cmdcode:0x%02x\n",__FUNCTION__,obj->cmdcode);
+		if(obj->cmdcode == GEN_CMD_CODE(_Set_MLME_EVT)){
+			if(obj->parmbuf){
+				struct C2HEvent_Header *pc2h_evt_hdr = (struct C2HEvent_Header *)(obj->parmbuf);
+				printk("pc2h_evt_hdr->ID:0x%02x(%d)\n",pc2h_evt_hdr->ID,pc2h_evt_hdr->ID);
+			}
+		}
+		if(obj->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra)){
+			if(obj->parmbuf){
+				struct drvextra_cmd_parm *pdrvextra_cmd_parm =(struct drvextra_cmd_parm*)(obj->parmbuf);
+				printk("pdrvextra_cmd_parm->ec_id:0x%02x\n",pdrvextra_cmd_parm->ec_id);
+			}
+		}
+	}	
+	
+	if (queue->queue.prev->next != &queue->queue)
+	{
+		DBG_871X("[%d] head %p, tail %p, tail->prev->next %p[tail], tail->next %p[head]\n", __LINE__,
+            &queue->queue, queue->queue.prev, queue->queue.prev->prev->next, queue->queue.prev->next);
+		
+		DBG_871X("==========%s============\n",__FUNCTION__);
+		DBG_871X("head:%p,obj_addr:%p\n",&queue->queue,obj);
+		DBG_871X("padapter: %p\n",obj->padapter);
+		DBG_871X("cmdcode: 0x%02x\n",obj->cmdcode);
+		DBG_871X("res: %d\n",obj->res);
+		DBG_871X("parmbuf: %p\n",obj->parmbuf);
+		DBG_871X("cmdsz: %d\n",obj->cmdsz);
+		DBG_871X("rsp: %p\n",obj->rsp);
+		DBG_871X("rspsz: %d\n",obj->rspsz);
+		DBG_871X("sctx: %p\n",obj->sctx);
+		DBG_871X("list->next: %p\n",obj->list.next);
+		DBG_871X("list->prev: %p\n",obj->list.prev);
+	}
+	#endif //DBG_CMD_QUEUE
+	
 	//_exit_critical_bh(&queue->lock, &irqL);	
 	_exit_critical(&queue->lock, &irqL);
 
@@ -243,11 +287,51 @@ _func_enter_;
 
 	//_enter_critical_bh(&(queue->lock), &irqL);
 	_enter_critical(&queue->lock, &irqL);
-	if (rtw_is_list_empty(&(queue->queue)))
+	
+	#ifdef DBG_CMD_QUEUE
+	if (queue->queue.prev->next != &queue->queue)
+	{
+   		 DBG_871X("[%d] head %p, tail %p, tail->prev->next %p[tail], tail->next %p[head]\n", __LINE__,
+            &queue->queue, queue->queue.prev, queue->queue.prev->prev->next, queue->queue.prev->next);
+	}
+	#endif //DBG_CMD_QUEUE
+
+
+	if (rtw_is_list_empty(&(queue->queue))){
 		obj = NULL;
+	}
 	else
 	{
 		obj = LIST_CONTAINOR(get_next(&(queue->queue)), struct cmd_obj, list);
+
+		#ifdef DBG_CMD_QUEUE
+		if (queue->queue.prev->next != &queue->queue){
+				DBG_871X("==========%s============\n",__FUNCTION__);
+                          DBG_871X("head:%p,obj_addr:%p\n",&queue->queue,obj);
+				DBG_871X("padapter: %p\n",obj->padapter);
+				DBG_871X("cmdcode: 0x%02x\n",obj->cmdcode);
+				DBG_871X("res: %d\n",obj->res);
+				DBG_871X("parmbuf: %p\n",obj->parmbuf);
+				DBG_871X("cmdsz: %d\n",obj->cmdsz);
+				DBG_871X("rsp: %p\n",obj->rsp);
+				DBG_871X("rspsz: %d\n",obj->rspsz);
+				DBG_871X("sctx: %p\n",obj->sctx);                        	
+				DBG_871X("list->next: %p\n",obj->list.next);
+				DBG_871X("list->prev: %p\n",obj->list.prev);
+		}
+		
+		if(dump_cmd_id){
+			DBG_871X("%s===> cmdcode:0x%02x\n",__FUNCTION__,obj->cmdcode);
+		 	if(obj->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra)){
+				if(obj->parmbuf){
+                                struct drvextra_cmd_parm *pdrvextra_cmd_parm =(struct drvextra_cmd_parm*)(obj->parmbuf);
+                                printk("pdrvextra_cmd_parm->ec_id:0x%02x\n",pdrvextra_cmd_parm->ec_id);
+                        }
+                	}
+
+		}	
+		#endif //DBG_CMD_QUEUE
+		
 		rtw_list_delete(&obj->list);
 	}
 
@@ -329,7 +413,6 @@ int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 	if(cmd_obj->cmdcode == GEN_CMD_CODE(_SetChannelPlan))
 		bAllow = _TRUE;
 
-
 	if( (pcmdpriv->padapter->hw_init_completed ==_FALSE && bAllow == _FALSE)
 		|| ATOMIC_READ(&(pcmdpriv->cmdthd_running)) == _FALSE	//com_thread not running
 	)
@@ -352,7 +435,7 @@ u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 	int res = _FAIL;
 	PADAPTER padapter = pcmdpriv->padapter;
 	
-_func_enter_;
+_func_enter_;	
 	
 	if (cmd_obj == NULL) {
 		goto exit;
@@ -373,7 +456,6 @@ _func_enter_;
 
 	res = _rtw_enqueue_cmd(&pcmdpriv->cmd_queue, cmd_obj);
 
-	
 	if(res == _SUCCESS)
 		_rtw_up_sema(&pcmdpriv->cmd_queue_sema);
 	
@@ -389,6 +471,7 @@ struct	cmd_obj	*rtw_dequeue_cmd(struct cmd_priv *pcmdpriv)
 	struct cmd_obj *cmd_obj;
 	
 _func_enter_;		
+
 	cmd_obj = _rtw_dequeue_cmd(&pcmdpriv->cmd_queue);
 		
 _func_exit_;			
@@ -405,14 +488,16 @@ _func_exit_;
 
 void rtw_free_cmd_obj(struct cmd_obj *pcmd)
 {
+	struct drvextra_cmd_parm *extra_parm = NULL;
 _func_enter_;
 
-	if((pcmd->cmdcode!=_JoinBss_CMD_) &&(pcmd->cmdcode!= _CreateBss_CMD_))
-	{
-		//free parmbuf in cmd_obj
-		rtw_mfree((unsigned char*)pcmd->parmbuf, pcmd->cmdsz);
-	}	
-	
+	if(pcmd->parmbuf != NULL){
+		if((pcmd->cmdcode!=_JoinBss_CMD_) &&(pcmd->cmdcode!= _CreateBss_CMD_))
+		{
+			//free parmbuf in cmd_obj
+			rtw_mfree((unsigned char*)pcmd->parmbuf, pcmd->cmdsz);
+		}	
+	}
 	if(pcmd->rsp!=NULL)
 	{
 		if(pcmd->rspsz!= 0)
@@ -431,19 +516,12 @@ _func_exit_;
 
 void rtw_stop_cmd_thread(_adapter *adapter)
 {
-	struct cmd_priv *pcmdpriv = &(adapter->cmdpriv);
-	u8 res;
-
 	if(adapter->cmdThread &&
 		ATOMIC_READ(&(adapter->cmdpriv.cmdthd_running)) == _TRUE &&
 		adapter->cmdpriv.stop_req == 0)
 	{
-		DBG_871X("%s: up sema\n", __func__);
 		adapter->cmdpriv.stop_req = 1;
 		_rtw_up_sema(&adapter->cmdpriv.cmd_queue_sema);
-		DBG_871X("%s: terminate_cmdthread_sema: %d\n",
-			__func__,
-			adapter->cmdpriv.terminate_cmdthread_sema.count);
 		_rtw_down_sema(&adapter->cmdpriv.terminate_cmdthread_sema);
 	}
 }
@@ -460,7 +538,7 @@ thread_return rtw_cmd_thread(thread_context context)
 	PADAPTER padapter = (PADAPTER)context;
 	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
 	struct drvextra_cmd_parm *extra_parm = NULL;
-	
+	_irqL irqL;
 _func_enter_;
 
 	thread_enter("RTW_CMD_THREAD");
@@ -485,8 +563,6 @@ _func_enter_;
 		{
 			DBG_871X_LEVEL(_drv_always_, "%s: DriverStopped(%d) SurpriseRemoved(%d) break at line %d\n",
 				__FUNCTION__, padapter->bDriverStopped, padapter->bSurpriseRemoved, __LINE__);
-			DBG_871X("%s: terminate_cmdthread_sema: %d\n", __func__,
-				padapter->cmdpriv.terminate_cmdthread_sema.count);
 			break;
 		}
 
@@ -495,11 +571,14 @@ _func_enter_;
 			break;
 		}
 		
+		_enter_critical(&pcmdpriv->cmd_queue.lock, &irqL);
 		if(rtw_is_list_empty(&(pcmdpriv->cmd_queue.queue)))
 		{
 			//DBG_871X("%s: cmd queue is empty!\n", __func__);
+			_exit_critical(&pcmdpriv->cmd_queue.lock, &irqL);
 			continue;
 		}
+		_exit_critical(&pcmdpriv->cmd_queue.lock, &irqL);
 
 #ifdef CONFIG_LPS_LCLK
 		if (rtw_register_cmd_alive(padapter) != _SUCCESS)
@@ -530,6 +609,11 @@ _func_enter_;
 		if( _FAIL == rtw_cmd_filter(pcmdpriv, pcmd) )
 		{
 			pcmd->res = H2C_DROPPED;
+			if (pcmd->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra)) {
+				extra_parm = (struct drvextra_cmd_parm *)pcmd->parmbuf;
+				if (extra_parm && extra_parm->pbuf && extra_parm->size > 0)
+					rtw_mfree(extra_parm->pbuf, extra_parm->size);
+			}
 			goto post_process;
 		}
 
@@ -537,6 +621,10 @@ _func_enter_;
 
 		pcmd->cmdsz = _RND4((pcmd->cmdsz));//_RND4
 
+		if(pcmd->cmdsz > MAX_CMDSZ ){
+			DBG_871X("%s cmdsz:%d > MAX_CMDSZ:%d\n",__FUNCTION__,pcmd->cmdsz,MAX_CMDSZ);
+		}
+
 		_rtw_memcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
 
 		if(pcmd->cmdcode < (sizeof(wlancmds) /sizeof(struct cmd_hdl)))
@@ -626,11 +714,9 @@ _func_enter_;
 #ifdef CONFIG_LPS_LCLK
 			rtw_unregister_cmd_alive(padapter);
 #endif
-			DBG_871X("%s: pcmd==NULL\n", __FUNCTION__);
 			break;
 		}
-
-		DBG_871X("%s: leaving... drop cmdcode:%u size:%d\n", __FUNCTION__, pcmd->cmdcode, pcmd->cmdsz);
+		//DBG_871X("%s: leaving... drop cmdcode:%u size:%d\n", __FUNCTION__, pcmd->cmdcode, pcmd->cmdsz);
 
 		if (pcmd->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra)) {
 			extra_parm = (struct drvextra_cmd_parm *)pcmd->parmbuf;
@@ -639,13 +725,16 @@ _func_enter_;
 			}
 		}
 
-		rtw_free_cmd_obj(pcmd);
+		rtw_free_cmd_obj(pcmd);	
 	}while(1);
 
 	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
+	ATOMIC_SET(&(pcmdpriv->cmdthd_running), _FALSE);
 
 _func_exit_;
+
 	thread_exit();
+
 }
 
 
@@ -1353,6 +1442,8 @@ _func_enter_;
 		}
 	}
 
+	pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->network.IEs, pnetwork->network.IELength);
+
 	psecnetwork=(WLAN_BSSID_EX *)&psecuritypriv->sec_bss;
 	if(psecnetwork==NULL)
 	{
@@ -1424,7 +1515,7 @@ _func_enter_;
 		{
 			rtw_ht_use_default_setting(padapter);
 
-			rtw_build_wmm_ie_ht(padapter, &psecnetwork->IEs[12], &psecnetwork->IELength);
+			rtw_build_wmm_ie_ht(padapter, &psecnetwork->IEs[0], &psecnetwork->IELength);
 
 			//rtw_restructure_ht_ie
 			rtw_restructure_ht_ie(padapter, &pnetwork->network.IEs[12], &psecnetwork->IEs[0], 
@@ -1445,8 +1536,6 @@ _func_enter_;
 
 #endif //CONFIG_80211N_HT
 
-	pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->network.IEs, pnetwork->network.IELength);
-
 	#if 0
 	psecuritypriv->supplicant_ie[0]=(u8)psecnetwork->IELength;
 
@@ -1659,7 +1748,6 @@ _func_exit_;
 }
 
 u8 rtw_clearstakey_cmd(_adapter *padapter, struct sta_info *sta, u8 enqueue)
-
 {
 	struct cmd_obj*			ph2c;
 	struct set_stakey_parm	*psetstakey_para;
@@ -1679,7 +1767,6 @@ _func_enter_;
 			clear_cam_entry(padapter, cam_id);
 			rtw_camid_free(padapter, cam_id);
 		}
-
 	}
 	else
 	{
@@ -2114,15 +2201,11 @@ _func_enter_;
 	else
 	{
 		//no need to enqueue, do the cmd hdl directly and free cmd parameter
-		if( H2C_SUCCESS !=set_chplan_hdl(padapter, (unsigned char *)setChannelPlan_param) )
+		if( H2C_SUCCESS != set_chplan_hdl(padapter, (unsigned char *)setChannelPlan_param) )
 			res = _FAIL;
 		
 		rtw_mfree((u8 *)setChannelPlan_param, sizeof(struct SetChannelPlan_param));
 	}
-
-	//do something based on res...
-	if(res == _SUCCESS)
-		padapter->mlmepriv.ChannelPlan = chplan;
 	
 exit:
 
@@ -2296,10 +2379,18 @@ static void collect_traffic_statistics(_adapter *padapter)
 	pdvobjpriv->traffic_stat.cur_rx_tp = (u32)(pdvobjpriv->traffic_stat.cur_rx_bytes *8/2/1024/1024);
 }
 
+//from_timer == 1 means driver is in LPS
 u8 traffic_status_watchdog(_adapter *padapter, u8 from_timer)
 {
 	u8	bEnterPS = _FALSE;
-	u16	BusyThreshold = 100;
+#ifdef CONFIG_BT_COEXIST
+	u16	BusyThresholdHigh = 25;
+	u16	BusyThresholdLow = 10;
+#else
+	u16	BusyThresholdHigh = 100;
+	u16	BusyThresholdLow = 75;
+#endif
+	u16	BusyThreshold = BusyThresholdHigh;
 	u8	bBusyTraffic = _FALSE, bTxBusyTraffic = _FALSE, bRxBusyTraffic = _FALSE;
 	u8	bHigherBusyTraffic = _FALSE, bHigherBusyRxTraffic = _FALSE, bHigherBusyTxTraffic = _FALSE;
 
@@ -2320,16 +2411,12 @@ u8 traffic_status_watchdog(_adapter *padapter, u8 from_timer)
 	if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) 
 		/*&& !MgntInitAdapterInProgress(pMgntInfo)*/)
 	{
-#ifdef CONFIG_BT_COEXIST
-		if( pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 25 ||
-			pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 25 )
-#else // !CONFIG_BT_COEXIST
 		// if we raise bBusyTraffic in last watchdog, using lower threshold.
 		if (pmlmepriv->LinkDetectInfo.bBusyTraffic)
-			BusyThreshold = 75;
+				BusyThreshold = BusyThresholdLow;
+
 		if( pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > BusyThreshold ||
 			pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > BusyThreshold )
-#endif // !CONFIG_BT_COEXIST
 		{
 			bBusyTraffic = _TRUE;
 
@@ -2383,11 +2470,16 @@ u8 traffic_status_watchdog(_adapter *padapter, u8 from_timer)
 #ifdef CONFIG_LPS
 		// check traffic for  powersaving.
 		if( ((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8 ) ||
-			(pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2) )
+#ifdef CONFIG_LPS_SLOW_TRANSITION			
+			(pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2) 
+#else //CONFIG_LPS_SLOW_TRANSITION
+			(pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 4) 
+#endif //CONFIG_LPS_SLOW_TRANSITION
+			)
 		{
 			//DBG_871X("(-)Tx = %d, Rx = %d \n",pmlmepriv->LinkDetectInfo.NumTxOkInPeriod,pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod);
 			bEnterPS= _FALSE;
-
+#ifdef CONFIG_LPS_SLOW_TRANSITION
 			if(bBusyTraffic == _TRUE)
 			{
 				if(pmlmepriv->LinkDetectInfo.TrafficTransitionCount <= 4)
@@ -2402,11 +2494,13 @@ u8 traffic_status_watchdog(_adapter *padapter, u8 from_timer)
 					pmlmepriv->LinkDetectInfo.TrafficTransitionCount = 30;
 				}	
 			}
+#endif //CONFIG_LPS_SLOW_TRANSITION
+	
 		}
 		else
 		{
 			//DBG_871X("(+)Tx = %d, Rx = %d \n",pmlmepriv->LinkDetectInfo.NumTxOkInPeriod,pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod);
-
+#ifdef CONFIG_LPS_SLOW_TRANSITION
 			if(pmlmepriv->LinkDetectInfo.TrafficTransitionCount>=2)
 				pmlmepriv->LinkDetectInfo.TrafficTransitionCount -=2;
 			else
@@ -2414,6 +2508,9 @@ u8 traffic_status_watchdog(_adapter *padapter, u8 from_timer)
 
 			if(pmlmepriv->LinkDetectInfo.TrafficTransitionCount == 0)
 				bEnterPS= _TRUE;
+#else //CONFIG_LPS_SLOW_TRANSITION
+				bEnterPS= _TRUE;
+#endif //CONFIG_LPS_SLOW_TRANSITION
 		}
 
 #ifdef CONFIG_DYNAMIC_DTIM
@@ -2530,8 +2627,9 @@ void dynamic_chk_wk_hdl(_adapter *padapter)
 
 	//if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==_FALSE)
 	{
-		linked_status_chk(padapter);	
+		linked_status_chk(padapter, 0);	
 		traffic_status_watchdog(padapter, 0);
+		dm_DynamicUsbTxAgg(padapter, 0);
 	}
 
 #ifdef CONFIG_BEAMFORMING
@@ -2624,6 +2722,16 @@ _func_enter_;
 			break;
 		case LPS_CTRL_TRAFFIC_BUSY:
 			LPS_Leave(padapter, "LPS_CTRL_TRAFFIC_BUSY");
+			break;
+		case LPS_CTRL_TX_TRAFFIC_LEAVE:
+			LPS_Leave(padapter, "LPS_CTRL_TX_TRAFFIC_LEAVE");
+			break;
+		case LPS_CTRL_RX_TRAFFIC_LEAVE:
+			LPS_Leave(padapter, "LPS_CTRL_RX_TRAFFIC_LEAVE");
+			break;
+		case LPS_CTRL_ENTER:
+			LPS_Enter(padapter, "TRAFFIC_IDLE_1");
+			break;
 		default:
 			break;
 	}
@@ -3053,8 +3161,6 @@ _func_exit_;
 
 #ifdef CONFIG_AP_MODE
 
-extern u32 g_wait_hiq_empty;
-
 static void rtw_chk_hi_queue_hdl(_adapter *padapter)
 {
 	struct sta_info *psta_bmc;
@@ -3068,7 +3174,7 @@ static void rtw_chk_hi_queue_hdl(_adapter *padapter)
 
 	rtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &empty);
 
-	while(_FALSE == empty && rtw_get_passing_time_ms(start) < g_wait_hiq_empty)
+	while(_FALSE == empty && rtw_get_passing_time_ms(start) < rtw_get_wait_hiq_empty_ms())
 	{
 		rtw_msleep_os(100);
 		rtw_hal_get_hwreg(padapter, HW_VAR_CHK_HI_QUEUE_EMPTY, &empty);
@@ -3087,7 +3193,7 @@ static void rtw_chk_hi_queue_hdl(_adapter *padapter)
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
 
 			if (update_tim == _TRUE)
-				update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
+				_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "bmc sleepq and HIQ empty");
 		}
 		else //re check again
 		{
@@ -3134,6 +3240,147 @@ u8 rtw_chk_hi_queue_cmd(_adapter*padapter)
 }
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+struct btinfo {
+	u8 cid;
+	u8 len;
+
+	u8 bConnection:1;
+	u8 bSCOeSCO:1;
+	u8 bInQPage:1;
+	u8 bACLBusy:1;
+	u8 bSCOBusy:1;
+	u8 bHID:1;
+	u8 bA2DP:1;
+	u8 bFTP:1;
+
+	u8 retry_cnt:4;
+	u8 rsvd_34:1;
+	u8 rsvd_35:1;
+	u8 rsvd_36:1;
+	u8 rsvd_37:1;
+
+	u8 rssi;
+
+	u8 rsvd_50:1;
+	u8 rsvd_51:1;
+	u8 rsvd_52:1;
+	u8 rsvd_53:1;
+	u8 rsvd_54:1;
+	u8 rsvd_55:1;
+	u8 eSCO_SCO:1;
+	u8 Master_Slave:1;
+
+	u8 rsvd_6;
+	u8 rsvd_7;
+};
+
+void btinfo_evt_dump(void *sel, void *buf)
+{
+	struct btinfo *info = (struct btinfo *)buf;
+	
+	DBG_871X_SEL_NL(sel, "cid:0x%02x, len:%u\n", info->cid, info->len);
+
+	if (info->len > 2)
+	DBG_871X_SEL_NL(sel, "byte2:%s%s%s%s%s%s%s%s\n"
+		, info->bConnection?"bConnection ":""
+		, info->bSCOeSCO?"bSCOeSCO ":""
+		, info->bInQPage?"bInQPage ":""
+		, info->bACLBusy?"bACLBusy ":""
+		, info->bSCOBusy?"bSCOBusy ":""
+		, info->bHID?"bHID ":""
+		, info->bA2DP?"bA2DP ":""
+		, info->bFTP?"bFTP":""
+	);
+
+	if (info->len > 3)
+	DBG_871X_SEL_NL(sel, "retry_cnt:%u\n", info->retry_cnt);
+
+	if (info->len > 4)
+	DBG_871X_SEL_NL(sel, "rssi:%u\n", info->rssi);
+
+	if (info->len > 5)
+	DBG_871X_SEL_NL(sel, "byte5:%s%s\n"
+		, info->eSCO_SCO?"eSCO_SCO ":""
+		, info->Master_Slave?"Master_Slave ":""
+	);
+}
+
+static void rtw_btinfo_hdl(_adapter *adapter, u8 *buf, u16 buf_len)
+{
+	#define BTINFO_WIFI_FETCH 0x23
+	#define BTINFO_BT_AUTO_RPT 0x27
+	struct btinfo *info = (struct btinfo *)buf;
+	u8 cmd_idx;
+	u8 len;
+
+	cmd_idx = info->cid;
+
+	if (info->len > buf_len-2) {
+		rtw_warn_on(1);
+		len = buf_len-2;
+	} else {
+		len = info->len;
+	}
+
+//#define DBG_PROC_SET_BTINFO_EVT
+#ifdef DBG_PROC_SET_BTINFO_EVT
+	btinfo_evt_dump(RTW_DBGDUMP, info);
+#endif
+
+	/* transform BT-FW btinfo to WiFI-FW C2H format and notify */
+	if (cmd_idx == BTINFO_WIFI_FETCH)
+		buf[1] = 0;
+	else if (cmd_idx == BTINFO_BT_AUTO_RPT)
+		buf[1] = 2;
+	rtw_btcoex_BtInfoNotify(adapter ,len+1, &buf[1]);
+}
+
+u8 rtw_btinfo_cmd(_adapter *adapter, u8 *buf, u16 len)
+{
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
+	u8 *btinfo;
+	struct cmd_priv *pcmdpriv = &adapter->cmdpriv;
+	u8	res = _SUCCESS;
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	if (pdrvextra_cmd_parm == NULL) {
+		rtw_mfree((u8*)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	btinfo = rtw_zmalloc(len);
+	if (btinfo == NULL) {
+		rtw_mfree((u8*)ph2c, sizeof(struct cmd_obj));
+		rtw_mfree((u8*)pdrvextra_cmd_parm, sizeof(struct drvextra_cmd_parm));
+		res = _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = BTINFO_WK_CID;
+	pdrvextra_cmd_parm->type = 0;
+	pdrvextra_cmd_parm->size = len;
+	pdrvextra_cmd_parm->pbuf = btinfo;
+
+	_rtw_memcpy(btinfo, buf, len);
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+	return res;
+}
+#endif
+
 //#ifdef CONFIG_C2H_PACKET_EN
 u8 rtw_c2h_packet_wk_cmd(PADAPTER padapter, u8 *pbuf, u16 length)
 {
@@ -3207,6 +3454,42 @@ u8 rtw_c2h_wk_cmd(PADAPTER padapter, u8 *c2h_evt)
 }
 //#endif //CONFIG_C2H_PACKET_EN
 
+u8 rtw_run_in_thread_cmd(PADAPTER padapter, void (*func)(void*), void* context)
+{
+	struct cmd_priv *pcmdpriv;
+	struct cmd_obj *ph2c;
+	struct RunInThread_param *parm;
+	s32 res = _SUCCESS;
+
+_func_enter_;
+
+	pcmdpriv = &padapter->cmdpriv;
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (NULL == ph2c) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	parm = (struct RunInThread_param*)rtw_zmalloc(sizeof(struct RunInThread_param));
+	if (NULL == parm) {
+		rtw_mfree((u8*)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
+		goto exit;
+	}
+
+	parm->func = func;
+	parm->context = context;
+	init_h2fwcmd_w_parm_no_rsp(ph2c, parm, GEN_CMD_CODE(_RunInThreadCMD));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+_func_exit_;
+
+	return res;
+}
+
 s32 c2h_evt_hdl(_adapter *adapter, u8 *c2h_evt, c2h_id_filter filter)
 {
 	s32 ret = _FAIL;
@@ -3366,7 +3649,11 @@ u8 rtw_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf)
 		case DM_RA_MSK_WK_CID:
 			rtw_dm_ra_mask_hdl(padapter, (struct sta_info *)pdrvextra_cmd->pbuf);
 			break;
-
+#ifdef CONFIG_BT_COEXIST
+		case BTINFO_WK_CID:
+			rtw_btinfo_hdl(padapter ,pdrvextra_cmd->pbuf, pdrvextra_cmd->size);
+			break;
+#endif
 		default:
 			break;
 	}
@@ -3404,16 +3691,16 @@ _func_exit_;
 void rtw_disassoc_cmd_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {
 	_irqL	irqL;
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
-
-_func_enter_;
+	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	
+_func_enter_;	
 
 	if (pcmd->res != H2C_SUCCESS)
 	{
 		_enter_critical_bh(&pmlmepriv->lock, &irqL);
 		set_fwstate(pmlmepriv, _FW_LINKED);
 		_exit_critical_bh(&pmlmepriv->lock, &irqL);
-
+				
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ***Error: disconnect_cmd_callback Fail ***\n."));
 
 		goto exit;
@@ -3425,16 +3712,16 @@ _func_enter_;
 
 	// free cmd
 	rtw_free_cmd_obj(pcmd);
-
+	
 exit:
-
-_func_exit_;
+	
+_func_exit_;	
 }
 
 
 void rtw_joinbss_cmd_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {
-	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct	mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct	mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u16	val;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_debug.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_debug.c
index 6413f5b921fd..72cad7378d2c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_debug.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_debug.c
@@ -151,6 +151,51 @@ void rf_reg_dump(void *sel, _adapter *adapter)
 	}
 }
 
+static u8 fwdl_test_chksum_fail = 0;
+static u8 fwdl_test_wintint_rdy_fail = 0;
+
+bool rtw_fwdl_test_trigger_chksum_fail()
+{
+	if (fwdl_test_chksum_fail) {
+		DBG_871X_LEVEL(_drv_always_, "fwdl test case: trigger chksum_fail\n");
+		fwdl_test_chksum_fail--;
+		return _TRUE;
+	}
+	return _FALSE;
+}
+
+bool rtw_fwdl_test_trigger_wintint_rdy_fail()
+{
+	if (fwdl_test_wintint_rdy_fail) {
+		DBG_871X_LEVEL(_drv_always_, "fwdl test case: trigger wintint_rdy_fail\n");
+		fwdl_test_wintint_rdy_fail--;
+		return _TRUE;
+	}
+	return _FALSE;
+}
+
+static u32 g_wait_hiq_empty_ms = 0;
+
+u32 rtw_get_wait_hiq_empty_ms()
+{
+	return g_wait_hiq_empty_ms;
+}
+
+void rtw_sink_rtp_seq_dbg( _adapter *adapter,_pkt *pkt)
+{
+	struct recv_priv *precvpriv = &(adapter->recvpriv);
+	if( precvpriv->sink_udpport > 0)
+	{
+		if(*((u16*)((pkt->data)+0x24)) == cpu_to_be16(precvpriv->sink_udpport))
+		{
+			precvpriv->pre_rtp_rxseq= precvpriv->cur_rtp_rxseq;
+			precvpriv->cur_rtp_rxseq = be16_to_cpu(*((u16*)((pkt->data)+0x2C)));
+			if( precvpriv->pre_rtp_rxseq+1 != precvpriv->cur_rtp_rxseq)
+				DBG_871X("%s : RTP Seq num from %d to %d\n",__FUNCTION__,precvpriv->pre_rtp_rxseq,precvpriv->cur_rtp_rxseq);
+		}
+	}
+}
+
 #ifdef CONFIG_PROC_DEBUG
 ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
@@ -466,15 +511,18 @@ int proc_get_survey_info(struct seq_file *m, void *v)
 	struct wlan_network	*pnetwork = NULL;
 	_list	*plist, *phead;
 	s32 notify_signal;
+	s16 notify_noise = 0;
 	u16  index = 0;
 
 	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);	
 	phead = get_list_head(queue);
+	if(!phead)
+		return 0;
 	plist = get_next(phead);
-	if ((!phead) || (!plist))
+	if (!plist)
 		return 0;
 
-	DBG_871X_SEL_NL(m, "%5s  %-17s  %3s  %-3s  %-4s  %5s  %s\n","index", "bssid", "ch", "dBm", "SdBm", "age", "ssid");
+	DBG_871X_SEL_NL(m, "%5s  %-17s  %3s  %-3s  %-4s  %-4s  %5s  %s\n","index", "bssid", "ch", "RSSI", "SdBm", "Noise", "age", "ssid");
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
@@ -490,13 +538,18 @@ int proc_get_survey_info(struct seq_file *m, void *v)
 		} else {
 			notify_signal = translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);//dbm
 		}
+
+		#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		rtw_hal_get_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&(pnetwork->network.Configuration.DSConfig), &(notify_noise));
+		#endif
 	
-		DBG_871X_SEL_NL(m, "%5d  "MAC_FMT"  %3d  %3d  %4d  %5d  %s\n", 
+		DBG_871X_SEL_NL(m, "%5d  "MAC_FMT"  %3d  %3d  %4d  %4d  %5d  %s\n", 
 			++index,
 			MAC_ARG(pnetwork->network.MacAddress), 
 			pnetwork->network.Configuration.DSConfig,
 			(int)pnetwork->network.Rssi,
 			notify_signal,
+			notify_noise,
 			rtw_get_passing_time_ms((u32)pnetwork->last_scanned),
 			//translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength),
 			pnetwork->network.Ssid.Ssid);
@@ -564,8 +617,14 @@ int proc_get_adapter_state(struct seq_file *m, void *v)
 	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
-	DBG_871X_SEL_NL(m, "bSurpriseRemoved=%d, bDriverStopped=%d\n", 
-						padapter->bSurpriseRemoved, padapter->bDriverStopped);
+#ifdef CONFIG_CONCURRENT_MODE
+	DBG_871X_SEL_NL(m, "name=%s, iface_type=%d, bSurpriseRemoved=%d, bDriverStopped=%d\n",
+					dev->name, padapter->iface_type,
+					padapter->bSurpriseRemoved, padapter->bDriverStopped);
+#else
+	DBG_871X_SEL_NL(m, "name=%s, bSurpriseRemoved=%d, bDriverStopped=%d\n",
+					dev->name, padapter->bSurpriseRemoved, padapter->bDriverStopped);
+#endif
 
 	return 0;
 }
@@ -579,6 +638,8 @@ int proc_get_trx_info(struct seq_file *m, void *v)
 	struct recv_priv  *precvpriv = &padapter->recvpriv;
 	struct hw_xmit *phwxmit;
 
+	dump_os_queue(m, padapter);
+
 	DBG_871X_SEL_NL(m, "free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d\n"
 		, pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt);
 	DBG_871X_SEL_NL(m, "free_ext_xmitbuf_cnt=%d, free_xframe_ext_cnt=%d\n"
@@ -593,21 +654,60 @@ int proc_get_trx_info(struct seq_file *m, void *v)
 	}
 
 #ifdef CONFIG_USB_HCI
-	DBG_871X_SEL_NL(m, "rx_urb_pending_cn=%d\n", precvpriv->rx_pending_cnt);
+	DBG_871X_SEL_NL(m, "rx_urb_pending_cn=%d\n", ATOMIC_READ(&(precvpriv->rx_pending_cnt)));
 #endif
 
 	return 0;
 }
 
+int proc_get_dis_pwt(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 dis_pwt = 0;
+	rtw_hal_get_def_var(padapter, HAL_DEF_DBG_DIS_PWT, &(dis_pwt));
+	DBG_871X_SEL_NL(m, " Tx Power training mode:%s \n",(dis_pwt==_TRUE)?"Disable":"Enable");
+	return 0;
+}
+ssize_t proc_set_dis_pwt(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[4]={0};
+	u8 dis_pwt = 0;
+	
+	if (count < 1)
+		return -EFAULT;
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%hhx", &dis_pwt);
+		DBG_871X("Set Tx Power training mode:%s \n",(dis_pwt==_TRUE)?"Disable":"Enable");
+		
+		if (num >= 1)
+			rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DIS_PWT, &(dis_pwt));
+	}
+
+	return count;
+	
+}
+
 int proc_get_rate_ctl(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
 	int i;
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
-
+	u8 data_rate = 0, sgi=0, data_fb = 0;
+		
 	if (adapter->fix_rate != 0xff) {
-		DBG_871X_SEL_NL(m, "FIX\n");
-		DBG_871X_SEL_NL(m, "0x%02x\n", adapter->fix_rate);
+		data_rate = adapter->fix_rate & 0x7F;
+		sgi = adapter->fix_rate >>7;
+		data_fb = adapter->data_fb?1:0;
+		DBG_871X_SEL_NL(m, "FIXED %s%s%s\n"
+			, HDATA_RATE(data_rate)
+			, sgi?" SGI":" LGI"
+			, data_fb?" FB":""
+		);
+		DBG_871X_SEL_NL(m, "0x%02x %u\n", adapter->fix_rate, adapter->data_fb);
 	} else {
 		DBG_871X_SEL_NL(m, "RA\n");
 	}
@@ -621,24 +721,24 @@ ssize_t proc_set_rate_ctl(struct file *file, const char __user *buffer, size_t c
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
 	char tmp[32];
 	u8 fix_rate;
+	u8 data_fb;
 
 	if (count < 1)
 		return -EFAULT;
 
 	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
-		int num = sscanf(tmp, "%hhx", &fix_rate);
+		int num = sscanf(tmp, "%hhx %hhu", &fix_rate, &data_fb);
 
 		if (num >= 1)
 			adapter->fix_rate = fix_rate;
+		if (num >= 2)
+			adapter->data_fb = data_fb?1:0;
 	}
 
 	return count;
 }
 
-u8 g_fwdl_chksum_fail = 0;
-u8 g_fwdl_wintint_rdy_fail = 0;
-
 ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
@@ -649,14 +749,12 @@ ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, si
 		return -EFAULT;
 
 	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
-		int num = sscanf(tmp, "%hhu %hhu", &g_fwdl_chksum_fail, &g_fwdl_wintint_rdy_fail);
+		int num = sscanf(tmp, "%hhu %hhu", &fwdl_test_chksum_fail, &fwdl_test_wintint_rdy_fail);
 	}
 
 	return count;
 }
 
-u32 g_wait_hiq_empty = 0;
-
 ssize_t proc_set_wait_hiq_empty(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
@@ -667,7 +765,7 @@ ssize_t proc_set_wait_hiq_empty(struct file *file, const char __user *buffer, si
 		return -EFAULT;
 
 	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
-		int num = sscanf(tmp, "%u", &g_wait_hiq_empty);
+		int num = sscanf(tmp, "%u", &g_wait_hiq_empty_ms);
 	}
 
 	return count;
@@ -712,24 +810,268 @@ int proc_get_suspend_resume_info(struct seq_file *m, void *v)
 	return 0;
 }
 
-int proc_get_rx_signal(struct seq_file *m, void *v)
+#ifdef CONFIG_DBG_COUNTER
+
+int proc_get_rx_logs(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct rx_logs *rx_logs = &padapter->rx_logs;
+
+	DBG_871X_SEL_NL(m, 
+		"intf_rx=%d\n"
+		"intf_rx_err_recvframe=%d\n"
+		"intf_rx_err_skb=%d\n"
+		"intf_rx_report=%d\n"
+		"core_rx=%d\n"
+		"core_rx_pre=%d\n"
+		"core_rx_pre_ver_err=%d\n"
+		"core_rx_pre_mgmt=%d\n"
+		"core_rx_pre_mgmt_err_80211w=%d\n"
+		"core_rx_pre_mgmt_err=%d\n"
+		"core_rx_pre_ctrl=%d\n"
+		"core_rx_pre_ctrl_err=%d\n"
+		"core_rx_pre_data=%d\n"
+		"core_rx_pre_data_wapi_seq_err=%d\n"
+		"core_rx_pre_data_wapi_key_err=%d\n"
+		"core_rx_pre_data_handled=%d\n"
+		"core_rx_pre_data_err=%d\n"
+		"core_rx_pre_data_unknown=%d\n"
+		"core_rx_pre_unknown=%d\n"
+		"core_rx_enqueue=%d\n"
+		"core_rx_dequeue=%d\n"
+		"core_rx_post=%d\n"
+		"core_rx_post_decrypt=%d\n"
+		"core_rx_post_decrypt_wep=%d\n"
+		"core_rx_post_decrypt_tkip=%d\n"
+		"core_rx_post_decrypt_aes=%d\n"
+		"core_rx_post_decrypt_wapi=%d\n"
+		"core_rx_post_decrypt_hw=%d\n"
+		"core_rx_post_decrypt_unknown=%d\n"
+		"core_rx_post_decrypt_err=%d\n"
+		"core_rx_post_defrag_err=%d\n"
+		"core_rx_post_portctrl_err=%d\n"
+		"core_rx_post_indicate=%d\n"
+		"core_rx_post_indicate_in_oder=%d\n"
+		"core_rx_post_indicate_reoder=%d\n"
+		"core_rx_post_indicate_err=%d\n"
+		"os_indicate=%d\n"
+		"os_indicate_ap_mcast=%d\n"
+		"os_indicate_ap_forward=%d\n"
+		"os_indicate_ap_self=%d\n"
+		"os_indicate_err=%d\n"
+		"os_netif_ok=%d\n"
+		"os_netif_err=%d\n",
+		rx_logs->intf_rx,
+		rx_logs->intf_rx_err_recvframe,
+		rx_logs->intf_rx_err_skb,
+		rx_logs->intf_rx_report,
+		rx_logs->core_rx,
+		rx_logs->core_rx_pre,
+		rx_logs->core_rx_pre_ver_err,
+		rx_logs->core_rx_pre_mgmt,
+		rx_logs->core_rx_pre_mgmt_err_80211w,
+		rx_logs->core_rx_pre_mgmt_err,
+		rx_logs->core_rx_pre_ctrl,
+		rx_logs->core_rx_pre_ctrl_err,
+		rx_logs->core_rx_pre_data,
+		rx_logs->core_rx_pre_data_wapi_seq_err,
+		rx_logs->core_rx_pre_data_wapi_key_err,
+		rx_logs->core_rx_pre_data_handled,
+		rx_logs->core_rx_pre_data_err,
+		rx_logs->core_rx_pre_data_unknown,
+		rx_logs->core_rx_pre_unknown,
+		rx_logs->core_rx_enqueue,
+		rx_logs->core_rx_dequeue,
+		rx_logs->core_rx_post,
+		rx_logs->core_rx_post_decrypt,
+		rx_logs->core_rx_post_decrypt_wep,
+		rx_logs->core_rx_post_decrypt_tkip,
+		rx_logs->core_rx_post_decrypt_aes,
+		rx_logs->core_rx_post_decrypt_wapi,
+		rx_logs->core_rx_post_decrypt_hw,
+		rx_logs->core_rx_post_decrypt_unknown,
+		rx_logs->core_rx_post_decrypt_err,
+		rx_logs->core_rx_post_defrag_err,
+		rx_logs->core_rx_post_portctrl_err,
+		rx_logs->core_rx_post_indicate,
+		rx_logs->core_rx_post_indicate_in_oder,
+		rx_logs->core_rx_post_indicate_reoder,
+		rx_logs->core_rx_post_indicate_err,
+		rx_logs->os_indicate,
+		rx_logs->os_indicate_ap_mcast,
+		rx_logs->os_indicate_ap_forward,
+		rx_logs->os_indicate_ap_self,
+		rx_logs->os_indicate_err,
+		rx_logs->os_netif_ok,
+		rx_logs->os_netif_err
+	);
 
-	DBG_871X_SEL_NL(m, "rssi:%d\n", padapter->recvpriv.rssi);
-	//DBG_871X_SEL_NL(m, "rxpwdb:%d\n", padapter->recvpriv.rxpwdb);
-	DBG_871X_SEL_NL(m, "signal_strength:%u\n", padapter->recvpriv.signal_strength);
-	DBG_871X_SEL_NL(m, "signal_qual:%u\n", padapter->recvpriv.signal_qual);
-	DBG_871X_SEL_NL(m, "noise:%u\n", padapter->recvpriv.noise);
-	rtw_odm_get_perpkt_rssi(m,padapter);
-	#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA
-	rtw_get_raw_rssi_info(m,padapter);
-	#endif
 	return 0;
 }
 
+int proc_get_tx_logs(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct tx_logs *tx_logs = &padapter->tx_logs;
+	
+	DBG_871X_SEL_NL(m,
+		"os_tx=%d\n"
+		"os_tx_err_up=%d\n"
+		"os_tx_err_xmit=%d\n"
+		"os_tx_m2u=%d\n"
+		"os_tx_m2u_ignore_fw_linked=%d\n"
+		"os_tx_m2u_ignore_self=%d\n"
+		"os_tx_m2u_entry=%d\n"
+		"os_tx_m2u_entry_err_xmit=%d\n"
+		"os_tx_m2u_entry_err_skb=%d\n"
+		"os_tx_m2u_stop=%d\n"
+		"core_tx=%d\n"
+		"core_tx_err_pxmitframe=%d\n"
+		"core_tx_err_brtx=%d\n"
+		"core_tx_upd_attrib=%d\n"
+		"core_tx_upd_attrib_adhoc=%d\n"
+		"core_tx_upd_attrib_sta=%d\n"
+		"core_tx_upd_attrib_ap=%d\n"
+		"core_tx_upd_attrib_unknown=%d\n"
+		"core_tx_upd_attrib_dhcp=%d\n"
+		"core_tx_upd_attrib_icmp=%d\n"
+		"core_tx_upd_attrib_active=%d\n"
+		"core_tx_upd_attrib_err_ucast_sta=%d\n"
+		"core_tx_upd_attrib_err_ucast_ap_link=%d\n"
+		"core_tx_upd_attrib_err_sta=%d\n"
+		"core_tx_upd_attrib_err_link=%d\n"
+		"core_tx_upd_attrib_err_sec=%d\n"
+		"core_tx_ap_enqueue_warn_fwstate=%d\n"
+		"core_tx_ap_enqueue_warn_sta=%d\n"
+		"core_tx_ap_enqueue_warn_nosta=%d\n"
+		"core_tx_ap_enqueue_warn_link=%d\n"
+		"core_tx_ap_enqueue_warn_trigger=%d\n"
+		"core_tx_ap_enqueue_mcast=%d\n"
+		"core_tx_ap_enqueue_ucast=%d\n"
+		"core_tx_ap_enqueue=%d\n"
+		"intf_tx=%d\n"
+		"intf_tx_pending_ac=%d\n"
+		"intf_tx_pending_fw_under_survey=%d\n"
+		"intf_tx_pending_fw_under_linking=%d\n"
+		"intf_tx_pending_xmitbuf=%d\n"
+		"intf_tx_enqueue=%d\n"
+		"core_tx_enqueue=%d\n"
+		"core_tx_enqueue_class=%d\n"
+		"core_tx_enqueue_class_err_sta=%d\n"
+		"core_tx_enqueue_class_err_nosta=%d\n"
+		"core_tx_enqueue_class_err_fwlink=%d\n"
+		"intf_tx_direct=%d\n"
+		"intf_tx_direct_err_coalesce=%d\n"
+		"intf_tx_dequeue=%d\n"
+		"intf_tx_dequeue_err_coalesce=%d\n"
+		"intf_tx_dump_xframe=%d\n"
+		"intf_tx_dump_xframe_err_txdesc=%d\n"
+		"intf_tx_dump_xframe_err_port=%d\n",
+		tx_logs->os_tx,
+		tx_logs->os_tx_err_up,
+		tx_logs->os_tx_err_xmit,
+		tx_logs->os_tx_m2u,
+		tx_logs->os_tx_m2u_ignore_fw_linked,
+		tx_logs->os_tx_m2u_ignore_self,
+		tx_logs->os_tx_m2u_entry,
+		tx_logs->os_tx_m2u_entry_err_xmit,
+		tx_logs->os_tx_m2u_entry_err_skb,
+		tx_logs->os_tx_m2u_stop,
+		tx_logs->core_tx,
+		tx_logs->core_tx_err_pxmitframe,
+		tx_logs->core_tx_err_brtx,
+		tx_logs->core_tx_upd_attrib,
+		tx_logs->core_tx_upd_attrib_adhoc,
+		tx_logs->core_tx_upd_attrib_sta,
+		tx_logs->core_tx_upd_attrib_ap,
+		tx_logs->core_tx_upd_attrib_unknown,
+		tx_logs->core_tx_upd_attrib_dhcp,
+		tx_logs->core_tx_upd_attrib_icmp,
+		tx_logs->core_tx_upd_attrib_active,
+		tx_logs->core_tx_upd_attrib_err_ucast_sta,
+		tx_logs->core_tx_upd_attrib_err_ucast_ap_link,
+		tx_logs->core_tx_upd_attrib_err_sta,
+		tx_logs->core_tx_upd_attrib_err_link,
+		tx_logs->core_tx_upd_attrib_err_sec,
+		tx_logs->core_tx_ap_enqueue_warn_fwstate,
+		tx_logs->core_tx_ap_enqueue_warn_sta,
+		tx_logs->core_tx_ap_enqueue_warn_nosta,
+		tx_logs->core_tx_ap_enqueue_warn_link,
+		tx_logs->core_tx_ap_enqueue_warn_trigger,
+		tx_logs->core_tx_ap_enqueue_mcast,
+		tx_logs->core_tx_ap_enqueue_ucast,
+		tx_logs->core_tx_ap_enqueue,
+		tx_logs->intf_tx,
+		tx_logs->intf_tx_pending_ac,
+		tx_logs->intf_tx_pending_fw_under_survey,
+		tx_logs->intf_tx_pending_fw_under_linking,
+		tx_logs->intf_tx_pending_xmitbuf,
+		tx_logs->intf_tx_enqueue,
+		tx_logs->core_tx_enqueue,
+		tx_logs->core_tx_enqueue_class,
+		tx_logs->core_tx_enqueue_class_err_sta,
+		tx_logs->core_tx_enqueue_class_err_nosta,
+		tx_logs->core_tx_enqueue_class_err_fwlink,
+		tx_logs->intf_tx_direct,
+		tx_logs->intf_tx_direct_err_coalesce,
+		tx_logs->intf_tx_dequeue,
+		tx_logs->intf_tx_dequeue_err_coalesce,
+		tx_logs->intf_tx_dump_xframe,
+		tx_logs->intf_tx_dump_xframe_err_txdesc,
+		tx_logs->intf_tx_dump_xframe_err_port
+	);
+
+	return 0;
+}
+
+int proc_get_int_logs(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	DBG_871X_SEL_NL(m,
+		"all=%d\n"
+		"err=%d\n"
+		"tbdok=%d\n"
+		"tbder=%d\n"
+		"bcnderr=%d\n"
+		"bcndma=%d\n"
+		"bcndma_e=%d\n"
+		"rx=%d\n"
+		"rx_rdu=%d\n"
+		"rx_fovw=%d\n"
+		"txfovw=%d\n"
+		"mgntok=%d\n"
+		"highdok=%d\n"
+		"bkdok=%d\n"
+		"bedok=%d\n"
+		"vidok=%d\n"
+		"vodok=%d\n",
+		padapter->int_logs.all,
+		padapter->int_logs.err,
+		padapter->int_logs.tbdok,
+		padapter->int_logs.tbder,
+		padapter->int_logs.bcnderr,
+		padapter->int_logs.bcndma,
+		padapter->int_logs.bcndma_e,
+		padapter->int_logs.rx,
+		padapter->int_logs.rx_rdu,
+		padapter->int_logs.rx_fovw,
+		padapter->int_logs.txfovw,
+		padapter->int_logs.mgntok,
+		padapter->int_logs.highdok,
+		padapter->int_logs.bkdok,
+		padapter->int_logs.bedok,
+		padapter->int_logs.vidok,
+		padapter->int_logs.vodok
+	);
+
+	return 0;
+}
+
+#endif // CONFIG_DBG_COUNTER
 
 int proc_get_hw_status(struct seq_file *m, void *v)
 {
@@ -744,6 +1086,24 @@ int proc_get_hw_status(struct seq_file *m, void *v)
 	return 0;
 }
 
+int proc_get_rx_signal(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	DBG_871X_SEL_NL(m, "rssi:%d\n", padapter->recvpriv.rssi);
+	//DBG_871X_SEL_NL(m, "rxpwdb:%d\n", padapter->recvpriv.rxpwdb);
+	DBG_871X_SEL_NL(m, "signal_strength:%u\n", padapter->recvpriv.signal_strength);
+	DBG_871X_SEL_NL(m, "signal_qual:%u\n", padapter->recvpriv.signal_qual);
+	DBG_871X_SEL_NL(m, "noise:%d\n", padapter->recvpriv.noise);
+	rtw_odm_get_perpkt_rssi(m,padapter);
+	#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA
+	rtw_get_raw_rssi_info(m,padapter);
+	#endif
+	return 0;
+}
+
 ssize_t proc_set_rx_signal(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
@@ -807,10 +1167,10 @@ ssize_t proc_set_ht_enable(struct file *file, const char __user *buffer, size_t
 
 		int num = sscanf(tmp, "%d ", &mode);
 
-		if( pregpriv && mode >= 0 && mode < 2 )
+		if( pregpriv && mode < 2 )
 		{
 			pregpriv->ht_enable= mode;
-			printk("ht_enable=%d\n", pregpriv->ht_enable);
+			DBG_871X("ht_enable=%d\n", pregpriv->ht_enable);
 		}
 	}
 	
@@ -930,7 +1290,7 @@ ssize_t proc_set_rx_ampdu(struct file *file, const char __user *buffer, size_t c
 
 		int num = sscanf(tmp, "%d ", &mode);
 
-		if( pregpriv && mode >= 0 && mode < 2 )
+		if( pregpriv && mode < 2 )
 		{
 			pmlmeinfo->bAcceptAddbaReq = mode;
 			DBG_871X("pmlmeinfo->bAcceptAddbaReq=%d \n",pmlmeinfo->bAcceptAddbaReq);
@@ -945,7 +1305,135 @@ ssize_t proc_set_rx_ampdu(struct file *file, const char __user *buffer, size_t c
 
 	return count;
 }
+int proc_get_rx_ampdu_factor(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+
+	if(padapter)
+	{
+		DBG_871X_SEL_NL(m,"rx ampdu factor = %x\n",padapter->driver_rx_ampdu_factor);
+	}
+	
+	return 0;
+}
+
+ssize_t proc_set_rx_ampdu_factor(struct file *file, const char __user *buffer
+                                 , size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 factor;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp)))
+	{
+
+		int num = sscanf(tmp, "%d ", &factor);
+
+		if( padapter && (num == 1) )
+		{
+			DBG_871X("padapter->driver_rx_ampdu_factor = %x\n", factor);
+
+			if(factor  > 0x03)
+				padapter->driver_rx_ampdu_factor = 0xFF;
+			else
+				padapter->driver_rx_ampdu_factor = factor;			
+		}
+	}
+
+	return count;
+}
+
+int proc_get_rx_ampdu_density(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+
+	if(padapter)
+	{
+		DBG_871X_SEL_NL(m,"rx ampdu densityg = %x\n",padapter->driver_rx_ampdu_spacing);
+	}
+
+	return 0;
+}
+
+ssize_t proc_set_rx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 density;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp)))
+	{
+
+		int num = sscanf(tmp, "%d ", &density);
+
+		if( padapter && (num == 1) )
+		{
+			DBG_871X("padapter->driver_rx_ampdu_spacing = %x\n", density);
+
+			if(density > 0x07)
+				padapter->driver_rx_ampdu_spacing = 0xFF;
+			else
+				padapter->driver_rx_ampdu_spacing = density;
+		}
+	}
+
+	return count;
+}
+
+int proc_get_tx_ampdu_density(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+
+	if(padapter)
+	{
+		DBG_871X_SEL_NL(m,"tx ampdu density = %x\n",padapter->driver_ampdu_spacing);
+	}
 
+	return 0;
+}
+
+ssize_t proc_set_tx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 density;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp)))
+	{
+
+		int num = sscanf(tmp, "%d ", &density);
+
+		if( padapter && (num == 1) )
+		{
+			DBG_871X("padapter->driver_ampdu_spacing = %x\n", density);
+
+			if(density > 0x07)
+				padapter->driver_ampdu_spacing = 0xFF;
+			else
+				padapter->driver_ampdu_spacing = density;
+		}
+	}
+
+	return count;
+}
 #endif //CONFIG_80211N_HT
 
 int proc_get_en_fwps(struct seq_file *m, void *v)
@@ -980,7 +1468,7 @@ ssize_t proc_set_en_fwps(struct file *file, const char __user *buffer, size_t co
 
 		int num = sscanf(tmp, "%d ", &mode);
 
-		if( pregpriv && mode >= 0 && mode < 2 )
+		if( pregpriv &&  mode < 2 )
 		{
 			pregpriv->check_fw_ps = mode;
 			DBG_871X("pregpriv->check_fw_ps=%d \n",pregpriv->check_fw_ps);
@@ -1044,13 +1532,14 @@ ssize_t proc_set_rx_stbc(struct file *file, const char __user *buffer, size_t co
 }
 #endif //CONFIG_80211N_HT
 
-int proc_get_rssi_disp(struct seq_file *m, void *v)
+/*int proc_get_rssi_disp(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
 	return 0;
 }
+*/
 
-ssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+/*ssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
@@ -1089,7 +1578,7 @@ ssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t
 	
 }	
 
-		
+*/		
 #ifdef CONFIG_AP_MODE
 
 int proc_get_all_sta_info(struct seq_file *m, void *v)
@@ -1131,6 +1620,11 @@ int proc_get_all_sta_info(struct seq_file *m, void *v)
 				DBG_871X_SEL_NL(m, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
 #endif //CONFIG_80211N_HT
 				DBG_871X_SEL_NL(m, "sleepq_len=%d\n", psta->sleepq_len);
+				DBG_871X_SEL_NL(m, "sta_xmitpriv.vo_q_qcnt=%d\n", psta->sta_xmitpriv.vo_q.qcnt);
+				DBG_871X_SEL_NL(m, "sta_xmitpriv.vi_q_qcnt=%d\n", psta->sta_xmitpriv.vi_q.qcnt);
+				DBG_871X_SEL_NL(m, "sta_xmitpriv.be_q_qcnt=%d\n", psta->sta_xmitpriv.be_q.qcnt);
+				DBG_871X_SEL_NL(m, "sta_xmitpriv.bk_q_qcnt=%d\n", psta->sta_xmitpriv.bk_q.qcnt);
+
 				DBG_871X_SEL_NL(m, "capability=0x%x\n", psta->capability);
 				DBG_871X_SEL_NL(m, "flags=0x%x\n", psta->flags);
 				DBG_871X_SEL_NL(m, "wpa_psk=0x%x\n", psta->wpa_psk);
@@ -1199,7 +1693,7 @@ int proc_get_best_channel(struct seq_file *m, void *v)
 			index_5G = i;
 	}	
 	
-	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+	for (i=0; (i < MAX_CHANNEL_NUM) && (pmlmeext->channel_set[i].ChannelNum !=0) ; i++) {
 		// 2.4G
 		if ( pmlmeext->channel_set[i].ChannelNum == 6 ) {
 			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
@@ -1403,5 +1897,148 @@ ssize_t proc_set_sreset(struct file *file, const char __user *buffer, size_t cou
 }
 #endif /* DBG_CONFIG_ERROR_DETECT */
 
+#ifdef CONFIG_PCI_HCI
+
+int proc_get_rx_ring(struct seq_file *m, void *v)
+{
+	_irqL irqL;
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *) rtw_netdev_priv(dev);
+	struct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct rtw_rx_ring *rx_ring = &precvpriv->rx_ring[RX_MPDU_QUEUE];
+	int i, j;
+
+	DBG_871X_SEL_NL(m, "rx ring (%p)\n", rx_ring);
+	DBG_871X_SEL_NL(m, "  dma: 0x%08x\n", (int) rx_ring->dma);
+	DBG_871X_SEL_NL(m, "  idx: %d\n", rx_ring->idx);
+
+	_enter_critical(&pdvobjpriv->irq_th_lock, &irqL);
+	for (i=0; i<precvpriv->rxringcount; i++)
+	{
+		struct recv_stat *entry = &rx_ring->desc[i];
+		struct sk_buff *skb = rx_ring->rx_buf[i];
+
+		DBG_871X_SEL_NL(m, "  desc[%03d]: %p, rx_buf[%03d]: 0x%08x\n",
+			i, entry, i, cpu_to_le32(*((dma_addr_t *)skb->cb)));
+
+		for (j=0; j<sizeof(*entry)/4; j++)
+		{
+			if ((j % 4) == 0)
+				DBG_871X_SEL_NL(m, "  0x%03x", j);
+
+			DBG_871X_SEL_NL(m, " 0x%08x ", ((int *) entry)[j]);
+
+			if ((j % 4) == 3)
+				DBG_871X_SEL_NL(m, "\n");
+		}
+	}
+	_exit_critical(&pdvobjpriv->irq_th_lock, &irqL);
+
+	return 0;
+}
+
+int proc_get_tx_ring(struct seq_file *m, void *v)
+{
+	_irqL irqL;
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *) rtw_netdev_priv(dev);
+	struct dvobj_priv *pdvobjpriv = adapter_to_dvobj(padapter);
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	int i, j, k;
+
+	_enter_critical(&pdvobjpriv->irq_th_lock, &irqL);
+	for (i = 0; i < PCI_MAX_TX_QUEUE_COUNT; i++)
+	{
+		struct rtw_tx_ring *tx_ring = &pxmitpriv->tx_ring[i];
+
+		DBG_871X_SEL_NL(m, "tx ring[%d] (%p)\n", i, tx_ring);
+		DBG_871X_SEL_NL(m, "  dma: 0x%08x\n", (int) tx_ring->dma);
+		DBG_871X_SEL_NL(m, "  idx: %d\n", tx_ring->idx);
+		DBG_871X_SEL_NL(m, "  entries: %d\n", tx_ring->entries);
+//		DBG_871X_SEL_NL(m, "  queue: %d\n", tx_ring->queue);
+		DBG_871X_SEL_NL(m, "  qlen: %d\n", tx_ring->qlen);
+
+		for (j=0; j < pxmitpriv->txringcount[i]; j++)
+		{
+			struct tx_desc *entry = &tx_ring->desc[j];
+
+			DBG_871X_SEL_NL(m, "  desc[%03d]: %p\n", j, entry);
+			for (k=0; k < sizeof(*entry)/4; k++)
+			{
+				if ((k % 4) == 0)
+					DBG_871X_SEL_NL(m, "  0x%03x", k);
+
+				DBG_871X_SEL_NL(m, " 0x%08x ", ((int *) entry)[k]);
+
+				if ((k % 4) == 3)
+					DBG_871X_SEL_NL(m, "\n");
+			}
+		}
+	}
+	_exit_critical(&pdvobjpriv->irq_th_lock, &irqL);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_P2P_WOWLAN
+int proc_get_p2p_wowlan_info(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	struct p2p_wowlan_info	 peerinfo = pwdinfo->p2p_wow_info;
+	if(_TRUE == peerinfo.is_trigger)
+	{
+		DBG_871X_SEL_NL(m,"is_trigger: TRUE\n");
+		switch(peerinfo.wowlan_recv_frame_type)
+		{
+			case P2P_WOWLAN_RECV_NEGO_REQ:
+				DBG_871X_SEL_NL(m,"Frame Type: Nego Request\n");
+				break;
+			case P2P_WOWLAN_RECV_INVITE_REQ:
+				DBG_871X_SEL_NL(m,"Frame Type: Invitation Request\n");
+				break;
+			case P2P_WOWLAN_RECV_PROVISION_REQ:
+				DBG_871X_SEL_NL(m,"Frame Type: Provision Request\n");
+				break;
+			default:
+				break;
+		}
+		DBG_871X_SEL_NL(m,"Peer Addr: "MAC_FMT"\n", MAC_ARG(peerinfo.wowlan_peer_addr));
+		DBG_871X_SEL_NL(m,"Peer WPS Config: %x\n", peerinfo.wowlan_peer_wpsconfig);
+		DBG_871X_SEL_NL(m,"Persistent Group: %d\n", peerinfo.wowlan_peer_is_persistent);
+		DBG_871X_SEL_NL(m,"Intivation Type: %d\n", peerinfo.wowlan_peer_invitation_type);
+	}
+	else
+	{
+		DBG_871X_SEL_NL(m,"is_trigger: False\n");
+	}
+	return 0;
+}
+#endif /* CONFIG_P2P_WOWLAN */
+
+int proc_get_new_bcn_max(struct seq_file *m, void *v)
+{
+	extern int new_bcn_max;
+
+	DBG_871X_SEL_NL(m, "%d", new_bcn_max);
+	return 0;
+}
+
+ssize_t proc_set_new_bcn_max(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	char tmp[32];
+	extern int new_bcn_max;
+
+	if(count < 1)
+		return -EFAULT;
+
+	if(buffer && !copy_from_user(tmp, buffer, sizeof(tmp)))
+		sscanf(tmp, "%d ", &new_bcn_max);
+
+	return count;
+}
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_ieee80211.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_ieee80211.c
index 789d30fa4ec0..224714b06c24 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_ieee80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_ieee80211.c
@@ -19,6 +19,9 @@
  ******************************************************************************/
 #define _IEEE80211_C
 
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+#include <linux/fs.h>
+#endif 
 #include <drv_types.h>
 
 
@@ -150,7 +153,6 @@ u8 *rtw_set_ie
 	uint *frlen //frame length
 )
 {
-_func_enter_;
 	*pbuf = (u8)index;
 
 	*(pbuf + 1) = (u8)len;
@@ -161,7 +163,6 @@ _func_enter_;
 	*frlen = *frlen + (len + 2);
 	
 	return (pbuf + len + 2);
-_func_exit_;	
 }
 
 inline u8 *rtw_set_ie_ch_switch(u8 *buf, u32 *buf_len, u8 ch_switch_mode,
@@ -1112,7 +1113,7 @@ static int rtw_ieee802_11_parse_vendor_specific(u8 *pos, uint elen,
 				elems->wme_tspec_len = elen;
 				break;
 			default:
-				DBG_871X("unknown WME "
+				DBG_871X_LEVEL(_drv_warning_, "unknown WME "
 					   "information element ignored "
 					   "(subtype=%d len=%lu)\n",
 					   pos[4], (unsigned long) elen);
@@ -1125,7 +1126,7 @@ static int rtw_ieee802_11_parse_vendor_specific(u8 *pos, uint elen,
 			elems->wps_ie_len = elen;
 			break;
 		default:
-			DBG_871X("Unknown Microsoft "
+			DBG_871X_LEVEL(_drv_warning_, "Unknown Microsoft "
 				   "information element ignored "
 				   "(type=%d len=%lu)\n",
 				   pos[3], (unsigned long) elen);
@@ -1140,7 +1141,7 @@ static int rtw_ieee802_11_parse_vendor_specific(u8 *pos, uint elen,
 			elems->vendor_ht_cap_len = elen;
 			break;
 		default:
-			DBG_871X("Unknown Broadcom "
+			DBG_871X_LEVEL(_drv_warning_, "Unknown Broadcom "
 				   "information element ignored "
 				   "(type=%d len=%lu)\n",
 				   pos[3], (unsigned long) elen);
@@ -1149,7 +1150,7 @@ static int rtw_ieee802_11_parse_vendor_specific(u8 *pos, uint elen,
 		break;
 
 	default:
-		DBG_871X("unknown vendor specific information "
+		DBG_871X_LEVEL(_drv_warning_, "unknown vendor specific information "
 			   "element ignored (vendor OUI %02x:%02x:%02x "
 			   "len=%lu)\n",
 			   pos[0], pos[1], pos[2], (unsigned long) elen);
@@ -1290,9 +1291,10 @@ ParseRes rtw_ieee802_11_parse_elems(u8 *start, uint len,
 			unknown++;
 			if (!show_errors)
 				break;
-			DBG_871X("IEEE 802.11 element parse "
-				   "ignored unknown element (id=%d elen=%d)\n",
-				   id, elen);
+			DBG_871X_LEVEL(_drv_warning_,
+				"IEEE 802.11 element parse "
+				"ignored unknown element (id=%d elen=%d)\n",
+				id, elen);
 			break;
 		}
 
@@ -1347,72 +1349,145 @@ u8 convert_ip_addr(u8 hch, u8 mch, u8 lch)
     return ((key_char2num(hch) * 100) + (key_char2num(mch) * 10 ) + key_char2num(lch));
 }
 
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+#define MAC_ADDRESS_LEN 12
+
+int rtw_get_mac_addr_intel(unsigned char *buf)
+{
+	int ret = 0;
+	int i;
+	struct file *fp = NULL;
+	mm_segment_t oldfs;
+	unsigned char c_mac[MAC_ADDRESS_LEN];
+	char fname[]="/config/wifi/mac.txt";
+	int jj,kk;
+
+	DBG_871X("%s Enter\n", __FUNCTION__);
+
+	ret = rtw_retrive_from_file(fname, c_mac, MAC_ADDRESS_LEN);
+	if(ret < MAC_ADDRESS_LEN)
+	{
+		return -1;
+	}
+
+	for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 2 )
+	{
+		buf[jj] = key_2char2num(c_mac[kk], c_mac[kk+ 1]);
+	}
+
+	DBG_871X("%s: read from file mac address: "MAC_FMT"\n",
+		 __FUNCTION__, MAC_ARG(buf));
+
+	return 0;
+}
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
 extern char* rtw_initmac;
 #include <linux/rfkill-wlan.h>
 void rtw_macaddr_cfg(u8 *mac_addr)
 {
-    u8 mac[ETH_ALEN];
-
-    if(mac_addr == NULL)    return;
-
-    if ( rtw_initmac )
-    {   //  Users specify the mac address
-        int jj,kk;
+	u8 mac[ETH_ALEN];
+	if(mac_addr == NULL)	return;
+	
+	if ( rtw_initmac )
+	{	//	Users specify the mac address
+		int jj,kk;
 
-        for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
+		for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
+		{
+			mac[jj] = key_2char2num(rtw_initmac[kk], rtw_initmac[kk+ 1]);
+		}
+		_rtw_memcpy(mac_addr, mac, ETH_ALEN);
+	}
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+	else if (0 == rtw_get_mac_addr_intel(mac))
+	{
+		_rtw_memcpy(mac_addr, mac, ETH_ALEN);
+	}
+#endif //CONFIG_PLATFORM_INTEL_BYT
+	else
         {
-            mac[jj] = key_2char2num(rtw_initmac[kk], rtw_initmac[kk+ 1]);
-        }
-        _rtw_memcpy(mac_addr, mac, ETH_ALEN);
-    }
-    else
-    {
-        printk("Wifi Efuse Mac => %02x:%02x:%02x:%02x:%02x:%02x\n", mac_addr[0], mac_addr[1],
-            mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
-        if (!rockchip_wifi_mac_addr(mac)) {
-            printk("=========> get mac address from flash=[%02x:%02x:%02x:%02x:%02x:%02x]\n", mac[0], mac[1],
-                mac[2], mac[3], mac[4], mac[5]);
-            _rtw_memcpy(mac_addr, mac, ETH_ALEN);
-        } else {
-            //  Use the mac address stored in the Efuse
-            _rtw_memcpy(mac, mac_addr, ETH_ALEN);
+		printk("Wifi Efuse Mac => %02x:%02x:%02x:%02x:%02x:%02x\n", mac_addr[0], mac_addr[1],
+		    mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5]);
+		if (!rockchip_wifi_mac_addr(mac)) {
+		    printk("=========> get mac address from flash=[%02x:%02x:%02x:%02x:%02x:%02x]\n", mac[0], mac[1],
+			mac[2], mac[3], mac[4], mac[5]);
+		    _rtw_memcpy(mac_addr, mac, ETH_ALEN);
+		} else {
+		    //  Use the mac address stored in the Efuse
+		    _rtw_memcpy(mac, mac_addr, ETH_ALEN);
+		}
         }
-    }
-
-    if (((mac[0]==0xff) &&(mac[1]==0xff) && (mac[2]==0xff) &&
-         (mac[3]==0xff) && (mac[4]==0xff) &&(mac[5]==0xff)) ||
-        ((mac[0]==0x0) && (mac[1]==0x0) && (mac[2]==0x0) &&
-         (mac[3]==0x0) && (mac[4]==0x0) &&(mac[5]==0x0)))
-    {
-        mac[0] = 0x00;
-        mac[1] = 0xe0;
-        mac[2] = 0x4c;
-        mac[3] = 0x87;
-        mac[4] = 0x00;
-        mac[5] = 0x00;
-        // use default mac addresss
-        _rtw_memcpy(mac_addr, mac, ETH_ALEN);
-        DBG_871X("MAC Address from efuse error, assign default one !!!\n");
-    }
-
-    DBG_871X("rtw_macaddr_cfg MAC Address  = "MAC_FMT"\n", MAC_ARG(mac_addr));
-}
-
-void dump_ies(u8 *buf, u32 buf_len)
+	
+	if (((mac[0]==0xff) &&(mac[1]==0xff) && (mac[2]==0xff) &&
+	     (mac[3]==0xff) && (mac[4]==0xff) &&(mac[5]==0xff)) ||
+	    ((mac[0]==0x0) && (mac[1]==0x0) && (mac[2]==0x0) &&
+	     (mac[3]==0x0) && (mac[4]==0x0) &&(mac[5]==0x0)))
+	{
+		mac[0] = 0x00;
+		mac[1] = 0xe0;
+		mac[2] = 0x4c;
+		mac[3] = 0x87;
+		mac[4] = 0x00;
+		mac[5] = 0x00;
+		// use default mac addresss
+		_rtw_memcpy(mac_addr, mac, ETH_ALEN);
+		DBG_871X("MAC Address from efuse error, assign default one !!!\n");
+	}	
+
+	DBG_871X("rtw_macaddr_cfg MAC Address  = "MAC_FMT"\n", MAC_ARG(mac_addr));
+}
+
+#ifdef CONFIG_80211N_HT
+void dump_ht_cap_ie_content(void *sel, u8 *buf, u32 buf_len)
+{
+	if (buf_len != 26) {
+		DBG_871X_SEL_NL(sel, "Invalid HT capability IE len:%d != %d\n", buf_len, 26);
+		return;
+	}
+
+	DBG_871X_SEL_NL(sel, "HT Capabilities Info:%02x%02x\n", *(buf), *(buf+1));
+	DBG_871X_SEL_NL(sel, "A-MPDU Parameters:"HT_AMPDU_PARA_FMT"\n"
+		, HT_AMPDU_PARA_ARG(HT_CAP_ELE_AMPDU_PARA(buf)));
+	DBG_871X_SEL_NL(sel, "Supported MCS Set:"HT_SUP_MCS_SET_FMT"\n"
+		, HT_SUP_MCS_SET_ARG(HT_CAP_ELE_SUP_MCS_SET(buf)));
+}
+
+void dump_ht_cap_ie(void *sel, u8 *ie, u32 ie_len)
+{
+	u8* pos = (u8*)ie;
+	u16 id;
+	u16 len;
+
+	u8 *ht_cap_ie;
+	sint ht_cap_ielen;
+
+	ht_cap_ie = rtw_get_ie(ie, _HT_CAPABILITY_IE_, &ht_cap_ielen, ie_len);
+	if(!ie || ht_cap_ie != ie)
+		return;
+
+	dump_ht_cap_ie_content(sel, ht_cap_ie+2, ht_cap_ielen);
+}
+#endif /* CONFIG_80211N_HT */
+
+void dump_ies(void *sel, u8 *buf, u32 buf_len)
 {
 	u8* pos = (u8*)buf;
 	u8 id, len;
 
-	while(pos-buf<=buf_len){
+	while(pos-buf+1<buf_len){
 		id = *pos;
 		len = *(pos+1);
 
-		DBG_871X("%s ID:%u, LEN:%u\n", __FUNCTION__, id, len);
-		dump_wps_ie(pos, len);
+		DBG_871X_SEL_NL(sel, "%s ID:%u, LEN:%u\n", __FUNCTION__, id, len);
+		#ifdef CONFIG_80211N_HT
+		dump_ht_cap_ie(sel, pos, len);
+		#endif
+		dump_wps_ie(sel, pos, len);
 		#ifdef CONFIG_P2P
-		dump_p2p_ie(pos, len);
+		dump_p2p_ie(sel, pos, len);
 		#ifdef CONFIG_WFD
-		dump_wfd_ie(pos, len);
+		dump_wfd_ie(sel, pos, len);
 		#endif
 		#endif
 
@@ -1420,7 +1495,7 @@ void dump_ies(u8 *buf, u32 buf_len)
 	}
 }
 
-void dump_wps_ie(u8 *ie, u32 ie_len)
+void dump_wps_ie(void *sel, u8 *ie, u32 ie_len)
 {
 	u8* pos = (u8*)ie;
 	u16 id;
@@ -1438,7 +1513,7 @@ void dump_wps_ie(u8 *ie, u32 ie_len)
 		id = RTW_GET_BE16(pos);
 		len = RTW_GET_BE16(pos + 2);
 
-		DBG_871X("%s ID:0x%04x, LEN:%u\n", __FUNCTION__, id, len);
+		DBG_871X_SEL_NL(sel, "%s ID:0x%04x, LEN:%u\n", __FUNCTION__, id, len);
 
 		pos+=(4+len);
 	}
@@ -1516,7 +1591,7 @@ int rtw_p2p_merge_ies(u8 *in_ie, u32 in_len, u8 *merge_ie)
 	return 0;
 }
 
-void dump_p2p_ie(u8 *ie, u32 ie_len) {
+void dump_p2p_ie(void *sel, u8 *ie, u32 ie_len) {
 	u8* pos = (u8*)ie;
 	u8 id;
 	u16 len;
@@ -1533,7 +1608,7 @@ void dump_p2p_ie(u8 *ie, u32 ie_len) {
 		id = *pos;
 		len = RTW_GET_LE16(pos+1);
 
-		DBG_871X("%s ID:%u, LEN:%u\n", __FUNCTION__, id, len);
+		DBG_871X_SEL_NL(sel, "%s ID:%u, LEN:%u\n", __FUNCTION__, id, len);
 
 		pos+=(3+len);
 	}	
@@ -1737,7 +1812,7 @@ static uint rtw_p2p_attr_remove(u8 *ie, uint ielen_ori, u8 attr_id)
 		{
 			u8 *next_attr = target_attr+target_attr_len;
 			uint remain_len = ielen-(next_attr-ie);
-			//dump_ies(ie, ielen);
+			//dump_ies(RTW_DBGDUMP, ie, ielen);
 			#if 0
 			DBG_871X("[%d] ie:%p, ielen:%u\n"
 				"target_attr:%p, target_attr_len:%u\n"
@@ -1758,7 +1833,7 @@ static uint rtw_p2p_attr_remove(u8 *ie, uint ielen_ori, u8 attr_id)
 		else
 		{
 			//if(index>0)
-			//	dump_ies(ie, ielen);
+			//	dump_ies(RTW_DBGDUMP, ie, ielen);
 			break;
 		}
 	}
@@ -1774,12 +1849,11 @@ void rtw_WLAN_BSSID_EX_remove_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id)
 	
 	if( (p2p_ie=rtw_get_p2p_ie(bss_ex->IEs+_FIXED_IE_LENGTH_, bss_ex->IELength-_FIXED_IE_LENGTH_, NULL, &p2p_ielen_ori)) ) 
 	{
-		#if 0
+		if (0)
 		if(rtw_get_p2p_attr(p2p_ie, p2p_ielen_ori, attr_id, NULL, NULL)) {
 			DBG_871X("rtw_get_p2p_attr: GOT P2P_ATTR:%u!!!!!!!!\n", attr_id);
-			dump_ies(bss_ex->IEs+_FIXED_IE_LENGTH_, bss_ex->IELength-_FIXED_IE_LENGTH_);
+			dump_ies(RTW_DBGDUMP, bss_ex->IEs+_FIXED_IE_LENGTH_, bss_ex->IELength-_FIXED_IE_LENGTH_);
 		}
-		#endif
 
 		p2p_ielen=rtw_p2p_attr_remove(p2p_ie, p2p_ielen_ori, attr_id);
 		if(p2p_ielen != p2p_ielen_ori) {
@@ -1792,10 +1866,10 @@ void rtw_WLAN_BSSID_EX_remove_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id)
 			_rtw_memset(next_ie+remain_len, 0, p2p_ielen_ori-p2p_ielen);
 			bss_ex->IELength -= p2p_ielen_ori-p2p_ielen;
 
-			#if 0
-			DBG_871X("remove P2P_ATTR:%u!\n", attr_id);
-			dump_ies(bss_ex->IEs+_FIXED_IE_LENGTH_, bss_ex->IELength-_FIXED_IE_LENGTH_);
-			#endif
+			if (0) {
+				DBG_871X("remove P2P_ATTR:%u!\n", attr_id);
+				dump_ies(RTW_DBGDUMP, bss_ex->IEs+_FIXED_IE_LENGTH_, bss_ex->IELength-_FIXED_IE_LENGTH_);
+			}
 		}
 	}
 }
@@ -1803,7 +1877,7 @@ void rtw_WLAN_BSSID_EX_remove_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id)
 #endif //CONFIG_P2P
 
 #ifdef CONFIG_WFD
-void dump_wfd_ie(u8 *ie, u32 ie_len)
+void dump_wfd_ie(void *sel, u8 *ie, u32 ie_len)
 {
 	u8* pos = (u8*)ie;
 	u8 id;
@@ -1820,7 +1894,7 @@ void dump_wfd_ie(u8 *ie, u32 ie_len)
 		id = *pos;
 		len = RTW_GET_BE16(pos+1);
 
-		DBG_871X("%s ID:%u, LEN:%u\n", __FUNCTION__, id, len);
+		DBG_871X_SEL_NL(sel, "%s ID:%u, LEN:%u\n", __FUNCTION__, id, len);
 
 		pos+=(3+len);
 	}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_iol.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_iol.c
index 45dc60d0bebe..3524e1c5a5ed 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_iol.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_iol.c
@@ -50,7 +50,7 @@ struct xmit_frame	*rtw_IOL_accquire_xmit_frame(ADAPTER *adapter)
 
 	pattrib = &xmit_frame->attrib;
 	update_mgntframe_attrib(adapter, pattrib);
-	pattrib->qsel = 0x10;//Beacon	
+	pattrib->qsel = QSLT_BEACON;//Beacon	
 	pattrib->subtype = WIFI_BEACON;	
 	pattrib->pktlen = pattrib->last_txcmdsz = 0;
 
@@ -62,7 +62,7 @@ struct xmit_frame	*rtw_IOL_accquire_xmit_frame(ADAPTER *adapter)
 	else {
 		pattrib = &xmit_frame->attrib;
 		update_mgntframe_attrib(adapter, pattrib);
-		pattrib->qsel = 0x10;
+		pattrib->qsel = QSLT_BEACON;
 		pattrib->pktlen = pattrib->last_txcmdsz = 0;
 	}
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mem.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mem.c
new file mode 100644
index 000000000000..a4de3e61431f
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mem.c
@@ -0,0 +1,103 @@
+
+#include <drv_types.h>
+#include <rtw_mem.h>
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Realtek Wireless Lan Driver");
+MODULE_AUTHOR("Realtek Semiconductor Corp.");
+MODULE_VERSION("DRIVERVERSION");
+
+struct sk_buff_head rtk_skb_mem_q;
+struct u8* rtk_buf_mem[NR_RECVBUFF];
+
+struct u8	* rtw_get_buf_premem(int index)
+{
+	printk("%s, rtk_buf_mem index : %d\n", __func__, index);
+	return rtk_buf_mem[index];
+}
+
+struct sk_buff *rtw_alloc_skb_premem(void)
+{
+	struct sk_buff *skb = NULL;
+
+	skb = skb_dequeue(&rtk_skb_mem_q);
+
+	printk("%s, rtk_skb_mem_q len : %d\n", __func__, skb_queue_len(&rtk_skb_mem_q));
+
+	return skb;	
+}
+EXPORT_SYMBOL(rtw_alloc_skb_premem);
+
+int rtw_free_skb_premem(struct sk_buff *pskb)
+{
+	if(!pskb)
+		return -1;
+
+	if(skb_queue_len(&rtk_skb_mem_q) >= NR_PREALLOC_RECV_SKB)	
+		return -1;
+	
+	skb_queue_tail(&rtk_skb_mem_q, pskb);
+	
+	printk("%s, rtk_skb_mem_q len : %d\n", __func__, skb_queue_len(&rtk_skb_mem_q));
+
+	return 0;
+}
+EXPORT_SYMBOL(rtw_free_skb_premem);
+
+static int __init rtw_mem_init(void)
+{
+	int i;
+	SIZE_PTR tmpaddr=0;
+	SIZE_PTR alignment=0;
+	struct sk_buff *pskb=NULL;
+
+	printk("%s\n", __func__);
+
+#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
+	for(i=0; i<NR_RECVBUFF; i++)
+	{
+		rtk_buf_mem[i] = usb_buffer_alloc(dev, size, (in_interrupt() ? GFP_ATOMIC : GFP_KERNEL), dma);
+	}
+#endif //CONFIG_USE_USB_BUFFER_ALLOC_RX
+
+	skb_queue_head_init(&rtk_skb_mem_q);
+
+	for(i=0; i<NR_PREALLOC_RECV_SKB; i++)
+	{
+		pskb = __dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+		if(pskb)
+		{		
+			tmpaddr = (SIZE_PTR)pskb->data;
+			alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+			skb_reserve(pskb, (RECVBUFF_ALIGN_SZ - alignment));
+
+			skb_queue_tail(&rtk_skb_mem_q, pskb);
+		}
+		else
+		{
+			printk("%s, alloc skb memory fail!\n", __func__);
+		}
+
+		pskb=NULL;
+	}
+
+	printk("%s, rtk_skb_mem_q len : %d\n", __func__, skb_queue_len(&rtk_skb_mem_q));
+
+	return 0;
+	
+}
+
+static void __exit rtw_mem_exit(void)
+{
+	if (skb_queue_len(&rtk_skb_mem_q)) {
+		printk("%s, rtk_skb_mem_q len : %d\n", __func__, skb_queue_len(&rtk_skb_mem_q));
+	}
+
+	skb_queue_purge(&rtk_skb_mem_q);
+
+	printk("%s\n", __func__);
+}
+
+module_init(rtw_mem_init);
+module_exit(rtw_mem_exit);
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mlme.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mlme.c
index 6b9abd77f753..eb40179e81cc 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mlme.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mlme.c
@@ -25,13 +25,6 @@
 extern void indicate_wx_scan_complete_event(_adapter *padapter);
 extern u8 rtw_do_join(_adapter * padapter);
 
-#ifdef CONFIG_DISABLE_MCS13TO15
-extern unsigned char	MCS_rate_2R_MCS13TO15_OFF[16];
-extern unsigned char	MCS_rate_2R[16];
-#else //CONFIG_DISABLE_MCS13TO15
-extern unsigned char	MCS_rate_2R[16];
-#endif //CONFIG_DISABLE_MCS13TO15
-extern unsigned char	MCS_rate_1R[16];
 
 sint	_rtw_init_mlme_priv (_adapter* padapter)
 {
@@ -162,7 +155,10 @@ void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)
 void _rtw_free_mlme_priv (struct mlme_priv *pmlmepriv)
 {
 _func_enter_;
-
+	if (NULL == pmlmepriv){
+		rtw_warn_on(1);
+		goto exit;
+	}
 	rtw_free_mlme_priv_ie_data(pmlmepriv);
 
 	if(pmlmepriv){
@@ -172,6 +168,7 @@ _func_enter_;
 			rtw_vmfree(pmlmepriv->free_bss_buf, MAX_BSS_CNT * sizeof(struct wlan_network));
 		}
 	}
+exit:
 _func_exit_;	
 }
 
@@ -540,19 +537,19 @@ void rtw_free_network(struct mlme_priv *pmlmepriv, struct	wlan_network *pnetwork
 _func_enter_;		
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
 	_rtw_free_network(pmlmepriv, pnetwork, is_freeall);
-_func_exit_;		
+_func_exit_;
 }
 
 void rtw_free_network_nolock(_adapter * padapter, struct wlan_network *pnetwork );
 void rtw_free_network_nolock(_adapter * padapter, struct wlan_network *pnetwork )
 {
-_func_enter_;
+_func_enter_;		
 	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
 	_rtw_free_network_nolock(&(padapter->mlmepriv), pnetwork);
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_unlink_bss(padapter, pnetwork);
 #endif //CONFIG_IOCTL_CFG80211
-_func_exit_;
+_func_exit_;		
 }
 
 
@@ -870,7 +867,9 @@ void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target)
 	ULONG	bssid_ex_sz;
 	struct mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);
-	struct wifidirect_info *pwdinfo= &(adapter->wdinfo);    
+#ifdef CONFIG_P2P
+	struct wifidirect_info *pwdinfo= &(adapter->wdinfo);
+#endif // CONFIG_P2P
 	_queue	*queue	= &(pmlmepriv->scanned_queue);
 	struct wlan_network	*pnetwork = NULL;
 	struct wlan_network	*oldest = NULL;
@@ -898,7 +897,7 @@ _func_enter_;
 		rtw_bug_check(pnetwork, pnetwork, pnetwork, pnetwork);
 
 #ifdef CONFIG_P2P
-		if (!rtw_p2p_chk_state(&(adapter->wdinfo), P2P_STATE_NONE) &&
+		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) &&
 			(_rtw_memcmp(pnetwork->network.MacAddress, target->MacAddress, ETH_ALEN) == _TRUE))
 		{
 			target_find = 1;
@@ -1452,6 +1451,14 @@ _func_enter_;
 	
 _func_exit_;
 }
+
+void rtw_reset_rx_info(struct debug_priv *pdbgpriv){
+	pdbgpriv->dbg_rx_ampdu_drop_count = 0;
+	pdbgpriv->dbg_rx_ampdu_forced_indicate_count = 0;
+	pdbgpriv->dbg_rx_ampdu_loss_count = 0;
+	pdbgpriv->dbg_rx_dup_mgt_frame_drop_count = 0;
+	pdbgpriv->dbg_rx_ampdu_window_shift_cnt = 0;
+}
 	
 /*
 *rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock
@@ -1460,9 +1467,12 @@ void rtw_free_assoc_resources(_adapter *adapter, int lock_scanned_queue)
 {
 	_irqL irqL;
 	struct wlan_network* pwlan = NULL;
-     	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
-   	struct	sta_priv *pstapriv = &adapter->stapriv;
+	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct	sta_priv *pstapriv = &adapter->stapriv;
 	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+	struct dvobj_priv *psdpriv = adapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;	
+
 	
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
@@ -1485,16 +1495,16 @@ _func_enter_;
 			rtw_tdls_cmd(adapter, myid(&(adapter->eeprompriv)), TDLS_RS_RCR);
 			rtw_reset_tdls_info(adapter);
 			rtw_free_all_stainfo(adapter);
-			_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		}
 		else
 #endif //CONFIG_TDLS
 		{
-			_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 			rtw_free_stainfo(adapter,  psta);
 		}
 
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		
 	}
 
@@ -1505,9 +1515,9 @@ _func_enter_;
 		rtw_free_all_stainfo(adapter);
 
 		psta = rtw_get_bcmc_stainfo(adapter);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 		rtw_free_stainfo(adapter, psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 
 		rtw_init_bcmc_stainfo(adapter);	
 	}
@@ -1519,32 +1529,14 @@ _func_enter_;
 	if(pwlan)		
 	{
 		pwlan->fixed = _FALSE;
+
+                DBG_871X("free disconnecting network\n");
+		rtw_free_network_nolock(adapter, pwlan);
 #ifdef CONFIG_P2P
 		if(!rtw_p2p_chk_state(&adapter->wdinfo, P2P_STATE_NONE))
 		{
-			u32 p2p_ielen=0;
-			u8  *p2p_ie;
-			//u16 capability;
-			u8 *pcap = NULL;
-			u32 capability_len=0;
-			
-			//DBG_871X("free disconnecting network\n");
-			//rtw_free_network_nolock(pmlmepriv, pwlan);
-
-			if((p2p_ie=rtw_get_p2p_ie(pwlan->network.IEs+_FIXED_IE_LENGTH_, pwlan->network.IELength-_FIXED_IE_LENGTH_, NULL, &p2p_ielen)))
-			{			
-				pcap = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, NULL, &capability_len);
-				if(pcap && capability_len==2)
-				{
-					u16 cap = *(u16*)pcap ;
-					*(u16*)pcap = cap&0x00ff;//clear group capability when free this network
-				}
-
-	}	
-
 			rtw_set_scan_deny(adapter, 2000);
-			//rtw_clear_scan_deny(adapter);
-			
+			//rtw_clear_scan_deny(adapter);			
 		}
 #endif //CONFIG_P2P
 	}	
@@ -1565,6 +1557,8 @@ _func_enter_;
 	
 	adapter->securitypriv.key_mask = 0;
 
+	rtw_reset_rx_info(pdbgpriv);
+
 _func_exit_;	
 	
 }
@@ -1638,6 +1632,8 @@ void rtw_indicate_disconnect( _adapter *padapter )
 	WLAN_BSSID_EX	*cur_network = &(pmlmeinfo->network);
 	struct sta_info *psta;
 	struct sta_priv *pstapriv = &padapter->stapriv;
+	u8 *wps_ie=NULL;
+	uint wpsie_len=0;
 
 _func_enter_;	
 	
@@ -1645,6 +1641,22 @@ _func_enter_;
 
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING|WIFI_UNDER_WPS);
 
+	// force to clear cur_network_scanned's SELECTED REGISTRAR
+	if (pmlmepriv->cur_network_scanned) {
+		WLAN_BSSID_EX	*current_joined_bss = &(pmlmepriv->cur_network_scanned->network);
+		if (current_joined_bss) {
+			wps_ie=rtw_get_wps_ie(current_joined_bss->IEs +_FIXED_IE_LENGTH_,
+				current_joined_bss->IELength-_FIXED_IE_LENGTH_, NULL, &wpsie_len);
+			if (wps_ie && wpsie_len>0) {
+				u8 *attr = NULL;
+				u32 attr_len;
+				attr=rtw_get_wps_attr(wps_ie, wpsie_len, WPS_ATTR_SELECTED_REGISTRAR,
+						       NULL, &attr_len);
+				if (attr)
+					*(attr + 4) = 0;
+			}
+		}
+	}
         //DBG_871X("clear wps when %s\n", __func__);
 
 	if(rtw_to_roam(padapter) > 0)
@@ -2033,9 +2045,9 @@ _func_enter_;
 
 					pcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
 					if(pcur_sta){
-						_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+						//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
 						rtw_free_stainfo(adapter,  pcur_sta);
-						_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+						//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
 					}
 
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
@@ -2320,12 +2332,11 @@ _func_enter_;
 			rtw_indicate_sta_assoc_event(adapter, psta);
 #endif //!CONFIG_IOCTL_CFG80211
 #endif //!CONFIG_AUTO_AP_MODE
+
+#ifdef CONFIG_BEAMFORMING
+			beamforming_wk_cmd(adapter, BEAMFORMING_CTRL_ENTER, (u8 *)psta, sizeof(struct sta_info), 0);
+#endif
 		}		
-		if (adapter->stapriv.asoc_sta_count > 1) {
-			DBG_871X("%s asoc_sta_count: %d\n", __func__,
-					adapter->stapriv.asoc_sta_count);
-			rtw_ap_connection_lock_suspend();
-		}
 		goto exit;
 	}	
 #endif //defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
@@ -2438,11 +2449,6 @@ _func_enter_;
 		rtw_cfg80211_indicate_sta_disassoc(adapter, pstadel->macaddr, *(u16*)pstadel->rsvd);
 		#endif //(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 #endif //CONFIG_IOCTL_CFG80211
-		DBG_871X("%s asoc_sta_count: %d\n", __func__,
-				adapter->stapriv.asoc_sta_count);
-		if (adapter->stapriv.asoc_sta_count == 2) {
-			rtw_ap_connection_unlock_suspend();
-		}
 
 		return;
 	}
@@ -2487,6 +2493,7 @@ _func_enter_;
 
 		rtw_free_assoc_resources(adapter, 1);
 		rtw_indicate_disconnect(adapter);
+		rtw_free_mlme_priv_ie_data(pmlmepriv);
 
 		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 		// remove the network entry in scanned_queue
@@ -2509,9 +2516,9 @@ _func_enter_;
 	      check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
 	{
 		
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		rtw_free_stainfo(adapter,  psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		
 		if(adapter->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
 		{ 
@@ -2583,6 +2590,17 @@ _func_exit_;
 
 }
 
+
+void rtw_wmm_event_callback(PADAPTER padapter, u8 *pbuf)
+{
+_func_enter_;
+
+	WMMOnAssocRsp(padapter);
+
+_func_exit_;
+
+}
+
 /*
 * _rtw_join_timeout_handler - Timeout/faliure handler for CMD JoinBss
 * @adapter: pointer to _adapter structure
@@ -2706,6 +2724,8 @@ void rtw_scan_timeout_handler (_adapter *adapter)
 void rtw_mlme_reset_auto_scan_int(_adapter *adapter)
 {
 	struct mlme_priv *mlme = &adapter->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 #ifdef CONFIG_P2P
 	if(!rtw_p2p_chk_state(&adapter->wdinfo, P2P_STATE_NONE)) {
@@ -2713,8 +2733,11 @@ void rtw_mlme_reset_auto_scan_int(_adapter *adapter)
 		goto exit;
 	}
 #endif	
-
-	if(adapter->registrypriv.wifi_spec) {
+	if(pmlmeinfo->VHT_enable) //disable auto scan when connect to 11AC AP
+	{
+		mlme->auto_scan_int_ms = 0;
+	}
+	else if(adapter->registrypriv.wifi_spec && is_client_associated_to_ap(adapter) == _TRUE) {
 		mlme->auto_scan_int_ms = 60*1000;
 #ifdef CONFIG_LAYER2_ROAMING
 	} else if(rtw_chk_roam_flags(adapter, RTW_ROAM_ACTIVE)) {
@@ -2822,7 +2845,7 @@ void rtw_dynamic_check_timer_handlder(_adapter *adapter)
 	{
 		u8 bEnterPS;	
 		
-		linked_status_chk(adapter);	
+		linked_status_chk(adapter, 1);	
 			
 		bEnterPS = traffic_status_watchdog(adapter, 1);
 		if(bEnterPS)
@@ -3490,22 +3513,67 @@ static int SecIsInPMKIDList(_adapter *Adapter, u8 *bssid)
 // 13th element in the array is the IE length  
 //
 
-static int rtw_append_pmkid(_adapter *Adapter,int iEntry, u8 *ie, uint ie_len)
+static int rtw_append_pmkid(_adapter *adapter,int iEntry, u8 *ie, uint ie_len)
 {
-	struct security_priv *psecuritypriv=&Adapter->securitypriv;
+	struct security_priv *sec=&adapter->securitypriv;
 
-	if(ie[13]<=20){	
-		// The RSN IE didn't include the PMK ID, append the PMK information 
-			ie[ie_len]=1;
-			ie_len++;
-			ie[ie_len]=0;	//PMKID count = 0x0100
-			ie_len++;
-			_rtw_memcpy(	&ie[ie_len], &psecuritypriv->PMKIDList[iEntry].PMKID, 16);
-		
-			ie_len+=16;
-			ie[13]+=18;//PMKID length = 2+16
+	if (ie[13] > 20) {
+		int i;
+		u16 pmkid_cnt = RTW_GET_LE16(ie+14+20);
+		if (pmkid_cnt == 1 && _rtw_memcmp(ie+14+20+2, &sec->PMKIDList[iEntry].PMKID, 16)) {
+			DBG_871X(FUNC_ADPT_FMT" has carried the same PMKID:"KEY_FMT"\n"
+				, FUNC_ADPT_ARG(adapter), KEY_ARG(&sec->PMKIDList[iEntry].PMKID));
+			goto exit;
+		}
+
+		DBG_871X(FUNC_ADPT_FMT" remove original PMKID, count:%u\n"
+			, FUNC_ADPT_ARG(adapter), pmkid_cnt);
+
+		for (i=0;i<pmkid_cnt;i++)
+			DBG_871X("    "KEY_FMT"\n", KEY_ARG(ie+14+20+2+i*16));
+
+		ie_len -= 2+pmkid_cnt*16;
+		ie[13] = 20;
+	}
+
+	if (ie[13] <= 20) {	
+		/* The RSN IE didn't include the PMK ID, append the PMK information */
+
+		DBG_871X(FUNC_ADPT_FMT" append PMKID:"KEY_FMT"\n"
+				, FUNC_ADPT_ARG(adapter), KEY_ARG(&sec->PMKIDList[iEntry].PMKID));
+
+		RTW_PUT_LE16(&ie[ie_len], 1);
+		ie_len += 2;
+
+		_rtw_memcpy(&ie[ie_len], &sec->PMKIDList[iEntry].PMKID, 16);
+		ie_len += 16;
 
+		ie[13] += 18;//PMKID length = 2+16
 	}
+
+exit:
+	return (ie_len);
+}
+
+static int rtw_remove_pmkid(_adapter *adapter, u8 *ie, uint ie_len)
+{
+	struct security_priv *sec=&adapter->securitypriv;
+	int i;
+	u16 pmkid_cnt = RTW_GET_LE16(ie+14+20);
+
+	if (ie[13] <= 20)
+		goto exit;
+
+	DBG_871X(FUNC_ADPT_FMT" remove original PMKID, count:%u\n"
+		, FUNC_ADPT_ARG(adapter), pmkid_cnt);
+
+	for (i=0;i<pmkid_cnt;i++)
+		DBG_871X("    "KEY_FMT"\n", KEY_ARG(ie+14+20+2+i*16));
+
+	ie_len -= 2+pmkid_cnt*16;
+	ie[13] = 20;
+
+exit:
 	return (ie_len);
 }
 
@@ -3565,14 +3633,13 @@ _func_enter_;
 	iEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);
 	if(iEntry<0)
 	{
-		return ielength;
+		if(authmode == _WPA2_IE_ID_)
+			ielength = rtw_remove_pmkid(adapter, out_ie, ielength);
 	}
 	else
 	{
 		if(authmode == _WPA2_IE_ID_)
-		{
 			ielength=rtw_append_pmkid(adapter, iEntry, out_ie, ielength);
-		}
 	}
 
 _func_exit_;
@@ -3696,17 +3763,10 @@ void rtw_joinbss_reset(_adapter *padapter)
 {
 	u8	threshold;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-
-#ifdef CONFIG_80211N_HT	
-	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
-#endif
-
 	//todo: if you want to do something io/reg/hw setting before join_bss, please add code here
 	
-
-
-
-#ifdef CONFIG_80211N_HT
+#ifdef CONFIG_80211N_HT	
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;	
 
 	pmlmepriv->num_FortyMHzIntolerant = 0;
 
@@ -3730,9 +3790,9 @@ void rtw_joinbss_reset(_adapter *padapter)
 		threshold = 1;
 		rtw_hal_set_hwreg(padapter, HW_VAR_RXDMA_AGG_PG_TH, (u8 *)(&threshold));
 	}
-#endif
+#endif//#if defined( CONFIG_USB_HCI) || defined (CONFIG_SDIO_HCI)
 
-#endif	
+#endif//#ifdef CONFIG_80211N_HT
 
 }
 
@@ -3831,6 +3891,7 @@ unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, ui
 	struct registry_priv *pregistrypriv = &padapter->registrypriv;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 
 	phtpriv->ht_option = _FALSE;
 
@@ -3904,17 +3965,21 @@ unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, ui
 		}
 	}
 
+	//fill default supported_mcs_set
+	_rtw_memcpy(ht_capie.supp_mcs_set, pmlmeext->default_supported_mcs_set, 16);
+
+	//update default supported_mcs_set
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-#ifdef RTL8192C_RECONFIG_TO_1T1R
-	rf_type = RF_1T1R;
-#endif
-	switch (rf_type) {
+
+	switch(rf_type)
+	{
 	case RF_1T1R:
+		
 		if (stbc_rx_enable)
 			ht_capie.cap_info |= IEEE80211_HT_CAP_RX_STBC_1R;//RX STBC One spatial stream
 
-		_rtw_memcpy(ht_capie.supp_mcs_set, MCS_rate_1R, 16);
-		break;
+	                set_mcs_rate_by_mask(ht_capie.supp_mcs_set, MCS_RATE_1R);			
+			break;
 
 	case RF_2T2R:
 	case RF_1T2R:
@@ -3925,11 +3990,11 @@ unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, ui
 
 		#ifdef CONFIG_DISABLE_MCS13TO15
 		if(((cbw40_enable == 1) && (operation_bw == CHANNEL_WIDTH_40)) && (pregistrypriv->wifi_spec!=1))
-			_rtw_memcpy(ht_capie.supp_mcs_set, MCS_rate_2R_MCS13TO15_OFF, 16);
+				set_mcs_rate_by_mask(ht_capie.supp_mcs_set, MCS_RATE_2R_13TO15_OFF);	
 		else
-			_rtw_memcpy(ht_capie.supp_mcs_set, MCS_rate_2R, 16);
+				set_mcs_rate_by_mask(ht_capie.supp_mcs_set, MCS_RATE_2R);	
 		#else //CONFIG_DISABLE_MCS13TO15
-		_rtw_memcpy(ht_capie.supp_mcs_set, MCS_rate_2R, 16);
+			set_mcs_rate_by_mask(ht_capie.supp_mcs_set, MCS_RATE_2R);	
 		#endif //CONFIG_DISABLE_MCS13TO15
 		break;
 	}
@@ -3956,14 +4021,25 @@ unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, ui
 	#endif
 	*/
 
-	rtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor);
+	if(padapter->driver_rx_ampdu_factor != 0xFF)
+		max_rx_ampdu_factor = (HT_CAP_AMPDU_FACTOR)padapter->driver_rx_ampdu_factor;
+	else
+		rtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor);
+				
+	//rtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor);
 	ht_capie.ampdu_params_info = (max_rx_ampdu_factor&0x03);
 
-	if(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_ )
-		ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));
+	if(padapter->driver_rx_ampdu_spacing != 0xFF) 
+	{
+		ht_capie.ampdu_params_info |= (( padapter->driver_rx_ampdu_spacing&0x07) <<2);	
+	}
 	else
-		ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);
-
+	{
+		if(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_ )
+			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));
+		else
+			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);
+	}
 #ifdef CONFIG_BEAMFORMING
 	ht_capie.tx_BF_cap_info = 0;
 
@@ -4039,7 +4115,9 @@ void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 	{
 		if(pregistrypriv->wifi_spec==1)
 		{
-			phtpriv->ampdu_enable = _FALSE;
+			//remove this part because testbed AP should disable RX AMPDU
+			//phtpriv->ampdu_enable = _FALSE;
+			phtpriv->ampdu_enable = _TRUE;
 		}
 		else
 		{
@@ -4048,7 +4126,8 @@ void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 	}
 	else if(pregistrypriv->ampdu_enable==2)
 	{
-		phtpriv->ampdu_enable = _TRUE;
+		//remove this part because testbed AP should disable RX AMPDU
+		//phtpriv->ampdu_enable = _TRUE;
 	}
 
 	
@@ -4091,34 +4170,31 @@ void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 		int i;
 		u8	rf_type;
 
-		padapter->HalFunc.GetHwRegHandler(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
-		//update the MCS rates
+		//update the MCS set
 		for (i = 0; i < 16; i++)
+			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= pmlmeext->default_supported_mcs_set[i];
+
+		//update the MCS rates
+		switch(rf_type)
 		{
-			if((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
-			{
-				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
-			}
-			else
-			{
-				#ifdef CONFIG_DISABLE_MCS13TO15
-				if(pmlmeext->cur_bwmode == CHANNEL_WIDTH_40 && pregistrypriv->wifi_spec != 1 )
-				{
-					pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R_MCS13TO15_OFF[i];
-				}
+			case RF_1T1R:
+			case RF_1T2R:
+				set_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_1R);							
+				break;
+			case RF_2T2R:			
+			default:
+#ifdef CONFIG_DISABLE_MCS13TO15
+				if(pmlmeext->cur_bwmode == CHANNEL_WIDTH_40 && pregistrypriv->wifi_spec != 1 )				
+					set_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_2R_13TO15_OFF);				
 				else
-					pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
-				#else
-				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
-				#endif //CONFIG_DISABLE_MCS13TO15
-			}
-			#ifdef RTL8192C_RECONFIG_TO_1T1R
-			{
-				pmlmeinfo->HT_caps.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
-			}
-			#endif
+					set_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_2R);
+#else //CONFIG_DISABLE_MCS13TO15
+				set_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_2R);
+#endif //CONFIG_DISABLE_MCS13TO15
 		}
+
 		//switch to the 40M Hz mode accoring to the AP
 		//pmlmeext->cur_bwmode = CHANNEL_WIDTH_40;
 		switch ((pmlmeinfo->HT_info.infos[0] & 0x3))
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mlme_ext.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mlme_ext.c
old mode 100644
new mode 100755
index 99e55120425e..16b6801ecc96
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mlme_ext.c
@@ -113,16 +113,6 @@ unsigned char RSN_TKIP_CIPHER[4] = {0x00, 0x0f, 0xac, 0x02};
 
 extern unsigned char REALTEK_96B_IE[];
 
-/********************************************************
-MCS rate definitions
-*********************************************************/
-#ifdef CONFIG_DISABLE_MCS13TO15
-unsigned char	MCS_rate_2R_MCS13TO15_OFF[16] = {0xff, 0x1f, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
-unsigned char	MCS_rate_2R[16] = {0xff, 0xff, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
-#else //CONFIG_DISABLE_MCS13TO15
-unsigned char	MCS_rate_2R[16] = {0xff, 0xff, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
-#endif //CONFIG_DISABLE_MCS13TO15
-unsigned char	MCS_rate_1R[16] = {0xff, 0x00, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
 
 /********************************************************
 ChannelPlan definitions
@@ -181,7 +171,7 @@ static RT_CHANNEL_PLAN_5G	RTW_ChannelPlan5G[RT_CHANNEL_DOMAIN_5G_MAX] = {
 	{{56,60,64,149,153,157,161,165},8},															// 0x10, RT_CHANNEL_DOMAIN_5G_NCC2
 	{{149,153,157,161,165},5},																	// 0x11, RT_CHANNEL_DOMAIN_5G_NCC3
 	{{36,40,44,48},4},																			// 0x12, RT_CHANNEL_DOMAIN_5G_ETSI4
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},20},					// 0x13, RT_CHANNEL_DOMAIN_5G_ETSI5
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},21},			// 0x13, RT_CHANNEL_DOMAIN_5G_ETSI5
 	{{149,153,157,161},4},																		// 0x14, RT_CHANNEL_DOMAIN_5G_FCC8
 	{{36,40,44,48,52,56,60,64},8},																// 0x15, RT_CHANNEL_DOMAIN_5G_ETSI6
 	{{36,40,44,48,52,56,60,64,149,153,157,161,165},13},											// 0x16, RT_CHANNEL_DOMAIN_5G_ETSI7
@@ -191,14 +181,17 @@ static RT_CHANNEL_PLAN_5G	RTW_ChannelPlan5G[RT_CHANNEL_DOMAIN_5G_MAX] = {
 	{{36,40,44,48,52,56,60,64,132,136,140,149,153,157,161,165},16},									// 0x1A, RT_CHANNEL_DOMAIN_5G_ETSI11
 	{{52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},17},							// 0x1B, RT_CHANNEL_DOMAIN_5G_NCC4
 	{{149,153,157,161},4},																		// 0x1C, RT_CHANNEL_DOMAIN_5G_ETSI12
-	{{36,40,44,48,100,104,108,112,116,132,136,140,149,153,157,161,165},17},							// 0x1D, RT_CHANNEL_DOMAIN_5G_FCC9
-	{{36,40,44,48,100,104,108,112,116,132,136,140},12},											// 0x1E, RT_CHANNEL_DOMAIN_5G_ETSI13
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161},20},					// 0x1F, RT_CHANNEL_DOMAIN_5G_FCC10
-
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},21},			// 0x1D, RT_CHANNEL_DOMAIN_5G_FCC9
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140},16},								// 0x1E, RT_CHANNEL_DOMAIN_5G_ETSI13
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161},20},				// 0x1F, RT_CHANNEL_DOMAIN_5G_FCC10
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,149,153,157,161},19},					// 0x20, RT_CHANNEL_DOMAIN_5G_KCC2
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},21},			// 0x21, RT_CHANNEL_DOMAIN_5G_FCC11
+	{{56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},16},						// 0x22, RT_CHANNEL_DOMAIN_5G_NCC5
+	{{36,40,44,48},4},																			// 0x23, RT_CHANNEL_DOMAIN_5G_MKK4
 	//===== Driver self defined for old channel plan Compatible ,Remember to modify if have new channel plan definition =====
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},21},				// 0x20, RT_CHANNEL_DOMAIN_5G_FCC
-	{{36,40,44,48},4},																			// 0x21, RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS
-	{{36,40,44,48,149,153,157,161},8},															// 0x22, RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},21},			// 0x30, RT_CHANNEL_DOMAIN_5G_FCC
+	{{36,40,44,48},4},																			// 0x31, RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS
+	{{36,40,44,48,149,153,157,161},8},															// 0x32, RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS
 };
 
 static RT_CHANNEL_PLAN_MAP	RTW_ChannelPlanMap[RT_CHANNEL_DOMAIN_MAX] = {
@@ -244,7 +237,7 @@ static RT_CHANNEL_PLAN_MAP	RTW_ChannelPlanMap[RT_CHANNEL_DOMAIN_MAX] = {
 	{0x02,0x04},	//0x25, RT_CHANNEL_DOMAIN_FCC1_FCC1
 	{0x00,0x01},	//0x26, RT_CHANNEL_DOMAIN_WORLD_ETSI1
 	{0x03,0x0C},	//0x27, RT_CHANNEL_DOMAIN_MKK1_MKK1
-	{0x00,0x0B},	//0x28, RT_CHANNEL_DOMAIN_WORLD_KCC1
+	{0x00,0x20},	//0x28, RT_CHANNEL_DOMAIN_5G_KCC2
 	{0x00,0x05},	//0x29, RT_CHANNEL_DOMAIN_WORLD_FCC2
 	{0x00,0x00},	//0x2A,
 	{0x00,0x00},	//0x2B,
@@ -256,12 +249,12 @@ static RT_CHANNEL_PLAN_MAP	RTW_ChannelPlanMap[RT_CHANNEL_DOMAIN_MAX] = {
 	{0x00,0x07},	//0x31, RT_CHANNEL_DOMAIN_WORLD_FCC4
 	{0x00,0x08},	//0x32, RT_CHANNEL_DOMAIN_WORLD_FCC5
 	{0x00,0x09},	//0x33, RT_CHANNEL_DOMAIN_WORLD_FCC6
-	{0x02,0x0A},	//0x34, RT_CHANNEL_DOMAIN_FCC1_FCC7
+	{0x02,0x21},	//0x34, RT_CHANNEL_DOMAIN_5G_FCC11
 	{0x00,0x02},	//0x35, RT_CHANNEL_DOMAIN_WORLD_ETSI2
 	{0x00,0x03},	//0x36, RT_CHANNEL_DOMAIN_WORLD_ETSI3
 	{0x03,0x0D},	//0x37, RT_CHANNEL_DOMAIN_MKK1_MKK2
 	{0x03,0x0E},	//0x38, RT_CHANNEL_DOMAIN_MKK1_MKK3
-	{0x02,0x0F},	//0x39, RT_CHANNEL_DOMAIN_FCC1_NCC1
+	{0x02,0x22},	//0x39, RT_CHANNEL_DOMAIN_5G_NCC5
 	{0x00,0x00},	//0x3A,
 	{0x00,0x00},	//0x3B,
 	{0x00,0x00},	//0x3C,
@@ -278,6 +271,12 @@ static RT_CHANNEL_PLAN_MAP	RTW_ChannelPlanMap[RT_CHANNEL_DOMAIN_MAX] = {
 	{0x00,0x15},	//0x47, RT_CHANNEL_DOMAIN_WORLD_ETSI6
 	{0x00,0x16},	//0x48, RT_CHANNEL_DOMAIN_WORLD_ETSI7
 	{0x00,0x17},	//0x49, RT_CHANNEL_DOMAIN_WORLD_ETSI8
+	{0x00,0x00},	//0x4A,
+	{0x00,0x00},	//0x4B,
+	{0x00,0x00},	//0x4C,
+	{0x00,0x00},	//0x4D,
+	{0x00,0x00},	//0x4E,
+	{0x00,0x00},	//0x4F,
 	{0x00,0x18},	//0x50, RT_CHANNEL_DOMAIN_WORLD_ETSI9
 	{0x00,0x19},	//0x51, RT_CHANNEL_DOMAIN_WORLD_ETSI10
 	{0x00,0x1A},	//0x52, RT_CHANNEL_DOMAIN_WORLD_ETSI11
@@ -286,9 +285,10 @@ static RT_CHANNEL_PLAN_MAP	RTW_ChannelPlanMap[RT_CHANNEL_DOMAIN_MAX] = {
 	{0x02,0x1D},	//0x55, RT_CHANNEL_DOMAIN_FCC1_FCC9
 	{0x00,0x1E},	//0x56, RT_CHANNEL_DOMAIN_WORLD_ETSI13
 	{0x02,0x1F},	//0x57, RT_CHANNEL_DOMAIN_FCC1_FCC10
+	{0x01,0x23},	//0x58, RT_CHANNEL_DOMAIN_WORLD_MKK4
 };
 
-static RT_CHANNEL_PLAN_MAP	RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE = {0x03,0x02}; //use the conbination for max channel numbers
+static RT_CHANNEL_PLAN_MAP	RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE = {0x01,0x02}; //use the conbination for max channel numbers
 
 /*
  * Search the @param ch in given @param ch_set
@@ -345,18 +345,24 @@ int init_hw_mlme_ext(_adapter *padapter)
 	return _SUCCESS;
 }
 
-static void init_mlme_ext_priv_value(_adapter* padapter)
+void init_mlme_default_rate_set(_adapter* padapter)
 {
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-#ifdef CONFIG_TDLS
-	u8 i;
-#endif
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
-	//unsigned char default_channel_set[MAX_CHANNEL_NUM] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 0};
 	unsigned char	mixed_datarate[NumRates] = {_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_,_9M_RATE_, _12M_RATE_, _18M_RATE_, _24M_RATE_, _36M_RATE_, _48M_RATE_, _54M_RATE_, 0xff};
 	unsigned char	mixed_basicrate[NumRates] ={_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_, _12M_RATE_, _24M_RATE_, 0xff,};
+	unsigned char	supported_mcs_set[16] = {0xff, 0xff, 0x00, 0x00, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+
+	_rtw_memcpy(pmlmeext->datarate, mixed_datarate, NumRates);
+	_rtw_memcpy(pmlmeext->basicrate, mixed_basicrate, NumRates);
+
+	_rtw_memcpy(pmlmeext->default_supported_mcs_set, supported_mcs_set, sizeof(pmlmeext->default_supported_mcs_set));
+}
+
+static void init_mlme_ext_priv_value(_adapter* padapter)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	ATOMIC_SET(&pmlmeext->event_seq, 0);
 	pmlmeext->mgnt_seq = 0;//reset to zero when disconnect at client mode
@@ -373,10 +379,7 @@ static void init_mlme_ext_priv_value(_adapter* padapter)
 
 	pmlmeext->cur_wireless_mode = padapter->registrypriv.wireless_mode;
 
-	//_rtw_memcpy(pmlmeext->channel_set, DefaultChannelPlan[padapter->mlmepriv.ChannelPlan].Channel, DefaultChannelPlan[padapter->mlmepriv.ChannelPlan].Len);
-	//_rtw_memcpy(pmlmeext->channel_set, default_channel_set, MAX_CHANNEL_NUM);
-	_rtw_memcpy(pmlmeext->datarate, mixed_datarate, NumRates);
-	_rtw_memcpy(pmlmeext->basicrate, mixed_basicrate, NumRates);
+	init_mlme_default_rate_set(padapter);
 
 	if(pmlmeext->cur_channel > 14)
 		pmlmeext->tx_rate = IEEE80211_OFDM_RATE_6MB;
@@ -487,14 +490,13 @@ static u8 init_channel_set(_adapter* padapter, u8 ChannelPlan, RT_CHANNEL_INFO *
 	u8	b5GBand = _FALSE, b2_4GBand = _FALSE;
 	u8	Index2G = 0, Index5G=0;
 
-	_rtw_memset(channel_set, 0, sizeof(RT_CHANNEL_INFO)*MAX_CHANNEL_NUM);
-
-	if(ChannelPlan >= RT_CHANNEL_DOMAIN_MAX && ChannelPlan != RT_CHANNEL_DOMAIN_REALTEK_DEFINE)
-	{
+	if (!rtw_is_channel_plan_valid(ChannelPlan)) {
 		DBG_871X("ChannelPlan ID %x error !!!!!\n",ChannelPlan);
 		return chanset_size;
 	}
 
+	_rtw_memset(channel_set, 0, sizeof(RT_CHANNEL_INFO)*MAX_CHANNEL_NUM);
+
 	if(IsSupported24G(padapter->registrypriv.wireless_mode))
 	{
 		b2_4GBand = _TRUE;
@@ -579,6 +581,8 @@ static u8 init_channel_set(_adapter* padapter, u8 ChannelPlan, RT_CHANNEL_INFO *
 		}
 	}
 
+	Hal_ChannelPlanToRegulation(padapter, ChannelPlan);
+
 	DBG_871X("%s ChannelPlan ID %x Chan num:%d  \n",__FUNCTION__,ChannelPlan,chanset_size);
 	return chanset_size;
 }
@@ -918,12 +922,13 @@ unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame)
 
 		//	Commented by Kurt 2012/10/16
 		//	IOT issue: Google Nexus7 use 1M rate to send p2p_probe_req after GO nego completed and Nexus7 is client
-#ifdef CONFIG_WIFI_TEST
-		if ( pattrib->data_rate <= 3 )
-		{
-			wifi_test_chk_rate = 0;
-		}
-#endif //CONFIG_WIFI_TEST
+        if (padapter->registrypriv.wifi_spec == 1)
+        {
+            if ( pattrib->data_rate <= 3 )
+            {
+                wifi_test_chk_rate = 0;
+            }
+        }
 
 		if( wifi_test_chk_rate == 1 )
 		{
@@ -1290,8 +1295,23 @@ unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
 			pbss = (WLAN_BSSID_EX*)rtw_malloc(sizeof(WLAN_BSSID_EX));
 			if (pbss) {
 				if (collect_bss_info(padapter, precv_frame, pbss) == _SUCCESS) {
+					struct beacon_keys recv_beacon;
+
 					update_network(&(pmlmepriv->cur_network.network), pbss, padapter, _TRUE);
 					rtw_get_bcn_info(&(pmlmepriv->cur_network));
+
+					// update bcn keys
+					if (rtw_get_bcn_keys(padapter, pframe, len, &recv_beacon) == _TRUE) {
+						DBG_871X("%s: beacon keys ready\n", __func__);
+						_rtw_memcpy(&pmlmepriv->cur_beacon_keys,
+							&recv_beacon, sizeof(recv_beacon));
+						pmlmepriv->new_beacon_cnts = 0;
+					}
+					else {
+						DBG_871X_LEVEL(_drv_err_, "%s: get beacon keys failed\n", __func__);
+						_rtw_memset(&pmlmepriv->cur_beacon_keys, 0, sizeof(recv_beacon));
+						pmlmepriv->new_beacon_cnts = 0;
+					}
 				}
 				rtw_mfree((u8*)pbss, sizeof(WLAN_BSSID_EX));
 			}
@@ -1953,17 +1973,12 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _SUPPORTEDRATES_IE_, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);
 	if (p == NULL) {
 		DBG_871X("Rx a sta assoc-req which supported rate is empty!\n");
-#ifdef CONFIG_SOFTAP_NO_CHECK_SUPPORT_RATE
-		supportRateNum = rtw_get_rateset_len(cur->SupportedRates);
-		_rtw_memcpy(supportRate, cur->SupportedRates, supportRateNum);
-#else
 		// use our own rate set as statoin used
 		//_rtw_memcpy(supportRate, AP_BSSRATE, AP_BSSRATE_LEN);
 		//supportRateNum = AP_BSSRATE_LEN;
 		
 		status = _STATS_FAILURE_;
 		goto OnAssocReqFail;
-#endif
 	}
 	else {
 		_rtw_memcpy(supportRate, p+2, ie_len);
@@ -2243,6 +2258,10 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		if (elems.vht_op_mode_notify && elems.vht_op_mode_notify_len == 1) {
 			_rtw_memcpy(&pstat->vhtpriv.vht_op_mode_notify, elems.vht_op_mode_notify, 1);
 		}
+		else // for Frame without Operating Mode notify ie; default: 80M
+		{
+			pstat->vhtpriv.vht_op_mode_notify = CHANNEL_WIDTH_80;
+		}
 	}
 	else {
 		pstat->flags &= ~WLAN_STA_VHT;
@@ -3190,7 +3209,7 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 
 	//	Value:
 	//	Todo the tie breaker bit.
-	p2pie[ p2pielen++ ] = ( ( pwdinfo->intent << 1 ) | BIT(0) );
+	p2pie[ p2pielen++ ] = ( ( pwdinfo->intent << 1 ) &  0xFE );
 
 	//	Configuration Timeout
 	//	Type:
@@ -5825,8 +5844,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 				result = process_p2p_group_negotation_req( pwdinfo, frame_body, len );
 				issue_p2p_GO_response( padapter, GetAddr2Ptr(pframe), frame_body, len, result );
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
-				{
+				if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL, 0);
@@ -6075,8 +6093,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 					_set_timer( &pwdinfo->restore_p2p_state_timer, 3000 );
 				}
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
-				{
+				if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL, 0);
@@ -6161,8 +6178,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ);
 				_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
-				{
+				if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) {
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					_cancel_timer_ex(&(padapter->mlmepriv.listen_timer));
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL, 0);
@@ -6394,7 +6410,7 @@ unsigned int OnAction_p2p(_adapter *padapter, union recv_frame *precv_frame)
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	uint len = precv_frame->u.hdr.len;
 	struct	wifidirect_info	*pwdinfo = &( padapter->wdinfo );
-	
+
 	//check RA matches or not
 	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))//for if1, sta/ap mode
 		return _SUCCESS;
@@ -6545,14 +6561,14 @@ void update_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 {
 	u8	wireless_mode;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-
+	struct xmit_priv 		*pxmitpriv = &padapter->xmitpriv;
 	//_rtw_memset((u8 *)(pattrib), 0, sizeof(struct pkt_attrib));
 
 	pattrib->hdrlen = 24;
 	pattrib->nr_frags = 1;
 	pattrib->priority = 7;
 	pattrib->mac_id = 0;
-	pattrib->qsel = 0x12;
+	pattrib->qsel = QSLT_MGNT;
 
 	pattrib->pktlen = 0;
 
@@ -6577,6 +6593,7 @@ void update_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 	pattrib->retry_ctrl = _TRUE;
 
 	pattrib->mbssid = 0;
+	pattrib->hw_ssn_sel = pxmitpriv->hw_ssn_seq_no;
 
 }
 
@@ -6736,7 +6753,11 @@ void issue_beacon(_adapter *padapter, int timeout_ms)
 
 	//DBG_871X("%s\n", __FUNCTION__);
 
+#ifdef CONFIG_BCN_ICF
+	if ((pmgntframe = rtw_alloc_bcnxmitframe(pxmitpriv)) == NULL)
+#else
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+#endif
 	{
 		DBG_871X("%s, alloc mgnt frame fail\n", __FUNCTION__);
 		return;
@@ -6748,7 +6769,7 @@ void issue_beacon(_adapter *padapter, int timeout_ms)
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
-	pattrib->qsel = 0x10;
+	pattrib->qsel = QSLT_BEACON;
 	#ifdef CONFIG_CONCURRENT_MODE
 	if(padapter->iface_type == IFACE_PORT1)	
 		pattrib->mbssid = 1;
@@ -8448,7 +8469,7 @@ int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mod
  * The null data packet would be sent without power bit,
  * and not guarantee success.
  */
-s32 issue_nulldata_in_interrupt(PADAPTER padapter, u8 *da)
+s32 issue_nulldata_in_interrupt(PADAPTER padapter, u8 *da, unsigned int power_mode)
 {
 	int ret;
 	struct mlme_ext_priv *pmlmeext;
@@ -8462,7 +8483,7 @@ s32 issue_nulldata_in_interrupt(PADAPTER padapter, u8 *da)
 	if (da == NULL)
 		da = get_my_bssid(&(pmlmeinfo->network));
 
-	ret = _issue_nulldata(padapter, da, 0, _FALSE);
+	ret = _issue_nulldata(padapter, da, power_mode, _FALSE);
 
 	return ret;
 }
@@ -8874,6 +8895,7 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 	u16	BA_timeout_value;
 	u16	BA_starting_seqctrl;
 	HT_CAP_AMPDU_FACTOR max_rx_ampdu_factor;
+	u8 ba_rxbuf_sz;
 	struct xmit_frame		*pmgntframe;
 	struct pkt_attrib		*pattrib;
 	u8					*pframe;
@@ -8887,7 +8909,6 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 	struct registry_priv	 	*pregpriv = &padapter->registrypriv;
 
 #ifdef CONFIG_80211N_HT
-	DBG_871X("%s, category=%d, action=%d, status=%d\n", __FUNCTION__, category, action, status);
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
@@ -8934,28 +8955,12 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 				} while (pmlmeinfo->dialogToken == 0);
 				pframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->dialogToken), &(pattrib->pktlen));
 
-#ifdef CONFIG_BT_COEXIST
-				if (rtw_btcoex_IsBTCoexCtrlAMPDUSize(padapter) == _TRUE)
-				{
-					// A-MSDU NOT Supported
-					BA_para_set = 0;
-					// immediate Block Ack
-					BA_para_set |= (1 << 1) & IEEE80211_ADDBA_PARAM_POLICY_MASK;
-					// TID
-					BA_para_set |= (status << 2) & IEEE80211_ADDBA_PARAM_TID_MASK;
-					// max buffer size is 8 MSDU
-					BA_para_set |= (8 << 6) & RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;
-				}
-				else
-#endif
-				{
-					#if defined(CONFIG_RTL8188E) && defined(CONFIG_SDIO_HCI)
-					BA_para_set = (0x0802 | ((status & 0xf) << 2)); //immediate ack & 16 buffer size
-					#else
-					BA_para_set = (0x1002 | ((status & 0xf) << 2)); //immediate ack & 64 buffer size
-					#endif
-				}
-				//sys_mib.BA_para_set = 0x0802; //immediate ack & 32 buffer size
+				#if defined(CONFIG_RTL8188E) && defined(CONFIG_SDIO_HCI)
+				BA_para_set = (0x0802 | ((status & 0xf) << 2)); //immediate ack & 16 buffer size
+				#else
+				BA_para_set = (0x1002 | ((status & 0xf) << 2)); //immediate ack & 64 buffer size
+				#endif
+
 				BA_para_set = cpu_to_le16(BA_para_set);
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
 
@@ -8978,49 +8983,57 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 				
 				BA_starting_seqctrl = cpu_to_le16(BA_starting_seqctrl);
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_starting_seqctrl)), &(pattrib->pktlen));
+				DBG_871X("%s, category=%d, action=%d, status=%d\n", __FUNCTION__, category, action, status);
 				break;
 
 			case 1: //ADDBA rsp
 				pframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->ADDBA_req.dialog_token), &(pattrib->pktlen));
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&status), &(pattrib->pktlen));
-				/*
-				//BA_para_set = cpu_to_le16((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
-				#if defined(CONFIG_RTL8188E )&& defined (CONFIG_SDIO_HCI)
-				BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0800); //32buffer size
-				#else
-				BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
-				#endif
-				*/
-				rtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor);
+
+				BA_para_set = le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set);
+
+				if(padapter->driver_rx_ampdu_factor != 0xFF)
+					max_rx_ampdu_factor = (HT_CAP_AMPDU_FACTOR)padapter->driver_rx_ampdu_factor;
+				else
+					rtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor);
+				
 				if(MAX_AMPDU_FACTOR_64K == max_rx_ampdu_factor)
-					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
+					ba_rxbuf_sz = 64;
 				else if(MAX_AMPDU_FACTOR_32K == max_rx_ampdu_factor)
-					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0800); //32 buffer size
+					ba_rxbuf_sz = 32;
 				else if(MAX_AMPDU_FACTOR_16K == max_rx_ampdu_factor)
-					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0400); //16 buffer size
+					ba_rxbuf_sz = 16;
 				else if(MAX_AMPDU_FACTOR_8K == max_rx_ampdu_factor)
-					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0200); //8 buffer size
+					ba_rxbuf_sz = 8;
 				else
-					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size	
+					ba_rxbuf_sz = 64;
 
-#ifdef CONFIG_BT_COEXIST
+				#ifdef CONFIG_BT_COEXIST
 				if (rtw_btcoex_IsBTCoexCtrlAMPDUSize(padapter) == _TRUE)
-				{
-					// max buffer size is 8 MSDU
-					BA_para_set &= ~RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;
-					BA_para_set |= (8 << 6) & RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;
+					ba_rxbuf_sz = rtw_btcoex_GetAMPDUSize(padapter);
+				#endif
+
+				if (padapter->fix_ba_rxbuf_bz != 0xFF)
+					ba_rxbuf_sz = padapter->fix_ba_rxbuf_bz;
+
+				if (ba_rxbuf_sz > 127)
+					ba_rxbuf_sz = 127;
+
+				BA_para_set &= ~RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;
+				BA_para_set |= (ba_rxbuf_sz << 6) & RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;
+
+				if (!padapter->registrypriv.wifi_spec) {
+					if(pregpriv->ampdu_amsdu==0)//disabled
+						BA_para_set &= ~BIT(0);
+					else if(pregpriv->ampdu_amsdu==1)//enabled
+						BA_para_set |= BIT(0);
 				}
-#endif
 
-				if(pregpriv->ampdu_amsdu==0)//disabled
-					BA_para_set = cpu_to_le16(BA_para_set & ~BIT(0));
-				else if(pregpriv->ampdu_amsdu==1)//enabled
-					BA_para_set = cpu_to_le16(BA_para_set | BIT(0));
-				else //auto
-					BA_para_set = cpu_to_le16(BA_para_set);
-				
+				BA_para_set = cpu_to_le16(BA_para_set);
+
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(pmlmeinfo->ADDBA_req.BA_timeout_value)), &(pattrib->pktlen));
+				DBG_871X("%s, category=%d, action=%d, status=%d, rxbuf_sz=%u\n", __FUNCTION__, category, action, status, ba_rxbuf_sz);
 				break;
 			case 2://DELBA
 				BA_para_set = (status & 0x1F) << 3;
@@ -9030,6 +9043,7 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 				reason_code = 37;//Requested from peer STA as it does not want to use the mechanism
 				reason_code = cpu_to_le16(reason_code);
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(reason_code)), &(pattrib->pktlen));
+				DBG_871X("%s, category=%d, action=%d, status=%d\n", __FUNCTION__, category, action, status);
 				break;
 			default:
 				break;
@@ -9200,6 +9214,140 @@ static void issue_action_BSSCoexistPacket(_adapter *padapter)
 #endif //CONFIG_80211N_HT
 }
 
+// Spatial Multiplexing Powersave (SMPS) action frame
+int _issue_action_SM_PS(_adapter *padapter ,  unsigned char *raddr , u8 NewMimoPsMode ,  u8 wait_ack)
+{
+
+        int ret=0;
+        unsigned char category = RTW_WLAN_CATEGORY_HT;
+	u8 action = RTW_WLAN_ACTION_HT_SM_PS; 	
+	u8 sm_power_control=0;
+	struct xmit_frame			*pmgntframe;
+	struct pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+
+	if(NewMimoPsMode==WLAN_HT_CAP_SM_PS_DISABLED)
+	{
+		sm_power_control = sm_power_control  & ~(BIT(0)); // SM Power Save Enable = 0 SM Power Save Disable 
+	}
+        else if(NewMimoPsMode==WLAN_HT_CAP_SM_PS_STATIC)
+        {
+                sm_power_control = sm_power_control | BIT(0);    // SM Power Save Enable = 1 SM Power Save Enable  
+                sm_power_control = sm_power_control & ~(BIT(1)); // SM Mode = 0 Static Mode
+        }
+        else if(NewMimoPsMode==WLAN_HT_CAP_SM_PS_DYNAMIC)
+        {
+                sm_power_control = sm_power_control | BIT(0); // SM Power Save Enable = 1 SM Power Save Enable  
+                sm_power_control = sm_power_control | BIT(1); // SM Mode = 1 Dynamic Mode
+        }
+        else 
+		return ret;
+
+        DBG_871X("%s, sm_power_control=%u, NewMimoPsMode=%u\n", __FUNCTION__ , sm_power_control , NewMimoPsMode );
+    
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+		return ret;
+
+	//update attribute
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+
+	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	_rtw_memcpy(pwlanhdr->addr1, raddr, ETH_ALEN); /* RA */
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN); /* TA */
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN); /* DA = RA */
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	/* category, action */
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(sm_power_control), &(pattrib->pktlen));
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	if(wait_ack)
+	{
+		ret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);
+	}
+	else
+	{
+		dump_mgntframe(padapter, pmgntframe);
+		ret = _SUCCESS;
+	}
+
+        if (ret != _SUCCESS)
+            DBG_8192C("%s, ack to\n", __func__);
+
+	return ret;
+}
+
+int issue_action_SM_PS_wait_ack(_adapter *padapter, unsigned char *raddr, u8 NewMimoPsMode, int try_cnt, int wait_ms)
+{
+	int ret = 0;
+	int i = 0;
+	u32 start = rtw_get_current_time();
+
+	do {
+		ret = _issue_action_SM_PS(padapter, raddr, NewMimoPsMode , wait_ms>0?_TRUE:_FALSE );
+
+		i++;
+
+		if (padapter->bDriverStopped || padapter->bSurpriseRemoved)
+			break;
+
+		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+			rtw_msleep_os(wait_ms);
+
+	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
+
+	if (ret != _FAIL) {
+		ret = _SUCCESS;
+		#ifndef DBG_XMIT_ACK
+		goto exit;
+		#endif
+	}
+
+	if (try_cnt && wait_ms) {
+		if (raddr)
+			DBG_871X(FUNC_ADPT_FMT" to "MAC_FMT", %s , %d/%d in %u ms\n",
+				FUNC_ADPT_ARG(padapter), MAC_ARG(raddr),
+				ret==_SUCCESS?", acked":"", i, try_cnt, rtw_get_passing_time_ms(start));
+		else
+			DBG_871X(FUNC_ADPT_FMT", %s , %d/%d in %u ms\n",
+				FUNC_ADPT_ARG(padapter),
+				ret==_SUCCESS?", acked":"", i, try_cnt, rtw_get_passing_time_ms(start));
+	}
+exit:
+
+	return ret;
+}
+
+int issue_action_SM_PS(_adapter *padapter ,  unsigned char *raddr , u8 NewMimoPsMode )
+{
+	DBG_871X("%s to "MAC_FMT"\n", __func__, MAC_ARG(raddr));
+	return _issue_action_SM_PS(padapter, raddr, NewMimoPsMode , _FALSE );
+}
+
 unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr)
 {
 	struct sta_priv *pstapriv = &padapter->stapriv;
@@ -9271,13 +9419,16 @@ unsigned int send_beacon(_adapter *padapter)
 //#endif		
 
 #ifdef CONFIG_PCI_HCI
-
 	//DBG_871X("%s\n", __FUNCTION__);
 
+	rtw_hal_set_hwreg(padapter, HW_VAR_BCN_VALID, NULL);
+
+	/* 8192EE Port select for Beacon DL */
+	rtw_hal_set_hwreg(padapter, HW_VAR_DL_BCN_SEL, NULL);
+
 	issue_beacon(padapter, 0);
 
 	return _SUCCESS;
-
 #endif
 
 #if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
@@ -9352,6 +9503,7 @@ void site_survey(_adapter *padapter)
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u32 initialgain = 0;
+	u32 channel_scan_time_ms = 0,val32 = 0;
 
 #ifdef CONFIG_P2P
 
@@ -9526,28 +9678,43 @@ void site_survey(_adapter *padapter)
 				}
 			}
 		}
+
 #if  defined(CONFIG_ATMEL_RC_PATCH)
 		// treat wlan0 & p2p0 in same way, may be changed in near feature.
 		// assume home channel is 6, channel switch sequence will be 
 		//	1,2-6-3,4-6-5,6-6-7,8-6-9,10-6-11,12-6-13,14
 		//if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)==_TRUE)
 
-		if( stay_buddy_ch == 1 )
-			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND );
+		if( stay_buddy_ch == 1 ){
+			channel_scan_time_ms = pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND;			
+		}
 		else {
 			if( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
-				set_survey_timer(pmlmeext, 20);
+				channel_scan_time_ms = 20;
 			else
-				set_survey_timer(pmlmeext, 40);
+				channel_scan_time_ms = 40
 		}
 #elif defined(CONFIG_STA_MODE_SCAN_UNDER_AP_MODE)
 		if( stay_buddy_ch == 1 )
-			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND );
-		else
-			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
+			channel_scan_time_ms = pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND ;
+		else		
+			channel_scan_time_ms = pmlmeext->chan_scan_time;
 #else
-			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
+			channel_scan_time_ms = pmlmeext->chan_scan_time;
 #endif
+
+		set_survey_timer(pmlmeext, channel_scan_time_ms);
+#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		{
+			struct noise_info info;
+			info.bPauseDIG = _FALSE;
+			info.IGIValue = 0;
+			info.max_time = channel_scan_time_ms/2;//ms
+			info.chan = survey_channel;
+			rtw_hal_set_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&info, _FALSE);	
+		}
+#endif
+
 	}
 	else
 	{
@@ -9607,12 +9774,13 @@ void site_survey(_adapter *padapter)
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_LISTEN);
 			pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
 
-			initialgain = 0xff; //restore RX GAIN
-			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));	
-			//turn on dynamic functions
+			//turn on phy-dynamic functions
 			Restore_DM_Func_Flag(padapter);
 			//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
 			
+			initialgain = 0xff; //restore RX GAIN
+			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));		
+			
 			_set_timer( &pwdinfo->find_phase_timer, ( u32 ) ( ( u32 ) ( pwdinfo->listen_dwell ) * 100 ) );
 		}
 		else
@@ -9687,11 +9855,13 @@ void site_survey(_adapter *padapter)
 			//config MSR
 			Set_MSR(padapter, (pmlmeinfo->state & 0x3));
 
-			initialgain = 0xff; //restore RX GAIN
-			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));	
-			//turn on dynamic functions
+			//turn on phy-dynamic functions
 			Restore_DM_Func_Flag(padapter);
 			//Switch_DM_Func(padapter, DYNAMIC_ALL_FUNC_ENABLE, _TRUE);
+			
+			initialgain = 0xff; //restore RX GAIN
+			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));	
+			
 
 			if (is_client_associated_to_ap(padapter) == _TRUE)
 			{
@@ -10072,6 +10242,7 @@ void start_clnt_join(_adapter* padapter)
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
 	int beacon_timeout;
+	u8 ASIX_ID[]= {0x00, 0x0E, 0xC6};
 
 	//update wireless mode
 	update_wireless_mode(padapter);
@@ -10079,6 +10250,12 @@ void start_clnt_join(_adapter* padapter)
 	//udpate capability
 	caps = rtw_get_capability((WLAN_BSSID_EX *)pnetwork);
 	update_capinfo(padapter, caps);
+	
+	//check if sta is ASIX peer and fix IOT issue if it is.
+	if (_rtw_memcmp(get_my_bssid(&pmlmeinfo->network) ,ASIX_ID ,3)) {
+		u8 iot_flag = _TRUE;
+		rtw_hal_set_hwreg(padapter, HW_VAR_ASIX_IOT, (u8 *)(&iot_flag));
+	}
 	if (caps&cap_ESS)
 	{
 		Set_MSR(padapter, WIFI_FW_STATION_STATE);
@@ -10693,6 +10870,52 @@ void report_join_res(_adapter *padapter, int res)
 
 }
 
+void report_wmm_edca_update(_adapter *padapter)
+{
+	struct cmd_obj *pcmd_obj;
+	u8	*pevtcmd;
+	u32 cmdsz;
+	struct wmm_event		*pwmm_event;
+	struct C2HEvent_Header	*pc2h_evt_hdr;
+	struct mlme_ext_priv		*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	if ((pcmd_obj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct wmm_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (u8*)rtw_zmalloc(cmdsz)) == NULL)
+	{
+		rtw_mfree((u8 *)pcmd_obj, sizeof(struct cmd_obj));
+		return;
+	}
+
+	_rtw_init_listhead(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct wmm_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_WMM);
+	pc2h_evt_hdr->seq = ATOMIC_INC_RETURN(&pmlmeext->event_seq);
+
+	pwmm_event = (struct wmm_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	pwmm_event->wmm =0;
+	
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+
+}
+
 void report_del_sta_event(_adapter *padapter, unsigned char* MacAddr, unsigned short reason)
 {
 	struct cmd_obj *pcmd_obj;
@@ -10915,6 +11138,8 @@ void update_sta_info(_adapter *padapter, struct sta_info *psta)
 
 		psta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;
 
+		psta->htpriv.rx_ampdu_min_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para&IEEE80211_HT_CAP_AMPDU_DENSITY)>>2;
+
 		if (support_short_GI(padapter, &(pmlmeinfo->HT_caps), CHANNEL_WIDTH_20))
 			psta->htpriv.sgi_20m = _TRUE;
 
@@ -10974,16 +11199,39 @@ static void rtw_mlmeext_disconnect(_adapter *padapter)
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
 	u8 state_backup = (pmlmeinfo->state&0x03);
+	u8 ASIX_ID[]= {0x00, 0x0E, 0xC6};
 
 	//set_opmode_cmd(padapter, infra_client_with_mlme);
 
+#if 1
+	/*
+	 * For safety, prevent from keeping macid sleep.
+	 * If we can sure all power mode enter/leave are paired,
+	 * this check can be removed.
+	 * Lucas@20131113
+	 */
+	/* wakeup macid after disconnect. */
+	{
+		struct sta_info *psta;
+		psta = rtw_get_stainfo(&padapter->stapriv, get_my_bssid(pnetwork));
+		if (psta)
+			rtw_hal_macid_wakeup(padapter, psta->mac_id);
+	}
+#endif	
+
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, 0);
 	rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);
 
 	//set MSR to no link state -> infra. mode
 	Set_MSR(padapter, _HW_STATE_STATION_);
 
+	//check if sta is ASIX peer and fix IOT issue if it is.
+	if (_rtw_memcmp(get_my_bssid(&pmlmeinfo->network) ,ASIX_ID ,3)) {
+		u8 iot_flag = _FALSE;
+		rtw_hal_set_hwreg(padapter, HW_VAR_ASIX_IOT, (u8 *)(&iot_flag));
+	}
 	pmlmeinfo->state = WIFI_FW_NULL_STATE;
 
 	if(state_backup == WIFI_FW_STATION_STATE)
@@ -11115,6 +11363,10 @@ void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res)
 		set_sta_rate(padapter, psta);
 		
 		rtw_sta_media_status_rpt(padapter, psta, 1);
+
+		/* wakeup macid after join bss successfully to ensure 
+			the subsequent data frames can be sent out normally */
+		rtw_hal_macid_wakeup(padapter, psta->mac_id);
 	}
 
 	if (rtw_port_switch_chk(padapter) == _TRUE)
@@ -11234,10 +11486,10 @@ void _linked_info_dump(_adapter *padapter)
 {
 	int i;
 	struct mlme_ext_priv    *pmlmeext = &padapter->mlmeextpriv;
-      struct mlme_ext_info    *pmlmeinfo = &(pmlmeext->mlmext_info);
-	u8 mac_id;
+	struct mlme_ext_info    *pmlmeinfo = &(pmlmeext->mlmext_info);
 	int UndecoratedSmoothedPWDB;
-	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct macid_ctl_t *macid_ctl = dvobj_to_macidctl(dvobj);
 	
 	if(padapter->bLinkInfoDump){
 
@@ -11272,13 +11524,13 @@ void _linked_info_dump(_adapter *padapter)
 			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);		
 			
 		}
-		for(i=0; i<NUM_STA; i++)
+		for(i=0; i<macid_ctl->num; i++)
 		{
-			if(pdvobj->macid[i] == _TRUE)
-			{
-				if(i !=1) //skip bc/mc sta
-					//============  tx info ============	
-					rtw_hal_get_def_var(padapter, HW_DEF_RA_INFO_DUMP, &i);			
+			if(rtw_macid_is_used(macid_ctl, i) 
+				&& !rtw_macid_is_bmc(macid_ctl, i) /* skip bc/mc sta */
+			) {
+				//============  tx info ============	
+				rtw_hal_get_def_var(padapter, HW_DEF_RA_INFO_DUMP, &i);			
 			}
 		}
 		rtw_hal_set_def_var(padapter, HAL_DEF_DBG_RX_INFO_DUMP, NULL);
@@ -11442,7 +11694,8 @@ struct candidate_pool{
 }
 #endif //CONFIG_TDLS
 
-void linked_status_chk(_adapter *padapter)
+//from_timer == 1 means driver is in LPS
+void linked_status_chk(_adapter *padapter, u8 from_timer)
 {
 	u32	i;
 	struct sta_info		*psta;
@@ -11469,10 +11722,20 @@ void linked_status_chk(_adapter *padapter)
 		#endif
 #ifdef CONFIG_P2P
 		if (!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE))
-			link_count_limit = 3; // 8 sec
+		{
+			if(!from_timer)
+				link_count_limit = 3; // 8 sec
+			else
+				link_count_limit = 15; // 32 sec
+		}
 		else
 #endif // CONFIG_P2P
-			link_count_limit = 7; // 16 sec
+		{
+			if(!from_timer)
+				link_count_limit = 7; // 16 sec
+			else
+				link_count_limit = 29; // 60 sec
+		}		
 
 		// Marked by Kurt 20130715
 		// For WiDi 3.5 and latered on, they don't ask WiDi sink to do roaming, so we could not check rx limit that strictly.
@@ -11536,9 +11799,9 @@ void linked_status_chk(_adapter *padapter)
 
 				if (tx_chk != _SUCCESS && pmlmeinfo->link_count++ == link_count_limit) {
 					#ifdef DBG_EXPIRATION_CHK
-					DBG_871X("%s issue_nulldata 0\n", __FUNCTION__);
+					DBG_871X("%s issue_nulldata(%d)\n", __FUNCTION__, from_timer?1:0);
 					#endif
-					tx_chk = issue_nulldata_in_interrupt(padapter, NULL);
+					tx_chk = issue_nulldata_in_interrupt(padapter, NULL, from_timer?1:0);
 				}
 			}
 
@@ -11762,7 +12025,7 @@ void link_timer_hdl(_adapter *padapter)
 			{
 				if (tx_cnt == pxmitpriv->tx_pkts)
 				{
-					issue_nulldata_in_interrupt(padapter, NULL);
+					issue_nulldata_in_interrupt(padapter, NULL, 0);
 				}
 
 				tx_cnt = pxmitpriv->tx_pkts;
@@ -12053,14 +12316,14 @@ u8 createbss_hdl(_adapter *padapter, u8 *pbuf)
 		pmlmeinfo->agg_enable_bitmap = 0;
 		pmlmeinfo->candidate_tid_bitmap = 0;
 
-		//disable dynamic functions, such as high power, DIG
-		Save_DM_Func_Flag(padapter);
-		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
-
 		//config the initial gain under linking, need to write the BB registers
 		//initialgain = 0x1E;
 		//rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
 
+		//disable dynamic functions, such as high power, DIG
+		Save_DM_Func_Flag(padapter);
+		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
+		
 		//cancel link timer 
 		_cancel_timer_ex(&pmlmeext->link_timer);
 
@@ -12100,48 +12363,6 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 	//u32	acparm;
 	u8 ch, bw, offset;
 
-#if 1
-	/*
-	 * For safety, prevent from keeping macid sleep.
-	 * If we can sure all power mode enter/leave are paired,
-	 * this check can be removed.
-	 * Lucas@20131113
-	 */
-	{
-	struct sta_info *psta;
-	psta = rtw_get_stainfo(&padapter->stapriv, get_my_bssid(pnetwork));
-	if (psta)
-		rtw_hal_macid_wakeup(padapter, psta->mac_id);
-	}
-#endif
-
-#ifdef CONFIG_BT_COEXIST
-{
-	static u8 bw_mode = 0;
-
-	if (0 == bw_mode)
-	{
-		bw_mode = pregpriv->bw_mode; // keep original bw_mode
-		DBG_871X(FUNC_ADPT_FMT ": [BTCOEX] Save bw_mode(0x%02x)\n",
-			FUNC_ADPT_ARG(padapter), pregpriv->bw_mode);
-	}
-
-	if ((rtw_btcoex_1Ant(padapter) == _TRUE)
-		&& (rtw_btcoex_IsBtLinkExist(padapter) == _TRUE))
-	{
-		pregpriv->bw_mode = 0x00;
-		DBG_871X(FUNC_ADPT_FMT ": [BTCOEX] Change bw_mode to 20MHz(0x%02x)\n",
-			FUNC_ADPT_ARG(padapter), pregpriv->bw_mode);
-	}
-	else
-	{
-		pregpriv->bw_mode = bw_mode;
-		DBG_871X(FUNC_ADPT_FMT ": [BTCOEX] Restore bw_mode(0x%02x)\n",
-			FUNC_ADPT_ARG(padapter), pregpriv->bw_mode);
-	}
-}
-#endif // CONFIG_BT_COEXIST
-
 	//check already connecting to AP or not
 	if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
 	{
@@ -12357,22 +12578,6 @@ u8 disconnect_hdl(_adapter *padapter, unsigned char *pbuf)
 	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
 	u8 val8;
 
-
-#if 1
-	/*
-	 * For safety, prevent from keeping macid sleep.
-	 * If we can sure all power mode enter/leave are paired,
-	 * this check can be removed.
-	 * Lucas@20131113
-	 */
-	{
-	struct sta_info *psta;
-	psta = rtw_get_stainfo(&padapter->stapriv, get_my_bssid(pnetwork));
-	if (psta)
-		rtw_hal_macid_wakeup(padapter, psta->mac_id);
-	}
-#endif
-
 	if (is_client_associated_to_ap(padapter))
 	{
 #ifdef CONFIG_DFS
@@ -12622,10 +12827,6 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf)
 #endif
 #endif /* CONFIG_FIND_BEST_CHANNEL */
 
-		//disable dynamic functions, such as high power, DIG
-		Save_DM_Func_Flag(padapter);
-		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
-
 		//config the initial gain under scaning, need to write the BB registers
 #ifdef CONFIG_P2P
 #ifdef CONFIG_IOCTL_CFG80211
@@ -12640,6 +12841,10 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf)
 			initialgain = 0x1e;
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
+
+		//disable dynamic functions, such as high power, DIG
+		Save_DM_Func_Flag(padapter);
+		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
 		
 		//set MSR to no link state
 		Set_MSR(padapter, _HW_STATE_NOLINK_);
@@ -12674,7 +12879,6 @@ u8 setkey_hdl(_adapter *padapter, u8 *pbuf)
 {
 	u16	ctrl = 0;
 	s16 cam_id = 0;
-
 	struct setkey_parm		*pparm = (struct setkey_parm *)pbuf;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -12684,7 +12888,7 @@ u8 setkey_hdl(_adapter *padapter, u8 *pbuf)
 	//main tx key for wep.
 	if(pparm->set_tx)
 		pmlmeinfo->key_index = pparm->keyid;
-	
+
 	cam_id = rtw_camid_alloc(padapter, NULL, pparm->keyid);
 
 	if (cam_id < 0){
@@ -12694,17 +12898,17 @@ u8 setkey_hdl(_adapter *padapter, u8 *pbuf)
 		else
 			addr = null_addr;
 		
-		ctrl = BIT(15) | BIT6 | ((pparm->algorithm) << 2) | pparm->keyid;
+		ctrl = BIT(15) | BIT6 |((pparm->algorithm) << 2) | pparm->keyid;
 		write_cam(padapter, cam_id, ctrl, addr, pparm->key);
 		DBG_871X_LEVEL(_drv_always_, "set group key camid:%d, addr:"MAC_FMT", kid:%d, type:%s\n"
 			,cam_id, MAC_ARG(addr), pparm->keyid, security_type_str(pparm->algorithm));
 	}
 
-#ifdef DYNAMIC_CAMID_ALLOC
+	#ifdef DYNAMIC_CAMID_ALLOC
 	if (cam_id >=0 && cam_id <=3)
 		rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)_TRUE);
-#endif
-	
+	#endif
+
 	//allow multicast packets to driver
 	padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_ON_RCR_AM, null_addr);
 
@@ -12713,8 +12917,8 @@ u8 setkey_hdl(_adapter *padapter, u8 *pbuf)
 
 u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 {
-	u16 ctrl=0;
-	s16 cam_id = 0;//cam_entry
+	u16 ctrl = 0;
+	s16 cam_id = 0;
 	u8 ret = H2C_SUCCESS;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -12755,8 +12959,7 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 	}
 	ret = H2C_SUCCESS_RSP;
 
-exit:	
-
+exit:
 	return ret;
 }
 
@@ -12990,7 +13193,8 @@ u8 chk_bmc_sleepq_hdl(_adapter *padapter, unsigned char *pbuf)
 
 			pxmitframe->attrib.triggered=1;
 
-			pxmitframe->attrib.qsel = 0x11;//HIQ
+			if (xmitframe_hiq_filter(pxmitframe) == _TRUE)
+				pxmitframe->attrib.qsel = QSLT_HIGH;//HIQ
 
 			#if 0
 			_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
@@ -13006,10 +13210,10 @@ u8 chk_bmc_sleepq_hdl(_adapter *padapter, unsigned char *pbuf)
 		//_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
 		_exit_critical_bh(&pxmitpriv->lock, &irqL);
 
-		//#if defined(CONFIG_PCI_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
-		#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
-		rtw_chk_hi_queue_cmd(padapter);
-		#endif
+		if (padapter->interface_type != RTW_PCIE) {
+			/* check hi queue and bmc_sleepq */
+			rtw_chk_hi_queue_cmd(padapter);
+		}
 	}
 #endif
 
@@ -14190,23 +14394,27 @@ u8 set_ch_hdl(_adapter *padapter, u8 *pbuf)
 u8 set_chplan_hdl(_adapter *padapter, unsigned char *pbuf)
 {
 	struct SetChannelPlan_param *setChannelPlan_param;
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_priv *mlme = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
 	if(!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
 	setChannelPlan_param = (struct SetChannelPlan_param *)pbuf;
 
+	if(!rtw_is_channel_plan_valid(setChannelPlan_param->channel_plan)) {
+		return H2C_PARAMETERS_ERROR;
+	}
+
+	mlme->ChannelPlan = setChannelPlan_param->channel_plan;
+
 	pmlmeext->max_chan_nums = init_channel_set(padapter, setChannelPlan_param->channel_plan, pmlmeext->channel_set);
 	init_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);	
 
+	rtw_hal_set_odm_var(padapter,HAL_ODM_REGULATION,NULL,_TRUE);
+	
 #ifdef CONFIG_IOCTL_CFG80211
-	if ((padapter->rtw_wdev != NULL) && (padapter->rtw_wdev->wiphy)) {
-		struct regulatory_request request;
-		request.initiator = NL80211_REGDOM_SET_BY_DRIVER;
-		rtw_reg_notifier(padapter->rtw_wdev->wiphy, &request);
-	}
+	rtw_reg_notify_by_driver(padapter);
 #endif //CONFIG_IOCTL_CFG80211
 
 	return 	H2C_SUCCESS;
@@ -14472,3 +14680,18 @@ u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf)
 
 }
 
+u8 run_in_thread_hdl(_adapter *padapter, u8 *pbuf)
+{
+	struct RunInThread_param *p;
+
+
+	if (NULL == pbuf)
+		return H2C_PARAMETERS_ERROR;
+	p = (struct RunInThread_param*)pbuf;
+
+	if (p->func)
+		p->func(p->context);
+
+	return H2C_SUCCESS;
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mp.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mp.c
index 484b520acd8f..772633e1111e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mp.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mp.c
@@ -25,7 +25,7 @@
 #include <sys/unistd.h>		/* for RFHIGHPID */
 #endif
 
-#include "../hal/OUTSRC/odm_precomp.h"		
+#include "../hal/OUTSRC/phydm_precomp.h"		
 #if defined(CONFIG_RTL8723A) || defined(CONFIG_RTL8723B) || defined(CONFIG_RTL8821A)
 #include <rtw_bt_mp.h>
 #endif
@@ -292,7 +292,7 @@ s32 init_mp_priv(PADAPTER padapter)
 	pmppriv->tx.stop = 1;
 	pmppriv->bSetTxPower=0;		//for  manually set tx power
 	pmppriv->bTxBufCkFail=_FALSE;
-	pmppriv->pktInterval=300;
+	pmppriv->pktInterval=0;
 	
 	mp_init_xmit_attrib(&pmppriv->tx, padapter);
 
@@ -423,7 +423,7 @@ void mpt_InitHWConfig(PADAPTER Adapter)
 
 #define PHY_IQCalibrate(_Adapter, b)	\
 		IS_HARDWARE_TYPE_8812(_Adapter) ? PHY_IQCalibrate_8812A(_Adapter, b) : \
-		IS_HARDWARE_TYPE_8821(_Adapter) ? PHY_IQCalibrate_8821A(_Adapter, b) : \
+		IS_HARDWARE_TYPE_8821(_Adapter) ? PHY_IQCalibrate_8821A(&(GET_HAL_DATA(_Adapter)->odmpriv), b) : \
 		PHY_IQCalibrate_default(_Adapter, b)
 
 #define PHY_LCCalibrate(_Adapter)	\
@@ -449,17 +449,13 @@ static void PHY_IQCalibrate(PADAPTER padapter, u8 bReCovery)
 	u8 b2ant;	//false:1ant, true:2-ant
 	u8 RF_Path;	//0:S1, 1:S0
 
-
 	pHalData = GET_HAL_DATA(padapter);
 	b2ant = pHalData->EEPROMBluetoothAntNum==Ant_x2?_TRUE:_FALSE;
-	RF_Path = 0;
-#ifdef CONFIG_USB_HCI
-	RF_Path = 1;
-#endif
 
-	PHY_IQCalibrate_8723B(padapter, bReCovery, _FALSE, b2ant, RF_Path);
+	PHY_IQCalibrate_8723B(padapter, bReCovery, _FALSE, b2ant, pHalData->ant_path);
 }
 
+
 #define PHY_LCCalibrate(a)	PHY_LCCalibrate_8723B(&(GET_HAL_DATA(a)->odmpriv))
 #define PHY_SetRFPathSwitch(a,b)	PHY_SetRFPathSwitch_8723B(a,b)
 #endif
@@ -550,7 +546,7 @@ MPT_InitializeAdapter(
 	
 	PHY_LCCalibrate(pAdapter);
 	PHY_IQCalibrate(pAdapter, _FALSE);
-	dm_CheckTXPowerTracking(&pHalData->odmpriv);	//trigger thermal meter
+	//dm_CheckTXPowerTracking(&pHalData->odmpriv);	//trigger thermal meter
 	
 	PHY_SetRFPathSwitch(pAdapter, 1/*pHalData->bDefaultAntenna*/); //default use Main
 	
@@ -568,9 +564,6 @@ MPT_InitializeAdapter(
 	rtw_write16(pAdapter, 0x870, 0x300);
 	rtw_write16(pAdapter, 0x860, 0x110);
 
-	if (pAdapter->registrypriv.mp_mode == 1)
-		pmlmepriv->fw_state = WIFI_MP_STATE;
-
 	return	rtStatus;
 }
 
@@ -681,9 +674,9 @@ static void disable_dm(PADAPTER padapter)
 #endif
 	Switch_DM_Func(padapter, DYNAMIC_RF_CALIBRATION, _TRUE);
 
-#ifdef CONFIG_BT_COEXIST
-	rtw_btcoex_Switch(padapter, 0);
-#endif
+//#ifdef CONFIG_BT_COEXIST
+//	rtw_btcoex_Switch(padapter, 0); //remove for BT MP Down.
+//#endif
 }
 
 
@@ -693,7 +686,6 @@ void MPT_PwrCtlDM(PADAPTER padapter, u32 bstart)
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	PDM_ODM_T		pDM_Odm = &pHalData->odmpriv;
 
-	//Switch_DM_Func(padapter, DYNAMIC_RF_CALIBRATION, bstart);
 	if (bstart==1){
 		DBG_871X("in MPT_PwrCtlDM start \n");		
 		Switch_DM_Func(padapter, DYNAMIC_RF_TX_PWR_TRACK, _TRUE);
@@ -702,6 +694,9 @@ void MPT_PwrCtlDM(PADAPTER padapter, u32 bstart)
 		pdmpriv->TxPowerTrackControl = _TRUE;
 		pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = _TRUE;
 		padapter->mppriv.mp_dm =1;
+		odm_TXPowerTrackingInit(pDM_Odm);
+		ODM_ClearTxPowerTrackingState(pDM_Odm);
+		
 	}else{
 		DBG_871X("in MPT_PwrCtlDM stop \n");
 		disable_dm(padapter);
@@ -709,6 +704,15 @@ void MPT_PwrCtlDM(PADAPTER padapter, u32 bstart)
 		pdmpriv->TxPowerTrackControl = _FALSE;
 		pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = _FALSE;
 		padapter->mppriv.mp_dm = 0;
+		{
+			TXPWRTRACK_CFG	c;
+			u1Byte	chnl =0 ;
+		
+			ConfigureTxpowerTrack(pDM_Odm, &c);
+			ODM_ClearTxPowerTrackingState(pDM_Odm);
+			(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, ODM_RF_PATH_A, chnl);
+			(*c.ODM_TxPwrTrackSetPwr)(pDM_Odm, BBSWING, ODM_RF_PATH_B, chnl);
+		}
 	}
 		
 }
@@ -726,9 +730,7 @@ u32 mp_join(PADAPTER padapter,u8 mode)
 	struct mp_priv *pmppriv = &padapter->mppriv;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
-	_adapter				*pbuddyadapter = padapter->pbuddy_adapter;
-	struct mlme_priv *pbuddymlmepriv = &pbuddyadapter->mlmepriv;
-	
+
 	// 1. initialize a new WLAN_BSSID_EX
 	_rtw_memset(&bssid, 0, sizeof(WLAN_BSSID_EX));
 	DBG_8192C("%s ,pmppriv->network_macaddr=%x %x %x %x %x %x \n",__func__,
@@ -759,21 +761,18 @@ u32 mp_join(PADAPTER padapter,u8 mode)
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
-	//if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
-	//		goto end_of_mp_start_test;
-#if 0
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+		goto end_of_mp_start_test;
+
 	//init mp_start_test status
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
-			rtw_disassoc_cmd(padapter, 0, _TRUE);
+		rtw_disassoc_cmd(padapter, 500, _TRUE);
 		rtw_indicate_disconnect(padapter);
 		rtw_free_assoc_resources(padapter, 1);
 	}
-	rtw_msleep_os(500);
-
 	pmppriv->prev_fw_state = get_fwstate(pmlmepriv);
-	if (padapter->registrypriv.mp_mode == 1)
-		pmlmepriv->fw_state = WIFI_MP_STATE;
-
+	pmlmepriv->fw_state = WIFI_MP_STATE;
+#if 0
 	if (pmppriv->mode == _LOOPBOOK_MODE_) {
 		set_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE); //append txdesc
 		RT_TRACE(_module_mp_, _drv_notice_, ("+start mp in Lookback mode\n"));
@@ -781,11 +780,8 @@ u32 mp_join(PADAPTER padapter,u8 mode)
 		RT_TRACE(_module_mp_, _drv_notice_, ("+start mp in normal mode\n"));
 	}
 #endif
-
 	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
-	set_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
 
-	#if 1
 	//3 2. create a new psta for mp driver
 	//clear psta in the cur_network, if any
 	psta = rtw_get_stainfo(&padapter->stapriv, tgt_network->network.MacAddress);
@@ -798,7 +794,7 @@ u32 mp_join(PADAPTER padapter,u8 mode)
 		res = _FAIL;
 		goto end_of_mp_start_test;
 	}
-	#endif	
+	set_fwstate(pmlmepriv,WIFI_ADHOC_MASTER_STATE);
 	//3 3. join psudo AdHoc
 	tgt_network->join_res = 1;
 	tgt_network->aid = psta->aid = 1;
@@ -806,31 +802,32 @@ u32 mp_join(PADAPTER padapter,u8 mode)
 
 	rtw_indicate_connect(padapter);
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+	set_fwstate(pmlmepriv,_FW_LINKED);
 
 end_of_mp_start_test:
 
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
-		if(1) //(res == _SUCCESS)
+	if(1) //(res == _SUCCESS)
 	{
 		// set MSR to WIFI_FW_ADHOC_STATE
-			if( mode==WIFI_FW_ADHOC_STATE ){
+		if( mode==WIFI_FW_ADHOC_STATE ){
 
-		val8 = rtw_read8(padapter, MSR) & 0xFC; // 0x0102
-		val8 |= WIFI_FW_ADHOC_STATE;
-		rtw_write8(padapter, MSR, val8); // Link in ad hoc network
-			} 
-			else {
-				Set_MSR(padapter, WIFI_FW_STATION_STATE);
+			val8 = rtw_read8(padapter, MSR) & 0xFC; // 0x0102
+			val8 |= WIFI_FW_ADHOC_STATE;
+			rtw_write8(padapter, MSR, val8); // Link in ad hoc network
+		} 
+		else {
+			Set_MSR(padapter, WIFI_FW_STATION_STATE);
 
-				DBG_8192C("%s , pmppriv->network_macaddr =%x %x %x %x %x %x\n",__func__,
-								pmppriv->network_macaddr[0],pmppriv->network_macaddr[1],pmppriv->network_macaddr[2],pmppriv->network_macaddr[3],pmppriv->network_macaddr[4],pmppriv->network_macaddr[5]);
+			DBG_8192C("%s , pmppriv->network_macaddr =%x %x %x %x %x %x\n",__func__,
+						pmppriv->network_macaddr[0],pmppriv->network_macaddr[1],pmppriv->network_macaddr[2],pmppriv->network_macaddr[3],pmppriv->network_macaddr[4],pmppriv->network_macaddr[5]);
 
-				rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pmppriv->network_macaddr);
-			}
+			rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pmppriv->network_macaddr);
 		}
-		pmlmepriv->fw_state = WIFI_MP_STATE;
-			return res;
+	}
+
+	return res;
 }
 //This function initializes the DUT to the MP test mode
 s32 mp_start_test(PADAPTER padapter)
@@ -1268,7 +1265,7 @@ static thread_return mp_xmit_packet_thread(thread_context context)
 				goto exit;
 			}
 			else {
-				rtw_usleep_os(100);
+				rtw_usleep_os(10);
 				continue;
 			}
 		}
@@ -1276,7 +1273,7 @@ static thread_return mp_xmit_packet_thread(thread_context context)
 		_rtw_memcpy(&(pxmitframe->attrib), &(pmptx->attrib), sizeof(struct pkt_attrib));
 
 		
-		rtw_udelay_os(padapter->mppriv.pktInterval);
+		rtw_usleep_os(padapter->mppriv.pktInterval);
 		dump_mpframe(padapter, pxmitframe);
 		
 		pmptx->sended++;
@@ -1357,7 +1354,7 @@ void fill_tx_desc_8188e(PADAPTER padapter)
 	u32	pkt_size = pattrib->last_txcmdsz;
 	s32 bmcast = IS_MCAST(pattrib->ra);
 // offset 0
-#if !defined(CONFIG_RTL8188E_SDIO)
+#if !defined(CONFIG_RTL8188E_SDIO) && !defined(CONFIG_PCI_HCI)
 	desc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
 	desc->txdw0 |= cpu_to_le32(pkt_size & 0x0000FFFF); // packet size
 	desc->txdw0 |= cpu_to_le32(((TXDESC_SIZE + OFFSET_SZ) << OFFSET_SHT) & 0x00FF0000); //32 bytes for TX Desc
@@ -1468,8 +1465,15 @@ void fill_tx_desc_8192e(PADAPTER padapter)
 		
 	offset = TXDESC_SIZE + OFFSET_SZ;		
 	
+	SET_TX_DESC_OFFSET_92E(pDesc, offset);
+
+	#if defined(CONFIG_PCI_HCI) //8192EE
+	SET_TX_DESC_OFFSET_92E(pDesc, offset+8); //work around
+	SET_TX_DESC_PKT_OFFSET_92E(pDesc, 0); /* 8192EE pkt_offset is 0 */
+	#else //8192EU 8192ES
 	SET_TX_DESC_OFFSET_92E(pDesc, offset);
 	SET_TX_DESC_PKT_OFFSET_92E(pDesc, 1);
+	#endif
 		
 	if (bmcast) {
 		SET_TX_DESC_BMC_92E(pDesc, 1);
@@ -1483,7 +1487,8 @@ void fill_tx_desc_8192e(PADAPTER padapter)
 	//SET_TX_DESC_QUEUE_SEL_8812(pDesc,  QSLT_MGNT);
 		
 	if (!pattrib->qos_en) {
-		SET_TX_DESC_HWSEQ_SEL_92E(pDesc, 1); // Hw set sequence number
+		SET_TX_DESC_EN_HWSEQ_92E(pDesc, 1);// Hw set sequence number
+		SET_TX_DESC_HWSEQ_SEL_92E(pDesc, pattrib->hw_ssn_sel);
 	} else {
 		SET_TX_DESC_SEQ_92E(pDesc, pattrib->seqnum);
 	}
@@ -1507,48 +1512,47 @@ void fill_tx_desc_8192e(PADAPTER padapter)
 #if defined(CONFIG_RTL8723B)
 void fill_tx_desc_8723b(PADAPTER padapter)
 {
-
 	struct mp_priv *pmp_priv = &padapter->mppriv;
 	struct pkt_attrib *pattrib = &(pmp_priv->tx.attrib);
-	PTXDESC_8723B ptxdesc = (PTXDESC_8723B)&(pmp_priv->tx.desc);
-	u8 descRate;
-	
-	ptxdesc->bk = 1;
-	ptxdesc->macid = pattrib->mac_id;
-	ptxdesc->qsel = pattrib->qsel;
+	u8 *ptxdesc = pmp_priv->tx.desc;
 
-	ptxdesc->rate_id = pattrib->raid;
-	ptxdesc->seq = pattrib->seqnum;
-	ptxdesc->en_hwseq = 1;
-	ptxdesc->userate = 1;
-	ptxdesc->disdatafb = 1;
+	SET_TX_DESC_AGG_BREAK_8723B(ptxdesc, 1);
+	SET_TX_DESC_MACID_8723B(ptxdesc, pattrib->mac_id);
+	SET_TX_DESC_QUEUE_SEL_8723B(ptxdesc, pattrib->qsel);
 
-	if( pmp_priv->preamble ){
-		if (pmp_priv->rateidx <=  MPT_RATE_54M)
-			ptxdesc->data_short = 1;
-	}
-	if (pmp_priv->bandwidth == CHANNEL_WIDTH_40)
-		ptxdesc->data_bw = 1;
+	SET_TX_DESC_RATE_ID_8723B(ptxdesc, pattrib->raid);
+	SET_TX_DESC_SEQ_8723B(ptxdesc, pattrib->seqnum);
+	SET_TX_DESC_HWSEQ_EN_8723B(ptxdesc, 1);
+	SET_TX_DESC_USE_RATE_8723B(ptxdesc, 1);
+	SET_TX_DESC_DISABLE_FB_8723B(ptxdesc, 1);
+
+	if (pmp_priv->preamble)
+		if (pmp_priv->rateidx <=  MPT_RATE_54M) {
+			SET_TX_DESC_DATA_SHORT_8723B(ptxdesc, 1);
+		}
 
-	ptxdesc->datarate = pmp_priv->rateidx;
+	if (pmp_priv->bandwidth == CHANNEL_WIDTH_40) {
+		SET_TX_DESC_DATA_BW_8723B(ptxdesc, 1);
+	}
 
-	ptxdesc->data_ratefb_lmt = 0x1F;
-	ptxdesc->rts_ratefb_lmt = 0xF;
+	SET_TX_DESC_TX_RATE_8723B(ptxdesc, pmp_priv->rateidx);
 
+	SET_TX_DESC_DATA_RATE_FB_LIMIT_8723B(ptxdesc, 0x1F);
+	SET_TX_DESC_RTS_RATE_FB_LIMIT_8723B(ptxdesc, 0xF);
 }
 #endif
 
 static void Rtw_MPSetMacTxEDCA(PADAPTER padapter)
 {
 
-	rtw_write32(padapter, 0x508 , 0x00a43f); //Disable EDCA BE Txop for MP pkt tx adjust Packet interval
+	rtw_write32(padapter, 0x508 , 0x00a422); //Disable EDCA BE Txop for MP pkt tx adjust Packet interval
 	//DBG_871X("%s:write 0x508~~~~~~ 0x%x\n", __func__,rtw_read32(padapter, 0x508));
 	PHY_SetMacReg(padapter, 0x458 ,bMaskDWord , 0x0);
 	//DBG_8192C("%s()!!!!! 0x460 = 0x%x\n" ,__func__,PHY_QueryBBReg(padapter, 0x460, bMaskDWord));
 	PHY_SetMacReg(padapter, 0x460 ,bMaskLWord , 0x0);//fast EDCA queue packet interval & time out vaule
-	PHY_SetMacReg(padapter, ODM_EDCA_VO_PARAM ,bMaskLWord , 0x431C);
-	PHY_SetMacReg(padapter, ODM_EDCA_BE_PARAM ,bMaskLWord , 0x431C);
-	PHY_SetMacReg(padapter, ODM_EDCA_BK_PARAM ,bMaskLWord , 0x431C);
+	//PHY_SetMacReg(padapter, ODM_EDCA_VO_PARAM ,bMaskLWord , 0x431C);
+	//PHY_SetMacReg(padapter, ODM_EDCA_BE_PARAM ,bMaskLWord , 0x431C);
+	//PHY_SetMacReg(padapter, ODM_EDCA_BK_PARAM ,bMaskLWord , 0x431C);
 	DBG_8192C("%s()!!!!! 0x460 = 0x%x\n" ,__func__,PHY_QueryBBReg(padapter, 0x460, bMaskDWord));
 
 }
@@ -1665,16 +1669,18 @@ void SetPacketTx(PADAPTER padapter)
 	if(pmp_priv->TXradomBuffer == NULL)
 	{
 		DBG_871X("mp create random buffer fail!\n");
+		goto exit;
 	}
-	else
-	{
-		for(i=0;i<4096;i++)
-			pmp_priv->TXradomBuffer[i] = rtw_random32() %0xFF;
-	}
+	
+	
+	for(i=0;i<4096;i++)
+		pmp_priv->TXradomBuffer[i] = rtw_random32() %0xFF;
+	
 	//startPlace = (u32)(rtw_random32() % 3450);
 	_rtw_memcpy(ptr, pmp_priv->TXradomBuffer,pkt_end - ptr);
 	//_rtw_memset(ptr, payload, pkt_end - ptr);
 	rtw_mfree(pmp_priv->TXradomBuffer,4096);
+	
 	//3 6. start thread
 #ifdef PLATFORM_LINUX
 	pmp_priv->tx.PktTxThread = kthread_run(mp_xmit_packet_thread, pmp_priv, "RTW_MP_THREAD");
@@ -1694,7 +1700,8 @@ void SetPacketTx(PADAPTER padapter)
 #endif
 
 	Rtw_MPSetMacTxEDCA(padapter);
-
+exit:
+	return;
 }
 
 void SetPacketRx(PADAPTER pAdapter, u8 bStartRx)
@@ -1795,7 +1802,7 @@ static u32 rtw_GetPSDData(PADAPTER pAdapter, u32 point)
 {
 	u32 psd_val=0;
 	
-#if defined(CONFIG_RTL8812A) //MP PSD for 8812A	
+#if defined(CONFIG_RTL8812A)||defined(CONFIG_RTL8821A) //MP PSD for 8812A	
 	u16 psd_reg = 0x910;
 	u16 psd_regL= 0xF44;
 	
@@ -1881,7 +1888,7 @@ u32 mp_query_psd(PADAPTER pAdapter, u8 *data)
 }
 
 
-
+#if 0
 void _rtw_mp_xmit_priv (struct xmit_priv *pxmitpriv)
 {
 	   int i,res;
@@ -1948,7 +1955,7 @@ void _rtw_mp_xmit_priv (struct xmit_priv *pxmitpriv)
 		pxmitbuf->padapter = padapter;
 		pxmitbuf->buf_tag = XMITBUF_MGNT;
 
-		if((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,max_xmit_extbuf_size + XMITBUF_ALIGN_SZ, _FALSE)) == _FAIL) {
+		if((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,max_xmit_extbuf_size + XMITBUF_ALIGN_SZ, _TRUE)) == _FAIL) {
 			res= _FAIL;
 			goto exit;
 		}
@@ -1973,7 +1980,7 @@ void _rtw_mp_xmit_priv (struct xmit_priv *pxmitpriv)
 exit:
 	;
 }
-
+#endif
 
 
 ULONG getPowerDiffByRate8188E(
@@ -2195,8 +2202,7 @@ mpt_ProQueryCalTxPower_8188E(
 		CurrChannel = 1;
 	}	
 	
-	if( pMptCtx->MptRateIndex >= MPT_RATE_1M &&
-		pMptCtx->MptRateIndex <= MPT_RATE_11M )
+	if(pMptCtx->MptRateIndex <= MPT_RATE_11M )
 	{
 		TxPower = pHalData->Index24G_CCK_Base[rf_path][index];	
 	}
@@ -2240,8 +2246,7 @@ mpt_ProQueryCalTxPower_8188E(
 #endif
 
 	// 2012/11/02 Awk: add power limit mechansim
-	if( pMptCtx->MptRateIndex >= MPT_RATE_1M &&
-		pMptCtx->MptRateIndex <= MPT_RATE_11M )
+	if( pMptCtx->MptRateIndex <= MPT_RATE_11M )
 	{
 		rate = MGN_1M;
 	}
@@ -2272,72 +2277,141 @@ mpt_ProQueryCalTxPower_8188E(
 	return TxPower; 
 }
 
-u8 MptToMgntRate(u32 	MptRateIdx)
+
+u8 
+MptToMgntRate(
+	IN	ULONG	MptRateIdx
+	)
 {
 // Mapped to MGN_XXX defined in MgntGen.h
 	switch (MptRateIdx) 
 	{
 		/* CCK rate. */
-		case	MPT_RATE_1M:			return 2;	
-		case	MPT_RATE_2M:			return 4;	
-		case	MPT_RATE_55M:			return 11;	
-		case	MPT_RATE_11M:			return 22;	
-	
-		/* OFDM rate. */
-		case	MPT_RATE_6M:			return 12;	
-		case	MPT_RATE_9M:			return 18;	
-		case	MPT_RATE_12M:			return 24;	
-		case	MPT_RATE_18M:			return 36;	
-		case	MPT_RATE_24M:			return 48;		
-		case	MPT_RATE_36M:			return 72;	
-		case	MPT_RATE_48M:			return 96;	
-		case	MPT_RATE_54M:			return 108; 
-	
-		/* HT rate. */
-		case	MPT_RATE_MCS0:			return 0x80;
-		case	MPT_RATE_MCS1:			return 0x81;
-		case	MPT_RATE_MCS2:			return 0x82;
-		case	MPT_RATE_MCS3:			return 0x83;
-		case	MPT_RATE_MCS4:			return 0x84;
-		case	MPT_RATE_MCS5:			return 0x85;
-		case	MPT_RATE_MCS6:			return 0x86;
-		case	MPT_RATE_MCS7:			return 0x87;
-		case	MPT_RATE_MCS8:			return 0x88;
-		case	MPT_RATE_MCS9:			return 0x89;
-		case	MPT_RATE_MCS10: 		return 0x8A;
-		case	MPT_RATE_MCS11: 		return 0x8B;
-		case	MPT_RATE_MCS12: 		return 0x8C;
-		case	MPT_RATE_MCS13: 		return 0x8D;
-		case	MPT_RATE_MCS14: 		return 0x8E;
-		case	MPT_RATE_MCS15: 		return 0x8F;
-
-		/* VHT rate. */
-		case	MPT_RATE_VHT1SS_MCS0:	return 0x90;
-		case	MPT_RATE_VHT1SS_MCS1:	return 0x91;
-		case	MPT_RATE_VHT1SS_MCS2:	return 0x92;
-		case	MPT_RATE_VHT1SS_MCS3:	return 0x93;
-		case	MPT_RATE_VHT1SS_MCS4:	return 0x94;
-		case	MPT_RATE_VHT1SS_MCS5:	return 0x95;
-		case	MPT_RATE_VHT1SS_MCS6:	return 0x96;
-		case	MPT_RATE_VHT1SS_MCS7:	return 0x97;
-		case	MPT_RATE_VHT1SS_MCS8:	return 0x98;
-		case	MPT_RATE_VHT1SS_MCS9:	return 0x99;
-		case	MPT_RATE_VHT2SS_MCS0:	return 0x9A;
-		case	MPT_RATE_VHT2SS_MCS1:	return 0x9B;
-		case	MPT_RATE_VHT2SS_MCS2:	return 0x9C;
-		case	MPT_RATE_VHT2SS_MCS3:	return 0x9D;
-		case	MPT_RATE_VHT2SS_MCS4:	return 0x9E;
-		case	MPT_RATE_VHT2SS_MCS5:	return 0x9F;
-		case	MPT_RATE_VHT2SS_MCS6:	return 0xA0;
-		case	MPT_RATE_VHT2SS_MCS7:	return 0xA1;
-		case	MPT_RATE_VHT2SS_MCS8:	return 0xA2;
-		case	MPT_RATE_VHT2SS_MCS9:	return 0xA3;
+		case	MPT_RATE_1M:			return MGN_1M;		
+		case	MPT_RATE_2M:			return MGN_2M;		
+		case	MPT_RATE_55M:			return MGN_5_5M;	
+		case	MPT_RATE_11M:			return MGN_11M; 	
+											   
+		/* OFDM rate. */					   
+		case	MPT_RATE_6M:			return MGN_6M; 
+		case	MPT_RATE_9M:			return MGN_9M; 
+		case	MPT_RATE_12M:			return MGN_12M;
+		case	MPT_RATE_18M:			return MGN_18M;
+		case	MPT_RATE_24M:			return MGN_24M; 	
+		case	MPT_RATE_36M:			return MGN_36M;
+		case	MPT_RATE_48M:			return MGN_48M;
+		case	MPT_RATE_54M:			return MGN_54M;
+											   
+		/* HT rate. */						   
+		case	MPT_RATE_MCS0:			return MGN_MCS0; 
+		case	MPT_RATE_MCS1:			return MGN_MCS1; 
+		case	MPT_RATE_MCS2:			return MGN_MCS2; 
+		case	MPT_RATE_MCS3:			return MGN_MCS3; 
+		case	MPT_RATE_MCS4:			return MGN_MCS4;	
+		case	MPT_RATE_MCS5:			return MGN_MCS5;	
+		case	MPT_RATE_MCS6:			return MGN_MCS6;	
+		case	MPT_RATE_MCS7:			return MGN_MCS7;	
+		case	MPT_RATE_MCS8:			return MGN_MCS8;	
+		case	MPT_RATE_MCS9:			return MGN_MCS9;	
+		case	MPT_RATE_MCS10: 		return MGN_MCS10;	
+		case	MPT_RATE_MCS11: 		return MGN_MCS11;	
+		case	MPT_RATE_MCS12: 		return MGN_MCS12;	
+		case	MPT_RATE_MCS13: 		return MGN_MCS13;	
+		case	MPT_RATE_MCS14: 		return MGN_MCS14;	
+		case	MPT_RATE_MCS15: 		return MGN_MCS15;	
+		case	MPT_RATE_MCS16: 		return MGN_MCS16;
+		case	MPT_RATE_MCS17: 		return MGN_MCS17;
+		case	MPT_RATE_MCS18: 		return MGN_MCS18;
+		case	MPT_RATE_MCS19: 		return MGN_MCS19;
+		case	MPT_RATE_MCS20: 		return MGN_MCS20;
+		case	MPT_RATE_MCS21: 		return MGN_MCS21;
+		case	MPT_RATE_MCS22: 		return MGN_MCS22;
+		case	MPT_RATE_MCS23: 		return MGN_MCS23;
+		case	MPT_RATE_MCS24: 		return MGN_MCS24;
+		case	MPT_RATE_MCS25: 		return MGN_MCS25;
+		case	MPT_RATE_MCS26: 		return MGN_MCS26;
+		case	MPT_RATE_MCS27: 		return MGN_MCS27;
+		case	MPT_RATE_MCS28: 		return MGN_MCS28;
+		case	MPT_RATE_MCS29: 		return MGN_MCS29;
+		case	MPT_RATE_MCS30: 		return MGN_MCS30;
+		case	MPT_RATE_MCS31: 		return MGN_MCS31;
+											   
+		/* VHT rate. */ 					   
+		case	MPT_RATE_VHT1SS_MCS0:	return MGN_VHT1SS_MCS0;
+		case	MPT_RATE_VHT1SS_MCS1:	return MGN_VHT1SS_MCS1;
+		case	MPT_RATE_VHT1SS_MCS2:	return MGN_VHT1SS_MCS2;
+		case	MPT_RATE_VHT1SS_MCS3:	return MGN_VHT1SS_MCS3;
+		case	MPT_RATE_VHT1SS_MCS4:	return MGN_VHT1SS_MCS4;
+		case	MPT_RATE_VHT1SS_MCS5:	return MGN_VHT1SS_MCS5;
+		case	MPT_RATE_VHT1SS_MCS6:	return MGN_VHT1SS_MCS6;
+		case	MPT_RATE_VHT1SS_MCS7:	return MGN_VHT1SS_MCS7;
+		case	MPT_RATE_VHT1SS_MCS8:	return MGN_VHT1SS_MCS8;
+		case	MPT_RATE_VHT1SS_MCS9:	return MGN_VHT1SS_MCS9;
+		case	MPT_RATE_VHT2SS_MCS0:	return MGN_VHT2SS_MCS0; 
+		case	MPT_RATE_VHT2SS_MCS1:	return MGN_VHT2SS_MCS1; 
+		case	MPT_RATE_VHT2SS_MCS2:	return MGN_VHT2SS_MCS2; 
+		case	MPT_RATE_VHT2SS_MCS3:	return MGN_VHT2SS_MCS3; 
+		case	MPT_RATE_VHT2SS_MCS4:	return MGN_VHT2SS_MCS4; 
+		case	MPT_RATE_VHT2SS_MCS5:	return MGN_VHT2SS_MCS5; 
+		case	MPT_RATE_VHT2SS_MCS6:	return MGN_VHT2SS_MCS6; 
+		case	MPT_RATE_VHT2SS_MCS7:	return MGN_VHT2SS_MCS7; 
+		case	MPT_RATE_VHT2SS_MCS8:	return MGN_VHT2SS_MCS8; 
+		case	MPT_RATE_VHT2SS_MCS9:	return MGN_VHT2SS_MCS9; 
+		case	MPT_RATE_VHT3SS_MCS0:	return MGN_VHT3SS_MCS0; 
+		case	MPT_RATE_VHT3SS_MCS1:	return MGN_VHT3SS_MCS1; 
+		case	MPT_RATE_VHT3SS_MCS2:	return MGN_VHT3SS_MCS2; 
+		case	MPT_RATE_VHT3SS_MCS3:	return MGN_VHT3SS_MCS3; 
+		case	MPT_RATE_VHT3SS_MCS4:	return MGN_VHT3SS_MCS4; 
+		case	MPT_RATE_VHT3SS_MCS5:	return MGN_VHT3SS_MCS5; 
+		case	MPT_RATE_VHT3SS_MCS6:	return MGN_VHT3SS_MCS6; 
+		case	MPT_RATE_VHT3SS_MCS7:	return MGN_VHT3SS_MCS7; 
+		case	MPT_RATE_VHT3SS_MCS8:	return MGN_VHT3SS_MCS8; 
+		case	MPT_RATE_VHT3SS_MCS9:	return MGN_VHT3SS_MCS9; 
+		case	MPT_RATE_VHT4SS_MCS0:	return MGN_VHT4SS_MCS0; 
+		case	MPT_RATE_VHT4SS_MCS1:	return MGN_VHT4SS_MCS1; 
+		case	MPT_RATE_VHT4SS_MCS2:	return MGN_VHT4SS_MCS2; 
+		case	MPT_RATE_VHT4SS_MCS3:	return MGN_VHT4SS_MCS3; 
+		case	MPT_RATE_VHT4SS_MCS4:	return MGN_VHT4SS_MCS4; 
+		case	MPT_RATE_VHT4SS_MCS5:	return MGN_VHT4SS_MCS5; 
+		case	MPT_RATE_VHT4SS_MCS6:	return MGN_VHT4SS_MCS6; 
+		case	MPT_RATE_VHT4SS_MCS7:	return MGN_VHT4SS_MCS7; 
+		case	MPT_RATE_VHT4SS_MCS8:	return MGN_VHT4SS_MCS8; 
+		case	MPT_RATE_VHT4SS_MCS9:	return MGN_VHT4SS_MCS9; 
 		
-		case	MPT_RATE_LAST:// fully automatic
-		default:		
-			DBG_8192C("<===MptToMgntRate(), Invalid Rate: %d!!\n", MptRateIdx);
-			return 0x0;
+		case	MPT_RATE_LAST:	// fully automatiMGN_VHT2SS_MCS1;	
+		default:					  
+			DBG_871X("<===MptToMgntRate(), Invalid Rate: %d!!\n", MptRateIdx);
+			return 0x0; 					   
+	}										   
+}											   
+
+u8 rtw_mpRateParseFunc(PADAPTER pAdapter, u8 *targetStr)
+{
+	u16 i=0;
+ 	u8* rateindex_Array[] = { "1M","2M","5.5M","11M","6M","9M","12M","18M","24M","36M","48M","54M",
+ 								"HTMCS0","HTMCS1","HTMCS2","HTMCS3","HTMCS4","HTMCS5","HTMCS6","HTMCS7",
+ 								"HTMCS8","HTMCS9","HTMCS10","HTMCS11","HTMCS12","HTMCS13","HTMCS14","HTMCS15",
+ 								"HTMCS16","HTMCS17","HTMCS18","HTMCS19","HTMCS20","HTMCS21","HTMCS22","HTMCS23",
+ 								"HTMCS24","HTMCS25","HTMCS26","HTMCS27","HTMCS28","HTMCS29","HTMCS30","HTMCS31",
+ 								"VHT1MCS0","VHT1MCS1","VHT1MCS2","VHT1MCS3","VHT1MCS4","VHT1MCS5","VHT1MCS6","VHT1MCS7","VHT1MCS8","VHT1MCS9",
+ 								"VHT2MCS0","VHT2MCS1","VHT2MCS2","VHT2MCS3","VHT2MCS4","VHT2MCS5","VHT2MCS6","VHT2MCS7","VHT2MCS8","VHT2MCS9",
+ 								"VHT3MCS0","VHT3MCS1","VHT3MCS2","VHT3MCS3","VHT3MCS4","VHT3MCS5","VHT3MCS6","VHT3MCS7","VHT3MCS8","VHT3MCS9",
+ 								"VHT4MCS0","VHT4MCS1","VHT4MCS2","VHT4MCS3","VHT4MCS4","VHT4MCS5","VHT4MCS6","VHT4MCS7","VHT4MCS8","VHT4MCS9"};
+
+	for(i=0;i<=83;i++){	
+		if(strcmp(targetStr, rateindex_Array[i]) == 0){
+			DBG_871X("%s , index = %d \n",__func__ ,i);
+			return i;
+		}
 	}
+	
+	printk("%s ,please input a Data RATE String as:",__func__);
+	for(i=0;i<=83;i++){	
+		printk("%s ",rateindex_Array[i]);
+		if(i%10==0)
+			printk("\n");
+	}	
+	return _FAIL;
 }
 
 ULONG mpt_ProQueryCalTxPower(
@@ -2442,8 +2516,5 @@ void Hal_ProSetCrystalCap (PADAPTER pAdapter , u32 CrystalCap)
 		PHY_SetBBReg(pAdapter, REG_MAC_PHY_CTRL, 0xFFF000, (CrystalCap | (CrystalCap << 6)));	
 	}
 }
-
-
-
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mp_ioctl.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mp_ioctl.c
index b2c5a28aeb1c..2b4c94fbc18f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mp_ioctl.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_mp_ioctl.c
@@ -21,7 +21,7 @@
 
 #include <drv_types.h>
 #include <rtw_mp_ioctl.h>
-#include "../hal/OUTSRC/odm_precomp.h"
+#include "../hal/OUTSRC/phydm_precomp.h"
 
 //****************  oid_rtl_seg_81_85   section start ****************
 NDIS_STATUS oid_rt_wireless_mode_hdl(struct oid_par_priv *poid_par_priv)
@@ -1990,9 +1990,9 @@ NDIS_STATUS oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv *poid_par_priv)
 
 	psta = rtw_get_stainfo(&Adapter->stapriv, macaddr);
 	if (psta != NULL) {
-		_enter_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
+		//_enter_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
 		rtw_free_stainfo(Adapter, psta);
-		_exit_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
+		//_exit_critical(&(Adapter->stapriv.sta_hash_lock), &irqL);
 	}
 
 	return status;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_odm.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_odm.c
index 75beea8a2178..05063bfdf990 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_odm.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_odm.c
@@ -37,13 +37,13 @@ const char *odm_comp_str[] = {
 	/* BIT12 */"ODM_COMP_DYNAMIC_PRICCA",
 	/* BIT13 */"ODM_COMP_RXHP",
 	/* BIT14 */"ODM_COMP_MP",
-	/* BIT15 */"ODM_COMP_DYNAMIC_ATC",
-	/* BIT16 */"ODM_COMP_EDCA_TURBO",
-	/* BIT17 */"ODM_COMP_EARLY_MODE",
+	/* BIT15 */"ODM_COMP_CFO_TRACKING",
+	/* BIT16 */"ODM_COMP_ACS",
+	/* BIT17 */"PHYDM_COMP_ADAPTIVITY",
 	/* BIT18 */NULL,
 	/* BIT19 */NULL,
-	/* BIT20 */NULL,
-	/* BIT21 */NULL,
+	/* BIT20 */"ODM_COMP_EDCA_TURBO",
+	/* BIT21 */"ODM_COMP_EARLY_MODE",
 	/* BIT22 */NULL,
 	/* BIT23 */NULL,
 	/* BIT24 */"ODM_COMP_TX_PWR_TRACK",
@@ -73,14 +73,14 @@ const char *odm_ability_str[] = {
 	/* BIT11 */"ODM_BB_PSD",
 	/* BIT12 */"ODM_BB_RXHP",
 	/* BIT13 */"ODM_BB_ADAPTIVITY",
-	/* BIT14 */"ODM_BB_DYNAMIC_ATC",
-	/* BIT15 */NULL,
-	/* BIT16 */"ODM_MAC_EDCA_TURBO",
-	/* BIT17 */"ODM_MAC_EARLY_MODE",
+	/* BIT14 */"ODM_BB_CFO_TRACKING",
+	/* BIT15 */"ODM_BB_NHM_CNT",
+	/* BIT16 */"ODM_BB_PRIMARY_CCA",
+	/* BIT17 */NULL,
 	/* BIT18 */NULL,
 	/* BIT19 */NULL,
-	/* BIT20 */NULL,
-	/* BIT21 */NULL,
+	/* BIT20 */"ODM_MAC_EDCA_TURBO",
+	/* BIT21 */"ODM_MAC_EARLY_MODE",
 	/* BIT22 */NULL,
 	/* BIT23 */NULL,
 	/* BIT24 */"ODM_RF_TX_PWR_TRACK",
@@ -132,7 +132,7 @@ void rtw_odm_dbg_level_msg(void *sel, _adapter *adapter)
 	int i;
 
 	rtw_hal_get_def_var(adapter, HW_DEF_ODM_DBG_LEVEL, &dbg_level);
-	DBG_871X_SEL_NL(sel, "odm.DebugDebugLevel = %u\n", dbg_level);
+	DBG_871X_SEL_NL(sel, "odm.DebugLevel = %u\n", dbg_level);
 	for (i=0;i<RTW_ODM_DBG_LEVEL_NUM;i++) {
 		if (odm_dbg_level_str[i])
 			DBG_871X_SEL_NL(sel, "%u %s\n", i, odm_dbg_level_str[i]);
@@ -166,11 +166,102 @@ inline void rtw_odm_ability_set(_adapter *adapter, u32 ability)
 	rtw_hal_set_hwreg(adapter, HW_VAR_DM_FLAG, (u8*)&ability);
 }
 
+void rtw_odm_adaptivity_ver_msg(void *sel, _adapter *adapter)
+{
+	DBG_871X_SEL_NL(sel, "ADAPTIVITY_VERSION "ADAPTIVITY_VERSION"\n");
+}
+
+#define RTW_ADAPTIVITY_EN_DISABLE 0
+#define RTW_ADAPTIVITY_EN_ENABLE 1
+#define RTW_ADAPTIVITY_EN_AUTO 2
+
+void rtw_odm_adaptivity_en_msg(void *sel, _adapter *adapter)
+{
+	struct registry_priv *regsty = &adapter->registrypriv;
+	struct mlme_priv *mlme = &adapter->mlmepriv;
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	DM_ODM_T *odm = &hal_data->odmpriv;
+
+	DBG_871X_SEL_NL(sel, "RTW_ADAPTIVITY_EN_");
+
+	if (regsty->adaptivity_en == RTW_ADAPTIVITY_EN_DISABLE) {
+		DBG_871X_SEL(sel, "DISABLE\n");
+	} else if (regsty->adaptivity_en == RTW_ADAPTIVITY_EN_ENABLE) {
+		DBG_871X_SEL(sel, "ENABLE\n");
+	} else if (regsty->adaptivity_en == RTW_ADAPTIVITY_EN_AUTO) {
+		DBG_871X_SEL(sel, "AUTO, chplan:0x%02x, Regulation:%u,%u\n"
+			, mlme->ChannelPlan, odm->odm_Regulation2_4G, odm->odm_Regulation5G);
+	} else {
+		DBG_871X_SEL(sel, "INVALID\n");
+	}
+}
+
+#define RTW_ADAPTIVITY_MODE_NORMAL 0
+#define RTW_ADAPTIVITY_MODE_CARRIER_SENSE 1
+
+void rtw_odm_adaptivity_mode_msg(void *sel, _adapter *adapter)
+{
+	struct registry_priv *regsty = &adapter->registrypriv;
+
+	DBG_871X_SEL_NL(sel, "RTW_ADAPTIVITY_MODE_");
+
+	if (regsty->adaptivity_mode == RTW_ADAPTIVITY_MODE_NORMAL) {
+		DBG_871X_SEL(sel, "NORMAL\n");
+	} else if (regsty->adaptivity_mode == RTW_ADAPTIVITY_MODE_CARRIER_SENSE) {
+		DBG_871X_SEL(sel, "CARRIER_SENSE\n");
+	} else {
+		DBG_871X_SEL(sel, "INVALID\n");
+	}
+}
+
+#define RTW_NHM_EN_DISABLE 0
+#define RTW_NHM_EN_ENABLE 1
+
+void rtw_odm_nhm_en_msg(void *sel, _adapter *adapter)
+{
+	struct registry_priv *regsty = &adapter->registrypriv;
+
+	DBG_871X_SEL_NL(sel, "RTW_NHM_EN_");
+
+	if (regsty->nhm_en == RTW_NHM_EN_DISABLE) {
+		DBG_871X_SEL(sel, "DISABLE\n");
+	} else if (regsty->nhm_en == RTW_NHM_EN_ENABLE) {
+		DBG_871X_SEL(sel, "ENABLE\n");
+	} else {
+		DBG_871X_SEL(sel, "INVALID\n");
+	}
+}
+
+bool rtw_odm_adaptivity_needed(_adapter *adapter)
+{
+	struct registry_priv *regsty = &adapter->registrypriv;
+	struct mlme_priv *mlme = &adapter->mlmepriv;
+	bool ret = _FALSE;
+
+	if (regsty->adaptivity_en == RTW_ADAPTIVITY_EN_ENABLE
+		|| regsty->adaptivity_en == RTW_ADAPTIVITY_EN_AUTO)
+		ret = _TRUE;
+
+	if (ret == _TRUE) {
+		rtw_odm_adaptivity_ver_msg(RTW_DBGDUMP, adapter);
+		rtw_odm_adaptivity_en_msg(RTW_DBGDUMP, adapter);
+		rtw_odm_adaptivity_mode_msg(RTW_DBGDUMP, adapter);
+		rtw_odm_nhm_en_msg(RTW_DBGDUMP, adapter);
+	}
+
+	return ret;
+}
+
 void rtw_odm_adaptivity_parm_msg(void *sel, _adapter *adapter)
 {
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
 	DM_ODM_T *odm = &pHalData->odmpriv;
 
+	rtw_odm_adaptivity_ver_msg(sel, adapter);
+	rtw_odm_adaptivity_en_msg(sel, adapter);
+	rtw_odm_adaptivity_mode_msg(sel, adapter);
+	rtw_odm_nhm_en_msg(sel, adapter);
+
 	DBG_871X_SEL_NL(sel, "%10s %16s %8s %10s %11s %14s\n"
 		, "TH_L2H_ini", "TH_EDCCA_HL_diff", "IGI_Base", "ForceEDCCA", "AdapEn_RSSI", "IGI_LowerBound");
 	DBG_871X_SEL_NL(sel, "0x%-8x %-16d 0x%-6x %-10d %-11u %-14u\n"
@@ -181,6 +272,14 @@ void rtw_odm_adaptivity_parm_msg(void *sel, _adapter *adapter)
 		, odm->AdapEn_RSSI
 		, odm->IGI_LowerBound
 	);
+
+	DBG_871X_SEL_NL(sel, "%8s %9s\n", "EDCCA_ES","Adap_Flag");
+	DBG_871X_SEL_NL(sel, "%-8x %-9x \n"
+		, odm->EDCCA_enable_state
+		, odm->adaptivity_flag
+	);
+	
+	
 }
 
 void rtw_odm_adaptivity_parm_set(_adapter *adapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff,
@@ -204,4 +303,36 @@ void rtw_odm_get_perpkt_rssi(void *sel, _adapter *adapter)
 	
 	DBG_871X_SEL_NL(sel,"RxRate = %s, RSSI_A = %d(%%), RSSI_B = %d(%%)\n", 
 	HDATA_RATE(odm->RxRate), odm->RSSI_A, odm->RSSI_B);	
-}
\ No newline at end of file
+}
+
+
+void rtw_odm_acquirespinlock(_adapter *adapter,	RT_SPINLOCK_TYPE type)
+{
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	_irqL irqL;
+
+	switch(type)
+	{
+		case RT_IQK_SPINLOCK:
+			_enter_critical_bh(&pdmpriv->IQKSpinLock, &irqL);
+		default:
+			break;
+	}
+}
+
+void rtw_odm_releasespinlock(_adapter *adapter,	RT_SPINLOCK_TYPE type)
+{
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	_irqL irqL;
+
+	switch(type)
+	{
+		case RT_IQK_SPINLOCK:
+			_exit_critical_bh(&pdmpriv->IQKSpinLock, &irqL);
+		default:
+			break;
+	}
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_p2p.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_p2p.c
index f1bed6f86fc7..5f2f99c0a2cd 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_p2p.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_p2p.c
@@ -58,6 +58,11 @@ static u32 go_add_group_info_attr(struct wifidirect_info *pwdinfo, u8 *pbuf)
 
 	pdata_attr = rtw_zmalloc(MAX_P2P_IE_LEN);
 
+	if(NULL == pdata_attr){
+		DBG_871X("%s pdata_attr malloc failed \n", __FUNCTION__);
+		goto _exit;
+	}
+	
 	pstart = pdata_attr;
 	pcur = pdata_attr;
 
@@ -139,7 +144,8 @@ static u32 go_add_group_info_attr(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	}
 
 	rtw_mfree(pdata_attr, MAX_P2P_IE_LEN);
-
+	
+_exit:
 	return len;
 
 }
@@ -3455,6 +3461,8 @@ _func_exit_;
 void p2p_concurrent_handler( _adapter*	padapter )
 {
 	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);	
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	//_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	//struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
 	//struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
@@ -3495,9 +3503,12 @@ _func_enter_;
 					}
 
 					rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-					val8 = 1;
-					rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-
+					if(!check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&
+					!(pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+					{
+						val8 = 1;
+						rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
+					}
 					//	Todo: To check the value of pwdinfo->ext_listen_period is equal to 0 or not.
 					_set_timer( &pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period );
 				}
@@ -3517,8 +3528,11 @@ _func_enter_;
 				if ( pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel )
 				{
 					set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-					val8 = 0;
-					padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
+					if(!check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&!(pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+					{						
+						val8 = 0;
+						padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
+					}
 					rtw_p2p_set_state(pwdinfo, P2P_STATE_IDLE);
 					issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
 				}
@@ -3612,6 +3626,9 @@ _func_enter_;
 	pcfg80211_wdinfo->is_ro_ch = _FALSE;
 	pcfg80211_wdinfo->last_ro_ch_time = rtw_get_current_time();
 
+	if (pcfg80211_wdinfo->not_indic_ro_ch_exp == _TRUE)
+		return;
+
 	DBG_871X("cfg80211_remain_on_channel_expired, ch=%d, bw=%d, offset=%d\n", 
 		rtw_get_oper_ch(padapter), rtw_get_oper_bw(padapter), rtw_get_oper_choffset(padapter));
 
@@ -5277,10 +5294,6 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 			adapter_wdev_data(padapter)->p2p_enabled = _FALSE;
 #endif //CONFIG_IOCTL_CFG80211
 
-		if (_FAIL == rtw_pwr_wakeup(padapter)) {
-			ret = _FAIL;
-			goto exit;
-		}
 
 		//Disable P2P function
 		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -5299,6 +5312,10 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 			rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_NONE);
 			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DISABLE);
 			_rtw_memset(&pwdinfo->rx_prov_disc_info, 0x00, sizeof(struct rx_provdisc_req_info));
+
+			/* Remove profiles in wifidirect_info structure. */
+			_rtw_memset( &pwdinfo->profileinfo[ 0 ], 0x00, sizeof( struct profile_info ) * P2P_MAX_PERSISTENT_GROUP_NUM );
+			pwdinfo->profileindex = 0;
 		}
 
 		rtw_hal_set_odm_var(padapter,HAL_ODM_P2P_STATE,NULL,_FALSE);
@@ -5306,6 +5323,11 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 		rtw_hal_set_odm_var(padapter,HAL_ODM_WIFI_DISPLAY_STATE,NULL,_FALSE);
 		#endif
 
+		if (_FAIL == rtw_pwr_wakeup(padapter)) {
+			ret = _FAIL;
+			goto exit;
+		}
+
 		//Restore to initial setting.
 		update_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_pwrctrl.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_pwrctrl.c
index 7ca5f4357a4b..0a16ad5c2e3b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_pwrctrl.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_pwrctrl.c
@@ -20,7 +20,8 @@
 #define _RTW_PWRCTRL_C_
 
 #include <drv_types.h>
-
+#include <hal_data.h>
+#include <hal_com_h2c.h>
 
 int rtw_fw_ps_state(PADAPTER padapter)
 {
@@ -159,6 +160,9 @@ int ips_leave(_adapter * padapter)
 #endif //DBG_CHECK_FW_PS_STATE
 	_exit_pwrlock(&pwrpriv->lock);
 
+	if (_SUCCESS == ret)
+		ODM_DMReset(&GET_HAL_DATA(padapter)->odmpriv);
+
 #ifdef CONFIG_BT_COEXIST
 	if (_SUCCESS == ret)
 		rtw_btcoex_IpsNotify(padapter, IPS_NONE);
@@ -460,7 +464,7 @@ void	traffic_check_for_leave_lps(PADAPTER padapter, u8 tx, u32 tx_packets)
 #endif
 					)
 				{
-					DBG_871X("leave lps via Tx = %d\n", xmit_cnt);			
+					//DBG_871X("leave lps via Tx = %d\n", xmit_cnt);			
 					bLeaveLPS = _TRUE;
 				}
 			}
@@ -481,7 +485,7 @@ void	traffic_check_for_leave_lps(PADAPTER padapter, u8 tx, u32 tx_packets)
 #endif
 				)
 			{	
-				DBG_871X("leave lps via Rx = %d\n", pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod);	
+				//DBG_871X("leave lps via Rx = %d\n", pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod);	
 				bLeaveLPS = _TRUE;
 			}
 		}	
@@ -491,7 +495,7 @@ void	traffic_check_for_leave_lps(PADAPTER padapter, u8 tx, u32 tx_packets)
 	{
 		//DBG_871X("leave lps via %s, Tx = %d, Rx = %d \n", tx?"Tx":"Rx", pmlmepriv->LinkDetectInfo.NumTxOkInPeriod,pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod);	
 		//rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_LEAVE, 1);
-		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_LEAVE, tx?0:1);
+		rtw_lps_ctrl_wk_cmd(padapter, tx?LPS_CTRL_TX_TRAFFIC_LEAVE:LPS_CTRL_RX_TRAFFIC_LEAVE, tx?0:1);
 	}
 #endif //CONFIG_CHECK_LEAVE_LPS
 }		
@@ -604,7 +608,7 @@ _func_enter_;
 
 		// polling cpwm
 		do {
-			rtw_mdelay_os(1);
+			rtw_msleep_os(1);
 			poll_cnt++;
 			rtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_now);
 			if ((cpwm_orig ^ cpwm_now) & 0x80)
@@ -718,6 +722,141 @@ u8 PS_RDY_CHECK(_adapter * padapter)
 	return _TRUE;
 }
 
+#if defined(CONFIG_FWLPS_IN_IPS) && defined(CONFIG_PNO_SUPPORT)
+void rtw_set_fw_in_ips_mode(PADAPTER padapter, u8 enable)
+{
+	struct hal_ops *pHalFunc = &padapter->HalFunc;
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	int cnt=0;
+	u32 start_time;
+	u8 val8 = 0;
+	u8 cpwm_orig, cpwm_now;
+	u8 parm[H2C_INACTIVE_PS_LEN]={0};
+
+	if (padapter->netif_up == _FALSE) {
+		DBG_871X("%s: ERROR, netif is down\n", __func__);
+		return;
+	}
+
+	if (pHalFunc->fill_h2c_cmd == NULL) {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		return;
+	}
+
+	//u8 cmd_param; //BIT0:enable, BIT1:NoConnect32k
+	if (enable) {
+
+#ifdef CONFIG_BT_COEXIST
+		rtw_btcoex_IpsNotify(padapter, pwrpriv->ips_mode_req);
+#endif
+		//Enter IPS
+		DBG_871X("%s: issue H2C to FW when entering IPS\n", __func__);
+		parm[0] = 0x03;
+		parm[1] = 0x01;
+		parm[2] = 0x01;
+		pHalFunc->fill_h2c_cmd(padapter, //H2C_FWLPS_IN_IPS_,
+					H2C_INACTIVE_PS_,
+					H2C_INACTIVE_PS_LEN, parm);
+		//poll 0x1cc to make sure H2C command already finished by FW; MAC_0x1cc=0 means H2C done by FW.
+		do{
+			val8 = rtw_read8(padapter, REG_HMETFR);
+			cnt++;
+			DBG_871X("%s  polling REG_HMETFR=0x%x, cnt=%d \n",
+					__func__, val8, cnt);
+			rtw_mdelay_os(10);
+		}while(cnt<100 && (val8!=0));
+
+		//H2C done, enter 32k
+		if (val8 == 0) {
+			//ser rpwm to enter 32k
+			val8 = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1);
+			DBG_871X("%s: read rpwm=%02x\n", __FUNCTION__, val8);
+			val8 += 0x80;
+			val8 |= BIT(0);
+			rtw_write8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1, val8);
+			DBG_871X("%s: write rpwm=%02x\n", __FUNCTION__, val8);
+			adapter_to_pwrctl(padapter)->tog = (val8 + 0x80) & 0x80;
+			cnt = val8 = 0;
+			do {
+				val8 = rtw_read8(padapter, REG_CR);
+				cnt++;
+				DBG_871X("%s  polling 0x100=0x%x, cnt=%d \n",
+						__func__, val8, cnt);
+				DBG_871X("%s 0x08:%02x, 0x03:%02x\n",
+						__func__,
+						rtw_read8(padapter, 0x08),
+						rtw_read8(padapter, 0x03));
+				rtw_mdelay_os(10);
+			} while(cnt<20 && (val8!=0xEA));
+#ifdef DBG_CHECK_FW_PS_STATE
+			if(val8 != 0xEA) {
+				DBG_871X("MAC_1B8=0x%08x\n",
+						rtw_read32(padapter, 0x1b8));
+				DBG_871X("MAC_1C0=%08x, MAC_1C4=%08x, MAC_1C8=%08x, MAC_1CC=%08x\n",
+						rtw_read32(padapter, 0x1c0),
+						rtw_read32(padapter, 0x1c4),
+						rtw_read32(padapter, 0x1c8),
+						rtw_read32(padapter, 0x1cc));
+#endif //DBG_CHECK_FW_PS_STATE
+			} else {
+				DBG_871X("MAC_1C0=%08x, MAC_1C4=%08x, MAC_1C8=%08x, MAC_1CC=%08x\n",
+						rtw_read32(padapter, 0x1c0),
+						rtw_read32(padapter, 0x1c4),
+						rtw_read32(padapter, 0x1c8),
+						rtw_read32(padapter, 0x1cc));
+			}
+		}
+	} else {
+		//Leave IPS
+		DBG_871X("%s: Leaving IPS in FWLPS state\n", __func__);
+
+		//for polling cpwm
+		cpwm_orig = 0;
+		rtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_orig);
+
+		//ser rpwm
+		val8 = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1);
+		val8 &= 0x80;
+		val8 += 0x80;
+		val8 |= BIT(6);
+		rtw_write8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1, val8);
+		DBG_871X("%s: write rpwm=%02x\n", __FUNCTION__, val8);
+		adapter_to_pwrctl(padapter)->tog = (val8 + 0x80) & 0x80;
+
+		//do polling cpwm
+		start_time = rtw_get_current_time();
+		do {
+
+			rtw_mdelay_os(1);
+
+			rtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_now);
+			if ((cpwm_orig ^ cpwm_now) & 0x80) {
+#ifdef DBG_CHECK_FW_PS_STATE				
+				DBG_871X("%s: polling cpwm ok when leaving IPS in FWLPS state, cpwm_orig=%02x, cpwm_now=%02x, 0x100=0x%x \n"
+				, __FUNCTION__, cpwm_orig, cpwm_now, rtw_read8(padapter, REG_CR));
+#endif //DBG_CHECK_FW_PS_STATE
+				break;
+			}
+
+			if (rtw_get_passing_time_ms(start_time) > 100)
+			{
+				DBG_871X("%s: polling cpwm timeout when leaving IPS in FWLPS state\n", __FUNCTION__);
+				break;
+			}
+		} while (1);
+
+		parm[0] = 0x0;
+		parm[1] = 0x0;
+		parm[2] = 0x0;
+		pHalFunc->fill_h2c_cmd(padapter, H2C_INACTIVE_PS_,
+					H2C_INACTIVE_PS_LEN, parm);
+#ifdef CONFIG_BT_COEXIST
+		rtw_btcoex_IpsNotify(padapter, IPS_NONE);
+#endif
+	}
+}
+#endif //CONFIG_PNO_SUPPORT
+
 void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode, const char *msg)
 {
 	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
@@ -809,9 +948,10 @@ _func_enter_;
 			pwrpriv->pwr_mode = ps_mode;
 			rtw_set_rpwm(padapter, PS_STATE_S4);
 			
-#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN) || defined(CONFIG_P2P_WOWLAN)
 			if (pwrpriv->wowlan_mode == _TRUE ||
-					pwrpriv->wowlan_ap_mode == _TRUE)
+					pwrpriv->wowlan_ap_mode == _TRUE ||
+					pwrpriv->wowlan_p2p_mode == _TRUE)
 			{
 				u32 start_time, delay_ms;
 				u8 val8;
@@ -849,6 +989,9 @@ _func_enter_;
 			|| ((rtw_btcoex_IsBtControlLps(padapter) == _TRUE)
 				&& (rtw_btcoex_IsLpsOn(padapter) == _TRUE))
 #endif
+#ifdef CONFIG_P2P_WOWLAN
+			||( _TRUE == pwrpriv->wowlan_p2p_mode)
+#endif //CONFIG_P2P_WOWLAN
 			)
 		{
 			u8 pslv;
@@ -1015,6 +1158,13 @@ _func_enter_;
 			return;
 	}
 
+#ifdef CONFIG_P2P_PS
+	if(padapter->wdinfo.p2p_ps_mode == P2P_PS_NOA)
+	{
+		return;//supporting p2p client ps NOA via H2C_8723B_P2P_PS_OFFLOAD 
+	}
+#endif //CONFIG_P2P_PS
+
 	if (pwrpriv->bLeisurePs)
 	{
 		// Idle for a while if we connect to AP a while ago.
@@ -2148,6 +2298,7 @@ _func_enter_;
 
 	pwrctrlpriv->wowlan_mode = _FALSE;
 	pwrctrlpriv->wowlan_ap_mode = _FALSE;
+	pwrctrlpriv->wowlan_p2p_mode = _FALSE;
 
 	#ifdef CONFIG_RESUME_IN_WORKQUEUE
 	_init_workitem(&pwrctrlpriv->resume_work, resume_workitem_callback, NULL);
@@ -2159,10 +2310,15 @@ _func_enter_;
 	rtw_register_early_suspend(pwrctrlpriv);
 	#endif //CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER
 
+#ifdef CONFIG_WOWLAN
+	pwrctrlpriv->wowlan_from_cmd = _FALSE;
+#endif
 #ifdef CONFIG_PNO_SUPPORT
+	pwrctrlpriv->pno_inited = _FALSE;
 	pwrctrlpriv->pnlo_info = NULL;
 	pwrctrlpriv->pscan_info = NULL;
 	pwrctrlpriv->pno_ssid_list = NULL;
+	pwrctrlpriv->pno_in_resume = _TRUE;
 #endif
 
 _func_exit_;
@@ -2232,6 +2388,7 @@ void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv)
 {
 	// accquire system's suspend lock preventing from falliing asleep while resume in workqueue
 	//rtw_lock_suspend();
+
 	rtw_resume_lock_suspend();
 	
 	#if 1
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_recv.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_recv.c
index 186a50e0028d..a5e4e2d4a333 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_recv.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_recv.c
@@ -75,6 +75,10 @@ _func_enter_;
 
 	precvpriv->free_recvframe_cnt = NR_RECVFRAME;
 
+	precvpriv->sink_udpport = 0;
+	precvpriv->pre_rtp_rxseq = 0;
+	precvpriv->cur_rtp_rxseq = 0;
+
 	rtw_os_recv_resource_init(precvpriv, padapter);
 
 	precvpriv->pallocated_frame_buf = rtw_zvmalloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
@@ -109,7 +113,7 @@ _func_enter_;
 
 #ifdef CONFIG_USB_HCI
 
-	precvpriv->rx_pending_cnt=1;
+	ATOMIC_SET(&(precvpriv->rx_pending_cnt), 1);
 
 	_rtw_init_sema(&precvpriv->allrxreturnevt, 0);
 
@@ -606,8 +610,11 @@ union recv_frame * decryptor(_adapter *padapter,union recv_frame *precv_frame)
 	struct security_priv *psecuritypriv=&padapter->securitypriv;
 	union recv_frame *return_packet=precv_frame;
 	u32	 res=_SUCCESS;
+
 _func_enter_;
 
+	DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt);
+
 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("prxstat->decrypted=%x prxattrib->encrypt = 0x%03x\n",prxattrib->bdecrypted,prxattrib->encrypt));
 
 	if(prxattrib->encrypt>0)
@@ -653,16 +660,20 @@ _func_enter_;
 		switch(prxattrib->encrypt){
 		case _WEP40_:
 		case _WEP104_:
+			DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt_wep);
 			rtw_wep_decrypt(padapter, (u8 *)precv_frame);
 			break;
 		case _TKIP_:
+			DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt_tkip);
 			res = rtw_tkip_decrypt(padapter, (u8 *)precv_frame);
 			break;
 		case _AES_:
+			DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt_aes);
 			res = rtw_aes_decrypt(padapter, (u8 * )precv_frame);
 			break;
 #ifdef CONFIG_WAPI_SUPPORT
 		case _SMS4_:
+			DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt_wapi);
 			rtw_sms4_decrypt(padapter, (u8 * )precv_frame);
 			break;
 #endif
@@ -690,6 +701,8 @@ _func_enter_;
 		else
 #endif
 		{
+			DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt_hw);
+
 			psecuritypriv->hw_decrypted=_TRUE;
 			#ifdef DBG_RX_DECRYPTOR
 			DBG_871X("[%s] %d:prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  Setting psecuritypriv->hw_decrypted = %d\n",
@@ -700,10 +713,10 @@ _func_enter_;
 				psecuritypriv->hw_decrypted);
 
 			#endif
-
 		}
 	}
 	else {
+		DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt_unknown);
 		#ifdef DBG_RX_DECRYPTOR
 		DBG_871X("[%s] %d:prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  Setting psecuritypriv->hw_decrypted = %d\n",
 			__FUNCTION__,
@@ -1488,9 +1501,20 @@ _func_enter_;
 			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get sta_info
 			if (*psta == NULL)
 			{
-				DBG_871X("issue_deauth to the ap=" MAC_FMT " for the reason(7)\n", MAC_ARG(pattrib->bssid));
 	
-				issue_deauth(adapter, pattrib->bssid, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+				//for AP multicast issue , modify by yiwei 
+				static u32 send_issue_deauth_time=0;
+			
+				//DBG_871X("After send deauth , %u ms has elapsed.\n", rtw_get_passing_time_ms(send_issue_deauth_time));
+				
+				if(rtw_get_passing_time_ms(send_issue_deauth_time) > 10000 || send_issue_deauth_time == 0 )
+				{
+					send_issue_deauth_time = rtw_get_current_time(); 
+					
+					DBG_871X("issue_deauth to the ap=" MAC_FMT " for the reason(7)\n", MAC_ARG(pattrib->bssid));
+					
+					issue_deauth(adapter, pattrib->bssid, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+				}
 			}
 		}	
 	
@@ -1560,6 +1584,32 @@ _func_enter_;
 			goto exit;
 		}
 	}
+	else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) &&
+		     (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) )
+	{
+		DBG_871X("%s ,in WIFI_MP_STATE \n",__func__);
+
+		_rtw_memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		_rtw_memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		_rtw_memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+
+		//
+		_rtw_memcpy(pattrib->bssid,  mybssid, ETH_ALEN);
+
+
+		*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get sta_info
+		if (*psta == NULL) {
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under MP_MODE ; drop pkt\n"));
+			#ifdef DBG_RX_DROP_FRAME
+			DBG_871X("DBG_RX_DROP_FRAME %s can't get psta under WIFI_MP_STATE ; drop pkt\n", __FUNCTION__);
+			#endif
+			ret= _FAIL;
+			goto exit;
+		}
+
+	}
 	else {
 		u8 *myhwaddr = myid(&adapter->eeprompriv);
 		if (!_rtw_memcmp(pattrib->ra, myhwaddr, ETH_ALEN)) {
@@ -1725,7 +1775,7 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 						DBG_871X("no buffered packets to xmit\n");
 
 						//issue nulldata with More data bit = 0 to indicate we have no buffered packets
-						issue_nulldata_in_interrupt(padapter, psta->hwaddr);
+						issue_nulldata_in_interrupt(padapter, psta->hwaddr, 0);
 					}
 					else
 					{
@@ -2066,7 +2116,7 @@ static sint validate_80211w_mgmt(_adapter *adapter, union recv_frame *precv_fram
 				DBG_871X("%s mgmt allocate fail  !!!!!!!!!\n", __FUNCTION__);
 				goto validate_80211w_fail;
 			}
-			/*//dump the packet content before decrypt
+			/* //dump the packet content before decrypt
 			{
 				int pp;
 				printk("pattrib->pktlen = %d =>", pattrib->pkt_len);
@@ -2083,7 +2133,7 @@ static sint validate_80211w_mgmt(_adapter *adapter, union recv_frame *precv_fram
 			//remove the iv and icv length
 			pattrib->pkt_len = pattrib->pkt_len - pattrib->iv_len - pattrib->icv_len;
 			rtw_mfree(mgmt_DATA, data_len);
-			/*//print packet content after decryption
+			/* //print packet content after decryption
 			{
 				int pp;
 				printk("after decryption pattrib->pktlen = %d @@=>", pattrib->pkt_len);
@@ -2110,9 +2160,9 @@ static sint validate_80211w_mgmt(_adapter *adapter, union recv_frame *precv_fram
 			}
 			else if(BIP_ret == RTW_RX_HANDLED)
 			{
-				//DBG_871X("802.11w recv none protected packet\n");
-				//issue sa query request
-				issue_action_SA_Query(adapter, NULL, 0, 0);
+				DBG_871X("802.11w recv none protected packet\n");
+				//drop pkt, don't issue sa query request
+				//issue_action_SA_Query(adapter, NULL, 0, 0);
 				goto validate_80211w_fail;
 			}
 		}//802.11w protect
@@ -2133,9 +2183,14 @@ static sint validate_80211w_mgmt(_adapter *adapter, union recv_frame *precv_fram
 			}
 			else if(subtype == WIFI_DEAUTH || subtype == WIFI_DISASSOC)
 			{
-				DBG_871X("802.11w recv none protected packet\n");
-				//issue sa query request
-				issue_action_SA_Query(adapter, NULL, 0, 0);
+				unsigned short	reason;
+				reason = le16_to_cpu(*(unsigned short *)(ptr + WLAN_HDR_A3_LEN));
+				DBG_871X("802.11w recv none protected packet, reason=%d\n", reason);
+				if(reason == 6 || reason == 7)
+				{
+					//issue sa query request
+					issue_action_SA_Query(adapter, NULL, 0, 0);
+				}
 				goto validate_80211w_fail;
 			}
 		}
@@ -2148,6 +2203,17 @@ static sint validate_80211w_mgmt(_adapter *adapter, union recv_frame *precv_fram
 }
 #endif //CONFIG_IEEE80211W
 
+static inline void dump_rx_packet(u8 *ptr)
+{
+	int i;
+
+	DBG_871X("############################# \n");
+	for(i=0; i<64;i=i+8)
+		DBG_871X("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", *(ptr+i),
+		*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
+	DBG_871X("############################# \n");
+}
+
 sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame);
 sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 {
@@ -2180,7 +2246,6 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 
 _func_enter_;
 
-
 #ifdef CONFIG_FIND_BEST_CHANNEL
 	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
 		int ch_set_idx = rtw_ch_set_search_ch(pmlmeext->channel_set, rtw_get_oper_ch(adapter));
@@ -2214,6 +2279,7 @@ _func_enter_;
 	if(ver!=0){
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail! (ver!=0)\n"));
 		retval= _FAIL;
+		DBG_COUNTER(adapter->rx_logs.core_rx_pre_ver_err);
 		goto exit;
 	}
 
@@ -2238,46 +2304,23 @@ _func_enter_;
 {
 	u8 bDumpRxPkt;
 	rtw_hal_get_def_var(adapter, HAL_DEF_DBG_DUMP_RXPKT, &(bDumpRxPkt));
-	if(bDumpRxPkt ==1){//dump all rx packets
-		int i;
-		DBG_871X("############################# \n");
-		
-		for(i=0; i<64;i=i+8)
-			DBG_871X("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", *(ptr+i),
-			*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
-		DBG_871X("############################# \n");
-	}
-	else if(bDumpRxPkt ==2){
-		if(type== WIFI_MGT_TYPE){
-			int i;
-			DBG_871X("############################# \n");
-
-			for(i=0; i<64;i=i+8)
-				DBG_871X("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", *(ptr+i),
-				*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
-			DBG_871X("############################# \n");
-		}
-	}
-	else if(bDumpRxPkt ==3){
-		if(type== WIFI_DATA_TYPE){
-			int i;
-			DBG_871X("############################# \n");
-			
-			for(i=0; i<64;i=i+8)
-				DBG_871X("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", *(ptr+i),
-				*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
-			DBG_871X("############################# \n");
-		}
-	}
+	if (bDumpRxPkt == 1) //dump all rx packets
+		dump_rx_packet(ptr);
+	else if ((bDumpRxPkt == 2) && (type == WIFI_MGT_TYPE))
+		dump_rx_packet(ptr);
+	else if ((bDumpRxPkt == 3) && (type == WIFI_DATA_TYPE))
+		dump_rx_packet(ptr);
 }
 #endif
 	switch (type)
 	{
 		case WIFI_MGT_TYPE: //mgnt
+			DBG_COUNTER(adapter->rx_logs.core_rx_pre_mgmt);
 #ifdef CONFIG_IEEE80211W
 			if(validate_80211w_mgmt(adapter, precv_frame) == _FAIL)
 			{
 				retval = _FAIL;
+				DBG_COUNTER(padapter->rx_logs.core_rx_pre_mgmt_err_80211w);
 				break;
 			}
 #endif //CONFIG_IEEE80211W
@@ -2286,18 +2329,22 @@ _func_enter_;
 			if (retval == _FAIL)
 			{
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_mgnt_frame fail\n"));
+				DBG_COUNTER(adapter->rx_logs.core_rx_pre_mgmt_err);
 			}
 			retval = _FAIL; // only data frame return _SUCCESS
 			break;
 		case WIFI_CTRL_TYPE: //ctrl
+			DBG_COUNTER(adapter->rx_logs.core_rx_pre_ctrl);
 			retval = validate_recv_ctrl_frame(adapter, precv_frame);
 			if (retval == _FAIL)
 			{
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_ctrl_frame fail\n"));
+				DBG_COUNTER(adapter->rx_logs.core_rx_pre_ctrl_err);
 			}
 			retval = _FAIL; // only data frame return _SUCCESS
 			break;
 		case WIFI_DATA_TYPE: //data
+			DBG_COUNTER(adapter->rx_logs.core_rx_pre_data);
 #ifdef CONFIG_WAPI_SUPPORT
 			if(pattrib->qos)
 				external_len = 2;
@@ -2316,6 +2363,7 @@ _func_enter_;
 				else
 				{
 					retval = _FAIL;
+					DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_wapi_seq_err);
 					break;
 				}
 			}
@@ -2324,6 +2372,7 @@ _func_enter_;
 					if(rtw_wapi_drop_for_key_absent(adapter,GetAddr2Ptr(ptr))){
 						retval=_FAIL;
 						WAPI_TRACE(WAPI_RX,"drop for key absent for rx \n");
+						DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_wapi_key_err);
 						break;
 					}
 			}
@@ -2337,9 +2386,30 @@ _func_enter_;
 				struct recv_priv *precvpriv = &adapter->recvpriv;
 				//RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail\n"));
 				precvpriv->rx_drop++;
+				DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_err);
+			}
+			else if (retval == _SUCCESS)
+			{
+#ifdef DBG_RX_DUMP_EAP
+				u8 bDumpRxPkt;
+				u16 eth_type;
+
+				// dump eapol
+				rtw_hal_get_def_var(adapter, HAL_DEF_DBG_DUMP_RXPKT, &(bDumpRxPkt));
+				// get ether_type
+				_rtw_memcpy(&eth_type, ptr + pattrib->hdrlen + pattrib->iv_len + LLC_HEADER_SIZE, 2);
+				eth_type = ntohs((unsigned short) eth_type);
+				if ((bDumpRxPkt == 4) && (eth_type == 0x888e))
+					dump_rx_packet(ptr);
+#endif
+			}
+			else
+			{
+				DBG_COUNTER(adapter->rx_logs.core_rx_pre_data_handled);
 			}
 			break;
 		default:
+			DBG_COUNTER(adapter->rx_logs.core_rx_pre_unknown);
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail! type=0x%x\n", type));
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_871X("DBG_RX_DROP_FRAME validate_recv_data_frame fail! type=0x%x\n", type);
@@ -2451,21 +2521,32 @@ _func_enter_;
 		eth_type = 0x8712;
 		// append rx status for mp test packets
 		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2)-24);
+		if (!ptr) {
+			ret = _FAIL;
+			goto exiting;
+		}
 		_rtw_memcpy(ptr, get_rxmem(precvframe), 24);
 		ptr+=24;
 	}
 	else {
 		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+ (bsnaphdr?2:0)));
+		if (!ptr) {
+			ret = _FAIL;
+			goto exiting;
+		}
 	}
 
-	_rtw_memcpy(ptr, pattrib->dst, ETH_ALEN);
-	_rtw_memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+	if (ptr) {
+		_rtw_memcpy(ptr, pattrib->dst, ETH_ALEN);
+		_rtw_memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
 
-	if(!bsnaphdr) {
-		len = htons(len);
-		_rtw_memcpy(ptr+12, &len, 2);
+		if(!bsnaphdr) {
+			len = htons(len);
+			_rtw_memcpy(ptr+12, &len, 2);
+		}
 	}
 
+exiting:
 _func_exit_;	
 	return ret;
 
@@ -3103,10 +3184,11 @@ int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl, union rec
 
 void recv_indicatepkts_pkt_loss_cnt(struct debug_priv *pdbgpriv, u64 prev_seq, u64 current_seq);
 void recv_indicatepkts_pkt_loss_cnt(struct debug_priv *pdbgpriv, u64 prev_seq, u64 current_seq)
-{
+{
 	if(current_seq < prev_seq)
 	{
-		pdbgpriv->dbg_rx_ampdu_loss_count+= (4096 + current_seq - prev_seq);
+		pdbgpriv->dbg_rx_ampdu_loss_count+= (4096 + current_seq - prev_seq);
+
 	}
 	else
 	{
@@ -3128,6 +3210,8 @@ int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *pre
 	struct dvobj_priv *psdpriv = padapter->dvobj;
 	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
 
+	DBG_COUNTER(padapter->rx_logs.core_rx_post_indicate_in_oder);
+
 	//DbgPrint("+recv_indicatepkts_in_order\n");
 
 	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
@@ -3299,10 +3383,20 @@ int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe)
 	struct dvobj_priv *psdpriv = padapter->dvobj;
 	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
 
+	DBG_COUNTER(padapter->rx_logs.core_rx_post_indicate_reoder);
+
 	if(!pattrib->amsdu)
 	{
 		//s1.
-		wlanhdr_to_ethhdr(prframe);
+                retval = wlanhdr_to_ethhdr(prframe);
+                if (retval != _SUCCESS)
+                {
+                        RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("wlanhdr_to_ethhdr: drop pkt \n"));
+                        #ifdef DBG_RX_DROP_FRAME
+                        DBG_871X("DBG_RX_DROP_FRAME %s wlanhdr_to_ethhdr error!\n", __FUNCTION__);
+                        #endif
+                        return retval;
+                }
 
 		//if ((pattrib->qos!=1) /*|| pattrib->priority!=0 || IS_MCAST(pattrib->ra)*/
 		//	|| (pattrib->eth_type==0x0806) || (pattrib->ack_policy!=0))
@@ -3504,6 +3598,8 @@ int process_recv_indicatepkts(_adapter *padapter, union recv_frame *prframe)
 #ifdef CONFIG_80211N_HT
 
 	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
+	
+	DBG_COUNTER(padapter->rx_logs.core_rx_post_indicate);
 
 #ifdef CONFIG_TDLS
 	if( (phtpriv->ht_option==_TRUE) ||
@@ -3601,19 +3697,98 @@ int validate_mp_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 }
 #endif
 
+static sint MPwlanhdr_to_ethhdr ( union recv_frame *precvframe)
+{
+	sint	rmv_len;
+	u16 eth_type, len;
+	u8	bsnaphdr;
+	u8	*psnap_type;
+	struct ieee80211_snap_hdr	*psnap;
+	
+	sint ret=_SUCCESS;
+	_adapter			*adapter =precvframe->u.hdr.adapter;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	u8	*ptr = get_recvframe_data(precvframe) ; // point to frame_ctrl field
+	struct rx_pkt_attrib *pattrib = & precvframe->u.hdr.attrib;
+
+_func_enter_;
+
+	if(pattrib->encrypt){
+		recvframe_pull_tail(precvframe, pattrib->icv_len);	
+	}
+
+	psnap=(struct ieee80211_snap_hdr	*)(ptr+pattrib->hdrlen + pattrib->iv_len);
+	psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
+	/* convert hdr + possible LLC headers into Ethernet header */
+	//eth_type = (psnap_type[0] << 8) | psnap_type[1];
+	if((_rtw_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == _FALSE) && 
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==_FALSE) )||
+		//eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+		 _rtw_memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)){
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+		bsnaphdr = _TRUE;
+	}
+	else {
+		/* Leave Ethernet header part of hdr and full payload */
+		bsnaphdr = _FALSE;
+	}
+
+	rmv_len = pattrib->hdrlen + pattrib->iv_len +(bsnaphdr?SNAP_SIZE:0);
+	len = precvframe->u.hdr.len - rmv_len;
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n", pattrib->hdrlen,	pattrib->iv_len));
+
+	_rtw_memcpy(&eth_type, ptr+rmv_len, 2);
+	eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
+	pattrib->eth_type = eth_type;
+
+	{
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+ (bsnaphdr?2:0)));
+	}
+
+	_rtw_memcpy(ptr, pattrib->dst, ETH_ALEN);
+	_rtw_memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+
+	if(!bsnaphdr) {
+		len = htons(len);
+		_rtw_memcpy(ptr+12, &len, 2);
+	}
+	
+	if (adapter->registrypriv.mp_mode == 1)
+	{
+		len = htons(pattrib->seq_num);
+		//DBG_871X("wlan seq = %d ,seq_num =%x\n",len,pattrib->seq_num);
+		_rtw_memcpy(ptr+12,&len, 2);
+	}
+_func_exit_;	
+	return ret;
+
+}
+
+
 int recv_func_prehandle(_adapter *padapter, union recv_frame *rframe)
 {
 	int ret = _SUCCESS;
 	struct rx_pkt_attrib *pattrib = &rframe->u.hdr.attrib;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	_queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
-	
 #ifdef CONFIG_MP_INCLUDED
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mp_priv *pmppriv = &padapter->mppriv;
+#endif //CONFIG_MP_INCLUDED
+	u8 type;
+	u8 *ptr = rframe->u.hdr.rx_data;
+	u8 *psa, *pda, *pbssid;
+	struct sta_info *psta = NULL;
+    DBG_COUNTER(padapter->rx_logs.core_rx_pre);
 
+#ifdef CONFIG_MP_INCLUDED
 	if (padapter->registrypriv.mp_mode == 1)
 	{
-		if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE))//&&(padapter->mppriv.check_mp_pkt == 0))
+	
+		if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) )//&&(padapter->mppriv.check_mp_pkt == 0))
 		{
 			if (pattrib->crc_err == 1){
 				padapter->mppriv.rx_crcerrpktcount++;
@@ -3625,15 +3800,125 @@ int recv_func_prehandle(_adapter *padapter, union recv_frame *rframe)
 					padapter->mppriv.rx_pktcount_filter_out++;
 				
 			}
+			
+			if(pmppriv->rx_bindicatePkt == _FALSE)
+			{
+				//if (check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) == _FALSE) {
+					//RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("MP - Not in loopback mode , drop pkt \n"));
+					ret = _FAIL;
+					rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
+					goto exit;
+				
+			}
+			else {			
+			
+			type =  GetFrameType(ptr);
+			pattrib->to_fr_ds = get_tofr_ds(ptr);
+			pattrib->frag_num = GetFragNum(ptr);
+			pattrib->seq_num = GetSequence(ptr);
+			pattrib->pw_save = GetPwrMgt(ptr);
+			pattrib->mfrag = GetMFrag(ptr);
+			pattrib->mdata = GetMData(ptr);
+			pattrib->privacy = GetPrivacy(ptr);
+			pattrib->order = GetOrder(ptr);
+	
+			if(type ==WIFI_DATA_TYPE)
+			{
+				pda = get_da(ptr);
+				psa = get_sa(ptr);
+				pbssid = get_hdr_bssid(ptr);
+				
+				_rtw_memcpy(pattrib->dst, pda, ETH_ALEN);
+				_rtw_memcpy(pattrib->src, psa, ETH_ALEN);
+				_rtw_memcpy(pattrib->bssid, pbssid, ETH_ALEN);
+			
+			switch(pattrib->to_fr_ds)
+			{
+			case 0:
+				_rtw_memcpy(pattrib->ra, pda, ETH_ALEN);
+				_rtw_memcpy(pattrib->ta, psa, ETH_ALEN);
+				ret = sta2sta_data_frame(padapter, rframe, &psta);
+				break;
 
-			if (check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) == _FALSE) {
-				//RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("MP - Not in loopback mode , drop pkt \n"));
-				ret = _FAIL;
-				rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
-				goto exit;
+			case 1:
+		
+				_rtw_memcpy(pattrib->ra, pda, ETH_ALEN);
+				_rtw_memcpy(pattrib->ta, pbssid, ETH_ALEN);
+				ret = ap2sta_data_frame(padapter, rframe, &psta);
+		
+				break;
+
+			case 2:
+				_rtw_memcpy(pattrib->ra, pbssid, ETH_ALEN);
+				_rtw_memcpy(pattrib->ta, psa, ETH_ALEN);
+				ret = sta2ap_data_frame(padapter, rframe, &psta);
+				break;
+
+			case 3:
+				_rtw_memcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);
+				_rtw_memcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);
+				ret =_FAIL;
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" case 3\n"));
+				break;
+
+			default:
+				ret =_FAIL;
+				break;
 			}
+		
+			ret = MPwlanhdr_to_ethhdr (rframe);
+				
+			if (ret != _SUCCESS)
+			{
+							RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("wlanhdr_to_ethhdr: drop pkt \n"));
+				#ifdef DBG_RX_DROP_FRAME
+							DBG_871X("DBG_RX_DROP_FRAME %s wlanhdr_to_ethhdr: drop pkt\n", __FUNCTION__);
+				#endif
+							rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
+							ret = _FAIL;
+							goto exit;
+						}
+				
+						if ((padapter->bDriverStopped == _FALSE) && (padapter->bSurpriseRemoved == _FALSE))
+						{
+							RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@ recv_func: recv_func rtw_recv_indicatepkt\n" ));
+							//indicate this recv_frame
+							ret = rtw_recv_indicatepkt(padapter, rframe);
+							if (ret != _SUCCESS)
+							{	
+					#ifdef DBG_RX_DROP_FRAME
+								DBG_871X("DBG_RX_DROP_FRAME %s rtw_recv_indicatepkt fail!\n", __FUNCTION__);
+					#endif
+								rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
+								ret = _FAIL;
+
+								goto exit;
+							}
+						}
+						else
+						{
+							RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_func: rtw_free_recvframe\n" ));
+										RT_TRACE(_module_rtl871x_recv_c_, _drv_debug_, ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+							#ifdef DBG_RX_DROP_FRAME
+										DBG_871X("DBG_RX_DROP_FRAME %s ecv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", __FUNCTION__,
+											padapter->bDriverStopped, padapter->bSurpriseRemoved);
+							#endif
+							ret = _FAIL;
+							rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
+							goto exit;
+						}
+
+					}
+				}
+				
 		}
-	}
+
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_, ("recv_func: validate_recv_frame fail! drop pkt\n"));
+		rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
+		ret = _FAIL;
+		goto exit;
+	 }
+	
 #endif
 
 	//check the frame crtl field and decache
@@ -3656,12 +3941,11 @@ int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	_queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
-	
-
 #ifdef CONFIG_TDLS
 	u8 *psnap_type, *pcategory;
 #endif //CONFIG_TDLS
 
+	DBG_COUNTER(padapter->rx_logs.core_rx_post);
 
 	// DATA FRAME
 	rtw_led_control(padapter, LED_CTL_RX);
@@ -3673,6 +3957,7 @@ int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 		DBG_871X("DBG_RX_DROP_FRAME %s decryptor: drop pkt\n", __FUNCTION__);
 		#endif
 		ret = _FAIL;
+		DBG_COUNTER(padapter->rx_logs.core_rx_post_decrypt_err);
 		goto _recv_data_drop;
 	}
 
@@ -3712,6 +3997,7 @@ int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_871X("DBG_RX_DROP_FRAME %s recvframe_chk_defrag: drop pkt\n", __FUNCTION__);
 		#endif
+		DBG_COUNTER(padapter->rx_logs.core_rx_post_defrag_err);
 		goto _recv_data_drop;		
 	}
 
@@ -3722,6 +4008,7 @@ int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 		DBG_871X("DBG_RX_DROP_FRAME %s portctrl: drop pkt\n", __FUNCTION__);
 		#endif
 		ret = _FAIL;
+		DBG_COUNTER(padapter->rx_logs.core_rx_post_portctrl_err);
 		goto _recv_data_drop;
 	}
 
@@ -3740,6 +4027,7 @@ int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 		DBG_871X("DBG_RX_DROP_FRAME %s process_recv_indicatepkts fail!\n", __FUNCTION__);
 		#endif
 		rtw_free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+		DBG_COUNTER(padapter->rx_logs.core_rx_post_indicate_err);
 		goto _recv_data_drop;
 	}
 #else // CONFIG_80211N_HT
@@ -3830,6 +4118,7 @@ int recv_func(_adapter *padapter, union recv_frame *rframe)
 
 		while((pending_frame=rtw_alloc_recvframe(&padapter->recvpriv.uc_swdec_pending_queue))) {
 			cnt++;
+			DBG_COUNTER(padapter->rx_logs.core_rx_dequeue);
 			recv_func_posthandle(padapter, pending_frame);
 		}
 
@@ -3838,6 +4127,7 @@ int recv_func(_adapter *padapter, union recv_frame *rframe)
 				FUNC_ADPT_ARG(padapter), cnt);
 	}
 
+	DBG_COUNTER(padapter->rx_logs.core_rx);
 	ret = recv_func_prehandle(padapter, rframe);
 
 	if(ret == _SUCCESS) {
@@ -3849,6 +4139,7 @@ int recv_func(_adapter *padapter, union recv_frame *rframe)
 			psecuritypriv->ndisauthtype == Ndis802_11AuthModeWPAPSK &&
 			!psecuritypriv->busetkipkey)
 		{
+			DBG_COUNTER(padapter->rx_logs.core_rx_enqueue);
 			rtw_enqueue_recvframe(rframe, &padapter->recvpriv.uc_swdec_pending_queue);
 			//DBG_871X("%s: no key, enqueue uc_swdec_pending_queue\n", __func__);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_security.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_security.c
index 9605a984557f..9841568494ec 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_security.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_security.c
@@ -307,9 +307,9 @@ _func_enter_;
 
 			}
 			
-		}
-		
-		WEP_SW_ENC_CNT_INC(psecuritypriv, pattrib->ra);					
+		}		
+
+		WEP_SW_ENC_CNT_INC(psecuritypriv, pattrib->ra);
 	}
 	
 _func_exit_;						
@@ -360,7 +360,6 @@ _func_enter_;
 		}
 
 		WEP_SW_DEC_CNT_INC(psecuritypriv, prxattrib->ra);
-
 	}
 	
 _func_exit_;		
@@ -1764,7 +1763,7 @@ _func_enter_;
 
 				}
 			}
-			
+
 			AES_SW_ENC_CNT_INC(psecuritypriv, pattrib->ra);
 		}
 /*
@@ -1773,7 +1772,7 @@ _func_enter_;
 			DBG_871X("%s, psta==NUL\n", __func__);
 			res=_FAIL;
 		}
-*/						
+*/
 	}
 
 
@@ -2089,7 +2088,7 @@ _func_enter_;
 				static u32 start = 0;
 				static u32 no_gkey_bc_cnt = 0;
 				static u32 no_gkey_mc_cnt = 0;
-		
+
 				//DBG_871X("rx bc/mc packets, to perform sw rtw_aes_decrypt\n");
 				//prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
 				if(psecuritypriv->binstallGrpkey==_FALSE)
@@ -2166,7 +2165,6 @@ _func_enter_;
 			res= aes_decipher(prwskey,prxattrib->hdrlen,pframe, length);
 
 			AES_SW_DEC_CNT_INC(psecuritypriv, prxattrib->ra);
-
 		}
 		else{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_decrypt: stainfo==NULL!!!\n"));
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_sreset.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_sreset.c
index 62a8adf7239d..c7066f8fb9eb 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_sreset.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_sreset.c
@@ -267,8 +267,7 @@ void sreset_stop_adapter(_adapter *padapter)
 
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 
-	if (!rtw_netif_queue_stopped(padapter->pnetdev))
-		rtw_netif_stop_queue(padapter->pnetdev);
+	rtw_netif_stop_queue(padapter->pnetdev);
 
 	rtw_cancel_all_timer(padapter);
 
@@ -307,11 +306,10 @@ void sreset_start_adapter(_adapter *padapter)
 	tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 	#endif
 
-	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
-
-	if (rtw_netif_queue_stopped(padapter->pnetdev))
-		rtw_netif_wake_queue(padapter->pnetdev);
+	if (is_primary_adapter(padapter))
+		_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
+	rtw_netif_wake_queue(padapter->pnetdev);
 }
 
 void sreset_reset(_adapter *padapter)
@@ -331,10 +329,10 @@ void sreset_reset(_adapter *padapter)
 
 	psrtpriv->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
 
-	
-#ifdef CONFIG_POWER_SAVING
+
+#ifdef CONFIG_LPS
 	rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "SRESET");
-#endif
+#endif//#ifdef CONFIG_LPS
 	
 	_enter_pwrlock(&pwrpriv->lock);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_sta_mgt.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_sta_mgt.c
index f03f727d9ee6..f17b2a2dc475 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_sta_mgt.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_sta_mgt.c
@@ -456,13 +456,19 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 	struct	xmit_priv	*pxmitpriv= &padapter->xmitpriv;
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 	struct hw_xmit *phwxmit;
-
+	int pending_qcnt[4];
 
 _func_enter_;	
 	
 	if (psta == NULL)
 		goto exit;
 
+	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL0);
+	rtw_list_delete(&psta->hash_list);
+	RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x  \n",pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]));
+	pstapriv->asoc_sta_count --;
+	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL0);
+
 
 	_enter_critical_bh(&psta->lock, &irqL0);
 	psta->state &= ~_FW_LINKED;
@@ -488,6 +494,7 @@ _func_enter_;
 	rtw_list_delete(&(pstaxmitpriv->vo_q.tx_pending));
 	phwxmit = pxmitpriv->hwxmits;
 	phwxmit->accnt -= pstaxmitpriv->vo_q.qcnt;
+	pending_qcnt[0] = pstaxmitpriv->vo_q.qcnt;
 	pstaxmitpriv->vo_q.qcnt = 0;
 	//_exit_critical_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
 
@@ -497,6 +504,7 @@ _func_enter_;
 	rtw_list_delete(&(pstaxmitpriv->vi_q.tx_pending));
 	phwxmit = pxmitpriv->hwxmits+1;
 	phwxmit->accnt -= pstaxmitpriv->vi_q.qcnt;
+	pending_qcnt[1] = pstaxmitpriv->vi_q.qcnt;
 	pstaxmitpriv->vi_q.qcnt = 0;
 	//_exit_critical_bh(&(pxmitpriv->vi_pending.lock), &irqL0);
 
@@ -506,6 +514,7 @@ _func_enter_;
 	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
 	phwxmit = pxmitpriv->hwxmits+2;
 	phwxmit->accnt -= pstaxmitpriv->be_q.qcnt;
+	pending_qcnt[2] = pstaxmitpriv->be_q.qcnt;
 	pstaxmitpriv->be_q.qcnt = 0;
 	//_exit_critical_bh(&(pxmitpriv->be_pending.lock), &irqL0);
 	
@@ -515,15 +524,14 @@ _func_enter_;
 	rtw_list_delete(&(pstaxmitpriv->bk_q.tx_pending));
 	phwxmit = pxmitpriv->hwxmits+3;
 	phwxmit->accnt -= pstaxmitpriv->bk_q.qcnt;
+	pending_qcnt[3] = pstaxmitpriv->bk_q.qcnt;
 	pstaxmitpriv->bk_q.qcnt = 0;
 	//_exit_critical_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
-	
+
+	rtw_os_wake_queue_at_free_stainfo(padapter, pending_qcnt);
+
 	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
 	
-	rtw_list_delete(&psta->hash_list);
-	RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x  \n",pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]));
-	pstapriv->asoc_sta_count --;
-	
 	
 	// re-init sta_info; 20061114 // will be init in alloc_stainfo
 	//_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
@@ -631,7 +639,9 @@ _func_enter_;
 	 _rtw_spinlock_free(&psta->lock);
 
 	//_enter_critical_bh(&(pfree_sta_queue->lock), &irqL0);
+	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL0);	
 	rtw_list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
+	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL0);
 	//_exit_critical_bh(&(pfree_sta_queue->lock), &irqL0);
 
 exit:
@@ -651,6 +661,9 @@ void rtw_free_all_stainfo(_adapter *padapter)
 	struct sta_info *psta = NULL;
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info* pbcmc_stainfo =rtw_get_bcmc_stainfo( padapter);
+	u8 free_sta_num = 0;
+	char free_sta_list[NUM_STA];
+	int stainfo_offset;
 	
 _func_enter_;	
 
@@ -670,13 +683,27 @@ _func_enter_;
 
 			plist = get_next(plist);
 
-			if(pbcmc_stainfo!=psta)					
-				rtw_free_stainfo(padapter , psta);
+			if(pbcmc_stainfo!=psta)
+			{
+				rtw_list_delete(&psta->hash_list);
+				//rtw_free_stainfo(padapter , psta);
+				stainfo_offset = rtw_stainfo_offset(pstapriv, psta);
+				if (stainfo_offset_valid(stainfo_offset)) {
+					free_sta_list[free_sta_num++] = stainfo_offset;
+				}
+			}	
 			
 		}
 	}
 	
 	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+
+	for (index = 0; index < free_sta_num; index++) 
+	{
+		psta = rtw_get_stainfo_by_offset(pstapriv, free_sta_list[index]);
+		rtw_free_stainfo(padapter , psta);
+	}
 	
 exit:	
 	
@@ -762,9 +789,6 @@ _func_enter_;
 		goto exit;
 	}
 
-	// default broadcast & multicast use macid 1
-	psta->mac_id = 1;
-
 	ptxservq= &(psta->sta_xmitpriv.be_q);
 
 /*
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_tdls.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_tdls.c
index 59c41adc2054..21f9fcc8342b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_tdls.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_tdls.c
@@ -22,8 +22,6 @@
 #include <drv_types.h>
 
 #ifdef CONFIG_TDLS
-extern unsigned char MCS_rate_2R[16];
-extern unsigned char MCS_rate_1R[16];
 extern void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame);
 
 void rtw_reset_tdls_info(_adapter* padapter)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_vht.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_vht.c
index 1d752711e4f7..ce971d5a5ed3 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_vht.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_vht.c
@@ -281,8 +281,9 @@ void	update_sta_vht_info_apmode(_adapter *padapter, PVOID sta)
 	}
 
 	bw_mode = GET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(&pvhtpriv_sta->vht_op_mode_notify);
-	if (bw_mode > psta->bw_mode)
-		psta->bw_mode = bw_mode;
+	
+	//if (bw_mode > psta->bw_mode)
+	psta->bw_mode = bw_mode;
 
 	// B4 Rx LDPC
 	if (TEST_FLAG(pvhtpriv_ap->ldpc_cap, LDPC_VHT_ENABLE_TX) && 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_wlan_util.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_wlan_util.c
index 009f01cf46fa..1047712d9f62 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_wlan_util.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_wlan_util.c
@@ -41,11 +41,6 @@ unsigned char TPLINK_745N_OUI[] = {0x00, 0x0a, 0xeb};
 
 unsigned char REALTEK_96B_IE[] = {0x00, 0xe0, 0x4c, 0x02, 0x01, 0x20};
 
-extern unsigned char	MCS_rate_2R[16];
-#ifdef CONFIG_DISABLE_MCS13TO15
-extern unsigned char	MCS_rate_2R_MCS13TO15_OFF[16];
-#endif //CONFIG_DISABLE_MCS13TO15
-extern unsigned char	MCS_rate_1R[16];
 extern unsigned char RTW_WPA_OUI[];
 extern unsigned char WPA_TKIP_CIPHER[4];
 extern unsigned char RSN_TKIP_CIPHER[4];
@@ -55,6 +50,7 @@ extern unsigned char RSN_TKIP_CIPHER[4];
 //#define WAIT_FOR_BCN_TO_MIN	(3000)
 #define WAIT_FOR_BCN_TO_MIN	(6000)
 #define WAIT_FOR_BCN_TO_MAX	(20000)
+
 #define DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS 1000
 #define DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD 3
 
@@ -75,6 +71,7 @@ static u8 rtw_basic_rate_mix[7] = {
 	IEEE80211_OFDM_RATE_24MB|IEEE80211_BASIC_RATE_MASK
 };
 
+int new_bcn_max = 3;
 
 int cckrates_included(unsigned char *rate, int ratelen)
 {
@@ -396,6 +393,19 @@ void get_rate_set(_adapter *padapter, unsigned char *pbssrate, int *bssrate_len)
 	_rtw_memcpy(pbssrate, supportedrates, *bssrate_len);
 }
 
+void set_mcs_rate_by_mask(u8 *mcs_set, u32 mask)
+{
+	u8 mcs_rate_1r = (u8)(mask&0xff);
+	u8 mcs_rate_2r = (u8)((mask>>8)&0xff);
+	u8 mcs_rate_3r = (u8)((mask>>16)&0xff);
+	u8 mcs_rate_4r = (u8)((mask>>24)&0xff);
+
+	mcs_set[0] &= mcs_rate_1r;
+	mcs_set[1] &= mcs_rate_2r;
+	mcs_set[2] &= mcs_rate_3r;
+	mcs_set[3] &= mcs_rate_4r;
+}
+
 void UpdateBrateTbl(
 	IN PADAPTER		Adapter,
 	IN u8			*mBratesOS
@@ -892,6 +902,32 @@ void read_cam(_adapter *padapter ,u8 entry, u8 *get_key)
 	}
 	//DBG_8192C("*********************************\n");
 }
+
+bool read_phy_cam_is_gtk(_adapter *padapter, u8 entry)
+{
+	bool res = _FALSE;
+	u32 addr, cmd;
+
+	addr = entry << 3;
+	cmd = _ReadCAM(padapter, addr);
+
+	res = (cmd & BIT6)? _TRUE:_FALSE;
+	return res;
+}
+
+void dump_cam_table(_adapter *padapter) {
+	u32 i, j, addr, cmd;
+	DBG_871X("###########DUMP CAM TABLE##############\n");
+	for (i = 0; i < 8 ; i++) {
+		addr = i << 3;
+		DBG_871X("********* DUMP CAM Entry_#%02d**********\n",i);
+		for (j = 0; j < 6; j++) {
+			cmd = _ReadCAM(padapter ,addr+j);
+			DBG_8192C("offset:0x%02x => 0x%08x \n",addr+j,cmd);
+		}
+		DBG_871X("*********************************\n");
+	}
+}
 #endif
 
 void _write_cam(_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)
@@ -968,9 +1004,11 @@ void write_cam_cache(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key)
 	_irqL irqL;
 
 	_enter_critical_bh(&cam_ctl->lock, &irqL);
+
 	dvobj->cam_cache[id].ctrl = ctrl;
 	_rtw_memcpy(dvobj->cam_cache[id].mac, mac, ETH_ALEN);
 	_rtw_memcpy(dvobj->cam_cache[id].key, key, 16);
+
 	_exit_critical_bh(&cam_ctl->lock, &irqL);
 }
 
@@ -1041,7 +1079,7 @@ bool _rtw_camid_is_gk(_adapter *adapter, u8 cam_id)
 
 	if (!(cam_ctl->bitmap & BIT(cam_id)))
 		goto exit;
-
+	
 	ret = (dvobj->cam_cache[cam_id].ctrl&BIT6)?_TRUE:_FALSE;
 
 exit:
@@ -1066,7 +1104,6 @@ s16 _rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
 	struct cam_ctl_t *cam_ctl = &dvobj->cam_ctl;
-	_irqL irqL;
 	int i;
 	s16 cam_id = -1;
 
@@ -1145,15 +1182,11 @@ s16 rtw_camid_alloc(_adapter *adapter, struct sta_info *sta, u8 kid)
 			}
 
 			if ((i = _rtw_camid_search(adapter, addr, kid)) >= 0) {
-				/* 
-				 * Fix issue that pairwise and group key have same key id. Pairwise key first,
-				 * group key can overwirte group only(ex: rekey) 
-				 */
+				/* Fix issue that pairwise and group key have same key id. Pairwise key first, group key can overwirte group only(ex: rekey) */
 				if (sta || _rtw_camid_is_gk(adapter, i) == _TRUE)
 					cam_id = i;
 				else
-					DBG_871X_LEVEL(_drv_always_,
-						FUNC_ADPT_FMT" group key id:%u the same key id as pairwise key\n"
+					DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" group key id:%u the same key id as pairwise key\n"
 						, FUNC_ADPT_ARG(adapter), kid);
 				goto bitmap_handle;
 			}
@@ -1224,58 +1257,58 @@ int allocate_fw_sta_entry(_adapter *padapter)
 
 void flush_all_cam_entry(_adapter *padapter)
 {
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_buddy_fwstate(padapter, _FW_LINKED) == _TRUE)
+	if(check_buddy_fwstate(padapter, _FW_LINKED) == _TRUE)
+	{
+		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
 		{
-			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
-			{
-				struct sta_priv *pstapriv = &padapter->stapriv;
-				struct sta_info *psta;
-	
-				psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
-				if(psta) {
-					if(psta->state & WIFI_AP_STATE)
-					{}	 //clear cam when ap free per sta_info		  
-					else {
-						rtw_clearstakey_cmd(padapter, psta, _FALSE);
-					}
+			struct sta_priv	*pstapriv = &padapter->stapriv;
+			struct sta_info	*psta;
+
+			psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
+			if(psta) {
+				if(psta->state & WIFI_AP_STATE)
+				{}   //clear cam when ap free per sta_info        
+				else {
+					rtw_clearstakey_cmd(padapter, psta, _FALSE);
 				}
 			}
-			else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
-			{
-				/* clear default key */
-				int i, cam_id;
-				u8 null_addr[ETH_ALEN]= {0,0,0,0,0,0};
-	
-				for (i=0;i<4;i++) {
-					cam_id = rtw_camid_search(padapter, null_addr, i);
-					if (cam_id >= 0) {
-						clear_cam_entry(padapter, cam_id);
-						rtw_camid_free(padapter, cam_id);
-					}
+		}
+		else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		{
+			/* clear default key */
+			int i, cam_id;
+			u8 null_addr[ETH_ALEN]= {0,0,0,0,0,0};
+
+			for (i=0;i<4;i++) {
+				cam_id = rtw_camid_search(padapter, null_addr, i);
+				if (cam_id >= 0) {
+					clear_cam_entry(padapter, cam_id);
+					rtw_camid_free(padapter, cam_id);
 				}
-	
-				/* clear default key related key search setting */
+			}
+
+			/* clear default key related key search setting */
 			#ifdef DYNAMIC_CAMID_ALLOC
-				rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)_FALSE);
+			rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)_FALSE);
 			#endif
-	
-				/* leave pairwise key when ap free per sta_info */
-			}
+
+			/* leave pairwise key when ap free per sta_info */
 		}
-		else
+	}
+	else
 #endif //CONFIG_CONCURRENT_MODE
-		{
-			invalidate_cam_all(padapter);
-			/* clear default key related key search setting */
+	{
+		invalidate_cam_all(padapter);
+		/* clear default key related key search setting */
 		#ifdef DYNAMIC_CAMID_ALLOC
-			rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)_FALSE);
+		rtw_hal_set_hwreg(padapter, HW_VAR_SEC_DK_CFG, (u8*)_FALSE);
 		#endif
-		}
+	}
 
 	_rtw_memset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));
 	
@@ -1327,11 +1360,18 @@ int WMM_param_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE)
 	if(pmlmepriv->qospriv.qos_option==0)
 	{
 		pmlmeinfo->WMM_enable = 0;
-		return _FAIL;
+		return _FALSE;
 	}	
-
+	
+	if(_rtw_memcmp(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element)))
+	{
+		return _FALSE;
+	}
+	else
+	{
+		_rtw_memcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
+	}
 	pmlmeinfo->WMM_enable = 1;
-	_rtw_memcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
 	return _TRUE;
 
 	/*if (pregpriv->wifi_spec == 1)
@@ -1644,7 +1684,9 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 		}
 		else
 		{
-			//modify from  fw by Thomas 2010/11/17
+			/* AMPDU Parameters field */
+
+			/* Get MIN of MAX AMPDU Length Exp */
 			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3) > (pIE->data[i] & 0x3))
 			{
 				max_AMPDU_len = (pIE->data[i] & 0x3);
@@ -1653,7 +1695,8 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 			{
 				max_AMPDU_len = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3);
 			}
-			
+
+			/* Get MAX of MIN MPDU Start Spacing */
 			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) > (pIE->data[i] & 0x1c))
 			{
 				min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c);
@@ -1675,34 +1718,33 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
-	//update the MCS rates
+
+	//update the MCS set
 	for (i = 0; i < 16; i++)
+		pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= pmlmeext->default_supported_mcs_set[i];
+			
+	//update the MCS rates
+	switch(rf_type)
 	{
-		if((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
-		{
-			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
-		}
-		else
-		{
-			#ifdef CONFIG_DISABLE_MCS13TO15
-			if(pmlmeext->cur_bwmode == CHANNEL_WIDTH_40 && (pregistrypriv->wifi_spec!=1))
-				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R_MCS13TO15_OFF[i];
+		case RF_1T1R:
+		case RF_1T2R:
+			set_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_1R);							
+			break;
+		case RF_2T2R:		
+		default:
+#ifdef CONFIG_DISABLE_MCS13TO15
+			if(pmlmeext->cur_bwmode == CHANNEL_WIDTH_40 && pregistrypriv->wifi_spec != 1 )				
+				set_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_2R_13TO15_OFF);				
 			else
-			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
-			#else
-			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
-			#endif //CONFIG_DISABLE_MCS13TO15
-		}
-	        #ifdef RTL8192C_RECONFIG_TO_1T1R
-		{
-			pmlmeinfo->HT_caps.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
-		}
-		#endif
+				set_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_2R);
+#else //CONFIG_DISABLE_MCS13TO15
+			set_mcs_rate_by_mask(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_RATE_2R);
+#endif //CONFIG_DISABLE_MCS13TO15
 	}
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 		// Config STBC setting
-		if (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX) && GET_HT_CAPABILITY_ELE_TX_STBC(pIE->data))
+		if (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX) && GET_HT_CAP_ELE_TX_STBC(pIE->data))
 		{
 			SET_FLAG(cur_stbc_cap, STBC_HT_ENABLE_TX);
 			DBG_871X("Enable HT Tx STBC !\n");
@@ -1729,7 +1771,7 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 #endif //CONFIG_BEAMFORMING
 	} else {
 		// Config LDPC Coding Capability
-		if (TEST_FLAG(phtpriv->ldpc_cap, LDPC_HT_ENABLE_TX) && GET_HT_CAPABILITY_ELE_LDPC_CAP(pIE->data))
+		if (TEST_FLAG(phtpriv->ldpc_cap, LDPC_HT_ENABLE_TX) && GET_HT_CAP_ELE_LDPC_CAP(pIE->data))
 		{
 			SET_FLAG(cur_ldpc_cap, (LDPC_HT_ENABLE_TX | LDPC_HT_CAP_TX));
 			DBG_871X("Enable HT Tx LDPC!\n");
@@ -1737,7 +1779,7 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 		phtpriv->ldpc_cap = cur_ldpc_cap;
 
 		// Config STBC setting
-		if (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX) && GET_HT_CAPABILITY_ELE_RX_STBC(pIE->data))
+		if (TEST_FLAG(phtpriv->stbc_cap, STBC_HT_ENABLE_TX) && GET_HT_CAP_ELE_RX_STBC(pIE->data))
 		{
 			SET_FLAG(cur_stbc_cap, (STBC_HT_ENABLE_TX | STBC_HT_CAP_TX) );
 			DBG_871X("Enable HT Tx STBC!\n");
@@ -1765,7 +1807,6 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 	}
 
 #endif //CONFIG_80211N_HT
-	return;
 }
 
 void HT_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
@@ -1984,8 +2025,117 @@ int check_ap_tdls_prohibited(u8 *pframe, u8 pkt_len)
 }
 #endif //CONFIG_TDLS
 
+/*
+ * rtw_get_bcn_keys: get beacon keys from recv frame
+ *
+ * TODO:
+ *	WLAN_EID_COUNTRY
+ *	WLAN_EID_ERP_INFO
+ *	WLAN_EID_CHANNEL_SWITCH
+ *	WLAN_EID_PWR_CONSTRAINT
+ */
+int rtw_get_bcn_keys(ADAPTER *Adapter, u8 *pframe, u32 packet_len,
+		struct beacon_keys *recv_beacon)
+{
+	int left;
+	u16 capability;
+	unsigned char *pos;
+	struct rtw_ieee802_11_elems elems;
+	struct rtw_ieee80211_ht_cap *pht_cap = NULL;
+	struct HT_info_element *pht_info = NULL;
+
+	_rtw_memset(recv_beacon, 0, sizeof(*recv_beacon));
+
+	/* checking capabilities */
+	capability = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN + 10));
+
+	/* checking IEs */
+	left = packet_len - sizeof(struct rtw_ieee80211_hdr_3addr) - _BEACON_IE_OFFSET_;
+	pos = pframe + sizeof(struct rtw_ieee80211_hdr_3addr) + _BEACON_IE_OFFSET_;
+	if (rtw_ieee802_11_parse_elems(pos, left, &elems, 1) == ParseFailed)
+		return _FALSE;
+
+	/* check bw and channel offset */
+	if (elems.ht_capabilities) {
+		if (elems.ht_capabilities_len != sizeof(*pht_cap))
+			return _FALSE;
+
+		pht_cap = (struct rtw_ieee80211_ht_cap *) elems.ht_capabilities;
+		recv_beacon->ht_cap_info = pht_cap->cap_info;
+	}
+
+	if (elems.ht_operation) {
+		if (elems.ht_operation_len != sizeof(*pht_info))
+			return _FALSE;
+
+		pht_info = (struct HT_info_element *) elems.ht_operation;
+		recv_beacon->ht_info_infos_0_sco = pht_info->infos[0] & 0x03;
+	}
+
+	/* Checking for channel */
+	if (elems.ds_params && elems.ds_params_len == sizeof(recv_beacon->bcn_channel))
+		_rtw_memcpy(&recv_beacon->bcn_channel, elems.ds_params,
+				sizeof(recv_beacon->bcn_channel));
+	else if (pht_info)
+		/* In 5G, some ap do not have DSSET IE checking HT info for channel */
+		recv_beacon->bcn_channel = pht_info->primary_channel;
+	else {
+		/* we don't find channel IE, so don't check it */
+		//DBG_871X("Oops: %s we don't find channel IE, so don't check it \n", __func__);
+		recv_beacon->bcn_channel = Adapter->mlmeextpriv.cur_channel;
+	}
+
+	/* checking SSID */
+	if (elems.ssid) {
+	       if (elems.ssid_len > sizeof(recv_beacon->ssid))
+			return _FALSE;
+
+	       _rtw_memcpy(recv_beacon->ssid, elems.ssid, elems.ssid_len);
+	       recv_beacon->ssid_len = elems.ssid_len;
+	} else; // means hidden ssid
+
+	/* checking RSN first */
+	if (elems.rsn_ie && elems.rsn_ie_len) {
+		recv_beacon->encryp_protocol = ENCRYP_PROTOCOL_WPA2;
+		rtw_parse_wpa2_ie(elems.rsn_ie - 2, elems.rsn_ie_len + 2,
+			&recv_beacon->group_cipher, &recv_beacon->pairwise_cipher,
+			&recv_beacon->is_8021x);
+	}
+	/* checking WPA secon */
+	else if (elems.wpa_ie && elems.wpa_ie_len) {
+		recv_beacon->encryp_protocol = ENCRYP_PROTOCOL_WPA;
+		rtw_parse_wpa_ie(elems.wpa_ie - 2, elems.wpa_ie_len + 2,
+			&recv_beacon->group_cipher, &recv_beacon->pairwise_cipher,
+			&recv_beacon->is_8021x);
+	}
+	else if (capability & BIT(4)) {
+		recv_beacon->encryp_protocol = ENCRYP_PROTOCOL_WEP;
+	}
+
+	return _TRUE;
+}
+
+void rtw_dump_bcn_keys(struct beacon_keys *recv_beacon)
+{
+	int i;
+	char *p;
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+
+	_rtw_memcpy(ssid, recv_beacon->ssid, recv_beacon->ssid_len);
+	ssid[recv_beacon->ssid_len] = '\0';
+
+	DBG_871X("%s: ssid = %s\n", __func__, ssid);
+	DBG_871X("%s: channel = %x\n", __func__, recv_beacon->bcn_channel);
+	DBG_871X("%s: ht_cap = %x\n", __func__,	recv_beacon->ht_cap_info);
+	DBG_871X("%s: ht_info_infos_0_sco = %x\n", __func__, recv_beacon->ht_info_infos_0_sco);
+	DBG_871X("%s: sec=%d, group = %x, pair = %x, 8021X = %x\n", __func__,
+		recv_beacon->encryp_protocol, recv_beacon->group_cipher,
+		recv_beacon->pairwise_cipher, recv_beacon->is_8021x);
+}
+
 int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 {
+#if 0
 	unsigned int		len;
 	unsigned char		*p;
 	unsigned short	val16, subtype;
@@ -2005,7 +2155,12 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 	u32 bcn_channel;
 	unsigned short 	ht_cap_info;
 	unsigned char	ht_info_infos_0;
+#endif
+	unsigned int len;
+	u8 *pbssid = GetAddr3Ptr(pframe);
 	struct mlme_priv *pmlmepriv = &Adapter->mlmepriv;
+	struct wlan_network *cur_network = &(Adapter->mlmepriv.cur_network);
+	struct beacon_keys recv_beacon;
 
 	if (is_client_associated_to_ap(Adapter) == _FALSE)
 		return _TRUE;
@@ -2023,16 +2178,86 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 		return _TRUE;
 	}
 
+	if (rtw_get_bcn_keys(Adapter, pframe, packet_len, &recv_beacon) == _FALSE)
+		return _TRUE; // parsing failed => broken IE
+
+	// don't care hidden ssid, use current beacon ssid directly
+	if (recv_beacon.ssid_len == 0) {
+	       _rtw_memcpy(recv_beacon.ssid, pmlmepriv->cur_beacon_keys.ssid,
+			       pmlmepriv->cur_beacon_keys.ssid_len);
+	       recv_beacon.ssid_len = pmlmepriv->cur_beacon_keys.ssid_len;
+	}
+
+	if (_rtw_memcmp(&recv_beacon, &pmlmepriv->cur_beacon_keys, sizeof(recv_beacon)) == _TRUE)
+	{
+		pmlmepriv->new_beacon_cnts = 0;
+	}
+	else if ((pmlmepriv->new_beacon_cnts == 0) ||
+		_rtw_memcmp(&recv_beacon, &pmlmepriv->new_beacon_keys, sizeof(recv_beacon)) == _FALSE)
+	{
+		DBG_871X_LEVEL(_drv_err_, "%s: start new beacon (seq=%d)\n", __func__, GetSequence(pframe));
+
+		if (pmlmepriv->new_beacon_cnts == 0) {
+			DBG_871X_LEVEL(_drv_err_, "%s: cur beacon key\n", __func__);
+			DBG_871X_EXP(_drv_err_, rtw_dump_bcn_keys(&pmlmepriv->cur_beacon_keys));
+		}
+
+		DBG_871X_LEVEL(_drv_err_, "%s: new beacon key\n", __func__);
+		DBG_871X_EXP(_drv_err_, rtw_dump_bcn_keys(&recv_beacon));
+
+		memcpy(&pmlmepriv->new_beacon_keys, &recv_beacon, sizeof(recv_beacon));
+		pmlmepriv->new_beacon_cnts = 1;
+	}
+	else
+	{
+		DBG_871X_LEVEL(_drv_err_, "%s: new beacon again (seq=%d)\n", __func__, GetSequence(pframe));
+		pmlmepriv->new_beacon_cnts++;
+	}
+
+	// if counter >= max, it means beacon is changed really
+	if (pmlmepriv->new_beacon_cnts >= new_bcn_max)
+	{
+		DBG_871X_LEVEL(_drv_err_, "%s: new beacon occur!!\n", __func__);
+
+		// check bw mode change only?
+		pmlmepriv->cur_beacon_keys.ht_cap_info = recv_beacon.ht_cap_info;
+		pmlmepriv->cur_beacon_keys.ht_info_infos_0_sco = recv_beacon.ht_info_infos_0_sco;
+
+		if (_rtw_memcmp(&recv_beacon, &pmlmepriv->cur_beacon_keys,
+					sizeof(recv_beacon)) == _FALSE) {
+			// beacon is changed, have to do disconnect/connect
+			return _FAIL;
+		}
+
+		DBG_871X("%s bw mode change\n", __func__);
+		DBG_871X("%s bcn now: ht_cap_info:%x ht_info_infos_0:%x\n", __func__,
+				cur_network->BcnInfo.ht_cap_info,
+				cur_network->BcnInfo.ht_info_infos_0);
+
+		cur_network->BcnInfo.ht_cap_info = recv_beacon.ht_cap_info;
+		cur_network->BcnInfo.ht_info_infos_0 =
+			(cur_network->BcnInfo.ht_info_infos_0 & (~0x03)) |
+			recv_beacon.ht_info_infos_0_sco;
+
+		DBG_871X("%s bcn link: ht_cap_info:%x ht_info_infos_0:%x\n", __func__,
+				cur_network->BcnInfo.ht_cap_info,
+				cur_network->BcnInfo.ht_info_infos_0);
+
+		memcpy(&pmlmepriv->cur_beacon_keys, &recv_beacon, sizeof(recv_beacon));
+		pmlmepriv->new_beacon_cnts = 0;
+	}
+
+	return _SUCCESS;
+
+#if 0
 	bssid = (WLAN_BSSID_EX *)rtw_zmalloc(sizeof(WLAN_BSSID_EX));
 	if (bssid == NULL) {
 		DBG_871X("%s rtw_zmalloc fail !!!\n", __func__);
 		return _TRUE;
 	}
 
-	if ((pmlmepriv->timeBcnInfoChkStart != 0) &&
-		(rtw_get_passing_time_ms(pmlmepriv->timeBcnInfoChkStart) >
-		DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS)) {
-
+	if ((pmlmepriv->timeBcnInfoChkStart != 0) && (rtw_get_passing_time_ms(pmlmepriv->timeBcnInfoChkStart) > DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS))
+	{
 		pmlmepriv->timeBcnInfoChkStart = 0;
 		pmlmepriv->NumOfBcnInfoChkFail = 0;
 	}
@@ -2068,9 +2293,9 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 	if (ht_cap_info != cur_network->BcnInfo.ht_cap_info ||
 		((ht_info_infos_0&0x03) != (cur_network->BcnInfo.ht_info_infos_0&0x03))) {
 			DBG_871X("%s bcn now: ht_cap_info:%x ht_info_infos_0:%x\n", __func__,
-							ht_cap_info, ht_info_infos_0);
+						   	ht_cap_info, ht_info_infos_0);
 			DBG_871X("%s bcn link: ht_cap_info:%x ht_info_infos_0:%x\n", __func__,
-							cur_network->BcnInfo.ht_cap_info, cur_network->BcnInfo.ht_info_infos_0);
+						   	cur_network->BcnInfo.ht_cap_info, cur_network->BcnInfo.ht_info_infos_0);
 			DBG_871X("%s bw mode change\n", __func__);
 			{	
 				//bcn_info_update
@@ -2184,12 +2409,9 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,
 				("%s cur_network->group_cipher is %d: %d\n",__func__, cur_network->BcnInfo.group_cipher, group_cipher));
 		if (pairwise_cipher != cur_network->BcnInfo.pairwise_cipher || group_cipher != cur_network->BcnInfo.group_cipher) {
-			DBG_871X("%s pairwise_cipher(%x:%x) or group_cipher(%x:%x) is not match\n",
-					__func__,
-					pairwise_cipher,
-					cur_network->BcnInfo.pairwise_cipher,
-					group_cipher,
-					cur_network->BcnInfo.group_cipher);
+			DBG_871X("%s pairwise_cipher(%x:%x) or group_cipher(%x:%x) is not match\n",__func__,
+					pairwise_cipher, cur_network->BcnInfo.pairwise_cipher,
+					group_cipher, cur_network->BcnInfo.group_cipher);
 			goto _mismatch;
 		}
 
@@ -2206,29 +2428,25 @@ int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len)
 	rtw_mfree((u8 *)bssid, sizeof(WLAN_BSSID_EX));
 
 	if (pmlmepriv->NumOfBcnInfoChkFail == 0)
+	{
 		pmlmepriv->timeBcnInfoChkStart = rtw_get_current_time();
+	}
 
 	pmlmepriv->NumOfBcnInfoChkFail++;
+	DBG_871X("%s by "ADPT_FMT" - NumOfChkFail = %d (SeqNum of this Beacon frame = %d).\n", __func__, ADPT_ARG(Adapter), pmlmepriv->NumOfBcnInfoChkFail, GetSequence(pframe));
 
-	DBG_871X("%s by "ADPT_FMT" - NumOfChkFail = %d (SeqNum of this Beacon frame = %d).\n",
-			__func__, ADPT_ARG(Adapter),
-			pmlmepriv->NumOfBcnInfoChkFail, GetSequence(pframe));
-	if ((pmlmepriv->timeBcnInfoChkStart != 0) &&
-		(rtw_get_passing_time_ms(pmlmepriv->timeBcnInfoChkStart)
-		 <= DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS) &&
-		(pmlmepriv->NumOfBcnInfoChkFail >=
-		DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD)) {
-		DBG_871X("%s by "ADPT_FMT" - NumOfChkFail = %d >= threshold : %d(in %d ms), return FAIL.\n",
-				__func__,
-				ADPT_ARG(Adapter),
-				pmlmepriv->NumOfBcnInfoChkFail,
-				DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD,
-				rtw_get_passing_time_ms(pmlmepriv->timeBcnInfoChkStart));
+	if ((pmlmepriv->timeBcnInfoChkStart != 0) && (rtw_get_passing_time_ms(pmlmepriv->timeBcnInfoChkStart) <= DISCONNECT_BY_CHK_BCN_FAIL_OBSERV_PERIOD_IN_MS) 
+		&& (pmlmepriv->NumOfBcnInfoChkFail >= DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD))
+	{
+		DBG_871X("%s by "ADPT_FMT" - NumOfChkFail = %d >= threshold : %d (in %d ms), return FAIL.\n", __func__, ADPT_ARG(Adapter), pmlmepriv->NumOfBcnInfoChkFail, 
+			DISCONNECT_BY_CHK_BCN_FAIL_THRESHOLD, rtw_get_passing_time_ms(pmlmepriv->timeBcnInfoChkStart));
 		pmlmepriv->timeBcnInfoChkStart = 0;
 		pmlmepriv->NumOfBcnInfoChkFail = 0;
 		return _FAIL;
 	}
+
 	return _SUCCESS;
+#endif
 }
 
 void update_beacon_info(_adapter *padapter, u8 *pframe, uint pkt_len, struct sta_info *psta)
@@ -2250,15 +2468,14 @@ void update_beacon_info(_adapter *padapter, u8 *pframe, uint pkt_len, struct sta
 		
 		switch (pIE->ElementID)
 		{
-#if 0			
 			case _VENDOR_SPECIFIC_IE_:		
-				//todo: to update WMM paramter set while receiving beacon			
-				if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6))	//WMM
+				//to update WMM paramter set while receiving beacon
+				if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6) && pIE->Length == WLAN_WMM_LEN)	//WMM
 				{
-					(WMM_param_handler(padapter, pIE))? WMMOnAssocRsp(padapter): 0;
-				}				
+					(WMM_param_handler(padapter, pIE))? report_wmm_edca_update(padapter): 0;
+				}
+
 				break;
-#endif
 
 			case _HT_EXTRA_INFO_IE_:	//HT info				
 				//HT_info_handler(padapter, pIE);
@@ -3134,8 +3351,8 @@ void adaptive_early_32k(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)
 			pmlmeext->bcn_delay_ratio[i] = (pmlmeext->bcn_delay_cnt[i] * 100) /pmlmeext->bcn_cnt;
 			
 		
-			DBG_871X("%s():bcn_delay_cnt[%d]=%d,  bcn_delay_ratio[%d]=%d\n", __func__, i, 
-				pmlmeext->bcn_delay_cnt[i] , i, pmlmeext->bcn_delay_ratio[i]);
+			//DBG_871X("%s():bcn_delay_cnt[%d]=%d,  bcn_delay_ratio[%d]=%d\n", __func__, i, 
+			//	pmlmeext->bcn_delay_cnt[i] , i, pmlmeext->bcn_delay_ratio[i]);
 
 			ratio_20_delay += pmlmeext->bcn_delay_ratio[i];
 			ratio_80_delay += pmlmeext->bcn_delay_ratio[i];
@@ -3143,13 +3360,13 @@ void adaptive_early_32k(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)
 			if(ratio_20_delay > 20 && DrvBcnEarly == 0xff)
 			{			
 				DrvBcnEarly = i;
-				DBG_871X("%s(): DrvBcnEarly = %d\n", __func__, DrvBcnEarly);
+				//DBG_871X("%s(): DrvBcnEarly = %d\n", __func__, DrvBcnEarly);
 			}	
 
 			if(ratio_80_delay > 80 && DrvBcnTimeOut == 0xff)
 			{
 				DrvBcnTimeOut = i;
-				DBG_871X("%s(): DrvBcnTimeOut = %d\n", __func__, DrvBcnTimeOut);
+				//DBG_871X("%s(): DrvBcnTimeOut = %d\n", __func__, DrvBcnTimeOut);
 			}
 			
 			//reset adaptive_early_32k cnt
@@ -3171,99 +3388,278 @@ void beacon_timing_control(_adapter *padapter)
 	rtw_hal_bcn_related_reg_setting(padapter);
 }
 
+#define CONFIG_SHARED_BMC_MACID
+
+void dump_macid_map(void *sel, struct macid_bmp *map, u8 max_num)
+{
+	DBG_871X_SEL_NL(sel, "0x%08x\n", map->m0);
+#if (MACID_NUM_SW_LIMIT > 32)
+	if (max_num && max_num > 32)
+		DBG_871X_SEL_NL(sel, "0x%08x\n", map->m1);
+#endif
+#if (MACID_NUM_SW_LIMIT > 64)
+	if (max_num && max_num > 64)
+		DBG_871X_SEL_NL(sel, "0x%08x\n", map->m2);
+#endif
+#if (MACID_NUM_SW_LIMIT > 96)
+	if (max_num && max_num > 96)
+		DBG_871X_SEL_NL(sel, "0x%08x\n", map->m3);
+#endif
+}
+
+inline bool rtw_macid_is_set(struct macid_bmp *map, u8 id)
+{
+	if (id < 32)
+		return (map->m0 & BIT(id));
+#if (MACID_NUM_SW_LIMIT > 32)
+	else if (id < 64)
+		return (map->m1 & BIT(id-32));
+#endif
+#if (MACID_NUM_SW_LIMIT > 64)
+	else if (id < 96)
+		return (map->m2 & BIT(id-64));
+#endif
+#if (MACID_NUM_SW_LIMIT > 96)
+	else if (id < 128)
+		return (map->m3 & BIT(id-96));
+#endif
+	else
+		rtw_warn_on(1);
+
+	return 0;
+}
+
+inline void rtw_macid_map_set(struct macid_bmp *map, u8 id)
+{
+	if (id < 32)
+		map->m0 |= BIT(id);
+#if (MACID_NUM_SW_LIMIT > 32)
+	else if (id < 64)
+		map->m1 |= BIT(id-32);
+#endif
+#if (MACID_NUM_SW_LIMIT > 64)
+	else if (id < 96)
+		map->m2 |= BIT(id-64);
+#endif
+#if (MACID_NUM_SW_LIMIT > 96)
+	else if (id < 128)
+		map->m3 |= BIT(id-96);
+#endif
+	else
+		rtw_warn_on(1);
+}
+
+inline void rtw_macid_map_clr(struct macid_bmp *map, u8 id)
+{
+	if (id < 32)
+		map->m0 &= ~BIT(id);
+#if (MACID_NUM_SW_LIMIT > 32)
+	else if (id < 64)
+		map->m1 &= ~BIT(id-32);
+#endif
+#if (MACID_NUM_SW_LIMIT > 64)
+	else if (id < 96)
+		map->m2 &= ~BIT(id-64);
+#endif
+#if (MACID_NUM_SW_LIMIT > 96)
+	else if (id < 128)
+		map->m3 &= ~BIT(id-96);
+#endif
+	else
+		rtw_warn_on(1);
+}
+
+inline bool rtw_macid_is_used(struct macid_ctl_t *macid_ctl, u8 id)
+{
+	return rtw_macid_is_set(&macid_ctl->used, id);
+}
+
+inline bool rtw_macid_is_bmc(struct macid_ctl_t *macid_ctl, u8 id)
+{
+	return rtw_macid_is_set(&macid_ctl->bmc, id);
+}
+
+inline s8 rtw_macid_get_if_g(struct macid_ctl_t *macid_ctl, u8 id)
+{
+	int i;
+
+#ifdef CONFIG_SHARED_BMC_MACID
+	if (rtw_macid_is_bmc(macid_ctl,id))
+		return -1;
+#endif
+
+	for (i=0;i<IFACE_ID_MAX;i++) {
+		if (rtw_macid_is_set(&macid_ctl->if_g[i], id))
+			return i;
+	}
+	return -1;
+}
+
+inline s8 rtw_macid_get_ch_g(struct macid_ctl_t *macid_ctl, u8 id)
+{
+	int i;
+
+	for (i=0;i<2;i++) {
+		if (rtw_macid_is_set(&macid_ctl->ch_g[i], id))
+			return i;
+	}
+	return -1;
+}
+
 void rtw_alloc_macid(_adapter *padapter, struct sta_info *psta)
 {
 	int i;
-	_irqL	irqL;
+	_irqL irqL;
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
-	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
-
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct macid_ctl_t *macid_ctl = dvobj_to_macidctl(dvobj);
+	struct macid_bmp *used_map = &macid_ctl->used;
+	//static u8 last_id = 0; /* for testing */
+	u8 last_id = 0;
 
-	if(_rtw_memcmp(psta->hwaddr, bc_addr, ETH_ALEN))
+	if (_rtw_memcmp(psta->hwaddr, myid(&padapter->eeprompriv), ETH_ALEN)) {
+		psta->mac_id = macid_ctl->num;
 		return;
+	}
 
-	if(_rtw_memcmp(psta->hwaddr, myid(&padapter->eeprompriv), ETH_ALEN))
-	{
-		psta->mac_id = NUM_STA;
-		return;
+#ifdef CONFIG_SHARED_BMC_MACID
+	if(_rtw_memcmp(psta->hwaddr, bc_addr, ETH_ALEN)) {
+		/* use shared broadcast & multicast macid 1 */
+		_enter_critical_bh(&macid_ctl->lock, &irqL);
+		rtw_macid_map_set(used_map, 1);
+		rtw_macid_map_set(&macid_ctl->bmc, 1);
+		for (i=0;i<IFACE_ID_MAX;i++)
+			rtw_macid_map_set(&macid_ctl->if_g[padapter->iface_id], 1);
+		/* TODO ch_g? */
+		_exit_critical_bh(&macid_ctl->lock, &irqL);
+		i = 1;
+		goto assigned;
 	}
+#endif
 
-	_enter_critical_bh(&pdvobj->lock, &irqL);
-	for(i=0; i<NUM_STA; i++)
-	{
-		if(pdvobj->macid[i] == _FALSE)
-		{
-			pdvobj->macid[i]  = _TRUE;
+	_enter_critical_bh(&macid_ctl->lock, &irqL);
+
+	for (i=last_id;i<macid_ctl->num;i++) {
+		#ifdef CONFIG_SHARED_BMC_MACID
+		if (i == 1)
+			continue;
+		#endif
+		if (!rtw_macid_is_used(macid_ctl, i))
 			break;
-		}
 	}
-	_exit_critical_bh(&pdvobj->lock, &irqL);
 
-	if( i > (NUM_STA-1))
-	{
-		psta->mac_id = NUM_STA;
-		DBG_871X("  no room for more MACIDs\n");
+	if (i < macid_ctl->num) {
+
+		rtw_macid_map_set(used_map, i);
+
+		if(_rtw_memcmp(psta->hwaddr, bc_addr, ETH_ALEN))
+			rtw_macid_map_set(&macid_ctl->bmc, i);
+
+		rtw_macid_map_set(&macid_ctl->if_g[padapter->iface_id], i);
+
+		/* TODO ch_g? */
+
+		last_id++;
+		last_id %= macid_ctl->num;
 	}
-	else
-	{
-		psta->mac_id = i;
-		DBG_871X("%s = %d\n", __FUNCTION__, psta->mac_id);
+
+	_exit_critical_bh(&macid_ctl->lock, &irqL);
+
+	if (i >= macid_ctl->num) {
+		psta->mac_id = macid_ctl->num;
+		DBG_871X_LEVEL(_drv_err_, FUNC_ADPT_FMT" if%u, hwaddr:"MAC_FMT" no available macid\n"
+			, FUNC_ADPT_ARG(padapter), padapter->iface_id+1, MAC_ARG(psta->hwaddr));
+		rtw_warn_on(1);
+		goto exit;
+	} else {
+		goto assigned;
 	}
 
+assigned:
+	psta->mac_id = i;
+	DBG_871X(FUNC_ADPT_FMT" if%u, hwaddr:"MAC_FMT" macid:%u\n"
+		, FUNC_ADPT_ARG(padapter), padapter->iface_id+1, MAC_ARG(psta->hwaddr), psta->mac_id);
+
+exit:
+	return;
 }
 
 void rtw_release_macid(_adapter *padapter, struct sta_info *psta)
 {
-	int i;
-	_irqL	irqL;
+	_irqL irqL;
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
-	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct macid_ctl_t *macid_ctl = dvobj_to_macidctl(dvobj);
 
+	if(_rtw_memcmp(psta->hwaddr, myid(&padapter->eeprompriv), ETH_ALEN))
+		return;
 
+#ifdef CONFIG_SHARED_BMC_MACID
 	if(_rtw_memcmp(psta->hwaddr, bc_addr, ETH_ALEN))
 		return;
 
-	if(_rtw_memcmp(psta->hwaddr, myid(&padapter->eeprompriv), ETH_ALEN))
-	{
+	if (psta->mac_id == 1) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_ADPT_FMT" if%u, hwaddr:"MAC_FMT" with macid:%u\n"
+			, FUNC_ADPT_ARG(padapter), padapter->iface_id+1, MAC_ARG(psta->hwaddr), psta->mac_id);
+		rtw_warn_on(1);
 		return;
 	}
+#endif
 
-	_enter_critical_bh(&pdvobj->lock, &irqL);
-	if(psta->mac_id<NUM_STA && psta->mac_id !=1 )
-	{
-		if(pdvobj->macid[psta->mac_id] == _TRUE)
-		{
-			DBG_871X("%s = %d\n", __FUNCTION__, psta->mac_id);
-			pdvobj->macid[psta->mac_id]  = _FALSE;
-			psta->mac_id = NUM_STA;
+	_enter_critical_bh(&macid_ctl->lock, &irqL);
+
+	if (psta->mac_id < macid_ctl->num) {
+		int i;
+
+		if (!rtw_macid_is_used(macid_ctl, psta->mac_id)) {
+			DBG_871X_LEVEL(_drv_err_, FUNC_ADPT_FMT" if%u, hwaddr:"MAC_FMT" macid:%u not used\n"
+				, FUNC_ADPT_ARG(padapter), padapter->iface_id+1, MAC_ARG(psta->hwaddr), psta->mac_id);
+			rtw_warn_on(1);
 		}
 
+		rtw_macid_map_clr(&macid_ctl->used, psta->mac_id);
+		rtw_macid_map_clr(&macid_ctl->bmc, psta->mac_id);
+		for (i=0;i<IFACE_ID_MAX;i++)
+			rtw_macid_map_clr(&macid_ctl->if_g[i], psta->mac_id);
+		for (i=0;i<2;i++)
+			rtw_macid_map_clr(&macid_ctl->ch_g[i], psta->mac_id);
 	}
-	_exit_critical_bh(&pdvobj->lock, &irqL);
 
+	_exit_critical_bh(&macid_ctl->lock, &irqL);
+
+	psta->mac_id = macid_ctl->num;
 }
+
 //For 8188E RA
 u8 rtw_search_max_mac_id(_adapter *padapter)
 {
 	u8 max_mac_id=0;
-	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct macid_ctl_t *macid_ctl = dvobj_to_macidctl(dvobj);
 	int i;
-	_irqL	irqL;	
-	_enter_critical_bh(&pdvobj->lock, &irqL);
-	for(i=(NUM_STA-1); i>=0 ; i--)
-	{
-		if(pdvobj->macid[i] == _TRUE)
-		{			
+	_irqL irqL;
+
+	_enter_critical_bh(&macid_ctl->lock, &irqL);
+	for(i=(macid_ctl->num-1); i>0 ; i--) {
+		if (!rtw_macid_is_used(macid_ctl, i))
 			break;
-		}
 	}
+	_exit_critical_bh(&macid_ctl->lock, &irqL);
 	max_mac_id = i;
-	_exit_critical_bh(&pdvobj->lock, &irqL);
 
 	return max_mac_id;
-
 }		
 
+inline void rtw_macid_ctl_init(struct macid_ctl_t *macid_ctl)
+{
+	_rtw_spinlock_init(&macid_ctl->lock);
+}
+
+inline void rtw_macid_ctl_deinit(struct macid_ctl_t *macid_ctl)
+{
+	_rtw_spinlock_free(&macid_ctl->lock);
+}
+
 #if 0
 unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame)
 {
@@ -3479,157 +3875,7 @@ u8 rtw_check_invalid_mac_address(u8 *mac_addr) {
 	return res;
 }
 
-/*
- * Description:
- * dump_TX_FIFO: This is only used to dump TX_FIFO for debug WoW mode offload
- * contant.
- *
- * Input:
- * adapter: adapter pointer.
- * page_num: The max. page number that user want to dump. 
- * page_size: page size of each page. eg. 128 bytes, 256 bytes.
- *
- * Output:
- * NONE
- *
- * Auther: Isaac.Li
- */
-void dump_TX_FIFO(_adapter* padapter, u8 page_num, u16 page_size){
-
-	int i;
-	u8 val = 0;
-	u8 base = 0;
-	u32 addr = 0;
-	u32 count = (page_size / 8);
-
-	if (page_num <= 0) {
-		DBG_871X("!!%s: incorrect input page_num paramter!\n", __func__);
-		return;
-	}
-
-	if (page_size < 128 || page_size > 256) {
-		DBG_871X("!!%s: incorrect input page_size paramter!\n", __func__);
-		return;
-	}
-
-	DBG_871X("+%s+\n", __func__);
-	val = rtw_read8(padapter, 0x106);
-	rtw_write8(padapter, 0x106, 0x69);
-	DBG_871X("0x106: 0x%02x\n", val);
-	base = rtw_read8(padapter, 0x209);
-	DBG_871X("0x209: 0x%02x\n", base);
-
-	addr = ((base) * page_size)/8;
-	for (i = 0 ; i < page_num * count ; i+=2) {
-		rtw_write32(padapter, 0x140, addr + i);
-		printk(" %08x %08x ", rtw_read32(padapter, 0x144), rtw_read32(padapter, 0x148));
-		rtw_write32(padapter, 0x140, addr + i + 1);
-		printk(" %08x %08x \n", rtw_read32(padapter, 0x144), rtw_read32(padapter, 0x148));
-	}
-}
-
-#ifdef CONFIG_GPIO_API
-int rtw_get_gpio(struct net_device *netdev, int gpio_num)
-{
-	u8 value;
-	u8 direction;
-	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
-	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(adapter);
-
-	rtw_ps_deny(adapter, PS_DENY_IOCTL);
-
-	DBG_871X("rf_pwrstate=0x%02x\n", pwrpriv->rf_pwrstate);
-	LeaveAllPowerSaveModeDirect(adapter);
-
-	/* Read GPIO Direction */
-	direction = (rtw_read8(adapter,REG_GPIO_PIN_CTRL + 2) & BIT(gpio_num)) >> gpio_num;
-
-	/* According the direction to read register value */
-	if( direction )
-		value =  (rtw_read8(adapter, REG_GPIO_PIN_CTRL + 1)& BIT(gpio_num)) >> gpio_num;
-	else
-		value =  (rtw_read8(adapter, REG_GPIO_PIN_CTRL)& BIT(gpio_num)) >> gpio_num;
-
-	rtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);
-	DBG_871X("%s direction=%d value=%d\n",__FUNCTION__,direction,value);
-
-	return value;
-}
-EXPORT_SYMBOL(rtw_get_gpio);
-
-int  rtw_set_gpio_output_value(struct net_device *netdev, int gpio_num, BOOLEAN isHigh)
-{
-	u8 direction = 0;
-	u8 res = -1;
-	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
-
-	/* Check GPIO is 4~7 */
-	if( gpio_num > 7 || gpio_num < 4)
-	{
-		DBG_871X("%s The gpio number does not included 4~7.\n",__FUNCTION__);
-		return -1;
-	}
-
-	rtw_ps_deny(adapter, PS_DENY_IOCTL);
-
-	LeaveAllPowerSaveModeDirect(adapter);
-
-	/* Read GPIO direction */
-	direction = (rtw_read8(adapter,REG_GPIO_PIN_CTRL + 2) & BIT(gpio_num)) >> gpio_num;
-
-	/* If GPIO is output direction, setting value. */
-	if( direction )
-	{
-		if(isHigh)
-			rtw_write8(adapter, REG_GPIO_PIN_CTRL + 1, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 1) | BIT(gpio_num));
-		else
-			rtw_write8(adapter, REG_GPIO_PIN_CTRL + 1, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 1) & ~BIT(gpio_num));
-
-		DBG_871X("%s Set gpio %x[%d]=%d\n",__FUNCTION__,REG_GPIO_PIN_CTRL+1,gpio_num,isHigh );
-		res = 0;
-	}
-	else
-	{
-		DBG_871X("%s The gpio is input,not be set!\n",__FUNCTION__);
-		res = -1;
-	}
-
-	rtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);
-	return res;
-}
-EXPORT_SYMBOL(rtw_set_gpio_output_value);
-
-int rtw_config_gpio(struct net_device *netdev, int gpio_num, BOOLEAN isOutput)
-{
-	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
-
-	if( gpio_num > 7 || gpio_num < 4)
-	{
-		DBG_871X("%s The gpio number does not included 4~7.\n",__FUNCTION__);
-		return -1;
-	}
-
-	DBG_871X("%s gpio_num =%d direction=%d\n",__FUNCTION__,gpio_num,isOutput);
-
-	rtw_ps_deny(adapter, PS_DENY_IOCTL);
-
-	LeaveAllPowerSaveModeDirect(adapter);
-
-	if( isOutput )
-	{
-		rtw_write8(adapter, REG_GPIO_PIN_CTRL + 2, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 2) | BIT(gpio_num));
-	}
-	else
-	{
-		rtw_write8(adapter, REG_GPIO_PIN_CTRL + 2, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 2) & ~BIT(gpio_num));
-	}
-
-	rtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);
 
-	return 0;
-}
-EXPORT_SYMBOL(rtw_config_gpio);
-#endif
 
 #if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
 void rtw_get_current_ip_address(PADAPTER padapter, u8 *pcurrentip)
@@ -3836,9 +4082,13 @@ int rtw_dev_nlo_info_set(struct pno_nlo_info *nlo_info, pno_ssid_t* ssid,
 
 	nlo_info->fast_scan_period = pno_time;
 	nlo_info->ssid_num = num & BIT_LEN_MASK_32(8);
+	nlo_info->hidden_ssid_num = num & BIT_LEN_MASK_32(8);
 	nlo_info->slow_scan_period = (pno_time * 2);
 	nlo_info->fast_scan_iterations = 5;
 
+	if (nlo_info->hidden_ssid_num > 8)
+		nlo_info->hidden_ssid_num = 8;
+
 	//TODO: channel list and probe index is all empty.
 	for (i = 0 ; i < num ; i++) {
 		nlo_info->ssid_length[i]
@@ -3888,6 +4138,7 @@ int rtw_dev_ssid_list_set(struct pno_ssid_list *pno_ssid_list,
 	for (i = 0 ; i < num ; i++) {
 		_rtw_memcpy(&pno_ssid_list->node[i].SSID,
 			ssid[i].SSID, ssid[i].SSID_len);
+		pno_ssid_list->node[i].SSID_len = ssid[i].SSID_len;
 	}
 	return 0;
 }
@@ -3954,9 +4205,12 @@ int rtw_dev_pno_set(struct net_device *net, pno_ssid_t* ssid, int num,
 		pwrctl->pscan_info == NULL ||
 		pwrctl->pno_ssid_list == NULL){
 		DBG_871X("%s, ERROR: alloc nlo_info, ssid_list, scan_info fail\n", __func__);
-		return -1;
+		goto failing;
 	}
 
+	pwrctl->pno_in_resume = _FALSE;
+
+	pwrctl->pno_inited = _TRUE;
 	/* NLO Info */
 	ret = rtw_dev_nlo_info_set(pwrctl->pnlo_info, ssid, num,
 			pno_time, pno_repeat, pno_freq_expo_max);
@@ -3972,6 +4226,22 @@ int rtw_dev_pno_set(struct net_device *net, pno_ssid_t* ssid, int num,
 		 __func__, num, pno_time, pno_repeat, pno_freq_expo_max);
 
 	return 0;
+
+failing:
+	if (pwrctl->pnlo_info) {
+		rtw_mfree((u8 *)pwrctl->pnlo_info, sizeof(pno_nlo_info_t));
+		pwrctl->pnlo_info = NULL;
+	}
+	if (pwrctl->pno_ssid_list) {
+		rtw_mfree((u8 *)pwrctl->pno_ssid_list, sizeof(pno_ssid_list_t));
+		pwrctl->pno_ssid_list = NULL;
+	}
+	if (pwrctl->pscan_info) {
+		rtw_mfree((u8 *)pwrctl->pscan_info, sizeof(pno_scan_info_t));
+		pwrctl->pscan_info = NULL;
+	}
+
+	return -1;
 }
 
 #ifdef CONFIG_PNO_SET_DEBUG
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_xmit.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_xmit.c
old mode 100644
new mode 100755
index 6dc62174707a..581113925c23
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_xmit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/core/rtw_xmit.c
@@ -68,9 +68,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 	struct xmit_buf *pxmitbuf;
 	struct xmit_frame *pxframe;
 	sint	res=_SUCCESS;   
-	u32 max_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ;
-	u32 num_xmit_extbuf = NR_XMIT_EXTBUFF;
-
+	
 _func_enter_;   	
 
 	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
@@ -201,7 +199,7 @@ _func_enter_;
 	/* init xframe_ext queue,  the same count as extbuf  */
 	_rtw_init_queue(&pxmitpriv->free_xframe_ext_queue);
 	
-	pxmitpriv->xframe_ext_alloc_addr = rtw_zvmalloc(num_xmit_extbuf * sizeof(struct xmit_frame) + 4);
+	pxmitpriv->xframe_ext_alloc_addr = rtw_zvmalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_frame) + 4);
 	
 	if (pxmitpriv->xframe_ext_alloc_addr  == NULL){
 		pxmitpriv->xframe_ext = NULL;
@@ -212,7 +210,7 @@ _func_enter_;
 	pxmitpriv->xframe_ext = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->xframe_ext_alloc_addr), 4);
 	pxframe = (struct xmit_frame*)pxmitpriv->xframe_ext;
 
-	for (i = 0; i < num_xmit_extbuf; i++) {
+	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
 		_rtw_init_listhead(&(pxframe->list));
 
 		pxframe->padapter = padapter;
@@ -229,12 +227,12 @@ _func_enter_;
 
 		pxframe++;
 	}
-	pxmitpriv->free_xframe_ext_cnt = num_xmit_extbuf;
+	pxmitpriv->free_xframe_ext_cnt = NR_XMIT_EXTBUFF;
 
 	// Init xmit extension buff
 	_rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue);
 
-	pxmitpriv->pallocated_xmit_extbuf = rtw_zvmalloc(num_xmit_extbuf * sizeof(struct xmit_buf) + 4);
+	pxmitpriv->pallocated_xmit_extbuf = rtw_zvmalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
 	
 	if (pxmitpriv->pallocated_xmit_extbuf  == NULL){
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_extbuf fail!\n"));
@@ -246,7 +244,7 @@ _func_enter_;
 
 	pxmitbuf = (struct xmit_buf*)pxmitpriv->pxmit_extbuf;
 
-	for (i = 0; i < num_xmit_extbuf; i++)
+	for (i = 0; i < NR_XMIT_EXTBUFF; i++)
 	{
 		_rtw_init_listhead(&pxmitbuf->list);
 
@@ -254,14 +252,14 @@ _func_enter_;
 		pxmitbuf->padapter = padapter;
 		pxmitbuf->buf_tag = XMITBUF_MGNT;
 
-		if((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,max_xmit_extbuf_size + XMITBUF_ALIGN_SZ, _TRUE)) == _FAIL) {
+		if((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ, _TRUE)) == _FAIL) {
 			res= _FAIL;
 			goto exit;
 		}
 		
 #if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 		pxmitbuf->phead = pxmitbuf->pbuf;
-		pxmitbuf->pend = pxmitbuf->pbuf + max_xmit_extbuf_size;
+		pxmitbuf->pend = pxmitbuf->pbuf + MAX_XMIT_EXTBUF_SZ;
 		pxmitbuf->len = 0;
 		pxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;
 #endif
@@ -274,29 +272,30 @@ _func_enter_;
 		
 	}
 
-	pxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf;
+	pxmitpriv->free_xmit_extbuf_cnt = NR_XMIT_EXTBUFF;
 
+	for (i = 0; i<CMDBUF_MAX; i++) {
+		pxmitbuf = &pxmitpriv->pcmd_xmitbuf[i];
+		if (pxmitbuf) {
+			_rtw_init_listhead(&pxmitbuf->list);
 
-	pxmitbuf = &pxmitpriv->pcmd_xmitbuf;
-	if (pxmitbuf) {
-		_rtw_init_listhead(&pxmitbuf->list);
-
-		pxmitbuf->priv_data = NULL;
-		pxmitbuf->padapter = padapter;
-		pxmitbuf->buf_tag = XMITBUF_CMD;
+			pxmitbuf->priv_data = NULL;
+			pxmitbuf->padapter = padapter;
+			pxmitbuf->buf_tag = XMITBUF_CMD;
 
-		if((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf, MAX_CMDBUF_SZ+XMITBUF_ALIGN_SZ, _TRUE)) == _FAIL) {
-			res= _FAIL;
-			goto exit;
-		}
+			if((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf, MAX_CMDBUF_SZ+XMITBUF_ALIGN_SZ, _TRUE)) == _FAIL) {
+				res= _FAIL;
+				goto exit;
+			}
 
 #if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
-		pxmitbuf->phead = pxmitbuf->pbuf;
-		pxmitbuf->pend = pxmitbuf->pbuf + MAX_CMDBUF_SZ;
-		pxmitbuf->len = 0;
-		pxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;
+			pxmitbuf->phead = pxmitbuf->pbuf;
+			pxmitbuf->pend = pxmitbuf->pbuf + MAX_CMDBUF_SZ;
+			pxmitbuf->len = 0;
+			pxmitbuf->pdata = pxmitbuf->ptail = pxmitbuf->phead;
 #endif
-		pxmitbuf->alloc_sz = MAX_CMDBUF_SZ+XMITBUF_ALIGN_SZ;
+			pxmitbuf->alloc_sz = MAX_CMDBUF_SZ+XMITBUF_ALIGN_SZ;
+		}
 	}
 
 	rtw_alloc_hwxmits(padapter);
@@ -363,15 +362,7 @@ void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv)
       _adapter *padapter = pxmitpriv->adapter;
 	struct xmit_frame	*pxmitframe = (struct xmit_frame*) pxmitpriv->pxmit_frame_buf;
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
-	u32 max_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ;
-	u32 num_xmit_extbuf = NR_XMIT_EXTBUFF;
-#if defined(CONFIG_MP_INCLUDED) && (defined(CONFIG_RTL8723A) ||defined(CONFIG_RTL8723B))
-	if (padapter->registrypriv.mp_mode) {
-		max_xmit_extbuf_size = 20000;
-		num_xmit_extbuf = 1;
-	}
-#endif
-
+	
  _func_enter_;   
 
 	rtw_hal_free_xmit_priv(padapter);
@@ -406,33 +397,35 @@ void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv)
 
 	/* free xframe_ext queue,  the same count as extbuf  */
 	if ((pxmitframe = (struct xmit_frame*)pxmitpriv->xframe_ext)) {
-		for (i=0; i<num_xmit_extbuf; i++) {
+		for (i=0; i<NR_XMIT_EXTBUFF; i++) {
 			rtw_os_xmit_complete(padapter, pxmitframe);
 			pxmitframe++;
 		}
 	}
 	if (pxmitpriv->xframe_ext_alloc_addr)
-		rtw_vmfree(pxmitpriv->xframe_ext_alloc_addr, num_xmit_extbuf * sizeof(struct xmit_frame) + 4);
+		rtw_vmfree(pxmitpriv->xframe_ext_alloc_addr, NR_XMIT_EXTBUFF * sizeof(struct xmit_frame) + 4);
 	_rtw_spinlock_free(&pxmitpriv->free_xframe_ext_queue.lock);
 
 	// free xmit extension buff
 	_rtw_spinlock_free(&pxmitpriv->free_xmit_extbuf_queue.lock);
 
 	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
-	for(i=0; i<num_xmit_extbuf; i++)
+	for(i=0; i<NR_XMIT_EXTBUFF; i++)
 	{
-		rtw_os_xmit_resource_free(padapter, pxmitbuf,(max_xmit_extbuf_size + XMITBUF_ALIGN_SZ), _TRUE);
+		rtw_os_xmit_resource_free(padapter, pxmitbuf,(MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ), _TRUE);
 		
 		pxmitbuf++;
 	}
 
 	if(pxmitpriv->pallocated_xmit_extbuf) {
-		rtw_vmfree(pxmitpriv->pallocated_xmit_extbuf, num_xmit_extbuf * sizeof(struct xmit_buf) + 4);
+		rtw_vmfree(pxmitpriv->pallocated_xmit_extbuf, NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
 	}
 
-	pxmitbuf = &pxmitpriv->pcmd_xmitbuf;
-	if(pxmitbuf!=NULL)
-		rtw_os_xmit_resource_free(padapter, pxmitbuf, MAX_CMDBUF_SZ+XMITBUF_ALIGN_SZ , _TRUE);
+	for (i=0; i<CMDBUF_MAX; i++) {
+		pxmitbuf = &pxmitpriv->pcmd_xmitbuf[i];
+		if(pxmitbuf!=NULL)
+			rtw_os_xmit_resource_free(padapter, pxmitbuf, MAX_CMDBUF_SZ+XMITBUF_ALIGN_SZ , _TRUE);
+	}
 
 	rtw_free_hwxmits(padapter);
 
@@ -455,7 +448,6 @@ u8	query_ra_short_GI(struct sta_info *psta)
 	if (psta->vhtpriv.vht_option) {
 		sgi_80m= psta->vhtpriv.sgi_80m;
 	}
-	else
 #endif //CONFIG_80211AC_VHT
 	{
 		sgi_20m = psta->htpriv.sgi_20m;
@@ -612,18 +604,28 @@ static void update_attrib_vcs_info(_adapter *padapter, struct xmit_frame *pxmitf
 			break;
 		}
 	}
+
+	//for debug : force driver control vrtl_carrier_sense.
+	if(padapter->driver_vcs_en==1)
+	{
+		//u8 driver_vcs_en; //Enable=1, Disable=0 driver control vrtl_carrier_sense.
+		//u8 driver_vcs_type;//force 0:disable VCS, 1:RTS-CTS, 2:CTS-to-self when vcs_en=1.
+		pattrib->vcs_mode = padapter->driver_vcs_type;
+	}	
+	
 }
 
 static void update_attrib_phy_info(_adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta)
 {
 	struct mlme_ext_priv *mlmeext = &padapter->mlmeextpriv;
-	
+
 	pattrib->rtsen = psta->rtsen;
 	pattrib->cts2self = psta->cts2self;
 	
 	pattrib->mdata = 0;
 	pattrib->eosp = 0;
 	pattrib->triggered=0;
+	pattrib->ampdu_spacing = 0;
 	
 	//qos_en, ht_en, init rate, ,bw, ch_offset, sgi
 	pattrib->qos_en = psta->qos_option;
@@ -644,6 +646,11 @@ static void update_attrib_phy_info(_adapter *padapter, struct pkt_attrib *pattri
 	pattrib->ht_en = psta->htpriv.ht_option;
 	pattrib->ch_offset = psta->htpriv.ch_offset;
 	pattrib->ampdu_en = _FALSE;
+
+	if(padapter->driver_ampdu_spacing != 0xFF) //driver control AMPDU Density for peer sta's rx
+		pattrib->ampdu_spacing = padapter->driver_ampdu_spacing;
+	else
+		pattrib->ampdu_spacing = psta->htpriv.rx_ampdu_min_spacing;
 #endif //CONFIG_80211N_HT
 	//if(pattrib->ht_en && psta->htpriv.ampdu_enable)
 	//{
@@ -956,6 +963,18 @@ s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 
 #endif //CONFIG_TDLS
 
+//get non-qos hw_ssn control register,mapping to REG_HW_SEQ0,1,2,3
+inline u8 rtw_get_hwseq_no(_adapter *padapter)
+{
+	u8 hwseq_num = 0;
+#ifdef CONFIG_CONCURRENT_MODE
+	if(padapter->adapter_type == SECONDARY_ADAPTER)
+		hwseq_num = 1;
+	//else
+	//	hwseq_num = 2;
+#endif //CONFIG_CONCURRENT_MODE
+	return hwseq_num;
+}
 static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattrib)
 {
 	uint i;
@@ -966,12 +985,15 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 	sint bmcast;
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct qos_priv		*pqospriv= &pmlmepriv->qospriv;
+	struct xmit_priv 		*pxmitpriv = &padapter->xmitpriv;
 	sint res = _SUCCESS;
 
  _func_enter_;
 
+	DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib);
+
 	_rtw_open_pktfile(pkt, &pktfile);
 	i = _rtw_pktfile_read(&pktfile, (u8*)&etherhdr, ETH_HLEN);
 
@@ -985,16 +1007,21 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
 		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
-		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, myid(&padapter->eeprompriv), ETH_ALEN);
+		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_adhoc);
 	}
 	else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
 		_rtw_memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+		_rtw_memcpy(pattrib->ta, myid(&padapter->eeprompriv), ETH_ALEN);
+		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_sta);
 	}
 	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
 		_rtw_memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
-	}
+		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_ap);
+	} 
+	else
+		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_unknown);
 
 #ifdef CONFIG_TDLS
 	rtw_check_tdls_established(padapter, pattrib);
@@ -1029,6 +1056,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 					//	pTcb->DataRate = Adapter->MgntInfo.LowestBasicRate; 
 					//RTPRINT(FDM, WA_IOT, ("DHCP TranslateHeader(), pTcb->DataRate = 0x%x\n", pTcb->DataRate)); 
 					pattrib->dhcp_pkt = 1;
+					DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_dhcp);
 				}
 			}
 		}
@@ -1039,7 +1067,10 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 
 			pattrib->icmp_pkt = 0;	
 			if(piphdr->protocol == 0x1) // protocol type in ip header 0x1 is ICMP			
+			{
 				pattrib->icmp_pkt = 1;
+				DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_icmp);
+			}
 		}	
 
 		
@@ -1069,6 +1100,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 #endif 
 #endif
 	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_active);
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SPECIAL_PACKET, 1);
 	}
 #endif //CONFIG_LPS
@@ -1080,7 +1112,8 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 		psta = rtw_get_bcmc_stainfo(padapter);
 	} else {
 		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
-		if (psta == NULL)	{ // if we cannot get psta => drrp the pkt
+		if (psta == NULL)	{ // if we cannot get psta => drop the pkt
+			DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_err_ucast_sta);
 			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail, ra:" MAC_FMT"\n", MAC_ARG(pattrib->ra)));
 			#ifdef DBG_TX_DROP_FRAME
 			DBG_871X("DBG_TX_DROP_FRAME %s get sta_info fail, ra:" MAC_FMT"\n", __FUNCTION__, MAC_ARG(pattrib->ra));
@@ -1090,6 +1123,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 		}
 		else if((check_fwstate(pmlmepriv, WIFI_AP_STATE)==_TRUE)&&(!(psta->state & _FW_LINKED)))
 		{
+			DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_err_ucast_ap_link);
 			res =_FAIL;
 			goto exit;
 		}
@@ -1097,6 +1131,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 
 	if(psta == NULL)
 	{		// if we cannot get psta => drop the pkt
+		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_err_sta);
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail, ra:" MAC_FMT "\n", MAC_ARG(pattrib->ra)));
 		#ifdef DBG_TX_DROP_FRAME
 		DBG_871X("DBG_TX_DROP_FRAME %s get sta_info fail, ra:" MAC_FMT"\n", __FUNCTION__, MAC_ARG(pattrib->ra));
@@ -1107,6 +1142,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 
 	if(!(psta->state &_FW_LINKED))
 	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_err_link);
 		DBG_871X("%s, psta("MAC_FMT")->state(0x%x) != _FW_LINKED\n", __func__, MAC_ARG(psta->hwaddr), psta->state);
 		return _FAIL;
 	}
@@ -1116,6 +1152,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 	//TODO:_lock
 	if(update_attrib_sec_info(padapter, pattrib, psta) == _FAIL)
 	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_upd_attrib_err_sec);
 		res = _FAIL;
 		goto exit;
 	}
@@ -1156,7 +1193,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 	}
 
 	//pattrib->priority = 5; //force to used VI queue, for testing
-
+	pattrib->hw_ssn_sel = pxmitpriv->hw_ssn_seq_no;
 	rtw_set_tx_chksum_offload(pkt, pattrib);
 
 exit:
@@ -1409,8 +1446,6 @@ _func_enter_;
 	if (pattrib->subtype & WIFI_DATA_TYPE)
 	{
 		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == _TRUE)) {
-			//to_ds = 1, fr_ds = 0;
-
 #ifdef CONFIG_TDLS
 			if(pattrib->direct_link == _TRUE){
 				//TDLS data transfer, ToDS=0, FrDs=0
@@ -1421,11 +1456,12 @@ _func_enter_;
 			else
 #endif //CONFIG_TDLS
 			{
+				//to_ds = 1, fr_ds = 0;
 				// 1.Data transfer to AP
 				// 2.Arp pkt will relayed by AP
 				SetToDs(fctrl);							
 				_rtw_memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
-				_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+				_rtw_memcpy(pwlanhdr->addr2, pattrib->ta, ETH_ALEN);
 				_rtw_memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
 			} 
 
@@ -1446,7 +1482,7 @@ _func_enter_;
 		else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
 			_rtw_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
-			_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, pattrib->ta, ETH_ALEN);
 			_rtw_memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
 
 			if(pattrib->qos_en)
@@ -2218,7 +2254,7 @@ _func_enter_;
 		int frame_body_len;
 		u8 mic[16];
 		
-		_rtw_memset(MME, 0, 18);
+		_rtw_memset(MME, 0, _MME_IE_LENGTH_);
 				
 		//other types doesn't need the BIP
 		if(GetFrameSubType(pframe) != WIFI_DEAUTH && GetFrameSubType(pframe) != WIFI_DISASSOC)
@@ -2530,13 +2566,14 @@ void rtw_count_tx_stats(PADAPTER padapter, struct xmit_frame *pxmitframe, int sz
 	}
 }
 
-struct xmit_buf *rtw_alloc_cmd_xmitbuf(struct xmit_priv *pxmitpriv)
+static struct xmit_buf *__rtw_alloc_cmd_xmitbuf(struct xmit_priv *pxmitpriv,
+		enum cmdbuf_type buf_type)
 {
 	struct xmit_buf *pxmitbuf =  NULL;
 
 _func_enter_;
 
-	pxmitbuf = &pxmitpriv->pcmd_xmitbuf;
+	pxmitbuf = &pxmitpriv->pcmd_xmitbuf[buf_type];
 	if (pxmitbuf !=  NULL) {
 		pxmitbuf->priv_data = NULL;
 
@@ -2548,6 +2585,7 @@ _func_enter_;
 #endif
 #ifdef CONFIG_PCI_HCI
 		pxmitbuf->len = 0;
+		pxmitbuf->desc = NULL;
 #endif
 
 		if (pxmitbuf->sctx) {
@@ -2565,27 +2603,8 @@ _func_exit_;
 	return pxmitbuf;
 }
 
-s32	rtw_free_cmd_xmitbuf(struct xmit_priv *pxmitpriv)
-{
-	struct xmit_buf *pxmitbuf =  NULL;
-
-_func_enter_;
-
-	pxmitbuf = &pxmitpriv->pcmd_xmitbuf;
-	if (pxmitbuf==NULL) {
-		DBG_871X("%s fail, no xmitbuf available !!!\n", __func__);
-		return _FAIL;
-	} else {
-		rtw_os_xmit_resource_free(pxmitbuf->padapter, pxmitbuf, pxmitbuf->alloc_sz, _FALSE);
-		pxmitbuf->pallocated_buf = NULL;
-	}
-
-_func_exit_;
-
-	return _SUCCESS;
-}
-
-struct xmit_frame *rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv)
+struct xmit_frame *__rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv,
+		enum cmdbuf_type buf_type)
 {
 	struct xmit_frame		*pcmdframe;
 	struct xmit_buf		*pxmitbuf;
@@ -2596,7 +2615,7 @@ struct xmit_frame *rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv)
 		return NULL;
 	}
 
-	if ((pxmitbuf = rtw_alloc_cmd_xmitbuf(pxmitpriv)) == NULL) {
+	if ((pxmitbuf = __rtw_alloc_cmd_xmitbuf(pxmitpriv, buf_type)) == NULL) {
 		DBG_871X("%s, alloc xmitbuf fail\n", __FUNCTION__);
 		rtw_free_xmitframe(pxmitpriv, pcmdframe);
 		return NULL;
@@ -2655,6 +2674,7 @@ _func_enter_;
 #endif
 #ifdef CONFIG_PCI_HCI
 		pxmitbuf->len = 0;
+		pxmitbuf->desc = NULL;
 #endif
 
 		if (pxmitbuf->sctx) {
@@ -2744,6 +2764,7 @@ _func_enter_;
 #endif
 #ifdef CONFIG_PCI_HCI
 		pxmitbuf->len = 0;
+		pxmitbuf->desc = NULL;
 #endif
 
 		if (pxmitbuf->sctx) {
@@ -2992,7 +3013,7 @@ _func_enter_;
 	else if(pxmitframe->ext_tag == 1)
 		queue = &pxmitpriv->free_xframe_ext_queue;
 	else
-	{}
+		rtw_warn_on(1);
 
 	_enter_critical_bh(&queue->lock, &irqL);
 
@@ -3051,6 +3072,7 @@ _func_exit_;
 
 s32 rtw_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
+	DBG_COUNTER(padapter->tx_logs.core_tx_enqueue);
 	if (rtw_xmit_classifier(padapter, pxmitframe) == _FAIL)
 	{
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
@@ -3098,7 +3120,7 @@ static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv, str
 
 		break;		
 
-		pxmitframe = NULL;
+		//pxmitframe = NULL;
 
 	}
 
@@ -3317,6 +3339,8 @@ s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe)
 
 _func_enter_;
 
+	DBG_COUNTER(padapter->tx_logs.core_tx_enqueue_class);
+
 /*
 	if (pattrib->psta) {
 		psta = pattrib->psta;		
@@ -3329,11 +3353,13 @@ _func_enter_;
 	psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
 	if(pattrib->psta != psta)
 	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_enqueue_class_err_sta);
 		DBG_871X("%s, pattrib->psta(%p) != psta(%p)\n", __func__, pattrib->psta, psta);
 		return _FAIL;
 	}
 
 	if (psta == NULL) {
+		DBG_COUNTER(padapter->tx_logs.core_tx_enqueue_class_err_nosta);
 		res = _FAIL;
 		DBG_8192C("rtw_xmit_classifier: psta == NULL\n");
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("rtw_xmit_classifier: psta == NULL\n"));
@@ -3342,6 +3368,7 @@ _func_enter_;
 
 	if(!(psta->state &_FW_LINKED))
 	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_enqueue_class_err_fwlink);
 		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
 		return _FAIL;
 	}
@@ -3727,6 +3754,8 @@ s32 rtw_xmit(_adapter *padapter, _pkt **ppkt)
 
 	s32 res;
 
+	DBG_COUNTER(padapter->tx_logs.core_tx);
+
 	if (start == 0)
 		start = rtw_get_current_time();
 
@@ -3742,6 +3771,7 @@ s32 rtw_xmit(_adapter *padapter, _pkt **ppkt)
 	if (pxmitframe == NULL) {
 		drop_cnt ++;
 		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit: no more pxmitframe\n"));
+		DBG_COUNTER(padapter->tx_logs.core_tx_err_pxmitframe);
 		return -1;
 	}
 
@@ -3761,6 +3791,7 @@ s32 rtw_xmit(_adapter *padapter, _pkt **ppkt)
 		if (res == -1)
 		{
 			rtw_free_xmitframe(pxmitpriv, pxmitframe);
+			DBG_COUNTER(padapter->tx_logs.core_tx_err_brtx);
 			return -1;
 		}
 	}	
@@ -3798,11 +3829,13 @@ s32 rtw_xmit(_adapter *padapter, _pkt **ppkt)
 	if(xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == _TRUE)
 	{
 		_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+		DBG_COUNTER(padapter->tx_logs.core_tx_ap_enqueue);
 		return 1;		
 	}
 	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
 #endif
 
+	//pre_xmitframe
 	if (rtw_hal_xmit(padapter, pxmitframe) == _FALSE)
 		return 1;
 
@@ -3884,6 +3917,47 @@ sint xmitframe_enqueue_for_tdls_sleeping_sta(_adapter *padapter, struct xmit_fra
 }
 #endif //CONFIG_TDLS
 
+#define RTW_HIQ_FILTER_ALLOW_ALL 0
+#define RTW_HIQ_FILTER_ALLOW_SPECIAL 1
+#define RTW_HIQ_FILTER_DENY_ALL 2
+
+inline bool xmitframe_hiq_filter(struct xmit_frame *xmitframe)
+{
+	bool allow = _FALSE;
+	_adapter *adapter = xmitframe->padapter;
+	struct registry_priv *registry = &adapter->registrypriv;
+
+if (adapter->interface_type != RTW_PCIE) {
+
+	if (registry->hiq_filter == RTW_HIQ_FILTER_ALLOW_SPECIAL) {
+	
+		struct pkt_attrib *attrib = &xmitframe->attrib;
+
+		if (attrib->ether_type == 0x0806
+			|| attrib->ether_type == 0x888e
+			#ifdef CONFIG_WAPI_SUPPORT
+			|| attrib->ether_type == 0x88B4
+			#endif
+			|| attrib->dhcp_pkt
+		) {
+			if (0)
+			DBG_871X(FUNC_ADPT_FMT" ether_type:0x%04x%s\n", FUNC_ADPT_ARG(xmitframe->padapter)
+				, attrib->ether_type, attrib->dhcp_pkt?" DHCP":"");
+			allow = _TRUE;
+		}
+	}
+	else if (registry->hiq_filter == RTW_HIQ_FILTER_ALLOW_ALL) {
+		allow = _TRUE;
+	}
+	else if (registry->hiq_filter == RTW_HIQ_FILTER_DENY_ALL) {
+	}
+	else {
+		rtw_warn_on(1);
+	}
+}
+	return allow;
+}
+
 #if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
 
 sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -3905,7 +3979,10 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 #endif //CONFIG_TDLS
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _FALSE)
+	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_ap_enqueue_warn_fwstate);
 	    return ret;
+	}
 /*
 	if(pattrib->psta)
 	{
@@ -3920,31 +3997,33 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 	psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
 	if(pattrib->psta != psta)
 	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_ap_enqueue_warn_sta);
 		DBG_871X("%s, pattrib->psta(%p) != psta(%p)\n", __func__, pattrib->psta, psta);
 		return _FALSE;
 	}
 
 	if(psta==NULL)
 	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_ap_enqueue_warn_nosta);
 		DBG_871X("%s, psta==NUL\n", __func__);
 		return _FALSE;
 	}
 
 	if(!(psta->state &_FW_LINKED))
 	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_ap_enqueue_warn_link);
 		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
 		return _FALSE;
 	}
 
 	if(pattrib->triggered==1)
 	{
+		DBG_COUNTER(padapter->tx_logs.core_tx_ap_enqueue_warn_trigger);
 		//DBG_871X("directly xmit pspoll_triggered packet\n");
 
 		//pattrib->triggered=0;
-
-		if(bmcst)
-			pattrib->qsel = 0x11;//HIQ
-		
+		if (bmcst && xmitframe_hiq_filter(pxmitframe) == _TRUE)
+			pattrib->qsel = QSLT_HIGH;//HIQ
 
 		return ret;
 	}
@@ -3956,7 +4035,7 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 	
 		if(pstapriv->sta_dz_bitmap)//if anyone sta is in ps mode
 		{
-			//pattrib->qsel = 0x11;//HIQ
+			//pattrib->qsel = QSLT_HIGH;//HIQ
 			
 			rtw_list_delete(&pxmitframe->list);
 			
@@ -3975,7 +4054,10 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 			//DBG_871X("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
 			if (update_tim == _TRUE) {
-				update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
+				if (is_broadcast_mac_addr(pattrib->ra))
+					_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "buffer BC");
+				else
+					_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "buffer MC");
 			} else {
 				chk_bmc_sleepq_cmd(padapter);
 			}
@@ -3983,6 +4065,8 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);				
 			
 			ret = _TRUE;			
+
+			DBG_COUNTER(padapter->tx_logs.core_tx_ap_enqueue_mcast);
 			
 		}
 		
@@ -4046,7 +4130,7 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 				{
 					//DBG_871X("sleepq_len==1, update BCNTIM\n");
 					//upate BCN for TIM IE
-					update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
+					_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "buffer UC");
 				}
 			}
 
@@ -4059,6 +4143,7 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 
 			ret = _TRUE;
 
+			DBG_COUNTER(padapter->tx_logs.core_tx_ap_enqueue_ucast);
 		}
 
 	}
@@ -4086,14 +4171,16 @@ static void dequeue_xmitframes_to_sleeping_queue(_adapter *padapter, struct sta_
 	{			
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
-		plist = get_next(plist);	
+		plist = get_next(plist);
 		
+		pattrib = &pxmitframe->attrib;
+
+		pattrib->triggered = 0;
+  		
 		ret = xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe);	
 
 		if(_TRUE == ret)
 		{
-			pattrib = &pxmitframe->attrib;
-
 			ptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));
 
 			ptxservq->qcnt--;
@@ -4255,6 +4342,41 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 
 	}
 
+	if(psta->sleepq_len==0)
+	{
+#ifdef CONFIG_TDLS
+		if( psta->tdls_sta_state & TDLS_LINKED_STATE )
+		{
+			if(psta->state&WIFI_SLEEP_STATE)
+				psta->state ^= WIFI_SLEEP_STATE;
+
+			_exit_critical_bh(&pxmitpriv->lock, &irqL);
+			return;
+		}
+#endif //CONFIG_TDLS
+
+		if (pstapriv->tim_bitmap & BIT(psta->aid)) {
+			//DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
+			//upate BCN for TIM IE
+			//update_BCNTIM(padapter);
+			update_mask = BIT(0);
+		}
+
+		pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+		if(psta->state&WIFI_SLEEP_STATE)
+			psta->state ^= WIFI_SLEEP_STATE;
+
+		if(psta->state & WIFI_STA_ALIVE_CHK_STATE)
+		{
+			DBG_871X("%s alive check\n", __func__);
+			psta->expire_to = pstapriv->expire_to;
+			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
+		}
+
+		pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
+	}
+
 	//for BC/MC Frames
 	if(!psta_bmc)
 		goto _exit;
@@ -4307,41 +4429,6 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 
 	}	
 
-	if(psta->sleepq_len==0)
-	{
-#ifdef CONFIG_TDLS
-		if( psta->tdls_sta_state & TDLS_LINKED_STATE )
-		{
-			if(psta->state&WIFI_SLEEP_STATE)
-				psta->state ^= WIFI_SLEEP_STATE;
-
-			_exit_critical_bh(&pxmitpriv->lock, &irqL);
-			return;
-		}
-#endif //CONFIG_TDLS
-
-		if (pstapriv->tim_bitmap & BIT(psta->aid)) {
-			//DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
-			//upate BCN for TIM IE
-			//update_BCNTIM(padapter);
-			update_mask = BIT(0);
-		}
-
-		pstapriv->tim_bitmap &= ~BIT(psta->aid);
-
-		if(psta->state&WIFI_SLEEP_STATE)
-			psta->state ^= WIFI_SLEEP_STATE;
-
-		if(psta->state & WIFI_STA_ALIVE_CHK_STATE)
-		{
-			DBG_871X("%s alive check\n", __func__);
-			psta->expire_to = pstapriv->expire_to;
-			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
-	}
-
-		pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
-	}
-
 _exit:
 
 	//_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);	
@@ -4350,8 +4437,12 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 	if(update_mask)
 	{
 		//update_BCNTIM(padapter);
-		//printk("%s => call update_beacon\n",__FUNCTION__);
-		update_beacon(padapter, _TIM_IE_, NULL, _TRUE);
+		if ((update_mask & (BIT(0)|BIT(1))) == (BIT(0)|BIT(1)))
+			_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "clear UC&BMC");
+		else if ((update_mask & BIT(1)) == BIT(1))
+			_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "clear BMC");
+		else
+			_update_beacon(padapter, _TIM_IE_, NULL, _TRUE, "clear UC");
 	}
 	
 }
@@ -4615,6 +4706,7 @@ thread_return rtw_xmit_thread(thread_context context)
 	} while (_SUCCESS == err);
 
 	_rtw_up_sema(&padapter->xmitpriv.terminate_xmitthread_sema);
+
 	thread_exit();
 }
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/HalPwrSeqCmd.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/HalPwrSeqCmd.c
index 425fbefc8b68..972a3d893fa6 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/HalPwrSeqCmd.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/HalPwrSeqCmd.c
@@ -147,7 +147,7 @@ u8 HalPwrSeqCmdParsing(
 							rtw_udelay_os(10);
 
 						if (pollingCount++ > maxPollingCnt) {
-							DBG_871X("Fail to polling Offset[%#x]=%02x\n", offset, value);
+							DBG_871X_LEVEL(_drv_always_, "HalPwrSeqCmdParsing: Fail to polling Offset[%#x]=%02x\n", offset, value);
 							return _FALSE;
 						}
 					} while (!bPollingBit);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.c
index 65cf94e1769f..6e9454ca5cca 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.c
@@ -1724,9 +1724,17 @@ halbtc8188c2ant_ActionPanA2dp(
 // extern function start with EXhalbtc8188c2ant_
 //============================================================
 VOID
-EXhalbtc8188c2ant_InitHwConfig(
+EXhalbtc8188c2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
+{
+}
+
+VOID
+EXhalbtc8188c2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
 {
 	u1Byte	u1Tmp=0;
 
@@ -1766,22 +1774,10 @@ EXhalbtc8188c2ant_DisplayCoexInfo(
 	pu1Byte				cliBuf=pBtCoexist->cliBuf;
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
 	CL_PRINTF(cliBuf);
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);	
@@ -1796,34 +1792,12 @@ EXhalbtc8188c2ant_DisplayCoexInfo(
 		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(HsMode)", \
-		wifiDot11Chnl, wifiHsChnl, bBtHsOn);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 	
 	if(pStackInfo->bProfileNotified)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.h
index 086a87927bf0..ce7ec564414f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8188c2Ant.h
@@ -87,10 +87,15 @@ typedef struct _COEX_STA_8188C_2ANT{
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8188c2ant_InitHwConfig(
+EXhalbtc8188c2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8188c2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8188c2ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.c
index 0a3f31000524..cb60379c9a86 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.c
@@ -1713,9 +1713,17 @@ halbtc8192d2ant_IsBtCoexistEnter(
 // extern function start with EXhalbtc8192d2ant_
 //============================================================
 VOID
-EXhalbtc8192d2ant_InitHwConfig(
+EXhalbtc8192d2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
+{
+}
+
+VOID
+EXhalbtc8192d2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
 {
 	u1Byte	u1Tmp=0;
 
@@ -1772,22 +1780,10 @@ EXhalbtc8192d2ant_DisplayCoexInfo(
 	pu1Byte				cliBuf=pBtCoexist->cliBuf;
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
 	CL_PRINTF(cliBuf);
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);	
@@ -1802,34 +1798,12 @@ EXhalbtc8192d2ant_DisplayCoexInfo(
 		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(HsMode)", \
-		wifiDot11Chnl, wifiHsChnl, bBtHsOn);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 	
 	if(pStackInfo->bProfileNotified)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.h
index 4d3b83879081..85fd6742ca2f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192d2Ant.h
@@ -108,10 +108,15 @@ typedef struct _COEX_STA_8192D_2ANT{
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8192d2ant_InitHwConfig(
+EXhalbtc8192d2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8192d2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8192d2ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.c
index a9b90c6acd63..12dfe4b210eb 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.c
@@ -2437,9 +2437,17 @@ halbtc8192e1ant_InitCoexDm(
 // extern function start with EXhalbtc8192e1ant_
 //============================================================
 VOID
-EXhalbtc8192e1ant_InitHwConfig(
+EXhalbtc8192e1ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
+{
+}
+
+VOID
+EXhalbtc8192e1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
 {
 	u4Byte	u4Tmp=0;
 	u2Byte	u2Tmp=0;
@@ -2511,11 +2519,6 @@ EXhalbtc8192e1ant_DisplayCoexInfo(
 	pu1Byte				cliBuf=pBtCoexist->cliBuf;
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
 	u4Byte				fwVer=0, btPatchVer=0;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
@@ -2536,13 +2539,6 @@ EXhalbtc8192e1ant_DisplayCoexInfo(
 		CL_PRINTF(cliBuf);
 	}
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);	
@@ -2557,40 +2553,19 @@ EXhalbtc8192e1ant_DisplayCoexInfo(
 		GLCoexVerDate8192e1Ant, GLCoexVer8192e1Ant, fwVer, btPatchVer, btPatchVer);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(HsMode)", \
-		wifiDot11Chnl, wifiHsChnl, bBtHsOn);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
-	CL_PRINTF(cliBuf);
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
 		((pBtCoexist->btInfo.bBtDisabled)? ("disabled"):	((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8192E_1ANT_BT_STATUS_NON_CONNECTED_IDLE == pCoexDm->btStatus)? "non-connected idle":
 		(  (BT_8192E_1ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy")))),
@@ -2619,17 +2594,6 @@ EXhalbtc8192e1ant_DisplayCoexInfo(
 			CL_PRINTF(cliBuf);
 		}
 	}
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/%s, (0x%x/0x%x)", "PS state, IPS/LPS, (lps/rpwm)", \
-		((pCoexSta->bUnderIps? "IPS ON":"IPS OFF")),
-		((pCoexSta->bUnderLps? "LPS ON":"LPS OFF")), 
-		pBtCoexist->btInfo.lpsVal, 
-		pBtCoexist->btInfo.rpwmVal);
-	CL_PRINTF(cliBuf);
-	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_FW_PWR_MODE_CMD);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "SS Type", \
-		pCoexDm->curSsType);
-	CL_PRINTF(cliBuf);
 
 	if(!pBtCoexist->bManualControl)
 	{
@@ -2637,10 +2601,6 @@ EXhalbtc8192e1ant_DisplayCoexInfo(
 		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
 		CL_PRINTF(cliBuf);
 	
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d(0x%x) ", "SM[SwDacSwing(lvl)]", \
-			pCoexDm->bCurDacSwingOn, pCoexDm->curDacSwingLvl);
-		CL_PRINTF(cliBuf);
-
 		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s/ %d ", "DelBA/ BtCtrlAgg/ AggSize", \
 			(pBtCoexist->btInfo.bRejectAggPkt? "Yes":"No"), (pBtCoexist->btInfo.bBtCtrlAggBufSize? "Yes":"No"),
 				pBtCoexist->btInfo.aggBufSize);
@@ -2664,8 +2624,8 @@ EXhalbtc8192e1ant_DisplayCoexInfo(
 			pCoexDm->errorCondition);
 		CL_PRINTF(cliBuf);
 		
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "DecBtPwrLvl/ IgnWlanAct", \
-			pCoexDm->curBtDecPwrLvl, pCoexDm->bCurIgnoreWlanAct);
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "IgnWlanAct", \
+			pCoexDm->bCurIgnoreWlanAct);
 		CL_PRINTF(cliBuf);
 	}
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.h
index 7a1ce5ae1b1d..8792ec8d381c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e1Ant.h
@@ -140,10 +140,15 @@ typedef struct _COEX_STA_8192E_1ANT{
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8192e1ant_InitHwConfig(
+EXhalbtc8192e1ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8192e1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8192e1ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.c
index a1b8f274e670..8bde294c93f2 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.c
@@ -1697,7 +1697,8 @@ halbtc8192e2ant_SetSwitchSsType(
 		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xd04, 0x1);
 		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x90c, 0x81111111);
 		// switch cck patch
-		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xe77, 0x4, 0x1);
+		//Jenyu suggest to remove 0xe77 this line for tx issue
+		//pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xe77, 0x4, 0x1);
 		//pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xa07, 0x81);
 		mimoPs=BTC_MIMO_PS_STATIC;
 	}
@@ -1707,7 +1708,8 @@ halbtc8192e2ant_SetSwitchSsType(
 		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xc04, 0x33);
 		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xd04, 0x3);
 		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x90c, 0x81121313);
-		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xe77, 0x4, 0x0);
+                //Jenyu suggest to remove 0xe77 this line for tx issue
+		//pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xe77, 0x4, 0x0);
 		//pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xa07, 0x41);
 		mimoPs=BTC_MIMO_PS_DYNAMIC;
 	}
@@ -3791,9 +3793,17 @@ halbtc8192e2ant_InitHwConfig(
 // extern function start with EXhalbtc8192e2ant_
 //============================================================
 VOID
-EXhalbtc8192e2ant_InitHwConfig(
+EXhalbtc8192e2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
+{
+}
+
+VOID
+EXhalbtc8192e2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
 {
 	halbtc8192e2ant_InitHwConfig(pBtCoexist, TRUE);
 }
@@ -3819,11 +3829,7 @@ EXhalbtc8192e2ant_DisplayCoexInfo(
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u2Byte				u2Tmp[4];
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir, faOfdm, faCck;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
+	u4Byte				faOfdm, faCck;
 	u4Byte				fwVer=0, btPatchVer=0;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
@@ -3837,13 +3843,6 @@ EXhalbtc8192e2ant_DisplayCoexInfo(
 		CL_PRINTF(cliBuf);
 	}
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);
@@ -3858,39 +3857,17 @@ EXhalbtc8192e2ant_DisplayCoexInfo(
 		GLCoexVerDate8192e2Ant, GLCoexVer8192e2Ant, fwVer, btPatchVer, btPatchVer);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsMode(HsChnl)", \
-		wifiDot11Chnl, bBtHsOn, wifiHsChnl);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
@@ -3922,12 +3899,6 @@ EXhalbtc8192e2ant_DisplayCoexInfo(
 		}
 	}
 
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/%s", "PS state, IPS/LPS", \
-		((pCoexSta->bUnderIps? "IPS ON":"IPS OFF")),
-		((pCoexSta->bUnderLps? "LPS ON":"LPS OFF")));
-	CL_PRINTF(cliBuf);
-	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_FW_PWR_MODE_CMD);
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "SS Type", \
 		pCoexDm->curSsType);
 	CL_PRINTF(cliBuf);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.h
index dc94c73b3f3a..58cddce87a41 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8192e2Ant.h
@@ -143,10 +143,15 @@ typedef struct _COEX_STA_8192E_2ANT{
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8192e2ant_InitHwConfig(
+EXhalbtc8192e2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8192e2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8192e2ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a1Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a1Ant.c
index d2476cda62e5..8ea08e87d3de 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a1Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a1Ant.c
@@ -1068,22 +1068,10 @@ EXhalbtc8723a1ant_DisplayCoexInfo(
 	pu1Byte				cliBuf=pBtCoexist->cliBuf;
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
 	CL_PRINTF(cliBuf);
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);	
@@ -1098,39 +1086,17 @@ EXhalbtc8723a1ant_DisplayCoexInfo(
 		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(HsMode)", \
-		wifiDot11Chnl, wifiHsChnl, bBtHsOn);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
@@ -1258,12 +1224,6 @@ EXhalbtc8723a1ant_DisplayCoexInfo(
 		pCoexSta->lowPriorityRx, pCoexSta->lowPriorityTx);
 	CL_PRINTF(cliBuf);
 
-	// Tx mgnt queue hang or not, 0x41b should = 0xf, ex: 0xd ==>hang
-	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x41b);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x41b (mgntQ hang chk == 0xf)", \
-		u1Tmp[0]);
-	CL_PRINTF(cliBuf);	
-
 	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.c
index 2b72397b5285..ffe117596f5b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.c
@@ -58,6 +58,31 @@ halbtc8723a2ant_IsWifiIdle(
 	return TRUE;
 }
 
+BOOLEAN
+halbtc8723a2ant_IsWifiConnectedIdle(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bWifiConnected=FALSE, bScan=FALSE, bLink=FALSE, bRoam=FALSE, bWifiBusy=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+
+	if(bScan)
+		return FALSE;
+	if(bLink)
+		return FALSE;
+	if(bRoam)
+		return FALSE;
+	if(bWifiConnected && !bWifiBusy)
+		return TRUE;
+	else 
+		return FALSE;
+}
+
 u1Byte
 halbtc8723a2ant_BtRssiState(
 	u1Byte			levelNum,
@@ -629,6 +654,9 @@ halbtc8723a2ant_NeedToDecBtPwr(
 	BOOLEAN		bRet=FALSE;
 	BOOLEAN		bBtHsOn=FALSE, bWifiConnected=FALSE;
 	s4Byte		btHsRssi=0;
+	u1Byte		btRssiState=BTC_RSSI_STATE_HIGH;
+
+	btRssiState = halbtc8723a2ant_BtRssiState(2, 42, 0);
 
 	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn))
 		return FALSE;
@@ -636,6 +664,8 @@ halbtc8723a2ant_NeedToDecBtPwr(
 		return FALSE;
 	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi))
 		return FALSE;
+	if(BTC_RSSI_LOW(btRssiState))
+		return FALSE;
 
 	if(bWifiConnected)
 	{
@@ -1546,6 +1576,26 @@ halbtc8723a2ant_IsCommonAction(
 		
 		bCommon = TRUE;
 	}
+	else if(halbtc8723a2ant_IsWifiConnectedIdle(pBtCoexist) && 
+			(BT_8723A_2ANT_BT_STATUS_NON_IDLE == pCoexDm->btStatus) )
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi connected-idle + BT non-idle!!\n"));
+
+		halbtc8723a2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_RfShrink(pBtCoexist, NORMAL_EXEC, TRUE);
+		halbtc8723a2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0xffff, 0x3);
+
+		halbtc8723a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+		halbtc8723a2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x20);
+		halbtc8723a2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8723a2ant_AgcTable(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723a2ant_DacSwing(pBtCoexist, NORMAL_EXEC, FALSE, 0xc0);
+		
+		bCommon = TRUE;
+	}
 	else
 	{
 		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi non-idle + BT non-idle!!\n"));
@@ -3332,9 +3382,17 @@ wa_halbtc8723a2ant_MonitorC2h(
 // extern function start with EXhalbtc8723a2ant_
 //============================================================
 VOID
-EXhalbtc8723a2ant_InitHwConfig(
+EXhalbtc8723a2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
+{
+}
+
+VOID
+EXhalbtc8723a2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
 {
 	u4Byte	u4Tmp=0;
 	u1Byte	u1Tmp=0;
@@ -3371,22 +3429,10 @@ EXhalbtc8723a2ant_DisplayCoexInfo(
 	pu1Byte				cliBuf=pBtCoexist->cliBuf;
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
 	CL_PRINTF(cliBuf);
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);	
@@ -3401,39 +3447,17 @@ EXhalbtc8723a2ant_DisplayCoexInfo(
 		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(HsMode)", \
-		wifiDot11Chnl, wifiHsChnl, bBtHsOn);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
@@ -3564,12 +3588,6 @@ EXhalbtc8723a2ant_DisplayCoexInfo(
 		pCoexSta->lowPriorityRx, pCoexSta->lowPriorityTx);
 	CL_PRINTF(cliBuf);
 
-	// Tx mgnt queue hang or not, 0x41b should = 0xf, ex: 0xd ==>hang
-	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x41b);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x41b (mgntQ hang chk == 0xf)", \
-		u1Tmp[0]);
-	CL_PRINTF(cliBuf);	
-
 	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.h
index c2733d89cea5..f0cc8b546972 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723a2Ant.h
@@ -116,10 +116,15 @@ typedef struct _COEX_STA_8723A_2ANT{
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8723a2ant_InitHwConfig(
+EXhalbtc8723a2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8723a2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8723a2ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.c
index 6105afcc025c..ed9941fd0ec1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.c
@@ -27,8 +27,8 @@ const char *const GLBtInfoSrc8723b1Ant[]={
 	"BT Info[bt auto report]",
 };
 
-u4Byte	GLCoexVerDate8723b1Ant=20140110;
-u4Byte	GLCoexVer8723b1Ant=0x49;
+u4Byte	GLCoexVerDate8723b1Ant=20140725;
+u4Byte	GLCoexVer8723b1Ant=0x53;
 
 //============================================================
 // local function proto type if needed
@@ -411,6 +411,23 @@ halbtc8723b1ant_LimitedRx(
 
 }
 
+VOID
+halbtc8723b1ant_QueryBtInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+
+	pCoexSta->bC2hBtInfoReqSent = TRUE;
+
+	H2C_Parameter[0] |= BIT0;	// trigger
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], Query Bt Info, FW write 0x61=0x%x\n", 
+		H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x61, 1, H2C_Parameter);
+}
+
 VOID
 halbtc8723b1ant_MonitorBtCtr(
 	IN	PBTC_COEXIST		pBtCoexist
@@ -420,7 +437,20 @@ halbtc8723b1ant_MonitorBtCtr(
 	u4Byte			regHPTx=0, regHPRx=0, regLPTx=0, regLPRx=0;
 	u1Byte			u1Tmp, u1Tmp1;
 	s4Byte			wifiRssi;
+	static u1Byte		NumOfBtCounterChk = 0;
 	
+       //to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS
+	//if (! (pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e) & 0x8) ) 
+
+	if (pCoexSta->bUnderIps)
+	{
+		//pCoexSta->highPriorityTx = 65535;
+		//pCoexSta->highPriorityRx = 65535;
+		//pCoexSta->lowPriorityTx = 65535;
+		//pCoexSta->lowPriorityRx = 65535;
+		//return;
+	}
+		
 	regHPTxRx = 0x770;
 	regLPTxRx = 0x774;
 
@@ -437,25 +467,122 @@ halbtc8723b1ant_MonitorBtCtr(
 	pCoexSta->lowPriorityTx = regLPTx;
 	pCoexSta->lowPriorityRx = regLPRx;
 
+	if( (pCoexSta->lowPriorityTx > 1150)  && (!pCoexSta->bC2hBtInquiryPage))
+		pCoexSta->popEventCnt++;
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\n",
+		regHPRx, regHPTx, regLPRx, regLPTx));
+
 	// reset counter
 	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc);
+
+	if ((regHPTx == 0) && (regHPRx ==0) && (regLPTx == 0) && (regLPRx == 0))
+	{
+		NumOfBtCounterChk++;
+		if (NumOfBtCounterChk >= 3)
+{
+			halbtc8723b1ant_QueryBtInfo(pBtCoexist);
+			NumOfBtCounterChk = 0;
+		}
+	}
 }
 
+
 VOID
-halbtc8723b1ant_QueryBtInfo(
+halbtc8723b1ant_MonitorWiFiCtr(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	u1Byte			H2C_Parameter[1] ={0};
+	u4Byte 	u4Tmp;
+	u2Byte 	u2Tmp[3];
+	s4Byte	wifiRssi=0;
+	BOOLEAN bWifiBusy = FALSE, bWifiUnderBMode = FALSE;
+	static u1Byte nCCKLockCounter = 0;
 
-	pCoexSta->bC2hBtInfoReqSent = TRUE;
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_B_MODE, &bWifiUnderBMode);
 
-	H2C_Parameter[0] |= BIT0;	// trigger
+	if (pCoexSta->bUnderIps)
+	{
+		pCoexSta->nCRCOK_CCK = 0;
+		pCoexSta->nCRCOK_11g = 0;
+		pCoexSta->nCRCOK_11n = 0;
+		pCoexSta->nCRCOK_11nAgg = 0;
 
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], Query Bt Info, FW write 0x61=0x%x\n", 
-		H2C_Parameter[0]));
+		pCoexSta->nCRCErr_CCK = 0;
+		pCoexSta->nCRCErr_11g = 0;
+		pCoexSta->nCRCErr_11n = 0;
+		pCoexSta->nCRCErr_11nAgg = 0;	
+	}
+	else
+	{
+		pCoexSta->nCRCOK_CCK	= pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xf88);
+		pCoexSta->nCRCOK_11g 	= pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf94);
+		pCoexSta->nCRCOK_11n	= pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf90);
+		pCoexSta->nCRCOK_11nAgg= pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xfb8);
+
+		pCoexSta->nCRCErr_CCK 	 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xf84);
+		pCoexSta->nCRCErr_11g 	 = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf96);
+		pCoexSta->nCRCErr_11n 	 = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf92);
+		pCoexSta->nCRCErr_11nAgg = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xfba);		
+	}
+
+
+	//reset counter
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xf16, 0x1, 0x1);
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xf16, 0x1, 0x0);
+
+	if ( (bWifiBusy) && (wifiRssi >= 30) && (!bWifiUnderBMode))
+	{
+		if ( (pCoexDm->btStatus == BT_8723B_1ANT_BT_STATUS_ACL_BUSY) ||
+			(pCoexDm->btStatus == BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY) ||
+			(pCoexDm->btStatus == BT_8723B_1ANT_BT_STATUS_SCO_BUSY) )
+		{
+			if (pCoexSta->nCRCOK_CCK >(pCoexSta->nCRCOK_11g + pCoexSta->nCRCOK_11n + 
+				pCoexSta->nCRCOK_11nAgg) )
+			{
+				if (nCCKLockCounter < 5)
+				 nCCKLockCounter++;
+			}
+			else
+			{
+				if (nCCKLockCounter > 0)
+				 nCCKLockCounter--;
+			}
+
+		}
+		else
+		{
+			if (nCCKLockCounter > 0)
+			  nCCKLockCounter--;
+		}
+	}
+	else
+	{
+		if (nCCKLockCounter > 0)
+			nCCKLockCounter--;
+	}
+
+	if (!pCoexSta->bPreCCKLock)
+	{
+
+		if (nCCKLockCounter >= 5)
+		 pCoexSta->bCCKLock = TRUE;
+		else
+		 pCoexSta->bCCKLock = FALSE;			
+	}
+	else
+	{
+		if (nCCKLockCounter == 0)
+		 pCoexSta->bCCKLock = FALSE;
+		else
+		 pCoexSta->bCCKLock = TRUE;		
+	}
+
+	pCoexSta->bPreCCKLock =  pCoexSta->bCCKLock;	
+		
 
-	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x61, 1, H2C_Parameter);
 }
 
 BOOLEAN
@@ -509,6 +636,7 @@ halbtc8723b1ant_UpdateBtLinkInfo(
 	pBtLinkInfo->bA2dpExist = pCoexSta->bA2dpExist;
 	pBtLinkInfo->bPanExist = pCoexSta->bPanExist;
 	pBtLinkInfo->bHidExist = pCoexSta->bHidExist;
+	pBtLinkInfo->bBtHiPriLinkExist = pCoexSta->bBtHiPriLinkExist;
 
 	// work around for HS mode.
 	if(bBtHsOn)
@@ -920,9 +1048,9 @@ halbtc8723b1ant_CoexTableWithType(
 	IN	u1Byte				type
 	)
 {
-
-	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], ********** CoexTable(%d) **********\n", 
-				type));
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], ********** CoexTable(%d) **********\n", type));
+	
+	pCoexSta->nCoexTableType = type;
 	
 	switch(type)
 	{
@@ -936,16 +1064,19 @@ halbtc8723b1ant_CoexTableWithType(
 			halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
 			break;
 		case 3:
-			halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x5a5a5a5a, 0xaaaaaaaa, 0xffffff, 0x3);
+			halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0x5a5a5a5a, 0xffffff, 0x3);
 			break;
 		case 4:
-			halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+			if(pCoexSta->nScanAPNum > 5)
+				halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
+			else
+				halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
 			break;
 		case 5:
-			halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x5a5a5a5a, 0xaaaa5a5a, 0xffffff, 0x3);
+			halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x5a5a5a5a, 0xaa5a5a5a, 0xffffff, 0x3);
 			break;
 		case 6:
-			halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
+			halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
 			break;
 		case 7:
 			halbtc8723b1ant_CoexTable(pBtCoexist, bForceExec, 0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
@@ -998,54 +1129,6 @@ halbtc8723b1ant_IgnoreWlanAct(
 	pCoexDm->bPreIgnoreWlanAct = pCoexDm->bCurIgnoreWlanAct;
 }
 
-VOID
-halbtc8723b1ant_SetFwPstdma(
-	IN	PBTC_COEXIST		pBtCoexist,
-	IN	u1Byte			byte1,
-	IN	u1Byte			byte2,
-	IN	u1Byte			byte3,
-	IN	u1Byte			byte4,
-	IN	u1Byte			byte5
-	)
-{
-	u1Byte			H2C_Parameter[5] ={0};
-	u1Byte			realByte1=byte1, realByte5=byte5;
-	BOOLEAN			bApEnable=FALSE;
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE, &bApEnable);
-
-	if(bApEnable)
-	{
-		if(byte1&BIT4 && !(byte1&BIT5))
-		{			
-			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], FW for 1Ant AP mode\n"));
-			realByte1 &= ~BIT4;
-			realByte1 |= BIT5;
-
-			realByte5 |= BIT5;
-			realByte5 &= ~BIT6;
-		}
-	}
-
-	H2C_Parameter[0] = realByte1;	
-	H2C_Parameter[1] = byte2;	
-	H2C_Parameter[2] = byte3;
-	H2C_Parameter[3] = byte4;
-	H2C_Parameter[4] = realByte5;
-
-	pCoexDm->psTdmaPara[0] = realByte1;
-	pCoexDm->psTdmaPara[1] = byte2;
-	pCoexDm->psTdmaPara[2] = byte3;
-	pCoexDm->psTdmaPara[3] = byte4;
-	pCoexDm->psTdmaPara[4] = realByte5;
-	
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], PS-TDMA H2C cmd =0x%x%08x\n", 
-		H2C_Parameter[0], 
-		H2C_Parameter[1]<<24|H2C_Parameter[2]<<16|H2C_Parameter[3]<<8|H2C_Parameter[4]));
-
-	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x60, 5, H2C_Parameter);
-}
-
 VOID
 halbtc8723b1ant_SetLpsRpwm(
 	IN	PBTC_COEXIST		pBtCoexist,
@@ -1111,44 +1194,71 @@ VOID
 halbtc8723b1ant_SetAntPath(
 	IN	PBTC_COEXIST		pBtCoexist,
 	IN	u1Byte				antPosType,
+	IN	BOOLEAN				bForceExec,
 	IN	BOOLEAN				bInitHwCfg,
 	IN	BOOLEAN				bWifiOff
 	)
 {
 	PBTC_BOARD_INFO pBoardInfo=&pBtCoexist->boardInfo;
-	u4Byte			fwVer=0, u4Tmp=0;
+	u4Byte			fwVer=0, u4Tmp=0, cntBtCalChk=0;
 	BOOLEAN			bPgExtSwitch=FALSE;
 	BOOLEAN			bUseExtSwitch=FALSE;
-	u1Byte			H2C_Parameter[2] ={0};
-	PADAPTER padapter=pBtCoexist->Adapter;
+	BOOLEAN			bIsInMpMode = FALSE;
+	u1Byte			H2C_Parameter[2] ={0}, u1Tmp = 0;
+
+	pCoexDm->curAntPosType = antPosType;
+	
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_EXT_SWITCH, &bPgExtSwitch);
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);	// [31:16]=fw ver, [15:0]=fw sub ver
 
-
-	if((fwVer<0xc0000) || bPgExtSwitch)
+	if((fwVer>0 && fwVer<0xc0000) || bPgExtSwitch)
 		bUseExtSwitch = TRUE;
 
 	if(bInitHwCfg)
 	{
-		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x1); //BT select s0/s1 is controlled by WiFi
-		
-		//Force GNT_BT to Normal
-		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x765, 0x18, 0x0); 
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x780); //WiFi TRx Mask on
+		//remove due to interrupt is disabled that polling c2h will fail and delay 100ms.
+		//pBtCoexist->fBtcSetBtReg(pBtCoexist, BTC_BT_REG_RF, 0x3c, 0x15); //BT TRx Mask on
 
+		if(fwVer >= 0x180000)
+		{
+		/* Use H2C to set GNT_BT to HIGH */
+		H2C_Parameter[0] = 1;
+		pBtCoexist->fBtcFillH2c(pBtCoexist, 0x6E, 1, H2C_Parameter);
+		}
+		else
+		{
+			// set grant_bt to high
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x18); 
+		}
 		//set wlan_act control by PTA
-		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc); 
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4); 
+
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x0); //BT select s0/s1 is controlled by BT
 
-		//pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4); 
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x39, 0x8, 0x1);
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x974, 0xff);
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x944, 0x3, 0x3);
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x930, 0x77);
 	}
 	else if(bWifiOff)
 	{
-	//Force GNT_BT to High
-		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x765, 0x18, 0x3);
-		
+		if(fwVer >= 0x180000)
+		{
+		/* Use H2C to set GNT_BT to HIGH */
+		H2C_Parameter[0] = 1;
+		pBtCoexist->fBtcFillH2c(pBtCoexist, 0x6E, 1, H2C_Parameter);
+		}
+		else
+		{
+			// set grant_bt to high
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x18); 
+		}
 		//set wlan_act to always low
 		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4);
 		
-		if(padapter->registrypriv.mp_mode ==0)	
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_IS_IN_MP_MODE, &bIsInMpMode);
+		if(!bIsInMpMode)	
 			pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x0); //BT select s0/s1 is controlled by BT
 		else
 			pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x1); //BT select s0/s1 is controlled by WiFi
@@ -1159,6 +1269,48 @@ halbtc8723b1ant_SetAntPath(
 		u4Tmp &= ~BIT24;
 		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
 	}
+	else
+	{			
+		/* Use H2C to set GNT_BT to LOW */
+		if(fwVer >= 0x180000)
+		{
+		if (pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765) != 0)
+		{		
+			H2C_Parameter[0] = 0;
+			pBtCoexist->fBtcFillH2c(pBtCoexist, 0x6E, 1, H2C_Parameter);
+		}
+		}
+		else
+		{
+			// BT calibration check
+			while(cntBtCalChk <= 20)
+			{
+				u1Tmp = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x49d);
+				cntBtCalChk++;
+				if(u1Tmp & BIT0)
+				{
+					BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], ########### BT is calibrating (wait cnt=%d) ###########\n", cntBtCalChk));
+					delay_ms(50);
+				}
+				else
+				{
+					BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], ********** BT is NOT calibrating (wait cnt=%d)**********\n", cntBtCalChk));
+					break;
+				}
+			}
+
+			// set grant_bt to PTA
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x0);
+		}
+
+		if (pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e) != 0xc)
+		{
+			//set wlan_act control by PTA
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc); 
+		}
+
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x1); //BT select s0/s1 is controlled by WiFi
+	}
 	
 	if(bUseExtSwitch)
 	{
@@ -1170,10 +1322,10 @@ halbtc8723b1ant_SetAntPath(
 			u4Tmp |= BIT24;
 			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
 
+			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0); // fixed internal switch S1->WiFi, S0->BT
+
 			if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
 			{
-				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x1); //Main Ant to  BT for IPS case 0x4c[23]=1
-	
 				//tell firmware "no antenna inverse"
 				H2C_Parameter[0] = 0;
 				H2C_Parameter[1] = 1;  //ext switch type
@@ -1181,8 +1333,6 @@ halbtc8723b1ant_SetAntPath(
 			}
 			else
 			{
-				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x0); //Aux Ant to  BT for IPS case 0x4c[23]=1
-		
 				//tell firmware "antenna inverse"
 				H2C_Parameter[0] = 1;
 				H2C_Parameter[1] = 1;  //ext switch type
@@ -1190,36 +1340,32 @@ halbtc8723b1ant_SetAntPath(
 			}
 		}
 		
-		// fixed internal switch first
-		if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
- 			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0); // fixed internal switch S1->WiFi, S0->BT
-		else
-			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x280); // fixed internal switch S0->WiFi, S1->BT
-
-		// ext switch setting
-		switch(antPosType)
+		if(bForceExec || (pCoexDm->curAntPosType != pCoexDm->preAntPosType))
 		{
-			case BTC_ANT_PATH_WIFI:
-				if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
-					pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x1);
-				else
-					pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x2);
-				break;
-			case BTC_ANT_PATH_BT:
-				if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
-					pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x2);
-				else					
-					pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x1);
-				break;
-			default:
-			case BTC_ANT_PATH_PTA:
-				if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
-					pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x1);
-				else
-					pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x2);
-				break;
+			// ext switch setting
+			switch(antPosType)
+			{
+				case BTC_ANT_PATH_WIFI:
+					if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
+						pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x1);
+					else
+						pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x2);
+					break;
+				case BTC_ANT_PATH_BT:
+					if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
+						pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x2);
+					else					
+						pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x1);
+					break;
+				default:
+				case BTC_ANT_PATH_PTA:
+					if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
+						pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x1);
+					else
+						pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x2);
+					break;
+			}
 		}
-	
 	}
 	else
 	{
@@ -1231,9 +1377,11 @@ halbtc8723b1ant_SetAntPath(
 			u4Tmp &=~BIT24;	      
 			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
 
+			//Fix Ext switch Main->S1, Aux->S0
+			pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x0); 
+
 			if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
 			{
-				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x0); //Main Ant to  WiFi for IPS case 0x4c[23]=1
 	
 				//tell firmware "no antenna inverse"
 				H2C_Parameter[0] = 0;
@@ -1242,7 +1390,6 @@ halbtc8723b1ant_SetAntPath(
 			}
 			else
 			{
-				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x1); //Aux Ant to  BT for IPS case 0x4c[23]=1
 		
 				//tell firmware "antenna inverse"
 				H2C_Parameter[0] = 1;
@@ -1251,38 +1398,120 @@ halbtc8723b1ant_SetAntPath(
 			}
 		}
 	
-		// fixed external switch first
-		if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
-			pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x1); //Main->WiFi, Aux->BT
-		else
-			pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x2); //Main->BT, Aux->WiFi
-
-		// internal switch setting
-		switch(antPosType)
+		if(bForceExec || (pCoexDm->curAntPosType != pCoexDm->preAntPosType))
 		{
-			case BTC_ANT_PATH_WIFI:
-				if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
-					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
-				else
-					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x280);
-				break;
-			case BTC_ANT_PATH_BT:
-				if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
- 					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x280);
-				else
-					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
-				break;
-			default:
-			case BTC_ANT_PATH_PTA:
-				if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
-					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x200);					
-				else
-					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x80);
-				break;
+			// internal switch setting
+			switch(antPosType)
+			{
+				case BTC_ANT_PATH_WIFI:
+					if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
+						pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
+					else
+						pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x280);
+					break;
+				case BTC_ANT_PATH_BT:
+					if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
+ 						pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x280);
+					else
+						pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
+					break;
+				default:
+				case BTC_ANT_PATH_PTA:
+					if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
+						pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x200);					
+					else
+						pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x80);
+					break;
+			}
 		}
 	}
+
+	pCoexDm->preAntPosType = pCoexDm->curAntPosType;
 }
 
+VOID
+halbtc8723b1ant_SetAntPathDCut(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bAntennaAux,	//For 1-Ant--> 1: Antenna at S0, 0: Antenna at S1. Set 0 for 2-Ant
+	IN	BOOLEAN				bExtSwitch,		// 1: Ext Switch (SPDT) exist on module, 0: no Ext Switch (SPDT) exist on module
+	IN	BOOLEAN				bTwoAntenna,	// 1: 2-Antenna, 0:1-Antenna
+	IN	u1Byte				antennaPos,		//Set Antenna Pos, For 1-Ant: BTC_ANT_PATH_WIFI, BTC_ANT_PATH_BT, BTC_ANT_PATH_PTA, For 2-Ant:BTC_ANT_WIFI_AT_MAIN, BTC_ANT_WIFI_AT_Aux
+	IN	u1Byte				wifiState		//BTC_WIFI_STAT_INIT, BTC_WIFI_STAT_IQK, BTC_WIFI_STAT_NORMAL_OFF, BTC_WIFI_STAT_MP_OFF, BTC_WIFI_STAT_NORMAL, BTC_WIFI_STAT_ANT_DIV
+	)
+{
+	u1Byte	dataLen=5;
+	u1Byte	buf[6] = {0};
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], set BT Ant, bAntennaAux/bExtSwitch/bTwoAntenna/antennaPos/wifiState=%d/%d/%d/%d/%d\n",
+		bAntennaAux, bExtSwitch, bTwoAntenna, antennaPos, wifiState));
+
+	buf[0] = dataLen; 
+	
+	if(bAntennaAux)
+		buf[1] = 0x1;
+	
+	if(bExtSwitch)
+		buf[2] = 0x1;			
+	
+	if(bTwoAntenna)
+		buf[3] = 0x1;
+
+	buf[4] = antennaPos;
+
+	buf[5] = wifiState;
+	
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_CTRL_8723B_ANT, (PVOID)&buf[0]);	
+}
+
+VOID
+halbtc8723b1ant_SetFwPstdma(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			byte1,
+	IN	u1Byte			byte2,
+	IN	u1Byte			byte3,
+	IN	u1Byte			byte4,
+	IN	u1Byte			byte5
+	)
+{
+	u1Byte			H2C_Parameter[5] ={0};
+	u1Byte			realByte1=byte1, realByte5=byte5;
+	BOOLEAN			bApEnable=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE, &bApEnable);
+
+	if(bApEnable)
+	{
+		if(byte1&BIT4 && !(byte1&BIT5))
+		{			
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], FW for 1Ant AP mode\n"));
+			realByte1 &= ~BIT4;
+			realByte1 |= BIT5;
+
+			realByte5 |= BIT5;
+			realByte5 &= ~BIT6;
+		}
+	}
+
+	H2C_Parameter[0] = realByte1;	
+	H2C_Parameter[1] = byte2;	
+	H2C_Parameter[2] = byte3;
+	H2C_Parameter[3] = byte4;
+	H2C_Parameter[4] = realByte5;
+
+	pCoexDm->psTdmaPara[0] = realByte1;
+	pCoexDm->psTdmaPara[1] = byte2;
+	pCoexDm->psTdmaPara[2] = byte3;
+	pCoexDm->psTdmaPara[3] = byte4;
+	pCoexDm->psTdmaPara[4] = realByte5;
+	
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], PS-TDMA H2C cmd =0x%x%08x\n", 
+		H2C_Parameter[0], 
+		H2C_Parameter[1]<<24|H2C_Parameter[2]<<16|H2C_Parameter[3]<<8|H2C_Parameter[4]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x60, 5, H2C_Parameter);
+}
+
+
 VOID
 halbtc8723b1ant_PsTdma(
 	IN	PBTC_COEXIST		pBtCoexist,
@@ -1292,9 +1521,12 @@ halbtc8723b1ant_PsTdma(
 	)
 {
 	PBTC_BOARD_INFO	pBoardInfo=&pBtCoexist->boardInfo;
-	BOOLEAN			bTurnOnByCnt=FALSE, bWifiBusy=FALSE;
+	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	BOOLEAN			bTurnOnByCnt=FALSE, bWifiBusy=FALSE, bWiFiNoisy=FALSE;
 	u1Byte			psTdmaTypeByCnt=0, rssiAdjustVal=0;
-	//u4Byte			fwVer=0;
+	u1Byte			psTdmaByte4Val = 0x50, psTdmaByte0Val = 0x51, psTdmaByte3Val =  0x10;
+	s1Byte			nWiFiDurationAdjust = 0x0;
+	static BOOLEAN	 bPreWifiBusy=FALSE;
 
 	//BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s turn %s PS TDMA, type=%d\n", 
 	//	(bForceExec? "force to":""), (bTurnOn? "ON":"OFF"), type));
@@ -1303,14 +1535,20 @@ halbtc8723b1ant_PsTdma(
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);	
 
+	if (bWifiBusy != bPreWifiBusy)
+	{
+		bForceExec = TRUE;	
+		bPreWifiBusy = bWifiBusy;
+	}
+
 	if (pCoexDm->bCurPsTdmaOn)
 	{
-		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], ********** TDMA(on, %d) **********\n", 
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], ********** TDMA(on, %d) **********\n", 
 				pCoexDm->curPsTdma));
 	}
 	else
 	{
-		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], ********** TDMA(off, %d) **********\n", 
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], ********** TDMA(off, %d) **********\n", 
 				pCoexDm->curPsTdma));
 	}
 			
@@ -1320,40 +1558,57 @@ halbtc8723b1ant_PsTdma(
 			(pCoexDm->prePsTdma == pCoexDm->curPsTdma) )
 			return;
 	}
-	if(bTurnOn)
+
+	if (pCoexSta->nScanAPNum <= 5)
+		nWiFiDurationAdjust = 5;
+		//nWiFiDurationAdjust = 2;
+	else if  (pCoexSta->nScanAPNum >= 40)
+		nWiFiDurationAdjust = -15;	
+	else if  (pCoexSta->nScanAPNum >= 20)
+		nWiFiDurationAdjust = -10;	
+	
+	if (!pCoexSta->bForceLpsOn)  //only for A2DP-only case 1/2/9/11 while wifi noisy threshold > 30
+	{
+		psTdmaByte0Val = 0x61;  //no null-pkt
+		psTdmaByte3Val = 0x11; // no tx-pause at BT-slot
+		psTdmaByte4Val = 0x10; // 0x778 = d/1 toggle
+	}
+	
+	if (  (type == 3) || (type == 13) || (type == 14) )
 	{
+		psTdmaByte4Val = psTdmaByte4Val & 0xbf;  //no dynamic slot for multi-profile
+	
+		if (!bWifiBusy)
+			psTdmaByte4Val = psTdmaByte4Val | 0x1;  //0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts)
+		}
+		 
+	if (pBtLinkInfo->bSlaveRole == TRUE)
+		psTdmaByte4Val = psTdmaByte4Val | 0x1;  //0x778 = 0x1 at wifi slot (no blocking BT Low-Pri pkts)
+		
+	if(bTurnOn)
+	{	 
 		switch(type)
 		{
 			default:
-				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x1a, 0x1a, 0x0, 0x50);
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x1a, 0x1a, 0x0, psTdmaByte4Val);
 				break;
 			case 1:
-				//if(bWifiBusy)
-					halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x3a, 0x03, 0x10, 0x50);
-				//else
-				//	halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x3a, 0x03, 0x10, 0x51);
-				
-				rssiAdjustVal = 11;
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, psTdmaByte0Val, 0x3a+nWiFiDurationAdjust, 0x03, psTdmaByte3Val, psTdmaByte4Val);								
 				break;
 			case 2:
-				//if(bWifiBusy)
-					halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x2b, 0x03, 0x10, 0x50);
-				//else
-				//	halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x2b, 0x03, 0x10, 0x51);
-				rssiAdjustVal = 14;
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, psTdmaByte0Val, 0x2d+nWiFiDurationAdjust, 0x03, psTdmaByte3Val, psTdmaByte4Val);							
 				break;
 			case 3:
-				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x1d, 0x1d, 0x0, 0x52);
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x1d, 0x1d, 0x0, psTdmaByte4Val);
 				break;
 			case 4:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x93, 0x15, 0x3, 0x14, 0x0);
-				rssiAdjustVal = 17;
 				break;
 			case 5:
-				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x61, 0x15, 0x3, 0x11, 0x10);
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x61, 0x15, 0x3, 0x11, 0x11);
 				break;
 			case 6:
-				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x61, 0x20, 0x3, 0x11, 0x13);
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x61, 0x20, 0x3, 0x11, 0x11);
 				break;
 			case 7:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x13, 0xc, 0x5, 0x0, 0x0);
@@ -1362,45 +1617,34 @@ halbtc8723b1ant_PsTdma(
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x93, 0x25, 0x3, 0x10, 0x0);
 				break;
 			case 9:	
-				//if(bWifiBusy)
-					halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x21, 0x3, 0x10, 0x50);
-				//else
-				//	halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x21, 0x3, 0x10, 0x50);
-				rssiAdjustVal = 18;
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, psTdmaByte0Val, 0x21, 0x3, psTdmaByte3Val, psTdmaByte4Val);				
 				break;
 			case 10:	
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x13, 0xa, 0xa, 0x0, 0x40);
 				break;
 			case 11:	
-				//if(bWifiBusy)
-					halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x15, 0x03, 0x10, 0x50);
-				//else
-				//	halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x15, 0x03, 0x10, 0x50);
-				rssiAdjustVal = 20;
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, psTdmaByte0Val, 0x21, 0x03, psTdmaByte3Val, psTdmaByte4Val);			
 				break;
 			case 12:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x0a, 0x0a, 0x0, 0x50);
 				break;
 			case 13:
-				//halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x15, 0x15, 0x0, 0x50);
-				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x12, 0x12, 0x0, 0x50);
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x12, 0x12, 0x0, psTdmaByte4Val);
 				break;
 			case 14:
-				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x21, 0x3, 0x10, 0x52);
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x51, 0x21, 0x3, 0x10, psTdmaByte4Val);
 				break;
 			case 15:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x13, 0xa, 0x3, 0x8, 0x0);
 				break;
 			case 16:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x93, 0x15, 0x3, 0x10, 0x0);
-				rssiAdjustVal = 18;
 				break;
 			case 18:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x93, 0x25, 0x3, 0x10, 0x0);
-				rssiAdjustVal = 14;
 				break;			
 			case 20:
-				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x61, 0x35, 0x03, 0x11, 0x10);
+				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x61, 0x3f, 0x03, 0x11, 0x10);
 				break;
 			case 21:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x61, 0x25, 0x03, 0x11, 0x11);
@@ -1410,23 +1654,18 @@ halbtc8723b1ant_PsTdma(
 				break;
 			case 23:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0xe3, 0x25, 0x3, 0x31, 0x18);
-				rssiAdjustVal = 22;
 				break;
 			case 24:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0xe3, 0x15, 0x3, 0x31, 0x18);
-				rssiAdjustVal = 22;
 				break;
 			case 25:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0x3, 0x31, 0x18);
-				rssiAdjustVal = 22;
 				break;
 			case 26:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0x3, 0x31, 0x18);
-				rssiAdjustVal = 22;
 				break;
 			case 27:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0xe3, 0x25, 0x3, 0x31, 0x98);
-				rssiAdjustVal = 22;
 				break;
 			case 28:
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x69, 0x25, 0x3, 0x31, 0x0);
@@ -1441,7 +1680,6 @@ halbtc8723b1ant_PsTdma(
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0xd3, 0x1a, 0x1a, 0, 0x58);
 				break;
 			case 32:
-				//halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x61, 0xa, 0x3, 0x10, 0x0);
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x61, 0x35, 0x3, 0x11, 0x11);
 				break;
 			case 33:
@@ -1464,34 +1702,42 @@ halbtc8723b1ant_PsTdma(
 	}
 	else
 	{		
-		//pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);	// [31:16]=fw ver, [15:0]=fw sub ver
 
 		// disable PS tdma
 		switch(type)
 		{
 			case 8: //PTA Control
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x8, 0x0, 0x0, 0x0, 0x0);
-				halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, FALSE, FALSE);
+				//halbtc8723b1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_PTA, BTC_WIFI_STAT_NORMAL);
+				//halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, FALSE, FALSE);
 				break;
 			case 0:
 			default:  //Software control, Antenna at BT side
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x0, 0x0);
-				halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, FALSE);
+				//halbtc8723b1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL);
+				//halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, FALSE);
 				break;
+#if 0
 			case 9:   //Software control, Antenna at WiFi side
 				halbtc8723b1ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x0, 0x0);
+				//halbtc8723b1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_WIFI, BTC_WIFI_STAT_NORMAL);
 				halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_WIFI, FALSE, FALSE);
 				break;			
+#endif
 		}
 	}
 	rssiAdjustVal =0;
 	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE, &rssiAdjustVal);
 
+
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+		pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948),   pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765), pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x67)));
+
 	// update pre state
 	pCoexDm->bPrePsTdmaOn = pCoexDm->bCurPsTdmaOn;
 	pCoexDm->prePsTdma = pCoexDm->curPsTdma;
 }
-
+#if 0
 VOID
 halbtc8723b1ant_CoexAllOff(
 	IN	PBTC_COEXIST		pBtCoexist
@@ -1501,9 +1747,9 @@ halbtc8723b1ant_CoexAllOff(
 	halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
 
 	// hw all off
-	halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+	halbtc8723b1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 0);
 }
-
+#endif
 BOOLEAN
 halbtc8723b1ant_IsCommonAction(
 	IN	PBTC_COEXIST		pBtCoexist
@@ -1519,7 +1765,7 @@ halbtc8723b1ant_IsCommonAction(
 	{
 		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi non connected-idle + BT non connected-idle!!\n"));
 		
- 		halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
+ 		//halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
 
 		bCommon = TRUE;
 	}
@@ -1528,7 +1774,7 @@ halbtc8723b1ant_IsCommonAction(
 	{
 		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi connected + BT non connected-idle!!\n"));
 
-		halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
+		//halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
 
 		bCommon = TRUE;
 	}
@@ -1537,7 +1783,7 @@ halbtc8723b1ant_IsCommonAction(
 	{
 		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi non connected-idle + BT connected-idle!!\n"));
 
-		halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
+		//halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
 
 		bCommon = TRUE;
 	}
@@ -1546,7 +1792,7 @@ halbtc8723b1ant_IsCommonAction(
 	{
 		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi connected + BT connected-idle!!\n"));
 
-		halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
+		//halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
 
 		bCommon = TRUE;
 	}
@@ -1555,7 +1801,7 @@ halbtc8723b1ant_IsCommonAction(
 	{
 		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi non connected-idle + BT Busy!!\n"));
 
-		halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
+		//halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
 		
 		bCommon = TRUE;
 	}
@@ -1641,6 +1887,10 @@ halbtc8723b1ant_TdmaDurationAdjustForAcl(
 		//BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], retryCount = %d\n", retryCount));
 		//BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], up=%d, dn=%d, m=%d, n=%d, WaitCount=%d\n", 
 		//	up, dn, m, n, WaitCount));
+
+		if ( (pCoexSta->lowPriorityTx) > 1150 ||  (pCoexSta->lowPriorityRx) > 1250 )
+			retryCount++;	
+		
 		result = 0;
 		WaitCount++; 
 		  
@@ -1798,7 +2048,7 @@ halbtc8723b1ant_PsTdmaCheckForPowerSaveState(
 		else
 		{
 			// will leave LPS state, turn off psTdma first
-			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
 		}
 	}
 	else						// NO PS state
@@ -1806,7 +2056,7 @@ halbtc8723b1ant_PsTdmaCheckForPowerSaveState(
 		if(bNewPsState)
 		{
 			// will enter LPS state, turn off psTdma first
-			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
 		}
 		else
 		{
@@ -1832,6 +2082,7 @@ halbtc8723b1ant_PowerSaveState(
 			bLowPwrDisable = FALSE;
 			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
 			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_NORMAL_LPS, NULL);
+			pCoexSta->bForceLpsOn = FALSE;
 			break;
 		case BTC_PS_LPS_ON:
 			halbtc8723b1ant_PsTdmaCheckForPowerSaveState(pBtCoexist, TRUE);
@@ -1841,10 +2092,12 @@ halbtc8723b1ant_PowerSaveState(
 			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
 			// power save must executed before psTdma.			
 			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_ENTER_LPS, NULL);
+			pCoexSta->bForceLpsOn = TRUE;
 			break;
 		case BTC_PS_LPS_OFF:
 			halbtc8723b1ant_PsTdmaCheckForPowerSaveState(pBtCoexist, FALSE);
 			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_LEAVE_LPS, NULL);
+			pCoexSta->bForceLpsOn = FALSE;
 			break;
 		default:
 			break;
@@ -1856,8 +2109,9 @@ halbtc8723b1ant_ActionWifiOnly(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
-	halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9);	
+	halbtc8723b1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 0);
+	halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);
+	halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, FORCE_EXEC, FALSE, FALSE);
 }
 
 VOID
@@ -1929,6 +2183,8 @@ halbtc8723b1ant_MonitorBtEnableDisable(
 //=============================================
 
 // SCO only or SCO+PAN(HS)
+
+/*
 VOID
 halbtc8723b1ant_ActionSco(
 	IN	PBTC_COEXIST		pBtCoexist
@@ -2014,11 +2270,25 @@ halbtc8723b1ant_ActionHidA2dp(
 	halbtc8723b1ant_SwMechanism(pBtCoexist, TRUE);
 }
 
+*/
+
 //=============================================
 //
 //	Non-Software Coex Mechanism start
 //
 //=============================================
+VOID
+halbtc8723b1ant_ActionBtWhckTest(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	
+	halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+	halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
+	halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+}
+
 VOID
 halbtc8723b1ant_ActionWifiMultiPort(
 	IN	PBTC_COEXIST		pBtCoexist
@@ -2027,6 +2297,7 @@ halbtc8723b1ant_ActionWifiMultiPort(
 	halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 	
 	halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+	halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
 	halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 }
 
@@ -2052,39 +2323,43 @@ halbtc8723b1ant_ActionBtInquiry(
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
 	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bBtBusy);
 
-
 	if ( (!bWifiConnected) && (!pCoexSta->bWiFiIsHighPriTask) )
 	{
 		halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
-
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
 	 	halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);		
 	}
-	else if( (pBtLinkInfo->bScoExist) ||
-			(pBtLinkInfo->bHidExist) )
+	else if( (pBtLinkInfo->bScoExist) || 	(pBtLinkInfo->bHidExist) || 	(pBtLinkInfo->bA2dpExist)  )
 	{
-		// SCO/HID-only busy
+		// SCO/HID/A2DP busy
 		halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
 		
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 3);		
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);		
 	}
-	else if ( (pBtLinkInfo->bA2dpExist) ||  (pBtLinkInfo->bPanExist) ||  (bWifiBusy) )
+	else if ( (pBtLinkInfo->bPanExist) || (bWifiBusy) )
 	{
-		
 		halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
-		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);		
+
+		//for BT inquiry/page fail after S4 resume
+		//halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);		
+		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
 		
 		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
 	}
 	else
 	{
 		halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
-
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
 	 	halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);		
+		
+
+		//halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
+		//halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);				
 	}
-	
 }
 
 VOID
@@ -2104,35 +2379,13 @@ halbtc8723b1ant_ActionBtScoHidOnlyBusy(
 	if(pBtLinkInfo->bScoExist)
 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 5);
 	}
 	else //HID
 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
 		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 5);
 	}
-/*
-	if(pBtLinkInfo->bScoExist || pBtLinkInfo->bHidExist)
-	{
-		if(bWifiConnected)
-		{
-			wifiRssiState = halbtc8723b1ant_WifiRssiState(pBtCoexist, 0, 2, 30, 0);
-			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
-				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
-			{
-				halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 2, 1, 1, 1);
-			}
-			else
-			{
-				halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 1, 1, 1, 1);
-			}
-		}
-		else
-		{
-			halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
-		}
-	}
-*/
 }
 
 VOID
@@ -2146,6 +2399,15 @@ halbtc8723b1ant_ActionWifiConnectedBtAclBusy(
 	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
 	btRssiState = halbtc8723b1ant_BtRssiState(2, 28, 0);	
 
+	if ( (pCoexSta->lowPriorityRx >= 950)  && (!pCoexSta->bUnderIps) )
+	{
+		pBtLinkInfo->bSlaveRole = TRUE;
+	}
+	else
+	{
+		pBtLinkInfo->bSlaveRole = FALSE;
+	}
+
 	if(pBtLinkInfo->bHidOnly)  //HID
 	{
 		halbtc8723b1ant_ActionBtScoHidOnlyBusy(pBtCoexist, wifiStatus);
@@ -2156,58 +2418,42 @@ halbtc8723b1ant_ActionWifiConnectedBtAclBusy(
 	{
 		if(BT_8723B_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifiStatus)
 		{
-			//halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
-			//halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
-			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
 			pCoexDm->bAutoTdmaAdjust = FALSE;
 		}
-		else if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
-			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )	
+		else
 		{
 			halbtc8723b1ant_TdmaDurationAdjustForAcl(pBtCoexist, wifiStatus);
-			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
-		}
-		else //for low BT RSSI
-		{
-			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
-			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
-			pCoexDm->bAutoTdmaAdjust = FALSE;
+			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+			pCoexDm->bAutoTdmaAdjust = TRUE;
 		}
 	}
+	else if ( ((pBtLinkInfo->bA2dpExist) && (pBtLinkInfo->bPanExist)) ||
+		       (pBtLinkInfo->bHidExist&&pBtLinkInfo->bA2dpExist&&pBtLinkInfo->bPanExist) ) //A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP)
+	{
+		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+		pCoexDm->bAutoTdmaAdjust = FALSE;
+	}
 	else if(pBtLinkInfo->bHidExist&&pBtLinkInfo->bA2dpExist)  //HID+A2DP
 	{
-		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
-			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )	
-		{
-			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
-			pCoexDm->bAutoTdmaAdjust = FALSE;
-		}
-		else //for low BT RSSI
-		{
-			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
-			pCoexDm->bAutoTdmaAdjust = FALSE;
-		}		   	
+		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+		pCoexDm->bAutoTdmaAdjust = FALSE;
 
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 6);
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 3);
 	}
 	else if( (pBtLinkInfo->bPanOnly) || (pBtLinkInfo->bHidExist&&pBtLinkInfo->bPanExist) ) //PAN(OPP,FTP), HID+PAN(OPP,FTP)			
 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 6);
-		pCoexDm->bAutoTdmaAdjust = FALSE;
-	}
-	else if ( ((pBtLinkInfo->bA2dpExist) && (pBtLinkInfo->bPanExist)) ||
-		       (pBtLinkInfo->bHidExist&&pBtLinkInfo->bA2dpExist&&pBtLinkInfo->bPanExist) ) //A2DP+PAN(OPP,FTP), HID+A2DP+PAN(OPP,FTP)
-	{
-		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
 		pCoexDm->bAutoTdmaAdjust = FALSE;
 	}
 	else
 	{		
-		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+		//BT no-profile busy (0x9)
+		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);	
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
 		pCoexDm->bAutoTdmaAdjust = FALSE;
 	}	
 }
@@ -2221,7 +2467,8 @@ halbtc8723b1ant_ActionWifiNotConnected(
 	halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 
 	// tdma and coex table
-	halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+	halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);
+	halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
 	halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
 }
 
@@ -2233,25 +2480,24 @@ halbtc8723b1ant_ActionWifiNotConnectedScan(
 	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
 	
 	halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
-	halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);
 
 	// tdma and coex table
 	if(BT_8723B_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus)
 	{
-		if(pBtLinkInfo->bA2dpExist && pBtLinkInfo->bPanExist)
-	 	{
+		if (pBtLinkInfo->bA2dpExist)
+		{
+			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
+			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+		}
+		else if (pBtLinkInfo->bA2dpExist && pBtLinkInfo->bPanExist)
+		{
 			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
-			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
-	 	}
-		else if(pBtLinkInfo->bPanOnly)
-	 	{
-			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
-	 	}
+			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+		}
 	 	else
 	 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);			
 		}
 	}
 	else if( (BT_8723B_1ANT_BT_STATUS_SCO_BUSY == pCoexDm->btStatus) ||
@@ -2262,11 +2508,9 @@ halbtc8723b1ant_ActionWifiNotConnectedScan(
 	}
 	else
 	{
-		//halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-		//halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
-
 		//Bryant Add
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
 		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 	}
 }
@@ -2281,22 +2525,22 @@ halbtc8723b1ant_ActionWifiNotConnectedAssoAuth(
 	halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 
 	// tdma and coex table
-	if( (pBtLinkInfo->bScoExist)  || (pBtLinkInfo->bHidExist) )
+	if( (pBtLinkInfo->bScoExist)  || (pBtLinkInfo->bHidExist) ||  (pBtLinkInfo->bA2dpExist) )
 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 3);		
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 4);		
 	}
-	else if( (pBtLinkInfo->bA2dpExist)  || (pBtLinkInfo->bPanExist) ) 			
+	else if (pBtLinkInfo->bPanExist)   			
 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);		
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 4);		
 	}
 	else
 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 2);
 	}
-
 }
 
 VOID
@@ -2311,20 +2555,20 @@ halbtc8723b1ant_ActionWifiConnectedScan(
 	// tdma and coex table
 	if(BT_8723B_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus)
 	{
-		if(pBtLinkInfo->bA2dpExist && pBtLinkInfo->bPanExist)
-	 	{
-			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
-			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
-	 	}
-		else if(pBtLinkInfo->bPanOnly)
-	 	{
-			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
-	 	}
+		if (pBtLinkInfo->bA2dpExist)
+		{
+			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
+			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+		}
+		else if (pBtLinkInfo->bA2dpExist && pBtLinkInfo->bPanExist)
+		{
+			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+		}
 	 	else
 	 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
 	}
 	}
 	else if( (BT_8723B_1ANT_BT_STATUS_SCO_BUSY == pCoexDm->btStatus) ||
@@ -2335,11 +2579,9 @@ halbtc8723b1ant_ActionWifiConnectedScan(
 	}
 	else
 	{
-		//halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-		//halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
-
 		//Bryant Add
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
 		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 	}
 }
@@ -2354,12 +2596,12 @@ halbtc8723b1ant_ActionWifiConnectedSpecialPacket(
 	halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 
 	// tdma and coex table
-	if( (pBtLinkInfo->bScoExist)  || (pBtLinkInfo->bHidExist) )
+	if( (pBtLinkInfo->bScoExist)  || (pBtLinkInfo->bHidExist) || (pBtLinkInfo->bA2dpExist) )
 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
-		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 3);		
+		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);		
 	}
-	else if( (pBtLinkInfo->bA2dpExist)  || (pBtLinkInfo->bPanExist) ) 			
+	else if(pBtLinkInfo->bPanExist)
 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
 		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);		
@@ -2367,6 +2609,7 @@ halbtc8723b1ant_ActionWifiConnectedSpecialPacket(
 	else
 	{
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
 		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 	}
 }
@@ -2406,11 +2649,28 @@ halbtc8723b1ant_ActionWifiConnected(
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE, &bApEnable);
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	
 	// power save state
 	if(!bApEnable && BT_8723B_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus && !pBtCoexist->btLinkInfo.bHidOnly)
 	{
-		if(!bWifiBusy && pBtCoexist->btLinkInfo.bA2dpOnly)	//A2DP
+		if(pBtCoexist->btLinkInfo.bA2dpOnly)	//A2DP
+			{			
+			if(!bWifiBusy)
+				halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);				
+			else //busy
+			{
+				if  (pCoexSta->nScanAPNum >= BT_8723B_1ANT_WIFI_NOISY_THRESH)  //no force LPS, no PS-TDMA, use pure TDMA
+				{
 			halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+				}
+				else
+				{
+					halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);					
+				}
+			}
+		}
+		else if ((pCoexSta->bPanExist == FALSE) && (pCoexSta->bA2dpExist == FALSE) && (pCoexSta->bHidExist == FALSE))
+ 			halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 		else
 			halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);
 	}
@@ -2434,7 +2694,11 @@ halbtc8723b1ant_ActionWifiConnected(
 		else
 		{
 			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+			halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);
+			if ( (pCoexSta->highPriorityTx) + (pCoexSta->highPriorityRx) <= 60 )
 			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+			else
+				halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7); 		 
 		}
 	}
 	else
@@ -2453,7 +2717,11 @@ halbtc8723b1ant_ActionWifiConnected(
 		else 
 		{
 			halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+			halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, NORMAL_EXEC, FALSE, FALSE);	
+			if ( (pCoexSta->highPriorityTx) + (pCoexSta->highPriorityRx) <= 60 )
 			halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+			else
+				halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7); 
 		}
 	}
 }
@@ -2478,43 +2746,43 @@ halbtc8723b1ant_RunSwCoexistMechanism(
 		{
 			case BT_8723B_1ANT_COEX_ALGO_SCO:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = SCO.\n"));
-				halbtc8723b1ant_ActionSco(pBtCoexist);
+				//halbtc8723b1ant_ActionSco(pBtCoexist);
 				break;
 			case BT_8723B_1ANT_COEX_ALGO_HID:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = HID.\n"));
-				halbtc8723b1ant_ActionHid(pBtCoexist);
+				//halbtc8723b1ant_ActionHid(pBtCoexist);
 				break;
 			case BT_8723B_1ANT_COEX_ALGO_A2DP:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = A2DP.\n"));
-				halbtc8723b1ant_ActionA2dp(pBtCoexist);
+				//halbtc8723b1ant_ActionA2dp(pBtCoexist);
 				break;
 			case BT_8723B_1ANT_COEX_ALGO_A2DP_PANHS:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = A2DP+PAN(HS).\n"));
-				halbtc8723b1ant_ActionA2dpPanHs(pBtCoexist);
+				//halbtc8723b1ant_ActionA2dpPanHs(pBtCoexist);
 				break;
 			case BT_8723B_1ANT_COEX_ALGO_PANEDR:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = PAN(EDR).\n"));
-				halbtc8723b1ant_ActionPanEdr(pBtCoexist);
+				//halbtc8723b1ant_ActionPanEdr(pBtCoexist);
 				break;
 			case BT_8723B_1ANT_COEX_ALGO_PANHS:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = HS mode.\n"));
-				halbtc8723b1ant_ActionPanHs(pBtCoexist);
+				//halbtc8723b1ant_ActionPanHs(pBtCoexist);
 				break;
 			case BT_8723B_1ANT_COEX_ALGO_PANEDR_A2DP:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = PAN+A2DP.\n"));
-				halbtc8723b1ant_ActionPanEdrA2dp(pBtCoexist);
+				//halbtc8723b1ant_ActionPanEdrA2dp(pBtCoexist);
 				break;
 			case BT_8723B_1ANT_COEX_ALGO_PANEDR_HID:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = PAN(EDR)+HID.\n"));
-				halbtc8723b1ant_ActionPanEdrHid(pBtCoexist);
+				//halbtc8723b1ant_ActionPanEdrHid(pBtCoexist);
 				break;
 			case BT_8723B_1ANT_COEX_ALGO_HID_A2DP_PANEDR:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = HID+A2DP+PAN.\n"));
-				halbtc8723b1ant_ActionHidA2dpPanEdr(pBtCoexist);
+				//halbtc8723b1ant_ActionHidA2dpPanEdr(pBtCoexist);
 				break;
 			case BT_8723B_1ANT_COEX_ALGO_HID_A2DP:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = HID+A2DP.\n"));
-				halbtc8723b1ant_ActionHidA2dp(pBtCoexist);
+				//halbtc8723b1ant_ActionHidA2dp(pBtCoexist);
 				break;
 			default:
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action algorithm = coexist All Off!!\n"));
@@ -2534,10 +2802,11 @@ halbtc8723b1ant_RunCoexistMechanism(
 	BOOLEAN	bWifiConnected=FALSE, bBtHsOn=FALSE;
 	BOOLEAN	bIncreaseScanDevNum=FALSE;
 	BOOLEAN	bBtCtrlAggBufSize=FALSE;
+	BOOLEAN	bMiracastPlusBt=FALSE;
 	u1Byte	aggBufSize=5;
 	u1Byte	wifiRssiState=BTC_RSSI_STATE_HIGH;
 	u4Byte	wifiLinkStatus=0;
-	u4Byte	numOfWifiLink=0;
+	u4Byte	numOfWifiLink=0, wifiBw;
 
 	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], RunCoexistMechanism()===>\n"));
 
@@ -2559,6 +2828,13 @@ halbtc8723b1ant_RunCoexistMechanism(
 		return;
 	}
 
+	if(pCoexSta->bBtWhckTest)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], BT is under WHCK TEST!!!\n"));
+		halbtc8723b1ant_ActionBtWhckTest(pBtCoexist);
+		return;
+	}
+
 	if( (BT_8723B_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus) ||
 		(BT_8723B_1ANT_BT_STATUS_SCO_BUSY == pCoexDm->btStatus) ||
 		(BT_8723B_1ANT_BT_STATUS_ACL_SCO_BUSY == pCoexDm->btStatus) )
@@ -2571,62 +2847,79 @@ halbtc8723b1ant_RunCoexistMechanism(
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
 	numOfWifiLink = wifiLinkStatus>>16;
-	if(numOfWifiLink >= 2)
+	
+	if((numOfWifiLink>=2) || (wifiLinkStatus&WIFI_P2P_GO_CONNECTED))
 	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("############# [BTCoex],  Multi-Port numOfWifiLink = %d, wifiLinkStatus = 0x%x\n", numOfWifiLink,wifiLinkStatus) );
+
+		if(pBtLinkInfo->bBtLinkExist)
+		{
+			halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 1, 1, 0, 1);
+			bMiracastPlusBt = TRUE;
+		}
+		else
+		{
 		halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
+			bMiracastPlusBt = FALSE;
+		}
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_MIRACAST_PLUS_BT, &bMiracastPlusBt);
 		halbtc8723b1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, bBtCtrlAggBufSize, aggBufSize);
+
+		if ( (pBtLinkInfo->bA2dpExist) && (pCoexSta->bC2hBtInquiryPage) )
+		{
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("############# [BTCoex],  BT Is Inquirying \n") );	
+			halbtc8723b1ant_ActionBtInquiry(pBtCoexist);
+		}
+		else
 		halbtc8723b1ant_ActionWifiMultiPort(pBtCoexist);
+		
 		return;
 	}
-
-	if(!pBtLinkInfo->bScoExist && !pBtLinkInfo->bHidExist)
+	else
 	{
-		halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		bMiracastPlusBt = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_MIRACAST_PLUS_BT, &bMiracastPlusBt);
 	}
-	else
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if ( (pBtLinkInfo->bBtLinkExist) && (bWifiConnected) )
 	{
-		if(bWifiConnected)
-		{
-			wifiRssiState = halbtc8723b1ant_WifiRssiState(pBtCoexist, 1, 2, 30, 0);
-			if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
-				(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
-			{
-				halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 1, 1, 1, 1);
-			}
-			else
-			{
-				halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 1, 1, 1, 1);
-			}
-		}
+		halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 1, 1, 0, 1); 
+
+		if (pBtLinkInfo->bBtHiPriLinkExist)
+			halbtc8723b1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x5);	
+		else
+			halbtc8723b1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x5);
+		/*
+		if(pBtLinkInfo->bScoExist)
+			halbtc8723b1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, TRUE, FALSE, 0x5);
 		else
 		{
-			halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
+			if (BTC_WIFI_BW_HT40==wifiBw)
+			halbtc8723b1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, TRUE, 0x10);	
+		else
+			halbtc8723b1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, TRUE, 0x8);
 		}
+		*/
 
+		halbtc8723b1ant_SwMechanism(pBtCoexist, TRUE);
+		halbtc8723b1ant_RunSwCoexistMechanism(pBtCoexist);  //just print debug message
 	}
-
-	if(pBtLinkInfo->bScoExist)
-	{
-		bBtCtrlAggBufSize = TRUE;
-		aggBufSize = 0x3;
-	}
-	else if(pBtLinkInfo->bHidExist)
-	{
-		bBtCtrlAggBufSize = TRUE;
-		aggBufSize = 0x5;
-	}
-	else if(pBtLinkInfo->bA2dpExist || pBtLinkInfo->bPanExist)
+	else
 	{
-		bBtCtrlAggBufSize = TRUE;
-		aggBufSize = 0x8;
-	}
-	halbtc8723b1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, bBtCtrlAggBufSize, aggBufSize);
+		halbtc8723b1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
 
-	halbtc8723b1ant_RunSwCoexistMechanism(pBtCoexist);
+		halbtc8723b1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x5);
+
+		halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
+		halbtc8723b1ant_RunSwCoexistMechanism(pBtCoexist); ////just print debug message
+	}
 	
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
 	if(pCoexSta->bC2hBtInquiryPage)
 	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("############# [BTCoex],  BT Is Inquirying \n") );		
 		halbtc8723b1ant_ActionBtInquiry(pBtCoexist);
 		return;
 	}
@@ -2674,24 +2967,26 @@ halbtc8723b1ant_InitCoexDm(
 	halbtc8723b1ant_SwMechanism(pBtCoexist, FALSE);
 	
 	//halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);
-	halbtc8723b1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 0);
+	//halbtc8723b1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 0);
+
+	pCoexSta->popEventCnt = 0;
 }
 
 VOID
 halbtc8723b1ant_InitHwConfig(
 	IN	PBTC_COEXIST		pBtCoexist,
-	IN	BOOLEAN				bBackUp
+	IN	BOOLEAN				bBackUp,
+	IN	BOOLEAN				bWifiOnly
 	)
 {
 	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
 	u4Byte				u4Tmp=0;//, fwVer;
 	u2Byte				u2Tmp=0;
-	u1Byte				u1Tmp=0;
+	u1Byte				u1Tmp=0, u1Tmpa=0, u1Tmpb=0;
 	u1Byte				H2C_Parameter[2] ={0};
-	u4Byte				cntBtCalChk=0;
 
 	BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], 1Ant Init HW Config!!\n"));
-
+#if 0//move to BTC_MEDIA_CONNECT
 	if(bBackUp)
 	{
 		pCoexDm->backupArfrCnt1 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x430);
@@ -2699,60 +2994,61 @@ halbtc8723b1ant_InitHwConfig(
 		pCoexDm->backupRetryLimit = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0x42a);
 		pCoexDm->backupAmpduMaxTime = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x456);
 	}
+#endif
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x550, 0x8, 0x1);  //enable TBTT nterrupt
+
+	// 0x790[5:0]=0x5	
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x790, 0x5);
 	
-	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x780); //WiFi goto standby while GNT_BT 0-->1
-	//pBtCoexist->fBtcSetBtReg(pBtCoexist, 0, 0x3c, 0x15); //BT goto standby while GNT_BT 1-->0
+	// Enable counter statistics
+	//pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc); //0x76e[3] =1, WLAN_Act control by PTA
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x778, 0x1);
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x40, 0x20, 0x1);
 
-	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x974, 0xff);
-	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x944, 0x3, 0x3);
-	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x930, 0x77);
 
 	//pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x1); //BT select s0/s1 is controlled by WiFi
 
-	// BT calibration check
-	while(cntBtCalChk <= 20)
+	halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);
+	
+	//Antenna config
+	if(bWifiOnly)
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_WIFI, FORCE_EXEC, TRUE, FALSE);
+	else
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FORCE_EXEC, TRUE, FALSE);
+
+#if 0
+	if(bWifiOnly)
 	{
-		u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x49d);
-		cntBtCalChk++;
-		if(u4Tmp & BIT0)
-		{
-			BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], ########### BT calibration(cnt=%d) ###########\n", cntBtCalChk));
-			delay_ms(50);
-		}
-		else
-		{
-			BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], ********** BT NOT calibration (cnt=%d)**********\n", cntBtCalChk));
-			break;
-		}
+		halbtc8723b1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_WIFI, BTC_WIFI_STAT_INIT);
+		halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);
 	}
+	else
+		halbtc8723b1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_BT, BTC_WIFI_STAT_INIT);		
+#endif
 
-	// 0x790[5:0]=0x5
-	u1Tmp = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x790);
-	u1Tmp &= 0xc0;
-	u1Tmp |= 0x5;
-	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x790, u1Tmp);
-	
-	// Enable counter statistics
-	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc); //0x76e[3] =1, WLAN_Act control by PTA
-	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x778, 0x1);
-	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x40, 0x20, 0x1);	
 
-	//Antenna config
-	//halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, TRUE, FALSE);
-	halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, TRUE, FALSE);
 
 	// PTA parameter
 	halbtc8723b1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 0);
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
+	u1Tmpa = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765);
+	u1Tmpb = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x67);
+
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+			u4Tmp,  u1Tmpa, u1Tmpb));
 }
 
+/*
 VOID
 halbtc8723b1ant_WifiOffHwCfg(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
 	// set wlan_act to low
-	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4);
+	//pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4);
 }
+*/
 
 //============================================================
 // work around function start with wa_halbtc8723b1ant_
@@ -2761,11 +3057,87 @@ halbtc8723b1ant_WifiOffHwCfg(
 // extern function start with EXhalbtc8723b1ant_
 //============================================================
 VOID
-EXhalbtc8723b1ant_InitHwConfig(
+EXhalbtc8723b1ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO 	pBoardInfo=&pBtCoexist->boardInfo;
+	u1Byte u1Tmp=0x0;
+	u2Byte u2Tmp=0x0;
+
+	pBtCoexist->bStopCoexDm = TRUE;
+
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x67, 0x20);
+
+	// enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly.
+	u2Tmp = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0x2);
+	pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x2, u2Tmp|BIT0|BIT1);
+
+	// set GRAN_BT = 1
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x18);
+	// set WLAN_ACT = 0
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4);	
+
+	// 
+	// S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info)
+	// Local setting bit define
+	//	BIT0: "0" for no antenna inverse; "1" for antenna inverse 
+	//	BIT1: "0" for internal switch; "1" for external switch
+	//	BIT2: "0" for one antenna; "1" for two antenna
+	// NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0
+	if(pBtCoexist->chipInterface == BTC_INTF_USB)
+	{
+		// fixed at S0 for USB interface
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
+
+	 	u1Tmp |= 0x1;	// antenna inverse
+		pBtCoexist->fBtcWriteLocalReg1Byte(pBtCoexist, 0xfe08, u1Tmp);
+
+		pBoardInfo->btdmAntPos = BTC_ANTENNA_AT_AUX_PORT;
+	}
+	else
+	{
+		// for PCIE and SDIO interface, we check efuse 0xc3[6]
+		if(pBoardInfo->singleAntPath == 0)
+		{
+			// set to S1
+			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x280);
+			pBoardInfo->btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;
+		}
+		else if(pBoardInfo->singleAntPath == 1)
+		{
+			// set to S0
+			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
+			u1Tmp |= 0x1;	// antenna inverse
+			pBoardInfo->btdmAntPos = BTC_ANTENNA_AT_AUX_PORT;
+		}
+
+		if(pBtCoexist->chipInterface == BTC_INTF_PCI)
+		{	
+			pBtCoexist->fBtcWriteLocalReg1Byte(pBtCoexist, 0x384, u1Tmp);
+		}
+		else if(pBtCoexist->chipInterface == BTC_INTF_SDIO)
+		{
+			pBtCoexist->fBtcWriteLocalReg1Byte(pBtCoexist, 0x60, u1Tmp);
+		}			
+	}
+}
+
+VOID
+EXhalbtc8723b1ant_PreLoadFirmware(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	halbtc8723b1ant_InitHwConfig(pBtCoexist, TRUE);
+}
+
+VOID
+EXhalbtc8723b1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
+{
+	halbtc8723b1ant_InitHwConfig(pBtCoexist, TRUE, bWifiOnly);
+	pBtCoexist->bStopCoexDm = FALSE;
 }
 
 VOID
@@ -2794,12 +3166,9 @@ EXhalbtc8723b1ant_DisplayCoexInfo(
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u2Byte				u2Tmp[4];
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir, faOfdm, faCck, wifiLinkStatus;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
+	u4Byte				faOfdm, faCck;
 	u4Byte				fwVer=0, btPatchVer=0;
+	static u1Byte			PopReportIn10s = 0;	
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
 	CL_PRINTF(cliBuf);
@@ -2819,13 +3188,6 @@ EXhalbtc8723b1ant_DisplayCoexInfo(
 		CL_PRINTF(cliBuf);
 	}
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d", "Ant PG Num/ Ant Mech/ Ant Pos:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum, pBoardInfo->btdmAntPos);
 	CL_PRINTF(cliBuf);	
@@ -2840,59 +3202,50 @@ EXhalbtc8723b1ant_DisplayCoexInfo(
 		GLCoexVerDate8723b1Ant, GLCoexVer8723b1Ant, fwVer, btPatchVer, btPatchVer);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(HsMode)", \
-		wifiDot11Chnl, wifiHsChnl, bBtHsOn);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/ %s", "Wifi bHi-Pri/ Wifi CCK locked", \
+		(pCoexSta->bWiFiIsHighPriTask? "Yes":"No"),
+		(pCoexSta->bCCKLock? "Lock":"noLock") );
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d", "sta/vwifi/hs/p2pGo/p2pGc", \
-		((wifiLinkStatus&WIFI_STA_CONNECTED)? 1:0), ((wifiLinkStatus&WIFI_AP_CONNECTED)? 1:0), 
-		((wifiLinkStatus&WIFI_HS_CONNECTED)? 1:0), ((wifiLinkStatus&WIFI_P2P_GO_CONNECTED)? 1:0), 
-		((wifiLinkStatus&WIFI_P2P_GC_CONNECTED)? 1:0) );
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 	
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
+	PopReportIn10s++;
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d/ %d] ", "BT [status/ rssi/ retryCnt/ popCnt]", \
 		((pBtCoexist->btInfo.bBtDisabled)? ("disabled"):	((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE == pCoexDm->btStatus)? "non-connected idle":
 		(  (BT_8723B_1ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy")))),
-		pCoexSta->btRssi, pCoexSta->btRetryCnt);
+		pCoexSta->btRssi, pCoexSta->btRetryCnt, pCoexSta->popEventCnt);
 	CL_PRINTF(cliBuf);
 	
-				
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP", \
-		pBtLinkInfo->bScoExist, pBtLinkInfo->bHidExist, pBtLinkInfo->bPanExist, pBtLinkInfo->bA2dpExist);
+	if (PopReportIn10s >= 5)
+	{
+		pCoexSta->popEventCnt = 0;	
+		PopReportIn10s = 0;
+	}
+	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d / %d", "SCO/HID/PAN/A2DP/Hi-Pri", \
+		pBtLinkInfo->bScoExist, pBtLinkInfo->bHidExist, pBtLinkInfo->bPanExist, pBtLinkInfo->bA2dpExist, pBtLinkInfo->bBtHiPriLinkExist);
 	CL_PRINTF(cliBuf);
+
+	if (pStackInfo->bProfileNotified)
+	{
 	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_BT_LINK_INFO);	
+	}
+	else
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Role", \
+		(pBtLinkInfo->bSlaveRole )? "Slave":"Master");
+		CL_PRINTF(cliBuf);	
+	}	
 
 	btInfoExt = pCoexSta->btInfoExt;
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Info A2DP rate", \
@@ -2911,13 +3264,6 @@ EXhalbtc8723b1ant_DisplayCoexInfo(
 			CL_PRINTF(cliBuf);
 		}
 	}
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/%s, (0x%x/0x%x)", "PS state, IPS/LPS, (lps/rpwm)", \
-		((pCoexSta->bUnderIps? "IPS ON":"IPS OFF")),
-		((pCoexSta->bUnderLps? "LPS ON":"LPS OFF")), 
-		pBtCoexist->btInfo.lpsVal, 
-		pBtCoexist->btInfo.rpwmVal);
-	CL_PRINTF(cliBuf);
-	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_FW_PWR_MODE_CMD);
 
 	if(!pBtCoexist->bManualControl)
 	{
@@ -2948,13 +3294,19 @@ EXhalbtc8723b1ant_DisplayCoexInfo(
 			pCoexDm->psTdmaPara[4], psTdmaCase, pCoexDm->bAutoTdmaAdjust);
 		CL_PRINTF(cliBuf);
 		
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "Coex Table Type", \
+			pCoexSta->nCoexTableType);
+		CL_PRINTF(cliBuf);
+		
 		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "IgnWlanAct", \
 			pCoexDm->bCurIgnoreWlanAct);
 		CL_PRINTF(cliBuf);
 	
+		/*
 		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "Latest error condition(should be 0)", \
 			pCoexDm->errorCondition);
 		CL_PRINTF(cliBuf);
+		*/
 	}
 
 	// Hw setting		
@@ -2982,9 +3334,10 @@ EXhalbtc8723b1ant_DisplayCoexInfo(
 
 	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
 	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x67);
-	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x948/ 0x67[5] / 0x765", \
-		u4Tmp[0], ((u1Tmp[0]&0x20)>> 5), u1Tmp[1]);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x764);
+	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0x948/ 0x67[5] / 0x764 / 0x76e", \
+		u4Tmp[0], ((u1Tmp[0]&0x20)>> 5), (u4Tmp[1] & 0xffff), u1Tmp[1]);
 	CL_PRINTF(cliBuf);
 
 	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x92c);
@@ -3030,6 +3383,15 @@ EXhalbtc8723b1ant_DisplayCoexInfo(
 		u4Tmp[0]&0xffff, faOfdm, faCck);
 	CL_PRINTF(cliBuf);
 
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d", "CRC_OK CCK/11g/11n/11n-Agg", \
+		pCoexSta->nCRCOK_CCK, pCoexSta->nCRCOK_11g, pCoexSta->nCRCOK_11n, pCoexSta->nCRCOK_11nAgg);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d", "CRC_Err CCK/11g/11n/11n-Agg", \
+		pCoexSta->nCRCErr_CCK, pCoexSta->nCRCErr_11g, pCoexSta->nCRCErr_11n, pCoexSta->nCRCErr_11nAgg);
+	CL_PRINTF(cliBuf);	
+
 	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c0);
 	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c4);
 	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c8);
@@ -3044,7 +3406,7 @@ EXhalbtc8723b1ant_DisplayCoexInfo(
 		pCoexSta->lowPriorityRx, pCoexSta->lowPriorityTx);
 	CL_PRINTF(cliBuf);
 #if(BT_AUTO_REPORT_ONLY_8723B_1ANT == 1)
-	halbtc8723b1ant_MonitorBtCtr(pBtCoexist);
+	//halbtc8723b1ant_MonitorBtCtr(pBtCoexist);
 #endif
 	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
 }
@@ -3065,21 +3427,21 @@ EXhalbtc8723b1ant_IpsNotify(
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], IPS ENTER notify\n"));
 		pCoexSta->bUnderIps = TRUE;
-		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, TRUE);
+		
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FORCE_EXEC, FALSE, TRUE);
 		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
-		halbtc8723b1ant_WifiOffHwCfg(pBtCoexist);
+		//halbtc8723b1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF);
 	}
 	else if(BTC_IPS_LEAVE == type)
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], IPS LEAVE notify\n"));
-		pCoexSta->bUnderIps = FALSE;
-		//halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, TRUE, FALSE);
-		//halbtc8723b1ant_RunCoexistMechanism(pBtCoexist);
 
-		halbtc8723b1ant_InitHwConfig(pBtCoexist, FALSE);
+		halbtc8723b1ant_InitHwConfig(pBtCoexist, FALSE, FALSE);
 		halbtc8723b1ant_InitCoexDm(pBtCoexist);
 		halbtc8723b1ant_QueryBtInfo(pBtCoexist);
+
+		pCoexSta->bUnderIps = FALSE;
 	}
 }
 
@@ -3116,25 +3478,42 @@ EXhalbtc8723b1ant_ScanNotify(
 	BOOLEAN	bBtCtrlAggBufSize=FALSE;
 	u1Byte	aggBufSize=5;
 
+	u1Byte u1Tmpa, u1Tmpb;
+	u4Byte u4Tmp;
+
 	if(pBtCoexist->bManualControl ||
-		pBtCoexist->bStopCoexDm ||
-		pBtCoexist->btInfo.bBtDisabled )
+		pBtCoexist->bStopCoexDm )
 		return;
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
-
 	if(BTC_SCAN_START == type)
 	{
 		pCoexSta->bWiFiIsHighPriTask = TRUE;
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN START notify\n"));
+
+		halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);  //Force antenna setup for no scan result issue
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, FORCE_EXEC, FALSE, FALSE);
+		u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
+		u1Tmpa = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765);
+		u1Tmpb = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x67);
+          
+	   
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x\n",
+			u4Tmp,  u1Tmpa, u1Tmpb));
 	}
 	else
 	{
 		pCoexSta->bWiFiIsHighPriTask = FALSE;	
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN FINISH notify\n"));
+
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &pCoexSta->nScanAPNum);		
 	}
 
+	if(pBtCoexist->btInfo.bBtDisabled)
+		return;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+
 	halbtc8723b1ant_QueryBtInfo(pBtCoexist);
 	
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
@@ -3204,12 +3583,16 @@ EXhalbtc8723b1ant_ConnectNotify(
 	if(BTC_ASSOCIATE_START == type)
 	{
 		pCoexSta->bWiFiIsHighPriTask = TRUE;
+		halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);  //Force antenna setup for no scan result issue
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, FORCE_EXEC, FALSE, FALSE);
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT START notify\n"));	
+		 pCoexDm->nArpCnt = 0;
 	}
 	else
 	{
 		pCoexSta->bWiFiIsHighPriTask = FALSE;	
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT FINISH notify\n"));	
+		//pCoexDm->nArpCnt = 0;
 	}
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
@@ -3264,6 +3647,7 @@ EXhalbtc8723b1ant_MediaStatusNotify(
 	u1Byte			H2C_Parameter[3] ={0};
 	u4Byte			wifiBw;
 	u1Byte			wifiCentralChnl;
+	BOOLEAN			bWifiUnderBMode = FALSE;
 
 	if(pBtCoexist->bManualControl ||
 		pBtCoexist->bStopCoexDm ||
@@ -3273,10 +3657,34 @@ EXhalbtc8723b1ant_MediaStatusNotify(
 	if(BTC_MEDIA_CONNECT == type)
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], MEDIA connect notify\n"));
+		halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);  //Force antenna setup for no scan result issue
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, FORCE_EXEC, FALSE, FALSE);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_B_MODE, &bWifiUnderBMode);
+
+		//Set CCK Tx/Rx high Pri except 11b mode
+		if (bWifiUnderBMode)
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cd, 0x00); //CCK Tx
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cf, 0x00); //CCK Rx
+		}
+		else
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cd, 0x10); //CCK Tx
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cf, 0x10); //CCK Rx
+		}
+		
+		pCoexDm->backupArfrCnt1 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x430);
+		pCoexDm->backupArfrCnt2 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x434);
+		pCoexDm->backupRetryLimit = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0x42a);
+		pCoexDm->backupAmpduMaxTime = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x456);
 	}
 	else
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], MEDIA disconnect notify\n"));
+		pCoexDm->nArpCnt = 0;
+
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cd, 0x0); //CCK Tx
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cf, 0x0); //CCK Rx
 	}
 
 	// only 2.4G we need to inform bt the chnl mask
@@ -3321,16 +3729,29 @@ EXhalbtc8723b1ant_SpecialPacketNotify(
 		pBtCoexist->btInfo.bBtDisabled )
 		return;
 
-	if( BTC_PACKET_DHCP == type || 	 BTC_PACKET_EAPOL == type ||BTC_PACKET_ARP == type)
+	if( BTC_PACKET_DHCP == type || 
+		BTC_PACKET_EAPOL == type ||
+		BTC_PACKET_ARP == type )
 	{
-		pCoexSta->bWiFiIsHighPriTask = TRUE;
-
 		if (BTC_PACKET_ARP == type)
 		{
 			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], special Packet ARP notify\n"));		 
+
+			pCoexDm->nArpCnt++;
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], ARP Packet Count = %d\n", pCoexDm->nArpCnt));
+			
+			if(pCoexDm->nArpCnt >= 10) // if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecialPacket(pBtCoexist) 
+			{
+				pCoexSta->bWiFiIsHighPriTask = FALSE;					
+			}			
+			else
+			{
+				pCoexSta->bWiFiIsHighPriTask = TRUE;
+			}
 		}
 		else
 		{
+			pCoexSta->bWiFiIsHighPriTask = TRUE;
 			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], special Packet DHCP or EAPOL notify\n"));		 
 		}
 	} 
@@ -3365,9 +3786,9 @@ EXhalbtc8723b1ant_SpecialPacketNotify(
 	}
 
 	if( BTC_PACKET_DHCP == type ||
-		BTC_PACKET_EAPOL == type  || BTC_PACKET_ARP == type)
-	{
-		//BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], special Packet(%d) notify\n", type));
+		BTC_PACKET_EAPOL == type || 
+		( (BTC_PACKET_ARP == type ) && (pCoexSta->bWiFiIsHighPriTask) ) )
+		{
 		halbtc8723b1ant_ActionWifiConnectedSpecialPacket(pBtCoexist);
 	}
 }
@@ -3398,7 +3819,6 @@ EXhalbtc8723b1ant_BtInfoNotify(
 		pCoexSta->btInfoC2h[rspSource][i] = tmpBuf[i];
 		if(i == 1)
 			btInfo = tmpBuf[i];
-		
 		if(i == length-1)
 		{
 			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("0x%02x]\n", tmpBuf[i]));
@@ -3407,30 +3827,41 @@ EXhalbtc8723b1ant_BtInfoNotify(
 		{
 			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("0x%02x, ", tmpBuf[i]));
 		}
-			
 	}
 
+	// if 0xff, it means BT is under WHCK test
+	if (btInfo == 0xff)
+		pCoexSta->bBtWhckTest = TRUE;
+	else
+		pCoexSta->bBtWhckTest = FALSE;
+
 	if(BT_INFO_SRC_8723B_1ANT_WIFI_FW != rspSource)
 	{
 		pCoexSta->btRetryCnt =	// [3:0]
 			pCoexSta->btInfoC2h[rspSource][2]&0xf;
 
+		if (pCoexSta->btRetryCnt >= 1)
+			pCoexSta->popEventCnt++;
+
 		if (pCoexSta->btInfoC2h[rspSource][2]&0x20)
 			pCoexSta->bC2hBtPage = TRUE;
 		else
 			pCoexSta->bC2hBtPage = FALSE;			
 
 		pCoexSta->btRssi =
-			pCoexSta->btInfoC2h[rspSource][3]*2+10;
+			pCoexSta->btInfoC2h[rspSource][3]*2-90;
+			//pCoexSta->btInfoC2h[rspSource][3]*2+10;
 
 		pCoexSta->btInfoExt = 
 			pCoexSta->btInfoC2h[rspSource][4];
 		
-		if (!(pCoexSta->btInfoC2h[rspSource][2] & 0x40))
+		pCoexSta->bBtTxRxMask = (pCoexSta->btInfoC2h[rspSource][2]&0x40);
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TX_RX_MASK, &pCoexSta->bBtTxRxMask);
+		if(!pCoexSta->bBtTxRxMask)
 		{
-			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch GNT_BT */				
-			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Switch GNT_BT since BT RF REG 0x3C != 0x15\n"));
-			pBtCoexist->fBtcSetBtReg(pBtCoexist, 0, 0x3c, 0x15);
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */				
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n"));
+			pBtCoexist->fBtcSetBtReg(pBtCoexist, BTC_BT_REG_RF, 0x3c, 0x15);
 		}
 		
 		// Here we need to resend some wifi info to BT
@@ -3487,6 +3918,8 @@ EXhalbtc8723b1ant_BtInfoNotify(
 		pCoexSta->bA2dpExist = FALSE;
 		pCoexSta->bHidExist = FALSE;
 		pCoexSta->bScoExist = FALSE;
+
+		pCoexSta->bBtHiPriLinkExist = FALSE;
 	}
 	else	// connection exists
 	{
@@ -3507,10 +3940,16 @@ EXhalbtc8723b1ant_BtInfoNotify(
 			pCoexSta->bScoExist = TRUE;
 		else
 			pCoexSta->bScoExist = FALSE;
+
+		//Add Hi-Pri Tx/Rx counter to avoid false detection
+		if ( ( (pCoexSta->bHidExist) || (pCoexSta->bScoExist) ) && (pCoexSta->highPriorityTx > 60)  &&  (pCoexSta->highPriorityRx > 60))
+			pCoexSta->bBtHiPriLinkExist = TRUE;
 	}
 
 	halbtc8723b1ant_UpdateBtLinkInfo(pBtCoexist);
 	
+	btInfo = btInfo & 0x1f;  //mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41)
+	
 	if(!(btInfo&BT_INFO_8723B_1ANT_B_CONNECTION))
 	{
 		pCoexDm->btStatus = BT_8723B_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
@@ -3551,6 +3990,46 @@ EXhalbtc8723b1ant_BtInfoNotify(
 	halbtc8723b1ant_RunCoexistMechanism(pBtCoexist);
 }
 
+VOID
+EXhalbtc8723b1ant_RfStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte					type
+	)
+{
+	u4Byte	u4Tmp;
+	u1Byte	u1Tmpa,u1Tmpb, u1Tmpc;
+	
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], RF Status notify\n"));
+
+	if(BTC_RF_ON == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], RF is turned ON!!\n"));
+		pBtCoexist->bStopCoexDm = FALSE;
+	}
+	else if(BTC_RF_OFF == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], RF is turned OFF!!\n"));
+		
+		halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 0);
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FORCE_EXEC, FALSE, TRUE);
+		//halbtc8723b1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF);
+		
+		halbtc8723b1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+		pBtCoexist->bStopCoexDm = TRUE;
+
+		u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
+		u1Tmpa = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765);
+ 		u1Tmpb = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x67);
+		u1Tmpc = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e);
+
+
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x67=0x%x, 0x76e=0x%x\n",
+			u4Tmp,  u1Tmpa, u1Tmpb, u1Tmpc));
+
+	}
+}
+
 VOID
 EXhalbtc8723b1ant_HaltNotify(
 	IN	PBTC_COEXIST			pBtCoexist
@@ -3560,16 +4039,16 @@ EXhalbtc8723b1ant_HaltNotify(
 	
 	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Halt notify\n"));
 
-	pBtCoexist->bStopCoexDm = TRUE;
-
-	halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, TRUE);
-	halbtc8723b1ant_WifiOffHwCfg(pBtCoexist);
-	halbtc8723b1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
-
 	halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 	halbtc8723b1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 0);
+	halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FORCE_EXEC, FALSE, TRUE);
+	//halbtc8723b1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF);
+
+	halbtc8723b1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
 
 	EXhalbtc8723b1ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+
+	pBtCoexist->bStopCoexDm = TRUE;	
 }
 
 VOID
@@ -3583,24 +4062,20 @@ EXhalbtc8723b1ant_PnpNotify(
 	if(BTC_WIFI_PNP_SLEEP == pnpState)
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to SLEEP\n"));
-		pBtCoexist->bStopCoexDm = TRUE;
-		/*
-		halbtc8723b1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
-		halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
-		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9);	
-		*/
 
-		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, TRUE);
 		halbtc8723b1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 		halbtc8723b1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		halbtc8723b1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FORCE_EXEC, FALSE, TRUE);
 		halbtc8723b1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
-		halbtc8723b1ant_WifiOffHwCfg(pBtCoexist);
+		//halbtc8723b1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF);
+
+		pBtCoexist->bStopCoexDm = TRUE;
 	}
 	else if(BTC_WIFI_PNP_WAKE_UP == pnpState)
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to WAKE UP\n"));
 		pBtCoexist->bStopCoexDm = FALSE;
-		halbtc8723b1ant_InitHwConfig(pBtCoexist, FALSE);
+		halbtc8723b1ant_InitHwConfig(pBtCoexist, FALSE, FALSE);
 		halbtc8723b1ant_InitCoexDm(pBtCoexist);
 		halbtc8723b1ant_QueryBtInfo(pBtCoexist);
 	}
@@ -3613,9 +4088,9 @@ EXhalbtc8723b1ant_CoexDmReset(
 {
 	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], *****************Coex DM Reset*****************\n"));
 
-	halbtc8723b1ant_InitHwConfig(pBtCoexist, FALSE);
-	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
-	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x2, 0xfffff, 0x0);
+	halbtc8723b1ant_InitHwConfig(pBtCoexist, FALSE, FALSE);
+	//pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	//pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x2, 0xfffff, 0x0);
 	halbtc8723b1ant_InitCoexDm(pBtCoexist);
 }
 
@@ -3648,16 +4123,16 @@ EXhalbtc8723b1ant_Periodical(
 
 #if(BT_AUTO_REPORT_ONLY_8723B_1ANT == 0)
 	halbtc8723b1ant_QueryBtInfo(pBtCoexist);
-	halbtc8723b1ant_MonitorBtCtr(pBtCoexist);
 	halbtc8723b1ant_MonitorBtEnableDisable(pBtCoexist);
 #else
+	halbtc8723b1ant_MonitorBtCtr(pBtCoexist);
+	halbtc8723b1ant_MonitorWiFiCtr(pBtCoexist);
+
 	if( halbtc8723b1ant_IsWifiStatusChanged(pBtCoexist) ||
 		pCoexDm->bAutoTdmaAdjust )
 	{
-		//if(pCoexSta->specialPktPeriodCnt > 2)
-		//{
-			halbtc8723b1ant_RunCoexistMechanism(pBtCoexist);	
-		//}
+
+		halbtc8723b1ant_RunCoexistMechanism(pBtCoexist);	
 	}
 
 	pCoexSta->specialPktPeriodCnt++;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.h
index f6db10a68675..f7ebc96e8bd9 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b1Ant.h
@@ -17,6 +17,8 @@
 
 #define	BTC_RSSI_COEX_THRESH_TOL_8723B_1ANT		2
 
+#define  BT_8723B_1ANT_WIFI_NOISY_THRESH								30   //max: 255
+
 typedef enum _BT_INFO_SRC_8723B_1ANT{
 	BT_INFO_SRC_8723B_1ANT_WIFI_FW			= 0x0,
 	BT_INFO_SRC_8723B_1ANT_BT_RSP				= 0x1,
@@ -60,6 +62,9 @@ typedef enum _BT_8723B_1ANT_COEX_ALGO{
 }BT_8723B_1ANT_COEX_ALGO,*PBT_8723B_1ANT_COEX_ALGO;
 
 typedef struct _COEX_DM_8723B_1ANT{
+	// hw setting
+	u1Byte		preAntPosType;
+	u1Byte		curAntPosType;
 	// fw mechanism
 	BOOLEAN		bCurIgnoreWlanAct;
 	BOOLEAN		bPreIgnoreWlanAct;
@@ -109,6 +114,7 @@ typedef struct _COEX_DM_8723B_1ANT{
 	u1Byte		curRetryLimitType;
 	u1Byte		preAmpduTimeType;
 	u1Byte		curAmpduTimeType;
+	u4Byte		nArpCnt;
 
 	u1Byte		errorCondition;
 } COEX_DM_8723B_1ANT, *PCOEX_DM_8723B_1ANT;
@@ -119,6 +125,7 @@ typedef struct _COEX_STA_8723B_1ANT{
 	BOOLEAN					bA2dpExist;
 	BOOLEAN					bHidExist;
 	BOOLEAN					bPanExist;
+	BOOLEAN					bBtHiPriLinkExist;
 
 	BOOLEAN					bUnderLps;
 	BOOLEAN					bUnderIps;
@@ -127,27 +134,56 @@ typedef struct _COEX_STA_8723B_1ANT{
 	u4Byte					highPriorityRx;
 	u4Byte					lowPriorityTx;
 	u4Byte					lowPriorityRx;
-	u1Byte					btRssi;
+	s1Byte					btRssi;
+	BOOLEAN					bBtTxRxMask;
 	u1Byte					preBtRssiState;
 	u1Byte					preWifiRssiState[4];
 	BOOLEAN					bC2hBtInfoReqSent;
 	u1Byte					btInfoC2h[BT_INFO_SRC_8723B_1ANT_MAX][10];
 	u4Byte					btInfoC2hCnt[BT_INFO_SRC_8723B_1ANT_MAX];
+	BOOLEAN					bBtWhckTest;
 	BOOLEAN					bC2hBtInquiryPage;
+	BOOLEAN					bC2hBtPage;				//Add for win8.1 page out issue
+	BOOLEAN					bWiFiIsHighPriTask;		//Add for win8.1 page out issue
 	u1Byte					btRetryCnt;
 	u1Byte					btInfoExt;
-	BOOLEAN					bWiFiIsHighPriTask;
-	BOOLEAN					bC2hBtPage;
+	u4Byte					popEventCnt;
+	u1Byte					nScanAPNum;
+
+	u4Byte					nCRCOK_CCK;
+	u4Byte					nCRCOK_11g;
+	u4Byte					nCRCOK_11n;
+	u4Byte					nCRCOK_11nAgg;
+	
+	u4Byte					nCRCErr_CCK;
+	u4Byte					nCRCErr_11g;
+	u4Byte					nCRCErr_11n;
+	u4Byte					nCRCErr_11nAgg;	
+
+	BOOLEAN					bCCKLock;
+	BOOLEAN					bPreCCKLock;
+	u1Byte					nCoexTableType;
+
+	BOOLEAN					bForceLpsOn;
 }COEX_STA_8723B_1ANT, *PCOEX_STA_8723B_1ANT;
 
 //===========================================
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8723b1ant_InitHwConfig(
+EXhalbtc8723b1ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8723b1ant_PreLoadFirmware(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8723b1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8723b1ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
@@ -188,6 +224,11 @@ EXhalbtc8723b1ant_BtInfoNotify(
 	IN	u1Byte			length
 	);
 VOID
+EXhalbtc8723b1ant_RfStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte					type
+	);
+VOID
 EXhalbtc8723b1ant_HaltNotify(
 	IN	PBTC_COEXIST			pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.c
index dc29ba287a3a..096b30da729d 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.c
@@ -27,8 +27,8 @@ const char *const GLBtInfoSrc8723b2Ant[]={
 	"BT Info[bt auto report]",
 };
 
-u4Byte	GLCoexVerDate8723b2Ant=20131113;
-u4Byte	GLCoexVer8723b2Ant=0x3f;
+u4Byte	GLCoexVerDate8723b2Ant=20140730;
+u4Byte	GLCoexVer8723b2Ant=0x42;
 
 //============================================================
 // local function proto type if needed
@@ -303,6 +303,31 @@ halbtc8723b2ant_MonitorBtEnableDisable(
 	}
 }
 
+VOID
+halbtc8723b2ant_LimitedRx(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	BOOLEAN				bRejApAggPkt,
+	IN	BOOLEAN				bBtCtrlAggBufSize,
+	IN	u1Byte				aggBufSize
+	)
+{
+	BOOLEAN	bRejectRxAgg=bRejApAggPkt;
+	BOOLEAN	bBtCtrlRxAggSize=bBtCtrlAggBufSize;
+	u1Byte	rxAggSize=aggBufSize;
+
+	//============================================
+	//	Rx Aggregation related setting
+	//============================================
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT, &bRejectRxAgg);
+	// decide BT control aggregation buf size or not
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE, &bBtCtrlRxAggSize);
+	// aggregation buf size, only work when BT control Rx aggregation size.
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_AGG_BUF_SIZE, &rxAggSize);
+	// real update aggregation setting
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
 VOID
 halbtc8723b2ant_MonitorBtCtr(
 	IN	PBTC_COEXIST		pBtCoexist
@@ -337,6 +362,48 @@ halbtc8723b2ant_MonitorBtCtr(
 	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc);
 }
 
+VOID
+halbtc8723b2ant_MonitorWiFiCtr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u4Byte 	u4Tmp;
+	u2Byte 	u2Tmp[3];
+	s4Byte	wifiRssi=0;
+	BOOLEAN bWifiBusy = FALSE, bWifiUnderBMode = FALSE;
+	static u1Byte nCCKLockCounter = 0;
+
+
+	if (pCoexSta->bUnderIps)
+	{
+		pCoexSta->nCRCOK_CCK = 0;
+		pCoexSta->nCRCOK_11g = 0;
+		pCoexSta->nCRCOK_11n = 0;
+		pCoexSta->nCRCOK_11nAgg = 0;
+
+		pCoexSta->nCRCErr_CCK = 0;
+		pCoexSta->nCRCErr_11g = 0;
+		pCoexSta->nCRCErr_11n = 0;
+		pCoexSta->nCRCErr_11nAgg = 0;	
+	}
+	else
+	{
+		pCoexSta->nCRCOK_CCK	= pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xf88);
+		pCoexSta->nCRCOK_11g 	= pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf94);
+		pCoexSta->nCRCOK_11n	= pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf90);
+		pCoexSta->nCRCOK_11nAgg= pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xfb8);
+
+		pCoexSta->nCRCErr_CCK 	 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xf84);
+		pCoexSta->nCRCErr_11g 	 = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf96);
+		pCoexSta->nCRCErr_11n 	 = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xf92);
+		pCoexSta->nCRCErr_11nAgg = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0xfba);		
+	}
+
+	//reset counter
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xf16, 0x1, 0x1);
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xf16, 0x1, 0x0);
+}
+
 VOID
 halbtc8723b2ant_QueryBtInfo(
 	IN	PBTC_COEXIST		pBtCoexist
@@ -362,6 +429,8 @@ halbtc8723b2ant_IsWifiStatusChanged(
 	static BOOLEAN	bPreWifiBusy=FALSE, bPreUnder4way=FALSE, bPreBtHsOn=FALSE;
 	BOOLEAN	bWifiBusy=FALSE, bUnder4way=FALSE, bBtHsOn=FALSE;
 	BOOLEAN	bWifiConnected=FALSE;
+	u1Byte			wifiRssiState=BTC_RSSI_STATE_HIGH;
+	
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
@@ -385,6 +454,15 @@ halbtc8723b2ant_IsWifiStatusChanged(
 			bPreBtHsOn = bBtHsOn;
 			return TRUE;
 		}
+
+
+		wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist,3, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+
+		if ( (BTC_RSSI_STATE_HIGH ==wifiRssiState ) ||  (BTC_RSSI_STATE_LOW ==wifiRssiState ))
+		{
+			return TRUE;
+		}
+	
 	}
 
 	return FALSE;
@@ -685,50 +763,6 @@ halbtc8723b2ant_ActionAlgorithm(
 	return algorithm;
 }
 
-BOOLEAN
-halbtc8723b2ant_NeedToDecBtPwr(
-	IN	PBTC_COEXIST		pBtCoexist
-	)
-{
-	BOOLEAN		bRet=FALSE;
-	BOOLEAN		bBtHsOn=FALSE, bWifiConnected=FALSE;
-	s4Byte		btHsRssi=0;
-	u1Byte 		btRssiState;
-
-	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn))
-		return FALSE;
-	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected))
-		return FALSE;
-	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi))
-		return FALSE;
-
-	btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0);
-
-	if(bWifiConnected)
-	{
-		if(bBtHsOn)
-		{
-			if(btHsRssi > 37)
-			{
-				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], Need to decrease bt power for HS mode!!\n"));
-				bRet = TRUE;
-			}
-		}
-		else
-		{
-			if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
-			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
-			{
-		
-				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], Need to decrease bt power for Wifi is connected!!\n"));
-				bRet = TRUE;
-			}
-		}
-	}
-	
-	return bRet;
-}
-
 VOID
 halbtc8723b2ant_SetFwDacSwingLevel(
 	IN	PBTC_COEXIST		pBtCoexist,
@@ -750,20 +784,15 @@ halbtc8723b2ant_SetFwDacSwingLevel(
 VOID
 halbtc8723b2ant_SetFwDecBtPwr(
 	IN	PBTC_COEXIST		pBtCoexist,
-	IN	BOOLEAN			bDecBtPwr
+	IN	u1Byte				decBtPwrLvl
 	)
 {
 	u1Byte			H2C_Parameter[1] ={0};
 	
-	H2C_Parameter[0] = 0;
+	H2C_Parameter[0] = decBtPwrLvl;
 
-	if(bDecBtPwr)
-	{
-		H2C_Parameter[0] |= BIT1;
-	}
-
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], decrease Bt Power : %s, FW write 0x62=0x%x\n", 
-		(bDecBtPwr? "Yes!!":"No!!"), H2C_Parameter[0]));
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], decrease Bt Power level = %d, FW write 0x62=0x%x\n", 
+		decBtPwrLvl, H2C_Parameter[0]));
 
 	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x62, 1, H2C_Parameter);	
 }
@@ -772,24 +801,24 @@ VOID
 halbtc8723b2ant_DecBtPwr(
 	IN	PBTC_COEXIST		pBtCoexist,
 	IN	BOOLEAN			bForceExec,
-	IN	BOOLEAN			bDecBtPwr
+	IN	u1Byte				decBtPwrLvl
 	)
 {
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s Dec BT power = %s\n",  
-		(bForceExec? "force to":""), ((bDecBtPwr)? "ON":"OFF")));
-	pCoexDm->bCurDecBtPwr = bDecBtPwr;
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s Dec BT power level = %d\n",  
+		(bForceExec? "force to":""), decBtPwrLvl));
+	pCoexDm->curBtDecPwrLvl = decBtPwrLvl;
 
 	if(!bForceExec)
 	{
-		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], bPreDecBtPwr=%d, bCurDecBtPwr=%d\n", 
-			pCoexDm->bPreDecBtPwr, pCoexDm->bCurDecBtPwr));
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], preBtDecPwrLvl=%d, curBtDecPwrLvl=%d\n", 
+			pCoexDm->preBtDecPwrLvl, pCoexDm->curBtDecPwrLvl));
 
-		if(pCoexDm->bPreDecBtPwr == pCoexDm->bCurDecBtPwr) 
+		if(pCoexDm->preBtDecPwrLvl == pCoexDm->curBtDecPwrLvl) 
 			return;
 	}
-	halbtc8723b2ant_SetFwDecBtPwr(pBtCoexist, pCoexDm->bCurDecBtPwr);
+	halbtc8723b2ant_SetFwDecBtPwr(pBtCoexist, pCoexDm->curBtDecPwrLvl);
 
-	pCoexDm->bPreDecBtPwr = pCoexDm->bCurDecBtPwr;
+	pCoexDm->preBtDecPwrLvl = pCoexDm->curBtDecPwrLvl;
 }
 
 VOID
@@ -1225,46 +1254,57 @@ halbtc8723b2ant_CoexTableWithType(
 	IN	u1Byte				type
 	)
 {
+	pCoexSta->nCoexTableType = type;
+	
 	switch(type)
 	{
 		case 0:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0x55555555, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0x55555555, 0xffffff, 0x3);
 			break;
 		case 1:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0x5afa5afa, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0x5afa5afa, 0xffffff, 0x3);
 			break;
 		case 2:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x5a5a5a5a, 0x5a5a5a5a, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x5ada5ada, 0x5ada5ada, 0xffffff, 0x3);
 			break;
 		case 3:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0xaaaaaaaa, 0xaaaaaaaa, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
 			break;
 		case 4:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0xffffffff, 0xffffffff, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0xffffffff, 0xffffffff, 0xffffff, 0x3);
 			break;
 		case 5:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x5fff5fff, 0x5fff5fff, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x5fff5fff, 0x5fff5fff, 0xffffff, 0x3);
 			break;
 		case 6:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55ff55ff, 0x5a5a5a5a, 0xffffff, 0x3);
 			break;
 		case 7:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55ff55ff, 0x5afa5afa, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
 			break;
 		case 8:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x5aea5aea, 0x5aea5aea, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
 			break;
 		case 9:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55ff55ff, 0x5aea5aea, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
 			break;
 		case 10:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55ff55ff, 0x5aff5aff, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
 			break;
 		case 11:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55ff55ff, 0x5a5f5a5f, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
 			break;
 		case 12:
-			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55ff55ff, 0x5f5f5f5f, 0xffff, 0x3);
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 13:
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x5fff5fff, 0xaaaaaaaa, 0xffffff, 0x3);
+			break;
+		case 14:
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x5fff5fff, 0x5ada5ada, 0xffffff, 0x3);
+			break;
+		case 15:
+			halbtc8723b2ant_CoexTable(pBtCoexist, bForceExec, 0x55dd55dd, 0xaaaaaaaa, 0xffffff, 0x3);
 			break;
 		default:
 			break;
@@ -1290,6 +1330,55 @@ halbtc8723b2ant_SetFwIgnoreWlanAct(
 	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x63, 1, H2C_Parameter);
 }
 
+VOID
+halbtc8723b2ant_SetLpsRpwm(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			lpsVal,
+	IN	u1Byte			rpwmVal
+	)
+{
+	u1Byte	lps=lpsVal;
+	u1Byte	rpwm=rpwmVal;
+	
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_LPS_VAL, &lps);
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_RPWM_VAL, &rpwm);
+}
+
+VOID
+halbtc8723b2ant_LpsRpwm(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u1Byte			lpsVal,
+	IN	u1Byte			rpwmVal
+	)
+{
+	BOOLEAN	bForceExecPwrCmd=FALSE;
+	
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s set lps/rpwm=0x%x/0x%x \n", 
+		(bForceExec? "force to":""), lpsVal, rpwmVal));
+	pCoexDm->curLps = lpsVal;
+	pCoexDm->curRpwm = rpwmVal;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], LPS-RxBeaconMode=0x%x , LPS-RPWM=0x%x!!\n", 
+			 pCoexDm->curLps, pCoexDm->curRpwm));
+
+		if( (pCoexDm->preLps == pCoexDm->curLps) &&
+			(pCoexDm->preRpwm == pCoexDm->curRpwm) )
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], LPS-RPWM_Last=0x%x , LPS-RPWM_Now=0x%x!!\n", 
+				 pCoexDm->preRpwm, pCoexDm->curRpwm));
+
+			return;
+		}
+	}
+	halbtc8723b2ant_SetLpsRpwm(pBtCoexist, lpsVal, rpwmVal);
+
+	pCoexDm->preLps = pCoexDm->curLps;
+	pCoexDm->preRpwm = pCoexDm->curRpwm;
+}
+
 VOID
 halbtc8723b2ant_IgnoreWlanAct(
 	IN	PBTC_COEXIST		pBtCoexist,
@@ -1366,7 +1455,7 @@ halbtc8723b2ant_SwMechanism1(
 	}
 	*/
 	
-	halbtc8723b2ant_RfShrink(pBtCoexist, NORMAL_EXEC, bShrinkRxLPF);
+	//halbtc8723b2ant_RfShrink(pBtCoexist, NORMAL_EXEC, bShrinkRxLPF);
 	halbtc8723b2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, bLowPenaltyRA);
 }
 
@@ -1379,9 +1468,9 @@ halbtc8723b2ant_SwMechanism2(
 	IN	u4Byte		dacSwingLvl
 	) 
 {
-	halbtc8723b2ant_AgcTable(pBtCoexist, NORMAL_EXEC, bAGCTableShift);
+	//halbtc8723b2ant_AgcTable(pBtCoexist, NORMAL_EXEC, bAGCTableShift);
 	//halbtc8723b2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, bADCBackOff);
-	halbtc8723b2ant_DacSwing(pBtCoexist, NORMAL_EXEC, bSWDACSwing, dacSwingLvl);
+	//halbtc8723b2ant_DacSwing(pBtCoexist, NORMAL_EXEC, bSWDACSwing, dacSwingLvl);
 }
 
 VOID
@@ -1401,26 +1490,34 @@ halbtc8723b2ant_SetAntPath(
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_EXT_SWITCH, &bPgExtSwitch);
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);	// [31:16]=fw ver, [15:0]=fw sub ver
 
-	if((fwVer<0xc0000) || bPgExtSwitch)
+	if((fwVer>0 && fwVer<0xc0000) || bPgExtSwitch)
 		bUseExtSwitch = TRUE;
 
 	if(bInitHwCfg)
 	{
-		// 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT
-		u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x4c);
-		u4Tmp &=~BIT23;
-		u4Tmp |= BIT24;
-		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
-
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x39, 0x8, 0x1);
 		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x974, 0xff);
 		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x944, 0x3, 0x3);
 		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x930, 0x77);
 		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x1);
 
-		//Force GNT_BT to low
-		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x765, 0x18, 0x0);
+		if(fwVer >= 0x180000)
+		{
+			/* Use H2C to set GNT_BT to High to avoid A2DP click */
+			H2C_Parameter[0] = 1;
+		pBtCoexist->fBtcFillH2c(pBtCoexist, 0x6E, 1, H2C_Parameter);
+		}
+		else
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x18);
+		}
+		
 		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
 
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); //WiFi TRx Mask off
+		//remove due to interrupt is disabled that polling c2h will fail and delay 100ms.
+		//pBtCoexist->fBtcSetBtReg(pBtCoexist, BTC_BT_REG_RF, 0x3c, 0x01); //BT TRx Mask off
+
 		if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
 		{
 			//tell firmware "no antenna inverse"
@@ -1444,11 +1541,32 @@ halbtc8723b2ant_SetAntPath(
 		}
 		pBtCoexist->fBtcFillH2c(pBtCoexist, 0x65, 2, H2C_Parameter);
 	}
-
+	else
+	{
+		if(fwVer >= 0x180000)
+		{
+			/* Use H2C to set GNT_BT to "Control by PTA"*/
+			H2C_Parameter[0] = 0;
+			pBtCoexist->fBtcFillH2c(pBtCoexist, 0x6E, 1, H2C_Parameter);			
+		}
+		else
+		{
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x0);
+		}
+	}
 
 	// ext switch setting
 	if(bUseExtSwitch)
 	{
+		if (bInitHwCfg)
+		{
+			// 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT
+			u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x4c);
+			u4Tmp &=~BIT23;
+			u4Tmp |= BIT24;
+			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
+		}
+		
 		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0); // fixed internal switch S1->WiFi, S0->BT
 		switch(antPosType)
 		{
@@ -1462,8 +1580,16 @@ halbtc8723b2ant_SetAntPath(
 	}
 	else	// internal switch
 	{
-		// fixed ext switch
-		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x92c, 0x3, 0x1);
+		if (bInitHwCfg)
+		{
+			// 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT
+			u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x4c);
+			u4Tmp |= BIT23;
+			u4Tmp &=~BIT24;
+			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
+		}
+		
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x0); //fixed external switch S1->Main, S0->Aux
 		switch(antPosType)
 		{
 			case BTC_ANT_WIFI_AT_MAIN:
@@ -1486,6 +1612,16 @@ halbtc8723b2ant_PsTdma(
 {
 	BOOLEAN			bTurnOnByCnt=FALSE;
 	u1Byte			psTdmaTypeByCnt=0;
+	u1Byte			wifiRssiState1, btRssiState;
+
+	
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+
+	if (!(BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState)) && bTurnOn)
+	{
+		type = type +100;  //for WiFi RSSI low or BT RSSI low
+	}
 
 	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s turn %s PS TDMA, type=%d\n", 
 		(bForceExec? "force to":""), (bTurnOn? "ON":"OFF"), type));
@@ -1509,10 +1645,12 @@ halbtc8723b2ant_PsTdma(
 		{
 			case 1:
 			default:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0xf1, 0x90);
 				break;
 			case 2:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x2d, 0x03, 0xf1, 0x90);
 				break;
 			case 3:
 				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0xf1, 0x90);
@@ -1521,10 +1659,12 @@ halbtc8723b2ant_PsTdma(
 				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x10, 0x03, 0xf1, 0x90);
 				break;
 			case 5:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x3, 0x70, 0x90);				
 				break;
 			case 6:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x2d, 0x3, 0x70, 0x90);
 				break;
 			case 7:
 				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0x70, 0x90);
@@ -1533,28 +1673,36 @@ halbtc8723b2ant_PsTdma(
 				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xa3, 0x10, 0x3, 0x70, 0x90);
 				break;
 			case 9:	
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0xf1, 0x90);
 				break;
 			case 10:	
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x2d, 0x03, 0xf1, 0x90);
 				break;
 			case 11:	
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0xe1, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0xe1, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0xf1, 0x90);
 				break;
 			case 12:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0xe1, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0xe1, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x10, 0x3, 0xf1, 0x90);
 				break;
 			case 13:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x3, 0x70, 0x90);		
 				break;
 			case 14:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x2d, 0x3, 0x70, 0x90);		
 				break;
 			case 15:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0x60, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0x60, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0x70, 0x90);		
 				break;
 			case 16:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0x60, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0x60, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x10, 0x3, 0x70, 0x90);		
 				break;
 			case 17:
 				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xa3, 0x2f, 0x2f, 0x60, 0x90);
@@ -1572,7 +1720,47 @@ halbtc8723b2ant_PsTdma(
 				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x15, 0x03, 0x70, 0x90);
 				break;	
 			case 71:
-				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0xf1, 0x90);
+				break;
+			case 101:
+			case 105:
+			case 171:	
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xd3, 0x3a, 0x03, 0x70, 0x50);
+				break;
+			case 102:
+			case 106:
+			case 110:
+			case 114:	
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xd3, 0x2d, 0x03, 0x70, 0x50);
+				break;	
+			case 103:
+			case 107:
+			case 111:
+			case 115:	
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xd3, 0x21, 0x03, 0x70, 0x50);
+				break;		
+			case 104:
+			case 108:
+			case 112:
+			case 116:	
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xd3, 0x21, 0x03, 0x70, 0x50);
+				break;	
+			case 109:
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0xf1, 0x90);
+				break;
+			case 113:	
+				//halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x3c, 0x03, 0x70, 0x90);
+				break;
+			case 121:	
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x15, 0x03, 0x70, 0x90);
+				break;	
+			case 22:
+			case 122:
+				halbtc8723b2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x35, 0x03, 0x71, 0x11);
 				break;
 		}
 	}
@@ -1598,15 +1786,92 @@ halbtc8723b2ant_PsTdma(
 	pCoexDm->prePsTdma = pCoexDm->curPsTdma;
 }
 
+VOID
+halbtc8723b2ant_PsTdmaCheckForPowerSaveState(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bNewPsState
+	)
+{
+	u1Byte	lpsMode=0x0;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_LPS_MODE, &lpsMode);
+	
+	if(lpsMode)	// already under LPS state
+	{
+		if(bNewPsState)		
+		{
+			// keep state under LPS, do nothing.
+		}
+		else
+		{
+			// will leave LPS state, turn off psTdma first
+			halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+	}
+	else						// NO PS state
+	{
+		if(bNewPsState)
+		{
+			// will enter LPS state, turn off psTdma first
+			halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+		else
+		{
+			// keep state under NO PS state, do nothing.
+		}
+	}
+}
+
+VOID
+halbtc8723b2ant_PowerSaveState(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte				psType,
+	IN	u1Byte				lpsVal,
+	IN	u1Byte				rpwmVal
+	)
+{
+	BOOLEAN		bLowPwrDisable=FALSE;
+	
+	switch(psType)
+	{
+		case BTC_PS_WIFI_NATIVE:
+			// recover to original 32k low power setting
+			bLowPwrDisable = FALSE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_NORMAL_LPS, NULL);
+			pCoexSta->bForceLpsOn = FALSE;
+			break;
+		case BTC_PS_LPS_ON:
+			halbtc8723b2ant_PsTdmaCheckForPowerSaveState(pBtCoexist, TRUE);
+			halbtc8723b2ant_LpsRpwm(pBtCoexist, NORMAL_EXEC, lpsVal, rpwmVal);			
+			// when coex force to enter LPS, do not enter 32k low power.
+			bLowPwrDisable = TRUE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+			// power save must executed before psTdma.			
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_ENTER_LPS, NULL);
+			pCoexSta->bForceLpsOn = TRUE;
+			break;
+		case BTC_PS_LPS_OFF:
+			halbtc8723b2ant_PsTdmaCheckForPowerSaveState(pBtCoexist, FALSE);
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_LEAVE_LPS, NULL);
+			pCoexSta->bForceLpsOn = FALSE;
+			break;
+		default:
+			break;
+	}
+}
+
+
 VOID
 halbtc8723b2ant_CoexAllOff(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
 	// fw all off
+	halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
 	halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
-	halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 
 	// sw all off
 	halbtc8723b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
@@ -1623,10 +1888,12 @@ halbtc8723b2ant_InitCoexDm(
 	)
 {	
 	// force to reset coex mechanism
+	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
 	
+	halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
 	halbtc8723b2ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 1);
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, FORCE_EXEC, 6);
-	halbtc8723b2ant_DecBtPwr(pBtCoexist, FORCE_EXEC, FALSE);
+	halbtc8723b2ant_DecBtPwr(pBtCoexist, FORCE_EXEC, 0);
 
 	halbtc8723b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
 	halbtc8723b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
@@ -1637,38 +1904,88 @@ halbtc8723b2ant_ActionBtInquiry(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
 	BOOLEAN	bWifiConnected=FALSE;
 	BOOLEAN	bLowPwrDisable=TRUE;
+	BOOLEAN		bScan=FALSE, bLink=FALSE, bRoam=FALSE;
+
+
+	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 	
 	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
 
-	if(bWifiConnected)
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+		
+	
+	halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+
+	if(bScan || bLink || bRoam)
 	{
-		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
-		halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi link process + BT Inq/Page!!\n"));
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 15);		
+		halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+	}
+	else if(bWifiConnected)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi connected + BT Inq/Page!!\n"));
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 15);		
+		halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
 	}
 	else
 	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi no-link + BT Inq/Page!!\n"));
 		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
-		halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
 	}	
+	
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, FORCE_EXEC, 6);
-	halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 
 	halbtc8723b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
 	halbtc8723b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
-
+/*
 	pCoexDm->bNeedRecover0x948 = TRUE;
 	pCoexDm->backup0x948 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
 
 	halbtc8723b2ant_SetAntPath(pBtCoexist, BTC_ANT_WIFI_AT_AUX, FALSE, FALSE);
+*/	
 }
+
+
+VOID
+halbtc8723b2ant_ActionWiFiLinkProcess(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u4Byte 	u4Tmp;
+	u1Byte 	u1Tmpa, u1Tmpb;
+	
+	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 15);		
+	halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+
+	halbtc8723b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8723b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+
+	 u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
+        u1Tmpa = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765);
+	 u1Tmpb = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e);
+
+	 BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x76e=0x%x\n",
+	   	      u4Tmp,  u1Tmpa, u1Tmpb));
+}
+
 BOOLEAN
 halbtc8723b2ant_IsCommonAction(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
+	u1Byte			btRssiState=BTC_RSSI_STATE_HIGH;
 	BOOLEAN			bCommon=FALSE, bWifiConnected=FALSE, bWifiBusy=FALSE;
 	BOOLEAN			bBtHsOn=FALSE, bLowPwrDisable=FALSE;
 
@@ -1680,14 +1997,17 @@ halbtc8723b2ant_IsCommonAction(
 	{
 		bLowPwrDisable = FALSE;
 		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+		halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
 
 		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi non-connected idle!!\n"));
 
 		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+		
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
 		halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
 		halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 		
  		halbtc8723b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
 		halbtc8723b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
@@ -1700,14 +2020,17 @@ halbtc8723b2ant_IsCommonAction(
 		{
 			bLowPwrDisable = FALSE;
 			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+			halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
 
 			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi connected + BT non connected-idle!!\n"));
 
 			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 			halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+
+			halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
 			halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);		
 			halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0xb);
-			halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 
 	      	halbtc8723b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
 			halbtc8723b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
@@ -1722,12 +2045,15 @@ halbtc8723b2ant_IsCommonAction(
 			if(bBtHsOn)
 				return FALSE;
 			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi connected + BT connected-idle!!\n"));
+			halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
 
 			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 			halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+
+			halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
 			halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
 			halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0xb);
-			halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+			halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 
 			halbtc8723b2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
 			halbtc8723b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
@@ -1746,22 +2072,31 @@ halbtc8723b2ant_IsCommonAction(
 			}
 			else
 			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi Connected-Idle + BT Busy!!\n"));
+				bCommon = FALSE;
+			
+				/*
 				if(bBtHsOn)
 					return FALSE;
 				
 				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi Connected-Idle + BT Busy!!\n"));
+				btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
+				halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
 
 				pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 				halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+				
+				halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);							
 				halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 21);
 				halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0xb);
-				if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-					halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+				if(BTC_RSSI_HIGH(btRssiState))
+					halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 				else	
-					halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+					halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 				halbtc8723b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
 				halbtc8723b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
 				bCommon = TRUE;
+				*/
 			}
 		}	
 	}
@@ -2685,19 +3020,22 @@ halbtc8723b2ant_ActionSco(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	u1Byte	wifiRssiState;
+	u1Byte	wifiRssiState, btRssiState;
 	u4Byte	wifiBw;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+	
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 4);
 
-	if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 	else	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 	
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
 
@@ -2710,6 +3048,7 @@ halbtc8723b2ant_ActionSco(
 		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 8);
 	}
 
+	halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
 	halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0); //for voice quality
 
 	// sw mechanism
@@ -2753,16 +3092,18 @@ halbtc8723b2ant_ActionHid(
 	u4Byte	wifiBw;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
-	btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0);
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+	
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
 
-	if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 	else	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
 
@@ -2775,6 +3116,8 @@ halbtc8723b2ant_ActionHid(
 		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 9);
 	}
 
+	halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
+	
 	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
 		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
 	{
@@ -2827,19 +3170,25 @@ halbtc8723b2ant_ActionA2dp(
 	u1Byte		apNum=0;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
-	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, 40, 0);
-	btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0);
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &apNum);
 
 	// define the office environment
-	if(apNum >= 10 && BTC_RSSI_HIGH(wifiRssiState1))
+	if( (apNum >= 10) && BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
 	{
 		//DbgPrint(" AP#>10(%d)\n", apNum);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);			
+		
 		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);	
+		halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
 		halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);			
+					
 		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
 		halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
 
 		// sw mechanism
@@ -2855,18 +3204,31 @@ halbtc8723b2ant_ActionA2dp(
 			halbtc8723b2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,TRUE,0x18);		
 		}
 		return;
+		
 	}
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
 
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
 
-	if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 	else	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 
+		
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
 	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 13);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
+	
 
 	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
 		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
@@ -2915,21 +3277,34 @@ halbtc8723b2ant_ActionA2dpPanHs(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	u1Byte		wifiRssiState;
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
 	u4Byte		wifiBw;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+	
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
 
-	if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 	else	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
 	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 13);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
 
 	halbtc8723b2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 2);
 
@@ -2970,22 +3345,34 @@ halbtc8723b2ant_ActionPanEdr(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	u1Byte		wifiRssiState, btRssiState;
+	u1Byte		wifiRssiState,wifiRssiState1, btRssiState;
 	u4Byte		wifiBw;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
-	btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0);
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
 
-	if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 	else	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
 	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 10);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 13);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
 
 	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
 		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
@@ -3036,27 +3423,27 @@ halbtc8723b2ant_ActionPanHs(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	u1Byte		wifiRssiState;
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
 	u4Byte		wifiBw;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
 
-	if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
-		(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
-	{
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
-	}
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 	else
-	{
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
-	}
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 	
 	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
 	
+	halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
 	halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
@@ -3096,20 +3483,28 @@ halbtc8723b2ant_ActionPanEdrA2dp(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	u1Byte		wifiRssiState, btRssiState;
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
 	u4Byte		wifiBw;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
-	btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0);
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
 
-	if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 	else	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))		
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	else
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
 
@@ -3117,6 +3512,7 @@ halbtc8723b2ant_ActionPanEdrA2dp(
 		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
 	{
 		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 12);
+		
 		if(BTC_WIFI_BW_HT40 == wifiBw)
 			halbtc8723b2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
 		else
@@ -3124,7 +3520,7 @@ halbtc8723b2ant_ActionPanEdrA2dp(
 	}
 	else
 	{
-		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 13);
 		halbtc8723b2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
 	}
 	
@@ -3164,17 +3560,31 @@ halbtc8723b2ant_ActionPanEdrHid(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	u1Byte		wifiRssiState, btRssiState;
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
 	u4Byte		wifiBw;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
-	btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0);
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
 
-	if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 	else	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))	
+	{
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 14);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+	}
 
 	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
 		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
@@ -3182,13 +3592,13 @@ halbtc8723b2ant_ActionPanEdrHid(
 		if(BTC_WIFI_BW_HT40 == wifiBw)
 		{
 			halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 3);
-			halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 11);
+			//halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 11);
 			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x780);
 		}
 		else
 		{
 			halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
-			halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+			//halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
 			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 		}
 		halbtc8723b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 2);
@@ -3196,7 +3606,7 @@ halbtc8723b2ant_ActionPanEdrHid(
 	else
 	{
 		halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
-		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 11);
+		//halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 14);
 		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 		halbtc8723b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
 	}
@@ -3238,24 +3648,36 @@ halbtc8723b2ant_ActionHidA2dpPanEdr(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	u1Byte		wifiRssiState, btRssiState;
+	u1Byte		wifiRssiState,wifiRssiState1,  btRssiState;
 	u4Byte		wifiBw;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
-	btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0);
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8723b2ant_BtRssiState(2, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 0);
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 0x8);
+
 	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
 
-	if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	if(BTC_RSSI_HIGH(btRssiState))
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
 	else	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 14);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
 
-	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
 
 	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
 		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
@@ -3306,33 +3728,67 @@ halbtc8723b2ant_ActionHidA2dp(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	u1Byte		wifiRssiState, btRssiState;
+	u1Byte		wifiRssiState, wifiRssiState1, btRssiState;
 	u4Byte		wifiBw;
+	u1Byte		apNum=0;
 
 	wifiRssiState = halbtc8723b2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
-	btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0);
+	//btRssiState = halbtc8723b2ant_BtRssiState(2, 29, 0);
+	wifiRssiState1 = halbtc8723b2ant_WifiRssiState(pBtCoexist, 1, 2, BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES, 0);	
+	btRssiState = halbtc8723b2ant_BtRssiState(3, BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES, 37);
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
 
-	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+	halbtc8723b2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, TRUE, 0x5);
 
-	if(halbtc8723b2ant_NeedToDecBtPwr(pBtCoexist))
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
-	else	
-		halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	if(BTC_WIFI_BW_LEGACY == wifiBw)
+	{
+		if(BTC_RSSI_HIGH(btRssiState))
+			halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+		else if(BTC_RSSI_MEDIUM(btRssiState))
+			halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+	else	
+			halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+	}
+	else	
+	{	// only 802.11N mode we have to dec bt power to 4 degree
+		if(BTC_RSSI_HIGH(btRssiState))
+		{
+			pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &apNum);
+			// need to check ap Number of Not
+			if(apNum < 10)
+				halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 4);
+			else
+				halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+		}
+		else if(BTC_RSSI_MEDIUM(btRssiState))
+			halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 2);
+		else	
+			halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+	}
 
+	if (BTC_RSSI_HIGH(wifiRssiState1) && BTC_RSSI_HIGH(btRssiState))
+	{
 	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	}
+	else
+	{
+		halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 14);
+		halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);		
+	}
 
 	if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
 		(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
 	{
-		halbtc8723b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 2);
+		halbtc8723b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 3);
 	}
 	else
 	{
-		halbtc8723b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+		halbtc8723b2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
 	}
 	
 	// sw mechanism
@@ -3366,6 +3822,43 @@ halbtc8723b2ant_ActionHidA2dp(
 	}
 }
 
+VOID
+halbtc8723b2ant_ActionBtWhckTest(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	// sw all off
+	halbtc8723b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8723b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+	halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	
+	halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+}
+
+VOID
+halbtc8723b2ant_ActionWifiMultiPort(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{		
+	halbtc8723b2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+	halbtc8723b2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, 0);
+
+	// sw all off
+	halbtc8723b2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8723b2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+	// hw all off
+	//pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0);
+	halbtc8723b2ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+
+	halbtc8723b2ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);		
+	halbtc8723b2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+}
+
 VOID
 halbtc8723b2ant_RunCoexistMechanism(
 	IN	PBTC_COEXIST		pBtCoexist
@@ -3374,6 +3867,11 @@ halbtc8723b2ant_RunCoexistMechanism(
 	BOOLEAN				bWifiUnder5G=FALSE, bBtHsOn=FALSE;
 	u1Byte				btInfoOriginal=0, btRetryCnt=0;
 	u1Byte				algorithm=0;
+	u4Byte				numOfWifiLink=0;
+	u4Byte				wifiLinkStatus=0;
+	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	BOOLEAN				bMiracastPlusBt=FALSE;
+	BOOLEAN				bScan=FALSE, bLink=FALSE, bRoam=FALSE;
 
 	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], RunCoexistMechanism()===>\n"));
 
@@ -3389,6 +3887,13 @@ halbtc8723b2ant_RunCoexistMechanism(
 		return;
 	}
 
+	if(pCoexSta->bBtWhckTest)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], BT is under WHCK TEST!!!\n"));
+		halbtc8723b2ant_ActionBtWhckTest(pBtCoexist);
+		return;
+	}
+
 	algorithm = halbtc8723b2ant_ActionAlgorithm(pBtCoexist);
 	if(pCoexSta->bC2hBtInquiryPage && (BT_8723B_2ANT_COEX_ALGO_PANHS!=algorithm))
 	{
@@ -3398,11 +3903,53 @@ halbtc8723b2ant_RunCoexistMechanism(
 	}
 	else
 	{
+		/*
 		if(pCoexDm->bNeedRecover0x948)
 		{
 			pCoexDm->bNeedRecover0x948 = FALSE;
 			pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, pCoexDm->backup0x948);
 		}
+		*/
+	}
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+
+	if(bScan || bLink || bRoam)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], WiFi is under Link Process !!\n"));
+		halbtc8723b2ant_ActionWiFiLinkProcess(pBtCoexist);
+		return;
+	}
+
+	//for P2P
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
+	numOfWifiLink = wifiLinkStatus>>16;
+	
+	if((numOfWifiLink>=2) || (wifiLinkStatus&WIFI_P2P_GO_CONNECTED))
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("############# [BTCoex],  Multi-Port numOfWifiLink = %d, wifiLinkStatus = 0x%x\n", numOfWifiLink,wifiLinkStatus) );
+
+		if(pBtLinkInfo->bBtLinkExist)
+		{
+			bMiracastPlusBt = TRUE;
+		}
+		else
+		{
+			bMiracastPlusBt = FALSE;
+		}
+		
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_MIRACAST_PLUS_BT, &bMiracastPlusBt);
+		halbtc8723b2ant_ActionWifiMultiPort(pBtCoexist);
+		
+		return;
+	}
+	else
+	{
+		bMiracastPlusBt = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_MIRACAST_PLUS_BT, &bMiracastPlusBt);
 	}
 
 	pCoexDm->curAlgorithm = algorithm;
@@ -3477,29 +4024,37 @@ halbtc8723b2ant_WifiOffHwCfg(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	PADAPTER padapter=pBtCoexist->Adapter;
+	BOOLEAN	bIsInMpMode = FALSE;
+	u1Byte H2C_Parameter[2] ={0};
+	u4Byte fwVer=0;
+
 	// set wlan_act to low
 	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4);
 
 	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x780); //WiFi goto standby while GNT_BT 0-->1
-        
-	//Force GNT_BT to High
-	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x765, 0x18, 0x3);
-	if(padapter->registrypriv.mp_mode ==0)	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);
+	if(fwVer >= 0x180000)
+	{
+	/* Use H2C to set GNT_BT to HIGH */
+	H2C_Parameter[0] = 1;
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x6E, 1, H2C_Parameter);
+	}
+	else
+	{
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x765, 0x18);
+	}
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_IS_IN_MP_MODE, &bIsInMpMode);
+	if(!bIsInMpMode)
 		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x0); //BT select s0/s1 is controlled by BT
 	else
 		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x67, 0x20, 0x1); //BT select s0/s1 is controlled by WiFi
 }
 
-//============================================================
-// work around function start with wa_halbtc8723b2ant_
-//============================================================
-//============================================================
-// extern function start with EXhalbtc8723b2ant_
-//============================================================
 VOID
-EXhalbtc8723b2ant_InitHwConfig(
-	IN	PBTC_COEXIST		pBtCoexist
+halbtc8723b2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bBackUp
 	)
 {
 	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
@@ -3511,9 +4066,6 @@ EXhalbtc8723b2ant_InitHwConfig(
 
 	BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], 2Ant Init HW Config!!\n"));
 
-	//pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); //WiFi goto standby while GNT_BT 0-->1
-	//pBtCoexist->fBtcSetBtReg(pBtCoexist, 0, 0x3c, 0x1); //BT goto standby while GNT_BT 1-->0
-
 	// backup rf 0x1e value
 	pCoexDm->btRf0x1eBackup = 
 		pBtCoexist->fBtcGetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff);	
@@ -3526,16 +4078,111 @@ EXhalbtc8723b2ant_InitHwConfig(
 
 	//Antenna config	
 	halbtc8723b2ant_SetAntPath(pBtCoexist, BTC_ANT_WIFI_AT_MAIN, TRUE, FALSE);
+	pCoexSta->disVerInfoCnt = 0;
 
 	// PTA parameter
 	halbtc8723b2ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 0);
 	
 	// Enable counter statistics
-	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc); //0x76e[3] =1, WLAN_Act control by PTA
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x4); //0x76e[3] =1, WLAN_Act control by PTA
 	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x778, 0x3);
 	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x40, 0x20, 0x1);
+}
 
-	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1, 0xfffff, 0x0); //WiFi goto standby while GNT_BT 0-->1
+//============================================================
+// work around function start with wa_halbtc8723b2ant_
+//============================================================
+//============================================================
+// extern function start with EXhalbtc8723b2ant_
+//============================================================
+VOID
+EXhalbtc8723b2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO 	pBoardInfo=&pBtCoexist->boardInfo;
+	u2Byte u2Tmp=0x0;
+
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x67, 0x20);
+
+	// enable BB, REG_SYS_FUNC_EN such that we can write 0x948 correctly.
+	u2Tmp = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0x2);
+	pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x2, u2Tmp|BIT0|BIT1);
+
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x948, 0x0);
+
+	if(pBtCoexist->chipInterface == BTC_INTF_USB)
+	{
+		// fixed at S0 for USB interface
+		pBoardInfo->btdmAntPos = BTC_ANTENNA_AT_AUX_PORT;
+	}
+	else
+	{
+		// for PCIE and SDIO interface, we check efuse 0xc3[6]
+		if(pBoardInfo->singleAntPath == 0)
+		{
+			// set to S1
+			pBoardInfo->btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;
+		}
+		else if(pBoardInfo->singleAntPath == 1)
+		{
+			// set to S0
+			pBoardInfo->btdmAntPos = BTC_ANTENNA_AT_AUX_PORT;
+		}
+	}
+}
+
+VOID
+EXhalbtc8723b2ant_PreLoadFirmware(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO 	pBoardInfo=&pBtCoexist->boardInfo;
+	u1Byte u1Tmp=0x4; /* Set BIT2 by default since it's 2ant case */
+
+	// 
+	// S0 or S1 setting and Local register setting(By the setting fw can get ant number, S0/S1, ... info)
+	// Local setting bit define
+	//	BIT0: "0" for no antenna inverse; "1" for antenna inverse 
+	//	BIT1: "0" for internal switch; "1" for external switch
+	//	BIT2: "0" for one antenna; "1" for two antenna
+	// NOTE: here default all internal switch and 1-antenna ==> BIT1=0 and BIT2=0
+	if(pBtCoexist->chipInterface == BTC_INTF_USB)
+	{
+		// fixed at S0 for USB interface
+	 	u1Tmp |= 0x1;	// antenna inverse
+		pBtCoexist->fBtcWriteLocalReg1Byte(pBtCoexist, 0xfe08, u1Tmp);
+	}
+	else
+	{
+		// for PCIE and SDIO interface, we check efuse 0xc3[6]
+		if(pBoardInfo->singleAntPath == 0)
+		{
+		}
+		else if(pBoardInfo->singleAntPath == 1)
+		{
+			// set to S0
+			u1Tmp |= 0x1;	// antenna inverse
+		}
+
+		if(pBtCoexist->chipInterface == BTC_INTF_PCI)
+		{	
+			pBtCoexist->fBtcWriteLocalReg1Byte(pBtCoexist, 0x384, u1Tmp);
+		}
+		else if(pBtCoexist->chipInterface == BTC_INTF_SDIO)
+		{
+			pBtCoexist->fBtcWriteLocalReg1Byte(pBtCoexist, 0x60, u1Tmp);
+		}			
+	}
+}
+
+VOID
+EXhalbtc8723b2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
+{
+	halbtc8723b2ant_InitHwConfig(pBtCoexist, TRUE);
 }
 
 VOID
@@ -3559,13 +4206,8 @@ EXhalbtc8723b2ant_DisplayCoexInfo(
 	pu1Byte				cliBuf=pBtCoexist->cliBuf;
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir, faOfdm, faCck;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
+	u4Byte				faOfdm, faCck;
 	u4Byte				fwVer=0, btPatchVer=0;
-	u1Byte				apNum=0;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
 	CL_PRINTF(cliBuf);
@@ -3578,13 +4220,6 @@ EXhalbtc8723b2ant_DisplayCoexInfo(
 		CL_PRINTF(cliBuf);
 	}
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);
@@ -3599,46 +4234,23 @@ EXhalbtc8723b2ant_DisplayCoexInfo(
 		GLCoexVerDate8723b2Ant, GLCoexVer8723b2Ant, fwVer, btPatchVer, btPatchVer);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(HsMode)", \
-		wifiDot11Chnl, wifiHsChnl, bBtHsOn);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &apNum);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d", "Wifi rssi/ HS rssi/ AP#", \
-		wifiRssi, btHsRssi, apNum);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %ddBm/ %d] ", "BT [status/ rssi/ retryCnt]", \
 		((pBtCoexist->btInfo.bBtDisabled)? ("disabled"):	((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8723B_2ANT_BT_STATUS_NON_CONNECTED_IDLE == pCoexDm->btStatus)? "non-connected idle":
 		(  (BT_8723B_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy")))),
-		pCoexSta->btRssi, pCoexSta->btRetryCnt);
+		pCoexSta->btRssi-100, pCoexSta->btRetryCnt);
 	CL_PRINTF(cliBuf);
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP", \
@@ -3664,12 +4276,6 @@ EXhalbtc8723b2ant_DisplayCoexInfo(
 		}
 	}
 
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/%s", "PS state, IPS/LPS", \
-		((pCoexSta->bUnderIps? "IPS ON":"IPS OFF")),
-		((pCoexSta->bUnderLps? "LPS ON":"LPS OFF")));
-	CL_PRINTF(cliBuf);
-	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_FW_PWR_MODE_CMD);
-
 	// Sw mechanism	
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
 	CL_PRINTF(cliBuf);
@@ -3691,8 +4297,12 @@ EXhalbtc8723b2ant_DisplayCoexInfo(
 		pCoexDm->psTdmaPara[4], psTdmaCase, pCoexDm->bAutoTdmaAdjust);
 	CL_PRINTF(cliBuf);
 
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "Coex Table Type", \
+			pCoexSta->nCoexTableType);
+		CL_PRINTF(cliBuf);
+
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "DecBtPwr/ IgnWlanAct", \
-		pCoexDm->bCurDecBtPwr, pCoexDm->bCurIgnoreWlanAct);
+		pCoexDm->curBtDecPwrLvl, pCoexDm->bCurIgnoreWlanAct);
 	CL_PRINTF(cliBuf);
 
 	// Hw setting		
@@ -3761,6 +4371,14 @@ EXhalbtc8723b2ant_DisplayCoexInfo(
 		u4Tmp[0]&0xffff, faOfdm, faCck);
 	CL_PRINTF(cliBuf);
 
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d", "CRC_OK CCK/11g/11n/11n-Agg", \
+		pCoexSta->nCRCOK_CCK, pCoexSta->nCRCOK_11g, pCoexSta->nCRCOK_11n, pCoexSta->nCRCOK_11nAgg);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d", "CRC_Err CCK/11g/11n/11n-Agg", \
+		pCoexSta->nCRCErr_CCK, pCoexSta->nCRCErr_11g, pCoexSta->nCRCErr_11n, pCoexSta->nCRCErr_11nAgg);
+	CL_PRINTF(cliBuf);	
+
 	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c0);
 	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c4);
 	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c8);
@@ -3776,7 +4394,7 @@ EXhalbtc8723b2ant_DisplayCoexInfo(
 		pCoexSta->lowPriorityRx, pCoexSta->lowPriorityTx);
 	CL_PRINTF(cliBuf);
 #if(BT_AUTO_REPORT_ONLY_8723B_2ANT == 1)
-	halbtc8723b2ant_MonitorBtCtr(pBtCoexist);
+	//halbtc8723b2ant_MonitorBtCtr(pBtCoexist);
 #endif
 	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
 }
@@ -3800,7 +4418,7 @@ EXhalbtc8723b2ant_IpsNotify(
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], IPS LEAVE notify\n"));
 		pCoexSta->bUnderIps = FALSE;
-		EXhalbtc8723b2ant_InitHwConfig(pBtCoexist);
+		halbtc8723b2ant_InitHwConfig(pBtCoexist, FALSE);
 		halbtc8723b2ant_InitCoexDm(pBtCoexist);
 		halbtc8723b2ant_QueryBtInfo(pBtCoexist);
 	}
@@ -3830,6 +4448,15 @@ EXhalbtc8723b2ant_ScanNotify(
 	IN	u1Byte			type
 	)
 {
+	u4Byte 	u4Tmp;
+	u1Byte 	u1Tmpa, u1Tmpb;	
+	
+
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x948);
+	u1Tmpa = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x765);
+	u1Tmpb = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e);
+	
 	if(BTC_SCAN_START == type)
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN START notify\n"));
@@ -3838,6 +4465,9 @@ EXhalbtc8723b2ant_ScanNotify(
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN FINISH notify\n"));
 	}
+
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("############# [BTCoex], 0x948=0x%x, 0x765=0x%x, 0x76e=0x%x\n",
+		u4Tmp,  u1Tmpa, u1Tmpb));
 }
 
 VOID
@@ -3865,6 +4495,7 @@ EXhalbtc8723b2ant_MediaStatusNotify(
 	u1Byte			H2C_Parameter[3] ={0};
 	u4Byte			wifiBw;
 	u1Byte			wifiCentralChnl;
+	u1Byte			apNum=0;
 
 	if(BTC_MEDIA_CONNECT == type)
 	{
@@ -3886,7 +4517,13 @@ EXhalbtc8723b2ant_MediaStatusNotify(
 		if(BTC_WIFI_BW_HT40 == wifiBw)
 			H2C_Parameter[2] = 0x30;
 		else
-			H2C_Parameter[2] = 0x20;
+		{
+			pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &apNum);
+			if(apNum < 10)
+				H2C_Parameter[2] = 0x30;
+			else
+				H2C_Parameter[2] = 0x20;
+	}
 	}
 	
 	pCoexDm->wifiChnlInfo[0] = H2C_Parameter[0];
@@ -3955,6 +4592,12 @@ EXhalbtc8723b2ant_BtInfoNotify(
 		return;
 	}
 
+	// if 0xff, it means BT is under WHCK test
+	if (btInfo == 0xff)
+		pCoexSta->bBtWhckTest = TRUE;
+	else
+		pCoexSta->bBtWhckTest = FALSE;
+
 	if(BT_INFO_SRC_8723B_2ANT_WIFI_FW != rspSource)
 	{
 		pCoexSta->btRetryCnt =	// [3:0]
@@ -3966,11 +4609,13 @@ EXhalbtc8723b2ant_BtInfoNotify(
 		pCoexSta->btInfoExt = 
 			pCoexSta->btInfoC2h[rspSource][4];
 
-		if (pCoexSta->btInfoC2h[rspSource][2] & 0x40)
+		pCoexSta->bBtTxRxMask = (pCoexSta->btInfoC2h[rspSource][2]&0x40);
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TX_RX_MASK, &pCoexSta->bBtTxRxMask);
+		if (pCoexSta->bBtTxRxMask)
 		{
-			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x01 => Need to switch GNT_BT */				
-			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Switch GNT_BT since BT RF REG 0x3C != 0x01\n"));
-			pBtCoexist->fBtcSetBtReg(pBtCoexist, 0, 0x3c, 0x01);
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x01 => Need to switch BT TRx Mask */				
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x01\n"));
+			pBtCoexist->fBtcSetBtReg(pBtCoexist, BTC_BT_REG_RF, 0x3c, 0x01);
 		}
 
 		// Here we need to resend some wifi info to BT
@@ -4104,27 +4749,49 @@ EXhalbtc8723b2ant_HaltNotify(
 	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Halt notify\n"));
 
 	halbtc8723b2ant_WifiOffHwCfg(pBtCoexist);
-	pBtCoexist->fBtcSetBtReg(pBtCoexist, 0, 0x3c, 0x15); //BT goto standby while GNT_BT 1-->0
+	//remove due to interrupt is disabled that polling c2h will fail and delay 100ms.
+	//pBtCoexist->fBtcSetBtReg(pBtCoexist, BTC_BT_REG_RF, 0x3c, 0x15); //BT goto standby while GNT_BT 1-->0
 	halbtc8723b2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
 	
 	EXhalbtc8723b2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
 }
 
+VOID
+EXhalbtc8723b2ant_PnpNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				pnpState
+	)
+{
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify\n"));
+
+	if(BTC_WIFI_PNP_SLEEP == pnpState)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to SLEEP\n"));
+	}
+	else if(BTC_WIFI_PNP_WAKE_UP == pnpState)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to WAKE UP\n"));
+		halbtc8723b2ant_InitHwConfig(pBtCoexist, FALSE);
+		halbtc8723b2ant_InitCoexDm(pBtCoexist);
+		halbtc8723b2ant_QueryBtInfo(pBtCoexist);
+	}
+}
+
 VOID
 EXhalbtc8723b2ant_Periodical(
 	IN	PBTC_COEXIST			pBtCoexist
 	)
 {
-	static u1Byte		disVerInfoCnt=0;
+	//static u1Byte		disVerInfoCnt=0;
 	u4Byte				fwVer=0, btPatchVer=0;
 	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
 	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
 
 	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], ==========================Periodical===========================\n"));
 
-	if(disVerInfoCnt <= 5)
+	if(pCoexSta->disVerInfoCnt <= 5)
 	{
-		disVerInfoCnt += 1;
+		pCoexSta->disVerInfoCnt += 1;
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], ****************************************************************\n"));
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], Ant PG Num/ Ant Mech/ Ant Pos = %d/ %d/ %d\n", \
 			pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum, pBoardInfo->btdmAntPos));
@@ -4135,13 +4802,22 @@ EXhalbtc8723b2ant_Periodical(
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], CoexVer/ FwVer/ PatchVer = %d_%x/ 0x%x/ 0x%x(%d)\n", \
 			GLCoexVerDate8723b2Ant, GLCoexVer8723b2Ant, fwVer, btPatchVer, btPatchVer));
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], ****************************************************************\n"));
+
+		if (pCoexSta->disVerInfoCnt == 3)
+		{
+			//Antenna config to set 0x765 = 0x0 (GNT_BT control by PTA) after initial 
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], Set GNT_BT control by PTA\n"));
+			halbtc8723b2ant_SetAntPath(pBtCoexist, BTC_ANT_WIFI_AT_MAIN, FALSE, FALSE);
+		}
 	}
 
 #if(BT_AUTO_REPORT_ONLY_8723B_2ANT == 0)
 	halbtc8723b2ant_QueryBtInfo(pBtCoexist);
-	halbtc8723b2ant_MonitorBtCtr(pBtCoexist);
 	halbtc8723b2ant_MonitorBtEnableDisable(pBtCoexist);
 #else
+	halbtc8723b2ant_MonitorBtCtr(pBtCoexist);
+	halbtc8723b2ant_MonitorWiFiCtr(pBtCoexist);
+	
 	if( halbtc8723b2ant_IsWifiStatusChanged(pBtCoexist) ||
 		pCoexDm->bAutoTdmaAdjust)
 	{
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.h
index b894db023e84..2c049f9fcebf 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8723b2Ant.h
@@ -15,6 +15,10 @@
 
 #define		BTC_RSSI_COEX_THRESH_TOL_8723B_2ANT		2
 
+
+#define	BT_8723B_2ANT_WIFI_RSSI_COEXSWITCH_THRES				42  //WiFi RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation
+#define	BT_8723B_2ANT_BT_RSSI_COEXSWITCH_THRES				46 //BT RSSI Threshold for 2-Ant TDMA/1-Ant PS-TDMA translation
+
 typedef enum _BT_INFO_SRC_8723B_2ANT{
 	BT_INFO_SRC_8723B_2ANT_WIFI_FW			= 0x0,
 	BT_INFO_SRC_8723B_2ANT_BT_RSP				= 0x1,
@@ -49,8 +53,8 @@ typedef enum _BT_8723B_2ANT_COEX_ALGO{
 
 typedef struct _COEX_DM_8723B_2ANT{
 	// fw mechanism
-	BOOLEAN		bPreDecBtPwr;
-	BOOLEAN		bCurDecBtPwr;
+	u1Byte		preBtDecPwrLvl;
+	u1Byte		curBtDecPwrLvl;
 	u1Byte		preFwDacSwingLvl;
 	u1Byte		curFwDacSwingLvl;
 	BOOLEAN		bCurIgnoreWlanAct;
@@ -98,6 +102,11 @@ typedef struct _COEX_DM_8723B_2ANT{
 
 	BOOLEAN		bNeedRecover0x948;
 	u4Byte		backup0x948;
+
+	u1Byte		preLps;
+	u1Byte		curLps;
+	u1Byte		preRpwm;
+	u1Byte		curRpwm;
 } COEX_DM_8723B_2ANT, *PCOEX_DM_8723B_2ANT;
 
 typedef struct _COEX_STA_8723B_2ANT{	
@@ -114,24 +123,50 @@ typedef struct _COEX_STA_8723B_2ANT{
 	u4Byte					lowPriorityTx;
 	u4Byte					lowPriorityRx;
 	u1Byte					btRssi;
+	BOOLEAN				bBtTxRxMask;
 	u1Byte					preBtRssiState;
 	u1Byte					preWifiRssiState[4];
 	BOOLEAN					bC2hBtInfoReqSent;
 	u1Byte					btInfoC2h[BT_INFO_SRC_8723B_2ANT_MAX][10];
 	u4Byte					btInfoC2hCnt[BT_INFO_SRC_8723B_2ANT_MAX];
+	BOOLEAN 				bBtWhckTest;
 	BOOLEAN					bC2hBtInquiryPage;
 	u1Byte					btRetryCnt;
 	u1Byte					btInfoExt;
+
+	u4Byte					nCRCOK_CCK;
+	u4Byte					nCRCOK_11g;
+	u4Byte					nCRCOK_11n;
+	u4Byte					nCRCOK_11nAgg;
+	
+	u4Byte					nCRCErr_CCK;
+	u4Byte					nCRCErr_11g;
+	u4Byte					nCRCErr_11n;
+	u4Byte					nCRCErr_11nAgg;
+
+	u1Byte					nCoexTableType;
+	BOOLEAN					bForceLpsOn;
+
+	u1Byte					disVerInfoCnt;
 }COEX_STA_8723B_2ANT, *PCOEX_STA_8723B_2ANT;
 
 //===========================================
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8723b2ant_InitHwConfig(
+EXhalbtc8723b2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8723b2ant_PreLoadFirmware(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8723b2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8723b2ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
@@ -176,6 +211,11 @@ EXhalbtc8723b2ant_HaltNotify(
 	IN	PBTC_COEXIST			pBtCoexist
 	);
 VOID
+EXhalbtc8723b2ant_PnpNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				pnpState
+	);
+VOID
 EXhalbtc8723b2ant_Periodical(
 	IN	PBTC_COEXIST			pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.c
index 9f4e49ad6f8b..d081053b8c5c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.c
@@ -2092,9 +2092,17 @@ halbtc8812a1ant_InitCoexDm(
 // extern function start with EXhalbtc8812a1ant_
 //============================================================
 VOID
-EXhalbtc8812a1ant_InitHwConfig(
+EXhalbtc8812a1ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
+{
+}
+
+VOID
+EXhalbtc8812a1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
 {
 	u4Byte	u4Tmp=0;
 	u2Byte	u2Tmp=0;
@@ -2160,11 +2168,6 @@ EXhalbtc8812a1ant_DisplayCoexInfo(
 	pu1Byte				cliBuf=pBtCoexist->cliBuf;
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
 	u4Byte				fwVer=0, btPatchVer=0;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
@@ -2185,13 +2188,6 @@ EXhalbtc8812a1ant_DisplayCoexInfo(
 		CL_PRINTF(cliBuf);
 	}
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);	
@@ -2206,40 +2202,19 @@ EXhalbtc8812a1ant_DisplayCoexInfo(
 		GLCoexVerDate8812a1Ant, GLCoexVer8812a1Ant, fwVer, btPatchVer, btPatchVer);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(HsMode)", \
-		wifiDot11Chnl, wifiHsChnl, bBtHsOn);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
-	CL_PRINTF(cliBuf);
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
 		((pBtCoexist->btInfo.bBtDisabled)? ("disabled"):	((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8812A_1ANT_BT_STATUS_NON_CONNECTED_IDLE == pCoexDm->btStatus)? "non-connected idle":
 		(  (BT_8812A_1ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy")))),
@@ -2268,13 +2243,6 @@ EXhalbtc8812a1ant_DisplayCoexInfo(
 			CL_PRINTF(cliBuf);
 		}
 	}
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/%s, (0x%x/0x%x)", "PS state, IPS/LPS, (lps/rpwm)", \
-		((pCoexSta->bUnderIps? "IPS ON":"IPS OFF")),
-		((pCoexSta->bUnderLps? "LPS ON":"LPS OFF")), 
-		pBtCoexist->btInfo.lpsVal, 
-		pBtCoexist->btInfo.rpwmVal);
-	CL_PRINTF(cliBuf);
-	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_FW_PWR_MODE_CMD);
 
 	if(!pBtCoexist->bManualControl)
 	{
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.h
index 652e723ebea1..4f2df7a6033d 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a1Ant.h
@@ -132,10 +132,15 @@ typedef struct _COEX_STA_8812A_1ANT{
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8812a1ant_InitHwConfig(
+EXhalbtc8812a1ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8812a1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8812a1ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.c
index c7add94066cc..82029305e9b1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.c
@@ -4126,9 +4126,17 @@ halbtc8812a2ant_InitHwConfig(
 // extern function start with EXhalbtc8812a2ant_
 //============================================================
 VOID
-EXhalbtc8812a2ant_InitHwConfig(
+EXhalbtc8812a2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
+{
+}	
+
+VOID
+EXhalbtc8812a2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
 {
 	halbtc8812a2ant_InitHwConfig(pBtCoexist, TRUE);
 }
@@ -4155,11 +4163,6 @@ EXhalbtc8812a2ant_DisplayCoexInfo(
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u2Byte				u2Tmp[4];
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
 	u4Byte				fwVer=0, btPatchVer=0;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
@@ -4173,13 +4176,6 @@ EXhalbtc8812a2ant_DisplayCoexInfo(
 		CL_PRINTF(cliBuf);
 	}
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);	
@@ -4194,41 +4190,18 @@ EXhalbtc8812a2ant_DisplayCoexInfo(
 		GLCoexVerDate8812a2Ant, GLCoexVer8812a2Ant, fwVer, btPatchVer, btPatchVer);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsMode(HsChnl)", \
-		wifiDot11Chnl, bBtHsOn, wifiHsChnl);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
 		((pBtCoexist->btInfo.bBtDisabled)? ("disabled"):	((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8812A_2ANT_BT_STATUS_NON_CONNECTED_IDLE == pCoexDm->btStatus)? "non-connected idle":
 		(  (BT_8812A_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy")))),
@@ -4258,15 +4231,6 @@ EXhalbtc8812a2ant_DisplayCoexInfo(
 		}
 	}
 
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/%s, (0x%x/0x%x)", "PS state, IPS/LPS, (lps/rpwm)", \
-		((pCoexSta->bUnderIps? "IPS ON":"IPS OFF")),
-		((pCoexSta->bUnderLps? "LPS ON":"LPS OFF")), 
-		pBtCoexist->btInfo.lpsVal, 
-		pBtCoexist->btInfo.rpwmVal);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_FW_PWR_MODE_CMD);
-
 	// Sw mechanism	
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
 	CL_PRINTF(cliBuf);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.h
index 31c78d324e63..4f6f5d1210c7 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8812a2Ant.h
@@ -148,10 +148,15 @@ typedef struct _COEX_STA_8812A_2ANT{
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8812a2ant_InitHwConfig(
+EXhalbtc8812a2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8812a2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8812a2ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.c
index 8728a47db5c9..c05c7668623d 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.c
@@ -1,7 +1,7 @@
 //============================================================
 // Description:
 //
-// This file is for RTL8821A Co-exist mechanism
+// This file is for 8821A_1ANT Co-exist mechanism
 //
 // History
 // 2012/11/15 Cosa first check in.
@@ -27,8 +27,8 @@ const char *const GLBtInfoSrc8821a1Ant[]={
 	"BT Info[bt auto report]",
 };
 
-u4Byte	GLCoexVerDate8821a1Ant=20130816;
-u4Byte	GLCoexVer8821a1Ant=0x41;
+u4Byte	GLCoexVerDate8821a1Ant=20140306;
+u4Byte	GLCoexVer8821a1Ant=0x4b;
 
 //============================================================
 // local function proto type if needed
@@ -420,7 +420,17 @@ halbtc8821a1ant_MonitorBtCtr(
 	u4Byte			regHPTx=0, regHPRx=0, regLPTx=0, regLPRx=0;
 	u1Byte			u1Tmp, u1Tmp1;
 	s4Byte			wifiRssi;
-	
+#if 0
+	//to avoid 0x76e[3] = 1 (WLAN_Act control by PTA) during IPS
+	if (! (pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x76e) & 0x8) ) 
+	{
+		pCoexSta->highPriorityTx = 65535;
+		pCoexSta->highPriorityRx = 65535;
+		pCoexSta->lowPriorityTx = 65535;
+		pCoexSta->lowPriorityRx = 65535;
+		return;
+	}
+#endif	
 	regHPTxRx = 0x770;
 	regLPTxRx = 0x774;
 
@@ -915,6 +925,8 @@ halbtc8821a1ant_CoexTableWithType(
 	IN	u1Byte				type
 	)
 {
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], ********** CoexTable(%d) **********\n", type));
+	
 	switch(type)
 	{
 		case 0:
@@ -927,19 +939,19 @@ halbtc8821a1ant_CoexTableWithType(
 			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0x5a5a5a5a, 0x5a5a5a5a, 0xffffff, 0x3);
 			break;
 		case 3:
-			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
+			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0x5a5a5a5a, 0xaaaaaaaa, 0xffffff, 0x3);
 			break;
 		case 4:
-			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0xffffffff, 0xffffffff, 0xffffff, 0x3);
+			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0xaaaaaaaa, 0xffffff, 0x3);
 			break;
 		case 5:
-			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0x5fff5fff, 0x5fff5fff, 0xffffff, 0x3);
+			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0x5a5a5a5a, 0xaaaa5a5a, 0xffffff, 0x3);
 			break;
 		case 6:
-			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0x55ff55ff, 0x5a5a5a5a, 0xffffff, 0x3);
+			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0x55555555, 0xaaaa5a5a, 0xffffff, 0x3);
 			break;
 		case 7:
-			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0x5afa5afa, 0x5afa5afa, 0xffffff, 0x3);
+			halbtc8821a1ant_CoexTable(pBtCoexist, bForceExec, 0xaaaaaaaa, 0xaaaaaaaa, 0xffffff, 0x3);
 			break;
 		default:
 			break;
@@ -1000,18 +1012,35 @@ halbtc8821a1ant_SetFwPstdma(
 	)
 {
 	u1Byte			H2C_Parameter[5] ={0};
+	u1Byte			realByte1=byte1, realByte5=byte5;
+	BOOLEAN			bApEnable=FALSE;
 
-	H2C_Parameter[0] = byte1;	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE, &bApEnable);
+
+	if(bApEnable)
+	{
+		if(byte1&BIT4 && !(byte1&BIT5))
+		{			
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], FW for 1Ant AP mode\n"));
+			realByte1 &= ~BIT4;
+			realByte1 |= BIT5;
+
+			realByte5 |= BIT5;
+			realByte5 &= ~BIT6;
+		}
+	}
+
+	H2C_Parameter[0] = realByte1;	
 	H2C_Parameter[1] = byte2;	
 	H2C_Parameter[2] = byte3;
 	H2C_Parameter[3] = byte4;
-	H2C_Parameter[4] = byte5;
+	H2C_Parameter[4] = realByte5;
 
-	pCoexDm->psTdmaPara[0] = byte1;
+	pCoexDm->psTdmaPara[0] = realByte1;
 	pCoexDm->psTdmaPara[1] = byte2;
 	pCoexDm->psTdmaPara[2] = byte3;
 	pCoexDm->psTdmaPara[3] = byte4;
-	pCoexDm->psTdmaPara[4] = byte5;
+	pCoexDm->psTdmaPara[4] = realByte5;
 	
 	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], PS-TDMA H2C cmd =0x%x%08x\n", 
 		H2C_Parameter[0], 
@@ -1075,7 +1104,8 @@ halbtc8821a1ant_SwMechanism(
 	IN	BOOLEAN 	bLowPenaltyRA
 	) 
 {
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_MONITOR, ("[BTCoex], SM[LpRA] = %d \n", bLowPenaltyRA));
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_MONITOR, ("[BTCoex], SM[LpRA] = %d\n", 
+		bLowPenaltyRA));
 	
 	halbtc8821a1ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, bLowPenaltyRA);
 }
@@ -1100,8 +1130,8 @@ halbtc8821a1ant_SetAntPath(
 		u4Tmp |= BIT24;
 		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
 
-		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x975, 0x3, 0x3);
-		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xcb4, 0x77);
+		//0x765 = 0x18
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x765, 0x18, 0x3); 	
 
 		if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT) 
 		{
@@ -1110,7 +1140,7 @@ halbtc8821a1ant_SetAntPath(
 			H2C_Parameter[1] = 1;
 			pBtCoexist->fBtcFillH2c(pBtCoexist, 0x65, 2, H2C_Parameter);
 
-			pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x1); //Main Ant to  BT for IPS case 0x4c[23]=1
+			//pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x1); //Main Ant to  BT for IPS case 0x4c[23]=1
 		}
 		else
 		{
@@ -1119,7 +1149,7 @@ halbtc8821a1ant_SetAntPath(
 			H2C_Parameter[1] = 1;
 			pBtCoexist->fBtcFillH2c(pBtCoexist, 0x65, 2, H2C_Parameter);
 
-			pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x0); //Aux Ant to  BT for IPS case 0x4c[23]=1
+			//pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x64, 0x1, 0x0); //Aux Ant to  BT for IPS case 0x4c[23]=1
 		}
 	}
 	else if(bWifiOff)
@@ -1129,18 +1159,28 @@ halbtc8821a1ant_SetAntPath(
 		u4Tmp &= ~BIT23;
 		u4Tmp &= ~BIT24;
 		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
+
+		//0x765 = 0x18
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x765, 0x18, 0x3); 
+	}
+	else
+	{
+		//0x765 = 0x0
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x765, 0x18, 0x0); 
 	}
 	
 	// ext switch setting
 	switch(antPosType)
 	{
 		case BTC_ANT_PATH_WIFI:
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xcb4, 0x77);
 			if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
 				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xcb7, 0x30, 0x1);
 			else
 				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xcb7, 0x30, 0x2);
 			break;
 		case BTC_ANT_PATH_BT:
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xcb4, 0x77);
 			if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
 				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xcb7, 0x30, 0x2);
 			else
@@ -1148,6 +1188,7 @@ halbtc8821a1ant_SetAntPath(
 			break;
 		default:
 		case BTC_ANT_PATH_PTA:
+			pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xcb4, 0x66);
 			if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT)
 				pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xcb7, 0x30, 0x1);
 			else
@@ -1167,25 +1208,24 @@ halbtc8821a1ant_PsTdma(
 	PBTC_BOARD_INFO	pBoardInfo=&pBtCoexist->boardInfo;
 	BOOLEAN			bTurnOnByCnt=FALSE;
 	u1Byte			psTdmaTypeByCnt=0, rssiAdjustVal=0;
-	u4Byte			fwVer=0;
+	//u4Byte			fwVer=0;
 
 	pCoexDm->bCurPsTdmaOn = bTurnOn;
 	pCoexDm->curPsTdma = type;
 
-	if(!bForceExec)
+	if (pCoexDm->bCurPsTdmaOn)
 	{
-		if (pCoexDm->bCurPsTdmaOn)
-		{
-			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], ********** TDMA(on, %d) **********\n", 
-				pCoexDm->curPsTdma));
-		}
-		else
-		{
-			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], ********** TDMA(off, %d) **********\n", 
-				pCoexDm->curPsTdma));
-		}
-			
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], ********** TDMA(on, %d) **********\n", 
+			pCoexDm->curPsTdma));
+	}
+	else
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], ********** TDMA(off, %d) **********\n", 
+			pCoexDm->curPsTdma));
+	}
 
+	if(!bForceExec)
+	{
 		if( (pCoexDm->bPrePsTdmaOn == pCoexDm->bCurPsTdmaOn) &&
 			(pCoexDm->prePsTdma == pCoexDm->curPsTdma) )
 			return;
@@ -1206,7 +1246,7 @@ halbtc8821a1ant_PsTdma(
 				rssiAdjustVal = 14;
 				break;
 			case 3:
-				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x1d, 0x1d, 0x0, 0x10);
+				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x1d, 0x1d, 0x0, 0x52);
 				break;
 			case 4:
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x93, 0x15, 0x3, 0x14, 0x0);
@@ -1216,7 +1256,7 @@ halbtc8821a1ant_PsTdma(
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x61, 0x15, 0x3, 0x11, 0x10);
 				break;
 			case 6:
-				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x13, 0xa, 0x3, 0x0, 0x0);
+				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x61, 0x20, 0x3, 0x11, 0x13);
 				break;
 			case 7:
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x13, 0xc, 0x5, 0x0, 0x0);
@@ -1232,17 +1272,17 @@ halbtc8821a1ant_PsTdma(
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x13, 0xa, 0xa, 0x0, 0x40);
 				break;
 			case 11:	
-				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x14, 0x03, 0x10, 0x10);
+				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x15, 0x03, 0x10, 0x50);
 				rssiAdjustVal = 20;
 				break;
 			case 12:
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x0a, 0x0a, 0x0, 0x50);
 				break;
 			case 13:
-				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x18, 0x18, 0x0, 0x10);
+				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x12, 0x12, 0x0, 0x50);
 				break;
 			case 14:
-				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x21, 0x3, 0x10, 0x10);
+				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x21, 0x3, 0x10, 0x52);
 				break;
 			case 15:
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x13, 0xa, 0x3, 0x8, 0x0);
@@ -1259,7 +1299,7 @@ halbtc8821a1ant_PsTdma(
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x61, 0x35, 0x03, 0x11, 0x10);
 				break;
 			case 21:
-				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x61, 0x15, 0x03, 0x11, 0x10);
+				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x61, 0x25, 0x03, 0x11, 0x11);
 				break;
 			case 22:
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x61, 0x25, 0x03, 0x11, 0x10);
@@ -1291,13 +1331,13 @@ halbtc8821a1ant_PsTdma(
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0xab, 0x1a, 0x1a, 0x1, 0x10);
 				break;
 			case 30:
-				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x14, 0x3, 0x10, 0x50);
+				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x51, 0x30, 0x3, 0x10, 0x10);
 				break;
 			case 31:
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0xd3, 0x1a, 0x1a, 0, 0x58);
 				break;
 			case 32:
-				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x61, 0xa, 0x3, 0x10, 0x0);
+				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x61, 0x35, 0x3, 0x11, 0x11);
 				break;
 			case 33:
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0xa3, 0x25, 0x3, 0x30, 0x90);
@@ -1311,6 +1351,10 @@ halbtc8821a1ant_PsTdma(
 			case 36:
 				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0xd3, 0x12, 0x3, 0x14, 0x50);
 				break;
+			case 40: // SoftAP only with no sta associated,BT disable ,TDMA mode for power saving
+				/* here softap mode screen off will cost 70-80mA for phone */
+				halbtc8821a1ant_SetFwPstdma(pBtCoexist, 0x23, 0x18, 0x00, 0x10, 0x24);
+				break;	
 		}
 	}
 	else
@@ -1702,29 +1746,6 @@ halbtc8821a1ant_CoexUnder5G(
 	halbtc8821a1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, FALSE, 5);
 }
 
-#define WIFI_ONLY_CHECK_UNDER_5G
-#ifdef WIFI_ONLY_CHECK_UNDER_5G
-VOID
-halbtc8821a1ant_ActionWifiOnly(
-	IN	PBTC_COEXIST		pBtCoexist
-	)
-{
-	BOOLEAN	 bWifiUnder5G=FALSE;
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-
-	if (bWifiUnder5G)
-	{
-		halbtc8821a1ant_CoexUnder5G(pBtCoexist);
-		return;
-	}
-	else
-	{
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
-		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9);
-	}
-}
-#else
 VOID
 halbtc8821a1ant_ActionWifiOnly(
 	IN	PBTC_COEXIST		pBtCoexist
@@ -1733,7 +1754,6 @@ halbtc8821a1ant_ActionWifiOnly(
 	halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
 	halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9);	
 }
-#endif
 
 VOID
 halbtc8821a1ant_MonitorBtEnableDisable(
@@ -1893,6 +1913,16 @@ halbtc8821a1ant_ActionHidA2dp(
 //	Non-Software Coex Mechanism start
 //
 //=============================================
+VOID
+halbtc8821a1ant_ActionWifiMultiPort(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	
+	halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+	halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+}
 
 VOID
 halbtc8821a1ant_ActionHs(
@@ -1900,38 +1930,50 @@ halbtc8821a1ant_ActionHs(
 	)
 {
 	halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
-	halbtc8821a1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 2);
+	halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 }
 
 VOID
 halbtc8821a1ant_ActionBtInquiry(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
-{
+{	
 	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
-	BOOLEAN			bWifiConnected=FALSE;
-	
+	BOOLEAN			bWifiConnected=FALSE, bApEnable=FALSE, bWifiBusy=FALSE, bBtBusy=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE, &bApEnable);
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bBtBusy);
 
-	if(!bWifiConnected)
+	if((!bWifiConnected) && (!pCoexSta->bWiFiIsHighPriTask))
 	{
 		halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
-		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+
+	 	halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);		
 	}
-	else if( (pBtLinkInfo->bScoExist) ||
-			(pBtLinkInfo->bHidOnly) )
+	else if((pBtLinkInfo->bScoExist) || (pBtLinkInfo->bHidExist) || (pBtLinkInfo->bA2dpExist))
 	{
-		// SCO/HID-only busy
+		// SCO/HID/A2DP  busy
 		halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);		
+	}
+	else if ((pBtLinkInfo->bPanExist) || (bWifiBusy))
+	{
+		halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);		
+		
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
 	}
 	else
 	{
-		halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);
-		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 30);
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+		halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 7);
 	}
 }
 
@@ -1941,13 +1983,24 @@ halbtc8821a1ant_ActionBtScoHidOnlyBusy(
 	IN	u1Byte				wifiStatus
 	)
 {
+	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	BOOLEAN	bWifiConnected=FALSE;
+	u1Byte	wifiRssiState=BTC_RSSI_STATE_HIGH;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+
 	// tdma and coex table
-	halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
 
-	if(BT_8821A_1ANT_WIFI_STATUS_NON_CONNECTED_ASSO_AUTH_SCAN == wifiStatus)
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);		
-	else
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+	if(pBtLinkInfo->bScoExist)
+	{
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+	}
+	else //HID
+	{
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 5);
+	}
 }
 
 VOID
@@ -1969,18 +2022,26 @@ halbtc8821a1ant_ActionWifiConnectedBtAclBusy(
 	}
 	else if(pBtLinkInfo->bA2dpOnly)  //A2DP		
 	{
-		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+		if(BT_8821A_1ANT_WIFI_STATUS_CONNECTED_IDLE == wifiStatus)
+		{
+			//halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+			//halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
+			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+			pCoexDm->bAutoTdmaAdjust = FALSE;
+		}
+		else if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
 			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )	
 		{
- 			 halbtc8821a1ant_TdmaDurationAdjustForAcl(pBtCoexist, wifiStatus);
+			halbtc8821a1ant_TdmaDurationAdjustForAcl(pBtCoexist, wifiStatus);
+			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
 		}
 		else //for low BT RSSI
 		{
 			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
 			pCoexDm->bAutoTdmaAdjust = FALSE;
-		}		   	
-
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+		}
 	}
 	else if(pBtLinkInfo->bHidExist&&pBtLinkInfo->bA2dpExist)  //HID+A2DP
 	{
@@ -1992,16 +2053,16 @@ halbtc8821a1ant_ActionWifiConnectedBtAclBusy(
 		}
 		else //for low BT RSSI
 		{
-			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
 			pCoexDm->bAutoTdmaAdjust = FALSE;
 		}		   	
 
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 6);
 	}
 	else if( (pBtLinkInfo->bPanOnly) || (pBtLinkInfo->bHidExist&&pBtLinkInfo->bPanExist) ) //PAN(OPP,FTP), HID+PAN(OPP,FTP)			
 	{
 		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 6);
 		pCoexDm->bAutoTdmaAdjust = FALSE;
 	}
 	else if ( ((pBtLinkInfo->bA2dpExist) && (pBtLinkInfo->bPanExist)) ||
@@ -2028,20 +2089,80 @@ halbtc8821a1ant_ActionWifiNotConnected(
 	halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 
 	// tdma and coex table	
-	halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+	halbtc8821a1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);
 	halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
 }
 
 VOID
-halbtc8821a1ant_ActionWifiNotConnectedAssoAuthScan(
+halbtc8821a1ant_ActionWifiNotConnectedScan(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
+	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	
 	halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+	
+	// tdma and coex table
+	if(BT_8821A_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus)
+	{
+		if (pBtLinkInfo->bA2dpExist)
+		{
+			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
+			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+		}
+		else if (pBtLinkInfo->bA2dpExist && pBtLinkInfo->bPanExist)
+	 {
+			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+	 	}
+	 	else
+	 	{
+		        halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
+			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+		}
+	}
+	else if( (BT_8821A_1ANT_BT_STATUS_SCO_BUSY == pCoexDm->btStatus) ||
+			(BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY == pCoexDm->btStatus) )
+	{
+		halbtc8821a1ant_ActionBtScoHidOnlyBusy(pBtCoexist,
+			BT_8821A_1ANT_WIFI_STATUS_CONNECTED_SCAN);
+	}
+	else
+	{
+		//halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
+		//halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+
+		//Bryant Add
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+	}
+}
 
+VOID
+halbtc8821a1ant_ActionWifiNotConnectedAssoAuth(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
+	
+	halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 
-	halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
-	halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+	// tdma and coex table
+	if( (pBtLinkInfo->bScoExist)  || (pBtLinkInfo->bHidExist) )
+	{
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);		
+	}
+	else if( (pBtLinkInfo->bA2dpExist)  || (pBtLinkInfo->bPanExist) ) 			
+	{
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);		
+	}
+	else	
+	{		
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+	}
 }
 
 VOID
@@ -2051,22 +2172,26 @@ halbtc8821a1ant_ActionWifiConnectedScan(
 {
 	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
 	
-	// power save state
 	halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 
 	// tdma and coex table
 	if(BT_8821A_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus)
 	{
-		if(pBtLinkInfo->bA2dpExist && pBtLinkInfo->bPanExist)
+		if (pBtLinkInfo->bA2dpExist)
+		{
+			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
+			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+		}
+		else if (pBtLinkInfo->bA2dpExist && pBtLinkInfo->bPanExist)
 	 	{
 			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
-			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
 	 	}
 	 	else
 	 	{
-		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
-	}
+			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
+			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);
+	 	}
 	}
 	else if( (BT_8821A_1ANT_BT_STATUS_SCO_BUSY == pCoexDm->btStatus) ||
 			(BT_8821A_1ANT_BT_STATUS_ACL_SCO_BUSY == pCoexDm->btStatus) )
@@ -2076,8 +2201,12 @@ halbtc8821a1ant_ActionWifiConnectedScan(
 	}
 	else
 	{
-		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+		//halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
+		//halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+
+		//Bryant Add
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 	}
 }
 
@@ -2086,31 +2215,25 @@ halbtc8821a1ant_ActionWifiConnectedSpecialPacket(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	BOOLEAN 		bHsConnecting=FALSE;
 	PBTC_BT_LINK_INFO pBtLinkInfo=&pBtCoexist->btLinkInfo;
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_CONNECTING, &bHsConnecting);
-
 	halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 
 	// tdma and coex table
-	if(BT_8821A_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus)
+	if((pBtLinkInfo->bScoExist) || (pBtLinkInfo->bHidExist) || (pBtLinkInfo->bA2dpExist))
 	{
-		if(pBtLinkInfo->bA2dpExist && pBtLinkInfo->bPanExist)
-	 	{
-			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
-			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
-	 	}
-	 	else
-	 	{
-			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
-	 	}
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 32);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);		
 	}
-	else
+	else if(pBtLinkInfo->bPanExist) 
 	{
 		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 20);
-		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 1);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 4);		
+	}
+	else	
+	{		
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 	}
 }
 
@@ -2121,7 +2244,7 @@ halbtc8821a1ant_ActionWifiConnected(
 {
 	BOOLEAN 	bWifiBusy=FALSE;
 	BOOLEAN 	bScan=FALSE, bLink=FALSE, bRoam=FALSE;
-	BOOLEAN 	bUnder4way=FALSE;
+	BOOLEAN		bUnder4way=FALSE, bApEnable=FALSE;
 	u4Byte		wifiBw;
 
 	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], CoexForWifiConnect()===>\n"));
@@ -2139,19 +2262,28 @@ halbtc8821a1ant_ActionWifiConnected(
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
 	if(bScan || bLink || bRoam)
 	{
-		halbtc8821a1ant_ActionWifiConnectedScan(pBtCoexist);
+		if(bScan)	
+			halbtc8821a1ant_ActionWifiConnectedScan(pBtCoexist);
+		else
+			halbtc8821a1ant_ActionWifiConnectedSpecialPacket(pBtCoexist);
 		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], CoexForWifiConnect(), return for wifi is under scan<===\n"));
 		return;
 	}
 
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE, &bApEnable);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
 	// power save state
-	if(BT_8821A_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus && !pBtCoexist->btLinkInfo.bHidOnly)
-		halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+	if(!bApEnable && BT_8821A_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus && !pBtCoexist->btLinkInfo.bHidOnly)
+	{
+		if(!bWifiBusy && pBtCoexist->btLinkInfo.bA2dpOnly)	//A2DP
+			halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
+		else
+			halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_LPS_ON, 0x50, 0x4);
+	}
 	else
 		halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 
 	// tdma and coex table
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);	
 	if(!bWifiBusy)
 	{
 		if(BT_8821A_1ANT_BT_STATUS_ACL_BUSY == pCoexDm->btStatus)
@@ -2167,7 +2299,7 @@ halbtc8821a1ant_ActionWifiConnected(
 		}
 		else
 		{
-			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
 			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 		}
 	}
@@ -2186,7 +2318,7 @@ halbtc8821a1ant_ActionWifiConnected(
 		}
 		else 
 		{
-			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+			halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
 			halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
 		}
 	}
@@ -2270,6 +2402,8 @@ halbtc8821a1ant_RunCoexistMechanism(
 	BOOLEAN	bBtCtrlAggBufSize=FALSE;
 	u1Byte	aggBufSize=5;
 	u1Byte	wifiRssiState=BTC_RSSI_STATE_HIGH;
+	u4Byte	wifiLinkStatus=0;
+	u4Byte	numOfWifiLink=0;
 	BOOLEAN	bWifiUnder5G=FALSE;
 
 	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], RunCoexistMechanism()===>\n"));
@@ -2308,9 +2442,18 @@ halbtc8821a1ant_RunCoexistMechanism(
 	}
 
 	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_INC_SCAN_DEV_NUM, &bIncreaseScanDevNum);
-
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
 
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
+	numOfWifiLink = wifiLinkStatus>>16;
+	if((numOfWifiLink>=2) || (wifiLinkStatus&WIFI_P2P_GO_CONNECTED))
+	{
+		halbtc8821a1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, bBtCtrlAggBufSize, aggBufSize);
+		halbtc8821a1ant_ActionWifiMultiPort(pBtCoexist);
+		return;
+	}
+
 	if(!pBtLinkInfo->bScoExist && !pBtLinkInfo->bHidExist)
 	{
 		halbtc8821a1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
@@ -2380,7 +2523,12 @@ halbtc8821a1ant_RunCoexistMechanism(
 		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
 
 		if(bScan || bLink || bRoam)
-			halbtc8821a1ant_ActionWifiNotConnectedAssoAuthScan(pBtCoexist);
+		{
+			 if (bScan)	
+				halbtc8821a1ant_ActionWifiNotConnectedScan(pBtCoexist);	
+			 else
+				halbtc8821a1ant_ActionWifiNotConnectedAssoAuth(pBtCoexist);	
+		}
 		else
 			halbtc8821a1ant_ActionWifiNotConnected(pBtCoexist);
 	}
@@ -2399,14 +2547,15 @@ halbtc8821a1ant_InitCoexDm(
 	// sw all off
 	halbtc8821a1ant_SwMechanism(pBtCoexist, FALSE);
 
-	halbtc8821a1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);
+	//halbtc8821a1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);
 	halbtc8821a1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 0);
 }
 
 VOID
 halbtc8821a1ant_InitHwConfig(
 	IN	PBTC_COEXIST		pBtCoexist,
-	IN	BOOLEAN				bBackUp
+	IN	BOOLEAN				bBackUp,
+	IN	BOOLEAN				bWifiOnly
 	)
 {
 	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
@@ -2416,9 +2565,12 @@ halbtc8821a1ant_InitHwConfig(
 	u1Byte				H2C_Parameter[2] ={0};
 	BOOLEAN			bWifiUnder5G=FALSE;
 		
-
+	
 	BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], 1Ant Init HW Config!!\n"));
 
+	if(bWifiOnly)
+		return;
+	
 	if(bBackUp)
 	{
 		pCoexDm->backupArfrCnt1 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x430);
@@ -2440,6 +2592,7 @@ halbtc8821a1ant_InitHwConfig(
 		halbtc8821a1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, TRUE, FALSE);
 	else
 		halbtc8821a1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_PTA, TRUE, FALSE);
+
 	// PTA parameter
 	halbtc8821a1ant_CoexTableWithType(pBtCoexist, FORCE_EXEC, 0);
 
@@ -2456,11 +2609,19 @@ halbtc8821a1ant_InitHwConfig(
 // extern function start with EXhalbtc8821a1ant_
 //============================================================
 VOID
-EXhalbtc8821a1ant_InitHwConfig(
+EXhalbtc8821a1ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
 {
-	halbtc8821a1ant_InitHwConfig(pBtCoexist, TRUE);
+}
+
+VOID
+EXhalbtc8821a1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
+{
+	halbtc8821a1ant_InitHwConfig(pBtCoexist, TRUE, bWifiOnly);
 }
 
 VOID
@@ -2489,11 +2650,7 @@ EXhalbtc8821a1ant_DisplayCoexInfo(
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u2Byte				u2Tmp[4];
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
+	u4Byte				faOfdm, faCck;
 	u4Byte				fwVer=0, btPatchVer=0;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
@@ -2514,13 +2671,6 @@ EXhalbtc8821a1ant_DisplayCoexInfo(
 		CL_PRINTF(cliBuf);
 	}
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d", "Ant PG Num/ Ant Mech/ Ant Pos:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum, pBoardInfo->btdmAntPos);
 	CL_PRINTF(cliBuf);	
@@ -2535,40 +2685,19 @@ EXhalbtc8821a1ant_DisplayCoexInfo(
 		GLCoexVerDate8821a1Ant, GLCoexVer8821a1Ant, fwVer, btPatchVer, btPatchVer);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(HsMode)", \
-		wifiDot11Chnl, wifiHsChnl, bBtHsOn);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
+	
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
 		((pBtCoexist->btInfo.bBtDisabled)? ("disabled"):	((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE == pCoexDm->btStatus)? "non-connected idle":
 		(  (BT_8821A_1ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy")))),
@@ -2597,13 +2726,6 @@ EXhalbtc8821a1ant_DisplayCoexInfo(
 			CL_PRINTF(cliBuf);
 		}
 	}
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/%s, (0x%x/0x%x)", "PS state, IPS/LPS, (lps/rpwm)", \
-		((pCoexSta->bUnderIps? "IPS ON":"IPS OFF")),
-		((pCoexSta->bUnderLps? "LPS ON":"LPS OFF")), 
-		pBtCoexist->btInfo.lpsVal, 
-		pBtCoexist->btInfo.rpwmVal);
-	CL_PRINTF(cliBuf);
-	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_FW_PWR_MODE_CMD);
 
 	if(!pBtCoexist->bManualControl)
 	{
@@ -2634,13 +2756,13 @@ EXhalbtc8821a1ant_DisplayCoexInfo(
 			pCoexDm->psTdmaPara[4], psTdmaCase, pCoexDm->bAutoTdmaAdjust);
 		CL_PRINTF(cliBuf);
 	
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "Latest error condition(should be 0)", \
-			pCoexDm->errorCondition);
-		CL_PRINTF(cliBuf);
-		
 		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d ", "IgnWlanAct", \
 			pCoexDm->bCurIgnoreWlanAct);
 		CL_PRINTF(cliBuf);
+	
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x ", "Latest error condition(should be 0)", \
+			pCoexDm->errorCondition);
+		CL_PRINTF(cliBuf);
 	}
 
 	// Hw setting		
@@ -2705,9 +2827,8 @@ EXhalbtc8821a1ant_DisplayCoexInfo(
 	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c0);
 	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c4);
 	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c8);
-	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x6cc);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x/ 0x%x", "0x6c0/0x6c4/0x6c8/0x6cc(coexTable)", \
-		u4Tmp[0], u4Tmp[1], u4Tmp[2], u1Tmp[0]);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x6c0/0x6c4/0x6c8(coexTable)", \
+		u4Tmp[0], u4Tmp[1], u4Tmp[2]);
 	CL_PRINTF(cliBuf);
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "0x770(high-pri rx/tx)", \
@@ -2738,17 +2859,20 @@ EXhalbtc8821a1ant_IpsNotify(
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], IPS ENTER notify\n"));
 		pCoexSta->bUnderIps = TRUE;
-		halbtc8821a1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, TRUE);
-		//set PTA control
-		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 8);
+		
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
 		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 0);
+		halbtc8821a1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, TRUE);	
+		//halbtc8821a1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF);
 	}
 	else if(BTC_IPS_LEAVE == type)
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], IPS LEAVE notify\n"));
 		pCoexSta->bUnderIps = FALSE;
 
-		halbtc8821a1ant_RunCoexistMechanism(pBtCoexist);
+		halbtc8821a1ant_InitHwConfig(pBtCoexist, FALSE, FALSE);
+		halbtc8821a1ant_InitCoexDm(pBtCoexist);
+		halbtc8821a1ant_QueryBtInfo(pBtCoexist);
 	}
 }
 
@@ -2780,10 +2904,29 @@ EXhalbtc8821a1ant_ScanNotify(
 	)
 {
 	BOOLEAN bWifiConnected=FALSE, bBtHsOn=FALSE;	
+	u4Byte	wifiLinkStatus=0;
+	u4Byte	numOfWifiLink=0;
+	BOOLEAN	bBtCtrlAggBufSize=FALSE;
+	u1Byte	aggBufSize=5;
 
 	if(pBtCoexist->bManualControl ||
-		pBtCoexist->bStopCoexDm ||
-		pBtCoexist->btInfo.bBtDisabled )
+		pBtCoexist->bStopCoexDm )
+		return;
+
+	if(BTC_SCAN_START == type)
+	{
+		pCoexSta->bWiFiIsHighPriTask = TRUE;
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN START notify\n"));
+
+		halbtc8821a1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 8);  //Force antenna setup for no scan result issue
+	}
+	else
+	{
+		pCoexSta->bWiFiIsHighPriTask = FALSE;	
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN FINISH notify\n"));
+	}	
+
+	if(pBtCoexist->btInfo.bBtDisabled)
 		return;
 
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
@@ -2791,6 +2934,16 @@ EXhalbtc8821a1ant_ScanNotify(
 
 	halbtc8821a1ant_QueryBtInfo(pBtCoexist);
 	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
+	numOfWifiLink = wifiLinkStatus>>16;
+	if(numOfWifiLink >= 2)
+	{
+		halbtc8821a1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, bBtCtrlAggBufSize, aggBufSize);
+		halbtc8821a1ant_ActionWifiMultiPort(pBtCoexist);
+		return;
+	}
+	
 	if(pCoexSta->bC2hBtInquiryPage)
 	{
 		halbtc8821a1ant_ActionBtInquiry(pBtCoexist);
@@ -2804,10 +2957,10 @@ EXhalbtc8821a1ant_ScanNotify(
 
 	if(BTC_SCAN_START == type)
 	{
-		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN START notify\n"));
+		//BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN START notify\n"));
 		if(!bWifiConnected)	// non-connected scan
 		{
-			halbtc8821a1ant_ActionWifiNotConnectedAssoAuthScan(pBtCoexist);
+			halbtc8821a1ant_ActionWifiNotConnectedScan(pBtCoexist);
 		}
 		else	// wifi is connected
 		{
@@ -2816,7 +2969,7 @@ EXhalbtc8821a1ant_ScanNotify(
 	}
 	else if(BTC_SCAN_FINISH == type)
 	{
-		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN FINISH notify\n"));
+		//BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN FINISH notify\n"));
 		if(!bWifiConnected)	// non-connected scan
 		{
 			halbtc8821a1ant_ActionWifiNotConnected(pBtCoexist);
@@ -2835,12 +2988,39 @@ EXhalbtc8821a1ant_ConnectNotify(
 	)
 {
 	BOOLEAN	bWifiConnected=FALSE, bBtHsOn=FALSE;	
+	u4Byte	wifiLinkStatus=0;
+	u4Byte	numOfWifiLink=0;
+	BOOLEAN	bBtCtrlAggBufSize=FALSE;
+	u1Byte	aggBufSize=5;
 
 	if(pBtCoexist->bManualControl ||
 		pBtCoexist->bStopCoexDm ||
 		pBtCoexist->btInfo.bBtDisabled )
 		return;
 
+	if(BTC_ASSOCIATE_START == type)
+	{
+	 pCoexSta->bWiFiIsHighPriTask = TRUE;
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT START notify\n"));	
+		pCoexDm->nArpCnt = 0;
+	}
+	else
+	{
+		pCoexSta->bWiFiIsHighPriTask = FALSE;	
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT FINISH notify\n"));	
+		pCoexDm->nArpCnt = 0;
+	}
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
+	numOfWifiLink = wifiLinkStatus>>16;
+	if(numOfWifiLink >= 2)
+	{
+		halbtc8821a1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, bBtCtrlAggBufSize, aggBufSize);
+		halbtc8821a1ant_ActionWifiMultiPort(pBtCoexist);
+		return;
+	}
+
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
 	if(pCoexSta->bC2hBtInquiryPage)
 	{
@@ -2855,12 +3035,12 @@ EXhalbtc8821a1ant_ConnectNotify(
 
 	if(BTC_ASSOCIATE_START == type)
 	{
-		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT START notify\n"));
-		halbtc8821a1ant_ActionWifiNotConnectedAssoAuthScan(pBtCoexist);
+		//BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT START notify\n"));		
+		halbtc8821a1ant_ActionWifiNotConnectedAssoAuth(pBtCoexist);
 	}
 	else if(BTC_ASSOCIATE_FINISH == type)
 	{
-		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT FINISH notify\n"));
+		//BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT FINISH notify\n"));
 		
 		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
 		if(!bWifiConnected) // non-connected scan
@@ -2896,6 +3076,7 @@ EXhalbtc8821a1ant_MediaStatusNotify(
 	else
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], MEDIA disconnect notify\n"));
+		pCoexDm->nArpCnt = 0;
 	}
 
 	// only 2.4G we need to inform bt the chnl mask
@@ -2930,14 +3111,49 @@ EXhalbtc8821a1ant_SpecialPacketNotify(
 	)
 {
 	BOOLEAN	bBtHsOn=FALSE;
+	u4Byte	wifiLinkStatus=0;
+	u4Byte	numOfWifiLink=0;
+	BOOLEAN	bBtCtrlAggBufSize=FALSE;
+	u1Byte	aggBufSize=5;
 	
 	if(pBtCoexist->bManualControl ||
 		pBtCoexist->bStopCoexDm ||
 		pBtCoexist->btInfo.bBtDisabled )
 		return;
 
+	if( BTC_PACKET_DHCP == type || 
+		BTC_PACKET_EAPOL == type ||
+		BTC_PACKET_ARP == type )
+	{
+		pCoexSta->bWiFiIsHighPriTask = TRUE;
+
+		if(BTC_PACKET_ARP == type)
+		{
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], special Packet ARP notify\n"));		 
+		}
+		else
+		{
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], special Packet DHCP or EAPOL notify\n"));		 
+		}
+	}
+	else
+	{
+		pCoexSta->bWiFiIsHighPriTask = FALSE;	
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], special Packet [Type = %d] notify\n", type));
+	}
+
 	pCoexSta->specialPktPeriodCnt = 0;
 
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_LINK_STATUS, &wifiLinkStatus);
+	numOfWifiLink = wifiLinkStatus>>16;
+	if(numOfWifiLink >= 2)
+	{
+		halbtc8821a1ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0);
+		halbtc8821a1ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, bBtCtrlAggBufSize, aggBufSize);
+		halbtc8821a1ant_ActionWifiMultiPort(pBtCoexist);
+		return;
+	}
+
 	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
 	if(pCoexSta->bC2hBtInquiryPage)
 	{
@@ -2951,9 +3167,18 @@ EXhalbtc8821a1ant_SpecialPacketNotify(
 	}
 
 	if( BTC_PACKET_DHCP == type ||
-		BTC_PACKET_EAPOL == type )
+		BTC_PACKET_EAPOL == type || 
+		BTC_PACKET_ARP == type )
 	{
-		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], special Packet(%d) notify\n", type));
+		//BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], special Packet(%d) notify\n", type));
+		if(BTC_PACKET_ARP == type)
+		{
+			pCoexDm->nArpCnt++;
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], ARP Packet Count = %d\n", pCoexDm->nArpCnt));
+			if(pCoexDm->nArpCnt >= 10) // if APR PKT > 10 after connect, do not go to ActionWifiConnectedSpecialPacket(pBtCoexist) 
+				return;	
+		}
+		
 		halbtc8821a1ant_ActionWifiConnectedSpecialPacket(pBtCoexist);
 	}
 }
@@ -3002,12 +3227,26 @@ EXhalbtc8821a1ant_BtInfoNotify(
 		pCoexSta->btRetryCnt =	// [3:0]
 			pCoexSta->btInfoC2h[rspSource][2]&0xf;
 
+		if (pCoexSta->btInfoC2h[rspSource][2]&0x20)
+			pCoexSta->bC2hBtPage = TRUE;
+		else
+			pCoexSta->bC2hBtPage = FALSE;			
+
 		pCoexSta->btRssi =
 			pCoexSta->btInfoC2h[rspSource][3]*2+10;
 
 		pCoexSta->btInfoExt = 
 			pCoexSta->btInfoC2h[rspSource][4];
 
+		pCoexSta->bBtTxRxMask = (pCoexSta->btInfoC2h[rspSource][2]&0x40);
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TX_RX_MASK, &pCoexSta->bBtTxRxMask);
+		if(!pCoexSta->bBtTxRxMask)
+		{
+			/* BT into is responded by BT FW and BT RF REG 0x3C != 0x15 => Need to switch BT TRx Mask */				
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Switch BT TRx Mask since BT RF REG 0x3C != 0x15\n"));
+			pBtCoexist->fBtcSetBtReg(pBtCoexist, BTC_BT_REG_RF, 0x3c, 0x15);
+		}
+		
 		// Here we need to resend some wifi info to BT
 		// because bt is reset and loss of the info.
 		if(pCoexSta->btInfoExt & BIT1)
@@ -3043,7 +3282,6 @@ EXhalbtc8821a1ant_BtInfoNotify(
 		}
 		else
 		{
-			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], BT ext info bit4 check, set BT to enable Auto Report!!\n"));
 			halbtc8821a1ant_BtAutoReport(pBtCoexist, FORCE_EXEC, TRUE);
 		}
 #endif
@@ -3087,6 +3325,8 @@ EXhalbtc8821a1ant_BtInfoNotify(
 
 	halbtc8821a1ant_UpdateBtLinkInfo(pBtCoexist);
 		
+	btInfo = btInfo & 0x1f;  //mask profile bit for connect-ilde identification ( for CSR case: A2DP idle --> 0x41)
+	
 	if(!(btInfo&BT_INFO_8821A_1ANT_B_CONNECTION))
 	{
 		pCoexDm->btStatus = BT_8821A_1ANT_BT_STATUS_NON_CONNECTED_IDLE;
@@ -3136,15 +3376,16 @@ EXhalbtc8821a1ant_HaltNotify(
 	
 	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Halt notify\n"));
 
-	pBtCoexist->bStopCoexDm = TRUE;
-
-	halbtc8821a1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, TRUE);
-	halbtc8821a1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
-
 	halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
 	halbtc8821a1ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 0);
+	halbtc8821a1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, TRUE);
+	//halbtc8821a1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF);
+
+	halbtc8821a1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
 
 	EXhalbtc8821a1ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+
+	pBtCoexist->bStopCoexDm = TRUE;	
 }
 
 VOID
@@ -3158,16 +3399,20 @@ EXhalbtc8821a1ant_PnpNotify(
 	if(BTC_WIFI_PNP_SLEEP == pnpState)
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to SLEEP\n"));
-		pBtCoexist->bStopCoexDm = TRUE;
-		halbtc8821a1ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+
 		halbtc8821a1ant_PowerSaveState(pBtCoexist, BTC_PS_WIFI_NATIVE, 0x0, 0x0);
-		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 9);	
+		halbtc8821a1ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+		halbtc8821a1ant_CoexTableWithType(pBtCoexist, NORMAL_EXEC, 2);
+		halbtc8821a1ant_SetAntPath(pBtCoexist, BTC_ANT_PATH_BT, FALSE, TRUE);
+		//halbtc8821a1ant_SetAntPathDCut(pBtCoexist, FALSE, FALSE, FALSE, BTC_ANT_PATH_BT, BTC_WIFI_STAT_NORMAL_OFF);
+
+		pBtCoexist->bStopCoexDm = TRUE;
 	}
 	else if(BTC_WIFI_PNP_WAKE_UP == pnpState)
 	{
 		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to WAKE UP\n"));
 		pBtCoexist->bStopCoexDm = FALSE;
-		halbtc8821a1ant_InitHwConfig(pBtCoexist, FALSE);
+		halbtc8821a1ant_InitHwConfig(pBtCoexist, FALSE, FALSE);
 		halbtc8821a1ant_InitCoexDm(pBtCoexist);
 		halbtc8821a1ant_QueryBtInfo(pBtCoexist);
 	}
@@ -3208,10 +3453,10 @@ EXhalbtc8821a1ant_Periodical(
 	if( halbtc8821a1ant_IsWifiStatusChanged(pBtCoexist) ||
 		pCoexDm->bAutoTdmaAdjust )
 	{
-		if(pCoexSta->specialPktPeriodCnt > 2)
-		{
+		//if(pCoexSta->specialPktPeriodCnt > 2)
+		//{
 			halbtc8821a1ant_RunCoexistMechanism(pBtCoexist);	
-		}
+		//}
 	}
 
 	pCoexSta->specialPktPeriodCnt++;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.h
index a9656abc2e29..4c7469ef67c8 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a1Ant.h
@@ -1,7 +1,7 @@
 //===========================================
 // The following is for 8821A 1ANT BT Co-exist definition
 //===========================================
-#define	BT_AUTO_REPORT_ONLY_8821A_1ANT				0
+#define	BT_AUTO_REPORT_ONLY_8821A_1ANT				1
 
 #define	BT_INFO_8821A_1ANT_B_FTP						BIT7
 #define	BT_INFO_8821A_1ANT_B_A2DP					BIT6
@@ -108,6 +108,7 @@ typedef struct _COEX_DM_8821A_1ANT{
 	u1Byte		curRetryLimitType;
 	u1Byte		preAmpduTimeType;
 	u1Byte		curAmpduTimeType;
+	u4Byte		nArpCnt;
 
 	u1Byte		errorCondition;
 } COEX_DM_8821A_1ANT, *PCOEX_DM_8821A_1ANT;
@@ -127,12 +128,15 @@ typedef struct _COEX_STA_8821A_1ANT{
 	u4Byte					lowPriorityTx;
 	u4Byte					lowPriorityRx;
 	u1Byte					btRssi;
+	BOOLEAN					bBtTxRxMask;
 	u1Byte					preBtRssiState;
 	u1Byte					preWifiRssiState[4];
 	BOOLEAN					bC2hBtInfoReqSent;
 	u1Byte					btInfoC2h[BT_INFO_SRC_8821A_1ANT_MAX][10];
 	u4Byte					btInfoC2hCnt[BT_INFO_SRC_8821A_1ANT_MAX];
 	BOOLEAN					bC2hBtInquiryPage;
+	BOOLEAN					bC2hBtPage;				//Add for win8.1 page out issue
+	BOOLEAN					bWiFiIsHighPriTask;		//Add for win8.1 page out issue
 	u1Byte					btRetryCnt;
 	u1Byte					btInfoExt;
 }COEX_STA_8821A_1ANT, *PCOEX_STA_8821A_1ANT;
@@ -141,10 +145,15 @@ typedef struct _COEX_STA_8821A_1ANT{
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8821a1ant_InitHwConfig(
+EXhalbtc8821a1ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8821a1ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8821a1ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
@@ -201,10 +210,4 @@ VOID
 EXhalbtc8821a1ant_DisplayCoexInfo(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
-VOID
-EXhalbtc8821a1ant_DbgControl(
-	IN	PBTC_COEXIST			pBtCoexist,
-	IN	u1Byte				opCode,
-	IN	u1Byte				opLen,
-	IN	pu1Byte 			pData
-	);
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.c
index 0d513790a405..14ad651a9eb3 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.c
@@ -686,97 +686,6 @@ halbtc8821a2ant_DecBtPwr(
 	pCoexDm->bPreDecBtPwr = pCoexDm->bCurDecBtPwr;
 }
 
-VOID
-halbtc8821a2ant_SetFwBtLnaConstrain(
-	IN	PBTC_COEXIST		pBtCoexist,
-	IN	BOOLEAN			bBtLnaConsOn
-	)
-{
-	u1Byte			H2C_Parameter[2] ={0};
-	
-	H2C_Parameter[0] = 0x3;	// opCode, 0x3=BT_SET_LNA_CONSTRAIN
-
-	if(bBtLnaConsOn)
-	{
-		H2C_Parameter[1] |= BIT0;
-	}
-
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], set BT LNA Constrain: %s, FW write 0x69=0x%x\n", 
-		(bBtLnaConsOn? "ON!!":"OFF!!"), 
-		H2C_Parameter[0]<<8|H2C_Parameter[1]));
-
-	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x69, 2, H2C_Parameter);	
-}
-
-VOID
-halbtc8821a2ant_SetBtLnaConstrain(
-	IN	PBTC_COEXIST		pBtCoexist,
-	IN	BOOLEAN			bForceExec,
-	IN	BOOLEAN			bBtLnaConsOn
-	)
-{
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s BT Constrain = %s\n",  
-		(bForceExec? "force":""), ((bBtLnaConsOn)? "ON":"OFF")));
-	pCoexDm->bCurBtLnaConstrain = bBtLnaConsOn;
-
-	if(!bForceExec)
-	{
-		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], bPreBtLnaConstrain=%d, bCurBtLnaConstrain=%d\n", 
-			pCoexDm->bPreBtLnaConstrain, pCoexDm->bCurBtLnaConstrain));
-
-		if(pCoexDm->bPreBtLnaConstrain == pCoexDm->bCurBtLnaConstrain) 
-			return;
-	}
-	halbtc8821a2ant_SetFwBtLnaConstrain(pBtCoexist, pCoexDm->bCurBtLnaConstrain);
-
-	pCoexDm->bPreBtLnaConstrain = pCoexDm->bCurBtLnaConstrain;
-}
-
-VOID
-halbtc8821a2ant_SetFwBtPsdMode(
-	IN	PBTC_COEXIST		pBtCoexist,
-	IN	u1Byte			btPsdMode
-	)
-{
-	u1Byte			H2C_Parameter[2] ={0};
-	
-	H2C_Parameter[0] = 0x2;	// opCode, 0x2=BT_SET_PSD_MODE
-
-	H2C_Parameter[1] = btPsdMode;
-
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], set BT PSD mode=0x%x, FW write 0x69=0x%x\n", 
-		H2C_Parameter[1], 
-		H2C_Parameter[0]<<8|H2C_Parameter[1]));
-
-	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x69, 2, H2C_Parameter);	
-}
-
-
-VOID
-halbtc8821a2ant_SetBtPsdMode(
-	IN	PBTC_COEXIST		pBtCoexist,
-	IN	BOOLEAN			bForceExec,
-	IN	u1Byte			btPsdMode
-	)
-{
-	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s BT PSD mode = 0x%x\n",  
-		(bForceExec? "force":""), btPsdMode));
-	pCoexDm->bCurBtPsdMode = btPsdMode;
-
-	if(!bForceExec)
-	{
-		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], bPreBtPsdMode=0x%x, bCurBtPsdMode=0x%x\n", 
-			pCoexDm->bPreBtPsdMode, pCoexDm->bCurBtPsdMode));
-
-		if(pCoexDm->bPreBtPsdMode == pCoexDm->bCurBtPsdMode) 
-			return;
-	}
-	halbtc8821a2ant_SetFwBtPsdMode(pBtCoexist, pCoexDm->bCurBtPsdMode);
-
-	pCoexDm->bPreBtPsdMode = pCoexDm->bCurBtPsdMode;
-}
-
-
 VOID
 halbtc8821a2ant_SetBtAutoReport(
 	IN	PBTC_COEXIST		pBtCoexist,
@@ -1470,6 +1379,8 @@ halbtc8821a2ant_CoexUnder5G(
 	)
 {
 	halbtc8821a2ant_CoexAllOff(pBtCoexist);
+
+	halbtc8821a2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, TRUE);
 }
 
 VOID
@@ -3598,9 +3509,17 @@ halbtc8821a2ant_RunCoexistMechanism(
 // extern function start with EXhalbtc8821a2ant_
 //============================================================
 VOID
-EXhalbtc8821a2ant_InitHwConfig(
+EXhalbtc8821a2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	)
+{
+}
+
+VOID
+EXhalbtc8821a2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
 {
 	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
 	u4Byte	u4Tmp=0;
@@ -3653,23 +3572,11 @@ EXhalbtc8821a2ant_DisplayCoexInfo(
 	pu1Byte				cliBuf=pBtCoexist->cliBuf;
 	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
 	u4Byte				u4Tmp[4];
-	BOOLEAN				bRoam=FALSE, bScan=FALSE, bLink=FALSE, bWifiUnder5G=FALSE;
-	BOOLEAN				bBtHsOn=FALSE, bWifiBusy=FALSE;
-	s4Byte				wifiRssi=0, btHsRssi=0;
-	u4Byte				wifiBw, wifiTrafficDir;
-	u1Byte				wifiDot11Chnl, wifiHsChnl;
 	u4Byte				fwVer=0, btPatchVer=0;
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
 	CL_PRINTF(cliBuf);
 
-	if(!pBoardInfo->bBtExist)
-	{
-		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n BT not exists !!!");
-		CL_PRINTF(cliBuf);
-		return;
-	}
-
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
 		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
 	CL_PRINTF(cliBuf);	
@@ -3690,39 +3597,17 @@ EXhalbtc8821a2ant_DisplayCoexInfo(
 		GLCoexVerDate8821a2Ant, GLCoexVer8821a2Ant, fwVer, btPatchVer, btPatchVer);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiDot11Chnl);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsMode(HsChnl)", \
-		wifiDot11Chnl, bBtHsOn, wifiHsChnl);
-	CL_PRINTF(cliBuf);
-
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "H2C Wifi inform bt chnl Info", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
 		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
 		pCoexDm->wifiChnlInfo[2]);
 	CL_PRINTF(cliBuf);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
-		wifiRssi, btHsRssi);
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
 	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
 
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
-		bLink, bRoam, bScan);
-	CL_PRINTF(cliBuf);
-
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
-	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s ", "Wifi status", \
-		(bWifiUnder5G? "5G":"2.4G"),
-		((BTC_WIFI_BW_LEGACY==wifiBw)? "Legacy": (((BTC_WIFI_BW_HT40==wifiBw)? "HT40":"HT20"))),
-		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")));
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
 	CL_PRINTF(cliBuf);
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
@@ -3757,17 +3642,11 @@ EXhalbtc8821a2ant_DisplayCoexInfo(
 		}
 	}
 
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s/%s", "PS state, IPS/LPS", \
-		((pCoexSta->bUnderIps? "IPS ON":"IPS OFF")),
-		((pCoexSta->bUnderLps? "LPS ON":"LPS OFF")));
-	CL_PRINTF(cliBuf);
-	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_FW_PWR_MODE_CMD);
-
 	// Sw mechanism	
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
 	CL_PRINTF(cliBuf);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d ", "SM1[ShRf/ LpRA/ LimDig/ btLna]", \
-		pCoexDm->bCurRfRxLpfShrink, pCoexDm->bCurLowPenaltyRa, pCoexDm->bLimitedDig, pCoexDm->bCurBtLnaConstrain);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "SM1[ShRf/ LpRA/ LimDig]", \
+		pCoexDm->bCurRfRxLpfShrink, pCoexDm->bCurLowPenaltyRa, pCoexDm->bLimitedDig);
 	CL_PRINTF(cliBuf);
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ", "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]", \
 		pCoexDm->bCurAgcTableEn, pCoexDm->bCurAdcBackOff, pCoexDm->bCurDacSwingOn, pCoexDm->curDacSwingLvl);
@@ -3856,12 +3735,6 @@ EXhalbtc8821a2ant_DisplayCoexInfo(
 		pCoexSta->lowPriorityRx, pCoexSta->lowPriorityTx);
 	CL_PRINTF(cliBuf);
 
-	// Tx mgnt queue hang or not, 0x41b should = 0xf, ex: 0xd ==>hang
-	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x41b);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "0x41b (mgntQ hang chk == 0xf)", \
-		u1Tmp[0]);
-	CL_PRINTF(cliBuf);	
-
 	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
 }
 
@@ -4000,11 +3873,11 @@ EXhalbtc8821a2ant_BtInfoNotify(
 {
 	u1Byte			btInfo=0;
 	u1Byte			i, rspSource=0;
-	static u4Byte		setBtLnaCnt=0, setBtPsdMode=0;
 	BOOLEAN			bBtBusy=FALSE, bLimitedDig=FALSE;
-	BOOLEAN			bWifiConnected=FALSE, bBtHsOn=FALSE;
+	BOOLEAN			bWifiConnected=FALSE, bBtHsOn=FALSE, bWifiUnder5G=FALSE;
 
 	pCoexSta->bC2hBtInfoReqSent = FALSE;
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
 
 	rspSource = tmpBuf[0]&0xf;
 	if(rspSource >= BT_INFO_SRC_8821A_2ANT_MAX)
@@ -4027,6 +3900,7 @@ EXhalbtc8821a2ant_BtInfoNotify(
 		}
 	}
 
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
 	if(BT_INFO_SRC_8821A_2ANT_WIFI_FW != rspSource)
 	{
 		pCoexSta->btRetryCnt =	// [3:0]
@@ -4037,12 +3911,12 @@ EXhalbtc8821a2ant_BtInfoNotify(
 
 		pCoexSta->btInfoExt = 
 			pCoexSta->btInfoC2h[rspSource][4];
-
+		
 		// Here we need to resend some wifi info to BT
 		// because bt is reset and loss of the info.
 		if( (pCoexSta->btInfoExt & BIT1) )
 		{			
-			pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+			
 			if(bWifiConnected)
 			{
 				EXhalbtc8821a2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_CONNECT);
@@ -4051,42 +3925,28 @@ EXhalbtc8821a2ant_BtInfoNotify(
 			{
 				EXhalbtc8821a2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
 			}
-
-			setBtPsdMode = 0;
 		}
-		if(setBtPsdMode <= 3)
-		{
-			halbtc8821a2ant_SetBtPsdMode(pBtCoexist, FORCE_EXEC, 0x0); //fix CH-BW mode 
-			setBtPsdMode++;
-		}
-		
-		if(pCoexDm->bCurBtLnaConstrain)
+
+		if(!pBtCoexist->bManualControl && !bWifiUnder5G)
 		{
-			if( (pCoexSta->btInfoExt & BIT2) )
+			if( (pCoexSta->btInfoExt&BIT3) )
 			{
+				if(bWifiConnected)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n"));
+					halbtc8821a2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, FALSE);
+				}
 			}
 			else
 			{
-				if(setBtLnaCnt <= 3)
+				// BT already NOT ignore Wlan active, do nothing here.
+				if(!bWifiConnected)
 				{
-					halbtc8821a2ant_SetBtLnaConstrain(pBtCoexist, FORCE_EXEC, TRUE);
-					setBtLnaCnt++;
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], BT ext info bit3 check, set BT to ignore Wlan active!!\n"));
+					halbtc8821a2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
 				}
 			}
 		}
-		else
-		{
-			setBtLnaCnt = 0;
-		}
-
-		if( (pCoexSta->btInfoExt & BIT3) )
-		{
-			halbtc8821a2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, FALSE);
-		}
-		else
-		{
-			// BT already NOT ignore Wlan active, do nothing here.
-		}
 
 		if( (pCoexSta->btInfoExt & BIT4) )
 		{
@@ -4185,6 +4045,25 @@ EXhalbtc8821a2ant_HaltNotify(
 	EXhalbtc8821a2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
 }
 
+VOID
+EXhalbtc8821a2ant_PnpNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				pnpState
+	)
+{
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify\n"));
+
+	if(BTC_WIFI_PNP_SLEEP == pnpState)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to SLEEP\n"));
+		halbtc8821a2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+	}
+	else if(BTC_WIFI_PNP_WAKE_UP == pnpState)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to WAKE UP\n"));
+	}
+}
+
 VOID
 EXhalbtc8821a2ant_Periodical(
 	IN	PBTC_COEXIST			pBtCoexist
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.h
index 95266a122e8d..3da55176f5ba 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821a2Ant.h
@@ -45,10 +45,6 @@ typedef struct _COEX_DM_8821A_2ANT{
 	// fw mechanism
 	BOOLEAN		bPreDecBtPwr;
 	BOOLEAN		bCurDecBtPwr;
-	BOOLEAN		bPreBtLnaConstrain;
-	BOOLEAN		bCurBtLnaConstrain;
-	u1Byte		bPreBtPsdMode;
-	u1Byte		bCurBtPsdMode;
 	u1Byte		preFwDacSwingLvl;
 	u1Byte		curFwDacSwingLvl;
 	BOOLEAN		bCurIgnoreWlanAct;
@@ -122,10 +118,15 @@ typedef struct _COEX_STA_8821A_2ANT{
 // The following is interface which will notify coex module.
 //===========================================
 VOID
-EXhalbtc8821a2ant_InitHwConfig(
+EXhalbtc8821a2ant_PowerOnSetting(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtc8821a2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtc8821a2ant_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
@@ -170,6 +171,11 @@ EXhalbtc8821a2ant_HaltNotify(
 	IN	PBTC_COEXIST			pBtCoexist
 	);
 VOID
+EXhalbtc8821a2ant_PnpNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				pnpState
+	);
+VOID
 EXhalbtc8821a2ant_Periodical(
 	IN	PBTC_COEXIST			pBtCoexist
 	);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.c
new file mode 100644
index 000000000000..824b8fbb0f69
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.c
@@ -0,0 +1,4398 @@
+//============================================================
+// Description:
+//
+// This file is for RTL8821A_CSR Co-exist mechanism
+//
+// History
+// 2012/08/22 Cosa first check in.
+// 2012/11/14 Cosa Revise for 8821A_CSR 2Ant out sourcing.
+//
+//============================================================
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+
+#define _BTCOEX_CSR 1
+
+#ifndef rtw_warn_on
+	#define rtw_warn_on(condition) do {} while (0)
+#endif
+
+#if(BT_30_SUPPORT == 1)
+//============================================================
+// Global variables, these are static variables
+//============================================================
+static COEX_DM_8821A_CSR_2ANT	GLCoexDm8821aCsr2Ant;
+static PCOEX_DM_8821A_CSR_2ANT 	pCoexDm=&GLCoexDm8821aCsr2Ant;
+static COEX_STA_8821A_CSR_2ANT	GLCoexSta8821aCsr2Ant;
+static PCOEX_STA_8821A_CSR_2ANT	pCoexSta=&GLCoexSta8821aCsr2Ant;
+
+const char *const GLBtInfoSrc8821aCsr2Ant[]={
+	"BT Info[wifi fw]",
+	"BT Info[bt rsp]",
+	"BT Info[bt auto report]",
+};
+
+u4Byte	GLCoexVerDate8821aCsr2Ant=20130618;
+u4Byte	GLCoexVer8821aCsr2Ant=0x5050;
+
+//============================================================
+// local function proto type if needed
+//============================================================
+//============================================================
+// local function start with halbtc8821aCsr2ant_
+//============================================================
+u1Byte
+halbtc8821aCsr2ant_BtRssiState(
+	u1Byte			levelNum,
+	u1Byte			rssiThresh,
+	u1Byte			rssiThresh1
+	)
+{
+	s4Byte			btRssi=0;
+	u1Byte			btRssiState=pCoexSta->preBtRssiState;
+
+	btRssi = pCoexSta->btRssi;
+
+	if(levelNum == 2)
+	{			
+		if( (pCoexSta->preBtRssiState == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preBtRssiState == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(btRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+			{
+				btRssiState = BTC_RSSI_STATE_HIGH;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state switch to High\n"));
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_LOW;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state stay at Low\n"));
+			}
+		}
+		else
+		{
+			if(btRssi < rssiThresh)
+			{
+				btRssiState = BTC_RSSI_STATE_LOW;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state switch to Low\n"));
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_HIGH;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state stay at High\n"));
+			}
+		}
+	}
+	else if(levelNum == 3)
+	{
+		if(rssiThresh > rssiThresh1)
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi thresh error!!\n"));
+			return pCoexSta->preBtRssiState;
+		}
+		
+		if( (pCoexSta->preBtRssiState == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preBtRssiState == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(btRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+			{
+				btRssiState = BTC_RSSI_STATE_MEDIUM;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state switch to Medium\n"));
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_LOW;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state stay at Low\n"));
+			}
+		}
+		else if( (pCoexSta->preBtRssiState == BTC_RSSI_STATE_MEDIUM) ||
+			(pCoexSta->preBtRssiState == BTC_RSSI_STATE_STAY_MEDIUM))
+		{
+			if(btRssi >= (rssiThresh1+BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+			{
+				btRssiState = BTC_RSSI_STATE_HIGH;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state switch to High\n"));
+			}
+			else if(btRssi < rssiThresh)
+			{
+				btRssiState = BTC_RSSI_STATE_LOW;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state switch to Low\n"));
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_MEDIUM;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state stay at Medium\n"));
+			}
+		}
+		else
+		{
+			if(btRssi < rssiThresh1)
+			{
+				btRssiState = BTC_RSSI_STATE_MEDIUM;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state switch to Medium\n"));
+			}
+			else
+			{
+				btRssiState = BTC_RSSI_STATE_STAY_HIGH;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_RSSI_STATE, ("[BTCoex], BT Rssi state stay at High\n"));
+			}
+		}
+	}
+		
+	pCoexSta->preBtRssiState = btRssiState;
+
+	return btRssiState;
+}
+
+u1Byte
+halbtc8821aCsr2ant_WifiRssiState(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			index,
+	IN	u1Byte			levelNum,
+	IN	u1Byte			rssiThresh,
+	IN	u1Byte			rssiThresh1
+	)
+{
+	s4Byte			wifiRssi=0;
+	u1Byte			wifiRssiState=pCoexSta->preWifiRssiState[index];
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+	
+	if(levelNum == 2)
+	{
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state switch to High\n"));
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state stay at Low\n"));
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state switch to Low\n"));
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state stay at High\n"));
+			}
+		}
+	}
+	else if(levelNum == 3)
+	{
+		if(rssiThresh > rssiThresh1)
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI thresh error!!\n"));
+			return pCoexSta->preWifiRssiState[index];
+		}
+		
+		if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_LOW) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_LOW))
+		{
+			if(wifiRssi >= (rssiThresh+BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state switch to Medium\n"));
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_LOW;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state stay at Low\n"));
+			}
+		}
+		else if( (pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_MEDIUM) ||
+			(pCoexSta->preWifiRssiState[index] == BTC_RSSI_STATE_STAY_MEDIUM))
+		{
+			if(wifiRssi >= (rssiThresh1+BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT))
+			{
+				wifiRssiState = BTC_RSSI_STATE_HIGH;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state switch to High\n"));
+			}
+			else if(wifiRssi < rssiThresh)
+			{
+				wifiRssiState = BTC_RSSI_STATE_LOW;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state switch to Low\n"));
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_MEDIUM;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state stay at Medium\n"));
+			}
+		}
+		else
+		{
+			if(wifiRssi < rssiThresh1)
+			{
+				wifiRssiState = BTC_RSSI_STATE_MEDIUM;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state switch to Medium\n"));
+			}
+			else
+			{
+				wifiRssiState = BTC_RSSI_STATE_STAY_HIGH;
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_WIFI_RSSI_STATE, ("[BTCoex], wifi RSSI state stay at High\n"));
+			}
+		}
+	}
+		
+	pCoexSta->preWifiRssiState[index] = wifiRssiState;
+
+	return wifiRssiState;
+}
+
+VOID
+halbtc8821aCsr2ant_MonitorBtEnableDisable(
+	IN 	PBTC_COEXIST		pBtCoexist
+	)
+{
+	static BOOLEAN	bPreBtDisabled=FALSE;
+	static u4Byte	btDisableCnt=0;
+	BOOLEAN			bBtActive=TRUE, bBtDisabled=FALSE;
+
+	// This function check if bt is disabled
+
+	if(	pCoexSta->highPriorityTx == 0 &&
+		pCoexSta->highPriorityRx == 0 &&
+		pCoexSta->lowPriorityTx == 0 &&
+		pCoexSta->lowPriorityRx == 0)
+	{
+		bBtActive = FALSE;
+	}
+	if(	pCoexSta->highPriorityTx == 0xffff &&
+		pCoexSta->highPriorityRx == 0xffff &&
+		pCoexSta->lowPriorityTx == 0xffff &&
+		pCoexSta->lowPriorityRx == 0xffff)
+	{
+		bBtActive = FALSE;
+	}
+	if(bBtActive)
+	{
+		btDisableCnt = 0;
+		bBtDisabled = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_MONITOR, ("[BTCoex], BT is enabled !!\n"));
+	}
+	else
+	{
+		btDisableCnt++;
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_MONITOR, ("[BTCoex], bt all counters=0, %d times!!\n", 
+				btDisableCnt));
+		if(btDisableCnt >= 2)
+		{
+			bBtDisabled = TRUE;
+			pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_DISABLE, &bBtDisabled);
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_MONITOR, ("[BTCoex], BT is disabled !!\n"));
+		}
+	}
+	if(bPreBtDisabled != bBtDisabled)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_MONITOR, ("[BTCoex], BT is from %s to %s!!\n", 
+			(bPreBtDisabled ? "disabled":"enabled"), 
+			(bBtDisabled ? "disabled":"enabled")));
+		bPreBtDisabled = bBtDisabled;
+		if(!bBtDisabled)
+		{
+		}
+		else
+		{
+		}
+	}
+}
+
+VOID
+halbtc8821aCsr2ant_MonitorBtCtr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u4Byte 			regHPTxRx, regLPTxRx, u4Tmp;
+	u4Byte			regHPTx=0, regHPRx=0, regLPTx=0, regLPRx=0;
+	u1Byte			u1Tmp;
+	
+	regHPTxRx = 0x770;
+	regLPTxRx = 0x774;
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, regHPTxRx);
+	regHPTx = u4Tmp & bMaskLWord;
+	regHPRx = (u4Tmp & bMaskHWord)>>16;
+
+	u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, regLPTxRx);
+	regLPTx = u4Tmp & bMaskLWord;
+	regLPRx = (u4Tmp & bMaskHWord)>>16;
+		
+	pCoexSta->highPriorityTx = regHPTx;
+	pCoexSta->highPriorityRx = regHPRx;
+	pCoexSta->lowPriorityTx = regLPTx;
+	pCoexSta->lowPriorityRx = regLPRx;
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_MONITOR, ("[BTCoex], High Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n", 
+		regHPTxRx, regHPTx, regHPTx, regHPRx, regHPRx));
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_BT_MONITOR, ("[BTCoex], Low Priority Tx/Rx (reg 0x%x)=0x%x(%d)/0x%x(%d)\n", 
+		regLPTxRx, regLPTx, regLPTx, regLPRx, regLPRx));
+
+	// reset counter
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0x5d);
+}
+
+VOID
+halbtc8821aCsr2ant_UpdateRaMask(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	u4Byte				disRateMask
+	)
+{
+	pCoexDm->curRaMask = disRateMask;
+	
+	if( bForceExec || (pCoexDm->preRaMask != pCoexDm->curRaMask))
+	{
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_UPDATE_RAMASK, &pCoexDm->curRaMask);
+	}
+	pCoexDm->preRaMask = pCoexDm->curRaMask;
+}
+
+VOID
+halbtc8821aCsr2ant_AutoRateFallbackRetry(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	u1Byte				type
+	)
+{
+	BOOLEAN	bWifiUnderBMode=FALSE;
+	
+	pCoexDm->curArfrType = type;
+
+	if( bForceExec || (pCoexDm->preArfrType != pCoexDm->curArfrType))
+	{
+		switch(pCoexDm->curArfrType)
+		{
+			case 0:	// normal mode
+				pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x430, pCoexDm->backupArfrCnt1);
+				pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x434, pCoexDm->backupArfrCnt2);
+				break;
+			case 1:	
+				pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_B_MODE, &bWifiUnderBMode);
+				if(bWifiUnderBMode)
+				{
+					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x430, 0x0);
+					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x434, 0x01010101);
+				}
+				else
+				{
+					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x430, 0x0);
+					pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x434, 0x04030201);
+				}
+				break;
+			default:
+				break;
+		}
+	}
+
+	pCoexDm->preArfrType = pCoexDm->curArfrType;
+}
+
+VOID
+halbtc8821aCsr2ant_RetryLimit(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	u1Byte				type
+	)
+{
+	pCoexDm->curRetryLimitType = type;
+
+	if( bForceExec || (pCoexDm->preRetryLimitType != pCoexDm->curRetryLimitType))
+	{
+		switch(pCoexDm->curRetryLimitType)
+		{
+			case 0:	// normal mode
+				pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x42a, pCoexDm->backupRetryLimit);
+				break;
+			case 1:	// retry limit=8
+				pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x42a, 0x0808);
+				break;
+			default:
+				break;
+		}
+	}
+
+	pCoexDm->preRetryLimitType = pCoexDm->curRetryLimitType;
+}
+
+VOID
+halbtc8821aCsr2ant_AmpduMaxTime(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	u1Byte				type
+	)
+{
+	pCoexDm->curAmpduTimeType = type;
+
+	if( bForceExec || (pCoexDm->preAmpduTimeType != pCoexDm->curAmpduTimeType))
+	{
+		switch(pCoexDm->curAmpduTimeType)
+		{
+			case 0:	// normal mode
+				pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x456, pCoexDm->backupAmpduMaxTime);
+				break;
+			case 1:	// AMPDU timw = 0x38 * 32us
+				pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x456, 0x38);
+				break;
+			case 2: 
+				pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x456, 0x17);
+				break;
+			default:
+				break;
+		}
+	}
+
+	pCoexDm->preAmpduTimeType = pCoexDm->curAmpduTimeType;
+}
+
+VOID
+halbtc8821aCsr2Ant_AmpduMaxNum(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	u1Byte				type
+	)
+{
+	pCoexDm->curAmpduNumType = type;
+
+	if( bForceExec || (pCoexDm->preAmpduNumType != pCoexDm->curAmpduNumType))
+	{
+		switch(pCoexDm->curAmpduNumType)
+		{
+			case 0:	// normal mode
+				pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x4ca, pCoexDm->backupAmpduMaxNum);
+				break;
+			case 1:
+				pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x4ca, 0x0808);
+				break;
+			case 2: 
+				pBtCoexist->fBtcWrite2Byte(pBtCoexist, 0x4ca, 0x1f1f);
+				break;
+			default:
+				break;
+		}
+	}
+
+	pCoexDm->preAmpduNumType = pCoexDm->curAmpduNumType;
+
+}
+
+VOID
+halbtc8821aCsr2ant_LimitedTx(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	u1Byte				raMaskType,
+	IN	u1Byte				arfrType,
+	IN	u1Byte				retryLimitType,
+	IN	u1Byte				ampduTimeType,
+	IN	u1Byte				ampduNumType
+	)
+{
+	switch(raMaskType)
+	{
+		case 0:	// normal mode
+			halbtc8821aCsr2ant_UpdateRaMask(pBtCoexist, bForceExec, 0x0);
+			break;
+		case 1:	// disable cck 1/2
+			halbtc8821aCsr2ant_UpdateRaMask(pBtCoexist, bForceExec, 0x00000003);
+			break;
+		case 2:	// disable cck 1/2/5.5, ofdm 6/9/12/18/24, mcs 0/1/2/3/4
+			halbtc8821aCsr2ant_UpdateRaMask(pBtCoexist, bForceExec, 0x0001f1f7);
+			break;
+		default:
+			break;
+	}
+
+	halbtc8821aCsr2ant_AutoRateFallbackRetry(pBtCoexist, bForceExec, arfrType);
+	halbtc8821aCsr2ant_RetryLimit(pBtCoexist, bForceExec, retryLimitType);
+	halbtc8821aCsr2ant_AmpduMaxTime(pBtCoexist, bForceExec, ampduTimeType);
+	halbtc8821aCsr2Ant_AmpduMaxNum(pBtCoexist, bForceExec, ampduNumType);
+}
+
+
+
+VOID
+halbtc8821aCsr2ant_LimitedRx(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bForceExec,
+	IN	BOOLEAN				bRejApAggPkt,
+	IN	BOOLEAN				bBtCtrlAggBufSize,
+	IN	u1Byte				aggBufSize
+	)
+{
+	BOOLEAN	bRejectRxAgg=bRejApAggPkt;
+	BOOLEAN	bBtCtrlRxAggSize=bBtCtrlAggBufSize;
+	u1Byte	rxAggSize=aggBufSize;
+
+	//============================================
+	//	Rx Aggregation related setting
+	//============================================
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_TO_REJ_AP_AGG_PKT, &bRejectRxAgg);
+	// decide BT control aggregation buf size or not
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_CTRL_AGG_SIZE, &bBtCtrlRxAggSize);
+	// aggregation buf size, only work when BT control Rx aggregation size.
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_AGG_BUF_SIZE, &rxAggSize);
+	// real update aggregation setting
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_AGGREGATE_CTRL, NULL);
+}
+
+VOID
+halbtc8821aCsr2ant_QueryBtInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+
+	pCoexSta->bC2hBtInfoReqSent = TRUE;
+
+	H2C_Parameter[0] |= BIT0;	// trigger
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], Query Bt Info, FW write 0x61=0x%x\n", 
+		H2C_Parameter[0]));
+
+	rtw_warn_on(_BTCOEX_CSR);
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x61, 1, H2C_Parameter);
+}
+
+u1Byte
+halbtc8821aCsr2ant_ActionAlgorithm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	BOOLEAN				bBtHsOn=FALSE;
+	u1Byte				algorithm=BT_8821A_CSR_2ANT_COEX_ALGO_UNDEFINED;
+	u1Byte				numOfDiffProfile=0;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	//sync StackInfo with BT firmware and stack
+	pStackInfo->bHidExist = pCoexSta->bHidExist;
+	pStackInfo->bBtLinkExist = pCoexSta->bBtLinkExist;
+	pStackInfo->bScoExist = pCoexSta->bScoExist;
+	pStackInfo->bPanExist = pCoexSta->bPanExist;
+	pStackInfo->bA2dpExist = pCoexSta->bA2dpExist;
+
+	if(!pStackInfo->bBtLinkExist)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], No profile exists!!!\n"));
+		return algorithm;
+	}
+
+	if(pStackInfo->bScoExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bHidExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bPanExist)
+		numOfDiffProfile++;
+	if(pStackInfo->bA2dpExist)
+		numOfDiffProfile++;
+	
+	if(numOfDiffProfile == 1)
+	{
+		if(pStackInfo->bScoExist)
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO only\n"));
+			algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_SCO;
+		}
+		else
+		{
+			if(pStackInfo->bHidExist)
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], HID only\n"));
+				algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_HID;
+			}
+			else if(pStackInfo->bA2dpExist)
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], A2DP only\n"));
+				algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_A2DP;
+			}
+			else if(pStackInfo->bPanExist)
+			{
+				if(bBtHsOn)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], PAN(HS) only\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANHS;
+				}
+				else
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], PAN(EDR) only\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR;
+				}
+			}
+		}
+	}
+	else if(numOfDiffProfile == 2)
+	{
+		if(pStackInfo->bScoExist)
+		{
+			if(pStackInfo->bHidExist)
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + HID\n"));
+				algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+			}
+			else if(pStackInfo->bA2dpExist)
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + A2DP ==> SCO\n"));
+				algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+			}
+			else if(pStackInfo->bPanExist)
+			{
+				if(bBtHsOn)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + PAN(HS)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_SCO;
+				}
+				else
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + PAN(EDR)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+		else
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bA2dpExist )
+			{
+				if(pStackInfo->numOfHid >= 2)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], HID*2 + A2DP\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+				else
+				{			
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], HID + A2DP\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP;
+				}
+			}
+			else if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist )
+			{
+				if(bBtHsOn)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], HID + PAN(HS)\n"));
+					algorithm =  BT_8821A_CSR_2ANT_COEX_ALGO_HID;
+				}
+				else
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], HID + PAN(EDR)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+			else if( pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], A2DP + PAN(HS)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_A2DP_PANHS;
+				}
+				else
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], A2DP + PAN(EDR)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_A2DP;
+				}
+			}
+		}
+	}
+	else if(numOfDiffProfile == 3)
+	{
+		if(pStackInfo->bScoExist)
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bA2dpExist )
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + HID + A2DP ==> HID\n"));
+				algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+			}
+			else if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist )
+			{
+				if(bBtHsOn)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + HID + PAN(HS)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+				else
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + HID + PAN(EDR)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+			else if( pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + A2DP + PAN(HS)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+				else
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + A2DP + PAN(EDR) ==> HID\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+		else
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], HID + A2DP + PAN(HS)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP;
+				}
+				else
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], HID + A2DP + PAN(EDR)\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP_PANEDR;
+				}
+			}
+		}
+	}
+	else if(numOfDiffProfile >= 3)
+	{
+		if(pStackInfo->bScoExist)
+		{
+			if( pStackInfo->bHidExist &&
+				pStackInfo->bPanExist &&
+				pStackInfo->bA2dpExist )
+			{
+				if(bBtHsOn)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Error!!! SCO + HID + A2DP + PAN(HS)\n"));
+
+				}
+				else
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], SCO + HID + A2DP + PAN(EDR)==>PAN(EDR)+HID\n"));
+					algorithm = BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID;
+				}
+			}
+		}
+	}
+
+	return algorithm;
+}
+
+BOOLEAN
+halbtc8821aCsr2ant_NeedToDecBtPwr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN		bRet=FALSE;
+	BOOLEAN		bBtHsOn=FALSE, bWifiConnected=FALSE;
+	s4Byte		btHsRssi=0;
+	u1Byte 		btRssiState;
+
+	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn))
+		return FALSE;
+	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected))
+		return FALSE;
+	if(!pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi))
+		return FALSE;
+
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	if(bWifiConnected)
+	{
+		if(bBtHsOn)
+		{
+			if(btHsRssi > 37)
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], Need to decrease bt power for HS mode!!\n"));
+				bRet = TRUE;
+			}
+		}
+		else
+		{
+			if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+			{
+		
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], Need to decrease bt power for Wifi is connected!!\n"));
+				bRet = TRUE;
+			}
+		}
+	}
+	
+	return bRet;
+}
+
+VOID
+halbtc8821aCsr2ant_SetFwDacSwingLevel(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			dacSwingLvl
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+
+	// There are several type of dacswing
+	// 0x18/ 0x10/ 0xc/ 0x8/ 0x4/ 0x6
+	H2C_Parameter[0] = dacSwingLvl;
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], Set Dac Swing Level=0x%x\n", dacSwingLvl));
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], FW write 0x64=0x%x\n", H2C_Parameter[0]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x64, 1, H2C_Parameter);
+}
+
+VOID
+halbtc8821aCsr2ant_SetFwDecBtPwr(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bDecBtPwr
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+	
+	H2C_Parameter[0] = 0;
+
+	if(bDecBtPwr)
+	{
+		H2C_Parameter[0] |= BIT1;
+	}
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], decrease Bt Power : %s, FW write 0x62=0x%x\n", 
+		(bDecBtPwr? "Yes!!":"No!!"), H2C_Parameter[0]));
+
+	rtw_warn_on(_BTCOEX_CSR);
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x62, 1, H2C_Parameter);	
+}
+
+VOID
+halbtc8821aCsr2ant_DecBtPwr(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bDecBtPwr
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s Dec BT power = %s\n",  
+		(bForceExec? "force to":""), ((bDecBtPwr)? "ON":"OFF")));
+	pCoexDm->bCurDecBtPwr = bDecBtPwr;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], bPreDecBtPwr=%d, bCurDecBtPwr=%d\n", 
+			pCoexDm->bPreDecBtPwr, pCoexDm->bCurDecBtPwr));
+
+		if(pCoexDm->bPreDecBtPwr == pCoexDm->bCurDecBtPwr) 
+			return;
+	}
+
+	/* TODO: may CSR consider to decrease BT power? */
+	//halbtc8821aCsr2ant_SetFwDecBtPwr(pBtCoexist, pCoexDm->bCurDecBtPwr);
+
+	pCoexDm->bPreDecBtPwr = pCoexDm->bCurDecBtPwr;
+}
+
+VOID
+halbtc8821aCsr2ant_SetBtAutoReport(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bEnableAutoReport
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+	
+	H2C_Parameter[0] = 0;
+
+	if(bEnableAutoReport)
+	{
+		H2C_Parameter[0] |= BIT0;
+	}
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], BT FW auto report : %s, FW write 0x68=0x%x\n", 
+		(bEnableAutoReport? "Enabled!!":"Disabled!!"), H2C_Parameter[0]));
+
+	rtw_warn_on(_BTCOEX_CSR);
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x68, 1, H2C_Parameter);	
+}
+
+VOID
+halbtc8821aCsr2ant_BtAutoReport(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bEnableAutoReport
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s BT Auto report = %s\n",  
+		(bForceExec? "force to":""), ((bEnableAutoReport)? "Enabled":"Disabled")));
+	pCoexDm->bCurBtAutoReport = bEnableAutoReport;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], bPreBtAutoReport=%d, bCurBtAutoReport=%d\n", 
+			pCoexDm->bPreBtAutoReport, pCoexDm->bCurBtAutoReport));
+
+		if(pCoexDm->bPreBtAutoReport == pCoexDm->bCurBtAutoReport) 
+			return;
+	}
+	//halbtc8821aCsr2ant_SetBtAutoReport(pBtCoexist, pCoexDm->bCurBtAutoReport);
+
+	pCoexDm->bPreBtAutoReport = pCoexDm->bCurBtAutoReport;
+}
+
+VOID
+halbtc8821aCsr2ant_FwDacSwingLvl(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u1Byte			fwDacSwingLvl
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s set FW Dac Swing level = %d\n",  
+		(bForceExec? "force to":""), fwDacSwingLvl));
+	pCoexDm->curFwDacSwingLvl = fwDacSwingLvl;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], preFwDacSwingLvl=%d, curFwDacSwingLvl=%d\n", 
+			pCoexDm->preFwDacSwingLvl, pCoexDm->curFwDacSwingLvl));
+
+		if(pCoexDm->preFwDacSwingLvl == pCoexDm->curFwDacSwingLvl) 
+			return;
+	}
+
+	halbtc8821aCsr2ant_SetFwDacSwingLevel(pBtCoexist, pCoexDm->curFwDacSwingLvl);
+
+	pCoexDm->preFwDacSwingLvl = pCoexDm->curFwDacSwingLvl;
+}
+
+VOID
+halbtc8821aCsr2ant_SetSwRfRxLpfCorner(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	if(bRxRfShrinkOn)
+	{
+		//Shrink RF Rx LPF corner
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], Shrink RF Rx LPF corner!!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, 0xffffc);
+	}
+	else
+	{
+		//Resume RF Rx LPF corner
+		// After initialized, we can use pCoexDm->btRf0x1eBackup
+		if(pBtCoexist->bInitilized)
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], Resume RF Rx LPF corner!!\n"));
+			pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff, pCoexDm->btRf0x1eBackup);
+		}
+	}
+}
+
+VOID
+halbtc8821aCsr2ant_RfShrink(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bRxRfShrinkOn
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW, ("[BTCoex], %s turn Rx RF Shrink = %s\n",  
+		(bForceExec? "force to":""), ((bRxRfShrinkOn)? "ON":"OFF")));
+	pCoexDm->bCurRfRxLpfShrink = bRxRfShrinkOn;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL, ("[BTCoex], bPreRfRxLpfShrink=%d, bCurRfRxLpfShrink=%d\n", 
+			pCoexDm->bPreRfRxLpfShrink, pCoexDm->bCurRfRxLpfShrink));
+
+		if(pCoexDm->bPreRfRxLpfShrink == pCoexDm->bCurRfRxLpfShrink) 
+			return;
+	}
+	halbtc8821aCsr2ant_SetSwRfRxLpfCorner(pBtCoexist, pCoexDm->bCurRfRxLpfShrink);
+
+	pCoexDm->bPreRfRxLpfShrink = pCoexDm->bCurRfRxLpfShrink;
+}
+
+VOID
+halbtc8821aCsr2ant_SetSwPenaltyTxRateAdaptive(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	u1Byte			H2C_Parameter[6] ={0};
+	
+	H2C_Parameter[0] = 0x6;	// opCode, 0x6= Retry_Penalty
+
+	if(bLowPenaltyRa)
+	{
+		H2C_Parameter[1] |= BIT0;
+		H2C_Parameter[2] = 0x00;  //normal rate except MCS7/6/5, OFDM54/48/36
+		H2C_Parameter[3] = 0xf7;  //MCS7 or OFDM54
+		H2C_Parameter[4] = 0xf8;  //MCS6 or OFDM48
+		H2C_Parameter[5] = 0xf9;	//MCS5 or OFDM36	
+	}
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], set WiFi Low-Penalty Retry: %s", 
+		(bLowPenaltyRa? "ON!!":"OFF!!") ));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x69, 6, H2C_Parameter);
+}
+
+VOID
+halbtc8821aCsr2ant_LowPenaltyRa(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bLowPenaltyRa
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW, ("[BTCoex], %s turn LowPenaltyRA = %s\n",  
+		(bForceExec? "force to":""), ((bLowPenaltyRa)? "ON":"OFF")));
+	pCoexDm->bCurLowPenaltyRa = bLowPenaltyRa;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL, ("[BTCoex], bPreLowPenaltyRa=%d, bCurLowPenaltyRa=%d\n", 
+			pCoexDm->bPreLowPenaltyRa, pCoexDm->bCurLowPenaltyRa));
+
+		if(pCoexDm->bPreLowPenaltyRa == pCoexDm->bCurLowPenaltyRa) 
+			return;
+	}
+	halbtc8821aCsr2ant_SetSwPenaltyTxRateAdaptive(pBtCoexist, pCoexDm->bCurLowPenaltyRa);
+
+	pCoexDm->bPreLowPenaltyRa = pCoexDm->bCurLowPenaltyRa;
+}
+
+VOID
+halbtc8821aCsr2ant_SetDacSwingReg(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u4Byte			level
+	)
+{
+	u1Byte	val=(u1Byte)level;
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], Write SwDacSwing = 0x%x\n", level));
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xc5b, 0x3e, val);
+}
+
+VOID
+halbtc8821aCsr2ant_SetSwFullTimeDacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bSwDacSwingOn,
+	IN	u4Byte			swDacSwingLvl
+	)
+{
+	if(bSwDacSwingOn)
+	{
+		halbtc8821aCsr2ant_SetDacSwingReg(pBtCoexist, swDacSwingLvl);
+	}
+	else
+	{
+		halbtc8821aCsr2ant_SetDacSwingReg(pBtCoexist, 0x18);
+	}
+}
+
+
+VOID
+halbtc8821aCsr2ant_DacSwing(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bDacSwingOn,
+	IN	u4Byte			dacSwingLvl
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW, ("[BTCoex], %s turn DacSwing=%s, dacSwingLvl=0x%x\n",  
+		(bForceExec? "force to":""), ((bDacSwingOn)? "ON":"OFF"), dacSwingLvl));
+	pCoexDm->bCurDacSwingOn = bDacSwingOn;
+	pCoexDm->curDacSwingLvl = dacSwingLvl;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL, ("[BTCoex], bPreDacSwingOn=%d, preDacSwingLvl=0x%x, bCurDacSwingOn=%d, curDacSwingLvl=0x%x\n", 
+			pCoexDm->bPreDacSwingOn, pCoexDm->preDacSwingLvl,
+			pCoexDm->bCurDacSwingOn, pCoexDm->curDacSwingLvl));
+
+		if( (pCoexDm->bPreDacSwingOn == pCoexDm->bCurDacSwingOn) &&
+			(pCoexDm->preDacSwingLvl == pCoexDm->curDacSwingLvl) )
+			return;
+	}
+	delay_ms(30);
+	halbtc8821aCsr2ant_SetSwFullTimeDacSwing(pBtCoexist, bDacSwingOn, dacSwingLvl);
+
+	pCoexDm->bPreDacSwingOn = pCoexDm->bCurDacSwingOn;
+	pCoexDm->preDacSwingLvl = pCoexDm->curDacSwingLvl;
+}
+
+VOID
+halbtc8821aCsr2ant_SetAdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	if(bAdcBackOff)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], BB BackOff Level On!\n"));
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x8db, 0x60, 0x3);
+	}
+	else
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], BB BackOff Level Off!\n"));
+		pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x8db, 0x60, 0x1);
+	}
+}
+
+VOID
+halbtc8821aCsr2ant_AdcBackOff(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAdcBackOff
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW, ("[BTCoex], %s turn AdcBackOff = %s\n",  
+		(bForceExec? "force to":""), ((bAdcBackOff)? "ON":"OFF")));
+	pCoexDm->bCurAdcBackOff = bAdcBackOff;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL, ("[BTCoex], bPreAdcBackOff=%d, bCurAdcBackOff=%d\n", 
+			pCoexDm->bPreAdcBackOff, pCoexDm->bCurAdcBackOff));
+
+		if(pCoexDm->bPreAdcBackOff == pCoexDm->bCurAdcBackOff) 
+			return;
+	}
+	halbtc8821aCsr2ant_SetAdcBackOff(pBtCoexist, pCoexDm->bCurAdcBackOff);
+
+	pCoexDm->bPreAdcBackOff = pCoexDm->bCurAdcBackOff;
+}
+
+VOID
+halbtc8821aCsr2ant_SetAgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	u1Byte		rssiAdjustVal=0;
+
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0xef, 0xfffff, 0x02000);
+	if(bAgcTableEn)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], Agc Table On!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x3b, 0xfffff,  0x28F4B);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x3b, 0xfffff,  0x10AB2);
+		rssiAdjustVal = 8;
+	}
+	else
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], Agc Table Off!\n"));
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x3b, 0xfffff, 0x2884B);
+		pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0x3b, 0xfffff, 0x104B2);
+	}
+	pBtCoexist->fBtcSetRfReg(pBtCoexist, BTC_RF_A, 0xef, 0xfffff, 0x0);
+
+	// set rssiAdjustVal for wifi module.
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON, &rssiAdjustVal);
+}
+
+VOID
+halbtc8821aCsr2ant_AgcTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bAgcTableEn
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW, ("[BTCoex], %s %s Agc Table\n",  
+		(bForceExec? "force to":""), ((bAgcTableEn)? "Enable":"Disable")));
+	pCoexDm->bCurAgcTableEn = bAgcTableEn;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL, ("[BTCoex], bPreAgcTableEn=%d, bCurAgcTableEn=%d\n", 
+			pCoexDm->bPreAgcTableEn, pCoexDm->bCurAgcTableEn));
+
+		if(pCoexDm->bPreAgcTableEn == pCoexDm->bCurAgcTableEn) 
+			return;
+	}
+	halbtc8821aCsr2ant_SetAgcTable(pBtCoexist, bAgcTableEn);
+
+	pCoexDm->bPreAgcTableEn = pCoexDm->bCurAgcTableEn;
+}
+
+VOID
+halbtc8821aCsr2ant_SetCoexTable(
+	IN	PBTC_COEXIST	pBtCoexist,
+	IN	u4Byte		val0x6c0,
+	IN	u4Byte		val0x6c4,
+	IN	u4Byte		val0x6c8,
+	IN	u1Byte		val0x6cc
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], set coex table, set 0x6c0=0x%x\n", val0x6c0));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c0, val0x6c0);
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], set coex table, set 0x6c4=0x%x\n", val0x6c4));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c4, val0x6c4);
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], set coex table, set 0x6c8=0x%x\n", val0x6c8));
+	pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x6c8, val0x6c8);
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_EXEC, ("[BTCoex], set coex table, set 0x6cc=0x%x\n", val0x6cc));
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x6cc, val0x6cc);
+}
+
+VOID
+halbtc8821aCsr2ant_CoexTable(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	u4Byte			val0x6c0,
+	IN	u4Byte			val0x6c4,
+	IN	u4Byte			val0x6c8,
+	IN	u1Byte			val0x6cc
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW, ("[BTCoex], %s write Coex Table 0x6c0=0x%x, 0x6c4=0x%x, 0x6c8=0x%x, 0x6cc=0x%x\n", 
+		(bForceExec? "force to":""), val0x6c0, val0x6c4, val0x6c8, val0x6cc));
+	pCoexDm->curVal0x6c0 = val0x6c0;
+	pCoexDm->curVal0x6c4 = val0x6c4;
+	pCoexDm->curVal0x6c8 = val0x6c8;
+	pCoexDm->curVal0x6cc = val0x6cc;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL, ("[BTCoex], preVal0x6c0=0x%x, preVal0x6c4=0x%x, preVal0x6c8=0x%x, preVal0x6cc=0x%x !!\n", 
+			pCoexDm->preVal0x6c0, pCoexDm->preVal0x6c4, pCoexDm->preVal0x6c8, pCoexDm->preVal0x6cc));
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_SW_DETAIL, ("[BTCoex], curVal0x6c0=0x%x, curVal0x6c4=0x%x, curVal0x6c8=0x%x, curVal0x6cc=0x%x !!\n", 
+			pCoexDm->curVal0x6c0, pCoexDm->curVal0x6c4, pCoexDm->curVal0x6c8, pCoexDm->curVal0x6cc));
+	
+		if( (pCoexDm->preVal0x6c0 == pCoexDm->curVal0x6c0) &&
+			(pCoexDm->preVal0x6c4 == pCoexDm->curVal0x6c4) &&
+			(pCoexDm->preVal0x6c8 == pCoexDm->curVal0x6c8) &&
+			(pCoexDm->preVal0x6cc == pCoexDm->curVal0x6cc) )
+			return;
+	}
+	halbtc8821aCsr2ant_SetCoexTable(pBtCoexist, val0x6c0, val0x6c4, val0x6c8, val0x6cc);
+
+	pCoexDm->preVal0x6c0 = pCoexDm->curVal0x6c0;
+	pCoexDm->preVal0x6c4 = pCoexDm->curVal0x6c4;
+	pCoexDm->preVal0x6c8 = pCoexDm->curVal0x6c8;
+	pCoexDm->preVal0x6cc = pCoexDm->curVal0x6cc;
+}
+
+VOID
+halbtc8821aCsr2ant_SetFwIgnoreWlanAct(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bEnable
+	)
+{
+	u1Byte			H2C_Parameter[1] ={0};
+		
+	if(bEnable)
+	{
+		H2C_Parameter[0] |= BIT0;		// function enable
+	}
+	
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], set FW for BT Ignore Wlan_Act, FW write 0x63=0x%x\n", 
+		H2C_Parameter[0]));
+
+	rtw_warn_on(_BTCOEX_CSR);
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x63, 1, H2C_Parameter);
+}
+
+VOID
+halbtc8821aCsr2ant_IgnoreWlanAct(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bEnable
+	)
+{
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s turn Ignore WlanAct %s\n", 
+		(bForceExec? "force to":""), (bEnable? "ON":"OFF")));
+	pCoexDm->bCurIgnoreWlanAct = bEnable;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], bPreIgnoreWlanAct = %d, bCurIgnoreWlanAct = %d!!\n", 
+			pCoexDm->bPreIgnoreWlanAct, pCoexDm->bCurIgnoreWlanAct));
+
+		if(pCoexDm->bPreIgnoreWlanAct == pCoexDm->bCurIgnoreWlanAct)
+			return;
+	}
+	//halbtc8821aCsr2ant_SetFwIgnoreWlanAct(pBtCoexist, bEnable);
+
+	pCoexDm->bPreIgnoreWlanAct = pCoexDm->bCurIgnoreWlanAct;
+}
+
+VOID
+halbtc8821aCsr2ant_SetFwPstdma(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			byte1,
+	IN	u1Byte			byte2,
+	IN	u1Byte			byte3,
+	IN	u1Byte			byte4,
+	IN	u1Byte			byte5
+	)
+{
+	u1Byte			H2C_Parameter[6] ={0};
+
+	H2C_Parameter[0] = byte1;	
+	H2C_Parameter[1] = byte2;	
+	H2C_Parameter[2] = byte3;
+	H2C_Parameter[3] = byte4;
+	H2C_Parameter[4] = byte5;
+	H2C_Parameter[5] = 0x01;
+
+	pCoexDm->psTdmaPara[0] = byte1;
+	pCoexDm->psTdmaPara[1] = byte2;
+	pCoexDm->psTdmaPara[2] = byte3;
+	pCoexDm->psTdmaPara[3] = byte4;
+	pCoexDm->psTdmaPara[4] = byte5;
+	pCoexDm->psTdmaPara[5] = 0x01;
+	
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], FW write 0x60(6bytes)=0x%x%08x%02x\n", 
+		H2C_Parameter[0], 
+		H2C_Parameter[1]<<24|H2C_Parameter[2]<<16|H2C_Parameter[3]<<8|H2C_Parameter[4], H2C_Parameter[5]));
+
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x60, 6, H2C_Parameter);
+}
+
+VOID
+halbtc8821aCsr2ant_SwMechanism1(
+	IN	PBTC_COEXIST	pBtCoexist,	
+	IN	BOOLEAN		bShrinkRxLPF,
+	IN	BOOLEAN 	bLowPenaltyRA,
+	IN	BOOLEAN		bLimitedDIG, 
+	IN	BOOLEAN		bBTLNAConstrain
+	) 
+{
+	u4Byte	wifiBw;
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	
+	if(BTC_WIFI_BW_HT40 != wifiBw)  //only shrink RF Rx LPF for HT40
+	{
+		if (bShrinkRxLPF)
+			bShrinkRxLPF = FALSE;
+	}
+	 	
+	 halbtc8821aCsr2ant_RfShrink(pBtCoexist, NORMAL_EXEC, bShrinkRxLPF);
+	halbtc8821aCsr2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, bLowPenaltyRA);
+
+  	//no limited DIG
+	//halbtc8821aCsr2ant_SetBtLnaConstrain(pBtCoexist, NORMAL_EXEC, bBTLNAConstrain);
+}
+
+VOID
+halbtc8821aCsr2ant_SwMechanism2(
+	IN	PBTC_COEXIST	pBtCoexist,	
+	IN	BOOLEAN		bAGCTableShift,
+	IN	BOOLEAN 	bADCBackOff,
+	IN	BOOLEAN		bSWDACSwing,
+	IN	u4Byte		dacSwingLvl
+	) 
+{
+	//halbtc8821aCsr2ant_AgcTable(pBtCoexist, NORMAL_EXEC, bAGCTableShift);
+	halbtc8821aCsr2ant_AdcBackOff(pBtCoexist, NORMAL_EXEC, bADCBackOff);
+	halbtc8821aCsr2ant_DacSwing(pBtCoexist, NORMAL_EXEC, bSWDACSwing, dacSwingLvl);
+}
+
+VOID
+halbtc8821aCsr2ant_SetAntPath(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte				antPosType,
+	IN	BOOLEAN				bInitHwCfg,
+	IN	BOOLEAN				bWifiOff
+	)
+{
+	PBTC_BOARD_INFO 	pBoardInfo=&pBtCoexist->boardInfo;
+	u4Byte				u4Tmp=0;
+	u1Byte				H2C_Parameter[2] ={0};
+	
+	if(bInitHwCfg)
+	{
+		// 0x4c[23]=0, 0x4c[24]=1  Antenna control by WL/BT
+		u4Tmp = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x4c);
+		u4Tmp &=~BIT23;
+		u4Tmp |= BIT24;
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x4c, u4Tmp);
+
+		pBtCoexist->fBtcWrite4Byte(pBtCoexist, 0x974, 0x3ff);
+		pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0xcb4, 0x77);
+
+		if(pBoardInfo->btdmAntPos == BTC_ANTENNA_AT_MAIN_PORT) 
+		{
+			//tell firmware "antenna inverse"  ==> WRONG firmware antenna control code.==>need fw to fix
+			H2C_Parameter[0] = 1;
+			H2C_Parameter[1] = 1;
+			pBtCoexist->fBtcFillH2c(pBtCoexist, 0x65, 2, H2C_Parameter);
+		}
+		else
+		{
+			//tell firmware "no antenna inverse" ==> WRONG firmware antenna control code.==>need fw to fix
+			H2C_Parameter[0] = 0;
+			H2C_Parameter[1] = 1;
+			pBtCoexist->fBtcFillH2c(pBtCoexist, 0x65, 2, H2C_Parameter);
+		}
+	}
+	
+	// ext switch setting
+	switch(antPosType)
+	{
+		case BTC_ANT_WIFI_AT_MAIN:
+			pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xcb7, 0x30, 0x1);
+			break;
+		case BTC_ANT_WIFI_AT_AUX:
+			pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0xcb7, 0x30, 0x2);
+			break;
+	}
+}
+
+VOID
+halbtc8821aCsr2ant_PsTdma(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bForceExec,
+	IN	BOOLEAN			bTurnOn,
+	IN	u1Byte			type
+	)
+{
+	BOOLEAN			bTurnOnByCnt=FALSE;
+	u1Byte			psTdmaTypeByCnt=0;
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], %s turn %s PS TDMA, type=%d\n", 
+		(bForceExec? "force to":""), (bTurnOn? "ON":"OFF"), type));
+	pCoexDm->bCurPsTdmaOn = bTurnOn;
+	pCoexDm->curPsTdma = type;
+
+	if(!bForceExec)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], bPrePsTdmaOn = %d, bCurPsTdmaOn = %d!!\n", 
+			pCoexDm->bPrePsTdmaOn, pCoexDm->bCurPsTdmaOn));
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], prePsTdma = %d, curPsTdma = %d!!\n", 
+			pCoexDm->prePsTdma, pCoexDm->curPsTdma));
+
+		if( (pCoexDm->bPrePsTdmaOn == pCoexDm->bCurPsTdmaOn) &&
+			(pCoexDm->prePsTdma == pCoexDm->curPsTdma) )
+			return;
+	}	
+	if(bTurnOn)
+	{
+		switch(type)
+		{
+			case 1:
+			default:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				break;
+			case 2:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90);
+				break;
+			case 3:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0xf1, 0x90);
+				break;
+			case 4:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x10, 0x03, 0xf1, 0x90);
+				break;
+			case 5:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+				break;
+			case 6:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x90);
+				break;
+			case 7:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1c, 0x3, 0x70, 0x90);
+				break;
+			case 8:	
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xa3, 0x10, 0x3, 0x70, 0x90);
+				break;
+			case 9:	
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				break;
+			case 10:	
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0xe1, 0x90);
+				break;
+			case 11:	
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0xe1, 0x90);
+				break;
+			case 12:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0xe1, 0x90);
+				break;
+			case 13:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0x60, 0x90);
+				break;
+			case 14:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x12, 0x12, 0x60, 0x90);
+				break;
+			case 15:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0xa, 0xa, 0x60, 0x90);
+				break;
+			case 16:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0x60, 0x90);
+				break;
+			case 17:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xa3, 0x2f, 0x2f, 0x60, 0x90);
+				break;
+			case 18:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x5, 0x5, 0xe1, 0x90);
+				break;			
+			case 19:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x25, 0x25, 0xe1, 0x90);
+				break;
+			case 20:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x25, 0x25, 0x60, 0x90);
+				break;
+			case 21:	
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x15, 0x03, 0x70, 0x90);
+				break;
+			case 22:	//ad2dp master
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xeb, 0x11, 0x11, 0x21, 0x10);
+				break;
+			case 23:	//a2dp slave
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xeb, 0x12, 0x12, 0x20, 0x10);
+				break;
+			case 71:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0xe3, 0x1a, 0x1a, 0xe1, 0x90);
+				break;
+		}
+	}
+	else
+	{
+		// disable PS tdma
+		switch(type)
+		{
+			case 0:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x40, 0x0);
+				break;
+			case 1:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x48, 0x0);
+				break;
+			default:
+				halbtc8821aCsr2ant_SetFwPstdma(pBtCoexist, 0x0, 0x0, 0x0, 0x40, 0x0);
+				break;
+		}
+	}
+
+	// update pre state
+	pCoexDm->bPrePsTdmaOn = pCoexDm->bCurPsTdmaOn;
+	pCoexDm->prePsTdma = pCoexDm->curPsTdma;
+}
+
+VOID
+halbtc8821aCsr2ant_CoexAllOff(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	// fw all off
+	halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+	halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	// sw all off
+	halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+
+	// hw all off
+	halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x55555555, 0xffff, 0x3);
+}
+
+VOID
+halbtc8821aCsr2ant_CoexUnder5G(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	halbtc8821aCsr2ant_CoexAllOff(pBtCoexist);
+
+	halbtc8821aCsr2ant_IgnoreWlanAct(pBtCoexist, NORMAL_EXEC, TRUE);
+}
+
+VOID
+halbtc8821aCsr2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{	
+	// force to reset coex mechanism
+	halbtc8821aCsr2ant_CoexTable(pBtCoexist, FORCE_EXEC, 0x55555555, 0x55555555, 0xffff, 0x3);
+
+	halbtc8821aCsr2ant_PsTdma(pBtCoexist, FORCE_EXEC, FALSE, 1);
+	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, FORCE_EXEC, 6);
+	halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, FORCE_EXEC, FALSE);
+
+	halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+	halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+}
+
+VOID
+halbtc8821aCsr2ant_BtInquiryPage(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN	bLowPwrDisable=TRUE;
+	
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+
+	halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5afa5afa, 0xffff, 0x3);
+	halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+}
+BOOLEAN
+halbtc8821aCsr2ant_IsCommonAction(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BOOLEAN			bCommon=FALSE, bWifiConnected=FALSE, bWifiBusy=FALSE;
+	BOOLEAN			bLowPwrDisable=FALSE;
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+
+	if(!bWifiConnected && 
+		BT_8821A_CSR_2ANT_BT_STATUS_IDLE == pCoexDm->btStatus)
+	{
+		bLowPwrDisable = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi IPS + BT IPS!!\n"));	
+
+		
+		halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		
+ 		halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+		halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		halbtc8821aCsr2ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0, 0);
+		halbtc8821aCsr2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, 0, 0, 0);
+
+		bCommon = TRUE;
+	}
+	else if(bWifiConnected && 
+			(BT_8821A_CSR_2ANT_BT_STATUS_IDLE == pCoexDm->btStatus) )
+	{		
+		bLowPwrDisable = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+
+		if(bWifiBusy)
+		{	
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi Busy + BT IPS!!\n"));
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+		else
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi LPS + BT IPS!!\n"));
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+		
+		halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+		halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		halbtc8821aCsr2ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0, 0);
+		halbtc8821aCsr2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, 0, 0, 0);
+
+		bCommon = TRUE;
+	}
+	else if(!bWifiConnected && 
+		(BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus) )
+	{
+		bLowPwrDisable = TRUE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi IPS + BT LPS!!\n"));		
+
+		halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+		halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		halbtc8821aCsr2ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0, 0);
+		halbtc8821aCsr2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, 0, 0, 0);
+
+		bCommon = TRUE;
+	}
+	else if(bWifiConnected && 
+		(BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus) )
+	{
+		bLowPwrDisable = TRUE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+		
+		if(bWifiBusy)
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi Busy + BT LPS!!\n"));
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+		else
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi LPS + BT LPS!!\n"));
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+		
+		halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,TRUE,TRUE);
+		halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		halbtc8821aCsr2ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0, 0);
+		halbtc8821aCsr2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, 0, 0, 0);
+
+		bCommon = TRUE;
+	}
+	else if(!bWifiConnected && 
+			(BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE == pCoexDm->btStatus) )
+	{
+		bLowPwrDisable = FALSE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi IPS + BT Busy!!\n"));	
+
+		halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+		halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+		halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		halbtc8821aCsr2ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0, 0);
+		halbtc8821aCsr2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, 0, 0, 0);
+		
+		bCommon = TRUE;
+	}
+	else
+	{
+		bLowPwrDisable = TRUE;
+		pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_ACT_DISABLE_LOW_POWER, &bLowPwrDisable);
+
+		if(bWifiBusy)
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi Busy + BT Busy!!\n"));
+	  		bCommon = FALSE;
+		}
+		else
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Wifi LPS + BT Busy!!\n"));
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 21);
+
+			if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+				halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+			else	
+				halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+			
+			bCommon = TRUE;
+		}
+
+		halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,TRUE,TRUE);
+	}
+
+	if (bCommon == TRUE)
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5afa5afa, 0xffff, 0x3);
+
+	return bCommon;
+}
+VOID
+halbtc8821aCsr2ant_TdmaDurationAdjust(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN			bScoHid,
+	IN	BOOLEAN			bTxPause,
+	IN	u1Byte			maxInterval
+	)
+{
+	static s4Byte		up,dn,m,n,WaitCount;
+	s4Byte			result;   //0: no change, +1: increase WiFi duration, -1: decrease WiFi duration
+	u1Byte			retryCount=0;
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW, ("[BTCoex], TdmaDurationAdjust()\n"));
+
+	if(pCoexDm->bResetTdmaAdjust)
+	{
+		pCoexDm->bResetTdmaAdjust = FALSE;
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], first run TdmaDurationAdjust()!!\n"));
+		{
+			if(bScoHid)
+			{
+				if(bTxPause)
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+						pCoexDm->psTdmaDuAdjType = 13;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;	
+					}
+					else
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+				}
+				else
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+						pCoexDm->psTdmaDuAdjType = 9;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+				}
+			}
+			else
+			{
+				if(bTxPause)
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+						pCoexDm->psTdmaDuAdjType = 5;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+				}
+				else
+				{
+					if(maxInterval == 1)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+						pCoexDm->psTdmaDuAdjType = 1;	
+					}
+					else if(maxInterval == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;	
+					}
+					else if(maxInterval == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+				}
+			}
+		}
+		//============
+		up = 0;
+		dn = 0;
+		m = 1;
+		n= 3;
+		result = 0;
+		WaitCount = 0;
+	}
+	else
+	{
+		//accquire the BT TRx retry count from BT_Info byte2
+		retryCount = pCoexSta->btRetryCnt;
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], retryCount = %d\n", retryCount));
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], up=%d, dn=%d, m=%d, n=%d, WaitCount=%d\n", 
+			up, dn, m, n, WaitCount));
+		result = 0;
+		WaitCount++; 
+		  
+		if(retryCount == 0)  // no retry in the last 2-second duration
+		{
+			up++;
+			dn--;
+
+			if (dn <= 0)
+				dn = 0;				 
+
+			if(up >= n)	// if s n 2 retry count0, heWiFi duration
+			{
+				WaitCount = 0; 
+				n = 3;
+				up = 0;
+				dn = 0;
+				result = 1; 
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], Increase wifi duration!!\n"));
+			}
+		}
+		else if (retryCount <= 3)	// <=3 retry in the last 2-second duration
+		{
+			up--; 
+			dn++;
+
+			if (up <= 0)
+				up = 0;
+
+			if (dn == 2)	// if s 2 2 retry count< 3, hWiFi duration
+			{
+				if (WaitCount <= 2)
+					m++; // K@blevel^
+				else
+					m = 1;
+
+				if ( m >= 20) //m j = 20 ' j120 recheckO_ WiFi duration.
+					m = 20;
+
+				n = 3*m;
+				up = 0;
+				dn = 0;
+				WaitCount = 0;
+				result = -1; 
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], Decrease wifi duration for retryCounter<3!!\n"));
+			}
+		}
+		else  //retry count > 3, un1 retry count > 3, hWiFi duration
+		{
+			if (WaitCount == 1)
+				m++; // K@blevel^
+			else
+				m = 1;
+
+			if ( m >= 20) //m j = 20 ' j120 recheckO_ WiFi duration.
+				m = 20;
+
+			n = 3*m;
+			up = 0;
+			dn = 0;
+			WaitCount = 0; 
+			result = -1;
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], Decrease wifi duration for retryCounter>3!!\n"));
+		}
+
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], max Interval = %d\n", maxInterval));
+		if(maxInterval == 1)
+		{
+			if(bTxPause)
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], TxPause = 1\n"));
+
+				if(pCoexDm->curPsTdma == 71)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+					pCoexDm->psTdmaDuAdjType = 5;
+				}
+				else if(pCoexDm->curPsTdma == 1)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+					pCoexDm->psTdmaDuAdjType = 5;
+				}
+				else if(pCoexDm->curPsTdma == 2)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					pCoexDm->psTdmaDuAdjType = 6;
+				}
+				else if(pCoexDm->curPsTdma == 3)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 4)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+					pCoexDm->psTdmaDuAdjType = 8;
+				}
+				if(pCoexDm->curPsTdma == 9)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+					pCoexDm->psTdmaDuAdjType = 13;
+				}
+				else if(pCoexDm->curPsTdma == 10)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+					pCoexDm->psTdmaDuAdjType = 14;
+				}
+				else if(pCoexDm->curPsTdma == 11)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 12)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+					pCoexDm->psTdmaDuAdjType = 16;
+				}
+				
+				if(result == -1)
+				{					
+					if(pCoexDm->curPsTdma == 5)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+						pCoexDm->psTdmaDuAdjType = 8;
+					}
+					else if(pCoexDm->curPsTdma == 13)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+						pCoexDm->psTdmaDuAdjType = 16;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 8)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+						pCoexDm->psTdmaDuAdjType = 5;
+					}
+					else if(pCoexDm->curPsTdma == 16)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+						pCoexDm->psTdmaDuAdjType = 13;
+					}
+				}
+			}
+			else
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], TxPause = 0\n"));
+				if(pCoexDm->curPsTdma == 5)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 71);
+					pCoexDm->psTdmaDuAdjType = 71;
+				}
+				else if(pCoexDm->curPsTdma == 6)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+				else if(pCoexDm->curPsTdma == 7)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 8)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+					pCoexDm->psTdmaDuAdjType = 4;
+				}
+				if(pCoexDm->curPsTdma == 13)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+					pCoexDm->psTdmaDuAdjType = 9;
+				}
+				else if(pCoexDm->curPsTdma == 14)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					pCoexDm->psTdmaDuAdjType = 10;
+				}
+				else if(pCoexDm->curPsTdma == 15)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 16)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					pCoexDm->psTdmaDuAdjType = 12;
+				}
+				
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 71)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+						pCoexDm->psTdmaDuAdjType = 1;
+					}
+					else if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+						pCoexDm->psTdmaDuAdjType = 4;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+						pCoexDm->psTdmaDuAdjType = 12;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 4)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+						pCoexDm->psTdmaDuAdjType = 1;
+					}
+					else if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 71);
+						pCoexDm->psTdmaDuAdjType = 71;
+					}
+					else if(pCoexDm->curPsTdma == 12)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+						pCoexDm->psTdmaDuAdjType = 9;
+					}
+				}
+			}
+		}
+		else if(maxInterval == 2)
+		{
+			if(bTxPause)
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], TxPause = 1\n"));
+				if(pCoexDm->curPsTdma == 1)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					pCoexDm->psTdmaDuAdjType = 6;
+				}
+				else if(pCoexDm->curPsTdma == 2)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+					pCoexDm->psTdmaDuAdjType = 6;
+				}
+				else if(pCoexDm->curPsTdma == 3)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 4)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+					pCoexDm->psTdmaDuAdjType = 8;
+				}
+				if(pCoexDm->curPsTdma == 9)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+					pCoexDm->psTdmaDuAdjType = 14;
+				}
+				else if(pCoexDm->curPsTdma == 10)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+					pCoexDm->psTdmaDuAdjType = 14;
+				}
+				else if(pCoexDm->curPsTdma == 11)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 12)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+					pCoexDm->psTdmaDuAdjType = 16;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 5) 
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+						pCoexDm->psTdmaDuAdjType = 8;
+					}
+					else if(pCoexDm->curPsTdma == 13)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+						pCoexDm->psTdmaDuAdjType = 16;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 8)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 6);
+						pCoexDm->psTdmaDuAdjType = 6;
+					}					
+					else if(pCoexDm->curPsTdma == 16)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+						pCoexDm->psTdmaDuAdjType = 14;
+					}
+				}
+			}
+			else
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], TxPause = 0\n"));
+				if(pCoexDm->curPsTdma == 5)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+				else if(pCoexDm->curPsTdma == 6)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+					pCoexDm->psTdmaDuAdjType = 2;
+				}
+				else if(pCoexDm->curPsTdma == 7)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 8)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+					pCoexDm->psTdmaDuAdjType = 4;
+				}
+				if(pCoexDm->curPsTdma == 13)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					pCoexDm->psTdmaDuAdjType = 10;
+				}
+				else if(pCoexDm->curPsTdma == 14)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+					pCoexDm->psTdmaDuAdjType = 10;
+				}
+				else if(pCoexDm->curPsTdma == 15)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 16)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					pCoexDm->psTdmaDuAdjType = 12;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+						pCoexDm->psTdmaDuAdjType = 4;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+						pCoexDm->psTdmaDuAdjType = 12;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 4)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 2);
+						pCoexDm->psTdmaDuAdjType = 2;
+					}
+					else if(pCoexDm->curPsTdma == 12)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+						pCoexDm->psTdmaDuAdjType = 10;
+					}
+				}
+			}
+		}
+		else if(maxInterval == 3)
+		{
+			if(bTxPause)
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], TxPause = 1\n"));
+				if(pCoexDm->curPsTdma == 1)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 2)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 3)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+					pCoexDm->psTdmaDuAdjType = 7;
+				}
+				else if(pCoexDm->curPsTdma == 4)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+					pCoexDm->psTdmaDuAdjType = 8;
+				}
+				if(pCoexDm->curPsTdma == 9)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 10)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 11)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+					pCoexDm->psTdmaDuAdjType = 15;
+				}
+				else if(pCoexDm->curPsTdma == 12)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+					pCoexDm->psTdmaDuAdjType = 16;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 5) 
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 8);
+						pCoexDm->psTdmaDuAdjType = 8;
+					}
+					else if(pCoexDm->curPsTdma == 13)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 16);
+						pCoexDm->psTdmaDuAdjType = 16;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 8)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 7)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}
+					else if(pCoexDm->curPsTdma == 6)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 7);
+						pCoexDm->psTdmaDuAdjType = 7;
+					}					
+					else if(pCoexDm->curPsTdma == 16)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 15)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+					else if(pCoexDm->curPsTdma == 14)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 15);
+						pCoexDm->psTdmaDuAdjType = 15;
+					}
+				}
+			}
+			else
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], TxPause = 0\n"));
+				if(pCoexDm->curPsTdma == 5)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 6)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 7)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+					pCoexDm->psTdmaDuAdjType = 3;
+				}
+				else if(pCoexDm->curPsTdma == 8)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+					pCoexDm->psTdmaDuAdjType = 4;
+				}
+				if(pCoexDm->curPsTdma == 13)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 14)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 15)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+					pCoexDm->psTdmaDuAdjType = 11;
+				}
+				else if(pCoexDm->curPsTdma == 16)
+				{
+					halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+					pCoexDm->psTdmaDuAdjType = 12;
+				}
+				if(result == -1)
+				{
+					if(pCoexDm->curPsTdma == 1)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 4);
+						pCoexDm->psTdmaDuAdjType = 4;
+					}
+					else if(pCoexDm->curPsTdma == 9)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 12);
+						pCoexDm->psTdmaDuAdjType = 12;
+					}
+				} 
+				else if (result == 1)
+				{
+					if(pCoexDm->curPsTdma == 4)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 3)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 2)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 3);
+						pCoexDm->psTdmaDuAdjType = 3;
+					}
+					else if(pCoexDm->curPsTdma == 12)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 11)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+					else if(pCoexDm->curPsTdma == 10)
+					{
+						halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 11);
+						pCoexDm->psTdmaDuAdjType = 11;
+					}
+				}
+			}
+		}
+	}
+
+	// if current PsTdma not match with the recorded one (when scan, dhcp...), 
+	// then we have to adjust it back to the previous record one.
+	if(pCoexDm->curPsTdma != pCoexDm->psTdmaDuAdjType)
+	{
+		BOOLEAN	bScan=FALSE, bLink=FALSE, bRoam=FALSE;
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], PsTdma type dismatch!!!, curPsTdma=%d, recordPsTdma=%d\n", 
+			pCoexDm->curPsTdma, pCoexDm->psTdmaDuAdjType));
+
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+		
+		if( !bScan && !bLink && !bRoam)
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, pCoexDm->psTdmaDuAdjType);
+		}
+		else
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_DETAIL, ("[BTCoex], roaming/link/scan is under progress, will adjust next time!!!\n"));
+		}
+	}
+
+	// when halbtc8821aCsr2ant_TdmaDurationAdjust() is called, fw dac swing is included in the function.
+	//if(pCoexDm->psTdmaDuAdjType == 71)
+	//	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0xc); //Skip because A2DP get worse at HT40
+	//else
+		halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 0x6);
+}
+
+// SCO only or SCO+PAN(HS)
+VOID
+halbtc8821aCsr2ant_ActionSco(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte	wifiRssiState,btRssiState;
+	u4Byte	wifiBw;
+
+	halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55555555, 0x55555555, 0xffffff, 0x3);
+	halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0);
+
+	halbtc8821aCsr2ant_LowPenaltyRa(pBtCoexist, NORMAL_EXEC, TRUE);
+
+	halbtc8821aCsr2ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 1, 0, 2, 0);
+
+	if(pCoexSta->bSlave == FALSE)
+		halbtc8821aCsr2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, TRUE, 0x4);
+	else
+		halbtc8821aCsr2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, TRUE, 0x2);
+
+/*
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 4);
+
+	if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+	
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if (BTC_WIFI_BW_LEGACY == wifiBw) //for SCO quality at 11b/g mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x5a5a5a5a, 0x5a5a5a5a, 0xffff, 0x3);
+	}
+	else  //for SCO quality & wifi performance balance at 11n mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x5aea5aea, 0x5aea5aea, 0xffff, 0x3);
+	}
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+	
+		// fw mechanism
+		//halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0); //for voice quality
+		}
+		else
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0); //for voice quality
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);			
+		}
+		else
+		{
+			halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);	
+		}		
+	}
+	else
+	{
+		// fw mechanism
+		//halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0); //for voice quality
+		}
+		else
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 0); //for voice quality
+		}
+		
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}		
+	}
+*/
+}
+
+
+VOID
+halbtc8821aCsr2ant_ActionHid(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte	wifiRssiState, btRssiState;	
+	u4Byte	wifiBw;
+
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if (BTC_WIFI_BW_LEGACY == wifiBw) //for HID at 11b/g mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3);
+	}
+	else  //for HID quality & wifi performance balance at 11n mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5aea5aea, 0xffff, 0x3);
+	}
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+ 			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}	
+	}
+	else
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 9);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 13);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+ 			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}		
+	}
+}
+
+//A2DP only / PAN(EDR) only/ A2DP+PAN(HS)
+VOID
+halbtc8821aCsr2ant_ActionA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, btRssiState;
+	u4Byte		wifiBw;
+
+	halbtc8821aCsr2ant_LimitedRx(pBtCoexist, NORMAL_EXEC, FALSE, TRUE, 0x8);
+
+	if(pCoexSta->bSlave == FALSE)
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0xfdfdfdfd, 0xdfdadfda, 0xffffff, 0x3);
+		halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 22);
+		halbtc8821aCsr2ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0, 1);
+		halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,TRUE,0x0c);
+	}
+	else
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0xfdfdfdfd, 0xdfdadfda, 0xffffff, 0x3);
+		halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 23);
+		halbtc8821aCsr2ant_LimitedTx(pBtCoexist, NORMAL_EXEC, 0, 0, 0, 0, 2);
+		halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,TRUE,0x18);
+	}
+
+/*
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	//fw dac swing is called in halbtc8821aCsr2ant_TdmaDurationAdjust()
+	//halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+	
+
+	if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 1);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 1);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+ 			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 1);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 1);
+		}
+		
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}		
+	}
+*/
+}
+
+VOID
+halbtc8821aCsr2ant_ActionA2dpPanHs(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, btRssiState, btInfoExt;
+	u4Byte		wifiBw;
+
+	btInfoExt = pCoexSta->btInfoExt;
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2,35, 0);
+
+	//fw dac swing is called in halbtc8821aCsr2ant_TdmaDurationAdjust()
+	//halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+
+	if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		// fw mechanism
+		if(btInfoExt&BIT0)	//a2dp basic rate
+		{
+			halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 2);
+		}
+		else				//a2dp edr rate
+		{
+			halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 1);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+ 			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		// fw mechanism
+		if(btInfoExt&BIT0)	//a2dp basic rate
+		{
+			halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 2);
+		}
+		else				//a2dp edr rate
+		{
+			halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 1);
+		}
+		
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}		
+	}
+}
+
+VOID
+halbtc8821aCsr2ant_ActionPanEdr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, btRssiState;
+	u4Byte		wifiBw;
+
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if (BTC_WIFI_BW_LEGACY == wifiBw) //for HID at 11b/g mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5aff5aff, 0xffff, 0x3);
+	}
+	else  //for HID quality & wifi performance balance at 11n mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5aff5aff, 0xffff, 0x3);
+	}
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 1);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 5);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+
+//PAN(HS) only
+VOID
+halbtc8821aCsr2ant_ActionPanHs(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, btRssiState;
+	u4Byte		wifiBw;
+
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		}
+		halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		// fw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+		}
+
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, FALSE, 1);
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+//PAN(EDR)+A2DP
+VOID
+halbtc8821aCsr2ant_ActionPanEdrA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, btRssiState, btInfoExt;
+	u4Byte		wifiBw;
+
+	btInfoExt = pCoexSta->btInfoExt;
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if (BTC_WIFI_BW_LEGACY == wifiBw) //for HID at 11b/g mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5afa5afa, 0xffff, 0x3);
+	}
+	else  //for HID quality & wifi performance balance at 11n mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5afa5afa, 0xffff, 0x3);
+	}
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 3);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
+			}
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		};
+	}
+	else
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, FALSE, 3);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, FALSE, TRUE, 3);
+			}
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,FALSE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+VOID
+halbtc8821aCsr2ant_ActionPanEdrHid(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, btRssiState;
+	u4Byte		wifiBw;
+
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if (BTC_WIFI_BW_LEGACY == wifiBw) //for HID at 11b/g mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5a5f5a5f, 0xffff, 0x3);
+	}
+	else  //for HID quality & wifi performance balance at 11n mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5a5f5a5f, 0xffff, 0x3);
+	}
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{ 
+		halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 3);
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10); 
+		}
+		else
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14); 
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 10);
+		}
+		else
+		{
+			halbtc8821aCsr2ant_PsTdma(pBtCoexist, NORMAL_EXEC, TRUE, 14);
+		}
+		
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+// HID+A2DP+PAN(EDR)
+VOID
+halbtc8821aCsr2ant_ActionHidA2dpPanEdr(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, btRssiState, btInfoExt;
+	u4Byte		wifiBw;
+
+	btInfoExt = pCoexSta->btInfoExt;
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	halbtc8821aCsr2ant_FwDacSwingLvl(pBtCoexist, NORMAL_EXEC, 6);
+
+	if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if (BTC_WIFI_BW_LEGACY == wifiBw) //for HID at 11b/g mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3);
+	}
+	else  //for HID quality & wifi performance balance at 11n mode
+	{
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3);
+	}
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+			}
+		}
+		
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 3);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 3);
+			}
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+VOID
+halbtc8821aCsr2ant_ActionHidA2dp(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	u1Byte		wifiRssiState, btRssiState, btInfoExt;
+	u4Byte		wifiBw;
+
+	btInfoExt = pCoexSta->btInfoExt;
+	wifiRssiState = halbtc8821aCsr2ant_WifiRssiState(pBtCoexist, 0, 2, 15, 0);
+	btRssiState = halbtc8821aCsr2ant_BtRssiState(2, 35, 0);
+
+	if(halbtc8821aCsr2ant_NeedToDecBtPwr(pBtCoexist))
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, TRUE);
+	else	
+		halbtc8821aCsr2ant_DecBtPwr(pBtCoexist, NORMAL_EXEC, FALSE);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+
+	if (BTC_WIFI_BW_LEGACY == wifiBw) //for HID at 11b/g mode
+	{
+//Allen		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3);
+		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5f5b5f5b, 0xffffff, 0x3);
+	}
+	else  //for HID quality & wifi performance balance at 11n mode
+	{
+//Allen		halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5a5a5a5a, 0xffff, 0x3);
+			halbtc8821aCsr2ant_CoexTable(pBtCoexist, NORMAL_EXEC, 0x55ff55ff, 0x5f5b5f5b, 0xffffff, 0x3);
+
+	}
+
+	if(BTC_WIFI_BW_HT40 == wifiBw)
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+			}
+		}
+		
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,TRUE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+	else
+	{
+		// fw mechanism
+		if( (btRssiState == BTC_RSSI_STATE_HIGH) ||
+			(btRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+//				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 2);
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+
+			}
+			else				//a2dp edr rate
+			{
+//Allen				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, FALSE, 2);
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+			}
+		}
+		else
+		{
+			if(btInfoExt&BIT0)	//a2dp basic rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+			}
+			else				//a2dp edr rate
+			{
+				halbtc8821aCsr2ant_TdmaDurationAdjust(pBtCoexist, TRUE, TRUE, 2);
+			}
+		}
+
+		// sw mechanism
+		if( (wifiRssiState == BTC_RSSI_STATE_HIGH) ||
+			(wifiRssiState == BTC_RSSI_STATE_STAY_HIGH) )
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,TRUE,FALSE,FALSE,0x18);
+		}
+		else
+		{
+			 halbtc8821aCsr2ant_SwMechanism1(pBtCoexist,FALSE,TRUE,FALSE,FALSE);
+			 halbtc8821aCsr2ant_SwMechanism2(pBtCoexist,FALSE,FALSE,FALSE,0x18);
+		}
+	}
+}
+
+VOID
+halbtc8821aCsr2ant_RunCoexistMechanism(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	BOOLEAN				bWifiUnder5G=FALSE;
+	u1Byte				btInfoOriginal=0, btRetryCnt=0;
+	u1Byte				algorithm=0;
+
+	if(pBtCoexist->bManualControl)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Manual control!!!\n"));
+		return;
+	}
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
+
+	if(bWifiUnder5G)
+	{
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], RunCoexistMechanism(), run 5G coex setting!!<===\n"));
+		halbtc8821aCsr2ant_CoexUnder5G(pBtCoexist);
+		return;
+	}
+
+	//if(pStackInfo->bProfileNotified)
+	{
+		algorithm = halbtc8821aCsr2ant_ActionAlgorithm(pBtCoexist);
+		if(pCoexSta->bC2hBtInquiryPage && (BT_8821A_CSR_2ANT_COEX_ALGO_PANHS!=algorithm))
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], BT is under inquiry/page scan !!\n"));
+			halbtc8821aCsr2ant_BtInquiryPage(pBtCoexist);
+			return;
+		}
+
+		pCoexDm->curAlgorithm = algorithm;
+		BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Algorithm = %d \n", pCoexDm->curAlgorithm));
+
+		if(halbtc8821aCsr2ant_IsCommonAction(pBtCoexist))
+		{
+			BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant common.\n"));
+			pCoexDm->bResetTdmaAdjust = TRUE;
+		}
+		else
+		{
+			if(pCoexDm->curAlgorithm != pCoexDm->preAlgorithm)
+			{
+				BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], preAlgorithm=%d, curAlgorithm=%d\n", 
+					pCoexDm->preAlgorithm, pCoexDm->curAlgorithm));
+				pCoexDm->bResetTdmaAdjust = TRUE;
+			}
+			switch(pCoexDm->curAlgorithm)
+			{
+				case BT_8821A_CSR_2ANT_COEX_ALGO_SCO:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = SCO.\n"));
+					halbtc8821aCsr2ant_ActionSco(pBtCoexist);
+					break;
+				case BT_8821A_CSR_2ANT_COEX_ALGO_HID:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = HID.\n"));
+					halbtc8821aCsr2ant_ActionHid(pBtCoexist);
+					break;
+				case BT_8821A_CSR_2ANT_COEX_ALGO_A2DP:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = A2DP.\n"));
+					halbtc8821aCsr2ant_ActionA2dp(pBtCoexist);
+					break;
+				case BT_8821A_CSR_2ANT_COEX_ALGO_A2DP_PANHS:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = A2DP+PAN(HS).\n"));
+					halbtc8821aCsr2ant_ActionA2dpPanHs(pBtCoexist);
+					break;
+				case BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = PAN(EDR).\n"));
+					halbtc8821aCsr2ant_ActionPanEdr(pBtCoexist);
+					break;
+				case BT_8821A_CSR_2ANT_COEX_ALGO_PANHS:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = HS mode.\n"));
+					halbtc8821aCsr2ant_ActionPanHs(pBtCoexist);
+					break;
+				case BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_A2DP:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = PAN+A2DP.\n"));
+					halbtc8821aCsr2ant_ActionPanEdrA2dp(pBtCoexist);
+					break;
+				case BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = PAN(EDR)+HID.\n"));
+					halbtc8821aCsr2ant_ActionPanEdrHid(pBtCoexist);
+					break;
+				case BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP_PANEDR:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = HID+A2DP+PAN.\n"));
+					halbtc8821aCsr2ant_ActionHidA2dpPanEdr(pBtCoexist);
+					break;
+				case BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = HID+A2DP.\n"));
+					halbtc8821aCsr2ant_ActionHidA2dp(pBtCoexist);
+					break;
+				default:
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], Action 2-Ant, algorithm = coexist All Off!!\n"));
+					halbtc8821aCsr2ant_CoexAllOff(pBtCoexist);
+					break;
+			}
+			pCoexDm->preAlgorithm = pCoexDm->curAlgorithm;
+		}
+	}
+}
+
+
+
+//============================================================
+// work around function start with wa_halbtc8821aCsr2ant_
+//============================================================
+//============================================================
+// extern function start with EXhalbtc8821aCsr2ant_
+//============================================================
+VOID
+EXhalbtc8821aCsr2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+}
+
+VOID
+EXhalbtc8821aCsr2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	)
+{
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	u4Byte	u4Tmp=0;
+	u2Byte				u2Tmp=0;
+	u1Byte	u1Tmp=0;
+	u1Byte				H2C_Parameter[2] ={0};
+		
+
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], 2Ant Init HW Config!!\n"));
+
+	if(bWifiOnly)
+		return;
+	
+	//if(bBackUp)
+	{
+		// backup rf 0x1e value
+		pCoexDm->btRf0x1eBackup = pBtCoexist->fBtcGetRfReg(pBtCoexist, BTC_RF_A, 0x1e, 0xfffff);
+		pCoexDm->backupArfrCnt1 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x430);
+		pCoexDm->backupArfrCnt2 = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x434);
+		pCoexDm->backupRetryLimit = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0x42a);
+		pCoexDm->backupAmpduMaxTime = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x456);
+		pCoexDm->backupAmpduMaxNum = pBtCoexist->fBtcRead2Byte(pBtCoexist, 0x4ca);
+	}
+
+	#if 0 /* REMOVE */
+	// 0x790[5:0]=0x5
+	u1Tmp = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x790);
+	u1Tmp &= 0xc0;
+	u1Tmp |= 0x5;
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x790, u1Tmp);
+	#endif
+	
+	//Antenna config
+	halbtc8821aCsr2ant_SetAntPath(pBtCoexist, BTC_ANT_WIFI_AT_MAIN, TRUE, FALSE);
+
+	// PTA parameter
+	halbtc8821aCsr2ant_CoexTable(pBtCoexist, FORCE_EXEC, 0x55555555, 0x55555555, 0xffff, 0x3);
+	
+	// Enable counter statistics
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x76e, 0xc); //0x76e[3] =1, WLAN_Act control by PTA
+	pBtCoexist->fBtcWrite1Byte(pBtCoexist, 0x778, 0x3);
+
+	#if 0 /* REMOVE */
+	pBtCoexist->fBtcWrite1ByteBitMask(pBtCoexist, 0x40, 0x20, 0x1);
+	#endif
+}
+
+VOID
+EXhalbtc8821aCsr2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], Coex Mechanism Init!!\n"));
+	
+	halbtc8821aCsr2ant_InitCoexDm(pBtCoexist);
+}
+
+VOID
+EXhalbtc8821aCsr2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	)
+{
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+	pu1Byte				cliBuf=pBtCoexist->cliBuf;
+	u1Byte				u1Tmp[4], i, btInfoExt, psTdmaCase=0;
+	u4Byte				u4Tmp[4];
+	u4Byte				fwVer=0, btPatchVer=0;
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n ============[BT Coexist info]============");
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "Ant PG number/ Ant mechanism:", \
+		pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum);
+	CL_PRINTF(cliBuf);	
+	
+	if(pBtCoexist->bManualControl)
+	{
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "[Action Manual control]!!");
+		CL_PRINTF(cliBuf);
+	}
+	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %d", "BT stack/ hci ext ver", \
+		((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_BT_PATCH_VER, &btPatchVer);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d_%d/ 0x%x/ 0x%x(%d)", "CoexVer/ FwVer/ PatchVer", \
+		GLCoexVerDate8821aCsr2Ant, GLCoexVer8821aCsr2Ant, fwVer, btPatchVer, btPatchVer);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x ", "Wifi channel informed to BT", \
+		pCoexDm->wifiChnlInfo[0], pCoexDm->wifiChnlInfo[1],
+		pCoexDm->wifiChnlInfo[2]);
+	CL_PRINTF(cliBuf);
+
+	// wifi status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Wifi Status]============");
+	CL_PRINTF(cliBuf);
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_WIFI_STATUS);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[BT Status]============");
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s/ %d/ %d] ", "BT [status/ rssi/ retryCnt]", \
+		((pCoexSta->bC2hBtInquiryPage)?("inquiry/page scan"):((BT_8821A_CSR_2ANT_BT_STATUS_IDLE == pCoexDm->btStatus)? "idle":(  (BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE == pCoexDm->btStatus)? "connected-idle":"busy"))),
+		pCoexSta->btRssi, pCoexSta->btRetryCnt);
+	CL_PRINTF(cliBuf);
+	
+	if(pStackInfo->bProfileNotified)
+	{			
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "SCO/HID/PAN/A2DP", \
+			pStackInfo->bScoExist, pStackInfo->bHidExist, pStackInfo->bPanExist, pStackInfo->bA2dpExist);
+		CL_PRINTF(cliBuf);	
+
+		pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_BT_LINK_INFO);
+	}
+
+	btInfoExt = pCoexSta->btInfoExt;
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s", "BT Info A2DP rate", \
+		(btInfoExt&BIT0)? "Basic rate":"EDR rate");
+	CL_PRINTF(cliBuf);	
+
+	for(i=0; i<BT_INFO_SRC_8821A_CSR_2ANT_MAX; i++)
+	{
+		if(pCoexSta->btInfoC2hCnt[i])
+		{				
+			CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x %02x %02x(%d)", GLBtInfoSrc8821aCsr2Ant[i], \
+				pCoexSta->btInfoC2h[i][0], pCoexSta->btInfoC2h[i][1],
+				pCoexSta->btInfoC2h[i][2], pCoexSta->btInfoC2h[i][3],
+				pCoexSta->btInfoC2h[i][4], pCoexSta->btInfoC2h[i][5],
+				pCoexSta->btInfoC2h[i][6], pCoexSta->btInfoC2hCnt[i]);
+			CL_PRINTF(cliBuf);
+		}
+	}
+
+	// Sw mechanism	
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Sw mechanism]============");
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "SM1[ShRf/ LpRA/ LimDig]", \
+		pCoexDm->bCurRfRxLpfShrink, pCoexDm->bCurLowPenaltyRa, pCoexDm->bLimitedDig);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d(0x%x) ", "SM2[AgcT/ AdcB/ SwDacSwing(lvl)]", \
+		pCoexDm->bCurAgcTableEn, pCoexDm->bCurAdcBackOff, pCoexDm->bCurDacSwingOn, pCoexDm->curDacSwingLvl);
+	CL_PRINTF(cliBuf);
+
+	// Fw mechanism		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Fw mechanism]============");
+	CL_PRINTF(cliBuf);	
+	
+	if(!pBtCoexist->bManualControl)
+	{
+		psTdmaCase = pCoexDm->curPsTdma;
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x case-%d", "PS TDMA", \
+			pCoexDm->psTdmaPara[0], pCoexDm->psTdmaPara[1],
+			pCoexDm->psTdmaPara[2], pCoexDm->psTdmaPara[3],
+			pCoexDm->psTdmaPara[4], psTdmaCase);
+		CL_PRINTF(cliBuf);
+	
+		CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d ", "DecBtPwr/ IgnWlanAct", \
+			pCoexDm->bCurDecBtPwr, pCoexDm->bCurIgnoreWlanAct);
+		CL_PRINTF(cliBuf);
+	}
+
+	// Hw setting		
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "============[Hw setting]============");
+	CL_PRINTF(cliBuf);	
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "RF-A, 0x1e initVal", \
+		pCoexDm->btRf0x1eBackup);
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x778);
+	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x6cc);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x ", "0x778 (W_Act)/ 0x6cc (CoTab Sel)", \
+		u1Tmp[0], u1Tmp[1]);
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x8db);
+	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0xc5b);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0x8db(ADC)/0xc5b[29:25](DAC)", \
+		((u1Tmp[0]&0x60)>>5), ((u1Tmp[1]&0x3e)>>1));
+	CL_PRINTF(cliBuf); 
+	
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xcb4);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0xcb4[7:0](ctrl)/ 0xcb4[29:28](val)", \
+		u4Tmp[0]&0xff, ((u4Tmp[0]&0x30000000)>>28));
+	CL_PRINTF(cliBuf);
+
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x40);
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x4c);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x974);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x40/ 0x4c[24:23]/ 0x974", \
+		u1Tmp[0], ((u4Tmp[0]&0x01800000)>>23), u4Tmp[1]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x550);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0x522);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0x550(bcn ctrl)/0x522", \
+		u4Tmp[0], u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xc50);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0xa0a);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "0xc50(DIG)/0xa0a(CCK-TH)", \
+		u4Tmp[0], u1Tmp[0]);
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0xf48);
+	u1Tmp[0] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0xa5b);
+	u1Tmp[1] = pBtCoexist->fBtcRead1Byte(pBtCoexist, 0xa5c);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x", "OFDM-FA/ CCK-FA", \
+		u4Tmp[0], (u1Tmp[0]<<8) + u1Tmp[1]  );
+	CL_PRINTF(cliBuf);
+
+	u4Tmp[0] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c0);
+	u4Tmp[1] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c4);
+	u4Tmp[2] = pBtCoexist->fBtcRead4Byte(pBtCoexist, 0x6c8);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x/ 0x%x/ 0x%x", "0x6c0/0x6c4/0x6c8", \
+		u4Tmp[0], u4Tmp[1], u4Tmp[2]);
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "0x770 (hi-pri Rx/Tx)", \
+		pCoexSta->highPriorityRx, pCoexSta->highPriorityTx);
+	CL_PRINTF(cliBuf);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "0x774(low-pri Rx/Tx)", \
+		pCoexSta->lowPriorityRx, pCoexSta->lowPriorityTx);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcDispDbgMsg(pBtCoexist, BTC_DBG_DISP_COEX_STATISTICS);
+}
+
+
+VOID
+EXhalbtc8821aCsr2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_IPS_ENTER == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], IPS ENTER notify\n"));
+		pCoexSta->bUnderIps = TRUE;
+		halbtc8821aCsr2ant_CoexAllOff(pBtCoexist);
+	}
+	else if(BTC_IPS_LEAVE == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], IPS LEAVE notify\n"));
+		pCoexSta->bUnderIps = FALSE;
+		//halbtc8821aCsr2ant_InitCoexDm(pBtCoexist);
+	}
+}
+
+VOID
+EXhalbtc8821aCsr2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_LPS_ENABLE == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], LPS ENABLE notify\n"));
+		pCoexSta->bUnderLps = TRUE;
+	}
+	else if(BTC_LPS_DISABLE == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], LPS DISABLE notify\n"));
+		pCoexSta->bUnderLps = FALSE;
+	}
+}
+
+VOID
+EXhalbtc8821aCsr2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_SCAN_START == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN START notify\n"));
+	}
+	else if(BTC_SCAN_FINISH == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], SCAN FINISH notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8821aCsr2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	)
+{
+	if(BTC_ASSOCIATE_START == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT START notify\n"));
+	}
+	else if(BTC_ASSOCIATE_FINISH == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], CONNECT FINISH notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8821aCsr2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	u1Byte			H2C_Parameter[3] ={0};
+	u4Byte			wifiBw;
+	u1Byte			wifiCentralChnl;
+
+	if(BTC_MEDIA_CONNECT == type)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], MEDIA connect notify\n"));
+	}
+	else
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], MEDIA disconnect notify\n"));
+	}
+
+	// only 2.4G we need to inform bt the chnl mask
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_CENTRAL_CHNL, &wifiCentralChnl);
+	if( (BTC_MEDIA_CONNECT == type) &&
+		(wifiCentralChnl <= 14) )
+	{
+		H2C_Parameter[0] = 0x1;
+		H2C_Parameter[1] = wifiCentralChnl;
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+		if(BTC_WIFI_BW_HT40 == wifiBw)
+			H2C_Parameter[2] = 0x30;
+		else
+			H2C_Parameter[2] = 0x20;
+	}
+
+	#if 0 /* REMOVE */	
+	pCoexDm->wifiChnlInfo[0] = H2C_Parameter[0];
+	pCoexDm->wifiChnlInfo[1] = H2C_Parameter[1];
+	pCoexDm->wifiChnlInfo[2] = H2C_Parameter[2];
+	
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE_FW_EXEC, ("[BTCoex], FW write 0x66=0x%x\n", 
+		H2C_Parameter[0]<<16|H2C_Parameter[1]<<8|H2C_Parameter[2]));
+
+	rtw_warn_on(_BTCOEX_CSR);
+	pBtCoexist->fBtcFillH2c(pBtCoexist, 0x66, 3, H2C_Parameter);
+	#endif
+}
+
+VOID
+EXhalbtc8821aCsr2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	)
+{
+	if(type == BTC_PACKET_DHCP)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], DHCP Packet notify\n"));
+	}
+}
+
+VOID
+EXhalbtc8821aCsr2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	)
+{
+	u1Byte			btInfo=0;
+	u1Byte			i, rspSource=0;
+	BOOLEAN			bBtBusy=FALSE, bLimitedDig=FALSE;
+	BOOLEAN			bWifiConnected=FALSE, bBtHsOn=FALSE, bWifiUnder5G=FALSE;
+
+	pCoexSta->bC2hBtInfoReqSent = FALSE;
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &bWifiUnder5G);
+
+	rspSource = tmpBuf[0]&0xf;
+	if(rspSource >= BT_INFO_SRC_8821A_CSR_2ANT_MAX)
+		rspSource = BT_INFO_SRC_8821A_CSR_2ANT_WIFI_FW;
+	pCoexSta->btInfoC2hCnt[rspSource]++;
+
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Bt info[%d], length=%d, hex data=[", rspSource, length));
+	for(i=0; i<length; i++)
+	{
+		pCoexSta->btInfoC2h[rspSource][i] = tmpBuf[i];
+		if(i == 1)
+			btInfo = tmpBuf[i];
+		if(i == length-1)
+		{
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("0x%02x]\n", tmpBuf[i]));
+		}
+		else
+		{
+			BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("0x%02x, ", tmpBuf[i]));
+		}
+	}
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_CONNECTED, &bWifiConnected);
+	if(BT_INFO_SRC_8821A_CSR_2ANT_WIFI_FW != rspSource)
+	{
+		pCoexSta->btRetryCnt =	// [3:0]
+			pCoexSta->btInfoC2h[rspSource][2]&0xf;
+
+		pCoexSta->btRssi =
+			pCoexSta->btInfoC2h[rspSource][3]*2+10;
+
+		pCoexSta->btInfoExt = 
+			pCoexSta->btInfoC2h[rspSource][4];
+
+		#if 0 /* REMOVE */
+		// Here we need to resend some wifi info to BT
+		// because bt is reset and loss of the info.
+		if( (pCoexSta->btInfoExt & BIT1) )
+		{			
+			
+			if(bWifiConnected)
+			{
+				EXhalbtc8821aCsr2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_CONNECT);
+			}
+			else
+			{
+				EXhalbtc8821aCsr2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+			}
+		}
+		#endif
+
+		#if 0 /* REMOVE */
+		if(!pBtCoexist->bManualControl && !bWifiUnder5G)
+		{
+			if( (pCoexSta->btInfoExt&BIT3) )
+			{
+				if(bWifiConnected)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\n"));
+					halbtc8821aCsr2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, FALSE);
+				}
+			}
+			else
+			{
+				// BT already NOT ignore Wlan active, do nothing here.
+				if(!bWifiConnected)
+				{
+					BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], BT ext info bit3 check, set BT to ignore Wlan active!!\n"));
+					halbtc8821aCsr2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+				}
+			}
+		}
+		#endif
+
+		#if 0 /* REMOVE */
+		if( (pCoexSta->btInfoExt & BIT4) )
+		{
+			// BT auto report already enabled, do nothing
+		}
+		else
+		{
+			halbtc8821aCsr2ant_BtAutoReport(pBtCoexist, FORCE_EXEC, TRUE);
+		}
+		#endif
+	}
+		
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+
+	if(btInfo == BT_INFO_8821A_CSR_2ANT_B_CONNECTION)	// connection exists but no busy
+	{
+		pCoexSta->bBtLinkExist = TRUE;
+		pCoexDm->btStatus = BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE;
+	}
+	else if(btInfo & BT_INFO_8821A_CSR_2ANT_B_CONNECTION)	// connection exists and some link is busy
+	{
+		pCoexSta->bBtLinkExist = TRUE;
+
+		if(btInfo & BT_INFO_8821A_CSR_2ANT_B_FTP)
+			pCoexSta->bPanExist = TRUE;
+		else
+			pCoexSta->bPanExist = FALSE;
+
+		if(btInfo & BT_INFO_8821A_CSR_2ANT_B_A2DP)
+			pCoexSta->bA2dpExist = TRUE;
+		else
+			pCoexSta->bA2dpExist = FALSE;
+
+		if(btInfo & BT_INFO_8821A_CSR_2ANT_B_HID)
+			pCoexSta->bHidExist = TRUE;
+		else
+			pCoexSta->bHidExist = FALSE;
+
+		if(btInfo & BT_INFO_8821A_CSR_2ANT_B_SCO_ESCO)
+			pCoexSta->bScoExist = TRUE;
+		else
+			pCoexSta->bScoExist = FALSE;
+
+		if (pCoexSta->btInfoExt & 0x80)
+			pCoexSta->bSlave = TRUE; //Slave
+		else
+			pCoexSta->bSlave = FALSE; //Master
+
+		pCoexDm->btStatus = BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE;
+	}
+	else
+	{
+		pCoexSta->bBtLinkExist = FALSE;
+		pCoexSta->bPanExist = FALSE;
+		pCoexSta->bA2dpExist = FALSE;
+		pCoexSta->bSlave = FALSE;
+		pCoexSta->bHidExist = FALSE;
+		pCoexSta->bScoExist = FALSE;
+		pCoexDm->btStatus = BT_8821A_CSR_2ANT_BT_STATUS_IDLE;
+	}
+
+	if(bBtHsOn)
+	{
+		pCoexDm->btStatus = BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE;
+	}
+
+	if(btInfo & BT_INFO_8821A_CSR_2ANT_B_INQ_PAGE)
+	{
+		pCoexSta->bC2hBtInquiryPage = TRUE;
+		pCoexDm->btStatus = BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE;
+	} 
+	else
+	{
+		pCoexSta->bC2hBtInquiryPage = FALSE;
+	}
+
+
+	if(BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE == pCoexDm->btStatus)
+	{
+		bBtBusy = TRUE;
+	}
+	else
+	{
+		bBtBusy = FALSE;
+	}
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_TRAFFIC_BUSY, &bBtBusy);
+
+	if(BT_8821A_CSR_2ANT_BT_STATUS_IDLE != pCoexDm->btStatus)
+	{
+		bLimitedDig = TRUE;
+	}
+	else
+	{
+		bLimitedDig = FALSE;
+	}
+	pCoexDm->bLimitedDig = bLimitedDig;
+	pBtCoexist->fBtcSet(pBtCoexist, BTC_SET_BL_BT_LIMITED_DIG, &bLimitedDig);
+
+	halbtc8821aCsr2ant_RunCoexistMechanism(pBtCoexist);
+}
+
+VOID
+EXhalbtc8821aCsr2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Halt notify\n"));
+
+	halbtc8821aCsr2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+	EXhalbtc8821aCsr2ant_MediaStatusNotify(pBtCoexist, BTC_MEDIA_DISCONNECT);
+}
+
+VOID
+EXhalbtc8821aCsr2ant_PnpNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				pnpState
+	)
+{
+	BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify\n"));
+
+	if(BTC_WIFI_PNP_SLEEP == pnpState)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to SLEEP\n"));
+		halbtc8821aCsr2ant_IgnoreWlanAct(pBtCoexist, FORCE_EXEC, TRUE);
+	}
+	else if(BTC_WIFI_PNP_WAKE_UP == pnpState)
+	{
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_NOTIFY, ("[BTCoex], Pnp notify to WAKE UP\n"));
+	}
+}
+
+VOID
+EXhalbtc8821aCsr2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	)
+{
+	static u1Byte		disVerInfoCnt=0;
+	u4Byte				fwVer=0, btPatchVer=0;
+	PBTC_BOARD_INFO		pBoardInfo=&pBtCoexist->boardInfo;
+	PBTC_STACK_INFO		pStackInfo=&pBtCoexist->stackInfo;
+
+	BTC_PRINT(BTC_MSG_ALGORITHM, ALGO_TRACE, ("[BTCoex], ==========================Periodical===========================\n"));
+
+	if(disVerInfoCnt <= 5)
+	{
+		disVerInfoCnt += 1;
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], ****************************************************************\n"));
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], Ant PG Num/ Ant Mech/ Ant Pos = %d/ %d/ %d\n", \
+			pBoardInfo->pgAntNum, pBoardInfo->btdmAntNum, pBoardInfo->btdmAntPos));
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], BT stack/ hci ext ver = %s / %d\n", \
+			((pStackInfo->bProfileNotified)? "Yes":"No"), pStackInfo->hciVersion));
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_BT_PATCH_VER, &btPatchVer);
+		pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_FW_VER, &fwVer);
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], CoexVer/ FwVer/ PatchVer = %d_%x/ 0x%x/ 0x%x(%d)\n", \
+			GLCoexVerDate8821aCsr2Ant, GLCoexVer8821aCsr2Ant, fwVer, btPatchVer, btPatchVer));
+		BTC_PRINT(BTC_MSG_INTERFACE, INTF_INIT, ("[BTCoex], ****************************************************************\n"));
+	}
+
+	//halbtc8821aCsr2ant_QueryBtInfo(pBtCoexist);
+	//halbtc8821aCsr2ant_RunCoexistMechanism(pBtCoexist);
+	halbtc8821aCsr2ant_MonitorBtCtr(pBtCoexist);
+	halbtc8821aCsr2ant_MonitorBtEnableDisable(pBtCoexist);
+}
+
+
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.h
new file mode 100644
index 000000000000..aeebf82196da
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtc8821aCsr2Ant.h
@@ -0,0 +1,207 @@
+//===========================================
+// The following is for 8821A_CSR 2Ant BT Co-exist definition
+//===========================================
+#define	BT_INFO_8821A_CSR_2ANT_B_FTP						BIT7
+#define	BT_INFO_8821A_CSR_2ANT_B_A2DP					BIT6
+#define	BT_INFO_8821A_CSR_2ANT_B_HID						BIT5
+#define	BT_INFO_8821A_CSR_2ANT_B_SCO_BUSY				BIT4
+#define	BT_INFO_8821A_CSR_2ANT_B_ACL_BUSY				BIT3
+#define	BT_INFO_8821A_CSR_2ANT_B_INQ_PAGE				BIT2
+#define	BT_INFO_8821A_CSR_2ANT_B_SCO_ESCO				BIT1
+#define	BT_INFO_8821A_CSR_2ANT_B_CONNECTION				BIT0
+
+#define		BTC_RSSI_COEX_THRESH_TOL_8821A_CSR_2ANT		2
+
+typedef enum _BT_INFO_SRC_8821A_CSR_2ANT{
+	BT_INFO_SRC_8821A_CSR_2ANT_WIFI_FW			= 0x0,
+	BT_INFO_SRC_8821A_CSR_2ANT_BT_RSP				= 0x1,
+	BT_INFO_SRC_8821A_CSR_2ANT_BT_ACTIVE_SEND		= 0x2,
+	BT_INFO_SRC_8821A_CSR_2ANT_MAX
+}BT_INFO_SRC_8821A_CSR_2ANT,*PBT_INFO_SRC_8821A_CSR_2ANT;
+
+typedef enum _BT_8821A_CSR_2ANT_BT_STATUS{
+	BT_8821A_CSR_2ANT_BT_STATUS_IDLE				= 0x0,
+	BT_8821A_CSR_2ANT_BT_STATUS_CONNECTED_IDLE	= 0x1,
+	BT_8821A_CSR_2ANT_BT_STATUS_NON_IDLE			= 0x2,
+	BT_8821A_CSR_2ANT_BT_STATUS_MAX
+}BT_8821A_CSR_2ANT_BT_STATUS,*PBT_8821A_CSR_2ANT_BT_STATUS;
+
+typedef enum _BT_8821A_CSR_2ANT_COEX_ALGO{
+	BT_8821A_CSR_2ANT_COEX_ALGO_UNDEFINED			= 0x0,
+	BT_8821A_CSR_2ANT_COEX_ALGO_SCO				= 0x1,
+	BT_8821A_CSR_2ANT_COEX_ALGO_HID				= 0x2,
+	BT_8821A_CSR_2ANT_COEX_ALGO_A2DP				= 0x3,
+	BT_8821A_CSR_2ANT_COEX_ALGO_A2DP_PANHS		= 0x4,
+	BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR			= 0x5,
+	BT_8821A_CSR_2ANT_COEX_ALGO_PANHS			= 0x6,
+	BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_A2DP		= 0x7,
+	BT_8821A_CSR_2ANT_COEX_ALGO_PANEDR_HID		= 0x8,
+	BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP_PANEDR	= 0x9,
+	BT_8821A_CSR_2ANT_COEX_ALGO_HID_A2DP			= 0xa,
+	BT_8821A_CSR_2ANT_COEX_ALGO_MAX				= 0xb,
+}BT_8821A_CSR_2ANT_COEX_ALGO,*PBT_8821A_CSR_2ANT_COEX_ALGO;
+
+typedef struct _COEX_DM_8821A_CSR_2ANT{
+	// fw mechanism
+	BOOLEAN		bPreDecBtPwr;
+	BOOLEAN		bCurDecBtPwr;
+	u1Byte		preFwDacSwingLvl;
+	u1Byte		curFwDacSwingLvl;
+	BOOLEAN		bCurIgnoreWlanAct;
+	BOOLEAN		bPreIgnoreWlanAct;
+	u1Byte		prePsTdma;
+	u1Byte		curPsTdma;
+	u1Byte		psTdmaPara[6];
+	u1Byte		psTdmaDuAdjType;
+	BOOLEAN		bResetTdmaAdjust;
+	BOOLEAN		bPrePsTdmaOn;
+	BOOLEAN		bCurPsTdmaOn;
+	BOOLEAN		bPreBtAutoReport;
+	BOOLEAN		bCurBtAutoReport;
+
+	// sw mechanism
+	BOOLEAN		bPreRfRxLpfShrink;
+	BOOLEAN		bCurRfRxLpfShrink;
+	u4Byte		btRf0x1eBackup;
+	BOOLEAN 	bPreLowPenaltyRa;
+	BOOLEAN		bCurLowPenaltyRa;
+	BOOLEAN		bPreDacSwingOn;
+	u4Byte		preDacSwingLvl;
+	BOOLEAN		bCurDacSwingOn;
+	u4Byte		curDacSwingLvl;
+	BOOLEAN		bPreAdcBackOff;
+	BOOLEAN		bCurAdcBackOff;
+	BOOLEAN 	bPreAgcTableEn;
+	BOOLEAN		bCurAgcTableEn;
+	u4Byte		preVal0x6c0;
+	u4Byte		curVal0x6c0;
+	u4Byte		preVal0x6c4;
+	u4Byte		curVal0x6c4;
+	u4Byte		preVal0x6c8;
+	u4Byte		curVal0x6c8;
+	u1Byte		preVal0x6cc;
+	u1Byte		curVal0x6cc;
+	BOOLEAN		bLimitedDig;
+
+	u4Byte		preRaMask;
+	u4Byte		curRaMask;
+
+	u1Byte curAmpduNumType;
+	u1Byte preAmpduNumType;
+	u2Byte backupAmpduMaxNum;
+
+	u1Byte curAmpduTimeType;
+	u1Byte preAmpduTimeType;
+	u1Byte backupAmpduMaxTime;
+
+	u1Byte 		curArfrType;
+	u1Byte 		preArfrType;
+	u4Byte		backupArfrCnt1;
+	u4Byte		backupArfrCnt2;
+
+	u1Byte		curRetryLimitType;
+	u1Byte		preRetryLimitType;
+	u2Byte		backupRetryLimit;
+
+	// algorithm related
+	u1Byte		preAlgorithm;
+	u1Byte		curAlgorithm;
+	u1Byte		btStatus;
+	u1Byte		wifiChnlInfo[3];
+} COEX_DM_8821A_CSR_2ANT, *PCOEX_DM_8821A_CSR_2ANT;
+
+typedef struct _COEX_STA_8821A_CSR_2ANT{
+	BOOLEAN					bBtLinkExist;
+	BOOLEAN					bScoExist;
+	BOOLEAN					bA2dpExist;
+	BOOLEAN					bSlave;
+	BOOLEAN					bHidExist;
+	BOOLEAN					bPanExist;
+
+	BOOLEAN					bUnderLps;
+	BOOLEAN					bUnderIps;
+	u4Byte					highPriorityTx;
+	u4Byte					highPriorityRx;
+	u4Byte					lowPriorityTx;
+	u4Byte					lowPriorityRx;
+	u1Byte					btRssi;
+	u1Byte					preBtRssiState;
+	u1Byte					preWifiRssiState[4];
+	BOOLEAN					bC2hBtInfoReqSent;
+	u1Byte					btInfoC2h[BT_INFO_SRC_8821A_CSR_2ANT_MAX][10];
+	u4Byte					btInfoC2hCnt[BT_INFO_SRC_8821A_CSR_2ANT_MAX];
+	BOOLEAN					bC2hBtInquiryPage;
+	u1Byte					btRetryCnt;
+	u1Byte					btInfoExt;
+}COEX_STA_8821A_CSR_2ANT, *PCOEX_STA_8821A_CSR_2ANT;
+
+//===========================================
+// The following is interface which will notify coex module.
+//===========================================
+VOID
+EXhalbtc8821aCsr2ant_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8821aCsr2ant_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
+EXhalbtc8821aCsr2ant_InitCoexDm(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtc8821aCsr2ant_IpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8821aCsr2ant_LpsNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8821aCsr2ant_ScanNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8821aCsr2ant_ConnectNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte			type
+	);
+VOID
+EXhalbtc8821aCsr2ant_MediaStatusNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8821aCsr2ant_SpecialPacketNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				type
+	);
+VOID
+EXhalbtc8821aCsr2ant_BtInfoNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	pu1Byte			tmpBuf,
+	IN	u1Byte			length
+	);
+VOID
+EXhalbtc8821aCsr2ant_HaltNotify(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8821aCsr2ant_PnpNotify(
+	IN	PBTC_COEXIST			pBtCoexist,
+	IN	u1Byte				pnpState
+	);
+VOID
+EXhalbtc8821aCsr2ant_Periodical(
+	IN	PBTC_COEXIST			pBtCoexist
+	);
+VOID
+EXhalbtc8821aCsr2ant_DisplayCoexInfo(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtcOutSrc.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtcOutSrc.h
index 9a5638197863..9da0b6746d02 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtcOutSrc.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/HalBtcOutSrc.h
@@ -4,6 +4,9 @@
 #define		NORMAL_EXEC					FALSE
 #define		FORCE_EXEC						TRUE
 
+#define		BTC_RF_OFF					0x0
+#define		BTC_RF_ON					0x1
+
 #define		BTC_RF_A					0x0
 #define		BTC_RF_B					0x1
 #define		BTC_RF_C					0x2
@@ -42,6 +45,15 @@ typedef enum _BTC_POWERSAVE_TYPE{
 	BTC_PS_MAX
 } BTC_POWERSAVE_TYPE, *PBTC_POWERSAVE_TYPE;
 
+typedef enum _BTC_BT_REG_TYPE{
+	BTC_BT_REG_RF						= 0,
+	BTC_BT_REG_MODEM					= 1,
+	BTC_BT_REG_BLUEWIZE					= 2,
+	BTC_BT_REG_VENDOR					= 3,
+	BTC_BT_REG_LE						= 4,
+	BTC_BT_REG_MAX
+} BTC_BT_REG_TYPE, *PBTC_BT_REG_TYPE;
+
 typedef enum _BTC_CHIP_INTERFACE{
 	BTC_INTF_UNKNOWN	= 0,
 	BTC_INTF_PCI			= 1,
@@ -156,7 +168,8 @@ typedef struct _BTC_BOARD_INFO{
 	u1Byte				pgAntNum;	// pg ant number
 	u1Byte				btdmAntNum;	// ant number for btdm
 	u1Byte				btdmAntPos;		//Bryant Add to indicate Antenna Position for (pgAntNum = 2) && (btdmAntNum =1)  (DPDT+1Ant case)
-	BOOLEAN				bBtExist;
+	u1Byte				singleAntPath;	// current used for 8723b only, 1=>s0,  0=>s1
+	//BOOLEAN				bBtExist;
 } BTC_BOARD_INFO, *PBTC_BOARD_INFO;
 
 typedef enum _BTC_DBG_OPCODE{
@@ -190,10 +203,18 @@ typedef enum _BTC_WIFI_ROLE{
 	BTC_ROLE_MAX
 }BTC_WIFI_ROLE,*PBTC_WIFI_ROLE;
 
+typedef enum _BTC_WIRELESS_FREQ{
+	BTC_FREQ_2_4G					= 0x0,
+	BTC_FREQ_5G						= 0x1,
+	BTC_FREQ_MAX	
+}BTC_WIRELESS_FREQ,*PBTC_WIRELESS_FREQ;
+
 typedef enum _BTC_WIFI_BW_MODE{
 	BTC_WIFI_BW_LEGACY					= 0x0,
 	BTC_WIFI_BW_HT20					= 0x1,
 	BTC_WIFI_BW_HT40					= 0x2,
+	BTC_WIFI_BW_HT80					= 0x3,
+	BTC_WIFI_BW_HT160					= 0x4,
 	BTC_WIFI_BW_MAX	
 }BTC_WIFI_BW_MODE,*PBTC_WIFI_BW_MODE;
 
@@ -209,6 +230,24 @@ typedef enum _BTC_WIFI_PNP{
 	BTC_WIFI_PNP_MAX
 }BTC_WIFI_PNP,*PBTC_WIFI_PNP;
 
+//for 8723b-d cut large current issue
+typedef enum _BT_WIFI_COEX_STATE{
+	BTC_WIFI_STAT_INIT,
+	BTC_WIFI_STAT_IQK,
+	BTC_WIFI_STAT_NORMAL_OFF,
+	BTC_WIFI_STAT_MP_OFF,
+	BTC_WIFI_STAT_NORMAL,
+	BTC_WIFI_STAT_ANT_DIV,
+	BTC_WIFI_STAT_MAX
+}BT_WIFI_COEX_STATE,*PBT_WIFI_COEX_STATE;
+
+typedef enum _BT_ANT_TYPE{
+	BTC_ANT_TYPE_0,
+	BTC_ANT_TYPE_1,
+	BTC_ANT_TYPE_2,
+	BTC_ANT_TYPE_MAX
+}BT_ANT_TYPE,*PBT_ANT_TYPE;
+
 // defined for BFP_BTC_GET
 typedef enum _BTC_GET_TYPE{
 	// type BOOLEAN
@@ -225,6 +264,7 @@ typedef enum _BTC_GET_TYPE{
 	BTC_GET_BL_WIFI_ENABLE_ENCRYPTION,
 	BTC_GET_BL_WIFI_UNDER_B_MODE,
 	BTC_GET_BL_EXT_SWITCH,
+	BTC_GET_BL_WIFI_IS_IN_MP_MODE,
 
 	// type s4Byte
 	BTC_GET_S4_WIFI_RSSI,
@@ -243,6 +283,7 @@ typedef enum _BTC_GET_TYPE{
 	BTC_GET_U1_WIFI_HS_CHNL,
 	BTC_GET_U1_MAC_PHY_MODE,
 	BTC_GET_U1_AP_NUM,
+	BTC_GET_U1_ANT_TYPE,
 
 	//===== for 1Ant ======
 	BTC_GET_U1_LPS_MODE,
@@ -260,6 +301,8 @@ typedef enum _BTC_SET_TYPE{
 	BTC_SET_BL_TO_REJ_AP_AGG_PKT,
 	BTC_SET_BL_BT_CTRL_AGG_SIZE,
 	BTC_SET_BL_INC_SCAN_DEV_NUM,
+	BTC_SET_BL_BT_TX_RX_MASK,
+	BTC_SET_BL_MIRACAST_PLUS_BT,
 
 	// type u1Byte
 	BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON,
@@ -285,6 +328,7 @@ typedef enum _BTC_SET_TYPE{
 	// BT Coex related
 	BTC_SET_ACT_CTRL_BT_INFO,
 	BTC_SET_ACT_CTRL_BT_COEX,
+	BTC_SET_ACT_CTRL_8723B_ANT,
 	//=================
 	BTC_SET_MAX
 }BTC_SET_TYPE,*PBTC_SET_TYPE;
@@ -292,7 +336,7 @@ typedef enum _BTC_SET_TYPE{
 typedef enum _BTC_DBG_DISP_TYPE{
 	BTC_DBG_DISP_COEX_STATISTICS				= 0x0,
 	BTC_DBG_DISP_BT_LINK_INFO				= 0x1,
-	BTC_DBG_DISP_FW_PWR_MODE_CMD			= 0x2,
+	BTC_DBG_DISP_WIFI_STATUS				= 0x2,
 	BTC_DBG_DISP_MAX
 }BTC_DBG_DISP_TYPE,*PBTC_DBG_DISP_TYPE;
 
@@ -382,6 +426,12 @@ typedef VOID
 	IN	u4Byte			Data
 	);
 typedef VOID
+(*BFP_BTC_LOCAL_REG_W1)(
+	IN 	PVOID			pBtcContext,
+	IN	u4Byte			RegAddr,
+	IN	u1Byte			Data
+	);
+typedef VOID
 (*BFP_BTC_SET_BB_REG)(
 	IN 	PVOID			pBtcContext,
 	IN	u4Byte			RegAddr,
@@ -410,13 +460,6 @@ typedef u4Byte
 	IN	u4Byte			BitMask
 	);
 typedef VOID
-(*BFP_BTC_SET_BT_REG)(	
-	IN 	PVOID			pBtcContext,
-	IN	u1Byte			RegType,
-	IN	u4Byte			RegAddr,
-	IN	u4Byte			Data
-	);
-typedef VOID
 (*BFP_BTC_FILL_H2C)(
 	IN 	PVOID			pBtcContext,
 	IN	u1Byte 			elementId,
@@ -438,6 +481,19 @@ typedef	BOOLEAN
 	OUT	PVOID			pInBuf
 	);
 typedef VOID
+(*BFP_BTC_SET_BT_REG)(
+	IN 	PVOID			pBtcContext,
+	IN	u1Byte			regType,
+	IN	u4Byte			offset,
+	IN	u4Byte			value
+	);
+typedef u4Byte 
+(*BFP_BTC_GET_BT_REG)(
+	IN 	PVOID			pBtcContext,
+	IN	u1Byte			regType,
+	IN	u4Byte			offset
+	);
+typedef VOID
 (*BFP_BTC_DISP_DBG_MSG)(
 	IN	PVOID			pBtCoexist,
 	IN	u1Byte			dispType
@@ -449,8 +505,10 @@ typedef struct _BTC_BT_INFO{
 	u1Byte					rssiAdjustFor1AntCoexType;
 	BOOLEAN					bPreBtCtrlAggBufSize;
 	BOOLEAN					bBtCtrlAggBufSize;
+	BOOLEAN					bPreRejectAggPkt;
 	BOOLEAN					bRejectAggPkt;
 	BOOLEAN					bIncreaseScanDevNum;
+	BOOLEAN					bBtTxRxMask;
 	u1Byte					preAggBufSize;
 	u1Byte					aggBufSize;
 	BOOLEAN					bBtBusy;
@@ -458,6 +516,8 @@ typedef struct _BTC_BT_INFO{
 	u2Byte					btHciVer;
 	u2Byte					btRealFwVer;
 	u1Byte					btFwVer;
+	u4Byte					getBtFwVerCnt;
+	BOOLEAN					bMiracastPlusBt;
 
 	BOOLEAN					bBtDisableLowPwr;
 
@@ -486,6 +546,7 @@ typedef struct _BTC_STACK_INFO{
 
 typedef struct _BTC_BT_LINK_INFO{
 	BOOLEAN					bBtLinkExist;
+	BOOLEAN					bBtHiPriLinkExist;
 	BOOLEAN					bScoExist;
 	BOOLEAN					bScoOnly;
 	BOOLEAN					bA2dpExist;
@@ -494,10 +555,14 @@ typedef struct _BTC_BT_LINK_INFO{
 	BOOLEAN					bHidOnly;
 	BOOLEAN					bPanExist;
 	BOOLEAN					bPanOnly;
+	BOOLEAN					bSlaveRole;
+	BOOLEAN					bAclBusy;
 } BTC_BT_LINK_INFO, *PBTC_BT_LINK_INFO;
 
 typedef struct _BTC_STATISTICS{
 	u4Byte					cntBind;
+	u4Byte					cntPowerOn;
+	u4Byte					cntPreLoadFirmware;
 	u4Byte					cntInitHwConfig;
 	u4Byte					cntInitCoexDm;
 	u4Byte					cntIpsNotify;
@@ -507,6 +572,7 @@ typedef struct _BTC_STATISTICS{
 	u4Byte					cntMediaStatusNotify;
 	u4Byte					cntSpecialPacketNotify;
 	u4Byte					cntBtInfoNotify;
+	u4Byte					cntRfStatusNotify;
 	u4Byte					cntPeriodical;
 	u4Byte					cntCoexDmSwitch;
 	u4Byte					cntStackOperationNotify;
@@ -538,6 +604,7 @@ typedef struct _BTC_COEXIST{
 	BFP_BTC_W2			fBtcWrite2Byte;
 	BFP_BTC_R4			fBtcRead4Byte;
 	BFP_BTC_W4			fBtcWrite4Byte;
+	BFP_BTC_LOCAL_REG_W1	fBtcWriteLocalReg1Byte;
 	// read/write bb related
 	BFP_BTC_SET_BB_REG	fBtcSetBbReg;
 	BFP_BTC_GET_BB_REG	fBtcGetBbReg;
@@ -546,9 +613,6 @@ typedef struct _BTC_COEXIST{
 	BFP_BTC_SET_RF_REG	fBtcSetRfReg;
 	BFP_BTC_GET_RF_REG	fBtcGetRfReg;
 	
-	//write bt reg related
-	BFP_BTC_SET_BT_REG	fBtcSetBtReg;
-	
 	// fill h2c related
 	BFP_BTC_FILL_H2C		fBtcFillH2c;
 	// other
@@ -556,19 +620,31 @@ typedef struct _BTC_COEXIST{
 	// normal get/set related
 	BFP_BTC_GET			fBtcGet;
 	BFP_BTC_SET			fBtcSet;
+
+	BFP_BTC_GET_BT_REG	fBtcGetBtReg;
+	BFP_BTC_SET_BT_REG	fBtcSetBtReg;
 } BTC_COEXIST, *PBTC_COEXIST;
 
 extern BTC_COEXIST				GLBtCoexist;
 
 BOOLEAN
 EXhalbtcoutsrc_InitlizeVariables(
-	IN	PVOID		Adapter
+	IN	PVOID		Adapter	
 	);
 VOID
-EXhalbtcoutsrc_InitHwConfig(
+EXhalbtcoutsrc_PowerOnSetting(
+	IN	PBTC_COEXIST		pBtCoexist
+	);
+VOID
+EXhalbtcoutsrc_PreLoadFirmware(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
+EXhalbtcoutsrc_InitHwConfig(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	BOOLEAN				bWifiOnly
+	);
+VOID
 EXhalbtcoutsrc_InitCoexDm(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
@@ -609,6 +685,11 @@ EXhalbtcoutsrc_BtInfoNotify(
 	IN	u1Byte			length
 	);
 VOID
+EXhalbtcoutsrc_RfStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte 				type
+	);
+VOID
 EXhalbtcoutsrc_StackOperationNotify(
 	IN	PBTC_COEXIST		pBtCoexist,
 	IN	u1Byte			type
@@ -618,18 +699,13 @@ EXhalbtcoutsrc_HaltNotify(
 	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
-EXhalbtcoutsrc_SwitchGntBt(
-	IN	PBTC_COEXIST		pBtCoexist
-	);
-VOID
 EXhalbtcoutsrc_PnpNotify(
 	IN	PBTC_COEXIST		pBtCoexist,
 	IN	u1Byte			pnpState
 	);
 VOID
 EXhalbtcoutsrc_CoexDmSwitch(
-	IN	PBTC_COEXIST		pBtCoexist,
-	IN	BOOLEAN 			antInverse
+	IN	PBTC_COEXIST		pBtCoexist
 	);
 VOID
 EXhalbtcoutsrc_Periodical(
@@ -659,10 +735,12 @@ VOID
 EXhalbtcoutsrc_UpdateMinBtRssi(
 	IN	s1Byte	btRssi
 	);
+#if 0
 VOID
 EXhalbtcoutsrc_SetBtExist(
 	IN	BOOLEAN		bBtExist
 	);
+#endif
 VOID
 EXhalbtcoutsrc_SetChipType(
 	IN	u1Byte		chipType
@@ -670,8 +748,11 @@ EXhalbtcoutsrc_SetChipType(
 VOID
 EXhalbtcoutsrc_SetAntNum(
 	IN	u1Byte		type,
-	IN	u1Byte		antNum,
-	IN	BOOLEAN 	antInverse
+	IN	u1Byte		antNum
+	);
+VOID
+EXhalbtcoutsrc_SetSingleAntPath(
+	IN	u1Byte		singleAntPath
 	);
 VOID
 EXhalbtcoutsrc_DisplayBtCoexInfo(
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/Mp_Precomp.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/Mp_Precomp.h
index fdd940611f6f..b1fc17ba1484 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/Mp_Precomp.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC-BTCoexist/Mp_Precomp.h
@@ -52,5 +52,6 @@
 #include "HalBtc8812a2Ant.h"
 #include "HalBtc8821a1Ant.h"
 #include "HalBtc8821a2Ant.h"
+#include "HalBtc8821aCsr2Ant.h"
 
 #endif // __MP_PRECOMP_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/HalPhyRf.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/HalPhyRf.c
index d74846cb3047..3070e792b9f1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/HalPhyRf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/HalPhyRf.c
@@ -18,8 +18,8 @@
  *
  ******************************************************************************/
 
-//#include "Mp_Precomp.h"
-#include "odm_precomp.h"
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
 
 
 #define 	CALCULATE_SWINGTALBE_OFFSET(_offset, _direction, _size, _deltaThermal) \
@@ -161,7 +161,7 @@ ODM_TXPowerTrackingCallback_ThermalMeter(
 #endif
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	if ( *(pDM_Odm->mp_mode) == 1)
+	if (pDM_Odm->mp_mode == TRUE)
 #endif
 		// <Kordan> RFCalibrateInfo.RegA24 will be initialized when ODM HW configuring, but MP configures with para files.
 		pDM_Odm->RFCalibrateInfo.RegA24 = 0x090e1317;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/Mp_Precomp.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/Mp_Precomp.h
new file mode 100644
index 000000000000..43ea006e752b
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/Mp_Precomp.h
@@ -0,0 +1,24 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//#include <Precomp.h>
+//#include "phydm_precomp.h"
+//#include "../phydm_precomp.h"
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.c
new file mode 100644
index 000000000000..64ed3bc57493
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.c
@@ -0,0 +1,880 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+
+VOID
+Phydm_CheckAdaptivity(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)
+	{
+		if(pDM_Odm->bAdaOn == TRUE)
+		{
+			if(pDM_Odm->DynamicLinkAdaptivity == TRUE)
+			{
+				if(pDM_Odm->bLinked && pDM_Odm->bCheck == FALSE)
+				{
+					Phydm_NHMCounterStatistics(pDM_Odm);
+					Phydm_CheckEnvironment(pDM_Odm);
+				}
+				else if(!pDM_Odm->bLinked)
+				{
+				pDM_Odm->bCheck = FALSE;
+				}
+			}
+			else
+			{
+				Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+				pDM_Odm->adaptivity_flag = TRUE;
+			}
+		}
+		else
+		{
+			Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+			pDM_Odm->adaptivity_flag = FALSE;
+		}
+	}	
+}
+
+VOID
+Phydm_NHMCounterStatisticsInit(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+	{
+		//PHY parameters initialize for ac series
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11AC+2, 0xC350);	//0x990[31:16]=0xC350	Time duration for NHM unit: us, 0xc350=200ms
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC+2, 0xffff);	//0x994[31:16]=0xffff	th_9, th_10
+		//ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC, 0xffffff5c);	//0x998=0xffffff5c 		th_3, th_2, th_1, th_0
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11AC, 0xffffff50);	//0x998=0xffffff52 		th_3, th_2, th_1, th_0
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11AC, 0xffffffff);	//0x99c=0xffffffff		th_7, th_6, th_5, th_4
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH8_11AC, bMaskByte0, 0xff);		//0x9a0[7:0]=0xff		th_8
+		//ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT8|BIT9|BIT10, 0x7);	//0x994[9:8]=3			enable CCX
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT8|BIT9|BIT10, 0x1);	//0x994[10:8]=1	ignoreCCA ignore PHYTXON	enable CCX
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_9E8_11AC, BIT0, 0x1);		//0x9e8[7]=1			max power among all RX ants	
+				
+	}
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+		//PHY parameters initialize for n series
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N+2, 0xC350);	//0x894[31:16]=0x0xC350	Time duration for NHM unit: us, 0xc350=200ms
+		//ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N+2, 0x4e20);	//0x894[31:16]=0x4e20	Time duration for NHM unit: 4us, 0x4e20=80ms
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N+2, 0xffff);	//0x890[31:16]=0xffff	th_9, th_10
+		//ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff5c);	//0x898=0xffffff5c 		th_3, th_2, th_1, th_0
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH3_TO_TH0_11N, 0xffffff50);	//0x898=0xffffff52 		th_3, th_2, th_1, th_0
+		ODM_Write4Byte(pDM_Odm, ODM_REG_NHM_TH7_TO_TH4_11N, 0xffffffff);	//0x89c=0xffffffff		th_7, th_6, th_5, th_4
+		ODM_SetBBReg(pDM_Odm, ODM_REG_FPGA0_IQK_11N, bMaskByte0, 0xff);		//0xe28[7:0]=0xff		th_8
+		//ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT10|BIT9|BIT8, 0x7);	//0x890[9:8]=3			enable CCX
+		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT10|BIT9|BIT8, 0x1);	//0x890[10:8]=1		ignoreCCA ignore PHYTXON	enable CCX
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT7, 0x1);		//0xc0c[7]=1			max power among all RX ants				
+	}
+}
+
+VOID
+Phydm_NHMCounterStatistics(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_NHM_CNT))
+		return;
+
+	// Get NHM report
+	Phydm_GetNHMCounterStatistics(pDM_Odm);
+
+	// Reset NHM counter
+	Phydm_NHMCounterStatisticsReset(pDM_Odm);
+}
+
+VOID
+Phydm_GetNHMCounterStatistics(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte		value32 = 0;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_NHM_CNT_11AC, bMaskDWord);
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_NHM_CNT_11N, bMaskDWord);
+
+	pDM_Odm->NHM_cnt_0 = (u1Byte)(value32 & bMaskByte0);
+	pDM_Odm->NHM_cnt_1 = (u1Byte)((value32 & bMaskByte1)>>8);
+
+}
+
+VOID
+Phydm_NHMCounterStatisticsReset(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+	{           		
+    		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT1, 0);
+    		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT1, 1);
+	}
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+    		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 0);
+    		ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT1, 1);
+	}
+}
+
+VOID
+Phydm_NHMBBInit(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	pDM_Odm->adaptivity_flag = FALSE;
+	pDM_Odm->tolerance_cnt = 3;
+	pDM_Odm->NHMLastTxOkcnt = 0;
+	pDM_Odm->NHMLastRxOkcnt = 0;
+	pDM_Odm->NHMCurTxOkcnt = 0;
+	pDM_Odm->NHMCurRxOkcnt = 0;
+}
+
+VOID
+Phydm_SetEDCCAThreshold(
+	IN	PVOID	pDM_VOID,
+	IN	s1Byte	H2L,
+	IN	s1Byte	L2H
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		{
+		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)L2H);
+		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)H2L);
+		}
+	else if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		{
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, bMaskByte0, (u1Byte)L2H);
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, bMaskByte1, (u1Byte)H2L);
+		}
+}
+
+VOID
+Phydm_SetTRxMux(
+	IN	PVOID				pDM_VOID,
+	IN	PhyDM_Trx_MUX_Type	txMode,
+	IN	PhyDM_Trx_MUX_Type	rxMode
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N, BIT3|BIT2|BIT1, txMode);	// set TXmod to standby mode to remove outside noise affect
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N, BIT22|BIT21|BIT20, rxMode);	// set RXmod to standby mode to remove outside noise affect
+		if(pDM_Odm->RFType > ODM_1T1R)
+		{
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N_B, BIT3|BIT2|BIT1, txMode);	// set TXmod to standby mode to remove outside noise affect
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_RPT_FORMAT_11N_B, BIT22|BIT21|BIT20, rxMode);	// set RXmod to standby mode to remove outside noise affect
+		}
+	}
+	else if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+	{
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC, BIT11|BIT10|BIT9|BIT8, txMode);	// set TXmod to standby mode to remove outside noise affect
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC, BIT7|BIT6|BIT5|BIT4, rxMode);	// set RXmod to standby mode to remove outside noise affect
+		if(pDM_Odm->RFType > ODM_1T1R)
+		{
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC_B, BIT11|BIT10|BIT9|BIT8, txMode);	// set TXmod to standby mode to remove outside noise affect
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC_B, BIT7|BIT6|BIT5|BIT4, rxMode);	// set RXmod to standby mode to remove outside noise affect
+		}
+	}
+
+}
+
+VOID
+Phydm_MACEDCCAState(
+	IN	PVOID					pDM_VOID,
+	IN	PhyDM_MACEDCCA_Type		State
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(State == PhyDM_IGNORE_EDCCA)
+	{
+		ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 1);	//ignore EDCCA	reg520[15]=1
+		ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 0);		//reg524[11]=0
+	}
+	else		// don't set MAC ignore EDCCA signal
+	{
+		ODM_SetMACReg(pDM_Odm, REG_TX_PTCL_CTRL, BIT15, 0);	//don't ignore EDCCA	 reg520[15]=0
+		ODM_SetMACReg(pDM_Odm, REG_RD_CTRL, BIT11, 1);	//reg524[11]=1	
+	}
+
+	pDM_Odm->EDCCA_enable_state = State;
+	
+	ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("EDCCA enable State = %d \n", State));
+
+}
+
+BOOLEAN
+Phydm_CalNHMcnt(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte			Base = 0;
+
+	Base = pDM_Odm->NHM_cnt_0 + pDM_Odm->NHM_cnt_1;
+
+	if(Base != 0)
+	{
+		pDM_Odm->NHM_cnt_0 = ((pDM_Odm->NHM_cnt_0) << 8) / Base;
+		pDM_Odm->NHM_cnt_1 = ((pDM_Odm->NHM_cnt_1) << 8) / Base;
+	}
+	if((pDM_Odm->NHM_cnt_0 - pDM_Odm->NHM_cnt_1) >= 100)
+		return TRUE;			// clean environment
+	else
+		return FALSE;		//noisy environment
+
+}
+
+
+VOID
+Phydm_CheckEnvironment(
+	IN	PVOID	pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	BOOLEAN 	isCleanEnvironment = FALSE;
+	u1Byte		i, clean = 0;
+
+	if(pDM_Odm->bFirstLink == TRUE)
+	{
+		pDM_Odm->adaptivity_flag = TRUE;
+		pDM_Odm->bFirstLink = FALSE;
+		return;
+	}
+	else
+	{
+		if(pDM_Odm->NHMWait < 3)			// Start enter NHM after 4 NHMWait
+		{
+			pDM_Odm->NHMWait ++;
+			Phydm_NHMCounterStatistics(pDM_Odm);
+			return;
+		}
+		else
+		{
+			Phydm_NHMCounterStatistics(pDM_Odm);
+			isCleanEnvironment = Phydm_CalNHMcnt(pDM_Odm);
+			if(isCleanEnvironment == TRUE)
+			{
+				Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+				pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_backup;			//mode 1
+				pDM_Odm->TH_EDCCA_HL_diff= pDM_Odm->TH_EDCCA_HL_diff_backup;
+#endif
+				pDM_Odm->adaptivity_flag = TRUE;
+			}
+			else
+			{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+				Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+#else
+				Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+				pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_mode2;			// for AP mode 2
+				pDM_Odm->TH_EDCCA_HL_diff= pDM_Odm->TH_EDCCA_HL_diff_mode2;
+#endif
+				pDM_Odm->adaptivity_flag = FALSE;
+			}
+
+			pDM_Odm->bFirstLink = TRUE;
+			pDM_Odm->bCheck = TRUE;
+		}
+		
+	}
+
+
+}
+
+
+VOID
+Phydm_NHMBB(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	BOOLEAN		bCleanEnvironment;
+
+	bCleanEnvironment = Phydm_CalNHMcnt(pDM_Odm);
+
+	pDM_Odm->NHMCurTxOkcnt = *(pDM_Odm->pNumTxBytesUnicast) - pDM_Odm->NHMLastTxOkcnt;
+	pDM_Odm->NHMCurRxOkcnt = *(pDM_Odm->pNumRxBytesUnicast) - pDM_Odm->NHMLastRxOkcnt;
+	pDM_Odm->NHMLastTxOkcnt = *(pDM_Odm->pNumTxBytesUnicast);
+	pDM_Odm->NHMLastRxOkcnt = *(pDM_Odm->pNumRxBytesUnicast);	
+	ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("cnt_0=%d, cnt_1=%d, bCleanEnvironment = %d, NHMCurTxOkcnt = %llu, NHMCurRxOkcnt = %llu\n", 
+		pDM_Odm->NHM_cnt_0, pDM_Odm->NHM_cnt_1, bCleanEnvironment, pDM_Odm->NHMCurTxOkcnt, pDM_Odm->NHMCurRxOkcnt));
+
+	if(pDM_Odm->NHMWait < 4)			// Start enter NHM after 4 NHMWait
+	{
+		pDM_Odm->NHMWait ++;
+		Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+	}
+	else if ( ((pDM_Odm->NHMCurTxOkcnt>>10) > 2) && ((pDM_Odm->NHMCurTxOkcnt) + 1 > (u8Byte)(pDM_Odm->NHMCurRxOkcnt<<2) + 1))		//Tx > 4*Rx and Tx > 2Mb possible for adaptivity test
+	{
+		if(bCleanEnvironment == TRUE || pDM_Odm->adaptivity_flag == TRUE)
+		{
+			//Enable EDCCA since it is possible running Adaptivity testing
+			pDM_Odm->adaptivity_flag = TRUE;
+			Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+			pDM_Odm->tolerance_cnt = 0;
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+			pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_backup;
+			pDM_Odm->TH_EDCCA_HL_diff = pDM_Odm->TH_EDCCA_HL_diff_backup ;
+#endif
+            	}
+		else
+		{
+			if(pDM_Odm->tolerance_cnt < 3)
+				pDM_Odm->tolerance_cnt ++;
+			else
+			{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+			pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_mode2;
+			pDM_Odm->TH_EDCCA_HL_diff = pDM_Odm->TH_EDCCA_HL_diff_mode2 ;
+#else    			
+			Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+#endif
+            		pDM_Odm->adaptivity_flag = FALSE;
+			}
+		}
+	}
+	else	// TX<RX 
+	{
+		if(pDM_Odm->adaptivity_flag == TRUE && bCleanEnvironment == FALSE)
+		{
+			Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+			pDM_Odm->tolerance_cnt = 0;
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+			pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_backup;
+			pDM_Odm->TH_EDCCA_HL_diff = pDM_Odm->TH_EDCCA_HL_diff_backup ;
+#endif
+		}
+#if(DM_ODM_SUPPORT_TYPE & ODM_AP)		// for repeater mode add by YuChen 2014.06.23
+#ifdef UNIVERSAL_REPEATER
+		else if((bCleanEnvironment == TRUE) && (pDM_Odm->VXD_bLinked) && ((pDM_Odm->NHMCurTxOkcnt>>10) > 1))		// clean environment and VXD linked and Tx TP>1Mb
+		{
+			pDM_Odm->adaptivity_flag = TRUE;
+			Phydm_MACEDCCAState(pDM_Odm, PhyDM_DONT_IGNORE_EDCCA);
+			pDM_Odm->tolerance_cnt = 0;
+			pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_backup;
+			pDM_Odm->TH_EDCCA_HL_diff = pDM_Odm->TH_EDCCA_HL_diff_backup ;
+		}
+#endif 
+#endif									// for repeater mode add by YuChen 2014.06.23
+		else
+		{
+			if(pDM_Odm->tolerance_cnt < 3)
+				pDM_Odm->tolerance_cnt ++;
+			else
+			{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+			pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_mode2;
+			pDM_Odm->TH_EDCCA_HL_diff = pDM_Odm->TH_EDCCA_HL_diff_mode2 ;
+#else
+			Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+#endif
+			pDM_Odm->adaptivity_flag = FALSE;
+			}
+		}
+	}
+	 
+	ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("adaptivity_flag = %d\n ", pDM_Odm->adaptivity_flag));
+}
+
+VOID
+Phydm_SearchPwdBLowerBound(
+	IN		PVOID		pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u4Byte			value32 =0;
+	u1Byte			cnt, IGI_Pause = 0x7f, IGI_Resume = 0x20, IGI = 0x50;	//IGI = 0x50 for cal EDCCA lower bound
+	u1Byte			txEdcca1 = 0, txEdcca0 = 0;
+	BOOLEAN			bAdjust=TRUE;
+	s1Byte 			TH_L2H_dmc, TH_H2L_dmc, IGI_target = 0x32;
+	s1Byte 			Diff;
+
+	Phydm_SetTRxMux(pDM_Odm, PhyDM_STANDBY_MODE, PhyDM_STANDBY_MODE);
+	ODM_Write_DIG(pDM_Odm, IGI_Pause);
+	
+	Diff = IGI_target -(s1Byte)IGI;
+	TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
+		if(TH_L2H_dmc > 10) 	
+			TH_L2H_dmc = 10;
+	TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+	Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);			
+	ODM_delay_ms(5);
+		
+		while(bAdjust)
+			{
+			for(cnt=0; cnt<20; cnt ++)
+				{
+				if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+					value32 = ODM_GetBBReg(pDM_Odm,ODM_REG_RPT_11N, bMaskDWord);
+				else if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+					value32 = ODM_GetBBReg(pDM_Odm,ODM_REG_RPT_11AC, bMaskDWord);
+			
+				if (value32 & BIT30 && (pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8723B|ODM_RTL8188E)))
+					txEdcca1 = txEdcca1 + 1;
+				else if(value32 & BIT29)
+					txEdcca1 = txEdcca1 + 1;
+				else
+					txEdcca0 = txEdcca0 + 1;
+				}
+			
+				if(txEdcca1 > 9 )
+				{
+					IGI = IGI -1;
+					TH_L2H_dmc = TH_L2H_dmc + 1;
+						if(TH_L2H_dmc > 10)
+							TH_L2H_dmc = 10;
+					TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+					Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);
+
+					txEdcca1 = 0;
+					txEdcca0 = 0;
+
+					if(TH_L2H_dmc == 10)
+						{
+						bAdjust = FALSE;
+						pDM_Odm->H2L_lb = TH_H2L_dmc;
+						pDM_Odm->L2H_lb = TH_L2H_dmc;
+						pDM_Odm->Adaptivity_IGI_upper = IGI;
+						}
+				}
+				else
+				{
+					bAdjust = FALSE;
+					pDM_Odm->H2L_lb = TH_H2L_dmc;
+					pDM_Odm->L2H_lb = TH_L2H_dmc;	
+					pDM_Odm->Adaptivity_IGI_upper = IGI;
+				}
+			}
+							
+	Phydm_SetTRxMux(pDM_Odm, PhyDM_TX_MODE, PhyDM_RX_MODE);
+	ODM_Write_DIG(pDM_Odm, IGI_Resume);
+	Phydm_SetEDCCAThreshold(pDM_Odm, 0x7f, 0x7f); // resume to no link state
+}
+
+VOID
+Phydm_AdaptivityInit(
+	IN 	PVOID	 	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(pAdapter->MgntInfo);
+	pDM_Odm->Carrier_Sense_enable = (BOOLEAN)pMgntInfo->RegEnableCarrierSense;
+	pDM_Odm->NHM_enable = (BOOLEAN)pMgntInfo->RegNHMEnable;
+	pDM_Odm->DynamicLinkAdaptivity = (BOOLEAN)pMgntInfo->RegDmLinkAdaptivity;
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+	pDM_Odm->Carrier_Sense_enable = (pDM_Odm->Adapter->registrypriv.adaptivity_mode!=0)?TRUE:FALSE;
+	pDM_Odm->NHM_enable = (BOOLEAN)pDM_Odm->Adapter->registrypriv.nhm_en;
+	pDM_Odm->DynamicLinkAdaptivity = FALSE; // Jeff please add this
+#endif
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+
+	if(pDM_Odm->Carrier_Sense_enable == FALSE)
+	{
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		if( pMgntInfo->RegL2HForAdaptivity != 0 )
+			pDM_Odm->TH_L2H_ini = pMgntInfo->RegL2HForAdaptivity;
+		else
+#endif
+			pDM_Odm->TH_L2H_ini = 0xf5; // -7
+	}
+	else
+	{
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		if( pMgntInfo->RegL2HForAdaptivity != 0 )
+			pDM_Odm->TH_L2H_ini = pMgntInfo->RegL2HForAdaptivity;
+		else
+#endif
+		pDM_Odm->TH_L2H_ini = 0xa; 
+	}
+
+	pDM_Odm->AdapEn_RSSI = 20;
+
+#if(DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if( pMgntInfo->RegHLDiffForAdaptivity != 0 )
+		pDM_Odm->TH_EDCCA_HL_diff = pMgntInfo->RegHLDiffForAdaptivity;
+	else
+#endif
+	pDM_Odm->TH_EDCCA_HL_diff = 7;
+
+	ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("TH_L2H_ini = 0x%x, TH_EDCCA_HL_diff = 0x%x\n", pDM_Odm->TH_L2H_ini, pDM_Odm->TH_EDCCA_HL_diff));
+
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv				priv = pDM_Odm->priv;
+
+	if(pDM_Odm->Carrier_Sense_enable){
+		pDM_Odm->TH_L2H_ini = 10;
+		pDM_Odm->TH_EDCCA_HL_diff = 7;		
+		pDM_Odm->AdapEn_RSSI = 30;
+	}
+	else
+	{
+		pDM_Odm->TH_L2H_ini = pDM_Odm->TH_L2H_ini_backup;	//set by mib
+		pDM_Odm->TH_EDCCA_HL_diff = 7;
+		pDM_Odm->AdapEn_RSSI = 20;
+	}
+
+	pDM_Odm->TH_L2H_ini_mode2 = 20;
+	pDM_Odm->TH_EDCCA_HL_diff_mode2 = 8;
+	//pDM_Odm->TH_L2H_ini_backup = pDM_Odm->TH_L2H_ini;
+	pDM_Odm->TH_EDCCA_HL_diff_backup = pDM_Odm->TH_EDCCA_HL_diff ;
+	if(priv->pshare->rf_ft_var.adaptivity_enable == 2)
+		pDM_Odm->DynamicLinkAdaptivity = TRUE;
+	else
+		pDM_Odm->DynamicLinkAdaptivity = FALSE;
+//	pDM_Odm->NHM_enable = FALSE;
+#endif
+
+	pDM_Odm->IGI_Base = 0x32;	
+	pDM_Odm->IGI_target = 0x1c;
+	pDM_Odm->ForceEDCCA = 0;
+	pDM_Odm->H2L_lb= 0;
+	pDM_Odm->L2H_lb= 0;
+	pDM_Odm->Adaptivity_IGI_upper = 0;
+	pDM_Odm->NHMWait = 0;
+	Phydm_NHMBBInit(pDM_Odm);
+	pDM_Odm->bCheck = FALSE;
+	pDM_Odm->bFirstLink = TRUE;
+	pDM_Odm->bAdaOn = TRUE;
+
+	ODM_SetBBReg(pDM_Odm, REG_RD_CTRL, BIT11, 1); // stop counting if EDCCA is asserted
+
+	//Search pwdB lower bound
+	{
+	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		ODM_SetBBReg(pDM_Odm,ODM_REG_DBG_RPT_11N, bMaskDWord, 0x208);
+	else if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		ODM_SetBBReg(pDM_Odm,ODM_REG_DBG_RPT_11AC, bMaskDWord, 0x209);
+	Phydm_SearchPwdBLowerBound(pDM_Odm);
+	}
+	Phydm_MACEDCCAState(pDM_Odm, PhyDM_IGNORE_EDCCA);
+}
+
+
+BOOLEAN
+Phydm_Adaptivity(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			IGI
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	s1Byte TH_L2H_dmc, TH_H2L_dmc, L2H_nolink_Band4 = 0x7f, H2L_nolink_Band4 = 0x7f;
+	s1Byte Diff, IGI_target;
+	BOOLEAN EDCCA_State = FALSE;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	BOOLEAN		bFwCurrentInPSMode=FALSE;	
+	PMGNT_INFO				pMgntInfo = &(pAdapter->MgntInfo);
+	
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_FW_PSMODE_STATUS, (pu1Byte)(&bFwCurrentInPSMode));	
+
+	// Disable EDCCA mode while under LPS mode, added by Roger, 2012.09.14.
+	if(bFwCurrentInPSMode)
+		return FALSE;
+#endif
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY))
+	{
+		ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Go to odm_DynamicEDCCA() \n"));
+		// Add by Neil Chen to enable edcca to MP Platform 
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		// Adjust EDCCA.
+		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+			Phydm_DynamicEDCCA(pDM_Odm);
+#endif
+		return FALSE;
+	}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if(pMgntInfo->RegEnableAdaptivity== 2)
+#else
+	if (pDM_Odm->Adapter->registrypriv.adaptivity_en == 2)
+#endif
+	{
+		if(pDM_Odm->Carrier_Sense_enable == FALSE)		// check domain Code for Adaptivity or CarrierSense
+		{
+			if ((*pDM_Odm->pBandType == ODM_BAND_5G) && 
+				!(pDM_Odm->odm_Regulation5G == REGULATION_ETSI || pDM_Odm->odm_Regulation5G == REGULATION_WW))
+			{
+				ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity skip 5G domain code : %d \n", pDM_Odm->odm_Regulation5G));
+				return FALSE;
+			}
+
+			else if((*pDM_Odm->pBandType == ODM_BAND_2_4G) &&
+				!(pDM_Odm->odm_Regulation2_4G == REGULATION_ETSI || pDM_Odm->odm_Regulation2_4G == REGULATION_WW))
+			{
+				ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity skip 2.4G domain code : %d \n", pDM_Odm->odm_Regulation2_4G));
+				return FALSE;
+			
+			}
+			else if ((*pDM_Odm->pBandType != ODM_BAND_2_4G) && (*pDM_Odm->pBandType != ODM_BAND_5G))
+			{
+				ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("Adaptivity neither 2G nor 5G band, return\n"));
+				return FALSE;
+			}
+		}
+		else
+		{
+			if ((*pDM_Odm->pBandType == ODM_BAND_5G) && 
+				!(pDM_Odm->odm_Regulation5G == REGULATION_ETSI || pDM_Odm->odm_Regulation5G == REGULATION_WW))
+			{
+				ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("CarrierSense skip 5G domain code : %d\n", pDM_Odm->odm_Regulation5G));
+				return FALSE;
+			}
+
+			else if((*pDM_Odm->pBandType == ODM_BAND_2_4G) &&
+				!(pDM_Odm->odm_Regulation2_4G == REGULATION_ETSI || pDM_Odm->odm_Regulation2_4G == REGULATION_WW))
+			{
+				ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("CarrierSense skip 2.4G domain code : %d\n", pDM_Odm->odm_Regulation2_4G));
+				return FALSE;
+			
+			}
+			else if ((*pDM_Odm->pBandType != ODM_BAND_2_4G) && (*pDM_Odm->pBandType != ODM_BAND_5G))
+			{
+				ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("CarrierSense neither 2G nor 5G band, return\n"));
+				return FALSE;
+			}
+		}
+	}
+#endif
+
+	
+	ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("odm_Adaptivity() =====> \n"));
+	ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("ForceEDCCA=%d, IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d, AdapEn_RSSI = %d\n", 
+		pDM_Odm->ForceEDCCA, pDM_Odm->IGI_Base, pDM_Odm->TH_L2H_ini, pDM_Odm->TH_EDCCA_HL_diff, pDM_Odm->AdapEn_RSSI));
+
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		ODM_SetBBReg(pDM_Odm, 0x800, BIT10, 0); //ADC_mask enable
+
+	if(*pDM_Odm->pBandWidth == ODM_BW20M) //CHANNEL_WIDTH_20
+		IGI_target = pDM_Odm->IGI_Base;
+	else if(*pDM_Odm->pBandWidth == ODM_BW40M)
+		IGI_target = pDM_Odm->IGI_Base + 2;
+	else if(*pDM_Odm->pBandWidth == ODM_BW80M)
+		IGI_target = pDM_Odm->IGI_Base + 2;
+	else
+		IGI_target = pDM_Odm->IGI_Base;
+	pDM_Odm->IGI_target = (u1Byte) IGI_target;
+	
+	if(*pDM_Odm->pChannel >= 149)		// Band4 -> for AP : mode2, for sd4 and sd7 : turnoff adaptivity
+	{
+#if (DM_ODM_SUPPORT_TYPE & ODM_AP)
+		if(pDM_Odm->bLinked)
+		{
+		Diff = IGI_target -(s1Byte)IGI;
+		L2H_nolink_Band4 = pDM_Odm->TH_L2H_ini_mode2 + Diff;
+		if(L2H_nolink_Band4 > 10) 	
+			L2H_nolink_Band4 = 10;		
+		H2L_nolink_Band4 = L2H_nolink_Band4 - pDM_Odm->TH_EDCCA_HL_diff_mode2;
+		}
+#endif
+		Phydm_SetEDCCAThreshold(pDM_Odm, H2L_nolink_Band4, L2H_nolink_Band4);
+		return FALSE;
+	}
+
+	if(!pDM_Odm->ForceEDCCA)
+	{
+		if(pDM_Odm->RSSI_Min > pDM_Odm->AdapEn_RSSI)
+			EDCCA_State = 1;
+		else if(pDM_Odm->RSSI_Min < (pDM_Odm->AdapEn_RSSI - 5))
+			EDCCA_State = 0;
+	}
+	else
+		EDCCA_State = 1;
+
+	if(pDM_Odm->Carrier_Sense_enable == FALSE && pDM_Odm->NHM_enable == TRUE)
+		Phydm_NHMBB(pDM_Odm);
+	
+	ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("BandWidth=%s, IGI_target=0x%x, EDCCA_State=%d, EDCCA_enable_state = %d\n",
+		(*pDM_Odm->pBandWidth==ODM_BW80M)?"80M":((*pDM_Odm->pBandWidth==ODM_BW40M)?"40M":"20M"), IGI_target, EDCCA_State, pDM_Odm->EDCCA_enable_state));
+	ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("RSSI_min = %d, AdapIGIUpper= 0x %x\n", pDM_Odm->RSSI_Min, pDM_Odm->Adaptivity_IGI_upper));
+
+
+	if(EDCCA_State == 1)
+	{
+		Diff = IGI_target -(s1Byte)IGI;
+		TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
+		if(TH_L2H_dmc > 10) 	
+			TH_L2H_dmc = 10;
+				
+		TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
+
+		//replace lower bound to prevent EDCCA always equal 1
+			if(TH_H2L_dmc < pDM_Odm->H2L_lb)				
+				TH_H2L_dmc = pDM_Odm->H2L_lb;
+			if(TH_L2H_dmc < pDM_Odm->L2H_lb)
+				TH_L2H_dmc = pDM_Odm->L2H_lb;
+	}
+	else
+	{
+		TH_L2H_dmc = 0x7f;
+		TH_H2L_dmc = 0x7f;
+	}
+	ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d, adaptivity_flg = %d, bAdaOn = %d, DynamicLinkAdaptivity = %d, NHM_enable = %d\n", 
+		IGI, TH_L2H_dmc, TH_H2L_dmc, pDM_Odm->adaptivity_flag, pDM_Odm->bAdaOn, pDM_Odm->DynamicLinkAdaptivity, pDM_Odm->NHM_enable));
+	
+	Phydm_SetEDCCAThreshold(pDM_Odm, TH_H2L_dmc, TH_L2H_dmc);
+	return TRUE;
+}
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+Phydm_EnableEDCCA(
+	IN		PVOID					pDM_VOID
+)
+{
+
+	// This should be moved out of OUTSRC
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	// Enable EDCCA. The value is suggested by SD3 Wilson.
+
+	//
+	// Revised for ASUS 11b/g performance issues, suggested by BB Neil, 2012.04.13.
+	//
+	if((pDM_Odm->SupportICType == ODM_RTL8723A)&&(IS_WIRELESS_MODE_G(pAdapter)))
+	{
+		//PlatformEFIOWrite1Byte(Adapter, rOFDM0_ECCAThreshold, 0x00);
+		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold,0x00);
+		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold+2,0xFD);
+		
+	}	
+	else
+	{
+		//PlatformEFIOWrite1Byte(Adapter, rOFDM0_ECCAThreshold, 0x03);
+		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold,0x03);
+		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold+2,0x00);
+	}	
+	
+	//PlatformEFIOWrite1Byte(Adapter, rOFDM0_ECCAThreshold+2, 0x00);
+}
+
+VOID
+Phydm_DisableEDCCA(
+	IN		PVOID					pDM_VOID
+)
+{	
+	// Disable EDCCA..
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold, 0x7f);
+	ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold+2, 0x7f);
+}
+
+//
+// Description: According to initial gain value to determine to enable or disable EDCCA.
+//
+// Suggested by SD3 Wilson. Added by tynli. 2011.11.25.
+//
+VOID
+Phydm_DynamicEDCCA(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	u1Byte			RegC50, RegC58;
+	BOOLEAN			bEDCCAenable = FALSE;
+	
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))	
+	BOOLEAN			bFwCurrentInPSMode=FALSE;	
+
+	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_FW_PSMODE_STATUS, (pu1Byte)(&bFwCurrentInPSMode));	
+
+	// Disable EDCCA mode while under LPS mode, added by Roger, 2012.09.14.
+	if(bFwCurrentInPSMode)
+		return;
+#endif
+	//
+	// 2013/11/14 Ken According to BB team Jame's suggestion, we need to disable soft AP mode EDCCA.
+	// 2014/01/08 MH For Miracst AP mode test. We need to disable EDCCA. Otherwise, we may stop
+	// to send beacon in noisy environment or platform.
+	//
+	if(ACTING_AS_AP(pAdapter) || ACTING_AS_AP(GetFirstAPAdapter(pAdapter)))
+	//if(ACTING_AS_AP(pAdapter))
+	{
+		ODM_RT_TRACE(pDM_Odm,PHYDM_COMP_ADAPTIVITY, ODM_DBG_LOUD, ("At least One Port as AP disable EDCCA\n"));
+		Phydm_DisableEDCCA(pDM_Odm);
+		if(pHalData->bPreEdccaEnable)
+			Phydm_DisableEDCCA(pDM_Odm);
+		pHalData->bPreEdccaEnable = FALSE;
+		return;
+	}
+	
+	RegC50 = (u1Byte)ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0);
+	RegC58 = (u1Byte)ODM_GetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0);
+
+
+ 	if((RegC50 > 0x28 && RegC58 > 0x28) ||
+  		((pDM_Odm->SupportICType == ODM_RTL8723A && IS_WIRELESS_MODE_G(pAdapter) && RegC50>0x26)) ||
+  		(pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 > 0x28))
+	{
+		if(!pHalData->bPreEdccaEnable)
+		{
+			Phydm_EnableEDCCA(pDM_Odm);
+			pHalData->bPreEdccaEnable = TRUE;
+		}
+		
+	}
+	else if((RegC50 < 0x25 && RegC58 < 0x25) || (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 < 0x25))
+	{
+		if(pHalData->bPreEdccaEnable)
+		{
+			Phydm_DisableEDCCA(pDM_Odm);
+			pHalData->bPreEdccaEnable = FALSE;
+		}
+	}
+}
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.h
new file mode 100644
index 000000000000..e586ac8cf3a7
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/PhyDM_Adaptivity.h
@@ -0,0 +1,146 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMADAPTIVITY_H__
+#define    __PHYDMADAPTIVITY_H__
+
+#define ADAPTIVITY_VERSION	"7.1"
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+typedef enum _tag_PhyDM_REGULATION_Type {
+	REGULATION_FCC = 0,
+	REGULATION_MKK = 1,
+	REGULATION_ETSI = 2,
+	REGULATION_WW = 3,	
+	
+	MAX_REGULATION_NUM = 4
+} PhyDM_REGULATION_TYPE;
+#endif
+
+typedef enum tag_PhyDM_TRx_MUX_Type
+{
+	PhyDM_SHUTDOWN			= 0,
+	PhyDM_STANDBY_MODE		= 1,
+	PhyDM_TX_MODE			= 2,
+	PhyDM_RX_MODE			= 3
+}PhyDM_Trx_MUX_Type;
+
+typedef enum tag_PhyDM_MACEDCCA_Type
+{
+	PhyDM_IGNORE_EDCCA			= 0,
+	PhyDM_DONT_IGNORE_EDCCA	= 1
+}PhyDM_MACEDCCA_Type;
+
+
+VOID
+Phydm_CheckAdaptivity(
+	IN		PVOID			pDM_VOID
+	);
+
+VOID
+Phydm_CheckEnvironment(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_NHMCounterStatisticsInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_NHMCounterStatistics(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+Phydm_NHMBBInit(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+Phydm_NHMBB(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+Phydm_NHMCounterStatisticsReset(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+Phydm_GetNHMCounterStatistics(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+Phydm_MACEDCCAState(
+	IN	PVOID					pDM_VOID,
+	IN	PhyDM_MACEDCCA_Type		State
+);
+
+VOID
+Phydm_SetEDCCAThreshold(
+	IN		PVOID		pDM_VOID,
+	IN		s1Byte		H2L,
+	IN		s1Byte		L2H
+);
+
+VOID
+Phydm_SetTRxMux(
+	IN		PVOID			pDM_VOID,
+	IN		PhyDM_Trx_MUX_Type			txMode,
+	IN		PhyDM_Trx_MUX_Type			rxMode
+);	
+
+BOOLEAN
+Phydm_CalNHMcnt(
+	IN		PVOID		pDM_VOID
+);
+
+VOID
+Phydm_SearchPwdBLowerBound(
+	IN		PVOID					pDM_VOID
+);
+
+VOID 
+Phydm_AdaptivityInit(
+	IN		PVOID					pDM_VOID
+	);
+
+BOOLEAN
+Phydm_Adaptivity(
+	IN		PVOID					pDM_VOID,
+	IN		u1Byte					IGI
+	);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+Phydm_DisableEDCCA(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+Phydm_DynamicEDCCA(
+	IN		PVOID					pDM_VOID
+);
+#endif
+
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm.c
deleted file mode 100644
index 48766a2c0a6b..000000000000
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm.c
+++ /dev/null
@@ -1,14206 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-//============================================================
-// include files
-//============================================================
-
-#include "odm_precomp.h"
-
-
-const u2Byte dB_Invert_Table[8][12] = {
-	{	1,		1,		1,		2,		2,		2,		2,		3,		3,		3,		4,		4},
-	{	4,		5,		6,		6,		7,		8,		9,		10,		11,		13,		14,		16},
-	{	18,		20,		22,		25,		28,		32,		35,		40,		45,		50,		56,		63},
-	{	71,		79,		89,		100,	112,	126,	141,	158,	178,	200,	224,	251},
-	{	282,	316,	355,	398,	447,	501,	562,	631,	708,	794,	891,	1000},
-	{	1122,	1259,	1413,	1585,	1778,	1995,	2239,	2512,	2818,	3162,	3548,	3981},
-	{	4467,	5012,	5623,	6310,	7079,	7943,	8913,	10000,	11220,	12589,	14125,	15849},
-	{	17783,	19953,	22387,	25119,	28184,	31623,	35481,	39811,	44668,	50119,	56234,	65535}};
-
-
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-static u4Byte edca_setting_UL[HT_IOT_PEER_MAX] = 
-// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MERU        MARVELL	92U_AP		SELF_AP(DownLink/Tx)
-{ 0x5e4322, 		0xa44f, 		0x5e4322,		0x5ea32b,  		0x5ea422, 	0x5ea322,	0x3ea430,	0x5ea42b, 0x5ea44f,	0x5e4322,	0x5e4322};
-
-
-static u4Byte edca_setting_DL[HT_IOT_PEER_MAX] = 
-// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MERU,       MARVELL	92U_AP		SELF_AP(UpLink/Rx)
-{ 0xa44f, 		0x5ea44f, 	0x5e4322, 		0x5ea42b, 		0xa44f, 		0xa630, 		0x5ea630,	0x5ea42b, 0xa44f,		0xa42b,		0xa42b};
-
-static u4Byte edca_setting_DL_GMode[HT_IOT_PEER_MAX] = 
-// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MERU,       MARVELL	92U_AP		SELF_AP
-{ 0x4322, 		0xa44f, 		0x5e4322,		0xa42b, 			0x5e4322, 	0x4322, 		0xa42b,		0x5ea42b, 0xa44f,		0x5e4322,	0x5ea42b};
-
-
-//============================================================
-// EDCA Paramter for AP/ADSL   by Mingzhi 2011-11-22
-//============================================================
-#elif (DM_ODM_SUPPORT_TYPE &ODM_ADSL)
-enum qos_prio { BK, BE, VI, VO, VI_AG, VO_AG };
-
-static const struct ParaRecord rtl_ap_EDCA[] =
-{
-//ACM,AIFSN, ECWmin, ECWmax, TXOplimit
-     {0,     7,      4,      10,     0},            //BK
-     {0,     3,      4,      6,      0},             //BE
-     {0,     1,      3,      4,      188},         //VI
-     {0,     1,      2,      3,      102},         //VO
-     {0,     1,      3,      4,      94},          //VI_AG
-     {0,     1,      2,      3,      47},          //VO_AG
-};
-
-static const struct ParaRecord rtl_sta_EDCA[] =
-{
-//ACM,AIFSN, ECWmin, ECWmax, TXOplimit
-     {0,     7,      4,      10,     0},
-     {0,     3,      4,      10,     0},
-     {0,     2,      3,      4,      188},
-     {0,     2,      2,      3,      102},
-     {0,     2,      3,      4,      94},
-     {0,     2,      2,      3,      47},
-};
-#endif
-
-//============================================================
-// Global var
-//============================================================
-
-u4Byte	OFDMSwingTable[OFDM_TABLE_SIZE] = {
-	0x7f8001fe,	// 0, +6.0dB
-	0x788001e2,	// 1, +5.5dB
-	0x71c001c7,	// 2, +5.0dB
-	0x6b8001ae,	// 3, +4.5dB
-	0x65400195,	// 4, +4.0dB
-	0x5fc0017f,	// 5, +3.5dB
-	0x5a400169,	// 6, +3.0dB
-	0x55400155,	// 7, +2.5dB
-	0x50800142,	// 8, +2.0dB
-	0x4c000130,	// 9, +1.5dB
-	0x47c0011f,	// 10, +1.0dB
-	0x43c0010f,	// 11, +0.5dB
-	0x40000100,	// 12, +0dB
-	0x3c8000f2,	// 13, -0.5dB
-	0x390000e4,	// 14, -1.0dB
-	0x35c000d7,	// 15, -1.5dB
-	0x32c000cb,	// 16, -2.0dB
-	0x300000c0,	// 17, -2.5dB
-	0x2d4000b5,	// 18, -3.0dB
-	0x2ac000ab,	// 19, -3.5dB
-	0x288000a2,	// 20, -4.0dB
-	0x26000098,	// 21, -4.5dB
-	0x24000090,	// 22, -5.0dB
-	0x22000088,	// 23, -5.5dB
-	0x20000080,	// 24, -6.0dB
-	0x1e400079,	// 25, -6.5dB
-	0x1c800072,	// 26, -7.0dB
-	0x1b00006c,	// 27. -7.5dB
-	0x19800066,	// 28, -8.0dB
-	0x18000060,	// 29, -8.5dB
-	0x16c0005b,	// 30, -9.0dB
-	0x15800056,	// 31, -9.5dB
-	0x14400051,	// 32, -10.0dB
-	0x1300004c,	// 33, -10.5dB
-	0x12000048,	// 34, -11.0dB
-	0x11000044,	// 35, -11.5dB
-	0x10000040,	// 36, -12.0dB
-};
-
-u1Byte	CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8] = {
-	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},	// 0, +0dB
-	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 1, -0.5dB
-	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 2, -1.0dB
-	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 3, -1.5dB
-	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 4, -2.0dB 
-	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 5, -2.5dB
-	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 6, -3.0dB
-	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 7, -3.5dB
-	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 8, -4.0dB 
-	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 9, -4.5dB
-	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 10, -5.0dB 
-	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 11, -5.5dB
-	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 12, -6.0dB <== default
-	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 13, -6.5dB
-	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 14, -7.0dB 
-	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 15, -7.5dB
-	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
-	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 17, -8.5dB
-	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 18, -9.0dB 
-	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 19, -9.5dB
-	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 20, -10.0dB
-	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 21, -10.5dB
-	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 22, -11.0dB
-	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	// 23, -11.5dB
-	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	// 24, -12.0dB
-	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	// 25, -12.5dB
-	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	// 26, -13.0dB
-	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	// 27, -13.5dB
-	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	// 28, -14.0dB
-	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	// 29, -14.5dB
-	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	// 30, -15.0dB
-	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	// 31, -15.5dB
-	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}	// 32, -16.0dB
-};
-
-
-u1Byte	CCKSwingTable_Ch14[CCK_TABLE_SIZE][8] = {
-	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	// 0, +0dB  
-	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 1, -0.5dB 
-	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 2, -1.0dB  
-	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 3, -1.5dB
-	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 4, -2.0dB  
-	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 5, -2.5dB
-	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 6, -3.0dB  
-	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 7, -3.5dB  
-	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 8, -4.0dB  
-	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 9, -4.5dB
-	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 10, -5.0dB  
-	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 11, -5.5dB
-	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 12, -6.0dB  <== default
-	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 13, -6.5dB 
-	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 14, -7.0dB  
-	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 15, -7.5dB
-	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
-	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 17, -8.5dB
-	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 18, -9.0dB  
-	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 19, -9.5dB
-	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 20, -10.0dB
-	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 21, -10.5dB
-	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 22, -11.0dB
-	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 23, -11.5dB
-	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 24, -12.0dB
-	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	// 25, -12.5dB
-	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 26, -13.0dB
-	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 27, -13.5dB
-	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 28, -14.0dB
-	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 29, -14.5dB
-	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 30, -15.0dB
-	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 31, -15.5dB
-	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}	// 32, -16.0dB
-};
-
-
-u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE] = {
-	0x0b40002d, // 0,  -15.0dB	
-	0x0c000030, // 1,  -14.5dB
-	0x0cc00033, // 2,  -14.0dB
-	0x0d800036, // 3,  -13.5dB
-	0x0e400039, // 4,  -13.0dB    
-	0x0f00003c, // 5,  -12.5dB
-	0x10000040, // 6,  -12.0dB
-	0x11000044, // 7,  -11.5dB
-	0x12000048, // 8,  -11.0dB
-	0x1300004c, // 9,  -10.5dB
-	0x14400051, // 10, -10.0dB
-	0x15800056, // 11, -9.5dB
-	0x16c0005b, // 12, -9.0dB
-	0x18000060, // 13, -8.5dB
-	0x19800066, // 14, -8.0dB
-	0x1b00006c, // 15, -7.5dB
-	0x1c800072, // 16, -7.0dB
-	0x1e400079, // 17, -6.5dB
-	0x20000080, // 18, -6.0dB
-	0x22000088, // 19, -5.5dB
-	0x24000090, // 20, -5.0dB
-	0x26000098, // 21, -4.5dB
-	0x288000a2, // 22, -4.0dB
-	0x2ac000ab, // 23, -3.5dB
-	0x2d4000b5, // 24, -3.0dB
-	0x300000c0, // 25, -2.5dB
-	0x32c000cb, // 26, -2.0dB
-	0x35c000d7, // 27, -1.5dB
-	0x390000e4, // 28, -1.0dB
-	0x3c8000f2, // 29, -0.5dB
-	0x40000100, // 30, +0dB
-	0x43c0010f, // 31, +0.5dB
-	0x47c0011f, // 32, +1.0dB
-	0x4c000130, // 33, +1.5dB
-	0x50800142, // 34, +2.0dB
-	0x55400155, // 35, +2.5dB
-	0x5a400169, // 36, +3.0dB
-	0x5fc0017f, // 37, +3.5dB
-	0x65400195, // 38, +4.0dB
-	0x6b8001ae, // 39, +4.5dB
-	0x71c001c7, // 40, +5.0dB
-	0x788001e2, // 41, +5.5dB
-	0x7f8001fe  // 42, +6.0dB
-};               
-
-
-u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8] = {
-	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01},	//  0, -16.0dB
-	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	//  1, -15.5dB
-	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	//  2, -15.0dB
-	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	//  3, -14.5dB
-	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	//  4, -14.0dB
-	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	//  5, -13.5dB
-	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	//  6, -13.0dB
-	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	//  7, -12.5dB
-	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	//  8, -12.0dB
-	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	//  9, -11.5dB
-	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 10, -11.0dB
-	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 11, -10.5dB
-	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 12, -10.0dB
-	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 13, -9.5dB
-	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 14, -9.0dB 
-	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 15, -8.5dB
-	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
-	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 17, -7.5dB
-	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 18, -7.0dB 
-	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 19, -6.5dB
-    {0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 20, -6.0dB 
-	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 21, -5.5dB
-	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 22, -5.0dB 
-	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 23, -4.5dB
-	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 24, -4.0dB 
-	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 25, -3.5dB
-	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 26, -3.0dB
-	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 27, -2.5dB
-	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 28, -2.0dB 
-	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 29, -1.5dB
-	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 30, -1.0dB
-	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 31, -0.5dB
-	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04} 	// 32, +0dB
-};                                                                  
-
-
-u1Byte CCKSwingTable_Ch14_New[CCK_TABLE_SIZE][8]= {
-	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00},	//  0, -16.0dB
-	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  1, -15.5dB
-	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  2, -15.0dB
-	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  3, -14.5dB
-	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  4, -14.0dB
-	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  5, -13.5dB
-	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  6, -13.0dB
-	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	//  7, -12.5dB
-	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  8, -12.0dB
-	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  9, -11.5dB
-	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 10, -11.0dB
-	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 11, -10.5dB
-	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 12, -10.0dB
-	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 13, -9.5dB
-	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 14, -9.0dB  
-	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 15, -8.5dB
-	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
-	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 17, -7.5dB
-	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 18, -7.0dB  
-	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 19, -6.5dB 
-	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 20, -6.0dB  
-	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 21, -5.5dB
-	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 22, -5.0dB  
-	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 23, -4.5dB
-	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 24, -4.0dB  
-	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 25, -3.5dB  
-	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 26, -3.0dB  
-	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 27, -2.5dB
-	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 28, -2.0dB  
-	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 29, -1.5dB
-	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 30, -1.0dB  
-	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 31, -0.5dB 
-	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00} 	// 32, +0dB	
-};
-
-u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE] =
-{
-	0x081, // 0,  -12.0dB
-	0x088, // 1,  -11.5dB
-	0x090, // 2,  -11.0dB
-	0x099, // 3,  -10.5dB
-	0x0A2, // 4,  -10.0dB
-	0x0AC, // 5,  -9.5dB
-	0x0B6, // 6,  -9.0dB
-	0x0C0, // 7,  -8.5dB
-	0x0CC, // 8,  -8.0dB
-	0x0D8, // 9,  -7.5dB
-	0x0E5, // 10, -7.0dB
-	0x0F2, // 11, -6.5dB
-	0x101, // 12, -6.0dB
-	0x110, // 13, -5.5dB
-	0x120, // 14, -5.0dB
-	0x131, // 15, -4.5dB
-	0x143, // 16, -4.0dB
-	0x156, // 17, -3.5dB
-	0x16A, // 18, -3.0dB
-	0x180, // 19, -2.5dB
-	0x197, // 20, -2.0dB
-	0x1AF, // 21, -1.5dB
-	0x1C8, // 22, -1.0dB
-	0x1E3, // 23, -0.5dB
-	0x200, // 24, +0  dB
-	0x21E, // 25, +0.5dB
-	0x23E, // 26, +1.0dB
-	0x261, // 27, +1.5dB
-	0x285, // 28, +2.0dB
-	0x2AB, // 29, +2.5dB
-	0x2D3, // 30, +3.0dB
-	0x2FE, // 31, +3.5dB
-	0x32B, // 32, +4.0dB
-	0x35C, // 33, +4.5dB
-	0x38E, // 34, +5.0dB
-	0x3C4, // 35, +5.5dB
-	0x3FE  // 36, +6.0dB	
-};
-
-#ifdef AP_BUILD_WORKAROUND
-
-unsigned int TxPwrTrk_OFDM_SwingTbl[TxPwrTrk_OFDM_SwingTbl_Len] = {
-	/*  +6.0dB */ 0x7f8001fe,
-	/*  +5.5dB */ 0x788001e2,
-	/*  +5.0dB */ 0x71c001c7,
-	/*  +4.5dB */ 0x6b8001ae,
-	/*  +4.0dB */ 0x65400195,
-	/*  +3.5dB */ 0x5fc0017f,
-	/*  +3.0dB */ 0x5a400169,
-	/*  +2.5dB */ 0x55400155,
-	/*  +2.0dB */ 0x50800142,
-	/*  +1.5dB */ 0x4c000130,
-	/*  +1.0dB */ 0x47c0011f,
-	/*  +0.5dB */ 0x43c0010f,
-	/*   0.0dB */ 0x40000100,
-	/*  -0.5dB */ 0x3c8000f2,
-	/*  -1.0dB */ 0x390000e4,
-	/*  -1.5dB */ 0x35c000d7,
-	/*  -2.0dB */ 0x32c000cb,
-	/*  -2.5dB */ 0x300000c0,
-	/*  -3.0dB */ 0x2d4000b5,
-	/*  -3.5dB */ 0x2ac000ab,
-	/*  -4.0dB */ 0x288000a2,
-	/*  -4.5dB */ 0x26000098,
-	/*  -5.0dB */ 0x24000090,
-	/*  -5.5dB */ 0x22000088,
-	/*  -6.0dB */ 0x20000080,
-	/*  -6.5dB */ 0x1a00006c,
-	/*  -7.0dB */ 0x1c800072,
-	/*  -7.5dB */ 0x18000060,
-	/*  -8.0dB */ 0x19800066,
-	/*  -8.5dB */ 0x15800056,
-	/*  -9.0dB */ 0x26c0005b,
-	/*  -9.5dB */ 0x14400051,
-	/* -10.0dB */ 0x24400051,
-	/* -10.5dB */ 0x1300004c,
-	/* -11.0dB */ 0x12000048,
-	/* -11.5dB */ 0x11000044,
-	/* -12.0dB */ 0x10000040
-};
-#endif
-
-//============================================================
-// Local Function predefine.
-//============================================================
-
-//START------------COMMON INFO RELATED---------------//
-VOID
-odm_CommonInfoSelfInit(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_CommonInfoSelfUpdate(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_CmnInfoInit_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_CmnInfoHook_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_CmnInfoUpdate_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-VOID
-odm_BasicDbgMessage
-(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-//END------------COMMON INFO RELATED---------------//
-
-//START---------------DIG---------------------------//
-VOID 
-odm_FalseAlarmCounterStatistics(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_DIGInit(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID	
-odm_DIG(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-BOOLEAN 
-odm_DigAbort(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID 
-odm_CCKPacketDetectionThresh(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_AdaptivityInit(
-	IN		PDM_ODM_T		pDM_Odm
-);
-
-VOID
-odm_Adaptivity(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			IGI
-);
-//END---------------DIG---------------------------//
-
-//START-------BB POWER SAVE-----------------------//
-VOID 
-odm_DynamicBBPowerSavingInit(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID 
-odm_DynamicBBPowerSaving(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_1R_CCA(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-//END---------BB POWER SAVE-----------------------//
-
-//START-----------------PSD-----------------------//
-#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
-//============================================================
-// Function predefine.
-//============================================================
-VOID	odm_PathDiversityInit_92C(	IN	PADAPTER	Adapter);
-VOID	odm_2TPathDiversityInit_92C(	IN	PADAPTER	Adapter);
-VOID	odm_1TPathDiversityInit_92C(	IN	PADAPTER	Adapter);
-BOOLEAN	odm_IsConnected_92C(IN	PADAPTER	Adapter);
-VOID	odm_PathDiversityAfterLink_92C(	IN	PADAPTER	Adapter);
-
-VOID
-odm_CCKTXPathDiversityCallback(
-	PRT_TIMER		pTimer
-	);
-
-VOID
-odm_CCKTXPathDiversityWorkItemCallback(
-    IN PVOID            pContext
-    );
-
-VOID
-odm_PathDivChkAntSwitchCallback(
-	PRT_TIMER		pTimer
-	);
-
-VOID
-odm_PathDivChkAntSwitchWorkitemCallback(
-    IN PVOID            pContext
-    );
-
-VOID	odm_SetRespPath_92C(		IN	PADAPTER	Adapter, 	IN	u1Byte	DefaultRespPath);
-VOID	odm_OFDMTXPathDiversity_92C(	IN	PADAPTER	Adapter);
-VOID	odm_CCKTXPathDiversity_92C(	IN	PADAPTER	Adapter);
-VOID	odm_ResetPathDiversity_92C(		IN	PADAPTER	Adapter);
-
-//Start-------------------- RX High Power------------------------//
-VOID	odm_RXHPInit(	IN		PDM_ODM_T		pDM_Odm);
-VOID	odm_RXHP(	IN		PDM_ODM_T		pDM_Odm);
-VOID	odm_Write_RXHP(	IN	PDM_ODM_T	pDM_Odm);
-
-VOID	odm_PSD_RXHP(		IN	PDM_ODM_T	pDM_Odm);
-VOID	odm_PSD_RXHPCallback(	PRT_TIMER		pTimer);
-VOID	odm_PSD_RXHPWorkitemCallback(	IN PVOID            pContext);
-//End--------------------- RX High Power -----------------------//
-
-VOID	odm_PathDivInit_92D(	IN	PDM_ODM_T 	pDM_Odm);
-
-VOID
-odm_SetRespPath_92C(
-	IN	PADAPTER	Adapter,
-	IN	u1Byte	DefaultRespPath 
-	);
-
-#endif
-//END-------------------PSD-----------------------//
-
-VOID
-odm_RefreshRateAdaptiveMaskMP(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_RefreshRateAdaptiveMaskCE(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_RefreshRateAdaptiveMaskAPADSL(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-ODM_DynamicATCSwitch_init(
-	IN 		PDM_ODM_T 		pDM_Odm
-	);
-
-VOID
-ODM_DynamicATCSwitch(
-	IN 		PDM_ODM_T 		pDM_Odm
-	);
-
-VOID
-odm_Write_CrystalCap(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			CrystalCap
-);
-
-VOID 
-odm_DynamicTxPowerInit(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_DynamicTxPowerRestorePowerIndex(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-VOID 
-odm_DynamicTxPowerNIC(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-VOID
-odm_DynamicTxPowerSavePowerIndex(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_DynamicTxPowerWritePowerIndex(
-	IN	PDM_ODM_T	pDM_Odm, 
-	IN 	u1Byte		Value);
-
-VOID 
-odm_DynamicTxPower_92C(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-VOID 
-odm_DynamicTxPower_92D(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-VOID
-odm_MPT_DIGCallback(
-	PRT_TIMER		pTimer
-);
-
-VOID
-odm_MPT_DIGWorkItemCallback(
-    IN PVOID            pContext
-    );
-#endif
-
-
-VOID
-odm_RSSIMonitorInit(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-VOID
-odm_RSSIMonitorCheckMP(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-VOID 
-odm_RSSIMonitorCheckCE(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-VOID 
-odm_RSSIMonitorCheckAP(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-
-
-VOID
-odm_RSSIMonitorCheck(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-VOID 
-odm_DynamicTxPower(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID 
-odm_DynamicTxPowerAP(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-
-VOID
-odm_SwAntDivInit(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_SwAntDivInit_NIC(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_SwAntDetectInit(
-	IN 		PDM_ODM_T 		pDM_Odm
-	);
-
-VOID
-odm_SwAntDivChkAntSwitch(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			Step
-	);
-
-VOID
-odm_SwAntDivChkAntSwitchNIC(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte		Step
-	);
-
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID
-odm_SwAntDivChkAntSwitchCallback(
-	PRT_TIMER		pTimer
-);
-VOID
-odm_SwAntDivChkAntSwitchWorkitemCallback(
-    IN PVOID            pContext
-    );
-VOID
-ODM_UpdateInitRateWorkItemCallback(
-    IN PVOID            pContext
-    );
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-VOID odm_SwAntDivChkAntSwitchCallback(void *FunctionContext);
-#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-VOID odm_SwAntDivChkAntSwitchCallback(void *FunctionContext);
-#endif
-
-
-
-VOID
-odm_GlobalAdapterCheck(
-	IN		VOID
-	);
-
-VOID
-odm_RefreshBasicRateMask(
-	IN		PDM_ODM_T		pDM_Odm	
-	);
-
-VOID
-odm_RefreshRateAdaptiveMask(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-ODM_TXPowerTrackingCheck(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-VOID
-odm_TXPowerTrackingCheckAP(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-
-
-
-
-
-
-VOID
-odm_RateAdaptiveMaskInit(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-VOID
-odm_TXPowerTrackingThermalMeterInit(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-
-VOID
-odm_IQCalibrate(
-		IN	PDM_ODM_T	pDM_Odm 
-		);
-
-VOID
-odm_TXPowerTrackingInit(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-VOID
-odm_TXPowerTrackingCheckMP(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-
-VOID
-odm_TXPowerTrackingCheckCE(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
-
-VOID
-ODM_RateAdaptiveStateApInit(
-	IN	PADAPTER	Adapter	,
-	IN	PRT_WLAN_STA  pEntry
-	);
-
-VOID 
-odm_TXPowerTrackingCallbackThermalMeter92C(
-            IN PADAPTER	Adapter
-            );
-
-VOID
-odm_TXPowerTrackingCallbackRXGainThermalMeter92D(
-	IN PADAPTER 	Adapter
-	);
-
-VOID
-odm_TXPowerTrackingCallbackThermalMeter92D(
-            IN PADAPTER	Adapter
-            );
-
-VOID
-odm_TXPowerTrackingDirectCall92C(
-            IN	PADAPTER		Adapter
-            );
-
-VOID
-odm_TXPowerTrackingThermalMeterCheck(
-	IN	PADAPTER		Adapter
-	);
-
-#endif
-
-VOID
-odm_EdcaTurboCheck(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-VOID
-ODM_EdcaTurboInit(
-	IN	PDM_ODM_T		pDM_Odm
-);
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
-VOID
-odm_EdcaTurboCheckMP(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-//check if edca turbo is disabled
-BOOLEAN
-odm_IsEdcaTurboDisable(
-	IN 	PDM_ODM_T 	pDM_Odm
-);
-//choose edca paramter for special IOT case
-VOID 
-ODM_EdcaParaSelByIot(
-	IN 	PDM_ODM_T 	pDM_Odm,
-	OUT	u4Byte		*EDCA_BE_UL,
-	OUT u4Byte		*EDCA_BE_DL
-	);
-//check if it is UL or DL
-VOID
-odm_EdcaChooseTrafficIdx( 
-	IN	PDM_ODM_T		pDM_Odm,
-	IN	u8Byte  			cur_tx_bytes,  
-	IN	u8Byte  			cur_rx_bytes, 
-	IN	BOOLEAN 		bBiasOnRx,
-	OUT BOOLEAN 		*pbIsCurRDLState
-	);
-
-#elif (DM_ODM_SUPPORT_TYPE==ODM_CE)
-VOID
-odm_EdcaTurboCheckCE(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-#else
-VOID 
-odm_IotEngine(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-VOID
-odm_EdcaParaInit(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-#endif
-
-
-
-#define 	RxDefaultAnt1		0x65a9
-#define	RxDefaultAnt2		0x569a
-
-VOID
-odm_InitHybridAntDiv(
-	IN PDM_ODM_T	pDM_Odm 
-	);
-
-BOOLEAN
-odm_StaDefAntSel(
-	IN PDM_ODM_T	pDM_Odm,
-	IN u4Byte		OFDM_Ant1_Cnt,
-	IN u4Byte		OFDM_Ant2_Cnt,
-	IN u4Byte		CCK_Ant1_Cnt,
-	IN u4Byte		CCK_Ant2_Cnt,
-	OUT u1Byte		*pDefAnt 
-	);
-
-VOID
-odm_SetRxIdleAnt(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte	Ant,
-	IN   BOOLEAN   bDualPath                     
-);
-
-
-
-VOID
-odm_HwAntDiv(
-	IN	PDM_ODM_T	pDM_Odm
-);
-
-VOID	odm_PathDiversityInit(IN	PDM_ODM_T	pDM_Odm);
-VOID	odm_PathDiversity(	IN	PDM_ODM_T	pDM_Odm);
-
-
-
-//============================================================
-//3 Export Interface
-//============================================================
-
-//
-// 2011/09/21 MH Add to describe different team necessary resource allocate??
-//
-VOID
-ODM_DMInit(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-
-	//2012.05.03 Luke: For all IC series
-	odm_CommonInfoSelfInit(pDM_Odm);
-	odm_CmnInfoInit_Debug(pDM_Odm);
-	odm_DIGInit(pDM_Odm);	
-	odm_AdaptivityInit(pDM_Odm);
-	odm_RateAdaptiveMaskInit(pDM_Odm);
-	odm_RSSIMonitorInit(pDM_Odm);
-	
-#if (RTL8192E_SUPPORT == 1)
-	if(pDM_Odm->SupportICType==ODM_RTL8192E)
-	{
-		odm_PrimaryCCA_Check_Init(pDM_Odm);
-	}
-#endif
-
-//#if (MP_DRIVER != 1)
-	if ( *(pDM_Odm->mp_mode) != 1)
-	    odm_PathDiversityInit(pDM_Odm);
-//#endif
-	ODM_EdcaTurboInit(pDM_Odm);
-
-	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
-	{
-		odm_TXPowerTrackingInit(pDM_Odm);
-//#if (MP_DRIVER != 1)
-		if ( *(pDM_Odm->mp_mode) != 1)
-			ODM_AntDivInit(pDM_Odm);
-//#endif
-	}
-	else if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-	{
-		odm_DynamicBBPowerSavingInit(pDM_Odm);
-		odm_DynamicTxPowerInit(pDM_Odm);
-		odm_TXPowerTrackingInit(pDM_Odm);
-		//ODM_EdcaTurboInit(pDM_Odm);
-//#if (MP_DRIVER != 1)
-		if ( *(pDM_Odm->mp_mode) != 1) {
-		if(pDM_Odm->SupportICType==ODM_RTL8723A)
-			odm_SwAntDivInit(pDM_Odm);	
-		else if(pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8192D))
-		{
-			if(pDM_Odm->AntDivType == HW_ANTDIV)
-			odm_InitHybridAntDiv(pDM_Odm);
-			else
-			odm_SwAntDivInit(pDM_Odm);
-		}
-		else
-			ODM_AntDivInit(pDM_Odm);
-	
-		if(pDM_Odm->SupportICType == ODM_RTL8723B)
-			odm_SwAntDetectInit(pDM_Odm);
-		}
-//#endif
-
-//2010.05.30 LukeLee: For CE platform, files in IC subfolders may not be included to be compiled,
-// so compile flags must be left here to prevent from compile errors
-#if (RTL8188E_SUPPORT == 1)
-		if(pDM_Odm->SupportICType==ODM_RTL8188E)
-		{
-			odm_PrimaryCCA_Init(pDM_Odm);    // Gary
-			ODM_RAInfo_Init_all(pDM_Odm);
-		}	
-#endif		
-
-//2010.05.30 LukeLee: Following are not incorporated into ODM structure yet.
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-		if(pDM_Odm->SupportICType&ODM_RTL8723A)
-			odm_PSDMonitorInit(pDM_Odm);
-		
-		if(!(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8188E)))
-		{
-			odm_RXHPInit(pDM_Odm);	
-		}
-		if(pDM_Odm->SupportICType==ODM_RTL8192D)
-		{
-			odm_PathDivInit_92D(pDM_Odm); //92D Path Div Init   //Neil Chen
-		}	
-#endif
-	}
-
-	ODM_DynamicATCSwitch_init(pDM_Odm);
-	ODM_ClearTxPowerTrackingState(pDM_Odm);
-
-}
-
-//
-// 2011/09/20 MH This is the entry pointer for all team to execute HW out source DM.
-// You can not add any dummy function here, be care, you can only use DM structure
-// to perform any new ODM_DM.
-//
-VOID
-ODM_DMWatchdog(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{	
-	if((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->SupportInterface == ODM_ITRF_USB))
-	{
-		if(pDM_Odm->RSSI_Min > 25)
-			ODM_Write1Byte(pDM_Odm, 0x4CF, 0x02);
-		else if(pDM_Odm->RSSI_Min < 20)
-			ODM_Write1Byte(pDM_Odm, 0x4CF, 0x00);
-	}
-
-
-	odm_CommonInfoSelfUpdate(pDM_Odm);
-	odm_BasicDbgMessage(pDM_Odm);
-	odm_FalseAlarmCounterStatistics(pDM_Odm);
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): RSSI=0x%x\n",pDM_Odm->RSSI_Min));
-
-	odm_RSSIMonitorCheck(pDM_Odm);
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-//#ifdef CONFIG_PLATFORM_SPRD
-	//For CE Platform(SPRD or Tablet)
-	//8723A or 8189ES platform
-	//NeilChen--2012--08--24--
-	//Fix Leave LPS issue
-	if( 	(adapter_to_pwrctl(pDM_Odm->Adapter)->pwr_mode != PS_MODE_ACTIVE) // in LPS mode
-		//&&( 			
-		//	(pDM_Odm->SupportICType & (ODM_RTL8723A ) )||
-		//   	(pDM_Odm->SupportICType & (ODM_RTL8188E) &&((pDM_Odm->SupportInterface  == ODM_ITRF_SDIO)) ) 
-	  	//)	
-	)
-	{
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("----Step1: odm_DIG is in LPS mode\n"));				
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("---Step2: 8723AS is in LPS mode\n"));
-			odm_DIGbyRSSI_LPS(pDM_Odm);
-	}		
-	else				
-//#endif
-#endif
-	{
-		odm_DIG(pDM_Odm);
-	}
-
-	{
-		pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
-		odm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);
-	}
-	odm_CCKPacketDetectionThresh(pDM_Odm);
-
-	if(*(pDM_Odm->pbPowerSaving)==TRUE)
-		return;
-
-	
-	odm_RefreshRateAdaptiveMask(pDM_Odm);
-	odm_RefreshBasicRateMask(pDM_Odm);
-	odm_DynamicBBPowerSaving(pDM_Odm);	
-	odm_EdcaTurboCheck(pDM_Odm);
-	odm_PathDiversity(pDM_Odm);
-	ODM_DynamicATCSwitch(pDM_Odm);
-	odm_DynamicTxPower(pDM_Odm);	
-
-#if (RTL8192E_SUPPORT == 1)
-        if(pDM_Odm->SupportICType==ODM_RTL8192E)
-                odm_DynamicPrimaryCCA_Check(pDM_Odm); 
-#endif
-	 //if(pDM_Odm->SupportICType == ODM_RTL8192E)
-	 //        return;
-
-	
-//#if (MP_DRIVER != 1)		
-if ( *(pDM_Odm->mp_mode) != 1) {
-	if(pDM_Odm->SupportICType==ODM_RTL8723A)
-	{
-		odm_SwAntDivChkAntSwitch(pDM_Odm, SWAW_STEP_PEAK);
-	}
-	else if(pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8192D))
-	{
-		if(pDM_Odm->AntDivType == HW_ANTDIV)
-			odm_HwAntDiv(pDM_Odm);
-		else
-			odm_SwAntDivChkAntSwitch(pDM_Odm, SWAW_STEP_PEAK);
-	}
-	else
-		ODM_AntDiv(pDM_Odm);
-}
-//#endif
-
-	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
-	{
-		ODM_TXPowerTrackingCheck(pDM_Odm);
-
-		odm_IQCalibrate(pDM_Odm);
-	}
-	else if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-	{
-		ODM_TXPowerTrackingCheck(pDM_Odm);
-
-		//odm_EdcaTurboCheck(pDM_Odm);
-
-		#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN))	
-		if(!(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8188E)))
-		        odm_RXHP(pDM_Odm);	
-		#endif
-
-	//2010.05.30 LukeLee: For CE platform, files in IC subfolders may not be included to be compiled,
-	// so compile flags must be left here to prevent from compile errors
-#if (RTL8192D_SUPPORT == 1)
-	        if(pDM_Odm->SupportICType==ODM_RTL8192D)
-	                ODM_DynamicEarlyMode(pDM_Odm);
-#endif
-	        odm_DynamicBBPowerSaving(pDM_Odm);
-#if (RTL8188E_SUPPORT == 1)
-	        if(pDM_Odm->SupportICType==ODM_RTL8188E)
-	                odm_DynamicPrimaryCCA(pDM_Odm);	
-#endif
-
-	}
-	pDM_Odm->PhyDbgInfo.NumQryBeaconPkt = 0;
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	odm_dtc(pDM_Odm);
-#endif
-}
-
-
-//
-// Init /.. Fixed HW value. Only init time.
-//
-VOID
-ODM_CmnInfoInit(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		ODM_CMNINFO_E	CmnInfo,
-	IN		u4Byte			Value	
-	)
-{
-	//
-	// This section is used for init value
-	//
-	switch	(CmnInfo)
-	{
-		//
-		// Fixed ODM value.
-		//
-		case	ODM_CMNINFO_ABILITY:
-			pDM_Odm->SupportAbility = (u4Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_RF_TYPE:
-			pDM_Odm->RFType = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_PLATFORM:
-			pDM_Odm->SupportPlatform = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_INTERFACE:
-			pDM_Odm->SupportInterface = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_MP_TEST_CHIP:
-			pDM_Odm->bIsMPChip= (u1Byte)Value;
-			break;
-            
-		case	ODM_CMNINFO_IC_TYPE:
-			pDM_Odm->SupportICType = Value;
-			break;
-
-		case	ODM_CMNINFO_CUT_VER:
-			pDM_Odm->CutVersion = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_FAB_VER:
-			pDM_Odm->FabVersion = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_RFE_TYPE:
-			pDM_Odm->RFEType = (u1Byte)Value;
-			break;
-
-		case    ODM_CMNINFO_RF_ANTENNA_TYPE:
-			pDM_Odm->AntDivType= (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_BOARD_TYPE:
-			pDM_Odm->BoardType = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_PACKAGE_TYPE:
-			pDM_Odm->PackageType = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_EXT_LNA:
-			pDM_Odm->ExtLNA = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_5G_EXT_LNA:
-			pDM_Odm->ExtLNA5G = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_EXT_PA:
-			pDM_Odm->ExtPA = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_5G_EXT_PA:
-			pDM_Odm->ExtPA5G = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_GPA:
-			pDM_Odm->TypeGPA= (ODM_TYPE_GPA_E)Value;
-			break;
-		case	ODM_CMNINFO_APA:
-			pDM_Odm->TypeAPA= (ODM_TYPE_APA_E)Value;
-			break;
-		case	ODM_CMNINFO_GLNA:
-			pDM_Odm->TypeGLNA= (ODM_TYPE_GLNA_E)Value;
-			break;
-		case	ODM_CMNINFO_ALNA:
-			pDM_Odm->TypeALNA= (ODM_TYPE_ALNA_E)Value;
-			break;
-
-		case	ODM_CMNINFO_EXT_TRSW:
-			pDM_Odm->ExtTRSW = (u1Byte)Value;
-			break;
-		case 	ODM_CMNINFO_PATCH_ID:
-			pDM_Odm->PatchID = (u1Byte)Value;
-			break;
-		case 	ODM_CMNINFO_BINHCT_TEST:
-			pDM_Odm->bInHctTest = (BOOLEAN)Value;
-			break;
-		case 	ODM_CMNINFO_BWIFI_TEST:
-			pDM_Odm->bWIFITest = (BOOLEAN)Value;
-			break;	
-
-		case	ODM_CMNINFO_SMART_CONCURRENT:
-			pDM_Odm->bDualMacSmartConcurrent = (BOOLEAN )Value;
-			break;
-		
-		//To remove the compiler warning, must add an empty default statement to handle the other values.	
-		default:
-			//do nothing
-			break;	
-		
-	}
-
-}
-
-
-VOID
-ODM_CmnInfoHook(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		ODM_CMNINFO_E	CmnInfo,
-	IN		PVOID			pValue	
-	)
-{
-	//
-	// Hook call by reference pointer.
-	//
-	switch	(CmnInfo)
-	{
-		//
-		// Dynamic call by reference pointer.
-		//
-		case	ODM_CMNINFO_MAC_PHY_MODE:
-			pDM_Odm->pMacPhyMode = (u1Byte *)pValue;
-			break;
-		
-		case	ODM_CMNINFO_TX_UNI:
-			pDM_Odm->pNumTxBytesUnicast = (u8Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_RX_UNI:
-			pDM_Odm->pNumRxBytesUnicast = (u8Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_WM_MODE:
-			pDM_Odm->pWirelessMode = (u1Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_BAND:
-			pDM_Odm->pBandType = (u1Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_SEC_CHNL_OFFSET:
-			pDM_Odm->pSecChOffset = (u1Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_SEC_MODE:
-			pDM_Odm->pSecurity = (u1Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_BW:
-			pDM_Odm->pBandWidth = (u1Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_CHNL:
-			pDM_Odm->pChannel = (u1Byte *)pValue;
-			break;
-		
-		case	ODM_CMNINFO_DMSP_GET_VALUE:
-			pDM_Odm->pbGetValueFromOtherMac = (BOOLEAN *)pValue;
-			break;
-
-		case	ODM_CMNINFO_BUDDY_ADAPTOR:
-			pDM_Odm->pBuddyAdapter = (PADAPTER *)pValue;
-			break;
-
-		case	ODM_CMNINFO_DMSP_IS_MASTER:
-			pDM_Odm->pbMasterOfDMSP = (BOOLEAN *)pValue;
-			break;
-
-		case	ODM_CMNINFO_SCAN:
-			pDM_Odm->pbScanInProcess = (BOOLEAN *)pValue;
-			break;
-
-		case	ODM_CMNINFO_POWER_SAVING:
-			pDM_Odm->pbPowerSaving = (BOOLEAN *)pValue;
-			break;
-
-		case	ODM_CMNINFO_ONE_PATH_CCA:
-			pDM_Odm->pOnePathCCA = (u1Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_DRV_STOP:
-			pDM_Odm->pbDriverStopped =  (BOOLEAN *)pValue;
-			break;
-
-		case	ODM_CMNINFO_PNP_IN:
-			pDM_Odm->pbDriverIsGoingToPnpSetPowerSleep =  (BOOLEAN *)pValue;
-			break;
-
-		case	ODM_CMNINFO_INIT_ON:
-			pDM_Odm->pinit_adpt_in_progress =  (BOOLEAN *)pValue;
-			break;
-
-		case	ODM_CMNINFO_ANT_TEST:
-			pDM_Odm->pAntennaTest =  (u1Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_NET_CLOSED:
-			pDM_Odm->pbNet_closed = (BOOLEAN *)pValue;
-			break;
-
-		case 	ODM_CMNINFO_FORCED_RATE:
-			pDM_Odm->pForcedDataRate = (pu2Byte)pValue;
-			break;
-
-		case  ODM_CMNINFO_FORCED_IGI_LB:
-			pDM_Odm->pu1ForcedIgiLb = (u1Byte *)pValue;
-			break;
-
-		case	ODM_CMNINFO_MP_MODE:
-			pDM_Odm->mp_mode = (u1Byte *)pValue;
-			break;
-
-		//case	ODM_CMNINFO_RTSTA_AID:
-		//	pDM_Odm->pAidMap =  (u1Byte *)pValue;
-		//	break;
-
-		//case	ODM_CMNINFO_BT_COEXIST:
-		//	pDM_Odm->BTCoexist = (BOOLEAN *)pValue;		
-
-		//case	ODM_CMNINFO_STA_STATUS:
-			//pDM_Odm->pODM_StaInfo[] = (PSTA_INFO_T)pValue;
-			//break;
-
-		//case	ODM_CMNINFO_PHY_STATUS:
-		//	pDM_Odm->pPhyInfo = (ODM_PHY_INFO *)pValue;
-		//	break;
-
-		//case	ODM_CMNINFO_MAC_STATUS:
-		//	pDM_Odm->pMacInfo = (ODM_MAC_INFO *)pValue;
-		//	break;
-		//To remove the compiler warning, must add an empty default statement to handle the other values.				
-		default:
-			//do nothing
-			break;
-
-	}
-
-}
-
-
-VOID
-ODM_CmnInfoPtrArrayHook(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		ODM_CMNINFO_E	CmnInfo,
-	IN		u2Byte			Index,
-	IN		PVOID			pValue	
-	)
-{
-	//
-	// Hook call by reference pointer.
-	//
-	switch	(CmnInfo)
-	{
-		//
-		// Dynamic call by reference pointer.
-		//		
-		case	ODM_CMNINFO_STA_STATUS:
-			pDM_Odm->pODM_StaInfo[Index] = (PSTA_INFO_T)pValue;
-			break;		
-		//To remove the compiler warning, must add an empty default statement to handle the other values.				
-		default:
-			//do nothing
-			break;
-	}
-	
-}
-
-
-//
-// Update Band/CHannel/.. The values are dynamic but non-per-packet.
-//
-VOID
-ODM_CmnInfoUpdate(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u4Byte			CmnInfo,
-	IN		u8Byte			Value	
-	)
-{
-	//
-	// This init variable may be changed in run time.
-	//
-	switch	(CmnInfo)
-	{
-		case ODM_CMNINFO_LINK_IN_PROGRESS:
-			pDM_Odm->bLinkInProcess = (BOOLEAN)Value;
-			break;
-		
-		case	ODM_CMNINFO_ABILITY:
-			pDM_Odm->SupportAbility = (u4Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_RF_TYPE:
-			pDM_Odm->RFType = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_WIFI_DIRECT:
-			pDM_Odm->bWIFI_Direct = (BOOLEAN)Value;
-			break;
-
-		case	ODM_CMNINFO_WIFI_DISPLAY:
-			pDM_Odm->bWIFI_Display = (BOOLEAN)Value;
-			break;
-
-		case	ODM_CMNINFO_LINK:
-			pDM_Odm->bLinked = (BOOLEAN)Value;
-			break;
-			
-		case	ODM_CMNINFO_STATION_STATE:
-			pDM_Odm->bsta_state = (BOOLEAN)Value;
-			break;
-			
-		case	ODM_CMNINFO_RSSI_MIN:
-			pDM_Odm->RSSI_Min= (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_DBG_COMP:
-			pDM_Odm->DebugComponents = Value;
-			break;
-
-		case	ODM_CMNINFO_DBG_LEVEL:
-			pDM_Odm->DebugLevel = (u4Byte)Value;
-			break;
-		case	ODM_CMNINFO_RA_THRESHOLD_HIGH:
-			pDM_Odm->RateAdaptive.HighRSSIThresh = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_RA_THRESHOLD_LOW:
-			pDM_Odm->RateAdaptive.LowRSSIThresh = (u1Byte)Value;
-			break;
-		// The following is for BT HS mode and BT coexist mechanism.
-		case ODM_CMNINFO_BT_DISABLED:
-			pDM_Odm->bBtDisabled = (BOOLEAN)Value;
-			break;
-			
-		case ODM_CMNINFO_BT_HS_CONNECT_PROCESS:
-			pDM_Odm->bBtConnectProcess = (BOOLEAN)Value;
-			break;
-		
-		case ODM_CMNINFO_BT_HS_RSSI:
-			pDM_Odm->btHsRssi = (u1Byte)Value;
-			break;
-			
-		case	ODM_CMNINFO_BT_OPERATION:
-			pDM_Odm->bBtHsOperation = (BOOLEAN)Value;
-			break;
-
-		case	ODM_CMNINFO_BT_LIMITED_DIG:
-			pDM_Odm->bBtLimitedDig = (BOOLEAN)Value;
-			break;	
-
-		case	ODM_CMNINFO_BT_DISABLE_EDCA:
-			pDM_Odm->bBtDisableEdcaTurbo = (BOOLEAN)Value;
-			break;
-			
-/*
-		case	ODM_CMNINFO_OP_MODE:
-			pDM_Odm->OPMode = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_WM_MODE:
-			pDM_Odm->WirelessMode = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_BAND:
-			pDM_Odm->BandType = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_SEC_CHNL_OFFSET:
-			pDM_Odm->SecChOffset = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_SEC_MODE:
-			pDM_Odm->Security = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_BW:
-			pDM_Odm->BandWidth = (u1Byte)Value;
-			break;
-
-		case	ODM_CMNINFO_CHNL:
-			pDM_Odm->Channel = (u1Byte)Value;
-			break;			
-*/	
-                default:
-			//do nothing
-			break;
-	}
-
-	
-}
-
-VOID
-odm_CommonInfoSelfInit(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
-	pDM_Odm->bCckHighPower = (BOOLEAN) ODM_GetBBReg(pDM_Odm, ODM_REG(CCK_RPT_FORMAT,pDM_Odm), ODM_BIT(CCK_RPT_FORMAT,pDM_Odm));		
-	pDM_Odm->RFPathRxEnable = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(BB_RX_PATH,pDM_Odm), ODM_BIT(BB_RX_PATH,pDM_Odm));
-#if (DM_ODM_SUPPORT_TYPE != ODM_CE)	
-	pDM_Odm->pbNet_closed = &pDM_Odm->BOOLEAN_temp;
-#endif
-
-	ODM_InitDebugSetting(pDM_Odm);
-
-	if(pDM_Odm->SupportICType==ODM_RTL8723A)
-	{
-		pDM_Odm->AntDivType = SW_ANTDIV;
-	}
-	else if(pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8192D))
-	{
-           #if(defined(CONFIG_HW_ANTENNA_DIVERSITY))	
-		pDM_Odm->AntDivType = HW_ANTDIV;
-           #elif (defined(CONFIG_SW_ANTENNA_DIVERSITY))
-		pDM_Odm->AntDivType = SW_ANTDIV;
-           #endif
-	}
-	pDM_Odm->TxRate = 0xFF;
-#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-
-	if(pDM_Odm->SupportICType==ODM_RTL8723B)
-	{
-		if((!pDM_Odm->DM_SWAT_Table.ANTA_ON || !pDM_Odm->DM_SWAT_Table.ANTB_ON))
-			pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
-	}
-
-#elif (DM_ODM_SUPPORT_TYPE == ODM_AP)
-
-	#if(defined(CONFIG_NOT_SUPPORT_ANTDIV)) 
-		pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Disable AntDiv function] : Not Support 2.4G & 5G Antenna Diversity\n"));
-	#elif(defined(CONFIG_2G5G_SUPPORT_ANTDIV)) 
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Enable AntDiv function] : 2.4G & 5G Support Antenna Diversity Simultaneously \n"));
-		pDM_FatTable->AntDiv_2G_5G = (ODM_ANTDIV_2G|ODM_ANTDIV_5G);
-		if(pDM_Odm->SupportICType & ODM_ANTDIV_SUPPORT)
-			pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;
-		if(*pDM_Odm->pBandType == ODM_BAND_5G )
-		{
-			#if ( defined(CONFIG_5G_CGCS_RX_DIVERSITY) )
-				pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV; 
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));
-			#elif( defined(CONFIG_5G_CG_TRX_DIVERSITY) )
-				pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
-			#elif( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) )
-				pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_SMART_ANTDIV\n"));
-			#endif
-		}		
-		else 	if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
-	        {
-			#if ( defined(CONFIG_2G_CGCS_RX_DIVERSITY) )
-				pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));
-			#elif( defined(CONFIG_2G_CG_TRX_DIVERSITY) )
-				pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
-			#elif( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
-				pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_SMART_ANTDIV\n"));
-			#endif
-		}
-        #elif(defined(CONFIG_5G_SUPPORT_ANTDIV))
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Enable AntDiv function] : Only 5G Support Antenna Diversity\n"));
-		pDM_FatTable->AntDiv_2G_5G = (ODM_ANTDIV_5G);
-		if(*pDM_Odm->pBandType == ODM_BAND_5G )
-		{
-			if(pDM_Odm->SupportICType & ODM_ANTDIV_5G_SUPPORT_IC)
-				pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;	
-			#if ( defined(CONFIG_5G_CGCS_RX_DIVERSITY) )
-				pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));
-			#elif( defined(CONFIG_5G_CG_TRX_DIVERSITY) )
-				pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
-			#elif( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) )
-				pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_SMART_ANTDIV\n"));
-			#endif
-	        }
-		else if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
-		{
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Not Support 2G AntDivType\n"));
-			pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
-		}
-	#elif(defined(CONFIG_2G_SUPPORT_ANTDIV)) 
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Enable AntDiv function] : Only 2.4G Support Antenna Diversity\n"));
-		pDM_FatTable->AntDiv_2G_5G = (ODM_ANTDIV_2G);
-		if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
-		{
-			if(pDM_Odm->SupportICType & ODM_ANTDIV_2G_SUPPORT_IC)
-				pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;
-			#if ( defined(CONFIG_2G_CGCS_RX_DIVERSITY) )
-				pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));
-			#elif( defined(CONFIG_2G_CG_TRX_DIVERSITY) )
-				pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
-			#elif( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
-				pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_SMART_ANTDIV\n"));
-                        #endif
-	        }
-		else if(*pDM_Odm->pBandType == ODM_BAND_5G )
-		{
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Not Support 5G AntDivType\n"));
-			pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
-		}
-	#endif
-#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
-#endif //#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-
-}
-
-VOID
-odm_CommonInfoSelfUpdate(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	u1Byte	EntryCnt=0;
-	u1Byte	i;
-	PSTA_INFO_T   	pEntry;
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-	PADAPTER	Adapter =  pDM_Odm->Adapter;
-	PMGNT_INFO	pMgntInfo = &Adapter->MgntInfo;
-
-	pEntry = pDM_Odm->pODM_StaInfo[0];
-	if(pMgntInfo->mAssoc)
-	{
-		pEntry->bUsed=TRUE;
-		for (i=0; i<6; i++)
-			pEntry->MacAddr[i] = pMgntInfo->Bssid[i];
-	}
-	else
-	{
-		pEntry->bUsed=FALSE;
-		for (i=0; i<6; i++)
-			pEntry->MacAddr[i] = 0;
-	}
-#endif
-
-
-	if(*(pDM_Odm->pBandWidth) == ODM_BW40M)
-	{
-		if(*(pDM_Odm->pSecChOffset) == 1)
-			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) -2;
-		else if(*(pDM_Odm->pSecChOffset) == 2)
-			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) +2;
-	}
-	else
-		pDM_Odm->ControlChannel = *(pDM_Odm->pChannel);
-
-	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-		pEntry = pDM_Odm->pODM_StaInfo[i];
-		if(IS_STA_VALID(pEntry))
-			EntryCnt++;
-	}
-	if(EntryCnt == 1)
-		pDM_Odm->bOneEntryOnly = TRUE;
-	else
-		pDM_Odm->bOneEntryOnly = FALSE;
-}
-
-VOID
-odm_CmnInfoInit_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_CmnInfoInit_Debug==>\n"));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("SupportPlatform=%d\n",pDM_Odm->SupportPlatform) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("SupportAbility=0x%x\n",pDM_Odm->SupportAbility) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("SupportInterface=%d\n",pDM_Odm->SupportInterface) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("SupportICType=0x%x\n",pDM_Odm->SupportICType) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("CutVersion=%d\n",pDM_Odm->CutVersion) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("FabVersion=%d\n",pDM_Odm->FabVersion) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("RFType=%d\n",pDM_Odm->RFType) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("BoardType=%d\n",pDM_Odm->BoardType) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("ExtLNA=%d\n",pDM_Odm->ExtLNA) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("ExtPA=%d\n",pDM_Odm->ExtPA) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("ExtTRSW=%d\n",pDM_Odm->ExtTRSW) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("PatchID=%d\n",pDM_Odm->PatchID) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bInHctTest=%d\n",pDM_Odm->bInHctTest) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bWIFITest=%d\n",pDM_Odm->bWIFITest) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bDualMacSmartConcurrent=%d\n",pDM_Odm->bDualMacSmartConcurrent) );
-
-}
-
-VOID
-odm_CmnInfoHook_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_CmnInfoHook_Debug==>\n"));	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pNumTxBytesUnicast=%llu\n",*(pDM_Odm->pNumTxBytesUnicast)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pNumRxBytesUnicast=%llu\n",*(pDM_Odm->pNumRxBytesUnicast)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pWirelessMode=0x%x\n",*(pDM_Odm->pWirelessMode)) );	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pSecChOffset=%d\n",*(pDM_Odm->pSecChOffset)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pSecurity=%d\n",*(pDM_Odm->pSecurity)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pBandWidth=%d\n",*(pDM_Odm->pBandWidth)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pChannel=%d\n",*(pDM_Odm->pChannel)) );
-
-	if(pDM_Odm->SupportICType==ODM_RTL8192D)
-	{
-		if(pDM_Odm->pBandType)
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pBandType=%d\n",*(pDM_Odm->pBandType)) );
-		if(pDM_Odm->pMacPhyMode)
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pMacPhyMode=%d\n",*(pDM_Odm->pMacPhyMode)) );
-		if(pDM_Odm->pBuddyAdapter)
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pbGetValueFromOtherMac=%d\n",*(pDM_Odm->pbGetValueFromOtherMac)) );
-		if(pDM_Odm->pBuddyAdapter)
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pBuddyAdapter=%p\n",*(pDM_Odm->pBuddyAdapter)) );
-		if(pDM_Odm->pbMasterOfDMSP)
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pbMasterOfDMSP=%d\n",*(pDM_Odm->pbMasterOfDMSP)) );
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pbScanInProcess=%d\n",*(pDM_Odm->pbScanInProcess)) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pbPowerSaving=%d\n",*(pDM_Odm->pbPowerSaving)) );
-
-	if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("pOnePathCCA=%d\n",*(pDM_Odm->pOnePathCCA)) );
-}
-
-VOID
-odm_CmnInfoUpdate_Debug(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_CmnInfoUpdate_Debug==>\n"));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bWIFI_Direct=%d\n",pDM_Odm->bWIFI_Direct) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bWIFI_Display=%d\n",pDM_Odm->bWIFI_Display) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bLinked=%d\n",pDM_Odm->bLinked) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("RSSI_Min=%d\n",pDM_Odm->RSSI_Min) );
-}
-
-VOID
-odm_BasicDbgMessage
-(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pDM_Odm->FalseAlmCnt);
-	pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
-	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_BasicDbgMsg==>\n"));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bLinked = %d, RSSI_Min = %d, CurrentIGI = 0x%x \n",
-		pDM_Odm->bLinked, pDM_Odm->RSSI_Min, pDM_DigTable->CurIGValue) );
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("Cnt_Cck_fail = %d, Cnt_Ofdm_fail = %d, Total False Alarm = %d\n",	
-		FalseAlmCnt->Cnt_Cck_fail, FalseAlmCnt->Cnt_Ofdm_fail, FalseAlmCnt->Cnt_all));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("RxRate = 0x%x, RSSI_A = %d, RSSI_B = %d\n", 
-		pDM_Odm->RxRate, pDM_Odm->RSSI_A, pDM_Odm->RSSI_B));
-	//ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("RSSI_C = %d, RSSI_D = %d\n", pDM_Odm->RSSI_C, pDM_Odm->RSSI_D));
-
-}
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID
-ODM_InitAllWorkItems(IN PDM_ODM_T	pDM_Odm )
-{
-#if USE_WORKITEM
-	PADAPTER		pAdapter = pDM_Odm->Adapter;
-
-	ODM_InitializeWorkItem(	pDM_Odm, 
-							&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem_8723B, 
-							(RT_WORKITEM_CALL_BACK)ODM_SW_AntDiv_WorkitemCallback,
-							(PVOID)pAdapter,
-							"AntennaSwitchWorkitem");
-	
-	ODM_InitializeWorkItem(	pDM_Odm, 
-							&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem, 
-							(RT_WORKITEM_CALL_BACK)odm_SwAntDivChkAntSwitchWorkitemCallback,
-							(PVOID)pAdapter,
-							"AntennaSwitchWorkitem");
-	
-
-	ODM_InitializeWorkItem(
-		pDM_Odm,
-		&(pDM_Odm->PathDivSwitchWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_PathDivChkAntSwitchWorkitemCallback, 
-		(PVOID)pAdapter,
-		"SWAS_WorkItem");
-
-	ODM_InitializeWorkItem(
-		pDM_Odm,
-		&(pDM_Odm->CCKPathDiversityWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_CCKTXPathDiversityWorkItemCallback, 
-		(PVOID)pAdapter,
-		"CCKTXPathDiversityWorkItem");
-
-	ODM_InitializeWorkItem(
-		pDM_Odm,
-		&(pDM_Odm->MPT_DIGWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_MPT_DIGWorkItemCallback, 
-		(PVOID)pAdapter,
-		"MPT_DIGWorkitem");
-
-	ODM_InitializeWorkItem(
-		pDM_Odm,
-		&(pDM_Odm->RaRptWorkitem), 
-		(RT_WORKITEM_CALL_BACK)ODM_UpdateInitRateWorkItemCallback, 
-		(PVOID)pAdapter,
-		"RaRptWorkitem");
-	
-#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-#if (RTL8188E_SUPPORT == 1)
-	ODM_InitializeWorkItem(
-		pDM_Odm,
-		&(pDM_Odm->FastAntTrainingWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_FastAntTrainingWorkItemCallback, 
-		(PVOID)pAdapter,
-		"FastAntTrainingWorkitem");
-#endif
-#endif
-	ODM_InitializeWorkItem(
-		pDM_Odm,
-		&(pDM_Odm->DM_RXHP_Table.PSDTimeWorkitem), 
-		(RT_WORKITEM_CALL_BACK)odm_PSD_RXHPWorkitemCallback, 
-		(PVOID)pAdapter,
-		"PSDRXHP_WorkItem");  
-#endif
-}
-
-VOID
-ODM_FreeAllWorkItems(IN PDM_ODM_T	pDM_Odm )
-{
-#if USE_WORKITEM
-	ODM_FreeWorkItem(	&(pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem_8723B));
-	
-	ODM_FreeWorkItem(	&(pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem));
-
-	ODM_FreeWorkItem(&(pDM_Odm->PathDivSwitchWorkitem));      
-
-	ODM_FreeWorkItem(&(pDM_Odm->CCKPathDiversityWorkitem));
-	
-	ODM_FreeWorkItem(&(pDM_Odm->FastAntTrainingWorkitem));
-
-	ODM_FreeWorkItem(&(pDM_Odm->MPT_DIGWorkitem));
-
-	ODM_FreeWorkItem(&(pDM_Odm->RaRptWorkitem));
-
-	ODM_FreeWorkItem((&pDM_Odm->DM_RXHP_Table.PSDTimeWorkitem));
-#endif
-
-}
-#endif
-
-/*
-VOID
-odm_FindMinimumRSSI(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	u4Byte	i;
-	u1Byte	RSSI_Min = 0xFF;
-
-	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-//		if(pDM_Odm->pODM_StaInfo[i] != NULL)
-		if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[i]) )
-		{
-			if(pDM_Odm->pODM_StaInfo[i]->RSSI_Ave < RSSI_Min)
-			{
-				RSSI_Min = pDM_Odm->pODM_StaInfo[i]->RSSI_Ave;
-			}
-		}
-	}
-
-	pDM_Odm->RSSI_Min = RSSI_Min;
-
-}
-
-VOID
-odm_IsLinked(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	u4Byte i;
-	BOOLEAN Linked = FALSE;
-	
-	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-			if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[i]) )
-			{			
-				Linked = TRUE;
-				break;
-			}
-		
-	}
-
-	pDM_Odm->bLinked = Linked;
-}
-*/
-
-
-//3============================================================
-//3 DIG
-//3============================================================
-/*-----------------------------------------------------------------------------
- * Function:	odm_DIGInit()
- *
- * Overview:	Set DIG scheme init value.
- *
- * Input:		NONE
- *
- * Output:		NONE
- *
- * Return:		NONE
- *
- * Revised History:
- *	When		Who		Remark
- *
- *---------------------------------------------------------------------------*/
-VOID
-ODM_ChangeDynamicInitGainThresh(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		DM_Type,
-	IN	u4Byte		DM_Value
-	)
-{
-	pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
-
-	if (DM_Type == DIG_TYPE_THRESH_HIGH)
-	{
-		pDM_DigTable->RssiHighThresh = DM_Value;		
-	}
-	else if (DM_Type == DIG_TYPE_THRESH_LOW)
-	{
-		pDM_DigTable->RssiLowThresh = DM_Value;
-	}
-	else if (DM_Type == DIG_TYPE_ENABLE)
-	{
-		pDM_DigTable->Dig_Enable_Flag	= TRUE;
-	}	
-	else if (DM_Type == DIG_TYPE_DISABLE)
-	{
-		pDM_DigTable->Dig_Enable_Flag = FALSE;
-	}	
-	else if (DM_Type == DIG_TYPE_BACKOFF)
-	{
-		if(DM_Value > 30)
-			DM_Value = 30;
-		pDM_DigTable->BackoffVal = (u1Byte)DM_Value;
-	}
-	else if(DM_Type == DIG_TYPE_RX_GAIN_MIN)
-	{
-		if(DM_Value == 0)
-			DM_Value = 0x1;
-		pDM_DigTable->rx_gain_range_min = (u1Byte)DM_Value;
-	}
-	else if(DM_Type == DIG_TYPE_RX_GAIN_MAX)
-	{
-		if(DM_Value > 0x50)
-			DM_Value = 0x50;
-		pDM_DigTable->rx_gain_range_max = (u1Byte)DM_Value;
-	}
-}	/* DM_ChangeDynamicInitGainThresh */
-
-int getIGIForDiff(int value_IGI)
-{
-	#define ONERCCA_LOW_TH		0x30
-	#define ONERCCA_LOW_DIFF	8
-
-	if (value_IGI < ONERCCA_LOW_TH) {
-		if ((ONERCCA_LOW_TH - value_IGI) < ONERCCA_LOW_DIFF)
-			return ONERCCA_LOW_TH;
-		else
-			return value_IGI + ONERCCA_LOW_DIFF;
-	} else {
-		return value_IGI;
-	}
-}
-
-
-VOID
-odm_AdaptivityInit(
-IN PDM_ODM_T pDM_Odm
-)
-{
-	if(pDM_Odm->SupportICType == ODM_RTL8723B)
-	{
-		pDM_Odm->TH_L2H_ini = 0xf8; // -8
-	}
-	if((pDM_Odm->SupportICType == ODM_RTL8192E)&&(pDM_Odm->SupportInterface == ODM_ITRF_PCIE))
-	{
-		pDM_Odm->TH_L2H_ini = 0xf0; // -16
-	}
-	else
-	{
-		pDM_Odm->TH_L2H_ini = 0xf9; // -7
-	}
-	
-	pDM_Odm->TH_EDCCA_HL_diff = 7;
-	pDM_Odm->IGI_Base = 0x32;
-	pDM_Odm->IGI_target = 0x1c;
-	pDM_Odm->ForceEDCCA = 0;
-	pDM_Odm->AdapEn_RSSI = 20;
-
-	//Reg524[11]=0 is easily to transmit packets during adaptivity test
-
-	//ODM_SetBBReg(pDM_Odm, 0x524, BIT11, 1);// stop counting if EDCCA is asserted
-}
-
-// Add by Neil Chen to enable edcca to MP Platform 
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-VOID
-odm_EnableEDCCA(
-	IN		PDM_ODM_T		pDM_Odm
-)
-{
-
-	// This should be moved out of OUTSRC
-	PADAPTER		pAdapter	= pDM_Odm->Adapter;
-	// Enable EDCCA. The value is suggested by SD3 Wilson.
-
-	//
-	// Revised for ASUS 11b/g performance issues, suggested by BB Neil, 2012.04.13.
-	//
-	if((pDM_Odm->SupportICType == ODM_RTL8723A)&&(IS_WIRELESS_MODE_G(pAdapter)))
-	{
-		//PlatformEFIOWrite1Byte(Adapter, rOFDM0_ECCAThreshold, 0x00);
-		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold,0x00);
-		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold+2,0xFD);
-		
-	}	
-	else
-	{
-		//PlatformEFIOWrite1Byte(Adapter, rOFDM0_ECCAThreshold, 0x03);
-		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold,0x03);
-		ODM_Write1Byte(pDM_Odm,rOFDM0_ECCAThreshold+2,0x00);
-	}	
-	
-	//PlatformEFIOWrite1Byte(Adapter, rOFDM0_ECCAThreshold+2, 0x00);
-}
-
-VOID
-odm_DisableEDCCA(
-	IN		PDM_ODM_T		pDM_Odm
-)
-{	
-	// Disable EDCCA..
-	ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold, 0x7f);
-	ODM_Write1Byte(pDM_Odm, rOFDM0_ECCAThreshold+2, 0x7f);
-}
-
-//
-// Description: According to initial gain value to determine to enable or disable EDCCA.
-//
-// Suggested by SD3 Wilson. Added by tynli. 2011.11.25.
-//
-VOID
-odm_DynamicEDCCA(
-	IN		PDM_ODM_T		pDM_Odm
-)
-{
-	PADAPTER		pAdapter	= pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	u1Byte	RegC50, RegC58;
-	BOOLEAN		bFwCurrentInPSMode=FALSE;	
-
-	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_FW_PSMODE_STATUS, (pu1Byte)(&bFwCurrentInPSMode));	
-
-	// Disable EDCCA mode while under LPS mode, added by Roger, 2012.09.14.
-	if(bFwCurrentInPSMode)
-		return;
-	
-	RegC50 = (u1Byte)ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0);
-	RegC58 = (u1Byte)ODM_GetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0);
-
-
- 	if((RegC50 > 0x28 && RegC58 > 0x28) ||
-  		((pDM_Odm->SupportICType == ODM_RTL8723A && IS_WIRELESS_MODE_G(pAdapter) && RegC50>0x26)) ||
-  		(pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 > 0x28))
-	{
-		if(!pHalData->bPreEdccaEnable)
-		{
-			odm_EnableEDCCA(pDM_Odm);
-			pHalData->bPreEdccaEnable = TRUE;
-		}
-		
-	}
-	else if((RegC50 < 0x25 && RegC58 < 0x25) || (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 < 0x25))
-	{
-		if(pHalData->bPreEdccaEnable)
-		{
-			odm_DisableEDCCA(pDM_Odm);
-			pHalData->bPreEdccaEnable = FALSE;
-		}
-	}
-}
-
-
-#endif    // end MP platform support
-
-VOID
-odm_Adaptivity(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			IGI
-)
-{
-	s1Byte TH_L2H_dmc, TH_H2L_dmc;
-	s1Byte Diff, IGI_target;
-	BOOLEAN EDCCA_State = 0;
-	BOOLEAN isInterference = 0;
-	u4Byte	value32 = 0;
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER		pAdapter	= pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	BOOLEAN		bFwCurrentInPSMode=FALSE;	
-	PMGNT_INFO				pMgntInfo = &(pAdapter->MgntInfo);
-		
-	pAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_FW_PSMODE_STATUS, (pu1Byte)(&bFwCurrentInPSMode));	
-
-	// Disable EDCCA mode while under LPS mode, added by Roger, 2012.09.14.
-	if(bFwCurrentInPSMode)
-		return;
-#endif
-
-	if(!(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY))
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("Go to odm_DynamicEDCCA() \n"));
-		// Add by Neil Chen to enable edcca to MP Platform 
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-		// Adjust EDCCA.
-		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-			odm_DynamicEDCCA(pDM_Odm);
-#endif
-		return;
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_Adaptivity() =====> \n"));
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("ForceEDCCA=%d, IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d, AdapEn_RSSI = %d\n", 
-		pDM_Odm->ForceEDCCA, pDM_Odm->IGI_Base, pDM_Odm->TH_L2H_ini, pDM_Odm->TH_EDCCA_HL_diff, pDM_Odm->AdapEn_RSSI));
-
-	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
-		ODM_SetBBReg(pDM_Odm, 0x800, BIT10, 0); //ADC_mask enable
-
-	if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {
-		ODM_SetBBReg(pDM_Odm, 0x908, bMaskDWord, 0x208);
-		value32 = ODM_GetBBReg(pDM_Odm, 0xdf4, bMaskDWord);
-	}
-
-	if (value32 & BIT30)
-		isInterference = TRUE;
-	else
-		isInterference = FALSE;
-
-	if(((!pDM_Odm->bLinked) && (!isInterference)) || (*pDM_Odm->pChannel >= 149)) // Band4 doesn't need adaptivity
-	{
-		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-		{
-			ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, 0x7f);
-			ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, 0x7f);
-		}
-		else
-			ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, 0xFFFF, (0x7f<<8) | 0x7f);
-		return;
-	}
-
-#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)	
-		if(pMgntInfo->IOTPeer == HT_IOT_PEER_BROADCOM)
-			ODM_Write1Byte(pDM_Odm, REG_TRX_SIFS_OFDM, 0x0a); 
-		else
-			ODM_Write1Byte(pDM_Odm, REG_TRX_SIFS_OFDM, 0x0e);
-#endif
-	if(!pDM_Odm->ForceEDCCA)
-	{
-		if(pDM_Odm->RSSI_Min > pDM_Odm->AdapEn_RSSI)
-			EDCCA_State = 1;
-		else if(pDM_Odm->RSSI_Min < (pDM_Odm->AdapEn_RSSI - 5))
-			EDCCA_State = 0;
-	}
-	else
-		EDCCA_State = 1;
-	//if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (*pDM_Odm->pBandType == BAND_ON_5G))
-		//IGI_target = pDM_Odm->IGI_Base;
-	//else
-	{
-
-		if(*pDM_Odm->pBandWidth == ODM_BW20M) //CHANNEL_WIDTH_20
-			IGI_target = pDM_Odm->IGI_Base;
-		else if(*pDM_Odm->pBandWidth == ODM_BW40M)
-			IGI_target = pDM_Odm->IGI_Base + 2;
-		else if(*pDM_Odm->pBandWidth == ODM_BW80M)
-			IGI_target = pDM_Odm->IGI_Base + 6;
-		else
-			IGI_target = pDM_Odm->IGI_Base;
-	}
-
-	pDM_Odm->IGI_target = (u1Byte) IGI_target;
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("BandWidth=%s, IGI_target=0x%x, EDCCA_State=%d\n",
-		(*pDM_Odm->pBandWidth==ODM_BW80M)?"80M":((*pDM_Odm->pBandWidth==ODM_BW40M)?"40M":"20M"), IGI_target, EDCCA_State));
-
-	if(EDCCA_State == 1)
-	{
-		Diff = IGI_target -(s1Byte)IGI;
-		TH_L2H_dmc = pDM_Odm->TH_L2H_ini + Diff;
-		if(TH_L2H_dmc > 10) 	TH_L2H_dmc = 10;
-		TH_H2L_dmc = TH_L2H_dmc - pDM_Odm->TH_EDCCA_HL_diff;
-	}
-	else
-	{
-		TH_L2H_dmc = 0x7f;
-		TH_H2L_dmc = 0x7f;
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n", 
-		IGI, TH_L2H_dmc, TH_H2L_dmc));
-
-	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-	{
-		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte0, (u1Byte)TH_L2H_dmc);
-		ODM_SetBBReg(pDM_Odm,rOFDM0_ECCAThreshold, bMaskByte2, (u1Byte)TH_H2L_dmc);
-	}
-	else
-		ODM_SetBBReg(pDM_Odm, rFPGA0_XB_LSSIReadBack, 0xFFFF, ((u1Byte)TH_H2L_dmc<<8) | (u1Byte)TH_L2H_dmc);
-}
-
-VOID
-ODM_DynamicATCSwitch_init(
-	IN 		PDM_ODM_T 		pDM_Odm
-)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN )
-
-	pDM_Odm->CrystalCap = pHalData->CrystalCap;
-	pDM_Odm->bATCStatus = (u1Byte)ODM_GetBBReg(pDM_Odm, rOFDM1_CFOTracking, BIT11);
-	pDM_Odm->CFOThreshold = CFO_Threshold_Xtal;
-
-#endif
-}
-
-VOID
-ODM_DynamicATCSwitch(
-	IN 		PDM_ODM_T 		pDM_Odm
-)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u1Byte 			CrystalCap,ATC_status_temp = 0;
-	u4Byte			packet_count;
-	int				CFO_kHz_A,CFO_kHz_B,CFO_ave = 0, Adjust_Xtal = 0;
-	int				CFO_ave_diff;
-
-#if (MP_DRIVER == 1)
-	if ( *(pDM_Odm->mp_mode) == 1)
-		pDM_Odm->bLinked = TRUE;
-#endif 
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN )
-
-	if(!(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_ATC))
-		return;
-
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("=========> ODM_DynamicATCSwitch()\n"));
-
-	//2 No link!
-	//
-	if(!pDM_Odm->bLinked)
-	{	
-		//3 
-		//3 1.Enable ATC
-		if(pDM_Odm->bATCStatus == ATC_Status_Off)
-		{
-			if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-				ODM_SetBBReg(pDM_Odm, rOFDM1_CFOTracking, BIT11, ATC_Status_On);
-			
-			if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
-				ODM_SetBBReg(pDM_Odm, rFc_area_Jaguar, BIT14, ATC_Status_On);
-			
-			pDM_Odm->bATCStatus = ATC_Status_On;
-		}
-
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): No link!!\n"));
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): ATCStatus = %d\n", pDM_Odm->bATCStatus));
-
-		//3 2.Disable CFO tracking for BT
-		if(!pDM_Odm->bBtDisabled)
-		{
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): Disable CFO tracking for BT!!\n"));
-			return;
-		}
-
-		//3 3.Reset Crystal Cap.
-		if(pDM_Odm->CrystalCap != pHalData->CrystalCap)
-		{
-			pDM_Odm->CrystalCap = pHalData->CrystalCap;
-			CrystalCap = pDM_Odm->CrystalCap & 0x3f;
-			odm_Write_CrystalCap(pDM_Odm,CrystalCap);
-		}
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): CrystalCap = 0x%x\n", pDM_Odm->CrystalCap));
-		
-	}
-	else
-	{
-
-	//2 Initialization
-	//
-		//3 1. Calculate CFO for path-A & path-B
-		CFO_kHz_A =  (int)(pDM_Odm->CFO_tail[0] * 3125)  / 1280;
-		CFO_kHz_B =  (int)(pDM_Odm->CFO_tail[1] * 3125)  / 1280;
-		packet_count = pDM_Odm->packetCount;
-		
-		//3 2.No new packet
-		if(packet_count == pDM_Odm->packetCount_pre)
-		{
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): packet counter doesn't change\n"));
-			return;
-		}
-		pDM_Odm->packetCount_pre = packet_count;
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): packet counter = %d\n", pDM_Odm->packetCount));
-		
-		//3 3.Average CFO
-		if(pDM_Odm->RFType == ODM_1T1R)
-			CFO_ave = CFO_kHz_A;
-		else
-			CFO_ave = (int)(CFO_kHz_A + CFO_kHz_B) >> 1;
-
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): CFO_kHz_A = %dkHz, CFO_kHz_B = %dkHz, CFO_ave = %dkHz\n", 
-						CFO_kHz_A, CFO_kHz_B, CFO_ave));
-
-		//3 4.Avoid abnormal large CFO
-		CFO_ave_diff = (pDM_Odm->CFO_ave_pre >= CFO_ave)?(pDM_Odm->CFO_ave_pre - CFO_ave):(CFO_ave - pDM_Odm->CFO_ave_pre);
-		if(CFO_ave_diff > 20 && pDM_Odm->largeCFOHit == 0)
-		{
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): first large CFO hit\n"));
-			pDM_Odm->largeCFOHit = 1;
-			return;
-		}
-		else
-			pDM_Odm->largeCFOHit = 0;
-		pDM_Odm->CFO_ave_pre = CFO_ave;
-
-	//2 CFO tracking by adjusting Xtal cap.
-	//
-		if (pDM_Odm->bBtDisabled)
-		{
-			//3 1.Dynamic Xtal threshold
-			if(CFO_ave >= -pDM_Odm->CFOThreshold && CFO_ave <= pDM_Odm->CFOThreshold && pDM_Odm->bIsfreeze == 0)
-			{
-				if (pDM_Odm->CFOThreshold == CFO_Threshold_Xtal)
-				{
-					pDM_Odm->CFOThreshold = CFO_Threshold_Xtal + 10;
-					pDM_Odm->bIsfreeze = 1;
-				}
-				else
-					pDM_Odm->CFOThreshold = CFO_Threshold_Xtal;
-			}
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): Dynamic threshold = %d\n", pDM_Odm->CFOThreshold));
-			
-		//3	 2.Calculate Xtal offset
-			if(CFO_ave > pDM_Odm->CFOThreshold && pDM_Odm->CrystalCap < 0x3f)
-				Adjust_Xtal =  ((CFO_ave - CFO_Threshold_Xtal) >> 2) + 1;
-			else if(CFO_ave < (-pDM_Odm->CFOThreshold) && pDM_Odm->CrystalCap > 0)
-				Adjust_Xtal =  ((CFO_ave + CFO_Threshold_Xtal) >> 2) - 1;
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): Crystal cap = 0x%x, Crystal cap offset = %d\n", pDM_Odm->CrystalCap, Adjust_Xtal));
-
-			//3 3.Adjudt Crystal Cap.
-			if(Adjust_Xtal != 0)
-			{
-				pDM_Odm->bIsfreeze = 0;
-				pDM_Odm->CrystalCap = pDM_Odm->CrystalCap + Adjust_Xtal;
-
-				if(pDM_Odm->CrystalCap > 0x3f)
-					pDM_Odm->CrystalCap = 0x3f;
-				else if (pDM_Odm->CrystalCap < 0)
-					pDM_Odm->CrystalCap = 0;
-
-				CrystalCap = pDM_Odm->CrystalCap & 0x3f;
-				odm_Write_CrystalCap(pDM_Odm,CrystalCap);
-	
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): New crystal cap = 0x%x \n", pDM_Odm->CrystalCap));
-			}
-		}
-		else if(pDM_Odm->CrystalCap != pHalData->CrystalCap)
-		{
-			//3 Reset Xtal Cap when BT is enable
-			pDM_Odm->CrystalCap = pHalData->CrystalCap;
-			CrystalCap = pDM_Odm->CrystalCap & 0x3f;
-			odm_Write_CrystalCap(pDM_Odm,CrystalCap);
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): Disable CFO tracking for BT!! (CrystalCap is reset)\n"));
-		}
-		else
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): Disable CFO tracking for BT!! (CrystalCap is unchanged)\n"));
-		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES){
-			//2 Dynamic ATC switch
-			//
-				//3 1.Enable ATC when CFO is larger then 80kHz
-				if(CFO_ave < CFO_Threshold_ATC && CFO_ave > -CFO_Threshold_ATC)
-				{
-					if(pDM_Odm->bATCStatus == ATC_Status_On)
-					{
-					ODM_SetBBReg(pDM_Odm, rOFDM1_CFOTracking, BIT11, ATC_Status_Off);
-					pDM_Odm->bATCStatus = ATC_Status_Off;
-					}
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): Disable ATC!!\n"));
-				}
-				else
-				{
-					if(pDM_Odm->bATCStatus == ATC_Status_Off)
-					{
-						ODM_SetBBReg(pDM_Odm, rOFDM1_CFOTracking, BIT11, ATC_Status_On);
-						pDM_Odm->bATCStatus = ATC_Status_On;
-					}
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, ("ODM_DynamicATCSwitch(): Enable ATC!!\n"));
-				}
-		}
-	}
-#endif
-}
-
-VOID
-odm_Write_CrystalCap(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			CrystalCap
-)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
-	if(IS_HARDWARE_TYPE_8192D(Adapter))
-	{
-		PHY_SetBBReg(Adapter, 0x24, 0xF0, CrystalCap & 0x0F);
-		PHY_SetBBReg(Adapter, 0x28, 0xF0000000, ((CrystalCap & 0xF0) >> 4));
-	}
-
-	if(IS_HARDWARE_TYPE_8188E(Adapter))
-	{
-		// write 0x24[16:11] = 0x24[22:17] = CrystalCap
-		PHY_SetBBReg(Adapter, REG_AFE_XTAL_CTRL, 0x7ff800, (CrystalCap | (CrystalCap << 6)));
-	}
-	
-	if(IS_HARDWARE_TYPE_8812(Adapter))
-	{
-		// write 0x2C[30:25] = 0x2C[24:19] = CrystalCap
-		CrystalCap = CrystalCap & 0x3F;
-		PHY_SetBBReg(Adapter, REG_MAC_PHY_CTRL, 0x7FF80000, (CrystalCap | (CrystalCap << 6)));
-	}	
-	
-	//only for B-cut
-	if ((IS_HARDWARE_TYPE_8723A(Adapter) && pHalData->EEPROMVersion >= 0x01) ||
-		IS_HARDWARE_TYPE_8723B(Adapter) ||IS_HARDWARE_TYPE_8192E(Adapter) || IS_HARDWARE_TYPE_8821(Adapter))
-	{
-		// 0x2C[23:18] = 0x2C[17:12] = CrystalCap
-		CrystalCap = CrystalCap & 0x3F;
-		PHY_SetBBReg(Adapter, REG_MAC_PHY_CTRL, 0xFFF000, (CrystalCap | (CrystalCap << 6)));	
-	}
-	
-	if(IS_HARDWARE_TYPE_8723AE(Adapter))
-		PHY_SetBBReg(Adapter, REG_LDOA15_CTRL, bMaskDWord, 0x01572505);				
-
-}
-
-
-VOID
-ODM_Write_DIG(
-	IN	PDM_ODM_T		pDM_Odm,
-	IN	u1Byte			CurrentIGI
-	)
-{
-	pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
-
-	if(pDM_Odm->StopDIG)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("Stop Writing IGI\n"));
-		return;
-	}
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("ODM_REG(IGI_A,pDM_Odm)=0x%x, ODM_BIT(IGI,pDM_Odm)=0x%x \n",
-		ODM_REG(IGI_A,pDM_Odm),ODM_BIT(IGI,pDM_Odm)));
-
-	if(pDM_DigTable->CurIGValue != CurrentIGI)//if(pDM_DigTable->PreIGValue != CurrentIGI)
-	{
-		if(pDM_Odm->SupportPlatform & (ODM_CE|ODM_WIN))
-		{ 
-				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
-			if(pDM_Odm->RFType != ODM_1T1R)
-				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
-			}
-		else if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
-		{
-			switch(*(pDM_Odm->pOnePathCCA))
-			{
-			case ODM_CCA_2R:
-			ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
-					if(pDM_Odm->RFType != ODM_1T1R)
-					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
-				break;
-			case ODM_CCA_1R_A:
-				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
-					if(pDM_Odm->RFType != ODM_1T1R)
-					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
-				break;
-			case ODM_CCA_1R_B:
-				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
-					if(pDM_Odm->RFType != ODM_1T1R)
-					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
-					break;
-				}
-		}
-		
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("CurrentIGI(0x%02x). \n",CurrentIGI));
-		//pDM_DigTable->PreIGValue = pDM_DigTable->CurIGValue;
-		pDM_DigTable->CurIGValue = CurrentIGI;
-	}	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("ODM_Write_DIG():CurrentIGI=0x%x \n",CurrentIGI));
-	
-}
-
-VOID
-odm_DIGbyRSSI_LPS(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	//PADAPTER					pAdapter =pDM_Odm->Adapter;
-	//pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
-	PFALSE_ALARM_STATISTICS		pFalseAlmCnt = &pDM_Odm->FalseAlmCnt;
-
-#if 0		//and 2.3.5 coding rule
-	struct mlme_priv	*pmlmepriv = &(pAdapter->mlmepriv);
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-#endif 
-
-	u1Byte	RSSI_Lower=DM_DIG_MIN_NIC;   //0x1E or 0x1C
-	u1Byte	CurrentIGI=pDM_Odm->RSSI_Min;
-
-	CurrentIGI=CurrentIGI+RSSI_OFFSET_DIG;
-
-
-	//ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG_LPS, ODM_DBG_LOUD, ("odm_DIG()==>\n"));
-
-	// Using FW PS mode to make IGI
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("---Neil---odm_DIG is in LPS mode\n"));
-	//Adjust by  FA in LPS MODE
-	if(pFalseAlmCnt->Cnt_all> DM_DIG_FA_TH2_LPS)
-		CurrentIGI = CurrentIGI+2;
-	else if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1_LPS)
-		CurrentIGI = CurrentIGI+1;
-	else if(pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0_LPS)
-		CurrentIGI = CurrentIGI-1;	
-
-
-	//Lower bound checking
-
-	//RSSI Lower bound check
-	if((pDM_Odm->RSSI_Min-10) > DM_DIG_MIN_NIC)
-		RSSI_Lower =(pDM_Odm->RSSI_Min-10);
-	else
-		RSSI_Lower =DM_DIG_MIN_NIC;
-
-	//Upper and Lower Bound checking
-	 if(CurrentIGI > DM_DIG_MAX_NIC)
-	 	CurrentIGI=DM_DIG_MAX_NIC;
-	 else if(CurrentIGI < RSSI_Lower)
-		CurrentIGI =RSSI_Lower;
-
-	ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
-
-}
-
-VOID
-odm_DIGInit(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
-
-	//pDM_DigTable->Dig_Enable_Flag = TRUE;
-	//pDM_DigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_MAX;	
-	pDM_DigTable->CurIGValue = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm));
-	//pDM_DigTable->PreIGValue = 0x0;
-	//pDM_DigTable->CurSTAConnectState = pDM_DigTable->PreSTAConnectState = DIG_STA_DISCONNECT;
-	//pDM_DigTable->CurMultiSTAConnectState = DIG_MultiSTA_DISCONNECT;
-	pDM_DigTable->RssiLowThresh 	= DM_DIG_THRESH_LOW;
-	pDM_DigTable->RssiHighThresh 	= DM_DIG_THRESH_HIGH;
-	pDM_DigTable->FALowThresh	= DM_FALSEALARM_THRESH_LOW;
-	pDM_DigTable->FAHighThresh	= DM_FALSEALARM_THRESH_HIGH;
-	if(pDM_Odm->BoardType & (ODM_BOARD_EXT_PA|ODM_BOARD_EXT_LNA))
-	{
-		pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;
-		pDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC;
-	}
-	else
-	{
-		pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;
-		pDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC;
-	}
-	pDM_DigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;
-	pDM_DigTable->BackoffVal_range_max = DM_DIG_BACKOFF_MAX;
-	pDM_DigTable->BackoffVal_range_min = DM_DIG_BACKOFF_MIN;
-	pDM_DigTable->PreCCK_CCAThres = 0xFF;
-	pDM_DigTable->CurCCK_CCAThres = 0x83;
-	pDM_DigTable->ForbiddenIGI = DM_DIG_MIN_NIC;
-	pDM_DigTable->LargeFAHit = 0;
-	pDM_DigTable->Recover_cnt = 0;
-	pDM_DigTable->DIG_Dynamic_MIN_0 = DM_DIG_MIN_NIC;
-	pDM_DigTable->DIG_Dynamic_MIN_1 = DM_DIG_MIN_NIC;
-	pDM_DigTable->bMediaConnect_0 = FALSE;
-	pDM_DigTable->bMediaConnect_1 = FALSE;
-	
-	//To Initialize pDM_Odm->bDMInitialGainEnable == FALSE to avoid DIG error
-	pDM_Odm->bDMInitialGainEnable = TRUE;
-
-	//To Initi BT30 IGI
-	pDM_DigTable->BT30_CurIGI=0x32;
-
-}
-
-VOID
-odm_DigForBtHsMode(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	pDIG_T					pDM_DigTable=&pDM_Odm->DM_DigTable;
-	u1Byte					digForBtHs=0;
-	u1Byte					digUpBound=0x5a;
-	
-	if(pDM_Odm->bBtConnectProcess)
-	{
-		if(pDM_Odm->SupportICType&(ODM_RTL8723A))
-			digForBtHs = 0x28;
-		else
-			digForBtHs = 0x22;
-	}
-	else
-	{
-		//
-		// Decide DIG value by BT HS RSSI.
-		//
-		digForBtHs = pDM_Odm->btHsRssi+4;
-		
-		//DIG Bound
-		if(pDM_Odm->SupportICType&(ODM_RTL8723A))
-			digUpBound = 0x3e;
-		
-		if(digForBtHs > digUpBound)
-			digForBtHs = digUpBound;
-		if(digForBtHs < 0x1c)
-			digForBtHs = 0x1c;
-
-		// update Current IGI
-		pDM_DigTable->BT30_CurIGI = digForBtHs;
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DigForBtHsMode() : set DigValue=0x%x\n", digForBtHs));
-#endif
-}
-
-VOID 
-odm_DIG(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
-	PFALSE_ALARM_STATISTICS		pFalseAlmCnt = &pDM_Odm->FalseAlmCnt;
-	pRXHP_T						pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
-	u1Byte						DIG_Dynamic_MIN;
-	u1Byte						DIG_MaxOfMin;
-	BOOLEAN						FirstConnect, FirstDisConnect;
-	u1Byte						dm_dig_max, dm_dig_min, offset;
-	u1Byte						CurrentIGI = pDM_DigTable->CurIGValue;
-	u1Byte						Adap_IGI_Upper = pDM_Odm->IGI_target + 30 + (u1Byte) pDM_Odm->TH_L2H_ini -(u1Byte) pDM_Odm->TH_EDCCA_HL_diff;
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-// This should be moved out of OUTSRC
-	PADAPTER		pAdapter	= pDM_Odm->Adapter;
-#if OS_WIN_FROM_WIN7(OS_VERSION)
-	if(IsAPModeExist( pAdapter) && pAdapter->bInHctTest)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: Is AP mode or In HCT Test \n"));
-		return;
-	}
-#endif
-/*
-	if (pDM_Odm->SupportICType==ODM_RTL8723B)
-		return;
-*/
-
-	if(pDM_Odm->bBtHsOperation)
-	{
-		odm_DigForBtHsMode(pDM_Odm);
-	}
-	
-	if(!(pDM_Odm->SupportICType &(ODM_RTL8723A|ODM_RTL8188E)))
-	{
-		if(pRX_HP_Table->RXHP_flag == 1)
-		{
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: In RXHP Operation \n"));
-			return;	
-		}
-	}	
-#endif
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV	
-	if((pDM_Odm->bLinked) && (pDM_Odm->Adapter->registrypriv.force_igi !=0))
-	{	
-		printk("pDM_Odm->RSSI_Min=%d \n",pDM_Odm->RSSI_Min);
-		ODM_Write_DIG(pDM_Odm,pDM_Odm->Adapter->registrypriv.force_igi);
-		return;
-	}
-#endif
-#endif
-#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-	prtl8192cd_priv	priv			= pDM_Odm->priv;	
-	if (!((priv->up_time > 5) && (priv->up_time % 2)) )
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: Not In DIG Operation Period \n"));
-		return;
-	}
-#endif
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG()==>\n"));
-	//if(!(pDM_Odm->SupportAbility & (ODM_BB_DIG|ODM_BB_FA_CNT)))
-	if((!(pDM_Odm->SupportAbility&ODM_BB_DIG)) ||(!(pDM_Odm->SupportAbility&ODM_BB_FA_CNT)))
-	{
-#if 0	
-		if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
-		{
-			if ((pDM_Odm->SupportICType == ODM_RTL8192C) && (pDM_Odm->ExtLNA == 1))
-				CurrentIGI = 0x30; //pDM_DigTable->CurIGValue  = 0x30;
-			else
-				CurrentIGI = 0x20; //pDM_DigTable->CurIGValue  = 0x20;
-			ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
-		}
-#endif		
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: SupportAbility ODM_BB_DIG or ODM_BB_FA_CNT is disabled\n"));
-		return;
-	}
-		
-	if(*(pDM_Odm->pbScanInProcess))
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: In Scan Progress \n"));
-	    	return;
-	}
-
-	//add by Neil Chen to avoid PSD is processing
-	if(pDM_Odm->SupportICType==ODM_RTL8723A)
-	{
-	        if(pDM_Odm->bDMInitialGainEnable == FALSE)
-	        {
-		        ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: PSD is Processing \n"));
-		        return;
-	        }
-	}
-		
-	if(pDM_Odm->SupportICType == ODM_RTL8192D)
-	{
-		if(*(pDM_Odm->pMacPhyMode) == ODM_DMSP)
-		{
-			if(*(pDM_Odm->pbMasterOfDMSP))
-			{
-				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
-				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);	
-				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
-			}
-			else
-			{
-				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_1;
-				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == FALSE);	
-				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == TRUE);
-			}
-		}
-		else
-		{
-			if(*(pDM_Odm->pBandType) == ODM_BAND_5G)
-			{
-				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
-				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
-				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
-			}
-			else
-			{
-				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_1;
-				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == FALSE);
-				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == TRUE);
-			}
-		}
-	}
-	else
-	{	
-		DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
-		FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
-		FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
-	}
-	
-	//1 Boundary Decision
-	if(pDM_Odm->SupportICType & (ODM_RTL8192C) &&(pDM_Odm->BoardType & (ODM_BOARD_EXT_LNA | ODM_BOARD_EXT_PA)))
-	{
-		if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
-		{
-
-			dm_dig_max = DM_DIG_MAX_AP_HP;
-			dm_dig_min = DM_DIG_MIN_AP_HP;
-		}
-		else
-		{
-			dm_dig_max = DM_DIG_MAX_NIC_HP;
-			dm_dig_min = DM_DIG_MIN_NIC_HP;
-		}
-		DIG_MaxOfMin = DM_DIG_MAX_AP_HP;
-	}
-	else
-	{
-		if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
-		{
-#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-#ifdef DFS
-			if (!priv->pmib->dot11DFSEntry.disable_DFS &&
-				(OPMODE & WIFI_AP_STATE) &&
-				(((pDM_Odm->ControlChannel >= 52) &&
-				(pDM_Odm->ControlChannel <= 64)) ||
-				((pDM_Odm->ControlChannel >= 100) &&
-				(pDM_Odm->ControlChannel <= 140))))
-				dm_dig_max = 0x24;
-			else
-#endif
-			if (priv->pmib->dot11RFEntry.tx2path) {
-				if (*(pDM_Odm->pWirelessMode) == ODM_WM_B)//(priv->pmib->dot11BssType.net_work_type == WIRELESS_11B)
-					dm_dig_max = 0x2A;
-				else
-					dm_dig_max = 0x32;
-			}
-			else
-#endif				
-			dm_dig_max = DM_DIG_MAX_AP;
-			dm_dig_min = DM_DIG_MIN_AP;
-			DIG_MaxOfMin = dm_dig_max;
-		}
-		else
-		{
-			if((pDM_Odm->SupportICType >= ODM_RTL8188E) && (pDM_Odm->SupportPlatform & (ODM_WIN|ODM_CE)))
-				dm_dig_max = 0x5A;
-			else
-				dm_dig_max = DM_DIG_MAX_NIC;
-			
-			if(pDM_Odm->SupportICType != ODM_RTL8821)
-				dm_dig_min = DM_DIG_MIN_NIC;
-			else
-				dm_dig_min = 0x1C;
-
-			DIG_MaxOfMin = DM_DIG_MAX_AP;
-		}
-	}
-
-	if(0 < *pDM_Odm->pu1ForcedIgiLb)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): force IGI lb to: %u\n", *pDM_Odm->pu1ForcedIgiLb));
-		dm_dig_min = *pDM_Odm->pu1ForcedIgiLb;
-		dm_dig_max = (dm_dig_min <= dm_dig_max) ? (dm_dig_max) : (dm_dig_min + 1);
-	}
-		
-	if(pDM_Odm->bLinked)
-	{
-		if(pDM_Odm->SupportICType&(ODM_RTL8723A/*|ODM_RTL8821*/))
-		{
-			//2 Upper Bound
-			if(( pDM_Odm->RSSI_Min + 10) > DM_DIG_MAX_NIC )
-				pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;
-			else if(( pDM_Odm->RSSI_Min + 10) < DM_DIG_MIN_NIC )
-				pDM_DigTable->rx_gain_range_max = DM_DIG_MIN_NIC;
-			else
-				pDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + 10;
-
-			//BT is Concurrent
-
-			if(pDM_Odm->bBtLimitedDig)
-			{
-				if(pDM_Odm->RSSI_Min>10)
-				{
-					if((pDM_Odm->RSSI_Min - 10) > DM_DIG_MAX_NIC)
-						DIG_Dynamic_MIN = DM_DIG_MAX_NIC;
-					else if((pDM_Odm->RSSI_Min - 10) < DM_DIG_MIN_NIC)
-						DIG_Dynamic_MIN = DM_DIG_MIN_NIC;
-					else
-						DIG_Dynamic_MIN = pDM_Odm->RSSI_Min - 10;
-				}
-				else
-					DIG_Dynamic_MIN=DM_DIG_MIN_NIC;
-			}
-			else
-			{
-				if((pDM_Odm->RSSI_Min + 20) > dm_dig_max )
-					pDM_DigTable->rx_gain_range_max = dm_dig_max;
-				else if((pDM_Odm->RSSI_Min + 20) < dm_dig_min )
-					pDM_DigTable->rx_gain_range_max = dm_dig_min;
-				else
-					pDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + 20;
-				
-			}
-		}
-		else
-		{
-			if((pDM_Odm->SupportICType & (ODM_RTL8192E|ODM_RTL8723B|ODM_RTL8812|ODM_RTL8821)) && (pDM_Odm->bBtLimitedDig==1)){				
-				//2 Modify DIG upper bound for 92E, 8723B, 8821 & 8812 BT
-				if((pDM_Odm->RSSI_Min + 10) > dm_dig_max )
-					pDM_DigTable->rx_gain_range_max = dm_dig_max;
-				else if((pDM_Odm->RSSI_Min + 10) < dm_dig_min )
-					pDM_DigTable->rx_gain_range_max = dm_dig_min;
-				else
-					pDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + 10;
-			}
-			else{
-		
-			//2 Modify DIG upper bound
-			//2013.03.19 Luke: Modified upper bound for Netgear rental house test
-			if(pDM_Odm->SupportICType != ODM_RTL8821 && pDM_Odm->SupportICType != ODM_RTL8192E)
-				offset = 20;
-			else
-				offset = 10;
-			
-			if((pDM_Odm->RSSI_Min + offset) > dm_dig_max )
-				pDM_DigTable->rx_gain_range_max = dm_dig_max;
-				else if((pDM_Odm->RSSI_Min + offset) < dm_dig_min )
-					pDM_DigTable->rx_gain_range_max = dm_dig_min;
-			else
-				pDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + offset;
-			
-			}
-
-			//2 Modify DIG lower bound
-		/*
-			if((pFalseAlmCnt->Cnt_all > 500)&&(DIG_Dynamic_MIN < 0x25))
-				DIG_Dynamic_MIN++;
-			else if(((pFalseAlmCnt->Cnt_all < 500)||(pDM_Odm->RSSI_Min < 8))&&(DIG_Dynamic_MIN > dm_dig_min))
-				DIG_Dynamic_MIN--;
-		*/
-			if(pDM_Odm->bOneEntryOnly)
-			{	
-				if(pDM_Odm->SupportICType != ODM_RTL8723B)
-					offset = 0;
-				else
-					offset = 12;
-				
-				if(pDM_Odm->RSSI_Min - offset < dm_dig_min)
-					DIG_Dynamic_MIN = dm_dig_min;
-				else if (pDM_Odm->RSSI_Min - offset > DIG_MaxOfMin)
-					DIG_Dynamic_MIN = DIG_MaxOfMin;
-				else
-					DIG_Dynamic_MIN = pDM_Odm->RSSI_Min - offset;
-
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() : bOneEntryOnly=TRUE,  DIG_Dynamic_MIN=0x%x\n",DIG_Dynamic_MIN));
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() : pDM_Odm->RSSI_Min=%d",pDM_Odm->RSSI_Min));
-			}
-			//1 Lower Bound for 88E AntDiv
-#if (defined(CONFIG_HW_ANTENNA_DIVERSITY))
-			else if( (pDM_Odm->SupportICType & ODM_ANTDIV_SUPPORT) &&(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV) )
-			//else if((pDM_Odm->SupportICType == ODM_RTL8188E)&&(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
-			{
-				if((pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV)||(pDM_Odm->AntDivType == CGCS_RX_HW_ANTDIV) ||pDM_Odm->AntDivType == S0S1_SW_ANTDIV)
-				{
-					DIG_Dynamic_MIN = (u1Byte) pDM_DigTable->AntDiv_RSSI_max;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_DIG(): pDM_DigTable->AntDiv_RSSI_max=%d \n",pDM_DigTable->AntDiv_RSSI_max));
-				}
-			}
-#endif
-			else
-			{
-				DIG_Dynamic_MIN=dm_dig_min;
-			}
-		}
-	}
-	else
-	{
-		pDM_DigTable->rx_gain_range_max = dm_dig_max;
-		DIG_Dynamic_MIN = dm_dig_min;
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() : No Link\n"));
-	}
-	
-	//1 Modify DIG lower bound, deal with abnorally large false alarm
-	if(pFalseAlmCnt->Cnt_all > 10000)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("dm_DIG(): Abnornally false alarm case. \n"));
-
-		if(pDM_DigTable->LargeFAHit != 3)
-		        pDM_DigTable->LargeFAHit++;
-		if(pDM_DigTable->ForbiddenIGI < CurrentIGI)//if(pDM_DigTable->ForbiddenIGI < pDM_DigTable->CurIGValue)
-		{
-			pDM_DigTable->ForbiddenIGI = (u1Byte)CurrentIGI;//pDM_DigTable->ForbiddenIGI = pDM_DigTable->CurIGValue;
-			pDM_DigTable->LargeFAHit = 1;
-		}
-
-		if(pDM_DigTable->LargeFAHit >= 3)
-		{
-			if((pDM_DigTable->ForbiddenIGI+1) >pDM_DigTable->rx_gain_range_max)
-				pDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
-			else
-				pDM_DigTable->rx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 1);
-			pDM_DigTable->Recover_cnt = 3600; //3600=2hr
-		}
-
-	}
-	else
-	{
-		//Recovery mechanism for IGI lower bound
-		if(pDM_DigTable->Recover_cnt != 0)
-			pDM_DigTable->Recover_cnt --;
-		else
-		{
-			if(pDM_DigTable->LargeFAHit < 3)
-			{
-				if((pDM_DigTable->ForbiddenIGI -1) < DIG_Dynamic_MIN) //DM_DIG_MIN)
-				{
-					pDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN; //DM_DIG_MIN;
-					pDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN; //DM_DIG_MIN;
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: At Lower Bound\n"));
-				}
-				else
-				{
-					pDM_DigTable->ForbiddenIGI --;
-					pDM_DigTable->rx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 1);
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: Approach Lower Bound\n"));
-				}
-			}
-			else
-			{
-				pDM_DigTable->LargeFAHit = 0;
-			}
-		}
-	}
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): pDM_DigTable->LargeFAHit=%d\n",pDM_DigTable->LargeFAHit));
-
-	#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[0])) //STA mode is linked to AP
-		pDM_Odm->bsta_state = _TRUE;
-	#endif	
-	
-	if((pDM_Odm->SupportPlatform&(ODM_WIN|ODM_CE))&&(pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 2) && (pDM_Odm->bsta_state) )
-	{		
-			pDM_DigTable->rx_gain_range_min = dm_dig_min;
-	}
-	
-	if(pDM_DigTable->rx_gain_range_min > pDM_DigTable->rx_gain_range_max)
-		pDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
-
-	//1 Adjust initial gain by false alarm
-	if(pDM_Odm->bLinked)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG AfterLink\n"));
-		if(FirstConnect)
-		{
-			if(pDM_Odm->RSSI_Min <= DIG_MaxOfMin)
-				CurrentIGI = pDM_Odm->RSSI_Min;
-			else
-				CurrentIGI = DIG_MaxOfMin;
-			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("DIG: First Connect\n"));
-
-			ODM_ConfigBBWithHeaderFile(pDM_Odm, CONFIG_BB_AGC_TAB_DIFF);		
-		}
-		else
-		{
-			if(pDM_Odm->SupportICType == ODM_RTL8192D)
-			{
-				if(pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH2_92D)
-					CurrentIGI = CurrentIGI + 4;//pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+2;
-				else if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1_92D)
-					CurrentIGI = CurrentIGI + 2; //pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+1;
-				else if(pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0_92D)
-					CurrentIGI = CurrentIGI - 2;//pDM_DigTable->CurIGValue =pDM_DigTable->PreIGValue-1;	
-			}
-			else
-			{
-				//FA for Combo IC--NeilChen--2012--09--28 
-				if(pDM_Odm->SupportICType == ODM_RTL8723A)
-				{
-	     				//WLAN and BT ConCurrent
-					if(pDM_Odm->bBtLimitedDig)
-					{
-						if(pFalseAlmCnt->Cnt_all > 0x300)
-							CurrentIGI = CurrentIGI + 4;
-						else if (pFalseAlmCnt->Cnt_all > 0x250)
-							CurrentIGI = CurrentIGI + 2;
-						else if(pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0)
-							CurrentIGI = CurrentIGI -2;
-					}
-					else //Not Concurrent
-					{
-						if(pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH2)
-							CurrentIGI = CurrentIGI + 4;//pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+2;
-						else if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1)
-							CurrentIGI = CurrentIGI + 2;//pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+1;
-						else if(pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0)
-							CurrentIGI = CurrentIGI - 2;//pDM_DigTable->CurIGValue =pDM_DigTable->PreIGValue-1;	
-					}
-				}
-				else
-				{
-					if(pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH2)
-						CurrentIGI = CurrentIGI + 4;//pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+2;
-					else if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1)
-						CurrentIGI = CurrentIGI + 2;//pDM_DigTable->CurIGValue = pDM_DigTable->PreIGValue+1;
-					else if(pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0)
-						CurrentIGI = CurrentIGI - 2;//pDM_DigTable->CurIGValue =pDM_DigTable->PreIGValue-1;	
-
-					#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-					if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[0])) //STA mode is linked to AP
-						pDM_Odm->bsta_state = _TRUE;
-					#endif
-
-					if((pDM_Odm->SupportPlatform&(ODM_WIN|ODM_CE))&&(pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 2)
-						&&(pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH1) && (pDM_Odm->bsta_state))
-					{						
-						CurrentIGI = pDM_DigTable->rx_gain_range_min;
-						ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Beacon is less than 10 and FA is less than 768, IGI GOES TO 0x1E!!!!!!!!!!!!\n"));
-					}
-					/*{
-						u2Byte value16;
-						value16 = (u2Byte) ODM_GetBBReg(pDM_Odm, 0x664, bMaskLWord);
-						ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): NumQryBeaconPkt = %d, OFDM_OK_Cnt = %d\n", 
-							pDM_Odm->PhyDbgInfo.NumQryBeaconPkt, value16));
-					}*/
-				}
-			}
-		}
-	}	
-	else
-	{
-		//CurrentIGI = pDM_DigTable->rx_gain_range_min;//pDM_DigTable->CurIGValue = pDM_DigTable->rx_gain_range_min
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG BeforeLink\n"));
-		if(FirstDisConnect)
-		{
-				CurrentIGI = pDM_DigTable->rx_gain_range_min;
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): First DisConnect \n"));
-		}
-		else
-		{
-			//2012.03.30 LukeLee: enable DIG before link but with very high thresholds
-	             if(pFalseAlmCnt->Cnt_all > 10000)
-				CurrentIGI = CurrentIGI + 4;
-			else if (pFalseAlmCnt->Cnt_all > 8000)
-				CurrentIGI = CurrentIGI + 2;
-			else if(pFalseAlmCnt->Cnt_all < 500)
-				CurrentIGI = CurrentIGI - 2;
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): England DIG \n"));
-		}
-	}
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG End Adjust IGI\n"));
-	//1 Check initial gain by upper/lower bound
-
-	if(CurrentIGI > pDM_DigTable->rx_gain_range_max)
-		CurrentIGI = pDM_DigTable->rx_gain_range_max;
-	if(CurrentIGI < pDM_DigTable->rx_gain_range_min)
-		CurrentIGI = pDM_DigTable->rx_gain_range_min;
-
-	if(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY)
-	{
-		if(CurrentIGI > Adap_IGI_Upper)
-			CurrentIGI = Adap_IGI_Upper;
-
-		if(pDM_Odm->IGI_LowerBound != 0)
-		{
-			if(CurrentIGI < pDM_Odm->IGI_LowerBound)
-				CurrentIGI = pDM_Odm->IGI_LowerBound;
-		}
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): pDM_Odm->IGI_LowerBound = %d\n", pDM_Odm->IGI_LowerBound));
-	}
-	
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): rx_gain_range_max=0x%x, rx_gain_range_min=0x%x\n", 
-		pDM_DigTable->rx_gain_range_max, pDM_DigTable->rx_gain_range_min));
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): TotalFA=%d\n", pFalseAlmCnt->Cnt_all));
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue=0x%x\n", CurrentIGI));
-
-	//2 High power RSSI threshold
-#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)	
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
-	//PMGNT_INFO			pMgntInfo	= &(pAdapter->MgntInfo);	
-	// for LC issue to dymanic modify DIG lower bound----------LC Mocca Issue
-	u8Byte			curTxOkCnt=0, curRxOkCnt=0;
-	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
-
-	//u8Byte			OKCntAll=0;
-	//static u8Byte		TXByteCnt_A=0, TXByteCnt_B=0, RXByteCnt_A=0, RXByteCnt_B=0;
-	//u8Byte			CurByteCnt=0, PreByteCnt=0;
-	
-	curTxOkCnt = pAdapter->TxStats.NumTxBytesUnicast - lastTxOkCnt;
-	curRxOkCnt =pAdapter->RxStats.NumRxBytesUnicast - lastRxOkCnt;
-	lastTxOkCnt = pAdapter->TxStats.NumTxBytesUnicast;
-	lastRxOkCnt = pAdapter->RxStats.NumRxBytesUnicast;
-	//----------------------------------------------------------end for LC Mocca issue
-	if((pDM_Odm->SupportICType == ODM_RTL8723A)&& (pHalData->UndecoratedSmoothedPWDB > DM_DIG_HIGH_PWR_THRESHOLD))
-	{
-		// High power IGI lower bound
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): UndecoratedSmoothedPWDB(%#x)\n", pHalData->UndecoratedSmoothedPWDB));
-		if(CurrentIGI < DM_DIG_HIGH_PWR_IGI_LOWER_BOUND)
-		{
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue(%#x)\n", pDM_DigTable->CurIGValue));
-			//pDM_DigTable->CurIGValue = DM_DIG_HIGH_PWR_IGI_LOWER_BOUND;
-			CurrentIGI=DM_DIG_HIGH_PWR_IGI_LOWER_BOUND;
-		}
-	}
-	if((pDM_Odm->SupportICType & ODM_RTL8723A) && 
-			IS_WIRELESS_MODE_G(pAdapter))
-		{
-			if(pHalData->UndecoratedSmoothedPWDB > 0x28)
-			{
-				if(CurrentIGI < DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND)
-				{
-			 		//pDM_DigTable->CurIGValue = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
-					CurrentIGI = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
-				}	
-			} 
-		}	
-#if 0
-	if((pDM_Odm->SupportICType & ODM_RTL8723A)&&(pMgntInfo->CustomerID = RT_CID_LENOVO_CHINA))
-	{
-		OKCntAll = (curTxOkCnt+curRxOkCnt);
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue(%#x)\n", CurrentIGI));
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): UndecoratedSmoothedPWDB(%#x)\n", pHalData->UndecoratedSmoothedPWDB));
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): OKCntAll(%#x)\n", OKCntAll));
-		//8723AS_VAU
-		if(pDM_Odm->SupportInterface==ODM_ITRF_USB)
-		{
-			if(pHalData->UndecoratedSmoothedPWDB < 12)
-			{
-				if(CurrentIGI > DM_DIG_MIN_NIC)
-				{
-					if(OKCntAll >= 1500000) 		 // >=6Mbps
-						CurrentIGI=0x1B;
-					else if(OKCntAll >= 1000000) 	 //4Mbps
-						CurrentIGI=0x1A;
-					else if(OKCntAll >= 500000)		 //2Mbps
-						CurrentIGI=0x19;
-					else if(OKCntAll >= 250000)		//1Mbps
-						CurrentIGI=0x18;
-					else
-					{
-						CurrentIGI=0x17;		//SCAN mode
-					}
-				}
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("Modify---->CurIGValue(%#x)\n", CurrentIGI));	
-			}
-		}
-	}	
-#endif	
-}
-#endif
-		
-#if (RTL8192D_SUPPORT==1) 
-	if(pDM_Odm->SupportICType == ODM_RTL8192D)
-	{
-		//sherry  delete DualMacSmartConncurrent 20110517
-		if(*(pDM_Odm->pMacPhyMode) == ODM_DMSP)
-		{
-			ODM_Write_DIG_DMSP(pDM_Odm, (u1Byte)CurrentIGI);//ODM_Write_DIG_DMSP(pDM_Odm, pDM_DigTable->CurIGValue);
-			if(*(pDM_Odm->pbMasterOfDMSP))
-			{
-				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
-				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
-			}
-			else
-			{
-				pDM_DigTable->bMediaConnect_1 = pDM_Odm->bLinked;
-				pDM_DigTable->DIG_Dynamic_MIN_1 = DIG_Dynamic_MIN;
-			}
-		}
-		else
-		{
-			ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
-			if(*(pDM_Odm->pBandType) == ODM_BAND_5G)
-			{
-				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
-				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
-			}
-			else
-			{
-				pDM_DigTable->bMediaConnect_1 = pDM_Odm->bLinked;
-				pDM_DigTable->DIG_Dynamic_MIN_1 = DIG_Dynamic_MIN;
-			}
-		}
-	}
-	else
-#endif
-	{
-		if(pDM_Odm->bBtHsOperation)
-		{
-			if(pDM_Odm->bLinked)
-			{
-				if(pDM_DigTable->BT30_CurIGI > (CurrentIGI))
-				{
-					ODM_Write_DIG(pDM_Odm, CurrentIGI);
-					
-				}	
-				else
-				{
-					ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);
-				}
-				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
-				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
-			}
-			else
-			{
-				if(pDM_Odm->bLinkInProcess)
-				{
-					ODM_Write_DIG(pDM_Odm, 0x1c);
-				}
-				else if(pDM_Odm->bBtConnectProcess)
-				{
-					ODM_Write_DIG(pDM_Odm, 0x28);
-				}
-				else
-				{
-					ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);	
-				}
-			}
-		}	
-		else		// BT is not using
-		{
-			ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
-			pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
-			pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
-		}
-	}
-}
-
-
-BOOLEAN 
-odm_DigAbort(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-// This should be moved out of OUTSRC
-	PADAPTER		pAdapter	= pDM_Odm->Adapter;
-	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
-	
-#if OS_WIN_FROM_WIN7(OS_VERSION)
-	if(IsAPModeExist( pAdapter) && pAdapter->bInHctTest)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: Is AP mode or In HCT Test \n"));
-	    	return	TRUE;
-	}
-#endif
-
-	if(pRX_HP_Table->RXHP_flag == 1)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: In RXHP Operation \n"));
-		return	TRUE;	
-	}
-
-	return	FALSE;
-#else	// For Other team any special case for DIG?
-	return	FALSE;
-#endif
-	
-
-}
-
-//3============================================================
-//3 FASLE ALARM CHECK
-//3============================================================
-
-VOID 
-odm_FalseAlarmCounterStatistics(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	u4Byte ret_value;
-	PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pDM_Odm->FalseAlmCnt);
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
-	prtl8192cd_priv priv		= pDM_Odm->priv;
-	if( (priv->auto_channel != 0) && (priv->auto_channel != 2) )
-		return;
-#endif
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	if((pDM_Odm->SupportICType == ODM_RTL8192D) &&
-		(*(pDM_Odm->pMacPhyMode)==ODM_DMSP)&&    ////modify by Guo.Mingzhi 2011-12-29
-		(!(*(pDM_Odm->pbMasterOfDMSP))))
-	{
-		odm_FalseAlarmCounterStatistics_ForSlaveOfDMSP(pDM_Odm);
-		return;
-	}
-#endif		
-
-	if(!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT))
-		return;
-
-	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
-	{
-
-	//hold ofdm counter
-		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 1); //hold page C counter
-		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 1); //hold page D counter
-	
-		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE1_11N, bMaskDWord);
-		FalseAlmCnt->Cnt_Fast_Fsync = (ret_value&0xffff);
-		FalseAlmCnt->Cnt_SB_Search_fail = ((ret_value&0xffff0000)>>16);		
-		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE2_11N, bMaskDWord);
-		FalseAlmCnt->Cnt_OFDM_CCA = (ret_value&0xffff); 
-		FalseAlmCnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);	
-		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE3_11N, bMaskDWord);
-		FalseAlmCnt->Cnt_Rate_Illegal = (ret_value&0xffff);
-		FalseAlmCnt->Cnt_Crc8_fail = ((ret_value&0xffff0000)>>16);
-		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE4_11N, bMaskDWord);
-		FalseAlmCnt->Cnt_Mcs_fail = (ret_value&0xffff);
-
-		FalseAlmCnt->Cnt_Ofdm_fail = 	FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal +
-									FalseAlmCnt->Cnt_Crc8_fail + FalseAlmCnt->Cnt_Mcs_fail +
-									FalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail;
-
-#if (RTL8188E_SUPPORT==1)
-		if((pDM_Odm->SupportICType == ODM_RTL8188E)||(pDM_Odm->SupportICType == ODM_RTL8192E))
-		{
-				ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_SC_CNT_11N, bMaskDWord);
-			FalseAlmCnt->Cnt_BW_LSC = (ret_value&0xffff);
-			FalseAlmCnt->Cnt_BW_USC = ((ret_value&0xffff0000)>>16);
-		}
-#endif
-
-#if (RTL8192D_SUPPORT==1) 
-		if(pDM_Odm->SupportICType == ODM_RTL8192D)
-		{
-			odm_GetCCKFalseAlarm_92D(pDM_Odm);
-		}
-		else
-#endif
-		{
-			//hold cck counter
-				ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT12, 1); 
-				ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT14, 1); 
-		
-				ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_LSB_11N, bMaskByte0);
-			FalseAlmCnt->Cnt_Cck_fail = ret_value;
-				ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_MSB_11N, bMaskByte3);
-			FalseAlmCnt->Cnt_Cck_fail +=  (ret_value& 0xff)<<8;
-
-				ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_CCA_CNT_11N, bMaskDWord);
-			FalseAlmCnt->Cnt_CCK_CCA = ((ret_value&0xFF)<<8) |((ret_value&0xFF00)>>8);
-		}
-		
-		FalseAlmCnt->Cnt_all = (	FalseAlmCnt->Cnt_Fast_Fsync + 
-							FalseAlmCnt->Cnt_SB_Search_fail +
-							FalseAlmCnt->Cnt_Parity_Fail +
-							FalseAlmCnt->Cnt_Rate_Illegal +
-							FalseAlmCnt->Cnt_Crc8_fail +
-							FalseAlmCnt->Cnt_Mcs_fail +
-							FalseAlmCnt->Cnt_Cck_fail);	
-
-		FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA + FalseAlmCnt->Cnt_CCK_CCA;
-
-#if (RTL8192C_SUPPORT==1)
-		if(pDM_Odm->SupportICType == ODM_RTL8192C)
-			odm_ResetFACounter_92C(pDM_Odm);
-#endif
-
-#if (RTL8192D_SUPPORT==1)
-		if(pDM_Odm->SupportICType == ODM_RTL8192D)
-			odm_ResetFACounter_92D(pDM_Odm);
-#endif
-
-		if(pDM_Odm->SupportICType >=ODM_RTL8723A)
-		{
-			//reset false alarm counter registers
-				ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT31, 1);
-				ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT31, 0);
-				ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT27, 1);
-				ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT27, 0);
-			//update ofdm counter
-				ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 0); //update page C counter
-				ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 0); //update page D counter
-
-			//reset CCK CCA counter
-				ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT13|BIT12, 0); 
-				ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT13|BIT12, 2); 
-			//reset CCK FA counter
-				ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT15|BIT14, 0); 
-				ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT15|BIT14, 2); 
-		}
-			
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Enter odm_FalseAlarmCounterStatistics\n"));
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Fast_Fsync=%d, Cnt_SB_Search_fail=%d\n",
-			FalseAlmCnt->Cnt_Fast_Fsync, FalseAlmCnt->Cnt_SB_Search_fail));
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Parity_Fail=%d, Cnt_Rate_Illegal=%d\n",
-			FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal));
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Crc8_fail=%d, Cnt_Mcs_fail=%d\n",
-			FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail));
-	}
-	else if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
-	{
-		u4Byte CCKenable;
-		//read OFDM FA counter
-		FalseAlmCnt->Cnt_Ofdm_fail = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_11AC, bMaskLWord);
-		FalseAlmCnt->Cnt_Cck_fail = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_11AC, bMaskLWord);
-		
-		CCKenable =  ODM_GetBBReg(pDM_Odm, ODM_REG_BB_RX_PATH_11AC, BIT28);
-		if(CCKenable)//if(*pDM_Odm->pBandType == ODM_BAND_2_4G)
-			FalseAlmCnt->Cnt_all = FalseAlmCnt->Cnt_Ofdm_fail + FalseAlmCnt->Cnt_Cck_fail;
-		else
-			FalseAlmCnt->Cnt_all = FalseAlmCnt->Cnt_Ofdm_fail;
-
-		// reset OFDM FA coutner
-		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RST_11AC, BIT17, 1);
-		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RST_11AC, BIT17, 0);
-		// reset CCK FA counter
-		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11AC, BIT15, 0);
-		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11AC, BIT15, 1);
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Cck_fail=%d\n",	FalseAlmCnt->Cnt_Cck_fail));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Ofdm_fail=%d\n",	FalseAlmCnt->Cnt_Ofdm_fail));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Total False Alarm=%d\n",	FalseAlmCnt->Cnt_all));
-}
-
-//3============================================================
-//3 CCK Packet Detect Threshold
-//3============================================================
-
-VOID 
-odm_CCKPacketDetectionThresh(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-
-	u1Byte	CurCCK_CCAThres;
-	PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pDM_Odm->FalseAlmCnt);
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-//modify by Guo.Mingzhi 2011-12-29
-	if (pDM_Odm->bDualMacSmartConcurrent == TRUE)
-//	if (pDM_Odm->bDualMacSmartConcurrent == FALSE)
-		return;
-
-	if(pDM_Odm->bBtHsOperation)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_CCKPacketDetectionThresh() write 0xcd for BT HS mode!!\n"));
-		ODM_Write_CCK_CCA_Thres(pDM_Odm, 0xcd);
-		return;
-	}
-
-#endif
-
-	if(!(pDM_Odm->SupportAbility & (ODM_BB_CCK_PD|ODM_BB_FA_CNT)))
-		return;
-
-	if(pDM_Odm->ExtLNA)
-		return;
-
-	if(pDM_Odm->bLinked)
-	{
-		if(pDM_Odm->RSSI_Min > 25)
-			CurCCK_CCAThres = 0xcd;
-		else if((pDM_Odm->RSSI_Min <= 25) && (pDM_Odm->RSSI_Min > 10))
-			CurCCK_CCAThres = 0x83;
-		else
-		{
-			if(FalseAlmCnt->Cnt_Cck_fail > 1000)
-				CurCCK_CCAThres = 0x83;
-			else
-				CurCCK_CCAThres = 0x40;
-		}
-	}
-	else
-	{
-		if(FalseAlmCnt->Cnt_Cck_fail > 1000)
-			CurCCK_CCAThres = 0x83;
-		else
-			CurCCK_CCAThres = 0x40;
-	}
-	
-#if (RTL8192D_SUPPORT==1) 
-	if((pDM_Odm->SupportICType == ODM_RTL8192D)&&(*pDM_Odm->pBandType == ODM_BAND_2_4G))
-		ODM_Write_CCK_CCA_Thres_92D(pDM_Odm, CurCCK_CCAThres);
-	else
-#endif
-		ODM_Write_CCK_CCA_Thres(pDM_Odm, CurCCK_CCAThres);
-}
-
-VOID
-ODM_Write_CCK_CCA_Thres(
-	IN	PDM_ODM_T		pDM_Odm,
-	IN	u1Byte			CurCCK_CCAThres
-	)
-{
-	pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
-
-	if(pDM_DigTable->CurCCK_CCAThres!=CurCCK_CCAThres)		//modify by Guo.Mingzhi 2012-01-03
-	{
-		ODM_Write1Byte(pDM_Odm, ODM_REG(CCK_CCA,pDM_Odm), CurCCK_CCAThres);
-	}
-	pDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;
-	pDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;
-	
-}
-
-//3============================================================
-//3 BB Power Save
-//3============================================================
-VOID 
-odm_DynamicBBPowerSavingInit(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
-
-	pDM_PSTable->PreCCAState = CCA_MAX;
-	pDM_PSTable->CurCCAState = CCA_MAX;
-	pDM_PSTable->PreRFState = RF_MAX;
-	pDM_PSTable->CurRFState = RF_MAX;
-	pDM_PSTable->Rssi_val_min = 0;
-	pDM_PSTable->initialize = 0;
-}
-
-
-VOID
-odm_DynamicBBPowerSaving(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{	
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-
-	if (pDM_Odm->SupportICType != ODM_RTL8723A)
-		return;
-	if(!(pDM_Odm->SupportAbility & ODM_BB_PWR_SAVE))
-		return;
-	if(!(pDM_Odm->SupportPlatform & (ODM_WIN|ODM_CE)))
-		return;
-	
-	//1 2.Power Saving for 92C
-	if((pDM_Odm->SupportICType == ODM_RTL8192C) &&(pDM_Odm->RFType == ODM_2T2R))
-	{
-		odm_1R_CCA(pDM_Odm);
-	}
-	
-	// 20100628 Joseph: Turn off BB power save for 88CE because it makesthroughput unstable.
-	// 20100831 Joseph: Turn ON BB power save again after modifying AGC delay from 900ns ot 600ns.
-	//1 3.Power Saving for 88C
-	else
-	{
-		ODM_RF_Saving(pDM_Odm, FALSE);
-	}
-#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	
-}
-
-VOID
-odm_1R_CCA(
-	IN 	PDM_ODM_T	pDM_Odm
-	)
-{
-	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
-
-	if(pDM_Odm->RSSI_Min!= 0xFF)
-	{
-		 
-		if(pDM_PSTable->PreCCAState == CCA_2R)
-		{
-			if(pDM_Odm->RSSI_Min >= 35)
-				pDM_PSTable->CurCCAState = CCA_1R;
-			else
-				pDM_PSTable->CurCCAState = CCA_2R;
-			
-		}
-		else{
-			if(pDM_Odm->RSSI_Min <= 30)
-				pDM_PSTable->CurCCAState = CCA_2R;
-			else
-				pDM_PSTable->CurCCAState = CCA_1R;
-		}
-	}
-	else{
-		pDM_PSTable->CurCCAState=CCA_MAX;
-	}
-	
-	if(pDM_PSTable->PreCCAState != pDM_PSTable->CurCCAState)
-	{
-		if(pDM_PSTable->CurCCAState == CCA_1R)
-		{
-			if(  pDM_Odm->RFType ==ODM_2T2R )
-			{
-				ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x13);
-				//PHY_SetBBReg(pAdapter, 0xe70, bMaskByte3, 0x20);
-			}
-			else
-			{
-				ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x23);
-				//PHY_SetBBReg(pAdapter, 0xe70, 0x7fc00000, 0x10c); // Set RegE70[30:22] = 9b'100001100
-			}
-		}
-		else
-		{
-			ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x33);
-			//PHY_SetBBReg(pAdapter,0xe70, bMaskByte3, 0x63);
-		}
-		pDM_PSTable->PreCCAState = pDM_PSTable->CurCCAState;
-	}
-	//ODM_RT_TRACE(pDM_Odm,	COMP_BB_POWERSAVING, DBG_LOUD, ("CCAStage = %s\n",(pDM_PSTable->CurCCAState==0)?"1RCCA":"2RCCA"));
-}
-
-void
-ODM_RF_Saving(
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte		bForceInNormal 
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE != ODM_AP)
-	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
-	u1Byte	Rssi_Up_bound = 30 ;
-	u1Byte	Rssi_Low_bound = 25;
-	#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	if(pDM_Odm->PatchID == 40 ) //RT_CID_819x_FUNAI_TV
-	{
-		Rssi_Up_bound = 50 ;
-		Rssi_Low_bound = 45;
-	}
-	#endif
-	if(pDM_PSTable->initialize == 0){
-		
-		pDM_PSTable->Reg874 = (ODM_GetBBReg(pDM_Odm, 0x874, bMaskDWord)&0x1CC000)>>14;
-		pDM_PSTable->RegC70 = (ODM_GetBBReg(pDM_Odm, 0xc70, bMaskDWord)&BIT3)>>3;
-		pDM_PSTable->Reg85C = (ODM_GetBBReg(pDM_Odm, 0x85c, bMaskDWord)&0xFF000000)>>24;
-		pDM_PSTable->RegA74 = (ODM_GetBBReg(pDM_Odm, 0xa74, bMaskDWord)&0xF000)>>12;
-		//Reg818 = PHY_QueryBBReg(pAdapter, 0x818, bMaskDWord);
-		pDM_PSTable->initialize = 1;
-	}
-
-	if(!bForceInNormal)
-	{
-		if(pDM_Odm->RSSI_Min != 0xFF)
-		{			 
-			if(pDM_PSTable->PreRFState == RF_Normal)
-			{
-				if(pDM_Odm->RSSI_Min >= Rssi_Up_bound)
-					pDM_PSTable->CurRFState = RF_Save;
-				else
-					pDM_PSTable->CurRFState = RF_Normal;
-			}
-			else{
-				if(pDM_Odm->RSSI_Min <= Rssi_Low_bound)
-					pDM_PSTable->CurRFState = RF_Normal;
-				else
-					pDM_PSTable->CurRFState = RF_Save;
-			}
-		}
-		else
-			pDM_PSTable->CurRFState=RF_MAX;
-	}
-	else
-	{
-		pDM_PSTable->CurRFState = RF_Normal;
-	}
-	
-	if(pDM_PSTable->PreRFState != pDM_PSTable->CurRFState)
-	{
-		if(pDM_PSTable->CurRFState == RF_Save)
-		{
-			// <tynli_note> 8723 RSSI report will be wrong. Set 0x874[5]=1 when enter BB power saving mode.
-			// Suggested by SD3 Yu-Nan. 2011.01.20.
-			if(pDM_Odm->SupportICType == ODM_RTL8723A)
-			{
-				ODM_SetBBReg(pDM_Odm, 0x874  , BIT5, 0x1); //Reg874[5]=1b'1
-			}
-			ODM_SetBBReg(pDM_Odm, 0x874  , 0x1C0000, 0x2); //Reg874[20:18]=3'b010
-			ODM_SetBBReg(pDM_Odm, 0xc70, BIT3, 0); //RegC70[3]=1'b0
-			ODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, 0x63); //Reg85C[31:24]=0x63
-			ODM_SetBBReg(pDM_Odm, 0x874, 0xC000, 0x2); //Reg874[15:14]=2'b10
-			ODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, 0x3); //RegA75[7:4]=0x3
-			ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0); //Reg818[28]=1'b0
-			ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x1); //Reg818[28]=1'b1
-			//ODM_RT_TRACE(pDM_Odm,	COMP_BB_POWERSAVING, DBG_LOUD, (" RF_Save"));
-		}
-		else
-		{
-			ODM_SetBBReg(pDM_Odm, 0x874  , 0x1CC000, pDM_PSTable->Reg874); 
-			ODM_SetBBReg(pDM_Odm, 0xc70, BIT3, pDM_PSTable->RegC70); 
-			ODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, pDM_PSTable->Reg85C);
-			ODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, pDM_PSTable->RegA74); 
-			ODM_SetBBReg(pDM_Odm,0x818, BIT28, 0x0);  
-
-			if(pDM_Odm->SupportICType == ODM_RTL8723A)
-			{
-				ODM_SetBBReg(pDM_Odm,0x874  , BIT5, 0x0); //Reg874[5]=1b'0
-			}
-			//ODM_RT_TRACE(pDM_Odm,	COMP_BB_POWERSAVING, DBG_LOUD, (" RF_Normal"));
-		}
-		pDM_PSTable->PreRFState =pDM_PSTable->CurRFState;
-	}
-#endif	
-}
-
-
-//3============================================================
-//3 RATR MASK
-//3============================================================
-//3============================================================
-//3 Rate Adaptive
-//3============================================================
-
-VOID
-odm_RateAdaptiveMaskInit(
-	IN 	PDM_ODM_T	pDM_Odm
-	)
-{
-	PODM_RATE_ADAPTIVE	pOdmRA = &pDM_Odm->RateAdaptive;
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PMGNT_INFO		pMgntInfo = &pDM_Odm->Adapter->MgntInfo;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
-
-	pMgntInfo->Ratr_State = DM_RATR_STA_INIT;
-
-	if (pMgntInfo->DM_Type == DM_Type_ByDriver)
-		pHalData->bUseRAMask = TRUE;
-	else
-		pHalData->bUseRAMask = FALSE;	
-
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	pOdmRA->Type = DM_Type_ByDriver;
-	if (pOdmRA->Type == DM_Type_ByDriver)
-		pDM_Odm->bUseRAMask = _TRUE;
-	else
-		pDM_Odm->bUseRAMask = _FALSE;	
-#endif
-
-	pOdmRA->RATRState = DM_RATR_STA_INIT;
-	pOdmRA->LdpcThres = 35;
-	pOdmRA->bUseLdpc = FALSE;
-	pOdmRA->HighRSSIThresh = 50;
-	pOdmRA->LowRSSIThresh = 20;
-}
-
-#if (DM_ODM_SUPPORT_TYPE & ODM_WIN) 
-VOID
-ODM_RateAdaptiveStateApInit(	
-	IN	PADAPTER		Adapter	,
-	IN	PRT_WLAN_STA  	pEntry
-	)
-{
-	pEntry->Ratr_State = DM_RATR_STA_INIT;
-}
-#endif
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-u4Byte ODM_Get_Rate_Bitmap(
-	IN	PDM_ODM_T	pDM_Odm,	
-	IN	u4Byte		macid,
-	IN	u4Byte 		ra_mask,	
-	IN	u1Byte 		rssi_level)
-{
-	PSTA_INFO_T   	pEntry;
-	u4Byte 	rate_bitmap = 0;
-	u1Byte 	WirelessMode;
-	//u1Byte 	WirelessMode =*(pDM_Odm->pWirelessMode);
-	
-	
-	pEntry = pDM_Odm->pODM_StaInfo[macid];
-	if(!IS_STA_VALID(pEntry))
-		return ra_mask;
-
-	WirelessMode = pEntry->wireless_mode;
-	
-	switch(WirelessMode)
-	{
-		case ODM_WM_B:
-			if(ra_mask & 0x0000000c)		//11M or 5.5M enable				
-				rate_bitmap = 0x0000000d;
-			else
-				rate_bitmap = 0x0000000f;
-			break;
-			
-		case (ODM_WM_G):
-		case (ODM_WM_A):
-			if(rssi_level == DM_RATR_STA_HIGH)
-				rate_bitmap = 0x00000f00;
-			else
-				rate_bitmap = 0x00000ff0;
-			break;
-			
-		case (ODM_WM_B|ODM_WM_G):
-			if(rssi_level == DM_RATR_STA_HIGH)
-				rate_bitmap = 0x00000f00;
-			else if(rssi_level == DM_RATR_STA_MIDDLE)
-				rate_bitmap = 0x00000ff0;
-			else
-				rate_bitmap = 0x00000ff5;
-			break;		
-
-		case (ODM_WM_B|ODM_WM_G|ODM_WM_N24G)	:
-		case (ODM_WM_B|ODM_WM_N24G)	:
-		case (ODM_WM_G|ODM_WM_N24G)	:
-		case (ODM_WM_A|ODM_WM_N5G)	:
-			{					
-				if (	pDM_Odm->RFType == ODM_1T2R ||pDM_Odm->RFType == ODM_1T1R)
-				{
-					if(rssi_level == DM_RATR_STA_HIGH)
-					{
-						rate_bitmap = 0x000f0000;
-					}
-					else if(rssi_level == DM_RATR_STA_MIDDLE)
-					{
-						rate_bitmap = 0x000ff000;
-					}
-					else{
-						if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
-							rate_bitmap = 0x000ff015;
-						else
-							rate_bitmap = 0x000ff005;
-					}				
-				}
-				else
-				{
-					if(rssi_level == DM_RATR_STA_HIGH)
-					{		
-						rate_bitmap = 0x0f8f0000;
-					}
-					else if(rssi_level == DM_RATR_STA_MIDDLE)
-					{
-						rate_bitmap = 0x0f8ff000;
-					}
-					else
-					{
-						if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
-							rate_bitmap = 0x0f8ff015;
-						else
-							rate_bitmap = 0x0f8ff005;
-					}					
-				}
-			}
-			break;
-
-		case (ODM_WM_AC|ODM_WM_G):
-			if(rssi_level == 1)
-				rate_bitmap = 0xfc3f0000;
-			else if(rssi_level == 2)
-				rate_bitmap = 0xfffff000;
-			else
-				rate_bitmap = 0xffffffff;
-			break;
-
-		case (ODM_WM_AC|ODM_WM_A):
-
-			if (pDM_Odm->RFType == RF_1T1R)
-			{
-				if(rssi_level == 1)				// add by Gary for ac-series
-					rate_bitmap = 0x003f8000;
-				else if (rssi_level == 2)
-					rate_bitmap = 0x003ff000;
-				else
-					rate_bitmap = 0x003ff010;
-			}
-			else
-			{
-				if(rssi_level == 1)				// add by Gary for ac-series
-					rate_bitmap = 0xfe3f8000;       // VHT 2SS MCS3~9
-				else if (rssi_level == 2)
-					rate_bitmap = 0xfffff000;       // VHT 2SS MCS0~9
-				else
-					rate_bitmap = 0xfffff010;       // All
-			}
-			break;
-			
-		default:
-			if(pDM_Odm->RFType == RF_1T2R)
-				rate_bitmap = 0x000fffff;
-			else
-				rate_bitmap = 0x0fffffff;
-			break;	
-
-	}
-
-	//printk("%s ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n",__FUNCTION__,rssi_level,WirelessMode,rate_bitmap);
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, (" ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n",rssi_level,WirelessMode,rate_bitmap));
-
-	return (ra_mask&rate_bitmap);
-	
-}	
-#endif
-
-
-VOID
-odm_RefreshBasicRateMask(
-	IN		PDM_ODM_T		pDM_Odm	
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER		Adapter	 =  pDM_Odm->Adapter;
-	static u1Byte		Stage = 0;
-	u1Byte			CurStage = 0;
-	OCTET_STRING 	osRateSet;
-	PMGNT_INFO		pMgntInfo = GetDefaultMgntInfo(Adapter);
-	u1Byte 			RateSet[5] = {MGN_1M, MGN_2M, MGN_5_5M, MGN_11M, MGN_6M};
-
-	if(pDM_Odm->SupportICType != ODM_RTL8812 && pDM_Odm->SupportICType != ODM_RTL8821 )
-		return;
-
-	if(pDM_Odm->bLinked == FALSE)	// unlink Default port information
-		CurStage = 0;	
-	else if(pDM_Odm->RSSI_Min < 40)	// link RSSI  < 40%
-		CurStage = 1;
-	else if(pDM_Odm->RSSI_Min > 45)	// link RSSI > 45%
-		CurStage = 3;	
-	else
-		CurStage = 2;					// link  25% <= RSSI <= 30%
-
-	if(CurStage != Stage)
-	{
-		if(CurStage == 1)
-		{
-			FillOctetString(osRateSet, RateSet, 5);
-			FilterSupportRate(pMgntInfo->mBrates, &osRateSet, FALSE);
-			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_BASIC_RATE, (pu1Byte)&osRateSet);
-		}
-		else if(CurStage == 3 && (Stage == 1 || Stage == 2))
-		{
-			Adapter->HalFunc.SetHwRegHandler( Adapter, HW_VAR_BASIC_RATE, (pu1Byte)(&pMgntInfo->mBrates) );
-		}
-	}
-	
-	Stage = CurStage;
-#endif
-}
-
-/*-----------------------------------------------------------------------------
- * Function:	odm_RefreshRateAdaptiveMask()
- *
- * Overview:	Update rate table mask according to rssi
- *
- * Input:		NONE
- *
- * Output:		NONE
- *
- * Return:		NONE
- *
- * Revised History:
- *	When		Who		Remark
- *	05/27/2009	hpfan	Create Version 0.  
- *
- *---------------------------------------------------------------------------*/
-VOID
-odm_RefreshRateAdaptiveMask(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("odm_RefreshRateAdaptiveMask()---------->\n"));	
-	if (!(pDM_Odm->SupportAbility & ODM_BB_RA_MASK))
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("odm_RefreshRateAdaptiveMask(): Return cos not supported\n"));
-		return;	
-	}
-	//
-	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
-	// at the same time. In the stage2/3, we need to prive universal interface and merge all
-	// HW dynamic mechanism.
-	//
-	switch	(pDM_Odm->SupportPlatform)
-	{
-		case	ODM_WIN:
-			odm_RefreshRateAdaptiveMaskMP(pDM_Odm);
-			break;
-
-		case	ODM_CE:
-			odm_RefreshRateAdaptiveMaskCE(pDM_Odm);
-			break;
-
-		case	ODM_AP:
-		case	ODM_ADSL:
-			odm_RefreshRateAdaptiveMaskAPADSL(pDM_Odm);
-			break;
-	}
-	
-}
-
-VOID
-odm_RefreshRateAdaptiveMaskMP(
-	IN		PDM_ODM_T		pDM_Odm	
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER				pAdapter	 =  pDM_Odm->Adapter;
-	PADAPTER 				pTargetAdapter = NULL;
-	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(pAdapter);
-	PMGNT_INFO				pMgntInfo = GetDefaultMgntInfo(pAdapter);
-	PODM_RATE_ADAPTIVE		pRA = &pDM_Odm->RateAdaptive;
-
-	if(pAdapter->bDriverStopped)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("<---- odm_RefreshRateAdaptiveMask(): driver is going to unload\n"));
-		return;
-	}
-
-	if(!pHalData->bUseRAMask)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("<---- odm_RefreshRateAdaptiveMask(): driver does not control rate adaptive mask\n"));
-		return;
-	}
-
-	// if default port is connected, update RA table for default port (infrastructure mode only)
-	if(pMgntInfo->mAssoc && (!ACTING_AS_AP(pAdapter)))
-	{
-	
-		if(pHalData->UndecoratedSmoothedPWDB < pRA->LdpcThres)
-		{
-			pRA->bUseLdpc = TRUE;
-			pRA->bLowerRtsRate = TRUE;
-			if((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
-				MgntSet_TX_LDPC(pAdapter,0,TRUE);
-			//DbgPrint("RSSI=%d, bUseLdpc = TRUE\n", pHalData->UndecoratedSmoothedPWDB);
-		}
-		else if(pHalData->UndecoratedSmoothedPWDB > (pRA->LdpcThres-5))
-		{
-			pRA->bUseLdpc = FALSE;
-			pRA->bLowerRtsRate = FALSE;
-			if((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
-				MgntSet_TX_LDPC(pAdapter,0,FALSE);
-			//DbgPrint("RSSI=%d, bUseLdpc = FALSE\n", pHalData->UndecoratedSmoothedPWDB);
-		}
-	
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("odm_RefreshRateAdaptiveMask(): Infrasture Mode\n"));
-		if( ODM_RAStateCheck(pDM_Odm, pHalData->UndecoratedSmoothedPWDB, pMgntInfo->bSetTXPowerTrainingByOid, &pMgntInfo->Ratr_State) )
-		{
-			ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target AP addr : "), pMgntInfo->Bssid);
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pHalData->UndecoratedSmoothedPWDB, pMgntInfo->Ratr_State));
-			pAdapter->HalFunc.UpdateHalRAMaskHandler(pAdapter, pMgntInfo->mMacId, NULL, pMgntInfo->Ratr_State);
-		}
-	}
-
-	//
-	// The following part configure AP/VWifi/IBSS rate adaptive mask.
-	//
-
-	if(pMgntInfo->mIbss) 	// Target: AP/IBSS peer.
-		pTargetAdapter = GetDefaultAdapter(pAdapter);
-	else
-		pTargetAdapter = GetFirstAPAdapter(pAdapter);
-
-	// if extension port (softap) is started, updaet RA table for more than one clients associate
-	if(pTargetAdapter != NULL)
-	{
-		int	i;
-		PRT_WLAN_STA	pEntry;
-
-		for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
-		{
-			pEntry = AsocEntry_EnumStation(pTargetAdapter, i);
-			if(NULL != pEntry)
-			{
-				if(pEntry->bAssociated)
-				{
-					if(ODM_RAStateCheck(pDM_Odm, pEntry->rssi_stat.UndecoratedSmoothedPWDB, pMgntInfo->bSetTXPowerTrainingByOid, &pEntry->Ratr_State) )
-					{
-						ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target STA addr : "), pEntry->MacAddr);
-						ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pEntry->rssi_stat.UndecoratedSmoothedPWDB, pEntry->Ratr_State));
-						pAdapter->HalFunc.UpdateHalRAMaskHandler(pTargetAdapter, pEntry->AssociatedMacId, pEntry, pEntry->Ratr_State);
-					}
-				}
-			}
-		}
-	}
-
-	if(pMgntInfo->bSetTXPowerTrainingByOid)
-		pMgntInfo->bSetTXPowerTrainingByOid = FALSE;	
-#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-}
-
-
-VOID
-odm_RefreshRateAdaptiveMaskCE(
-	IN		PDM_ODM_T		pDM_Odm	
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	u1Byte	i;
-	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
-	PODM_RATE_ADAPTIVE		pRA = &pDM_Odm->RateAdaptive;
-
-	if(pAdapter->bDriverStopped)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("<---- odm_RefreshRateAdaptiveMask(): driver is going to unload\n"));
-		return;
-	}
-
-	if(!pDM_Odm->bUseRAMask)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("<---- odm_RefreshRateAdaptiveMask(): driver does not control rate adaptive mask\n"));
-		return;
-	}
-
-	//printk("==> %s \n",__FUNCTION__);
-
-	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++){
-		PSTA_INFO_T pstat = pDM_Odm->pODM_StaInfo[i];
-		if(IS_STA_VALID(pstat) ) {
-			if(IS_MCAST( pstat->hwaddr))  //if(psta->mac_id ==1)
-				 continue;
-			if(IS_MCAST( pstat->hwaddr))
-				continue;
-
-			#if((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
-			if((pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8821))
-			{
-				if(pstat->rssi_stat.UndecoratedSmoothedPWDB < pRA->LdpcThres)
-				{
-					pRA->bUseLdpc = TRUE;
-					pRA->bLowerRtsRate = TRUE;
-					if((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
-						Set_RA_LDPC_8812(pstat, TRUE);
-					//DbgPrint("RSSI=%d, bUseLdpc = TRUE\n", pHalData->UndecoratedSmoothedPWDB);
-				}
-				else if(pstat->rssi_stat.UndecoratedSmoothedPWDB > (pRA->LdpcThres-5))
-				{
-					pRA->bUseLdpc = FALSE;
-					pRA->bLowerRtsRate = FALSE;
-					if((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
-						Set_RA_LDPC_8812(pstat, FALSE);
-					//DbgPrint("RSSI=%d, bUseLdpc = FALSE\n", pHalData->UndecoratedSmoothedPWDB);
-				}
-			}
-			#endif
-
-			if( TRUE == ODM_RAStateCheck(pDM_Odm, pstat->rssi_stat.UndecoratedSmoothedPWDB, FALSE , &pstat->rssi_level) )
-			{
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level));
-				//printk("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level);
-				rtw_hal_update_ra_mask(pstat, pstat->rssi_level);
-			}
-		
-		}
-	}			
-	
-#endif
-}
-
-VOID
-odm_RefreshRateAdaptiveMaskAPADSL(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-	struct rtl8192cd_priv *priv = pDM_Odm->priv;
-	struct stat_info	*pstat;
-
-	if (!priv->pmib->dot11StationConfigEntry.autoRate) 
-		return;
-
-	if (list_empty(&priv->asoc_list))
-		return;
-
-	list_for_each_entry(pstat, &priv->asoc_list, asoc_list) {
-		if(ODM_RAStateCheck(pDM_Odm, (s4Byte)pstat->rssi, FALSE, &pstat->rssi_level) ) {
-			ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target STA addr : "), pstat->hwaddr);
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi, pstat->rssi_level));
-
-#ifdef CONFIG_RTL_88E_SUPPORT
-			if (GET_CHIP_VER(priv)==VERSION_8188E) {
-#ifdef TXREPORT
-				add_RATid(priv, pstat);
-#endif
-			} else
-#endif
-			{
-#if defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_92C_SUPPORT)			
-			add_update_RATid(priv, pstat);
-#endif
-		        }
-	        }
-	}
-#endif
-}
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID
-ODM_DynamicARFBSelect(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN 		u1Byte			rate,
-	IN  		BOOLEAN			Collision_State	
-)
-{
-
-	if(pDM_Odm->SupportICType != ODM_RTL8192E)
-		return;
-
-	if (rate >= DESC_RATEMCS8  && rate <= DESC_RATEMCS12){
-		if (Collision_State == 1){
-			if(rate == DESC_RATEMCS12){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07060501);	
-			}
-			else if(rate == DESC_RATEMCS11){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07070605);	
-			}
-			else if(rate == DESC_RATEMCS10){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08080706);	
-			}
-			else if(rate == DESC_RATEMCS9){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08080707);	
-			}
-			else{
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09090808);	
-			}
-		}
-		else{   // Collision_State == 0
-			if(rate == DESC_RATEMCS12){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x05010000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09080706);	
-			}
-			else if(rate == DESC_RATEMCS11){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x06050000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09080807);	
-			}
-			else if(rate == DESC_RATEMCS10){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x07060000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x0a090908);	
-			}
-			else if(rate == DESC_RATEMCS9){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x07070000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x0a090808);	
-			}
-			else{
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x08080000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x0b0a0909);	
-			}
-		}
-	}
-	else{  // MCS13~MCS15,  1SS, G-mode
-		if (Collision_State == 1){
-			if(rate == DESC_RATEMCS15){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x05040302);	
-			}
-			else if(rate == DESC_RATEMCS14){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x06050302);	
-			}
-			else if(rate == DESC_RATEMCS13){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07060502);	
-			}
-			else{
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x06050402);	
-			}
-		}
-		else{   // Collision_State == 0
-  			if(rate == DESC_RATEMCS15){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x03020000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07060504);	
-			}
-			else if(rate == DESC_RATEMCS14){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x03020000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08070605);	
-			}
-			else if(rate == DESC_RATEMCS13){
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x05020000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09080706);	
-			}
-			else{
-
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x04020000);
-				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08070605);	
-			}
-
-
-		}
-
-	}	
-
-}
-
-#endif
-
-// Return Value: BOOLEAN
-// - TRUE: RATRState is changed.
-BOOLEAN 
-ODM_RAStateCheck(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		s4Byte			RSSI,
-	IN		BOOLEAN			bForceUpdate,
-	OUT		pu1Byte			pRATRState
-	)
-{
-	PODM_RATE_ADAPTIVE pRA = &pDM_Odm->RateAdaptive;
-	const u1Byte GoUpGap = 5;
-	u1Byte HighRSSIThreshForRA = pRA->HighRSSIThresh;
-	u1Byte LowRSSIThreshForRA = pRA->LowRSSIThresh;
-	u1Byte RATRState;
-
-	// Threshold Adjustment: 
-	// when RSSI state trends to go up one or two levels, make sure RSSI is high enough.
-	// Here GoUpGap is added to solve the boundary's level alternation issue.
-	switch (*pRATRState)
-	{
-		case DM_RATR_STA_INIT:
-		case DM_RATR_STA_HIGH:
-			break;
-
-		case DM_RATR_STA_MIDDLE:
-			HighRSSIThreshForRA += GoUpGap;
-			break;
-
-		case DM_RATR_STA_LOW:
-			HighRSSIThreshForRA += GoUpGap;
-			LowRSSIThreshForRA += GoUpGap;
-			break;
-
-		default: 
-			ODM_RT_ASSERT(pDM_Odm, FALSE, ("wrong rssi level setting %d !", *pRATRState) );
-			break;
-	}
-
-	// Decide RATRState by RSSI.
-	if(RSSI > HighRSSIThreshForRA)
-		RATRState = DM_RATR_STA_HIGH;
-	else if(RSSI > LowRSSIThreshForRA)
-		RATRState = DM_RATR_STA_MIDDLE;
-	else
-		RATRState = DM_RATR_STA_LOW;
-	//printk("==>%s,RATRState:0x%02x ,RSSI:%d \n",__FUNCTION__,RATRState,RSSI);
-
-	if( *pRATRState!=RATRState || bForceUpdate)
-	{
-		ODM_RT_TRACE( pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI Level %d -> %d\n", *pRATRState, RATRState) );
-		*pRATRState = RATRState;
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-
-//============================================================
-
-//3============================================================
-//3 Dynamic Tx Power
-//3============================================================
-
-VOID 
-odm_DynamicTxPowerInit(
-	IN		PDM_ODM_T		pDM_Odm	
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER	Adapter = pDM_Odm->Adapter;
-	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-
-	#if DEV_BUS_TYPE==RT_USB_INTERFACE					
-	if(RT_GetInterfaceSelection(Adapter) == INTF_SEL1_USB_High_Power)
-	{
-		odm_DynamicTxPowerSavePowerIndex(pDM_Odm);
-		pMgntInfo->bDynamicTxPowerEnable = TRUE;
-	}		
-	else	
-	#else
-	//so 92c pci do not need dynamic tx power? vivi check it later
-	if(IS_HARDWARE_TYPE_8192D(Adapter))
-		pMgntInfo->bDynamicTxPowerEnable = TRUE;
-	else
-		pMgntInfo->bDynamicTxPowerEnable = FALSE;
-	#endif
-	
-
-	pHalData->LastDTPLvl = TxHighPwrLevel_Normal;
-	pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	PADAPTER	Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	pdmpriv->bDynamicTxPowerEnable = _FALSE;
-
-	#if (RTL8192C_SUPPORT==1) 
-	#ifdef CONFIG_USB_HCI
-
-	#ifdef CONFIG_INTEL_PROXIM
-	if((pHalData->BoardType == BOARD_USB_High_PA)||(Adapter->proximity.proxim_support==_TRUE))
-	#else
-	if(pHalData->BoardType == BOARD_USB_High_PA)
-	#endif
-
-	{
-		//odm_SavePowerIndex(Adapter);
-		odm_DynamicTxPowerSavePowerIndex(pDM_Odm);
-		pdmpriv->bDynamicTxPowerEnable = _TRUE;
-	}		
-	else	
-	#else
-		pdmpriv->bDynamicTxPowerEnable = _FALSE;
-	#endif
-	#endif
-	
-	pdmpriv->LastDTPLvl = TxHighPwrLevel_Normal;
-	pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;	
-	
-#endif
-	
-}
-
-VOID
-odm_DynamicTxPowerSavePowerIndex(
-	IN		PDM_ODM_T		pDM_Odm	
-	)
-{	
-	u1Byte		index;
-	u4Byte		Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
-	
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
-	PADAPTER	Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
-	for(index = 0; index< 6; index++)
-		pHalData->PowerIndex_backup[index] = PlatformEFIORead1Byte(Adapter, Power_Index_REG[index]);
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)	
-	PADAPTER	Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	for(index = 0; index< 6; index++)
-		pdmpriv->PowerIndex_backup[index] = rtw_read8(Adapter, Power_Index_REG[index]);
-#endif
-}
-
-VOID
-odm_DynamicTxPowerRestorePowerIndex(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	u1Byte			index;
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-
-#if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u4Byte			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	for(index = 0; index< 6; index++)
-		PlatformEFIOWrite1Byte(Adapter, Power_Index_REG[index], pHalData->PowerIndex_backup[index]);
-#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)	
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	for(index = 0; index< 6; index++)
-		rtw_write8(Adapter, Power_Index_REG[index], pdmpriv->PowerIndex_backup[index]);
-#endif
-#endif
-}
-
-VOID
-odm_DynamicTxPowerWritePowerIndex(
-	IN	PDM_ODM_T	pDM_Odm, 
-	IN 	u1Byte		Value)
-{
-
-	u1Byte			index;
-	u4Byte			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
-	
-	for(index = 0; index< 6; index++)
-		//PlatformEFIOWrite1Byte(Adapter, Power_Index_REG[index], Value);
-		ODM_Write1Byte(pDM_Odm, Power_Index_REG[index], Value);
-
-}
-
-
-VOID 
-odm_DynamicTxPower(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	// 
-	// For AP/ADSL use prtl8192cd_priv
-	// For CE/NIC use PADAPTER
-	//
-	//PADAPTER		pAdapter = pDM_Odm->Adapter;
-//	prtl8192cd_priv	priv		= pDM_Odm->priv;
-
-	if (!(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR))
-		return;
-
-	//
-	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
-	// at the same time. In the stage2/3, we need to prive universal interface and merge all
-	// HW dynamic mechanism.
-	//
-	switch	(pDM_Odm->SupportPlatform)
-	{
-		case	ODM_WIN:
-		case	ODM_CE:
-			odm_DynamicTxPowerNIC(pDM_Odm);
-			break;	
-		case	ODM_AP:
-			odm_DynamicTxPowerAP(pDM_Odm);
-			break;		
-
-		case	ODM_ADSL:
-			//odm_DIGAP(pDM_Odm);
-			break;	
-	}
-
-	
-}
-
-
-VOID 
-odm_DynamicTxPowerNIC(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{	
-	if (!(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR))
-		return;
-	
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-
-	if(pDM_Odm->SupportICType == ODM_RTL8192C)	
-	{
-		odm_DynamicTxPower_92C(pDM_Odm);
-	}
-	else if(pDM_Odm->SupportICType == ODM_RTL8192D)
-	{
-		odm_DynamicTxPower_92D(pDM_Odm);
-	}
-	else if (pDM_Odm->SupportICType == ODM_RTL8821)
-	{
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
-		PADAPTER		Adapter	 =  pDM_Odm->Adapter;
-		PMGNT_INFO		pMgntInfo = GetDefaultMgntInfo(Adapter);
-
-		if (pMgntInfo->RegRspPwr == 1)
-		{
-			if(pDM_Odm->RSSI_Min > 60)
-			{
-				ODM_SetMACReg(pDM_Odm, ODM_REG_RESP_TX_11AC, BIT20|BIT19|BIT18, 1); // Resp TXAGC offset = -3dB
-
-			}
-			else if(pDM_Odm->RSSI_Min < 55)
-			{
-				ODM_SetMACReg(pDM_Odm, ODM_REG_RESP_TX_11AC, BIT20|BIT19|BIT18, 0); // Resp TXAGC offset = 0dB
-			}
-		}
-#endif
-	}
-#endif	
-}
-
-VOID 
-odm_DynamicTxPowerAP(
-	IN		PDM_ODM_T		pDM_Odm
-
-	)
-{	
-#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
-	prtl8192cd_priv	priv		= pDM_Odm->priv;
-	s4Byte i;
-
-	if(!priv->pshare->rf_ft_var.tx_pwr_ctrl)
-		return;
-	
-#ifdef HIGH_POWER_EXT_PA
-	if(pDM_Odm->ExtPA)
-		tx_power_control(priv);
-#endif		
-
-	/*
-	 *	Check if station is near by to use lower tx power
-	 */
-
-	if ((priv->up_time % 3) == 0 )  {
-		for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++){
-			PSTA_INFO_T pstat = pDM_Odm->pODM_StaInfo[i];
-			if(IS_STA_VALID(pstat) ) {
-				if ((pstat->hp_level == 0) && (pstat->rssi > TX_POWER_NEAR_FIELD_THRESH_AP+4))
-					pstat->hp_level = 1;
-				else if ((pstat->hp_level == 1) && (pstat->rssi < TX_POWER_NEAR_FIELD_THRESH_AP))
-					pstat->hp_level = 0;
-			}
-		}
-	}
-
-#endif	
-}
-
-
-VOID 
-odm_DynamicTxPower_92C(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER Adapter = pDM_Odm->Adapter;
-	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	s4Byte				UndecoratedSmoothedPWDB;
-
-	// 2012/01/12 MH According to Luke's suggestion, only high power will support the feature.
-	if (pDM_Odm->ExtPA == FALSE)
-		return;
-
-	// STA not connected and AP not connected
-	if((!pMgntInfo->bMediaConnect) &&	
-		(pHalData->EntryMinUndecoratedSmoothedPWDB == 0))
-	{
-		ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
-		pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-
-		//the LastDTPlvl should reset when disconnect, 
-		//otherwise the tx power level wouldn't change when disconnect and connect again.
-		// Maddest 20091220.
-		 pHalData->LastDTPLvl=TxHighPwrLevel_Normal;
-		return;
-	}
-
-#if (INTEL_PROXIMITY_SUPPORT == 1)
-	// Intel set fixed tx power 
-	if(pMgntInfo->IntelProximityModeInfo.PowerOutput > 0)
-	{
-		switch(pMgntInfo->IntelProximityModeInfo.PowerOutput){
-			case 1:
-				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_100;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_100\n"));
-				break;
-			case 2:
-				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_70;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_70\n"));
-				break;
-			case 3:
-				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_50;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_50\n"));
-				break;
-			case 4:
-				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_35;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_35\n"));
-				break;
-			case 5:
-				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_15;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_15\n"));
-				break;
-			default:
-				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_100;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_100\n"));
-				break;
-		}		
-	}
-	else
-#endif		
-	{ 
-		if(	(pMgntInfo->bDynamicTxPowerEnable != TRUE) ||
-			(pHalData->DMFlag & HAL_DM_HIPWR_DISABLE) ||
-			pMgntInfo->IOTAction & HT_IOT_ACT_DISABLE_HIGH_POWER)
-		{
-			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-		}
-		else
-		{
-			if(pMgntInfo->bMediaConnect)	// Default port
-			{
-				if(ACTING_AS_AP(Adapter) || ACTING_AS_IBSS(Adapter))
-				{
-					UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
-					ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-				}
-				else
-				{
-					UndecoratedSmoothedPWDB = pHalData->UndecoratedSmoothedPWDB;
-					ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-				}
-			}
-			else // associated entry pwdb
-			{	
-				UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-			}
-				
-			if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
-			{
-				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
-			}
-			else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
-				(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
-			{
-				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
-			}
-			else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
-			{
-				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-				ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
-			}
-		}
-	}
-	if( pHalData->DynamicTxHighPowerLvl != pHalData->LastDTPLvl )
-	{
-		ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192C() Channel = %d \n" , pHalData->CurrentChannel));
-		PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
-		if(	(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Normal) &&
-			(pHalData->LastDTPLvl == TxHighPwrLevel_Level1 || pHalData->LastDTPLvl == TxHighPwrLevel_Level2)) //TxHighPwrLevel_Normal
-			odm_DynamicTxPowerRestorePowerIndex(pDM_Odm);
-		else if(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)
-			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x14);
-		else if(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)
-			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x10);
-	}
-	pHalData->LastDTPLvl = pHalData->DynamicTxHighPowerLvl;
-
-	
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-
-	#if (RTL8192C_SUPPORT==1) 
-	PADAPTER Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
-	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
-	int	UndecoratedSmoothedPWDB;
-
-	if(!pdmpriv->bDynamicTxPowerEnable)
-		return;
-
-#ifdef CONFIG_INTEL_PROXIM
-	if(Adapter->proximity.proxim_on== _TRUE){
-		struct proximity_priv *prox_priv=Adapter->proximity.proximity_priv;
-		// Intel set fixed tx power 
-		printk("\n %s  Adapter->proximity.proxim_on=%d prox_priv->proxim_modeinfo->power_output=%d \n",__FUNCTION__,Adapter->proximity.proxim_on,prox_priv->proxim_modeinfo->power_output);
-		if(prox_priv!=NULL){
-			if(prox_priv->proxim_modeinfo->power_output> 0)	
-			{
-				switch(prox_priv->proxim_modeinfo->power_output)
-				{
-					case 1:
-						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_100;
-						printk("TxHighPwrLevel_100\n");
-						break;
-					case 2:
-						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_70;
-						printk("TxHighPwrLevel_70\n");
-						break;
-					case 3:
-						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_50;
-						printk("TxHighPwrLevel_50\n");
-						break;
-					case 4:
-						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_35;
-						printk("TxHighPwrLevel_35\n");
-						break;
-					case 5:
-						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_15;
-						printk("TxHighPwrLevel_15\n");
-						break;
-					default:
-						pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_100;
-						printk("TxHighPwrLevel_100\n");
-						break;
-				}		
-			}
-		}
-	}
-	else
-#endif	
-	{
-		// STA not connected and AP not connected
-		if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&	
-			(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
-		{
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-
-			//the LastDTPlvl should reset when disconnect, 
-			//otherwise the tx power level wouldn't change when disconnect and connect again.
-			// Maddest 20091220.
-			pdmpriv->LastDTPLvl=TxHighPwrLevel_Normal;
-			return;
-		}
-		
-		if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	// Default port
-		{
-		#if 0
-			//todo: AP Mode
-			if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
-			       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
-			{
-				UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-				//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-			}
-			else
-			{
-				UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
-				//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-			}
-		#else
-		UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;	
-		#endif
-		}
-		else // associated entry pwdb
-		{	
-			UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-		}
-			
-		if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
-		{
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
-		}
-		else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
-			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
-		{
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
-		}
-		else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
-		{
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
-		}
-	}
-	if( (pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl) )
-	{
-		PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
-		if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Normal) // HP1 -> Normal  or HP2 -> Normal
-			odm_DynamicTxPowerRestorePowerIndex(pDM_Odm);
-		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)
-			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x14);
-		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)
-			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x10);
-	}
-	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
-	#endif
-#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-}
-
-
-VOID 
-odm_DynamicTxPower_92D(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER Adapter = pDM_Odm->Adapter;
-	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	s4Byte				UndecoratedSmoothedPWDB;
-
-	PADAPTER	BuddyAdapter = Adapter->BuddyAdapter;
-	BOOLEAN		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(Adapter);
-	u1Byte		HighPowerLvlBackForMac0 = TxHighPwrLevel_Level1;
-
-	// 2012/01/12 MH According to Luke's suggestion, only high power will support the feature.
-	if (pDM_Odm->ExtPA == FALSE)
-		return;
-
-	// If dynamic high power is disabled.
-	if( (pMgntInfo->bDynamicTxPowerEnable != TRUE) ||
-		(pHalData->DMFlag & HAL_DM_HIPWR_DISABLE) ||
-		pMgntInfo->IOTAction & HT_IOT_ACT_DISABLE_HIGH_POWER)
-	{
-		pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-		return;
-	}
-
-	// STA not connected and AP not connected
-	if((!pMgntInfo->bMediaConnect) &&	
-		(pHalData->EntryMinUndecoratedSmoothedPWDB == 0))
-	{
-		ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
-		pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-
-		//the LastDTPlvl should reset when disconnect, 
-		//otherwise the tx power level wouldn't change when disconnect and connect again.
-		// Maddest 20091220.
-		 pHalData->LastDTPLvl=TxHighPwrLevel_Normal;
-		return;
-	}
-	
-	if(pMgntInfo->bMediaConnect)	// Default port
-	{
-		if(ACTING_AS_AP(Adapter) || pMgntInfo->mIbss)
-		{
-			UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
-			ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-		}
-		else
-		{
-			UndecoratedSmoothedPWDB = pHalData->UndecoratedSmoothedPWDB;
-			ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-		}
-	}
-	else // associated entry pwdb
-	{	
-		UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
-		ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-	}
-	
-	if(IS_HARDWARE_TYPE_8192D(Adapter) && GET_HAL_DATA(Adapter)->CurrentBandType == 1){
-		if(UndecoratedSmoothedPWDB >= 0x33)
-		{
-			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
-			ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level2 (TxPwr=0x0)\n"));
-		}
-		else if((UndecoratedSmoothedPWDB <0x33) &&
-			(UndecoratedSmoothedPWDB >= 0x2b) )
-		{
-			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
-			ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
-		}
-		else if(UndecoratedSmoothedPWDB < 0x2b)
-		{
-			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-			ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Normal\n"));
-		}
-
-	}
-	else
-	
-	{
-		if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
-		{
-			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
-			ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
-		}
-		else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
-			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
-		{
-			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
-			ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
-		}
-		else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
-		{
-			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-			ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
-		}
-
-	}
-
-//sherry  delete flag 20110517
-	if(bGetValueFromBuddyAdapter)
-	{
-		ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 1 \n"));
-		if(Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP)
-		{
-			ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() change value \n"));
-			HighPowerLvlBackForMac0 = pHalData->DynamicTxHighPowerLvl;
-			pHalData->DynamicTxHighPowerLvl = Adapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP;
-			PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
-			pHalData->DynamicTxHighPowerLvl = HighPowerLvlBackForMac0;
-			Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = FALSE;
-		}						
-	}
-
-	if( (pHalData->DynamicTxHighPowerLvl != pHalData->LastDTPLvl) )
-	{
-			ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192S() Channel = %d \n" , pHalData->CurrentChannel));
-			if(Adapter->DualMacSmartConcurrent == TRUE)
-			{
-				if(BuddyAdapter == NULL)
-				{
-					ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter == NULL case \n"));
-					if(!Adapter->bSlaveOfDMSP)
-					{
-						PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
-					}
-				}
-				else
-				{
-					if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
-					{
-						ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMSP \n"));
-						if(Adapter->bSlaveOfDMSP)
-						{
-							ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() bslave case  \n"));
-							BuddyAdapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = TRUE;
-							BuddyAdapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP = pHalData->DynamicTxHighPowerLvl;
-						}
-						else
-						{
-							ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() master case  \n"));					
-							if(!bGetValueFromBuddyAdapter)
-							{
-								ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 0 \n"));
-								PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
-							}
-						}
-					}
-					else
-					{
-						ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMDP\n"));
-						PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
-					}
-				}
-			}
-			else
-			{
-				PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
-			}
-
-		}
-	pHalData->LastDTPLvl = pHalData->DynamicTxHighPowerLvl;
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-#if (RTL8192D_SUPPORT==1) 
-	PADAPTER Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
-
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	DM_ODM_T 		*podmpriv = &pHalData->odmpriv;
-	int	UndecoratedSmoothedPWDB;
-	#if (RTL8192D_EASY_SMART_CONCURRENT == 1)
-	PADAPTER	BuddyAdapter = Adapter->BuddyAdapter;
-	BOOLEAN		bGetValueFromBuddyAdapter = DualMacGetParameterFromBuddyAdapter(Adapter);
-	u8		HighPowerLvlBackForMac0 = TxHighPwrLevel_Level1;
-	#endif
-
-	// If dynamic high power is disabled.
-	if( (pdmpriv->bDynamicTxPowerEnable != _TRUE) ||
-		(!(podmpriv->SupportAbility& ODM_BB_DYNAMIC_TXPWR)) )
-	{
-		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-		return;
-	}
-
-	// STA not connected and AP not connected
-	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&	
-		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
-	{
-		//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
-		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-		//the LastDTPlvl should reset when disconnect, 
-		//otherwise the tx power level wouldn't change when disconnect and connect again.
-		// Maddest 20091220.
-		pdmpriv->LastDTPLvl=TxHighPwrLevel_Normal;
-		return;
-	}
-		
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	// Default port
-	{
-	#if 0
-		//todo: AP Mode
-		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
-	       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
-		{
-			UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-		}
-		else
-		{
-			UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-		}
-	#else
-	UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-	#endif
-	}
-	else // associated entry pwdb
-	{	
-		UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-		//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
-	}
-#if TX_POWER_FOR_5G_BAND == 1
-	if(pHalData->CurrentBandType92D == BAND_ON_5G){
-		if(UndecoratedSmoothedPWDB >= 0x33)
-		{
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level2 (TxPwr=0x0)\n"));
-		}
-		else if((UndecoratedSmoothedPWDB <0x33) &&
-			(UndecoratedSmoothedPWDB >= 0x2b) )
-		{
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
-		}
-		else if(UndecoratedSmoothedPWDB < 0x2b)
-		{
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Normal\n"));
-		}
-	}
-	else
-#endif
-	{
-		if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
-		{
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
-		}
-		else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
-			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
-		{
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
-		}
-		else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
-		{
-			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
-		}
-	}
-#if (RTL8192D_EASY_SMART_CONCURRENT == 1)
-	if(bGetValueFromBuddyAdapter)
-	{
-		//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 1 \n"));
-		if(Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP)
-		{
-			//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() change value \n"));
-			HighPowerLvlBackForMac0 = pHalData->DynamicTxHighPowerLvl;
-			pHalData->DynamicTxHighPowerLvl = Adapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP;
-			PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
-			pHalData->DynamicTxHighPowerLvl = HighPowerLvlBackForMac0;
-			Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = _FALSE;
-		}						
-	}
-#endif
-
-	if( (pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl) )
-	{
-		//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192S() Channel = %d \n" , pHalData->CurrentChannel));
-#if (RTL8192D_EASY_SMART_CONCURRENT == 1)
-		if(BuddyAdapter == NULL)
-		{
-			//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter == NULL case \n"));
-			if(!Adapter->bSlaveOfDMSP)
-			{
-				PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
-			}
-		}
-		else
-		{
-			if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
-			{
-				//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMSP \n"));
-				if(Adapter->bSlaveOfDMSP)
-				{
-					//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() bslave case  \n"));
-					BuddyAdapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = _TRUE;
-					BuddyAdapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP = pHalData->DynamicTxHighPowerLvl;
-				}
-				else
-				{
-					//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() master case  \n"));					
-					if(!bGetValueFromBuddyAdapter)
-					{
-						//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 0 \n"));
-						PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
-					}
-				}
-			}
-			else
-			{
-				//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMDP\n"));
-				PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
-			}
-		}
-#else
-		PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
-#endif
-	}
-	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
-#endif	
-#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-}
-
-
-//3============================================================
-//3 RSSI Monitor
-//3============================================================
-
-VOID
-odm_RSSIDumpToRegister(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-
-	if(pDM_Odm->SupportICType == ODM_RTL8812)
-	{
-		PlatformEFIOWrite1Byte(Adapter, rA_RSSIDump_Jaguar, Adapter->RxStats.RxRSSIPercentage[0]);
-		PlatformEFIOWrite1Byte(Adapter, rB_RSSIDump_Jaguar, Adapter->RxStats.RxRSSIPercentage[1]);
-
-		// Rx EVM
-		PlatformEFIOWrite1Byte(Adapter, rS1_RXevmDump_Jaguar, Adapter->RxStats.RxEVMdbm[0]);
-		PlatformEFIOWrite1Byte(Adapter, rS2_RXevmDump_Jaguar, Adapter->RxStats.RxEVMdbm[1]);
-
-		// Rx SNR
-		PlatformEFIOWrite1Byte(Adapter, rA_RXsnrDump_Jaguar, (u1Byte)(Adapter->RxStats.RxSNRdB[0]));
-		PlatformEFIOWrite1Byte(Adapter, rB_RXsnrDump_Jaguar, (u1Byte)(Adapter->RxStats.RxSNRdB[1]));
-
-		// Rx Cfo_Short
-		PlatformEFIOWrite2Byte(Adapter, rA_CfoShortDump_Jaguar, Adapter->RxStats.RxCfoShort[0]);
-		PlatformEFIOWrite2Byte(Adapter, rB_CfoShortDump_Jaguar, Adapter->RxStats.RxCfoShort[1]);
-
-		// Rx Cfo_Tail
-		PlatformEFIOWrite2Byte(Adapter, rA_CfoLongDump_Jaguar, Adapter->RxStats.RxCfoTail[0]);
-		PlatformEFIOWrite2Byte(Adapter, rB_CfoLongDump_Jaguar, Adapter->RxStats.RxCfoTail[1]);
-	}
-	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
-	{
-		PlatformEFIOWrite1Byte(Adapter, rA_RSSIDump_92E, Adapter->RxStats.RxRSSIPercentage[0]);
-		PlatformEFIOWrite1Byte(Adapter, rB_RSSIDump_92E, Adapter->RxStats.RxRSSIPercentage[1]);
-		// Rx EVM
-		PlatformEFIOWrite1Byte(Adapter, rS1_RXevmDump_92E, Adapter->RxStats.RxEVMdbm[0]);
-		PlatformEFIOWrite1Byte(Adapter, rS2_RXevmDump_92E, Adapter->RxStats.RxEVMdbm[1]);
-		// Rx SNR
-		PlatformEFIOWrite1Byte(Adapter, rA_RXsnrDump_92E, (u1Byte)(Adapter->RxStats.RxSNRdB[0]));
-		PlatformEFIOWrite1Byte(Adapter, rB_RXsnrDump_92E, (u1Byte)(Adapter->RxStats.RxSNRdB[1]));
-		// Rx Cfo_Short
-		PlatformEFIOWrite2Byte(Adapter, rA_CfoShortDump_92E, Adapter->RxStats.RxCfoShort[0]);
-		PlatformEFIOWrite2Byte(Adapter, rB_CfoShortDump_92E, Adapter->RxStats.RxCfoShort[1]);
-		// Rx Cfo_Tail
-		PlatformEFIOWrite2Byte(Adapter, rA_CfoLongDump_92E, Adapter->RxStats.RxCfoTail[0]);
-		PlatformEFIOWrite2Byte(Adapter, rB_CfoLongDump_92E, Adapter->RxStats.RxCfoTail[1]);
-	 }
-#endif
-}
-
-
-VOID
-odm_RSSIMonitorInit(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-	pRA_T		pRA_Table = &pDM_Odm->DM_RA_Table;
-
-   	pRA_Table->firstconnect = FALSE;
-
-}
-
-VOID
-odm_RSSIMonitorCheck(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	// 
-	// For AP/ADSL use prtl8192cd_priv
-	// For CE/NIC use PADAPTER
-	//
-
-	if (!(pDM_Odm->SupportAbility & ODM_BB_RSSI_MONITOR))
-		return;
-	
-	//
-	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
-	// at the same time. In the stage2/3, we need to prive universal interface and merge all
-	// HW dynamic mechanism.
-	//
-	switch	(pDM_Odm->SupportPlatform)
-	{
-		case	ODM_WIN:
-			odm_RSSIMonitorCheckMP(pDM_Odm);
-			break;
-
-		case	ODM_CE:
-			odm_RSSIMonitorCheckCE(pDM_Odm);
-			break;
-
-		case	ODM_AP:
-			odm_RSSIMonitorCheckAP(pDM_Odm);
-			break;		
-
-		case	ODM_ADSL:
-			//odm_DIGAP(pDM_Odm);
-			break;	
-	}
-	
-}	// odm_RSSIMonitorCheck
-
-
-VOID
-odm_RSSIMonitorCheckMP(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	PRT_WLAN_STA	pEntry;
-	u1Byte			i;
-	s4Byte			tmpEntryMaxPWDB=0, tmpEntryMinPWDB=0xff;
-	u1Byte			H2C_Parameter[4] ={0};
-	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
-	u8Byte			curTxOkCnt = 0, curRxOkCnt = 0;	
-	u1Byte			STBC_TX = 0;
-	BOOLEAN			FirstConnect;                                                    
-	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;      
-#if (BEAMFORMING_SUPPORT == 1)	
-	BEAMFORMING_CAP Beamform_cap = BEAMFORMING_CAP_NONE;
-	u1Byte			TxBF_EN = 0;
-#endif
-
-	RT_DISP(FDM, DM_PWDB, ("pHalData->UndecoratedSmoothedPWDB = 0x%x( %d)\n", 
-		pHalData->UndecoratedSmoothedPWDB,
-		pHalData->UndecoratedSmoothedPWDB));
-
-	curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - pMgntInfo->lastTxOkCnt;
-	curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - pMgntInfo->lastRxOkCnt;
-	pMgntInfo->lastTxOkCnt = curTxOkCnt;
-	pMgntInfo->lastRxOkCnt = curRxOkCnt;
-
-	RT_DISP(FDM, DM_PWDB, ("Tx = %d Rx = %d\n", curTxOkCnt, curRxOkCnt));
-
-       FirstConnect = (pHalData->bLinked) && (pRA_Table->firstconnect == FALSE);    
-	pRA_Table->firstconnect = pHalData->bLinked;                                               
-       H2C_Parameter[3] |= FirstConnect << 5;
-
-	if(pDM_Odm->SupportICType == ODM_RTL8188E && (pMgntInfo->CustomerID==RT_CID_819x_HP))
-	{
-		if(curRxOkCnt >(curTxOkCnt*6))
-			PlatformEFIOWrite4Byte(Adapter, REG_ARFR0, 0x8f015);
-		else
-			PlatformEFIOWrite4Byte(Adapter, REG_ARFR0, 0xff015);
-	}	
-
-	if(pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8821)
-	{
-		if(curRxOkCnt >(curTxOkCnt*6))
-			H2C_Parameter[3]=0x01;
-		else
-			H2C_Parameter[3]=0x00;
-	}
-
-	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
-		{
-			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
-		}
-		else
-		{
-			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
-		}
-
-		if(pEntry != NULL)
-		{
-			if(pEntry->bAssociated)
-			{
-			
-				RT_DISP_ADDR(FDM, DM_PWDB, ("pEntry->MacAddr ="), pEntry->MacAddr);
-				RT_DISP(FDM, DM_PWDB, ("pEntry->rssi = 0x%x(%d)\n", 
-					pEntry->rssi_stat.UndecoratedSmoothedPWDB, pEntry->rssi_stat.UndecoratedSmoothedPWDB));
-
-				if(pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8812)
-				{
-
-#if (BEAMFORMING_SUPPORT == 1)
-					Beamform_cap = Beamforming_GetEntryBeamCapByMacId(pMgntInfo, pEntry->AssociatedMacId);
-					if(Beamform_cap & (BEAMFORMER_CAP_HT_EXPLICIT |BEAMFORMER_CAP_VHT_SU))
-						TxBF_EN = 1;
-					else
-						TxBF_EN = 0;
-	
-					H2C_Parameter[3] |= TxBF_EN << 6; 
-					
-					if(TxBF_EN)
-						STBC_TX = 0;
-					else
-#endif
-					{
-						if(IS_WIRELESS_MODE_AC(Adapter))
-							STBC_TX = TEST_FLAG(pEntry->VHTInfo.STBC, STBC_VHT_ENABLE_TX);
-						else
-							STBC_TX = TEST_FLAG(pEntry->HTInfo.STBC, STBC_HT_ENABLE_TX);
-					}
-
-					H2C_Parameter[3] |= STBC_TX << 1;
-				}
-
-				if(pEntry->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
-					tmpEntryMinPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
-				if(pEntry->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
-					tmpEntryMaxPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
-
-				H2C_Parameter[2] = (u1Byte)(pEntry->rssi_stat.UndecoratedSmoothedPWDB & 0xFF);
-				H2C_Parameter[1] = 0x20;   // fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
-				H2C_Parameter[0] = (pEntry->AssociatedMacId);
-				if(pDM_Odm->SupportICType == ODM_RTL8812)
-					ODM_FillH2CCmd(Adapter, ODM_H2C_RSSI_REPORT, 4, H2C_Parameter);
-				else if(pDM_Odm->SupportICType == ODM_RTL8192E)
-					ODM_FillH2CCmd(Adapter, ODM_H2C_RSSI_REPORT, 4, H2C_Parameter);
-				else	
-					ODM_FillH2CCmd(Adapter, ODM_H2C_RSSI_REPORT, 3, H2C_Parameter);
-			}
-		}
-		else
-		{
-			break;
-		}
-	}
-
-	if(tmpEntryMaxPWDB != 0)	// If associated entry is found
-	{
-		pHalData->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
-		RT_DISP(FDM, DM_PWDB, ("EntryMaxPWDB = 0x%x(%d)\n",	tmpEntryMaxPWDB, tmpEntryMaxPWDB));
-	}
-	else
-	{
-		pHalData->EntryMaxUndecoratedSmoothedPWDB = 0;
-	}
-	
-	if(tmpEntryMinPWDB != 0xff) // If associated entry is found
-	{
-		pHalData->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
-		RT_DISP(FDM, DM_PWDB, ("EntryMinPWDB = 0x%x(%d)\n", tmpEntryMinPWDB, tmpEntryMinPWDB));
-
-	}
-	else
-	{
-		pHalData->EntryMinUndecoratedSmoothedPWDB = 0;
-	}
-
-	// Indicate Rx signal strength to FW.
-	if(pHalData->bUseRAMask)
-	{
-		if(pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8812)
-		{
-			PRT_HIGH_THROUGHPUT 		pHTInfo = GET_HT_INFO(pMgntInfo);
-			PRT_VERY_HIGH_THROUGHPUT	pVHTInfo = GET_VHT_INFO(pMgntInfo);
-
-#if (BEAMFORMING_SUPPORT == 1)
-			
-			Beamform_cap = Beamforming_GetEntryBeamCapByMacId(pMgntInfo, pMgntInfo->mMacId);
-
-			if(Beamform_cap & (BEAMFORMER_CAP_HT_EXPLICIT |BEAMFORMER_CAP_VHT_SU))
-				TxBF_EN = 1;
-			else
-				TxBF_EN = 0;
-
-			H2C_Parameter[3] |= TxBF_EN << 6; 
-
-			if(TxBF_EN)
-				STBC_TX = 0;
-			else
-#endif
-			{
-				if(IS_WIRELESS_MODE_AC(Adapter))
-					STBC_TX = TEST_FLAG(pVHTInfo->VhtCurStbc, STBC_VHT_ENABLE_TX);
-				else
-					STBC_TX = TEST_FLAG(pHTInfo->HtCurStbc, STBC_HT_ENABLE_TX);
-			}
-
-			H2C_Parameter[3] |= STBC_TX << 1;
-		}
-		
-		H2C_Parameter[2] = (u1Byte)(pHalData->UndecoratedSmoothedPWDB & 0xFF);
-		H2C_Parameter[1] = 0x20;	// fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
-		H2C_Parameter[0] = 0;		// fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
-		if(pDM_Odm->SupportICType == ODM_RTL8812)
-			ODM_FillH2CCmd(Adapter, ODM_H2C_RSSI_REPORT, 4, H2C_Parameter);
-		else  if(pDM_Odm->SupportICType == ODM_RTL8192E)
-			ODM_FillH2CCmd(Adapter, ODM_H2C_RSSI_REPORT, 4, H2C_Parameter);	
-		else	
-			ODM_FillH2CCmd(Adapter, ODM_H2C_RSSI_REPORT, 3, H2C_Parameter);
-	}
-	else
-	{
-		PlatformEFIOWrite1Byte(Adapter, 0x4fe, (u1Byte)pHalData->UndecoratedSmoothedPWDB);
-	}
-
-	if((pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8192E))
-		odm_RSSIDumpToRegister(pDM_Odm);
-
-	odm_FindMinimumRSSI(Adapter);
-	ODM_CmnInfoUpdate(&pHalData->DM_OutSrc ,ODM_CMNINFO_LINK, (u8Byte)pHalData->bLinked);
-	ODM_CmnInfoUpdate(&pHalData->DM_OutSrc ,ODM_CMNINFO_RSSI_MIN, (u8Byte)pHalData->MinUndecoratedPWDBForDM);
-#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-}
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-//
-//sherry move from DUSC to here 20110517
-//
-static VOID
-FindMinimumRSSI_Dmsp(
-	IN	PADAPTER	pAdapter
-)
-{
-#if 0
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	s32	Rssi_val_min_back_for_mac0;
-	BOOLEAN		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(pAdapter);
-	BOOLEAN		bRestoreRssi = _FALSE;
-	PADAPTER	BuddyAdapter = pAdapter->BuddyAdapter;
-
-	if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
-	{
-		if(BuddyAdapter!= NULL)
-		{
-			if(pHalData->bSlaveOfDMSP)
-			{
-				//ODM_RT_TRACE(pDM_Odm,COMP_EASY_CONCURRENT,DBG_LOUD,("bSlavecase of dmsp\n"));
-				BuddyAdapter->DualMacDMSPControl.RssiValMinForAnotherMacOfDMSP = pdmpriv->MinUndecoratedPWDBForDM;
-			}
-			else
-			{
-				if(bGetValueFromBuddyAdapter)
-				{
-					//ODM_RT_TRACE(pDM_Odm,COMP_EASY_CONCURRENT,DBG_LOUD,("get new RSSI\n"));
-					bRestoreRssi = _TRUE;
-					Rssi_val_min_back_for_mac0 = pdmpriv->MinUndecoratedPWDBForDM;
-					pdmpriv->MinUndecoratedPWDBForDM = pAdapter->DualMacDMSPControl.RssiValMinForAnotherMacOfDMSP;
-				}
-			}
-		}
-		
-	}
-
-	if(bRestoreRssi)
-	{
-		bRestoreRssi = _FALSE;
-		pdmpriv->MinUndecoratedPWDBForDM = Rssi_val_min_back_for_mac0;
-	}
-#endif
-}
-
-static void
-FindMinimumRSSI(
-IN	PADAPTER	pAdapter
-	)
-{	
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;	
-	PDM_ODM_T		pDM_Odm = &(pHalData->odmpriv);
-
-	//1 1.Determine the minimum RSSI 
-
-	if((pDM_Odm->bLinked != _TRUE) &&
-		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
-	{
-		pdmpriv->MinUndecoratedPWDBForDM = 0;
-		//ODM_RT_TRACE(pDM_Odm,COMP_BB_POWERSAVING, DBG_LOUD, ("Not connected to any \n"));
-	}
-	else
-	{
-		pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-	}
-
-	//DBG_8192C("%s=>MinUndecoratedPWDBForDM(%d)\n",__FUNCTION__,pdmpriv->MinUndecoratedPWDBForDM);
-	//ODM_RT_TRACE(pDM_Odm,COMP_DIG, DBG_LOUD, ("MinUndecoratedPWDBForDM =%d\n",pHalData->MinUndecoratedPWDBForDM));
-}
-#endif
-
-VOID
-odm_RSSIMonitorCheckCE(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	PADAPTER	Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(Adapter);
-	int	i;
-	int	tmpEntryMaxPWDB=0, tmpEntryMinPWDB=0xff;
-	u8 	sta_cnt=0;
-	u32	UL_DL_STATE = 0, STBC_TX = 0, TxBF_EN = 0;
-	u32	PWDB_rssi[NUM_STA]={0};//[0~15]:MACID, [16~31]:PWDB_rssi
-	BOOLEAN			FirstConnect = FALSE;
-	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
-
-	if(pDM_Odm->bLinked != _TRUE)
-		return;
-
-	#if((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
-	if((pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8821))
-	{
-		u64	curTxOkCnt = pdvobjpriv->traffic_stat.cur_tx_bytes;
-		u64	curRxOkCnt = pdvobjpriv->traffic_stat.cur_rx_bytes;
-
-		if(curRxOkCnt >(curTxOkCnt*6))
-			UL_DL_STATE = 1;
-		else
-			UL_DL_STATE = 0;
-	}
-	#endif
-
-       FirstConnect = (pDM_Odm->bLinked) && (pRA_Table->firstconnect == FALSE);    
-	pRA_Table->firstconnect = pDM_Odm->bLinked;
-
-	//if(check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == _TRUE)
-	{
-		#if 1
-		struct sta_info *psta;
-		
-		for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++) {
-			if (IS_STA_VALID(psta = pDM_Odm->pODM_StaInfo[i]))
-			{
-                        		if(IS_MCAST( psta->hwaddr))  //if(psta->mac_id ==1)
-						 continue;
-								
-					if(psta->rssi_stat.UndecoratedSmoothedPWDB == (-1))
-						 continue;
-								
-					if(psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
-						tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
-
-					if(psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
-						tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
-
-					#if 0
-					DBG_871X("%s mac_id:%u, mac:"MAC_FMT", rssi:%d\n", __func__,
-						psta->mac_id, MAC_ARG(psta->hwaddr), psta->rssi_stat.UndecoratedSmoothedPWDB);
-					#endif
-
-					if(psta->rssi_stat.UndecoratedSmoothedPWDB != (-1)) {
-
-#ifdef CONFIG_80211N_HT
-						if(pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8812)
-						{
-#ifdef CONFIG_BEAMFORMING
-							BEAMFORMING_CAP Beamform_cap = beamforming_get_entry_beam_cap_by_mac_id(&Adapter->mlmepriv, psta->mac_id);
-
-							if(Beamform_cap & (BEAMFORMER_CAP_HT_EXPLICIT |BEAMFORMER_CAP_VHT_SU))
-								TxBF_EN = 1;
-							else
-								TxBF_EN = 0;
-
-							if (TxBF_EN) {
-								STBC_TX = 0;
-							}
-							else
-#endif
-							{
-#ifdef CONFIG_80211AC_VHT
-								if(IsSupportedVHT(psta->wireless_mode))
-									STBC_TX = TEST_FLAG(psta->vhtpriv.stbc_cap, STBC_VHT_ENABLE_TX);
-								else	
-#endif
-									STBC_TX = TEST_FLAG(psta->htpriv.stbc_cap, STBC_HT_ENABLE_TX);
-							}
-						}
-#endif
-
-						if(pDM_Odm->SupportICType == ODM_RTL8192D)
-							PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) | ((Adapter->stapriv.asoc_sta_count+1) << 8));
-						else if ((pDM_Odm->SupportICType == ODM_RTL8192E)||(pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8821))
-							PWDB_rssi[sta_cnt++] = (((u8)(psta->mac_id&0xFF)) | ((psta->rssi_stat.UndecoratedSmoothedPWDB&0x7F)<<16) |(STBC_TX << 25) | (FirstConnect << 29) | (TxBF_EN << 30));
-						else
-							PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) );
-					}
-			}
-		}
-		#else
-		_irqL irqL;
-		_list	*plist, *phead;
-		struct sta_info *psta;
-		struct sta_priv *pstapriv = &Adapter->stapriv;
-		u8 bcast_addr[ETH_ALEN]= {0xff,0xff,0xff,0xff,0xff,0xff};
-
-		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
-
-		for(i=0; i< NUM_STA; i++)
-		{
-			phead = &(pstapriv->sta_hash[i]);
-			plist = get_next(phead);
-		
-			while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
-			{
-				psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
-
-				plist = get_next(plist);
-
-				if(_rtw_memcmp(psta->hwaddr, bcast_addr, ETH_ALEN) || 
-					_rtw_memcmp(psta->hwaddr, myid(&Adapter->eeprompriv), ETH_ALEN))
-					continue;
-
-				if(psta->state & WIFI_ASOC_STATE)
-				{
-					
-					if(psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
-						tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
-
-					if(psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
-						tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
-
-					if(psta->rssi_stat.UndecoratedSmoothedPWDB != (-1)){
-						//printk("%s==> mac_id(%d),rssi(%d)\n",__FUNCTION__,psta->mac_id,psta->rssi_stat.UndecoratedSmoothedPWDB);
-						#if(RTL8192D_SUPPORT==1)
-						PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) | ((Adapter->stapriv.asoc_sta_count+1) << 8));
-						#else
-						PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) );
-						#endif
-					}
-				}
-			
-			}
-
-		}
-	
-		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
-		#endif
-
-		//printk("%s==> sta_cnt(%d)\n",__FUNCTION__,sta_cnt);
-
-		for(i=0; i< sta_cnt; i++)
-		{
-			if(PWDB_rssi[i] != (0)){
-				if(pHalData->fw_ractrl == _TRUE)// Report every sta's RSSI to FW
-				{
-					#if(RTL8192D_SUPPORT==1)
-					if(pDM_Odm->SupportICType == ODM_RTL8192D){
-						FillH2CCmd92D(Adapter, H2C_RSSI_REPORT, 3, (u8 *)(&PWDB_rssi[i]));		
-					}
-					#endif
-					
-					#if((RTL8192C_SUPPORT==1)||(RTL8723A_SUPPORT==1))
-					if((pDM_Odm->SupportICType == ODM_RTL8192C)||(pDM_Odm->SupportICType == ODM_RTL8723A)){
-						rtl8192c_set_rssi_cmd(Adapter, (u8*)&PWDB_rssi[i]);
-					}
-					#endif
-					
-					#if((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
-					if((pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8821)){	
-						PWDB_rssi[i] |= (UL_DL_STATE << 24);
-						rtl8812_set_rssi_cmd(Adapter, (u8 *)(&PWDB_rssi[i]));
-					}
-					#endif
-					#if(RTL8192E_SUPPORT==1)
-					if(pDM_Odm->SupportICType == ODM_RTL8192E){
-						rtl8192e_set_rssi_cmd(Adapter, (u8 *)(&PWDB_rssi[i]));
-					}
-					#endif
-					#if(RTL8723B_SUPPORT==1)
-					if(pDM_Odm->SupportICType == ODM_RTL8723B){
-						rtl8723b_set_rssi_cmd(Adapter, (u8 *)(&PWDB_rssi[i]));
-					}
-					#endif
-				}
-				else{
-					#if((RTL8188E_SUPPORT==1)&&(RATE_ADAPTIVE_SUPPORT == 1))
-					if(pDM_Odm->SupportICType == ODM_RTL8188E){
-						ODM_RA_SetRSSI_8188E(
-						&(pHalData->odmpriv), (PWDB_rssi[i]&0xFF), (u8)((PWDB_rssi[i]>>16) & 0xFF));
-					}
-					#endif
-				}
-			}
-		}		
-	}
-
-
-
-	if(tmpEntryMaxPWDB != 0)	// If associated entry is found
-	{
-		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;		
-	}
-	else
-	{
-		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;
-	}
-
-	if(tmpEntryMinPWDB != 0xff) // If associated entry is found
-	{
-		pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;		
-	}
-	else
-	{
-		pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
-	}
-
-	FindMinimumRSSI(Adapter);//get pdmpriv->MinUndecoratedPWDBForDM
-
-	#if(RTL8192D_SUPPORT==1)
-	FindMinimumRSSI_Dmsp(Adapter);
-	#endif
-	pDM_Odm->RSSI_Min = pdmpriv->MinUndecoratedPWDBForDM;
-	//ODM_CmnInfoUpdate(&pHalData->odmpriv ,ODM_CMNINFO_RSSI_MIN, pdmpriv->MinUndecoratedPWDBForDM);
-#endif//if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-}
-VOID
-odm_RSSIMonitorCheckAP(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
-#ifdef CONFIG_RTL_92C_SUPPORT || defined(CONFIG_RTL_92D_SUPPORT)
-
-	u4Byte i;
-	PSTA_INFO_T pstat;
-
-	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-		pstat = pDM_Odm->pODM_StaInfo[i];
-		if(IS_STA_VALID(pstat) )
-		{			
-#ifdef STA_EXT
-			if (REMAP_AID(pstat) < (FW_NUM_STAT - 1))
-#endif
-				add_update_rssi(pDM_Odm->priv, pstat);
-
-		}		
-	}
-#endif
-#endif
-
-}
-
-
-
-VOID
-ODM_InitAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
-	)
-{
-#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
-	ODM_InitializeTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer_8723B,
-	(RT_TIMER_CALL_BACK)ODM_SW_AntDiv_Callback, NULL, "SwAntennaSwitchTimer_8723B");
-#endif
-#endif
-
-#if(defined(CONFIG_SW_ANTENNA_DIVERSITY))
-	ODM_InitializeTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer,
-		(RT_TIMER_CALL_BACK)odm_SwAntDivChkAntSwitchCallback, NULL, "SwAntennaSwitchTimer");
-#endif
-	
-#if (!(DM_ODM_SUPPORT_TYPE == ODM_CE))
-#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-#if (RTL8188E_SUPPORT == 1)
-	ODM_InitializeTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer,
-		(RT_TIMER_CALL_BACK)odm_FastAntTrainingCallback, NULL, "FastAntTrainingTimer");
-#endif
-#endif
-#endif
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PSDTimer, 
-		(RT_TIMER_CALL_BACK)dm_PSDMonitorCallback, NULL, "PSDTimer");
-	//
-	//Path Diversity
-	//Neil Chen--2011--06--16--  / 2012/02/23 MH Revise Arch.
-	//
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 
-		(RT_TIMER_CALL_BACK)odm_PathDivChkAntSwitchCallback, NULL, "PathDivTimer");
-
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, 
-		(RT_TIMER_CALL_BACK)odm_CCKTXPathDiversityCallback, NULL, "CCKPathDiversityTimer");
-
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 
-		(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");
-
-	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->DM_RXHP_Table.PSDTimer,
-		(RT_TIMER_CALL_BACK)odm_PSD_RXHPCallback, NULL, "PSDRXHPTimer");  
-#endif	
-}
-
-VOID
-ODM_CancelAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	//
-	// 2012/01/12 MH Temp BSOD fix. We need to find NIC allocate mem fail reason in 
-	// win7 platform.
-	//
-	HAL_ADAPTER_STS_CHK(pDM_Odm)
-#endif	
-#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
-	ODM_CancelTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer_8723B);
-#endif
-#endif
-
-#if(defined(CONFIG_SW_ANTENNA_DIVERSITY))
-	ODM_CancelTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer);
-#endif
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-#if (RTL8188E_SUPPORT == 1)
-	ODM_CancelTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer);
-#endif
-	ODM_CancelTimer(pDM_Odm, &pDM_Odm->PSDTimer);	
-	//
-	//Path Diversity
-	//Neil Chen--2011--06--16--  / 2012/02/23 MH Revise Arch.
-	//
-	ODM_CancelTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer);
-
-	ODM_CancelTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer);
-
-	ODM_CancelTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
-
-	ODM_CancelTimer(pDM_Odm, &pDM_Odm->DM_RXHP_Table.PSDTimer);
-#endif	
-}
-
-
-VOID
-ODM_ReleaseAllTimers(
-	IN PDM_ODM_T	pDM_Odm 
-	)
-{
-#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
-	ODM_ReleaseTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer_8723B);
-#endif
-#endif
-
-#if(defined(CONFIG_SW_ANTENNA_DIVERSITY))
-	ODM_ReleaseTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer);
-#endif
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-#if (RTL8188E_SUPPORT == 1)
-	ODM_ReleaseTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer);
-#endif
-
-	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->PSDTimer);
-	//
-	//Path Diversity
-	//Neil Chen--2011--06--16--  / 2012/02/23 MH Revise Arch.
-	//
-	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer);
-
-	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer);
-
-	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
-
-	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->DM_RXHP_Table.PSDTimer); 
-#endif	
-}
-
-
-//3============================================================
-//3 Tx Power Tracking
-//3============================================================
-
-VOID
-odm_IQCalibrate(
-		IN	PDM_ODM_T	pDM_Odm 
-		)
-{
-	PADAPTER	Adapter = pDM_Odm->Adapter;
-	
-	if(!IS_HARDWARE_TYPE_JAGUAR(Adapter))
-		return;
-	else if(IS_HARDWARE_TYPE_8812AU(Adapter))
-		return;
-#if (RTL8821A_SUPPORT == 1)
-	if(pDM_Odm->bLinked)
-	{
-		if((*pDM_Odm->pChannel != pDM_Odm->preChannel) && (!*pDM_Odm->pbScanInProcess))
-		{
-			pDM_Odm->preChannel = *pDM_Odm->pChannel;
-			pDM_Odm->LinkedInterval = 0;
-		}
-
-		if(pDM_Odm->LinkedInterval < 3)
-			pDM_Odm->LinkedInterval++;
-		
-		if(pDM_Odm->LinkedInterval == 2)
-		{
-			// Mark out IQK flow to prevent tx stuck. by Maddest 20130306
-			// Open it verified by James 20130715
-			PHY_IQCalibrate_8821A(Adapter, FALSE);
-		}
-	}
-	else
-		pDM_Odm->LinkedInterval = 0;
-#endif
-}
-
-
-VOID
-odm_TXPowerTrackingInit(
-	IN	PDM_ODM_T	pDM_Odm 
-	)
-{
-	odm_TXPowerTrackingThermalMeterInit(pDM_Odm);
-}	
-
-u1Byte 
-getSwingIndex(
-	IN	PDM_ODM_T	pDM_Odm 
-	)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u1Byte 			i = 0;
-	u4Byte 			bbSwing;
-	u4Byte 			swingTableSize;
-	pu4Byte 			pSwingTable;
-
-	if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8723B ||
-		pDM_Odm->SupportICType == ODM_RTL8192E) 
-	{
-		bbSwing = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, 0xFFC00000);
-
-		pSwingTable = OFDMSwingTable_New;
-		swingTableSize = OFDM_TABLE_SIZE;
-	} else {
-#if ((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
-		if (pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8821)
-		{
-			bbSwing = PHY_GetTxBBSwing_8812A(Adapter, pHalData->CurrentBandType, ODM_RF_PATH_A);
-			pSwingTable = TxScalingTable_Jaguar;
-			swingTableSize = TXSCALE_TABLE_SIZE;
-		}
-		else
-#endif
-		{
-			bbSwing = 0;
-			pSwingTable = OFDMSwingTable;
-			swingTableSize = OFDM_TABLE_SIZE;
-		}
-	}
-
-	for (i = 0; i < swingTableSize; ++i) {
-		u4Byte tableValue = pSwingTable[i];
-		
-		if (tableValue >= 0x100000 )
-			tableValue >>= 22;
-		if (bbSwing == tableValue)
-			break;
-	}
-	return i;
-}
-
-VOID
-odm_TXPowerTrackingThermalMeterInit(
-	IN	PDM_ODM_T	pDM_Odm 
-	)
-{
-	u1Byte defaultSwingIndex = getSwingIndex(pDM_Odm);
-	u1Byte 			p = 0;
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
-	#if	MP_DRIVER != 1					//for mp driver, turn off txpwrtracking as default
-	pHalData->TxPowerTrackControl = TRUE;		
-	#endif
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	PADAPTER			Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-
-
-	if (pDM_Odm->SupportICType >= ODM_RTL8188E) 
-	{
-		pDM_Odm->RFCalibrateInfo.bTXPowerTracking = _TRUE;
-		pDM_Odm->RFCalibrateInfo.TXPowercount = 0;
-		pDM_Odm->RFCalibrateInfo.bTXPowerTrackingInit = _FALSE;
-		//#if	(MP_DRIVER != 1)		//for mp driver, turn off txpwrtracking as default
-		if ( *(pDM_Odm->mp_mode) != 1)
-			pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = _TRUE;
-		//#endif//#if	(MP_DRIVER != 1)
-		MSG_8192C("pDM_Odm TxPowerTrackControl = %d\n", pDM_Odm->RFCalibrateInfo.TxPowerTrackControl);
-	}
-	else
-	{
-		struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-
-		pdmpriv->bTXPowerTracking = _TRUE;
-		pdmpriv->TXPowercount = 0;
-		pdmpriv->bTXPowerTrackingInit = _FALSE;
-		//#if	(MP_DRIVER != 1)		//for mp driver, turn off txpwrtracking as default
-
-		if (*(pDM_Odm->mp_mode) != 1)
-			pdmpriv->TxPowerTrackControl = _TRUE;
-		//#endif//#if	(MP_DRIVER != 1)
-
-		//MSG_8192C("pdmpriv->TxPowerTrackControl = %d\n", pdmpriv->TxPowerTrackControl);
-	}
-	
-#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-	#ifdef RTL8188E_SUPPORT
-	{
-		pDM_Odm->RFCalibrateInfo.bTXPowerTracking = _TRUE;
-		pDM_Odm->RFCalibrateInfo.TXPowercount = 0;
-		pDM_Odm->RFCalibrateInfo.bTXPowerTrackingInit = _FALSE;
-		pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = _TRUE;
-	}
-	#endif
-#endif
-
-	pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = TRUE;
-	pDM_Odm->RFCalibrateInfo.ThermalValue = pHalData->EEPROMThermalMeter;
-	pDM_Odm->RFCalibrateInfo.ThermalValue_IQK = pHalData->EEPROMThermalMeter;
-	pDM_Odm->RFCalibrateInfo.ThermalValue_LCK = pHalData->EEPROMThermalMeter;	
-
-	// The index of "0 dB" in SwingTable.
-	if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8723B ||
-		pDM_Odm->SupportICType == ODM_RTL8192E) 
-	{
-		pDM_Odm->DefaultOfdmIndex = (defaultSwingIndex >= OFDM_TABLE_SIZE) ? 30 : defaultSwingIndex;
-		pDM_Odm->DefaultCckIndex = 20;	
-	}
-	else
-	{
-		pDM_Odm->DefaultOfdmIndex = (defaultSwingIndex >= TXSCALE_TABLE_SIZE) ? 24 : defaultSwingIndex;
-		pDM_Odm->DefaultCckIndex = 24;	
-	}
-
-	pDM_Odm->BbSwingIdxCckBase = pDM_Odm->DefaultCckIndex;
-	pDM_Odm->RFCalibrateInfo.CCK_index = pDM_Odm->DefaultCckIndex;
-	
-	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p)
-	{
-		pDM_Odm->BbSwingIdxOfdmBase[p] = pDM_Odm->DefaultOfdmIndex;		
-	   	pDM_Odm->RFCalibrateInfo.OFDM_index[p] = pDM_Odm->DefaultOfdmIndex;		
-		pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = 0;
-		pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast[p] = 0;
-		pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p] = 0;
-	}
-
-}
-
-
-VOID
-ODM_TXPowerTrackingCheck(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	//
-	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
-	// at the same time. In the stage2/3, we need to prive universal interface and merge all
-	// HW dynamic mechanism.
-	//
-	switch	(pDM_Odm->SupportPlatform)
-	{
-		case	ODM_WIN:
-			odm_TXPowerTrackingCheckMP(pDM_Odm);
-			break;
-
-		case	ODM_CE:
-			odm_TXPowerTrackingCheckCE(pDM_Odm);
-			break;
-
-		case	ODM_AP:
-			odm_TXPowerTrackingCheckAP(pDM_Odm);		
-			break;		
-
-		case	ODM_ADSL:
-			//odm_DIGAP(pDM_Odm);
-			break;	
-	}
-
-}
-
-VOID
-odm_TXPowerTrackingCheckCE(
-	IN		PDM_ODM_T		pDM_Odm 
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	PADAPTER	Adapter = pDM_Odm->Adapter;
-	#if( (RTL8192C_SUPPORT==1) ||  (RTL8723A_SUPPORT==1) )
-	if(IS_HARDWARE_TYPE_8192C(Adapter)){
-		rtl8192c_odm_CheckTXPowerTracking(Adapter);
-		return;
-	}
-	#endif
-
-	#if (RTL8192D_SUPPORT==1) 
-	if(IS_HARDWARE_TYPE_8192D(Adapter)){	
-		#if (RTL8192D_EASY_SMART_CONCURRENT == 1)
-		if(!Adapter->bSlaveOfDMSP)
-		#endif
-			rtl8192d_odm_CheckTXPowerTracking(Adapter);
-		return;	
-	}
-	#endif
-
-	#if(((RTL8188E_SUPPORT==1) ||  (RTL8812A_SUPPORT==1) ||  (RTL8821A_SUPPORT==1) ||  (RTL8192E_SUPPORT==1)  ||  (RTL8723B_SUPPORT==1)  ))
-	if(!(pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK))
-	{
-		return;
-	}
-
-	if(!pDM_Odm->RFCalibrateInfo.TM_Trigger)		//at least delay 1 sec
-	{
-		//pHalData->TxPowerCheckCnt++;	//cosa add for debug
-		if(IS_HARDWARE_TYPE_8188E(Adapter) || IS_HARDWARE_TYPE_JAGUAR(Adapter) || IS_HARDWARE_TYPE_8192E(Adapter)||IS_HARDWARE_TYPE_8723B(Adapter))
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_T_METER_NEW, (BIT17 | BIT16), 0x03);
-		else
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_T_METER_OLD, bRFRegOffsetMask, 0x60);
-		
-		//DBG_871X("Trigger Thermal Meter!!\n");
-		
-		pDM_Odm->RFCalibrateInfo.TM_Trigger = 1;
-		return;
-	}
-	else
-	{
-		//DBG_871X("Schedule TxPowerTracking direct call!!\n");
-		ODM_TXPowerTrackingCallback_ThermalMeter(Adapter);
-		pDM_Odm->RFCalibrateInfo.TM_Trigger = 0;
-	}
-	#endif
-#endif	
-}
-
-VOID
-odm_TXPowerTrackingCheckMP(
-	IN		PDM_ODM_T		pDM_Odm 
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	PADAPTER	Adapter = pDM_Odm->Adapter;
-
-	if (ODM_CheckPowerStatus(Adapter) == FALSE) 
-	{
-		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD, ("===>ODM_CheckPowerStatus() return FALSE\n"));
-		return;
-	}
-
-	if(IS_HARDWARE_TYPE_8723A(Adapter))
-		return;
-
-	if(!Adapter->bSlaveOfDMSP || Adapter->DualMacSmartConcurrent == FALSE)
-		odm_TXPowerTrackingThermalMeterCheck(Adapter);
-	else {
-		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD, ("!Adapter->bSlaveOfDMSP || Adapter->DualMacSmartConcurrent == FALSE\n"));
-	}
-#endif
-	
-}
-
-
-VOID
-odm_TXPowerTrackingCheckAP(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
-	prtl8192cd_priv	priv		= pDM_Odm->priv;
-
-	if ( (priv->pmib->dot11RFEntry.ther) && ((priv->up_time % priv->pshare->rf_ft_var.tpt_period) == 0)){
-#ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D){
-			tx_power_tracking_92D(priv);
-		} else 
-#endif
-		{
-#ifdef CONFIG_RTL_92C_SUPPORT			
-			tx_power_tracking(priv);
-#endif
-		}
-	}
-#endif	
-
-}
-
-
-
-//antenna mapping info
-// 1: right-side antenna
-// 2/0: left-side antenna
-//PDM_SWAT_Table->CCK_Ant1_Cnt /OFDM_Ant1_Cnt:  for right-side antenna:   Ant:1    RxDefaultAnt1
-//PDM_SWAT_Table->CCK_Ant2_Cnt /OFDM_Ant2_Cnt:  for left-side antenna:     Ant:0    RxDefaultAnt2
-// We select left antenna as default antenna in initial process, modify it as needed
-//
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-VOID
-odm_TXPowerTrackingThermalMeterCheck(
-	IN	PADAPTER		Adapter
-	)
-{
-#ifndef AP_BUILD_WORKAROUND
-	static u1Byte			TM_Trigger = 0;
-
-	if(!(GET_HAL_DATA(Adapter)->DM_OutSrc.SupportAbility & ODM_RF_TX_PWR_TRACK))
-	{
-		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,
-			("===>odm_TXPowerTrackingThermalMeterCheck(),pMgntInfo->bTXPowerTracking is FALSE, return!!\n"));
-		return;
-	}
-
-	if(!TM_Trigger)		//at least delay 1 sec
-	{
-		if(IS_HARDWARE_TYPE_8192D(Adapter))
-			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER_92D, BIT17 | BIT16, 0x03);
-		else if(IS_HARDWARE_TYPE_8188E(Adapter) || IS_HARDWARE_TYPE_JAGUAR(Adapter) || IS_HARDWARE_TYPE_8192E(Adapter) ||
-			    IS_HARDWARE_TYPE_8723B(Adapter))
-			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER_88E, BIT17 | BIT16, 0x03);
-		else
-			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
-		
-		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Trigger Thermal Meter!!\n"));
-		
-		TM_Trigger = 1;
-		return;
-	}
-	else
-	{
-		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Schedule TxPowerTracking direct call!!\n"));		
-		odm_TXPowerTrackingDirectCall(Adapter); //Using direct call is instead, added by Roger, 2009.06.18.
-		TM_Trigger = 0;
-	}
-#endif
-}
-
-// Only for 8723A SW ANT DIV INIT--2012--07--17
-VOID
-odm_SwAntDivInit_NIC_8723A(
-	IN	PDM_ODM_T		pDM_Odm)
-{
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	
-	u1Byte 			btAntNum=BT_GetPgAntNum(Adapter);
-
-	if(IS_HARDWARE_TYPE_8723A(Adapter))
-	{
-		pDM_SWAT_Table->ANTA_ON =TRUE;
-		
-		// Set default antenna B status by PG
-		if(btAntNum == 2)
-			pDM_SWAT_Table->ANTB_ON = TRUE;
-		else if(btAntNum == 1)
-			pDM_SWAT_Table->ANTB_ON = FALSE;
-		else
-			pDM_SWAT_Table->ANTB_ON = TRUE;
-	}	
-	
-}
-
-#endif //end #ifMP
-
-
-
-//3============================================================
-//3 SW Antenna Diversity
-//3============================================================
-#if(defined(CONFIG_SW_ANTENNA_DIVERSITY))
-VOID
-odm_SwAntDivInit(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
-	odm_SwAntDivInit_NIC(pDM_Odm);
-#elif(DM_ODM_SUPPORT_TYPE == ODM_AP)
-	dm_SW_AntennaSwitchInit(pDM_Odm->priv);
-#endif
-}
-
-VOID
-odm_SwAntDivInit_NIC(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-
-
-// Init SW ANT DIV mechanism for 8723AE/AU/AS
-// Neil Chen--2012--07--17---
-// CE/AP/ADSL no using SW ANT DIV for 8723A Series IC
-//#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)
-#if (RTL8723A_SUPPORT==1) 
-	if(pDM_Odm->SupportICType == ODM_RTL8723A)
-	{
-		odm_SwAntDivInit_NIC_8723A(pDM_Odm);	
-	}	
-#endif
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS:Init SW Antenna Switch\n"));
-	pDM_SWAT_Table->RSSI_sum_A = 0;
-	pDM_SWAT_Table->RSSI_cnt_A = 0;
-	pDM_SWAT_Table->RSSI_sum_B = 0;
-	pDM_SWAT_Table->RSSI_cnt_B = 0;
-	pDM_SWAT_Table->CurAntenna = MAIN_ANT;
-	pDM_SWAT_Table->PreAntenna = MAIN_ANT;
-	pDM_SWAT_Table->try_flag = 0xff;
-	pDM_SWAT_Table->PreRSSI = 0;
-	pDM_SWAT_Table->SWAS_NoLink_State = 0;
-	pDM_SWAT_Table->bTriggerAntennaSwitch = 0;
-	pDM_SWAT_Table->SelectAntennaMap=0xAA;
-	pDM_SWAT_Table->lastTxOkCnt = 0;
-	pDM_SWAT_Table->lastRxOkCnt = 0;
-	pDM_SWAT_Table->TXByteCnt_A = 0;
-	pDM_SWAT_Table->TXByteCnt_B = 0;
-	pDM_SWAT_Table->RXByteCnt_A = 0;
-	pDM_SWAT_Table->RXByteCnt_B = 0;
-	pDM_SWAT_Table->TrafficLoad = TRAFFIC_LOW;
-	pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ODM_Read4Byte(pDM_Odm, 0x860);
-	
-}
-
-//
-// 20100514 Joseph: 
-// Add new function to reset the state of antenna diversity before link.
-//
-VOID
-ODM_SwAntDivResetBeforeLink(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-
-	pDM_SWAT_Table->SWAS_NoLink_State = 0;
-
-}
-
-//
-// 20100514 Luke/Joseph:
-// Add new function to reset antenna diversity state after link.
-//
-VOID
-ODM_SwAntDivRestAfterLink(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
-	u4Byte             i;
-
-	if(pDM_Odm->SupportICType == ODM_RTL8723A)
-	{
-	    pDM_SWAT_Table->RSSI_cnt_A = 0;
-	    pDM_SWAT_Table->RSSI_cnt_B = 0;
-	    pDM_Odm->RSSI_test = FALSE;
-	    pDM_SWAT_Table->try_flag = 0xff;
-	    pDM_SWAT_Table->RSSI_Trying = 0;
-	    pDM_SWAT_Table->SelectAntennaMap=0xAA;
-	
-	}
-	else if(pDM_Odm->SupportICType & (ODM_RTL8723B|ODM_RTL8821))
-	{
-		pDM_Odm->RSSI_test = FALSE;
-		pDM_SWAT_Table->try_flag = 0xff;
-		pDM_SWAT_Table->RSSI_Trying = 0;
-		pDM_SWAT_Table->Double_chk_flag= 0;
-		
-		pDM_FatTable->RxIdleAnt=MAIN_ANT;
-		
-		for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
-		{
-			pDM_FatTable->MainAnt_Sum[i] = 0;
-			pDM_FatTable->AuxAnt_Sum[i] = 0;
-			pDM_FatTable->MainAnt_Cnt[i] = 0;
-			pDM_FatTable->AuxAnt_Cnt[i] = 0;
-		}
-
-	}
-}
-
-void
-odm_SwAntDetectInit(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-#if (RTL8723B_SUPPORT == 1)
-	pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c = ODM_Read4Byte(pDM_Odm, rDPDT_control);
-#endif
-	pDM_SWAT_Table->PreAntenna = MAIN_ANT;
-	pDM_SWAT_Table->CurAntenna = MAIN_ANT;
-	pDM_SWAT_Table->SWAS_NoLink_State = 0;
-}
-
-VOID
-ODM_SwAntDivChkPerPktRssi(
-	IN PDM_ODM_T	pDM_Odm,
-	IN u1Byte		StationID,
-	IN PODM_PHY_INFO_T pPhyInfo
-	)
-{	
-	SWAT_T		*pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	
-	if(!(pDM_Odm->SupportAbility & (ODM_BB_ANT_DIV)))
-		return;
-
-// temporary Fix 8723A MP SW ANT DIV Bug --NeilChen--2012--07--11
-#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)
-	if(pDM_Odm->SupportICType == ODM_RTL8723A)
-	{
-		//if(StationID == pDM_SWAT_Table->RSSI_target)
-		//{
-		//1 RSSI for SW Antenna Switch
-		if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-		{
-			pDM_SWAT_Table->RSSI_sum_A += pPhyInfo->RxPWDBAll;
-			pDM_SWAT_Table->RSSI_cnt_A++;
-		}
-		else
-		{
-			pDM_SWAT_Table->RSSI_sum_B += pPhyInfo->RxPWDBAll;
-			pDM_SWAT_Table->RSSI_cnt_B++;
-
-		}
-		//}
-	}
-	else
-	{
-		if(StationID == pDM_SWAT_Table->RSSI_target)
-		{
-			//1 RSSI for SW Antenna Switch
-			if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-			{
-				pDM_SWAT_Table->RSSI_sum_A += pPhyInfo->RxPWDBAll;
-				pDM_SWAT_Table->RSSI_cnt_A++;
-			}
-			else
-			{
-				pDM_SWAT_Table->RSSI_sum_B += pPhyInfo->RxPWDBAll;
-				pDM_SWAT_Table->RSSI_cnt_B++;
-
-			}
-		}
-	}
-#else	
-	if(StationID == pDM_SWAT_Table->RSSI_target)
-	{
-		//1 RSSI for SW Antenna Switch
-		if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-		{
-			pDM_SWAT_Table->RSSI_sum_A += pPhyInfo->RxPWDBAll;
-			pDM_SWAT_Table->RSSI_cnt_A++;
-		}
-		else
-		{
-			pDM_SWAT_Table->RSSI_sum_B += pPhyInfo->RxPWDBAll;
-			pDM_SWAT_Table->RSSI_cnt_B++;
-
-		}
-	}
-#endif
-}
-
-//
-VOID
-odm_SwAntDivChkAntSwitch(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			Step
-	)
-{
-	// 
-	// For AP/ADSL use prtl8192cd_priv
-	// For CE/NIC use PADAPTER
-	//
-	prtl8192cd_priv	priv		= pDM_Odm->priv;
-
-	//
-	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
-	// at the same time. In the stage2/3, we need to prive universal interface and merge all
-	// HW dynamic mechanism.
-	//
-	switch	(pDM_Odm->SupportPlatform)
-	{
-		case	ODM_WIN:	
-			odm_SwAntDivChkAntSwitchNIC(pDM_Odm, Step);
-			break;
-		case	ODM_CE:
-			odm_SwAntDivChkAntSwitchNIC(pDM_Odm, Step);
-			break;
-
-		case	ODM_AP:
-		case	ODM_ADSL:
-#if (DM_ODM_SUPPORT_TYPE & (ODM_AP |ODM_ADSL))
-			if (priv->pshare->rf_ft_var.antSw_enable && (priv->up_time % 4==1))
-				dm_SW_AntennaSwitch(priv, SWAW_STEP_PEAK);
-#endif		
-			break;			
-	}
-
-}
-
-//
-// 20100514 Luke/Joseph:
-// Add new function for antenna diversity after link.
-// This is the main function of antenna diversity after link.
-// This function is called in HalDmWatchDog() and ODM_SwAntDivChkAntSwitchCallback().
-// HalDmWatchDog() calls this function with SWAW_STEP_PEAK to initialize the antenna test.
-// In SWAW_STEP_PEAK, another antenna and a 500ms timer will be set for testing.
-// After 500ms, ODM_SwAntDivChkAntSwitchCallback() calls this function to compare the signal just
-// listened on the air with the RSSI of original antenna.
-// It chooses the antenna with better RSSI.
-// There is also a aged policy for error trying. Each error trying will cost more 5 seconds waiting 
-// penalty to get next try.
-
-
-VOID
-ODM_SetAntenna(
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte		Antenna)
-{
-	ODM_SetBBReg(pDM_Odm, 0x860, BIT8|BIT9, Antenna); 
-}
-
-VOID
-odm_SwAntDivChkAntSwitchNIC(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte		Step
-	)
-{
-#if ((RTL8192C_SUPPORT==1)||(RTL8723A_SUPPORT==1))
-	//PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
-	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
-#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)
-	PADAPTER		Adapter=pDM_Odm->Adapter;
-#endif
-
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	s4Byte			curRSSI=100, RSSI_A, RSSI_B;
-	u1Byte			nextAntenna=AUX_ANT;
-	//static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
-	u8Byte			curTxOkCnt=0, curRxOkCnt=0;
-	//static u8Byte		TXByteCnt_A=0, TXByteCnt_B=0, RXByteCnt_A=0, RXByteCnt_B=0;
-	u8Byte			CurByteCnt=0, PreByteCnt=0;
-	//static u1Byte		TrafficLoad = TRAFFIC_LOW;
-	u1Byte			Score_A=0, Score_B=0;       //A: Main; B: AUX
-	u1Byte			i;
-
-	if(!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
-		return;
-
-	if (pDM_Odm->SupportICType & (ODM_RTL8192D|ODM_RTL8188E))
-		return;
-
-	if((pDM_Odm->SupportICType == ODM_RTL8192C) &&(pDM_Odm->RFType == ODM_2T2R))
-		return;
-
-	if(pDM_Odm->SupportPlatform & ODM_WIN)
-	{
-		if(*(pDM_Odm->pAntennaTest))
-			return;
-	}
-
-	if((pDM_SWAT_Table->ANTA_ON == FALSE) ||(pDM_SWAT_Table->ANTB_ON == FALSE))
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,
-				("odm_SwAntDivChkAntSwitch(): No AntDiv Mechanism, Antenna A or B is off\n"));
-		return;
-	}
-
-	// Radio off: Status reset to default and return.
-	if(*(pDM_Odm->pbPowerSaving)==TRUE) //pHalData->eRFPowerState==eRfOff
-	{
-		ODM_SwAntDivRestAfterLink(pDM_Odm);
-		return;
-	}
-
-
-	// Handling step mismatch condition.
-	// Peak step is not finished at last time. Recover the variable and check again.
-	if(	Step != pDM_SWAT_Table->try_flag	)
-	{
-		ODM_SwAntDivRestAfterLink(pDM_Odm);
-	}
-
-#if  (DM_ODM_SUPPORT_TYPE &( ODM_WIN| ODM_CE ))
-
-	if(pDM_SWAT_Table->try_flag == 0xff)
-	{
-		pDM_SWAT_Table->RSSI_target = 0xff;
-		
-		#if(DM_ODM_SUPPORT_TYPE & ODM_CE)
-		{
-			u1Byte			index = 0;
-			PSTA_INFO_T		pEntry = NULL;
-			
-			
-			for(index=0; index<ODM_ASSOCIATE_ENTRY_NUM; index++)
-			{					
-				pEntry =  pDM_Odm->pODM_StaInfo[index];
-				if(IS_STA_VALID(pEntry) ) {
-					break;
-				}
-			}
-			if(pEntry == NULL)
-			{
-				ODM_SwAntDivRestAfterLink(pDM_Odm);
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): No Link.\n"));
-				return;
-			}
-			else
-			{
-				pDM_SWAT_Table->RSSI_target = index;
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): RSSI_target is PEER STA\n"));
-			}
-                }
-		#elif (DM_ODM_SUPPORT_TYPE & ODM_WIN) 
-		{
-			PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
-			PMGNT_INFO	pMgntInfo=&pAdapter->MgntInfo;
-			
-			// Select RSSI checking target
-			if(pMgntInfo->mAssoc && !ACTING_AS_AP(pAdapter))
-			{
-				// Target: Infrastructure mode AP.
-				//pDM_SWAT_Table->RSSI_target = NULL;
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("odm_SwAntDivChkAntSwitch(): RSSI_target is DEF AP!\n"));
-			}
-			else
-			{
-				u1Byte			index = 0;
-				PSTA_INFO_T		pEntry = NULL;
-				PADAPTER		pTargetAdapter = NULL;
-			
-				if(pMgntInfo->mIbss )
-				{
-					// Target: AP/IBSS peer.
-					pTargetAdapter = pAdapter;
-				}
-				else
-				{
-					pTargetAdapter = GetFirstAPAdapter(pAdapter);
-				}
-
-				if(pTargetAdapter != NULL)
-				{			
-					for(index=0; index<ODM_ASSOCIATE_ENTRY_NUM; index++)
-					{					
-						
-						pEntry = AsocEntry_EnumStation(pTargetAdapter, index);
-						if(pEntry != NULL)
-						{
-							if(pEntry->bAssociated)
-								break;			
-						}
-						
-					}
-					
-				}
-
-				if(pEntry == NULL)
-				{
-					ODM_SwAntDivRestAfterLink(pDM_Odm);
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): No Link.\n"));
-					return;
-				}
-				else
-				{
-					//pDM_SWAT_Table->RSSI_target = pEntry;
-					pDM_SWAT_Table->RSSI_target = index;
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): RSSI_target is PEER STA\n"));
-				}
-			}//end if(pMgntInfo->mAssoc && !ACTING_AS_AP(Adapter))
-
-		}
-		#endif
-
-		pDM_SWAT_Table->RSSI_cnt_A = 0;
-		pDM_SWAT_Table->RSSI_cnt_B = 0;
-		pDM_SWAT_Table->try_flag = 0;
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("odm_SwAntDivChkAntSwitch(): Set try_flag to 0 prepare for peak!\n"));
-		return;
-	}
-	else
-	{
-
-// To Fix 8723A SW ANT DIV Bug issue
-#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)
-		if (pDM_Odm->SupportICType & ODM_RTL8723A)
-		{
-			curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - pDM_SWAT_Table->lastTxOkCnt;
-			curRxOkCnt =Adapter->RxStats.NumRxBytesUnicast - pDM_SWAT_Table->lastRxOkCnt;
-			pDM_SWAT_Table->lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
-			pDM_SWAT_Table->lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
-		}
-#else	
-		curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast) - pDM_SWAT_Table->lastTxOkCnt;
-		curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast) - pDM_SWAT_Table->lastRxOkCnt;
-		pDM_SWAT_Table->lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
-		pDM_SWAT_Table->lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);
-#endif	
-		if(pDM_SWAT_Table->try_flag == 1)
-		{
-			if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-			{
-				pDM_SWAT_Table->TXByteCnt_A += curTxOkCnt;
-				pDM_SWAT_Table->RXByteCnt_A += curRxOkCnt;
-			}
-			else
-			{
-				pDM_SWAT_Table->TXByteCnt_B += curTxOkCnt;
-				pDM_SWAT_Table->RXByteCnt_B += curRxOkCnt;
-			}
-		
-			nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? AUX_ANT : MAIN_ANT;
-			pDM_SWAT_Table->RSSI_Trying--;
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("RSSI_Trying = %d\n",pDM_SWAT_Table->RSSI_Trying));
-			if(pDM_SWAT_Table->RSSI_Trying == 0)
-			{
-				CurByteCnt = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? (pDM_SWAT_Table->TXByteCnt_A+pDM_SWAT_Table->RXByteCnt_A) : (pDM_SWAT_Table->TXByteCnt_B+pDM_SWAT_Table->RXByteCnt_B);
-				PreByteCnt = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? (pDM_SWAT_Table->TXByteCnt_B+pDM_SWAT_Table->RXByteCnt_B) : (pDM_SWAT_Table->TXByteCnt_A+pDM_SWAT_Table->RXByteCnt_A);
-				
-				if(pDM_SWAT_Table->TrafficLoad == TRAFFIC_HIGH)
-					//CurByteCnt = PlatformDivision64(CurByteCnt, 9);
-					PreByteCnt = PreByteCnt*9;
-				else if(pDM_SWAT_Table->TrafficLoad == TRAFFIC_LOW)
-					//CurByteCnt = PlatformDivision64(CurByteCnt, 2);
-					PreByteCnt = PreByteCnt*2;
-
-				if(pDM_SWAT_Table->RSSI_cnt_A > 0)
-					RSSI_A = pDM_SWAT_Table->RSSI_sum_A/pDM_SWAT_Table->RSSI_cnt_A; 
-				else
-					RSSI_A = 0;
-				if(pDM_SWAT_Table->RSSI_cnt_B > 0)
-					RSSI_B = pDM_SWAT_Table->RSSI_sum_B/pDM_SWAT_Table->RSSI_cnt_B; 
-				else
-					RSSI_B = 0;
-				curRSSI = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
-				pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_B : RSSI_A;
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Luke:PreRSSI = %d, CurRSSI = %d\n",pDM_SWAT_Table->PreRSSI, curRSSI));
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: preAntenna= %s, curAntenna= %s \n", 
-				(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Luke:RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
-					RSSI_A, pDM_SWAT_Table->RSSI_cnt_A, RSSI_B, pDM_SWAT_Table->RSSI_cnt_B));
-			}
-
-		}
-		else
-		{
-		
-			if(pDM_SWAT_Table->RSSI_cnt_A > 0)
-				RSSI_A = pDM_SWAT_Table->RSSI_sum_A/pDM_SWAT_Table->RSSI_cnt_A; 
-			else
-				RSSI_A = 0;
-			if(pDM_SWAT_Table->RSSI_cnt_B > 0)
-				RSSI_B = pDM_SWAT_Table->RSSI_sum_B/pDM_SWAT_Table->RSSI_cnt_B; 
-			else
-				RSSI_B = 0;
-			curRSSI = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
-			pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->PreAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Ekul:PreRSSI = %d, CurRSSI = %d\n", pDM_SWAT_Table->PreRSSI, curRSSI));
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: preAntenna= %s, curAntenna= %s \n", 
-			(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
-
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Ekul:RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
-				RSSI_A, pDM_SWAT_Table->RSSI_cnt_A, RSSI_B, pDM_SWAT_Table->RSSI_cnt_B));
-			//RT_TRACE(COMP_SWAS, DBG_LOUD, ("Ekul:curTxOkCnt = %d\n", curTxOkCnt));
-			//RT_TRACE(COMP_SWAS, DBG_LOUD, ("Ekul:curRxOkCnt = %d\n", curRxOkCnt));
-		}
-
-		//1 Trying State
-		if((pDM_SWAT_Table->try_flag == 1)&&(pDM_SWAT_Table->RSSI_Trying == 0))
-		{
-
-			if(pDM_SWAT_Table->TestMode == TP_MODE)
-			{
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: TestMode = TP_MODE"));
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("TRY:CurByteCnt = %lld,", CurByteCnt));
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("TRY:PreByteCnt = %lld\n",PreByteCnt));		
-				if(CurByteCnt < PreByteCnt)
-				{
-					if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
-					else
-						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
-				}
-				else
-				{
-					if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
-					else
-						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
-				}
-				for (i= 0; i<8; i++)
-				{
-					if(((pDM_SWAT_Table->SelectAntennaMap>>i)&BIT0) == 1)
-						Score_A++;
-					else
-						Score_B++;
-				}
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SelectAntennaMap=%x\n ",pDM_SWAT_Table->SelectAntennaMap));
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Score_A=%d, Score_B=%d\n", Score_A, Score_B));
-			
-				if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-				{
-					nextAntenna = (Score_A > Score_B)?MAIN_ANT:AUX_ANT;
-				}
-				else
-				{
-					nextAntenna = (Score_B > Score_A)?AUX_ANT:MAIN_ANT;
-				}
-				//RT_TRACE(COMP_SWAS, DBG_LOUD, ("nextAntenna=%s\n",(nextAntenna==Antenna_A)?"A":"B"));
-				//RT_TRACE(COMP_SWAS, DBG_LOUD, ("preAntenna= %s, curAntenna= %s \n", 
-				//(DM_SWAT_Table.PreAntenna == Antenna_A?"A":"B"), (DM_SWAT_Table.CurAntenna == Antenna_A?"A":"B")));
-
-				if(nextAntenna != pDM_SWAT_Table->CurAntenna)
-				{
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: Switch back to another antenna"));
-				}
-				else
-				{
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: current anntena is good\n"));
-				}	
-			}
-
-			if(pDM_SWAT_Table->TestMode == RSSI_MODE)
-			{	
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: TestMode = RSSI_MODE"));
-				pDM_SWAT_Table->SelectAntennaMap=0xAA;
-				if(curRSSI < pDM_SWAT_Table->PreRSSI) //Current antenna is worse than previous antenna
-				{
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: Switch back to another antenna"));
-					nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? AUX_ANT : MAIN_ANT;
-				}
-				else // current anntena is good
-				{
-					nextAntenna =pDM_SWAT_Table->CurAntenna;
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: current anntena is good\n"));
-				}
-			}
-			pDM_SWAT_Table->try_flag = 0;
-			pDM_Odm->RSSI_test = FALSE;
-			pDM_SWAT_Table->RSSI_sum_A = 0;
-			pDM_SWAT_Table->RSSI_cnt_A = 0;
-			pDM_SWAT_Table->RSSI_sum_B = 0;
-			pDM_SWAT_Table->RSSI_cnt_B = 0;
-			pDM_SWAT_Table->TXByteCnt_A = 0;
-			pDM_SWAT_Table->TXByteCnt_B = 0;
-			pDM_SWAT_Table->RXByteCnt_A = 0;
-			pDM_SWAT_Table->RXByteCnt_B = 0;
-			
-		}
-
-		//1 Normal State
-		else if(pDM_SWAT_Table->try_flag == 0)
-		{
-			if(pDM_SWAT_Table->TrafficLoad == TRAFFIC_HIGH)
-			{
-				if ((curTxOkCnt+curRxOkCnt) > 3750000)//if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)
-					pDM_SWAT_Table->TrafficLoad = TRAFFIC_HIGH;
-				else
-					pDM_SWAT_Table->TrafficLoad = TRAFFIC_LOW;
-			}
-			else if(pDM_SWAT_Table->TrafficLoad == TRAFFIC_LOW)
-				{
-				if ((curTxOkCnt+curRxOkCnt) > 3750000) //if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)
-					pDM_SWAT_Table->TrafficLoad = TRAFFIC_HIGH;
-				else
-					pDM_SWAT_Table->TrafficLoad = TRAFFIC_LOW;
-			}
-			if(pDM_SWAT_Table->TrafficLoad == TRAFFIC_HIGH)
-				pDM_SWAT_Table->bTriggerAntennaSwitch = 0;
-			//RT_TRACE(COMP_SWAS, DBG_LOUD, ("Normal:TrafficLoad = %llu\n", curTxOkCnt+curRxOkCnt));
-
-			//Prepare To Try Antenna		
-					nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? AUX_ANT : MAIN_ANT;
-					pDM_SWAT_Table->try_flag = 1;
-					pDM_Odm->RSSI_test = TRUE;
-			if((curRxOkCnt+curTxOkCnt) > 1000)
-			{
-				pDM_SWAT_Table->RSSI_Trying = 4;
-				pDM_SWAT_Table->TestMode = TP_MODE;
-				}
-				else
-				{
-				pDM_SWAT_Table->RSSI_Trying = 2;
-				pDM_SWAT_Table->TestMode = RSSI_MODE;
-
-			}
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: Normal State -> Begin Trying!\n"));
-			
-			
-			pDM_SWAT_Table->RSSI_sum_A = 0;
-			pDM_SWAT_Table->RSSI_cnt_A = 0;
-			pDM_SWAT_Table->RSSI_sum_B = 0;
-			pDM_SWAT_Table->RSSI_cnt_B = 0;
-		}
-	}
-
-	//1 4.Change TRX antenna
-	if(nextAntenna != pDM_SWAT_Table->CurAntenna)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SWAS: Change TX Antenna!\n "));
-		//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, nextAntenna);		
-		#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)			
-		ODM_SetAntenna(pDM_Odm,nextAntenna);		
-		#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-		{
-			BOOLEAN bEnqueue;			
-			bEnqueue = (pDM_Odm->SupportInterface ==  ODM_ITRF_PCIE)?FALSE :TRUE;			
-			rtw_antenna_select_cmd(pDM_Odm->Adapter, nextAntenna, bEnqueue);
-		}
-		#endif
-		
-	}
-
-	//1 5.Reset Statistics
-	pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
-	pDM_SWAT_Table->CurAntenna = nextAntenna;
-	pDM_SWAT_Table->PreRSSI = curRSSI;
-
-	//1 6.Set next timer
-	{
-		//PADAPTER		pAdapter = pDM_Odm->Adapter;
-		//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	
-
-	if(pDM_SWAT_Table->RSSI_Trying == 0)
-		return;
-
-	if(pDM_SWAT_Table->RSSI_Trying%2 == 0)
-	{
-		if(pDM_SWAT_Table->TestMode == TP_MODE)
-		{
-			if(pDM_SWAT_Table->TrafficLoad == TRAFFIC_HIGH)
-			{
-				ODM_SetTimer(pDM_Odm,&pDM_SWAT_Table->SwAntennaSwitchTimer, 10 ); //ms
-				
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("dm_SW_AntennaSwitch(): Test another antenna for 10 ms\n"));
-			}
-			else if(pDM_SWAT_Table->TrafficLoad == TRAFFIC_LOW)
-			{
-				ODM_SetTimer(pDM_Odm,&pDM_SWAT_Table->SwAntennaSwitchTimer, 50 ); //ms
-				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("dm_SW_AntennaSwitch(): Test another antenna for 50 ms\n"));
-			}
-		}
-		else
-		{
-			ODM_SetTimer(pDM_Odm,&pDM_SWAT_Table->SwAntennaSwitchTimer, 500 ); //ms
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("dm_SW_AntennaSwitch(): Test another antenna for 500 ms\n"));
-		}
-	}
-	else
-	{
-		if(pDM_SWAT_Table->TestMode == TP_MODE)
-		{
-			if(pDM_SWAT_Table->TrafficLoad == TRAFFIC_HIGH)
-				ODM_SetTimer(pDM_Odm,&pDM_SWAT_Table->SwAntennaSwitchTimer, 90 ); //ms
-			else if(pDM_SWAT_Table->TrafficLoad == TRAFFIC_LOW)
-				ODM_SetTimer(pDM_Odm,&pDM_SWAT_Table->SwAntennaSwitchTimer, 100 ); //ms
-		}
-		else
-			ODM_SetTimer(pDM_Odm,&pDM_SWAT_Table->SwAntennaSwitchTimer, 500 ); //ms 
-	}
-	}
-#endif	// #if (DM_ODM_SUPPORT_TYPE  & (ODM_WIN|ODM_CE))
-#endif	// #if (RTL8192C_SUPPORT==1) 
-}
-
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-u1Byte
-odm_SwAntDivSelectScanChnl(
-	IN	PADAPTER	Adapter
-	)
-{
-#if (RT_MEM_SIZE_LEVEL != RT_MEM_SIZE_MINIMUM)
-	PHAL_DATA_TYPE		pHalData = GET_HAL_DATA(Adapter);
-	PMGNT_INFO			pMgntInfo = &(Adapter->MgntInfo);
-	PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
-	u1Byte 				i, j, ScanChannel = 0, ChannelNum = 0;
-	PRT_CHANNEL_LIST	pChannelList = GET_RT_CHANNEL_LIST(pMgntInfo);
-	u1Byte 				EachChannelSTAs[MAX_SCAN_CHANNEL_NUM] = {0};
-
-	if(pMgntInfo->tmpNumBssDesc == 0)
-		return 0;
-
-	for(i = 0; i < pMgntInfo->tmpNumBssDesc; i++)
-	{		
-		ChannelNum = pMgntInfo->tmpbssDesc[i].ChannelNumber;
-		for(j = 0; j < pChannelList->ChannelLen; j++)
-		{
-			if(pChannelList->ChnlListEntry[j].ChannelNum == ChannelNum)
-			{
-				EachChannelSTAs[j]++;
-				break;
-			}
-		}
-	}
-	
-	for(i = 0; i < MAX_SCAN_CHANNEL_NUM; i++)
-		{
-		if(EachChannelSTAs[i] > EachChannelSTAs[ScanChannel])
-			ScanChannel = i;
-		}
-
-	if(EachChannelSTAs[ScanChannel] == 0)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("odm_SwAntDivSelectScanChnl(): Scan List is empty.\n"));
-		return 0;
-	}
-	
-	ScanChannel = pChannelList->ChnlListEntry[ScanChannel].ChannelNum;
-
-	
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, 
-		("odm_SwAntDivSelectScanChnl(): Channel %d is select as scan channel.\n", ScanChannel));
-
-	return ScanChannel;
-#else
-	return	0;
-#endif	
-}
-
-
-VOID
-odm_SwAntDivConstructScanChnl(
-	IN	PADAPTER	Adapter,
-	IN	u1Byte		ScanChnl
-	)
-{
-
-	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
-
-	if(ScanChnl == 0)
-	{
-		u1Byte				i;		
-		PRT_CHANNEL_LIST	pChannelList = GET_RT_CHANNEL_LIST(pMgntInfo);
-	
-		// 20100519 Joseph: Original antenna scanned nothing. 
-		// Test antenna shall scan all channel with half period in this condition.
-		RtActChannelList(Adapter, RT_CHNL_LIST_ACTION_CONSTRUCT_SCAN_LIST, NULL, NULL);
-		for(i = 0; i < pChannelList->ChannelLen; i++)
-			pChannelList->ChnlListEntry[i].ScanPeriod /= 2;
-	}
-	else
-	{
-		// The using of this CustomizedScanRequest is a trick to rescan the two channels 
-		//	under the NORMAL scanning process. It will not affect MGNT_INFO.CustomizedScanRequest.
-		CUSTOMIZED_SCAN_REQUEST CustomScanReq;
-
-		CustomScanReq.bEnabled = TRUE;
-		CustomScanReq.Channels[0] = ScanChnl;
-		CustomScanReq.Channels[1] = pMgntInfo->dot11CurrentChannelNumber;
-		CustomScanReq.nChannels = 2;
-		CustomScanReq.ScanType = SCAN_ACTIVE;
-		CustomScanReq.Duration = DEFAULT_PASSIVE_SCAN_PERIOD;
-
-		RtActChannelList(Adapter, RT_CHNL_LIST_ACTION_CONSTRUCT_SCAN_LIST, &CustomScanReq, NULL);
-	}
-
-}
-#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-//
-// 20100514 Luke/Joseph:
-// Callback function for 500ms antenna test trying.
-//
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID
-odm_SwAntDivChkAntSwitchCallback(
-	PRT_TIMER		pTimer
-)
-{
-	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	pSWAT_T		pDM_SWAT_Table = &pHalData->DM_OutSrc.DM_SWAT_Table;
-
-	#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-	#if USE_WORKITEM
-	ODM_ScheduleWorkItem(&pDM_SWAT_Table->SwAntennaSwitchWorkitem);
-	#else
-	odm_SwAntDivChkAntSwitch(&pHalData->DM_OutSrc, SWAW_STEP_DETERMINE);
-	#endif
-	#else
-	ODM_ScheduleWorkItem(&pDM_SWAT_Table->SwAntennaSwitchWorkitem);
-	#endif
-	
-}
-VOID
-odm_SwAntDivChkAntSwitchWorkitemCallback(
-    IN PVOID            pContext
-    )
-{
-
-	PADAPTER		pAdapter = (PADAPTER)pContext;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-
-	odm_SwAntDivChkAntSwitch(&pHalData->DM_OutSrc, SWAW_STEP_DETERMINE);
-
-}
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-VOID odm_SwAntDivChkAntSwitchCallback(void *FunctionContext)
-{
-	PDM_ODM_T	pDM_Odm= (PDM_ODM_T)FunctionContext;
-	PADAPTER	padapter = pDM_Odm->Adapter;
-	if(padapter->net_closed == _TRUE)
-	    return;
-	odm_SwAntDivChkAntSwitch(pDM_Odm, SWAW_STEP_DETERMINE);	
-}
-#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-VOID odm_SwAntDivChkAntSwitchCallback(void *FunctionContext)
-{
-	PDM_ODM_T	pDM_Odm= (PDM_ODM_T)FunctionContext;
-	odm_SwAntDivChkAntSwitch(pDM_Odm, SWAW_STEP_DETERMINE);
-}
-#endif
-
-#else //#if(defined(CONFIG_SW_ANTENNA_DIVERSITY))
-
-VOID odm_SwAntDivInit(	IN		PDM_ODM_T		pDM_Odm	) {}
-VOID ODM_SwAntDivChkPerPktRssi(
-	IN PDM_ODM_T	pDM_Odm,
-	IN u1Byte		StationID,
-	IN PODM_PHY_INFO_T pPhyInfo
-	) {}
-VOID odm_SwAntDivChkAntSwitch(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			Step
-	) {}
-VOID ODM_SwAntDivResetBeforeLink(	IN		PDM_ODM_T		pDM_Odm	){}
-VOID ODM_SwAntDivRestAfterLink(	IN		PDM_ODM_T		pDM_Odm	){}
-VOID odm_SwAntDetectInit(	IN		PDM_ODM_T		pDM_Odm){}
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID odm_SwAntDivChkAntSwitchCallback(	PRT_TIMER		pTimer){}
-VOID odm_SwAntDivChkAntSwitchWorkitemCallback(    IN PVOID            pContext    ){}
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-VOID odm_SwAntDivChkAntSwitchCallback(void *FunctionContext){}
-#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-VOID odm_SwAntDivChkAntSwitchCallback(void *FunctionContext){}
-#endif
-
-#endif //#if(defined(CONFIG_SW_ANTENNA_DIVERSITY))
-
-
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-BOOLEAN
-ODM_SwAntDivCheckBeforeLink(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-
-#if (RT_MEM_SIZE_LEVEL != RT_MEM_SIZE_MINIMUM)
-
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(Adapter);
-	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
-	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
-	s1Byte			Score = 0;
-	PRT_WLAN_BSS	pTmpBssDesc, pTestBssDesc;
-	s4Byte 			power_diff = 0, power_target = 10;
-	u1Byte			index, counter = 0;
-	static u1Byte		ScanChannel;
-	u8Byte			tStamp_diff = 0;		
-
-
-	if (pDM_Odm->Adapter == NULL)  //For BSOD when plug/unplug fast.  //By YJ,120413
-	{	// The ODM structure is not initialized.
-		return FALSE;
-	}
-
-	// Retrieve antenna detection registry info, added by Roger, 2012.11.27.
-	if(!IS_ANT_DETECT_SUPPORT_RSSI(Adapter))
-			return FALSE;
-
-	// Since driver is going to set BB register, it shall check if there is another thread controlling BB/RF.
-	PlatformAcquireSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
-	if(pHalData->eRFPowerState!=eRfOn || pMgntInfo->RFChangeInProgress || pMgntInfo->bMediaConnect)
-	{
-		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
-	
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
-				("ODM_SwAntDivCheckBeforeLink(): RFChangeInProgress(%x), eRFPowerState(%x)\n", 
-				pMgntInfo->RFChangeInProgress, pHalData->eRFPowerState));
-	
-		pDM_SWAT_Table->SWAS_NoLink_State = 0;
-		
-		return FALSE;
-	}
-	else
-	{
-		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("pDM_SWAT_Table->SWAS_NoLink_State = %d\n", pDM_SWAT_Table->SWAS_NoLink_State));
-	//1 Run AntDiv mechanism "Before Link" part.
-	if(pDM_SWAT_Table->SWAS_NoLink_State == 0)
-	{
-		//1 Prepare to do Scan again to check current antenna state.
-
-		// Set check state to next step.
-		pDM_SWAT_Table->SWAS_NoLink_State = 1;
-	
-		// Copy Current Scan list.
-		pMgntInfo->tmpNumBssDesc = pMgntInfo->NumBssDesc;
-		PlatformMoveMemory((PVOID)Adapter->MgntInfo.tmpbssDesc, (PVOID)pMgntInfo->bssDesc, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC);
-		
-		// Go back to scan function again.
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Scan one more time\n"));
-		pMgntInfo->ScanStep=0;
-		pMgntInfo->bScanAntDetect = TRUE;
-		ScanChannel = odm_SwAntDivSelectScanChnl(Adapter);
-
-		
-		if(pDM_Odm->SupportICType & (ODM_RTL8188E|ODM_RTL8821))
-		{
-			if(pDM_FatTable->RxIdleAnt == MAIN_ANT)
-				ODM_UpdateRxIdleAnt(pDM_Odm, AUX_ANT);
-			else
-				ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
-			if(ScanChannel == 0)
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
-					("ODM_SwAntDivCheckBeforeLink(): No AP List Avaiable, Using Ant(%s)\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"AUX_ANT":"MAIN_ANT"));
-
-				if(IS_5G_WIRELESS_MODE(pMgntInfo->dot11CurrentWirelessMode))
-				{
-					pDM_SWAT_Table->Ant5G = pDM_FatTable->RxIdleAnt;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant5G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
-				}
-				else
-				{
-					pDM_SWAT_Table->Ant2G = pDM_FatTable->RxIdleAnt;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant2G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
-				}
-				return FALSE;
-			}
-
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
-				("ODM_SwAntDivCheckBeforeLink: Change to %s for testing.\n", ((pDM_FatTable->RxIdleAnt == MAIN_ANT)?"MAIN_ANT":"AUX_ANT")));
-		}
-		else if(pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8723B))
-		{
-			// Switch Antenna to another one.
-			pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
-			pDM_SWAT_Table->CurAntenna = (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?AUX_ANT:MAIN_ANT;
-			
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
-				("ODM_SwAntDivCheckBeforeLink: Change to Ant(%s) for testing.\n", (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?"MAIN":"AUX"));
-			//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
-			if(pDM_Odm->SupportICType == ODM_RTL8192C)
-			{
-				pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
-				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
-			}
-			else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-			{
-				pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c & 0xfffffffc) | (pDM_SWAT_Table->CurAntenna));
-				ODM_SetBBReg(pDM_Odm,  rfe_ctrl_anta_src, 0xff, 0x77);
-				ODM_SetBBReg(pDM_Odm,  rDPDT_control, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c);
-			}
-		}
-		
-		odm_SwAntDivConstructScanChnl(Adapter, ScanChannel);
-		PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
-
-		return TRUE;
-	}
-	else
-	{
-		//1 ScanComple() is called after antenna swiched.
-		//1 Check scan result and determine which antenna is going
-		//1 to be used.
-
-		for(index = 0; index < pMgntInfo->tmpNumBssDesc; index++)
-		{
-			pTmpBssDesc = &(pMgntInfo->tmpbssDesc[index]); // Antenna 1
-			pTestBssDesc = &(pMgntInfo->bssDesc[index]); // Antenna 2
-
-			if(PlatformCompareMemory(pTestBssDesc->bdBssIdBuf, pTmpBssDesc->bdBssIdBuf, 6)!=0)
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): ERROR!! This shall not happen.\n"));
-				continue;
-			}
-
-			if(pDM_Odm->SupportICType != ODM_RTL8723B)
-			{
-				if(pTmpBssDesc->ChannelNumber == ScanChannel)
-				{
-			if(pTmpBssDesc->RecvSignalPower > pTestBssDesc->RecvSignalPower)
-			{
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Compare scan entry: Score++\n"));
-						RT_PRINT_STR(COMP_SCAN, DBG_WARNING, "GetScanInfo(): new Bss SSID:", pTmpBssDesc->bdSsIdBuf, pTmpBssDesc->bdSsIdLen);
-						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("at ch %d, Original: %d, Test: %d\n\n", pTmpBssDesc->ChannelNumber, pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
-			
-				Score++;
-				PlatformMoveMemory(pTestBssDesc, pTmpBssDesc, sizeof(RT_WLAN_BSS));
-			}
-			else if(pTmpBssDesc->RecvSignalPower < pTestBssDesc->RecvSignalPower)
-			{
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Compare scan entry: Score--\n"));
-						RT_PRINT_STR(COMP_SCAN, DBG_WARNING, "GetScanInfo(): new Bss SSID:", pTmpBssDesc->bdSsIdBuf, pTmpBssDesc->bdSsIdLen);
-						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("at ch %d, Original: %d, Test: %d\n\n", pTmpBssDesc->ChannelNumber, pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
-				Score--;
-			}
-					else
-					{
-						if(pTestBssDesc->bdTstamp - pTmpBssDesc->bdTstamp < 5000)
-						{
-							RT_PRINT_STR(COMP_SCAN, DBG_WARNING, "GetScanInfo(): new Bss SSID:", pTmpBssDesc->bdSsIdBuf, pTmpBssDesc->bdSsIdLen);
-							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("at ch %d, Original: %d, Test: %d\n", pTmpBssDesc->ChannelNumber, pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
-							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("The 2nd Antenna didn't get this AP\n\n"));
-						}
-					}
-				}
-			}
-			else
-			{ 
-				if(pTmpBssDesc->ChannelNumber == ScanChannel)
-				{
-					if(pTmpBssDesc->RecvSignalPower > pTestBssDesc->RecvSignalPower)
-					{
-						counter++;
-						power_diff = power_diff + (pTmpBssDesc->RecvSignalPower - pTestBssDesc->RecvSignalPower); 
-						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
-						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("SSID:"), pTmpBssDesc->bdSsIdBuf);
-						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("BSSID:"), pTmpBssDesc->bdBssIdBuf);
-						PlatformMoveMemory(pTestBssDesc, pTmpBssDesc, sizeof(RT_WLAN_BSS));
-					}
-					else if(pTestBssDesc->RecvSignalPower > pTmpBssDesc->RecvSignalPower)
-					{
-						counter++;
-						power_diff = power_diff + (pTestBssDesc->RecvSignalPower - pTmpBssDesc->RecvSignalPower);
-						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
-						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("SSID:"), pTmpBssDesc->bdSsIdBuf);
-						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("BSSID:"), pTmpBssDesc->bdBssIdBuf)
-					}
-					else if(pTestBssDesc->bdTstamp > pTmpBssDesc->bdTstamp)
-					{
-						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("time_diff: %lld\n", (pTestBssDesc->bdTstamp-pTmpBssDesc->bdTstamp)/1000));
-						if(pTestBssDesc->bdTstamp - pTmpBssDesc->bdTstamp > 5000)
-						{
-							counter++;
-							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
-							ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("SSID:"), pTmpBssDesc->bdSsIdBuf);
-							ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("BSSID:"), pTmpBssDesc->bdBssIdBuf)
-						}
-					}
-				}
-			}
-		}
-
-		if(pDM_Odm->SupportICType == ODM_RTL8723B)
-		{ 
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("counter: %d power_diff: %d\n", counter, power_diff));
-
-			if(counter != 0)
-				power_diff = power_diff / counter;
-
-			if(power_diff <= power_target && counter != 0) 
-				Score++;
-		}
-
-		if(pDM_Odm->SupportICType & (ODM_RTL8188E|ODM_RTL8821))
-		{
-			if(pMgntInfo->NumBssDesc!=0 && Score<0)
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,
-							("ODM_SwAntDivCheckBeforeLink(): Using Ant(%s)\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
-			}
-			else
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
-						("ODM_SwAntDivCheckBeforeLink(): Remain Ant(%s)\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"AUX_ANT":"MAIN_ANT"));
-
-				if(pDM_FatTable->RxIdleAnt == MAIN_ANT)
-					ODM_UpdateRxIdleAnt(pDM_Odm, AUX_ANT);
-				else
-					ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
-			}
-			
-			if(IS_5G_WIRELESS_MODE(pMgntInfo->dot11CurrentWirelessMode))
-			{
-				pDM_SWAT_Table->Ant5G = pDM_FatTable->RxIdleAnt;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant5G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
-			}
-			else
-			{
-				pDM_SWAT_Table->Ant2G = pDM_FatTable->RxIdleAnt;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant2G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
-			}
-		}
-		else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-		{
-			pDM_SWAT_Table->CurAntenna = pDM_SWAT_Table->PreAntenna;
-			pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c & 0xfffffffc) | (pDM_SWAT_Table->CurAntenna));
-			ODM_SetBBReg(pDM_Odm,  rfe_ctrl_anta_src, 0xff, 0x77);
-			ODM_SetBBReg(pDM_Odm,  rDPDT_control,bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c);
-
-			if(counter != 0)
-			{
-				if(pMgntInfo->NumBssDesc != 0 && Score > 0)
-				{
-					if(pDM_Odm->DM_SWAT_Table.ANTB_ON == FALSE)
-					{
-						pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
-						pDM_Odm->DM_SWAT_Table.ANTB_ON = TRUE;
-					}
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SwAntDivCheckBeforeLink(): Dual antenna\n"));
-				}
-				else
-				{
-					if(pDM_Odm->DM_SWAT_Table.ANTB_ON == TRUE)
-					{
-						pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
-						pDM_Odm->DM_SWAT_Table.ANTB_ON = FALSE;
-						BT_SetBtCoexAntNum(Adapter, BT_COEX_ANT_TYPE_DETECTED, 1);
-					}
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): Single antenna\n"));
-				}
-			}
-			else
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SwAntDivCheckBeforeLink(): Igone result\n"));
-		}
-		else if(pDM_Odm->SupportICType == ODM_RTL8192C)
-		{
-			if(pMgntInfo->NumBssDesc!=0 && Score<=0)
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,
-					("ODM_SwAntDivCheckBeforeLink(): Using Ant(%s)\n", (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?"MAIN":"AUX"));
-
-				pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
-			}
-			else
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
-					("ODM_SwAntDivCheckBeforeLink(): Remain Ant(%s)\n", (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?"AUX":"MAIN"));
-
-				pDM_SWAT_Table->CurAntenna = pDM_SWAT_Table->PreAntenna;
-
-				//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
-				pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
-				PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
-			}
-		}
-		
-		// Check state reset to default and wait for next time.
-		pDM_SWAT_Table->SWAS_NoLink_State = 0;
-		pMgntInfo->bScanAntDetect = FALSE;
-
-		return FALSE;
-	}
-
-#else
-		return	FALSE;
-#endif
-
-return FALSE;
-}
-
-#endif //#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
-
-
-//3============================================================
-//3 SW Antenna Diversity
-//3============================================================
-
-#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-VOID
-odm_InitHybridAntDiv_88C_92D(
-	IN PDM_ODM_T	pDM_Odm 
-	)
-{
-
-#if((DM_ODM_SUPPORT_TYPE==ODM_AP)||(DM_ODM_SUPPORT_TYPE==ODM_ADSL))
-	struct rtl8192cd_priv *priv=pDM_Odm->priv;
-#endif
-	SWAT_T			*pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	u1Byte                  bTxPathSel=0;	        //0:Path-A   1:Path-B
-	u1Byte			i;
-
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("odm_InitHybridAntDiv==============>\n"));
-
-	//whether to do antenna diversity or not
-#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-	if(priv==NULL)	return;
-	if(!priv->pshare->rf_ft_var.antHw_enable)
-		return;	
-	
-	#ifdef SW_ANT_SWITCH
-	priv->pshare->rf_ft_var.antSw_enable =0;
-	#endif
-#endif
-
-	if((pDM_Odm->SupportICType != ODM_RTL8192C) && (pDM_Odm->SupportICType != ODM_RTL8192D))
-		return;
-
-
-	bTxPathSel=(pDM_Odm->RFType==ODM_1T1R)?FALSE:TRUE;
-
-	ODM_SetBBReg(pDM_Odm,ODM_REG_BB_PWR_SAV1_11N, BIT23, 0); //No update ANTSEL during GNT_BT=1
-	ODM_SetBBReg(pDM_Odm,ODM_REG_TX_ANT_CTRL_11N, BIT21, 1); //TX atenna selection from tx_info
-	ODM_SetBBReg(pDM_Odm,ODM_REG_ANTSEL_PIN_11N, BIT23, 1);	//enable LED[1:0] pin as ANTSEL
-	ODM_SetBBReg(pDM_Odm,ODM_REG_ANTSEL_CTRL_11N, BIT8|BIT9, 0x01);	// 0x01: left antenna, 0x02: right antenna
-	// check HW setting: ANTSEL pin connection
-	#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-	ODM_Write2Byte(pDM_Odm,ODM_REG_RF_PIN_11N, (ODM_Read2Byte(pDM_Odm,0x804)&0xf0ff )| BIT(8) );	// b11-b8=0001,update RFPin setting
-	#endif
-	
-	// only AP support different path selection temperarly
-	if(!bTxPathSel){                 //PATH-A
-		ODM_SetBBReg(pDM_Odm,ODM_REG_PIN_CTRL_11N, BIT8|BIT9, 0 ); // ANTSEL as HW control
-		ODM_SetBBReg(pDM_Odm,ODM_REG_ANTSEL_PATH_11N, BIT13, 1);	 //select TX ANTESEL from path A
-	}
-	else	{
-		ODM_SetBBReg(pDM_Odm,ODM_REG_PIN_CTRL_11N, BIT24|BIT25, 0 ); // ANTSEL as HW control
-		ODM_SetBBReg(pDM_Odm,ODM_REG_ANTSEL_PATH_11N, BIT13, 0);		 //select ANTESEL from path B
-	}
-
-	//Set OFDM HW RX Antenna Diversity
-	ODM_SetBBReg(pDM_Odm,ODM_REG_ANTDIV_PARA1_11N, 0x7FF, 0x0c0); //Pwdb threshold=8dB
-	ODM_SetBBReg(pDM_Odm,ODM_REG_ANTDIV_PARA1_11N, BIT11, 0); //Switch to another antenna by checking pwdb threshold
-	ODM_SetBBReg(pDM_Odm,ODM_REG_ANTDIV_PARA3_11N, BIT23, 1);	// Decide final antenna by comparing 2 antennas' pwdb
-	
-	//Set CCK HW RX Antenna Diversity
-	ODM_SetBBReg(pDM_Odm,ODM_REG_CCK_ANTDIV_PARA2_11N, BIT4, 0); //Antenna diversity decision period = 32 sample
-	ODM_SetBBReg(pDM_Odm,ODM_REG_CCK_ANTDIV_PARA2_11N, 0xf, 0xf); //Threshold for antenna diversity. Check another antenna power if input power < ANT_lim*4
-	ODM_SetBBReg(pDM_Odm,ODM_REG_CCK_ANTDIV_PARA3_11N, BIT13, 1); //polarity ana_A=1 and ana_B=0
-	ODM_SetBBReg(pDM_Odm,ODM_REG_CCK_ANTDIV_PARA4_11N, 0x1f, 0x8); //default antenna power = inpwr*(0.5 + r_ant_step/16)
-
-
-	//Enable HW Antenna Diversity
-	if(!bTxPathSel)                 //PATH-A
-		ODM_SetBBReg(pDM_Odm,ODM_REG_IGI_A_11N, BIT7,1);	// Enable Hardware antenna switch
-	else
-		ODM_SetBBReg(pDM_Odm,ODM_REG_IGI_B_11N, BIT7,1);	// Enable Hardware antenna switch
-	ODM_SetBBReg(pDM_Odm,ODM_REG_CCK_ANTDIV_PARA1_11N, BIT15, 1);//Enable antenna diversity
-
-	pDM_SWAT_Table->CurAntenna=0;			//choose left antenna as default antenna
-	pDM_SWAT_Table->PreAntenna=0;
-	for(i=0; i<ASSOCIATE_ENTRY_NUM ; i++)
-	{
-		pDM_SWAT_Table->CCK_Ant1_Cnt[i] = 0;
-		pDM_SWAT_Table->CCK_Ant2_Cnt[i] = 0;
-		pDM_SWAT_Table->OFDM_Ant1_Cnt[i] = 0;
-		pDM_SWAT_Table->OFDM_Ant2_Cnt[i] = 0;
-		pDM_SWAT_Table->RSSI_Ant1_Sum[i] = 0;
-		pDM_SWAT_Table->RSSI_Ant2_Sum[i] = 0;
-	}
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("<==============odm_InitHybridAntDiv\n"));
-}
-
-
-VOID
-odm_InitHybridAntDiv(
-	IN PDM_ODM_T	pDM_Odm 
-	)
-{
-	if(!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("Return: Not Support HW AntDiv\n"));
-		return;
-	}
-	
-	if(pDM_Odm->SupportICType & (ODM_RTL8192C | ODM_RTL8192D))
-	{
-#if ((RTL8192C_SUPPORT == 1)||(RTL8192D_SUPPORT == 1))
-		odm_InitHybridAntDiv_88C_92D(pDM_Odm);
-#endif
-	}
-}
-
-
-BOOLEAN
-odm_StaDefAntSel(
-	IN PDM_ODM_T	pDM_Odm,
-	IN u4Byte		OFDM_Ant1_Cnt,
-	IN u4Byte		OFDM_Ant2_Cnt,
-	IN u4Byte		CCK_Ant1_Cnt,
-	IN u4Byte		CCK_Ant2_Cnt,
-	OUT u1Byte		*pDefAnt 
-
-	)
-{
-#if 1
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("odm_StaDefAntSelect==============>\n"));
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("OFDM_Ant1_Cnt:%d, OFDM_Ant2_Cnt:%d\n",OFDM_Ant1_Cnt,OFDM_Ant2_Cnt));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("CCK_Ant1_Cnt:%d, CCK_Ant2_Cnt:%d\n",CCK_Ant1_Cnt,CCK_Ant2_Cnt));
-
-	
-	if(((OFDM_Ant1_Cnt+OFDM_Ant2_Cnt)==0)&&((CCK_Ant1_Cnt + CCK_Ant2_Cnt) <10)){
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("odm_StaDefAntSelect Fail: No enough packet info!\n"));
-		return	FALSE;
-	}
-
-	if(OFDM_Ant1_Cnt || OFDM_Ant2_Cnt )	{
-		//if RX OFDM packet number larger than 0
-		if(OFDM_Ant1_Cnt > OFDM_Ant2_Cnt)
-			(*pDefAnt)=1;
-		else
-			(*pDefAnt)=0;
-	}
-	// else if RX CCK packet number larger than 10
-	else if((CCK_Ant1_Cnt + CCK_Ant2_Cnt) >=10 )
-	{
-		if(CCK_Ant1_Cnt > (5*CCK_Ant2_Cnt))
-			(*pDefAnt)=1;
-		else if(CCK_Ant2_Cnt > (5*CCK_Ant1_Cnt))
-			(*pDefAnt)=0;
-		else if(CCK_Ant1_Cnt > CCK_Ant2_Cnt)
-			(*pDefAnt)=0;
-		else
-			(*pDefAnt)=1;
-
-	}
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("TxAnt = %s\n",((*pDefAnt)==1)?"Ant1":"Ant2"));
-	
-#endif
-	//u4Byte antsel = ODM_GetBBReg(pDM_Odm, 0xc88, bMaskByte0);
-	//(*pDefAnt)= (u1Byte) antsel;
-	
-
-
-	
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("<==============odm_StaDefAntSelect\n"));
-
-	return TRUE;
-
-	
-}
-
-
-VOID
-odm_SetRxIdleAnt(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte	Ant,
-	IN   BOOLEAN   bDualPath                     
-)
-{
-	SWAT_T			*pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-
-	//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("odm_SetRxIdleAnt==============>\n"));
-
-	if(Ant != pDM_SWAT_Table->RxIdleAnt)
-	{
-	//for path-A
-	if(Ant==1) 
-			ODM_SetBBReg(pDM_Odm,ODM_REG_RX_DEFUALT_A_11N, 0xFFFF, 0x65a9);   //right-side antenna
-	else
-			ODM_SetBBReg(pDM_Odm,ODM_REG_RX_DEFUALT_A_11N, 0xFFFF, 0x569a);   //left-side antenna
-
-	//for path-B
-	if(bDualPath){
-		if(Ant==0) 
-				ODM_SetBBReg(pDM_Odm,ODM_REG_RX_DEFUALT_A_11N, 0xFFFF0000, 0x65a9);   //right-side antenna
-		else 
-				ODM_SetBBReg(pDM_Odm,ODM_REG_RX_DEFUALT_A_11N, 0xFFFF0000, 0x569a);  //left-side antenna
-		}
-	}
-		pDM_SWAT_Table->RxIdleAnt = Ant;
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("RxIdleAnt: %s  Reg858=0x%x\n",(Ant==1)?"Ant1":"Ant2",(Ant==1)?0x65a9:0x569a));
-
-	//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("<==============odm_SetRxIdleAnt\n"));
-
-	}
-		
-VOID
-ODM_AntselStatistics_88C(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			MacId,
-	IN		u4Byte			PWDBAll,
-	IN		BOOLEAN			isCCKrate
-)
-{
-	SWAT_T			*pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-
-	if(pDM_SWAT_Table->antsel == 1)
-	{
-		if(isCCKrate)
-			pDM_SWAT_Table->CCK_Ant1_Cnt[MacId]++;
-		else
-		{
-			pDM_SWAT_Table->OFDM_Ant1_Cnt[MacId]++;
-			pDM_SWAT_Table->RSSI_Ant1_Sum[MacId] += PWDBAll;
-		}
-	}
-	else
-	{
-		if(isCCKrate)
-			pDM_SWAT_Table->CCK_Ant2_Cnt[MacId]++;
-		else
-		{
-			pDM_SWAT_Table->OFDM_Ant2_Cnt[MacId]++;
-			pDM_SWAT_Table->RSSI_Ant2_Sum[MacId] += PWDBAll;
-		}
-	}
-
-}
-
-
-
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
-VOID
-ODM_SetTxAntByTxInfo_88C_92D(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		pu1Byte			pDesc,
-	IN		u1Byte			macId	
-)
-{
-	SWAT_T			*pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	u1Byte			antsel;
-
-	if(!(pDM_Odm->SupportAbility&ODM_BB_ANT_DIV)) 
-		return;
-
-	if(pDM_SWAT_Table->RxIdleAnt == 1)
-		antsel=(pDM_SWAT_Table->TxAnt[macId] == 1)?0:1;
-	else
-		antsel=(pDM_SWAT_Table->TxAnt[macId] == 1)?1:0;
-	
-	SET_TX_DESC_ANTSEL_A_92C(pDesc, antsel);
-	//SET_TX_DESC_ANTSEL_B_92C(pDesc, antsel);
-	//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("SET_TX_DESC_ANTSEL_A_92C=%d\n", pDM_SWAT_Table->TxAnt[macId]));
-}
-#elif(DM_ODM_SUPPORT_TYPE==ODM_CE)
-VOID
-ODM_SetTxAntByTxInfo_88C_92D(
-	IN		PDM_ODM_T		pDM_Odm
-)
-{
-
-}
-#elif(DM_ODM_SUPPORT_TYPE==ODM_AP)
-VOID
-ODM_SetTxAntByTxInfo_88C_92D(
-	IN		PDM_ODM_T		pDM_Odm
-)
-{
-
-}
-#endif
-
-VOID
-odm_HwAntDiv_92C_92D(
-	IN	PDM_ODM_T	pDM_Odm
-)
-{
-	SWAT_T			*pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	u4Byte			RSSI_Min=0xFF, RSSI, RSSI_Ant1, RSSI_Ant2;
-	u1Byte			RxIdleAnt, i;
-	BOOLEAN		bRet=FALSE;
-	PSTA_INFO_T   	pEntry;
-	
-#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
-	struct rtl8192cd_priv *priv=pDM_Odm->priv;
-	//if test, return
-	if(priv->pshare->rf_ft_var.CurAntenna & 0x80)
-		return;	
-#endif	
-
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("odm_HwAntDiv==============>\n"));
-	
-	if(!(pDM_Odm->SupportAbility&ODM_BB_ANT_DIV))                                    //if don't support antenna diveristy
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("odm_HwAntDiv: Not supported!\n"));
-		return;
-	}
-
-	if((pDM_Odm->SupportICType != ODM_RTL8192C) && (pDM_Odm->SupportICType != ODM_RTL8192D))
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("Return: IC Type is not 92C or 92D\n"));
-		return;
-	}
-	
-#if (DM_ODM_SUPPORT_TYPE&(ODM_WIN|ODM_CE))
-	if(!pDM_Odm->bLinked)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("Return: bLinked is FALSE\n"));
-		return;
-	}
-#endif
-
-	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-		pEntry = pDM_Odm->pODM_StaInfo[i];
-		if(IS_STA_VALID(pEntry))
-		{
-
-			RSSI_Ant1 = (pDM_SWAT_Table->OFDM_Ant1_Cnt[i] == 0)?0:(pDM_SWAT_Table->RSSI_Ant1_Sum[i]/pDM_SWAT_Table->OFDM_Ant1_Cnt[i]);
-			RSSI_Ant2 = (pDM_SWAT_Table->OFDM_Ant2_Cnt[i] == 0)?0:(pDM_SWAT_Table->RSSI_Ant2_Sum[i]/pDM_SWAT_Table->OFDM_Ant2_Cnt[i]);
-
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("RSSI_Ant1=%d,  RSSI_Ant2=%d\n", RSSI_Ant1, RSSI_Ant2));
-		
-			if(RSSI_Ant1 ||RSSI_Ant2) 
-			{
-#if (DM_ODM_SUPPORT_TYPE==ODM_AP)		
-				if(pDM_Odm->pODM_StaInfo[i]->expire_to)
-#endif
-				{
-					RSSI = (RSSI_Ant1 < RSSI_Ant2) ? RSSI_Ant1 : RSSI_Ant2;
-					if((!RSSI) || ( RSSI < RSSI_Min) ) {
-						pDM_SWAT_Table->TargetSTA = i;
-						RSSI_Min = RSSI;
-					}
-				}
-	}
-			///STA: found out default antenna
-			bRet=odm_StaDefAntSel(pDM_Odm, 
-						 pDM_SWAT_Table->OFDM_Ant1_Cnt[i], 
-						 pDM_SWAT_Table->OFDM_Ant2_Cnt[i], 
-						 pDM_SWAT_Table->CCK_Ant1_Cnt[i], 
-						 pDM_SWAT_Table->CCK_Ant2_Cnt[i], 
-						 &pDM_SWAT_Table->TxAnt[i]);
-
-			//if Tx antenna selection: successful
-			if(bRet){	
-				pDM_SWAT_Table->RSSI_Ant1_Sum[i] = 0;
-				pDM_SWAT_Table->RSSI_Ant2_Sum[i] = 0;
-				pDM_SWAT_Table->OFDM_Ant1_Cnt[i] = 0;
-				pDM_SWAT_Table->OFDM_Ant2_Cnt[i] = 0; 
-				pDM_SWAT_Table->CCK_Ant1_Cnt[i] = 0; 
-				pDM_SWAT_Table->CCK_Ant2_Cnt[i] = 0; 
-			}
-		}
-	}
-	
-	//set RX Idle Ant
-	RxIdleAnt = pDM_SWAT_Table->TxAnt[pDM_SWAT_Table->TargetSTA];
-	odm_SetRxIdleAnt(pDM_Odm, RxIdleAnt, FALSE);
-
-#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
-#ifdef TX_SHORTCUT
-	if (!priv->pmib->dot11OperationEntry.disable_txsc) {
-		plist = phead->next;
-		while(plist != phead)	{
-			pstat = list_entry(plist, struct stat_info, asoc_list);
-			if(pstat->expire_to) {
-				for (i=0; i<TX_SC_ENTRY_NUM; i++) {
-					struct tx_desc *pdesc= &(pstat->tx_sc_ent[i].hwdesc1);	
-					pdesc->Dword2 &= set_desc(~ (BIT(24)|BIT(25)));
-					if((pstat->CurAntenna^priv->pshare->rf_ft_var.CurAntenna)&1)
-						pdesc->Dword2 |= set_desc(BIT(24)|BIT(25));
-					pdesc= &(pstat->tx_sc_ent[i].hwdesc2);	
-					pdesc->Dword2 &= set_desc(~ (BIT(24)|BIT(25)));
-					if((pstat->CurAntenna^priv->pshare->rf_ft_var.CurAntenna)&1)
-						pdesc->Dword2 |= set_desc(BIT(24)|BIT(25));					
-				}
-			}		
-
-			if (plist == plist->next)
-				break;
-			plist = plist->next;
-		};
-	}
-#endif	
-#endif
-	
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("<==============odm_HwAntDiv\n"));
-	
-}
-
-VOID
-odm_HwAntDiv(
-	IN	PDM_ODM_T	pDM_Odm
-)
-{	
-
-	PADAPTER		pAdapter	= pDM_Odm->Adapter;
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
-	if(pAdapter->MgntInfo.AntennaTest)
-		return;
-#endif
-	if(!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("Return: Not Support HW AntDiv\n"));
-		return;
-	}
-	
-	if(pDM_Odm->SupportICType & (ODM_RTL8192C | ODM_RTL8192D))
-	{
-#if ((RTL8192C_SUPPORT == 1)||(RTL8192D_SUPPORT == 1))
-		odm_HwAntDiv_92C_92D(pDM_Odm);
-#endif
-	}
-}
-
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-#if 0
-VOID
-odm_HwAntDiv(
-	IN	PDM_ODM_T	pDM_Odm
-)
-{
-	struct rtl8192cd_priv *priv=pDM_Odm->priv;
-	struct stat_info	*pstat, *pstat_min=NULL;
-	struct list_head	*phead, *plist;
-	int rssi_min= 0xff, i;
-	u1Byte	idleAnt=priv->pshare->rf_ft_var.CurAntenna;	
-	u1Byte	nextAnt;
-	BOOLEAN		bRet=FALSE;
-	
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("odm_HwAntDiv==============>\n"));
-
-	if((!priv->pshare->rf_ft_var.antHw_enable) ||(!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV)))
-		return;
-	
-	//if test, return
-	if(priv->pshare->rf_ft_var.CurAntenna & 0x80)
-		return;
-	
-	phead = &priv->asoc_list;
-	plist = phead->next;
-	////=========================
-	//find mimum rssi sta
-	////=========================
-	while(plist != phead)	{
-		pstat = list_entry(plist, struct stat_info, asoc_list);
-		if((pstat->expire_to) && (pstat->AntRSSI[0] || pstat->AntRSSI[1])) {
-			int rssi = (pstat->AntRSSI[0] < pstat->AntRSSI[1]) ? pstat->AntRSSI[0] : pstat->AntRSSI[1];
-			if((!pstat_min) || ( rssi < rssi_min) ) {
-				pstat_min = pstat;
-				rssi_min = rssi;
-			}
-		}
-		///STA: found out default antenna
-		bRet=odm_StaDefAntSel(pDM_Odm,
-						pstat->hwRxAntSel[1],
-						pstat->hwRxAntSel[0],
-						pstat->cckPktCount[1],
-						pstat->cckPktCount[0],
-						&nextAnt
-						);
-		
-		//if default antenna selection: successful
-		if(bRet){	
-			pstat->CurAntenna = nextAnt;
-			//update rssi
-			for(i=0; i<2; i++) {
-				if(pstat->cckPktCount[i]==0 && pstat->hwRxAntSel[i]==0)
-					pstat->AntRSSI[i] = 0;
-			}
-			if(pstat->AntRSSI[idleAnt]==0)
-				pstat->AntRSSI[idleAnt] = pstat->AntRSSI[idleAnt^1];
-			// reset variables
-			pstat->hwRxAntSel[1] = pstat->hwRxAntSel[0] =0;
-			pstat->cckPktCount[1]= pstat->cckPktCount[0] =0;
-		}
-
-		if (plist == plist->next)
-			break;
-		plist = plist->next;
-		
-	};
-	////=========================
-	//Choose  RX Idle antenna according to minmum rssi
-	////=========================
-	if(pstat_min)	{
-		if(priv->pshare->rf_ft_var.CurAntenna!=pstat_min->CurAntenna)
-			odm_SetRxIdleAnt(pDM_Odm,pstat_min->CurAntenna,TRUE);
-		priv->pshare->rf_ft_var.CurAntenna = pstat_min->CurAntenna;
-	}
-
-
-#ifdef TX_SHORTCUT
-	if (!priv->pmib->dot11OperationEntry.disable_txsc) {
-		plist = phead->next;
-		while(plist != phead)	{
-			pstat = list_entry(plist, struct stat_info, asoc_list);
-			if(pstat->expire_to) {
-				for (i=0; i<TX_SC_ENTRY_NUM; i++) {
-					struct tx_desc *pdesc= &(pstat->tx_sc_ent[i].hwdesc1);	
-					pdesc->Dword2 &= set_desc(~ (BIT(24)|BIT(25)));
-					if((pstat->CurAntenna^priv->pshare->rf_ft_var.CurAntenna)&1)
-						pdesc->Dword2 |= set_desc(BIT(24)|BIT(25));
-					pdesc= &(pstat->tx_sc_ent[i].hwdesc2);	
-					pdesc->Dword2 &= set_desc(~ (BIT(24)|BIT(25)));
-					if((pstat->CurAntenna^priv->pshare->rf_ft_var.CurAntenna)&1)
-						pdesc->Dword2 |= set_desc(BIT(24)|BIT(25));					
-				}
-			}		
-
-			if (plist == plist->next)
-				break;
-			plist = plist->next;
-		};
-	}
-#endif	
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,"<==============odm_HwAntDiv\n");
-}
-#endif
-
-u1Byte
-ODM_Diversity_AntennaSelect(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte	*data
-)
-{
-	struct rtl8192cd_priv *priv=pDM_Odm->priv;
-
-	int ant = _atoi(data, 16);
-
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("ODM_Diversity_AntennaSelect==============>\n"));
-
-	#ifdef PCIE_POWER_SAVING
-	PCIeWakeUp(priv, POWER_DOWN_T0);
-	#endif
-
-	if (ant==AUX_ANT || ant==MAIN_ANT) 
-	{
-		if ( !priv->pshare->rf_ft_var.antSw_select) {
-			ODM_Write4Byte(pDM_Odm,0x870, ODM_Read4Byte(pDM_Odm,0x870) | BIT(8)| BIT(9) );  //  ANTSEL A as SW control
-			ODM_Write1Byte(pDM_Odm,0xc50, ODM_Read1Byte(pDM_Odm,0xc50) & (~ BIT(7)));	// rx OFDM SW control
-			PHY_SetBBReg(priv, 0x860, 0x300, ant);
-		} else {
-			ODM_Write4Byte(pDM_Odm,0x870, ODM_Read4Byte(pDM_Odm,0x870) | BIT(24)| BIT(25) ); // ANTSEL B as HW control
-			PHY_SetBBReg(priv, 0x864, 0x300, ant);
-			ODM_Write1Byte(pDM_Odm,0xc58, ODM_Read1Byte(pDM_Odm,0xc58) & (~ BIT(7)));		// rx OFDM SW control
-		}
-
-		ODM_Write1Byte(pDM_Odm,0xa01, ODM_Read1Byte(pDM_Odm,0xa01) & (~ BIT(7)));	// rx CCK SW control
-		ODM_Write4Byte(pDM_Odm,0x80c, ODM_Read4Byte(pDM_Odm,0x80c) & (~ BIT(21))); // select ant by tx desc
-		ODM_Write4Byte(pDM_Odm,0x858, 0x569a569a);
-
-		priv->pshare->rf_ft_var.antHw_enable = 0;
-		priv->pshare->rf_ft_var.CurAntenna  = (ant%2);
-
-		#ifdef SW_ANT_SWITCH
-		priv->pshare->rf_ft_var.antSw_enable = 0;
-		priv->pshare->DM_SWAT_Table.CurAntenna = ant;
-		priv->pshare->RSSI_test =0;
-		#endif
-	}
-	else if(ant==0){
-
-		if ( !priv->pshare->rf_ft_var.antSw_select)  {
-			ODM_Write4Byte(pDM_Odm,0x870, ODM_Read4Byte(pDM_Odm,0x870) & ~(BIT(8)| BIT(9)) );
-			ODM_Write1Byte(pDM_Odm,0xc50, ODM_Read1Byte(pDM_Odm,0xc50) | BIT(7));	// OFDM HW control
-		} else {
-			ODM_Write4Byte(pDM_Odm,0x870, ODM_Read4Byte(pDM_Odm,0x870) & ~(BIT(24)| BIT(25)) );
-			ODM_Write1Byte(pDM_Odm,0xc58, ODM_Read1Byte(pDM_Odm,0xc58) | BIT(7));	// OFDM HW control
-		}
-
-		ODM_Write1Byte(pDM_Odm,0xa01, ODM_Read1Byte(pDM_Odm,0xa01) | BIT(7));	// CCK HW control
-		ODM_Write4Byte(pDM_Odm,0x80c, ODM_Read4Byte(pDM_Odm,0x80c) | BIT(21) ); // by tx desc
-		priv->pshare->rf_ft_var.CurAntenna = 0;
-		ODM_Write4Byte(pDM_Odm,0x858, 0x569a569a);
-		priv->pshare->rf_ft_var.antHw_enable = 1;
-#ifdef SW_ANT_SWITCH
-		priv->pshare->rf_ft_var.antSw_enable = 0;
-		priv->pshare->RSSI_test =0;
-#endif
-	}
-#ifdef SW_ANT_SWITCH
-	else if(ant==3) {
-		if(!priv->pshare->rf_ft_var.antSw_enable) {
-			
-			dm_SW_AntennaSwitchInit(priv);
-			ODM_Write4Byte(pDM_Odm,0x858, 0x569a569a);
-			priv->pshare->lastTxOkCnt = priv->net_stats.tx_bytes;
-			priv->pshare->lastRxOkCnt = priv->net_stats.rx_bytes;
-		}
-		if ( !priv->pshare->rf_ft_var.antSw_select)
-			ODM_Write1Byte(pDM_Odm,0xc50, ODM_Read1Byte(pDM_Odm,0xc50) & (~ BIT(7)));	// rx OFDM SW control
-		else
-			ODM_Write1Byte(pDM_Odm,0xc58, ODM_Read1Byte(pDM_Odm,0xc58) & (~ BIT(7)));	// rx OFDM SW control
-
-		ODM_Write1Byte(pDM_Odm,0xa01, ODM_Read1Byte(pDM_Odm,0xa01) & (~ BIT(7)));		// rx CCK SW control
-		ODM_Write4Byte(pDM_Odm,0x80c, ODM_Read4Byte(pDM_Odm,0x80c) & (~ BIT(21))); 	// select ant by tx desc
-		priv->pshare->rf_ft_var.antHw_enable = 0;
-		priv->pshare->rf_ft_var.antSw_enable = 1;
-
-	}
-#endif
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("<==============ODM_Diversity_AntennaSelect\n"));
-
-	return 1;
-}
-#endif
-
-#else //#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-
-VOID odm_InitHybridAntDiv(	IN PDM_ODM_T	pDM_Odm 	){}
-VOID odm_HwAntDiv(	IN	PDM_ODM_T	pDM_Odm){}
-#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
-VOID ODM_SetTxAntByTxInfo_88C_92D(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		pu1Byte			pDesc,
-	IN		u1Byte			macId	
-){}
-#elif(DM_ODM_SUPPORT_TYPE==ODM_CE)
-VOID ODM_SetTxAntByTxInfo_88C_92D(	IN		PDM_ODM_T		pDM_Odm){ }
-#elif(DM_ODM_SUPPORT_TYPE==ODM_AP)
-VOID ODM_SetTxAntByTxInfo_88C_92D(	IN		PDM_ODM_T		pDM_Odm){ }
-#endif
-
-#endif //#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
-
-
-
-//============================================================
-//EDCA Turbo
-//============================================================
-VOID
-ODM_EdcaTurboInit(
-	IN    PDM_ODM_T		pDM_Odm)
-{
-
-#if ((DM_ODM_SUPPORT_TYPE == ODM_AP)||(DM_ODM_SUPPORT_TYPE==ODM_ADSL))
-	odm_EdcaParaInit(pDM_Odm);
-#elif (DM_ODM_SUPPORT_TYPE==ODM_WIN)
-	PADAPTER	Adapter = NULL;
-	HAL_DATA_TYPE	*pHalData = NULL;
-
-	if(pDM_Odm->Adapter==NULL)	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("EdcaTurboInit fail!!!\n"));
-		return;
-	}
-
-	Adapter=pDM_Odm->Adapter;
-	pHalData=GET_HAL_DATA(Adapter);
-
-	pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = FALSE;	
-	pDM_Odm->DM_EDCA_Table.bIsCurRDLState = FALSE;
-	pHalData->bIsAnyNonBEPkts = FALSE;
-	
-#elif(DM_ODM_SUPPORT_TYPE==ODM_CE)
-	PADAPTER	Adapter = pDM_Odm->Adapter;	
-	pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = FALSE;	
-	pDM_Odm->DM_EDCA_Table.bIsCurRDLState = FALSE;
-	Adapter->recvpriv.bIsAnyNonBEPkts =FALSE;
-
-#endif	
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VO PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_VO_PARAM)));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VI PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_VI_PARAM)));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BE PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BE_PARAM)));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BK PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BK_PARAM)));
-
-	
-}	// ODM_InitEdcaTurbo
-
-VOID
-odm_EdcaTurboCheck(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	// 
-	// For AP/ADSL use prtl8192cd_priv
-	// For CE/NIC use PADAPTER
-	//
-
-	//
-	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
-	// at the same time. In the stage2/3, we need to prive universal interface and merge all
-	// HW dynamic mechanism.
-	//
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("odm_EdcaTurboCheck========================>\n"));
-
-	if(!(pDM_Odm->SupportAbility& ODM_MAC_EDCA_TURBO ))
-		return;
-
-	switch	(pDM_Odm->SupportPlatform)
-	{
-		case	ODM_WIN:
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
-			odm_EdcaTurboCheckMP(pDM_Odm);
-#endif
-			break;
-
-		case	ODM_CE:
-#if(DM_ODM_SUPPORT_TYPE==ODM_CE)
-			odm_EdcaTurboCheckCE(pDM_Odm);
-#endif
-			break;
-
-		case	ODM_AP:
-		case	ODM_ADSL:
-
-#if ((DM_ODM_SUPPORT_TYPE == ODM_AP)||(DM_ODM_SUPPORT_TYPE==ODM_ADSL))
-		odm_IotEngine(pDM_Odm);
-#endif
-			break;	
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("<========================odm_EdcaTurboCheck\n"));
-
-}	// odm_CheckEdcaTurbo
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_CE)
-
-
-VOID
-odm_EdcaTurboCheckCE(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_CE)
-
-	PADAPTER		       Adapter = pDM_Odm->Adapter;
-	u32	EDCA_BE_UL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_UL[pMgntInfo->IOTPeer];
-	u32	EDCA_BE_DL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_DL[pMgntInfo->IOTPeer];
-	u32	ICType=pDM_Odm->SupportICType;
-	u32	IOTPeer=0;
-	u8	WirelessMode=0xFF;                   //invalid value
-	u32 	trafficIndex;
-	u32	edca_param;
-	u64	cur_tx_bytes = 0;
-	u64	cur_rx_bytes = 0;
-	u8	bbtchange = _FALSE;
-	u8	bBiasOnRx = _FALSE;
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	struct dvobj_priv		*pdvobjpriv = adapter_to_dvobj(Adapter);
-	struct xmit_priv		*pxmitpriv = &(Adapter->xmitpriv);
-	struct recv_priv		*precvpriv = &(Adapter->recvpriv);
-	struct registry_priv	*pregpriv = &Adapter->registrypriv;
-	struct mlme_ext_priv	*pmlmeext = &(Adapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-	if(pDM_Odm->bLinked != _TRUE)
-		goto dm_CheckEdcaTurbo_EXIT;
-
-	if ((pregpriv->wifi_spec == 1) )//|| (pmlmeinfo->HT_enable == 0))
-	{
-		goto dm_CheckEdcaTurbo_EXIT;
-	}
-
-	if(pDM_Odm->pWirelessMode!=NULL)
-		WirelessMode=*(pDM_Odm->pWirelessMode);
-
-	IOTPeer = pmlmeinfo->assoc_AP_vendor;
-
-	if (IOTPeer >=  HT_IOT_PEER_MAX)
-	{
-		goto dm_CheckEdcaTurbo_EXIT;
-	}
-
-	if(	(pDM_Odm->SupportICType == ODM_RTL8192C) ||
-		(pDM_Odm->SupportICType == ODM_RTL8723A) ||
-		(pDM_Odm->SupportICType == ODM_RTL8188E))
-	{
-		if((IOTPeer == HT_IOT_PEER_RALINK)||(IOTPeer == HT_IOT_PEER_ATHEROS))
-			bBiasOnRx = _TRUE;
-	}
-
-	// Check if the status needs to be changed.
-	if((bbtchange) || (!precvpriv->bIsAnyNonBEPkts) )
-	{
-		cur_tx_bytes = pdvobjpriv->traffic_stat.cur_tx_bytes;
-		cur_rx_bytes = pdvobjpriv->traffic_stat.cur_rx_bytes;
-
-		//traffic, TX or RX
-		if(bBiasOnRx)
-		{
-			if (cur_tx_bytes > (cur_rx_bytes << 2))
-			{ // Uplink TP is present.
-				trafficIndex = UP_LINK; 
-			}
-			else
-			{ // Balance TP is present.
-				trafficIndex = DOWN_LINK;
-			}
-		}
-		else
-		{
-			if (cur_rx_bytes > (cur_tx_bytes << 2))
-			{ // Downlink TP is present.
-				trafficIndex = DOWN_LINK;
-			}
-			else
-			{ // Balance TP is present.
-				trafficIndex = UP_LINK;
-			}
-		}
-
-		//if ((pDM_Odm->DM_EDCA_Table.prv_traffic_idx != trafficIndex) || (!pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA))
-		{
-			if(ICType==ODM_RTL8192D)
-			{      
-				// Single PHY
-				if(pDM_Odm->RFType==ODM_2T2R)
-				{
-					EDCA_BE_UL = 0x60a42b;    //0x5ea42b;
-					EDCA_BE_DL = 0x60a42b;    //0x5ea42b;
-				}
-				else
-				{
-					EDCA_BE_UL = 0x6ea42b;
-					EDCA_BE_DL = 0x6ea42b;
-				}
-			}
-			else
-			{
-				if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE) {
-					if((ICType==ODM_RTL8192C)&&(pDM_Odm->RFType==ODM_2T2R)) {
-						EDCA_BE_UL = 0x60a42b;
-						EDCA_BE_DL = 0x60a42b;
-					}
-					else
-					{
-						EDCA_BE_UL = 0x6ea42b;
-						EDCA_BE_DL = 0x6ea42b;
-					}
-				}
-			}
-		
-			//92D txop can't be set to 0x3e for cisco1250
-			if((ICType!=ODM_RTL8192D) && (IOTPeer== HT_IOT_PEER_CISCO) &&(WirelessMode==ODM_WM_N24G))
-			{
-				EDCA_BE_DL = edca_setting_DL[IOTPeer];
-				EDCA_BE_UL = edca_setting_UL[IOTPeer];
-			}
-			//merge from 92s_92c_merge temp brunch v2445    20120215 
-			else if((IOTPeer == HT_IOT_PEER_CISCO) &&((WirelessMode==ODM_WM_G)||(WirelessMode==(ODM_WM_B|ODM_WM_G))||(WirelessMode==ODM_WM_A)||(WirelessMode==ODM_WM_B)))
-			{
-				EDCA_BE_DL = edca_setting_DL_GMode[IOTPeer];
-			}
-			else if((IOTPeer== HT_IOT_PEER_AIRGO )&& ((WirelessMode==ODM_WM_G)||(WirelessMode==ODM_WM_A)))
-			{
-				EDCA_BE_DL = 0xa630;
-			}
-			else if(IOTPeer == HT_IOT_PEER_MARVELL)
-			{
-				EDCA_BE_DL = edca_setting_DL[IOTPeer];
-				EDCA_BE_UL = edca_setting_UL[IOTPeer];
-			}
-			else if(IOTPeer == HT_IOT_PEER_ATHEROS)
-			{
-				// Set DL EDCA for Atheros peer to 0x3ea42b. Suggested by SD3 Wilson for ASUS TP issue. 
-				EDCA_BE_DL = edca_setting_DL[IOTPeer];
-			}
-
-			if((ICType==ODM_RTL8812)||(ICType==ODM_RTL8821)||(ICType==ODM_RTL8192E))           //add 8812AU/8812AE
-			{
-				EDCA_BE_UL = 0x5ea42b;
-				EDCA_BE_DL = 0x5ea42b;
-
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("8812A: EDCA_BE_UL=0x%x EDCA_BE_DL =0x%x",EDCA_BE_UL,EDCA_BE_DL));
-			}
-
-			if (trafficIndex == DOWN_LINK)
-				edca_param = EDCA_BE_DL;
-			else
-				edca_param = EDCA_BE_UL;
-
-			rtw_write32(Adapter, REG_EDCA_BE_PARAM, edca_param);
-
-			pDM_Odm->DM_EDCA_Table.prv_traffic_idx = trafficIndex;
-		}
-		
-		pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = _TRUE;
-	}
-	else
-	{
-		//
-		// Turn Off EDCA turbo here.
-		// Restore original EDCA according to the declaration of AP.
-		//
-		 if(pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA)
-		{
-			rtw_write32(Adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
-			pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = _FALSE;
-		}
-	}
-
-dm_CheckEdcaTurbo_EXIT:
-	// Set variables for next time.
-	precvpriv->bIsAnyNonBEPkts = _FALSE;
-#endif	
-}
-
-
-#elif(DM_ODM_SUPPORT_TYPE==ODM_WIN)
-VOID
-odm_EdcaTurboCheckMP(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-
-
-	PADAPTER		       Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-
-	PADAPTER 			pDefaultAdapter = GetDefaultAdapter(Adapter);
-	PADAPTER 			pExtAdapter = GetFirstExtAdapter(Adapter);//NULL;
-	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
-	PSTA_QOS			pStaQos = Adapter->MgntInfo.pStaQos;
-	//[Win7 Count Tx/Rx statistic for Extension Port] odm_CheckEdcaTurbo's Adapter is always Default. 2009.08.20, by Bohn
-	u8Byte				Ext_curTxOkCnt = 0;
-	u8Byte				Ext_curRxOkCnt = 0;	
-	//For future Win7  Enable Default Port to modify AMPDU size dynamically, 2009.08.20, Bohn.	
-	u1Byte TwoPortStatus = (u1Byte)TWO_PORT_STATUS__WITHOUT_ANY_ASSOCIATE;
-
-	// Keep past Tx/Rx packet count for RT-to-RT EDCA turbo.
-	u8Byte				curTxOkCnt = 0;
-	u8Byte				curRxOkCnt = 0;	
-	u4Byte				EDCA_BE_UL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_UL[pMgntInfo->IOTPeer];
-	u4Byte				EDCA_BE_DL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_DL[pMgntInfo->IOTPeer];
-	u4Byte                         EDCA_BE = 0x5ea42b;
-	u1Byte                         IOTPeer=0;
-	BOOLEAN                      *pbIsCurRDLState=NULL;
-	BOOLEAN                      bLastIsCurRDLState=FALSE;
-	BOOLEAN				 bBiasOnRx=FALSE;
-	BOOLEAN				bEdcaTurboOn=FALSE;
-	u1Byte				TxRate = 0xFF;
-	u8Byte				value64;	
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("odm_EdcaTurboCheckMP========================>"));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BE PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BE_PARAM)));
-
-////===============================
-////list paramter for different platform
-////===============================
-	bLastIsCurRDLState=pDM_Odm->DM_EDCA_Table.bIsCurRDLState;
-	pbIsCurRDLState=&(pDM_Odm->DM_EDCA_Table.bIsCurRDLState);	
-
-	//2012/09/14 MH Add 
-	if (pMgntInfo->NumNonBePkt > pMgntInfo->RegEdcaThresh && !Adapter->MgntInfo.bWiFiConfg)
-		pHalData->bIsAnyNonBEPkts = TRUE;
-
-	pMgntInfo->NumNonBePkt = 0;
-
-       // Caculate TX/RX TP:
-	//curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - pMgntInfo->lastTxOkCnt;
-	//curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - pMgntInfo->lastRxOkCnt;
-	curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - pDM_Odm->lastTxOkCnt;
-	curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - pDM_Odm->lastRxOkCnt;
-	pDM_Odm->lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
-	pDM_Odm->lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
-
-	if(pExtAdapter == NULL) 
-		pExtAdapter = pDefaultAdapter;
-
-	Ext_curTxOkCnt = pExtAdapter->TxStats.NumTxBytesUnicast - pMgntInfo->Ext_lastTxOkCnt;
-	Ext_curRxOkCnt = pExtAdapter->RxStats.NumRxBytesUnicast - pMgntInfo->Ext_lastRxOkCnt;
-	GetTwoPortSharedResource(Adapter,TWO_PORT_SHARED_OBJECT__STATUS,NULL,&TwoPortStatus);
-	//For future Win7  Enable Default Port to modify AMPDU size dynamically, 2009.08.20, Bohn.
-	if(TwoPortStatus == TWO_PORT_STATUS__EXTENSION_ONLY)
-	{
-		curTxOkCnt = Ext_curTxOkCnt ;
-		curRxOkCnt = Ext_curRxOkCnt ;
-	}
-	//
-	IOTPeer=pMgntInfo->IOTPeer;
-	bBiasOnRx=(pMgntInfo->IOTAction & HT_IOT_ACT_EDCA_BIAS_ON_RX)?TRUE:FALSE;
-	bEdcaTurboOn=((!pHalData->bIsAnyNonBEPkts) && (!pMgntInfo->bDisableFrameBursting))?TRUE:FALSE;
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("bIsAnyNonBEPkts : 0x%lx  bDisableFrameBursting : 0x%lx  \n",pHalData->bIsAnyNonBEPkts,pMgntInfo->bDisableFrameBursting));
-
-
-////===============================
-////check if edca turbo is disabled
-////===============================
-	if(odm_IsEdcaTurboDisable(pDM_Odm))
-		goto dm_CheckEdcaTurbo_EXIT;
-
-
-////===============================
-////remove iot case out
-////===============================
-	ODM_EdcaParaSelByIot(pDM_Odm, &EDCA_BE_UL, &EDCA_BE_DL);
-
-
-////===============================
-////Check if the status needs to be changed.
-////===============================
-	if(bEdcaTurboOn)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("bEdcaTurboOn : 0x%x bBiasOnRx : 0x%x\n",bEdcaTurboOn,bBiasOnRx));
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("curTxOkCnt : 0x%lx \n",curTxOkCnt));
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("curRxOkCnt : 0x%lx \n",curRxOkCnt));
-		if(bBiasOnRx)
-			odm_EdcaChooseTrafficIdx(pDM_Odm,curTxOkCnt, curRxOkCnt,   TRUE,  pbIsCurRDLState);
-		else
-			odm_EdcaChooseTrafficIdx(pDM_Odm,curTxOkCnt, curRxOkCnt,   FALSE,  pbIsCurRDLState);
-
-//modify by Guo.Mingzhi 2011-12-29
-			EDCA_BE=((*pbIsCurRDLState)==TRUE)?EDCA_BE_DL:EDCA_BE_UL;
-			if(IS_HARDWARE_TYPE_8821U(Adapter))
-			{
-				if(pMgntInfo->RegTxDutyEnable)
-				{
-					//2013.01.23 LukeLee: debug for 8811AU thermal issue (reduce Tx duty cycle)
-					if(!pMgntInfo->ForcedDataRate) //auto rate
-					{
-						if(pDM_Odm->TxRate != 0xFF)
-							TxRate = Adapter->HalFunc.GetHwRateFromMRateHandler(pDM_Odm->TxRate); 
-					}
-					else //force rate
-					{
-						TxRate = (u1Byte) pMgntInfo->ForcedDataRate;
-					}
-
-					value64 = (curRxOkCnt<<2);
-					if(curTxOkCnt < value64) //Downlink
-						ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
-					else //Uplink
-					{
-						//DbgPrint("pDM_Odm->RFCalibrateInfo.ThermalValue = 0x%X\n", pDM_Odm->RFCalibrateInfo.ThermalValue);
-						//if(pDM_Odm->RFCalibrateInfo.ThermalValue < pHalData->EEPROMThermalMeter)
-						if((pDM_Odm->RFCalibrateInfo.ThermalValue < 0x2c) || (*pDM_Odm->pBandType == BAND_ON_2_4G))
-							ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
-						else
-						{
-							switch (TxRate)
-							{
-								case MGN_VHT1SS_MCS6:
-								case MGN_VHT1SS_MCS5:
-								case MGN_MCS6:
-								case MGN_MCS5:
-								case MGN_48M:
-								case MGN_54M:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0x1ea42b);
-								break;
-								case MGN_VHT1SS_MCS4:
-								case MGN_MCS4:
-								case MGN_36M:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa42b);
-								break;
-								case MGN_VHT1SS_MCS3:
-								case MGN_MCS3:
-								case MGN_24M:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa47f);
-								break;
-								case MGN_VHT1SS_MCS2:
-								case MGN_MCS2:
-								case MGN_18M:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa57f);
-								break;
-								case MGN_VHT1SS_MCS1:
-								case MGN_MCS1:
-								case MGN_9M:
-								case MGN_12M:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa77f);
-								break;
-								case MGN_VHT1SS_MCS0:
-								case MGN_MCS0:
-								case MGN_6M:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa87f);
-								break;
-								default:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
-								break;
-							}
-						}
-					}				
-				}
-				else
-				{
-					ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
-				}
-
-			}
-			else if (IS_HARDWARE_TYPE_8812AU(Adapter)){
-				if(pMgntInfo->RegTxDutyEnable)
-				{
-					//2013.07.26 Wilson: debug for 8812AU thermal issue (reduce Tx duty cycle)
-					// it;s the same issue as 8811AU
-					if(!pMgntInfo->ForcedDataRate) //auto rate
-					{
-						if(pDM_Odm->TxRate != 0xFF)
-							TxRate = Adapter->HalFunc.GetHwRateFromMRateHandler(pDM_Odm->TxRate); 
-					}
-					else //force rate
-					{
-						TxRate = (u1Byte) pMgntInfo->ForcedDataRate;
-					}
-
-					value64 = (curRxOkCnt<<2);
-					if(curTxOkCnt < value64) //Downlink
-						ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
-					else //Uplink
-					{
-						//DbgPrint("pDM_Odm->RFCalibrateInfo.ThermalValue = 0x%X\n", pDM_Odm->RFCalibrateInfo.ThermalValue);
-						//if(pDM_Odm->RFCalibrateInfo.ThermalValue < pHalData->EEPROMThermalMeter)
-						if((pDM_Odm->RFCalibrateInfo.ThermalValue < 0x2c) || (*pDM_Odm->pBandType == BAND_ON_2_4G))
-							ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
-						else
-						{
-							switch (TxRate)
-							{
-								case MGN_VHT2SS_MCS9:
-								case MGN_VHT1SS_MCS9:									
-								case MGN_VHT1SS_MCS8:
-								case MGN_MCS15:
-								case MGN_MCS7:									
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0x1ea44f);							
-								case MGN_VHT2SS_MCS8:
-								case MGN_VHT1SS_MCS7:
-								case MGN_MCS14:
-								case MGN_MCS6:
-								case MGN_54M:									
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa44f);
-								case MGN_VHT2SS_MCS7:
-								case MGN_VHT2SS_MCS6:
-								case MGN_VHT1SS_MCS6:
-								case MGN_VHT1SS_MCS5:
-								case MGN_MCS13:
-								case MGN_MCS5:
-								case MGN_48M:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa630);
-								break;
-								case MGN_VHT2SS_MCS5:
-								case MGN_VHT2SS_MCS4:
-								case MGN_VHT1SS_MCS4:
-								case MGN_VHT1SS_MCS3:	
-								case MGN_MCS12:
-								case MGN_MCS4:	
-								case MGN_MCS3:	
-								case MGN_36M:
-								case MGN_24M:	
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa730);
-								break;
-								case MGN_VHT2SS_MCS3:
-								case MGN_VHT2SS_MCS2:
-								case MGN_VHT2SS_MCS1:
-								case MGN_VHT1SS_MCS2:
-								case MGN_VHT1SS_MCS1:	
-								case MGN_MCS11:	
-								case MGN_MCS10:	
-								case MGN_MCS9:		
-								case MGN_MCS2:	
-								case MGN_MCS1:
-								case MGN_18M:	
-								case MGN_12M:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa830);
-								break;
-								case MGN_VHT2SS_MCS0:
-								case MGN_VHT1SS_MCS0:
-								case MGN_MCS0:	
-								case MGN_MCS8:
-								case MGN_9M:	
-								case MGN_6M:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa87f);
-								break;
-								default:
-									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
-								break;
-							}
-						}
-					}				
-				}
-				else
-				{
-					ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
-				}
-			}
-			else
-				ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
-
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("EDCA Turbo on: EDCA_BE:0x%lx\n",EDCA_BE));
-
-		pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = TRUE;
-		
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("EDCA_BE_DL : 0x%lx  EDCA_BE_UL : 0x%lx  EDCA_BE : 0x%lx  \n",EDCA_BE_DL,EDCA_BE_UL,EDCA_BE));
-
-	}
-	else
-	{
-		// Turn Off EDCA turbo here.
-		// Restore original EDCA according to the declaration of AP.
-		 if(pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA)
-		{
-			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_AC_PARAM, GET_WMM_PARAM_ELE_SINGLE_AC_PARAM(pStaQos->WMMParamEle, AC0_BE) );
-
-			pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = FALSE;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Restore EDCA BE: 0x%lx  \n",pDM_Odm->WMMEDCA_BE));
-
-		}
-	}
-
-////===============================
-////Set variables for next time.
-////===============================
-dm_CheckEdcaTurbo_EXIT:
-#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)
-	pHalData->bIsAnyNonBEPkts = FALSE;
-	pMgntInfo->lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
-	pMgntInfo->lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
-	pMgntInfo->Ext_lastTxOkCnt = pExtAdapter->TxStats.NumTxBytesUnicast;
-	pMgntInfo->Ext_lastRxOkCnt = pExtAdapter->RxStats.NumRxBytesUnicast;
-#elif (DM_ODM_SUPPORT_TYPE==ODM_CE)
-	precvpriv->bIsAnyNonBEPkts = FALSE;
-	pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
-	precvpriv->last_rx_bytes = precvpriv->rx_bytes;
-#endif
-
-}
-
-
-//check if edca turbo is disabled
-BOOLEAN
-odm_IsEdcaTurboDisable(
-	IN 	PDM_ODM_T 	pDM_Odm
-)
-{
-	PADAPTER		       Adapter = pDM_Odm->Adapter;
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
-	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
-	u4Byte				IOTPeer=pMgntInfo->IOTPeer;
-#elif (DM_ODM_SUPPORT_TYPE==ODM_CE)
-	struct registry_priv	*pregpriv = &Adapter->registrypriv;
-	struct mlme_ext_priv	*pmlmeext = &(Adapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	u4Byte                         IOTPeer=pmlmeinfo->assoc_AP_vendor;
-	u1Byte                         WirelessMode=0xFF;                   //invalid value
-
-	if(pDM_Odm->pWirelessMode!=NULL)
-		WirelessMode=*(pDM_Odm->pWirelessMode);
-
-#endif
-
-	if(pDM_Odm->bBtDisableEdcaTurbo)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("EdcaTurboDisable for BT!!\n"));
-		return TRUE;
-	}
-
-	if((!(pDM_Odm->SupportAbility& ODM_MAC_EDCA_TURBO ))||
-		(pDM_Odm->bWIFITest)||
-		(IOTPeer>= HT_IOT_PEER_MAX))
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("EdcaTurboDisable\n"));
-		return TRUE;
-	}
-
-
-#if (DM_ODM_SUPPORT_TYPE ==ODM_WIN)
-	// 1. We do not turn on EDCA turbo mode for some AP that has IOT issue
-	// 2. User may disable EDCA Turbo mode with OID settings.
-	if(pMgntInfo->IOTAction & HT_IOT_ACT_DISABLE_EDCA_TURBO){
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("IOTAction:EdcaTurboDisable\n"));
-		return	TRUE;
-		}
-		
-#elif(DM_ODM_SUPPORT_TYPE==ODM_CE)
-	//suggested by Jr.Luke: open TXOP for B/G/BG/A mode 2012-0215
-	if((WirelessMode==ODM_WM_B)||(WirelessMode==(ODM_WM_B|ODM_WM_G)||(WirelessMode==ODM_WM_G)||(WirelessMode=ODM_WM_A))
-		ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, ODM_Read4Byte(pDM_Odm, ODM_EDCA_BE_PARAM)|0x5E0000);	
-	
-	if(pDM_Odm->SupportICType==ODM_RTL8192D)		{
-		if ((pregpriv->wifi_spec == 1)  || (pmlmeext->cur_wireless_mode == WIRELESS_11B)) {
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("92D:EdcaTurboDisable\n"));
-			return TRUE;
-		}
-	}	
-	else
-	{
-		if((pregpriv->wifi_spec == 1) || (pmlmeinfo->HT_enable == 0)){
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("Others:EdcaTurboDisable\n"));
-			return TRUE;
-		}
-	}
-
-#endif
-
-	return	FALSE;
-	
-
-}
-
-//add iot case here: for MP/CE
-VOID 
-ODM_EdcaParaSelByIot(
-	IN 	PDM_ODM_T 	pDM_Odm,
-	OUT	u4Byte		*EDCA_BE_UL,
-	OUT u4Byte		*EDCA_BE_DL
-	)
-{
-
-	PADAPTER		       Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	u4Byte                         IOTPeer=0;
-	u4Byte                         ICType=pDM_Odm->SupportICType;
-	u1Byte                         WirelessMode=0xFF;                   //invalid value
-	u4Byte				RFType=pDM_Odm->RFType;
-	  u4Byte                         IOTPeerSubType=0;
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
-	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
-	u1Byte 				TwoPortStatus = (u1Byte)TWO_PORT_STATUS__WITHOUT_ANY_ASSOCIATE;
-
-#elif(DM_ODM_SUPPORT_TYPE==ODM_CE)
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	#ifdef CONFIG_BT_COEXIST
-	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);	
-	#endif
-       u1Byte bbtchange =FALSE;
-#endif
-
-	if(pDM_Odm->pWirelessMode!=NULL)
-		WirelessMode=*(pDM_Odm->pWirelessMode);
-		
-///////////////////////////////////////////////////////////
-////list paramter for different platform
-#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)	
-	IOTPeer=pMgntInfo->IOTPeer;
-	IOTPeerSubType=pMgntInfo->IOTPeerSubtype;
-	GetTwoPortSharedResource(Adapter,TWO_PORT_SHARED_OBJECT__STATUS,NULL,&TwoPortStatus);
-
-#elif(DM_ODM_SUPPORT_TYPE==ODM_CE)
-	IOTPeer=pmlmeinfo->assoc_AP_vendor;
-	#ifdef CONFIG_BT_COEXIST
-	if(pbtpriv->BT_Coexist)
-	{
-		if( (pbtpriv->BT_EDCA[UP_LINK]!=0) ||  (pbtpriv->BT_EDCA[DOWN_LINK]!=0))
-			bbtchange = TRUE;		
-	}
-	#endif
-
-#endif
-
-	if(ICType==ODM_RTL8192D)
-	{      
-		// Single PHY
-		if(pDM_Odm->RFType==ODM_2T2R)
-		{
-			(*EDCA_BE_UL) = 0x60a42b;    //0x5ea42b;
-			(*EDCA_BE_DL) = 0x60a42b;    //0x5ea42b;
-
-		}
-		else
-		{
-			(*EDCA_BE_UL) = 0x6ea42b;
-			(*EDCA_BE_DL) = 0x6ea42b;
-		}
-
-	}
-////============================
-/// IOT case for MP
-////============================	
-#if (DM_ODM_SUPPORT_TYPE==ODM_WIN)
-	else
-	{
-
-		if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE){
-			if((ICType==ODM_RTL8192C)&&(pDM_Odm->RFType==ODM_2T2R))			{
-				(*EDCA_BE_UL) = 0x60a42b;
-				(*EDCA_BE_DL) = 0x60a42b;
-			}
-			else
-			{
-				(*EDCA_BE_UL) = 0x6ea42b;
-				(*EDCA_BE_DL) = 0x6ea42b;
-			}
-		}
-	}
- 
-	if(TwoPortStatus == TWO_PORT_STATUS__EXTENSION_ONLY)
-	{
-		(*EDCA_BE_UL) = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_UL[ExtAdapter->MgntInfo.IOTPeer];
-		(*EDCA_BE_DL) = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_DL[ExtAdapter->MgntInfo.IOTPeer];
-	}
-     
-	#if (INTEL_PROXIMITY_SUPPORT == 1)
-	if(pMgntInfo->IntelClassModeInfo.bEnableCA == TRUE)
-	{
-		(*EDCA_BE_UL) = (*EDCA_BE_DL) = 0xa44f;
-	}
-	else
-	#endif		
-	{
-		if((!pMgntInfo->bDisableFrameBursting) && 
-			(pMgntInfo->IOTAction & (HT_IOT_ACT_FORCED_ENABLE_BE_TXOP|HT_IOT_ACT_AMSDU_ENABLE)))
-		{// To check whether we shall force turn on TXOP configuration.
-			if(!((*EDCA_BE_UL) & 0xffff0000))
-				(*EDCA_BE_UL) |= 0x005e0000; // Force TxOP limit to 0x005e for UL.
-			if(!((*EDCA_BE_DL) & 0xffff0000))
-				(*EDCA_BE_DL) |= 0x005e0000; // Force TxOP limit to 0x005e for DL.
-		}
-		
-		//92D txop can't be set to 0x3e for cisco1250
-		if((ICType!=ODM_RTL8192D) && (IOTPeer== HT_IOT_PEER_CISCO) &&(WirelessMode==ODM_WM_N24G))
-		{
-			(*EDCA_BE_DL) = edca_setting_DL[IOTPeer];
-			(*EDCA_BE_UL) = edca_setting_UL[IOTPeer];
-		}
-		//merge from 92s_92c_merge temp brunch v2445    20120215 
-		else if((IOTPeer == HT_IOT_PEER_CISCO) &&((WirelessMode==ODM_WM_G)||(WirelessMode==(ODM_WM_B|ODM_WM_G))||(WirelessMode==ODM_WM_A)||(WirelessMode==ODM_WM_B)))
-		{
-			(*EDCA_BE_DL) = edca_setting_DL_GMode[IOTPeer];
-		}
-		else if((IOTPeer== HT_IOT_PEER_AIRGO )&& ((WirelessMode==ODM_WM_G)||(WirelessMode==ODM_WM_A)))
-		{
-			(*EDCA_BE_DL) = 0xa630;
-		}
-
-		else if(IOTPeer == HT_IOT_PEER_MARVELL)
-		{
-			(*EDCA_BE_DL) = edca_setting_DL[IOTPeer];
-			(*EDCA_BE_UL) = edca_setting_UL[IOTPeer];
-		}
-		else if(IOTPeer == HT_IOT_PEER_ATHEROS)
-		{
-			// Set DL EDCA for Atheros peer to 0x3ea42b. Suggested by SD3 Wilson for ASUS TP issue. 
-			(*EDCA_BE_DL) = edca_setting_DL[IOTPeer];
-			
-			if(ICType == ODM_RTL8821)
-				 (*EDCA_BE_DL) = 0x5ea630;
-			
-		}
-	}
-
-    	if((ICType == ODM_RTL8192D)&&(IOTPeerSubType == HT_IOT_PEER_LINKSYS_E4200_V1)&&((WirelessMode==ODM_WM_N5G)))
-	{
-		(*EDCA_BE_DL) = 0x432b;
-		(*EDCA_BE_UL) = 0x432b;
-	}		
-
-
-
-	if((ICType==ODM_RTL8812)||(ICType==ODM_RTL8192E))           //add 8812AU/8812AE
-	{
-		(*EDCA_BE_UL) = 0x5ea42b;
-		(*EDCA_BE_DL) = 0x5ea42b;
-
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("8812A: EDCA_BE_UL=0x%lx EDCA_BE_DL =0x%lx",(*EDCA_BE_UL),(*EDCA_BE_DL)));
-	}
-
-	// Revised for Atheros DIR-655 IOT issue to improve down link TP, added by Roger, 2013.03.22.
-	if((ICType == ODM_RTL8723A) && (IOTPeerSubType== HT_IOT_PEER_ATHEROS_DIR655) && 
-		(pMgntInfo->dot11CurrentChannelNumber == 6))
-	{
-		(*EDCA_BE_DL) = 0xa92b;
-	}
-
-////============================
-/// IOT case for CE 
-////============================
-#elif (DM_ODM_SUPPORT_TYPE==ODM_CE)
-
-	if(RFType==ODM_RTL8192D)
-	{
-		if((IOTPeer == HT_IOT_PEER_CISCO) &&(WirelessMode==ODM_WM_N24G))
-		{
-			(*EDCA_BE_UL) = EDCAParam[IOTPeer][UP_LINK];
-			(*EDCA_BE_DL)=EDCAParam[IOTPeer][DOWN_LINK];
-		}
-		else if((IOTPeer == HT_IOT_PEER_AIRGO) &&
-			((WirelessMode==ODM_WM_B)||(WirelessMode==(ODM_WM_B|ODM_WM_G)))) 
-			(*EDCA_BE_DL)=0x00a630;
-		
-		else if((IOTPeer== HT_IOT_PEER_ATHEROS) && 
-					(WirelessMode&ODM_WM_N5G) &&
-					(Adapter->securitypriv.dot11PrivacyAlgrthm == _AES_ ))
-			(*EDCA_BE_DL)=0xa42b;
-			
-	}
-	//92C IOT case:
-	else
-	{
-		#ifdef CONFIG_BT_COEXIST
-		if(bbtchange)
-		{
-			(*EDCA_BE_UL) = pbtpriv->BT_EDCA[UP_LINK];
-			(*EDCA_BE_DL) = pbtpriv->BT_EDCA[DOWN_LINK];		
-		}
-		else
-		#endif
-		{
-			if((IOTPeer == HT_IOT_PEER_CISCO) &&(WirelessMode==ODM_WM_N24G))
-			{
-				(*EDCA_BE_UL) = EDCAParam[IOTPeer][UP_LINK];
-				(*EDCA_BE_DL)=EDCAParam[IOTPeer][DOWN_LINK];
-			}
-			else
-			{
-				(*EDCA_BE_UL)=EDCAParam[HT_IOT_PEER_UNKNOWN][UP_LINK];
-				(*EDCA_BE_DL)=EDCAParam[HT_IOT_PEER_UNKNOWN][DOWN_LINK];
-			}
-		}
-		if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE){
-			if((ICType==ODM_RTL8192C)&&(pDM_Odm->RFType==ODM_2T2R))
-			{
-				(*EDCA_BE_UL) = 0x60a42b;
-				(*EDCA_BE_DL) = 0x60a42b;
-			}
-			else
-			{
-				(*EDCA_BE_UL) = 0x6ea42b;
-				(*EDCA_BE_DL) = 0x6ea42b;
-			}
-		}
-
-	}
-#endif
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Special: EDCA_BE_UL=0x%lx EDCA_BE_DL =0x%lx",(*EDCA_BE_UL),(*EDCA_BE_DL)));
-
-}
-
-
-VOID
-odm_EdcaChooseTrafficIdx( 
-	IN	PDM_ODM_T		pDM_Odm,
-	IN	u8Byte  			cur_tx_bytes,  
-	IN	u8Byte  			cur_rx_bytes, 
-	IN	BOOLEAN 		bBiasOnRx,
-	OUT BOOLEAN 		*pbIsCurRDLState
-	)
-{	
-	
-	
-	if(bBiasOnRx)
-	{
-	  
-		if(cur_tx_bytes>(cur_rx_bytes*4))
-		{
-			*pbIsCurRDLState=FALSE;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Uplink Traffic\n "));
-
-		}
-		else
-		{
-			*pbIsCurRDLState=TRUE;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Balance Traffic\n"));
-
-		}
-	}
-	else
-	{
-		if(cur_rx_bytes>(cur_tx_bytes*4))
-		{
-			*pbIsCurRDLState=TRUE;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Downlink	Traffic\n"));
-
-		}
-		else
-		{
-			*pbIsCurRDLState=FALSE;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Balance Traffic\n"));
-		}
-	}
-
-	return ;
-}
-
-#endif
-
-#if((DM_ODM_SUPPORT_TYPE==ODM_AP)||(DM_ODM_SUPPORT_TYPE==ODM_ADSL))
-
-void odm_EdcaParaInit(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-	prtl8192cd_priv	priv		= pDM_Odm->priv;
-	int   mode=priv->pmib->dot11BssType.net_work_type;
-	
-	static unsigned int slot_time, VO_TXOP, VI_TXOP, sifs_time;
-	struct ParaRecord EDCA[4];
-
-	 memset(EDCA, 0, 4*sizeof(struct ParaRecord));
-
-	sifs_time = 10;
-	slot_time = 20;
-
-	if (mode & (ODM_WM_N24G|ODM_WM_N5G))
-		sifs_time = 16;
-
-	if (mode & (ODM_WM_N24G|ODM_WM_N5G| ODM_WM_G|ODM_WM_A))
-		slot_time = 9;
-
-
-#if((defined(RTL_MANUAL_EDCA))&&(DM_ODM_SUPPORT_TYPE==ODM_AP))
-	 if( priv->pmib->dot11QosEntry.ManualEDCA ) {
-		 if( OPMODE & WIFI_AP_STATE )
-			 memcpy(EDCA, priv->pmib->dot11QosEntry.AP_manualEDCA, 4*sizeof(struct ParaRecord));
-		 else
-			 memcpy(EDCA, priv->pmib->dot11QosEntry.STA_manualEDCA, 4*sizeof(struct ParaRecord));
-
-		#ifdef WIFI_WMM
-		if (QOS_ENABLE)
-			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, (EDCA[VI].TXOPlimit<< 16) | (EDCA[VI].ECWmax<< 12) | (EDCA[VI].ECWmin<< 8) | (sifs_time + EDCA[VI].AIFSN* slot_time));
-		else
-		#endif
-			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, (EDCA[BE].TXOPlimit<< 16) | (EDCA[BE].ECWmax<< 12) | (EDCA[BE].ECWmin<< 8) | (sifs_time + EDCA[VI].AIFSN* slot_time));
-
-	}else
-	#endif //RTL_MANUAL_EDCA
-	{
-
-		 if(OPMODE & WIFI_AP_STATE)
-		 {
-		 	memcpy(EDCA, rtl_ap_EDCA, 2*sizeof(struct ParaRecord));
-
-			if(mode & (ODM_WM_A|ODM_WM_G|ODM_WM_N24G|ODM_WM_N5G))
-				memcpy(&EDCA[VI], &rtl_ap_EDCA[VI_AG], 2*sizeof(struct ParaRecord));
-			else
-				memcpy(&EDCA[VI], &rtl_ap_EDCA[VI], 2*sizeof(struct ParaRecord));
-		 }
-		 else
-		 {
-		 	memcpy(EDCA, rtl_sta_EDCA, 2*sizeof(struct ParaRecord));
-
-			if(mode & (ODM_WM_A|ODM_WM_G|ODM_WM_N24G|ODM_WM_N5G))
-				memcpy(&EDCA[VI], &rtl_sta_EDCA[VI_AG], 2*sizeof(struct ParaRecord));
-			else
-				memcpy(&EDCA[VI], &rtl_sta_EDCA[VI], 2*sizeof(struct ParaRecord));
-		 }
-		 
-	#ifdef WIFI_WMM
-		if (QOS_ENABLE)
-			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, (EDCA[VI].TXOPlimit<< 16) | (EDCA[VI].ECWmax<< 12) | (EDCA[VI].ECWmin<< 8) | (sifs_time + EDCA[VI].AIFSN* slot_time));
-		else
-	#endif
-
-#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
-			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM,  (EDCA[BK].ECWmax<< 12) | (EDCA[BK].ECWmin<< 8) | (sifs_time + EDCA[VI].AIFSN* slot_time));
-#elif(DM_ODM_SUPPORT_TYPE==ODM_ADSL)
-			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM,  (EDCA[BK].ECWmax<< 12) | (EDCA[BK].ECWmin<< 8) | (sifs_time + 2* slot_time));
-#endif
-			
-
-	}
-
-	ODM_Write4Byte(pDM_Odm, ODM_EDCA_VO_PARAM, (EDCA[VO].TXOPlimit<< 16) | (EDCA[VO].ECWmax<< 12) | (EDCA[VO].ECWmin<< 8) | (sifs_time + EDCA[VO].AIFSN* slot_time));
-	ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM,  (EDCA[BE].TXOPlimit<< 16) | (EDCA[BE].ECWmax<< 12) | (EDCA[BE].ECWmin<< 8) | (sifs_time + EDCA[BE].AIFSN* slot_time));
-	ODM_Write4Byte(pDM_Odm, ODM_EDCA_BK_PARAM, (EDCA[BK].TXOPlimit<< 16) | (EDCA[BK].ECWmax<< 12) | (EDCA[BK].ECWmin<< 8) | (sifs_time + EDCA[BK].AIFSN* slot_time));
-//	ODM_Write1Byte(pDM_Odm,ACMHWCTRL, 0x00);
-
-	priv->pshare->iot_mode_enable = 0;
-#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-	if (priv->pshare->rf_ft_var.wifi_beq_iot)
-		priv->pshare->iot_mode_VI_exist = 0;
-	
-	#ifdef WMM_VIBE_PRI
-	priv->pshare->iot_mode_BE_exist = 0;
-	#endif
-	
-	#ifdef LOW_TP_TXOP
-	priv->pshare->BE_cwmax_enhance = 0;
-	#endif
-
-#elif (DM_ODM_SUPPORT_TYPE==ODM_ADSL)
-      priv->pshare->iot_mode_BE_exist = 0;   
-#endif
-	priv->pshare->iot_mode_VO_exist = 0;
-}
-
-BOOLEAN
-ODM_ChooseIotMainSTA(
-	IN	PDM_ODM_T		pDM_Odm,
-	IN	PSTA_INFO_T		pstat
-	)
-{
-	prtl8192cd_priv	priv = pDM_Odm->priv;
-	BOOLEAN		bhighTP_found_pstat=FALSE;
-	
-	if ((GET_ROOT(priv)->up_time % 2) == 0) {
-		unsigned int tx_2s_avg = 0;
-		unsigned int rx_2s_avg = 0;
-		int i=0, aggReady=0;
-		unsigned long total_sum = (priv->pshare->current_tx_bytes+priv->pshare->current_rx_bytes);
-
-		pstat->current_tx_bytes += pstat->tx_byte_cnt;
-		pstat->current_rx_bytes += pstat->rx_byte_cnt;
-
-		if (total_sum != 0) {
-			if (total_sum <= 100) {
-			tx_2s_avg = (unsigned int)((pstat->current_tx_bytes*100) / total_sum);
-			rx_2s_avg = (unsigned int)((pstat->current_rx_bytes*100) / total_sum);
-			} else {
-				tx_2s_avg = (unsigned int)(pstat->current_tx_bytes / (total_sum / 100));
-				rx_2s_avg = (unsigned int)(pstat->current_rx_bytes / (total_sum / 100));
-			}
-
-		}
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_ADSL)
-		if (pstat->ht_cap_len) {
-			if ((tx_2s_avg + rx_2s_avg) >=25 /*50*/) {
-
-					priv->pshare->highTP_found_pstat = pstat;
-					bhighTP_found_pstat=TRUE;
-   				}
-			}
-#elif(DM_ODM_SUPPORT_TYPE==ODM_AP)
-		for(i=0; i<8; i++)
-			aggReady += (pstat->ADDBA_ready[i]);
-		if (pstat->ht_cap_len && aggReady) 
-		{
-			if ((tx_2s_avg + rx_2s_avg >= 25)) {
-				priv->pshare->highTP_found_pstat = pstat;
-			}
-			
-		#ifdef CLIENT_MODE
-			if (OPMODE & WIFI_STATION_STATE) {
-#if (DM_ODM_SUPPORT_TYPE &ODM_AP) && defined(USE_OUT_SRC)
-				if ((pstat->IOTPeer==HT_IOT_PEER_RALINK) && ((tx_2s_avg + rx_2s_avg) >= 45))
-#else
-				if(pstat->is_ralink_sta && ((tx_2s_avg + rx_2s_avg) >= 45))
-#endif					
-					priv->pshare->highTP_found_pstat = pstat;
-		}
-		#endif				
-	}
-#endif
-	} else {
-		pstat->current_tx_bytes = pstat->tx_byte_cnt;
-		pstat->current_rx_bytes = pstat->rx_byte_cnt;
-	}
-
-	return bhighTP_found_pstat;
-}
-
-
-#ifdef WIFI_WMM
-VOID
-ODM_IotEdcaSwitch(
-	IN	PDM_ODM_T		pDM_Odm,
-	IN	unsigned char		enable
-	)
-{
-	prtl8192cd_priv	priv	= pDM_Odm->priv;
-	int   mode=priv->pmib->dot11BssType.net_work_type;
-	unsigned int slot_time = 20, sifs_time = 10, BE_TXOP = 47, VI_TXOP = 94;
-	unsigned int vi_cw_max = 4, vi_cw_min = 3, vi_aifs;
-
-#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
-	if (!(!priv->pmib->dot11OperationEntry.wifi_specific ||
-		((OPMODE & WIFI_AP_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))
-	#ifdef CLIENT_MODE
-		|| ((OPMODE & WIFI_STATION_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))
-	#endif
-		))
-		return;
-#endif
-
-	if ((mode & (ODM_WM_N24G|ODM_WM_N5G)) && (priv->pshare->ht_sta_num
-	#ifdef WDS
-		|| ((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11WdsInfo.wdsEnabled && priv->pmib->dot11WdsInfo.wdsNum)
-	#endif
-		))
-		sifs_time = 16;
-
-	if (mode & (ODM_WM_N24G|ODM_WM_N5G|ODM_WM_G|ODM_WM_A)) {
-		slot_time = 9;
-	} 
-	else
-	{
-		BE_TXOP = 94;
-		VI_TXOP = 188;
-	}
-
-#if (DM_ODM_SUPPORT_TYPE==ODM_ADSL)
-	if (priv->pshare->iot_mode_VO_exist) {
-		// to separate AC_VI and AC_BE to avoid using the same EDCA settings
-		if (priv->pshare->iot_mode_BE_exist) {
-			vi_cw_max = 5;
-			vi_cw_min = 3;
-		} else {
-			vi_cw_max = 6;
-			vi_cw_min = 4;
-		}
-	}
-	vi_aifs = (sifs_time + ((OPMODE & WIFI_AP_STATE)?1:2) * slot_time);
-
-	ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, ((VI_TXOP*(1-priv->pshare->iot_mode_VO_exist)) << 16)| (vi_cw_max << 12) | (vi_cw_min << 8) | vi_aifs);
-
-	
-#elif (DM_ODM_SUPPORT_TYPE==ODM_AP)
-	if ((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11OperationEntry.wifi_specific) {
-		if (priv->pshare->iot_mode_VO_exist) {
-	#ifdef WMM_VIBE_PRI
-			if (priv->pshare->iot_mode_BE_exist) 
-			{
-				vi_cw_max = 5;
-				vi_cw_min = 3;
-				vi_aifs = (sifs_time + ((OPMODE & WIFI_AP_STATE)?1:2) * slot_time);
-			}
-			else 
-	#endif
-			{
-			vi_cw_max = 6;
-			vi_cw_min = 4;
-			vi_aifs = 0x2b;
-			}
-		} 
-		else {
-			vi_aifs = (sifs_time + ((OPMODE & WIFI_AP_STATE)?1:2) * slot_time);
-		}
-
-		ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, ((VI_TXOP*(1-priv->pshare->iot_mode_VO_exist)) << 16)
-			| (vi_cw_max << 12) | (vi_cw_min << 8) | vi_aifs);
-	}
-#endif
-
-
-
-#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
- 	if (priv->pshare->rf_ft_var.wifi_beq_iot && priv->pshare->iot_mode_VI_exist) 
-	  	ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (10 << 12) | (4 << 8) | 0x4f);
-	else if(!enable)
-#elif(DM_ODM_SUPPORT_TYPE==ODM_ADSL)      
-	if(!enable)                                 //if iot is disable ,maintain original BEQ PARAM
-#endif
-		ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (((OPMODE & WIFI_AP_STATE)?6:10) << 12) | (4 << 8)
-			| (sifs_time + 3 * slot_time));
-	else
-	{
-		int txop_enlarge;
-		int txop;
-		unsigned int cw_max;
-		unsigned int txop_close;
-		
-	#if((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined LOW_TP_TXOP))
-			cw_max = ((priv->pshare->BE_cwmax_enhance) ? 10 : 6);
-			txop_close = ((priv->pshare->rf_ft_var.low_tp_txop && priv->pshare->rf_ft_var.low_tp_txop_close) ? 1 : 0);
-
-			if(priv->pshare->txop_enlarge == 0xe)   //if intel case
-				txop = (txop_close ? 0 : (BE_TXOP*2));
-			else                                                        //if other case
-				txop = (txop_close ? 0: (BE_TXOP*priv->pshare->txop_enlarge));
-	#else
-			cw_max=6;
-			if((priv->pshare->txop_enlarge==0xe)||(priv->pshare->txop_enlarge==0xd))
-				txop=BE_TXOP*2;
-			else
-				txop=BE_TXOP*priv->pshare->txop_enlarge;
-
-	#endif
-                           
-		if (priv->pshare->ht_sta_num
-	#ifdef WDS
-			|| ((OPMODE & WIFI_AP_STATE) && (mode & (ODM_WM_N24G|ODM_WM_N5G)) &&
-			priv->pmib->dot11WdsInfo.wdsEnabled && priv->pmib->dot11WdsInfo.wdsNum)
-	#endif
-			) 
-			{
-
-			if (priv->pshare->txop_enlarge == 0xe) {
-				// is intel client, use a different edca value
-				ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop<< 16) | (cw_max<< 12) | (4 << 8) | 0x1f);
-				priv->pshare->txop_enlarge = 2;
-			} 
-#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-	#ifndef LOW_TP_TXOP
-			 else if (priv->pshare->txop_enlarge == 0xd) {
-				// is intel ralink, use a different edca value
-				ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) | (4 << 12) | (3 << 8) | 0x19);
-				priv->pshare->txop_enlarge = 2;
-			} 
-	#endif
-#endif
-			else 
-			{
-				if (pDM_Odm->RFType==ODM_2T2R)
-					ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) |
-						(cw_max << 12) | (4 << 8) | (sifs_time + 3 * slot_time));
-				else
-				#if(DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined LOW_TP_TXOP)
-					ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) |
-						(((priv->pshare->BE_cwmax_enhance) ? 10 : 5) << 12) | (3 << 8) | (sifs_time + 2 * slot_time));
-				#else
-					ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) |
-						(5 << 12) | (3 << 8) | (sifs_time + 2 * slot_time));
-
-				#endif
-			}
-		}
-              else 
-              {
- #if((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined LOW_TP_TXOP))
-			 ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (BE_TXOP << 16) | (cw_max << 12) | (4 << 8) | (sifs_time + 3 * slot_time));
- #else
- 		#if defined(CONFIG_RTL_8196D) || defined(CONFIG_RTL_8196E) || (defined(CONFIG_RTL_8197D) && !defined(CONFIG_PORT0_EXT_GIGA))
-			ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM,  (BE_TXOP*2 << 16) | (cw_max << 12) | (5 << 8) | (sifs_time + 3 * slot_time));
-		#else
-			ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM,  (BE_TXOP*2 << 16) | (cw_max << 12) | (4 << 8) | (sifs_time + 3 * slot_time));
-		#endif
-		
- #endif
-              }
-
-	}
-}
-#endif
-
-VOID 
-odm_IotEngine(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-
-	struct rtl8192cd_priv *priv=pDM_Odm->priv;
-	PSTA_INFO_T pstat = NULL;
-	u4Byte i;
-	
-#ifdef WIFI_WMM
-	unsigned int switch_turbo = 0;
-#endif	
-////////////////////////////////////////////////////////
-//  if EDCA Turbo function is not supported or Manual EDCA Setting
-//  then return
-////////////////////////////////////////////////////////
-	if(!(pDM_Odm->SupportAbility&ODM_MAC_EDCA_TURBO)){
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("ODM_MAC_EDCA_TURBO NOT SUPPORTED\n"));
-		return;
-	}
-	
-#if((DM_ODM_SUPPORT_TYPE==ODM_AP)&& defined(RTL_MANUAL_EDCA) && defined(WIFI_WMM))
-	if(priv->pmib->dot11QosEntry.ManualEDCA){
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("ODM_MAC_EDCA_TURBO OFF: MANUAL SETTING\n"));
-		return ;
-	}
-#endif 
-
-#if !(DM_ODM_SUPPORT_TYPE &ODM_AP)
- //////////////////////////////////////////////////////
- //find high TP STA every 2s
-//////////////////////////////////////////////////////
-	if ((GET_ROOT(priv)->up_time % 2) == 0) 
-		priv->pshare->highTP_found_pstat==NULL;
-
-#if 0
-	phead = &priv->asoc_list;
-	plist = phead->next;
-	while(plist != phead)	{
-		pstat = list_entry(plist, struct stat_info, asoc_list);
-
-		if(ODM_ChooseIotMainSTA(pDM_Odm, pstat));              //find the correct station
-			break;
-		if (plist == plist->next)                                          //the last plist 
-			break;
-		plist = plist->next;
-	};
-#endif
-
-	//find highTP STA
-	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++) {
-		pstat = pDM_Odm->pODM_StaInfo[i];
-		if(IS_STA_VALID(pstat) && (ODM_ChooseIotMainSTA(pDM_Odm, pstat)))	 //find the correct station
-				break;
-	}
-
- //////////////////////////////////////////////////////
- //if highTP STA is not found, then return
- //////////////////////////////////////////////////////
-	if(priv->pshare->highTP_found_pstat==NULL)	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("ODM_MAC_EDCA_TURBO OFF: NO HT STA FOUND\n"));
-		return;
-	}
-#endif
-
-	pstat=priv->pshare->highTP_found_pstat;
-
-
-#ifdef WIFI_WMM
-	if (QOS_ENABLE) {
-		if (!priv->pmib->dot11OperationEntry.wifi_specific 
-		#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-			||((OPMODE & WIFI_AP_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))
-		#elif(DM_ODM_SUPPORT_TYPE==ODM_ADSL)
-			|| (priv->pmib->dot11OperationEntry.wifi_specific == 2)
-		#endif
-			) {
-			if (priv->pshare->iot_mode_enable &&
-				((priv->pshare->phw->VO_pkt_count > 50) ||
-				 (priv->pshare->phw->VI_pkt_count > 50) ||
-				 (priv->pshare->phw->BK_pkt_count > 50))) {
-				priv->pshare->iot_mode_enable = 0;
-				switch_turbo++;
-			} else if ((!priv->pshare->iot_mode_enable) &&
-				((priv->pshare->phw->VO_pkt_count < 50) &&
-				 (priv->pshare->phw->VI_pkt_count < 50) &&
-				 (priv->pshare->phw->BK_pkt_count < 50))) {
-				priv->pshare->iot_mode_enable++;
-				switch_turbo++;
-			}
-		}
-
-
-		#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-		if ((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11OperationEntry.wifi_specific)
-		#elif (DM_ODM_SUPPORT_TYPE==ODM_ADSL)
-		if (priv->pmib->dot11OperationEntry.wifi_specific) 
-		#endif
-		{
-			if (!priv->pshare->iot_mode_VO_exist && (priv->pshare->phw->VO_pkt_count > 50)) {
-				priv->pshare->iot_mode_VO_exist++;
-				switch_turbo++;
-			} else if (priv->pshare->iot_mode_VO_exist && (priv->pshare->phw->VO_pkt_count < 50)) {
-				priv->pshare->iot_mode_VO_exist = 0;
-				switch_turbo++;
-			}
-#if((DM_ODM_SUPPORT_TYPE==ODM_ADSL)||((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined WMM_VIBE_PRI)))
-			if (priv->pshare->iot_mode_VO_exist) {
-				//printk("[%s %d] BE_pkt_count=%d\n", __FUNCTION__, __LINE__, priv->pshare->phw->BE_pkt_count);
-				if (!priv->pshare->iot_mode_BE_exist && (priv->pshare->phw->BE_pkt_count > 250)) {
-					priv->pshare->iot_mode_BE_exist++;
-					switch_turbo++;
-				} else if (priv->pshare->iot_mode_BE_exist && (priv->pshare->phw->BE_pkt_count < 250)) {
-					priv->pshare->iot_mode_BE_exist = 0;
-					switch_turbo++;
-				}
-			}
-#endif
-
-#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
-			if (priv->pshare->rf_ft_var.wifi_beq_iot) 
-			{
-				if (!priv->pshare->iot_mode_VI_exist && (priv->pshare->phw->VI_rx_pkt_count > 50)) {
-					priv->pshare->iot_mode_VI_exist++;
-					switch_turbo++;
-				} else if (priv->pshare->iot_mode_VI_exist && (priv->pshare->phw->VI_rx_pkt_count < 50)) {
-					priv->pshare->iot_mode_VI_exist = 0;
-					switch_turbo++;
-				}
-			}
-#endif
-
-		}
-		else if (!pstat || pstat->rssi < priv->pshare->rf_ft_var.txop_enlarge_lower) {
-		   if (priv->pshare->txop_enlarge) {
-			   priv->pshare->txop_enlarge = 0;
-			   if (priv->pshare->iot_mode_enable)
-					switch_turbo++;
-				}
-         	}
-
-#if(defined(CLIENT_MODE) && (DM_ODM_SUPPORT_TYPE==ODM_AP))
-        if ((OPMODE & WIFI_STATION_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))
-        {
-            if (priv->pshare->iot_mode_enable &&
-                (((priv->pshare->phw->VO_pkt_count > 50) ||
-                 (priv->pshare->phw->VI_pkt_count > 50) ||
-                 (priv->pshare->phw->BK_pkt_count > 50)) ||
-                 (pstat && (!pstat->ADDBA_ready[0]) & (!pstat->ADDBA_ready[3]))))
-            {
-                priv->pshare->iot_mode_enable = 0;
-                switch_turbo++;
-            }
-            else if ((!priv->pshare->iot_mode_enable) &&
-                (((priv->pshare->phw->VO_pkt_count < 50) &&
-                 (priv->pshare->phw->VI_pkt_count < 50) &&
-                 (priv->pshare->phw->BK_pkt_count < 50)) &&
-                 (pstat && (pstat->ADDBA_ready[0] | pstat->ADDBA_ready[3]))))
-            {
-                priv->pshare->iot_mode_enable++;
-                switch_turbo++;
-            }
-        }
-#endif
-
-		priv->pshare->phw->VO_pkt_count = 0;
-		priv->pshare->phw->VI_pkt_count = 0;
-		priv->pshare->phw->BK_pkt_count = 0;
-
-	#if((DM_ODM_SUPPORT_TYPE==ODM_ADSL)||((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined WMM_VIBE_PRI)))
-		priv->pshare->phw->BE_pkt_count = 0;
-	#endif
-		
-	#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-		if (priv->pshare->rf_ft_var.wifi_beq_iot)
-			priv->pshare->phw->VI_rx_pkt_count = 0;
-		#endif
-
-	}
-#endif
-
-	if ((priv->up_time % 2) == 0) {
-		/*
-		 * decide EDCA content for different chip vendor
-		 */
-#ifdef WIFI_WMM
-	#if(DM_ODM_SUPPORT_TYPE==ODM_ADSL)
-		if (QOS_ENABLE && (!priv->pmib->dot11OperationEntry.wifi_specific || (priv->pmib->dot11OperationEntry.wifi_specific == 2)
-	
-	#elif(DM_ODM_SUPPORT_TYPE==ODM_AP)
-		if (QOS_ENABLE && (!priv->pmib->dot11OperationEntry.wifi_specific || 
-			((OPMODE & WIFI_AP_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))
-		#ifdef CLIENT_MODE
-            || ((OPMODE & WIFI_STATION_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))
-		#endif
-	#endif
-		))
-	
-		{
-
-			if (pstat && pstat->rssi >= priv->pshare->rf_ft_var.txop_enlarge_upper) {
-#ifdef LOW_TP_TXOP
-#if (DM_ODM_SUPPORT_TYPE &ODM_AP) && defined(USE_OUT_SRC)
-				if (pstat->IOTPeer==HT_IOT_PEER_INTEL)
-#else
-				if (pstat->is_intel_sta)
-#endif					
-				{
-					if (priv->pshare->txop_enlarge != 0xe)
-					{
-						priv->pshare->txop_enlarge = 0xe;
-
-						if (priv->pshare->iot_mode_enable)
-							switch_turbo++;
-					}
-				} 
-				else if (priv->pshare->txop_enlarge != 2) 
-				{
-					priv->pshare->txop_enlarge = 2;
-					if (priv->pshare->iot_mode_enable)
-						switch_turbo++;
-				}
-#else
-				if (priv->pshare->txop_enlarge != 2)
-				{
-#if (DM_ODM_SUPPORT_TYPE &ODM_AP) && defined(USE_OUT_SRC)
-					if (pstat->IOTPeer==HT_IOT_PEER_INTEL)
-#else				
-					if (pstat->is_intel_sta)
-#endif						
-						priv->pshare->txop_enlarge = 0xe;						
-#if (DM_ODM_SUPPORT_TYPE &ODM_AP) && defined(USE_OUT_SRC)
-					else if (pstat->IOTPeer==HT_IOT_PEER_RALINK)
-#else
-					else if (pstat->is_ralink_sta)
-#endif						
-						priv->pshare->txop_enlarge = 0xd;						
-					else
-						priv->pshare->txop_enlarge = 2;
-
-					if (priv->pshare->iot_mode_enable)
-						switch_turbo++;
-				}
-#endif
-#if 0
-				if (priv->pshare->txop_enlarge != 2) 
-				{
-				#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-					if (pstat->IOTPeer==HT_IOT_PEER_INTEL)
-				#else
-					if (pstat->is_intel_sta)
-				#endif					
-						priv->pshare->txop_enlarge = 0xe;
-				#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-					else if (pstat->IOTPeer==HT_IOT_PEER_RALINK)
-						priv->pshare->txop_enlarge = 0xd;						
-				#endif
-					else
-						priv->pshare->txop_enlarge = 2;
-					if (priv->pshare->iot_mode_enable)
-						switch_turbo++;
-				}
-#endif
-			}
-			else if (!pstat || pstat->rssi < priv->pshare->rf_ft_var.txop_enlarge_lower) 
-			{
-				if (priv->pshare->txop_enlarge) {
-					priv->pshare->txop_enlarge = 0;
-					if (priv->pshare->iot_mode_enable)
-						switch_turbo++;
-				}
-			}
-
-#if((DM_ODM_SUPPORT_TYPE==ODM_AP)&&( defined LOW_TP_TXOP))
-			// for Intel IOT, need to enlarge CW MAX from 6 to 10
-			if (pstat && pstat->is_intel_sta && (((pstat->tx_avarage+pstat->rx_avarage)>>10) < 
-					priv->pshare->rf_ft_var.cwmax_enhance_thd)) 
-			{
-				if (!priv->pshare->BE_cwmax_enhance && priv->pshare->iot_mode_enable)
-				{
-					priv->pshare->BE_cwmax_enhance = 1;
-					switch_turbo++;
-				}
-			} else {
-				if (priv->pshare->BE_cwmax_enhance) {
-					priv->pshare->BE_cwmax_enhance = 0;
-					switch_turbo++;
-				}
-			}
-#endif
-		}
-#endif
-		priv->pshare->current_tx_bytes = 0;
-		priv->pshare->current_rx_bytes = 0;
-	}
-	
-#if((DM_ODM_SUPPORT_TYPE==ODM_AP)&& defined( SW_TX_QUEUE))
-	if ((priv->assoc_num > 1) && (AMPDU_ENABLE))
-   	{
-       	if (priv->swq_txmac_chg >= priv->pshare->rf_ft_var.swq_en_highthd){
-			if ((priv->swq_en == 0)){
-				switch_turbo++;
-				if (priv->pshare->txop_enlarge == 0)
-					priv->pshare->txop_enlarge = 2;
-				priv->swq_en = 1;
-				}
-			else
-			{
-				if ((switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))
-				{
-					priv->pshare->txop_enlarge = 2;
-					switch_turbo--;
-				}
-			}
-		}
-		else if(priv->swq_txmac_chg <= priv->pshare->rf_ft_var.swq_dis_lowthd){
-			priv->swq_en = 0;
-		}
-		else if ((priv->swq_en == 1) && (switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))        {
-			priv->pshare->txop_enlarge = 2;
-			switch_turbo--;
-		}
-    }
-#if ((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined CONFIG_RTL_819XD))
-    else if( (priv->assoc_num == 1) && (AMPDU_ENABLE)) {		
-        if (pstat) {
-			int en_thd = 14417920>>(priv->up_time % 2);
-            if ((priv->swq_en == 0) && (pstat->current_tx_bytes > en_thd) && (pstat->current_rx_bytes > en_thd) )  { //50Mbps
-                priv->swq_en = 1;
-				priv->swqen_keeptime = priv->up_time;
-            }
-            else if ((priv->swq_en == 1) && ((pstat->tx_avarage < 4587520) || (pstat->rx_avarage < 4587520))) { //35Mbps
-                priv->swq_en = 0;
-				priv->swqen_keeptime = 0;
-            }
-        }
-        else {
-            priv->swq_en = 0;
-			priv->swqen_keeptime = 0;
-        }
-    }
-#endif
-#endif
-
-#ifdef WIFI_WMM
-#ifdef LOW_TP_TXOP
-	if ((!priv->pmib->dot11OperationEntry.wifi_specific || (priv->pmib->dot11OperationEntry.wifi_specific == 2))
-		&& QOS_ENABLE) {
-		if (switch_turbo || priv->pshare->rf_ft_var.low_tp_txop) {
-			unsigned int thd_tp;
-			unsigned char under_thd;
-			unsigned int curr_tp;
-
-			if (priv->pmib->dot11BssType.net_work_type & (ODM_WM_N24G|ODM_WM_N5G| ODM_WM_G))
-			{
-				// Determine the upper bound throughput threshold.
-				if (priv->pmib->dot11BssType.net_work_type & (ODM_WM_N24G|ODM_WM_N5G)) {
-					if (priv->assoc_num && priv->assoc_num != priv->pshare->ht_sta_num)
-						thd_tp = priv->pshare->rf_ft_var.low_tp_txop_thd_g;
-					else
-						thd_tp = priv->pshare->rf_ft_var.low_tp_txop_thd_n;
-				}
-				else
-					thd_tp = priv->pshare->rf_ft_var.low_tp_txop_thd_g;
-
-				// Determine to close txop.
-				curr_tp = (unsigned int)(priv->ext_stats.tx_avarage>>17) + (unsigned int)(priv->ext_stats.rx_avarage>>17);
-				if (curr_tp <= thd_tp && curr_tp >= priv->pshare->rf_ft_var.low_tp_txop_thd_low)
-					under_thd = 1;
-				else
-					under_thd = 0;
-			}
-			else
-			{
-				under_thd = 0;
-			}
-
-			if (switch_turbo) 
-			{
-				priv->pshare->rf_ft_var.low_tp_txop_close = under_thd;
-				priv->pshare->rf_ft_var.low_tp_txop_count = 0;
-			}
-			else if (priv->pshare->iot_mode_enable && (priv->pshare->rf_ft_var.low_tp_txop_close != under_thd)) {
-				priv->pshare->rf_ft_var.low_tp_txop_count++;
-				if (priv->pshare->rf_ft_var.low_tp_txop_close) {
-					priv->pshare->rf_ft_var.low_tp_txop_count = priv->pshare->rf_ft_var.low_tp_txop_delay;
-				}
-				if (priv->pshare->rf_ft_var.low_tp_txop_count ==priv->pshare->rf_ft_var.low_tp_txop_delay) 
-
-				{					
-					priv->pshare->rf_ft_var.low_tp_txop_count = 0;
-					priv->pshare->rf_ft_var.low_tp_txop_close = under_thd;
-					switch_turbo++;
-				}
-			} 
-			else 
-			{
-				priv->pshare->rf_ft_var.low_tp_txop_count = 0;
-			}
-		}
-	}
-#endif		
-
-	if (switch_turbo)
-		ODM_IotEdcaSwitch( pDM_Odm, priv->pshare->iot_mode_enable );
-#endif
-}
-#endif
-
-
-#if( DM_ODM_SUPPORT_TYPE == ODM_WIN) 
-//
-// 2011/07/26 MH Add an API for testing IQK fail case.
-//
-BOOLEAN
-ODM_CheckPowerStatus(
-	IN	PADAPTER		Adapter)
-{
-
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
-	RT_RF_POWER_STATE 	rtState;
-	PMGNT_INFO			pMgntInfo	= &(Adapter->MgntInfo);
-
-	// 2011/07/27 MH We are not testing ready~~!! We may fail to get correct value when init sequence.
-	if (pMgntInfo->init_adpt_in_progress == TRUE)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return TRUE, due to initadapter"));
-		return	TRUE;
-	}
-	
-	//
-	//	2011/07/19 MH We can not execute tx pwoer tracking/ LLC calibrate or IQK.
-	//
-	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));	
-	if(Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff)
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n", 
-		Adapter->bDriverStopped, Adapter->bDriverIsGoingToPnpSetPowerSleep, rtState));
-		return	FALSE;
-	}
-	return	TRUE;
-}
-#endif
-
-// need to ODM CE Platform
-//move to here for ANT detection mechanism using
-
-#if ((DM_ODM_SUPPORT_TYPE == ODM_WIN)||(DM_ODM_SUPPORT_TYPE == ODM_CE))
-u4Byte
-GetPSDData(
-	IN PDM_ODM_T	pDM_Odm,
-	unsigned int 	point,
-	u1Byte initial_gain_psd)
-{
-	//unsigned int	val, rfval;
-	//int	psd_report;
-	u4Byte	psd_report;
-	
-	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	//Debug Message
-	//val = PHY_QueryBBReg(Adapter,0x908, bMaskDWord);
-	//DbgPrint("Reg908 = 0x%x\n",val);
-	//val = PHY_QueryBBReg(Adapter,0xDF4, bMaskDWord);
-	//rfval = PHY_QueryRFReg(Adapter, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask);
-	//DbgPrint("RegDF4 = 0x%x, RFReg00 = 0x%x\n",val, rfval);
-	//DbgPrint("PHYTXON = %x, OFDMCCA_PP = %x, CCKCCA_PP = %x, RFReg00 = %x\n",
-		//(val&BIT25)>>25, (val&BIT14)>>14, (val&BIT15)>>15, rfval);
-
-	//Set DCO frequency index, offset=(40MHz/SamplePts)*point
-	ODM_SetBBReg(pDM_Odm, 0x808, 0x3FF, point);
-
-	//Start PSD calculation, Reg808[22]=0->1
-	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 1);
-	//Need to wait for HW PSD report
-	ODM_StallExecution(1000);
-	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 0);
-	//Read PSD report, Reg8B4[15:0]
-	psd_report = ODM_GetBBReg(pDM_Odm,0x8B4, bMaskDWord) & 0x0000FFFF;
-	
-#if 1//(DEV_BUS_TYPE == RT_PCI_INTERFACE) && ( (RT_PLATFORM == PLATFORM_LINUX) || (RT_PLATFORM == PLATFORM_MACOSX))
-	psd_report = (u4Byte) (ConvertTo_dB(psd_report))+(u4Byte)(initial_gain_psd-0x1c);
-#else
-	psd_report = (int) (20*log10((double)psd_report))+(int)(initial_gain_psd-0x1c);
-#endif
-
-	return psd_report;
-	
-}
-
-u4Byte 
-ConvertTo_dB(
-	u4Byte 	Value)
-{
-	u1Byte i;
-	u1Byte j;
-	u4Byte dB;
-
-	Value = Value & 0xFFFF;
-	
-	for (i=0;i<8;i++)
-	{
-		if (Value <= dB_Invert_Table[i][11])
-		{
-			break;
-		}
-	}
-
-	if (i >= 8)
-	{
-		return (96);	// maximum 96 dB
-	}
-
-	for (j=0;j<12;j++)
-	{
-		if (Value <= dB_Invert_Table[i][j])
-		{
-			break;
-		}
-	}
-
-	dB = i*12 + j + 1;
-
-	return (dB);
-}
-
-#endif
-
-//
-// LukeLee: 
-// PSD function will be moved to FW in future IC, but now is only implemented in MP platform
-// So PSD function will not be incorporated to common ODM
-//
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-#define	AFH_PSD		1	//0:normal PSD scan, 1: only do 20 pts PSD
-#define	MODE_40M		0	//0:20M, 1:40M
-#define	PSD_TH2		3  
-#define	PSD_CHMIN		20   // Minimum channel number for BT AFH
-#define	SIR_STEP_SIZE	3
-#define   Smooth_Size_1 	5
-#define	Smooth_TH_1	3
-#define   Smooth_Size_2 	10
-#define	Smooth_TH_2	4
-#define   Smooth_Size_3 	20
-#define	Smooth_TH_3	4
-#define   Smooth_Step_Size 5
-#define	Adaptive_SIR	1
-//#if(RTL8723_FPGA_VERIFICATION == 1)
-//#define	PSD_RESCAN		1
-//#else
-//#define	PSD_RESCAN		4
-//#endif
-#define	SCAN_INTERVAL	1500 //ms
-#define	SYN_Length		5    // for 92D
-	
-#define	LNA_Low_Gain_1                      0x64
-#define	LNA_Low_Gain_2                      0x5A
-#define	LNA_Low_Gain_3                      0x58
-
-#define	pw_th_10dB					0x0
-#define	pw_th_16dB					0x3
-
-#define	FA_RXHP_TH1                           5000
-#define	FA_RXHP_TH2                           1500
-#define	FA_RXHP_TH3                             800
-#define	FA_RXHP_TH4                             600
-#define	FA_RXHP_TH5                             500
-
-#define	Idle_Mode					0
-#define	High_TP_Mode				1
-#define	Low_TP_Mode				2
-
-
-VOID
-odm_PSDMonitorInit(
-	IN PDM_ODM_T	pDM_Odm)
-{
-#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)|(DEV_BUS_TYPE == RT_USB_INTERFACE)
-	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	//PSD Monitor Setting
-	//Which path in ADC/DAC is turnned on for PSD: both I/Q
-	ODM_SetBBReg(pDM_Odm, ODM_PSDREG, BIT10|BIT11, 0x3);
-	//Ageraged number: 8
-	ODM_SetBBReg(pDM_Odm, ODM_PSDREG, BIT12|BIT13, 0x1);
-	pDM_Odm->bPSDinProcess = FALSE;
-	pDM_Odm->bUserAssignLevel = FALSE;
-	pDM_Odm->bPSDactive = FALSE;
-	//pDM_Odm->bDMInitialGainEnable=TRUE;		//change the initialization to DIGinit
-	//Set Debug Port
-	//PHY_SetBBReg(Adapter, 0x908, bMaskDWord, 0x803);
-	//PHY_SetBBReg(Adapter, 0xB34, bMaskByte0, 0x00); // pause PSD
-	//PHY_SetBBReg(Adapter, 0xB38, bMaskByte0, 10); //rescan
-	//PHY_SetBBReg(Adapter, 0xB38, bMaskByte2|bMaskByte3, 100); //interval
-
-	//PlatformSetTimer( Adapter, &pHalData->PSDTriggerTimer, 0); //ms
-#endif
-}
-
-VOID
-PatchDCTone(
-	IN	PDM_ODM_T	pDM_Odm,
-	pu4Byte		PSD_report,
-	u1Byte 		initial_gain_psd
-)
-{
-	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	//PADAPTER	pAdapter;
-	
-	u4Byte	psd_report;
-
-	//2 Switch to CH11 to patch CH9 and CH13 DC tone
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, 11);
-	
-	if(pDM_Odm->SupportICType== ODM_RTL8192D)
-	{
-		if((*(pDM_Odm->pMacPhyMode) == ODM_SMSP)||(*(pDM_Odm->pMacPhyMode) == ODM_DMSP))
-		{
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, 0x3FF, 11);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x25, 0xfffff, 0x643BC);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x26, 0xfffff, 0xFC038);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, 0xfffff, 0x77C1A);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2B, 0xfffff, 0x41289);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2C, 0xfffff, 0x01840);
-		}
-		else
-		{
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x25, 0xfffff, 0x643BC);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x26, 0xfffff, 0xFC038);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, 0xfffff, 0x77C1A);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2B, 0xfffff, 0x41289);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2C, 0xfffff, 0x01840);
-		}
-	}
-	
-	//Ch9 DC tone patch
-	psd_report = GetPSDData(pDM_Odm, 96, initial_gain_psd);
-	PSD_report[50] = psd_report;
-	//Ch13 DC tone patch
-	psd_report = GetPSDData(pDM_Odm, 32, initial_gain_psd);
-	PSD_report[70] = psd_report;
-	
-	//2 Switch to CH3 to patch CH1 and CH5 DC tone
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, 3);
-
-	
-	if(pDM_Odm->SupportICType==ODM_RTL8192D)
-	{
-		if((*(pDM_Odm->pMacPhyMode) == ODM_SMSP)||(*(pDM_Odm->pMacPhyMode) == ODM_DMSP))
-		{
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, 0x3FF, 3);
-			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x25, 0xfffff, 0x643BC);
-			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x26, 0xfffff, 0xFC038);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, 0xfffff, 0x07C1A);
-			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x2B, 0xfffff, 0x61289);
-			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x2C, 0xfffff, 0x01C41);
-		}
-		else
-		{
-			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x25, 0xfffff, 0x643BC);
-			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x26, 0xfffff, 0xFC038);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, 0xfffff, 0x07C1A);
-			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x2B, 0xfffff, 0x61289);
-			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x2C, 0xfffff, 0x01C41);
-		}
-	}
-	
-	//Ch1 DC tone patch
-	psd_report = GetPSDData(pDM_Odm, 96, initial_gain_psd);
-	PSD_report[10] = psd_report;
-	//Ch5 DC tone patch
-	psd_report = GetPSDData(pDM_Odm, 32, initial_gain_psd);
-	PSD_report[30] = psd_report;
-
-}
-
-
-VOID
-GoodChannelDecision(
-	PDM_ODM_T	pDM_Odm,
-	pu4Byte		PSD_report,
-	pu1Byte		PSD_bitmap,
-	u1Byte 		RSSI_BT,
-	pu1Byte		PSD_bitmap_memory)
-{
-	pRXHP_T			pRX_HP_Table = &pDM_Odm->DM_RXHP_Table;
-	//s4Byte	TH1 =  SSBT-0x15;    // modify TH by Neil Chen
-	s4Byte	TH1= RSSI_BT+0x14;
-	s4Byte	TH2 = RSSI_BT+85;
-	//u2Byte    TH3;
-//	s4Byte	RegB34;
-	u1Byte	bitmap, Smooth_size[3], Smooth_TH[3];
-	//u1Byte	psd_bit;
-	u4Byte	i,n,j, byte_idx, bit_idx, good_cnt, good_cnt_smoothing, Smooth_Interval[3];
-	int 		start_byte_idx,start_bit_idx,cur_byte_idx, cur_bit_idx,NOW_byte_idx ;
-	
-//	RegB34 = PHY_QueryBBReg(Adapter,0xB34, bMaskDWord)&0xFF;
-
-	if((pDM_Odm->SupportICType == ODM_RTL8192C)||(pDM_Odm->SupportICType == ODM_RTL8192D))
-       {
-            TH1 = RSSI_BT + 0x14;  
-	}
-
-	Smooth_size[0]=Smooth_Size_1;
-	Smooth_size[1]=Smooth_Size_2;
-	Smooth_size[2]=Smooth_Size_3;
-	Smooth_TH[0]=Smooth_TH_1;
-	Smooth_TH[1]=Smooth_TH_2;
-	Smooth_TH[2]=Smooth_TH_3;
-	Smooth_Interval[0]=16;
-	Smooth_Interval[1]=15;
-	Smooth_Interval[2]=13;
-	good_cnt = 0;
-	if(pDM_Odm->SupportICType==ODM_RTL8723A)
-	{
-		//2 Threshold  
-
-		if(RSSI_BT >=41)
-			TH1 = 113;	
-		else if(RSSI_BT >=38)   // >= -15dBm
-			TH1 = 105;                              //0x69
-		else if((RSSI_BT >=33)&(RSSI_BT <38))
-			TH1 = 99+(RSSI_BT-33);         //0x63
-		else if((RSSI_BT >=26)&(RSSI_BT<33))
-			TH1 = 99-(33-RSSI_BT)+2;     //0x5e
-	 	else if((RSSI_BT >=24)&(RSSI_BT<26))
-			TH1 = 88-((RSSI_BT-24)*3);   //0x58
-		else if((RSSI_BT >=18)&(RSSI_BT<24))
-			TH1 = 77+((RSSI_BT-18)*2);
-		else if((RSSI_BT >=14)&(RSSI_BT<18))
-			TH1 = 63+((RSSI_BT-14)*2);
-		else if((RSSI_BT >=8)&(RSSI_BT<14))
-			TH1 = 58+((RSSI_BT-8)*2);
-		else if((RSSI_BT >=3)&(RSSI_BT<8))
-			TH1 = 52+(RSSI_BT-3);
-		else
-			TH1 = 51;
-	}
-
-	for (i = 0; i< 10; i++)
-		PSD_bitmap[i] = 0;
-	
-
-	 // Add By Gary
-       for (i=0; i<80; i++)
-	   	pRX_HP_Table->PSD_bitmap_RXHP[i] = 0;
-	// End
-
-
-
-	if(pDM_Odm->SupportICType==ODM_RTL8723A)
-	{
-		TH1 =TH1-SIR_STEP_SIZE;
-	}
-	while (good_cnt < PSD_CHMIN)
-	{
-		good_cnt = 0;
-		if(pDM_Odm->SupportICType==ODM_RTL8723A)
-		{
-		if(TH1 ==TH2)
-			break;
-		if((TH1+SIR_STEP_SIZE) < TH2)
-			TH1 += SIR_STEP_SIZE;
-		else
-			TH1 = TH2;
-		}
-		else
-		{
-			if(TH1==(RSSI_BT+0x1E))
-             		     break;    
-   			if((TH1+2) < (RSSI_BT+0x1E))
-				TH1+=3;
-		     	else
-				TH1 = RSSI_BT+0x1E;	
-             
-		}
-		ODM_RT_TRACE(pDM_Odm,COMP_PSD,DBG_LOUD,("PSD: decision threshold is: %d", TH1));
-			 
-		for (i = 0; i< 80; i++)
-		{
-			if((s4Byte)(PSD_report[i]) < TH1)
-			{
-				byte_idx = i / 8;
-				bit_idx = i -8*byte_idx;
-				bitmap = PSD_bitmap[byte_idx];
-				PSD_bitmap[byte_idx] = bitmap | (u1Byte) (1 << bit_idx);
-			}
-		}
-
-#if DBG
-		ODM_RT_TRACE(pDM_Odm,COMP_PSD, DBG_LOUD,("PSD: before smoothing\n"));
-		for(n=0;n<10;n++)
-		{
-			//DbgPrint("PSD_bitmap[%u]=%x\n", n, PSD_bitmap[n]);
-			for (i = 0; i<8; i++)
-				ODM_RT_TRACE(pDM_Odm,COMP_PSD, DBG_LOUD,("PSD_bitmap[%u] =   %d\n", 2402+n*8+i, (PSD_bitmap[n]&BIT(i))>>i));
-		}
-#endif
-	
-		//1 Start of smoothing function
-
-		for (j=0;j<3;j++)
-		{
-			start_byte_idx=0;
-			start_bit_idx=0;
-			for(n=0; n<Smooth_Interval[j]; n++)
-			{
-				good_cnt_smoothing = 0;
-				cur_bit_idx = start_bit_idx;
-				cur_byte_idx = start_byte_idx;
-				for ( i=0; i < Smooth_size[j]; i++)
-				{
-					NOW_byte_idx = cur_byte_idx + (i+cur_bit_idx)/8;
-					if ( (PSD_bitmap[NOW_byte_idx]& BIT( (cur_bit_idx + i)%8)) != 0)
-						good_cnt_smoothing++;
-
-				}
-
-				if( good_cnt_smoothing < Smooth_TH[j] )
-				{
-					cur_bit_idx = start_bit_idx;
-					cur_byte_idx = start_byte_idx;
-					for ( i=0; i< Smooth_size[j] ; i++)
-					{	
-						NOW_byte_idx = cur_byte_idx + (i+cur_bit_idx)/8;				
-						PSD_bitmap[NOW_byte_idx] = PSD_bitmap[NOW_byte_idx] & (~BIT( (cur_bit_idx + i)%8));
-					}
-				}
-				start_bit_idx =  start_bit_idx + Smooth_Step_Size;
-				while ( (start_bit_idx)  > 7 )
-				{
-					start_byte_idx= start_byte_idx+start_bit_idx/8;
-					start_bit_idx = start_bit_idx%8;
-				}
-			}
-
-			ODM_RT_TRACE(	pDM_Odm,COMP_PSD, DBG_LOUD,("PSD: after %u smoothing", j+1));
-			for(n=0;n<10;n++)
-			{
-				for (i = 0; i<8; i++)
-				{
-					ODM_RT_TRACE(pDM_Odm,COMP_PSD, DBG_LOUD,("PSD_bitmap[%u] =   %d\n", 2402+n*8+i, (PSD_bitmap[n]&BIT(i))>>i));
-					
-					if ( ((PSD_bitmap[n]&BIT(i))>>i) ==1)  //----- Add By Gary
-					{
-	                                   pRX_HP_Table->PSD_bitmap_RXHP[8*n+i] = 1;
-					}                                                  // ------end by Gary
-				}
-			}
-
-		}
-
-	
-		good_cnt = 0;
-		for ( i = 0; i < 10; i++)
-		{
-			for (n = 0; n < 8; n++)
-				if((PSD_bitmap[i]& BIT(n)) != 0)
-					good_cnt++;
-		}
-		ODM_RT_TRACE(pDM_Odm,COMP_PSD, DBG_LOUD,("PSD: good channel cnt = %u",good_cnt));
-	}
-
-	//RT_TRACE(COMP_PSD, DBG_LOUD,("PSD: SSBT=%d, TH2=%d, TH1=%d",SSBT,TH2,TH1));
-	for (i = 0; i <10; i++)
-		ODM_RT_TRACE(pDM_Odm,COMP_PSD, DBG_LOUD,("PSD: PSD_bitmap[%u]=%x",i,PSD_bitmap[i]));
-/*	
-	//Update bitmap memory
-	for(i = 0; i < 80; i++)
-	{
-		byte_idx = i / 8;
-		bit_idx = i -8*byte_idx;
-		psd_bit = (PSD_bitmap[byte_idx] & BIT(bit_idx)) >> bit_idx;
-		bitmap = PSD_bitmap_memory[i]; 
-		PSD_bitmap_memory[i] = (bitmap << 1) |psd_bit;
-	}
-*/
-}
-
-
-
-VOID
-odm_PSD_Monitor(
-	PDM_ODM_T	pDM_Odm
-)
-{
-	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	//PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-
-	unsigned int 		pts, start_point, stop_point;
-	u1Byte			initial_gain ;
-	static u1Byte		PSD_bitmap_memory[80], init_memory = 0;
-	static u1Byte 		psd_cnt=0;
-	static u4Byte		PSD_report[80], PSD_report_tmp;
-	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
-	u1Byte 			H2C_PSD_DATA[5]={0,0,0,0,0};
-	static u1Byte		H2C_PSD_DATA_last[5] ={0,0,0,0,0};
-	u1Byte			idx[20]={96,99,102,106,109,112,115,118,122,125,
-					0,3,6,10,13,16,19,22,26,29};
-	u1Byte			n, i, channel, BBReset,tone_idx;
-	u1Byte			PSD_bitmap[10], SSBT=0,initial_gain_psd=0, RSSI_BT=0, initialGainUpper;
-	s4Byte    			PSD_skip_start, PSD_skip_stop;
-	u4Byte			CurrentChannel, RXIQI, RxIdleLowPwr, wlan_channel;
-	u4Byte			ReScan, Interval, Is40MHz;
-	u8Byte			curTxOkCnt, curRxOkCnt;
-	int 				cur_byte_idx, cur_bit_idx;
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	PMGNT_INFO      	pMgntInfo = &Adapter->MgntInfo;
-	
-	if( (*(pDM_Odm->pbScanInProcess)) ||
-		pDM_Odm->bLinkInProcess)
-	{
-		if((pDM_Odm->SupportICType==ODM_RTL8723A)&(pDM_Odm->SupportInterface==ODM_ITRF_PCIE))
-		{
-			ODM_SetTimer( pDM_Odm, &pDM_Odm->PSDTimer, 1500); //ms	
-			//psd_cnt=0;
-		}
-		return;
-	}
-
-	if(pDM_Odm->bBtHsOperation)
-	{
-		ReScan = 1;
-		Interval = SCAN_INTERVAL;
-	}
-	else
-	{
-	ReScan = PSD_RESCAN;
-	Interval = SCAN_INTERVAL;
-	}
-
-	//1 Initialization
-	if(init_memory == 0)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Init memory\n"));
-		for(i = 0; i < 80; i++)
-			PSD_bitmap_memory[i] = 0xFF; // channel is always good
-		init_memory = 1;
-	}
-	if(psd_cnt == 0)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Enter dm_PSD_Monitor\n"));
-		for(i = 0; i < 80; i++)
-			PSD_report[i] = 0;
-	}
-
-	//1 Backup Current Settings
-	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask);
-/*
-	if(pDM_Odm->SupportICType==ODM_RTL8192D)
-	{
-		//2 Record Current synthesizer parameters based on current channel
-		if((*pDM_Odm->MacPhyMode92D == SINGLEMAC_SINGLEPHY)||(*pDM_Odm->MacPhyMode92D == DUALMAC_SINGLEPHY))
-		{
-			SYN_RF25 = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x25, bMaskDWord);
-			SYN_RF26 = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x26, bMaskDWord);
-			SYN_RF27 = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x27, bMaskDWord);
-			SYN_RF2B = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x2B, bMaskDWord);
-			SYN_RF2C = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x2C, bMaskDWord);
-       	}
-		else     // DualMAC_DualPHY 2G
-		{
-			SYN_RF25 = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x25, bMaskDWord);
-			SYN_RF26 = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x26, bMaskDWord);
-			SYN_RF27 = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x27, bMaskDWord);
-			SYN_RF2B = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x2B, bMaskDWord);
-			SYN_RF2C = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x2C, bMaskDWord);
-		}
-	}
-*/
-	//RXIQI = PHY_QueryBBReg(Adapter, 0xC14, bMaskDWord);
-	RXIQI = ODM_GetBBReg(pDM_Odm, 0xC14, bMaskDWord);
-
-	//RxIdleLowPwr = (PHY_QueryBBReg(Adapter, 0x818, bMaskDWord)&BIT28)>>28;
-	RxIdleLowPwr = (ODM_GetBBReg(pDM_Odm, 0x818, bMaskDWord)&BIT28)>>28;
-
-	//2???
-	if(CHNL_RUN_ABOVE_40MHZ(pMgntInfo))
-		Is40MHz = TRUE;
-	else
-		Is40MHz = FALSE;
-
-	ODM_RT_TRACE(pDM_Odm,	ODM_COMP_PSD, DBG_LOUD,("PSD Scan Start\n"));
-	//1 Turn off CCK
-	//PHY_SetBBReg(Adapter, rFPGA0_RFMOD, BIT24, 0);
-	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0);
-	//1 Turn off TX
-	//Pause TX Queue
-	//PlatformEFIOWrite1Byte(Adapter, REG_TXPAUSE, 0xFF);
-	ODM_Write1Byte(pDM_Odm,REG_TXPAUSE, 0xFF);
-	
-	//Force RX to stop TX immediately
-	//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x32E13);
-
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x32E13);
-	//1 Turn off RX
-	//Rx AGC off  RegC70[0]=0, RegC7C[20]=0
-	//PHY_SetBBReg(Adapter, 0xC70, BIT0, 0);
-	//PHY_SetBBReg(Adapter, 0xC7C, BIT20, 0);
-
-	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 0);
-	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 0);
-
-	
-	//Turn off CCA
-	//PHY_SetBBReg(Adapter, 0xC14, bMaskDWord, 0x0);
-	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, 0x0);
-	
-	//BB Reset
-	//BBReset = PlatformEFIORead1Byte(Adapter, 0x02);
-	BBReset = ODM_Read1Byte(pDM_Odm, 0x02);
-	
-	//PlatformEFIOWrite1Byte(Adapter, 0x02, BBReset&(~BIT0));
-	//PlatformEFIOWrite1Byte(Adapter, 0x02, BBReset|BIT0);
-	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 1); //clock gated to prevent from AGC table mess 
-	ODM_Write1Byte(pDM_Odm,  0x02, BBReset&(~BIT0));
-	ODM_Write1Byte(pDM_Odm,  0x02, BBReset|BIT0);
-	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 0);
-	
-	//1 Leave RX idle low power
-	//PHY_SetBBReg(Adapter, 0x818, BIT28, 0x0);
-
-	ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0);
-	//1 Fix initial gain
-	//if (IS_HARDWARE_TYPE_8723AE(Adapter))
-	//RSSI_BT = pHalData->RSSI_BT;
-       //else if((IS_HARDWARE_TYPE_8192C(Adapter))||(IS_HARDWARE_TYPE_8192D(Adapter)))      // Add by Gary
-       //    RSSI_BT = RSSI_BT_new;
-
-	if((pDM_Odm->SupportICType==ODM_RTL8723A)&(pDM_Odm->SupportInterface==ODM_ITRF_PCIE))
-	RSSI_BT=pDM_Odm->RSSI_BT;		//need to check C2H to pDM_Odm RSSI BT
-
-	if(RSSI_BT>=47)
-		RSSI_BT=47;
-	   
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
-	
-	if(pDM_Odm->SupportICType==ODM_RTL8723A)
-	{
-	       //Neil add--2011--10--12
-		//2 Initial Gain index 
-		if(RSSI_BT >=35)   // >= -15dBm
-			initial_gain_psd = RSSI_BT*2;
-		else if((RSSI_BT >=33)&(RSSI_BT<35))
-			initial_gain_psd = RSSI_BT*2+6;
-		else if((RSSI_BT >=24)&(RSSI_BT<33))
-			initial_gain_psd = 70-(33-RSSI_BT);
-	 	else if((RSSI_BT >=19)&(RSSI_BT<24))
-			initial_gain_psd = 64-((24-RSSI_BT)*4);
-		else if((RSSI_BT >=14)&(RSSI_BT<19))
-			initial_gain_psd = 44-((18-RSSI_BT)*2);
-		else if((RSSI_BT >=8)&(RSSI_BT<14))
-			initial_gain_psd = 35-(14-RSSI_BT);
-		else
-			initial_gain_psd = 0x1B;
-	}
-	else
-	{
-	
-		//need to do	
-         	initial_gain_psd = pDM_Odm->RSSI_Min;    // PSD report based on RSSI
-           	//}  	
-	}
-	//if(RSSI_BT<0x17)
-	//	RSSI_BT +=3;
-	//DbgPrint("PSD: RSSI_BT= %d\n", RSSI_BT);
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
-
-	//initialGainUpper = 0x5E;  //Modify by neil chen
-	
-	if(pDM_Odm->bUserAssignLevel)
-	{
-		pDM_Odm->bUserAssignLevel = FALSE;
-		initialGainUpper = 0x7f;
-	}
-	else
-	{
-		initialGainUpper = 0x5E;
-	}
-	
-	/*
-	if (initial_gain_psd < 0x1a)
-		initial_gain_psd = 0x1a;
-	if (initial_gain_psd > initialGainUpper)
-		initial_gain_psd = initialGainUpper;
-	*/
-
-	//if(pDM_Odm->SupportICType==ODM_RTL8723A)
-	SSBT = RSSI_BT  * 2 +0x3E;
-	
-	
-	//if(IS_HARDWARE_TYPE_8723AE(Adapter))
-	//	SSBT = RSSI_BT  * 2 +0x3E;
-	//else if((IS_HARDWARE_TYPE_8192C(Adapter))||(IS_HARDWARE_TYPE_8192D(Adapter)))   // Add by Gary
-	//{
-	//	RSSI_BT = initial_gain_psd;
-	//	SSBT = RSSI_BT;
-	//}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: SSBT= %d\n", SSBT));
-	ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: initial gain= 0x%x\n", initial_gain_psd));
-	//DbgPrint("PSD: SSBT= %d", SSBT);
-	//need to do
-	//pMgntInfo->bDMInitialGainEnable = FALSE;
-	pDM_Odm->bDMInitialGainEnable = FALSE;
-	initial_gain =(u1Byte) (ODM_GetBBReg(pDM_Odm, 0xc50, bMaskDWord) & 0x7F);
-	
-        // make sure the initial gain is under the correct range.
-	//initial_gain_psd &= 0x7f;
-	ODM_Write_DIG(pDM_Odm, initial_gain_psd);
-	//1 Turn off 3-wire
-	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0xF);
-
-	//pts value = 128, 256, 512, 1024
-	pts = 128;
-
-	if(pts == 128)
-	{
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
-		start_point = 64;
-		stop_point = 192;
-	}
-	else if(pts == 256)
-	{
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x1);
-		start_point = 128;
-		stop_point = 384;
-	}
-	else if(pts == 512)
-	{
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x2);
-		start_point = 256;
-		stop_point = 768;
-	}
-	else
-	{
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x3);
-		start_point = 512;
-		stop_point = 1536;
-	}
-	
-
-//3 Skip WLAN channels if WLAN busy
-
-	curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast) - lastTxOkCnt;
-	curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast) - lastRxOkCnt;
-	lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
-	lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);	
-
-	PSD_skip_start=80;
-	PSD_skip_stop = 0;
-	wlan_channel = CurrentChannel & 0x0f;
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD: current channel: %x, BW:%d \n", wlan_channel, Is40MHz));
-	if(pDM_Odm->SupportICType==ODM_RTL8723A)
-	{
-		if(pDM_Odm->bBtHsOperation)
-		{
-			if(pDM_Odm->bLinked)
-			{
-				if(Is40MHz)
-				{
-					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-2;  // Modify by Neil to add 10 chs to mask
-					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+4;
-				}
-				else
-				{
-					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-10;  // Modify by Neil to add 10 chs to mask
-					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+18; 
-				}
-			}
-			else
-			{
-				// mask for 40MHz
-				PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-2;  // Modify by Neil to add 10 chs to mask
-				PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+4;
-			}
-			if(PSD_skip_start < 0)
-				PSD_skip_start = 0;
-			if(PSD_skip_stop >80)
-				PSD_skip_stop = 80;
-		}
-		else
-		{
-			if((curRxOkCnt+curTxOkCnt) > 5)
-			{
-				if(Is40MHz)
-				{
-					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-2;  // Modify by Neil to add 10 chs to mask
-					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+4;
-				}
-				else
-				{
-					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-10;  // Modify by Neil to add 10 chs to mask
-					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+18; 
-				}
-				
-				if(PSD_skip_start < 0)
-					PSD_skip_start = 0;
-				if(PSD_skip_stop >80)
-					PSD_skip_stop = 80;
-			}
-		}
-	}
-#if 0	
-	else
-	{
-		if((curRxOkCnt+curTxOkCnt) > 1000)
-		{
-			PSD_skip_start = (wlan_channel-1)*5 -Is40MHz*10;
-			PSD_skip_stop = PSD_skip_start + (1+Is40MHz)*20;
-		}
-	}   
-#endif  //Reove RXHP Issue
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD: Skip tone from %d to %d \n", PSD_skip_start, PSD_skip_stop));
-
- 	for (n=0;n<80;n++)
- 	{
- 		if((n%20)==0)
- 		{
-			channel = (n/20)*4 + 1;
-					
-					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
-				}
-		tone_idx = n%20;
-		if ((n>=PSD_skip_start) && (n<PSD_skip_stop))
-		{	
-			PSD_report[n] = SSBT;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD:Tone %d skipped \n", n));
-		}
-		else
-		{
-			PSD_report_tmp =  GetPSDData(pDM_Odm, idx[tone_idx], initial_gain_psd);
-
-			if ( PSD_report_tmp > PSD_report[n])
-				PSD_report[n] = PSD_report_tmp;
-				
-		}
-	}
-
-	PatchDCTone(pDM_Odm, PSD_report, initial_gain_psd);
-      
-       //----end
-	//1 Turn on RX
-	//Rx AGC on
-	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 1);
-	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 1);
-	//CCK on
-	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 1);
-	//1 Turn on TX
-	//Resume TX Queue
-	
-	ODM_Write1Byte(pDM_Odm,REG_TXPAUSE, 0x00);
-	//Turn on 3-wire
-	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0x0);
-	//1 Restore Current Settings
-	//Resume DIG
-	pDM_Odm->bDMInitialGainEnable = TRUE;
-	
-	ODM_Write_DIG(pDM_Odm, initial_gain);
-
-	// restore originl center frequency
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, CurrentChannel);
-
-	//Turn on CCA
-	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, RXIQI);
-	//Restore RX idle low power
-	if(RxIdleLowPwr == TRUE)
-		ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 1);
-	
-	psd_cnt++;
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD:psd_cnt = %d \n",psd_cnt));
-	if (psd_cnt < ReScan)
-		ODM_SetTimer(pDM_Odm, &pDM_Odm->PSDTimer, Interval);		
-	else
-	{
-		psd_cnt = 0;
-		for(i=0;i<80;i++)
-			//DbgPrint("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]);
-			RT_TRACE(	COMP_PSD, DBG_LOUD,("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]));
-
-
-		GoodChannelDecision(pDM_Odm, PSD_report, PSD_bitmap,RSSI_BT, PSD_bitmap_memory);
-
-		if(pDM_Odm->SupportICType==ODM_RTL8723A)
-		{
-			cur_byte_idx=0;
-			cur_bit_idx=0;
-
-			//2 Restore H2C PSD Data to Last Data
-		  	H2C_PSD_DATA_last[0] = H2C_PSD_DATA[0];
-			H2C_PSD_DATA_last[1] = H2C_PSD_DATA[1];
-			H2C_PSD_DATA_last[2] = H2C_PSD_DATA[2];
-			H2C_PSD_DATA_last[3] = H2C_PSD_DATA[3];
-			H2C_PSD_DATA_last[4] = H2C_PSD_DATA[4];
-
-	
-			//2 Translate 80bit channel map to 40bit channel	
-			for ( i=0;i<5;i++)
-			{
-				for(n=0;n<8;n++)
-				{
-					cur_byte_idx = i*2 + n/4;
-					cur_bit_idx = (n%4)*2;
-					if ( ((PSD_bitmap[cur_byte_idx]& BIT(cur_bit_idx)) != 0) && ((PSD_bitmap[cur_byte_idx]& BIT(cur_bit_idx+1)) != 0))
-						H2C_PSD_DATA[i] = H2C_PSD_DATA[i] | (u1Byte) (1 << n);
-				}
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("H2C_PSD_DATA[%d]=0x%x\n" ,i, H2C_PSD_DATA[i]));
-			}
-	
-			//3 To Compare the difference
-			for ( i=0;i<5;i++)
-			{
-				if(H2C_PSD_DATA[i] !=H2C_PSD_DATA_last[i])
-				{
-					FillH2CCmd(Adapter, H2C_92C_PSD_RESULT, 5, H2C_PSD_DATA);
-					ODM_RT_TRACE(pDM_Odm, ODM_COMP_PSD, DBG_LOUD,("Need to Update the AFH Map \n"));
-					break;
-				}
-				else
-				{
-					if(i==5)
-						ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Not need to Update\n"));	
-				}
-			}
-			if(pDM_Odm->bBtHsOperation)
-			{
-				ODM_SetTimer(pDM_Odm, &pDM_Odm->PSDTimer, 10000);
-				ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Leave dm_PSD_Monitor\n"));		
-			}
-			else
-			{
-				ODM_SetTimer(pDM_Odm, &pDM_Odm->PSDTimer, 1500);
-				ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Leave dm_PSD_Monitor\n"));		
-		}
-	}
-    }
-}
-/*
-//Neil for Get BT RSSI
-// Be Triggered by BT C2H CMD
-VOID
-ODM_PSDGetRSSI(
-	IN	u1Byte	RSSI_BT)
-{
-
-
-}
-
-*/
-
-VOID
-ODM_PSDMonitor(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	
-	//if(IS_HARDWARE_TYPE_8723AE(Adapter))
-	
-	if(pDM_Odm->SupportICType == ODM_RTL8723A)   //may need to add other IC type
-	{
-		if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE)
-		{
-			if(pDM_Odm->bBtDisabled) //need to check upper layer connection
-			{
-				pDM_Odm->bPSDactive=FALSE;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD, ("odm_PSDMonitor, return for BT is disabled!!!\n"));
-		   		return; 
-			}
-
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD, ("odm_PSDMonitor\n"));
-		//{
-			pDM_Odm->bPSDinProcess = TRUE;
-	 		pDM_Odm->bPSDactive=TRUE;
-			odm_PSD_Monitor(pDM_Odm);
-			pDM_Odm->bPSDinProcess = FALSE;
-		}	
-	}	
-
-}
-VOID
-odm_PSDMonitorCallback(
-	PRT_TIMER		pTimer
-)
-{
-	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
-       HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
-	PlatformScheduleWorkItem(&pHalData->PSDMonitorWorkitem);
-}
-
-VOID
-odm_PSDMonitorWorkItemCallback(
-    IN PVOID            pContext
-    )
-{
-	PADAPTER	Adapter = (PADAPTER)pContext;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-
-	ODM_PSDMonitor(pDM_Odm);
-}
-
-// <20130108, Kordan> E.g., With LNA used, we make the Rx power smaller to have a better EVM. (Asked by Willis)
-VOID
-odm_RFEControl(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN  u8Byte		RSSIVal
-	)
-{
-	PADAPTER		Adapter = (PADAPTER)pDM_Odm->Adapter;
-    HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	static u1Byte 	TRSW_HighPwr = 0;
-	 
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, DBG_LOUD, ("===> odm_RFEControl, RSSI = %d, TRSW_HighPwr = 0x%X, pHalData->RFEType = %d\n",
-		         RSSIVal, TRSW_HighPwr, pHalData->RFEType ));
-
-    if (pHalData->RFEType == 3) {	   
-		
-        pDM_Odm->RSSI_TRSW = RSSIVal;
-
-        if (pDM_Odm->RSSI_TRSW >= pDM_Odm->RSSI_TRSW_H) 
-		{				 
-            TRSW_HighPwr = 1; // Switch to
-            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT1|BIT0, 0x1);  // Set ANTSW=1/ANTSWB=0  for SW control
-            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT9|BIT8, 0x3);  // Set ANTSW=1/ANTSWB=0  for SW control
-            
-        } 
-		else if (pDM_Odm->RSSI_TRSW <= pDM_Odm->RSSI_TRSW_L) 
-        {	  
-            TRSW_HighPwr = 0; // Switched back
-            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT1|BIT0, 0x1);  // Set ANTSW=1/ANTSWB=0  for SW control
-            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT9|BIT8, 0x0);  // Set ANTSW=1/ANTSWB=0  for SW control
-
-        }
-    }  
-
-	
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, DBG_LOUD, ("(pDM_Odm->RSSI_TRSW_H, pDM_Odm->RSSI_TRSW_L) = (%d, %d)\n", pDM_Odm->RSSI_TRSW_H, pDM_Odm->RSSI_TRSW_L));		
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, DBG_LOUD, ("(RSSIVal, RSSIVal, pDM_Odm->RSSI_TRSW_iso) = (%d, %d, %d)\n", 
-				 RSSIVal, pDM_Odm->RSSI_TRSW_iso, pDM_Odm->RSSI_TRSW));
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, DBG_LOUD, ("<=== odm_RFEControl, RSSI = %d, TRSW_HighPwr = 0x%X\n", RSSIVal, TRSW_HighPwr));	
-}
-
-VOID
-ODM_MPT_DIG(
-	IN	PDM_ODM_T	pDM_Odm
-	)
-{
-	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
-	PFALSE_ALARM_STATISTICS 	pFalseAlmCnt = &pDM_Odm->FalseAlmCnt;
-	u1Byte						CurrentIGI = (u1Byte)pDM_DigTable->CurIGValue;
-	u1Byte						DIG_Upper = 0x40, DIG_Lower = 0x20, C50, E50;
-	u8Byte						RXOK_cal;
-	u1Byte						IGI_A = 0x20, IGI_B = 0x20;
-
-#if ODM_FIX_2G_DIG
-	IGI_A = 0x22;
-	IGI_B = 0x24;		
-#endif
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_MP, DBG_LOUD, ("===> ODM_MPT_DIG, pBandType = %d\n", *pDM_Odm->pBandType));
-
-	odm_FalseAlarmCounterStatistics( pDM_Odm);
-	pDM_Odm->LastNumQryPhyStatusAll = pDM_Odm->NumQryPhyStatusAll;
-	pDM_Odm->NumQryPhyStatusAll = pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK + pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM;
-	RXOK_cal = pDM_Odm->NumQryPhyStatusAll - pDM_Odm->LastNumQryPhyStatusAll;
-	
-	if (RXOK_cal == 0)
-		pDM_Odm->RxPWDBAve_final= 0;
-	else
-		pDM_Odm->RxPWDBAve_final= pDM_Odm->RxPWDBAve/RXOK_cal;
-
-	pDM_Odm->RxPWDBAve = 0;
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, DBG_LOUD, ("RX OK = %d\n", RXOK_cal));
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, DBG_LOUD, ("pDM_Odm->RxPWDBAve_final = %d\n", pDM_Odm->RxPWDBAve_final));
-	
-	// <20130315, Kordan> Except Cameo, we should always trun on 2.4G/5G DIG.
-	// (Cameo fixes the IGI of 2.4G, so only DIG on 5G. Asked by James.)
-#if ODM_FIX_2G_DIG
-	if (*pDM_Odm->pBandType == BAND_ON_5G){	 // for 5G
-#else
-	if (1){ // for both 2G/5G
-#endif
-		pDM_Odm->MPDIG_2G = FALSE;
-		pDM_Odm->Times_2G = 0;
-	
-		if (RXOK_cal >= 70 && pDM_Odm->RxPWDBAve_final<= 30)
-		{
-			if (CurrentIGI > 0x24){
-				ODM_Write1Byte( pDM_Odm, rA_IGI_Jaguar, 0x24);
-				ODM_Write1Byte( pDM_Odm, rB_IGI_Jaguar, 0x24);
-			}
-		}
-		else
-		{
-			if(pFalseAlmCnt->Cnt_all > 1000){
-				CurrentIGI = CurrentIGI + 8;
-			}
-			else if(pFalseAlmCnt->Cnt_all > 200){
-				CurrentIGI = CurrentIGI + 4;
-			}
-			else if (pFalseAlmCnt->Cnt_all > 50){
-				CurrentIGI = CurrentIGI + 2;
-			}
-			else if (pFalseAlmCnt->Cnt_all < 2){
-				CurrentIGI = CurrentIGI - 2;
-			}
-			
-			if (CurrentIGI < DIG_Lower ){
-				CurrentIGI = DIG_Lower;
-			}
-			else if(CurrentIGI > DIG_Upper){
-				CurrentIGI = DIG_Upper;
-			}
-			
-			pDM_DigTable->CurIGValue = CurrentIGI;
-			
-			ODM_Write1Byte( pDM_Odm, rA_IGI_Jaguar, (u1Byte)CurrentIGI);
-			ODM_Write1Byte( pDM_Odm, rB_IGI_Jaguar, (u1Byte)CurrentIGI);
-
-			C50 = ODM_Read1Byte( pDM_Odm, 0xc50);
-			E50 = ODM_Read1Byte( pDM_Odm, 0xe50);
-			//pDM_Odm->MPDIG_2G = FALSE;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_MP, DBG_LOUD, ("DIG = (%x, %x), Cnt_all = %d, Cnt_Ofdm_fail = %d, Cnt_Cck_fail = %d\n", C50, E50, pFalseAlmCnt->Cnt_all, pFalseAlmCnt->Cnt_Ofdm_fail, pFalseAlmCnt->Cnt_Cck_fail));
-		}
-			
-	}
-	else
-	{	//2G
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_MP, DBG_LOUD, ("MPDIG_2G = %d,\n", pDM_Odm->MPDIG_2G));
-		
-		if(pDM_Odm->MPDIG_2G == FALSE){
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_MP, DBG_LOUD, ("===> Fix IGI\n"));
-			ODM_Write1Byte( pDM_Odm, rA_IGI_Jaguar, (u1Byte)IGI_A);
-			ODM_Write1Byte( pDM_Odm, rB_IGI_Jaguar, (u1Byte)IGI_B);
-		}
-		if (pDM_Odm->Times_2G == 2)
-			pDM_Odm->MPDIG_2G = TRUE;
-		pDM_Odm->Times_2G++;
-	}
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, DBG_LOUD, ("pDM_Odm->RxPWDBAve_final = %d\n", pDM_Odm->RxPWDBAve_final));
-
-	if (pDM_Odm->SupportICType == ODM_RTL8812)
-		odm_RFEControl(pDM_Odm, pDM_Odm->RxPWDBAve_final);
-	
-	ODM_SetTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 700);
-	
-}		
-
-VOID
-odm_MPT_DIGCallback(
-	PRT_TIMER		pTimer
-)
-{
-	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
-       HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	  PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-
-
-	#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-		#if USE_WORKITEM
-			PlatformScheduleWorkItem(&pDM_Odm->MPT_DIGWorkitem);
-		#else
-			ODM_MPT_DIG(pDM_Odm);
-		#endif
-	#else
-		PlatformScheduleWorkItem(&pDM_Odm->MPT_DIGWorkitem);
-	#endif
-
-}
-
-VOID
-odm_MPT_DIGWorkItemCallback(
-    IN PVOID            pContext
-    )
-{
-	PADAPTER	Adapter = (PADAPTER)pContext;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-
-	ODM_MPT_DIG(pDM_Odm);
-}
-
-
-
-
- //cosa debug tool need to modify
-
-VOID
-ODM_PSDDbgControl(
-	IN	PADAPTER	Adapter,
-	IN	u4Byte		mode,
-	IN	u4Byte		btRssi
-	)
-{
-#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-
-	ODM_RT_TRACE(pDM_Odm,COMP_PSD, DBG_LOUD, (" Monitor mode=%d, btRssi=%d\n", mode, btRssi));
-	if(mode)
-	{
-		pDM_Odm->RSSI_BT = (u1Byte)btRssi;
-		pDM_Odm->bUserAssignLevel = TRUE;
-		ODM_SetTimer( pDM_Odm, &pDM_Odm->PSDTimer, 0); //ms		
-	}
-	else
-	{
-		ODM_CancelTimer(pDM_Odm, &pDM_Odm->PSDTimer);
-	}
-#endif
-}
-
-
-//#if(DEV_BUS_TYPE == RT_PCI_INTERFACE)|(DEV_BUS_TYPE == RT_USB_INTERFACE)
-
-void	odm_RXHPInit(
-	IN		PDM_ODM_T		pDM_Odm)
-{
-#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)|(DEV_BUS_TYPE == RT_USB_INTERFACE)
-	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
-   	u1Byte			index;
-
-	pRX_HP_Table->RXHP_enable = TRUE;
-	pRX_HP_Table->RXHP_flag = 0;
-	pRX_HP_Table->PSD_func_trigger = 0;
-	pRX_HP_Table->Pre_IGI = 0x20;
-	pRX_HP_Table->Cur_IGI = 0x20;
-	pRX_HP_Table->Cur_pw_th = pw_th_10dB;
-	pRX_HP_Table->Pre_pw_th = pw_th_10dB;
-	for(index=0; index<80; index++)
-		pRX_HP_Table->PSD_bitmap_RXHP[index] = 1;
-
-#if(DEV_BUS_TYPE == RT_USB_INTERFACE)
-	pRX_HP_Table->TP_Mode = Idle_Mode;
-#endif
-#endif
-}
-
-void odm_RXHP(
-	IN		PDM_ODM_T		pDM_Odm)
-{
-#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN))
-#if (DEV_BUS_TYPE == RT_PCI_INTERFACE) | (DEV_BUS_TYPE == RT_USB_INTERFACE)
-	PADAPTER	Adapter =  pDM_Odm->Adapter;
-	PMGNT_INFO	pMgntInfo = &(Adapter->MgntInfo);
-	pDIG_T		pDM_DigTable = &pDM_Odm->DM_DigTable;
-	pRXHP_T		pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
-       PFALSE_ALARM_STATISTICS		FalseAlmCnt = &(pDM_Odm->FalseAlmCnt);
-	
-	u1Byte              	i, j, sum;
-	u1Byte			Is40MHz;
-	s1Byte              	Intf_diff_idx, MIN_Intf_diff_idx = 16;   
-       s4Byte              	cur_channel;    
-       u1Byte              	ch_map_intf_5M[17] = {0};     
-       static u4Byte		FA_TH = 0;	
-	static u1Byte      	psd_intf_flag = 0;
-	static s4Byte      	curRssi = 0;                
-       static s4Byte  		preRssi = 0;                                                                
-	static u1Byte		PSDTriggerCnt = 1;
-	
-	u1Byte			RX_HP_enable = (u1Byte)(ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore2, bMaskDWord)>>31);   // for debug!!
-
-#if(DEV_BUS_TYPE == RT_USB_INTERFACE)	
-	static s8Byte  		lastTxOkCnt = 0, lastRxOkCnt = 0;  
-       s8Byte			curTxOkCnt, curRxOkCnt;
-	s8Byte			curTPOkCnt;
-	s8Byte			TP_Acc3, TP_Acc5;
-	static s8Byte		TP_Buff[5] = {0};
-	static u1Byte		pre_state = 0, pre_state_flag = 0;
-	static u1Byte		Intf_HighTP_flag = 0, De_counter = 16; 
-	static u1Byte		TP_Degrade_flag = 0;
-#endif	   
-	static u1Byte		LatchCnt = 0;
-	
-	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8188E))
-		return;
-	//AGC RX High Power Mode is only applied on 2G band in 92D!!!
-	if(pDM_Odm->SupportICType == ODM_RTL8192D)
-	{
-		if(*(pDM_Odm->pBandType) != ODM_BAND_2_4G)
-			return;
-	}
-
-	if(!(pDM_Odm->SupportAbility==ODM_BB_RXHP))
-		return;
-
-
-	//RX HP ON/OFF
-	if(RX_HP_enable == 1)
-		pRX_HP_Table->RXHP_enable = FALSE;
-	else
-		pRX_HP_Table->RXHP_enable = TRUE;
-
-	if(pRX_HP_Table->RXHP_enable == FALSE)
-	{
-		if(pRX_HP_Table->RXHP_flag == 1)
-		{
-			pRX_HP_Table->RXHP_flag = 0;
-			psd_intf_flag = 0;
-		}
-		return;
-	}
-
-#if(DEV_BUS_TYPE == RT_USB_INTERFACE)	
-	//2 Record current TP for USB interface
-	curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast)-lastTxOkCnt;
-	curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast)-lastRxOkCnt;
-	lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
-	lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);
-
-	curTPOkCnt = curTxOkCnt+curRxOkCnt;
-	TP_Buff[0] = curTPOkCnt;    // current TP  
-	TP_Acc3 = PlatformDivision64((TP_Buff[1]+TP_Buff[2]+TP_Buff[3]), 3);
-	TP_Acc5 = PlatformDivision64((TP_Buff[0]+TP_Buff[1]+TP_Buff[2]+TP_Buff[3]+TP_Buff[4]), 5);
-	
-	if(TP_Acc5 < 1000)
-		pRX_HP_Table->TP_Mode = Idle_Mode;
-	else if((1000 < TP_Acc5)&&(TP_Acc5 < 3750000))
-		pRX_HP_Table->TP_Mode = Low_TP_Mode;
-	else
-		pRX_HP_Table->TP_Mode = High_TP_Mode;
-
-	ODM_RT_TRACE(pDM_Odm, 	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP TP Mode = %d\n", pRX_HP_Table->TP_Mode));
-	// Since TP result would be sampled every 2 sec, it needs to delay 4sec to wait PSD processing.
-	// When LatchCnt = 0, we would Get PSD result.
-	if(TP_Degrade_flag == 1)
-	{
-		LatchCnt--;
-		if(LatchCnt == 0)
-		{
-			TP_Degrade_flag = 0;
-		}
-	}
-	// When PSD function triggered by TP degrade 20%, and Interference Flag = 1
-	// Set a De_counter to wait IGI = upper bound. If time is UP, the Interference flag will be pull down.
-	if(Intf_HighTP_flag == 1)
-	{
-		De_counter--;
-		if(De_counter == 0)
-		{
-			Intf_HighTP_flag = 0;
-			psd_intf_flag = 0;
-		}
-	}
-#endif
-
-	//2 AGC RX High Power Mode by PSD only applied to STA Mode
-	//3 NOT applied 1. Ad Hoc Mode.
-	//3 NOT applied 2. AP Mode
-	if ((pMgntInfo->mAssoc) && (!pMgntInfo->mIbss) && (!ACTING_AS_AP(Adapter)))
-	{    
-		Is40MHz = *(pDM_Odm->pBandWidth);
-		curRssi = pDM_Odm->RSSI_Min;
-		cur_channel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x0fff) & 0x0f;
-		ODM_RT_TRACE(pDM_Odm, 	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP RX HP flag = %d\n", pRX_HP_Table->RXHP_flag));
-		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP FA = %d\n", FalseAlmCnt->Cnt_all));
-		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP cur RSSI = %d, pre RSSI=%d\n", curRssi, preRssi));
-		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP current CH = %d\n", cur_channel));
-		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP Is 40MHz = %d\n", Is40MHz));
-       	//2 PSD function would be triggered 
-       	//3 1. Every 4 sec for PCIE
-       	//3 2. Before TP Mode (Idle TP<4kbps) for USB
-       	//3 3. After TP Mode (High TP) for USB 
-		if((curRssi > 68) && (pRX_HP_Table->RXHP_flag == 0))	// Only RSSI>TH and RX_HP_flag=0 will Do PSD process 
-		{
-#if (DEV_BUS_TYPE == RT_USB_INTERFACE)
-			//2 Before TP Mode ==> PSD would be trigger every 4 sec
-			if(pRX_HP_Table->TP_Mode == Idle_Mode)		//2.1 less wlan traffic <4kbps
-			{
-#endif
-				if(PSDTriggerCnt == 1)       
-				{    	
-					odm_PSD_RXHP(pDM_Odm);
-					pRX_HP_Table->PSD_func_trigger = 1;
-					PSDTriggerCnt = 0;
-				}
-				else
-				{
-             				PSDTriggerCnt++;
-				}
-#if(DEV_BUS_TYPE == RT_USB_INTERFACE)
-			}	
-			//2 After TP Mode ==> Check if TP degrade larger than 20% would trigger PSD function
-			if(pRX_HP_Table->TP_Mode == High_TP_Mode)
-			{
-				if((pre_state_flag == 0)&&(LatchCnt == 0)) 
-				{
-					// TP var < 5%
-					if((((curTPOkCnt-TP_Acc3)*20)<(TP_Acc3))&&(((curTPOkCnt-TP_Acc3)*20)>(-TP_Acc3)))
-					{
-						pre_state++;
-						if(pre_state == 3)      // hit pre_state condition => consecutive 3 times
-						{
-							pre_state_flag = 1;
-							pre_state = 0;
-						}
-
-					}
-					else
-					{
-						pre_state = 0;
-					}
-				}
-				//3 If pre_state_flag=1 ==> start to monitor TP degrade 20%
-				if(pre_state_flag == 1)		
-				{
-					if(((TP_Acc3-curTPOkCnt)*5)>(TP_Acc3))      // degrade 20%
-					{
-						odm_PSD_RXHP(pDM_Odm);
-						pRX_HP_Table->PSD_func_trigger = 1;
-						TP_Degrade_flag = 1;
-						LatchCnt = 2;
-						pre_state_flag = 0;
-					}
-					else if(((TP_Buff[2]-curTPOkCnt)*5)>TP_Buff[2])
-					{
-						odm_PSD_RXHP(pDM_Odm);
-						pRX_HP_Table->PSD_func_trigger = 1;
-						TP_Degrade_flag = 1;
-						LatchCnt = 2;
-						pre_state_flag = 0;
-					}
-					else if(((TP_Buff[3]-curTPOkCnt)*5)>TP_Buff[3])
-					{
-						odm_PSD_RXHP(pDM_Odm);
-						pRX_HP_Table->PSD_func_trigger = 1;
-						TP_Degrade_flag = 1;
-						LatchCnt = 2;
-						pre_state_flag = 0;
-					}
-				}
-			}
-#endif
-}
-
-#if (DEV_BUS_TYPE == RT_USB_INTERFACE)
-		for (i=0;i<4;i++)
-		{
-			TP_Buff[4-i] = TP_Buff[3-i];
-		}
-#endif
-		//2 Update PSD bitmap according to PSD report 
-		if((pRX_HP_Table->PSD_func_trigger == 1)&&(LatchCnt == 0))
-    		{	
-           		//2 Separate 80M bandwidth into 16 group with smaller 5M BW.
-			for (i = 0 ; i < 16 ; i++)
-           		{
-				sum = 0;
-				for(j = 0; j < 5 ; j++)
-                			sum += pRX_HP_Table->PSD_bitmap_RXHP[5*i + j];
-            
-                		if(sum < 5)
-                		{
-                			ch_map_intf_5M[i] = 1;  // interference flag
-                		}
-           		}
-			//=============just for debug=========================
-			//for(i=0;i<16;i++)
-				//DbgPrint("RX HP: ch_map_intf_5M[%d] = %d\n", i, ch_map_intf_5M[i]);
-			//===============================================
-			//2 Mask target channel 5M index
-	    		for(i = 0; i < (4+4*Is40MHz) ; i++)
-           		{
-				ch_map_intf_5M[cur_channel - (1+2*Is40MHz) + i] = 0;  
-           		}
-				
-           		psd_intf_flag = 0;
-	    		for(i = 0; i < 16; i++)
-           		{
-         			if(ch_map_intf_5M[i] == 1)
-	              	{
-	              		psd_intf_flag = 1;            // interference is detected!!!	
-	              		break;
-         			}
-	    		}
-				
-#if (DEV_BUS_TYPE == RT_USB_INTERFACE)
-			if(pRX_HP_Table->TP_Mode!=Idle_Mode)
-			{
-				if(psd_intf_flag == 1)     // to avoid psd_intf_flag always 1
-				{
-					Intf_HighTP_flag = 1;
-					De_counter = 32;     // 0x1E -> 0x3E needs 32 times by each IGI step =1
-				}
-			}
-#endif
-			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP psd_intf_flag = %d\n", psd_intf_flag));
-			//2 Distance between target channel and interference
-           		for(i = 0; i < 16; i++)
-          		{
-				if(ch_map_intf_5M[i] == 1)
-                		{
-					Intf_diff_idx = ((cur_channel+Is40MHz-(i+1))>0) ? (s1Byte)(cur_channel-2*Is40MHz-(i-2)) : (s1Byte)((i+1)-(cur_channel+2*Is40MHz));  
-                      		if(Intf_diff_idx < MIN_Intf_diff_idx)
-						MIN_Intf_diff_idx = Intf_diff_idx;    // the min difference index between interference and target
-		  		}
-	    		}
-	    		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP MIN_Intf_diff_idx = %d\n", MIN_Intf_diff_idx)); 
-			//2 Choose False Alarm Threshold
-			switch (MIN_Intf_diff_idx){
-      				case 0: 
-	   			case 1:
-	        		case 2:
-	        		case 3:	 	 
-                 			FA_TH = FA_RXHP_TH1;  
-                     		break;
-	        		case 4:				// CH5
-	        		case 5:				// CH6
-		   			FA_TH = FA_RXHP_TH2;	
-               			break;
-	        		case 6:				// CH7
-	        		case 7:				// CH8
-		      			FA_TH = FA_RXHP_TH3;
-                    			break; 
-               		case 8:				// CH9
-	        		case 9:				//CH10
-		      			FA_TH = FA_RXHP_TH4;
-                    			break; 	
-	        		case 10:
-	        		case 11:
-	        		case 12:
-	        		case 13:	 
-	        		case 14:
-	      			case 15:	 	
-		      			FA_TH = FA_RXHP_TH5;
-                    			break;  		
-       		}	
-			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP FA_TH = %d\n", FA_TH));
-			pRX_HP_Table->PSD_func_trigger = 0;
-		}
-		//1 Monitor RSSI variation to choose the suitable IGI or Exit AGC RX High Power Mode
-         	if(pRX_HP_Table->RXHP_flag == 1)
-         	{
-              	if ((curRssi > 80)&&(preRssi < 80))
-              	{ 
-                   		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_1;
-              	}
-              	else if ((curRssi < 80)&&(preRssi > 80))
-              	{
-                   		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_2;
-			}
-	       	else if ((curRssi > 72)&&(preRssi < 72))
-	      		{
-                		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_2;
-	       	}
-              	else if ((curRssi < 72)&&( preRssi > 72))
-	     		{
-                   		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_3;
-	       	}
-	       	else if (curRssi < 68)		 //RSSI is NOT large enough!!==> Exit AGC RX High Power Mode
-	       	{
-                   		pRX_HP_Table->Cur_pw_th = pw_th_10dB;
-				pRX_HP_Table->RXHP_flag = 0;    // Back to Normal DIG Mode		  
-				psd_intf_flag = 0;
-			}
-		}
-		else    // pRX_HP_Table->RXHP_flag == 0
-		{
-			//1 Decide whether to enter AGC RX High Power Mode
-			if ((curRssi > 70) && (psd_intf_flag == 1) && (FalseAlmCnt->Cnt_all > FA_TH) &&  
-				(pDM_DigTable->CurIGValue == pDM_DigTable->rx_gain_range_max))
-			{
-             			if (curRssi > 80)
-             			{
-					pRX_HP_Table->Cur_IGI = LNA_Low_Gain_1;
-				}
-				else if (curRssi > 72) 
-              		{
-               			pRX_HP_Table->Cur_IGI = LNA_Low_Gain_2;
-				}
-             			else
-            			{
-                   			pRX_HP_Table->Cur_IGI = LNA_Low_Gain_3;
-				}
-           			pRX_HP_Table->Cur_pw_th = pw_th_16dB;		//RegC54[9:8]=2'b11: to enter AGC Flow 3
-				pRX_HP_Table->First_time_enter = TRUE;
-				pRX_HP_Table->RXHP_flag = 1;    //	RXHP_flag=1: AGC RX High Power Mode, RXHP_flag=0: Normal DIG Mode
-			}
-		}
-		preRssi = curRssi; 
-		odm_Write_RXHP(pDM_Odm);	
-	}
-#endif //#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN))
-#endif //#if (DEV_BUS_TYPE == RT_PCI_INTERFACE) | (DEV_BUS_TYPE == RT_USB_INTERFACE)
-}
-
-void odm_Write_RXHP(
-	IN	PDM_ODM_T	pDM_Odm)
-{
-	pRXHP_T		pRX_HP_Table = &pDM_Odm->DM_RXHP_Table;
-	u4Byte		currentIGI;
-
-	if(pRX_HP_Table->Cur_IGI != pRX_HP_Table->Pre_IGI)
-	{
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);
-	     	ODM_SetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);	
-	}
-	
-	if(pRX_HP_Table->Cur_pw_th != pRX_HP_Table->Pre_pw_th)
-{
-		ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore2, BIT8|BIT9, pRX_HP_Table->Cur_pw_th);  // RegC54[9:8]=2'b11:  AGC Flow 3
-	}
-
-	if(pRX_HP_Table->RXHP_flag == 0)
-	{
-		pRX_HP_Table->Cur_IGI = 0x20;
-	}
-	else
-	{
-		currentIGI = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0);
-		if(currentIGI<0x50)
-		{
-			ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);
-	     		ODM_SetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);	
-		}
-	}
-	pRX_HP_Table->Pre_IGI = pRX_HP_Table->Cur_IGI;
-	pRX_HP_Table->Pre_pw_th = pRX_HP_Table->Cur_pw_th;
-
-}
-
-VOID
-odm_PSD_RXHP(
-	IN	PDM_ODM_T	pDM_Odm
-)
-{
-	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
-	PADAPTER		Adapter =  pDM_Odm->Adapter;
-	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
-	unsigned int 		pts, start_point, stop_point, initial_gain ;
-	static u1Byte		PSD_bitmap_memory[80], init_memory = 0;
-	static u1Byte 		psd_cnt=0;
-	static u4Byte		PSD_report[80], PSD_report_tmp;
-	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
-	u1Byte			idx[20]={96,99,102,106,109,112,115,118,122,125,
-					0,3,6,10,13,16,19,22,26,29};
-	u1Byte			n, i, channel, BBReset,tone_idx;
-	u1Byte			PSD_bitmap[10]/*, SSBT=0*/,initial_gain_psd=0, RSSI_BT=0, initialGainUpper;
-	s4Byte    			PSD_skip_start, PSD_skip_stop;
-	u4Byte			CurrentChannel, RXIQI, RxIdleLowPwr, wlan_channel;
-	u4Byte			ReScan, Interval, Is40MHz;
-	u8Byte			curTxOkCnt, curRxOkCnt;
-	//--------------2G band synthesizer for 92D switch RF channel using----------------- 
-	u1Byte			group_idx=0;
-	u4Byte			SYN_RF25=0, SYN_RF26=0, SYN_RF27=0, SYN_RF2B=0, SYN_RF2C=0;
-	u4Byte			SYN[5] = {0x25, 0x26, 0x27, 0x2B, 0x2C};    // synthesizer RF register for 2G channel
-	u4Byte			SYN_group[3][5] = {{0x643BC, 0xFC038, 0x77C1A, 0x41289, 0x01840},     // For CH1,2,4,9,10.11.12   {0x643BC, 0xFC038, 0x77C1A, 0x41289, 0x01840}
-									    {0x643BC, 0xFC038, 0x07C1A, 0x41289, 0x01840},     // For CH3,13,14
-									    {0x243BC, 0xFC438, 0x07C1A, 0x4128B, 0x0FC41}};   // For Ch5,6,7,8
-       //--------------------- Add by Gary for Debug setting ----------------------
-  	u1Byte                 RSSI_BT_new = (u1Byte) ODM_GetBBReg(pDM_Odm, 0xB9C, 0xFF);
-       u1Byte                 rssi_ctrl = (u1Byte) ODM_GetBBReg(pDM_Odm, 0xB38, 0xFF);
-       //---------------------------------------------------------------------
-	
-	if(pMgntInfo->bScanInProgress)
-	{
-		return;
-	}
-
-	ReScan = PSD_RESCAN;
-	Interval = SCAN_INTERVAL;
-
-
-	//1 Initialization
-	if(init_memory == 0)
-	{
-		RT_TRACE(	COMP_PSD, DBG_LOUD,("Init memory\n"));
-		for(i = 0; i < 80; i++)
-			PSD_bitmap_memory[i] = 0xFF; // channel is always good
-		init_memory = 1;
-	}
-	if(psd_cnt == 0)
-	{
-		RT_TRACE(COMP_PSD, DBG_LOUD,("Enter dm_PSD_Monitor\n"));
-		for(i = 0; i < 80; i++)
-			PSD_report[i] = 0;
-	}
-
-	//1 Backup Current Settings
-	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask);
-	if(pDM_Odm->SupportICType == ODM_RTL8192D)
-	{
-		//2 Record Current synthesizer parameters based on current channel
-		if((*(pDM_Odm->pMacPhyMode)==ODM_SMSP)||(*(pDM_Odm->pMacPhyMode)==ODM_DMSP))
-		{
-			SYN_RF25 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x25, bMaskDWord);
-			SYN_RF26 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x26, bMaskDWord);
-			SYN_RF27 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, bMaskDWord);
-			SYN_RF2B = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2B, bMaskDWord);
-			SYN_RF2C = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2C, bMaskDWord);
-       	}
-		else     // DualMAC_DualPHY 2G
-		{
-			SYN_RF25 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x25, bMaskDWord);
-			SYN_RF26 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x26, bMaskDWord);
-			SYN_RF27 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, bMaskDWord);
-			SYN_RF2B = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2B, bMaskDWord);
-			SYN_RF2C = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2C, bMaskDWord);
-		}
-	}
-	RXIQI = ODM_GetBBReg(pDM_Odm, 0xC14, bMaskDWord);
-	RxIdleLowPwr = (ODM_GetBBReg(pDM_Odm, 0x818, bMaskDWord)&BIT28)>>28;
-	Is40MHz = *(pDM_Odm->pBandWidth);
-	ODM_RT_TRACE(pDM_Odm,	COMP_PSD, DBG_LOUD,("PSD Scan Start\n"));
-	//1 Turn off CCK
-	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0);
-	//1 Turn off TX
-	//Pause TX Queue
-	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0xFF);
-	//Force RX to stop TX immediately
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x32E13);
-	//1 Turn off RX
-	//Rx AGC off  RegC70[0]=0, RegC7C[20]=0
-	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 0);
-	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 0);
-	//Turn off CCA
-	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, 0x0);
-	//BB Reset
-	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 1); //clock gated to prevent from AGC table mess 
-	BBReset = ODM_Read1Byte(pDM_Odm, 0x02);
-	ODM_Write1Byte(pDM_Odm, 0x02, BBReset&(~BIT0));
-	ODM_Write1Byte(pDM_Odm, 0x02, BBReset|BIT0);
-	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 0);
-	//1 Leave RX idle low power
-	ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0);
-	//1 Fix initial gain
-      	RSSI_BT = RSSI_BT_new;
-	RT_TRACE(COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
-	
-	if(rssi_ctrl == 1)        // just for debug!!
-		initial_gain_psd = RSSI_BT_new; 
-     	else
-		initial_gain_psd = pDM_Odm->RSSI_Min;    // PSD report based on RSSI
-	
-	RT_TRACE(COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
-	
-	initialGainUpper = 0x54;
-	
-	RSSI_BT = initial_gain_psd;
-	//SSBT = RSSI_BT;
-	
-	//RT_TRACE(	COMP_PSD, DBG_LOUD,("PSD: SSBT= %d\n", SSBT));
-	RT_TRACE(	COMP_PSD, DBG_LOUD,("PSD: initial gain= 0x%x\n", initial_gain_psd));
-	
-	pDM_Odm->bDMInitialGainEnable = FALSE;		
-	initial_gain = ODM_GetBBReg(pDM_Odm, 0xc50, bMaskDWord) & 0x7F;
-	//ODM_SetBBReg(pDM_Odm, 0xc50, 0x7F, initial_gain_psd);	
-	ODM_Write_DIG(pDM_Odm, initial_gain_psd);
-	//1 Turn off 3-wire
-	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0xF);
-
-	//pts value = 128, 256, 512, 1024
-	pts = 128;
-
-	if(pts == 128)
-	{
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
-		start_point = 64;
-		stop_point = 192;
-	}
-	else if(pts == 256)
-	{
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x1);
-		start_point = 128;
-		stop_point = 384;
-	}
-	else if(pts == 512)
-	{
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x2);
-		start_point = 256;
-		stop_point = 768;
-	}
-	else
-	{
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x3);
-		start_point = 512;
-		stop_point = 1536;
-	}
-	
-
-//3 Skip WLAN channels if WLAN busy
-	curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast) - lastTxOkCnt;
-	curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast) - lastRxOkCnt;
-	lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
-	lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);
-	
-	PSD_skip_start=80;
-	PSD_skip_stop = 0;
-	wlan_channel = CurrentChannel & 0x0f;
-
-	RT_TRACE(COMP_PSD,DBG_LOUD,("PSD: current channel: %x, BW:%d \n", wlan_channel, Is40MHz));
-	
-	if((curRxOkCnt+curTxOkCnt) > 1000)
-	{
-		PSD_skip_start = (wlan_channel-1)*5 -Is40MHz*10;
-		PSD_skip_stop = PSD_skip_start + (1+Is40MHz)*20;
-	}
-
-	RT_TRACE(COMP_PSD,DBG_LOUD,("PSD: Skip tone from %d to %d \n", PSD_skip_start, PSD_skip_stop));
-
- 	for (n=0;n<80;n++)
- 	{
- 		if((n%20)==0)
- 		{
-			channel = (n/20)*4 + 1;
-			if(pDM_Odm->SupportICType == ODM_RTL8192D)
-			{
-				switch(channel)
-				{
-					case 1: 
-					case 9:
-						group_idx = 0;
-						break;
-					case 5:
-						group_idx = 2;
-						break;
-					case 13:
-				 		group_idx = 1;
-						break;
-				}
-				if((*(pDM_Odm->pMacPhyMode)==ODM_SMSP)||(*(pDM_Odm->pMacPhyMode)==ODM_DMSP))   
-		{
-					for(i = 0; i < SYN_Length; i++)
-						ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, SYN[i], bMaskDWord, SYN_group[group_idx][i]);
-
-					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
-					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, 0x3FF, channel);
-				}
-				else  // DualMAC_DualPHY 2G
-			{
-					for(i = 0; i < SYN_Length; i++)
-						ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, SYN[i], bMaskDWord, SYN_group[group_idx][i]);   
-					
-					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
-				}
-			}
-			else
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
-			}	
-		tone_idx = n%20;
-		if ((n>=PSD_skip_start) && (n<PSD_skip_stop))
-		{	
-			PSD_report[n] = initial_gain_psd;//SSBT;
-			ODM_RT_TRACE(pDM_Odm,COMP_PSD,DBG_LOUD,("PSD:Tone %d skipped \n", n));
-		}
-		else
-		{
-			PSD_report_tmp =  GetPSDData(pDM_Odm, idx[tone_idx], initial_gain_psd);
-
-			if ( PSD_report_tmp > PSD_report[n])
-				PSD_report[n] = PSD_report_tmp;
-				
-		}
-	}
-
-	PatchDCTone(pDM_Odm, PSD_report, initial_gain_psd);
-      
-       //----end
-	//1 Turn on RX
-	//Rx AGC on
-	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 1);
-	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 1);
-	//CCK on
-	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 1);
-	//1 Turn on TX
-	//Resume TX Queue
-	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0x00);
-	//Turn on 3-wire
-	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0x0);
-	//1 Restore Current Settings
-	//Resume DIG
-	pDM_Odm->bDMInitialGainEnable= TRUE;
-	//ODM_SetBBReg(pDM_Odm, 0xc50, 0x7F, initial_gain);
-	ODM_Write_DIG(pDM_Odm,(u1Byte) initial_gain);
-	// restore originl center frequency
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, CurrentChannel);
-	if(pDM_Odm->SupportICType == ODM_RTL8192D)
-	{
-		if((*(pDM_Odm->pMacPhyMode)==ODM_SMSP)||(*(pDM_Odm->pMacPhyMode)==ODM_DMSP))
-		{
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, bMaskDWord, CurrentChannel);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x25, bMaskDWord, SYN_RF25);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x26, bMaskDWord, SYN_RF26);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, bMaskDWord, SYN_RF27);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2B, bMaskDWord, SYN_RF2B);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2C, bMaskDWord, SYN_RF2C);
-		}
-		else     // DualMAC_DualPHY
-		{
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x25, bMaskDWord, SYN_RF25);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x26, bMaskDWord, SYN_RF26);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, bMaskDWord, SYN_RF27);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2B, bMaskDWord, SYN_RF2B);
-			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2C, bMaskDWord, SYN_RF2C);
-		}
-	}
-	//Turn on CCA
-	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, RXIQI);
-	//Restore RX idle low power
-	if(RxIdleLowPwr == TRUE)
-		ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 1);
-	
-	psd_cnt++;
-	//gPrint("psd cnt=%d\n", psd_cnt);
-	ODM_RT_TRACE(pDM_Odm,COMP_PSD, DBG_LOUD,("PSD:psd_cnt = %d \n",psd_cnt));
-	if (psd_cnt < ReScan)
-	{
-		ODM_SetTimer(pDM_Odm, &pRX_HP_Table->PSDTimer, Interval);  //ms
-	}
-	else
-			{	
-		psd_cnt = 0;
-		for(i=0;i<80;i++)
-			RT_TRACE(	COMP_PSD, DBG_LOUD,("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]));
-			//DbgPrint("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]);
-
-		GoodChannelDecision(pDM_Odm, PSD_report, PSD_bitmap,RSSI_BT, PSD_bitmap_memory);
-
-			}
-		}
-
-VOID
-odm_PSD_RXHPCallback(
-	PRT_TIMER		pTimer
-)
-{
-	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
-	
-#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-	#if USE_WORKITEM
-	ODM_ScheduleWorkItem(&pRX_HP_Table->PSDTimeWorkitem);
-	#else
-	odm_PSD_RXHP(pDM_Odm);
-	#endif
-#else
-	ODM_ScheduleWorkItem(&pRX_HP_Table->PSDTimeWorkitem);
-#endif
-	
-	}
-
-VOID
-odm_PSD_RXHPWorkitemCallback(
-    IN PVOID            pContext
-    )
-{
-	PADAPTER	pAdapter = (PADAPTER)pContext;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-	
-	odm_PSD_RXHP(pDM_Odm);
-}
-
-#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-VOID
-odm_PathDiversityInit(
-	IN	PDM_ODM_T	pDM_Odm
-)
-{
-	if(!(pDM_Odm->SupportAbility & ODM_BB_PATH_DIV))
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("Return: Not Support PathDiv\n"));
-		return;
-	}
-
-#if RTL8812A_SUPPORT
-
-	if(pDM_Odm->SupportICType & ODM_RTL8812)
-		ODM_PathDiversityInit_8812A(pDM_Odm);
-#endif	
-}
-
-
-VOID
-odm_PathDiversity(
-	IN	PDM_ODM_T	pDM_Odm
-)
-{
-	if(!(pDM_Odm->SupportAbility & ODM_BB_PATH_DIV))
-	{
-		ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("Return: Not Support PathDiv\n"));
-		return;
-	}
-
-#if RTL8812A_SUPPORT
-
-	if(pDM_Odm->SupportICType & ODM_RTL8812)
-		ODM_PathDiversity_8812A(pDM_Odm);
-#endif	
-}
-
-
-//
-// 2011/12/02 MH Copy from MP oursrc for temporarily test.
-//
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID
-odm_OFDMTXPathDiversity_92C(
-	IN	PADAPTER	Adapter)
-{
-//	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
-	PRT_WLAN_STA	pEntry;
-	u1Byte	i, DefaultRespPath = 0;
-	s4Byte	MinRSSI = 0xFF;
-	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
-	pDM_PDTable->OFDMTXPath = 0;
-	
-	//1 Default Port
-	if(pMgntInfo->mAssoc)
-	{
-		RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: Default port RSSI[0]=%d, RSSI[1]=%d\n",
-			Adapter->RxStats.RxRSSIPercentage[0], Adapter->RxStats.RxRSSIPercentage[1]));
-		if(Adapter->RxStats.RxRSSIPercentage[0] > Adapter->RxStats.RxRSSIPercentage[1])
-		{
-			pDM_PDTable->OFDMTXPath = pDM_PDTable->OFDMTXPath & (~BIT0);
-			MinRSSI =  Adapter->RxStats.RxRSSIPercentage[1];
-			DefaultRespPath = 0;
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: Default port Select Path-0\n"));
-		}
-		else
-		{
-			pDM_PDTable->OFDMTXPath =  pDM_PDTable->OFDMTXPath | BIT0;
-			MinRSSI =  Adapter->RxStats.RxRSSIPercentage[0];
-			DefaultRespPath = 1;
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: Default port Select Path-1\n"));
-		}
-		//RT_TRACE(	COMP_SWAS, DBG_LOUD, ("pDM_PDTable->OFDMTXPath =0x%x\n",pDM_PDTable->OFDMTXPath));
-	}
-	//1 Extension Port
-	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
-			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
-		else
-			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
-
-		if(pEntry!=NULL)
-		{
-			if(pEntry->bAssociated)
-			{
-				RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: MACID=%d, RSSI_0=%d, RSSI_1=%d\n", 
-					pEntry->AssociatedMacId, pEntry->rssi_stat.RxRSSIPercentage[0], pEntry->rssi_stat.RxRSSIPercentage[1]));
-				
-				if(pEntry->rssi_stat.RxRSSIPercentage[0] > pEntry->rssi_stat.RxRSSIPercentage[1])
-				{
-					pDM_PDTable->OFDMTXPath = pDM_PDTable->OFDMTXPath & ~(BIT(pEntry->AssociatedMacId));
-					//pHalData->TXPath = pHalData->TXPath & ~(1<<(pEntry->AssociatedMacId));
-					RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: MACID=%d Select Path-0\n", pEntry->AssociatedMacId));
-					if(pEntry->rssi_stat.RxRSSIPercentage[1] < MinRSSI)
-					{
-						MinRSSI = pEntry->rssi_stat.RxRSSIPercentage[1];
-						DefaultRespPath = 0;
-					}
-				}
-				else
-				{
-					pDM_PDTable->OFDMTXPath = pDM_PDTable->OFDMTXPath | BIT(pEntry->AssociatedMacId);
-					//pHalData->TXPath = pHalData->TXPath | (1 << (pEntry->AssociatedMacId));
-					RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: MACID=%d Select Path-1\n", pEntry->AssociatedMacId));
-					if(pEntry->rssi_stat.RxRSSIPercentage[0] < MinRSSI)
-					{
-						MinRSSI = pEntry->rssi_stat.RxRSSIPercentage[0];
-						DefaultRespPath = 1;
-					}
-				}
-			}
-		}
-		else
-		{
-			break;
-		}
-	}
-
-	pDM_PDTable->OFDMDefaultRespPath = DefaultRespPath;
-}
-
-
-BOOLEAN
-odm_IsConnected_92C(
-	IN	PADAPTER	Adapter
-)
-{
-	PRT_WLAN_STA	pEntry;
-	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
-	u4Byte		i;
-	BOOLEAN		bConnected=FALSE;
-	
-	if(pMgntInfo->mAssoc)
-	{
-		bConnected = TRUE;
-	}
-	else
-	{
-		for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
-		{
-			if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
-				pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
-			else
-				pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
-
-			if(pEntry!=NULL)
-			{
-				if(pEntry->bAssociated)
-				{
-					bConnected = TRUE;
-					break;
-				}
-			}
-			else
-			{
-				break;
-			}
-		}
-	}
-	return	bConnected;
-}
-
-
-VOID
-odm_ResetPathDiversity_92C(
-		IN	PADAPTER	Adapter
-)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
-	PRT_WLAN_STA	pEntry;
-	u4Byte	i,j;
-
-	pHalData->RSSI_test = FALSE;
-	pDM_PDTable->CCK_Pkt_Cnt = 0;
-	pDM_PDTable->OFDM_Pkt_Cnt = 0;
-	pHalData->CCK_Pkt_Cnt =0;
-	pHalData->OFDM_Pkt_Cnt =0;
-	
-	if(pDM_PDTable->CCKPathDivEnable == TRUE)	
-		PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x01); //RX path = PathAB
-
-	for(i=0; i<2; i++)
-	{
-		pDM_PDTable->RSSI_CCK_Path_cnt[i]=0;
-		pDM_PDTable->RSSI_CCK_Path[i] = 0;
-	}
-	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
-			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
-		else
-			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
-
-		if(pEntry!=NULL)
-		{
-			pEntry->rssi_stat.CCK_Pkt_Cnt = 0;
-			pEntry->rssi_stat.OFDM_Pkt_Cnt = 0;
-			for(j=0; j<2; j++)
-			{
-				pEntry->rssi_stat.RSSI_CCK_Path_cnt[j] = 0;
-				pEntry->rssi_stat.RSSI_CCK_Path[j] = 0;
-			}
-		}
-		else
-			break;
-	}
-}
-
-
-VOID
-odm_CCKTXPathDiversity_92C(
-	IN	PADAPTER	Adapter
-)
-{
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
-	PRT_WLAN_STA	pEntry;
-	s4Byte	MinRSSI = 0xFF;
-	u1Byte	i, DefaultRespPath = 0;
-//	BOOLEAN	bBModePathDiv = FALSE;
-	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
-
-	//1 Default Port
-	if(pMgntInfo->mAssoc)
-	{
-		if(pHalData->OFDM_Pkt_Cnt == 0)
-		{
-			for(i=0; i<2; i++)
-			{
-				if(pDM_PDTable->RSSI_CCK_Path_cnt[i] > 1) //Because the first packet is discarded
-					pDM_PDTable->RSSI_CCK_Path[i] = pDM_PDTable->RSSI_CCK_Path[i] / (pDM_PDTable->RSSI_CCK_Path_cnt[i]-1);
-				else
-					pDM_PDTable->RSSI_CCK_Path[i] = 0;
-			}
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: pDM_PDTable->RSSI_CCK_Path[0]=%d, pDM_PDTable->RSSI_CCK_Path[1]=%d\n",
-				pDM_PDTable->RSSI_CCK_Path[0], pDM_PDTable->RSSI_CCK_Path[1]));
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: pDM_PDTable->RSSI_CCK_Path_cnt[0]=%d, pDM_PDTable->RSSI_CCK_Path_cnt[1]=%d\n",
-				pDM_PDTable->RSSI_CCK_Path_cnt[0], pDM_PDTable->RSSI_CCK_Path_cnt[1]));
-		
-			if(pDM_PDTable->RSSI_CCK_Path[0] > pDM_PDTable->RSSI_CCK_Path[1])
-			{
-				pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & (~BIT0);
-				MinRSSI =  pDM_PDTable->RSSI_CCK_Path[1];
-				DefaultRespPath = 0;
-				RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port Select CCK Path-0\n"));
-			}
-			else if(pDM_PDTable->RSSI_CCK_Path[0] < pDM_PDTable->RSSI_CCK_Path[1])
-			{
-				pDM_PDTable->CCKTXPath =  pDM_PDTable->CCKTXPath | BIT0;
-				MinRSSI =  pDM_PDTable->RSSI_CCK_Path[0];
-				DefaultRespPath = 1;
-				RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port Select CCK Path-1\n"));
-			}
-			else
-			{
-				if((pDM_PDTable->RSSI_CCK_Path[0] != 0) && (pDM_PDTable->RSSI_CCK_Path[0] < MinRSSI))
-				{
-					pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & (~BIT0);
-					RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port Select CCK Path-0\n"));
-					MinRSSI =  pDM_PDTable->RSSI_CCK_Path[1];
-					DefaultRespPath = 0;
-				}
-				else
-				{
-					RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port unchange CCK Path\n"));
-				}
-			}
-		}
-		else //Follow OFDM decision
-		{
-			pDM_PDTable->CCKTXPath = (pDM_PDTable->CCKTXPath & (~BIT0)) | (pDM_PDTable->OFDMTXPath &BIT0);
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Follow OFDM decision, Default port Select CCK Path-%d\n",
-				pDM_PDTable->CCKTXPath &BIT0));
-		}
-	}
-	//1 Extension Port
-	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
-	{
-		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
-			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
-		else
-			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
-
-		if(pEntry!=NULL)
-		{
-			if(pEntry->bAssociated)
-			{
-				if(pEntry->rssi_stat.OFDM_Pkt_Cnt == 0)
-				{
-					u1Byte j=0;
-					for(j=0; j<2; j++)
-					{
-						if(pEntry->rssi_stat.RSSI_CCK_Path_cnt[j] > 1)
-							pEntry->rssi_stat.RSSI_CCK_Path[j] = pEntry->rssi_stat.RSSI_CCK_Path[j] / (pEntry->rssi_stat.RSSI_CCK_Path_cnt[j]-1);
-						else
-							pEntry->rssi_stat.RSSI_CCK_Path[j] = 0;
-					}
-					RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d, RSSI_CCK0=%d, RSSI_CCK1=%d\n", 
-						pEntry->AssociatedMacId, pEntry->rssi_stat.RSSI_CCK_Path[0], pEntry->rssi_stat.RSSI_CCK_Path[1]));
-					
-					if(pEntry->rssi_stat.RSSI_CCK_Path[0] >pEntry->rssi_stat.RSSI_CCK_Path[1])
-					{
-						pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & ~(BIT(pEntry->AssociatedMacId));
-						RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d Select CCK Path-0\n", pEntry->AssociatedMacId));
-						if(pEntry->rssi_stat.RSSI_CCK_Path[1] < MinRSSI)
-						{
-							MinRSSI = pEntry->rssi_stat.RSSI_CCK_Path[1];
-							DefaultRespPath = 0;
-						}
-					}
-					else if(pEntry->rssi_stat.RSSI_CCK_Path[0] <pEntry->rssi_stat.RSSI_CCK_Path[1])
-					{
-						pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath | BIT(pEntry->AssociatedMacId);
-						RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d Select CCK Path-1\n", pEntry->AssociatedMacId));
-						if(pEntry->rssi_stat.RSSI_CCK_Path[0] < MinRSSI)
-						{
-							MinRSSI = pEntry->rssi_stat.RSSI_CCK_Path[0];
-							DefaultRespPath = 1;
-						}
-					}
-					else
-					{
-						if((pEntry->rssi_stat.RSSI_CCK_Path[0] != 0) && (pEntry->rssi_stat.RSSI_CCK_Path[0] < MinRSSI))
-						{
-							pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & ~(BIT(pEntry->AssociatedMacId));
-							MinRSSI = pEntry->rssi_stat.RSSI_CCK_Path[1];
-							DefaultRespPath = 0;
-							RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d Select CCK Path-0\n", pEntry->AssociatedMacId));
-						}
-						else
-						{
-							RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d unchange CCK Path\n", pEntry->AssociatedMacId));
-						}
-					}
-				}
-				else //Follow OFDM decision
-				{
-					pDM_PDTable->CCKTXPath = (pDM_PDTable->CCKTXPath & (~(BIT(pEntry->AssociatedMacId)))) | (pDM_PDTable->OFDMTXPath & BIT(pEntry->AssociatedMacId));
-					RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Follow OFDM decision, MACID=%d Select CCK Path-%d\n",
-						pEntry->AssociatedMacId, (pDM_PDTable->CCKTXPath & BIT(pEntry->AssociatedMacId))>>(pEntry->AssociatedMacId)));
-				}
-			}
-		}
-		else
-		{
-			break;
-		}
-	}
-
-	RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C:MinRSSI=%d\n",MinRSSI));
-
-	if(MinRSSI == 0xFF)
-		DefaultRespPath = pDM_PDTable->CCKDefaultRespPath;
-
-	pDM_PDTable->CCKDefaultRespPath = DefaultRespPath;
-}
-
-
-
-VOID
-odm_PathDiversityAfterLink_92C(
-	IN	PADAPTER	Adapter
-)
-{
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-	pPD_T		pDM_PDTable = &Adapter->DM_PDTable;
-	u1Byte		DefaultRespPath=0;
-
-	if((!IS_92C_SERIAL(pHalData->VersionID)) || (pHalData->PathDivCfg != 1) || (pHalData->eRFPowerState == eRfOff))
-	{
-		if(pHalData->PathDivCfg == 0)
-		{
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("No ODM_TXPathDiversity()\n"));
-		}
-		else
-		{
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("2T ODM_TXPathDiversity()\n"));
-		}
-		return;
-	}
-	if(!odm_IsConnected_92C(Adapter))
-	{
-		RT_TRACE(	COMP_SWAS, DBG_LOUD, ("ODM_TXPathDiversity(): No Connections\n"));
-		return;
-	}
-	
-	
-	if(pDM_PDTable->TrainingState == 0)
-	{
-		RT_TRACE(	COMP_SWAS, DBG_LOUD, ("ODM_TXPathDiversity() ==>\n"));
-		odm_OFDMTXPathDiversity_92C(Adapter);
-
-		if((pDM_PDTable->CCKPathDivEnable == TRUE) && (pDM_PDTable->OFDM_Pkt_Cnt < 100))
-		{
-			//RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: TrainingState=0\n"));
-			
-			if(pDM_PDTable->CCK_Pkt_Cnt > 300)
-				pDM_PDTable->Timer = 20;
-			else if(pDM_PDTable->CCK_Pkt_Cnt > 100)
-				pDM_PDTable->Timer = 60;
-			else
-				pDM_PDTable->Timer = 250;
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: timer=%d\n",pDM_PDTable->Timer));
-
-			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x00); // RX path = PathA
-			pDM_PDTable->TrainingState = 1;
-			pHalData->RSSI_test = TRUE;
-			ODM_SetTimer( pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, pDM_PDTable->Timer); //ms
-		}
-		else
-		{
-			pDM_PDTable->CCKTXPath = pDM_PDTable->OFDMTXPath;
-			DefaultRespPath = pDM_PDTable->OFDMDefaultRespPath;
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_SetRespPath_92C: Skip odm_CCKTXPathDiversity_92C, DefaultRespPath is OFDM\n"));
-			odm_SetRespPath_92C(Adapter, DefaultRespPath);
-			odm_ResetPathDiversity_92C(Adapter);
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("ODM_TXPathDiversity() <==\n"));
-		}
-	}
-	else if(pDM_PDTable->TrainingState == 1)
-	{
-		//RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: TrainingState=1\n"));
-		PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x05); // RX path = PathB
-		pDM_PDTable->TrainingState = 2;
-		ODM_SetTimer( pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, pDM_PDTable->Timer); //ms
-	}
-	else
-	{
-		//RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: TrainingState=2\n"));
-		pDM_PDTable->TrainingState = 0;	
-		odm_CCKTXPathDiversity_92C(Adapter); 
-		if(pDM_PDTable->OFDM_Pkt_Cnt != 0)
-		{
-			DefaultRespPath = pDM_PDTable->OFDMDefaultRespPath;
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_SetRespPath_92C: DefaultRespPath is OFDM\n"));
-		}
-		else
-		{
-			DefaultRespPath = pDM_PDTable->CCKDefaultRespPath;
-			RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_SetRespPath_92C: DefaultRespPath is CCK\n"));
-		}
-		odm_SetRespPath_92C(Adapter, DefaultRespPath);
-		odm_ResetPathDiversity_92C(Adapter);
-		RT_TRACE(	COMP_SWAS, DBG_LOUD, ("ODM_TXPathDiversity() <==\n"));
-	}
-
-}
-
-
-
-VOID
-odm_CCKTXPathDiversityCallback(
-	PRT_TIMER		pTimer
-)
-{
-#if USE_WORKITEM
-       PADAPTER	Adapter = (PADAPTER)pTimer->Adapter;
-       HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	   PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-#else
-	PADAPTER	Adapter = (PADAPTER)pTimer->Adapter;
-#endif
-
-#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-#if USE_WORKITEM
-	PlatformScheduleWorkItem(&pDM_Odm->CCKPathDiversityWorkitem);
-#else
-	odm_PathDiversityAfterLink_92C(Adapter);
-#endif
-#else
-	PlatformScheduleWorkItem(&pDM_Odm->CCKPathDiversityWorkitem);
-#endif
-
-}
-
-
-VOID
-odm_CCKTXPathDiversityWorkItemCallback(
-    IN PVOID            pContext
-    )
-{
-	PADAPTER	Adapter = (PADAPTER)pContext;
-
-	odm_CCKTXPathDiversity_92C(Adapter);
-}
-
-
-VOID
-ODM_CCKPathDiversityChkPerPktRssi(
-	PADAPTER		Adapter,
-	BOOLEAN			bIsDefPort,
-	BOOLEAN			bMatchBSSID,
-	PRT_WLAN_STA	pEntry,
-	PRT_RFD			pRfd,
-	pu1Byte			pDesc
-	)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	BOOLEAN			bCount = FALSE;
-	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
-	//BOOLEAN	isCCKrate = RX_HAL_IS_CCK_RATE_92C(pDesc);
-#if DEV_BUS_TYPE != RT_SDIO_INTERFACE
-	BOOLEAN	isCCKrate = RX_HAL_IS_CCK_RATE(Adapter, pDesc);
-#else  //below code would be removed if we have verified SDIO
-	BOOLEAN	isCCKrate = IS_HARDWARE_TYPE_8188E(Adapter) ? RX_HAL_IS_CCK_RATE_88E(pDesc) : RX_HAL_IS_CCK_RATE_92C(pDesc);
-#endif
-
-	if((pHalData->PathDivCfg != 1) || (pHalData->RSSI_test == FALSE))
-		return;
-		
-	if(pHalData->RSSI_target==NULL && bIsDefPort && bMatchBSSID)
-		bCount = TRUE;
-	else if(pHalData->RSSI_target!=NULL && pEntry!=NULL && pHalData->RSSI_target==pEntry)
-		bCount = TRUE;
-
-	if(bCount && isCCKrate)
-	{
-		if(pDM_PDTable->TrainingState == 1 )
-		{
-			if(pEntry)
-			{
-				if(pEntry->rssi_stat.RSSI_CCK_Path_cnt[0] != 0)
-					pEntry->rssi_stat.RSSI_CCK_Path[0] += pRfd->Status.RxPWDBAll;
-				pEntry->rssi_stat.RSSI_CCK_Path_cnt[0]++;
-			}
-			else
-			{
-				if(pDM_PDTable->RSSI_CCK_Path_cnt[0] != 0)
-					pDM_PDTable->RSSI_CCK_Path[0] += pRfd->Status.RxPWDBAll;
-				pDM_PDTable->RSSI_CCK_Path_cnt[0]++;
-			}
-		}
-		else if(pDM_PDTable->TrainingState == 2 )
-		{
-			if(pEntry)
-			{
-				if(pEntry->rssi_stat.RSSI_CCK_Path_cnt[1] != 0)
-					pEntry->rssi_stat.RSSI_CCK_Path[1] += pRfd->Status.RxPWDBAll;
-				pEntry->rssi_stat.RSSI_CCK_Path_cnt[1]++;
-			}
-			else
-			{
-				if(pDM_PDTable->RSSI_CCK_Path_cnt[1] != 0)
-					pDM_PDTable->RSSI_CCK_Path[1] += pRfd->Status.RxPWDBAll;
-				pDM_PDTable->RSSI_CCK_Path_cnt[1]++;
-			}
-		}
-	}
-}
-
-
-BOOLEAN
-ODM_PathDiversityBeforeLink92C(
-	//IN	PADAPTER	Adapter
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-#if (RT_MEM_SIZE_LEVEL != RT_MEM_SIZE_MINIMUM)
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE*	pHalData = NULL;
-	PMGNT_INFO		pMgntInfo = NULL;
-	//pSWAT_T		pDM_SWAT_Table = &Adapter->DM_SWAT_Table;
-	pPD_T			pDM_PDTable = NULL;
-
-	s1Byte			Score = 0;
-	PRT_WLAN_BSS	pTmpBssDesc;
-	PRT_WLAN_BSS	pTestBssDesc;
-
-	u1Byte			target_chnl = 0;
-	u1Byte			index;
-
-	if (pDM_Odm->Adapter == NULL)  //For BSOD when plug/unplug fast.  //By YJ,120413
-	{	// The ODM structure is not initialized.
-		return FALSE;
-	}
-	pHalData = GET_HAL_DATA(Adapter);
-	pMgntInfo = &Adapter->MgntInfo;
-	pDM_PDTable = &Adapter->DM_PDTable;
-	
-	// Condition that does not need to use path diversity.
-	if((!IS_92C_SERIAL(pHalData->VersionID)) || (pHalData->PathDivCfg!=1) || pMgntInfo->AntennaTest )
-	{
-		RT_TRACE(COMP_SWAS, DBG_LOUD, 
-				("ODM_PathDiversityBeforeLink92C(): No PathDiv Mechanism before link.\n"));
-		return FALSE;
-	}
-
-	// Since driver is going to set BB register, it shall check if there is another thread controlling BB/RF.
-	PlatformAcquireSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
-	if(pHalData->eRFPowerState!=eRfOn || pMgntInfo->RFChangeInProgress || pMgntInfo->bMediaConnect)
-	{
-		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
-	
-		RT_TRACE(COMP_SWAS, DBG_LOUD, 
-				("ODM_PathDiversityBeforeLink92C(): RFChangeInProgress(%x), eRFPowerState(%x)\n", 
-				pMgntInfo->RFChangeInProgress,
-				pHalData->eRFPowerState));
-	
-		//pDM_SWAT_Table->SWAS_NoLink_State = 0;
-		pDM_PDTable->PathDiv_NoLink_State = 0;
-		
-		return FALSE;
-	}
-	else
-	{
-		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
-	}
-
-	//1 Run AntDiv mechanism "Before Link" part.
-	//if(pDM_SWAT_Table->SWAS_NoLink_State == 0)
-	if(pDM_PDTable->PathDiv_NoLink_State == 0)
-	{
-		//1 Prepare to do Scan again to check current antenna state.
-
-		// Set check state to next step.
-		//pDM_SWAT_Table->SWAS_NoLink_State = 1;
-		pDM_PDTable->PathDiv_NoLink_State = 1;
-	
-		// Copy Current Scan list.
-		Adapter->MgntInfo.tmpNumBssDesc = pMgntInfo->NumBssDesc;
-		PlatformMoveMemory((PVOID)Adapter->MgntInfo.tmpbssDesc, (PVOID)pMgntInfo->bssDesc, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC);
-
-		// Switch Antenna to another one.
-		if(pDM_PDTable->DefaultRespPath == 0)
-		{
-			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x05); // TRX path = PathB
-			odm_SetRespPath_92C(Adapter, 1);
-			pDM_PDTable->OFDMTXPath = 0xFFFFFFFF;
-			pDM_PDTable->CCKTXPath = 0xFFFFFFFF;
-		}
-		else
-		{
-			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x00); // TRX path = PathA
-			odm_SetRespPath_92C(Adapter, 0);
-			pDM_PDTable->OFDMTXPath = 0x0;
-			pDM_PDTable->CCKTXPath = 0x0;
-		}
-#if 0	
-
-		pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
-		pDM_SWAT_Table->CurAntenna = (pDM_SWAT_Table->CurAntenna==Antenna_A)?Antenna_B:Antenna_A;
-		
-		RT_TRACE(COMP_SWAS, DBG_LOUD, 
-			("ODM_SwAntDivCheckBeforeLink: Change to Ant(%s) for testing.\n", (pDM_SWAT_Table->CurAntenna==Antenna_A)?"A":"B"));
-		//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
-		pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
-		PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
-#endif
-
-		// Go back to scan function again.
-		RT_TRACE(COMP_SWAS, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C: Scan one more time\n"));
-		pMgntInfo->ScanStep=0;
-		target_chnl = odm_SwAntDivSelectScanChnl(Adapter);
-		odm_SwAntDivConstructScanChnl(Adapter, target_chnl);
-		PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
-
-		return TRUE;
-	}
-	else
-	{
-		//1 ScanComple() is called after antenna swiched.
-		//1 Check scan result and determine which antenna is going
-		//1 to be used.
-
-		for(index=0; index<Adapter->MgntInfo.tmpNumBssDesc; index++)
-		{
-			pTmpBssDesc = &(Adapter->MgntInfo.tmpbssDesc[index]);
-			pTestBssDesc = &(pMgntInfo->bssDesc[index]);
-
-			if(PlatformCompareMemory(pTestBssDesc->bdBssIdBuf, pTmpBssDesc->bdBssIdBuf, 6)!=0)
-			{
-				RT_TRACE(COMP_SWAS, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C(): ERROR!! This shall not happen.\n"));
-				continue;
-			}
-
-			if(pTmpBssDesc->RecvSignalPower > pTestBssDesc->RecvSignalPower)
-			{
-				RT_TRACE(COMP_SWAS, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C: Compare scan entry: Score++\n"));
-				RT_PRINT_STR(COMP_SWAS, DBG_LOUD, "SSID: ", pTestBssDesc->bdSsIdBuf, pTestBssDesc->bdSsIdLen);
-				RT_TRACE(COMP_SWAS, DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
-			
-				Score++;
-				PlatformMoveMemory(pTestBssDesc, pTmpBssDesc, sizeof(RT_WLAN_BSS));
-			}
-			else if(pTmpBssDesc->RecvSignalPower < pTestBssDesc->RecvSignalPower)
-			{
-				RT_TRACE(COMP_SWAS, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C: Compare scan entry: Score--\n"));
-				RT_PRINT_STR(COMP_SWAS, DBG_LOUD, "SSID: ", pTestBssDesc->bdSsIdBuf, pTestBssDesc->bdSsIdLen);
-				RT_TRACE(COMP_SWAS, DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
-				Score--;
-			}
-
-		}
-
-		if(pMgntInfo->NumBssDesc!=0 && Score<=0)
-		{
-			RT_TRACE(COMP_SWAS, DBG_LOUD,
-				("ODM_PathDiversityBeforeLink92C(): DefaultRespPath=%d\n", pDM_PDTable->DefaultRespPath));
-
-			//pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
-		}
-		else
-		{
-			RT_TRACE(COMP_SWAS, DBG_LOUD, 
-				("ODM_PathDiversityBeforeLink92C(): DefaultRespPath=%d\n", pDM_PDTable->DefaultRespPath));
-
-			if(pDM_PDTable->DefaultRespPath == 0)
-			{
-				pDM_PDTable->OFDMTXPath = 0xFFFFFFFF;
-				pDM_PDTable->CCKTXPath = 0xFFFFFFFF;
-				odm_SetRespPath_92C(Adapter, 1);
-			}
-			else
-			{
-				pDM_PDTable->OFDMTXPath = 0x0;
-				pDM_PDTable->CCKTXPath = 0x0;
-				odm_SetRespPath_92C(Adapter, 0);
-			}
-			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x01); // RX path = PathAB
-
-			//pDM_SWAT_Table->CurAntenna = pDM_SWAT_Table->PreAntenna;
-
-			//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
-			//pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
-			//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
-		}
-
-		// Check state reset to default and wait for next time.
-		//pDM_SWAT_Table->SWAS_NoLink_State = 0;
-		pDM_PDTable->PathDiv_NoLink_State = 0;
-
-		return FALSE;
-	}
-#else
-		return	FALSE;
-#endif
-	
-}
-
-
-//Neil Chen---2011--06--22
-//----92D Path Diversity----//
-//#ifdef PathDiv92D
-//==================================
-//3 Path Diversity 
-//==================================
-//
-// 20100514 Luke/Joseph:
-// Add new function for antenna diversity after link.
-// This is the main function of antenna diversity after link.
-// This function is called in HalDmWatchDog() and ODM_SwAntDivChkAntSwitchCallback().
-// HalDmWatchDog() calls this function with SWAW_STEP_PEAK to initialize the antenna test.
-// In SWAW_STEP_PEAK, another antenna and a 500ms timer will be set for testing.
-// After 500ms, ODM_SwAntDivChkAntSwitchCallback() calls this function to compare the signal just
-// listened on the air with the RSSI of original antenna.
-// It chooses the antenna with better RSSI.
-// There is also a aged policy for error trying. Each error trying will cost more 5 seconds waiting 
-// penalty to get next try.
-//
-//
-// 20100503 Joseph:
-// Add new function SwAntDivCheck8192C().
-// This is the main function of Antenna diversity function before link.
-// Mainly, it just retains last scan result and scan again.
-// After that, it compares the scan result to see which one gets better RSSI.
-// It selects antenna with better receiving power and returns better scan result.
-//
-
-
-//
-// 20100514 Luke/Joseph:
-// This function is used to gather the RSSI information for antenna testing.
-// It selects the RSSI of the peer STA that we want to know.
-//
-VOID
-ODM_PathDivChkPerPktRssi(
-	PADAPTER		Adapter,
-	BOOLEAN			bIsDefPort,
-	BOOLEAN			bMatchBSSID,
-	PRT_WLAN_STA	pEntry,
-	PRT_RFD			pRfd
-	)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
-	BOOLEAN			bCount = FALSE;
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-
-	if(pHalData->RSSI_target==NULL && bIsDefPort && bMatchBSSID)
-		bCount = TRUE;
-	else if(pHalData->RSSI_target!=NULL && pEntry!=NULL && pHalData->RSSI_target==pEntry)
-		bCount = TRUE;
-
-	if(bCount)
-	{
-		//1 RSSI for SW Antenna Switch
-		if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-		{
-			pHalData->RSSI_sum_A += pRfd->Status.RxPWDBAll;
-			pHalData->RSSI_cnt_A++;
-		}
-		else
-		{
-			pHalData->RSSI_sum_B += pRfd->Status.RxPWDBAll;
-			pHalData->RSSI_cnt_B++;
-
-		}
-	}
-}
-
-
-
-//
-// 20100514 Luke/Joseph:
-// Add new function to reset antenna diversity state after link.
-//
-VOID
-ODM_PathDivRestAfterLink(
-	IN	PDM_ODM_T		pDM_Odm
-	)
-{
-	PADAPTER		Adapter=pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-
-	pHalData->RSSI_cnt_A = 0;
-	pHalData->RSSI_cnt_B = 0;
-	pHalData->RSSI_test = FALSE;
-	pDM_SWAT_Table->try_flag = 0x0;       // NOT 0xff
-	pDM_SWAT_Table->RSSI_Trying = 0;
-	pDM_SWAT_Table->SelectAntennaMap=0xAA;
-	pDM_SWAT_Table->CurAntenna = MAIN_ANT;  
-}
-
-
-//
-// 20100514 Luke/Joseph:
-// Callback function for 500ms antenna test trying.
-//
-VOID
-odm_PathDivChkAntSwitchCallback(
-	PRT_TIMER		pTimer
-)
-{
-	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-
-#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-
-#if USE_WORKITEM
-	PlatformScheduleWorkItem(&pDM_Odm->PathDivSwitchWorkitem);
-#else
-	odm_PathDivChkAntSwitch(pDM_Odm);
-#endif
-#else
-	PlatformScheduleWorkItem(&pDM_Odm->PathDivSwitchWorkitem);
-#endif
-
-//odm_SwAntDivChkAntSwitch(Adapter, SWAW_STEP_DETERMINE);
-
-}
-
-
-VOID
-odm_PathDivChkAntSwitchWorkitemCallback(
-    IN PVOID            pContext
-    )
-{
-	PADAPTER	pAdapter = (PADAPTER)pContext;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-
-	odm_PathDivChkAntSwitch(pDM_Odm);
-}
-
-
- //MAC0_ACCESS_PHY1
-
-// 2011-06-22 Neil Chen & Gary Hsin
-// Refer to Jr.Luke's SW ANT DIV
-// 92D Path Diversity Main function
-// refer to 88C software antenna diversity
-// 
-VOID
-odm_PathDivChkAntSwitch(
-	PDM_ODM_T		pDM_Odm
-	//PADAPTER		Adapter,
-	//u1Byte			Step
-)
-{
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
-
-
-	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	s4Byte			curRSSI=100, RSSI_A, RSSI_B;
-	u1Byte			nextAntenna=AUX_ANT;
-	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
-	u8Byte			curTxOkCnt, curRxOkCnt;
-	static u8Byte		TXByteCnt_A=0, TXByteCnt_B=0, RXByteCnt_A=0, RXByteCnt_B=0;
-	u8Byte			CurByteCnt=0, PreByteCnt=0;
-	static u1Byte		TrafficLoad = TRAFFIC_LOW;
-	u1Byte			Score_A=0, Score_B=0;
-	u1Byte			i=0x0;
-       // Neil Chen
-       static u1Byte        pathdiv_para=0x0;     
-       static u1Byte        switchfirsttime=0x00;
-	// u1Byte                 regB33 = (u1Byte) PHY_QueryBBReg(Adapter, 0xB30,BIT27);
-	u1Byte			regB33 = (u1Byte)ODM_GetBBReg(pDM_Odm, PATHDIV_REG, BIT27);
-
-
-       //u1Byte                 reg637 =0x0;   
-       static u1Byte        fw_value=0x0;         
-	//u8Byte			curTxOkCnt_tmp, curRxOkCnt_tmp;
-       PADAPTER            BuddyAdapter = Adapter->BuddyAdapter;     // another adapter MAC
-        // Path Diversity   //Neil Chen--2011--06--22
-
-	//u1Byte                 PathDiv_Trigger = (u1Byte) PHY_QueryBBReg(Adapter, 0xBA0,BIT31);
-	u1Byte                 PathDiv_Trigger = (u1Byte) ODM_GetBBReg(pDM_Odm, PATHDIV_TRI,BIT31);
-	u1Byte                 PathDiv_Enable = pHalData->bPathDiv_Enable;
-
-
-	//DbgPrint("Path Div PG Value:%x \n",PathDiv_Enable);	
-       if((BuddyAdapter==NULL)||(!PathDiv_Enable)||(PathDiv_Trigger)||(pHalData->CurrentBandType == BAND_ON_2_4G))
-       {
-           return;
-       }
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD,("===================>odm_PathDivChkAntSwitch()\n"));
-
-       // The first time to switch path excluding 2nd, 3rd, ....etc....
-	if(switchfirsttime==0)
-	{
-	    if(regB33==0)
-	    {
-	       pDM_SWAT_Table->CurAntenna = MAIN_ANT;    // Default MAC0_5G-->Path A (current antenna)     
-	    }	    
-	}
-
-	// Condition that does not need to use antenna diversity.
-	if(pDM_Odm->SupportICType != ODM_RTL8192D)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_PathDiversityMechanims(): No PathDiv Mechanism.\n"));
-		return;
-	}
-
-	// Radio off: Status reset to default and return.
-	if(pHalData->eRFPowerState==eRfOff)
-	{
-		//ODM_SwAntDivRestAfterLink(Adapter);
-		return;
-	}
-
-       /*
-	// Handling step mismatch condition.
-	// Peak step is not finished at last time. Recover the variable and check again.
-	if(	Step != pDM_SWAT_Table->try_flag	)
-	{
-		ODM_SwAntDivRestAfterLink(Adapter);
-	} */
-	
-	if(pDM_SWAT_Table->try_flag == 0xff)
-	{
-		// Select RSSI checking target
-		if(pMgntInfo->mAssoc && !ACTING_AS_AP(Adapter))
-		{
-			// Target: Infrastructure mode AP.
-			pHalData->RSSI_target = NULL;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_PathDivMechanism(): RSSI_target is DEF AP!\n"));
-		}
-		else
-		{
-			u1Byte			index = 0;
-			PRT_WLAN_STA	pEntry = NULL;
-			PADAPTER		pTargetAdapter = NULL;
-		
-			if(	pMgntInfo->mIbss || ACTING_AS_AP(Adapter) )
-			{
-				// Target: AP/IBSS peer.
-				pTargetAdapter = Adapter;
-			}
-			else if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
-			{
-				// Target: VWIFI peer.
-				pTargetAdapter = GetFirstExtAdapter(Adapter);
-			}
-
-			if(pTargetAdapter != NULL)
-			{
-				for(index=0; index<ODM_ASSOCIATE_ENTRY_NUM; index++)
-				{
-					pEntry = AsocEntry_EnumStation(pTargetAdapter, index);
-					if(pEntry != NULL)
-					{
-						if(pEntry->bAssociated)
-							break;			
-					}
-				}
-			}
-
-			if(pEntry == NULL)
-			{
-				ODM_PathDivRestAfterLink(pDM_Odm);
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): No Link.\n"));
-				return;
-			}
-			else
-			{
-				pHalData->RSSI_target = pEntry;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): RSSI_target is PEER STA\n"));
-			}
-		}
-			
-		pHalData->RSSI_cnt_A = 0;
-		pHalData->RSSI_cnt_B = 0;
-		pDM_SWAT_Table->try_flag = 0;
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): Set try_flag to 0 prepare for peak!\n"));
-		return;
-	}
-	else
-	{
-	       // 1st step
-		curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - lastTxOkCnt;
-		curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - lastRxOkCnt;
-		lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
-		lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
-	
-		if(pDM_SWAT_Table->try_flag == 1)   // Training State
-		{
-			if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-			{
-				TXByteCnt_A += curTxOkCnt;
-				RXByteCnt_A += curRxOkCnt;
-			}
-			else
-			{
-				TXByteCnt_B += curTxOkCnt;
-				RXByteCnt_B += curRxOkCnt;
-			}
-		
-			nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? AUX_ANT : MAIN_ANT;
-			pDM_SWAT_Table->RSSI_Trying--;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: RSSI_Trying = %d\n",pDM_SWAT_Table->RSSI_Trying));
-			if(pDM_SWAT_Table->RSSI_Trying == 0)
-			{
-				CurByteCnt = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? (TXByteCnt_A+RXByteCnt_A) : (TXByteCnt_B+RXByteCnt_B);
-				PreByteCnt = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? (TXByteCnt_B+RXByteCnt_B) : (TXByteCnt_A+RXByteCnt_A);
-				
-				if(TrafficLoad == TRAFFIC_HIGH)
-				{
-					//CurByteCnt = PlatformDivision64(CurByteCnt, 9);
-					PreByteCnt =PreByteCnt*9;
-				}
-				else if(TrafficLoad == TRAFFIC_LOW)
-				{
-					//CurByteCnt = PlatformDivision64(CurByteCnt, 2);
-					PreByteCnt =PreByteCnt*2;
-				}
-				if(pHalData->RSSI_cnt_A > 0)
-					RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
-				else
-					RSSI_A = 0;
-				if(pHalData->RSSI_cnt_B > 0)
-					RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
-		             else
-					RSSI_B = 0;
-				curRSSI = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
-				pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_B : RSSI_A;
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: PreRSSI = %d, CurRSSI = %d\n",pDM_SWAT_Table->PreRSSI, curRSSI));
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: preAntenna= %s, curAntenna= %s \n", 
-				(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
-					RSSI_A, pHalData->RSSI_cnt_A, RSSI_B, pHalData->RSSI_cnt_B));
-			}
-
-		}
-		else   // try_flag=0
-		{
-		
-			if(pHalData->RSSI_cnt_A > 0)
-				RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
-			else
-				RSSI_A = 0;
-			if(pHalData->RSSI_cnt_B > 0)
-				RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
-			else
-				RSSI_B = 0;	
-			curRSSI = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
-			pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->PreAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: PreRSSI = %d, CurRSSI = %d\n", pDM_SWAT_Table->PreRSSI, curRSSI));
-		       ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: preAntenna= %s, curAntenna= %s \n", 
-			(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
-
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
-				RSSI_A, pHalData->RSSI_cnt_A, RSSI_B, pHalData->RSSI_cnt_B));
-			//RT_TRACE(COMP_SWAS, DBG_LOUD, ("Ekul:curTxOkCnt = %d\n", curTxOkCnt));
-			//RT_TRACE(COMP_SWAS, DBG_LOUD, ("Ekul:curRxOkCnt = %d\n", curRxOkCnt));
-		}
-
-		//1 Trying State
-		if((pDM_SWAT_Table->try_flag == 1)&&(pDM_SWAT_Table->RSSI_Trying == 0))
-		{
-
-			if(pDM_SWAT_Table->TestMode == TP_MODE)
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: TestMode = TP_MODE"));
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH= TRY:CurByteCnt = %"i64fmt"d,", CurByteCnt));
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH= TRY:PreByteCnt = %"i64fmt"d\n",PreByteCnt));		
-				if(CurByteCnt < PreByteCnt)
-				{
-					if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
-					else
-						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
-				}
-				else
-				{
-					if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
-					else
-						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
-				}
-				for (i= 0; i<8; i++)
-				{
-					if(((pDM_SWAT_Table->SelectAntennaMap>>i)&BIT0) == 1)
-						Score_A++;
-					else
-						Score_B++;
-				}
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("SelectAntennaMap=%x\n ",pDM_SWAT_Table->SelectAntennaMap));
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Score_A=%d, Score_B=%d\n", Score_A, Score_B));
-			
-				if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
-				{
-					nextAntenna = (Score_A >= Score_B)?MAIN_ANT:AUX_ANT;
-				}
-				else
-				{
-					nextAntenna = (Score_B >= Score_A)?AUX_ANT:MAIN_ANT;
-				}
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: nextAntenna=%s\n",(nextAntenna==MAIN_ANT)?"MAIN":"AUX"));
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: preAntenna= %s, curAntenna= %s \n", 
-				(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
-
-				if(nextAntenna != pDM_SWAT_Table->CurAntenna)
-				{
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Switch back to another antenna"));
-				}
-				else
-				{
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: current anntena is good\n"));
-				}	
-			}
-
-                    
-			if(pDM_SWAT_Table->TestMode == RSSI_MODE)
-			{	
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: TestMode = RSSI_MODE"));
-				pDM_SWAT_Table->SelectAntennaMap=0xAA;
-				if(curRSSI < pDM_SWAT_Table->PreRSSI) //Current antenna is worse than previous antenna
-				{
-					//RT_TRACE(COMP_SWAS, DBG_LOUD, ("SWAS: Switch back to another antenna"));
-					nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)?AUX_ANT : MAIN_ANT;
-				}
-				else // current anntena is good
-				{
-					nextAntenna =pDM_SWAT_Table->CurAntenna;
-					//RT_TRACE(COMP_SWAS, DBG_LOUD, ("SWAS: current anntena is good\n"));
-				}
-			}
-			
-			pDM_SWAT_Table->try_flag = 0;
-			pHalData->RSSI_test = FALSE;
-			pHalData->RSSI_sum_A = 0;
-			pHalData->RSSI_cnt_A = 0;
-			pHalData->RSSI_sum_B = 0;
-			pHalData->RSSI_cnt_B = 0;
-			TXByteCnt_A = 0;
-			TXByteCnt_B = 0;
-			RXByteCnt_A = 0;
-			RXByteCnt_B = 0;
-			
-		}
-
-		//1 Normal State
-		else if(pDM_SWAT_Table->try_flag == 0)
-		{
-			if(TrafficLoad == TRAFFIC_HIGH)
-			{
-				if ((curTxOkCnt+curRxOkCnt) > 3750000)//if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)
-					TrafficLoad = TRAFFIC_HIGH;
-				else
-					TrafficLoad = TRAFFIC_LOW;
-			}
-			else if(TrafficLoad == TRAFFIC_LOW)
-				{
-				if ((curTxOkCnt+curRxOkCnt) > 3750000)//if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)
-					TrafficLoad = TRAFFIC_HIGH;
-				else
-					TrafficLoad = TRAFFIC_LOW;
-			}
-			if(TrafficLoad == TRAFFIC_HIGH)
-				pDM_SWAT_Table->bTriggerAntennaSwitch = 0;
-			//RT_TRACE(COMP_SWAS, DBG_LOUD, ("Normal:TrafficLoad = %llu\n", curTxOkCnt+curRxOkCnt));
-
-			//Prepare To Try Antenna		
-				nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? AUX_ANT : MAIN_ANT;
-				pDM_SWAT_Table->try_flag = 1;
-				pHalData->RSSI_test = TRUE;
-			if((curRxOkCnt+curTxOkCnt) > 1000)
-			{
-#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-	                    pDM_SWAT_Table->RSSI_Trying = 4;                           
-#else
-	                    pDM_SWAT_Table->RSSI_Trying = 2;
-#endif
-				pDM_SWAT_Table->TestMode = TP_MODE;
-			}
-			else
-			{
-				pDM_SWAT_Table->RSSI_Trying = 2;
-				pDM_SWAT_Table->TestMode = RSSI_MODE;
-
-			}
-                          
-			//RT_TRACE(COMP_SWAS, DBG_LOUD, ("SWAS: Normal State -> Begin Trying!\n"));			
-			pHalData->RSSI_sum_A = 0;
-			pHalData->RSSI_cnt_A = 0;
-			pHalData->RSSI_sum_B = 0;
-			pHalData->RSSI_cnt_B = 0;
-		} // end of try_flag=0
-	}
-	
-	//1 4.Change TRX antenna
-	if(nextAntenna != pDM_SWAT_Table->CurAntenna)
-	{
-	
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Change TX Antenna!\n "));
-		//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, nextAntenna); for 88C
-		if(nextAntenna==MAIN_ANT)
-		{
-		    ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Next Antenna is RF PATH A\n "));
-		    pathdiv_para = 0x02;   //02 to switchback to RF path A
-		    fw_value = 0x03;
-#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-                 odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
-#else
-                 ODM_FillH2CCmd(Adapter, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
-#endif
-		}	
-	       else if(nextAntenna==AUX_ANT)
-	       {
-	           ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Next Antenna is RF PATH B\n "));
-	           if(switchfirsttime==0)  // First Time To Enter Path Diversity
-	           {
-	               switchfirsttime=0x01;
-                      pathdiv_para = 0x00;
-			  fw_value=0x00;    // to backup RF Path A Releated Registers		  
-					  
-#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-                     odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
-#else
-                     ODM_FillH2CCmd(Adapter, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
-                     //for(u1Byte n=0; n<80,n++)
-                     //{
-                     //delay_us(500);
-			  ODM_delay_ms(500);
-                     odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
-			 		 
-			 fw_value=0x01;   	// to backup RF Path A Releated Registers		 
-                     ODM_FillH2CCmd(Adapter, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
-#endif	
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: FIRST TIME To DO PATH SWITCH!\n "));	
-	           }		   
-		    else
-		    {
-		        pathdiv_para = 0x01;
-			 fw_value = 0x02;	
-#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-                     odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
-#else
-                     ODM_FillH2CCmd(Adapter, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
-#endif	
-		    }		
-	       }
-           //   odm_PathDiversity_8192D(Adapter, pathdiv_para);
-	}
-
-	//1 5.Reset Statistics
-	pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
-	pDM_SWAT_Table->CurAntenna = nextAntenna;
-	pDM_SWAT_Table->PreRSSI = curRSSI;
-
-	//1 6.Set next timer
-
-	if(pDM_SWAT_Table->RSSI_Trying == 0)
-		return;
-
-	if(pDM_SWAT_Table->RSSI_Trying%2 == 0)
-	{
-		if(pDM_SWAT_Table->TestMode == TP_MODE)
-		{
-			if(TrafficLoad == TRAFFIC_HIGH)
-			{
-#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 10 ); //ms
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 10 ms\n"));
-#else
-				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 20 ); //ms
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 20 ms\n"));
-#endif				
-			}
-			else if(TrafficLoad == TRAFFIC_LOW)
-			{
-				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 50 ); //ms
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 50 ms\n"));
-			}
-		}
-		else   // TestMode == RSSI_MODE
-		{
-			ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 500 ); //ms
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 500 ms\n"));
-		}
-	}
-	else
-	{
-		if(pDM_SWAT_Table->TestMode == TP_MODE)
-		{
-			if(TrafficLoad == TRAFFIC_HIGH)
-				
-#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 90 ); //ms
-				//ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 90 ms\n"));
-#else		
-				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 180); //ms
-#endif				
-			else if(TrafficLoad == TRAFFIC_LOW)
-				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 100 ); //ms
-		}
-		else
-			ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 500 ); //ms
-	}
-}
-
-//==================================================
-//3 PathDiv End
-//==================================================
-
-VOID
-odm_SetRespPath_92C(
-	IN	PADAPTER	Adapter,
-	IN	u1Byte	DefaultRespPath
-	)
-{
-	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
-
-	RT_TRACE(	COMP_SWAS, DBG_LOUD, ("odm_SetRespPath_92C: Select Response Path=%d\n",DefaultRespPath));
-	if(DefaultRespPath != pDM_PDTable->DefaultRespPath)
-	{
-		if(DefaultRespPath == 0)
-		{
-			PlatformEFIOWrite1Byte(Adapter, 0x6D8, (PlatformEFIORead1Byte(Adapter, 0x6D8)&0xc0)|0x15);	
-		}
-		else
-		{
-			PlatformEFIOWrite1Byte(Adapter, 0x6D8, (PlatformEFIORead1Byte(Adapter, 0x6D8)&0xc0)|0x2A);
-		}	
-	}
-	pDM_PDTable->DefaultRespPath = DefaultRespPath;
-}
-
-
-VOID
-ODM_FillTXPathInTXDESC(
-		IN	PADAPTER	Adapter,
-		IN	PRT_TCB		pTcb,
-		IN	pu1Byte		pDesc
-)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u4Byte	TXPath;
-	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
-
-	//2011.09.05  Add by Luke Lee for path diversity
-	if(pHalData->PathDivCfg == 1)
-	{	
-		TXPath = (pDM_PDTable->OFDMTXPath >> pTcb->macId) & BIT0;
-		//RT_TRACE(	COMP_SWAS, DBG_LOUD, ("Fill TXDESC: macID=%d, TXPath=%d\n", pTcb->macId, TXPath));
-		//SET_TX_DESC_TX_ANT_CCK(pDesc,TXPath);
-		if(TXPath == 0)
-		{
-			SET_TX_DESC_TX_ANTL_92C(pDesc,1);
-			SET_TX_DESC_TX_ANT_HT_92C(pDesc,1);
-		}
-		else
-		{
-			SET_TX_DESC_TX_ANTL_92C(pDesc,2);
-			SET_TX_DESC_TX_ANT_HT_92C(pDesc,2);
-		}
-		TXPath = (pDM_PDTable->CCKTXPath >> pTcb->macId) & BIT0;
-		if(TXPath == 0)
-		{
-			SET_TX_DESC_TX_ANT_CCK_92C(pDesc,1);
-		}
-		else
-		{
-			SET_TX_DESC_TX_ANT_CCK_92C(pDesc,2);
-		}
-	}
-}
-
-//Only for MP //Neil Chen--2012--0502--
-VOID
-odm_PathDivInit_92D(
-IN	PDM_ODM_T 	pDM_Odm)
-{
-	pPATHDIV_PARA	pathIQK = &pDM_Odm->pathIQK;
-
-	pathIQK->org_2g_RegC14=0x0;
-	pathIQK->org_2g_RegC4C=0x0;
-	pathIQK->org_2g_RegC80=0x0;
-	pathIQK->org_2g_RegC94=0x0;
-	pathIQK->org_2g_RegCA0=0x0;
-	pathIQK->org_5g_RegC14=0x0;
-	pathIQK->org_5g_RegCA0=0x0;
-	pathIQK->org_5g_RegE30=0x0;
-	pathIQK->swt_2g_RegC14=0x0;
-	pathIQK->swt_2g_RegC4C=0x0;
-	pathIQK->swt_2g_RegC80=0x0;
-	pathIQK->swt_2g_RegC94=0x0;
-	pathIQK->swt_2g_RegCA0=0x0;
-	pathIQK->swt_5g_RegC14=0x0;
-	pathIQK->swt_5g_RegCA0=0x0;
-	pathIQK->swt_5g_RegE30=0x0;
-
-}
-
-#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN| ODM_CE))
-
-VOID
-odm_PHY_SaveAFERegisters(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	pu4Byte		AFEReg,
-	IN	pu4Byte		AFEBackup,
-	IN	u4Byte		RegisterNum
-	)
-{
-	u4Byte	i;
-	
-	//RT_DISP(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
-	for( i = 0 ; i < RegisterNum ; i++){
-		AFEBackup[i] = ODM_GetBBReg(pDM_Odm, AFEReg[i], bMaskDWord);
-	}
-}
-
-VOID
-odm_PHY_ReloadAFERegisters(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	pu4Byte		AFEReg,
-	IN	pu4Byte		AFEBackup,
-	IN	u4Byte		RegiesterNum
-	)
-{
-	u4Byte	i;
-
-	//RT_DISP(FINIT, INIT_IQK, ("Reload ADDA power saving parameters !\n"));
-	for(i = 0 ; i < RegiesterNum; i++)
-	{
-	
-		ODM_SetBBReg(pDM_Odm, AFEReg[i], bMaskDWord, AFEBackup[i]);
-	}
-}
-
-//
-// Description:
-//	Set Single/Dual Antenna default setting for products that do not do detection in advance.
-//
-// Added by Joseph, 2012.03.22
-//
-VOID
-ODM_SingleDualAntennaDefaultSetting(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
-	u1Byte btAntNum = 2;
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
-	btAntNum=BT_GetPgAntNum(pAdapter);
-#elif (DM_ODM_SUPPORT_TYPE & (ODM_CE))
-#ifdef CONFIG_BT_COEXIST
-	btAntNum = hal_btcoex_GetPgAntNum(pAdapter);
-#endif
-#endif
-
-	// Set default antenna A and B status
-	if(btAntNum == 2)
-	{
-		pDM_SWAT_Table->ANTA_ON=TRUE;
-		pDM_SWAT_Table->ANTB_ON=TRUE;
-		//RT_TRACE(COMP_ANTENNA, DBG_LOUD, ("Dual antenna\n"));
-	}
-#ifdef CONFIG_BT_COEXIST
-	else if(btAntNum == 1)
-	{// Set antenna A as default
-		pDM_SWAT_Table->ANTA_ON=TRUE;
-		pDM_SWAT_Table->ANTB_ON=FALSE;
-		//RT_TRACE(COMP_ANTENNA, DBG_LOUD, ("Single antenna\n"));
-	}
-	else
-	{
-		//RT_ASSERT(FALSE, ("Incorrect antenna number!!\n"));
-	}
-#endif
-}
-
-
-
-//2 8723A ANT DETECT
-//
-// Description:
-//	Implement IQK single tone for RF DPK loopback and BB PSD scanning. 
-//	This function is cooperated with BB team Neil. 
-//
-// Added by Roger, 2011.12.15
-//
-BOOLEAN
-ODM_SingleDualAntennaDetection(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			mode
-	)
-{
-	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
-	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
-	u4Byte		CurrentChannel,RfLoopReg;
-	u1Byte		n;
-	u4Byte		Reg88c, Regc08, Reg874, Regc50, Reg948=0, Regb2c=0, Reg92c=0, AFE_rRx_Wait_CCA=0;
-	u1Byte		initial_gain = 0x5a;
-	u4Byte		PSD_report_tmp;
-	u4Byte		AntA_report = 0x0, AntB_report = 0x0,AntO_report=0x0;
-	BOOLEAN		bResult = TRUE;
-	u4Byte		AFE_Backup[16];
-	u4Byte		AFE_REG_8723A[16] = {
-					rRx_Wait_CCA, 	rTx_CCK_RFON, 
-					rTx_CCK_BBON, 	rTx_OFDM_RFON,
-					rTx_OFDM_BBON, 	rTx_To_Rx,
-					rTx_To_Tx, 		rRx_CCK, 
-					rRx_OFDM, 		rRx_Wait_RIFS, 
-					rRx_TO_Rx,		rStandby,
-					rSleep,			rPMPD_ANAEN, 	
-					rFPGA0_XCD_SwitchControl, rBlue_Tooth};
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection()============> \n"));	
-
-	
-	if(!(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C|ODM_RTL8723B)))
-		return bResult;
-
-	// Retrieve antenna detection registry info, added by Roger, 2012.11.27.
-	if(!IS_ANT_DETECT_SUPPORT_SINGLE_TONE(pAdapter))
-		return bResult;
-
-	if(pDM_Odm->SupportICType == ODM_RTL8192C)
-	{
-		//Which path in ADC/DAC is turnned on for PSD: both I/Q
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT10|BIT11, 0x3);
-		//Ageraged number: 8
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT12|BIT13, 0x1);
-		//pts = 128;
-		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
-	}
-
-	//1 Backup Current RF/BB Settings	
-	
-	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask);
-	RfLoopReg = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask);
-	if(!(pDM_Odm->SupportICType == ODM_RTL8723B))
-	ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_A);  // change to Antenna A
-#if (RTL8723B_SUPPORT == 1)
-	else
-	{
-		Reg92c = ODM_GetBBReg(pDM_Odm, 0x92c, bMaskDWord);
-		Reg948 = ODM_GetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord);
-		Regb2c = ODM_GetBBReg(pDM_Odm, AGC_table_select, bMaskDWord);
-		ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x1);
-		ODM_SetBBReg(pDM_Odm, rfe_ctrl_anta_src, 0xff, 0x77);
-		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0x3ff, 0x000);
-		ODM_SetBBReg(pDM_Odm, AGC_table_select, BIT31, 0x0);
-	}
-#endif
-	ODM_StallExecution(10);
-	
-	//Store A Path Register 88c, c08, 874, c50
-	Reg88c = ODM_GetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord);
-	Regc08 = ODM_GetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord);
-	Reg874 = ODM_GetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord);
-	Regc50 = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord);	
-	
-	// Store AFE Registers
-	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
-	odm_PHY_SaveAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);	
-	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-		AFE_rRx_Wait_CCA = ODM_GetBBReg(pDM_Odm, rRx_Wait_CCA,bMaskDWord);
-	
-	//Set PSD 128 pts
-	ODM_SetBBReg(pDM_Odm, rFPGA0_PSDFunction, BIT14|BIT15, 0x0);  //128 pts
-	
-	// To SET CH1 to do
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask, 0x7401);     //Channel 1
-	
-	// AFE all on step
-	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
-	{
-		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rTx_CCK_RFON, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rTx_CCK_BBON, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rTx_OFDM_RFON, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rTx_OFDM_BBON, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rTx_To_Rx, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rTx_To_Tx, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rRx_CCK, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rRx_OFDM, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rRx_Wait_RIFS, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rRx_TO_Rx, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rStandby, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rSleep, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rPMPD_ANAEN, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_SwitchControl, bMaskDWord, 0x6FDB25A4);
-		ODM_SetBBReg(pDM_Odm, rBlue_Tooth, bMaskDWord, 0x6FDB25A4);
-	}
-	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-	{
-		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x01c00016);
-	}
-
-	// 3 wire Disable
-	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, 0xCCF000C0);
-	
-	//BB IQK Setting
-	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, 0x000800E4);
-	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
-
-	//IQK setting tone@ 4.34Mhz
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x10008C1C);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);	
-
-	//Page B init
-	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x00080000);
-	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x0f600000);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
-	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82150008);
-	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28150008);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x001028d0);	
-
-	//RF loop Setting
-	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x0, 0xFFFFF, 0x50008);	
-	
-	//IQK Single tone start
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x80800000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
-	
-	ODM_StallExecution(10000);
-
-	// PSD report of antenna A
-	PSD_report_tmp=0x0;
-	for (n=0;n<2;n++)
- 	{
- 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
-		if(PSD_report_tmp >AntA_report)
-			AntA_report=PSD_report_tmp;
-	}
-
-	 // change to Antenna B
-	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
-		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_B); 
-#if (RTL8723B_SUPPORT == 1)
-	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-		ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x2);
-#endif
-
-	ODM_StallExecution(10);	
-
-	// PSD report of antenna B
-	PSD_report_tmp=0x0;
-	for (n=0;n<2;n++)
- 	{
- 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
-		if(PSD_report_tmp > AntB_report)
-			AntB_report=PSD_report_tmp;
-	}
-
-	// change to open case
-	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
-		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, 0);  // change to Antenna A
-#if (RTL8723B_SUPPORT == 1)
-	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-		ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x0);
-#endif
-
-	ODM_StallExecution(10);	
-	
-	// PSD report of open case
-	PSD_report_tmp=0x0;
-	for (n=0;n<2;n++)
- 	{
- 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
-		if(PSD_report_tmp > AntO_report)
-			AntO_report=PSD_report_tmp;
-	}
-
-	//Close IQK Single Tone function
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);
-
-	//1 Return to antanna A
-	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
-		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_A);  // change to Antenna A
-#if (RTL8723B_SUPPORT == 1)
-	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-	{
-		// external DPDT
-		ODM_SetBBReg(pDM_Odm, rDPDT_control, bMaskDWord, Reg92c);
-
-		//internal S0/S1
-		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord, Reg948);
-		ODM_SetBBReg(pDM_Odm, AGC_table_select, bMaskDWord, Regb2c);
-	}
-#endif
-	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, Reg88c);
-	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, Regc08);
-	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, Reg874);
-	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, 0x7F, 0x40);
-	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord, Regc50);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask,CurrentChannel);
-	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask,RfLoopReg);
-
-	//Reload AFE Registers
-	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
-	odm_PHY_ReloadAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);	
-	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, AFE_rRx_Wait_CCA);
-
-	if(pDM_Odm->SupportICType == ODM_RTL8723A)
-	{
-		//2 Test Ant B based on Ant A is ON
-		if(mode==ANTTESTB)
-		{
-			if(AntA_report >=	100)
-			{
-				if(AntB_report > (AntA_report+1))
-				{
-					pDM_SWAT_Table->ANTB_ON=FALSE;
-							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));		
-				}	
-				else
-				{
-					pDM_SWAT_Table->ANTB_ON=TRUE;
-							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n"));	
-				}	
-			}
-			else
-			{
-							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
-				pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
-				bResult = FALSE;
-			}
-		}	
-		//2 Test Ant A and B based on DPDT Open
-		else if(mode==ANTTESTALL)
-		{
-			if((AntO_report >=100) && (AntO_report <=118))
-			{
-				if(AntA_report > (AntO_report+1))
-				{
-					pDM_SWAT_Table->ANTA_ON=FALSE;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant A is OFF\n"));
-				}	
-				else
-				{
-					pDM_SWAT_Table->ANTA_ON=TRUE;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant A is ON\n"));
-				}
-
-				if(AntB_report > (AntO_report+2))
-				{
-					pDM_SWAT_Table->ANTB_ON=FALSE;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant B is OFF\n"));
-				}	
-				else
-				{
-					pDM_SWAT_Table->ANTB_ON=TRUE;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant B is ON\n"));
-				}
-				
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d \n", 2416, AntA_report));	
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d \n", 2416, AntB_report));	
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_O[%d]= %d \n", 2416, AntO_report));
-				
-				pDM_Odm->AntDetectedInfo.bAntDetected= TRUE;
-				pDM_Odm->AntDetectedInfo.dBForAntA = AntA_report;
-				pDM_Odm->AntDetectedInfo.dBForAntB = AntB_report;
-				pDM_Odm->AntDetectedInfo.dBForAntO = AntO_report;
-				
-				}
-			else
-				{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("return FALSE!!\n"));
-				bResult = FALSE;
-			}
-		}
-	}
-	else if(pDM_Odm->SupportICType == ODM_RTL8192C)
-	{
-		if(AntA_report >=	100)
-		{
-			if(AntB_report > (AntA_report+2))
-			{
-				pDM_SWAT_Table->ANTA_ON=FALSE;
-				pDM_SWAT_Table->ANTB_ON=TRUE;
-				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_B);
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna B\n"));		
-			}	
-			else if(AntA_report > (AntB_report+2))
-			{
-				pDM_SWAT_Table->ANTA_ON=TRUE;
-				pDM_SWAT_Table->ANTB_ON=FALSE;
-				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_A);
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));
-			}	
-			else
-			{
-				pDM_SWAT_Table->ANTA_ON=TRUE;
-				pDM_SWAT_Table->ANTB_ON=TRUE;
-				RT_TRACE(COMP_ANTENNA, DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna \n"));
-			}
-		}
-		else
-		{
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
-			pDM_SWAT_Table->ANTA_ON=TRUE; // Set Antenna A on as default 
-			pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
-			bResult = FALSE;
-		}
-	}
-	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d \n", 2416, AntA_report));	
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d \n", 2416, AntB_report));	
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_O[%d]= %d \n", 2416, AntO_report));
-		
-		//2 Test Ant B based on Ant A is ON
-		if(mode==ANTTESTB)
-		{
-			if(AntA_report >=100 && AntA_report <= 116)
-			{
-				if(AntB_report >= (AntA_report+4) && AntB_report > 116)
-				{
-					pDM_SWAT_Table->ANTB_ON=FALSE;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));		
-				}	
-				else if(AntB_report >=100 && AntB_report <= 116)
-				{
-					pDM_SWAT_Table->ANTB_ON=TRUE;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n"));	
-				}
-				else
-				{
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
-					pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
-					bResult = FALSE;
-				}
-			}
-			else
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
-				pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
-				bResult = FALSE;
-			}
-		}	
-		//2 Test Ant A and B based on DPDT Open
-		else if(mode==ANTTESTALL)
-		{
-			if((AntA_report >= 100) && (AntB_report >= 100) && (AntA_report <= 120) && (AntB_report <= 120))
-			{
-				if((AntA_report - AntB_report < 2) || (AntB_report - AntA_report < 2))
-				{
-					pDM_SWAT_Table->ANTA_ON=TRUE;
-					pDM_SWAT_Table->ANTB_ON=TRUE;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Dual Antenna\n"));
-				}
-				else if(((AntA_report - AntB_report >= 2) && (AntA_report - AntB_report <= 4)) || 
-					((AntB_report - AntA_report >= 2) && (AntB_report - AntA_report <= 4)))
-				{
-					pDM_SWAT_Table->ANTA_ON=FALSE;
-					pDM_SWAT_Table->ANTB_ON=FALSE;
-					bResult = FALSE;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
-				}
-				else
-				{
-					pDM_SWAT_Table->ANTA_ON = TRUE;
-					pDM_SWAT_Table->ANTB_ON=FALSE;
-					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));
-				}
-				
-				pDM_Odm->AntDetectedInfo.bAntDetected= TRUE;
-				pDM_Odm->AntDetectedInfo.dBForAntA = AntA_report;
-				pDM_Odm->AntDetectedInfo.dBForAntB = AntB_report;
-				pDM_Odm->AntDetectedInfo.dBForAntO = AntO_report;
-				
-			}
-			else
-			{
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("return FALSE!!\n"));
-				bResult = FALSE;
-			}
-		}
-	}
-		
-	return bResult;
-
-}
-
-
-#endif   // end odm_CE
-
-#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN| ODM_CE))
-
-VOID
-odm_Set_RA_DM_ARFB_by_Noisy(
-	IN	PDM_ODM_T	pDM_Odm
-)
-{
-	//DbgPrint("DM_ARFB ====> \n");
-	if (pDM_Odm->bNoisyState){
-		ODM_Write4Byte(pDM_Odm,0x430,0x00000000);
-		ODM_Write4Byte(pDM_Odm,0x434,0x05040200);
-		//DbgPrint("DM_ARFB ====> Noisy State\n");
-	}
-	else{
-		ODM_Write4Byte(pDM_Odm,0x430,0x02010000);
-		ODM_Write4Byte(pDM_Odm,0x434,0x07050403);
-		//DbgPrint("DM_ARFB ====> Clean State\n");
-	}
-	
-}
-
-VOID
-ODM_UpdateNoisyState(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN 	BOOLEAN 	bNoisyStateFromC2H
-	)
-{
-	//DbgPrint("Get C2H Command! NoisyState=0x%x\n ", bNoisyStateFromC2H);
-	if(pDM_Odm->SupportICType == ODM_RTL8821  || pDM_Odm->SupportICType == ODM_RTL8812  || 
-	   pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8188E)
-	{
-		pDM_Odm->bNoisyState = bNoisyStateFromC2H;
-	}
-	odm_Set_RA_DM_ARFB_by_Noisy(pDM_Odm);
-};
-
-u4Byte
-Set_RA_DM_Ratrbitmap_by_Noisy(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	WIRELESS_MODE	WirelessMode,
-	IN	u4Byte			ratr_bitmap,
-	IN	u1Byte			rssi_level
-)
-{
-	u4Byte ret_bitmap = ratr_bitmap;
-	switch (WirelessMode)
-	{
-		case WIRELESS_MODE_AC_24G :
-		case WIRELESS_MODE_AC_5G :
-		case WIRELESS_MODE_AC_ONLY:
-			if (pDM_Odm->bNoisyState){ // in Noisy State
-				if (rssi_level==1)
-					ret_bitmap&=0xfe3f0e08;
-				else if (rssi_level==2)
-					ret_bitmap&=0xff3f8f8c;
-				else if (rssi_level==3)
-					ret_bitmap&=0xffffffcc ;
-				else
-					ret_bitmap&=0xffffffff ;
-			}
-			else{                                   // in SNR State
-				if (rssi_level==1){
-					ret_bitmap&=0xfc3e0c08;
-				}
-				else if (rssi_level==2){
-					ret_bitmap&=0xfe3f0e08;
-				}
-				else if (rssi_level==3){
-					ret_bitmap&=0xffbfefcc;
-				}
-				else{
-					ret_bitmap&=0x0fffffff;
-				}
-			}
-			break;
-		case WIRELESS_MODE_B:
-		case WIRELESS_MODE_A:
-		case WIRELESS_MODE_G:
-		case WIRELESS_MODE_N_24G:
-		case WIRELESS_MODE_N_5G:
-			if (pDM_Odm->bNoisyState){
-				if (rssi_level==1)
-					ret_bitmap&=0x0f0e0c08;
-				else if (rssi_level==2)
-					ret_bitmap&=0x0f8f0e0c;
-				else if (rssi_level==3)
-					ret_bitmap&=0x0fefefcc ;
-				else
-					ret_bitmap&=0xffffffff ;
-			}
-			else{
-				if (rssi_level==1){
-					ret_bitmap&=0x0f8f0e08;
-				}
-				else if (rssi_level==2){
-					ret_bitmap&=0x0fcf8f8c;
-				}
-				else if (rssi_level==3){
-					ret_bitmap&=0x0fffffcc;
-				}
-				else{
-					ret_bitmap&=0x0fffffff;
-				}
-			}
-			break;
-		default:
-			break;
-	}
-	//DbgPrint("DM_RAMask ====> rssi_LV = %d, BITMAP = %x \n", rssi_level, ret_bitmap);
-	return ret_bitmap;
-
-}
-
-
-
-VOID
-ODM_UpdateInitRate(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte		Rate
-	)
-{
-	u1Byte			p = 0;
-
-	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("Get C2H Command! Rate=0x%x\n", Rate));
-	
-	if(pDM_Odm->SupportICType == ODM_RTL8821  || pDM_Odm->SupportICType == ODM_RTL8812  || 
-	   pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8188E)
-	{
-		pDM_Odm->TxRate = Rate;
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	#if DEV_BUS_TYPE==RT_PCI_INTERFACE
-		#if USE_WORKITEM
-		PlatformScheduleWorkItem(&pDM_Odm->RaRptWorkitem);
-		#else
-		if(pDM_Odm->SupportICType == ODM_RTL8821)
-		{
-			ODM_TxPwrTrackSetPwr8821A(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
-		}
-		else if(pDM_Odm->SupportICType == ODM_RTL8812)
-		{
-			for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8812A; p++) 		
-			{
-				ODM_TxPwrTrackSetPwr8812A(pDM_Odm, MIX_MODE, p, 0);
-			}
-		}
-		else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-		{
-			ODM_TxPwrTrackSetPwr_8723B(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
-		}
-		else if(pDM_Odm->SupportICType == ODM_RTL8192E)
-		{
-			for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8192E; p++) 		
-			{
-				ODM_TxPwrTrackSetPwr92E(pDM_Odm, MIX_MODE, p, 0);
-			}
-		}
-		else if(pDM_Odm->SupportICType == ODM_RTL8188E)
-		{
-			ODM_TxPwrTrackSetPwr88E(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
-		}
-		#endif
-	#else
-		PlatformScheduleWorkItem(&pDM_Odm->RaRptWorkitem);
-	#endif	
-#endif
-	}
-	else
-		return;
-}
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID
-ODM_UpdateInitRateWorkItemCallback(
-    IN PVOID            pContext
-    )
-{
-	PADAPTER	Adapter = (PADAPTER)pContext;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
-
-	u1Byte			p = 0;	
-
-	if(pDM_Odm->SupportICType == ODM_RTL8821)
-	{
-		ODM_TxPwrTrackSetPwr8821A(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
-	}
-	else if(pDM_Odm->SupportICType == ODM_RTL8812)
-	{
-		for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8812A; p++)    //DOn't know how to include &c
-		{
-			ODM_TxPwrTrackSetPwr8812A(pDM_Odm, MIX_MODE, p, 0);
-		}
-	}
-	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
-	{
-			ODM_TxPwrTrackSetPwr_8723B(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
-	}
-	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
-	{
-		for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8192E; p++)    //DOn't know how to include &c
-		{
-			ODM_TxPwrTrackSetPwr92E(pDM_Odm, MIX_MODE, p, 0);
-		}
-	}
-	else if(pDM_Odm->SupportICType == ODM_RTL8188E)
-	{
-			ODM_TxPwrTrackSetPwr88E(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
-	}
-}
-#endif
-#endif
-
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-/* Justin: According to the current RRSI to adjust Response Frame TX power, 2012/11/05 */
-void odm_dtc(PDM_ODM_T pDM_Odm)
-{
-#ifdef CONFIG_DM_RESP_TXAGC
-	#define DTC_BASE            35	/* RSSI higher than this value, start to decade TX power */
-	#define DTC_DWN_BASE       (DTC_BASE-5)	/* RSSI lower than this value, start to increase TX power */
-
-	/* RSSI vs TX power step mapping: decade TX power */
-	static const u8 dtc_table_down[]={
-		DTC_BASE,
-		(DTC_BASE+5),
-		(DTC_BASE+10),
-		(DTC_BASE+15),
-		(DTC_BASE+20),
-		(DTC_BASE+25)
-	};
-
-	/* RSSI vs TX power step mapping: increase TX power */
-	static const u8 dtc_table_up[]={
-		DTC_DWN_BASE,
-		(DTC_DWN_BASE-5),
-		(DTC_DWN_BASE-10),
-		(DTC_DWN_BASE-15),
-		(DTC_DWN_BASE-15),
-		(DTC_DWN_BASE-20),
-		(DTC_DWN_BASE-20),
-		(DTC_DWN_BASE-25),
-		(DTC_DWN_BASE-25),
-		(DTC_DWN_BASE-30),
-		(DTC_DWN_BASE-35)
-	};
-
-	u8 i;
-	u8 dtc_steps=0;
-	u8 sign;
-	u8 resp_txagc=0;
-
-	#if 0
-	/* As DIG is disabled, DTC is also disable */
-	if(!(pDM_Odm->SupportAbility & ODM_XXXXXX))
-		return;
-	#endif
-
-	if (DTC_BASE < pDM_Odm->RSSI_Min) {
-		/* need to decade the CTS TX power */
-		sign = 1;
-		for (i=0;i<ARRAY_SIZE(dtc_table_down);i++)
-		{
-			if ((dtc_table_down[i] >= pDM_Odm->RSSI_Min) || (dtc_steps >= 6))
-				break;
-			else
-				dtc_steps++;
-		}
-	}
-#if 0
-	else if (DTC_DWN_BASE > pDM_Odm->RSSI_Min)
-	{
-		/* needs to increase the CTS TX power */
-		sign = 0;
-		dtc_steps = 1;
-		for (i=0;i<ARRAY_SIZE(dtc_table_up);i++)
-		{
-			if ((dtc_table_up[i] <= pDM_Odm->RSSI_Min) || (dtc_steps>=10))
-				break;
-			else
-				dtc_steps++;
-		}
-	}
-#endif
-	else
-	{
-		sign = 0;
-		dtc_steps = 0;
-	}
-
-	resp_txagc = dtc_steps | (sign << 4);
-	resp_txagc = resp_txagc | (resp_txagc << 5);
-	ODM_Write1Byte(pDM_Odm, 0x06d9, resp_txagc);
-
-	DBG_871X("%s RSSI_Min:%u, set RESP_TXAGC to %s %u\n", 
-		__func__, pDM_Odm->RSSI_Min, sign?"minus":"plus", dtc_steps);
-#endif /* CONFIG_RESP_TXAGC_ADJUST */
-}
-
-#endif /* #if (DM_ODM_SUPPORT_TYPE == ODM_CE) */
-
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_debug.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_debug.c
deleted file mode 100644
index 1547ff10450b..000000000000
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_debug.c
+++ /dev/null
@@ -1,629 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-//============================================================
-// include files
-//============================================================
-
-#include "odm_precomp.h"
-
-
-VOID 
-ODM_InitDebugSetting(
-	IN		PDM_ODM_T		pDM_Odm
-	)
-{
-pDM_Odm->DebugLevel				= 	ODM_DBG_LOUD;
-
-pDM_Odm->DebugComponents			= 
-\
-#if DBG
-//BB Functions
-//									ODM_COMP_DIG					|
-//									ODM_COMP_RA_MASK				|
-//									ODM_COMP_DYNAMIC_TXPWR		|
-//									ODM_COMP_FA_CNT				|
-//									ODM_COMP_RSSI_MONITOR			|
-//									ODM_COMP_CCK_PD				|
-//									ODM_COMP_ANT_DIV				|
-//									ODM_COMP_PWR_SAVE				|
-//									ODM_COMP_PWR_TRAIN			|
-//									ODM_COMP_RATE_ADAPTIVE		|
-//									ODM_COMP_PATH_DIV				|
-//									ODM_COMP_DYNAMIC_PRICCA		|
-//									ODM_COMP_RXHP					|
-//									ODM_COMP_MP 					|
-//									ODM_COMP_DYNAMIC_ATC		|
-
-//MAC Functions
-//									ODM_COMP_EDCA_TURBO			|
-//									ODM_COMP_EARLY_MODE			|
-//RF Functions
-//									ODM_COMP_TX_PWR_TRACK		|
-//									ODM_COMP_RX_GAIN_TRACK		|
-//									ODM_COMP_CALIBRATION			|
-//Common
-//									ODM_COMP_COMMON				|
-//									ODM_COMP_INIT					|
-//									ODM_COMP_PSD					|
-#endif
-									0;
-}
-
-#if 0
-/*------------------Declare variable-----------------------
-// Define debug flag array for common debug print macro. */
-u4Byte ODM_DBGP_Type[ODM_DBGP_TYPE_MAX];
-
-/* Define debug print header for every service module. */
-ODM_DBGP_HEAD_T	ODM_DBGP_Head;
-
-
-/*-----------------------------------------------------------------------------
- * Function:    DBGP_Flag_Init
- *
- * Overview:    Refresh all debug print control flag content to zero.
- *
- * Input:       NONE
- *
- * Output:      NONE
- *
- * Return:      NONE
- *
- * Revised History:
- *  When		Who		Remark
- *  10/20/2006	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-extern	void	ODM_DBGP_Flag_Init(void)
-{    
-    u1Byte i;
-    
-	for (i = 0; i < ODM_DBGP_TYPE_MAX; i++)
-	{
- 		ODM_DBGP_Type[i] = 0;
-	}
-    
-#ifndef ADSL_AP_BUILD_WORKAROUND
-#if DBG		
-	// 2010/06/02 MH Free build driver can not out any debug message!!!
-	// Init Debug flag enable condition
-
-	ODM_DBGP_Type[FINIT]			=	\
-//								INIT_EEPROM						|
-//								INIT_TxPower						|
-//								INIT_IQK							|
-//								INIT_RF							|
-								0;
-
-	ODM_DBGP_Type[FDM]			=	\
-//								WA_IOT							|
-//								DM_PWDB						|
-//								DM_Monitor						|
-//								DM_DIG				|
-//								DM_EDCA_Turbo		|
-//								DM_BT30				|
-								0;
-
-	ODM_DBGP_Type[FIOCTL]		= 	\
-//								IOCTL_IRP						|
-//								IOCTL_IRP_DETAIL					|
-//								IOCTL_IRP_STATISTICS				|
-//								IOCTL_IRP_HANDLE				|
-//								IOCTL_BT_HCICMD					|
-//								IOCTL_BT_HCICMD_DETAIL			|
-//								IOCTL_BT_HCICMD_EXT				|
-//								IOCTL_BT_EVENT					|
-//								IOCTL_BT_EVENT_DETAIL			|
-//								IOCTL_BT_EVENT_PERIODICAL		|
-//								IOCTL_BT_TX_ACLDATA			|
-//								IOCTL_BT_TX_ACLDATA_DETAIL		|
-//								IOCTL_BT_RX_ACLDATA				|
-//								IOCTL_BT_RX_ACLDATA_DETAIL		|
-//								IOCTL_BT_TP						|
-//								IOCTL_STATE						|
-//								IOCTL_BT_LOGO					|
-//								IOCTL_CALLBACK_FUN				|
-//								IOCTL_PARSE_BT_PKT				|
-								0;
-
-	ODM_DBGP_Type[FBT]			= 	\
-//								BT_TRACE						|
-								0;
-
-	ODM_DBGP_Type[FEEPROM]		=	\
-//								EEPROM_W						|
-//								EFUSE_PG						|
-//								EFUSE_READ_ALL					|
-//								EFUSE_ANALYSIS					|
-//								EFUSE_PG_DETAIL					|
-								0;
-
-	ODM_DBGP_Type[FDBG_CTRL]	= 	\
-//								DBG_CTRL_TRACE					|
-//								DBG_CTRL_INBAND_NOISE			|
-								0;
-	
-	// 2011/07/20 MH Add for short cut 
-	ODM_DBGP_Type[FSHORT_CUT] = 	\
-//								SHCUT_TX 						| 
-//								SHCUT_RX						|
-								0;
-	
-#endif	
-#endif
-	/* Define debug header of every service module. */
-	//ODM_DBGP_Head.pMANS	= "\n\r[MANS] ";
-	//ODM_DBGP_Head.pRTOS	= "\n\r[RTOS] ";
-	//ODM_DBGP_Head.pALM	= "\n\r[ALM]  ";
-	//ODM_DBGP_Head.pPEM	= "\n\r[PEM]  ";
-	//ODM_DBGP_Head.pCMPK	= "\n\r[CMPK] ";
-	//ODM_DBGP_Head.pRAPD	= "\n\r[RAPD] ";
-	//ODM_DBGP_Head.pTXPB	= "\n\r[TXPB] ";
-	//ODM_DBGP_Head.pQUMG	= "\n\r[QUMG] ";
-    	
-}	/* DBGP_Flag_Init */
-
-#endif
-
-
-#if 0
-u4Byte GlobalDebugLevel			= 	DBG_LOUD;
-//
-// 2009/06/22 MH Allow Fre build to print none debug info at init time.
-//
-#if DBG
-u8Byte GlobalDebugComponents	= 	\
-//									COMP_TRACE				|
-//									COMP_DBG				|
-//									COMP_INIT				|
-//									COMP_OID_QUERY			|
-//									COMP_OID_SET			|
-//									COMP_RECV				|
-//									COMP_SEND				|
-//									COMP_IO					|
-//									COMP_POWER				|
-//									COMP_MLME				|
-//									COMP_SCAN				|
-//									COMP_SYSTEM			|
-//									COMP_SEC				|
-//									COMP_AP				|
-//									COMP_TURBO				|
-//									COMP_QOS				|
-//									COMP_AUTHENTICATOR	|
-//									COMP_BEACON			|
-//									COMP_ANTENNA			|
-//									COMP_RATE				|
-//									COMP_EVENTS			|
-//									COMP_FPGA				|
-//									COMP_RM				|
-//									COMP_MP				|
-//									COMP_RXDESC			|
-//									COMP_CKIP				|
-//									COMP_DIG				|
-//									COMP_TXAGC				|
-//									COMP_HIPWR				|
-//									COMP_HALDM				|
-//									COMP_RSNA				|
-//									COMP_INDIC				|
-//									COMP_LED				|
-//									COMP_RF					|
-//									COMP_DUALMACSWITCH	|
-//									COMP_EASY_CONCURRENT	|
-
-//1!!!!!!!!!!!!!!!!!!!!!!!!!!!
-//1//1Attention Please!!!<11n or 8190 specific code should be put below this line>
-//1!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-//									COMP_HT				|
-//									COMP_POWER_TRACKING 	|
-//									COMP_RX_REORDER		|
-//									COMP_AMSDU 			|
-//									COMP_WPS				|
-//									COMP_RATR				|
-//									COMP_RESET 				|
-//									COMP_CMD				|
-//									COMP_EFUSE				|
-//									COMP_MESH_INTERWORKING |
-//									COMP_CCX				|	
-//									COMP_IOCTL				|
-//									COMP_GP 				|
-//									COMP_TXAGG				|
-//									COMP_BB_POWERSAVING	|
-//									COMP_SWAS				|
-//									COMP_P2P				|
-//									COMP_MUX				|
-//									COMP_FUNC				|
-//									COMP_TDLS				|
-//									COMP_OMNIPEEK			|
-//									COMP_PSD				|
-									0;
-
-
-#else
-u8Byte GlobalDebugComponents	= 0;
-#endif
-
-#if (RT_PLATFORM==PLATFORM_LINUX) 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
-EXPORT_SYMBOL(GlobalDebugComponents);
-EXPORT_SYMBOL(GlobalDebugLevel);
-#endif
-#endif
-
-/*------------------Declare variable-----------------------
-// Define debug flag array for common debug print macro. */
-u4Byte			DBGP_Type[DBGP_TYPE_MAX];
-
-/* Define debug print header for every service module. */
-DBGP_HEAD_T		DBGP_Head;
-
-
-/*-----------------------------------------------------------------------------
- * Function:    DBGP_Flag_Init
- *
- * Overview:    Refresh all debug print control flag content to zero.
- *
- * Input:       NONE
- *
- * Output:      NONE
- *
- * Return:      NONE
- *
- * Revised History:
- *  When		Who		Remark
- *  10/20/2006	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-extern	void	DBGP_Flag_Init(void)
-{    
-    u1Byte	i;
-    
-	for (i = 0; i < DBGP_TYPE_MAX; i++)
-	{
- 		DBGP_Type[i] = 0;
-	}
-    
-#if DBG		
-	// 2010/06/02 MH Free build driver can not out any debug message!!!
-	// Init Debug flag enable condition
-
-	DBGP_Type[FINIT]			=	\
-//								INIT_EEPROM						|
-//								INIT_TxPower						|
-//								INIT_IQK							|
-//								INIT_RF							|
-								0;
-
-	DBGP_Type[FDM]			=	\
-//								WA_IOT							|
-//								DM_PWDB						|
-//								DM_Monitor						|
-//								DM_DIG				|
-//								DM_EDCA_Turbo		|
-//								DM_BT30				|
-								0;
-
-	DBGP_Type[FIOCTL]		= 	\
-//								IOCTL_IRP						|
-//								IOCTL_IRP_DETAIL					|
-//								IOCTL_IRP_STATISTICS				|
-//								IOCTL_IRP_HANDLE				|
-//								IOCTL_BT_HCICMD					|
-//								IOCTL_BT_HCICMD_DETAIL			|
-//								IOCTL_BT_HCICMD_EXT				|
-//								IOCTL_BT_EVENT					|
-//								IOCTL_BT_EVENT_DETAIL			|
-//								IOCTL_BT_EVENT_PERIODICAL		|
-//								IOCTL_BT_TX_ACLDATA			|
-//								IOCTL_BT_TX_ACLDATA_DETAIL		|
-//								IOCTL_BT_RX_ACLDATA				|
-//								IOCTL_BT_RX_ACLDATA_DETAIL		|
-//								IOCTL_BT_TP						|
-//								IOCTL_STATE						|
-//								IOCTL_BT_LOGO					|
-//								IOCTL_CALLBACK_FUN				|
-//								IOCTL_PARSE_BT_PKT				|
-								0;
-
-	DBGP_Type[FBT]			= 	\
-//								BT_TRACE						|
-								0;
-
-	DBGP_Type[FEEPROM]		=	\
-//								EEPROM_W						|
-//								EFUSE_PG						|
-//								EFUSE_READ_ALL					|
-//								EFUSE_ANALYSIS					|
-//								EFUSE_PG_DETAIL					|
-								0;
-
-	DBGP_Type[FDBG_CTRL]	= 	\
-//								DBG_CTRL_TRACE					|
-//								DBG_CTRL_INBAND_NOISE			|
-								0;
-	
-	// 2011/07/20 MH Add for short cut 
-	DBGP_Type[FSHORT_CUT] = 	\
-//								SHCUT_TX 						| 
-//								SHCUT_RX						|
-								0;
-	
-#endif	
-	/* Define debug header of every service module. */
-	DBGP_Head.pMANS	= "\n\r[MANS] ";
-	DBGP_Head.pRTOS	= "\n\r[RTOS] ";
-	DBGP_Head.pALM	= "\n\r[ALM]  ";
-	DBGP_Head.pPEM	= "\n\r[PEM]  ";
-	DBGP_Head.pCMPK	= "\n\r[CMPK] ";
-	DBGP_Head.pRAPD	= "\n\r[RAPD] ";
-	DBGP_Head.pTXPB	= "\n\r[TXPB] ";
-	DBGP_Head.pQUMG	= "\n\r[QUMG] ";
-    	
-}	/* DBGP_Flag_Init */
-
-
-/*-----------------------------------------------------------------------------
- * Function:    DBG_PrintAllFlag
- *
- * Overview:    Print All debug flag
- *
- * Input:       NONE
- *
- * Output:      NONE
- *
- * Return:      NONE
- *
- * Revised History:
- *  When		Who		Remark
- *  12/10/2008	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-extern	void	DBG_PrintAllFlag(void)
-{
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 0    FQoS\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 1    FTX\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 2    FRX\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 3    FSEC\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 4    FMGNT\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 5    FMLME\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 6    FRESOURCE\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 7    FBEACON\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 8    FISR\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 9    FPHY\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 11   FMP\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 12   FPWR\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 13   FDM\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 14   FDBG_CTRL\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 15   FC2H\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("DBGFLAG 16   FBT\n"));			
-}	// DBG_PrintAllFlag
-
-
-extern	void	DBG_PrintAllComp(void)
-{
-	u1Byte	i;
-	
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("GlobalDebugComponents Definition\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT0    COMP_TRACE\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT1    COMP_DBG\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT2    COMP_INIT\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT3    COMP_OID_QUERY\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT4    COMP_OID_SET\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT5    COMP_RECV\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT6    COMP_SEND\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT7    COMP_IO\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT8    COMP_POWER\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT9   COMP_MLME\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT10   COMP_SCAN\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT11   COMP_SYSTEM\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT12   COMP_SEC\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT13   COMP_AP\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT14   COMP_TURBO\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT15   COMP_QOS\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT16   COMP_AUTHENTICATOR\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT17   COMP_BEACON\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT18   COMP_BEACON\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT19   COMP_RATE\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT20   COMP_EVENTS\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT21   COMP_FPGA\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT22   COMP_RM\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT23   COMP_MP\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT24   COMP_RXDESC\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT25   COMP_CKIP\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT26   COMP_DIG\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT27   COMP_TXAGC\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT28   COMP_HIPWR\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT29   COMP_HALDM\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT30   COMP_RSNA\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT31   COMP_INDIC\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT32   COMP_LED\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT33   COMP_RF\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT34   COMP_HT\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT35   COMP_POWER_TRACKING\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT36   COMP_POWER_TRACKING\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT37   COMP_AMSDU\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT38   COMP_WPS\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT39   COMP_RATR\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT40   COMP_RESET\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT41   COMP_CMD\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT42   COMP_EFUSE\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT43   COMP_MESH_INTERWORKING\n"));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT43   COMP_CCX\n"));		
-	
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("GlobalDebugComponents = %"i64fmt"x\n", GlobalDebugComponents));
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("Enable DBG COMP ="));
-	for (i = 0; i < 64; i++)
-	{
-		if (GlobalDebugComponents & ((u8Byte)0x1 << i) )
-		{
-			ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT%02d |\n", i));
-		}
-	}
-	ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("\n"));
-	
-}	// DBG_PrintAllComp
-
-
-/*-----------------------------------------------------------------------------
- * Function:    DBG_PrintFlagEvent
- *
- * Overview:    Print dedicated debug flag event
- *
- * Input:       NONE
- *
- * Output:      NONE
- *
- * Return:      NONE
- *
- * Revised History:
- *  When		Who		Remark
- *  12/10/2008	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-extern	void	DBG_PrintFlagEvent(u1Byte	DbgFlag)
-{
-	switch(DbgFlag)
-	{
-		case	FQoS:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    QoS_INIT\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    QoS_VISTA\n"));
-		break;
-
-		case	FTX:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    TX_DESC\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    TX_DESC_TID\n"));
-		break;
-
-		case	FRX:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    RX_DATA\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    RX_PHY_STS\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 2    RX_PHY_SS\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 3    RX_PHY_SQ\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 4    RX_PHY_ASTS\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 5    RX_ERR_LEN\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 6    RX_DEFRAG\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 7    RX_ERR_RATE\n"));
-		break;
-
-		case	FSEC:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("NA\n"));
-		break;
-
-		case	FMGNT:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("NA\n"));
-		break;
-
-		case	FMLME:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    MEDIA_STS\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    LINK_STS\n"));		
-		break;
-
-		case	FRESOURCE:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    OS_CHK\n"));
-		break;
-
-		case	FBEACON:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    BCN_SHOW\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    BCN_PEER\n"));		
-		break;
-
-		case	FISR:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    ISR_CHK\n"));
-		break;
-
-		case	FPHY:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    PHY_BBR\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    PHY_BBW\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 2    PHY_RFR\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 3    PHY_RFW\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 4    PHY_MACR\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 5    PHY_MACW\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 6    PHY_ALLR\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 7    PHY_ALLW\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 8    PHY_TXPWR\n"));
-		break;
-
-		case	FMP:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    MP_RX\n"));
-		break;
-		
-		case	FEEPROM:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    EEPROM_W\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    EFUSE_PG\n"));		
-		break;
-		
-		case	FPWR:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    LPS\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    IPS\n"));		
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 2    PWRSW\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 3    PWRHW\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 4    PWRHAL\n"));
-		break;
-
-		case	FDM:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    WA_IOT\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    DM_PWDB\n"));		
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 2    DM_Monitor\n"));		
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 3    DM_DIG\n"));		
-		break;
-
-		case	FDBG_CTRL:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    DBG_CTRL_TRACE\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    DBG_CTRL_INBAND_NOISE\n"));		
-		break;
-		
-		case	FC2H:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    C2H_Summary\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    C2H_PacketData\n"));		
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 2    C2H_ContentData\n"));		
-		break;
-		
-		case	FBT:
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 0    BT_TRACE\n"));
-		ODM_RT_TRACE(pDM_Odm,COMP_CMD, DBG_LOUD, 	("BIT 1    BT_RFPoll\n"));		
-		break;		
-		
-		default:
-			break;
-	}
-
-}	// DBG_PrintFlagEvent
-
-
-extern	void	DBG_DumpMem(const u1Byte DbgComp, 
-							const u1Byte DbgLevel, 
-							pu1Byte pMem, 
-							u2Byte Len)
-{
-	u2Byte i;
-
-	for (i=0;i<((Len>>3) + 1);i++)
-	{
-		ODM_RT_TRACE(pDM_Odm,DbgComp, DbgLevel, ("%02X %02X %02X %02X %02X %02X %02X %02X\n",
-					*(pMem+(i*8)), *(pMem+(i*8+1)), *(pMem+(i*8+2)), *(pMem+(i*8+3)),
-					*(pMem+(i*8+4)), *(pMem+(i*8+5)), *(pMem+(i*8+6)), *(pMem+(i*8+7))));
-		
-	}
-}
-
-
-#endif
-
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_debug.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_debug.h
deleted file mode 100644
index 0a32f85ef34d..000000000000
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_debug.h
+++ /dev/null
@@ -1,892 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-
-#ifndef	__ODM_DBG_H__
-#define __ODM_DBG_H__
-
-
-//-----------------------------------------------------------------------------
-//	Define the debug levels
-//
-//	1.	DBG_TRACE and DBG_LOUD are used for normal cases.
-//	So that, they can help SW engineer to develope or trace states changed 
-//	and also help HW enginner to trace every operation to and from HW, 
-//	e.g IO, Tx, Rx. 
-//
-//	2.	DBG_WARNNING and DBG_SERIOUS are used for unusual or error cases, 
-//	which help us to debug SW or HW.
-//
-//-----------------------------------------------------------------------------
-//
-//	Never used in a call to ODM_RT_TRACE()!
-//
-#define ODM_DBG_OFF					1
-
-//
-//	Fatal bug. 
-//	For example, Tx/Rx/IO locked up, OS hangs, memory access violation, 
-//	resource allocation failed, unexpected HW behavior, HW BUG and so on.
-//
-#define ODM_DBG_SERIOUS				2
-
-//
-//	Abnormal, rare, or unexpeted cases.
-//	For example, IRP/Packet/OID canceled, device suprisely unremoved and so on.
-//
-#define ODM_DBG_WARNING				3
-
-//
-//	Normal case with useful information about current SW or HW state. 
-//	For example, Tx/Rx descriptor to fill, Tx/Rx descriptor completed status, 
-//	SW protocol state change, dynamic mechanism state change and so on.
-//
-#define ODM_DBG_LOUD					4
-
-//
-//	Normal case with detail execution flow or information.
-//
-#define ODM_DBG_TRACE					5
-
-//-----------------------------------------------------------------------------
-// Define the tracing components
-//
-//-----------------------------------------------------------------------------
-//BB Functions
-#define ODM_COMP_DIG				BIT0	
-#define ODM_COMP_RA_MASK			BIT1	
-#define ODM_COMP_DYNAMIC_TXPWR		BIT2
-#define ODM_COMP_FA_CNT				BIT3
-#define ODM_COMP_RSSI_MONITOR		BIT4
-#define ODM_COMP_CCK_PD				BIT5
-#define ODM_COMP_ANT_DIV			BIT6
-#define ODM_COMP_PWR_SAVE			BIT7
-#define ODM_COMP_PWR_TRAIN			BIT8
-#define ODM_COMP_RATE_ADAPTIVE		BIT9
-#define ODM_COMP_PATH_DIV			BIT10
-#define ODM_COMP_PSD				BIT11
-#define ODM_COMP_DYNAMIC_PRICCA		BIT12
-#define ODM_COMP_RXHP				BIT13			
-#define ODM_COMP_MP					BIT14
-#define ODM_COMP_DYNAMIC_ATC			BIT15
-//MAC Functions
-#define ODM_COMP_EDCA_TURBO			BIT16
-#define ODM_COMP_EARLY_MODE			BIT17
-//RF Functions
-#define ODM_COMP_TX_PWR_TRACK		BIT24
-#define ODM_COMP_RX_GAIN_TRACK		BIT25
-#define ODM_COMP_CALIBRATION		BIT26
-//Common Functions
-#define ODM_COMP_COMMON				BIT30
-#define ODM_COMP_INIT				BIT31
-
-/*------------------------Export Marco Definition---------------------------*/
-#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-	#define RT_PRINTK				DbgPrint
-#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-	#define DbgPrint	printk
-	#define RT_PRINTK(fmt, args...)	DbgPrint( "%s(): " fmt, __FUNCTION__, ## args);
-	#define	RT_DISP(dbgtype, dbgflag, printstr)
-#else
-	#define DbgPrint	panic_printk
-	#define RT_PRINTK(fmt, args...)	DbgPrint( "%s(): " fmt, __FUNCTION__, ## args);
-#endif
-
-#ifndef ASSERT
-	#define ASSERT(expr)
-#endif
-
-#if DBG
-#define ODM_RT_TRACE(pDM_Odm, comp, level, fmt)									\
-		if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel || level == ODM_DBG_SERIOUS))	\
-		{																			\
-			RT_PRINTK fmt;															\
-		}
-
-#define ODM_RT_TRACE_F(pDM_Odm, comp, level, fmt)									\
-		if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel))	\
-		{																			\
-			RT_PRINTK fmt;															\
-		}
-
-#define ODM_RT_ASSERT(pDM_Odm, expr, fmt)											\
-		if(!(expr)) {																	\
-			DbgPrint( "Assertion failed! %s at ......\n", #expr);								\
-			DbgPrint( "      ......%s,%s,line=%d\n",__FILE__,__FUNCTION__,__LINE__);			\
-			RT_PRINTK fmt;															\
-			ASSERT(FALSE);															\
-		}
-#define ODM_dbg_enter() { DbgPrint("==> %s\n", __FUNCTION__); }
-#define ODM_dbg_exit() { DbgPrint("<== %s\n", __FUNCTION__); }
-#define ODM_dbg_trace(str) { DbgPrint("%s:%s\n", __FUNCTION__, str); }
-
-#define ODM_PRINT_ADDR(pDM_Odm, comp, level, title_str, ptr)							\
-			if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel))	\
-			{																		\
-				int __i;																\
-				pu1Byte	__ptr = (pu1Byte)ptr;											\
-				DbgPrint("[ODM] ");													\
-				DbgPrint(title_str);													\
-				DbgPrint(" ");														\
-				for( __i=0; __i<6; __i++ )												\
-					DbgPrint("%02X%s", __ptr[__i], (__i==5)?"":"-");						\
-				DbgPrint("\n");														\
-			}
-#else
-#define ODM_RT_TRACE(pDM_Odm, comp, level, fmt)
-#define ODM_RT_TRACE_F(pDM_Odm, comp, level, fmt)
-#define ODM_RT_ASSERT(pDM_Odm, expr, fmt)
-#define ODM_dbg_enter()
-#define ODM_dbg_exit()
-#define ODM_dbg_trace(str)
-#define ODM_PRINT_ADDR(pDM_Odm, comp, level, title_str, ptr)
-#endif
-
-
-VOID 
-ODM_InitDebugSetting(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-
-
-#if 0
-#if DBG
-#define DbgPrint printk
-
-#define PRINT_DATA(_TitleString, _HexData, _HexDataLen)								\
-			{																		\
-				char			*szTitle = _TitleString;									\
-				pu1Byte		pbtHexData = _HexData;									\
-				u4Byte		u4bHexDataLen = _HexDataLen;							\
-				u4Byte		__i;														\
-				DbgPrint("%s", szTitle);													\
-				for (__i=0;__i<u4bHexDataLen;__i++)									\
-				{																	\
-					if ((__i & 15) == 0) 												\
-					{																\
-						DbgPrint("\n");												\
-					}																\
-					DbgPrint("%02X%s", pbtHexData[__i], ( ((__i&3)==3) ? "  " : " ") );		\
-				}																	\
-				DbgPrint("\n");														\
-			}
-
-// RT_PRINT_XXX macros: implemented for debugging purpose.
-// Added by Annie, 2005-11-21.
-#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)			\
-			if(((_Comp) & ODM_GlobalDebugComponents) && (_Level <= ODM_GlobalDebugLevel))	\
-			{																		\
-				int __i;																\
-				pu1Byte	ptr = (pu1Byte)_HexData;										\
-				DbgPrint("Rtl819x: ");													\
-				DbgPrint(_TitleString);												\
-				for( __i=0; __i<(int)_HexDataLen; __i++ )								\
-				{																	\
-					DbgPrint("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");			\
-					if (((__i + 1) % 16) == 0)	DbgPrint("\n");							\
-				}																	\
-				DbgPrint("\n");														\
-			}
-
-#define RT_PRINT_ADDR(_Comp, _Level, _TitleString, _Ptr)								\
-			if(((_Comp) & ODM_GlobalDebugComponents) && (_Level <= ODM_GlobalDebugLevel))	\
-			{																		\
-				int __i;																\
-				pu1Byte	ptr = (pu1Byte)_Ptr;											\
-				DbgPrint("Rtl819x: ");													\
-				DbgPrint(_TitleString);												\
-				DbgPrint(" ");															\
-				for( __i=0; __i<6; __i++ )												\
-					DbgPrint("%02X%s", ptr[__i], (__i==5)?"":"-");							\
-				DbgPrint("\n");														\
-			}
-
-#define RT_PRINT_ADDRS(_Comp, _Level, _TitleString, _Ptr, _AddNum)					\
-			if(((_Comp) & ODM_GlobalDebugComponents) && (_Level <= ODM_GlobalDebugLevel))	\
-			{																		\
-				int __i, __j;															\
-				pu1Byte	ptr = (pu1Byte)_Ptr;											\
-				DbgPrint("Rtl819x: ");													\
-				DbgPrint(_TitleString);												\
-				DbgPrint("\n");														\
-				for( __i=0; __i<(int)_AddNum; __i++ )									\
-				{																	\
-					for( __j=0; __j<6; __j++ )											\
-						DbgPrint("%02X%s", ptr[__i*6+__j], (__j==5)?"":"-");				\
-					DbgPrint("\n");													\
-				}																	\
-			}
-
-// Added by Annie, 2005-11-22.
-#define	MAX_STR_LEN	64
-#define	PRINTABLE(_ch)	(_ch>=' ' &&_ch<='~' )	// I want to see ASCII 33 to 126 only. Otherwise, I print '?'. Annie, 2005-11-22.
-
-#define RT_PRINT_STR(_Comp, _Level, _TitleString, _Ptr, _Len)							\
-			if(((_Comp) & ODM_GlobalDebugComponents) && (_Level <= ODM_GlobalDebugLevel))	\
-			{																		\
-				int		__i;															\
-				u1Byte	buffer[MAX_STR_LEN];											\
-				int	length = (_Len<MAX_STR_LEN)? _Len : (MAX_STR_LEN-1) ;				\
-				PlatformZeroMemory( buffer, MAX_STR_LEN );							\
-				PlatformMoveMemory( buffer, (pu1Byte)_Ptr, length );						\
-				for( __i=0; __i<MAX_STR_LEN; __i++ )									\
-				{																	\
-					if( !PRINTABLE(buffer[__i]) )	buffer[__i] = '?';						\
-				}																	\
-				buffer[length] = '\0';													\
-				DbgPrint("Rtl819x: ");													\
-				DbgPrint(_TitleString);												\
-				DbgPrint(": %d, <%s>\n", _Len, buffer);									\
-			}
-			
-#else	// of #if DBG
-#define DbgPrint(...)	
-#define PRINT_DATA(_TitleString, _HexData, _HexDataLen)
-#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)
-#define RT_PRINT_ADDR(_Comp, _Level, _TitleString, _Ptr)
-#define RT_PRINT_ADDRS(_Comp, _Level, _TitleString, _Ptr, _AddNum)
-#define RT_PRINT_STR(_Comp, _Level, _TitleString, _Ptr, _Len)
-#endif	// of #if DBG
-
-#endif	
-
-
-#if 0
-/* Define debug print header for every service module.*/
-typedef struct tag_ODM_DBGP_Service_Module_Header_Name_Structure
-{
-	const char 	*pMANS;
-	const char 	*pRTOS;
-	const char 	*pALM;
-	const char 	*pPEM;
-	const char 	*pCMPK;
-	const char 	*pRAPD;
-	const char 	*pTXPB;
-	const char 	*pQUMG;
-}ODM_DBGP_HEAD_T;
-
-
-/* Define different debug flag for dedicated service modules in debug flag array. */
-// Each module has independt 32 bit debug flag you cnn define the flag as yout require.
-typedef enum tag_ODM_DBGP_Flag_Type_Definition
-{
-	ODM_FTX				= 0,
-	ODM_FRX				,	
-	ODM_FPHY				,
-	ODM_FPWR				,
-	ODM_FDM				,
-	ODM_FC2H				,
-	ODM_FBT				,
-	ODM_DBGP_TYPE_MAX
-}ODM_DBGP_FLAG_E;
-
-
-// Define TX relative debug bit				--> FTX
-#define		ODM_TX_DESC			BIT0
-#define		ODM_TX_DESC_TID		BIT1
-#define		ODM_TX_PATH			BIT2
-
-// Define RX relative debug  bit				--> FRX
-#define		ODM_RX_DATA				BIT0	
-#define		ODM_RX_PHY_STS			BIT1
-#define		ODM_RX_PHY_SS				BIT2
-#define		ODM_RX_PHY_SQ				BIT3
-#define		ODM_RX_PHY_ASTS			BIT4
-#define		ODM_RX_ERR_LEN			BIT5
-#define		ODM_RX_DEFRAG				BIT6
-#define		ODM_RX_ERR_RATE			BIT7
-#define		ODM_RX_PATH				BIT8
-#define		ODM_RX_BEACON				BIT9
-
-// Define PHY-BB/RF/MAC check module bit		--> FPHY
-#define		ODM_PHY_BBR				BIT0
-#define		ODM_PHY_BBW				BIT1
-#define		ODM_PHY_RFR				BIT2
-#define		ODM_PHY_RFW				BIT3
-#define		ODM_PHY_MACR				BIT4
-#define		ODM_PHY_MACW				BIT5
-#define		ODM_PHY_ALLR				BIT6
-#define		ODM_PHY_ALLW				BIT7
-#define		ODM_PHY_TXPWR			BIT8
-#define		ODM_PHY_PWRDIFF			BIT9
-#define		ODM_PHY_SICR				BIT10
-#define		ODM_PHY_SICW				BIT11
-
-
-
-
-extern	u4Byte ODM_GlobalDebugLevel;
-
-
-#if DBG
-extern	u8Byte ODM_GlobalDebugComponents;
-#endif
-#endif
-#if 0
-
-//-----------------------------------------------------------------------------
-//	Define the debug levels
-//
-//	1.	DBG_TRACE and DBG_LOUD are used for normal cases.
-//	So that, they can help SW engineer to develope or trace states changed 
-//	and also help HW enginner to trace every operation to and from HW, 
-//	e.g IO, Tx, Rx. 
-//
-//	2.	DBG_WARNNING and DBG_SERIOUS are used for unusual or error cases, 
-//	which help us to debug SW or HW.
-//
-//-----------------------------------------------------------------------------
-//
-//	Never used in a call to ODM_RT_TRACE(pDM_Odm,)!
-//
-#define DBG_OFF					0
-
-//
-//	Deprecated! Don't use it! 
-//	TODO: fix related debug message!
-//
-//#define DBG_SEC					1
-
-//
-//	Fatal bug. 
-//	For example, Tx/Rx/IO locked up, OS hangs, memory access violation, 
-//	resource allocation failed, unexpected HW behavior, HW BUG and so on.
-//
-#define DBG_SERIOUS				2
-
-//
-//	Abnormal, rare, or unexpeted cases.
-//	For example, IRP/Packet/OID canceled, device suprisely unremoved and so on.
-//
-#define DBG_WARNING				3
-
-//
-//	Normal case with useful information about current SW or HW state. 
-//	For example, Tx/Rx descriptor to fill, Tx/Rx descriptor completed status, 
-//	SW protocol state change, dynamic mechanism state change and so on.
-//
-#define DBG_LOUD				4
-
-//
-//	Normal case with detail execution flow or information.
-//
-#define DBG_TRACE				5
-
-
-
-//-----------------------------------------------------------------------------
-// Define the tracing components
-//
-//-----------------------------------------------------------------------------
-#define COMP_TRACE				BIT0		// For function call tracing.
-#define COMP_DBG				BIT1		// Only for temporary debug message.
-#define COMP_INIT				BIT2		// during driver initialization / halt / reset.
-#define COMP_OID_QUERY				BIT3		// Query OID.
-#define COMP_OID_SET				BIT4		// Set OID.
-#define COMP_RECV				BIT5		// Reveive part data path.
-#define COMP_SEND				BIT6		// Send part path.
-#define COMP_IO					BIT7		// I/O Related. Added by Annie, 2006-03-02.
-#define COMP_POWER				BIT8		// 802.11 Power Save mode or System/Device Power state related.
-#define COMP_MLME				BIT9		// 802.11 link related: join/start BSS, leave BSS.
-#define COMP_SCAN				BIT10	// For site survey.
-#define COMP_SYSTEM				BIT11	// For general platform function.
-#define COMP_SEC				BIT12	// For Security.
-#define COMP_AP					BIT13	// For AP mode related.
-#define COMP_TURBO				BIT14	// For Turbo Mode related. By Annie, 2005-10-21.
-#define COMP_QOS				BIT15	// For QoS.
-#define COMP_AUTHENTICATOR			BIT16	// For AP mode Authenticator. Added by Annie, 2006-01-30.
-#define COMP_BEACON				BIT17	// For Beacon related, by rcnjko.
-#define COMP_ANTENNA				BIT18	// For Antenna diversity related, by rcnjko. 
-#define COMP_RATE				BIT19	// For Rate Adaptive mechanism, 2006.07.02, by rcnjko. #define COMP_EVENTS				0x00000080	// Event handling
-#define COMP_EVENTS				BIT20	// Event handling
-#define COMP_FPGA				BIT21	// For FPGA verfication 
-#define COMP_RM					BIT22	// For Radio Measurement. 
-#define COMP_MP					BIT23	// For mass production test, by shien chang, 2006.07.13
-#define COMP_RXDESC				BIT24	// Show Rx desc information for SD3 debug. Added by Annie, 2006-07-15.
-#define COMP_CKIP				BIT25	// For CCX 1 S13: CKIP. Added by Annie, 2006-08-14.
-#define COMP_DIG				BIT26	// For DIG, 2006.09.25, by rcnjko.
-#define COMP_TXAGC				BIT27	// For Tx power, 060928, by rcnjko. 
-#define COMP_HIPWR				BIT28	// For High Power Mechanism, 060928, by rcnjko. 
-#define COMP_HALDM				BIT29	// For HW Dynamic Mechanism, 061010, by rcnjko. 
-#define COMP_RSNA				BIT30	// For RSNA IBSS , 061201, by CCW. 
-#define COMP_INDIC				BIT31	// For link indication
-#define COMP_LED				BIT32	// For LED.
-#define COMP_RF					BIT33	// For RF.
-//1!!!!!!!!!!!!!!!!!!!!!!!!!!!
-//1//1Attention Please!!!<11n or 8190 specific code should be put below this line>
-//1!!!!!!!!!!!!!!!!!!!!!!!!!!!
-
-#define COMP_HT					BIT34	// For 802.11n HT related information. by Emily 2006-8-11
-#define COMP_POWER_TRACKING			BIT35	//FOR 8190 TX POWER TRACKING
-#define COMP_RX_REORDER				BIT36	// 8190 Rx Reorder
-#define COMP_AMSDU				BIT37	// For A-MSDU Debugging
-#define COMP_WPS				BIT38   //WPS Debug Message 
-#define COMP_RATR				BIT39	
-#define COMP_RESET				BIT40
-// For debug command to print on dbgview!!
-#define COMP_CMD				BIT41
-#define COMP_EFUSE				BIT42
-#define COMP_MESH_INTERWORKING 			BIT43
-#define COMP_CCX				BIT44	//CCX Debug Flag
-#define	COMP_IOCTL				BIT45	// IO Control
-#define COMP_GP					BIT46	// For generic parser.
-#define COMP_TXAGG				BIT47
-#define COMP_HVL                            	BIT48     // For Ndis 6.2 Context Swirch and Hardware Virtualiztion Layer
-#define COMP_TEST				BIT49
-#define COMP_BB_POWERSAVING	BIT50
-#define COMP_SWAS				BIT51	// For SW Antenna Switch
-#define COMP_P2P				BIT52
-#define COMP_MUX				BIT53
-#define COMP_FUNC				BIT54
-#define COMP_TDLS				BIT55
-#define COMP_OMNIPEEK			BIT56
-#define COMP_DUALMACSWITCH	BIT60	// 2010/12/27 Add for Dual mac mode debug
-#define COMP_EASY_CONCURRENT	BIT61	// 2010/12/27 Add for easy cncurrent mode debug
-#define COMP_PSD				BIT63	//2011/3/9 Add for WLAN PSD for BT AFH
-
-#define COMP_DFS                                BIT62
-
-#define	COMP_ALL				UINT64_C(0xFFFFFFFFFFFFFFFF) // All components
-// For debug print flag to use
-/*------------------------------Define structure----------------------------*/
-/* 2007/07/13 MH  *//*------For DeBuG Print modeue------*/
-
-/* Defnie structure to store different debug flag variable. Every debug flag 
-     is a UINT32 integer and you can assign 32 different events. */
-typedef struct tag_DBGP_Debug_Flag_Structure
-{
-	u4Byte	Mans;			/* Main Scheduler module. */
-	u4Byte	Rtos;			/* RTOS module. */
-	u4Byte	Alarm;		/* Alarm module. */	
-	u4Byte	Pm;			/* Performance monitor module. */	
-}DBGP_FLAG_T;
-
-/* Define debug print header for every service module.*/
-typedef struct tag_DBGP_Service_Module_Header_Name_Structure
-{
-	const char 	*pMANS;
-	const char 	*pRTOS;
-	const char 	*pALM;
-	const char 	*pPEM;
-	const char 	*pCMPK;
-	const char 	*pRAPD;
-	const char 	*pTXPB;
-	const char 	*pQUMG;
-}DBGP_HEAD_T;
-
-
-/* Define different debug flag for dedicated service modules in debug flag array. */
-// Each module has independt 32 bit debug flag you cnn define the flag as yout require.
-typedef enum tag_DBGP_Flag_Type_Definition
-{
-	FQoS				= 0,	
-	FTX					= 1,
-	FRX					= 2,	
-	FSEC				= 3,
-	FMGNT				= 4,
-	FMLME				= 5,
-	FRESOURCE			= 6,
-	FBEACON				= 7,
-	FISR				= 8,
-	FPHY				= 9,
-	FMP					= 10,
-	FEEPROM			= 11,
-	FPWR				= 12,
-	FDM					= 13,
-	FDBG_CTRL			= 14,
-	FC2H				= 15,
-	FBT					= 16,
-	FINIT				= 17,
-	FIOCTL				= 18,
-	FSHORT_CUT			= 19,
-	DBGP_TYPE_MAX
-}DBGP_FLAG_E;
-
-
-// Define Qos Relative debug flag bit		--> FQoS
-#define		QoS_INIT			BIT0
-#define		QoS_VISTA			BIT1
-
-// Define TX relative debug bit				--> FTX
-#define		TX_DESC			BIT0
-#define		TX_DESC_TID		BIT1
-#define		TX_PATH			BIT2
-
-// Define RX relative debug  bit				--> FRX
-#define		RX_DATA				BIT0	
-#define		RX_PHY_STS				BIT1
-#define		RX_PHY_SS				BIT2
-#define		RX_PHY_SQ				BIT3
-#define		RX_PHY_ASTS			BIT4
-#define		RX_ERR_LEN			BIT5
-#define		RX_DEFRAG			BIT6
-#define		RX_ERR_RATE			BIT7
-#define		RX_PATH				BIT8
-#define		RX_BEACON				BIT9
-
-// Define Security relative debug  bit			--> FSEC
-
-// Define MGNT relative debug bit			--> FMGNT
-
-// Define MLME relative debug bit				--> FMLME
-#define		MEDIA_STS			BIT0
-#define		LINK_STS			BIT1
-
-// Define OS resource check module bit		--> FRESOURCE
-#define		OS_CHK				BIT0
-
-// Define beacon content check module bit		--> FBEACON
-#define		BCN_SHOW			BIT0
-#define		BCN_PEER			BIT1
-
-// Define ISR/IMR check module bit		--> FISR
-#define		ISR_CHK				BIT0
-
-// Define PHY-BB/RF/MAC check module bit		--> FPHY
-#define		PHY_BBR				BIT0
-#define		PHY_BBW				BIT1
-#define		PHY_RFR				BIT2
-#define		PHY_RFW				BIT3
-#define		PHY_MACR				BIT4
-#define		PHY_MACW				BIT5
-#define		PHY_ALLR				BIT6
-#define		PHY_ALLW				BIT7
-#define		PHY_TXPWR				BIT8
-#define		PHY_PWRDIFF			BIT9
-#define		PHY_SICR				BIT10
-#define		PHY_SICW				BIT11
-
-// Define MPT driver check module bit		--> FMP
-#define		MP_RX					BIT0
-#define		MP_SWICH_CH			BIT1
-
-// Define EEPROM and EFUSE  check module bit		--> FEEPROM
-#define		EEPROM_W					BIT0
-#define		EFUSE_PG					BIT1
-#define		EFUSE_READ_ALL			BIT2
-#define		EFUSE_ANALYSIS				BIT3
-#define		EFUSE_PG_DETAIL			BIT4
-
-// Define power save  check module bit		--> FPWR
-#define		LPS					BIT0
-#define		IPS					BIT1
-#define		PWRSW				BIT2
-#define		PWRHW				BIT3
-#define		PWRHAL				BIT4
-
-// Define Dynamic Mechanism check module bit		--> FDM
-#define		WA_IOT				BIT0
-#define		DM_PWDB			BIT1
-#define		DM_Monitor			BIT2
-#define		DM_DIG				BIT3
-#define		DM_EDCA_Turbo		BIT4
-#define		DM_BT30			BIT5
-
-// Define Dbg Control module bit		--> FDBG_CTRL
-#define		DBG_CTRL_TRACE			BIT0
-#define		DBG_CTRL_INBAND_NOISE	BIT1
-
-// Define FW C2H Cmd check module bit		--> FC2H
-#define		C2H_Summary				BIT0
-#define		C2H_PacketData				BIT1
-#define		C2H_ContentData			BIT2
-// Define BT Cmd check module bit		--> FBT
-#define		BT_TRACE					BIT0
-#define		BT_RFPoll					BIT1
-
-// Define init check for module bit		--> FINIT
-#define		INIT_EEPROM				BIT0
-#define		INIT_TxPower				BIT1
-#define		INIT_IQK					BIT2
-#define		INIT_RF						BIT3
-
-// Define IOCTL Cmd check module bit		--> FIOCTL
-// section 1 : IRP related
-#define		IOCTL_IRP						BIT0
-#define		IOCTL_IRP_DETAIL				BIT1
-#define		IOCTL_IRP_STATISTICS			BIT2
-#define		IOCTL_IRP_HANDLE				BIT3
-// section 2 : HCI command/event
-#define		IOCTL_BT_HCICMD				BIT8
-#define		IOCTL_BT_HCICMD_DETAIL		BIT9
-#define		IOCTL_BT_HCICMD_EXT			BIT10
-#define		IOCTL_BT_EVENT					BIT11
-#define		IOCTL_BT_EVENT_DETAIL			BIT12
-#define		IOCTL_BT_EVENT_PERIODICAL		BIT13
-// section 3 : BT tx/rx data and throughput
-#define		IOCTL_BT_TX_ACLDATA			BIT16
-#define		IOCTL_BT_TX_ACLDATA_DETAIL	BIT17
-#define		IOCTL_BT_RX_ACLDATA			BIT18
-#define		IOCTL_BT_RX_ACLDATA_DETAIL	BIT19
-#define		IOCTL_BT_TP					BIT20
-// section 4 : BT connection state machine.
-#define 		IOCTL_STATE					BIT21	
-#define		IOCTL_BT_LOGO					BIT22
-// section 5 : BT function trace
-#define		IOCTL_CALLBACK_FUN			BIT24
-#define		IOCTL_PARSE_BT_PKT			BIT25
-#define		IOCTL_BT_TX_PKT				BIT26
-#define		IOCTL_BT_FLAG_MON				BIT27
-
-//
-// Define init check for module bit		--> FSHORT_CUT
-// 2011/07/20 MH Add for short but definition.
-//
-#define		SHCUT_TX				BIT0
-#define		SHCUT_RX				BIT1
-
-
-/* 2007/07/13 MH  *//*------For DeBuG Print modeue------*/
-/*------------------------------Define structure----------------------------*/
-
-
-/*------------------------Export Marco Definition---------------------------*/
-#if (DM_ODM_SUPPORT_TYPE != ODM_WIN)
-#define RT_PRINTK(fmt, args...)    printk( "%s(): " fmt, __FUNCTION__, ## args);
-
-#if DBG
-#define ODM_RT_TRACE(pDM_Odm,comp, level, fmt)											\
-		if(((comp) & GlobalDebugComponents) && (level <= GlobalDebugLevel))	\
-		{																	\
-			RT_PRINTK fmt;													\
-		}
-
-#define RT_TRACE_F(comp, level, fmt)											\
-		if(((comp) & GlobalDebugComponents) && (level <= GlobalDebugLevel))	\
-		{																	\
-			RT_PRINTK fmt;													\
-		}
-
-#define RT_ASSERT(expr,fmt)													\
-		if(!(expr)) {															\
-			printk( "Assertion failed! %s at ......\n", #expr);							\
-			printk( "      ......%s,%s,line=%d\n",__FILE__,__FUNCTION__,__LINE__);	\
-		}
-#define dbg_enter() { printk("==> %s\n", __FUNCTION__); }
-#define dbg_exit() { printk("<== %s\n", __FUNCTION__); }
-#define dbg_trace(str) { printk("%s:%s\n", __FUNCTION__, str); }
-#else
-#define ODM_RT_TRACE(pDM_Odm,comp, level, fmt)
-#define RT_TRACE_F(comp, level, fmt)
-#define RT_ASSERT(expr, fmt)
-#define dbg_enter()
-#define dbg_exit()
-#define dbg_trace(str)
-#endif
-
-#if DBG
-#define DbgPrint printk
-
-#define PRINT_DATA(_TitleString, _HexData, _HexDataLen)								\
-			{																		\
-				char			*szTitle = _TitleString;									\
-				pu1Byte		pbtHexData = _HexData;									\
-				u4Byte		u4bHexDataLen = _HexDataLen;							\
-				u4Byte		__i;														\
-				DbgPrint("%s", szTitle);													\
-				for (__i=0;__i<u4bHexDataLen;__i++)									\
-				{																	\
-					if ((__i & 15) == 0) 												\
-					{																\
-						DbgPrint("\n");												\
-					}																\
-					DbgPrint("%02X%s", pbtHexData[__i], ( ((__i&3)==3) ? "  " : " ") );		\
-				}																	\
-				DbgPrint("\n");														\
-			}
-
-// RT_PRINT_XXX macros: implemented for debugging purpose.
-// Added by Annie, 2005-11-21.
-#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)			\
-			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
-			{																		\
-				int __i;																\
-				pu1Byte	ptr = (pu1Byte)_HexData;										\
-				DbgPrint("Rtl819x: ");													\
-				DbgPrint(_TitleString);												\
-				for( __i=0; __i<(int)_HexDataLen; __i++ )								\
-				{																	\
-					DbgPrint("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");			\
-					if (((__i + 1) % 16) == 0)	DbgPrint("\n");							\
-				}																	\
-				DbgPrint("\n");														\
-			}
-
-#define RT_PRINT_ADDR(_Comp, _Level, _TitleString, _Ptr)								\
-			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
-			{																		\
-				int __i;																\
-				pu1Byte	ptr = (pu1Byte)_Ptr;											\
-				DbgPrint("Rtl819x: ");													\
-				DbgPrint(_TitleString);												\
-				DbgPrint(" ");															\
-				for( __i=0; __i<6; __i++ )												\
-					DbgPrint("%02X%s", ptr[__i], (__i==5)?"":"-");							\
-				DbgPrint("\n");														\
-			}
-
-#define RT_PRINT_ADDRS(_Comp, _Level, _TitleString, _Ptr, _AddNum)					\
-			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
-			{																		\
-				int __i, __j;															\
-				pu1Byte	ptr = (pu1Byte)_Ptr;											\
-				DbgPrint("Rtl819x: ");													\
-				DbgPrint(_TitleString);												\
-				DbgPrint("\n");														\
-				for( __i=0; __i<(int)_AddNum; __i++ )									\
-				{																	\
-					for( __j=0; __j<6; __j++ )											\
-						DbgPrint("%02X%s", ptr[__i*6+__j], (__j==5)?"":"-");				\
-					DbgPrint("\n");													\
-				}																	\
-			}
-
-// Added by Annie, 2005-11-22.
-#define	MAX_STR_LEN	64
-#define	PRINTABLE(_ch)	(_ch>=' ' &&_ch<='~' )	// I want to see ASCII 33 to 126 only. Otherwise, I print '?'. Annie, 2005-11-22.
-
-#define RT_PRINT_STR(_Comp, _Level, _TitleString, _Ptr, _Len)							\
-			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
-			{																		\
-				int		__i;															\
-				u1Byte	buffer[MAX_STR_LEN];											\
-				int	length = (_Len<MAX_STR_LEN)? _Len : (MAX_STR_LEN-1) ;				\
-				PlatformZeroMemory( buffer, MAX_STR_LEN );							\
-				PlatformMoveMemory( buffer, (pu1Byte)_Ptr, length );						\
-				for( __i=0; __i<MAX_STR_LEN; __i++ )									\
-				{																	\
-					if( !PRINTABLE(buffer[__i]) )	buffer[__i] = '?';						\
-				}																	\
-				buffer[length] = '\0';													\
-				DbgPrint("Rtl819x: ");													\
-				DbgPrint(_TitleString);												\
-				DbgPrint(": %d, <%s>\n", _Len, buffer);									\
-			}
-			
-#else	// of #if DBG
-#define DbgPrint(...)	
-#define PRINT_DATA(_TitleString, _HexData, _HexDataLen)
-#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)
-#define RT_PRINT_ADDR(_Comp, _Level, _TitleString, _Ptr)
-#define RT_PRINT_ADDRS(_Comp, _Level, _TitleString, _Ptr, _AddNum)
-#define RT_PRINT_STR(_Comp, _Level, _TitleString, _Ptr, _Len)
-#endif	// of #if DBG
-
-
-
-#endif	// #if (DM_ODM_SUPPORT_TYPE != ODM_WIN)
-
-#define		DEBUG_PRINT				1
-
-// Please add new OS's print API by yourself
-
-//#if (RT_PLATFORM==PLATFORM_WINDOWS) 
-#if (DEBUG_PRINT == 1) && DBG
-#define	RT_DISP(dbgtype, dbgflag, printstr)\
-{\
-	if (DBGP_Type[dbgtype] & dbgflag)\
-	{\
-		DbgPrint printstr;\
-	}\
-}
-
-#define	RT_DISP_ADDR(dbgtype, dbgflag, printstr, _Ptr)\
-{\
-	if (DBGP_Type[dbgtype] & dbgflag)\
-	{\
-				int __i;						\
-				pu1Byte	ptr = (pu1Byte)_Ptr;	\
-				DbgPrint printstr;				\
-				DbgPrint(" ");					\
-				for( __i=0; __i<6; __i++ )		\
-					DbgPrint("%02X%s", ptr[__i], (__i==5)?"":"-");		\
-				DbgPrint("\n");							\
-	}\
-}
-
-#define RT_DISP_DATA(dbgtype, dbgflag, _TitleString, _HexData, _HexDataLen)\
-{\
-	if (DBGP_Type[dbgtype] & dbgflag)\
-	{\
-		int __i;									\
-		pu1Byte	ptr = (pu1Byte)_HexData;			\
-		DbgPrint(_TitleString);					\
-		for( __i=0; __i<(int)_HexDataLen; __i++ )	\
-		{										\
-			DbgPrint("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");\
-			if (((__i + 1) % 16) == 0)	DbgPrint("\n");\
-		}										\
-		DbgPrint("\n");							\
-	}\
-}
-
-#define FunctionIn(_comp)		ODM_RT_TRACE(pDM_Odm,(_comp), DBG_LOUD, ("==========> %s\n",  __FUNCTION__))
-#define FunctionOut(_comp)		ODM_RT_TRACE(pDM_Odm,(_comp), DBG_LOUD, ("<========== %s\n",  __FUNCTION__))
-
-
-#else
-
-#define	RT_DISP(dbgtype, dbgflag, printstr)
-#define	RT_DISP_ADDR(dbgtype, dbgflag, printstr, _Ptr)
-#define   RT_DISP_DATA(dbgtype, dbgflag, _TitleString, _HexData, _HexDataLen)
-
-#define FunctionIn(_comp)
-#define FunctionOut(_comp)
-#endif
-/*------------------------Export Marco Definition---------------------------*/
-
-
-/*------------------------Export global variable----------------------------*/
-extern	u4Byte			DBGP_Type[DBGP_TYPE_MAX];
-extern	DBGP_HEAD_T	DBGP_Head;
-
-/*------------------------Export global variable----------------------------*/
-
-
-/*--------------------------Exported Function prototype---------------------*/
-extern	void	DBGP_Flag_Init(void);
-extern	void	DBG_PrintAllFlag(void);
-extern	void	DBG_PrintAllComp(void);
-extern	void	DBG_PrintFlagEvent(u1Byte	DbgFlag);
-extern	void	DBG_DumpMem(const u1Byte DbgComp, 
-							const u1Byte DbgLevel, 
-							pu1Byte pMem, 
-							u2Byte Len);
-
-/*--------------------------Exported Function prototype---------------------*/
-
-
-
-
-
-
-
-
-
-extern u4Byte GlobalDebugLevel;
-extern u8Byte GlobalDebugComponents;
-
-
-#endif
-
-
-#endif	// __ODM_DBG_H__
-
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_reg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_reg.h
deleted file mode 100644
index 16999a105193..000000000000
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_reg.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *                                        
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-//============================================================
-// File Name: odm_reg.h
-//
-// Description:
-//
-// This file is for general register definition.
-//
-//
-//============================================================
-#ifndef	__HAL_ODM_REG_H__
-#define __HAL_ODM_REG_H__
-
-//
-// Register Definition
-//
-
-//MAC REG
-#define	ODM_BB_RESET					0x002
-#define	ODM_DUMMY						0x4fe
-#define	RF_T_METER_OLD				0x24
-#define	RF_T_METER_NEW				0x42
-
-#define	ODM_EDCA_VO_PARAM			0x500
-#define	ODM_EDCA_VI_PARAM			0x504
-#define	ODM_EDCA_BE_PARAM			0x508
-#define	ODM_EDCA_BK_PARAM			0x50C
-#define	ODM_TXPAUSE					0x522
-
-//BB REG
-#define	ODM_FPGA_PHY0_PAGE8			0x800
-#define	ODM_PSD_SETTING				0x808
-#define	ODM_AFE_SETTING				0x818
-#define	ODM_TXAGC_B_24_54			0x834
-#define	ODM_TXAGC_B_MCS32_5			0x838
-#define	ODM_TXAGC_B_MCS0_MCS3		0x83c
-#define	ODM_TXAGC_B_MCS4_MCS7		0x848
-#define	ODM_TXAGC_B_MCS8_MCS11		0x84c
-#define	ODM_ANALOG_REGISTER			0x85c
-#define	ODM_RF_INTERFACE_OUTPUT		0x860
-#define	ODM_TXAGC_B_MCS12_MCS15	0x868
-#define	ODM_TXAGC_B_11_A_2_11		0x86c
-#define	ODM_AD_DA_LSB_MASK			0x874
-#define	ODM_ENABLE_3_WIRE			0x88c
-#define	ODM_PSD_REPORT				0x8b4
-#define	ODM_R_ANT_SELECT				0x90c
-#define	ODM_CCK_ANT_SELECT			0xa07
-#define	ODM_CCK_PD_THRESH			0xa0a
-#define	ODM_CCK_RF_REG1				0xa11
-#define	ODM_CCK_MATCH_FILTER			0xa20
-#define	ODM_CCK_RAKE_MAC				0xa2e
-#define	ODM_CCK_CNT_RESET			0xa2d
-#define	ODM_CCK_TX_DIVERSITY			0xa2f
-#define	ODM_CCK_FA_CNT_MSB			0xa5b
-#define	ODM_CCK_FA_CNT_LSB			0xa5c
-#define	ODM_CCK_NEW_FUNCTION		0xa75
-#define	ODM_OFDM_PHY0_PAGE_C		0xc00
-#define	ODM_OFDM_RX_ANT				0xc04
-#define	ODM_R_A_RXIQI					0xc14
-#define	ODM_R_A_AGC_CORE1			0xc50
-#define	ODM_R_A_AGC_CORE2			0xc54
-#define	ODM_R_B_AGC_CORE1			0xc58
-#define	ODM_R_AGC_PAR					0xc70
-#define	ODM_R_HTSTF_AGC_PAR			0xc7c
-#define	ODM_TX_PWR_TRAINING_A		0xc90
-#define	ODM_TX_PWR_TRAINING_B		0xc98
-#define	ODM_OFDM_FA_CNT1				0xcf0
-#define	ODM_OFDM_PHY0_PAGE_D		0xd00
-#define	ODM_OFDM_FA_CNT2				0xda0
-#define	ODM_OFDM_FA_CNT3				0xda4
-#define	ODM_OFDM_FA_CNT4				0xda8
-#define	ODM_TXAGC_A_6_18				0xe00
-#define	ODM_TXAGC_A_24_54			0xe04
-#define	ODM_TXAGC_A_1_MCS32			0xe08
-#define	ODM_TXAGC_A_MCS0_MCS3		0xe10
-#define	ODM_TXAGC_A_MCS4_MCS7		0xe14
-#define	ODM_TXAGC_A_MCS8_MCS11		0xe18
-#define	ODM_TXAGC_A_MCS12_MCS15		0xe1c
-
-//RF REG
-#define	ODM_GAIN_SETTING				0x00
-#define	ODM_CHANNEL					0x18
-
-//Ant Detect Reg
-#define	ODM_DPDT						0x300
-
-//PSD Init
-#define	ODM_PSDREG					0x808
-
-//92D Path Div
-#define	PATHDIV_REG					0xB30
-#define	PATHDIV_TRI					0xBA0
-
-
-//
-// Bitmap Definition
-//
-
-#define	BIT_FA_RESET					BIT0
-
-
-
-#endif
-
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm.c
new file mode 100644
index 000000000000..13e5e28ec647
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm.c
@@ -0,0 +1,2397 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+
+const u2Byte dB_Invert_Table[8][12] = {
+	{	1,		1,		1,		2,		2,		2,		2,		3,		3,		3,		4,		4},
+	{	4,		5,		6,		6,		7,		8,		9,		10,		11,		13,		14,		16},
+	{	18,		20,		22,		25,		28,		32,		35,		40,		45,		50,		56,		63},
+	{	71,		79,		89,		100,	112,	126,	141,	158,	178,	200,	224,	251},
+	{	282,	316,	355,	398,	447,	501,	562,	631,	708,	794,	891,	1000},
+	{	1122,	1259,	1413,	1585,	1778,	1995,	2239,	2512,	2818,	3162,	3548,	3981},
+	{	4467,	5012,	5623,	6310,	7079,	7943,	8913,	10000,	11220,	12589,	14125,	15849},
+	{	17783,	19953,	22387,	25119,	28184,	31623,	35481,	39811,	44668,	50119,	56234,	65535}};
+
+
+//============================================================
+// Local Function predefine.
+//============================================================
+
+VOID
+odm_SwAntDetectInit(
+	IN 		PDM_ODM_T 		pDM_Odm
+	);
+
+
+
+
+
+VOID
+odm_AntennaDiversityInit(
+	IN 		PDM_ODM_T		pDM_Odm 
+);
+
+VOID
+odm_AntennaDiversity(
+	IN 		PDM_ODM_T		pDM_Odm 
+);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+ODM_UpdateInitRateWorkItemCallback(
+    IN PVOID            pContext
+    );
+#endif
+
+
+VOID
+odm_GlobalAdapterCheck(
+	IN		VOID
+	);
+
+//Remove RAMask by RS_James
+
+
+
+VOID
+odm_IQCalibrate(
+		IN	PDM_ODM_T	pDM_Odm 
+		);
+
+//remove PT by Yuchen
+
+//Remove Edca by Yu Chen
+
+
+VOID
+odm_UpdatePowerTrainingState(
+	IN	PDM_ODM_T	pDM_Odm
+);
+
+VOID
+ODM_AsocEntry_Init(
+	IN	PDM_ODM_T	pDM_Odm
+	);
+
+//============================================================
+//3 Export Interface
+//============================================================
+
+VOID
+ODM_InitMpDriverStatus(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+
+	// Decide when compile time
+	#if(MP_DRIVER == 1)
+	pDM_Odm->mp_mode = TRUE;
+	#else
+	pDM_Odm->mp_mode = FALSE;
+	#endif
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+
+	PADAPTER	Adapter =  pDM_Odm->Adapter;
+
+	// Update information every period
+	pDM_Odm->mp_mode = (BOOLEAN)Adapter->registrypriv.mp_mode;
+
+#else
+
+	// MP mode is always false at AP side
+	pDM_Odm->mp_mode = FALSE;
+
+#endif
+}
+
+VOID
+ODM_UpdateMpDriverStatus(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+
+	// Do nothing.
+
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	PADAPTER	Adapter =  pDM_Odm->Adapter;
+
+	// Update information erery period
+	pDM_Odm->mp_mode = (BOOLEAN)Adapter->registrypriv.mp_mode;
+
+#else
+
+	// Do nothing.
+
+#endif
+}
+
+VOID
+odm_CommonInfoSelfInit(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	pDM_Odm->bCckHighPower = (BOOLEAN) ODM_GetBBReg(pDM_Odm, ODM_REG(CCK_RPT_FORMAT,pDM_Odm), ODM_BIT(CCK_RPT_FORMAT,pDM_Odm));		
+	pDM_Odm->RFPathRxEnable = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(BB_RX_PATH,pDM_Odm), ODM_BIT(BB_RX_PATH,pDM_Odm));
+#if (DM_ODM_SUPPORT_TYPE != ODM_CE)	
+	pDM_Odm->pbNet_closed = &pDM_Odm->BOOLEAN_temp;
+#endif
+
+	PHYDM_InitDebugSetting(pDM_Odm);
+	ODM_InitMpDriverStatus(pDM_Odm);
+
+	pDM_Odm->TxRate = 0xFF;
+
+}
+
+VOID
+odm_CommonInfoSelfUpdate(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	u1Byte	EntryCnt=0;
+	u1Byte	i;
+	PSTA_INFO_T   	pEntry;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+	PADAPTER	Adapter =  pDM_Odm->Adapter;
+	PMGNT_INFO	pMgntInfo = &Adapter->MgntInfo;
+
+	pEntry = pDM_Odm->pODM_StaInfo[0];
+	if(pMgntInfo->mAssoc)
+	{
+		pEntry->bUsed=TRUE;
+		for (i=0; i<6; i++)
+			pEntry->MacAddr[i] = pMgntInfo->Bssid[i];
+	}
+	else
+	{
+		pEntry->bUsed=FALSE;
+		for (i=0; i<6; i++)
+			pEntry->MacAddr[i] = 0;
+	}
+
+	//STA mode is linked to AP
+	if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[0]) && !ACTING_AS_AP(Adapter))
+		pDM_Odm->bsta_state = TRUE;
+	else
+		pDM_Odm->bsta_state = FALSE;
+#endif
+
+
+	if(*(pDM_Odm->pBandWidth) == ODM_BW40M)
+	{
+		if(*(pDM_Odm->pSecChOffset) == 1)
+			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) -2;
+		else if(*(pDM_Odm->pSecChOffset) == 2)
+			pDM_Odm->ControlChannel = *(pDM_Odm->pChannel) +2;
+	}
+	else
+		pDM_Odm->ControlChannel = *(pDM_Odm->pChannel);
+
+	for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+		pEntry = pDM_Odm->pODM_StaInfo[i];
+		if(IS_STA_VALID(pEntry))
+			EntryCnt++;
+	}
+	
+	if(EntryCnt == 1)
+		pDM_Odm->bOneEntryOnly = TRUE;
+	else
+		pDM_Odm->bOneEntryOnly = FALSE;
+
+	// Update MP driver status
+	ODM_UpdateMpDriverStatus(pDM_Odm);
+}
+
+VOID
+odm_CommonInfoSelfReset(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	pDM_Odm->PhyDbgInfo.NumQryBeaconPkt = 0;
+#endif
+}
+
+PVOID
+PhyDM_Get_Structure(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			Structure_Type
+)
+
+{
+	PVOID	pStruct = NULL;
+#if RTL8195A_SUPPORT
+	switch (Structure_Type){
+		case	PHYDM_FALSEALMCNT:
+			pStruct = &FalseAlmCnt;
+		break;
+		
+		case	PHYDM_CFOTRACK:
+			pStruct = &DM_CfoTrack;
+		break;
+		
+		default:
+		break;
+	}
+
+#else
+	switch (Structure_Type){
+		case	PHYDM_FALSEALMCNT:
+			pStruct = &(pDM_Odm->FalseAlmCnt);
+		break;
+		
+		case	PHYDM_CFOTRACK:
+			pStruct = &(pDM_Odm->DM_CfoTrack);
+		break;
+		
+		default:
+		break;
+	}
+
+#endif
+	return	pStruct;
+}
+
+VOID
+odm_HWSetting(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+#if (RTL8821A_SUPPORT == 1)
+	if(pDM_Odm->SupportICType & ODM_RTL8821)
+		odm_HWSetting_8821A(pDM_Odm);
+#endif
+
+}
+
+//
+// 2011/09/21 MH Add to describe different team necessary resource allocate??
+//
+VOID
+ODM_DMInit(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+
+	odm_CommonInfoSelfInit(pDM_Odm);
+	odm_DIGInit(pDM_Odm);
+	Phydm_NHMCounterStatisticsInit(pDM_Odm);
+	Phydm_AdaptivityInit(pDM_Odm);
+	odm_RateAdaptiveMaskInit(pDM_Odm);
+	ODM_CfoTrackingInit(pDM_Odm);
+	ODM_EdcaTurboInit(pDM_Odm);
+	odm_RSSIMonitorInit(pDM_Odm);
+	odm_TXPowerTrackingInit(pDM_Odm);
+	odm_AntennaDiversityInit(pDM_Odm);
+	odm_AutoChannelSelectInit(pDM_Odm);
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	ODM_ClearTxPowerTrackingState(pDM_Odm);
+	odm_PathDiversityInit(pDM_Odm);
+#endif
+
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+		odm_DynamicBBPowerSavingInit(pDM_Odm);
+		odm_DynamicTxPowerInit(pDM_Odm);
+
+#if (RTL8188E_SUPPORT == 1)
+		if(pDM_Odm->SupportICType==ODM_RTL8188E)
+		{
+			odm_PrimaryCCA_Init(pDM_Odm);
+			ODM_RAInfo_Init_all(pDM_Odm);
+		}
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	
+	#if (RTL8723B_SUPPORT == 1)
+		if(pDM_Odm->SupportICType == ODM_RTL8723B)
+			odm_SwAntDetectInit(pDM_Odm);
+	#endif
+
+	#if (RTL8192E_SUPPORT == 1)
+		if(pDM_Odm->SupportICType==ODM_RTL8192E)
+			odm_PrimaryCCA_Check_Init(pDM_Odm);
+	#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#if (RTL8723A_SUPPORT == 1)
+		if(pDM_Odm->SupportICType == ODM_RTL8723A)
+			odm_PSDMonitorInit(pDM_Odm);
+	#endif
+
+	#if (RTL8192D_SUPPORT == 1)
+		if(pDM_Odm->SupportICType==ODM_RTL8192D)
+			odm_PathDivInit_92D(pDM_Odm);
+	#endif
+
+	#if ((RTL8192C_SUPPORT == 1) || (RTL8192D_SUPPORT == 1))
+		if(pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8192D))
+			odm_RXHPInit(pDM_Odm);
+	#endif
+#endif
+#endif
+
+	}
+
+}
+
+VOID
+ODM_DMReset(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+        #if (defined(CONFIG_HW_ANTENNA_DIVERSITY))
+	ODM_AntDivReset(pDM_Odm);
+        #endif
+}
+
+//
+// 2011/09/20 MH This is the entry pointer for all team to execute HW out source DM.
+// You can not add any dummy function here, be care, you can only use DM structure
+// to perform any new ODM_DM.
+//
+VOID
+ODM_DMWatchdog(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	ODM_AsocEntry_Init(pDM_Odm);
+	odm_CommonInfoSelfUpdate(pDM_Odm);
+	phydm_BasicDbgMessage(pDM_Odm);
+	odm_HWSetting(pDM_Odm);
+	odm_FalseAlarmCounterStatistics(pDM_Odm);
+	odm_RSSIMonitorCheck(pDM_Odm);
+
+	if(*(pDM_Odm->pbPowerSaving) == TRUE)
+	{
+		odm_DIGbyRSSI_LPS(pDM_Odm);
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("DMWatchdog in power saving mode\n"));
+		return;
+	}
+	
+	Phydm_CheckAdaptivity(pDM_Odm);
+	odm_UpdatePowerTrainingState(pDM_Odm);
+	odm_DIG(pDM_Odm);
+	{
+		pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
+		pDM_Odm->bAdaOn = Phydm_Adaptivity(pDM_Odm, pDM_DigTable->CurIGValue);
+	}
+	odm_CCKPacketDetectionThresh(pDM_Odm);
+	odm_RefreshRateAdaptiveMask(pDM_Odm);
+	odm_RefreshBasicRateMask(pDM_Odm);
+	odm_DynamicBBPowerSaving(pDM_Odm);
+	odm_EdcaTurboCheck(pDM_Odm);
+	odm_PathDiversity(pDM_Odm);
+	ODM_CfoTracking(pDM_Odm);
+	odm_DynamicTxPower(pDM_Odm);
+	odm_AntennaDiversity(pDM_Odm);
+
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+
+	ODM_TXPowerTrackingCheck(pDM_Odm);
+
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+		odm_IQCalibrate(pDM_Odm);
+	else 
+#endif
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+#if (RTL8192D_SUPPORT == 1)
+	        if(pDM_Odm->SupportICType==ODM_RTL8192D)
+			ODM_DynamicEarlyMode(pDM_Odm);
+#endif
+	        
+#if (RTL8188E_SUPPORT == 1)
+	        if(pDM_Odm->SupportICType==ODM_RTL8188E)
+	                odm_DynamicPrimaryCCA(pDM_Odm);	
+#endif
+
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+
+	#if (RTL8192E_SUPPORT == 1)
+		if(pDM_Odm->SupportICType==ODM_RTL8192E)
+			odm_DynamicPrimaryCCA_Check(pDM_Odm); 
+	#endif
+
+#if( DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#if ((RTL8192C_SUPPORT == 1) || (RTL8192D_SUPPORT == 1))
+		if(pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8192D))
+			odm_RXHP(pDM_Odm);
+	#endif
+#endif
+#endif
+	}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	odm_dtc(pDM_Odm);
+#endif
+
+	odm_CommonInfoSelfReset(pDM_Odm);
+	
+}
+
+
+//
+// Init /.. Fixed HW value. Only init time.
+//
+VOID
+ODM_CmnInfoInit(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		ODM_CMNINFO_E	CmnInfo,
+	IN		u4Byte			Value	
+	)
+{
+	//
+	// This section is used for init value
+	//
+	switch	(CmnInfo)
+	{
+		//
+		// Fixed ODM value.
+		//
+		case	ODM_CMNINFO_ABILITY:
+			pDM_Odm->SupportAbility = (u4Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_RF_TYPE:
+			pDM_Odm->RFType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_PLATFORM:
+			pDM_Odm->SupportPlatform = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_INTERFACE:
+			pDM_Odm->SupportInterface = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_MP_TEST_CHIP:
+			pDM_Odm->bIsMPChip= (u1Byte)Value;
+			break;
+            
+		case	ODM_CMNINFO_IC_TYPE:
+			pDM_Odm->SupportICType = Value;
+			break;
+
+		case	ODM_CMNINFO_CUT_VER:
+			pDM_Odm->CutVersion = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_FAB_VER:
+			pDM_Odm->FabVersion = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_RFE_TYPE:
+			pDM_Odm->RFEType = (u1Byte)Value;
+			break;
+
+		case    ODM_CMNINFO_RF_ANTENNA_TYPE:
+			pDM_Odm->AntDivType= (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_BOARD_TYPE:
+			pDM_Odm->BoardType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_PACKAGE_TYPE:
+			pDM_Odm->PackageType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_EXT_LNA:
+			pDM_Odm->ExtLNA = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_5G_EXT_LNA:
+			pDM_Odm->ExtLNA5G = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_EXT_PA:
+			pDM_Odm->ExtPA = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_5G_EXT_PA:
+			pDM_Odm->ExtPA5G = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_GPA:
+			pDM_Odm->TypeGPA= (ODM_TYPE_GPA_E)Value;
+			break;
+		case	ODM_CMNINFO_APA:
+			pDM_Odm->TypeAPA= (ODM_TYPE_APA_E)Value;
+			break;
+		case	ODM_CMNINFO_GLNA:
+			pDM_Odm->TypeGLNA= (ODM_TYPE_GLNA_E)Value;
+			break;
+		case	ODM_CMNINFO_ALNA:
+			pDM_Odm->TypeALNA= (ODM_TYPE_ALNA_E)Value;
+			break;
+
+		case	ODM_CMNINFO_EXT_TRSW:
+			pDM_Odm->ExtTRSW = (u1Byte)Value;
+			break;
+		case 	ODM_CMNINFO_PATCH_ID:
+			pDM_Odm->PatchID = (u1Byte)Value;
+			break;
+		case 	ODM_CMNINFO_BINHCT_TEST:
+			pDM_Odm->bInHctTest = (BOOLEAN)Value;
+			break;
+		case 	ODM_CMNINFO_BWIFI_TEST:
+			pDM_Odm->bWIFITest = (BOOLEAN)Value;
+			break;	
+		case	ODM_CMNINFO_SMART_CONCURRENT:
+			pDM_Odm->bDualMacSmartConcurrent = (BOOLEAN )Value;
+			break;
+		case	ODM_CMNINFO_DOMAIN_CODE_2G:
+			pDM_Odm->odm_Regulation2_4G = (u1Byte)Value;
+			break;
+		case	ODM_CMNINFO_DOMAIN_CODE_5G:
+			pDM_Odm->odm_Regulation5G = (u1Byte)Value;
+			break;
+		case	ODM_CMNINFO_IQKFWOFFLOAD:
+			pDM_Odm->IQKFWOffload = (u1Byte)Value;
+			break;
+		//To remove the compiler warning, must add an empty default statement to handle the other values.	
+		default:
+			//do nothing
+			break;	
+		
+	}
+
+}
+
+
+VOID
+ODM_CmnInfoHook(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		ODM_CMNINFO_E	CmnInfo,
+	IN		PVOID			pValue	
+	)
+{
+	//
+	// Hook call by reference pointer.
+	//
+	switch	(CmnInfo)
+	{
+		//
+		// Dynamic call by reference pointer.
+		//
+		case	ODM_CMNINFO_MAC_PHY_MODE:
+			pDM_Odm->pMacPhyMode = (u1Byte *)pValue;
+			break;
+		
+		case	ODM_CMNINFO_TX_UNI:
+			pDM_Odm->pNumTxBytesUnicast = (u8Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_RX_UNI:
+			pDM_Odm->pNumRxBytesUnicast = (u8Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_WM_MODE:
+			pDM_Odm->pWirelessMode = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_BAND:
+			pDM_Odm->pBandType = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_SEC_CHNL_OFFSET:
+			pDM_Odm->pSecChOffset = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_SEC_MODE:
+			pDM_Odm->pSecurity = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_BW:
+			pDM_Odm->pBandWidth = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_CHNL:
+			pDM_Odm->pChannel = (u1Byte *)pValue;
+			break;
+		
+		case	ODM_CMNINFO_DMSP_GET_VALUE:
+			pDM_Odm->pbGetValueFromOtherMac = (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_BUDDY_ADAPTOR:
+			pDM_Odm->pBuddyAdapter = (PADAPTER *)pValue;
+			break;
+
+		case	ODM_CMNINFO_DMSP_IS_MASTER:
+			pDM_Odm->pbMasterOfDMSP = (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_SCAN:
+			pDM_Odm->pbScanInProcess = (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_POWER_SAVING:
+			pDM_Odm->pbPowerSaving = (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_ONE_PATH_CCA:
+			pDM_Odm->pOnePathCCA = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_DRV_STOP:
+			pDM_Odm->pbDriverStopped =  (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_PNP_IN:
+			pDM_Odm->pbDriverIsGoingToPnpSetPowerSleep =  (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_INIT_ON:
+			pDM_Odm->pinit_adpt_in_progress =  (BOOLEAN *)pValue;
+			break;
+
+		case	ODM_CMNINFO_ANT_TEST:
+			pDM_Odm->pAntennaTest =  (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_NET_CLOSED:
+			pDM_Odm->pbNet_closed = (BOOLEAN *)pValue;
+			break;
+
+		case 	ODM_CMNINFO_FORCED_RATE:
+			pDM_Odm->pForcedDataRate = (pu2Byte)pValue;
+			break;
+
+		case  ODM_CMNINFO_FORCED_IGI_LB:
+			pDM_Odm->pu1ForcedIgiLb = (u1Byte *)pValue;
+			break;
+
+		case	ODM_CMNINFO_P2P_LINK:
+			pDM_Odm->DM_DigTable.pbP2pLinkInProgress = (u1Byte *)pValue;
+			break;
+
+		case ODM_CMNINFO_FCS_MODE:
+			pDM_Odm->pIsFcsModeEnable = (BOOLEAN *)pValue;
+			break;
+//sd7 only
+
+		//case	ODM_CMNINFO_RTSTA_AID:
+		//	pDM_Odm->pAidMap =  (u1Byte *)pValue;
+		//	break;
+
+		//case	ODM_CMNINFO_BT_COEXIST:
+		//	pDM_Odm->BTCoexist = (BOOLEAN *)pValue;		
+
+		//case	ODM_CMNINFO_STA_STATUS:
+			//pDM_Odm->pODM_StaInfo[] = (PSTA_INFO_T)pValue;
+			//break;
+
+		//case	ODM_CMNINFO_PHY_STATUS:
+		//	pDM_Odm->pPhyInfo = (ODM_PHY_INFO *)pValue;
+		//	break;
+
+		//case	ODM_CMNINFO_MAC_STATUS:
+		//	pDM_Odm->pMacInfo = (ODM_MAC_INFO *)pValue;
+		//	break;
+		//To remove the compiler warning, must add an empty default statement to handle the other values.				
+		default:
+			//do nothing
+			break;
+
+	}
+
+}
+
+
+VOID
+ODM_CmnInfoPtrArrayHook(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		ODM_CMNINFO_E	CmnInfo,
+	IN		u2Byte			Index,
+	IN		PVOID			pValue	
+	)
+{
+	//
+	// Hook call by reference pointer.
+	//
+	switch	(CmnInfo)
+	{
+		//
+		// Dynamic call by reference pointer.
+		//		
+		case	ODM_CMNINFO_STA_STATUS:
+			pDM_Odm->pODM_StaInfo[Index] = (PSTA_INFO_T)pValue;
+			break;		
+		//To remove the compiler warning, must add an empty default statement to handle the other values.				
+		default:
+			//do nothing
+			break;
+	}
+	
+}
+
+
+//
+// Update Band/CHannel/.. The values are dynamic but non-per-packet.
+//
+VOID
+ODM_CmnInfoUpdate(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u4Byte			CmnInfo,
+	IN		u8Byte			Value	
+	)
+{
+	//
+	// This init variable may be changed in run time.
+	//
+	switch	(CmnInfo)
+	{
+		case ODM_CMNINFO_LINK_IN_PROGRESS:
+			pDM_Odm->bLinkInProcess = (BOOLEAN)Value;
+			break;
+		
+		case	ODM_CMNINFO_ABILITY:
+			pDM_Odm->SupportAbility = (u4Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_RF_TYPE:
+			pDM_Odm->RFType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_WIFI_DIRECT:
+			pDM_Odm->bWIFI_Direct = (BOOLEAN)Value;
+			break;
+
+		case	ODM_CMNINFO_WIFI_DISPLAY:
+			pDM_Odm->bWIFI_Display = (BOOLEAN)Value;
+			break;
+
+		case	ODM_CMNINFO_LINK:
+			pDM_Odm->bLinked = (BOOLEAN)Value;
+			break;
+			
+		case	ODM_CMNINFO_STATION_STATE:
+			pDM_Odm->bsta_state = (BOOLEAN)Value;
+			break;
+			
+		case	ODM_CMNINFO_RSSI_MIN:
+			pDM_Odm->RSSI_Min= (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_DBG_COMP:
+			pDM_Odm->DebugComponents = Value;
+			break;
+
+		case	ODM_CMNINFO_DBG_LEVEL:
+			pDM_Odm->DebugLevel = (u4Byte)Value;
+			break;
+		case	ODM_CMNINFO_RA_THRESHOLD_HIGH:
+			pDM_Odm->RateAdaptive.HighRSSIThresh = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_RA_THRESHOLD_LOW:
+			pDM_Odm->RateAdaptive.LowRSSIThresh = (u1Byte)Value;
+			break;
+		// The following is for BT HS mode and BT coexist mechanism.
+		case ODM_CMNINFO_BT_ENABLED:
+			pDM_Odm->bBtEnabled = (BOOLEAN)Value;
+			break;
+			
+		case ODM_CMNINFO_BT_HS_CONNECT_PROCESS:
+			pDM_Odm->bBtConnectProcess = (BOOLEAN)Value;
+			break;
+		
+		case ODM_CMNINFO_BT_HS_RSSI:
+			pDM_Odm->btHsRssi = (u1Byte)Value;
+			break;
+			
+		case	ODM_CMNINFO_BT_OPERATION:
+			pDM_Odm->bBtHsOperation = (BOOLEAN)Value;
+			break;
+
+		case	ODM_CMNINFO_BT_LIMITED_DIG:
+			pDM_Odm->bBtLimitedDig = (BOOLEAN)Value;
+			break;	
+
+		case	ODM_CMNINFO_BT_DISABLE_EDCA:
+			pDM_Odm->bBtDisableEdcaTurbo = (BOOLEAN)Value;
+			break;
+
+
+#if(DM_ODM_SUPPORT_TYPE & ODM_AP)		// for repeater mode add by YuChen 2014.06.23
+#ifdef UNIVERSAL_REPEATER
+		case	ODM_CMNINFO_VXD_LINK:
+			pDM_Odm->VXD_bLinked= (BOOLEAN)Value;
+			break;
+#endif
+#endif
+/*
+		case	ODM_CMNINFO_OP_MODE:
+			pDM_Odm->OPMode = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_WM_MODE:
+			pDM_Odm->WirelessMode = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_BAND:
+			pDM_Odm->BandType = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_SEC_CHNL_OFFSET:
+			pDM_Odm->SecChOffset = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_SEC_MODE:
+			pDM_Odm->Security = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_BW:
+			pDM_Odm->BandWidth = (u1Byte)Value;
+			break;
+
+		case	ODM_CMNINFO_CHNL:
+			pDM_Odm->Channel = (u1Byte)Value;
+			break;			
+*/	
+                default:
+			//do nothing
+			break;
+	}
+
+	
+}
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+ODM_InitAllWorkItems(IN PDM_ODM_T	pDM_Odm )
+{
+#if USE_WORKITEM
+	PADAPTER		pAdapter = pDM_Odm->Adapter;
+
+	ODM_InitializeWorkItem(	pDM_Odm, 
+							&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem_8723B, 
+							(RT_WORKITEM_CALL_BACK)ODM_SW_AntDiv_WorkitemCallback,
+							(PVOID)pAdapter,
+							"AntennaSwitchWorkitem");
+	
+	ODM_InitializeWorkItem(	pDM_Odm, 
+							&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem, 
+							(RT_WORKITEM_CALL_BACK)odm_SwAntDivChkAntSwitchWorkitemCallback,
+							(PVOID)pAdapter,
+							"AntennaSwitchWorkitem");
+	
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->PathDivSwitchWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_PathDivChkAntSwitchWorkitemCallback, 
+		(PVOID)pAdapter,
+		"SWAS_WorkItem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->CCKPathDiversityWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_CCKTXPathDiversityWorkItemCallback, 
+		(PVOID)pAdapter,
+		"CCKTXPathDiversityWorkItem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->MPT_DIGWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_MPT_DIGWorkItemCallback, 
+		(PVOID)pAdapter,
+		"MPT_DIGWorkitem");
+
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->RaRptWorkitem), 
+		(RT_WORKITEM_CALL_BACK)ODM_UpdateInitRateWorkItemCallback, 
+		(PVOID)pAdapter,
+		"RaRptWorkitem");
+	
+#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
+#if (RTL8188E_SUPPORT == 1)
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->FastAntTrainingWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_FastAntTrainingWorkItemCallback, 
+		(PVOID)pAdapter,
+		"FastAntTrainingWorkitem");
+#endif
+#endif
+	ODM_InitializeWorkItem(
+		pDM_Odm,
+		&(pDM_Odm->DM_RXHP_Table.PSDTimeWorkitem), 
+		(RT_WORKITEM_CALL_BACK)odm_PSD_RXHPWorkitemCallback, 
+		(PVOID)pAdapter,
+		"PSDRXHP_WorkItem");  
+#endif
+}
+
+VOID
+ODM_FreeAllWorkItems(IN PDM_ODM_T	pDM_Odm )
+{
+#if USE_WORKITEM
+	ODM_FreeWorkItem(	&(pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem_8723B));
+	
+	ODM_FreeWorkItem(	&(pDM_Odm->DM_SWAT_Table.SwAntennaSwitchWorkitem));
+
+	ODM_FreeWorkItem(&(pDM_Odm->PathDivSwitchWorkitem));      
+
+	ODM_FreeWorkItem(&(pDM_Odm->CCKPathDiversityWorkitem));
+	
+	ODM_FreeWorkItem(&(pDM_Odm->FastAntTrainingWorkitem));
+
+	ODM_FreeWorkItem(&(pDM_Odm->MPT_DIGWorkitem));
+
+	ODM_FreeWorkItem(&(pDM_Odm->RaRptWorkitem));
+
+	ODM_FreeWorkItem((&pDM_Odm->DM_RXHP_Table.PSDTimeWorkitem));
+#endif
+
+}
+#endif
+
+/*
+VOID
+odm_FindMinimumRSSI(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	u4Byte	i;
+	u1Byte	RSSI_Min = 0xFF;
+
+	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+//		if(pDM_Odm->pODM_StaInfo[i] != NULL)
+		if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[i]) )
+		{
+			if(pDM_Odm->pODM_StaInfo[i]->RSSI_Ave < RSSI_Min)
+			{
+				RSSI_Min = pDM_Odm->pODM_StaInfo[i]->RSSI_Ave;
+			}
+		}
+	}
+
+	pDM_Odm->RSSI_Min = RSSI_Min;
+
+}
+
+VOID
+odm_IsLinked(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	u4Byte i;
+	BOOLEAN Linked = FALSE;
+	
+	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+			if(IS_STA_VALID(pDM_Odm->pODM_StaInfo[i]) )
+			{			
+				Linked = TRUE;
+				break;
+			}
+		
+	}
+
+	pDM_Odm->bLinked = Linked;
+}
+*/
+
+
+//3============================================================
+//3 DIG
+//3============================================================
+/*-----------------------------------------------------------------------------
+ * Function:	odm_DIGInit()
+ *
+ * Overview:	Set DIG scheme init value.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *
+ *---------------------------------------------------------------------------*/
+
+//Remove DIG by yuchen
+
+//Remove DIG and FA check by Yu Chen
+
+
+//3============================================================
+//3 BB Power Save
+//3============================================================
+
+//Remove BB power saving by Yuchen
+
+//3============================================================
+//3 RATR MASK
+//3============================================================
+//3============================================================
+//3 Rate Adaptive
+//3============================================================
+
+//Remove RAMask by RS_James
+
+//3============================================================
+//3 Dynamic Tx Power
+//3============================================================
+
+//Remove BY YuChen
+
+//Remove  Rssimonitorcheck related function to odm_rssimonitorcheck.c 
+
+
+VOID
+ODM_InitAllTimers(
+	IN PDM_ODM_T	pDM_Odm 
+	)
+{
+#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
+	ODM_AntDivTimers(pDM_Odm,INIT_ANTDIV_TIMMER);
+#elif(defined(CONFIG_SW_ANTENNA_DIVERSITY))
+	ODM_InitializeTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer,
+		(RT_TIMER_CALL_BACK)odm_SwAntDivChkAntSwitchCallback, NULL, "SwAntennaSwitchTimer");
+#endif
+	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PSDTimer, 
+		(RT_TIMER_CALL_BACK)dm_PSDMonitorCallback, NULL, "PSDTimer");
+	//
+	//Path Diversity
+	//Neil Chen--2011--06--16--  / 2012/02/23 MH Revise Arch.
+	//
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 
+		(RT_TIMER_CALL_BACK)odm_PathDivChkAntSwitchCallback, NULL, "PathDivTimer");
+
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, 
+		(RT_TIMER_CALL_BACK)odm_CCKTXPathDiversityCallback, NULL, "CCKPathDiversityTimer");
+
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 
+		(RT_TIMER_CALL_BACK)odm_MPT_DIGCallback, NULL, "MPT_DIGTimer");
+
+	ODM_InitializeTimer(pDM_Odm, &pDM_Odm->DM_RXHP_Table.PSDTimer,
+		(RT_TIMER_CALL_BACK)odm_PSD_RXHPCallback, NULL, "PSDRXHPTimer");  
+#endif	
+}
+
+VOID
+ODM_CancelAllTimers(
+	IN PDM_ODM_T	pDM_Odm 
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	//
+	// 2012/01/12 MH Temp BSOD fix. We need to find NIC allocate mem fail reason in 
+	// win7 platform.
+	//
+	HAL_ADAPTER_STS_CHK(pDM_Odm)
+#endif	
+
+#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
+	ODM_AntDivTimers(pDM_Odm,CANCEL_ANTDIV_TIMMER);
+#elif(defined(CONFIG_SW_ANTENNA_DIVERSITY))
+	ODM_CancelTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->PSDTimer);	
+	//
+	//Path Diversity
+	//Neil Chen--2011--06--16--  / 2012/02/23 MH Revise Arch.
+	//
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer);
+
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer);
+
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
+
+	ODM_CancelTimer(pDM_Odm, &pDM_Odm->DM_RXHP_Table.PSDTimer);
+#endif	
+}
+
+
+VOID
+ODM_ReleaseAllTimers(
+	IN PDM_ODM_T	pDM_Odm 
+	)
+{
+#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
+	ODM_AntDivTimers(pDM_Odm,RELEASE_ANTDIV_TIMMER);
+#elif(defined(CONFIG_SW_ANTENNA_DIVERSITY))
+	ODM_ReleaseTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->PSDTimer);
+	//
+	//Path Diversity
+	//Neil Chen--2011--06--16--  / 2012/02/23 MH Revise Arch.
+	//
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->PathDivSwitchTimer);
+
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->CCKPathDiversityTimer);
+
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer);
+
+	ODM_ReleaseTimer(pDM_Odm, &pDM_Odm->DM_RXHP_Table.PSDTimer); 
+#endif	
+}
+
+
+//3============================================================
+//3 Tx Power Tracking
+//3============================================================
+
+VOID
+odm_IQCalibrate(
+		IN	PDM_ODM_T	pDM_Odm 
+		)
+{
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+#if( DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	if(*pDM_Odm->pIsFcsModeEnable)
+		return;
+#endif
+
+	if(!IS_HARDWARE_TYPE_JAGUAR(Adapter))
+		return;
+	else if(IS_HARDWARE_TYPE_8812AU(Adapter))
+		return;
+#if (RTL8821A_SUPPORT == 1)
+	if(pDM_Odm->bLinked)
+	{
+		if((*pDM_Odm->pChannel != pDM_Odm->preChannel) && (!*pDM_Odm->pbScanInProcess))
+		{
+			pDM_Odm->preChannel = *pDM_Odm->pChannel;
+			pDM_Odm->LinkedInterval = 0;
+		}
+
+		if(pDM_Odm->LinkedInterval < 3)
+			pDM_Odm->LinkedInterval++;
+		
+		if(pDM_Odm->LinkedInterval == 2)
+		{
+			// Mark out IQK flow to prevent tx stuck. by Maddest 20130306
+			// Open it verified by James 20130715
+			PHY_IQCalibrate_8821A(pDM_Odm, FALSE);
+		}
+	}
+	else
+		pDM_Odm->LinkedInterval = 0;
+#endif
+}
+
+
+
+//antenna mapping info
+// 1: right-side antenna
+// 2/0: left-side antenna
+//PDM_SWAT_Table->CCK_Ant1_Cnt /OFDM_Ant1_Cnt:  for right-side antenna:   Ant:1    RxDefaultAnt1
+//PDM_SWAT_Table->CCK_Ant2_Cnt /OFDM_Ant2_Cnt:  for left-side antenna:     Ant:0    RxDefaultAnt2
+// We select left antenna as default antenna in initial process, modify it as needed
+//
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+// Only for 8723A SW ANT DIV INIT--2012--07--17
+VOID
+odm_SwAntDivInit_NIC_8723A(
+	IN	PDM_ODM_T		pDM_Odm)
+{
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	
+	u1Byte 			btAntNum=BT_GetPgAntNum(Adapter);
+
+	if(IS_HARDWARE_TYPE_8723A(Adapter))
+	{
+		pDM_SWAT_Table->ANTA_ON =TRUE;
+		
+		// Set default antenna B status by PG
+		if(btAntNum == 2)
+			pDM_SWAT_Table->ANTB_ON = TRUE;
+		else if(btAntNum == 1)
+			pDM_SWAT_Table->ANTB_ON = FALSE;
+		else
+			pDM_SWAT_Table->ANTB_ON = TRUE;
+	}	
+	
+}
+
+#endif //end #ifMP
+
+
+
+//3============================================================
+//3 SW Antenna Diversity
+//3============================================================
+
+VOID
+odm_AntennaDiversityInit(
+	IN 		PDM_ODM_T		pDM_Odm 
+)
+{
+	if(pDM_Odm->mp_mode == TRUE)
+		return;
+
+	if(pDM_Odm->SupportICType & (ODM_OLD_IC_ANTDIV_SUPPORT))
+	{
+		#if (RTL8192C_SUPPORT==1) 
+		ODM_OldIC_AntDiv_Init(pDM_Odm);
+		#endif
+	}
+	else
+	{
+		#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
+		ODM_AntDiv_Config(pDM_Odm);
+		ODM_AntDivInit(pDM_Odm);
+		#endif
+	}
+}
+
+VOID
+odm_AntennaDiversity(
+	IN 		PDM_ODM_T		pDM_Odm 
+)
+{
+	if(pDM_Odm->mp_mode == TRUE)
+		return;
+
+	if(pDM_Odm->SupportICType & (ODM_OLD_IC_ANTDIV_SUPPORT))
+	{
+		#if (RTL8192C_SUPPORT==1) 
+		ODM_OldIC_AntDiv(pDM_Odm);
+		#endif
+	}
+	else
+	{
+		#if(defined(CONFIG_HW_ANTENNA_DIVERSITY))
+		ODM_AntDiv(pDM_Odm);
+		#endif
+	}
+}
+
+
+void
+odm_SwAntDetectInit(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+#if (RTL8723B_SUPPORT == 1)
+	pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c = ODM_Read4Byte(pDM_Odm, rDPDT_control);
+#endif
+	pDM_SWAT_Table->PreAntenna = MAIN_ANT;
+	pDM_SWAT_Table->CurAntenna = MAIN_ANT;
+	pDM_SWAT_Table->SWAS_NoLink_State = 0;
+}
+
+
+//============================================================
+//EDCA Turbo
+//============================================================
+
+//Remove Edca by Yuchen
+
+
+#if( DM_ODM_SUPPORT_TYPE == ODM_WIN) 
+//
+// 2011/07/26 MH Add an API for testing IQK fail case.
+//
+BOOLEAN
+ODM_CheckPowerStatus(
+	IN	PADAPTER		Adapter)
+{
+
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
+	RT_RF_POWER_STATE 	rtState;
+	PMGNT_INFO			pMgntInfo	= &(Adapter->MgntInfo);
+
+	// 2011/07/27 MH We are not testing ready~~!! We may fail to get correct value when init sequence.
+	if (pMgntInfo->init_adpt_in_progress == TRUE)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return TRUE, due to initadapter"));
+		return	TRUE;
+	}
+	
+	//
+	//	2011/07/19 MH We can not execute tx pwoer tracking/ LLC calibrate or IQK.
+	//
+	Adapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (pu1Byte)(&rtState));	
+	if(Adapter->bDriverStopped || Adapter->bDriverIsGoingToPnpSetPowerSleep || rtState == eRfOff)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("ODM_CheckPowerStatus Return FALSE, due to %d/%d/%d\n", 
+		Adapter->bDriverStopped, Adapter->bDriverIsGoingToPnpSetPowerSleep, rtState));
+		return	FALSE;
+	}
+	return	TRUE;
+}
+#endif
+
+// need to ODM CE Platform
+//move to here for ANT detection mechanism using
+
+#if ((DM_ODM_SUPPORT_TYPE == ODM_WIN)||(DM_ODM_SUPPORT_TYPE == ODM_CE))
+u4Byte
+GetPSDData(
+	IN PDM_ODM_T	pDM_Odm,
+	unsigned int 	point,
+	u1Byte initial_gain_psd)
+{
+	//unsigned int	val, rfval;
+	//int	psd_report;
+	u4Byte	psd_report;
+	
+	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	//Debug Message
+	//val = PHY_QueryBBReg(Adapter,0x908, bMaskDWord);
+	//DbgPrint("Reg908 = 0x%x\n",val);
+	//val = PHY_QueryBBReg(Adapter,0xDF4, bMaskDWord);
+	//rfval = PHY_QueryRFReg(Adapter, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask);
+	//DbgPrint("RegDF4 = 0x%x, RFReg00 = 0x%x\n",val, rfval);
+	//DbgPrint("PHYTXON = %x, OFDMCCA_PP = %x, CCKCCA_PP = %x, RFReg00 = %x\n",
+		//(val&BIT25)>>25, (val&BIT14)>>14, (val&BIT15)>>15, rfval);
+
+	//Set DCO frequency index, offset=(40MHz/SamplePts)*point
+	ODM_SetBBReg(pDM_Odm, 0x808, 0x3FF, point);
+
+	//Start PSD calculation, Reg808[22]=0->1
+	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 1);
+	//Need to wait for HW PSD report
+	ODM_StallExecution(1000);
+	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 0);
+	//Read PSD report, Reg8B4[15:0]
+	psd_report = ODM_GetBBReg(pDM_Odm,0x8B4, bMaskDWord) & 0x0000FFFF;
+	
+#if 1//(DEV_BUS_TYPE == RT_PCI_INTERFACE) && ( (RT_PLATFORM == PLATFORM_LINUX) || (RT_PLATFORM == PLATFORM_MACOSX))
+	psd_report = (u4Byte) (ConvertTo_dB(psd_report))+(u4Byte)(initial_gain_psd-0x1c);
+#else
+	psd_report = (int) (20*log10((double)psd_report))+(int)(initial_gain_psd-0x1c);
+#endif
+
+	return psd_report;
+	
+}
+
+u4Byte 
+ConvertTo_dB(
+	u4Byte 	Value)
+{
+	u1Byte i;
+	u1Byte j;
+	u4Byte dB;
+
+	Value = Value & 0xFFFF;
+	
+	for (i=0;i<8;i++)
+	{
+		if (Value <= dB_Invert_Table[i][11])
+		{
+			break;
+		}
+	}
+
+	if (i >= 8)
+	{
+		return (96);	// maximum 96 dB
+	}
+
+	for (j=0;j<12;j++)
+	{
+		if (Value <= dB_Invert_Table[i][j])
+		{
+			break;
+		}
+	}
+
+	dB = i*12 + j + 1;
+
+	return (dB);
+}
+
+#endif
+
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN| ODM_CE))
+
+VOID
+odm_PHY_SaveAFERegisters(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	pu4Byte		AFEReg,
+	IN	pu4Byte		AFEBackup,
+	IN	u4Byte		RegisterNum
+	)
+{
+	u4Byte	i;
+	
+	//RT_DISP(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
+	for( i = 0 ; i < RegisterNum ; i++){
+		AFEBackup[i] = ODM_GetBBReg(pDM_Odm, AFEReg[i], bMaskDWord);
+	}
+}
+
+VOID
+odm_PHY_ReloadAFERegisters(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	pu4Byte		AFEReg,
+	IN	pu4Byte		AFEBackup,
+	IN	u4Byte		RegiesterNum
+	)
+{
+	u4Byte	i;
+
+	//RT_DISP(FINIT, INIT_IQK, ("Reload ADDA power saving parameters !\n"));
+	for(i = 0 ; i < RegiesterNum; i++)
+	{
+	
+		ODM_SetBBReg(pDM_Odm, AFEReg[i], bMaskDWord, AFEBackup[i]);
+	}
+}
+
+//
+// Description:
+//	Set Single/Dual Antenna default setting for products that do not do detection in advance.
+//
+// Added by Joseph, 2012.03.22
+//
+VOID
+ODM_SingleDualAntennaDefaultSetting(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+	u1Byte btAntNum = 2;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+	btAntNum=BT_GetPgAntNum(pAdapter);
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+#ifdef CONFIG_BT_COEXIST
+	btAntNum = hal_btcoex_GetPgAntNum(pAdapter);
+#endif
+#endif
+
+	// Set default antenna A and B status
+	if(btAntNum == 2)
+	{
+		pDM_SWAT_Table->ANTA_ON=TRUE;
+		pDM_SWAT_Table->ANTB_ON=TRUE;
+		//RT_TRACE(COMP_ANTENNA, DBG_LOUD, ("Dual antenna\n"));
+	}
+#ifdef CONFIG_BT_COEXIST
+	else if(btAntNum == 1)
+	{// Set antenna A as default
+		pDM_SWAT_Table->ANTA_ON=TRUE;
+		pDM_SWAT_Table->ANTB_ON=FALSE;
+		//RT_TRACE(COMP_ANTENNA, DBG_LOUD, ("Single antenna\n"));
+	}
+	else
+	{
+		//RT_ASSERT(FALSE, ("Incorrect antenna number!!\n"));
+	}
+#endif
+}
+
+
+
+//2 8723A ANT DETECT
+//
+// Description:
+//	Implement IQK single tone for RF DPK loopback and BB PSD scanning. 
+//	This function is cooperated with BB team Neil. 
+//
+// Added by Roger, 2011.12.15
+//
+BOOLEAN
+ODM_SingleDualAntennaDetection(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			mode
+	)
+{
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	u4Byte		CurrentChannel,RfLoopReg;
+	u1Byte		n;
+	u4Byte		Reg88c, Regc08, Reg874, Regc50, Reg948=0, Regb2c=0, Reg92c=0, AFE_rRx_Wait_CCA=0;
+	u1Byte		initial_gain = 0x5a;
+	u4Byte		PSD_report_tmp;
+	u4Byte		AntA_report = 0x0, AntB_report = 0x0,AntO_report=0x0;
+	BOOLEAN		bResult = TRUE;
+	u4Byte		AFE_Backup[16];
+	u4Byte		AFE_REG_8723A[16] = {
+					rRx_Wait_CCA, 	rTx_CCK_RFON, 
+					rTx_CCK_BBON, 	rTx_OFDM_RFON,
+					rTx_OFDM_BBON, 	rTx_To_Rx,
+					rTx_To_Tx, 		rRx_CCK, 
+					rRx_OFDM, 		rRx_Wait_RIFS, 
+					rRx_TO_Rx,		rStandby,
+					rSleep,			rPMPD_ANAEN, 	
+					rFPGA0_XCD_SwitchControl, rBlue_Tooth};
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection()============> \n"));	
+
+	
+	if(!(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C|ODM_RTL8723B)))
+		return bResult;
+
+	// Retrieve antenna detection registry info, added by Roger, 2012.11.27.
+	if(!IS_ANT_DETECT_SUPPORT_SINGLE_TONE(pAdapter))
+		return bResult;
+
+	if(pDM_Odm->SupportICType == ODM_RTL8192C)
+	{
+		//Which path in ADC/DAC is turnned on for PSD: both I/Q
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT10|BIT11, 0x3);
+		//Ageraged number: 8
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT12|BIT13, 0x1);
+		//pts = 128;
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
+	}
+
+	//1 Backup Current RF/BB Settings	
+	
+	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask);
+	RfLoopReg = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask);
+	if(!(pDM_Odm->SupportICType == ODM_RTL8723B))
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_A);  // change to Antenna A
+#if (RTL8723B_SUPPORT == 1)
+	else
+	{
+		Reg92c = ODM_GetBBReg(pDM_Odm, 0x92c, bMaskDWord);
+		Reg948 = ODM_GetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord);
+		Regb2c = ODM_GetBBReg(pDM_Odm, AGC_table_select, bMaskDWord);
+		ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x1);
+		ODM_SetBBReg(pDM_Odm, rfe_ctrl_anta_src, 0xff, 0x77);
+		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0x3ff, 0x000);
+		ODM_SetBBReg(pDM_Odm, AGC_table_select, BIT31, 0x0);
+	}
+#endif
+	ODM_StallExecution(10);
+	
+	//Store A Path Register 88c, c08, 874, c50
+	Reg88c = ODM_GetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord);
+	Regc08 = ODM_GetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord);
+	Reg874 = ODM_GetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord);
+	Regc50 = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord);	
+	
+	// Store AFE Registers
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	odm_PHY_SaveAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);	
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		AFE_rRx_Wait_CCA = ODM_GetBBReg(pDM_Odm, rRx_Wait_CCA,bMaskDWord);
+	
+	//Set PSD 128 pts
+	ODM_SetBBReg(pDM_Odm, rFPGA0_PSDFunction, BIT14|BIT15, 0x0);  //128 pts
+	
+	// To SET CH1 to do
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask, 0x7401);     //Channel 1
+	
+	// AFE all on step
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	{
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_CCK_RFON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_CCK_BBON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_OFDM_RFON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_OFDM_BBON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_To_Rx, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_To_Tx, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_CCK, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_OFDM, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_RIFS, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_TO_Rx, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rStandby, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rSleep, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rPMPD_ANAEN, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_SwitchControl, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rBlue_Tooth, bMaskDWord, 0x6FDB25A4);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x01c00016);
+	}
+
+	// 3 wire Disable
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, 0xCCF000C0);
+	
+	//BB IQK Setting
+	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, 0x000800E4);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
+
+	//IQK setting tone@ 4.34Mhz
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x10008C1C);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);	
+
+	//Page B init
+	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x00080000);
+	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x0f600000);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82150008);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28150008);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x001028d0);	
+
+	//RF loop Setting
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x0, 0xFFFFF, 0x50008);	
+	
+	//IQK Single tone start
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	
+	ODM_StallExecution(10000);
+
+	// PSD report of antenna A
+	PSD_report_tmp=0x0;
+	for (n=0;n<2;n++)
+ 	{
+ 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
+		if(PSD_report_tmp >AntA_report)
+			AntA_report=PSD_report_tmp;
+	}
+
+	 // change to Antenna B
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_B); 
+#if (RTL8723B_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x2);
+#endif
+
+	ODM_StallExecution(10);	
+
+	// PSD report of antenna B
+	PSD_report_tmp=0x0;
+	for (n=0;n<2;n++)
+ 	{
+ 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
+		if(PSD_report_tmp > AntB_report)
+			AntB_report=PSD_report_tmp;
+	}
+
+	// change to open case
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, 0);  // change to Antenna A
+#if (RTL8723B_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x0);
+#endif
+
+	ODM_StallExecution(10);	
+	
+	// PSD report of open case
+	PSD_report_tmp=0x0;
+	for (n=0;n<2;n++)
+ 	{
+ 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
+		if(PSD_report_tmp > AntO_report)
+			AntO_report=PSD_report_tmp;
+	}
+
+	//Close IQK Single Tone function
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
+
+	//1 Return to antanna A
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_A);  // change to Antenna A
+#if (RTL8723B_SUPPORT == 1)
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		// external DPDT
+		ODM_SetBBReg(pDM_Odm, rDPDT_control, bMaskDWord, Reg92c);
+
+		//internal S0/S1
+		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord, Reg948);
+		ODM_SetBBReg(pDM_Odm, AGC_table_select, bMaskDWord, Regb2c);
+	}
+#endif
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, Reg88c);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, Regc08);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, Reg874);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, 0x7F, 0x40);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord, Regc50);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask,CurrentChannel);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask,RfLoopReg);
+
+	//Reload AFE Registers
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	odm_PHY_ReloadAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);	
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, AFE_rRx_Wait_CCA);
+
+	if(pDM_Odm->SupportICType == ODM_RTL8723A)
+	{
+		//2 Test Ant B based on Ant A is ON
+		if(mode==ANTTESTB)
+		{
+			if(AntA_report >=	100)
+			{
+				if(AntB_report > (AntA_report+1))
+				{
+					pDM_SWAT_Table->ANTB_ON=FALSE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));		
+				}	
+				else
+				{
+					pDM_SWAT_Table->ANTB_ON=TRUE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n"));	
+				}	
+			}
+			else
+			{
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+				pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
+				bResult = FALSE;
+			}
+		}	
+		//2 Test Ant A and B based on DPDT Open
+		else if(mode==ANTTESTALL)
+		{
+			if((AntO_report >=100) && (AntO_report <=118))
+			{
+				if(AntA_report > (AntO_report+1))
+				{
+					pDM_SWAT_Table->ANTA_ON=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant A is OFF\n"));
+				}	
+				else
+				{
+					pDM_SWAT_Table->ANTA_ON=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant A is ON\n"));
+				}
+
+				if(AntB_report > (AntO_report+2))
+				{
+					pDM_SWAT_Table->ANTB_ON=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant B is OFF\n"));
+				}	
+				else
+				{
+					pDM_SWAT_Table->ANTB_ON=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant B is ON\n"));
+				}
+				
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d \n", 2416, AntA_report));	
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d \n", 2416, AntB_report));	
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_O[%d]= %d \n", 2416, AntO_report));
+				
+				pDM_Odm->AntDetectedInfo.bAntDetected= TRUE;
+				pDM_Odm->AntDetectedInfo.dBForAntA = AntA_report;
+				pDM_Odm->AntDetectedInfo.dBForAntB = AntB_report;
+				pDM_Odm->AntDetectedInfo.dBForAntO = AntO_report;
+				
+				}
+			else
+				{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("return FALSE!!\n"));
+				bResult = FALSE;
+			}
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8192C)
+	{
+		if(AntA_report >=	100)
+		{
+			if(AntB_report > (AntA_report+2))
+			{
+				pDM_SWAT_Table->ANTA_ON=FALSE;
+				pDM_SWAT_Table->ANTB_ON=TRUE;
+				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_B);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna B\n"));		
+			}	
+			else if(AntA_report > (AntB_report+2))
+			{
+				pDM_SWAT_Table->ANTA_ON=TRUE;
+				pDM_SWAT_Table->ANTB_ON=FALSE;
+				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_A);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));
+			}	
+			else
+			{
+				pDM_SWAT_Table->ANTA_ON=TRUE;
+				pDM_SWAT_Table->ANTB_ON=TRUE;
+				RT_TRACE(COMP_ANTENNA, DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna \n"));
+			}
+		}
+		else
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+			pDM_SWAT_Table->ANTA_ON=TRUE; // Set Antenna A on as default 
+			pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
+			bResult = FALSE;
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d \n", 2416, AntA_report));	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d \n", 2416, AntB_report));	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_O[%d]= %d \n", 2416, AntO_report));
+		
+		//2 Test Ant B based on Ant A is ON
+		if(mode==ANTTESTB)
+		{
+			if(AntA_report >=100 && AntA_report <= 116)
+			{
+				if(AntB_report >= (AntA_report+4) && AntB_report > 116)
+				{
+					pDM_SWAT_Table->ANTB_ON=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));		
+				}	
+				else if(AntB_report >=100 && AntB_report <= 116)
+				{
+					pDM_SWAT_Table->ANTB_ON=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n"));	
+				}
+				else
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+					pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
+					bResult = FALSE;
+				}
+			}
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+				pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
+				bResult = FALSE;
+			}
+		}	
+		//2 Test Ant A and B based on DPDT Open
+		else if(mode==ANTTESTALL)
+		{
+			if((AntA_report >= 100) && (AntB_report >= 100) && (AntA_report <= 120) && (AntB_report <= 120))
+			{
+				if((AntA_report - AntB_report < 2) || (AntB_report - AntA_report < 2))
+				{
+					pDM_SWAT_Table->ANTA_ON=TRUE;
+					pDM_SWAT_Table->ANTB_ON=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Dual Antenna\n"));
+				}
+				else if(((AntA_report - AntB_report >= 2) && (AntA_report - AntB_report <= 4)) || 
+					((AntB_report - AntA_report >= 2) && (AntB_report - AntA_report <= 4)))
+				{
+					pDM_SWAT_Table->ANTA_ON=FALSE;
+					pDM_SWAT_Table->ANTB_ON=FALSE;
+					bResult = FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+				}
+				else
+				{
+					pDM_SWAT_Table->ANTA_ON = TRUE;
+					pDM_SWAT_Table->ANTB_ON=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));
+				}
+				
+				pDM_Odm->AntDetectedInfo.bAntDetected= TRUE;
+				pDM_Odm->AntDetectedInfo.dBForAntA = AntA_report;
+				pDM_Odm->AntDetectedInfo.dBForAntB = AntB_report;
+				pDM_Odm->AntDetectedInfo.dBForAntO = AntO_report;
+				
+			}
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("return FALSE!!\n"));
+				bResult = FALSE;
+			}
+		}
+	}
+		
+	return bResult;
+
+}
+
+
+#endif   // end odm_CE
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN| ODM_CE))
+
+VOID
+odm_Set_RA_DM_ARFB_by_Noisy(
+	IN	PDM_ODM_T	pDM_Odm
+)
+{
+	//DbgPrint("DM_ARFB ====> \n");
+	if (pDM_Odm->bNoisyState){
+		ODM_Write4Byte(pDM_Odm,0x430,0x00000000);
+		ODM_Write4Byte(pDM_Odm,0x434,0x05040200);
+		//DbgPrint("DM_ARFB ====> Noisy State\n");
+	}
+	else{
+		ODM_Write4Byte(pDM_Odm,0x430,0x02010000);
+		ODM_Write4Byte(pDM_Odm,0x434,0x07050403);
+		//DbgPrint("DM_ARFB ====> Clean State\n");
+	}
+	
+}
+
+VOID
+ODM_UpdateNoisyState(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN 	BOOLEAN 	bNoisyStateFromC2H
+	)
+{
+	//DbgPrint("Get C2H Command! NoisyState=0x%x\n ", bNoisyStateFromC2H);
+	if(pDM_Odm->SupportICType == ODM_RTL8821  || pDM_Odm->SupportICType == ODM_RTL8812  || 
+	   pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+		pDM_Odm->bNoisyState = bNoisyStateFromC2H;
+	}
+	odm_Set_RA_DM_ARFB_by_Noisy(pDM_Odm);
+};
+
+u4Byte
+Set_RA_DM_Ratrbitmap_by_Noisy(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	WIRELESS_MODE	WirelessMode,
+	IN	u4Byte			ratr_bitmap,
+	IN	u1Byte			rssi_level
+)
+{
+	u4Byte ret_bitmap = ratr_bitmap;
+	switch (WirelessMode)
+	{
+		case WIRELESS_MODE_AC_24G :
+		case WIRELESS_MODE_AC_5G :
+		case WIRELESS_MODE_AC_ONLY:
+			if (pDM_Odm->bNoisyState){ // in Noisy State
+				if (rssi_level==1)
+					ret_bitmap&=0xfe3f0e08;
+				else if (rssi_level==2)
+					ret_bitmap&=0xff3f8f8c;
+				else if (rssi_level==3)
+					ret_bitmap&=0xffffffcc ;
+				else
+					ret_bitmap&=0xffffffff ;
+			}
+			else{                                   // in SNR State
+				if (rssi_level==1){
+					ret_bitmap&=0xfc3e0c08;
+				}
+				else if (rssi_level==2){
+					ret_bitmap&=0xfe3f0e08;
+				}
+				else if (rssi_level==3){
+					ret_bitmap&=0xffbfefcc;
+				}
+				else{
+					ret_bitmap&=0x0fffffff;
+				}
+			}
+			break;
+		case WIRELESS_MODE_B:
+		case WIRELESS_MODE_A:
+		case WIRELESS_MODE_G:
+		case WIRELESS_MODE_N_24G:
+		case WIRELESS_MODE_N_5G:
+			if (pDM_Odm->bNoisyState){
+				if (rssi_level==1)
+					ret_bitmap&=0x0f0e0c08;
+				else if (rssi_level==2)
+					ret_bitmap&=0x0f8f0e0c;
+				else if (rssi_level==3)
+					ret_bitmap&=0x0fefefcc ;
+				else
+					ret_bitmap&=0xffffffff ;
+			}
+			else{
+				if (rssi_level==1){
+					ret_bitmap&=0x0f8f0e08;
+				}
+				else if (rssi_level==2){
+					ret_bitmap&=0x0fcf8f8c;
+				}
+				else if (rssi_level==3){
+					ret_bitmap&=0x0fffffcc;
+				}
+				else{
+					ret_bitmap&=0x0fffffff;
+				}
+			}
+			break;
+		default:
+			break;
+	}
+	//DbgPrint("DM_RAMask ====> rssi_LV = %d, BITMAP = %x \n", rssi_level, ret_bitmap);
+	return ret_bitmap;
+
+}
+
+
+
+VOID
+ODM_UpdateInitRate(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	u1Byte		Rate
+	)
+{
+	u1Byte			p = 0;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("Get C2H Command! Rate=0x%x\n", Rate));
+	
+	if(pDM_Odm->SupportICType == ODM_RTL8821  || pDM_Odm->SupportICType == ODM_RTL8812  || 
+	   pDM_Odm->SupportICType == ODM_RTL8723B || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+		pDM_Odm->TxRate = Rate;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+		#if USE_WORKITEM
+		PlatformScheduleWorkItem(&pDM_Odm->RaRptWorkitem);
+		#else
+		if(pDM_Odm->SupportICType == ODM_RTL8821)
+		{
+			ODM_TxPwrTrackSetPwr8821A(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8812)
+		{
+			for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8812A; p++) 		
+			{
+				ODM_TxPwrTrackSetPwr8812A(pDM_Odm, MIX_MODE, p, 0);
+			}
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		{
+			ODM_TxPwrTrackSetPwr_8723B(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8192E)
+		{
+			for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8192E; p++) 		
+			{
+				ODM_TxPwrTrackSetPwr92E(pDM_Odm, MIX_MODE, p, 0);
+			}
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8188E)
+		{
+			ODM_TxPwrTrackSetPwr88E(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+		}
+		#endif
+	#else
+		PlatformScheduleWorkItem(&pDM_Odm->RaRptWorkitem);
+	#endif	
+#endif
+	}
+	else
+		return;
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+ODM_UpdateInitRateWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	Adapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	u1Byte			p = 0;	
+
+	if(pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+		ODM_TxPwrTrackSetPwr8821A(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8812)
+	{
+		for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8812A; p++)    //DOn't know how to include &c
+		{
+			ODM_TxPwrTrackSetPwr8812A(pDM_Odm, MIX_MODE, p, 0);
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+			ODM_TxPwrTrackSetPwr_8723B(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
+	{
+		for (p = ODM_RF_PATH_A; p < MAX_PATH_NUM_8192E; p++)    //DOn't know how to include &c
+		{
+			ODM_TxPwrTrackSetPwr92E(pDM_Odm, MIX_MODE, p, 0);
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+			ODM_TxPwrTrackSetPwr88E(pDM_Odm, MIX_MODE, ODM_RF_PATH_A, 0);
+	}
+}
+#endif
+#endif
+
+//
+// ODM multi-port consideration, added by Roger, 2013.10.01.
+//
+VOID
+ODM_AsocEntry_Init(
+	IN	PDM_ODM_T	pDM_Odm
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER pLoopAdapter = GetDefaultAdapter(pDM_Odm->Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pLoopAdapter);
+	PDM_ODM_T		 pDM_OutSrc = &pHalData->DM_OutSrc;
+	u1Byte	TotalAssocEntryNum = 0;
+	u1Byte	index = 0;
+
+
+	ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, 0, &pLoopAdapter->MgntInfo.DefaultPort[0]);
+	pLoopAdapter->MgntInfo.DefaultPort[0].MultiPortStationIdx = TotalAssocEntryNum;
+		
+	pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
+	TotalAssocEntryNum +=1;
+
+	while(pLoopAdapter)
+	{
+		for (index = 0; index <ASSOCIATE_ENTRY_NUM; index++)
+		{
+			ODM_CmnInfoPtrArrayHook(pDM_OutSrc, ODM_CMNINFO_STA_STATUS, TotalAssocEntryNum+index, &pLoopAdapter->MgntInfo.AsocEntry[index]);
+			pLoopAdapter->MgntInfo.AsocEntry[index].MultiPortStationIdx = TotalAssocEntryNum+index;				
+		}
+		
+		TotalAssocEntryNum+= index;
+		if(IS_HARDWARE_TYPE_8188E((pDM_Odm->Adapter)))
+			pLoopAdapter->RASupport = TRUE;
+		pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
+	}
+#endif
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+/* Justin: According to the current RRSI to adjust Response Frame TX power, 2012/11/05 */
+void odm_dtc(PDM_ODM_T pDM_Odm)
+{
+#ifdef CONFIG_DM_RESP_TXAGC
+	#define DTC_BASE            35	/* RSSI higher than this value, start to decade TX power */
+	#define DTC_DWN_BASE       (DTC_BASE-5)	/* RSSI lower than this value, start to increase TX power */
+
+	/* RSSI vs TX power step mapping: decade TX power */
+	static const u8 dtc_table_down[]={
+		DTC_BASE,
+		(DTC_BASE+5),
+		(DTC_BASE+10),
+		(DTC_BASE+15),
+		(DTC_BASE+20),
+		(DTC_BASE+25)
+	};
+
+	/* RSSI vs TX power step mapping: increase TX power */
+	static const u8 dtc_table_up[]={
+		DTC_DWN_BASE,
+		(DTC_DWN_BASE-5),
+		(DTC_DWN_BASE-10),
+		(DTC_DWN_BASE-15),
+		(DTC_DWN_BASE-15),
+		(DTC_DWN_BASE-20),
+		(DTC_DWN_BASE-20),
+		(DTC_DWN_BASE-25),
+		(DTC_DWN_BASE-25),
+		(DTC_DWN_BASE-30),
+		(DTC_DWN_BASE-35)
+	};
+
+	u8 i;
+	u8 dtc_steps=0;
+	u8 sign;
+	u8 resp_txagc=0;
+
+	#if 0
+	/* As DIG is disabled, DTC is also disable */
+	if(!(pDM_Odm->SupportAbility & ODM_XXXXXX))
+		return;
+	#endif
+
+	if (DTC_BASE < pDM_Odm->RSSI_Min) {
+		/* need to decade the CTS TX power */
+		sign = 1;
+		for (i=0;i<ARRAY_SIZE(dtc_table_down);i++)
+		{
+			if ((dtc_table_down[i] >= pDM_Odm->RSSI_Min) || (dtc_steps >= 6))
+				break;
+			else
+				dtc_steps++;
+		}
+	}
+#if 0
+	else if (DTC_DWN_BASE > pDM_Odm->RSSI_Min)
+	{
+		/* needs to increase the CTS TX power */
+		sign = 0;
+		dtc_steps = 1;
+		for (i=0;i<ARRAY_SIZE(dtc_table_up);i++)
+		{
+			if ((dtc_table_up[i] <= pDM_Odm->RSSI_Min) || (dtc_steps>=10))
+				break;
+			else
+				dtc_steps++;
+		}
+	}
+#endif
+	else
+	{
+		sign = 0;
+		dtc_steps = 0;
+	}
+
+	resp_txagc = dtc_steps | (sign << 4);
+	resp_txagc = resp_txagc | (resp_txagc << 5);
+	ODM_Write1Byte(pDM_Odm, 0x06d9, resp_txagc);
+
+	DBG_871X("%s RSSI_Min:%u, set RESP_TXAGC to %s %u\n", 
+		__func__, pDM_Odm->RSSI_Min, sign?"minus":"plus", dtc_steps);
+#endif /* CONFIG_RESP_TXAGC_ADJUST */
+}
+
+#endif /* #if (DM_ODM_SUPPORT_TYPE == ODM_CE) */
+
+VOID
+odm_UpdatePowerTrainingState(
+	IN	PDM_ODM_T	pDM_Odm
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PFALSE_ALARM_STATISTICS 	FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm , PHYDM_FALSEALMCNT);
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+	u4Byte						score = 0;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_PWR_TRAIN))
+		return;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState()============>\n"));
+	pDM_Odm->bChangeState = FALSE;
+
+	// Debug command
+	if(pDM_Odm->ForcePowerTrainingState)
+	{
+		if(pDM_Odm->ForcePowerTrainingState == 1 && !pDM_Odm->bDisablePowerTraining)
+		{
+			pDM_Odm->bChangeState = TRUE;
+			pDM_Odm->bDisablePowerTraining = TRUE;
+		}
+		else if(pDM_Odm->ForcePowerTrainingState == 2 && pDM_Odm->bDisablePowerTraining)
+		{
+			pDM_Odm->bChangeState = TRUE;
+			pDM_Odm->bDisablePowerTraining = FALSE;
+		}
+
+		pDM_Odm->PT_score = 0;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = 0;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): ForcePowerTrainingState = %d\n", 
+			pDM_Odm->ForcePowerTrainingState));
+		return;
+	}
+	
+	if(!pDM_Odm->bLinked)
+		return;
+	
+	// First connect
+	if((pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE))
+	{
+		pDM_Odm->PT_score = 0;
+		pDM_Odm->bChangeState = TRUE;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = 0;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): First Connect\n"));
+		return;
+	}
+
+	// Compute score
+	if(pDM_Odm->NHM_cnt_0 >= 215)
+		score = 2;
+	else if(pDM_Odm->NHM_cnt_0 >= 190) 
+		score = 1;							// unknow state
+	else
+	{
+		u4Byte	RX_Pkt_Cnt;
+		
+		RX_Pkt_Cnt = (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM) + (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK);
+		
+		if((FalseAlmCnt->Cnt_CCA_all > 31 && RX_Pkt_Cnt > 31) && (FalseAlmCnt->Cnt_CCA_all >= RX_Pkt_Cnt))
+		{
+			if((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 1)) <= FalseAlmCnt->Cnt_CCA_all)
+				score = 0;
+			else if((RX_Pkt_Cnt + (RX_Pkt_Cnt >> 2)) <= FalseAlmCnt->Cnt_CCA_all)
+				score = 1;
+			else
+				score = 2;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): RX_Pkt_Cnt = %d, Cnt_CCA_all = %d\n", 
+			RX_Pkt_Cnt, FalseAlmCnt->Cnt_CCA_all));
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NumQryPhyStatusOFDM = %d, NumQryPhyStatusCCK = %d\n",
+			(u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM), (u4Byte)(pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): NHM_cnt_0 = %d, score = %d\n", 
+		pDM_Odm->NHM_cnt_0, score));
+
+	// smoothing
+	pDM_Odm->PT_score = (score << 4) + (pDM_Odm->PT_score>>1) + (pDM_Odm->PT_score>>2);
+	score = (pDM_Odm->PT_score + 32) >> 6;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): PT_score = %d, score after smoothing = %d\n", 
+		pDM_Odm->PT_score, score));
+
+	// Mode decision
+	if(score == 2)
+	{
+		if(pDM_Odm->bDisablePowerTraining)
+		{
+			pDM_Odm->bChangeState = TRUE;
+			pDM_Odm->bDisablePowerTraining = FALSE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Change state\n"));
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Enable Power Training\n"));
+	}
+	else if(score == 0)
+	{
+		if(!pDM_Odm->bDisablePowerTraining)
+		{
+			pDM_Odm->bChangeState = TRUE;
+			pDM_Odm->bDisablePowerTraining = TRUE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Change state\n"));
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_UpdatePowerTrainingState(): Disable Power Training\n"));
+	}
+
+	pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
+	pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = 0;
+#endif
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm.h
similarity index 70%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm.h
index 5b198608dc73..3a50704ce852 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm.h
@@ -22,6 +22,24 @@
 #ifndef	__HALDMOUTSRC_H__
 #define __HALDMOUTSRC_H__
 
+//============================================================
+// include files
+//============================================================
+#include "phydm_DIG.h"
+#include "phydm_EdcaTurboCheck.h"
+#include "phydm_PathDiv.h"
+#include "phydm_DynamicBBPowerSaving.h"
+#include "phydm_RaInfo.h"
+#include "phydm_DynamicTxPower.h"
+#include "phydm_CfoTracking.h"
+#include "phydm_ACS.h"
+#include "phydm_PowerTracking.h"
+#include "PhyDM_Adaptivity.h"
+#include "phydm_NoiseMonitor.h"
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+#include "phydm_RXHP.h"
+#endif
+
 //============================================================
 // Definition 
 //============================================================
@@ -59,19 +77,13 @@
 #define	RSSI_MODE		1
 #define	TRAFFIC_LOW	0
 #define	TRAFFIC_HIGH	1
+#define	NONE			0
 
 
 //============================================================
 //3 Tx Power Tracking
 //3============================================================
-#define		DPK_DELTA_MAPPING_NUM	13
-#define		index_mapping_HP_NUM	15	
-#define	OFDM_TABLE_SIZE 	43
-#define	CCK_TABLE_SIZE			33
-#define TXSCALE_TABLE_SIZE 		37
-#define TXPWR_TRACK_TABLE_SIZE 	30
-#define DELTA_SWINGIDX_SIZE     30
-#define BAND_NUM 				4
+
 
 //============================================================
 //3 PSD Handler
@@ -110,14 +122,6 @@
 #define		ANTTESTA		0x01		//Ant A will be Testing	
 #define		ANTTESTB		0x02		//Ant B will be testing
 
-// LPS define
-#define DM_DIG_FA_TH0_LPS				4 //-> 4 in lps
-#define DM_DIG_FA_TH1_LPS				15 //-> 15 lps
-#define DM_DIG_FA_TH2_LPS				30 //-> 30 lps
-#define RSSI_OFFSET_DIG					0x05;
-
-
-
 //for 8723A Ant Definition--2012--06--07 due to different IC may be different ANT define
 #define		MAIN_ANT		1		//Ant A or Ant Main
 #define		AUX_ANT		2		//AntB or Ant Aux
@@ -161,82 +165,11 @@ typedef		struct _WLAN_STA{
 
 #endif
 
-typedef struct _Dynamic_Initial_Gain_Threshold_
-{
-	u1Byte		Dig_Enable_Flag;
-	u1Byte		Dig_Ext_Port_Stage;
-	
-	int		   	RssiLowThresh;
-	int		    	RssiHighThresh;
-
-	u4Byte		FALowThresh;
-	u4Byte		FAHighThresh;
-
-	u1Byte		CurSTAConnectState;
-	u1Byte		PreSTAConnectState;
-	u1Byte		CurMultiSTAConnectState;
-
-	u1Byte		PreIGValue;
-	u1Byte		CurIGValue;
-	u1Byte		BT30_CurIGI;
-	u1Byte		BackupIGValue;
-
-	s1Byte		BackoffVal;
-	s1Byte		BackoffVal_range_max;
-	s1Byte		BackoffVal_range_min;
-	u1Byte		rx_gain_range_max;
-	u1Byte		rx_gain_range_min;
-	u1Byte		Rssi_val_min;
-
-	u1Byte		PreCCK_CCAThres;
-	u1Byte		CurCCK_CCAThres;
-	u1Byte		PreCCKPDState;
-	u1Byte		CurCCKPDState;
-
-	u1Byte		LargeFAHit;
-	u1Byte		ForbiddenIGI;
-	u4Byte		Recover_cnt;
-
-	u1Byte		DIG_Dynamic_MIN_0;
-	u1Byte		DIG_Dynamic_MIN_1;
-	BOOLEAN		bMediaConnect_0;
-	BOOLEAN		bMediaConnect_1;
-
-	u4Byte		AntDiv_RSSI_max;
-	u4Byte		RSSI_max;
-}DIG_T,*pDIG_T;
-
-typedef struct _Dynamic_Power_Saving_
-{
-	u1Byte		PreCCAState;
-	u1Byte		CurCCAState;
+//Remove DIG by Yuchen
 
-	u1Byte		PreRFState;
-	u1Byte		CurRFState;
+//Remoce BB power saving by Yuchn
 
-	int		    Rssi_val_min;
-	
-	u1Byte		initialize;
-	u4Byte		Reg874,RegC70,Reg85C,RegA74;
-	
-}PS_T,*pPS_T;
-
-typedef struct _FALSE_ALARM_STATISTICS{
-	u4Byte	Cnt_Parity_Fail;
-	u4Byte	Cnt_Rate_Illegal;
-	u4Byte	Cnt_Crc8_fail;
-	u4Byte	Cnt_Mcs_fail;
-	u4Byte	Cnt_Ofdm_fail;
-	u4Byte	Cnt_Cck_fail;
-	u4Byte	Cnt_all;
-	u4Byte	Cnt_Fast_Fsync;
-	u4Byte	Cnt_SB_Search_fail;
-	u4Byte	Cnt_OFDM_CCA;
-	u4Byte	Cnt_CCK_CCA;
-	u4Byte	Cnt_CCA_all;
-	u4Byte	Cnt_BW_USC;	//Gary
-	u4Byte	Cnt_BW_LSC;	//Gary
-}FALSE_ALARM_STATISTICS, *PFALSE_ALARM_STATISTICS;
+//Remove DIG by yuchen
 
 typedef struct _Dynamic_Primary_CCA{
 	u1Byte		PriCCA_flag;
@@ -248,9 +181,7 @@ typedef struct _Dynamic_Primary_CCA{
 	u1Byte  		MF_state;
 }Pri_CCA_T, *pPri_CCA_T;
 
-typedef struct _Rate_Adaptive_Table_{
-	u1Byte		firstconnect;
-}RA_T, *pRA_T;
+//Remove RA_T,*pRA_T by RS_James
 
 typedef struct _RX_High_Power_
 {
@@ -316,13 +247,20 @@ typedef struct _SW_Antenna_Switch_
 	u1Byte		SelectAntennaMap;
 	u1Byte		RSSI_target;	
 	u1Byte 		reset_idx;
+	u2Byte		Single_Ant_Counter;
+	u2Byte		Dual_Ant_Counter;
+	u2Byte          Aux_FailDetec_Counter;
+	u2Byte          Retry_Counter;
 
 	// Before link Antenna Switch check
 	u1Byte		SWAS_NoLink_State;
 	u4Byte		SWAS_NoLink_BK_Reg860;
 	u4Byte		SWAS_NoLink_BK_Reg92c;
+	u4Byte		SWAS_NoLink_BK_Reg948;
 	BOOLEAN		ANTA_ON;	//To indicate Ant A is or not
 	BOOLEAN		ANTB_ON;	//To indicate Ant B is on or not
+	BOOLEAN		Pre_Aux_FailDetec;
+	BOOLEAN		RSSI_AntDect_bResult;	
 	u1Byte		Ant5G;
 	u1Byte		Ant2G;
 
@@ -341,13 +279,20 @@ typedef struct _SW_Antenna_Switch_
 	u1Byte		Train_time;
 	u1Byte		Train_time_flag;
 	RT_TIMER 	SwAntennaSwitchTimer;
+#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)	
 	RT_TIMER 	SwAntennaSwitchTimer_8723B;
+	u4Byte		PktCnt_SWAntDivByCtrlFrame;
+	BOOLEAN		bSWAntDivByCtrlFrame;
+#endif
+	
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
 	#if USE_WORKITEM
 	RT_WORK_ITEM			SwAntennaSwitchWorkitem;
+#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)	
 	RT_WORK_ITEM			SwAntennaSwitchWorkitem_8723B;
 	#endif
 #endif
+#endif
 /* CE Platform use
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
 	_timer SwAntennaSwitchTimer; 
@@ -382,28 +327,9 @@ typedef struct _SW_Antenna_Switch_
 }SWAT_T, *pSWAT_T;
 //#endif
 
-typedef struct _EDCA_TURBO_
-{
-	BOOLEAN bCurrentTurboEDCA;
-	BOOLEAN bIsCurRDLState;
-
-	#if(DM_ODM_SUPPORT_TYPE == ODM_CE	)
-	u4Byte	prv_traffic_idx; // edca turbo
-	#endif
-
-}EDCA_T,*pEDCA_T;
+// Edca Remove by YuChen
 
-typedef struct _ODM_RATE_ADAPTIVE
-{
-	u1Byte				Type;				// DM_Type_ByFW/DM_Type_ByDriver
-	u1Byte				LdpcThres;			// if RSSI > LdpcThres => switch from LPDC to BCC
-	BOOLEAN				bUseLdpc;
-	BOOLEAN				bLowerRtsRate;
-	u1Byte				HighRSSIThresh;		// if RSSI > HighRSSIThresh	=> RATRState is DM_RATR_STA_HIGH
-	u1Byte				LowRSSIThresh;		// if RSSI <= LowRSSIThresh	=> RATRState is DM_RATR_STA_LOW
-	u1Byte				RATRState;			// Current RSSI level, DM_RATR_STA_HIGH/DM_RATR_STA_MIDDLE/DM_RATR_STA_LOW
-
-} ODM_RATE_ADAPTIVE, *PODM_RATE_ADAPTIVE;
+//ODM_RATE_ADAPTIVE Remove by RS_James
 
 
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
@@ -439,22 +365,6 @@ typedef enum _HT_IOT_PEER
 }HT_IOT_PEER_E, *PHTIOT_PEER_E;
 #endif//#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
 
-
-
-#define IQK_MAC_REG_NUM		4
-#define IQK_ADDA_REG_NUM		16
-#define IQK_BB_REG_NUM_MAX	10
-#if (RTL8192D_SUPPORT==1) 
-#define IQK_BB_REG_NUM		10
-#else
-#define IQK_BB_REG_NUM		9
-#endif
-#define HP_THERMAL_NUM		8
-
-#define AVG_THERMAL_NUM		8
-#define IQK_Matrix_REG_NUM	8
-#define IQK_Matrix_Settings_NUM	14+24+21 // Channels_2_4G_NUM + Channels_5G_20M_NUM + Channels_5G
-
 #define		DM_Type_ByFW			0
 #define		DM_Type_ByDriver		1
 
@@ -467,8 +377,12 @@ typedef enum _HT_IOT_PEER
 #define MAX_PATH_NUM_8723B		1
 #define MAX_PATH_NUM_8812A		2
 #define MAX_PATH_NUM_8821A		1
+#define MAX_PATH_NUM_8814A		4
+#define MAX_PATH_NUM_8822B		2
+
 
 #define IQK_THRESHOLD			8
+#define DPK_THRESHOLD			4
 
 typedef struct _ODM_Phy_Status_Info_
 {
@@ -513,6 +427,7 @@ typedef struct _ODM_Per_Pkt_Info_
 	BOOLEAN		bPacketMatchBSSID;
 	BOOLEAN		bPacketToSelf;
 	BOOLEAN		bPacketBeacon;
+	BOOLEAN		bToSelf;
 }ODM_PACKET_INFO_T,*PODM_PACKET_INFO_T;
 
 
@@ -520,9 +435,9 @@ typedef struct _ODM_Phy_Dbg_Info_
 {
 	//ODM Write,debug info
 	s1Byte		RxSNRdB[4];
-	u8Byte		NumQryPhyStatus;
-	u8Byte		NumQryPhyStatusCCK;
-	u8Byte		NumQryPhyStatusOFDM;
+	u4Byte		NumQryPhyStatus;
+	u4Byte		NumQryPhyStatusCCK;
+	u4Byte		NumQryPhyStatusOFDM;
 	u1Byte		NumQryBeaconPkt;
 	//Others
 	s4Byte		RxEVM[4];	
@@ -600,6 +515,7 @@ typedef		struct _ODM_STA_INFO{
 	u1Byte		rate_id;
 	u1Byte		rate_SGI;
 	u1Byte		rssi_sta_ra;
+
 	u1Byte		SGI_enable;
 	u1Byte		Decision_rate;
 	u1Byte		Pre_rate;
@@ -659,6 +575,9 @@ typedef enum _ODM_Common_Info_Definition
 	ODM_CMNINFO_BINHCT_TEST,
 	ODM_CMNINFO_BWIFI_TEST,
 	ODM_CMNINFO_SMART_CONCURRENT,
+	ODM_CMNINFO_DOMAIN_CODE_2G,
+	ODM_CMNINFO_DOMAIN_CODE_5G,
+	ODM_CMNINFO_IQKFWOFFLOAD,
 	//-----------HOOK BEFORE REG INIT-----------//	
 
 
@@ -688,9 +607,12 @@ typedef enum _ODM_Common_Info_Definition
 	ODM_CMNINFO_INIT_ON,
 	ODM_CMNINFO_ANT_TEST,
 	ODM_CMNINFO_NET_CLOSED,
-	ODM_CMNINFO_MP_MODE,
 	//ODM_CMNINFO_RTSTA_AID,				// For win driver only?
 	ODM_CMNINFO_FORCED_IGI_LB,
+	ODM_CMNINFO_P2P_LINK,
+	ODM_CMNINFO_FCS_MODE,
+	ODM_CMNINFO_IS1ANTENNA,
+	ODM_CMNINFO_RFDEFAULTPATH,
 //--------- POINTER REFERENCE-----------//
 
 //------------CALL BY VALUE-------------//
@@ -705,12 +627,18 @@ typedef enum _ODM_Common_Info_Definition
 	ODM_CMNINFO_RA_THRESHOLD_HIGH,		// u1Byte
 	ODM_CMNINFO_RA_THRESHOLD_LOW,		// u1Byte
 	ODM_CMNINFO_RF_ANTENNA_TYPE,		// u1Byte
-	ODM_CMNINFO_BT_DISABLED,
+	ODM_CMNINFO_BT_ENABLED,
 	ODM_CMNINFO_BT_HS_CONNECT_PROCESS,
 	ODM_CMNINFO_BT_HS_RSSI,
 	ODM_CMNINFO_BT_OPERATION,
 	ODM_CMNINFO_BT_LIMITED_DIG,					//Need to Limited Dig or not
 	ODM_CMNINFO_BT_DISABLE_EDCA,
+#if(DM_ODM_SUPPORT_TYPE & ODM_AP)		// for repeater mode add by YuChen 2014.06.
+#ifdef UNIVERSAL_REPEATER
+	ODM_CMNINFO_VXD_LINK,
+#endif
+#endif
+	
 //------------CALL BY VALUE-------------//
 
 	//
@@ -731,7 +659,7 @@ typedef enum _ODM_Common_Info_Definition
 typedef enum _ODM_Support_Ability_Definition
 {
 	//
-	// BB ODM section BIT 0-15
+	// BB ODM section BIT 0-19
 	//
 	ODM_BB_DIG					= BIT0,
 	ODM_BB_RA_MASK				= BIT1,
@@ -747,13 +675,15 @@ typedef enum _ODM_Support_Ability_Definition
 	ODM_BB_PSD					= BIT11,
 	ODM_BB_RXHP					= BIT12,
 	ODM_BB_ADAPTIVITY				= BIT13,
-	ODM_BB_DYNAMIC_ATC			= BIT14,
+	ODM_BB_CFO_TRACKING			= BIT14,
+	ODM_BB_NHM_CNT				= BIT15,
+	ODM_BB_PRIMARY_CCA			= BIT16,
 	
 	//
-	// MAC DM section BIT 16-23
+	// MAC DM section BIT 20-23
 	//
-	ODM_MAC_EDCA_TURBO			= BIT16,
-	ODM_MAC_EARLY_MODE			= BIT17,
+	ODM_MAC_EDCA_TURBO			= BIT20,
+	ODM_MAC_EARLY_MODE			= BIT21,
 	
 	//
 	// RF ODM section BIT 24-31
@@ -785,23 +715,53 @@ typedef enum tag_ODM_Support_IC_Type_Definition
 	ODM_RTL8821 	=	BIT6,
 	ODM_RTL8192E 	=	BIT7,	
 	ODM_RTL8723B	=	BIT8,
-	ODM_RTL8813A	=	BIT9,	
-	ODM_RTL8881A 	=	BIT10
+	ODM_RTL8814A	=	BIT9,	
+	ODM_RTL8881A 	=	BIT10,
+	ODM_RTL8821B 	=	BIT11,
+	ODM_RTL8822B 	=	BIT12,
+        ODM_RTL8703B 	=	BIT13
 }ODM_IC_TYPE_E;
 
-#define ODM_IC_11N_SERIES		(ODM_RTL8192S|ODM_RTL8192C|ODM_RTL8192D|ODM_RTL8723A|ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B)
-#define ODM_IC_11AC_SERIES		(ODM_RTL8812|ODM_RTL8821|ODM_RTL8813A|ODM_RTL8881A)
+#define ODM_IC_11N_SERIES		(ODM_RTL8192S|ODM_RTL8192C|ODM_RTL8192D|ODM_RTL8723A|ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B|ODM_RTL8703B)
+#define ODM_IC_11AC_SERIES		(ODM_RTL8812|ODM_RTL8821|ODM_RTL8814A|ODM_RTL8881A|ODM_RTL8821B|ODM_RTL8822B)
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+
 #ifdef RTK_AC_SUPPORT
 #define ODM_IC_11AC_SERIES_SUPPORT		1
 #else
 #define ODM_IC_11AC_SERIES_SUPPORT		0
 #endif
+
+#define ODM_IC_11N_SERIES_SUPPORT			1
+#define ODM_CONFIG_BT_COEXIST				0
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+#define ODM_IC_11AC_SERIES_SUPPORT		1
+#define ODM_IC_11N_SERIES_SUPPORT			1
+#define ODM_CONFIG_BT_COEXIST				1
+
+#else 
+
+#if((RTL8192C_SUPPORT == 1) || (RTL8192D_SUPPORT == 1) || (RTL8723A_SUPPORT == 1) || (RTL8188E_SUPPORT == 1) ||\
+(RTL8723B_SUPPORT == 1) || (RTL8192E_SUPPORT == 1) || (RTL8195A_SUPPORT == 1))
+#define ODM_IC_11N_SERIES_SUPPORT			1
+#define ODM_IC_11AC_SERIES_SUPPORT		0
 #else
+#define ODM_IC_11N_SERIES_SUPPORT			0
 #define ODM_IC_11AC_SERIES_SUPPORT		1
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+#define ODM_CONFIG_BT_COEXIST				1
+#else
+#define ODM_CONFIG_BT_COEXIST				0
+#endif
+
+#endif
+
+
 //ODM_CMNINFO_CUT_VER
 typedef enum tag_ODM_Cut_Version_Definition
 {
@@ -813,6 +773,8 @@ typedef enum tag_ODM_Cut_Version_Definition
 	ODM_CUT_F 		=	5,
 
 	ODM_CUT_I 		=	8,
+	ODM_CUT_J 		=	9,
+	ODM_CUT_K 		=	10,	
 	ODM_CUT_TEST 	=	15,
 }ODM_CUT_VERSION_E;
 
@@ -1061,137 +1023,10 @@ typedef struct _ODM_RA_Info_
 #endif
 } ODM_RA_INFO_T,*PODM_RA_INFO_T;
 
-typedef struct _IQK_MATRIX_REGS_SETTING{
-	BOOLEAN 	bIQKDone;
-	s4Byte		Value[3][IQK_Matrix_REG_NUM];
-	BOOLEAN 	bBWIqkResultSaved[3];	
-}IQK_MATRIX_REGS_SETTING,*PIQK_MATRIX_REGS_SETTING;
-
-#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
-typedef struct _PathDiv_Parameter_define_
-{
-	u4Byte org_5g_RegE30;
-	u4Byte org_5g_RegC14;
-	u4Byte org_5g_RegCA0;
-	u4Byte swt_5g_RegE30;
-	u4Byte swt_5g_RegC14;
-	u4Byte swt_5g_RegCA0;
-	//for 2G IQK information
-	u4Byte org_2g_RegC80;
-	u4Byte org_2g_RegC4C;
-	u4Byte org_2g_RegC94;
-	u4Byte org_2g_RegC14;
-	u4Byte org_2g_RegCA0;
-
-	u4Byte swt_2g_RegC80;
-	u4Byte swt_2g_RegC4C;
-	u4Byte swt_2g_RegC94;
-	u4Byte swt_2g_RegC14;
-	u4Byte swt_2g_RegCA0;
-}PATHDIV_PARA,*pPATHDIV_PARA;
-#endif
+//Remove struct  PATHDIV_PARA to odm_PathDiv.h 
 
+//move to PowerTracking.h by YuChen
 
-typedef struct ODM_RF_Calibration_Structure
-{
-	//for tx power tracking
-	
-	u4Byte	RegA24; // for TempCCK
-	s4Byte	RegE94;
-	s4Byte 	RegE9C;
-	s4Byte	RegEB4;
-	s4Byte	RegEBC;	
-
-	u1Byte  	TXPowercount;
-	BOOLEAN bTXPowerTrackingInit; 
-	BOOLEAN bTXPowerTracking;
-	u1Byte  	TxPowerTrackControl; //for mp mode, turn off txpwrtracking as default
-	u1Byte  	TM_Trigger;
-    	u1Byte  	InternalPA5G[2];	//pathA / pathB
-	
-	u1Byte  	ThermalMeter[2];    // ThermalMeter, index 0 for RFIC0, and 1 for RFIC1
-	u1Byte  	ThermalValue;
-	u1Byte  	ThermalValue_LCK;
-	u1Byte  	ThermalValue_IQK;
-	u1Byte	ThermalValue_DPK;		
-	u1Byte	ThermalValue_AVG[AVG_THERMAL_NUM];
-	u1Byte	ThermalValue_AVG_index;		
-	u1Byte	ThermalValue_RxGain;
-	u1Byte	ThermalValue_Crystal;
-	u1Byte	ThermalValue_DPKstore;
-	u1Byte	ThermalValue_DPKtrack;
-	BOOLEAN	TxPowerTrackingInProgress;
-	
-	BOOLEAN	bReloadtxpowerindex;	
-	u1Byte 	bRfPiEnable;
-	u4Byte 	TXPowerTrackingCallbackCnt; //cosa add for debug
-
-
-	//------------------------- Tx power Tracking -------------------------//
-	u1Byte 	bCCKinCH14;
-	u1Byte 	CCK_index;
-	u1Byte 	OFDM_index[MAX_RF_PATH];
-	s1Byte	PowerIndexOffset[MAX_RF_PATH];
-	s1Byte	DeltaPowerIndex[MAX_RF_PATH];
-	s1Byte	DeltaPowerIndexLast[MAX_RF_PATH];	
-	BOOLEAN bTxPowerChanged;
-		
-	u1Byte 	ThermalValue_HP[HP_THERMAL_NUM];
-	u1Byte 	ThermalValue_HP_index;
-	IQK_MATRIX_REGS_SETTING IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];
-	BOOLEAN	bNeedIQK;
-	BOOLEAN	bIQKInProgress;	
-	u1Byte	Delta_IQK;
-	u1Byte	Delta_LCK;
-	s1Byte  BBSwingDiff2G, BBSwingDiff5G; // Unit: dB
-    u1Byte  DeltaSwingTableIdx_2GCCKA_P[DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_2GCCKA_N[DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_2GCCKB_P[DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_2GCCKB_N[DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_2GA_P[DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_2GA_N[DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_2GB_P[DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_2GB_N[DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_5GA_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_5GA_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_5GB_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_5GB_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_2GA_P_8188E[DELTA_SWINGIDX_SIZE];
-    u1Byte  DeltaSwingTableIdx_2GA_N_8188E[DELTA_SWINGIDX_SIZE];
-    
-	//--------------------------------------------------------------------//	
-	
-	//for IQK	
-	u4Byte 	RegC04;
-	u4Byte 	Reg874;
-	u4Byte 	RegC08;
-	u4Byte 	RegB68;
-	u4Byte 	RegB6C;
-	u4Byte 	Reg870;
-	u4Byte 	Reg860;
-	u4Byte 	Reg864;
-	
-	BOOLEAN	bIQKInitialized;
-	BOOLEAN bLCKInProgress;
-	BOOLEAN	bAntennaDetected;
-	u4Byte	ADDA_backup[IQK_ADDA_REG_NUM];
-	u4Byte	IQK_MAC_backup[IQK_MAC_REG_NUM];
-	u4Byte	IQK_BB_backup_recover[9];
-	u4Byte	IQK_BB_backup[IQK_BB_REG_NUM];	
-
-	//for APK
-	u4Byte 	APKoutput[2][2]; //path A/B; output1_1a/output1_2a
-	u1Byte 	bAPKdone;
-	u1Byte 	bAPKThermalMeterIgnore;
-	u1Byte 	bDPdone;
-	u1Byte 	bDPPathAOK;
-	u1Byte 	bDPPathBOK;
-
-	u4Byte 	TxIQC_8723B[2][3][2]; // { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}}
-	u4Byte 	RxIQC_8723B[2][2][2]; // { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}}
-	u4Byte	TxLOK[2];
-
-}ODM_RF_CAL_T,*PODM_RF_CAL_T;
 //
 // ODM Dynamic common info value definition
 //
@@ -1202,6 +1037,7 @@ typedef struct _FAST_ANTENNA_TRAINNING_
 	u1Byte	antsel_rx_keep_0;
 	u1Byte	antsel_rx_keep_1;
 	u1Byte	antsel_rx_keep_2;
+	u1Byte	antsel_rx_keep_3;
 	u4Byte	antSumRSSI[7];
 	u4Byte	antRSSIcnt[7];
 	u4Byte	antAveRSSI[7];
@@ -1225,6 +1061,16 @@ typedef struct _FAST_ANTENNA_TRAINNING_
 	u4Byte    OFDM_counter_main;
 	u4Byte    OFDM_counter_aux;	
 
+
+	u4Byte    CCK_CtrlFrame_Cnt_main;
+	u4Byte    CCK_CtrlFrame_Cnt_aux;
+	u4Byte    OFDM_CtrlFrame_Cnt_main;
+	u4Byte    OFDM_CtrlFrame_Cnt_aux;
+	u4Byte	MainAnt_CtrlFrame_Sum;
+	u4Byte	AuxAnt_CtrlFrame_Sum;
+	u4Byte	MainAnt_CtrlFrame_Cnt;
+	u4Byte	AuxAnt_CtrlFrame_Cnt;
+
 }FAT_T,*pFAT_T;
 
 typedef enum _FAT_STATE
@@ -1244,6 +1090,7 @@ typedef enum _ANT_DIV_TYPE
 	S0S1_SW_ANTDIV          = 0x06 //8723B intrnal switch S0 S1
 }ANT_DIV_TYPE_E, *PANT_DIV_TYPE_E;
 
+
 typedef struct _ODM_PATH_DIVERSITY_
 {
 	u1Byte	RespTxPath;
@@ -1306,10 +1153,9 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 	u8Byte			DebugComponents;
 	u4Byte			DebugLevel;
 	
-	u8Byte			NumQryPhyStatusAll; 	//CCK + OFDM
-	u8Byte			LastNumQryPhyStatusAll; 
-	u8Byte			RxPWDBAve;
-	u8Byte			RxPWDBAve_final;
+	u4Byte			NumQryPhyStatusAll; 	//CCK + OFDM
+	u4Byte			LastNumQryPhyStatusAll; 
+	u4Byte			RxPWDBAve;
 	BOOLEAN			MPDIG_2G; 		//off MPDIG
 	u1Byte			Times_2G;
 	
@@ -1374,6 +1220,10 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 	BOOLEAN			bDualMacSmartConcurrent;
 	u4Byte			BK_SupportAbility;
 	u1Byte			AntDivType;
+
+	u1Byte			odm_Regulation2_4G;
+	u1Byte			odm_Regulation5G;
+	u1Byte			IQKFWOffload;
 //-----------HOOK BEFORE REG INIT-----------//	
 
 	//
@@ -1417,9 +1267,14 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 	//pMgntInfo->AntennaTest
 	u1Byte			*pAntennaTest;
 	BOOLEAN			*pbNet_closed;
-	u1Byte			*mp_mode;
 	//u1Byte			*pAidMap;
 	u1Byte			*pu1ForcedIgiLb;
+	BOOLEAN			*pIsFcsModeEnable;
+//--------- For 8723B IQK-----------//
+	BOOLEAN			*pIs1Antenna;
+	u1Byte			*pRFDefaultPath;
+	// 0:S1, 1:S0
+	
 //--------- POINTER REFERENCE-----------//
 	pu2Byte			pForcedDataRate;
 //------------CALL BY VALUE-------------//
@@ -1427,14 +1282,14 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 	BOOLEAN			bWIFI_Direct;
 	BOOLEAN			bWIFI_Display;
 	BOOLEAN			bLinked;
-
 	BOOLEAN			bsta_state;
 	u1Byte			RSSI_Min;	
 	u1Byte          InterfaceIndex; // Add for 92D  dual MAC: 0--Mac0 1--Mac1
 	BOOLEAN         bIsMPChip;
 	BOOLEAN			bOneEntryOnly;
+	BOOLEAN			mp_mode;
 	// Common info for BTDM
-	BOOLEAN			bBtDisabled;			// BT is disabled
+	BOOLEAN			bBtEnabled;			// BT is enabled
 	BOOLEAN			bBtConnectProcess;	// BT HS is under connection progress.
 	u1Byte			btHsRssi;				// BT HS mode wifi rssi value.
 	BOOLEAN			bBtHsOperation;		// BT HS mode is under progress
@@ -1443,13 +1298,14 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 //------------CALL BY VALUE-------------//
 	u1Byte			RSSI_A;
 	u1Byte			RSSI_B;
+	u1Byte			RSSI_C;
+	u1Byte			RSSI_D;
 	u8Byte			RSSI_TRSW;	
 	u8Byte			RSSI_TRSW_H;
 	u8Byte			RSSI_TRSW_L;	
 	u8Byte			RSSI_TRSW_iso;
 
 	u1Byte			RxRate;
-	BOOLEAN			StopDIG;
 	BOOLEAN			bNoisyState;
 	u1Byte			TxRate;
 	u1Byte			LinkedInterval;
@@ -1478,6 +1334,32 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 	u1Byte			pre_AntType;
 	u1Byte		        antdiv_period;
         u1Byte		        antdiv_select;	
+	u1Byte			NdpaPeriod;
+	BOOLEAN			H2C_RARpt_connect;
+
+	// add by Yu Cehn for adaptivtiy
+	BOOLEAN			adaptivity_flag;
+	u1Byte			tolerance_cnt;
+	u8Byte			NHMCurTxOkcnt;
+	u8Byte			NHMCurRxOkcnt;
+	u8Byte			NHMLastTxOkcnt;
+	u8Byte			NHMLastRxOkcnt;
+	u1Byte			NHMWait;
+	s1Byte			H2L_lb;
+	s1Byte			L2H_lb;
+	u1Byte			Adaptivity_IGI_upper;
+	u2Byte			NHM_cnt_0;
+	u2Byte			NHM_cnt_1;
+	BOOLEAN			Carrier_Sense_enable;
+	BOOLEAN			bFirstLink;
+	BOOLEAN			bCheck;
+	BOOLEAN			EDCCA_enable_state;
+	BOOLEAN			NHM_enable;
+	BOOLEAN			DynamicLinkAdaptivity;
+	BOOLEAN			bAdaOn;
+
+	ODM_NOISE_MONITOR noise_level;//[ODM_MAX_CHANNEL_NUM];
+	//
 	//2 Define STA info.
 	// _ODM_STA_INFO
 	// 2012/01/12 MH For MP, we need to reduce one array pointer for default port.??
@@ -1513,17 +1395,21 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 	//
 	//ODM Structure
 	//
-	FAT_T		DM_FatTable;
-	DIG_T		DM_DigTable;
-	PS_T		DM_PSTable;
-	Pri_CCA_T	DM_PriCCA;
-	RXHP_T		DM_RXHP_Table;
-	RA_T		DM_RA_Table;  
-	FALSE_ALARM_STATISTICS	FalseAlmCnt;
-	FALSE_ALARM_STATISTICS	FlaseAlmCntBuddyAdapter;
+	FAT_T						DM_FatTable;
+	DIG_T						DM_DigTable;
+	PS_T						DM_PSTable;
+	Pri_CCA_T					DM_PriCCA;
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	RXHP_T						DM_RXHP_Table;
+#endif
+	RA_T						DM_RA_Table;  
+	FALSE_ALARM_STATISTICS		FalseAlmCnt;
+	FALSE_ALARM_STATISTICS		FlaseAlmCntBuddyAdapter;
 	//#ifdef CONFIG_ANTENNA_DIVERSITY
-	SWAT_T		DM_SWAT_Table;
-	BOOLEAN		RSSI_test;
+	SWAT_T						DM_SWAT_Table;
+	BOOLEAN						RSSI_test;
+	CFO_TRACKING    				DM_CfoTrack;
+	ACS							DM_ACS;
 	//#endif 
 	
 #if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
@@ -1594,21 +1480,28 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 	s1Byte			Modify_TxAGC_Value;       //Remnat compensate value at TxAGC 
 	BOOLEAN			Modify_TxAGC_Flag_PathA;
 	BOOLEAN			Modify_TxAGC_Flag_PathB;
+	BOOLEAN			Modify_TxAGC_Flag_PathC;
+	BOOLEAN			Modify_TxAGC_Flag_PathD;
 	BOOLEAN			Modify_TxAGC_Flag_PathA_CCK;
+	
+	s1Byte			KfreeOffset[MAX_RF_PATH];
 
 	//
 	// Dynamic ATC switch
 	//
-	BOOLEAN			bATCStatus;
-	BOOLEAN			largeCFOHit;
-	BOOLEAN			bIsfreeze;
-	int				CFO_tail[2];
-	int				CFO_ave_pre;
-	int				CrystalCap;
-	u1Byte			CFOThreshold;
-	u4Byte			packetCount;
-	u4Byte			packetCount_pre;
-	
+
+#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))	
+	//
+	// Power Training
+	//
+	BOOLEAN			bDisablePowerTraining;
+	u1Byte			ForcePowerTrainingState;
+	BOOLEAN			bChangeState;
+	u4Byte			PT_score;
+	u8Byte			OFDM_RX_Cnt;
+	u8Byte			CCK_RX_Cnt;
+#endif
+
 	//
 	// ODM system resource.
 	//
@@ -1630,6 +1523,10 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 	#endif
 #endif
 
+	#if (BEAMFORMING_SUPPORT == 1)
+	RT_BEAMFORMING_INFO BeamformingInfo;
+	#endif 
+
 #if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
 	
 #if (RT_PLATFORM != PLATFORM_LINUX)
@@ -1650,6 +1547,13 @@ typedef  struct DM_Out_Source_Dynamic_Mechanism_Structure
 #define ODM_RF_PATH_MAX 4
 #endif
 
+typedef enum _PhyDM_Structure_Type{
+	PHYDM_FALSEALMCNT,
+	PHYDM_CFOTRACK,
+	PHYDM_ROMINFO,
+	
+}PhyDM_Structure_Type;
+
 typedef enum _ODM_RF_RADIO_PATH {
     ODM_RF_PATH_A = 0,   //Radio Path A
     ODM_RF_PATH_B = 1,   //Radio Path B
@@ -1725,88 +1629,7 @@ typedef enum _RT_STATUS{
 //3 DIG
 //3===========================================================
 
-typedef enum tag_Dynamic_Init_Gain_Operation_Type_Definition
-{
-	DIG_TYPE_THRESH_HIGH	= 0,
-	DIG_TYPE_THRESH_LOW	= 1,
-	DIG_TYPE_BACKOFF		= 2,
-	DIG_TYPE_RX_GAIN_MIN	= 3,
-	DIG_TYPE_RX_GAIN_MAX	= 4,
-	DIG_TYPE_ENABLE 		= 5,
-	DIG_TYPE_DISABLE 		= 6,	
-	DIG_OP_TYPE_MAX
-}DM_DIG_OP_E;
-/*
-typedef enum tag_CCK_Packet_Detection_Threshold_Type_Definition
-{
-	CCK_PD_STAGE_LowRssi = 0,
-	CCK_PD_STAGE_HighRssi = 1,
-	CCK_PD_STAGE_MAX = 3,
-}DM_CCK_PDTH_E;
-
-typedef enum tag_DIG_EXT_PORT_ALGO_Definition
-{
-	DIG_EXT_PORT_STAGE_0 = 0,
-	DIG_EXT_PORT_STAGE_1 = 1,
-	DIG_EXT_PORT_STAGE_2 = 2,
-	DIG_EXT_PORT_STAGE_3 = 3,
-	DIG_EXT_PORT_STAGE_MAX = 4,
-}DM_DIG_EXT_PORT_ALG_E;
-
-typedef enum tag_DIG_Connect_Definition
-{
-	DIG_STA_DISCONNECT = 0,	
-	DIG_STA_CONNECT = 1,
-	DIG_STA_BEFORE_CONNECT = 2,
-	DIG_MultiSTA_DISCONNECT = 3,
-	DIG_MultiSTA_CONNECT = 4,
-	DIG_CONNECT_MAX
-}DM_DIG_CONNECT_E;
-
-
-#define DM_MultiSTA_InitGainChangeNotify(Event) {DM_DigTable.CurMultiSTAConnectState = Event;}
-
-#define DM_MultiSTA_InitGainChangeNotify_CONNECT(_ADAPTER)	\
-	DM_MultiSTA_InitGainChangeNotify(DIG_MultiSTA_CONNECT)
-
-#define DM_MultiSTA_InitGainChangeNotify_DISCONNECT(_ADAPTER)	\
-	DM_MultiSTA_InitGainChangeNotify(DIG_MultiSTA_DISCONNECT)
-*/
-#define		DM_DIG_THRESH_HIGH			40
-#define		DM_DIG_THRESH_LOW			35
-
-#define		DM_FALSEALARM_THRESH_LOW	400
-#define		DM_FALSEALARM_THRESH_HIGH	1000
-
-#define		DM_DIG_MAX_NIC				0x3e
-#define		DM_DIG_MIN_NIC				0x1e //0x22//0x1c
-
-#define		DM_DIG_MAX_AP					0x32
-#define		DM_DIG_MIN_AP					0x20
-
-#define		DM_DIG_MAX_NIC_HP			0x46
-#define		DM_DIG_MIN_NIC_HP			0x2e
-
-#define		DM_DIG_MAX_AP_HP				0x42
-#define		DM_DIG_MIN_AP_HP				0x30
-
-//vivi 92c&92d has different definition, 20110504
-//this is for 92c
-#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
-#define		DM_DIG_FA_TH0				0x80//0x20
-#else
-#define		DM_DIG_FA_TH0				0x200//0x20
-#endif
-#define		DM_DIG_FA_TH1				0x300//0x100
-#define		DM_DIG_FA_TH2				0x400//0x200
-//this is for 92d
-#define		DM_DIG_FA_TH0_92D			0x100
-#define		DM_DIG_FA_TH1_92D			0x400
-#define		DM_DIG_FA_TH2_92D			0x600
-
-#define		DM_DIG_BACKOFF_MAX			12
-#define		DM_DIG_BACKOFF_MIN			-4
-#define		DM_DIG_BACKOFF_DEFAULT		10
+//Remove DIG by Yuchen
 
 //3===========================================================
 //3 AGC RX High Power Mode
@@ -1829,20 +1652,8 @@ typedef enum tag_DIG_Connect_Definition
 //3 Dynamic Tx Power
 //3===========================================================
 //Dynamic Tx Power Control Threshold
-#define		TX_POWER_NEAR_FIELD_THRESH_LVL2	74
-#define		TX_POWER_NEAR_FIELD_THRESH_LVL1	67
-#define		TX_POWER_NEAR_FIELD_THRESH_AP		0x3F
-
-#define		TxHighPwrLevel_Normal		0	
-#define		TxHighPwrLevel_Level1		1
-#define		TxHighPwrLevel_Level2		2
-#define		TxHighPwrLevel_BT1			3
-#define		TxHighPwrLevel_BT2			4
-#define		TxHighPwrLevel_15			5
-#define		TxHighPwrLevel_35			6
-#define		TxHighPwrLevel_50			7
-#define		TxHighPwrLevel_70			8
-#define		TxHighPwrLevel_100			9
+
+//Remove By YuChen
 
 //3===========================================================
 //3 Tx Power Tracking
@@ -1856,24 +1667,12 @@ typedef enum tag_DIG_Connect_Definition
 //3===========================================================
 //3 Rate Adaptive
 //3===========================================================
-#define		DM_RATR_STA_INIT			0
-#define		DM_RATR_STA_HIGH			1
-#define 		DM_RATR_STA_MIDDLE		2
-#define 		DM_RATR_STA_LOW			3
+//Remove to odm_RaInfo.h by RS_James
 
 //3===========================================================
 //3 BB Power Save
 //3===========================================================
 
-
-//3===========================================================
-//3 Dynamic ATC switch
-//3===========================================================
-#define		ATC_Status_Off				0x0			// enable
-#define		ATC_Status_On				0x1			// disable
-#define		CFO_Threshold_Xtal			10			// kHz
-#define		CFO_Threshold_ATC			80			// kHz
-
 typedef enum tag_1R_CCA_Type_Definition
 {
 	CCA_1R =0,
@@ -1905,20 +1704,7 @@ typedef enum tag_SW_Antenna_Switch_Definition
 //
 // Extern Global Variables.
 //
-extern	u4Byte OFDMSwingTable[OFDM_TABLE_SIZE];
-extern	u1Byte CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8];
-extern	u1Byte CCKSwingTable_Ch14 [CCK_TABLE_SIZE][8];
-
-extern	u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE];
-extern	u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8];
-extern	u1Byte CCKSwingTable_Ch14_New [CCK_TABLE_SIZE][8];
-
-extern  u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE];
-
-// <20121018, Kordan> In case fail to read TxPowerTrack.txt, we use the table of 88E as the default table.
-static u1Byte DeltaSwingTableIdx_2GA_P_8188E[] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
-static u1Byte DeltaSwingTableIdx_2GA_N_8188E[] = {0, 0, 0, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11}; 
-
+//remove PT by YuChen
 //
 // check Sta pointer valid or not
 //
@@ -1937,35 +1723,18 @@ static u1Byte DeltaSwingTableIdx_2GA_N_8188E[] = {0, 0, 0, 2, 2, 3, 3, 4, 4, 4,
 #define SWAW_STEP_PEAK		0
 #define SWAW_STEP_DETERMINE	1
 
-VOID ODM_Write_DIG(IN	PDM_ODM_T	pDM_Odm, 	IN	u1Byte	CurrentIGI);
-VOID ODM_Write_CCK_CCA_Thres(IN	PDM_ODM_T	pDM_Odm, IN	u1Byte	CurCCK_CCAThres);
+//Remove DIG by yuchen
 
-VOID
-ODM_SetAntenna(
-	IN 	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte		Antenna);
 
 
-#define dm_RF_Saving	ODM_RF_Saving
-void ODM_RF_Saving(	IN	PDM_ODM_T	pDM_Odm,
-							IN	u1Byte		bForceInNormal );
 
-#define SwAntDivRestAfterLink	ODM_SwAntDivRestAfterLink
-VOID ODM_SwAntDivRestAfterLink(	IN	PDM_ODM_T	pDM_Odm);
+//Remove BB power saving by Yuchen
+
+
+
 
-#define dm_CheckTXPowerTracking 	ODM_TXPowerTrackingCheck
-VOID	
-ODM_TXPowerTrackingCheck(
-	IN		PDM_ODM_T		pDM_Odm
-	);
 						
-BOOLEAN 
-ODM_RAStateCheck(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		s4Byte			RSSI,
-	IN		BOOLEAN			bForceUpdate,
-	OUT		pu1Byte			pRATRState
-	);
+//ODM_RAStateCheck() Remove by RS_James
 
 #if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_AP|ODM_ADSL))
 //============================================================
@@ -1975,75 +1744,22 @@ ODM_RAStateCheck(
 //void	ODM_ChangeDynamicInitGainThresh(IN	PADAPTER	pAdapter,
 //											IN	INT32		DM_Type,
 //											IN	INT32		DM_Value);
-VOID
-ODM_ChangeDynamicInitGainThresh(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte  DM_Type,
-	IN	u4Byte DM_Value
-	);
 
-BOOLEAN
-ODM_CheckPowerStatus(
-	IN	PADAPTER		Adapter
-	);
+//Remove DIG by yuchen
 
 
-#if (DM_ODM_SUPPORT_TYPE != ODM_ADSL) 
-VOID
-ODM_RateAdaptiveStateApInit(
-	IN	PADAPTER	Adapter	,
-	IN	PRT_WLAN_STA  pEntry
-	);
-#endif
-#define AP_InitRateAdaptiveState	ODM_RateAdaptiveStateApInit
-
-
-#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-#ifdef WIFI_WMM
-VOID
-ODM_IotEdcaSwitch(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	unsigned char		enable
-	);
-#endif
-
 BOOLEAN
-ODM_ChooseIotMainSTA(
-	IN	PDM_ODM_T		pDM_Odm,
-	IN	PSTA_INFO_T		pstat
+ODM_CheckPowerStatus(
+	IN	PADAPTER		Adapter
 	);
-#endif
-
-#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
-#ifdef HW_ANT_SWITCH
-u1Byte
-ODM_Diversity_AntennaSelect(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u1Byte	*data
-);
-#endif
-#endif
-
-#define SwAntDivResetBeforeLink		ODM_SwAntDivResetBeforeLink
-VOID ODM_SwAntDivResetBeforeLink(IN	PDM_ODM_T	pDM_Odm);
 
-#define SwAntDivCheckBeforeLink	ODM_SwAntDivCheckBeforeLink
 
-BOOLEAN 
-ODM_SwAntDivCheckBeforeLink(
-	IN		PDM_ODM_T		pDM_Odm
-	);
+//Remove ODM_RateAdaptiveStateApInit() by RS_James
 
+//Remove Edca by YuChen
 
 #endif
 
-#define dm_SWAW_RSSI_Check	ODM_SwAntDivChkPerPktRssi
-VOID ODM_SwAntDivChkPerPktRssi(	
-	IN PDM_ODM_T		pDM_Odm,
-	IN u1Byte			StationID,
-	IN PODM_PHY_INFO_T pPhyInfo
-	);
-
 #if((DM_ODM_SUPPORT_TYPE==ODM_WIN)||(DM_ODM_SUPPORT_TYPE==ODM_CE))
 
 u4Byte ConvertTo_dB(u4Byte Value);
@@ -2056,57 +1772,7 @@ GetPSDData(
 
 #endif
 
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
-
-VOID
-odm_DIGbyRSSI_LPS(
-	IN		PDM_ODM_T		pDM_Odm
-	);
-
-u4Byte ODM_Get_Rate_Bitmap(
-	IN	PDM_ODM_T	pDM_Odm,
-	IN	u4Byte		macid,
-	IN	u4Byte 		ra_mask,	
-	IN	u1Byte 		rssi_level);
-
-#endif
-	
-
-#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN))
-#define	dm_PSDMonitorCallback	odm_PSDMonitorCallback
-VOID	odm_PSDMonitorCallback(PRT_TIMER		pTimer);
-
-VOID
-odm_PSDMonitorWorkItemCallback(
-    IN PVOID            pContext
-    );
-
-VOID
-ODM_MPT_DIG(
-	IN	PDM_ODM_T	pDM_Odm
-);
-
-VOID
-PatchDCTone(
-	IN	PDM_ODM_T	pDM_Odm,
-	pu4Byte		PSD_report,
-	u1Byte 		initial_gain_psd
-);
-VOID
-ODM_PSDMonitor(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-VOID	odm_PSD_Monitor(PDM_ODM_T	pDM_Odm);
-VOID	odm_PSDMonitorInit(PDM_ODM_T 	pDM_Odm);
-
-VOID
-ODM_PSDDbgControl(
-	IN	PADAPTER	Adapter,
-	IN	u4Byte		mode,
-	IN	u4Byte		btRssi
-	);
-
-#endif	// DM_ODM_SUPPORT_TYPE
+//Remove ODM_Get_Rate_Bitmap() by RS_James	
 
 
 #if (BEAMFORMING_SUPPORT == 1)
@@ -2117,9 +1783,15 @@ Beamforming_GetEntryBeamCapByMacId(
  );
 #endif
 
+VOID 
+ODM_DMInit(
+ IN	PDM_ODM_T	pDM_Odm
+);
 
-
-VOID ODM_DMInit( IN	PDM_ODM_T	pDM_Odm);
+VOID
+ODM_DMReset(
+	IN	PDM_ODM_T	pDM_Odm
+	);
 
 VOID
 ODM_DMWatchdog(
@@ -2180,11 +1852,6 @@ ODM_ResetIQKResult(
 VOID ODM_InitAllWorkItems(IN PDM_ODM_T	pDM_Odm );
 VOID ODM_FreeAllWorkItems(IN PDM_ODM_T	pDM_Odm );
 
-VOID odm_PathDivChkAntSwitch(PDM_ODM_T pDM_Odm);
-VOID ODM_PathDivRestAfterLink(
-	IN	PDM_ODM_T		pDM_Odm
-	);
-
 
 //===========================================//
 // Neil Chen----2011--06--15--
@@ -2199,17 +1866,7 @@ VOID ODM_PathDivRestAfterLink(
 
 //#define   PATHDIV_ENABLE 	 1
 
-//VOID odm_PathDivChkAntSwitch(PADAPTER	Adapter,u1Byte	Step);
-VOID ODM_PathDivRestAfterLink(
-	IN	PDM_ODM_T	pDM_Odm
-	);
-
-#define dm_PathDiv_RSSI_Check	ODM_PathDivChkPerPktRssi
-VOID ODM_PathDivChkPerPktRssi(PADAPTER		Adapter,
-										BOOLEAN			bIsDefPort,
-										BOOLEAN			bMatchBSSID,
-										PRT_WLAN_STA	pEntry,
-										PRT_RFD			pRfd	);
+//#define dm_PathDiv_RSSI_Check	ODM_PathDivChkPerPktRssi
 
 u8Byte
 PlatformDivision64(
@@ -2230,12 +1887,7 @@ PlatformDivision64(
 //3 PathDiV End
 //====================================================
 
-#define PathDivCheckBeforeLink8192C	ODM_PathDiversityBeforeLink92C
-BOOLEAN 
-ODM_PathDiversityBeforeLink92C(
-	//IN	PADAPTER	Adapter
-	IN		PDM_ODM_T		pDM_Odm
-	);
+//#define PathDivCheckBeforeLink8192C	ODM_PathDiversityBeforeLink92C
 
 #define DM_ChangeDynamicInitGainThresh		ODM_ChangeDynamicInitGainThresh
 //void	ODM_ChangeDynamicInitGainThresh(IN	PADAPTER	pAdapter,
@@ -2243,18 +1895,6 @@ ODM_PathDiversityBeforeLink92C(
 //											IN	INT32		DM_Value);
 //
 
-
-VOID
-ODM_CCKPathDiversityChkPerPktRssi(
-	PADAPTER		Adapter,
-	BOOLEAN			bIsDefPort,
-	BOOLEAN			bMatchBSSID,
-	PRT_WLAN_STA	pEntry,
-	PRT_RFD			pRfd,
-	pu1Byte			pDesc
-	);
-
-
 typedef enum tag_DIG_Connect_Definition
 {
 	DIG_STA_DISCONNECT = 0,	
@@ -2266,16 +1906,6 @@ typedef enum tag_DIG_Connect_Definition
 }DM_DIG_CONNECT_E;
 
 
-VOID
-ODM_FillTXPathInTXDESC(
-		IN	PADAPTER	Adapter,
-		IN	PRT_TCB		pTcb,
-		IN	pu1Byte		pDesc
-);
-
-
-#define dm_SWAW_RSSI_Check	ODM_SwAntDivChkPerPktRssi
-
 //
 // 2012/01/12 MH Check afapter status. Temp fix BSOD.
 //
@@ -2295,21 +1925,10 @@ ODM_FillTXPathInTXDESC(
 	IS_HARDWARE_TYPE_8723A(_Adapter) ? odm_TXPowerTrackingCallback_ThermalMeter_8723A(_Adapter) :\
 	ODM_TXPowerTrackingCallback_ThermalMeter(_Adapter)
 
-VOID
-ODM_SetTxAntByTxInfo_88C_92D(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		pu1Byte			pDesc,
-	IN		u1Byte			macId	
-	);
+
 
 #endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-VOID
-ODM_AntselStatistics_88C(
-	IN		PDM_ODM_T		pDM_Odm,
-	IN		u1Byte			MacId,
-	IN		u4Byte			PWDBAll,
-	IN		BOOLEAN			isCCKrate
-);
+
 
 #if( DM_ODM_SUPPORT_TYPE & (ODM_WIN |ODM_CE))
 
@@ -2324,12 +1943,6 @@ ODM_SingleDualAntennaDetection(
 	IN		u1Byte			mode
 	);
 
-VOID
-ODM_DynamicATCSwitch(
-	IN 		PDM_ODM_T 		pDM_Odm
-);
-
-
 #endif	// #if((DM_ODM_SUPPORT_TYPE==ODM_WIN)||(DM_ODM_SUPPORT_TYPE==ODM_CE))
 VOID
 ODM_UpdateNoisyState(
@@ -2352,11 +1965,32 @@ ODM_UpdateInitRate(
 	);
 
 VOID
-ODM_DynamicARFBSelect(
+ODM_InitializeTimer(
+	IN 	PDM_ODM_T			pDM_Odm,
+	IN	PRT_TIMER 			pTimer, 
+	IN	RT_TIMER_CALL_BACK	CallBackFunc, 
+	IN	PVOID				pContext,
+	IN	const char*			szID
+);
+
+VOID
+ODM_CancelAllTimers(
+	IN PDM_ODM_T	pDM_Odm 
+);
+
+VOID
+ODM_ReleaseAllTimers(
+	IN PDM_ODM_T	pDM_Odm 
+);
+
+//Remove ODM_DynamicARFBSelect() by RS_James
+
+PVOID
+PhyDM_Get_Structure(
 	IN		PDM_ODM_T		pDM_Odm,
-	IN 		u1Byte			rate,
-	IN  		BOOLEAN			Collision_State	
-	);
+	IN		u1Byte			Structure_Type
+);
+
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_CE)
 void odm_dtc(PDM_ODM_T pDM_Odm);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_ACS.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_ACS.c
new file mode 100644
index 000000000000..f82846d71e6c
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_ACS.c
@@ -0,0 +1,213 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+
+u1Byte
+ODM_GetAutoChannelSelectResult(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Band
+)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PACS					pACS = &pDM_Odm->DM_ACS;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	if(Band == ODM_BAND_2_4G)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("[ACS] ODM_GetAutoChannelSelectResult(): CleanChannel_2G(%d)\n", pACS->CleanChannel_2G));
+		return (u1Byte)pACS->CleanChannel_2G;	
+	}
+	else
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("[ACS] ODM_GetAutoChannelSelectResult(): CleanChannel_5G(%d)\n", pACS->CleanChannel_5G));
+		return (u1Byte)pACS->CleanChannel_5G;	
+	}
+#else
+	return (u1Byte)pACS->CleanChannel_2G;
+#endif
+
+}
+
+VOID
+odm_AutoChannelSelectSetting(
+	IN		PVOID			pDM_VOID,
+	IN		BOOLEAN			IsEnable
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u2Byte						period = 0x2710;// 40ms in default
+	u2Byte						NHMType = 0x7;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelectSetting()=========> \n"));
+
+	if(IsEnable)
+	{//20 ms
+		period = 0x1388;
+		NHMType = 0x1;
+	}
+
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+	{
+		//PHY parameters initialize for ac series
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11AC+2, period);	//0x990[31:16]=0x2710	Time duration for NHM unit: 4us, 0x2710=40ms
+		//ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11AC, BIT8|BIT9|BIT10, NHMType);	//0x994[9:8]=3			enable CCX
+	}
+	else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+		//PHY parameters initialize for n series
+		ODM_Write2Byte(pDM_Odm, ODM_REG_NHM_TIMER_11N+2, period);	//0x894[31:16]=0x2710	Time duration for NHM unit: 4us, 0x2710=40ms
+		//ODM_SetBBReg(pDM_Odm, ODM_REG_NHM_TH9_TH10_11N, BIT10|BIT9|BIT8, NHMType);	//0x890[9:8]=3			enable CCX		
+	}
+#endif
+}
+
+VOID
+odm_AutoChannelSelectInit(
+	IN		PVOID			pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PACS						pACS = &pDM_Odm->DM_ACS;
+	u1Byte						i;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_NHM_CNT))
+		return;
+
+	if(pACS->bForceACSResult)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelectInit()=========> \n"));
+
+	pACS->CleanChannel_2G = 1;
+	pACS->CleanChannel_5G = 36;
+
+	for (i = 0; i < ODM_MAX_CHANNEL_2G; ++i)
+	{
+		pACS->Channel_Info_2G[0][i] = 0;
+		pACS->Channel_Info_2G[1][i] = 0;
+	}
+
+	if(pDM_Odm->SupportICType & (ODM_IC_11AC_SERIES|ODM_RTL8192D))
+	{
+		for (i = 0; i < ODM_MAX_CHANNEL_5G; ++i)
+		{
+			pACS->Channel_Info_5G[0][i] = 0;
+			pACS->Channel_Info_5G[1][i] = 0;
+		}
+	}
+#endif
+}
+
+VOID
+odm_AutoChannelSelectReset(
+	IN		PVOID			pDM_VOID
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PACS						pACS = &pDM_Odm->DM_ACS;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_NHM_CNT))
+		return;
+
+	if(pACS->bForceACSResult)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelectReset()=========> \n"));
+
+	odm_AutoChannelSelectSetting(pDM_Odm,TRUE);// for 20ms measurement
+	Phydm_NHMCounterStatisticsReset(pDM_Odm);
+#endif
+}
+
+VOID
+odm_AutoChannelSelect(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Channel
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PACS						pACS = &pDM_Odm->DM_ACS;
+	u1Byte						ChannelIDX = 0, SearchIDX = 0;
+	u2Byte						MaxScore=0;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_NHM_CNT))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): Return: SupportAbility ODM_BB_NHM_CNT is disabled\n"));
+		return;
+	}
+
+	if(pACS->bForceACSResult)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): Force 2G clean channel = %d, 5G clean channel = %d\n",
+			pACS->CleanChannel_2G, pACS->CleanChannel_5G));
+		return;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): Channel = %d=========> \n", Channel));
+
+	Phydm_GetNHMCounterStatistics(pDM_Odm);
+	odm_AutoChannelSelectSetting(pDM_Odm,FALSE);
+
+	if(Channel >=1 && Channel <=14)
+	{
+		ChannelIDX = Channel - 1;
+		pACS->Channel_Info_2G[1][ChannelIDX]++;
+		
+		if(pACS->Channel_Info_2G[1][ChannelIDX] >= 2)
+			pACS->Channel_Info_2G[0][ChannelIDX] = (pACS->Channel_Info_2G[0][ChannelIDX] >> 1) + 
+			(pACS->Channel_Info_2G[0][ChannelIDX] >> 2) + (pDM_Odm->NHM_cnt_0>>2);
+		else
+			pACS->Channel_Info_2G[0][ChannelIDX] = pDM_Odm->NHM_cnt_0;
+	
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): NHM_cnt_0 = %d \n", pDM_Odm->NHM_cnt_0));
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("odm_AutoChannelSelect(): Channel_Info[0][%d] = %d, Channel_Info[1][%d] = %d\n", ChannelIDX, pACS->Channel_Info_2G[0][ChannelIDX], ChannelIDX, pACS->Channel_Info_2G[1][ChannelIDX]));
+
+		for(SearchIDX = 0; SearchIDX < ODM_MAX_CHANNEL_2G; SearchIDX++)
+		{
+			if(pACS->Channel_Info_2G[1][SearchIDX] != 0)
+			{
+				if(pACS->Channel_Info_2G[0][SearchIDX] >= MaxScore)
+				{
+					MaxScore = pACS->Channel_Info_2G[0][SearchIDX];
+					pACS->CleanChannel_2G = SearchIDX+1;
+				}
+			}
+		}
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_ACS, ODM_DBG_LOUD, ("(1)odm_AutoChannelSelect(): 2G: CleanChannel_2G = %d, MaxScore = %d \n", 
+			pACS->CleanChannel_2G, MaxScore));
+
+	}
+	else if(Channel >= 36)
+	{
+		// Need to do
+		pACS->CleanChannel_5G = Channel;
+	}
+#endif
+}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_ACS.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_ACS.h
new file mode 100644
index 000000000000..d24c4c63bbde
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_ACS.h
@@ -0,0 +1,61 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMACS_H__
+#define    __PHYDMACS_H__
+
+#define ACS_VERSION	"1.0"
+
+#define ODM_MAX_CHANNEL_2G			14
+#define ODM_MAX_CHANNEL_5G			24
+
+typedef struct _ACS_
+{
+	BOOLEAN		bForceACSResult;
+	u1Byte		CleanChannel_2G;
+	u1Byte		CleanChannel_5G;
+	u2Byte		Channel_Info_2G[2][ODM_MAX_CHANNEL_2G];		//Channel_Info[1]: Channel Score, Channel_Info[2]:Channel_Scan_Times
+	u2Byte		Channel_Info_5G[2][ODM_MAX_CHANNEL_5G];	
+}ACS, *PACS;
+
+
+VOID
+odm_AutoChannelSelectInit(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+odm_AutoChannelSelectReset(
+	IN		PVOID			pDM_VOID
+);
+
+VOID
+odm_AutoChannelSelect(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Channel
+);
+
+u1Byte
+ODM_GetAutoChannelSelectResult(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			Band
+);
+
+#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDect.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDect.c
new file mode 100644
index 000000000000..d6a1c5d86faf
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDect.c
@@ -0,0 +1,1206 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN |ODM_CE))
+
+//IS_ANT_DETECT_SUPPORT_SINGLE_TONE(Adapter)	
+//IS_ANT_DETECT_SUPPORT_RSSI(Adapter)		
+//IS_ANT_DETECT_SUPPORT_PSD(Adapter)
+
+//1 [1. Single Tone Method] ===================================================
+
+
+VOID
+odm_PHY_SaveAFERegisters(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	pu4Byte		AFEReg,
+	IN	pu4Byte		AFEBackup,
+	IN	u4Byte		RegisterNum
+	)
+{
+	u4Byte	i;
+	
+	//RT_DISP(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
+	for( i = 0 ; i < RegisterNum ; i++){
+		AFEBackup[i] = ODM_GetBBReg(pDM_Odm, AFEReg[i], bMaskDWord);
+	}
+}
+
+VOID
+odm_PHY_ReloadAFERegisters(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	pu4Byte		AFEReg,
+	IN	pu4Byte		AFEBackup,
+	IN	u4Byte		RegiesterNum
+	)
+{
+	u4Byte	i;
+
+	//RT_DISP(FINIT, INIT_IQK, ("Reload ADDA power saving parameters !\n"));
+	for(i = 0 ; i < RegiesterNum; i++)
+	{
+	
+		ODM_SetBBReg(pDM_Odm, AFEReg[i], bMaskDWord, AFEBackup[i]);
+	}
+}
+
+//
+// Description:
+//	Set Single/Dual Antenna default setting for products that do not do detection in advance.
+//
+// Added by Joseph, 2012.03.22
+//
+VOID
+ODM_SingleDualAntennaDefaultSetting(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+
+	u1Byte btAntNum=BT_GetPgAntNum(pAdapter);
+	// Set default antenna A and B status
+	if(btAntNum == 2)
+	{
+		pDM_SWAT_Table->ANTA_ON=TRUE;
+		pDM_SWAT_Table->ANTB_ON=TRUE;
+	
+	}
+	else if(btAntNum == 1)
+	{// Set antenna A as default
+		pDM_SWAT_Table->ANTA_ON=TRUE;
+		pDM_SWAT_Table->ANTB_ON=FALSE;
+	
+	}
+	else
+	{
+		RT_ASSERT(FALSE, ("Incorrect antenna number!!\n"));
+	}
+}
+
+
+//2 8723A ANT DETECT
+//
+// Description:
+//	Implement IQK single tone for RF DPK loopback and BB PSD scanning. 
+//	This function is cooperated with BB team Neil. 
+//
+// Added by Roger, 2011.12.15
+//
+BOOLEAN
+ODM_SingleDualAntennaDetection(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			mode
+	)
+{
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	u4Byte		CurrentChannel,RfLoopReg;
+	u1Byte		n;
+	u4Byte		Reg88c, Regc08, Reg874, Regc50, Reg948, Regb2c, Reg92c, Reg930, Reg064, AFE_rRx_Wait_CCA;
+	u1Byte		initial_gain = 0x5a;
+	u4Byte		PSD_report_tmp;
+	u4Byte		AntA_report = 0x0, AntB_report = 0x0,AntO_report=0x0,temp;
+	BOOLEAN		bResult = TRUE;
+	u4Byte		AFE_Backup[16];
+	u4Byte		AFE_REG_8723A[16] = {
+					rRx_Wait_CCA, 	rTx_CCK_RFON, 
+					rTx_CCK_BBON, 	rTx_OFDM_RFON,
+					rTx_OFDM_BBON, 	rTx_To_Rx,
+					rTx_To_Tx, 		rRx_CCK, 
+					rRx_OFDM, 		rRx_Wait_RIFS, 
+					rRx_TO_Rx,		rStandby,
+					rSleep,			rPMPD_ANAEN, 	
+					rFPGA0_XCD_SwitchControl, rBlue_Tooth};
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection()============> \n"));	
+
+	
+	if(!(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C|ODM_RTL8723B)))
+		return bResult;
+
+	// Retrieve antenna detection registry info, added by Roger, 2012.11.27.
+	if(!IS_ANT_DETECT_SUPPORT_SINGLE_TONE(pAdapter))
+		return bResult;
+
+	if(pDM_Odm->SupportICType == ODM_RTL8192C)
+	{
+		//Which path in ADC/DAC is turnned on for PSD: both I/Q
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT10|BIT11, 0x3);
+		//Ageraged number: 8
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT12|BIT13, 0x1);
+		//pts = 128;
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
+	}
+
+	//1 Backup Current RF/BB Settings	
+	
+	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask);
+	RfLoopReg = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask);
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_A);  // change to Antenna A
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		Reg92c = ODM_GetBBReg(pDM_Odm, rDPDT_control, bMaskDWord);	
+		Reg930 = ODM_GetBBReg(pDM_Odm, rfe_ctrl_anta_src, bMaskDWord);
+		Reg948 = ODM_GetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord);
+		Regb2c = ODM_GetBBReg(pDM_Odm, rAGC_table_select, bMaskDWord);
+		Reg064 = ODM_GetMACReg(pDM_Odm, rSYM_WLBT_PAPE_SEL, BIT29);
+		ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x1);
+		ODM_SetBBReg(pDM_Odm, rfe_ctrl_anta_src, 0xff, 0x77);
+		ODM_SetMACReg(pDM_Odm, rSYM_WLBT_PAPE_SEL, BIT29, 0x1);  //dbg 7
+		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0x3c0, 0x0);//dbg 8
+		ODM_SetBBReg(pDM_Odm, rAGC_table_select, BIT31, 0x0);
+	}
+
+	ODM_StallExecution(10);
+	
+	//Store A Path Register 88c, c08, 874, c50
+	Reg88c = ODM_GetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord);
+	Regc08 = ODM_GetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord);
+	Reg874 = ODM_GetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord);
+	Regc50 = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord);	
+	
+	// Store AFE Registers
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	odm_PHY_SaveAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);	
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		AFE_rRx_Wait_CCA = ODM_GetBBReg(pDM_Odm, rRx_Wait_CCA,bMaskDWord);
+	
+	//Set PSD 128 pts
+	ODM_SetBBReg(pDM_Odm, rFPGA0_PSDFunction, BIT14|BIT15, 0x0);  //128 pts
+	
+	// To SET CH1 to do
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask, 0x7401);     //Channel 1
+	
+	// AFE all on step
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	{
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_CCK_RFON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_CCK_BBON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_OFDM_RFON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_OFDM_BBON, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_To_Rx, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rTx_To_Tx, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_CCK, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_OFDM, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_RIFS, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rRx_TO_Rx, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rStandby, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rSleep, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rPMPD_ANAEN, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_SwitchControl, bMaskDWord, 0x6FDB25A4);
+		ODM_SetBBReg(pDM_Odm, rBlue_Tooth, bMaskDWord, 0x6FDB25A4);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x01c00016);
+	}
+
+	// 3 wire Disable
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, 0xCCF000C0);
+	
+	//BB IQK Setting
+	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, 0x000800E4);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
+
+	//IQK setting tone@ 4.34Mhz
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x10008C1C);
+	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);	
+
+	//Page B init
+	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x00080000);
+	ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x0f600000);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	{
+	ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82150008);
+	ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28150008);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		ODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82150016);
+		ODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28150016);
+	}
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x001028d0);	
+	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, 0x7f, initial_gain);
+
+	//RF loop Setting
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x0, 0xFFFFF, 0x50008);	
+	
+	//IQK Single tone start
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x808000);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	ODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	
+	ODM_StallExecution(10000);
+
+	// PSD report of antenna A
+	PSD_report_tmp=0x0;
+	for (n=0;n<2;n++)
+ 	{
+ 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
+		if(PSD_report_tmp >AntA_report)
+			AntA_report=PSD_report_tmp;
+	}
+
+	 // change to Antenna B
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_B); 
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		//ODM_SetBBReg(pDM_Odm, rDPDT_control, 0x3, 0x2);
+		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0xfff, 0x280);
+		ODM_SetBBReg(pDM_Odm, rAGC_table_select, BIT31, 0x1);
+	}
+
+	ODM_StallExecution(10);	
+
+	// PSD report of antenna B
+	PSD_report_tmp=0x0;
+	for (n=0;n<2;n++)
+ 	{
+ 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
+		if(PSD_report_tmp > AntB_report)
+			AntB_report=PSD_report_tmp;
+	}
+
+	// change to open case
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+	{
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, 0);  // change to Antenna A
+
+		ODM_StallExecution(10);	
+		
+		// PSD report of open case
+		PSD_report_tmp=0x0;
+		for (n=0;n<2;n++)
+	 	{
+	 		PSD_report_tmp =  GetPSDData(pDM_Odm, 14, initial_gain);	
+			if(PSD_report_tmp > AntO_report)
+				AntO_report=PSD_report_tmp;
+		}
+	}
+	//Close IQK Single Tone function
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, 0xffffff00, 0x000000);
+
+	//1 Return to antanna A
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+		ODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_A);  // change to Antenna A
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		// external DPDT
+		ODM_SetBBReg(pDM_Odm, rDPDT_control, bMaskDWord, Reg92c);
+
+		//internal S0/S1
+		ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord, Reg948);
+		ODM_SetBBReg(pDM_Odm, rAGC_table_select, bMaskDWord, Regb2c);
+		ODM_SetBBReg(pDM_Odm, rfe_ctrl_anta_src, bMaskDWord, Reg930);
+		ODM_SetMACReg(pDM_Odm, rSYM_WLBT_PAPE_SEL, BIT29, Reg064);
+	}
+	
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, Reg88c);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, Regc08);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, Reg874);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, 0x7F, 0x40);
+	ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord, Regc50);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask,CurrentChannel);
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x00, bRFRegOffsetMask,RfLoopReg);
+
+	//Reload AFE Registers
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C))
+		odm_PHY_ReloadAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);	
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		ODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, AFE_rRx_Wait_CCA);
+
+	if(pDM_Odm->SupportICType == ODM_RTL8723A)
+	{
+		//2 Test Ant B based on Ant A is ON
+		if(mode==ANTTESTB)
+		{
+			if(AntA_report >=	100)
+			{
+				if(AntB_report > (AntA_report+1))
+				{
+					pDM_SWAT_Table->ANTB_ON=FALSE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));		
+				}	
+				else
+				{
+					pDM_SWAT_Table->ANTB_ON=TRUE;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n"));	
+				}	
+			}
+			else
+			{
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+				pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
+				bResult = FALSE;
+			}
+		}	
+		//2 Test Ant A and B based on DPDT Open
+		else if(mode==ANTTESTALL)
+		{
+			if((AntO_report >=100) && (AntO_report <=118))
+			{
+				if(AntA_report > (AntO_report+1))
+				{
+					pDM_SWAT_Table->ANTA_ON=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant A is OFF\n"));
+				}	
+				else
+				{
+					pDM_SWAT_Table->ANTA_ON=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant A is ON\n"));
+				}
+
+				if(AntB_report > (AntO_report+2))
+				{
+					pDM_SWAT_Table->ANTB_ON=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant B is OFF\n"));
+				}	
+				else
+				{
+					pDM_SWAT_Table->ANTB_ON=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Ant B is ON\n"));
+				}
+				
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d \n", 2416, AntA_report));	
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d \n", 2416, AntB_report));	
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_O[%d]= %d \n", 2416, AntO_report));
+				
+				pDM_Odm->AntDetectedInfo.bAntDetected= TRUE;
+				pDM_Odm->AntDetectedInfo.dBForAntA = AntA_report;
+				pDM_Odm->AntDetectedInfo.dBForAntB = AntB_report;
+				pDM_Odm->AntDetectedInfo.dBForAntO = AntO_report;
+				
+				}
+			else
+				{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("return FALSE!!\n"));
+				bResult = FALSE;
+			}
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8192C)
+	{
+		if(AntA_report >=	100)
+		{
+			if(AntB_report > (AntA_report+2))
+			{
+				pDM_SWAT_Table->ANTA_ON=FALSE;
+				pDM_SWAT_Table->ANTB_ON=TRUE;
+				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_B);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna B\n"));		
+			}	
+			else if(AntA_report > (AntB_report+2))
+			{
+				pDM_SWAT_Table->ANTA_ON=TRUE;
+				pDM_SWAT_Table->ANTB_ON=FALSE;
+				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_A);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));
+			}	
+			else
+			{
+				pDM_SWAT_Table->ANTA_ON=TRUE;
+				pDM_SWAT_Table->ANTB_ON=TRUE;
+			}
+		}
+		else
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+			pDM_SWAT_Table->ANTA_ON=TRUE; // Set Antenna A on as default 
+			pDM_SWAT_Table->ANTB_ON=FALSE; // Set Antenna B off as default 
+			bResult = FALSE;
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d \n", 2416, AntA_report));	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d \n", 2416, AntB_report));	
+		
+		//2 Test Ant B based on Ant A is ON
+		if((AntA_report >= 100) && (AntB_report >= 100) && (AntA_report <= 135) && (AntB_report <= 135))
+		{
+			u1Byte TH1=2, TH2=6;
+		
+			if((AntA_report - AntB_report < TH1) || (AntB_report - AntA_report < TH1))
+			{
+				pDM_SWAT_Table->ANTA_ON=TRUE;
+				pDM_SWAT_Table->ANTB_ON=TRUE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Dual Antenna\n"));
+			}
+			else if(((AntA_report - AntB_report >= TH1) && (AntA_report - AntB_report <= TH2)) || 
+				((AntB_report - AntA_report >= TH1) && (AntB_report - AntA_report <= TH2)))
+			{
+				pDM_SWAT_Table->ANTA_ON=FALSE;
+				pDM_SWAT_Table->ANTB_ON=FALSE;
+				bResult = FALSE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));
+			}
+			else
+			{
+				pDM_SWAT_Table->ANTA_ON = TRUE;
+				pDM_SWAT_Table->ANTB_ON=FALSE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SingleDualAntennaDetection(): Single Antenna\n"));
+			}
+			pDM_Odm->AntDetectedInfo.bAntDetected= TRUE;
+			pDM_Odm->AntDetectedInfo.dBForAntA = AntA_report;
+			pDM_Odm->AntDetectedInfo.dBForAntB = AntB_report;
+			pDM_Odm->AntDetectedInfo.dBForAntO = AntO_report;
+				
+		}
+		else
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("return FALSE!!\n"));
+			bResult = FALSE;
+		}
+	}
+	return bResult;
+
+}
+
+
+
+//1 [2. Scan AP RSSI Method] ==================================================
+
+
+void
+odm_SwAntDetectInit(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	
+	//pDM_SWAT_Table->SWAS_NoLink_BK_Reg92c = ODM_Read4Byte(pDM_Odm, rDPDT_control);
+	//pDM_SWAT_Table->PreAntenna = MAIN_ANT;
+	//pDM_SWAT_Table->CurAntenna = MAIN_ANT;
+	pDM_SWAT_Table->SWAS_NoLink_State = 0;
+	pDM_SWAT_Table->Pre_Aux_FailDetec = FALSE;
+	pDM_SWAT_Table->SWAS_NoLink_BK_Reg948 = 0xff;
+}
+
+
+BOOLEAN
+ODM_SwAntDivCheckBeforeLink(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+
+#if (RT_MEM_SIZE_LEVEL != RT_MEM_SIZE_MINIMUM)
+
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
+	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+	s1Byte			Score = 0;
+	PRT_WLAN_BSS	pTmpBssDesc, pTestBssDesc;
+	u1Byte 			power_target = 10, power_target_L = 9, power_target_H = 16;
+	u1Byte			tmp_power_diff = 0,power_diff = 0,avg_power_diff = 0,max_power_diff = 0,min_power_diff = 0xff;
+	u2Byte			index, counter = 0;
+	static u1Byte		ScanChannel;
+	u8Byte			tStamp_diff = 0;		
+	u4Byte			tmp_SWAS_NoLink_BK_Reg948;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ANTA_ON = (( %d )) , ANTB_ON = (( %d )) \n",pDM_Odm->DM_SWAT_Table.ANTA_ON ,pDM_Odm->DM_SWAT_Table.ANTB_ON ));
+
+	//if(HP id)
+	{
+		if(pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult==TRUE && pDM_Odm->SupportICType == ODM_RTL8723B)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("8723B RSSI-based Antenna Detection is done\n"));
+			return FALSE;
+		}
+		
+		if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		{
+			if(pDM_SWAT_Table->SWAS_NoLink_BK_Reg948 == 0xff)
+				pDM_SWAT_Table->SWAS_NoLink_BK_Reg948 = ODM_Read4Byte(pDM_Odm, rS0S1_PathSwitch );
+		}
+	}
+
+	if (pDM_Odm->Adapter == NULL)  //For BSOD when plug/unplug fast.  //By YJ,120413
+	{	// The ODM structure is not initialized.
+		return FALSE;
+	}
+
+	// Retrieve antenna detection registry info, added by Roger, 2012.11.27.
+	if(!IS_ANT_DETECT_SUPPORT_RSSI(Adapter))
+	{
+		return FALSE;
+	}
+	else
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Antenna Detection: RSSI Method\n"));	
+	}
+
+	// Since driver is going to set BB register, it shall check if there is another thread controlling BB/RF.
+	PlatformAcquireSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	if(pHalData->eRFPowerState!=eRfOn || pMgntInfo->RFChangeInProgress || pMgntInfo->bMediaConnect)
+	{
+		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+				("ODM_SwAntDivCheckBeforeLink(): RFChangeInProgress(%x), eRFPowerState(%x)\n", 
+				pMgntInfo->RFChangeInProgress, pHalData->eRFPowerState));
+	
+		pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		
+		return FALSE;
+	}
+	else
+	{
+		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("pDM_SWAT_Table->SWAS_NoLink_State = %d\n", pDM_SWAT_Table->SWAS_NoLink_State));
+	//1 Run AntDiv mechanism "Before Link" part.
+	if(pDM_SWAT_Table->SWAS_NoLink_State == 0)
+	{
+		//1 Prepare to do Scan again to check current antenna state.
+
+		// Set check state to next step.
+		pDM_SWAT_Table->SWAS_NoLink_State = 1;
+	
+		// Copy Current Scan list.
+		pMgntInfo->tmpNumBssDesc = pMgntInfo->NumBssDesc;
+		PlatformMoveMemory((PVOID)Adapter->MgntInfo.tmpbssDesc, (PVOID)pMgntInfo->bssDesc, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC);
+		
+		// Go back to scan function again.
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Scan one more time\n"));
+		pMgntInfo->ScanStep=0;
+		pMgntInfo->bScanAntDetect = TRUE;
+		ScanChannel = odm_SwAntDivSelectScanChnl(Adapter);
+
+		
+		if(pDM_Odm->SupportICType & (ODM_RTL8188E|ODM_RTL8821))
+		{
+			if(pDM_FatTable->RxIdleAnt == MAIN_ANT)
+				ODM_UpdateRxIdleAnt(pDM_Odm, AUX_ANT);
+			else
+				ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
+			if(ScanChannel == 0)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+					("ODM_SwAntDivCheckBeforeLink(): No AP List Avaiable, Using Ant(%s)\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"AUX_ANT":"MAIN_ANT"));
+
+				if(IS_5G_WIRELESS_MODE(pMgntInfo->dot11CurrentWirelessMode))
+				{
+					pDM_SWAT_Table->Ant5G = pDM_FatTable->RxIdleAnt;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant5G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+				}
+				else
+				{
+					pDM_SWAT_Table->Ant2G = pDM_FatTable->RxIdleAnt;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant2G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+				}
+				return FALSE;
+			}
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+				("ODM_SwAntDivCheckBeforeLink: Change to %s for testing.\n", ((pDM_FatTable->RxIdleAnt == MAIN_ANT)?"MAIN_ANT":"AUX_ANT")));
+		}
+		else if(pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8723B))
+		{
+			if(pDM_Odm->SupportICType == ODM_RTL8192C)
+			{
+			// Switch Antenna to another one.
+			pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+			pDM_SWAT_Table->CurAntenna = (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?AUX_ANT:MAIN_ANT;
+			
+				pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
+				ODM_SetBBReg(pDM_Odm,  rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
+			}
+			else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+			{
+				// Switch Antenna to another one.
+				
+				tmp_SWAS_NoLink_BK_Reg948 = ODM_Read4Byte(pDM_Odm, rS0S1_PathSwitch );
+				
+				if( (pDM_SWAT_Table->CurAntenna = MAIN_ANT) && (tmp_SWAS_NoLink_BK_Reg948==0x200))
+				{
+					ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0xfff, 0x280);
+					ODM_SetBBReg(pDM_Odm, rAGC_table_select, BIT31, 0x1);
+					pDM_SWAT_Table->CurAntenna = AUX_ANT;
+			}
+				else
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Reg[948]= (( %x )) was in wrong state\n", tmp_SWAS_NoLink_BK_Reg948 ));
+					return FALSE;
+				}
+				ODM_StallExecution(10);
+		
+			}
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Change to (( %s-ant))  for testing.\n", (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?"MAIN":"AUX"));
+		}
+		
+		odm_SwAntDivConstructScanChnl(Adapter, ScanChannel);
+		PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
+
+		return TRUE;
+	}
+	else //pDM_SWAT_Table->SWAS_NoLink_State == 1
+	{
+		//1 ScanComple() is called after antenna swiched.
+		//1 Check scan result and determine which antenna is going
+		//1 to be used.
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,(" tmpNumBssDesc= (( %d )) \n",pMgntInfo->tmpNumBssDesc));// debug for Dino
+		
+		for(index = 0; index < pMgntInfo->tmpNumBssDesc; index++)
+		{
+			pTmpBssDesc = &(pMgntInfo->tmpbssDesc[index]); // Antenna 1
+			pTestBssDesc = &(pMgntInfo->bssDesc[index]); // Antenna 2
+
+			if(PlatformCompareMemory(pTestBssDesc->bdBssIdBuf, pTmpBssDesc->bdBssIdBuf, 6)!=0)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): ERROR!! This shall not happen.\n"));
+				continue;
+			}
+
+			if(pDM_Odm->SupportICType != ODM_RTL8723B)
+			{
+				if(pTmpBssDesc->ChannelNumber == ScanChannel)
+				{
+			if(pTmpBssDesc->RecvSignalPower > pTestBssDesc->RecvSignalPower)
+			{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Compare scan entry: Score++\n"));
+						RT_PRINT_STR(COMP_SCAN, DBG_WARNING, "GetScanInfo(): new Bss SSID:", pTmpBssDesc->bdSsIdBuf, pTmpBssDesc->bdSsIdLen);
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("at ch %d, Original: %d, Test: %d\n\n", pTmpBssDesc->ChannelNumber, pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+			
+				Score++;
+				PlatformMoveMemory(pTestBssDesc, pTmpBssDesc, sizeof(RT_WLAN_BSS));
+			}
+			else if(pTmpBssDesc->RecvSignalPower < pTestBssDesc->RecvSignalPower)
+			{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink: Compare scan entry: Score--\n"));
+						RT_PRINT_STR(COMP_SCAN, DBG_WARNING, "GetScanInfo(): new Bss SSID:", pTmpBssDesc->bdSsIdBuf, pTmpBssDesc->bdSsIdLen);
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("at ch %d, Original: %d, Test: %d\n\n", pTmpBssDesc->ChannelNumber, pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+				Score--;
+			}
+					else
+					{
+						if(pTestBssDesc->bdTstamp - pTmpBssDesc->bdTstamp < 5000)
+						{
+							RT_PRINT_STR(COMP_SCAN, DBG_WARNING, "GetScanInfo(): new Bss SSID:", pTmpBssDesc->bdSsIdBuf, pTmpBssDesc->bdSsIdLen);
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("at ch %d, Original: %d, Test: %d\n", pTmpBssDesc->ChannelNumber, pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("The 2nd Antenna didn't get this AP\n\n"));
+						}
+					}
+				}
+			}
+			else // 8723B
+			{ 
+				if(pTmpBssDesc->ChannelNumber == ScanChannel)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ChannelNumber == ScanChannel -> (( %d )) \n", pTmpBssDesc->ChannelNumber ));
+				
+					if(pTmpBssDesc->RecvSignalPower > pTestBssDesc->RecvSignalPower) // Pow(Ant1) > Pow(Ant2)
+					{
+						counter++;
+						tmp_power_diff=(u1Byte)(pTmpBssDesc->RecvSignalPower - pTestBssDesc->RecvSignalPower);
+						power_diff = power_diff + tmp_power_diff;	
+						
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("SSID:"), pTmpBssDesc->bdSsIdBuf);
+						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("BSSID:"), pTmpBssDesc->bdBssIdBuf);
+
+						//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("tmp_power_diff: (( %d)),max_power_diff: (( %d)),min_power_diff: (( %d))  \n", tmp_power_diff,max_power_diff,min_power_diff));
+						if(tmp_power_diff > max_power_diff)
+							max_power_diff=tmp_power_diff;
+						if(tmp_power_diff < min_power_diff)
+							min_power_diff=tmp_power_diff;
+						//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("max_power_diff: (( %d)),min_power_diff: (( %d))  \n",max_power_diff,min_power_diff));
+						
+						PlatformMoveMemory(pTestBssDesc, pTmpBssDesc, sizeof(RT_WLAN_BSS));
+					}
+					else if(pTestBssDesc->RecvSignalPower > pTmpBssDesc->RecvSignalPower) // Pow(Ant1) < Pow(Ant2)
+					{
+						counter++;
+						tmp_power_diff=(u1Byte)(pTestBssDesc->RecvSignalPower - pTmpBssDesc->RecvSignalPower);
+						power_diff = power_diff + tmp_power_diff;						
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("SSID:"), pTmpBssDesc->bdSsIdBuf);
+						ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("BSSID:"), pTmpBssDesc->bdBssIdBuf);							
+						if(tmp_power_diff > max_power_diff)
+							max_power_diff=tmp_power_diff;
+						if(tmp_power_diff < min_power_diff)
+							min_power_diff=tmp_power_diff;							
+					}
+					else // Pow(Ant1) = Pow(Ant2)
+					{
+						if(pTestBssDesc->bdTstamp > pTmpBssDesc->bdTstamp) //  Stamp(Ant1) < Stamp(Ant2) 
+					{
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("time_diff: %lld\n", (pTestBssDesc->bdTstamp-pTmpBssDesc->bdTstamp)/1000));
+						if(pTestBssDesc->bdTstamp - pTmpBssDesc->bdTstamp > 5000)
+						{
+							counter++;
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+							ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("SSID:"), pTmpBssDesc->bdSsIdBuf);
+								ODM_PRINT_ADDR(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("BSSID:"), pTmpBssDesc->bdBssIdBuf);
+								min_power_diff = 0;
+						}
+					}
+						else
+						{
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Error !!!]: Time_diff: %lld\n", (pTestBssDesc->bdTstamp-pTmpBssDesc->bdTstamp)/1000));
+						}
+				}
+			}
+		}
+		}
+
+		if(pDM_Odm->SupportICType & (ODM_RTL8188E|ODM_RTL8821))
+		{
+			if(pMgntInfo->NumBssDesc!=0 && Score<0)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,
+							("ODM_SwAntDivCheckBeforeLink(): Using Ant(%s)\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+			}
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+						("ODM_SwAntDivCheckBeforeLink(): Remain Ant(%s)\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"AUX_ANT":"MAIN_ANT"));
+
+				if(pDM_FatTable->RxIdleAnt == MAIN_ANT)
+					ODM_UpdateRxIdleAnt(pDM_Odm, AUX_ANT);
+				else
+					ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
+			}
+			
+			if(IS_5G_WIRELESS_MODE(pMgntInfo->dot11CurrentWirelessMode))
+			{
+				pDM_SWAT_Table->Ant5G = pDM_FatTable->RxIdleAnt;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant5G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+			}
+			else
+			{
+				pDM_SWAT_Table->Ant2G = pDM_FatTable->RxIdleAnt;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("pDM_SWAT_Table->Ant2G=%s\n", (pDM_FatTable->RxIdleAnt==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+			}
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		{
+			if(counter == 0)
+			{	
+				if(pDM_Odm->DM_SWAT_Table.Pre_Aux_FailDetec == FALSE)
+				{
+					pDM_Odm->DM_SWAT_Table.Pre_Aux_FailDetec = TRUE;
+					pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=FALSE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Counter=(( 0 )) , [[ Cannot find any AP with Aux-ant ]] ->  Scan Target-channel again  \n"));	
+
+                                        //3 [ Scan again ]
+					odm_SwAntDivConstructScanChnl(Adapter, ScanChannel);
+					PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
+					return TRUE;
+				}
+				else// Pre_Aux_FailDetec == TRUE
+				{
+					//2 [ Single Antenna ]
+					pDM_Odm->DM_SWAT_Table.Pre_Aux_FailDetec = FALSE;
+					pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=TRUE;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Counter=(( 0 )) , [[  Still cannot find any AP ]] \n"));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): Single antenna\n"));	
+				}
+				pDM_Odm->DM_SWAT_Table.Aux_FailDetec_Counter++;
+			}
+			else
+			{
+				pDM_Odm->DM_SWAT_Table.Pre_Aux_FailDetec = FALSE;
+				
+				if(counter==3)
+				{
+					avg_power_diff = ((power_diff-max_power_diff - min_power_diff)>>1)+ ((max_power_diff + min_power_diff)>>2);
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("counter: (( %d )) ,  power_diff: (( %d )) \n", counter, power_diff));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ counter==3 ] Modified avg_power_diff: (( %d )) , max_power_diff: (( %d )) ,  min_power_diff: (( %d )) \n", avg_power_diff,max_power_diff, min_power_diff));
+				}
+				else if(counter>=4)
+				{
+					avg_power_diff=(power_diff-max_power_diff - min_power_diff) / (counter - 2);
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("counter: (( %d )) ,  power_diff: (( %d )) \n", counter, power_diff));
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ counter>=4 ] Modified avg_power_diff: (( %d )) , max_power_diff: (( %d )) ,  min_power_diff: (( %d )) \n", avg_power_diff,max_power_diff, min_power_diff));
+					
+				}
+				else//counter==1,2
+				{
+					avg_power_diff=power_diff/counter;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("avg_power_diff: (( %d )) , counter: (( %d )) ,  power_diff: (( %d )) \n", avg_power_diff,counter, power_diff));
+				}
+
+				//2 [ Retry ]
+				if( (avg_power_diff >=power_target_L) && (avg_power_diff <=power_target_H)  )
+				{
+					pDM_Odm->DM_SWAT_Table.Retry_Counter++;
+					
+					if(pDM_Odm->DM_SWAT_Table.Retry_Counter<=3)
+					{
+						pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=FALSE;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[[ Low confidence result ]] avg_power_diff= (( %d ))  ->  Scan Target-channel again ]] \n", avg_power_diff));	
+
+					         //3 [ Scan again ]
+						odm_SwAntDivConstructScanChnl(Adapter, ScanChannel);
+						PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
+						return TRUE;					         
+					}
+					else
+			{
+						pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=TRUE;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[[ Still Low confidence result ]]  (( Retry_Counter > 3 )) \n"));
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): Single antenna\n"));
+					}
+					
+				}
+				//2 [ Dual Antenna ]
+				else if( (pMgntInfo->NumBssDesc != 0) && (avg_power_diff < power_target_L)   ) 
+				{
+					pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=TRUE;
+					if(pDM_Odm->DM_SWAT_Table.ANTB_ON == FALSE)
+					{
+						pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
+						pDM_Odm->DM_SWAT_Table.ANTB_ON = TRUE;
+					}
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SwAntDivCheckBeforeLink(): Dual antenna\n"));
+					pDM_Odm->DM_SWAT_Table.Dual_Ant_Counter++;
+
+					// set bt coexDM from 1ant coexDM to 2ant coexDM
+					BT_SetBtCoexAntNum(Adapter, BT_COEX_ANT_TYPE_DETECTED, 2);
+					
+					//3 [ Init antenna diversity ]
+					pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV; 
+					ODM_AntDivInit(pDM_Odm);
+				}
+				//2 [ Single Antenna ]
+				else if(avg_power_diff > power_target_H)
+				{
+					pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult=TRUE;
+					if(pDM_Odm->DM_SWAT_Table.ANTB_ON == TRUE)
+					{
+						pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
+						pDM_Odm->DM_SWAT_Table.ANTB_ON = FALSE;
+						//BT_SetBtCoexAntNum(Adapter, BT_COEX_ANT_TYPE_DETECTED, 1);
+					}
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): Single antenna\n"));
+					pDM_Odm->DM_SWAT_Table.Single_Ant_Counter++;
+				}
+			}
+			//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("bResult=(( %d ))\n",pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Dual_Ant_Counter = (( %d )), Single_Ant_Counter = (( %d )) , Retry_Counter = (( %d )) , Aux_FailDetec_Counter = (( %d ))\n\n\n",
+			pDM_Odm->DM_SWAT_Table.Dual_Ant_Counter,pDM_Odm->DM_SWAT_Table.Single_Ant_Counter,pDM_Odm->DM_SWAT_Table.Retry_Counter,pDM_Odm->DM_SWAT_Table.Aux_FailDetec_Counter));
+
+			//2 recover the antenna setting
+
+			if(pDM_Odm->DM_SWAT_Table.ANTB_ON == FALSE)
+				ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, 0xfff, (pDM_SWAT_Table->SWAS_NoLink_BK_Reg948));
+			
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("bResult=(( %d )), Recover  Reg[948]= (( %x )) \n\n",pDM_Odm->DM_SWAT_Table.RSSI_AntDect_bResult, pDM_SWAT_Table->SWAS_NoLink_BK_Reg948 ));
+
+			
+		}
+		else if(pDM_Odm->SupportICType == ODM_RTL8192C)
+		{
+			if(pMgntInfo->NumBssDesc!=0 && Score<=0)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,
+					("ODM_SwAntDivCheckBeforeLink(): Using Ant(%s)\n", (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?"MAIN":"AUX"));
+
+				pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+			}
+			else
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, 
+					("ODM_SwAntDivCheckBeforeLink(): Remain Ant(%s)\n", (pDM_SWAT_Table->CurAntenna==MAIN_ANT)?"AUX":"MAIN"));
+
+				pDM_SWAT_Table->CurAntenna = pDM_SWAT_Table->PreAntenna;
+
+				//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
+				pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
+				PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
+			}
+		}
+		
+		// Check state reset to default and wait for next time.
+		pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		pMgntInfo->bScanAntDetect = FALSE;
+
+		return FALSE;
+	}
+
+#else
+		return	FALSE;
+#endif
+
+return FALSE;
+}
+
+
+
+
+
+
+//1 [3. PSD Method] ==========================================================
+
+
+
+
+u4Byte
+odm_GetPSDData(
+	IN PDM_ODM_T	pDM_Odm,
+	IN u2Byte			point,
+	IN u1Byte 		initial_gain)
+{
+	u4Byte			psd_report;
+	
+	ODM_SetBBReg(pDM_Odm, 0x808, 0x3FF, point);
+	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 1);  //Start PSD calculation, Reg808[22]=0->1
+	ODM_StallExecution(150);//Wait for HW PSD report
+	ODM_SetBBReg(pDM_Odm, 0x808, BIT22, 0);//Stop PSD calculation,  Reg808[22]=1->0
+	psd_report = ODM_GetBBReg(pDM_Odm,0x8B4, bMaskDWord) & 0x0000FFFF;//Read PSD report, Reg8B4[15:0]
+	
+	psd_report = (u4Byte) (ConvertTo_dB(psd_report));//+(u4Byte)(initial_gain);
+	return psd_report;
+}
+
+
+
+VOID
+ODM_SingleDualAntennaDetection_PSD(
+	IN	 PDM_ODM_T 	pDM_Odm
+)
+{
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	u4Byte	Channel_ori;
+	u1Byte 	initial_gain = 0x36;
+	u1Byte	tone_idx;
+	u1Byte	Tone_lenth_1=7, Tone_lenth_2=4;
+	u2Byte	Tone_idx_1[7]={88, 104, 120, 8, 24, 40, 56};
+	u2Byte	Tone_idx_2[4]={8, 24, 40, 56};
+	u4Byte	PSD_report_Main[11]={0}, PSD_report_Aux[11]={0};
+	//u1Byte	Tone_lenth_1=4, Tone_lenth_2=2;
+	//u2Byte	Tone_idx_1[4]={88, 120, 24, 56};
+	//u2Byte	Tone_idx_2[2]={ 24,  56};
+	//u4Byte	PSD_report_Main[6]={0}, PSD_report_Aux[6]={0};
+
+	u4Byte	PSD_report_temp,MAX_PSD_report_Main=0,MAX_PSD_report_Aux=0;
+	u4Byte	PSD_power_threshold;
+	u4Byte	Main_psd_result=0, Aux_psd_result=0;
+	u4Byte	Regc50, Reg948, Regb2c,Regc14,Reg908;
+	u4Byte	i=0,test_num=8;
+	
+
+	if(pDM_Odm->SupportICType != ODM_RTL8723B)
+		return;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection_PSD()============> \n"));	
+	
+	//2 [ Backup Current RF/BB Settings ]	
+	
+	Channel_ori = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask);
+	Reg948 = ODM_GetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord);
+	Regb2c =  ODM_GetBBReg(pDM_Odm, rAGC_table_select, bMaskDWord);
+	Regc50 = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord);
+	Regc14 = ODM_GetBBReg(pDM_Odm, 0xc14, bMaskDWord);
+	Reg908 = ODM_GetBBReg(pDM_Odm, 0x908, bMaskDWord);
+
+	//2 [ Setting for doing PSD function (CH4)]
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0); //disable whole CCK block
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0xFF); // Turn off TX  ->  Pause TX Queue
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, 0x0); // [ Set IQK Matrix = 0 ] equivalent to [ Turn off CCA]
+
+	// PHYTXON while loop
+	ODM_SetBBReg(pDM_Odm, 0x908, bMaskDWord, 0x803); 
+	while (ODM_GetBBReg(pDM_Odm, 0xdf4, BIT6)) 
+	{
+		i++;
+		if (i > 1000000) 
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Wait in %s() more than %d times!\n", __FUNCTION__, i));	
+			break;
+		}
+	}
+	
+	ODM_SetBBReg(pDM_Odm, 0xc50, 0x7f, initial_gain);  
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, 0x7ff, 0x04);     // Set RF to CH4 & 40M
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, 0xf00000, 0xf);	// 3 wire Disable    88c[23:20]=0xf
+	ODM_SetBBReg(pDM_Odm, rFPGA0_PSDFunction, BIT14|BIT15, 0x0);  //128 pt	//Set PSD 128 ptss
+	ODM_StallExecution(3000);	
+	
+	
+	//2 [ Doing PSD Function in (CH4)]
+	
+        //Antenna A
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Switch to Main-ant   (CH4)\n"));
+	ODM_SetBBReg(pDM_Odm, 0x948, 0xfff, 0x200);
+	ODM_StallExecution(10);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("dbg\n"));
+	for (i=0;i<test_num;i++)
+	{	
+		for (tone_idx=0;tone_idx<Tone_lenth_1;tone_idx++)
+		{
+			PSD_report_temp = odm_GetPSDData(pDM_Odm, Tone_idx_1[tone_idx], initial_gain);
+			//if(  PSD_report_temp>PSD_report_Main[tone_idx]  )
+				PSD_report_Main[tone_idx]+=PSD_report_temp;
+		}
+	}
+        //Antenna B
+       ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Switch to Aux-ant   (CH4)\n"));
+       ODM_SetBBReg(pDM_Odm, 0x948, 0xfff, 0x280);
+       ODM_StallExecution(10);	
+	for (i=0;i<test_num;i++)
+	{
+		for (tone_idx=0;tone_idx<Tone_lenth_1;tone_idx++)
+		{
+			PSD_report_temp = odm_GetPSDData(pDM_Odm, Tone_idx_1[tone_idx], initial_gain);
+			//if(  PSD_report_temp>PSD_report_Aux[tone_idx]  )
+				PSD_report_Aux[tone_idx]+=PSD_report_temp;
+		}
+	}
+	//2 [ Doing PSD Function in (CH8)]
+
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, 0xf00000, 0x0);	// 3 wire enable    88c[23:20]=0x0
+	ODM_StallExecution(3000);	
+	
+	ODM_SetBBReg(pDM_Odm, 0xc50, 0x7f, initial_gain);  
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, ODM_CHANNEL, 0x7ff, 0x04);     // Set RF to CH8 & 40M
+	
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, 0xf00000, 0xf);	// 3 wire Disable    88c[23:20]=0xf
+	ODM_StallExecution(3000);
+
+        //Antenna A
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Switch to Main-ant   (CH8)\n"));
+	ODM_SetBBReg(pDM_Odm, 0x948, 0xfff, 0x200);
+	ODM_StallExecution(10);
+
+	for (i=0;i<test_num;i++)
+	{
+		for (tone_idx=0;tone_idx<Tone_lenth_2;tone_idx++)
+		{
+			PSD_report_temp = odm_GetPSDData(pDM_Odm, Tone_idx_2[tone_idx], initial_gain);
+			//if(  PSD_report_temp>PSD_report_Main[tone_idx]  )
+				PSD_report_Main[Tone_lenth_1+tone_idx]+=PSD_report_temp;
+		}
+	}
+
+        //Antenna B
+        ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Switch to Aux-ant   (CH8)\n"));
+        ODM_SetBBReg(pDM_Odm, 0x948, 0xfff, 0x280);
+	ODM_StallExecution(10);	
+
+	for (i=0;i<test_num;i++)
+	{
+		for (tone_idx=0;tone_idx<Tone_lenth_2;tone_idx++)
+		{
+			PSD_report_temp = odm_GetPSDData(pDM_Odm, Tone_idx_2[tone_idx], initial_gain);
+			//if(  PSD_report_temp>PSD_report_Aux[tone_idx]  )
+				PSD_report_Aux[Tone_lenth_1+tone_idx]+=PSD_report_temp;
+		}
+	}
+
+        //2 [ Calculate Result ]
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\nMain PSD Result: (ALL) \n"));
+	for (tone_idx=0;tone_idx<(Tone_lenth_1+Tone_lenth_2);tone_idx++)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Tone-%d]: %d, \n",(tone_idx+1), PSD_report_Main[tone_idx] ));
+		Main_psd_result+= PSD_report_Main[tone_idx];
+		if(PSD_report_Main[tone_idx]>MAX_PSD_report_Main)
+			MAX_PSD_report_Main=PSD_report_Main[tone_idx];
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("--------------------------- \nTotal_Main= (( %d ))\n", Main_psd_result));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("MAX_Main = (( %d ))\n", MAX_PSD_report_Main));
+	
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("\nAux PSD Result: (ALL) \n"));
+	for (tone_idx=0;tone_idx<(Tone_lenth_1+Tone_lenth_2);tone_idx++)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Tone-%d]: %d, \n",(tone_idx+1), PSD_report_Aux[tone_idx] ));
+		Aux_psd_result+= PSD_report_Aux[tone_idx];
+		if(PSD_report_Aux[tone_idx]>MAX_PSD_report_Aux)
+			MAX_PSD_report_Aux=PSD_report_Aux[tone_idx];
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("--------------------------- \nTotal_Aux= (( %d ))\n", Aux_psd_result));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("MAX_Aux = (( %d ))\n\n", MAX_PSD_report_Aux));
+		
+	//Main_psd_result=Main_psd_result-MAX_PSD_report_Main;
+	//Aux_psd_result=Aux_psd_result-MAX_PSD_report_Aux;
+	PSD_power_threshold=(Main_psd_result*7)>>3;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Main_result , Aux_result ] = [ %d , %d ], PSD_power_threshold=(( %d ))\n", Main_psd_result, Aux_psd_result,PSD_power_threshold));
+	
+	//3 [ Dual Antenna ]
+	 if(Aux_psd_result >= PSD_power_threshold   ) 
+	{
+		if(pDM_Odm->DM_SWAT_Table.ANTB_ON == FALSE)
+		{
+			pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
+			pDM_Odm->DM_SWAT_Table.ANTB_ON = TRUE;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("ODM_SwAntDivCheckBeforeLink(): Dual antenna\n"));
+		
+		// set bt coexDM from 1ant coexDM to 2ant coexDM
+		//BT_SetBtCoexAntNum(pAdapter, BT_COEX_ANT_TYPE_DETECTED, 2);
+					
+		// Init antenna diversity
+		pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV; 
+		ODM_AntDivInit(pDM_Odm);
+		}
+	//3 [ Single Antenna ]
+	else
+	{
+		if(pDM_Odm->DM_SWAT_Table.ANTB_ON == TRUE)
+		{
+			pDM_Odm->DM_SWAT_Table.ANTA_ON = TRUE;
+			pDM_Odm->DM_SWAT_Table.ANTB_ON = FALSE;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SwAntDivCheckBeforeLink(): Single antenna\n"));
+	}
+
+	//2 [ Recover all parameters ]
+	
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask,Channel_ori);	
+	ODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, 0xf00000, 0x0);	// 3 wire enable    88c[23:20]=0x0
+	ODM_SetBBReg(pDM_Odm, 0xc50, 0x7f, Regc50);  	
+	
+	ODM_SetBBReg(pDM_Odm, rS0S1_PathSwitch, bMaskDWord, Reg948);
+	ODM_SetBBReg(pDM_Odm, rAGC_table_select, bMaskDWord, Regb2c);
+
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 1); //enable whole CCK block
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0x0); //Turn on TX 	// Resume TX Queue
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, Regc14); // [ Set IQK Matrix = 0 ] equivalent to [ Turn on CCA]
+	ODM_SetBBReg(pDM_Odm, 0x908, bMaskDWord, Reg908); 
+	
+	return;
+
+}
+
+
+
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDect.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDect.h
new file mode 100644
index 000000000000..9e18c2ebfeee
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDect.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMANTDECT_H__
+#define    __PHYDMANTDECT_H__
+
+#define ANTDECT_VERSION	"1.0"
+
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN |ODM_CE))
+//1 [1. Single Tone Method] ===================================================
+
+
+
+VOID
+ODM_SingleDualAntennaDefaultSetting(
+	IN		PDM_ODM_T		pDM_Odm
+	);
+
+BOOLEAN
+ODM_SingleDualAntennaDetection(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			mode
+	);
+
+//1 [2. Scan AP RSSI Method] ==================================================
+
+VOID
+odm_SwAntDetectInit(
+	IN 		PDM_ODM_T 		pDM_Odm
+	);
+
+
+#define SwAntDivCheckBeforeLink	ODM_SwAntDivCheckBeforeLink
+
+BOOLEAN 
+ODM_SwAntDivCheckBeforeLink(
+	IN		PDM_ODM_T		pDM_Odm
+	);
+
+
+
+
+//1 [3. PSD Method] ==========================================================
+
+
+VOID
+ODM_SingleDualAntennaDetection_PSD(
+	IN	 PDM_ODM_T 	pDM_Odm
+);
+
+
+
+
+
+
+#endif
+#endif
+
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_AntDiv.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDiv.c
similarity index 72%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_AntDiv.c
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDiv.c
index 4b361e2c5d5e..4898e9ce7db2 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_AntDiv.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDiv.c
@@ -22,7 +22,80 @@
 // include files
 //============================================================
 
-#include "odm_precomp.h"
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+//======================================================
+// when antenna test utility is on or some testing need to disable antenna diversity
+// call this function to disable all ODM related mechanisms which will switch antenna.
+//======================================================
+VOID
+ODM_StopAntennaSwitchDm(
+	IN	PDM_ODM_T	pDM_Odm
+	)
+{
+	// disable ODM antenna diversity
+	pDM_Odm->SupportAbility &= ~ODM_BB_ANT_DIV;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("STOP Antenna Diversity \n"));
+}
+
+VOID
+ODM_SetAntConfig(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	u1Byte		antSetting	// 0=A, 1=B, 2=C, ....
+	)
+{
+	if(pDM_Odm->SupportICType == ODM_RTL8723B)
+	{
+		if(antSetting == 0)		// ant A
+			ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000000);
+		else if(antSetting == 1)
+			ODM_SetBBReg(pDM_Odm, 0x948, bMaskDWord, 0x00000280);
+	}
+}
+
+//======================================================
+
+
+VOID
+ODM_SwAntDivRestAfterLink(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
+	u4Byte             i;
+
+	if(pDM_Odm->SupportICType == ODM_RTL8723A)
+	{
+	    pDM_SWAT_Table->RSSI_cnt_A = 0;
+	    pDM_SWAT_Table->RSSI_cnt_B = 0;
+	    pDM_Odm->RSSI_test = FALSE;
+	    pDM_SWAT_Table->try_flag = 0xff;
+	    pDM_SWAT_Table->RSSI_Trying = 0;
+	    pDM_SWAT_Table->SelectAntennaMap=0xAA;
+	
+	}
+	else if(pDM_Odm->SupportICType & (ODM_RTL8723B|ODM_RTL8821))
+	{
+		pDM_Odm->RSSI_test = FALSE;
+		pDM_SWAT_Table->try_flag = 0xff;
+		pDM_SWAT_Table->RSSI_Trying = 0;
+		pDM_SWAT_Table->Double_chk_flag= 0;
+		
+		pDM_FatTable->RxIdleAnt=MAIN_ANT;
+		
+		for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+		{
+			pDM_FatTable->MainAnt_Sum[i] = 0;
+			pDM_FatTable->AuxAnt_Sum[i] = 0;
+			pDM_FatTable->MainAnt_Cnt[i] = 0;
+			pDM_FatTable->AuxAnt_Cnt[i] = 0;
+		}
+
+	}
+}
+
 
 #if (defined(CONFIG_HW_ANTENNA_DIVERSITY))
 VOID
@@ -33,22 +106,29 @@ odm_AntDiv_on_off( IN PDM_ODM_T	pDM_Odm ,IN u1Byte swch)
 
 	if(pDM_Odm->SupportICType & ODM_N_ANTDIV_SUPPORT)
 	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("(( Turn %s )) N-Series AntDiv Function\n",(swch==ANTDIV_ON)?"ON" : "OFF"));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("(( Turn %s )) N-Series HW-AntDiv block\n",(swch==ANTDIV_ON)?"ON" : "OFF"));
 		ODM_SetBBReg(pDM_Odm, 0xc50 , BIT7, swch); //OFDM AntDiv function block enable
-		ODM_SetBBReg(pDM_Odm, 0xa00 , BIT15, swch); //CCK AntDiv function block enable
+		if( pDM_Odm->AntDivType != S0S1_SW_ANTDIV)
+		        ODM_SetBBReg(pDM_Odm, 0xa00 , BIT15, swch); //CCK AntDiv function block enable
 	}
 	else if(pDM_Odm->SupportICType & ODM_AC_ANTDIV_SUPPORT)
 	{
-		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("(( Turn %s )) AC-Series AntDiv Function\n",(swch==ANTDIV_ON)?"ON" : "OFF"));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("(( Turn %s )) AC-Series HW-AntDiv block\n",(swch==ANTDIV_ON)?"ON" : "OFF"));
 		if(pDM_Odm->SupportICType == ODM_RTL8812)
 		{
 			ODM_SetBBReg(pDM_Odm, 0xc50 , BIT7, swch); //OFDM AntDiv function block enable
-			ODM_SetBBReg(pDM_Odm, 0xa00 , BIT15, swch); //CCK AntDiv function block enable
+			//ODM_SetBBReg(pDM_Odm, 0xa00 , BIT15, swch); //CCK AntDiv function block enable
 		}
 		else
 		{
 		ODM_SetBBReg(pDM_Odm, 0x8D4 , BIT24, swch); //OFDM AntDiv function block enable
-		ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, swch); //CCK AntDiv function block enable
+			
+			if( (pDM_Odm->CutVersion >= ODM_CUT_C) && (pDM_Odm->SupportICType == ODM_RTL8821) && ( pDM_Odm->AntDivType != S0S1_SW_ANTDIV))
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("(( Turn %s )) CCK HW-AntDiv block\n",(swch==ANTDIV_ON)?"ON" : "OFF"));
+				ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, swch); 
+				ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, swch); //CCK AntDiv function block enable
+			}
 	        }
          }
 }
@@ -59,15 +139,17 @@ ODM_UpdateRxIdleAnt(IN PDM_ODM_T pDM_Odm, IN u1Byte Ant)
 	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
 	u4Byte	DefaultAnt, OptionalAnt,value32;
 
-	#if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
-	PADAPTER 		pAdapter = pDM_Odm->Adapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	#endif
+	//#if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	//PADAPTER 		pAdapter = pDM_Odm->Adapter;
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	//#endif
 
 	if(pDM_FatTable->RxIdleAnt != Ant)
 	{
 		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] RxIdleAnt =%s\n",(Ant==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
-		pDM_FatTable->RxIdleAnt = Ant;
+
+		if(!(pDM_Odm->SupportICType & ODM_RTL8723B))
+		        pDM_FatTable->RxIdleAnt = Ant;
 
 		if(Ant == MAIN_ANT)
 		{
@@ -86,32 +168,52 @@ ODM_UpdateRxIdleAnt(IN PDM_ODM_T pDM_Odm, IN u1Byte Ant)
 			{
 				ODM_SetBBReg(pDM_Odm, 0xB38 , BIT5|BIT4|BIT3, DefaultAnt); //Default RX
 				ODM_SetBBReg(pDM_Odm, 0xB38 , BIT8|BIT7|BIT6, OptionalAnt);//Optional RX
+				ODM_SetBBReg(pDM_Odm, 0x860, BIT14|BIT13|BIT12, DefaultAnt);//Default TX	
+			}
+			else if(pDM_Odm->SupportICType==ODM_RTL8723B)
+			{
+				value32 = ODM_GetBBReg(pDM_Odm, 0x948, 0xFFF);
+				
+				if (value32 !=0x280)
+				        ODM_UpdateRxIdleAnt_8723B(pDM_Odm, Ant, DefaultAnt, OptionalAnt);
+			        else
+				        ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Fail to set RX antenna due to 0x948 = 0x280\n"));
 			}
 			else
 			{
 				ODM_SetBBReg(pDM_Odm, 0x864 , BIT5|BIT4|BIT3, DefaultAnt);	//Default RX
 				ODM_SetBBReg(pDM_Odm, 0x864 , BIT8|BIT7|BIT6, OptionalAnt);	//Optional RX
-
-				if(pDM_Odm->SupportICType == ODM_RTL8723B)
-				{
-					value32 = ODM_GetBBReg(pDM_Odm, 0x948, 0xFFF);
-				
-					if (value32 !=0x280)
-						ODM_SetBBReg(pDM_Odm, 0x948 , BIT9, DefaultAnt);
-
-					rtw_hal_set_tx_power_level(pAdapter, pHalData->CurrentChannel);
-				}
-				
-			}
-			ODM_SetBBReg(pDM_Odm, 0x860, BIT14|BIT13|BIT12, DefaultAnt);	        //Default TX	
+	        		ODM_SetBBReg(pDM_Odm, 0x860, BIT14|BIT13|BIT12, DefaultAnt);	        //Default TX	
+		        }
 		}
 		else if(pDM_Odm->SupportICType & ODM_AC_ANTDIV_SUPPORT)
 		{
-			ODM_SetBBReg(pDM_Odm, 0xC08 , BIT21|BIT20|BIT19, DefaultAnt);	 //Default RX
-			ODM_SetBBReg(pDM_Odm, 0xC08 , BIT24|BIT23|BIT22, OptionalAnt);//Optional RX
-			ODM_SetBBReg(pDM_Odm, 0xC08 , BIT27|BIT26|BIT25, DefaultAnt);	 //Default TX
+			u2Byte	value16 = ODM_Read2Byte(pDM_Odm, ODM_REG_TRMUX_11AC+2);
+			//
+			// 2014/01/14 MH/Luke.Lee Add direct write for register 0xc0a to prevnt 
+			// incorrect 0xc08 bit0-15 .We still not know why it is changed.
+			//
+			value16 &= ~(BIT11|BIT10|BIT9|BIT8|BIT7|BIT6|BIT5|BIT4|BIT3);
+			value16 |= ((u2Byte)DefaultAnt <<3);
+			value16 |= ((u2Byte)OptionalAnt <<6);
+			value16 |= ((u2Byte)DefaultAnt <<9);
+			ODM_Write2Byte(pDM_Odm, ODM_REG_TRMUX_11AC+2, value16);
+			/*
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC , BIT21|BIT20|BIT19, DefaultAnt);	 //Default RX
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC , BIT24|BIT23|BIT22, OptionalAnt);//Optional RX
+			ODM_SetBBReg(pDM_Odm, ODM_REG_TRMUX_11AC , BIT27|BIT26|BIT25, DefaultAnt);	 //Default TX
+			*/
+		}
+		
+		if(pDM_Odm->SupportICType==ODM_RTL8188E)
+		{		
+			ODM_SetMACReg(pDM_Odm, 0x6D8 , BIT7|BIT6, DefaultAnt);	//PathA Resp Tx
 		}
-		ODM_SetMACReg(pDM_Odm, 0x6D8 , BIT10|BIT9|BIT8, DefaultAnt);	//PathA Resp Tx
+		else
+		{
+			ODM_SetMACReg(pDM_Odm, 0x6D8 , BIT10|BIT9|BIT8, DefaultAnt);	//PathA Resp Tx
+		}	
+		
 	}
 	else// pDM_FatTable->RxIdleAnt == Ant
 	{
@@ -163,12 +265,13 @@ odm_RX_HWAntDiv_Init_88E(
 
 	pDM_Odm->AntType = ODM_AUTO_ANT;
 
-        #if (MP_DRIVER == 1)
+	if(pDM_Odm->mp_mode == TRUE)
+	{
 	        pDM_Odm->AntDivType = CGCS_RX_SW_ANTDIV;
 	        ODM_SetBBReg(pDM_Odm, ODM_REG_IGI_A_11N , BIT7, 0); // disable HW AntDiv 
 	        ODM_SetBBReg(pDM_Odm, ODM_REG_LNA_SWITCH_11N , BIT31, 1);  // 1:CG, 0:CS
         	return;
-        #endif
+	}
 	
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8188E AntDiv_Init =>  AntDivType=[CGCS_RX_HW_ANTDIV]\n"));
 	
@@ -186,8 +289,7 @@ odm_RX_HWAntDiv_Init_88E(
 	ODM_SetBBReg(pDM_Odm, ODM_REG_BB_PWR_SAV4_11N , BIT7, 1); //Fix CCK PHY status report issue
 	ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_ANTDIV_PARA2_11N , BIT4, 1); //CCK complete HW AntDiv within 64 samples	
 	
-	ODM_SetBBReg(pDM_Odm, ODM_REG_ANT_MAPPING1_11N , 0xFFFF, 0x0102);	//antenna mapping table
-
+	ODM_SetBBReg(pDM_Odm, ODM_REG_ANT_MAPPING1_11N , 0xFFFF, 0x0001);	//antenna mapping table
 }
 
 VOID
@@ -197,12 +299,13 @@ odm_TRX_HWAntDiv_Init_88E(
 {
 	u4Byte	value32;
 	
-        #if (MP_DRIVER == 1)
+	if(pDM_Odm->mp_mode == TRUE)
+	{
 	        pDM_Odm->AntDivType = CGCS_RX_SW_ANTDIV;
 	        ODM_SetBBReg(pDM_Odm, ODM_REG_IGI_A_11N , BIT7, 0); // disable HW AntDiv 
 	        ODM_SetBBReg(pDM_Odm, ODM_REG_RX_ANT_CTRL_11N , BIT5|BIT4|BIT3, 0); //Default RX   (0/1)
 	        return;
-        #endif
+	}
 
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8188E AntDiv_Init =>  AntDivType=[CG_TRX_HW_ANTDIV (SPDT)]\n"));
 	
@@ -227,7 +330,7 @@ odm_TRX_HWAntDiv_Init_88E(
 		ODM_SetBBReg(pDM_Odm, ODM_REG_RX_DEFUALT_A_11N , BIT13|BIT12|BIT11, 2);	//Reg858[13:11]=3'b010
 	}
 	else //MPchip
-		ODM_SetBBReg(pDM_Odm, ODM_REG_ANT_MAPPING1_11N , bMaskDWord, 0x0201);	//Reg914=3'b010, Reg915=3'b001
+		ODM_SetBBReg(pDM_Odm, ODM_REG_ANT_MAPPING1_11N , bMaskDWord, 0x0001);	//Reg914=3'b010, Reg915=3'b001
 }
 
 VOID
@@ -241,10 +344,11 @@ odm_Smart_HWAntDiv_Init_88E(
 
     ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8188E AntDiv_Init =>  AntDivType=[CG_TRX_SMART_ANTDIV]\n"));
     
-#if (MP_DRIVER == 1)
+	if(pDM_Odm->mp_mode == TRUE)
+	{
     ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("pDM_Odm->AntDivType: %d\n", pDM_Odm->AntDivType));
     return;
-#endif
+	}
 
 	for(i=0; i<6; i++)
 	{
@@ -346,14 +450,15 @@ odm_RX_HWAntDiv_Init_92E(
 )
 {
 	
-#if (MP_DRIVER == 1)
+	if(pDM_Odm->mp_mode == TRUE)
+	{
         //pDM_Odm->AntDivType = CGCS_RX_SW_ANTDIV;
 	odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
         ODM_SetBBReg(pDM_Odm, 0xc50 , BIT8, 0); //r_rxdiv_enable_anta  Regc50[8]=1'b0  0: control by c50[9]
         ODM_SetBBReg(pDM_Odm, 0xc50 , BIT9, 1);  // 1:CG, 0:CS
         return;
-#endif
-
+	}
+	
 	 ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***8192E AntDiv_Init =>  AntDivType=[CGCS_RX_HW_ANTDIV]\n"));
 	
 	 //Pin Settings
@@ -380,13 +485,14 @@ odm_TRX_HWAntDiv_Init_92E(
 )
 {
 	
-#if (MP_DRIVER == 1)
+	if(pDM_Odm->mp_mode == TRUE)
+	{
         //pDM_Odm->AntDivType = CGCS_RX_SW_ANTDIV;
 	odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
         ODM_SetBBReg(pDM_Odm, 0xc50 , BIT8, 0); //r_rxdiv_enable_anta  Regc50[8]=1'b0  0: control by c50[9]
         ODM_SetBBReg(pDM_Odm, 0xc50 , BIT9, 1);  // 1:CG, 0:CS
         return;
-#endif
+	}
 
 #if (DM_ODM_SUPPORT_TYPE & ODM_AP)
 	 pDM_Odm->antdiv_rssi=0;
@@ -528,8 +634,108 @@ odm_S0S1_SWAntDiv_Init_8723B(
 	ODM_SetBBReg(pDM_Odm, 0x80C , BIT21, 0); //TX Ant  by Reg
 
 }
-#endif //#if (RTL8723B_SUPPORT == 1)
 
+VOID
+odm_S0S1_SWAntDiv_Reset_8723B(
+	IN		PDM_ODM_T		pDM_Odm
+)
+{
+	pSWAT_T		pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+    
+	pDM_FatTable->bBecomeLinked  =FALSE;
+	pDM_SWAT_Table->try_flag = 0xff;	
+	pDM_SWAT_Table->Double_chk_flag = 0;
+	pDM_SWAT_Table->TrafficLoad = TRAFFIC_LOW;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_S0S1_SWAntDiv_Reset_8723B(): pDM_FatTable->bBecomeLinked = %d\n", pDM_FatTable->bBecomeLinked));
+}
+
+VOID
+ODM_UpdateRxIdleAnt_8723B(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			Ant,
+	IN		u4Byte			DefaultAnt, 
+	IN		u4Byte			OptionalAnt
+)
+{
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+	PADAPTER 		pAdapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	u1Byte			count=0;
+	u1Byte			u1Temp;
+	u1Byte			H2C_Parameter;
+	u4Byte			value32;
+	
+	if(!pDM_Odm->bLinked)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Fail to set RX antenna due to no link\n"));
+		return;
+	}
+
+	// Send H2C command to FW
+	// Enable wifi calibration
+	H2C_Parameter = TRUE;
+	ODM_FillH2CCmd(pDM_Odm, ODM_H2C_WIFI_CALIBRATION, 1, &H2C_Parameter);
+
+	// Check if H2C command sucess or not (0x1e6)
+	u1Temp = ODM_Read1Byte(pDM_Odm, 0x1e6);
+	while((u1Temp != 0x1) && (count < 100))
+	{
+		ODM_delay_us(10);	
+		u1Temp = ODM_Read1Byte(pDM_Odm, 0x1e6);
+		count++;
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: H2C command status = %d, count = %d\n", u1Temp, count));
+
+	if(u1Temp == 0x1)
+	{
+		// Check if BT is doing IQK (0x1e7)
+		count = 0;
+		u1Temp = ODM_Read1Byte(pDM_Odm, 0x1e7);
+		while((!(u1Temp & BIT0))  && (count < 100))
+		{
+			ODM_delay_us(50);	
+			u1Temp = ODM_Read1Byte(pDM_Odm, 0x1e7);
+			count++;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: BT IQK status = %d, count = %d\n", u1Temp, count));
+
+		if(u1Temp & BIT0)
+		{
+			ODM_SetBBReg(pDM_Odm, 0x948 , BIT6, 0x1);
+			ODM_SetBBReg(pDM_Odm, 0x948 , BIT9, DefaultAnt);	
+			ODM_SetBBReg(pDM_Odm, 0x864 , BIT5|BIT4|BIT3, DefaultAnt);	//Default RX
+			ODM_SetBBReg(pDM_Odm, 0x864 , BIT8|BIT7|BIT6, OptionalAnt);	//Optional RX
+			ODM_SetBBReg(pDM_Odm, 0x860, BIT14|BIT13|BIT12, DefaultAnt); //Default TX	
+			pDM_FatTable->RxIdleAnt = Ant;
+
+			// Set TX AGC by S0/S1
+			// Need to consider Linux driver
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+			 pAdapter->HalFunc.SetTxPowerLevelHandler(pAdapter, pHalData->CurrentChannel);
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)
+			rtw_hal_set_tx_power_level(pAdapter, pHalData->CurrentChannel);
+#endif
+
+			// Set IQC by S0/S1
+			ODM_SetIQCbyRFpath(pDM_Odm,DefaultAnt);
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Sucess to set RX antenna\n"));
+		}
+		else
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Fail to set RX antenna due to BT IQK\n"));
+	}
+	else
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Update Rx-Idle-Ant ] 8723B: Fail to set RX antenna due to H2C command fail\n"));
+
+	// Send H2C command to FW
+	// Disable wifi calibration
+	H2C_Parameter = FALSE;
+	ODM_FillH2CCmd(pDM_Odm, ODM_H2C_WIFI_CALIBRATION, 1, &H2C_Parameter);
+
+}
+
+#endif //#if (RTL8723B_SUPPORT == 1)
 
 #if (RTL8821A_SUPPORT == 1)
 VOID
@@ -583,7 +789,8 @@ odm_TRX_HWAntDiv_Init_8821A(
 	ODM_SetBBReg(pDM_Odm, 0xA74 , BIT7, 1); //patch for clk from 88M to 80M
 	ODM_SetBBReg(pDM_Odm, 0xA0C , BIT4, 1); //do 64 samples
 
-	ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function block enable
+	ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //ANTSEL_CCK sent to the smart_antenna circuit
+	ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, 0); //CCK AntDiv function block enable
 
 	//BT Coexistence
 	ODM_SetBBReg(pDM_Odm, 0xCAC , BIT9, 1); //keep antsel_map when GNT_BT = 1
@@ -596,9 +803,7 @@ odm_TRX_HWAntDiv_Init_8821A(
 	//response TX ant by RX ant
 	ODM_SetMACReg(pDM_Odm, 0x668 , BIT3, 1);
 	
-	//2 [--For HW Bug Setting]
-	if(pDM_Odm->AntType == ODM_AUTO_ANT)
-		ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function block enable
+
 			
 }
 
@@ -656,7 +861,8 @@ odm_S0S1_SWAntDiv_Init_8821A(
 	ODM_SetBBReg(pDM_Odm, 0xA74 , BIT7, 1); //patch for clk from 88M to 80M
 	ODM_SetBBReg(pDM_Odm, 0xA0C , BIT4, 1); //do 64 samples
 
-	ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function block enable
+	ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //ANTSEL_CCK sent to the smart_antenna circuit
+	ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, 0); //CCK AntDiv function block enable
 
 	//BT Coexistence
 	ODM_SetBBReg(pDM_Odm, 0xCAC , BIT9, 1); //keep antsel_map when GNT_BT = 1
@@ -669,10 +875,6 @@ odm_S0S1_SWAntDiv_Init_8821A(
 	//response TX ant by RX ant
 	ODM_SetMACReg(pDM_Odm, 0x668 , BIT3, 1);
 	
-	//2 [--For HW Bug Setting]
-	if(pDM_Odm->AntType == ODM_AUTO_ANT)
-		ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function block enable
-
 		
 	ODM_SetBBReg(pDM_Odm, 0x900 , BIT18, 0); 
 	
@@ -818,16 +1020,16 @@ odm_HW_AntDiv(
 		{
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[Linked !!!]\n"));
 			odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);
-			if(pDM_Odm->SupportICType == ODM_RTL8821 )
-				ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function disable
+			//if(pDM_Odm->SupportICType == ODM_RTL8821 )
+				//ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function disable
 				
-			#if(DM_ODM_SUPPORT_TYPE  == ODM_AP)
-			else if(pDM_Odm->SupportICType == ODM_RTL8881 )
-				ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function disable
-			#endif
+			//#if(DM_ODM_SUPPORT_TYPE  == ODM_AP)
+			//else if(pDM_Odm->SupportICType == ODM_RTL8881 )
+			//	ODM_SetBBReg(pDM_Odm, 0x800 , BIT25, 0); //CCK AntDiv function disable
+			//#endif
 			
-			else if(pDM_Odm->SupportICType == ODM_RTL8723B ||pDM_Odm->SupportICType == ODM_RTL8812)
-				ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, 0); //CCK AntDiv function disable
+			//else if(pDM_Odm->SupportICType == ODM_RTL8723B ||pDM_Odm->SupportICType == ODM_RTL8812)
+				//ODM_SetBBReg(pDM_Odm, 0xA00 , BIT15, 0); //CCK AntDiv function disable
 			
 			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
 
@@ -863,10 +1065,10 @@ odm_HW_AntDiv(
 					TargetAnt=AUX_ANT;
 			}
 			*/			
-			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("*** SupportICType=[%u] \n",pDM_Odm->SupportICType));
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***  Main_Cnt = (( %u ))  , Main_RSSI= ((  %u )) \n", pDM_FatTable->MainAnt_Cnt[i], Main_RSSI));
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***  Aux_Cnt   = (( %u ))  , Aux_RSSI = ((  %u )) \n", pDM_FatTable->AuxAnt_Cnt[i]  , Aux_RSSI ));
-			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** MAC ID:[ %u ] , TargetAnt = (( %s )) \n", i ,( TargetAnt ==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
+			//ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("*** SupportICType=[%lu] \n",pDM_Odm->SupportICType));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***  Main_Cnt = (( %d ))  , Main_RSSI= ((  %d )) \n", pDM_FatTable->MainAnt_Cnt[i], Main_RSSI));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("***  Aux_Cnt   = (( %d ))  , Aux_RSSI = ((  %d )) \n", pDM_FatTable->AuxAnt_Cnt[i]  , Aux_RSSI ));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("*** MAC ID:[ %d ] , TargetAnt = (( %s )) \n", i ,( TargetAnt ==MAIN_ANT)?"MAIN_ANT":"AUX_ANT"));
 
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,("*** Phy_AntSel_A=[ %d, %d, %d] \n",((pDM_Odm->DM_FatTable.antsel_rx_keep_0)&BIT2)>>2,
 				                                                                              ((pDM_Odm->DM_FatTable.antsel_rx_keep_0)&BIT1) >>1, ((pDM_Odm->DM_FatTable.antsel_rx_keep_0)&BIT0)));
@@ -934,7 +1136,10 @@ odm_HW_AntDiv(
 			panic_printk("*** RxIdleAnt = (( %s )) \n \n", ( RxIdleAnt ==MAIN_ANT)?"MAIN_ANT":"AUX_ANT");
 	#endif
 	
-	pDM_DigTable->AntDiv_RSSI_max = AntDivMaxRSSI;
+	if(AntDivMaxRSSI == 0)
+		pDM_DigTable->AntDiv_RSSI_max = pDM_Odm->RSSI_Min;
+	else
+        	pDM_DigTable->AntDiv_RSSI_max = AntDivMaxRSSI;
 	pDM_DigTable->RSSI_max = MaxRSSI;
 }
 
@@ -950,11 +1155,11 @@ odm_S0S1_SwAntDiv(
 	u4Byte			i,MinMaxRSSI=0xFF, LocalMaxRSSI,LocalMinRSSI;
 	u4Byte			Main_RSSI, Aux_RSSI;
 	u1Byte			reset_period=10, SWAntDiv_threshold=35;
-	u1Byte			HighTraffic_TrainTime_U=0x32,HighTraffic_TrainTime_L,Train_time_temp;
-	u1Byte			LowTraffic_TrainTime_U=200,LowTraffic_TrainTime_L;
-	u1Byte			RxIdleAnt, TargetAnt, nextAnt;
+	u1Byte			HighTraffic_TrainTime_U=0x32,HighTraffic_TrainTime_L=0,Train_time_temp;
+	u1Byte			LowTraffic_TrainTime_U=200,LowTraffic_TrainTime_L=0;
 	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
 	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;	
+	u1Byte			RxIdleAnt = pDM_SWAT_Table->PreAntenna, TargetAnt, nextAnt=0;
 	PSTA_INFO_T		pEntry=NULL;
 	//static u1Byte		reset_idx;
 	u4Byte			value32;
@@ -985,18 +1190,17 @@ odm_S0S1_SwAntDiv(
 				value32 = ODM_GetBBReg(pDM_Odm, 0x864, BIT5|BIT4|BIT3);
 				
 				if (value32==0x0)
-					ODM_UpdateRxIdleAnt(pDM_Odm, MAIN_ANT);
+					ODM_UpdateRxIdleAnt_8723B(pDM_Odm, MAIN_ANT, ANT1_2G, ANT2_2G);
 				else if (value32==0x1)
-					ODM_UpdateRxIdleAnt(pDM_Odm, AUX_ANT);
+					ODM_UpdateRxIdleAnt_8723B(pDM_Odm, AUX_ANT, ANT2_2G, ANT1_2G);
 				
-				ODM_SetBBReg(pDM_Odm, 0x948 , BIT6, 0x1);
-				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Set REG 948[6]=0x1 , Set REG 864[5:3]=0x%x \n",value32 ));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("8723B: First link! Force antenna to  %s\n",(value32 == 0x0?"MAIN":"AUX") ));
 			}
 
 			pDM_SWAT_Table->lastTxOkCnt = 0; 
 			pDM_SWAT_Table->lastRxOkCnt =0; 
-			TxCntOffset = Adapter->TxStats.NumTxBytesUnicast;
-			RxCntOffset = Adapter->RxStats.NumRxBytesUnicast;
+			TxCntOffset = *(pDM_Odm->pNumTxBytesUnicast);
+			RxCntOffset = *(pDM_Odm->pNumRxBytesUnicast);
 			
 			pDM_FatTable->bBecomeLinked = pDM_Odm->bLinked;
 		}
@@ -1032,10 +1236,10 @@ odm_S0S1_SwAntDiv(
 		{
 		
 			//---trafic decision---
-			curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - pDM_SWAT_Table->lastTxOkCnt - TxCntOffset;
-			curRxOkCnt =Adapter->RxStats.NumRxBytesUnicast - pDM_SWAT_Table->lastRxOkCnt - RxCntOffset;
-			pDM_SWAT_Table->lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
-			pDM_SWAT_Table->lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
+			curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast) - pDM_SWAT_Table->lastTxOkCnt - TxCntOffset;
+			curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast) - pDM_SWAT_Table->lastRxOkCnt - RxCntOffset;
+			pDM_SWAT_Table->lastTxOkCnt =  *(pDM_Odm->pNumTxBytesUnicast);
+			pDM_SWAT_Table->lastRxOkCnt =  *(pDM_Odm->pNumRxBytesUnicast);
 			
 			if (curTxOkCnt > 1875000 || curRxOkCnt > 1875000)//if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)  ( 1.875M * 8bit ) / 2= 7.5M bits /sec )
 			{
@@ -1169,8 +1373,8 @@ odm_S0S1_SwAntDiv(
 			else
 				pDM_SWAT_Table->RSSI_Trying = 1;
 			
+			odm_S0S1_SwAntDivByCtrlFrame(pDM_Odm, SWAW_STEP_PEAK);
 			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("[set try_flag=1]  Normal State:  Begin Trying!! \n"));
-									
 		}
 	
 		else if(pDM_SWAT_Table->try_flag == 1 && pDM_SWAT_Table->Double_chk_flag== 0)
@@ -1182,6 +1386,8 @@ odm_S0S1_SwAntDiv(
 		//1 Decision State
 		if((pDM_SWAT_Table->try_flag == 1)&&(pDM_SWAT_Table->RSSI_Trying == 0) )
 		{
+			BOOLEAN bByCtrlFrame = FALSE;
+			u8Byte	pkt_cnt_total = 0;
 			
 			for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
 			{
@@ -1248,13 +1454,60 @@ odm_S0S1_SwAntDiv(
 					pDM_FatTable->AuxAnt_Sum[i] = 0;
 					pDM_FatTable->MainAnt_Cnt[i] = 0;
 					pDM_FatTable->AuxAnt_Cnt[i] = 0;
-					pDM_FatTable->CCK_counter_main=0;
-					pDM_FatTable->CCK_counter_aux=0;
-					pDM_FatTable->OFDM_counter_main=0;
-					pDM_FatTable->OFDM_counter_aux=0;
+			}
 
+			if(pDM_SWAT_Table->bSWAntDivByCtrlFrame)
+			{
+				odm_S0S1_SwAntDivByCtrlFrame(pDM_Odm, SWAW_STEP_DETERMINE);
+				bByCtrlFrame = TRUE;
 			}
+
+			pkt_cnt_total = pDM_FatTable->CCK_counter_main + pDM_FatTable->CCK_counter_aux + 
+			pDM_FatTable->OFDM_counter_main + pDM_FatTable->OFDM_counter_aux;
+			pDM_FatTable->CCK_counter_main=0;
+			pDM_FatTable->CCK_counter_aux=0;
+			pDM_FatTable->OFDM_counter_main=0;
+			pDM_FatTable->OFDM_counter_aux=0;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Control frame packet counter = %d, Data frame packet counter = %llu\n", 
+				pDM_SWAT_Table->PktCnt_SWAntDivByCtrlFrame, pkt_cnt_total));
+
+			if(MinMaxRSSI == 0xff || ((pkt_cnt_total < (pDM_SWAT_Table->PktCnt_SWAntDivByCtrlFrame >> 1)) && pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 2))
+			{	
+				MinMaxRSSI = 0;
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Check RSSI of control frame because MinMaxRSSI == 0xff\n"));
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("bByCtrlFrame = %d\n", bByCtrlFrame));
+				
+				if(bByCtrlFrame)
+				{
+					Main_RSSI = (pDM_FatTable->MainAnt_CtrlFrame_Cnt!=0)?(pDM_FatTable->MainAnt_CtrlFrame_Sum/pDM_FatTable->MainAnt_CtrlFrame_Cnt):0;
+					Aux_RSSI = (pDM_FatTable->AuxAnt_CtrlFrame_Cnt!=0)?(pDM_FatTable->AuxAnt_CtrlFrame_Sum/pDM_FatTable->AuxAnt_CtrlFrame_Cnt):0;
+					
+					if(pDM_FatTable->MainAnt_CtrlFrame_Cnt<=1 && pDM_FatTable->CCK_CtrlFrame_Cnt_main>=1)
+						Main_RSSI=0;	
+					
+					if(pDM_FatTable->AuxAnt_CtrlFrame_Cnt<=1 && pDM_FatTable->CCK_CtrlFrame_Cnt_aux>=1)
+						Aux_RSSI=0;
+
+					if (Main_RSSI != 0 || Aux_RSSI != 0)
+					{
+						RxIdleAnt = (Main_RSSI==Aux_RSSI)?pDM_SWAT_Table->PreAntenna:((Main_RSSI>=Aux_RSSI)?MAIN_ANT:AUX_ANT);
+						LocalMaxRSSI = (Main_RSSI>=Aux_RSSI) ? Main_RSSI : Aux_RSSI;
+						LocalMinRSSI = (Main_RSSI>=Aux_RSSI) ? Aux_RSSI : Main_RSSI;
 		
+						if((LocalMaxRSSI-LocalMinRSSI)>8)
+							pDM_SWAT_Table->Train_time_flag=3;
+						else if((LocalMaxRSSI-LocalMinRSSI)>5)
+							pDM_SWAT_Table->Train_time_flag=2;
+						else if((LocalMaxRSSI-LocalMinRSSI)>2)
+							pDM_SWAT_Table->Train_time_flag=1;
+						else
+							pDM_SWAT_Table->Train_time_flag=0;
+
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Control frame: Main_RSSI = %d, Aux_RSSI = %d\n", Main_RSSI, Aux_RSSI));
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("RxIdleAnt decided by control frame = %s\n", (RxIdleAnt == MAIN_ANT?"MAIN":"AUX")));
+					}
+				}
+			}
 			
 			pDM_FatTable->MinMaxRSSI=MinMaxRSSI;
 			pDM_SWAT_Table->try_flag = 0;
@@ -1286,6 +1539,9 @@ odm_S0S1_SwAntDiv(
 			}
 			else
 			{
+				if(pDM_FatTable->MinMaxRSSI < SWAntDiv_threshold)
+					pDM_SWAT_Table->reset_idx=reset_period;
+				
 				pDM_SWAT_Table->PreAntenna =RxIdleAnt;
 				ODM_UpdateRxIdleAnt(pDM_Odm, RxIdleAnt );
 				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("[reset try_flag = 0] Training accomplished !!!] \n\n\n"));
@@ -1348,19 +1604,149 @@ ODM_SW_AntDiv_WorkitemCallback(
 	//DbgPrint("SW_antdiv_Workitem_Callback");
 	odm_S0S1_SwAntDiv(&pHalData->DM_OutSrc, SWAW_STEP_DETERMINE);
 }
-#endif  //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+VOID
+ODM_SW_AntDiv_WorkitemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER		pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+
+	//DbgPrint("SW_antdiv_Workitem_Callback");
+	odm_S0S1_SwAntDiv(&pHalData->odmpriv, SWAW_STEP_DETERMINE);
+}
+
 VOID
 ODM_SW_AntDiv_Callback(void *FunctionContext)
 {
 	PDM_ODM_T	pDM_Odm= (PDM_ODM_T)FunctionContext;
 	PADAPTER	padapter = pDM_Odm->Adapter;
+
+
 	if(padapter->net_closed == _TRUE)
 	    return;
-	//odm_S0S1_SwAntDiv(pDM_Odm, SWAW_STEP_DETERMINE);	
+
+#if 0 // Can't do I/O in timer callback
+	odm_S0S1_SwAntDiv(pDM_Odm, SWAW_STEP_DETERMINE);
+#else
+	rtw_run_in_thread_cmd(padapter, ODM_SW_AntDiv_WorkitemCallback, padapter);
+#endif
 }
-#endif  //#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+#endif
+
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+VOID
+odm_S0S1_SwAntDivByCtrlFrame(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			Step
+	)
+{
+	pSWAT_T	pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
+	
+	switch(Step)
+	{
+		case SWAW_STEP_PEAK:
+			pDM_SWAT_Table->PktCnt_SWAntDivByCtrlFrame = 0;
+			pDM_SWAT_Table->bSWAntDivByCtrlFrame = TRUE;
+			pDM_FatTable->MainAnt_CtrlFrame_Cnt = 0;
+			pDM_FatTable->AuxAnt_CtrlFrame_Cnt = 0;
+			pDM_FatTable->MainAnt_CtrlFrame_Sum = 0;
+			pDM_FatTable->AuxAnt_CtrlFrame_Sum = 0;
+			pDM_FatTable->CCK_CtrlFrame_Cnt_main = 0;
+			pDM_FatTable->CCK_CtrlFrame_Cnt_aux = 0;
+			pDM_FatTable->OFDM_CtrlFrame_Cnt_main = 0;
+			pDM_FatTable->OFDM_CtrlFrame_Cnt_aux = 0;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("odm_S0S1_SwAntDivForAPMode(): Start peak and reset counter\n"));
+			break;
+		case SWAW_STEP_DETERMINE:
+			pDM_SWAT_Table->bSWAntDivByCtrlFrame = FALSE;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("odm_S0S1_SwAntDivForAPMode(): Stop peak\n"));
+			break;
+		default:
+			pDM_SWAT_Table->bSWAntDivByCtrlFrame = FALSE;
+			break;
+	}			
+}
+
+VOID
+odm_AntselStatisticsOfCtrlFrame(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			antsel_tr_mux,
+	IN		u4Byte			RxPWDBAll
+)
+{
+	pFAT_T	pDM_FatTable = &pDM_Odm->DM_FatTable;
+
+	if(antsel_tr_mux == ANT1_2G)
+	{
+		pDM_FatTable->MainAnt_CtrlFrame_Sum+=RxPWDBAll;
+		pDM_FatTable->MainAnt_CtrlFrame_Cnt++;
+	}
+	else
+	{
+		pDM_FatTable->AuxAnt_CtrlFrame_Sum+=RxPWDBAll;
+		pDM_FatTable->AuxAnt_CtrlFrame_Cnt++;
+	}
+}
+
+VOID
+odm_S0S1_SwAntDivByCtrlFrame_ProcessRSSI(
+	IN		PDM_ODM_T				pDM_Odm,
+	IN		PODM_PHY_INFO_T		pPhyInfo,
+	IN		PODM_PACKET_INFO_T		pPktinfo
+	)
+{
+	pSWAT_T	pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	pFAT_T		pDM_FatTable = &pDM_Odm->DM_FatTable;
+	BOOLEAN		isCCKrate;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
+		return;
+
+	if(pDM_Odm->AntDivType != S0S1_SW_ANTDIV)
+		return;
+
+	// In try state
+	if(!pDM_SWAT_Table->bSWAntDivByCtrlFrame)
+		return;
+
+	// No HW error and match receiver address
+	if(!pPktinfo->bToSelf)
+		return;
+	
+	pDM_SWAT_Table->PktCnt_SWAntDivByCtrlFrame++;
+	isCCKrate = ((pPktinfo->DataRate >= DESC_RATE1M ) && (pPktinfo->DataRate <= DESC_RATE11M ))?TRUE :FALSE;
+
+	if(isCCKrate)
+	{
+	 	pDM_FatTable->antsel_rx_keep_0 = (pDM_FatTable->RxIdleAnt == MAIN_ANT) ? ANT1_2G : ANT2_2G;
+
+		if(pDM_FatTable->antsel_rx_keep_0==ANT1_2G)
+			pDM_FatTable->CCK_CtrlFrame_Cnt_main++;
+		else
+			pDM_FatTable->CCK_CtrlFrame_Cnt_aux++;
+
+		odm_AntselStatisticsOfCtrlFrame(pDM_Odm, pDM_FatTable->antsel_rx_keep_0, pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A]);
+	}
+	else
+	{
+		if(pDM_FatTable->antsel_rx_keep_0==ANT1_2G)
+			pDM_FatTable->OFDM_CtrlFrame_Cnt_main++;
+		else
+			pDM_FatTable->OFDM_CtrlFrame_Cnt_aux++;
+
+		odm_AntselStatisticsOfCtrlFrame(pDM_Odm, pDM_FatTable->antsel_rx_keep_0, pPhyInfo->RxPWDBAll);
+	}
+}
+#endif  //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+
 
 #endif //#if (RTL8723B_SUPPORT == 1)
 
@@ -1610,6 +1996,17 @@ odm_FastAntTrainingWorkItemCallback(
 
 #endif
 
+VOID
+ODM_AntDivReset(
+	IN PDM_ODM_T	pDM_Odm 
+	)
+{
+	//2 [--8723B---]
+#if (RTL8723B_SUPPORT == 1)
+	if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		odm_S0S1_SWAntDiv_Reset_8723B(pDM_Odm);
+#endif
+}
 
 VOID
 ODM_AntDivInit(
@@ -1883,7 +2280,7 @@ ODM_AntDiv(
 	
         {
 	#if (BEAMFORMING_SUPPORT == 1)			
-	        BEAMFORMING_CAP		BeamformCap = (pAdapter->MgntInfo.BeamformingInfo.BeamformCap);
+	        BEAMFORMING_CAP		BeamformCap = (pDM_Odm->BeamformingInfo.BeamformCap);
 
 		if( BeamformCap & BEAMFORMEE_CAP ) //  BFmee On  &&   Div On ->  Div Off
 		{	
@@ -2017,12 +2414,15 @@ ODM_AntDiv(
 	#if (RTL8821A_SUPPORT == 1)
 	else if(pDM_Odm->SupportICType == ODM_RTL8821)
 	{
-		if(pDM_Odm->bBtDisabled)  //BT disabled
+		if(!pDM_Odm->bBtEnabled)  //BT disabled
 		{
 			if(pDM_Odm->AntDivType == S0S1_SW_ANTDIV)
 			{
 			pDM_Odm->AntDivType=CG_TRX_HW_ANTDIV;
-			ODM_SetBBReg(pDM_Odm, 0x8D4 , BIT24, 1); 
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,(" [S0S1_SW_ANTDIV]  ->  [CG_TRX_HW_ANTDIV]\n"));
+				//ODM_SetBBReg(pDM_Odm, 0x8D4 , BIT24, 1); 
+				if(pDM_FatTable->bBecomeLinked ==TRUE)
+					odm_AntDiv_on_off(pDM_Odm, ANTDIV_ON);
 			}
 		}	
 		else //BT enabled
@@ -2030,7 +2430,9 @@ ODM_AntDiv(
 			if(pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV)
 			{
 			pDM_Odm->AntDivType=S0S1_SW_ANTDIV;
-			ODM_SetBBReg(pDM_Odm, 0x8D4 , BIT24, 0); 
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV,ODM_DBG_LOUD,(" [CG_TRX_HW_ANTDIV]  ->  [S0S1_SW_ANTDIV]\n"));
+				//ODM_SetBBReg(pDM_Odm, 0x8D4 , BIT24, 0);
+				odm_AntDiv_on_off(pDM_Odm, ANTDIV_OFF);
 			}	
 		}	
 	
@@ -2152,7 +2554,6 @@ pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
 				}
 				else
 				{
-
 					if(pDM_FatTable->antsel_rx_keep_0==ANT1_2G)
 						pDM_FatTable->OFDM_counter_main++;
 					else// if(pDM_FatTable->antsel_rx_keep_0==ANT2_2G)
@@ -2185,29 +2586,29 @@ ODM_SetTxAntByTxInfo(
 
 	if(pDM_Odm->SupportICType == ODM_RTL8723B)
 	{
-#if (RTL8723B_SUPPORT == 1)
+		#if (RTL8723B_SUPPORT == 1)
 		SET_TX_DESC_ANTSEL_A_8723B(pDesc, pDM_FatTable->antsel_a[macId]);
 		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[8723B] SetTxAntByTxInfo_WIN: MacID=%d, antsel_tr_mux=3'b%d%d%d\n", 
 			//macId, pDM_FatTable->antsel_c[macId], pDM_FatTable->antsel_b[macId], pDM_FatTable->antsel_a[macId]));
-#endif
+		#endif
 	}
 	else if(pDM_Odm->SupportICType == ODM_RTL8821)
 	{
-#if (RTL8821A_SUPPORT == 1)
+		#if (RTL8821A_SUPPORT == 1)
 		SET_TX_DESC_ANTSEL_A_8812(pDesc, pDM_FatTable->antsel_a[macId]);
 		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[8821A] SetTxAntByTxInfo_WIN: MacID=%d, antsel_tr_mux=3'b%d%d%d\n", 
 			//macId, pDM_FatTable->antsel_c[macId], pDM_FatTable->antsel_b[macId], pDM_FatTable->antsel_a[macId]));
-#endif
+		#endif
 	}
 	else if(pDM_Odm->SupportICType == ODM_RTL8188E)
 	{
-#if (RTL8188E_SUPPORT == 1)
+		#if (RTL8188E_SUPPORT == 1)
 		SET_TX_DESC_ANTSEL_A_88E(pDesc, pDM_FatTable->antsel_a[macId]);
 		SET_TX_DESC_ANTSEL_B_88E(pDesc, pDM_FatTable->antsel_b[macId]);
 		SET_TX_DESC_ANTSEL_C_88E(pDesc, pDM_FatTable->antsel_c[macId]);
 		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[8188E] SetTxAntByTxInfo_WIN: MacID=%d, antsel_tr_mux=3'b%d%d%d\n", 
 			//macId, pDM_FatTable->antsel_c[macId], pDM_FatTable->antsel_b[macId], pDM_FatTable->antsel_a[macId]));
-#endif
+		#endif
 	}
 	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
 	{
@@ -2259,10 +2660,190 @@ ODM_SetTxAntByTxInfo(
 }
 #endif
 
-#else
 
-VOID ODM_AntDivInit(	IN PDM_ODM_T	pDM_Odm ){}
-VOID ODM_AntDiv(	IN PDM_ODM_T		pDM_Odm){}
+VOID
+ODM_AntDiv_Config(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+	pFAT_T			pDM_FatTable = &pDM_Odm->DM_FatTable;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("WIN Config Antenna Diversity\n"));
+		if(pDM_Odm->SupportICType==ODM_RTL8723B)
+		{
+			if((!pDM_Odm->DM_SWAT_Table.ANTA_ON || !pDM_Odm->DM_SWAT_Table.ANTB_ON))
+				pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+		}
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("CE Config Antenna Diversity\n"));
+		//if(pDM_Odm->SupportICType & ODM_ANTDIV_SUPPORT)
+		//{
+			//pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;
+		//}
+		
+		if(pDM_Odm->SupportICType==ODM_RTL8723B)
+		{
+			pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+		}	
+
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP))
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("AP Config Antenna Diversity\n"));
+
+	//2 [ NOT_SUPPORT_ANTDIV ]
+	#if(defined(CONFIG_NOT_SUPPORT_ANTDIV)) 
+		pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Disable AntDiv function] : Not Support 2.4G & 5G Antenna Diversity\n"));
+		
+		//2 [ 2G&5G_SUPPORT_ANTDIV ]
+	#elif(defined(CONFIG_2G5G_SUPPORT_ANTDIV))
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Enable AntDiv function] : 2.4G & 5G Support Antenna Diversity Simultaneously \n"));
+		pDM_FatTable->AntDiv_2G_5G = (ODM_ANTDIV_2G|ODM_ANTDIV_5G);
+
+		if(pDM_Odm->SupportICType & ODM_ANTDIV_SUPPORT)
+			pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;
+		if(*pDM_Odm->pBandType == ODM_BAND_5G )
+		{
+				#if ( defined(CONFIG_5G_CGCS_RX_DIVERSITY) )
+					pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV; 
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));
+					panic_printk("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n");
+				#elif( defined(CONFIG_5G_CG_TRX_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));				
+					panic_printk("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n");
+				#elif( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_SMART_ANTDIV\n"));
+				#elif( defined(CONFIG_5G_S0S1_SW_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = S0S1_SW_ANTDIV\n"));
+				#endif
+		}		
+		else if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
+		 {
+				#if ( defined(CONFIG_2G_CGCS_RX_DIVERSITY) )
+						pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));		
+				#elif( defined(CONFIG_2G_CG_TRX_DIVERSITY) )
+						pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
+				#elif( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+						pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_SMART_ANTDIV\n"));
+				#elif( defined(CONFIG_2G_S0S1_SW_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = S0S1_SW_ANTDIV\n"));
+				#endif
+		}
+		
+		//2 [ 5G_SUPPORT_ANTDIV ]
+	#elif(defined(CONFIG_5G_SUPPORT_ANTDIV))
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Enable AntDiv function] : Only 5G Support Antenna Diversity\n"));
+		panic_printk("[ Enable AntDiv function] : Only 5G Support Antenna Diversity\n");
+		pDM_FatTable->AntDiv_2G_5G = (ODM_ANTDIV_5G);
+		if(*pDM_Odm->pBandType == ODM_BAND_5G )
+		{
+				if(pDM_Odm->SupportICType & ODM_ANTDIV_5G_SUPPORT_IC)
+				pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;	
+				#if ( defined(CONFIG_5G_CGCS_RX_DIVERSITY) )
+					pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));
+					panic_printk("[ 5G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n");
+				#elif( defined(CONFIG_5G_CG_TRX_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+					panic_printk("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n");
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
+				#elif( defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = CG_SMART_ANTDIV\n"));
+				#elif( defined(CONFIG_5G_S0S1_SW_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 5G] : AntDiv Type = S0S1_SW_ANTDIV\n"));
+				#endif
+		}
+		else if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
+		{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Not Support 2G AntDivType\n"));
+				pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+		}
+		
+		//2 [ 2G_SUPPORT_ANTDIV ]
+	#elif(defined(CONFIG_2G_SUPPORT_ANTDIV)) 
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ Enable AntDiv function] : Only 2.4G Support Antenna Diversity\n"));
+		pDM_FatTable->AntDiv_2G_5G = (ODM_ANTDIV_2G);
+		if(*pDM_Odm->pBandType == ODM_BAND_2_4G )
+		{
+				if(pDM_Odm->SupportICType & ODM_ANTDIV_2G_SUPPORT_IC)
+					pDM_Odm->SupportAbility |= ODM_BB_ANT_DIV;
+				#if ( defined(CONFIG_2G_CGCS_RX_DIVERSITY) )
+					pDM_Odm->AntDivType = CGCS_RX_HW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CGCS_RX_HW_ANTDIV\n"));		
+				#elif( defined(CONFIG_2G_CG_TRX_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_TRX_HW_ANTDIV\n"));
+				#elif( defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = CG_TRX_SMART_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = CG_SMART_ANTDIV\n"));
+				#elif( defined(CONFIG_2G_S0S1_SW_ANT_DIVERSITY) )
+					pDM_Odm->AntDivType = S0S1_SW_ANTDIV;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("[ 2.4G] : AntDiv Type = S0S1_SW_ANTDIV\n"));
+				#endif
+		}
+		else if(*pDM_Odm->pBandType == ODM_BAND_5G )
+		{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD,("Not Support 5G AntDivType\n"));
+				pDM_Odm->SupportAbility &= ~(ODM_BB_ANT_DIV);
+		}
+	#endif		
+#endif
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("SupportAbility = (( %x ))\n", pDM_Odm->SupportAbility ));
+
+}
+
+
+VOID
+ODM_AntDivTimers(
+	IN PDM_ODM_T	pDM_Odm,
+	IN u1Byte			state
+	)
+{
+	if(state==INIT_ANTDIV_TIMMER)
+	{
+		#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
+			ODM_InitializeTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer_8723B,
+			(RT_TIMER_CALL_BACK)ODM_SW_AntDiv_Callback, NULL, "SwAntennaSwitchTimer_8723B");
+		#elif (RTL8188E_SUPPORT == 1)
+			#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+			ODM_InitializeTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer,
+			(RT_TIMER_CALL_BACK)odm_FastAntTrainingCallback, NULL, "FastAntTrainingTimer");
+			#endif
+		#endif
+	}
+	else if(state==CANCEL_ANTDIV_TIMMER)
+	{
+		#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
+			ODM_CancelTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer_8723B);
+		#elif (RTL8188E_SUPPORT == 1)
+			#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+			ODM_CancelTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer);
+			#endif
+		#endif
+	}
+	else if(state==RELEASE_ANTDIV_TIMMER)
+	{
+		#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
+			ODM_ReleaseTimer(pDM_Odm,&pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer_8723B);
+		#elif (RTL8188E_SUPPORT == 1)
+			#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+			ODM_ReleaseTimer(pDM_Odm,&pDM_Odm->FastAntTrainingTimer);
+			#endif
+		#endif
+	}
+
+}
 
 #endif //#if (defined(CONFIG_HW_ANTENNA_DIVERSITY))
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_AntDiv.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDiv.h
similarity index 64%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_AntDiv.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDiv.h
index 832ee6b4f3cb..1e88e11fef8e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_AntDiv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_AntDiv.h
@@ -18,10 +18,10 @@
  *
  ******************************************************************************/
  
-#ifndef	__ODMANTDIV_H__
-#define    __ODMANTDIV_H__
-
+#ifndef	__PHYDMANTDIV_H__
+#define    __PHYDMANTDIV_H__
 
+#define ANTDIV_VERSION	"1.0"
 
 #define ANT1_2G 0 // = ANT2_5G
 #define ANT2_2G 1 // = ANT1_5G
@@ -42,6 +42,8 @@
 #define ODM_AC_ANTDIV_SUPPORT		(ODM_RTL8821|ODM_RTL8881A|ODM_RTL8812)
 #define ODM_SMART_ANT_SUPPORT		(ODM_RTL8188E|ODM_RTL8192E)
 
+#define ODM_OLD_IC_ANTDIV_SUPPORT		(ODM_RTL8723A|ODM_RTL8192C|ODM_RTL8192D)
+
 #define ODM_ANTDIV_2G_SUPPORT_IC			(ODM_RTL8188E|ODM_RTL8192E|ODM_RTL8723B|ODM_RTL8881A)
 #define ODM_ANTDIV_5G_SUPPORT_IC			(ODM_RTL8821|ODM_RTL8881A|ODM_RTL8812)
 #define ODM_ANTDIV_2G	BIT0
@@ -50,15 +52,24 @@
 #define ANTDIV_ON 1
 #define ANTDIV_OFF 0
 
-VOID
-ODM_AntDivInit(
-	IN		 PDM_ODM_T		pDM_Odm 
-);
+#define INIT_ANTDIV_TIMMER 0
+#define CANCEL_ANTDIV_TIMMER 1
+#define RELEASE_ANTDIV_TIMMER 2
 
 VOID
-ODM_AntDiv(
-	IN		PDM_ODM_T		pDM_Odm
-);
+ODM_StopAntennaSwitchDm(
+	IN	PDM_ODM_T	pDM_Odm
+	);
+VOID
+ODM_SetAntConfig(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN	u1Byte		antSetting	// 0=A, 1=B, 2=C, ....
+	);
+
+
+
+#define SwAntDivRestAfterLink	ODM_SwAntDivRestAfterLink
+VOID ODM_SwAntDivRestAfterLink(	IN	PDM_ODM_T	pDM_Odm);
 
 #if (defined(CONFIG_HW_ANTENNA_DIVERSITY))
 
@@ -68,6 +79,14 @@ ODM_UpdateRxIdleAnt(
 	IN		 u1Byte			Ant
 );
 
+VOID
+odm_AntselStatistics(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			antsel_tr_mux,
+	IN		u4Byte			MacId,
+	IN		u4Byte			RxPWDBAll
+);
+
 #if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 VOID
@@ -77,13 +96,39 @@ ODM_SW_AntDiv_Callback(
 
 VOID
 ODM_SW_AntDiv_WorkitemCallback(
-    	IN 	PVOID            pContext
-);
-#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+    IN PVOID            pContext
+    );
+
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
 VOID
 ODM_SW_AntDiv_Callback(void *FunctionContext);
-#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+VOID
+odm_S0S1_SwAntDivByCtrlFrame(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			Step
+	);
+
+VOID
+odm_AntselStatisticsOfCtrlFrame(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			antsel_tr_mux,
+	IN		u4Byte			RxPWDBAll
+);
+
+VOID
+odm_S0S1_SwAntDivByCtrlFrame_ProcessRSSI(
+	IN		PDM_ODM_T				pDM_Odm,
+	IN		PODM_PHY_INFO_T		pPhyInfo,
+	IN		PODM_PACKET_INFO_T		pPktinfo
+	);
+
+#endif  //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 #endif
 
 #if(RTL8188E_SUPPORT == 1  || RTL8192E_SUPPORT == 1)
@@ -105,6 +150,21 @@ odm_FastAntTrainingWorkItemCallback(
 #endif
 #endif
 
+VOID
+ODM_AntDivInit(
+	IN		 PDM_ODM_T		pDM_Odm 
+);
+
+VOID
+ODM_AntDivReset(
+	IN		PDM_ODM_T		pDM_Odm 
+);
+
+VOID
+ODM_AntDiv(
+	IN		PDM_ODM_T		pDM_Odm
+);
+
 VOID
 ODM_Process_RSSIForAntDiv(	
 	IN OUT	PDM_ODM_T					pDM_Odm,
@@ -132,5 +192,26 @@ ODM_SetTxAntByTxInfo(
 
 #endif
 
+
+VOID
+ODM_AntDiv_Config(
+	IN		PDM_ODM_T		pDM_Odm
+);
+
+
+VOID
+ODM_UpdateRxIdleAnt_8723B(
+	IN		PDM_ODM_T		pDM_Odm,
+	IN		u1Byte			Ant,
+	IN		u4Byte			DefaultAnt, 
+	IN		u4Byte			OptionalAnt
+);
+
+VOID
+ODM_AntDivTimers(
+	IN PDM_ODM_T	pDM_Odm,
+	IN u1Byte			state
+);
+
 #endif //#if (defined(CONFIG_HW_ANTENNA_DIVERSITY))
 #endif //#ifndef	__ODMANTDIV_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_CfoTracking.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_CfoTracking.c
new file mode 100644
index 000000000000..489bc49806fe
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_CfoTracking.c
@@ -0,0 +1,357 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+VOID
+odm_SetCrystalCap(
+	IN		PVOID					pDM_VOID,
+	IN		u1Byte					CrystalCap
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+	BOOLEAN 					bEEPROMCheck;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PADAPTER					Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
+
+	bEEPROMCheck = (pHalData->EEPROMVersion >= 0x01)?TRUE:FALSE;
+#else
+	bEEPROMCheck = TRUE;
+#endif
+
+	if(pCfoTrack->CrystalCap == CrystalCap)
+		return;
+
+	pCfoTrack->CrystalCap = CrystalCap;
+
+	if(pDM_Odm->SupportICType & ODM_RTL8192D)
+	{
+		ODM_SetBBReg(pDM_Odm, REG_AFE_XTAL_CTRL, 0x000000F0, CrystalCap & 0x0F);
+		ODM_SetBBReg(pDM_Odm, REG_AFE_PLL_CTRL, 0xF0000000, ((CrystalCap & 0xF0) >> 4));
+	}
+	else if(pDM_Odm->SupportICType & ODM_RTL8188E)
+	{
+		// write 0x24[22:17] = 0x24[16:11] = CrystalCap
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_AFE_XTAL_CTRL, 0x007ff800, (CrystalCap | (CrystalCap << 6)));
+	}
+	else if(pDM_Odm->SupportICType & ODM_RTL8812)
+	{
+		// write 0x2C[30:25] = 0x2C[24:19] = CrystalCap
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_MAC_PHY_CTRL, 0x7FF80000, (CrystalCap | (CrystalCap << 6)));
+	}	
+	else if (((pDM_Odm->SupportICType & ODM_RTL8723A) && bEEPROMCheck) ||
+		(pDM_Odm->SupportICType & ODM_RTL8723B) ||(pDM_Odm->SupportICType & ODM_RTL8192E) ||
+		(pDM_Odm->SupportICType & ODM_RTL8821))
+	{
+		// 0x2C[23:18] = 0x2C[17:12] = CrystalCap
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_MAC_PHY_CTRL, 0x00FFF000, (CrystalCap | (CrystalCap << 6)));	
+	}
+	else if(pDM_Odm->SupportICType & ODM_RTL8821B)
+	{
+		// write 0x28[6:1] = 0x24[30:25] = CrystalCap
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_AFE_XTAL_CTRL, 0x7E000000, CrystalCap);
+		ODM_SetBBReg(pDM_Odm, REG_AFE_PLL_CTRL, 0x7E, CrystalCap);	
+	}
+	else if(pDM_Odm->SupportICType & ODM_RTL8814A)
+	{
+		// write 0x2C[26:21] = 0x2C[20:15] = CrystalCap
+		CrystalCap = CrystalCap & 0x3F;
+		ODM_SetBBReg(pDM_Odm, REG_MAC_PHY_CTRL, 0x07FF8000, (CrystalCap | (CrystalCap << 6)));
+	}
+	else 
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("odm_SetCrystalCap(): Use default setting.\n"));
+		ODM_SetBBReg(pDM_Odm, REG_MAC_PHY_CTRL, 0xFFF000, (CrystalCap | (CrystalCap << 6)));
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("odm_SetCrystalCap(): CrystalCap = 0x%x\n", CrystalCap));
+}
+
+u1Byte
+odm_GetDefaultCrytaltalCap(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte						CrystalCap = 0x20;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PADAPTER					Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
+
+	CrystalCap = pHalData->CrystalCap;
+#else
+	prtl8192cd_priv	priv		= pDM_Odm->priv;
+
+	if(priv->pmib->dot11RFEntry.xcap > 0)
+		CrystalCap = priv->pmib->dot11RFEntry.xcap;
+#endif
+
+	CrystalCap = CrystalCap & 0x3f;
+
+	return CrystalCap;
+}
+
+VOID
+odm_SetATCStatus(
+	IN		PVOID					pDM_VOID,
+	IN		BOOLEAN					ATCStatus
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+
+	if(pCfoTrack->bATCStatus == ATCStatus)
+		return;
+	
+	ODM_SetBBReg(pDM_Odm, ODM_REG(BB_ATC,pDM_Odm), ODM_BIT(BB_ATC,pDM_Odm), ATCStatus);
+	pCfoTrack->bATCStatus = ATCStatus;
+}
+
+BOOLEAN
+odm_GetATCStatus(
+	IN		PVOID					pDM_VOID
+)
+{
+	BOOLEAN						ATCStatus;
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	ATCStatus = (BOOLEAN)ODM_GetBBReg(pDM_Odm, ODM_REG(BB_ATC,pDM_Odm), ODM_BIT(BB_ATC,pDM_Odm));
+	return ATCStatus;
+}
+
+VOID
+ODM_CfoTrackingReset(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+	u1Byte						CrystalCap;
+
+	pCfoTrack->DefXCap = odm_GetDefaultCrytaltalCap(pDM_Odm);
+	pCfoTrack->bAdjust = TRUE;
+	
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	odm_SetCrystalCap(pDM_Odm, pCfoTrack->DefXCap);
+	odm_SetATCStatus(pDM_Odm, TRUE);
+#else
+	if(pCfoTrack->CrystalCap > pCfoTrack->DefXCap)
+	{
+		for(CrystalCap = pCfoTrack->CrystalCap; CrystalCap >= pCfoTrack->DefXCap; CrystalCap--)
+			odm_SetCrystalCap(pDM_Odm, CrystalCap);
+	}
+	else
+	{
+		for(CrystalCap = pCfoTrack->CrystalCap; CrystalCap <= pCfoTrack->DefXCap; CrystalCap++)
+			odm_SetCrystalCap(pDM_Odm, CrystalCap);
+	}
+#endif
+}
+
+VOID
+ODM_CfoTrackingInit(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+      
+	pCfoTrack->DefXCap = pCfoTrack->CrystalCap = odm_GetDefaultCrytaltalCap(pDM_Odm);
+	pCfoTrack->bATCStatus = odm_GetATCStatus(pDM_Odm);
+	pCfoTrack->bAdjust = TRUE;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking_init()=========> \n"));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking_init(): bATCStatus = %d, CrystalCap = 0x%x \n",pCfoTrack->bATCStatus, pCfoTrack->DefXCap));
+}
+
+VOID
+ODM_CfoTracking(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PCFO_TRACKING				pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+	int							CFO_kHz_A, CFO_kHz_B, CFO_ave = 0;
+	int							CFO_ave_diff;
+	int							CrystalCap = (int)pCfoTrack->CrystalCap;
+	u1Byte						Adjust_Xtal = 1;
+
+	//4 Support ability
+	if(!(pDM_Odm->SupportAbility & ODM_BB_CFO_TRACKING))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Return: SupportAbility ODM_BB_CFO_TRACKING is disabled\n"));
+		return;
+	}
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking()=========> \n"));
+
+	if(!pDM_Odm->bLinked || !pDM_Odm->bOneEntryOnly)
+	{	
+		//4 No link or more than one entry
+		ODM_CfoTrackingReset(pDM_Odm);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Reset: bLinked = %d, bOneEntryOnly = %d\n", 
+			pDM_Odm->bLinked, pDM_Odm->bOneEntryOnly));
+	}
+	else
+	{
+		//3 1. CFO Tracking
+		//4 1.1 No new packet
+		if(pCfoTrack->packetCount == pCfoTrack->packetCount_pre)
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): packet counter doesn't change\n"));
+			return;
+		}
+		pCfoTrack->packetCount_pre = pCfoTrack->packetCount;
+	
+		//4 1.2 Calculate CFO
+		CFO_kHz_A =  (int)(pCfoTrack->CFO_tail[0] * 3125)  / 1280;
+		CFO_kHz_B =  (int)(pCfoTrack->CFO_tail[1] * 3125)  / 1280;
+		
+		if(pDM_Odm->RFType < ODM_2T2R)
+			CFO_ave = CFO_kHz_A;
+		else
+			CFO_ave = (int)(CFO_kHz_A + CFO_kHz_B) >> 1;
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): CFO_kHz_A = %dkHz, CFO_kHz_B = %dkHz, CFO_ave = %dkHz\n", 
+						CFO_kHz_A, CFO_kHz_B, CFO_ave));
+
+		//4 1.3 Avoid abnormal large CFO
+		CFO_ave_diff = (pCfoTrack->CFO_ave_pre >= CFO_ave)?(pCfoTrack->CFO_ave_pre - CFO_ave):(CFO_ave - pCfoTrack->CFO_ave_pre);
+		if(CFO_ave_diff > 20 && pCfoTrack->largeCFOHit == 0 && !pCfoTrack->bAdjust)
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): first large CFO hit\n"));
+			pCfoTrack->largeCFOHit = 1;
+			return;
+		}
+		else
+			pCfoTrack->largeCFOHit = 0;
+		pCfoTrack->CFO_ave_pre = CFO_ave;
+
+		//4 1.4 Dynamic Xtal threshold
+		if(pCfoTrack->bAdjust == FALSE)
+		{
+			if(CFO_ave > CFO_TH_XTAL_HIGH || CFO_ave < (-CFO_TH_XTAL_HIGH))
+				pCfoTrack->bAdjust = TRUE;
+		}
+		else
+		{
+			if(CFO_ave < CFO_TH_XTAL_LOW && CFO_ave > (-CFO_TH_XTAL_LOW))
+				pCfoTrack->bAdjust = FALSE;
+		}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+		//4 1.5 BT case: Disable CFO tracking
+		if(pDM_Odm->bBtEnabled)
+		{
+			pCfoTrack->bAdjust = FALSE;
+			odm_SetCrystalCap(pDM_Odm, pCfoTrack->DefXCap);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Disable CFO tracking for BT!!\n"));
+		}
+
+		//4 1.6 Big jump 
+		if(pCfoTrack->bAdjust)
+		{
+			if(CFO_ave > CFO_TH_XTAL_LOW)
+				Adjust_Xtal =  Adjust_Xtal + ((CFO_ave - CFO_TH_XTAL_LOW) >> 2);
+			else if(CFO_ave < (-CFO_TH_XTAL_LOW))
+				Adjust_Xtal =  Adjust_Xtal + ((CFO_TH_XTAL_LOW - CFO_ave) >> 2);
+
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Crystal cap offset = %d\n", Adjust_Xtal));
+		}
+#endif
+
+		//4 1.7 Adjust Crystal Cap.
+		if(pCfoTrack->bAdjust)
+		{
+			if(CFO_ave > CFO_TH_XTAL_LOW)
+				CrystalCap = CrystalCap + Adjust_Xtal;
+			else if(CFO_ave < (-CFO_TH_XTAL_LOW))
+				CrystalCap = CrystalCap - Adjust_Xtal;
+
+			if(CrystalCap > 0x3f)
+				CrystalCap = 0x3f;
+			else if (CrystalCap < 0)
+				CrystalCap = 0;
+
+			odm_SetCrystalCap(pDM_Odm, (u1Byte)CrystalCap);
+		}
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Crystal cap = 0x%x, Default Crystal cap = 0x%x\n", 
+			pCfoTrack->CrystalCap, pCfoTrack->DefXCap));
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+		if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+			return;
+		
+		//3 2. Dynamic ATC switch
+		if(CFO_ave < CFO_TH_ATC && CFO_ave > -CFO_TH_ATC)
+		{
+			odm_SetATCStatus(pDM_Odm, FALSE);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Disable ATC!!\n"));
+		}
+		else
+		{
+			odm_SetATCStatus(pDM_Odm, TRUE);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_CFO_TRACKING, ODM_DBG_LOUD, ("ODM_CfoTracking(): Enable ATC!!\n"));
+		}
+#endif
+	}
+}
+
+VOID
+ODM_ParsingCFO(
+	IN		PVOID			pDM_VOID,
+	IN		PVOID			pPktinfo_VOID,
+	IN		s1Byte* 			pcfotail
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_PACKET_INFO_T		pPktinfo = (PODM_PACKET_INFO_T)pPktinfo_VOID;
+	PCFO_TRACKING			pCfoTrack = (PCFO_TRACKING)PhyDM_Get_Structure( pDM_Odm, PHYDM_CFOTRACK);
+	u1Byte					i;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_CFO_TRACKING))
+		return;
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	if(pPktinfo->bPacketMatchBSSID)
+#else
+	if(pPktinfo->StationID != 0)
+#endif
+	{				
+		//3 Update CFO report for path-A & path-B
+		// Only paht-A and path-B have CFO tail and short CFO
+		for(i = ODM_RF_PATH_A; i <= ODM_RF_PATH_B; i++)   
+		{
+			pCfoTrack->CFO_tail[i] = (int)pcfotail[i];
+	 	}
+
+		//3 Update packet counter
+		if(pCfoTrack->packetCount == 0xffffffff)
+			pCfoTrack->packetCount = 0;
+		else
+	 		pCfoTrack->packetCount++;
+	}
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_CfoTracking.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_CfoTracking.h
new file mode 100644
index 000000000000..77e0a4baa3f1
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_CfoTracking.h
@@ -0,0 +1,68 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef	__PHYDMCFOTRACK_H__
+#define    __PHYDMCFOTRACK_H__
+
+#define CFO_TRACKING_VERSION	"1.0"
+
+#define		CFO_TH_XTAL_HIGH			20			// kHz
+#define		CFO_TH_XTAL_LOW			10			// kHz
+#define		CFO_TH_ATC					80			// kHz
+
+typedef struct _CFO_TRACKING_
+{
+	BOOLEAN			bATCStatus;
+	BOOLEAN			largeCFOHit;
+	BOOLEAN			bAdjust;
+	u1Byte			CrystalCap;
+	u1Byte			DefXCap;
+	int				CFO_tail[2];
+	int				CFO_ave_pre;
+	u4Byte			packetCount;
+	u4Byte			packetCount_pre;
+
+	BOOLEAN			bForceXtalCap;
+	BOOLEAN			bReset;
+}CFO_TRACKING, *PCFO_TRACKING;
+
+VOID
+ODM_CfoTrackingReset(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+ODM_CfoTrackingInit(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+ODM_CfoTracking(
+	IN		PVOID					pDM_VOID
+);
+
+VOID
+ODM_ParsingCFO(
+	IN		PVOID					pDM_VOID,
+	IN		PVOID					pPktinfo_VOID,
+	IN     	s1Byte* 					pcfotail
+);
+
+#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DIG.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DIG.c
new file mode 100644
index 000000000000..4e6304fe50e7
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DIG.c
@@ -0,0 +1,2023 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+
+VOID
+ODM_ChangeDynamicInitGainThresh(
+	IN	PVOID		pDM_VOID,
+	IN	u4Byte		DM_Type,
+	IN	u4Byte		DM_Value
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T			pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	if (DM_Type == DIG_TYPE_THRESH_HIGH)
+	{
+		pDM_DigTable->RssiHighThresh = DM_Value;		
+	}
+	else if (DM_Type == DIG_TYPE_THRESH_LOW)
+	{
+		pDM_DigTable->RssiLowThresh = DM_Value;
+	}
+	else if (DM_Type == DIG_TYPE_ENABLE)
+	{
+		pDM_DigTable->Dig_Enable_Flag	= TRUE;
+	}	
+	else if (DM_Type == DIG_TYPE_DISABLE)
+	{
+		pDM_DigTable->Dig_Enable_Flag = FALSE;
+	}	
+	else if (DM_Type == DIG_TYPE_BACKOFF)
+	{
+		if(DM_Value > 30)
+			DM_Value = 30;
+		pDM_DigTable->BackoffVal = (u1Byte)DM_Value;
+	}
+	else if(DM_Type == DIG_TYPE_RX_GAIN_MIN)
+	{
+		if(DM_Value == 0)
+			DM_Value = 0x1;
+		pDM_DigTable->rx_gain_range_min = (u1Byte)DM_Value;
+	}
+	else if(DM_Type == DIG_TYPE_RX_GAIN_MAX)
+	{
+		if(DM_Value > 0x50)
+			DM_Value = 0x50;
+		pDM_DigTable->rx_gain_range_max = (u1Byte)DM_Value;
+	}
+}	// DM_ChangeDynamicInitGainThresh //
+
+int 
+getIGIForDiff(int value_IGI)
+{
+	#define ONERCCA_LOW_TH		0x30
+	#define ONERCCA_LOW_DIFF	8
+
+	if (value_IGI < ONERCCA_LOW_TH) {
+		if ((ONERCCA_LOW_TH - value_IGI) < ONERCCA_LOW_DIFF)
+			return ONERCCA_LOW_TH;
+		else
+			return value_IGI + ONERCCA_LOW_DIFF;
+	} else {
+		return value_IGI;
+	}
+}
+
+VOID
+odm_FAThresholdCheck(
+	IN		PVOID			pDM_VOID,
+	IN		BOOLEAN			bDFSBand,
+	IN		BOOLEAN			bPerformance,
+	IN		u4Byte			RxTp,
+	IN		u4Byte			TxTp,
+	OUT		u4Byte*			dm_FA_thres
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if(pDM_Odm->bLinked && (bPerformance||bDFSBand))
+	{
+		if(pDM_Odm->SupportICType == ODM_RTL8192D)
+		{
+			// 8192D special case
+			dm_FA_thres[0] = DM_DIG_FA_TH0_92D;
+			dm_FA_thres[1] = DM_DIG_FA_TH1_92D;
+			dm_FA_thres[2] = DM_DIG_FA_TH2_92D;
+		}
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		else if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
+		{
+			// For AP
+			if((RxTp>>2) > TxTp && RxTp < 10000 && RxTp > 500)			// 10Mbps & 0.5Mbps
+			{
+				dm_FA_thres[0] = 0x080;
+				dm_FA_thres[1] = 0x100;
+				dm_FA_thres[2] = 0x200;			
+			}
+			else
+			{
+				dm_FA_thres[0] = 0x100;
+				dm_FA_thres[1] = 0x200;
+				dm_FA_thres[2] = 0x300;	
+			}
+		}
+#else
+		else if(pDM_Odm->SupportICType == ODM_RTL8723A && pDM_Odm->bBtLimitedDig)
+		{
+			// 8723A BT special case
+			dm_FA_thres[0] = DM_DIG_FA_TH0;
+			dm_FA_thres[1] = 0x250;
+			dm_FA_thres[2] = 0x300;
+		}
+#endif
+		else
+		{
+			// For NIC
+			dm_FA_thres[0] = DM_DIG_FA_TH0;
+			dm_FA_thres[1] = DM_DIG_FA_TH1;
+			dm_FA_thres[2] = DM_DIG_FA_TH2;
+		}
+	}
+	else
+	{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		if(bDFSBand)
+		{
+			// For DFS band and no link
+			dm_FA_thres[0] = 250;
+			dm_FA_thres[1] = 1000;
+			dm_FA_thres[2] = 2000;
+		}
+		else
+#endif
+		{
+			dm_FA_thres[0] = 2000;
+			dm_FA_thres[1] = 4000;
+			dm_FA_thres[2] = 5000;
+		}
+	}
+	return;
+}
+
+u1Byte
+odm_ForbiddenIGICheck(
+	IN		PVOID			pDM_VOID,
+	IN		u1Byte			DIG_Dynamic_MIN,
+	IN		u1Byte			CurrentIGI
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+	PFALSE_ALARM_STATISTICS 	pFalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	u1Byte						rx_gain_range_min = pDM_DigTable->rx_gain_range_min;
+
+	if(pFalseAlmCnt->Cnt_all > 10000)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnormally false alarm case. \n"));
+
+		if(pDM_DigTable->LargeFAHit != 3)
+			pDM_DigTable->LargeFAHit++;
+		
+		if(pDM_DigTable->ForbiddenIGI < CurrentIGI)//if(pDM_DigTable->ForbiddenIGI < pDM_DigTable->CurIGValue)
+		{
+			pDM_DigTable->ForbiddenIGI = CurrentIGI;//pDM_DigTable->ForbiddenIGI = pDM_DigTable->CurIGValue;
+			pDM_DigTable->LargeFAHit = 1;
+		}
+
+		if(pDM_DigTable->LargeFAHit >= 3)
+		{
+			if((pDM_DigTable->ForbiddenIGI + 2) > pDM_DigTable->rx_gain_range_max)
+				rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
+			else
+				rx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 2);
+			pDM_DigTable->Recover_cnt = 1800;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnormally false alarm case: Recover_cnt = %d \n", pDM_DigTable->Recover_cnt));
+		}
+	}
+	else
+	{
+		if(pDM_DigTable->Recover_cnt != 0)
+		{
+			pDM_DigTable->Recover_cnt --;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: Recover_cnt = %d \n", pDM_DigTable->Recover_cnt));
+		}
+		else
+		{
+			if(pDM_DigTable->LargeFAHit < 3)
+			{
+				if((pDM_DigTable->ForbiddenIGI - 2) < DIG_Dynamic_MIN) //DM_DIG_MIN)
+				{
+					pDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN; //DM_DIG_MIN;
+					rx_gain_range_min = DIG_Dynamic_MIN; //DM_DIG_MIN;
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: At Lower Bound\n"));
+				}
+				else
+				{
+					pDM_DigTable->ForbiddenIGI -= 2;
+					rx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 2);
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: Approach Lower Bound\n"));
+				}
+			}
+			else
+			{
+				pDM_DigTable->LargeFAHit = 0;
+			}
+		}
+	}
+	
+	return rx_gain_range_min;
+
+}
+
+VOID
+odm_InbandNoiseCalculate (	
+	IN		PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T				pDM_DigTable = &pDM_Odm->DM_DigTable;
+	u1Byte				IGIBackup, TimeCnt = 0, ValidCnt = 0;
+	BOOLEAN				bTimeout = TRUE;
+	s1Byte				sNoise_A, sNoise_B;
+	s4Byte				NoiseRpt_A = 0,NoiseRpt_B = 0;
+	u4Byte				tmp = 0;
+	static	u1Byte		failCnt = 0;
+
+	if(!(pDM_Odm->SupportICType & (ODM_RTL8192E)))
+		return;
+
+	if(pDM_Odm->RFType == ODM_1T1R || *(pDM_Odm->pOnePathCCA) != ODM_CCA_2R)
+		return;
+
+	if(!pDM_DigTable->bNoiseEst)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_InbandNoiseEstimate()========>\n"));
+	
+	//1 Set initial gain.
+	IGIBackup = pDM_DigTable->CurIGValue;
+	pDM_DigTable->IGIOffset_A = 0;
+	pDM_DigTable->IGIOffset_B = 0;
+	ODM_Write_DIG(pDM_Odm, 0x24);
+
+	//1 Update idle time power report	
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TX_ANT_CTRL_11N, BIT25, 0x0);
+
+	delay_ms(2);
+
+	//1 Get noise power level
+	while(1)
+	{
+		//2 Read Noise Floor Report
+		if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+			tmp = ODM_GetBBReg(pDM_Odm, 0x8f8, bMaskLWord);
+
+		sNoise_A = (s1Byte)(tmp & 0xff);
+		sNoise_B = (s1Byte)((tmp & 0xff00)>>8);
+
+		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("sNoise_A = %d, sNoise_B = %d\n",sNoise_A, sNoise_B));
+
+		if((sNoise_A < 20 && sNoise_A >= -70) && (sNoise_B < 20 && sNoise_B >= -70))
+		{
+			ValidCnt++;
+			NoiseRpt_A += sNoise_A;
+			NoiseRpt_B += sNoise_B;
+			//ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("sNoise_A = %d, sNoise_B = %d\n",sNoise_A, sNoise_B));
+		}
+
+		TimeCnt++;
+		bTimeout = (TimeCnt >= 150)?TRUE:FALSE;
+		
+		if(ValidCnt == 20 || bTimeout)
+			break;
+
+		delay_ms(2);
+		
+	}
+
+	//1 Keep idle time power report	
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		ODM_SetBBReg(pDM_Odm, ODM_REG_TX_ANT_CTRL_11N, BIT25, 0x1);
+
+	//1 Recover IGI
+	ODM_Write_DIG(pDM_Odm, IGIBackup);
+	
+	//1 Calculate Noise Floor
+	if(ValidCnt != 0)
+	{
+		NoiseRpt_A  /= (ValidCnt<<1);
+		NoiseRpt_B  /= (ValidCnt<<1);
+	}
+	
+	if(bTimeout)
+	{
+		NoiseRpt_A = 0;
+		NoiseRpt_B = 0;
+
+		failCnt ++;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("Noise estimate fail time = %d\n", failCnt));
+		
+		if(failCnt == 3)
+		{
+			failCnt = 0;
+			pDM_DigTable->bNoiseEst = FALSE;
+		}
+	}
+	else
+	{
+		NoiseRpt_A = -110 + 0x24 + NoiseRpt_A -6;
+		NoiseRpt_B = -110 + 0x24 + NoiseRpt_B -6;
+		pDM_DigTable->bNoiseEst = FALSE;
+		failCnt = 0;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("NoiseRpt_A = %d, NoiseRpt_B = %d\n", NoiseRpt_A, NoiseRpt_B));
+	}
+
+	//1 Calculate IGI Offset
+	if(NoiseRpt_A > NoiseRpt_B)
+	{
+		pDM_DigTable->IGIOffset_A = NoiseRpt_A - NoiseRpt_B;
+		pDM_DigTable->IGIOffset_B = 0;
+	}
+	else
+	{
+		pDM_DigTable->IGIOffset_A = 0;
+		pDM_DigTable->IGIOffset_B = NoiseRpt_B - NoiseRpt_A;
+	}
+
+#endif
+	return;
+}
+
+VOID
+odm_DigForBtHsMode(
+	IN		PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T					pDM_DigTable=&pDM_Odm->DM_DigTable;
+	u1Byte					digForBtHs=0;
+	u1Byte					digUpBound=0x5a;
+	
+	if(pDM_Odm->bBtConnectProcess)
+	{
+		if(pDM_Odm->SupportICType&(ODM_RTL8723A))
+			digForBtHs = 0x28;
+		else
+			digForBtHs = 0x22;
+	}
+	else
+	{
+		//
+		// Decide DIG value by BT HS RSSI.
+		//
+		digForBtHs = pDM_Odm->btHsRssi+4;
+		
+		//DIG Bound
+		if(pDM_Odm->SupportICType&(ODM_RTL8723A))
+			digUpBound = 0x3e;
+		
+		if(digForBtHs > digUpBound)
+			digForBtHs = digUpBound;
+		if(digForBtHs < 0x1c)
+			digForBtHs = 0x1c;
+
+		// update Current IGI
+		pDM_DigTable->BT30_CurIGI = digForBtHs;
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DigForBtHsMode() : set DigValue=0x%x\n", digForBtHs));
+#endif
+}
+
+VOID
+ODM_Write_DIG(
+	IN	PVOID			pDM_VOID,
+	IN	u1Byte			CurrentIGI
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T			pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	if(pDM_DigTable->bStopDIG)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("Stop Writing IGI\n"));
+		return;
+	}
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_TRACE, ("ODM_REG(IGI_A,pDM_Odm)=0x%x, ODM_BIT(IGI,pDM_Odm)=0x%x \n",
+		ODM_REG(IGI_A,pDM_Odm),ODM_BIT(IGI,pDM_Odm)));
+
+	if(pDM_DigTable->CurIGValue != CurrentIGI)
+	{
+		//1 Check initial gain by upper bound		
+		if(!pDM_DigTable->bPSDInProgress)
+		{
+			if(CurrentIGI > pDM_DigTable->rx_gain_range_max)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_TRACE, ("CurrentIGI(0x%02x) is larger than upper bound !!\n",CurrentIGI));
+				CurrentIGI = pDM_DigTable->rx_gain_range_max;
+			}
+
+		}
+
+		//1 Set IGI value
+		if(pDM_Odm->SupportPlatform & (ODM_WIN|ODM_CE))
+		{ 
+			ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+
+			if(pDM_Odm->RFType > ODM_1T1R)
+				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+
+			if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (pDM_Odm->RFType > ODM_2T2R))
+			{
+				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_C,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+				ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_D,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+			}
+		}
+		else if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
+		{
+			switch(*(pDM_Odm->pOnePathCCA))
+			{
+				case ODM_CCA_2R:
+					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+
+					if(pDM_Odm->RFType > ODM_1T1R)
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					
+					if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (pDM_Odm->RFType > ODM_2T2R))
+					{
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_C,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_D,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					}
+					break;
+				case ODM_CCA_1R_A:
+					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					if(pDM_Odm->RFType != ODM_1T1R)
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
+					break;
+				case ODM_CCA_1R_B:
+					ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm), getIGIForDiff(CurrentIGI));
+					if(pDM_Odm->RFType != ODM_1T1R)
+						ODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B,pDM_Odm), ODM_BIT(IGI,pDM_Odm), CurrentIGI);
+					break;
+			}
+		}
+		pDM_DigTable->CurIGValue = CurrentIGI;
+	}
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_TRACE, ("CurrentIGI(0x%02x). \n",CurrentIGI));
+	
+}
+
+VOID
+odm_PauseDIG(
+	IN		PVOID					pDM_VOID,
+	IN		ODM_Pause_DIG_TYPE		PauseType,
+	IN		u1Byte					IGIValue
+)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T				pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG()=========>\n"));
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)	
+	if(*pDM_DigTable->pbP2pLinkInProgress)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): P2P in progress !!\n"));
+		return;
+	}
+#endif
+
+	if(!pDM_DigTable->bPauseDIG && (!(pDM_Odm->SupportAbility & ODM_BB_DIG) || !(pDM_Odm->SupportAbility & ODM_BB_FA_CNT)))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Return: SupportAbility ODM_BB_DIG or ODM_BB_FA_CNT is disabled\n"));
+		return;
+	}
+	
+	switch(PauseType)
+	{
+		//1 Pause DIG
+		case ODM_PAUSE_DIG:
+			//2 Disable DIG
+			ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility & (~ODM_BB_DIG));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Pause DIG !!\n"));
+
+			//2 Backup IGI value
+			if(!pDM_DigTable->bPauseDIG)
+			{
+				pDM_DigTable->IGIBackup = pDM_DigTable->CurIGValue;
+				pDM_DigTable->bPauseDIG = TRUE;
+			}
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Backup IGI  = 0x%x\n", pDM_DigTable->IGIBackup));
+
+			//2 Write new IGI value
+			ODM_Write_DIG(pDM_Odm, IGIValue);
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Write new IGI = 0x%x\n", IGIValue));
+			break;
+
+		//1 Resume DIG
+		case ODM_RESUME_DIG:
+			if(pDM_DigTable->bPauseDIG)
+			{
+				//2 Write backup IGI value
+				ODM_Write_DIG(pDM_Odm, pDM_DigTable->IGIBackup);
+				pDM_DigTable->bPauseDIG = FALSE;
+				pDM_DigTable->bIgnoreDIG = TRUE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Write original IGI = 0x%x\n", pDM_DigTable->IGIBackup));
+
+				//2 Enable DIG
+				ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility | ODM_BB_DIG);	
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Resume DIG !!\n"));
+			}
+			break;
+
+		default:
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_PauseDIG(): Wrong  type !!\n"));
+			break;
+	}
+}
+
+BOOLEAN 
+odm_DigAbort(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T			pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv	priv = pDM_Odm->priv;
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER		pAdapter	= pDM_Odm->Adapter;
+	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+#endif
+
+	//SupportAbility
+	if(!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: SupportAbility ODM_BB_FA_CNT is disabled\n"));
+		return	TRUE;
+	}
+
+	//SupportAbility
+	if(!(pDM_Odm->SupportAbility & ODM_BB_DIG))
+	{	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: SupportAbility ODM_BB_DIG is disabled\n"));
+		return	TRUE;
+	}
+
+	//ScanInProcess
+	if(*(pDM_Odm->pbScanInProcess))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: In Scan Progress \n"));
+	    	return	TRUE;
+	}
+
+	if(pDM_DigTable->bIgnoreDIG)
+	{
+		pDM_DigTable->bIgnoreDIG = FALSE;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: Ignore DIG \n"));
+	    	return	TRUE;
+	}
+
+	//add by Neil Chen to avoid PSD is processing
+	if(pDM_Odm->bDMInitialGainEnable == FALSE)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: PSD is Processing \n"));
+		return	TRUE;
+	}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#if OS_WIN_FROM_WIN7(OS_VERSION)
+	if(IsAPModeExist( pAdapter) && pAdapter->bInHctTest)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: Is AP mode or In HCT Test \n"));
+	    	return	TRUE;
+	}
+	#endif
+
+	if(pDM_Odm->bBtHsOperation)
+	{
+		odm_DigForBtHsMode(pDM_Odm);
+	}	
+
+	if(!(pDM_Odm->SupportICType &(ODM_RTL8723A|ODM_RTL8188E)))
+	{
+		if(pRX_HP_Table->RXHP_flag == 1)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: In RXHP Operation \n"));
+			return	TRUE;	
+		}
+	}
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV	
+	if((pDM_Odm->bLinked) && (pDM_Odm->Adapter->registrypriv.force_igi !=0))
+	{	
+		printk("pDM_Odm->RSSI_Min=%d \n",pDM_Odm->RSSI_Min);
+		ODM_Write_DIG(pDM_Odm,pDM_Odm->Adapter->registrypriv.force_igi);
+		return	TRUE;
+	}
+	#endif
+#else
+	if (!(priv->up_time > 5))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Return: Not In DIG Operation Period \n"));
+		return	TRUE;
+	}
+#endif
+
+	return	FALSE;
+}
+
+VOID
+odm_DIGInit(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	PFALSE_ALARM_STATISTICS 	FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+#endif
+
+	pDM_DigTable->bStopDIG = FALSE;
+	pDM_DigTable->bPauseDIG = FALSE;
+	pDM_DigTable->bIgnoreDIG = FALSE;
+	pDM_DigTable->bPSDInProgress = FALSE;
+	pDM_DigTable->CurIGValue = (u1Byte) ODM_GetBBReg(pDM_Odm, ODM_REG(IGI_A,pDM_Odm), ODM_BIT(IGI,pDM_Odm));
+	pDM_DigTable->RssiLowThresh 	= DM_DIG_THRESH_LOW;
+	pDM_DigTable->RssiHighThresh 	= DM_DIG_THRESH_HIGH;
+	pDM_DigTable->FALowThresh	= DM_FALSEALARM_THRESH_LOW;
+	pDM_DigTable->FAHighThresh	= DM_FALSEALARM_THRESH_HIGH;
+	pDM_DigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;
+	pDM_DigTable->BackoffVal_range_max = DM_DIG_BACKOFF_MAX;
+	pDM_DigTable->BackoffVal_range_min = DM_DIG_BACKOFF_MIN;
+	pDM_DigTable->PreCCK_CCAThres = 0xFF;
+	pDM_DigTable->CurCCK_CCAThres = 0x83;
+	pDM_DigTable->ForbiddenIGI = DM_DIG_MIN_NIC;
+	pDM_DigTable->LargeFAHit = 0;
+	pDM_DigTable->Recover_cnt = 0;
+	pDM_DigTable->bMediaConnect_0 = FALSE;
+	pDM_DigTable->bMediaConnect_1 = FALSE;
+
+	//To Initialize pDM_Odm->bDMInitialGainEnable == FALSE to avoid DIG error
+	pDM_Odm->bDMInitialGainEnable = TRUE;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	pDM_DigTable->DIG_Dynamic_MIN_0 = 0x25;
+	pDM_DigTable->DIG_Dynamic_MIN_1 = 0x25;
+
+	// For AP\ ADSL modified DIG
+	pDM_DigTable->bTpTarget = FALSE;
+	pDM_DigTable->bNoiseEst = TRUE;
+	pDM_DigTable->IGIOffset_A = 0;
+	pDM_DigTable->IGIOffset_B = 0;
+	pDM_DigTable->TpTrainTH_min = 0;
+
+	// For RTL8881A
+	FalseAlmCnt->Cnt_Ofdm_fail_pre = 0;
+
+	//Dyanmic EDCCA
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+	{
+		ODM_SetBBReg(pDM_Odm, 0xC50, 0xFFFF0000, 0xfafd);
+	}
+#else
+	pDM_DigTable->DIG_Dynamic_MIN_0 = DM_DIG_MIN_NIC;
+	pDM_DigTable->DIG_Dynamic_MIN_1 = DM_DIG_MIN_NIC;
+
+	//To Initi BT30 IGI
+	pDM_DigTable->BT30_CurIGI=0x32;
+
+	#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	*pDM_DigTable->pbP2pLinkInProgress= FALSE;
+	#endif
+#endif
+
+	if(pDM_Odm->BoardType & (ODM_BOARD_EXT_PA|ODM_BOARD_EXT_LNA))
+	{
+		pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;
+		pDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC;
+	}
+	else
+	{
+		pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;
+		pDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC;
+	}
+	
+}
+
+
+VOID 
+odm_DIG(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PADAPTER					pAdapter	= pDM_Odm->Adapter;
+	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	prtl8192cd_priv				priv = pDM_Odm->priv;
+	PSTA_INFO_T   				pEntry;
+#endif
+
+	// Common parameters
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+	PFALSE_ALARM_STATISTICS		pFalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	BOOLEAN						FirstConnect,FirstDisConnect;
+	u1Byte						DIG_MaxOfMin, DIG_Dynamic_MIN;
+	u1Byte						dm_dig_max, dm_dig_min;
+	u1Byte						CurrentIGI = pDM_DigTable->CurIGValue;
+	u1Byte						offset;
+	u4Byte						dm_FA_thres[3];
+	u1Byte						Adap_IGI_Upper = 0;
+	u4Byte						TxTp = 0, RxTp = 0;
+	BOOLEAN						bDFSBand = FALSE;
+	BOOLEAN						bPerformance = TRUE, bFirstTpTarget = FALSE, bFirstCoverage = FALSE;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	u4Byte						TpTrainTH_MIN = DM_DIG_TP_Target_TH0;
+	static		u1Byte			TimeCnt = 0;
+	u1Byte						i;
+#endif
+
+	if(odm_DigAbort(pDM_Odm) == TRUE)
+		return;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG()===========================>\n\n"));
+
+	if(pDM_Odm->adaptivity_flag == TRUE)
+		Adap_IGI_Upper = pDM_Odm->Adaptivity_IGI_upper;
+	
+
+	//1 Update status
+#if (RTL8192D_SUPPORT==1) 
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		if(*(pDM_Odm->pMacPhyMode) == ODM_DMSP)
+		{
+			if(*(pDM_Odm->pbMasterOfDMSP))
+			{
+				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
+				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
+			}
+			else
+			{
+				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_1;
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == FALSE);
+				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == TRUE);
+			}
+		}
+		else
+		{
+			if(*(pDM_Odm->pBandType) == ODM_BAND_5G)
+			{
+				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
+				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
+			}
+			else
+			{
+				DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_1;
+				FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == FALSE);
+				FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1 == TRUE);
+			}
+		}
+	}
+	else
+#endif
+	{	
+		DIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;
+		FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
+		FirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == TRUE);
+	}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	//1 Noise Floor Estimate
+	//pDM_DigTable->bNoiseEst = (FirstConnect)?TRUE:pDM_DigTable->bNoiseEst;
+	//odm_InbandNoiseCalculate (pDM_Odm);
+	
+	//1 Mode decision
+	if(pDM_Odm->bLinked)
+	{
+		//2 Calculate total TP
+		for (i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+		{
+			pEntry = pDM_Odm->pODM_StaInfo[i];
+			if(IS_STA_VALID(pEntry))
+			{
+				RxTp += (u4Byte)(pEntry->rx_byte_cnt_LowMAW>>7);
+				TxTp += (u4Byte)(pEntry->tx_byte_cnt_LowMAW>>7);			//Kbps
+			}
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): TX TP = %dkbps, RX TP = %dkbps\n", TxTp, RxTp));
+	}
+
+	switch(pDM_Odm->priv->pshare->rf_ft_var.dig_cov_enable)
+	{
+		case 0:
+		{
+			bPerformance = TRUE;
+			break;
+		}
+		case 1:
+		{
+			bPerformance = FALSE;
+			break;
+		}
+		case 2:
+		{
+			if(pDM_Odm->bLinked)
+			{
+				if(pDM_DigTable->TpTrainTH_min > DM_DIG_TP_Target_TH0)
+					TpTrainTH_MIN = pDM_DigTable->TpTrainTH_min;
+
+				if(pDM_DigTable->TpTrainTH_min > DM_DIG_TP_Target_TH1)
+					TpTrainTH_MIN = DM_DIG_TP_Target_TH1;
+
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): TP training mode lower bound = %dkbps\n", TpTrainTH_MIN));
+
+				//2 Decide DIG mode by total TP
+				if((TxTp + RxTp) > DM_DIG_TP_Target_TH1)			// change to performance mode
+				{
+					bFirstTpTarget = (!pDM_DigTable->bTpTarget)?TRUE:FALSE;
+					pDM_DigTable->bTpTarget = TRUE;
+					bPerformance = TRUE;
+				}
+				else if((TxTp + RxTp) < TpTrainTH_MIN)	// change to coverage mode
+				{
+					bFirstCoverage = (pDM_DigTable->bTpTarget)?TRUE:FALSE;
+					
+					if(TimeCnt < DM_DIG_TP_Training_Period)
+					{
+						pDM_DigTable->bTpTarget = FALSE;
+						bPerformance = FALSE;
+						TimeCnt++;
+					}
+					else
+					{
+						pDM_DigTable->bTpTarget = TRUE;
+						bPerformance = TRUE;
+						bFirstTpTarget = TRUE;
+						TimeCnt = 0;
+					}
+				}
+				else										// remain previous mode
+				{
+					bPerformance = pDM_DigTable->bTpTarget;
+
+					if(!bPerformance)
+					{
+						if(TimeCnt < DM_DIG_TP_Training_Period)
+							TimeCnt++;
+						else
+						{
+							pDM_DigTable->bTpTarget = TRUE;
+							bPerformance = TRUE;
+							bFirstTpTarget = TRUE;
+							TimeCnt = 0;
+						}
+					}
+				}
+
+				if(!bPerformance)
+					pDM_DigTable->TpTrainTH_min = RxTp + TxTp;
+
+			}
+			else
+			{
+				bPerformance = FALSE;
+				pDM_DigTable->TpTrainTH_min = 0;
+			}
+			break;
+		}
+		default:
+			bPerformance = TRUE;
+	}
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("====== DIG mode = %d  ======\n", pDM_Odm->priv->pshare->rf_ft_var.dig_cov_enable));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("====== bPerformance = %d ======\n", bPerformance));
+#endif
+
+	//1 Boundary Decision
+#if (RTL8192C_SUPPORT==1) 
+	if((pDM_Odm->SupportICType & ODM_RTL8192C) && (pDM_Odm->BoardType & (ODM_BOARD_EXT_LNA | ODM_BOARD_EXT_PA)))
+	{
+		//2 High power case
+		if(pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))
+		{
+			dm_dig_max = DM_DIG_MAX_AP_HP;
+			dm_dig_min = DM_DIG_MIN_AP_HP;
+		}
+		else
+		{
+			dm_dig_max = DM_DIG_MAX_NIC_HP;
+			dm_dig_min = DM_DIG_MIN_NIC_HP;
+		}
+		DIG_MaxOfMin = DM_DIG_MAX_AP_HP;
+	}
+	else
+#endif
+	{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		//2 For AP\ADSL
+		if(!bPerformance)
+		{
+			dm_dig_max = DM_DIG_MAX_AP_COVERAGR;
+			dm_dig_min = DM_DIG_MIN_AP_COVERAGE;
+			DIG_MaxOfMin = DM_DIG_MAX_OF_MIN_COVERAGE;
+		}
+		else
+		{
+			dm_dig_max = DM_DIG_MAX_AP;
+			dm_dig_min = DM_DIG_MIN_AP;
+			DIG_MaxOfMin = DM_DIG_MAX_OF_MIN;
+		}
+
+		//4 DFS band
+		if (((*pDM_Odm->pChannel>= 52) &&(*pDM_Odm->pChannel <= 64)) ||
+			((*pDM_Odm->pChannel >= 100) &&	(*pDM_Odm->pChannel <= 140)))
+		{
+			bDFSBand = TRUE;
+			dm_dig_min = DM_DIG_MIN_AP_DFS;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): ====== In DFS band ======\n"));
+		}
+		
+		//4 TX2path
+		if (priv->pmib->dot11RFEntry.tx2path && !bDFSBand && (*(pDM_Odm->pWirelessMode) == ODM_WM_B))
+				dm_dig_max = 0x2A;
+
+#if RTL8192E_SUPPORT
+#ifdef HIGH_POWER_EXT_LNA
+		if ((pDM_Odm->SupportICType & (ODM_RTL8192E)) && (pDM_Odm->ExtLNA))
+			dm_dig_max = 0x42;						
+#endif
+#endif
+
+#else
+		//2 For WIN\CE
+		if(pDM_Odm->SupportICType >= ODM_RTL8188E)
+			dm_dig_max = 0x5A;
+		else
+			dm_dig_max = DM_DIG_MAX_NIC;
+		
+		if(pDM_Odm->SupportICType != ODM_RTL8821)
+			dm_dig_min = DM_DIG_MIN_NIC;
+		else
+			dm_dig_min = 0x1C;
+
+		DIG_MaxOfMin = DM_DIG_MAX_AP;
+#endif	
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Absolutly upper bound = 0x%x, lower bound = 0x%x\n",dm_dig_max, dm_dig_min));
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	// for P2P case
+	if(0 < *pDM_Odm->pu1ForcedIgiLb)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): P2P case: Force IGI lb to: %u !!!!!!\n", *pDM_Odm->pu1ForcedIgiLb));
+		dm_dig_min = *pDM_Odm->pu1ForcedIgiLb;
+		dm_dig_max = (dm_dig_min <= dm_dig_max) ? (dm_dig_max) : (dm_dig_min + 1);
+	}
+#endif
+
+	//1 Adjust boundary by RSSI
+	if(pDM_Odm->bLinked && bPerformance)
+	{
+		//2 Modify DIG upper bound
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		offset = 15;
+#else
+		//4 Modify DIG upper bound for 92E, 8723A\B, 8821 & 8812 BT
+		if((pDM_Odm->SupportICType & (ODM_RTL8192E|ODM_RTL8723B|ODM_RTL8812|ODM_RTL8821|ODM_RTL8723A)) && (pDM_Odm->bBtLimitedDig==1))
+		{
+			offset = 10;
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Coex. case: Force upper bound to RSSI + %d !!!!!!\n", offset));		
+		}
+		else
+			offset = 15;
+#endif
+
+		if((pDM_Odm->RSSI_Min + offset) > dm_dig_max )
+			pDM_DigTable->rx_gain_range_max = dm_dig_max;
+		else if((pDM_Odm->RSSI_Min + offset) < dm_dig_min )
+			pDM_DigTable->rx_gain_range_max = dm_dig_min;
+		else
+			pDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + offset;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+		//2 Modify DIG lower bound
+		//if(pDM_Odm->bOneEntryOnly)
+		{
+			if(pDM_Odm->RSSI_Min < dm_dig_min)
+				DIG_Dynamic_MIN = dm_dig_min;
+			else if (pDM_Odm->RSSI_Min > DIG_MaxOfMin)
+				DIG_Dynamic_MIN = DIG_MaxOfMin;
+			else
+				DIG_Dynamic_MIN = pDM_Odm->RSSI_Min;
+		}
+#else
+		{
+			//4 For AP
+#ifdef __ECOS
+			HAL_REORDER_BARRIER();
+#else
+			rmb();
+#endif
+			if (bDFSBand)
+			{
+				DIG_Dynamic_MIN = dm_dig_min;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DFS band: Force lower bound to 0x%x after link !!!!!!\n", dm_dig_min));
+			}
+			else 
+			{
+				if(pDM_Odm->RSSI_Min < dm_dig_min)
+					DIG_Dynamic_MIN = dm_dig_min;
+				else if (pDM_Odm->RSSI_Min > DIG_MaxOfMin)
+					DIG_Dynamic_MIN = DIG_MaxOfMin;
+				else
+					DIG_Dynamic_MIN = pDM_Odm->RSSI_Min;
+			}
+		}
+#endif
+	}
+	else
+	{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		if(bPerformance && bDFSBand)
+		{
+			pDM_DigTable->rx_gain_range_max = 0x28;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DFS band: Force upper bound to 0x%x before link !!!!!!\n", pDM_DigTable->rx_gain_range_max));
+		}
+		else
+#endif
+		{
+			pDM_DigTable->rx_gain_range_max = DM_DIG_MAX_OF_MIN;
+		}
+		DIG_Dynamic_MIN = dm_dig_min;
+	}
+	
+	//1 Force Lower Bound for AntDiv
+	if(pDM_Odm->bLinked && !pDM_Odm->bOneEntryOnly)
+	{
+		if((pDM_Odm->SupportICType & ODM_ANTDIV_SUPPORT) && (pDM_Odm->SupportAbility & ODM_BB_ANT_DIV))
+		{
+			if(pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV || pDM_Odm->AntDivType == CG_TRX_SMART_ANTDIV ||pDM_Odm->AntDivType == S0S1_SW_ANTDIV)
+			{
+				if(pDM_DigTable->AntDiv_RSSI_max > DIG_MaxOfMin)
+					DIG_Dynamic_MIN = DIG_MaxOfMin;
+				else
+					DIG_Dynamic_MIN = (u1Byte) pDM_DigTable->AntDiv_RSSI_max;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_DIG(): Antenna diversity case: Force lower bound to 0x%x !!!!!!\n", DIG_Dynamic_MIN));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("odm_DIG(): Antenna diversity case: RSSI_max = 0x%x !!!!!!\n", pDM_DigTable->AntDiv_RSSI_max));
+			}
+		}
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Adjust boundary by RSSI Upper bound = 0x%x, Lower bound = 0x%x\n",
+		pDM_DigTable->rx_gain_range_max, DIG_Dynamic_MIN));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Link status: bLinked = %d, RSSI = %d, bFirstConnect = %d, bFirsrDisConnect = %d\n\n",
+		pDM_Odm->bLinked, pDM_Odm->RSSI_Min, FirstConnect, FirstDisConnect));
+
+	//1 Modify DIG lower bound, deal with abnormal case
+	//2 Abnormal false alarm case
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	if(bDFSBand)
+	{
+		pDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;
+	}
+	else
+#endif
+	{
+		if(!pDM_Odm->bLinked)
+		{
+			pDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;
+
+			if(FirstDisConnect)
+			pDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN;
+		}
+		else
+			pDM_DigTable->rx_gain_range_min = odm_ForbiddenIGICheck(pDM_Odm, DIG_Dynamic_MIN, CurrentIGI);
+	}
+
+	//2 Abnormal # beacon case
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	if(pDM_Odm->bLinked && !FirstConnect)
+	{
+		if((pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 5) && (pDM_Odm->bsta_state))
+		{
+			pDM_DigTable->rx_gain_range_min = dm_dig_min;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnrormal #beacon (%d) case in STA mode: Force lower bound to 0x%x !!!!!!\n\n",
+				pDM_Odm->PhyDbgInfo.NumQryBeaconPkt, pDM_DigTable->rx_gain_range_min));
+		}
+	}
+#endif
+
+	//2 Abnormal lower bound case
+	if(pDM_DigTable->rx_gain_range_min > pDM_DigTable->rx_gain_range_max)
+	{
+		pDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnrormal lower bound case: Force lower bound to 0x%x !!!!!!\n\n",pDM_DigTable->rx_gain_range_min));
+	}
+
+	
+	//1 False alarm threshold decision
+	odm_FAThresholdCheck(pDM_Odm, bDFSBand, bPerformance, RxTp, TxTp, dm_FA_thres);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): False alarm threshold = %d, %d, %d \n\n", dm_FA_thres[0], dm_FA_thres[1], dm_FA_thres[2]));
+
+	//1 Adjust initial gain by false alarm
+	if(pDM_Odm->bLinked && bPerformance)
+	{
+		//2 After link
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Adjust IGI after link\n"));
+
+		if(bFirstTpTarget || (FirstConnect && bPerformance))
+		{	
+			pDM_DigTable->LargeFAHit = 0;
+			
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+			if(bDFSBand)
+			{
+				if(pDM_Odm->RSSI_Min > 0x28)
+					CurrentIGI = 0x28;
+				else
+					CurrentIGI = pDM_Odm->RSSI_Min;
+				ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DFS band: One-shot to 0x28 upmost!!!!!!\n"));
+			}
+			else
+#endif
+			{
+				if(pDM_Odm->RSSI_Min < DIG_MaxOfMin)
+				{
+					if(CurrentIGI < pDM_Odm->RSSI_Min)
+						CurrentIGI = pDM_Odm->RSSI_Min;
+				}
+				else
+				{
+					if(CurrentIGI < DIG_MaxOfMin)
+						CurrentIGI = DIG_MaxOfMin;
+				}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+#if (RTL8812A_SUPPORT==1) 
+				if(pDM_Odm->SupportICType == ODM_RTL8812)
+					ODM_ConfigBBWithHeaderFile(pDM_Odm, CONFIG_BB_AGC_TAB_DIFF);
+#endif
+#endif
+			}
+
+			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): First connect case: IGI does on-shot to 0x%x\n", CurrentIGI));
+
+		}
+		else
+		{
+			if(pFalseAlmCnt->Cnt_all > dm_FA_thres[2])
+				CurrentIGI = CurrentIGI + 4;
+			else if (pFalseAlmCnt->Cnt_all > dm_FA_thres[1])
+				CurrentIGI = CurrentIGI + 2;
+			else if(pFalseAlmCnt->Cnt_all < dm_FA_thres[0])
+				CurrentIGI = CurrentIGI - 2;
+
+			//4 Abnormal # beacon case
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+			if((pDM_Odm->PhyDbgInfo.NumQryBeaconPkt < 5) && (pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH1) && (pDM_Odm->bsta_state))
+			{						
+				CurrentIGI = pDM_DigTable->rx_gain_range_min;
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Abnormal #beacon (%d) case: IGI does one-shot to 0x%x\n", 
+					pDM_Odm->PhyDbgInfo.NumQryBeaconPkt, CurrentIGI));
+			}
+#endif
+		}
+	}	
+	else
+	{
+		//2 Before link
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Adjust IGI before link\n"));
+		
+		if(FirstDisConnect || bFirstCoverage)
+		{
+			CurrentIGI = dm_dig_min;
+			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): First disconnect case: IGI does on-shot to lower bound\n"));
+		}
+		else
+		{
+			if(pFalseAlmCnt->Cnt_all > dm_FA_thres[2])
+				CurrentIGI = CurrentIGI + 4;
+			else if (pFalseAlmCnt->Cnt_all > dm_FA_thres[1])
+				CurrentIGI = CurrentIGI + 2;
+			else if(pFalseAlmCnt->Cnt_all < dm_FA_thres[0])
+				CurrentIGI = CurrentIGI - 2;
+		}
+	}
+
+	//1 Check initial gain by upper/lower bound
+	if(CurrentIGI < pDM_DigTable->rx_gain_range_min)
+		CurrentIGI = pDM_DigTable->rx_gain_range_min;
+	
+	if(CurrentIGI > pDM_DigTable->rx_gain_range_max)
+		CurrentIGI = pDM_DigTable->rx_gain_range_max;
+
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue=0x%x, TotalFA = %d\n\n", CurrentIGI, pFalseAlmCnt->Cnt_all));
+
+	//1 Force upper bound and lower bound for adaptivity
+	if(pDM_Odm->SupportAbility & ODM_BB_ADAPTIVITY && pDM_Odm->adaptivity_flag == TRUE)
+	{
+		if(CurrentIGI > Adap_IGI_Upper)
+			CurrentIGI = Adap_IGI_Upper;
+		
+		if(pDM_Odm->IGI_LowerBound != 0)
+		{
+			if(CurrentIGI < pDM_Odm->IGI_LowerBound)
+				CurrentIGI = pDM_Odm->IGI_LowerBound;
+		}
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Adaptivity case: Force upper bound to 0x%x !!!!!!\n", Adap_IGI_Upper));
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Adaptivity case: Force lower bound to 0x%x !!!!!!\n\n", pDM_Odm->IGI_LowerBound));
+	}
+	
+
+	//1 High power RSSI threshold
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	if((pDM_Odm->SupportICType == ODM_RTL8723A)&& (pHalData->UndecoratedSmoothedPWDB > DM_DIG_HIGH_PWR_THRESHOLD))
+	{
+		// High power IGI lower bound
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): UndecoratedSmoothedPWDB(%#x)\n", pHalData->UndecoratedSmoothedPWDB));
+		if(CurrentIGI < DM_DIG_HIGH_PWR_IGI_LOWER_BOUND)
+		{
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue(%#x)\n", pDM_DigTable->CurIGValue));
+			//pDM_DigTable->CurIGValue = DM_DIG_HIGH_PWR_IGI_LOWER_BOUND;
+			CurrentIGI=DM_DIG_HIGH_PWR_IGI_LOWER_BOUND;
+		}
+	}
+	if((pDM_Odm->SupportICType & ODM_RTL8723A) && IS_WIRELESS_MODE_G(pAdapter))
+	{
+		if(pHalData->UndecoratedSmoothedPWDB > 0x28)
+		{
+			if(CurrentIGI < DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND)
+			{
+			 	//pDM_DigTable->CurIGValue = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
+				CurrentIGI = DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND;
+			}	
+		} 
+	}
+#endif
+
+	//1 Update status
+#if (RTL8192D_SUPPORT==1) 
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		//sherry  delete DualMacSmartConncurrent 20110517
+		if(*(pDM_Odm->pMacPhyMode) == ODM_DMSP)
+		{
+			ODM_Write_DIG_DMSP(pDM_Odm, CurrentIGI);//ODM_Write_DIG_DMSP(pDM_Odm, pDM_DigTable->CurIGValue);
+			if(*(pDM_Odm->pbMasterOfDMSP))
+			{
+				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+			}
+			else
+			{
+				pDM_DigTable->bMediaConnect_1 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_1 = DIG_Dynamic_MIN;
+			}
+		}
+		else
+		{
+			ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
+			if(*(pDM_Odm->pBandType) == ODM_BAND_5G)
+			{
+				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+			}
+			else
+			{
+				pDM_DigTable->bMediaConnect_1 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_1 = DIG_Dynamic_MIN;
+			}
+		}
+	}
+	else
+#endif
+	{
+#if ((DM_ODM_SUPPORT_TYPE & ODM_WIN) || ((DM_ODM_SUPPORT_TYPE & ODM_CE) && (ODM_CONFIG_BT_COEXIST == 1)))
+		if(pDM_Odm->bBtHsOperation)
+		{
+			if(pDM_Odm->bLinked)
+			{
+				if(pDM_DigTable->BT30_CurIGI > (CurrentIGI))
+					ODM_Write_DIG(pDM_Odm, CurrentIGI);
+				else
+					ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);
+					
+				pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
+				pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+			}
+			else
+			{
+				if(pDM_Odm->bLinkInProcess)
+					ODM_Write_DIG(pDM_Odm, 0x1c);
+				else if(pDM_Odm->bBtConnectProcess)
+					ODM_Write_DIG(pDM_Odm, 0x28);
+				else
+					ODM_Write_DIG(pDM_Odm, pDM_DigTable->BT30_CurIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);	
+			}
+		}
+		else		// BT is not using
+#endif
+		{
+			ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
+			pDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;
+			pDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+		}
+	}
+}
+
+VOID
+odm_DIGbyRSSI_LPS(
+	IN		PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PFALSE_ALARM_STATISTICS		pFalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_CE)
+#if 0		//and 2.3.5 coding rule
+	struct mlme_priv	*pmlmepriv = &(pAdapter->mlmepriv);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+#endif
+#endif
+
+	u1Byte	RSSI_Lower=DM_DIG_MIN_NIC;   //0x1E or 0x1C
+	u1Byte	CurrentIGI=pDM_Odm->RSSI_Min;
+
+	if(odm_DigAbort(pDM_Odm) == TRUE)
+		return;
+
+	CurrentIGI=CurrentIGI+RSSI_OFFSET_DIG;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIGbyRSSI_LPS()==>\n"));
+
+	// Using FW PS mode to make IGI
+	//Adjust by  FA in LPS MODE
+	if(pFalseAlmCnt->Cnt_all> DM_DIG_FA_TH2_LPS)
+		CurrentIGI = CurrentIGI+4;
+	else if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1_LPS)
+		CurrentIGI = CurrentIGI+2;
+	else if(pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0_LPS)
+		CurrentIGI = CurrentIGI-2;	
+
+
+	//Lower bound checking
+
+	//RSSI Lower bound check
+	if((pDM_Odm->RSSI_Min-10) > DM_DIG_MIN_NIC)
+		RSSI_Lower =(pDM_Odm->RSSI_Min-10);
+	else
+		RSSI_Lower =DM_DIG_MIN_NIC;
+
+	//Upper and Lower Bound checking
+	 if(CurrentIGI > DM_DIG_MAX_NIC)
+	 	CurrentIGI=DM_DIG_MAX_NIC;
+	 else if(CurrentIGI < RSSI_Lower)
+		CurrentIGI =RSSI_Lower;
+
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIGbyRSSI_LPS(): pFalseAlmCnt->Cnt_all = %d\n",pFalseAlmCnt->Cnt_all));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIGbyRSSI_LPS(): pDM_Odm->RSSI_Min = %d\n",pDM_Odm->RSSI_Min));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIGbyRSSI_LPS(): CurrentIGI = 0x%x\n",CurrentIGI));
+
+	ODM_Write_DIG(pDM_Odm, CurrentIGI);//ODM_Write_DIG(pDM_Odm, pDM_DigTable->CurIGValue);
+#endif
+}
+
+//3============================================================
+//3 FASLE ALARM CHECK
+//3============================================================
+
+VOID 
+odm_FalseAlarmCounterStatistics(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PFALSE_ALARM_STATISTICS 	FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	u4Byte 						ret_value;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+//Mark there, and check this in odm_DMWatchDog
+#if 0 //(DM_ODM_SUPPORT_TYPE == ODM_AP)
+	prtl8192cd_priv priv		= pDM_Odm->priv;
+	if( (priv->auto_channel != 0) && (priv->auto_channel != 2) )
+		return;
+#endif
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if((pDM_Odm->SupportICType == ODM_RTL8192D) &&
+		(*(pDM_Odm->pMacPhyMode)==ODM_DMSP)&&    ////modify by Guo.Mingzhi 2011-12-29
+		(!(*(pDM_Odm->pbMasterOfDMSP))))
+	{
+		odm_FalseAlarmCounterStatistics_ForSlaveOfDMSP(pDM_Odm);
+		return;
+	}
+#endif		
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT))
+		return;
+
+#if (ODM_IC_11N_SERIES_SUPPORT == 1) 
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+	{
+
+		//hold ofdm counter
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 1); //hold page C counter
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 1); //hold page D counter
+	
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE1_11N, bMaskDWord);
+		FalseAlmCnt->Cnt_Fast_Fsync = (ret_value&0xffff);
+		FalseAlmCnt->Cnt_SB_Search_fail = ((ret_value&0xffff0000)>>16);		
+
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE2_11N, bMaskDWord);
+		FalseAlmCnt->Cnt_OFDM_CCA = (ret_value&0xffff); 
+		FalseAlmCnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);	
+
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE3_11N, bMaskDWord);
+		FalseAlmCnt->Cnt_Rate_Illegal = (ret_value&0xffff);
+		FalseAlmCnt->Cnt_Crc8_fail = ((ret_value&0xffff0000)>>16);
+
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE4_11N, bMaskDWord);
+		FalseAlmCnt->Cnt_Mcs_fail = (ret_value&0xffff);
+
+		FalseAlmCnt->Cnt_Ofdm_fail = 	FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal +
+								FalseAlmCnt->Cnt_Crc8_fail + FalseAlmCnt->Cnt_Mcs_fail +
+								FalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail;
+
+#if (RTL8188E_SUPPORT==1)
+		if(pDM_Odm->SupportICType == ODM_RTL8188E)
+		{
+			ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_SC_CNT_11N, bMaskDWord);
+			FalseAlmCnt->Cnt_BW_LSC = (ret_value&0xffff);
+			FalseAlmCnt->Cnt_BW_USC = ((ret_value&0xffff0000)>>16);
+		}
+#endif
+
+#if (RTL8192D_SUPPORT==1) 
+		if(pDM_Odm->SupportICType == ODM_RTL8192D)
+		{
+			odm_GetCCKFalseAlarm_92D(pDM_Odm);
+		}
+		else
+#endif
+		{
+			//hold cck counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT12, 1); 
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT14, 1); 
+		
+			ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_LSB_11N, bMaskByte0);
+			FalseAlmCnt->Cnt_Cck_fail = ret_value;
+
+			ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_MSB_11N, bMaskByte3);
+			FalseAlmCnt->Cnt_Cck_fail +=  (ret_value& 0xff)<<8;
+
+			ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_CCA_CNT_11N, bMaskDWord);
+			FalseAlmCnt->Cnt_CCK_CCA = ((ret_value&0xFF)<<8) |((ret_value&0xFF00)>>8);
+		}
+	
+		FalseAlmCnt->Cnt_all = (	FalseAlmCnt->Cnt_Fast_Fsync + 
+							FalseAlmCnt->Cnt_SB_Search_fail +
+							FalseAlmCnt->Cnt_Parity_Fail +
+							FalseAlmCnt->Cnt_Rate_Illegal +
+							FalseAlmCnt->Cnt_Crc8_fail +
+							FalseAlmCnt->Cnt_Mcs_fail +
+							FalseAlmCnt->Cnt_Cck_fail);	
+
+		FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA + FalseAlmCnt->Cnt_CCK_CCA;
+
+#if (RTL8192C_SUPPORT==1)
+		if(pDM_Odm->SupportICType == ODM_RTL8192C)
+			odm_ResetFACounter_92C(pDM_Odm);
+#endif
+
+#if (RTL8192D_SUPPORT==1)
+		if(pDM_Odm->SupportICType == ODM_RTL8192D)
+			odm_ResetFACounter_92D(pDM_Odm);
+#endif
+
+		if(pDM_Odm->SupportICType >=ODM_RTL8723A)
+		{
+			//reset false alarm counter registers
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT31, 1);
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT31, 0);
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT27, 1);
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT27, 0);
+
+			//update ofdm counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 0); //update page C counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 0); //update page D counter
+
+			//reset CCK CCA counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT13|BIT12, 0); 
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT13|BIT12, 2); 
+			//reset CCK FA counter
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT15|BIT14, 0); 
+			ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT15|BIT14, 2); 
+		}
+		
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Enter odm_FalseAlarmCounterStatistics\n"));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Fast_Fsync=%d, Cnt_SB_Search_fail=%d\n",
+			FalseAlmCnt->Cnt_Fast_Fsync, FalseAlmCnt->Cnt_SB_Search_fail));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Parity_Fail=%d, Cnt_Rate_Illegal=%d\n",
+			FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Crc8_fail=%d, Cnt_Mcs_fail=%d\n",
+		FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail));
+	}
+#endif
+
+#if (ODM_IC_11AC_SERIES_SUPPORT == 1) 
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
+	{
+		u4Byte CCKenable;
+		
+		//read OFDM FA counter
+		FalseAlmCnt->Cnt_Ofdm_fail = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_11AC, bMaskLWord);
+		FalseAlmCnt->Cnt_Cck_fail = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_11AC, bMaskLWord);
+
+		//read CCK/OFDM CCA counter
+		ret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_CCA_CNT_11AC, bMaskDWord);
+		FalseAlmCnt->Cnt_OFDM_CCA = (ret_value & 0xffff0000) >> 16;
+		FalseAlmCnt->Cnt_CCK_CCA = ret_value & 0xffff;
+
+#if (RTL8881A_SUPPORT==1) 
+		// For 8881A
+		if(pDM_Odm->SupportICType == ODM_RTL8881A)
+		{
+			u4Byte Cnt_Ofdm_fail_temp = 0;
+		
+			if(FalseAlmCnt->Cnt_Ofdm_fail >= FalseAlmCnt->Cnt_Ofdm_fail_pre)
+			{
+				Cnt_Ofdm_fail_temp = FalseAlmCnt->Cnt_Ofdm_fail_pre;
+				FalseAlmCnt->Cnt_Ofdm_fail_pre = FalseAlmCnt->Cnt_Ofdm_fail;
+				FalseAlmCnt->Cnt_Ofdm_fail = FalseAlmCnt->Cnt_Ofdm_fail - Cnt_Ofdm_fail_temp;
+			}
+			else
+				FalseAlmCnt->Cnt_Ofdm_fail_pre = FalseAlmCnt->Cnt_Ofdm_fail;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Ofdm_fail=%d\n",	FalseAlmCnt->Cnt_Ofdm_fail_pre));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Ofdm_fail_pre=%d\n",	Cnt_Ofdm_fail_temp));
+			
+			// Reset FA counter by enable/disable OFDM
+			if(FalseAlmCnt->Cnt_Ofdm_fail_pre >= 0x7fff)
+			{
+				// reset OFDM
+				ODM_SetBBReg(pDM_Odm, ODM_REG_BB_RX_PATH_11AC, BIT29,0);
+				ODM_SetBBReg(pDM_Odm, ODM_REG_BB_RX_PATH_11AC, BIT29,1);
+				FalseAlmCnt->Cnt_Ofdm_fail_pre = 0;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Reset false alarm counter\n"));
+			}
+		}
+#endif
+
+		// reset OFDM FA coutner
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RST_11AC, BIT17, 1);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RST_11AC, BIT17, 0);
+
+		// reset CCK FA counter
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11AC, BIT15, 0);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11AC, BIT15, 1);
+
+		// reset CCA counter
+		ODM_SetBBReg(pDM_Odm, ODM_REG_RST_RPT_11AC, BIT0, 1);
+		ODM_SetBBReg(pDM_Odm, ODM_REG_RST_RPT_11AC, BIT0, 0);
+
+		CCKenable =  ODM_GetBBReg(pDM_Odm, ODM_REG_BB_RX_PATH_11AC, BIT28);
+		if(CCKenable)//if(*pDM_Odm->pBandType == ODM_BAND_2_4G)
+		{
+			FalseAlmCnt->Cnt_all = FalseAlmCnt->Cnt_Ofdm_fail + FalseAlmCnt->Cnt_Cck_fail;
+			FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_CCK_CCA + FalseAlmCnt->Cnt_OFDM_CCA;
+		}
+		else
+		{
+			FalseAlmCnt->Cnt_all = FalseAlmCnt->Cnt_Ofdm_fail;
+			FalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA;
+		}
+
+	}
+#endif
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_OFDM_CCA=%d\n",	FalseAlmCnt->Cnt_OFDM_CCA));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_CCK_CCA=%d\n",	FalseAlmCnt->Cnt_CCK_CCA));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_CCA_all=%d\n",	FalseAlmCnt->Cnt_CCA_all));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Ofdm_fail=%d\n",	FalseAlmCnt->Cnt_Ofdm_fail));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Cck_fail=%d\n",	FalseAlmCnt->Cnt_Cck_fail));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Ofdm_fail=%d\n",	FalseAlmCnt->Cnt_Ofdm_fail));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Total False Alarm=%d\n",	FalseAlmCnt->Cnt_all));
+}
+
+//3============================================================
+//3 CCK Packet Detect Threshold
+//3============================================================
+
+VOID
+odm_PauseCCKPacketDetection(
+	IN		PVOID					pDM_VOID,
+	IN		ODM_Pause_CCKPD_TYPE	PauseType,
+	IN		u1Byte					CCKPDThreshold
+)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T				pDM_DigTable = &pDM_Odm->DM_DigTable;
+	static	BOOLEAN		bPaused = FALSE;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_PauseCCKPacketDetection()=========>\n"));
+
+#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)	
+	if(*pDM_DigTable->pbP2pLinkInProgress)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("P2P in progress !!\n"));
+		return;
+	}
+#endif
+
+	if(!bPaused && (!(pDM_Odm->SupportAbility & ODM_BB_CCK_PD) || !(pDM_Odm->SupportAbility & ODM_BB_FA_CNT)))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Return: SupportAbility ODM_BB_CCK_PD or ODM_BB_FA_CNT is disabled\n"));
+		return;
+	}
+
+	switch(PauseType)
+	{
+		//1 Pause CCK Packet Detection Threshold
+		case ODM_PAUSE_CCKPD:
+			//2 Disable DIG
+			ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility & (~ODM_BB_CCK_PD));
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Pause CCK packet detection threshold !!\n"));
+
+			//2 Backup CCK Packet Detection Threshold value
+			if(!bPaused)
+			{
+				pDM_DigTable->CCKPDBackup = pDM_DigTable->CurCCK_CCAThres;
+				bPaused = TRUE;
+			}
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Backup CCK packet detection tgreshold  = %d\n", pDM_DigTable->CCKPDBackup));
+
+			//2 Write new CCK Packet Detection Threshold value
+			ODM_Write_CCK_CCA_Thres(pDM_Odm, CCKPDThreshold);
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Write new CCK packet detection tgreshold = %d\n", CCKPDThreshold));
+			break;
+			
+		//1 Resume CCK Packet Detection Threshold
+		case ODM_RESUME_CCKPD:
+			if(bPaused)
+			{
+				//2 Write backup CCK Packet Detection Threshold value
+				ODM_Write_CCK_CCA_Thres(pDM_Odm, pDM_DigTable->CCKPDBackup);
+				bPaused = FALSE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Write original CCK packet detection tgreshold = %d\n", pDM_DigTable->CCKPDBackup));
+
+				//2 Enable CCK Packet Detection Threshold
+				ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_ABILITY, pDM_Odm->SupportAbility | ODM_BB_CCK_PD);		
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Resume CCK packet detection threshold  !!\n"));
+			}
+			break;
+			
+		default:
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("Wrong  type !!\n"));
+			break;
+	}	
+	return;
+}
+
+
+VOID 
+odm_CCKPacketDetectionThresh(
+	IN		PVOID		pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PFALSE_ALARM_STATISTICS 	FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	u1Byte						CurCCK_CCAThres;
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+//modify by Guo.Mingzhi 2011-12-29
+	if (pDM_Odm->bDualMacSmartConcurrent == TRUE)
+//	if (pDM_Odm->bDualMacSmartConcurrent == FALSE)
+		return;
+	if(pDM_Odm->bBtHsOperation)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_CCKPacketDetectionThresh() write 0xcd for BT HS mode!!\n"));
+		ODM_Write_CCK_CCA_Thres(pDM_Odm, 0xcd);
+		return;
+	}
+#endif
+
+	if((!(pDM_Odm->SupportAbility & ODM_BB_CCK_PD)) ||(!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT)))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_CCKPacketDetectionThresh()  return==========\n"));
+		return;
+	}
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	if(pDM_Odm->ExtLNA)
+		return;
+#endif
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_CCKPacketDetectionThresh()  ==========>\n"));
+
+	if(pDM_Odm->bLinked)
+	{
+		if(pDM_Odm->RSSI_Min > 25)
+			CurCCK_CCAThres = 0xcd;
+		else if((pDM_Odm->RSSI_Min <= 25) && (pDM_Odm->RSSI_Min > 10))
+			CurCCK_CCAThres = 0x83;
+		else
+		{
+			if(FalseAlmCnt->Cnt_Cck_fail > 1000)
+				CurCCK_CCAThres = 0x83;
+			else
+				CurCCK_CCAThres = 0x40;
+		}
+	}
+	else
+	{
+		if(FalseAlmCnt->Cnt_Cck_fail > 1000)
+			CurCCK_CCAThres = 0x83;
+		else
+			CurCCK_CCAThres = 0x40;
+	}
+	
+#if (RTL8192D_SUPPORT==1) 
+	if((pDM_Odm->SupportICType == ODM_RTL8192D) && (*pDM_Odm->pBandType == ODM_BAND_2_4G))
+		ODM_Write_CCK_CCA_Thres_92D(pDM_Odm, CurCCK_CCAThres);
+	else
+#endif
+		ODM_Write_CCK_CCA_Thres(pDM_Odm, CurCCK_CCAThres);
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CCK_PD, ODM_DBG_LOUD, ("odm_CCKPacketDetectionThresh()  CurCCK_CCAThres = 0x%x\n",CurCCK_CCAThres));
+}
+
+VOID
+ODM_Write_CCK_CCA_Thres(
+	IN	PVOID			pDM_VOID,
+	IN	u1Byte			CurCCK_CCAThres
+	)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T				pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	if(pDM_DigTable->CurCCK_CCAThres!=CurCCK_CCAThres)		//modify by Guo.Mingzhi 2012-01-03
+	{
+		ODM_Write1Byte(pDM_Odm, ODM_REG(CCK_CCA,pDM_Odm), CurCCK_CCAThres);
+	}
+	pDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;
+	pDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+// <20130108, Kordan> E.g., With LNA used, we make the Rx power smaller to have a better EVM. (Asked by Willis)
+VOID
+odm_RFEControl(
+	IN	PDM_ODM_T	pDM_Odm,
+	IN  u8Byte		RSSIVal
+	)
+{
+	PADAPTER		Adapter = (PADAPTER)pDM_Odm->Adapter;
+    HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	static u1Byte 	TRSW_HighPwr = 0;
+	 
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("===> odm_RFEControl, RSSI = %d, TRSW_HighPwr = 0x%X, pHalData->RFEType = %d\n",
+		         RSSIVal, TRSW_HighPwr, pHalData->RFEType ));
+
+    if (pHalData->RFEType == 3) {	   
+		
+        pDM_Odm->RSSI_TRSW = RSSIVal;
+
+        if (pDM_Odm->RSSI_TRSW >= pDM_Odm->RSSI_TRSW_H) 
+		{				 
+            TRSW_HighPwr = 1; // Switch to
+            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT1|BIT0, 0x1);  // Set ANTSW=1/ANTSWB=0  for SW control
+            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT9|BIT8, 0x3);  // Set ANTSW=1/ANTSWB=0  for SW control
+            
+        } 
+		else if (pDM_Odm->RSSI_TRSW <= pDM_Odm->RSSI_TRSW_L) 
+        {	  
+            TRSW_HighPwr = 0; // Switched back
+            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT1|BIT0, 0x1);  // Set ANTSW=1/ANTSWB=0  for SW control
+            PHY_SetBBReg(Adapter, r_ANTSEL_SW_Jaguar, BIT9|BIT8, 0x0);  // Set ANTSW=1/ANTSWB=0  for SW control
+
+        }
+    }  
+
+	
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("(pDM_Odm->RSSI_TRSW_H, pDM_Odm->RSSI_TRSW_L) = (%d, %d)\n", pDM_Odm->RSSI_TRSW_H, pDM_Odm->RSSI_TRSW_L));		
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("(RSSIVal, RSSIVal, pDM_Odm->RSSI_TRSW_iso) = (%d, %d, %d)\n", 
+				 RSSIVal, pDM_Odm->RSSI_TRSW_iso, pDM_Odm->RSSI_TRSW));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("<=== odm_RFEControl, RSSI = %d, TRSW_HighPwr = 0x%X\n", RSSIVal, TRSW_HighPwr));	
+}
+
+VOID
+odm_MPT_DIGWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	Adapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	ODM_MPT_DIG(pDM_Odm);
+}
+
+VOID
+odm_MPT_DIGCallback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+       HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	  PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+
+	#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+		#if USE_WORKITEM
+			PlatformScheduleWorkItem(&pDM_Odm->MPT_DIGWorkitem);
+		#else
+			ODM_MPT_DIG(pDM_Odm);
+		#endif
+	#else
+		PlatformScheduleWorkItem(&pDM_Odm->MPT_DIGWorkitem);
+	#endif
+
+}
+
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+VOID
+odm_MPT_DIGCallback(
+	IN		PVOID					pDM_VOID
+)
+{
+	PDM_ODM_T			pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if USE_WORKITEM
+	PlatformScheduleWorkItem(&pDM_Odm->MPT_DIGWorkitem);
+#else
+	ODM_MPT_DIG(pDM_Odm);
+#endif
+}
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE != ODM_CE)
+VOID
+odm_MPT_Write_DIG(
+	IN		PVOID					pDM_VOID,
+	IN		u1Byte					CurIGValue
+)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+	ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_A,pDM_Odm), CurIGValue);
+
+	if(pDM_Odm->RFType > ODM_1T1R)
+		ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_B,pDM_Odm), CurIGValue);
+
+	if((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (pDM_Odm->RFType > ODM_2T2R))
+	{
+		ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_C,pDM_Odm), CurIGValue);
+		ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_D,pDM_Odm), CurIGValue);	
+	}
+
+	pDM_DigTable->CurIGValue = CurIGValue;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("CurIGValue = 0x%x\n", CurIGValue));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("pDM_Odm->RFType = 0x%x\n", pDM_Odm->RFType));
+}
+
+VOID
+ODM_MPT_DIG(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T					pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pDIG_T						pDM_DigTable = &pDM_Odm->DM_DigTable;
+	PFALSE_ALARM_STATISTICS		pFalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm, PHYDM_FALSEALMCNT);
+	u1Byte						CurrentIGI = pDM_DigTable->CurIGValue;
+	u1Byte						DIG_Upper = 0x40, DIG_Lower = 0x20;
+	u4Byte						RXOK_cal;
+	u4Byte						RxPWDBAve_final;
+	u1Byte						IGI_A = 0x20, IGI_B = 0x20;
+	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+	#if ODM_FIX_2G_DIG
+	IGI_A = 0x22;
+	IGI_B = 0x24;		
+	#endif
+	
+#else
+	if (!(pDM_Odm->priv->pshare->rf_ft_var.mp_specific && pDM_Odm->priv->pshare->mp_dig_on))
+		return;
+
+	if (*pDM_Odm->pBandType == ODM_BAND_5G)
+		DIG_Lower = 0x22;
+#endif
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("===> ODM_MPT_DIG, pBandType = %d\n", *pDM_Odm->pBandType));
+	
+#if (ODM_FIX_2G_DIG || (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL)))
+	if (*pDM_Odm->pBandType == ODM_BAND_5G || (pDM_Odm->SupportICType & ODM_RTL8814A)) // for 5G or 8814
+#else
+	if (1) // for both 2G/5G
+#endif
+		{
+		odm_FalseAlarmCounterStatistics(pDM_Odm);
+
+		RXOK_cal = pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK + pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM;
+		RxPWDBAve_final = (RXOK_cal != 0)?pDM_Odm->RxPWDBAve/RXOK_cal:0;
+
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusCCK = 0;
+		pDM_Odm->PhyDbgInfo.NumQryPhyStatusOFDM = 0;
+		pDM_Odm->RxPWDBAve = 0;
+		pDM_Odm->MPDIG_2G = FALSE;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		pDM_Odm->Times_2G = 0;
+#endif
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("RX OK = %d\n", RXOK_cal));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("RSSI = %d\n", RxPWDBAve_final));
+	
+		if (RXOK_cal >= 70 && RxPWDBAve_final <= 40)
+		{
+			if (CurrentIGI > 0x24)
+				odm_MPT_Write_DIG(pDM_Odm, 0x24);
+		}
+		else
+		{
+			if(pFalseAlmCnt->Cnt_all > 1000){
+				CurrentIGI = CurrentIGI + 8;
+			}
+			else if(pFalseAlmCnt->Cnt_all > 200){
+				CurrentIGI = CurrentIGI + 4;
+			}
+			else if (pFalseAlmCnt->Cnt_all > 50){
+				CurrentIGI = CurrentIGI + 2;
+			}
+			else if (pFalseAlmCnt->Cnt_all < 2){
+				CurrentIGI = CurrentIGI - 2;
+			}
+			
+			if (CurrentIGI < DIG_Lower ){
+				CurrentIGI = DIG_Lower;
+			}
+
+			if(CurrentIGI > DIG_Upper){
+				CurrentIGI = DIG_Upper;
+			}
+
+			odm_MPT_Write_DIG(pDM_Odm, CurrentIGI);
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("DIG = 0x%x, Cnt_all = %d, Cnt_Ofdm_fail = %d, Cnt_Cck_fail = %d\n", 
+				CurrentIGI, pFalseAlmCnt->Cnt_all, pFalseAlmCnt->Cnt_Ofdm_fail, pFalseAlmCnt->Cnt_Cck_fail));
+		}
+	}
+	else
+	{
+		if(pDM_Odm->MPDIG_2G == FALSE)
+		{
+			if((pDM_Odm->SupportPlatform & ODM_WIN) && !(pDM_Odm->SupportICType & ODM_RTL8814A))
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DIG, ODM_DBG_LOUD, ("===> Fix IGI\n"));
+				ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_A,pDM_Odm), IGI_A);
+				ODM_Write1Byte( pDM_Odm, ODM_REG(IGI_B,pDM_Odm), IGI_B);
+				pDM_DigTable->CurIGValue = IGI_B;
+			}
+			else
+				odm_MPT_Write_DIG(pDM_Odm, IGI_A);
+		}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+		pDM_Odm->Times_2G++;
+
+		if (pDM_Odm->Times_2G == 3)
+#endif
+		{
+			pDM_Odm->MPDIG_2G = TRUE;
+		}
+	}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	if (pDM_Odm->SupportICType == ODM_RTL8812)
+		odm_RFEControl(pDM_Odm, RxPWDBAve_final);
+#endif
+
+	ODM_SetTimer(pDM_Odm, &pDM_Odm->MPT_DIGTimer, 700);
+}
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DIG.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DIG.h
new file mode 100644
index 000000000000..54e74d781dad
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DIG.h
@@ -0,0 +1,309 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMDIG_H__
+#define    __PHYDMDIG_H__
+
+#define DIG_VERSION	"1.1"
+
+typedef struct _Dynamic_Initial_Gain_Threshold_
+{
+	BOOLEAN		bStopDIG;		// for debug
+	BOOLEAN		bPauseDIG;
+	BOOLEAN		bIgnoreDIG;
+	BOOLEAN		bPSDInProgress;
+
+	u1Byte		Dig_Enable_Flag;
+	u1Byte		Dig_Ext_Port_Stage;
+	
+	int		   	RssiLowThresh;
+	int		    	RssiHighThresh;
+
+	u4Byte		FALowThresh;
+	u4Byte		FAHighThresh;
+
+	u1Byte		CurSTAConnectState;
+	u1Byte		PreSTAConnectState;
+	u1Byte		CurMultiSTAConnectState;
+
+	u1Byte		PreIGValue;
+	u1Byte		CurIGValue;
+	u1Byte		BackupIGValue;		//MP DIG
+	u1Byte		BT30_CurIGI;
+	u1Byte		IGIBackup;
+
+	s1Byte		BackoffVal;
+	s1Byte		BackoffVal_range_max;
+	s1Byte		BackoffVal_range_min;
+	u1Byte		rx_gain_range_max;
+	u1Byte		rx_gain_range_min;
+	u1Byte		Rssi_val_min;
+
+	u1Byte		PreCCK_CCAThres;
+	u1Byte		CurCCK_CCAThres;
+	u1Byte		PreCCKPDState;
+	u1Byte		CurCCKPDState;
+	u1Byte		CCKPDBackup;
+
+	u1Byte		LargeFAHit;
+	u1Byte		ForbiddenIGI;
+	u4Byte		Recover_cnt;
+
+	u1Byte		DIG_Dynamic_MIN_0;
+	u1Byte		DIG_Dynamic_MIN_1;
+	BOOLEAN		bMediaConnect_0;
+	BOOLEAN		bMediaConnect_1;
+
+	u4Byte		AntDiv_RSSI_max;
+	u4Byte		RSSI_max;
+
+	u1Byte		*pbP2pLinkInProgress;
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	BOOLEAN		bTpTarget;
+	BOOLEAN		bNoiseEst;
+	u4Byte		TpTrainTH_min;
+	u1Byte		IGIOffset_A;
+	u1Byte		IGIOffset_B;
+#endif
+}DIG_T,*pDIG_T;
+
+typedef struct _FALSE_ALARM_STATISTICS{
+	u4Byte	Cnt_Parity_Fail;
+	u4Byte	Cnt_Rate_Illegal;
+	u4Byte	Cnt_Crc8_fail;
+	u4Byte	Cnt_Mcs_fail;
+	u4Byte	Cnt_Ofdm_fail;
+	u4Byte	Cnt_Ofdm_fail_pre;	//For RTL8881A
+	u4Byte	Cnt_Cck_fail;
+	u4Byte	Cnt_all;
+	u4Byte	Cnt_Fast_Fsync;
+	u4Byte	Cnt_SB_Search_fail;
+	u4Byte	Cnt_OFDM_CCA;
+	u4Byte	Cnt_CCK_CCA;
+	u4Byte	Cnt_CCA_all;
+	u4Byte	Cnt_BW_USC;	//Gary
+	u4Byte	Cnt_BW_LSC;	//Gary
+}FALSE_ALARM_STATISTICS, *PFALSE_ALARM_STATISTICS;
+
+typedef enum tag_Dynamic_Init_Gain_Operation_Type_Definition
+{
+	DIG_TYPE_THRESH_HIGH	= 0,
+	DIG_TYPE_THRESH_LOW	= 1,
+	DIG_TYPE_BACKOFF		= 2,
+	DIG_TYPE_RX_GAIN_MIN	= 3,
+	DIG_TYPE_RX_GAIN_MAX	= 4,
+	DIG_TYPE_ENABLE 		= 5,
+	DIG_TYPE_DISABLE 		= 6,	
+	DIG_OP_TYPE_MAX
+}DM_DIG_OP_E;
+
+typedef enum tag_ODM_PauseDIG_Type {
+	ODM_PAUSE_DIG    		= 	BIT0,
+	ODM_RESUME_DIG  		= 	BIT1
+} ODM_Pause_DIG_TYPE;
+
+typedef enum tag_ODM_PauseCCKPD_Type {
+	ODM_PAUSE_CCKPD    	= 	BIT0,
+	ODM_RESUME_CCKPD  	= 	BIT1
+} ODM_Pause_CCKPD_TYPE;
+
+/*
+typedef enum tag_CCK_Packet_Detection_Threshold_Type_Definition
+{
+	CCK_PD_STAGE_LowRssi = 0,
+	CCK_PD_STAGE_HighRssi = 1,
+	CCK_PD_STAGE_MAX = 3,
+}DM_CCK_PDTH_E;
+
+typedef enum tag_DIG_EXT_PORT_ALGO_Definition
+{
+	DIG_EXT_PORT_STAGE_0 = 0,
+	DIG_EXT_PORT_STAGE_1 = 1,
+	DIG_EXT_PORT_STAGE_2 = 2,
+	DIG_EXT_PORT_STAGE_3 = 3,
+	DIG_EXT_PORT_STAGE_MAX = 4,
+}DM_DIG_EXT_PORT_ALG_E;
+
+typedef enum tag_DIG_Connect_Definition
+{
+	DIG_STA_DISCONNECT = 0,	
+	DIG_STA_CONNECT = 1,
+	DIG_STA_BEFORE_CONNECT = 2,
+	DIG_MultiSTA_DISCONNECT = 3,
+	DIG_MultiSTA_CONNECT = 4,
+	DIG_CONNECT_MAX
+}DM_DIG_CONNECT_E;
+
+
+#define DM_MultiSTA_InitGainChangeNotify(Event) {DM_DigTable.CurMultiSTAConnectState = Event;}
+
+#define DM_MultiSTA_InitGainChangeNotify_CONNECT(_ADAPTER)	\
+	DM_MultiSTA_InitGainChangeNotify(DIG_MultiSTA_CONNECT)
+
+#define DM_MultiSTA_InitGainChangeNotify_DISCONNECT(_ADAPTER)	\
+	DM_MultiSTA_InitGainChangeNotify(DIG_MultiSTA_DISCONNECT)
+*/
+#define		DM_DIG_THRESH_HIGH			40
+#define		DM_DIG_THRESH_LOW			35
+
+#define		DM_FALSEALARM_THRESH_LOW	400
+#define		DM_FALSEALARM_THRESH_HIGH	1000
+
+#define		DM_DIG_MAX_NIC				0x3e
+#define		DM_DIG_MIN_NIC				0x1e //0x22//0x1c
+#define		DM_DIG_MAX_OF_MIN_NIC		0x3e
+
+#define		DM_DIG_MAX_AP					0x3e
+#define		DM_DIG_MIN_AP					0x1c
+#define		DM_DIG_MAX_OF_MIN			0x2A	//0x32
+#define		DM_DIG_MIN_AP_DFS				0x20
+
+#define		DM_DIG_MAX_NIC_HP			0x46
+#define		DM_DIG_MIN_NIC_HP				0x2e
+
+#define		DM_DIG_MAX_AP_HP				0x42
+#define		DM_DIG_MIN_AP_HP				0x30
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+#define		DM_DIG_MAX_AP_COVERAGR		0x26
+#define		DM_DIG_MIN_AP_COVERAGE		0x1c
+#define		DM_DIG_MAX_OF_MIN_COVERAGE	0x22
+
+#define		DM_DIG_TP_Target_TH0			500
+#define		DM_DIG_TP_Target_TH1			1000
+#define		DM_DIG_TP_Training_Period		10
+#endif
+
+//vivi 92c&92d has different definition, 20110504
+//this is for 92c
+#if (DM_ODM_SUPPORT_TYPE & ODM_CE)
+	#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
+	#define		DM_DIG_FA_TH0				0x80//0x20
+	#else
+	#define		DM_DIG_FA_TH0				0x200//0x20
+	#endif
+#else
+	#define		DM_DIG_FA_TH0				0x200//0x20
+#endif
+
+#define		DM_DIG_FA_TH1					0x300
+#define		DM_DIG_FA_TH2					0x400
+//this is for 92d
+#define		DM_DIG_FA_TH0_92D				0x100
+#define		DM_DIG_FA_TH1_92D				0x400
+#define		DM_DIG_FA_TH2_92D				0x600
+
+#define		DM_DIG_BACKOFF_MAX			12
+#define		DM_DIG_BACKOFF_MIN			-4
+#define		DM_DIG_BACKOFF_DEFAULT		10
+
+#define 		DM_DIG_FA_TH0_LPS				4 //-> 4 in lps
+#define 		DM_DIG_FA_TH1_LPS				15 //-> 15 lps
+#define 		DM_DIG_FA_TH2_LPS				30 //-> 30 lps
+#define 		RSSI_OFFSET_DIG				0x05
+
+VOID
+ODM_ChangeDynamicInitGainThresh(
+	IN		PVOID					pDM_VOID,
+	IN		u4Byte  					DM_Type,
+	IN		u4Byte 					DM_Value
+	);
+
+VOID
+ODM_Write_DIG(
+	IN		PVOID					pDM_VOID, 	
+	IN		u1Byte					CurrentIGI
+	);
+
+VOID
+odm_PauseDIG(
+	IN		PVOID					pDM_VOID,
+	IN		ODM_Pause_DIG_TYPE		PauseType,
+	IN		u1Byte					IGIValue
+	);
+
+VOID
+odm_DIGInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID	
+odm_DIG(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_DIGbyRSSI_LPS(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_FalseAlarmCounterStatistics(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_PauseCCKPacketDetection(
+	IN		PVOID					pDM_VOID,
+	IN		ODM_Pause_CCKPD_TYPE	PauseType,
+	IN		u1Byte					CCKPDThreshold
+	);
+
+VOID 
+odm_CCKPacketDetectionThresh(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+ODM_Write_CCK_CCA_Thres(
+	IN		PVOID					pDM_VOID, 
+	IN		u1Byte					CurCCK_CCAThres
+	);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+odm_MPT_DIGCallback(
+	PRT_TIMER						pTimer
+);
+
+VOID
+odm_MPT_DIGWorkItemCallback(
+    IN 		PVOID            			pContext
+    );
+
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+VOID
+odm_MPT_DIGCallback(
+	IN		PVOID					pDM_VOID
+);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE != ODM_CE)
+VOID
+ODM_MPT_DIG(
+	IN		PVOID					pDM_VOID
+);
+#endif
+
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicBBPowerSaving.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicBBPowerSaving.c
new file mode 100644
index 000000000000..a9099ade38a3
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicBBPowerSaving.c
@@ -0,0 +1,218 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+VOID 
+odm_DynamicBBPowerSavingInit(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
+
+	pDM_PSTable->PreCCAState = CCA_MAX;
+	pDM_PSTable->CurCCAState = CCA_MAX;
+	pDM_PSTable->PreRFState = RF_MAX;
+	pDM_PSTable->CurRFState = RF_MAX;
+	pDM_PSTable->Rssi_val_min = 0;
+	pDM_PSTable->initialize = 0;
+}
+
+
+VOID
+odm_DynamicBBPowerSaving(
+	IN		PVOID					pDM_VOID
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+
+	if (pDM_Odm->SupportICType != ODM_RTL8723A)
+		return;
+	if(!(pDM_Odm->SupportAbility & ODM_BB_PWR_SAVE))
+		return;
+	if(!(pDM_Odm->SupportPlatform & (ODM_WIN|ODM_CE)))
+		return;
+	
+	//1 2.Power Saving for 92C
+	if((pDM_Odm->SupportICType == ODM_RTL8192C) &&(pDM_Odm->RFType == ODM_2T2R))
+	{
+		odm_1R_CCA(pDM_Odm);
+	}
+	
+	// 20100628 Joseph: Turn off BB power save for 88CE because it makesthroughput unstable.
+	// 20100831 Joseph: Turn ON BB power save again after modifying AGC delay from 900ns ot 600ns.
+	//1 3.Power Saving for 88C
+	else
+	{
+		ODM_RF_Saving(pDM_Odm, FALSE);
+	}
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	
+}
+
+VOID
+odm_1R_CCA(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
+
+	if(pDM_Odm->RSSI_Min!= 0xFF)
+	{
+		 
+		if(pDM_PSTable->PreCCAState == CCA_2R)
+		{
+			if(pDM_Odm->RSSI_Min >= 35)
+				pDM_PSTable->CurCCAState = CCA_1R;
+			else
+				pDM_PSTable->CurCCAState = CCA_2R;
+			
+		}
+		else{
+			if(pDM_Odm->RSSI_Min <= 30)
+				pDM_PSTable->CurCCAState = CCA_2R;
+			else
+				pDM_PSTable->CurCCAState = CCA_1R;
+		}
+	}
+	else{
+		pDM_PSTable->CurCCAState=CCA_MAX;
+	}
+	
+	if(pDM_PSTable->PreCCAState != pDM_PSTable->CurCCAState)
+	{
+		if(pDM_PSTable->CurCCAState == CCA_1R)
+		{
+			if(  pDM_Odm->RFType ==ODM_2T2R )
+			{
+				ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x13);
+				//PHY_SetBBReg(pAdapter, 0xe70, bMaskByte3, 0x20);
+			}
+			else
+			{
+				ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x23);
+				//PHY_SetBBReg(pAdapter, 0xe70, 0x7fc00000, 0x10c); // Set RegE70[30:22] = 9b'100001100
+			}
+		}
+		else
+		{
+			ODM_SetBBReg(pDM_Odm, 0xc04  , bMaskByte0, 0x33);
+			//PHY_SetBBReg(pAdapter,0xe70, bMaskByte3, 0x63);
+		}
+		pDM_PSTable->PreCCAState = pDM_PSTable->CurCCAState;
+	}
+}
+
+void
+ODM_RF_Saving(
+	IN		PVOID					pDM_VOID,
+	IN	u1Byte		bForceInNormal 
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE != ODM_AP)
+	pPS_T	pDM_PSTable = &pDM_Odm->DM_PSTable;
+	u1Byte	Rssi_Up_bound = 30 ;
+	u1Byte	Rssi_Low_bound = 25;
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	if(pDM_Odm->PatchID == 40 ) //RT_CID_819x_FUNAI_TV
+	{
+		Rssi_Up_bound = 50 ;
+		Rssi_Low_bound = 45;
+	}
+#endif
+	if(pDM_PSTable->initialize == 0){
+		
+		pDM_PSTable->Reg874 = (ODM_GetBBReg(pDM_Odm, 0x874, bMaskDWord)&0x1CC000)>>14;
+		pDM_PSTable->RegC70 = (ODM_GetBBReg(pDM_Odm, 0xc70, bMaskDWord)&BIT3)>>3;
+		pDM_PSTable->Reg85C = (ODM_GetBBReg(pDM_Odm, 0x85c, bMaskDWord)&0xFF000000)>>24;
+		pDM_PSTable->RegA74 = (ODM_GetBBReg(pDM_Odm, 0xa74, bMaskDWord)&0xF000)>>12;
+		//Reg818 = PHY_QueryBBReg(pAdapter, 0x818, bMaskDWord);
+		pDM_PSTable->initialize = 1;
+	}
+
+	if(!bForceInNormal)
+	{
+		if(pDM_Odm->RSSI_Min != 0xFF)
+		{			 
+			if(pDM_PSTable->PreRFState == RF_Normal)
+			{
+				if(pDM_Odm->RSSI_Min >= Rssi_Up_bound)
+					pDM_PSTable->CurRFState = RF_Save;
+				else
+					pDM_PSTable->CurRFState = RF_Normal;
+			}
+			else{
+				if(pDM_Odm->RSSI_Min <= Rssi_Low_bound)
+					pDM_PSTable->CurRFState = RF_Normal;
+				else
+					pDM_PSTable->CurRFState = RF_Save;
+			}
+		}
+		else
+			pDM_PSTable->CurRFState=RF_MAX;
+	}
+	else
+	{
+		pDM_PSTable->CurRFState = RF_Normal;
+	}
+	
+	if(pDM_PSTable->PreRFState != pDM_PSTable->CurRFState)
+	{
+		if(pDM_PSTable->CurRFState == RF_Save)
+		{
+			// <tynli_note> 8723 RSSI report will be wrong. Set 0x874[5]=1 when enter BB power saving mode.
+			// Suggested by SD3 Yu-Nan. 2011.01.20.
+			if(pDM_Odm->SupportICType == ODM_RTL8723A)
+			{
+				ODM_SetBBReg(pDM_Odm, 0x874  , BIT5, 0x1); //Reg874[5]=1b'1
+			}
+			ODM_SetBBReg(pDM_Odm, 0x874  , 0x1C0000, 0x2); //Reg874[20:18]=3'b010
+			ODM_SetBBReg(pDM_Odm, 0xc70, BIT3, 0); //RegC70[3]=1'b0
+			ODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, 0x63); //Reg85C[31:24]=0x63
+			ODM_SetBBReg(pDM_Odm, 0x874, 0xC000, 0x2); //Reg874[15:14]=2'b10
+			ODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, 0x3); //RegA75[7:4]=0x3
+			ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0); //Reg818[28]=1'b0
+			ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x1); //Reg818[28]=1'b1
+		}
+		else
+		{
+			ODM_SetBBReg(pDM_Odm, 0x874  , 0x1CC000, pDM_PSTable->Reg874); 
+			ODM_SetBBReg(pDM_Odm, 0xc70, BIT3, pDM_PSTable->RegC70); 
+			ODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, pDM_PSTable->Reg85C);
+			ODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, pDM_PSTable->RegA74); 
+			ODM_SetBBReg(pDM_Odm,0x818, BIT28, 0x0);  
+
+			if(pDM_Odm->SupportICType == ODM_RTL8723A)
+			{
+				ODM_SetBBReg(pDM_Odm,0x874  , BIT5, 0x0); //Reg874[5]=1b'0
+			}
+		}
+		pDM_PSTable->PreRFState =pDM_PSTable->CurRFState;
+	}
+#endif	
+}
\ No newline at end of file
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicBBPowerSaving.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicBBPowerSaving.h
new file mode 100644
index 000000000000..ef045098afbf
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicBBPowerSaving.h
@@ -0,0 +1,63 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMDYNAMICBBPOWERSAVING_H__
+#define    __PHYDMDYNAMICBBPOWERSAVING_H__
+
+#define DYNAMIC_BBPWRSAV_VERSION	"1.0"
+
+typedef struct _Dynamic_Power_Saving_
+{
+	u1Byte		PreCCAState;
+	u1Byte		CurCCAState;
+
+	u1Byte		PreRFState;
+	u1Byte		CurRFState;
+
+	int		    Rssi_val_min;
+	
+	u1Byte		initialize;
+	u4Byte		Reg874,RegC70,Reg85C,RegA74;
+	
+}PS_T,*pPS_T;
+
+#define dm_RF_Saving	ODM_RF_Saving
+
+void ODM_RF_Saving(
+	IN		PVOID					pDM_VOID,
+	IN	u1Byte		bForceInNormal 
+	);
+
+VOID 
+odm_DynamicBBPowerSavingInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_DynamicBBPowerSaving(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_1R_CCA(
+	IN		PVOID					pDM_VOID
+	);
+
+#endif
\ No newline at end of file
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicTxPower.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicTxPower.c
new file mode 100644
index 000000000000..5a6d2a94f805
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicTxPower.c
@@ -0,0 +1,882 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+VOID 
+odm_DynamicTxPowerInit(
+	IN		PVOID					pDM_VOID	
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+
+	#if DEV_BUS_TYPE==RT_USB_INTERFACE					
+	if(RT_GetInterfaceSelection(Adapter) == INTF_SEL1_USB_High_Power)
+	{
+		odm_DynamicTxPowerSavePowerIndex(pDM_Odm);
+		pMgntInfo->bDynamicTxPowerEnable = TRUE;
+	}		
+	else	
+	#else
+	//so 92c pci do not need dynamic tx power? vivi check it later
+	if(IS_HARDWARE_TYPE_8192D(Adapter))
+		pMgntInfo->bDynamicTxPowerEnable = TRUE;
+	else
+		pMgntInfo->bDynamicTxPowerEnable = FALSE;
+	#endif
+	
+
+	pHalData->LastDTPLvl = TxHighPwrLevel_Normal;
+	pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	pdmpriv->bDynamicTxPowerEnable = _FALSE;
+
+	#if (RTL8192C_SUPPORT==1) 
+	#ifdef CONFIG_USB_HCI
+
+	#ifdef CONFIG_INTEL_PROXIM
+	if((pHalData->BoardType == BOARD_USB_High_PA)||(Adapter->proximity.proxim_support==_TRUE))
+	#else
+	if(pHalData->BoardType == BOARD_USB_High_PA)
+	#endif
+
+	{
+		//odm_SavePowerIndex(Adapter);
+		odm_DynamicTxPowerSavePowerIndex(pDM_Odm);
+		pdmpriv->bDynamicTxPowerEnable = _TRUE;
+	}		
+	else	
+	#else
+		pdmpriv->bDynamicTxPowerEnable = _FALSE;
+	#endif
+	#endif
+	
+	pdmpriv->LastDTPLvl = TxHighPwrLevel_Normal;
+	pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;	
+	
+#endif
+	
+}
+
+VOID
+odm_DynamicTxPowerSavePowerIndex(
+	IN		PVOID					pDM_VOID	
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	u1Byte		index;
+	u4Byte		Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+	
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)	
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	for(index = 0; index< 6; index++)
+		pHalData->PowerIndex_backup[index] = PlatformEFIORead1Byte(Adapter, Power_Index_REG[index]);
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)	
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	for(index = 0; index< 6; index++)
+		pdmpriv->PowerIndex_backup[index] = rtw_read8(Adapter, Power_Index_REG[index]);
+#endif
+#endif
+}
+
+VOID
+odm_DynamicTxPowerRestorePowerIndex(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_WIN))
+	u1Byte			index;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u4Byte			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	for(index = 0; index< 6; index++)
+		PlatformEFIOWrite1Byte(Adapter, Power_Index_REG[index], pHalData->PowerIndex_backup[index]);
+#elif(DM_ODM_SUPPORT_TYPE == ODM_CE)	
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	for(index = 0; index< 6; index++)
+		rtw_write8(Adapter, Power_Index_REG[index], pdmpriv->PowerIndex_backup[index]);
+#endif
+#endif
+}
+
+VOID
+odm_DynamicTxPowerWritePowerIndex(
+	IN		PVOID					pDM_VOID, 
+	IN 	u1Byte		Value)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte			index;
+	u4Byte			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
+	
+	for(index = 0; index< 6; index++)
+		//PlatformEFIOWrite1Byte(Adapter, Power_Index_REG[index], Value);
+		ODM_Write1Byte(pDM_Odm, Power_Index_REG[index], Value);
+
+}
+
+
+VOID 
+odm_DynamicTxPower(
+	IN		PVOID					pDM_VOID
+	)
+{
+	// 
+	// For AP/ADSL use prtl8192cd_priv
+	// For CE/NIC use PADAPTER
+	//
+	//PADAPTER		pAdapter = pDM_Odm->Adapter;
+//	prtl8192cd_priv	priv		= pDM_Odm->priv;
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if (!(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR))
+		return;
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+		case	ODM_CE:
+			odm_DynamicTxPowerNIC(pDM_Odm);
+			break;	
+		case	ODM_AP:
+			odm_DynamicTxPowerAP(pDM_Odm);
+			break;		
+
+		case	ODM_ADSL:
+			//odm_DIGAP(pDM_Odm);
+			break;	
+	}
+
+	
+}
+
+
+VOID 
+odm_DynamicTxPowerNIC(
+	IN		PVOID					pDM_VOID
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if (!(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR))
+		return;
+	
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+
+	if(pDM_Odm->SupportICType == ODM_RTL8192C)	
+	{
+		odm_DynamicTxPower_92C(pDM_Odm);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		odm_DynamicTxPower_92D(pDM_Odm);
+	}
+	else if (pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+		PADAPTER		Adapter	 =  pDM_Odm->Adapter;
+		PMGNT_INFO		pMgntInfo = GetDefaultMgntInfo(Adapter);
+
+		if (pMgntInfo->RegRspPwr == 1)
+		{
+			if(pDM_Odm->RSSI_Min > 60)
+			{
+				ODM_SetMACReg(pDM_Odm, ODM_REG_RESP_TX_11AC, BIT20|BIT19|BIT18, 1); // Resp TXAGC offset = -3dB
+
+			}
+			else if(pDM_Odm->RSSI_Min < 55)
+			{
+				ODM_SetMACReg(pDM_Odm, ODM_REG_RESP_TX_11AC, BIT20|BIT19|BIT18, 0); // Resp TXAGC offset = 0dB
+			}
+		}
+#endif
+	}
+#endif	
+}
+
+VOID 
+odm_DynamicTxPowerAP(
+	IN		PVOID					pDM_VOID
+
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+
+//#if ((RTL8192C_SUPPORT==1) || (RTL8192D_SUPPORT==1) || (RTL8188E_SUPPORT==1) || (RTL8812E_SUPPORT==1))
+
+
+	prtl8192cd_priv	priv		= pDM_Odm->priv;
+	s4Byte i;
+	s2Byte pwr_thd = TX_POWER_NEAR_FIELD_THRESH_AP;
+
+	if(!priv->pshare->rf_ft_var.tx_pwr_ctrl)
+		return;
+	
+#if ((RTL8812E_SUPPORT==1) || (RTL8881A_SUPPORT==1))
+	if (pDM_Odm->SupportICType & (ODM_RTL8812 | ODM_RTL8881A))
+		pwr_thd = TX_POWER_NEAR_FIELD_THRESH_8812;
+#endif
+
+#if defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_92C_SUPPORT)
+	if(CHIP_VER_92X_SERIES(priv))
+	{
+#ifdef HIGH_POWER_EXT_PA
+	if(pDM_Odm->ExtPA)
+		tx_power_control(priv);
+#endif		
+	}
+#endif	
+	/*
+	 *	Check if station is near by to use lower tx power
+	 */
+
+	if ((priv->up_time % 3) == 0 )  {
+		int disable_pwr_ctrl = ((pDM_Odm->FalseAlmCnt.Cnt_all > 1000 ) || ((pDM_Odm->FalseAlmCnt.Cnt_all > 300 ) && ((RTL_R8(0xc50) & 0x7f) >= 0x32))) ? 1 : 0;
+			
+		for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++){
+			PSTA_INFO_T pstat = pDM_Odm->pODM_StaInfo[i];
+			if(IS_STA_VALID(pstat) ) {
+					if(disable_pwr_ctrl)
+						pstat->hp_level = 0;
+					 else if ((pstat->hp_level == 0) && (pstat->rssi > pwr_thd))
+					pstat->hp_level = 1;
+						else if ((pstat->hp_level == 1) && (pstat->rssi < (pwr_thd-8)))
+					pstat->hp_level = 0;
+			}
+		}
+
+#if defined(CONFIG_WLAN_HAL_8192EE)
+		if (GET_CHIP_VER(priv) == VERSION_8192E) {
+			if( !disable_pwr_ctrl && (pDM_Odm->RSSI_Min != 0xff) ) {
+				if(pDM_Odm->RSSI_Min > pwr_thd)
+					RRSR_power_control_11n(priv,  1 );
+				else if(pDM_Odm->RSSI_Min < (pwr_thd-8))
+					RRSR_power_control_11n(priv,  0 );
+			} else {
+					RRSR_power_control_11n(priv,  0 );
+			}
+		}
+#endif			
+	}
+//#endif	
+
+#endif	
+}
+
+
+VOID 
+odm_DynamicTxPower_92C(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	s4Byte				UndecoratedSmoothedPWDB;
+
+	// 2012/01/12 MH According to Luke's suggestion, only high power will support the feature.
+	if (pDM_Odm->ExtPA == FALSE)
+		return;
+
+	// STA not connected and AP not connected
+	if((!pMgntInfo->bMediaConnect) &&	
+		(pHalData->EntryMinUndecoratedSmoothedPWDB == 0))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("Not connected to any \n"));
+		pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+
+		//the LastDTPlvl should reset when disconnect, 
+		//otherwise the tx power level wouldn't change when disconnect and connect again.
+		// Maddest 20091220.
+		 pHalData->LastDTPLvl=TxHighPwrLevel_Normal;
+		return;
+	}
+
+#if (INTEL_PROXIMITY_SUPPORT == 1)
+	// Intel set fixed tx power 
+	if(pMgntInfo->IntelProximityModeInfo.PowerOutput > 0)
+	{
+		switch(pMgntInfo->IntelProximityModeInfo.PowerOutput){
+			case 1:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_100;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_100\n"));
+				break;
+			case 2:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_70;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_70\n"));
+				break;
+			case 3:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_50;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_50\n"));
+				break;
+			case 4:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_35;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_35\n"));
+				break;
+			case 5:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_15;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_15\n"));
+				break;
+			default:
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_100;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_100\n"));
+				break;
+		}		
+	}
+	else
+#endif		
+	{ 
+		if(	(pMgntInfo->bDynamicTxPowerEnable != TRUE) ||
+			pMgntInfo->IOTAction & HT_IOT_ACT_DISABLE_HIGH_POWER)
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		}
+		else
+		{
+			if(pMgntInfo->bMediaConnect)	// Default port
+			{
+				if(ACTING_AS_AP(Adapter) || ACTING_AS_IBSS(Adapter))
+				{
+					UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+				}
+				else
+				{
+					UndecoratedSmoothedPWDB = pHalData->UndecoratedSmoothedPWDB;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+				}
+			}
+			else // associated entry pwdb
+			{	
+				UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+			}
+				
+			if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
+			{
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
+			}
+			else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
+				(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
+			{
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+			}
+			else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
+			{
+				pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
+			}
+		}
+	}
+	if( pHalData->DynamicTxHighPowerLvl != pHalData->LastDTPLvl )
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192C() Channel = %d \n" , pHalData->CurrentChannel));
+		PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+		if(	(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Normal) &&
+			(pHalData->LastDTPLvl == TxHighPwrLevel_Level1 || pHalData->LastDTPLvl == TxHighPwrLevel_Level2)) //TxHighPwrLevel_Normal
+			odm_DynamicTxPowerRestorePowerIndex(pDM_Odm);
+		else if(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)
+			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x14);
+		else if(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)
+			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x10);
+	}
+	pHalData->LastDTPLvl = pHalData->DynamicTxHighPowerLvl;
+
+	
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+
+	#if (RTL8192C_SUPPORT==1) 
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	int	UndecoratedSmoothedPWDB;
+
+	if(!pdmpriv->bDynamicTxPowerEnable)
+		return;
+
+#ifdef CONFIG_INTEL_PROXIM
+	if(Adapter->proximity.proxim_on== _TRUE){
+		struct proximity_priv *prox_priv=Adapter->proximity.proximity_priv;
+		// Intel set fixed tx power 
+		printk("\n %s  Adapter->proximity.proxim_on=%d prox_priv->proxim_modeinfo->power_output=%d \n",__FUNCTION__,Adapter->proximity.proxim_on,prox_priv->proxim_modeinfo->power_output);
+		if(prox_priv!=NULL){
+			if(prox_priv->proxim_modeinfo->power_output> 0)	
+			{
+				switch(prox_priv->proxim_modeinfo->power_output)
+				{
+					case 1:
+						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_100;
+						printk("TxHighPwrLevel_100\n");
+						break;
+					case 2:
+						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_70;
+						printk("TxHighPwrLevel_70\n");
+						break;
+					case 3:
+						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_50;
+						printk("TxHighPwrLevel_50\n");
+						break;
+					case 4:
+						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_35;
+						printk("TxHighPwrLevel_35\n");
+						break;
+					case 5:
+						pdmpriv->DynamicTxHighPowerLvl  = TxHighPwrLevel_15;
+						printk("TxHighPwrLevel_15\n");
+						break;
+					default:
+						pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_100;
+						printk("TxHighPwrLevel_100\n");
+						break;
+				}		
+			}
+		}
+	}
+	else
+#endif	
+	{
+		// STA not connected and AP not connected
+		if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&	
+			(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
+		{
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+
+			//the LastDTPlvl should reset when disconnect, 
+			//otherwise the tx power level wouldn't change when disconnect and connect again.
+			// Maddest 20091220.
+			pdmpriv->LastDTPLvl=TxHighPwrLevel_Normal;
+			return;
+		}
+		
+		if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	// Default port
+		{
+		#if 0
+			//todo: AP Mode
+			if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+			       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+			{
+				UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+				//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+			}
+			else
+			{
+				UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
+				//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+			}
+		#else
+		UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;	
+		#endif
+		}
+		else // associated entry pwdb
+		{	
+			UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+		}
+			
+		if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
+		}
+		else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
+			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+		}
+		else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
+		}
+	}
+	if( (pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl) )
+	{
+		PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+		if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Normal) // HP1 -> Normal  or HP2 -> Normal
+			odm_DynamicTxPowerRestorePowerIndex(pDM_Odm);
+		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)
+			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x14);
+		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)
+			odm_DynamicTxPowerWritePowerIndex(pDM_Odm, 0x10);
+	}
+	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
+	#endif
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+}
+
+
+VOID 
+odm_DynamicTxPower_92D(
+	IN		PVOID					pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	s4Byte				UndecoratedSmoothedPWDB;
+
+	PADAPTER	BuddyAdapter = Adapter->BuddyAdapter;
+	BOOLEAN		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(Adapter);
+	u1Byte		HighPowerLvlBackForMac0 = TxHighPwrLevel_Level1;
+
+	// 2012/01/12 MH According to Luke's suggestion, only high power will support the feature.
+	if (pDM_Odm->ExtPA == FALSE)
+		return;
+
+	// If dynamic high power is disabled.
+	if( (pMgntInfo->bDynamicTxPowerEnable != TRUE) ||
+		pMgntInfo->IOTAction & HT_IOT_ACT_DISABLE_HIGH_POWER)
+	{
+		pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		return;
+	}
+
+	// STA not connected and AP not connected
+	if((!pMgntInfo->bMediaConnect) &&	
+		(pHalData->EntryMinUndecoratedSmoothedPWDB == 0))
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("Not connected to any \n"));
+		pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+
+		//the LastDTPlvl should reset when disconnect, 
+		//otherwise the tx power level wouldn't change when disconnect and connect again.
+		// Maddest 20091220.
+		 pHalData->LastDTPLvl=TxHighPwrLevel_Normal;
+		return;
+	}
+	
+	if(pMgntInfo->bMediaConnect)	// Default port
+	{
+		if(ACTING_AS_AP(Adapter) || pMgntInfo->mIbss)
+		{
+			UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+		}
+		else
+		{
+			UndecoratedSmoothedPWDB = pHalData->UndecoratedSmoothedPWDB;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+		}
+	}
+	else // associated entry pwdb
+	{	
+		UndecoratedSmoothedPWDB = pHalData->EntryMinUndecoratedSmoothedPWDB;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+	}
+	
+	if(IS_HARDWARE_TYPE_8192D(Adapter) && GET_HAL_DATA(Adapter)->CurrentBandType == 1){
+		if(UndecoratedSmoothedPWDB >= 0x33)
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level2 (TxPwr=0x0)\n"));
+		}
+		else if((UndecoratedSmoothedPWDB <0x33) &&
+			(UndecoratedSmoothedPWDB >= 0x2b) )
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+		}
+		else if(UndecoratedSmoothedPWDB < 0x2b)
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Normal\n"));
+		}
+
+	}
+	else
+	
+	{
+		if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
+		}
+		else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
+			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+		}
+		else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
+		{
+			pHalData->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
+		}
+
+	}
+
+//sherry  delete flag 20110517
+	if(bGetValueFromBuddyAdapter)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 1 \n"));
+		if(Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP)
+		{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() change value \n"));
+			HighPowerLvlBackForMac0 = pHalData->DynamicTxHighPowerLvl;
+			pHalData->DynamicTxHighPowerLvl = Adapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP;
+			PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+			pHalData->DynamicTxHighPowerLvl = HighPowerLvlBackForMac0;
+			Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = FALSE;
+		}						
+	}
+
+	if( (pHalData->DynamicTxHighPowerLvl != pHalData->LastDTPLvl) )
+	{
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192S() Channel = %d \n" , pHalData->CurrentChannel));
+			if(Adapter->DualMacSmartConcurrent == TRUE)
+			{
+				if(BuddyAdapter == NULL)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter == NULL case \n"));
+					if(!Adapter->bSlaveOfDMSP)
+					{
+						PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+					}
+				}
+				else
+				{
+					if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+					{
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMSP \n"));
+						if(Adapter->bSlaveOfDMSP)
+						{
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() bslave case  \n"));
+							BuddyAdapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = TRUE;
+							BuddyAdapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP = pHalData->DynamicTxHighPowerLvl;
+						}
+						else
+						{
+							ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() master case  \n"));					
+							if(!bGetValueFromBuddyAdapter)
+							{
+								ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 0 \n"));
+								PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+							}
+						}
+					}
+					else
+					{
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_DYNAMIC_TXPWR,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMDP\n"));
+						PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+					}
+				}
+			}
+			else
+			{
+				PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
+			}
+
+		}
+	pHalData->LastDTPLvl = pHalData->DynamicTxHighPowerLvl;
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#if (RTL8192D_SUPPORT==1) 
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
+
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	DM_ODM_T 		*podmpriv = &pHalData->odmpriv;
+	int	UndecoratedSmoothedPWDB;
+	#if (RTL8192D_EASY_SMART_CONCURRENT == 1)
+	PADAPTER	BuddyAdapter = Adapter->BuddyAdapter;
+	BOOLEAN		bGetValueFromBuddyAdapter = DualMacGetParameterFromBuddyAdapter(Adapter);
+	u8		HighPowerLvlBackForMac0 = TxHighPwrLevel_Level1;
+	#endif
+
+	// If dynamic high power is disabled.
+	if( (pdmpriv->bDynamicTxPowerEnable != _TRUE) ||
+		(!(podmpriv->SupportAbility& ODM_BB_DYNAMIC_TXPWR)) )
+	{
+		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		return;
+	}
+
+	// STA not connected and AP not connected
+	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&	
+		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
+	{
+		//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
+		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		//the LastDTPlvl should reset when disconnect, 
+		//otherwise the tx power level wouldn't change when disconnect and connect again.
+		// Maddest 20091220.
+		pdmpriv->LastDTPLvl=TxHighPwrLevel_Normal;
+		return;
+	}
+		
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	// Default port
+	{
+	#if 0
+		//todo: AP Mode
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
+	       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+		{
+			UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+		}
+		else
+		{
+			UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+		}
+	#else
+	UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+	#endif
+	}
+	else // associated entry pwdb
+	{	
+		UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+		//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
+	}
+#if TX_POWER_FOR_5G_BAND == 1
+	if(pHalData->CurrentBandType92D == BAND_ON_5G){
+		if(UndecoratedSmoothedPWDB >= 0x33)
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level2 (TxPwr=0x0)\n"));
+		}
+		else if((UndecoratedSmoothedPWDB <0x33) &&
+			(UndecoratedSmoothedPWDB >= 0x2b) )
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+		}
+		else if(UndecoratedSmoothedPWDB < 0x2b)
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Normal\n"));
+		}
+	}
+	else
+#endif
+	{
+		if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
+		}
+		else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
+			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
+		}
+		else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+			//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
+		}
+	}
+#if (RTL8192D_EASY_SMART_CONCURRENT == 1)
+	if(bGetValueFromBuddyAdapter)
+	{
+		//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 1 \n"));
+		if(Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP)
+		{
+			//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() change value \n"));
+			HighPowerLvlBackForMac0 = pHalData->DynamicTxHighPowerLvl;
+			pHalData->DynamicTxHighPowerLvl = Adapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP;
+			PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+			pHalData->DynamicTxHighPowerLvl = HighPowerLvlBackForMac0;
+			Adapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = _FALSE;
+		}						
+	}
+#endif
+
+	if( (pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl) )
+	{
+		//ODM_RT_TRACE(pDM_Odm,COMP_HIPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192S() Channel = %d \n" , pHalData->CurrentChannel));
+#if (RTL8192D_EASY_SMART_CONCURRENT == 1)
+		if(BuddyAdapter == NULL)
+		{
+			//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter == NULL case \n"));
+			if(!Adapter->bSlaveOfDMSP)
+			{
+				PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+			}
+		}
+		else
+		{
+			if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+			{
+				//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMSP \n"));
+				if(Adapter->bSlaveOfDMSP)
+				{
+					//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() bslave case  \n"));
+					BuddyAdapter->DualMacDMSPControl.bChangeTxHighPowerLvlForAnotherMacOfDMSP = _TRUE;
+					BuddyAdapter->DualMacDMSPControl.CurTxHighLvlForAnotherMacOfDMSP = pHalData->DynamicTxHighPowerLvl;
+				}
+				else
+				{
+					//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() master case  \n"));					
+					if(!bGetValueFromBuddyAdapter)
+					{
+						//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() mac 0 for mac 0 \n"));
+						PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+					}
+				}
+			}
+			else
+			{
+				//ODM_RT_TRACE(pDM_Odm,COMP_MLME,DBG_LOUD,("dm_DynamicTxPower() BuddyAdapter DMDP\n"));
+				PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+			}
+		}
+#else
+		PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+#endif
+	}
+	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
+#endif	
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicTxPower.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicTxPower.h
new file mode 100644
index 000000000000..508cd31277d3
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_DynamicTxPower.h
@@ -0,0 +1,89 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMDYNAMICTXPOWER_H__
+#define    __PHYDMDYNAMICTXPOWER_H__
+
+#define DYNAMIC_TXPWR_VERSION	"1.0"
+
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL2	74
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL1	67
+#define		TX_POWER_NEAR_FIELD_THRESH_AP		0x3F
+#define		TX_POWER_NEAR_FIELD_THRESH_8812	60
+
+#define		TxHighPwrLevel_Normal		0	
+#define		TxHighPwrLevel_Level1		1
+#define		TxHighPwrLevel_Level2		2
+#define		TxHighPwrLevel_BT1			3
+#define		TxHighPwrLevel_BT2			4
+#define		TxHighPwrLevel_15			5
+#define		TxHighPwrLevel_35			6
+#define		TxHighPwrLevel_50			7
+#define		TxHighPwrLevel_70			8
+#define		TxHighPwrLevel_100			9
+
+VOID 
+odm_DynamicTxPowerInit(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_DynamicTxPowerRestorePowerIndex(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_DynamicTxPowerNIC(
+	IN		PVOID					pDM_VOID
+	);
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+VOID
+odm_DynamicTxPowerSavePowerIndex(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID
+odm_DynamicTxPowerWritePowerIndex(
+	IN		PVOID					pDM_VOID, 
+	IN 	u1Byte		Value);
+
+VOID 
+odm_DynamicTxPower_92C(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_DynamicTxPower_92D(
+	IN		PVOID					pDM_VOID
+	);
+#endif
+
+VOID 
+odm_DynamicTxPower(
+	IN		PVOID					pDM_VOID
+	);
+
+VOID 
+odm_DynamicTxPowerAP(
+	IN		PVOID					pDM_VOID
+	);
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_EdcaTurboCheck.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_EdcaTurboCheck.c
new file mode 100644
index 000000000000..479300050b4d
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_EdcaTurboCheck.c
@@ -0,0 +1,1915 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+VOID
+ODM_EdcaTurboInit(
+	IN 	PVOID	 	pDM_VOID)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if ((DM_ODM_SUPPORT_TYPE == ODM_AP)||(DM_ODM_SUPPORT_TYPE==ODM_ADSL))
+	odm_EdcaParaInit(pDM_Odm);
+#elif (DM_ODM_SUPPORT_TYPE==ODM_WIN)
+	PADAPTER	Adapter = NULL;
+	HAL_DATA_TYPE	*pHalData = NULL;
+
+	if(pDM_Odm->Adapter==NULL)	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("EdcaTurboInit fail!!!\n"));
+		return;
+	}
+
+	Adapter=pDM_Odm->Adapter;
+	pHalData=GET_HAL_DATA(Adapter);
+
+	pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = FALSE;	
+	pDM_Odm->DM_EDCA_Table.bIsCurRDLState = FALSE;
+	pHalData->bIsAnyNonBEPkts = FALSE;
+	
+#elif(DM_ODM_SUPPORT_TYPE==ODM_CE)
+	PADAPTER	Adapter = pDM_Odm->Adapter;	
+	pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = FALSE;	
+	pDM_Odm->DM_EDCA_Table.bIsCurRDLState = FALSE;
+	Adapter->recvpriv.bIsAnyNonBEPkts =FALSE;
+
+#endif	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VO PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_VO_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial VI PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_VI_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BE PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BE_PARAM)));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BK PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BK_PARAM)));
+
+	
+}	// ODM_InitEdcaTurbo
+
+VOID
+odm_EdcaTurboCheck(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	// 
+	// For AP/ADSL use prtl8192cd_priv
+	// For CE/NIC use PADAPTER
+	//
+
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("odm_EdcaTurboCheck========================>\n"));
+	
+	if(!(pDM_Odm->SupportAbility& ODM_MAC_EDCA_TURBO ))
+		return;
+
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
+			odm_EdcaTurboCheckMP(pDM_Odm);
+#endif
+			break;
+
+		case	ODM_CE:
+#if(DM_ODM_SUPPORT_TYPE==ODM_CE)
+			odm_EdcaTurboCheckCE(pDM_Odm);
+#endif
+			break;
+
+		case	ODM_AP:
+		case	ODM_ADSL:
+
+#if ((DM_ODM_SUPPORT_TYPE == ODM_AP)||(DM_ODM_SUPPORT_TYPE==ODM_ADSL))
+		odm_IotEngine(pDM_Odm);
+#endif
+			break;	
+	}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("<========================odm_EdcaTurboCheck\n"));
+
+}	// odm_CheckEdcaTurbo
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_CE)
+
+
+VOID
+odm_EdcaTurboCheckCE(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		       Adapter = pDM_Odm->Adapter;
+	u32	EDCA_BE_UL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_UL[pMgntInfo->IOTPeer];
+	u32	EDCA_BE_DL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_DL[pMgntInfo->IOTPeer];
+	u32	ICType=pDM_Odm->SupportICType;
+	u32	IOTPeer=0;
+	u8	WirelessMode=0xFF;                   //invalid value
+	u32 	trafficIndex;
+	u32	edca_param;
+	u64	cur_tx_bytes = 0;
+	u64	cur_rx_bytes = 0;
+	u8	bbtchange = _FALSE;
+	u8	bBiasOnRx = _FALSE;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	struct dvobj_priv		*pdvobjpriv = adapter_to_dvobj(Adapter);
+	struct xmit_priv		*pxmitpriv = &(Adapter->xmitpriv);
+	struct recv_priv		*precvpriv = &(Adapter->recvpriv);
+	struct registry_priv	*pregpriv = &Adapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &(Adapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if(pDM_Odm->bLinked != _TRUE)
+	{
+		precvpriv->bIsAnyNonBEPkts = _FALSE;
+		return;
+	}
+
+	if ((pregpriv->wifi_spec == 1) )//|| (pmlmeinfo->HT_enable == 0))
+	{
+		precvpriv->bIsAnyNonBEPkts = _FALSE;
+		return;
+	}
+
+	if(pDM_Odm->pWirelessMode!=NULL)
+		WirelessMode=*(pDM_Odm->pWirelessMode);
+
+	IOTPeer = pmlmeinfo->assoc_AP_vendor;
+
+	if (IOTPeer >=  HT_IOT_PEER_MAX)
+	{
+		precvpriv->bIsAnyNonBEPkts = _FALSE;
+		return;
+	}
+
+	if(	(pDM_Odm->SupportICType == ODM_RTL8192C) ||
+		(pDM_Odm->SupportICType == ODM_RTL8723A) ||
+		(pDM_Odm->SupportICType == ODM_RTL8188E))
+	{
+		if((IOTPeer == HT_IOT_PEER_RALINK)||(IOTPeer == HT_IOT_PEER_ATHEROS))
+			bBiasOnRx = _TRUE;
+	}
+
+	// Check if the status needs to be changed.
+	if((bbtchange) || (!precvpriv->bIsAnyNonBEPkts) )
+	{
+		cur_tx_bytes = pdvobjpriv->traffic_stat.cur_tx_bytes;
+		cur_rx_bytes = pdvobjpriv->traffic_stat.cur_rx_bytes;
+
+		//traffic, TX or RX
+		if(bBiasOnRx)
+		{
+			if (cur_tx_bytes > (cur_rx_bytes << 2))
+			{ // Uplink TP is present.
+				trafficIndex = UP_LINK; 
+			}
+			else
+			{ // Balance TP is present.
+				trafficIndex = DOWN_LINK;
+			}
+		}
+		else
+		{
+			if (cur_rx_bytes > (cur_tx_bytes << 2))
+			{ // Downlink TP is present.
+				trafficIndex = DOWN_LINK;
+			}
+			else
+			{ // Balance TP is present.
+				trafficIndex = UP_LINK;
+			}
+		}
+
+		//if ((pDM_Odm->DM_EDCA_Table.prv_traffic_idx != trafficIndex) || (!pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA))
+		{
+			if(ICType==ODM_RTL8192D)
+			{      
+				// Single PHY
+				if(pDM_Odm->RFType==ODM_2T2R)
+				{
+					EDCA_BE_UL = 0x60a42b;    //0x5ea42b;
+					EDCA_BE_DL = 0x60a42b;    //0x5ea42b;
+				}
+				else
+				{
+					EDCA_BE_UL = 0x6ea42b;
+					EDCA_BE_DL = 0x6ea42b;
+				}
+			}
+			else
+			{
+				if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE) {
+					if((ICType==ODM_RTL8192C)&&(pDM_Odm->RFType==ODM_2T2R)) {
+						EDCA_BE_UL = 0x60a42b;
+						EDCA_BE_DL = 0x60a42b;
+					}
+					else
+					{
+						EDCA_BE_UL = 0x6ea42b;
+						EDCA_BE_DL = 0x6ea42b;
+					}
+				}
+			}
+		
+			//92D txop can't be set to 0x3e for cisco1250
+			if((ICType!=ODM_RTL8192D) && (IOTPeer== HT_IOT_PEER_CISCO) &&(WirelessMode==ODM_WM_N24G))
+			{
+				EDCA_BE_DL = edca_setting_DL[IOTPeer];
+				EDCA_BE_UL = edca_setting_UL[IOTPeer];
+			}
+			//merge from 92s_92c_merge temp brunch v2445    20120215 
+			else if((IOTPeer == HT_IOT_PEER_CISCO) &&((WirelessMode==ODM_WM_G)||(WirelessMode==(ODM_WM_B|ODM_WM_G))||(WirelessMode==ODM_WM_A)||(WirelessMode==ODM_WM_B)))
+			{
+				EDCA_BE_DL = edca_setting_DL_GMode[IOTPeer];
+			}
+			else if((IOTPeer== HT_IOT_PEER_AIRGO )&& ((WirelessMode==ODM_WM_G)||(WirelessMode==ODM_WM_A)))
+			{
+				EDCA_BE_DL = 0xa630;
+			}
+			else if(IOTPeer == HT_IOT_PEER_MARVELL)
+			{
+				EDCA_BE_DL = edca_setting_DL[IOTPeer];
+				EDCA_BE_UL = edca_setting_UL[IOTPeer];
+			}
+			else if(IOTPeer == HT_IOT_PEER_ATHEROS)
+			{
+				// Set DL EDCA for Atheros peer to 0x3ea42b. Suggested by SD3 Wilson for ASUS TP issue. 
+				EDCA_BE_DL = edca_setting_DL[IOTPeer];
+			}
+
+			if((ICType==ODM_RTL8812)||(ICType==ODM_RTL8821)||(ICType==ODM_RTL8192E))           //add 8812AU/8812AE
+			{
+				EDCA_BE_UL = 0x5ea42b;
+				EDCA_BE_DL = 0x5ea42b;
+
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("8812A: EDCA_BE_UL=0x%x EDCA_BE_DL =0x%x",EDCA_BE_UL,EDCA_BE_DL));
+			}
+
+			if (trafficIndex == DOWN_LINK)
+				edca_param = EDCA_BE_DL;
+			else
+				edca_param = EDCA_BE_UL;
+
+			rtw_write32(Adapter, REG_EDCA_BE_PARAM, edca_param);
+
+			pDM_Odm->DM_EDCA_Table.prv_traffic_idx = trafficIndex;
+		}
+		
+		pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = _TRUE;
+	}
+	else
+	{
+		//
+		// Turn Off EDCA turbo here.
+		// Restore original EDCA according to the declaration of AP.
+		//
+		 if(pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA)
+		{
+			rtw_write32(Adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
+			pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = _FALSE;
+		}
+	}
+
+}
+
+
+#elif(DM_ODM_SUPPORT_TYPE==ODM_WIN)
+VOID
+odm_EdcaTurboCheckMP(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		       Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+
+	PADAPTER 			pDefaultAdapter = GetDefaultAdapter(Adapter);
+	PADAPTER 			pExtAdapter = GetFirstExtAdapter(Adapter);//NULL;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	PSTA_QOS			pStaQos = Adapter->MgntInfo.pStaQos;
+	//[Win7 Count Tx/Rx statistic for Extension Port] odm_CheckEdcaTurbo's Adapter is always Default. 2009.08.20, by Bohn
+	u8Byte				Ext_curTxOkCnt = 0;
+	u8Byte				Ext_curRxOkCnt = 0;	
+	//For future Win7  Enable Default Port to modify AMPDU size dynamically, 2009.08.20, Bohn.	
+	u1Byte TwoPortStatus = (u1Byte)TWO_PORT_STATUS__WITHOUT_ANY_ASSOCIATE;
+
+	// Keep past Tx/Rx packet count for RT-to-RT EDCA turbo.
+	u8Byte				curTxOkCnt = 0;
+	u8Byte				curRxOkCnt = 0;	
+	u4Byte				EDCA_BE_UL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_UL[pMgntInfo->IOTPeer];
+	u4Byte				EDCA_BE_DL = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_DL[pMgntInfo->IOTPeer];
+	u4Byte                         EDCA_BE = 0x5ea42b;
+	u1Byte                         IOTPeer=0;
+	BOOLEAN                      *pbIsCurRDLState=NULL;
+	BOOLEAN                      bLastIsCurRDLState=FALSE;
+	BOOLEAN				 bBiasOnRx=FALSE;
+	BOOLEAN				bEdcaTurboOn=FALSE;
+	u1Byte				TxRate = 0xFF;
+	u8Byte				value64;	
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("odm_EdcaTurboCheckMP========================>"));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Orginial BE PARAM: 0x%x\n",ODM_Read4Byte(pDM_Odm,ODM_EDCA_BE_PARAM)));
+
+////===============================
+////list paramter for different platform
+////===============================
+	bLastIsCurRDLState=pDM_Odm->DM_EDCA_Table.bIsCurRDLState;
+	pbIsCurRDLState=&(pDM_Odm->DM_EDCA_Table.bIsCurRDLState);	
+
+	//2012/09/14 MH Add 
+	if (pMgntInfo->NumNonBePkt > pMgntInfo->RegEdcaThresh && !Adapter->MgntInfo.bWiFiConfg)
+		pHalData->bIsAnyNonBEPkts = TRUE;
+
+	pMgntInfo->NumNonBePkt = 0;
+
+       // Caculate TX/RX TP:
+	//curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - pMgntInfo->lastTxOkCnt;
+	//curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - pMgntInfo->lastRxOkCnt;
+	curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - pDM_Odm->lastTxOkCnt;
+	curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - pDM_Odm->lastRxOkCnt;
+	pDM_Odm->lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
+	pDM_Odm->lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
+
+	if(pExtAdapter == NULL) 
+		pExtAdapter = pDefaultAdapter;
+
+	Ext_curTxOkCnt = pExtAdapter->TxStats.NumTxBytesUnicast - pMgntInfo->Ext_lastTxOkCnt;
+	Ext_curRxOkCnt = pExtAdapter->RxStats.NumRxBytesUnicast - pMgntInfo->Ext_lastRxOkCnt;
+	GetTwoPortSharedResource(Adapter,TWO_PORT_SHARED_OBJECT__STATUS,NULL,&TwoPortStatus);
+	//For future Win7  Enable Default Port to modify AMPDU size dynamically, 2009.08.20, Bohn.
+	if(TwoPortStatus == TWO_PORT_STATUS__EXTENSION_ONLY)
+	{
+		curTxOkCnt = Ext_curTxOkCnt ;
+		curRxOkCnt = Ext_curRxOkCnt ;
+	}
+	//
+	IOTPeer=pMgntInfo->IOTPeer;
+	bBiasOnRx=(pMgntInfo->IOTAction & HT_IOT_ACT_EDCA_BIAS_ON_RX)?TRUE:FALSE;
+	bEdcaTurboOn=((!pHalData->bIsAnyNonBEPkts))?TRUE:FALSE;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("bIsAnyNonBEPkts : 0x%lx  \n",pHalData->bIsAnyNonBEPkts));
+
+
+////===============================
+////check if edca turbo is disabled
+////===============================
+	if(odm_IsEdcaTurboDisable(pDM_Odm))
+	{
+		pHalData->bIsAnyNonBEPkts = FALSE;
+		pMgntInfo->lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
+		pMgntInfo->lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
+		pMgntInfo->Ext_lastTxOkCnt = pExtAdapter->TxStats.NumTxBytesUnicast;
+		pMgntInfo->Ext_lastRxOkCnt = pExtAdapter->RxStats.NumRxBytesUnicast;
+
+	}
+
+////===============================
+////remove iot case out
+////===============================
+	ODM_EdcaParaSelByIot(pDM_Odm, &EDCA_BE_UL, &EDCA_BE_DL);
+
+
+////===============================
+////Check if the status needs to be changed.
+////===============================
+	if(bEdcaTurboOn)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("bEdcaTurboOn : 0x%x bBiasOnRx : 0x%x\n",bEdcaTurboOn,bBiasOnRx));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("curTxOkCnt : 0x%lx \n",curTxOkCnt));
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("curRxOkCnt : 0x%lx \n",curRxOkCnt));
+		if(bBiasOnRx)
+			odm_EdcaChooseTrafficIdx(pDM_Odm,curTxOkCnt, curRxOkCnt,   TRUE,  pbIsCurRDLState);
+		else
+			odm_EdcaChooseTrafficIdx(pDM_Odm,curTxOkCnt, curRxOkCnt,   FALSE,  pbIsCurRDLState);
+
+//modify by Guo.Mingzhi 2011-12-29
+			EDCA_BE=((*pbIsCurRDLState)==TRUE)?EDCA_BE_DL:EDCA_BE_UL;
+			if(IS_HARDWARE_TYPE_8821U(Adapter))
+			{
+				if(pMgntInfo->RegTxDutyEnable)
+				{
+					//2013.01.23 LukeLee: debug for 8811AU thermal issue (reduce Tx duty cycle)
+					if(!pMgntInfo->ForcedDataRate) //auto rate
+					{
+						if(pDM_Odm->TxRate != 0xFF)
+							TxRate = Adapter->HalFunc.GetHwRateFromMRateHandler(pDM_Odm->TxRate); 
+					}
+					else //force rate
+					{
+						TxRate = (u1Byte) pMgntInfo->ForcedDataRate;
+					}
+
+					value64 = (curRxOkCnt<<2);
+					if(curTxOkCnt < value64) //Downlink
+						ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+					else //Uplink
+					{
+						//DbgPrint("pDM_Odm->RFCalibrateInfo.ThermalValue = 0x%X\n", pDM_Odm->RFCalibrateInfo.ThermalValue);
+						//if(pDM_Odm->RFCalibrateInfo.ThermalValue < pHalData->EEPROMThermalMeter)
+						if((pDM_Odm->RFCalibrateInfo.ThermalValue < 0x2c) || (*pDM_Odm->pBandType == BAND_ON_2_4G))
+							ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+						else
+						{
+							switch (TxRate)
+							{
+								case MGN_VHT1SS_MCS6:
+								case MGN_VHT1SS_MCS5:
+								case MGN_MCS6:
+								case MGN_MCS5:
+								case MGN_48M:
+								case MGN_54M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0x1ea42b);
+								break;
+								case MGN_VHT1SS_MCS4:
+								case MGN_MCS4:
+								case MGN_36M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa42b);
+								break;
+								case MGN_VHT1SS_MCS3:
+								case MGN_MCS3:
+								case MGN_24M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa47f);
+								break;
+								case MGN_VHT1SS_MCS2:
+								case MGN_MCS2:
+								case MGN_18M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa57f);
+								break;
+								case MGN_VHT1SS_MCS1:
+								case MGN_MCS1:
+								case MGN_9M:
+								case MGN_12M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa77f);
+								break;
+								case MGN_VHT1SS_MCS0:
+								case MGN_MCS0:
+								case MGN_6M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa87f);
+								break;
+								default:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+								break;
+							}
+						}
+					}				
+				}
+				else
+				{
+					ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+				}
+
+			}
+			else if (IS_HARDWARE_TYPE_8812AU(Adapter)){
+				if(pMgntInfo->RegTxDutyEnable)
+				{
+					//2013.07.26 Wilson: debug for 8812AU thermal issue (reduce Tx duty cycle)
+					// it;s the same issue as 8811AU
+					if(!pMgntInfo->ForcedDataRate) //auto rate
+					{
+						if(pDM_Odm->TxRate != 0xFF)
+							TxRate = Adapter->HalFunc.GetHwRateFromMRateHandler(pDM_Odm->TxRate); 
+					}
+					else //force rate
+					{
+						TxRate = (u1Byte) pMgntInfo->ForcedDataRate;
+					}
+
+					value64 = (curRxOkCnt<<2);
+					if(curTxOkCnt < value64) //Downlink
+						ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+					else //Uplink
+					{
+						//DbgPrint("pDM_Odm->RFCalibrateInfo.ThermalValue = 0x%X\n", pDM_Odm->RFCalibrateInfo.ThermalValue);
+						//if(pDM_Odm->RFCalibrateInfo.ThermalValue < pHalData->EEPROMThermalMeter)
+						if((pDM_Odm->RFCalibrateInfo.ThermalValue < 0x2c) || (*pDM_Odm->pBandType == BAND_ON_2_4G))
+							ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+						else
+						{
+							switch (TxRate)
+							{
+								case MGN_VHT2SS_MCS9:
+								case MGN_VHT1SS_MCS9:									
+								case MGN_VHT1SS_MCS8:
+								case MGN_MCS15:
+								case MGN_MCS7:									
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0x1ea44f);							
+								case MGN_VHT2SS_MCS8:
+								case MGN_VHT1SS_MCS7:
+								case MGN_MCS14:
+								case MGN_MCS6:
+								case MGN_54M:									
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa44f);
+								case MGN_VHT2SS_MCS7:
+								case MGN_VHT2SS_MCS6:
+								case MGN_VHT1SS_MCS6:
+								case MGN_VHT1SS_MCS5:
+								case MGN_MCS13:
+								case MGN_MCS5:
+								case MGN_48M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa630);
+								break;
+								case MGN_VHT2SS_MCS5:
+								case MGN_VHT2SS_MCS4:
+								case MGN_VHT1SS_MCS4:
+								case MGN_VHT1SS_MCS3:	
+								case MGN_MCS12:
+								case MGN_MCS4:	
+								case MGN_MCS3:	
+								case MGN_36M:
+								case MGN_24M:	
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa730);
+								break;
+								case MGN_VHT2SS_MCS3:
+								case MGN_VHT2SS_MCS2:
+								case MGN_VHT2SS_MCS1:
+								case MGN_VHT1SS_MCS2:
+								case MGN_VHT1SS_MCS1:	
+								case MGN_MCS11:	
+								case MGN_MCS10:	
+								case MGN_MCS9:		
+								case MGN_MCS2:	
+								case MGN_MCS1:
+								case MGN_18M:	
+								case MGN_12M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa830);
+								break;
+								case MGN_VHT2SS_MCS0:
+								case MGN_VHT1SS_MCS0:
+								case MGN_MCS0:	
+								case MGN_MCS8:
+								case MGN_9M:	
+								case MGN_6M:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,0xa87f);
+								break;
+								default:
+									ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+								break;
+							}
+						}
+					}				
+				}
+				else
+				{
+					ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+				}
+			}
+			else
+				ODM_Write4Byte(pDM_Odm,ODM_EDCA_BE_PARAM,EDCA_BE);
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("EDCA Turbo on: EDCA_BE:0x%lx\n",EDCA_BE));
+
+		pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = TRUE;
+		
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("EDCA_BE_DL : 0x%lx  EDCA_BE_UL : 0x%lx  EDCA_BE : 0x%lx  \n",EDCA_BE_DL,EDCA_BE_UL,EDCA_BE));
+
+	}
+	else
+	{
+		// Turn Off EDCA turbo here.
+		// Restore original EDCA according to the declaration of AP.
+		 if(pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA)
+		{
+			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_AC_PARAM, GET_WMM_PARAM_ELE_SINGLE_AC_PARAM(pStaQos->WMMParamEle, AC0_BE) );
+
+			pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = FALSE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Restore EDCA BE: 0x%lx  \n",pDM_Odm->WMMEDCA_BE));
+
+		}
+	}
+
+}
+
+
+//check if edca turbo is disabled
+BOOLEAN
+odm_IsEdcaTurboDisable(
+	IN 	PVOID	 	pDM_VOID
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		       Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	u4Byte				IOTPeer=pMgntInfo->IOTPeer;
+
+	if(pDM_Odm->bBtDisableEdcaTurbo)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("EdcaTurboDisable for BT!!\n"));
+		return TRUE;
+	}
+
+	if((!(pDM_Odm->SupportAbility& ODM_MAC_EDCA_TURBO ))||
+		(pDM_Odm->bWIFITest)||
+		(IOTPeer>= HT_IOT_PEER_MAX))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("EdcaTurboDisable\n"));
+		return TRUE;
+	}
+
+
+	// 1. We do not turn on EDCA turbo mode for some AP that has IOT issue
+	// 2. User may disable EDCA Turbo mode with OID settings.
+	if(pMgntInfo->IOTAction & HT_IOT_ACT_DISABLE_EDCA_TURBO){
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD, ("IOTAction:EdcaTurboDisable\n"));
+		return	TRUE;
+		}
+		
+	return	FALSE;
+	
+
+}
+
+//add iot case here: for MP/CE
+VOID 
+ODM_EdcaParaSelByIot(
+	IN 	PVOID	 	pDM_VOID,
+	OUT	u4Byte		*EDCA_BE_UL,
+	OUT u4Byte		*EDCA_BE_DL
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		       Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	u4Byte                         IOTPeer=0;
+	u4Byte                         ICType=pDM_Odm->SupportICType;
+	u1Byte                         WirelessMode=0xFF;                   //invalid value
+	u4Byte				RFType=pDM_Odm->RFType;
+	  u4Byte                         IOTPeerSubType=0;
+
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+	u1Byte 				TwoPortStatus = (u1Byte)TWO_PORT_STATUS__WITHOUT_ANY_ASSOCIATE;
+
+	if(pDM_Odm->pWirelessMode!=NULL)
+		WirelessMode=*(pDM_Odm->pWirelessMode);
+		
+///////////////////////////////////////////////////////////
+////list paramter for different platform
+
+	IOTPeer=pMgntInfo->IOTPeer;
+	IOTPeerSubType=pMgntInfo->IOTPeerSubtype;
+	GetTwoPortSharedResource(Adapter,TWO_PORT_SHARED_OBJECT__STATUS,NULL,&TwoPortStatus);
+
+
+	if(ICType==ODM_RTL8192D)
+	{      
+		// Single PHY
+		if(pDM_Odm->RFType==ODM_2T2R)
+		{
+			(*EDCA_BE_UL) = 0x60a42b;    //0x5ea42b;
+			(*EDCA_BE_DL) = 0x60a42b;    //0x5ea42b;
+
+		}
+		else
+		{
+			(*EDCA_BE_UL) = 0x6ea42b;
+			(*EDCA_BE_DL) = 0x6ea42b;
+		}
+
+	}
+////============================
+/// IOT case for MP
+////============================	
+
+	else
+	{
+
+		if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE){
+			if((ICType==ODM_RTL8192C)&&(pDM_Odm->RFType==ODM_2T2R))			{
+				(*EDCA_BE_UL) = 0x60a42b;
+				(*EDCA_BE_DL) = 0x60a42b;
+			}
+			else
+			{
+				(*EDCA_BE_UL) = 0x6ea42b;
+				(*EDCA_BE_DL) = 0x6ea42b;
+			}
+		}
+	}
+ 
+	if(TwoPortStatus == TWO_PORT_STATUS__EXTENSION_ONLY)
+	{
+		(*EDCA_BE_UL) = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_UL[ExtAdapter->MgntInfo.IOTPeer];
+		(*EDCA_BE_DL) = 0x5ea42b;//Parameter suggested by Scott  //edca_setting_DL[ExtAdapter->MgntInfo.IOTPeer];
+	}
+     
+	#if (INTEL_PROXIMITY_SUPPORT == 1)
+	if(pMgntInfo->IntelClassModeInfo.bEnableCA == TRUE)
+	{
+		(*EDCA_BE_UL) = (*EDCA_BE_DL) = 0xa44f;
+	}
+	else
+	#endif		
+	{
+		if((pMgntInfo->IOTAction & (HT_IOT_ACT_FORCED_ENABLE_BE_TXOP|HT_IOT_ACT_AMSDU_ENABLE)))
+		{// To check whether we shall force turn on TXOP configuration.
+			if(!((*EDCA_BE_UL) & 0xffff0000))
+				(*EDCA_BE_UL) |= 0x005e0000; // Force TxOP limit to 0x005e for UL.
+			if(!((*EDCA_BE_DL) & 0xffff0000))
+				(*EDCA_BE_DL) |= 0x005e0000; // Force TxOP limit to 0x005e for DL.
+		}
+		
+		//92D txop can't be set to 0x3e for cisco1250
+		if((ICType!=ODM_RTL8192D) && (IOTPeer== HT_IOT_PEER_CISCO) &&(WirelessMode==ODM_WM_N24G))
+		{
+			(*EDCA_BE_DL) = edca_setting_DL[IOTPeer];
+			(*EDCA_BE_UL) = edca_setting_UL[IOTPeer];
+		}
+		//merge from 92s_92c_merge temp brunch v2445    20120215 
+		else if((IOTPeer == HT_IOT_PEER_CISCO) &&((WirelessMode==ODM_WM_G)||(WirelessMode==(ODM_WM_B|ODM_WM_G))||(WirelessMode==ODM_WM_A)||(WirelessMode==ODM_WM_B)))
+		{
+			(*EDCA_BE_DL) = edca_setting_DL_GMode[IOTPeer];
+		}
+		else if((IOTPeer== HT_IOT_PEER_AIRGO )&& ((WirelessMode==ODM_WM_G)||(WirelessMode==ODM_WM_A)))
+		{
+			(*EDCA_BE_DL) = 0xa630;
+		}
+
+		else if(IOTPeer == HT_IOT_PEER_MARVELL)
+		{
+			(*EDCA_BE_DL) = edca_setting_DL[IOTPeer];
+			(*EDCA_BE_UL) = edca_setting_UL[IOTPeer];
+		}
+		else if(IOTPeer == HT_IOT_PEER_ATHEROS)
+		{
+			// Set DL EDCA for Atheros peer to 0x3ea42b. Suggested by SD3 Wilson for ASUS TP issue. 
+			if(WirelessMode==ODM_WM_G)
+				(*EDCA_BE_DL) = edca_setting_DL_GMode[IOTPeer];
+			else
+			(*EDCA_BE_DL) = edca_setting_DL[IOTPeer];
+			
+			if(ICType == ODM_RTL8821)
+				 (*EDCA_BE_DL) = 0x5ea630;
+			
+		}
+	}
+
+    	if((ICType == ODM_RTL8192D)&&(IOTPeerSubType == HT_IOT_PEER_LINKSYS_E4200_V1)&&((WirelessMode==ODM_WM_N5G)))
+	{
+		(*EDCA_BE_DL) = 0x432b;
+		(*EDCA_BE_UL) = 0x432b;
+	}		
+
+
+
+	if((ICType==ODM_RTL8812)||(ICType==ODM_RTL8192E))           //add 8812AU/8812AE
+	{
+		(*EDCA_BE_UL) = 0x5ea42b;
+		(*EDCA_BE_DL) = 0x5ea42b;
+
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("8812A: EDCA_BE_UL=0x%lx EDCA_BE_DL =0x%lx",(*EDCA_BE_UL),(*EDCA_BE_DL)));
+	}
+
+	// Revised for Atheros DIR-655 IOT issue to improve down link TP, added by Roger, 2013.03.22.
+	if((ICType == ODM_RTL8723A) && (IOTPeerSubType== HT_IOT_PEER_ATHEROS_DIR655) && 
+		(pMgntInfo->dot11CurrentChannelNumber == 6))
+	{
+		(*EDCA_BE_DL) = 0xa92b;
+	}
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Special: EDCA_BE_UL=0x%lx EDCA_BE_DL =0x%lx",(*EDCA_BE_UL),(*EDCA_BE_DL)));
+
+}
+
+
+VOID
+odm_EdcaChooseTrafficIdx( 
+	IN 	PVOID	 	pDM_VOID,
+	IN	u8Byte  			cur_tx_bytes,  
+	IN	u8Byte  			cur_rx_bytes, 
+	IN	BOOLEAN 		bBiasOnRx,
+	OUT BOOLEAN 		*pbIsCurRDLState
+	)
+{	
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	
+	if(bBiasOnRx)
+	{
+	  
+		if(cur_tx_bytes>(cur_rx_bytes*4))
+		{
+			*pbIsCurRDLState=FALSE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Uplink Traffic\n "));
+
+		}
+		else
+		{
+			*pbIsCurRDLState=TRUE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Balance Traffic\n"));
+
+		}
+	}
+	else
+	{
+		if(cur_rx_bytes>(cur_tx_bytes*4))
+		{
+			*pbIsCurRDLState=TRUE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Downlink	Traffic\n"));
+
+		}
+		else
+		{
+			*pbIsCurRDLState=FALSE;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_EDCA_TURBO,ODM_DBG_LOUD,("Balance Traffic\n"));
+		}
+	}
+
+	return ;
+}
+
+#endif
+
+#if((DM_ODM_SUPPORT_TYPE==ODM_AP)||(DM_ODM_SUPPORT_TYPE==ODM_ADSL))
+
+void odm_EdcaParaInit(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	prtl8192cd_priv	priv		= pDM_Odm->priv;
+	int   mode=priv->pmib->dot11BssType.net_work_type;
+	
+	static unsigned int slot_time, sifs_time;
+	struct ParaRecord EDCA[4];
+
+	 memset(EDCA, 0, 4*sizeof(struct ParaRecord));
+
+	sifs_time = 10;
+	slot_time = 20;
+
+	if (mode & (ODM_WM_N24G|ODM_WM_N5G))
+		sifs_time = 16;
+
+	if (mode & (ODM_WM_N24G|ODM_WM_N5G| ODM_WM_G|ODM_WM_A))
+		slot_time = 9;
+
+
+#ifdef RTK_AC_SUPPORT //for 11ac logo,  edit aifs time for cca test cases
+	if(AC_SIGMA_MODE != AC_SIGMA_NONE)
+		sifs_time = 10;	
+#endif
+
+
+#if((defined(RTL_MANUAL_EDCA))&&(DM_ODM_SUPPORT_TYPE==ODM_AP))
+	 if( priv->pmib->dot11QosEntry.ManualEDCA ) {
+		 if( OPMODE & WIFI_AP_STATE )
+			 memcpy(EDCA, priv->pmib->dot11QosEntry.AP_manualEDCA, 4*sizeof(struct ParaRecord));
+		 else
+			 memcpy(EDCA, priv->pmib->dot11QosEntry.STA_manualEDCA, 4*sizeof(struct ParaRecord));
+
+		#ifdef WIFI_WMM
+		if (QOS_ENABLE)
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, (EDCA[VI].TXOPlimit<< 16) | (EDCA[VI].ECWmax<< 12) | (EDCA[VI].ECWmin<< 8) | (sifs_time + EDCA[VI].AIFSN* slot_time));
+		else
+		#endif
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, (EDCA[BE].TXOPlimit<< 16) | (EDCA[BE].ECWmax<< 12) | (EDCA[BE].ECWmin<< 8) | (sifs_time + EDCA[VI].AIFSN* slot_time));
+
+	}else
+	#endif //RTL_MANUAL_EDCA
+	{
+
+		 if(OPMODE & WIFI_AP_STATE)
+		 {
+		 	memcpy(EDCA, rtl_ap_EDCA, 2*sizeof(struct ParaRecord));
+
+			if(mode & (ODM_WM_A|ODM_WM_G|ODM_WM_N24G|ODM_WM_N5G))
+				memcpy(&EDCA[VI], &rtl_ap_EDCA[VI_AG], 2*sizeof(struct ParaRecord));
+			else
+				memcpy(&EDCA[VI], &rtl_ap_EDCA[VI], 2*sizeof(struct ParaRecord));
+		 }
+		 else
+		 {
+		 	memcpy(EDCA, rtl_sta_EDCA, 2*sizeof(struct ParaRecord));
+
+			if(mode & (ODM_WM_A|ODM_WM_G|ODM_WM_N24G|ODM_WM_N5G))
+				memcpy(&EDCA[VI], &rtl_sta_EDCA[VI_AG], 2*sizeof(struct ParaRecord));
+			else
+				memcpy(&EDCA[VI], &rtl_sta_EDCA[VI], 2*sizeof(struct ParaRecord));
+		 }
+		 
+	#ifdef WIFI_WMM
+		if (QOS_ENABLE)
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, (EDCA[VI].TXOPlimit<< 16) | (EDCA[VI].ECWmax<< 12) | (EDCA[VI].ECWmin<< 8) | (sifs_time + EDCA[VI].AIFSN* slot_time));
+		else
+	#endif
+
+#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM,  (EDCA[BK].ECWmax<< 12) | (EDCA[BK].ECWmin<< 8) | (sifs_time + EDCA[VI].AIFSN* slot_time));
+#elif(DM_ODM_SUPPORT_TYPE==ODM_ADSL)
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM,  (EDCA[BK].ECWmax<< 12) | (EDCA[BK].ECWmin<< 8) | (sifs_time + 2* slot_time));
+#endif
+			
+
+	}
+
+	ODM_Write4Byte(pDM_Odm, ODM_EDCA_VO_PARAM, (EDCA[VO].TXOPlimit<< 16) | (EDCA[VO].ECWmax<< 12) | (EDCA[VO].ECWmin<< 8) | (sifs_time + EDCA[VO].AIFSN* slot_time));
+	ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM,  (EDCA[BE].TXOPlimit<< 16) | (EDCA[BE].ECWmax<< 12) | (EDCA[BE].ECWmin<< 8) | (sifs_time + EDCA[BE].AIFSN* slot_time));
+	ODM_Write4Byte(pDM_Odm, ODM_EDCA_BK_PARAM, (EDCA[BK].TXOPlimit<< 16) | (EDCA[BK].ECWmax<< 12) | (EDCA[BK].ECWmin<< 8) | (sifs_time + EDCA[BK].AIFSN* slot_time));
+
+#if defined(RTK_AC_SUPPORT) && defined(RTL_MANUAL_EDCA) //for 11ac logo,  make BK worse to seperate with BE.
+	if((AC_SIGMA_MODE != AC_SIGMA_NONE) && (priv->pmib->dot11QosEntry.ManualEDCA))
+	{
+		ODM_Write4Byte(pDM_Odm, ODM_EDCA_BK_PARAM, (EDCA[BK].TXOPlimit<< 16) | (EDCA[BK].ECWmax<< 12) | (EDCA[BK].ECWmin<< 8) | 0xa4 );
+	}
+#endif
+
+//	ODM_Write1Byte(pDM_Odm,ACMHWCTRL, 0x00);
+
+	priv->pshare->iot_mode_enable = 0;
+#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
+	if (priv->pshare->rf_ft_var.wifi_beq_iot)
+		priv->pshare->iot_mode_VI_exist = 0;
+	
+	#ifdef WMM_VIBE_PRI
+	priv->pshare->iot_mode_BE_exist = 0;
+	#endif
+	
+#ifdef WMM_BEBK_PRI
+	priv->pshare->iot_mode_BK_exist = 0;
+#endif
+	
+	#ifdef LOW_TP_TXOP
+	priv->pshare->BE_cwmax_enhance = 0;
+	#endif
+
+#elif (DM_ODM_SUPPORT_TYPE==ODM_ADSL)
+      priv->pshare->iot_mode_BE_exist = 0;   
+#endif
+	priv->pshare->iot_mode_VO_exist = 0;
+}
+
+BOOLEAN
+ODM_ChooseIotMainSTA(
+	IN 	PVOID	 	pDM_VOID,
+	IN	PSTA_INFO_T		pstat
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	prtl8192cd_priv	priv = pDM_Odm->priv;
+	BOOLEAN		bhighTP_found_pstat=FALSE;
+	
+	if ((GET_ROOT(priv)->up_time % 2) == 0) {
+		unsigned int tx_2s_avg = 0;
+		unsigned int rx_2s_avg = 0;
+		int i=0, aggReady=0;
+		unsigned long total_sum = (priv->pshare->current_tx_bytes+priv->pshare->current_rx_bytes);
+		int assoc_num = GET_ROOT(priv)->assoc_num;
+#ifdef MBSSID
+		if (GET_ROOT(priv)->pmib->miscEntry.vap_enable){
+			for (i=0; i<RTL8192CD_NUM_VWLAN; ++i)
+				assoc_num += GET_ROOT(priv)->pvap_priv[i]-> assoc_num;
+		}
+#endif	
+#ifdef UNIVERSAL_REPEATER
+		if (IS_DRV_OPEN(GET_VXD_PRIV(GET_ROOT(priv))))
+			assoc_num += GET_VXD_PRIV(GET_ROOT(priv))-> assoc_num;
+#endif
+#ifdef WDS
+		 if(GET_ROOT(priv)->pmib->dot11WdsInfo.wdsEnabled)
+			assoc_num ++;
+#endif
+
+
+		pstat->current_tx_bytes += pstat->tx_byte_cnt;
+		pstat->current_rx_bytes += pstat->rx_byte_cnt;
+
+		if (total_sum != 0) {
+			if (total_sum <= 1000000) {
+			tx_2s_avg = (unsigned int)((pstat->current_tx_bytes*100) / total_sum);
+			rx_2s_avg = (unsigned int)((pstat->current_rx_bytes*100) / total_sum);
+			} else {
+				tx_2s_avg = (unsigned int)(pstat->current_tx_bytes / (total_sum / 100));
+				rx_2s_avg = (unsigned int)(pstat->current_rx_bytes / (total_sum / 100));
+			}
+
+		}
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_ADSL)
+		if (pstat->ht_cap_len) {
+			if ((tx_2s_avg + rx_2s_avg) >=25 ) {//50//
+
+					priv->pshare->highTP_found_pstat = pstat;
+					bhighTP_found_pstat=TRUE;
+   				}
+			}
+#elif(DM_ODM_SUPPORT_TYPE==ODM_AP)
+		for(i=0; i<8; i++)
+			aggReady += (pstat->ADDBA_ready[i]);
+
+		if ((pstat->ht_cap_len && (
+#ifdef	SUPPORT_TX_AMSDU			
+			AMSDU_ENABLE || 
+#endif			
+			aggReady)) || (pstat->IOTPeer==HT_IOT_PEER_INTEL))
+		{
+			if ((assoc_num==1) || (tx_2s_avg + rx_2s_avg >= 25)) {
+				priv->pshare->highTP_found_pstat = pstat;
+			}
+			
+		#ifdef CLIENT_MODE
+			if (OPMODE & WIFI_STATION_STATE) {
+				if ((tx_2s_avg + rx_2s_avg) >= 20)
+					priv->pshare->highTP_found_pstat = pstat;
+		}
+		#endif				
+	}
+#endif
+	} 
+	else {
+		pstat->current_tx_bytes = pstat->tx_byte_cnt;
+		pstat->current_rx_bytes = pstat->rx_byte_cnt;
+	}
+
+	return bhighTP_found_pstat;
+}
+
+
+#ifdef WIFI_WMM
+VOID
+ODM_IotEdcaSwitch(
+	IN 	PVOID	 	pDM_VOID,
+	IN	unsigned char		enable
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	prtl8192cd_priv	priv	= pDM_Odm->priv;
+	int   mode=priv->pmib->dot11BssType.net_work_type;
+	unsigned int slot_time = 20, sifs_time = 10, BE_TXOP = 47, VI_TXOP = 94;
+	unsigned int vi_cw_max = 4, vi_cw_min = 3, vi_aifs;
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+	u32 be_edca, vi_edca;
+	u16 disable_cfe;
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
+	if (!(!priv->pmib->dot11OperationEntry.wifi_specific ||
+		((OPMODE & WIFI_AP_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific))
+	#ifdef CLIENT_MODE
+		|| ((OPMODE & WIFI_STATION_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific))
+	#endif
+		))
+		return;
+#endif
+
+#ifdef RTK_AC_SUPPORT //for 11ac logo, do not dynamic switch edca 
+	if(AC_SIGMA_MODE != AC_SIGMA_NONE)
+		return;
+#endif
+
+	if ((mode & (ODM_WM_N24G|ODM_WM_N5G)) && (priv->pshare->ht_sta_num
+	#ifdef WDS
+		|| ((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11WdsInfo.wdsEnabled && priv->pmib->dot11WdsInfo.wdsNum)
+	#endif
+		))
+		sifs_time = 16;
+
+	if (mode & (ODM_WM_N24G|ODM_WM_N5G|ODM_WM_G|ODM_WM_A)) {
+		slot_time = 9;
+	} 
+	else
+	{
+		BE_TXOP = 94;
+		VI_TXOP = 188;
+	}
+
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+	vi_edca = -1;
+	disable_cfe = -1;
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE==ODM_ADSL)
+	if (priv->pshare->iot_mode_VO_exist) {
+		// to separate AC_VI and AC_BE to avoid using the same EDCA settings
+		if (priv->pshare->iot_mode_BE_exist) {
+			vi_cw_max = 5;
+			vi_cw_min = 3;
+		} else {
+			vi_cw_max = 6;
+			vi_cw_min = 4;
+		}
+	}
+	vi_aifs = (sifs_time + ((OPMODE & WIFI_AP_STATE)?1:2) * slot_time);
+
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+	vi_edca = ((VI_TXOP*(1-priv->pshare->iot_mode_VO_exist)) << 16)| (vi_cw_max << 12) | (vi_cw_min << 8) | vi_aifs;
+#else
+	ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, ((VI_TXOP*(1-priv->pshare->iot_mode_VO_exist)) << 16)| (vi_cw_max << 12) | (vi_cw_min << 8) | vi_aifs);
+#endif
+	
+#elif (DM_ODM_SUPPORT_TYPE==ODM_AP)
+	if ((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11OperationEntry.wifi_specific) {
+		if (priv->pshare->iot_mode_VO_exist) {
+	#ifdef WMM_VIBE_PRI
+			if (priv->pshare->iot_mode_BE_exist) 
+			{
+				vi_cw_max = 5;
+				vi_cw_min = 3;
+				vi_aifs = (sifs_time + ((OPMODE & WIFI_AP_STATE)?1:2) * slot_time);
+			}
+			else 
+	#endif
+			{
+			vi_cw_max = 6;
+			vi_cw_min = 4;
+			vi_aifs = 0x2b;
+			}
+		} 
+		else {
+			vi_aifs = (sifs_time + ((OPMODE & WIFI_AP_STATE)?1:2) * slot_time);
+		}
+
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+		vi_edca = ((VI_TXOP*(1-priv->pshare->iot_mode_VO_exist)) << 16)
+			| (vi_cw_max << 12) | (vi_cw_min << 8) | vi_aifs;
+#else
+		ODM_Write4Byte(pDM_Odm, ODM_EDCA_VI_PARAM, ((VI_TXOP*(1-priv->pshare->iot_mode_VO_exist)) << 16)
+			| (vi_cw_max << 12) | (vi_cw_min << 8) | vi_aifs);
+#endif
+
+	#ifdef WMM_BEBK_PRI
+	#ifdef CONFIG_RTL_88E_SUPPORT
+		if ((GET_CHIP_VER(priv) == VERSION_8188E) && priv->pshare->iot_mode_BK_exist) {
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+			be_edca = (10 << 12) | (6 << 8) | 0x4f;
+#else
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_BK_PARAM, (10 << 12) | (6 << 8) | 0x4f);
+#endif
+		}
+	#endif		
+	#endif
+#if defined(CONFIG_WLAN_HAL_8881A) 
+		if (GET_CHIP_VER(priv) == VERSION_8881A) 
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_BK_PARAM,  0xa64f);
+#endif		
+	}
+#endif
+
+
+
+#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
+ 	if (priv->pshare->rf_ft_var.wifi_beq_iot && priv->pshare->iot_mode_VI_exist) {
+#if defined(CONFIG_RTL_88E_SUPPORT) || defined(CONFIG_RTL_8812_SUPPORT)
+		if (GET_CHIP_VER(priv) == VERSION_8188E || GET_CHIP_VER(priv) == VERSION_8812E) {
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+			be_edca = (10 << 12) | (6 << 8) | 0x4f;
+#else
+		  	ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (10 << 12) | (6 << 8) | 0x4f);
+#endif
+		}
+		else
+#endif
+		{
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+			be_edca = (10 << 12) | (4 << 8) | 0x4f;
+#else
+	  	ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (10 << 12) | (4 << 8) | 0x4f);
+#endif
+		}
+	} else if(!enable)
+#elif(DM_ODM_SUPPORT_TYPE==ODM_ADSL)      
+	if(!enable)                                 //if iot is disable ,maintain original BEQ PARAM
+#endif
+	{
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+		be_edca = (((OPMODE & WIFI_AP_STATE)?6:10) << 12) | (4 << 8)
+			| (sifs_time + 3 * slot_time);
+		disable_cfe = 1;
+#else
+		ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (((OPMODE & WIFI_AP_STATE)?6:10) << 12) | (4 << 8)
+			| (sifs_time + 3 * slot_time));
+#endif
+#ifdef CONFIG_PCI_HCI
+//		ODM_Write2Byte(pDM_Odm, RD_CTRL, ODM_Read2Byte(pDM_Odm, RD_CTRL) | (DIS_TXOP_CFE));
+#endif
+	}
+	else
+	{
+		int txop;
+		unsigned int cw_max;
+#ifdef LOW_TP_TXOP
+		unsigned int txop_close;
+#endif
+		
+	#if((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined LOW_TP_TXOP))
+			cw_max = ((priv->pshare->BE_cwmax_enhance) ? 10 : 6);
+			txop_close = ((priv->pshare->rf_ft_var.low_tp_txop && priv->pshare->rf_ft_var.low_tp_txop_close) ? 1 : 0);
+
+			if(priv->pshare->txop_enlarge == 0xe)   //if intel case
+				txop = (txop_close ? 0 : (BE_TXOP*2));
+			else                                                        //if other case
+				txop = (txop_close ? 0: (BE_TXOP*priv->pshare->txop_enlarge));
+	#else
+			cw_max=6;
+			if((priv->pshare->txop_enlarge==0xe)||(priv->pshare->txop_enlarge==0xd))
+				txop=BE_TXOP*2;
+			else
+				txop=BE_TXOP*priv->pshare->txop_enlarge;
+
+	#endif
+                           
+		if (priv->pshare->ht_sta_num
+	#ifdef WDS
+			|| ((OPMODE & WIFI_AP_STATE) && (mode & (ODM_WM_N24G|ODM_WM_N5G)) &&
+			priv->pmib->dot11WdsInfo.wdsEnabled && priv->pmib->dot11WdsInfo.wdsNum)
+	#endif
+			) 
+			{
+
+			if (priv->pshare->txop_enlarge == 0xe) {
+				// is intel client, use a different edca value
+				//ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop<< 16) | (cw_max<< 12) | (4 << 8) | 0x1f);
+				if (pDM_Odm->RFType==ODM_1T1R) {
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+					be_edca = (txop << 16) | (5 << 12) | (3 << 8) | 0x1f;
+#else
+					ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) | (5 << 12) | (3 << 8) | 0x1f);
+#endif
+				}
+				else {
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+					be_edca = (txop << 16) | (8 << 12) | (5 << 8) | 0x1f;
+#else
+					ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) | (8 << 12) | (5 << 8) | 0x1f);
+#endif
+				}
+				
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+				disable_cfe = 0;
+#endif
+#ifdef CONFIG_PCI_HCI
+//				ODM_Write2Byte(pDM_Odm, RD_CTRL, ODM_Read2Byte(pDM_Odm, RD_CTRL) & ~(DIS_TXOP_CFE));
+#endif
+				priv->pshare->txop_enlarge = 2;
+			} 
+#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
+	#ifndef LOW_TP_TXOP
+			 else if (priv->pshare->txop_enlarge == 0xd) {
+				// is intel ralink, use a different edca value
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+				be_edca = (txop << 16) | (6 << 12) | (5 << 8) | 0x2b;
+#else
+				ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) | (6 << 12) | (5 << 8) | 0x2b);
+#endif
+				priv->pshare->txop_enlarge = 2;
+			} 
+	#endif
+#endif
+			else 
+			{
+//				if (txop == 0) {
+//#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+//					disable_cfe = 1;
+//#endif
+//#ifdef CONFIG_PCI_HCI
+//					ODM_Write2Byte(pDM_Odm, RD_CTRL, ODM_Read2Byte(pDM_Odm, RD_CTRL) | (DIS_TXOP_CFE));
+//#endif
+//				}
+					
+				if (pDM_Odm->RFType==ODM_2T2R) {
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+					be_edca = (txop << 16) | (cw_max << 12) | (4 << 8) | (sifs_time + 3 * slot_time);
+#else
+					ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) |
+						(cw_max << 12) | (4 << 8) | (sifs_time + 3 * slot_time));
+#endif
+				}
+				else
+				#if(DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined LOW_TP_TXOP)
+				{
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+					be_edca = (txop << 16) |
+						(((priv->pshare->BE_cwmax_enhance) ? 10 : 5) << 12) | (3 << 8) | (sifs_time + 2 * slot_time);
+#else
+					ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) |
+						(((priv->pshare->BE_cwmax_enhance) ? 10 : 5) << 12) | (3 << 8) | (sifs_time + 2 * slot_time));
+#endif
+				}
+				#else
+				{
+					PSTA_INFO_T		pstat = priv->pshare->highTP_found_pstat;
+					if ((GET_CHIP_VER(priv)==VERSION_8881A) && pstat && (pstat->IOTPeer == HT_IOT_PEER_HTC))
+					ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, 0x642b);
+					else {
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+					be_edca = (txop << 16) | (5 << 12) | (3 << 8) | (sifs_time + 2 * slot_time);
+				#else
+					ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (txop << 16) |
+						(5 << 12) | (3 << 8) | (sifs_time + 2 * slot_time));
+#endif
+					}
+				}
+				#endif
+			}
+		}
+              else 
+              {
+ #if((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined LOW_TP_TXOP))
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+			 be_edca = (BE_TXOP << 16) | (cw_max << 12) | (4 << 8) | (sifs_time + 3 * slot_time);
+#else
+			 ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (BE_TXOP << 16) | (cw_max << 12) | (4 << 8) | (sifs_time + 3 * slot_time));
+#endif
+ #else
+ 		#if defined(CONFIG_RTL_8196D) || defined(CONFIG_RTL_8197DL) || defined(CONFIG_RTL_8196E) || (defined(CONFIG_RTL_8197D) && !defined(CONFIG_PORT0_EXT_GIGA))
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+			be_edca = (BE_TXOP*2 << 16) | (cw_max << 12) | (5 << 8) | (sifs_time + 3 * slot_time);
+ #else
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM,  (BE_TXOP*2 << 16) | (cw_max << 12) | (5 << 8) | (sifs_time + 3 * slot_time));
+#endif
+		#else
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+			be_edca = (BE_TXOP*2 << 16) | (cw_max << 12) | (4 << 8) | (sifs_time + 3 * slot_time);
+		#else
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM,  (BE_TXOP*2 << 16) | (cw_max << 12) | (4 << 8) | (sifs_time + 3 * slot_time));
+		#endif
+		#endif
+/*		
+		if (priv->pshare->txop_enlarge == 0xe) {
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+			disable_cfe = 0;
+#endif
+	#ifdef CONFIG_PCI_HCI
+			ODM_Write2Byte(pDM_Odm, RD_CTRL, ODM_Read2Byte(pDM_Odm, RD_CTRL) & ~(DIS_TXOP_CFE));
+	#endif
+		} else {
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+			disable_cfe = 1;
+#endif
+	#ifdef CONFIG_PCI_HCI
+			ODM_Write2Byte(pDM_Odm, RD_CTRL, ODM_Read2Byte(pDM_Odm, RD_CTRL) | (DIS_TXOP_CFE));
+	#endif
+		}
+*/			
+ #endif
+              }
+
+	}
+	
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+	notify_IOT_EDCA_switch(priv, be_edca, vi_edca, disable_cfe);
+#endif
+}
+#endif
+
+VOID 
+odm_IotEngine(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	struct rtl8192cd_priv *priv=pDM_Odm->priv;
+	PSTA_INFO_T pstat = NULL;
+	u4Byte i;
+	
+#ifdef WIFI_WMM
+	unsigned int switch_turbo = 0, avg_tp;
+#endif	
+////////////////////////////////////////////////////////
+//  if EDCA Turbo function is not supported or Manual EDCA Setting
+//  then return
+////////////////////////////////////////////////////////
+	if(!(pDM_Odm->SupportAbility&ODM_MAC_EDCA_TURBO)){
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("ODM_MAC_EDCA_TURBO NOT SUPPORTED\n"));
+		return;
+	}
+	
+#if((DM_ODM_SUPPORT_TYPE==ODM_AP)&& defined(RTL_MANUAL_EDCA) && defined(WIFI_WMM))
+	if(priv->pmib->dot11QosEntry.ManualEDCA){
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("ODM_MAC_EDCA_TURBO OFF: MANUAL SETTING\n"));
+		return ;
+	}
+#endif 
+
+#if !(DM_ODM_SUPPORT_TYPE &ODM_AP)
+ //////////////////////////////////////////////////////
+ //find high TP STA every 2s
+//////////////////////////////////////////////////////
+	if ((GET_ROOT(priv)->up_time % 2) == 0) 
+		priv->pshare->highTP_found_pstat==NULL;
+
+#if 0
+	phead = &priv->asoc_list;
+	plist = phead->next;
+	while(plist != phead)	{
+		pstat = list_entry(plist, struct stat_info, asoc_list);
+
+		if(ODM_ChooseIotMainSTA(pDM_Odm, pstat));              //find the correct station
+			break;
+		if (plist == plist->next)                                          //the last plist 
+			break;
+		plist = plist->next;
+	};
+#endif
+
+	//find highTP STA
+	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		pstat = pDM_Odm->pODM_StaInfo[i];
+		if(IS_STA_VALID(pstat) && (ODM_ChooseIotMainSTA(pDM_Odm, pstat)))	 //find the correct station
+				break;
+	}
+
+ //////////////////////////////////////////////////////
+ //if highTP STA is not found, then return
+ //////////////////////////////////////////////////////
+	if(priv->pshare->highTP_found_pstat==NULL)	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("ODM_MAC_EDCA_TURBO OFF: NO HT STA FOUND\n"));
+		return;
+	}
+#endif
+
+	pstat=priv->pshare->highTP_found_pstat;
+	if(pstat) {
+		if((pstat->tx_avarage + pstat->rx_avarage) < (1<<17))	// 1M bps
+			pstat = NULL;
+	}
+
+#ifdef WIFI_WMM
+	if (QOS_ENABLE) {
+		if (!priv->pmib->dot11OperationEntry.wifi_specific 
+		#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
+			||((OPMODE & WIFI_AP_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific))
+		#elif(DM_ODM_SUPPORT_TYPE==ODM_ADSL)
+			|| (priv->pmib->dot11OperationEntry.wifi_specific == 2)
+		#endif
+			) {
+			if (priv->pshare->iot_mode_enable &&
+				((priv->pshare->phw->VO_pkt_count > 50) ||
+				 (priv->pshare->phw->VI_pkt_count > 50) ||
+				 (priv->pshare->phw->BK_pkt_count > 50))) {
+				priv->pshare->iot_mode_enable = 0;
+				switch_turbo++;
+#ifdef CONFIG_WLAN_HAL_8881A
+				if (GET_CHIP_VER(priv) == VERSION_8881A) {
+					RTL_W32(0x460, 0x03086666);
+				}
+#endif //CONFIG_WLAN_HAL_8881A
+			} else if ((!priv->pshare->iot_mode_enable) &&
+				((priv->pshare->phw->VO_pkt_count < 50) &&
+				 (priv->pshare->phw->VI_pkt_count < 50) &&
+				 (priv->pshare->phw->BK_pkt_count < 50))) {
+				priv->pshare->iot_mode_enable++;
+				switch_turbo++;
+//#ifdef CONFIG_WLAN_HAL_8881A
+#if 0
+				if (GET_CHIP_VER(priv) == VERSION_8881A) {
+					if (get_bonding_type_8881A()==BOND_8881AB) {
+						RTL_W32(0x460, 0x03086666);
+					}
+					else {
+						RTL_W32(0x460, 0x0320ffff);
+					}
+				}
+#endif //CONFIG_WLAN_HAL_8881A
+			}
+		}
+
+
+		#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
+		if ((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11OperationEntry.wifi_specific)
+		#elif (DM_ODM_SUPPORT_TYPE==ODM_ADSL)
+		if (priv->pmib->dot11OperationEntry.wifi_specific) 
+		#endif
+		{
+			if (!priv->pshare->iot_mode_VO_exist && (priv->pshare->phw->VO_pkt_count > 50)) {
+				priv->pshare->iot_mode_VO_exist++;
+				switch_turbo++;
+			} else if (priv->pshare->iot_mode_VO_exist && (priv->pshare->phw->VO_pkt_count < 50)) {
+				priv->pshare->iot_mode_VO_exist = 0;
+				switch_turbo++;
+			}
+#if((DM_ODM_SUPPORT_TYPE==ODM_ADSL)||((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined WMM_VIBE_PRI)))
+			if (priv->pshare->iot_mode_VO_exist) {
+				//printk("[%s %d] BE_pkt_count=%d\n", __FUNCTION__, __LINE__, priv->pshare->phw->BE_pkt_count);
+				if (!priv->pshare->iot_mode_BE_exist && (priv->pshare->phw->BE_pkt_count > 250)) {
+					priv->pshare->iot_mode_BE_exist++;
+					switch_turbo++;
+				} else if (priv->pshare->iot_mode_BE_exist && (priv->pshare->phw->BE_pkt_count < 250)) {
+					priv->pshare->iot_mode_BE_exist = 0;
+					switch_turbo++;
+				}
+			}
+#endif
+
+#if((DM_ODM_SUPPORT_TYPE==ODM_ADSL)||((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined WMM_BEBK_PRI)))
+			if (priv->pshare->phw->BE_pkt_count) {
+				//printk("[%s %d] BK_pkt_count=%d\n", __FUNCTION__, __LINE__, priv->pshare->phw->BK_pkt_count);
+				if (!priv->pshare->iot_mode_BK_exist && (priv->pshare->phw->BK_pkt_count > 250)) {
+					priv->pshare->iot_mode_BK_exist++;
+					switch_turbo++;
+				} else if (priv->pshare->iot_mode_BK_exist && (priv->pshare->phw->BK_pkt_count < 250)) {
+					priv->pshare->iot_mode_BK_exist = 0;
+					switch_turbo++;
+				}
+			}
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE==ODM_AP)
+			if (priv->pshare->rf_ft_var.wifi_beq_iot) 
+			{
+				if (!priv->pshare->iot_mode_VI_exist && (priv->pshare->phw->VI_rx_pkt_count > 50)) {
+					priv->pshare->iot_mode_VI_exist++;
+					switch_turbo++;
+				} else if (priv->pshare->iot_mode_VI_exist && (priv->pshare->phw->VI_rx_pkt_count < 50)) {
+					priv->pshare->iot_mode_VI_exist = 0;
+					switch_turbo++;
+				}
+			}
+#endif
+
+		}
+		else if (!pstat || pstat->rssi < priv->pshare->rf_ft_var.txop_enlarge_lower) {
+		   if (priv->pshare->txop_enlarge) {
+			   priv->pshare->txop_enlarge = 0;
+			   if (priv->pshare->iot_mode_enable)
+					switch_turbo++;
+				}
+         	}
+
+#if(defined(CLIENT_MODE) && (DM_ODM_SUPPORT_TYPE==ODM_AP))
+        if ((OPMODE & WIFI_STATION_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific))
+        {
+            if (priv->pshare->iot_mode_enable &&
+                (((priv->pshare->phw->VO_pkt_count > 50) ||
+                 (priv->pshare->phw->VI_pkt_count > 50) ||
+                 (priv->pshare->phw->BK_pkt_count > 50)) ||
+                 (pstat && (!pstat->ADDBA_ready[0]) & (!pstat->ADDBA_ready[3]))))
+            {
+                priv->pshare->iot_mode_enable = 0;
+                switch_turbo++;
+            }
+            else if ((!priv->pshare->iot_mode_enable) &&
+                (((priv->pshare->phw->VO_pkt_count < 50) &&
+                 (priv->pshare->phw->VI_pkt_count < 50) &&
+                 (priv->pshare->phw->BK_pkt_count < 50)) &&
+                 (pstat && (pstat->ADDBA_ready[0] | pstat->ADDBA_ready[3]))))
+            {
+                priv->pshare->iot_mode_enable++;
+                switch_turbo++;
+            }
+        }
+#endif
+
+		priv->pshare->phw->VO_pkt_count = 0;
+		priv->pshare->phw->VI_pkt_count = 0;
+		priv->pshare->phw->BK_pkt_count = 0;
+
+	#if((DM_ODM_SUPPORT_TYPE==ODM_ADSL)||((DM_ODM_SUPPORT_TYPE==ODM_AP)&&(defined WMM_VIBE_PRI)))
+		priv->pshare->phw->BE_pkt_count = 0;
+	#endif
+		
+	#if(DM_ODM_SUPPORT_TYPE==ODM_AP)
+		if (priv->pshare->rf_ft_var.wifi_beq_iot)
+			priv->pshare->phw->VI_rx_pkt_count = 0;
+		#endif
+
+	}
+#endif
+
+	if ((priv->up_time % 2) == 0) {
+		/*
+		 * decide EDCA content for different chip vendor
+		 */
+#ifdef WIFI_WMM
+	#if(DM_ODM_SUPPORT_TYPE==ODM_ADSL)
+		if (QOS_ENABLE && (!priv->pmib->dot11OperationEntry.wifi_specific || (priv->pmib->dot11OperationEntry.wifi_specific == 2)
+	
+	#elif(DM_ODM_SUPPORT_TYPE==ODM_AP)
+		if (QOS_ENABLE && (!priv->pmib->dot11OperationEntry.wifi_specific || 
+			((OPMODE & WIFI_AP_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))
+		#ifdef CLIENT_MODE
+            || ((OPMODE & WIFI_STATION_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))
+		#endif
+	#endif
+		))
+	
+		{
+
+			if (pstat && pstat->rssi >= priv->pshare->rf_ft_var.txop_enlarge_upper) {
+#ifdef LOW_TP_TXOP
+				if (pstat->IOTPeer==HT_IOT_PEER_INTEL)
+				{
+					if (priv->pshare->txop_enlarge != 0xe)
+					{
+						priv->pshare->txop_enlarge = 0xe;
+
+						if (priv->pshare->iot_mode_enable)
+							switch_turbo++;
+					}
+				} 
+				else if (priv->pshare->txop_enlarge != 2) 
+				{
+					priv->pshare->txop_enlarge = 2;
+					if (priv->pshare->iot_mode_enable)
+						switch_turbo++;
+				}
+#else
+				if (priv->pshare->txop_enlarge != 2)
+				{
+					if (pstat->IOTPeer==HT_IOT_PEER_INTEL)
+						priv->pshare->txop_enlarge = 0xe;						
+					else if (pstat->IOTPeer==HT_IOT_PEER_RALINK)
+						priv->pshare->txop_enlarge = 0xd;						
+					else if (pstat->IOTPeer==HT_IOT_PEER_HTC)
+						priv->pshare->txop_enlarge = 0;		
+					else
+						priv->pshare->txop_enlarge = 2;
+
+					if (priv->pshare->iot_mode_enable)
+						switch_turbo++;
+				}
+#endif
+			}
+			else if (!pstat || pstat->rssi < priv->pshare->rf_ft_var.txop_enlarge_lower) 
+			{
+				if (priv->pshare->txop_enlarge) {
+					priv->pshare->txop_enlarge = 0;
+					if (priv->pshare->iot_mode_enable)
+						switch_turbo++;
+				}
+			}
+
+#if((DM_ODM_SUPPORT_TYPE==ODM_AP)&&( defined LOW_TP_TXOP))
+			// for Intel IOT, need to enlarge CW MAX from 6 to 10
+			if (pstat && pstat->IOTPeer==HT_IOT_PEER_INTEL && (((pstat->tx_avarage+pstat->rx_avarage)>>10) < 
+					priv->pshare->rf_ft_var.cwmax_enhance_thd)) 
+			{
+				if (!priv->pshare->BE_cwmax_enhance && priv->pshare->iot_mode_enable)
+				{
+					priv->pshare->BE_cwmax_enhance = 1;
+					switch_turbo++;
+				}
+			} else {
+				if (priv->pshare->BE_cwmax_enhance) {
+					priv->pshare->BE_cwmax_enhance = 0;
+					switch_turbo++;
+				}
+			}
+#endif
+		}
+#endif
+		priv->pshare->current_tx_bytes = 0;
+		priv->pshare->current_rx_bytes = 0;
+	}else {
+		if ((GET_CHIP_VER(priv) == VERSION_8881A)||(GET_CHIP_VER(priv) == VERSION_8192E)|| (GET_CHIP_VER(priv) == VERSION_8188E) ){
+			unsigned int uldl_tp = (priv->pshare->current_tx_bytes+priv->pshare->current_rx_bytes)>>17;
+			if((uldl_tp > 40) && (priv->pshare->agg_to!= 1)) {
+				RTL_W8(0x462, 0x08);
+				priv->pshare->agg_to = 1;
+			} else if((uldl_tp < 35) && (priv->pshare->agg_to !=0)) {
+				RTL_W8(0x462, 0x02);
+				priv->pshare->agg_to = 0;
+			} 
+		}
+	}
+	
+#if((DM_ODM_SUPPORT_TYPE==ODM_AP)&& defined( SW_TX_QUEUE))
+	if(AMPDU_ENABLE) {
+#ifdef TX_EARLY_MODE
+		if (GET_TX_EARLY_MODE) {
+			if (!GET_EM_SWQ_ENABLE &&
+				((priv->assoc_num > 1) ||
+				(pstat && pstat->IOTPeer != HT_IOT_PEER_UNKNOWN))) {
+				if ((priv->pshare->em_tx_byte_cnt >> 17) > EM_TP_UP_BOUND) 
+					priv->pshare->reach_tx_limit_cnt++;				
+				else					
+					priv->pshare->reach_tx_limit_cnt = 0;	
+
+				if (priv->pshare->txop_enlarge && priv->pshare->reach_tx_limit_cnt) { //>= WAIT_TP_TIME//
+					GET_EM_SWQ_ENABLE = 1;			
+					priv->pshare->reach_tx_limit_cnt = 0;
+
+					if (pstat->IOTPeer == HT_IOT_PEER_INTEL)
+						MAX_EM_QUE_NUM = 12;
+					else if (pstat->IOTPeer == HT_IOT_PEER_RALINK)
+						MAX_EM_QUE_NUM = 10;
+					
+					enable_em(priv);			
+				}
+			}
+			else if (GET_EM_SWQ_ENABLE) {
+				if ((priv->pshare->em_tx_byte_cnt >> 17) < EM_TP_LOW_BOUND)
+					priv->pshare->reach_tx_limit_cnt++;				
+				else					
+					priv->pshare->reach_tx_limit_cnt = 0;	
+
+				if (!priv->pshare->txop_enlarge || priv->pshare->reach_tx_limit_cnt >= WAIT_TP_TIME) {
+					GET_EM_SWQ_ENABLE = 0;
+					priv->pshare->reach_tx_limit_cnt = 0;
+					disable_em(priv);
+				}
+			}
+		}
+#endif
+
+#if defined(CONFIG_WLAN_HAL_8881A) || defined(CONFIG_WLAN_HAL_8192EE) || defined(CONFIG_RTL_8812_SUPPORT) || defined(CONFIG_WLAN_HAL_8814AE)
+	if (pDM_Odm->SupportICType == ODM_RTL8881A || pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8814A) {	
+		if (priv->assoc_num > 9)
+   	{
+       	if (priv->swq_txmac_chg >= priv->pshare->rf_ft_var.swq_en_highthd){
+				if ((priv->swq_decision == 0)){
+				switch_turbo++;
+				if (priv->pshare->txop_enlarge == 0)
+					priv->pshare->txop_enlarge = 2;
+					priv->swq_decision = 1;
+				}
+			else
+			{
+				if ((switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))
+				{
+					priv->pshare->txop_enlarge = 2;
+					switch_turbo--;
+				}
+			}
+		}
+		else if(priv->swq_txmac_chg <= priv->pshare->rf_ft_var.swq_dis_lowthd){
+				priv->swq_decision = 0;
+		}
+			else if ((priv->swq_decision == 1) && (switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))        {
+			priv->pshare->txop_enlarge = 2;
+			switch_turbo--;
+		}
+	    	} else {
+			priv->swq_decision = 0;
+    }
+	} else if(CONFIG_WLAN_NOT_HAL_EXIST)
+#endif
+		{	
+		if (priv->assoc_num > 1)
+   	{
+       	if (priv->swq_txmac_chg >= priv->pshare->rf_ft_var.swq_en_highthd){
+				if ((priv->swq_decision == 0)){
+				switch_turbo++;
+				if (priv->pshare->txop_enlarge == 0)
+					priv->pshare->txop_enlarge = 2;
+					priv->swq_decision = 1;
+				}
+			else
+			{
+				if ((switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))
+				{
+					priv->pshare->txop_enlarge = 2;
+					switch_turbo--;
+				}
+			}
+		}
+		else if(priv->swq_txmac_chg <= priv->pshare->rf_ft_var.swq_dis_lowthd){
+				priv->swq_decision = 0;
+		}
+			else if ((priv->swq_decision == 1) && (switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))        {
+			priv->pshare->txop_enlarge = 2;
+			switch_turbo--;
+		}
+    }
+	//#if (defined CONFIG_RTL_819XD))
+		else if (priv->assoc_num == 1 && (priv->up_time % 2 == 0)
+#if (DM_ODM_SUPPORT_TYPE==ODM_AP) && defined(TX_EARLY_MODE)
+			&& (!GET_TX_EARLY_MODE || !GET_EM_SWQ_ENABLE) 
+#endif
+		) {
+			if ((pstat) && (pstat->ADDBA_ready[0] | pstat->ADDBA_ready[3])) {
+				//int en_thd = 14417920>>(priv->up_time % 2);
+				avg_tp = (pstat->current_tx_bytes >> 17);
+
+				//if ((priv->swq_decision == 0) && (pstat->current_tx_bytes > en_thd) && (pstat->current_rx_bytes > en_thd) )  { //50Mbps
+				if ((priv->swq_decision == 0) && (avg_tp  > TP_HIGH_WATER_MARK)) { //55Mbps
+					//printk("[%s:%d] swq_decision=1 current_tp: %d Mbps\n", __FUNCTION__, __LINE__, avg_tp);
+					priv->swq_decision = 1;
+				}
+				//else if ((priv->swq_decision == 1) && ((pstat->tx_avarage < 4587520) || (pstat->rx_avarage < 4587520))) { //35Mbps
+				else if ((priv->swq_decision == 1) && (avg_tp < TP_LOW_WATER_MARK)) { //35Mbps
+					//printk("[%s:%d] swq_decision=0 current_tp: %d Mbps\n", __FUNCTION__, __LINE__, avg_tp);
+					priv->swq_decision = 0;
+				}
+			} else {
+				priv->swq_decision = 0;
+            }
+            }
+        }
+		if( (priv->swq_decision == 1) 
+#if (DM_ODM_SUPPORT_TYPE==ODM_AP) && defined(TX_EARLY_MODE)		
+		|| (GET_EM_SWQ_ENABLE == 1) 
+#endif		
+		) {
+			priv->swq_en = 1;
+			priv->swqen_keeptime = priv->up_time;
+		} else {
+            priv->swq_en = 0;
+			priv->swqen_keeptime = 0;
+        }
+    }
+#endif
+
+#ifdef WIFI_WMM
+#ifdef LOW_TP_TXOP
+	if ((!priv->pmib->dot11OperationEntry.wifi_specific || (priv->pmib->dot11OperationEntry.wifi_specific == 2))
+		&& QOS_ENABLE) {
+		if (switch_turbo || priv->pshare->rf_ft_var.low_tp_txop) {
+			unsigned int thd_tp;
+			unsigned char under_thd;
+			unsigned int curr_tp;
+
+			if (priv->pmib->dot11BssType.net_work_type & (ODM_WM_N24G|ODM_WM_N5G| ODM_WM_G))
+			{
+				// Determine the upper bound throughput threshold.
+				if (priv->pmib->dot11BssType.net_work_type & (ODM_WM_N24G|ODM_WM_N5G)) {
+					if (priv->assoc_num && priv->assoc_num != priv->pshare->ht_sta_num)
+						thd_tp = priv->pshare->rf_ft_var.low_tp_txop_thd_g;
+					else
+						thd_tp = priv->pshare->rf_ft_var.low_tp_txop_thd_n;
+				}
+				else
+					thd_tp = priv->pshare->rf_ft_var.low_tp_txop_thd_g;
+
+				// Determine to close txop.
+#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
+				if(IS_STA_VALID(pstat)) 
+				{	
+					struct rtl8192cd_priv *tmppriv;
+					struct aid_obj *aidarray;	
+					aidarray = container_of(pstat, struct aid_obj, station);
+					tmppriv = aidarray->priv;
+
+					curr_tp = (unsigned int)(tmppriv->ext_stats.tx_avarage>>17) + (unsigned int)(tmppriv->ext_stats.rx_avarage>>17);
+				} 
+				else 
+#endif
+				curr_tp = (unsigned int)(priv->ext_stats.tx_avarage>>17) + (unsigned int)(priv->ext_stats.rx_avarage>>17);
+				if (curr_tp <= thd_tp && curr_tp >= priv->pshare->rf_ft_var.low_tp_txop_thd_low)
+					under_thd = 1;
+				else
+					under_thd = 0;
+			}
+			else
+			{
+				under_thd = 0;
+			}
+
+			if (switch_turbo) 
+			{
+				priv->pshare->rf_ft_var.low_tp_txop_close = under_thd;
+				priv->pshare->rf_ft_var.low_tp_txop_count = 0;
+			}
+			else if (priv->pshare->iot_mode_enable && (priv->pshare->rf_ft_var.low_tp_txop_close != under_thd)) {
+				priv->pshare->rf_ft_var.low_tp_txop_count++;
+				if (priv->pshare->rf_ft_var.low_tp_txop_close) {
+					priv->pshare->rf_ft_var.low_tp_txop_count = priv->pshare->rf_ft_var.low_tp_txop_delay;
+				}
+				if (priv->pshare->rf_ft_var.low_tp_txop_count ==priv->pshare->rf_ft_var.low_tp_txop_delay) 
+
+				{					
+					priv->pshare->rf_ft_var.low_tp_txop_count = 0;
+					priv->pshare->rf_ft_var.low_tp_txop_close = under_thd;
+					switch_turbo++;
+				}
+			} 
+			else 
+			{
+				priv->pshare->rf_ft_var.low_tp_txop_count = 0;
+			}
+		}
+	}
+#endif		
+
+#ifdef WMM_DSCP_C42
+	if (switch_turbo) {
+		if (!priv->pshare->iot_mode_enable && !priv->pshare->aggrmax_change) {
+			RTL_W16(0x4ca, 0x0404);
+			priv->pshare->aggrmax_change = 1;
+		}
+		else if (priv->pshare->iot_mode_enable && priv->pshare->aggrmax_change) {
+			RTL_W16(0x4ca, priv->pshare->aggrmax_bak);
+			priv->pshare->aggrmax_change = 0;
+		}
+	} 
+#endif
+#ifdef TX_EARLY_MODE
+		unsigned int em_tp = ((priv->ext_stats.tx_avarage>>17) + (priv->ext_stats.rx_avarage>>17));
+		if (em_tp > 80)
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (0x5e << 16) | (4 << 12) | (3 << 8) | 0x19);
+		else //if (em_tp < 75)
+			ODM_Write4Byte(pDM_Odm, ODM_EDCA_BE_PARAM, (0x5e << 16) | (6 << 12) | (5 << 8) | 0x2b);
+#endif
+	if (switch_turbo)
+		ODM_IotEdcaSwitch( pDM_Odm, priv->pshare->iot_mode_enable );
+#endif
+}
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_EdcaTurboCheck.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_EdcaTurboCheck.h
new file mode 100644
index 000000000000..4557d158ce99
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_EdcaTurboCheck.h
@@ -0,0 +1,152 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMEDCATURBOCHECK_H__
+#define    __PHYDMEDCATURBOCHECK_H__
+
+#define EDCATURBO_VERSION	"1.0"
+
+typedef struct _EDCA_TURBO_
+{
+	BOOLEAN bCurrentTurboEDCA;
+	BOOLEAN bIsCurRDLState;
+
+	#if(DM_ODM_SUPPORT_TYPE == ODM_CE	)
+	u4Byte	prv_traffic_idx; // edca turbo
+	#endif
+
+}EDCA_T,*pEDCA_T;
+
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+static u4Byte edca_setting_UL[HT_IOT_PEER_MAX] = 
+// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MERU        MARVELL	92U_AP		SELF_AP(DownLink/Tx)
+{ 0x5e4322, 		0xa44f, 		0x5e4322,		0x5ea32b,  		0x5ea422, 	0x5ea322,	0x3ea430,	0x5ea42b, 0x5ea44f,	0x5e4322,	0x5e4322};
+
+
+static u4Byte edca_setting_DL[HT_IOT_PEER_MAX] = 
+// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MERU,       MARVELL	92U_AP		SELF_AP(UpLink/Rx)
+{ 0xa44f, 		0x5ea44f, 	0x5e4322, 		0x5ea42b, 		0xa44f, 		0xa630, 		0x5ea630,	0x5ea42b, 0xa44f,		0xa42b,		0xa42b};
+
+static u4Byte edca_setting_DL_GMode[HT_IOT_PEER_MAX] = 
+// UNKNOWN		REALTEK_90	REALTEK_92SE	BROADCOM		RALINK		ATHEROS		CISCO		MERU,       MARVELL	92U_AP		SELF_AP
+{ 0x4322, 		0xa44f, 		0x5e4322,		0xa42b, 			0x5e4322, 	0x4322, 		0xa42b,		0x5ea42b, 0xa44f,		0x5e4322,	0x5ea42b};
+
+
+//============================================================
+// EDCA Paramter for AP/ADSL   by Mingzhi 2011-11-22
+//============================================================
+#elif (DM_ODM_SUPPORT_TYPE &ODM_ADSL)
+enum qos_prio { BK, BE, VI, VO, VI_AG, VO_AG };
+
+static const struct ParaRecord rtl_ap_EDCA[] =
+{
+//ACM,AIFSN, ECWmin, ECWmax, TXOplimit
+     {0,     7,      4,      10,     0},            //BK
+     {0,     3,      4,      6,      0},             //BE
+     {0,     1,      3,      4,      188},         //VI
+     {0,     1,      2,      3,      102},         //VO
+     {0,     1,      3,      4,      94},          //VI_AG
+     {0,     1,      2,      3,      47},          //VO_AG
+};
+
+static const struct ParaRecord rtl_sta_EDCA[] =
+{
+//ACM,AIFSN, ECWmin, ECWmax, TXOplimit
+     {0,     7,      4,      10,     0},
+     {0,     3,      4,      10,     0},
+     {0,     2,      3,      4,      188},
+     {0,     2,      2,      3,      102},
+     {0,     2,      3,      4,      94},
+     {0,     2,      2,      3,      47},
+};
+#endif
+
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+#ifdef WIFI_WMM
+VOID
+ODM_IotEdcaSwitch(
+	IN		PVOID					pDM_VOID,
+	IN	unsigned char		enable
+	);
+#endif
+
+BOOLEAN
+ODM_ChooseIotMainSTA(
+	IN		PVOID					pDM_VOID,
+	IN	PSTA_INFO_T		pstat
+	);
+#endif
+
+VOID
+odm_EdcaTurboCheck(
+	IN 	PVOID	 	pDM_VOID
+	);
+VOID
+ODM_EdcaTurboInit(
+	IN 	PVOID	 	pDM_VOID
+);
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
+VOID
+odm_EdcaTurboCheckMP(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+//check if edca turbo is disabled
+BOOLEAN
+odm_IsEdcaTurboDisable(
+	IN 	PVOID	 	pDM_VOID
+);
+//choose edca paramter for special IOT case
+VOID 
+ODM_EdcaParaSelByIot(
+	IN		PVOID					pDM_VOID,
+	OUT	u4Byte		*EDCA_BE_UL,
+	OUT u4Byte		*EDCA_BE_DL
+	);
+//check if it is UL or DL
+VOID
+odm_EdcaChooseTrafficIdx( 
+	IN 	PVOID	 	pDM_VOID,
+	IN	u8Byte  			cur_tx_bytes,  
+	IN	u8Byte  			cur_rx_bytes, 
+	IN	BOOLEAN 		bBiasOnRx,
+	OUT BOOLEAN 		*pbIsCurRDLState
+	);
+
+#elif (DM_ODM_SUPPORT_TYPE==ODM_CE)
+VOID
+odm_EdcaTurboCheckCE(
+	IN 	PVOID	 	pDM_VOID
+	);
+#else
+VOID 
+odm_IotEngine(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+VOID
+odm_EdcaParaInit(
+	IN 	PVOID	 	pDM_VOID
+	);
+#endif
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_HWConfig.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_HWConfig.c
similarity index 88%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_HWConfig.c
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_HWConfig.c
index a5955ad059d7..e8dc0a60b356 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_HWConfig.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_HWConfig.c
@@ -22,8 +22,8 @@
 // include files
 //============================================================
 
-
-#include "odm_precomp.h"
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
 
 #define READ_AND_CONFIG_MP(ic, txt) (ODM_ReadAndConfig_MP_##ic##txt(pDM_Odm))
 #define READ_AND_CONFIG_TC(ic, txt) (ODM_ReadAndConfig_TC_##ic##txt(pDM_Odm))
@@ -57,13 +57,7 @@
 						
 #define GET_VERSION_MP(ic, txt) 		(ODM_GetVersion_MP_##ic##txt())
 #define GET_VERSION_TC(ic, txt) 		(ODM_GetVersion_TC_##ic##txt())
-	
-#define GET_VERSION(ic, txt) do {\
-							if (pDM_Odm->bIsMPChip)\
-								GET_VERSION_MP(ic,txt);\
-							else\
-								GET_VERSION_TC(ic,txt);\
-						} while(0)
+#define GET_VERSION(ic, txt) (pDM_Odm->bIsMPChip?GET_VERSION_MP(ic,txt):GET_VERSION_TC(ic,txt))
 
 
 u1Byte
@@ -630,7 +624,7 @@ odm_Cfo(
 	return ret_val;
 }
 
-
+#if(ODM_IC_11N_SERIES_SUPPORT == 1)
 VOID
 odm_RxPhyStatus92CSeries_Parsing(
 	IN OUT	PDM_ODM_T					pDM_Odm,
@@ -987,29 +981,7 @@ odm_RxPhyStatus92CSeries_Parsing(
 			}
 		}
 
-		//2 For dynamic ATC switch
-		if(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_ATC)
-		{
-			if(pPktinfo->bPacketMatchBSSID && ( *(pDM_Odm->mp_mode) == 0))
-			{
-				// TODO:
-				
-				//3 Update CFO report for path-A & path-B
-				 for(i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX; i++)   
-				{
-					pDM_Odm->CFO_tail[i] = (int)pPhyStaRpt->path_cfotail[i];
-			 	}
-
-				//3 Update packet counter
-				if(pDM_Odm->packetCount == 0xffffffff)
-					pDM_Odm->packetCount = 0;
-				else
-				 	pDM_Odm->packetCount++;
-				
-				//ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, 
-					//("pPhyStaRpt->path_cfotail[i] = 0x%x, pDM_Odm->CFO_tail[i] = 0x%x\n", pPhyStaRpt->path_cfotail[0], pDM_Odm->CFO_tail[1]));
-			}
-		}
+		ODM_ParsingCFO(pDM_Odm, pPktinfo, pPhyStaRpt->path_cfotail);
 		
 	}
 #if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
@@ -1020,8 +992,12 @@ odm_RxPhyStatus92CSeries_Parsing(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 		// 2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/	
 		pPhyInfo->SignalStrength = (u1Byte)(SignalScaleMapping(pDM_Odm->Adapter, PWDB_ALL));//PWDB_ALL;
+#else
+#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+		pPhyInfo->SignalStrength = (u1Byte)PWDB_ALL;
 #else
 		pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, PWDB_ALL));//PWDB_ALL;
+#endif
 #endif
 	}
 	else
@@ -1031,8 +1007,13 @@ odm_RxPhyStatus92CSeries_Parsing(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 			// 2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/	
 			pPhyInfo->SignalStrength = (u1Byte)(SignalScaleMapping(pDM_Odm->Adapter, total_rssi/=rf_rx_num));//PWDB_ALL;
+#else
+#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+			total_rssi/=rf_rx_num;
+			pPhyInfo->SignalStrength = (u1Byte)total_rssi;
 #else
 			pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, total_rssi/=rf_rx_num));
+#endif
 #endif
 		}
 	}
@@ -1050,6 +1031,8 @@ odm_RxPhyStatus92CSeries_Parsing(
 	pDM_Odm->DM_FatTable.antsel_rx_keep_2 = pPhyStaRpt->antsel_rx_keep_2;
 #endif
 }
+#endif
+
 
 #if	ODM_IC_11AC_SERIES_SUPPORT
 
@@ -1122,9 +1105,9 @@ odm_RxPhyStatusJaguarSeries_Parsing(
 		//	cck_highpwr = FALSE;
 
 		cck_agc_rpt =  pPhyStaRpt->cfosho[0] ;
-		
 		LNA_idx = ((cck_agc_rpt & 0xE0) >>5);
 		VGA_idx = (cck_agc_rpt & 0x1F); 
+		
 		if(pDM_Odm->SupportICType == ODM_RTL8812)
 		{
 			switch(LNA_idx)
@@ -1166,6 +1149,7 @@ odm_RxPhyStatusJaguarSeries_Parsing(
 			}
 			rx_pwr_all += 6;
 			PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+			
 			if(cck_highpwr == FALSE)
 			{
 				if(PWDB_ALL >= 80)
@@ -1219,13 +1203,16 @@ odm_RxPhyStatusJaguarSeries_Parsing(
 			u1Byte	SQ,SQ_rpt;			
 			
 			if((pDM_Odm->SupportPlatform == ODM_WIN) &&
-				(pDM_Odm->PatchID==RT_CID_819x_Lenovo)){
+				(pDM_Odm->PatchID==RT_CID_819x_Lenovo))
+			{
 				SQ = odm_SQ_process_patch_RT_CID_819x_Lenovo(pDM_Odm,isCCKrate,PWDB_ALL,0,0);
 			}
-			else if(pPhyInfo->RxPWDBAll > 40 && !pDM_Odm->bInHctTest){
+			else if(pPhyInfo->RxPWDBAll > 40 && !pDM_Odm->bInHctTest)
+			{
 				SQ = 100;
 			}
-			else{						
+			else
+			{						
 				SQ_rpt = pPhyStaRpt->pwdb_all;
 					
 				if(SQ_rpt > 64)
@@ -1315,10 +1302,8 @@ odm_RxPhyStatusJaguarSeries_Parsing(
 		else
 			rx_pwr_all = (((pPhyStaRpt->pwdb_all) >> 1 )& 0x7f) -110;	 //OLD FORMULA
 
-
 		PWDB_ALL_BT = PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);	
 			
-	
 		pPhyInfo->RxPWDBAll = PWDB_ALL;
 		//ODM_RT_TRACE(pDM_Odm,ODM_COMP_RSSI_MONITOR, ODM_DBG_LOUD, ("ODM OFDM RSSI=%d\n",pPhyInfo->RxPWDBAll));
 	#if (DM_ODM_SUPPORT_TYPE &  (ODM_WIN|ODM_CE))
@@ -1331,10 +1316,12 @@ odm_RxPhyStatusJaguarSeries_Parsing(
 		//	pPhyInfo->RxPWDBAll, pPhyInfo->RxMIMOSignalStrength[0], pPhyInfo->RxMIMOSignalStrength[1]);
 	
 	
-		if((pDM_Odm->SupportPlatform == ODM_WIN) &&(pDM_Odm->PatchID==19)){
+		if((pDM_Odm->SupportPlatform == ODM_WIN) &&(pDM_Odm->PatchID==19))
+		{
 			//do nothing	
 		}
-		else{//pMgntInfo->CustomerID != RT_CID_819x_Lenovo
+		else
+		{	//pMgntInfo->CustomerID != RT_CID_819x_Lenovo
 			//
 			// (4)EVM of OFDM rate
 			//
@@ -1386,7 +1373,6 @@ odm_RxPhyStatusJaguarSeries_Parsing(
 					//RT_DISP(FRX, RX_PHY_SQ, ("RXRATE=%x RXEVM=%x EVM=%s%d\n", 
 					//pPktinfo->DataRate, pPhyStaRpt->rxevm[i], "%", EVM));
 					
-					
 					{
 						if(i==ODM_RF_PATH_A) // Fill value in RFD, Get the first spatial stream only
 						{
@@ -1398,27 +1384,9 @@ odm_RxPhyStatusJaguarSeries_Parsing(
 				}
 			}
 		}
-		//2 For dynamic ATC switch
-		if(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_ATC)
-		{
-			if(pPktinfo->bPacketMatchBSSID && ( *(pDM_Odm->mp_mode) == 0) )
-			{
-				//3 Update CFO report for path-A & path-B
-				 for(i = ODM_RF_PATH_A; i < ODM_RF_PATH_MAX; i++)   
-				{
-					pDM_Odm->CFO_tail[i] = (int)pPhyStaRpt->cfotail[i];
-			 	}
 
-				//3 Update packet counter
-				if(pDM_Odm->packetCount == 0xffffffff)
-					pDM_Odm->packetCount = 0;
-				else
-				 	pDM_Odm->packetCount++;
-				
-				//ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, ODM_DBG_LOUD, 
-					//("pPhyStaRpt->path_cfotail[i] = 0x%x, pDM_Odm->CFO_tail[i] = 0x%x\n", pPhyStaRpt->path_cfotail[0], pDM_Odm->CFO_tail[1]));
-			}
-		}
+		ODM_ParsingCFO(pDM_Odm, pPktinfo, pPhyStaRpt->cfotail);
+		
 	}
 	//DbgPrint("isCCKrate= %d, pPhyInfo->SignalStrength=%d % PWDB_AL=%d rf_rx_num=%d\n", isCCKrate, pPhyInfo->SignalStrength, PWDB_ALL, rf_rx_num);
 	
@@ -1483,16 +1451,21 @@ odm_Process_RSSIForDM(
 {
 	
 	s4Byte			UndecoratedSmoothedPWDB, UndecoratedSmoothedCCK, UndecoratedSmoothedOFDM, RSSI_Ave;
-	u1Byte			isCCKrate=0;	
-	u1Byte			RSSI_max, RSSI_min, i;
+	u1Byte			i, isCCKrate=0;	
+	u1Byte			RSSI_max, RSSI_min;
 	u4Byte			OFDM_pkt=0; 
 	u4Byte			Weighting=0;
 	PSTA_INFO_T           	pEntry;
 
-
 	if(pPktinfo->StationID == 0xFF)
 		return;
 
+#if (RTL8723B_SUPPORT == 1)||(RTL8821A_SUPPORT == 1)
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	odm_S0S1_SwAntDivByCtrlFrame_ProcessRSSI(pDM_Odm, pPhyInfo, pPktinfo);
+#endif
+#endif
+
 	//
 	// 2012/05/30 MH/Luke.Lee Add some description 
 	// In windows driver: AP/IBSS mode STA
@@ -1504,9 +1477,11 @@ odm_Process_RSSIForDM(
 	//else
 		pEntry = pDM_Odm->pODM_StaInfo[pPktinfo->StationID];							
 
-	if(!IS_STA_VALID(pEntry) ){		
+	if(!IS_STA_VALID(pEntry) )
+	{		
 		return;
 	}
+
 	if((!pPktinfo->bPacketMatchBSSID) )
 	{
 		return;
@@ -1559,7 +1534,8 @@ odm_Process_RSSIForDM(
 
 		if(!isCCKrate)//ofdm rate
 		{
-			if(pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B] == 0){
+			if(pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_B] == 0)
+                        {
 				RSSI_Ave = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A];
 				pDM_Odm->RSSI_A = pPhyInfo->RxMIMOSignalStrength[ODM_RF_PATH_A];
 				pDM_Odm->RSSI_B = 0;
@@ -1684,6 +1660,7 @@ odm_Process_RSSIForDM(
 }
 
 
+#if(ODM_IC_11N_SERIES_SUPPORT ==1)
 //
 // Endianness before calling this API
 //
@@ -1695,7 +1672,7 @@ ODM_PhyStatusQuery_92CSeries(
 	IN		PODM_PACKET_INFO_T			pPktinfo
 	)
 {
-	
+
 	odm_RxPhyStatus92CSeries_Parsing(
 							pDM_Odm,
 							pPhyInfo,
@@ -1720,18 +1697,20 @@ ODM_PhyStatusQuery_92CSeries(
 			//odm_SwAntDivRSSICheck8192C(padapter, precvframe->u.hdr.attrib.RxPWDBAll);
 			#endif
 				*/
+#if (RTL8192C_SUPPORT == 1)
 				ODM_SwAntDivChkPerPktRssi(pDM_Odm,pPktinfo->StationID,pPhyInfo);
+#endif
 		}	
 	}
 	else
 	{
 		odm_Process_RSSIForDM(pDM_Odm,pPhyInfo,pPktinfo);
 	}
-	
-}
-
 
+}
+#endif
 
+#if(ODM_IC_11AC_SERIES_SUPPORT == 1)
 //
 // Endianness before calling this API
 //
@@ -1743,6 +1722,7 @@ ODM_PhyStatusQuery_JaguarSeries(
 	IN		PODM_PACKET_INFO_T			pPktinfo
 	)
 {
+
 	odm_RxPhyStatusJaguarSeries_Parsing(
 							pDM_Odm,
 							pPhyInfo,
@@ -1750,7 +1730,10 @@ ODM_PhyStatusQuery_JaguarSeries(
 							pPktinfo);
 	
 	odm_Process_RSSIForDM(pDM_Odm,pPhyInfo,pPktinfo);
+
 }
+#endif
+
 
 VOID
 ODM_PhyStatusQuery(
@@ -1760,15 +1743,15 @@ ODM_PhyStatusQuery(
 	IN		PODM_PACKET_INFO_T			pPktinfo
 	)
 {
-
+#if(ODM_IC_11AC_SERIES_SUPPORT == 1)
 	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES )
-	{
 		ODM_PhyStatusQuery_JaguarSeries(pDM_Odm,pPhyInfo,pPhyStatus,pPktinfo);
-	}
-	else
-	{
+#endif
+
+#if(ODM_IC_11N_SERIES_SUPPORT ==1)
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES )
 		ODM_PhyStatusQuery_92CSeries(pDM_Odm,pPhyInfo,pPhyStatus,pPktinfo);
-	}
+#endif
 }
 	
 // For future use.
@@ -1812,7 +1795,7 @@ ODM_ConfigRFWithHeaderFile(
 	{
 		if(ConfigType == CONFIG_RF_RADIO) {
 			if(eRFPath == ODM_RF_PATH_A)
-				READ_AND_CONFIG_MP(8723A,_RadioA_1T);
+				READ_AND_CONFIG_MP(8723A,_RadioA);
 		}
 	}
 #endif
@@ -1821,15 +1804,11 @@ ODM_ConfigRFWithHeaderFile(
 	if (pDM_Odm->SupportICType == ODM_RTL8188E)
 	{
 		if(ConfigType == CONFIG_RF_RADIO) {
-			if(eRFPath == ODM_RF_PATH_A){
-				if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
-					READ_AND_CONFIG(8188E,_RadioA_1T_ICUT);
-				else
-					READ_AND_CONFIG(8188E,_RadioA_1T);
-				}
+			if(eRFPath == ODM_RF_PATH_A)
+					READ_AND_CONFIG_MP(8188E,_RadioA);
 		}
 		else if(ConfigType == CONFIG_RF_TXPWR_LMT) {
-			READ_AND_CONFIG(8188E,_TXPWR_LMT);
+			READ_AND_CONFIG_MP(8188E,_TXPWR_LMT);
 		}
 	}
 #endif
@@ -1840,15 +1819,15 @@ ODM_ConfigRFWithHeaderFile(
 		if(ConfigType == CONFIG_RF_RADIO) {
 			if(eRFPath == ODM_RF_PATH_A)
 			{
-				READ_AND_CONFIG(8812A,_RadioA);
+				READ_AND_CONFIG_MP(8812A,_RadioA);
 			}
 			else if(eRFPath == ODM_RF_PATH_B)
 			{
-				READ_AND_CONFIG(8812A,_RadioB);
+				READ_AND_CONFIG_MP(8812A,_RadioB);
 			}
 		}
 		else if(ConfigType == CONFIG_RF_TXPWR_LMT) {
-			READ_AND_CONFIG(8812A,_TXPWR_LMT);
+			READ_AND_CONFIG_MP(8812A,_TXPWR_LMT);
 		}
 	}
 #endif
@@ -1859,18 +1838,18 @@ ODM_ConfigRFWithHeaderFile(
 		if(ConfigType == CONFIG_RF_RADIO) {
 	 		if(eRFPath == ODM_RF_PATH_A)
 			{
-				READ_AND_CONFIG(8821A,_RadioA);
+				READ_AND_CONFIG_MP(8821A,_RadioA);
 			}
 		}
 		else if(ConfigType == CONFIG_RF_TXPWR_LMT) {
 			
 			if (pDM_Odm->SupportInterface == ODM_ITRF_USB) {
 				if (pDM_Odm->ExtPA5G || pDM_Odm->ExtLNA5G)
-					READ_AND_CONFIG(8821A,_TXPWR_LMT_8811AU_FEM);
+					READ_AND_CONFIG_MP(8821A,_TXPWR_LMT_8811AU_FEM);
 				else
-					READ_AND_CONFIG(8821A,_TXPWR_LMT_8811AU_IPA);				
+					READ_AND_CONFIG_MP(8821A,_TXPWR_LMT_8811AU_IPA);				
 			} else {
-				READ_AND_CONFIG(8821A,_TXPWR_LMT_8821A);			
+				READ_AND_CONFIG_MP(8821A,_TXPWR_LMT_8821A);			
 			}
 		}
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("<===8821_ODM_ConfigRFWithHeaderFile\n"));
@@ -1881,10 +1860,10 @@ ODM_ConfigRFWithHeaderFile(
 	if (pDM_Odm->SupportICType == ODM_RTL8723B)
 	{
 		if(ConfigType == CONFIG_RF_RADIO) {
-			READ_AND_CONFIG(8723B,_RadioA);
+			READ_AND_CONFIG_MP(8723B,_RadioA);
 		}
 		else if(ConfigType == CONFIG_RF_TXPWR_LMT) {
-			READ_AND_CONFIG(8723B,_TXPWR_LMT);
+			READ_AND_CONFIG_MP(8723B,_TXPWR_LMT);
 		}
 	}
 #endif
@@ -1894,18 +1873,18 @@ ODM_ConfigRFWithHeaderFile(
 	{
 		if(ConfigType == CONFIG_RF_RADIO) {
 		 	if(eRFPath == ODM_RF_PATH_A)
-				READ_AND_CONFIG(8192E,_RadioA);
+				READ_AND_CONFIG_MP(8192E,_RadioA);
 			else if(eRFPath == ODM_RF_PATH_B)
-				READ_AND_CONFIG(8192E,_RadioB);
+				READ_AND_CONFIG_MP(8192E,_RadioB);
 		}
 		else if(ConfigType == CONFIG_RF_TXPWR_LMT) {
-			READ_AND_CONFIG(8192E,_TXPWR_LMT);
+			READ_AND_CONFIG_MP(8192E,_TXPWR_LMT);
 		}
 	}
 #endif
 
-#if (RTL8813A_SUPPORT == 1)
-	if (pDM_Odm->SupportICType == ODM_RTL8813A)
+#if (RTL8814A_SUPPORT == 1)
+	if (pDM_Odm->SupportICType == ODM_RTL8814A)
 	{
 		/*
 		if(ConfigType == CONFIG_RF_TXPWR_LMT) {
@@ -1928,7 +1907,6 @@ ODM_ConfigRFWithTxPwrTrackHeaderFile(
    	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, 
 				 ("pDM_Odm->SupportPlatform: 0x%X, pDM_Odm->SupportInterface: 0x%X, pDM_Odm->BoardType: 0x%X\n",
 				 pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface, pDM_Odm->BoardType));
-
 	if(0)
 	{
 	}
@@ -1936,23 +1914,23 @@ ODM_ConfigRFWithTxPwrTrackHeaderFile(
 	else if(pDM_Odm->SupportICType == ODM_RTL8821)
 	{
 		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
-			READ_AND_CONFIG(8821A,_TxPowerTrack_PCIE);
+			READ_AND_CONFIG_MP(8821A,_TxPowerTrack_PCIE);
 		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
-			READ_AND_CONFIG(8821A,_TxPowerTrack_USB);
+			READ_AND_CONFIG_MP(8821A,_TxPowerTrack_USB);
 		else
-			READ_AND_CONFIG(8821A,_TxPowerTrack_PCIE);
+			READ_AND_CONFIG_MP(8821A,_TxPowerTrack_PCIE);
 	}
 #endif
 #if (RTL8812A_SUPPORT == 1)
 	else if(pDM_Odm->SupportICType == ODM_RTL8812)
 	{
 		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
-			READ_AND_CONFIG(8812A,_TxPowerTrack_PCIE);
+			READ_AND_CONFIG_MP(8812A,_TxPowerTrack_PCIE);
 		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB) {
 			if (pDM_Odm->RFEType == 3 && pDM_Odm->bIsMPChip) 
 				READ_AND_CONFIG_MP(8812A,_TxPowerTrack_RFE3);	
 			else
-				READ_AND_CONFIG(8812A,_TxPowerTrack_USB);	
+				READ_AND_CONFIG_MP(8812A,_TxPowerTrack_USB);	
 		}
 		
 	}
@@ -1961,29 +1939,31 @@ ODM_ConfigRFWithTxPwrTrackHeaderFile(
 	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
 	{
 		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
-			READ_AND_CONFIG(8192E,_TxPowerTrack_PCIE);
+			READ_AND_CONFIG_MP(8192E,_TxPowerTrack_PCIE);
 		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
-			READ_AND_CONFIG(8192E,_TxPowerTrack_USB); 
+			READ_AND_CONFIG_MP(8192E,_TxPowerTrack_USB); 
 	}
 #endif
 #if RTL8723B_SUPPORT 	
 	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
 	{
 		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
-			READ_AND_CONFIG(8723B,_TxPowerTrack_PCIE);
+			READ_AND_CONFIG_MP(8723B,_TxPowerTrack_PCIE);
 		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
-			READ_AND_CONFIG(8723B,_TxPowerTrack_USB);
+			READ_AND_CONFIG_MP(8723B,_TxPowerTrack_USB);
 		else if (pDM_Odm->SupportInterface == ODM_ITRF_SDIO)
-			READ_AND_CONFIG(8723B,_TxPowerTrack_SDIO); 			
+			READ_AND_CONFIG_MP(8723B,_TxPowerTrack_SDIO); 			
 	}
 #endif	
 #if RTL8188E_SUPPORT 	
 	else if(pDM_Odm->SupportICType == ODM_RTL8188E)
 	{
 		if (pDM_Odm->SupportInterface == ODM_ITRF_PCIE)
-			READ_AND_CONFIG(8188E,_TxPowerTrack_PCIE);
+			READ_AND_CONFIG_MP(8188E,_TxPowerTrack_PCIE);
 		else if (pDM_Odm->SupportInterface == ODM_ITRF_USB)
-			READ_AND_CONFIG(8188E,_TxPowerTrack_USB);
+			READ_AND_CONFIG_MP(8188E,_TxPowerTrack_USB);
+		else
+			READ_AND_CONFIG_MP(8188E,_TxPowerTrack_PCIE);
 	}
 #endif
 
@@ -2014,11 +1994,11 @@ ODM_ConfigBBWithHeaderFile(
 	{
 		if(ConfigType == CONFIG_BB_PHY_REG)
 		{
-			READ_AND_CONFIG_MP(8723A,_PHY_REG_1T);
+			READ_AND_CONFIG_MP(8723A,_PHY_REG);
 		}
 		else if(ConfigType == CONFIG_BB_AGC_TAB)
 		{
-			READ_AND_CONFIG_MP(8723A,_AGC_TAB_1T);
+			READ_AND_CONFIG_MP(8723A,_AGC_TAB);
 		}
 	}		
 #endif
@@ -2028,21 +2008,15 @@ ODM_ConfigBBWithHeaderFile(
 	{
 		if(ConfigType == CONFIG_BB_PHY_REG)
 		{
-			if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
-				READ_AND_CONFIG(8188E,_PHY_REG_1T_ICUT);
-			else
-				READ_AND_CONFIG(8188E,_PHY_REG_1T);
+				READ_AND_CONFIG_MP(8188E,_PHY_REG);
 		}
 		else if(ConfigType == CONFIG_BB_AGC_TAB)
 		{
-			if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
-				READ_AND_CONFIG(8188E,_AGC_TAB_1T_ICUT);
-			else
-				READ_AND_CONFIG(8188E,_AGC_TAB_1T);
+				READ_AND_CONFIG_MP(8188E,_AGC_TAB);
 		}
 		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
 		{
-			READ_AND_CONFIG(8188E,_PHY_REG_PG);
+			READ_AND_CONFIG_MP(8188E,_PHY_REG_PG);
 		}
 	}
 #endif
@@ -2052,11 +2026,11 @@ ODM_ConfigBBWithHeaderFile(
 	{
 		if(ConfigType == CONFIG_BB_PHY_REG)
 		{
-			READ_AND_CONFIG(8812A,_PHY_REG);
+			READ_AND_CONFIG_MP(8812A,_PHY_REG);
 		}
 		else if(ConfigType == CONFIG_BB_AGC_TAB)
 		{
-			READ_AND_CONFIG(8812A,_AGC_TAB);
+			READ_AND_CONFIG_MP(8812A,_AGC_TAB);
 		}
 		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
 		{
@@ -2067,7 +2041,7 @@ ODM_ConfigBBWithHeaderFile(
 				READ_AND_CONFIG_MP(8812A,_PHY_REG_PG_NEC);
 #endif			
 			else
-				READ_AND_CONFIG(8812A,_PHY_REG_PG);
+				READ_AND_CONFIG_MP(8812A,_PHY_REG_PG);
 		}
 		else if(ConfigType == CONFIG_BB_PHY_REG_MP)
 		{
@@ -2088,15 +2062,15 @@ ODM_ConfigBBWithHeaderFile(
 	{
 		if(ConfigType == CONFIG_BB_PHY_REG)
 		{
-			READ_AND_CONFIG(8821A,_PHY_REG);
+			READ_AND_CONFIG_MP(8821A,_PHY_REG);
 		}
 		else if(ConfigType == CONFIG_BB_AGC_TAB)
 		{
-			READ_AND_CONFIG(8821A,_AGC_TAB);
+			READ_AND_CONFIG_MP(8821A,_AGC_TAB);
 		}
 		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
 		{
-			READ_AND_CONFIG(8821A,_PHY_REG_PG);
+			READ_AND_CONFIG_MP(8821A,_PHY_REG_PG);
 		}
 	}
 #endif
@@ -2106,15 +2080,15 @@ ODM_ConfigBBWithHeaderFile(
 
 		if(ConfigType == CONFIG_BB_PHY_REG)
 		{
-			READ_AND_CONFIG(8723B,_PHY_REG);
+			READ_AND_CONFIG_MP(8723B,_PHY_REG);
 		}
 		else if(ConfigType == CONFIG_BB_AGC_TAB)
 		{
-			READ_AND_CONFIG(8723B,_AGC_TAB);
+			READ_AND_CONFIG_MP(8723B,_AGC_TAB);
 		}
 		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
 		{
-			READ_AND_CONFIG(8723B,_PHY_REG_PG);
+			READ_AND_CONFIG_MP(8723B,_PHY_REG_PG);
 		}
 	}
 #endif
@@ -2124,20 +2098,20 @@ ODM_ConfigBBWithHeaderFile(
 
 		if(ConfigType == CONFIG_BB_PHY_REG)
 		{
-			READ_AND_CONFIG(8192E,_PHY_REG);
+			READ_AND_CONFIG_MP(8192E,_PHY_REG);
 		}
 		else if(ConfigType == CONFIG_BB_AGC_TAB)
 		{
-			READ_AND_CONFIG(8192E,_AGC_TAB);
+			READ_AND_CONFIG_MP(8192E,_AGC_TAB);
 		}
 		else if(ConfigType == CONFIG_BB_PHY_REG_PG)
 		{
-			READ_AND_CONFIG(8192E,_PHY_REG_PG);
+			READ_AND_CONFIG_MP(8192E,_PHY_REG_PG);
 		}
 	}
 #endif
-#if (RTL8813A_SUPPORT == 1)
-    if(pDM_Odm->SupportICType == ODM_RTL8813A)
+#if (RTL8814A_SUPPORT == 1)
+    if(pDM_Odm->SupportICType == ODM_RTL8814A)
 	{
 
 		if(ConfigType == CONFIG_BB_PHY_REG)
@@ -2182,22 +2156,19 @@ ODM_ConfigMACWithHeaderFile(
 #if (RTL8188E_SUPPORT == 1)  
 	if (pDM_Odm->SupportICType == ODM_RTL8188E)
 	{
-		if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
-			result = READ_AND_CONFIG(8188E,_MAC_REG_ICUT);
-		else
-			result = READ_AND_CONFIG(8188E,_MAC_REG);
+		READ_AND_CONFIG_MP(8188E,_MAC_REG);
 	}
 #endif
 #if (RTL8812A_SUPPORT == 1)
 	if (pDM_Odm->SupportICType == ODM_RTL8812)
 	{
-		READ_AND_CONFIG(8812A,_MAC_REG);
+		READ_AND_CONFIG_MP(8812A,_MAC_REG);
 	}
 #endif
 #if (RTL8821A_SUPPORT == 1)
 	if (pDM_Odm->SupportICType == ODM_RTL8821)
 	{
-		READ_AND_CONFIG(8821A,_MAC_REG);
+		READ_AND_CONFIG_MP(8821A,_MAC_REG);
 
 		ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("<===8821_ODM_ConfigMACwithHeaderFile\n"));
 	}
@@ -2205,13 +2176,13 @@ ODM_ConfigMACWithHeaderFile(
 #if (RTL8723B_SUPPORT == 1)  
 	if (pDM_Odm->SupportICType == ODM_RTL8723B)
 	{
-		READ_AND_CONFIG(8723B,_MAC_REG);
+		READ_AND_CONFIG_MP(8723B,_MAC_REG);
 	}
 #endif
 #if (RTL8192E_SUPPORT == 1)  
 	if (pDM_Odm->SupportICType == ODM_RTL8192E)
 	{
-		READ_AND_CONFIG(8192E,_MAC_REG);
+		READ_AND_CONFIG_MP(8192E,_MAC_REG);
 	}
 #endif
 
@@ -2230,22 +2201,33 @@ ODM_ConfigFWWithHeaderFile(
 #if (RTL8188E_SUPPORT == 1)  
 	if (pDM_Odm->SupportICType == ODM_RTL8188E)
 	{
+	#ifdef CONFIG_SFW_SUPPORTED
 		if (ConfigType == CONFIG_FW_NIC)
 		{
-			READ_FIRMWARE(8188E,_FW_NIC_T);
+			READ_FIRMWARE_MP(8188E,_FW_NIC_T);
 		}
 		else if (ConfigType == CONFIG_FW_WoWLAN)
 		{
-			READ_FIRMWARE(8188E,_FW_WoWLAN_T);
+			READ_FIRMWARE_MP(8188E,_FW_WoWLAN_T);
 		}
 		else if(ConfigType == CONFIG_FW_NIC_2)
 		{
-			READ_FIRMWARE(8188E,_FW_NIC_S);
+			READ_FIRMWARE_MP(8188E,_FW_NIC_S);
 		}
 		else if (ConfigType == CONFIG_FW_WoWLAN_2)
 		{
-			READ_FIRMWARE(8188E,_FW_WoWLAN_S);
+			READ_FIRMWARE_MP(8188E,_FW_WoWLAN_S);
 		}
+	#else
+		if (ConfigType == CONFIG_FW_NIC)
+		{
+			READ_FIRMWARE_MP(8188E,_FW_NIC);
+		}
+		else if (ConfigType == CONFIG_FW_WoWLAN)
+		{
+			READ_FIRMWARE_MP(8188E,_FW_WoWLAN);
+		}
+	#endif
 	}
 #endif
 #if (RTL8723B_SUPPORT == 1)  
@@ -2253,11 +2235,11 @@ ODM_ConfigFWWithHeaderFile(
 	{
 		if (ConfigType == CONFIG_FW_NIC)
 		{
-			READ_FIRMWARE(8723B,_FW_NIC);
+			READ_FIRMWARE_MP(8723B,_FW_NIC);
 		}
 		else if (ConfigType == CONFIG_FW_WoWLAN)
 		{
-			READ_FIRMWARE(8723B,_FW_WoWLAN);
+			READ_FIRMWARE_MP(8723B,_FW_WoWLAN);
 		}
 #ifdef CONFIG_AP_WOWLAN
 		else if (ConfigType == CONFIG_FW_AP_WoWLAN)
@@ -2280,15 +2262,15 @@ ODM_ConfigFWWithHeaderFile(
 	{
 		if (ConfigType == CONFIG_FW_NIC)
 		{
-			READ_FIRMWARE(8812A,_FW_NIC);
+			READ_FIRMWARE_MP(8812A,_FW_NIC);
 		}
 		else if (ConfigType == CONFIG_FW_WoWLAN)
 		{
-			READ_FIRMWARE(8812A,_FW_WoWLAN);
+			READ_FIRMWARE_MP(8812A,_FW_WoWLAN);
 		}
 		else if (ConfigType == CONFIG_FW_BT)
 		{
-			READ_FIRMWARE(8812A,_FW_NIC_BT);
+			READ_FIRMWARE_MP(8812A,_FW_NIC_BT);
 		}
 
 	}
@@ -2302,7 +2284,7 @@ ODM_ConfigFWWithHeaderFile(
 		}
 		else if (ConfigType == CONFIG_FW_WoWLAN)
 		{
-			READ_FIRMWARE(8821A,_FW_WoWLAN);
+			READ_FIRMWARE_MP(8821A,_FW_WoWLAN);
 		}
 		else if (ConfigType == CONFIG_FW_BT)
 		{
@@ -2315,16 +2297,16 @@ ODM_ConfigFWWithHeaderFile(
 	{
 		if (ConfigType == CONFIG_FW_NIC)
 		{
-			READ_FIRMWARE(8192E,_FW_NIC);
+			READ_FIRMWARE_MP(8192E,_FW_NIC);
 		}
 		else if (ConfigType == CONFIG_FW_WoWLAN)
 		{
-			READ_FIRMWARE(8192E,_FW_WoWLAN);
+			READ_FIRMWARE_MP(8192E,_FW_WoWLAN);
 		}
 #ifdef CONFIG_AP_WOWLAN
 		else if (ConfigType == CONFIG_FW_AP_WoWLAN)
 		{
-			READ_FIRMWARE(8192E,_FW_AP_WoWLAN);
+			READ_FIRMWARE_MP(8192E,_FW_AP_WoWLAN);
 		}
 #endif
 
@@ -2339,13 +2321,39 @@ ODM_GetHWImgVersion(
 	IN	PDM_ODM_T	pDM_Odm
 	)
 {
+    u4Byte  Version=0;
+
+#if (RTL8723A_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8723A)
+		Version = GET_VERSION_MP(8723A,_MAC_REG);
+#endif
+
+#if (RTL8723B_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8723B)
+		Version = GET_VERSION_MP(8723B,_MAC_REG);
+#endif
+
+#if (RTL8188E_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8188E)
+		Version = GET_VERSION_MP(8188E,_MAC_REG);
+#endif
+
+#if (RTL8821A_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8821)
+		Version = GET_VERSION_MP(8821A,_MAC_REG);
+#endif
+
+#if (RTL8192E_SUPPORT == 1)  
+	if (pDM_Odm->SupportICType == ODM_RTL8192E)
+		Version = GET_VERSION_MP(8192E,_MAC_REG);
+#endif
 
 #if (RTL8812A_SUPPORT == 1)  
 	if (pDM_Odm->SupportICType == ODM_RTL8812)
-		return GET_VERSION_MP(8812A,_MAC_REG);
+		Version = GET_VERSION_MP(8812A,_MAC_REG);
 #endif
 
-	return 0;
+	return Version;
 }
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_HWConfig.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_HWConfig.h
similarity index 93%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_HWConfig.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_HWConfig.h
index 16a26f6da780..da0e5fc1cfce 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_HWConfig.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_HWConfig.h
@@ -24,7 +24,7 @@
 
 
 /*--------------------------Define -------------------------------------------*/ 
-#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
+//#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
 #define AGC_DIFF_CONFIG_MP(ic, band) (ODM_ReadAndConfig_MP_##ic##_AGC_TAB_DIFF(pDM_Odm, Array_MP_##ic##_AGC_TAB_DIFF_##band, \
                                                                               sizeof(Array_MP_##ic##_AGC_TAB_DIFF_##band)/sizeof(u4Byte)))
 #define AGC_DIFF_CONFIG_TC(ic, band) (ODM_ReadAndConfig_TC_##ic##_AGC_TAB_DIFF(pDM_Odm, Array_TC_##ic##_AGC_TAB_DIFF_##band, \
@@ -225,6 +225,12 @@ ODM_GetHWImgVersion(
 	IN	PDM_ODM_T	pDM_Odm
 	);
 
+s4Byte
+odm_SignalScaleMapping(	
+	IN OUT PDM_ODM_T pDM_Odm,
+	IN	s4Byte CurrSig 
+	);
+
 #endif
 
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.c
new file mode 100644
index 000000000000..f8c207b09907
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.c
@@ -0,0 +1,197 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+//#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+//=================================================
+// This function is for inband noise test utility only
+// To obtain the inband noise level(dbm), do the following.
+// 1. disable DIG and Power Saving 
+// 2. Set initial gain = 0x1a
+// 3. Stop updating idle time pwer report (for driver read)
+//	- 0x80c[25]
+//
+//=================================================
+
+#define Valid_Min				-35
+#define Valid_Max			10
+#define ValidCnt				5	
+
+s2Byte odm_InbandNoise_Monitor_NSeries(PDM_ODM_T	pDM_Odm,u8 bPauseDIG,u8 IGIValue,u32 max_time)
+{
+	u4Byte				tmp4b;	
+	u1Byte				max_rf_path=0,rf_path;	
+	u1Byte				reg_c50, reg_c58,valid_done=0;	
+	struct noise_level		noise_data;
+	u32 start  = 0, 	func_start=0,	func_end = 0;
+
+	func_start = ODM_GetCurrentTime(pDM_Odm);
+	pDM_Odm->noise_level.noise_all = 0;
+	
+	if((pDM_Odm->RFType == ODM_1T2R) ||(pDM_Odm->RFType == ODM_2T2R))	
+		max_rf_path = 2;
+	else
+		max_rf_path = 1;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("odm_DebugControlInbandNoise_Nseries() ==> \n"));
+
+	ODM_Memory_Set(pDM_Odm,&noise_data,0,sizeof(struct noise_level));
+	
+	//
+	// Step 1. Disable DIG && Set initial gain.
+	//
+	
+	if(bPauseDIG)
+	{
+		odm_PauseDIG(pDM_Odm,ODM_PAUSE_DIG,IGIValue);
+	}
+	//
+	// Step 2. Disable all power save for read registers
+	//
+	//dcmd_DebugControlPowerSave(pAdapter, PSDisable);
+
+	//
+	// Step 3. Get noise power level
+	//
+	start = ODM_GetCurrentTime(pDM_Odm);
+	while(1)
+	{
+		
+		//Stop updating idle time pwer report (for driver read)
+		ODM_SetBBReg(pDM_Odm, rFPGA0_TxGainStage, BIT25, 1);	
+		
+		//Read Noise Floor Report
+		tmp4b = ODM_GetBBReg(pDM_Odm, 0x8f8,bMaskDWord );
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("Noise Floor Report (0x8f8) = 0x%08x\n", tmp4b));
+		
+		//ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0, TestInitialGain);
+		//if(max_rf_path == 2)
+		//	ODM_SetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0, TestInitialGain);
+		
+		//update idle time pwer report per 5us
+		ODM_SetBBReg(pDM_Odm, rFPGA0_TxGainStage, BIT25, 0);
+		
+		noise_data.value[ODM_RF_PATH_A] = (u1Byte)(tmp4b&0xff);		
+		noise_data.value[ODM_RF_PATH_B]  = (u1Byte)((tmp4b&0xff00)>>8);
+	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("value_a = 0x%x(%d), value_b = 0x%x(%d)\n", 
+			noise_data.value[ODM_RF_PATH_A], noise_data.value[ODM_RF_PATH_A], noise_data.value[ODM_RF_PATH_B], noise_data.value[ODM_RF_PATH_B]));
+
+		 for(rf_path = ODM_RF_PATH_A; rf_path < max_rf_path; rf_path++) 
+		 {
+		 	noise_data.sval[rf_path] = (s1Byte)noise_data.value[rf_path];
+			noise_data.sval[rf_path] /= 2;
+		 }	
+		 	
+		
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("sval_a = %d, sval_b = %d\n", 
+			noise_data.sval[ODM_RF_PATH_A], noise_data.sval[ODM_RF_PATH_B]));
+		//ODM_delay_ms(10);
+		//ODM_sleep_ms(10);
+
+		for(rf_path = ODM_RF_PATH_A; rf_path < max_rf_path; rf_path++) 
+		{
+			if( (noise_data.valid_cnt[rf_path] < ValidCnt) && (noise_data.sval[rf_path] < Valid_Max && noise_data.sval[rf_path] >= Valid_Min))
+			{
+				noise_data.valid_cnt[rf_path]++;
+				noise_data.sum[rf_path] += noise_data.sval[rf_path];
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("RF_Path:%d Valid sval = %d\n", rf_path,noise_data.sval[rf_path]));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("Sum of sval = %d, \n", noise_data.sum[rf_path]));
+				if(noise_data.valid_cnt[rf_path] == ValidCnt)
+				{				
+					valid_done++;
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("After divided, RF_Path:%d ,sum = %d \n", rf_path,noise_data.sum[rf_path]));
+				}				
+			
+			}
+			
+		}
+
+		//printk("####### valid_done:%d #############\n",valid_done);
+		if ((valid_done==max_rf_path) || (ODM_GetProgressingTime(pDM_Odm,start) > max_time))
+		{
+			for(rf_path = ODM_RF_PATH_A; rf_path < max_rf_path; rf_path++)
+			{ 
+				//printk("%s PATH_%d - sum = %d, valid_cnt = %d \n",__FUNCTION__,rf_path,noise_data.sum[rf_path], noise_data.valid_cnt[rf_path]);
+				if(noise_data.valid_cnt[rf_path])
+					noise_data.sum[rf_path] /= noise_data.valid_cnt[rf_path];		
+				else
+					noise_data.sum[rf_path]  = 0;
+			}
+			break;
+		}
+	}
+	reg_c50 = (s4Byte)ODM_GetBBReg(pDM_Odm,rOFDM0_XAAGCCore1,bMaskByte0);
+	reg_c50 &= ~BIT7;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("0x%x = 0x%02x(%d)\n", rOFDM0_XAAGCCore1, reg_c50, reg_c50));
+	pDM_Odm->noise_level.noise[ODM_RF_PATH_A] = -110 + reg_c50 + noise_data.sum[ODM_RF_PATH_A];
+	pDM_Odm->noise_level.noise_all += pDM_Odm->noise_level.noise[ODM_RF_PATH_A];
+		
+	if(max_rf_path == 2){
+		reg_c58 = (s4Byte)ODM_GetBBReg(pDM_Odm,rOFDM0_XBAGCCore1,bMaskByte0);
+		reg_c58 &= ~BIT7;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("0x%x = 0x%02x(%d)\n", rOFDM0_XBAGCCore1, reg_c58, reg_c58));
+		pDM_Odm->noise_level.noise[ODM_RF_PATH_B] = -110 + reg_c58 + noise_data.sum[ODM_RF_PATH_B];
+		pDM_Odm->noise_level.noise_all += pDM_Odm->noise_level.noise[ODM_RF_PATH_B];
+	}
+	pDM_Odm->noise_level.noise_all /= max_rf_path;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("noise_a = %d, noise_b = %d\n", 
+		pDM_Odm->noise_level.noise[ODM_RF_PATH_A],
+		pDM_Odm->noise_level.noise[ODM_RF_PATH_B]));
+
+	//
+	// Step 4. Recover the Dig
+	//
+	if(bPauseDIG)
+	{
+		odm_PauseDIG(pDM_Odm,ODM_RESUME_DIG,IGIValue);
+	}	
+	func_end = ODM_GetProgressingTime(pDM_Odm,func_start) ;	
+	//printk("%s noise_a = %d, noise_b = %d noise_all:%d (%d ms)\n",__FUNCTION__,
+	//	pDM_Odm->noise_level.noise[ODM_RF_PATH_A],
+	//	pDM_Odm->noise_level.noise[ODM_RF_PATH_B],
+	//	pDM_Odm->noise_level.noise_all,func_end);	
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD,("odm_DebugControlInbandNoise_Nseries() <== \n"));
+	return pDM_Odm->noise_level.noise_all;
+
+}
+s2Byte ODM_InbandNoise_Monitor(PVOID pDM_VOID,u8 bPauseDIG,u8 IGIValue,u32 max_time)
+{
+
+	PDM_ODM_T	pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES )
+	{
+		//odm_InbandNoise_Monitor_JaguarSeries(pDM_Odm,bPauseDIG,IGIValue,max_time);
+		return 0;
+	}
+	else
+	{
+		return odm_InbandNoise_Monitor_NSeries(pDM_VOID,bPauseDIG,IGIValue,max_time);
+	}
+}
+
+
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.h
new file mode 100644
index 000000000000..6625be61633a
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_NoiseMonitor.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ *****************************************************************************/
+#ifndef	__ODMNOISEMONITOR_H__
+#define __ODMNOISEMONITOR_H__
+
+#define	ODM_MAX_CHANNEL_NUM					38//14+24
+struct noise_level
+{
+	//u1Byte				value_a, value_b;
+	u1Byte				value[MAX_RF_PATH];
+	//s1Byte				sval_a, sval_b;
+	s1Byte				sval[MAX_RF_PATH];
+	
+	//s4Byte				noise_a=0, noise_b=0,sum_a=0, sum_b=0;
+	//s4Byte				noise[ODM_RF_PATH_MAX];
+	s4Byte				sum[MAX_RF_PATH];
+	//u1Byte				valid_cnt_a=0, valid_cnt_b=0, 
+	u1Byte				valid[MAX_RF_PATH];
+	u1Byte				valid_cnt[MAX_RF_PATH];
+
+};
+
+
+typedef struct _ODM_NOISE_MONITOR_
+{
+	s1Byte			noise[MAX_RF_PATH];
+	s2Byte			noise_all;	
+}ODM_NOISE_MONITOR;
+
+s2Byte ODM_InbandNoise_Monitor(PVOID pDM_VOID,u8 bPauseDIG,u8 IGIValue,u32 max_time);
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PathDiv.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PathDiv.c
new file mode 100644
index 000000000000..3bbea923f5af
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PathDiv.c
@@ -0,0 +1,1585 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+
+
+VOID
+odm_PathDiversityInit(
+	IN	PVOID	pDM_VOID
+)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	if(pDM_Odm->mp_mode == TRUE)
+		return;
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_PATH_DIV))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("Return: Not Support PathDiv\n"));
+		return;
+	}
+
+	#if RTL8812A_SUPPORT
+	if(pDM_Odm->SupportICType & ODM_RTL8812)
+		ODM_PathDiversityInit_8812A(pDM_Odm);
+	#endif
+#endif
+}
+
+VOID
+odm_PathDiversity(
+	IN	PVOID	pDM_VOID
+)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if(!(pDM_Odm->SupportAbility & ODM_BB_PATH_DIV))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_PATH_DIV,ODM_DBG_LOUD,("Return: Not Support PathDiv\n"));
+		return;
+	}
+
+#if RTL8812A_SUPPORT
+
+	if(pDM_Odm->SupportICType & ODM_RTL8812)
+		ODM_PathDiversity_8812A(pDM_Odm);
+#endif	
+#endif  //(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+}
+
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+//
+// 2011/12/02 MH Copy from MP oursrc for temporarily test.
+//
+
+BOOLEAN
+odm_IsConnected_92C(
+	IN	PADAPTER	Adapter
+)
+{
+	PRT_WLAN_STA	pEntry;
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	u4Byte		i;
+	BOOLEAN		bConnected=FALSE;
+	
+	if(pMgntInfo->mAssoc)
+	{
+		bConnected = TRUE;
+	}
+	else
+	{
+		for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+		{
+			if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+				pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
+			else
+				pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
+
+			if(pEntry!=NULL)
+			{
+				if(pEntry->bAssociated)
+				{
+					bConnected = TRUE;
+					break;
+				}
+			}
+			else
+			{
+				break;
+			}
+		}
+	}
+	return	bConnected;
+}
+
+BOOLEAN
+ODM_PathDiversityBeforeLink92C(
+	//IN	PADAPTER	Adapter
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+#if (RT_MEM_SIZE_LEVEL != RT_MEM_SIZE_MINIMUM)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE*	pHalData = NULL;
+	PMGNT_INFO		pMgntInfo = NULL;
+	//pSWAT_T		pDM_SWAT_Table = &Adapter->DM_SWAT_Table;
+	pPD_T			pDM_PDTable = NULL;
+
+	s1Byte			Score = 0;
+	PRT_WLAN_BSS	pTmpBssDesc;
+	PRT_WLAN_BSS	pTestBssDesc;
+
+	u1Byte			target_chnl = 0;
+	u2Byte			index;
+
+	if (pDM_Odm->Adapter == NULL)  //For BSOD when plug/unplug fast.  //By YJ,120413
+	{	// The ODM structure is not initialized.
+		return FALSE;
+	}
+	pHalData = GET_HAL_DATA(Adapter);
+	pMgntInfo = &Adapter->MgntInfo;
+	pDM_PDTable = &Adapter->DM_PDTable;
+	
+	// Condition that does not need to use path diversity.
+	if((!(pHalData->CVID_Version==VERSION_1_BEFORE_8703B && IS_92C_SERIAL(pHalData->VersionID))) || (pHalData->PathDivCfg!=1) || pMgntInfo->AntennaTest )
+	{
+		RT_TRACE(COMP_INIT, DBG_LOUD, 
+				("ODM_PathDiversityBeforeLink92C(): No PathDiv Mechanism before link.\n"));
+		return FALSE;
+	}
+
+	// Since driver is going to set BB register, it shall check if there is another thread controlling BB/RF.
+	PlatformAcquireSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	if(pHalData->eRFPowerState!=eRfOn || pMgntInfo->RFChangeInProgress || pMgntInfo->bMediaConnect)
+	{
+		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	
+		RT_TRACE(COMP_INIT, DBG_LOUD, 
+				("ODM_PathDiversityBeforeLink92C(): RFChangeInProgress(%x), eRFPowerState(%x)\n", 
+				pMgntInfo->RFChangeInProgress,
+				pHalData->eRFPowerState));
+	
+		//pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		pDM_PDTable->PathDiv_NoLink_State = 0;
+		
+		return FALSE;
+	}
+	else
+	{
+		PlatformReleaseSpinLock(Adapter, RT_RF_STATE_SPINLOCK);
+	}
+
+	//1 Run AntDiv mechanism "Before Link" part.
+	//if(pDM_SWAT_Table->SWAS_NoLink_State == 0)
+	if(pDM_PDTable->PathDiv_NoLink_State == 0)
+	{
+		//1 Prepare to do Scan again to check current antenna state.
+
+		// Set check state to next step.
+		//pDM_SWAT_Table->SWAS_NoLink_State = 1;
+		pDM_PDTable->PathDiv_NoLink_State = 1;
+	
+		// Copy Current Scan list.
+		Adapter->MgntInfo.tmpNumBssDesc = pMgntInfo->NumBssDesc;
+		PlatformMoveMemory((PVOID)Adapter->MgntInfo.tmpbssDesc, (PVOID)pMgntInfo->bssDesc, sizeof(RT_WLAN_BSS)*MAX_BSS_DESC);
+
+		// Switch Antenna to another one.
+		if(pDM_PDTable->DefaultRespPath == 0)
+		{
+			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x05); // TRX path = PathB
+			odm_SetRespPath_92C(Adapter, 1);
+			pDM_PDTable->OFDMTXPath = 0xFFFFFFFF;
+			pDM_PDTable->CCKTXPath = 0xFFFFFFFF;
+		}
+		else
+		{
+			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x00); // TRX path = PathA
+			odm_SetRespPath_92C(Adapter, 0);
+			pDM_PDTable->OFDMTXPath = 0x0;
+			pDM_PDTable->CCKTXPath = 0x0;
+		}
+#if 0	
+
+		pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+		pDM_SWAT_Table->CurAntenna = (pDM_SWAT_Table->CurAntenna==Antenna_A)?Antenna_B:Antenna_A;
+		
+		RT_TRACE(COMP_INIT, DBG_LOUD, 
+			("ODM_SwAntDivCheckBeforeLink: Change to Ant(%s) for testing.\n", (pDM_SWAT_Table->CurAntenna==Antenna_A)?"A":"B"));
+		//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
+		pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
+		PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
+#endif
+
+		// Go back to scan function again.
+		RT_TRACE(COMP_INIT, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C: Scan one more time\n"));
+		pMgntInfo->ScanStep=0;
+		target_chnl = odm_SwAntDivSelectScanChnl(Adapter);
+		odm_SwAntDivConstructScanChnl(Adapter, target_chnl);
+		PlatformSetTimer(Adapter, &pMgntInfo->ScanTimer, 5);
+
+		return TRUE;
+	}
+	else
+	{
+		//1 ScanComple() is called after antenna swiched.
+		//1 Check scan result and determine which antenna is going
+		//1 to be used.
+
+		for(index=0; index<Adapter->MgntInfo.tmpNumBssDesc; index++)
+		{
+			pTmpBssDesc = &(Adapter->MgntInfo.tmpbssDesc[index]);
+			pTestBssDesc = &(pMgntInfo->bssDesc[index]);
+
+			if(PlatformCompareMemory(pTestBssDesc->bdBssIdBuf, pTmpBssDesc->bdBssIdBuf, 6)!=0)
+			{
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C(): ERROR!! This shall not happen.\n"));
+				continue;
+			}
+
+			if(pTmpBssDesc->RecvSignalPower > pTestBssDesc->RecvSignalPower)
+			{
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C: Compare scan entry: Score++\n"));
+				RT_PRINT_STR(COMP_INIT, DBG_LOUD, "SSID: ", pTestBssDesc->bdSsIdBuf, pTestBssDesc->bdSsIdLen);
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+			
+				Score++;
+				PlatformMoveMemory(pTestBssDesc, pTmpBssDesc, sizeof(RT_WLAN_BSS));
+			}
+			else if(pTmpBssDesc->RecvSignalPower < pTestBssDesc->RecvSignalPower)
+			{
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("ODM_PathDiversityBeforeLink92C: Compare scan entry: Score--\n"));
+				RT_PRINT_STR(COMP_INIT, DBG_LOUD, "SSID: ", pTestBssDesc->bdSsIdBuf, pTestBssDesc->bdSsIdLen);
+				RT_TRACE(COMP_INIT, DBG_LOUD, ("Original: %d, Test: %d\n", pTmpBssDesc->RecvSignalPower, pTestBssDesc->RecvSignalPower));
+				Score--;
+			}
+
+		}
+
+		if(pMgntInfo->NumBssDesc!=0 && Score<=0)
+		{
+			RT_TRACE(COMP_INIT, DBG_LOUD,
+				("ODM_PathDiversityBeforeLink92C(): DefaultRespPath=%d\n", pDM_PDTable->DefaultRespPath));
+
+			//pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+		}
+		else
+		{
+			RT_TRACE(COMP_INIT, DBG_LOUD, 
+				("ODM_PathDiversityBeforeLink92C(): DefaultRespPath=%d\n", pDM_PDTable->DefaultRespPath));
+
+			if(pDM_PDTable->DefaultRespPath == 0)
+			{
+				pDM_PDTable->OFDMTXPath = 0xFFFFFFFF;
+				pDM_PDTable->CCKTXPath = 0xFFFFFFFF;
+				odm_SetRespPath_92C(Adapter, 1);
+			}
+			else
+			{
+				pDM_PDTable->OFDMTXPath = 0x0;
+				pDM_PDTable->CCKTXPath = 0x0;
+				odm_SetRespPath_92C(Adapter, 0);
+			}
+			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x01); // RX path = PathAB
+
+			//pDM_SWAT_Table->CurAntenna = pDM_SWAT_Table->PreAntenna;
+
+			//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, DM_SWAT_Table.CurAntenna);
+			//pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 = ((pDM_SWAT_Table->SWAS_NoLink_BK_Reg860 & 0xfffffcff) | (pDM_SWAT_Table->CurAntenna<<8));
+			//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pDM_SWAT_Table->SWAS_NoLink_BK_Reg860);
+		}
+
+		// Check state reset to default and wait for next time.
+		//pDM_SWAT_Table->SWAS_NoLink_State = 0;
+		pDM_PDTable->PathDiv_NoLink_State = 0;
+
+		return FALSE;
+	}
+#else
+		return	FALSE;
+#endif
+	
+}
+
+
+
+VOID
+odm_PathDiversityAfterLink_92C(
+	IN	PADAPTER	Adapter
+)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	pPD_T		pDM_PDTable = &Adapter->DM_PDTable;
+	u1Byte		DefaultRespPath=0;
+
+	if((!(pHalData->CVID_Version==VERSION_1_BEFORE_8703B && IS_92C_SERIAL(pHalData->VersionID))) || (pHalData->PathDivCfg != 1) || (pHalData->eRFPowerState == eRfOff))
+	{
+		if(pHalData->PathDivCfg == 0)
+		{
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("No ODM_TXPathDiversity()\n"));
+		}
+		else
+		{
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("2T ODM_TXPathDiversity()\n"));
+		}
+		return;
+	}
+	if(!odm_IsConnected_92C(Adapter))
+	{
+		RT_TRACE(	COMP_INIT, DBG_LOUD, ("ODM_TXPathDiversity(): No Connections\n"));
+		return;
+	}
+	
+	
+	if(pDM_PDTable->TrainingState == 0)
+	{
+		RT_TRACE(	COMP_INIT, DBG_LOUD, ("ODM_TXPathDiversity() ==>\n"));
+		odm_OFDMTXPathDiversity_92C(Adapter);
+
+		if((pDM_PDTable->CCKPathDivEnable == TRUE) && (pDM_PDTable->OFDM_Pkt_Cnt < 100))
+		{
+			//RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: TrainingState=0\n"));
+			
+			if(pDM_PDTable->CCK_Pkt_Cnt > 300)
+				pDM_PDTable->Timer = 20;
+			else if(pDM_PDTable->CCK_Pkt_Cnt > 100)
+				pDM_PDTable->Timer = 60;
+			else
+				pDM_PDTable->Timer = 250;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: timer=%d\n",pDM_PDTable->Timer));
+
+			PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x00); // RX path = PathA
+			pDM_PDTable->TrainingState = 1;
+			pHalData->RSSI_test = TRUE;
+			ODM_SetTimer( pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, pDM_PDTable->Timer); //ms
+		}
+		else
+		{
+			pDM_PDTable->CCKTXPath = pDM_PDTable->OFDMTXPath;
+			DefaultRespPath = pDM_PDTable->OFDMDefaultRespPath;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_SetRespPath_92C: Skip odm_CCKTXPathDiversity_92C, DefaultRespPath is OFDM\n"));
+			odm_SetRespPath_92C(Adapter, DefaultRespPath);
+			odm_ResetPathDiversity_92C(Adapter);
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("ODM_TXPathDiversity() <==\n"));
+		}
+	}
+	else if(pDM_PDTable->TrainingState == 1)
+	{		
+		//RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: TrainingState=1\n"));
+		PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x05); // RX path = PathB
+		pDM_PDTable->TrainingState = 2;
+		ODM_SetTimer( pDM_Odm, &pDM_Odm->CCKPathDiversityTimer, pDM_PDTable->Timer); //ms
+	}
+	else
+	{
+		//RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: TrainingState=2\n"));
+		pDM_PDTable->TrainingState = 0;	
+		odm_CCKTXPathDiversity_92C(Adapter); 
+		if(pDM_PDTable->OFDM_Pkt_Cnt != 0)
+		{
+			DefaultRespPath = pDM_PDTable->OFDMDefaultRespPath;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_SetRespPath_92C: DefaultRespPath is OFDM\n"));
+		}
+		else
+		{
+			DefaultRespPath = pDM_PDTable->CCKDefaultRespPath;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_SetRespPath_92C: DefaultRespPath is CCK\n"));
+		}
+		odm_SetRespPath_92C(Adapter, DefaultRespPath);
+		odm_ResetPathDiversity_92C(Adapter);
+		RT_TRACE(	COMP_INIT, DBG_LOUD, ("ODM_TXPathDiversity() <==\n"));
+	}
+
+}
+
+VOID
+odm_SetRespPath_92C(
+	IN	PADAPTER	Adapter,
+	IN	u1Byte	DefaultRespPath
+	)
+{
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+
+	RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_SetRespPath_92C: Select Response Path=%d\n",DefaultRespPath));
+	if(DefaultRespPath != pDM_PDTable->DefaultRespPath)
+	{
+		if(DefaultRespPath == 0)
+		{
+			PlatformEFIOWrite1Byte(Adapter, 0x6D8, (PlatformEFIORead1Byte(Adapter, 0x6D8)&0xc0)|0x15);	
+		}
+		else
+		{
+			PlatformEFIOWrite1Byte(Adapter, 0x6D8, (PlatformEFIORead1Byte(Adapter, 0x6D8)&0xc0)|0x2A);
+		}	
+	}
+	pDM_PDTable->DefaultRespPath = DefaultRespPath;
+}
+
+VOID
+odm_OFDMTXPathDiversity_92C(
+	IN	PADAPTER	Adapter)
+{
+//	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	PRT_WLAN_STA	pEntry;
+	u1Byte	i, DefaultRespPath = 0;
+	s4Byte	MinRSSI = 0xFF;
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+	pDM_PDTable->OFDMTXPath = 0;
+	
+	//1 Default Port
+	if(pMgntInfo->mAssoc)
+	{
+		RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: Default port RSSI[0]=%d, RSSI[1]=%d\n",
+			Adapter->RxStats.RxRSSIPercentage[0], Adapter->RxStats.RxRSSIPercentage[1]));
+		if(Adapter->RxStats.RxRSSIPercentage[0] > Adapter->RxStats.RxRSSIPercentage[1])
+		{
+			pDM_PDTable->OFDMTXPath = pDM_PDTable->OFDMTXPath & (~BIT0);
+			MinRSSI =  Adapter->RxStats.RxRSSIPercentage[1];
+			DefaultRespPath = 0;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: Default port Select Path-0\n"));
+		}
+		else
+		{
+			pDM_PDTable->OFDMTXPath =  pDM_PDTable->OFDMTXPath | BIT0;
+			MinRSSI =  Adapter->RxStats.RxRSSIPercentage[0];
+			DefaultRespPath = 1;
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: Default port Select Path-1\n"));
+		}
+			//RT_TRACE(	COMP_INIT, DBG_LOUD, ("pDM_PDTable->OFDMTXPath =0x%x\n",pDM_PDTable->OFDMTXPath));
+	}
+	//1 Extension Port
+	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
+		else
+			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
+
+		if(pEntry!=NULL)
+		{
+			if(pEntry->bAssociated)
+			{
+				RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: MACID=%d, RSSI_0=%d, RSSI_1=%d\n", 
+					pEntry->AssociatedMacId, pEntry->rssi_stat.RxRSSIPercentage[0], pEntry->rssi_stat.RxRSSIPercentage[1]));
+				
+				if(pEntry->rssi_stat.RxRSSIPercentage[0] > pEntry->rssi_stat.RxRSSIPercentage[1])
+				{
+					pDM_PDTable->OFDMTXPath = pDM_PDTable->OFDMTXPath & ~(BIT(pEntry->AssociatedMacId));
+					//pHalData->TXPath = pHalData->TXPath & ~(1<<(pEntry->AssociatedMacId));
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: MACID=%d Select Path-0\n", pEntry->AssociatedMacId));
+					if(pEntry->rssi_stat.RxRSSIPercentage[1] < MinRSSI)
+					{
+						MinRSSI = pEntry->rssi_stat.RxRSSIPercentage[1];
+						DefaultRespPath = 0;
+					}
+				}
+				else
+				{
+					pDM_PDTable->OFDMTXPath = pDM_PDTable->OFDMTXPath | BIT(pEntry->AssociatedMacId);
+					//pHalData->TXPath = pHalData->TXPath | (1 << (pEntry->AssociatedMacId));
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_OFDMTXPathDiversity_92C: MACID=%d Select Path-1\n", pEntry->AssociatedMacId));
+					if(pEntry->rssi_stat.RxRSSIPercentage[0] < MinRSSI)
+					{
+						MinRSSI = pEntry->rssi_stat.RxRSSIPercentage[0];
+						DefaultRespPath = 1;
+					}
+				}
+			}
+		}
+		else
+		{
+			break;
+		}
+	}
+
+	pDM_PDTable->OFDMDefaultRespPath = DefaultRespPath;
+}
+
+
+VOID
+odm_CCKTXPathDiversity_92C(
+	IN	PADAPTER	Adapter
+)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	PRT_WLAN_STA	pEntry;
+	s4Byte	MinRSSI = 0xFF;
+	u1Byte	i, DefaultRespPath = 0;
+//	BOOLEAN	bBModePathDiv = FALSE;
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+
+	//1 Default Port
+	if(pMgntInfo->mAssoc)
+	{
+		if(pHalData->OFDM_Pkt_Cnt == 0)
+		{
+			for(i=0; i<2; i++)
+			{
+				if(pDM_PDTable->RSSI_CCK_Path_cnt[i] > 1) //Because the first packet is discarded
+					pDM_PDTable->RSSI_CCK_Path[i] = pDM_PDTable->RSSI_CCK_Path[i] / (pDM_PDTable->RSSI_CCK_Path_cnt[i]-1);
+				else
+					pDM_PDTable->RSSI_CCK_Path[i] = 0;
+			}
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: pDM_PDTable->RSSI_CCK_Path[0]=%d, pDM_PDTable->RSSI_CCK_Path[1]=%d\n",
+				pDM_PDTable->RSSI_CCK_Path[0], pDM_PDTable->RSSI_CCK_Path[1]));
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: pDM_PDTable->RSSI_CCK_Path_cnt[0]=%d, pDM_PDTable->RSSI_CCK_Path_cnt[1]=%d\n",
+				pDM_PDTable->RSSI_CCK_Path_cnt[0], pDM_PDTable->RSSI_CCK_Path_cnt[1]));
+		
+			if(pDM_PDTable->RSSI_CCK_Path[0] > pDM_PDTable->RSSI_CCK_Path[1])
+			{
+				pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & (~BIT0);
+				MinRSSI =  pDM_PDTable->RSSI_CCK_Path[1];
+				DefaultRespPath = 0;
+				RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port Select CCK Path-0\n"));
+			}
+			else if(pDM_PDTable->RSSI_CCK_Path[0] < pDM_PDTable->RSSI_CCK_Path[1])
+			{
+				pDM_PDTable->CCKTXPath =  pDM_PDTable->CCKTXPath | BIT0;
+				MinRSSI =  pDM_PDTable->RSSI_CCK_Path[0];
+				DefaultRespPath = 1;
+				RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port Select CCK Path-1\n"));
+			}
+			else
+			{
+				if((pDM_PDTable->RSSI_CCK_Path[0] != 0) && (pDM_PDTable->RSSI_CCK_Path[0] < MinRSSI))
+				{
+					pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & (~BIT0);
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port Select CCK Path-0\n"));
+					MinRSSI =  pDM_PDTable->RSSI_CCK_Path[1];
+					DefaultRespPath = 0;
+				}
+				else
+				{
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Default port unchange CCK Path\n"));
+				}
+			}
+		}
+		else //Follow OFDM decision
+		{
+			pDM_PDTable->CCKTXPath = (pDM_PDTable->CCKTXPath & (~BIT0)) | (pDM_PDTable->OFDMTXPath &BIT0);
+			RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Follow OFDM decision, Default port Select CCK Path-%d\n",
+				pDM_PDTable->CCKTXPath &BIT0));
+		}
+	}
+	//1 Extension Port
+	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
+		else
+			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
+
+		if(pEntry!=NULL)
+		{
+			if(pEntry->bAssociated)
+			{
+				if(pEntry->rssi_stat.OFDM_Pkt_Cnt == 0)
+				{
+					u1Byte j=0;
+					for(j=0; j<2; j++)
+					{
+						if(pEntry->rssi_stat.RSSI_CCK_Path_cnt[j] > 1)
+							pEntry->rssi_stat.RSSI_CCK_Path[j] = pEntry->rssi_stat.RSSI_CCK_Path[j] / (pEntry->rssi_stat.RSSI_CCK_Path_cnt[j]-1);
+						else
+							pEntry->rssi_stat.RSSI_CCK_Path[j] = 0;
+					}
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d, RSSI_CCK0=%d, RSSI_CCK1=%d\n", 
+						pEntry->AssociatedMacId, pEntry->rssi_stat.RSSI_CCK_Path[0], pEntry->rssi_stat.RSSI_CCK_Path[1]));
+					
+					if(pEntry->rssi_stat.RSSI_CCK_Path[0] >pEntry->rssi_stat.RSSI_CCK_Path[1])
+					{
+						pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & ~(BIT(pEntry->AssociatedMacId));
+						RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d Select CCK Path-0\n", pEntry->AssociatedMacId));
+						if(pEntry->rssi_stat.RSSI_CCK_Path[1] < MinRSSI)
+						{
+							MinRSSI = pEntry->rssi_stat.RSSI_CCK_Path[1];
+							DefaultRespPath = 0;
+						}
+					}
+					else if(pEntry->rssi_stat.RSSI_CCK_Path[0] <pEntry->rssi_stat.RSSI_CCK_Path[1])
+					{
+						pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath | BIT(pEntry->AssociatedMacId);
+						RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d Select CCK Path-1\n", pEntry->AssociatedMacId));
+						if(pEntry->rssi_stat.RSSI_CCK_Path[0] < MinRSSI)
+						{
+							MinRSSI = pEntry->rssi_stat.RSSI_CCK_Path[0];
+							DefaultRespPath = 1;
+						}
+					}
+					else
+					{
+						if((pEntry->rssi_stat.RSSI_CCK_Path[0] != 0) && (pEntry->rssi_stat.RSSI_CCK_Path[0] < MinRSSI))
+						{
+							pDM_PDTable->CCKTXPath = pDM_PDTable->CCKTXPath & ~(BIT(pEntry->AssociatedMacId));
+							MinRSSI = pEntry->rssi_stat.RSSI_CCK_Path[1];
+							DefaultRespPath = 0;
+							RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d Select CCK Path-0\n", pEntry->AssociatedMacId));
+						}
+						else
+						{
+							RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: MACID=%d unchange CCK Path\n", pEntry->AssociatedMacId));
+						}
+					}
+				}
+				else //Follow OFDM decision
+				{
+					pDM_PDTable->CCKTXPath = (pDM_PDTable->CCKTXPath & (~(BIT(pEntry->AssociatedMacId)))) | (pDM_PDTable->OFDMTXPath & BIT(pEntry->AssociatedMacId));
+					RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C: Follow OFDM decision, MACID=%d Select CCK Path-%d\n",
+						pEntry->AssociatedMacId, (pDM_PDTable->CCKTXPath & BIT(pEntry->AssociatedMacId))>>(pEntry->AssociatedMacId)));
+				}
+			}
+		}
+		else
+		{
+			break;
+		}
+	}
+
+	RT_TRACE(	COMP_INIT, DBG_LOUD, ("odm_CCKTXPathDiversity_92C:MinRSSI=%d\n",MinRSSI));
+
+	if(MinRSSI == 0xFF)
+		DefaultRespPath = pDM_PDTable->CCKDefaultRespPath;
+
+	pDM_PDTable->CCKDefaultRespPath = DefaultRespPath;
+}
+
+
+VOID
+odm_ResetPathDiversity_92C(
+		IN	PADAPTER	Adapter
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+	PRT_WLAN_STA	pEntry;
+	u4Byte	i,j;
+
+	pHalData->RSSI_test = FALSE;
+	pDM_PDTable->CCK_Pkt_Cnt = 0;
+	pDM_PDTable->OFDM_Pkt_Cnt = 0;
+	pHalData->CCK_Pkt_Cnt =0;
+	pHalData->OFDM_Pkt_Cnt =0;
+	
+	if(pDM_PDTable->CCKPathDivEnable == TRUE)	
+		PHY_SetBBReg(Adapter, rCCK0_AFESetting  , 0x0F000000, 0x01); //RX path = PathAB
+
+	for(i=0; i<2; i++)
+	{
+		pDM_PDTable->RSSI_CCK_Path_cnt[i]=0;
+		pDM_PDTable->RSSI_CCK_Path[i] = 0;
+	}
+	for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+	{
+		if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+			pEntry = AsocEntry_EnumStation(GetFirstExtAdapter(Adapter), i);
+		else
+			pEntry = AsocEntry_EnumStation(GetDefaultAdapter(Adapter), i);
+
+		if(pEntry!=NULL)
+		{
+			pEntry->rssi_stat.CCK_Pkt_Cnt = 0;
+			pEntry->rssi_stat.OFDM_Pkt_Cnt = 0;
+			for(j=0; j<2; j++)
+			{
+				pEntry->rssi_stat.RSSI_CCK_Path_cnt[j] = 0;
+				pEntry->rssi_stat.RSSI_CCK_Path[j] = 0;
+			}
+		}
+		else
+			break;
+	}
+}
+
+
+
+
+
+VOID
+odm_CCKTXPathDiversityCallback(
+	PRT_TIMER		pTimer
+)
+{
+#if USE_WORKITEM
+       PADAPTER	Adapter = (PADAPTER)pTimer->Adapter;
+       HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	   PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+#else
+	PADAPTER	Adapter = (PADAPTER)pTimer->Adapter;
+#endif
+
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+#if USE_WORKITEM
+	PlatformScheduleWorkItem(&pDM_Odm->CCKPathDiversityWorkitem);
+#else
+	odm_PathDiversityAfterLink_92C(Adapter);
+#endif
+#else
+	PlatformScheduleWorkItem(&pDM_Odm->CCKPathDiversityWorkitem);
+#endif
+
+}
+
+
+VOID
+odm_CCKTXPathDiversityWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	Adapter = (PADAPTER)pContext;
+
+	odm_CCKTXPathDiversity_92C(Adapter);
+}
+
+//
+// 20100514 Luke/Joseph:
+// Callback function for 500ms antenna test trying.
+//
+VOID
+odm_PathDivChkAntSwitchCallback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+
+#if USE_WORKITEM
+	PlatformScheduleWorkItem(&pDM_Odm->PathDivSwitchWorkitem);
+#else
+	odm_PathDivChkAntSwitch(pDM_Odm);
+#endif
+#else
+	PlatformScheduleWorkItem(&pDM_Odm->PathDivSwitchWorkitem);
+#endif
+
+//odm_SwAntDivChkAntSwitch(Adapter, SWAW_STEP_DETERMINE);
+
+}
+
+
+VOID
+odm_PathDivChkAntSwitchWorkitemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	odm_PathDivChkAntSwitch(pDM_Odm);
+}
+
+
+ //MAC0_ACCESS_PHY1
+
+// 2011-06-22 Neil Chen & Gary Hsin
+// Refer to Jr.Luke's SW ANT DIV
+// 92D Path Diversity Main function
+// refer to 88C software antenna diversity
+// 
+VOID
+odm_PathDivChkAntSwitch(
+	PDM_ODM_T		pDM_Odm
+	//PADAPTER		Adapter,
+	//u1Byte			Step
+)
+{
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
+
+
+	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+	s4Byte			curRSSI=100, RSSI_A, RSSI_B;
+	u1Byte			nextAntenna=AUX_ANT;
+	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
+	u8Byte			curTxOkCnt, curRxOkCnt;
+	static u8Byte		TXByteCnt_A=0, TXByteCnt_B=0, RXByteCnt_A=0, RXByteCnt_B=0;
+	u8Byte			CurByteCnt=0, PreByteCnt=0;
+	static u1Byte		TrafficLoad = TRAFFIC_LOW;
+	u1Byte			Score_A=0, Score_B=0;
+	u1Byte			i=0x0;
+       // Neil Chen
+       static u1Byte        pathdiv_para=0x0;     
+       static u1Byte        switchfirsttime=0x00;
+	// u1Byte                 regB33 = (u1Byte) PHY_QueryBBReg(Adapter, 0xB30,BIT27);
+	u1Byte			regB33 = (u1Byte)ODM_GetBBReg(pDM_Odm, PATHDIV_REG, BIT27);
+
+
+       //u1Byte                 reg637 =0x0;   
+       static u1Byte        fw_value=0x0;         
+	//u8Byte			curTxOkCnt_tmp, curRxOkCnt_tmp;
+       PADAPTER            BuddyAdapter = Adapter->BuddyAdapter;     // another adapter MAC
+        // Path Diversity   //Neil Chen--2011--06--22
+
+	//u1Byte                 PathDiv_Trigger = (u1Byte) PHY_QueryBBReg(Adapter, 0xBA0,BIT31);
+	u1Byte                 PathDiv_Trigger = (u1Byte) ODM_GetBBReg(pDM_Odm, PATHDIV_TRI,BIT31);
+	u1Byte                 PathDiv_Enable = pHalData->bPathDiv_Enable;
+
+
+	//DbgPrint("Path Div PG Value:%x \n",PathDiv_Enable);	
+       if((BuddyAdapter==NULL)||(!PathDiv_Enable)||(PathDiv_Trigger)||(pHalData->CurrentBandType == BAND_ON_2_4G))
+       {
+           return;
+       }
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD,("===================>odm_PathDivChkAntSwitch()\n"));
+
+       // The first time to switch path excluding 2nd, 3rd, ....etc....
+	if(switchfirsttime==0)
+	{
+	    if(regB33==0)
+	    {
+	       pDM_SWAT_Table->CurAntenna = MAIN_ANT;    // Default MAC0_5G-->Path A (current antenna)     
+	    }	    
+	}
+
+	// Condition that does not need to use antenna diversity.
+	if(pDM_Odm->SupportICType != ODM_RTL8192D)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_PathDiversityMechanims(): No PathDiv Mechanism.\n"));
+		return;
+	}
+
+	// Radio off: Status reset to default and return.
+	if(pHalData->eRFPowerState==eRfOff)
+	{
+		//ODM_SwAntDivRestAfterLink(Adapter);
+		return;
+	}
+
+       /*
+	// Handling step mismatch condition.
+	// Peak step is not finished at last time. Recover the variable and check again.
+	if(	Step != pDM_SWAT_Table->try_flag	)
+	{
+		ODM_SwAntDivRestAfterLink(Adapter);
+	} */
+	
+	if(pDM_SWAT_Table->try_flag == 0xff)
+	{
+		// Select RSSI checking target
+		if(pMgntInfo->mAssoc && !ACTING_AS_AP(Adapter))
+		{
+			// Target: Infrastructure mode AP.
+			pHalData->RSSI_target = NULL;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_PathDivMechanism(): RSSI_target is DEF AP!\n"));
+		}
+		else
+		{
+			u1Byte			index = 0;
+			PRT_WLAN_STA	pEntry = NULL;
+			PADAPTER		pTargetAdapter = NULL;
+		
+			if(	pMgntInfo->mIbss || ACTING_AS_AP(Adapter) )
+			{
+				// Target: AP/IBSS peer.
+				pTargetAdapter = Adapter;
+			}
+			else if(IsAPModeExist(Adapter)  && GetFirstExtAdapter(Adapter) != NULL)
+			{
+				// Target: VWIFI peer.
+				pTargetAdapter = GetFirstExtAdapter(Adapter);
+			}
+
+			if(pTargetAdapter != NULL)
+			{
+				for(index=0; index<ODM_ASSOCIATE_ENTRY_NUM; index++)
+				{
+					pEntry = AsocEntry_EnumStation(pTargetAdapter, index);
+					if(pEntry != NULL)
+					{
+						if(pEntry->bAssociated)
+							break;			
+					}
+				}
+			}
+
+			if(pEntry == NULL)
+			{
+				ODM_PathDivRestAfterLink(pDM_Odm);
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): No Link.\n"));
+				return;
+			}
+			else
+			{
+				pHalData->RSSI_target = pEntry;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): RSSI_target is PEER STA\n"));
+			}
+		}
+			
+		pHalData->RSSI_cnt_A = 0;
+		pHalData->RSSI_cnt_B = 0;
+		pDM_SWAT_Table->try_flag = 0;
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("odm_SwAntDivChkAntSwitch(): Set try_flag to 0 prepare for peak!\n"));
+		return;
+	}
+	else
+	{
+	       // 1st step
+		curTxOkCnt = Adapter->TxStats.NumTxBytesUnicast - lastTxOkCnt;
+		curRxOkCnt = Adapter->RxStats.NumRxBytesUnicast - lastRxOkCnt;
+		lastTxOkCnt = Adapter->TxStats.NumTxBytesUnicast;
+		lastRxOkCnt = Adapter->RxStats.NumRxBytesUnicast;
+	
+		if(pDM_SWAT_Table->try_flag == 1)   // Training State
+		{
+			if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+			{
+				TXByteCnt_A += curTxOkCnt;
+				RXByteCnt_A += curRxOkCnt;
+			}
+			else
+			{
+				TXByteCnt_B += curTxOkCnt;
+				RXByteCnt_B += curRxOkCnt;
+			}
+		
+			nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? AUX_ANT : MAIN_ANT;
+			pDM_SWAT_Table->RSSI_Trying--;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: RSSI_Trying = %d\n",pDM_SWAT_Table->RSSI_Trying));
+			if(pDM_SWAT_Table->RSSI_Trying == 0)
+			{
+				CurByteCnt = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? (TXByteCnt_A+RXByteCnt_A) : (TXByteCnt_B+RXByteCnt_B);
+				PreByteCnt = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? (TXByteCnt_B+RXByteCnt_B) : (TXByteCnt_A+RXByteCnt_A);
+				
+				if(TrafficLoad == TRAFFIC_HIGH)
+				{
+					//CurByteCnt = PlatformDivision64(CurByteCnt, 9);
+					PreByteCnt =PreByteCnt*9;
+				}
+				else if(TrafficLoad == TRAFFIC_LOW)
+				{
+					//CurByteCnt = PlatformDivision64(CurByteCnt, 2);
+					PreByteCnt =PreByteCnt*2;
+				}
+				if(pHalData->RSSI_cnt_A > 0)
+					RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
+				else
+					RSSI_A = 0;
+				if(pHalData->RSSI_cnt_B > 0)
+					RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
+		             else
+					RSSI_B = 0;
+				curRSSI = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
+				pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_B : RSSI_A;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: PreRSSI = %d, CurRSSI = %d\n",pDM_SWAT_Table->PreRSSI, curRSSI));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: preAntenna= %s, curAntenna= %s \n", 
+				(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
+					RSSI_A, pHalData->RSSI_cnt_A, RSSI_B, pHalData->RSSI_cnt_B));
+			}
+
+		}
+		else   // try_flag=0
+		{
+		
+			if(pHalData->RSSI_cnt_A > 0)
+				RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
+			else
+				RSSI_A = 0;
+			if(pHalData->RSSI_cnt_B > 0)
+				RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
+			else
+				RSSI_B = 0;	
+			curRSSI = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
+			pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->PreAntenna == MAIN_ANT)? RSSI_A : RSSI_B;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: PreRSSI = %d, CurRSSI = %d\n", pDM_SWAT_Table->PreRSSI, curRSSI));
+		       ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: preAntenna= %s, curAntenna= %s \n", 
+			(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH DIV=: RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
+				RSSI_A, pHalData->RSSI_cnt_A, RSSI_B, pHalData->RSSI_cnt_B));
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Ekul:curTxOkCnt = %d\n", curTxOkCnt));
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Ekul:curRxOkCnt = %d\n", curRxOkCnt));
+		}
+
+		//1 Trying State
+		if((pDM_SWAT_Table->try_flag == 1)&&(pDM_SWAT_Table->RSSI_Trying == 0))
+		{
+
+			if(pDM_SWAT_Table->TestMode == TP_MODE)
+			{
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: TestMode = TP_MODE"));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH= TRY:CurByteCnt = %"i64fmt"d,", CurByteCnt));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH= TRY:PreByteCnt = %"i64fmt"d\n",PreByteCnt));		
+				if(CurByteCnt < PreByteCnt)
+				{
+					if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
+					else
+						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
+				}
+				else
+				{
+					if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+						pDM_SWAT_Table->SelectAntennaMap=(pDM_SWAT_Table->SelectAntennaMap<<1)+1;
+					else
+						pDM_SWAT_Table->SelectAntennaMap=pDM_SWAT_Table->SelectAntennaMap<<1;
+				}
+				for (i= 0; i<8; i++)
+				{
+					if(((pDM_SWAT_Table->SelectAntennaMap>>i)&BIT0) == 1)
+						Score_A++;
+					else
+						Score_B++;
+				}
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("SelectAntennaMap=%x\n ",pDM_SWAT_Table->SelectAntennaMap));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Score_A=%d, Score_B=%d\n", Score_A, Score_B));
+			
+				if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+				{
+					nextAntenna = (Score_A >= Score_B)?MAIN_ANT:AUX_ANT;
+				}
+				else
+				{
+					nextAntenna = (Score_B >= Score_A)?AUX_ANT:MAIN_ANT;
+				}
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: nextAntenna=%s\n",(nextAntenna==MAIN_ANT)?"MAIN":"AUX"));
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: preAntenna= %s, curAntenna= %s \n", 
+				(pDM_SWAT_Table->PreAntenna == MAIN_ANT?"MAIN":"AUX"), (pDM_SWAT_Table->CurAntenna == MAIN_ANT?"MAIN":"AUX")));
+
+				if(nextAntenna != pDM_SWAT_Table->CurAntenna)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Switch back to another antenna"));
+				}
+				else
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: current anntena is good\n"));
+				}	
+			}
+
+                    
+			if(pDM_SWAT_Table->TestMode == RSSI_MODE)
+			{	
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: TestMode = RSSI_MODE"));
+				pDM_SWAT_Table->SelectAntennaMap=0xAA;
+				if(curRSSI < pDM_SWAT_Table->PreRSSI) //Current antenna is worse than previous antenna
+				{
+					//RT_TRACE(COMP_INIT, DBG_LOUD, ("SWAS: Switch back to another antenna"));
+					nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)?AUX_ANT : MAIN_ANT;
+				}
+				else // current anntena is good
+				{
+					nextAntenna =pDM_SWAT_Table->CurAntenna;
+					//RT_TRACE(COMP_INIT, DBG_LOUD, ("SWAS: current anntena is good\n"));
+				}
+			}
+			
+			pDM_SWAT_Table->try_flag = 0;
+			pHalData->RSSI_test = FALSE;
+			pHalData->RSSI_sum_A = 0;
+			pHalData->RSSI_cnt_A = 0;
+			pHalData->RSSI_sum_B = 0;
+			pHalData->RSSI_cnt_B = 0;
+			TXByteCnt_A = 0;
+			TXByteCnt_B = 0;
+			RXByteCnt_A = 0;
+			RXByteCnt_B = 0;
+			
+		}
+
+		//1 Normal State
+		else if(pDM_SWAT_Table->try_flag == 0)
+		{
+			if(TrafficLoad == TRAFFIC_HIGH)
+			{
+				if ((curTxOkCnt+curRxOkCnt) > 3750000)//if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)
+					TrafficLoad = TRAFFIC_HIGH;
+				else
+					TrafficLoad = TRAFFIC_LOW;
+			}
+			else if(TrafficLoad == TRAFFIC_LOW)
+				{
+				if ((curTxOkCnt+curRxOkCnt) > 3750000)//if(PlatformDivision64(curTxOkCnt+curRxOkCnt, 2) > 1875000)
+					TrafficLoad = TRAFFIC_HIGH;
+				else
+					TrafficLoad = TRAFFIC_LOW;
+			}
+			if(TrafficLoad == TRAFFIC_HIGH)
+				pDM_SWAT_Table->bTriggerAntennaSwitch = 0;
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Normal:TrafficLoad = %llu\n", curTxOkCnt+curRxOkCnt));
+
+			//Prepare To Try Antenna		
+				nextAntenna = (pDM_SWAT_Table->CurAntenna == MAIN_ANT)? AUX_ANT : MAIN_ANT;
+				pDM_SWAT_Table->try_flag = 1;
+				pHalData->RSSI_test = TRUE;
+			if((curRxOkCnt+curTxOkCnt) > 1000)
+			{
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+	                    pDM_SWAT_Table->RSSI_Trying = 4;                           
+#else
+	                    pDM_SWAT_Table->RSSI_Trying = 2;
+#endif
+				pDM_SWAT_Table->TestMode = TP_MODE;
+			}
+			else
+			{
+				pDM_SWAT_Table->RSSI_Trying = 2;
+				pDM_SWAT_Table->TestMode = RSSI_MODE;
+
+			}
+                          
+			//RT_TRACE(COMP_INIT, DBG_LOUD, ("SWAS: Normal State -> Begin Trying!\n"));			
+			pHalData->RSSI_sum_A = 0;
+			pHalData->RSSI_cnt_A = 0;
+			pHalData->RSSI_sum_B = 0;
+			pHalData->RSSI_cnt_B = 0;
+		} // end of try_flag=0
+	}
+	
+	//1 4.Change TRX antenna
+	if(nextAntenna != pDM_SWAT_Table->CurAntenna)
+	{
+	
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Change TX Antenna!\n "));
+		//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, nextAntenna); for 88C
+		if(nextAntenna==MAIN_ANT)
+		{
+		    ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Next Antenna is RF PATH A\n "));
+		    pathdiv_para = 0x02;   //02 to switchback to RF path A
+		    fw_value = 0x03;
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+                 odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
+#else
+                 ODM_FillH2CCmd(pDM_Odm, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
+#endif
+		}	
+	       else if(nextAntenna==AUX_ANT)
+	       {
+	           ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Next Antenna is RF PATH B\n "));
+	           if(switchfirsttime==0)  // First Time To Enter Path Diversity
+	           {
+	               switchfirsttime=0x01;
+                      pathdiv_para = 0x00;
+			  fw_value=0x00;    // to backup RF Path A Releated Registers		  
+					  
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+                     odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
+#else
+                     ODM_FillH2CCmd(pDM_Odm, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
+                     //for(u1Byte n=0; n<80,n++)
+                     //{
+                     //delay_us(500);
+			  ODM_delay_ms(500);
+                     odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
+			 		 
+			 fw_value=0x01;   	// to backup RF Path A Releated Registers		 
+                     ODM_FillH2CCmd(pDM_Odm, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
+#endif	
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: FIRST TIME To DO PATH SWITCH!\n "));	
+	           }		   
+		    else
+		    {
+		        pathdiv_para = 0x01;
+			 fw_value = 0x02;	
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+                     odm_PathDiversity_8192D(pDM_Odm, pathdiv_para);
+#else
+                     ODM_FillH2CCmd(pDM_Odm, ODM_H2C_PathDiv,1,(pu1Byte)(&fw_value));	
+#endif	
+		    }		
+	       }
+           //   odm_PathDiversity_8192D(Adapter, pathdiv_para);
+	}
+
+	//1 5.Reset Statistics
+	pDM_SWAT_Table->PreAntenna = pDM_SWAT_Table->CurAntenna;
+	pDM_SWAT_Table->CurAntenna = nextAntenna;
+	pDM_SWAT_Table->PreRSSI = curRSSI;
+
+	//1 6.Set next timer
+
+	if(pDM_SWAT_Table->RSSI_Trying == 0)
+		return;
+
+	if(pDM_SWAT_Table->RSSI_Trying%2 == 0)
+	{
+		if(pDM_SWAT_Table->TestMode == TP_MODE)
+		{
+			if(TrafficLoad == TRAFFIC_HIGH)
+			{
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 10 ); //ms
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 10 ms\n"));
+#else
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 20 ); //ms
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 20 ms\n"));
+#endif				
+			}
+			else if(TrafficLoad == TRAFFIC_LOW)
+			{
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 50 ); //ms
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 50 ms\n"));
+			}
+		}
+		else   // TestMode == RSSI_MODE
+		{
+			ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 500 ); //ms
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 500 ms\n"));
+		}
+	}
+	else
+	{
+		if(pDM_SWAT_Table->TestMode == TP_MODE)
+		{
+			if(TrafficLoad == TRAFFIC_HIGH)
+				
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 90 ); //ms
+				//ODM_RT_TRACE(pDM_Odm,ODM_COMP_PATH_DIV, ODM_DBG_LOUD, ("=PATH=: Test another antenna for 90 ms\n"));
+#else		
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 180); //ms
+#endif				
+			else if(TrafficLoad == TRAFFIC_LOW)
+				ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 100 ); //ms
+		}
+		else
+			ODM_SetTimer( pDM_Odm, &pDM_Odm->PathDivSwitchTimer, 500 ); //ms
+	}
+}
+
+
+
+VOID
+ODM_CCKPathDiversityChkPerPktRssi(
+	PADAPTER		Adapter,
+	BOOLEAN			bIsDefPort,
+	BOOLEAN			bMatchBSSID,
+	PRT_WLAN_STA	pEntry,
+	PRT_RFD			pRfd,
+	pu1Byte			pDesc
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	BOOLEAN			bCount = FALSE;
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+	//BOOLEAN	isCCKrate = RX_HAL_IS_CCK_RATE_92C(pDesc);
+#if DEV_BUS_TYPE != RT_SDIO_INTERFACE
+	BOOLEAN	isCCKrate = RX_HAL_IS_CCK_RATE(Adapter, pDesc);
+#else  //below code would be removed if we have verified SDIO
+	BOOLEAN	isCCKrate = IS_HARDWARE_TYPE_8188E(Adapter) ? RX_HAL_IS_CCK_RATE_88E(pDesc) : RX_HAL_IS_CCK_RATE_92C(pDesc);
+#endif
+
+	if((pHalData->PathDivCfg != 1) || (pHalData->RSSI_test == FALSE))
+		return;
+		
+	if(pHalData->RSSI_target==NULL && bIsDefPort && bMatchBSSID)
+		bCount = TRUE;
+	else if(pHalData->RSSI_target!=NULL && pEntry!=NULL && pHalData->RSSI_target==pEntry)
+		bCount = TRUE;
+
+	if(bCount && isCCKrate)
+	{
+		if(pDM_PDTable->TrainingState == 1 )
+		{
+			if(pEntry)
+			{
+				if(pEntry->rssi_stat.RSSI_CCK_Path_cnt[0] != 0)
+					pEntry->rssi_stat.RSSI_CCK_Path[0] += pRfd->Status.RxPWDBAll;
+				pEntry->rssi_stat.RSSI_CCK_Path_cnt[0]++;
+			}
+			else
+			{
+				if(pDM_PDTable->RSSI_CCK_Path_cnt[0] != 0)
+					pDM_PDTable->RSSI_CCK_Path[0] += pRfd->Status.RxPWDBAll;
+				pDM_PDTable->RSSI_CCK_Path_cnt[0]++;
+			}
+		}
+		else if(pDM_PDTable->TrainingState == 2 )
+		{
+			if(pEntry)
+			{
+				if(pEntry->rssi_stat.RSSI_CCK_Path_cnt[1] != 0)
+					pEntry->rssi_stat.RSSI_CCK_Path[1] += pRfd->Status.RxPWDBAll;
+				pEntry->rssi_stat.RSSI_CCK_Path_cnt[1]++;
+			}
+			else
+			{
+				if(pDM_PDTable->RSSI_CCK_Path_cnt[1] != 0)
+					pDM_PDTable->RSSI_CCK_Path[1] += pRfd->Status.RxPWDBAll;
+				pDM_PDTable->RSSI_CCK_Path_cnt[1]++;
+			}
+		}
+	}
+}
+
+
+
+
+//Neil Chen---2011--06--22
+//----92D Path Diversity----//
+//#ifdef PathDiv92D
+//==================================
+//3 Path Diversity 
+//==================================
+//
+// 20100514 Luke/Joseph:
+// Add new function for antenna diversity after link.
+// This is the main function of antenna diversity after link.
+// This function is called in HalDmWatchDog() and ODM_SwAntDivChkAntSwitchCallback().
+// HalDmWatchDog() calls this function with SWAW_STEP_PEAK to initialize the antenna test.
+// In SWAW_STEP_PEAK, another antenna and a 500ms timer will be set for testing.
+// After 500ms, ODM_SwAntDivChkAntSwitchCallback() calls this function to compare the signal just
+// listened on the air with the RSSI of original antenna.
+// It chooses the antenna with better RSSI.
+// There is also a aged policy for error trying. Each error trying will cost more 5 seconds waiting 
+// penalty to get next try.
+//
+//
+// 20100503 Joseph:
+// Add new function SwAntDivCheck8192C().
+// This is the main function of Antenna diversity function before link.
+// Mainly, it just retains last scan result and scan again.
+// After that, it compares the scan result to see which one gets better RSSI.
+// It selects antenna with better receiving power and returns better scan result.
+//
+
+
+//
+// 20100514 Luke/Joseph:
+// This function is used to gather the RSSI information for antenna testing.
+// It selects the RSSI of the peer STA that we want to know.
+//
+VOID
+ODM_PathDivChkPerPktRssi(
+	PADAPTER		Adapter,
+	BOOLEAN			bIsDefPort,
+	BOOLEAN			bMatchBSSID,
+	PRT_WLAN_STA	pEntry,
+	PRT_RFD			pRfd
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	BOOLEAN			bCount = FALSE;
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+
+	if(pHalData->RSSI_target==NULL && bIsDefPort && bMatchBSSID)
+		bCount = TRUE;
+	else if(pHalData->RSSI_target!=NULL && pEntry!=NULL && pHalData->RSSI_target==pEntry)
+		bCount = TRUE;
+
+	if(bCount)
+	{
+		//1 RSSI for SW Antenna Switch
+		if(pDM_SWAT_Table->CurAntenna == MAIN_ANT)
+		{
+			pHalData->RSSI_sum_A += pRfd->Status.RxPWDBAll;
+			pHalData->RSSI_cnt_A++;
+		}
+		else
+		{
+			pHalData->RSSI_sum_B += pRfd->Status.RxPWDBAll;
+			pHalData->RSSI_cnt_B++;
+
+		}
+	}
+}
+
+
+//
+// 20100514 Luke/Joseph:
+// Add new function to reset antenna diversity state after link.
+//
+VOID
+ODM_PathDivRestAfterLink(
+	IN	PDM_ODM_T		pDM_Odm
+	)
+{
+	PADAPTER		Adapter=pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	pSWAT_T			pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;
+
+	pHalData->RSSI_cnt_A = 0;
+	pHalData->RSSI_cnt_B = 0;
+	pHalData->RSSI_test = FALSE;
+	pDM_SWAT_Table->try_flag = 0x0;       // NOT 0xff
+	pDM_SWAT_Table->RSSI_Trying = 0;
+	pDM_SWAT_Table->SelectAntennaMap=0xAA;
+	pDM_SWAT_Table->CurAntenna = MAIN_ANT;  
+}
+
+
+//==================================================
+//3 PathDiv End
+//==================================================
+
+
+VOID
+ODM_FillTXPathInTXDESC(
+		IN	PADAPTER	Adapter,
+		IN	PRT_TCB		pTcb,
+		IN	pu1Byte		pDesc
+)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u4Byte	TXPath;
+	pPD_T	pDM_PDTable = &Adapter->DM_PDTable;
+
+	//2011.09.05  Add by Luke Lee for path diversity
+	if(pHalData->PathDivCfg == 1)
+	{	
+		TXPath = (pDM_PDTable->OFDMTXPath >> pTcb->macId) & BIT0;
+		//RT_TRACE(	COMP_INIT, DBG_LOUD, ("Fill TXDESC: macID=%d, TXPath=%d\n", pTcb->macId, TXPath));
+		//SET_TX_DESC_TX_ANT_CCK(pDesc,TXPath);
+		if(TXPath == 0)
+		{
+			SET_TX_DESC_TX_ANTL_92C(pDesc,1);
+			SET_TX_DESC_TX_ANT_HT_92C(pDesc,1);
+		}
+		else
+		{
+			SET_TX_DESC_TX_ANTL_92C(pDesc,2);
+			SET_TX_DESC_TX_ANT_HT_92C(pDesc,2);
+		}
+		TXPath = (pDM_PDTable->CCKTXPath >> pTcb->macId) & BIT0;
+		if(TXPath == 0)
+		{
+			SET_TX_DESC_TX_ANT_CCK_92C(pDesc,1);
+		}
+		else
+		{
+			SET_TX_DESC_TX_ANT_CCK_92C(pDesc,2);
+		}
+	}
+}
+
+//Only for MP //Neil Chen--2012--0502--
+VOID
+odm_PathDivInit_92D(
+IN	PDM_ODM_T 	pDM_Odm)
+{
+	pPATHDIV_PARA	pathIQK = &pDM_Odm->pathIQK;
+
+	pathIQK->org_2g_RegC14=0x0;
+	pathIQK->org_2g_RegC4C=0x0;
+	pathIQK->org_2g_RegC80=0x0;
+	pathIQK->org_2g_RegC94=0x0;
+	pathIQK->org_2g_RegCA0=0x0;
+	pathIQK->org_5g_RegC14=0x0;
+	pathIQK->org_5g_RegCA0=0x0;
+	pathIQK->org_5g_RegE30=0x0;
+	pathIQK->swt_2g_RegC14=0x0;
+	pathIQK->swt_2g_RegC4C=0x0;
+	pathIQK->swt_2g_RegC80=0x0;
+	pathIQK->swt_2g_RegC94=0x0;
+	pathIQK->swt_2g_RegCA0=0x0;
+	pathIQK->swt_5g_RegC14=0x0;
+	pathIQK->swt_5g_RegCA0=0x0;
+	pathIQK->swt_5g_RegE30=0x0;
+
+}
+
+
+u1Byte
+odm_SwAntDivSelectScanChnl(
+	IN	PADAPTER	Adapter
+	)
+{
+#if (RT_MEM_SIZE_LEVEL != RT_MEM_SIZE_MINIMUM)
+	PHAL_DATA_TYPE		pHalData = GET_HAL_DATA(Adapter);
+	PMGNT_INFO			pMgntInfo = &(Adapter->MgntInfo);
+	PDM_ODM_T			pDM_Odm = &pHalData->DM_OutSrc;
+	u2Byte 				i;
+	u1Byte				j, ScanChannel = 0, ChannelNum = 0;
+	PRT_CHANNEL_LIST	pChannelList = GET_RT_CHANNEL_LIST(pMgntInfo);
+	u1Byte 				EachChannelSTAs[MAX_SCAN_CHANNEL_NUM] = {0};
+
+	if(pMgntInfo->tmpNumBssDesc == 0)
+		return 0;
+
+	for(i = 0; i < pMgntInfo->tmpNumBssDesc; i++)
+	{		
+		ChannelNum = pMgntInfo->tmpbssDesc[i].ChannelNumber;
+		for(j = 0; j < pChannelList->ChannelLen; j++)
+		{
+			if(pChannelList->ChnlListEntry[j].ChannelNum == ChannelNum)
+			{
+				EachChannelSTAs[j]++;
+				break;
+			}
+		}
+	}
+	
+	for(i = 0; i < MAX_SCAN_CHANNEL_NUM; i++)
+		{
+		if(EachChannelSTAs[i] > EachChannelSTAs[ScanChannel])
+			ScanChannel = (u1Byte)i;
+		}
+
+	if(EachChannelSTAs[ScanChannel] == 0)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, ("odm_SwAntDivSelectScanChnl(): Scan List is empty.\n"));
+		return 0;
+	}
+	
+	ScanChannel = pChannelList->ChnlListEntry[ScanChannel].ChannelNum;
+
+	
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_ANT_DIV, DBG_LOUD, 
+		("odm_SwAntDivSelectScanChnl(): Channel (( %d )) is select as scan channel.\n", ScanChannel));
+
+	return ScanChannel;
+#else
+	return	0;
+#endif	
+}
+
+
+VOID
+odm_SwAntDivConstructScanChnl(
+	IN	PADAPTER	Adapter,
+	IN	u1Byte		ScanChnl
+	)
+{
+
+	PMGNT_INFO			pMgntInfo = &Adapter->MgntInfo;
+
+	if(ScanChnl == 0)
+	{
+		u1Byte				i;		
+		PRT_CHANNEL_LIST	pChannelList = GET_RT_CHANNEL_LIST(pMgntInfo);
+	
+		// 20100519 Joseph: Original antenna scanned nothing. 
+		// Test antenna shall scan all channel with half period in this condition.
+
+		RT_TRACE_F(COMP_SCAN, DBG_TRACE, (" RT_CHNL_LIST_ACTION_CONSTRUCT chnl %d \n", ScanChnl));
+
+		RtActChannelList(Adapter, RT_CHNL_LIST_ACTION_CONSTRUCT_SCAN_LIST, NULL, NULL);
+		for(i = 0; i < pChannelList->ChannelLen; i++)
+			pChannelList->ChnlListEntry[i].ScanPeriod /= 2;
+	}
+	else
+	{
+		// The using of this CustomizedScanRequest is a trick to rescan the two channels 
+		//	under the NORMAL scanning process. It will not affect MGNT_INFO.CustomizedScanRequest.
+		CUSTOMIZED_SCAN_REQUEST CustomScanReq;
+
+		CustomScanReq.bEnabled = TRUE;
+		CustomScanReq.Channels[0] = ScanChnl;
+		CustomScanReq.Channels[1] = pMgntInfo->dot11CurrentChannelNumber;
+		CustomScanReq.nChannels = 2;
+		CustomScanReq.ScanType = SCAN_ACTIVE;
+		CustomScanReq.Duration = DEFAULT_PASSIVE_SCAN_PERIOD;
+
+		RT_TRACE_F(COMP_SCAN, DBG_TRACE, (" RT_CHNL_LIST_ACTION_CONSTRUCT chnl %d \n", ScanChnl));
+
+		RtActChannelList(Adapter, RT_CHNL_LIST_ACTION_CONSTRUCT_SCAN_LIST, &CustomScanReq, NULL);
+	}
+
+}
+
+
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PathDiv.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PathDiv.h
new file mode 100644
index 000000000000..e72e937a7bf5
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PathDiv.h
@@ -0,0 +1,193 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMPATHDIV_H__
+#define    __PHYDMPATHDIV_H__
+
+#define PATHDIV_VERSION	"1.0"
+
+VOID	
+odm_PathDiversityInit(
+	IN	PVOID	pDM_VOID
+	);
+
+VOID    
+odm_PathDiversity(
+	IN	PVOID	pDM_VOID
+	);
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
+
+//#define   PATHDIV_ENABLE 	 1
+#define dm_PathDiv_RSSI_Check	ODM_PathDivChkPerPktRssi
+#define PathDivCheckBeforeLink8192C	ODM_PathDiversityBeforeLink92C
+
+typedef struct _PathDiv_Parameter_define_
+{
+	u4Byte org_5g_RegE30;
+	u4Byte org_5g_RegC14;
+	u4Byte org_5g_RegCA0;
+	u4Byte swt_5g_RegE30;
+	u4Byte swt_5g_RegC14;
+	u4Byte swt_5g_RegCA0;
+	//for 2G IQK information
+	u4Byte org_2g_RegC80;
+	u4Byte org_2g_RegC4C;
+	u4Byte org_2g_RegC94;
+	u4Byte org_2g_RegC14;
+	u4Byte org_2g_RegCA0;
+
+	u4Byte swt_2g_RegC80;
+	u4Byte swt_2g_RegC4C;
+	u4Byte swt_2g_RegC94;
+	u4Byte swt_2g_RegC14;
+	u4Byte swt_2g_RegCA0;
+}PATHDIV_PARA,*pPATHDIV_PARA;
+
+VOID	
+odm_PathDiversityInit_92C(
+	IN	PADAPTER	Adapter
+	);
+
+VOID	
+odm_2TPathDiversityInit_92C(
+	IN	PADAPTER	Adapter
+	);
+
+VOID	
+odm_1TPathDiversityInit_92C(	
+	IN	PADAPTER	Adapter
+	);
+
+BOOLEAN
+odm_IsConnected_92C(
+	IN	PADAPTER	Adapter
+	);
+
+BOOLEAN 
+ODM_PathDiversityBeforeLink92C(
+	//IN	PADAPTER	Adapter
+	IN		PDM_ODM_T		pDM_Odm
+	);
+
+VOID	
+odm_PathDiversityAfterLink_92C(
+	IN	PADAPTER	Adapter
+	);
+
+VOID
+odm_SetRespPath_92C(	
+	IN	PADAPTER	Adapter, 	
+	IN	u1Byte	DefaultRespPath
+	);
+
+VOID	
+odm_OFDMTXPathDiversity_92C(
+	IN	PADAPTER	Adapter
+	);
+
+VOID	
+odm_CCKTXPathDiversity_92C(	
+	IN	PADAPTER	Adapter
+	);
+
+VOID	
+odm_ResetPathDiversity_92C(	
+	IN	PADAPTER	Adapter
+	);
+
+VOID
+odm_CCKTXPathDiversityCallback(
+	PRT_TIMER		pTimer
+	);
+
+VOID
+odm_CCKTXPathDiversityWorkItemCallback(
+	IN PVOID            pContext
+	);
+
+VOID
+odm_PathDivChkAntSwitchCallback(
+	PRT_TIMER		pTimer
+	);
+
+VOID
+odm_PathDivChkAntSwitchWorkitemCallback(
+	IN PVOID            pContext
+	);
+
+
+VOID 
+odm_PathDivChkAntSwitch(
+	PDM_ODM_T    pDM_Odm
+	);
+
+VOID
+ODM_CCKPathDiversityChkPerPktRssi(
+	PADAPTER		Adapter,
+	BOOLEAN			bIsDefPort,
+	BOOLEAN			bMatchBSSID,
+	PRT_WLAN_STA	pEntry,
+	PRT_RFD			pRfd,
+	pu1Byte			pDesc
+	);
+
+VOID 
+ODM_PathDivChkPerPktRssi(
+	PADAPTER		Adapter,
+	BOOLEAN			bIsDefPort,
+	BOOLEAN			bMatchBSSID,
+	PRT_WLAN_STA	pEntry,
+	PRT_RFD			pRfd	
+	);
+
+VOID
+ODM_PathDivRestAfterLink(
+	IN	PDM_ODM_T		pDM_Odm
+	);
+
+VOID
+ODM_FillTXPathInTXDESC(
+		IN	PADAPTER	Adapter,
+		IN	PRT_TCB		pTcb,
+		IN	pu1Byte		pDesc
+	);
+
+VOID
+odm_PathDivInit_92D(
+	IN	PDM_ODM_T 	pDM_Odm
+	);
+
+u1Byte
+odm_SwAntDivSelectScanChnl(
+	IN	PADAPTER	Adapter
+	);
+
+VOID
+odm_SwAntDivConstructScanChnl(
+	IN	PADAPTER	Adapter,
+	IN	u1Byte		ScanChnl
+	);
+	
+ #endif       //#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
+ 
+ 
+ #endif		 //#ifndef  __ODMPATHDIV_H__
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PowerTracking.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PowerTracking.c
new file mode 100644
index 000000000000..507b250ec174
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PowerTracking.c
@@ -0,0 +1,687 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+//============================================================
+// Global var
+//============================================================
+
+u4Byte	OFDMSwingTable[OFDM_TABLE_SIZE] = {
+	0x7f8001fe,	// 0, +6.0dB
+	0x788001e2,	// 1, +5.5dB
+	0x71c001c7,	// 2, +5.0dB
+	0x6b8001ae,	// 3, +4.5dB
+	0x65400195,	// 4, +4.0dB
+	0x5fc0017f,	// 5, +3.5dB
+	0x5a400169,	// 6, +3.0dB
+	0x55400155,	// 7, +2.5dB
+	0x50800142,	// 8, +2.0dB
+	0x4c000130,	// 9, +1.5dB
+	0x47c0011f,	// 10, +1.0dB
+	0x43c0010f,	// 11, +0.5dB
+	0x40000100,	// 12, +0dB
+	0x3c8000f2,	// 13, -0.5dB
+	0x390000e4,	// 14, -1.0dB
+	0x35c000d7,	// 15, -1.5dB
+	0x32c000cb,	// 16, -2.0dB
+	0x300000c0,	// 17, -2.5dB
+	0x2d4000b5,	// 18, -3.0dB
+	0x2ac000ab,	// 19, -3.5dB
+	0x288000a2,	// 20, -4.0dB
+	0x26000098,	// 21, -4.5dB
+	0x24000090,	// 22, -5.0dB
+	0x22000088,	// 23, -5.5dB
+	0x20000080,	// 24, -6.0dB
+	0x1e400079,	// 25, -6.5dB
+	0x1c800072,	// 26, -7.0dB
+	0x1b00006c,	// 27. -7.5dB
+	0x19800066,	// 28, -8.0dB
+	0x18000060,	// 29, -8.5dB
+	0x16c0005b,	// 30, -9.0dB
+	0x15800056,	// 31, -9.5dB
+	0x14400051,	// 32, -10.0dB
+	0x1300004c,	// 33, -10.5dB
+	0x12000048,	// 34, -11.0dB
+	0x11000044,	// 35, -11.5dB
+	0x10000040,	// 36, -12.0dB
+};
+
+u1Byte	CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},	// 0, +0dB
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 1, -0.5dB
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 2, -1.0dB
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 3, -1.5dB
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 4, -2.0dB 
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 5, -2.5dB
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 6, -3.0dB
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 7, -3.5dB
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 8, -4.0dB 
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 9, -4.5dB
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 10, -5.0dB 
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 11, -5.5dB
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 12, -6.0dB <== default
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 13, -6.5dB
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 14, -7.0dB 
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 15, -7.5dB
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 17, -8.5dB
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 18, -9.0dB 
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 19, -9.5dB
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 20, -10.0dB
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 21, -10.5dB
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 22, -11.0dB
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	// 23, -11.5dB
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	// 24, -12.0dB
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	// 25, -12.5dB
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	// 26, -13.0dB
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	// 27, -13.5dB
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	// 28, -14.0dB
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	// 29, -14.5dB
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	// 30, -15.0dB
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	// 31, -15.5dB
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}	// 32, -16.0dB
+};
+
+
+u1Byte	CCKSwingTable_Ch14[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	// 0, +0dB  
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 1, -0.5dB 
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 2, -1.0dB  
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 3, -1.5dB
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 4, -2.0dB  
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 5, -2.5dB
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 6, -3.0dB  
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 7, -3.5dB  
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 8, -4.0dB  
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 9, -4.5dB
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 10, -5.0dB  
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 11, -5.5dB
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 12, -6.0dB  <== default
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 13, -6.5dB 
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 14, -7.0dB  
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 15, -7.5dB
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 17, -8.5dB
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 18, -9.0dB  
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 19, -9.5dB
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 20, -10.0dB
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 21, -10.5dB
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 22, -11.0dB
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 23, -11.5dB
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 24, -12.0dB
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	// 25, -12.5dB
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 26, -13.0dB
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 27, -13.5dB
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 28, -14.0dB
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 29, -14.5dB
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 30, -15.0dB
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 31, -15.5dB
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}	// 32, -16.0dB
+};
+
+
+u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE] = {
+	0x0b40002d, // 0,  -15.0dB	
+	0x0c000030, // 1,  -14.5dB
+	0x0cc00033, // 2,  -14.0dB
+	0x0d800036, // 3,  -13.5dB
+	0x0e400039, // 4,  -13.0dB    
+	0x0f00003c, // 5,  -12.5dB
+	0x10000040, // 6,  -12.0dB
+	0x11000044, // 7,  -11.5dB
+	0x12000048, // 8,  -11.0dB
+	0x1300004c, // 9,  -10.5dB
+	0x14400051, // 10, -10.0dB
+	0x15800056, // 11, -9.5dB
+	0x16c0005b, // 12, -9.0dB
+	0x18000060, // 13, -8.5dB
+	0x19800066, // 14, -8.0dB
+	0x1b00006c, // 15, -7.5dB
+	0x1c800072, // 16, -7.0dB
+	0x1e400079, // 17, -6.5dB
+	0x20000080, // 18, -6.0dB
+	0x22000088, // 19, -5.5dB
+	0x24000090, // 20, -5.0dB
+	0x26000098, // 21, -4.5dB
+	0x288000a2, // 22, -4.0dB
+	0x2ac000ab, // 23, -3.5dB
+	0x2d4000b5, // 24, -3.0dB
+	0x300000c0, // 25, -2.5dB
+	0x32c000cb, // 26, -2.0dB
+	0x35c000d7, // 27, -1.5dB
+	0x390000e4, // 28, -1.0dB
+	0x3c8000f2, // 29, -0.5dB
+	0x40000100, // 30, +0dB
+	0x43c0010f, // 31, +0.5dB
+	0x47c0011f, // 32, +1.0dB
+	0x4c000130, // 33, +1.5dB
+	0x50800142, // 34, +2.0dB
+	0x55400155, // 35, +2.5dB
+	0x5a400169, // 36, +3.0dB
+	0x5fc0017f, // 37, +3.5dB
+	0x65400195, // 38, +4.0dB
+	0x6b8001ae, // 39, +4.5dB
+	0x71c001c7, // 40, +5.0dB
+	0x788001e2, // 41, +5.5dB
+	0x7f8001fe  // 42, +6.0dB
+};               
+
+
+u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8] = {
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 14, -9.0dB 
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 18, -7.0dB 
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 19, -6.5dB
+    {0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 20, -6.0dB 
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 22, -5.0dB 
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 24, -4.0dB 
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 25, -3.5dB
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 26, -3.0dB
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 28, -2.0dB 
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 30, -1.0dB
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 31, -0.5dB
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04} 	// 32, +0dB
+};                                                                  
+
+
+u1Byte CCKSwingTable_Ch14_New[CCK_TABLE_SIZE][8]= {
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00},	//  0, -16.0dB
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  1, -15.5dB
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	//  2, -15.0dB
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  3, -14.5dB
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	//  4, -14.0dB
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  5, -13.5dB
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	//  6, -13.0dB
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	//  7, -12.5dB
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  8, -12.0dB
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	//  9, -11.5dB
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 10, -11.0dB
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 11, -10.5dB
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 12, -10.0dB
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 13, -9.5dB
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 14, -9.0dB  
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 15, -8.5dB
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 17, -7.5dB
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 18, -7.0dB  
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 19, -6.5dB 
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 20, -6.0dB  
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 21, -5.5dB
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 22, -5.0dB  
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 23, -4.5dB
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 24, -4.0dB  
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 25, -3.5dB  
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 26, -3.0dB  
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 27, -2.5dB
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 28, -2.0dB  
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 29, -1.5dB
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 30, -1.0dB  
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 31, -0.5dB 
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00} 	// 32, +0dB	
+};
+
+u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE] =
+{
+	0x081, // 0,  -12.0dB
+	0x088, // 1,  -11.5dB
+	0x090, // 2,  -11.0dB
+	0x099, // 3,  -10.5dB
+	0x0A2, // 4,  -10.0dB
+	0x0AC, // 5,  -9.5dB
+	0x0B6, // 6,  -9.0dB
+	0x0C0, // 7,  -8.5dB
+	0x0CC, // 8,  -8.0dB
+	0x0D8, // 9,  -7.5dB
+	0x0E5, // 10, -7.0dB
+	0x0F2, // 11, -6.5dB
+	0x101, // 12, -6.0dB
+	0x110, // 13, -5.5dB
+	0x120, // 14, -5.0dB
+	0x131, // 15, -4.5dB
+	0x143, // 16, -4.0dB
+	0x156, // 17, -3.5dB
+	0x16A, // 18, -3.0dB
+	0x180, // 19, -2.5dB
+	0x197, // 20, -2.0dB
+	0x1AF, // 21, -1.5dB
+	0x1C8, // 22, -1.0dB
+	0x1E3, // 23, -0.5dB
+	0x200, // 24, +0  dB
+	0x21E, // 25, +0.5dB
+	0x23E, // 26, +1.0dB
+	0x261, // 27, +1.5dB
+	0x285, // 28, +2.0dB
+	0x2AB, // 29, +2.5dB
+	0x2D3, // 30, +3.0dB
+	0x2FE, // 31, +3.5dB
+	0x32B, // 32, +4.0dB
+	0x35C, // 33, +4.5dB
+	0x38E, // 34, +5.0dB
+	0x3C4, // 35, +5.5dB
+	0x3FE  // 36, +6.0dB	
+};
+
+#ifdef AP_BUILD_WORKAROUND
+
+unsigned int TxPwrTrk_OFDM_SwingTbl[TxPwrTrk_OFDM_SwingTbl_Len] = {
+	/*  +6.0dB */ 0x7f8001fe,
+	/*  +5.5dB */ 0x788001e2,
+	/*  +5.0dB */ 0x71c001c7,
+	/*  +4.5dB */ 0x6b8001ae,
+	/*  +4.0dB */ 0x65400195,
+	/*  +3.5dB */ 0x5fc0017f,
+	/*  +3.0dB */ 0x5a400169,
+	/*  +2.5dB */ 0x55400155,
+	/*  +2.0dB */ 0x50800142,
+	/*  +1.5dB */ 0x4c000130,
+	/*  +1.0dB */ 0x47c0011f,
+	/*  +0.5dB */ 0x43c0010f,
+	/*   0.0dB */ 0x40000100,
+	/*  -0.5dB */ 0x3c8000f2,
+	/*  -1.0dB */ 0x390000e4,
+	/*  -1.5dB */ 0x35c000d7,
+	/*  -2.0dB */ 0x32c000cb,
+	/*  -2.5dB */ 0x300000c0,
+	/*  -3.0dB */ 0x2d4000b5,
+	/*  -3.5dB */ 0x2ac000ab,
+	/*  -4.0dB */ 0x288000a2,
+	/*  -4.5dB */ 0x26000098,
+	/*  -5.0dB */ 0x24000090,
+	/*  -5.5dB */ 0x22000088,
+	/*  -6.0dB */ 0x20000080,
+	/*  -6.5dB */ 0x1a00006c,
+	/*  -7.0dB */ 0x1c800072,
+	/*  -7.5dB */ 0x18000060,
+	/*  -8.0dB */ 0x19800066,
+	/*  -8.5dB */ 0x15800056,
+	/*  -9.0dB */ 0x26c0005b,
+	/*  -9.5dB */ 0x14400051,
+	/* -10.0dB */ 0x24400051,
+	/* -10.5dB */ 0x1300004c,
+	/* -11.0dB */ 0x12000048,
+	/* -11.5dB */ 0x11000044,
+	/* -12.0dB */ 0x10000040
+};
+#endif
+
+
+
+VOID
+odm_TXPowerTrackingInit(
+	IN 	PVOID	 	pDM_VOID 
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	if(!(pDM_Odm->SupportICType & (ODM_RTL8814A|ODM_IC_11N_SERIES)))
+		return;
+#endif
+
+	odm_TXPowerTrackingThermalMeterInit(pDM_Odm);
+}	
+
+u1Byte 
+getSwingIndex(
+	IN 	PVOID	 	pDM_VOID 
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u1Byte 			i = 0;
+	u4Byte 			bbSwing;
+	u4Byte 			swingTableSize;
+	pu4Byte 			pSwingTable;
+
+	if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8723B ||
+		pDM_Odm->SupportICType == ODM_RTL8192E) 
+	{
+		bbSwing = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, 0xFFC00000);
+
+		pSwingTable = OFDMSwingTable_New;
+		swingTableSize = OFDM_TABLE_SIZE;
+	} else {
+#if ((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
+		if (pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8821)
+		{
+			bbSwing = PHY_GetTxBBSwing_8812A(Adapter, pHalData->CurrentBandType, ODM_RF_PATH_A);
+			pSwingTable = TxScalingTable_Jaguar;
+			swingTableSize = TXSCALE_TABLE_SIZE;
+		}
+		else
+#endif
+		{
+			bbSwing = 0;
+			pSwingTable = OFDMSwingTable;
+			swingTableSize = OFDM_TABLE_SIZE;
+		}
+	}
+
+	for (i = 0; i < swingTableSize; ++i) {
+		u4Byte tableValue = pSwingTable[i];
+		
+		if (tableValue >= 0x100000 )
+			tableValue >>= 22;
+		if (bbSwing == tableValue)
+			break;
+	}
+	return i;
+}
+
+VOID
+odm_TXPowerTrackingThermalMeterInit(
+	IN 	PVOID	 	pDM_VOID 
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte defaultSwingIndex = getSwingIndex(pDM_Odm);
+	u1Byte 			p = 0;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	if(pDM_Odm->mp_mode == FALSE)
+		pHalData->TxPowerTrackControl = TRUE;
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PADAPTER			Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+
+
+	if (pDM_Odm->SupportICType >= ODM_RTL8188E) 
+	{
+		pDM_Odm->RFCalibrateInfo.bTXPowerTracking = _TRUE;
+		pDM_Odm->RFCalibrateInfo.TXPowercount = 0;
+		pDM_Odm->RFCalibrateInfo.bTXPowerTrackingInit = _FALSE;
+		
+		if(pDM_Odm->mp_mode == FALSE)
+			pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = _TRUE;
+		else
+			pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = _FALSE;
+
+		MSG_8192C("pDM_Odm TxPowerTrackControl = %d\n", pDM_Odm->RFCalibrateInfo.TxPowerTrackControl);
+	}
+	else
+	{
+		struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+		pdmpriv->bTXPowerTracking = _TRUE;
+		pdmpriv->TXPowercount = 0;
+		pdmpriv->bTXPowerTrackingInit = _FALSE;
+		//#if	(MP_DRIVER != 1)		//for mp driver, turn off txpwrtracking as default
+
+		if(pDM_Odm->mp_mode == FALSE)
+			pdmpriv->TxPowerTrackControl = _TRUE;
+		else
+			pdmpriv->TxPowerTrackControl = _FALSE;
+
+
+		//MSG_8192C("pdmpriv->TxPowerTrackControl = %d\n", pdmpriv->TxPowerTrackControl);
+	}
+	
+#elif (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	#ifdef RTL8188E_SUPPORT
+	{
+		pDM_Odm->RFCalibrateInfo.bTXPowerTracking = _TRUE;
+		pDM_Odm->RFCalibrateInfo.TXPowercount = 0;
+		pDM_Odm->RFCalibrateInfo.bTXPowerTrackingInit = _FALSE;
+		pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = _TRUE;
+	}
+	#endif
+#endif
+
+	//pDM_Odm->RFCalibrateInfo.TxPowerTrackControl = TRUE;
+	pDM_Odm->RFCalibrateInfo.ThermalValue = pHalData->EEPROMThermalMeter;
+	pDM_Odm->RFCalibrateInfo.ThermalValue_IQK = pHalData->EEPROMThermalMeter;
+	pDM_Odm->RFCalibrateInfo.ThermalValue_LCK = pHalData->EEPROMThermalMeter;	
+
+	// The index of "0 dB" in SwingTable.
+	if (pDM_Odm->SupportICType == ODM_RTL8188E || pDM_Odm->SupportICType == ODM_RTL8723B ||
+		pDM_Odm->SupportICType == ODM_RTL8192E) 
+	{
+		pDM_Odm->DefaultOfdmIndex = (defaultSwingIndex >= OFDM_TABLE_SIZE) ? 30 : defaultSwingIndex;
+		pDM_Odm->DefaultCckIndex = 20;	
+	}
+	else
+	{
+		pDM_Odm->DefaultOfdmIndex = (defaultSwingIndex >= TXSCALE_TABLE_SIZE) ? 24 : defaultSwingIndex;
+		pDM_Odm->DefaultCckIndex = 24;	
+	}
+
+	pDM_Odm->BbSwingIdxCckBase = pDM_Odm->DefaultCckIndex;
+	pDM_Odm->RFCalibrateInfo.CCK_index = pDM_Odm->DefaultCckIndex;
+	
+	for (p = ODM_RF_PATH_A; p < MAX_RF_PATH; ++p)
+	{
+		pDM_Odm->BbSwingIdxOfdmBase[p] = pDM_Odm->DefaultOfdmIndex;		
+	   	pDM_Odm->RFCalibrateInfo.OFDM_index[p] = pDM_Odm->DefaultOfdmIndex;		
+		pDM_Odm->RFCalibrateInfo.DeltaPowerIndex[p] = 0;
+		pDM_Odm->RFCalibrateInfo.DeltaPowerIndexLast[p] = 0;
+		pDM_Odm->RFCalibrateInfo.PowerIndexOffset[p] = 0;
+	}
+
+}
+
+
+VOID
+ODM_TXPowerTrackingCheck(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+			odm_TXPowerTrackingCheckMP(pDM_Odm);
+			break;
+
+		case	ODM_CE:
+			odm_TXPowerTrackingCheckCE(pDM_Odm);
+			break;
+
+		case	ODM_AP:
+			odm_TXPowerTrackingCheckAP(pDM_Odm);		
+			break;		
+
+		case	ODM_ADSL:
+			//odm_DIGAP(pDM_Odm);
+			break;	
+	}
+
+}
+
+VOID
+odm_TXPowerTrackingCheckCE(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	#if( (RTL8192C_SUPPORT==1) ||  (RTL8723A_SUPPORT==1) )
+	if(IS_HARDWARE_TYPE_8192C(Adapter)){
+		rtl8192c_odm_CheckTXPowerTracking(Adapter);
+		return;
+	}
+	#endif
+
+	#if (RTL8192D_SUPPORT==1) 
+	if(IS_HARDWARE_TYPE_8192D(Adapter)){	
+		#if (RTL8192D_EASY_SMART_CONCURRENT == 1)
+		if(!Adapter->bSlaveOfDMSP)
+		#endif
+			rtl8192d_odm_CheckTXPowerTracking(Adapter);
+		return;	
+	}
+	#endif
+
+	#if(((RTL8188E_SUPPORT==1) ||  (RTL8812A_SUPPORT==1) ||  (RTL8821A_SUPPORT==1) ||  (RTL8192E_SUPPORT==1)  ||  (RTL8723B_SUPPORT==1)  ))
+	if(!(pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK))
+	{
+		return;
+	}
+
+	if(!pDM_Odm->RFCalibrateInfo.TM_Trigger)		//at least delay 1 sec
+	{
+		//pHalData->TxPowerCheckCnt++;	//cosa add for debug
+		if(IS_HARDWARE_TYPE_8188E(Adapter) || IS_HARDWARE_TYPE_JAGUAR(Adapter) || IS_HARDWARE_TYPE_8192E(Adapter)||IS_HARDWARE_TYPE_8723B(Adapter))
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_T_METER_NEW, (BIT17 | BIT16), 0x03);
+		else
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_T_METER_OLD, bRFRegOffsetMask, 0x60);
+		
+		//DBG_871X("Trigger Thermal Meter!!\n");
+		
+		pDM_Odm->RFCalibrateInfo.TM_Trigger = 1;
+		return;
+	}
+	else
+	{
+		//DBG_871X("Schedule TxPowerTracking direct call!!\n");
+		ODM_TXPowerTrackingCallback_ThermalMeter(Adapter);
+		pDM_Odm->RFCalibrateInfo.TM_Trigger = 0;
+	}
+	#endif
+#endif	
+}
+
+VOID
+odm_TXPowerTrackingCheckMP(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+
+	if (ODM_CheckPowerStatus(Adapter) == FALSE) 
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD, ("===>ODM_CheckPowerStatus() return FALSE\n"));
+		return;
+	}
+
+	if(IS_HARDWARE_TYPE_8723A(Adapter))
+		return;
+
+	if(!Adapter->bSlaveOfDMSP || Adapter->DualMacSmartConcurrent == FALSE)
+		odm_TXPowerTrackingThermalMeterCheck(Adapter);
+	else {
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD, ("!Adapter->bSlaveOfDMSP || Adapter->DualMacSmartConcurrent == FALSE\n"));
+	}
+#endif
+	
+}
+
+
+VOID
+odm_TXPowerTrackingCheckAP(
+	IN 	PVOID	 	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+	prtl8192cd_priv	priv		= pDM_Odm->priv;
+
+	if ( (priv->pmib->dot11RFEntry.ther) && ((priv->up_time % priv->pshare->rf_ft_var.tpt_period) == 0)){
+#ifdef CONFIG_RTL_92D_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8192D){
+			tx_power_tracking_92D(priv);
+		} else 
+#endif
+		{
+#ifdef CONFIG_RTL_92C_SUPPORT			
+			tx_power_tracking(priv);
+#endif
+		}
+	}
+#endif	
+
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+odm_TXPowerTrackingThermalMeterCheck(
+	IN	PADAPTER		Adapter
+	)
+{
+#ifndef AP_BUILD_WORKAROUND
+	static u1Byte			TM_Trigger = 0;
+
+	if(!(GET_HAL_DATA(Adapter)->DM_OutSrc.SupportAbility & ODM_RF_TX_PWR_TRACK))
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,
+			("===>odm_TXPowerTrackingThermalMeterCheck(),pMgntInfo->bTXPowerTracking is FALSE, return!!\n"));
+		return;
+	}
+
+	if(!TM_Trigger)		//at least delay 1 sec
+	{
+		if(IS_HARDWARE_TYPE_8192D(Adapter))
+			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER_92D, BIT17 | BIT16, 0x03);
+		else if(IS_HARDWARE_TYPE_8188E(Adapter) || IS_HARDWARE_TYPE_JAGUAR(Adapter) || IS_HARDWARE_TYPE_8192E(Adapter) ||
+			    IS_HARDWARE_TYPE_8723B(Adapter))
+			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER_88E, BIT17 | BIT16, 0x03);
+		else
+			PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
+		
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Trigger Thermal Meter!!\n"));
+		
+		TM_Trigger = 1;
+		return;
+	}
+	else
+	{
+		RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Schedule TxPowerTracking direct call!!\n"));		
+		odm_TXPowerTrackingDirectCall(Adapter); //Using direct call is instead, added by Roger, 2009.06.18.
+		TM_Trigger = 0;
+	}
+#endif
+}
+#endif
+
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PowerTracking.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PowerTracking.h
new file mode 100644
index 000000000000..727cdb14a816
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_PowerTracking.h
@@ -0,0 +1,248 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMPOWERTRACKING_H__
+#define    __PHYDMPOWERTRACKING_H__
+
+#define POWRTRACKING_VERSION	"1.0"
+
+#define		DPK_DELTA_MAPPING_NUM	13
+#define		index_mapping_HP_NUM	15	
+#define	OFDM_TABLE_SIZE 	43
+#define	CCK_TABLE_SIZE			33
+#define TXSCALE_TABLE_SIZE 		37
+#define TXPWR_TRACK_TABLE_SIZE 	30
+#define DELTA_SWINGIDX_SIZE     30
+#define BAND_NUM 				4
+
+#define AVG_THERMAL_NUM		8
+#define HP_THERMAL_NUM		8
+#define IQK_MAC_REG_NUM		4
+#define IQK_ADDA_REG_NUM		16
+#define IQK_BB_REG_NUM_MAX	10
+#if (RTL8192D_SUPPORT==1) 
+#define IQK_BB_REG_NUM		10
+#else
+#define IQK_BB_REG_NUM		9
+#endif
+
+
+#define IQK_Matrix_REG_NUM	8
+#define IQK_Matrix_Settings_NUM	14+24+21 // Channels_2_4G_NUM + Channels_5G_20M_NUM + Channels_5G
+
+extern	u4Byte OFDMSwingTable[OFDM_TABLE_SIZE];
+extern	u1Byte CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch14 [CCK_TABLE_SIZE][8];
+
+extern	u4Byte OFDMSwingTable_New[OFDM_TABLE_SIZE];
+extern	u1Byte CCKSwingTable_Ch1_Ch13_New[CCK_TABLE_SIZE][8];
+extern	u1Byte CCKSwingTable_Ch14_New [CCK_TABLE_SIZE][8];
+
+extern  u4Byte TxScalingTable_Jaguar[TXSCALE_TABLE_SIZE];
+
+// <20121018, Kordan> In case fail to read TxPowerTrack.txt, we use the table of 88E as the default table.
+static u1Byte DeltaSwingTableIdx_2GA_P_8188E[] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+static u1Byte DeltaSwingTableIdx_2GA_N_8188E[] = {0, 0, 0, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11}; 
+
+#define dm_CheckTXPowerTracking 	ODM_TXPowerTrackingCheck
+
+typedef struct _IQK_MATRIX_REGS_SETTING{
+	BOOLEAN 	bIQKDone;
+	s4Byte		Value[3][IQK_Matrix_REG_NUM];
+	BOOLEAN 	bBWIqkResultSaved[3];	
+}IQK_MATRIX_REGS_SETTING,*PIQK_MATRIX_REGS_SETTING;
+
+typedef struct ODM_RF_Calibration_Structure
+{
+	//for tx power tracking
+	
+	u4Byte	RegA24; // for TempCCK
+	s4Byte	RegE94;
+	s4Byte 	RegE9C;
+	s4Byte	RegEB4;
+	s4Byte	RegEBC;	
+
+	u1Byte  	TXPowercount;
+	BOOLEAN bTXPowerTrackingInit; 
+	BOOLEAN bTXPowerTracking;
+	u1Byte  	TxPowerTrackControl; //for mp mode, turn off txpwrtracking as default
+	u1Byte  	TM_Trigger;
+    	u1Byte  	InternalPA5G[2];	//pathA / pathB
+	
+	u1Byte  	ThermalMeter[2];    // ThermalMeter, index 0 for RFIC0, and 1 for RFIC1
+	u1Byte  	ThermalValue;
+	u1Byte  	ThermalValue_LCK;
+	u1Byte  	ThermalValue_IQK;
+	u1Byte	ThermalValue_DPK;		
+	u1Byte	ThermalValue_AVG[AVG_THERMAL_NUM];
+	u1Byte	ThermalValue_AVG_index;		
+	u1Byte	ThermalValue_RxGain;
+	u1Byte	ThermalValue_Crystal;
+	u1Byte	ThermalValue_DPKstore;
+	u1Byte	ThermalValue_DPKtrack;
+	BOOLEAN	TxPowerTrackingInProgress;
+	
+	BOOLEAN	bReloadtxpowerindex;	
+	u1Byte 	bRfPiEnable;
+	u4Byte 	TXPowerTrackingCallbackCnt; //cosa add for debug
+
+
+	//------------------------- Tx power Tracking -------------------------//
+	u1Byte 	bCCKinCH14;
+	u1Byte 	CCK_index;
+	u1Byte 	OFDM_index[MAX_RF_PATH];
+	s1Byte	PowerIndexOffset[MAX_RF_PATH];
+	s1Byte	DeltaPowerIndex[MAX_RF_PATH];
+	s1Byte	DeltaPowerIndexLast[MAX_RF_PATH];	
+	BOOLEAN bTxPowerChanged;
+		
+	u1Byte 	ThermalValue_HP[HP_THERMAL_NUM];
+	u1Byte 	ThermalValue_HP_index;
+	IQK_MATRIX_REGS_SETTING IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];
+	u1Byte	Delta_LCK;
+	s1Byte  BBSwingDiff2G, BBSwingDiff5G; // Unit: dB
+    u1Byte  DeltaSwingTableIdx_2GCCKA_P[DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_2GCCKA_N[DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_2GCCKB_P[DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_2GCCKB_N[DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_2GA_P[DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_2GA_N[DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_2GB_P[DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_2GB_N[DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_5GA_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_5GA_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_5GB_P[BAND_NUM][DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_5GB_N[BAND_NUM][DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_2GA_P_8188E[DELTA_SWINGIDX_SIZE];
+    u1Byte  DeltaSwingTableIdx_2GA_N_8188E[DELTA_SWINGIDX_SIZE];
+    
+    
+	//--------------------------------------------------------------------//	
+	
+	//for IQK	
+	u4Byte 	RegC04;
+	u4Byte 	Reg874;
+	u4Byte 	RegC08;
+	u4Byte 	RegB68;
+	u4Byte 	RegB6C;
+	u4Byte 	Reg870;
+	u4Byte 	Reg860;
+	u4Byte 	Reg864;
+	
+	BOOLEAN	bIQKInitialized;
+	BOOLEAN bLCKInProgress;
+	BOOLEAN	bAntennaDetected;
+	BOOLEAN	bNeedIQK;
+	BOOLEAN	bIQKInProgress;	
+	u1Byte	Delta_IQK;
+	u4Byte	ADDA_backup[IQK_ADDA_REG_NUM];
+	u4Byte	IQK_MAC_backup[IQK_MAC_REG_NUM];
+	u4Byte	IQK_BB_backup_recover[9];
+	u4Byte	IQK_BB_backup[IQK_BB_REG_NUM];	
+	u4Byte 	TxIQC_8723B[2][3][2]; // { {S1: 0xc94, 0xc80, 0xc4c} , {S0: 0xc9c, 0xc88, 0xc4c}}
+	u4Byte 	RxIQC_8723B[2][2][2]; // { {S1: 0xc14, 0xca0} ,           {S0: 0xc14, 0xca0}}
+
+	// <James> IQK time measurement 
+	u8Byte	IQK_StartTime;
+	u8Byte	IQK_ProgressingTime;
+
+	//for APK
+	u4Byte 	APKoutput[2][2]; //path A/B; output1_1a/output1_2a
+	u1Byte 	bAPKdone;
+	u1Byte 	bAPKThermalMeterIgnore;
+	
+	// DPK
+	BOOLEAN bDPKFail;	
+	u1Byte 	bDPdone;
+	u1Byte 	bDPPathAOK;
+	u1Byte 	bDPPathBOK;
+
+	u4Byte	TxLOK[2];
+
+}ODM_RF_CAL_T,*PODM_RF_CAL_T;
+
+
+VOID	
+ODM_TXPowerTrackingCheck(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+
+VOID
+odm_TXPowerTrackingInit(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingCheckAP(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingThermalMeterInit(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingInit(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+VOID
+odm_TXPowerTrackingCheckMP(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+
+VOID
+odm_TXPowerTrackingCheckCE(
+	IN 	PVOID	 	pDM_VOID
+	);
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN)) 
+
+VOID 
+odm_TXPowerTrackingCallbackThermalMeter92C(
+            IN PADAPTER	Adapter
+            );
+
+VOID
+odm_TXPowerTrackingCallbackRXGainThermalMeter92D(
+	IN PADAPTER 	Adapter
+	);
+
+VOID
+odm_TXPowerTrackingCallbackThermalMeter92D(
+            IN PADAPTER	Adapter
+            );
+
+VOID
+odm_TXPowerTrackingDirectCall92C(
+            IN	PADAPTER		Adapter
+            );
+
+VOID
+odm_TXPowerTrackingThermalMeterCheck(
+	IN	PADAPTER		Adapter
+	);
+
+#endif
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RXHP.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RXHP.c
new file mode 100644
index 000000000000..fcdcb0eca354
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RXHP.c
@@ -0,0 +1,1685 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+#define	AFH_PSD		1	//0:normal PSD scan, 1: only do 20 pts PSD
+#define	MODE_40M		0	//0:20M, 1:40M
+#define	PSD_TH2		3  
+#define	PSD_CHMIN		20   // Minimum channel number for BT AFH
+#define	SIR_STEP_SIZE	3
+#define   Smooth_Size_1 	5
+#define	Smooth_TH_1	3
+#define   Smooth_Size_2 	10
+#define	Smooth_TH_2	4
+#define   Smooth_Size_3 	20
+#define	Smooth_TH_3	4
+#define   Smooth_Step_Size 5
+#define	Adaptive_SIR	1
+#define	SCAN_INTERVAL	1500 //ms
+#define	SYN_Length		5    // for 92D
+	
+#define	LNA_Low_Gain_1                      0x64
+#define	LNA_Low_Gain_2                      0x5A
+#define	LNA_Low_Gain_3                      0x58
+
+#define	pw_th_10dB					0x0
+#define	pw_th_16dB					0x3
+
+#define	FA_RXHP_TH1                           5000
+#define	FA_RXHP_TH2                           1500
+#define	FA_RXHP_TH3                             800
+#define	FA_RXHP_TH4                             600
+#define	FA_RXHP_TH5                             500
+
+#define	Idle_Mode					0
+#define	High_TP_Mode				1
+#define	Low_TP_Mode				2
+
+
+VOID
+odm_PSDMonitorInit(
+	IN		PVOID			pDM_VOID
+	)
+{
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)|(DEV_BUS_TYPE == RT_USB_INTERFACE)
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+
+	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	//PSD Monitor Setting
+	//Which path in ADC/DAC is turnned on for PSD: both I/Q
+	ODM_SetBBReg(pDM_Odm, ODM_PSDREG, BIT10|BIT11, 0x3);
+	//Ageraged number: 8
+	ODM_SetBBReg(pDM_Odm, ODM_PSDREG, BIT12|BIT13, 0x1);
+	pDM_Odm->bPSDinProcess = FALSE;
+	pDM_Odm->bUserAssignLevel = FALSE;
+	pDM_Odm->bPSDactive = FALSE;
+	//pDM_Odm->bDMInitialGainEnable=TRUE;		//change the initialization to DIGinit
+	//Set Debug Port
+	//PHY_SetBBReg(Adapter, 0x908, bMaskDWord, 0x803);
+	//PHY_SetBBReg(Adapter, 0xB34, bMaskByte0, 0x00); // pause PSD
+	//PHY_SetBBReg(Adapter, 0xB38, bMaskByte0, 10); //rescan
+	//PHY_SetBBReg(Adapter, 0xB38, bMaskByte2|bMaskByte3, 100); //interval
+
+	//PlatformSetTimer( Adapter, &pHalData->PSDTriggerTimer, 0); //ms
+#endif
+}
+
+VOID
+PatchDCTone(
+	IN		PVOID			pDM_VOID,
+	pu4Byte		PSD_report,
+	u1Byte 		initial_gain_psd
+)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	//PADAPTER	pAdapter;
+	
+	u4Byte	psd_report;
+
+	//2 Switch to CH11 to patch CH9 and CH13 DC tone
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, 11);
+	
+	if(pDM_Odm->SupportICType== ODM_RTL8192D)
+	{
+		if((*(pDM_Odm->pMacPhyMode) == ODM_SMSP)||(*(pDM_Odm->pMacPhyMode) == ODM_DMSP))
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, 0x3FF, 11);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x25, 0xfffff, 0x643BC);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x26, 0xfffff, 0xFC038);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, 0xfffff, 0x77C1A);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2B, 0xfffff, 0x41289);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2C, 0xfffff, 0x01840);
+		}
+		else
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x25, 0xfffff, 0x643BC);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x26, 0xfffff, 0xFC038);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, 0xfffff, 0x77C1A);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2B, 0xfffff, 0x41289);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2C, 0xfffff, 0x01840);
+		}
+	}
+	
+	//Ch9 DC tone patch
+	psd_report = GetPSDData(pDM_Odm, 96, initial_gain_psd);
+	PSD_report[50] = psd_report;
+	//Ch13 DC tone patch
+	psd_report = GetPSDData(pDM_Odm, 32, initial_gain_psd);
+	PSD_report[70] = psd_report;
+	
+	//2 Switch to CH3 to patch CH1 and CH5 DC tone
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, 3);
+
+	
+	if(pDM_Odm->SupportICType==ODM_RTL8192D)
+	{
+		if((*(pDM_Odm->pMacPhyMode) == ODM_SMSP)||(*(pDM_Odm->pMacPhyMode) == ODM_DMSP))
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, 0x3FF, 3);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x25, 0xfffff, 0x643BC);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x26, 0xfffff, 0xFC038);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, 0xfffff, 0x07C1A);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x2B, 0xfffff, 0x61289);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_B, 0x2C, 0xfffff, 0x01C41);
+		}
+		else
+		{
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x25, 0xfffff, 0x643BC);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x26, 0xfffff, 0xFC038);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, 0xfffff, 0x07C1A);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x2B, 0xfffff, 0x61289);
+			//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, 0x2C, 0xfffff, 0x01C41);
+		}
+	}
+	
+	//Ch1 DC tone patch
+	psd_report = GetPSDData(pDM_Odm, 96, initial_gain_psd);
+	PSD_report[10] = psd_report;
+	//Ch5 DC tone patch
+	psd_report = GetPSDData(pDM_Odm, 32, initial_gain_psd);
+	PSD_report[30] = psd_report;
+
+}
+
+
+VOID
+GoodChannelDecision(
+	IN		PVOID			pDM_VOID,
+	pu4Byte		PSD_report,
+	pu1Byte		PSD_bitmap,
+	u1Byte 		RSSI_BT,
+	pu1Byte		PSD_bitmap_memory)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRXHP_T			pRX_HP_Table = &pDM_Odm->DM_RXHP_Table;
+	//s4Byte	TH1 =  SSBT-0x15;    // modify TH by Neil Chen
+	s4Byte	TH1= RSSI_BT+0x14;
+	s4Byte	TH2 = RSSI_BT+85;
+	//u2Byte    TH3;
+//	s4Byte	RegB34;
+	u1Byte	bitmap, Smooth_size[3], Smooth_TH[3];
+	//u1Byte	psd_bit;
+	u4Byte	i,n,j, byte_idx, bit_idx, good_cnt, good_cnt_smoothing, Smooth_Interval[3];
+	int 		start_byte_idx,start_bit_idx,cur_byte_idx, cur_bit_idx,NOW_byte_idx ;
+	
+//	RegB34 = PHY_QueryBBReg(Adapter,0xB34, bMaskDWord)&0xFF;
+
+	if((pDM_Odm->SupportICType == ODM_RTL8192C)||(pDM_Odm->SupportICType == ODM_RTL8192D))
+       {
+            TH1 = RSSI_BT + 0x14;  
+	}
+
+	Smooth_size[0]=Smooth_Size_1;
+	Smooth_size[1]=Smooth_Size_2;
+	Smooth_size[2]=Smooth_Size_3;
+	Smooth_TH[0]=Smooth_TH_1;
+	Smooth_TH[1]=Smooth_TH_2;
+	Smooth_TH[2]=Smooth_TH_3;
+	Smooth_Interval[0]=16;
+	Smooth_Interval[1]=15;
+	Smooth_Interval[2]=13;
+	good_cnt = 0;
+	if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	{
+		//2 Threshold  
+
+		if(RSSI_BT >=41)
+			TH1 = 113;	
+		else if(RSSI_BT >=38)   // >= -15dBm
+			TH1 = 105;                              //0x69
+		else if((RSSI_BT >=33)&(RSSI_BT <38))
+			TH1 = 99+(RSSI_BT-33);         //0x63
+		else if((RSSI_BT >=26)&(RSSI_BT<33))
+			TH1 = 99-(33-RSSI_BT)+2;     //0x5e
+	 	else if((RSSI_BT >=24)&(RSSI_BT<26))
+			TH1 = 88-((RSSI_BT-24)*3);   //0x58
+		else if((RSSI_BT >=18)&(RSSI_BT<24))
+			TH1 = 77+((RSSI_BT-18)*2);
+		else if((RSSI_BT >=14)&(RSSI_BT<18))
+			TH1 = 63+((RSSI_BT-14)*2);
+		else if((RSSI_BT >=8)&(RSSI_BT<14))
+			TH1 = 58+((RSSI_BT-8)*2);
+		else if((RSSI_BT >=3)&(RSSI_BT<8))
+			TH1 = 52+(RSSI_BT-3);
+		else
+			TH1 = 51;
+	}
+
+	for (i = 0; i< 10; i++)
+		PSD_bitmap[i] = 0;
+	
+
+	 // Add By Gary
+       for (i=0; i<80; i++)
+	   	pRX_HP_Table->PSD_bitmap_RXHP[i] = 0;
+	// End
+
+
+
+	if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	{
+		TH1 =TH1-SIR_STEP_SIZE;
+	}
+	while (good_cnt < PSD_CHMIN)
+	{
+		good_cnt = 0;
+		if(pDM_Odm->SupportICType==ODM_RTL8723A)
+		{
+		if(TH1 ==TH2)
+			break;
+		if((TH1+SIR_STEP_SIZE) < TH2)
+			TH1 += SIR_STEP_SIZE;
+		else
+			TH1 = TH2;
+		}
+		else
+		{
+			if(TH1==(RSSI_BT+0x1E))
+             		     break;    
+   			if((TH1+2) < (RSSI_BT+0x1E))
+				TH1+=3;
+		     	else
+				TH1 = RSSI_BT+0x1E;	
+             
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD: decision threshold is: %d", TH1));
+			 
+		for (i = 0; i< 80; i++)
+		{
+			if((s4Byte)(PSD_report[i]) < TH1)
+			{
+				byte_idx = i / 8;
+				bit_idx = i -8*byte_idx;
+				bitmap = PSD_bitmap[byte_idx];
+				PSD_bitmap[byte_idx] = bitmap | (u1Byte) (1 << bit_idx);
+			}
+		}
+
+#if DBG
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: before smoothing\n"));
+		for(n=0;n<10;n++)
+		{
+			//DbgPrint("PSD_bitmap[%u]=%x\n", n, PSD_bitmap[n]);
+			for (i = 0; i<8; i++)
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD_bitmap[%u] =   %d\n", 2402+n*8+i, (PSD_bitmap[n]&BIT(i))>>i));
+		}
+#endif
+	
+		//1 Start of smoothing function
+
+		for (j=0;j<3;j++)
+		{
+			start_byte_idx=0;
+			start_bit_idx=0;
+			for(n=0; n<Smooth_Interval[j]; n++)
+			{
+				good_cnt_smoothing = 0;
+				cur_bit_idx = start_bit_idx;
+				cur_byte_idx = start_byte_idx;
+				for ( i=0; i < Smooth_size[j]; i++)
+				{
+					NOW_byte_idx = cur_byte_idx + (i+cur_bit_idx)/8;
+					if ( (PSD_bitmap[NOW_byte_idx]& BIT( (cur_bit_idx + i)%8)) != 0)
+						good_cnt_smoothing++;
+
+				}
+
+				if( good_cnt_smoothing < Smooth_TH[j] )
+				{
+					cur_bit_idx = start_bit_idx;
+					cur_byte_idx = start_byte_idx;
+					for ( i=0; i< Smooth_size[j] ; i++)
+					{	
+						NOW_byte_idx = cur_byte_idx + (i+cur_bit_idx)/8;				
+						PSD_bitmap[NOW_byte_idx] = PSD_bitmap[NOW_byte_idx] & (~BIT( (cur_bit_idx + i)%8));
+					}
+				}
+				start_bit_idx =  start_bit_idx + Smooth_Step_Size;
+				while ( (start_bit_idx)  > 7 )
+				{
+					start_byte_idx= start_byte_idx+start_bit_idx/8;
+					start_bit_idx = start_bit_idx%8;
+				}
+			}
+
+			ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: after %u smoothing", j+1));
+			for(n=0;n<10;n++)
+			{
+				for (i = 0; i<8; i++)
+				{
+					ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD_bitmap[%u] =   %d\n", 2402+n*8+i, (PSD_bitmap[n]&BIT(i))>>i));
+					
+					if ( ((PSD_bitmap[n]&BIT(i))>>i) ==1)  //----- Add By Gary
+					{
+	                                   pRX_HP_Table->PSD_bitmap_RXHP[8*n+i] = 1;
+					}                                                  // ------end by Gary
+				}
+			}
+
+		}
+
+	
+		good_cnt = 0;
+		for ( i = 0; i < 10; i++)
+		{
+			for (n = 0; n < 8; n++)
+				if((PSD_bitmap[i]& BIT(n)) != 0)
+					good_cnt++;
+		}
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, ODM_COMP_PSD,("PSD: good channel cnt = %u",good_cnt));
+	}
+
+	//RT_TRACE(ODM_COMP_PSD, DBG_LOUD,("PSD: SSBT=%d, TH2=%d, TH1=%d",SSBT,TH2,TH1));
+	for (i = 0; i <10; i++)
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: PSD_bitmap[%u]=%x",i,PSD_bitmap[i]));
+/*	
+	//Update bitmap memory
+	for(i = 0; i < 80; i++)
+	{
+		byte_idx = i / 8;
+		bit_idx = i -8*byte_idx;
+		psd_bit = (PSD_bitmap[byte_idx] & BIT(bit_idx)) >> bit_idx;
+		bitmap = PSD_bitmap_memory[i]; 
+		PSD_bitmap_memory[i] = (bitmap << 1) |psd_bit;
+	}
+*/
+}
+
+
+
+VOID
+odm_PSD_Monitor(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	//PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	unsigned int 		pts, start_point, stop_point;
+	u1Byte			initial_gain ;
+	static u1Byte		PSD_bitmap_memory[80], init_memory = 0;
+	static u1Byte 		psd_cnt=0;
+	static u4Byte		PSD_report[80], PSD_report_tmp;
+	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
+	u1Byte 			H2C_PSD_DATA[5]={0,0,0,0,0};
+	static u1Byte		H2C_PSD_DATA_last[5] ={0,0,0,0,0};
+	u1Byte			idx[20]={96,99,102,106,109,112,115,118,122,125,
+					0,3,6,10,13,16,19,22,26,29};
+	u1Byte			n, i, channel, BBReset,tone_idx;
+	u1Byte			PSD_bitmap[10], SSBT=0,initial_gain_psd=0, RSSI_BT=0, initialGainUpper;
+	s4Byte    			PSD_skip_start, PSD_skip_stop;
+	u4Byte			CurrentChannel, RXIQI, RxIdleLowPwr, wlan_channel;
+	u4Byte			ReScan, Interval, Is40MHz;
+	u8Byte			curTxOkCnt, curRxOkCnt;
+	int 				cur_byte_idx, cur_bit_idx;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	PMGNT_INFO      	pMgntInfo = &Adapter->MgntInfo;
+	
+
+	if(*pDM_Odm->pbDriverIsGoingToPnpSetPowerSleep)
+ 	{
+  		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("pbDriverIsGoingToPnpSetPowerSleep!!!!!!!!!!!!!!!\n"));
+  		return;
+ 	}
+
+	
+	if( (*(pDM_Odm->pbScanInProcess)) ||
+		pDM_Odm->bLinkInProcess)
+	{
+		if((pDM_Odm->SupportICType==ODM_RTL8723A)&(pDM_Odm->SupportInterface==ODM_ITRF_PCIE))
+		{
+			ODM_SetTimer( pDM_Odm, &pDM_Odm->PSDTimer, 1500); //ms	
+			//psd_cnt=0;
+		}
+		return;
+	}
+
+	if(pDM_Odm->bBtHsOperation)
+	{
+		ReScan = 1;
+		Interval = SCAN_INTERVAL;
+	}
+	else
+	{
+	ReScan = PSD_RESCAN;
+	Interval = SCAN_INTERVAL;
+	}
+
+	//1 Initialization
+	if(init_memory == 0)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Init memory\n"));
+		for(i = 0; i < 80; i++)
+			PSD_bitmap_memory[i] = 0xFF; // channel is always good
+		init_memory = 1;
+	}
+	if(psd_cnt == 0)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Enter dm_PSD_Monitor\n"));
+		for(i = 0; i < 80; i++)
+			PSD_report[i] = 0;
+	}
+
+	//1 Backup Current Settings
+	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask);
+/*
+	if(pDM_Odm->SupportICType==ODM_RTL8192D)
+	{
+		//2 Record Current synthesizer parameters based on current channel
+		if((*pDM_Odm->MacPhyMode92D == SINGLEMAC_SINGLEPHY)||(*pDM_Odm->MacPhyMode92D == DUALMAC_SINGLEPHY))
+		{
+			SYN_RF25 = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x25, bMaskDWord);
+			SYN_RF26 = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x26, bMaskDWord);
+			SYN_RF27 = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x27, bMaskDWord);
+			SYN_RF2B = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x2B, bMaskDWord);
+			SYN_RF2C = ODM_GetRFReg(Adapter, ODM_RF_PATH_B, 0x2C, bMaskDWord);
+       	}
+		else     // DualMAC_DualPHY 2G
+		{
+			SYN_RF25 = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x25, bMaskDWord);
+			SYN_RF26 = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x26, bMaskDWord);
+			SYN_RF27 = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x27, bMaskDWord);
+			SYN_RF2B = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x2B, bMaskDWord);
+			SYN_RF2C = ODM_GetRFReg(Adapter, ODM_RF_PATH_A, 0x2C, bMaskDWord);
+		}
+	}
+*/
+	//RXIQI = PHY_QueryBBReg(Adapter, 0xC14, bMaskDWord);
+	RXIQI = ODM_GetBBReg(pDM_Odm, 0xC14, bMaskDWord);
+
+	//RxIdleLowPwr = (PHY_QueryBBReg(Adapter, 0x818, bMaskDWord)&BIT28)>>28;
+	RxIdleLowPwr = (ODM_GetBBReg(pDM_Odm, 0x818, bMaskDWord)&BIT28)>>28;
+
+	//2???
+	if(CHNL_RUN_ABOVE_40MHZ(pMgntInfo))
+		Is40MHz = TRUE;
+	else
+		Is40MHz = FALSE;
+
+	ODM_RT_TRACE(pDM_Odm,	ODM_COMP_PSD, DBG_LOUD,("PSD Scan Start\n"));
+	//1 Turn off CCK
+	//PHY_SetBBReg(Adapter, rFPGA0_RFMOD, BIT24, 0);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0);
+	//1 Turn off TX
+	//Pause TX Queue
+	//PlatformEFIOWrite1Byte(Adapter, REG_TXPAUSE, 0xFF);
+	ODM_Write1Byte(pDM_Odm,REG_TXPAUSE, 0xFF);
+	
+	//Force RX to stop TX immediately
+	//PHY_SetRFReg(Adapter, ODM_RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x32E13);
+
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x32E13);
+	//1 Turn off RX
+	//Rx AGC off  RegC70[0]=0, RegC7C[20]=0
+	//PHY_SetBBReg(Adapter, 0xC70, BIT0, 0);
+	//PHY_SetBBReg(Adapter, 0xC7C, BIT20, 0);
+
+	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 0);
+	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 0);
+
+	
+	//Turn off CCA
+	//PHY_SetBBReg(Adapter, 0xC14, bMaskDWord, 0x0);
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, 0x0);
+	
+	//BB Reset
+	//BBReset = PlatformEFIORead1Byte(Adapter, 0x02);
+	BBReset = ODM_Read1Byte(pDM_Odm, 0x02);
+	
+	//PlatformEFIOWrite1Byte(Adapter, 0x02, BBReset&(~BIT0));
+	//PlatformEFIOWrite1Byte(Adapter, 0x02, BBReset|BIT0);
+	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 1); //clock gated to prevent from AGC table mess 
+	ODM_Write1Byte(pDM_Odm,  0x02, BBReset&(~BIT0));
+	ODM_Write1Byte(pDM_Odm,  0x02, BBReset|BIT0);
+	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 0);
+	
+	//1 Leave RX idle low power
+	//PHY_SetBBReg(Adapter, 0x818, BIT28, 0x0);
+
+	ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0);
+	//1 Fix initial gain
+	//if (IS_HARDWARE_TYPE_8723AE(Adapter))
+	//RSSI_BT = pHalData->RSSI_BT;
+       //else if((IS_HARDWARE_TYPE_8192C(Adapter))||(IS_HARDWARE_TYPE_8192D(Adapter)))      // Add by Gary
+       //    RSSI_BT = RSSI_BT_new;
+
+	if((pDM_Odm->SupportICType==ODM_RTL8723A)&(pDM_Odm->SupportInterface==ODM_ITRF_PCIE))
+	RSSI_BT=pDM_Odm->RSSI_BT;		//need to check C2H to pDM_Odm RSSI BT
+
+	if(RSSI_BT>=47)
+		RSSI_BT=47;
+	   
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
+	
+	if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	{
+	       //Neil add--2011--10--12
+		//2 Initial Gain index 
+		if(RSSI_BT >=35)   // >= -15dBm
+			initial_gain_psd = RSSI_BT*2;
+		else if((RSSI_BT >=33)&(RSSI_BT<35))
+			initial_gain_psd = RSSI_BT*2+6;
+		else if((RSSI_BT >=24)&(RSSI_BT<33))
+			initial_gain_psd = 70-(33-RSSI_BT);
+	 	else if((RSSI_BT >=19)&(RSSI_BT<24))
+			initial_gain_psd = 64-((24-RSSI_BT)*4);
+		else if((RSSI_BT >=14)&(RSSI_BT<19))
+			initial_gain_psd = 44-((18-RSSI_BT)*2);
+		else if((RSSI_BT >=8)&(RSSI_BT<14))
+			initial_gain_psd = 35-(14-RSSI_BT);
+		else
+			initial_gain_psd = 0x1B;
+	}
+	else
+	{
+	
+		//need to do	
+         	initial_gain_psd = pDM_Odm->RSSI_Min;    // PSD report based on RSSI
+           	//}  	
+	}
+	//if(RSSI_BT<0x17)
+	//	RSSI_BT +=3;
+	//DbgPrint("PSD: RSSI_BT= %d\n", RSSI_BT);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
+
+	//initialGainUpper = 0x5E;  //Modify by neil chen
+	
+	if(pDM_Odm->bUserAssignLevel)
+	{
+		pDM_Odm->bUserAssignLevel = FALSE;
+		initialGainUpper = 0x7f;
+	}
+	else
+	{
+		initialGainUpper = 0x5E;
+	}
+	
+	/*
+	if (initial_gain_psd < 0x1a)
+		initial_gain_psd = 0x1a;
+	if (initial_gain_psd > initialGainUpper)
+		initial_gain_psd = initialGainUpper;
+	*/
+
+	//if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	SSBT = RSSI_BT  * 2 +0x3E;
+	
+	
+	//if(IS_HARDWARE_TYPE_8723AE(Adapter))
+	//	SSBT = RSSI_BT  * 2 +0x3E;
+	//else if((IS_HARDWARE_TYPE_8192C(Adapter))||(IS_HARDWARE_TYPE_8192D(Adapter)))   // Add by Gary
+	//{
+	//	RSSI_BT = initial_gain_psd;
+	//	SSBT = RSSI_BT;
+	//}
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: SSBT= %d\n", SSBT));
+	ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD: initial gain= 0x%x\n", initial_gain_psd));
+	//DbgPrint("PSD: SSBT= %d", SSBT);
+	//need to do
+	pDM_Odm->bDMInitialGainEnable = FALSE;
+	initial_gain =(u1Byte) (ODM_GetBBReg(pDM_Odm, 0xc50, bMaskDWord) & 0x7F);
+	
+        // make sure the initial gain is under the correct range.
+	//initial_gain_psd &= 0x7f;
+	ODM_Write_DIG(pDM_Odm, initial_gain_psd);
+	//1 Turn off 3-wire
+	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0xF);
+
+	//pts value = 128, 256, 512, 1024
+	pts = 128;
+
+	if(pts == 128)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
+		start_point = 64;
+		stop_point = 192;
+	}
+	else if(pts == 256)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x1);
+		start_point = 128;
+		stop_point = 384;
+	}
+	else if(pts == 512)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x2);
+		start_point = 256;
+		stop_point = 768;
+	}
+	else
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x3);
+		start_point = 512;
+		stop_point = 1536;
+	}
+	
+
+//3 Skip WLAN channels if WLAN busy
+
+	curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast) - lastTxOkCnt;
+	curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast) - lastRxOkCnt;
+	lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
+	lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);	
+
+	PSD_skip_start=80;
+	PSD_skip_stop = 0;
+	wlan_channel = CurrentChannel & 0x0f;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD: current channel: %x, BW:%d \n", wlan_channel, Is40MHz));
+	if(pDM_Odm->SupportICType==ODM_RTL8723A)
+	{
+		if(pDM_Odm->bBtHsOperation)
+		{
+			if(pDM_Odm->bLinked)
+			{
+				if(Is40MHz)
+				{
+					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-2;  // Modify by Neil to add 10 chs to mask
+					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+4;
+				}
+				else
+				{
+					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-10;  // Modify by Neil to add 10 chs to mask
+					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+18; 
+				}
+			}
+			else
+			{
+				// mask for 40MHz
+				PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-2;  // Modify by Neil to add 10 chs to mask
+				PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+4;
+			}
+			if(PSD_skip_start < 0)
+				PSD_skip_start = 0;
+			if(PSD_skip_stop >80)
+				PSD_skip_stop = 80;
+		}
+		else
+		{
+			if((curRxOkCnt+curTxOkCnt) > 5)
+			{
+				if(Is40MHz)
+				{
+					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-2;  // Modify by Neil to add 10 chs to mask
+					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+4;
+				}
+				else
+				{
+					PSD_skip_start = ((wlan_channel-1)*5 -Is40MHz*10)-10;  // Modify by Neil to add 10 chs to mask
+					PSD_skip_stop = (PSD_skip_start + (1+Is40MHz)*20)+18; 
+				}
+				
+				if(PSD_skip_start < 0)
+					PSD_skip_start = 0;
+				if(PSD_skip_stop >80)
+					PSD_skip_stop = 80;
+			}
+		}
+	}
+#if 0	
+	else
+	{
+		if((curRxOkCnt+curTxOkCnt) > 1000)
+		{
+			PSD_skip_start = (wlan_channel-1)*5 -Is40MHz*10;
+			PSD_skip_stop = PSD_skip_start + (1+Is40MHz)*20;
+		}
+	}   
+#endif  //Reove RXHP Issue
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD: Skip tone from %d to %d \n", PSD_skip_start, PSD_skip_stop));
+
+ 	for (n=0;n<80;n++)
+ 	{
+ 		if((n%20)==0)
+ 		{
+			channel = (n/20)*4 + 1;
+					
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
+				}
+		tone_idx = n%20;
+		if ((n>=PSD_skip_start) && (n<PSD_skip_stop))
+		{	
+			PSD_report[n] = SSBT;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD:Tone %d skipped \n", n));
+		}
+		else
+		{
+			PSD_report_tmp =  GetPSDData(pDM_Odm, idx[tone_idx], initial_gain_psd);
+
+			if ( PSD_report_tmp > PSD_report[n])
+				PSD_report[n] = PSD_report_tmp;
+				
+		}
+	}
+
+	PatchDCTone(pDM_Odm, PSD_report, initial_gain_psd);
+      
+       //----end
+	//1 Turn on RX
+	//Rx AGC on
+	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 1);
+	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 1);
+	//CCK on
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 1);
+	//1 Turn on TX
+	//Resume TX Queue
+	
+	ODM_Write1Byte(pDM_Odm,REG_TXPAUSE, 0x00);
+	//Turn on 3-wire
+	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0x0);
+	//1 Restore Current Settings
+	//Resume DIG
+	pDM_Odm->bDMInitialGainEnable = TRUE;
+	
+	ODM_Write_DIG(pDM_Odm, initial_gain);
+
+	// restore originl center frequency
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, CurrentChannel);
+
+	//Turn on CCA
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, RXIQI);
+	//Restore RX idle low power
+	if(RxIdleLowPwr == TRUE)
+		ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 1);
+	
+	psd_cnt++;
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD:psd_cnt = %d \n",psd_cnt));
+	if (psd_cnt < ReScan)
+		ODM_SetTimer(pDM_Odm, &pDM_Odm->PSDTimer, Interval);		
+	else
+	{
+		psd_cnt = 0;
+		for(i=0;i<80;i++)
+			//DbgPrint("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]);
+			RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]));
+
+
+		GoodChannelDecision(pDM_Odm, PSD_report, PSD_bitmap,RSSI_BT, PSD_bitmap_memory);
+
+		if(pDM_Odm->SupportICType==ODM_RTL8723A)
+		{
+			cur_byte_idx=0;
+			cur_bit_idx=0;
+
+			//2 Restore H2C PSD Data to Last Data
+		  	H2C_PSD_DATA_last[0] = H2C_PSD_DATA[0];
+			H2C_PSD_DATA_last[1] = H2C_PSD_DATA[1];
+			H2C_PSD_DATA_last[2] = H2C_PSD_DATA[2];
+			H2C_PSD_DATA_last[3] = H2C_PSD_DATA[3];
+			H2C_PSD_DATA_last[4] = H2C_PSD_DATA[4];
+
+	
+			//2 Translate 80bit channel map to 40bit channel	
+			for ( i=0;i<5;i++)
+			{
+				for(n=0;n<8;n++)
+				{
+					cur_byte_idx = i*2 + n/4;
+					cur_bit_idx = (n%4)*2;
+					if ( ((PSD_bitmap[cur_byte_idx]& BIT(cur_bit_idx)) != 0) && ((PSD_bitmap[cur_byte_idx]& BIT(cur_bit_idx+1)) != 0))
+						H2C_PSD_DATA[i] = H2C_PSD_DATA[i] | (u1Byte) (1 << n);
+				}
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("H2C_PSD_DATA[%d]=0x%x\n" ,i, H2C_PSD_DATA[i]));
+			}
+	
+			//3 To Compare the difference
+			for ( i=0;i<5;i++)
+			{
+				if(H2C_PSD_DATA[i] !=H2C_PSD_DATA_last[i])
+				{
+					FW_FillH2CCmd(Adapter, H2C_92C_PSD_RESULT, 5, H2C_PSD_DATA);
+					ODM_RT_TRACE(pDM_Odm, ODM_COMP_PSD, DBG_LOUD,("Need to Update the AFH Map \n"));
+					break;
+				}
+				else
+				{
+					if(i==5)
+						ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Not need to Update\n"));	
+				}
+			}
+			if(pDM_Odm->bBtHsOperation)
+			{
+				ODM_SetTimer(pDM_Odm, &pDM_Odm->PSDTimer, 10000);
+				ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Leave dm_PSD_Monitor\n"));		
+			}
+			else
+			{
+				ODM_SetTimer(pDM_Odm, &pDM_Odm->PSDTimer, 1500);
+				ODM_RT_TRACE(	pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("Leave dm_PSD_Monitor\n"));		
+		}
+	}
+    }
+}
+/*
+//Neil for Get BT RSSI
+// Be Triggered by BT C2H CMD
+VOID
+ODM_PSDGetRSSI(
+	IN	u1Byte	RSSI_BT)
+{
+
+
+}
+
+*/
+
+VOID
+ODM_PSDMonitor(
+	IN		PVOID			pDM_VOID
+	)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+	//if(IS_HARDWARE_TYPE_8723AE(Adapter))
+	
+	if(pDM_Odm->SupportICType == ODM_RTL8723A)   //may need to add other IC type
+	{
+		if(pDM_Odm->SupportInterface==ODM_ITRF_PCIE)
+		{
+			if(!pDM_Odm->bBtEnabled) //need to check upper layer connection
+			{
+				pDM_Odm->bPSDactive=FALSE;
+				ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD, ("odm_PSDMonitor, return for BT is disabled!!!\n"));
+		   		return; 
+			}
+
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD, ("odm_PSDMonitor\n"));
+		//{
+			pDM_Odm->bPSDinProcess = TRUE;
+	 		pDM_Odm->bPSDactive=TRUE;
+			odm_PSD_Monitor(pDM_Odm);
+			pDM_Odm->bPSDinProcess = FALSE;
+		}	
+	}	
+
+}
+VOID
+odm_PSDMonitorCallback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+       HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+
+	PlatformScheduleWorkItem(&pHalData->PSDMonitorWorkitem);
+}
+
+VOID
+odm_PSDMonitorWorkItemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	Adapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	ODM_PSDMonitor(pDM_Odm);
+}
+
+
+ //cosa debug tool need to modify
+
+VOID
+ODM_PSDDbgControl(
+	IN	PADAPTER	Adapter,
+	IN	u4Byte		mode,
+	IN	u4Byte		btRssi
+	)
+{
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD, (" Monitor mode=%d, btRssi=%d\n", mode, btRssi));
+	if(mode)
+	{
+		pDM_Odm->RSSI_BT = (u1Byte)btRssi;
+		pDM_Odm->bUserAssignLevel = TRUE;
+		ODM_SetTimer( pDM_Odm, &pDM_Odm->PSDTimer, 0); //ms		
+	}
+	else
+	{
+		ODM_CancelTimer(pDM_Odm, &pDM_Odm->PSDTimer);
+	}
+#endif
+}
+
+
+//#if(DEV_BUS_TYPE == RT_PCI_INTERFACE)|(DEV_BUS_TYPE == RT_USB_INTERFACE)
+
+void	odm_RXHPInit(
+	IN		PVOID			pDM_VOID)
+{
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE)|(DEV_BUS_TYPE == RT_USB_INTERFACE)
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+   	u1Byte			index;
+
+	pRX_HP_Table->RXHP_enable = TRUE;
+	pRX_HP_Table->RXHP_flag = 0;
+	pRX_HP_Table->PSD_func_trigger = 0;
+	pRX_HP_Table->Pre_IGI = 0x20;
+	pRX_HP_Table->Cur_IGI = 0x20;
+	pRX_HP_Table->Cur_pw_th = pw_th_10dB;
+	pRX_HP_Table->Pre_pw_th = pw_th_10dB;
+	for(index=0; index<80; index++)
+		pRX_HP_Table->PSD_bitmap_RXHP[index] = 1;
+
+#if(DEV_BUS_TYPE == RT_USB_INTERFACE)
+	pRX_HP_Table->TP_Mode = Idle_Mode;
+#endif
+#endif
+}
+
+VOID
+odm_PSD_RXHP(
+	IN		PVOID			pDM_VOID
+)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+	PADAPTER		Adapter =  pDM_Odm->Adapter;
+	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	unsigned int 		pts, start_point, stop_point, initial_gain ;
+	static u1Byte		PSD_bitmap_memory[80], init_memory = 0;
+	static u1Byte 		psd_cnt=0;
+	static u4Byte		PSD_report[80], PSD_report_tmp;
+	static u8Byte		lastTxOkCnt=0, lastRxOkCnt=0;
+	u1Byte			idx[20]={96,99,102,106,109,112,115,118,122,125,
+					0,3,6,10,13,16,19,22,26,29};
+	u1Byte			n, i, channel, BBReset,tone_idx;
+	u1Byte			PSD_bitmap[10]/*, SSBT=0*/,initial_gain_psd=0, RSSI_BT=0, initialGainUpper;
+	s4Byte    			PSD_skip_start, PSD_skip_stop;
+	u4Byte			CurrentChannel, RXIQI, RxIdleLowPwr, wlan_channel;
+	u4Byte			ReScan, Interval, Is40MHz;
+	u8Byte			curTxOkCnt, curRxOkCnt;
+	//--------------2G band synthesizer for 92D switch RF channel using----------------- 
+	u1Byte			group_idx=0;
+	u4Byte			SYN_RF25=0, SYN_RF26=0, SYN_RF27=0, SYN_RF2B=0, SYN_RF2C=0;
+	u4Byte			SYN[5] = {0x25, 0x26, 0x27, 0x2B, 0x2C};    // synthesizer RF register for 2G channel
+	u4Byte			SYN_group[3][5] = {{0x643BC, 0xFC038, 0x77C1A, 0x41289, 0x01840},     // For CH1,2,4,9,10.11.12   {0x643BC, 0xFC038, 0x77C1A, 0x41289, 0x01840}
+									    {0x643BC, 0xFC038, 0x07C1A, 0x41289, 0x01840},     // For CH3,13,14
+									    {0x243BC, 0xFC438, 0x07C1A, 0x4128B, 0x0FC41}};   // For Ch5,6,7,8
+       //--------------------- Add by Gary for Debug setting ----------------------
+  	u1Byte                 RSSI_BT_new = (u1Byte) ODM_GetBBReg(pDM_Odm, 0xB9C, 0xFF);
+       u1Byte                 rssi_ctrl = (u1Byte) ODM_GetBBReg(pDM_Odm, 0xB38, 0xFF);
+       //---------------------------------------------------------------------
+	
+	if(pMgntInfo->bScanInProgress)
+	{
+		return;
+	}
+
+	ReScan = PSD_RESCAN;
+	Interval = SCAN_INTERVAL;
+
+
+	//1 Initialization
+	if(init_memory == 0)
+	{
+		RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("Init memory\n"));
+		for(i = 0; i < 80; i++)
+			PSD_bitmap_memory[i] = 0xFF; // channel is always good
+		init_memory = 1;
+	}
+	if(psd_cnt == 0)
+	{
+		RT_TRACE(ODM_COMP_PSD, DBG_LOUD,("Enter dm_PSD_Monitor\n"));
+		for(i = 0; i < 80; i++)
+			PSD_report[i] = 0;
+	}
+
+	//1 Backup Current Settings
+	CurrentChannel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask);
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		//2 Record Current synthesizer parameters based on current channel
+		if((*(pDM_Odm->pMacPhyMode)==ODM_SMSP)||(*(pDM_Odm->pMacPhyMode)==ODM_DMSP))
+		{
+			SYN_RF25 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x25, bMaskDWord);
+			SYN_RF26 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x26, bMaskDWord);
+			SYN_RF27 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, bMaskDWord);
+			SYN_RF2B = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2B, bMaskDWord);
+			SYN_RF2C = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2C, bMaskDWord);
+       	}
+		else     // DualMAC_DualPHY 2G
+		{
+			SYN_RF25 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x25, bMaskDWord);
+			SYN_RF26 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x26, bMaskDWord);
+			SYN_RF27 = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, bMaskDWord);
+			SYN_RF2B = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2B, bMaskDWord);
+			SYN_RF2C = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2C, bMaskDWord);
+		}
+	}
+	RXIQI = ODM_GetBBReg(pDM_Odm, 0xC14, bMaskDWord);
+	RxIdleLowPwr = (ODM_GetBBReg(pDM_Odm, 0x818, bMaskDWord)&BIT28)>>28;
+	Is40MHz = *(pDM_Odm->pBandWidth);
+	ODM_RT_TRACE(pDM_Odm,	ODM_COMP_PSD, DBG_LOUD,("PSD Scan Start\n"));
+	//1 Turn off CCK
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 0);
+	//1 Turn off TX
+	//Pause TX Queue
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0xFF);
+	//Force RX to stop TX immediately
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x32E13);
+	//1 Turn off RX
+	//Rx AGC off  RegC70[0]=0, RegC7C[20]=0
+	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 0);
+	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 0);
+	//Turn off CCA
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, 0x0);
+	//BB Reset
+	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 1); //clock gated to prevent from AGC table mess 
+	BBReset = ODM_Read1Byte(pDM_Odm, 0x02);
+	ODM_Write1Byte(pDM_Odm, 0x02, BBReset&(~BIT0));
+	ODM_Write1Byte(pDM_Odm, 0x02, BBReset|BIT0);
+	ODM_SetBBReg(pDM_Odm, 0x87C, BIT31, 0);
+	//1 Leave RX idle low power
+	ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0);
+	//1 Fix initial gain
+      	RSSI_BT = RSSI_BT_new;
+	RT_TRACE(ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
+	
+	if(rssi_ctrl == 1)        // just for debug!!
+		initial_gain_psd = RSSI_BT_new; 
+     	else
+		initial_gain_psd = pDM_Odm->RSSI_Min;    // PSD report based on RSSI
+	
+	RT_TRACE(ODM_COMP_PSD, DBG_LOUD,("PSD: RSSI_BT= %d\n", RSSI_BT));
+	
+	initialGainUpper = 0x54;
+	
+	RSSI_BT = initial_gain_psd;
+	//SSBT = RSSI_BT;
+	
+	//RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("PSD: SSBT= %d\n", SSBT));
+	RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("PSD: initial gain= 0x%x\n", initial_gain_psd));
+	
+	pDM_Odm->bDMInitialGainEnable = FALSE;		
+	initial_gain = ODM_GetBBReg(pDM_Odm, 0xc50, bMaskDWord) & 0x7F;
+	//ODM_SetBBReg(pDM_Odm, 0xc50, 0x7F, initial_gain_psd);	
+	ODM_Write_DIG(pDM_Odm, initial_gain_psd);
+	//1 Turn off 3-wire
+	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0xF);
+
+	//pts value = 128, 256, 512, 1024
+	pts = 128;
+
+	if(pts == 128)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);
+		start_point = 64;
+		stop_point = 192;
+	}
+	else if(pts == 256)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x1);
+		start_point = 128;
+		stop_point = 384;
+	}
+	else if(pts == 512)
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x2);
+		start_point = 256;
+		stop_point = 768;
+	}
+	else
+	{
+		ODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x3);
+		start_point = 512;
+		stop_point = 1536;
+	}
+	
+
+//3 Skip WLAN channels if WLAN busy
+	curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast) - lastTxOkCnt;
+	curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast) - lastRxOkCnt;
+	lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
+	lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);
+	
+	PSD_skip_start=80;
+	PSD_skip_stop = 0;
+	wlan_channel = CurrentChannel & 0x0f;
+
+	RT_TRACE(ODM_COMP_PSD,DBG_LOUD,("PSD: current channel: %x, BW:%d \n", wlan_channel, Is40MHz));
+	
+	if((curRxOkCnt+curTxOkCnt) > 1000)
+	{
+		PSD_skip_start = (wlan_channel-1)*5 -Is40MHz*10;
+		PSD_skip_stop = PSD_skip_start + (1+Is40MHz)*20;
+	}
+
+	RT_TRACE(ODM_COMP_PSD,DBG_LOUD,("PSD: Skip tone from %d to %d \n", PSD_skip_start, PSD_skip_stop));
+
+ 	for (n=0;n<80;n++)
+ 	{
+ 		if((n%20)==0)
+ 		{
+			channel = (n/20)*4 + 1;
+			if(pDM_Odm->SupportICType == ODM_RTL8192D)
+			{
+				switch(channel)
+				{
+					case 1: 
+					case 9:
+						group_idx = 0;
+						break;
+					case 5:
+						group_idx = 2;
+						break;
+					case 13:
+				 		group_idx = 1;
+						break;
+				}
+				if((*(pDM_Odm->pMacPhyMode)==ODM_SMSP)||(*(pDM_Odm->pMacPhyMode)==ODM_DMSP))   
+		{
+					for(i = 0; i < SYN_Length; i++)
+						ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, SYN[i], bMaskDWord, SYN_group[group_idx][i]);
+
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, 0x3FF, channel);
+				}
+				else  // DualMAC_DualPHY 2G
+			{
+					for(i = 0; i < SYN_Length; i++)
+						ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, SYN[i], bMaskDWord, SYN_group[group_idx][i]);   
+					
+					ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
+				}
+			}
+			else
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x3FF, channel);
+			}	
+		tone_idx = n%20;
+		if ((n>=PSD_skip_start) && (n<PSD_skip_stop))
+		{	
+			PSD_report[n] = initial_gain_psd;//SSBT;
+			ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD,DBG_LOUD,("PSD:Tone %d skipped \n", n));
+		}
+		else
+		{
+			PSD_report_tmp =  GetPSDData(pDM_Odm, idx[tone_idx], initial_gain_psd);
+
+			if ( PSD_report_tmp > PSD_report[n])
+				PSD_report[n] = PSD_report_tmp;
+				
+		}
+	}
+
+	PatchDCTone(pDM_Odm, PSD_report, initial_gain_psd);
+      
+       //----end
+	//1 Turn on RX
+	//Rx AGC on
+	ODM_SetBBReg(pDM_Odm, 0xC70, BIT0, 1);
+	ODM_SetBBReg(pDM_Odm, 0xC7C, BIT20, 1);
+	//CCK on
+	ODM_SetBBReg(pDM_Odm, rFPGA0_RFMOD, BIT24, 1);
+	//1 Turn on TX
+	//Resume TX Queue
+	ODM_Write1Byte(pDM_Odm, REG_TXPAUSE, 0x00);
+	//Turn on 3-wire
+	ODM_SetBBReg(pDM_Odm, 0x88c, BIT20|BIT21|BIT22|BIT23, 0x0);
+	//1 Restore Current Settings
+	//Resume DIG
+	pDM_Odm->bDMInitialGainEnable= TRUE;
+	//ODM_SetBBReg(pDM_Odm, 0xc50, 0x7F, initial_gain);
+	ODM_Write_DIG(pDM_Odm,(u1Byte) initial_gain);
+	// restore originl center frequency
+	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, CurrentChannel);
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		if((*(pDM_Odm->pMacPhyMode)==ODM_SMSP)||(*(pDM_Odm->pMacPhyMode)==ODM_DMSP))
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, RF_CHNLBW, bMaskDWord, CurrentChannel);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x25, bMaskDWord, SYN_RF25);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x26, bMaskDWord, SYN_RF26);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x27, bMaskDWord, SYN_RF27);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2B, bMaskDWord, SYN_RF2B);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_B, 0x2C, bMaskDWord, SYN_RF2C);
+		}
+		else     // DualMAC_DualPHY
+		{
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x25, bMaskDWord, SYN_RF25);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x26, bMaskDWord, SYN_RF26);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x27, bMaskDWord, SYN_RF27);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2B, bMaskDWord, SYN_RF2B);
+			ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, 0x2C, bMaskDWord, SYN_RF2C);
+		}
+	}
+	//Turn on CCA
+	ODM_SetBBReg(pDM_Odm, 0xC14, bMaskDWord, RXIQI);
+	//Restore RX idle low power
+	if(RxIdleLowPwr == TRUE)
+		ODM_SetBBReg(pDM_Odm, 0x818, BIT28, 1);
+	
+	psd_cnt++;
+	//gPrint("psd cnt=%d\n", psd_cnt);
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_PSD, DBG_LOUD,("PSD:psd_cnt = %d \n",psd_cnt));
+	if (psd_cnt < ReScan)
+	{
+		ODM_SetTimer(pDM_Odm, &pRX_HP_Table->PSDTimer, Interval);  //ms
+	}
+	else
+	{	
+		psd_cnt = 0;
+		for(i=0;i<80;i++)
+			RT_TRACE(	ODM_COMP_PSD, DBG_LOUD,("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]));
+			//DbgPrint("psd_report[%d]=     %d \n", 2402+i, PSD_report[i]);
+
+		GoodChannelDecision(pDM_Odm, PSD_report, PSD_bitmap,RSSI_BT, PSD_bitmap_memory);
+
+	}
+}
+
+void odm_Write_RXHP(
+	IN		PVOID			pDM_VOID)
+{
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRXHP_T		pRX_HP_Table = &pDM_Odm->DM_RXHP_Table;
+	u4Byte		currentIGI;
+
+	if(pRX_HP_Table->Cur_IGI != pRX_HP_Table->Pre_IGI)
+	{
+		ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);
+	     	ODM_SetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);	
+	}
+	
+	if(pRX_HP_Table->Cur_pw_th != pRX_HP_Table->Pre_pw_th)
+{
+		ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore2, BIT8|BIT9, pRX_HP_Table->Cur_pw_th);  // RegC54[9:8]=2'b11:  AGC Flow 3
+	}
+
+	if(pRX_HP_Table->RXHP_flag == 0)
+	{
+		pRX_HP_Table->Cur_IGI = 0x20;
+	}
+	else
+	{
+		currentIGI = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0);
+		if(currentIGI<0x50)
+		{
+			ODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);
+	     		ODM_SetBBReg(pDM_Odm, rOFDM0_XBAGCCore1, bMaskByte0, pRX_HP_Table->Cur_IGI);	
+		}
+	}
+	pRX_HP_Table->Pre_IGI = pRX_HP_Table->Cur_IGI;
+	pRX_HP_Table->Pre_pw_th = pRX_HP_Table->Cur_pw_th;
+
+}
+
+
+void odm_RXHP(
+	IN		PVOID			pDM_VOID)
+{
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+#if (DEV_BUS_TYPE == RT_PCI_INTERFACE) | (DEV_BUS_TYPE == RT_USB_INTERFACE)
+	PDM_ODM_T				pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER	Adapter =  pDM_Odm->Adapter;
+	PMGNT_INFO	pMgntInfo = &(Adapter->MgntInfo);
+	pDIG_T		pDM_DigTable = &pDM_Odm->DM_DigTable;
+	pRXHP_T		pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+       PFALSE_ALARM_STATISTICS		FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm , PHYDM_FALSEALMCNT);
+	
+	u1Byte              	i, j, sum;
+	u1Byte			Is40MHz;
+	s1Byte              	Intf_diff_idx, MIN_Intf_diff_idx = 16;   
+       s4Byte              	cur_channel;    
+       u1Byte              	ch_map_intf_5M[17] = {0};     
+       static u4Byte		FA_TH = 0;	
+	static u1Byte      	psd_intf_flag = 0;
+	static s4Byte      	curRssi = 0;                
+       static s4Byte  		preRssi = 0;                                                                
+	static u1Byte		PSDTriggerCnt = 1;
+	
+	u1Byte			RX_HP_enable = (u1Byte)(ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore2, bMaskDWord)>>31);   // for debug!!
+
+#if(DEV_BUS_TYPE == RT_USB_INTERFACE)	
+	static s8Byte  		lastTxOkCnt = 0, lastRxOkCnt = 0;  
+       s8Byte			curTxOkCnt, curRxOkCnt;
+	s8Byte			curTPOkCnt;
+	s8Byte			TP_Acc3, TP_Acc5;
+	static s8Byte		TP_Buff[5] = {0};
+	static u1Byte		pre_state = 0, pre_state_flag = 0;
+	static u1Byte		Intf_HighTP_flag = 0, De_counter = 16; 
+	static u1Byte		TP_Degrade_flag = 0;
+#endif	   
+	static u1Byte		LatchCnt = 0;
+	
+	if(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8188E))
+		return;
+	//AGC RX High Power Mode is only applied on 2G band in 92D!!!
+	if(pDM_Odm->SupportICType == ODM_RTL8192D)
+	{
+		if(*(pDM_Odm->pBandType) != ODM_BAND_2_4G)
+			return;
+	}
+
+	if(!(pDM_Odm->SupportAbility & ODM_BB_RXHP))
+		return;
+
+
+	//RX HP ON/OFF
+	if(RX_HP_enable == 1)
+		pRX_HP_Table->RXHP_enable = FALSE;
+	else
+		pRX_HP_Table->RXHP_enable = TRUE;
+
+	if(pRX_HP_Table->RXHP_enable == FALSE)
+	{
+		if(pRX_HP_Table->RXHP_flag == 1)
+		{
+			pRX_HP_Table->RXHP_flag = 0;
+			psd_intf_flag = 0;
+		}
+		return;
+	}
+
+#if(DEV_BUS_TYPE == RT_USB_INTERFACE)	
+	//2 Record current TP for USB interface
+	curTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast)-lastTxOkCnt;
+	curRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast)-lastRxOkCnt;
+	lastTxOkCnt = *(pDM_Odm->pNumTxBytesUnicast);
+	lastRxOkCnt = *(pDM_Odm->pNumRxBytesUnicast);
+
+	curTPOkCnt = curTxOkCnt+curRxOkCnt;
+	TP_Buff[0] = curTPOkCnt;    // current TP  
+	TP_Acc3 = PlatformDivision64((TP_Buff[1]+TP_Buff[2]+TP_Buff[3]), 3);
+	TP_Acc5 = PlatformDivision64((TP_Buff[0]+TP_Buff[1]+TP_Buff[2]+TP_Buff[3]+TP_Buff[4]), 5);
+	
+	if(TP_Acc5 < 1000)
+		pRX_HP_Table->TP_Mode = Idle_Mode;
+	else if((1000 < TP_Acc5)&&(TP_Acc5 < 3750000))
+		pRX_HP_Table->TP_Mode = Low_TP_Mode;
+	else
+		pRX_HP_Table->TP_Mode = High_TP_Mode;
+
+	ODM_RT_TRACE(pDM_Odm, 	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP TP Mode = %d\n", pRX_HP_Table->TP_Mode));
+	// Since TP result would be sampled every 2 sec, it needs to delay 4sec to wait PSD processing.
+	// When LatchCnt = 0, we would Get PSD result.
+	if(TP_Degrade_flag == 1)
+	{
+		LatchCnt--;
+		if(LatchCnt == 0)
+		{
+			TP_Degrade_flag = 0;
+		}
+	}
+	// When PSD function triggered by TP degrade 20%, and Interference Flag = 1
+	// Set a De_counter to wait IGI = upper bound. If time is UP, the Interference flag will be pull down.
+	if(Intf_HighTP_flag == 1)
+	{
+		De_counter--;
+		if(De_counter == 0)
+		{
+			Intf_HighTP_flag = 0;
+			psd_intf_flag = 0;
+		}
+	}
+#endif
+
+	//2 AGC RX High Power Mode by PSD only applied to STA Mode
+	//3 NOT applied 1. Ad Hoc Mode.
+	//3 NOT applied 2. AP Mode
+	if ((pMgntInfo->mAssoc) && (!pMgntInfo->mIbss) && (!ACTING_AS_AP(Adapter)))
+	{    
+		Is40MHz = *(pDM_Odm->pBandWidth);
+		curRssi = pDM_Odm->RSSI_Min;
+		cur_channel = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_CHNLBW, 0x0fff) & 0x0f;
+		ODM_RT_TRACE(pDM_Odm, 	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP RX HP flag = %d\n", pRX_HP_Table->RXHP_flag));
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP FA = %d\n", FalseAlmCnt->Cnt_all));
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP cur RSSI = %d, pre RSSI=%d\n", curRssi, preRssi));
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP current CH = %d\n", cur_channel));
+		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RXHP Is 40MHz = %d\n", Is40MHz));
+       	//2 PSD function would be triggered 
+       	//3 1. Every 4 sec for PCIE
+       	//3 2. Before TP Mode (Idle TP<4kbps) for USB
+       	//3 3. After TP Mode (High TP) for USB 
+		if((curRssi > 68) && (pRX_HP_Table->RXHP_flag == 0))	// Only RSSI>TH and RX_HP_flag=0 will Do PSD process 
+		{
+#if (DEV_BUS_TYPE == RT_USB_INTERFACE)
+			//2 Before TP Mode ==> PSD would be trigger every 4 sec
+			if(pRX_HP_Table->TP_Mode == Idle_Mode)		//2.1 less wlan traffic <4kbps
+			{
+#endif
+				if(PSDTriggerCnt == 1)       
+				{    	
+					odm_PSD_RXHP(pDM_Odm);
+					pRX_HP_Table->PSD_func_trigger = 1;
+					PSDTriggerCnt = 0;
+				}
+				else
+				{
+             				PSDTriggerCnt++;
+				}
+#if(DEV_BUS_TYPE == RT_USB_INTERFACE)
+			}	
+			//2 After TP Mode ==> Check if TP degrade larger than 20% would trigger PSD function
+			if(pRX_HP_Table->TP_Mode == High_TP_Mode)
+			{
+				if((pre_state_flag == 0)&&(LatchCnt == 0)) 
+				{
+					// TP var < 5%
+					if((((curTPOkCnt-TP_Acc3)*20)<(TP_Acc3))&&(((curTPOkCnt-TP_Acc3)*20)>(-TP_Acc3)))
+					{
+						pre_state++;
+						if(pre_state == 3)      // hit pre_state condition => consecutive 3 times
+						{
+							pre_state_flag = 1;
+							pre_state = 0;
+						}
+
+					}
+					else
+					{
+						pre_state = 0;
+					}
+				}
+				//3 If pre_state_flag=1 ==> start to monitor TP degrade 20%
+				if(pre_state_flag == 1)		
+				{
+					if(((TP_Acc3-curTPOkCnt)*5)>(TP_Acc3))      // degrade 20%
+					{
+						odm_PSD_RXHP(pDM_Odm);
+						pRX_HP_Table->PSD_func_trigger = 1;
+						TP_Degrade_flag = 1;
+						LatchCnt = 2;
+						pre_state_flag = 0;
+					}
+					else if(((TP_Buff[2]-curTPOkCnt)*5)>TP_Buff[2])
+					{
+						odm_PSD_RXHP(pDM_Odm);
+						pRX_HP_Table->PSD_func_trigger = 1;
+						TP_Degrade_flag = 1;
+						LatchCnt = 2;
+						pre_state_flag = 0;
+					}
+					else if(((TP_Buff[3]-curTPOkCnt)*5)>TP_Buff[3])
+					{
+						odm_PSD_RXHP(pDM_Odm);
+						pRX_HP_Table->PSD_func_trigger = 1;
+						TP_Degrade_flag = 1;
+						LatchCnt = 2;
+						pre_state_flag = 0;
+					}
+				}
+			}
+#endif
+}
+
+#if (DEV_BUS_TYPE == RT_USB_INTERFACE)
+		for (i=0;i<4;i++)
+		{
+			TP_Buff[4-i] = TP_Buff[3-i];
+		}
+#endif
+		//2 Update PSD bitmap according to PSD report 
+		if((pRX_HP_Table->PSD_func_trigger == 1)&&(LatchCnt == 0))
+    		{	
+           		//2 Separate 80M bandwidth into 16 group with smaller 5M BW.
+			for (i = 0 ; i < 16 ; i++)
+           		{
+				sum = 0;
+				for(j = 0; j < 5 ; j++)
+                			sum += pRX_HP_Table->PSD_bitmap_RXHP[5*i + j];
+            
+                		if(sum < 5)
+                		{
+                			ch_map_intf_5M[i] = 1;  // interference flag
+                		}
+           		}
+			//=============just for debug=========================
+			//for(i=0;i<16;i++)
+				//DbgPrint("RX HP: ch_map_intf_5M[%d] = %d\n", i, ch_map_intf_5M[i]);
+			//===============================================
+			//2 Mask target channel 5M index
+	    		for(i = 0; i < (4+4*Is40MHz) ; i++)
+           		{
+				ch_map_intf_5M[cur_channel - (1+2*Is40MHz) + i] = 0;  
+           		}
+				
+           		psd_intf_flag = 0;
+	    		for(i = 0; i < 16; i++)
+           		{
+         			if(ch_map_intf_5M[i] == 1)
+	              	{
+	              		psd_intf_flag = 1;            // interference is detected!!!	
+	              		break;
+         			}
+	    		}
+				
+#if (DEV_BUS_TYPE == RT_USB_INTERFACE)
+			if(pRX_HP_Table->TP_Mode!=Idle_Mode)
+			{
+				if(psd_intf_flag == 1)     // to avoid psd_intf_flag always 1
+				{
+					Intf_HighTP_flag = 1;
+					De_counter = 32;     // 0x1E -> 0x3E needs 32 times by each IGI step =1
+				}
+			}
+#endif
+			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP psd_intf_flag = %d\n", psd_intf_flag));
+			//2 Distance between target channel and interference
+           		for(i = 0; i < 16; i++)
+          		{
+				if(ch_map_intf_5M[i] == 1)
+                		{
+					Intf_diff_idx = ((cur_channel+Is40MHz-(i+1))>0) ? (s1Byte)(cur_channel-2*Is40MHz-(i-2)) : (s1Byte)((i+1)-(cur_channel+2*Is40MHz));  
+                      		if(Intf_diff_idx < MIN_Intf_diff_idx)
+						MIN_Intf_diff_idx = Intf_diff_idx;    // the min difference index between interference and target
+		  		}
+	    		}
+	    		ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP MIN_Intf_diff_idx = %d\n", MIN_Intf_diff_idx)); 
+			//2 Choose False Alarm Threshold
+			switch (MIN_Intf_diff_idx){
+      				case 0: 
+	   			case 1:
+	        		case 2:
+	        		case 3:	 	 
+                 			FA_TH = FA_RXHP_TH1;  
+                     		break;
+	        		case 4:				// CH5
+	        		case 5:				// CH6
+		   			FA_TH = FA_RXHP_TH2;	
+               			break;
+	        		case 6:				// CH7
+	        		case 7:				// CH8
+		      			FA_TH = FA_RXHP_TH3;
+                    			break; 
+               		case 8:				// CH9
+	        		case 9:				//CH10
+		      			FA_TH = FA_RXHP_TH4;
+                    			break; 	
+	        		case 10:
+	        		case 11:
+	        		case 12:
+	        		case 13:	 
+	        		case 14:
+	      			case 15:	 	
+		      			FA_TH = FA_RXHP_TH5;
+                    			break;  		
+       		}	
+			ODM_RT_TRACE(pDM_Odm,	ODM_COMP_RXHP, ODM_DBG_LOUD, ("RX HP FA_TH = %d\n", FA_TH));
+			pRX_HP_Table->PSD_func_trigger = 0;
+		}
+		//1 Monitor RSSI variation to choose the suitable IGI or Exit AGC RX High Power Mode
+         	if(pRX_HP_Table->RXHP_flag == 1)
+         	{
+              	if ((curRssi > 80)&&(preRssi < 80))
+              	{ 
+                   		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_1;
+              	}
+              	else if ((curRssi < 80)&&(preRssi > 80))
+              	{
+                   		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_2;
+			}
+	       	else if ((curRssi > 72)&&(preRssi < 72))
+	      		{
+                		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_2;
+	       	}
+              	else if ((curRssi < 72)&&( preRssi > 72))
+	     		{
+                   		pRX_HP_Table->Cur_IGI = LNA_Low_Gain_3;
+	       	}
+	       	else if (curRssi < 68)		 //RSSI is NOT large enough!!==> Exit AGC RX High Power Mode
+	       	{
+                   		pRX_HP_Table->Cur_pw_th = pw_th_10dB;
+				pRX_HP_Table->RXHP_flag = 0;    // Back to Normal DIG Mode		  
+				psd_intf_flag = 0;
+			}
+		}
+		else    // pRX_HP_Table->RXHP_flag == 0
+		{
+			//1 Decide whether to enter AGC RX High Power Mode
+			if ((curRssi > 70) && (psd_intf_flag == 1) && (FalseAlmCnt->Cnt_all > FA_TH) &&  
+				(pDM_DigTable->CurIGValue == pDM_DigTable->rx_gain_range_max))
+			{
+             			if (curRssi > 80)
+             			{
+					pRX_HP_Table->Cur_IGI = LNA_Low_Gain_1;
+				}
+				else if (curRssi > 72) 
+              		{
+               			pRX_HP_Table->Cur_IGI = LNA_Low_Gain_2;
+				}
+             			else
+            			{
+                   			pRX_HP_Table->Cur_IGI = LNA_Low_Gain_3;
+				}
+           			pRX_HP_Table->Cur_pw_th = pw_th_16dB;		//RegC54[9:8]=2'b11: to enter AGC Flow 3
+				pRX_HP_Table->First_time_enter = TRUE;
+				pRX_HP_Table->RXHP_flag = 1;    //	RXHP_flag=1: AGC RX High Power Mode, RXHP_flag=0: Normal DIG Mode
+			}
+		}
+		preRssi = curRssi; 
+		odm_Write_RXHP(pDM_Odm);	
+	}
+#endif //#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+#endif //#if (DEV_BUS_TYPE == RT_PCI_INTERFACE) | (DEV_BUS_TYPE == RT_USB_INTERFACE)
+}
+
+
+VOID
+odm_PSD_RXHPCallback(
+	PRT_TIMER		pTimer
+)
+{
+	PADAPTER		Adapter = (PADAPTER)pTimer->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	pRXHP_T			pRX_HP_Table  = &pDM_Odm->DM_RXHP_Table;
+	
+#if DEV_BUS_TYPE==RT_PCI_INTERFACE
+	#if USE_WORKITEM
+	ODM_ScheduleWorkItem(&pRX_HP_Table->PSDTimeWorkitem);
+	#else
+	odm_PSD_RXHP(pDM_Odm);
+	#endif
+#else
+	ODM_ScheduleWorkItem(&pRX_HP_Table->PSDTimeWorkitem);
+#endif
+	
+	}
+
+VOID
+odm_PSD_RXHPWorkitemCallback(
+    IN PVOID            pContext
+    )
+{
+	PADAPTER	pAdapter = (PADAPTER)pContext;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	PDM_ODM_T		pDM_Odm = &pHalData->DM_OutSrc;
+	
+	odm_PSD_RXHP(pDM_Odm);
+}
+
+#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+
+ 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RXHP.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RXHP.h
new file mode 100644
index 000000000000..ef07bba0119f
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RXHP.h
@@ -0,0 +1,105 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__PHYDMRXHP_H__
+#define    __PHYDMRXHP_H__
+
+#define RXHP_VERSION	"1.0"
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+#define	AFH_PSD		1	//0:normal PSD scan, 1: only do 20 pts PSD
+#define	MODE_40M		0	//0:20M, 1:40M
+#define	PSD_TH2		3  
+#define	PSD_CHMIN		20   // Minimum channel number for BT AFH
+#define	SIR_STEP_SIZE	3
+#define   Smooth_Size_1 	5
+#define	Smooth_TH_1	3
+#define   Smooth_Size_2 	10
+#define	Smooth_TH_2	4
+#define   Smooth_Size_3 	20
+#define	Smooth_TH_3	4
+#define   Smooth_Step_Size 5
+#define	Adaptive_SIR	1
+#define	PSD_RESCAN		4
+#define	PSD_SCAN_INTERVAL	700 //ms
+
+typedef struct _RX_High_Power_
+{
+	u1Byte		RXHP_flag;
+	u1Byte		PSD_func_trigger;
+	u1Byte		PSD_bitmap_RXHP[80];
+	u1Byte		Pre_IGI;
+	u1Byte		Cur_IGI;
+	u1Byte		Pre_pw_th;
+	u1Byte		Cur_pw_th;
+	BOOLEAN		First_time_enter;
+	BOOLEAN		RXHP_enable;
+	u1Byte		TP_Mode;
+	RT_TIMER	PSDTimer;
+	#if USE_WORKITEM
+	RT_WORK_ITEM		PSDTimeWorkitem;
+	#endif
+}RXHP_T, *pRXHP_T;
+
+#define	dm_PSDMonitorCallback	odm_PSDMonitorCallback
+VOID	odm_PSDMonitorCallback(PRT_TIMER		pTimer);
+
+VOID
+odm_PSDMonitorInit(
+	IN		PVOID			pDM_VOID
+	);
+
+void	odm_RXHPInit(
+	IN		PVOID			pDM_VOID);
+
+void odm_RXHP(
+	IN		PVOID			pDM_VOID);
+
+VOID
+odm_PSD_RXHPCallback(
+	PRT_TIMER		pTimer
+);
+
+ VOID
+ODM_PSDDbgControl(
+	IN	PADAPTER	Adapter,
+	IN	u4Byte		mode,
+	IN	u4Byte		btRssi
+	);
+
+ VOID
+odm_PSD_RXHPCallback(
+	PRT_TIMER		pTimer
+);
+
+VOID
+odm_PSD_RXHPWorkitemCallback(
+    IN PVOID            pContext
+    );
+
+VOID
+odm_PSDMonitorWorkItemCallback(
+    IN PVOID            pContext
+    );
+
+ #endif
+
+ #endif
+ 
\ No newline at end of file
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RaInfo.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RaInfo.c
new file mode 100644
index 000000000000..0e7873745a3a
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RaInfo.c
@@ -0,0 +1,1595 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+
+VOID
+odm_RSSIMonitorInit(
+	IN		PVOID		pDM_VOID
+	)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T		pRA_Table = &pDM_Odm->DM_RA_Table;
+   	pRA_Table->firstconnect = FALSE;
+	
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN))
+	pRA_Table->PT_collision_pre = TRUE;   //used in ODM_DynamicARFBSelect(WIN only)
+#endif	
+#endif
+}
+
+
+VOID
+odm_RSSIMonitorCheck(
+	IN		PVOID		pDM_VOID
+	)
+{
+	// 
+	// For AP/ADSL use prtl8192cd_priv
+	// For CE/NIC use PADAPTER
+	//
+PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	if (!(pDM_Odm->SupportAbility & ODM_BB_RSSI_MONITOR))
+		return;
+	
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+			odm_RSSIMonitorCheckMP(pDM_Odm);
+			break;
+
+		case	ODM_CE:
+			odm_RSSIMonitorCheckCE(pDM_Odm);
+			break;
+
+		case	ODM_AP:
+			odm_RSSIMonitorCheckAP(pDM_Odm);
+			break;		
+
+		case	ODM_ADSL:
+			//odm_DIGAP(pDM_Odm);
+			break;	
+	}
+	
+}	// odm_RSSIMonitorCheck
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+odm_RSSIDumpToRegister(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+
+	if(pDM_Odm->SupportICType == ODM_RTL8812)
+	{
+		PlatformEFIOWrite1Byte(Adapter, rA_RSSIDump_Jaguar, Adapter->RxStats.RxRSSIPercentage[0]);
+		PlatformEFIOWrite1Byte(Adapter, rB_RSSIDump_Jaguar, Adapter->RxStats.RxRSSIPercentage[1]);
+
+		// Rx EVM
+		PlatformEFIOWrite1Byte(Adapter, rS1_RXevmDump_Jaguar, Adapter->RxStats.RxEVMdbm[0]);
+		PlatformEFIOWrite1Byte(Adapter, rS2_RXevmDump_Jaguar, Adapter->RxStats.RxEVMdbm[1]);
+
+		// Rx SNR
+		PlatformEFIOWrite1Byte(Adapter, rA_RXsnrDump_Jaguar, (u1Byte)(Adapter->RxStats.RxSNRdB[0]));
+		PlatformEFIOWrite1Byte(Adapter, rB_RXsnrDump_Jaguar, (u1Byte)(Adapter->RxStats.RxSNRdB[1]));
+
+		// Rx Cfo_Short
+		PlatformEFIOWrite2Byte(Adapter, rA_CfoShortDump_Jaguar, Adapter->RxStats.RxCfoShort[0]);
+		PlatformEFIOWrite2Byte(Adapter, rB_CfoShortDump_Jaguar, Adapter->RxStats.RxCfoShort[1]);
+
+		// Rx Cfo_Tail
+		PlatformEFIOWrite2Byte(Adapter, rA_CfoLongDump_Jaguar, Adapter->RxStats.RxCfoTail[0]);
+		PlatformEFIOWrite2Byte(Adapter, rB_CfoLongDump_Jaguar, Adapter->RxStats.RxCfoTail[1]);
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
+	{
+		PlatformEFIOWrite1Byte(Adapter, rA_RSSIDump_92E, Adapter->RxStats.RxRSSIPercentage[0]);
+		PlatformEFIOWrite1Byte(Adapter, rB_RSSIDump_92E, Adapter->RxStats.RxRSSIPercentage[1]);
+		// Rx EVM
+		PlatformEFIOWrite1Byte(Adapter, rS1_RXevmDump_92E, Adapter->RxStats.RxEVMdbm[0]);
+		PlatformEFIOWrite1Byte(Adapter, rS2_RXevmDump_92E, Adapter->RxStats.RxEVMdbm[1]);
+		// Rx SNR
+		PlatformEFIOWrite1Byte(Adapter, rA_RXsnrDump_92E, (u1Byte)(Adapter->RxStats.RxSNRdB[0]));
+		PlatformEFIOWrite1Byte(Adapter, rB_RXsnrDump_92E, (u1Byte)(Adapter->RxStats.RxSNRdB[1]));
+		// Rx Cfo_Short
+		PlatformEFIOWrite2Byte(Adapter, rA_CfoShortDump_92E, Adapter->RxStats.RxCfoShort[0]);
+		PlatformEFIOWrite2Byte(Adapter, rB_CfoShortDump_92E, Adapter->RxStats.RxCfoShort[1]);
+		// Rx Cfo_Tail
+		PlatformEFIOWrite2Byte(Adapter, rA_CfoLongDump_92E, Adapter->RxStats.RxCfoTail[0]);
+		PlatformEFIOWrite2Byte(Adapter, rB_CfoLongDump_92E, Adapter->RxStats.RxCfoTail[1]);
+	 }
+}
+#endif
+
+VOID
+odm_RSSIMonitorCheckMP(
+	IN	PVOID	pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PRT_WLAN_STA	pEntry = NULL;
+	u1Byte			i;
+	s4Byte			tmpEntryMaxPWDB=0, tmpEntryMinPWDB=0xff;
+	u1Byte			H2C_Parameter[4] ={0};
+	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
+	PMGNT_INFO		pDefaultMgntInfo = &Adapter->MgntInfo;
+	u8Byte			curTxOkCnt = 0, curRxOkCnt = 0;	
+	u1Byte			STBC_TX = 0;
+	BOOLEAN			FirstConnect;                                                    
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table; 
+	pDIG_T			pDM_DigTable = &pDM_Odm->DM_DigTable;
+
+#if (BEAMFORMING_SUPPORT == 1)	
+	BEAMFORMING_CAP Beamform_cap = BEAMFORMING_CAP_NONE;
+	u1Byte			TxBF_EN = 0;
+#endif
+
+	PADAPTER	pLoopAdapter = GetDefaultAdapter(Adapter);
+
+	BOOLEAN		bExtRAInfo = FALSE;
+
+	if(pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8821 || pDM_Odm->SupportICType == ODM_RTL8723B)
+		bExtRAInfo = TRUE;
+
+	FirstConnect = (pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0 == FALSE);
+	pRA_Table->firstconnect = pHalData->bLinked;                                               
+       H2C_Parameter[3] |= FirstConnect << 5;
+
+	if(pDM_Odm->SupportICType == ODM_RTL8188E && (pDefaultMgntInfo->CustomerID==RT_CID_819x_HP))
+	{
+		if(curRxOkCnt >(curTxOkCnt*6))
+			PlatformEFIOWrite4Byte(Adapter, REG_ARFR0, 0x8f015);
+		else
+			PlatformEFIOWrite4Byte(Adapter, REG_ARFR0, 0xff015);
+	}	
+
+	if(pDM_Odm->SupportICType == ODM_RTL8812 || pDM_Odm->SupportICType == ODM_RTL8821)
+	{
+		if(curRxOkCnt >(curTxOkCnt*6))
+			H2C_Parameter[3]=0x01;
+		else
+			H2C_Parameter[3]=0x00;
+	}
+
+	while(pLoopAdapter)
+	{		
+	
+		if(pLoopAdapter != NULL){
+			pMgntInfo = &pLoopAdapter->MgntInfo;			
+			curTxOkCnt = pLoopAdapter->TxStats.NumTxBytesUnicast - pMgntInfo->lastTxOkCnt;
+			curRxOkCnt = pLoopAdapter->RxStats.NumRxBytesUnicast - pMgntInfo->lastRxOkCnt;
+			pMgntInfo->lastTxOkCnt = curTxOkCnt;
+			pMgntInfo->lastRxOkCnt = curRxOkCnt;			
+		}
+
+		for(i = 0; i < ASSOCIATE_ENTRY_NUM; i++)
+		{
+		
+			if(IsAPModeExist(pLoopAdapter))
+			{
+				if(GetFirstExtAdapter(pLoopAdapter) != NULL && 
+					GetFirstExtAdapter(pLoopAdapter) == pLoopAdapter){	
+					pEntry = AsocEntry_EnumStation(pLoopAdapter, i);		
+				}
+				else if(GetFirstGOPort(pLoopAdapter) != NULL && 
+					IsFirstGoAdapter(pLoopAdapter)){
+					pEntry = AsocEntry_EnumStation(pLoopAdapter, i);						
+				}				
+			}
+			else
+			{
+					if(GetDefaultAdapter(pLoopAdapter) == pLoopAdapter){
+						pEntry = AsocEntry_EnumStation(pLoopAdapter, i);					
+					}
+			}
+
+		if(pEntry != NULL)
+		{
+			if(pEntry->bAssociated)
+			{
+			
+				RT_DISP_ADDR(FDM, DM_PWDB, ("pEntry->MacAddr ="), pEntry->MacAddr);
+				RT_DISP(FDM, DM_PWDB, ("pEntry->rssi = 0x%x(%d)\n", 
+					pEntry->rssi_stat.UndecoratedSmoothedPWDB, pEntry->rssi_stat.UndecoratedSmoothedPWDB));
+
+				if(bExtRAInfo)
+				{
+
+#if (BEAMFORMING_SUPPORT == 1)
+					Beamform_cap = Beamforming_GetEntryBeamCapByMacId(Adapter, pEntry->AssociatedMacId);
+					if(Beamform_cap & (BEAMFORMER_CAP_HT_EXPLICIT |BEAMFORMER_CAP_VHT_SU))
+						TxBF_EN = 1;
+					else
+						TxBF_EN = 0;
+	
+					H2C_Parameter[3] |= TxBF_EN << 6; 
+					
+					if(TxBF_EN)
+						STBC_TX = 0;
+					else
+#endif
+					{
+						if(IS_WIRELESS_MODE_AC(Adapter))
+							STBC_TX = TEST_FLAG(pEntry->VHTInfo.STBC, STBC_VHT_ENABLE_TX);
+						else
+							STBC_TX = TEST_FLAG(pEntry->HTInfo.STBC, STBC_HT_ENABLE_TX);
+					}
+
+					H2C_Parameter[3] |= STBC_TX << 1;
+				}
+
+				if(pEntry->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+					tmpEntryMinPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+				if(pEntry->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+					tmpEntryMaxPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+
+				H2C_Parameter[2] = (u1Byte)(pEntry->rssi_stat.UndecoratedSmoothedPWDB & 0xFF);
+				H2C_Parameter[1] = 0x20;   // fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
+				H2C_Parameter[0] = (pEntry->AssociatedMacId);
+				if(bExtRAInfo)
+					ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, 4, H2C_Parameter);
+				else
+					ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, 3, H2C_Parameter);
+			}
+		}
+		else
+		{
+			break;
+		}
+	}
+
+		pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
+	}
+
+	if(tmpEntryMaxPWDB != 0)	// If associated entry is found
+	{
+		pHalData->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
+		RT_DISP(FDM, DM_PWDB, ("EntryMaxPWDB = 0x%x(%d)\n",	tmpEntryMaxPWDB, tmpEntryMaxPWDB));
+	}
+	else
+	{
+		pHalData->EntryMaxUndecoratedSmoothedPWDB = 0;
+	}
+	
+	if(tmpEntryMinPWDB != 0xff) // If associated entry is found
+	{
+		pHalData->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
+		RT_DISP(FDM, DM_PWDB, ("EntryMinPWDB = 0x%x(%d)\n", tmpEntryMinPWDB, tmpEntryMinPWDB));
+
+	}
+	else
+	{
+		pHalData->EntryMinUndecoratedSmoothedPWDB = 0;
+	}
+
+	// Indicate Rx signal strength to FW.
+	if(pHalData->bUseRAMask)
+	{
+		if(bExtRAInfo)
+		{
+			PRT_HIGH_THROUGHPUT 		pHTInfo = GET_HT_INFO(pDefaultMgntInfo);
+			PRT_VERY_HIGH_THROUGHPUT	pVHTInfo = GET_VHT_INFO(pDefaultMgntInfo);
+
+#if (BEAMFORMING_SUPPORT == 1)
+			
+			Beamform_cap = Beamforming_GetEntryBeamCapByMacId(Adapter, pDefaultMgntInfo->mMacId);
+
+			if(Beamform_cap & (BEAMFORMER_CAP_HT_EXPLICIT |BEAMFORMER_CAP_VHT_SU))
+				TxBF_EN = 1;
+			else
+				TxBF_EN = 0;
+
+			H2C_Parameter[3] |= TxBF_EN << 6; 
+
+			if(TxBF_EN)
+				STBC_TX = 0;
+			else
+#endif
+			{
+				if(IS_WIRELESS_MODE_AC(Adapter))
+					STBC_TX = TEST_FLAG(pVHTInfo->VhtCurStbc, STBC_VHT_ENABLE_TX);
+				else
+					STBC_TX = TEST_FLAG(pHTInfo->HtCurStbc, STBC_HT_ENABLE_TX);
+			}
+
+			H2C_Parameter[3] |= STBC_TX << 1;
+		}
+		
+		H2C_Parameter[2] = (u1Byte)(pHalData->UndecoratedSmoothedPWDB & 0xFF);
+		H2C_Parameter[1] = 0x20;	// fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
+		H2C_Parameter[0] = 0;		// fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
+		if(bExtRAInfo)
+			ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, 4, H2C_Parameter);
+		else
+			ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, 3, H2C_Parameter);
+		
+		// BT 3.0 HS mode Rssi
+		if(pDM_Odm->bBtHsOperation)
+		{
+			H2C_Parameter[2] = pDM_Odm->btHsRssi;
+			H2C_Parameter[1] = 0x0;
+			H2C_Parameter[0] = 2;
+			if(bExtRAInfo)
+				ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, 4, H2C_Parameter);
+			else	
+				ODM_FillH2CCmd(pDM_Odm, ODM_H2C_RSSI_REPORT, 3, H2C_Parameter);
+		}
+	}
+	else
+	{
+		PlatformEFIOWrite1Byte(Adapter, 0x4fe, (u1Byte)pHalData->UndecoratedSmoothedPWDB);
+	}
+
+	if((pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8192E))
+		odm_RSSIDumpToRegister(pDM_Odm);
+		
+
+	{
+		PADAPTER pLoopAdapter = GetDefaultAdapter(Adapter);
+		s4Byte	GlobalRSSI_min = 0xFF, LocalRSSI_Min;
+		BOOLEAN		bLink= FALSE;
+		
+		while(pLoopAdapter)
+		{
+			LocalRSSI_Min = odm_FindMinimumRSSI(pLoopAdapter);
+			//DbgPrint("pHalData->bLinked=%d, LocalRSSI_Min=%d\n", pHalData->bLinked, LocalRSSI_Min);
+			if((LocalRSSI_Min < GlobalRSSI_min) && (LocalRSSI_Min != 0))
+				GlobalRSSI_min = LocalRSSI_Min;			
+			
+			if(pHalData->bLinked)
+				bLink = TRUE;
+			
+			pLoopAdapter = GetNextExtAdapter(pLoopAdapter);
+		}
+
+		pHalData->bLinked = bLink;
+		ODM_CmnInfoUpdate(&pHalData->DM_OutSrc ,ODM_CMNINFO_LINK, (u8Byte)bLink);
+		ODM_CmnInfoUpdate(&pHalData->DM_OutSrc ,ODM_CMNINFO_RSSI_MIN, (u8Byte)GlobalRSSI_min);
+		
+	}
+	
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+}
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_CE)
+//
+//sherry move from DUSC to here 20110517
+//
+static VOID
+FindMinimumRSSI_Dmsp(
+	IN	PADAPTER	pAdapter
+)
+{
+#if 0
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	s32	Rssi_val_min_back_for_mac0;
+	BOOLEAN		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(pAdapter);
+	BOOLEAN		bRestoreRssi = _FALSE;
+	PADAPTER	BuddyAdapter = pAdapter->BuddyAdapter;
+
+	if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+	{
+		if(BuddyAdapter!= NULL)
+		{
+			if(pHalData->bSlaveOfDMSP)
+			{
+				//ODM_RT_TRACE(pDM_Odm,COMP_EASY_CONCURRENT,DBG_LOUD,("bSlavecase of dmsp\n"));
+				BuddyAdapter->DualMacDMSPControl.RssiValMinForAnotherMacOfDMSP = pdmpriv->MinUndecoratedPWDBForDM;
+			}
+			else
+			{
+				if(bGetValueFromBuddyAdapter)
+				{
+					//ODM_RT_TRACE(pDM_Odm,COMP_EASY_CONCURRENT,DBG_LOUD,("get new RSSI\n"));
+					bRestoreRssi = _TRUE;
+					Rssi_val_min_back_for_mac0 = pdmpriv->MinUndecoratedPWDBForDM;
+					pdmpriv->MinUndecoratedPWDBForDM = pAdapter->DualMacDMSPControl.RssiValMinForAnotherMacOfDMSP;
+				}
+			}
+		}
+		
+	}
+
+	if(bRestoreRssi)
+	{
+		bRestoreRssi = _FALSE;
+		pdmpriv->MinUndecoratedPWDBForDM = Rssi_val_min_back_for_mac0;
+	}
+#endif
+}
+
+static void
+FindMinimumRSSI(
+IN	PADAPTER	pAdapter
+	)
+{	
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;	
+	PDM_ODM_T		pDM_Odm = &(pHalData->odmpriv);
+
+	//1 1.Determine the minimum RSSI 
+
+	if((pDM_Odm->bLinked != _TRUE) &&
+		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
+	{
+		pdmpriv->MinUndecoratedPWDBForDM = 0;
+		//ODM_RT_TRACE(pDM_Odm,COMP_BB_POWERSAVING, DBG_LOUD, ("Not connected to any \n"));
+	}
+	else
+	{
+		pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+	}
+
+	//DBG_8192C("%s=>MinUndecoratedPWDBForDM(%d)\n",__FUNCTION__,pdmpriv->MinUndecoratedPWDBForDM);
+	//ODM_RT_TRACE(pDM_Odm,COMP_DIG, DBG_LOUD, ("MinUndecoratedPWDBForDM =%d\n",pHalData->MinUndecoratedPWDBForDM));
+}
+#endif
+
+VOID
+odm_RSSIMonitorCheckCE(
+	IN		PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER	Adapter = pDM_Odm->Adapter;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(Adapter);
+	int	i;
+	int	tmpEntryMaxPWDB=0, tmpEntryMinPWDB=0xff;
+	u8 	sta_cnt=0;
+	u32	UL_DL_STATE = 0, STBC_TX = 0, TxBF_EN = 0;
+	u32	PWDB_rssi[NUM_STA]={0};//[0~15]:MACID, [16~31]:PWDB_rssi
+	BOOLEAN			FirstConnect = FALSE;
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
+
+	if(pDM_Odm->bLinked != _TRUE)
+		return;
+
+	#if((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
+	if((pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8821))
+	{
+		u64	curTxOkCnt = pdvobjpriv->traffic_stat.cur_tx_bytes;
+		u64	curRxOkCnt = pdvobjpriv->traffic_stat.cur_rx_bytes;
+
+		if(curRxOkCnt >(curTxOkCnt*6))
+			UL_DL_STATE = 1;
+		else
+			UL_DL_STATE = 0;
+	}
+	#endif
+
+       FirstConnect = (pDM_Odm->bLinked) && (pRA_Table->firstconnect == FALSE);    
+	pRA_Table->firstconnect = pDM_Odm->bLinked;
+
+	//if(check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	{
+		#if 1
+		struct sta_info *psta;
+		
+		for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++) {
+			if (IS_STA_VALID(psta = pDM_Odm->pODM_StaInfo[i]))
+			{
+                        		if(IS_MCAST( psta->hwaddr))  //if(psta->mac_id ==1)
+						 continue;
+								
+					if(psta->rssi_stat.UndecoratedSmoothedPWDB == (-1))
+						 continue;
+								
+					if(psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+						tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+					if(psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+						tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+					#if 0
+					DBG_871X("%s mac_id:%u, mac:"MAC_FMT", rssi:%d\n", __func__,
+						psta->mac_id, MAC_ARG(psta->hwaddr), psta->rssi_stat.UndecoratedSmoothedPWDB);
+					#endif
+
+					if(psta->rssi_stat.UndecoratedSmoothedPWDB != (-1)) {
+
+#ifdef CONFIG_80211N_HT
+						if(pDM_Odm->SupportICType == ODM_RTL8192E || pDM_Odm->SupportICType == ODM_RTL8812)
+						{
+#ifdef CONFIG_BEAMFORMING
+							BEAMFORMING_CAP Beamform_cap = beamforming_get_entry_beam_cap_by_mac_id(&Adapter->mlmepriv, psta->mac_id);
+
+							if(Beamform_cap & (BEAMFORMER_CAP_HT_EXPLICIT |BEAMFORMER_CAP_VHT_SU))
+								TxBF_EN = 1;
+							else
+								TxBF_EN = 0;
+
+							if (TxBF_EN) {
+								STBC_TX = 0;
+							}
+							else
+#endif
+							{
+#ifdef CONFIG_80211AC_VHT
+								if(IsSupportedVHT(psta->wireless_mode))
+									STBC_TX = TEST_FLAG(psta->vhtpriv.stbc_cap, STBC_VHT_ENABLE_TX);
+								else	
+#endif
+									STBC_TX = TEST_FLAG(psta->htpriv.stbc_cap, STBC_HT_ENABLE_TX);
+							}
+						}
+#endif
+
+						if(pDM_Odm->SupportICType == ODM_RTL8192D)
+							PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) | ((Adapter->stapriv.asoc_sta_count+1) << 8));
+						else if ((pDM_Odm->SupportICType == ODM_RTL8192E)||(pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8821))
+							PWDB_rssi[sta_cnt++] = (((u8)(psta->mac_id&0xFF)) | ((psta->rssi_stat.UndecoratedSmoothedPWDB&0x7F)<<16) |(STBC_TX << 25) | (FirstConnect << 29) | (TxBF_EN << 30));
+						else
+							PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) );
+					}
+			}
+		}
+		#else
+		_irqL irqL;
+		_list	*plist, *phead;
+		struct sta_info *psta;
+		struct sta_priv *pstapriv = &Adapter->stapriv;
+		u8 bcast_addr[ETH_ALEN]= {0xff,0xff,0xff,0xff,0xff,0xff};
+
+		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+		for(i=0; i< NUM_STA; i++)
+		{
+			phead = &(pstapriv->sta_hash[i]);
+			plist = get_next(phead);
+		
+			while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+			{
+				psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+
+				plist = get_next(plist);
+
+				if(_rtw_memcmp(psta->hwaddr, bcast_addr, ETH_ALEN) || 
+					_rtw_memcmp(psta->hwaddr, myid(&Adapter->eeprompriv), ETH_ALEN))
+					continue;
+
+				if(psta->state & WIFI_ASOC_STATE)
+				{
+					
+					if(psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+						tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+					if(psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+						tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+					if(psta->rssi_stat.UndecoratedSmoothedPWDB != (-1)){
+						//printk("%s==> mac_id(%d),rssi(%d)\n",__FUNCTION__,psta->mac_id,psta->rssi_stat.UndecoratedSmoothedPWDB);
+						#if(RTL8192D_SUPPORT==1)
+						PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) | ((Adapter->stapriv.asoc_sta_count+1) << 8));
+						#else
+						PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) );
+						#endif
+					}
+				}
+			
+			}
+
+		}
+	
+		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		#endif
+
+		//printk("%s==> sta_cnt(%d)\n",__FUNCTION__,sta_cnt);
+
+		for(i=0; i< sta_cnt; i++)
+		{
+			if(PWDB_rssi[i] != (0)){
+				if(pHalData->fw_ractrl == _TRUE)// Report every sta's RSSI to FW
+				{
+					#if(RTL8192D_SUPPORT==1)
+					if(pDM_Odm->SupportICType == ODM_RTL8192D){
+						FillH2CCmd92D(Adapter, H2C_RSSI_REPORT, 3, (u8 *)(&PWDB_rssi[i]));		
+					}
+					#endif
+					
+					#if((RTL8192C_SUPPORT==1)||(RTL8723A_SUPPORT==1))
+					if((pDM_Odm->SupportICType == ODM_RTL8192C)||(pDM_Odm->SupportICType == ODM_RTL8723A)){
+						rtl8192c_set_rssi_cmd(Adapter, (u8*)&PWDB_rssi[i]);
+					}
+					#endif
+					
+					#if((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
+					if((pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8821)){	
+						PWDB_rssi[i] |= (UL_DL_STATE << 24);
+						rtl8812_set_rssi_cmd(Adapter, (u8 *)(&PWDB_rssi[i]));
+					}
+					#endif
+					#if(RTL8192E_SUPPORT==1)
+					if(pDM_Odm->SupportICType == ODM_RTL8192E){
+						rtl8192e_set_rssi_cmd(Adapter, (u8 *)(&PWDB_rssi[i]));
+					}
+					#endif
+					#if(RTL8723B_SUPPORT==1)
+					if(pDM_Odm->SupportICType == ODM_RTL8723B){
+						rtl8723b_set_rssi_cmd(Adapter, (u8 *)(&PWDB_rssi[i]));
+					}
+					#endif
+
+					#if(RTL8188E_SUPPORT==1)
+					if(pDM_Odm->SupportICType == ODM_RTL8188E){
+						rtl8188e_set_rssi_cmd(Adapter, (u8 *)(&PWDB_rssi[i]));
+					}
+					#endif
+										
+				}
+				else{
+					#if((RTL8188E_SUPPORT==1)&&(RATE_ADAPTIVE_SUPPORT == 1))
+					if(pDM_Odm->SupportICType == ODM_RTL8188E){
+						ODM_RA_SetRSSI_8188E(
+						&(pHalData->odmpriv), (PWDB_rssi[i]&0xFF), (u8)((PWDB_rssi[i]>>16) & 0xFF));
+					}
+					#endif
+				}
+			}
+		}		
+	}
+
+
+
+	if(tmpEntryMaxPWDB != 0)	// If associated entry is found
+	{
+		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;		
+	}
+	else
+	{
+		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;
+	}
+
+	if(tmpEntryMinPWDB != 0xff) // If associated entry is found
+	{
+		pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;		
+	}
+	else
+	{
+		pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
+	}
+
+	FindMinimumRSSI(Adapter);//get pdmpriv->MinUndecoratedPWDBForDM
+
+	#if(RTL8192D_SUPPORT==1)
+	FindMinimumRSSI_Dmsp(Adapter);
+	#endif
+	pDM_Odm->RSSI_Min = pdmpriv->MinUndecoratedPWDBForDM;
+	//ODM_CmnInfoUpdate(&pHalData->odmpriv ,ODM_CMNINFO_RSSI_MIN, pdmpriv->MinUndecoratedPWDBForDM);
+#endif//if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+}
+
+
+VOID
+odm_RSSIMonitorCheckAP(
+	IN		PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT) ||defined(CONFIG_RTL_8812_SUPPORT)||defined(CONFIG_WLAN_HAL_8881A)||defined(CONFIG_WLAN_HAL_8192EE)
+	{
+		PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+		prtl8192cd_priv	priv		= pDM_Odm->priv;		
+		u4Byte i;
+		PSTA_INFO_T pstat;
+		static u1Byte H2C_Parameter[5];
+		u1Byte	  TxBF_EN = 0;
+		pBDC_T	pDM_BdcTable = &pDM_Odm->DM_BdcTable;
+
+		if( priv->up_time % 2 )
+			return;
+
+		pDM_BdcTable->num_Txbfee_Client=0;
+		pDM_BdcTable->num_Txbfer_Client=0;
+		//pDM_BdcTable->num_Client=0;
+		
+		for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+		{
+			pstat = pDM_Odm->pODM_StaInfo[i];
+			if(IS_STA_VALID(pstat) )
+			{			
+#ifdef BEAMFORMING_SUPPORT
+				BEAMFORMING_CAP Beamform_cap = Beamforming_GetEntryBeamCapByMacId(priv, pstat->aid);
+				if(Beamform_cap == BEAMFORMER_CAP_HT_EXPLICIT || Beamform_cap == BEAMFORMER_CAP_VHT_SU ||
+					 Beamform_cap == (BEAMFORMER_CAP_HT_EXPLICIT|BEAMFORMEE_CAP_HT_EXPLICIT) ||
+					 Beamform_cap == (BEAMFORMER_CAP_VHT_SU|BEAMFORMEE_CAP_VHT_SU))
+				{
+					TxBF_EN = (1<< 6);
+					pDM_BdcTable->w_BFee_Client[i]=1; //AP act as BFer
+					pDM_BdcTable->num_Txbfee_Client++;
+				}
+				else 
+				{
+					pDM_BdcTable->w_BFee_Client[i]=0; //AP act as BFer
+				}
+				
+				if((Beamform_cap & BEAMFORMEE_CAP_HT_EXPLICIT) || (Beamform_cap & BEAMFORMEE_CAP_VHT_SU) )
+				{
+					pDM_BdcTable->w_BFer_Client[i]=1; //AP act as BFee
+					pDM_BdcTable->num_Txbfer_Client++;
+				}
+				else 
+				{
+					pDM_BdcTable->w_BFer_Client[i]=0; //AP act as BFer
+				}
+
+					
+				//pDM_BdcTable->num_Client++;
+		
+				
+				
+#endif			
+//#ifdef STA_EXT
+//				if (GET_CHIP_VER(priv)==VERSION_8812E && REMAP_AID(pstat) < (RTL8812_NUM_STAT - 1))
+//#endif
+				{
+#ifdef CONFIG_RTL_8812_SUPPORT
+#ifdef STA_EXT
+					if(REMAP_AID(pstat) < (RTL8812_NUM_STAT - 1))
+#endif					
+
+					if(pDM_Odm->SupportICType == ODM_RTL8812) {
+						memset(H2C_Parameter,0,5);						
+						H2C_Parameter[2] = (u1Byte)(pstat->rssi & 0x7F);
+						H2C_Parameter[0] = REMAP_AID(pstat);				
+						if ((priv->pmib->dot11nConfigEntry.dot11nSTBC) && (
+							(pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_RX_STBC_CAP_)
+#ifdef RTK_AC_SUPPORT			
+							|| (pstat->vht_cap_buf.vht_cap_info & cpu_to_le32(_VHTCAP_RX_STBC_CAP_))
+#endif
+							)))	
+							H2C_Parameter[3] |= 2;
+						H2C_Parameter[3] |= TxBF_EN ; 
+						FillH2CCmd8812(pDM_Odm->priv, H2C_8812_RSSI_REPORT, 4, H2C_Parameter);
+					}
+#endif
+				}
+//#ifdef STA_EXT
+//				else if (GET_CHIP_VER(priv)!=VERSION_8812E && REMAP_AID(pstat) < (FW_NUM_STAT - 1)) 
+//#endif
+				{
+#if defined(CONFIG_WLAN_HAL_8881A) || defined(CONFIG_WLAN_HAL_8192EE)
+#ifdef STA_EXT
+					if(REMAP_AID(pstat) < (RTL8812_NUM_STAT - 1))
+#endif	
+					if(pDM_Odm->SupportICType == ODM_RTL8881A || pDM_Odm->SupportICType == ODM_RTL8192E) {
+//						u1Byte	H2C_Parameter[5] ={0};	
+						u1Byte	cmdlen = 3;
+						memset(H2C_Parameter, 0, 5);
+						H2C_Parameter[2] = (u1Byte)(pstat->rssi & 0xFF);
+						H2C_Parameter[0] = REMAP_AID(pstat);
+						if(pDM_Odm->SupportICType == ODM_RTL8192E) {
+							cmdlen = 4;
+							if ((priv->pmib->dot11nConfigEntry.dot11nSTBC) && (pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_RX_STBC_CAP_)))	
+								H2C_Parameter[3] |= 2;		
+							 H2C_Parameter[3] |= TxBF_EN; 
+
+						} 
+                        GET_HAL_INTERFACE(pDM_Odm->priv)->FillH2CCmdHandler(pDM_Odm->priv, H2C_88XX_RSSI_REPORT, cmdlen, H2C_Parameter);
+					}
+#endif
+				
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)	
+#ifdef STA_EXT
+					if(REMAP_AID(pstat) < (FW_NUM_STAT - 1))
+#endif
+					if(pDM_Odm->SupportICType == ODM_RTL8192C || pDM_Odm->SupportICType == ODM_RTL8192D) 
+						add_update_rssi(pDM_Odm->priv, pstat);
+#endif
+				}
+
+			}		
+		}
+	}
+#endif
+#endif
+
+}
+
+
+VOID
+odm_RateAdaptiveMaskInit(
+	IN	PVOID	pDM_VOID	
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_RATE_ADAPTIVE	pOdmRA = &pDM_Odm->RateAdaptive;
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PMGNT_INFO		pMgntInfo = &pDM_Odm->Adapter->MgntInfo;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pDM_Odm->Adapter);
+
+	pMgntInfo->Ratr_State = DM_RATR_STA_INIT;
+
+	if (pMgntInfo->DM_Type == DM_Type_ByDriver)
+		pHalData->bUseRAMask = TRUE;
+	else
+		pHalData->bUseRAMask = FALSE;	
+
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	pOdmRA->Type = DM_Type_ByDriver;
+	if (pOdmRA->Type == DM_Type_ByDriver)
+		pDM_Odm->bUseRAMask = _TRUE;
+	else
+		pDM_Odm->bUseRAMask = _FALSE;	
+#endif
+
+	pOdmRA->RATRState = DM_RATR_STA_INIT;
+	
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	if(pDM_Odm->SupportICType == ODM_RTL8812)
+		pOdmRA->LdpcThres = 50;		
+	else
+		pOdmRA->LdpcThres = 35;
+		
+	pOdmRA->RtsThres = 35;
+	
+#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	pOdmRA->LdpcThres = 35;
+	pOdmRA->bUseLdpc = FALSE;
+	
+#else
+	pOdmRA->UltraLowRSSIThresh = 9;	
+	
+#endif
+
+	pOdmRA->HighRSSIThresh = 50;
+	pOdmRA->LowRSSIThresh = 20;
+}
+/*-----------------------------------------------------------------------------
+ * Function:	odm_RefreshRateAdaptiveMask()
+ *
+ * Overview:	Update rate table mask according to rssi
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	05/27/2009	hpfan	Create Version 0.  
+ *
+ *---------------------------------------------------------------------------*/
+VOID
+odm_RefreshRateAdaptiveMask(
+	IN	PVOID	pDM_VOID
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("odm_RefreshRateAdaptiveMask()---------->\n"));	
+	if (!(pDM_Odm->SupportAbility & ODM_BB_RA_MASK))
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("odm_RefreshRateAdaptiveMask(): Return cos not supported\n"));
+		return;	
+	}
+	//
+	// 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	// at the same time. In the stage2/3, we need to prive universal interface and merge all
+	// HW dynamic mechanism.
+	//
+	switch	(pDM_Odm->SupportPlatform)
+	{
+		case	ODM_WIN:
+			odm_RefreshRateAdaptiveMaskMP(pDM_Odm);
+			break;
+
+		case	ODM_CE:
+			odm_RefreshRateAdaptiveMaskCE(pDM_Odm);
+			break;
+
+		case	ODM_AP:
+		case	ODM_ADSL:
+			odm_RefreshRateAdaptiveMaskAPADSL(pDM_Odm);
+			break;
+	}
+	
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+odm_RefreshLdpcRtsMP(
+	IN	PADAPTER			pAdapter,
+	IN	PDM_ODM_T			pDM_Odm,
+	IN	u1Byte				mMacId,
+	IN	u1Byte				IOTPeer,
+	IN	s4Byte				UndecoratedSmoothedPWDB	
+	)
+{
+	BOOLEAN					bCtlLdpc = FALSE;
+	PMGNT_INFO				pMgntInfo = GetDefaultMgntInfo(pAdapter);
+	PODM_RATE_ADAPTIVE		pRA = &pDM_Odm->RateAdaptive;
+
+	if(pDM_Odm->SupportICType != ODM_RTL8821 && pDM_Odm->SupportICType != ODM_RTL8812)
+		return;
+
+	if((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
+		bCtlLdpc = TRUE;
+	else if(	pDM_Odm->SupportICType == ODM_RTL8812 && 
+			IOTPeer == HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP)
+				bCtlLdpc = TRUE;
+
+	if(bCtlLdpc)
+	{
+		if(UndecoratedSmoothedPWDB < (pRA->LdpcThres-5))
+			MgntSet_TX_LDPC(pAdapter, mMacId, TRUE);
+		else if(UndecoratedSmoothedPWDB > pRA->LdpcThres)
+			MgntSet_TX_LDPC(pAdapter, mMacId, FALSE);
+	}	
+
+	if(UndecoratedSmoothedPWDB < (pRA->RtsThres-5))
+		pRA->bLowerRtsRate = TRUE;
+	else if(UndecoratedSmoothedPWDB > pRA->RtsThres)
+		pRA->bLowerRtsRate = FALSE;
+}
+#endif
+
+
+VOID
+odm_RefreshRateAdaptiveMaskMP(
+	IN		PVOID		pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER				pAdapter	 =  pDM_Odm->Adapter;
+	PADAPTER 				pTargetAdapter = NULL;
+	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(pAdapter);
+	PMGNT_INFO				pMgntInfo = GetDefaultMgntInfo(pAdapter);
+
+	if(pAdapter->bDriverStopped)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("<---- odm_RefreshRateAdaptiveMask(): driver is going to unload\n"));
+		return;
+	}
+
+	if(!pHalData->bUseRAMask)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("<---- odm_RefreshRateAdaptiveMask(): driver does not control rate adaptive mask\n"));
+		return;
+	}
+
+	// if default port is connected, update RA table for default port (infrastructure mode only)
+	if(pMgntInfo->mAssoc && (!ACTING_AS_AP(pAdapter)))
+	{	
+		odm_RefreshLdpcRtsMP(pAdapter, pDM_Odm, pMgntInfo->mMacId,  pMgntInfo->IOTPeer, pHalData->UndecoratedSmoothedPWDB);
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("odm_RefreshRateAdaptiveMask(): Infrasture Mode\n"));
+		if( ODM_RAStateCheck(pDM_Odm, pHalData->UndecoratedSmoothedPWDB, pMgntInfo->bSetTXPowerTrainingByOid, &pMgntInfo->Ratr_State) )
+		{
+			ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target AP addr : "), pMgntInfo->Bssid);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pHalData->UndecoratedSmoothedPWDB, pMgntInfo->Ratr_State));
+			pAdapter->HalFunc.UpdateHalRAMaskHandler(pAdapter, pMgntInfo->mMacId, NULL, pMgntInfo->Ratr_State);
+		}
+		else if(pDM_Odm->bChangeState)
+		{
+			ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target AP addr : "), pMgntInfo->Bssid);
+			ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Change Power Training State, bDisablePowerTraining = %d\n", pDM_Odm->bDisablePowerTraining));
+			pAdapter->HalFunc.UpdateHalRAMaskHandler(pAdapter, pMgntInfo->mMacId, NULL, pMgntInfo->Ratr_State);
+		}
+	}
+
+	//
+	// The following part configure AP/VWifi/IBSS rate adaptive mask.
+	//
+
+	if(pMgntInfo->mIbss) 	// Target: AP/IBSS peer.
+		pTargetAdapter = GetDefaultAdapter(pAdapter);
+	else
+		pTargetAdapter = GetFirstAPAdapter(pAdapter);
+
+	// if extension port (softap) is started, updaet RA table for more than one clients associate
+	if(pTargetAdapter != NULL)
+	{
+		int	i;
+		PRT_WLAN_STA	pEntry;
+
+		for(i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++)
+		{
+			pEntry = AsocEntry_EnumStation(pTargetAdapter, i);
+			if(NULL != pEntry)
+			{
+				if(pEntry->bAssociated)
+				{
+					odm_RefreshLdpcRtsMP(pAdapter, pDM_Odm, pEntry->AssociatedMacId, pEntry->IOTPeer, pEntry->rssi_stat.UndecoratedSmoothedPWDB);
+
+					if(ODM_RAStateCheck(pDM_Odm, pEntry->rssi_stat.UndecoratedSmoothedPWDB, pMgntInfo->bSetTXPowerTrainingByOid, &pEntry->Ratr_State) )
+					{
+						ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target STA addr : "), pEntry->MacAddr);
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pEntry->rssi_stat.UndecoratedSmoothedPWDB, pEntry->Ratr_State));
+						pAdapter->HalFunc.UpdateHalRAMaskHandler(pTargetAdapter, pEntry->AssociatedMacId, pEntry, pEntry->Ratr_State);
+					}
+					else if(pDM_Odm->bChangeState)
+					{
+						ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Change Power Training State, bDisablePowerTraining = %d\n", pDM_Odm->bDisablePowerTraining));
+						pAdapter->HalFunc.UpdateHalRAMaskHandler(pAdapter, pMgntInfo->mMacId, NULL, pMgntInfo->Ratr_State);
+					}
+				}
+			}
+		}
+	}
+
+	if(pMgntInfo->bSetTXPowerTrainingByOid)
+		pMgntInfo->bSetTXPowerTrainingByOid = FALSE;	
+#endif	// #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+}
+
+
+VOID
+odm_RefreshRateAdaptiveMaskCE(
+	IN	PVOID	pDM_VOID	
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	u1Byte	i;
+	PADAPTER	pAdapter	 =  pDM_Odm->Adapter;
+	PODM_RATE_ADAPTIVE		pRA = &pDM_Odm->RateAdaptive;
+
+	if(pAdapter->bDriverStopped)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("<---- odm_RefreshRateAdaptiveMask(): driver is going to unload\n"));
+		return;
+	}
+
+	if(!pDM_Odm->bUseRAMask)
+	{
+		ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("<---- odm_RefreshRateAdaptiveMask(): driver does not control rate adaptive mask\n"));
+		return;
+	}
+
+	//printk("==> %s \n",__FUNCTION__);
+
+	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++){
+		PSTA_INFO_T pstat = pDM_Odm->pODM_StaInfo[i];
+		if(IS_STA_VALID(pstat) ) {
+			if(IS_MCAST( pstat->hwaddr))  //if(psta->mac_id ==1)
+				 continue;
+			if(IS_MCAST( pstat->hwaddr))
+				continue;
+
+			#if((RTL8812A_SUPPORT==1)||(RTL8821A_SUPPORT==1))
+			if((pDM_Odm->SupportICType == ODM_RTL8812)||(pDM_Odm->SupportICType == ODM_RTL8821))
+			{
+				if(pstat->rssi_stat.UndecoratedSmoothedPWDB < pRA->LdpcThres)
+				{
+					pRA->bUseLdpc = TRUE;
+					pRA->bLowerRtsRate = TRUE;
+					if((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
+						Set_RA_LDPC_8812(pstat, TRUE);
+					//DbgPrint("RSSI=%d, bUseLdpc = TRUE\n", pHalData->UndecoratedSmoothedPWDB);
+				}
+				else if(pstat->rssi_stat.UndecoratedSmoothedPWDB > (pRA->LdpcThres-5))
+				{
+					pRA->bUseLdpc = FALSE;
+					pRA->bLowerRtsRate = FALSE;
+					if((pDM_Odm->SupportICType == ODM_RTL8821) && (pDM_Odm->CutVersion == ODM_CUT_A))
+						Set_RA_LDPC_8812(pstat, FALSE);
+					//DbgPrint("RSSI=%d, bUseLdpc = FALSE\n", pHalData->UndecoratedSmoothedPWDB);
+				}
+			}
+			#endif
+
+			if( TRUE == ODM_RAStateCheck(pDM_Odm, pstat->rssi_stat.UndecoratedSmoothedPWDB, FALSE , &pstat->rssi_level) )
+			{
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level));
+				//printk("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level);
+				rtw_hal_update_ra_mask(pstat, pstat->rssi_level);
+			}
+			else if(pDM_Odm->bChangeState)
+			{
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Change Power Training State, bDisablePowerTraining = %d\n", pDM_Odm->bDisablePowerTraining));
+				rtw_hal_update_ra_mask(pstat, pstat->rssi_level);
+			}
+		
+		}
+	}			
+	
+#endif
+}
+
+VOID
+odm_RefreshRateAdaptiveMaskAPADSL(
+	IN	PVOID	pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	struct rtl8192cd_priv *priv = pDM_Odm->priv;
+	struct aid_obj *aidarray;
+	u4Byte i;
+	PSTA_INFO_T pstat;
+
+	if(priv->up_time % 2)
+		return;	
+
+	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		pstat = pDM_Odm->pODM_StaInfo[i];
+
+		if(IS_STA_VALID(pstat) )
+		{			
+#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
+			aidarray = container_of(pstat, struct aid_obj, station);
+			priv = aidarray->priv;
+#endif
+
+			if (!priv->pmib->dot11StationConfigEntry.autoRate) 
+				continue;
+
+			if(ODM_RAStateCheck(pDM_Odm, (s4Byte)pstat->rssi, FALSE, &pstat->rssi_level) ) {
+				ODM_PRINT_ADDR(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("Target STA addr : "), pstat->hwaddr);
+				ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi, pstat->rssi_level));
+
+#if defined(CONFIG_PCI_HCI)
+#ifdef CONFIG_WLAN_HAL
+				if (IS_HAL_CHIP(priv)) {
+#ifdef WDS
+					if(!(pstat->state & WIFI_WDS))//if WDS donot setting
+#endif
+						GET_HAL_INTERFACE(priv)->UpdateHalRAMaskHandler(priv, pstat, pstat->rssi_level);
+				} else
+#endif
+#ifdef CONFIG_RTL_8812_SUPPORT
+				if(GET_CHIP_VER(priv)== VERSION_8812E) {
+					UpdateHalRAMask8812(priv, pstat, 3);
+				} else
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+					add_RATid(priv, pstat);
+#endif
+				} else
+#endif
+				{
+#if defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_92C_SUPPORT)
+					add_update_RATid(priv, pstat);
+#endif
+				}
+#elif defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+				update_STA_RATid(priv, pstat);
+#endif
+			}
+		}
+	}
+#endif
+}
+
+
+// Return Value: BOOLEAN
+// - TRUE: RATRState is changed.
+BOOLEAN 
+ODM_RAStateCheck(
+	IN		PVOID			pDM_VOID,
+	IN		s4Byte			RSSI,
+	IN		BOOLEAN			bForceUpdate,
+	OUT		pu1Byte			pRATRState
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PODM_RATE_ADAPTIVE pRA = &pDM_Odm->RateAdaptive;
+	const u1Byte GoUpGap = 5;
+	u1Byte HighRSSIThreshForRA = pRA->HighRSSIThresh;
+	u1Byte LowRSSIThreshForRA = pRA->LowRSSIThresh;
+	u1Byte RATRState;
+
+	// Threshold Adjustment: 
+	// when RSSI state trends to go up one or two levels, make sure RSSI is high enough.
+	// Here GoUpGap is added to solve the boundary's level alternation issue.
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	u1Byte UltraLowRSSIThreshForRA = pRA->UltraLowRSSIThresh;
+	if(pDM_Odm->SupportICType == ODM_RTL8881A)		
+		LowRSSIThreshForRA = 30;		// for LDPC / BCC switch
+#endif
+
+	switch (*pRATRState)
+	{
+		case DM_RATR_STA_INIT:
+		case DM_RATR_STA_HIGH:
+			break;
+
+		case DM_RATR_STA_MIDDLE:
+			HighRSSIThreshForRA += GoUpGap;
+			break;
+
+		case DM_RATR_STA_LOW:
+			HighRSSIThreshForRA += GoUpGap;
+			LowRSSIThreshForRA += GoUpGap;
+			break;
+			
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+		case DM_RATR_STA_ULTRA_LOW:
+			HighRSSIThreshForRA += GoUpGap;
+			LowRSSIThreshForRA += GoUpGap;
+			UltraLowRSSIThreshForRA += GoUpGap;
+			break;
+#endif
+
+		default: 
+			ODM_RT_ASSERT(pDM_Odm, FALSE, ("wrong rssi level setting %d !", *pRATRState) );
+			break;
+	}
+
+	// Decide RATRState by RSSI.
+	if(RSSI > HighRSSIThreshForRA)
+		RATRState = DM_RATR_STA_HIGH;
+	else if(RSSI > LowRSSIThreshForRA)
+		RATRState = DM_RATR_STA_MIDDLE;
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	else if(RSSI > UltraLowRSSIThreshForRA)
+		RATRState = DM_RATR_STA_LOW;
+	else
+		RATRState = DM_RATR_STA_ULTRA_LOW;
+#else
+	else
+		RATRState = DM_RATR_STA_LOW;
+#endif
+	//printk("==>%s,RATRState:0x%02x ,RSSI:%d \n",__FUNCTION__,RATRState,RSSI);
+
+	if( *pRATRState!=RATRState || bForceUpdate)
+	{
+		ODM_RT_TRACE( pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI Level %d -> %d\n", *pRATRState, RATRState) );
+		*pRATRState = RATRState;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+VOID
+odm_RefreshBasicRateMask(
+	IN	PVOID	pDM_VOID
+	)
+{
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PADAPTER		Adapter	 =  pDM_Odm->Adapter;
+	static u1Byte		Stage = 0;
+	u1Byte			CurStage = 0;
+	OCTET_STRING 	osRateSet;
+	PMGNT_INFO		pMgntInfo = GetDefaultMgntInfo(Adapter);
+	u1Byte 			RateSet[5] = {MGN_1M, MGN_2M, MGN_5_5M, MGN_11M, MGN_6M};
+
+	if(pDM_Odm->SupportICType != ODM_RTL8812 && pDM_Odm->SupportICType != ODM_RTL8821 )
+		return;
+
+	if(pDM_Odm->bLinked == FALSE)	// unlink Default port information
+		CurStage = 0;	
+	else if(pDM_Odm->RSSI_Min < 40)	// link RSSI  < 40%
+		CurStage = 1;
+	else if(pDM_Odm->RSSI_Min > 45)	// link RSSI > 45%
+		CurStage = 3;	
+	else
+		CurStage = 2;					// link  25% <= RSSI <= 30%
+
+	if(CurStage != Stage)
+	{
+		if(CurStage == 1)
+		{
+			FillOctetString(osRateSet, RateSet, 5);
+			FilterSupportRate(pMgntInfo->mBrates, &osRateSet, FALSE);
+			Adapter->HalFunc.SetHwRegHandler(Adapter, HW_VAR_BASIC_RATE, (pu1Byte)&osRateSet);
+		}
+		else if(CurStage == 3 && (Stage == 1 || Stage == 2))
+		{
+			Adapter->HalFunc.SetHwRegHandler( Adapter, HW_VAR_BASIC_RATE, (pu1Byte)(&pMgntInfo->mBrates) );
+		}
+	}
+	
+	Stage = CurStage;
+#endif
+}
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+ODM_DynamicARFBSelect(
+	IN		PVOID		pDM_VOID,
+	IN 		u1Byte			rate,
+	IN  		BOOLEAN			Collision_State	
+)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	pRA_T			pRA_Table = &pDM_Odm->DM_RA_Table;
+
+	if(pDM_Odm->SupportICType != ODM_RTL8192E)
+		return;
+
+	if(Collision_State == pRA_Table->PT_collision_pre)
+		return;
+
+	if (rate >= DESC_RATEMCS8  && rate <= DESC_RATEMCS12){
+		if (Collision_State == 1){
+			if(rate == DESC_RATEMCS12){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07060501);	
+			}
+			else if(rate == DESC_RATEMCS11){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07070605);	
+			}
+			else if(rate == DESC_RATEMCS10){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08080706);	
+			}
+			else if(rate == DESC_RATEMCS9){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08080707);	
+			}
+			else{
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x0);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09090808);	
+			}
+		}
+		else{   // Collision_State == 0
+			if(rate == DESC_RATEMCS12){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x05010000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09080706);	
+			}
+			else if(rate == DESC_RATEMCS11){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x06050000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09080807);	
+			}
+			else if(rate == DESC_RATEMCS10){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x07060000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x0a090908);	
+			}
+			else if(rate == DESC_RATEMCS9){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x07070000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x0a090808);	
+			}
+			else{
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x08080000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x0b0a0909);	
+			}
+		}
+	}
+	else{  // MCS13~MCS15,  1SS, G-mode
+		if (Collision_State == 1){
+			if(rate == DESC_RATEMCS15){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x05040302);	
+			}
+			else if(rate == DESC_RATEMCS14){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x06050302);	
+			}
+			else if(rate == DESC_RATEMCS13){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07060502);	
+			}
+			else{
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x00000000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x06050402);	
+			}
+		}
+		else{   // Collision_State == 0
+  			if(rate == DESC_RATEMCS15){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x03020000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x07060504);	
+			}
+			else if(rate == DESC_RATEMCS14){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x03020000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08070605);	
+			}
+			else if(rate == DESC_RATEMCS13){
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x05020000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x09080706);	
+			}
+			else{
+
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E, 0x04020000);
+				ODM_Write4Byte(pDM_Odm, REG_DARFRC_8192E+4, 0x08070605);	
+			}
+
+
+		}
+
+	}	
+	 pRA_Table->PT_collision_pre = Collision_State;	
+}
+
+VOID
+ODM_RateAdaptiveStateApInit(	
+	IN	PVOID		PADAPTER_VOID,
+	IN	PRT_WLAN_STA  	pEntry
+	)
+{
+	PADAPTER		Adapter = (PADAPTER)PADAPTER_VOID;
+	pEntry->Ratr_State = DM_RATR_STA_INIT;
+}
+#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+u4Byte 
+ODM_Get_Rate_Bitmap(
+	IN	PVOID		pDM_VOID,	
+	IN	u4Byte		macid,
+	IN	u4Byte 		ra_mask,	
+	IN	u1Byte 		rssi_level
+	)
+{
+	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PSTA_INFO_T   	pEntry;
+	u4Byte 	rate_bitmap = 0;
+	u1Byte 	WirelessMode;
+	//u1Byte 	WirelessMode =*(pDM_Odm->pWirelessMode);
+	
+	
+	pEntry = pDM_Odm->pODM_StaInfo[macid];
+	if(!IS_STA_VALID(pEntry))
+		return ra_mask;
+
+	WirelessMode = pEntry->wireless_mode;
+	
+	switch(WirelessMode)
+	{
+		case ODM_WM_B:
+			if(ra_mask & 0x0000000c)		//11M or 5.5M enable				
+				rate_bitmap = 0x0000000d;
+			else
+				rate_bitmap = 0x0000000f;
+			break;
+			
+		case (ODM_WM_G):
+		case (ODM_WM_A):
+			if(rssi_level == DM_RATR_STA_HIGH)
+				rate_bitmap = 0x00000f00;
+			else
+				rate_bitmap = 0x00000ff0;
+			break;
+			
+		case (ODM_WM_B|ODM_WM_G):
+			if(rssi_level == DM_RATR_STA_HIGH)
+				rate_bitmap = 0x00000f00;
+			else if(rssi_level == DM_RATR_STA_MIDDLE)
+				rate_bitmap = 0x00000ff0;
+			else
+				rate_bitmap = 0x00000ff5;
+			break;		
+
+		case (ODM_WM_B|ODM_WM_G|ODM_WM_N24G)	:
+		case (ODM_WM_B|ODM_WM_N24G)	:
+		case (ODM_WM_G|ODM_WM_N24G)	:
+		case (ODM_WM_A|ODM_WM_N5G)	:
+			{					
+				if (	pDM_Odm->RFType == ODM_1T2R ||pDM_Odm->RFType == ODM_1T1R)
+				{
+					if(rssi_level == DM_RATR_STA_HIGH)
+					{
+						rate_bitmap = 0x000f0000;
+					}
+					else if(rssi_level == DM_RATR_STA_MIDDLE)
+					{
+						rate_bitmap = 0x000ff000;
+					}
+					else{
+						if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
+							rate_bitmap = 0x000ff015;
+						else
+							rate_bitmap = 0x000ff005;
+					}				
+				}
+				else
+				{
+					if(rssi_level == DM_RATR_STA_HIGH)
+					{		
+						rate_bitmap = 0x0f8f0000;
+					}
+					else if(rssi_level == DM_RATR_STA_MIDDLE)
+					{
+						rate_bitmap = 0x0f8ff000;
+					}
+					else
+					{
+						if (*(pDM_Odm->pBandWidth) == ODM_BW40M)
+							rate_bitmap = 0x0f8ff015;
+						else
+							rate_bitmap = 0x0f8ff005;
+					}					
+				}
+			}
+			break;
+
+		case (ODM_WM_AC|ODM_WM_G):
+			if(rssi_level == 1)
+				rate_bitmap = 0xfc3f0000;
+			else if(rssi_level == 2)
+				rate_bitmap = 0xfffff000;
+			else
+				rate_bitmap = 0xffffffff;
+			break;
+
+		case (ODM_WM_AC|ODM_WM_A):
+
+			if (pDM_Odm->RFType == RF_1T1R)
+			{
+				if(rssi_level == 1)				// add by Gary for ac-series
+					rate_bitmap = 0x003f8000;
+				else if (rssi_level == 2)
+					rate_bitmap = 0x003ff000;
+				else
+					rate_bitmap = 0x003ff010;
+			}
+			else
+			{
+				if(rssi_level == 1)				// add by Gary for ac-series
+					rate_bitmap = 0xfe3f8000;       // VHT 2SS MCS3~9
+				else if (rssi_level == 2)
+					rate_bitmap = 0xfffff000;       // VHT 2SS MCS0~9
+				else
+					rate_bitmap = 0xfffff010;       // All
+			}
+			break;
+			
+		default:
+			if(pDM_Odm->RFType == RF_1T2R)
+				rate_bitmap = 0x000fffff;
+			else
+				rate_bitmap = 0x0fffffff;
+			break;	
+
+	}
+
+	//printk("%s ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n",__FUNCTION__,rssi_level,WirelessMode,rate_bitmap);
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, (" ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n",rssi_level,WirelessMode,rate_bitmap));
+
+	return (ra_mask&rate_bitmap);
+	
+}	
+
+#endif //#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
\ No newline at end of file
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RaInfo.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RaInfo.h
new file mode 100644
index 000000000000..b9625de98dd0
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RaInfo.h
@@ -0,0 +1,167 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__PHYDMRAINFO_H__
+#define    __PHYDMRAINFO_H__
+
+#define RAINFO_VERSION	"1.0"
+
+#define AP_InitRateAdaptiveState	ODM_RateAdaptiveStateApInit
+
+#define		DM_RATR_STA_INIT			0
+#define		DM_RATR_STA_HIGH			1
+#define 		DM_RATR_STA_MIDDLE		2
+#define 		DM_RATR_STA_LOW			3
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+#define		DM_RATR_STA_ULTRA_LOW	4
+#endif
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+typedef struct _Rate_Adaptive_Table_{
+	u1Byte		firstconnect;
+	#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
+	BOOLEAN		PT_collision_pre;
+	#endif
+}RA_T, *pRA_T;
+#endif
+
+typedef struct _ODM_RATE_ADAPTIVE
+{
+	u1Byte				Type;				// DM_Type_ByFW/DM_Type_ByDriver
+	u1Byte				HighRSSIThresh;		// if RSSI > HighRSSIThresh	=> RATRState is DM_RATR_STA_HIGH
+	u1Byte				LowRSSIThresh;		// if RSSI <= LowRSSIThresh	=> RATRState is DM_RATR_STA_LOW
+	u1Byte				RATRState;			// Current RSSI level, DM_RATR_STA_HIGH/DM_RATR_STA_MIDDLE/DM_RATR_STA_LOW
+
+	#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	u1Byte				LdpcThres;			// if RSSI > LdpcThres => switch from LPDC to BCC
+	BOOLEAN				bLowerRtsRate;
+	#endif
+
+	#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	u1Byte				RtsThres;
+	#elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	BOOLEAN				bUseLdpc;
+	#else
+	u1Byte				UltraLowRSSIThresh;
+	u4Byte				LastRATR;			// RATR Register Content
+	#endif
+
+} ODM_RATE_ADAPTIVE, *PODM_RATE_ADAPTIVE;
+
+VOID
+odm_RSSIMonitorInit(
+	IN		PVOID		pDM_VOID
+	);
+
+VOID
+odm_RSSIMonitorCheck(
+	IN	 	PVOID	 	 pDM_VOID
+	);
+
+#if(DM_ODM_SUPPORT_TYPE==ODM_WIN)
+VOID
+odm_RSSIDumpToRegister(
+	IN	PVOID	pDM_VOID
+	);
+#endif
+
+VOID
+odm_RSSIMonitorCheckMP(
+	IN		PVOID	 	pDM_VOID
+	);
+
+VOID 
+odm_RSSIMonitorCheckCE(
+	IN		PVOID		pDM_VOID
+	);
+
+VOID 
+odm_RSSIMonitorCheckAP(
+	IN		PVOID		 pDM_VOID
+	);
+
+
+VOID
+odm_RateAdaptiveMaskInit(
+	IN	PVOID	pDM_VOID	
+	);
+
+VOID
+odm_RefreshRateAdaptiveMask(
+	IN	PVOID	pDM_VOID
+	);
+
+VOID
+odm_RefreshRateAdaptiveMaskMP(
+	IN	PVOID	pDM_VOID
+	);
+
+VOID
+odm_RefreshRateAdaptiveMaskCE(
+	IN	PVOID	pDM_VOID	
+	);
+
+VOID
+odm_RefreshRateAdaptiveMaskAPADSL(
+	IN	PVOID	pDM_VOID
+	);
+
+BOOLEAN 
+ODM_RAStateCheck(
+	IN		PVOID			pDM_VOID,
+	IN		s4Byte			RSSI,
+	IN		BOOLEAN			bForceUpdate,
+	OUT		pu1Byte			pRATRState
+	);
+	
+VOID
+odm_RefreshBasicRateMask(
+	IN	PVOID	pDM_VOID
+	);
+
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+VOID
+ODM_DynamicARFBSelect(
+	IN		PVOID			pDM_VOID,
+	IN 		u1Byte			rate,
+	IN  	BOOLEAN			Collision_State	
+	);
+	
+VOID
+ODM_RateAdaptiveStateApInit(	
+	IN	PVOID		PADAPTER_VOID,
+	IN	PRT_WLAN_STA  	pEntry
+	);
+#endif
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+u4Byte 
+ODM_Get_Rate_Bitmap(
+	IN	PVOID		pDM_VOID,	
+	IN	u4Byte		macid,
+	IN	u4Byte 		ra_mask,	
+	IN	u1Byte 		rssi_level
+	);
+#endif
+
+#endif //#ifndef	__ODMRAINFO_H__
+
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_RegDefine11AC.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RegDefine11AC.h
similarity index 68%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_RegDefine11AC.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RegDefine11AC.h
index 1193653a5272..e7e54184f099 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_RegDefine11AC.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RegDefine11AC.h
@@ -29,19 +29,37 @@
 //PAGE 8
 #define	ODM_REG_CCK_RPT_FORMAT_11AC	0x804
 #define	ODM_REG_BB_RX_PATH_11AC			0x808
+#define	ODM_REG_BB_ATC_11AC				0x860
+#define	ODM_REG_DBG_RPT_11AC				0x8fc
 //PAGE 9
 #define	ODM_REG_OFDM_FA_RST_11AC		0x9A4
+#define	ODM_REG_NHM_TIMER_11AC			0x990
+#define	ODM_REG_NHM_TH9_TH10_11AC		0x994
+#define	ODM_REG_NHM_TH3_TO_TH0_11AC	0x998
+#define	ODM_REG_NHM_TH7_TO_TH4_11AC	0x99c
+#define	ODM_REG_NHM_TH8_11AC			0x9a0
+#define	ODM_REG_NHM_9E8_11AC			0x9e8
 //PAGE A
 #define	ODM_REG_CCK_CCA_11AC			0xA0A
 #define	ODM_REG_CCK_FA_RST_11AC			0xA2C
 #define	ODM_REG_CCK_FA_11AC				0xA5C
+//PAGE B
+#define	ODM_REG_RST_RPT_11AC				0xB58
 //PAGE C
+#define	ODM_REG_TRMUX_11AC				0xC08
 #define	ODM_REG_IGI_A_11AC				0xC50
 //PAGE E
 #define	ODM_REG_IGI_B_11AC				0xE50
+#define	ODM_REG_TRMUX_11AC_B			0xE08
 //PAGE F
+#define	ODM_REG_CCK_CCA_CNT_11AC		0xF08
 #define	ODM_REG_OFDM_FA_11AC			0xF48
-
+#define	ODM_REG_RPT_11AC					0xfa0
+#define	ODM_REG_NHM_CNT_11AC			0xfa8
+//PAGE 18
+#define	ODM_REG_IGI_C_11AC				0x1850
+//PAGE 1A
+#define	ODM_REG_IGI_D_11AC				0x1A50
 
 //2 MAC REG LIST
 #define	ODM_REG_RESP_TX_11AC				0x6D8
@@ -52,6 +70,7 @@
 #define	ODM_BIT_IGI_11AC					0xFFFFFFFF
 #define	ODM_BIT_CCK_RPT_FORMAT_11AC		BIT16
 #define	ODM_BIT_BB_RX_PATH_11AC			0xF
+#define	ODM_BIT_BB_ATC_11AC				BIT14
 
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_RegDefine11N.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RegDefine11N.h
similarity index 84%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_RegDefine11N.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RegDefine11N.h
index b6236092fb5a..9d07509f6feb 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_RegDefine11N.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_RegDefine11N.h
@@ -44,20 +44,28 @@
 #define	ODM_REG_RF_PIN_11N				0x804
 #define	ODM_REG_PSD_CTRL_11N				0x808
 #define	ODM_REG_TX_ANT_CTRL_11N			0x80C
-#define	ODM_REG_BB_PWR_SAV5_11N			0x818
+#define	ODM_REG_BB_PWR_SAV5_11N		0x818
 #define	ODM_REG_CCK_RPT_FORMAT_11N		0x824
+#define	ODM_REG_CCK_RPT_FORMAT_11N_B	0x82C
 #define	ODM_REG_RX_DEFUALT_A_11N		0x858
 #define	ODM_REG_RX_DEFUALT_B_11N		0x85A
-#define	ODM_REG_BB_PWR_SAV3_11N			0x85C
+#define	ODM_REG_BB_PWR_SAV3_11N		0x85C
 #define	ODM_REG_ANTSEL_CTRL_11N			0x860
 #define	ODM_REG_RX_ANT_CTRL_11N			0x864
 #define	ODM_REG_PIN_CTRL_11N				0x870
-#define	ODM_REG_BB_PWR_SAV1_11N			0x874
+#define	ODM_REG_BB_PWR_SAV1_11N		0x874
 #define	ODM_REG_ANTSEL_PATH_11N			0x878
 #define	ODM_REG_BB_3WIRE_11N			0x88C
 #define	ODM_REG_SC_CNT_11N				0x8C4
-#define	ODM_REG_PSD_DATA_11N			0x8B4
+#define	ODM_REG_PSD_DATA_11N				0x8B4
+#define	ODM_REG_PSD_DATA_11N				0x8B4
+#define	ODM_REG_NHM_TIMER_11N			0x894
+#define	ODM_REG_NHM_TH9_TH10_11N		0x890
+#define	ODM_REG_NHM_TH3_TO_TH0_11N		0x898
+#define	ODM_REG_NHM_TH7_TO_TH4_11N		0x89c
+#define	ODM_REG_NHM_CNT_11N				0x8d8
 //PAGE 9
+#define	ODM_REG_DBG_RPT_11N				0x908
 #define	ODM_REG_ANT_MAPPING1_11N		0x914
 #define	ODM_REG_ANT_MAPPING2_11N		0x918
 //PAGE A
@@ -78,7 +86,7 @@
 #define	ODM_REG_CCK_FA_MSB_11N			0xA58
 #define	ODM_REG_CCK_FA_LSB_11N			0xA5C
 #define	ODM_REG_CCK_CCA_CNT_11N			0xA60
-#define	ODM_REG_BB_PWR_SAV4_11N			0xA74
+#define	ODM_REG_BB_PWR_SAV4_11N		0xA74
 //PAGE B
 #define	ODM_REG_LNA_SWITCH_11N			0xB2C
 #define	ODM_REG_PATH_SWITCH_11N			0xB30
@@ -90,9 +98,9 @@
 #define	ODM_REG_BB_RX_PATH_11N			0xC04
 #define	ODM_REG_TRMUX_11N				0xC08
 #define	ODM_REG_OFDM_FA_RSTC_11N		0xC0C
-#define	ODM_REG_RXIQI_MATRIX_11N		0xC14
+#define	ODM_REG_RXIQI_MATRIX_11N			0xC14
 #define	ODM_REG_TXIQK_MATRIX_LSB1_11N	0xC4C
-#define	ODM_REG_IGI_A_11N				0xC50
+#define	ODM_REG_IGI_A_11N					0xC50
 #define	ODM_REG_ANTDIV_PARA2_11N		0xC54
 #define	ODM_REG_IGI_B_11N					0xC58
 #define	ODM_REG_ANTDIV_PARA3_11N		0xC5C
@@ -108,9 +116,11 @@
 #define	ODM_REG_OFDM_FA_TYPE1_11N		0xCF0
 //PAGE D
 #define	ODM_REG_OFDM_FA_RSTD_11N		0xD00
+#define	ODM_REG_BB_ATC_11N				0xD2C
 #define	ODM_REG_OFDM_FA_TYPE2_11N		0xDA0
 #define	ODM_REG_OFDM_FA_TYPE3_11N		0xDA4
 #define	ODM_REG_OFDM_FA_TYPE4_11N		0xDA8
+#define	ODM_REG_RPT_11N					0xDF4
 //PAGE E
 #define	ODM_REG_TXAGC_A_6_18_11N		0xE00
 #define	ODM_REG_TXAGC_A_24_54_11N		0xE04
@@ -143,12 +153,8 @@
 #define	ODM_REG_STANDBY_11N				0xEDC
 #define	ODM_REG_SLEEP_11N				0xEE0
 #define	ODM_REG_PMPD_ANAEN_11N			0xEEC
-
-
-
-
-
-
+#define	ODM_REG_IGI_C_11N					0xF84
+#define	ODM_REG_IGI_D_11N					0xF88
 
 //2 MAC REG LIST
 #define	ODM_REG_BB_RST_11N				0x02
@@ -161,14 +167,15 @@
 #define	ODM_REG_EDCA_BK_11N				0x50C
 #define	ODM_REG_TXPAUSE_11N				0x522
 #define	ODM_REG_RESP_TX_11N				0x6D8
-#define	ODM_REG_ANT_TRAIN_PARA1_11N	0x7b0
-#define	ODM_REG_ANT_TRAIN_PARA2_11N	0x7b4
+#define	ODM_REG_ANT_TRAIN_PARA1_11N		0x7b0
+#define	ODM_REG_ANT_TRAIN_PARA2_11N		0x7b4
 
 
 //DIG Related
 #define	ODM_BIT_IGI_11N					0x0000007F
 #define	ODM_BIT_CCK_RPT_FORMAT_11N		BIT9
 #define	ODM_BIT_BB_RX_PATH_11N			0xF
+#define	ODM_BIT_BB_ATC_11N				BIT11
 
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_debug.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_debug.c
new file mode 100644
index 000000000000..7e514db3b609
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_debug.c
@@ -0,0 +1,873 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//============================================================
+// include files
+//============================================================
+
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
+
+
+VOID 
+PHYDM_InitDebugSetting(
+	IN		PDM_ODM_T		pDM_Odm
+	)
+{
+pDM_Odm->DebugLevel				= 	ODM_DBG_TRACE;
+
+pDM_Odm->DebugComponents			= 
+\
+#if DBG
+//BB Functions
+//									ODM_COMP_DIG					|
+//									ODM_COMP_RA_MASK				|
+//									ODM_COMP_DYNAMIC_TXPWR		|
+//									ODM_COMP_FA_CNT				|
+//									ODM_COMP_RSSI_MONITOR			|
+//									ODM_COMP_CCK_PD				|
+//									ODM_COMP_ANT_DIV				|
+//									ODM_COMP_PWR_SAVE				|
+//									ODM_COMP_PWR_TRAIN			|
+//									ODM_COMP_RATE_ADAPTIVE		|
+//									ODM_COMP_PATH_DIV				|
+//									ODM_COMP_DYNAMIC_PRICCA		|
+//									ODM_COMP_RXHP					|
+//									ODM_COMP_MP 					|
+//									ODM_COMP_CFO_TRACKING		|
+//									ODM_COMP_ACS					|
+//									PHYDM_COMP_ADAPTIVITY			|
+
+//MAC Functions
+//									ODM_COMP_EDCA_TURBO			|
+//									ODM_COMP_EARLY_MODE			|
+//RF Functions
+//									ODM_COMP_TX_PWR_TRACK		|
+//									ODM_COMP_RX_GAIN_TRACK		|
+//									ODM_COMP_CALIBRATION			|
+//Common
+//									ODM_COMP_COMMON				|
+//									ODM_COMP_INIT					|
+//									ODM_COMP_PSD					|
+#endif
+									0;
+}
+
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+
+static u1Byte	BbDbgBuf[BB_TMP_BUF_SIZE];
+VOID
+phydm_BB_Debug_Info(IN PDM_ODM_T pDM_Odm)
+{
+
+	u1Byte	RX_HT_BW, RX_VHT_BW, RXSC, RX_HT, RX_BW;
+	static u1Byte vRX_BW ;
+	u4Byte	value32, value32_1, value32_2, value32_3;
+	s4Byte	SFO_A, SFO_B, SFO_C, SFO_D;
+	s4Byte	LFO_A, LFO_B, LFO_C, LFO_D;
+	static u1Byte	MCSS,Tail,Parity,rsv,vrsv,idx,smooth,htsound,agg,stbc,vstbc,fec,fecext,sgi,sgiext,htltf,vgid,vNsts,vtxops,vrsv2,vbrsv,bf,vbcrc;
+	static u2Byte	HLength,htcrc8,Length;
+	static u2Byte vpaid;
+	static u2Byte	vLength,vhtcrc8,vMCSS,vTail,vbTail;
+	static u1Byte	HMCSS,HRX_BW;
+
+	
+	u1Byte    pwDB;
+	s1Byte    RXEVM_0, RXEVM_1, RXEVM_2 ;
+	u1Byte    RF_gain_pathA, RF_gain_pathB, RF_gain_pathC, RF_gain_pathD;
+	u1Byte    RX_SNR_pathA, RX_SNR_pathB, RX_SNR_pathC, RX_SNR_pathD;
+       s4Byte    sig_power;
+       const char *RXHT_table[] = {"legacy", "HT", "VHT"};
+	const char *BW_table[] = {"20M", "40M", "80M"};
+	const char *RXSC_table[] = {"duplicate/full bw", "usc20-1", "lsc20-1", "usc20-2", "lsc20-2",  "usc40", "lsc40"};
+
+	const char *L_rate[]={"6M","9M","12M","18M","24M","36M","48M","54M"}; 
+
+	
+	/*
+	const double evm_comp_20M = 0.579919469776867; //10*log10(64.0/56.0)
+	const double evm_comp_40M = 0.503051183113957; //10*log10(128.0/114.0)
+	const double evm_comp_80M = 0.244245993314183; //10*log10(256.0/242.0)
+	const double evm_comp_160M = 0.244245993314183; //10*log10(512.0/484.0)
+       */
+
+	if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
+		return;
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s \n", "BB Report Info");
+	DCMD_Printf(BbDbgBuf);
+
+       //BW & Mode Detection
+	///////////////////////////////////////////////////////			
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf80 ,bMaskDWord);
+	value32_2 =value32; 
+	RX_HT_BW = (u1Byte)(value32&0x1)	;
+	RX_VHT_BW = (u1Byte)((value32>>1)&0x3);
+	RXSC = (u1Byte)(value32&0x78);
+	value32_1= (value32&0x180)>>7;
+	RX_HT = (u1Byte)(value32_1);
+	/*		
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "F80", value32_2);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "RX_HT_BW", RX_HT_BW);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "RX_VHT_BW", RX_VHT_BW);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "RX_SC", RXSC);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "RX_HT", RX_HT);
+	DCMD_Printf(BbDbgBuf);
+	*/
+	
+	//rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  RX_HT:%s ", RXHT_table[RX_HT]);
+	//DCMD_Printf(BbDbgBuf);
+	RX_BW = 0;
+
+	if(RX_HT == 2)
+	{
+		rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  Mode: VHT Mode");
+		DCMD_Printf(BbDbgBuf);
+		if(RX_VHT_BW==0)
+		{
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=20M");
+			DCMD_Printf(BbDbgBuf);
+		}	
+		else if(RX_VHT_BW==1)
+		{
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=40M");
+			DCMD_Printf(BbDbgBuf);
+		}
+		else
+		{
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=80M");
+			DCMD_Printf(BbDbgBuf);
+		}
+		RX_BW = RX_VHT_BW;
+	}
+	else if(RX_HT == 1)
+	{
+		rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  Mode: HT Mode");
+		DCMD_Printf(BbDbgBuf);
+		if(RX_HT_BW==0)
+		{
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=20M");
+			DCMD_Printf(BbDbgBuf);
+		}	
+		else if(RX_HT_BW==1)
+		{
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "     BW=40M");
+			DCMD_Printf(BbDbgBuf);
+		}
+		RX_BW = RX_HT_BW;
+	}
+	else
+	{
+		rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  Mode: Legeacy Mode");
+		DCMD_Printf(BbDbgBuf);
+	}
+
+	if(RX_HT !=0)
+	{
+		if(RXSC==0)
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  duplicate/full bw");
+		else if(RXSC==1)
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  usc20-1");
+		else if(RXSC==2)
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  lsc20-1");
+		else if(RXSC==3)
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  usc20-2");
+		else if(RXSC==4)
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  lsc20-2");
+		else if(RXSC==9)
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  usc40");
+		else if(RXSC==10)
+			rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  lsc40");
+		DCMD_Printf(BbDbgBuf);
+	}
+	/*
+	if(RX_HT == 2){
+		rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "  BW:%s", BW_table[RX_VHT_BW]);
+		RX_BW = RX_VHT_BW;
+		}
+	else if(RX_HT == 1){		
+		rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "  BW:%s", BW_table[RX_HT_BW]);
+		RX_BW = RX_HT_BW;
+		}
+	else
+		rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE,  "");
+	
+	DCMD_Printf(BbDbgBuf);	
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "  RXSC:%s", RXSC_table[RXSC]);		
+	DCMD_Printf(BbDbgBuf);
+	*/
+	///////////////////////////////////////////////////////	
+	
+//	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "dB Conversion: 10log(65)", ODM_PWdB_Conversion(65,10,0));
+//	DCMD_Printf(BbDbgBuf);
+
+        // RX signal power and AGC related info
+        ///////////////////////////////////////////////////////
+       value32 = ODM_GetBBReg(pDM_Odm, 0xF90 ,bMaskDWord);
+	pwDB = (u1Byte) ((value32 & bMaskByte1) >> 8);
+	pwDB=pwDB>>1;
+	sig_power = -110+pwDB;
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "OFDM RX Signal Power(dB)", sig_power);
+	DCMD_Printf(BbDbgBuf);
+
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd14 ,bMaskDWord);
+	RX_SNR_pathA = (u1Byte)(value32&0xFF)>>1;
+	RF_gain_pathA = (s1Byte) ((value32 & bMaskByte1) >> 8);
+	RF_gain_pathA *=2;
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd54 ,bMaskDWord);
+	RX_SNR_pathB = (u1Byte)(value32&0xFF)>>1;
+	RF_gain_pathB = (s1Byte) ((value32 & bMaskByte1) >> 8);
+	RF_gain_pathB *=2;
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd94 ,bMaskDWord);
+	RX_SNR_pathC = (u1Byte)(value32&0xFF)>>1;
+	RF_gain_pathC = (s1Byte) ((value32 & bMaskByte1) >> 8);
+	RF_gain_pathC *=2;
+	value32 = ODM_GetBBReg(pDM_Odm, 0xdd4 ,bMaskDWord);
+	RX_SNR_pathD = (u1Byte)(value32&0xFF)>>1;
+	RF_gain_pathD = (s1Byte) ((value32 & bMaskByte1) >> 8);
+	RF_gain_pathD *=2;
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "OFDM RX RF Gain(A/B/C/D)", RF_gain_pathA, RF_gain_pathA, RF_gain_pathC, RF_gain_pathD);
+	DCMD_Printf(BbDbgBuf);	
+        ///////////////////////////////////////////////////////
+
+	// RX Counter related info
+        ///////////////////////////////////////////////////////	
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF08 ,bMaskDWord);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "OFDM CCA Counter", ((value32&0xFFFF0000)>>16));
+	DCMD_Printf(BbDbgBuf);
+	
+	value32 = ODM_GetBBReg(pDM_Odm, 0xFD0 ,bMaskDWord);
+       rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "OFDM SBD Fail Counter", value32&0xFFFF);
+	DCMD_Printf(BbDbgBuf);
+	
+	value32 = ODM_GetBBReg(pDM_Odm, 0xFC4 ,bMaskDWord);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "VHT SIGA/SIGB CRC8 Fail Counter", value32&0xFFFF, ((value32&0xFFFF0000)>>16));
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xFCC ,bMaskDWord);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "CCK CCA Counter", value32&0xFFFF);
+	DCMD_Printf(BbDbgBuf);
+	
+	value32 = ODM_GetBBReg(pDM_Odm, 0xFBC ,bMaskDWord);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "LSIG (\"Parity Fail\"/\"Rate Illegal\") Counter", value32&0xFFFF, ((value32&0xFFFF0000)>>16));
+	DCMD_Printf(BbDbgBuf);
+
+	value32_1 = ODM_GetBBReg(pDM_Odm, 0xFC8 ,bMaskDWord);
+	value32_2 = ODM_GetBBReg(pDM_Odm, 0xFC0 ,bMaskDWord);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "HT/VHT MCS NOT SUPPORT counter", ((value32_2&0xFFFF0000)>>16), value32_1&0xFFFF);
+	DCMD_Printf(BbDbgBuf);
+	///////////////////////////////////////////////////////
+	
+	// PostFFT related info
+	///////////////////////////////////////////////////////
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF8c ,bMaskDWord);
+	RXEVM_0 = (s1Byte) ((value32 & bMaskByte2) >> 16);
+	RXEVM_0 /=2;
+	if(RXEVM_0 < -63)
+		RXEVM_0=0;
+	
+	DCMD_Printf(BbDbgBuf);
+	RXEVM_1 = (s1Byte) ((value32 & bMaskByte3) >> 24);
+	RXEVM_1 /=2;
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF88 ,bMaskDWord);
+	RXEVM_2 = (s1Byte) ((value32 & bMaskByte2) >> 16);
+	RXEVM_2 /=2;
+
+	if(RXEVM_1 < -63)
+		RXEVM_1=0;
+	if(RXEVM_2 < -63)
+		RXEVM_2=0;
+	
+	/*
+	if(RX_BW == 0){
+		RXEVM_0 -= evm_comp_20M;
+		RXEVM_1 -= evm_comp_20M;
+		RXEVM_2 -= evm_comp_20M;		
+		}
+	else if(RX_BW == 1){
+		RXEVM_0 -= evm_comp_40M;
+		RXEVM_1 -= evm_comp_40M;
+		RXEVM_2 -= evm_comp_40M;		
+		}
+	else if (RX_BW == 2){
+		RXEVM_0 -= evm_comp_80M;
+		RXEVM_1 -= evm_comp_80M;
+		RXEVM_2 -= evm_comp_80M;		
+		}
+		*/
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d", "RXEVM (1ss/2ss/3ss)", RXEVM_0, RXEVM_1, RXEVM_2);
+	DCMD_Printf(BbDbgBuf);
+
+//	value32 = ODM_GetBBReg(pDM_Odm, 0xD14 ,bMaskDWord);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d / %d / %d", "RXSNR(A/B/C/D, dB)", RX_SNR_pathA, RX_SNR_pathB, RX_SNR_pathC, RX_SNR_pathD);
+	DCMD_Printf(BbDbgBuf);
+//	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "B_RXSNR", (value32&0xFF00)>>9);
+//	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xF8C ,bMaskDWord);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d", "CSI_1st /CSI_2nd", value32&0xFFFF, ((value32&0xFFFF0000)>>16));
+	DCMD_Printf(BbDbgBuf);
+	///////////////////////////////////////////////////////			
+	
+	//BW & Mode Detection
+
+	//Reset Page F Counter
+	ODM_SetBBReg(pDM_Odm, 0xB58 ,BIT0, 1);
+	ODM_SetBBReg(pDM_Odm, 0xB58 ,BIT0, 0);
+	
+	//CFO Report Info
+	//Short CFO
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd0c ,bMaskDWord);
+	value32_1 = ODM_GetBBReg(pDM_Odm, 0xd4c ,bMaskDWord);
+	value32_2 = ODM_GetBBReg(pDM_Odm, 0xd8c ,bMaskDWord);
+	value32_3 = ODM_GetBBReg(pDM_Odm, 0xdcc ,bMaskDWord);
+
+	SFO_A=(s4Byte)(value32&bMask12Bits);
+	SFO_B=(s4Byte)(value32_1&bMask12Bits);
+	SFO_C=(s4Byte)(value32_2&bMask12Bits);
+	SFO_D=(s4Byte)(value32_3&bMask12Bits);
+
+	LFO_A=(s4Byte)(value32>>16);
+	LFO_B=(s4Byte)(value32_1>>16);
+	LFO_C=(s4Byte)(value32_2>>16);
+	LFO_D=(s4Byte)(value32_3>>16);
+
+	//SFO 2's to dec
+	if(SFO_A >2047)
+	{
+		SFO_A=SFO_A-4096;
+	}
+	SFO_A=(SFO_A*312500)/2048;
+	
+	if(SFO_B >2047)
+	{
+		SFO_B=SFO_B-4096;
+	}
+	SFO_B=(SFO_B*312500)/2048;
+	if(SFO_C >2047)
+	{
+		SFO_C=SFO_C-4096;
+	}
+	SFO_C=(SFO_C*312500)/2048;
+	if(SFO_D >2047)
+	{
+		SFO_D=SFO_D-4096;
+	}
+	SFO_D=(SFO_D*312500)/2048;
+
+	//LFO 2's to dec
+	
+	if(LFO_A >4095)
+	{
+		LFO_A=LFO_A-8192;
+	}
+	
+	if(LFO_B >4095)
+	{
+		LFO_B=LFO_B-8192;
+	}
+
+	if(LFO_C>4095)
+	{
+		LFO_C=LFO_C-8192;
+	}
+
+	if(LFO_D >4095)
+	{
+		LFO_D=LFO_D-8192;
+	}
+	LFO_A=LFO_A*312500/4096;
+	LFO_B=LFO_B*312500/4096;
+	LFO_C=LFO_C*312500/4096;
+	LFO_D=LFO_D*312500/4096;
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "CFO Report Info");
+	DCMD_Printf(BbDbgBuf);
+	
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  Short CFO(Hz) <A/B/C/D>", SFO_A,SFO_B,SFO_C,SFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  Long CFO(Hz) <A/B/C/D>", LFO_A,LFO_B,LFO_C,LFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	//SCFO
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd10 ,bMaskDWord);
+	value32_1 = ODM_GetBBReg(pDM_Odm, 0xd50 ,bMaskDWord);
+	value32_2 = ODM_GetBBReg(pDM_Odm, 0xd90 ,bMaskDWord);
+	value32_3 = ODM_GetBBReg(pDM_Odm, 0xdd0 ,bMaskDWord);
+
+	SFO_A=(s4Byte)(value32&0x7ff);
+	SFO_B=(s4Byte)(value32_1&0x7ff);
+	SFO_C=(s4Byte)(value32_2&0x7ff);
+	SFO_D=(s4Byte)(value32_3&0x7ff);
+
+	if(SFO_A >1023)
+	{
+		SFO_A=SFO_A-2048;
+	}
+	
+	if(SFO_B >2047)
+	{
+		SFO_B=SFO_B-4096;
+}
+
+	if(SFO_C >2047)
+	{
+		SFO_C=SFO_C-4096;
+	}
+
+	if(SFO_D >2047)
+	{
+		SFO_D=SFO_D-4096;
+	}
+	
+	SFO_A=SFO_A*312500/1024;
+	SFO_B=SFO_B*312500/1024;
+	SFO_C=SFO_C*312500/1024;
+	SFO_D=SFO_D*312500/1024;
+
+	LFO_A=(s4Byte)(value32>>16);
+	LFO_B=(s4Byte)(value32_1>>16);
+	LFO_C=(s4Byte)(value32_2>>16);
+	LFO_D=(s4Byte)(value32_3>>16);
+
+	if(LFO_A >4095)
+	{
+		LFO_A=LFO_A-8192;
+	}
+	
+	if(LFO_B >4095)
+	{
+		LFO_B=LFO_B-8192;
+	}
+
+	if(LFO_C>4095)
+	{
+		LFO_C=LFO_C-8192;
+	}
+
+	if(LFO_D >4095)
+	{
+		LFO_D=LFO_D-8192;
+	}
+	LFO_A=LFO_A*312500/4096;
+	LFO_B=LFO_B*312500/4096;
+	LFO_C=LFO_C*312500/4096;
+	LFO_D=LFO_D*312500/4096;
+	
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  Value SCFO(Hz) <A/B/C/D>", SFO_A,SFO_B,SFO_C,SFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  ACQ CFO(Hz) <A/B/C/D>", LFO_A,LFO_B,LFO_C,LFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xd14 ,bMaskDWord);
+	value32_1 = ODM_GetBBReg(pDM_Odm, 0xd54 ,bMaskDWord);
+	value32_2 = ODM_GetBBReg(pDM_Odm, 0xd94 ,bMaskDWord);
+	value32_3 = ODM_GetBBReg(pDM_Odm, 0xdd4 ,bMaskDWord);
+
+	LFO_A=(s4Byte)(value32>>16);
+	LFO_B=(s4Byte)(value32_1>>16);
+	LFO_C=(s4Byte)(value32_2>>16);
+	LFO_D=(s4Byte)(value32_3>>16);
+
+	if(LFO_A >4095)
+	{
+		LFO_A=LFO_A-8192;
+	}
+	
+	if(LFO_B >4095)
+	{
+		LFO_B=LFO_B-8192;
+	}
+
+	if(LFO_C>4095)
+	{
+		LFO_C=LFO_C-8192;
+	}
+
+	if(LFO_D >4095)
+	{
+		LFO_D=LFO_D-8192;
+	}
+	LFO_A=LFO_A*312500/4096;
+	LFO_B=LFO_B*312500/4096;
+	LFO_C=LFO_C*312500/4096;
+	LFO_D=LFO_D*312500/4096;
+	
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d/ %d/ %d", "  End CFO(Hz) <A/B/C/D>", LFO_A,LFO_B,LFO_C,LFO_D);
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf20 ,bMaskDWord);   //L SIG
+	
+	Tail=(u1Byte)((value32&0xfc0000)>>16);
+	Parity = (u1Byte)((value32&0x20000)>>16);
+	Length =(u2Byte)((value32&0x1ffe00)>>8);
+	rsv = (u1Byte)(value32&0x10);
+	MCSS=(u1Byte)(value32&0x0f);
+
+	switch(MCSS)
+	{
+		case 0x0b:
+			idx=0;
+		break;
+		case 0x0f:
+			idx=1;
+		break;
+		case 0x0a:
+			idx=2;
+		break;
+		case 0x0e:
+			idx=3;
+		break;
+		case 0x09:
+			idx=4;
+		break;
+		case 0x08:
+			idx=5;
+		break;
+		case 0x0c:
+			idx=6;
+		break;
+		default:
+			idx=6;
+		break;
+			
+	}
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "L-SIG");
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n   Rate:%s", L_rate[idx]);		
+	DCMD_Printf(BbDbgBuf);	
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x/ %x /%x", "  Rsv/Length/Parity",rsv,RX_BW,Length);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "HT-SIG1");
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf2c ,bMaskDWord);   //HT SIG
+	if(RX_HT == 1)
+	{
+	
+		HMCSS=(u1Byte)(value32&0x7F);
+		HRX_BW = (u1Byte)(value32&0x80);
+		HLength =(u2Byte)((value32>>8)&0xffff);
+	}
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x", "  MCS/BW/Length",HMCSS,HRX_BW,HLength);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "HT-SIG2");
+	DCMD_Printf(BbDbgBuf);
+
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf30 ,bMaskDWord);   //HT SIG
+
+	if(RX_HT == 1)
+	{
+		smooth = (u1Byte)(value32&0x01);
+		htsound =  (u1Byte)(value32&0x02);
+		rsv=(u1Byte)(value32&0x04);
+		agg =(u1Byte)(value32&0x08);
+		stbc =(u1Byte)(value32&0x30);
+		fec=(u1Byte)(value32&0x40);
+		sgi=(u1Byte)(value32&0x80);
+		htltf=(u1Byte)((value32&0x300)>>8);
+		htcrc8=(u2Byte)((value32&0x3fc00)>>8);
+		Tail=(u1Byte)((value32&0xfc0000)>>16);
+
+	
+	}
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x/ %x/ %x", "  Smooth/NoSound/Rsv/Aggregate/STBC/LDPC",smooth,htsound,rsv,agg,stbc,fec);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x", "  SGI/E-HT-LTFs/CRC/Tail",sgi,htltf,htcrc8,Tail);
+	DCMD_Printf(BbDbgBuf);
+
+	
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "VHT-SIG-A1");
+	DCMD_Printf(BbDbgBuf);
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf2c ,bMaskDWord);   //VHT SIG A1
+	if(RX_HT == 2)
+	{
+		//value32 = ODM_GetBBReg(pDM_Odm, 0xf2c ,bMaskDWord);   //VHT SIG A1
+		vRX_BW=(u1Byte)(value32&0x03);
+		vrsv=(u1Byte)(value32&0x04);
+		vstbc =(u1Byte)(value32&0x08);
+		vgid = (u1Byte)((value32&0x3f0)>>4);
+		vNsts = (u1Byte)(((value32&0x1c00)>>8)+1);
+		vpaid = (u2Byte)(value32&0x3fe);
+		vtxops =(u1Byte)((value32&0x400000)>>20);
+		vrsv2 = (u1Byte)((value32&0x800000)>>20);
+	}
+
+	//rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x", "F2C", value32);
+	//DCMD_Printf(BbDbgBuf);
+
+	
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x/ %x/ %x /%x /%x", "  BW/Rsv1/STBC/GID/Nsts/PAID/TXOPPS/Rsv2",vRX_BW,vrsv,vstbc,vgid,vNsts,vpaid,vtxops,vrsv2);
+	DCMD_Printf(BbDbgBuf);
+	
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "VHT-SIG-A2");
+	DCMD_Printf(BbDbgBuf);
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf30 ,bMaskDWord);   //VHT SIG
+
+
+	if(RX_HT == 2)
+	{
+		//value32 = ODM_GetBBReg(pDM_Odm, 0xf30 ,bMaskDWord);   //VHT SIG
+
+		//sgi=(u1Byte)(value32&0x01);
+		sgiext =(u1Byte)(value32&0x03);
+		//fec = (u1Byte)(value32&0x04);
+		fecext = (u1Byte)(value32&0x0C);
+
+		vMCSS =(u1Byte)(value32&0xf0); 
+		bf = (u1Byte)((value32&0x100)>>8); 
+		vrsv =(u1Byte)((value32&0x200)>>8);  
+		vhtcrc8=(u2Byte)((value32&0x3fc00)>>8);
+		vTail=(u1Byte)((value32&0xfc0000)>>16);
+	}
+	//rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x", "F30", value32);
+	//DCMD_Printf(BbDbgBuf);
+	
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x/ %x/ %x/ %x", "  SGI/FEC/MCS/BF/Rsv/CRC/Tail",sgiext,fecext,vMCSS,bf,vrsv,vhtcrc8,vTail);
+	DCMD_Printf(BbDbgBuf);
+
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s", "VHT-SIG-B");
+	DCMD_Printf(BbDbgBuf);
+	value32 = ODM_GetBBReg(pDM_Odm, 0xf34 ,bMaskDWord);   //VHT SIG
+	{
+		vLength=(u2Byte)(value32&0x1fffff);
+		vbrsv = (u1Byte)((value32&0x600000)>>20);
+		vbTail =(u2Byte)((value32&0x1f800000)>>20);
+		vbcrc = (u1Byte)((value32&0x80000000)>>28);
+	
+	}
+	//rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x", "F34", value32);
+	//DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %x / %x/ %x/ %x/", "  Length/Rsv/Tail/CRC",vLength,vbrsv,vbTail,vbcrc);
+	DCMD_Printf(BbDbgBuf);
+	
+		
+}
+
+
+VOID phydm_BasicProfile(
+	IN		PVOID			pDM_VOID
+	)
+{
+        PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+        PADAPTER		       Adapter = pDM_Odm->Adapter;
+        char* Cut = NULL;
+	char* ICType = NULL;
+
+        rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n%-35s", "% Basic Profile %");
+	DCMD_Printf(BbDbgBuf);
+
+	if(pDM_Odm->SupportICType == ODM_RTL8192C)
+		ICType = "RTL8192C";
+	else if(pDM_Odm->SupportICType == ODM_RTL8192D)
+		ICType = "RTL8192D";
+	else if(pDM_Odm->SupportICType == ODM_RTL8723A)
+		ICType = "RTL8723A";
+	else if(pDM_Odm->SupportICType == ODM_RTL8188E)
+		ICType = "RTL8188E";
+	else if(pDM_Odm->SupportICType == ODM_RTL8812)
+		ICType = "RTL8812A";
+	else if(pDM_Odm->SupportICType == ODM_RTL8821)
+		ICType = "RTL8821A";
+	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
+		ICType = "RTL8192E";
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
+		ICType = "RTL8723B";
+	else if(pDM_Odm->SupportICType == ODM_RTL8814A)
+		ICType = "RTL8814A";
+	else if(pDM_Odm->SupportICType == ODM_RTL8881A)
+		ICType = "RTL8881A";
+	else if(pDM_Odm->SupportICType == ODM_RTL8821B)
+		ICType = "RTL8821B";
+	else if(pDM_Odm->SupportICType == ODM_RTL8822B)
+		ICType = "RTL8822B";
+	else if(pDM_Odm->SupportICType == ODM_RTL8703B)
+		ICType = "RTL8703B";
+	else if(pDM_Odm->SupportICType == ODM_RTL8195A)
+		ICType = "RTL8195A";
+	else if(pDM_Odm->SupportICType == ODM_RTL8188F)
+		ICType = "RTL8188F";
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s (MP Chip: %s)","IC Type", ICType, pDM_Odm->bIsMPChip?"Yes":"No");		
+	DCMD_Printf(BbDbgBuf);
+
+        if(pDM_Odm->CutVersion==ODM_CUT_A)
+            Cut = "A";
+        else if(pDM_Odm->CutVersion==ODM_CUT_B)
+            Cut = "B";
+        else if(pDM_Odm->CutVersion==ODM_CUT_C)
+            Cut = "C";
+        else if(pDM_Odm->CutVersion==ODM_CUT_D)
+            Cut = "D";
+        else if(pDM_Odm->CutVersion==ODM_CUT_E)
+            Cut = "E";
+        else if(pDM_Odm->CutVersion==ODM_CUT_F)
+            Cut = "F";
+        else if(pDM_Odm->CutVersion==ODM_CUT_I)
+            Cut = "I";
+        rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","Cut Version", Cut);		
+	DCMD_Printf(BbDbgBuf);
+        rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %d","PHY Parameter Version", ODM_GetHWImgVersion(pDM_Odm));		
+	DCMD_Printf(BbDbgBuf);
+        rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %d (Subversion: %d)","FW Version", Adapter->MgntInfo.FirmwareVersion, Adapter->MgntInfo.FirmwareSubVersion);		
+	DCMD_Printf(BbDbgBuf);
+
+	//1 PHY DM Version List
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n%-35s","% PHYDM Version %");
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","Adaptivity", ADAPTIVITY_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","DIG", DIG_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","Dynamic BB PowerSaving", DYNAMIC_BBPWRSAV_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","CFO Tracking", CFO_TRACKING_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","Antenna Diversity", ANTDIV_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","Power Tracking", POWRTRACKING_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","Dynamic TxPower", DYNAMIC_TXPWR_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","RA Info", RAINFO_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","Antenna Detection", ANTDECT_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","Auto Channel Selection", ACS_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","EDCA Turbo", EDCATURBO_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","Path Diversity", PATHDIV_VERSION);
+	DCMD_Printf(BbDbgBuf);
+	rsprintf(BbDbgBuf, BT_TMP_BUF_SIZE, "\r\n  %-35s: %s","RxHP", RXHP_VERSION);
+	DCMD_Printf(BbDbgBuf);
+
+}
+#endif
+VOID
+phydm_BasicDbgMessage
+(
+	IN		PVOID			pDM_VOID
+	)
+{
+#if( DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+        PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
+	PFALSE_ALARM_STATISTICS FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm , PHYDM_FALSEALMCNT);
+	pDIG_T	pDM_DigTable = &pDM_Odm->DM_DigTable;
+	
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_BasicDbgMsg==>\n"));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("bLinked = %d, RSSI_Min = %d, CurrentIGI = 0x%x \n",
+		pDM_Odm->bLinked, pDM_Odm->RSSI_Min, pDM_DigTable->CurIGValue) );
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("Cnt_Cck_fail = %d, Cnt_Ofdm_fail = %d, Total False Alarm = %d\n",	
+		FalseAlmCnt->Cnt_Cck_fail, FalseAlmCnt->Cnt_Ofdm_fail, FalseAlmCnt->Cnt_all));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("RxRate = 0x%x, RSSI_A = %d, RSSI_B = %d\n", 
+		pDM_Odm->RxRate, pDM_Odm->RSSI_A, pDM_Odm->RSSI_B));
+	ODM_RT_TRACE(pDM_Odm,ODM_COMP_COMMON, ODM_DBG_LOUD, ("RSSI_C = %d, RSSI_D = %d\n", pDM_Odm->RSSI_C, pDM_Odm->RSSI_D));
+#endif
+}
+
+#if( DM_ODM_SUPPORT_TYPE & ODM_CE)
+struct _PHYDM_COMMAND {
+	char name[16];
+	u1Byte id;
+};
+
+enum PHYDM_CMD_ID {
+	PHYDM_ANTDIV,
+};
+
+struct _PHYDM_COMMAND phy_dm_ary[] = {
+	{"antdiv", PHYDM_ANTDIV},
+};
+
+s4Byte
+PhyDM_Cmd(
+	IN PDM_ODM_T	pDM_Odm,
+	IN char		*input,
+	IN u4Byte	in_len,
+	IN u1Byte	flag,
+	OUT char	*output,
+	IN u4Byte	out_len
+	)
+{
+	u4Byte used = 0;
+
+	if (flag == 0) {
+		if (out_len > used)
+			used += snprintf(output+used, out_len-used, "GET, nothing to print\n");
+	} else {
+		char *token;
+		u1Byte id = 0;
+		int var = 0;
+
+		token = strsep(&input, ", ");
+		if (token) {
+			int n, i;
+			n = sizeof(phy_dm_ary)/sizeof(struct _PHYDM_COMMAND);
+			for (i = 0; i < n; i++) {
+				if (strcmp(phy_dm_ary[i].name, token) == 0) {
+					id = phy_dm_ary[i].id;
+					break;
+				}
+			}
+			if (i == n) {
+				if (out_len > used)
+					used += snprintf(output+used, out_len-used, "SET, command not found!\n");
+				goto exit;
+			}
+		}
+
+		switch (id) {
+		case PHYDM_ANTDIV:
+			token = strsep(&input, ", ");
+			sscanf(token, "%d", &var);
+			if (out_len > used)
+				used += snprintf(output+used, out_len-used, "SET, old antdiv_select=%d\n", pDM_Odm->antdiv_select);
+			pDM_Odm->antdiv_select = var;
+			if (out_len > used)
+				used += snprintf(output+used, out_len-used, "SET, new antdiv_select=%d\n", pDM_Odm->antdiv_select);
+			break;
+
+		default:
+			if (out_len > used)
+				used += snprintf(output+used, out_len-used, "SET, unknown command!\n");
+			break;
+		}
+	}
+
+exit:
+	return 0;
+}
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_debug.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_debug.h
new file mode 100644
index 000000000000..93574f2a0d90
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_debug.h
@@ -0,0 +1,202 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__ODM_DBG_H__
+#define __ODM_DBG_H__
+
+
+//-----------------------------------------------------------------------------
+//	Define the debug levels
+//
+//	1.	DBG_TRACE and DBG_LOUD are used for normal cases.
+//	So that, they can help SW engineer to develope or trace states changed 
+//	and also help HW enginner to trace every operation to and from HW, 
+//	e.g IO, Tx, Rx. 
+//
+//	2.	DBG_WARNNING and DBG_SERIOUS are used for unusual or error cases, 
+//	which help us to debug SW or HW.
+//
+//-----------------------------------------------------------------------------
+//
+//	Never used in a call to ODM_RT_TRACE()!
+//
+#define ODM_DBG_OFF					1
+
+//
+//	Fatal bug. 
+//	For example, Tx/Rx/IO locked up, OS hangs, memory access violation, 
+//	resource allocation failed, unexpected HW behavior, HW BUG and so on.
+//
+#define ODM_DBG_SERIOUS				2
+
+//
+//	Abnormal, rare, or unexpeted cases.
+//	For example, IRP/Packet/OID canceled, device suprisely unremoved and so on.
+//
+#define ODM_DBG_WARNING				3
+
+//
+//	Normal case with useful information about current SW or HW state. 
+//	For example, Tx/Rx descriptor to fill, Tx/Rx descriptor completed status, 
+//	SW protocol state change, dynamic mechanism state change and so on.
+//
+#define ODM_DBG_LOUD					4
+
+//
+//	Normal case with detail execution flow or information.
+//
+#define ODM_DBG_TRACE					5
+
+//-----------------------------------------------------------------------------
+// Define the tracing components
+//
+//-----------------------------------------------------------------------------
+//BB Functions
+#define ODM_COMP_DIG					BIT0	
+#define ODM_COMP_RA_MASK				BIT1	
+#define ODM_COMP_DYNAMIC_TXPWR		BIT2
+#define ODM_COMP_FA_CNT				BIT3
+#define ODM_COMP_RSSI_MONITOR		BIT4
+#define ODM_COMP_CCK_PD				BIT5
+#define ODM_COMP_ANT_DIV				BIT6
+#define ODM_COMP_PWR_SAVE			BIT7
+#define ODM_COMP_PWR_TRAIN			BIT8
+#define ODM_COMP_RATE_ADAPTIVE		BIT9
+#define ODM_COMP_PATH_DIV				BIT10
+#define ODM_COMP_PSD					BIT11
+#define ODM_COMP_DYNAMIC_PRICCA		BIT12
+#define ODM_COMP_RXHP					BIT13
+#define ODM_COMP_MP					BIT14
+#define ODM_COMP_CFO_TRACKING		BIT15
+#define ODM_COMP_ACS					BIT16
+#define PHYDM_COMP_ADAPTIVITY			BIT17
+//MAC Functions
+#define ODM_COMP_EDCA_TURBO			BIT20
+#define ODM_COMP_EARLY_MODE			BIT21
+//RF Functions
+#define ODM_COMP_TX_PWR_TRACK		BIT24
+#define ODM_COMP_RX_GAIN_TRACK		BIT25
+#define ODM_COMP_CALIBRATION			BIT26
+//Common Functions
+#define ODM_COMP_COMMON				BIT30
+#define ODM_COMP_INIT					BIT31
+
+/*------------------------Export Marco Definition---------------------------*/
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+	#define RT_PRINTK				DbgPrint
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+	#define DbgPrint	printk
+	#define RT_PRINTK(fmt, args...)	DbgPrint( "%s(): " fmt, __FUNCTION__, ## args);
+	#define	RT_DISP(dbgtype, dbgflag, printstr)
+#else
+	#define DbgPrint	panic_printk
+	#define RT_PRINTK(fmt, args...)	DbgPrint( "%s(): " fmt, __FUNCTION__, ## args);
+#endif
+
+#ifndef ASSERT
+	#define ASSERT(expr)
+#endif
+
+#if DBG
+#define ODM_RT_TRACE(pDM_Odm, comp, level, fmt)									\
+		if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel || level == ODM_DBG_SERIOUS))	\
+		{																			\
+			if(pDM_Odm->SupportICType == ODM_RTL8192C)								\
+				DbgPrint("[ODM-92C] ");												\
+			else if(pDM_Odm->SupportICType == ODM_RTL8192D)							\
+				DbgPrint("[ODM-92D] ");												\
+			else if(pDM_Odm->SupportICType == ODM_RTL8723A)							\
+				DbgPrint("[ODM-8723A] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8188E)							\
+				DbgPrint("[ODM-8188E] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8192E) 						\
+				DbgPrint("[ODM-8192E] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8812)							\
+				DbgPrint("[ODM-8812] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8821)							\
+				DbgPrint("[ODM-8821] ");											\
+			else if(pDM_Odm->SupportICType == ODM_RTL8814A)							\
+				DbgPrint("[ODM-8814] ");											\
+			RT_PRINTK fmt;															\
+		}
+
+#define ODM_RT_TRACE_F(pDM_Odm, comp, level, fmt)									\
+		if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel))	\
+		{																			\
+			RT_PRINTK fmt;															\
+		}
+
+#define ODM_RT_ASSERT(pDM_Odm, expr, fmt)											\
+		if(!(expr)) {																	\
+			DbgPrint( "Assertion failed! %s at ......\n", #expr);								\
+			DbgPrint( "      ......%s,%s,line=%d\n",__FILE__,__FUNCTION__,__LINE__);			\
+			RT_PRINTK fmt;															\
+			ASSERT(FALSE);															\
+		}
+#define ODM_dbg_enter() { DbgPrint("==> %s\n", __FUNCTION__); }
+#define ODM_dbg_exit() { DbgPrint("<== %s\n", __FUNCTION__); }
+#define ODM_dbg_trace(str) { DbgPrint("%s:%s\n", __FUNCTION__, str); }
+
+#define ODM_PRINT_ADDR(pDM_Odm, comp, level, title_str, ptr)							\
+			if(((comp) & pDM_Odm->DebugComponents) && (level <= pDM_Odm->DebugLevel))	\
+			{																		\
+				int __i;																\
+				pu1Byte	__ptr = (pu1Byte)ptr;											\
+				DbgPrint("[ODM] ");													\
+				DbgPrint(title_str);													\
+				DbgPrint(" ");														\
+				for( __i=0; __i<6; __i++ )												\
+					DbgPrint("%02X%s", __ptr[__i], (__i==5)?"":"-");						\
+				DbgPrint("\n");														\
+			}
+#else
+#define ODM_RT_TRACE(pDM_Odm, comp, level, fmt)
+#define ODM_RT_TRACE_F(pDM_Odm, comp, level, fmt)
+#define ODM_RT_ASSERT(pDM_Odm, expr, fmt)
+#define ODM_dbg_enter()
+#define ODM_dbg_exit()
+#define ODM_dbg_trace(str)
+#define ODM_PRINT_ADDR(pDM_Odm, comp, level, title_str, ptr)
+#endif
+
+
+VOID 
+PHYDM_InitDebugSetting(IN		PDM_ODM_T		pDM_Odm);
+
+#define	BB_TMP_BUF_SIZE		100
+VOID phydm_BB_Debug_Info(IN PDM_ODM_T pDM_Odm);
+VOID phydm_BasicProfile(IN		PVOID			pDM_VOID);
+VOID phydm_BasicDbgMessage(	IN		PVOID			pDM_VOID);
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+s4Byte
+PhyDM_Cmd(
+	IN PDM_ODM_T	pDM_Odm,
+	IN char		*input,
+	IN u4Byte	in_len,
+	IN u1Byte	flag,
+	OUT char	*output,
+	IN u4Byte	out_len
+);
+#endif
+
+#endif	// __ODM_DBG_H__
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_interface.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_interface.c
similarity index 73%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_interface.c
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_interface.c
index 555fd7d705fb..16caf370b73c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_interface.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_interface.c
@@ -22,8 +22,8 @@
 // include files
 //============================================================
 
-
-#include "odm_precomp.h"
+#include "Mp_Precomp.h"
+#include "phydm_precomp.h"
 
 //
 // ODM IO Relative API.
@@ -177,12 +177,9 @@ ODM_GetMACReg(
 	)
 {
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-	return PHY_QueryMacReg(pDM_Odm->priv, RegAddr, BitMask);
-#elif(DM_ODM_SUPPORT_TYPE & (ODM_WIN))
-	PADAPTER		Adapter = pDM_Odm->Adapter;
-	return PHY_QueryMacReg(Adapter, RegAddr, BitMask);
-#elif(DM_ODM_SUPPORT_TYPE & (ODM_CE))
-	return PHY_QueryBBReg(pDM_Odm->Adapter, RegAddr, BitMask);
+	return PHY_QueryBBReg(pDM_Odm->priv, RegAddr, BitMask);
+#elif(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	return PHY_QueryMacReg(pDM_Odm->Adapter, RegAddr, BitMask);
 #endif	
 }
 
@@ -304,7 +301,7 @@ ODM_MoveMemory(
 	)
 {
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-	
+	memcpy(pDest, pSrc, Length);
 #elif (DM_ODM_SUPPORT_TYPE & ODM_CE )	
 	_rtw_memcpy(pDest, pSrc, Length);
 #elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
@@ -312,6 +309,20 @@ ODM_MoveMemory(
 #endif	
 }
 
+void ODM_Memory_Set
+	(IN 	PDM_ODM_T	pDM_Odm,
+		IN  PVOID	pbuf,
+		IN  s1Byte	value,
+		IN  u4Byte	length)
+{
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	
+#elif (DM_ODM_SUPPORT_TYPE & ODM_CE )	
+	_rtw_memset(pbuf,value, length);
+#elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+	PlatformFillMemory(pbuf,length,value);
+#endif
+}
 s4Byte ODM_CompareMemory(
 	IN 	PDM_ODM_T		pDM_Odm,
 	IN	PVOID           pBuf1,
@@ -342,7 +353,8 @@ ODM_AcquireSpinLock(
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
 	
 #elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
-
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	rtw_odm_acquirespinlock(Adapter, type);
 #elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
 	PADAPTER		Adapter = pDM_Odm->Adapter;
 	PlatformAcquireSpinLock(Adapter, type);
@@ -357,7 +369,8 @@ ODM_ReleaseSpinLock(
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
 
 #elif (DM_ODM_SUPPORT_TYPE & ODM_CE )
-	
+	PADAPTER Adapter = pDM_Odm->Adapter;
+	rtw_odm_releasespinlock(Adapter, type);
 #elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
 	PADAPTER		Adapter = pDM_Odm->Adapter;
 	PlatformReleaseSpinLock(Adapter, type);
@@ -534,7 +547,7 @@ ODM_SetTimer(
 	)
 {
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
-	mod_timer(pTimer, jiffies + (msDelay+9)/10);	
+	mod_timer(pTimer, jiffies + RTL_MILISECONDS_TO_JIFFIES(msDelay));
 #elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
 	_set_timer(pTimer,msDelay ); //ms
 #elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)
@@ -554,9 +567,10 @@ ODM_InitializeTimer(
 	)
 {
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
+	init_timer(pTimer);
 	pTimer->function = CallBackFunc;
 	pTimer->data = (unsigned long)pDM_Odm;
-	init_timer(pTimer);	
+	mod_timer(pTimer, jiffies+RTL_MILISECONDS_TO_JIFFIES(10));	
 #elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
 	PADAPTER Adapter = pDM_Odm->Adapter;
 	_init_timer(pTimer,Adapter->pnetdev,CallBackFunc,pDM_Odm);
@@ -614,81 +628,152 @@ ODM_ReleaseTimer(
 //
 // ODM FW relative API.
 //
-#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
 VOID
 ODM_FillH2CCmd(
-	IN	PADAPTER		Adapter,
-	IN	u1Byte 	ElementID,
-	IN	u4Byte 	CmdLen,
-	IN	pu1Byte	pCmdBuffer
+	IN	PDM_ODM_T		pDM_Odm,
+	IN	u1Byte 			ElementID,
+	IN	u4Byte 			CmdLen,
+	IN	pu1Byte			pCmdBuffer
 )
 {
-	if(IS_HARDWARE_TYPE_JAGUAR(Adapter))
+	PADAPTER 		Adapter = pDM_Odm->Adapter;
+
+	if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
 	{
 		switch(ElementID)
 		{
-		case ODM_H2C_RSSI_REPORT:
-			FillH2CCmd8812(Adapter, H2C_8812_RSSI_REPORT, CmdLen, pCmdBuffer);
-			break;
-		default:
-			break;
+			case ODM_H2C_RSSI_REPORT:
+
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				FillH2CCmd(Adapter, H2C_RSSI_REPORT, CmdLen, pCmdBuffer);
+#else
+	#if((RTL8812A_SUPPORT==1) ||(RTL8821A_SUPPORT==1))
+				FillH2CCmd_8812(Adapter, H2C_8812_RSSI_REPORT, CmdLen, pCmdBuffer);
+	#endif
+#endif
+				break;
+			case ODM_H2C_IQ_CALIBRATION:
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				FillH2CCmd(Adapter, H2C_IQ_CALIBRATION, CmdLen, pCmdBuffer);
+#else
+	#if((RTL8812A_SUPPORT==1) ||(RTL8821A_SUPPORT==1))
+				FillH2CCmd_8812(Adapter, H2C_8812_IQ_CALIBRATION, CmdLen, pCmdBuffer);
+	#endif
+#endif
+				break;
+			default:
+				break;
 		}
 
 	}
-	else if(IS_HARDWARE_TYPE_8192E(Adapter))
+	else if(pDM_Odm->SupportICType == ODM_RTL8192E)
 	{
 		switch(ElementID)
 		{
-		case ODM_H2C_RSSI_REPORT:
-			FillH2CCmd8812(Adapter, H2C_8812_RSSI_REPORT, CmdLen, pCmdBuffer);
-			break;
-		default:
-			break;
+			case ODM_H2C_RSSI_REPORT:
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				FillH2CCmd(Adapter, H2C_RSSI_REPORT, CmdLen, pCmdBuffer);
+#else
+	#if(RTL8192E_SUPPORT==1)
+				FillH2CCmd_8192E(Adapter, H2C_8192E_RSSI_REPORT, CmdLen, pCmdBuffer);
+	#endif
+#endif
+				break;
+			default:
+				break;
 		}	
 	}
-	else if(IS_HARDWARE_TYPE_8723B(Adapter))
+	else if(pDM_Odm->SupportICType == ODM_RTL8723B)
 	{
-		//
-		// <Roger_TODO> We should take RTL8723B into consideration, 2012.10.08
-		//
 		switch(ElementID)
 		{
 			case ODM_H2C_RSSI_REPORT:
-			   FillH2CCmd8723B(Adapter, H2C_8723B_RSSI_REPORT, CmdLen, pCmdBuffer);
-			   break;
-			   
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				FillH2CCmd(Adapter, H2C_RSSI_REPORT, CmdLen, pCmdBuffer);
+#else
+	#if(RTL8723B_SUPPORT==1)
+				FillH2CCmd8723B(Adapter, H2C_8723B_RSSI_SETTING, CmdLen, pCmdBuffer);
+	#endif
+#endif
+				break;
+			case ODM_H2C_WIFI_CALIBRATION:
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				FillH2CCmd(Adapter, H2C_WIFI_CALIBRATION, CmdLen, pCmdBuffer);
+#else
+	#if(RTL8723B_SUPPORT==1)
+				FillH2CCmd8723B(Adapter, H2C_8723B_BT_WLAN_CALIBRATION, CmdLen, pCmdBuffer);
+	#endif
+#endif
+			   	break;
 			default:
-			   break;			   
+				break;			   
 		}
 
 	}
-	else if(IS_HARDWARE_TYPE_8188E(Adapter))
+	else if(pDM_Odm->SupportICType == ODM_RTL8188E)
+	{
+		switch(ElementID)
+		{
+			case ODM_H2C_RSSI_REPORT:
+				//if((pDM_Odm->CutVersion == ODM_CUT_I) && (!pDM_Odm->RaSupport88E)){
+				if(!pDM_Odm->RaSupport88E){
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+					FillH2CCmd88E(Adapter, H2C_88E_RSSI_REPORT, CmdLen, pCmdBuffer);
+#else
+	#if(RTL8188E_SUPPORT==1)
+					FillH2CCmd_88E(Adapter, H2C_RSSI_REPORT, CmdLen, pCmdBuffer);
+	#endif
+#endif			
+				}
+				break;
+			default:
+				break;
+		}
+	}
+#if(DM_ODM_SUPPORT_TYPE & ODM_CE)
+	else if(pDM_Odm->SupportICType == ODM_RTL8723A)
+	{
+		switch(ElementID)
+		{
+			case ODM_H2C_RSSI_REPORT:
+	#if(RTL8723A_SUPPORT==1)
+				FillH2CCmd(Adapter, RSSI_SETTING_EID, CmdLen, pCmdBuffer);
+	#endif
+				break;
+			default:
+				break;
+		}
+	}
+	else if(pDM_Odm->SupportICType == ODM_RTL8192D)
 	{
 		switch(ElementID)
 		{
-		case ODM_H2C_PSD_RESULT:
-			FillH2CCmd88E(Adapter, H2C_88E_PSD_RESULT, CmdLen, pCmdBuffer);
-			break;
-		case ODM_H2C_RSSI_REPORT:
-			if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
-				FillH2CCmd88E(Adapter, H2C_88E_RSSI_REPORT, CmdLen, pCmdBuffer);
-			break;
-		default:
-			break;
+			case ODM_H2C_RSSI_REPORT:
+	#if(RTL8192D_SUPPORT==1)
+			FillH2CCmd92D(Adapter, H2C_RSSI_REPORT, CmdLen, pCmdBuffer);	
+	#endif
+				break;
+			default:
+				break;
 		}
 	}
+#endif
 	else
 	{
 		switch(ElementID)
 		{
-		case ODM_H2C_RSSI_REPORT:
-			FillH2CCmd92C(Adapter, H2C_RSSI_REPORT, CmdLen, pCmdBuffer);
-			break;
-		case ODM_H2C_PSD_RESULT:
-			FillH2CCmd92C(Adapter, H2C_92C_PSD_RESULT, CmdLen, pCmdBuffer);
-			break;
-		default:
-			break;
+			case ODM_H2C_RSSI_REPORT:
+#if(DM_ODM_SUPPORT_TYPE & ODM_WIN)
+				FillH2CCmd92C(Adapter, H2C_RSSI_REPORT, CmdLen, pCmdBuffer);
+#else
+	#if(RTL8192C_SUPPORT==1)
+				rtl8192c_FillH2CCmd(Adapter, RSSI_SETTING_EID, CmdLen, pCmdBuffer);
+	#endif
+#endif
+				break;
+			default:
+				break;
 		}
 	}
 }
@@ -718,7 +803,7 @@ ODM_FillH2CCmd(
 #endif
 
 
-u4Byte
+u8Byte
 ODM_GetCurrentTime(	
 	IN 	PDM_ODM_T		pDM_Odm
 	)
@@ -726,24 +811,24 @@ ODM_GetCurrentTime(
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
 	return  0;
 #elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
-	return rtw_get_current_time();
+	return (u8Byte)rtw_get_current_time();
 #elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)	
-	return  0;
+	return  PlatformGetCurrentTime();
 #endif
 }
 
-s4Byte
+u8Byte
 ODM_GetProgressingTime(	
 	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			Start_Time
+	IN	u8Byte			Start_Time
 	)
 {
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
 	return  0;
 #elif(DM_ODM_SUPPORT_TYPE & ODM_CE)
-	return rtw_get_passing_time_ms(Start_Time);
+	return rtw_get_passing_time_ms((u4Byte)Start_Time);
 #elif(DM_ODM_SUPPORT_TYPE & ODM_WIN)	
-	return  0;
+	return   ((PlatformGetCurrentTime() - Start_Time)>>10);
 #endif
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_interface.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_interface.h
similarity index 81%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_interface.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_interface.h
index 8c0303b54214..6a6d50ce6953 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_interface.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_interface.h
@@ -60,36 +60,50 @@ ODM_REG(DIG,_pDM_Odm)
 #define _bit_11N(_name)			ODM_BIT_##_name##_11N 
 #define _bit_11AC(_name)		ODM_BIT_##_name##_11AC
 
-#if 1 //TODO: enable it if we need to support run-time to differentiate between 92C_SERIES and JAGUAR_SERIES.
-#define _cat(_name, _ic_type, _func)									\
-	( 															\
+#ifdef __ECOS
+#define _rtk_cat(_name, _ic_type, _func)		\
+	( 					\
 		((_ic_type) & ODM_IC_11N_SERIES)? _func##_11N(_name):		\
-		_func##_11AC(_name)									\
+		_func##_11AC(_name)	\
 	)
-#endif
-#if 0 // only sample code
+#else
+
 #define _cat(_name, _ic_type, _func)									\
 	( 															\
-		((_ic_type) & ODM_RTL8192C)? _func##_ic(_name, _8192C):		\
-		((_ic_type) & ODM_RTL8192D)? _func##_ic(_name, _8192D):		\
-		((_ic_type) & ODM_RTL8192S)? _func##_ic(_name, _8192S):		\
-		((_ic_type) & ODM_RTL8723A)? _func##_ic(_name, _8723A):		\
-		((_ic_type) & ODM_RTL8188E)? _func##_ic(_name, _8188E):		\
-		_func##_ic(_name, _8195)									\
+		((_ic_type) & ODM_IC_11N_SERIES)? _func##_11N(_name):		\
+		_func##_11AC(_name)									\
 	)
 #endif
+/* 
+// only sample code
+//#define _cat(_name, _ic_type, _func)									\
+//	( 															\
+//		((_ic_type) & ODM_RTL8192C)? _func##_ic(_name, _8192C):		\
+//		((_ic_type) & ODM_RTL8192D)? _func##_ic(_name, _8192D):		\
+//		((_ic_type) & ODM_RTL8192S)? _func##_ic(_name, _8192S):		\
+//		((_ic_type) & ODM_RTL8723A)? _func##_ic(_name, _8723A):		\
+//		((_ic_type) & ODM_RTL8188E)? _func##_ic(_name, _8188E):		\
+//		_func##_ic(_name, _8195)									\
+//	)
+*/
 
 // _name: name of register or bit.
 // Example: "ODM_REG(R_A_AGC_CORE1, pDM_Odm)" 
 //        gets "ODM_R_A_AGC_CORE1" or "ODM_R_A_AGC_CORE1_8192C", depends on SupportICType.
+#ifdef __ECOS
+#define ODM_REG(_name, _pDM_Odm)	_rtk_cat(_name, _pDM_Odm->SupportICType, _reg)
+#define ODM_BIT(_name, _pDM_Odm)	_rtk_cat(_name, _pDM_Odm->SupportICType, _bit)
+#else
 #define ODM_REG(_name, _pDM_Odm)	_cat(_name, _pDM_Odm->SupportICType, _reg)
 #define ODM_BIT(_name, _pDM_Odm)	_cat(_name, _pDM_Odm->SupportICType, _bit)
-
+#endif
 typedef enum _ODM_H2C_CMD 
 {
 	ODM_H2C_RSSI_REPORT = 0,
 	ODM_H2C_PSD_RESULT=1,	
-	ODM_H2C_PathDiv = 2,               
+	ODM_H2C_PathDiv = 2,
+	ODM_H2C_WIFI_CALIBRATION = 3,
+	ODM_H2C_IQ_CALIBRATION = 4,
 	ODM_MAX_H2CCMD
 }ODM_H2C_CMD;
 
@@ -251,6 +265,12 @@ s4Byte ODM_CompareMemory(
       IN	PVOID           pBuf2,
       IN	u4Byte          length
        );
+
+void ODM_Memory_Set
+	(IN 	PDM_ODM_T	pDM_Odm,
+		IN  PVOID	pbuf,
+		IN  s1Byte	value,
+		IN  u4Byte	length);
 	
 //
 // ODM MISC-spin lock relative API.
@@ -359,13 +379,13 @@ ODM_ReleaseTimer(
 //
 // ODM FW relative API.
 //
-#if (DM_ODM_SUPPORT_TYPE & ODM_WIN)
+#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
 VOID
 ODM_FillH2CCmd(
-	IN	PADAPTER		Adapter,
-	IN	u1Byte 	ElementID,
-	IN	u4Byte 	CmdLen,
-	IN	pu1Byte	pCmdBuffer
+	IN	PDM_ODM_T		pDM_Odm,
+	IN	u1Byte 			ElementID,
+	IN	u4Byte 			CmdLen,
+	IN	pu1Byte			pCmdBuffer
 );
 #else
 u4Byte
@@ -380,14 +400,14 @@ ODM_FillH2CCmd(
 	);
 #endif
 
-u4Byte
+u8Byte
 ODM_GetCurrentTime(	
 	IN 	PDM_ODM_T		pDM_Odm
 	);
-s4Byte
+u8Byte
 ODM_GetProgressingTime(	
 	IN 	PDM_ODM_T		pDM_Odm,
-	IN	u4Byte			Start_Time
+	IN	u8Byte			Start_Time
 	);
 
 #endif	// __ODM_INTERFACE_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_precomp.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_precomp.h
similarity index 83%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_precomp.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_precomp.h
index e3c71d2d34da..5651d7eaa190 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_precomp.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_precomp.h
@@ -21,7 +21,7 @@
 #ifndef	__ODM_PRECOMP_H__
 #define __ODM_PRECOMP_H__
 
-#include "odm_types.h"
+#include "phydm_types.h"
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 #include "Precomp.h"		// We need to include mp_precomp.h due to batch file setting.
@@ -138,13 +138,14 @@
 
 
 //2 OutSrc Header Files
-
-#include "odm.h"
-#include "odm_HWConfig.h"
-#include "odm_debug.h"
-#include "odm_RegDefine11AC.h"
-#include "odm_RegDefine11N.h"
-#include "odm_AntDiv.h"
+#include "phydm.h"
+#include "phydm_HWConfig.h"
+#include "phydm_debug.h"
+#include "phydm_RegDefine11AC.h"
+#include "phydm_RegDefine11N.h"
+#include "phydm_AntDiv.h"
+#include "phydm_interface.h"
+#include "phydm_reg.h"
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
 #if (RTL8192C_SUPPORT==1)
@@ -197,7 +198,8 @@
 	#if (RTL8821A_SUPPORT==1)
 		#include "rtl8821a/HalPhyRf_8821A.h"//for IQK,LCK,Power-tracking
 		#include "rtl8812a/HalPhyRf_8812A.h"//for IQK,LCK,Power-tracking
-		#include "rtl8812a_hal.h"		
+		#include "rtl8812a_hal.h"
+		#include "rtl8821a/PhyDM_IQK_8821A.h"
 	#endif
 
 	#if (RTL8723B_SUPPORT==1)
@@ -206,8 +208,6 @@
 	#endif
 #endif
 
-#include "odm_interface.h"
-#include "odm_reg.h"
 
 #if (RTL8192C_SUPPORT==1) 
 #if (DM_ODM_SUPPORT_TYPE == ODM_AP)
@@ -216,10 +216,10 @@
 #include "rtl8192c/Hal8192CHWImg_BB.h"
 #include "rtl8192c/Hal8192CHWImg_FW.h"
 #endif
-#include "rtl8192c/odm_RTL8192C.h"
+#include "rtl8192c/phydm_RTL8192C.h"
 #endif
 #if (RTL8192D_SUPPORT==1) 
-#include "rtl8192d/odm_RTL8192D.h"
+#include "rtl8192d/phydm_RTL8192D.h"
 #endif
 
 #if (RTL8723A_SUPPORT==1) 
@@ -227,7 +227,7 @@
 #include "rtl8723a/HalHWImg8723A_RF.h"
 #include "rtl8723a/HalHWImg8723A_BB.h"
 #include "rtl8723a/HalHWImg8723A_FW.h"
-#include "rtl8723a/odm_RegConfig8723A.h"
+#include "rtl8723a/phydm_RegConfig8723A.h"
 #endif
 
 #if (RTL8188E_SUPPORT==1) 
@@ -248,8 +248,8 @@
 #endif
 
 
-#include "rtl8188e/odm_RegConfig8188E.h"
-#include "rtl8188e/odm_RTL8188E.h"
+#include "rtl8188e/phydm_RegConfig8188E.h"
+#include "rtl8188e/phydm_RTL8188E.h"
 #endif
 
 #if (RTL8192E_SUPPORT==1) 
@@ -258,8 +258,8 @@
 #include "rtl8192e/HalHWImg8192E_BB.h"
 #include "rtl8192e/HalHWImg8192E_FW.h"
 #include "rtl8192e/Hal8192EReg.h"
-#include "rtl8192e/odm_RegConfig8192E.h"
-#include "rtl8192e/odm_RTL8192E.h"
+#include "rtl8192e/phydm_RegConfig8192E.h"
+#include "rtl8192e/phydm_RTL8192E.h"
 #endif
 
 #if (RTL8723B_SUPPORT==1) 
@@ -269,8 +269,8 @@
 #include "rtl8723b/HalHWImg8723B_FW.h"
 #include "rtl8723b/HalHWImg8723B_MP.h"
 #include "rtl8723b/Hal8723BReg.h"
-#include "rtl8723b/odm_RTL8723B.h"
-#include "rtl8723b/odm_RegConfig8723B.h"
+#include "rtl8723b/phydm_RTL8723B.h"
+#include "rtl8723b/phydm_RegConfig8723B.h"
 #endif
 
 #if (RTL8812A_SUPPORT==1) 
@@ -278,13 +278,8 @@
 #include "rtl8812a/HalHWImg8812A_RF.h"
 #include "rtl8812a/HalHWImg8812A_BB.h"
 #include "rtl8812a/HalHWImg8812A_FW.h"
-#include "rtl8812a/odm_RegConfig8812A.h"
-#include "rtl8812a/odm_RTL8812A.h"
-#if (TESTCHIP_SUPPORT == 1) 
-#include "rtl8812a/HalHWImg8812A_TestChip_MAC.h"
-#include "rtl8812a/HalHWImg8812A_TestChip_RF.h"
-#include "rtl8812a/HalHWImg8812A_TestChip_BB.h"
-#endif
+#include "rtl8812a/phydm_RegConfig8812A.h"
+#include "rtl8812a/phydm_RTL8812A.h"
 #endif
 
 
@@ -293,14 +288,8 @@
 #include "rtl8821a/HalHWImg8821A_RF.h"
 #include "rtl8821a/HalHWImg8821A_BB.h"
 #include "rtl8821a/HalHWImg8821A_FW.h"
-#include "rtl8821a/odm_RegConfig8821A.h"
-#include "rtl8821a/odm_RTL8821A.h"
-#if (TESTCHIP_SUPPORT == 1) 
-#include "rtl8821a/HalHWImg8821A_TestChip_MAC.h"
-#include "rtl8821a/HalHWImg8821A_TestChip_RF.h"
-#include "rtl8821a/HalHWImg8821A_TestChip_BB.h"
-#include "rtl8821a/HalHWImg8821A_TestChip_FW.h"
-#endif
+#include "rtl8821a/phydm_RegConfig8821A.h"
+#include "rtl8821a/phydm_RTL8821A.h"
 #endif
 
 #endif	// __ODM_PRECOMP_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_reg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_reg.h
new file mode 100644
index 000000000000..8deff91364f4
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_reg.h
@@ -0,0 +1,208 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+//============================================================
+// File Name: odm_reg.h
+//
+// Description:
+//
+// This file is for general register definition.
+//
+//
+//============================================================
+#ifndef	__HAL_ODM_REG_H__
+#define __HAL_ODM_REG_H__
+
+//
+// Register Definition
+//
+
+//MAC REG
+#define	ODM_BB_RESET					0x002
+#define	ODM_DUMMY						0x4fe
+#define	RF_T_METER_OLD				0x24
+#define	RF_T_METER_NEW				0x42
+
+#define	ODM_EDCA_VO_PARAM			0x500
+#define	ODM_EDCA_VI_PARAM			0x504
+#define	ODM_EDCA_BE_PARAM			0x508
+#define	ODM_EDCA_BK_PARAM			0x50C
+#define	ODM_TXPAUSE					0x522
+
+//BB REG
+#define	ODM_FPGA_PHY0_PAGE8			0x800
+#define	ODM_PSD_SETTING				0x808
+#define	ODM_AFE_SETTING				0x818
+#define	ODM_TXAGC_B_6_18				0x830
+#define	ODM_TXAGC_B_24_54			0x834
+#define	ODM_TXAGC_B_MCS32_5			0x838
+#define	ODM_TXAGC_B_MCS0_MCS3		0x83c
+#define	ODM_TXAGC_B_MCS4_MCS7		0x848
+#define	ODM_TXAGC_B_MCS8_MCS11		0x84c
+#define	ODM_ANALOG_REGISTER			0x85c
+#define	ODM_RF_INTERFACE_OUTPUT		0x860
+#define	ODM_TXAGC_B_MCS12_MCS15	0x868
+#define	ODM_TXAGC_B_11_A_2_11		0x86c
+#define	ODM_AD_DA_LSB_MASK			0x874
+#define	ODM_ENABLE_3_WIRE			0x88c
+#define	ODM_PSD_REPORT				0x8b4
+#define	ODM_R_ANT_SELECT				0x90c
+#define	ODM_CCK_ANT_SELECT			0xa07
+#define	ODM_CCK_PD_THRESH			0xa0a
+#define	ODM_CCK_RF_REG1				0xa11
+#define	ODM_CCK_MATCH_FILTER			0xa20
+#define	ODM_CCK_RAKE_MAC				0xa2e
+#define	ODM_CCK_CNT_RESET			0xa2d
+#define	ODM_CCK_TX_DIVERSITY			0xa2f
+#define	ODM_CCK_FA_CNT_MSB			0xa5b
+#define	ODM_CCK_FA_CNT_LSB			0xa5c
+#define	ODM_CCK_NEW_FUNCTION		0xa75
+#define	ODM_OFDM_PHY0_PAGE_C		0xc00
+#define	ODM_OFDM_RX_ANT				0xc04
+#define	ODM_R_A_RXIQI					0xc14
+#define	ODM_R_A_AGC_CORE1			0xc50
+#define	ODM_R_A_AGC_CORE2			0xc54
+#define	ODM_R_B_AGC_CORE1			0xc58
+#define	ODM_R_AGC_PAR					0xc70
+#define	ODM_R_HTSTF_AGC_PAR			0xc7c
+#define	ODM_TX_PWR_TRAINING_A		0xc90
+#define	ODM_TX_PWR_TRAINING_B		0xc98
+#define	ODM_OFDM_FA_CNT1				0xcf0
+#define	ODM_OFDM_PHY0_PAGE_D		0xd00
+#define	ODM_OFDM_FA_CNT2				0xda0
+#define	ODM_OFDM_FA_CNT3				0xda4
+#define	ODM_OFDM_FA_CNT4				0xda8
+#define	ODM_TXAGC_A_6_18				0xe00
+#define	ODM_TXAGC_A_24_54			0xe04
+#define	ODM_TXAGC_A_1_MCS32			0xe08
+#define	ODM_TXAGC_A_MCS0_MCS3		0xe10
+#define	ODM_TXAGC_A_MCS4_MCS7		0xe14
+#define	ODM_TXAGC_A_MCS8_MCS11		0xe18
+#define	ODM_TXAGC_A_MCS12_MCS15		0xe1c
+
+//RF REG
+#define	ODM_GAIN_SETTING				0x00
+#define	ODM_CHANNEL					0x18
+#define	ODM_RF_T_METER				0x24
+#define	ODM_RF_T_METER_92D			0x42
+#define	ODM_RF_T_METER_88E			0x42
+#define	ODM_RF_T_METER_92E			0x42
+#define	ODM_RF_T_METER_8812			0x42
+
+//Ant Detect Reg
+#define	ODM_DPDT						0x300
+
+//PSD Init
+#define	ODM_PSDREG					0x808
+
+//92D Path Div
+#define	PATHDIV_REG					0xB30
+#define	PATHDIV_TRI					0xBA0
+
+
+//
+// Bitmap Definition
+//
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP))
+// TX AGC 
+#define		rTxAGC_A_CCK11_CCK1_JAguar	0xc20
+#define		rTxAGC_A_Ofdm18_Ofdm6_JAguar	0xc24
+#define		rTxAGC_A_Ofdm54_Ofdm24_JAguar	0xc28
+#define		rTxAGC_A_MCS3_MCS0_JAguar	0xc2c
+#define		rTxAGC_A_MCS7_MCS4_JAguar	0xc30
+#define		rTxAGC_A_MCS11_MCS8_JAguar	0xc34
+#define		rTxAGC_A_MCS15_MCS12_JAguar	0xc38
+#define		rTxAGC_A_Nss1Index3_Nss1Index0_JAguar	0xc3c
+#define		rTxAGC_A_Nss1Index7_Nss1Index4_JAguar	0xc40
+#define		rTxAGC_A_Nss2Index1_Nss1Index8_JAguar	0xc44
+#define		rTxAGC_A_Nss2Index5_Nss2Index2_JAguar	0xc48
+#define		rTxAGC_A_Nss2Index9_Nss2Index6_JAguar	0xc4c
+#if defined(CONFIG_WLAN_HAL_8814AE)
+#define		rTxAGC_A_MCS19_MCS16_JAguar	0xcd8
+#define		rTxAGC_A_MCS23_MCS20_JAguar	0xcdc
+#define		rTxAGC_A_Nss3Index3_Nss3Index0_JAguar	0xce0
+#define		rTxAGC_A_Nss3Index7_Nss3Index4_JAguar	0xce4
+#define		rTxAGC_A_Nss3Index9_Nss3Index8_JAguar	0xce8
+#endif
+#define		rTxAGC_B_CCK11_CCK1_JAguar	0xe20
+#define		rTxAGC_B_Ofdm18_Ofdm6_JAguar	0xe24
+#define		rTxAGC_B_Ofdm54_Ofdm24_JAguar	0xe28
+#define		rTxAGC_B_MCS3_MCS0_JAguar	0xe2c
+#define		rTxAGC_B_MCS7_MCS4_JAguar	0xe30
+#define		rTxAGC_B_MCS11_MCS8_JAguar	0xe34
+#define		rTxAGC_B_MCS15_MCS12_JAguar	0xe38
+#define		rTxAGC_B_Nss1Index3_Nss1Index0_JAguar	0xe3c
+#define		rTxAGC_B_Nss1Index7_Nss1Index4_JAguar	0xe40
+#define		rTxAGC_B_Nss2Index1_Nss1Index8_JAguar	0xe44
+#define		rTxAGC_B_Nss2Index5_Nss2Index2_JAguar	0xe48
+#define		rTxAGC_B_Nss2Index9_Nss2Index6_JAguar	0xe4c
+#if defined(CONFIG_WLAN_HAL_8814AE)
+#define		rTxAGC_B_MCS19_MCS16_JAguar	0xed8
+#define		rTxAGC_B_MCS23_MCS20_JAguar	0xedc
+#define		rTxAGC_B_Nss3Index3_Nss3Index0_JAguar	0xee0
+#define		rTxAGC_B_Nss3Index7_Nss3Index4_JAguar	0xee4
+#define		rTxAGC_B_Nss3Index9_Nss3Index8_JAguar	0xee8
+#define		rTxAGC_C_CCK11_CCK1_JAguar	0x1820
+#define		rTxAGC_C_Ofdm18_Ofdm6_JAguar	0x1824
+#define		rTxAGC_C_Ofdm54_Ofdm24_JAguar	0x1828
+#define		rTxAGC_C_MCS3_MCS0_JAguar	0x182c
+#define		rTxAGC_C_MCS7_MCS4_JAguar	0x1830
+#define		rTxAGC_C_MCS11_MCS8_JAguar	0x1834
+#define		rTxAGC_C_MCS15_MCS12_JAguar	0x1838
+#define		rTxAGC_C_Nss1Index3_Nss1Index0_JAguar	0x183c
+#define		rTxAGC_C_Nss1Index7_Nss1Index4_JAguar	0x1840
+#define		rTxAGC_C_Nss2Index1_Nss1Index8_JAguar	0x1844
+#define		rTxAGC_C_Nss2Index5_Nss2Index2_JAguar	0x1848
+#define		rTxAGC_C_Nss2Index9_Nss2Index6_JAguar	0x184c
+#define		rTxAGC_C_MCS19_MCS16_JAguar	0x18d8
+#define		rTxAGC_C_MCS23_MCS20_JAguar	0x18dc
+#define		rTxAGC_C_Nss3Index3_Nss3Index0_JAguar	0x18e0
+#define		rTxAGC_C_Nss3Index7_Nss3Index4_JAguar	0x18e4
+#define		rTxAGC_C_Nss3Index9_Nss3Index8_JAguar	0x18e8
+#define		rTxAGC_D_CCK11_CCK1_JAguar	0x1a20
+#define		rTxAGC_D_Ofdm18_Ofdm6_JAguar	0x1a24
+#define		rTxAGC_D_Ofdm54_Ofdm24_JAguar	0x1a28
+#define		rTxAGC_D_MCS3_MCS0_JAguar	0x1a2c
+#define		rTxAGC_D_MCS7_MCS4_JAguar	0x1a30
+#define		rTxAGC_D_MCS11_MCS8_JAguar	0x1a34
+#define		rTxAGC_D_MCS15_MCS12_JAguar	0x1a38
+#define		rTxAGC_D_Nss1Index3_Nss1Index0_JAguar	0x1a3c
+#define		rTxAGC_D_Nss1Index7_Nss1Index4_JAguar	0x1a40
+#define		rTxAGC_D_Nss2Index1_Nss1Index8_JAguar	0x1a44
+#define		rTxAGC_D_Nss2Index5_Nss2Index2_JAguar	0x1a48
+#define		rTxAGC_D_Nss2Index9_Nss2Index6_JAguar	0x1a4c
+#define		rTxAGC_D_MCS19_MCS16_JAguar	0x1ad8
+#define		rTxAGC_D_MCS23_MCS20_JAguar	0x1adc
+#define		rTxAGC_D_Nss3Index3_Nss3Index0_JAguar	0x1ae0
+#define		rTxAGC_D_Nss3Index7_Nss3Index4_JAguar	0x1ae4
+#define		rTxAGC_D_Nss3Index9_Nss3Index8_JAguar	0x1ae8
+#endif
+
+#define		bTxAGC_byte0_Jaguar	0xff
+#define		bTxAGC_byte1_Jaguar	0xff00
+#define		bTxAGC_byte2_Jaguar	0xff0000
+#define		bTxAGC_byte3_Jaguar	0xff000000
+#endif
+
+#define	BIT_FA_RESET					BIT0
+
+
+
+#endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_types.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_types.h
similarity index 61%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_types.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_types.h
index 27cecceeec61..ddeb1a8a8a1f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/odm_types.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/phydm_types.h
@@ -20,6 +20,101 @@
 #ifndef __ODM_TYPES_H__
 #define __ODM_TYPES_H__
 
+
+
+
+#define ODM_RATEMCS15_SG		0x1c
+#define ODM_RATEMCS32			0x20
+
+
+// CCK Rates, TxHT = 0
+#define ODM_RATE1M				0x00
+#define ODM_RATE2M				0x01
+#define ODM_RATE5_5M			0x02
+#define ODM_RATE11M				0x03
+// OFDM Rates, TxHT = 0
+#define ODM_RATE6M				0x04
+#define ODM_RATE9M				0x05
+#define ODM_RATE12M				0x06
+#define ODM_RATE18M				0x07
+#define ODM_RATE24M				0x08
+#define ODM_RATE36M				0x09
+#define ODM_RATE48M				0x0A
+#define ODM_RATE54M				0x0B
+// MCS Rates, TxHT = 1
+#define ODM_RATEMCS0			0x0C
+#define ODM_RATEMCS1			0x0D
+#define ODM_RATEMCS2			0x0E
+#define ODM_RATEMCS3			0x0F
+#define ODM_RATEMCS4			0x10
+#define ODM_RATEMCS5			0x11
+#define ODM_RATEMCS6			0x12
+#define ODM_RATEMCS7			0x13
+#define ODM_RATEMCS8			0x14
+#define ODM_RATEMCS9			0x15
+#define ODM_RATEMCS10			0x16
+#define ODM_RATEMCS11			0x17
+#define ODM_RATEMCS12			0x18
+#define ODM_RATEMCS13			0x19
+#define ODM_RATEMCS14			0x1A
+#define ODM_RATEMCS15			0x1B
+#define ODM_RATEMCS16			0x1C
+#define ODM_RATEMCS17			0x1D
+#define ODM_RATEMCS18			0x1E
+#define ODM_RATEMCS19			0x1F
+#define ODM_RATEMCS20			0x20
+#define ODM_RATEMCS21			0x21
+#define ODM_RATEMCS22			0x22
+#define ODM_RATEMCS23			0x23
+#define ODM_RATEMCS24			0x24
+#define ODM_RATEMCS25			0x25
+#define ODM_RATEMCS26			0x26
+#define ODM_RATEMCS27			0x27
+#define ODM_RATEMCS28			0x28
+#define ODM_RATEMCS29			0x29
+#define ODM_RATEMCS30			0x2A
+#define ODM_RATEMCS31			0x2B
+#define ODM_RATEVHTSS1MCS0		0x2C
+#define ODM_RATEVHTSS1MCS1		0x2D
+#define ODM_RATEVHTSS1MCS2		0x2E
+#define ODM_RATEVHTSS1MCS3		0x2F
+#define ODM_RATEVHTSS1MCS4		0x30
+#define ODM_RATEVHTSS1MCS5		0x31
+#define ODM_RATEVHTSS1MCS6		0x32
+#define ODM_RATEVHTSS1MCS7		0x33
+#define ODM_RATEVHTSS1MCS8		0x34
+#define ODM_RATEVHTSS1MCS9		0x35
+#define ODM_RATEVHTSS2MCS0		0x36
+#define ODM_RATEVHTSS2MCS1		0x37
+#define ODM_RATEVHTSS2MCS2		0x38
+#define ODM_RATEVHTSS2MCS3		0x39
+#define ODM_RATEVHTSS2MCS4		0x3A
+#define ODM_RATEVHTSS2MCS5		0x3B
+#define ODM_RATEVHTSS2MCS6		0x3C
+#define ODM_RATEVHTSS2MCS7		0x3D
+#define ODM_RATEVHTSS2MCS8		0x3E
+#define ODM_RATEVHTSS2MCS9		0x3F
+#define ODM_RATEVHTSS3MCS0		0x40
+#define ODM_RATEVHTSS3MCS1		0x41
+#define ODM_RATEVHTSS3MCS2		0x42
+#define ODM_RATEVHTSS3MCS3		0x43
+#define ODM_RATEVHTSS3MCS4		0x44
+#define ODM_RATEVHTSS3MCS5		0x45
+#define ODM_RATEVHTSS3MCS6		0x46
+#define ODM_RATEVHTSS3MCS7		0x47
+#define ODM_RATEVHTSS3MCS8		0x48
+#define ODM_RATEVHTSS3MCS9		0x49
+#define ODM_RATEVHTSS4MCS0		0x4A
+#define ODM_RATEVHTSS4MCS1		0x4B
+#define ODM_RATEVHTSS4MCS2		0x4C
+#define ODM_RATEVHTSS4MCS3		0x4D
+#define ODM_RATEVHTSS4MCS4		0x4E
+#define ODM_RATEVHTSS4MCS5		0x4F
+#define ODM_RATEVHTSS4MCS6		0x50
+#define ODM_RATEVHTSS4MCS7		0x51
+#define ODM_RATEVHTSS4MCS8		0x52
+#define ODM_RATEVHTSS4MCS9		0x53
+
 //
 // Define Different SW team support
 //
@@ -34,6 +129,12 @@
 #define	ODM_ENDIAN_BIG	0
 #define	ODM_ENDIAN_LITTLE	1
 
+#if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
+#define GET_PDM_ODM(__pAdapter)	((PDM_ODM_T)(&((GET_HAL_DATA(__pAdapter))->DM_OutSrc)))
+#elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
+#define GET_PDM_ODM(__pAdapter)	((PDM_ODM_T)(&((GET_HAL_DATA(__pAdapter))->odmpriv)))
+#endif
+
 #if (DM_ODM_SUPPORT_TYPE != ODM_WIN)
 #define 	RT_PCI_INTERFACE				1
 #define 	RT_USB_INTERFACE				2
@@ -51,8 +152,10 @@ typedef enum _HAL_STATUS{
 	RT_STATUS_OS_API_FAILED,*/
 }HAL_STATUS,*PHAL_STATUS;
 
-
-#if( (DM_ODM_SUPPORT_TYPE == ODM_AP) ||(DM_ODM_SUPPORT_TYPE == ODM_ADSL) || (DM_ODM_SUPPORT_TYPE == ODM_CE))
+#if( DM_ODM_SUPPORT_TYPE == ODM_AP)
+#define		MP_DRIVER		0
+#endif
+#if(DM_ODM_SUPPORT_TYPE != ODM_WIN)
 
 #define		VISTA_USB_RX_REVISE			0
 
@@ -77,6 +180,8 @@ typedef enum _RT_SPINLOCK_TYPE{
 #endif
 	//Shall we define Ndis 6.2 SpinLock Here ?
 	RT_PORT_SPINLOCK=16,
+	RT_VNIC_SPINLOCK=17,
+	RT_HVL_SPINLOCK=18,	
 	RT_H2C_SPINLOCK = 20, // For H2C cmd. Added by tynli. 2009.11.09.
 
 	RT_BTData_SPINLOCK=25,
@@ -99,6 +204,8 @@ typedef enum _RT_SPINLOCK_TYPE{
 	RT_PENDED_OID_SPINLOCK = 39,
 	RT_CHNLLIST_SPINLOCK = 40,	
 	RT_INDIC_SPINLOCK = 41,	//protect indication	
+	RT_RFD_SPINLOCK = 42,
+	RT_LAST_SPINLOCK,
 }RT_SPINLOCK_TYPE;
 
 #endif
@@ -117,9 +224,29 @@ typedef enum _RT_SPINLOCK_TYPE{
 	// To let ADSL/AP project compile ok; it should be removed after all conflict are solved. Added by Annie, 2011-10-07.
 	#define ADSL_AP_BUILD_WORKAROUND
 	#define AP_BUILD_WORKAROUND
-	//
-#ifdef CONFIG_ANT_SWITCH
+	
+	//2 [ Configure Antenna Diversity ]
+#if defined(CONFIG_RTL_8881A_ANT_SWITCH) || defined(CONFIG_SLOT_0_ANT_SWITCH) || defined(CONFIG_SLOT_1_ANT_SWITCH)
 	#define CONFIG_HW_ANTENNA_DIVERSITY 
+	#define ODM_EVM_ENHANCE_ANTDIV
+
+        //----------
+	#if(!defined(CONFIG_NO_2G_DIVERSITY) && !defined(CONFIG_2G_CGCS_RX_DIVERSITY) && !defined(CONFIG_2G_CG_TRX_DIVERSITY) && !defined(CONFIG_2G_CG_SMART_ANT_DIVERSITY))
+		#define CONFIG_NO_2G_DIVERSITY
+	#endif
+
+	#ifdef CONFIG_NO_5G_DIVERSITY_8881A
+		#define CONFIG_NO_5G_DIVERSITY
+	#elif  defined(CONFIG_5G_CGCS_RX_DIVERSITY_8881A)
+		#define CONFIG_5G_CGCS_RX_DIVERSITY
+	#elif  defined(CONFIG_5G_CG_TRX_DIVERSITY_8881A)
+		#define CONFIG_5G_CG_TRX_DIVERSITY
+	#endif
+
+	#if(!defined(CONFIG_NO_5G_DIVERSITY) && !defined(CONFIG_5G_CGCS_RX_DIVERSITY) && !defined(CONFIG_5G_CG_TRX_DIVERSITY) && !defined(CONFIG_5G_CG_SMART_ANT_DIVERSITY))
+		#define CONFIG_NO_5G_DIVERSITY
+	#endif	
+	//----------
 	#if ( defined(CONFIG_NO_2G_DIVERSITY) && defined(CONFIG_NO_5G_DIVERSITY) )
 		#define CONFIG_NOT_SUPPORT_ANTDIV 
 	#elif( !defined(CONFIG_NO_2G_DIVERSITY) && defined(CONFIG_NO_5G_DIVERSITY) )
@@ -129,8 +256,8 @@ typedef enum _RT_SPINLOCK_TYPE{
 	#elif( !defined(CONFIG_NO_2G_DIVERSITY) && !defined(CONFIG_NO_5G_DIVERSITY) )
 		#define CONFIG_2G5G_SUPPORT_ANTDIV 
 	#endif
+	//----------
 #endif
-
 	#ifdef AP_BUILD_WORKAROUND
 	#include "../typedef.h"
 	#else
@@ -140,7 +267,13 @@ typedef enum _RT_SPINLOCK_TYPE{
 	typedef unsigned short			u2Byte,*pu2Byte;
 	typedef unsigned int			u4Byte,*pu4Byte;
 	typedef unsigned long long		u8Byte,*pu8Byte;
+#if 1
+/* In ARM platform, system would use the type -- "char" as "unsigned char"
+ * And we only use s1Byte/ps1Byte as INT8 now, so changes the type of s1Byte.*/
+    typedef signed char				s1Byte,*ps1Byte;
+#else
 	typedef char					s1Byte,*ps1Byte;
+#endif
 	typedef short					s2Byte,*ps2Byte;
 	typedef long					s4Byte,*ps4Byte;
 	typedef long long				s8Byte,*ps8Byte;
@@ -151,7 +284,9 @@ typedef enum _RT_SPINLOCK_TYPE{
 	typedef struct timer_list		RT_TIMER, *PRT_TIMER;
 	typedef  void *				RT_TIMER_CALL_BACK;
 
+#ifdef CONFIG_PCI_HCI
 	#define DEV_BUS_TYPE		RT_PCI_INTERFACE
+#endif
 
 	#define _TRUE				1
 	#define _FALSE				0
@@ -168,7 +303,13 @@ typedef enum _RT_SPINLOCK_TYPE{
 	typedef unsigned short			u2Byte,*pu2Byte;
 	typedef unsigned int			u4Byte,*pu4Byte;
 	typedef unsigned long long		u8Byte,*pu8Byte;
+#if 1
+/* In ARM platform, system would use the type -- "char" as "unsigned char"
+ * And we only use s1Byte/ps1Byte as INT8 now, so changes the type of s1Byte.*/
+    typedef signed char				s1Byte,*ps1Byte;
+#else
 	typedef char					s1Byte,*ps1Byte;
+#endif
 	typedef short					s2Byte,*ps2Byte;
 	typedef long					s4Byte,*ps4Byte;
 	typedef long long				s8Byte,*ps8Byte;
@@ -260,6 +401,9 @@ typedef enum _RT_SPINLOCK_TYPE{
 	#define	RTL8881A_SUPPORT	0
 #endif
 
+#define READ_NEXT_PAIR(v1, v2, i) do { if (i+2 >= ArrayLen) break; i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
+#define COND_ELSE  2
+#define COND_ENDIF 3
 
 #endif // __ODM_TYPES_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Hal8188ERateAdaptive.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Hal8188ERateAdaptive.c
index bda8ad87db47..0f128d161ab8 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Hal8188ERateAdaptive.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Hal8188ERateAdaptive.c
@@ -13,9 +13,9 @@ Major Change History:
 	2011-08-12 Page            Create.	
 
 --*/
+#include "Mp_Precomp.h"
 
-
-#include "../odm_precomp.h"
+#include "../phydm_precomp.h"
 
 
 #if (RATE_ADAPTIVE_SUPPORT == 1)
@@ -565,6 +565,7 @@ odm_ARFBRefresh_8188E(
 #if POWER_TRAINING_ACTIVE == 1
 static void 
 odm_PTTryState_8188E(
+	IN	PDM_ODM_T		pDM_Odm,
 	IN 	PODM_RA_INFO_T 	pRaInfo
 	)
 {
@@ -621,6 +622,17 @@ odm_PTTryState_8188E(
 		pRaInfo->RAstage=0;
 	}
 	pRaInfo->PTPreRate=pRaInfo->DecisionRate;
+
+#if(DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE))
+	// Disable power training when noisy environment
+	if(pDM_Odm->bDisablePowerTraining)
+	{
+		ODM_RT_TRACE(pDM_Odm,ODM_COMP_RA_MASK, ODM_DBG_LOUD,("odm_PTTryState_8188E(): Disable power training when noisy environment\n"));
+		pRaInfo->PTStage = 0;
+		pRaInfo->RAstage = 0;
+		pRaInfo->PTStopCount = 0;
+	}
+#endif
 }
 
 static void 
@@ -703,10 +715,12 @@ ODM_RASupport_Init(
 		//I Cut: FALSE(FW RA); Ohterwise: TRUE(Driver RA)
 		pDM_Odm->RaSupport88E = (pDM_Odm->Adapter->RASupport == TRUE);
 #elif (DM_ODM_SUPPORT_TYPE == ODM_CE)
-		if(pDM_Odm->CutVersion == ODM_CUT_I)//I Cut use FW RA
-			pDM_Odm->RaSupport88E = FALSE;
-		else
-			pDM_Odm->RaSupport88E = TRUE;
+		{	
+			PADAPTER 		Adapter = pDM_Odm->Adapter;
+			HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+			pDM_Odm->RaSupport88E = (TRUE == pHalData->fw_ractrl)?FALSE:TRUE;
+			
+		}
 #endif
 	}
 }
@@ -1037,12 +1051,11 @@ ODM_RA_TxRPT2Handle_8188E(
 
 	do
 	{
-		if(MacId >= ASSOCIATE_ENTRY_NUM)
-			valid = 0;
-		else if(MacId >= 32)
-			valid = (1<<(MacId-32)) & MacIDValidEntry1;
-		else
+		valid = 0;
+		if(MacId < 32)
 			valid = (1<<MacId) & MacIDValidEntry0;
+		else if(MacId < 64)
+			valid = (1<<(MacId-32)) & MacIDValidEntry1;
 
 		if(valid)
 		{
@@ -1081,7 +1094,7 @@ ODM_RA_TxRPT2Handle_8188E(
 						odm_RateDecision_8188E(pDM_Odm,pRAInfo);
 					}
 					else if(pRAInfo->RAstage==5){  // Power training try state
-						odm_PTTryState_8188E(pRAInfo);
+						odm_PTTryState_8188E(pDM_Odm, pRAInfo);
 					}
 					else {// RAstage==6
 						odm_PTDecision_8188E(pRAInfo);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Hal8188EReg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Hal8188EReg.h
index f5401453ffa4..aeb4e76d55fd 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Hal8188EReg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Hal8188EReg.h
@@ -41,7 +41,7 @@
 // Bitmap Definition
 //
 #define	BIT_FA_RESET_8188E			BIT0
-
+#define 	REG_ADAPTIVE_DATA_RATE_0		0x2B0
 #define	REG_DBI_WDATA_8188			0x0348	// DBI Write Data
 #define	REG_DBI_RDATA_8188			0x034C	// DBI Read Data
 #define	REG_DBI_ADDR_8188			0x0350	// DBI Address
@@ -50,5 +50,8 @@
 #define	REG_MDIO_RDATA_8188E		0x0356	// MDIO for Reads PCIE PHY
 #define	REG_MDIO_CTL_8188E			0x0358	// MDIO for Control
 
+// [0-63]
+#define	REG_MACID_NO_LINK			0x484	// No Link register (bit[x] enabled means dropping packets for MACID in HW queue)
+
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.c
index 48945bfa2a10..947281450efb 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.c
@@ -18,55 +18,150 @@
 * 
 ******************************************************************************/
 
-#include "../odm_precomp.h"
-
-#ifdef CONFIG_IOL_IOREG_CFG
-#include <rtw_iol.h>
-#endif
+#include "Mp_Precomp.h"
+#include "../phydm_precomp.h"
 
 #if (RTL8188E_SUPPORT == 1)
 static BOOLEAN
-CheckCondition(
-    const u4Byte  Condition,
-    const u4Byte  Hex
+CheckPositive(
+    IN  PDM_ODM_T     pDM_Odm,
+    IN  const u4Byte  Condition1,
+    IN  const u4Byte  Condition2
     )
 {
-    u4Byte _board     = (Hex & 0x000000FF);
-    u4Byte _interface = (Hex & 0x0000FF00) >> 8;
-    u4Byte _platform  = (Hex & 0x00FF0000) >> 16;
-    u4Byte cond = Condition;
+    u1Byte    _BoardType = ((pDM_Odm->BoardType & BIT4) >> 4) << 0 | // _GLNA
+                           ((pDM_Odm->BoardType & BIT3) >> 3) << 1 | // _GPA 
+                           ((pDM_Odm->BoardType & BIT7) >> 7) << 2 | // _ALNA
+                           ((pDM_Odm->BoardType & BIT6) >> 6) << 3 | // _APA 
+                           ((pDM_Odm->BoardType & BIT2) >> 2) << 4;  // _BT  
 
-    if ( Condition == 0xCDCDCDCD )
-        return TRUE;
+	u4Byte 	  cond1   = Condition1, cond2 = Condition2;
+	u4Byte    driver1 = pDM_Odm->CutVersion       << 24 |  
+		                pDM_Odm->SupportPlatform  << 16 | 
+		                pDM_Odm->PackageType      << 12 | 
+		                pDM_Odm->SupportInterface << 8  |
+		                _BoardType;
 
-    cond = Condition & 0x000000FF;
-    if ( (_board != cond) && (cond != 0xFF) )
-        return FALSE;
+	u4Byte    driver2 = pDM_Odm->TypeGLNA <<  0 |  
+		                pDM_Odm->TypeGPA  <<  8 | 
+		                pDM_Odm->TypeALNA << 16 | 
+		                pDM_Odm->TypeAPA  << 24; 
 
-    cond = Condition & 0x0000FF00;
-    cond = cond >> 8;
-    if ( ((_interface & cond) == 0) && (cond != 0x07) )
-        return FALSE;
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("===> [8812A] CheckPositive (cond1, cond2) = (0x%X 0x%X)\n", cond1, cond2));
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("===> [8812A] CheckPositive (driver1, driver2) = (0x%X 0x%X)\n", driver1, driver2));
+
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("	(Platform, Interface) = (0x%X, 0x%X)\n", pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface));
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("	(Board, Package) = (0x%X, 0x%X)\n", pDM_Odm->BoardType, pDM_Odm->PackageType));
+
+
+	//============== Value Defined Check ===============//
+	//QFN Type [15:12] and Cut Version [27:24] need to do value check
+	
+	if(((cond1 & 0x0000F000) != 0) &&((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return FALSE;
+	if(((cond1 & 0x0F000000) != 0) &&((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return FALSE;		
+
+	//=============== Bit Defined Check ================//
+    // We don't care [31:28] and [23:20]
+    //
+	cond1   &= 0x000F0FFF; 
+	driver1 &= 0x000F0FFF; 
 
-    cond = Condition & 0x00FF0000;
-    cond = cond >> 16;
-    if ( ((_platform & cond) == 0) && (cond != 0x0F) )
+    if ((cond1 & driver1) == cond1) 
+    {
+        u4Byte bitMask = 0;
+        if ((cond1 & 0x0F) == 0) // BoardType is DONTCARE
+            return TRUE;
+
+        if ((cond1 & BIT0) != 0) //GLNA
+            bitMask |= 0x000000FF;
+        if ((cond1 & BIT1) != 0) //GPA
+            bitMask |= 0x0000FF00;
+        if ((cond1 & BIT2) != 0) //ALNA
+            bitMask |= 0x00FF0000;
+        if ((cond1 & BIT3) != 0) //APA
+            bitMask |= 0xFF000000;
+
+        if ((cond2 & bitMask) == (driver2 & bitMask)) // BoardType of each RF path is matched
+            return TRUE;
+        else
+            return FALSE;
+    }
+    else 
+    {
         return FALSE;
+    }
+}
+static BOOLEAN
+CheckNegative(
+    IN  PDM_ODM_T     pDM_Odm,
+    IN  const u4Byte  Condition1,
+    IN  const u4Byte  Condition2
+    )
+{
     return TRUE;
 }
 
-
 /******************************************************************************
-*                           AGC_TAB_1T.TXT
+*                           AGC_TAB.TXT
 ******************************************************************************/
 
-u4Byte Array_MP_8188E_AGC_TAB_1T[] = { 
-	0xFF0F0718, 0xABCD,
+u4Byte Array_MP_8188E_AGC_TAB[] = { 
+	0x88000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0xF6000001,
+		0xC78, 0xF5010001,
+		0xC78, 0xF4020001,
+		0xC78, 0xF3030001,
+		0xC78, 0xF2040001,
+	0x90000001,0x00000000,0x40000000,0x00000000,
 		0xC78, 0xF7000001,
 		0xC78, 0xF6010001,
 		0xC78, 0xF5020001,
 		0xC78, 0xF4030001,
 		0xC78, 0xF3040001,
+	0xA0000000,0x00000000,
+		0xC78, 0xFB000001,
+		0xC78, 0xFB010001,
+		0xC78, 0xFB020001,
+		0xC78, 0xFB030001,
+		0xC78, 0xFB040001,
+	0xB0000000,0x00000000,
+	0x88000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0xF1050001,
+		0xC78, 0xF0060001,
+		0xC78, 0xEF070001,
+		0xC78, 0xEE080001,
+		0xC78, 0xED090001,
+		0xC78, 0xEC0A0001,
+		0xC78, 0xEB0B0001,
+		0xC78, 0xEA0C0001,
+		0xC78, 0xE90D0001,
+		0xC78, 0xE80E0001,
+		0xC78, 0xE70F0001,
+		0xC78, 0xE6100001,
+		0xC78, 0xE5110001,
+		0xC78, 0xE4120001,
+		0xC78, 0xE3130001,
+		0xC78, 0xE2140001,
+		0xC78, 0xC5150001,
+		0xC78, 0xC4160001,
+		0xC78, 0xC3170001,
+		0xC78, 0xC2180001,
+		0xC78, 0x88190001,
+		0xC78, 0x871A0001,
+		0xC78, 0x861B0001,
+		0xC78, 0x851C0001,
+		0xC78, 0x841D0001,
+		0xC78, 0x831E0001,
+		0xC78, 0x821F0001,
+		0xC78, 0x81200001,
+		0xC78, 0x80210001,
+	0x90000001,0x00000000,0x40000000,0x00000000,
 		0xC78, 0xF2050001,
 		0xC78, 0xF1060001,
 		0xC78, 0xF0070001,
@@ -96,42 +191,37 @@ u4Byte Array_MP_8188E_AGC_TAB_1T[] = {
 		0xC78, 0x811F0001,
 		0xC78, 0x6B200001,
 		0xC78, 0x6A210001,
-		0xC78, 0x69220001,
-		0xC78, 0x68230001,
-		0xC78, 0x67240001,
-		0xC78, 0x66250001,
-		0xC78, 0x65260001,
-		0xC78, 0x64270001,
-		0xC78, 0x63280001,
-		0xC78, 0x62290001,
-		0xC78, 0x612A0001,
-		0xC78, 0x462B0001,
-		0xC78, 0x452C0001,
-		0xC78, 0x442D0001,
-		0xC78, 0x432E0001,
-		0xC78, 0x422F0001,
-		0xC78, 0x41300001,
-		0xC78, 0x40310001,
-		0xC78, 0x40320001,
-		0xC78, 0x40330001,
-		0xC78, 0x40340001,
-		0xC78, 0x40350001,
-		0xC78, 0x40360001,
-		0xC78, 0x40370001,
-		0xC78, 0x40380001,
-		0xC78, 0x40390001,
-		0xC78, 0x403A0001,
-		0xC78, 0x403B0001,
-		0xC78, 0x403C0001,
-		0xC78, 0x403D0001,
-		0xC78, 0x403E0001,
-		0xC78, 0x403F0001,
-	0xCDCDCDCD, 0xCDCD,
-		0xC78, 0xFB000001,
-		0xC78, 0xFB010001,
-		0xC78, 0xFB020001,
-		0xC78, 0xFB030001,
-		0xC78, 0xFB040001,
+	0x98000000,0x00000000,0x40000000,0x00000000,
+		0xC78, 0xFA050001,
+		0xC78, 0xF9060001,
+		0xC78, 0xF8070001,
+		0xC78, 0xF7080001,
+		0xC78, 0xF6090001,
+		0xC78, 0xF50A0001,
+		0xC78, 0xF40B0001,
+		0xC78, 0xF30C0001,
+		0xC78, 0xF20D0001,
+		0xC78, 0xF10E0001,
+		0xC78, 0xF00F0001,
+		0xC78, 0xEF100001,
+		0xC78, 0xEE110001,
+		0xC78, 0xED120001,
+		0xC78, 0xEC130001,
+		0xC78, 0xEB140001,
+		0xC78, 0xEA150001,
+		0xC78, 0xE9160001,
+		0xC78, 0xE8170001,
+		0xC78, 0xE7180001,
+		0xC78, 0xE6190001,
+		0xC78, 0xE51A0001,
+		0xC78, 0xE41B0001,
+		0xC78, 0xC71C0001,
+		0xC78, 0xC61D0001,
+		0xC78, 0xC51E0001,
+		0xC78, 0xC41F0001,
+		0xC78, 0xC3200001,
+		0xC78, 0xC2210001,
+	0xA0000000,0x00000000,
 		0xC78, 0xFB050001,
 		0xC78, 0xFA060001,
 		0xC78, 0xF9070001,
@@ -161,6 +251,24 @@ u4Byte Array_MP_8188E_AGC_TAB_1T[] = {
 		0xC78, 0xE11F0001,
 		0xC78, 0x8A200001,
 		0xC78, 0x89210001,
+	0xB0000000,0x00000000,
+	0x88000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x66220001,
+		0xC78, 0x65230001,
+		0xC78, 0x64240001,
+		0xC78, 0x63250001,
+		0xC78, 0x62260001,
+		0xC78, 0x61270001,
+		0xC78, 0x60280001,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x69220001,
+		0xC78, 0x68230001,
+		0xC78, 0x67240001,
+		0xC78, 0x66250001,
+		0xC78, 0x65260001,
+		0xC78, 0x64270001,
+		0xC78, 0x63280001,
+	0xA0000000,0x00000000,
 		0xC78, 0x88220001,
 		0xC78, 0x87230001,
 		0xC78, 0x86240001,
@@ -168,10 +276,45 @@ u4Byte Array_MP_8188E_AGC_TAB_1T[] = {
 		0xC78, 0x84260001,
 		0xC78, 0x83270001,
 		0xC78, 0x82280001,
+	0xB0000000,0x00000000,
+	0x88000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x4A290001,
+		0xC78, 0x492A0001,
+		0xC78, 0x482B0001,
+		0xC78, 0x472C0001,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x62290001,
+		0xC78, 0x612A0001,
+		0xC78, 0x462B0001,
+		0xC78, 0x452C0001,
+	0x98000000,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x81290001,
+		0xC78, 0x242A0001,
+		0xC78, 0x232B0001,
+		0xC78, 0x222C0001,
+	0xA0000000,0x00000000,
 		0xC78, 0x6B290001,
 		0xC78, 0x6A2A0001,
 		0xC78, 0x692B0001,
 		0xC78, 0x682C0001,
+	0xB0000000,0x00000000,
+	0x88000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x462D0001,
+		0xC78, 0x452E0001,
+		0xC78, 0x442F0001,
+		0xC78, 0x43300001,
+		0xC78, 0x42310001,
+		0xC78, 0x41320001,
+		0xC78, 0x40330001,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x442D0001,
+		0xC78, 0x432E0001,
+		0xC78, 0x422F0001,
+		0xC78, 0x41300001,
+		0xC78, 0x40310001,
+		0xC78, 0x40320001,
+		0xC78, 0x40330001,
+	0xA0000000,0x00000000,
 		0xC78, 0x672D0001,
 		0xC78, 0x662E0001,
 		0xC78, 0x652F0001,
@@ -179,6 +322,44 @@ u4Byte Array_MP_8188E_AGC_TAB_1T[] = {
 		0xC78, 0x63310001,
 		0xC78, 0x62320001,
 		0xC78, 0x61330001,
+	0xB0000000,0x00000000,
+	0x88000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x40340001,
+		0xC78, 0x40350001,
+		0xC78, 0x40360001,
+		0xC78, 0x40370001,
+		0xC78, 0x40380001,
+		0xC78, 0x40390001,
+		0xC78, 0x403A0001,
+		0xC78, 0x403B0001,
+		0xC78, 0x403C0001,
+		0xC78, 0x403D0001,
+		0xC78, 0x403E0001,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x40340001,
+		0xC78, 0x40350001,
+		0xC78, 0x40360001,
+		0xC78, 0x40370001,
+		0xC78, 0x40380001,
+		0xC78, 0x40390001,
+		0xC78, 0x403A0001,
+		0xC78, 0x403B0001,
+		0xC78, 0x403C0001,
+		0xC78, 0x403D0001,
+		0xC78, 0x403E0001,
+	0x98000000,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x60340001,
+		0xC78, 0x4A350001,
+		0xC78, 0x49360001,
+		0xC78, 0x48370001,
+		0xC78, 0x47380001,
+		0xC78, 0x46390001,
+		0xC78, 0x453A0001,
+		0xC78, 0x443B0001,
+		0xC78, 0x433C0001,
+		0xC78, 0x423D0001,
+		0xC78, 0x413E0001,
+	0xA0000000,0x00000000,
 		0xC78, 0x46340001,
 		0xC78, 0x45350001,
 		0xC78, 0x44360001,
@@ -190,9 +371,50 @@ u4Byte Array_MP_8188E_AGC_TAB_1T[] = {
 		0xC78, 0x403C0001,
 		0xC78, 0x403D0001,
 		0xC78, 0x403E0001,
+	0xB0000000,0x00000000,
 		0xC78, 0x403F0001,
-	0xFF0F0718, 0xDEAD,
-	0xFF0F0718, 0xABCD,
+	0x88000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0xFB400001,
+		0xC78, 0xFA410001,
+		0xC78, 0xF9420001,
+		0xC78, 0xF8430001,
+		0xC78, 0xF7440001,
+		0xC78, 0xF6450001,
+		0xC78, 0xF5460001,
+		0xC78, 0xF4470001,
+		0xC78, 0xF3480001,
+		0xC78, 0xF2490001,
+		0xC78, 0xF14A0001,
+		0xC78, 0xF04B0001,
+		0xC78, 0xEF4C0001,
+		0xC78, 0xEE4D0001,
+		0xC78, 0xED4E0001,
+		0xC78, 0xEC4F0001,
+		0xC78, 0xEB500001,
+		0xC78, 0xEA510001,
+		0xC78, 0xE9520001,
+		0xC78, 0xE8530001,
+		0xC78, 0xE7540001,
+		0xC78, 0xE6550001,
+		0xC78, 0xE5560001,
+		0xC78, 0xC6570001,
+		0xC78, 0xC5580001,
+		0xC78, 0xC4590001,
+		0xC78, 0xC35A0001,
+		0xC78, 0xC25B0001,
+		0xC78, 0xC15C0001,
+		0xC78, 0xC05D0001,
+		0xC78, 0xA35E0001,
+		0xC78, 0xA25F0001,
+		0xC78, 0xA1600001,
+		0xC78, 0x88610001,
+		0xC78, 0x87620001,
+		0xC78, 0x86630001,
+		0xC78, 0x85640001,
+		0xC78, 0x84650001,
+		0xC78, 0x83660001,
+		0xC78, 0x82670001,
+	0x90000001,0x00000000,0x40000000,0x00000000,
 		0xC78, 0xFB400001,
 		0xC78, 0xFA410001,
 		0xC78, 0xF9420001,
@@ -233,31 +455,48 @@ u4Byte Array_MP_8188E_AGC_TAB_1T[] = {
 		0xC78, 0x67650001,
 		0xC78, 0x66660001,
 		0xC78, 0x65670001,
-		0xC78, 0x64680001,
-		0xC78, 0x63690001,
-		0xC78, 0x626A0001,
-		0xC78, 0x616B0001,
-		0xC78, 0x606C0001,
-		0xC78, 0x466D0001,
-		0xC78, 0x456E0001,
-		0xC78, 0x446F0001,
-		0xC78, 0x43700001,
-		0xC78, 0x42710001,
-		0xC78, 0x41720001,
-		0xC78, 0x40730001,
-		0xC78, 0x40740001,
-		0xC78, 0x40750001,
-		0xC78, 0x40760001,
-		0xC78, 0x40770001,
-		0xC78, 0x40780001,
-		0xC78, 0x40790001,
-		0xC78, 0x407A0001,
-		0xC78, 0x407B0001,
-		0xC78, 0x407C0001,
-		0xC78, 0x407D0001,
-		0xC78, 0x407E0001,
-		0xC78, 0x407F0001,
-	0xCDCDCDCD, 0xCDCD,
+	0x98000000,0x00000000,0x40000000,0x00000000,
+		0xC78, 0xFB400001,
+		0xC78, 0xFB410001,
+		0xC78, 0xFB420001,
+		0xC78, 0xFB430001,
+		0xC78, 0xFB440001,
+		0xC78, 0xFB450001,
+		0xC78, 0xFB460001,
+		0xC78, 0xFB470001,
+		0xC78, 0xFA480001,
+		0xC78, 0xF9490001,
+		0xC78, 0xF84A0001,
+		0xC78, 0xF74B0001,
+		0xC78, 0xF64C0001,
+		0xC78, 0xF54D0001,
+		0xC78, 0xF44E0001,
+		0xC78, 0xF34F0001,
+		0xC78, 0xF2500001,
+		0xC78, 0xF1510001,
+		0xC78, 0xF0520001,
+		0xC78, 0xEF530001,
+		0xC78, 0xEE540001,
+		0xC78, 0xED550001,
+		0xC78, 0xEC560001,
+		0xC78, 0xEB570001,
+		0xC78, 0xEA580001,
+		0xC78, 0xE9590001,
+		0xC78, 0xE85A0001,
+		0xC78, 0xE75B0001,
+		0xC78, 0xE65C0001,
+		0xC78, 0xE55D0001,
+		0xC78, 0xC65E0001,
+		0xC78, 0xC55F0001,
+		0xC78, 0xC4600001,
+		0xC78, 0xC3610001,
+		0xC78, 0xC2620001,
+		0xC78, 0xC1630001,
+		0xC78, 0xC0640001,
+		0xC78, 0xA3650001,
+		0xC78, 0xA2660001,
+		0xC78, 0xA1670001,
+	0xA0000000,0x00000000,
 		0xC78, 0xFB400001,
 		0xC78, 0xFB410001,
 		0xC78, 0xFB420001,
@@ -298,283 +537,61 @@ u4Byte Array_MP_8188E_AGC_TAB_1T[] = {
 		0xC78, 0x8B650001,
 		0xC78, 0x8A660001,
 		0xC78, 0x89670001,
+	0xB0000000,0x00000000,
+	0x88000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x66680001,
+		0xC78, 0x65690001,
+		0xC78, 0x646A0001,
+		0xC78, 0x636B0001,
+		0xC78, 0x626C0001,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x64680001,
+		0xC78, 0x63690001,
+		0xC78, 0x626A0001,
+		0xC78, 0x616B0001,
+		0xC78, 0x606C0001,
+	0xA0000000,0x00000000,
 		0xC78, 0x88680001,
 		0xC78, 0x87690001,
 		0xC78, 0x866A0001,
 		0xC78, 0x856B0001,
 		0xC78, 0x846C0001,
-		0xC78, 0x676D0001,
-		0xC78, 0x666E0001,
-		0xC78, 0x656F0001,
-		0xC78, 0x64700001,
-		0xC78, 0x63710001,
-		0xC78, 0x62720001,
-		0xC78, 0x61730001,
-		0xC78, 0x60740001,
-		0xC78, 0x46750001,
-		0xC78, 0x45760001,
-		0xC78, 0x44770001,
-		0xC78, 0x43780001,
-		0xC78, 0x42790001,
-		0xC78, 0x417A0001,
+	0xB0000000,0x00000000,
+	0x88000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x616D0001,
+		0xC78, 0x486E0001,
+		0xC78, 0x476F0001,
+		0xC78, 0x46700001,
+		0xC78, 0x45710001,
+		0xC78, 0x44720001,
+		0xC78, 0x43730001,
+		0xC78, 0x42740001,
+		0xC78, 0x41750001,
+		0xC78, 0x40760001,
+		0xC78, 0x40770001,
+		0xC78, 0x40780001,
+		0xC78, 0x40790001,
+		0xC78, 0x407A0001,
 		0xC78, 0x407B0001,
 		0xC78, 0x407C0001,
-		0xC78, 0x407D0001,
-		0xC78, 0x407E0001,
-		0xC78, 0x407F0001,
-	0xFF0F0718, 0xDEAD,
-		0xC50, 0x69553422,
-		0xC50, 0x69553420,
-
-};
-
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_AGC_TAB_1T(
- 	IN   PDM_ODM_T  pDM_Odm
- 	)
-{
-	#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
-
-	u4Byte     hex         = 0;
-	u4Byte     i           = 0;
-	u2Byte     count       = 0;
-	pu4Byte    ptr_array   = NULL;
-	u1Byte     platform    = pDM_Odm->SupportPlatform;
-	u1Byte     _interface   = pDM_Odm->SupportInterface;
-	u1Byte     board       = pDM_Odm->BoardType;  
-	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_AGC_TAB_1T)/sizeof(u4Byte);
-	pu4Byte    Array       = Array_MP_8188E_AGC_TAB_1T;
-	BOOLEAN		biol = FALSE;
-#ifdef CONFIG_IOL_IOREG_CFG
-	PADAPTER	Adapter =  pDM_Odm->Adapter;	
-	struct xmit_frame	*pxmit_frame;	
-	u8 bndy_cnt=1;	
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
-	HAL_STATUS rst =HAL_STATUS_SUCCESS;
-
-	hex += board;
-	hex += _interface << 8;
-	hex += platform << 16;
-	hex += 0xFF000000;
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_8188E_AGC_TAB_1T, hex = 0x%X\n", hex));
-#ifdef CONFIG_IOL_IOREG_CFG
-	biol = rtw_IOL_applied(Adapter);
-	
-	if(biol){		
-		if((pxmit_frame= rtw_IOL_accquire_xmit_frame(Adapter)) == NULL){
-			printk("rtw_IOL_accquire_xmit_frame failed\n");
-			return HAL_STATUS_FAILURE;
-		}
-	}		
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
-
-	for (i = 0; i < ArrayLen; i += 2 )
-	{
-	    u4Byte v1 = Array[i];
-	    u4Byte v2 = Array[i+1];
-	
-	    // This (offset, data) pair meets the condition.
-	    if ( v1 < 0xCDCDCDCD )
-	    {
-			#ifdef CONFIG_IOL_IOREG_CFG
-	 		if(biol){	
-				if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-					bndy_cnt++;
-				rtw_IOL_append_WD_cmd(pxmit_frame,(u2Byte)v1, v2,bMaskDWord);					
-	 		}
-			else
-			#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-			{
-		    	odm_ConfigBB_AGC_8188E(pDM_Odm, v1, bMaskDWord, v2);
-			}
-		    continue;
-	 	}
-		else
-		{ // This line is the start line of branch.
-		    if ( !CheckCondition(Array[i], hex) )
-		    { // Discard the following (offset, data) pairs.
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        i -= 2; // prevent from for-loop += 2
-		    }
-		    else // Configure matched pairs and skip to end of if-else.
-		    {
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-					#ifdef CONFIG_IOL_IOREG_CFG
-	 				if(biol){	
-						if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-							bndy_cnt++;
-						rtw_IOL_append_WD_cmd(pxmit_frame,(u2Byte)v1, v2,bMaskDWord);							
-	 				}
-					else
-					#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-					{
-		     			odm_ConfigBB_AGC_8188E(pDM_Odm, v1, bMaskDWord, v2);
-					}
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-
-		        while (v2 != 0xDEAD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        
-		    }
-		}	
-	}
-#ifdef CONFIG_IOL_IOREG_CFG
-	if(biol){
-		//printk("==> %s, pktlen = %d,bndy_cnt = %d\n",__FUNCTION__,pxmit_frame->attrib.pktlen+4+32,bndy_cnt);
-		if(rtw_IOL_exec_cmds_sync(pDM_Odm->Adapter, pxmit_frame, 1000, bndy_cnt))
-		{			
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			printk("~~~ %s Success !!! \n",__FUNCTION__);
-			{
-				//dump data from TX packet buffer				
-				rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
-			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-		
-		}
-		else{
-			printk("~~~ %s IOL_exec_cmds Failed !!! \n",__FUNCTION__);
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			{
-				//dump data from TX packet buffer				
-				rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
-			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-
-			rst = HAL_STATUS_FAILURE;			
-		}
-	}
-#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-	return rst;
-}
-
-/******************************************************************************
-*                           AGC_TAB_1T_ICUT.TXT
-******************************************************************************/
-
-u4Byte Array_MP_8188E_AGC_TAB_1T_ICUT[] = { 
-		0xC78, 0xFB000001,
-		0xC78, 0xFB010001,
-		0xC78, 0xFB020001,
-		0xC78, 0xFB030001,
-		0xC78, 0xFB040001,
-		0xC78, 0xFA050001,
-		0xC78, 0xF9060001,
-		0xC78, 0xF8070001,
-		0xC78, 0xF7080001,
-		0xC78, 0xF6090001,
-		0xC78, 0xF50A0001,
-		0xC78, 0xF40B0001,
-		0xC78, 0xF30C0001,
-		0xC78, 0xF20D0001,
-		0xC78, 0xF10E0001,
-		0xC78, 0xF00F0001,
-		0xC78, 0xEF100001,
-		0xC78, 0xEE110001,
-		0xC78, 0xED120001,
-		0xC78, 0xEC130001,
-		0xC78, 0xEB140001,
-		0xC78, 0xEA150001,
-		0xC78, 0xE9160001,
-		0xC78, 0xE8170001,
-		0xC78, 0xE7180001,
-		0xC78, 0xE6190001,
-		0xC78, 0xE51A0001,
-		0xC78, 0xE41B0001,
-		0xC78, 0xC71C0001,
-		0xC78, 0xC61D0001,
-		0xC78, 0xC51E0001,
-		0xC78, 0xC41F0001,
-		0xC78, 0xC3200001,
-		0xC78, 0xC2210001,
-		0xC78, 0x88220001,
-		0xC78, 0x87230001,
-		0xC78, 0x86240001,
-		0xC78, 0x85250001,
-		0xC78, 0x84260001,
-		0xC78, 0x83270001,
-		0xC78, 0x82280001,
-		0xC78, 0x81290001,
-		0xC78, 0x242A0001,
-		0xC78, 0x232B0001,
-		0xC78, 0x222C0001,
-		0xC78, 0x672D0001,
-		0xC78, 0x662E0001,
-		0xC78, 0x652F0001,
-		0xC78, 0x64300001,
-		0xC78, 0x63310001,
-		0xC78, 0x62320001,
-		0xC78, 0x61330001,
-		0xC78, 0x60340001,
-		0xC78, 0x4A350001,
-		0xC78, 0x49360001,
-		0xC78, 0x48370001,
-		0xC78, 0x47380001,
-		0xC78, 0x46390001,
-		0xC78, 0x453A0001,
-		0xC78, 0x443B0001,
-		0xC78, 0x433C0001,
-		0xC78, 0x423D0001,
-		0xC78, 0x413E0001,
-		0xC78, 0x403F0001,
-		0xC78, 0xFB400001,
-		0xC78, 0xFB410001,
-		0xC78, 0xFB420001,
-		0xC78, 0xFB430001,
-		0xC78, 0xFB440001,
-		0xC78, 0xFB450001,
-		0xC78, 0xFB460001,
-		0xC78, 0xFB470001,
-		0xC78, 0xFA480001,
-		0xC78, 0xF9490001,
-		0xC78, 0xF84A0001,
-		0xC78, 0xF74B0001,
-		0xC78, 0xF64C0001,
-		0xC78, 0xF54D0001,
-		0xC78, 0xF44E0001,
-		0xC78, 0xF34F0001,
-		0xC78, 0xF2500001,
-		0xC78, 0xF1510001,
-		0xC78, 0xF0520001,
-		0xC78, 0xEF530001,
-		0xC78, 0xEE540001,
-		0xC78, 0xED550001,
-		0xC78, 0xEC560001,
-		0xC78, 0xEB570001,
-		0xC78, 0xEA580001,
-		0xC78, 0xE9590001,
-		0xC78, 0xE85A0001,
-		0xC78, 0xE75B0001,
-		0xC78, 0xE65C0001,
-		0xC78, 0xE55D0001,
-		0xC78, 0xC65E0001,
-		0xC78, 0xC55F0001,
-		0xC78, 0xC4600001,
-		0xC78, 0xC3610001,
-		0xC78, 0xC2620001,
-		0xC78, 0xC1630001,
-		0xC78, 0xC0640001,
-		0xC78, 0xA3650001,
-		0xC78, 0xA2660001,
-		0xC78, 0xA1670001,
-		0xC78, 0x88680001,
-		0xC78, 0x87690001,
-		0xC78, 0x866A0001,
-		0xC78, 0x856B0001,
-		0xC78, 0x846C0001,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0xC78, 0x466D0001,
+		0xC78, 0x456E0001,
+		0xC78, 0x446F0001,
+		0xC78, 0x43700001,
+		0xC78, 0x42710001,
+		0xC78, 0x41720001,
+		0xC78, 0x40730001,
+		0xC78, 0x40740001,
+		0xC78, 0x40750001,
+		0xC78, 0x40760001,
+		0xC78, 0x40770001,
+		0xC78, 0x40780001,
+		0xC78, 0x40790001,
+		0xC78, 0x407A0001,
+		0xC78, 0x407B0001,
+		0xC78, 0x407C0001,
+	0x98000000,0x00000000,0x40000000,0x00000000,
 		0xC78, 0x836D0001,
 		0xC78, 0x826E0001,
 		0xC78, 0x666F0001,
@@ -586,591 +603,113 @@ u4Byte Array_MP_8188E_AGC_TAB_1T_ICUT[] = {
 		0xC78, 0x48750001,
 		0xC78, 0x47760001,
 		0xC78, 0x46770001,
-		0xC78, 0x45780001,
-		0xC78, 0x44790001,
-		0xC78, 0x437A0001,
-		0xC78, 0x427B0001,
-		0xC78, 0x417C0001,
-		0xC78, 0x407D0001,
-		0xC78, 0x407E0001,
-		0xC78, 0x407F0001,
-		0xC50, 0x69553422,
-		0xC50, 0x69553420,
-
-};
-
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_AGC_TAB_1T_ICUT(
- 	IN   PDM_ODM_T  pDM_Odm
- 	)
-{
-	#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
-
-	u4Byte     hex         = 0;
-	u4Byte     i           = 0;
-	u2Byte     count       = 0;
-	pu4Byte    ptr_array   = NULL;
-	u1Byte     platform    = pDM_Odm->SupportPlatform;
-	u1Byte     _interface   = pDM_Odm->SupportInterface;
-	u1Byte     board       = pDM_Odm->BoardType;  
-	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_AGC_TAB_1T_ICUT)/sizeof(u4Byte);
-	pu4Byte    Array       = Array_MP_8188E_AGC_TAB_1T_ICUT;
-	BOOLEAN		biol = FALSE;
-#ifdef CONFIG_IOL_IOREG_CFG
-	PADAPTER	Adapter =  pDM_Odm->Adapter;	
-	struct xmit_frame	*pxmit_frame;	
-	u8 bndy_cnt=1;	
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
-	HAL_STATUS rst =HAL_STATUS_SUCCESS;
-
-	hex += board;
-	hex += _interface << 8;
-	hex += platform << 16;
-	hex += 0xFF000000;
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_8188E_AGC_TAB_1T_ICUT, hex = 0x%X\n", hex));
-#ifdef CONFIG_IOL_IOREG_CFG
-	biol = rtw_IOL_applied(Adapter);
-	
-	if(biol){		
-		if((pxmit_frame= rtw_IOL_accquire_xmit_frame(Adapter)) == NULL){
-			printk("rtw_IOL_accquire_xmit_frame failed\n");
-			return HAL_STATUS_FAILURE;
-		}
-	}		
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
-
-	for (i = 0; i < ArrayLen; i += 2 )
-	{
-	    u4Byte v1 = Array[i];
-	    u4Byte v2 = Array[i+1];
-	
-	    // This (offset, data) pair meets the condition.
-	    if ( v1 < 0xCDCDCDCD )
-	    {
-			#ifdef CONFIG_IOL_IOREG_CFG
-	 		if(biol){	
-				if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-					bndy_cnt++;
-				rtw_IOL_append_WD_cmd(pxmit_frame,(u2Byte)v1, v2,bMaskDWord);					
-	 		}
-			else
-			#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-			{
-		    	odm_ConfigBB_AGC_8188E(pDM_Odm, v1, bMaskDWord, v2);
-			}
-		    continue;
-	 	}
-		else
-		{ // This line is the start line of branch.
-		    if ( !CheckCondition(Array[i], hex) )
-		    { // Discard the following (offset, data) pairs.
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        i -= 2; // prevent from for-loop += 2
-		    }
-		    else // Configure matched pairs and skip to end of if-else.
-		    {
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-					#ifdef CONFIG_IOL_IOREG_CFG
-	 				if(biol){	
-						if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-							bndy_cnt++;
-						rtw_IOL_append_WD_cmd(pxmit_frame,(u2Byte)v1, v2,bMaskDWord);							
-	 				}
-					else
-					#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-					{
-		     			odm_ConfigBB_AGC_8188E(pDM_Odm, v1, bMaskDWord, v2);
-					}
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-
-		        while (v2 != 0xDEAD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        
-		    }
-		}	
-	}
-#ifdef CONFIG_IOL_IOREG_CFG
-	if(biol){
-		//printk("==> %s, pktlen = %d,bndy_cnt = %d\n",__FUNCTION__,pxmit_frame->attrib.pktlen+4+32,bndy_cnt);
-		if(rtw_IOL_exec_cmds_sync(pDM_Odm->Adapter, pxmit_frame, 1000, bndy_cnt))
-		{			
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			printk("~~~ %s Success !!! \n",__FUNCTION__);
-			{
-				//dump data from TX packet buffer				
-				rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
-			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-		
-		}
-		else{
-			printk("~~~ %s IOL_exec_cmds Failed !!! \n",__FUNCTION__);
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			{
-				//dump data from TX packet buffer				
-				rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
-			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-
-			rst = HAL_STATUS_FAILURE;			
-		}
-	}
-#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-	return rst;
-}
-
-/******************************************************************************
-*                           PHY_REG_1T.TXT
-******************************************************************************/
-
-u4Byte Array_MP_8188E_PHY_REG_1T[] = { 
-		0x800, 0x80040000,
-		0x804, 0x00000003,
-		0x808, 0x0000FC00,
-		0x80C, 0x0000000A,
-		0x810, 0x10001331,
-		0x814, 0x020C3D10,
-		0x818, 0x02200385,
-		0x81C, 0x00000000,
-		0x820, 0x01000100,
-		0x824, 0x00390204,
-		0x828, 0x00000000,
-		0x82C, 0x00000000,
-		0x830, 0x00000000,
-		0x834, 0x00000000,
-		0x838, 0x00000000,
-		0x83C, 0x00000000,
-		0x840, 0x00010000,
-		0x844, 0x00000000,
-		0x848, 0x00000000,
-		0x84C, 0x00000000,
-		0x850, 0x00000000,
-		0x854, 0x00000000,
-		0x858, 0x569A11A9,
-		0x85C, 0x01000014,
-		0x860, 0x66F60110,
-		0x864, 0x061F0649,
-		0x868, 0x00000000,
-		0x86C, 0x27272700,
-	0xFF0F0718, 0xABCD,
-		0x870, 0x07000300,
-	0xCDCDCDCD, 0xCDCD,
-		0x870, 0x07000760,
-	0xFF0F0718, 0xDEAD,
-		0x874, 0x25004000,
-		0x878, 0x00000808,
-		0x87C, 0x00000000,
-		0x880, 0xB0000C1C,
-		0x884, 0x00000001,
-		0x888, 0x00000000,
-		0x88C, 0xCCC000C0,
-		0x890, 0x00000800,
-		0x894, 0xFFFFFFFE,
-		0x898, 0x40302010,
-		0x89C, 0x00706050,
-		0x900, 0x00000000,
-		0x904, 0x00000023,
-		0x908, 0x00000000,
-		0x90C, 0x81121111,
-		0x910, 0x00000002,
-		0x914, 0x00000201,
-		0xA00, 0x00D047C8,
-		0xA04, 0x80FF000C,
-		0xA08, 0x8C838300,
-		0xA0C, 0x2E7F120F,
-		0xA10, 0x9500BB78,
-		0xA14, 0x1114D028,
-		0xA18, 0x00881117,
-		0xA1C, 0x89140F00,
-	0xFF0F0718, 0xABCD,
-		0xA20, 0x13130000,
-		0xA24, 0x060A0D10,
-		0xA28, 0x00000103,
-	0xCDCDCDCD, 0xCDCD,
-		0xA20, 0x1A1B0000,
-		0xA24, 0x090E1317,
-		0xA28, 0x00000204,
-	0xFF0F0718, 0xDEAD,
-		0xA2C, 0x00D30000,
-		0xA70, 0x101FBF00,
-		0xA74, 0x00000007,
-		0xA78, 0x00000900,
-		0xA7C, 0x225B0606,
-		0xA80, 0x218075B1,
-	0xFF0F0718, 0xABCD,
-		0xB2C, 0x00000000,
-	0xCDCDCDCD, 0xCDCD,
-		0xB2C, 0x80000000,
-	0xFF0F0718, 0xDEAD,
-		0xC00, 0x48071D40,
-		0xC04, 0x03A05611,
-		0xC08, 0x000000E4,
-		0xC0C, 0x6C6C6C6C,
-		0xC10, 0x08800000,
-		0xC14, 0x40000100,
-		0xC18, 0x08800000,
-		0xC1C, 0x40000100,
-		0xC20, 0x00000000,
-		0xC24, 0x00000000,
-		0xC28, 0x00000000,
-		0xC2C, 0x00000000,
-		0xC30, 0x69E9AC47,
-		0xC34, 0x469652AF,
-		0xC38, 0x49795994,
-		0xC3C, 0x0A97971C,
-		0xC40, 0x1F7C403F,
-		0xC44, 0x000100B7,
-		0xC48, 0xEC020107,
-		0xC4C, 0x007F037F,
+		0xC78, 0x45780001,
+		0xC78, 0x44790001,
+		0xC78, 0x437A0001,
+		0xC78, 0x427B0001,
+		0xC78, 0x417C0001,
+	0xA0000000,0x00000000,
+		0xC78, 0x676D0001,
+		0xC78, 0x666E0001,
+		0xC78, 0x656F0001,
+		0xC78, 0x64700001,
+		0xC78, 0x63710001,
+		0xC78, 0x62720001,
+		0xC78, 0x61730001,
+		0xC78, 0x60740001,
+		0xC78, 0x46750001,
+		0xC78, 0x45760001,
+		0xC78, 0x44770001,
+		0xC78, 0x43780001,
+		0xC78, 0x42790001,
+		0xC78, 0x417A0001,
+		0xC78, 0x407B0001,
+		0xC78, 0x407C0001,
+	0xB0000000,0x00000000,
+		0xC78, 0x407D0001,
+		0xC78, 0x407E0001,
+		0xC78, 0x407F0001,
+		0xC50, 0x69553422,
 		0xC50, 0x69553420,
-		0xC54, 0x43BC0094,
-		0xC58, 0x00013169,
-		0xC5C, 0x00250492,
-		0xC60, 0x00000000,
-		0xC64, 0x7112848B,
-		0xC68, 0x47C00BFF,
-		0xC6C, 0x00000036,
-		0xC70, 0x2C7F000D,
-		0xC74, 0x020610DB,
-		0xC78, 0x0000001F,
-		0xC7C, 0x00B91612,
-	0xFF0F0718, 0xABCD,
-		0xC80, 0x2D4000B5,
-	0xCDCDCDCD, 0xCDCD,
-		0xC80, 0x390000E4,
-	0xFF0F0718, 0xDEAD,
-		0xC84, 0x20F60000,
-		0xC88, 0x40000100,
-		0xC8C, 0x20200000,
-		0xC90, 0x00091521,
-		0xC94, 0x00000000,
-		0xC98, 0x00121820,
-		0xC9C, 0x00007F7F,
-		0xCA0, 0x00000000,
-		0xCA4, 0x000300A0,
-		0xCA8, 0x00000000,
-		0xCAC, 0x00000000,
-		0xCB0, 0x00000000,
-		0xCB4, 0x00000000,
-		0xCB8, 0x00000000,
-		0xCBC, 0x28000000,
-		0xCC0, 0x00000000,
-		0xCC4, 0x00000000,
-		0xCC8, 0x00000000,
-		0xCCC, 0x00000000,
-		0xCD0, 0x00000000,
-		0xCD4, 0x00000000,
-		0xCD8, 0x64B22427,
-		0xCDC, 0x00766932,
-		0xCE0, 0x00222222,
-		0xCE4, 0x00000000,
-		0xCE8, 0x37644302,
-		0xCEC, 0x2F97D40C,
-		0xD00, 0x00000740,
-		0xD04, 0x00020401,
-		0xD08, 0x0000907F,
-		0xD0C, 0x20010201,
-		0xD10, 0xA0633333,
-		0xD14, 0x3333BC43,
-		0xD18, 0x7A8F5B6F,
-		0xD2C, 0xCC979975,
-		0xD30, 0x00000000,
-		0xD34, 0x80608000,
-		0xD38, 0x00000000,
-		0xD3C, 0x00127353,
-		0xD40, 0x00000000,
-		0xD44, 0x00000000,
-		0xD48, 0x00000000,
-		0xD4C, 0x00000000,
-		0xD50, 0x6437140A,
-		0xD54, 0x00000000,
-		0xD58, 0x00000282,
-		0xD5C, 0x30032064,
-		0xD60, 0x4653DE68,
-		0xD64, 0x04518A3C,
-		0xD68, 0x00002101,
-		0xD6C, 0x2A201C16,
-		0xD70, 0x1812362E,
-		0xD74, 0x322C2220,
-		0xD78, 0x000E3C24,
-		0xE00, 0x2D2D2D2D,
-		0xE04, 0x2D2D2D2D,
-		0xE08, 0x0390272D,
-		0xE10, 0x2D2D2D2D,
-		0xE14, 0x2D2D2D2D,
-		0xE18, 0x2D2D2D2D,
-		0xE1C, 0x2D2D2D2D,
-		0xE28, 0x00000000,
-		0xE30, 0x1000DC1F,
-		0xE34, 0x10008C1F,
-		0xE38, 0x02140102,
-		0xE3C, 0x681604C2,
-		0xE40, 0x01007C00,
-		0xE44, 0x01004800,
-		0xE48, 0xFB000000,
-		0xE4C, 0x000028D1,
-		0xE50, 0x1000DC1F,
-		0xE54, 0x10008C1F,
-		0xE58, 0x02140102,
-		0xE5C, 0x28160D05,
-		0xE60, 0x00000008,
-		0xE68, 0x001B25A4,
-		0xE6C, 0x00C00014,
-		0xE70, 0x00C00014,
-		0xE74, 0x01000014,
-		0xE78, 0x01000014,
-		0xE7C, 0x01000014,
-		0xE80, 0x01000014,
-		0xE84, 0x00C00014,
-		0xE88, 0x01000014,
-		0xE8C, 0x00C00014,
-		0xED0, 0x00C00014,
-		0xED4, 0x00C00014,
-		0xED8, 0x00C00014,
-		0xEDC, 0x00000014,
-		0xEE0, 0x00000014,
-	0xFF0F0718, 0xABCD,
-		0xEE8, 0x32555448,
-	0xCDCDCDCD, 0xCDCD,
-		0xEE8, 0x21555448,
-	0xFF0F0718, 0xDEAD,
-		0xEEC, 0x01C00014,
-		0xF14, 0x00000003,
-		0xF4C, 0x00000000,
-		0xF00, 0x00000300,
 
 };
 
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_PHY_REG_1T(
+void
+ODM_ReadAndConfig_MP_8188E_AGC_TAB(
  	IN   PDM_ODM_T  pDM_Odm
  	)
 {
-	#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
-
-	u4Byte     hex         = 0;
-	u4Byte     i           = 0;
-	u2Byte     count       = 0;
-	pu4Byte    ptr_array   = NULL;
-	u1Byte     platform    = pDM_Odm->SupportPlatform;
-	u1Byte     _interface   = pDM_Odm->SupportInterface;
-	u1Byte     board       = pDM_Odm->BoardType;  
-	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_PHY_REG_1T)/sizeof(u4Byte);
-	pu4Byte    Array       = Array_MP_8188E_PHY_REG_1T;
-	BOOLEAN		biol = FALSE;
-#ifdef CONFIG_IOL_IOREG_CFG
-	PADAPTER	Adapter =  pDM_Odm->Adapter;	
-	struct xmit_frame	*pxmit_frame;
-	u8 bndy_cnt=1;
-	#ifdef CONFIG_IOL_IOREG_CFG_DBG
-	struct cmd_cmp cmpdata[ArrayLen];
-	u4Byte	cmpdata_idx=0;
-	#endif
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
-	HAL_STATUS rst =HAL_STATUS_SUCCESS;
-
-	hex += board;
-	hex += _interface << 8;
-	hex += platform << 16;
-	hex += 0xFF000000;
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_8188E_PHY_REG_1T, hex = 0x%X\n", hex));
-#ifdef CONFIG_IOL_IOREG_CFG
-	biol = rtw_IOL_applied(Adapter);
+    u4Byte     i         = 0;
+    u1Byte     cCond;
+    BOOLEAN bMatched = TRUE, bSkipped = FALSE;
+//ask by Luke.Lee
+    u4Byte     ArrayLen    = sizeof(Array_MP_8188E_AGC_TAB)/sizeof(u4Byte);
+    pu4Byte    Array       = Array_MP_8188E_AGC_TAB;
 	
-	if(biol){		
-		if((pxmit_frame=rtw_IOL_accquire_xmit_frame(Adapter)) == NULL)
-		{
-			printk("rtw_IOL_accquire_xmit_frame failed\n");
-			return HAL_STATUS_FAILURE;
-		}
-	}		
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8188E_AGC_TAB\n"));
 
-	for (i = 0; i < ArrayLen; i += 2 )
+	while(( i+1) < ArrayLen)
 	{
-	    u4Byte v1 = Array[i];
-	    u4Byte v2 = Array[i+1];
-	
-	    // This (offset, data) pair meets the condition.
-	    if ( v1 < 0xCDCDCDCD )
-	    {
-			#ifdef CONFIG_IOL_IOREG_CFG
-			if(biol){
-				if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-					bndy_cnt++;
-
+		u4Byte v1 = Array[i];
+		u4Byte v2 = Array[i+1];
 
-				if (v1 == 0xfe){						
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,50);					
-				}
-				else if (v1 == 0xfd){
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,5);
-				}
-				else if (v1 == 0xfc){
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,1);
-				}
-				else if (v1 == 0xfb){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,50);
-				}
-				else if (v1 == 0xfa){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame, 5);
-				}
-				else if (v1 == 0xf9){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,1);
+		if(v1 & (BIT31|BIT30)) //positive & negative condition
+		{
+			if(v1 & BIT31) // positive condition
+			{
+				cCond  = (u1Byte)((v1 & (BIT29|BIT28)) >> 28);
+				if(cCond == COND_ENDIF) //end
+				{
+					bMatched = TRUE;
+					bSkipped = FALSE;
 				}
-				else{
-					if (v1 == 0xa24)
-						pDM_Odm->RFCalibrateInfo.RegA24 = v2;	
-		
-					rtw_IOL_append_WD_cmd(pxmit_frame,(u2Byte)v1, v2,bMaskDWord);	
-					#ifdef CONFIG_IOL_IOREG_CFG_DBG
-							cmpdata[cmpdata_idx].addr = v1;
-							cmpdata[cmpdata_idx].value= v2;
-							cmpdata_idx++;
-					#endif
+				else if(cCond == COND_ELSE) //else
+				{
+					bMatched = bSkipped?FALSE:TRUE;
 				}
-	 		}
-			else
-			#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-			{
-		   		odm_ConfigBB_PHY_8188E(pDM_Odm, v1, bMaskDWord, v2);
-			}
-			continue;
-	 	}
-		else
-		{ // This line is the start line of branch.
-		    if ( !CheckCondition(Array[i], hex) )
-		    { // Discard the following (offset, data) pairs.
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        i -= 2; // prevent from for-loop += 2
-		    }
-		    else // Configure matched pairs and skip to end of if-else.
-		    {
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-					#ifdef CONFIG_IOL_IOREG_CFG
-	 				if(biol){	
-						if(rtw_IOL_cmd_boundary_handle(pxmit_frame))	
-							bndy_cnt++;
-						if (v1 == 0xfe){						
-							rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,50);						
-						}
-						else if (v1 == 0xfd){
-							rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,5);
-						}
-						else if (v1 == 0xfc){
-							rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,1);
-						}
-						else if (v1 == 0xfb){
-							rtw_IOL_append_DELAY_US_cmd(pxmit_frame,50);
-						}
-						else if (v1 == 0xfa){
-							rtw_IOL_append_DELAY_US_cmd(pxmit_frame,5);
-						}
-						else if (v1 == 0xf9){
-							rtw_IOL_append_DELAY_US_cmd(pxmit_frame,1);
-						}
-						else{
-							if (v1 == 0xa24)
-								pDM_Odm->RFCalibrateInfo.RegA24 = v2;	
-			
-							rtw_IOL_append_WD_cmd(pxmit_frame,(u2Byte)v1, v2,bMaskDWord);	
-							#ifdef CONFIG_IOL_IOREG_CFG_DBG
-								cmpdata[cmpdata_idx].addr = v1;
-								cmpdata[cmpdata_idx].value= v2;
-								cmpdata_idx++;
-							#endif
-						}
-	 				}
+				else //if , else if
+				{
+					if(bSkipped)
+						bMatched = FALSE;
 					else
-					#endif	//#ifdef CONFIG_IOL_IOREG_CFG
 					{
-		   				odm_ConfigBB_PHY_8188E(pDM_Odm, v1, bMaskDWord, v2);
+						if(CheckPositive(pDM_Odm, v1, v2))
+						{
+							bMatched = TRUE;
+							bSkipped = TRUE;
+						}
+						else
+						{
+							bMatched = FALSE;
+							bSkipped = FALSE;
+						}
 					}
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-
-		        while (v2 != 0xDEAD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        
-		    }
-		}	
-	}
-#ifdef CONFIG_IOL_IOREG_CFG
-	if(biol){
-		//printk("==> %s, pktlen = %d,bndy_cnt = %d\n",__FUNCTION__,pxmit_frame->attrib.pktlen+4+32,bndy_cnt);
-		if(rtw_IOL_exec_cmds_sync(pDM_Odm->Adapter, pxmit_frame, 1000, bndy_cnt))
-		{			
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			printk("~~~ %s IOL_exec_cmds Success !!! \n",__FUNCTION__);
-			{
-				u4Byte idx;
-				u4Byte cdata;
-				printk("  %s data compare => array_len:%d \n",__FUNCTION__,cmpdata_idx);
-				printk("### %s data compared !!###\n",__FUNCTION__);
-				for(idx=0;idx< cmpdata_idx;idx++)
-				{
-					cdata = ODM_Read4Byte(pDM_Odm, cmpdata[idx].addr);
-					if(cdata != cmpdata[idx].value){
-						printk(" addr:0x%04x, data:(0x%02x : 0x%02x) \n",
-							cmpdata[idx].addr,cmpdata[idx].value,cdata);
-						rst = HAL_STATUS_FAILURE;
-					}					
 				}
-				printk("### %s data compared !!###\n",__FUNCTION__);
-				//if(rst == HAL_STATUS_FAILURE)
-				{//dump data from TX packet buffer				
-					rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
-				}
-				
 			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-		
-		}
-		else{
-			rst = HAL_STATUS_FAILURE;
-			printk("~~~ IOL Config %s Failed !!! \n",__FUNCTION__);
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			{
-				//dump data from TX packet buffer				
-				rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
+			else if(v1 & BIT30){ //negative condition
+			//do nothing
 			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
 		}
+		else
+		{
+			if(bMatched)
+			odm_ConfigBB_AGC_8188E(pDM_Odm, v1, bMaskDWord, v2);
+		}
+	i = i + 2;
 	}
-#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-	return rst;
+}
+
+u4Byte
+ODM_GetVersion_MP_8188E_AGC_TAB(void)
+{
+	   return 53;
 }
 
 /******************************************************************************
-*                           PHY_REG_1T_ICUT.TXT
+*                           PHY_REG.TXT
 ******************************************************************************/
 
-u4Byte Array_MP_8188E_PHY_REG_1T_ICUT[] = { 
+u4Byte Array_MP_8188E_PHY_REG[] = { 
 		0x800, 0x80040000,
 		0x804, 0x00000003,
 		0x808, 0x0000FC00,
@@ -1199,7 +738,17 @@ u4Byte Array_MP_8188E_PHY_REG_1T_ICUT[] = {
 		0x864, 0x061F0649,
 		0x868, 0x00000000,
 		0x86C, 0x27272700,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0x870, 0x07000300,
+	0x98000001,0x00000000,0x40000000,0x00000000,
+		0x870, 0x07000300,
+	0x90000003,0x00000000,0x40000000,0x00000000,
+		0x870, 0x07000300,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0x870, 0x07000300,
+	0xA0000000,0x00000000,
 		0x870, 0x07000760,
+	0xB0000000,0x00000000,
 		0x874, 0x25004000,
 		0x878, 0x00000808,
 		0x87C, 0x00000000,
@@ -1218,23 +767,43 @@ u4Byte Array_MP_8188E_PHY_REG_1T_ICUT[] = {
 		0x910, 0x00000002,
 		0x914, 0x00000201,
 		0xA00, 0x00D047C8,
-		0xA04, 0x80FF000C,
+		0xA04, 0x80FF800C,
 		0xA08, 0x8C838300,
 		0xA0C, 0x2E7F120F,
 		0xA10, 0x9500BB78,
 		0xA14, 0x1114D028,
 		0xA18, 0x00881117,
 		0xA1C, 0x89140F00,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0xA20, 0x13130000,
+		0xA24, 0x060A0D10,
+		0xA28, 0x00000103,
+	0x90000003,0x00000000,0x40000000,0x00000000,
+		0xA20, 0x13130000,
+		0xA24, 0x060A0D10,
+		0xA28, 0x00000103,
+	0xA0000000,0x00000000,
 		0xA20, 0x1A1B0000,
 		0xA24, 0x090E1317,
 		0xA28, 0x00000204,
+	0xB0000000,0x00000000,
 		0xA2C, 0x00D30000,
 		0xA70, 0x101FBF00,
 		0xA74, 0x00000007,
 		0xA78, 0x00000900,
 		0xA7C, 0x225B0606,
 		0xA80, 0x218075B1,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0xB2C, 0x00000000,
+	0x98000001,0x00000000,0x40000000,0x00000000,
+		0xB2C, 0x00000000,
+	0x90000003,0x00000000,0x40000000,0x00000000,
+		0xB2C, 0x00000000,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0xB2C, 0x00000000,
+	0xA0000000,0x00000000,
 		0xB2C, 0x80000000,
+	0xB0000000,0x00000000,
 		0xC00, 0x48071D40,
 		0xC04, 0x03A05611,
 		0xC08, 0x000000E4,
@@ -1257,18 +826,44 @@ u4Byte Array_MP_8188E_PHY_REG_1T_ICUT[] = {
 		0xC4C, 0x007F037F,
 		0xC50, 0x69553420,
 		0xC54, 0x43BC0094,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0xC58, 0x00013159,
+	0x98000001,0x00000000,0x40000000,0x00000000,
 		0xC58, 0x00013159,
+	0x98000400,0x00000000,0x40000000,0x00000000,
+		0xC58, 0x00013159,
+	0x98000000,0x00000000,0x40000000,0x00000000,
+		0xC58, 0x00013159,
+	0xA0000000,0x00000000,
+		0xC58, 0x00013169,
+	0xB0000000,0x00000000,
 		0xC5C, 0x00250492,
 		0xC60, 0x00000000,
 		0xC64, 0x7112848B,
 		0xC68, 0x47C00BFF,
 		0xC6C, 0x00000036,
 		0xC70, 0x2C7F000D,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0xC74, 0x028610DB,
+	0x98000001,0x00000000,0x40000000,0x00000000,
 		0xC74, 0x028610DB,
+	0x98000400,0x00000000,0x40000000,0x00000000,
+		0xC74, 0x028610DB,
+	0x98000000,0x00000000,0x40000000,0x00000000,
+		0xC74, 0x028610DB,
+	0xA0000000,0x00000000,
+		0xC74, 0x020610DB,
+	0xB0000000,0x00000000,
 		0xC78, 0x0000001F,
 		0xC7C, 0x00B91612,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0xC80, 0x2D4000B5,
+	0x90000003,0x00000000,0x40000000,0x00000000,
+		0xC80, 0x2D4000B5,
+	0xA0000000,0x00000000,
 		0xC80, 0x390000E4,
-		0xC84, 0x20F60000,
+	0xB0000000,0x00000000,
+		0xC84, 0x21F60000,
 		0xC88, 0x40000100,
 		0xC8C, 0x20200000,
 		0xC90, 0x00091521,
@@ -1277,7 +872,17 @@ u4Byte Array_MP_8188E_PHY_REG_1T_ICUT[] = {
 		0xC9C, 0x00007F7F,
 		0xCA0, 0x00000000,
 		0xCA4, 0x000300A0,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0xCA8, 0xFFFF0000,
+	0x98000001,0x00000000,0x40000000,0x00000000,
+		0xCA8, 0xFFFF0000,
+	0x98000400,0x00000000,0x40000000,0x00000000,
+		0xCA8, 0xFFFF0000,
+	0x98000000,0x00000000,0x40000000,0x00000000,
 		0xCA8, 0xFFFF0000,
+	0xA0000000,0x00000000,
+		0xCA8, 0x00000000,
+	0xB0000000,0x00000000,
 		0xCAC, 0x00000000,
 		0xCB0, 0x00000000,
 		0xCB4, 0x00000000,
@@ -1358,6 +963,17 @@ u4Byte Array_MP_8188E_PHY_REG_1T_ICUT[] = {
 		0xED8, 0x00C00014,
 		0xEDC, 0x00000014,
 		0xEE0, 0x00000014,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0xEE8, 0x32555448,
+	0x98000001,0x00000000,0x40000000,0x00000000,
+		0xEE8, 0x32555448,
+	0x90000003,0x00000000,0x40000000,0x00000000,
+		0xEE8, 0x32555448,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0xEE8, 0x32555448,
+	0xA0000000,0x00000000,
+		0xEE8, 0x21555448,
+	0xB0000000,0x00000000,
 		0xEEC, 0x01C00014,
 		0xF14, 0x00000003,
 		0xF4C, 0x00000000,
@@ -1365,216 +981,75 @@ u4Byte Array_MP_8188E_PHY_REG_1T_ICUT[] = {
 
 };
 
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_PHY_REG_1T_ICUT(
+void
+ODM_ReadAndConfig_MP_8188E_PHY_REG(
  	IN   PDM_ODM_T  pDM_Odm
  	)
 {
-	#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
-
-	u4Byte     hex         = 0;
-	u4Byte     i           = 0;
-	u2Byte     count       = 0;
-	pu4Byte    ptr_array   = NULL;
-	u1Byte     platform    = pDM_Odm->SupportPlatform;
-	u1Byte     _interface   = pDM_Odm->SupportInterface;
-	u1Byte     board       = pDM_Odm->BoardType;  
-	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_PHY_REG_1T_ICUT)/sizeof(u4Byte);
-	pu4Byte    Array       = Array_MP_8188E_PHY_REG_1T_ICUT;
-	BOOLEAN		biol = FALSE;
-#ifdef CONFIG_IOL_IOREG_CFG
-	PADAPTER	Adapter =  pDM_Odm->Adapter;	
-	struct xmit_frame	*pxmit_frame;
-	u8 bndy_cnt=1;
-	#ifdef CONFIG_IOL_IOREG_CFG_DBG
-	struct cmd_cmp cmpdata[ArrayLen];
-	u4Byte	cmpdata_idx=0;
-	#endif
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
-	HAL_STATUS rst =HAL_STATUS_SUCCESS;
-
-	hex += board;
-	hex += _interface << 8;
-	hex += platform << 16;
-	hex += 0xFF000000;
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_8188E_PHY_REG_1T_ICUT, hex = 0x%X\n", hex));
-#ifdef CONFIG_IOL_IOREG_CFG
-	biol = rtw_IOL_applied(Adapter);
+    u4Byte     i         = 0;
+    u1Byte     cCond;
+    BOOLEAN bMatched = TRUE, bSkipped = FALSE;
+//ask by Luke.Lee
+    u4Byte     ArrayLen    = sizeof(Array_MP_8188E_PHY_REG)/sizeof(u4Byte);
+    pu4Byte    Array       = Array_MP_8188E_PHY_REG;
 	
-	if(biol){		
-		if((pxmit_frame=rtw_IOL_accquire_xmit_frame(Adapter)) == NULL)
-		{
-			printk("rtw_IOL_accquire_xmit_frame failed\n");
-			return HAL_STATUS_FAILURE;
-		}
-	}		
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8188E_PHY_REG\n"));
 
-	for (i = 0; i < ArrayLen; i += 2 )
+	while(( i+1) < ArrayLen)
 	{
-	    u4Byte v1 = Array[i];
-	    u4Byte v2 = Array[i+1];
-	
-	    // This (offset, data) pair meets the condition.
-	    if ( v1 < 0xCDCDCDCD )
-	    {
-			#ifdef CONFIG_IOL_IOREG_CFG
-			if(biol){
-				if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-					bndy_cnt++;
+		u4Byte v1 = Array[i];
+		u4Byte v2 = Array[i+1];
 
-
-				if (v1 == 0xfe){						
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,50);					
-				}
-				else if (v1 == 0xfd){
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,5);
-				}
-				else if (v1 == 0xfc){
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,1);
-				}
-				else if (v1 == 0xfb){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,50);
-				}
-				else if (v1 == 0xfa){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame, 5);
-				}
-				else if (v1 == 0xf9){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,1);
+		if(v1 & (BIT31|BIT30)) //positive & negative condition
+		{
+			if(v1 & BIT31) // positive condition
+			{
+				cCond  = (u1Byte)((v1 & (BIT29|BIT28)) >> 28);
+				if(cCond == COND_ENDIF) //end
+				{
+					bMatched = TRUE;
+					bSkipped = FALSE;
 				}
-				else{
-					if (v1 == 0xa24)
-						pDM_Odm->RFCalibrateInfo.RegA24 = v2;	
-		
-					rtw_IOL_append_WD_cmd(pxmit_frame,(u2Byte)v1, v2,bMaskDWord);	
-					#ifdef CONFIG_IOL_IOREG_CFG_DBG
-							cmpdata[cmpdata_idx].addr = v1;
-							cmpdata[cmpdata_idx].value= v2;
-							cmpdata_idx++;
-					#endif
+				else if(cCond == COND_ELSE) //else
+				{
+					bMatched = bSkipped?FALSE:TRUE;
 				}
-	 		}
-			else
-			#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-			{
-		   		odm_ConfigBB_PHY_8188E(pDM_Odm, v1, bMaskDWord, v2);
-			}
-		    continue;
-	 	}
-		else
-		{ // This line is the start line of branch.
-		    if ( !CheckCondition(Array[i], hex) )
-		    { // Discard the following (offset, data) pairs.
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        i -= 2; // prevent from for-loop += 2
-		    }
-		    else // Configure matched pairs and skip to end of if-else.
-		    {
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-					#ifdef CONFIG_IOL_IOREG_CFG
-	 				if(biol){	
-						if(rtw_IOL_cmd_boundary_handle(pxmit_frame))	
-							bndy_cnt++;
-						if (v1 == 0xfe){						
-							rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,50);						
-						}
-						else if (v1 == 0xfd){
-							rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,5);
-						}
-						else if (v1 == 0xfc){
-							rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,1);
-						}
-						else if (v1 == 0xfb){
-							rtw_IOL_append_DELAY_US_cmd(pxmit_frame,50);
-						}
-						else if (v1 == 0xfa){
-							rtw_IOL_append_DELAY_US_cmd(pxmit_frame,5);
-						}
-						else if (v1 == 0xf9){
-							rtw_IOL_append_DELAY_US_cmd(pxmit_frame,1);
-						}
-						else{
-							if (v1 == 0xa24)
-								pDM_Odm->RFCalibrateInfo.RegA24 = v2;	
-			
-							rtw_IOL_append_WD_cmd(pxmit_frame,(u2Byte)v1, v2,bMaskDWord);	
-							#ifdef CONFIG_IOL_IOREG_CFG_DBG
-								cmpdata[cmpdata_idx].addr = v1;
-								cmpdata[cmpdata_idx].value= v2;
-								cmpdata_idx++;
-							#endif
-						}
-	 				}
+				else //if , else if
+				{
+					if(bSkipped)
+						bMatched = FALSE;
 					else
-					#endif	//#ifdef CONFIG_IOL_IOREG_CFG
 					{
-		   				odm_ConfigBB_PHY_8188E(pDM_Odm, v1, bMaskDWord, v2);
+						if(CheckPositive(pDM_Odm, v1, v2))
+						{
+							bMatched = TRUE;
+							bSkipped = TRUE;
+						}
+						else
+						{
+							bMatched = FALSE;
+							bSkipped = FALSE;
+						}
 					}
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-
-		        while (v2 != 0xDEAD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        
-		    }
-		}	
-	}
-#ifdef CONFIG_IOL_IOREG_CFG
-	if(biol){
-		//printk("==> %s, pktlen = %d,bndy_cnt = %d\n",__FUNCTION__,pxmit_frame->attrib.pktlen+4+32,bndy_cnt);
-		if(rtw_IOL_exec_cmds_sync(pDM_Odm->Adapter, pxmit_frame, 1000, bndy_cnt))
-		{			
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			printk("~~~ %s IOL_exec_cmds Success !!! \n",__FUNCTION__);
-			{
-				u4Byte idx;
-				u4Byte cdata;
-				printk("  %s data compare => array_len:%d \n",__FUNCTION__,cmpdata_idx);
-				printk("### %s data compared !!###\n",__FUNCTION__);
-				for(idx=0;idx< cmpdata_idx;idx++)
-				{
-					cdata = ODM_Read4Byte(pDM_Odm, cmpdata[idx].addr);
-					if(cdata != cmpdata[idx].value){
-						printk(" addr:0x%04x, data:(0x%02x : 0x%02x) \n",
-							cmpdata[idx].addr,cmpdata[idx].value,cdata);
-						rst = HAL_STATUS_FAILURE;
-					}					
-				}
-				printk("### %s data compared !!###\n",__FUNCTION__);
-				//if(rst == HAL_STATUS_FAILURE)
-				{//dump data from TX packet buffer				
-					rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
 				}
-				
 			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-		
-		}
-		else{
-			rst = HAL_STATUS_FAILURE;
-			printk("~~~ IOL Config %s Failed !!! \n",__FUNCTION__);
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			{
-				//dump data from TX packet buffer				
-				rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
+			else if(v1 & BIT30){ //negative condition
+			//do nothing
 			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
 		}
+		else
+		{
+			if(bMatched)
+			odm_ConfigBB_PHY_8188E(pDM_Odm, v1, bMaskDWord, v2);
+		}
+	i = i + 2;
 	}
-#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-	return rst;
+}
+
+u4Byte
+ODM_GetVersion_MP_8188E_PHY_REG(void)
+{
+	   return 53;
 }
 
 /******************************************************************************
@@ -1595,22 +1070,15 @@ ODM_ReadAndConfig_MP_8188E_PHY_REG_PG(
  	IN   PDM_ODM_T  pDM_Odm
  	)
 {
-	u4Byte     hex = 0;
-	u4Byte     i           = 0;
-	u2Byte     count       = 0;
-	pu4Byte    ptr_array   = NULL;
-	u1Byte     platform    = pDM_Odm->SupportPlatform;
-	u1Byte     _interface   = pDM_Odm->SupportInterface;
-	u1Byte     board       = pDM_Odm->BoardType;  
-	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_PHY_REG_PG)/sizeof(u4Byte);
-	pu4Byte    Array       = Array_MP_8188E_PHY_REG_PG;
+    u4Byte     i         = 0;
+    u4Byte     ArrayLen    = sizeof(Array_MP_8188E_PHY_REG_PG)/sizeof(u4Byte);
+    pu4Byte    Array       = Array_MP_8188E_PHY_REG_PG;
+
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8188E_PHY_REG_PG\n"));
 
 	pDM_Odm->PhyRegPgVersion = 1;
 	pDM_Odm->PhyRegPgValueType = PHY_REG_PG_EXACT_VALUE;
-	hex += board;
-	hex += _interface << 8;
-	hex += platform << 16;
-	hex += 0xFF000000;
+
 	for (i = 0; i < ArrayLen; i += 6 )
 	{
 	    u4Byte v1 = Array[i];
@@ -1620,29 +1088,7 @@ ODM_ReadAndConfig_MP_8188E_PHY_REG_PG(
 	    u4Byte v5 = Array[i+4];
 	    u4Byte v6 = Array[i+5];
 
-	    // this line is a line of pure_body
-	    if ( v1 < 0xCDCDCDCD )
-	    {
-		 	 odm_ConfigBB_PHY_REG_PG_8188E(pDM_Odm, v1, v2, v3, v4, v5, v6);
-		 	 continue;
-	    }
-	    else
-	    { // this line is the start of branch
-	        if ( !CheckCondition(Array[i], hex) )
-	        { // don't need the hw_body
-	            i += 2; // skip the pair of expression
-	            v1 = Array[i];
-	            v2 = Array[i+1];
-	            v3 = Array[i+2];
-	            while (v2 != 0xDEAD)
-	            {
-	                i += 3;
-	                v1 = Array[i];
-	                v2 = Array[i+1];
-	                v3 = Array[i+1];
-	            }
-	        }
-	    }
+	    odm_ConfigBB_PHY_REG_PG_8188E(pDM_Odm, v1, v2, v3, v4, v5, v6);
 	}
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.h
index 1bd271c66bba..807fd2a12688 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_BB.h
@@ -22,43 +22,26 @@
 #ifndef __INC_MP_BB_HW_IMG_8188E_H
 #define __INC_MP_BB_HW_IMG_8188E_H
 
-//static BOOLEAN CheckCondition(const u4Byte Condition, const u4Byte Hex);
 
 /******************************************************************************
-*                           AGC_TAB_1T.TXT
+*                           AGC_TAB.TXT
 ******************************************************************************/
 
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_AGC_TAB_1T( // TC: Test Chip, MP: MP Chip
-	IN   PDM_ODM_T  pDM_Odm
-);
-
-/******************************************************************************
-*                           AGC_TAB_1T_ICUT.TXT
-******************************************************************************/
-
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_AGC_TAB_1T_ICUT( // TC: Test Chip, MP: MP Chip
-	IN   PDM_ODM_T  pDM_Odm
-);
-
-/******************************************************************************
-*                           PHY_REG_1T.TXT
-******************************************************************************/
-
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_PHY_REG_1T( // TC: Test Chip, MP: MP Chip
+void
+ODM_ReadAndConfig_MP_8188E_AGC_TAB( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
+u4Byte ODM_GetVersion_MP_8188E_AGC_TAB(void);
 
 /******************************************************************************
-*                           PHY_REG_1T_ICUT.TXT
+*                           PHY_REG.TXT
 ******************************************************************************/
 
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_PHY_REG_1T_ICUT( // TC: Test Chip, MP: MP Chip
+void
+ODM_ReadAndConfig_MP_8188E_PHY_REG( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
+u4Byte ODM_GetVersion_MP_8188E_PHY_REG(void);
 
 /******************************************************************************
 *                           PHY_REG_PG.TXT
@@ -68,6 +51,7 @@ void
 ODM_ReadAndConfig_MP_8188E_PHY_REG_PG( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
+u4Byte ODM_GetVersion_MP_8188E_PHY_REG_PG(void);
 
 #endif
 #endif // end of HWIMG_SUPPORT
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.c
index 497f3a1a0650..8a73cc691699 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.c
@@ -18,85 +18,21 @@
 * 
 ******************************************************************************/
 
-
-#include "../odm_precomp.h"
+#include "Mp_Precomp.h"
+#include "../phydm_precomp.h"
 
 #if (RTL8188E_SUPPORT == 1)
 #if(DM_ODM_SUPPORT_TYPE & (ODM_AP))
 
 
 u1Byte Array_MP_8188E_FW_AP[] = {
-0x00, 0x95, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x18, 0x19, 0x12, 0x5A, 0x3B, 0x00, 0x00, 
-0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x02, 0x49, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x02, 0x59, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x02, 0x59, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x5F, 0xDD, 0x00, 0x00, 
-0x0F, 0xF0, 0x8F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0xF0, 
-0x8F, 0x0F, 0x00, 0x00, 0x00, 0x05, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xF0, 0x8F, 0x0F, 
-0x00, 0x00, 0x00, 0x0A, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 
-0x04, 0x03, 0x02, 0x00, 0x03, 0x06, 0x05, 0x04, 0x03, 0x00, 0x04, 0x06, 0x05, 0x04, 0x02, 0x00, 
-0x04, 0x08, 0x07, 0x06, 0x04, 0x00, 0x06, 0x0A, 0x09, 0x08, 0x06, 0x00, 0x08, 0x0A, 0x09, 0x08, 
-0x04, 0x00, 0x08, 0x0A, 0x09, 0x08, 0x02, 0x00, 0x08, 0x0A, 0x09, 0x08, 0x00, 0x00, 0x08, 0x12, 
-0x11, 0x10, 0x08, 0x00, 0x10, 0x1A, 0x19, 0x18, 0x10, 0x00, 0x18, 0x22, 0x21, 0x20, 0x18, 0x00, 
-0x20, 0x22, 0x21, 0x20, 0x10, 0x00, 0x20, 0x22, 0x21, 0x20, 0x08, 0x00, 0x20, 0x22, 0x21, 0x1C, 
-0x08, 0x00, 0x20, 0x22, 0x21, 0x14, 0x08, 0x00, 0x20, 0x22, 0x20, 0x18, 0x08, 0x00, 0x20, 0x31, 
-0x30, 0x20, 0x10, 0x00, 0x30, 0x31, 0x30, 0x18, 0x00, 0x00, 0x30, 0x31, 0x2F, 0x10, 0x10, 0x00, 
-0x30, 0x31, 0x2C, 0x10, 0x10, 0x00, 0x30, 0x31, 0x28, 0x10, 0x00, 0x00, 0x30, 0x31, 0x20, 0x10, 
-0x00, 0x00, 0x30, 0x31, 0x10, 0x10, 0x00, 0x00, 0x30, 0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x05, 
-0x07, 0x07, 0x07, 0x08, 0x0A, 0x04, 0x04, 0x04, 0x04, 0x06, 0x0A, 0x0B, 0x0D, 0x05, 0x05, 0x07, 
-0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 0x05, 0x07, 
-0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x05, 
-0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 
-0x0F, 0x0F, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x04, 0x04, 0x04, 
-0x05, 0x07, 0x07, 0x09, 0x09, 0x0C, 0x0E, 0x10, 0x12, 0x04, 0x04, 0x05, 0x05, 0x06, 0x0A, 0x11, 
-0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 
-0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 
-0x0E, 0x11, 0x13, 0x13, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 0x13, 0x09, 
-0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x26, 0x2A, 0x18, 0x1A, 0x1D, 
-0x1F, 0x21, 0x27, 0x29, 0x2A, 0x00, 0x00, 0x00, 0x1F, 0x23, 0x28, 0x2A, 0x2C, 0x00, 0x00, 0x00, 
-0x1F, 0x23, 0x28, 0x2A, 0x2C, 0x00, 0x00, 0x00, 0x1F, 0x23, 0x28, 0x2A, 0x2C, 0x00, 0x00, 0x00, 
-0x1F, 0x23, 0x28, 0x2A, 0x2C, 0x2C, 0x2C, 0x00, 0x00, 0x00, 0x1F, 0x23, 0x28, 0x2A, 0x2C, 0x2C, 
-0x2C, 0x00, 0x00, 0x00, 0x1F, 0x23, 0x28, 0x2A, 0x2C, 0x2C, 0x2C, 0x00, 0x00, 0x00, 0x1F, 0x23, 
-0x28, 0x2A, 0x2C, 0x2C, 0x2C, 0x00, 0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x18, 0x00, 
-0x24, 0x00, 0x30, 0x00, 0x48, 0x00, 0x60, 0x00, 0x90, 0x00, 0xC0, 0x00, 0xD8, 0x00, 0x50, 0x00, 
-0x78, 0x00, 0xA0, 0x00, 0xC8, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x02, 0x30, 0x01, 0x2C, 0x01, 
-0x40, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x01, 0x2C, 0x01, 
-0x40, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x01, 0x2C, 0x01, 
-0x40, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x01, 0x2C, 0x01, 
-0x40, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 
-0xD0, 0x01, 0x2C, 0x01, 0x40, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 
-0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x01, 0x2C, 0x01, 0x40, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 
-0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x01, 0x2C, 0x01, 0x40, 0x01, 0xE0, 0x02, 
-0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x00, 0x02, 0x00, 
-0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x12, 0x00, 0x18, 0x00, 0x24, 0x00, 0x30, 0x00, 
-0x48, 0x00, 0x60, 0x00, 0x6C, 0x00, 0x28, 0x00, 0x3C, 0x00, 0x50, 0x00, 0x64, 0x00, 0xA0, 0x00, 
-0xC8, 0x00, 0xF0, 0x01, 0x18, 0x00, 0x64, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 
-0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 0x64, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 
-0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 0x64, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 
-0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 0x64, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 
-0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x00, 0x64, 0x00, 0xA0, 0x00, 0xF0, 0x01, 
-0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x00, 0x64, 0x00, 
-0xA0, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 
-0xE8, 0x00, 0x64, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 
-0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x10, 0x18, 0x20, 0x30, 0x40, 
-0x50, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x06, 0x07, 0x05, 0x05, 0x05, 
-0x06, 0x06, 0x07, 0x07, 0x08, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 
-0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 
-0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 
-0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 
-0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
-0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 
-0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 
-0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 
-0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 
-0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x20, 0x1E, 0x1C, 0x18, 0x10, 0x18, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xE1, 0x88, 0x20, 0x00, 0x14, 0x00, 0x00, 0x00, 0x09, 0x11, 0x20, 0x13, 0xCA, 0x37, 0x00, 0x00, 
+0xEE, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x45, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0xC1, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0xA1, 0xEE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0xFA, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
@@ -108,48 +44,48 @@ u1Byte Array_MP_8188E_FW_AP[] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x45, 0x04, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x41, 0x04, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
 0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
-0xEC, 0x24, 0x89, 0xF8, 0xE6, 0xBC, 0x03, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
-0x40, 0xCE, 0x79, 0x04, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
 0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
-0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x04, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
-0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x88, 0x25, 0x0C, 0xF8, 
-0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x03, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
 0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
-0x0C, 0x24, 0x89, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x03, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
-0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x88, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
 0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
 0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
-0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x88, 0xA6, 
-0x81, 0x74, 0x03, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x04, 0xE4, 0x78, 0x80, 
-0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x49, 0xF8, 0x74, 0x01, 0x93, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x45, 0xE8, 0x74, 0x01, 0x93, 
 0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
-0x8C, 0xD2, 0xAF, 0x22, 0x03, 0xEF, 0xD3, 0x94, 0x03, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
 0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
-0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x88, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
-0xBE, 0x03, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
 0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
-0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x88, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
 0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
-0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x88, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
-0x04, 0x90, 0x49, 0xF8, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
-0x94, 0x03, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
-0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x88, 0x2F, 
-0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x45, 0x4D, 0x50, 0x2E, 0x74, 0x89, 0x2F, 0xF8, 0xE6, 0xBF, 0x03, 
-0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x88, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x45, 0xE8, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x41, 0x4D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
 0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
-0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x89, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
-0x0F, 0x74, 0x88, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
 0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
-0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x03, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
-0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x45, 0x4C, 0x8F, 0xF0, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x41, 0x4C, 0x8F, 0xF0, 
 0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
 0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x30, 0x50, 0x2E, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
 0x60, 0x25, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x23, 0x0E, 0x30, 
 0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x12, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x13, 0x54, 0xEC, 
-0x4E, 0xF6, 0xD2, 0xAF, 0x02, 0x45, 0x4D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 0xC2, 0xAF, 
+0x4E, 0xF6, 0xD2, 0xAF, 0x02, 0x41, 0x4D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 0xC2, 0xAF, 
 0x56, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0xE7, 0x09, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 
 0x46, 0xE7, 0x09, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x3E, 0x88, 0x82, 0x8C, 0x83, 0xE7, 0x09, 0xF0, 
 0xA3, 0xDF, 0xFA, 0x80, 0x32, 0xE3, 0x09, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 0x78, 0xE3, 0x09, 0xF2, 
@@ -165,821 +101,828 @@ u1Byte Array_MP_8188E_FW_AP[] = {
 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xEA, 0xDE, 0xE8, 0x80, 0xDB, 0x89, 0x82, 0x8A, 0x83, 
 0xE4, 0x93, 0xA3, 0xF2, 0x08, 0xDF, 0xF9, 0x80, 0xCC, 0x88, 0xF0, 0xEF, 0x60, 0x01, 0x0E, 0x4E, 
 0x60, 0xC3, 0x88, 0xF0, 0xED, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0xB9, 0xF5, 0x82, 0xEB, 0x24, 
-0x02, 0xB4, 0x04, 0x00, 0x50, 0xAF, 0x23, 0x23, 0x45, 0x82, 0x23, 0x90, 0x47, 0xF9, 0x73, 0xC5, 
+0x02, 0xB4, 0x04, 0x00, 0x50, 0xAF, 0x23, 0x23, 0x45, 0x82, 0x23, 0x90, 0x43, 0xF9, 0x73, 0xC5, 
 0xF0, 0xF8, 0xA3, 0xE0, 0x28, 0xF0, 0xC5, 0xF0, 0xF8, 0xE5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 
-0x83, 0xE0, 0x38, 0xF0, 0x22, 0xBB, 0x01, 0x0A, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 
-0xE0, 0x22, 0x50, 0x06, 0x87, 0xF0, 0x09, 0xE7, 0x19, 0x22, 0xBB, 0xFE, 0x07, 0xE3, 0xF5, 0xF0, 
-0x09, 0xE3, 0x19, 0x22, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xF5, 0xF0, 0x74, 0x01, 0x93, 0x22, 
-0xBB, 0x01, 0x10, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE5, 0x83, 0x3A, 0xF5, 0x83, 0xE0, 0xF5, 0xF0, 
-0xA3, 0xE0, 0x22, 0x50, 0x09, 0xE9, 0x25, 0x82, 0xF8, 0x86, 0xF0, 0x08, 0xE6, 0x22, 0xBB, 0xFE, 
-0x0A, 0xE9, 0x25, 0x82, 0xF8, 0xE2, 0xF5, 0xF0, 0x08, 0xE2, 0x22, 0xE5, 0x83, 0x2A, 0xF5, 0x83, 
-0xE9, 0x93, 0xF5, 0xF0, 0xA3, 0xE9, 0x93, 0x22, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFE, 
-0xA3, 0xE0, 0xFF, 0x22, 0xA4, 0x25, 0x82, 0xF5, 0x82, 0xE5, 0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 
-0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 
-0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 
-0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 
-0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0x02, 0x49, 0xA6, 0x02, 0x45, 0xDD, 0xE4, 0x93, 
-0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 0x08, 0xDF, 0xF4, 0x80, 0x29, 
-0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 0xC4, 0x54, 0x0F, 0x44, 0x20, 
-0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 0xE4, 0x80, 0x0B, 0x01, 0x02, 
-0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x49, 0xEB, 0xE4, 0x7E, 0x01, 0x93, 0x60, 0xBC, 0xA3, 
-0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 
-0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 
-0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 
-0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 0x00, 0x41, 0x9E, 0xA8, 0x00, 
-0x41, 0x9E, 0xA9, 0x00, 0x41, 0x9E, 0xBA, 0x00, 0x4A, 0xEA, 0x4D, 0xD3, 0x52, 0xD2, 0x57, 0xF6, 
-0x90, 0x00, 0xF0, 0xE0, 0x7F, 0x01, 0x20, 0xE2, 0x02, 0x7F, 0x03, 0x22, 0x51, 0x00, 0x90, 0x9C, 
-0x94, 0xEF, 0xF0, 0x51, 0x1E, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x02, 0x2D, 0x4A, 0x51, 0x89, 
-0x51, 0xB9, 0x51, 0x4B, 0x51, 0x6A, 0xE4, 0xF5, 0x0D, 0xF5, 0x0E, 0xF5, 0x0F, 0xF5, 0x10, 0xAD, 
-0x0D, 0x7F, 0x50, 0x12, 0x31, 0xE4, 0xAD, 0x0E, 0x7F, 0x51, 0x12, 0x31, 0xE4, 0xAD, 0x0F, 0x7F, 
-0x52, 0x12, 0x31, 0xE4, 0xAD, 0x10, 0x7F, 0x53, 0x02, 0x31, 0xE4, 0x75, 0x15, 0x12, 0xE4, 0xF5, 
-0x16, 0x75, 0x17, 0x07, 0x75, 0x18, 0x32, 0x90, 0x01, 0x30, 0xE5, 0x15, 0xF0, 0xA3, 0xE5, 0x16, 
-0xF0, 0xA3, 0xE5, 0x17, 0xF0, 0xA3, 0xE5, 0x18, 0xF0, 0x22, 0x75, 0x1D, 0x0E, 0x75, 0x1E, 0x01, 
-0x75, 0x1F, 0x03, 0x75, 0x20, 0x62, 0x90, 0x01, 0x38, 0xE5, 0x1D, 0xF0, 0xA3, 0xE5, 0x1E, 0xF0, 
-0xA3, 0xE5, 0x1F, 0xF0, 0xA3, 0xE5, 0x20, 0xF0, 0x22, 0x90, 0x01, 0x30, 0xE4, 0xF0, 0xA3, 0xF0, 
-0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x38, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xFD, 0x7F, 
-0x50, 0x12, 0x31, 0xE4, 0xE4, 0xFD, 0x7F, 0x51, 0x12, 0x31, 0xE4, 0xE4, 0xFD, 0x7F, 0x52, 0x12, 
-0x31, 0xE4, 0xE4, 0xFD, 0x7F, 0x53, 0x02, 0x31, 0xE4, 0x90, 0x01, 0x34, 0x74, 0xFF, 0xF0, 0xA3, 
-0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x3C, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xFD, 
-0x7F, 0x54, 0x12, 0x31, 0xE4, 0x7D, 0xFF, 0x7F, 0x55, 0x12, 0x31, 0xE4, 0x7D, 0xFF, 0x7F, 0x56, 
-0x12, 0x31, 0xE4, 0x7D, 0xFF, 0x7F, 0x57, 0x02, 0x31, 0xE4, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 
-0xFD, 0x7F, 0x80, 0x12, 0x31, 0xE4, 0x71, 0x6B, 0x12, 0x32, 0x25, 0x71, 0x85, 0x7F, 0x01, 0x12, 
-0x46, 0x15, 0x90, 0x9D, 0xCA, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x46, 0x15, 0x90, 0x9D, 0xCA, 0xE0, 
-0x04, 0xF0, 0x7F, 0x03, 0x12, 0x46, 0x15, 0x90, 0x9D, 0xCA, 0xE0, 0x04, 0xF0, 0x51, 0x0C, 0x71, 
-0x39, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 0x31, 0xE4, 0x75, 0x28, 0xFF, 
-0x71, 0x5C, 0x71, 0xB5, 0xE4, 0xFF, 0x02, 0x46, 0x9E, 0x71, 0x56, 0x71, 0x63, 0x91, 0xB7, 0x91, 
-0x0A, 0x71, 0x73, 0x90, 0x9D, 0xCE, 0xE0, 0x54, 0xFE, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0xA3, 0xF0, 
-0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xE4, 0x90, 0x9D, 0x36, 0xF0, 0x22, 0x75, 0xE8, 0x03, 0x75, 
-0xA8, 0x85, 0x22, 0xE4, 0x90, 0x9D, 0x30, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 
-0x01, 0xF0, 0x22, 0x90, 0x9D, 0xCB, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0x7F, 0xF0, 0xA3, 0x74, 0x0A, 
-0xF0, 0xE4, 0xA3, 0xF0, 0x22, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9C, 0x74, 
-0x7E, 0xF0, 0xA3, 0x74, 0x92, 0xF0, 0xA3, 0x74, 0xA0, 0xF0, 0xA3, 0x74, 0x24, 0xF0, 0x90, 0x01, 
-0x9B, 0x74, 0x49, 0xF0, 0x90, 0x01, 0x9A, 0x74, 0xE0, 0xF0, 0x90, 0x01, 0x99, 0xE4, 0xF0, 0x90, 
-0x01, 0x98, 0x04, 0xF0, 0x22, 0xE4, 0x90, 0x9D, 0xD3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x98, 0xE0, 
-0x7F, 0x00, 0x30, 0xE4, 0x02, 0x7F, 0x01, 0xEF, 0x64, 0x01, 0x60, 0x3D, 0xC3, 0x90, 0x9D, 0xD4, 
-0xE0, 0x94, 0x88, 0x90, 0x9D, 0xD3, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 
-0x10, 0xF0, 0x22, 0x90, 0x9D, 0xD3, 0xE4, 0x75, 0xF0, 0x01, 0x11, 0x9F, 0x7F, 0x14, 0x7E, 0x00, 
-0x12, 0x32, 0x58, 0xD3, 0x90, 0x9D, 0xD4, 0xE0, 0x94, 0x32, 0x90, 0x9D, 0xD3, 0xE0, 0x94, 0x00, 
-0x40, 0xBA, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xB3, 0x22, 0xE4, 0x90, 0x9D, 0xBA, 0xF0, 0x90, 
-0x9D, 0xB9, 0xE0, 0x54, 0x0F, 0xF0, 0x54, 0xF0, 0xF0, 0x90, 0x9D, 0xB7, 0xE0, 0x54, 0xFD, 0xF0, 
-0x54, 0xF7, 0xF0, 0x54, 0xEF, 0xF0, 0x90, 0x9D, 0xBF, 0x74, 0x01, 0xF0, 0xA3, 0xF0, 0x90, 0x9D, 
-0xB7, 0xE0, 0x54, 0xFB, 0xF0, 0xA3, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x9D, 0xC2, 0xF0, 0x90, 
-0x9D, 0xC1, 0x74, 0x07, 0xF0, 0x90, 0x9D, 0xC4, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0xE4, 0x90, 
-0x9D, 0xBD, 0xF0, 0x90, 0x9D, 0xB7, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x9D, 0xBB, 0x74, 0x0C, 0xF0, 
-0x90, 0x9D, 0xB7, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x9D, 0xBC, 0x74, 0x0C, 0xF0, 0x90, 0x9D, 0xB7, 
-0xE0, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0xA3, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 0x54, 
-0xF7, 0xF0, 0x90, 0x9C, 0x94, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 0x9D, 0xC3, 0x74, 0x93, 0xF0, 
-0x80, 0x0F, 0xEF, 0x90, 0x9D, 0xC3, 0xB4, 0x03, 0x05, 0x74, 0xDC, 0xF0, 0x80, 0x03, 0x74, 0x40, 
-0xF0, 0x90, 0x9D, 0xC6, 0x74, 0x01, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 
-0x28, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x22, 0xE4, 0xFF, 0xE4, 0xFE, 0x75, 0xF0, 0x10, 0xEF, 0x90, 
-0x81, 0x00, 0xBE, 0x03, 0x11, 0x31, 0x24, 0xE5, 0x82, 0x2E, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 
-0x83, 0x74, 0x80, 0xF0, 0x80, 0x0E, 0x31, 0x24, 0xE5, 0x82, 0x2E, 0xF5, 0x82, 0xE4, 0x35, 0x83, 
-0xF5, 0x83, 0xE4, 0xF0, 0x75, 0xF0, 0x08, 0xEF, 0x90, 0x89, 0x00, 0x31, 0x24, 0xE5, 0x82, 0x2E, 
-0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xE4, 0xF0, 0x0E, 0xBE, 0x10, 0xBE, 0x0F, 0xBF, 0x80, 
-0xB8, 0xE4, 0x90, 0xAF, 0x71, 0xF0, 0xFF, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 0x8D, 0x01, 0x31, 0x24, 
-0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 0x8D, 0x03, 0x31, 0x24, 0xE4, 0xF0, 0xA3, 
-0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 0x8D, 0x05, 0x31, 0x24, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 
-0x0A, 0xEF, 0x90, 0x8D, 0x07, 0x31, 0x24, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 
-0x8D, 0x09, 0x31, 0x24, 0xE4, 0xF0, 0xA3, 0xF0, 0xEF, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 
-0x34, 0x92, 0xF5, 0x83, 0xE4, 0xF0, 0xA3, 0xF0, 0x74, 0x93, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x99, 
-0xF5, 0x83, 0xE4, 0xF0, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x98, 0x31, 0x24, 0x74, 0x01, 0xF0, 
-0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x99, 0x31, 0x24, 0xE4, 0xF0, 0x75, 0xF0, 0x09, 0xEF, 0x90, 
-0x94, 0x97, 0x31, 0x24, 0x74, 0x01, 0xF0, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x95, 0x31, 0x24, 
-0x74, 0x09, 0xF0, 0xF5, 0xF0, 0xEF, 0x90, 0x94, 0x96, 0x31, 0x24, 0xE4, 0xF0, 0x75, 0xF0, 0x09, 
-0xEF, 0x90, 0x94, 0x93, 0x31, 0x24, 0x74, 0x13, 0xF0, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x94, 
-0x31, 0x24, 0xE4, 0xF0, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x00, 0x31, 0x24, 0x74, 0x13, 0xF0, 
-0x0F, 0xEF, 0x64, 0x80, 0x60, 0x02, 0xA1, 0x07, 0x7F, 0x20, 0x90, 0x9E, 0x7B, 0xE4, 0xF0, 0xA3, 
-0xDF, 0xFC, 0x22, 0xE4, 0x90, 0x9D, 0xD5, 0xF0, 0x90, 0x9D, 0xD5, 0xE0, 0x64, 0x01, 0xF0, 0x24, 
-0xD3, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x4D, 0xA3, 0xF0, 0x90, 0x9D, 0xBC, 0xE0, 0xFF, 0x90, 0x9D, 
-0xBB, 0xE0, 0x6F, 0x60, 0x03, 0x12, 0x5F, 0xC4, 0x90, 0x9D, 0xB7, 0xE0, 0x30, 0xE0, 0x09, 0x12, 
-0x67, 0xF4, 0xBF, 0x01, 0x03, 0x12, 0x6B, 0x36, 0x90, 0x9D, 0xBC, 0xE0, 0x90, 0x01, 0xBC, 0xF0, 
-0x90, 0x9D, 0x36, 0xE0, 0x90, 0x01, 0xBD, 0xF0, 0xD1, 0x3B, 0x90, 0x00, 0x02, 0xE0, 0x54, 0xFE, 
-0xF0, 0x7F, 0xF4, 0x7E, 0x01, 0x12, 0x32, 0x58, 0x90, 0x00, 0x02, 0xE0, 0x44, 0x01, 0xF0, 0x7F, 
-0xF4, 0x7E, 0x01, 0x12, 0x32, 0x58, 0x12, 0x45, 0x4D, 0x80, 0x9D, 0x12, 0x7A, 0x45, 0x12, 0x52, 
-0x73, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0x90, 0x9E, 0xAB, 0xF0, 0x90, 0x00, 0x8F, 
-0xE0, 0x20, 0xE6, 0x03, 0x02, 0x51, 0x91, 0x90, 0x00, 0x8D, 0xE0, 0x90, 0x9E, 0xAA, 0xF0, 0x90, 
-0x00, 0x8C, 0xE0, 0x90, 0x9E, 0xAB, 0xF0, 0x90, 0x9E, 0xAA, 0xE0, 0x31, 0x42, 0x4E, 0x86, 0x01, 
-0x4E, 0x91, 0x02, 0x4E, 0x9C, 0x04, 0x4F, 0x8A, 0x05, 0x50, 0x82, 0x06, 0x51, 0x07, 0x07, 0x51, 
-0x4B, 0x08, 0x00, 0x00, 0x51, 0x83, 0x90, 0x9E, 0xAB, 0xE0, 0xFF, 0x12, 0x52, 0x18, 0x02, 0x51, 
-0x83, 0x90, 0x9E, 0xAB, 0xE0, 0xFF, 0x12, 0x51, 0xC4, 0x02, 0x51, 0x83, 0x90, 0x9E, 0xAB, 0xE0, 
-0x75, 0xF0, 0x09, 0x90, 0x94, 0x98, 0x31, 0x24, 0xE0, 0xFB, 0xE4, 0xFD, 0xFF, 0x12, 0x51, 0x9C, 
-0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x09, 0x90, 0x94, 0x96, 0x12, 0x51, 0x96, 0x90, 0x9E, 0xAB, 
-0xE0, 0x75, 0xF0, 0x09, 0x90, 0x94, 0x9B, 0x12, 0x51, 0x96, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 
-0x09, 0x90, 0x94, 0x99, 0x12, 0x51, 0x96, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x09, 0x90, 0x94, 
-0x93, 0x31, 0x24, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x12, 0x51, 0x9C, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 
-0xF0, 0x09, 0x90, 0x94, 0x94, 0x12, 0x51, 0x96, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x09, 0x90, 
-0x94, 0x97, 0x12, 0x51, 0x96, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x09, 0x90, 0x94, 0x95, 0x12, 
-0x51, 0x96, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x00, 0x31, 0x24, 0xE0, 0xFB, 
-0xE4, 0xFD, 0x0F, 0x12, 0x51, 0x9C, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x01, 
-0x12, 0x51, 0x96, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x02, 0x12, 0x51, 0x96, 
-0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x03, 0x12, 0x51, 0x96, 0x90, 0x9E, 0xAB, 
-0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x04, 0x31, 0x24, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x12, 0x51, 
-0x9C, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x05, 0x12, 0x51, 0x96, 0x90, 0x9E, 
-0xAB, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x06, 0x12, 0x51, 0x96, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 
-0xF0, 0x08, 0x90, 0x89, 0x07, 0x31, 0x24, 0x02, 0x51, 0x46, 0x90, 0x9E, 0xAB, 0xE0, 0x25, 0xE0, 
-0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xA3, 0xE0, 0xFB, 0xE4, 0xFD, 0xFF, 0x12, 
-0x51, 0x9C, 0x90, 0x9E, 0xAB, 0xE0, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 
-0x83, 0xE0, 0xFB, 0x0D, 0x12, 0x51, 0x9C, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x0A, 0x90, 0x8D, 
-0x01, 0x31, 0x24, 0xA3, 0xE0, 0xFB, 0x0D, 0x12, 0x51, 0x9C, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 
-0x0A, 0x90, 0x8D, 0x01, 0x12, 0x51, 0x96, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x0A, 0x90, 0x8D, 
-0x03, 0x31, 0x24, 0xA3, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x12, 0x51, 0x9C, 0x90, 0x9E, 0xAB, 0xE0, 
-0x75, 0xF0, 0x0A, 0x90, 0x8D, 0x05, 0x31, 0x24, 0xA3, 0xE0, 0xFB, 0x0D, 0x12, 0x51, 0x9C, 0x90, 
-0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x0A, 0x90, 0x8D, 0x07, 0x12, 0x49, 0x24, 0xA3, 0xE0, 0xFB, 0x0D, 
-0x31, 0x9C, 0x90, 0x9E, 0xAB, 0xE0, 0x75, 0xF0, 0x0A, 0x90, 0x8D, 0x09, 0x12, 0x49, 0x24, 0xA3, 
-0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0xAB, 0xE0, 0x24, 0x93, 0xF5, 0x82, 0xE4, 0x34, 0x99, 
-0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x31, 0x9C, 0x90, 0x9E, 0xAB, 0xE0, 0x25, 0xE0, 0x24, 
-0x91, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0xA3, 0xE0, 0xFB, 0x7D, 0x02, 0x31, 0x9C, 0x90, 
-0x9E, 0xAB, 0xE0, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0xE0, 0xFB, 
-0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x7B, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x31, 0x9C, 0x90, 0x9E, 0x7C, 
-0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x7D, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x7E, 
-0x21, 0x46, 0x90, 0x9E, 0x83, 0xE0, 0xFB, 0xE4, 0xFD, 0xFF, 0x31, 0x9C, 0x90, 0x9E, 0x84, 0xE0, 
-0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x85, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x86, 0xE0, 
-0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x87, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x31, 0x9C, 0x90, 0x9E, 
-0x88, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x89, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 
-0x8A, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x8B, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x31, 0x9C, 
-0x90, 0x9E, 0x8C, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x8D, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 
-0x90, 0x9E, 0x8E, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x8F, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 
-0x31, 0x9C, 0x90, 0x9E, 0x90, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x91, 0xE0, 0xFB, 0x0D, 
-0x31, 0x9C, 0x90, 0x9E, 0x92, 0x80, 0x3F, 0x90, 0x9E, 0x93, 0xE0, 0xFB, 0xE4, 0xFD, 0xFF, 0x31, 
-0x9C, 0x90, 0x9E, 0x94, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x95, 0xE0, 0xFB, 0x0D, 0x31, 
-0x9C, 0x90, 0x9E, 0x96, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x97, 0xE0, 0xFB, 0xE4, 0xFD, 
-0x0F, 0x31, 0x9C, 0x90, 0x9E, 0x98, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x99, 0xE0, 0xFB, 
-0x0D, 0x31, 0x9C, 0x90, 0x9E, 0x9A, 0xE0, 0xFB, 0x0D, 0x80, 0x36, 0x90, 0x9D, 0xBA, 0xE0, 0xFB, 
-0xE4, 0xFD, 0xFF, 0x31, 0x9C, 0x90, 0x9D, 0xB9, 0xE0, 0x54, 0x0F, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 
-0x9D, 0xBB, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 0x9D, 0xBC, 0xE0, 0xFB, 0x0D, 0x31, 0x9C, 0x90, 
-0x9E, 0xAB, 0xE0, 0x24, 0x36, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFD, 
-0x0F, 0x31, 0x9C, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE0, 0x07, 0xE4, 0xFD, 0x7F, 0x8D, 0x12, 0x31, 
-0xE4, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x49, 0x24, 0xE0, 0xFB, 0x0D, 0xEF, 0x70, 0x04, 0x74, 
-0xF0, 0x80, 0x16, 0xEF, 0xB4, 0x01, 0x04, 0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 0x74, 
-0xF8, 0x80, 0x06, 0xEF, 0xB4, 0x03, 0x0C, 0x74, 0xFC, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 
-0x83, 0xEB, 0xF0, 0x22, 0x8F, 0x27, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE6, 0x4A, 0x90, 0x00, 0x8D, 
-0xE0, 0x64, 0x02, 0x70, 0x42, 0x90, 0x9E, 0xB9, 0xF0, 0x90, 0x9E, 0xB9, 0xE0, 0xFD, 0xE5, 0x27, 
-0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0xE5, 0x82, 0x2D, 
-0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFF, 0x31, 0x9C, 0x90, 0x9E, 0xB9, 
-0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x08, 0x40, 0xD0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE0, 0x07, 
-0xE4, 0xFD, 0x7F, 0x8D, 0x12, 0x31, 0xE4, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 
-0x26, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE6, 0x46, 0x90, 0x00, 0x8D, 0xE0, 0x64, 0x01, 0x70, 0x3E, 
-0x90, 0x9E, 0xB8, 0xF0, 0x90, 0x9E, 0xB8, 0xE0, 0xFD, 0x75, 0xF0, 0x10, 0xE5, 0x26, 0x90, 0x81, 
-0x00, 0x12, 0x49, 0x24, 0xE5, 0x82, 0x2D, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xE0, 0xFB, 
-0xE4, 0xFF, 0x31, 0x9C, 0x90, 0x9E, 0xB8, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x10, 0x40, 0xD4, 
-0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE0, 0x07, 0xE4, 0xFD, 0x7F, 0x8D, 0x12, 0x31, 0xE4, 0xD0, 0xD0, 
-0x92, 0xAF, 0x22, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE6, 0x57, 0x90, 0x00, 0x8D, 0xE0, 0x64, 0x03, 
-0x70, 0x4F, 0x90, 0x00, 0x8F, 0xE0, 0xFE, 0x90, 0x00, 0x8E, 0xE0, 0xFD, 0xED, 0xFF, 0x90, 0x9D, 
-0xD7, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0x90, 0x9D, 0xD6, 0xF0, 0x90, 0x9D, 0xD6, 0xE0, 0xFD, 
-0xFF, 0x90, 0x9D, 0xD8, 0xE0, 0x2F, 0xFF, 0x90, 0x9D, 0xD7, 0xE0, 0x34, 0x00, 0x8F, 0x82, 0xF5, 
-0x83, 0xE0, 0xFB, 0xE4, 0xFF, 0x31, 0x9C, 0x90, 0x9D, 0xD6, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 
-0x10, 0x40, 0xD8, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE0, 0x07, 0xE4, 0xFD, 0x7F, 0x8D, 0x12, 0x31, 
-0xE4, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x47, 0x4E, 0x90, 0x9D, 0xD9, 0xEF, 0xF0, 
-0x60, 0xF0, 0x90, 0x9E, 0x93, 0xE0, 0x04, 0xF0, 0x51, 0xEC, 0x80, 0xE6, 0xD3, 0x10, 0xAF, 0x01, 
-0xC3, 0xC0, 0xD0, 0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0x9D, 0xDA, 0xF0, 0x90, 0x9D, 0xDA, 
-0xE0, 0xFD, 0x70, 0x02, 0x81, 0x25, 0x90, 0x9E, 0xA8, 0xE0, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 
-0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 
-0x81, 0x0F, 0x90, 0x9E, 0xA8, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xD0, 0x12, 0x49, 0x24, 0xE0, 
-0x90, 0x9D, 0xDB, 0xF0, 0x75, 0x40, 0x01, 0x75, 0x41, 0x9D, 0x75, 0x42, 0xDB, 0x75, 0x43, 0x01, 
-0x7B, 0x01, 0x7A, 0x9D, 0x79, 0xDC, 0x12, 0x2B, 0x33, 0x90, 0x9E, 0xA8, 0xE0, 0x75, 0xF0, 0x04, 
-0x90, 0x01, 0xD1, 0x12, 0x49, 0x24, 0xE0, 0x90, 0x9D, 0xDD, 0xF0, 0x90, 0x9E, 0xA8, 0xE0, 0x75, 
-0xF0, 0x04, 0x90, 0x01, 0xD2, 0x12, 0x49, 0x24, 0xE0, 0x90, 0x9D, 0xDE, 0xF0, 0x90, 0x9E, 0xA8, 
-0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xD3, 0x12, 0x49, 0x24, 0xE0, 0x90, 0x9D, 0xDF, 0xF0, 0x90, 
-0x9E, 0xA8, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xF0, 0x12, 0x49, 0x24, 0xE0, 0x90, 0x9D, 0xE0, 
-0xF0, 0x90, 0x9E, 0xA8, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xF1, 0x12, 0x49, 0x24, 0xE0, 0x90, 
-0x9D, 0xE1, 0xF0, 0x90, 0x9E, 0xA8, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xF2, 0x12, 0x49, 0x24, 
-0xE0, 0x90, 0x9D, 0xE2, 0xF0, 0x90, 0x9E, 0xA8, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xF3, 0x12, 
-0x49, 0x24, 0xE0, 0x90, 0x9D, 0xE3, 0xF0, 0x90, 0x9D, 0xDA, 0xE0, 0xFF, 0x90, 0x9E, 0xA8, 0xE0, 
-0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0x9D, 
-0xDA, 0xF0, 0x90, 0x9E, 0xA8, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 
-0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x9D, 0xDC, 0xE0, 0xFF, 0x7B, 0x01, 0x7A, 0x9D, 0x79, 
-0xDD, 0x91, 0x2A, 0x90, 0x9E, 0xA8, 0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x41, 0xFD, 0x90, 
-0x01, 0xC0, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x4D, 0xE0, 0x64, 0x80, 0xF0, 0x90, 0x9E, 0xA8, 
-0xE0, 0x90, 0x00, 0x89, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x9D, 0xE4, 0x12, 0x49, 0x39, 
-0xEF, 0x12, 0x49, 0x42, 0x54, 0x56, 0x00, 0x54, 0x5F, 0x01, 0x54, 0x68, 0x02, 0x54, 0x71, 0x03, 
-0x54, 0x7A, 0x04, 0x54, 0x83, 0x20, 0x54, 0x8B, 0x21, 0x54, 0x94, 0x23, 0x54, 0x9C, 0x40, 0x54, 
-0xAB, 0x42, 0x00, 0x00, 0x54, 0xB4, 0x90, 0x9D, 0xE4, 0x12, 0x49, 0x30, 0x02, 0x65, 0xE8, 0x90, 
-0x9D, 0xE4, 0x12, 0x49, 0x30, 0x02, 0x66, 0x30, 0x90, 0x9D, 0xE4, 0x12, 0x49, 0x30, 0x02, 0x66, 
-0xC8, 0x90, 0x9D, 0xE4, 0x12, 0x49, 0x30, 0x02, 0x7A, 0x7D, 0x90, 0x9D, 0xE4, 0x12, 0x49, 0x30, 
-0x02, 0x7A, 0x9D, 0x90, 0x9D, 0xE4, 0x12, 0x49, 0x30, 0x80, 0x31, 0x90, 0x9D, 0xE4, 0x12, 0x49, 
-0x30, 0x02, 0x67, 0x00, 0x90, 0x9D, 0xE4, 0x12, 0x49, 0x30, 0xE1, 0xE4, 0x90, 0x9E, 0x94, 0xE0, 
-0x04, 0xF0, 0x90, 0x9D, 0xE4, 0x12, 0x49, 0x30, 0x02, 0x79, 0x17, 0x90, 0x9D, 0xE4, 0x12, 0x49, 
-0x30, 0x02, 0x79, 0xFE, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x12, 0x1F, 0x96, 0x90, 
-0x9D, 0xBA, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xAF, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 
-0x90, 0x9D, 0xB9, 0xE0, 0x54, 0xF0, 0x4E, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xAF, 0x54, 0x01, 
-0x25, 0xE0, 0xFE, 0x90, 0x9D, 0xB7, 0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 
-0xF0, 0xFF, 0x90, 0x9D, 0xB9, 0xE0, 0x54, 0x0F, 0x4F, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xAF, 
-0x90, 0x9D, 0xBB, 0xF0, 0xB1, 0x2B, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0xF0, 
-0x90, 0x9D, 0xBA, 0xE0, 0x90, 0x01, 0xBA, 0xF0, 0x90, 0x9D, 0xBB, 0xE0, 0x90, 0x01, 0xBB, 0xF0, 
-0x90, 0x9D, 0xB9, 0xE0, 0x54, 0x0F, 0x90, 0x01, 0xBE, 0xF0, 0x22, 0x90, 0x9D, 0xE7, 0x12, 0x49, 
-0x39, 0x12, 0x7A, 0xC7, 0x90, 0x9D, 0xBA, 0xE0, 0xFF, 0xB1, 0x5B, 0x90, 0x9D, 0xBA, 0xE0, 0x60, 
-0x19, 0x90, 0x9D, 0xE7, 0x12, 0x49, 0x30, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xAF, 0x54, 0x0F, 0xFF, 
-0x90, 0x00, 0x02, 0x12, 0x1F, 0xAF, 0xFD, 0x12, 0x7A, 0xD8, 0x22, 0xEF, 0x70, 0x3E, 0x7D, 0x01, 
-0xFF, 0x12, 0x5E, 0x47, 0x7D, 0x78, 0x7F, 0x02, 0x12, 0x5E, 0x47, 0x7D, 0x02, 0x7F, 0x03, 0x12, 
-0x5E, 0x47, 0x7D, 0xC8, 0x7F, 0x02, 0x12, 0x7A, 0x2D, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 
-0x3C, 0x74, 0x02, 0xF0, 0x7D, 0x01, 0x7F, 0x0C, 0xB1, 0xF5, 0x90, 0x9D, 0xB7, 0xE0, 0x54, 0xF7, 
-0xF0, 0x54, 0xEF, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 0x90, 0x01, 0x30, 0x74, 
-0x01, 0xF0, 0x90, 0x01, 0x36, 0x74, 0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x01, 0xE4, 0xFF, 
-0xF1, 0xA9, 0x7D, 0x78, 0x7F, 0x02, 0xF1, 0xA9, 0x7D, 0x02, 0x7F, 0x03, 0xF1, 0xA9, 0x90, 0x06, 
-0x0A, 0xE0, 0x44, 0x07, 0xF0, 0x90, 0x9D, 0xC4, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x90, 0x9D, 
-0x36, 0xE0, 0xB4, 0x01, 0x14, 0x90, 0x9D, 0xB8, 0xE0, 0x54, 0xFB, 0xF0, 0x90, 0x9D, 0xBC, 0xE0, 
-0x20, 0xE2, 0x0D, 0x7D, 0x01, 0x7F, 0x04, 0x80, 0x0C, 0x90, 0x9D, 0xB8, 0xE0, 0x44, 0x04, 0xF0, 
-0x22, 0x7D, 0x01, 0x7F, 0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9E, 0xB4, 0xED, 
-0xF0, 0x90, 0x9D, 0xBC, 0xE0, 0x90, 0x9E, 0xB5, 0xF0, 0x90, 0x9D, 0xB7, 0xE0, 0xFE, 0xC4, 0x13, 
-0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0xE1, 0x53, 0xEE, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x30, 
-0xE0, 0x02, 0xE1, 0x53, 0x90, 0x9E, 0xB5, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0xE1, 0x53, 0xEF, 0x70, 
-0x02, 0xC1, 0xC4, 0x24, 0xFC, 0x60, 0x52, 0x24, 0xFE, 0x70, 0x02, 0xE1, 0x00, 0x24, 0xFE, 0x70, 
-0x02, 0xE1, 0x3E, 0x24, 0xFC, 0x60, 0x02, 0xE1, 0x53, 0xEE, 0xB4, 0x0E, 0x03, 0x12, 0x7B, 0x1C, 
-0x90, 0x9E, 0xB5, 0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 0x6A, 0x9A, 0x90, 0x9E, 0xB5, 0xE0, 0xB4, 
-0x06, 0x02, 0xF1, 0xBE, 0x90, 0x9E, 0xB5, 0xE0, 0xB4, 0x04, 0x0F, 0x90, 0x9E, 0xB4, 0xE0, 0xFF, 
-0x60, 0x05, 0x12, 0x63, 0xEF, 0x80, 0x03, 0x12, 0x7B, 0x09, 0x90, 0x9E, 0xB5, 0xE0, 0x64, 0x08, 
-0x60, 0x02, 0xE1, 0x53, 0x12, 0x6A, 0xB3, 0xE1, 0x53, 0x90, 0x9E, 0xB5, 0xE0, 0x70, 0x05, 0x7F, 
-0x01, 0x12, 0x6A, 0x9A, 0x90, 0x9E, 0xB5, 0xE0, 0xB4, 0x06, 0x02, 0xF1, 0xBE, 0x90, 0x9E, 0xB5, 
-0xE0, 0xB4, 0x0E, 0x08, 0xF1, 0x58, 0xBF, 0x01, 0x03, 0x12, 0x7B, 0x1C, 0x90, 0x9E, 0xB5, 0xE0, 
-0x64, 0x0C, 0x60, 0x02, 0xE1, 0x53, 0xF1, 0x58, 0xEF, 0x64, 0x01, 0x60, 0x02, 0xE1, 0x53, 0x12, 
-0x60, 0xE0, 0xE1, 0x53, 0x90, 0x9E, 0xB5, 0xE0, 0xB4, 0x0E, 0x08, 0xF1, 0x58, 0xBF, 0x01, 0x03, 
-0x12, 0x7B, 0x1C, 0x90, 0x9E, 0xB5, 0xE0, 0xB4, 0x06, 0x02, 0xF1, 0xBE, 0x90, 0x9E, 0xB5, 0xE0, 
-0xB4, 0x0C, 0x08, 0xF1, 0x58, 0xBF, 0x01, 0x03, 0x12, 0x60, 0xE0, 0x90, 0x9E, 0xB5, 0xE0, 0x64, 
-0x04, 0x70, 0x60, 0x12, 0x68, 0xB1, 0xEF, 0x64, 0x01, 0x70, 0x58, 0x12, 0x69, 0xC7, 0x80, 0x53, 
-0x90, 0x9E, 0xB5, 0xE0, 0xB4, 0x0E, 0x08, 0xF1, 0x58, 0xBF, 0x01, 0x03, 0x12, 0x7B, 0x1C, 0x90, 
-0x9E, 0xB5, 0xE0, 0xB4, 0x06, 0x02, 0xF1, 0xBE, 0x90, 0x9E, 0xB5, 0xE0, 0xB4, 0x0C, 0x08, 0xF1, 
-0x58, 0xBF, 0x01, 0x03, 0x12, 0x60, 0xE0, 0x90, 0x9E, 0xB5, 0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 
-0x6A, 0x9A, 0x90, 0x9E, 0xB5, 0xE0, 0xB4, 0x04, 0x1A, 0x12, 0x7B, 0x44, 0x80, 0x15, 0x90, 0x9E, 
-0xB5, 0xE0, 0xB4, 0x0C, 0x0E, 0x90, 0x9D, 0xB8, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 
-0x02, 0xF1, 0xEC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x68, 0x98, 0xEF, 0x64, 0x01, 0x60, 0x08, 
-0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x80, 0x38, 0x90, 0x9D, 0xB7, 0xE0, 0xFF, 0x13, 0x13, 0x13, 
-0x54, 0x1F, 0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x23, 0xEF, 0xC4, 0x54, 
-0x0F, 0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x14, 0x90, 0x9D, 0xBB, 0xE0, 
-0xD3, 0x94, 0x04, 0x40, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x80, 0x03, 0x7F, 0x01, 0x22, 
-0x90, 0x01, 0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 0x74, 0x15, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 
-0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 0x9D, 
-0xB8, 0xE0, 0x90, 0x06, 0x04, 0x20, 0xE0, 0x0C, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x9D, 0xBC, 0x74, 
-0x04, 0xF0, 0x80, 0x0A, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x9D, 0xBC, 0x74, 0x0C, 0xF0, 0x90, 0x05, 
-0x22, 0xE4, 0xF0, 0x22, 0x12, 0x1F, 0x96, 0x90, 0x9D, 0xC3, 0xF0, 0x22, 0x12, 0x69, 0xE3, 0x90, 
-0x9D, 0xBC, 0x74, 0x08, 0xF0, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x47, 0x4E, 0x90, 
-0x9D, 0xEC, 0xEF, 0xF0, 0x60, 0xF0, 0x11, 0x0A, 0x80, 0xEC, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x90, 0x9D, 0x31, 0xE0, 0xFF, 0x90, 0x9D, 0x30, 0xE0, 0xFE, 0xB5, 0x07, 0x04, 0x7F, 0x01, 
-0x80, 0x02, 0x7F, 0x00, 0xEF, 0x64, 0x01, 0x60, 0x45, 0x90, 0x01, 0xAF, 0xE0, 0x70, 0x3F, 0xEE, 
-0x75, 0xF0, 0x0F, 0xA4, 0xFF, 0xAE, 0xF0, 0x24, 0x9A, 0xF9, 0x74, 0x9C, 0x3E, 0xFA, 0x7B, 0x01, 
-0xC0, 0x02, 0xC0, 0x01, 0x74, 0x9C, 0x2F, 0xF9, 0x74, 0x9C, 0x3E, 0xFA, 0x90, 0x9D, 0xF0, 0x12, 
-0x49, 0x39, 0xD0, 0x01, 0xD0, 0x02, 0x11, 0x73, 0x90, 0x9D, 0x30, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 
-0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x9D, 0x30, 0xF0, 0xD0, 0xD0, 
-0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9D, 0xED, 0x12, 0x49, 0x39, 
-0x90, 0x9E, 0xA9, 0xE0, 0xFF, 0x04, 0xF0, 0x90, 0x00, 0x01, 0xEF, 0x12, 0x1F, 0xEE, 0x7F, 0xAF, 
-0x7E, 0x01, 0x11, 0xE5, 0xEF, 0x60, 0x49, 0x90, 0x9D, 0xED, 0x12, 0x49, 0x30, 0x8B, 0x40, 0x8A, 
-0x41, 0x89, 0x42, 0x75, 0x43, 0x02, 0x7B, 0x01, 0x7A, 0x01, 0x79, 0xA0, 0x12, 0x2B, 0x33, 0x90, 
-0x9D, 0xF0, 0x12, 0x49, 0x30, 0x8B, 0x40, 0x8A, 0x41, 0x89, 0x42, 0x90, 0x9D, 0xED, 0x12, 0x49, 
-0x30, 0x12, 0x1F, 0x96, 0xFF, 0xC4, 0x54, 0x0F, 0xF5, 0x43, 0x7B, 0x01, 0x7A, 0x01, 0x79, 0xA2, 
-0x12, 0x2B, 0x33, 0x90, 0x01, 0xAF, 0x74, 0xFF, 0xF0, 0x90, 0x01, 0xCB, 0xE0, 0x64, 0x80, 0xF0, 
-0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9D, 0xF3, 0xEE, 
-0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x9D, 0xF3, 0xE0, 0xFE, 0xA3, 0xE0, 
-0xF5, 0x82, 0x8E, 0x83, 0xE0, 0x60, 0x2D, 0xC3, 0x90, 0x9D, 0xF6, 0xE0, 0x94, 0xE8, 0x90, 0x9D, 
-0xF5, 0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 
-0x15, 0x90, 0x9D, 0xF5, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x48, 0x9F, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 
-0x32, 0x58, 0x80, 0xC5, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 
-0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 
-0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x3B, 0xF0, 0x74, 0x59, 
-0xA3, 0xF0, 0x53, 0x91, 0xEF, 0x31, 0x8D, 0x74, 0x3B, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x59, 
-0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 
-0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x00, 0x54, 
-0xE0, 0x55, 0x0D, 0xF5, 0x11, 0xA3, 0xE0, 0x55, 0x0E, 0xF5, 0x12, 0xA3, 0xE0, 0x55, 0x0F, 0xF5, 
-0x13, 0xA3, 0xE0, 0x55, 0x10, 0xF5, 0x14, 0xAD, 0x11, 0x7F, 0x54, 0x12, 0x31, 0xE4, 0xAD, 0x12, 
-0x7F, 0x55, 0x12, 0x31, 0xE4, 0xAD, 0x13, 0x7F, 0x56, 0x12, 0x31, 0xE4, 0xAD, 0x14, 0x7F, 0x57, 
-0x02, 0x31, 0xE4, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 
-0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 
-0x90, 0x01, 0xC4, 0x74, 0xC3, 0xF0, 0x74, 0x59, 0xA3, 0xF0, 0x12, 0x68, 0x13, 0xE5, 0x19, 0x30, 
-0xE0, 0x03, 0x12, 0x68, 0x40, 0xE5, 0x19, 0x30, 0xE1, 0x02, 0x51, 0x7B, 0xE5, 0x19, 0x30, 0xE4, 
-0x05, 0x7F, 0x02, 0x12, 0x47, 0x27, 0xE5, 0x1B, 0x30, 0xE0, 0x02, 0x51, 0xBE, 0xE5, 0x1B, 0x30, 
-0xE1, 0x02, 0xB1, 0xDE, 0xE5, 0x1B, 0x30, 0xE2, 0x02, 0xD1, 0x5F, 0xE5, 0x1B, 0x30, 0xE3, 0x03, 
-0x12, 0x69, 0x1D, 0xE5, 0x1B, 0x30, 0xE4, 0x03, 0x12, 0x69, 0x50, 0xE5, 0x1B, 0x30, 0xE5, 0x02, 
-0xF1, 0x3A, 0xE5, 0x1B, 0x30, 0xE6, 0x02, 0xF1, 0x1F, 0xE5, 0x1C, 0x30, 0xE1, 0x02, 0x91, 0x32, 
-0xE5, 0x1C, 0x30, 0xE4, 0x02, 0x91, 0x3B, 0xE5, 0x1C, 0x30, 0xE5, 0x02, 0x71, 0x82, 0xE5, 0x1C, 
-0x30, 0xE6, 0x02, 0x71, 0x4B, 0x74, 0xC3, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x59, 0xA3, 0xF0, 
-0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 
-0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x04, 0x7E, 0xE0, 0xFF, 
-0xA3, 0xE0, 0x04, 0xFE, 0xEE, 0xD3, 0x9F, 0x50, 0x2F, 0xE4, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 
-0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0xE5, 0x82, 0x2D, 0xF5, 0x82, 0xE4, 0x35, 
-0x83, 0xF5, 0x83, 0xE0, 0xFC, 0x74, 0x72, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xAF, 0xF5, 0x83, 0xEC, 
-0xF0, 0x0D, 0xBD, 0x08, 0xD6, 0x0E, 0x80, 0xCC, 0x90, 0x04, 0x7F, 0xEF, 0xF0, 0x22, 0xE4, 0xFF, 
-0x90, 0x9D, 0xBA, 0xE0, 0x70, 0x02, 0x61, 0x4A, 0x90, 0x9D, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x7A, 
-0x90, 0x9D, 0xB9, 0xE0, 0xC4, 0x54, 0x0F, 0x60, 0x24, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 0x1F, 
-0x90, 0x9D, 0xC0, 0xE0, 0x14, 0xF0, 0xE0, 0xFE, 0x60, 0x06, 0x90, 0x9D, 0xC2, 0xE0, 0x60, 0x0F, 
-0xEE, 0x70, 0x06, 0x90, 0x9D, 0xBF, 0xE0, 0xA3, 0xF0, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x01, 0xEF, 
-0x60, 0x48, 0x90, 0x9D, 0xBD, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x9D, 0xC2, 0xE0, 0x60, 0x03, 0xB4, 
-0x01, 0x09, 0xE4, 0xF5, 0x3B, 0x90, 0x9D, 0xC2, 0xE0, 0x80, 0x0D, 0xE4, 0xF5, 0x3B, 0x90, 0x9D, 
-0xC2, 0xE0, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 0x90, 0x9D, 0xC1, 0xE0, 0x2F, 0xF5, 0x3C, 
-0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0x12, 0x2B, 0xF0, 0x90, 0x01, 0x57, 0x74, 0x05, 0xF0, 
-0x90, 0x9D, 0xBC, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x55, 0xF1, 0x22, 0x90, 0x07, 0x1F, 0xE0, 0x54, 
-0x7F, 0xF0, 0x90, 0x07, 0x1C, 0xE0, 0x54, 0x01, 0x90, 0x9D, 0xF9, 0xF0, 0x90, 0x9D, 0xF7, 0xE0, 
-0x54, 0xF0, 0x44, 0x02, 0xF0, 0x54, 0x0F, 0x44, 0x10, 0xF0, 0x7B, 0x01, 0x7A, 0x9D, 0x79, 0xF9, 
-0x90, 0x9D, 0xFD, 0x12, 0x49, 0x39, 0x7A, 0x9D, 0x79, 0xF7, 0x12, 0x67, 0x46, 0x7F, 0x03, 0x02, 
-0x47, 0x27, 0x90, 0x9E, 0x90, 0xE0, 0x04, 0xF0, 0xE4, 0xF5, 0x52, 0x90, 0x9D, 0x36, 0xE0, 0x70, 
-0x02, 0x81, 0x26, 0xE5, 0x52, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFF, 0xE5, 0x52, 0x54, 0x07, 0xFE, 
-0x74, 0x81, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0xE0, 0xFD, 0xAF, 0x06, 0x74, 0x01, 
-0x7E, 0x00, 0xA8, 0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 
-0x5D, 0x60, 0x63, 0x75, 0xF0, 0x10, 0xE5, 0x52, 0x90, 0x81, 0x01, 0x12, 0x49, 0x24, 0xE0, 0x20, 
-0xE7, 0x02, 0x80, 0x10, 0x75, 0xF0, 0x10, 0xE5, 0x52, 0x90, 0x81, 0x02, 0x12, 0x49, 0x24, 0xE0, 
-0xFF, 0x20, 0xE7, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x20, 0xF0, 0x80, 0x39, 0xEF, 0x30, 0xE6, 
-0x2A, 0x90, 0x9E, 0x8D, 0xE0, 0x04, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x52, 0x90, 0x81, 0x00, 0x12, 
-0x49, 0x24, 0xE0, 0xFD, 0x75, 0xF0, 0x09, 0xE5, 0x52, 0x90, 0x94, 0x96, 0x12, 0x49, 0x24, 0xE0, 
-0xF5, 0x6A, 0xE4, 0xFB, 0xAF, 0x52, 0x12, 0x6B, 0xD1, 0x80, 0x0B, 0x90, 0x9E, 0x8E, 0xE0, 0x04, 
-0xF0, 0xAF, 0x52, 0x12, 0x6F, 0x28, 0x05, 0x52, 0xE5, 0x52, 0xC3, 0x94, 0x80, 0x50, 0x02, 0x61, 
-0x8B, 0x22, 0x90, 0x9D, 0xBA, 0xE0, 0x60, 0x02, 0xF1, 0x92, 0x22, 0x90, 0x9E, 0x8F, 0xE0, 0x04, 
-0xF0, 0xE4, 0xFF, 0x8F, 0x52, 0xE4, 0xFC, 0x74, 0xF7, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 
-0x83, 0xE4, 0xF0, 0x75, 0xF0, 0x10, 0xEC, 0x90, 0x81, 0x03, 0x12, 0x49, 0x24, 0xE0, 0xFF, 0x30, 
-0xE7, 0x0F, 0xEC, 0x70, 0x1D, 0xEF, 0x30, 0xE6, 0x19, 0x90, 0x9E, 0x8C, 0xE0, 0x04, 0xF0, 0x80, 
-0x11, 0xAF, 0x04, 0xF1, 0xCE, 0x74, 0xF7, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0x74, 
-0x01, 0xF0, 0x0C, 0xBC, 0x80, 0xC1, 0x7F, 0x0C, 0x7E, 0x00, 0x12, 0x32, 0x58, 0xE4, 0xFC, 0x74, 
-0xF7, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0xE0, 0x70, 0x02, 0xA1, 0xD5, 0x75, 0xF0, 
-0x10, 0xEC, 0x90, 0x81, 0x06, 0x12, 0x49, 0x24, 0xE0, 0xFD, 0x75, 0xF0, 0x10, 0xEC, 0x90, 0x81, 
-0x07, 0x12, 0x49, 0x24, 0xE0, 0xFE, 0xED, 0xFB, 0xEB, 0xFF, 0xEC, 0x25, 0xE0, 0x24, 0x01, 0xF5, 
-0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x10, 0xEC, 0x90, 
-0x81, 0x0A, 0x12, 0x49, 0x24, 0xE0, 0xFD, 0x75, 0xF0, 0x10, 0xEC, 0x90, 0x81, 0x0B, 0x12, 0x49, 
-0x24, 0xE0, 0xFB, 0xFE, 0xED, 0xF5, 0x82, 0xE5, 0x82, 0xFF, 0x75, 0xF0, 0x0A, 0xEC, 0x90, 0x8D, 
-0x01, 0x12, 0x49, 0x24, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x10, 0xEC, 0x90, 0x81, 0x0C, 
-0x12, 0x49, 0x24, 0xE0, 0xFF, 0x75, 0xF0, 0x0A, 0xEC, 0x90, 0x8D, 0x03, 0x12, 0x49, 0x24, 0xE4, 
-0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x10, 0xEC, 0x90, 0x81, 0x0D, 0x12, 0x49, 0x24, 0xE0, 0xFF, 
-0x75, 0xF0, 0x0A, 0xEC, 0x90, 0x8D, 0x05, 0x12, 0x49, 0x24, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 
-0xF0, 0x10, 0xEC, 0x90, 0x81, 0x0E, 0x12, 0x49, 0x24, 0xE0, 0xFF, 0x75, 0xF0, 0x0A, 0xEC, 0x90, 
-0x8D, 0x07, 0x12, 0x49, 0x24, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x10, 0xEC, 0x90, 0x81, 
-0x0F, 0x12, 0x49, 0x24, 0xE0, 0xFF, 0x75, 0xF0, 0x0A, 0xEC, 0x90, 0x8D, 0x09, 0x12, 0x49, 0x24, 
-0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x10, 0xEC, 0x90, 0x81, 0x09, 0x12, 0x49, 0x24, 0xE0, 
-0xFF, 0x74, 0x93, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 0xEF, 0xF0, 0xEC, 0x70, 0x4E, 
-0xEB, 0x30, 0xE7, 0x05, 0x90, 0x9E, 0x8B, 0x80, 0x42, 0xEB, 0x30, 0xE6, 0x05, 0x90, 0x9E, 0x8A, 
-0x80, 0x39, 0xEB, 0x30, 0xE5, 0x05, 0x90, 0x9E, 0x89, 0x80, 0x30, 0xEB, 0x30, 0xE4, 0x05, 0x90, 
-0x9E, 0x88, 0x80, 0x27, 0xEB, 0x30, 0xE3, 0x05, 0x90, 0x9E, 0x87, 0x80, 0x1E, 0xEB, 0x30, 0xE2, 
-0x05, 0x90, 0x9E, 0x86, 0x80, 0x15, 0xEB, 0x30, 0xE1, 0x05, 0x90, 0x9E, 0x85, 0x80, 0x0C, 0xEB, 
-0x30, 0xE0, 0x05, 0x90, 0x9E, 0x84, 0x80, 0x03, 0x90, 0x9E, 0x83, 0xE0, 0x04, 0xF0, 0xAF, 0x04, 
-0xAD, 0x52, 0x12, 0x76, 0x33, 0x0C, 0xEC, 0x64, 0x80, 0x60, 0x02, 0x81, 0x8F, 0x22, 0x90, 0x9D, 
-0xBA, 0xE0, 0x60, 0x45, 0x90, 0x9D, 0xB8, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 
-0x12, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x0B, 0xD1, 0x3D, 0x90, 0x9D, 0xBF, 0xE0, 0x14, 0x90, 
-0x05, 0x73, 0xF0, 0x90, 0x9E, 0xAC, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x48, 0x9F, 0xC3, 0x90, 0x9E, 
-0xAD, 0xE0, 0x94, 0x80, 0x90, 0x9E, 0xAC, 0xE0, 0x64, 0x80, 0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 
-0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0x63, 0x03, 0x12, 0x60, 0x85, 0xE4, 
-0xFF, 0x91, 0x43, 0x12, 0x73, 0x7B, 0x90, 0x9E, 0x91, 0xE0, 0x04, 0xF0, 0x22, 0x7D, 0x02, 0x7F, 
-0x02, 0xD1, 0x47, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x15, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 
-0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 
-0x9D, 0xBC, 0xE0, 0x64, 0x06, 0x60, 0x22, 0xD1, 0x8A, 0x90, 0x9D, 0xB8, 0xE0, 0x13, 0x13, 0x13, 
-0x54, 0x1F, 0x30, 0xE0, 0x14, 0x90, 0x9D, 0xBF, 0xE0, 0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x0A, 0xF1, 
-0x6E, 0xD1, 0x3D, 0x90, 0x9D, 0xC0, 0xE0, 0x14, 0xF0, 0x22, 0x90, 0x9D, 0x36, 0xE0, 0x64, 0x01, 
-0x60, 0x02, 0xE1, 0x1E, 0x90, 0x9D, 0xBA, 0xE0, 0x70, 0x02, 0xE1, 0x1E, 0x90, 0x9D, 0xB9, 0xE0, 
-0xC4, 0x54, 0x0F, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x9D, 0xC0, 0xF0, 0x90, 
-0x06, 0xAA, 0xE0, 0x90, 0x9D, 0xBF, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x9D, 0xBF, 0xE0, 
-0xFE, 0xFF, 0x80, 0x00, 0x90, 0x9D, 0xC0, 0xEF, 0xF0, 0x90, 0x9D, 0xB8, 0xE0, 0x44, 0x04, 0xF0, 
-0xE4, 0x90, 0x9D, 0xC2, 0xF0, 0x90, 0x9D, 0xC4, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x90, 0x01, 
-0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x90, 0x9D, 0xBD, 0xE0, 0x54, 0xFD, 0xF0, 
-0x54, 0xEF, 0xF0, 0x90, 0x9D, 0xB9, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x24, 0xFD, 0x50, 0x02, 0x80, 
-0x03, 0x12, 0x65, 0x6A, 0x90, 0x9D, 0xB8, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x0E, 
-0x90, 0x9D, 0xBF, 0xE0, 0xFF, 0xA3, 0xE0, 0xB5, 0x07, 0x04, 0xF1, 0x6E, 0xD1, 0x43, 0x22, 0x90, 
-0x9D, 0x36, 0xE0, 0xB4, 0x01, 0x13, 0x90, 0x9D, 0xBA, 0xE0, 0x60, 0x0D, 0x90, 0x9D, 0xBD, 0xE0, 
-0x54, 0xFE, 0xF0, 0x54, 0x07, 0x70, 0x02, 0xF1, 0xC4, 0x22, 0x90, 0x9D, 0x36, 0xE0, 0xB4, 0x01, 
-0x15, 0x90, 0x9D, 0xBA, 0xE0, 0x60, 0x0F, 0x90, 0x9D, 0xB9, 0xE0, 0x54, 0x0F, 0x64, 0x02, 0x60, 
-0x02, 0x80, 0x04, 0x12, 0x64, 0x77, 0x22, 0x12, 0x62, 0xD5, 0xBF, 0x01, 0x10, 0x90, 0x9C, 0x96, 
-0xE0, 0xFF, 0xE4, 0xFD, 0x12, 0x62, 0x0A, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x22, 0xEF, 0x14, 
-0x90, 0x05, 0x73, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 0x03, 0x74, 0x1D, 0x2F, 
-0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 
-0xF0, 0x22, 0x90, 0x9D, 0xBA, 0xE0, 0x64, 0x01, 0x70, 0x29, 0x90, 0x9D, 0xB9, 0xE0, 0x54, 0x0F, 
-0x60, 0x15, 0x90, 0x9D, 0xBC, 0xE0, 0x70, 0x04, 0xFF, 0x12, 0x6A, 0x9A, 0x90, 0x9D, 0xBC, 0xE0, 
-0x64, 0x0C, 0x60, 0x0F, 0x02, 0x7B, 0x09, 0x90, 0x9D, 0xBC, 0xE0, 0xC3, 0x94, 0x04, 0x50, 0x03, 
-0x12, 0x55, 0xF1, 0x22, 0x90, 0x9D, 0xBB, 0xE0, 0xFF, 0x7D, 0x01, 0x02, 0x55, 0xF5, 0x75, 0xF0, 
-0x10, 0xEF, 0x90, 0x81, 0x03, 0x12, 0x49, 0x24, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0xC0, 0xE0, 0xC0, 
-0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 
-0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xDD, 0xF0, 
-0x74, 0x5F, 0xA3, 0xF0, 0x53, 0x91, 0xDF, 0x51, 0xA8, 0xE5, 0x21, 0x30, 0xE1, 0x02, 0x11, 0x6A, 
-0xE5, 0x21, 0x30, 0xE2, 0x02, 0x71, 0x37, 0xE5, 0x21, 0x30, 0xE3, 0x02, 0x71, 0x73, 0xE5, 0x22, 
-0x30, 0xE0, 0x02, 0x31, 0x93, 0xE5, 0x24, 0x30, 0xE1, 0x05, 0x7F, 0x03, 0x12, 0x47, 0x27, 0xE5, 
-0x24, 0x30, 0xE4, 0x02, 0x11, 0x73, 0xE5, 0x24, 0x30, 0xE5, 0x02, 0x31, 0x16, 0xE5, 0x24, 0x30, 
-0xE6, 0x02, 0x31, 0xCC, 0x74, 0xDD, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x5F, 0xA3, 0xF0, 0xD0, 
-0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 
-0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x9D, 0xBA, 0xE0, 0x60, 0x02, 
-0xB1, 0x0C, 0x22, 0x71, 0xAF, 0x90, 0x9D, 0xBF, 0xE0, 0x14, 0x90, 0x05, 0x73, 0xF0, 0x7D, 0x02, 
-0x7F, 0x02, 0x12, 0x57, 0xA9, 0x90, 0x9D, 0xCB, 0xE0, 0x30, 0xE0, 0x2D, 0x90, 0x9D, 0x36, 0xE0, 
-0xB4, 0x01, 0x26, 0x90, 0x9E, 0xBA, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x0A, 0x0B, 0x90, 0x9D, 0xCD, 
-0xE0, 0x04, 0xF0, 0xE4, 0x90, 0x9E, 0xBA, 0xF0, 0x90, 0x9D, 0xCD, 0xE0, 0xFF, 0x90, 0x9D, 0xCC, 
-0xE0, 0xB5, 0x07, 0x05, 0xE4, 0xA3, 0xF0, 0x11, 0xBA, 0x22, 0xE4, 0xFF, 0x8F, 0x6F, 0x51, 0xD5, 
-0xBF, 0x01, 0x1A, 0x90, 0x9C, 0x97, 0xE0, 0xFF, 0x7D, 0x01, 0x51, 0x0A, 0xAD, 0x07, 0xAC, 0x06, 
-0xAF, 0x6F, 0x91, 0xC1, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 
-0x90, 0x9D, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x2D, 0x90, 0x9D, 0xB8, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 
-0x05, 0x22, 0x74, 0x6F, 0xF0, 0x7F, 0x01, 0x11, 0xBC, 0xBF, 0x01, 0x0E, 0x90, 0x9D, 0xB7, 0xE0, 
-0x44, 0x80, 0xF0, 0x90, 0x9D, 0xBC, 0x74, 0x0E, 0xF0, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 
-0x90, 0x01, 0xB8, 0x04, 0xF0, 0x22, 0x90, 0x9D, 0xB7, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 
-0x30, 0xE0, 0x27, 0xEF, 0x54, 0xBF, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x9D, 0xB8, 0x30, 0xE0, 
-0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x10, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 
-0xF0, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x12, 0x5F, 0xC4, 0xE4, 0xFF, 0x90, 0x9D, 0xCE, 0xE0, 
-0x30, 0xE0, 0x3F, 0x90, 0x9D, 0xD2, 0xE0, 0xFD, 0x60, 0x38, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 
-0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x04, 0xE0, 0xE0, 0xFB, 
-0xEF, 0x5B, 0x60, 0x06, 0xE4, 0x90, 0x9D, 0xD2, 0xF0, 0x22, 0x90, 0x9D, 0xD0, 0xE0, 0xB5, 0x05, 
-0x09, 0x90, 0x01, 0xC7, 0xE0, 0x44, 0x10, 0xF0, 0x41, 0x73, 0x11, 0xBA, 0x90, 0x9D, 0xD2, 0xE0, 
-0x04, 0xF0, 0x22, 0x91, 0x30, 0x90, 0x9E, 0x77, 0xEF, 0xF0, 0xE0, 0xFC, 0x54, 0x01, 0xFE, 0x90, 
-0x9D, 0xB7, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0xEC, 0x30, 0xE6, 0x20, 0x90, 0x01, 0x00, 0xE0, 0xB4, 
-0xEA, 0x09, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 0x58, 0x80, 0xF0, 0x90, 0x01, 0x2F, 0xE0, 0x30, 
-0xE7, 0x03, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 0x22, 0x90, 0x9D, 0xB7, 0xE0, 
-0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x30, 0xE0, 0x2C, 0xEF, 0x54, 0x7F, 0xF0, 0x90, 0x04, 
-0xE0, 0xE0, 0x90, 0x9D, 0xB8, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x0F, 0xE0, 0x54, 
-0xFD, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x04, 0xF0, 0x90, 0x9D, 0xBA, 
-0xE0, 0x60, 0x03, 0x12, 0x5F, 0xC4, 0x7F, 0x01, 0x21, 0x4C, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x90, 0x9E, 0xAF, 0xED, 0xF0, 0x90, 0x9E, 0xAE, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x51, 0x8A, 
-0x7C, 0x00, 0xAD, 0x07, 0x90, 0x9E, 0xAE, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x9E, 0xAF, 0xE0, 
-0x60, 0x0E, 0x74, 0x0F, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 
-0xAF, 0x05, 0x74, 0x08, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x09, 
-0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 0x74, 0x29, 0x2D, 0xF5, 
-0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 
-0x92, 0xAF, 0x22, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x9C, 0x94, 0xE0, 0x64, 0x02, 
-0x60, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0xE4, 0xFE, 0xEF, 0x25, 0xE0, 0xFD, 
-0xEF, 0xC3, 0x94, 0x80, 0x90, 0xFD, 0x12, 0x50, 0x04, 0xE4, 0xF0, 0x80, 0x03, 0x74, 0x01, 0xF0, 
-0x90, 0xFD, 0x10, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0x90, 0x01, 0x3C, 0xE0, 0x55, 0x1D, 0xF5, 0x21, 
-0xA3, 0xE0, 0x55, 0x1E, 0xF5, 0x22, 0xA3, 0xE0, 0x55, 0x1F, 0xF5, 0x23, 0xA3, 0xE0, 0x55, 0x20, 
-0xF5, 0x24, 0x90, 0x01, 0x3C, 0xE5, 0x21, 0xF0, 0xA3, 0xE5, 0x22, 0xF0, 0xA3, 0xE5, 0x23, 0xF0, 
-0xA3, 0xE5, 0x24, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x04, 0x1D, 0xE0, 
-0x60, 0x1A, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x90, 0x60, 0x07, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x08, 
-0xF0, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE1, 0xE4, 0x7F, 0x00, 0x80, 0x02, 0x7F, 0x01, 0xD0, 0xD0, 
-0x92, 0xAF, 0x22, 0x90, 0x9D, 0xCE, 0xE0, 0x30, 0xE0, 0x2C, 0x90, 0x9D, 0xD1, 0xE0, 0x04, 0xF0, 
-0xE0, 0xFF, 0x90, 0x9D, 0xCF, 0xE0, 0xB5, 0x07, 0x1D, 0x90, 0x06, 0x92, 0xE0, 0x54, 0x1C, 0x70, 
-0x0A, 0x11, 0xBA, 0x90, 0x9D, 0xD2, 0xE0, 0x04, 0xF0, 0x80, 0x06, 0x90, 0x06, 0x92, 0x74, 0x1C, 
-0xF0, 0xE4, 0x90, 0x9D, 0xD1, 0xF0, 0x22, 0x90, 0x9D, 0xBA, 0xE0, 0x60, 0x35, 0x90, 0x06, 0x92, 
-0xE0, 0x30, 0xE0, 0x24, 0xE4, 0xF5, 0x3B, 0x90, 0x9D, 0xC8, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0xF5, 
-0x3C, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x12, 0x2B, 0xF0, 0x90, 0x01, 0x5B, 0x74, 0x05, 
-0xF0, 0x90, 0x06, 0x92, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x9D, 0xB7, 0xE0, 0x54, 0xF7, 0xF0, 0x12, 
-0x5F, 0xC4, 0x22, 0x90, 0x9D, 0xBA, 0xE0, 0x60, 0x35, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x24, 
-0xE4, 0xF5, 0x3B, 0x90, 0x9D, 0xC8, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0xF5, 0x3C, 0xE4, 0xFB, 0xFD, 
-0x7F, 0x5C, 0x7E, 0x01, 0x12, 0x2B, 0xF0, 0x90, 0x01, 0x5F, 0x74, 0x05, 0xF0, 0x90, 0x06, 0x92, 
-0x74, 0x02, 0xF0, 0x22, 0x90, 0x9D, 0xB7, 0xE0, 0x54, 0xEF, 0xF0, 0x12, 0x5F, 0xC4, 0x22, 0x90, 
-0x9D, 0xBA, 0xE0, 0x60, 0x39, 0x90, 0x9D, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x31, 0x90, 0x9D, 0xC0, 
-0xF0, 0x04, 0x60, 0x2A, 0x90, 0x9D, 0xBD, 0xE0, 0x44, 0x10, 0xF0, 0xE4, 0xF5, 0x3B, 0x90, 0x9D, 
-0xC1, 0xE0, 0xF5, 0x3C, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0x12, 0x2B, 0xF0, 0x90, 0x01, 
-0x57, 0x74, 0x05, 0xF0, 0x90, 0x9D, 0xBC, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x55, 0xF1, 0x22, 0xEF, 
-0x60, 0x3D, 0x90, 0x9D, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x35, 0x90, 0x9D, 0xB8, 0xE0, 0x54, 0xFE, 
-0xF0, 0x90, 0x05, 0x22, 0x74, 0x0F, 0xF0, 0x90, 0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 0xE4, 0xFF, 
-0x11, 0xBC, 0xBF, 0x01, 0x0E, 0x90, 0x9D, 0xB7, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x9D, 0xBC, 0x74, 
-0x06, 0xF0, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x22, 
-0xE4, 0x90, 0x9E, 0x78, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0x90, 0x9E, 0x78, 
-0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 0x90, 0x9E, 0x78, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 
-0x90, 0x9E, 0x7A, 0xE0, 0x94, 0x64, 0x90, 0x9E, 0x79, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 
-0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x9E, 0x78, 0xE0, 0xFF, 0x22, 0x90, 0x9E, 0x79, 0xE4, 0x75, 
-0xF0, 0x01, 0x12, 0x48, 0x9F, 0x80, 0xC2, 0x90, 0x01, 0x5F, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 
-0x08, 0xF0, 0xE4, 0xF5, 0x3B, 0x90, 0x9D, 0xC8, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0xF5, 0x3C, 0xE4, 
-0xFB, 0xFD, 0x7F, 0x5C, 0x7E, 0x01, 0x12, 0x2B, 0xF0, 0x90, 0x01, 0x5F, 0x74, 0x05, 0xF0, 0x90, 
-0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x9D, 0xB7, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x9D, 0xBC, 0xE0, 
-0xC3, 0x94, 0x0C, 0x50, 0x0B, 0xE4, 0xFD, 0x7F, 0x0C, 0x12, 0x55, 0xF5, 0xE4, 0xFF, 0x11, 0xBC, 
-0x22, 0x74, 0x09, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0x3F, 0xF0, 0xEF, 
-0x60, 0x1D, 0x74, 0x29, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x10, 0xF0, 
-0x74, 0x09, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0x22, 0x74, 
-0x29, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xEF, 0xF0, 0x74, 0x09, 0x2D, 
-0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0x90, 0x9D, 0xB7, 0xE0, 
-0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x11, 0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x9D, 0xBD, 0xE0, 
-0x54, 0xFD, 0xF0, 0x54, 0x07, 0x70, 0x42, 0x80, 0x3D, 0x90, 0x9D, 0xC2, 0xE0, 0x04, 0xF0, 0x90, 
-0x9D, 0xBD, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0x9D, 0xC2, 0xE0, 0xFF, 0xB4, 0x01, 0x02, 0x80, 0x04, 
-0xEF, 0xB4, 0x02, 0x06, 0x90, 0x05, 0x58, 0xE0, 0x04, 0xF0, 0x90, 0x9D, 0xC6, 0xE0, 0xFF, 0x90, 
-0x9D, 0xC2, 0xE0, 0xD3, 0x9F, 0x40, 0x0F, 0x90, 0x9D, 0x36, 0xE0, 0xB4, 0x01, 0x0B, 0x90, 0x9D, 
-0xB8, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x12, 0x5F, 0xC4, 0x22, 0x90, 0x06, 0xA9, 0xE0, 0x90, 0x9D, 
-0xF7, 0xF0, 0xE0, 0x54, 0xC0, 0x70, 0x0D, 0x90, 0x9D, 0xBD, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 
-0xF0, 0x02, 0x5F, 0xC4, 0x90, 0x9D, 0xF7, 0xE0, 0x30, 0xE6, 0x22, 0x90, 0x9D, 0xBA, 0xE0, 0x64, 
-0x01, 0x70, 0x21, 0x90, 0x9D, 0xBD, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x9D, 0xB9, 0xE0, 0x54, 0x0F, 
-0x64, 0x02, 0x60, 0x05, 0x12, 0x5F, 0x57, 0x80, 0x0B, 0x91, 0x77, 0x80, 0x07, 0x90, 0x9D, 0xBD, 
-0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x9D, 0xF7, 0xE0, 0x90, 0x9D, 0xBD, 0x30, 0xE7, 0x25, 0xE0, 0x44, 
-0x02, 0xF0, 0xE4, 0xF5, 0x3B, 0x90, 0x9D, 0xC7, 0xE0, 0xF5, 0x3C, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 
-0x7E, 0x01, 0x12, 0x2B, 0xF0, 0x90, 0x01, 0x57, 0x74, 0x05, 0xF0, 0x90, 0x9D, 0xB7, 0xE0, 0x44, 
-0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFD, 0x12, 0x1F, 0x96, 
-0xFE, 0xAF, 0x05, 0xED, 0x2E, 0x90, 0x9C, 0x95, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xAF, 0xFF, 
-0xED, 0x2F, 0x90, 0x9C, 0x96, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xAF, 0xFF, 0xED, 0x2F, 0x90, 
-0x9C, 0x97, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xAF, 0xFF, 0xED, 0x2F, 0x90, 0x9C, 0x98, 0xF0, 
-0x90, 0x00, 0x04, 0x12, 0x1F, 0xAF, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x9C, 0x99, 0xF0, 0x22, 
-0x90, 0x9D, 0xE7, 0x12, 0x49, 0x39, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xAF, 0xFF, 0xFE, 0x12, 0x1F, 
-0x96, 0xFD, 0xC3, 0x13, 0x30, 0xE0, 0x12, 0x90, 0x9D, 0xE7, 0x12, 0x49, 0x30, 0x90, 0x00, 0x02, 
-0x12, 0x1F, 0xAF, 0x90, 0x9D, 0xEB, 0xF0, 0x80, 0x05, 0x90, 0x9D, 0xEB, 0xEF, 0xF0, 0x90, 0x9D, 
-0xEA, 0xEE, 0xF0, 0x90, 0x9D, 0xEB, 0xE0, 0xFE, 0x90, 0x9D, 0xEA, 0xE0, 0xFF, 0xD3, 0x9E, 0x50, 
-0x38, 0x90, 0x9D, 0xE7, 0x12, 0x49, 0x30, 0x12, 0x1F, 0x96, 0x54, 0x01, 0xFE, 0x74, 0x36, 0x2F, 
-0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0xEE, 0xF0, 0x74, 0x36, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
-0x9D, 0xF5, 0x83, 0xE0, 0x70, 0x04, 0xD1, 0xB9, 0x80, 0x07, 0x90, 0x9D, 0xEA, 0xE0, 0xFF, 0xD1, 
-0xAA, 0x90, 0x9D, 0xEA, 0xE0, 0x04, 0xF0, 0x80, 0xBA, 0x22, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 
-0x05, 0x12, 0x49, 0x24, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x05, 
-0x12, 0x49, 0x24, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 
-0x1F, 0x96, 0xFF, 0x90, 0x9D, 0xB6, 0xF0, 0xBF, 0x01, 0x12, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xAF, 
-0x64, 0x01, 0x60, 0x17, 0x90, 0x05, 0x22, 0x74, 0x6F, 0xF0, 0x80, 0x0F, 0x90, 0x00, 0x01, 0x12, 
-0x1F, 0xAF, 0x64, 0x01, 0x60, 0x05, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
-0x90, 0x00, 0x02, 0x12, 0x1F, 0xAF, 0xFF, 0x30, 0xE0, 0x26, 0x12, 0x1F, 0x96, 0x90, 0x9D, 0xC6, 
-0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xAF, 0x90, 0x9D, 0xC7, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 
-0xE0, 0x54, 0x01, 0x4F, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xAF, 0x90, 0x9D, 0xC9, 0xF0, 0x22, 
-0x90, 0x9D, 0xC6, 0x74, 0x01, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 0x28, 
-0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9D, 0xFA, 
-0x12, 0x49, 0x39, 0x90, 0x9D, 0x30, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 
-0xEF, 0x14, 0xFF, 0x90, 0x9D, 0x31, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 
-0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x73, 0x90, 0x9D, 0x31, 0xE0, 
-0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x9A, 0xF9, 0x74, 0x9C, 0x35, 0xF0, 0xA8, 0x01, 0xFC, 0x7D, 0x01, 
-0x90, 0x9D, 0xFA, 0x12, 0x49, 0x30, 0x7E, 0x00, 0x7F, 0x02, 0x12, 0x48, 0x79, 0x90, 0x9D, 0x31, 
-0xE0, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x9C, 0xF9, 0x74, 0x9C, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xC0, 
-0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x9D, 0xFD, 0x12, 0x49, 0x30, 0x8B, 0x40, 0x8A, 0x41, 0x89, 
-0x42, 0x90, 0x9D, 0xFA, 0x12, 0x49, 0x30, 0x12, 0x1F, 0x96, 0xFF, 0xC4, 0x54, 0x0F, 0xF5, 0x43, 
-0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x2B, 0x33, 0x90, 0x9D, 0x31, 0xE0, 0x04, 0xF0, 0xE0, 
-0x7F, 0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x9D, 0x31, 0xF0, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0x7F, 0x02, 0x90, 0x9D, 0xCA, 0xE0, 0xFE, 0xEF, 0xC3, 0x9E, 0x50, 0x10, 
-0xEF, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x03, 0x7F, 0x00, 0x22, 0x0F, 0x80, 0xE6, 
-0x7F, 0x01, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x15, 0xF5, 0x19, 0xA3, 0xE0, 0x55, 0x16, 0xF5, 
-0x1A, 0xA3, 0xE0, 0x55, 0x17, 0xF5, 0x1B, 0xA3, 0xE0, 0x55, 0x18, 0xF5, 0x1C, 0x90, 0x01, 0x34, 
-0xE5, 0x19, 0xF0, 0xA3, 0xE5, 0x1A, 0xF0, 0xA3, 0xE5, 0x1B, 0xF0, 0xA3, 0xE5, 0x1C, 0xF0, 0x22, 
-0x90, 0x9D, 0xB9, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x49, 0xEF, 0x54, 
-0x0F, 0x60, 0x3C, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0x11, 0x98, 
-0xEF, 0x64, 0x01, 0x70, 0x32, 0xF5, 0x3B, 0x90, 0x9D, 0xC8, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0xF5, 
-0x3C, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x12, 0x2B, 0xF0, 0x90, 0x01, 0x5B, 0x74, 0x05, 
-0xF0, 0x90, 0x06, 0x92, 0x74, 0x01, 0xF0, 0x90, 0x9D, 0xB7, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x11, 
-0x98, 0xBF, 0x01, 0x03, 0x12, 0x5F, 0xC4, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 
-0x00, 0x22, 0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 
-0x22, 0x11, 0x98, 0xEF, 0x64, 0x01, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x80, 0x54, 
-0x90, 0x9D, 0xBD, 0xE0, 0xFF, 0x54, 0x03, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 
-0x43, 0x90, 0x9D, 0xBB, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 
-0xF0, 0x80, 0x31, 0xEF, 0x30, 0xE2, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x80, 0x25, 0x90, 
-0x9D, 0xBD, 0xE0, 0x30, 0xE4, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 0x16, 0x90, 0x9D, 
-0xB8, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x20, 0xF0, 0x80, 
-0x03, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x9D, 0x36, 
-0xE0, 0x64, 0x01, 0x70, 0x2A, 0x90, 0x9D, 0xBA, 0xE0, 0x60, 0x24, 0x90, 0x01, 0x57, 0xE4, 0xF0, 
-0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0xE4, 0xF5, 0x3B, 0x90, 0x9D, 0xC7, 0xE0, 0xF5, 0x3C, 0xE4, 
-0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0x12, 0x2B, 0xF0, 0x90, 0x01, 0x57, 0x74, 0x05, 0xF0, 0x22, 
-0x90, 0x9D, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x26, 0x90, 0x9D, 0xBA, 0xE0, 0x60, 0x20, 0x90, 0x01, 
-0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x90, 0x9D, 0xB7, 0xE0, 0x54, 0xFB, 0xF0, 
-0x90, 0x9D, 0xBD, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0x07, 0x70, 0x03, 0x12, 0x5F, 0xC4, 0x22, 0xE4, 
-0x90, 0x9E, 0xB0, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 
-0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 0x9E, 0xB1, 0xE0, 
-0x94, 0xE8, 0x90, 0x9E, 0xB0, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 
-0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x32, 0x58, 0x90, 0x9E, 0xB0, 0xE4, 0x75, 
-0xF0, 0x01, 0x12, 0x48, 0x9F, 0x80, 0xBF, 0x90, 0x05, 0x22, 0x74, 0xFF, 0xF0, 0x31, 0x7F, 0x90, 
-0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 0x57, 0xA9, 0x31, 0xE3, 0xE4, 0x90, 0x9D, 
-0xBC, 0xF0, 0x22, 0x31, 0x7F, 0x90, 0x00, 0x02, 0xE0, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x12, 0x31, 
-0xE4, 0x90, 0x00, 0x02, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x12, 0x31, 0xE4, 0x90, 0x00, 0x02, 
-0xE0, 0x54, 0xFE, 0xF0, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x2C, 0xFF, 0xEF, 0x44, 0x40, 0xFF, 0xEC, 
-0x90, 0x9E, 0xA4, 0x12, 0x20, 0xC0, 0x90, 0x9E, 0xA4, 0x12, 0x49, 0x18, 0x90, 0xAD, 0xBC, 0x12, 
-0x20, 0xC0, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x2E, 0x45, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 
-0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0x22, 0x90, 0x00, 0x10, 0xE0, 
-0x44, 0x0C, 0xFD, 0x7F, 0x10, 0x12, 0x31, 0xE4, 0x90, 0x00, 0x72, 0xE0, 0x54, 0xF3, 0xFD, 0x7F, 
-0x72, 0x12, 0x31, 0xE4, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 
-0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x7F, 0xB4, 0x7E, 
-0x08, 0x12, 0x2C, 0xFF, 0xEF, 0x54, 0xBF, 0xFF, 0xEC, 0x90, 0x9E, 0xA0, 0x12, 0x20, 0xC0, 0x90, 
-0x9E, 0xA0, 0x12, 0x49, 0x18, 0x90, 0xAD, 0xBC, 0x12, 0x20, 0xC0, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 
-0x2E, 0x45, 0x90, 0x00, 0x02, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x9E, 0xBB, 0xEF, 0xF0, 0x51, 
-0x3C, 0x90, 0x9E, 0xBB, 0xE0, 0x60, 0x05, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x90, 0x9D, 0xBC, 0x74, 
-0x04, 0xF0, 0x22, 0x51, 0x3C, 0x90, 0x9D, 0xBC, 0x74, 0x0C, 0xF0, 0x22, 0x8F, 0x25, 0xE4, 0x90, 
-0x9E, 0xB2, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 
-0xEF, 0x65, 0x25, 0x60, 0x3E, 0xC3, 0x90, 0x9E, 0xB3, 0xE0, 0x94, 0x88, 0x90, 0x9E, 0xB2, 0xE0, 
-0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x9E, 0xB2, 0xE4, 
-0x75, 0xF0, 0x01, 0x12, 0x48, 0x9F, 0x7F, 0x14, 0x7E, 0x00, 0x12, 0x32, 0x58, 0xD3, 0x90, 0x9E, 
-0xB3, 0xE0, 0x94, 0x32, 0x90, 0x9E, 0xB2, 0xE0, 0x94, 0x00, 0x40, 0xB9, 0x90, 0x01, 0xC6, 0xE0, 
-0x30, 0xE0, 0xB2, 0x22, 0x71, 0x7C, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 0xFD, 0x7F, 0x08, 0x12, 
-0x31, 0xE4, 0xE4, 0xFF, 0x80, 0x96, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x71, 0x4F, 0x71, 
-0x14, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9D, 0xBC, 
-0xE0, 0x70, 0x07, 0x71, 0x84, 0xBF, 0x01, 0x02, 0x71, 0x26, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 
-0x9D, 0xC3, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x31, 0xE4, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 0xFD, 
-0x7F, 0x08, 0x12, 0x31, 0xE4, 0x7F, 0x01, 0x51, 0xBC, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 0xFD, 
-0x7F, 0x90, 0x12, 0x31, 0xE4, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x32, 0x58, 0x90, 0x00, 0x90, 0xE0, 
-0x20, 0xE0, 0xF9, 0x22, 0x90, 0x02, 0x87, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 
-0x80, 0x12, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 
-0x03, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 0xF5, 0x6D, 0x74, 
-0x94, 0x25, 0x6B, 0xF5, 0x82, 0xE4, 0x34, 0x9B, 0xF5, 0x83, 0xE5, 0x6D, 0xF0, 0x75, 0xF0, 0x09, 
-0xE5, 0x6B, 0x90, 0x94, 0x96, 0x12, 0x49, 0x24, 0xE0, 0xF5, 0x6A, 0xE4, 0xFB, 0xAD, 0x6D, 0xAF, 
-0x6B, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xF9, 0xEF, 
-0x54, 0x07, 0xFE, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x01, 0x12, 0x49, 0x24, 0xE0, 0xFC, 0xEB, 
-0x70, 0x1F, 0x74, 0x81, 0x29, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0xE0, 0xFB, 0x74, 0x01, 
-0xA8, 0x06, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5B, 0xF0, 0x53, 0x04, 0x7F, 0x80, 
-0x36, 0x74, 0x81, 0x29, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0xE0, 0xFC, 0x74, 0x01, 0xA8, 
-0x06, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4C, 0xF0, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 
-0x01, 0x12, 0x49, 0x24, 0xE0, 0x54, 0x07, 0xFC, 0xED, 0x90, 0x43, 0x71, 0x93, 0x33, 0x33, 0x33, 
-0x54, 0xF8, 0x42, 0x04, 0x43, 0x04, 0x80, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x00, 0x12, 0x49, 
-0x24, 0xED, 0xF0, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x01, 0x12, 0x49, 0x24, 0xEC, 0xF0, 0x75, 
-0xF0, 0x10, 0xEF, 0x90, 0x81, 0x05, 0x12, 0x49, 0x24, 0xE0, 0x54, 0xFC, 0x45, 0x6A, 0xFE, 0x75, 
-0xF0, 0x10, 0xEF, 0x90, 0x81, 0x05, 0x12, 0x49, 0x24, 0xEE, 0xF0, 0x7D, 0x01, 0x12, 0x76, 0x33, 
-0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 0x6B, 0x90, 0x9E, 
-0x92, 0xE0, 0x04, 0xF0, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x95, 0x12, 0x49, 0x24, 0xE0, 0x90, 
-0x9E, 0x9D, 0xF0, 0x12, 0x49, 0x42, 0x6C, 0xD7, 0x00, 0x6C, 0xD7, 0x01, 0x6C, 0xD7, 0x02, 0x6C, 
-0xD7, 0x03, 0x6C, 0xD7, 0x04, 0x6C, 0xD7, 0x05, 0x6C, 0xD7, 0x06, 0x6C, 0xD7, 0x07, 0x6C, 0xD7, 
-0x08, 0x6D, 0x39, 0x09, 0x6D, 0x3F, 0x0A, 0x6D, 0x45, 0x0B, 0x6D, 0x4B, 0x0C, 0x6D, 0x51, 0x0D, 
-0x6D, 0x57, 0x0E, 0x00, 0x00, 0x6D, 0x5F, 0xE4, 0xF5, 0x6C, 0x75, 0xF0, 0x08, 0xE5, 0x6B, 0x90, 
-0x89, 0x00, 0x12, 0x49, 0x24, 0xE5, 0x82, 0x25, 0x6C, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 
-0xE0, 0xFF, 0x90, 0x9E, 0x9D, 0xE0, 0x75, 0xF0, 0x07, 0xA4, 0x24, 0x50, 0xF5, 0x82, 0xE4, 0x34, 
-0x40, 0xF5, 0x83, 0xE5, 0x82, 0x25, 0x6C, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xE4, 0x93, 
-0xFE, 0xEF, 0x5E, 0xFF, 0x90, 0x9E, 0x9F, 0xF0, 0x75, 0xF0, 0x08, 0xE5, 0x6B, 0x90, 0x89, 0x00, 
-0x12, 0x49, 0x24, 0xE5, 0x82, 0x25, 0x6C, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xEF, 0xF0, 
-0x05, 0x6C, 0xE5, 0x6C, 0xB4, 0x07, 0xA3, 0x80, 0x26, 0xAD, 0x6B, 0x7F, 0x44, 0x80, 0x1C, 0xAD, 
-0x6B, 0x7F, 0x4C, 0x80, 0x16, 0xAD, 0x6B, 0x7F, 0x8C, 0x80, 0x10, 0xAD, 0x6B, 0x7F, 0x94, 0x80, 
-0x0A, 0xAD, 0x6B, 0x7F, 0x9C, 0x80, 0x04, 0xAD, 0x6B, 0x7F, 0xA4, 0x7E, 0x04, 0xF1, 0xB4, 0x75, 
-0xF0, 0x09, 0xE5, 0x6B, 0x90, 0x94, 0x99, 0x12, 0x49, 0x24, 0xE0, 0xFD, 0xE4, 0x90, 0x9E, 0x9B, 
-0xF0, 0x7C, 0x06, 0x75, 0xF0, 0x08, 0xE5, 0x6B, 0x90, 0x89, 0x00, 0xBC, 0x06, 0x12, 0x12, 0x49, 
-0x24, 0xE5, 0x82, 0x2C, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x80, 0x0E, 
-0x12, 0x49, 0x24, 0xE5, 0x82, 0x2C, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xE0, 0x90, 0x9E, 
-0x9E, 0xF0, 0x90, 0x9E, 0x9E, 0xE0, 0x60, 0x64, 0x75, 0x6C, 0x07, 0x74, 0x01, 0x7E, 0x00, 0xA8, 
-0x6C, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x9E, 0x9E, 0xE0, 
-0xFB, 0xEF, 0x5B, 0x60, 0x3E, 0xEC, 0x75, 0xF0, 0x08, 0xA4, 0x25, 0x6C, 0x90, 0x9E, 0x9B, 0xF0, 
-0xBD, 0x01, 0x0C, 0xE0, 0xD3, 0x94, 0x0B, 0x40, 0x06, 0xE0, 0x24, 0x20, 0xF0, 0x80, 0x39, 0xBD, 
-0x02, 0x0F, 0x90, 0x9E, 0x9B, 0xE0, 0xD3, 0x94, 0x1B, 0x40, 0x06, 0xE0, 0x24, 0x18, 0xF0, 0x80, 
-0x27, 0xBD, 0x03, 0x24, 0x90, 0x9E, 0x9B, 0xE0, 0xD3, 0x94, 0x1B, 0x40, 0x1B, 0xE0, 0x24, 0x22, 
-0xF0, 0x80, 0x15, 0x15, 0x6C, 0xE5, 0x6C, 0xC3, 0x94, 0x00, 0x50, 0x9F, 0xEC, 0x60, 0x09, 0x1C, 
-0xEC, 0xC3, 0x94, 0x00, 0x40, 0x02, 0xA1, 0x73, 0xE4, 0x90, 0x9E, 0x9C, 0xF0, 0xFC, 0x75, 0xF0, 
-0x08, 0xE5, 0x6B, 0x90, 0x89, 0x00, 0xBC, 0x06, 0x12, 0x12, 0x49, 0x24, 0xE5, 0x82, 0x2C, 0xF5, 
-0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x80, 0x0E, 0x12, 0x49, 0x24, 0xE5, 0x82, 
-0x2C, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xE0, 0x90, 0x9E, 0x9E, 0xF0, 0x90, 0x9E, 0x9E, 
-0xE0, 0x60, 0x63, 0xE4, 0xF5, 0x6C, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x6C, 0x08, 0x80, 0x05, 0xC3, 
-0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x9E, 0x9E, 0xE0, 0xFB, 0xEF, 0x5B, 0x60, 0x3E, 
-0xEC, 0x75, 0xF0, 0x08, 0xA4, 0x25, 0x6C, 0x90, 0x9E, 0x9C, 0xF0, 0xBD, 0x01, 0x0C, 0xE0, 0xD3, 
-0x94, 0x0B, 0x40, 0x06, 0xE0, 0x24, 0x20, 0xF0, 0x80, 0x34, 0xBD, 0x02, 0x0F, 0x90, 0x9E, 0x9C, 
-0xE0, 0xD3, 0x94, 0x1B, 0x40, 0x06, 0xE0, 0x24, 0x18, 0xF0, 0x80, 0x22, 0xBD, 0x03, 0x1F, 0x90, 
-0x9E, 0x9C, 0xE0, 0xD3, 0x94, 0x1B, 0x40, 0x16, 0xE0, 0x24, 0x22, 0xF0, 0x80, 0x10, 0x05, 0x6C, 
-0xE5, 0x6C, 0x64, 0x08, 0x70, 0xA0, 0x0C, 0xEC, 0x64, 0x07, 0x60, 0x02, 0xC1, 0x1E, 0x90, 0x9E, 
-0x9B, 0xE0, 0xFF, 0x75, 0xF0, 0x09, 0xE5, 0x6B, 0x90, 0x94, 0x93, 0x12, 0x49, 0x24, 0xEF, 0xF0, 
-0x90, 0x9E, 0x9C, 0xE0, 0xFE, 0x75, 0xF0, 0x09, 0xE5, 0x6B, 0x90, 0x94, 0x94, 0x12, 0x49, 0x24, 
-0xEE, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x6B, 0x90, 0x81, 0x00, 0x12, 0x49, 0x24, 0xE0, 0xFE, 0x54, 
-0x7F, 0xF5, 0x6D, 0xEE, 0x54, 0x80, 0xF5, 0x6E, 0xE5, 0x6D, 0xD3, 0x9F, 0x40, 0x08, 0x90, 0x9E, 
-0x9B, 0xE0, 0x45, 0x6E, 0x71, 0xAD, 0x90, 0x9E, 0x9C, 0xE0, 0xFF, 0xE5, 0x6D, 0xC3, 0x9F, 0x50, 
-0x05, 0xE5, 0x6E, 0x4F, 0x71, 0xAD, 0x75, 0xF0, 0x10, 0xE5, 0x6B, 0x90, 0x81, 0x03, 0x12, 0x49, 
-0x24, 0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x8F, 0x53, 0x90, 0x01, 0xC4, 0x74, 0x28, 0xF0, 
-0x74, 0x6F, 0xA3, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x53, 0x90, 0x81, 0x05, 0x12, 0x49, 0x24, 0xE0, 
-0x54, 0x03, 0xFD, 0x75, 0xF0, 0x09, 0xE5, 0x53, 0x90, 0x94, 0x93, 0x12, 0x49, 0x24, 0xE0, 0xFF, 
-0x74, 0x14, 0x25, 0x53, 0xF5, 0x82, 0xE4, 0x34, 0x9C, 0xF5, 0x83, 0xE0, 0x54, 0x7F, 0xF5, 0x54, 
-0xD3, 0x9F, 0x40, 0x02, 0x8F, 0x54, 0xE5, 0x54, 0x25, 0xE0, 0x24, 0xBD, 0xF5, 0x82, 0xE4, 0x34, 
-0x42, 0xF5, 0x83, 0xE4, 0x93, 0xFE, 0x74, 0x01, 0x93, 0xFF, 0xE5, 0x54, 0x25, 0xE0, 0x24, 0x15, 
-0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0x74, 0x01, 0x93, 0x2F, 0xFF, 0xE4, 0x93, 0x3E, 0xC3, 
-0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x53, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x93, 
-0xF5, 0x83, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x8D, 0x6A, 0xE4, 0xFB, 0xAD, 0x54, 0xAF, 0x53, 0x71, 
-0xD1, 0xAF, 0x54, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8E, 0x5D, 0x8F, 0x5E, 0x7F, 
-0x08, 0x78, 0x5F, 0xE4, 0xF6, 0x08, 0xDF, 0xFC, 0x75, 0xF0, 0x09, 0xED, 0x90, 0x94, 0x99, 0x12, 
-0x49, 0x24, 0xE0, 0x90, 0x9E, 0xB6, 0xF0, 0x64, 0x01, 0x70, 0x43, 0x75, 0xF0, 0x08, 0xED, 0x90, 
-0x89, 0x00, 0x12, 0x49, 0x24, 0xE0, 0xF5, 0x5F, 0x75, 0xF0, 0x08, 0xED, 0x90, 0x89, 0x01, 0x12, 
-0x49, 0x24, 0xE0, 0xFE, 0x54, 0x0F, 0xF5, 0x60, 0xE4, 0xF5, 0x61, 0xF5, 0x62, 0xF5, 0x63, 0xEE, 
-0x54, 0xF0, 0xF5, 0x64, 0x75, 0xF0, 0x08, 0xED, 0x90, 0x89, 0x02, 0x12, 0x49, 0x24, 0xE0, 0xF5, 
-0x65, 0x75, 0xF0, 0x08, 0xED, 0x90, 0x89, 0x03, 0x12, 0x49, 0x24, 0xE0, 0xF5, 0x66, 0x90, 0x9E, 
-0xB6, 0xE0, 0xFE, 0xC3, 0x94, 0x02, 0x40, 0x4A, 0x75, 0xF0, 0x08, 0xED, 0x90, 0x89, 0x00, 0x12, 
-0x49, 0x24, 0xE0, 0xF5, 0x5F, 0x75, 0xF0, 0x08, 0xED, 0x90, 0x89, 0x01, 0x12, 0x49, 0x24, 0xE0, 
-0xF5, 0x60, 0x75, 0xF0, 0x08, 0xED, 0x90, 0x89, 0x02, 0x12, 0x49, 0x24, 0xE0, 0xF5, 0x61, 0x75, 
-0xF0, 0x08, 0xED, 0x90, 0x89, 0x03, 0x12, 0x49, 0x24, 0xE0, 0xFC, 0x54, 0x0F, 0xF5, 0x62, 0xEC, 
-0x54, 0xF0, 0xF9, 0xEE, 0xB4, 0x03, 0x09, 0xE9, 0x25, 0xE0, 0x25, 0xE0, 0xF5, 0x66, 0x80, 0x02, 
-0x89, 0x65, 0xE4, 0xFF, 0x74, 0x5F, 0x2F, 0xF8, 0xE6, 0xFE, 0xEF, 0x7A, 0x00, 0x25, 0x5E, 0xFB, 
-0xEA, 0x35, 0x5D, 0x8B, 0x82, 0xF5, 0x83, 0xE0, 0x5E, 0xF6, 0x0F, 0xBF, 0x08, 0xE6, 0xE5, 0x64, 
-0xC4, 0x54, 0x0F, 0x70, 0x08, 0xE5, 0x65, 0x70, 0x04, 0xE5, 0x66, 0x60, 0x24, 0x90, 0x9E, 0xB6, 
-0xE0, 0xB4, 0x01, 0x1D, 0xE5, 0x60, 0x54, 0x0F, 0xF9, 0xE5, 0x64, 0x54, 0xF0, 0x42, 0x01, 0x89, 
-0x60, 0x85, 0x65, 0x61, 0x85, 0x66, 0x62, 0xE4, 0xF5, 0x63, 0xF5, 0x64, 0xF5, 0x65, 0x75, 0x66, 
-0x80, 0x90, 0x9E, 0xB6, 0xE0, 0xFE, 0xC3, 0x94, 0x02, 0x40, 0x15, 0xEE, 0xB4, 0x02, 0x06, 0xE5, 
-0x65, 0x42, 0x62, 0x80, 0x08, 0xE5, 0x66, 0x13, 0x13, 0x54, 0x3F, 0x42, 0x62, 0x75, 0x66, 0x80, 
-0xE4, 0xFF, 0x74, 0x5F, 0x2F, 0xF8, 0xE6, 0xFE, 0x75, 0xF0, 0x08, 0xED, 0x90, 0x89, 0x00, 0x12, 
-0x49, 0x24, 0xE5, 0x82, 0x2F, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xEE, 0xF0, 0x0F, 0xBF, 
-0x08, 0xE0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x8F, 0x5B, 0x90, 0x01, 0xC4, 0x74, 0x07, 0xF0, 0x74, 
-0x71, 0xA3, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x5B, 0x90, 0x81, 0x00, 0x12, 0x49, 0x24, 0xE0, 0xF5, 
-0x5C, 0x54, 0x7F, 0xFD, 0x75, 0xF0, 0x09, 0xE5, 0x5B, 0x90, 0x94, 0x93, 0x12, 0x49, 0x24, 0xE0, 
-0xFF, 0x90, 0x9D, 0xFF, 0xF0, 0x75, 0xF0, 0x09, 0xE5, 0x5B, 0x90, 0x94, 0x99, 0x12, 0x49, 0x24, 
-0xE0, 0x90, 0x9E, 0x00, 0xF0, 0xED, 0x25, 0xE0, 0x24, 0x15, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 
-0x83, 0xE4, 0x93, 0xFA, 0x74, 0x01, 0x93, 0xFB, 0xE5, 0x5B, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 
-0xE4, 0x34, 0x93, 0xF5, 0x83, 0xEA, 0xF0, 0xA3, 0xEB, 0xF0, 0x75, 0xF0, 0x09, 0xE5, 0x5B, 0x90, 
-0x94, 0x96, 0x12, 0x49, 0x24, 0xE0, 0xF9, 0xED, 0xC3, 0x9F, 0x40, 0x02, 0x41, 0x9C, 0x74, 0x14, 
-0x25, 0x5B, 0xF5, 0x82, 0xE4, 0x34, 0x9C, 0xF5, 0x83, 0xED, 0xF0, 0x90, 0x9E, 0x00, 0xE0, 0xFF, 
-0xB4, 0x01, 0x0C, 0xED, 0xC3, 0x94, 0x2C, 0x40, 0x06, 0x74, 0xE0, 0x2D, 0xFD, 0x80, 0x1E, 0xEF, 
-0xB4, 0x02, 0x0C, 0xED, 0xC3, 0x94, 0x2C, 0x40, 0x06, 0x74, 0xE8, 0x2D, 0xFD, 0x80, 0x0E, 0xEF, 
-0xB4, 0x03, 0x0A, 0xED, 0xC3, 0x94, 0x2C, 0x40, 0x04, 0x74, 0xDE, 0x2D, 0xFD, 0xEF, 0xB4, 0x01, 
-0x0F, 0x90, 0x9D, 0xFF, 0xE0, 0xC3, 0x94, 0x2C, 0x40, 0x06, 0xE0, 0x24, 0xE0, 0xF0, 0x80, 0x2A, 
-0x90, 0x9E, 0x00, 0xE0, 0xB4, 0x02, 0x0F, 0x90, 0x9D, 0xFF, 0xE0, 0xC3, 0x94, 0x2C, 0x40, 0x06, 
-0xE0, 0x24, 0xE8, 0xF0, 0x80, 0x14, 0x90, 0x9E, 0x00, 0xE0, 0xB4, 0x03, 0x0D, 0x90, 0x9D, 0xFF, 
-0xE0, 0xC3, 0x94, 0x2C, 0x40, 0x04, 0xE0, 0x24, 0xDE, 0xF0, 0xED, 0x04, 0xFC, 0x90, 0x9D, 0xFF, 
-0xE0, 0xFF, 0xEC, 0xD3, 0x9F, 0x50, 0x46, 0xEC, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFF, 0x75, 0xF0, 
-0x08, 0xE5, 0x5B, 0x90, 0x89, 0x00, 0x12, 0x49, 0x24, 0xE5, 0x82, 0x2F, 0xF5, 0x82, 0xE4, 0x35, 
-0x83, 0xF5, 0x83, 0xE0, 0xFB, 0x7A, 0x00, 0xEC, 0x54, 0x07, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 
-0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 
-0x5B, 0x4E, 0x60, 0x06, 0xAD, 0x04, 0x8D, 0x5C, 0x80, 0x03, 0x0C, 0x80, 0xB0, 0x90, 0x9E, 0x00, 
-0xE0, 0xFF, 0xB4, 0x01, 0x19, 0xE5, 0x5C, 0xD3, 0x94, 0x0B, 0x40, 0x12, 0xE5, 0x5C, 0x94, 0x34, 
-0x50, 0x0C, 0x74, 0x20, 0x25, 0x5C, 0xF5, 0x5C, 0x74, 0x20, 0x2D, 0xFD, 0x80, 0x61, 0xEF, 0xB4, 
-0x02, 0x13, 0xE5, 0x5C, 0xD3, 0x94, 0x1B, 0x40, 0x0C, 0x74, 0x18, 0x25, 0x5C, 0xF5, 0x5C, 0x74, 
-0x18, 0x2D, 0xFD, 0x80, 0x4A, 0xEF, 0xB4, 0x03, 0x11, 0xE5, 0x5C, 0xD3, 0x94, 0x1B, 0x40, 0x3F, 
-0x74, 0x22, 0x25, 0x5C, 0xF5, 0x5C, 0x74, 0x22, 0x2D, 0xFD, 0x80, 0x33, 0x90, 0x9D, 0xFF, 0xE0, 
-0xFC, 0x6D, 0x70, 0x6C, 0x74, 0x14, 0x25, 0x5B, 0xF5, 0x82, 0xE4, 0x34, 0x9C, 0xF5, 0x83, 0xED, 
-0xF0, 0x75, 0xF0, 0x09, 0xE5, 0x5B, 0x90, 0x94, 0x97, 0x12, 0x49, 0x24, 0xE0, 0xB4, 0x01, 0x0C, 
-0xE5, 0x5C, 0x20, 0xE7, 0x07, 0xED, 0x44, 0x80, 0xF5, 0x5C, 0x80, 0x03, 0xAF, 0x5C, 0x22, 0xED, 
-0x25, 0xE0, 0x24, 0xBD, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0xE4, 0x93, 0xFE, 0x74, 0x01, 
-0x93, 0xFF, 0xED, 0x25, 0xE0, 0x24, 0x15, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0x74, 0x01, 
-0x93, 0x2F, 0xFF, 0xE4, 0x93, 0x3E, 0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x5B, 0x25, 0xE0, 
-0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x80, 0x5D, 
-0xED, 0xD3, 0x9C, 0x40, 0x58, 0x90, 0x9D, 0xFF, 0xE0, 0xFF, 0x74, 0x14, 0x25, 0x5B, 0xF5, 0x82, 
-0xE4, 0x34, 0x9C, 0xF5, 0x83, 0xEF, 0xF0, 0xAD, 0x07, 0x8F, 0x5C, 0xED, 0x25, 0xE0, 0x24, 0xBD, 
-0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0xE4, 0x93, 0xFE, 0x74, 0x01, 0x93, 0xFF, 0xED, 0x25, 
-0xE0, 0x24, 0x15, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0x74, 0x01, 0x93, 0x2F, 0xFF, 0xE4, 
-0x93, 0x3E, 0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x5B, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 
-0xE4, 0x34, 0x93, 0xF5, 0x83, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xAF, 0x5C, 0x22, 0x89, 0x6A, 0x7B, 
-0x01, 0xAD, 0x5C, 0xAF, 0x5B, 0x12, 0x6B, 0xD1, 0xAF, 0x5C, 0x22, 0x90, 0x01, 0xC4, 0x74, 0x7B, 
-0xF0, 0x74, 0x73, 0xA3, 0xF0, 0xE4, 0xF5, 0x52, 0x90, 0x9D, 0x36, 0xE0, 0x70, 0x02, 0xC1, 0x27, 
-0x75, 0xF0, 0x09, 0xE5, 0x52, 0x90, 0x94, 0x98, 0x12, 0x49, 0x24, 0xE0, 0x64, 0x01, 0x60, 0x02, 
-0xC1, 0x27, 0xE5, 0x52, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xE0, 
-0xFE, 0xA3, 0xE0, 0xD3, 0x94, 0x00, 0xEE, 0x94, 0x00, 0x50, 0x02, 0xC1, 0x27, 0xE5, 0x52, 0x75, 
-0xF0, 0x0A, 0xA4, 0x24, 0x01, 0xF9, 0x74, 0x8D, 0x35, 0xF0, 0x75, 0x56, 0x01, 0xF5, 0x57, 0x89, 
-0x58, 0xE5, 0x52, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xE0, 0xFF, 
-0xA3, 0xE0, 0x90, 0x9D, 0xF9, 0xCF, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x93, 0x25, 0x52, 0xF5, 0x82, 
-0xE4, 0x34, 0x99, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x9D, 0xFB, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 
-0xF0, 0x10, 0xE5, 0x52, 0x90, 0x81, 0x00, 0x12, 0x49, 0x24, 0xE0, 0x54, 0x7F, 0x90, 0x9D, 0xF7, 
-0xF0, 0x54, 0x7F, 0xA3, 0xF0, 0x75, 0xF0, 0x09, 0xE5, 0x52, 0x90, 0x94, 0x93, 0x12, 0x49, 0x24, 
-0xE0, 0x90, 0x9D, 0xFE, 0xF0, 0x74, 0x14, 0x25, 0x52, 0xF5, 0x82, 0xE4, 0x34, 0x9B, 0xF5, 0x83, 
-0xE0, 0xC3, 0x94, 0x05, 0x40, 0x02, 0xC1, 0x21, 0x90, 0x9D, 0xFE, 0xE0, 0xFF, 0x90, 0x9D, 0xF8, 
-0xE0, 0x9F, 0x40, 0x13, 0x90, 0x9D, 0xFE, 0xE0, 0x90, 0x9D, 0xF8, 0xF0, 0x90, 0x9D, 0xF7, 0xE0, 
-0x54, 0x80, 0xFE, 0xF0, 0xEF, 0x4E, 0xF0, 0x90, 0x9D, 0xF8, 0xE0, 0xFF, 0x90, 0x41, 0xC1, 0x93, 
-0xFE, 0x74, 0x13, 0x25, 0x52, 0xF5, 0x82, 0xE4, 0x34, 0x9A, 0xF5, 0x83, 0xE0, 0xC3, 0x9E, 0x40, 
-0x06, 0xEF, 0x90, 0x41, 0x19, 0x80, 0x07, 0x90, 0x9D, 0xF8, 0xE0, 0x90, 0x41, 0x6D, 0x93, 0x90, 
-0x9D, 0xFD, 0xF0, 0x90, 0x9D, 0xFD, 0xE0, 0x75, 0xF0, 0x06, 0xA4, 0x24, 0x8F, 0xF9, 0x74, 0x40, 
-0x35, 0xF0, 0x75, 0x53, 0xFF, 0xF5, 0x54, 0x89, 0x55, 0x90, 0x9D, 0xF7, 0xE0, 0x90, 0x43, 0xC5, 
-0x93, 0xFF, 0xD3, 0x90, 0x9D, 0xFC, 0xE0, 0x9F, 0x90, 0x9D, 0xFB, 0xE0, 0x94, 0x00, 0x40, 0x02, 
-0xC1, 0x1B, 0xE5, 0x52, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0xE0, 
-0xF5, 0x59, 0xA3, 0xE0, 0xF5, 0x5A, 0xAB, 0x53, 0xAA, 0x54, 0xA9, 0x55, 0x12, 0x1F, 0x96, 0xFF, 
-0x7E, 0x00, 0xAB, 0x56, 0xAA, 0x57, 0xA9, 0x58, 0x12, 0x48, 0xB5, 0xFD, 0xAC, 0xF0, 0x12, 0x20, 
-0x10, 0xEF, 0x25, 0x5A, 0xF5, 0x5A, 0xEE, 0x35, 0x59, 0xF5, 0x59, 0xAB, 0x53, 0xAA, 0x54, 0xA9, 
-0x55, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xAF, 0xFF, 0x7E, 0x00, 0xAB, 0x56, 0xAA, 0x57, 0xA9, 0x58, 
-0x90, 0x00, 0x02, 0x12, 0x48, 0xE0, 0xFD, 0xAC, 0xF0, 0x12, 0x20, 0x10, 0xEF, 0x25, 0x5A, 0xF5, 
-0x5A, 0xEE, 0x35, 0x59, 0xF5, 0x59, 0xAB, 0x53, 0xAA, 0x54, 0xA9, 0x55, 0x90, 0x00, 0x02, 0x12, 
-0x1F, 0xAF, 0xFF, 0x7E, 0x00, 0xAB, 0x56, 0xAA, 0x57, 0xA9, 0x58, 0x90, 0x00, 0x04, 0x12, 0x48, 
-0xE0, 0xFD, 0xAC, 0xF0, 0x12, 0x20, 0x10, 0xEF, 0x25, 0x5A, 0xF5, 0x5A, 0xEE, 0x35, 0x59, 0xF5, 
-0x59, 0xAB, 0x53, 0xAA, 0x54, 0xA9, 0x55, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xAF, 0xFF, 0x7E, 0x00, 
-0xAB, 0x56, 0xAA, 0x57, 0xA9, 0x58, 0x90, 0x00, 0x06, 0x12, 0x48, 0xE0, 0xFD, 0xAC, 0xF0, 0x12, 
-0x20, 0x10, 0xEF, 0x25, 0x5A, 0xF5, 0x5A, 0xEE, 0x35, 0x59, 0xF5, 0x59, 0xAB, 0x53, 0xAA, 0x54, 
-0xA9, 0x55, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xAF, 0xFF, 0x7E, 0x00, 0xAB, 0x56, 0xAA, 0x57, 0xA9, 
-0x58, 0x90, 0x00, 0x08, 0x12, 0x48, 0xE0, 0xFD, 0xAC, 0xF0, 0x12, 0x20, 0x10, 0xEF, 0x25, 0x5A, 
-0xF5, 0x5A, 0xEE, 0x35, 0x59, 0xF5, 0x59, 0xAB, 0x53, 0xAA, 0x54, 0xA9, 0x55, 0x90, 0x00, 0x05, 
-0x12, 0x1F, 0xAF, 0xFF, 0x7E, 0x00, 0x90, 0x9D, 0xF9, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0x12, 0x20, 
-0x10, 0xD3, 0xE5, 0x5A, 0x9F, 0xE5, 0x59, 0x9E, 0x40, 0x0C, 0xE5, 0x5A, 0x9F, 0xF5, 0x5A, 0xE5, 
-0x59, 0x9E, 0xF5, 0x59, 0x80, 0x05, 0xE4, 0xF5, 0x59, 0xF5, 0x5A, 0xE5, 0x52, 0x25, 0xE0, 0x24, 
-0x91, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0xE5, 0x59, 0xF0, 0xA3, 0xE5, 0x5A, 0xF0, 0x90, 
-0x9D, 0xF7, 0xE0, 0x25, 0xE0, 0x24, 0x15, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0xC3, 0x74, 
-0x01, 0x93, 0x95, 0x5A, 0xE4, 0x93, 0x95, 0x59, 0x50, 0x06, 0xAF, 0x52, 0x31, 0x07, 0x80, 0x21, 
-0x90, 0x9D, 0xF7, 0xE0, 0x25, 0xE0, 0x24, 0xBD, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0xD3, 
-0x74, 0x01, 0x93, 0x95, 0x5A, 0xE4, 0x93, 0x95, 0x59, 0x40, 0x06, 0x7D, 0x01, 0xAF, 0x52, 0xD1, 
-0xC5, 0xE4, 0xFD, 0xAF, 0x52, 0xD1, 0x33, 0x05, 0x52, 0xE5, 0x52, 0xC3, 0x94, 0x80, 0x50, 0x02, 
-0x61, 0x88, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xED, 0x60, 0x62, 0x75, 0xF0, 0x0A, 
-0xEF, 0x90, 0x8D, 0x01, 0x12, 0x49, 0x24, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 
-0x8D, 0x03, 0x12, 0x49, 0x24, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 0x8D, 0x05, 
-0x12, 0x49, 0x24, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 0x8D, 0x07, 0x12, 0x49, 
-0x24, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 0x8D, 0x09, 0x12, 0x49, 0x24, 0xE4, 
-0xF0, 0xA3, 0xF0, 0xEF, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xE4, 
-0xF0, 0xA3, 0xF0, 0x74, 0x93, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 0xE4, 0xF0, 0x75, 
-0xF0, 0x10, 0xEF, 0x90, 0x81, 0x03, 0x12, 0x49, 0x24, 0xE0, 0x54, 0xBF, 0x90, 0x9E, 0xB7, 0xF0, 
-0x44, 0x80, 0xFE, 0xF0, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x03, 0x12, 0x49, 0x24, 0xEE, 0xF0, 
-0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x8F, 0x5B, 0x90, 0x01, 0xC4, 0x74, 0xC5, 0xF0, 0x74, 0x76, 0xA3, 
-0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x5B, 0x90, 0x81, 0x00, 0x12, 0x49, 0x24, 0xE0, 0xF5, 0x5C, 0x54, 
-0x7F, 0xFF, 0x90, 0x9E, 0x01, 0xF0, 0x75, 0xF0, 0x09, 0xE5, 0x5B, 0x90, 0x94, 0x94, 0x12, 0x49, 
-0x24, 0xE0, 0x90, 0x9E, 0x03, 0xF0, 0x75, 0xF0, 0x09, 0xE5, 0x5B, 0x90, 0x94, 0x93, 0x12, 0x49, 
-0x24, 0xE0, 0xFE, 0x90, 0x9E, 0x04, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x5B, 0x90, 0x81, 0x05, 0x12, 
-0x49, 0x24, 0xE0, 0x54, 0x03, 0xFC, 0x75, 0xF0, 0x09, 0xE5, 0x5B, 0x90, 0x94, 0x99, 0x12, 0x49, 
-0x24, 0xE0, 0xFB, 0xEF, 0xD3, 0x9E, 0x40, 0x0A, 0x90, 0x9E, 0x04, 0xE0, 0x90, 0x9E, 0x01, 0xF0, 
-0xF5, 0x5C, 0xED, 0x70, 0x03, 0x02, 0x78, 0xC8, 0x90, 0x9E, 0x02, 0xED, 0xF0, 0xE5, 0x5C, 0x30, 
-0xE7, 0x0A, 0x90, 0x9E, 0x01, 0xE0, 0xF5, 0x5C, 0xA3, 0xE0, 0x14, 0xF0, 0x90, 0x9E, 0x02, 0xE0, 
-0x70, 0x03, 0x02, 0x78, 0xC8, 0x90, 0x9E, 0x01, 0xE0, 0xFF, 0xB4, 0x2C, 0x08, 0xEC, 0x60, 0x05, 
-0x1C, 0xA3, 0xE0, 0x14, 0xF0, 0x90, 0x9E, 0x02, 0xE0, 0x70, 0x03, 0x02, 0x78, 0xC8, 0x90, 0x9E, 
-0x03, 0xE0, 0xFE, 0xEF, 0xD3, 0x9E, 0x50, 0x03, 0x02, 0x78, 0xC2, 0xE4, 0x90, 0x9E, 0x00, 0xF0, 
-0xBB, 0x01, 0x0F, 0xA3, 0xE0, 0xC3, 0x94, 0x2C, 0x40, 0x08, 0xE0, 0x24, 0xE0, 0xF0, 0x74, 0xE0, 
-0x80, 0x26, 0xBB, 0x02, 0x11, 0x90, 0x9E, 0x01, 0xE0, 0xC3, 0x94, 0x2C, 0x40, 0x08, 0xE0, 0x24, 
-0xE8, 0xF0, 0x74, 0xE8, 0x80, 0x12, 0xBB, 0x03, 0x13, 0x90, 0x9E, 0x01, 0xE0, 0xC3, 0x94, 0x2C, 
-0x40, 0x0A, 0xE0, 0x24, 0xDE, 0xF0, 0x74, 0xDE, 0x25, 0x5C, 0xF5, 0x5C, 0xBB, 0x01, 0x0F, 0xEE, 
-0xC3, 0x94, 0x2C, 0x40, 0x09, 0x90, 0x9E, 0x03, 0xE0, 0x24, 0xE0, 0xF0, 0x80, 0x22, 0xBB, 0x02, 
-0x0F, 0x90, 0x9E, 0x03, 0xE0, 0xC3, 0x94, 0x2C, 0x40, 0x06, 0xE0, 0x24, 0xE8, 0xF0, 0x80, 0x10, 
-0xBB, 0x03, 0x0D, 0x90, 0x9E, 0x03, 0xE0, 0xC3, 0x94, 0x2C, 0x40, 0x04, 0xE0, 0x24, 0xDE, 0xF0, 
-0x90, 0x9E, 0x01, 0xE0, 0x14, 0x90, 0x9D, 0xFF, 0xF0, 0x90, 0x9E, 0x03, 0xE0, 0xFF, 0x90, 0x9D, 
-0xFF, 0xE0, 0xF9, 0xC3, 0x9F, 0x40, 0x6A, 0xE9, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFF, 0x75, 0xF0, 
-0x08, 0xE5, 0x5B, 0x90, 0x89, 0x00, 0x12, 0x49, 0x24, 0xE5, 0x82, 0x2F, 0xF5, 0x82, 0xE4, 0x35, 
-0x83, 0xF5, 0x83, 0xE0, 0xF5, 0x82, 0x75, 0x83, 0x00, 0xE9, 0x54, 0x07, 0xFF, 0x74, 0x01, 0x7E, 
-0x00, 0xA8, 0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x55, 
-0x83, 0xFE, 0xEF, 0x55, 0x82, 0x4E, 0x60, 0x29, 0x90, 0x9D, 0xFF, 0xE0, 0xF5, 0x5C, 0xA3, 0xE0, 
-0x04, 0xF0, 0x90, 0x9E, 0x02, 0xE0, 0xFF, 0x90, 0x9E, 0x00, 0xE0, 0x6F, 0x60, 0x13, 0x90, 0x9E, 
-0x03, 0xE0, 0xFF, 0xE5, 0x5C, 0xD3, 0x9F, 0x40, 0x08, 0x90, 0x9D, 0xFF, 0xE0, 0x14, 0xF0, 0x80, 
-0x88, 0xBB, 0x01, 0x1C, 0xE5, 0x5C, 0xD3, 0x94, 0x0B, 0x40, 0x15, 0xE5, 0x5C, 0x94, 0x34, 0x50, 
-0x0F, 0x74, 0x20, 0x25, 0x5C, 0xF5, 0x5C, 0x90, 0x9E, 0x01, 0xE0, 0x24, 0x20, 0xF0, 0x80, 0x38, 
-0xBB, 0x02, 0x16, 0xE5, 0x5C, 0xD3, 0x94, 0x1B, 0x40, 0x0F, 0x74, 0x18, 0x25, 0x5C, 0xF5, 0x5C, 
-0x90, 0x9E, 0x01, 0xE0, 0x24, 0x18, 0xF0, 0x80, 0x1F, 0xBB, 0x03, 0x1C, 0xE5, 0x5C, 0xD3, 0x94, 
-0x1B, 0x40, 0x15, 0x74, 0x22, 0x25, 0x5C, 0xF5, 0x5C, 0x90, 0x9E, 0x01, 0xE0, 0x24, 0x22, 0xF0, 
-0x80, 0x06, 0x90, 0x9E, 0x03, 0xE0, 0xF5, 0x5C, 0xE5, 0x5C, 0x25, 0xE0, 0x24, 0xBD, 0xF5, 0x82, 
-0xE4, 0x34, 0x42, 0xF5, 0x83, 0xE4, 0x93, 0xFE, 0x74, 0x01, 0x93, 0xFF, 0xE5, 0x5C, 0x25, 0xE0, 
-0x24, 0x15, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0x74, 0x01, 0x93, 0x2F, 0xFF, 0xE4, 0x93, 
-0x3E, 0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x5B, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 
-0x34, 0x93, 0xF5, 0x83, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x8C, 0x6A, 0xE4, 0xFB, 0xAD, 0x5C, 0xAF, 
-0x5B, 0x12, 0x6B, 0xD1, 0xAF, 0x5C, 0x22, 0x12, 0x1F, 0x96, 0x54, 0x3F, 0xFF, 0x90, 0x00, 0x01, 
-0x12, 0x1F, 0xAF, 0xFE, 0x54, 0x1F, 0xFD, 0xEE, 0x54, 0x80, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 
-0x90, 0x9D, 0xE7, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xAF, 0xFE, 0x54, 0x03, 0x90, 0x9D, 0xE8, 
-0xF0, 0xEE, 0x54, 0x30, 0xC4, 0x54, 0x0F, 0x90, 0x9D, 0xEA, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 
-0xAF, 0xFE, 0x54, 0x40, 0xFC, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x90, 0x9D, 0xE9, 0xF0, 0xEE, 0x54, 
-0x80, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0xFE, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x95, 0x12, 
-0x49, 0x24, 0xED, 0xF0, 0x90, 0x9D, 0xE8, 0xE0, 0xFD, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x96, 
-0x12, 0x49, 0x24, 0xED, 0xF0, 0x90, 0x9D, 0xE7, 0xE0, 0xFD, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 
-0x97, 0x12, 0x49, 0x24, 0xED, 0xF0, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x98, 0x12, 0x49, 0x24, 
-0x74, 0x01, 0xF0, 0x90, 0x9D, 0xEA, 0xE0, 0xFD, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x99, 0x12, 
-0x49, 0x24, 0xED, 0xF0, 0x90, 0x9D, 0xE9, 0xE0, 0xFD, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x9A, 
-0x12, 0x49, 0x24, 0xED, 0xF0, 0x75, 0xF0, 0x09, 0xEF, 0x90, 0x94, 0x9B, 0x12, 0x49, 0x24, 0xEE, 
-0xF0, 0xE4, 0xFE, 0xEE, 0xF5, 0x82, 0x75, 0x83, 0x00, 0xA3, 0xA3, 0xA3, 0x12, 0x1F, 0xAF, 0xFD, 
-0x75, 0xF0, 0x08, 0xEF, 0x90, 0x89, 0x00, 0x12, 0x49, 0x24, 0xE5, 0x82, 0x2E, 0xF5, 0x82, 0xE4, 
-0x35, 0x83, 0xF5, 0x83, 0xED, 0xF0, 0x0E, 0xEE, 0xB4, 0x04, 0xD8, 0x02, 0x6C, 0x85, 0x12, 0x1F, 
-0x96, 0xF5, 0x51, 0xC3, 0x94, 0x80, 0x50, 0x15, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xAF, 0xFF, 0x74, 
-0x13, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9A, 0xF5, 0x83, 0xEF, 0xF0, 0x22, 0xE5, 0x51, 0xB4, 
-0x80, 0x0A, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xAF, 0x90, 0x94, 0x91, 0xF0, 0x22, 0x74, 0x1D, 0x2F, 
-0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 
-0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE5, 0x30, 0x90, 0x00, 0x8E, 0xE0, 
-0x64, 0x05, 0x70, 0x28, 0xA3, 0xE0, 0x90, 0x9D, 0xD6, 0xF0, 0x90, 0x00, 0x8E, 0xE0, 0xFF, 0x90, 
-0x9D, 0xD6, 0xE0, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x00, 
-0x8F, 0xE0, 0x30, 0xE0, 0x07, 0xE4, 0xFD, 0x7F, 0x8E, 0x12, 0x31, 0xE4, 0x22, 0x12, 0x1F, 0x96, 
-0xFF, 0x54, 0x01, 0xFE, 0x90, 0x9D, 0xCB, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 
-0xE0, 0x0A, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xAF, 0x90, 0x9D, 0xCC, 0xF0, 0x22, 0x12, 0x1F, 0x96, 
-0xFF, 0x54, 0x01, 0xFE, 0x90, 0x9D, 0xCE, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 
-0xE0, 0x14, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xAF, 0x90, 0x9D, 0xCF, 0xF0, 0x90, 0x00, 0x02, 0x12, 
-0x1F, 0xAF, 0x90, 0x9D, 0xD0, 0xF0, 0x22, 0x90, 0x9D, 0xB7, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 
-0x9D, 0xC2, 0xF0, 0x90, 0x9D, 0xBD, 0xF0, 0x22, 0xEF, 0x24, 0xFE, 0x60, 0x0C, 0x04, 0x70, 0x28, 
-0x90, 0x9D, 0xBF, 0x74, 0x01, 0xF0, 0xA3, 0xF0, 0x22, 0xED, 0x70, 0x0A, 0x90, 0x9D, 0xC9, 0xE0, 
-0x90, 0x9D, 0xBF, 0xF0, 0x80, 0x05, 0x90, 0x9D, 0xBF, 0xED, 0xF0, 0x90, 0x9D, 0xBF, 0xE0, 0xA3, 
-0xF0, 0x90, 0x9D, 0xB8, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 
-0x90, 0x05, 0x22, 0xE4, 0xF0, 0x90, 0x9D, 0xBC, 0x74, 0x0C, 0xF0, 0x22, 0x90, 0x9D, 0xB8, 0xE0, 
-0xC3, 0x13, 0x20, 0xE0, 0x08, 0x90, 0x9D, 0xBC, 0x74, 0x0C, 0xF0, 0x80, 0x11, 0x90, 0x06, 0x04, 
-0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x9D, 0xBC, 0x74, 0x04, 0xF0, 0x90, 0x05, 
-0x22, 0xE4, 0xF0, 0x22, 0x90, 0x05, 0x22, 0x74, 0x6F, 0xF0, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 
-0xF0, 0x90, 0x9D, 0xBC, 0x74, 0x06, 0xF0, 0x22, 0x47, 0xF8, 
+0x83, 0xE0, 0x38, 0xF0, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 0xEC, 0x48, 
+0xFC, 0x22, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xA4, 0x25, 
+0x82, 0xF5, 0x82, 0xE5, 0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 
+0xE0, 0xF9, 0x22, 0xEB, 0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 
+0xF8, 0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 
+0x93, 0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 
+0x80, 0xDF, 0xEF, 0x4E, 0x60, 0x12, 0xEF, 0x60, 0x01, 0x0E, 0xED, 0xBB, 0x01, 0x0B, 0x89, 0x82, 
+0x8A, 0x83, 0xF0, 0xA3, 0xDF, 0xFC, 0xDE, 0xFA, 0x22, 0x89, 0xF0, 0x50, 0x07, 0xF7, 0x09, 0xDF, 
+0xFC, 0xA9, 0xF0, 0x22, 0xBB, 0xFE, 0xFC, 0xF3, 0x09, 0xDF, 0xFC, 0xA9, 0xF0, 0x22, 0x02, 0x45, 
+0x7C, 0x02, 0x41, 0xDD, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 
+0xF2, 0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 
+0x33, 0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 
+0xDF, 0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x45, 0xC1, 0xE4, 
+0x7E, 0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 
+0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 
+0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 
+0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 
+0xBE, 0x41, 0x82, 0x67, 0x00, 0x41, 0x82, 0x68, 0x00, 0x41, 0x82, 0x6F, 0x00, 0x41, 0x82, 0x70, 
+0x00, 0x41, 0x82, 0x7B, 0x00, 0x44, 0x82, 0x43, 0x41, 0x4E, 0x59, 0x00, 0x44, 0x82, 0x3F, 0x61, 
+0x6E, 0x79, 0x00, 0x41, 0x82, 0x7C, 0x00, 0x00, 0x60, 0x40, 0x61, 0x40, 0x5A, 0x14, 0xC0, 0xE0, 
+0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 
+0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xEE, 
+0xF0, 0x74, 0x45, 0xA3, 0xF0, 0xD1, 0x5F, 0xE5, 0x3C, 0x30, 0xE7, 0x02, 0xD1, 0x44, 0x74, 0xEE, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x45, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 
+0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 
+0xF0, 0xD0, 0xE0, 0x32, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 0x06, 0x90, 0x00, 0xF2, 0xE0, 0x20, 
+0xE6, 0x0C, 0x90, 0x00, 0x05, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x05, 0x12, 0x32, 0x1E, 0x22, 0x90, 
+0x00, 0x54, 0xE0, 0x55, 0x35, 0xF5, 0x39, 0xA3, 0xE0, 0x55, 0x36, 0xF5, 0x3A, 0xA3, 0xE0, 0x55, 
+0x37, 0xF5, 0x3B, 0xA3, 0xE0, 0x55, 0x38, 0xF5, 0x3C, 0xAD, 0x39, 0x7F, 0x54, 0x12, 0x32, 0x1E, 
+0xAD, 0x3A, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0xAD, 0x3B, 0x7F, 0x56, 0x12, 0x32, 0x1E, 0xAD, 0x3C, 
+0x7F, 0x57, 0x12, 0x32, 0x1E, 0x53, 0x91, 0xEF, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 
+0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 
+0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x99, 0xF0, 0x74, 0x46, 0xA3, 0xF0, 
+0x12, 0x69, 0x77, 0xE5, 0x41, 0x30, 0xE3, 0x02, 0xF1, 0x6A, 0xE5, 0x41, 0x30, 0xE4, 0x02, 0xF1, 
+0x44, 0xE5, 0x43, 0x30, 0xE0, 0x02, 0xF1, 0x76, 0xE5, 0x43, 0x30, 0xE1, 0x03, 0x12, 0x5F, 0x7F, 
+0xE5, 0x43, 0x30, 0xE2, 0x03, 0x12, 0x67, 0x98, 0xE5, 0x43, 0x30, 0xE3, 0x03, 0x12, 0x67, 0xAF, 
+0xE5, 0x43, 0x30, 0xE4, 0x03, 0x12, 0x5E, 0x8C, 0xE5, 0x43, 0x30, 0xE5, 0x03, 0x12, 0x6A, 0x10, 
+0xE5, 0x43, 0x30, 0xE6, 0x03, 0x12, 0x5E, 0x10, 0xE5, 0x43, 0x30, 0xE7, 0x03, 0x12, 0x6A, 0x2C, 
+0xE5, 0x44, 0x30, 0xE0, 0x02, 0xF1, 0x60, 0xE5, 0x44, 0x30, 0xE1, 0x02, 0xF1, 0x57, 0x74, 0x99, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x46, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 
+0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 
+0xF0, 0xD0, 0xE0, 0x32, 0x12, 0x58, 0x82, 0x7F, 0x02, 0x8F, 0x0D, 0x7F, 0x02, 0x71, 0x27, 0x90, 
+0x80, 0x01, 0xE0, 0x45, 0x0D, 0xF0, 0x22, 0x90, 0x81, 0x2B, 0xE0, 0x60, 0x02, 0xF1, 0xA3, 0x22, 
+0xF1, 0xEB, 0xFF, 0xBF, 0x03, 0x03, 0x12, 0x6A, 0x3D, 0x22, 0x90, 0x80, 0xFA, 0xE0, 0x30, 0xE0, 
+0x04, 0x7F, 0x20, 0xF1, 0x49, 0x22, 0x12, 0x66, 0xED, 0x90, 0x80, 0xFA, 0xE0, 0x30, 0xE0, 0x03, 
+0x12, 0x77, 0x3E, 0x90, 0x81, 0x6F, 0xE0, 0x30, 0xE0, 0x18, 0xF1, 0xC6, 0x12, 0x4E, 0x13, 0x90, 
+0x81, 0x6F, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x7D, 0x0C, 0x7F, 0x01, 0x12, 0x4B, 0x11, 0xF1, 
+0xE4, 0xF0, 0x22, 0x90, 0x81, 0x2B, 0xE0, 0x64, 0x01, 0x70, 0x19, 0xF1, 0xF3, 0x60, 0x08, 0x12, 
+0x49, 0x1F, 0xF1, 0xC6, 0x02, 0x5C, 0x75, 0x90, 0x81, 0x2E, 0xE0, 0x70, 0x07, 0x7D, 0x01, 0x7F, 
+0x04, 0x12, 0x49, 0x23, 0x22, 0xF0, 0xE4, 0xFD, 0xFF, 0x02, 0x4B, 0xAB, 0x12, 0x5C, 0x75, 0x90, 
+0x81, 0x2E, 0xE0, 0x64, 0x0C, 0x60, 0x0C, 0x12, 0x49, 0x1F, 0xF1, 0xC6, 0x7D, 0x08, 0xE4, 0xFF, 
+0x12, 0x4C, 0x1A, 0x22, 0x90, 0x81, 0x6F, 0xE0, 0x44, 0x04, 0x22, 0x90, 0x01, 0x02, 0xE0, 0x54, 
+0x03, 0x22, 0xF0, 0x90, 0x81, 0x29, 0xE0, 0x54, 0x0F, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 
+0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 
+0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xFA, 0xF0, 0x74, 0x47, 0xA3, 
+0xF0, 0x12, 0x69, 0xA4, 0xE5, 0x49, 0x30, 0xE1, 0x03, 0x12, 0x64, 0xD6, 0xE5, 0x49, 0x30, 0xE2, 
+0x03, 0x12, 0x5C, 0x5D, 0xE5, 0x49, 0x30, 0xE3, 0x03, 0x12, 0x5E, 0xC7, 0xE5, 0x4A, 0x30, 0xE0, 
+0x03, 0x12, 0x6A, 0x45, 0xE5, 0x4B, 0x30, 0xE5, 0x03, 0x12, 0x53, 0x0B, 0xE5, 0x4C, 0x30, 0xE1, 
+0x05, 0x7F, 0x04, 0x12, 0x47, 0x49, 0xE5, 0x4C, 0x30, 0xE4, 0x02, 0x11, 0x93, 0xE5, 0x4C, 0x30, 
+0xE5, 0x03, 0x12, 0x5D, 0xBE, 0xE5, 0x4C, 0x30, 0xE6, 0x03, 0x12, 0x5C, 0xA1, 0x74, 0xFA, 0x04, 
+0x90, 0x01, 0xC4, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 
+0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 
+0xD0, 0xE0, 0x32, 0xF1, 0x9A, 0x7D, 0x02, 0x7F, 0x02, 0x74, 0x3D, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 
+0xF6, 0x74, 0x30, 0x80, 0x34, 0x90, 0x81, 0x27, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x81, 0x34, 
+0xF0, 0xA3, 0xF0, 0x90, 0x81, 0x2F, 0xF0, 0x90, 0x81, 0x28, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 
+0xF0, 0x7D, 0x01, 0x7F, 0x02, 0x11, 0x99, 0x7D, 0x02, 0x7F, 0x02, 0x11, 0x99, 0x7D, 0x10, 0x7F, 
+0x03, 0x74, 0x45, 0xF1, 0xF1, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 
+0x83, 0xEE, 0xF0, 0x22, 0x90, 0x01, 0x36, 0x74, 0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 
+0xFF, 0x11, 0x99, 0x7D, 0x02, 0x7F, 0x03, 0x11, 0x99, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0x12, 
+0x67, 0x81, 0xE4, 0xFF, 0xB1, 0xB7, 0xBF, 0x01, 0x11, 0x12, 0x65, 0x52, 0xF0, 0x90, 0x81, 0x2E, 
+0xE0, 0x20, 0xE2, 0x0A, 0x7D, 0x01, 0x7F, 0x04, 0x80, 0x09, 0x12, 0x66, 0x28, 0xF0, 0x22, 0xE4, 
+0xFD, 0x7F, 0x0C, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x78, 0xED, 0xF0, 0x90, 
+0x81, 0x27, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x41, 0x6B, 0xEE, 0x12, 
+0x5C, 0x56, 0x30, 0xE0, 0x02, 0x41, 0x6B, 0x90, 0x81, 0x2E, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0x41, 
+0x6B, 0xEF, 0x70, 0x02, 0x21, 0xDF, 0x24, 0xFE, 0x70, 0x02, 0x41, 0x18, 0x24, 0xFE, 0x60, 0x47, 
+0x24, 0xFC, 0x70, 0x02, 0x41, 0x52, 0x24, 0xFC, 0x60, 0x02, 0x41, 0x64, 0xEE, 0xB4, 0x0E, 0x02, 
+0x51, 0xC0, 0x90, 0x81, 0x2E, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0xFD, 0x90, 0x81, 0x2E, 0xE0, 
+0xB4, 0x06, 0x02, 0x51, 0xDC, 0x90, 0x81, 0x2E, 0xE0, 0xB4, 0x04, 0x0D, 0x90, 0x82, 0x78, 0xE0, 
+0xFF, 0x60, 0x04, 0x71, 0xE2, 0x80, 0x02, 0xD1, 0x7C, 0x90, 0x81, 0x2E, 0xE0, 0x64, 0x08, 0x60, 
+0x02, 0x41, 0x64, 0x71, 0xCF, 0x41, 0x64, 0x90, 0x81, 0x2E, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 
+0xFD, 0x90, 0x81, 0x2E, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0xDC, 0x90, 0x81, 0x2E, 0xE0, 0xB4, 0x0E, 
+0x07, 0x51, 0x70, 0xBF, 0x01, 0x02, 0x51, 0xC0, 0x90, 0x81, 0x2E, 0xE0, 0x64, 0x0C, 0x60, 0x02, 
+0x41, 0x64, 0x51, 0x70, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x41, 0x64, 0x71, 0x79, 0x41, 0x64, 0x90, 
+0x81, 0x2E, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 0x70, 0xBF, 0x01, 0x02, 0x51, 0xC0, 0x90, 0x81, 0x2E, 
+0xE0, 0xB4, 0x06, 0x02, 0x51, 0xDC, 0x90, 0x81, 0x2E, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0x70, 0xBF, 
+0x01, 0x02, 0x71, 0x79, 0x90, 0x81, 0x2E, 0xE0, 0x64, 0x04, 0x70, 0x58, 0x12, 0x61, 0xBD, 0xEF, 
+0x64, 0x01, 0x70, 0x50, 0x71, 0xB6, 0x80, 0x4C, 0x90, 0x81, 0x2E, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 
+0x70, 0xBF, 0x01, 0x02, 0x51, 0xC0, 0x90, 0x81, 0x2E, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0xDC, 0x90, 
+0x81, 0x2E, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0x70, 0xBF, 0x01, 0x02, 0x71, 0x79, 0x90, 0x81, 0x2E, 
+0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0xFD, 0x90, 0x81, 0x2E, 0xE0, 0xB4, 0x04, 0x16, 0xF1, 0xDC, 
+0x80, 0x12, 0x90, 0x81, 0x2E, 0xE0, 0xB4, 0x0C, 0x0B, 0x90, 0x81, 0x28, 0x12, 0x65, 0x59, 0x30, 
+0xE0, 0x02, 0x71, 0xD7, 0x90, 0x81, 0x2E, 0x12, 0x77, 0x8C, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x12, 0x62, 0x46, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x12, 0x62, 0x34, 0x80, 0x3A, 0x12, 0x77, 0x99, 
+0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x2C, 0x90, 0x81, 0x2D, 0xE0, 0xD3, 
+0x94, 0x04, 0x40, 0x05, 0x12, 0x61, 0xB6, 0x80, 0x1E, 0x90, 0x81, 0x6F, 0xE0, 0x30, 0xE0, 0x0F, 
+0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x11, 0xF0, 0x80, 0x08, 0x90, 
+0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 
+0x90, 0x81, 0x28, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x04, 0x7D, 0x0C, 0x80, 0x06, 0x12, 0x6D, 0x10, 
+0xF0, 0x7D, 0x04, 0x7F, 0x01, 0x71, 0x11, 0xE4, 0xFD, 0xFF, 0x61, 0xAB, 0x90, 0x81, 0x28, 0xE0, 
+0x90, 0x06, 0x04, 0x20, 0xE0, 0x08, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x04, 0x80, 0x06, 0xE0, 0x54, 
+0x7F, 0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0x71, 0x11, 0xE4, 0xFD, 0xFF, 0x61, 0xAB, 0x90, 0x82, 0x77, 
+0xEF, 0xF0, 0xD1, 0x13, 0x90, 0x82, 0x77, 0xE0, 0x60, 0x03, 0x12, 0x47, 0xC6, 0x7D, 0x04, 0x7F, 
+0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 0x14, 0x60, 0x15, 0x14, 0x60, 
+0x19, 0x24, 0x02, 0x70, 0x1A, 0xED, 0x54, 0x01, 0xFE, 0x90, 0x81, 0x27, 0xE0, 0x54, 0xFE, 0x4E, 
+0xF0, 0x80, 0x0C, 0x90, 0x81, 0x2E, 0xED, 0xF0, 0x80, 0x05, 0x90, 0x81, 0x2D, 0xED, 0xF0, 0x90, 
+0x00, 0x8F, 0xE0, 0x30, 0xE4, 0x2E, 0xEC, 0x14, 0x60, 0x07, 0x14, 0x60, 0x1D, 0x24, 0x02, 0x70, 
+0x23, 0x90, 0x81, 0x27, 0xE0, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0xFF, 0x90, 0x81, 
+0x2E, 0xE0, 0x54, 0x7F, 0x4F, 0xFD, 0x7F, 0x88, 0x80, 0x07, 0x90, 0x81, 0x2D, 0xE0, 0xFD, 0x7F, 
+0x89, 0x12, 0x32, 0x1E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF1, 0xD4, 0x70, 0x28, 0x90, 0x81, 0x28, 
+0xE0, 0x54, 0xFD, 0xF0, 0x7D, 0x2C, 0x7F, 0x6F, 0x71, 0xAB, 0x7D, 0x08, 0x7F, 0x01, 0x91, 0x1A, 
+0xBF, 0x01, 0x0D, 0x90, 0x81, 0x27, 0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x0E, 0x7F, 0x01, 0x61, 0x11, 
+0x12, 0x5D, 0xFB, 0x04, 0xF0, 0x22, 0xD1, 0x13, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 
+0x90, 0x80, 0x05, 0xED, 0xF0, 0x22, 0x7D, 0x2D, 0x12, 0x6B, 0x44, 0x90, 0x01, 0x37, 0x74, 0x02, 
+0xF0, 0xFD, 0x7F, 0x03, 0x11, 0x99, 0x12, 0x64, 0x12, 0xE4, 0xFD, 0x7F, 0x01, 0x61, 0x11, 0x71, 
+0xA6, 0x7D, 0x0C, 0x7F, 0x01, 0x61, 0x11, 0x7D, 0x2F, 0x12, 0x64, 0x0D, 0x7D, 0x08, 0x7F, 0x01, 
+0x61, 0x11, 0xEF, 0x60, 0x34, 0xF1, 0xD4, 0x70, 0x30, 0x90, 0x81, 0x28, 0xE0, 0x54, 0xFE, 0xF0, 
+0x7D, 0x2B, 0x7F, 0x0F, 0x71, 0xAB, 0x90, 0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 0x7D, 0x08, 0xE4, 
+0xFF, 0x91, 0x1A, 0xBF, 0x01, 0x0D, 0x90, 0x81, 0x27, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x06, 0x7F, 
+0x01, 0x61, 0x11, 0x12, 0x5D, 0xFB, 0x74, 0x08, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x82, 0x53, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x80, 0x03, 0xE0, 0x04, 0xF0, 0x90, 
+0x04, 0x1D, 0xE0, 0x60, 0x22, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x82, 0x57, 0xF0, 0x7D, 0x26, 0x12, 
+0x6B, 0x44, 0xEF, 0x64, 0x01, 0x70, 0x02, 0x91, 0x82, 0x90, 0x82, 0x57, 0xE0, 0xFF, 0x7D, 0x27, 
+0x71, 0xAB, 0x12, 0x6C, 0xAC, 0x80, 0x05, 0x12, 0x6C, 0xAC, 0x91, 0x82, 0x12, 0x76, 0x9A, 0x7F, 
+0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xB1, 0xAB, 0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x0A, 0xB1, 0x9E, 
+0x44, 0x10, 0xB1, 0xAA, 0x44, 0x80, 0xF0, 0x22, 0xB1, 0x9E, 0x54, 0xEF, 0xB1, 0xAA, 0x44, 0x40, 
+0xF0, 0x22, 0x90, 0x80, 0x09, 0xE0, 0xFF, 0x90, 0x82, 0x54, 0xE0, 0xFB, 0x7D, 0x01, 0xB1, 0x12, 
+0x90, 0x82, 0x55, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x82, 0x53, 0xE0, 0xFF, 0x91, 
+0x66, 0x90, 0x82, 0x55, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x04, 0x80, 0xE0, 0x54, 0x0F, 0xFD, 
+0xAC, 0x07, 0x12, 0x77, 0xA3, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0x77, 0xA3, 0xE0, 0x54, 0xFB, 0xF0, 
+0xAC, 0x07, 0x74, 0x16, 0x2C, 0xB1, 0x96, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x15, 0x2C, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x0F, 0xF0, 0x90, 0x04, 0x53, 0xE4, 0xF0, 0x90, 0x04, 
+0x52, 0xF0, 0x90, 0x04, 0x51, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0x50, 0x74, 0xFD, 0xF0, 0x74, 0x14, 
+0x2C, 0x12, 0x77, 0xC0, 0xE0, 0x54, 0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 0x12, 0x77, 0xC0, 0xED, 
+0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x65, 0xED, 0xF0, 0xA3, 0xEB, 
+0xF0, 0x90, 0x82, 0x64, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x12, 0x6D, 0x6C, 0x7C, 0x00, 0xAD, 0x07, 
+0x90, 0x82, 0x64, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x82, 0x65, 0xE0, 0x60, 0x0E, 0x74, 0x0F, 
+0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x08, 
+0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x09, 0x2F, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 0xAF, 0x05, 0xB1, 0x93, 0xE0, 0x54, 0x01, 0xFE, 
+0x90, 0x82, 0x66, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0xB1, 0x93, 
+0xEE, 0xF0, 0x74, 0x21, 0x2F, 0xB1, 0xA1, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x74, 0x16, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 0x21, 
+0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x12, 0x77, 0xAE, 0xFF, 0x12, 0x51, 0x52, 0xE0, 0xFD, 
+0x7C, 0x00, 0x12, 0x5D, 0xF2, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 
+0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 0x7F, 0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0xEF, 0x70, 0x32, 0x7D, 
+0x78, 0xF1, 0xEA, 0x7F, 0x03, 0xD1, 0x72, 0x7D, 0xC8, 0x7F, 0x02, 0x11, 0xD1, 0x12, 0x67, 0x8C, 
+0xE4, 0xFF, 0xB1, 0xB7, 0xEF, 0x70, 0x0A, 0xD1, 0x88, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x80, 
+0x06, 0x7D, 0x01, 0x7F, 0x0C, 0x31, 0x23, 0xD1, 0x8C, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 
+0x22, 0x01, 0xE4, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 
+0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 
+0x74, 0x86, 0xF0, 0x12, 0x64, 0x98, 0x54, 0x7F, 0xFC, 0x90, 0x82, 0x5C, 0x12, 0x20, 0xCE, 0x90, 
+0x82, 0x5C, 0x12, 0x63, 0x85, 0x7F, 0x7C, 0x12, 0x64, 0x6D, 0x12, 0x20, 0xDA, 0xCC, 0xC0, 0x00, 
+0xC0, 0x7F, 0x8C, 0x12, 0x64, 0x6D, 0x12, 0x20, 0xDA, 0x00, 0xC0, 0x00, 0x14, 0x12, 0x64, 0xA1, 
+0x12, 0x20, 0xDA, 0x00, 0x03, 0x3E, 0x60, 0xE4, 0xFD, 0xFF, 0x12, 0x64, 0x76, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x74, 0x3D, 0xF1, 0xF1, 0xFE, 0xF6, 0x74, 0x30, 0x01, 0xD9, 0x12, 0x6C, 0xA5, 0x12, 
+0x47, 0xC5, 0x7D, 0x0C, 0x7F, 0x01, 0x61, 0x11, 0xD1, 0x13, 0xD1, 0x7C, 0x90, 0x81, 0x27, 0xE0, 
+0x54, 0xF7, 0xF0, 0x22, 0x8B, 0x1A, 0x8A, 0x1B, 0x89, 0x1C, 0x12, 0x55, 0xFA, 0xFF, 0xF5, 0x1E, 
+0x12, 0x1F, 0xA4, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x12, 0x56, 0x33, 0xF5, 0x1F, 0x80, 0x02, 
+0x8F, 0x1F, 0x85, 0x1E, 0x1D, 0xE5, 0x1D, 0xD3, 0x95, 0x1F, 0x50, 0x24, 0xAB, 0x1A, 0xAA, 0x1B, 
+0xA9, 0x1C, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFD, 0xAF, 0x1D, 0x12, 0x51, 0x15, 0xAF, 0x1D, 0xB1, 
+0xB7, 0xEF, 0xAF, 0x1D, 0x70, 0x04, 0xF1, 0xE9, 0x80, 0x02, 0xF1, 0xE8, 0x05, 0x1D, 0x80, 0xD5, 
+0xE5, 0x1E, 0x70, 0x0E, 0xFF, 0xB1, 0xB7, 0xEF, 0x70, 0x08, 0xD1, 0x88, 0x54, 0xBF, 0xF0, 0x54, 
+0x7F, 0xF0, 0x22, 0x90, 0x81, 0x9F, 0x12, 0x44, 0xE3, 0x90, 0x81, 0x9E, 0xEF, 0xF0, 0x12, 0x44, 
+0xEC, 0x4F, 0x35, 0x00, 0x4F, 0x3A, 0x01, 0x4F, 0x3E, 0x02, 0x4F, 0x43, 0x03, 0x4F, 0x48, 0x04, 
+0x4F, 0x4D, 0x08, 0x4F, 0x52, 0x09, 0x4F, 0x57, 0x0A, 0x4F, 0x5C, 0x12, 0x4F, 0x61, 0x13, 0x4F, 
+0x66, 0x14, 0x4F, 0x6B, 0x20, 0x4F, 0x70, 0x21, 0x4F, 0x75, 0x23, 0x4F, 0x7A, 0x25, 0x4F, 0x7F, 
+0x26, 0x00, 0x00, 0x4F, 0x84, 0xF1, 0x94, 0x02, 0x56, 0x6D, 0xF1, 0x94, 0xC1, 0x94, 0xF1, 0x94, 
+0x02, 0x67, 0xC6, 0xF1, 0x94, 0x02, 0x66, 0xBD, 0xF1, 0x94, 0x02, 0x56, 0x39, 0xF1, 0x94, 0x02, 
+0x54, 0x3B, 0xF1, 0x94, 0x02, 0x56, 0xB4, 0xF1, 0x94, 0x02, 0x56, 0xD7, 0xF1, 0x94, 0x02, 0x68, 
+0x03, 0xF1, 0x94, 0x02, 0x57, 0x30, 0xF1, 0x94, 0x02, 0x68, 0xA8, 0xF1, 0x94, 0x02, 0x55, 0x3B, 
+0xF1, 0x94, 0x02, 0x56, 0xF3, 0xF1, 0x94, 0x02, 0x68, 0xB7, 0xF1, 0x94, 0x02, 0x68, 0xBF, 0xF1, 
+0x94, 0x02, 0x66, 0x2F, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x81, 0x9E, 0xE0, 0x90, 
+0x01, 0xC2, 0xF0, 0x22, 0x90, 0x81, 0x9F, 0x02, 0x44, 0xDA, 0xE4, 0x90, 0x81, 0x88, 0xF0, 0x90, 
+0x81, 0x2B, 0xE0, 0x60, 0x2E, 0xF1, 0xD4, 0x70, 0x2A, 0x12, 0x67, 0x78, 0x90, 0x81, 0x88, 0x74, 
+0x01, 0xF0, 0xE4, 0x90, 0x81, 0x32, 0xF0, 0x04, 0x60, 0x19, 0x12, 0x67, 0x5F, 0xE4, 0xF5, 0x52, 
+0x90, 0x81, 0x33, 0x12, 0x53, 0xCC, 0x90, 0x81, 0x2E, 0xE0, 0x20, 0xE2, 0x06, 0x7D, 0x01, 0x7F, 
+0x04, 0x31, 0x23, 0x22, 0xE4, 0xFF, 0xB1, 0xB7, 0xEF, 0x64, 0x01, 0x22, 0x7D, 0x2E, 0x7F, 0x6F, 
+0x71, 0xAB, 0x7D, 0x02, 0x7F, 0x01, 0x61, 0x11, 0x22, 0x22, 0x7F, 0x02, 0xD1, 0x72, 0x7D, 0x02, 
+0x22, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x20, 0xE7, 0x09, 
+0xE0, 0x7F, 0x01, 0x20, 0xE6, 0x0C, 0x7F, 0x02, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x30, 0xE6, 0x02, 
+0x7F, 0x03, 0x22, 0x12, 0x4F, 0xF9, 0x90, 0x80, 0x06, 0xEF, 0xF0, 0x11, 0x34, 0x90, 0x01, 0x64, 
+0x74, 0x01, 0xF0, 0x90, 0x00, 0x12, 0xE0, 0x54, 0xC7, 0x44, 0x20, 0xFD, 0x7F, 0x12, 0x12, 0x32, 
+0x1E, 0x02, 0x2D, 0xA7, 0x11, 0x64, 0x11, 0xBC, 0x12, 0x69, 0x39, 0x12, 0x69, 0x58, 0xE4, 0xF5, 
+0x35, 0xF5, 0x36, 0xF5, 0x37, 0x75, 0x38, 0x80, 0xAD, 0x35, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xAD, 
+0x36, 0x7F, 0x51, 0x12, 0x32, 0x1E, 0xAD, 0x37, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xAD, 0x38, 0x7F, 
+0x53, 0x02, 0x32, 0x1E, 0x90, 0x01, 0x30, 0xE4, 0x11, 0x94, 0x90, 0x01, 0x38, 0x11, 0x94, 0xFD, 
+0x7F, 0x50, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x51, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x52, 
+0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x53, 0x02, 0x32, 0x1E, 0xE4, 0x90, 0x81, 0xAA, 0xF0, 0x90, 
+0x82, 0x15, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x80, 0xFA, 0xE0, 
+0x54, 0xFE, 0x31, 0xC6, 0x90, 0x80, 0xFA, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0xFB, 0xF0, 0x54, 0xF7, 
+0xF0, 0x54, 0xEF, 0xF0, 0xE4, 0x90, 0x80, 0xFD, 0x11, 0x92, 0x80, 0xD9, 0x90, 0x01, 0x34, 0x74, 
+0xFF, 0x11, 0x94, 0x90, 0x01, 0x3C, 0x11, 0x94, 0xFD, 0x7F, 0x54, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 
+0x7F, 0x55, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x56, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x57, 
+0x02, 0x32, 0x1E, 0x31, 0x12, 0x12, 0x68, 0xC7, 0x12, 0x6B, 0xF7, 0x12, 0x6D, 0x48, 0x31, 0xB3, 
+0x12, 0x6F, 0xBA, 0x11, 0x9C, 0x90, 0x81, 0x7E, 0xE0, 0x54, 0x7F, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 
+0xDF, 0xF0, 0x54, 0xF0, 0xF0, 0xE4, 0x90, 0x81, 0x80, 0xF0, 0x90, 0x81, 0x7E, 0xE0, 0x54, 0xEF, 
+0xF0, 0x22, 0xE4, 0xFD, 0xFF, 0x12, 0x77, 0xAE, 0xFF, 0xED, 0x70, 0x12, 0x31, 0x52, 0xC0, 0x83, 
+0xC0, 0x82, 0x31, 0x4A, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x0F, 0x31, 0x52, 
+0xC0, 0x83, 0xC0, 0x82, 0x31, 0x4A, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 0xD0, 
+0x83, 0xF0, 0x31, 0x5D, 0x90, 0x81, 0x25, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x07, 
+0x08, 0x22, 0x74, 0x1D, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x7D, 0x08, 0xED, 0x14, 0xF9, 0x24, 0x1D, 0x31, 0x55, 0xE0, 0x60, 0x3A, 
+0x7C, 0x08, 0xEC, 0x14, 0x90, 0x82, 0x74, 0xF0, 0x74, 0x1D, 0x29, 0x31, 0x55, 0xE0, 0xFB, 0x7A, 
+0x00, 0x90, 0x82, 0x74, 0x12, 0x5D, 0xF0, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 
+0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 0x5B, 0x4E, 0x60, 0x0F, 0xE9, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x90, 
+0x82, 0x74, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 0x06, 0xDC, 0xC8, 0xDD, 0xBA, 0x7F, 0x00, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x81, 0x72, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0x7F, 0xF0, 0x54, 0xFB, 0xF0, 
+0xA3, 0x74, 0x0A, 0x80, 0x01, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x58, 0xEE, 0xF0, 0xA3, 0x31, 0xC5, 0x90, 0x82, 0x58, 0xE0, 
+0xFE, 0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 0xE0, 0x60, 0x24, 0xC3, 0x90, 0x82, 0x5B, 0xE0, 0x94, 
+0xE8, 0x90, 0x82, 0x5A, 0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 
+0x7F, 0x00, 0x80, 0x0C, 0x90, 0x82, 0x5A, 0x51, 0x62, 0x12, 0x77, 0xB9, 0x80, 0xCE, 0x7F, 0x01, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x81, 0x9A, 0x31, 0xC5, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 
+0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 0x81, 0x9A, 0xE0, 0x6F, 0x60, 0x35, 0xC3, 0x90, 0x81, 0x9C, 
+0xE0, 0x94, 0x88, 0x90, 0x81, 0x9B, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 
+0x10, 0xF0, 0x22, 0x90, 0x81, 0x9B, 0x51, 0x62, 0x12, 0x60, 0xF2, 0xD3, 0x90, 0x81, 0x9C, 0xE0, 
+0x94, 0x32, 0x90, 0x81, 0x9B, 0xE0, 0x94, 0x00, 0x40, 0xC0, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 
+0xB9, 0x22, 0xE4, 0x75, 0xF0, 0x01, 0x02, 0x44, 0x9F, 0xE4, 0x90, 0x81, 0x8A, 0x11, 0x94, 0x90, 
+0x00, 0x9E, 0xE0, 0x90, 0x81, 0x8E, 0xF0, 0x90, 0x00, 0x9F, 0xE0, 0x90, 0x81, 0x8F, 0xF0, 0xE0, 
+0xFD, 0xFE, 0x90, 0x81, 0x8E, 0xE0, 0xFC, 0xFB, 0xEB, 0xFF, 0x90, 0x81, 0x8A, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x90, 0x00, 0x9E, 0xE0, 0xFF, 0xEC, 0xB5, 0x07, 0x09, 0xA3, 0xE0, 0xFF, 0xED, 0xB5, 
+0x07, 0x02, 0x80, 0x12, 0xC3, 0x90, 0x81, 0x8D, 0xE0, 0x94, 0x64, 0x90, 0x81, 0x8C, 0xE0, 0x94, 
+0x00, 0x40, 0x0C, 0x12, 0x6B, 0x3C, 0x90, 0x81, 0x8A, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0x90, 
+0x81, 0x8C, 0x51, 0x62, 0x80, 0xA9, 0x12, 0x6B, 0x8D, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 0xFD, 
+0x7F, 0x08, 0x12, 0x32, 0x1E, 0xE4, 0xFF, 0x51, 0x15, 0x90, 0x81, 0x28, 0xE0, 0x54, 0xEF, 0xF0, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x6B, 0xAA, 0x51, 0xC6, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x90, 0x81, 0x2E, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x0E, 0x12, 0x62, 0x5F, 0xBF, 
+0x01, 0x08, 0x51, 0xE1, 0x90, 0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 0x51, 0x69, 0x90, 0x81, 0x88, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xD1, 0x00, 0x30, 0xE0, 0x15, 0x90, 0x81, 0x89, 0xE0, 0x20, 0xE0, 0x0E, 
+0x12, 0x5F, 0x10, 0x90, 0x02, 0x86, 0xE0, 0x30, 0xE2, 0x04, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0xE4, 
+0x90, 0x82, 0x71, 0xF0, 0xA3, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x23, 0xC3, 0x90, 0x82, 
+0x72, 0xE0, 0x94, 0xD0, 0x90, 0x82, 0x71, 0xE0, 0x94, 0x07, 0x40, 0x0A, 0x90, 0x01, 0xC1, 0xE0, 
+0x44, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x82, 0x71, 0x51, 0x62, 0x12, 0x77, 0xB9, 0x80, 0xD6, 
+0x7F, 0x01, 0x22, 0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0x12, 0x77, 0x2F, 0x90, 0x80, 
+0xF8, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x44, 0x04, 0xD1, 0x00, 0x30, 0xE0, 0x2A, 
+0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x71, 0x2F, 0x90, 0x80, 0xFA, 0xE0, 0xBF, 0x01, 0x05, 0x54, 0xEF, 
+0xF0, 0x80, 0x03, 0x44, 0x10, 0xF0, 0x90, 0x80, 0xFD, 0xE0, 0xFF, 0x60, 0x0D, 0xE4, 0xF5, 0x52, 
+0x8F, 0x53, 0xFB, 0xFD, 0x7F, 0x5C, 0x7E, 0x01, 0x71, 0xD6, 0x90, 0x80, 0xFA, 0xE0, 0x44, 0x01, 
+0xF0, 0x7D, 0x08, 0xE4, 0xFF, 0x12, 0x48, 0x99, 0x90, 0x05, 0x52, 0xE0, 0x54, 0x07, 0x04, 0x90, 
+0x81, 0x05, 0x31, 0xC6, 0x90, 0x04, 0x22, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0xE0, 0xF5, 0x53, 0xE4, 
+0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8E, 0x4E, 0x8F, 
+0x4F, 0xE5, 0x53, 0x91, 0x2B, 0x85, 0x4E, 0x83, 0x85, 0x4F, 0x82, 0xF0, 0xE5, 0x52, 0x91, 0x2B, 
+0xFF, 0xE5, 0x53, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0xA3, 0xF0, 0xEB, 0x91, 0x2B, 0xFF, 0xE5, 
+0x52, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0x91, 0x32, 0xF0, 0xBD, 0x01, 0x0D, 0x85, 0x4F, 0x82, 
+0x8E, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 0x03, 0xF0, 0x80, 0x06, 0x91, 0x32, 0xA3, 0x74, 0x01, 0xF0, 
+0x91, 0x32, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x54, 0x07, 0xC4, 0x33, 0x54, 
+0xE0, 0x22, 0x85, 0x4F, 0x82, 0x85, 0x4E, 0x83, 0xA3, 0xA3, 0x22, 0xF1, 0x2A, 0x12, 0x1F, 0xA4, 
+0xFC, 0x54, 0x02, 0xFE, 0x90, 0x80, 0xFA, 0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xE0, 0xFF, 0xC3, 0x13, 
+0x30, 0xE0, 0x08, 0xB1, 0x35, 0xD1, 0xAE, 0x90, 0x80, 0xFD, 0xF0, 0xEC, 0x30, 0xE0, 0x13, 0x71, 
+0x63, 0x90, 0x80, 0x06, 0xE0, 0x64, 0x01, 0x70, 0x20, 0x90, 0xFE, 0x10, 0xE0, 0x44, 0x04, 0xF0, 
+0x80, 0x17, 0x12, 0x5F, 0x10, 0x90, 0x80, 0xFA, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x0B, 0x90, 0x02, 
+0x86, 0xE0, 0x30, 0xE2, 0x04, 0xE0, 0x54, 0xFB, 0xF0, 0xB1, 0x35, 0xB1, 0xFA, 0x90, 0x80, 0xFB, 
+0xD1, 0x32, 0x90, 0x80, 0xFC, 0xD1, 0x00, 0x30, 0xE0, 0x36, 0xB1, 0x35, 0x12, 0x1F, 0xA4, 0xFE, 
+0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 0xFF, 0x90, 0x80, 0xFA, 0xF0, 0xEE, 0x54, 0x08, 0xFE, 
+0xEF, 0x54, 0xF7, 0x4E, 0xD1, 0xD0, 0x90, 0x80, 0xFE, 0xF0, 0x70, 0x03, 0x74, 0x14, 0xF0, 0xB1, 
+0x35, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0x90, 0x80, 0xFF, 0xB1, 0xF2, 0x90, 0x81, 0x00, 0xF0, 
+0x90, 0x80, 0xFB, 0xE0, 0x54, 0x01, 0x90, 0x81, 0x08, 0xF0, 0x90, 0x80, 0xFB, 0xE0, 0x54, 0x02, 
+0x90, 0x81, 0x09, 0xF0, 0x90, 0x80, 0xFB, 0xE0, 0x54, 0x04, 0x90, 0x81, 0x0A, 0xF0, 0x90, 0x80, 
+0xFB, 0xE0, 0x54, 0x08, 0x90, 0x81, 0x0B, 0xF0, 0x90, 0x80, 0xFB, 0xE0, 0x54, 0x10, 0x90, 0x81, 
+0x0C, 0xF0, 0x90, 0x80, 0xFC, 0xE0, 0x54, 0x01, 0x90, 0x81, 0x0D, 0xF0, 0x90, 0x80, 0xFC, 0xE0, 
+0x54, 0x02, 0x90, 0x81, 0x0E, 0xF0, 0x90, 0x80, 0xFC, 0xE0, 0x54, 0x04, 0x90, 0x81, 0x0F, 0xF0, 
+0x90, 0x80, 0xFC, 0xE0, 0x54, 0x08, 0x90, 0x81, 0x10, 0xF0, 0x90, 0x80, 0xFC, 0xE0, 0x54, 0x10, 
+0x90, 0x81, 0x11, 0xF0, 0x22, 0x90, 0x81, 0xA2, 0x02, 0x44, 0xDA, 0xF1, 0x2A, 0x12, 0x1F, 0xA4, 
+0xFF, 0x54, 0x7F, 0x90, 0x81, 0x2B, 0xF0, 0xEF, 0x12, 0x5C, 0x56, 0xA3, 0xB1, 0xF9, 0xFF, 0x54, 
+0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0x81, 0x29, 0xE0, 0x54, 0xF0, 0x4E, 0xD1, 0xAD, 0x54, 0x01, 
+0x25, 0xE0, 0xFE, 0x90, 0x81, 0x27, 0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 
+0xF0, 0xFF, 0x12, 0x47, 0xF3, 0x4F, 0xD1, 0x32, 0x90, 0x81, 0x2A, 0xB1, 0xF2, 0x30, 0xE0, 0x52, 
+0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x81, 0x3E, 0x50, 0x04, 0xEF, 0xF0, 0x80, 
+0x2A, 0x74, 0x03, 0xF0, 0xB1, 0x35, 0xE9, 0x24, 0x06, 0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x1F, 0xA4, 
+0xFF, 0x74, 0x03, 0x24, 0xFD, 0xFE, 0xEF, 0xC4, 0x54, 0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 0xED, 
+0x2E, 0x54, 0x0F, 0xFE, 0xC4, 0x54, 0xF0, 0x4F, 0x12, 0x1F, 0xEA, 0xB1, 0x35, 0xB1, 0xF3, 0xC4, 
+0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x81, 0x33, 0x50, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x02, 
+0xEF, 0xF0, 0xB1, 0x35, 0xD1, 0xD1, 0xFD, 0x7F, 0x02, 0x12, 0x4B, 0x11, 0xB1, 0x35, 0xD1, 0x09, 
+0x12, 0x5D, 0xFB, 0xF0, 0x90, 0x81, 0x2B, 0x12, 0x77, 0x8C, 0x12, 0x47, 0xF2, 0x90, 0x01, 0xBE, 
+0xF0, 0x22, 0xF0, 0x90, 0x00, 0x06, 0x02, 0x1F, 0xBD, 0xF0, 0x90, 0x00, 0x01, 0x02, 0x1F, 0xBD, 
+0xF0, 0x90, 0x80, 0xFA, 0xE0, 0xFF, 0xC3, 0x13, 0x22, 0x90, 0x81, 0xA5, 0x12, 0x44, 0xE3, 0x12, 
+0x48, 0xA5, 0x90, 0x81, 0x2B, 0xE0, 0xFF, 0x12, 0x4D, 0xDC, 0x90, 0x81, 0x2B, 0xE0, 0x60, 0x11, 
+0x90, 0x81, 0xA5, 0x12, 0x44, 0xDA, 0xB1, 0xFA, 0x54, 0x0F, 0xFF, 0xD1, 0x33, 0xFD, 0x12, 0x6D, 
+0x1B, 0x22, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x1F, 0xBD, 0xF1, 0x2A, 0x12, 0x6F, 0xBA, 0xB1, 0x35, 
+0x12, 0x66, 0xB6, 0xFE, 0x12, 0x5D, 0x42, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x1D, 0xB1, 
+0xFA, 0x90, 0x81, 0x77, 0xD1, 0x32, 0x90, 0x81, 0x78, 0xF0, 0x12, 0x1F, 0xA4, 0x54, 0x04, 0xFF, 
+0x90, 0x81, 0x76, 0xE0, 0x54, 0xFB, 0xD1, 0xAC, 0x90, 0x81, 0x79, 0xF0, 0x22, 0x90, 0x02, 0x09, 
+0xE0, 0xF5, 0x1A, 0x12, 0x1F, 0xA4, 0x25, 0x1A, 0x90, 0x80, 0x07, 0xB1, 0xF9, 0x25, 0x1A, 0x90, 
+0x80, 0x08, 0xD1, 0x32, 0x25, 0x1A, 0x90, 0x80, 0x09, 0xD1, 0xAD, 0x25, 0x1A, 0x90, 0x80, 0x0A, 
+0xD1, 0xD0, 0x25, 0x1A, 0x90, 0x80, 0x0B, 0xF0, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0x25, 0x1A, 
+0x90, 0x80, 0x0C, 0xB1, 0xF2, 0x25, 0x1A, 0x90, 0x80, 0x0D, 0xF0, 0x22, 0x4F, 0xF0, 0x90, 0x00, 
+0x03, 0x02, 0x1F, 0xBD, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x12, 0xB1, 0xF9, 0x90, 0x81, 0x13, 0xD1, 
+0x32, 0x90, 0x81, 0x14, 0xD1, 0xAD, 0x90, 0x81, 0x15, 0xD1, 0xD0, 0x90, 0x81, 0x16, 0xF0, 0x22, 
+0xF0, 0x90, 0x00, 0x04, 0x02, 0x1F, 0xBD, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x17, 0xB1, 0xF9, 0x90, 
+0x81, 0x18, 0xD1, 0x32, 0x90, 0x81, 0x19, 0xD1, 0xAD, 0x90, 0x81, 0x1A, 0xD1, 0xD0, 0x90, 0x81, 
+0x1B, 0xF0, 0x22, 0xD1, 0x33, 0xFF, 0x30, 0xE0, 0x1B, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x68, 0xB1, 
+0xF9, 0x90, 0x81, 0x69, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0xD1, 0xAC, 0x90, 
+0x81, 0x6B, 0xF0, 0x22, 0x90, 0x81, 0x68, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0xA3, 0xE0, 
+0x54, 0x01, 0x44, 0x1E, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x22, 0x90, 0x81, 0xA2, 0x02, 0x44, 0xE3, 
+0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x80, 0xFE, 0x90, 0x81, 0x7E, 0xE0, 0x54, 0x7F, 0x4E, 0xFE, 0xF0, 
+0xEF, 0x54, 0x40, 0xFF, 0xEE, 0x54, 0xBF, 0x12, 0x67, 0x67, 0x54, 0x20, 0xFD, 0xEF, 0x54, 0xDF, 
+0x4D, 0xFF, 0x90, 0x81, 0x7E, 0xF0, 0xEE, 0x54, 0x10, 0xFE, 0xEF, 0x54, 0xEF, 0x4E, 0xFF, 0xF0, 
+0x12, 0x1F, 0xA4, 0x54, 0x0F, 0xFE, 0xEF, 0x54, 0xF0, 0x4E, 0x90, 0x81, 0x7E, 0xB1, 0xF9, 0xFF, 
+0x54, 0x7F, 0x90, 0x81, 0x80, 0xF0, 0xEF, 0x54, 0x80, 0x12, 0x5C, 0x56, 0xFF, 0x90, 0x81, 0x7F, 
+0xE0, 0x54, 0xFE, 0x4F, 0xD1, 0x32, 0x90, 0x81, 0x81, 0xD1, 0xAD, 0x54, 0x01, 0x25, 0xE0, 0xFF, 
+0x90, 0x81, 0x7F, 0xE0, 0x54, 0xFD, 0x4F, 0xF0, 0x12, 0x5B, 0x96, 0x54, 0x03, 0x7D, 0x00, 0x20, 
+0xE0, 0x02, 0x7D, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x6E, 0xED, 0xF0, 
+0x90, 0x82, 0x6D, 0xEF, 0xF0, 0xD3, 0x94, 0x07, 0x50, 0x50, 0x12, 0x58, 0x7A, 0x80, 0x02, 0xC3, 
+0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x47, 0xE0, 0x5F, 0xFD, 0x7F, 0x47, 0x12, 0x58, 0x74, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x46, 0xE0, 0x4F, 0xFD, 0x7F, 0x46, 0x12, 
+0x59, 0xA5, 0x60, 0x11, 0x12, 0x58, 0x77, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 
+0x45, 0xE0, 0x4F, 0x80, 0x10, 0x12, 0x58, 0x77, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 
+0x90, 0x00, 0x45, 0xE0, 0x5F, 0xFD, 0x7F, 0x45, 0x80, 0x62, 0x90, 0x82, 0x6D, 0xE0, 0x24, 0xF8, 
+0xF0, 0xE0, 0x24, 0x04, 0x11, 0x7B, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 
+0x43, 0xE0, 0x5F, 0xFD, 0x7F, 0x43, 0x11, 0x74, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 
+0x00, 0x43, 0xE0, 0x4F, 0xFD, 0x7F, 0x43, 0x31, 0xA5, 0x60, 0x19, 0x90, 0x82, 0x6D, 0xE0, 0x24, 
+0x04, 0x11, 0x7B, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x42, 0xE0, 0x4F, 0xFD, 
+0x7F, 0x42, 0x80, 0x18, 0x90, 0x82, 0x6D, 0xE0, 0x24, 0x04, 0x11, 0x7B, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x42, 0xE0, 0x5F, 0xFD, 0x7F, 0x42, 0x12, 0x32, 0x1E, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x12, 0x32, 0x1E, 0x90, 0x82, 0x6D, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 
+0x08, 0x22, 0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0x82, 0x69, 0xF0, 0x90, 0x82, 0x69, 0xE0, 
+0xFD, 0x70, 0x02, 0x21, 0x7A, 0x90, 0x80, 0x5E, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 
+0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x80, 0x5F, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 
+0x7F, 0x00, 0xEF, 0x60, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x82, 0x67, 
+0xB1, 0xF0, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 
+0x21, 0x5D, 0xE4, 0x90, 0x82, 0x6A, 0xF0, 0x90, 0x82, 0x6A, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 
+0x32, 0x31, 0x7C, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 
+0xD0, 0x31, 0x93, 0x90, 0x80, 0x0E, 0x31, 0x84, 0x31, 0x7B, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 
+0xFE, 0x74, 0xF0, 0x31, 0x93, 0x90, 0x80, 0x12, 0x31, 0x84, 0xF0, 0x90, 0x82, 0x6A, 0xE0, 0x04, 
+0xF0, 0x80, 0xC4, 0x90, 0x82, 0x69, 0xE0, 0xFF, 0x90, 0x82, 0x67, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 
+0x06, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0x82, 0x69, 0xF0, 0x90, 0x82, 
+0x67, 0x11, 0x7A, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x82, 0x67, 
+0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0x80, 0x5F, 0x51, 0x0D, 0xB4, 0x0A, 0x02, 0x7F, 
+0x01, 0xEF, 0x70, 0x02, 0x01, 0x8C, 0xE4, 0x90, 0x80, 0x5F, 0xF0, 0x01, 0x8C, 0x90, 0x01, 0xC0, 
+0xE0, 0x44, 0x02, 0xF0, 0x90, 0x82, 0x67, 0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0x31, 0x7B, 0x90, 
+0x01, 0xD0, 0x12, 0x44, 0xCE, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 0xF0, 0x90, 0x82, 0x67, 0xE0, 
+0x75, 0xF0, 0x04, 0x22, 0x12, 0x44, 0xCE, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 
+0x83, 0xEF, 0x22, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x80, 0x5F, 
+0xE0, 0x75, 0xF0, 0x08, 0x22, 0x12, 0x32, 0x1E, 0x90, 0x82, 0x6E, 0xE0, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x80, 0x5F, 0xE0, 0xFF, 0x90, 0x80, 0x5E, 0xE0, 0xB5, 0x07, 0x04, 
+0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x3F, 0x90, 0x80, 0x5E, 0xE0, 0xFE, 0x75, 0xF0, 
+0x08, 0x90, 0x80, 0x0E, 0x12, 0x44, 0xCE, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x0F, 
+0xF9, 0x74, 0x80, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x12, 0x4E, 0xF3, 0x90, 0x80, 0x5E, 
+0x51, 0x0D, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0x5E, 0xF0, 0x11, 
+0x82, 0x90, 0x80, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE0, 0x04, 0xF0, 
+0xE0, 0x7F, 0x00, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x43, 0x4E, 0x90, 0x81, 0x9D, 
+0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x80, 0x01, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 
+0xAF, 0xEF, 0x30, 0xE1, 0x09, 0x90, 0x80, 0x01, 0xE0, 0x54, 0xFD, 0xF0, 0x31, 0xAD, 0x51, 0x5D, 
+0x30, 0xE2, 0x05, 0x54, 0xFB, 0xF0, 0x51, 0x67, 0x51, 0x5D, 0x30, 0xE5, 0x0C, 0x54, 0xDF, 0xF0, 
+0x12, 0x53, 0x2F, 0xBF, 0x01, 0x03, 0x12, 0x70, 0x08, 0xD2, 0xAF, 0x80, 0xC7, 0xD2, 0xAF, 0xC2, 
+0xAF, 0x90, 0x80, 0x01, 0xE0, 0xFF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 
+0x90, 0x80, 0xF7, 0xE0, 0xFE, 0x90, 0x80, 0xF6, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 0x01, 0x80, 
+0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x44, 0x90, 0x01, 0xAF, 0xE0, 0x70, 0x0D, 0xED, 0x71, 
+0x30, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x12, 0x68, 0xD5, 0x7F, 0x01, 0xEF, 0x60, 0x2E, 0x90, 0x80, 
+0xF6, 0x51, 0x0D, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0xF6, 0xF0, 
+0x90, 0x80, 0xF7, 0xE0, 0xFF, 0x90, 0x80, 0xF6, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 
+0x7F, 0x00, 0xEF, 0x70, 0x07, 0x90, 0x80, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x80, 0xF6, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 
+0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x80, 0xF7, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 
+0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 0xF0, 0x80, 
+0x2A, 0xC0, 0x01, 0x90, 0x80, 0xF7, 0xE0, 0x71, 0x30, 0x35, 0xF0, 0xA8, 0x01, 0xFC, 0x7D, 0x01, 
+0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x44, 0x79, 0x90, 0x80, 0xF7, 0x51, 0x0D, 0xB4, 0x0A, 
+0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0xF7, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x60, 0xF9, 0x74, 0x80, 0x22, 0xE4, 0x90, 0x81, 0x8A, 0xF0, 0x90, 
+0x81, 0x88, 0x74, 0x14, 0xF0, 0x90, 0x81, 0x96, 0x74, 0x01, 0xF0, 0xFB, 0x7A, 0x81, 0x79, 0x88, 
+0x51, 0xD1, 0x7F, 0x04, 0x90, 0x82, 0x73, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x43, 0x27, 0x90, 0x80, 
+0x01, 0xE0, 0xFF, 0x90, 0x82, 0x73, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x80, 0x01, 0xF0, 0x22, 0x90, 
+0x81, 0x7E, 0x91, 0x54, 0x30, 0xE0, 0x1E, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x02, 0x71, 0x3A, 
+0x90, 0x81, 0x7F, 0xE0, 0x30, 0xE0, 0x0E, 0x71, 0x96, 0x54, 0x03, 0x7D, 0x00, 0x20, 0xE0, 0x02, 
+0x7D, 0x01, 0x12, 0x57, 0xA4, 0x22, 0x90, 0x81, 0x7E, 0xE0, 0xFE, 0x54, 0x0F, 0xFF, 0xEE, 0xC4, 
+0x13, 0x13, 0x22, 0xAD, 0x07, 0x90, 0x81, 0x80, 0xE0, 0x75, 0xF0, 0x20, 0xA4, 0xFF, 0x90, 0x82, 
+0x4D, 0xE5, 0xF0, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x81, 0x81, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0xAE, 
+0xF0, 0x90, 0x82, 0x4F, 0xF0, 0xEE, 0xA3, 0xF0, 0x91, 0x40, 0x90, 0x82, 0x51, 0xF0, 0xEE, 0xA3, 
+0xF0, 0xED, 0x64, 0x01, 0x60, 0x69, 0x90, 0x81, 0x7E, 0xE0, 0xFE, 0x91, 0x56, 0x30, 0xE0, 0x5F, 
+0xEE, 0x71, 0x9B, 0x54, 0x03, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0x57, 0xA4, 0x71, 
+0x96, 0x54, 0x01, 0xFD, 0x12, 0x57, 0xA4, 0x90, 0x81, 0x7E, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 
+0xE0, 0x27, 0xA3, 0xE0, 0x30, 0xE0, 0x0E, 0x90, 0x82, 0x52, 0xE0, 0xF5, 0x52, 0x90, 0x82, 0x51, 
+0xE0, 0x91, 0x48, 0x80, 0x14, 0x91, 0x40, 0xFF, 0x12, 0x32, 0xAA, 0x71, 0x96, 0x54, 0x03, 0x7D, 
+0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0x57, 0xA4, 0x90, 0x81, 0x7E, 0xE0, 0xC4, 0x54, 0x0F, 
+0x30, 0xE0, 0x0C, 0x90, 0x82, 0x50, 0xE0, 0xF5, 0x52, 0x90, 0x82, 0x4F, 0xE0, 0x91, 0x48, 0x22, 
+0x90, 0x82, 0x4D, 0xE0, 0xFE, 0xA3, 0xE0, 0x22, 0xF5, 0x53, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 
+0x01, 0x02, 0x53, 0xD6, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0x90, 0x81, 0x2B, 
+0xE0, 0x60, 0x10, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x04, 0x91, 0x75, 0x80, 0x05, 0x12, 0x4E, 
+0x8C, 0xB1, 0xB4, 0x61, 0x6F, 0x12, 0x77, 0x99, 0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 
+0x90, 0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0xF5, 0x52, 0x90, 
+0x81, 0x6A, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x91, 0x48, 0x90, 0x81, 0x27, 0xE0, 0x44, 0x08, 0xF0, 
+0x22, 0x90, 0x81, 0x27, 0x91, 0x54, 0x30, 0xE0, 0x1D, 0xEF, 0x54, 0x7F, 0xB1, 0xE7, 0x30, 0xE1, 
+0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x07, 0xE0, 0x54, 0xFD, 0xB1, 0xFA, 0x04, 0xF0, 0x90, 0x81, 
+0x2B, 0xE0, 0x60, 0x02, 0xB1, 0xB4, 0x7F, 0x01, 0x90, 0x81, 0x76, 0xE0, 0x30, 0xE0, 0x38, 0x90, 
+0x81, 0x7B, 0xE0, 0xFD, 0x60, 0x31, 0xB1, 0xF2, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 
+0xF9, 0xFF, 0x90, 0x04, 0xE0, 0xE0, 0xFB, 0xEF, 0x5B, 0x60, 0x0B, 0xE4, 0x90, 0x81, 0x7B, 0xF0, 
+0x90, 0x81, 0x7D, 0x04, 0xF0, 0x22, 0x90, 0x81, 0x78, 0xE0, 0xD3, 0x9D, 0x50, 0x04, 0xB1, 0x38, 
+0xF0, 0x22, 0x7D, 0x08, 0xE4, 0xD1, 0x05, 0x22, 0x90, 0x82, 0x7A, 0xEF, 0xF0, 0x90, 0x80, 0x06, 
+0xE0, 0xB4, 0x02, 0x12, 0x90, 0x82, 0x7A, 0xE0, 0xFF, 0x64, 0x01, 0x60, 0x17, 0x90, 0x01, 0x4D, 
+0xE0, 0x64, 0x80, 0xF0, 0x80, 0x0C, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x82, 0x7A, 
+0xE0, 0xFF, 0x71, 0xA3, 0xB1, 0x42, 0xF0, 0x22, 0x90, 0x01, 0xC7, 0x74, 0x10, 0xF0, 0x7F, 0x01, 
+0xB1, 0x08, 0x90, 0x81, 0x76, 0xE0, 0x54, 0xFE, 0x22, 0x90, 0x81, 0x76, 0xE0, 0x30, 0xE0, 0x63, 
+0x90, 0x81, 0x7A, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x7D, 0xE0, 0x64, 0x01, 0x70, 0x20, 0x90, 0x81, 
+0x76, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x15, 0x90, 0x81, 0x7C, 0xE0, 0x70, 0x0F, 0x90, 
+0x81, 0x79, 0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x40, 0x04, 0xB1, 0x38, 0xF0, 0x22, 0x90, 0x81, 
+0x7A, 0xE0, 0xFF, 0x90, 0x81, 0x77, 0xE0, 0xD3, 0x9F, 0x50, 0x28, 0x90, 0x06, 0x92, 0xE0, 0x20, 
+0xE2, 0x12, 0x90, 0x81, 0x7C, 0xE0, 0x70, 0x0C, 0x7D, 0x08, 0xD1, 0x05, 0x90, 0x81, 0x75, 0xE0, 
+0x04, 0xF0, 0x80, 0x06, 0x90, 0x06, 0x92, 0x74, 0x04, 0xF0, 0xE4, 0x90, 0x81, 0x7A, 0xF0, 0x90, 
+0x81, 0x7C, 0xF0, 0x22, 0x90, 0x81, 0x2D, 0xE0, 0xFF, 0x7D, 0x01, 0x02, 0x49, 0x23, 0x90, 0x81, 
+0x27, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x18, 0xEF, 0x54, 0xBF, 0xB1, 0xE7, 
+0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x08, 0xE0, 0x54, 0xFE, 0xB1, 0xFA, 0x74, 0x04, 
+0xF0, 0xB1, 0xB4, 0xE4, 0xFF, 0x81, 0xC8, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x81, 0x28, 0x22, 
+0xE0, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 
+0xF0, 0x90, 0x01, 0xB8, 0x22, 0xFF, 0x12, 0x4C, 0x1A, 0x90, 0x81, 0x7B, 0xE0, 0x04, 0xF0, 0x22, 
+0xE4, 0xFF, 0x12, 0x4D, 0xB7, 0xBF, 0x01, 0x0F, 0x90, 0x81, 0x2B, 0xE0, 0x60, 0x09, 0xD1, 0x28, 
+0xF0, 0x54, 0x07, 0x70, 0x02, 0xB1, 0xB4, 0x22, 0x90, 0x81, 0x2F, 0xE0, 0x54, 0xFE, 0x22, 0xE4, 
+0xF5, 0x19, 0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x19, 0x54, 0xC0, 0x70, 0x08, 0xD1, 0x28, 0xF0, 0x54, 
+0xFD, 0xF0, 0xA1, 0xB4, 0xE5, 0x19, 0x30, 0xE6, 0x1E, 0x90, 0x81, 0x2B, 0xE0, 0x64, 0x01, 0x70, 
+0x19, 0x90, 0x81, 0x2F, 0xE0, 0x44, 0x01, 0x12, 0x47, 0xF2, 0x64, 0x02, 0x60, 0x04, 0xD1, 0xA9, 
+0x80, 0x08, 0x12, 0x47, 0xCC, 0x80, 0x03, 0xD1, 0x28, 0xF0, 0xE5, 0x19, 0x90, 0x81, 0x2F, 0x30, 
+0xE7, 0x15, 0xE0, 0x44, 0x02, 0xF0, 0xE4, 0xF5, 0x52, 0x90, 0x81, 0x69, 0x12, 0x53, 0xCC, 0x90, 
+0x81, 0x27, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x12, 0x4F, 0xD4, 0x70, 
+0x17, 0x90, 0x81, 0x2B, 0xE0, 0x60, 0x11, 0x12, 0x67, 0x8C, 0x90, 0x81, 0x27, 0xE0, 0x12, 0x65, 
+0x60, 0xF0, 0x54, 0x07, 0x70, 0x02, 0xB1, 0xB4, 0x22, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x17, 0x90, 
+0x80, 0x08, 0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 0x12, 0x4D, 0x12, 0x90, 0x81, 0x86, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x12, 0x76, 0x9A, 0x22, 0x12, 0x56, 0x01, 0x30, 0xE0, 0x16, 0xE4, 0x90, 0x80, 
+0xFD, 0xF0, 0x90, 0x80, 0xFA, 0xE0, 0x30, 0xE0, 0x0A, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x04, 0xD1, 
+0xE4, 0xB1, 0x08, 0x22, 0xF1, 0x10, 0x90, 0x01, 0xC7, 0x74, 0x66, 0xF0, 0xE4, 0xFF, 0x22, 0x90, 
+0x80, 0xFA, 0xE0, 0xFF, 0x30, 0xE0, 0x18, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x10, 0x90, 
+0x80, 0xFE, 0xE0, 0x70, 0x04, 0xD1, 0xE4, 0xA1, 0x08, 0x90, 0x80, 0xFE, 0xE0, 0x14, 0xF0, 0x22, 
+0xC2, 0xAF, 0x90, 0x80, 0xFA, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x08, 0xE4, 0xFF, 0x12, 0x4E, 0x72, 
+0x90, 0x02, 0x09, 0xE0, 0x90, 0x04, 0x24, 0xF0, 0x90, 0x02, 0x09, 0xE0, 0x90, 0x04, 0x25, 0xF0, 
+0xE4, 0x90, 0x81, 0x06, 0xF0, 0xA3, 0xF0, 0xD2, 0xAF, 0x22, 0x90, 0x80, 0xFD, 0xE0, 0x60, 0x08, 
+0x90, 0x80, 0xFA, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xD1, 0xE4, 0xA1, 0x08, 0x90, 0x81, 0xAD, 0x74, 
+0x12, 0xF0, 0x90, 0x81, 0xBB, 0x74, 0x05, 0xF0, 0x90, 0x81, 0xAF, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 
+0xA3, 0xEB, 0xF0, 0x90, 0x81, 0xAB, 0xE0, 0x90, 0x81, 0xB2, 0xF0, 0x90, 0x81, 0xAC, 0xE0, 0x90, 
+0x81, 0xB3, 0xF0, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xAD, 0x51, 0xD1, 0x7F, 0x04, 0x61, 0x54, 0x90, 
+0x81, 0x2B, 0xE0, 0x60, 0x35, 0x90, 0x81, 0x28, 0x12, 0x77, 0x9C, 0x30, 0xE0, 0x15, 0x90, 0x01, 
+0x3B, 0xE0, 0x30, 0xE4, 0x0E, 0x7D, 0x02, 0x7F, 0x02, 0x12, 0x4E, 0x72, 0x7D, 0x01, 0x7F, 0x02, 
+0x12, 0x4E, 0x72, 0x90, 0x82, 0x75, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x80, 0x40, 0x0B, 0x90, 
+0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0x47, 0xEB, 0xFF, 0xBF, 0x03, 
+0x0D, 0x90, 0x01, 0xB8, 0xE0, 0x04, 0xF0, 0x90, 0x05, 0x21, 0xE0, 0x44, 0x80, 0xF0, 0xB1, 0x49, 
+0x12, 0x6F, 0x4E, 0xE4, 0x90, 0x81, 0x75, 0xF0, 0xD1, 0xEF, 0x90, 0x81, 0x6F, 0xE0, 0x30, 0xE0, 
+0x0B, 0xE4, 0xF5, 0x52, 0xA3, 0x12, 0x53, 0xCC, 0x12, 0x47, 0xE4, 0xF0, 0x90, 0x81, 0x6F, 0xE0, 
+0x30, 0xE0, 0x3C, 0x90, 0x82, 0x70, 0xE0, 0x70, 0x3F, 0x90, 0x82, 0x6F, 0xE0, 0x04, 0xF0, 0xE0, 
+0xD3, 0x94, 0x06, 0x40, 0x33, 0x90, 0x81, 0x36, 0x74, 0xD0, 0xF0, 0x90, 0x82, 0x70, 0x74, 0x01, 
+0xF0, 0x90, 0x81, 0x6F, 0xE0, 0xFF, 0x13, 0x30, 0xE0, 0x1E, 0xEF, 0xC4, 0x54, 0x0F, 0x20, 0xE0, 
+0x17, 0x90, 0x81, 0x27, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x81, 0x36, 0x74, 0xD0, 0xF0, 0x22, 0xE4, 
+0x90, 0x82, 0x70, 0xF0, 0x90, 0x82, 0x6F, 0xF0, 0x22, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x84, 0x22, 
+0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x90, 0xFD, 0x00, 0xE0, 
+0x54, 0xBF, 0xF0, 0x31, 0x03, 0x12, 0x32, 0x77, 0x31, 0x10, 0x11, 0xEB, 0x7F, 0x01, 0x12, 0x42, 
+0x15, 0x90, 0x81, 0x71, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x42, 0x15, 0x90, 0x81, 0x71, 0xE0, 0x04, 
+0xF0, 0x12, 0x50, 0x13, 0x12, 0x50, 0xE3, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 
+0x12, 0x32, 0x1E, 0x75, 0x20, 0xFF, 0x11, 0x39, 0x11, 0x91, 0x11, 0xF9, 0xE4, 0xFF, 0x02, 0x42, 
+0x9E, 0xE4, 0x90, 0x81, 0x97, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x98, 0xE0, 0x7F, 0x00, 0x30, 0xE4, 
+0x02, 0x7F, 0x01, 0xEF, 0x64, 0x01, 0x60, 0x3C, 0xC3, 0x90, 0x81, 0x98, 0xE0, 0x94, 0x88, 0x90, 
+0x81, 0x97, 0xE0, 0x94, 0x13, 0x40, 0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 
+0xC7, 0x74, 0xFD, 0xF0, 0x80, 0x1E, 0x90, 0x81, 0x97, 0x12, 0x52, 0x62, 0x11, 0xF2, 0xD3, 0x90, 
+0x81, 0x98, 0xE0, 0x94, 0x32, 0x90, 0x81, 0x97, 0xE0, 0x94, 0x00, 0x40, 0xBB, 0x90, 0x01, 0xC6, 
+0xE0, 0x30, 0xE3, 0xB4, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0xE4, 0x90, 0x80, 0x01, 0x02, 
+0x50, 0x92, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x32, 0xAA, 0x90, 0x01, 0xE4, 0x74, 0x14, 0xF0, 0xA3, 
+0xE4, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 
+0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9C, 0x74, 0x7E, 0xF0, 0xA3, 0x74, 0x92, 
+0xF0, 0xA3, 0x74, 0xA0, 0xF0, 0xA3, 0x74, 0x24, 0xF0, 0x90, 0x01, 0x9B, 0x74, 0x49, 0xF0, 0x90, 
+0x01, 0x9A, 0x74, 0xE0, 0xF0, 0x90, 0x01, 0x99, 0xE4, 0xF0, 0x90, 0x01, 0x98, 0x04, 0xF0, 0x22, 
+0xE4, 0x90, 0x81, 0x99, 0xF0, 0x90, 0x81, 0x99, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0x40, 0x90, 0x01, 
+0xC4, 0xF0, 0x74, 0x61, 0xA3, 0xF0, 0x90, 0x81, 0x2B, 0xE0, 0x60, 0x0F, 0x90, 0x81, 0x2E, 0xE0, 
+0xFF, 0x90, 0x81, 0x2D, 0xE0, 0x6F, 0x60, 0x03, 0x12, 0x5D, 0xB4, 0xC2, 0xAF, 0x31, 0x7D, 0xBF, 
+0x01, 0x02, 0x51, 0x3B, 0xD2, 0xAF, 0x31, 0xB5, 0x12, 0x41, 0x4D, 0x80, 0xC8, 0x7D, 0x02, 0x90, 
+0x01, 0xC4, 0x74, 0x7D, 0xF0, 0x74, 0x61, 0xA3, 0xF0, 0x90, 0x81, 0x71, 0xE0, 0xFF, 0xED, 0xC3, 
+0x9F, 0x50, 0x14, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x07, 0x31, 0xB6, 0xA3, 
+0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xE2, 0x74, 0x7D, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x61, 
+0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x22, 0x51, 0x46, 0xEF, 
+0x64, 0x01, 0x60, 0x04, 0x51, 0x34, 0x80, 0x63, 0x90, 0x81, 0x2F, 0xE0, 0xFF, 0x54, 0x03, 0x60, 
+0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x52, 0x90, 0x81, 0x2D, 0xE0, 0xFE, 0xE4, 0xC3, 
+0x9E, 0x50, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x40, 0xEF, 0x30, 0xE2, 0x04, 0x31, 
+0xB6, 0x80, 0x38, 0x90, 0x81, 0x2F, 0xE0, 0x30, 0xE4, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 
+0x80, 0x29, 0x90, 0x81, 0x28, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 
+0x74, 0x20, 0xF0, 0x80, 0x16, 0x90, 0x81, 0x6E, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 
+0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x04, 
+0xF0, 0x7F, 0x00, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x81, 0x27, 0xE0, 0x30, 
+0xE0, 0x03, 0x12, 0x52, 0xF2, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 
+0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0x90, 
+0x02, 0x87, 0xE0, 0x60, 0x04, 0x51, 0x34, 0x80, 0x25, 0x90, 0x02, 0x96, 0xE0, 0x60, 0x08, 0x90, 
+0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 0x17, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x08, 0x90, 0x01, 
+0xB8, 0x74, 0x04, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x01, 
+0xB9, 0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x82, 0x26, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 
+0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x90, 0x82, 0x34, 0xF0, 0x7F, 0x24, 0x7E, 0x08, 
+0x12, 0x2D, 0x5C, 0x90, 0x82, 0x2C, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x26, 0xE0, 0xFB, 0x70, 0x04, 
+0x71, 0x7F, 0x80, 0x06, 0xEB, 0x71, 0x8E, 0x12, 0x2D, 0x5C, 0x90, 0x82, 0x30, 0x12, 0x20, 0xCE, 
+0x90, 0x82, 0x27, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x17, 0x91, 0x03, 0xAB, 0x07, 0x90, 
+0x82, 0x30, 0x12, 0x44, 0xC2, 0xED, 0x54, 0x7F, 0xFD, 0xEC, 0x54, 0x80, 0xFC, 0x12, 0x44, 0xB5, 
+0xEC, 0x44, 0x80, 0xFC, 0x90, 0x82, 0x30, 0x12, 0x20, 0xCE, 0x71, 0x7F, 0xEC, 0x54, 0x7F, 0xFC, 
+0x71, 0x88, 0x71, 0xA1, 0xE0, 0x71, 0x8E, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 0x30, 0x71, 0x85, 
+0xD0, 0x07, 0xD0, 0x06, 0x12, 0x2E, 0xA2, 0x71, 0x7F, 0xEC, 0x44, 0x80, 0xFC, 0x71, 0x88, 0x71, 
+0xA1, 0xE0, 0x70, 0x04, 0x7F, 0x20, 0x80, 0x09, 0x90, 0x82, 0x26, 0xE0, 0xB4, 0x01, 0x16, 0x7F, 
+0x28, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0x78, 0x08, 0x12, 0x20, 0xA8, 0xEF, 0x54, 0x01, 0xFF, 0xE4, 
+0x90, 0x82, 0x34, 0xEF, 0xF0, 0x90, 0x82, 0x34, 0xE0, 0x90, 0x82, 0x26, 0x60, 0x0E, 0xE0, 0x75, 
+0xF0, 0x08, 0xA4, 0x24, 0x66, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x80, 0x0C, 0xE0, 0x75, 0xF0, 0x08, 
+0xA4, 0x24, 0x64, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x71, 0x99, 0x12, 0x2D, 0x5C, 0xED, 0x54, 0x0F, 
+0xFD, 0xE4, 0xFC, 0x90, 0x82, 0x28, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x28, 0x02, 0x44, 0xC2, 0x90, 
+0x82, 0x2C, 0x02, 0x44, 0xC2, 0x12, 0x44, 0xC2, 0x90, 0x85, 0xBB, 0x02, 0x20, 0xCE, 0x75, 0xF0, 
+0x08, 0xA4, 0x24, 0x62, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
+0x22, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x82, 0x26, 0x22, 0x90, 0x82, 0x35, 0xEF, 
+0xF0, 0xAB, 0x05, 0x90, 0x82, 0x3B, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x03, 0xE4, 
+0xFC, 0xFD, 0xFE, 0x78, 0x14, 0x91, 0x03, 0xAB, 0x07, 0x90, 0x82, 0x37, 0x12, 0x44, 0xC2, 0xED, 
+0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x12, 0x44, 0xB5, 0xEC, 0x54, 0x0F, 0xFC, 0x90, 0x82, 0x3B, 0x12, 
+0x20, 0xCE, 0x90, 0x82, 0x35, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x60, 0xF5, 0x82, 0xE4, 0x34, 
+0x87, 0x71, 0x99, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 0x3B, 0x71, 0x85, 0xD0, 0x07, 0xD0, 0x06, 
+0x02, 0x2E, 0xA2, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0x22, 0x7F, 0xFF, 0x12, 
+0x4B, 0xAB, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x6B, 0x49, 0x90, 0x85, 0xBB, 0x12, 
+0x20, 0xDA, 0xCC, 0xF0, 0x00, 0xC0, 0x7F, 0x8C, 0x91, 0x6D, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 
+0x14, 0x91, 0xA1, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFD, 0xFF, 0x91, 0x76, 0x91, 
+0x98, 0x44, 0x80, 0xFC, 0x90, 0x82, 0x60, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x60, 0x71, 0x85, 0x7F, 
+0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 0xFD, 
+0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7E, 0x08, 0x12, 
+0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 
+0x05, 0x90, 0x82, 0x49, 0x12, 0x44, 0xC2, 0x90, 0x82, 0x37, 0x12, 0x20, 0xCE, 0xD0, 0x05, 0xD0, 
+0x07, 0x71, 0xAC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0xEC, 
+0x22, 0x7F, 0x70, 0x7E, 0x0E, 0x12, 0x2E, 0xA2, 0x90, 0x82, 0x49, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x51, 0x97, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x81, 0x6F, 0xE0, 0x30, 0xE0, 
+0x14, 0x54, 0xFB, 0xF0, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x7D, 0x04, 0x7F, 0x01, 0x02, 0x4B, 
+0x11, 0x7D, 0x31, 0x91, 0x0D, 0x22, 0x90, 0x81, 0x2B, 0xE0, 0x60, 0x02, 0x91, 0xE0, 0x80, 0xDA, 
+0xD1, 0x1D, 0x30, 0xE0, 0x10, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x07, 0x7D, 0x02, 
+0x7F, 0x02, 0x12, 0x4E, 0x72, 0x90, 0x81, 0x27, 0xB1, 0x59, 0x30, 0xE0, 0x0A, 0xEF, 0xB1, 0x60, 
+0xF0, 0x54, 0x07, 0x70, 0x4C, 0x80, 0x47, 0x90, 0x81, 0x34, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x2F, 
+0xE0, 0x54, 0xEF, 0xF0, 0x90, 0x81, 0x68, 0xE0, 0xFF, 0x90, 0x81, 0x34, 0xE0, 0xD3, 0x9F, 0x40, 
+0x2D, 0x12, 0x4F, 0xD4, 0x70, 0x2B, 0x12, 0x47, 0xF3, 0x70, 0x04, 0xB1, 0x52, 0xF0, 0x22, 0x90, 
+0x81, 0x35, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 0x0A, 0xB1, 0x52, 0xF0, 0xE4, 0x90, 
+0x81, 0x35, 0xF0, 0x80, 0x03, 0x12, 0x47, 0xCC, 0xE4, 0x90, 0x81, 0x34, 0xF0, 0x22, 0x12, 0x5D, 
+0xB4, 0x22, 0x90, 0x81, 0x28, 0xE0, 0x54, 0xFB, 0x22, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x22, 
+0x54, 0xFB, 0xF0, 0x90, 0x81, 0x2F, 0xE0, 0x54, 0xFD, 0x22, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 
+0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 
+0x81, 0x84, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x4F, 0xD4, 0x60, 0x02, 0xC1, 0x1C, 0x90, 0x81, 
+0x2B, 0xE0, 0x70, 0x02, 0xC1, 0x1C, 0xD1, 0xE5, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 
+0x90, 0x81, 0x32, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 0x90, 0x81, 0x31, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 
+0x08, 0x90, 0x81, 0x31, 0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 0x81, 0x32, 0xEF, 0xF0, 0xD1, 0x28, 
+0xF0, 0xE4, 0x90, 0x81, 0x34, 0xF1, 0x81, 0xF1, 0x8C, 0xB1, 0x63, 0xF0, 0x54, 0xEF, 0xF0, 0x90, 
+0x81, 0x29, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x03, 0x12, 0x5E, 0x2F, 
+0xD1, 0x1D, 0x30, 0xE0, 0x37, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x2E, 0x90, 0x81, 
+0x31, 0xE0, 0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x24, 0x90, 0x81, 0x28, 0xE0, 0x44, 0x40, 0xF0, 0xF1, 
+0x78, 0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 0x03, 0xF1, 0x6F, 0x7D, 0x01, 0x12, 0x4F, 
+0xEA, 0x7F, 0x02, 0x12, 0x4E, 0x72, 0x90, 0x81, 0x32, 0xE0, 0x14, 0xF0, 0x22, 0x90, 0x81, 0x28, 
+0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x90, 0x81, 0x28, 0xE0, 0x44, 0x04, 0x22, 0xD1, 
+0xB6, 0xFE, 0x90, 0x81, 0x6F, 0xD1, 0xDD, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0xF1, 0x67, 0x54, 
+0x04, 0x25, 0xE0, 0xFD, 0xEF, 0x54, 0xF7, 0x4D, 0xFF, 0x90, 0x81, 0x6F, 0xF0, 0xEE, 0x54, 0x08, 
+0x25, 0xE0, 0xFE, 0xEF, 0x54, 0xEF, 0x4E, 0x12, 0x55, 0xF9, 0xFF, 0x90, 0x05, 0x54, 0xE0, 0xC3, 
+0x9F, 0x90, 0x81, 0x70, 0xF0, 0x12, 0x1F, 0xA4, 0x20, 0xE0, 0x0A, 0x12, 0x4B, 0xA6, 0x90, 0x01, 
+0x57, 0xE4, 0xF0, 0x80, 0x0B, 0x7D, 0x0C, 0x7F, 0x01, 0x12, 0x4B, 0x11, 0x12, 0x47, 0xE4, 0xF0, 
+0x90, 0x81, 0x6F, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x15, 0x90, 0x81, 0x2B, 0x74, 0x01, 0xF0, 0xE4, 
+0x90, 0x81, 0x2D, 0xF0, 0xD1, 0x28, 0xF0, 0x90, 0x05, 0x58, 0x74, 0x05, 0xF0, 0x22, 0xE4, 0x90, 
+0x81, 0x2B, 0xF0, 0x90, 0x81, 0x2D, 0x74, 0x0C, 0xF0, 0x90, 0x81, 0x27, 0xE0, 0x54, 0xFE, 0xF0, 
+0xA3, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0x22, 0xD1, 0xB6, 0xFE, 
+0x90, 0x81, 0x72, 0xD1, 0xDD, 0x54, 0x04, 0xFF, 0xEE, 0x54, 0xFB, 0x4F, 0xF0, 0x12, 0x1F, 0xA4, 
+0xC3, 0x13, 0x30, 0xE0, 0x07, 0x12, 0x55, 0xFA, 0x90, 0x81, 0x73, 0xF0, 0x22, 0xE0, 0x54, 0xFE, 
+0x4E, 0xFE, 0xF0, 0xEF, 0x22, 0x90, 0x81, 0x29, 0xE0, 0xC4, 0x54, 0x0F, 0x22, 0xE4, 0xF5, 0x19, 
+0x90, 0x81, 0x2B, 0xE0, 0x60, 0x60, 0x12, 0x4F, 0xD4, 0x70, 0x5B, 0xD1, 0xE5, 0x60, 0x22, 0x24, 
+0xFE, 0x60, 0x03, 0x04, 0x70, 0x1E, 0x90, 0x81, 0x32, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 
+0x90, 0x81, 0x34, 0xE0, 0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 0x81, 0x31, 0xE0, 0xA3, 0xF0, 0x80, 
+0x00, 0x75, 0x19, 0x01, 0xE5, 0x19, 0x60, 0x2E, 0xF1, 0x5F, 0x90, 0x81, 0x34, 0xE0, 0x60, 0x03, 
+0xB4, 0x01, 0x04, 0xF1, 0x57, 0x80, 0x08, 0xF1, 0x57, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 
+0x90, 0x81, 0x33, 0xE0, 0x2F, 0x12, 0x53, 0xCD, 0x90, 0x81, 0x2E, 0xE0, 0x20, 0xE2, 0x07, 0x7D, 
+0x01, 0x7F, 0x04, 0x12, 0x49, 0x23, 0x22, 0xE4, 0xF5, 0x52, 0x90, 0x81, 0x34, 0xE0, 0x22, 0x90, 
+0x81, 0x2F, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x4F, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x22, 0x74, 
+0x45, 0x2F, 0xF8, 0xE6, 0x4D, 0x02, 0x48, 0xD5, 0x90, 0x81, 0x31, 0xE0, 0x90, 0x05, 0x73, 0xF0, 
+0x22, 0xF0, 0x90, 0x81, 0x37, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0x90, 0x01, 0x57, 0xE4, 
+0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x22, 0x90, 0x81, 0x7C, 0xE0, 0x04, 0xF0, 0x90, 0x81, 
+0x2E, 0xE0, 0x64, 0x02, 0x60, 0x08, 0xB1, 0x6A, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 0x12, 
+0x4F, 0xD4, 0x70, 0x11, 0x90, 0x81, 0x2B, 0xE0, 0x60, 0x0B, 0xF1, 0x8C, 0xE4, 0xF5, 0x52, 0x90, 
+0x81, 0x69, 0x12, 0x53, 0xCC, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8B, 0x1A, 0x8A, 
+0x1B, 0x89, 0x1C, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 0x26, 0xF0, 0xBF, 0x01, 0x0D, 0x12, 0x55, 
+0xFA, 0x64, 0x01, 0x60, 0x19, 0x7D, 0x13, 0x7F, 0x6F, 0x80, 0x10, 0xAB, 0x1A, 0xAA, 0x1B, 0xA9, 
+0x1C, 0x12, 0x55, 0xFA, 0x64, 0x01, 0x60, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x4B, 0xAB, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 0x1C, 0xF0, 0xBF, 0x01, 0x07, 0x11, 0x16, 
+0xE4, 0x90, 0x81, 0x1C, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xA2, 0x7F, 0xF5, 0x7E, 0x00, 
+0x12, 0x2B, 0x27, 0xBF, 0x01, 0x06, 0x90, 0x81, 0xA2, 0xE0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0x81, 
+0x79, 0xA2, 0x7F, 0xF6, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x81, 0xA2, 0xE0, 
+0x90, 0x81, 0xA4, 0xF0, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xA2, 0x7F, 0xF4, 0x7E, 0x00, 0x12, 0x2B, 
+0x27, 0xBF, 0x01, 0x08, 0x90, 0x81, 0xA2, 0xE0, 0x90, 0x81, 0xA5, 0xF0, 0x7B, 0x01, 0x7A, 0x81, 
+0x79, 0xA2, 0x7F, 0xF3, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x81, 0xA2, 0xE0, 
+0x90, 0x81, 0xA6, 0xF0, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xA2, 0x7F, 0xF2, 0x7E, 0x00, 0x12, 0x2B, 
+0x27, 0xBF, 0x01, 0x08, 0x90, 0x81, 0xA2, 0xE0, 0x90, 0x81, 0xA7, 0xF0, 0x90, 0x81, 0xA3, 0xE0, 
+0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 0x81, 0xAB, 0xF0, 0x90, 0x81, 0xA7, 
+0xE0, 0x90, 0x81, 0xAC, 0xF0, 0x02, 0x5F, 0x4C, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 0x90, 0x81, 
+0x83, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x36, 0xF0, 0x22, 0x12, 
+0x1F, 0xA4, 0x90, 0x81, 0x6E, 0xF0, 0x22, 0xE4, 0x90, 0x80, 0xF6, 0xF0, 0xA3, 0xF0, 0x90, 0x80, 
+0x5E, 0xF0, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x9E, 0x12, 
+0x44, 0xE3, 0x90, 0x82, 0x68, 0xE0, 0xFF, 0x04, 0xF0, 0x90, 0x00, 0x01, 0xEF, 0x12, 0x1F, 0xFC, 
+0x7F, 0xAF, 0x7E, 0x01, 0x12, 0x51, 0xCD, 0xEF, 0x60, 0x3A, 0x90, 0x81, 0x9E, 0x12, 0x44, 0xDA, 
+0x8B, 0x13, 0x8A, 0x14, 0x89, 0x15, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x24, 0x02, 0xF5, 0x16, 
+0x7B, 0x01, 0x7A, 0x01, 0x79, 0xA0, 0x12, 0x2B, 0xED, 0x90, 0x81, 0x9E, 0x12, 0x44, 0xDA, 0x90, 
+0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x90, 0x01, 0xAE, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0x90, 0x01, 0xCB, 
+0xE0, 0x64, 0x80, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x75, 0x3D, 0x10, 0xE4, 0xF5, 0x3E, 0x75, 
+0x3F, 0x87, 0x75, 0x40, 0x03, 0x90, 0x01, 0x30, 0xE5, 0x3D, 0xF0, 0xA3, 0xE5, 0x3E, 0xF0, 0xA3, 
+0xE5, 0x3F, 0xF0, 0xA3, 0xE5, 0x40, 0xF0, 0x22, 0x75, 0x45, 0x0E, 0x75, 0x46, 0x01, 0x75, 0x47, 
+0x23, 0x75, 0x48, 0x62, 0x90, 0x01, 0x38, 0xE5, 0x45, 0xF0, 0xA3, 0xE5, 0x46, 0xF0, 0xA3, 0xE5, 
+0x47, 0xF0, 0xA3, 0xE5, 0x48, 0xF0, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x3D, 0xF5, 0x41, 0xA3, 
+0xE0, 0x55, 0x3E, 0xF5, 0x42, 0xA3, 0xE0, 0x55, 0x3F, 0xF5, 0x43, 0xA3, 0xE0, 0x55, 0x40, 0xF5, 
+0x44, 0x90, 0x01, 0x34, 0xE5, 0x41, 0xF0, 0xA3, 0xE5, 0x42, 0xF0, 0xA3, 0xE5, 0x43, 0xF0, 0xA3, 
+0xE5, 0x44, 0xF0, 0x22, 0x90, 0x01, 0x3C, 0xE0, 0x55, 0x45, 0xF5, 0x49, 0xA3, 0xE0, 0x55, 0x46, 
+0xF5, 0x4A, 0xA3, 0xE0, 0x55, 0x47, 0xF5, 0x4B, 0xA3, 0xE0, 0x55, 0x48, 0xF5, 0x4C, 0x90, 0x01, 
+0x3C, 0xE5, 0x49, 0xF0, 0xA3, 0xE5, 0x4A, 0xF0, 0xA3, 0xE5, 0x4B, 0xF0, 0xA3, 0xE5, 0x4C, 0xF0, 
+0x53, 0x91, 0xDF, 0x22, 0x90, 0x01, 0xCF, 0xE0, 0x90, 0x82, 0x76, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 
+0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 
+0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x50, 
+0x64, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x32, 0x1E, 0x80, 0xFE, 0x22, 
+0xE4, 0xFF, 0x12, 0x4D, 0xB7, 0xBF, 0x01, 0x13, 0x90, 0x81, 0x2B, 0xE0, 0x60, 0x0D, 0x12, 0x47, 
+0xF3, 0x64, 0x02, 0x60, 0x03, 0x02, 0x5E, 0xA9, 0x12, 0x47, 0xCC, 0x22, 0x90, 0x05, 0x50, 0xE0, 
+0x44, 0x01, 0xF0, 0x12, 0x47, 0xEB, 0xFF, 0xBF, 0x03, 0x02, 0x51, 0x3D, 0x22, 0x90, 0x05, 0x21, 
+0xE0, 0x54, 0x7F, 0xF0, 0x22, 0x51, 0xFE, 0x90, 0x81, 0x88, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 
+0x01, 0xE4, 0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x4B, 0x11, 0x90, 0x81, 0x88, 0xE0, 0x30, 0xE6, 
+0x11, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 
+0x80, 0xF0, 0x90, 0x81, 0x27, 0xE0, 0x90, 0x04, 0xEC, 0x30, 0xE0, 0x06, 0xE0, 0x54, 0xDD, 0xF0, 
+0x80, 0x04, 0xE0, 0x44, 0x22, 0xF0, 0x90, 0x81, 0x3D, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x90, 0x81, 
+0x44, 0xE0, 0xFB, 0xAC, 0x07, 0x90, 0x81, 0x27, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x81, 0x61, 0xE0, 
+0x24, 0x04, 0x90, 0x81, 0x40, 0xF0, 0x90, 0x81, 0x61, 0xE0, 0x24, 0x03, 0x90, 0x81, 0x3F, 0xF0, 
+0x80, 0x0B, 0x90, 0x81, 0x40, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x3F, 0x14, 0xF0, 0x90, 0x81, 0x3F, 
+0xE0, 0xFA, 0x90, 0x81, 0x3E, 0xE0, 0xD3, 0x9A, 0x50, 0x09, 0x90, 0x81, 0x33, 0xEB, 0x51, 0xF6, 
+0x2C, 0x80, 0x0B, 0xAD, 0x02, 0xC3, 0xED, 0x9D, 0x2B, 0x90, 0x81, 0x33, 0x51, 0xF6, 0x90, 0x81, 
+0x43, 0xF0, 0x90, 0x81, 0x43, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0x81, 0x37, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0xF0, 0x90, 0x81, 0x40, 0xE0, 0xC3, 0x9D, 0x22, 0xE4, 0x90, 
+0x81, 0x89, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0x90, 0x81, 0x89, 0xF0, 0x90, 
+0x00, 0x83, 0xE0, 0xFE, 0x90, 0x81, 0x89, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x81, 
+0x8B, 0xE0, 0x94, 0x64, 0x90, 0x81, 0x8A, 0xE0, 0x94, 0x00, 0x40, 0x08, 0x71, 0x3C, 0x90, 0x81, 
+0x89, 0xE0, 0xFF, 0x22, 0x90, 0x81, 0x8A, 0x12, 0x52, 0x62, 0x80, 0xCB, 0x90, 0x01, 0xC0, 0xE0, 
+0x44, 0x40, 0xF0, 0x22, 0x7F, 0xFF, 0x12, 0x4B, 0xAB, 0xE4, 0x90, 0x82, 0x6B, 0xF0, 0xA3, 0xF0, 
+0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 
+0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 0x82, 0x6C, 0xE0, 0x94, 0xE8, 0x90, 0x82, 0x6B, 0xE0, 
+0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 
+0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x82, 0x6B, 0x12, 0x52, 0x62, 0x80, 0xC3, 0x90, 0x01, 0xC4, 
+0x74, 0x8D, 0xF0, 0x74, 0x6B, 0xA3, 0xF0, 0x90, 0x00, 0x90, 0xE0, 0x20, 0xE0, 0xF9, 0x74, 0x8D, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x6B, 0xA3, 0xF0, 0x22, 0x90, 0x81, 0x28, 0xE0, 0x44, 0x10, 
+0xF0, 0x90, 0x81, 0x36, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x32, 0x1E, 0x90, 0x81, 0x2C, 0xE0, 0x60, 
+0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 
+0x74, 0x90, 0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x12, 0x32, 0x1E, 0x7F, 
+0x01, 0x12, 0x52, 0x15, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x90, 0x12, 0x32, 0x1E, 
+0x7F, 0x14, 0x7E, 0x00, 0x02, 0x32, 0xAA, 0x7E, 0x00, 0x7F, 0x41, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 
+0x81, 0x79, 0x27, 0x12, 0x45, 0x12, 0x90, 0x81, 0x2A, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x31, 0x14, 
+0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x90, 0x81, 0x37, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 
+0x91, 0x97, 0xF0, 0xE4, 0xFD, 0xFF, 0x12, 0x4B, 0x11, 0x7D, 0x0C, 0x7F, 0x02, 0x12, 0x4B, 0x11, 
+0x7D, 0x0C, 0x7F, 0x01, 0x12, 0x4B, 0x11, 0x90, 0x80, 0x06, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 
+0x81, 0x36, 0x74, 0x99, 0xF0, 0x80, 0x29, 0xEF, 0xB4, 0x03, 0x08, 0x90, 0x81, 0x36, 0x74, 0x90, 
+0xF0, 0x80, 0x1D, 0x90, 0x81, 0x36, 0x74, 0x40, 0xF0, 0x90, 0x00, 0x2C, 0xE0, 0x54, 0x0F, 0xFF, 
+0xBF, 0x05, 0x08, 0x90, 0x81, 0x61, 0x74, 0x02, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0x81, 0x61, 0xF0, 
+0x12, 0x57, 0x14, 0x91, 0x97, 0xF0, 0x7E, 0x00, 0x7F, 0x02, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 
+0x79, 0x6C, 0x12, 0x45, 0x12, 0x91, 0xA5, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0x12, 0x47, 
+0xC5, 0xE4, 0x90, 0x81, 0x6E, 0xF0, 0x22, 0x90, 0x81, 0x61, 0xE0, 0x24, 0x04, 0x90, 0x81, 0x43, 
+0xF0, 0xA3, 0x74, 0x08, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0x22, 0x90, 0x82, 0x53, 0xE0, 
+0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x79, 0xEF, 0xF0, 0x90, 0x80, 0x09, 
+0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 0x42, 0x90, 0x81, 0x2E, 0xE0, 0x64, 0x0E, 0x70, 
+0x19, 0x90, 0x82, 0x79, 0xE0, 0x70, 0x34, 0x90, 0x81, 0x27, 0xE0, 0x54, 0x7F, 0xF0, 0x91, 0xA5, 
+0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0x12, 0x4B, 0x11, 0x80, 0x1E, 0x90, 0x81, 0x2E, 0xE0, 0x64, 0x06, 
+0x70, 0x19, 0x90, 0x82, 0x79, 0xE0, 0x60, 0x13, 0x90, 0x81, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0xB1, 
+0x10, 0xF0, 0x90, 0x81, 0x2E, 0x74, 0x04, 0xF0, 0x12, 0x47, 0xC6, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0x22, 0xEF, 0x24, 0xFE, 0x60, 0x0B, 
+0x04, 0x70, 0x24, 0x90, 0x81, 0x31, 0x74, 0x02, 0xF0, 0x80, 0x13, 0xED, 0x70, 0x06, 0x90, 0x81, 
+0x6B, 0xE0, 0x80, 0x02, 0xED, 0x14, 0x90, 0x81, 0x31, 0xF0, 0x90, 0x81, 0x31, 0xE0, 0xA3, 0xF0, 
+0x90, 0x81, 0x28, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x90, 0x81, 0x6F, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 
+0xFD, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0x81, 0x6F, 0xE0, 0x54, 0xFB, 0xF0, 0x54, 0xEF, 0xF0, 0x22, 
+0x74, 0x01, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFE, 0xEF, 0xC3, 
+0x13, 0xFD, 0xEF, 0x30, 0xE0, 0x02, 0x7E, 0x80, 0x90, 0xFD, 0x10, 0xED, 0xF0, 0xAF, 0x06, 0x22, 
+0x24, 0x07, 0xCF, 0x34, 0x00, 0xFE, 0xE4, 0xFD, 0xAB, 0x07, 0xAA, 0x06, 0xED, 0x2B, 0xFB, 0xE4, 
+0x3A, 0xFA, 0xC3, 0x90, 0x80, 0xF9, 0xE0, 0x9B, 0x90, 0x80, 0xF8, 0xE0, 0x9A, 0x50, 0x09, 0xA3, 
+0xF1, 0x01, 0xEB, 0x9F, 0xFB, 0xEA, 0x9E, 0xFA, 0xEA, 0x90, 0xFD, 0x11, 0xF0, 0xAF, 0x03, 0x74, 
+0x00, 0x2F, 0xD1, 0xE4, 0xFF, 0x22, 0xD1, 0x61, 0xC0, 0x07, 0xD1, 0x55, 0xAD, 0x07, 0xD0, 0x07, 
+0xD1, 0x4B, 0xD1, 0x05, 0x24, 0x06, 0xB1, 0x82, 0xEF, 0x64, 0x08, 0x70, 0x30, 0xD1, 0x00, 0xB1, 
+0x80, 0xEF, 0x70, 0x29, 0xD1, 0x00, 0x24, 0x1D, 0xB1, 0x82, 0xBF, 0x44, 0x0B, 0xD1, 0x00, 0x24, 
+0x1F, 0xB1, 0x82, 0xEF, 0x64, 0x43, 0x60, 0x12, 0xD1, 0x00, 0x24, 0x1D, 0xB1, 0x82, 0xBF, 0x43, 
+0x0C, 0xD1, 0x00, 0x24, 0x1F, 0xB1, 0x82, 0xBF, 0x44, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 
+0x90, 0x82, 0x21, 0xE0, 0xFF, 0x90, 0x82, 0x20, 0xE0, 0x2F, 0xFF, 0x90, 0x82, 0x1F, 0xE0, 0x34, 
+0x00, 0xCF, 0x22, 0xD1, 0x61, 0xC0, 0x07, 0xD1, 0x55, 0xAD, 0x07, 0xD0, 0x07, 0xD1, 0x4B, 0xD1, 
+0x05, 0x24, 0x06, 0xB1, 0x82, 0xEF, 0x64, 0x08, 0x70, 0x1E, 0xD1, 0x00, 0xB1, 0x80, 0xEF, 0x64, 
+0x06, 0x70, 0x15, 0xD1, 0x00, 0x24, 0x0E, 0xB1, 0x82, 0xEF, 0x70, 0x0C, 0xD1, 0x00, 0x24, 0x0F, 
+0xB1, 0x82, 0xBF, 0x01, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0xE4, 0xFB, 0xD1, 0x6D, 0x90, 
+0x82, 0x21, 0xEF, 0xF0, 0x22, 0x90, 0x82, 0x1F, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x01, 0xA1, 
+0x88, 0x90, 0x82, 0x1F, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xFD, 0xA1, 0x88, 0xEF, 0x30, 0xE7, 
+0x04, 0x7E, 0x02, 0x80, 0x02, 0xE4, 0xFE, 0xED, 0x30, 0xE6, 0x12, 0xEB, 0x20, 0xE0, 0x07, 0x90, 
+0x80, 0xFF, 0xE0, 0xFC, 0x80, 0x09, 0x90, 0x81, 0x00, 0xE0, 0xFC, 0x80, 0x02, 0xE4, 0xFC, 0xEE, 
+0x24, 0x18, 0x2C, 0xFF, 0x22, 0xFC, 0xED, 0x2C, 0xFD, 0xA1, 0x88, 0x90, 0x82, 0x1F, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xB1, 0x88, 0xEF, 0x54, 0x0C, 0x64, 0x08, 0x70, 0x2B, 0x90, 
+0x82, 0x22, 0xF0, 0x90, 0x82, 0x22, 0xE0, 0xFD, 0xC3, 0x94, 0x06, 0x50, 0x1D, 0x90, 0x82, 0x1F, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x24, 0x10, 0xD1, 0x95, 0xEF, 0xF4, 0x60, 0x03, 0x7F, 
+0x01, 0x22, 0x90, 0x82, 0x22, 0xE0, 0x04, 0xF0, 0x80, 0xD9, 0x7F, 0x00, 0x22, 0x24, 0x18, 0xFD, 
+0xB1, 0x88, 0xEF, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x22, 0x24, 0x19, 0xFD, 
+0xB1, 0x88, 0x90, 0x81, 0xBF, 0x22, 0x24, 0x04, 0xFD, 0x90, 0x81, 0xA8, 0xE0, 0x2D, 0xFD, 0xA1, 
+0x88, 0xE0, 0x24, 0x01, 0xFF, 0x90, 0x80, 0xF8, 0xE0, 0x34, 0x00, 0xFE, 0xC3, 0x22, 0x24, 0x1A, 
+0xFC, 0xED, 0x2C, 0xFD, 0xB1, 0x88, 0x90, 0x81, 0xA8, 0xE0, 0x24, 0xC0, 0xF5, 0x82, 0xE4, 0x34, 
+0x81, 0x22, 0x24, 0x0A, 0xFC, 0xED, 0x2C, 0xFD, 0xB1, 0x88, 0x90, 0x81, 0xA2, 0xA3, 0xE0, 0xFE, 
+0x90, 0x81, 0xA8, 0xE0, 0x2E, 0x24, 0x24, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEF, 0xF0, 
+0x90, 0x81, 0xA8, 0xE0, 0x04, 0xF0, 0x22, 0x7D, 0x08, 0xE4, 0xFF, 0x02, 0x4C, 0x1A, 0x90, 0x81, 
+0x72, 0xE0, 0x30, 0xE0, 0x34, 0x12, 0x4F, 0xD4, 0x70, 0x2F, 0x90, 0x82, 0x7B, 0xE0, 0x04, 0xF0, 
+0xE0, 0xB4, 0x0A, 0x0B, 0x90, 0x81, 0x74, 0xE0, 0x04, 0xF0, 0xE4, 0x90, 0x82, 0x7B, 0xF0, 0x90, 
+0x81, 0x74, 0xE0, 0xFF, 0x90, 0x81, 0x73, 0xE0, 0xD3, 0x9F, 0x50, 0x0D, 0x90, 0x81, 0x75, 0xE0, 
+0x70, 0x07, 0xE4, 0x90, 0x81, 0x74, 0xF0, 0xF1, 0x47, 0x22, 0x90, 0x02, 0x84, 0xEF, 0xF0, 0xEE, 
+0xA3, 0xF0, 0xA3, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x7D, 0x7F, 0xEF, 0x5D, 0xC3, 0x60, 0x0A, 0xF1, 
+0xAD, 0x24, 0x80, 0xFF, 0xE4, 0x3E, 0xFE, 0x80, 0x03, 0xF1, 0xAD, 0xFF, 0x22, 0x74, 0xFF, 0x9D, 
+0xFD, 0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x5F, 0x22, 0x7E, 0x00, 0x7F, 0x08, 0x7D, 0x00, 
+0x7B, 0x01, 0x7A, 0x81, 0x79, 0x76, 0x12, 0x45, 0x12, 0x90, 0x81, 0x77, 0x74, 0x08, 0xF0, 0xA3, 
+0x74, 0x03, 0xF0, 0x22, 0x90, 0x82, 0x1F, 0x12, 0x44, 0xE3, 0xE4, 0xFF, 0x90, 0x82, 0x25, 0xE0, 
+0xFE, 0xEF, 0xC3, 0x9E, 0x50, 0x14, 0x90, 0x82, 0x22, 0xF1, 0xFD, 0xFE, 0x90, 0x82, 0x1F, 0xF1, 
+0xFD, 0x6E, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x0F, 0x80, 0xE2, 0x7F, 0x01, 0x22, 0x12, 0x44, 0xDA, 
+0x8F, 0x82, 0x75, 0x83, 0x00, 0x02, 0x1F, 0xBD, 0x12, 0x56, 0x01, 0x30, 0xE0, 0x09, 0xEF, 0xC4, 
+0x54, 0x0F, 0x30, 0xE0, 0x02, 0xA1, 0xD7, 0x90, 0x81, 0x17, 0xE0, 0x90, 0x82, 0x01, 0xF0, 0x90, 
+0x81, 0x18, 0xE0, 0x90, 0x82, 0x02, 0xF0, 0x90, 0x81, 0x19, 0xE0, 0x90, 0x82, 0x03, 0xF0, 0x90, 
+0x81, 0x1A, 0xE0, 0x90, 0x82, 0x04, 0xF0, 0x90, 0x81, 0x1B, 0xE0, 0x90, 0x82, 0x05, 0xF0, 0x90, 
+0x81, 0x08, 0xE0, 0x90, 0x82, 0x06, 0xF0, 0x90, 0x81, 0x09, 0xE0, 0x90, 0x82, 0x07, 0xF0, 0x90, 
+0x81, 0x0A, 0xE0, 0x90, 0x82, 0x08, 0xF0, 0x90, 0x81, 0x0B, 0xE0, 0x90, 0x82, 0x09, 0xF0, 0x90, 
+0x81, 0x0C, 0xE0, 0x90, 0x82, 0x0A, 0xF0, 0x90, 0x81, 0x0D, 0xE0, 0x90, 0x82, 0x0B, 0xF0, 0x90, 
+0x81, 0x0E, 0xE0, 0x90, 0x82, 0x0C, 0xF0, 0x90, 0x81, 0x0F, 0xE0, 0x90, 0x82, 0x0D, 0xF0, 0x90, 
+0x81, 0x10, 0xE0, 0x90, 0x82, 0x0E, 0xF0, 0x90, 0x81, 0x11, 0xE0, 0x90, 0x82, 0x0F, 0xF0, 0x12, 
+0x50, 0x8A, 0x90, 0x81, 0xA9, 0xF0, 0xB1, 0xE5, 0x50, 0x04, 0xB1, 0xF2, 0x80, 0xF8, 0x90, 0x01, 
+0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0xF1, 0x2F, 0x90, 0x81, 0x9E, 0xF0, 0xA3, 0xD1, 0xA1, 0xB1, 
+0xE5, 0x50, 0x4B, 0x12, 0x6D, 0x60, 0x90, 0x81, 0xA9, 0xE0, 0xFE, 0x24, 0x10, 0xF5, 0x82, 0xE4, 
+0x34, 0x82, 0xD1, 0x7C, 0xE0, 0x24, 0x45, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFF, 
+0x74, 0xAB, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xD1, 0x7C, 0xE0, 0x24, 0x46, 0xF9, 0xE4, 0x34, 
+0xFC, 0xFA, 0x7B, 0x01, 0xEE, 0xD1, 0x8C, 0x12, 0x44, 0xE3, 0xD1, 0x80, 0xE0, 0x24, 0x30, 0xF9, 
+0xE4, 0x34, 0xFC, 0xFA, 0xEE, 0xD1, 0x27, 0x12, 0x44, 0xE3, 0xB1, 0xFF, 0x80, 0xB1, 0x90, 0x02, 
+0x87, 0xE0, 0x70, 0x02, 0xA1, 0xD7, 0x90, 0x80, 0xFA, 0xE0, 0x20, 0xE0, 0x02, 0xA1, 0xD7, 0xC3, 
+0x13, 0x30, 0xE0, 0x09, 0xE0, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x02, 0xA1, 0xD7, 0xE4, 0x90, 0x82, 
+0x1A, 0x12, 0x50, 0x92, 0x90, 0x81, 0x9E, 0xE0, 0xFF, 0xA3, 0xE0, 0xA3, 0xCF, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x90, 0x81, 0xA0, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xEC, 0x90, 0xFD, 0x11, 0xF0, 0x74, 0x01, 
+0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x00, 0x2D, 0x12, 0x6E, 0xE4, 
+0x7A, 0x00, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x54, 0x3F, 0x90, 0x81, 0xA2, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x74, 0x02, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x33, 0x33, 0x33, 
+0x54, 0xF8, 0x90, 0x81, 0xA5, 0xF0, 0xFC, 0x74, 0x07, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 
+0x83, 0xE0, 0x54, 0xC0, 0x90, 0x81, 0xA7, 0xF0, 0xEC, 0x24, 0x18, 0x90, 0x81, 0xA4, 0xF0, 0xFD, 
+0x90, 0x81, 0xA0, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x6D, 0x88, 0xEF, 0x54, 0xFC, 0x90, 0x81, 
+0xA6, 0xF0, 0x90, 0x81, 0xA5, 0xE0, 0x24, 0x18, 0xFF, 0xE4, 0x33, 0x90, 0x81, 0xA2, 0x8F, 0xF0, 
+0x12, 0x44, 0x9F, 0x90, 0x81, 0xA2, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x6F, 0x98, 0x90, 0x81, 
+0x9E, 0xEE, 0x8F, 0xF0, 0x12, 0x44, 0x9F, 0x90, 0x80, 0xF8, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 
+0x81, 0x9E, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xD3, 0x9F, 0xEC, 0x9E, 0x40, 0x12, 0x90, 0x80, 0xF9, 
+0x12, 0x6F, 0x01, 0xED, 0x9F, 0xFF, 0xEC, 0x9E, 0x90, 0x81, 0x9E, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
+0x81, 0x6F, 0xE0, 0x30, 0xE0, 0x09, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x02, 0xA1, 0xD0, 0x90, 
+0x80, 0xFA, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x02, 0x61, 0xDE, 0xE4, 0x90, 0x81, 0xAA, 0xF0, 0x90, 
+0x81, 0xA9, 0xF0, 0xB1, 0xE5, 0x50, 0x3A, 0x12, 0x6D, 0x60, 0xE4, 0x90, 0x81, 0xA8, 0xF0, 0xD1, 
+0x19, 0x94, 0x06, 0x50, 0x19, 0xB1, 0xD8, 0x24, 0x04, 0x12, 0x6E, 0x95, 0x90, 0x81, 0xA9, 0xE0, 
+0xD1, 0x27, 0xD1, 0xC4, 0x11, 0x02, 0xB5, 0x07, 0x05, 0x12, 0x6F, 0x40, 0x80, 0xE1, 0x90, 0x81, 
+0xA8, 0xE0, 0xB4, 0x06, 0x08, 0x90, 0x81, 0xAA, 0x74, 0x01, 0xF0, 0x80, 0x04, 0xB1, 0xFF, 0x80, 
+0xC2, 0x90, 0x81, 0xA6, 0xE0, 0x24, 0x60, 0x70, 0x02, 0x61, 0x90, 0x24, 0xFC, 0x70, 0x02, 0x61, 
+0x90, 0x24, 0xF4, 0x70, 0x02, 0x61, 0x85, 0x24, 0xF0, 0x70, 0x02, 0x61, 0x90, 0x24, 0x80, 0x60, 
+0x02, 0x61, 0xA4, 0xB1, 0xD8, 0x12, 0x6E, 0xDD, 0x60, 0x02, 0x81, 0xF6, 0xB1, 0xD8, 0x12, 0x6E, 
+0xED, 0xD1, 0x74, 0xD1, 0x14, 0x9F, 0x50, 0x0A, 0xB1, 0xD8, 0x12, 0x6F, 0x0E, 0x12, 0x6F, 0x3C, 
+0x80, 0xF1, 0x90, 0x81, 0xBF, 0xE0, 0x60, 0x7C, 0xE4, 0x90, 0x81, 0xA9, 0xF0, 0xB1, 0xE5, 0x50, 
+0x5B, 0x12, 0x6D, 0x60, 0xF1, 0x17, 0x70, 0x1B, 0xD1, 0x8B, 0x12, 0x44, 0xDA, 0xC0, 0x03, 0xC0, 
+0x02, 0xC0, 0x01, 0xD1, 0xF2, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x6F, 0xD4, 0xEF, 0x60, 
+0x02, 0x80, 0x24, 0x90, 0x81, 0xBF, 0xE0, 0x64, 0x03, 0x70, 0x27, 0xD1, 0x45, 0xD1, 0xA9, 0x70, 
+0x06, 0xD1, 0x45, 0xD1, 0xB2, 0x60, 0x17, 0xD1, 0xE3, 0xE0, 0x60, 0x02, 0x80, 0x04, 0xD1, 0x35, 
+0x60, 0x05, 0x74, 0x1A, 0x2F, 0x80, 0x0D, 0xD1, 0x06, 0x74, 0x01, 0xF0, 0x80, 0x0A, 0xD1, 0x20, 
+0x80, 0x02, 0xD1, 0x20, 0xD1, 0x0C, 0xE4, 0xF0, 0xB1, 0xFF, 0x80, 0xA1, 0x90, 0x82, 0x1A, 0xE0, 
+0x70, 0x4F, 0xA3, 0xE0, 0x70, 0x4B, 0xA3, 0xE0, 0x70, 0x47, 0xA3, 0xE0, 0x70, 0x43, 0xA3, 0xE0, 
+0x70, 0x3F, 0x81, 0xF6, 0xE4, 0x90, 0x81, 0xA9, 0xF0, 0xB1, 0xE5, 0x50, 0x1C, 0x74, 0x06, 0x2E, 
+0xD1, 0x3C, 0x60, 0x09, 0x74, 0x1A, 0x2E, 0xD1, 0x0C, 0xE4, 0xF0, 0x80, 0x08, 0x74, 0x1A, 0x2E, 
+0xD1, 0x0C, 0x74, 0x01, 0xF0, 0xB1, 0xFF, 0x80, 0xE0, 0x90, 0x82, 0x1A, 0xE0, 0x70, 0x12, 0xA3, 
+0xE0, 0x70, 0x0E, 0xA3, 0xE0, 0x70, 0x0A, 0xA3, 0xE0, 0x70, 0x06, 0xA3, 0xE0, 0x70, 0x02, 0x81, 
+0xF6, 0xE4, 0x90, 0x81, 0xA9, 0xF0, 0xB1, 0xE5, 0x40, 0x02, 0x81, 0xF6, 0x12, 0x6D, 0x60, 0xD1, 
+0x06, 0xE0, 0x60, 0x1D, 0xD1, 0xD8, 0xE0, 0x70, 0x15, 0xD1, 0x58, 0xD1, 0x19, 0x94, 0x06, 0x50, 
+0x07, 0xB1, 0xD8, 0x12, 0x6F, 0x22, 0x80, 0xF3, 0xD1, 0x9A, 0x90, 0x06, 0x35, 0xF0, 0x12, 0x47, 
+0xC6, 0xB1, 0xFF, 0x80, 0xD1, 0x90, 0x81, 0xAA, 0xE0, 0xB4, 0x01, 0x02, 0x80, 0x49, 0xA1, 0xD0, 
+0x90, 0x81, 0xAA, 0xE0, 0xB4, 0x01, 0x0B, 0x90, 0x80, 0xFA, 0x12, 0x65, 0x59, 0x30, 0xE0, 0x02, 
+0x80, 0x35, 0xA1, 0xD0, 0x90, 0x81, 0xA7, 0xE0, 0x70, 0x12, 0x90, 0x81, 0xAA, 0xE0, 0xB4, 0x01, 
+0x0B, 0x90, 0x80, 0xFA, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x02, 0xA1, 0xD0, 0xB1, 0xD8, 
+0xFD, 0x12, 0x6E, 0x9B, 0xEF, 0x70, 0x10, 0xF1, 0x04, 0x12, 0x6E, 0x13, 0xEF, 0x70, 0x08, 0xF1, 
+0x04, 0x12, 0x6D, 0xB6, 0xEF, 0x60, 0x05, 0x12, 0x5F, 0x3A, 0x01, 0xFE, 0xA1, 0xD0, 0x90, 0x81, 
+0xA6, 0xE0, 0x24, 0xC0, 0x60, 0x02, 0xA1, 0x03, 0xB1, 0xD8, 0x12, 0x6E, 0xDD, 0x60, 0x02, 0x81, 
+0xF6, 0xB1, 0xD8, 0x12, 0x6E, 0xED, 0xD1, 0x74, 0xD1, 0x14, 0x9F, 0x50, 0x0A, 0xB1, 0xD8, 0x12, 
+0x6F, 0x0E, 0x12, 0x6F, 0x3C, 0x80, 0xF1, 0x90, 0x81, 0xBF, 0xE0, 0x60, 0x7C, 0xE4, 0x90, 0x81, 
+0xA9, 0xF0, 0xB1, 0xE5, 0x50, 0x5B, 0x12, 0x6D, 0x60, 0xF1, 0x17, 0x70, 0x1B, 0xD1, 0x8B, 0x12, 
+0x44, 0xDA, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xD1, 0xF2, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 
+0x12, 0x6F, 0xD4, 0xEF, 0x60, 0x02, 0x80, 0x24, 0x90, 0x81, 0xBF, 0xE0, 0x64, 0x03, 0x70, 0x27, 
+0xD1, 0x45, 0xD1, 0xA9, 0x70, 0x06, 0xD1, 0x45, 0xD1, 0xB2, 0x60, 0x17, 0xD1, 0xE3, 0xE0, 0x60, 
+0x02, 0x80, 0x04, 0xD1, 0x35, 0x60, 0x05, 0x74, 0x1A, 0x2F, 0x80, 0x0D, 0xD1, 0x06, 0x74, 0x01, 
+0xF0, 0x80, 0x0A, 0xD1, 0x20, 0x80, 0x02, 0xD1, 0x20, 0xD1, 0x0C, 0xE4, 0xF0, 0xB1, 0xFF, 0x80, 
+0xA1, 0x90, 0x82, 0x1A, 0xE0, 0x70, 0x4D, 0xA3, 0xE0, 0x70, 0x49, 0xA3, 0xE0, 0x70, 0x45, 0xA3, 
+0xE0, 0x70, 0x41, 0xA3, 0xE0, 0x70, 0x3D, 0x80, 0x6D, 0xE4, 0x90, 0x81, 0xA9, 0xF0, 0xB1, 0xE5, 
+0x50, 0x1C, 0x74, 0x06, 0x2E, 0xD1, 0x3C, 0x60, 0x09, 0x74, 0x1A, 0x2E, 0xD1, 0x0C, 0xE4, 0xF0, 
+0x80, 0x08, 0x74, 0x1A, 0x2E, 0xD1, 0x0C, 0x74, 0x01, 0xF0, 0xB1, 0xFF, 0x80, 0xE0, 0x90, 0x82, 
+0x1A, 0xE0, 0x70, 0x10, 0xA3, 0xE0, 0x70, 0x0C, 0xA3, 0xE0, 0x70, 0x08, 0xA3, 0xE0, 0x70, 0x04, 
+0xA3, 0xE0, 0x60, 0x32, 0xE4, 0x90, 0x81, 0xA9, 0xF0, 0xB1, 0xE5, 0x50, 0x29, 0x12, 0x6D, 0x60, 
+0xD1, 0x06, 0xE0, 0x60, 0x1D, 0xD1, 0xD8, 0xE0, 0x70, 0x15, 0xD1, 0x58, 0xD1, 0x19, 0x94, 0x06, 
+0x50, 0x07, 0xB1, 0xD8, 0x12, 0x6F, 0x22, 0x80, 0xF3, 0xD1, 0x9A, 0x90, 0x06, 0x35, 0xF0, 0x12, 
+0x47, 0xC6, 0xB1, 0xFF, 0x80, 0xD3, 0xD1, 0xBB, 0x12, 0x6F, 0x8A, 0x90, 0x06, 0x36, 0x74, 0xDD, 
+0xF0, 0x01, 0xFE, 0x90, 0x81, 0xA7, 0xE0, 0x60, 0x02, 0xA1, 0xD0, 0xB1, 0xD8, 0x24, 0x16, 0xFD, 
+0x12, 0x6D, 0x88, 0x90, 0x06, 0x34, 0xEF, 0xF0, 0xB1, 0xD8, 0x24, 0x17, 0xFD, 0x12, 0x6D, 0x88, 
+0x90, 0x06, 0x37, 0xD1, 0xA1, 0xB1, 0xE5, 0x50, 0x64, 0x12, 0x6D, 0x60, 0xE4, 0x90, 0x81, 0xA8, 
+0xF0, 0x90, 0x81, 0xA8, 0xE0, 0xFF, 0xC3, 0x94, 0x06, 0x50, 0x4E, 0xEF, 0x60, 0x04, 0x64, 0x01, 
+0x70, 0x21, 0xB1, 0xD8, 0x12, 0x6E, 0xF6, 0x90, 0x81, 0xA8, 0xE0, 0xFE, 0x24, 0x44, 0xD1, 0xCE, 
+0x90, 0x81, 0xA9, 0xE0, 0xD1, 0x27, 0x12, 0x44, 0xDA, 0x8E, 0x82, 0x11, 0x02, 0xFF, 0x74, 0x46, 
+0x2E, 0xD1, 0xCE, 0xB1, 0xD8, 0x12, 0x6E, 0xF6, 0x90, 0x81, 0xA9, 0xE0, 0xFE, 0xD1, 0x27, 0xD1, 
+0xC4, 0x11, 0x02, 0x6F, 0x60, 0x0E, 0x74, 0x15, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 
+0xE4, 0xF0, 0x80, 0x05, 0x12, 0x6F, 0x40, 0x80, 0xA8, 0xB1, 0xFF, 0x80, 0x98, 0x90, 0x82, 0x15, 
+0xE0, 0x64, 0x01, 0x60, 0x17, 0xA3, 0xE0, 0x64, 0x01, 0x60, 0x11, 0xA3, 0xE0, 0x64, 0x01, 0x60, 
+0x0B, 0xA3, 0xE0, 0x64, 0x01, 0x60, 0x05, 0xA3, 0xE0, 0xB4, 0x01, 0x06, 0x90, 0x81, 0xAA, 0x74, 
+0x01, 0xF0, 0x90, 0x81, 0xAA, 0xE0, 0xB4, 0x01, 0x08, 0x12, 0x5E, 0xE4, 0x12, 0x5D, 0x08, 0x01, 
+0xFE, 0x12, 0x50, 0x8A, 0x90, 0x81, 0xA9, 0xF0, 0xB1, 0xE5, 0x50, 0x04, 0xB1, 0xF2, 0x80, 0xF8, 
+0xD1, 0xBB, 0x12, 0x6F, 0x8A, 0x01, 0xFE, 0x22, 0x90, 0x81, 0xA0, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
+0x90, 0x81, 0xA4, 0xE0, 0x22, 0x90, 0x81, 0x05, 0xE0, 0xFF, 0x90, 0x81, 0xA9, 0xE0, 0xFE, 0xC3, 
+0x9F, 0x22, 0x74, 0x15, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0x74, 0x01, 0xF0, 0x90, 
+0x81, 0xA9, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x81, 0xA9, 0xE0, 0x24, 0x1A, 0xF5, 0x82, 0xE4, 0x34, 
+0x82, 0xF5, 0x83, 0x22, 0x90, 0x81, 0xBF, 0xE0, 0xFF, 0x90, 0x81, 0xA8, 0xE0, 0xFD, 0xC3, 0x22, 
+0x90, 0x81, 0xA9, 0xE0, 0x24, 0x1A, 0x22, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xF2, 0xF5, 0x82, 0xE4, 
+0x34, 0x81, 0xF5, 0x83, 0x22, 0x90, 0x81, 0xA9, 0xE0, 0xFF, 0x24, 0x06, 0xF5, 0x82, 0xE4, 0x34, 
+0x82, 0xF5, 0x83, 0xE0, 0x22, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xC0, 0x90, 0x82, 0x22, 0x12, 0x44, 
+0xE3, 0x90, 0x82, 0x25, 0x74, 0x03, 0xF0, 0x22, 0x90, 0x81, 0xA9, 0xE0, 0x24, 0x01, 0xF5, 0x82, 
+0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFF, 0x7B, 0x08, 0x7D, 0x01, 0x12, 0x4D, 0x12, 0x90, 0x81, 
+0xA2, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0x90, 0x81, 0xA8, 0xF0, 0x22, 0xF5, 0x83, 0xEF, 0xF0, 
+0x74, 0x10, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0x22, 0xEF, 0x75, 0xF0, 0x03, 0xA4, 
+0x24, 0xB0, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 
+0x22, 0xEF, 0xF0, 0xE4, 0x90, 0x81, 0xA9, 0xF0, 0x22, 0x7A, 0x82, 0x79, 0x43, 0x12, 0x6F, 0xD4, 
+0xEF, 0x22, 0x7A, 0x82, 0x79, 0x3F, 0x12, 0x6F, 0xD4, 0xEF, 0x22, 0x90, 0x81, 0x9E, 0xE0, 0xFE, 
+0xA3, 0xE0, 0xFF, 0x22, 0x12, 0x44, 0xDA, 0x90, 0x81, 0xA8, 0xE0, 0xF5, 0x82, 0x22, 0xF5, 0x82, 
+0xE4, 0x34, 0x04, 0xF5, 0x83, 0xEF, 0xF0, 0x22, 0x7D, 0x43, 0x7F, 0xFF, 0x12, 0x4B, 0xAB, 0x90, 
+0x04, 0x1D, 0x22, 0x90, 0x81, 0xA9, 0xE0, 0xFF, 0x24, 0x0B, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 
+0x83, 0x22, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xC0, 0x90, 0x82, 0x22, 0x12, 0x44, 0xE3, 0x90, 0x82, 
+0x25, 0xED, 0xF0, 0x22, 0x90, 0x81, 0xA4, 0xE0, 0xFF, 0x90, 0x81, 0xA1, 0xE0, 0x2F, 0xFF, 0x90, 
+0x81, 0xA0, 0xE0, 0x34, 0x00, 0xFE, 0x22, 0x90, 0x81, 0xA9, 0xE0, 0xFF, 0x24, 0xAB, 0xF5, 0x82, 
+0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFE, 0x90, 0x81, 0xBF, 0xE0, 0xFD, 0xEE, 0x6D, 0x22, 0xE0, 
+0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x22, 0x90, 0x04, 0x24, 0xEF, 0xF0, 0x22, 0x90, 0x81, 
+0x05, 0xE0, 0xFD, 0x7C, 0x00, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x20, 0x30, 0xED, 0x4C, 
+0x70, 0x05, 0x90, 0x81, 0x12, 0x80, 0x2A, 0xED, 0x64, 0x01, 0x4C, 0x70, 0x05, 0x90, 0x81, 0x13, 
+0x80, 0x1F, 0xED, 0x64, 0x02, 0x4C, 0x70, 0x05, 0x90, 0x81, 0x14, 0x80, 0x14, 0xED, 0x64, 0x03, 
+0x4C, 0x70, 0x05, 0x90, 0x81, 0x15, 0x80, 0x09, 0xED, 0x64, 0x04, 0x4C, 0x70, 0x0D, 0x90, 0x81, 
+0x16, 0xE0, 0xFF, 0xF1, 0x38, 0x90, 0x81, 0x06, 0x12, 0x52, 0x62, 0x22, 0xE0, 0x90, 0x01, 0xBA, 
+0xF0, 0x90, 0x81, 0x2D, 0xE0, 0x90, 0x01, 0xBB, 0x22, 0x90, 0x81, 0x27, 0xE0, 0x13, 0x13, 0x13, 
+0x54, 0x1F, 0x22, 0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xEF, 0x13, 
+0x13, 0x13, 0x54, 0x1F, 0xFE, 0xEF, 0x54, 0x07, 0x22, 0x7F, 0x0A, 0x7E, 0x00, 0x02, 0x32, 0xAA, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xF1, 0xCA,  
 };
-u4Byte ArrayLength_MP_8188E_FW_AP = 15226;
+u4Byte ArrayLength_MP_8188E_FW_AP = 14314;
 
 
 void
@@ -997,126 +940,14 @@ ODM_ReadFirmware_MP_8188E_FW_AP(
 #else
 
 
-u1Byte Array_MP_8188E_FW_NIC_S[] = {
-0xE2, 0x88, 0x10, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x02, 0x22, 0x10, 0x14, 0xF6, 0x3D, 0x02, 0x00, 
-0xCD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x02, 0x4B, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x02, 0x4C, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x02, 0x4B, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x50, 0x15, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+u1Byte Array_MP_8188E_FW_NIC[] = {
+0xE1, 0x88, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x09, 0x11, 0x20, 0x12, 0x0A, 0x38, 0x00, 0x00, 
+0xEE, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x45, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0xC1, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0xC1, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0xFC, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
@@ -1128,898 +959,915 @@ u1Byte Array_MP_8188E_FW_NIC_S[] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x48, 0x04, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x41, 0x04, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
 0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
-0xEC, 0x24, 0x89, 0xF8, 0xE6, 0xBC, 0x03, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
-0x40, 0xCE, 0x79, 0x04, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
 0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
-0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x04, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
-0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x88, 0x25, 0x0C, 0xF8, 
-0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x03, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
 0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
-0x0C, 0x24, 0x89, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x03, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
-0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x88, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
 0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
 0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
-0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x88, 0xA6, 
-0x81, 0x74, 0x03, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x04, 0xE4, 0x78, 0x80, 
-0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x4B, 0xDE, 0x74, 0x01, 0x93, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x46, 0x08, 0x74, 0x01, 0x93, 
 0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
-0x8C, 0xD2, 0xAF, 0x22, 0x03, 0xEF, 0xD3, 0x94, 0x03, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
 0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
-0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x88, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
-0xBE, 0x03, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
 0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
-0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x88, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
 0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
-0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x88, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
-0x04, 0x90, 0x4B, 0xDE, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
-0x94, 0x03, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
-0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x88, 0x2F, 
-0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x48, 0x4D, 0x50, 0x2E, 0x74, 0x89, 0x2F, 0xF8, 0xE6, 0xBF, 0x03, 
-0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x88, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x46, 0x08, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x41, 0x4D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
 0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
-0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x89, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
-0x0F, 0x74, 0x88, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
 0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
-0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x03, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
-0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x48, 0x4C, 0x8F, 0xF0, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x41, 0x4C, 0x8F, 0xF0, 
 0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
 0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x30, 0x50, 0x2E, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
 0x60, 0x25, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x23, 0x0E, 0x30, 
 0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x12, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x13, 0x54, 0xEC, 
-0x4E, 0xF6, 0xD2, 0xAF, 0x02, 0x48, 0x4D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 0xC2, 0xAF, 
-0x56, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0xC5, 0xF0, 0xF8, 0xA3, 0xE0, 0x28, 0xF0, 
-0xC5, 0xF0, 0xF8, 0xE5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 0x83, 0xE0, 0x38, 0xF0, 0x22, 0xEF, 
-0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 0xED, 0x59, 0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 
-0x4A, 0xFE, 0xED, 0x49, 0xFD, 0xEC, 0x48, 0xFC, 0x22, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 
-0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xE2, 0xFC, 0x08, 0xE2, 0xFD, 0x08, 0xE2, 0xFE, 0x08, 0xE2, 0xFF, 
-0x22, 0xE2, 0xFB, 0x08, 0xE2, 0xF9, 0x08, 0xE2, 0xFA, 0x08, 0xE2, 0xCB, 0xF8, 0x22, 0xEC, 0xF2, 
-0x08, 0xED, 0xF2, 0x08, 0xEE, 0xF2, 0x08, 0xEF, 0xF2, 0x22, 0xA4, 0x25, 0x82, 0xF5, 0x82, 0xE5, 
-0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 
-0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 
-0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 
-0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0x02, 0x4B, 
-0x8C, 0x02, 0x48, 0xDD, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 
-0xF2, 0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 
-0x33, 0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 
-0xDF, 0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x4B, 0xD1, 0xE4, 
-0x7E, 0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 
-0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 
-0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 
-0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 
-0xBE, 0x00, 0x41, 0x82, 0x12, 0x00, 0x41, 0x82, 0x13, 0x00, 0x41, 0x82, 0x1F, 0x00, 0x58, 0xF0, 
-0x5F, 0xDD, 0x69, 0x7E, 0x6A, 0xC2, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 
-0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 
-0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xE6, 0xF0, 0x74, 0x4B, 0xA3, 0xF0, 0x91, 0x35, 0x74, 
-0xE6, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x4B, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 
-0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 
-0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x00, 0x54, 0xE0, 0x55, 0x35, 0xF5, 0x39, 0xA3, 0xE0, 0x55, 
-0x36, 0xF5, 0x3A, 0xA3, 0xE0, 0x55, 0x37, 0xF5, 0x3B, 0xA3, 0xE0, 0x55, 0x38, 0xF5, 0x3C, 0xAD, 
-0x39, 0x7F, 0x54, 0x12, 0x32, 0x1E, 0xAD, 0x3A, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0xAD, 0x3B, 0x7F, 
-0x56, 0x12, 0x32, 0x1E, 0xAD, 0x3C, 0x7F, 0x57, 0x12, 0x32, 0x1E, 0x53, 0x91, 0xEF, 0x22, 0xC0, 
-0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 
-0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 
-0x6F, 0xF0, 0x74, 0x4C, 0xA3, 0xF0, 0x12, 0x72, 0x41, 0xE5, 0x41, 0x30, 0xE4, 0x04, 0x7F, 0x02, 
-0x51, 0x27, 0xE5, 0x41, 0x30, 0xE6, 0x02, 0xF1, 0xEF, 0xE5, 0x43, 0x30, 0xE0, 0x03, 0x12, 0x72, 
-0x9E, 0xE5, 0x43, 0x30, 0xE1, 0x03, 0x12, 0x54, 0x43, 0xE5, 0x43, 0x30, 0xE2, 0x03, 0x12, 0x53, 
-0xF7, 0xE5, 0x43, 0x30, 0xE3, 0x03, 0x12, 0x6F, 0xB0, 0xE5, 0x43, 0x30, 0xE4, 0x03, 0x12, 0x74, 
-0xA9, 0xE5, 0x43, 0x30, 0xE5, 0x03, 0x12, 0x6F, 0x58, 0xE5, 0x43, 0x30, 0xE6, 0x02, 0xB1, 0x0E, 
-0xE5, 0x44, 0x30, 0xE1, 0x03, 0x12, 0x74, 0xD8, 0x74, 0x6F, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 
-0x4C, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 
-0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x80, 
-0xDE, 0xE0, 0xB4, 0x01, 0x13, 0x90, 0x81, 0x27, 0xE0, 0x60, 0x0D, 0x90, 0x81, 0x2B, 0xE0, 0x54, 
-0xFE, 0xF0, 0x54, 0x07, 0x70, 0x02, 0xB1, 0x29, 0x22, 0x90, 0x81, 0x1F, 0xE0, 0x90, 0x81, 0x29, 
-0x30, 0xE0, 0x04, 0xE0, 0xFF, 0xE1, 0x6E, 0xE0, 0xFF, 0x7D, 0x01, 0x80, 0x04, 0xE4, 0xFD, 0x7F, 
-0x0C, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x1D, 0xED, 0xF0, 0x90, 0x81, 0x24, 
-0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0xC1, 0x8E, 0xEE, 0xC4, 0x13, 0x13, 
-0x13, 0x54, 0x01, 0x30, 0xE0, 0x02, 0xC1, 0x8E, 0x90, 0x81, 0x2A, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 
-0xC1, 0x8E, 0xEF, 0x70, 0x02, 0xC1, 0x03, 0x24, 0xFE, 0x70, 0x02, 0xC1, 0x3D, 0x24, 0xFE, 0x60, 
-0x4A, 0x24, 0xFC, 0x70, 0x02, 0xC1, 0x78, 0x24, 0xFC, 0x60, 0x02, 0xC1, 0x8E, 0xEE, 0xB4, 0x0E, 
-0x02, 0xF1, 0x39, 0x90, 0x81, 0x2A, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0xF1, 0x1B, 0x90, 0x81, 0x2A, 
-0xE0, 0xB4, 0x06, 0x02, 0xD1, 0xE8, 0x90, 0x81, 0x2A, 0xE0, 0xB4, 0x04, 0x0F, 0x90, 0x82, 0x1D, 
-0xE0, 0xFF, 0x60, 0x05, 0x12, 0x7A, 0xBA, 0x80, 0x03, 0x12, 0x5F, 0xB4, 0x90, 0x81, 0x2A, 0xE0, 
-0x64, 0x08, 0x60, 0x02, 0xC1, 0x8E, 0x12, 0x5B, 0xEB, 0xC1, 0x8E, 0x90, 0x81, 0x2A, 0xE0, 0x70, 
-0x04, 0x7F, 0x01, 0xF1, 0x1B, 0x90, 0x81, 0x2A, 0xE0, 0xB4, 0x06, 0x02, 0xD1, 0xE8, 0x90, 0x81, 
-0x2A, 0xE0, 0xB4, 0x0E, 0x07, 0xD1, 0x93, 0xBF, 0x01, 0x02, 0xF1, 0x39, 0x90, 0x81, 0x2A, 0xE0, 
-0x64, 0x0C, 0x60, 0x02, 0xC1, 0x8E, 0xD1, 0x93, 0xEF, 0x64, 0x01, 0x60, 0x02, 0xC1, 0x8E, 0xF1, 
-0x8D, 0xC1, 0x8E, 0x90, 0x81, 0x2A, 0xE0, 0xB4, 0x0E, 0x07, 0xD1, 0x93, 0xBF, 0x01, 0x02, 0xF1, 
-0x39, 0x90, 0x81, 0x2A, 0xE0, 0xB4, 0x06, 0x02, 0xD1, 0xE8, 0x90, 0x81, 0x2A, 0xE0, 0xB4, 0x0C, 
-0x07, 0xD1, 0x93, 0xBF, 0x01, 0x02, 0xF1, 0x8D, 0x90, 0x81, 0x2A, 0xE0, 0x64, 0x04, 0x70, 0x5E, 
-0x12, 0x7A, 0x0C, 0xEF, 0x64, 0x01, 0x70, 0x56, 0x12, 0x5D, 0x5A, 0x80, 0x51, 0x90, 0x81, 0x2A, 
-0xE0, 0xB4, 0x0E, 0x07, 0xD1, 0x93, 0xBF, 0x01, 0x02, 0xF1, 0x39, 0x90, 0x81, 0x2A, 0xE0, 0xB4, 
-0x06, 0x02, 0xD1, 0xE8, 0x90, 0x81, 0x2A, 0xE0, 0xB4, 0x0C, 0x07, 0xD1, 0x93, 0xBF, 0x01, 0x02, 
-0xF1, 0x8D, 0x90, 0x81, 0x2A, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0xF1, 0x1B, 0x90, 0x81, 0x2A, 0xE0, 
-0xB4, 0x04, 0x1B, 0x12, 0x7B, 0x00, 0x80, 0x16, 0x90, 0x81, 0x2A, 0xE0, 0xB4, 0x0C, 0x0F, 0x90, 
-0x81, 0x25, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x03, 0x12, 0x5F, 0x55, 0xD0, 0xD0, 
-0x92, 0xAF, 0x22, 0xF1, 0xFC, 0xEF, 0x64, 0x01, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 
-0x80, 0x3D, 0x90, 0x81, 0x24, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x08, 0x90, 
-0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x28, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x08, 0x90, 0x01, 
-0xB8, 0x74, 0x04, 0xF0, 0x80, 0x19, 0x90, 0x81, 0x29, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x08, 0x90, 
-0x01, 0xB8, 0x74, 0x08, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 
-0x01, 0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x81, 0x25, 0xE0, 0x90, 0x06, 0x04, 0x20, 
-0xE0, 0x0C, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x81, 0x2A, 0x74, 0x04, 0xF0, 0x80, 0x17, 0xE0, 0x54, 
-0x7F, 0xF0, 0x90, 0x81, 0x2A, 0x74, 0x0C, 0xF0, 0x90, 0x05, 0x27, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 
-0x81, 0x23, 0x74, 0x0C, 0xF0, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x22, 0x90, 0x82, 0x1C, 0xEF, 0xF0, 
-0x12, 0x5B, 0xFD, 0x90, 0x82, 0x1C, 0xE0, 0x60, 0x05, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x90, 0x81, 
-0x2A, 0x74, 0x04, 0xF0, 0x90, 0x81, 0x23, 0xF0, 0x22, 0x90, 0x81, 0x25, 0xE0, 0xC3, 0x13, 0x20, 
-0xE0, 0x08, 0x90, 0x81, 0x2A, 0x74, 0x0C, 0xF0, 0x80, 0x1E, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 
-0xF0, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x81, 0x2A, 0x74, 0x04, 0xF0, 0x90, 0x05, 0x27, 0xE0, 0x44, 
-0x80, 0xF0, 0x90, 0x81, 0x23, 0x74, 0x04, 0xF0, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x22, 0xAE, 0x07, 
-0xF1, 0xE3, 0xBF, 0x01, 0x15, 0x90, 0x81, 0x1F, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 
-0x09, 0xAF, 0x06, 0x7D, 0x01, 0xB1, 0x41, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x90, 0x80, 0xDE, 
-0xE0, 0x64, 0x01, 0x70, 0x32, 0x90, 0x81, 0x25, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x05, 0x22, 0x74, 
-0x6F, 0xF0, 0x7F, 0x01, 0x12, 0x56, 0xA8, 0xBF, 0x01, 0x12, 0x90, 0x81, 0x24, 0xE0, 0x44, 0x80, 
-0xF0, 0x90, 0x81, 0x2A, 0x74, 0x0E, 0xF0, 0x90, 0x81, 0x23, 0xF0, 0x22, 0x90, 0x01, 0xB9, 0x74, 
-0x01, 0xF0, 0x90, 0x01, 0xB8, 0x04, 0xF0, 0x22, 0x90, 0x81, 0x27, 0xE0, 0x64, 0x02, 0x60, 0x12, 
-0x90, 0x81, 0x26, 0xE0, 0x54, 0x0F, 0x60, 0x0A, 0xF1, 0xFC, 0xEF, 0x70, 0x05, 0xFD, 0x7F, 0x0C, 
-0xB1, 0x41, 0x22, 0x90, 0x05, 0x43, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0x90, 
-0x81, 0x1F, 0xE0, 0x30, 0xE0, 0x05, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x04, 0x1A, 0xE0, 
-0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 
-0x60, 0x02, 0x7F, 0x00, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 
-0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 
-0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x15, 0xF0, 0x74, 0x50, 0xA3, 0xF0, 0x12, 0x72, 0x6E, 0xE5, 
-0x49, 0x30, 0xE1, 0x02, 0x11, 0xC5, 0xE5, 0x49, 0x30, 0xE2, 0x03, 0x12, 0x75, 0x58, 0xE5, 0x49, 
-0x30, 0xE3, 0x03, 0x12, 0x75, 0x94, 0xE5, 0x4A, 0x30, 0xE0, 0x03, 0x12, 0x75, 0xD0, 0xE5, 0x4A, 
-0x30, 0xE4, 0x03, 0x12, 0x76, 0x6F, 0xE5, 0x4B, 0x30, 0xE1, 0x03, 0x12, 0x73, 0x3B, 0xE5, 0x4B, 
-0x30, 0xE0, 0x03, 0x12, 0x72, 0xF5, 0xE5, 0x4B, 0x30, 0xE3, 0x03, 0x12, 0x76, 0x85, 0xE5, 0x4C, 
-0x30, 0xE1, 0x05, 0x7F, 0x03, 0x12, 0x4A, 0x27, 0xE5, 0x4C, 0x30, 0xE4, 0x02, 0x11, 0xD9, 0xE5, 
-0x4C, 0x30, 0xE5, 0x03, 0x12, 0x76, 0x86, 0xE5, 0x4C, 0x30, 0xE6, 0x03, 0x12, 0x77, 0x1C, 0x74, 
-0x15, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x50, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 
-0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 
-0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x81, 0x27, 0xE0, 0x60, 0x03, 0x12, 0x7B, 0x98, 0x90, 0x81, 
-0x40, 0xE0, 0x30, 0xE0, 0x03, 0x12, 0x5C, 0xEA, 0x22, 0x12, 0x7B, 0x33, 0x90, 0x81, 0x2D, 0xE0, 
-0x14, 0x90, 0x05, 0x73, 0xF0, 0x7D, 0x02, 0x7F, 0x02, 0x31, 0x31, 0x91, 0xBC, 0x90, 0x81, 0x42, 
-0xE0, 0x30, 0xE0, 0x33, 0x90, 0x81, 0x44, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x90, 0x81, 0x45, 0xE0, 
-0x60, 0x05, 0x14, 0xF0, 0x02, 0x5F, 0x55, 0x90, 0x81, 0x43, 0xE0, 0x14, 0x90, 0x81, 0x45, 0xF0, 
-0x90, 0x05, 0x73, 0x74, 0x01, 0xF0, 0xE4, 0xFF, 0x12, 0x5B, 0xBB, 0x7D, 0x02, 0x7F, 0x02, 0x31, 
-0x31, 0x7D, 0x01, 0x7F, 0x02, 0x31, 0x31, 0x22, 0x90, 0x01, 0x34, 0x74, 0x40, 0xF0, 0xFD, 0xE4, 
-0xFF, 0x74, 0x3D, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
-0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x05, 0x27, 
-0xE0, 0x90, 0x81, 0xD0, 0xF0, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x81, 0x1F, 0xE0, 
-0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 
-0x1F, 0xA4, 0xFE, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 0xFF, 0x90, 0x81, 0x1F, 0xF0, 0xEE, 
-0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x10, 0xFD, 
-0xEF, 0x54, 0xEF, 0x4D, 0xFF, 0x90, 0x81, 0x1F, 0xF0, 0xEE, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 
-0x4E, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 0x4D, 0x90, 0x81, 
-0x1F, 0xF0, 0xEE, 0xC3, 0x13, 0x20, 0xE0, 0x02, 0x41, 0x77, 0xE0, 0xFF, 0x20, 0xE0, 0x02, 0x41, 
-0x5E, 0x90, 0x81, 0xD0, 0x74, 0x21, 0xF0, 0xEF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x0B, 0x31, 
-0x28, 0x90, 0x81, 0xD0, 0xE0, 0x44, 0x08, 0xF0, 0x80, 0x0C, 0xE4, 0x90, 0x81, 0x20, 0xF0, 0xA3, 
-0xF0, 0x7D, 0x40, 0xFF, 0x71, 0x5C, 0x90, 0x81, 0x1F, 0xE0, 0xFD, 0x13, 0x13, 0x13, 0x54, 0x1F, 
-0x30, 0xE0, 0x07, 0x90, 0x81, 0xD0, 0xE0, 0x44, 0x12, 0xF0, 0xED, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 
-0x07, 0x90, 0x81, 0xD0, 0xE0, 0x44, 0x14, 0xF0, 0x90, 0x81, 0x1F, 0xE0, 0xC4, 0x13, 0x54, 0x07, 
-0x30, 0xE0, 0x07, 0x90, 0x81, 0xD0, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x81, 0x1F, 0xE0, 0xC4, 0x13, 
-0x13, 0x54, 0x03, 0x30, 0xE0, 0x07, 0x90, 0x81, 0xD0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x81, 0xD0, 
-0xE0, 0x90, 0x05, 0x27, 0xF0, 0x90, 0x81, 0x22, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0xB1, 0xA3, 0x90, 
-0x81, 0x1F, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x04, 0x7F, 0x04, 0x80, 0x23, 
-0x12, 0x4F, 0xE3, 0xEF, 0x60, 0x04, 0x7F, 0x01, 0x80, 0x19, 0x7F, 0x02, 0x80, 0x15, 0x90, 0x81, 
-0xD0, 0x74, 0x01, 0xF0, 0x90, 0x05, 0x27, 0xF0, 0x90, 0x81, 0x22, 0xE0, 0x64, 0x04, 0x60, 0x02, 
-0x61, 0x4D, 0xFF, 0xB1, 0xA3, 0x61, 0x4D, 0x90, 0x81, 0x1F, 0xE0, 0xFD, 0x20, 0xE0, 0x02, 0x61, 
-0x18, 0x90, 0x81, 0xD0, 0xE0, 0x44, 0x31, 0xF0, 0xED, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x0B, 
-0x31, 0x28, 0x90, 0x81, 0xD0, 0xE0, 0x44, 0x08, 0xF0, 0x80, 0x06, 0x7D, 0x40, 0xE4, 0xFF, 0x71, 
-0x5C, 0x90, 0x81, 0x1F, 0xE0, 0xFD, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x07, 0x90, 0x81, 
-0xD0, 0xE0, 0x44, 0x02, 0xF0, 0xED, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x07, 0x90, 0x81, 0xD0, 0xE0, 
-0x44, 0x04, 0xF0, 0x90, 0x81, 0xD0, 0xE0, 0x90, 0x05, 0x27, 0xF0, 0x90, 0x81, 0x1F, 0xE0, 0xFF, 
-0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x0E, 0x90, 0x81, 0x23, 0xE0, 0x64, 0x02, 0x60, 0x6D, 
-0xE4, 0xFD, 0x7F, 0x02, 0x80, 0x23, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x81, 0x23, 
-0xE0, 0xB4, 0x02, 0x1A, 0x12, 0x7B, 0x1A, 0x12, 0x4F, 0xE3, 0xBF, 0x01, 0x09, 0x90, 0x81, 0x29, 
-0xE0, 0xFF, 0x7D, 0x01, 0x80, 0x03, 0xE4, 0xFD, 0xFF, 0x12, 0x4D, 0x41, 0x80, 0x3F, 0x90, 0x81, 
-0x2A, 0xE0, 0x90, 0x81, 0x23, 0xF0, 0x80, 0x35, 0x90, 0x81, 0xD0, 0x74, 0x01, 0xF0, 0x90, 0x05, 
-0x27, 0xF0, 0x90, 0x81, 0x23, 0xE0, 0xB4, 0x02, 0x06, 0x7D, 0x01, 0x7F, 0x04, 0x80, 0x0B, 0x90, 
-0x81, 0x23, 0xE0, 0xB4, 0x08, 0x07, 0x7D, 0x01, 0x7F, 0x0C, 0x12, 0x4D, 0x41, 0x12, 0x75, 0x4F, 
-0x90, 0x81, 0x29, 0xE0, 0xFF, 0x7D, 0x01, 0x12, 0x4D, 0x41, 0x12, 0x5A, 0x64, 0xD0, 0xD0, 0x92, 
-0xAF, 0x22, 0x7D, 0x02, 0x7F, 0x02, 0x71, 0x5C, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x3D, 0x2F, 0xF8, 
-0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 
-0x83, 0xEE, 0xF0, 0x22, 0xEF, 0x70, 0x37, 0x7D, 0x78, 0x7F, 0x02, 0x71, 0x5C, 0x7D, 0x02, 0x7F, 
-0x03, 0x71, 0x5C, 0x7D, 0xC8, 0x7F, 0x02, 0x12, 0x77, 0xE2, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 
-0x01, 0x3C, 0x74, 0x02, 0xF0, 0x7D, 0x01, 0x7F, 0x0C, 0x12, 0x4D, 0x41, 0x90, 0x81, 0x24, 0xE0, 
-0x54, 0xF7, 0xF0, 0x54, 0xEF, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 0x90, 0x01, 
-0x36, 0x74, 0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x31, 0x31, 0x7D, 0x02, 0x7F, 
-0x03, 0x31, 0x31, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0xF0, 0x90, 0x81, 0x32, 0xA3, 0xE0, 0x90, 
-0x05, 0x58, 0xF0, 0x90, 0x80, 0xDE, 0xE0, 0xB4, 0x01, 0x15, 0x90, 0x81, 0x25, 0xE0, 0x54, 0xFB, 
-0xF0, 0x90, 0x81, 0x2A, 0xE0, 0x20, 0xE2, 0x0E, 0x7D, 0x01, 0x7F, 0x04, 0x02, 0x4D, 0x41, 0x90, 
-0x81, 0x25, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x90, 0x81, 0x1F, 0xE0, 0xFF, 0x30, 0xE0, 0x08, 0x90, 
-0x81, 0x23, 0xE0, 0x64, 0x02, 0x60, 0x3B, 0x90, 0x81, 0x27, 0xE0, 0x70, 0x04, 0xEF, 0x30, 0xE0, 
-0x0A, 0x90, 0x81, 0x2A, 0xE0, 0x64, 0x02, 0x60, 0x29, 0x91, 0xF1, 0x90, 0x81, 0x25, 0xE0, 0x13, 
-0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x15, 0x90, 0x81, 0x2D, 0xE0, 0xFF, 0xA3, 0xE0, 0x6F, 0x70, 
-0x0B, 0x12, 0x77, 0xBE, 0x71, 0x52, 0x90, 0x81, 0x2E, 0xE0, 0x14, 0xF0, 0x90, 0x01, 0xE6, 0xE0, 
-0x04, 0xF0, 0x22, 0x90, 0x81, 0x1F, 0xE0, 0x30, 0xE0, 0x06, 0x90, 0x81, 0x21, 0x74, 0x01, 0xF0, 
-0x90, 0x81, 0x27, 0xE0, 0x60, 0x45, 0x90, 0x81, 0x25, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 
-0x30, 0xE0, 0x12, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x0B, 0x71, 0x52, 0x90, 0x81, 0x2D, 0xE0, 
-0x14, 0x90, 0x05, 0x73, 0xF0, 0x90, 0x82, 0x14, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x4A, 0xA9, 0xC3, 
-0x90, 0x82, 0x15, 0xE0, 0x94, 0x80, 0x90, 0x82, 0x14, 0xE0, 0x64, 0x80, 0x94, 0x80, 0x40, 0x0B, 
-0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0x7D, 0xBE, 0x91, 0xBC, 
-0x12, 0x6F, 0x96, 0x90, 0x81, 0x42, 0xE0, 0x30, 0xE0, 0x11, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 
-0x0A, 0x71, 0x52, 0x90, 0x81, 0x44, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 0x90, 0x81, 0x47, 0xE0, 
-0x30, 0xE0, 0x2D, 0x90, 0x80, 0xDE, 0xE0, 0xB4, 0x01, 0x26, 0x90, 0x82, 0x1F, 0xE0, 0x04, 0xF0, 
-0xE0, 0xB4, 0x0A, 0x0B, 0x90, 0x81, 0x49, 0xE0, 0x04, 0xF0, 0xE4, 0x90, 0x82, 0x1F, 0xF0, 0x90, 
-0x81, 0x49, 0xE0, 0xFF, 0x90, 0x81, 0x48, 0xE0, 0xB5, 0x07, 0x05, 0xE4, 0xA3, 0xF0, 0xD1, 0xA6, 
-0x22, 0x90, 0x80, 0xDE, 0xE0, 0x64, 0x01, 0x60, 0x02, 0xA1, 0x92, 0x90, 0x81, 0x27, 0xE0, 0x70, 
-0x02, 0xA1, 0x92, 0x90, 0x81, 0x26, 0xE0, 0xC4, 0x54, 0x0F, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 
-0xAB, 0xE0, 0x90, 0x81, 0x2E, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 0x90, 0x81, 0x2D, 0xF0, 0xA3, 0xE0, 
-0xFF, 0x70, 0x08, 0x90, 0x81, 0x2D, 0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 0x81, 0x2E, 0xEF, 0xF0, 
-0x90, 0x81, 0x25, 0xE0, 0x44, 0x04, 0xF0, 0xE4, 0x90, 0x81, 0x30, 0xF0, 0x90, 0x81, 0x32, 0xA3, 
-0xE0, 0x90, 0x05, 0x58, 0xF0, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 
-0x90, 0x81, 0x2B, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0xEF, 0xF0, 0x90, 0x81, 0x26, 0xE0, 0xFF, 0xC4, 
-0x54, 0x0F, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x0F, 0x90, 0x81, 0x1F, 0xE0, 0x30, 0xE0, 0x05, 0x12, 
-0x6E, 0xB1, 0x80, 0x03, 0x12, 0x6D, 0xFF, 0x90, 0x81, 0x25, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 
-0x30, 0xE0, 0x0F, 0x90, 0x81, 0x2D, 0xE0, 0xFF, 0xA3, 0xE0, 0xB5, 0x07, 0x05, 0x12, 0x77, 0xBE, 
-0x71, 0x58, 0x90, 0x81, 0x1F, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x07, 0x90, 0x81, 0x25, 0xE0, 0x44, 
-0x04, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x22, 0xE0, 0x90, 0x82, 
-0x1E, 0xF0, 0x6F, 0x70, 0x02, 0xC1, 0xA1, 0xEF, 0x14, 0x60, 0x40, 0x14, 0x60, 0x68, 0x14, 0x70, 
-0x02, 0xC1, 0x53, 0x14, 0x70, 0x02, 0xC1, 0x7B, 0x24, 0x04, 0x60, 0x02, 0xC1, 0xA1, 0x90, 0x82, 
-0x1E, 0xE0, 0xFF, 0xB4, 0x04, 0x05, 0x12, 0x7C, 0x16, 0xC1, 0xA1, 0xEF, 0xB4, 0x02, 0x04, 0xF1, 
-0xE3, 0xC1, 0xA1, 0x90, 0x82, 0x1E, 0xE0, 0xFF, 0xB4, 0x03, 0x05, 0x12, 0x7C, 0x3A, 0xC1, 0xA1, 
-0xEF, 0x64, 0x01, 0x60, 0x02, 0xC1, 0xA1, 0xF1, 0xE5, 0xC1, 0xA1, 0x90, 0x82, 0x1E, 0xE0, 0xFF, 
-0xB4, 0x04, 0x05, 0x12, 0x7C, 0x03, 0xC1, 0xA1, 0xEF, 0xB4, 0x02, 0x04, 0xF1, 0xD5, 0xC1, 0xA1, 
-0x90, 0x82, 0x1E, 0xE0, 0xFF, 0xB4, 0x03, 0x05, 0x12, 0x7C, 0x2F, 0xC1, 0xA1, 0xEF, 0x60, 0x02, 
-0xC1, 0xA1, 0xF1, 0xA9, 0x80, 0x7B, 0x90, 0x82, 0x1E, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0x5F, 0x92, 
-0x80, 0x6F, 0x90, 0x82, 0x1E, 0xE0, 0xB4, 0x01, 0x04, 0xF1, 0x9B, 0x80, 0x64, 0x90, 0x82, 0x1E, 
-0xE0, 0xB4, 0x03, 0x05, 0x12, 0x5F, 0x4C, 0x80, 0x58, 0x90, 0x82, 0x1E, 0xE0, 0x70, 0x52, 0xF1, 
-0xA5, 0x80, 0x4E, 0x90, 0x82, 0x1E, 0xE0, 0xFF, 0xB4, 0x04, 0x05, 0x12, 0x7C, 0x1B, 0x80, 0x41, 
-0xEF, 0xB4, 0x01, 0x04, 0xF1, 0xC8, 0x80, 0x39, 0xEF, 0xB4, 0x02, 0x05, 0x12, 0x5F, 0x43, 0x80, 
-0x30, 0x90, 0x82, 0x1E, 0xE0, 0x70, 0x2A, 0xF1, 0xC6, 0x80, 0x26, 0x90, 0x82, 0x1E, 0xE0, 0xFF, 
-0xB4, 0x03, 0x05, 0x12, 0x7C, 0x3F, 0x80, 0x19, 0xEF, 0xB4, 0x01, 0x04, 0xF1, 0xB2, 0x80, 0x11, 
-0xEF, 0xB4, 0x02, 0x05, 0x12, 0x5F, 0xC7, 0x80, 0x08, 0x90, 0x82, 0x1E, 0xE0, 0x70, 0x02, 0xF1, 
-0xB0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 
-0x53, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x1F, 0x90, 0x05, 0x22, 0xE0, 0xF5, 0x56, 0x74, 0xFF, 0xF0, 
-0x12, 0x5D, 0x7A, 0xBF, 0x01, 0x08, 0xAF, 0x53, 0x12, 0x7C, 0xFF, 0x12, 0x7C, 0x60, 0x90, 0x05, 
-0x22, 0xE5, 0x56, 0xF0, 0x80, 0x03, 0x12, 0x7C, 0x60, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x7F, 
-0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
-0xE0, 0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x1D, 0x74, 0x21, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
-0x83, 0xE0, 0x44, 0x10, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
-0x44, 0x80, 0xF0, 0x22, 0x74, 0x21, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 
-0xEF, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x40, 0xF0, 
-0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x17, 0xED, 0xF0, 0x90, 0x82, 0x16, 
-0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x12, 0x7D, 0x4C, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0x82, 0x16, 0xE0, 
-0x90, 0x04, 0x25, 0xF0, 0x90, 0x82, 0x17, 0xE0, 0x60, 0x0E, 0x74, 0x0F, 0x2F, 0xF5, 0x82, 0xE4, 
-0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x08, 0x2F, 0xF5, 0x82, 0xE4, 
-0x34, 0xFC, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x09, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
-0xE0, 0x54, 0xF0, 0xF0, 0x74, 0x21, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 
-0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x5C, 0xEA, 0x90, 0x81, 
-0x22, 0x74, 0x02, 0xF0, 0x22, 0xF1, 0xA9, 0x80, 0xF2, 0x90, 0x81, 0x22, 0x74, 0x01, 0xF0, 0x22, 
-0xF1, 0xA9, 0x90, 0x05, 0x22, 0x74, 0x6F, 0xF0, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 
-0x81, 0x22, 0x74, 0x04, 0xF0, 0x22, 0xF1, 0xA9, 0x90, 0x05, 0x22, 0x74, 0xFF, 0xF0, 0x90, 0x81, 
-0x22, 0x74, 0x03, 0xF0, 0x22, 0x12, 0x5B, 0xFD, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x90, 0x81, 0x22, 
-0x04, 0xF0, 0x22, 0xF1, 0xD5, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0xE4, 0x90, 0x81, 0x22, 
-0xF0, 0x22, 0x90, 0x01, 0xC8, 0xE4, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0x81, 0x79, 
-0x56, 0x7F, 0xFF, 0xFE, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x09, 0x90, 0x81, 0x56, 0xE0, 0x64, 0x03, 
-0x60, 0x03, 0x22, 0x01, 0xB4, 0xE4, 0x90, 0x81, 0x5B, 0xF0, 0x90, 0x81, 0x5B, 0xE0, 0xFF, 0xC3, 
-0x94, 0x02, 0x40, 0x02, 0x01, 0xEF, 0xC3, 0x74, 0xFE, 0x9F, 0xFF, 0xE4, 0x94, 0x00, 0xFE, 0x7B, 
-0x01, 0x7A, 0x81, 0x79, 0x57, 0x12, 0x2B, 0x27, 0xEF, 0x64, 0x01, 0x70, 0x77, 0x90, 0x81, 0x57, 
-0xE0, 0xFF, 0x54, 0xC0, 0xFE, 0x60, 0x05, 0xEF, 0x54, 0x0C, 0x70, 0x16, 0x90, 0x81, 0x57, 0xE0, 
-0xFF, 0x54, 0x30, 0x60, 0x67, 0xEF, 0x54, 0x03, 0x60, 0x62, 0x90, 0x81, 0x58, 0x74, 0x01, 0xF0, 
-0x80, 0x05, 0xE4, 0x90, 0x81, 0x58, 0xF0, 0x90, 0x81, 0x58, 0xE0, 0x90, 0x81, 0x57, 0x70, 0x16, 
-0xE0, 0xFF, 0xEE, 0x13, 0x13, 0x54, 0x3F, 0x90, 0x81, 0x59, 0xF0, 0xEF, 0x54, 0x0C, 0x13, 0x13, 
-0x54, 0x3F, 0xA3, 0xF0, 0x80, 0x0D, 0xE0, 0xFE, 0x54, 0x30, 0x90, 0x81, 0x59, 0xF0, 0xEE, 0x54, 
-0x03, 0xA3, 0xF0, 0x90, 0x81, 0x59, 0xE0, 0x64, 0x30, 0x70, 0x54, 0xA3, 0xE0, 0x64, 0x02, 0x70, 
-0x4E, 0x90, 0x00, 0xF5, 0xE0, 0x54, 0x40, 0x90, 0x81, 0x5C, 0xF0, 0xE0, 0x70, 0x41, 0xA3, 0x74, 
-0x02, 0xF0, 0x80, 0x10, 0x90, 0x81, 0x5D, 0x74, 0x01, 0xF0, 0x80, 0x08, 0x90, 0x81, 0x5B, 0xE0, 
-0x04, 0xF0, 0x01, 0x1A, 0x90, 0x01, 0xC4, 0x74, 0xF2, 0xF0, 0x74, 0x57, 0xA3, 0xF0, 0x90, 0x81, 
-0x5D, 0xE0, 0x90, 0x01, 0xC8, 0xF0, 0x90, 0x81, 0x57, 0xE0, 0x90, 0x01, 0xC9, 0xF0, 0x90, 0x81, 
-0x58, 0xE0, 0x90, 0x01, 0xCA, 0xF0, 0xE4, 0xFD, 0x7F, 0x1F, 0x12, 0x32, 0x1E, 0x80, 0xD5, 0x22, 
-0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x90, 0xFD, 0x00, 0xE0, 
-0x54, 0xBF, 0xF0, 0x12, 0x57, 0xF2, 0x31, 0xCB, 0x12, 0x32, 0x77, 0x12, 0x71, 0x94, 0x31, 0xB2, 
-0x7F, 0x01, 0x12, 0x49, 0x15, 0x90, 0x81, 0x46, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x49, 0x15, 0x90, 
-0x81, 0x46, 0xE0, 0x04, 0xF0, 0x7F, 0x03, 0x12, 0x49, 0x15, 0x90, 0x81, 0x46, 0xE0, 0x04, 0xF0, 
-0x31, 0x4F, 0x31, 0x90, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 
-0x75, 0x20, 0xFF, 0x31, 0xBC, 0x12, 0x71, 0xC4, 0x31, 0xD3, 0xE4, 0xFF, 0x02, 0x49, 0x9E, 0x51, 
-0x09, 0x90, 0x80, 0x3C, 0xEF, 0xF0, 0x31, 0x61, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x02, 0x2D, 
-0xA7, 0x12, 0x71, 0x33, 0x12, 0x71, 0x63, 0x51, 0x23, 0x51, 0x42, 0xE4, 0xF5, 0x35, 0xF5, 0x36, 
-0xF5, 0x37, 0xF5, 0x38, 0xAD, 0x35, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xAD, 0x36, 0x7F, 0x51, 0x12, 
-0x32, 0x1E, 0xAD, 0x37, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xAD, 0x38, 0x7F, 0x53, 0x02, 0x32, 0x1E, 
-0x31, 0xB6, 0x31, 0xC3, 0x51, 0x64, 0x12, 0x79, 0x06, 0x31, 0xDD, 0x31, 0xE8, 0x31, 0xF7, 0x90, 
-0x81, 0x4A, 0xE0, 0x54, 0xFE, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0xA3, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 
-0xF0, 0x22, 0xE4, 0xF5, 0x4D, 0x22, 0xE4, 0x90, 0x80, 0xDE, 0xF0, 0x22, 0x75, 0xE8, 0x03, 0x75, 
-0xA8, 0x84, 0x22, 0xE4, 0x90, 0x80, 0xD8, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 
-0x01, 0xF0, 0x22, 0x90, 0x01, 0xE4, 0x74, 0x0C, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x81, 0x40, 
-0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xA3, 0xF0, 0x22, 0x90, 0x81, 0x42, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 
-0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x81, 0x47, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0x7F, 
-0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0xE4, 0xA3, 0xF0, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x20, 0xE7, 0x09, 
-0xE0, 0x7F, 0x01, 0x20, 0xE6, 0x0C, 0x7F, 0x02, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x30, 0xE6, 0x02, 
-0x7F, 0x03, 0x22, 0x75, 0x3D, 0x10, 0xE4, 0xF5, 0x3E, 0x75, 0x3F, 0x07, 0x75, 0x40, 0x02, 0x90, 
-0x01, 0x30, 0xE5, 0x3D, 0xF0, 0xA3, 0xE5, 0x3E, 0xF0, 0xA3, 0xE5, 0x3F, 0xF0, 0xA3, 0xE5, 0x40, 
-0xF0, 0x22, 0x75, 0x45, 0x0E, 0x75, 0x46, 0x01, 0x43, 0x46, 0x10, 0x75, 0x47, 0x03, 0x75, 0x48, 
-0x62, 0x90, 0x01, 0x38, 0xE5, 0x45, 0xF0, 0xA3, 0xE5, 0x46, 0xF0, 0xA3, 0xE5, 0x47, 0xF0, 0xA3, 
-0xE5, 0x48, 0xF0, 0x22, 0x90, 0x81, 0x1F, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 0x54, 0xFB, 
-0xF0, 0x54, 0xF7, 0xF0, 0x54, 0xEF, 0xF0, 0x54, 0xDF, 0xF0, 0x54, 0xBF, 0xF0, 0xE4, 0xA3, 0xF0, 
-0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x0C, 0xF0, 0x22, 0x31, 0x9F, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 
-0x01, 0xFE, 0x90, 0x81, 0x4A, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x14, 
-0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x81, 0x4B, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 
-0x90, 0x81, 0x4C, 0xF0, 0x22, 0x90, 0x81, 0xCD, 0x12, 0x4B, 0x1F, 0xEF, 0x12, 0x4B, 0x28, 0x5A, 
-0xEA, 0x00, 0x5A, 0xF3, 0x01, 0x5A, 0xFB, 0x02, 0x5B, 0x03, 0x03, 0x5B, 0x0C, 0x04, 0x5B, 0x14, 
-0x20, 0x5B, 0x1C, 0x21, 0x5B, 0x25, 0x23, 0x5B, 0x2D, 0x24, 0x5B, 0x36, 0x25, 0x5B, 0x3E, 0x26, 
-0x5B, 0x46, 0x27, 0x5B, 0x4E, 0xC0, 0x00, 0x00, 0x5B, 0x56, 0x90, 0x81, 0xCD, 0x12, 0x4B, 0x16, 
-0x02, 0x70, 0x9E, 0x90, 0x81, 0xCD, 0x12, 0x4B, 0x16, 0xC1, 0x95, 0x90, 0x81, 0xCD, 0x12, 0x4B, 
-0x16, 0x81, 0x9A, 0x90, 0x81, 0xCD, 0x12, 0x4B, 0x16, 0x02, 0x7D, 0x9E, 0x90, 0x81, 0xCD, 0x12, 
-0x4B, 0x16, 0x41, 0x89, 0x90, 0x81, 0xCD, 0x12, 0x4B, 0x16, 0xA1, 0xC2, 0x90, 0x81, 0xCD, 0x12, 
-0x4B, 0x16, 0x02, 0x70, 0xE6, 0x90, 0x81, 0xCD, 0x12, 0x4B, 0x16, 0xE1, 0x3B, 0x90, 0x81, 0xCD, 
-0x12, 0x4B, 0x16, 0x02, 0x51, 0x46, 0x90, 0x81, 0xCD, 0x12, 0x4B, 0x16, 0xE1, 0x62, 0x90, 0x81, 
-0xCD, 0x12, 0x4B, 0x16, 0x80, 0x18, 0x90, 0x81, 0xCD, 0x12, 0x4B, 0x16, 0x80, 0x3C, 0x90, 0x81, 
-0xCD, 0x12, 0x4B, 0x16, 0xE1, 0xA2, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x12, 0x1F, 
-0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x81, 0x40, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0x90, 0x00, 0x01, 
-0x12, 0x1F, 0xBD, 0xFE, 0x90, 0x05, 0x54, 0xE0, 0xC3, 0x9E, 0x90, 0x81, 0x41, 0xF0, 0xEF, 0x20, 
-0xE0, 0x07, 0x71, 0xFD, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 
-0x90, 0x81, 0x42, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x81, 
-0x43, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x90, 0x81, 0x44, 0xF0, 0x90, 0x81, 0x43, 0xE0, 
-0x90, 0x81, 0x45, 0xF0, 0x90, 0x81, 0x42, 0xE0, 0x54, 0x01, 0xFF, 0xAC, 0x07, 0xEF, 0x54, 0x01, 
-0xFE, 0x90, 0x81, 0x42, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0xEF, 0x90, 0x01, 0x53, 0xB4, 0x01, 0x12, 
-0xE4, 0xF0, 0x7D, 0x10, 0x7F, 0x03, 0x12, 0x77, 0xCD, 0x90, 0x81, 0x44, 0xE0, 0x90, 0x05, 0x73, 
-0xF0, 0x22, 0x74, 0x03, 0xF0, 0x7D, 0x10, 0xFF, 0x12, 0x77, 0xE2, 0x71, 0xFD, 0x90, 0x05, 0x22, 
-0xE4, 0xF0, 0x90, 0x81, 0x2A, 0x74, 0x0C, 0xF0, 0x90, 0x81, 0x23, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 
-0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 
-0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x7F, 0x7C, 0x7E, 
-0x08, 0x12, 0x2D, 0x5C, 0xEC, 0x54, 0x7F, 0xFC, 0x90, 0x82, 0x0A, 0x12, 0x20, 0xCE, 0x90, 0x82, 
-0x0A, 0x12, 0x4A, 0xD9, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2E, 
-0xA2, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0xCC, 0xC0, 0x00, 0xC0, 0x7F, 0x8C, 0x7E, 0x08, 0x12, 
-0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0x00, 0xC0, 0x00, 0x14, 0x7F, 0x70, 0x7E, 0x0E, 
-0x12, 0x2E, 0xA2, 0x90, 0x82, 0x02, 0x12, 0x20, 0xDA, 0x00, 0x03, 0x3E, 0x60, 0xE4, 0xFD, 0xFF, 
-0x91, 0x77, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 
-0xC0, 0x05, 0x90, 0x82, 0x02, 0x12, 0x4A, 0xD9, 0x90, 0x81, 0xEE, 0x12, 0x20, 0xCE, 0xD0, 0x05, 
-0xD0, 0x07, 0x12, 0x6D, 0x26, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x90, 0x81, 0xD0, 0x12, 0x4B, 0x1F, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 0x1E, 0xF0, 0xBF, 
-0x01, 0x12, 0x90, 0x81, 0xD0, 0x12, 0x4B, 0x16, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x64, 0x01, 
-0x60, 0x23, 0x80, 0x1E, 0x90, 0x81, 0xD0, 0x12, 0x4B, 0x16, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 
-0x64, 0x01, 0x60, 0x11, 0x90, 0x81, 0x1F, 0xE0, 0x20, 0xE0, 0x07, 0xE4, 0xFF, 0x12, 0x55, 0xA3, 
-0x80, 0x03, 0x12, 0x72, 0xCF, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x05, 0x22, 0x74, 0xFF, 0xF0, 
-0xB1, 0x7A, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0xCC, 0xF0, 0x00, 0xC0, 0x7F, 0x8C, 0x7E, 0x08, 
-0x12, 0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x14, 0x7F, 0x70, 0x7E, 
-0x0E, 0x12, 0x2E, 0xA2, 0x90, 0x82, 0x02, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFD, 
-0xFF, 0x91, 0x77, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x82, 
-0x0E, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x0E, 0x12, 0x4A, 0xD9, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 
-0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 
-0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0x22, 0x90, 0x05, 0x22, 0x74, 0xFF, 0xF0, 
-0xB1, 0x7A, 0x90, 0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 0x51, 0x31, 0x91, 0xF0, 
-0xE4, 0x90, 0x81, 0x2A, 0xF0, 0x90, 0x81, 0x23, 0xF0, 0x22, 0xE4, 0x90, 0x82, 0x18, 0xF0, 0xA3, 
-0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 
-0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 0x82, 0x19, 0xE0, 0x94, 0xE8, 0x90, 0x82, 0x18, 
-0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 
-0x32, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x82, 0x18, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x4A, 0xA9, 
-0x80, 0xBF, 0x90, 0x81, 0xD0, 0x12, 0x4B, 0x1F, 0x90, 0x81, 0xD0, 0x12, 0x4B, 0x16, 0x90, 0x81, 
-0xD3, 0x12, 0x4B, 0x1F, 0x90, 0x81, 0xD0, 0x12, 0x4B, 0x16, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 
-0x90, 0x81, 0x3F, 0xF0, 0x90, 0x81, 0xD3, 0x12, 0x4B, 0x16, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x7F, 
-0x90, 0x81, 0x27, 0xF0, 0xEF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0xA3, 0xF0, 0x90, 0x00, 0x01, 
-0x12, 0x1F, 0xBD, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0x81, 0x26, 0xE0, 0x54, 0xF0, 
-0x4E, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 0x81, 0x24, 
-0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0x90, 0x81, 0x26, 0xE0, 
-0x54, 0x0F, 0x4F, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0x90, 0x81, 0x29, 0xF0, 0xD1, 0x65, 
-0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0xF0, 0x90, 0x81, 0x27, 0xE0, 0x90, 0x01, 
-0xBA, 0xF0, 0x90, 0x81, 0x29, 0xE0, 0x90, 0x01, 0xBB, 0xF0, 0x90, 0x81, 0x26, 0xE0, 0x54, 0x0F, 
-0x90, 0x01, 0xBE, 0xF0, 0x22, 0x90, 0x81, 0xD6, 0x12, 0x4B, 0x1F, 0xF1, 0x81, 0x90, 0x81, 0x27, 
-0xE0, 0xFF, 0x12, 0x53, 0x74, 0x90, 0x81, 0x27, 0xE0, 0x60, 0x19, 0x90, 0x81, 0xD6, 0x12, 0x4B, 
-0x16, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x54, 0x0F, 0xFF, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 
-0xFD, 0x12, 0x79, 0xDB, 0x22, 0x90, 0x81, 0xD0, 0x12, 0x4B, 0x1F, 0x90, 0x00, 0x01, 0x12, 0x1F, 
-0xBD, 0xFF, 0xFE, 0x12, 0x1F, 0xA4, 0xFD, 0xC3, 0x13, 0x30, 0xE0, 0x12, 0x90, 0x81, 0xD0, 0x12, 
-0x4B, 0x16, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x90, 0x81, 0xD4, 0xF0, 0x80, 0x05, 0x90, 0x81, 
-0xD4, 0xEF, 0xF0, 0x90, 0x81, 0xD3, 0xEE, 0xF0, 0x90, 0x81, 0xD4, 0xE0, 0xFE, 0x90, 0x81, 0xD3, 
-0xE0, 0xFF, 0xD3, 0x9E, 0x50, 0x38, 0x90, 0x81, 0xD0, 0x12, 0x4B, 0x16, 0x12, 0x1F, 0xA4, 0x54, 
-0x01, 0xFE, 0x74, 0xDE, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0xEE, 0xF0, 0x74, 0xDE, 
-0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0xE0, 0x70, 0x04, 0xF1, 0x3A, 0x80, 0x07, 0x90, 
-0x81, 0xD3, 0xE0, 0xFF, 0xF1, 0x39, 0x90, 0x81, 0xD3, 0xE0, 0x04, 0xF0, 0x80, 0xBA, 0x90, 0x80, 
-0xDE, 0xE0, 0x70, 0x24, 0x90, 0x81, 0x2A, 0xE0, 0x70, 0x04, 0xFF, 0x12, 0x4F, 0x1B, 0x90, 0x81, 
-0x2A, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0xF1, 0xB4, 0x90, 0x81, 0x24, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 
-0xEF, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x22, 0x22, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 
-0x31, 0xF0, 0x22, 0x71, 0xFD, 0x90, 0x81, 0x22, 0x74, 0x03, 0xF0, 0x22, 0x91, 0xF0, 0x90, 0x81, 
-0x22, 0x74, 0x02, 0xF0, 0x22, 0x91, 0xEA, 0x90, 0x81, 0x2A, 0x74, 0x08, 0xF0, 0x90, 0x81, 0x23, 
-0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x3E, 0xF0, 0x90, 0x81, 0x3E, 0xE0, 0x90, 0x01, 0xE7, 
-0xF0, 0x22, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x07, 0x71, 0xFD, 0x90, 0x05, 0x22, 0xE4, 0xF0, 
-0x22, 0x90, 0x81, 0x24, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x81, 0x30, 0xF0, 0x90, 0x81, 0x2B, 
-0xF0, 0x22, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 0x91, 0xEA, 0x90, 0x81, 0x22, 0x74, 0x02, 
-0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x4F, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 
-0x81, 0x50, 0xF0, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x05, 0x22, 0xE4, 0xF0, 
-0x90, 0x81, 0x2A, 0x74, 0x0C, 0xF0, 0x22, 0x71, 0xFD, 0x90, 0x05, 0x22, 0x74, 0x6F, 0xF0, 0x90, 
-0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x81, 0x22, 0x74, 0x04, 0xF0, 0x22, 0xE4, 0x90, 0x81, 
-0x5E, 0xF0, 0x90, 0x81, 0x5E, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0xDD, 0x90, 0x01, 0xC4, 0xF0, 0x74, 
-0x5F, 0xA3, 0xF0, 0x90, 0x81, 0x27, 0xE0, 0x60, 0x0F, 0x90, 0x81, 0x2A, 0xE0, 0xFF, 0x90, 0x81, 
-0x29, 0xE0, 0x6F, 0x60, 0x03, 0x12, 0x4D, 0x29, 0xC2, 0xAF, 0x12, 0x72, 0x1A, 0xBF, 0x01, 0x02, 
-0x11, 0x23, 0xD2, 0xAF, 0xF1, 0xD6, 0x12, 0x32, 0x9E, 0xBF, 0x01, 0x02, 0x31, 0x24, 0x12, 0x48, 
-0x4D, 0x80, 0xBF, 0x90, 0x81, 0x24, 0xE0, 0x30, 0xE0, 0x23, 0x90, 0x81, 0x1F, 0xE0, 0xFF, 0x30, 
-0xE0, 0x19, 0xC3, 0x13, 0x30, 0xE0, 0x08, 0x12, 0x7C, 0x53, 0xBF, 0x01, 0x10, 0x80, 0x0A, 0x90, 
-0x81, 0x23, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x04, 0x80, 0x03, 0x11, 0x5E, 0x22, 0xD3, 0x10, 
-0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x11, 0xDF, 0x11, 0x77, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x81, 
-0x2A, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x0E, 0x12, 0x7A, 0x8C, 0xBF, 0x01, 0x08, 0x11, 0x4E, 
-0x90, 0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 0xF1, 0xD7, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 0xFD, 
-0x7F, 0x08, 0x12, 0x32, 0x1E, 0xE4, 0xFF, 0x8F, 0x50, 0xE4, 0x90, 0x81, 0x5F, 0xF0, 0xA3, 0xF0, 
-0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0xEF, 0x65, 0x50, 0x60, 0x3E, 
-0xC3, 0x90, 0x81, 0x60, 0xE0, 0x94, 0x88, 0x90, 0x81, 0x5F, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 
-0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x81, 0x5F, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x4A, 
-0xA9, 0x7F, 0x14, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0xD3, 0x90, 0x81, 0x60, 0xE0, 0x94, 0x32, 0x90, 
-0x81, 0x5F, 0xE0, 0x94, 0x00, 0x40, 0xB9, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xB2, 0x22, 0x90, 
-0x81, 0x31, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x32, 0x1E, 0x90, 0x81, 0x28, 0xE0, 0x60, 0x12, 0x90, 
-0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 
-0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x12, 0x32, 0x1E, 0x7F, 0x01, 0x11, 
-0x87, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x90, 0x12, 0x32, 0x1E, 0x7F, 0x14, 0x7E, 
-0x00, 0x02, 0x32, 0xAA, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x2D, 0xA7, 0xE4, 0xF5, 
-0x52, 0x12, 0x32, 0x9E, 0xEF, 0x60, 0x71, 0x63, 0x52, 0x01, 0xE5, 0x52, 0x24, 0x24, 0x90, 0x01, 
-0xC4, 0xF0, 0x74, 0x61, 0xA3, 0xF0, 0x90, 0x00, 0x88, 0xE0, 0xF5, 0x50, 0xF5, 0x51, 0x54, 0x0F, 
-0x60, 0xDF, 0xE5, 0x50, 0x30, 0xE0, 0x0B, 0x20, 0xE4, 0x03, 0x12, 0x29, 0xC5, 0x53, 0x51, 0xEE, 
-0x80, 0x3D, 0xE5, 0x50, 0x30, 0xE1, 0x16, 0x20, 0xE5, 0x0E, 0x12, 0x11, 0xBD, 0xEF, 0x70, 0x03, 
-0x43, 0x51, 0x20, 0x90, 0x01, 0x06, 0xE4, 0xF0, 0x53, 0x51, 0xFD, 0x80, 0x22, 0xE5, 0x50, 0x30, 
-0xE2, 0x0A, 0x20, 0xE6, 0x02, 0x91, 0x2F, 0x53, 0x51, 0xFB, 0x80, 0x13, 0xE5, 0x50, 0x30, 0xE3, 
-0x0E, 0x20, 0xE7, 0x08, 0x31, 0xAD, 0xEF, 0x70, 0x03, 0x43, 0x51, 0x80, 0x53, 0x51, 0xF7, 0xAD, 
-0x51, 0x7F, 0x88, 0x12, 0x32, 0x1E, 0x80, 0x89, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x78, 0x10, 0x74, 
-0x01, 0xF2, 0x90, 0x02, 0x09, 0xE0, 0x78, 0x00, 0xF2, 0x08, 0x74, 0x20, 0xF2, 0x18, 0xE2, 0xFF, 
-0x30, 0xE0, 0x05, 0x08, 0xE2, 0x24, 0x80, 0xF2, 0xEF, 0xC3, 0x13, 0x90, 0xFD, 0x10, 0xF0, 0x78, 
-0x01, 0xE2, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x78, 0x03, 0xF2, 0x64, 
-0x04, 0x60, 0x0D, 0xE2, 0xFF, 0x64, 0x08, 0x60, 0x07, 0xEF, 0x64, 0x0C, 0x60, 0x02, 0x81, 0x1D, 
-0xE4, 0x78, 0x02, 0xF2, 0x78, 0x03, 0xE2, 0xFF, 0x18, 0xE2, 0xC3, 0x9F, 0x50, 0x2D, 0xE2, 0xFD, 
-0x18, 0xE2, 0x2D, 0x90, 0x81, 0x5F, 0xF0, 0xE0, 0xFF, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
-0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x04, 0x2D, 0xF8, 0xEE, 0xF2, 0xEF, 0xB4, 0xFF, 0x06, 0x90, 0xFD, 
-0x10, 0xE0, 0x04, 0xF0, 0x78, 0x02, 0xE2, 0x04, 0xF2, 0x80, 0xC9, 0x78, 0x04, 0xE2, 0x78, 0x12, 
-0xF2, 0xFF, 0x78, 0x05, 0xE2, 0x78, 0x11, 0xF2, 0x78, 0x06, 0xE2, 0x78, 0x13, 0xF2, 0x78, 0x07, 
-0xE2, 0x78, 0x14, 0xF2, 0x78, 0x08, 0xE2, 0x78, 0x33, 0xF2, 0x78, 0x09, 0xE2, 0x78, 0x34, 0xF2, 
-0x78, 0x0A, 0xE2, 0x78, 0x35, 0xF2, 0x78, 0x0B, 0xE2, 0x78, 0x36, 0xF2, 0x78, 0x0C, 0xE2, 0x78, 
-0x37, 0xF2, 0x78, 0x0D, 0xE2, 0x78, 0x38, 0xF2, 0x78, 0x0E, 0xE2, 0x78, 0x39, 0xF2, 0x78, 0x0F, 
-0xE2, 0x78, 0x3A, 0xF2, 0xE4, 0x78, 0x15, 0xF2, 0xEF, 0x24, 0xF8, 0x60, 0x75, 0x24, 0xFC, 0x60, 
-0x6C, 0x24, 0x08, 0x60, 0x02, 0x61, 0xFF, 0x78, 0x11, 0xE2, 0xB4, 0x01, 0x05, 0x12, 0x29, 0xC5, 
-0x81, 0x04, 0x78, 0x11, 0xE2, 0xB4, 0x02, 0x05, 0x12, 0x11, 0xBD, 0x81, 0x04, 0x78, 0x11, 0xE2, 
-0xB4, 0x03, 0x04, 0x91, 0x2F, 0x81, 0x04, 0x78, 0x11, 0xE2, 0xB4, 0x10, 0x17, 0x78, 0x14, 0xE2, 
-0xFE, 0x18, 0xE2, 0xFD, 0xED, 0xFF, 0x78, 0x16, 0xEE, 0xF2, 0xFE, 0x08, 0xEF, 0xF2, 0xFF, 0x12, 
-0x32, 0xAA, 0x81, 0x04, 0x78, 0x11, 0xE2, 0xB4, 0x11, 0x17, 0x78, 0x14, 0xE2, 0xFE, 0x18, 0xE2, 
-0xFD, 0xED, 0xFF, 0x78, 0x16, 0xEE, 0xF2, 0xFE, 0x08, 0xEF, 0xF2, 0xFF, 0x12, 0x32, 0x06, 0x81, 
-0x04, 0x78, 0x11, 0xE2, 0xF4, 0x60, 0x02, 0x81, 0x04, 0x18, 0xF2, 0x81, 0x04, 0x78, 0x15, 0x74, 
-0x01, 0xF2, 0x78, 0x11, 0xE2, 0x64, 0x07, 0x60, 0x02, 0x61, 0xE9, 0x78, 0x34, 0xE2, 0xFF, 0xE4, 
-0xFC, 0xFD, 0xFE, 0x78, 0x08, 0x12, 0x20, 0xBB, 0xC0, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 
-0x78, 0x33, 0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0xD0, 0x00, 0x12, 0x4A, 0xCC, 0xC0, 0x04, 0xC0, 
-0x05, 0xC0, 0x06, 0xC0, 0x07, 0x78, 0x35, 0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x10, 0x12, 
-0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x4A, 0xCC, 0x78, 0x18, 0x12, 
-0x4A, 0xFE, 0x78, 0x15, 0xE2, 0x70, 0x02, 0x61, 0xD2, 0x18, 0xE2, 0xFF, 0x18, 0xE2, 0xFD, 0x91, 
-0x20, 0x78, 0x1C, 0x12, 0x4A, 0xFE, 0x78, 0x38, 0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x08, 
-0x12, 0x20, 0xBB, 0xC0, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x78, 0x37, 0xE2, 0xFF, 0xE4, 
-0xFC, 0xFD, 0xFE, 0xD0, 0x00, 0x12, 0x4A, 0xCC, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 
-0x78, 0x39, 0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 
-0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x4A, 0xCC, 0x78, 0x20, 0x12, 0x4A, 0xFE, 0x78, 0x20, 0x12, 
-0x4A, 0xE5, 0x12, 0x20, 0x9B, 0x78, 0x1C, 0x12, 0x4A, 0xF1, 0x12, 0x4A, 0xBF, 0xC0, 0x04, 0xC0, 
-0x05, 0xC0, 0x06, 0xC0, 0x07, 0x78, 0x18, 0x12, 0x4A, 0xE5, 0x78, 0x20, 0x12, 0x4A, 0xF1, 0x12, 
-0x4A, 0xBF, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x4A, 0xCC, 0x78, 0x18, 0x12, 
-0x4A, 0xFE, 0x78, 0x18, 0x12, 0x4A, 0xE5, 0x90, 0x82, 0x02, 0x12, 0x20, 0xCE, 0x78, 0x13, 0xE2, 
-0xFD, 0x08, 0xE2, 0xFF, 0x12, 0x5C, 0x77, 0x80, 0x1B, 0x78, 0x13, 0xE2, 0xFF, 0x08, 0xE2, 0xFD, 
-0x78, 0x11, 0xE2, 0xFB, 0x78, 0x15, 0xE2, 0x90, 0x81, 0xC1, 0xF0, 0xF1, 0xDF, 0x80, 0x05, 0x78, 
-0x10, 0x74, 0x02, 0xF2, 0x78, 0x10, 0xE2, 0xFF, 0xC3, 0x94, 0x02, 0x50, 0x10, 0xEF, 0x60, 0x0A, 
-0x78, 0x02, 0xE2, 0xFF, 0x18, 0xE2, 0x2F, 0xF2, 0x21, 0xCF, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 
-0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x6B, 0xE7, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 
-0x90, 0x81, 0x6F, 0xF0, 0x90, 0x87, 0x5F, 0xE0, 0x90, 0x81, 0x6E, 0xF0, 0xE4, 0x90, 0x81, 0x7B, 
-0xF0, 0x90, 0x81, 0x6B, 0xF0, 0x90, 0x81, 0x6B, 0xE0, 0xFF, 0xC3, 0x94, 0x40, 0x50, 0x15, 0x74, 
-0x7E, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x74, 0xFF, 0xF0, 0x90, 0x81, 0x6B, 0xE0, 
-0x04, 0xF0, 0x80, 0xE1, 0xE4, 0x90, 0x81, 0x6B, 0xF0, 0x90, 0x81, 0x6E, 0xE0, 0xFF, 0x90, 0x81, 
-0x6B, 0xE0, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0xA1, 0x39, 0x74, 0xDF, 0x2E, 0xF9, 0xE4, 0x34, 0x86, 
-0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x0A, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x60, 
-0x12, 0x2B, 0xED, 0x90, 0x81, 0x61, 0xE0, 0xFF, 0x12, 0x2F, 0x27, 0xEF, 0x04, 0x90, 0x81, 0x7B, 
-0xF0, 0x90, 0x81, 0x60, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x12, 0x31, 0xEA, 0xEF, 0x24, 0xC8, 0x90, 
-0x81, 0x7D, 0xF0, 0x75, 0xF0, 0x08, 0xA4, 0xF0, 0x90, 0x81, 0x61, 0xE0, 0x54, 0x0F, 0x90, 0x81, 
-0x7C, 0xF0, 0xE4, 0x90, 0x81, 0x6A, 0xF0, 0x90, 0x81, 0x6C, 0xF0, 0x90, 0x81, 0x6C, 0xE0, 0xFF, 
-0xC3, 0x94, 0x04, 0x50, 0x57, 0x90, 0x81, 0x7C, 0xE0, 0xFE, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 
-0x13, 0xD8, 0xFC, 0x20, 0xE0, 0x3E, 0x90, 0x81, 0x6C, 0xE0, 0x25, 0xE0, 0xFF, 0x90, 0x81, 0x7D, 
-0xE0, 0x2F, 0x24, 0x7E, 0xF9, 0xE4, 0x34, 0x81, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x01, 0x90, 
-0x81, 0x6A, 0xE0, 0x75, 0xF0, 0x02, 0xA4, 0x24, 0x62, 0xF9, 0x74, 0x81, 0x35, 0xF0, 0x8B, 0x13, 
-0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x02, 0xD0, 0x01, 0xD0, 0x03, 0x12, 0x2B, 0xED, 0x90, 0x81, 
-0x6A, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x6C, 0xE0, 0x04, 0xF0, 0x80, 0x9F, 0x90, 0x81, 0x7B, 0xE0, 
-0xFF, 0x90, 0x81, 0x6B, 0xE0, 0x2F, 0xF0, 0x81, 0x69, 0xE4, 0x90, 0x81, 0x6F, 0xF0, 0x90, 0x81, 
-0x6F, 0xE0, 0xC3, 0x94, 0x40, 0x40, 0x02, 0xE1, 0xD5, 0xE0, 0xFF, 0x24, 0x7E, 0xF5, 0x82, 0xE4, 
-0x34, 0x81, 0xF5, 0x83, 0xE0, 0x90, 0x81, 0x71, 0xF0, 0xE0, 0xFE, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 
-0xFD, 0x90, 0x81, 0x70, 0xF0, 0xEE, 0x54, 0x0F, 0xFE, 0xA3, 0xF0, 0x74, 0x7F, 0x2F, 0xF5, 0x82, 
-0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0x90, 0x81, 0x72, 0xF0, 0xFC, 0xEE, 0xFE, 0xEC, 0xFB, 0xEB, 
-0xFF, 0x90, 0x81, 0x77, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xED, 0x12, 0x4B, 0x28, 0x65, 0xB2, 0x00, 
-0x65, 0xE9, 0x01, 0x66, 0x9A, 0x02, 0x67, 0xC6, 0x03, 0x66, 0xB5, 0x04, 0x66, 0xD6, 0x05, 0x66, 
-0xD6, 0x06, 0x66, 0xD6, 0x07, 0x66, 0xD6, 0x08, 0x67, 0x5A, 0x09, 0x67, 0x90, 0x0A, 0x00, 0x00, 
-0x67, 0xD5, 0x90, 0x81, 0x6F, 0xE0, 0xFD, 0x24, 0x81, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 
-0xE0, 0xFE, 0x74, 0x80, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFD, 0xED, 0xFF, 
-0x90, 0x81, 0x79, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0x90, 0x81, 0x72, 0xE0, 0xFF, 0x12, 0x2F, 
-0x96, 0x90, 0x81, 0x6D, 0x74, 0x02, 0xF0, 0xE1, 0xC6, 0x90, 0x81, 0x6F, 0xE0, 0x24, 0x81, 0xF5, 
-0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x08, 0x12, 0x20, 
-0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x81, 0x6F, 0xE0, 0x24, 0x80, 0xF5, 
-0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x12, 0x4A, 0xCC, 0xC0, 
-0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x81, 0x6F, 0xE0, 0x24, 0x82, 0xF5, 0x82, 0xE4, 
-0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 
-0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x4A, 0xCC, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 
-0xC0, 0x07, 0x90, 0x81, 0x6F, 0xE0, 0x24, 0x83, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 
-0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x18, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 
-0xD0, 0x00, 0x12, 0x4A, 0xCC, 0x90, 0x81, 0x73, 0x12, 0x20, 0xCE, 0x90, 0x81, 0x73, 0x12, 0x4A, 
-0xD9, 0x90, 0x85, 0x96, 0x12, 0x20, 0xCE, 0x90, 0x81, 0x77, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 
-0x2E, 0xE4, 0x90, 0x81, 0x6D, 0x74, 0x04, 0xF0, 0xE1, 0xC6, 0x90, 0x81, 0x72, 0xE0, 0xFD, 0x90, 
-0x81, 0x6F, 0xE0, 0x24, 0x80, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFF, 
-0x12, 0x30, 0xC7, 0x80, 0x19, 0x90, 0x81, 0x72, 0xE0, 0xFD, 0x90, 0x81, 0x6F, 0xE0, 0x24, 0x80, 
-0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFF, 0x12, 0x30, 0x6A, 0x90, 0x81, 
-0x6D, 0x74, 0x01, 0xF0, 0xE1, 0xC6, 0x90, 0x81, 0x6D, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x6F, 0xE0, 
-0x24, 0x81, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 
-0x08, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x81, 0x6F, 0xE0, 
-0x24, 0x80, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x12, 
-0x4A, 0xCC, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x81, 0x71, 0xE0, 0xFF, 0xE4, 
-0xFC, 0xFD, 0xFE, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 
-0x12, 0x4A, 0xCC, 0x90, 0x81, 0x73, 0x12, 0x20, 0xCE, 0x90, 0x81, 0x70, 0xE0, 0x24, 0xFB, 0xFF, 
-0xC0, 0x07, 0x90, 0x81, 0x73, 0x12, 0x4A, 0xD9, 0x90, 0x82, 0x02, 0x12, 0x20, 0xCE, 0x90, 0x81, 
-0x72, 0xE0, 0xFD, 0xD0, 0x07, 0x12, 0x5C, 0x77, 0x80, 0x6C, 0x90, 0x81, 0x6D, 0x74, 0x01, 0xF0, 
-0x90, 0x81, 0x6F, 0xE0, 0x24, 0x80, 0xF9, 0xE4, 0x34, 0x81, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 
-0x15, 0x75, 0x16, 0x01, 0x7B, 0xFE, 0x7A, 0x80, 0x79, 0x33, 0x12, 0x2B, 0xED, 0x90, 0x81, 0x72, 
-0xE0, 0xFF, 0x90, 0x81, 0x71, 0xE0, 0xFD, 0xE4, 0x90, 0x81, 0xC1, 0xF0, 0x7B, 0x04, 0x80, 0x34, 
-0x90, 0x81, 0x6D, 0x74, 0x04, 0xF0, 0x90, 0x81, 0x6F, 0xE0, 0x24, 0x80, 0xF9, 0xE4, 0x34, 0x81, 
-0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x04, 0x7B, 0xFE, 0x7A, 0x80, 0x79, 0x33, 
-0x12, 0x2B, 0xED, 0x90, 0x81, 0x72, 0xE0, 0xFF, 0x90, 0x81, 0x71, 0xE0, 0xFD, 0xE4, 0x90, 0x81, 
-0xC1, 0xF0, 0x7B, 0x06, 0xF1, 0xDF, 0x90, 0x81, 0x6D, 0xE0, 0x24, 0x02, 0xFF, 0x90, 0x81, 0x6F, 
-0xE0, 0x2F, 0xF0, 0xA1, 0x3E, 0x22, 0x22, 0x90, 0x00, 0x90, 0xE0, 0x20, 0xE0, 0xF9, 0x22, 0xAC, 
-0x07, 0xED, 0xAD, 0x04, 0x78, 0x24, 0xF2, 0xED, 0x08, 0xF2, 0xEB, 0xB4, 0x04, 0x07, 0x78, 0x27, 
-0x74, 0x01, 0xF2, 0x80, 0x0E, 0xEB, 0x78, 0x27, 0xB4, 0x05, 0x05, 0x74, 0x02, 0xF2, 0x80, 0x03, 
-0x74, 0x04, 0xF2, 0xD3, 0x78, 0x25, 0xE2, 0x94, 0xFF, 0x18, 0xE2, 0x94, 0x00, 0x50, 0x63, 0xE4, 
-0x78, 0x26, 0xF2, 0x78, 0x27, 0xE2, 0xFF, 0x18, 0xE2, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0x21, 0x7D, 
-0x74, 0x33, 0x2E, 0xF8, 0xE2, 0x78, 0x28, 0xF2, 0x90, 0x81, 0xC1, 0xE0, 0x60, 0x2D, 0x74, 0x37, 
-0x2E, 0xF8, 0xE2, 0x78, 0x32, 0xF2, 0xEE, 0xFF, 0x78, 0x25, 0xE2, 0x2F, 0xFF, 0x18, 0xE2, 0x34, 
-0x00, 0x8F, 0x82, 0xF5, 0x83, 0xE0, 0x78, 0x29, 0xF2, 0x78, 0x32, 0xE2, 0xFF, 0xF4, 0xFE, 0x78, 
-0x29, 0xE2, 0x5E, 0xFE, 0x18, 0xE2, 0xFD, 0xEF, 0x5D, 0x4E, 0xF2, 0x78, 0x24, 0x08, 0xE2, 0xFF, 
-0x08, 0xE2, 0x2F, 0xFF, 0x78, 0x28, 0xE2, 0xFD, 0x12, 0x32, 0x1E, 0x78, 0x26, 0xE2, 0x04, 0xF2, 
-0x80, 0xA1, 0xD3, 0x78, 0x25, 0xE2, 0x94, 0xFF, 0x18, 0xE2, 0x94, 0x07, 0x50, 0x69, 0xE4, 0x78, 
-0x26, 0xF2, 0x78, 0x27, 0xE2, 0xFF, 0x18, 0xE2, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0x21, 0x7D, 0x74, 
-0x33, 0x2E, 0xF8, 0xE2, 0x78, 0x28, 0xF2, 0x90, 0x81, 0xC1, 0xE0, 0x60, 0x2D, 0x78, 0x26, 0xE2, 
-0xFF, 0xFD, 0x18, 0xE2, 0x2D, 0xFD, 0x18, 0xE2, 0x34, 0x00, 0x8D, 0x82, 0xF5, 0x83, 0xE0, 0x78, 
-0x29, 0xF2, 0x74, 0x37, 0x2F, 0xF8, 0xE2, 0x78, 0x32, 0xF2, 0xE2, 0xFF, 0xF4, 0xFE, 0x78, 0x29, 
-0xE2, 0x5E, 0xFE, 0x18, 0xE2, 0xFD, 0xEF, 0x5D, 0x4E, 0xF2, 0x78, 0x28, 0xE2, 0xFF, 0x78, 0x26, 
-0xE2, 0xFD, 0x18, 0xE2, 0x2D, 0xFD, 0x18, 0xE2, 0x34, 0x00, 0x8D, 0x82, 0xF5, 0x83, 0xEF, 0xF0, 
-0x78, 0x26, 0xE2, 0x04, 0xF2, 0x80, 0x9B, 0x90, 0x81, 0xC1, 0xE0, 0x60, 0x0F, 0x78, 0x24, 0xE2, 
-0xFE, 0x08, 0xE2, 0xFF, 0x12, 0x2D, 0x5C, 0x78, 0x2E, 0x12, 0x4A, 0xFE, 0xE4, 0x78, 0x26, 0xF2, 
-0x78, 0x27, 0xE2, 0xFF, 0x18, 0xE2, 0xFE, 0xC3, 0x9F, 0x50, 0x5D, 0x74, 0x33, 0x2E, 0xF8, 0xE2, 
-0x78, 0x28, 0xF2, 0x90, 0x81, 0xC1, 0xE0, 0x60, 0x2B, 0x78, 0x2E, 0x12, 0x4A, 0xE5, 0x78, 0x26, 
-0xE2, 0xFB, 0x75, 0xF0, 0x08, 0xA4, 0xF9, 0xF8, 0x12, 0x20, 0xA8, 0x78, 0x29, 0xEF, 0xF2, 0x74, 
-0x37, 0x2B, 0xF8, 0xE2, 0x78, 0x32, 0xF2, 0xE2, 0xFE, 0xF4, 0x5F, 0xFF, 0x78, 0x28, 0xE2, 0xFD, 
-0xEE, 0x5D, 0x4F, 0xF2, 0x78, 0x28, 0xE2, 0xFF, 0x78, 0x26, 0xE2, 0xFD, 0xC3, 0x74, 0x03, 0x9D, 
-0xFD, 0xE4, 0x94, 0x00, 0xFC, 0x7B, 0xFE, 0x74, 0x2A, 0x2D, 0xF9, 0x74, 0x80, 0x3C, 0xFA, 0xEF, 
-0x12, 0x1F, 0xEA, 0xE2, 0x04, 0xF2, 0x80, 0x98, 0x78, 0x2A, 0x12, 0x4A, 0xE5, 0x90, 0x85, 0xBB, 
-0x12, 0x20, 0xCE, 0x78, 0x24, 0xE2, 0xFE, 0x08, 0xE2, 0xFF, 0x12, 0x2E, 0xA2, 0x22, 0xE4, 0xFB, 
-0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x4A, 0x4E, 0x90, 0x81, 0xC2, 0xEF, 0xF0, 0x60, 0xF0, 0x31, 0x92, 
-0x80, 0xEC, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 
-0x81, 0xC3, 0xF0, 0x90, 0x81, 0xC3, 0xE0, 0xFD, 0x70, 0x02, 0x41, 0xBD, 0x90, 0x82, 0x12, 0xE0, 
-0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 
-0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0x41, 0xB6, 0x90, 0x82, 0x12, 0xE0, 0x75, 0xF0, 0x04, 0x90, 
-0x01, 0xD0, 0x12, 0x4B, 0x0A, 0xE0, 0x90, 0x81, 0xC4, 0xF0, 0x75, 0x13, 0x01, 0x75, 0x14, 0x81, 
-0x75, 0x15, 0xC4, 0x75, 0x16, 0x01, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xC5, 0x12, 0x2B, 0xED, 0x90, 
-0x82, 0x12, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xD1, 0x12, 0x4B, 0x0A, 0xE0, 0x90, 0x81, 0xC6, 
-0xF0, 0x90, 0x82, 0x12, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xD2, 0x12, 0x4B, 0x0A, 0xE0, 0x90, 
-0x81, 0xC7, 0xF0, 0x90, 0x82, 0x12, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xD3, 0x12, 0x4B, 0x0A, 
-0xE0, 0x90, 0x81, 0xC8, 0xF0, 0x90, 0x82, 0x12, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xF0, 0x12, 
-0x4B, 0x0A, 0xE0, 0x90, 0x81, 0xC9, 0xF0, 0x90, 0x82, 0x12, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 
-0xF1, 0x12, 0x4B, 0x0A, 0xE0, 0x90, 0x81, 0xCA, 0xF0, 0x90, 0x82, 0x12, 0xE0, 0x75, 0xF0, 0x04, 
-0x90, 0x01, 0xF2, 0x12, 0x4B, 0x0A, 0xE0, 0x90, 0x81, 0xCB, 0xF0, 0x90, 0x82, 0x12, 0xE0, 0x75, 
-0xF0, 0x04, 0x90, 0x01, 0xF3, 0x12, 0x4B, 0x0A, 0xE0, 0x90, 0x81, 0xCC, 0xF0, 0x90, 0x81, 0xC3, 
-0xE0, 0xFF, 0x90, 0x82, 0x12, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x80, 0x02, 0xC3, 0x33, 
-0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0x81, 0xC3, 0xF0, 0x90, 0x82, 0x12, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 
-0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x81, 0xC5, 0xE0, 
-0xFF, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xC6, 0x12, 0x5A, 0xB5, 0x90, 0x82, 0x12, 0xE0, 0x04, 0xF0, 
-0xE0, 0x54, 0x03, 0xF0, 0x21, 0xA3, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 
-0xAF, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x4A, 0x4E, 0x90, 0x81, 0xD9, 0xEF, 0xF0, 
-0x60, 0xF0, 0x51, 0xD6, 0x80, 0xEC, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 0x90, 
-0x80, 0xD9, 0xE0, 0xFE, 0x90, 0x80, 0xD8, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 0x01, 0x80, 0x02, 
-0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x32, 0x90, 0x01, 0xAF, 0xE0, 0x70, 0x13, 0xED, 0x75, 0xF0, 
-0x0F, 0xA4, 0x24, 0x42, 0xF9, 0x74, 0x80, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x71, 0x2E, 0x7F, 0x01, 
-0xEF, 0x60, 0x16, 0x90, 0x80, 0xD8, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0xB4, 0x0A, 0x02, 0x7F, 
-0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0xD8, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 
-0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0xDA, 0x12, 0x4B, 0x1F, 0x90, 0x82, 0x13, 0xE0, 0xFF, 
-0x04, 0xF0, 0x90, 0x00, 0x01, 0xEF, 0x12, 0x1F, 0xFC, 0x7F, 0xAF, 0x7E, 0x01, 0x71, 0x91, 0xEF, 
-0x60, 0x3A, 0x90, 0x81, 0xDA, 0x12, 0x4B, 0x16, 0x8B, 0x13, 0x8A, 0x14, 0x89, 0x15, 0x90, 0x00, 
-0x0E, 0x12, 0x1F, 0xBD, 0x24, 0x02, 0xF5, 0x16, 0x7B, 0x01, 0x7A, 0x01, 0x79, 0xA0, 0x12, 0x2B, 
-0xED, 0x90, 0x81, 0xDA, 0x12, 0x4B, 0x16, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x90, 0x01, 0xAE, 
-0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0x90, 0x01, 0xCB, 0xE0, 0x64, 0x80, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 
-0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x06, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
-0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x82, 0x06, 0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 
-0xE0, 0x60, 0x2D, 0xC3, 0x90, 0x82, 0x09, 0xE0, 0x94, 0xE8, 0x90, 0x82, 0x08, 0xE0, 0x94, 0x03, 
-0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 0x15, 0x90, 0x82, 0x08, 
-0xE4, 0x75, 0xF0, 0x01, 0x12, 0x4A, 0xA9, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x80, 0xC5, 
-0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x81, 0xDD, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 
-0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x90, 0x81, 0xEB, 0xF0, 0x7F, 0x24, 0x7E, 0x08, 
-0x12, 0x2D, 0x5C, 0x90, 0x81, 0xE3, 0x12, 0x20, 0xCE, 0x90, 0x81, 0xDD, 0xE0, 0xFB, 0x70, 0x08, 
-0x90, 0x81, 0xE3, 0x12, 0x4A, 0xD9, 0x80, 0x16, 0xEB, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x62, 0xF5, 
-0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x2D, 0x5C, 0x90, 0x81, 
-0xE7, 0x12, 0x20, 0xCE, 0x90, 0x81, 0xDE, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x17, 0x12, 
-0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x81, 0xE7, 0x12, 0x4A, 0xD9, 
-0xED, 0x54, 0x7F, 0xFD, 0xEC, 0x54, 0x80, 0xFC, 0x12, 0x4A, 0xCC, 0xEC, 0x44, 0x80, 0xFC, 0x90, 
-0x81, 0xE7, 0x12, 0x20, 0xCE, 0x90, 0x81, 0xE3, 0x12, 0x4A, 0xD9, 0xEC, 0x54, 0x7F, 0xFC, 0x90, 
-0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x81, 0xDD, 0xE0, 
-0x75, 0xF0, 0x08, 0xA4, 0x24, 0x62, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 
-0xE0, 0xFF, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x81, 0xE7, 0x12, 0x4A, 0xD9, 0x90, 0x85, 0xBB, 0x12, 
-0x20, 0xCE, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x2E, 0xA2, 0x90, 0x81, 0xE3, 0x12, 0x4A, 0xD9, 0xEC, 
-0x44, 0x80, 0xFC, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 
-0x90, 0x81, 0xDD, 0xE0, 0x70, 0x04, 0x7F, 0x20, 0x80, 0x09, 0x90, 0x81, 0xDD, 0xE0, 0xB4, 0x01, 
+0x4E, 0xF6, 0xD2, 0xAF, 0x02, 0x41, 0x4D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 0xC2, 0xAF, 
+0x56, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0xE7, 0x09, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 
+0x46, 0xE7, 0x09, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x3E, 0x88, 0x82, 0x8C, 0x83, 0xE7, 0x09, 0xF0, 
+0xA3, 0xDF, 0xFA, 0x80, 0x32, 0xE3, 0x09, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 0x78, 0xE3, 0x09, 0xF2, 
+0x08, 0xDF, 0xFA, 0x80, 0x70, 0x88, 0x82, 0x8C, 0x83, 0xE3, 0x09, 0xF0, 0xA3, 0xDF, 0xFA, 0x80, 
+0x64, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xA3, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 0x58, 0x89, 0x82, 0x8A, 
+0x83, 0xE0, 0xA3, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x4C, 0x80, 0xD2, 0x80, 0xFA, 0x80, 0xC6, 0x80, 
+0xD4, 0x80, 0x69, 0x80, 0xF2, 0x80, 0x33, 0x80, 0x10, 0x80, 0xA6, 0x80, 0xEA, 0x80, 0x9A, 0x80, 
+0xA8, 0x80, 0xDA, 0x80, 0xE2, 0x80, 0xCA, 0x80, 0x33, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 
+0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 
+0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0x0D, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 
+0xA3, 0xF6, 0x08, 0xDF, 0xF9, 0xEC, 0xFA, 0xA9, 0xF0, 0xED, 0xFB, 0x22, 0x89, 0x82, 0x8A, 0x83, 
+0xEC, 0xFA, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 
+0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xEA, 0xDE, 0xE8, 0x80, 0xDB, 0x89, 0x82, 0x8A, 0x83, 
+0xE4, 0x93, 0xA3, 0xF2, 0x08, 0xDF, 0xF9, 0x80, 0xCC, 0x88, 0xF0, 0xEF, 0x60, 0x01, 0x0E, 0x4E, 
+0x60, 0xC3, 0x88, 0xF0, 0xED, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0xB9, 0xF5, 0x82, 0xEB, 0x24, 
+0x02, 0xB4, 0x04, 0x00, 0x50, 0xAF, 0x23, 0x23, 0x45, 0x82, 0x23, 0x90, 0x43, 0xF9, 0x73, 0xC5, 
+0xF0, 0xF8, 0xA3, 0xE0, 0x28, 0xF0, 0xC5, 0xF0, 0xF8, 0xE5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 
+0x83, 0xE0, 0x38, 0xF0, 0x22, 0xEF, 0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 0xED, 0x59, 0xFD, 0xEC, 0x58, 
+0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 0xEC, 0x48, 0xFC, 0x22, 0xE0, 
+0xFC, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xE2, 0xFC, 0x08, 0xE2, 0xFD, 
+0x08, 0xE2, 0xFE, 0x08, 0xE2, 0xFF, 0x22, 0xE2, 0xFB, 0x08, 0xE2, 0xF9, 0x08, 0xE2, 0xFA, 0x08, 
+0xE2, 0xCB, 0xF8, 0x22, 0xEC, 0xF2, 0x08, 0xED, 0xF2, 0x08, 0xEE, 0xF2, 0x08, 0xEF, 0xF2, 0x22, 
+0xA4, 0x25, 0x82, 0xF5, 0x82, 0xE5, 0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 
+0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xD0, 0x83, 
+0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 0x93, 0xF8, 
+0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xEF, 0xA3, 
+0xA3, 0xA3, 0x80, 0xDF, 0xEF, 0x4E, 0x60, 0x12, 0xEF, 0x60, 0x01, 0x0E, 0xED, 0xBB, 0x01, 0x0B, 
+0x89, 0x82, 0x8A, 0x83, 0xF0, 0xA3, 0xDF, 0xFC, 0xDE, 0xFA, 0x22, 0x89, 0xF0, 0x50, 0x07, 0xF7, 
+0x09, 0xDF, 0xFC, 0xA9, 0xF0, 0x22, 0xBB, 0xFE, 0xFC, 0xF3, 0x09, 0xDF, 0xFC, 0xA9, 0xF0, 0x22, 
+0x02, 0x45, 0xAE, 0x02, 0x41, 0xDD, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 
+0x80, 0x01, 0xF2, 0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 
+0xC8, 0xC3, 0x33, 0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 
+0x46, 0xF6, 0xDF, 0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x45, 
+0xF3, 0xE4, 0x7E, 0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 
+0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 
+0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 
+0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 
+0xE7, 0x80, 0xBE, 0x41, 0x82, 0xC9, 0x00, 0x41, 0x82, 0xCA, 0x00, 0x41, 0x82, 0xCF, 0x00, 0x41, 
+0x82, 0xD0, 0x00, 0x41, 0x82, 0xD9, 0x00, 0x00, 0x50, 0xFC, 0x58, 0x0E, 0x5F, 0xDA, 0xC0, 0xE0, 
+0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 
+0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x0E, 
+0xF0, 0x74, 0x46, 0xA3, 0xF0, 0xD1, 0x7F, 0xE5, 0x3C, 0x30, 0xE7, 0x02, 0xD1, 0x64, 0x74, 0x0E, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x46, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 
+0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 
+0xF0, 0xD0, 0xE0, 0x32, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 0x06, 0x90, 0x00, 0xF2, 0xE0, 0x20, 
+0xE6, 0x0C, 0x90, 0x00, 0x05, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x05, 0x12, 0x32, 0x1E, 0x22, 0x90, 
+0x00, 0x54, 0xE0, 0x55, 0x35, 0xF5, 0x39, 0xA3, 0xE0, 0x55, 0x36, 0xF5, 0x3A, 0xA3, 0xE0, 0x55, 
+0x37, 0xF5, 0x3B, 0xA3, 0xE0, 0x55, 0x38, 0xF5, 0x3C, 0xAD, 0x39, 0x7F, 0x54, 0x12, 0x32, 0x1E, 
+0xAD, 0x3A, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0xAD, 0x3B, 0x7F, 0x56, 0x12, 0x32, 0x1E, 0xAD, 0x3C, 
+0x7F, 0x57, 0x12, 0x32, 0x1E, 0x53, 0x91, 0xEF, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 
+0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 
+0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xB9, 0xF0, 0x74, 0x46, 0xA3, 0xF0, 
+0x12, 0x6E, 0xF4, 0xE5, 0x41, 0x30, 0xE4, 0x02, 0xF1, 0x57, 0xE5, 0x41, 0x30, 0xE6, 0x03, 0x12, 
+0x6F, 0x8D, 0xE5, 0x43, 0x30, 0xE0, 0x03, 0x12, 0x6F, 0x9A, 0xE5, 0x43, 0x30, 0xE1, 0x03, 0x12, 
+0x70, 0x43, 0xE5, 0x43, 0x30, 0xE2, 0x03, 0x12, 0x75, 0x86, 0xE5, 0x43, 0x30, 0xE3, 0x02, 0xF1, 
+0x6A, 0xE5, 0x43, 0x30, 0xE4, 0x03, 0x12, 0x5B, 0x4F, 0xE5, 0x43, 0x30, 0xE5, 0x03, 0x12, 0x54, 
+0x68, 0xE5, 0x43, 0x30, 0xE6, 0x03, 0x12, 0x58, 0x7F, 0xE5, 0x44, 0x30, 0xE1, 0x03, 0x12, 0x5B, 
+0x6C, 0x74, 0xB9, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x46, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 
+0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 
+0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x12, 0x60, 0x79, 0x7F, 0x02, 0x8F, 0x0D, 0x7F, 0x02, 
+0x71, 0x27, 0x90, 0x80, 0x3C, 0xE0, 0x45, 0x0D, 0xF0, 0x22, 0xF1, 0xF3, 0x70, 0x0B, 0x90, 0x81, 
+0x49, 0xE0, 0x60, 0x05, 0x12, 0x57, 0xAA, 0xF1, 0x7D, 0x22, 0xE0, 0x44, 0x02, 0xF0, 0xE4, 0xF5, 
+0x1D, 0x90, 0x81, 0xEE, 0xE0, 0xF5, 0x1E, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8E, 0x19, 0x8F, 0x1A, 0xE5, 0x1E, 0xF1, 0xE3, 0x85, 0x19, 0x83, 
+0x85, 0x1A, 0x82, 0xF0, 0xE5, 0x1D, 0xF1, 0xE3, 0xFF, 0xE5, 0x1E, 0x13, 0x13, 0x13, 0x54, 0x1F, 
+0x4F, 0xA3, 0xF0, 0xEB, 0xF1, 0xE3, 0xFF, 0xE5, 0x1D, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0xF1, 
+0xEA, 0xF0, 0xBD, 0x01, 0x0D, 0x85, 0x1A, 0x82, 0x8E, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 0x03, 0xF0, 
+0x80, 0x06, 0xF1, 0xEA, 0xA3, 0x74, 0x01, 0xF0, 0xF1, 0xEA, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x54, 0x07, 0xC4, 0x33, 0x54, 0xE0, 0x22, 0x85, 0x1A, 0x82, 0x85, 0x19, 0x83, 
+0xA3, 0xA3, 0x22, 0xE4, 0xFF, 0x12, 0x52, 0xD1, 0xEF, 0x64, 0x01, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 
+0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 
+0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xFC, 0xF0, 0x74, 
+0x47, 0xA3, 0xF0, 0x12, 0x6F, 0x21, 0xE5, 0x49, 0x30, 0xE1, 0x02, 0x11, 0xA4, 0xE5, 0x49, 0x30, 
+0xE2, 0x03, 0x12, 0x58, 0x69, 0xE5, 0x4A, 0x30, 0xE0, 0x03, 0x12, 0x72, 0xE1, 0xE5, 0x4A, 0x30, 
+0xE4, 0x03, 0x12, 0x75, 0xAF, 0xE5, 0x4B, 0x30, 0xE1, 0x03, 0x12, 0x76, 0x0D, 0xE5, 0x4B, 0x30, 
+0xE0, 0x03, 0x12, 0x75, 0xC5, 0xE5, 0x4B, 0x30, 0xE3, 0x03, 0x12, 0x76, 0x56, 0xE5, 0x4C, 0x30, 
+0xE1, 0x05, 0x7F, 0x04, 0x12, 0x47, 0x5C, 0xE5, 0x4C, 0x30, 0xE4, 0x02, 0x11, 0xCD, 0xE5, 0x4C, 
+0x30, 0xE5, 0x03, 0x12, 0x5B, 0xCE, 0xE5, 0x4C, 0x30, 0xE6, 0x03, 0x12, 0x76, 0x57, 0x74, 0xFC, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 
+0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 
+0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x03, 0x12, 0x70, 0xBC, 0x90, 0x81, 0xF4, 
+0xE0, 0x30, 0xE0, 0x18, 0x54, 0xFB, 0xF0, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x06, 0x7D, 0x04, 0x7F, 
+0x01, 0xA1, 0xFD, 0x7D, 0x31, 0x7F, 0xFF, 0xB1, 0xA9, 0x12, 0x5D, 0xA2, 0x22, 0x12, 0x74, 0x31, 
+0x7D, 0x02, 0x7F, 0x02, 0x31, 0x0A, 0x90, 0x81, 0xF6, 0xE0, 0x30, 0xE0, 0x22, 0x12, 0x73, 0xF6, 
+0x90, 0x81, 0xF9, 0xE0, 0x60, 0x04, 0x14, 0xF0, 0xA1, 0xE4, 0x90, 0x81, 0xF7, 0xE0, 0x14, 0x90, 
+0x81, 0xF9, 0xF0, 0x90, 0x05, 0x73, 0x74, 0x01, 0xF0, 0xE4, 0xFF, 0x31, 0x16, 0x31, 0x00, 0x22, 
+0x7D, 0x02, 0x7F, 0x02, 0x31, 0x0A, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x3D, 0x2F, 0xF8, 0xE6, 0x4D, 
+0xFE, 0xF6, 0x74, 0x30, 0x80, 0x5B, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 
+0x54, 0x01, 0xFE, 0x12, 0x77, 0xF0, 0xF0, 0xEF, 0x64, 0x01, 0x70, 0x20, 0x90, 0x01, 0x53, 0xF0, 
+0x90, 0x81, 0xF8, 0xE0, 0x60, 0x0B, 0x7D, 0x10, 0x7F, 0x03, 0x31, 0x67, 0x12, 0x73, 0xF6, 0x80, 
+0x13, 0x31, 0x59, 0x12, 0x57, 0xBC, 0x31, 0x7C, 0xB1, 0xE4, 0x80, 0x08, 0x31, 0x59, 0x31, 0x67, 
+0x31, 0x00, 0xF1, 0x35, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x01, 0x53, 0x74, 0x03, 0xF0, 0x7D, 
+0x10, 0xFF, 0x22, 0x7D, 0x03, 0x7F, 0x02, 0x74, 0x45, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 
+0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x7D, 0x02, 0x7F, 0x02, 
+0x31, 0x86, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x3D, 0x12, 0x77, 0xF8, 0xFE, 0xF6, 0x74, 0x30, 0x80, 
+0xE0, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x57, 0xB5, 0x90, 0x05, 0x27, 0xE0, 0xF5, 
+0x55, 0x12, 0x57, 0xC4, 0x90, 0x81, 0x40, 0x12, 0x77, 0xAC, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 
+0x12, 0x78, 0x00, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 0x12, 0x77, 0xBA, 0x54, 0x10, 0xFD, 
+0xEF, 0x54, 0xEF, 0x12, 0x78, 0x00, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 0x12, 0x77, 0xBA, 
+0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 0x4D, 0x90, 0x81, 0x40, 0xF0, 0xEE, 0xC3, 0x13, 0x20, 0xE0, 
+0x02, 0x41, 0x74, 0xE0, 0x30, 0xE0, 0x78, 0x31, 0x63, 0x75, 0x55, 0x21, 0x90, 0x81, 0x40, 0xE0, 
+0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0xF1, 0xDF, 0x43, 0x55, 0x08, 0x80, 0x0C, 0xE4, 0x90, 
+0x81, 0x41, 0xF0, 0xA3, 0xF0, 0x7D, 0x40, 0xFF, 0x31, 0x86, 0x90, 0x81, 0x40, 0x12, 0x70, 0xB4, 
+0x30, 0xE0, 0x03, 0x43, 0x55, 0x12, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x14, 
+0x90, 0x81, 0x40, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x80, 0x12, 0x5F, 
+0xD0, 0x20, 0xE0, 0x03, 0x43, 0x55, 0x40, 0x71, 0xB3, 0x90, 0x81, 0x43, 0xE0, 0x70, 0x05, 0x7F, 
+0x01, 0x12, 0x5C, 0x81, 0x12, 0x5B, 0xC3, 0x30, 0xE0, 0x04, 0x7F, 0x04, 0x80, 0x0C, 0x12, 0x5B, 
+0x43, 0xEF, 0x60, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x02, 0x12, 0x5C, 0x81, 0x41, 0xEC, 0x75, 
+0x55, 0x01, 0x71, 0xB3, 0x90, 0x81, 0x43, 0xE0, 0x64, 0x04, 0x60, 0x02, 0x61, 0x1F, 0xFF, 0x12, 
+0x5C, 0x81, 0x61, 0x1F, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x79, 0x31, 0x63, 0x43, 0x55, 0x31, 
+0x90, 0x81, 0x40, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0xF1, 0xDF, 0x43, 0x55, 0x08, 
+0x80, 0x06, 0x7D, 0x40, 0xE4, 0xFF, 0x31, 0x86, 0x90, 0x81, 0x40, 0x12, 0x70, 0xB4, 0x30, 0xE0, 
+0x03, 0x43, 0x55, 0x02, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x04, 0x71, 0xB3, 
+0x12, 0x5B, 0xC3, 0x30, 0xE0, 0x0B, 0x12, 0x5B, 0xBC, 0x60, 0x31, 0xE4, 0xFD, 0x7F, 0x02, 0x80, 
+0x1F, 0x12, 0x5E, 0x8E, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x02, 0x19, 0x12, 0x77, 0x66, 0x12, 0x5B, 
+0x43, 0xBF, 0x01, 0x09, 0x90, 0x81, 0x4B, 0xE0, 0xFF, 0x7D, 0x01, 0x80, 0x03, 0xE4, 0xFD, 0xFF, 
+0x71, 0xBE, 0x80, 0x08, 0x90, 0x81, 0x4C, 0xE0, 0x90, 0x81, 0x44, 0xF0, 0x90, 0x05, 0x40, 0x74, 
+0x22, 0xF0, 0x80, 0x2B, 0x75, 0x55, 0x01, 0x71, 0xB3, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x02, 0x06, 
+0x7D, 0x01, 0x7F, 0x04, 0x80, 0x0B, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x08, 0x06, 0x7D, 0x01, 0x7F, 
+0x0C, 0x71, 0xBE, 0x12, 0x6E, 0xE1, 0x90, 0x81, 0x4B, 0x12, 0x58, 0x62, 0x12, 0x52, 0x16, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x90, 0x82, 0x75, 0x12, 0x45, 0x15, 0x90, 0x82, 0x74, 0xEF, 0xF0, 0x12, 
+0x45, 0x1E, 0x4B, 0x5D, 0x00, 0x4B, 0x62, 0x01, 0x4B, 0x67, 0x02, 0x4B, 0x6C, 0x12, 0x4B, 0x71, 
+0x14, 0x4B, 0x76, 0x20, 0x4B, 0x7B, 0x21, 0x4B, 0x80, 0x23, 0x4B, 0x85, 0x24, 0x4B, 0x89, 0x25, 
+0x4B, 0x8E, 0x26, 0x4B, 0x93, 0x27, 0x4B, 0x98, 0xC0, 0x00, 0x00, 0x4B, 0x9D, 0x71, 0xAD, 0x02, 
+0x54, 0xB1, 0x71, 0xAD, 0x02, 0x52, 0xF3, 0x71, 0xAD, 0x02, 0x53, 0x52, 0x71, 0xAD, 0x02, 0x65, 
+0x08, 0x71, 0xAD, 0x02, 0x6D, 0x15, 0x71, 0xAD, 0x02, 0x53, 0x90, 0x71, 0xAD, 0x02, 0x54, 0xF5, 
+0x71, 0xAD, 0x02, 0x6D, 0x24, 0x71, 0xAD, 0x21, 0x91, 0x71, 0xAD, 0x02, 0x6D, 0x2C, 0x71, 0xAD, 
+0x02, 0x56, 0x4B, 0x71, 0xAD, 0x02, 0x55, 0x34, 0x71, 0xAD, 0x02, 0x6D, 0x34, 0x90, 0x01, 0xC0, 
+0xE0, 0x44, 0x01, 0xF0, 0x90, 0x82, 0x74, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0x90, 0x82, 0x75, 
+0x02, 0x45, 0x0C, 0x90, 0x05, 0x27, 0xE5, 0x55, 0xF0, 0x22, 0x7D, 0x01, 0x7F, 0x04, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0xD6, 0xED, 0xF0, 0x90, 0x81, 0x45, 0xE0, 0xFE, 0xC4, 
+0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0xA1, 0x07, 0xEE, 0x12, 0x76, 0x86, 0x30, 0xE0, 0x02, 
+0xA1, 0x07, 0x90, 0x81, 0x4C, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0xA1, 0x07, 0xEF, 0x70, 0x02, 0x81, 
+0x7A, 0x24, 0xFE, 0x70, 0x02, 0x81, 0xB3, 0x24, 0xFE, 0x60, 0x47, 0x24, 0xFC, 0x70, 0x02, 0x81, 
+0xEE, 0x24, 0xFC, 0x60, 0x02, 0xA1, 0x00, 0xEE, 0xB4, 0x0E, 0x02, 0xB1, 0x57, 0x90, 0x81, 0x4C, 
+0xE0, 0x70, 0x04, 0x7F, 0x01, 0xD1, 0x65, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x06, 0x02, 0xB1, 0x7B, 
+0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x04, 0x0D, 0x90, 0x82, 0xD6, 0xE0, 0xFF, 0x60, 0x04, 0xD1, 0xA4, 
+0x80, 0x02, 0xF1, 0xA2, 0x90, 0x81, 0x4C, 0xE0, 0x64, 0x08, 0x60, 0x02, 0xA1, 0x00, 0xF1, 0x35, 
+0xA1, 0x00, 0x90, 0x81, 0x4C, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0xD1, 0x65, 0x90, 0x81, 0x4C, 0xE0, 
+0xB4, 0x06, 0x02, 0xB1, 0x7B, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0E, 0x07, 0xB1, 0x0C, 0xBF, 0x01, 
+0x02, 0xB1, 0x57, 0x90, 0x81, 0x4C, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0xA1, 0x00, 0xB1, 0x0C, 0xEF, 
+0x64, 0x01, 0x60, 0x02, 0xA1, 0x00, 0xB1, 0xB4, 0xA1, 0x00, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0E, 
+0x07, 0xB1, 0x0C, 0xBF, 0x01, 0x02, 0xB1, 0x57, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x06, 0x02, 0xB1, 
+0x7B, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0C, 0x07, 0xB1, 0x0C, 0xBF, 0x01, 0x02, 0xB1, 0xB4, 0x90, 
+0x81, 0x4C, 0xE0, 0x64, 0x04, 0x70, 0x59, 0x12, 0x6E, 0x0D, 0xEF, 0x64, 0x01, 0x70, 0x51, 0xD1, 
+0x7D, 0x80, 0x4D, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0E, 0x07, 0xB1, 0x0C, 0xBF, 0x01, 0x02, 0xB1, 
+0x57, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x06, 0x02, 0xB1, 0x7B, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0C, 
+0x07, 0xB1, 0x0C, 0xBF, 0x01, 0x02, 0xB1, 0xB4, 0x90, 0x81, 0x4C, 0xE0, 0x70, 0x04, 0x7F, 0x01, 
+0xD1, 0x65, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x04, 0x17, 0x12, 0x77, 0x4E, 0x80, 0x12, 0x90, 0x81, 
+0x4C, 0xE0, 0xB4, 0x0C, 0x0B, 0x90, 0x81, 0x46, 0x12, 0x74, 0x02, 0x30, 0xE0, 0x02, 0xB1, 0xE4, 
+0x90, 0x81, 0x4C, 0x12, 0x77, 0xC1, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x6E, 0xC8, 0xEF, 
+0x64, 0x01, 0x60, 0x05, 0x12, 0x6E, 0x7E, 0x80, 0x35, 0x12, 0x76, 0xEA, 0x30, 0xE0, 0x08, 0x90, 
+0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x27, 0x90, 0x81, 0x4B, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x05, 
+0x12, 0x6E, 0x06, 0x80, 0x19, 0x90, 0x81, 0xF4, 0xE0, 0x30, 0xE0, 0x0F, 0x13, 0x13, 0x54, 0x3F, 
+0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x11, 0xF0, 0x80, 0x03, 0x02, 0x6E, 0xC0, 0x90, 0x01, 
+0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x81, 0x46, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x04, 
+0xB1, 0xF9, 0x80, 0x12, 0x12, 0x77, 0xDA, 0xF1, 0xD8, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x80, 0xF0, 
+0x90, 0x81, 0x44, 0x74, 0x04, 0xF0, 0xE4, 0xFD, 0xFF, 0x80, 0x2E, 0x90, 0x81, 0x46, 0xE0, 0x90, 
+0x06, 0x04, 0x20, 0xE0, 0x07, 0xE0, 0x44, 0x40, 0xF1, 0xD8, 0x80, 0x0F, 0xB1, 0xF5, 0x90, 0x05, 
+0x27, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x81, 0x44, 0x74, 0x0C, 0xF0, 0xE4, 0xFD, 0xFF, 0x80, 0x09, 
+0xE4, 0xFD, 0x7F, 0x0C, 0x71, 0xBE, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 0x90, 0x80, 
+0x40, 0xED, 0xF0, 0x22, 0x12, 0x47, 0xF3, 0x70, 0x2A, 0x90, 0x81, 0x46, 0xE0, 0x54, 0xFD, 0xF0, 
+0x7D, 0x2C, 0x7F, 0x6F, 0xB1, 0xA9, 0x7D, 0x08, 0x7F, 0x01, 0xD1, 0xDF, 0xBF, 0x01, 0x0F, 0x90, 
+0x81, 0x45, 0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x0E, 0xD1, 0x9C, 0x74, 0x0E, 0xF0, 0x22, 0x12, 0x76, 
+0x8E, 0x04, 0xF0, 0x22, 0x7D, 0x2F, 0x7F, 0xFF, 0xB1, 0xA9, 0x12, 0x5D, 0xA2, 0x7D, 0x08, 0xD1, 
+0x9C, 0x74, 0x08, 0xF0, 0x22, 0xE0, 0x54, 0x7F, 0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 0x14, 0x60, 0x15, 0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 
+0x1A, 0xED, 0x54, 0x01, 0xFE, 0x90, 0x81, 0x45, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0x80, 0x0C, 0x90, 
+0x81, 0x4C, 0xED, 0xF0, 0x80, 0x05, 0x90, 0x81, 0x4B, 0xED, 0xF0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 
+0xE4, 0x2E, 0xEC, 0x14, 0x60, 0x07, 0x14, 0x60, 0x1D, 0x24, 0x02, 0x70, 0x23, 0x90, 0x81, 0x45, 
+0xE0, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0xFF, 0x90, 0x81, 0x4C, 0xE0, 0x54, 0x7F, 
+0x4F, 0xFD, 0x7F, 0x88, 0x80, 0x07, 0x90, 0x81, 0x4B, 0xE0, 0xFD, 0x7F, 0x89, 0x12, 0x32, 0x1E, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x82, 0xD5, 0xEF, 0xF0, 0x12, 0x55, 0xE4, 0x90, 0x82, 0xD5, 
+0xE0, 0x60, 0x02, 0xF1, 0x43, 0x7D, 0x04, 0xD1, 0x9C, 0x74, 0x04, 0xF0, 0x22, 0x7D, 0x2D, 0x12, 
+0x5E, 0x06, 0x90, 0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x31, 0x0A, 0x12, 0x5D, 0xA2, 
+0xE4, 0xFD, 0x7F, 0x01, 0xB1, 0xFD, 0xE4, 0x90, 0x81, 0x44, 0xF0, 0x22, 0x7F, 0x01, 0xB1, 0xFD, 
+0x90, 0x81, 0x44, 0x22, 0xEF, 0x60, 0x33, 0x12, 0x47, 0xF3, 0x70, 0x2E, 0x90, 0x81, 0x46, 0xE0, 
+0x54, 0xFE, 0xF0, 0x7D, 0x2B, 0x7F, 0x0F, 0xB1, 0xA9, 0x90, 0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 
+0xD1, 0xDB, 0xBF, 0x01, 0x0F, 0x90, 0x81, 0x45, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x06, 0xD1, 0x9C, 
+0x74, 0x06, 0xF0, 0x22, 0x12, 0x76, 0x8E, 0x74, 0x08, 0xF0, 0x22, 0x7D, 0x08, 0xE4, 0xFF, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0xB1, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x80, 
+0x3E, 0xE0, 0x04, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x27, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x82, 
+0xB5, 0xF0, 0x7D, 0x26, 0x12, 0x5E, 0x06, 0xEF, 0x64, 0x01, 0x70, 0x03, 0x12, 0x5A, 0x72, 0x90, 
+0x82, 0xB5, 0xE0, 0xFF, 0x7D, 0x27, 0xB1, 0xA9, 0x90, 0x82, 0xB1, 0xE0, 0xFF, 0xF1, 0x48, 0x80, 
+0x0A, 0x90, 0x82, 0xB1, 0xE0, 0xFF, 0xF1, 0x48, 0x12, 0x5A, 0x72, 0x12, 0x5B, 0x1B, 0x7F, 0x01, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF1, 0x40, 0xB1, 0xF9, 0x90, 0x81, 0x44, 0x74, 0x0C, 0xF0, 0x22, 
+0x12, 0x55, 0xE4, 0xE4, 0xFD, 0xFF, 0xA1, 0xA9, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x82, 0xD8, 0xEF, 0xF0, 0x90, 0x80, 0x44, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 0x3D, 
+0x90, 0x81, 0x4C, 0xE0, 0x64, 0x0E, 0x70, 0x14, 0x90, 0x82, 0xD8, 0xE0, 0x70, 0x2F, 0x90, 0x81, 
+0x45, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x04, 0xB1, 0xF5, 0x80, 0x1F, 0x90, 0x81, 0x4C, 0xE0, 
+0x64, 0x06, 0x70, 0x19, 0x90, 0x82, 0xD8, 0xE0, 0x60, 0x13, 0x90, 0x81, 0x45, 0xE0, 0x54, 0xBF, 
+0xF0, 0x12, 0x77, 0xDA, 0xF0, 0x90, 0x81, 0x4C, 0x74, 0x04, 0xF0, 0xF1, 0x43, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x12, 0x73, 0xEE, 0xF1, 0x43, 0x7D, 0x0C, 0x7F, 0x01, 0xA1, 0xFD, 0x12, 0x76, 0xB5, 
+0x90, 0x81, 0x4C, 0xE0, 0x64, 0x0C, 0x60, 0x04, 0xB1, 0xA0, 0xD1, 0xDB, 0x22, 0x90, 0x81, 0x49, 
+0xE0, 0x64, 0x01, 0x70, 0x12, 0x12, 0x54, 0x61, 0x60, 0x05, 0xB1, 0xA0, 0x02, 0x76, 0xB5, 0x90, 
+0x81, 0x4C, 0xE0, 0x70, 0x02, 0x71, 0xBA, 0x22, 0xF0, 0x7D, 0x04, 0x7F, 0x01, 0xA1, 0xFD, 0x90, 
+0x01, 0x34, 0x74, 0x40, 0xF0, 0xFD, 0xE4, 0xFF, 0x21, 0x0A, 0x7D, 0x1F, 0x7F, 0x6F, 0xB1, 0xA9, 
+0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x81, 0x43, 0x74, 0x04, 0xF0, 0x22, 0x90, 0x01, 
+0xC8, 0xE4, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x07, 0x7F, 0xFF, 0xFE, 
+0x12, 0x2B, 0x27, 0xBF, 0x01, 0x09, 0x90, 0x82, 0x07, 0xE0, 0x64, 0x03, 0x60, 0x03, 0x22, 0x01, 
+0xC0, 0xE4, 0x90, 0x82, 0x0C, 0xF0, 0x90, 0x82, 0x0C, 0xE0, 0xFF, 0xC3, 0x94, 0x02, 0x40, 0x02, 
+0x01, 0xFB, 0xC3, 0x74, 0xFE, 0x9F, 0xFF, 0xE4, 0x94, 0x00, 0xFE, 0x7B, 0x01, 0x7A, 0x82, 0x79, 
+0x08, 0x12, 0x2B, 0x27, 0xEF, 0x64, 0x01, 0x70, 0x77, 0x90, 0x82, 0x08, 0xE0, 0xFF, 0x54, 0xC0, 
+0xFE, 0x60, 0x05, 0xEF, 0x54, 0x0C, 0x70, 0x16, 0x90, 0x82, 0x08, 0xE0, 0xFF, 0x54, 0x30, 0x60, 
+0x67, 0xEF, 0x54, 0x03, 0x60, 0x62, 0x90, 0x82, 0x09, 0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 
+0x82, 0x09, 0xF0, 0x90, 0x82, 0x09, 0xE0, 0x90, 0x82, 0x08, 0x70, 0x16, 0xE0, 0xFF, 0xEE, 0x13, 
+0x13, 0x54, 0x3F, 0x90, 0x82, 0x0A, 0xF0, 0xEF, 0x54, 0x0C, 0x13, 0x13, 0x54, 0x3F, 0xA3, 0xF0, 
+0x80, 0x0D, 0xE0, 0xFE, 0x54, 0x30, 0x90, 0x82, 0x0A, 0xF0, 0xEE, 0x54, 0x03, 0xA3, 0xF0, 0x90, 
+0x82, 0x0A, 0xE0, 0x64, 0x30, 0x70, 0x54, 0xA3, 0xE0, 0x64, 0x02, 0x70, 0x4E, 0x90, 0x00, 0xF5, 
+0xE0, 0x54, 0x40, 0x90, 0x82, 0x0D, 0xF0, 0xE0, 0x70, 0x41, 0xA3, 0x74, 0x02, 0xF0, 0x80, 0x10, 
+0x90, 0x82, 0x0E, 0x74, 0x01, 0xF0, 0x80, 0x08, 0x90, 0x82, 0x0C, 0xE0, 0x04, 0xF0, 0x01, 0x26, 
+0x90, 0x01, 0xC4, 0x74, 0xFE, 0xF0, 0x74, 0x4F, 0xA3, 0xF0, 0x90, 0x82, 0x0E, 0xE0, 0x90, 0x01, 
+0xC8, 0xF0, 0x90, 0x82, 0x08, 0xE0, 0x90, 0x01, 0xC9, 0xF0, 0x90, 0x82, 0x09, 0xE0, 0x90, 0x01, 
+0xCA, 0xF0, 0xE4, 0xFD, 0x7F, 0x1F, 0x12, 0x32, 0x1E, 0x80, 0xD5, 0x22, 0x90, 0x00, 0x80, 0xE0, 
+0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x90, 0xFD, 0x00, 0xE0, 0x54, 0xBF, 0xF0, 0x12, 
+0x4F, 0xFE, 0x12, 0x6D, 0x91, 0x12, 0x32, 0x77, 0x12, 0x6D, 0x9E, 0x31, 0x53, 0x7F, 0x01, 0x12, 
+0x42, 0x15, 0x90, 0x81, 0xFA, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x42, 0x15, 0x90, 0x81, 0xFA, 0xE0, 
+0x04, 0xF0, 0x51, 0x34, 0x31, 0x64, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 
+0x32, 0x1E, 0x75, 0x20, 0xFF, 0x12, 0x58, 0x07, 0x12, 0x64, 0x1D, 0x12, 0x6E, 0xEA, 0xE4, 0xFF, 
+0x02, 0x42, 0x9E, 0xE4, 0x90, 0x80, 0x3C, 0x31, 0x5C, 0xA3, 0xF0, 0x22, 0xF0, 0xA3, 0xF0, 0xA3, 
+0xF0, 0xA3, 0xF0, 0x22, 0x31, 0x77, 0x12, 0x6D, 0x42, 0x51, 0x16, 0x12, 0x73, 0x34, 0x12, 0x77, 
+0x76, 0x12, 0x74, 0x15, 0x02, 0x45, 0x44, 0xE4, 0xFD, 0xFF, 0x12, 0x77, 0xCE, 0xED, 0x70, 0x12, 
+0x31, 0xB6, 0xC0, 0x83, 0xC0, 0x82, 0x31, 0xAE, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 
+0x80, 0x0F, 0x31, 0xB6, 0xC0, 0x83, 0xC0, 0x82, 0x31, 0xAE, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
+0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x31, 0xC1, 0x90, 0x81, 0x3E, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 
+0x74, 0x01, 0xA8, 0x07, 0x08, 0x22, 0x74, 0x36, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7D, 0x08, 0xED, 0x14, 0xF9, 0x24, 0x36, 0x31, 
+0xB9, 0xE0, 0x60, 0x39, 0x7C, 0x08, 0xEC, 0x14, 0x90, 0x82, 0xD2, 0xF0, 0x74, 0x36, 0x29, 0x31, 
+0xB9, 0xE0, 0xFB, 0x7A, 0x00, 0x90, 0x82, 0xD2, 0xF1, 0xD4, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 
+0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 0x5B, 0x4E, 0x60, 0x0F, 0xE9, 0x75, 0xF0, 0x08, 
+0xA4, 0xFF, 0x90, 0x82, 0xD2, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 0x06, 0xDC, 0xC9, 0xDD, 0xBB, 0x7F, 
+0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7E, 0x00, 0x7F, 0x01, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 
+0x79, 0x40, 0x12, 0x45, 0x44, 0x90, 0x81, 0x40, 0xE0, 0x54, 0xFD, 0xF0, 0xE4, 0x31, 0x5D, 0xA3, 
+0x74, 0x0C, 0xF0, 0x22, 0xF1, 0xED, 0x90, 0x80, 0x41, 0xEF, 0xF0, 0x51, 0x54, 0x90, 0x01, 0x64, 
+0x74, 0x01, 0xF0, 0x90, 0x00, 0x12, 0xE0, 0x54, 0xC7, 0x44, 0x20, 0xFD, 0x7F, 0x12, 0x12, 0x32, 
+0x1E, 0x02, 0x2D, 0xA7, 0x51, 0x84, 0x51, 0xAA, 0x12, 0x6D, 0x50, 0x12, 0x6D, 0x6F, 0xE4, 0xF5, 
+0x35, 0xF5, 0x36, 0xF5, 0x37, 0x75, 0x38, 0x80, 0xAD, 0x35, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xAD, 
+0x36, 0x7F, 0x51, 0x12, 0x32, 0x1E, 0xAD, 0x37, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xAD, 0x38, 0x7F, 
+0x53, 0x02, 0x32, 0x1E, 0x90, 0x01, 0x30, 0xE4, 0x31, 0x5C, 0x90, 0x01, 0x38, 0x31, 0x5C, 0xFD, 
+0x7F, 0x50, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x51, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x52, 
+0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x53, 0x02, 0x32, 0x1E, 0x90, 0x01, 0x34, 0x74, 0xFF, 0x31, 
+0x5C, 0x90, 0x01, 0x3C, 0x31, 0x5C, 0xFD, 0x7F, 0x54, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x55, 
+0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x56, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x57, 0x02, 0x32, 
+0x1E, 0x12, 0x77, 0xCE, 0x31, 0xB6, 0xE0, 0xFD, 0x7C, 0x00, 0xF1, 0xD6, 0x80, 0x05, 0xC3, 0x33, 
+0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 0x7F, 0x00, 0x60, 0x02, 
+0x7F, 0x01, 0x22, 0xF1, 0xB5, 0x71, 0x4C, 0xFF, 0xF5, 0x56, 0x12, 0x1F, 0xA4, 0xFE, 0xC3, 0x13, 
+0x30, 0xE0, 0x06, 0x91, 0xAB, 0xF5, 0x57, 0x80, 0x02, 0x8F, 0x57, 0x85, 0x56, 0x55, 0xE5, 0x55, 
+0xD3, 0x95, 0x57, 0x50, 0x23, 0xAB, 0x52, 0xAA, 0x53, 0xA9, 0x54, 0x12, 0x1F, 0xA4, 0x54, 0x01, 
+0xFD, 0xAF, 0x55, 0x31, 0x7A, 0xAF, 0x55, 0x51, 0xD1, 0xEF, 0xAF, 0x55, 0x70, 0x04, 0xF1, 0xDF, 
+0x80, 0x02, 0xF1, 0xDE, 0x05, 0x55, 0x80, 0xD6, 0xE5, 0x56, 0x70, 0x0E, 0xFF, 0x51, 0xD1, 0xEF, 
+0x70, 0x08, 0xB1, 0xD7, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x22, 0xF0, 0x90, 0x00, 0x01, 0x02, 
+0x1F, 0xBD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0xB5, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 
+0x81, 0x3F, 0xF0, 0xBF, 0x01, 0x08, 0x71, 0x4C, 0x64, 0x01, 0x60, 0x1F, 0x80, 0x1A, 0xAB, 0x52, 
+0xAA, 0x53, 0xA9, 0x54, 0x71, 0x4C, 0x64, 0x01, 0x60, 0x11, 0x90, 0x81, 0x40, 0xE0, 0x20, 0xE0, 
+0x07, 0xE4, 0xFF, 0x12, 0x5C, 0x81, 0x80, 0x03, 0x12, 0x5C, 0x5D, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0x82, 0x78, 0x12, 0x45, 0x15, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x7F, 0x90, 0x81, 0x49, 0xF0, 
+0xEF, 0x12, 0x76, 0x86, 0xA3, 0x71, 0x4B, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0x81, 
+0x47, 0xE0, 0x54, 0xF0, 0x4E, 0xB1, 0x2D, 0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 0x81, 0x45, 0xE0, 
+0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0x91, 0x61, 0x4F, 0x91, 0xAA, 
+0x90, 0x81, 0x48, 0x91, 0x53, 0x30, 0xE0, 0x52, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 0x04, 
+0x90, 0x81, 0x5C, 0x50, 0x04, 0xEF, 0xF0, 0x80, 0x2A, 0x74, 0x03, 0xF0, 0x91, 0x4D, 0xE9, 0x24, 
+0x06, 0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x1F, 0xA4, 0xFF, 0x74, 0x03, 0x24, 0xFD, 0xFE, 0xEF, 0xC4, 
+0x54, 0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 0xED, 0x2E, 0x54, 0x0F, 0xFE, 0xC4, 0x54, 0xF0, 0x4F, 
+0x12, 0x1F, 0xEA, 0x91, 0x4D, 0x91, 0x54, 0xC4, 0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x81, 
+0x51, 0x50, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 0x91, 0x4D, 0x90, 0x00, 0x04, 0x12, 
+0x1F, 0xBD, 0xFD, 0x7F, 0x02, 0x12, 0x4D, 0xFD, 0x91, 0x4D, 0x91, 0x82, 0x12, 0x76, 0x8E, 0xF0, 
+0x90, 0x81, 0x49, 0x12, 0x77, 0xC1, 0x91, 0x60, 0x90, 0x01, 0xBE, 0xF0, 0x22, 0x90, 0x82, 0x78, 
+0x02, 0x45, 0x0C, 0xF0, 0x90, 0x00, 0x06, 0x02, 0x1F, 0xBD, 0x90, 0x81, 0x4D, 0xE0, 0x44, 0x01, 
+0xF0, 0x90, 0x81, 0x47, 0xE0, 0x54, 0x0F, 0x22, 0xE4, 0xFF, 0x51, 0xD1, 0xBF, 0x01, 0x12, 0x90, 
+0x81, 0x49, 0xE0, 0x60, 0x0C, 0x91, 0x61, 0x64, 0x02, 0x60, 0x03, 0x02, 0x59, 0x4E, 0x12, 0x4F, 
+0xAD, 0x22, 0x90, 0x82, 0x7B, 0x12, 0x45, 0x15, 0x12, 0x76, 0xF4, 0x90, 0x81, 0x49, 0xE0, 0xFF, 
+0xB1, 0x60, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x11, 0x90, 0x82, 0x7B, 0x12, 0x45, 0x0C, 0x71, 0x4C, 
+0x54, 0x0F, 0xFF, 0x91, 0xAB, 0xFD, 0x12, 0x77, 0x21, 0x22, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x1F, 
+0xBD, 0x90, 0x02, 0x09, 0xE0, 0xF5, 0x52, 0x12, 0x1F, 0xA4, 0x25, 0x52, 0x90, 0x80, 0x42, 0x71, 
+0x4B, 0x25, 0x52, 0x90, 0x80, 0x43, 0x91, 0xAA, 0x25, 0x52, 0x90, 0x80, 0x44, 0xB1, 0x2D, 0x25, 
+0x52, 0x90, 0x80, 0x45, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0x25, 0x52, 0x90, 0x80, 0x46, 
+0xF0, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0x25, 0x52, 0x90, 0x80, 0x47, 0x91, 0x53, 0x25, 0x52, 
+0x90, 0x80, 0x48, 0xF0, 0x22, 0x91, 0xAB, 0xFF, 0x30, 0xE0, 0x1C, 0x12, 0x1F, 0xA4, 0x90, 0x81, 
+0xED, 0x71, 0x4B, 0x90, 0x81, 0xEE, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0x4F, 
+0xB1, 0x2D, 0x90, 0x81, 0xF0, 0xF0, 0x22, 0x90, 0x81, 0xED, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x0A, 
+0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 0x1E, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x22, 0xF0, 0x90, 0x00, 
+0x03, 0x02, 0x1F, 0xBD, 0xF1, 0xC4, 0x12, 0x77, 0xF0, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 
+0x54, 0xFD, 0x4F, 0x71, 0x4B, 0x90, 0x81, 0xF7, 0x91, 0xAA, 0x90, 0x81, 0xF8, 0xF0, 0x90, 0x81, 
+0xF7, 0xE0, 0x90, 0x81, 0xF9, 0xF0, 0x90, 0x81, 0xF6, 0xE0, 0x54, 0x01, 0xFF, 0x02, 0x49, 0x16, 
+0xEF, 0x70, 0x39, 0x7D, 0x78, 0x7F, 0x02, 0x12, 0x49, 0x86, 0x7D, 0x02, 0x7F, 0x03, 0x12, 0x49, 
+0x86, 0x7D, 0xC8, 0x7F, 0x02, 0xF1, 0xBC, 0xF1, 0xAA, 0xF0, 0xE4, 0xFF, 0x51, 0xD1, 0xEF, 0x70, 
+0x0A, 0xB1, 0xD7, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x80, 0x07, 0x7D, 0x01, 0x7F, 0x0C, 0x12, 
+0x4B, 0xBE, 0xB1, 0xDC, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 0x90, 0x01, 0x36, 0x74, 
+0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x12, 0x49, 0x0A, 0x7D, 0x02, 0x7F, 0x03, 
+0x12, 0x49, 0x0A, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0xF1, 0xE2, 0xE4, 0xFF, 0x51, 0xD1, 0xBF, 
+0x01, 0x11, 0xF1, 0x81, 0xF0, 0x90, 0x81, 0x4C, 0xE0, 0x20, 0xE2, 0x0A, 0x7D, 0x01, 0x7F, 0x04, 
+0x02, 0x4B, 0xBE, 0xD1, 0xA9, 0xF0, 0x22, 0xB1, 0xE4, 0x12, 0x4F, 0xA2, 0x90, 0x81, 0x45, 0xE0, 
+0x54, 0xF7, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x01, 0x01, 0xE0, 0x44, 
+0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 
+0xB4, 0x74, 0x86, 0xF0, 0x12, 0x5F, 0xB9, 0xEC, 0x54, 0x7F, 0xFC, 0x90, 0x82, 0xBA, 0x12, 0x20, 
+0xCE, 0x90, 0x82, 0xBA, 0x12, 0x5E, 0x96, 0x7F, 0x7C, 0xD1, 0x42, 0x12, 0x20, 0xDA, 0xCC, 0xC0, 
+0x00, 0xC0, 0x7F, 0x8C, 0xD1, 0x42, 0x12, 0x20, 0xDA, 0x00, 0xC0, 0x00, 0x14, 0x12, 0x77, 0xE5, 
+0x12, 0x20, 0xDA, 0x00, 0x03, 0x3E, 0x60, 0xE4, 0xFD, 0xFF, 0x12, 0x67, 0xD3, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x22, 0xF1, 0xC4, 0x90, 0x81, 0xF4, 
+0x12, 0x77, 0xAC, 0x54, 0x04, 0x25, 0xE0, 0xFD, 0xEF, 0x54, 0xF7, 0x4D, 0x90, 0x81, 0xF4, 0x71, 
+0x4B, 0xFF, 0x90, 0x05, 0x54, 0xE0, 0xC3, 0x9F, 0x90, 0x81, 0xF5, 0xF0, 0xEE, 0x20, 0xE0, 0x03, 
+0x12, 0x4F, 0x40, 0x90, 0x81, 0xF4, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x15, 0x90, 0x81, 0x49, 0x74, 
+0x01, 0xF0, 0xE4, 0x90, 0x81, 0x4B, 0xF0, 0xD1, 0xA9, 0xF0, 0x90, 0x05, 0x58, 0x74, 0x05, 0xF0, 
+0x22, 0xE4, 0x90, 0x81, 0x49, 0xF0, 0x90, 0x81, 0x4B, 0x74, 0x0C, 0xF0, 0x90, 0x81, 0x45, 0xE0, 
+0x54, 0xFE, 0xF0, 0xA3, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x90, 0x81, 0x46, 0xE0, 0x44, 0x04, 0x22, 
+0x12, 0x74, 0x23, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x81, 0xFE, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x12, 0x47, 0xF3, 0x60, 0x02, 0xE1, 0x60, 0x90, 0x81, 0x49, 0xE0, 0x70, 0x02, 
+0xE1, 0x60, 0xF1, 0x6E, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x81, 0x50, 0xF0, 
+0x90, 0x06, 0xAA, 0xE0, 0x90, 0x81, 0x4F, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x81, 0x4F, 
+0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 0x81, 0x50, 0xEF, 0xF0, 0x12, 0x71, 0xBC, 0xD1, 0xA9, 0xF0, 
+0xE4, 0x90, 0x81, 0x52, 0xF1, 0xE2, 0xF1, 0xAA, 0x12, 0x74, 0x0C, 0x54, 0xEF, 0xF1, 0x6D, 0x24, 
+0xFD, 0x50, 0x02, 0x80, 0x0F, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x05, 0x12, 0x58, 0xE3, 0x80, 
+0x03, 0x12, 0x58, 0x9E, 0x12, 0x70, 0xB1, 0x30, 0xE0, 0x36, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 
+0x20, 0xE0, 0x2D, 0x90, 0x81, 0x4F, 0xE0, 0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x23, 0x90, 0x81, 0x46, 
+0xE0, 0x44, 0x40, 0xF0, 0x12, 0x75, 0x3B, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 
+0x03, 0x12, 0x49, 0x67, 0x12, 0x49, 0x82, 0x12, 0x73, 0xE7, 0x90, 0x81, 0x50, 0xE0, 0x14, 0xF0, 
+0x90, 0x81, 0x40, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x03, 0xD1, 0xA9, 0xF0, 0x22, 0xF0, 0x90, 0x81, 
+0x47, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x22, 0x12, 0x4F, 0x40, 0x90, 0x81, 0x43, 0x74, 0x01, 0xF0, 
+0x22, 0x90, 0x81, 0x46, 0xE0, 0x54, 0xFB, 0x22, 0x90, 0x01, 0x57, 0xE0, 0x60, 0x1B, 0xF1, 0xAD, 
+0xF0, 0x12, 0x73, 0xFF, 0x30, 0xE0, 0x03, 0x02, 0x74, 0x09, 0x12, 0x71, 0x38, 0x40, 0x0A, 0xE4, 
+0xFF, 0x51, 0xD1, 0xBF, 0x01, 0x03, 0xF1, 0x81, 0xF0, 0x22, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 
+0x01, 0x3C, 0x74, 0x02, 0x22, 0x8B, 0x52, 0x8A, 0x53, 0x89, 0x54, 0x22, 0x74, 0x45, 0x12, 0x77, 
+0xF8, 0x02, 0x49, 0x6D, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x22, 0x12, 0x4F, 0x43, 0x12, 
+0x5E, 0x8E, 0x80, 0xA6, 0xE0, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0x22, 0x22, 
+0x80, 0x98, 0xF0, 0x90, 0x81, 0x55, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0x90, 0x00, 0xF7, 
+0xE0, 0x20, 0xE7, 0x09, 0xE0, 0x7F, 0x01, 0x20, 0xE6, 0x0C, 0x7F, 0x02, 0x22, 0x90, 0x00, 0xF7, 
+0xE0, 0x30, 0xE6, 0x02, 0x7F, 0x03, 0x22, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x84, 0x22, 0xE4, 0x90, 
+0x82, 0x0F, 0xF0, 0x90, 0x82, 0x0F, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0x0E, 0x90, 0x01, 0xC4, 0xF0, 
+0x74, 0x58, 0xA3, 0xF0, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x0E, 0x90, 0x81, 0x4C, 0xE0, 0xFF, 0x90, 
+0x81, 0x4B, 0xE0, 0x6F, 0x60, 0x02, 0x11, 0x54, 0xC2, 0xAF, 0x12, 0x6D, 0xCE, 0xBF, 0x01, 0x02, 
+0x71, 0xF6, 0xD2, 0xAF, 0xF1, 0xA6, 0x12, 0x32, 0x9E, 0xBF, 0x01, 0x03, 0x12, 0x6C, 0x8B, 0x12, 
+0x41, 0x4D, 0x80, 0xBF, 0x90, 0x81, 0x40, 0xE0, 0x90, 0x81, 0x4B, 0x30, 0xE0, 0x04, 0xE0, 0xFF, 
+0x61, 0x2A, 0xE0, 0xFF, 0x7D, 0x01, 0x02, 0x4B, 0xBE, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x0F, 0x90, 
+0x06, 0x92, 0xE0, 0x30, 0xE1, 0x03, 0x02, 0x76, 0xB5, 0x12, 0x55, 0xDC, 0x11, 0x54, 0x22, 0xE4, 
+0xFF, 0x12, 0x52, 0xD1, 0xBF, 0x01, 0x0E, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x08, 0x11, 0x96, 0x54, 
+0x07, 0x70, 0x02, 0x11, 0x54, 0x22, 0x90, 0x81, 0x4D, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0xE4, 0xF5, 
+0x4E, 0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x4E, 0x54, 0xC0, 0x70, 0x07, 0x11, 0x96, 0x54, 0xFD, 0xF0, 
+0x80, 0xA2, 0xE5, 0x4E, 0x30, 0xE6, 0x18, 0x90, 0x81, 0x49, 0xE0, 0x64, 0x01, 0x70, 0x12, 0x12, 
+0x54, 0x5A, 0x64, 0x02, 0x60, 0x04, 0x31, 0x4E, 0x80, 0x07, 0x12, 0x4F, 0xAD, 0x80, 0x02, 0x11, 
+0x96, 0xE5, 0x4E, 0x90, 0x81, 0x4D, 0x30, 0xE7, 0x05, 0x12, 0x47, 0x7A, 0x61, 0x22, 0xE0, 0x54, 
+0xFD, 0xF0, 0x22, 0x90, 0x06, 0xA9, 0xE0, 0x90, 0x82, 0x00, 0xF0, 0xE0, 0xFD, 0x54, 0xC0, 0x70, 
+0x04, 0x11, 0x96, 0x80, 0x55, 0xED, 0x30, 0xE6, 0x3F, 0x90, 0x81, 0x49, 0xE0, 0x64, 0x02, 0x70, 
+0x27, 0x90, 0x81, 0x45, 0xE0, 0xFF, 0xC3, 0x13, 0x20, 0xE0, 0x09, 0x90, 0x81, 0x4D, 0xE0, 0x44, 
+0x01, 0xF0, 0x80, 0x1B, 0x12, 0x54, 0x61, 0x64, 0x01, 0x70, 0x1F, 0x90, 0x81, 0x4D, 0xE0, 0x44, 
+0x04, 0xF0, 0x7F, 0x01, 0x31, 0xEB, 0x80, 0x12, 0x12, 0x54, 0x5A, 0x64, 0x02, 0x60, 0x04, 0x31, 
+0x4E, 0x80, 0x07, 0x12, 0x4F, 0xAD, 0x80, 0x02, 0x11, 0x96, 0x90, 0x82, 0x00, 0xE0, 0x90, 0x81, 
+0x4D, 0x30, 0xE7, 0x05, 0x12, 0x47, 0x7A, 0x61, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x04, 
+0x1D, 0xE0, 0x70, 0x15, 0x90, 0x80, 0x43, 0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 0x31, 0x6A, 0x90, 
+0x82, 0x01, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x71, 0x1B, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x82, 0xC7, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x82, 0xC6, 0xEF, 0xF0, 0xE4, 0xFD, 
+0xFC, 0x12, 0x77, 0x98, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0x82, 0xC6, 0xE0, 0x90, 0x04, 0x25, 0xF0, 
+0x90, 0x82, 0xC7, 0xE0, 0x60, 0x0E, 0x74, 0x0F, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x08, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE4, 0xF0, 0x74, 0x09, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 
+0xAF, 0x05, 0x51, 0xFC, 0xE0, 0x54, 0x01, 0xFE, 0x90, 0x82, 0xC8, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 
+0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0x51, 0xFC, 0xEE, 0xF0, 0x74, 0x21, 0x2F, 0x51, 0x5C, 0x54, 
+0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0x82, 0xC2, 0xEF, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x1D, 0x90, 0x05, 0x22, 
+0xE0, 0x90, 0x82, 0xC5, 0xF0, 0x7D, 0x29, 0xD1, 0x06, 0xBF, 0x01, 0x02, 0x51, 0x23, 0x90, 0x82, 
+0xC5, 0xE0, 0xFF, 0x7D, 0x2A, 0x12, 0x4D, 0xA9, 0x80, 0x02, 0x51, 0x23, 0x71, 0x1B, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x80, 0x45, 0xE0, 0xFF, 0x7B, 0x08, 0x7D, 0x01, 0x31, 0x6A, 0x90, 0x82, 
+0xC3, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x82, 0xC2, 0xE0, 0xFF, 0x51, 0x66, 0x54, 
+0x3F, 0xF0, 0xEF, 0x60, 0x0A, 0x51, 0x59, 0x44, 0x10, 0x51, 0x65, 0x44, 0x80, 0xF0, 0x22, 0x51, 
+0x59, 0x54, 0xEF, 0x51, 0x65, 0x44, 0x40, 0xF0, 0x22, 0x74, 0x21, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 
+0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0x22, 0x90, 0x80, 0x44, 0xE0, 0xFF, 0x90, 0x82, 0xB2, 0xE0, 0xFB, 0x7D, 0x01, 0x31, 0x6A, 
+0x90, 0x82, 0xB3, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x82, 0xB1, 0xE0, 0xFF, 0x51, 
+0x3D, 0x90, 0x82, 0xB3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x04, 0x80, 0xE0, 0x54, 0x0F, 0xFD, 
+0xAC, 0x07, 0x71, 0x0F, 0x44, 0x01, 0xF0, 0x71, 0x0F, 0x54, 0xFB, 0xF0, 0xAC, 0x07, 0x74, 0x16, 
+0x2C, 0x51, 0xFF, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x15, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0xE0, 0x44, 0x0F, 0xF0, 0x90, 0x04, 0x53, 0xE4, 0xF0, 0x90, 0x04, 0x52, 0xF0, 0x90, 0x04, 
+0x51, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0x50, 0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 0x71, 0x07, 0xE0, 
+0x54, 0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 0x71, 0x07, 0xED, 0xF0, 0x22, 0x74, 0x16, 0x2F, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 
+0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x90, 0x04, 0x1F, 0x74, 0x20, 
+0xF0, 0x22, 0x90, 0x81, 0x45, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xAE, 0x07, 0x71, 0x43, 0xBF, 0x01, 
+0x0F, 0xF1, 0xD0, 0x20, 0xE0, 0x0A, 0xAF, 0x06, 0x7D, 0x01, 0x12, 0x4B, 0xBE, 0x7F, 0x01, 0x22, 
+0x7F, 0x00, 0x22, 0x90, 0x05, 0x43, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0x12, 
+0x47, 0xF3, 0x70, 0x17, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x11, 0x12, 0x57, 0xAA, 0xF0, 0x90, 0x81, 
+0x45, 0xE0, 0x12, 0x74, 0x0A, 0x54, 0x07, 0x70, 0x02, 0x11, 0x54, 0x22, 0x90, 0x81, 0x49, 0xE0, 
+0x70, 0x07, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x11, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x07, 
+0x71, 0x43, 0xBF, 0x01, 0x05, 0x80, 0x04, 0x12, 0x4F, 0xBD, 0x22, 0x90, 0x81, 0x49, 0xE0, 0x64, 
+0x02, 0x60, 0x11, 0x12, 0x54, 0x61, 0x60, 0x0C, 0x12, 0x6E, 0xC8, 0xEF, 0x70, 0x06, 0xFD, 0x7F, 
+0x0C, 0x12, 0x4B, 0xBE, 0x22, 0x71, 0xC3, 0x30, 0xE0, 0x0B, 0x71, 0xBC, 0x60, 0x07, 0x7D, 0x01, 
+0x7F, 0x02, 0x12, 0x4B, 0xBE, 0x71, 0xBC, 0x60, 0x02, 0x71, 0x8B, 0x22, 0x90, 0x81, 0x44, 0xE0, 
+0x64, 0x02, 0x22, 0x90, 0x81, 0x40, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x90, 0x81, 
+0x45, 0x71, 0xC6, 0x30, 0xE0, 0x1F, 0xEF, 0x54, 0xBF, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x81, 
+0x46, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x09, 0xE0, 0x54, 0xFE, 0x12, 0x76, 0x8D, 
+0x74, 0x04, 0xF0, 0x11, 0x54, 0x22, 0x90, 0x81, 0x45, 0xE0, 0x30, 0xE0, 0x19, 0x90, 0x81, 0x40, 
+0xE0, 0xFF, 0x30, 0xE0, 0x0F, 0xC3, 0x13, 0x30, 0xE0, 0x08, 0x12, 0x77, 0x8B, 0xBF, 0x01, 0x06, 
+0x80, 0x02, 0x80, 0x00, 0x91, 0x17, 0x22, 0x90, 0x81, 0x4C, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 
+0x0E, 0x12, 0x6E, 0x85, 0xBF, 0x01, 0x08, 0x91, 0x30, 0x90, 0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x63, 0xD1, 0x91, 0x41, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x12, 0x76, 0x98, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 0xFD, 0x7F, 0x08, 0x12, 0x32, 0x1E, 
+0xE4, 0xFF, 0x12, 0x63, 0x7D, 0x90, 0x81, 0x46, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x3F, 0xE0, 0xB4, 0x01, 0x04, 0x7F, 0x04, 0x80, 0x0B, 0x71, 
+0x43, 0xBF, 0x01, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x02, 0x91, 0x81, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x43, 0xE0, 0x90, 0x82, 0xD7, 0xF0, 
+0x6F, 0x70, 0x02, 0xA1, 0x8B, 0xEF, 0x14, 0x60, 0x42, 0x14, 0x60, 0x6F, 0x14, 0x70, 0x02, 0xA1, 
+0x36, 0x14, 0x70, 0x02, 0xA1, 0x61, 0x24, 0x04, 0x60, 0x02, 0xA1, 0x8B, 0x90, 0x82, 0xD7, 0xE0, 
+0xB4, 0x04, 0x04, 0xD1, 0x6F, 0xA1, 0x8B, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x02, 0x04, 0xD1, 0x7E, 
+0xA1, 0x8B, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x03, 0x04, 0xD1, 0x7A, 0xA1, 0x8B, 0x90, 0x82, 0xD7, 
+0xE0, 0x64, 0x01, 0x60, 0x02, 0xA1, 0x8B, 0xD1, 0x72, 0xA1, 0x8B, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 
+0x04, 0x05, 0x12, 0x57, 0xCC, 0xA1, 0x8B, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x02, 0x05, 0x12, 0x57, 
+0x77, 0xA1, 0x8B, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x03, 0x04, 0xD1, 0x88, 0xA1, 0x8B, 0x90, 0x82, 
+0xD7, 0xE0, 0x60, 0x02, 0xA1, 0x8B, 0x12, 0x57, 0xE0, 0xA1, 0x8B, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 
+0x04, 0x04, 0xD1, 0x00, 0x80, 0x75, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x01, 0x04, 0xB1, 0x92, 0x80, 
+0x6A, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x03, 0x04, 0xB1, 0x90, 0x80, 0x5F, 0x90, 0x82, 0xD7, 0xE0, 
+0x70, 0x59, 0xD1, 0x4E, 0x80, 0x55, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x04, 0x04, 0xD1, 0x64, 0x80, 
+0x4A, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x01, 0x04, 0xD1, 0x56, 0x80, 0x3F, 0x90, 0x82, 0xD7, 0xE0, 
+0xB4, 0x02, 0x04, 0xD1, 0x83, 0x80, 0x34, 0x90, 0x82, 0xD7, 0xE0, 0x70, 0x2E, 0xD1, 0x53, 0x80, 
+0x2A, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x03, 0x04, 0xF1, 0xA7, 0x80, 0x1F, 0x90, 0x82, 0xD7, 0xE0, 
+0xB4, 0x01, 0x05, 0x12, 0x4F, 0xEA, 0x80, 0x13, 0x90, 0x82, 0xD7, 0xE0, 0xB4, 0x02, 0x04, 0xF1, 
+0xC0, 0x80, 0x08, 0x90, 0x82, 0xD7, 0xE0, 0x70, 0x02, 0xF1, 0xAC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x80, 0x07, 0x7D, 0x20, 0x7F, 0xFF, 0x12, 0x4D, 0xA9, 0xB1, 0xA2, 0x90, 0x81, 0x43, 0x74, 0x02, 
+0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xD1, 0x0B, 0x90, 0x85, 0xBB, 0x12, 0x20, 
+0xDA, 0xCC, 0xF0, 0x00, 0xC0, 0x7F, 0x8C, 0x12, 0x56, 0x42, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 
+0x14, 0x12, 0x77, 0xE5, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFD, 0xFF, 0x12, 0x67, 
+0xD3, 0xF1, 0xB9, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x82, 0xBE, 0x12, 0x20, 0xCE, 0x90, 0x82, 0xBE, 
+0xD1, 0x96, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 
+0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD1, 0x8E, 0x7D, 0x23, 0x80, 0x8E, 0x7F, 0xFF, 0x12, 0x4D, 0xA9, 0xE4, 0x90, 0x82, 0xCD, 0xF0, 
+0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 
+0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 0x82, 0xCE, 0xE0, 0x94, 0xE8, 0x90, 0x82, 
+0xCD, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 
+0x7F, 0x32, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x82, 0xCD, 0xF1, 0xB2, 0x80, 0xC4, 0x12, 0x57, 
+0xE0, 0xA1, 0x92, 0x12, 0x57, 0xE0, 0x7D, 0x21, 0x7F, 0xFF, 0x12, 0x4D, 0xA9, 0x90, 0x81, 0x43, 
+0x74, 0x03, 0xF0, 0x22, 0x7D, 0x22, 0x7F, 0xFF, 0x12, 0x4D, 0xA9, 0xD1, 0x8E, 0x80, 0xEE, 0x12, 
+0x57, 0xCC, 0xF1, 0xC8, 0xE4, 0x90, 0x81, 0x43, 0xF0, 0x22, 0xD1, 0x88, 0x80, 0xF4, 0x12, 0x57, 
+0x77, 0x80, 0xEF, 0x12, 0x55, 0xE4, 0x80, 0xD5, 0x12, 0x4F, 0x43, 0x02, 0x57, 0x7A, 0x90, 0x05, 
+0x27, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0x12, 0x44, 0xCF, 0x90, 0x85, 0xBB, 0x02, 0x20, 0xCE, 0x90, 
+0x82, 0x92, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 
+0x90, 0x82, 0xA0, 0xF0, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0x90, 0x82, 0x98, 0x12, 0x20, 
+0xCE, 0x90, 0x82, 0x92, 0xE0, 0xFB, 0x70, 0x04, 0xF1, 0x81, 0x80, 0x06, 0xEB, 0xF1, 0x87, 0x12, 
+0x2D, 0x5C, 0x90, 0x82, 0x9C, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x93, 0x12, 0x6B, 0xFE, 0x78, 0x17, 
+0x12, 0x65, 0x72, 0x90, 0x82, 0x9C, 0x12, 0x44, 0xCF, 0xED, 0x54, 0x7F, 0xFD, 0xEC, 0x54, 0x80, 
+0xFC, 0x12, 0x44, 0xC2, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x82, 0x9C, 0x12, 0x20, 0xCE, 0xF1, 0x81, 
+0xEC, 0x54, 0x7F, 0xFC, 0xD1, 0x99, 0xF1, 0x9A, 0xF1, 0x87, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 
+0x9C, 0xD1, 0x96, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x2E, 0xA2, 0xF1, 0x81, 0xEC, 0x44, 0x80, 0xFC, 
+0xD1, 0x99, 0xF1, 0x9A, 0x70, 0x04, 0x7F, 0x20, 0x80, 0x09, 0x90, 0x82, 0x92, 0xE0, 0xB4, 0x01, 
 0x16, 0x7F, 0x28, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0x78, 0x08, 0x12, 0x20, 0xA8, 0xEF, 0x54, 0x01, 
-0xFF, 0xE4, 0x90, 0x81, 0xEB, 0xEF, 0xF0, 0x90, 0x81, 0xEB, 0xE0, 0x90, 0x81, 0xDD, 0x60, 0x0E, 
+0xFF, 0xE4, 0x90, 0x82, 0xA0, 0xEF, 0xF0, 0x90, 0x82, 0xA0, 0xE0, 0x90, 0x82, 0x92, 0x60, 0x0E, 
 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x66, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x80, 0x0C, 0xE0, 0x75, 
-0xF0, 0x08, 0xA4, 0x24, 0x64, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 
-0xFF, 0x12, 0x2D, 0x5C, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x90, 0x81, 0xDF, 0x12, 0x20, 0xCE, 
-0x90, 0x81, 0xDF, 0x02, 0x4A, 0xD9, 0x90, 0x81, 0xEC, 0xEF, 0xF0, 0xAB, 0x05, 0x90, 0x81, 0xF2, 
-0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x03, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x14, 0x12, 
-0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x81, 0xEE, 0x12, 0x4A, 0xD9, 
-0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x12, 0x4A, 0xCC, 0xEC, 0x54, 0x0F, 0xFC, 0x90, 0x81, 0xF2, 
-0x12, 0x20, 0xCE, 0x90, 0x81, 0xEC, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x60, 0xF5, 0x82, 0xE4, 
-0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x81, 0xF2, 
-0x12, 0x4A, 0xD9, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0xD0, 0x07, 0xD0, 0x06, 0x02, 0x2E, 0xA2, 
-0xE0, 0x44, 0x02, 0xF0, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x39, 0xE0, 0xF5, 0x1E, 0xE4, 0xFB, 0xFD, 
-0x7F, 0x54, 0x7E, 0x01, 0x8E, 0x19, 0x8F, 0x1A, 0xE5, 0x1E, 0x54, 0x07, 0xC4, 0x33, 0x54, 0xE0, 
-0x85, 0x19, 0x83, 0x85, 0x1A, 0x82, 0xF0, 0xE5, 0x1D, 0x54, 0x07, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 
-0xE5, 0x1E, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0xA3, 0xF0, 0xEB, 0x54, 0x07, 0xC4, 0x33, 0x54, 
-0xE0, 0xFF, 0xE5, 0x1D, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0x85, 0x1A, 0x82, 0x85, 0x19, 0x83, 
-0xA3, 0xA3, 0xF0, 0xBD, 0x01, 0x0C, 0x85, 0x1A, 0x82, 0x8E, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 0x03, 
-0xF0, 0x22, 0x85, 0x1A, 0x82, 0x85, 0x19, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 0x01, 0xF0, 0x22, 0xE4, 
-0x90, 0x81, 0x51, 0xF0, 0x90, 0x06, 0xA9, 0xE0, 0x90, 0x81, 0x51, 0xF0, 0xE0, 0x54, 0xC0, 0x70, 
-0x0D, 0x90, 0x81, 0x2B, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 0x02, 0x4D, 0x29, 0x90, 0x81, 
-0x51, 0xE0, 0x30, 0xE6, 0x21, 0x90, 0x81, 0x27, 0xE0, 0x64, 0x01, 0x70, 0x20, 0x90, 0x81, 0x2B, 
-0xE0, 0x44, 0x01, 0xF0, 0x90, 0x81, 0x26, 0xE0, 0x54, 0x0F, 0x64, 0x02, 0x60, 0x04, 0xF1, 0x3D, 
-0x80, 0x0B, 0xD1, 0x6C, 0x80, 0x07, 0x90, 0x81, 0x2B, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x81, 0x51, 
-0xE0, 0x90, 0x81, 0x2B, 0x30, 0xE7, 0x10, 0xB1, 0x90, 0x90, 0x01, 0x57, 0x74, 0x05, 0xF0, 0x90, 
-0x81, 0x24, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x01, 0x5F, 0xE4, 
-0xF0, 0x90, 0x01, 0x3C, 0x74, 0x08, 0xF0, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x3A, 0xE0, 0xC3, 0x13, 
-0x54, 0x7F, 0xF5, 0x1E, 0xE4, 0xFB, 0xFD, 0x7F, 0x5C, 0x7E, 0x01, 0xB1, 0xA4, 0x90, 0x01, 0x5F, 
-0x74, 0x05, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x24, 0xE0, 0x44, 0x10, 0xF0, 
-0x90, 0x81, 0x2A, 0xE0, 0x64, 0x0C, 0x60, 0x08, 0x12, 0x4D, 0x3D, 0xE4, 0xFF, 0x12, 0x56, 0xA8, 
-0x22, 0x90, 0x06, 0xA9, 0xE0, 0x90, 0x81, 0x51, 0xF0, 0xE0, 0xFD, 0x54, 0xC0, 0x70, 0x09, 0x90, 
-0x81, 0x2B, 0xE0, 0x54, 0xFE, 0xF0, 0x80, 0x71, 0xED, 0x30, 0xE6, 0x4B, 0x90, 0x81, 0x27, 0xE0, 
-0x64, 0x02, 0x70, 0x2A, 0x90, 0x81, 0x24, 0xE0, 0xFF, 0xC3, 0x13, 0x20, 0xE0, 0x09, 0x90, 0x81, 
-0x2B, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x28, 0x90, 0x81, 0x26, 0xE0, 0x54, 0x0F, 0x64, 0x01, 0x70, 
-0x2D, 0x90, 0x81, 0x2B, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x01, 0xF1, 0x74, 0x80, 0x20, 0x90, 0x81, 
-0x2B, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x81, 0x26, 0xE0, 0x54, 0x0F, 0x64, 0x02, 0x60, 0x04, 0xF1, 
-0x3D, 0x80, 0x0B, 0xD1, 0x6C, 0x80, 0x07, 0x90, 0x81, 0x2B, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x81, 
-0x51, 0xE0, 0x90, 0x81, 0x2B, 0x30, 0xE7, 0x10, 0xB1, 0x90, 0x90, 0x01, 0x57, 0x74, 0x05, 0xF0, 
-0x90, 0x81, 0x24, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x04, 0x1D, 
-0xE0, 0x70, 0x14, 0x90, 0x80, 0x3E, 0xE0, 0xFF, 0xE4, 0xFD, 0x12, 0x57, 0x31, 0x8E, 0x4E, 0x8F, 
-0x4F, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x22, 0x90, 0x80, 0xDE, 0xE0, 0xB4, 0x01, 0x14, 0x90, 
-0x81, 0x27, 0xE0, 0x60, 0x0E, 0x90, 0x81, 0x26, 0xE0, 0x54, 0x0F, 0x64, 0x02, 0x60, 0x02, 0x80, 
-0xCC, 0xD1, 0x6C, 0x22, 0x8F, 0x4E, 0x12, 0x77, 0x5A, 0xBF, 0x01, 0x19, 0x90, 0x80, 0x40, 0xE0, 
-0xFF, 0x7D, 0x01, 0x12, 0x57, 0x31, 0xAD, 0x07, 0xAC, 0x06, 0xAF, 0x4E, 0x12, 0x56, 0xE6, 0x90, 
-0x04, 0x1F, 0x74, 0x20, 0xF0, 0x22, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x0C, 0xE4, 0xF5, 0x1D, 
-0xA3, 0xB1, 0x9A, 0x90, 0x01, 0x57, 0x74, 0x05, 0xF0, 0x90, 0x01, 0xBE, 0xE0, 0x04, 0xF0, 0x22, 
-0x90, 0x80, 0xDE, 0xE0, 0x64, 0x01, 0x70, 0x18, 0x90, 0x81, 0x27, 0xE0, 0x60, 0x12, 0x90, 0x01, 
-0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xB1, 0x93, 0x90, 0x01, 0x57, 0x74, 0x05, 0xF0, 
-0x22, 0x90, 0x81, 0xF6, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xAD, 0x03, 0xAC, 0x02, 0xE4, 0x90, 0x81, 
-0xFE, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0xC4, 0x74, 0xD1, 0xF0, 0x74, 0x6F, 0xA3, 0xF0, 0xEC, 0x54, 
-0x3F, 0xFC, 0x90, 0x01, 0x40, 0xED, 0xF0, 0xAE, 0x04, 0xEE, 0xA3, 0xF0, 0x90, 0x81, 0xF6, 0xE0, 
-0x24, 0x81, 0x60, 0x34, 0x24, 0xDA, 0x60, 0x1C, 0x24, 0x3C, 0x70, 0x41, 0x90, 0x81, 0xF7, 0xE0, 
-0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0x90, 0x81, 0xFB, 0xF0, 0xA3, 0x74, 0x69, 0xF0, 0xA3, 0x74, 
-0x80, 0xF0, 0x80, 0x2C, 0x90, 0x81, 0xF7, 0xE0, 0x54, 0x01, 0x90, 0x81, 0xFB, 0xF0, 0xA3, 0x74, 
-0xA5, 0xF0, 0xA3, 0x74, 0x01, 0xF0, 0x80, 0x18, 0x90, 0x81, 0xF7, 0xE0, 0xC4, 0x54, 0x10, 0x90, 
-0x81, 0xFB, 0xF0, 0xA3, 0x74, 0x7F, 0xF0, 0xA3, 0x74, 0x10, 0xF0, 0x80, 0x03, 0x7F, 0x00, 0x22, 
-0x90, 0x81, 0xFC, 0xE0, 0x90, 0x01, 0x06, 0xF0, 0x90, 0x81, 0xFB, 0xE0, 0x60, 0x0E, 0x90, 0x01, 
-0x42, 0xF0, 0x90, 0x81, 0xFA, 0xE0, 0x90, 0x01, 0x43, 0xF0, 0x80, 0x0D, 0x90, 0x01, 0x43, 0xE4, 
-0xF0, 0x90, 0x81, 0xFB, 0xE0, 0x90, 0x01, 0x42, 0xF0, 0x90, 0x81, 0xFD, 0xE0, 0xFF, 0x90, 0x01, 
-0x42, 0xE0, 0x5F, 0xFF, 0x90, 0x81, 0xFB, 0xE0, 0x6F, 0x60, 0xEE, 0x74, 0xD1, 0x04, 0x90, 0x01, 
-0xC4, 0xF0, 0x74, 0x6F, 0xA3, 0xF0, 0x90, 0x01, 0x43, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x02, 
-0x09, 0xE0, 0xFD, 0x12, 0x1F, 0xA4, 0xFE, 0xAF, 0x05, 0xED, 0x2E, 0x90, 0x80, 0x3D, 0xF0, 0x90, 
-0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x80, 0x3E, 0xF0, 0x90, 0x00, 0x02, 0x12, 
-0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x80, 0x3F, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0xFF, 
-0xED, 0x2F, 0x90, 0x80, 0x40, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0xFF, 0xAE, 0x05, 0xED, 
-0x2F, 0x90, 0x80, 0x41, 0xF0, 0x22, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0xFF, 0x30, 0xE0, 0x26, 
-0x12, 0x1F, 0xA4, 0x90, 0x81, 0x38, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x81, 0x39, 
-0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0x4F, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 
-0xBD, 0x90, 0x81, 0x3B, 0xF0, 0x22, 0x90, 0x81, 0x38, 0x74, 0x01, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 
-0xA3, 0xE0, 0x54, 0x01, 0x44, 0x28, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x22, 0x8F, 0x0D, 0x22, 0x8F, 
-0x0E, 0x22, 0x22, 0x90, 0x01, 0x30, 0xE4, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 
-0x38, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xFD, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 
-0x7F, 0x51, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x53, 
-0x02, 0x32, 0x1E, 0x90, 0x01, 0x34, 0x74, 0xFF, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 
-0x01, 0x3C, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xFD, 0x7F, 0x54, 0x12, 0x32, 0x1E, 0x7D, 
-0xFF, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x56, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 
-0x57, 0x02, 0x32, 0x1E, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9C, 0x74, 0x7E, 
-0xF0, 0xA3, 0x74, 0x92, 0xF0, 0xA3, 0x74, 0xA0, 0xF0, 0xA3, 0x74, 0x24, 0xF0, 0x90, 0x01, 0x9B, 
-0x74, 0x49, 0xF0, 0x90, 0x01, 0x9A, 0x74, 0xE0, 0xF0, 0x90, 0x01, 0x99, 0xE4, 0xF0, 0x90, 0x01, 
-0x98, 0x04, 0xF0, 0x22, 0xE4, 0x90, 0x81, 0x56, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x98, 0xE0, 0x7F, 
-0x00, 0x30, 0xE4, 0x02, 0x7F, 0x01, 0xEF, 0x64, 0x01, 0x60, 0x3E, 0xC3, 0x90, 0x81, 0x57, 0xE0, 
-0x94, 0x88, 0x90, 0x81, 0x56, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 
-0xF0, 0x22, 0x90, 0x81, 0x56, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x4A, 0xA9, 0x7F, 0x14, 0x7E, 0x00, 
-0x12, 0x32, 0xAA, 0xD3, 0x90, 0x81, 0x57, 0xE0, 0x94, 0x32, 0x90, 0x81, 0x56, 0xE0, 0x94, 0x00, 
-0x40, 0xB9, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xB2, 0x22, 0x7F, 0x02, 0x90, 0x81, 0x46, 0xE0, 
-0xFE, 0xEF, 0xC3, 0x9E, 0x50, 0x18, 0xEF, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x0B, 
-0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0xA3, 0xF0, 0x7F, 0x00, 0x22, 0x0F, 0x80, 0xDE, 0x7F, 0x01, 
-0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x3D, 0xF5, 0x41, 0xA3, 0xE0, 0x55, 0x3E, 0xF5, 0x42, 0xA3, 
-0xE0, 0x55, 0x3F, 0xF5, 0x43, 0xA3, 0xE0, 0x55, 0x40, 0xF5, 0x44, 0x90, 0x01, 0x34, 0xE5, 0x41, 
-0xF0, 0xA3, 0xE5, 0x42, 0xF0, 0xA3, 0xE5, 0x43, 0xF0, 0xA3, 0xE5, 0x44, 0xF0, 0x22, 0x90, 0x01, 
-0x3C, 0xE0, 0x55, 0x45, 0xF5, 0x49, 0xA3, 0xE0, 0x55, 0x46, 0xF5, 0x4A, 0xA3, 0xE0, 0x55, 0x47, 
-0xF5, 0x4B, 0xA3, 0xE0, 0x55, 0x48, 0xF5, 0x4C, 0x90, 0x01, 0x3C, 0xE5, 0x49, 0xF0, 0xA3, 0xE5, 
-0x4A, 0xF0, 0xA3, 0xE5, 0x4B, 0xF0, 0xA3, 0xE5, 0x4C, 0xF0, 0x53, 0x91, 0xDF, 0x22, 0x90, 0x81, 
-0x50, 0xE0, 0x60, 0x0F, 0xE4, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x05, 0xFC, 
-0xE0, 0x04, 0xF0, 0x90, 0x81, 0x1F, 0xE0, 0x30, 0xE0, 0x10, 0xA3, 0x74, 0x01, 0xF0, 0x90, 0x81, 
-0x1F, 0xE0, 0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x02, 0x51, 0xCF, 0x71, 0xF9, 0x02, 0x5F, 0x72, 0xD3, 
-0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x1E, 0xE0, 0xB4, 0x01, 0x04, 0x7F, 0x04, 0x80, 
-0x0C, 0x12, 0x4F, 0xE3, 0xBF, 0x01, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x02, 0x12, 0x55, 0xA3, 
-0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x81, 0x1F, 0xE0, 0xFF, 0x30, 0xE0, 0x3D, 0x90, 0x81, 0x23, 
-0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x81, 0x22, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 
-0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x23, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x02, 0x80, 0xB0, 0x71, 
-0x82, 0x90, 0x81, 0x23, 0xE0, 0xB4, 0x08, 0x06, 0xE4, 0xFD, 0x7F, 0x0C, 0x80, 0x09, 0x90, 0x81, 
-0x23, 0xE0, 0x70, 0x06, 0xFD, 0x7F, 0x04, 0x12, 0x4D, 0x41, 0x22, 0x90, 0x81, 0x1F, 0xE0, 0xFF, 
-0x30, 0xE0, 0x3E, 0x90, 0x81, 0x23, 0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x81, 
-0x22, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x24, 0xEF, 0xC3, 0x13, 
-0x30, 0xE0, 0x02, 0x41, 0xCF, 0x71, 0xAA, 0x90, 0x81, 0x23, 0xE0, 0xB4, 0x0C, 0x06, 0xE4, 0xFD, 
-0x7F, 0x08, 0x80, 0x0A, 0x90, 0x81, 0x23, 0xE0, 0xB4, 0x04, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x4D, 
-0x41, 0x22, 0x90, 0x81, 0x1F, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x0F, 0x90, 
-0x81, 0x23, 0xE0, 0x64, 0x02, 0x60, 0x07, 0x7D, 0x01, 0x7F, 0x02, 0x12, 0x4D, 0x41, 0x90, 0x81, 
-0x23, 0xE0, 0x64, 0x02, 0x60, 0x03, 0x12, 0x4F, 0xC8, 0x22, 0x90, 0x01, 0x57, 0xE0, 0x60, 0x48, 
-0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x24, 0xE0, 0xFF, 0x13, 0x13, 0x54, 
-0x3F, 0x30, 0xE0, 0x0C, 0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x2B, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 
-0x90, 0x81, 0x30, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x2B, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0x81, 0x38, 
-0xE0, 0xFF, 0x90, 0x81, 0x30, 0xE0, 0xD3, 0x9F, 0x40, 0x0E, 0x90, 0x80, 0xDE, 0xE0, 0xB4, 0x01, 
-0x07, 0x90, 0x81, 0x25, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0xE4, 0x90, 0x81, 0x51, 0xF0, 0x90, 0x81, 
-0x27, 0xE0, 0x70, 0x02, 0x81, 0xA8, 0x90, 0x80, 0xDE, 0xE0, 0x64, 0x01, 0x60, 0x02, 0x81, 0xA8, 
-0x90, 0x81, 0x26, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 
-0x21, 0x90, 0x81, 0x2E, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x81, 0x30, 0xE0, 0x60, 
-0x11, 0xEF, 0x70, 0x08, 0x90, 0x81, 0x2D, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x90, 0x81, 0x51, 0x74, 
-0x01, 0xF0, 0x90, 0x81, 0x1F, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x81, 0x23, 0xE0, 0xB4, 0x02, 0x05, 
-0xE4, 0x90, 0x81, 0x51, 0xF0, 0x12, 0x4F, 0xE3, 0xEF, 0x70, 0x04, 0x90, 0x81, 0x51, 0xF0, 0x90, 
-0x81, 0x51, 0xE0, 0x60, 0x43, 0x90, 0x81, 0x2B, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x81, 0x30, 0xE0, 
-0x60, 0x03, 0xB4, 0x01, 0x09, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x30, 0xE0, 0x80, 0x0D, 0xE4, 0xF5, 
-0x1D, 0x90, 0x81, 0x30, 0xE0, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 0x90, 0x81, 0x2F, 0xE0, 
-0x2F, 0x12, 0x6D, 0x9B, 0x90, 0x01, 0x57, 0x74, 0x05, 0xF0, 0x90, 0x81, 0x2A, 0xE0, 0x20, 0xE2, 
-0x07, 0x7D, 0x01, 0x7F, 0x04, 0x12, 0x4D, 0x41, 0x22, 0x90, 0x80, 0xDE, 0xE0, 0x64, 0x01, 0x70, 
-0x26, 0x90, 0x81, 0x27, 0xE0, 0x60, 0x20, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 
-0x02, 0xF0, 0x90, 0x81, 0x24, 0xE0, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x2B, 0xE0, 0x54, 0xFD, 0xF0, 
-0x54, 0x07, 0x70, 0x03, 0x12, 0x4D, 0x29, 0x22, 0x90, 0x81, 0x27, 0xE0, 0x70, 0x07, 0x90, 0x81, 
-0x1F, 0xE0, 0x30, 0xE0, 0x12, 0x90, 0x81, 0x1F, 0xE0, 0x30, 0xE0, 0x09, 0x12, 0x4F, 0xE3, 0xBF, 
-0x01, 0x05, 0x02, 0x4F, 0xC8, 0x91, 0xF8, 0x22, 0x90, 0x81, 0x27, 0xE0, 0x64, 0x01, 0x70, 0x4E, 
-0x90, 0x81, 0x26, 0xE0, 0x54, 0x0F, 0x60, 0x39, 0x12, 0x4D, 0x3D, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 
-0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x3A, 0xE0, 0xC3, 0x13, 0x54, 
-0x7F, 0xF5, 0x1E, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x12, 0x6D, 0xA4, 0x90, 0x01, 0x5B, 
-0x74, 0x05, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x01, 0xF0, 0x90, 0x81, 0x24, 0xE0, 0x44, 0x08, 0xF0, 
-0x22, 0x90, 0x81, 0x2A, 0xE0, 0x70, 0x07, 0x7D, 0x01, 0x7F, 0x04, 0x12, 0x4D, 0x41, 0x22, 0x12, 
-0x4F, 0xFC, 0xEF, 0x70, 0x02, 0x91, 0xF8, 0x22, 0x90, 0x81, 0x27, 0xE0, 0x60, 0x35, 0x90, 0x06, 
-0x92, 0xE0, 0x30, 0xE0, 0x24, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x3A, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 
-0xF5, 0x1E, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x12, 0x6D, 0xA4, 0x90, 0x01, 0x5B, 0x74, 
-0x05, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x81, 0x24, 0xE0, 0x54, 0xF7, 0xF0, 
-0x12, 0x4D, 0x29, 0x22, 0x90, 0x81, 0x27, 0xE0, 0x60, 0x35, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 
-0x24, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x3A, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0xF5, 0x1E, 0xE4, 0xFB, 
-0xFD, 0x7F, 0x5C, 0x7E, 0x01, 0x12, 0x6D, 0xA4, 0x90, 0x01, 0x5F, 0x74, 0x05, 0xF0, 0x90, 0x06, 
-0x92, 0x74, 0x02, 0xF0, 0x22, 0x90, 0x81, 0x24, 0xE0, 0x54, 0xEF, 0xF0, 0x12, 0x4D, 0x29, 0x22, 
-0xD1, 0x28, 0x90, 0x81, 0x52, 0xEF, 0xF0, 0x90, 0x81, 0x24, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 
-0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x81, 0x52, 0xE0, 0x30, 0xE6, 0x11, 0x90, 0x01, 
-0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 0x90, 
-0x81, 0x24, 0xE0, 0x30, 0xE0, 0x1A, 0x90, 0x81, 0x32, 0xE4, 0xF0, 0xA3, 0x74, 0x07, 0xF0, 0x90, 
-0x81, 0x32, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x90, 0x04, 0xEC, 0xE0, 0x54, 0xDD, 0xF0, 0x22, 
-0x90, 0x04, 0xEC, 0xE0, 0x44, 0x22, 0xF0, 0x22, 0xE4, 0x90, 0x81, 0x53, 0xF0, 0xA3, 0xF0, 0xA3, 
-0xF0, 0x90, 0x00, 0x83, 0xE0, 0x90, 0x81, 0x53, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 0x90, 0x81, 
-0x53, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x81, 0x55, 0xE0, 0x94, 0x64, 0x90, 0x81, 
-0x54, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x81, 0x53, 
-0xE0, 0xFF, 0x22, 0x90, 0x81, 0x54, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x4A, 0xA9, 0x80, 0xC2, 0x90, 
-0x81, 0x4F, 0xE0, 0x60, 0x0F, 0xE4, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x05, 
-0xFD, 0xE0, 0x04, 0xF0, 0x22, 0x22, 0x90, 0x81, 0x24, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 
-0x30, 0xE0, 0x27, 0xEF, 0x54, 0xBF, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x81, 0x25, 0x30, 0xE0, 
-0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x10, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 
-0xF0, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x12, 0x4D, 0x29, 0xE4, 0xFF, 0x90, 0x81, 0x4A, 0xE0, 
-0x30, 0xE0, 0x48, 0x90, 0x81, 0x4E, 0xE0, 0xFD, 0x60, 0x41, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 
-0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x04, 0xE0, 0xE0, 0xFB, 
-0xEF, 0x5B, 0x60, 0x06, 0xE4, 0x90, 0x81, 0x4E, 0xF0, 0x22, 0x90, 0x81, 0x4C, 0xE0, 0xD3, 0x9D, 
-0x50, 0x10, 0x90, 0x01, 0xC7, 0x74, 0x10, 0xF0, 0xF1, 0x0C, 0x90, 0x81, 0x4A, 0xE0, 0x54, 0xFE, 
-0xF0, 0x22, 0x12, 0x56, 0xA6, 0x90, 0x81, 0x4E, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x80, 0x3C, 0xE0, 
-0x64, 0x02, 0x60, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x81, 0x24, 0xE0, 
-0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x30, 0xE0, 0x2C, 0xEF, 0x54, 0x7F, 0xF0, 0x90, 0x04, 
-0xE0, 0xE0, 0x90, 0x81, 0x25, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x0F, 0xE0, 0x54, 
-0xFD, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x04, 0xF0, 0x90, 0x81, 0x27, 
-0xE0, 0x60, 0x03, 0x12, 0x4D, 0x29, 0x7F, 0x01, 0xC1, 0xBC, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x1A, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x90, 0x60, 0x07, 0x90, 
-0x01, 0xC0, 0xE0, 0x44, 0x08, 0xF0, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE1, 0xE4, 0x7F, 0x00, 0x80, 
-0x02, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xC3, 0xEE, 0x94, 0x01, 0x40, 0x0A, 0x0D, 0xED, 
-0x13, 0x90, 0xFD, 0x10, 0xF0, 0xE4, 0x2F, 0xFF, 0x22, 0xC3, 0xEE, 0x94, 0x01, 0x40, 0x1E, 0x90, 
-0xFD, 0x11, 0xE0, 0xB5, 0x05, 0x14, 0x90, 0x01, 0x17, 0xE0, 0xB5, 0x05, 0x07, 0x90, 0xFD, 0x11, 
-0xE4, 0xF0, 0x80, 0x06, 0xED, 0x04, 0x90, 0xFD, 0x11, 0xF0, 0xE4, 0x2F, 0xFF, 0x22, 0xEF, 0x14, 
-0x90, 0x05, 0x73, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 0x03, 0x74, 0x45, 0x2F, 
-0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 
-0xF0, 0x22, 0x74, 0x45, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 
-0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x90, 0x82, 0x1B, 0xED, 0xF0, 0x90, 0x82, 0x1A, 0xEF, 0xF0, 0xD3, 0x94, 0x07, 0x50, 0x70, 
-0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 
-0x00, 0x47, 0xE0, 0x5F, 0xFD, 0x7F, 0x47, 0x12, 0x32, 0x1E, 0x90, 0x82, 0x1A, 0xE0, 0xFF, 0x74, 
-0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x46, 0xE0, 0x4F, 
-0xFD, 0x7F, 0x46, 0x12, 0x32, 0x1E, 0x90, 0x82, 0x1B, 0xE0, 0x60, 0x18, 0x90, 0x82, 0x1A, 0xE0, 
-0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x45, 
-0xE0, 0x4F, 0x80, 0x17, 0x90, 0x82, 0x1A, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 
-0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x45, 0xE0, 0x5F, 0xFD, 0x7F, 0x45, 0x80, 0x7E, 
-0x90, 0x82, 0x1A, 0xE0, 0x24, 0xF8, 0xF0, 0xE0, 0x24, 0x04, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 
-0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x43, 0xE0, 0x5F, 0xFD, 0x7F, 0x43, 
-0x12, 0x32, 0x1E, 0x90, 0x82, 0x1A, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 
-0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x43, 0xE0, 0x4F, 0xFD, 0x7F, 0x43, 0x12, 0x32, 0x1E, 0x90, 
-0x82, 0x1B, 0xE0, 0x60, 0x1D, 0x90, 0x82, 0x1A, 0xE0, 0x24, 0x04, 0xFF, 0x74, 0x01, 0xA8, 0x07, 
-0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x42, 0xE0, 0x4F, 0xFD, 0x7F, 0x42, 
-0x80, 0x1C, 0x90, 0x82, 0x1A, 0xE0, 0x24, 0x04, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 
-0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x42, 0xE0, 0x5F, 0xFD, 0x7F, 0x42, 0x12, 0x32, 
-0x1E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0x90, 0x81, 0x27, 0xF0, 0xA3, 0xF0, 0x90, 0x81, 0x26, 
-0xE0, 0x54, 0x0F, 0xF0, 0x54, 0xF0, 0xF0, 0x90, 0x81, 0x24, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0xF7, 
-0xF0, 0x54, 0xEF, 0xF0, 0x90, 0x81, 0x2D, 0x74, 0x01, 0xF0, 0xA3, 0xF0, 0x90, 0x81, 0x24, 0xE0, 
-0x54, 0xFB, 0xF0, 0xA3, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x81, 0x30, 0xF0, 0x90, 0x81, 0x2F, 
-0x74, 0x07, 0xF0, 0x90, 0x81, 0x32, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0xE4, 0x90, 0x81, 0x2B, 
-0xF0, 0x90, 0x81, 0x24, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x81, 0x29, 0x74, 0x0C, 0xF0, 0x90, 0x81, 
-0x24, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x81, 0x2A, 0x74, 0x0C, 0xF0, 0x90, 0x81, 0x24, 0xE0, 0x54, 
-0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0xA3, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 0x54, 0xF7, 0xF0, 
-0x90, 0x81, 0x34, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0x90, 0x80, 0x3C, 0xE0, 0xB4, 0x01, 
-0x08, 0x90, 0x81, 0x31, 0x74, 0x99, 0xF0, 0x80, 0x12, 0x90, 0x80, 0x3C, 0xE0, 0x90, 0x81, 0x31, 
-0xB4, 0x03, 0x05, 0x74, 0x90, 0xF0, 0x80, 0x03, 0x74, 0x40, 0xF0, 0x90, 0x81, 0x38, 0x74, 0x01, 
-0xF0, 0xA3, 0x74, 0x05, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 0x28, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 
-0xE4, 0xA3, 0xF0, 0xA3, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0xFB, 0xF0, 0x54, 0xF7, 0xF0, 0x54, 0xEF, 
-0xF0, 0x54, 0xDF, 0xF0, 0x54, 0xBF, 0xF0, 0xE4, 0xA3, 0xF0, 0x22, 0xEF, 0x24, 0xFE, 0x60, 0x0C, 
-0x04, 0x70, 0x28, 0x90, 0x81, 0x2D, 0x74, 0x01, 0xF0, 0xA3, 0xF0, 0x22, 0xED, 0x70, 0x0A, 0x90, 
-0x81, 0x3B, 0xE0, 0x90, 0x81, 0x2D, 0xF0, 0x80, 0x05, 0x90, 0x81, 0x2D, 0xED, 0xF0, 0x90, 0x81, 
-0x2D, 0xE0, 0xA3, 0xF0, 0x90, 0x81, 0x25, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x12, 0x4F, 0xFC, 0xEF, 
-0x64, 0x01, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x80, 0x67, 0x90, 0x81, 0x2B, 0xE0, 
-0xFF, 0x54, 0x03, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x56, 0x90, 0x81, 0x29, 
-0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x44, 0xEF, 
-0x30, 0xE2, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x80, 0x38, 0x90, 0x81, 0x2B, 0xE0, 0x30, 
-0xE4, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 0x29, 0x90, 0x81, 0x25, 0xE0, 0x13, 0x13, 
-0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x20, 0xF0, 0x80, 0x16, 0x90, 0x81, 0x3E, 
-0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 
-0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x02, 0x87, 0xE0, 
-0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x80, 0x17, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 
-0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 
-0x22, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 0xEF, 0x60, 0x42, 0x90, 0x80, 0xDE, 
-0xE0, 0x64, 0x01, 0x70, 0x3A, 0x90, 0x81, 0x25, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x05, 0x22, 0x74, 
-0x0F, 0xF0, 0x90, 0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 0xE4, 0xFF, 0x12, 0x56, 0xA8, 0xBF, 0x01, 
-0x12, 0x90, 0x81, 0x24, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x81, 0x2A, 0x74, 0x06, 0xF0, 0x90, 0x81, 
-0x23, 0xF0, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x22, 
-0x90, 0x05, 0x22, 0x74, 0x6F, 0xF0, 0x90, 0x81, 0x2A, 0x74, 0x02, 0xF0, 0x90, 0x05, 0x27, 0xE0, 
-0x54, 0xBF, 0xF0, 0x90, 0x81, 0x23, 0x74, 0x02, 0xF0, 0x22, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x90, 
-0x81, 0x2A, 0x74, 0x04, 0xF0, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x81, 0x23, 0x74, 
-0x04, 0xF0, 0x22, 0xE4, 0x90, 0x81, 0x52, 0xF0, 0x90, 0x81, 0x27, 0xE0, 0x60, 0x59, 0x90, 0x80, 
-0xDE, 0xE0, 0x64, 0x01, 0x70, 0x51, 0x90, 0x81, 0x52, 0x04, 0xF0, 0xE4, 0x90, 0x81, 0x2E, 0xF0, 
-0x90, 0x81, 0x1F, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x81, 0x23, 0xE0, 0xB4, 0x02, 0x05, 0xE4, 0x90, 
-0x81, 0x52, 0xF0, 0x12, 0x4F, 0xE3, 0xEF, 0x70, 0x04, 0x90, 0x81, 0x52, 0xF0, 0x90, 0x81, 0x52, 
-0xE0, 0x60, 0x24, 0x90, 0x81, 0x2B, 0xE0, 0x44, 0x10, 0xF0, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x2F, 
-0x12, 0x6D, 0x9A, 0x90, 0x01, 0x57, 0x74, 0x05, 0xF0, 0x90, 0x81, 0x2A, 0xE0, 0x20, 0xE2, 0x07, 
-0x7D, 0x01, 0x7F, 0x04, 0x12, 0x4D, 0x41, 0x22, 0x90, 0x81, 0x24, 0xE0, 0xFF, 0x13, 0x13, 0x54, 
-0x3F, 0x30, 0xE0, 0x11, 0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x2B, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 
-0x07, 0x70, 0x42, 0x80, 0x3D, 0x90, 0x81, 0x30, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x2B, 0xE0, 0x54, 
-0xEF, 0xF0, 0x90, 0x81, 0x30, 0xE0, 0xFF, 0xB4, 0x01, 0x02, 0x80, 0x04, 0xEF, 0xB4, 0x02, 0x06, 
-0x90, 0x05, 0x58, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x38, 0xE0, 0xFF, 0x90, 0x81, 0x30, 0xE0, 0xD3, 
-0x9F, 0x40, 0x0F, 0x90, 0x80, 0xDE, 0xE0, 0xB4, 0x01, 0x0B, 0x90, 0x81, 0x25, 0xE0, 0x54, 0xFB, 
-0xF0, 0x22, 0x12, 0x4D, 0x29, 0x22, 0x22, 0x90, 0x05, 0x2B, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 
-0x7F, 0x01, 0x22, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 0x90, 
-0x81, 0x22, 0x74, 0x01, 0xF0, 0x22, 0x91, 0x03, 0x02, 0x57, 0xE5, 0x90, 0x05, 0x22, 0x74, 0xFF, 
-0xF0, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x81, 0x22, 0x74, 0x03, 0xF0, 0x22, 0x90, 
-0x05, 0x22, 0xE4, 0xF0, 0x90, 0x81, 0x22, 0x04, 0xF0, 0x22, 0x91, 0x2F, 0x02, 0x57, 0xE5, 0x90, 
-0x05, 0x22, 0x74, 0x6F, 0xF0, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x81, 0x22, 0x74, 
-0x04, 0xF0, 0x22, 0x90, 0x81, 0x22, 0xE0, 0x64, 0x02, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 
-0x90, 0x80, 0x3F, 0xE0, 0xFF, 0x7D, 0x01, 0x12, 0x57, 0x31, 0x8E, 0x54, 0x8F, 0x55, 0xAD, 0x55, 
-0xAC, 0x54, 0xAF, 0x53, 0x12, 0x56, 0xE6, 0xAF, 0x55, 0xAE, 0x54, 0x90, 0x04, 0x80, 0xE0, 0x54, 
-0x0F, 0xFD, 0xAC, 0x07, 0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 
-0x01, 0xF0, 0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xFB, 0xF0, 
-0xAC, 0x07, 0x74, 0x16, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0xFA, 0xF0, 
-0x74, 0x15, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 
-0x74, 0x06, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x0F, 0xF0, 0x90, 0x04, 
-0x53, 0xE4, 0xF0, 0x90, 0x04, 0x52, 0xF0, 0x90, 0x04, 0x51, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0x50, 
-0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 
-0x4D, 0xFD, 0x74, 0x14, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xED, 0xF0, 0x22, 0x90, 
-0x80, 0x3F, 0xE0, 0xFE, 0x90, 0x04, 0x1C, 0xE0, 0x6E, 0x70, 0x40, 0x90, 0x81, 0x2A, 0xE0, 0xFE, 
-0x64, 0x0E, 0x70, 0x1C, 0xEF, 0x70, 0x34, 0x90, 0x81, 0x24, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 
-0x04, 0xE0, 0x54, 0xBF, 0xF0, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x81, 0x2A, 0x74, 0x04, 0xF0, 0x22, 
-0xEE, 0xB4, 0x06, 0x17, 0xEF, 0x60, 0x14, 0x90, 0x81, 0x24, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x06, 
-0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x81, 0x2A, 0x74, 0x0C, 0xF0, 0x22, 0xE4, 0xFE, 0xEF, 0xC3, 
-0x13, 0xFD, 0xEF, 0x30, 0xE0, 0x02, 0x7E, 0x80, 0x90, 0xFD, 0x10, 0xED, 0xF0, 0xAF, 0x06, 0x22, 
-0xAB, 0x07, 0xAA, 0x06, 0xED, 0x2B, 0xFB, 0xE4, 0x3A, 0xFA, 0xC3, 0x90, 0x80, 0xDB, 0xE0, 0x9B, 
-0x90, 0x80, 0xDA, 0xE0, 0x9A, 0x50, 0x13, 0xA3, 0xE0, 0x24, 0x01, 0xFF, 0x90, 0x80, 0xDA, 0xE0, 
-0x34, 0x00, 0xFE, 0xC3, 0xEB, 0x9F, 0xFB, 0xEA, 0x9E, 0xFA, 0xEA, 0x90, 0xFD, 0x11, 0xF0, 0xAF, 
-0x03, 0x74, 0x00, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 0x22, 0x12, 0x1F, 
-0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x81, 0x47, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 
-0x30, 0xE0, 0x0A, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x81, 0x48, 0xF0, 0x22, 0x90, 0x81, 
-0x4A, 0xE0, 0x30, 0xE0, 0x2D, 0x90, 0x81, 0x4D, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x90, 0x81, 0x4B, 
-0xE0, 0xB5, 0x07, 0x1E, 0x90, 0x06, 0x92, 0xE0, 0x54, 0x1C, 0x70, 0x0B, 0x12, 0x56, 0xA6, 0x90, 
-0x81, 0x4E, 0xE0, 0x04, 0xF0, 0x80, 0x06, 0x90, 0x06, 0x92, 0x74, 0x1C, 0xF0, 0xE4, 0x90, 0x81, 
-0x4D, 0xF0, 0x22, 0x00, 0x74, 0x53, 
+0xF0, 0x08, 0xA4, 0x24, 0x64, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF1, 0x92, 0x12, 0x2D, 0x5C, 0xED, 
+0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x90, 0x82, 0x94, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x94, 0x02, 0x44, 
+0xCF, 0x90, 0x82, 0x98, 0x02, 0x44, 0xCF, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x62, 0xF5, 0x82, 0xE4, 
+0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2E, 
+0xA2, 0x90, 0x82, 0x92, 0xE0, 0x22, 0x22, 0x7D, 0x25, 0x02, 0x4F, 0xEC, 0x12, 0x57, 0xE0, 0x02, 
+0x4F, 0xEA, 0xE4, 0x75, 0xF0, 0x01, 0x02, 0x44, 0x9F, 0x7F, 0x7C, 0x7E, 0x08, 0x02, 0x2D, 0x5C, 
+0x12, 0x55, 0xE4, 0x7D, 0x24, 0x02, 0x4F, 0xEC, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x22, 
+0x90, 0x81, 0x40, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 
+0x12, 0x43, 0x4E, 0x90, 0x82, 0x73, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x80, 0x3C, 0xE0, 0xFF, 0x70, 
+0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 0xEF, 0x30, 0xE1, 0x09, 0x90, 0x80, 0x3C, 0xE0, 0x54, 
+0xFD, 0xF0, 0x11, 0x19, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x80, 0x3C, 0xE0, 0xFF, 0x30, 0xE2, 0x05, 
+0x54, 0xFB, 0xF0, 0x31, 0xA9, 0xD2, 0xAF, 0x80, 0xD1, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0x80, 0x9A, 0xE0, 0xFF, 0x90, 0x80, 0x99, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 
+0x7F, 0x00, 0xEF, 0x70, 0x3F, 0x90, 0x80, 0x99, 0xE0, 0xFE, 0x75, 0xF0, 0x08, 0x90, 0x80, 0x49, 
+0x12, 0x45, 0x00, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x4A, 0xF9, 0x74, 0x80, 0x35, 
+0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x12, 0x4B, 0x24, 0x90, 0x80, 0x99, 0x31, 0xA2, 0xB4, 0x0A, 
+0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0x99, 0xF0, 0x11, 0x79, 0x90, 0x80, 0x3C, 
+0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 
+0x82, 0xCB, 0xF0, 0x90, 0x82, 0xCB, 0xE0, 0xFD, 0x70, 0x02, 0x21, 0x77, 0x90, 0x80, 0x99, 0xE0, 
+0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x80, 0x9A, 0xE0, 
+0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x08, 0x90, 0x01, 0xC1, 0xE0, 
+0x44, 0x01, 0xF0, 0x22, 0x90, 0x82, 0xC9, 0x12, 0x57, 0xD4, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 
+0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0x21, 0x5A, 0xE4, 0x90, 0x82, 0xCC, 0xF0, 0x90, 
+0x82, 0xCC, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 0x32, 0x31, 0x79, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 
+0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 0x31, 0x90, 0x90, 0x80, 0x49, 0x31, 0x81, 
+0x31, 0x78, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xF0, 0x31, 0x90, 0x90, 0x80, 0x4D, 
+0x31, 0x81, 0xF0, 0x90, 0x82, 0xCC, 0xE0, 0x04, 0xF0, 0x80, 0xC4, 0x90, 0x82, 0xCB, 0xE0, 0xFF, 
+0x90, 0x82, 0xC9, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
+0xF4, 0x5F, 0x90, 0x82, 0xCB, 0xF0, 0x90, 0x82, 0xC9, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x82, 0xC9, 0xE0, 0x04, 0xF0, 
+0xE0, 0x54, 0x03, 0xF0, 0x90, 0x80, 0x9A, 0x31, 0xA2, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x70, 
+0x02, 0x01, 0x83, 0xE4, 0x90, 0x80, 0x9A, 0xF0, 0x01, 0x83, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x02, 
+0xF0, 0x90, 0x82, 0xC9, 0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0x31, 0x78, 0x90, 0x01, 0xD0, 0x12, 
+0x45, 0x00, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 0xF0, 0x90, 0x82, 0xC9, 0xE0, 0x75, 0xF0, 0x04, 
+0x22, 0x12, 0x45, 0x00, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xEF, 0x22, 
+0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x80, 0x9A, 0xE0, 0x75, 0xF0, 
+0x08, 0x22, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0xE4, 0xFF, 0x90, 0x81, 0x32, 0xE0, 0xFE, 0x90, 0x81, 0x31, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 
+0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x41, 0x90, 0x01, 0xAF, 0xE0, 0x70, 0x0A, 
+0xED, 0x51, 0x6D, 0xFA, 0x7B, 0x01, 0x51, 0xC5, 0x7F, 0x01, 0xEF, 0x60, 0x2E, 0x90, 0x81, 0x31, 
+0x31, 0xA2, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x81, 0x31, 0xF0, 0x90, 
+0x81, 0x32, 0xE0, 0xFF, 0x90, 0x81, 0x31, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 
+0x00, 0xEF, 0x70, 0x07, 0x90, 0x80, 0x3C, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x31, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 
+0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x81, 0x32, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 
+0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x28, 
+0xC0, 0x01, 0x90, 0x81, 0x32, 0xE0, 0x51, 0x6D, 0xA8, 0x01, 0xFC, 0x7D, 0x01, 0xD0, 0x01, 0x7E, 
+0x00, 0x7F, 0x0F, 0x12, 0x44, 0x79, 0x90, 0x81, 0x32, 0x31, 0xA2, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 
+0xEF, 0x60, 0x05, 0xE4, 0x90, 0x81, 0x32, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x75, 0xF0, 0x0F, 
+0xA4, 0x24, 0x9B, 0xF9, 0x74, 0x80, 0x35, 0xF0, 0x22, 0x90, 0x82, 0x83, 0x74, 0x12, 0xF0, 0x90, 
+0x82, 0x91, 0x74, 0x05, 0xF0, 0x90, 0x82, 0x85, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 
+0x90, 0x82, 0x81, 0xE0, 0x90, 0x82, 0x88, 0xF0, 0x90, 0x82, 0x82, 0xE0, 0x90, 0x82, 0x89, 0xF0, 
+0x7B, 0x01, 0x7A, 0x82, 0x79, 0x83, 0x51, 0x10, 0x7F, 0x04, 0x90, 0x82, 0xD1, 0xEF, 0xF0, 0x7F, 
+0x02, 0x12, 0x43, 0x27, 0x90, 0x80, 0x3C, 0xE0, 0xFF, 0x90, 0x82, 0xD1, 0xE0, 0xFE, 0xEF, 0x4E, 
+0x90, 0x80, 0x3C, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x74, 0x12, 
+0x45, 0x15, 0x90, 0x82, 0xCA, 0xE0, 0xFF, 0x04, 0xF0, 0x90, 0x00, 0x01, 0xEF, 0x12, 0x1F, 0xFC, 
+0x7F, 0xAF, 0x7E, 0x01, 0x71, 0x28, 0xEF, 0x60, 0x3A, 0x90, 0x82, 0x74, 0x12, 0x45, 0x0C, 0x8B, 
+0x13, 0x8A, 0x14, 0x89, 0x15, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x24, 0x02, 0xF5, 0x16, 0x7B, 
+0x01, 0x7A, 0x01, 0x79, 0xA0, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x74, 0x12, 0x45, 0x0C, 0x90, 0x00, 
+0x0E, 0x12, 0x1F, 0xBD, 0x90, 0x01, 0xAE, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0x90, 0x01, 0xCB, 0xE0, 
+0x64, 0x80, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x82, 0xB6, 0xEE, 0xF0, 0xA3, 0x71, 0x75, 0x90, 0x82, 0xB6, 0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 
+0x8E, 0x83, 0xE0, 0x60, 0x29, 0xC3, 0x90, 0x82, 0xB9, 0xE0, 0x94, 0xE8, 0x90, 0x82, 0xB8, 0xE0, 
+0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 0x11, 0x90, 
+0x82, 0xB8, 0x12, 0x5F, 0xB2, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x80, 0xC9, 0x7F, 0x01, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x82, 0x10, 
+0x71, 0x75, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 0x82, 0x10, 
+0xE0, 0x6F, 0x60, 0x35, 0xC3, 0x90, 0x82, 0x12, 0xE0, 0x94, 0x88, 0x90, 0x82, 0x11, 0xE0, 0x94, 
+0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x82, 0x11, 0x12, 0x5F, 
+0xB2, 0x71, 0xCA, 0xD3, 0x90, 0x82, 0x12, 0xE0, 0x94, 0x32, 0x90, 0x82, 0x11, 0xE0, 0x94, 0x00, 
+0x40, 0xC0, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xB9, 0x22, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x32, 
+0xAA, 0x90, 0x81, 0x46, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x81, 0x54, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 
+0x32, 0x1E, 0x90, 0x81, 0x4A, 0xE0, 0x60, 0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 
+0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 
+0xFD, 0x7F, 0x08, 0x12, 0x32, 0x1E, 0x7F, 0x01, 0x71, 0x7D, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 
+0xFD, 0x7F, 0x90, 0x12, 0x32, 0x1E, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x32, 0xAA, 0xE4, 0x90, 0x82, 
+0x07, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x98, 0xE0, 0x7F, 0x00, 0x30, 0xE4, 0x02, 0x7F, 0x01, 0xEF, 
+0x64, 0x01, 0x60, 0x3C, 0xC3, 0x90, 0x82, 0x08, 0xE0, 0x94, 0x88, 0x90, 0x82, 0x07, 0xE0, 0x94, 
+0x13, 0x40, 0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0xFD, 0xF0, 
+0x80, 0x1E, 0x90, 0x82, 0x07, 0x12, 0x5F, 0xB2, 0x71, 0xCA, 0xD3, 0x90, 0x82, 0x08, 0xE0, 0x94, 
+0x32, 0x90, 0x82, 0x07, 0xE0, 0x94, 0x00, 0x40, 0xBB, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xB4, 
+0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x78, 0x7F, 0xF5, 0x7E, 
+0x00, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x06, 0x90, 0x82, 0x78, 0xE0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 
+0x82, 0x79, 0x78, 0x7F, 0xF6, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0x78, 
+0xE0, 0x90, 0x82, 0x7A, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x78, 0x7F, 0xF4, 0x7E, 0x00, 0x12, 
+0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0x78, 0xE0, 0x90, 0x82, 0x7B, 0xF0, 0x7B, 0x01, 0x7A, 
+0x82, 0x79, 0x78, 0x7F, 0xF3, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0x78, 
+0xE0, 0x90, 0x82, 0x7C, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x78, 0x7F, 0xF2, 0x7E, 0x00, 0x12, 
+0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0x78, 0xE0, 0x90, 0x82, 0x7D, 0xF0, 0x90, 0x82, 0x79, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 0x82, 0x81, 0xF0, 0x90, 0x82, 
+0x7D, 0xE0, 0x90, 0x82, 0x82, 0xF0, 0x41, 0x79, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 0x35, 0xF0, 
+0xBF, 0x01, 0x07, 0x91, 0x77, 0xE4, 0x90, 0x81, 0x35, 0xF0, 0x22, 0x90, 0x82, 0xA1, 0xEF, 0xF0, 
+0xAB, 0x05, 0x90, 0x82, 0xA7, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x03, 0xE4, 0xFC, 
+0xFD, 0xFE, 0x78, 0x14, 0xB1, 0x72, 0x90, 0x82, 0xA3, 0x12, 0x44, 0xCF, 0xED, 0x54, 0x0F, 0xFD, 
+0xE4, 0xFC, 0x12, 0x44, 0xC2, 0xEC, 0x54, 0x0F, 0xFC, 0x90, 0x82, 0xA7, 0x12, 0x20, 0xCE, 0x90, 
+0x82, 0xA1, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x60, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x12, 0x5F, 
+0x92, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 0xA7, 0x12, 0x5E, 0x96, 0xD0, 0x07, 0xD0, 0x06, 0x02, 
+0x2E, 0xA2, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x22, 0x78, 0x10, 
+0x74, 0x01, 0xF2, 0x90, 0x02, 0x09, 0xE0, 0x78, 0x00, 0xF2, 0x08, 0x74, 0x20, 0xF2, 0x18, 0xE2, 
+0xFF, 0x30, 0xE0, 0x05, 0x08, 0xE2, 0x24, 0x80, 0xF2, 0xEF, 0xC3, 0x13, 0x90, 0xFD, 0x10, 0xF0, 
+0x78, 0x01, 0xE2, 0xF1, 0xA6, 0x78, 0x03, 0xF2, 0x64, 0x04, 0x60, 0x0D, 0xE2, 0xFF, 0x64, 0x08, 
+0x60, 0x07, 0xEF, 0x64, 0x0C, 0x60, 0x02, 0xE1, 0x9C, 0xE4, 0x78, 0x02, 0xF2, 0x78, 0x03, 0xE2, 
+0xFF, 0x18, 0xE2, 0xC3, 0x9F, 0x50, 0x25, 0xE2, 0xFD, 0x18, 0xE2, 0x2D, 0x90, 0x82, 0x10, 0xF0, 
+0xE0, 0xFF, 0xF1, 0xA6, 0xFE, 0x74, 0x04, 0x2D, 0xF8, 0xEE, 0xF2, 0xEF, 0xB4, 0xFF, 0x06, 0x90, 
+0xFD, 0x10, 0xE0, 0x04, 0xF0, 0x78, 0x02, 0xE2, 0x04, 0xF2, 0x80, 0xD1, 0x78, 0x04, 0xE2, 0x78, 
+0x12, 0xF2, 0xFF, 0x78, 0x05, 0xE2, 0x78, 0x11, 0xF2, 0x78, 0x06, 0xE2, 0x78, 0x13, 0xF2, 0x78, 
+0x07, 0xE2, 0x78, 0x14, 0xF2, 0x78, 0x08, 0xE2, 0x78, 0x33, 0xF2, 0x78, 0x09, 0xE2, 0x78, 0x34, 
+0xF2, 0x78, 0x0A, 0xE2, 0x78, 0x35, 0xF2, 0x78, 0x0B, 0xE2, 0x78, 0x36, 0xF2, 0x78, 0x0C, 0xE2, 
+0x78, 0x37, 0xF2, 0x78, 0x0D, 0xE2, 0x78, 0x38, 0xF2, 0x78, 0x0E, 0xE2, 0x78, 0x39, 0xF2, 0x78, 
+0x0F, 0xE2, 0x78, 0x3A, 0xF2, 0xE4, 0x78, 0x15, 0xF2, 0xEF, 0x24, 0xF8, 0x60, 0x56, 0x24, 0xFC, 
+0x60, 0x4D, 0x24, 0x08, 0x60, 0x02, 0xE1, 0x7E, 0x78, 0x11, 0xE2, 0xB4, 0x01, 0x05, 0x12, 0x29, 
+0xC5, 0xE1, 0x83, 0x78, 0x11, 0xE2, 0xB4, 0x02, 0x05, 0x12, 0x11, 0xBD, 0xE1, 0x83, 0x78, 0x11, 
+0xE2, 0xB4, 0x03, 0x05, 0x12, 0x69, 0x27, 0xE1, 0x83, 0x78, 0x11, 0xE2, 0xB4, 0x10, 0x07, 0xF1, 
+0xB1, 0x12, 0x32, 0xAA, 0xE1, 0x83, 0x78, 0x11, 0xE2, 0xB4, 0x11, 0x07, 0xF1, 0xB1, 0x12, 0x32, 
+0x06, 0xE1, 0x83, 0x78, 0x11, 0xE2, 0xF4, 0x60, 0x02, 0xE1, 0x83, 0x18, 0xF2, 0xE1, 0x83, 0x78, 
+0x15, 0x74, 0x01, 0xF2, 0x78, 0x11, 0xE2, 0x64, 0x07, 0x60, 0x02, 0xE1, 0x68, 0x78, 0x34, 0xF1, 
+0x9F, 0x78, 0x08, 0x12, 0x20, 0xBB, 0xC0, 0x04, 0xB1, 0x77, 0x78, 0x33, 0xF1, 0x9F, 0xD0, 0x00, 
+0x12, 0x44, 0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x78, 0x35, 0xF1, 0x9F, 0x78, 
+0x10, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0x78, 
+0x18, 0x12, 0x44, 0xF4, 0x78, 0x15, 0xE2, 0x60, 0x79, 0x18, 0xE2, 0xFF, 0x18, 0xE2, 0xFD, 0xF1, 
+0xC4, 0x78, 0x1C, 0x12, 0x44, 0xF4, 0x78, 0x38, 0xF1, 0x9F, 0x78, 0x08, 0x12, 0x20, 0xBB, 0xC0, 
+0x04, 0xB1, 0x77, 0x78, 0x37, 0xF1, 0x9F, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0xC0, 0x04, 0xC0, 0x05, 
+0xC0, 0x06, 0xC0, 0x07, 0x78, 0x39, 0xF1, 0x9F, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0x78, 0x20, 0x12, 0x44, 0xF4, 0x78, 0x20, 0x12, 
+0x44, 0xDB, 0x12, 0x20, 0x9B, 0x78, 0x1C, 0x12, 0x44, 0xE7, 0x12, 0x44, 0xB5, 0xC0, 0x04, 0xC0, 
+0x05, 0xC0, 0x06, 0xC0, 0x07, 0x78, 0x18, 0x12, 0x44, 0xDB, 0x78, 0x20, 0x12, 0x44, 0xE7, 0x12, 
+0x44, 0xB5, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0x78, 0x18, 0x12, 
+0x44, 0xF4, 0x78, 0x18, 0x12, 0x44, 0xDB, 0x90, 0x82, 0xAD, 0x12, 0x20, 0xCE, 0x78, 0x13, 0xE2, 
+0xFD, 0x08, 0xE2, 0xFF, 0xF1, 0xD3, 0x80, 0x1B, 0x78, 0x13, 0xE2, 0xFF, 0x08, 0xE2, 0xFD, 0x78, 
+0x11, 0xE2, 0xFB, 0x78, 0x15, 0xE2, 0x90, 0x82, 0x72, 0xF0, 0xF1, 0xF5, 0x80, 0x05, 0x78, 0x10, 
+0x74, 0x02, 0xF2, 0x78, 0x10, 0xE2, 0xFF, 0xC3, 0x94, 0x02, 0x50, 0x10, 0xEF, 0x60, 0x0A, 0x78, 
+0x02, 0xE2, 0xFF, 0x18, 0xE2, 0x2F, 0xF2, 0xA1, 0xA0, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0xE2, 
+0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x22, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
+0x22, 0x78, 0x14, 0xE2, 0xFE, 0x18, 0xE2, 0xFD, 0xED, 0xFF, 0x78, 0x16, 0xEE, 0xF2, 0xFE, 0x08, 
+0xEF, 0xF2, 0xFF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x5E, 0x9F, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0x82, 
+0xAD, 0x12, 0x44, 0xCF, 0x90, 0x82, 0xA3, 0x12, 0x20, 0xCE, 0xD0, 0x05, 0xD0, 0x07, 0xB1, 0x1B, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xAC, 0x07, 0xED, 0xAD, 0x04, 0x78, 0x24, 0xF2, 0xED, 0x08, 0xF2, 
+0xEB, 0xB4, 0x04, 0x07, 0x78, 0x27, 0x74, 0x01, 0xF2, 0x80, 0x0E, 0xEB, 0x78, 0x27, 0xB4, 0x05, 
+0x05, 0x74, 0x02, 0xF2, 0x80, 0x03, 0x74, 0x04, 0xF2, 0x91, 0x43, 0xE2, 0x94, 0x00, 0x50, 0x45, 
+0xE4, 0x78, 0x26, 0xF2, 0x31, 0x11, 0x9F, 0x40, 0x02, 0x21, 0x10, 0x31, 0x1A, 0x60, 0x1F, 0x74, 
+0x37, 0x2E, 0xF8, 0xE2, 0x78, 0x32, 0xF2, 0xEE, 0xFF, 0x78, 0x25, 0xE2, 0x2F, 0xFF, 0x18, 0xE2, 
+0x34, 0x00, 0x8F, 0x82, 0xF5, 0x83, 0xE0, 0x78, 0x29, 0xF2, 0x78, 0x32, 0x91, 0x62, 0x78, 0x24, 
+0x08, 0xE2, 0xFF, 0x08, 0xE2, 0x2F, 0xFF, 0x78, 0x28, 0xE2, 0xFD, 0x12, 0x32, 0x1E, 0x78, 0x26, 
+0xE2, 0x04, 0xF2, 0x80, 0xBF, 0x91, 0x43, 0xE2, 0x94, 0x07, 0x50, 0x30, 0xE4, 0x78, 0x26, 0xF2, 
+0x31, 0x11, 0x9F, 0x40, 0x02, 0x21, 0x10, 0x31, 0x1A, 0x60, 0x14, 0x78, 0x26, 0xE2, 0xFF, 0x91, 
+0x54, 0xE0, 0x78, 0x29, 0xF2, 0x74, 0x37, 0x2F, 0xF8, 0xE2, 0x78, 0x32, 0xF2, 0x91, 0x62, 0x91, 
+0x3B, 0x91, 0x54, 0xEF, 0xF0, 0x78, 0x26, 0xE2, 0x04, 0xF2, 0x80, 0xD4, 0x90, 0x82, 0x72, 0xE0, 
+0x60, 0x0A, 0x91, 0x33, 0x12, 0x2D, 0x5C, 0x78, 0x2E, 0x12, 0x44, 0xF4, 0xE4, 0x78, 0x26, 0xF2, 
+0x31, 0x11, 0x9F, 0x50, 0x4E, 0x31, 0x1A, 0x60, 0x2B, 0x78, 0x2E, 0x12, 0x44, 0xDB, 0x78, 0x26, 
+0xE2, 0xFB, 0x75, 0xF0, 0x08, 0xA4, 0xF9, 0xF8, 0x12, 0x20, 0xA8, 0x78, 0x29, 0xEF, 0xF2, 0x74, 
+0x37, 0x2B, 0xF8, 0xE2, 0x78, 0x32, 0xF2, 0xE2, 0xFE, 0xF4, 0x5F, 0xFF, 0x78, 0x28, 0xE2, 0xFD, 
+0xEE, 0x5D, 0x4F, 0xF2, 0x91, 0x3B, 0xFD, 0xC3, 0x74, 0x03, 0x9D, 0xFD, 0xE4, 0x94, 0x00, 0xFC, 
+0x7B, 0xFE, 0x74, 0x2A, 0x2D, 0xF9, 0x74, 0x80, 0x3C, 0xFA, 0xEF, 0x12, 0x1F, 0xEA, 0xE2, 0x04, 
+0xF2, 0x80, 0xAD, 0x78, 0x2A, 0x12, 0x44, 0xDB, 0x12, 0x5E, 0x99, 0x91, 0x33, 0x12, 0x2E, 0xA2, 
+0x22, 0x78, 0x27, 0xE2, 0xFF, 0x18, 0xE2, 0xFE, 0xC3, 0x22, 0x74, 0x33, 0x2E, 0xF8, 0xE2, 0x78, 
+0x28, 0xF2, 0x90, 0x82, 0x72, 0xE0, 0x22, 0xE4, 0x90, 0x82, 0x20, 0xF0, 0x90, 0x87, 0x5F, 0xE0, 
+0x90, 0x82, 0x1F, 0xF0, 0xE4, 0x90, 0x82, 0x2C, 0xF0, 0x90, 0x82, 0x1C, 0xF0, 0x90, 0x82, 0x1C, 
+0xE0, 0xFF, 0xC3, 0x94, 0x40, 0x50, 0x10, 0x74, 0x2F, 0x2F, 0x91, 0x2B, 0x74, 0xFF, 0xF0, 0x90, 
+0x82, 0x1C, 0xE0, 0x04, 0xF0, 0x80, 0xE6, 0xE4, 0x90, 0x82, 0x1C, 0xF0, 0x90, 0x82, 0x1F, 0xE0, 
+0xFF, 0x90, 0x82, 0x1C, 0xE0, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0x41, 0x27, 0x74, 0xDF, 0x2E, 0xF9, 
+0xE4, 0x34, 0x86, 0x91, 0x23, 0x75, 0x16, 0x0A, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x11, 0x12, 0x2B, 
+0xED, 0x90, 0x82, 0x12, 0xE0, 0xFF, 0x12, 0x2F, 0x27, 0xEF, 0x04, 0x90, 0x82, 0x2C, 0xF0, 0x90, 
+0x82, 0x11, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x12, 0x31, 0xEA, 0xEF, 0x24, 0xC8, 0x90, 0x82, 0x2E, 
+0xF0, 0x75, 0xF0, 0x08, 0xA4, 0xF0, 0x90, 0x82, 0x12, 0xE0, 0x54, 0x0F, 0x90, 0x82, 0x2D, 0xF0, 
+0xE4, 0x90, 0x82, 0x1B, 0xF0, 0x90, 0x82, 0x1D, 0xF0, 0x90, 0x82, 0x1D, 0xE0, 0xFF, 0xC3, 0x94, 
+0x04, 0x50, 0x57, 0x90, 0x82, 0x2D, 0xE0, 0xFE, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x13, 0xD8, 
+0xFC, 0x20, 0xE0, 0x3E, 0x90, 0x82, 0x1D, 0xE0, 0x25, 0xE0, 0xFF, 0x90, 0x82, 0x2E, 0xE0, 0x2F, 
+0x24, 0x2F, 0xF9, 0xE4, 0x34, 0x82, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x01, 0x90, 0x82, 0x1B, 
+0xE0, 0x75, 0xF0, 0x02, 0xA4, 0x24, 0x13, 0xF9, 0x74, 0x82, 0x35, 0xF0, 0x8B, 0x13, 0xF5, 0x14, 
+0x89, 0x15, 0x75, 0x16, 0x02, 0xD0, 0x01, 0xD0, 0x03, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x1B, 0xE0, 
+0x04, 0xF0, 0x90, 0x82, 0x1D, 0xE0, 0x04, 0xF0, 0x80, 0x9F, 0x90, 0x82, 0x2C, 0xE0, 0xFF, 0x90, 
+0x82, 0x1C, 0xE0, 0x2F, 0xF0, 0x21, 0x5C, 0xE4, 0x90, 0x82, 0x20, 0xF0, 0x90, 0x82, 0x20, 0xE0, 
+0xC3, 0x94, 0x40, 0x40, 0x02, 0x61, 0xD0, 0xE0, 0xFF, 0x24, 0x2F, 0x91, 0x2B, 0xE0, 0x90, 0x82, 
+0x22, 0xF0, 0xE0, 0xFE, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFD, 0x90, 0x82, 0x21, 0xF0, 0xEE, 0x54, 
+0x0F, 0xFE, 0xA3, 0xF0, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0x90, 
+0x82, 0x23, 0xF0, 0xFC, 0xEE, 0xFE, 0xEC, 0xFB, 0xEB, 0xFF, 0x90, 0x82, 0x28, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0xED, 0x12, 0x45, 0x1E, 0x6A, 0x9B, 0x00, 0x6A, 0xCD, 0x01, 0x6B, 0x3A, 0x02, 0x6B, 
+0xC1, 0x03, 0x6B, 0x45, 0x04, 0x6B, 0x56, 0x05, 0x6B, 0x56, 0x06, 0x6B, 0x56, 0x07, 0x6B, 0x56, 
+0x08, 0x6B, 0x9E, 0x09, 0x6B, 0xAF, 0x0A, 0x00, 0x00, 0x6B, 0xD0, 0x90, 0x82, 0x20, 0xE0, 0xFD, 
+0x24, 0x32, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x31, 0x2D, 0x91, 0x10, 
+0xE0, 0xFD, 0xED, 0xFF, 0x90, 0x82, 0x2A, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0x90, 0x82, 0x23, 
+0xE0, 0xFF, 0x12, 0x2F, 0x96, 0x90, 0x82, 0x1E, 0x74, 0x02, 0xF0, 0x61, 0xC1, 0x71, 0xD1, 0x12, 
+0x44, 0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 0x20, 0xE0, 0x24, 0x33, 
+0xF5, 0x82, 0xE4, 0x34, 0x82, 0x71, 0xFC, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 
+0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 
+0x82, 0x20, 0xE0, 0x24, 0x34, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0x71, 0xFC, 0x78, 0x18, 0x12, 0x20, 
+0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x91, 0x4B, 0x90, 0x82, 0x24, 0x12, 0x44, 
+0xCF, 0x90, 0x85, 0x96, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x28, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 
+0x2E, 0xE4, 0x90, 0x82, 0x1E, 0x74, 0x04, 0xF0, 0x61, 0xC1, 0x91, 0x05, 0xE0, 0xFB, 0xE4, 0xFF, 
+0x12, 0x30, 0xC7, 0x80, 0x09, 0x91, 0x05, 0xE0, 0xFB, 0xE4, 0xFF, 0x12, 0x30, 0x6A, 0x90, 0x82, 
+0x1E, 0x74, 0x01, 0xF0, 0x80, 0x6B, 0x90, 0x82, 0x1E, 0x74, 0x02, 0xF0, 0x71, 0xD1, 0x12, 0x44, 
+0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 0x22, 0x71, 0xFE, 0x78, 0x10, 
+0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x91, 0x4B, 0x90, 0x82, 0x21, 
+0xE0, 0x24, 0xFB, 0xFF, 0xC0, 0x07, 0x90, 0x82, 0x24, 0x12, 0x44, 0xCF, 0x90, 0x82, 0xAD, 0x12, 
+0x20, 0xCE, 0x90, 0x82, 0x23, 0xE0, 0xFD, 0xD0, 0x07, 0x12, 0x67, 0xD3, 0x80, 0x23, 0x90, 0x82, 
+0x1E, 0x74, 0x01, 0x91, 0x18, 0x75, 0x16, 0x01, 0x91, 0x73, 0xF0, 0x7B, 0x04, 0x80, 0x0F, 0x90, 
+0x82, 0x1E, 0x74, 0x04, 0x91, 0x18, 0x75, 0x16, 0x04, 0x91, 0x73, 0xF0, 0x7B, 0x06, 0x12, 0x67, 
+0xF5, 0x90, 0x82, 0x1E, 0xE0, 0x24, 0x02, 0xFF, 0x90, 0x82, 0x20, 0xE0, 0x2F, 0xF0, 0x41, 0x2C, 
+0x22, 0x90, 0x82, 0x20, 0xE0, 0x24, 0x32, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFF, 
+0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x08, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 
+0x07, 0x90, 0x82, 0x20, 0xE0, 0x24, 0x31, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFF, 
+0xE4, 0xFC, 0xFD, 0xFE, 0x22, 0x90, 0x82, 0x23, 0xE0, 0xFD, 0x90, 0x82, 0x20, 0xE0, 0x24, 0x31, 
+0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0x22, 0xF0, 0x90, 0x82, 0x20, 0xE0, 0x24, 0x31, 0xF9, 
+0xE4, 0x34, 0x82, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x82, 
+0xF5, 0x83, 0x22, 0x78, 0x24, 0xE2, 0xFE, 0x08, 0xE2, 0xFF, 0x22, 0x78, 0x28, 0xE2, 0xFF, 0x78, 
+0x26, 0xE2, 0x22, 0xD3, 0x78, 0x25, 0xE2, 0x94, 0xFF, 0x18, 0x22, 0x12, 0x44, 0xC2, 0x90, 0x82, 
+0x24, 0x02, 0x20, 0xCE, 0xFD, 0x18, 0xE2, 0x2D, 0xFD, 0x18, 0xE2, 0x34, 0x00, 0x8D, 0x82, 0xF5, 
+0x83, 0x22, 0xE2, 0xFF, 0xF4, 0xFE, 0x78, 0x29, 0xE2, 0x5E, 0xFE, 0x18, 0xE2, 0xFD, 0xEF, 0x5D, 
+0x4E, 0xF2, 0x22, 0x7B, 0xFE, 0x7A, 0x80, 0x79, 0x33, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x23, 0xE0, 
+0xFF, 0x90, 0x82, 0x22, 0xE0, 0xFD, 0xE4, 0x90, 0x82, 0x72, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x12, 0x2D, 0xA7, 0xE4, 0xF5, 0x51, 0x12, 0x32, 0x9E, 0xEF, 0x60, 0x72, 0x63, 0x51, 
+0x01, 0xE5, 0x51, 0x24, 0x8B, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x6C, 0xA3, 0xF0, 0x90, 0x00, 0x88, 
+0xE0, 0xF5, 0x4F, 0xF5, 0x50, 0x54, 0x0F, 0x60, 0xDF, 0xE5, 0x4F, 0x30, 0xE0, 0x0B, 0x20, 0xE4, 
+0x03, 0x12, 0x29, 0xC5, 0x53, 0x50, 0xEE, 0x80, 0x3E, 0xE5, 0x4F, 0x30, 0xE1, 0x16, 0x20, 0xE5, 
+0x0E, 0x12, 0x11, 0xBD, 0xEF, 0x70, 0x03, 0x43, 0x50, 0x20, 0x90, 0x01, 0x06, 0xE4, 0xF0, 0x53, 
+0x50, 0xFD, 0x80, 0x23, 0xE5, 0x4F, 0x30, 0xE2, 0x0A, 0x20, 0xE6, 0x02, 0x31, 0x27, 0x53, 0x50, 
+0xFB, 0x80, 0x14, 0xE5, 0x4F, 0x30, 0xE3, 0x0F, 0x20, 0xE7, 0x09, 0x12, 0x65, 0x7E, 0xEF, 0x70, 
+0x03, 0x43, 0x50, 0x80, 0x53, 0x50, 0xF7, 0xAD, 0x50, 0x7F, 0x88, 0x12, 0x32, 0x1E, 0x80, 0x88, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 0x90, 0x81, 0xFD, 0xE0, 0x54, 
+0xFE, 0x4F, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x54, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 
+0x81, 0xF3, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0xFB, 0x12, 0x53, 0x4B, 0x90, 0x81, 0xFC, 
+0xF0, 0x22, 0xE4, 0x90, 0x81, 0x31, 0xF0, 0xA3, 0xF0, 0x90, 0x80, 0x99, 0xF0, 0xA3, 0xF0, 0x22, 
+0x75, 0x3D, 0x10, 0xE4, 0xF5, 0x3E, 0x75, 0x3F, 0x07, 0x75, 0x40, 0x02, 0x90, 0x01, 0x30, 0xE5, 
+0x3D, 0xF0, 0xA3, 0xE5, 0x3E, 0xF0, 0xA3, 0xE5, 0x3F, 0xF0, 0xA3, 0xE5, 0x40, 0xF0, 0x22, 0x75, 
+0x45, 0x06, 0x75, 0x46, 0x01, 0x43, 0x46, 0x10, 0x75, 0x47, 0x03, 0x75, 0x48, 0x62, 0x90, 0x01, 
+0x38, 0xE5, 0x45, 0xF0, 0xA3, 0xE5, 0x46, 0xF0, 0xA3, 0xE5, 0x47, 0xF0, 0xA3, 0xE5, 0x48, 0xF0, 
+0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 
+0x01, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9C, 0x74, 0x7E, 0xF0, 0xA3, 0x74, 0x92, 0xF0, 0xA3, 
+0x74, 0xA0, 0xF0, 0xA3, 0x74, 0x24, 0xF0, 0x90, 0x01, 0x9B, 0x74, 0x49, 0xF0, 0x90, 0x01, 0x9A, 
+0x74, 0xE0, 0xF0, 0x90, 0x01, 0x99, 0xE4, 0xF0, 0x90, 0x01, 0x98, 0x04, 0xF0, 0x22, 0x7D, 0x02, 
+0x90, 0x01, 0xC4, 0x74, 0xCE, 0xF0, 0x74, 0x6D, 0xA3, 0xF0, 0x90, 0x81, 0xFA, 0xE0, 0xFF, 0xED, 
+0xC3, 0x9F, 0x50, 0x14, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x07, 0xD1, 0x06, 
+0xA3, 0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xE2, 0x74, 0xCE, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 
+0x6D, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x22, 0xD1, 0xC8, 0xEF, 
+0x64, 0x01, 0x60, 0x04, 0xD1, 0x7E, 0x80, 0x5D, 0x90, 0x81, 0x4D, 0xE0, 0xFF, 0x54, 0x03, 0x60, 
+0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x4C, 0x90, 0x81, 0x4B, 0xE0, 0xFE, 0xE4, 0xC3, 
+0x9E, 0x50, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x3A, 0xEF, 0x30, 0xE2, 0x04, 0xD1, 
+0x06, 0x80, 0x32, 0x90, 0x81, 0x4D, 0xE0, 0x30, 0xE4, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 
+0x80, 0x23, 0x90, 0x81, 0x46, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 
+0x74, 0x20, 0xF0, 0x80, 0x10, 0x90, 0x81, 0xF3, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 
+0xF0, 0x80, 0x02, 0x80, 0x4B, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x01, 
+0xB8, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x81, 0xF6, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x27, 0x90, 0x02, 
+0x87, 0xE0, 0x60, 0x04, 0xD1, 0x7E, 0x80, 0x1F, 0x90, 0x02, 0x96, 0xE0, 0x60, 0x08, 0x90, 0x01, 
+0xB8, 0x74, 0x10, 0xF0, 0x80, 0x11, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x08, 0x90, 0x01, 0xB8, 
+0x74, 0x04, 0xF0, 0x80, 0x02, 0x80, 0x09, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 
+0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 
+0x00, 0x22, 0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 
+0x22, 0xD1, 0xC8, 0xEF, 0x70, 0x03, 0x12, 0x4F, 0xBD, 0x22, 0x90, 0x01, 0xE4, 0x74, 0x14, 0xF0, 
+0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x3D, 0xF5, 0x41, 0xA3, 0xE0, 0x55, 0x3E, 
+0xF5, 0x42, 0xA3, 0xE0, 0x55, 0x3F, 0xF5, 0x43, 0xA3, 0xE0, 0x55, 0x40, 0xF5, 0x44, 0x90, 0x01, 
+0x34, 0xE5, 0x41, 0xF0, 0xA3, 0xE5, 0x42, 0xF0, 0xA3, 0xE5, 0x43, 0xF0, 0xA3, 0xE5, 0x44, 0xF0, 
+0x22, 0x90, 0x01, 0x3C, 0xE0, 0x55, 0x45, 0xF5, 0x49, 0xA3, 0xE0, 0x55, 0x46, 0xF5, 0x4A, 0xA3, 
+0xE0, 0x55, 0x47, 0xF5, 0x4B, 0xA3, 0xE0, 0x55, 0x48, 0xF5, 0x4C, 0x90, 0x01, 0x3C, 0xE5, 0x49, 
+0xF0, 0xA3, 0xE5, 0x4A, 0xF0, 0xA3, 0xE5, 0x4B, 0xF0, 0xA3, 0xE5, 0x4C, 0xF0, 0x53, 0x91, 0xDF, 
+0x22, 0x90, 0x01, 0xCF, 0xE0, 0x90, 0x82, 0xD4, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 
+0xCF, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 
+0x90, 0x01, 0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x52, 0x84, 0x90, 0x00, 
+0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x32, 0x1E, 0x80, 0xFE, 0x22, 0x90, 0x81, 0x40, 
+0xE0, 0x30, 0xE0, 0x05, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x81, 0xFC, 0xE0, 0x60, 0x0F, 
+0xE4, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x05, 0xFC, 0xE0, 0x04, 0xF0, 0x90, 
+0x81, 0x40, 0xE0, 0x30, 0xE0, 0x11, 0xA3, 0x74, 0x01, 0xF0, 0x90, 0x81, 0x40, 0xE0, 0xFF, 0xC3, 
+0x13, 0x30, 0xE0, 0x03, 0x12, 0x5C, 0x5D, 0x12, 0x74, 0x93, 0x90, 0x81, 0xF4, 0xE0, 0x30, 0xE0, 
+0x14, 0x12, 0x4F, 0x43, 0x12, 0x55, 0xE4, 0x90, 0x81, 0xF4, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x03, 
+0x12, 0x4D, 0xF9, 0xF1, 0xE6, 0x22, 0x90, 0x81, 0xF4, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x90, 0x81, 
+0xF4, 0xE0, 0x30, 0xE0, 0x09, 0xE4, 0xF5, 0x1D, 0xA3, 0x12, 0x47, 0x84, 0xF1, 0xE6, 0x90, 0x81, 
+0xF4, 0xE0, 0x30, 0xE0, 0x34, 0x90, 0x82, 0xD0, 0xE0, 0x70, 0x37, 0x90, 0x82, 0xCF, 0xE0, 0x04, 
+0xF0, 0xE0, 0xD3, 0x94, 0x06, 0x40, 0x2B, 0x90, 0x81, 0x54, 0x74, 0xD0, 0xF0, 0x90, 0x82, 0xD0, 
+0x74, 0x01, 0xF0, 0x90, 0x81, 0xF4, 0xE0, 0x13, 0x30, 0xE0, 0x17, 0x90, 0x81, 0x45, 0xE0, 0x44, 
+0x01, 0xF0, 0x90, 0x81, 0x54, 0x74, 0xD0, 0xF0, 0x22, 0xE4, 0x90, 0x82, 0xD0, 0xF0, 0x90, 0x82, 
+0xCF, 0xF0, 0x22, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x06, 0x90, 0x81, 0x42, 0x74, 0x01, 0xF0, 
+0x90, 0x81, 0x49, 0xE0, 0x60, 0x44, 0x90, 0x81, 0x45, 0xE0, 0x30, 0xE0, 0x17, 0x90, 0x81, 0x60, 
+0xE0, 0x04, 0x91, 0x22, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x81, 0x80, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x11, 0xB1, 0x30, 0xE0, 0x0A, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x03, 
+0x12, 0x49, 0x7C, 0x90, 0x82, 0xD3, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x80, 0x40, 0x0B, 0x90, 
+0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0x6F, 0xEE, 0x90, 0x81, 0xF6, 
+0xE0, 0x30, 0xE0, 0x0C, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x05, 0x12, 0x49, 0x7C, 0x71, 0xF6, 
+0x22, 0x90, 0x81, 0x46, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x11, 0xB1, 0x30, 0xE0, 
+0x0B, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x71, 0xE7, 0x71, 0xFF, 0x30, 0xE0, 
+0x08, 0x91, 0x09, 0x54, 0x07, 0x70, 0x3C, 0x80, 0x37, 0x31, 0x38, 0x40, 0x33, 0x12, 0x47, 0xF3, 
+0x70, 0x31, 0x12, 0x54, 0x61, 0x70, 0x07, 0x31, 0x14, 0x12, 0x57, 0x81, 0xF0, 0x22, 0x31, 0x14, 
+0x90, 0x81, 0x53, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 0x0B, 0x12, 0x57, 0x81, 0xF0, 
+0xE4, 0x90, 0x81, 0x53, 0xF0, 0x80, 0x03, 0x12, 0x4F, 0xAD, 0xE4, 0x90, 0x81, 0x52, 0xF0, 0x22, 
+0x12, 0x58, 0x54, 0x22, 0x31, 0x45, 0x40, 0x1F, 0x90, 0x81, 0x63, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 
+0x94, 0x04, 0x50, 0x13, 0x90, 0x81, 0x5B, 0xEF, 0xF0, 0x25, 0xE0, 0x24, 0x08, 0x90, 0x81, 0x62, 
+0xF0, 0xFB, 0x71, 0x2C, 0xFD, 0x31, 0x51, 0x22, 0x90, 0x81, 0x52, 0xE0, 0x04, 0xF0, 0x90, 0x81, 
+0x4D, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0x81, 0xED, 0xE0, 0xFF, 0x90, 0x81, 0x52, 0xE0, 0xD3, 0x9F, 
+0x22, 0xAC, 0x07, 0x90, 0x81, 0x45, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x81, 0x7F, 0xE0, 0x24, 0x04, 
+0x90, 0x81, 0x5E, 0xF0, 0x90, 0x81, 0x7F, 0xE0, 0x24, 0x03, 0x90, 0x81, 0x5D, 0xF0, 0x80, 0x0B, 
+0x90, 0x81, 0x5E, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x5D, 0x14, 0xF0, 0x90, 0x81, 0x5D, 0xE0, 0xFA, 
+0x90, 0x81, 0x5C, 0xE0, 0xD3, 0x9A, 0x50, 0x09, 0x90, 0x81, 0x51, 0xEB, 0x31, 0xB4, 0x2C, 0x80, 
+0x0B, 0xAD, 0x02, 0xC3, 0xED, 0x9D, 0x2B, 0x90, 0x81, 0x51, 0x31, 0xB4, 0x90, 0x81, 0x61, 0xF0, 
+0x90, 0x81, 0x61, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0x81, 0x55, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
+0x05, 0x58, 0xF0, 0x22, 0xF0, 0x90, 0x81, 0x5E, 0xE0, 0xC3, 0x9D, 0x22, 0xE4, 0xFD, 0xF9, 0xFC, 
+0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFB, 0xEB, 0x78, 0x02, 0xCE, 0xC3, 0x13, 
+0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xEE, 0x54, 0x3F, 0x90, 0x81, 0x82, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x81, 0x82, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0xC3, 0x9F, 0xEA, 
+0x9E, 0x40, 0x21, 0xEB, 0x9F, 0xFF, 0x90, 0x81, 0x61, 0xE0, 0xFE, 0xC3, 0x74, 0x0A, 0x9E, 0x2F, 
+0xF9, 0xC3, 0x94, 0x19, 0x50, 0x0E, 0x74, 0x66, 0x29, 0x51, 0xA8, 0xE0, 0x04, 0xF0, 0x90, 0x81, 
+0x5F, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x5F, 0xE0, 0xC3, 0x94, 0x64, 0x50, 0x02, 0x41, 0xA4, 0xE4, 
+0xFC, 0xFD, 0x51, 0xA5, 0xE0, 0x2C, 0xFC, 0xD3, 0x94, 0x05, 0x40, 0x07, 0x90, 0x82, 0x00, 0xED, 
+0xF0, 0x80, 0x05, 0x0D, 0xED, 0xB4, 0x19, 0xEA, 0xE4, 0xFC, 0xFD, 0x51, 0xA5, 0xE0, 0x2C, 0xFC, 
+0xD3, 0x94, 0x5F, 0x40, 0x07, 0x90, 0x82, 0x01, 0xED, 0xF0, 0x80, 0x05, 0x0D, 0xED, 0xB4, 0x19, 
+0xEA, 0x90, 0x82, 0x00, 0xE0, 0x90, 0x81, 0x64, 0xF0, 0x90, 0x82, 0x01, 0xE0, 0x90, 0x81, 0x65, 
+0x51, 0xB0, 0x94, 0x0B, 0x40, 0x0A, 0xEF, 0x24, 0xF6, 0x90, 0x81, 0x5C, 0xF0, 0xE4, 0x80, 0x09, 
+0xE4, 0x90, 0x81, 0x5C, 0x51, 0xB0, 0x74, 0x0A, 0x9F, 0x90, 0x81, 0x5B, 0xF0, 0x90, 0x81, 0x64, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x90, 0x81, 0x62, 0xF0, 0xC3, 0x94, 0x08, 0x50, 0x03, 0x74, 
+0x08, 0xF0, 0x90, 0x81, 0x5C, 0xE0, 0xFD, 0x90, 0x81, 0x62, 0xE0, 0xFB, 0xE4, 0xFF, 0x31, 0x51, 
+0xE4, 0xFF, 0x51, 0xB8, 0x22, 0x74, 0x66, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 
+0xF0, 0x90, 0x81, 0x64, 0xE0, 0xFF, 0xC3, 0x22, 0xE4, 0xFE, 0x74, 0x66, 0x2E, 0x51, 0xA8, 0xE4, 
+0xF0, 0x0E, 0xEE, 0xB4, 0x19, 0xF4, 0xE4, 0x90, 0x81, 0x5F, 0xF0, 0x90, 0x81, 0x63, 0xF0, 0x90, 
+0x81, 0x5B, 0xF0, 0xEF, 0xB4, 0x01, 0x09, 0x90, 0x81, 0x64, 0x74, 0x19, 0xF0, 0xE4, 0xA3, 0xF0, 
+0x22, 0xB1, 0x43, 0x90, 0x82, 0x03, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 0x01, 0xE4, 0x80, 0x02, 
+0xE4, 0xFD, 0xFF, 0x12, 0x4D, 0xFD, 0x90, 0x82, 0x03, 0xE0, 0x30, 0xE6, 0x11, 0x90, 0x01, 0x2F, 
+0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 0x90, 0x81, 
+0x45, 0xE0, 0x90, 0x04, 0xEC, 0x30, 0xE0, 0x06, 0xE0, 0x54, 0xDD, 0xF0, 0x80, 0x04, 0xE0, 0x44, 
+0x22, 0xF0, 0x71, 0x2C, 0xFD, 0x90, 0x81, 0x62, 0xE0, 0xFB, 0x21, 0x51, 0x90, 0x81, 0x5B, 0xE0, 
+0xFF, 0xA3, 0xE0, 0x22, 0x7E, 0x00, 0x7F, 0xA8, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x45, 
+0x12, 0x45, 0x44, 0x91, 0x15, 0x12, 0x45, 0x44, 0x90, 0x81, 0x48, 0x74, 0x02, 0xF0, 0x90, 0x81, 
+0x4F, 0x14, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x90, 0x81, 0x55, 0xE4, 0xF0, 0xA3, 0x74, 
+0x02, 0xF0, 0x71, 0xD9, 0xF0, 0xE4, 0xFD, 0xFF, 0x12, 0x4D, 0xFD, 0x7D, 0x0C, 0x7F, 0x02, 0x12, 
+0x4D, 0xFD, 0x12, 0x4D, 0xF9, 0x90, 0x80, 0x41, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 0x81, 0x54, 
+0x74, 0x99, 0xF0, 0x80, 0x29, 0xEF, 0xB4, 0x03, 0x08, 0x90, 0x81, 0x54, 0x74, 0x90, 0xF0, 0x80, 
+0x1D, 0x90, 0x81, 0x54, 0x74, 0x40, 0xF0, 0x90, 0x00, 0x2C, 0xE0, 0x54, 0x0F, 0xFF, 0xBF, 0x05, 
+0x08, 0x90, 0x81, 0x7F, 0x74, 0x02, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0x81, 0x7F, 0xF0, 0x12, 0x55, 
+0x17, 0x71, 0xD9, 0xF0, 0x7F, 0x01, 0x51, 0xB8, 0x7E, 0x00, 0x7F, 0x02, 0x7D, 0x00, 0x7B, 0x01, 
+0x7A, 0x81, 0x79, 0xF1, 0x12, 0x45, 0x44, 0x71, 0xEE, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 
+0x12, 0x4F, 0x43, 0xE4, 0x90, 0x81, 0xF3, 0xF0, 0x22, 0x90, 0x81, 0x7F, 0xE0, 0x24, 0x04, 0x90, 
+0x81, 0x61, 0xF0, 0xA3, 0x74, 0x08, 0x22, 0x7D, 0x02, 0x7F, 0x02, 0x02, 0x49, 0x86, 0x90, 0x06, 
+0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x22, 0x90, 0x81, 0xF8, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 0x90, 
+0x81, 0x45, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x22, 0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x4D, 
+0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x7E, 0x00, 0x7F, 0x04, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 
+0xF6, 0x22, 0xF0, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 0x02, 
+0x22, 0xE4, 0x90, 0x82, 0x03, 0xF0, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x56, 0x12, 0x47, 0xF3, 0x70, 
+0x51, 0xB1, 0x3B, 0x91, 0x22, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xB1, 0x30, 0xF0, 0x90, 
+0x82, 0x03, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x81, 0x50, 0xF0, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 
+0x16, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x02, 0x05, 0xE4, 0x90, 0x82, 0x03, 0xF0, 0x12, 0x5B, 0x43, 
+0xEF, 0x70, 0x04, 0x90, 0x82, 0x03, 0xF0, 0x90, 0x82, 0x03, 0xE0, 0x60, 0x15, 0xB1, 0x28, 0xE4, 
+0xF5, 0x1D, 0x90, 0x81, 0x51, 0x12, 0x47, 0x84, 0x90, 0x81, 0x4C, 0xE0, 0x20, 0xE2, 0x03, 0x12, 
+0x4B, 0xBA, 0x22, 0xE4, 0xF5, 0x4E, 0x90, 0x81, 0x49, 0xE0, 0x70, 0x02, 0xA1, 0x1F, 0x12, 0x47, 
+0xF3, 0x70, 0x7C, 0x91, 0x23, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xB1, 0x30, 0x12, 0x57, 
+0x6D, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 0x1E, 0x90, 0x81, 0x50, 0xE0, 0x14, 0xF0, 
+0xE0, 0xFF, 0x60, 0x06, 0x90, 0x81, 0x52, 0xE0, 0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 0x81, 0x4F, 
+0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x4E, 0x01, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x12, 0x90, 
+0x81, 0x44, 0xE0, 0xB4, 0x02, 0x03, 0xE4, 0xF5, 0x4E, 0x12, 0x5B, 0x43, 0xEF, 0x70, 0x02, 0xF5, 
+0x4E, 0xE5, 0x4E, 0x60, 0x2A, 0xB1, 0x28, 0x90, 0x81, 0x52, 0xE0, 0x60, 0x03, 0xB4, 0x01, 0x04, 
+0xB1, 0x20, 0x80, 0x08, 0xB1, 0x20, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 0x90, 0x81, 0x51, 
+0xE0, 0x2F, 0x12, 0x47, 0x85, 0x90, 0x81, 0x4C, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x4B, 0xBA, 0x22, 
+0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x52, 0xE0, 0x22, 0x90, 0x81, 0x4D, 0xE0, 0x44, 0x10, 0xF0, 0x22, 
+0xFF, 0xEE, 0x54, 0x3F, 0x90, 0x81, 0x84, 0xF0, 0xA3, 0xEF, 0x22, 0x90, 0x81, 0x4F, 0xE0, 0x90, 
+0x05, 0x73, 0x22, 0xE4, 0x90, 0x82, 0x04, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x00, 0x83, 0xE0, 
+0x90, 0x82, 0x04, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 0x90, 0x82, 0x04, 0xE0, 0xFF, 0xB5, 0x06, 
+0x01, 0x22, 0xC3, 0x90, 0x82, 0x06, 0xE0, 0x94, 0x64, 0x90, 0x82, 0x05, 0xE0, 0x94, 0x00, 0x40, 
+0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x82, 0x04, 0xE0, 0xFF, 0x22, 0x90, 0x82, 
+0x05, 0x12, 0x5F, 0xB2, 0x80, 0xC6, 0x90, 0x81, 0x40, 0xE0, 0xFF, 0x30, 0xE0, 0x05, 0x12, 0x5B, 
+0xBC, 0x60, 0x1B, 0x90, 0x81, 0x49, 0xE0, 0x70, 0x04, 0xEF, 0x30, 0xE0, 0x0B, 0x90, 0x81, 0x4C, 
+0xE0, 0x64, 0x02, 0x60, 0x09, 0x12, 0x56, 0xB0, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 0x90, 
+0x81, 0xFB, 0xE0, 0x60, 0x0F, 0xE4, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x05, 
+0xFD, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x81, 0x40, 0xE0, 0xFF, 0x30, 0xE0, 0x3F, 0x90, 0x81, 0x44, 
+0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x81, 0x43, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 
+0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x25, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x03, 0x02, 0x5C, 0x5D, 
+0x12, 0x5B, 0xA5, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x08, 0x06, 0xE4, 0xFD, 0x7F, 0x0C, 0x80, 0x09, 
+0x90, 0x81, 0x44, 0xE0, 0x70, 0x06, 0xFD, 0x7F, 0x04, 0x12, 0x4B, 0xBE, 0x22, 0x90, 0x81, 0x40, 
+0xE0, 0xFF, 0x30, 0xE0, 0x40, 0x90, 0x81, 0x44, 0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 
+0x90, 0x81, 0x43, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x26, 0xEF, 
+0xC3, 0x13, 0x30, 0xE0, 0x03, 0x02, 0x5C, 0x5D, 0x12, 0x57, 0x88, 0x90, 0x81, 0x44, 0xE0, 0xB4, 
+0x0C, 0x06, 0xE4, 0xFD, 0x7F, 0x08, 0x80, 0x0A, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x04, 0x06, 0xE4, 
+0xFD, 0xFF, 0x12, 0x4B, 0xBE, 0x22, 0x22, 0x90, 0x81, 0x45, 0xE0, 0xFF, 0xD1, 0x86, 0x30, 0xE0, 
+0x24, 0xEF, 0x54, 0x7F, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x81, 0x46, 0x30, 0xE1, 0x06, 0xE0, 
+0x44, 0x02, 0xF0, 0x80, 0x07, 0xE0, 0x54, 0xFD, 0xD1, 0x8D, 0x04, 0xF0, 0x90, 0x81, 0x49, 0xE0, 
+0x60, 0x03, 0x12, 0x58, 0x54, 0x22, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0xF0, 0x90, 0x01, 
+0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x22, 0x90, 0x01, 0xC4, 0x74, 0x98, 0xF0, 0x74, 0x76, 
+0xA3, 0xF0, 0x90, 0x00, 0x90, 0xE0, 0x20, 0xE0, 0xF9, 0x74, 0x98, 0x04, 0x90, 0x01, 0xC4, 0xF0, 
+0x74, 0x76, 0xA3, 0xF0, 0x22, 0xD1, 0xEA, 0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 0x90, 
+0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 
+0xEF, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0xF5, 0x1E, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x12, 
+0x47, 0x8E, 0x90, 0x81, 0x45, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x90, 0x81, 0x45, 0xE0, 0x13, 0x13, 
+0x13, 0x54, 0x1F, 0x22, 0x90, 0x81, 0x45, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x81, 0x52, 0xF0, 
+0xA3, 0xF0, 0x90, 0x81, 0x4D, 0xF0, 0x90, 0x81, 0x46, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 
+0x12, 0x49, 0x06, 0x7D, 0x02, 0x7F, 0x02, 0x12, 0x49, 0x0A, 0x7D, 0x10, 0x7F, 0x03, 0x02, 0x57, 
+0xBC, 0xEF, 0x24, 0xFE, 0x60, 0x0B, 0x04, 0x70, 0x24, 0x90, 0x81, 0x4F, 0x74, 0x02, 0xF0, 0x80, 
+0x13, 0xED, 0x70, 0x06, 0x90, 0x81, 0xF0, 0xE0, 0x80, 0x02, 0xED, 0x14, 0x90, 0x81, 0x4F, 0xF0, 
+0x90, 0x81, 0x4F, 0xE0, 0xA3, 0xF0, 0x90, 0x81, 0x46, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x7D, 0x2E, 
+0x7F, 0x6F, 0x12, 0x4D, 0xA9, 0x7D, 0x02, 0x7F, 0x01, 0x12, 0x4D, 0xFD, 0x12, 0x5F, 0xC8, 0x90, 
+0x81, 0x44, 0x74, 0x02, 0xF0, 0x22, 0x12, 0x4F, 0x43, 0x12, 0x4F, 0xD9, 0x12, 0x5E, 0x8E, 0x90, 
+0x81, 0x44, 0x74, 0x04, 0xF0, 0x22, 0x90, 0x81, 0xF4, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 
+0xE4, 0xA3, 0xF0, 0x90, 0x81, 0xF4, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x90, 0x81, 0x43, 0xE0, 0x64, 
+0x02, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0xE4, 0xFE, 0xEF, 0xC3, 0x13, 0xFD, 0xEF, 0x30, 
+0xE0, 0x02, 0x7E, 0x80, 0x90, 0xFD, 0x10, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 
+0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 
+0x22, 0xE0, 0x90, 0x01, 0xBA, 0xF0, 0x90, 0x81, 0x4B, 0xE0, 0x90, 0x01, 0xBB, 0x22, 0xEF, 0x13, 
+0x13, 0x13, 0x54, 0x1F, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 
+0xF0, 0xE0, 0x44, 0x80, 0x22, 0x7F, 0x70, 0x7E, 0x0E, 0x12, 0x2E, 0xA2, 0x90, 0x82, 0xAD, 0x22, 
+0x90, 0x81, 0xF6, 0xE0, 0x54, 0xFE, 0x4E, 0x22, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0x22, 
+0x4D, 0xFF, 0x90, 0x81, 0x40, 0xF0, 0xEE, 0x22, 0x36, 0x28,  
 };
-u4Byte ArrayLength_MP_8188E_FW_NIC_S = 15894;
+u4Byte ArrayLength_MP_8188E_FW_NIC = 14378;
 
 
 void
-ODM_ReadFirmware_MP_8188E_FW_NIC_S(
+ODM_ReadFirmware_MP_8188E_FW_NIC(
      IN   PDM_ODM_T    pDM_Odm,
      OUT  u1Byte       *pFirmware,
      OUT  u4Byte       *pFirmwareSize
 )
 {
-#if(DM_ODM_SUPPORT_TYPE & (ODM_CE))
-	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8188E_FW_NIC_S;
+ #if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+     *((SIZE_PTR*)pFirmware) = (SIZE_PTR)Array_MP_8188E_FW_NIC;
 #else
-	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8188E_FW_NIC_S, ArrayLength_MP_8188E_FW_NIC_S);
+     ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8188E_FW_NIC, ArrayLength_MP_8188E_FW_NIC);
 #endif
-	*pFirmwareSize = ArrayLength_MP_8188E_FW_NIC_S;
+     *pFirmwareSize = ArrayLength_MP_8188E_FW_NIC;
 }
 
 
-u1Byte Array_MP_8188E_FW_NIC_T[] = {
-0xE1, 0x88, 0x10, 0x00, 0x12, 0x00, 0x00, 0x00, 0x04, 0x03, 0x13, 0x39, 0xD8, 0x3A, 0x00, 0x00, 
-0xF1, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+u1Byte Array_MP_8188E_FW_NIC_89EM[] = {
+0xE1, 0x88, 0x40, 0x00, 0x14, 0x00, 0x00, 0x00, 0x09, 0x11, 0x20, 0x13, 0x70, 0x36, 0x00, 0x00, 
+0xEE, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x02, 0x45, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0xC1, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0xC1, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0xED, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0xC1, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0xFC, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
@@ -2110,8 +1958,8 @@ u1Byte Array_MP_8188E_FW_NIC_T[] = {
 0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 
 0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 
 0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 
-0xE7, 0x80, 0xBE, 0x00, 0x41, 0x82, 0xF9, 0x00, 0x41, 0x82, 0xFA, 0x00, 0x41, 0x83, 0x01, 0x00, 
-0x41, 0x83, 0x02, 0x01, 0x41, 0x83, 0x0A, 0x00, 0x52, 0x2F, 0x57, 0xD7, 0x5F, 0xEA, 0xC0, 0xE0, 
+0xE7, 0x80, 0xBE, 0x41, 0x82, 0x62, 0x00, 0x41, 0x82, 0x63, 0x00, 0x41, 0x82, 0x68, 0x00, 0x41, 
+0x82, 0x69, 0x00, 0x41, 0x82, 0x72, 0x00, 0x00, 0x50, 0xF3, 0x58, 0x0D, 0x5F, 0xDE, 0xC0, 0xE0, 
 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 
 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x0E, 
 0xF0, 0x74, 0x46, 0xA3, 0xF0, 0xD1, 0x7F, 0xE5, 0x3C, 0x30, 0xE7, 0x02, 0xD1, 0x64, 0x74, 0x0E, 
@@ -2125,1964 +1973,795 @@ u1Byte Array_MP_8188E_FW_NIC_T[] = {
 0x7F, 0x57, 0x12, 0x32, 0x1E, 0x53, 0x91, 0xEF, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 
 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 
 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xB9, 0xF0, 0x74, 0x46, 0xA3, 0xF0, 
-0x12, 0x71, 0x98, 0xE5, 0x41, 0x30, 0xE4, 0x02, 0xF1, 0x55, 0xE5, 0x41, 0x30, 0xE6, 0x02, 0xF1, 
-0xE0, 0xE5, 0x43, 0x30, 0xE0, 0x03, 0x12, 0x71, 0xF5, 0xE5, 0x43, 0x30, 0xE1, 0x03, 0x12, 0x56, 
-0xC0, 0xE5, 0x43, 0x30, 0xE2, 0x03, 0x12, 0x56, 0x74, 0xE5, 0x43, 0x30, 0xE3, 0x02, 0xF1, 0x68, 
-0xE5, 0x43, 0x30, 0xE4, 0x03, 0x12, 0x73, 0x07, 0xE5, 0x43, 0x30, 0xE5, 0x03, 0x12, 0x67, 0xCA, 
-0xE5, 0x43, 0x30, 0xE6, 0x02, 0xF1, 0x84, 0xE5, 0x44, 0x30, 0xE1, 0x03, 0x12, 0x73, 0x36, 0x74, 
-0xB9, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x46, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 
-0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 
-0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x12, 0x61, 0x95, 0x7F, 0x02, 0x8F, 0x0D, 0x7F, 0x02, 0x71, 0x27, 
-0x90, 0x80, 0x3C, 0xE0, 0x45, 0x0D, 0xF0, 0x22, 0x90, 0x81, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x13, 
-0x90, 0x81, 0x80, 0xE0, 0x60, 0x0D, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 
-0x12, 0x64, 0x27, 0x22, 0x90, 0x81, 0x36, 0xE0, 0xB4, 0x01, 0x13, 0x90, 0x81, 0x80, 0xE0, 0x60, 
-0x0D, 0x90, 0x81, 0x84, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0x07, 0x70, 0x02, 0xF1, 0x9F, 0x22, 0x90, 
-0x81, 0x77, 0xE0, 0x90, 0x81, 0x82, 0x30, 0xE0, 0x04, 0xE0, 0xFF, 0x80, 0x07, 0xE0, 0xFF, 0x7D, 
-0x01, 0x02, 0x48, 0xD1, 0xAE, 0x07, 0xF1, 0xD4, 0xBF, 0x01, 0x16, 0x90, 0x81, 0x77, 0xE0, 0xC4, 
-0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x0A, 0xAF, 0x06, 0x7D, 0x01, 0x12, 0x48, 0xD1, 0x7F, 0x01, 
-0x22, 0x7F, 0x00, 0x22, 0x90, 0x05, 0x43, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 
-0x90, 0x81, 0x77, 0xE0, 0x30, 0xE0, 0x05, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xC0, 0xE0, 0xC0, 
-0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 
-0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xED, 0xF0, 
-0x74, 0x47, 0xA3, 0xF0, 0x12, 0x71, 0xC5, 0xE5, 0x49, 0x30, 0xE1, 0x02, 0x11, 0x95, 0xE5, 0x49, 
-0x30, 0xE2, 0x03, 0x12, 0x73, 0xE1, 0xE5, 0x4A, 0x30, 0xE0, 0x03, 0x12, 0x74, 0x37, 0xE5, 0x4A, 
-0x30, 0xE4, 0x03, 0x12, 0x74, 0xF1, 0xE5, 0x4B, 0x30, 0xE1, 0x03, 0x12, 0x75, 0x07, 0xE5, 0x4B, 
-0x30, 0xE0, 0x03, 0x12, 0x73, 0x9A, 0xE5, 0x4B, 0x30, 0xE3, 0x02, 0xF1, 0xEE, 0xE5, 0x4C, 0x30, 
-0xE1, 0x05, 0x7F, 0x04, 0x12, 0x47, 0x5A, 0xE5, 0x4C, 0x30, 0xE4, 0x03, 0x12, 0x56, 0x60, 0xE5, 
-0x4C, 0x30, 0xE5, 0x03, 0x12, 0x75, 0x9E, 0xE5, 0x4C, 0x30, 0xE6, 0x03, 0x12, 0x75, 0xD3, 0x74, 
-0xED, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 
-0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 
-0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x81, 0x80, 0xE0, 0x60, 0x03, 0x12, 0x77, 0xC4, 0x90, 0x82, 
-0x26, 0xE0, 0x30, 0xE0, 0x13, 0x54, 0xFB, 0xF0, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x06, 0x7D, 0x04, 
-0x7F, 0x01, 0x61, 0x09, 0x7D, 0x31, 0x91, 0xC4, 0x22, 0xE4, 0xFD, 0x7F, 0x0C, 0x11, 0xD1, 0xE4, 
-0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 0x90, 0x80, 0x40, 0xED, 0xF0, 0x22, 0x7D, 0x01, 0x7F, 
-0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0x07, 0xED, 0xF0, 0x90, 0x81, 0x7C, 
-0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x41, 0x29, 0xEE, 0xC4, 0x13, 0x13, 
-0x13, 0x54, 0x01, 0x30, 0xE0, 0x02, 0x41, 0x29, 0x90, 0x81, 0x83, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 
-0x41, 0x29, 0xEF, 0x70, 0x02, 0x21, 0x90, 0x24, 0xFE, 0x70, 0x02, 0x21, 0xC9, 0x24, 0xFE, 0x60, 
-0x47, 0x24, 0xFC, 0x70, 0x02, 0x41, 0x04, 0x24, 0xFC, 0x60, 0x02, 0x41, 0x19, 0xEE, 0xB4, 0x0E, 
-0x02, 0x51, 0xB1, 0x90, 0x81, 0x83, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0xE1, 0x90, 0x81, 0x83, 
-0xE0, 0xB4, 0x06, 0x02, 0x51, 0x87, 0x90, 0x81, 0x83, 0xE0, 0xB4, 0x04, 0x0D, 0x90, 0x83, 0x07, 
-0xE0, 0xFF, 0x60, 0x04, 0xB1, 0x3E, 0x80, 0x02, 0xF1, 0xD1, 0x90, 0x81, 0x83, 0xE0, 0x64, 0x08, 
-0x60, 0x02, 0x41, 0x19, 0x91, 0x77, 0x41, 0x19, 0x90, 0x81, 0x83, 0xE0, 0x70, 0x04, 0x7F, 0x01, 
-0x51, 0xE1, 0x90, 0x81, 0x83, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x87, 0x90, 0x81, 0x83, 0xE0, 0xB4, 
-0x0E, 0x07, 0x51, 0x2E, 0xBF, 0x01, 0x02, 0x51, 0xB1, 0x90, 0x81, 0x83, 0xE0, 0x64, 0x0C, 0x60, 
-0x02, 0x41, 0x19, 0x51, 0x2E, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x41, 0x19, 0x71, 0x71, 0x41, 0x19, 
-0x90, 0x81, 0x83, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 0x2E, 0xBF, 0x01, 0x02, 0x51, 0xB1, 0x90, 0x81, 
-0x83, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x87, 0x90, 0x81, 0x83, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0x2E, 
-0xBF, 0x01, 0x02, 0x71, 0x71, 0x90, 0x81, 0x83, 0xE0, 0x64, 0x04, 0x70, 0x5C, 0x12, 0x76, 0xAC, 
-0xEF, 0x64, 0x01, 0x70, 0x54, 0x91, 0xA6, 0x80, 0x50, 0x90, 0x81, 0x83, 0xE0, 0xB4, 0x0E, 0x07, 
-0x51, 0x2E, 0xBF, 0x01, 0x02, 0x51, 0xB1, 0x90, 0x81, 0x83, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x87, 
-0x90, 0x81, 0x83, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0x2E, 0xBF, 0x01, 0x02, 0x71, 0x71, 0x90, 0x81, 
-0x83, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0xE1, 0x90, 0x81, 0x83, 0xE0, 0xB4, 0x04, 0x1A, 0x12, 
-0x77, 0x2C, 0x80, 0x15, 0x90, 0x81, 0x83, 0xE0, 0xB4, 0x0C, 0x0E, 0x90, 0x81, 0x7D, 0xE0, 0xFF, 
-0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x02, 0x91, 0x66, 0x90, 0x81, 0x83, 0xE0, 0x90, 0x01, 0xBA, 
-0xF0, 0x90, 0x81, 0x82, 0xE0, 0x90, 0x01, 0xBB, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x57, 
-0xA3, 0xEF, 0x64, 0x01, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x80, 0x40, 0x90, 0x81, 
-0x7C, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 
-0x80, 0x2C, 0x90, 0x81, 0x82, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x08, 
-0xF0, 0x80, 0x1B, 0x90, 0x82, 0x26, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x08, 0x90, 0x01, 
-0xB8, 0x74, 0x11, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x01, 
-0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x81, 0x7D, 0xE0, 0x90, 0x06, 0x04, 0x20, 0xE0, 
-0x0C, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x04, 0x7F, 0x01, 0x71, 0x09, 0x80, 0x0F, 0x71, 0x01, 0x90, 
-0x05, 0x27, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x81, 0x7B, 0x74, 0x0C, 0xF0, 0xE4, 0xFD, 0xFF, 0x01, 
-0xC2, 0x90, 0x81, 0x7D, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x04, 0x71, 0x05, 0x80, 0x1E, 0x90, 0x06, 
-0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x04, 0x7F, 0x01, 0x71, 0x09, 0x90, 
-0x05, 0x27, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x81, 0x7B, 0x74, 0x04, 0xF0, 0xE4, 0xFD, 0xFF, 0x01, 
-0xC2, 0x90, 0x83, 0x06, 0xEF, 0xF0, 0x12, 0x5D, 0x56, 0x90, 0x83, 0x06, 0xE0, 0x60, 0x05, 0xE4, 
-0xFD, 0xFF, 0x11, 0xC2, 0x7D, 0x04, 0x7F, 0x01, 0x71, 0x09, 0x90, 0x81, 0x7B, 0x74, 0x04, 0xF0, 
-0x22, 0xE0, 0x54, 0x7F, 0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
-0xAC, 0x07, 0xEF, 0x14, 0x60, 0x15, 0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 0x1A, 0xED, 0x54, 0x01, 
-0xFE, 0x90, 0x81, 0x7C, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0x80, 0x0C, 0x90, 0x81, 0x83, 0xED, 0xF0, 
-0x80, 0x05, 0x90, 0x81, 0x82, 0xED, 0xF0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE4, 0x2E, 0xEC, 0x14, 
-0x60, 0x07, 0x14, 0x60, 0x1D, 0x24, 0x02, 0x70, 0x23, 0x90, 0x81, 0x7C, 0xE0, 0x54, 0x01, 0xC4, 
-0x33, 0x33, 0x33, 0x54, 0x80, 0xFF, 0x90, 0x81, 0x83, 0xE0, 0x54, 0x7F, 0x4F, 0xFD, 0x7F, 0x88, 
-0x80, 0x07, 0x90, 0x81, 0x82, 0xE0, 0xFD, 0x7F, 0x89, 0x12, 0x32, 0x1E, 0xD0, 0xD0, 0x92, 0xAF, 
-0x22, 0x90, 0x81, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x35, 0x90, 0x81, 0x7D, 0xE0, 0x54, 0xFD, 0xF0, 
-0x7D, 0x2C, 0x7F, 0x6F, 0x11, 0xC2, 0x7D, 0x08, 0x7F, 0x01, 0xB1, 0x87, 0xBF, 0x01, 0x14, 0x90, 
-0x81, 0x7C, 0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x0E, 0x7F, 0x01, 0x71, 0x09, 0x90, 0x81, 0x7B, 0x74, 
-0x0E, 0xF0, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x04, 0xF0, 0x22, 0x7E, 
-0x00, 0x7F, 0xA3, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x7C, 0x12, 0x45, 0x44, 0x90, 0x81, 
-0x7F, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x86, 0x14, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x90, 
-0x81, 0x8B, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x90, 0x81, 0xB7, 0xE0, 0x24, 0x04, 0x90, 0x81, 
-0x95, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0xE4, 0xFD, 0xFF, 0x71, 0x09, 0x7D, 0x0C, 0x7F, 0x02, 0x71, 
-0x09, 0x71, 0x05, 0x90, 0x80, 0x41, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 0x81, 0x8A, 0x74, 0x99, 
-0xF0, 0x80, 0x15, 0xEF, 0x90, 0x81, 0x8A, 0xB4, 0x03, 0x05, 0x74, 0x90, 0xF0, 0x80, 0x09, 0x74, 
-0x40, 0xF0, 0x90, 0x81, 0xB7, 0x74, 0x02, 0xF0, 0x90, 0x82, 0x1F, 0x74, 0x03, 0xF0, 0xA3, 0x74, 
-0x05, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 0x28, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x90, 0x81, 0xB7, 
-0xE0, 0x24, 0x04, 0x90, 0x81, 0x95, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x12, 0x77, 0xA3, 0x7E, 0x00, 
-0x7F, 0x02, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x23, 0x12, 0x45, 0x44, 0x90, 0x06, 0x04, 
-0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0xE4, 0xFD, 0xFF, 0x11, 0xC2, 
-0xE4, 0x90, 0x82, 0x25, 0xF0, 0x22, 0x7D, 0x2F, 0x91, 0xC4, 0x7D, 0x08, 0x7F, 0x01, 0x71, 0x09, 
-0x90, 0x81, 0x7B, 0x74, 0x08, 0xF0, 0x22, 0x12, 0x5D, 0x56, 0xE4, 0xFD, 0xFF, 0x11, 0xC2, 0x71, 
-0x05, 0x90, 0x81, 0x7B, 0x74, 0x0C, 0xF0, 0x22, 0x90, 0x81, 0x80, 0xE0, 0x64, 0x01, 0x70, 0x15, 
-0x90, 0x81, 0x7E, 0xE0, 0x54, 0x0F, 0x60, 0x05, 0x11, 0xB9, 0x02, 0x73, 0xFB, 0x90, 0x81, 0x83, 
-0xE0, 0x70, 0x02, 0x11, 0xCD, 0x22, 0x7D, 0x2D, 0xD1, 0x4E, 0x90, 0x01, 0x37, 0x74, 0x02, 0xF0, 
-0xFD, 0x7F, 0x03, 0x12, 0x54, 0xFC, 0x91, 0xC8, 0xE4, 0xFD, 0x7F, 0x01, 0x71, 0x09, 0xE4, 0x90, 
-0x81, 0x7B, 0xF0, 0x22, 0x7F, 0xFF, 0x11, 0xC2, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xD1, 
-0x52, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0xCC, 0xF0, 0x00, 0xC0, 0x7F, 0x8C, 0x7E, 0x08, 0x12, 
-0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x14, 0x7F, 0x70, 0x7E, 0x0E, 
-0x12, 0x2E, 0xA2, 0x90, 0x82, 0xDD, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFD, 0xFF, 
-0x12, 0x5C, 0x32, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x82, 
-0xEE, 0x12, 0x20, 0xCE, 0x90, 0x82, 0xEE, 0x12, 0x44, 0xCF, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 
-0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 
-0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x60, 
-0x41, 0x90, 0x81, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x39, 0x90, 0x81, 0x7D, 0xE0, 0x54, 0xFE, 0xF0, 
-0x7D, 0x2B, 0x7F, 0x0F, 0x11, 0xC2, 0x90, 0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 0xB1, 0x83, 0xBF, 
-0x01, 0x14, 0x90, 0x81, 0x7C, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x06, 0x7F, 0x01, 0x71, 0x09, 0x90, 
-0x81, 0x7B, 0x74, 0x06, 0xF0, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x74, 
-0x08, 0xF0, 0x22, 0x7D, 0x08, 0xE4, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 
-0xE1, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x80, 0x3E, 0xE0, 0x04, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 
-0x60, 0x21, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x82, 0xE5, 0xF0, 0x7D, 0x26, 0xD1, 0x4E, 0xEF, 0x64, 
-0x01, 0x70, 0x03, 0x12, 0x7A, 0x15, 0x90, 0x82, 0xE5, 0xE0, 0xFF, 0x7D, 0x27, 0x11, 0xC2, 0xB1, 
-0xD5, 0x80, 0x05, 0xB1, 0xD5, 0x12, 0x7A, 0x15, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x7F, 0x01, 
-0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x82, 0xE1, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x90, 0x83, 0x09, 0xEF, 0xF0, 0x90, 0x80, 0x44, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 
-0x70, 0x47, 0x90, 0x81, 0x83, 0xE0, 0x64, 0x0E, 0x70, 0x14, 0x90, 0x83, 0x09, 0xE0, 0x70, 0x39, 
-0x90, 0x81, 0x7C, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x04, 0x71, 0x01, 0x80, 0x26, 0x90, 0x81, 
-0x83, 0xE0, 0x64, 0x06, 0x70, 0x23, 0x90, 0x83, 0x09, 0xE0, 0x60, 0x1D, 0x90, 0x81, 0x7C, 0xE0, 
-0x54, 0xBF, 0xF0, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x81, 
-0x83, 0x74, 0x04, 0xF0, 0xE4, 0xFD, 0xFF, 0x11, 0xC2, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x73, 
-0xFB, 0x90, 0x81, 0x83, 0xE0, 0x64, 0x0C, 0x60, 0x04, 0x11, 0xB9, 0xB1, 0x83, 0x22, 0x7F, 0xFF, 
-0x11, 0xC2, 0xE4, 0x90, 0x82, 0xFF, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 
-0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 
-0x83, 0x00, 0xE0, 0x94, 0xE8, 0x90, 0x82, 0xFF, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 
-0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x82, 
-0xFF, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x44, 0x9F, 0x80, 0xBF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x90, 0x82, 0xF2, 0xEF, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x1C, 0x90, 0x05, 0x22, 0xE0, 
-0x90, 0x82, 0xF5, 0xF0, 0x7D, 0x29, 0xD1, 0x4E, 0xBF, 0x01, 0x02, 0xD1, 0xD5, 0x90, 0x82, 0xF5, 
-0xE0, 0xFF, 0x7D, 0x2A, 0x11, 0xC2, 0x80, 0x02, 0xD1, 0xD5, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 
-0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x80, 0x45, 0xE0, 0xFF, 0x7B, 0x08, 0x7D, 0x01, 0xF1, 0x3A, 
-0x90, 0x82, 0xF3, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x82, 0xF2, 0xE0, 0xFF, 0x74, 
-0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x1D, 
-0x74, 0x21, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x10, 0xF0, 0x74, 0x1F, 
-0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0x22, 0x74, 0x21, 0x2D, 
-0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xEF, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 
-0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x90, 0x82, 0xF7, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x82, 0xF6, 0xEF, 0xF0, 0xE4, 0xFD, 
-0xFC, 0x12, 0x7A, 0xC2, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0x82, 0xF6, 0xE0, 0x90, 0x04, 0x25, 0xF0, 
-0x90, 0x82, 0xF7, 0xE0, 0x60, 0x0E, 0x74, 0x0F, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
-0xE0, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x08, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
-0xE4, 0xF0, 0x74, 0x09, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 
-0xAF, 0x05, 0x74, 0x16, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0x01, 0xFE, 
-0x90, 0x82, 0xF8, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0x74, 0x16, 
-0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEE, 0xF0, 0x74, 0x21, 0x2F, 0xF5, 0x82, 0xE4, 
-0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 
-0x22, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0xE4, 0xFD, 0xFF, 0x11, 0xC2, 0x7D, 0x0C, 0x7F, 
-0x01, 0x61, 0x09, 0x7D, 0x20, 0x91, 0xC4, 0x90, 0x81, 0x7A, 0x74, 0x02, 0xF0, 0x22, 0x22, 0xF1, 
-0xF3, 0x80, 0xF0, 0x90, 0x81, 0x7A, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x01, 0xC8, 0xE4, 0xF0, 0xA3, 
-0xF0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x37, 0x7F, 0xFF, 0xFE, 0x12, 0x2B, 0x27, 0xBF, 
-0x01, 0x09, 0x90, 0x82, 0x37, 0xE0, 0x64, 0x03, 0x60, 0x03, 0x22, 0x01, 0xBC, 0xE4, 0x90, 0x82, 
-0x3C, 0xF0, 0x90, 0x82, 0x3C, 0xE0, 0xFF, 0xC3, 0x94, 0x02, 0x40, 0x02, 0x01, 0xF7, 0xC3, 0x74, 
-0xFE, 0x9F, 0xFF, 0xE4, 0x94, 0x00, 0xFE, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x38, 0x12, 0x2B, 0x27, 
-0xEF, 0x64, 0x01, 0x70, 0x77, 0x90, 0x82, 0x38, 0xE0, 0xFF, 0x54, 0xC0, 0xFE, 0x60, 0x05, 0xEF, 
-0x54, 0x0C, 0x70, 0x16, 0x90, 0x82, 0x38, 0xE0, 0xFF, 0x54, 0x30, 0x60, 0x67, 0xEF, 0x54, 0x03, 
-0x60, 0x62, 0x90, 0x82, 0x39, 0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0x82, 0x39, 0xF0, 0x90, 
-0x82, 0x39, 0xE0, 0x90, 0x82, 0x38, 0x70, 0x16, 0xE0, 0xFF, 0xEE, 0x13, 0x13, 0x54, 0x3F, 0x90, 
-0x82, 0x3A, 0xF0, 0xEF, 0x54, 0x0C, 0x13, 0x13, 0x54, 0x3F, 0xA3, 0xF0, 0x80, 0x0D, 0xE0, 0xFE, 
-0x54, 0x30, 0x90, 0x82, 0x3A, 0xF0, 0xEE, 0x54, 0x03, 0xA3, 0xF0, 0x90, 0x82, 0x3A, 0xE0, 0x64, 
-0x30, 0x70, 0x54, 0xA3, 0xE0, 0x64, 0x02, 0x70, 0x4E, 0x90, 0x00, 0xF5, 0xE0, 0x54, 0x40, 0x90, 
-0x82, 0x3D, 0xF0, 0xE0, 0x70, 0x41, 0xA3, 0x74, 0x02, 0xF0, 0x80, 0x10, 0x90, 0x82, 0x3E, 0x74, 
-0x01, 0xF0, 0x80, 0x08, 0x90, 0x82, 0x3C, 0xE0, 0x04, 0xF0, 0x01, 0x22, 0x90, 0x01, 0xC4, 0x74, 
-0xFA, 0xF0, 0x74, 0x4F, 0xA3, 0xF0, 0x90, 0x82, 0x3E, 0xE0, 0x90, 0x01, 0xC8, 0xF0, 0x90, 0x82, 
-0x38, 0xE0, 0x90, 0x01, 0xC9, 0xF0, 0x90, 0x82, 0x39, 0xE0, 0x90, 0x01, 0xCA, 0xF0, 0xE4, 0xFD, 
-0x7F, 0x1F, 0x12, 0x32, 0x1E, 0x80, 0xD5, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x20, 0xE7, 0x09, 0xE0, 
-0x7F, 0x01, 0x20, 0xE6, 0x0C, 0x7F, 0x02, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x30, 0xE6, 0x02, 0x7F, 
-0x03, 0x22, 0x11, 0xF8, 0x90, 0x80, 0x41, 0xEF, 0xF0, 0x31, 0x24, 0x90, 0x01, 0x64, 0x74, 0x01, 
-0xF0, 0x02, 0x2D, 0xA7, 0x31, 0x93, 0x31, 0xC3, 0x31, 0x52, 0x31, 0x71, 0xE4, 0xF5, 0x35, 0xF5, 
-0x36, 0xF5, 0x37, 0x75, 0x38, 0x80, 0xAD, 0x35, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xAD, 0x36, 0x7F, 
-0x51, 0x12, 0x32, 0x1E, 0xAD, 0x37, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xAD, 0x38, 0x7F, 0x53, 0x02, 
-0x32, 0x1E, 0x75, 0x3D, 0x10, 0xE4, 0xF5, 0x3E, 0x75, 0x3F, 0x07, 0x75, 0x40, 0x02, 0x90, 0x01, 
-0x30, 0xE5, 0x3D, 0xF0, 0xA3, 0xE5, 0x3E, 0xF0, 0xA3, 0xE5, 0x3F, 0xF0, 0xA3, 0xE5, 0x40, 0xF0, 
-0x22, 0x75, 0x45, 0x06, 0x75, 0x46, 0x01, 0x43, 0x46, 0x10, 0x75, 0x47, 0x03, 0x75, 0x48, 0x62, 
-0x90, 0x01, 0x38, 0xE5, 0x45, 0xF0, 0xA3, 0xE5, 0x46, 0xF0, 0xA3, 0xE5, 0x47, 0xF0, 0xA3, 0xE5, 
-0x48, 0xF0, 0x22, 0x90, 0x01, 0x30, 0xE4, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 
-0x38, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xFD, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 
-0x7F, 0x51, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x53, 
-0x02, 0x32, 0x1E, 0x90, 0x01, 0x34, 0x74, 0xFF, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 
-0x01, 0x3C, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xFD, 0x7F, 0x54, 0x12, 0x32, 0x1E, 0x7D, 
-0xFF, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x56, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 
-0x57, 0x02, 0x32, 0x1E, 0x90, 0x01, 0xCF, 0xE0, 0x90, 0x83, 0x05, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 
-0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x22, 0x90, 0x01, 0xCF, 0xE0, 
-0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x31, 0x93, 
-0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x32, 0x1E, 0x80, 0xFE, 0x22, 0x90, 
-0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x90, 0xFD, 0x00, 0xE0, 0x54, 
-0xBF, 0xF0, 0x12, 0x4F, 0xFA, 0x51, 0xB4, 0x12, 0x32, 0x77, 0x12, 0x71, 0x05, 0x51, 0xCF, 0x7F, 
-0x01, 0x12, 0x42, 0x15, 0x90, 0x82, 0x2C, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x42, 0x15, 0x90, 0x82, 
-0x2C, 0xE0, 0x04, 0xF0, 0x31, 0x12, 0x51, 0x83, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 
-0x80, 0x12, 0x32, 0x1E, 0x75, 0x20, 0xFF, 0x51, 0xA3, 0x12, 0x71, 0x35, 0x51, 0xAA, 0xE4, 0xFF, 
-0x02, 0x42, 0x9E, 0x51, 0x9D, 0x51, 0xC1, 0x51, 0xF2, 0x12, 0x4B, 0xAF, 0x51, 0xDD, 0x7E, 0x00, 
-0x7F, 0x04, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x28, 0x02, 0x45, 0x44, 0xE4, 0x90, 0x81, 
-0x36, 0xF0, 0x22, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x84, 0x22, 0x90, 0x01, 0xE4, 0x74, 0x12, 0xF0, 
-0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 
-0x22, 0xE4, 0x90, 0x81, 0x31, 0xF0, 0xA3, 0xF0, 0x90, 0x80, 0x99, 0xF0, 0xA3, 0xF0, 0x22, 0xE4, 
-0x90, 0x80, 0x3C, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x82, 0x26, 
-0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0x82, 0x26, 0xE0, 0x54, 0xFB, 
-0xF0, 0x22, 0x7E, 0x00, 0x7F, 0x01, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x77, 0x12, 0x45, 
-0x44, 0x90, 0x81, 0x77, 0xE0, 0x54, 0xFD, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 
-0x74, 0x0C, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8B, 0x52, 0x8A, 0x53, 0x89, 
-0x54, 0x90, 0x05, 0x27, 0xE0, 0xF5, 0x55, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x81, 
-0x77, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0xFF, 
-0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 0xFF, 0x90, 0x81, 0x77, 
-0xF0, 0xEE, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 
-0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x4D, 0xFF, 0x90, 0x81, 0x77, 0xF0, 0xEE, 0x54, 0x20, 0xFE, 0xEF, 
-0x54, 0xDF, 0x4E, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 0x4D, 
-0x90, 0x81, 0x77, 0xF0, 0xEE, 0xC3, 0x13, 0x20, 0xE0, 0x02, 0x81, 0x2F, 0xE0, 0x20, 0xE0, 0x02, 
-0x81, 0x16, 0x75, 0x55, 0x21, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0x91, 0xF3, 0x43, 0x55, 
-0x08, 0x80, 0x0C, 0xE4, 0x90, 0x81, 0x78, 0xF0, 0xA3, 0xF0, 0x7D, 0x40, 0xFF, 0xB1, 0x1B, 0x90, 
-0x81, 0x77, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x12, 0xEF, 
-0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x14, 0x90, 0x81, 0x77, 0xE0, 0xC4, 0x13, 0x54, 
-0x07, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x80, 0x90, 0x81, 0x77, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 
-0x20, 0xE0, 0x03, 0x43, 0x55, 0x40, 0x90, 0x05, 0x27, 0xE5, 0x55, 0xF0, 0x90, 0x81, 0x7A, 0xE0, 
-0x70, 0x05, 0x7F, 0x01, 0x12, 0x78, 0x77, 0x90, 0x81, 0x77, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 
-0x03, 0x30, 0xE0, 0x04, 0x7F, 0x04, 0x80, 0x22, 0x12, 0x47, 0xD4, 0xEF, 0x60, 0x04, 0x7F, 0x01, 
-0x80, 0x18, 0x7F, 0x02, 0x80, 0x14, 0x75, 0x55, 0x01, 0x90, 0x05, 0x27, 0xE5, 0x55, 0xF0, 0x90, 
-0x81, 0x7A, 0xE0, 0x64, 0x04, 0x60, 0x02, 0x81, 0xEE, 0xFF, 0x12, 0x78, 0x77, 0x81, 0xEE, 0x90, 
-0x81, 0x77, 0xE0, 0xFF, 0x20, 0xE0, 0x02, 0x81, 0xBC, 0x43, 0x55, 0x31, 0x13, 0x13, 0x54, 0x3F, 
-0x30, 0xE0, 0x07, 0x91, 0xF3, 0x43, 0x55, 0x08, 0x80, 0x06, 0x7D, 0x40, 0xE4, 0xFF, 0xB1, 0x1B, 
-0x90, 0x81, 0x77, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x02, 
-0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x04, 0x90, 0x05, 0x27, 0xE5, 0x55, 0xF0, 
-0x90, 0x81, 0x77, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x0E, 0x90, 0x81, 0x7B, 
-0xE0, 0x64, 0x02, 0x60, 0x69, 0xE4, 0xFD, 0x7F, 0x02, 0x80, 0x22, 0x90, 0x05, 0x27, 0xE0, 0x44, 
-0x40, 0xF0, 0x90, 0x81, 0x7B, 0xE0, 0xB4, 0x02, 0x19, 0xF1, 0xBC, 0x12, 0x47, 0xD4, 0xBF, 0x01, 
-0x09, 0x90, 0x81, 0x82, 0xE0, 0xFF, 0x7D, 0x01, 0x80, 0x03, 0xE4, 0xFD, 0xFF, 0x12, 0x48, 0xD1, 
-0x80, 0x3C, 0x90, 0x81, 0x83, 0xE0, 0x90, 0x81, 0x7B, 0xF0, 0x80, 0x32, 0x75, 0x55, 0x01, 0x90, 
-0x05, 0x27, 0xE5, 0x55, 0xF0, 0x90, 0x81, 0x7B, 0xE0, 0xB4, 0x02, 0x06, 0x7D, 0x01, 0x7F, 0x04, 
-0x80, 0x0B, 0x90, 0x81, 0x7B, 0xE0, 0xB4, 0x08, 0x07, 0x7D, 0x01, 0x7F, 0x0C, 0x12, 0x48, 0xD1, 
-0xF1, 0x9A, 0x90, 0x81, 0x82, 0xE0, 0xFF, 0x7D, 0x01, 0x12, 0x48, 0xD1, 0x51, 0xF2, 0xD0, 0xD0, 
-0x92, 0xAF, 0x22, 0x90, 0x01, 0x34, 0x74, 0x40, 0xF0, 0xFD, 0xE4, 0xFF, 0x74, 0x3D, 0x2F, 0xF8, 
-0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 
-0x22, 0x7D, 0x02, 0x7F, 0x02, 0xB1, 0x1B, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x3D, 0x2F, 0xF8, 0xE6, 
-0xFE, 0xED, 0xF4, 0x5E, 0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 
-0xEE, 0xF0, 0x22, 0xAC, 0x07, 0xEF, 0x54, 0x01, 0xFE, 0x90, 0x82, 0x28, 0xE0, 0x54, 0xFE, 0x4E, 
-0xF0, 0xEF, 0x64, 0x01, 0x70, 0x20, 0x90, 0x01, 0x53, 0xF0, 0x90, 0x82, 0x2A, 0xE0, 0x60, 0x0F, 
-0x7D, 0x10, 0x7F, 0x03, 0xF1, 0x85, 0x90, 0x82, 0x2A, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 0xB1, 
-0x6B, 0xB1, 0x11, 0x02, 0x4C, 0x66, 0xB1, 0x6B, 0x02, 0x4C, 0x77, 0x90, 0x01, 0x53, 0x74, 0x03, 
-0xF0, 0x7D, 0x10, 0xFF, 0x74, 0x45, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0xFE, 0xF6, 0x74, 
-0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0xEF, 0x70, 0x4E, 0x7D, 
-0x78, 0x7F, 0x02, 0xB1, 0x1B, 0x7D, 0x02, 0x7F, 0x03, 0xB1, 0x1B, 0x7D, 0xC8, 0x7F, 0x02, 0xB1, 
-0x74, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x36, 0xE0, 
-0x70, 0x15, 0x12, 0x5D, 0x56, 0x12, 0x4F, 0xD1, 0x90, 0x81, 0x7C, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 
-0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x80, 0x07, 0x7D, 0x01, 0x7F, 0x0C, 0x12, 0x48, 0xD1, 0x90, 0x81, 
-0x7C, 0xE0, 0x54, 0xF7, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 0x90, 0x01, 0x36, 
-0x74, 0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x91, 0xFC, 0x7D, 0x02, 0x7F, 0x03, 
-0x91, 0xFC, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0xF0, 0x90, 0x81, 0x8B, 0xA3, 0xE0, 0x90, 0x05, 
-0x58, 0xF0, 0x90, 0x81, 0x36, 0xE0, 0xB4, 0x01, 0x15, 0x90, 0x81, 0x7D, 0xE0, 0x54, 0xFB, 0xF0, 
-0x90, 0x81, 0x83, 0xE0, 0x20, 0xE2, 0x0E, 0x7D, 0x01, 0x7F, 0x04, 0x02, 0x48, 0xD1, 0x90, 0x81, 
-0x7D, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x90, 0x82, 0x28, 0xE0, 0x30, 0xE0, 0x32, 0x90, 0x82, 0x2A, 
-0xE0, 0x90, 0x05, 0x73, 0xF0, 0x90, 0x82, 0x2B, 0xE0, 0x60, 0x05, 0x14, 0xF0, 0x02, 0x4C, 0x66, 
-0x90, 0x82, 0x29, 0xE0, 0x14, 0x90, 0x82, 0x2B, 0xF0, 0x90, 0x05, 0x73, 0x74, 0x01, 0xF0, 0xE4, 
-0xFF, 0xB1, 0x33, 0x7D, 0x02, 0x7F, 0x02, 0x91, 0xFC, 0x7D, 0x01, 0x7F, 0x02, 0x91, 0xFC, 0x22, 
-0x12, 0x77, 0x48, 0x90, 0x81, 0x86, 0xE0, 0x14, 0x90, 0x05, 0x73, 0xF0, 0x7D, 0x02, 0x7F, 0x02, 
-0x91, 0xFC, 0x80, 0xB2, 0x90, 0x81, 0x77, 0xE0, 0xFF, 0x30, 0xE0, 0x08, 0x90, 0x81, 0x7B, 0xE0, 
-0x64, 0x02, 0x60, 0x3B, 0x90, 0x81, 0x80, 0xE0, 0x70, 0x04, 0xEF, 0x30, 0xE0, 0x0B, 0x90, 0x81, 
-0x83, 0xE0, 0x64, 0x02, 0x60, 0x29, 0x12, 0x65, 0x92, 0x90, 0x81, 0x7D, 0xE0, 0x13, 0x13, 0x13, 
-0x54, 0x1F, 0x30, 0xE0, 0x14, 0x90, 0x81, 0x86, 0xE0, 0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x0A, 0xF1, 
-0x76, 0xB1, 0x11, 0x90, 0x81, 0x87, 0xE0, 0x14, 0xF0, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 
-0x90, 0x81, 0x77, 0xE0, 0x30, 0xE0, 0x06, 0x90, 0x81, 0x79, 0x74, 0x01, 0xF0, 0x90, 0x81, 0x80, 
-0xE0, 0x60, 0x6F, 0x90, 0x81, 0x7C, 0xE0, 0x30, 0xE0, 0x23, 0x90, 0x81, 0x94, 0xE0, 0x04, 0xF0, 
-0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 0x02, 0xCE, 0xC3, 0x13, 
-0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x81, 0xB1, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x81, 0x7D, 
-0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x12, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 
-0x0B, 0xB1, 0x11, 0x90, 0x81, 0x86, 0xE0, 0x14, 0x90, 0x05, 0x73, 0xF0, 0x90, 0x82, 0xFD, 0xE4, 
-0x75, 0xF0, 0x01, 0x12, 0x44, 0x9F, 0xC3, 0x90, 0x82, 0xFE, 0xE0, 0x94, 0x80, 0x90, 0x82, 0xFD, 
-0xE0, 0x64, 0x80, 0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 
-0x01, 0xF0, 0xF1, 0x5D, 0x90, 0x82, 0x28, 0xE0, 0x30, 0xE0, 0x11, 0x90, 0x01, 0x3B, 0xE0, 0x30, 
-0xE4, 0x0A, 0xB1, 0x11, 0x90, 0x82, 0x2A, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 0x90, 0x82, 0x26, 
-0xE0, 0x30, 0xE0, 0x11, 0xE4, 0xF5, 0x1D, 0xA3, 0x12, 0x64, 0x2E, 0x90, 0x82, 0x26, 0xE0, 0x44, 
-0x04, 0xF0, 0x12, 0x78, 0x0F, 0x22, 0xEF, 0x14, 0x90, 0x05, 0x73, 0xF0, 0x90, 0x01, 0x3F, 0x74, 
-0x10, 0xF0, 0xFD, 0x7F, 0x03, 0x74, 0x45, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 
-0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0xF1, 0xA3, 0xEF, 0x70, 0x03, 0x12, 
-0x4C, 0x88, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x90, 0x04, 0x1B, 
-0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0xE4, 0xFD, 0xFF, 0x12, 
-0x48, 0xC2, 0x7D, 0x04, 0x7F, 0x01, 0x12, 0x4B, 0x09, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 
-0x90, 0x81, 0x7B, 0x74, 0x04, 0xF0, 0x22, 0xE4, 0x90, 0x82, 0x3F, 0xF0, 0x90, 0x82, 0x3F, 0xE0, 
-0x64, 0x01, 0xF0, 0x24, 0xD7, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x57, 0xA3, 0xF0, 0x90, 0x81, 0x80, 
-0xE0, 0x60, 0x0F, 0x90, 0x81, 0x83, 0xE0, 0xFF, 0x90, 0x81, 0x82, 0xE0, 0x6F, 0x60, 0x03, 0x12, 
-0x47, 0x9F, 0xC2, 0xAF, 0x91, 0x7F, 0xBF, 0x01, 0x02, 0x11, 0x1C, 0xD2, 0xAF, 0x91, 0x54, 0x12, 
-0x32, 0x9E, 0xBF, 0x01, 0x02, 0x31, 0x25, 0x12, 0x41, 0x4D, 0x80, 0xC0, 0x90, 0x81, 0x7C, 0xE0, 
-0x30, 0xE0, 0x18, 0x90, 0x81, 0x77, 0xE0, 0xFF, 0x30, 0xE0, 0x0E, 0xC3, 0x13, 0x30, 0xE0, 0x07, 
-0x91, 0x55, 0xBF, 0x01, 0x06, 0x80, 0x02, 0x80, 0x00, 0x11, 0x3C, 0x22, 0x90, 0x81, 0x83, 0xE0, 
-0xFF, 0x60, 0x03, 0xB4, 0x08, 0x0D, 0x91, 0xB0, 0xBF, 0x01, 0x08, 0x11, 0x54, 0x90, 0x01, 0xE5, 
-0xE0, 0x04, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x11, 0x7E, 0x11, 0x64, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0x91, 0x62, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 0xFD, 0x7F, 0x08, 0x12, 
-0x32, 0x1E, 0xE4, 0xFF, 0x11, 0xCA, 0x90, 0x81, 0x7D, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0x90, 0x81, 
-0x7D, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x81, 0x8A, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x32, 0x1E, 0x90, 
-0x81, 0x81, 0xE0, 0x60, 0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 
-0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 0xFD, 0x7F, 0x08, 
-0x12, 0x32, 0x1E, 0x7F, 0x01, 0x11, 0xCA, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x90, 
-0x12, 0x32, 0x1E, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x32, 0xAA, 0x90, 0x82, 0x40, 0xEF, 0xF0, 0xE4, 
-0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 
-0x82, 0x40, 0xE0, 0x6F, 0x60, 0x3E, 0xC3, 0x90, 0x82, 0x42, 0xE0, 0x94, 0x88, 0x90, 0x82, 0x41, 
-0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x82, 0x41, 
-0xE4, 0x75, 0xF0, 0x01, 0x12, 0x44, 0x9F, 0x7F, 0x14, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0xD3, 0x90, 
-0x82, 0x42, 0xE0, 0x94, 0x32, 0x90, 0x82, 0x41, 0xE0, 0x94, 0x00, 0x40, 0xB7, 0x90, 0x01, 0xC6, 
-0xE0, 0x30, 0xE0, 0xB0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x2D, 0xA7, 0xE4, 
-0xF5, 0x51, 0x12, 0x32, 0x9E, 0xEF, 0x60, 0x72, 0x63, 0x51, 0x01, 0xE5, 0x51, 0x24, 0x25, 0x90, 
-0x01, 0xC4, 0xF0, 0x74, 0x59, 0xA3, 0xF0, 0x90, 0x00, 0x88, 0xE0, 0xF5, 0x4F, 0xF5, 0x50, 0x54, 
-0x0F, 0x60, 0xDF, 0xE5, 0x4F, 0x30, 0xE0, 0x0B, 0x20, 0xE4, 0x03, 0x12, 0x29, 0xC5, 0x53, 0x50, 
-0xEE, 0x80, 0x3E, 0xE5, 0x4F, 0x30, 0xE1, 0x16, 0x20, 0xE5, 0x0E, 0x12, 0x11, 0xBD, 0xEF, 0x70, 
-0x03, 0x43, 0x50, 0x20, 0x90, 0x01, 0x06, 0xE4, 0xF0, 0x53, 0x50, 0xFD, 0x80, 0x23, 0xE5, 0x4F, 
-0x30, 0xE2, 0x0B, 0x20, 0xE6, 0x03, 0x12, 0x69, 0x86, 0x53, 0x50, 0xFB, 0x80, 0x13, 0xE5, 0x4F, 
-0x30, 0xE3, 0x0E, 0x20, 0xE7, 0x08, 0x31, 0xAF, 0xEF, 0x70, 0x03, 0x43, 0x50, 0x80, 0x53, 0x50, 
-0xF7, 0xAD, 0x50, 0x7F, 0x88, 0x12, 0x32, 0x1E, 0x80, 0x88, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x78, 
-0x10, 0x74, 0x01, 0xF2, 0x90, 0x02, 0x09, 0xE0, 0x78, 0x00, 0xF2, 0x08, 0x74, 0x20, 0xF2, 0x18, 
-0xE2, 0xFF, 0x30, 0xE0, 0x05, 0x08, 0xE2, 0x24, 0x80, 0xF2, 0xEF, 0xC3, 0x13, 0x90, 0xFD, 0x10, 
-0xF0, 0x78, 0x01, 0xE2, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x78, 0x03, 
-0xF2, 0x64, 0x04, 0x60, 0x0D, 0xE2, 0xFF, 0x64, 0x08, 0x60, 0x07, 0xEF, 0x64, 0x0C, 0x60, 0x02, 
-0x81, 0x20, 0xE4, 0x78, 0x02, 0xF2, 0x78, 0x03, 0xE2, 0xFF, 0x18, 0xE2, 0xC3, 0x9F, 0x50, 0x2D, 
-0xE2, 0xFD, 0x18, 0xE2, 0x2D, 0x90, 0x82, 0x40, 0xF0, 0xE0, 0xFF, 0x24, 0x00, 0xF5, 0x82, 0xE4, 
-0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x04, 0x2D, 0xF8, 0xEE, 0xF2, 0xEF, 0xB4, 0xFF, 0x06, 
-0x90, 0xFD, 0x10, 0xE0, 0x04, 0xF0, 0x78, 0x02, 0xE2, 0x04, 0xF2, 0x80, 0xC9, 0x78, 0x04, 0xE2, 
-0x78, 0x12, 0xF2, 0xFF, 0x78, 0x05, 0xE2, 0x78, 0x11, 0xF2, 0x78, 0x06, 0xE2, 0x78, 0x13, 0xF2, 
-0x78, 0x07, 0xE2, 0x78, 0x14, 0xF2, 0x78, 0x08, 0xE2, 0x78, 0x33, 0xF2, 0x78, 0x09, 0xE2, 0x78, 
-0x34, 0xF2, 0x78, 0x0A, 0xE2, 0x78, 0x35, 0xF2, 0x78, 0x0B, 0xE2, 0x78, 0x36, 0xF2, 0x78, 0x0C, 
-0xE2, 0x78, 0x37, 0xF2, 0x78, 0x0D, 0xE2, 0x78, 0x38, 0xF2, 0x78, 0x0E, 0xE2, 0x78, 0x39, 0xF2, 
-0x78, 0x0F, 0xE2, 0x78, 0x3A, 0xF2, 0xE4, 0x78, 0x15, 0xF2, 0xEF, 0x24, 0xF8, 0x60, 0x76, 0x24, 
-0xFC, 0x60, 0x6D, 0x24, 0x08, 0x60, 0x02, 0x81, 0x02, 0x78, 0x11, 0xE2, 0xB4, 0x01, 0x05, 0x12, 
-0x29, 0xC5, 0x81, 0x07, 0x78, 0x11, 0xE2, 0xB4, 0x02, 0x05, 0x12, 0x11, 0xBD, 0x81, 0x07, 0x78, 
-0x11, 0xE2, 0xB4, 0x03, 0x05, 0x12, 0x69, 0x86, 0x81, 0x07, 0x78, 0x11, 0xE2, 0xB4, 0x10, 0x17, 
-0x78, 0x14, 0xE2, 0xFE, 0x18, 0xE2, 0xFD, 0xED, 0xFF, 0x78, 0x16, 0xEE, 0xF2, 0xFE, 0x08, 0xEF, 
-0xF2, 0xFF, 0x12, 0x32, 0xAA, 0x81, 0x07, 0x78, 0x11, 0xE2, 0xB4, 0x11, 0x17, 0x78, 0x14, 0xE2, 
-0xFE, 0x18, 0xE2, 0xFD, 0xED, 0xFF, 0x78, 0x16, 0xEE, 0xF2, 0xFE, 0x08, 0xEF, 0xF2, 0xFF, 0x12, 
-0x32, 0x06, 0x81, 0x07, 0x78, 0x11, 0xE2, 0xF4, 0x60, 0x02, 0x81, 0x07, 0x18, 0xF2, 0x81, 0x07, 
-0x78, 0x15, 0x74, 0x01, 0xF2, 0x78, 0x11, 0xE2, 0x64, 0x07, 0x60, 0x02, 0x61, 0xEB, 0x78, 0x34, 
-0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x08, 0x12, 0x20, 0xBB, 0xC0, 0x04, 0xA9, 0x05, 0xAA, 
-0x06, 0xAB, 0x07, 0x78, 0x33, 0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0xD0, 0x00, 0x12, 0x44, 0xC2, 
-0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x78, 0x35, 0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 
-0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 
-0x78, 0x18, 0x12, 0x44, 0xF4, 0x78, 0x15, 0xE2, 0x70, 0x02, 0x61, 0xD5, 0x18, 0xE2, 0xFF, 0x18, 
-0xE2, 0xFD, 0x91, 0x23, 0x78, 0x1C, 0x12, 0x44, 0xF4, 0x78, 0x38, 0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 
-0xFE, 0x78, 0x08, 0x12, 0x20, 0xBB, 0xC0, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x78, 0x37, 
-0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 
-0x06, 0xC0, 0x07, 0x78, 0x39, 0xE2, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x10, 0x12, 0x20, 0xBB, 
-0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0x78, 0x20, 0x12, 0x44, 0xF4, 
-0x78, 0x20, 0x12, 0x44, 0xDB, 0x12, 0x20, 0x9B, 0x78, 0x1C, 0x12, 0x44, 0xE7, 0x12, 0x44, 0xB5, 
-0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x78, 0x18, 0x12, 0x44, 0xDB, 0x78, 0x20, 0x12, 
-0x44, 0xE7, 0x12, 0x44, 0xB5, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 
-0x78, 0x18, 0x12, 0x44, 0xF4, 0x78, 0x18, 0x12, 0x44, 0xDB, 0x90, 0x82, 0xDD, 0x12, 0x20, 0xCE, 
-0x78, 0x13, 0xE2, 0xFD, 0x08, 0xE2, 0xFF, 0x91, 0x32, 0x80, 0x1C, 0x78, 0x13, 0xE2, 0xFF, 0x08, 
-0xE2, 0xFD, 0x78, 0x11, 0xE2, 0xFB, 0x78, 0x15, 0xE2, 0x90, 0x82, 0xA2, 0xF0, 0x12, 0x67, 0xE7, 
-0x80, 0x05, 0x78, 0x10, 0x74, 0x02, 0xF2, 0x78, 0x10, 0xE2, 0xFF, 0xC3, 0x94, 0x02, 0x50, 0x10, 
-0xEF, 0x60, 0x0A, 0x78, 0x02, 0xE2, 0xFF, 0x18, 0xE2, 0x2F, 0xF2, 0x21, 0xD1, 0x7F, 0x01, 0x22, 
-0x7F, 0x00, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x62, 0xE5, 0xD0, 0xD0, 0x92, 
-0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0x82, 0xDD, 
-0x12, 0x44, 0xCF, 0x90, 0x82, 0xD3, 0x12, 0x20, 0xCE, 0xD0, 0x05, 0xD0, 0x07, 0x91, 0xEC, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0x22, 0x90, 0x81, 0x7A, 0xE0, 0x64, 0x02, 0x7F, 0x01, 0x60, 0x02, 0x7F, 
-0x00, 0x22, 0x90, 0x01, 0xC4, 0x74, 0x62, 0xF0, 0x74, 0x5C, 0xA3, 0xF0, 0x90, 0x00, 0x90, 0xE0, 
-0x20, 0xE0, 0xF9, 0x74, 0x62, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x5C, 0xA3, 0xF0, 0x22, 0x7D, 
-0x02, 0x90, 0x01, 0xC4, 0x74, 0x7F, 0xF0, 0x74, 0x5C, 0xA3, 0xF0, 0x90, 0x82, 0x2C, 0xE0, 0xFF, 
-0xED, 0xC3, 0x9F, 0x50, 0x18, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x0B, 0x90, 
-0x01, 0xB8, 0x74, 0x08, 0xF0, 0xA3, 0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xDE, 0x7F, 0x01, 0x22, 
-0x90, 0x02, 0x87, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x80, 0x25, 0x90, 0x02, 
-0x96, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 0x17, 0x90, 0x02, 0x86, 0xE0, 
-0x20, 0xE1, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 
-0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x82, 0xD1, 0xEF, 
-0xF0, 0xAB, 0x05, 0x90, 0x82, 0xD7, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x03, 0xE4, 
-0xFC, 0xFD, 0xFE, 0x78, 0x14, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 
-0x90, 0x82, 0xD3, 0x12, 0x44, 0xCF, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x12, 0x44, 0xC2, 0xEC, 
-0x54, 0x0F, 0xFC, 0x90, 0x82, 0xD7, 0x12, 0x20, 0xCE, 0x90, 0x82, 0xD1, 0xE0, 0x75, 0xF0, 0x08, 
-0xA4, 0x24, 0x60, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC0, 
-0x06, 0xC0, 0x07, 0x90, 0x82, 0xD7, 0x12, 0x44, 0xCF, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0xD0, 
-0x07, 0xD0, 0x06, 0x02, 0x2E, 0xA2, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x01, 0x01, 
-0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 
-0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0xEC, 0x54, 0x7F, 
-0xFC, 0x90, 0x82, 0xEA, 0x12, 0x20, 0xCE, 0x90, 0x82, 0xEA, 0x12, 0x44, 0xCF, 0x90, 0x85, 0xBB, 
-0x12, 0x20, 0xCE, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 
-0xCC, 0xC0, 0x00, 0xC0, 0x7F, 0x8C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x12, 0x20, 
-0xDA, 0x00, 0xC0, 0x00, 0x14, 0x7F, 0x70, 0x7E, 0x0E, 0x12, 0x2E, 0xA2, 0x90, 0x82, 0xDD, 0x12, 
-0x20, 0xDA, 0x00, 0x03, 0x3E, 0x60, 0xE4, 0xFD, 0xFF, 0x91, 0x32, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
-0x8B, 0x52, 0x8A, 0x53, 0x89, 0x54, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFF, 0xF5, 0x56, 0x12, 
-0x1F, 0xA4, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x0A, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0xF5, 0x57, 
-0x80, 0x02, 0x8F, 0x57, 0x85, 0x56, 0x55, 0xE5, 0x55, 0xD3, 0x95, 0x57, 0x50, 0x33, 0xAB, 0x52, 
-0xAA, 0x53, 0xA9, 0x54, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 0x74, 0x36, 0x25, 0x55, 0xF5, 0x82, 
-0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 0x36, 0x25, 0x55, 0xF5, 0x82, 0xE4, 0x34, 0x81, 
-0xF5, 0x83, 0xE0, 0xAF, 0x55, 0x70, 0x04, 0xF1, 0x8D, 0x80, 0x02, 0xF1, 0x8C, 0x05, 0x55, 0x80, 
-0xC6, 0x12, 0x77, 0xA3, 0xE5, 0x56, 0x70, 0x18, 0x90, 0x81, 0x36, 0xE0, 0x70, 0x12, 0xB1, 0x56, 
-0x12, 0x4F, 0xD1, 0x90, 0x81, 0x7C, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 
-0x22, 0x90, 0x82, 0xA5, 0x12, 0x45, 0x15, 0x90, 0x82, 0xA4, 0xEF, 0xF0, 0x12, 0x45, 0x1E, 0x5E, 
-0x8A, 0x00, 0x5E, 0x93, 0x01, 0x5E, 0x9B, 0x02, 0x5E, 0xA3, 0x12, 0x5E, 0xAB, 0x14, 0x5E, 0xB3, 
-0x20, 0x5E, 0xBC, 0x21, 0x5E, 0xC5, 0x23, 0x5E, 0xCD, 0x24, 0x5E, 0xD6, 0x25, 0x5E, 0xDE, 0x26, 
-0x5E, 0xE7, 0x27, 0x5E, 0xF0, 0xC0, 0x00, 0x00, 0x5E, 0xF9, 0x90, 0x82, 0xA5, 0x12, 0x45, 0x0C, 
-0x02, 0x6E, 0x92, 0x90, 0x82, 0xA5, 0x12, 0x45, 0x0C, 0xA1, 0xD0, 0x90, 0x82, 0xA5, 0x12, 0x45, 
-0x0C, 0x80, 0x7A, 0x90, 0x82, 0xA5, 0x12, 0x45, 0x0C, 0x80, 0x5E, 0x90, 0x82, 0xA5, 0x12, 0x45, 
-0x0C, 0xE1, 0xA7, 0x90, 0x82, 0xA5, 0x12, 0x45, 0x0C, 0x02, 0x6E, 0xEA, 0x90, 0x82, 0xA5, 0x12, 
-0x45, 0x0C, 0x02, 0x6F, 0xEB, 0x90, 0x82, 0xA5, 0x12, 0x45, 0x0C, 0xE1, 0x8E, 0x90, 0x82, 0xA5, 
-0x12, 0x45, 0x0C, 0x02, 0x53, 0x14, 0x90, 0x82, 0xA5, 0x12, 0x45, 0x0C, 0xE1, 0x96, 0x90, 0x82, 
-0xA5, 0x12, 0x45, 0x0C, 0x02, 0x70, 0x31, 0x90, 0x82, 0xA5, 0x12, 0x45, 0x0C, 0x02, 0x70, 0xB4, 
-0x90, 0x82, 0xA5, 0x12, 0x45, 0x0C, 0x02, 0x70, 0xE8, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 
-0x90, 0x82, 0xA4, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 0x35, 
-0xF0, 0xBF, 0x01, 0x08, 0x12, 0x6D, 0xE6, 0xE4, 0x90, 0x81, 0x35, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 
-0x01, 0xC3, 0xC0, 0xD0, 0x8B, 0x52, 0x8A, 0x53, 0x89, 0x54, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 
-0x76, 0xF0, 0xBF, 0x01, 0x0C, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x64, 0x01, 0x60, 0x22, 0x80, 
-0x1E, 0xAB, 0x52, 0xAA, 0x53, 0xA9, 0x54, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x64, 0x01, 0x60, 
-0x10, 0x90, 0x81, 0x77, 0xE0, 0x20, 0xE0, 0x07, 0xE4, 0xFF, 0x12, 0x78, 0x77, 0x80, 0x02, 0xF1, 
-0x66, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x76, 
-0xE0, 0xB4, 0x01, 0x04, 0x7F, 0x04, 0x80, 0x0C, 0x12, 0x47, 0xD4, 0xBF, 0x01, 0x04, 0x7F, 0x01, 
-0x80, 0x02, 0x7F, 0x02, 0x12, 0x78, 0x77, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x22, 0x22, 0x12, 0x1F, 
-0xA4, 0x90, 0x81, 0x8A, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x82, 0x25, 0xF0, 0x22, 0xB1, 0x56, 
-0x90, 0x81, 0x7A, 0x74, 0x03, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 0x90, 0x82, 0x2F, 
-0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0xB1, 0x56, 0xE4, 0xFD, 0xFF, 0x12, 0x48, 0xC2, 0x90, 0x81, 
-0x7A, 0x74, 0x01, 0xF0, 0x22, 0xF1, 0xB6, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0xE4, 0x90, 
-0x81, 0x7A, 0xF0, 0x22, 0x12, 0x79, 0xBF, 0x80, 0xEE, 0xF1, 0xDD, 0x80, 0xEA, 0xE4, 0xFD, 0xFF, 
-0x12, 0x48, 0xC2, 0x90, 0x81, 0x7A, 0x74, 0x01, 0xF0, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 
-0x12, 0x43, 0x4E, 0x90, 0x82, 0xA3, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x80, 0x3C, 0xE0, 0xFF, 0x60, 
-0xE9, 0xC2, 0xAF, 0x30, 0xE1, 0x05, 0x54, 0xFD, 0xF0, 0x11, 0xDB, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 
-0x80, 0x3C, 0xE0, 0xFF, 0x30, 0xE2, 0x05, 0x54, 0xFB, 0xF0, 0x11, 0x20, 0xD2, 0xAF, 0x80, 0xDA, 
-0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 0x90, 0x81, 0x32, 0xE0, 0xFE, 0x90, 0x81, 
-0x31, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 
-0x32, 0x90, 0x01, 0xAF, 0xE0, 0x70, 0x13, 0xED, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x9B, 0xF9, 0x74, 
-0x80, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x11, 0x78, 0x7F, 0x01, 0xEF, 0x60, 0x16, 0x90, 0x81, 0x31, 
-0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 
-0x81, 0x31, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
-0x82, 0xA4, 0x12, 0x45, 0x15, 0x90, 0x82, 0xFA, 0xE0, 0xFF, 0x04, 0xF0, 0x90, 0x00, 0x01, 0xEF, 
-0x12, 0x1F, 0xFC, 0x7F, 0xAF, 0x7E, 0x01, 0x31, 0x3F, 0xEF, 0x60, 0x3A, 0x90, 0x82, 0xA4, 0x12, 
+0x12, 0x6F, 0x03, 0xE5, 0x41, 0x30, 0xE4, 0x02, 0xF1, 0x57, 0xE5, 0x41, 0x30, 0xE6, 0x03, 0x12, 
+0x6F, 0x9C, 0xE5, 0x43, 0x30, 0xE0, 0x03, 0x12, 0x6F, 0xA9, 0xE5, 0x43, 0x30, 0xE1, 0x03, 0x12, 
+0x70, 0x53, 0xE5, 0x43, 0x30, 0xE2, 0x03, 0x12, 0x70, 0xB7, 0xE5, 0x43, 0x30, 0xE3, 0x02, 0xF1, 
+0x6A, 0xE5, 0x43, 0x30, 0xE4, 0x03, 0x12, 0x5B, 0x4E, 0xE5, 0x43, 0x30, 0xE5, 0x03, 0x12, 0x54, 
+0x65, 0xE5, 0x43, 0x30, 0xE6, 0x03, 0x12, 0x58, 0x7E, 0xE5, 0x44, 0x30, 0xE1, 0x03, 0x12, 0x5B, 
+0x6B, 0x74, 0xB9, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x46, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 
+0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 
+0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x12, 0x60, 0x7D, 0x7F, 0x02, 0x8F, 0x0D, 0x7F, 0x02, 
+0x71, 0x27, 0x90, 0x80, 0x3C, 0xE0, 0x45, 0x0D, 0xF0, 0x22, 0xF1, 0xF3, 0x70, 0x0B, 0x90, 0x81, 
+0x49, 0xE0, 0x60, 0x05, 0x12, 0x72, 0xAE, 0xF1, 0x7D, 0x22, 0xE0, 0x44, 0x02, 0xF0, 0xE4, 0xF5, 
+0x1D, 0x90, 0x81, 0x87, 0xE0, 0xF5, 0x1E, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8E, 0x19, 0x8F, 0x1A, 0xE5, 0x1E, 0xF1, 0xE3, 0x85, 0x19, 0x83, 
+0x85, 0x1A, 0x82, 0xF0, 0xE5, 0x1D, 0xF1, 0xE3, 0xFF, 0xE5, 0x1E, 0x13, 0x13, 0x13, 0x54, 0x1F, 
+0x4F, 0xA3, 0xF0, 0xEB, 0xF1, 0xE3, 0xFF, 0xE5, 0x1D, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0xF1, 
+0xEA, 0xF0, 0xBD, 0x01, 0x0D, 0x85, 0x1A, 0x82, 0x8E, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 0x03, 0xF0, 
+0x80, 0x06, 0xF1, 0xEA, 0xA3, 0x74, 0x01, 0xF0, 0xF1, 0xEA, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x54, 0x07, 0xC4, 0x33, 0x54, 0xE0, 0x22, 0x85, 0x1A, 0x82, 0x85, 0x19, 0x83, 
+0xA3, 0xA3, 0x22, 0xE4, 0xFF, 0x12, 0x52, 0xC9, 0xEF, 0x64, 0x01, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 
+0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 
+0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xFC, 0xF0, 0x74, 
+0x47, 0xA3, 0xF0, 0x12, 0x6F, 0x30, 0xE5, 0x49, 0x30, 0xE1, 0x02, 0x11, 0xA4, 0xE5, 0x49, 0x30, 
+0xE2, 0x03, 0x12, 0x58, 0x68, 0xE5, 0x4A, 0x30, 0xE0, 0x03, 0x12, 0x70, 0xE0, 0xE5, 0x4A, 0x30, 
+0xE4, 0x03, 0x12, 0x71, 0xDC, 0xE5, 0x4B, 0x30, 0xE1, 0x03, 0x12, 0x72, 0x3A, 0xE5, 0x4B, 0x30, 
+0xE0, 0x03, 0x12, 0x71, 0xF2, 0xE5, 0x4B, 0x30, 0xE3, 0x03, 0x12, 0x72, 0xDD, 0xE5, 0x4C, 0x30, 
+0xE1, 0x05, 0x7F, 0x04, 0x12, 0x47, 0x5C, 0xE5, 0x4C, 0x30, 0xE4, 0x02, 0x11, 0xCD, 0xE5, 0x4C, 
+0x30, 0xE5, 0x03, 0x12, 0x5B, 0xCD, 0xE5, 0x4C, 0x30, 0xE6, 0x03, 0x12, 0x72, 0xDE, 0x74, 0xFC, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 
+0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 
+0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x03, 0x12, 0x57, 0x84, 0x90, 0x81, 0x8D, 
+0xE0, 0x30, 0xE0, 0x18, 0x54, 0xFB, 0xF0, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x06, 0x7D, 0x04, 0x7F, 
+0x01, 0xA1, 0xFD, 0x7D, 0x31, 0x7F, 0xFF, 0xB1, 0xA9, 0x12, 0x5D, 0x9F, 0x22, 0x12, 0x75, 0x64, 
+0x7D, 0x02, 0x7F, 0x02, 0x31, 0x0A, 0x90, 0x81, 0x8F, 0xE0, 0x30, 0xE0, 0x22, 0x12, 0x70, 0xAE, 
+0x90, 0x81, 0x92, 0xE0, 0x60, 0x04, 0x14, 0xF0, 0xA1, 0xE4, 0x90, 0x81, 0x90, 0xE0, 0x14, 0x90, 
+0x81, 0x92, 0xF0, 0x90, 0x05, 0x73, 0x74, 0x01, 0xF0, 0xE4, 0xFF, 0x31, 0x16, 0x31, 0x00, 0x22, 
+0x7D, 0x02, 0x7F, 0x02, 0x31, 0x0A, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x3D, 0x2F, 0xF8, 0xE6, 0x4D, 
+0xFE, 0xF6, 0x74, 0x30, 0x80, 0x5B, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 
+0x54, 0x01, 0xFE, 0x12, 0x76, 0x57, 0xF0, 0xEF, 0x64, 0x01, 0x70, 0x20, 0x90, 0x01, 0x53, 0xF0, 
+0x90, 0x81, 0x91, 0xE0, 0x60, 0x0B, 0x7D, 0x10, 0x7F, 0x03, 0x31, 0x67, 0x12, 0x70, 0xAE, 0x80, 
+0x13, 0x31, 0x59, 0x12, 0x73, 0x3C, 0x31, 0x7C, 0xB1, 0xE4, 0x80, 0x08, 0x31, 0x59, 0x31, 0x67, 
+0x31, 0x00, 0xF1, 0x35, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x01, 0x53, 0x74, 0x03, 0xF0, 0x7D, 
+0x10, 0xFF, 0x22, 0x7D, 0x03, 0x7F, 0x02, 0x74, 0x45, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 
+0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x7D, 0x02, 0x7F, 0x02, 
+0x31, 0x86, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x3D, 0x12, 0x73, 0x43, 0xFE, 0xF6, 0x74, 0x30, 0x80, 
+0xE0, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x76, 0x50, 0x90, 0x05, 0x27, 0xE0, 0xF5, 
+0x55, 0x12, 0x76, 0x27, 0x90, 0x81, 0x40, 0x12, 0x75, 0xF9, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 
+0x12, 0x76, 0x66, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 0x12, 0x76, 0x07, 0x54, 0x10, 0xFD, 
+0xEF, 0x54, 0xEF, 0x12, 0x76, 0x66, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 0x12, 0x76, 0x07, 
+0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 0x4D, 0x90, 0x81, 0x40, 0xF0, 0xEE, 0xC3, 0x13, 0x20, 0xE0, 
+0x02, 0x41, 0x74, 0xE0, 0x30, 0xE0, 0x78, 0x31, 0x63, 0x75, 0x55, 0x21, 0x90, 0x81, 0x40, 0xE0, 
+0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0xF1, 0xDF, 0x43, 0x55, 0x08, 0x80, 0x0C, 0xE4, 0x90, 
+0x81, 0x41, 0xF0, 0xA3, 0xF0, 0x7D, 0x40, 0xFF, 0x31, 0x86, 0x90, 0x81, 0x40, 0x12, 0x70, 0xA6, 
+0x30, 0xE0, 0x03, 0x43, 0x55, 0x12, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x14, 
+0x90, 0x81, 0x40, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x80, 0x12, 0x5F, 
+0xD4, 0x20, 0xE0, 0x03, 0x43, 0x55, 0x40, 0x71, 0xB3, 0x90, 0x81, 0x43, 0xE0, 0x70, 0x05, 0x7F, 
+0x01, 0x12, 0x5C, 0x80, 0x12, 0x5B, 0xC2, 0x30, 0xE0, 0x04, 0x7F, 0x04, 0x80, 0x0C, 0x12, 0x5B, 
+0x42, 0xEF, 0x60, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x02, 0x12, 0x5C, 0x80, 0x41, 0xEC, 0x75, 
+0x55, 0x01, 0x71, 0xB3, 0x90, 0x81, 0x43, 0xE0, 0x64, 0x04, 0x60, 0x02, 0x61, 0x1F, 0xFF, 0x12, 
+0x5C, 0x80, 0x61, 0x1F, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x79, 0x31, 0x63, 0x43, 0x55, 0x31, 
+0x90, 0x81, 0x40, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0xF1, 0xDF, 0x43, 0x55, 0x08, 
+0x80, 0x06, 0x7D, 0x40, 0xE4, 0xFF, 0x31, 0x86, 0x90, 0x81, 0x40, 0x12, 0x70, 0xA6, 0x30, 0xE0, 
+0x03, 0x43, 0x55, 0x02, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 0x55, 0x04, 0x71, 0xB3, 
+0x12, 0x5B, 0xC2, 0x30, 0xE0, 0x0B, 0x12, 0x5B, 0xBB, 0x60, 0x31, 0xE4, 0xFD, 0x7F, 0x02, 0x80, 
+0x1F, 0x12, 0x5E, 0x88, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x02, 0x19, 0x12, 0x74, 0xBF, 0x12, 0x5B, 
+0x42, 0xBF, 0x01, 0x09, 0x90, 0x81, 0x4B, 0xE0, 0xFF, 0x7D, 0x01, 0x80, 0x03, 0xE4, 0xFD, 0xFF, 
+0x71, 0xBE, 0x80, 0x08, 0x90, 0x81, 0x4C, 0xE0, 0x90, 0x81, 0x44, 0xF0, 0x90, 0x05, 0x40, 0x74, 
+0x22, 0xF0, 0x80, 0x2B, 0x75, 0x55, 0x01, 0x71, 0xB3, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x02, 0x06, 
+0x7D, 0x01, 0x7F, 0x04, 0x80, 0x0B, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x08, 0x06, 0x7D, 0x01, 0x7F, 
+0x0C, 0x71, 0xBE, 0x12, 0x6E, 0xF0, 0x90, 0x81, 0x4B, 0x12, 0x58, 0x61, 0x12, 0x52, 0x0E, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x90, 0x82, 0x0E, 0x12, 0x45, 0x15, 0x90, 0x82, 0x0D, 0xEF, 0xF0, 0x12, 
+0x45, 0x1E, 0x4B, 0x5D, 0x00, 0x4B, 0x62, 0x01, 0x4B, 0x67, 0x02, 0x4B, 0x6C, 0x12, 0x4B, 0x71, 
+0x14, 0x4B, 0x76, 0x20, 0x4B, 0x7B, 0x21, 0x4B, 0x80, 0x23, 0x4B, 0x85, 0x24, 0x4B, 0x89, 0x25, 
+0x4B, 0x8E, 0x26, 0x4B, 0x93, 0x27, 0x4B, 0x98, 0xC0, 0x00, 0x00, 0x4B, 0x9D, 0x71, 0xAD, 0x02, 
+0x54, 0xAE, 0x71, 0xAD, 0x02, 0x52, 0xEC, 0x71, 0xAD, 0x02, 0x53, 0x4E, 0x71, 0xAD, 0x02, 0x65, 
+0x15, 0x71, 0xAD, 0x02, 0x6D, 0x22, 0x71, 0xAD, 0x02, 0x53, 0x8D, 0x71, 0xAD, 0x02, 0x54, 0xF2, 
+0x71, 0xAD, 0x02, 0x6D, 0x31, 0x71, 0xAD, 0x21, 0x91, 0x71, 0xAD, 0x02, 0x6D, 0x39, 0x71, 0xAD, 
+0x02, 0x56, 0x4C, 0x71, 0xAD, 0x02, 0x55, 0x31, 0x71, 0xAD, 0x02, 0x6D, 0x41, 0x90, 0x01, 0xC0, 
+0xE0, 0x44, 0x01, 0xF0, 0x90, 0x82, 0x0D, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0x90, 0x82, 0x0E, 
+0x02, 0x45, 0x0C, 0x90, 0x05, 0x27, 0xE5, 0x55, 0xF0, 0x22, 0x7D, 0x01, 0x7F, 0x04, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x6F, 0xED, 0xF0, 0x90, 0x81, 0x45, 0xE0, 0xFE, 0xC4, 
+0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0xA1, 0x07, 0xEE, 0x12, 0x73, 0x0D, 0x30, 0xE0, 0x02, 
+0xA1, 0x07, 0x90, 0x81, 0x4C, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0xA1, 0x07, 0xEF, 0x70, 0x02, 0x81, 
+0x7A, 0x24, 0xFE, 0x70, 0x02, 0x81, 0xB3, 0x24, 0xFE, 0x60, 0x47, 0x24, 0xFC, 0x70, 0x02, 0x81, 
+0xEE, 0x24, 0xFC, 0x60, 0x02, 0xA1, 0x00, 0xEE, 0xB4, 0x0E, 0x02, 0xB1, 0x57, 0x90, 0x81, 0x4C, 
+0xE0, 0x70, 0x04, 0x7F, 0x01, 0xD1, 0x65, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x06, 0x02, 0xB1, 0x7B, 
+0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x04, 0x0D, 0x90, 0x82, 0x6F, 0xE0, 0xFF, 0x60, 0x04, 0xD1, 0xA4, 
+0x80, 0x02, 0xF1, 0xA2, 0x90, 0x81, 0x4C, 0xE0, 0x64, 0x08, 0x60, 0x02, 0xA1, 0x00, 0xF1, 0x35, 
+0xA1, 0x00, 0x90, 0x81, 0x4C, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0xD1, 0x65, 0x90, 0x81, 0x4C, 0xE0, 
+0xB4, 0x06, 0x02, 0xB1, 0x7B, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0E, 0x07, 0xB1, 0x0C, 0xBF, 0x01, 
+0x02, 0xB1, 0x57, 0x90, 0x81, 0x4C, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0xA1, 0x00, 0xB1, 0x0C, 0xEF, 
+0x64, 0x01, 0x60, 0x02, 0xA1, 0x00, 0xB1, 0xB4, 0xA1, 0x00, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0E, 
+0x07, 0xB1, 0x0C, 0xBF, 0x01, 0x02, 0xB1, 0x57, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x06, 0x02, 0xB1, 
+0x7B, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0C, 0x07, 0xB1, 0x0C, 0xBF, 0x01, 0x02, 0xB1, 0xB4, 0x90, 
+0x81, 0x4C, 0xE0, 0x64, 0x04, 0x70, 0x59, 0x12, 0x6E, 0x1C, 0xEF, 0x64, 0x01, 0x70, 0x51, 0xD1, 
+0x7D, 0x80, 0x4D, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0E, 0x07, 0xB1, 0x0C, 0xBF, 0x01, 0x02, 0xB1, 
+0x57, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x06, 0x02, 0xB1, 0x7B, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x0C, 
+0x07, 0xB1, 0x0C, 0xBF, 0x01, 0x02, 0xB1, 0xB4, 0x90, 0x81, 0x4C, 0xE0, 0x70, 0x04, 0x7F, 0x01, 
+0xD1, 0x65, 0x90, 0x81, 0x4C, 0xE0, 0xB4, 0x04, 0x17, 0x12, 0x74, 0xA7, 0x80, 0x12, 0x90, 0x81, 
+0x4C, 0xE0, 0xB4, 0x0C, 0x0B, 0x90, 0x81, 0x46, 0x12, 0x72, 0xA7, 0x30, 0xE0, 0x02, 0xB1, 0xE4, 
+0x90, 0x81, 0x4C, 0x12, 0x76, 0x0E, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x6E, 0xD7, 0xEF, 
+0x64, 0x01, 0x60, 0x05, 0x12, 0x6E, 0x8D, 0x80, 0x35, 0x12, 0x73, 0xAC, 0x30, 0xE0, 0x08, 0x90, 
+0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x27, 0x90, 0x81, 0x4B, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x05, 
+0x12, 0x6E, 0x15, 0x80, 0x19, 0x90, 0x81, 0x8D, 0xE0, 0x30, 0xE0, 0x0F, 0x13, 0x13, 0x54, 0x3F, 
+0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x11, 0xF0, 0x80, 0x03, 0x02, 0x6E, 0xCF, 0x90, 0x01, 
+0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x81, 0x46, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x04, 
+0xB1, 0xF9, 0x80, 0x12, 0x12, 0x76, 0x2F, 0xF1, 0xD8, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x80, 0xF0, 
+0x90, 0x81, 0x44, 0x74, 0x04, 0xF0, 0xE4, 0xFD, 0xFF, 0x80, 0x2E, 0x90, 0x81, 0x46, 0xE0, 0x90, 
+0x06, 0x04, 0x20, 0xE0, 0x07, 0xE0, 0x44, 0x40, 0xF1, 0xD8, 0x80, 0x0F, 0xB1, 0xF5, 0x90, 0x05, 
+0x27, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x81, 0x44, 0x74, 0x0C, 0xF0, 0xE4, 0xFD, 0xFF, 0x80, 0x09, 
+0xE4, 0xFD, 0x7F, 0x0C, 0x71, 0xBE, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 0x90, 0x80, 
+0x40, 0xED, 0xF0, 0x22, 0x12, 0x47, 0xF3, 0x70, 0x2A, 0x90, 0x81, 0x46, 0xE0, 0x54, 0xFD, 0xF0, 
+0x7D, 0x2C, 0x7F, 0x6F, 0xB1, 0xA9, 0x7D, 0x08, 0x7F, 0x01, 0xD1, 0xDF, 0xBF, 0x01, 0x0F, 0x90, 
+0x81, 0x45, 0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x0E, 0xD1, 0x9C, 0x74, 0x0E, 0xF0, 0x22, 0x12, 0x73, 
+0x15, 0x04, 0xF0, 0x22, 0x7D, 0x2F, 0x7F, 0xFF, 0xB1, 0xA9, 0x12, 0x5D, 0x9F, 0x7D, 0x08, 0xD1, 
+0x9C, 0x74, 0x08, 0xF0, 0x22, 0xE0, 0x54, 0x7F, 0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 0x14, 0x60, 0x15, 0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 
+0x1A, 0xED, 0x54, 0x01, 0xFE, 0x90, 0x81, 0x45, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0x80, 0x0C, 0x90, 
+0x81, 0x4C, 0xED, 0xF0, 0x80, 0x05, 0x90, 0x81, 0x4B, 0xED, 0xF0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 
+0xE4, 0x2E, 0xEC, 0x14, 0x60, 0x07, 0x14, 0x60, 0x1D, 0x24, 0x02, 0x70, 0x23, 0x90, 0x81, 0x45, 
+0xE0, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0xFF, 0x90, 0x81, 0x4C, 0xE0, 0x54, 0x7F, 
+0x4F, 0xFD, 0x7F, 0x88, 0x80, 0x07, 0x90, 0x81, 0x4B, 0xE0, 0xFD, 0x7F, 0x89, 0x12, 0x32, 0x1E, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x82, 0x6E, 0xEF, 0xF0, 0x12, 0x55, 0xE5, 0x90, 0x82, 0x6E, 
+0xE0, 0x60, 0x02, 0xF1, 0x43, 0x7D, 0x04, 0xD1, 0x9C, 0x74, 0x04, 0xF0, 0x22, 0x7D, 0x2D, 0x12, 
+0x5E, 0x07, 0x90, 0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x31, 0x0A, 0x12, 0x5D, 0x9F, 
+0xE4, 0xFD, 0x7F, 0x01, 0xB1, 0xFD, 0xE4, 0x90, 0x81, 0x44, 0xF0, 0x22, 0x7F, 0x01, 0xB1, 0xFD, 
+0x90, 0x81, 0x44, 0x22, 0xEF, 0x60, 0x33, 0x12, 0x47, 0xF3, 0x70, 0x2E, 0x90, 0x81, 0x46, 0xE0, 
+0x54, 0xFE, 0xF0, 0x7D, 0x2B, 0x7F, 0x0F, 0xB1, 0xA9, 0x90, 0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 
+0xD1, 0xDB, 0xBF, 0x01, 0x0F, 0x90, 0x81, 0x45, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x06, 0xD1, 0x9C, 
+0x74, 0x06, 0xF0, 0x22, 0x12, 0x73, 0x15, 0x74, 0x08, 0xF0, 0x22, 0x7D, 0x08, 0xE4, 0xFF, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x4A, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x80, 
+0x3E, 0xE0, 0x04, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x27, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x82, 
+0x4E, 0xF0, 0x7D, 0x26, 0x12, 0x5E, 0x07, 0xEF, 0x64, 0x01, 0x70, 0x03, 0x12, 0x5A, 0x71, 0x90, 
+0x82, 0x4E, 0xE0, 0xFF, 0x7D, 0x27, 0xB1, 0xA9, 0x90, 0x82, 0x4A, 0xE0, 0xFF, 0xF1, 0x48, 0x80, 
+0x0A, 0x90, 0x82, 0x4A, 0xE0, 0xFF, 0xF1, 0x48, 0x12, 0x5A, 0x71, 0x12, 0x5B, 0x1A, 0x7F, 0x01, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF1, 0x40, 0xB1, 0xF9, 0x90, 0x81, 0x44, 0x74, 0x0C, 0xF0, 0x22, 
+0x12, 0x55, 0xE5, 0xE4, 0xFD, 0xFF, 0xA1, 0xA9, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x82, 0x71, 0xEF, 0xF0, 0x90, 0x80, 0x44, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 0x3D, 
+0x90, 0x81, 0x4C, 0xE0, 0x64, 0x0E, 0x70, 0x14, 0x90, 0x82, 0x71, 0xE0, 0x70, 0x2F, 0x90, 0x81, 
+0x45, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x04, 0xB1, 0xF5, 0x80, 0x1F, 0x90, 0x81, 0x4C, 0xE0, 
+0x64, 0x06, 0x70, 0x19, 0x90, 0x82, 0x71, 0xE0, 0x60, 0x13, 0x90, 0x81, 0x45, 0xE0, 0x54, 0xBF, 
+0xF0, 0x12, 0x76, 0x2F, 0xF0, 0x90, 0x81, 0x4C, 0x74, 0x04, 0xF0, 0xF1, 0x43, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x12, 0x74, 0x65, 0xF1, 0x43, 0x7D, 0x0C, 0x7F, 0x01, 0xA1, 0xFD, 0x12, 0x73, 0x77, 
+0x90, 0x81, 0x4C, 0xE0, 0x64, 0x0C, 0x60, 0x04, 0xB1, 0xA0, 0xD1, 0xDB, 0x22, 0x90, 0x81, 0x49, 
+0xE0, 0x64, 0x01, 0x70, 0x12, 0x12, 0x54, 0x5E, 0x60, 0x05, 0xB1, 0xA0, 0x02, 0x73, 0x77, 0x90, 
+0x81, 0x4C, 0xE0, 0x70, 0x02, 0x71, 0xBA, 0x22, 0xF0, 0x7D, 0x04, 0x7F, 0x01, 0xA1, 0xFD, 0x90, 
+0x01, 0x34, 0x74, 0x40, 0xF0, 0xFD, 0xE4, 0xFF, 0x21, 0x0A, 0x7D, 0x1F, 0x7F, 0x6F, 0xB1, 0xA9, 
+0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x81, 0x43, 0x74, 0x04, 0xF0, 0x22, 0x90, 0x01, 
+0xC8, 0xE4, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xA0, 0x7F, 0xFF, 0xFE, 
+0x12, 0x2B, 0x27, 0xBF, 0x01, 0x0A, 0x90, 0x81, 0xA0, 0xE0, 0x64, 0x03, 0x60, 0x04, 0x01, 0xAF, 
+0x01, 0xB7, 0xE4, 0x90, 0x81, 0xA5, 0xF0, 0x90, 0x81, 0xA5, 0xE0, 0xFF, 0xC3, 0x94, 0x02, 0x40, 
+0x02, 0x01, 0xF2, 0xC3, 0x74, 0xFE, 0x9F, 0xFF, 0xE4, 0x94, 0x00, 0xFE, 0x7B, 0x01, 0x7A, 0x81, 
+0x79, 0xA1, 0x12, 0x2B, 0x27, 0xEF, 0x64, 0x01, 0x70, 0x6D, 0x90, 0x81, 0xA1, 0xE0, 0xFF, 0x54, 
+0xC0, 0xFE, 0x60, 0x05, 0xEF, 0x54, 0x0C, 0x70, 0x16, 0x90, 0x81, 0xA1, 0xE0, 0xFF, 0x54, 0x30, 
+0x60, 0x5D, 0xEF, 0x54, 0x03, 0x60, 0x58, 0x90, 0x81, 0xA2, 0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 
+0x90, 0x81, 0xA2, 0xF0, 0x90, 0x81, 0xA2, 0xE0, 0x90, 0x81, 0xA1, 0x70, 0x16, 0xE0, 0xFF, 0xEE, 
+0x13, 0x13, 0x54, 0x3F, 0x90, 0x81, 0xA3, 0xF0, 0xEF, 0x54, 0x0C, 0x13, 0x13, 0x54, 0x3F, 0xA3, 
+0xF0, 0x80, 0x0D, 0xE0, 0xFE, 0x54, 0x30, 0x90, 0x81, 0xA3, 0xF0, 0xEE, 0x54, 0x03, 0xA3, 0xF0, 
+0x90, 0x81, 0xA4, 0xE0, 0xB4, 0x01, 0x08, 0x90, 0x81, 0xA3, 0xE0, 0x64, 0x30, 0x60, 0x43, 0x90, 
+0x81, 0xA7, 0x74, 0x02, 0xF0, 0x80, 0x10, 0x90, 0x81, 0xA7, 0x74, 0x01, 0xF0, 0x80, 0x08, 0x90, 
+0x81, 0xA5, 0xE0, 0x04, 0xF0, 0x01, 0x27, 0x90, 0x01, 0xC4, 0x74, 0xFE, 0xF0, 0x74, 0x4F, 0xA3, 
+0xF0, 0x90, 0x81, 0xA7, 0xE0, 0x90, 0x01, 0xC8, 0xF0, 0x90, 0x81, 0xA1, 0xE0, 0x90, 0x01, 0xC9, 
+0xF0, 0x90, 0x81, 0xA2, 0xE0, 0x90, 0x01, 0xCA, 0xF0, 0xE4, 0xFD, 0x7F, 0x1F, 0x12, 0x32, 0x1E, 
+0x80, 0xD5, 0x22, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x90, 
+0xFD, 0x00, 0xE0, 0x54, 0xBF, 0xF0, 0x12, 0x4F, 0xFE, 0x12, 0x6D, 0xA0, 0x12, 0x32, 0x77, 0x12, 
+0x6D, 0xAD, 0x31, 0x4A, 0x7F, 0x01, 0x12, 0x42, 0x15, 0x90, 0x81, 0x93, 0x74, 0x02, 0xF0, 0xFF, 
+0x12, 0x42, 0x15, 0x90, 0x81, 0x93, 0xE0, 0x04, 0xF0, 0x51, 0x2C, 0x31, 0x5B, 0x90, 0x00, 0x80, 
+0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x75, 0x20, 0xFF, 0x12, 0x58, 0x06, 0x12, 
+0x64, 0x2A, 0x12, 0x6E, 0xF9, 0xE4, 0xFF, 0x02, 0x42, 0x9E, 0xE4, 0x90, 0x80, 0x3C, 0x31, 0x53, 
+0xA3, 0xF0, 0x22, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x31, 0x6E, 0x12, 0x6D, 0x4F, 
+0x51, 0x0E, 0x12, 0x73, 0xB6, 0x12, 0x75, 0xC3, 0x12, 0x74, 0x6D, 0x02, 0x45, 0x44, 0xE4, 0xFD, 
+0xFF, 0x12, 0x76, 0x1B, 0xED, 0x70, 0x12, 0x31, 0xAD, 0xC0, 0x83, 0xC0, 0x82, 0x31, 0xA5, 0x80, 
+0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x0F, 0x31, 0xAD, 0xC0, 0x83, 0xC0, 0x82, 0x31, 
+0xA5, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x31, 0xB8, 0x90, 
+0x81, 0x3E, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x22, 0x74, 0x36, 0x2E, 
+0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7D, 
+0x08, 0xED, 0x14, 0xF9, 0x24, 0x36, 0x31, 0xB0, 0xE0, 0x60, 0x3A, 0x7C, 0x08, 0xEC, 0x14, 0x90, 
+0x82, 0x6B, 0xF0, 0x74, 0x36, 0x29, 0x31, 0xB0, 0xE0, 0xFB, 0x7A, 0x00, 0x90, 0x82, 0x6B, 0x12, 
+0x63, 0xD4, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 
+0x5B, 0x4E, 0x60, 0x0F, 0xE9, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x90, 0x82, 0x6B, 0xE0, 0x2F, 0x04, 
+0xFF, 0x80, 0x06, 0xDC, 0xC8, 0xDD, 0xBA, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7E, 0x00, 
+0x7F, 0x01, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x40, 0x12, 0x45, 0x44, 0x90, 0x81, 0x40, 
+0xE0, 0x54, 0xFD, 0xF0, 0xE4, 0x31, 0x54, 0xA3, 0x74, 0x0C, 0xF0, 0x22, 0xF1, 0xEC, 0x90, 0x80, 
+0x41, 0xEF, 0xF0, 0x51, 0x4C, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x90, 0x00, 0x12, 0xE0, 0x54, 
+0xC7, 0x44, 0x20, 0xFD, 0x7F, 0x12, 0x12, 0x32, 0x1E, 0x02, 0x2D, 0xA7, 0x51, 0x7C, 0x51, 0xA2, 
+0x12, 0x6D, 0x5F, 0x12, 0x6D, 0x7E, 0xE4, 0xF5, 0x35, 0xF5, 0x36, 0xF5, 0x37, 0x75, 0x38, 0x80, 
+0xAD, 0x35, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xAD, 0x36, 0x7F, 0x51, 0x12, 0x32, 0x1E, 0xAD, 0x37, 
+0x7F, 0x52, 0x12, 0x32, 0x1E, 0xAD, 0x38, 0x7F, 0x53, 0x02, 0x32, 0x1E, 0x90, 0x01, 0x30, 0xE4, 
+0x31, 0x53, 0x90, 0x01, 0x38, 0x31, 0x53, 0xFD, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 
+0x51, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x53, 0x02, 
+0x32, 0x1E, 0x90, 0x01, 0x34, 0x74, 0xFF, 0x31, 0x53, 0x90, 0x01, 0x3C, 0x31, 0x53, 0xFD, 0x7F, 
+0x54, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x56, 0x12, 
+0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x57, 0x02, 0x32, 0x1E, 0x12, 0x76, 0x1B, 0x31, 0xAD, 0xE0, 0xFD, 
+0x7C, 0x00, 0x12, 0x63, 0xD6, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 
+0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 0x7F, 0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0x12, 0x76, 0x50, 0x71, 
+0x48, 0xFF, 0xF5, 0x56, 0x12, 0x1F, 0xA4, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x06, 0x91, 0xA8, 0xF5, 
+0x57, 0x80, 0x02, 0x8F, 0x57, 0x85, 0x56, 0x55, 0xE5, 0x55, 0xD3, 0x95, 0x57, 0x50, 0x25, 0xAB, 
+0x52, 0xAA, 0x53, 0xA9, 0x54, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFD, 0xAF, 0x55, 0x31, 0x71, 0xAF, 
+0x55, 0x51, 0xC9, 0xEF, 0xAF, 0x55, 0x70, 0x05, 0x12, 0x6D, 0x5E, 0x80, 0x03, 0x12, 0x6D, 0x5D, 
+0x05, 0x55, 0x80, 0xD4, 0xE5, 0x56, 0x70, 0x0E, 0xFF, 0x51, 0xC9, 0xEF, 0x70, 0x08, 0xB1, 0xD8, 
+0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x22, 0xF0, 0x90, 0x00, 0x01, 0x02, 0x1F, 0xBD, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x76, 0x50, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 0x3F, 0xF0, 
+0xBF, 0x01, 0x08, 0x71, 0x48, 0x64, 0x01, 0x60, 0x1F, 0x80, 0x1A, 0xAB, 0x52, 0xAA, 0x53, 0xA9, 
+0x54, 0x71, 0x48, 0x64, 0x01, 0x60, 0x11, 0x90, 0x81, 0x40, 0xE0, 0x20, 0xE0, 0x07, 0xE4, 0xFF, 
+0x12, 0x5C, 0x80, 0x80, 0x03, 0x12, 0x5C, 0x5C, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x82, 0x11, 
+0x12, 0x45, 0x15, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x7F, 0x90, 0x81, 0x49, 0xF0, 0xEF, 0x12, 0x73, 
+0x0D, 0xA3, 0x71, 0x47, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0x81, 0x47, 0xE0, 0x54, 
+0xF0, 0x4E, 0xB1, 0x2A, 0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 0x81, 0x45, 0xE0, 0x54, 0xFD, 0x4E, 
+0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0x91, 0x5E, 0x4F, 0x91, 0xA7, 0x90, 0x81, 0x48, 
+0x91, 0x50, 0x30, 0xE0, 0x52, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x81, 0x5C, 
+0x50, 0x04, 0xEF, 0xF0, 0x80, 0x2A, 0x74, 0x03, 0xF0, 0x91, 0x4A, 0xE9, 0x24, 0x06, 0xF9, 0xE4, 
+0x3A, 0xFA, 0x12, 0x1F, 0xA4, 0xFF, 0x74, 0x03, 0x24, 0xFD, 0xFE, 0xEF, 0xC4, 0x54, 0x0F, 0xFD, 
+0xEF, 0x54, 0x0F, 0xFF, 0xED, 0x2E, 0x54, 0x0F, 0xFE, 0xC4, 0x54, 0xF0, 0x4F, 0x12, 0x1F, 0xEA, 
+0x91, 0x4A, 0x91, 0x51, 0xC4, 0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x81, 0x51, 0x50, 0x05, 
+0x74, 0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 0x91, 0x4A, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0xFD, 
+0x7F, 0x02, 0x12, 0x4D, 0xFD, 0x91, 0x4A, 0x91, 0x7F, 0x12, 0x73, 0x15, 0xF0, 0x90, 0x81, 0x49, 
+0x12, 0x76, 0x0E, 0x91, 0x5D, 0x90, 0x01, 0xBE, 0xF0, 0x22, 0x90, 0x82, 0x11, 0x02, 0x45, 0x0C, 
+0xF0, 0x90, 0x00, 0x06, 0x02, 0x1F, 0xBD, 0x90, 0x81, 0x4D, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x81, 
+0x47, 0xE0, 0x54, 0x0F, 0x22, 0xE4, 0xFF, 0x51, 0xC9, 0xBF, 0x01, 0x12, 0x90, 0x81, 0x49, 0xE0, 
+0x60, 0x0C, 0x91, 0x5E, 0x64, 0x02, 0x60, 0x03, 0x02, 0x59, 0x4D, 0x12, 0x4F, 0xAD, 0x22, 0x90, 
+0x82, 0x14, 0x12, 0x45, 0x15, 0x12, 0x73, 0x4B, 0x90, 0x81, 0x49, 0xE0, 0xFF, 0xB1, 0x5E, 0x90, 
+0x81, 0x49, 0xE0, 0x60, 0x11, 0x90, 0x82, 0x14, 0x12, 0x45, 0x0C, 0x71, 0x48, 0x54, 0x0F, 0xFF, 
+0x91, 0xA8, 0xFD, 0x12, 0x74, 0x7A, 0x22, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x1F, 0xBD, 0x90, 0x02, 
+0x09, 0xE0, 0xF5, 0x52, 0x12, 0x1F, 0xA4, 0x25, 0x52, 0x90, 0x80, 0x42, 0x71, 0x47, 0x25, 0x52, 
+0x90, 0x80, 0x43, 0x91, 0xA7, 0x25, 0x52, 0x90, 0x80, 0x44, 0xB1, 0x2A, 0x25, 0x52, 0x90, 0x80, 
+0x45, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0x25, 0x52, 0x90, 0x80, 0x46, 0xF0, 0x90, 0x00, 
+0x05, 0x12, 0x1F, 0xBD, 0x25, 0x52, 0x90, 0x80, 0x47, 0x91, 0x50, 0x25, 0x52, 0x90, 0x80, 0x48, 
+0xF0, 0x22, 0x91, 0xA8, 0xFF, 0x30, 0xE0, 0x1C, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x86, 0x71, 0x47, 
+0x90, 0x81, 0x87, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0x4F, 0xB1, 0x2A, 0x90, 
+0x81, 0x89, 0xF0, 0x22, 0x90, 0x81, 0x86, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0xA3, 0xE0, 
+0x54, 0x01, 0x44, 0x1E, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x22, 0xF0, 0x90, 0x00, 0x03, 0x02, 0x1F, 
+0xBD, 0x12, 0x76, 0x27, 0x12, 0x76, 0x57, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 
+0x4F, 0x71, 0x47, 0x90, 0x81, 0x90, 0x91, 0xA7, 0x90, 0x81, 0x91, 0xF0, 0x90, 0x81, 0x90, 0xE0, 
+0x90, 0x81, 0x92, 0xF0, 0x90, 0x81, 0x8F, 0xE0, 0x54, 0x01, 0xFF, 0x02, 0x49, 0x16, 0xEF, 0x70, 
+0x3B, 0x7D, 0x78, 0x7F, 0x02, 0x12, 0x49, 0x86, 0x7D, 0x02, 0x7F, 0x03, 0x12, 0x49, 0x86, 0x7D, 
+0xC8, 0x7F, 0x02, 0x12, 0x73, 0x3C, 0x12, 0x72, 0xAE, 0xF0, 0xE4, 0xFF, 0x51, 0xC9, 0xEF, 0x70, 
+0x0A, 0xB1, 0xD8, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x80, 0x07, 0x7D, 0x01, 0x7F, 0x0C, 0x12, 
+0x4B, 0xBE, 0xB1, 0xDD, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 0x90, 0x01, 0x36, 0x74, 
+0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x12, 0x49, 0x0A, 0x7D, 0x02, 0x7F, 0x03, 
+0x12, 0x49, 0x0A, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0x12, 0x76, 0x3A, 0xE4, 0xFF, 0x51, 0xC9, 
+0xBF, 0x01, 0x11, 0xF1, 0xDB, 0xF0, 0x90, 0x81, 0x4C, 0xE0, 0x20, 0xE2, 0x0A, 0x7D, 0x01, 0x7F, 
+0x04, 0x02, 0x4B, 0xBE, 0xD1, 0xAB, 0xF0, 0x22, 0xB1, 0xE5, 0x12, 0x4F, 0xA2, 0x90, 0x81, 0x45, 
+0xE0, 0x54, 0xF7, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x01, 0x01, 0xE0, 
+0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 
+0x06, 0xB4, 0x74, 0x86, 0xF0, 0x12, 0x5F, 0xBD, 0xEC, 0x54, 0x7F, 0xFC, 0x90, 0x82, 0x53, 0x12, 
+0x20, 0xCE, 0x90, 0x82, 0x53, 0x12, 0x5E, 0xA0, 0x7F, 0x7C, 0xD1, 0x43, 0x12, 0x20, 0xDA, 0xCC, 
+0xC0, 0x00, 0xC0, 0x7F, 0x8C, 0xD1, 0x43, 0x12, 0x20, 0xDA, 0x00, 0xC0, 0x00, 0x14, 0x12, 0x76, 
+0x45, 0x12, 0x20, 0xDA, 0x00, 0x03, 0x3E, 0x60, 0xE4, 0xFD, 0xFF, 0x12, 0x67, 0xE1, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x22, 0x12, 0x76, 0x27, 0x90, 
+0x81, 0x8D, 0x12, 0x75, 0xF9, 0x54, 0x04, 0x25, 0xE0, 0xFD, 0xEF, 0x54, 0xF7, 0x4D, 0x90, 0x81, 
+0x8D, 0x71, 0x47, 0xFF, 0x90, 0x05, 0x54, 0xE0, 0xC3, 0x9F, 0x90, 0x81, 0x8E, 0xF0, 0xEE, 0x20, 
+0xE0, 0x03, 0x12, 0x4F, 0x40, 0x90, 0x81, 0x8D, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x15, 0x90, 0x81, 
+0x49, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x81, 0x4B, 0xF0, 0xD1, 0xAB, 0xF0, 0x90, 0x05, 0x58, 0x74, 
+0x05, 0xF0, 0x22, 0xE4, 0x90, 0x81, 0x49, 0xF0, 0x90, 0x81, 0x4B, 0x74, 0x0C, 0xF0, 0x90, 0x81, 
+0x45, 0xE0, 0x54, 0xFE, 0xF0, 0xA3, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x90, 0x81, 0x46, 0xE0, 0x44, 
+0x04, 0x22, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 0x02, 0xCE, 
+0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x81, 0x97, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 
+0x47, 0xF3, 0x60, 0x02, 0xE1, 0x77, 0x90, 0x81, 0x49, 0xE0, 0x70, 0x02, 0xE1, 0x77, 0x90, 0x81, 
+0x47, 0xE0, 0xC4, 0x54, 0x0F, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x81, 0x50, 
+0xF0, 0x90, 0x06, 0xAA, 0xE0, 0x90, 0x81, 0x4F, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x81, 
+0x4F, 0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 0x81, 0x50, 0xEF, 0xF0, 0xD1, 0xAB, 0xF0, 0xE4, 0x90, 
+0x81, 0x52, 0x12, 0x76, 0x3A, 0x12, 0x72, 0xAE, 0x12, 0x72, 0xBC, 0x54, 0xEF, 0xF0, 0x90, 0x81, 
+0x47, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x0F, 0x90, 0x81, 0x40, 0xE0, 
+0x30, 0xE0, 0x05, 0x12, 0x58, 0xE2, 0x80, 0x03, 0x12, 0x58, 0x9D, 0x12, 0x70, 0xA3, 0x30, 0xE0, 
+0x36, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x2D, 0x90, 0x81, 0x4F, 0xE0, 0xFF, 0xA3, 
+0xE0, 0x6F, 0x70, 0x23, 0x90, 0x81, 0x46, 0xE0, 0x44, 0x40, 0xF0, 0x12, 0x75, 0xBB, 0xF0, 0x90, 
+0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 0x49, 0x67, 0x12, 0x49, 0x82, 0x12, 0x76, 
+0x5F, 0x90, 0x81, 0x50, 0xE0, 0x14, 0xF0, 0x90, 0x81, 0x40, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x03, 
+0xD1, 0xAB, 0xF0, 0x22, 0x12, 0x70, 0xA3, 0x30, 0xE0, 0x0C, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 
+0x30, 0xE0, 0x03, 0x12, 0x76, 0x5F, 0x12, 0x72, 0xA4, 0x30, 0xE0, 0x09, 0x12, 0x72, 0xB9, 0x54, 
+0x07, 0x70, 0x37, 0x80, 0x32, 0x12, 0x72, 0xC5, 0x9F, 0x40, 0x2C, 0x12, 0x47, 0xF3, 0x70, 0x2A, 
+0x91, 0x5E, 0x70, 0x04, 0xF1, 0xDB, 0xF0, 0x22, 0x90, 0x81, 0x53, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 
+0x94, 0x02, 0x40, 0x0A, 0xF1, 0xDB, 0xF0, 0xE4, 0x90, 0x81, 0x53, 0xF0, 0x80, 0x03, 0x12, 0x4F, 
+0xAD, 0xE4, 0x90, 0x81, 0x52, 0xF0, 0x22, 0x12, 0x58, 0x53, 0x22, 0x90, 0x81, 0x46, 0xE0, 0x54, 
+0xFB, 0x22, 0x12, 0x4F, 0x40, 0x90, 0x81, 0x43, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x00, 0xF7, 0xE0, 
+0x20, 0xE7, 0x09, 0xE0, 0x7F, 0x01, 0x20, 0xE6, 0x0C, 0x7F, 0x02, 0x22, 0x90, 0x00, 0xF7, 0xE0, 
+0x30, 0xE6, 0x02, 0x7F, 0x03, 0x22, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x84, 0x22, 0xE4, 0x90, 0x81, 
+0xA8, 0xF0, 0x90, 0x81, 0xA8, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0x0D, 0x90, 0x01, 0xC4, 0xF0, 0x74, 
+0x58, 0xA3, 0xF0, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x0E, 0x90, 0x81, 0x4C, 0xE0, 0xFF, 0x90, 0x81, 
+0x4B, 0xE0, 0x6F, 0x60, 0x02, 0x11, 0x53, 0xC2, 0xAF, 0x12, 0x6D, 0xDD, 0xBF, 0x01, 0x02, 0x71, 
+0xF5, 0xD2, 0xAF, 0xF1, 0xB0, 0x12, 0x32, 0x9E, 0xBF, 0x01, 0x03, 0x12, 0x6C, 0x98, 0x12, 0x41, 
+0x4D, 0x80, 0xBF, 0x90, 0x81, 0x40, 0xE0, 0x90, 0x81, 0x4B, 0x30, 0xE0, 0x04, 0xE0, 0xFF, 0x61, 
+0x29, 0xE0, 0xFF, 0x7D, 0x01, 0x02, 0x4B, 0xBE, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x0F, 0x90, 0x06, 
+0x92, 0xE0, 0x30, 0xE1, 0x03, 0x02, 0x73, 0x77, 0x12, 0x55, 0xDD, 0x11, 0x53, 0x22, 0xE4, 0xFF, 
+0x12, 0x52, 0xC9, 0xBF, 0x01, 0x0E, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x08, 0x11, 0x95, 0x54, 0x07, 
+0x70, 0x02, 0x11, 0x53, 0x22, 0x90, 0x81, 0x4D, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0xE4, 0xF5, 0x4E, 
+0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x4E, 0x54, 0xC0, 0x70, 0x07, 0x11, 0x95, 0x54, 0xFD, 0xF0, 0x80, 
+0xA2, 0xE5, 0x4E, 0x30, 0xE6, 0x18, 0x90, 0x81, 0x49, 0xE0, 0x64, 0x01, 0x70, 0x12, 0x12, 0x54, 
+0x57, 0x64, 0x02, 0x60, 0x04, 0x31, 0x4D, 0x80, 0x07, 0x12, 0x4F, 0xAD, 0x80, 0x02, 0x11, 0x95, 
+0xE5, 0x4E, 0x90, 0x81, 0x4D, 0x30, 0xE7, 0x05, 0x12, 0x47, 0x7A, 0x61, 0x21, 0xE0, 0x54, 0xFD, 
+0xF0, 0x22, 0x90, 0x06, 0xA9, 0xE0, 0x90, 0x81, 0x99, 0xF0, 0xE0, 0xFD, 0x54, 0xC0, 0x70, 0x04, 
+0x11, 0x95, 0x80, 0x55, 0xED, 0x30, 0xE6, 0x3F, 0x90, 0x81, 0x49, 0xE0, 0x64, 0x02, 0x70, 0x27, 
+0x90, 0x81, 0x45, 0xE0, 0xFF, 0xC3, 0x13, 0x20, 0xE0, 0x09, 0x90, 0x81, 0x4D, 0xE0, 0x44, 0x01, 
+0xF0, 0x80, 0x1B, 0x12, 0x54, 0x5E, 0x64, 0x01, 0x70, 0x1F, 0x90, 0x81, 0x4D, 0xE0, 0x44, 0x04, 
+0xF0, 0x7F, 0x01, 0x31, 0xEA, 0x80, 0x12, 0x12, 0x54, 0x57, 0x64, 0x02, 0x60, 0x04, 0x31, 0x4D, 
+0x80, 0x07, 0x12, 0x4F, 0xAD, 0x80, 0x02, 0x11, 0x95, 0x90, 0x81, 0x99, 0xE0, 0x90, 0x81, 0x4D, 
+0x30, 0xE7, 0x05, 0x12, 0x47, 0x7A, 0x61, 0x21, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x04, 0x1D, 
+0xE0, 0x70, 0x15, 0x90, 0x80, 0x43, 0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 0x31, 0x69, 0x90, 0x81, 
+0x9A, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x71, 0x1A, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0x82, 0x60, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x82, 0x5F, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 
+0x12, 0x75, 0xE5, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0x82, 0x5F, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 
+0x82, 0x60, 0xE0, 0x60, 0x0E, 0x74, 0x0F, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
+0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x08, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE4, 
+0xF0, 0x74, 0x09, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 0xAF, 
+0x05, 0x51, 0xFB, 0xE0, 0x54, 0x01, 0xFE, 0x90, 0x82, 0x61, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 
+0xEE, 0x44, 0x02, 0x4B, 0xFE, 0x51, 0xFB, 0xEE, 0xF0, 0x74, 0x21, 0x2F, 0x51, 0x5B, 0x54, 0xF7, 
+0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x82, 0x5B, 0xEF, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x1D, 0x90, 0x05, 0x22, 0xE0, 
+0x90, 0x82, 0x5E, 0xF0, 0x7D, 0x29, 0xD1, 0x07, 0xBF, 0x01, 0x02, 0x51, 0x22, 0x90, 0x82, 0x5E, 
+0xE0, 0xFF, 0x7D, 0x2A, 0x12, 0x4D, 0xA9, 0x80, 0x02, 0x51, 0x22, 0x71, 0x1A, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x90, 0x80, 0x45, 0xE0, 0xFF, 0x7B, 0x08, 0x7D, 0x01, 0x31, 0x69, 0x90, 0x82, 0x5C, 
+0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x82, 0x5B, 0xE0, 0xFF, 0x51, 0x65, 0x54, 0x3F, 
+0xF0, 0xEF, 0x60, 0x0A, 0x51, 0x58, 0x44, 0x10, 0x51, 0x64, 0x44, 0x80, 0xF0, 0x22, 0x51, 0x58, 
+0x54, 0xEF, 0x51, 0x64, 0x44, 0x40, 0xF0, 0x22, 0x74, 0x21, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0xE0, 0x22, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
+0x22, 0x90, 0x80, 0x44, 0xE0, 0xFF, 0x90, 0x82, 0x4B, 0xE0, 0xFB, 0x7D, 0x01, 0x31, 0x69, 0x90, 
+0x82, 0x4C, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x82, 0x4A, 0xE0, 0xFF, 0x51, 0x3C, 
+0x90, 0x82, 0x4C, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x04, 0x80, 0xE0, 0x54, 0x0F, 0xFD, 0xAC, 
+0x07, 0x71, 0x0E, 0x44, 0x01, 0xF0, 0x71, 0x0E, 0x54, 0xFB, 0xF0, 0xAC, 0x07, 0x74, 0x16, 0x2C, 
+0x51, 0xFE, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x15, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0x44, 0x0F, 0xF0, 0x90, 0x04, 0x53, 0xE4, 0xF0, 0x90, 0x04, 0x52, 0xF0, 0x90, 0x04, 0x51, 
+0x74, 0xFF, 0xF0, 0x90, 0x04, 0x50, 0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 0x71, 0x06, 0xE0, 0x54, 
+0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 0x71, 0x06, 0xED, 0xF0, 0x22, 0x74, 0x16, 0x2F, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 0x11, 
+0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 
+0x22, 0x90, 0x81, 0x45, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xAE, 0x07, 0x71, 0x42, 0xBF, 0x01, 0x0F, 
+0xF1, 0xD4, 0x20, 0xE0, 0x0A, 0xAF, 0x06, 0x7D, 0x01, 0x12, 0x4B, 0xBE, 0x7F, 0x01, 0x22, 0x7F, 
+0x00, 0x22, 0x90, 0x05, 0x43, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0x12, 0x47, 
+0xF3, 0x70, 0x17, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x11, 0x12, 0x72, 0xAE, 0xF0, 0x90, 0x81, 0x45, 
+0xE0, 0x12, 0x72, 0xBA, 0x54, 0x07, 0x70, 0x02, 0x11, 0x53, 0x22, 0x90, 0x81, 0x49, 0xE0, 0x70, 
+0x07, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x11, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x07, 0x71, 
+0x42, 0xBF, 0x01, 0x05, 0x80, 0x04, 0x12, 0x4F, 0xBD, 0x22, 0x90, 0x81, 0x49, 0xE0, 0x64, 0x02, 
+0x60, 0x11, 0x12, 0x54, 0x5E, 0x60, 0x0C, 0x12, 0x6E, 0xD7, 0xEF, 0x70, 0x06, 0xFD, 0x7F, 0x0C, 
+0x12, 0x4B, 0xBE, 0x22, 0x71, 0xC2, 0x30, 0xE0, 0x0B, 0x71, 0xBB, 0x60, 0x07, 0x7D, 0x01, 0x7F, 
+0x02, 0x12, 0x4B, 0xBE, 0x71, 0xBB, 0x60, 0x02, 0x71, 0x8A, 0x22, 0x90, 0x81, 0x44, 0xE0, 0x64, 
+0x02, 0x22, 0x90, 0x81, 0x40, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x90, 0x81, 0x45, 
+0x71, 0xC5, 0x30, 0xE0, 0x1F, 0xEF, 0x54, 0xBF, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x81, 0x46, 
+0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x09, 0xE0, 0x54, 0xFE, 0x12, 0x73, 0x14, 0x74, 
+0x04, 0xF0, 0x11, 0x53, 0x22, 0x90, 0x81, 0x45, 0xE0, 0x30, 0xE0, 0x19, 0x90, 0x81, 0x40, 0xE0, 
+0xFF, 0x30, 0xE0, 0x0F, 0xC3, 0x13, 0x30, 0xE0, 0x08, 0x12, 0x75, 0xD8, 0xBF, 0x01, 0x06, 0x80, 
+0x02, 0x80, 0x00, 0x91, 0x16, 0x22, 0x90, 0x81, 0x4C, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x0E, 
+0x12, 0x6E, 0x94, 0xBF, 0x01, 0x08, 0x91, 0x2F, 0x90, 0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x63, 0xDE, 0x91, 0x40, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x12, 0x73, 0x1F, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 0xFD, 0x7F, 0x08, 0x12, 0x32, 0x1E, 0xE4, 
+0xFF, 0x12, 0x63, 0x80, 0x90, 0x81, 0x46, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x3F, 0xE0, 0xB4, 0x01, 0x04, 0x7F, 0x04, 0x80, 0x0B, 0x71, 0x42, 
+0xBF, 0x01, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x02, 0x91, 0x80, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x43, 0xE0, 0x90, 0x82, 0x70, 0xF0, 0x6F, 
+0x70, 0x02, 0xA1, 0x88, 0xEF, 0x14, 0x60, 0x42, 0x14, 0x60, 0x6D, 0x14, 0x70, 0x02, 0xA1, 0x33, 
+0x14, 0x70, 0x02, 0xA1, 0x5E, 0x24, 0x04, 0x60, 0x02, 0xA1, 0x88, 0x90, 0x82, 0x70, 0xE0, 0xB4, 
+0x04, 0x04, 0xD1, 0x72, 0xA1, 0x88, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x02, 0x04, 0xD1, 0x90, 0xA1, 
+0x88, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x03, 0x04, 0xD1, 0x7C, 0xA1, 0x88, 0x90, 0x82, 0x70, 0xE0, 
+0x64, 0x01, 0x60, 0x02, 0xA1, 0x88, 0xD1, 0x74, 0xA1, 0x88, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x04, 
+0x04, 0xD1, 0x80, 0xA1, 0x88, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x02, 0x05, 0x12, 0x57, 0xE2, 0xA1, 
+0x88, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x03, 0x04, 0xD1, 0x9A, 0xA1, 0x88, 0x90, 0x82, 0x70, 0xE0, 
+0x60, 0x02, 0xA1, 0x88, 0xD1, 0x4F, 0xA1, 0x88, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x04, 0x04, 0xB1, 
+0xFD, 0x80, 0x75, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x01, 0x04, 0xB1, 0x8F, 0x80, 0x6A, 0x90, 0x82, 
+0x70, 0xE0, 0xB4, 0x03, 0x04, 0xB1, 0x8D, 0x80, 0x5F, 0x90, 0x82, 0x70, 0xE0, 0x70, 0x59, 0xD1, 
+0x03, 0x80, 0x55, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x04, 0x04, 0xD1, 0x62, 0x80, 0x4A, 0x90, 0x82, 
+0x70, 0xE0, 0xB4, 0x01, 0x04, 0xD1, 0x54, 0x80, 0x3F, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x02, 0x04, 
+0xD1, 0x95, 0x80, 0x34, 0x90, 0x82, 0x70, 0xE0, 0x70, 0x2E, 0xD1, 0x52, 0x80, 0x2A, 0x90, 0x82, 
+0x70, 0xE0, 0xB4, 0x03, 0x04, 0xF1, 0xB1, 0x80, 0x1F, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x01, 0x05, 
+0x12, 0x4F, 0xEA, 0x80, 0x13, 0x90, 0x82, 0x70, 0xE0, 0xB4, 0x02, 0x04, 0xF1, 0xC4, 0x80, 0x08, 
+0x90, 0x82, 0x70, 0xE0, 0x70, 0x02, 0xD1, 0x6D, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x80, 0x07, 0x7D, 
+0x20, 0x7F, 0xFF, 0x12, 0x4D, 0xA9, 0xB1, 0x9F, 0x90, 0x81, 0x43, 0x74, 0x02, 0xF0, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xD1, 0x0C, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0xCC, 0xF0, 
+0x00, 0xC0, 0x7F, 0x8C, 0x12, 0x56, 0x43, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x14, 0x12, 0x76, 
+0x45, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFD, 0xFF, 0x12, 0x67, 0xE1, 0xF1, 0xBD, 
+0xEC, 0x44, 0x80, 0xFC, 0x90, 0x82, 0x57, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x57, 0xD1, 0xA0, 0x7F, 
+0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 0xFD, 
+0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD1, 0x88, 0x7D, 
+0x23, 0x80, 0x8E, 0xD1, 0x4F, 0x80, 0x88, 0x7F, 0xFF, 0x12, 0x4D, 0xA9, 0xE4, 0x90, 0x82, 0x66, 
+0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 
+0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 0x82, 0x67, 0xE0, 0x94, 0xE8, 0x90, 
+0x82, 0x66, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 
+0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x82, 0x66, 0xF1, 0xB6, 0x80, 0xC4, 0x02, 
+0x57, 0xE5, 0xD1, 0x4F, 0x7D, 0x21, 0x7F, 0xFF, 0x12, 0x4D, 0xA9, 0x90, 0x81, 0x43, 0x74, 0x03, 
+0xF0, 0x22, 0x7D, 0x22, 0x7F, 0xFF, 0x12, 0x4D, 0xA9, 0xD1, 0x88, 0x80, 0xEE, 0xD1, 0x4F, 0x02, 
+0x4F, 0xEA, 0xD1, 0x80, 0xF1, 0xCC, 0xE4, 0x90, 0x81, 0x43, 0xF0, 0x22, 0xD1, 0x9A, 0x80, 0xF4, 
+0x12, 0x4F, 0x43, 0xD1, 0x88, 0x02, 0x57, 0xE5, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 0x22, 
+0x12, 0x57, 0xE2, 0x80, 0xDF, 0x12, 0x55, 0xE5, 0x80, 0xC1, 0x12, 0x4F, 0x43, 0x02, 0x57, 0xE5, 
+0x12, 0x44, 0xCF, 0x90, 0x85, 0xBB, 0x02, 0x20, 0xCE, 0x90, 0x82, 0x2B, 0xEF, 0xF0, 0xA3, 0xED, 
+0xF0, 0xA3, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x90, 0x82, 0x39, 0xF0, 0x7F, 0x24, 
+0x7E, 0x08, 0x12, 0x2D, 0x5C, 0x90, 0x82, 0x31, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x2B, 0xE0, 0xFB, 
+0x70, 0x04, 0xF1, 0x8B, 0x80, 0x06, 0xEB, 0xF1, 0x91, 0x12, 0x2D, 0x5C, 0x90, 0x82, 0x35, 0x12, 
+0x20, 0xCE, 0x90, 0x82, 0x2C, 0x12, 0x6A, 0xD9, 0x78, 0x17, 0x12, 0x65, 0x7F, 0x90, 0x82, 0x35, 
+0x12, 0x44, 0xCF, 0xED, 0x54, 0x7F, 0xFD, 0xEC, 0x54, 0x80, 0xFC, 0x12, 0x44, 0xC2, 0xEC, 0x44, 
+0x80, 0xFC, 0x90, 0x82, 0x35, 0x12, 0x20, 0xCE, 0xF1, 0x8B, 0xEC, 0x54, 0x7F, 0xFC, 0xD1, 0xA3, 
+0xF1, 0xA4, 0xF1, 0x91, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 0x35, 0xD1, 0xA0, 0xD0, 0x07, 0xD0, 
+0x06, 0x12, 0x2E, 0xA2, 0xF1, 0x8B, 0xEC, 0x44, 0x80, 0xFC, 0xD1, 0xA3, 0xF1, 0xA4, 0x70, 0x04, 
+0x7F, 0x20, 0x80, 0x09, 0x90, 0x82, 0x2B, 0xE0, 0xB4, 0x01, 0x16, 0x7F, 0x28, 0x7E, 0x08, 0x12, 
+0x2D, 0x5C, 0x78, 0x08, 0x12, 0x20, 0xA8, 0xEF, 0x54, 0x01, 0xFF, 0xE4, 0x90, 0x82, 0x39, 0xEF, 
+0xF0, 0x90, 0x82, 0x39, 0xE0, 0x90, 0x82, 0x2B, 0x60, 0x0E, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 
+0x66, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x80, 0x0C, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x64, 0xF5, 
+0x82, 0xE4, 0x34, 0x87, 0xF1, 0x9C, 0x12, 0x2D, 0x5C, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x90, 
+0x82, 0x2D, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x2D, 0x02, 0x44, 0xCF, 0x90, 0x82, 0x31, 0x02, 0x44, 
+0xCF, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x62, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 
+0xA3, 0xE0, 0xFF, 0x22, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x82, 0x2B, 0xE0, 0x22, 
+0x22, 0x7D, 0x25, 0x02, 0x4F, 0xEC, 0xE4, 0x75, 0xF0, 0x01, 0x02, 0x44, 0x9F, 0x7F, 0x7C, 0x7E, 
+0x08, 0x02, 0x2D, 0x5C, 0x12, 0x55, 0xE5, 0x7D, 0x24, 0x02, 0x4F, 0xEC, 0x90, 0x05, 0x27, 0xE0, 
+0x54, 0xBF, 0xF0, 0x22, 0x90, 0x81, 0x40, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0xE4, 0xFB, 
+0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x43, 0x4E, 0x90, 0x82, 0x0C, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x80, 
+0x3C, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 0xEF, 0x30, 0xE1, 0x09, 0x90, 
+0x80, 0x3C, 0xE0, 0x54, 0xFD, 0xF0, 0x11, 0x1D, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x80, 0x3C, 0xE0, 
+0xFF, 0x30, 0xE2, 0x05, 0x54, 0xFB, 0xF0, 0x31, 0xAC, 0xD2, 0xAF, 0x80, 0xD1, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x80, 0x9A, 0xE0, 0xFF, 0x90, 0x80, 0x99, 0xE0, 0xB5, 0x07, 0x04, 
+0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x3F, 0x90, 0x80, 0x99, 0xE0, 0xFE, 0x75, 0xF0, 
+0x08, 0x90, 0x80, 0x49, 0x12, 0x45, 0x00, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x4A, 
+0xF9, 0x74, 0x80, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x12, 0x4B, 0x24, 0x90, 0x80, 0x99, 
+0x31, 0xA5, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0x99, 0xF0, 0x11, 
+0x7D, 0x90, 0x80, 0x3C, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x01, 0xCC, 
+0xE0, 0x54, 0x0F, 0x90, 0x82, 0x64, 0xF0, 0x90, 0x82, 0x64, 0xE0, 0xFD, 0x70, 0x02, 0x21, 0x7A, 
+0x90, 0x80, 0x99, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 
+0x90, 0x80, 0x9A, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x08, 
+0x90, 0x01, 0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x82, 0x62, 0x71, 0xD4, 0x80, 0x05, 0xC3, 
+0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0x21, 0x5D, 0xE4, 0x90, 0x82, 
+0x65, 0xF0, 0x90, 0x82, 0x65, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 0x32, 0x31, 0x7C, 0xA4, 0xFF, 
+0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 0x31, 0x93, 0x90, 0x80, 
+0x49, 0x31, 0x84, 0x31, 0x7B, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xF0, 0x31, 0x93, 
+0x90, 0x80, 0x4D, 0x31, 0x84, 0xF0, 0x90, 0x82, 0x65, 0xE0, 0x04, 0xF0, 0x80, 0xC4, 0x90, 0x82, 
+0x64, 0xE0, 0xFF, 0x90, 0x82, 0x62, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x80, 0x02, 0xC3, 
+0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0x82, 0x64, 0xF0, 0x90, 0x82, 0x62, 0xE0, 0xFF, 0x74, 0x01, 
+0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x82, 0x62, 
+0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0x80, 0x9A, 0x31, 0xA5, 0xB4, 0x0A, 0x02, 0x7F, 
+0x01, 0xEF, 0x70, 0x02, 0x01, 0x87, 0xE4, 0x90, 0x80, 0x9A, 0xF0, 0x01, 0x87, 0x90, 0x01, 0xC0, 
+0xE0, 0x44, 0x02, 0xF0, 0x90, 0x82, 0x62, 0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0x31, 0x7B, 0x90, 
+0x01, 0xD0, 0x12, 0x45, 0x00, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 0xF0, 0x90, 0x82, 0x62, 0xE0, 
+0x75, 0xF0, 0x04, 0x22, 0x12, 0x45, 0x00, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 
+0x83, 0xEF, 0x22, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x80, 0x9A, 
+0xE0, 0x75, 0xF0, 0x08, 0x22, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 0x90, 0x81, 0x32, 0xE0, 0xFE, 0x90, 0x81, 0x31, 0xE0, 0xFD, 0xB5, 
+0x06, 0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x41, 0x90, 0x01, 0xAF, 
+0xE0, 0x70, 0x0A, 0xED, 0x51, 0x70, 0xFA, 0x7B, 0x01, 0x51, 0xC8, 0x7F, 0x01, 0xEF, 0x60, 0x2E, 
+0x90, 0x81, 0x31, 0x31, 0xA5, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x81, 
+0x31, 0xF0, 0x90, 0x81, 0x32, 0xE0, 0xFF, 0x90, 0x81, 0x31, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 
+0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x07, 0x90, 0x80, 0x3C, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x31, 0xE0, 0xFF, 0x70, 
+0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x81, 0x32, 0xE0, 0xB5, 0x07, 
+0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 
+0xF0, 0x80, 0x28, 0xC0, 0x01, 0x90, 0x81, 0x32, 0xE0, 0x51, 0x70, 0xA8, 0x01, 0xFC, 0x7D, 0x01, 
+0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x44, 0x79, 0x90, 0x81, 0x32, 0x31, 0xA5, 0xB4, 0x0A, 
+0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x81, 0x32, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x9B, 0xF9, 0x74, 0x80, 0x35, 0xF0, 0x22, 0x90, 0x82, 0x1C, 0x74, 
+0x12, 0xF0, 0x90, 0x82, 0x2A, 0x74, 0x05, 0xF0, 0x90, 0x82, 0x1E, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 
+0xA3, 0xEB, 0xF0, 0x90, 0x82, 0x1A, 0xE0, 0x90, 0x82, 0x21, 0xF0, 0x90, 0x82, 0x1B, 0xE0, 0x90, 
+0x82, 0x22, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x1C, 0x51, 0x13, 0x7F, 0x04, 0x90, 0x82, 0x6A, 
+0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x43, 0x27, 0x90, 0x80, 0x3C, 0xE0, 0xFF, 0x90, 0x82, 0x6A, 0xE0, 
+0xFE, 0xEF, 0x4E, 0x90, 0x80, 0x3C, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x82, 0x0D, 0x12, 0x45, 0x15, 0x90, 0x82, 0x63, 0xE0, 0xFF, 0x04, 0xF0, 0x90, 0x00, 0x01, 0xEF, 
+0x12, 0x1F, 0xFC, 0x7F, 0xAF, 0x7E, 0x01, 0x71, 0x2B, 0xEF, 0x60, 0x3A, 0x90, 0x82, 0x0D, 0x12, 
 0x45, 0x0C, 0x8B, 0x13, 0x8A, 0x14, 0x89, 0x15, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x24, 0x02, 
-0xF5, 0x16, 0x7B, 0x01, 0x7A, 0x01, 0x79, 0xA0, 0x12, 0x2B, 0xED, 0x90, 0x82, 0xA4, 0x12, 0x45, 
+0xF5, 0x16, 0x7B, 0x01, 0x7A, 0x01, 0x79, 0xA0, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x0D, 0x12, 0x45, 
 0x0C, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x90, 0x01, 0xAE, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0x90, 
 0x01, 0xCB, 0xE0, 0x64, 0x80, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
-0xC0, 0xD0, 0x90, 0x80, 0x9A, 0xE0, 0xFF, 0x90, 0x80, 0x99, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 
-0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x43, 0x90, 0x80, 0x99, 0xE0, 0xFE, 0x75, 0xF0, 0x08, 0x90, 
-0x80, 0x49, 0x12, 0x45, 0x00, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x4A, 0xF9, 0x74, 
-0x80, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x12, 0x5E, 0x51, 0x90, 0x80, 0x99, 0xE0, 0x04, 
-0xF0, 0xE0, 0x7F, 0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0x99, 
-0xF0, 0x31, 0x95, 0x90, 0x80, 0x3C, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 
-0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0xE6, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xA3, 
-0xF0, 0xA3, 0xF0, 0x90, 0x82, 0xE6, 0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 0xE0, 0x60, 
-0x2D, 0xC3, 0x90, 0x82, 0xE9, 0xE0, 0x94, 0xE8, 0x90, 0x82, 0xE8, 0xE0, 0x94, 0x03, 0x40, 0x0B, 
-0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 0x15, 0x90, 0x82, 0xE8, 0xE4, 0x75, 
-0xF0, 0x01, 0x12, 0x44, 0x9F, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x80, 0xC5, 0x7F, 0x01, 
-0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0x82, 0xFB, 0xF0, 0x90, 
-0x82, 0xFB, 0xE0, 0xFD, 0x70, 0x02, 0x41, 0xE4, 0x90, 0x80, 0x99, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 
-0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x80, 0x9A, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 
-0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 
-0x90, 0x82, 0xF9, 0xE0, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 
-0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0x41, 0xC1, 0xE4, 0x90, 0x82, 0xFC, 
-0xF0, 0x90, 0x82, 0xFC, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 0x73, 0x90, 0x82, 0xF9, 0xE0, 0x75, 
-0xF0, 0x04, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 
-0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x80, 0x9A, 0xE0, 0x75, 0xF0, 
-0x08, 0x90, 0x80, 0x49, 0x12, 0x45, 0x00, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 
-0x83, 0xEF, 0xF0, 0x90, 0x82, 0xF9, 0xE0, 0x75, 0xF0, 0x04, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 
-0xFE, 0x74, 0xF0, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x80, 0x9A, 
-0xE0, 0x75, 0xF0, 0x08, 0x90, 0x80, 0x4D, 0x12, 0x45, 0x00, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE4, 
-0x35, 0x83, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0xFC, 0xE0, 0x04, 0xF0, 0x80, 0x83, 0x90, 0x82, 
-0xFB, 0xE0, 0xFF, 0x90, 0x82, 0xF9, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x80, 0x02, 0xC3, 
-0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0x82, 0xFB, 0xF0, 0x90, 0x82, 0xF9, 0xE0, 0xFF, 0x74, 0x01, 
-0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x82, 0xF9, 
-0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0x80, 0x9A, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 
-0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x70, 0x02, 0x21, 0x9F, 0xE4, 0x90, 0x80, 0x9A, 0xF0, 0x21, 
-0x9F, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x82, 0xF9, 0xE0, 0x44, 0x80, 0x90, 0x00, 
-0x8A, 0xF0, 0x90, 0x82, 0xF9, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xD0, 0x12, 0x45, 0x00, 0xE0, 
-0x90, 0x01, 0xC3, 0xF0, 0x22, 0x90, 0x82, 0xC2, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0x12, 0x20, 
-0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x90, 0x82, 0xD0, 0xF0, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2D, 
-0x5C, 0x90, 0x82, 0xC8, 0x12, 0x20, 0xCE, 0x90, 0x82, 0xC2, 0xE0, 0xFB, 0x70, 0x08, 0x90, 0x82, 
-0xC8, 0x12, 0x44, 0xCF, 0x80, 0x16, 0xEB, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x62, 0xF5, 0x82, 0xE4, 
-0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x2D, 0x5C, 0x90, 0x82, 0xCC, 0x12, 
-0x20, 0xCE, 0x90, 0x82, 0xC3, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x17, 0x12, 0x20, 0xBB, 
-0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x82, 0xCC, 0x12, 0x44, 0xCF, 0xED, 0x54, 
-0x7F, 0xFD, 0xEC, 0x54, 0x80, 0xFC, 0x12, 0x44, 0xC2, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x82, 0xCC, 
-0x12, 0x20, 0xCE, 0x90, 0x82, 0xC8, 0x12, 0x44, 0xCF, 0xEC, 0x54, 0x7F, 0xFC, 0x90, 0x85, 0xBB, 
-0x12, 0x20, 0xCE, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x82, 0xC2, 0xE0, 0x75, 0xF0, 
-0x08, 0xA4, 0x24, 0x62, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
-0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 0xCC, 0x12, 0x44, 0xCF, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 
-0xD0, 0x07, 0xD0, 0x06, 0x12, 0x2E, 0xA2, 0x90, 0x82, 0xC8, 0x12, 0x44, 0xCF, 0xEC, 0x44, 0x80, 
-0xFC, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x82, 
-0xC2, 0xE0, 0x70, 0x04, 0x7F, 0x20, 0x80, 0x09, 0x90, 0x82, 0xC2, 0xE0, 0xB4, 0x01, 0x16, 0x7F, 
-0x28, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0x78, 0x08, 0x12, 0x20, 0xA8, 0xEF, 0x54, 0x01, 0xFF, 0xE4, 
-0x90, 0x82, 0xD0, 0xEF, 0xF0, 0x90, 0x82, 0xD0, 0xE0, 0x90, 0x82, 0xC2, 0x60, 0x0E, 0xE0, 0x75, 
-0xF0, 0x08, 0xA4, 0x24, 0x66, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x80, 0x0C, 0xE0, 0x75, 0xF0, 0x08, 
-0xA4, 0x24, 0x64, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 
-0x2D, 0x5C, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x90, 0x82, 0xC4, 0x12, 0x20, 0xCE, 0x90, 0x82, 
-0xC4, 0x02, 0x44, 0xCF, 0xE0, 0x44, 0x02, 0xF0, 0xE4, 0xF5, 0x1D, 0x90, 0x82, 0x20, 0xE0, 0xF5, 
-0x1E, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8E, 
-0x19, 0x8F, 0x1A, 0xE5, 0x1E, 0x54, 0x07, 0xC4, 0x33, 0x54, 0xE0, 0x85, 0x19, 0x83, 0x85, 0x1A, 
-0x82, 0xF0, 0xE5, 0x1D, 0x54, 0x07, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 0xE5, 0x1E, 0x13, 0x13, 0x13, 
-0x54, 0x1F, 0x4F, 0xA3, 0xF0, 0xEB, 0x54, 0x07, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 0xE5, 0x1D, 0x13, 
-0x13, 0x13, 0x54, 0x1F, 0x4F, 0x85, 0x1A, 0x82, 0x85, 0x19, 0x83, 0xA3, 0xA3, 0xF0, 0xBD, 0x01, 
-0x0D, 0x85, 0x1A, 0x82, 0x8E, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 0x03, 0xF0, 0x80, 0x0C, 0x85, 0x1A, 
-0x82, 0x85, 0x19, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 0x01, 0xF0, 0x85, 0x1A, 0x82, 0x85, 0x19, 0x83, 
-0xA3, 0xA3, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xF5, 0x4E, 0x90, 0x06, 
-0xA9, 0xE0, 0xF5, 0x4E, 0x54, 0xC0, 0x70, 0x0D, 0x90, 0x81, 0x84, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 
-0xFD, 0xF0, 0x02, 0x47, 0x9F, 0xE5, 0x4E, 0x30, 0xE6, 0x22, 0x90, 0x81, 0x80, 0xE0, 0x64, 0x01, 
-0x70, 0x21, 0x90, 0x81, 0x84, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x81, 0x7E, 0xE0, 0x54, 0x0F, 0x64, 
-0x02, 0x60, 0x04, 0xD1, 0x51, 0x80, 0x0C, 0x12, 0x4E, 0x3E, 0x80, 0x07, 0x90, 0x81, 0x84, 0xE0, 
-0x54, 0xFE, 0xF0, 0xE5, 0x4E, 0x90, 0x81, 0x84, 0x30, 0xE7, 0x0A, 0x91, 0x24, 0x90, 0x81, 0x7C, 
-0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x06, 0xA9, 0xE0, 0x90, 0x82, 
-0x30, 0xF0, 0xE0, 0xFD, 0x54, 0xC0, 0x70, 0x09, 0x90, 0x81, 0x84, 0xE0, 0x54, 0xFE, 0xF0, 0x80, 
-0x6D, 0xED, 0x30, 0xE6, 0x4D, 0x90, 0x81, 0x80, 0xE0, 0x64, 0x02, 0x70, 0x2B, 0x90, 0x81, 0x7C, 
-0xE0, 0xFF, 0xC3, 0x13, 0x20, 0xE0, 0x09, 0x90, 0x81, 0x84, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x29, 
-0x90, 0x81, 0x7E, 0xE0, 0x54, 0x0F, 0x64, 0x01, 0x70, 0x2F, 0x90, 0x81, 0x84, 0xE0, 0x44, 0x04, 
-0xF0, 0x7F, 0x01, 0x12, 0x4E, 0x9A, 0x80, 0x21, 0x90, 0x81, 0x84, 0xE0, 0x44, 0x01, 0xF0, 0x90, 
-0x81, 0x7E, 0xE0, 0x54, 0x0F, 0x64, 0x02, 0x60, 0x04, 0xD1, 0x51, 0x80, 0x0C, 0x12, 0x4E, 0x3E, 
-0x80, 0x07, 0x90, 0x81, 0x84, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x82, 0x30, 0xE0, 0x90, 0x81, 0x84, 
-0x30, 0xE7, 0x0A, 0x91, 0x24, 0x90, 0x81, 0x7C, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFD, 
-0xF0, 0x22, 0x90, 0x81, 0x36, 0xE0, 0x64, 0x01, 0x60, 0x02, 0xC1, 0x40, 0x90, 0x81, 0x80, 0xE0, 
-0x70, 0x02, 0xC1, 0x40, 0x90, 0x81, 0x7E, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x64, 0x01, 0x70, 0x26, 
-0x90, 0x06, 0xAB, 0xE0, 0x90, 0x81, 0x87, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 0x04, 0x90, 0x81, 0x86, 
-0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x81, 0x86, 0xE0, 0xFE, 0xFF, 0x80, 0x03, 0xEF, 0x04, 
-0xFF, 0x90, 0x81, 0x87, 0xEF, 0xF0, 0x90, 0x81, 0x7C, 0xE0, 0x30, 0xE0, 0x02, 0xD1, 0x72, 0x90, 
-0x81, 0x7D, 0xE0, 0x44, 0x04, 0xF0, 0xE4, 0x90, 0x81, 0x89, 0xF0, 0x90, 0x81, 0x8B, 0xA3, 0xE0, 
-0x90, 0x05, 0x58, 0xF0, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x90, 
-0x81, 0x84, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0xEF, 0xF0, 0x90, 0x81, 0x7E, 0xE0, 0xFF, 0xC4, 0x54, 
-0x0F, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x0D, 0x90, 0x81, 0x77, 0xE0, 0x30, 0xE0, 0x04, 0xB1, 0x0A, 
-0x80, 0x02, 0x91, 0xAB, 0x90, 0x81, 0x7D, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x10, 
-0x90, 0x81, 0x86, 0xE0, 0xFF, 0xA3, 0xE0, 0xB5, 0x07, 0x06, 0x12, 0x57, 0x76, 0x12, 0x55, 0x17, 
-0x90, 0x81, 0x77, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x07, 0x90, 0x81, 0x7D, 0xE0, 0x44, 0x04, 0xF0, 
-0x22, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x1A, 0x90, 0x80, 0x43, 0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 
-0x12, 0x4F, 0x3A, 0x90, 0x82, 0x31, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x04, 0x1F, 0x74, 0x20, 
-0xF0, 0x22, 0xE4, 0x90, 0x82, 0x30, 0xF0, 0xFD, 0xA3, 0xF0, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 
-0x05, 0x61, 0xE0, 0xFB, 0xEB, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 
-0x81, 0xB3, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x81, 0xB3, 
-0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0xC3, 0x9F, 0xEA, 0x9E, 0x40, 0x28, 0xEB, 0x9F, 0xFF, 0x90, 0x81, 
-0x95, 0xE0, 0xFE, 0xC3, 0x74, 0x0A, 0x9E, 0x2F, 0xFD, 0xC3, 0x94, 0x19, 0x50, 0x13, 0x74, 0x98, 
-0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x93, 0xE0, 0x04, 
-0xF0, 0xF1, 0x45, 0x90, 0x81, 0x93, 0xE0, 0xC3, 0x94, 0x64, 0x40, 0x68, 0xE4, 0x90, 0x82, 0x31, 
-0xF0, 0x90, 0x82, 0x30, 0xF0, 0x90, 0x82, 0x30, 0xE0, 0xFF, 0xC3, 0x94, 0x19, 0x50, 0x47, 0x74, 
-0x98, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 0x31, 0xE0, 0x2F, 
-0xF0, 0xE0, 0xD3, 0x94, 0x05, 0x40, 0x27, 0x90, 0x82, 0x30, 0xE0, 0xFF, 0x94, 0x0A, 0x40, 0x0A, 
-0xEF, 0x24, 0xF6, 0x90, 0x81, 0x92, 0xF0, 0xE4, 0x80, 0x0E, 0xE4, 0x90, 0x81, 0x92, 0xF0, 0x90, 
-0x82, 0x30, 0xE0, 0xFF, 0xC3, 0x74, 0x0A, 0x9F, 0x90, 0x81, 0x91, 0xF0, 0x80, 0x08, 0x90, 0x82, 
-0x30, 0xE0, 0x04, 0xF0, 0x80, 0xAF, 0x90, 0x81, 0x92, 0xE0, 0xFD, 0x7B, 0x08, 0xE4, 0xFF, 0xF1, 
-0x77, 0x12, 0x77, 0xA3, 0x22, 0x90, 0x82, 0x1F, 0xE0, 0xFF, 0x90, 0x81, 0x89, 0xE0, 0xD3, 0x9F, 
-0x40, 0x24, 0x90, 0x81, 0x97, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x94, 0x04, 0x50, 0x18, 0x90, 0x81, 
-0x91, 0xEF, 0xF0, 0x25, 0xE0, 0x24, 0x08, 0x90, 0x81, 0x96, 0xF0, 0xFB, 0x90, 0x81, 0x91, 0xE0, 
-0xFF, 0xA3, 0xE0, 0xFD, 0xF1, 0x77, 0x22, 0xAC, 0x07, 0x90, 0x81, 0x7C, 0xE0, 0x30, 0xE0, 0x32, 
-0x90, 0x81, 0x92, 0xE0, 0xD3, 0x94, 0x03, 0x50, 0x07, 0x90, 0x81, 0x88, 0xEB, 0xF0, 0x80, 0x0A, 
-0xED, 0x24, 0xFD, 0x2B, 0x90, 0x81, 0x88, 0xF0, 0x7D, 0x03, 0x90, 0x81, 0xB7, 0xE0, 0x24, 0x04, 
-0xC3, 0x9D, 0x2C, 0xFF, 0x90, 0x81, 0x95, 0xF0, 0x90, 0x81, 0x8B, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 
-0x80, 0x0E, 0x90, 0x81, 0x8B, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x88, 0xEB, 0xF0, 
-0x90, 0x81, 0x8B, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0x90, 0x81, 0x36, 0xE0, 0xB4, 0x01, 
-0x15, 0x90, 0x81, 0x80, 0xE0, 0x60, 0x0F, 0x90, 0x81, 0x7E, 0xE0, 0x54, 0x0F, 0x64, 0x02, 0x60, 
-0x02, 0xC1, 0x51, 0x12, 0x4E, 0x3E, 0x22, 0xAC, 0x07, 0xED, 0xAD, 0x04, 0x78, 0x24, 0xF2, 0xED, 
-0x08, 0xF2, 0xEB, 0xB4, 0x04, 0x07, 0x78, 0x27, 0x74, 0x01, 0xF2, 0x80, 0x0E, 0xEB, 0x78, 0x27, 
-0xB4, 0x05, 0x05, 0x74, 0x02, 0xF2, 0x80, 0x03, 0x74, 0x04, 0xF2, 0xD3, 0x78, 0x25, 0xE2, 0x94, 
-0xFF, 0x18, 0xE2, 0x94, 0x00, 0x50, 0x63, 0xE4, 0x78, 0x26, 0xF2, 0x78, 0x27, 0xE2, 0xFF, 0x18, 
-0xE2, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0x21, 0x85, 0x74, 0x33, 0x2E, 0xF8, 0xE2, 0x78, 0x28, 0xF2, 
-0x90, 0x82, 0xA2, 0xE0, 0x60, 0x2D, 0x74, 0x37, 0x2E, 0xF8, 0xE2, 0x78, 0x32, 0xF2, 0xEE, 0xFF, 
-0x78, 0x25, 0xE2, 0x2F, 0xFF, 0x18, 0xE2, 0x34, 0x00, 0x8F, 0x82, 0xF5, 0x83, 0xE0, 0x78, 0x29, 
-0xF2, 0x78, 0x32, 0xE2, 0xFF, 0xF4, 0xFE, 0x78, 0x29, 0xE2, 0x5E, 0xFE, 0x18, 0xE2, 0xFD, 0xEF, 
-0x5D, 0x4E, 0xF2, 0x78, 0x24, 0x08, 0xE2, 0xFF, 0x08, 0xE2, 0x2F, 0xFF, 0x78, 0x28, 0xE2, 0xFD, 
-0x12, 0x32, 0x1E, 0x78, 0x26, 0xE2, 0x04, 0xF2, 0x80, 0xA1, 0xD3, 0x78, 0x25, 0xE2, 0x94, 0xFF, 
-0x18, 0xE2, 0x94, 0x07, 0x50, 0x69, 0xE4, 0x78, 0x26, 0xF2, 0x78, 0x27, 0xE2, 0xFF, 0x18, 0xE2, 
-0xFE, 0xC3, 0x9F, 0x40, 0x02, 0x21, 0x85, 0x74, 0x33, 0x2E, 0xF8, 0xE2, 0x78, 0x28, 0xF2, 0x90, 
-0x82, 0xA2, 0xE0, 0x60, 0x2D, 0x78, 0x26, 0xE2, 0xFF, 0xFD, 0x18, 0xE2, 0x2D, 0xFD, 0x18, 0xE2, 
-0x34, 0x00, 0x8D, 0x82, 0xF5, 0x83, 0xE0, 0x78, 0x29, 0xF2, 0x74, 0x37, 0x2F, 0xF8, 0xE2, 0x78, 
-0x32, 0xF2, 0xE2, 0xFF, 0xF4, 0xFE, 0x78, 0x29, 0xE2, 0x5E, 0xFE, 0x18, 0xE2, 0xFD, 0xEF, 0x5D, 
-0x4E, 0xF2, 0x78, 0x28, 0xE2, 0xFF, 0x78, 0x26, 0xE2, 0xFD, 0x18, 0xE2, 0x2D, 0xFD, 0x18, 0xE2, 
-0x34, 0x00, 0x8D, 0x82, 0xF5, 0x83, 0xEF, 0xF0, 0x78, 0x26, 0xE2, 0x04, 0xF2, 0x80, 0x9B, 0x90, 
-0x82, 0xA2, 0xE0, 0x60, 0x0F, 0x78, 0x24, 0xE2, 0xFE, 0x08, 0xE2, 0xFF, 0x12, 0x2D, 0x5C, 0x78, 
-0x2E, 0x12, 0x44, 0xF4, 0xE4, 0x78, 0x26, 0xF2, 0x78, 0x27, 0xE2, 0xFF, 0x18, 0xE2, 0xFE, 0xC3, 
-0x9F, 0x50, 0x5D, 0x74, 0x33, 0x2E, 0xF8, 0xE2, 0x78, 0x28, 0xF2, 0x90, 0x82, 0xA2, 0xE0, 0x60, 
-0x2B, 0x78, 0x2E, 0x12, 0x44, 0xDB, 0x78, 0x26, 0xE2, 0xFB, 0x75, 0xF0, 0x08, 0xA4, 0xF9, 0xF8, 
-0x12, 0x20, 0xA8, 0x78, 0x29, 0xEF, 0xF2, 0x74, 0x37, 0x2B, 0xF8, 0xE2, 0x78, 0x32, 0xF2, 0xE2, 
-0xFE, 0xF4, 0x5F, 0xFF, 0x78, 0x28, 0xE2, 0xFD, 0xEE, 0x5D, 0x4F, 0xF2, 0x78, 0x28, 0xE2, 0xFF, 
-0x78, 0x26, 0xE2, 0xFD, 0xC3, 0x74, 0x03, 0x9D, 0xFD, 0xE4, 0x94, 0x00, 0xFC, 0x7B, 0xFE, 0x74, 
-0x2A, 0x2D, 0xF9, 0x74, 0x80, 0x3C, 0xFA, 0xEF, 0x12, 0x1F, 0xEA, 0xE2, 0x04, 0xF2, 0x80, 0x98, 
-0x78, 0x2A, 0x12, 0x44, 0xDB, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0x78, 0x24, 0xE2, 0xFE, 0x08, 
-0xE2, 0xFF, 0x12, 0x2E, 0xA2, 0x22, 0xE4, 0x90, 0x82, 0x50, 0xF0, 0x90, 0x87, 0x5F, 0xE0, 0x90, 
-0x82, 0x4F, 0xF0, 0xE4, 0x90, 0x82, 0x5C, 0xF0, 0x90, 0x82, 0x4C, 0xF0, 0x90, 0x82, 0x4C, 0xE0, 
-0xFF, 0xC3, 0x94, 0x40, 0x50, 0x15, 0x74, 0x5F, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 
-0x74, 0xFF, 0xF0, 0x90, 0x82, 0x4C, 0xE0, 0x04, 0xF0, 0x80, 0xE1, 0xE4, 0x90, 0x82, 0x4C, 0xF0, 
-0x90, 0x82, 0x4F, 0xE0, 0xFF, 0x90, 0x82, 0x4C, 0xE0, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0x41, 0x90, 
-0x74, 0xDF, 0x2E, 0xF9, 0xE4, 0x34, 0x86, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 
-0x0A, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x41, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x42, 0xE0, 0xFF, 0x12, 
-0x2F, 0x27, 0xEF, 0x04, 0x90, 0x82, 0x5C, 0xF0, 0x90, 0x82, 0x41, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 
-0x12, 0x31, 0xEA, 0xEF, 0x24, 0xC8, 0x90, 0x82, 0x5E, 0xF0, 0x75, 0xF0, 0x08, 0xA4, 0xF0, 0x90, 
-0x82, 0x42, 0xE0, 0x54, 0x0F, 0x90, 0x82, 0x5D, 0xF0, 0xE4, 0x90, 0x82, 0x4B, 0xF0, 0x90, 0x82, 
-0x4D, 0xF0, 0x90, 0x82, 0x4D, 0xE0, 0xFF, 0xC3, 0x94, 0x04, 0x50, 0x57, 0x90, 0x82, 0x5D, 0xE0, 
-0xFE, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x13, 0xD8, 0xFC, 0x20, 0xE0, 0x3E, 0x90, 0x82, 0x4D, 
-0xE0, 0x25, 0xE0, 0xFF, 0x90, 0x82, 0x5E, 0xE0, 0x2F, 0x24, 0x5F, 0xF9, 0xE4, 0x34, 0x82, 0xFA, 
-0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x01, 0x90, 0x82, 0x4B, 0xE0, 0x75, 0xF0, 0x02, 0xA4, 0x24, 0x43, 
-0xF9, 0x74, 0x82, 0x35, 0xF0, 0x8B, 0x13, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x02, 0xD0, 0x01, 
-0xD0, 0x03, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x4B, 0xE0, 0x04, 0xF0, 0x90, 0x82, 0x4D, 0xE0, 0x04, 
-0xF0, 0x80, 0x9F, 0x90, 0x82, 0x5C, 0xE0, 0xFF, 0x90, 0x82, 0x4C, 0xE0, 0x2F, 0xF0, 0x21, 0xC0, 
-0xE4, 0x90, 0x82, 0x50, 0xF0, 0x90, 0x82, 0x50, 0xE0, 0xC3, 0x94, 0x40, 0x40, 0x02, 0xA1, 0x2D, 
-0xE0, 0xFF, 0x24, 0x5F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0x90, 0x82, 0x52, 0xF0, 
-0xE0, 0xFE, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFD, 0x90, 0x82, 0x51, 0xF0, 0xEE, 0x54, 0x0F, 0xFE, 
-0xA3, 0xF0, 0x74, 0x60, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0x90, 0x82, 0x53, 
-0xF0, 0xFC, 0xEE, 0xFE, 0xEC, 0xFB, 0xEB, 0xFF, 0x90, 0x82, 0x58, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
-0xED, 0x12, 0x45, 0x1E, 0x6B, 0x09, 0x00, 0x6B, 0x40, 0x01, 0x6B, 0xF1, 0x02, 0x6D, 0x1E, 0x03, 
-0x6C, 0x0C, 0x04, 0x6C, 0x2D, 0x05, 0x6C, 0x2D, 0x06, 0x6C, 0x2D, 0x07, 0x6C, 0x2D, 0x08, 0x6C, 
-0xB1, 0x09, 0x6C, 0xE7, 0x0A, 0x00, 0x00, 0x6D, 0x2D, 0x90, 0x82, 0x50, 0xE0, 0xFD, 0x24, 0x62, 
-0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x61, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 
-0x82, 0xF5, 0x83, 0xE0, 0xFD, 0xED, 0xFF, 0x90, 0x82, 0x5A, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 
-0x90, 0x82, 0x53, 0xE0, 0xFF, 0x12, 0x2F, 0x96, 0x90, 0x82, 0x4E, 0x74, 0x02, 0xF0, 0xA1, 0x1E, 
-0x90, 0x82, 0x50, 0xE0, 0x24, 0x62, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 
-0xFC, 0xFD, 0xFE, 0x78, 0x08, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 
-0x90, 0x82, 0x50, 0xE0, 0x24, 0x61, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 
-0xFC, 0xFD, 0xFE, 0x12, 0x44, 0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 
-0x50, 0xE0, 0x24, 0x63, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 
-0xFE, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 
-0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x82, 0x50, 0xE0, 0x24, 0x64, 0xF5, 
-0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x18, 0x12, 0x20, 
-0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0x90, 0x82, 0x54, 0x12, 
-0x20, 0xCE, 0x90, 0x82, 0x54, 0x12, 0x44, 0xCF, 0x90, 0x85, 0x96, 0x12, 0x20, 0xCE, 0x90, 0x82, 
-0x58, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x2E, 0xE4, 0x90, 0x82, 0x4E, 0x74, 0x04, 0xF0, 0xA1, 
-0x1E, 0x90, 0x82, 0x53, 0xE0, 0xFD, 0x90, 0x82, 0x50, 0xE0, 0x24, 0x61, 0xF5, 0x82, 0xE4, 0x34, 
-0x82, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFF, 0x12, 0x30, 0xC7, 0x80, 0x19, 0x90, 0x82, 0x53, 0xE0, 
-0xFD, 0x90, 0x82, 0x50, 0xE0, 0x24, 0x61, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFB, 
-0xE4, 0xFF, 0x12, 0x30, 0x6A, 0x90, 0x82, 0x4E, 0x74, 0x01, 0xF0, 0xA1, 0x1E, 0x90, 0x82, 0x4E, 
-0x74, 0x02, 0xF0, 0x90, 0x82, 0x50, 0xE0, 0x24, 0x62, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 
-0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x08, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 
-0x06, 0xAB, 0x07, 0x90, 0x82, 0x50, 0xE0, 0x24, 0x61, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 
-0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x12, 0x44, 0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 
-0x07, 0x90, 0x82, 0x52, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 
-0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0x90, 0x82, 0x54, 0x12, 0x20, 0xCE, 
-0x90, 0x82, 0x51, 0xE0, 0x24, 0xFB, 0xFF, 0xC0, 0x07, 0x90, 0x82, 0x54, 0x12, 0x44, 0xCF, 0x90, 
-0x82, 0xDD, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x53, 0xE0, 0xFD, 0xD0, 0x07, 0x12, 0x5C, 0x32, 0x80, 
-0x6D, 0x90, 0x82, 0x4E, 0x74, 0x01, 0xF0, 0x90, 0x82, 0x50, 0xE0, 0x24, 0x61, 0xF9, 0xE4, 0x34, 
-0x82, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x01, 0x7B, 0xFE, 0x7A, 0x80, 0x79, 
-0x33, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x53, 0xE0, 0xFF, 0x90, 0x82, 0x52, 0xE0, 0xFD, 0xE4, 0x90, 
-0x82, 0xA2, 0xF0, 0x7B, 0x04, 0x80, 0x34, 0x90, 0x82, 0x4E, 0x74, 0x04, 0xF0, 0x90, 0x82, 0x50, 
-0xE0, 0x24, 0x61, 0xF9, 0xE4, 0x34, 0x82, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 
-0x04, 0x7B, 0xFE, 0x7A, 0x80, 0x79, 0x33, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x53, 0xE0, 0xFF, 0x90, 
-0x82, 0x52, 0xE0, 0xFD, 0xE4, 0x90, 0x82, 0xA2, 0xF0, 0x7B, 0x06, 0x12, 0x67, 0xE7, 0x90, 0x82, 
-0x4E, 0xE0, 0x24, 0x02, 0xFF, 0x90, 0x82, 0x50, 0xE0, 0x2F, 0xF0, 0x41, 0x95, 0x22, 0x90, 0x83, 
-0x03, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x43, 0x27, 0x90, 0x80, 0x3C, 0xE0, 0xFF, 0x90, 0x83, 0x03, 
-0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x80, 0x3C, 0xF0, 0x22, 0x90, 0x82, 0xB3, 0x74, 0x12, 0xF0, 0x90, 
-0x82, 0xC1, 0x74, 0x05, 0xF0, 0x90, 0x82, 0xB5, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 
-0x90, 0x82, 0xB1, 0xE0, 0x90, 0x82, 0xB8, 0xF0, 0x90, 0x82, 0xB2, 0xE0, 0x90, 0x82, 0xB9, 0xF0, 
-0x7B, 0x01, 0x7A, 0x82, 0x79, 0xB3, 0xB1, 0x7C, 0x7F, 0x04, 0x80, 0xB2, 0xD3, 0x10, 0xAF, 0x01, 
-0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x31, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 
-0xEF, 0x14, 0xFF, 0x90, 0x81, 0x32, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 
-0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x35, 0xC0, 0x01, 0x90, 0x81, 
-0x32, 0xE0, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x9B, 0xF9, 0x74, 0x80, 0x35, 0xF0, 0xA8, 0x01, 0xFC, 
-0x7D, 0x01, 0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x44, 0x79, 0x90, 0x81, 0x32, 0xE0, 0x04, 
-0xF0, 0xE0, 0x7F, 0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x81, 0x32, 
-0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0xA8, 0x7F, 0xF5, 0x7E, 0x00, 
-0x12, 0x2B, 0x27, 0xBF, 0x01, 0x06, 0x90, 0x82, 0xA8, 0xE0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 
-0x79, 0xA8, 0x7F, 0xF6, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0xA8, 0xE0, 
-0x90, 0x82, 0xAA, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0xA8, 0x7F, 0xF4, 0x7E, 0x00, 0x12, 0x2B, 
-0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0xA8, 0xE0, 0x90, 0x82, 0xAB, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 
-0x79, 0xA8, 0x7F, 0xF3, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0xA8, 0xE0, 
-0x90, 0x82, 0xAC, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0xA8, 0x7F, 0xF2, 0x7E, 0x00, 0x12, 0x2B, 
-0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0xA8, 0xE0, 0x90, 0x82, 0xAD, 0xF0, 0x90, 0x82, 0xA9, 0xE0, 
-0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 0x82, 0xB1, 0xF0, 0x90, 0x82, 0xAD, 
-0xE0, 0x90, 0x82, 0xB2, 0xF0, 0xA1, 0x49, 0x90, 0x83, 0x04, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x43, 
-0x27, 0x90, 0x80, 0x3D, 0xE0, 0xFF, 0x90, 0x83, 0x04, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x80, 0x3D, 
-0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xF5, 0x52, 0x12, 0x1F, 0xA4, 0x25, 0x52, 0x90, 0x80, 0x42, 
-0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x25, 0x52, 0x90, 0x80, 0x43, 0xF0, 0x90, 0x00, 0x02, 
-0x12, 0x1F, 0xBD, 0x25, 0x52, 0x90, 0x80, 0x44, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0x25, 
-0x52, 0x90, 0x80, 0x45, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0x25, 0x52, 0x90, 0x80, 0x46, 
-0xF0, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0x25, 0x52, 0x90, 0x80, 0x47, 0xF0, 0x90, 0x00, 0x06, 
-0x12, 0x1F, 0xBD, 0x25, 0x52, 0x90, 0x80, 0x48, 0xF0, 0x22, 0x90, 0x82, 0xA8, 0x12, 0x45, 0x15, 
-0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x7F, 0x90, 0x81, 0x80, 0xF0, 0xEF, 0xC4, 0x13, 0x13, 0x13, 0x54, 
-0x01, 0xA3, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 
-0x90, 0x81, 0x7E, 0xE0, 0x54, 0xF0, 0x4E, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0x54, 0x01, 
-0x25, 0xE0, 0xFE, 0x90, 0x81, 0x7C, 0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 
-0xF0, 0xFF, 0x90, 0x81, 0x7E, 0xE0, 0x54, 0x0F, 0x4F, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 
-0x90, 0x81, 0x7F, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x1F, 0xBD, 0x30, 0xE0, 0x5E, 0xC3, 0x13, 0x54, 
-0x07, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x81, 0x92, 0x50, 0x04, 0xEF, 0xF0, 0x80, 0x2E, 0x74, 0x03, 
-0xF0, 0x90, 0x82, 0xA8, 0x12, 0x45, 0x0C, 0xE9, 0x24, 0x06, 0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x1F, 
-0xA4, 0xFF, 0x74, 0x03, 0x24, 0xFD, 0xFE, 0xEF, 0xC4, 0x54, 0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 
-0xED, 0x2E, 0x54, 0x0F, 0xFE, 0xC4, 0x54, 0xF0, 0x4F, 0x12, 0x1F, 0xEA, 0x90, 0x82, 0xA8, 0x12, 
-0x45, 0x0C, 0x90, 0x00, 0x06, 0x12, 0x1F, 0xBD, 0xC4, 0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 
-0x81, 0x88, 0x50, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 0x90, 0x82, 0xA8, 0x12, 0x45, 
-0x0C, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0xFD, 0x7F, 0x02, 0x12, 0x4B, 0x09, 0x90, 0x82, 0xA8, 
-0x12, 0x45, 0x0C, 0x12, 0x76, 0x4D, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0xF0, 
-0x90, 0x81, 0x80, 0xE0, 0x90, 0x01, 0xBA, 0xF0, 0x90, 0x81, 0x82, 0xE0, 0x90, 0x01, 0xBB, 0xF0, 
-0x90, 0x81, 0x7E, 0xE0, 0x54, 0x0F, 0x90, 0x01, 0xBE, 0xF0, 0x22, 0x90, 0x00, 0x02, 0x12, 0x1F, 
-0xBD, 0xFF, 0x30, 0xE0, 0x26, 0x12, 0x1F, 0xA4, 0x90, 0x82, 0x1F, 0xF0, 0x90, 0x00, 0x01, 0x12, 
-0x1F, 0xBD, 0x90, 0x82, 0x20, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0x4F, 0xF0, 
-0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0x90, 0x82, 0x22, 0xF0, 0x22, 0x90, 0x82, 0x1F, 0x74, 0x03, 
-0xF0, 0xA3, 0x74, 0x05, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 0x28, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 
-0x22, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x82, 0x26, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 
-0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 
-0x04, 0x25, 0xE0, 0xFD, 0xEF, 0x54, 0xF7, 0x4D, 0x90, 0x82, 0x26, 0xF0, 0x90, 0x00, 0x01, 0x12, 
-0x1F, 0xBD, 0xFF, 0x90, 0x05, 0x54, 0xE0, 0xC3, 0x9F, 0x90, 0x82, 0x27, 0xF0, 0xEE, 0x20, 0xE0, 
-0x09, 0x12, 0x5D, 0x56, 0xE4, 0xFD, 0xFF, 0x12, 0x48, 0xC2, 0x90, 0x82, 0x26, 0xE0, 0xC3, 0x13, 
-0x30, 0xE0, 0x19, 0x90, 0x81, 0x80, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x81, 0x82, 0xF0, 0x90, 0x81, 
-0x7D, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x05, 0x58, 0x74, 0x05, 0xF0, 0x22, 0xE4, 0x90, 0x81, 0x80, 
-0xF0, 0x90, 0x81, 0x82, 0x74, 0x0C, 0xF0, 0x90, 0x81, 0x7C, 0xE0, 0x54, 0xFE, 0xF0, 0xA3, 0xE0, 
-0x54, 0xFB, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 0x90, 0x82, 0x28, 0xE0, 0x54, 0xFE, 
-0x4F, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x82, 0x29, 0xF0, 0x90, 0x00, 0x02, 0x12, 
-0x1F, 0xBD, 0x90, 0x82, 0x2A, 0xF0, 0x90, 0x82, 0x29, 0xE0, 0x90, 0x82, 0x2B, 0xF0, 0x90, 0x82, 
-0x28, 0xE0, 0x54, 0x01, 0xFF, 0x02, 0x55, 0x33, 0x12, 0x1F, 0xA4, 0x90, 0x82, 0x2D, 0xF0, 0x90, 
-0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x82, 0x2E, 0xF0, 0x22, 0x90, 0x00, 0xF1, 0xE0, 0x54, 0xF0, 
-0xC4, 0x54, 0x0F, 0xFF, 0x22, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9C, 0x74, 
-0x7E, 0xF0, 0xA3, 0x74, 0x92, 0xF0, 0xA3, 0x74, 0xA0, 0xF0, 0xA3, 0x74, 0x24, 0xF0, 0x90, 0x01, 
-0x9B, 0x74, 0x49, 0xF0, 0x90, 0x01, 0x9A, 0x74, 0xE0, 0xF0, 0x90, 0x01, 0x99, 0xE4, 0xF0, 0x90, 
-0x01, 0x98, 0x04, 0xF0, 0x22, 0xE4, 0x90, 0x82, 0x37, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x98, 0xE0, 
-0x7F, 0x00, 0x30, 0xE4, 0x02, 0x7F, 0x01, 0xEF, 0x64, 0x01, 0x60, 0x45, 0xC3, 0x90, 0x82, 0x38, 
-0xE0, 0x94, 0x88, 0x90, 0x82, 0x37, 0xE0, 0x94, 0x13, 0x40, 0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 
-0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0xFD, 0xF0, 0x80, 0x27, 0x90, 0x82, 0x37, 0xE4, 0x75, 0xF0, 
-0x01, 0x12, 0x44, 0x9F, 0x7F, 0x14, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0xD3, 0x90, 0x82, 0x38, 0xE0, 
-0x94, 0x32, 0x90, 0x82, 0x37, 0xE0, 0x94, 0x00, 0x40, 0xB2, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 
-0xAB, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x3D, 0xF5, 0x41, 
-0xA3, 0xE0, 0x55, 0x3E, 0xF5, 0x42, 0xA3, 0xE0, 0x55, 0x3F, 0xF5, 0x43, 0xA3, 0xE0, 0x55, 0x40, 
-0xF5, 0x44, 0x90, 0x01, 0x34, 0xE5, 0x41, 0xF0, 0xA3, 0xE5, 0x42, 0xF0, 0xA3, 0xE5, 0x43, 0xF0, 
-0xA3, 0xE5, 0x44, 0xF0, 0x22, 0x90, 0x01, 0x3C, 0xE0, 0x55, 0x45, 0xF5, 0x49, 0xA3, 0xE0, 0x55, 
-0x46, 0xF5, 0x4A, 0xA3, 0xE0, 0x55, 0x47, 0xF5, 0x4B, 0xA3, 0xE0, 0x55, 0x48, 0xF5, 0x4C, 0x90, 
-0x01, 0x3C, 0xE5, 0x49, 0xF0, 0xA3, 0xE5, 0x4A, 0xF0, 0xA3, 0xE5, 0x4B, 0xF0, 0xA3, 0xE5, 0x4C, 
-0xF0, 0x53, 0x91, 0xDF, 0x22, 0x90, 0x82, 0x2E, 0xE0, 0x60, 0x0F, 0xE4, 0xF0, 0x90, 0x05, 0x53, 
-0xE0, 0x44, 0x02, 0xF0, 0x90, 0x05, 0xFC, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x77, 0xE0, 0x30, 0xE0, 
-0x11, 0xA3, 0x74, 0x01, 0xF0, 0x90, 0x81, 0x77, 0xE0, 0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x03, 0x12, 
-0x5F, 0x66, 0x51, 0x48, 0x90, 0x82, 0x26, 0xE0, 0x30, 0xE0, 0x1C, 0xE4, 0xFD, 0xFF, 0x12, 0x48, 
-0xC2, 0x12, 0x5D, 0x56, 0x90, 0x82, 0x26, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x03, 0x12, 0x4B, 0x05, 
-0x90, 0x82, 0x26, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE4, 0xF5, 0x4E, 0x90, 0x81, 0x80, 0xE0, 0x70, 
-0x02, 0x61, 0x06, 0x90, 0x81, 0x36, 0xE0, 0x64, 0x01, 0x60, 0x02, 0x61, 0x06, 0x90, 0x81, 0x7C, 
-0xE0, 0x30, 0xE0, 0x1D, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 
-0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x81, 0xB5, 0xEE, 0xF0, 0xA3, 0xEF, 
-0xF0, 0x90, 0x81, 0x7E, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 
-0x70, 0x1E, 0x90, 0x81, 0x87, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x81, 0x89, 0xE0, 
-0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 0x81, 0x86, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x4E, 0x01, 
-0x90, 0x81, 0x77, 0xE0, 0x30, 0xE0, 0x12, 0x90, 0x81, 0x7B, 0xE0, 0xB4, 0x02, 0x03, 0xE4, 0xF5, 
-0x4E, 0x12, 0x47, 0xD4, 0xEF, 0x70, 0x02, 0xF5, 0x4E, 0xE5, 0x4E, 0x60, 0x39, 0x90, 0x81, 0x84, 
-0xE0, 0x44, 0x10, 0xF0, 0x90, 0x81, 0x89, 0xE0, 0x60, 0x03, 0xB4, 0x01, 0x09, 0xE4, 0xF5, 0x1D, 
-0x90, 0x81, 0x89, 0xE0, 0x80, 0x0D, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x89, 0xE0, 0x75, 0xF0, 0x03, 
-0xA4, 0x24, 0xFE, 0xFF, 0x90, 0x81, 0x88, 0xE0, 0x2F, 0x12, 0x64, 0x2F, 0x90, 0x81, 0x83, 0xE0, 
-0x20, 0xE2, 0x03, 0x12, 0x48, 0xCD, 0x22, 0x90, 0x81, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x26, 0x90, 
-0x81, 0x80, 0xE0, 0x60, 0x20, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 
-0x90, 0x81, 0x7C, 0xE0, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x84, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0x07, 
-0x70, 0x03, 0x12, 0x47, 0x9F, 0x22, 0x90, 0x81, 0x80, 0xE0, 0x70, 0x07, 0x90, 0x81, 0x77, 0xE0, 
-0x30, 0xE0, 0x12, 0x90, 0x81, 0x77, 0xE0, 0x30, 0xE0, 0x08, 0x12, 0x47, 0xD4, 0xBF, 0x01, 0x05, 
-0x80, 0x04, 0x12, 0x4C, 0x88, 0x22, 0x90, 0x81, 0x80, 0xE0, 0x64, 0x02, 0x60, 0x14, 0x90, 0x81, 
-0x7E, 0xE0, 0x54, 0x0F, 0x60, 0x0C, 0x12, 0x57, 0xA3, 0xEF, 0x70, 0x06, 0xFD, 0x7F, 0x0C, 0x12, 
-0x48, 0xD1, 0x22, 0x90, 0x81, 0x77, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x0F, 
-0x90, 0x81, 0x7B, 0xE0, 0x64, 0x02, 0x60, 0x07, 0x7D, 0x01, 0x7F, 0x02, 0x12, 0x48, 0xD1, 0x90, 
-0x81, 0x7B, 0xE0, 0x64, 0x02, 0x60, 0x02, 0x71, 0x56, 0x22, 0x90, 0x81, 0x77, 0xE0, 0xFF, 0x30, 
-0xE0, 0x3E, 0x90, 0x81, 0x7B, 0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x81, 0x7A, 
-0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x24, 0xEF, 0xC3, 0x13, 0x30, 
-0xE0, 0x03, 0x02, 0x5F, 0x66, 0x71, 0x73, 0x90, 0x81, 0x7B, 0xE0, 0xB4, 0x08, 0x06, 0xE4, 0xFD, 
-0x7F, 0x0C, 0x80, 0x09, 0x90, 0x81, 0x7B, 0xE0, 0x70, 0x06, 0xFD, 0x7F, 0x04, 0x12, 0x48, 0xD1, 
-0x22, 0x90, 0x81, 0x80, 0xE0, 0x60, 0x13, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x02, 0x80, 0x0B, 
-0x90, 0x81, 0x7C, 0xE0, 0x54, 0xF7, 0xF0, 0x12, 0x47, 0x9F, 0x22, 0x90, 0x81, 0x7C, 0xE0, 0x13, 
-0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 0x90, 0x06, 0x92, 0x74, 
-0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0xF5, 0x1D, 0x90, 0x82, 0x21, 0xE0, 0xC3, 
-0x13, 0x54, 0x7F, 0xF5, 0x1E, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x12, 0x64, 0x38, 0x90, 
-0x81, 0x7C, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x91, 0xAA, 0x90, 0x82, 0x33, 0xEF, 0xF0, 0x30, 0xE0, 
-0x05, 0x7D, 0x01, 0xE4, 0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x4B, 0x09, 0x90, 0x82, 0x33, 0xE0, 
-0x30, 0xE6, 0x11, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 
-0x2F, 0x74, 0x80, 0xF0, 0x90, 0x81, 0x7C, 0xE0, 0x30, 0xE0, 0x25, 0x90, 0x81, 0xB7, 0xE0, 0x24, 
-0x04, 0xFF, 0x90, 0x81, 0x92, 0xE0, 0xFE, 0xC3, 0xEF, 0x9E, 0xFF, 0x90, 0x81, 0x95, 0xF0, 0x90, 
-0x81, 0x8B, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x04, 0xEC, 0xE0, 0x54, 0xDD, 0xF0, 0x80, 0x10, 
-0x90, 0x81, 0x8B, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x90, 0x04, 0xEC, 0xE0, 0x44, 0x22, 0xF0, 
-0x90, 0x81, 0x8B, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0xE4, 0x90, 0x82, 0x34, 0xF0, 0xA3, 
-0xF0, 0xA3, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0x90, 0x82, 0x34, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 
-0x90, 0x82, 0x34, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x82, 0x36, 0xE0, 0x94, 0x64, 
-0x90, 0x82, 0x35, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 
-0x82, 0x34, 0xE0, 0xFF, 0x22, 0x90, 0x82, 0x35, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x44, 0x9F, 0x80, 
-0xC2, 0x90, 0x82, 0x2D, 0xE0, 0x60, 0x0F, 0xE4, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x01, 0xF0, 
-0x90, 0x05, 0xFD, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x81, 0x77, 0xE0, 0xFF, 0x30, 0xE0, 0x3F, 0x90, 
-0x81, 0x7B, 0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x81, 0x7A, 0xE0, 0x7D, 0x00, 
-0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x25, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x03, 0x02, 
-0x5F, 0x66, 0xB1, 0x4F, 0x90, 0x81, 0x7B, 0xE0, 0xB4, 0x0C, 0x06, 0xE4, 0xFD, 0x7F, 0x08, 0x80, 
-0x0A, 0x90, 0x81, 0x7B, 0xE0, 0xB4, 0x04, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x48, 0xD1, 0x22, 0x90, 
-0x01, 0x57, 0xE0, 0x60, 0x48, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x7C, 
-0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x0C, 0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x84, 
-0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x81, 0x89, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x84, 0xE0, 0x54, 
-0xEF, 0xF0, 0x90, 0x82, 0x1F, 0xE0, 0xFF, 0x90, 0x81, 0x89, 0xE0, 0xD3, 0x9F, 0x40, 0x0E, 0x90, 
-0x81, 0x36, 0xE0, 0xB4, 0x01, 0x07, 0x90, 0x81, 0x7D, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x90, 0x81, 
-0x7C, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x27, 0xEF, 0x54, 0xBF, 0xF0, 0x90, 
-0x04, 0xE0, 0xE0, 0x90, 0x81, 0x7D, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x10, 0xE0, 
-0x54, 0xFE, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x12, 
-0x47, 0x9F, 0x22, 0x90, 0x81, 0x7C, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x30, 0xE0, 
-0x2C, 0xEF, 0x54, 0x7F, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x81, 0x7D, 0x30, 0xE1, 0x06, 0xE0, 
-0x44, 0x02, 0xF0, 0x80, 0x0F, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 
-0x01, 0xB8, 0x04, 0xF0, 0x90, 0x81, 0x80, 0xE0, 0x60, 0x03, 0x12, 0x47, 0x9F, 0x22, 0xD3, 0x10, 
-0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x1A, 0x90, 0x05, 0x22, 0xE0, 0x54, 
-0x90, 0x60, 0x07, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x08, 0xF0, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE1, 
-0xE4, 0x7F, 0x00, 0x80, 0x02, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x81, 0x7C, 0xE0, 
-0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x81, 0x89, 0xF0, 0x90, 0x81, 0x84, 0xF0, 0x22, 0x90, 0x82, 0xAB, 
-0x12, 0x45, 0x15, 0xD1, 0x3C, 0x90, 0x81, 0x80, 0xE0, 0xFF, 0x12, 0x55, 0x8C, 0x90, 0x81, 0x80, 
-0xE0, 0x60, 0x18, 0x90, 0x82, 0xAB, 0x12, 0x45, 0x0C, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x54, 
-0x0F, 0xFF, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0xFD, 0xD1, 0x7C, 0x22, 0xEF, 0x24, 0xFE, 0x60, 
-0x0B, 0x04, 0x70, 0x27, 0x90, 0x81, 0x86, 0x74, 0x02, 0xF0, 0x80, 0x16, 0xED, 0x70, 0x0A, 0x90, 
-0x82, 0x22, 0xE0, 0x90, 0x81, 0x86, 0xF0, 0x80, 0x05, 0x90, 0x81, 0x86, 0xED, 0xF0, 0x90, 0x81, 
-0x86, 0xE0, 0xA3, 0xF0, 0x90, 0x81, 0x7D, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x12, 0x57, 0xA3, 0xEF, 
-0x64, 0x01, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x80, 0x67, 0x90, 0x81, 0x84, 0xE0, 
-0xFF, 0x54, 0x03, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x56, 0x90, 0x81, 0x82, 
-0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x44, 0xEF, 
-0x30, 0xE2, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x80, 0x38, 0x90, 0x81, 0x84, 0xE0, 0x30, 
-0xE4, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 0x29, 0x90, 0x81, 0x7D, 0xE0, 0x13, 0x13, 
-0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x20, 0xF0, 0x80, 0x16, 0x90, 0x82, 0x25, 
-0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 
-0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x7D, 0x2E, 0x7F, 0x6F, 
-0x12, 0x48, 0xC2, 0x7D, 0x02, 0x7F, 0x01, 0x12, 0x4B, 0x09, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 
-0xF0, 0x90, 0x81, 0x7B, 0x74, 0x02, 0xF0, 0x22, 0xE4, 0x90, 0x82, 0x33, 0xF0, 0x90, 0x81, 0x80, 
-0xE0, 0x60, 0x4F, 0x90, 0x81, 0x36, 0xE0, 0x64, 0x01, 0x70, 0x47, 0x90, 0x82, 0x33, 0x04, 0xF0, 
-0xE4, 0x90, 0x81, 0x87, 0xF0, 0x90, 0x81, 0x77, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x81, 0x7B, 0xE0, 
-0xB4, 0x02, 0x05, 0xE4, 0x90, 0x82, 0x33, 0xF0, 0x12, 0x47, 0xD4, 0xEF, 0x70, 0x04, 0x90, 0x82, 
-0x33, 0xF0, 0x90, 0x82, 0x33, 0xE0, 0x60, 0x1A, 0x90, 0x81, 0x84, 0xE0, 0x44, 0x10, 0xF0, 0xE4, 
-0xF5, 0x1D, 0x90, 0x81, 0x88, 0x12, 0x64, 0x2E, 0x90, 0x81, 0x83, 0xE0, 0x20, 0xE2, 0x03, 0x12, 
-0x48, 0xCD, 0x22, 0xE4, 0xFF, 0x74, 0x98, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE4, 
-0xF0, 0x0F, 0xEF, 0xB4, 0x19, 0xEF, 0xE4, 0x90, 0x81, 0x93, 0xF0, 0x90, 0x81, 0x97, 0xF0, 0x90, 
-0x81, 0x91, 0xF0, 0x22, 0x90, 0x81, 0x7C, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x11, 
-0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x84, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0x07, 0x70, 0x2E, 0x80, 
-0x29, 0x90, 0x81, 0x89, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x84, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0x82, 
-0x1F, 0xE0, 0xFF, 0x90, 0x81, 0x89, 0xE0, 0xD3, 0x9F, 0x40, 0x0F, 0x90, 0x81, 0x36, 0xE0, 0xB4, 
-0x01, 0x0B, 0x90, 0x81, 0x7D, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x12, 0x47, 0x9F, 0x22, 0x22, 0x90, 
-0x83, 0x02, 0xE0, 0x60, 0x4C, 0x90, 0x82, 0x26, 0xE0, 0x30, 0xE0, 0x45, 0x90, 0x83, 0x01, 0xE0, 
-0x04, 0xF0, 0xE0, 0xD3, 0x94, 0xC8, 0x40, 0x39, 0x90, 0x81, 0x8A, 0x74, 0xD0, 0xF0, 0x90, 0x00, 
-0xCC, 0xE0, 0x44, 0x04, 0xFD, 0x7F, 0xCC, 0x12, 0x32, 0x1E, 0x90, 0x00, 0x02, 0xE0, 0x54, 0xFB, 
-0xFD, 0x7F, 0x02, 0x12, 0x32, 0x1E, 0xE4, 0x90, 0x83, 0x02, 0xF0, 0x90, 0x82, 0x26, 0xE0, 0xC3, 
-0x13, 0x30, 0xE0, 0x0D, 0x90, 0x81, 0x7C, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x81, 0x8A, 0x74, 0xD0, 
-0xF0, 0x22, 0x7D, 0x1F, 0x7F, 0x6F, 0x12, 0x48, 0xC2, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 
-0x90, 0x81, 0x7A, 0x74, 0x04, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 
-0x7A, 0xE0, 0x90, 0x83, 0x08, 0xF0, 0x6F, 0x70, 0x02, 0x21, 0x87, 0xEF, 0x14, 0x60, 0x46, 0x14, 
-0x60, 0x73, 0x14, 0x70, 0x02, 0x21, 0x32, 0x14, 0x70, 0x02, 0x21, 0x5E, 0x24, 0x04, 0x60, 0x02, 
-0x21, 0x87, 0x90, 0x83, 0x08, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0x5F, 0xD4, 0x21, 0x87, 0x90, 0x83, 
-0x08, 0xE0, 0xB4, 0x02, 0x05, 0x12, 0x5F, 0xC5, 0x21, 0x87, 0x90, 0x83, 0x08, 0xE0, 0xB4, 0x03, 
-0x05, 0x12, 0x5F, 0xD9, 0x21, 0x87, 0x90, 0x83, 0x08, 0xE0, 0x64, 0x01, 0x60, 0x02, 0x21, 0x87, 
-0x12, 0x5F, 0xC7, 0x21, 0x87, 0x90, 0x83, 0x08, 0xE0, 0xB4, 0x04, 0x04, 0x31, 0xBF, 0x21, 0x87, 
-0x90, 0x83, 0x08, 0xE0, 0xB4, 0x02, 0x05, 0x12, 0x5F, 0xB6, 0x21, 0x87, 0x90, 0x83, 0x08, 0xE0, 
-0xB4, 0x03, 0x05, 0x12, 0x5F, 0xDD, 0x21, 0x87, 0x90, 0x83, 0x08, 0xE0, 0x60, 0x02, 0x21, 0x87, 
-0x12, 0x4F, 0xF3, 0x21, 0x87, 0x90, 0x83, 0x08, 0xE0, 0xB4, 0x04, 0x04, 0x31, 0xAC, 0x80, 0x77, 
-0x90, 0x83, 0x08, 0xE0, 0xB4, 0x01, 0x05, 0x12, 0x4F, 0xE3, 0x80, 0x6B, 0x90, 0x83, 0x08, 0xE0, 
-0xB4, 0x03, 0x04, 0x31, 0xA2, 0x80, 0x60, 0x90, 0x83, 0x08, 0xE0, 0x70, 0x5A, 0x12, 0x4F, 0xEF, 
-0x80, 0x55, 0x90, 0x83, 0x08, 0xE0, 0xB4, 0x04, 0x04, 0x31, 0xD3, 0x80, 0x4A, 0x90, 0x83, 0x08, 
-0xE0, 0xB4, 0x01, 0x04, 0x31, 0x94, 0x80, 0x3F, 0x90, 0x83, 0x08, 0xE0, 0xB4, 0x02, 0x05, 0x12, 
-0x5F, 0x9E, 0x80, 0x33, 0x90, 0x83, 0x08, 0xE0, 0x70, 0x2D, 0x31, 0x91, 0x80, 0x29, 0x90, 0x83, 
-0x08, 0xE0, 0xB4, 0x03, 0x04, 0x31, 0xE8, 0x80, 0x1E, 0x90, 0x83, 0x08, 0xE0, 0xB4, 0x01, 0x04, 
-0x11, 0x62, 0x80, 0x13, 0x90, 0x83, 0x08, 0xE0, 0xB4, 0x02, 0x04, 0x31, 0xFD, 0x80, 0x08, 0x90, 
-0x83, 0x08, 0xE0, 0x70, 0x02, 0x31, 0x8C, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x4F, 0xF3, 0x01, 
-0x62, 0x12, 0x4F, 0xF3, 0x7D, 0x21, 0x7F, 0xFF, 0x12, 0x48, 0xC2, 0x90, 0x81, 0x7A, 0x74, 0x03, 
-0xF0, 0x22, 0x12, 0x4C, 0xC8, 0x90, 0x81, 0x7A, 0x74, 0x02, 0xF0, 0x22, 0x90, 0x05, 0x27, 0xE0, 
-0x44, 0x40, 0xF0, 0x7D, 0x23, 0x12, 0x4C, 0xC4, 0x90, 0x81, 0x7A, 0x74, 0x02, 0xF0, 0x22, 0xE4, 
-0xFD, 0xFF, 0x12, 0x48, 0xC2, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x81, 0x7A, 0x74, 
-0x01, 0xF0, 0x22, 0x7D, 0x22, 0x7F, 0xFF, 0x12, 0x48, 0xC2, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 
-0xF0, 0x90, 0x81, 0x7A, 0x74, 0x03, 0xF0, 0x22, 0x7D, 0x25, 0x7F, 0x6F, 0x12, 0x48, 0xC2, 0x90, 
-0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x81, 0x7A, 0x74, 0x04, 0xF0, 0x22, 0x12, 0x5D, 0x56, 
-0x7D, 0x24, 0x7F, 0x6F, 0x12, 0x48, 0xC2, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x81, 
-0x7A, 0x74, 0x04, 0xF0, 0x22, 0x90, 0x80, 0x44, 0xE0, 0xFF, 0x90, 0x82, 0xE2, 0xE0, 0xFB, 0x7D, 
-0x01, 0x12, 0x4F, 0x3A, 0x90, 0x82, 0xE3, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x82, 
-0xE1, 0xE0, 0xFF, 0x12, 0x4E, 0xEF, 0x90, 0x82, 0xE3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x04, 
-0x80, 0xE0, 0x54, 0x0F, 0xFD, 0xAC, 0x07, 0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
-0x83, 0xE0, 0x44, 0x01, 0xF0, 0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
-0x54, 0xFB, 0xF0, 0xAC, 0x07, 0x74, 0x16, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
-0x44, 0xFA, 0xF0, 0x74, 0x15, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x1F, 
-0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x0F, 
-0xF0, 0x90, 0x04, 0x53, 0xE4, 0xF0, 0x90, 0x04, 0x52, 0xF0, 0x90, 0x04, 0x51, 0x74, 0xFF, 0xF0, 
-0x90, 0x04, 0x50, 0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
-0xE0, 0x54, 0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xED, 
-0xF0, 0x22, 0xE4, 0xFE, 0xEF, 0xC3, 0x13, 0xFD, 0xEF, 0x30, 0xE0, 0x02, 0x7E, 0x80, 0x90, 0xFD, 
-0x10, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0xC6, 0xBE,  
-};
-u4Byte ArrayLength_MP_8188E_FW_NIC_T = 15096;
-
-
-void
-ODM_ReadFirmware_MP_8188E_FW_NIC_T(
-     IN   PDM_ODM_T    pDM_Odm,
-     OUT  u1Byte       *pFirmware,
-     OUT  u4Byte       *pFirmwareSize
-)
-{
-#if(DM_ODM_SUPPORT_TYPE & (ODM_CE))
-	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8188E_FW_NIC_T;
-#else
-	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8188E_FW_NIC_T, ArrayLength_MP_8188E_FW_NIC_T);
-#endif
-	*pFirmwareSize = ArrayLength_MP_8188E_FW_NIC_T;
-}
-
-
-u1Byte Array_MP_8188E_FW_WoWLAN_S[] = {
-0xE2, 0x88, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x02, 0x22, 0x10, 0x14, 0x26, 0x43, 0x02, 0x00, 
-0xCD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x02, 0x4E, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x02, 0x4F, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x02, 0x4F, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x57, 0xF3, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0xE7, 0x09, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 0x46, 0xE7, 0x09, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x3E, 
-0x88, 0x82, 0x8C, 0x83, 0xE7, 0x09, 0xF0, 0xA3, 0xDF, 0xFA, 0x80, 0x32, 0xE3, 0x09, 0xF6, 0x08, 
-0xDF, 0xFA, 0x80, 0x78, 0xE3, 0x09, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x70, 0x88, 0x82, 0x8C, 0x83, 
-0xE3, 0x09, 0xF0, 0xA3, 0xDF, 0xFA, 0x80, 0x64, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xA3, 0xF6, 0x08, 
-0xDF, 0xFA, 0x80, 0x58, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xA3, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x4C, 
-0x80, 0xD2, 0x80, 0xFA, 0x80, 0xC6, 0x80, 0xD4, 0x80, 0x69, 0x80, 0xF2, 0x80, 0x33, 0x80, 0x10, 
-0x80, 0xA6, 0x80, 0xEA, 0x80, 0x9A, 0x80, 0xA8, 0x80, 0xDA, 0x80, 0xE2, 0x80, 0xCA, 0x80, 0x33, 
-0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 
-0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 
-0x0D, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xA3, 0xF6, 0x08, 0xDF, 0xF9, 0xEC, 0xFA, 0xA9, 0xF0, 
-0xED, 0xFB, 0x22, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 
-0xC5, 0x83, 0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xEA, 0xDE, 
-0xE8, 0x80, 0xDB, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xA3, 0xF2, 0x08, 0xDF, 0xF9, 0x80, 0xCC, 
-0x88, 0xF0, 0xEF, 0x60, 0x01, 0x0E, 0x4E, 0x60, 0xC3, 0x88, 0xF0, 0xED, 0x24, 0x02, 0xB4, 0x04, 
-0x00, 0x50, 0xB9, 0xF5, 0x82, 0xEB, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0xAF, 0x23, 0x23, 0x45, 
-0x82, 0x23, 0x90, 0x48, 0x50, 0x73, 0xBB, 0x01, 0x09, 0x89, 0x82, 0x8A, 0x83, 0xF8, 0xE0, 0x28, 
-0xF0, 0x22, 0x50, 0x03, 0x27, 0xF7, 0x22, 0xBB, 0xFE, 0x05, 0xF8, 0xE3, 0x28, 0xF3, 0x22, 0x8A, 
-0x83, 0x89, 0x82, 0xF8, 0xE4, 0x93, 0x28, 0x22, 0xBB, 0x01, 0x0F, 0xF8, 0xE5, 0x82, 0x29, 0xF5, 
-0x82, 0xE5, 0x83, 0x3A, 0xF5, 0x83, 0xE0, 0x28, 0xF0, 0x22, 0x50, 0x09, 0xC5, 0x82, 0x29, 0xF8, 
-0xE5, 0x82, 0x26, 0xF6, 0x22, 0xBB, 0xFE, 0x09, 0xC5, 0x82, 0x29, 0xF8, 0xE2, 0x25, 0x82, 0xF2, 
-0x22, 0xF8, 0xEA, 0x25, 0x83, 0xF5, 0x83, 0xE9, 0x93, 0x28, 0x22, 0xC5, 0xF0, 0xF8, 0xA3, 0xE0, 
-0x28, 0xF0, 0xC5, 0xF0, 0xF8, 0xE5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 0x83, 0xE0, 0x38, 0xF0, 
-0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 0xEC, 0x48, 0xFC, 0x22, 0xE0, 0xFC, 
-0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xA4, 0x25, 0x82, 0xF5, 0x82, 0xE5, 
-0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 
-0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xBB, 0x01, 0x1A, 0x89, 0x82, 0x8A, 0x83, 0xD0, 
-0xF0, 0xD0, 0xE0, 0xF8, 0xD0, 0xE0, 0xF9, 0xD0, 0xE0, 0xFA, 0xD0, 0xE0, 0xFB, 0xE8, 0xC0, 0xE0, 
-0xC0, 0xF0, 0x02, 0x49, 0x8F, 0x50, 0x16, 0xE9, 0xF8, 0xD0, 0x83, 0xD0, 0x82, 0xD0, 0xE0, 0xF9, 
-0xD0, 0xE0, 0xFA, 0xD0, 0xE0, 0xFB, 0xC0, 0x82, 0xC0, 0x83, 0x02, 0x4C, 0x3C, 0xBB, 0xFE, 0x16, 
-0xE9, 0xF8, 0xD0, 0x83, 0xD0, 0x82, 0xD0, 0xE0, 0xF9, 0xD0, 0xE0, 0xFA, 0xD0, 0xE0, 0xFB, 0xC0, 
-0x82, 0xC0, 0x83, 0x02, 0x4C, 0x45, 0x22, 0xBB, 0x01, 0x20, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE5, 
-0x83, 0x3A, 0xF5, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0xF8, 0xD0, 0xE0, 0xF9, 0xD0, 0xE0, 0xFA, 0xD0, 
-0xE0, 0xFB, 0xE8, 0xC0, 0xE0, 0xC0, 0xF0, 0x02, 0x49, 0x8F, 0x50, 0x18, 0xE9, 0x25, 0x82, 0xF8, 
-0xD0, 0x83, 0xD0, 0x82, 0xD0, 0xE0, 0xF9, 0xD0, 0xE0, 0xFA, 0xD0, 0xE0, 0xFB, 0xC0, 0x82, 0xC0, 
-0x83, 0x02, 0x4C, 0x3C, 0xBB, 0xFE, 0x18, 0xE9, 0x25, 0x82, 0xF8, 0xD0, 0x83, 0xD0, 0x82, 0xD0, 
-0xE0, 0xF9, 0xD0, 0xE0, 0xFA, 0xD0, 0xE0, 0xFB, 0xC0, 0x82, 0xC0, 0x83, 0x02, 0x4C, 0x45, 0x22, 
-0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 
-0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 
-0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0xE3, 0xF5, 0xF0, 0x09, 0xE2, 0x08, 0xB5, 0xF0, 0x6B, 0xDF, 
-0xF5, 0x80, 0x67, 0xE3, 0xF5, 0xF0, 0x09, 0xE6, 0x08, 0xB5, 0xF0, 0x5E, 0xDF, 0xF5, 0x80, 0x5A, 
-0x87, 0xF0, 0x09, 0xE6, 0x08, 0xB5, 0xF0, 0x52, 0xDF, 0xF6, 0x80, 0x4E, 0x87, 0xF0, 0x09, 0xE2, 
-0x08, 0xB5, 0xF0, 0x46, 0xDF, 0xF6, 0x80, 0x42, 0x88, 0x82, 0x8C, 0x83, 0x87, 0xF0, 0x09, 0xE0, 
-0xA3, 0xB5, 0xF0, 0x36, 0xDF, 0xF6, 0x80, 0x32, 0x88, 0x82, 0x8C, 0x83, 0x87, 0xF0, 0x09, 0xE4, 
-0x93, 0xA3, 0xB5, 0xF0, 0x25, 0xDF, 0xF5, 0x80, 0x21, 0x88, 0x82, 0x8C, 0x83, 0xE3, 0xF5, 0xF0, 
-0x09, 0xE0, 0xA3, 0xB5, 0xF0, 0x14, 0xDF, 0xF5, 0x80, 0x10, 0x88, 0x82, 0x8C, 0x83, 0xE3, 0xF5, 
-0xF0, 0x09, 0xE4, 0x93, 0xA3, 0xB5, 0xF0, 0x02, 0xDF, 0xF4, 0x02, 0x4B, 0x95, 0x80, 0x87, 0x80, 
-0xE9, 0x80, 0x90, 0x80, 0xD4, 0x80, 0x3E, 0x80, 0x15, 0x80, 0x6E, 0x80, 0x7E, 0x80, 0x9D, 0x80, 
-0xB7, 0x80, 0x8D, 0x80, 0xA3, 0x80, 0x51, 0x80, 0x74, 0x80, 0x3C, 0x02, 0x4B, 0xA1, 0x89, 0x82, 
-0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 
-0xCC, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0x76, 0xDF, 
-0xE3, 0xDE, 0xE1, 0x80, 0x70, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 0xE2, 0x08, 
-0xB5, 0xF0, 0x62, 0xDF, 0xF4, 0x80, 0x5E, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 0xE6, 
-0x08, 0xB5, 0xF0, 0x51, 0xDF, 0xF5, 0x80, 0x4D, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 
-0xE2, 0x08, 0xB5, 0xF0, 0x40, 0xDF, 0xF5, 0x80, 0x3C, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xF5, 
-0xF0, 0xA3, 0xE6, 0x08, 0xB5, 0xF0, 0x2E, 0xDF, 0xF4, 0x80, 0x2A, 0x80, 0x02, 0x80, 0x57, 0x89, 
-0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 
-0x83, 0xCC, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0x06, 0xDF, 
-0xE4, 0xDE, 0xE2, 0x80, 0x00, 0x7F, 0xFF, 0xB5, 0xF0, 0x02, 0x0F, 0x22, 0x40, 0x02, 0x7F, 0x01, 
-0x22, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE0, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 
-0xC5, 0x83, 0xCC, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0xD5, 
-0xDF, 0xE5, 0xDE, 0xE3, 0x80, 0xCF, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE0, 0xF5, 0xF0, 0xA3, 
-0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 
-0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0xAF, 0xDF, 0xE4, 0xDE, 0xE2, 0x80, 0xA9, 0x88, 0xF0, 0xEF, 0x60, 
-0x01, 0x0E, 0x4E, 0x60, 0xAB, 0xED, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0x98, 0xF5, 0x82, 0xEB, 
-0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0x8E, 0x23, 0x23, 0x45, 0x82, 0x23, 0x90, 0x4A, 0xDD, 0x73, 
-0xEF, 0x4E, 0x60, 0x12, 0xEF, 0x60, 0x01, 0x0E, 0xED, 0xBB, 0x01, 0x0B, 0x89, 0x82, 0x8A, 0x83, 
-0xF0, 0xA3, 0xDF, 0xFC, 0xDE, 0xFA, 0x22, 0x89, 0xF0, 0x50, 0x07, 0xF7, 0x09, 0xDF, 0xFC, 0xA9, 
-0xF0, 0x22, 0xBB, 0xFE, 0xFC, 0xF3, 0x09, 0xDF, 0xFC, 0xA9, 0xF0, 0x22, 0xEB, 0xF6, 0x08, 0xEA, 
-0xF6, 0x08, 0xE9, 0xF6, 0x22, 0xEB, 0xF2, 0x08, 0xEA, 0xF2, 0x08, 0xE9, 0xF2, 0x22, 0xC2, 0xAF, 
-0x80, 0xFE, 0x32, 0x12, 0x4C, 0x52, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 0xC2, 0x8C, 
-0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 0xEC, 0x24, 
-0x8B, 0xF8, 0xE6, 0xBC, 0x04, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 0x40, 0xCE, 
-0x79, 0x05, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 0x03, 0x44, 
-0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 0x23, 0x24, 
-0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x05, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 0xE4, 0xF2, 
-0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x8A, 0x25, 0x0C, 0xF8, 0xE6, 0xFD, 
-0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x04, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 0x6D, 0x60, 
-0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 0x0C, 0x24, 
-0x8B, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x04, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 0xF8, 0xE5, 
-0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x8A, 0xC8, 0xF6, 
-0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 0xE6, 0x30, 
-0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 0x08, 0x54, 
-0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x8A, 0xA6, 0x81, 0x74, 
-0x04, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x05, 0xE4, 0x78, 0x80, 0xF6, 0x08, 
-0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x4F, 0xA3, 0x74, 0x01, 0x93, 0xC0, 0xE0, 
-0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 0x8C, 0xD2, 
-0xAF, 0x22, 0x04, 0xEF, 0xD3, 0x94, 0x04, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 0x2F, 0x2F, 
-0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 0x0C, 0xEE, 
-0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x8A, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 0xBE, 0x04, 
-0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 0x09, 0x80, 
-0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 0xEE, 0xD3, 
-0x9F, 0x40, 0x22, 0x74, 0x8A, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 0xA9, 0x81, 
-0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 0xF7, 0x19, 
-0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x8A, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 0x04, 0x90, 
-0x4F, 0xA3, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x04, 
-0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 0xC2, 0xAF, 
-0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x8A, 0x2F, 0xF8, 0xE6, 
-0xF5, 0x81, 0x02, 0x4C, 0x9B, 0x50, 0x2E, 0x74, 0x8B, 0x2F, 0xF8, 0xE6, 0xBF, 0x04, 0x02, 0x74, 
-0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x8A, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 0x60, 0x08, 
-0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 0x0C, 0xB5, 
-0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x8B, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 0x0F, 0x74, 
-0x8A, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 0x81, 0xED, 
-0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 0x07, 0xDE, 
-0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x04, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 
-0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 0xD2, 0xE2, 
-0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x4C, 0x9A, 0x8F, 0xF0, 0xE4, 0xFF, 
-0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 0xE6, 0x60, 
-0x0B, 0x2D, 0xF6, 0x60, 0x30, 0x50, 0x2E, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 0x60, 0x25, 
-0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x23, 0x0E, 0x30, 0xE2, 0x0C, 
-0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x12, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x13, 0x54, 0xEC, 0x4E, 0xF6, 
-0xD2, 0xAF, 0x02, 0x4C, 0x9B, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 0xC2, 0xAF, 0x56, 0xC6, 
-0xD2, 0xAF, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0x02, 0x4F, 0x35, 0x02, 0x4D, 0x2B, 0xE4, 0x93, 0xA3, 
-0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 
-0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 
-0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 
-0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x4F, 0x7A, 0xE4, 0x7E, 0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 
-0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 
-0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 
-0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 
-0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 0x00, 0x41, 0x83, 0xA7, 0x00, 0x41, 
-0x83, 0xA8, 0x00, 0x41, 0x83, 0xB3, 0x00, 0x44, 0x83, 0x4F, 0x00, 0x50, 0xF2, 0x01, 0x44, 0x83, 
-0x53, 0x00, 0x0F, 0xAC, 0x01, 0x44, 0x83, 0x57, 0x00, 0x0F, 0xAC, 0x03, 0x44, 0x83, 0x5B, 0x00, 
-0x0F, 0xAC, 0x04, 0x59, 0x92, 0x60, 0xED, 0x61, 0x0B, 0x62, 0x4F, 0x63, 0x74, 0xC0, 0xE0, 0xC0, 
-0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 
-0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xAD, 0xF0, 
-0x74, 0x4F, 0xA3, 0xF0, 0x12, 0x6C, 0x7D, 0x74, 0xAD, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x4F, 
-0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 
-0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xC0, 0xE0, 0xC0, 
-0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 
-0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xFD, 0xF0, 
-0x74, 0x4F, 0xA3, 0xF0, 0x12, 0x6C, 0xB7, 0xE5, 0x41, 0x30, 0xE3, 0x02, 0xF1, 0xE6, 0xE5, 0x41, 
-0x30, 0xE4, 0x05, 0x7F, 0x02, 0x12, 0x4E, 0x75, 0xE5, 0x43, 0x30, 0xE1, 0x02, 0x11, 0x65, 0x74, 
-0xFD, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x4F, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 
-0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 
-0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x51, 0x2B, 0x90, 0x81, 0xFB, 0xE0, 0x30, 0xE0, 0x2D, 0x90, 0x80, 
-0xA3, 0xE0, 0xB4, 0x01, 0x26, 0x90, 0x83, 0xB3, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x0A, 0x0B, 0x90, 
-0x81, 0xFD, 0xE0, 0x04, 0xF0, 0xE4, 0x90, 0x83, 0xB3, 0xF0, 0x90, 0x81, 0xFD, 0xE0, 0xFF, 0x90, 
-0x81, 0xFC, 0xE0, 0xB5, 0x07, 0x05, 0xE4, 0xA3, 0xF0, 0x11, 0x9C, 0x22, 0xE4, 0xFF, 0xD3, 0x10, 
-0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 0x4E, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x19, 0x90, 0x05, 0x22, 
-0xE0, 0xF5, 0x51, 0x74, 0xFF, 0xF0, 0x12, 0x6F, 0x85, 0xBF, 0x01, 0x02, 0x31, 0x20, 0x90, 0x05, 
-0x22, 0xE5, 0x51, 0xF0, 0x80, 0x02, 0x31, 0x20, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x7F, 0x01, 
-0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
-0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x1D, 0x74, 0x21, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
-0xE0, 0x44, 0x10, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 
-0x80, 0xF0, 0x22, 0x74, 0x21, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xEF, 
-0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x40, 0xF0, 0x22, 
-0x90, 0x80, 0x04, 0xE0, 0xFF, 0x7D, 0x01, 0x31, 0xC1, 0x8E, 0x4F, 0x8F, 0x50, 0xAD, 0x50, 0xAC, 
-0x4F, 0xAF, 0x4E, 0x11, 0xD5, 0xAF, 0x50, 0xAE, 0x4F, 0x90, 0x04, 0x80, 0xE0, 0x54, 0x0F, 0xFD, 
-0xAC, 0x07, 0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x01, 0xF0, 
-0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xFB, 0xF0, 0xAC, 0x07, 
-0x74, 0x16, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x15, 
-0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 
-0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x0F, 0xF0, 0x90, 0x04, 0x53, 0xE4, 
-0xF0, 0x90, 0x04, 0x52, 0xF0, 0x90, 0x04, 0x51, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0x50, 0x74, 0xFD, 
-0xF0, 0x74, 0x14, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0x4D, 0xFD, 
-0x74, 0x14, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xED, 0xF0, 0x22, 0xE0, 0xFF, 0x7D, 
-0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0xAA, 0xED, 0xF0, 0x90, 0x83, 0xA9, 
-0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x12, 0x5D, 0x8E, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0x83, 0xA9, 0xE0, 
-0x90, 0x04, 0x25, 0xF0, 0x90, 0x83, 0xAA, 0xE0, 0x60, 0x0E, 0x74, 0x0F, 0x2F, 0xF5, 0x82, 0xE4, 
-0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x08, 0x2F, 0xF5, 0x82, 0xE4, 
-0x34, 0xFC, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x09, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
-0xE0, 0x54, 0xF0, 0xF0, 0x74, 0x21, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 
-0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x81, 0xFE, 0xE0, 0x30, 
-0xE0, 0x2C, 0x90, 0x82, 0x01, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x90, 0x81, 0xFF, 0xE0, 0xB5, 0x07, 
-0x1D, 0x90, 0x06, 0x92, 0xE0, 0x54, 0x1C, 0x70, 0x0A, 0x11, 0x9C, 0x90, 0x82, 0x02, 0xE0, 0x04, 
-0xF0, 0x80, 0x06, 0x90, 0x06, 0x92, 0x74, 0x1C, 0xF0, 0xE4, 0x90, 0x82, 0x01, 0xF0, 0x22, 0x90, 
-0x81, 0xFE, 0xE0, 0x30, 0xE0, 0x47, 0x90, 0x82, 0x02, 0xE0, 0xFD, 0x60, 0x40, 0x74, 0x01, 0x7E, 
-0x00, 0xA8, 0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x04, 
-0xE0, 0xE0, 0xFB, 0xEF, 0x5B, 0x60, 0x06, 0xE4, 0x90, 0x82, 0x02, 0xF0, 0x22, 0x90, 0x82, 0x00, 
-0xE0, 0xD3, 0x9D, 0x50, 0x10, 0x90, 0x01, 0xC7, 0x74, 0x10, 0xF0, 0x51, 0xAE, 0x90, 0x81, 0xFE, 
-0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x11, 0x9C, 0x90, 0x82, 0x02, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x80, 
-0x01, 0xE0, 0x64, 0x02, 0x70, 0x4B, 0x90, 0x80, 0xE6, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 
-0x01, 0x30, 0xE0, 0x08, 0x90, 0x01, 0x4D, 0xE0, 0x64, 0x80, 0xF0, 0x22, 0x90, 0x80, 0xE5, 0xE0, 
-0xFE, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x13, 0xEF, 0x54, 0x7F, 0xFF, 0xE4, 0xFD, 0xD1, 0xD0, 
-0x90, 0x80, 0xE6, 0xE0, 0x54, 0x7F, 0xFF, 0x7D, 0x01, 0x80, 0x14, 0x90, 0x80, 0xE6, 0xE0, 0x54, 
-0x7F, 0xFF, 0x7D, 0x01, 0xD1, 0xD0, 0x90, 0x80, 0xE6, 0xE0, 0x54, 0x7F, 0xFF, 0xE4, 0xFD, 0xC1, 
-0xD0, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
-0x90, 0x82, 0x37, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xE4, 0x90, 0x82, 0x42, 0xF0, 
-0xA3, 0x74, 0x08, 0xF0, 0xA3, 0xF0, 0x90, 0x06, 0x31, 0xE0, 0x54, 0xEF, 0x44, 0x08, 0xF0, 0x90, 
-0x82, 0x37, 0xA3, 0xE0, 0x24, 0x00, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0x12, 0x5D, 0xF8, 
-0x90, 0x82, 0x37, 0xA3, 0xE0, 0x2F, 0xFF, 0x90, 0x82, 0x44, 0xE0, 0x2F, 0x90, 0x82, 0x46, 0xF0, 
-0x7E, 0x00, 0x7F, 0x83, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x55, 0x12, 0x4C, 0x10, 0x90, 
-0x82, 0x46, 0xE0, 0x24, 0x00, 0xF9, 0xE4, 0x34, 0xFB, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 
-0x75, 0x16, 0x01, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x55, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x46, 0xE0, 
-0x24, 0x01, 0xF9, 0xE4, 0x34, 0xFB, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x01, 
-0x7B, 0x01, 0x7A, 0x81, 0x79, 0x56, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x46, 0xE0, 0x24, 0x02, 0xF9, 
-0xE4, 0x34, 0xFB, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x02, 0x7B, 0x01, 0x7A, 
-0x81, 0x79, 0x57, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x46, 0xE0, 0x24, 0x04, 0xF9, 0xE4, 0x34, 0xFB, 
-0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x01, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x59, 
-0x12, 0x2B, 0xED, 0x90, 0x82, 0x46, 0xE0, 0x24, 0x05, 0xF9, 0xE4, 0x34, 0xFB, 0x75, 0x13, 0x01, 
-0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x02, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x5A, 0x12, 0x2B, 0xED, 
-0x90, 0x82, 0x46, 0xE0, 0x24, 0x07, 0xF9, 0xE4, 0x34, 0xFB, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 
-0x15, 0x75, 0x16, 0x02, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x5C, 0x12, 0x2B, 0xED, 0xE4, 0x90, 0x82, 
-0x45, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0xFF, 0xC3, 0x94, 0x08, 0x50, 0x32, 0xA3, 0xE0, 0x24, 0x09, 
-0xD1, 0x9A, 0x7E, 0x00, 0x90, 0x82, 0x40, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 0x00, 0xF5, 0x82, 
-0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 0x45, 0xE0, 0x24, 0x5E, 0xF5, 0x82, 0xE4, 
-0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0x04, 0xF0, 0x80, 0xC4, 0xE4, 0x90, 
-0x82, 0x45, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0xFF, 0xC3, 0x94, 0x20, 0x50, 0x32, 0xA3, 0xE0, 0x24, 
-0x11, 0xD1, 0x9A, 0x7E, 0x00, 0x90, 0x82, 0x40, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 0x00, 0xF5, 
-0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 0x45, 0xE0, 0x24, 0x66, 0xF5, 0x82, 
-0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0x04, 0xF0, 0x80, 0xC4, 0xE4, 
-0x90, 0x82, 0x45, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0xFF, 0xC3, 0x94, 0x10, 0x50, 0x32, 0xA3, 0xE0, 
-0x24, 0x31, 0xD1, 0x9A, 0x7E, 0x00, 0x90, 0x82, 0x40, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 0x00, 
-0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 0x45, 0xE0, 0x24, 0x86, 0xF5, 
-0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0x04, 0xF0, 0x80, 0xC4, 
-0xE4, 0x90, 0x82, 0x45, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0xFF, 0xC3, 0x94, 0x08, 0x50, 0x32, 0xA3, 
-0xE0, 0x24, 0x41, 0xD1, 0x9A, 0x7E, 0x00, 0x90, 0x82, 0x40, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 
-0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 0x45, 0xE0, 0x24, 0x96, 
-0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0x04, 0xF0, 0x80, 
-0xC4, 0xE4, 0x90, 0x82, 0x45, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0xFF, 0xC3, 0x94, 0x08, 0x50, 0x32, 
-0xA3, 0xE0, 0x24, 0x49, 0xD1, 0x9A, 0x7E, 0x00, 0x90, 0x82, 0x40, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
-0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 0x45, 0xE0, 0x24, 
-0x9E, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0x04, 0xF0, 
-0x80, 0xC4, 0xE4, 0x90, 0x82, 0x45, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0xFF, 0xC3, 0x94, 0x10, 0x50, 
-0x32, 0xA3, 0xE0, 0x24, 0x51, 0xD1, 0x9A, 0x7E, 0x00, 0x90, 0x82, 0x40, 0xEE, 0xF0, 0xA3, 0xEF, 
-0xF0, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 0x45, 0xE0, 
-0x24, 0xA6, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0x04, 
-0xF0, 0x80, 0xC4, 0xE4, 0x90, 0x82, 0x45, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0xFF, 0xC3, 0x94, 0x02, 
-0x50, 0x32, 0xA3, 0xE0, 0x24, 0x61, 0xD1, 0x9A, 0x7E, 0x00, 0x90, 0x82, 0x40, 0xEE, 0xF0, 0xA3, 
-0xEF, 0xF0, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 0x45, 
-0xE0, 0x24, 0xB6, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0x45, 0xE0, 
-0x04, 0xF0, 0x80, 0xC4, 0xE4, 0x90, 0x82, 0x45, 0xF0, 0x90, 0x82, 0x45, 0xE0, 0xFF, 0xC3, 0x94, 
-0x20, 0x50, 0x32, 0xA3, 0xE0, 0x24, 0x63, 0xD1, 0x9A, 0x7E, 0x00, 0x90, 0x82, 0x40, 0xEE, 0xF0, 
-0xA3, 0xEF, 0xF0, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 
-0x45, 0xE0, 0x24, 0xB8, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0x45, 
-0xE0, 0x04, 0xF0, 0x80, 0xC4, 0x90, 0x81, 0x57, 0xE0, 0xFC, 0xA3, 0xE0, 0xFA, 0xEC, 0xFF, 0xEA, 
-0xFE, 0x90, 0x82, 0x3C, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x81, 0xB6, 0xE0, 0xFE, 0xA3, 0xE0, 
-0xFD, 0xED, 0xFF, 0x90, 0x82, 0x3E, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x81, 0x5A, 0xE0, 0xFE, 
-0xA3, 0xE0, 0xFD, 0xED, 0xFF, 0x90, 0x82, 0x3A, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x30, 0xE3, 0x04, 
-0x51, 0xAE, 0x80, 0x3F, 0x90, 0x82, 0x3A, 0xA3, 0xE0, 0xFF, 0x7C, 0x00, 0x54, 0x07, 0xFD, 0x64, 
-0x01, 0x60, 0x05, 0xED, 0x64, 0x02, 0x70, 0x2B, 0xED, 0x64, 0x02, 0x4C, 0x70, 0x25, 0xEF, 0x54, 
-0x30, 0xFF, 0xE4, 0xC4, 0xF8, 0x54, 0xF0, 0xC8, 0xEF, 0xC4, 0x54, 0x0F, 0x48, 0x90, 0x81, 0xEE, 
-0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xE4, 0xFD, 0x12, 0x77, 0xFE, 0x90, 0x06, 0x31, 0xE0, 0x54, 0xF7, 
-0x44, 0x10, 0xF0, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xFD, 0xE4, 0x33, 0xFC, 0x7E, 0x00, 
-0xED, 0x2F, 0xFF, 0xEE, 0x3C, 0xFE, 0x90, 0x82, 0x39, 0xE0, 0xFD, 0xC3, 0xEE, 0x94, 0x01, 0x40, 
-0x1E, 0x90, 0xFD, 0x11, 0xE0, 0xB5, 0x05, 0x14, 0x90, 0x01, 0x17, 0xE0, 0xB5, 0x05, 0x07, 0x90, 
-0xFD, 0x11, 0xE4, 0xF0, 0x80, 0x06, 0xED, 0x04, 0x90, 0xFD, 0x11, 0xF0, 0xE4, 0x2F, 0xFF, 0x22, 
-0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0xAE, 0xED, 0xF0, 0x90, 0x83, 0xAD, 0xEF, 
-0xF0, 0xD3, 0x94, 0x07, 0x50, 0x70, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 
-0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x47, 0xE0, 0x5F, 0xFD, 0x7F, 0x47, 0x12, 0x32, 0x1E, 
-0x90, 0x83, 0xAD, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
-0xFF, 0x90, 0x00, 0x46, 0xE0, 0x4F, 0xFD, 0x7F, 0x46, 0x12, 0x32, 0x1E, 0x90, 0x83, 0xAE, 0xE0, 
-0x60, 0x18, 0x90, 0x83, 0xAD, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 
-0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x45, 0xE0, 0x4F, 0x80, 0x17, 0x90, 0x83, 0xAD, 0xE0, 0xFF, 0x74, 
-0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x45, 0xE0, 
-0x5F, 0xFD, 0x7F, 0x45, 0x80, 0x7E, 0x90, 0x83, 0xAD, 0xE0, 0x24, 0xF8, 0xF0, 0xE0, 0x24, 0x04, 
-0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 
-0x43, 0xE0, 0x5F, 0xFD, 0x7F, 0x43, 0x12, 0x32, 0x1E, 0x90, 0x83, 0xAD, 0xE0, 0xFF, 0x74, 0x01, 
-0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x43, 0xE0, 0x4F, 0xFD, 
-0x7F, 0x43, 0x12, 0x32, 0x1E, 0x90, 0x83, 0xAE, 0xE0, 0x60, 0x1D, 0x90, 0x83, 0xAD, 0xE0, 0x24, 
-0x04, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 
-0x42, 0xE0, 0x4F, 0xFD, 0x7F, 0x42, 0x80, 0x1C, 0x90, 0x83, 0xAD, 0xE0, 0x24, 0x04, 0xFF, 0x74, 
-0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x42, 0xE0, 
-0x5F, 0xFD, 0x7F, 0x42, 0x12, 0x32, 0x1E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x01, 0x67, 0xE4, 0xFF, 
-0x41, 0x5F, 0x7F, 0x01, 0x41, 0x5F, 0x90, 0x80, 0xE4, 0xE0, 0x30, 0xE0, 0x05, 0x7F, 0x04, 0x12, 
-0x4E, 0x75, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 
-0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 
-0x90, 0x01, 0xC4, 0x74, 0xF3, 0xF0, 0x74, 0x57, 0xA3, 0xF0, 0x11, 0x64, 0xE5, 0x4C, 0x30, 0xE1, 
-0x05, 0x7F, 0x03, 0x12, 0x4E, 0x75, 0xE5, 0x4C, 0x30, 0xE4, 0x03, 0x12, 0x57, 0xDC, 0xE5, 0x4C, 
-0x30, 0xE5, 0x03, 0x12, 0x57, 0xDE, 0xE5, 0x4C, 0x30, 0xE6, 0x03, 0x12, 0x57, 0xE2, 0x74, 0xF3, 
-0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x57, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 
-0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 
-0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x01, 0x3C, 0xE0, 0x55, 0x45, 0xF5, 0x49, 0xA3, 0xE0, 0x55, 0x46, 
-0xF5, 0x4A, 0xA3, 0xE0, 0x55, 0x47, 0xF5, 0x4B, 0xA3, 0xE0, 0x55, 0x48, 0xF5, 0x4C, 0x90, 0x01, 
-0x3C, 0xE5, 0x49, 0xF0, 0xA3, 0xE5, 0x4A, 0xF0, 0xA3, 0xE5, 0x4B, 0xF0, 0xA3, 0xE5, 0x4C, 0xF0, 
-0x53, 0x91, 0xDF, 0x22, 0x90, 0x01, 0xC8, 0xE4, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 
-0x82, 0x79, 0x03, 0x7F, 0xFF, 0xFE, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x09, 0x90, 0x82, 0x03, 0xE0, 
-0x64, 0x03, 0x60, 0x03, 0x22, 0x21, 0x56, 0xE4, 0x90, 0x82, 0x08, 0xF0, 0x90, 0x82, 0x08, 0xE0, 
-0xFF, 0xC3, 0x94, 0x02, 0x40, 0x02, 0x21, 0x91, 0xC3, 0x74, 0xFE, 0x9F, 0xFF, 0xE4, 0x94, 0x00, 
-0xFE, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x04, 0x12, 0x2B, 0x27, 0xEF, 0x64, 0x01, 0x70, 0x77, 0x90, 
-0x82, 0x04, 0xE0, 0xFF, 0x54, 0xC0, 0xFE, 0x60, 0x05, 0xEF, 0x54, 0x0C, 0x70, 0x16, 0x90, 0x82, 
-0x04, 0xE0, 0xFF, 0x54, 0x30, 0x60, 0x67, 0xEF, 0x54, 0x03, 0x60, 0x62, 0x90, 0x82, 0x05, 0x74, 
-0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0x82, 0x05, 0xF0, 0x90, 0x82, 0x05, 0xE0, 0x90, 0x82, 0x04, 
-0x70, 0x16, 0xE0, 0xFF, 0xEE, 0x13, 0x13, 0x54, 0x3F, 0x90, 0x82, 0x06, 0xF0, 0xEF, 0x54, 0x0C, 
-0x13, 0x13, 0x54, 0x3F, 0xA3, 0xF0, 0x80, 0x0D, 0xE0, 0xFE, 0x54, 0x30, 0x90, 0x82, 0x06, 0xF0, 
-0xEE, 0x54, 0x03, 0xA3, 0xF0, 0x90, 0x82, 0x06, 0xE0, 0x64, 0x30, 0x70, 0x54, 0xA3, 0xE0, 0x64, 
-0x02, 0x70, 0x4E, 0x90, 0x00, 0xF5, 0xE0, 0x54, 0x40, 0x90, 0x82, 0x09, 0xF0, 0xE0, 0x70, 0x41, 
-0xA3, 0x74, 0x02, 0xF0, 0x80, 0x10, 0x90, 0x82, 0x0A, 0x74, 0x01, 0xF0, 0x80, 0x08, 0x90, 0x82, 
-0x08, 0xE0, 0x04, 0xF0, 0x01, 0xBC, 0x90, 0x01, 0xC4, 0x74, 0x94, 0xF0, 0x74, 0x58, 0xA3, 0xF0, 
-0x90, 0x82, 0x0A, 0xE0, 0x90, 0x01, 0xC8, 0xF0, 0x90, 0x82, 0x04, 0xE0, 0x90, 0x01, 0xC9, 0xF0, 
-0x90, 0x82, 0x05, 0xE0, 0x90, 0x01, 0xCA, 0xF0, 0xE4, 0xFD, 0x7F, 0x1F, 0x12, 0x32, 0x1E, 0x80, 
-0xD5, 0x22, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x90, 0xFD, 
-0x00, 0xE0, 0x54, 0xBF, 0xF0, 0x11, 0x94, 0xF1, 0x76, 0x12, 0x32, 0x77, 0x12, 0x6B, 0xF7, 0xF1, 
-0x51, 0x7F, 0x01, 0x12, 0x4D, 0x63, 0x7F, 0x02, 0x12, 0x4D, 0x63, 0x7F, 0x03, 0x12, 0x4D, 0x63, 
-0x7F, 0x04, 0x12, 0x4D, 0x63, 0x31, 0xFF, 0x31, 0xE4, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 
-0x7F, 0x80, 0x12, 0x32, 0x1E, 0x75, 0x20, 0xFF, 0xF1, 0x67, 0x12, 0x6C, 0x27, 0xF1, 0x7E, 0xE4, 
-0xFF, 0x02, 0x4D, 0xEC, 0xF1, 0x55, 0xF1, 0x6E, 0x51, 0x42, 0xF1, 0x88, 0x90, 0x81, 0xFE, 0xE0, 
-0x54, 0xFE, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0xA3, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xF1, 
-0xC7, 0x90, 0x80, 0x01, 0xEF, 0xF0, 0x51, 0x11, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x02, 0x2D, 
-0xA7, 0x12, 0x6B, 0x58, 0x12, 0x6B, 0x88, 0x12, 0x6B, 0xB9, 0x12, 0x6B, 0xD8, 0xE4, 0xF5, 0x35, 
-0xF5, 0x36, 0xF5, 0x37, 0xF5, 0x38, 0xAD, 0x35, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xAD, 0x36, 0x7F, 
-0x51, 0x12, 0x32, 0x1E, 0xAD, 0x37, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xAD, 0x38, 0x7F, 0x53, 0x02, 
-0x32, 0x1E, 0x90, 0x80, 0xE4, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x80, 0xE9, 0xE0, 0x54, 0xFE, 0xF0, 
-0x90, 0x06, 0x90, 0xE0, 0x44, 0x20, 0xF0, 0x90, 0x80, 0xE5, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 
-0xF0, 0x54, 0xFB, 0xF0, 0x54, 0xF7, 0xF0, 0x54, 0xEF, 0xF0, 0x54, 0xDF, 0xF0, 0x54, 0xBF, 0xF0, 
-0x54, 0x7F, 0xF0, 0xA3, 0xE0, 0x54, 0x80, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xE0, 0x54, 0xFE, 0xF0, 
-0x90, 0x80, 0xE6, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x80, 0xE8, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0xEF, 
-0x60, 0x58, 0x90, 0x04, 0xEC, 0xE0, 0x54, 0xDD, 0xF0, 0x90, 0x81, 0xF1, 0xE0, 0xFF, 0x60, 0x02, 
-0x71, 0x3D, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xE0, 
-0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x90, 0x80, 0x9F, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x06, 
-0x09, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x05, 0x22, 0x74, 0xFF, 0xF0, 0x71, 0x9C, 0x90, 0x02, 0x86, 
-0xE0, 0x44, 0x04, 0xF0, 0x71, 0x09, 0xF1, 0x4F, 0x91, 0x2A, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0x90, 
-0x01, 0x34, 0x74, 0x08, 0xF0, 0xFD, 0xE4, 0xFF, 0xE1, 0x9A, 0x90, 0x04, 0xEC, 0xE0, 0x44, 0x22, 
-0xF0, 0x7D, 0x08, 0xE4, 0xFF, 0xF1, 0xAF, 0x90, 0x06, 0x90, 0xE4, 0xF0, 0x90, 0x02, 0x86, 0xE0, 
-0x54, 0xFB, 0xF0, 0x71, 0x1A, 0xF1, 0x50, 0x41, 0x42, 0x12, 0x65, 0xC1, 0x90, 0x02, 0x87, 0xE0, 
-0x70, 0xF7, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x02, 0xF0, 0x22, 0x51, 0x57, 0x90, 0x01, 0x3F, 0x74, 
-0x04, 0xF0, 0x90, 0x80, 0x01, 0xE0, 0xFF, 0xB4, 0x01, 0x07, 0x90, 0xFD, 0x00, 0xE0, 0x54, 0xEF, 
-0xF0, 0xEF, 0xB4, 0x01, 0x07, 0x90, 0xFE, 0x10, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0xB1, 0x8E, 0x7E, 
-0x00, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFC, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 
-0x16, 0x08, 0x7B, 0x01, 0x7A, 0x80, 0x79, 0xFB, 0x12, 0x2B, 0xED, 0x90, 0x80, 0xFB, 0xE0, 0x90, 
-0x81, 0x03, 0xF0, 0x90, 0x80, 0xFC, 0xE0, 0x90, 0x81, 0x04, 0xF0, 0x90, 0x80, 0xFD, 0xE0, 0x90, 
-0x81, 0x05, 0xF0, 0x90, 0x80, 0xFE, 0xE0, 0x90, 0x81, 0x06, 0xF0, 0x90, 0x80, 0xFF, 0xE0, 0x90, 
-0x81, 0x07, 0xF0, 0x90, 0x81, 0x00, 0xE0, 0x90, 0x81, 0x08, 0xF0, 0x90, 0x81, 0x01, 0xE0, 0x90, 
-0x81, 0x09, 0xF0, 0x90, 0x81, 0x02, 0xE0, 0x90, 0x81, 0x0A, 0xF0, 0x22, 0x12, 0x6F, 0x85, 0x90, 
-0x85, 0xBB, 0x12, 0x20, 0xDA, 0xCC, 0xF0, 0x00, 0xC0, 0x7F, 0x8C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 
-0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x14, 0x7F, 0x70, 0x7E, 0x0E, 0x12, 0x2E, 
-0xA2, 0x90, 0x83, 0x97, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFD, 0xFF, 0x91, 0x07, 
-0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x83, 0xA3, 0x12, 0x20, 
-0xCE, 0x90, 0x83, 0xA3, 0x12, 0x49, 0x6E, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 0x7C, 0x7E, 
-0x08, 0x12, 0x2E, 0xA2, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 
-0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 
-0xC0, 0x05, 0x90, 0x83, 0x97, 0x12, 0x49, 0x6E, 0x90, 0x83, 0x70, 0x12, 0x20, 0xCE, 0xD0, 0x05, 
-0xD0, 0x07, 0x12, 0x69, 0x30, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 
-0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2D, 
-0x5C, 0xEC, 0x54, 0x7F, 0xFC, 0x90, 0x83, 0x9F, 0x12, 0x20, 0xCE, 0x90, 0x83, 0x9F, 0x12, 0x49, 
-0x6E, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x85, 
-0xBB, 0x12, 0x20, 0xDA, 0xCC, 0xC0, 0x00, 0xC0, 0x7F, 0x8C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 
-0x85, 0xBB, 0x12, 0x20, 0xDA, 0x00, 0xC0, 0x00, 0x14, 0x7F, 0x70, 0x7E, 0x0E, 0x12, 0x2E, 0xA2, 
-0x90, 0x83, 0x97, 0x12, 0x20, 0xDA, 0x00, 0x03, 0x3E, 0x60, 0xE4, 0xFD, 0xFF, 0x91, 0x07, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 
-0x01, 0xFE, 0x90, 0x80, 0xE4, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 
-0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 
-0xFF, 0x90, 0x80, 0xE4, 0xF0, 0xEE, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 0xFF, 0xF0, 0x12, 
-0x1F, 0xA4, 0xFE, 0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x4D, 0xFF, 0x90, 0x80, 0xE4, 0xF0, 0xEE, 
-0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 0xF0, 0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 
-0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x90, 0x80, 0x9F, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
-0x80, 0xE4, 0xE0, 0xC3, 0x13, 0x54, 0x01, 0xFF, 0xB1, 0x49, 0x90, 0x80, 0xE4, 0xE0, 0x13, 0x13, 
-0x54, 0x01, 0xFF, 0xF1, 0x5B, 0x90, 0x80, 0xE4, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x01, 0xFF, 0xB1, 
-0x54, 0x90, 0x80, 0xE4, 0xE0, 0xC4, 0x54, 0x01, 0xFF, 0xF1, 0x61, 0x90, 0x80, 0xE4, 0xE0, 0x54, 
-0x01, 0xFF, 0x51, 0x8F, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x60, 0x07, 0x90, 0x81, 0xF2, 0xE0, 
-0xFF, 0xB1, 0xA2, 0x22, 0xE4, 0xFD, 0xFC, 0xEF, 0x60, 0x33, 0x90, 0x81, 0xF5, 0xE0, 0xFF, 0xB1, 
-0x8E, 0x7C, 0x00, 0xAD, 0x07, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x90, 
-0x82, 0x1A, 0x12, 0x49, 0x8F, 0x90, 0x82, 0x1A, 0x12, 0x49, 0x86, 0x8B, 0x13, 0x8A, 0x14, 0x89, 
-0x15, 0x75, 0x16, 0x4A, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x0B, 0x12, 0x2B, 0xED, 0x22, 0xE4, 0xFE, 
-0xEF, 0xC3, 0x13, 0xFD, 0xEF, 0x30, 0xE0, 0x02, 0x7E, 0x80, 0x90, 0xFD, 0x10, 0xED, 0xF0, 0xAF, 
-0x06, 0x22, 0xB1, 0x8E, 0x7E, 0x00, 0x90, 0x83, 0xB1, 0xB1, 0xEA, 0x90, 0x83, 0xB1, 0xA3, 0xE0, 
-0x2F, 0x24, 0x36, 0xF9, 0xE4, 0x34, 0xFC, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 
-0x04, 0x7B, 0x01, 0x7A, 0x80, 0x79, 0xF6, 0x12, 0x2B, 0xED, 0xE4, 0xFF, 0x74, 0x18, 0x2F, 0xF5, 
-0x82, 0xE4, 0x34, 0x06, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0xEA, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x80, 
-0xF5, 0x83, 0xEE, 0xF0, 0x0F, 0xEF, 0xB4, 0x06, 0xE3, 0x22, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 
-0x20, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xE4, 0x90, 0x83, 0xB4, 0xF0, 0xFF, 0x12, 0x1F, 
-0xA4, 0x30, 0xE7, 0x08, 0x90, 0x83, 0xB4, 0x74, 0x02, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0x83, 0xB4, 
-0xF0, 0x12, 0x6E, 0xF9, 0x90, 0x83, 0xB4, 0xE0, 0x24, 0x18, 0x2F, 0xFF, 0x22, 0x90, 0x82, 0x17, 
-0x12, 0x49, 0x8F, 0xEF, 0x12, 0x4A, 0x40, 0x5E, 0x49, 0x00, 0x5E, 0x52, 0x01, 0x5E, 0x5A, 0x02, 
-0x5E, 0x63, 0x03, 0x5E, 0x6C, 0x04, 0x5E, 0x7C, 0x80, 0x5E, 0x74, 0x81, 0x5E, 0x84, 0x82, 0x5E, 
-0x8D, 0x83, 0x5E, 0x96, 0x84, 0x00, 0x00, 0x5E, 0x9F, 0x90, 0x82, 0x17, 0x12, 0x49, 0x86, 0x02, 
-0x6A, 0xD1, 0x90, 0x82, 0x17, 0x12, 0x49, 0x86, 0x80, 0x79, 0x90, 0x82, 0x17, 0x12, 0x49, 0x86, 
-0x02, 0x6B, 0x19, 0x90, 0x82, 0x17, 0x12, 0x49, 0x86, 0x02, 0x70, 0x53, 0x90, 0x82, 0x17, 0x12, 
-0x49, 0x86, 0x80, 0x33, 0x90, 0x82, 0x17, 0x12, 0x49, 0x86, 0x81, 0xA4, 0x90, 0x82, 0x17, 0x12, 
-0x49, 0x86, 0xE1, 0xE1, 0x90, 0x82, 0x17, 0x12, 0x49, 0x86, 0x02, 0x71, 0xB9, 0x90, 0x82, 0x17, 
-0x12, 0x49, 0x86, 0x02, 0x71, 0xD3, 0x90, 0x82, 0x17, 0x12, 0x49, 0x86, 0x02, 0x72, 0x35, 0x90, 
-0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x31, 0xEC, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 
-0x90, 0x81, 0xFE, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x14, 0x90, 0x00, 
-0x01, 0x12, 0x1F, 0xBD, 0x90, 0x81, 0xFF, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x90, 0x82, 
-0x00, 0xF0, 0x22, 0x90, 0x82, 0x1A, 0x12, 0x49, 0x8F, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFF, 
-0xFE, 0x12, 0x1F, 0xA4, 0xFD, 0xC3, 0x13, 0x30, 0xE0, 0x12, 0x90, 0x82, 0x1A, 0x12, 0x49, 0x86, 
-0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x90, 0x82, 0x1E, 0xF0, 0x80, 0x05, 0x90, 0x82, 0x1E, 0xEF, 
-0xF0, 0x90, 0x82, 0x1D, 0xEE, 0xF0, 0x90, 0x82, 0x1E, 0xE0, 0xFE, 0x90, 0x82, 0x1D, 0xE0, 0xFF, 
-0xD3, 0x9E, 0x50, 0x38, 0x90, 0x82, 0x1A, 0x12, 0x49, 0x86, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFE, 
-0x74, 0xA3, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0xEE, 0xF0, 0x74, 0xA3, 0x2F, 0xF5, 
-0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0xE0, 0x70, 0x04, 0xF1, 0x4E, 0x80, 0x07, 0x90, 0x82, 0x1D, 
-0xE0, 0xFF, 0xF1, 0x4D, 0x90, 0x82, 0x1D, 0xE0, 0x04, 0xF0, 0x80, 0xBA, 0x22, 0x22, 0x22, 0x22, 
-0x22, 0xE4, 0xF5, 0x4D, 0x22, 0xE4, 0x90, 0x80, 0xA3, 0xF0, 0x22, 0x90, 0x82, 0x1A, 0xEF, 0xF0, 
-0x22, 0x90, 0x82, 0x1A, 0xEF, 0xF0, 0x22, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x84, 0x22, 0xE4, 0x90, 
-0x80, 0x9D, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x01, 
-0xE4, 0x74, 0x0C, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x81, 0xFB, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 
-0x7F, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0xE4, 0xA3, 0xF0, 0x22, 0x74, 0x3D, 0x2F, 0xF8, 0xE6, 0x4D, 
-0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x74, 
-0x3D, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 
-0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x20, 0xE7, 0x09, 0xE0, 0x7F, 
-0x01, 0x20, 0xE6, 0x0C, 0x7F, 0x02, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x30, 0xE6, 0x02, 0x7F, 0x03, 
-0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x1F, 0xA4, 0xFC, 0x20, 0xE0, 0x05, 0x71, 
-0x1A, 0x02, 0x60, 0xE8, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x80, 0xE5, 0xE0, 0x54, 
-0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 0x1F, 
-0xA4, 0xFE, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 0xFF, 0x90, 0x80, 0xE5, 0xF0, 0xEE, 0x54, 
-0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x10, 0xFD, 0xEF, 
-0x54, 0xEF, 0x4D, 0xFF, 0x90, 0x80, 0xE5, 0xF0, 0xEE, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 
-0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 0x4D, 0xFF, 0x90, 0x80, 
-0xE5, 0xF0, 0xEE, 0x54, 0x80, 0xFE, 0xEF, 0x54, 0x7F, 0x4E, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 
-0xBD, 0xFD, 0x54, 0x80, 0xFF, 0x90, 0x80, 0xE6, 0xE0, 0x54, 0x7F, 0x4F, 0xF0, 0xEC, 0x13, 0x13, 
-0x54, 0x3F, 0x30, 0xE0, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x04, 0xF0, 0x12, 0x1F, 0xA4, 0x13, 
-0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x08, 0xF0, 0x90, 0x80, 
-0x01, 0xE0, 0x64, 0x02, 0x70, 0x44, 0x90, 0x80, 0xE6, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 
-0x01, 0x20, 0xE0, 0x36, 0xED, 0x54, 0x7F, 0xFE, 0xEF, 0x54, 0x80, 0x4E, 0x90, 0x80, 0xE6, 0xF0, 
-0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x90, 0x80, 0xE7, 0xF0, 0x90, 0x80, 0xE5, 0xE0, 0xC4, 0x13, 
-0x54, 0x07, 0x30, 0xE0, 0x09, 0xA3, 0xE0, 0x54, 0x7F, 0xFF, 0xE4, 0xFD, 0x80, 0x09, 0x90, 0x80, 
-0xE6, 0xE0, 0x54, 0x7F, 0xFF, 0x7D, 0x01, 0x12, 0x56, 0xD0, 0x90, 0x80, 0x01, 0xE0, 0xB4, 0x01, 
-0x07, 0x90, 0xFE, 0x10, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0x90, 0x82, 
-0x0B, 0xF0, 0x90, 0x82, 0x0B, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0xED, 0x90, 0x01, 0xC4, 0xF0, 0x74, 
-0x60, 0xA3, 0xF0, 0x31, 0x0A, 0x12, 0x4C, 0x9B, 0x80, 0xE8, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 
-0x01, 0x12, 0x4E, 0x9C, 0x90, 0x82, 0x0C, 0xEF, 0xF0, 0x60, 0xF0, 0x31, 0x1F, 0x80, 0xEC, 0xD3, 
-0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0x82, 0x0D, 0xF0, 
-0x90, 0x82, 0x0D, 0xE0, 0xFD, 0x70, 0x02, 0x41, 0x4A, 0x90, 0x83, 0xA7, 0xE0, 0xFF, 0x74, 0x01, 
-0x7E, 0x00, 0xA8, 0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 
-0x5D, 0x70, 0x02, 0x41, 0x43, 0x90, 0x83, 0xA7, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xD0, 0x12, 
-0x49, 0x7A, 0xE0, 0x90, 0x82, 0x0E, 0xF0, 0x75, 0x13, 0x01, 0x75, 0x14, 0x82, 0x75, 0x15, 0x0E, 
-0x75, 0x16, 0x01, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x0F, 0x12, 0x2B, 0xED, 0x90, 0x83, 0xA7, 0xE0, 
-0x75, 0xF0, 0x04, 0x90, 0x01, 0xD1, 0x12, 0x49, 0x7A, 0xE0, 0x90, 0x82, 0x10, 0xF0, 0x90, 0x83, 
-0xA7, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xD2, 0x12, 0x49, 0x7A, 0xE0, 0x90, 0x82, 0x11, 0xF0, 
-0x90, 0x83, 0xA7, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xD3, 0x12, 0x49, 0x7A, 0xE0, 0x90, 0x82, 
-0x12, 0xF0, 0x90, 0x83, 0xA7, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xF0, 0x12, 0x49, 0x7A, 0xE0, 
-0x90, 0x82, 0x13, 0xF0, 0x90, 0x83, 0xA7, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xF1, 0x12, 0x49, 
-0x7A, 0xE0, 0x90, 0x82, 0x14, 0xF0, 0x90, 0x83, 0xA7, 0xE0, 0x75, 0xF0, 0x04, 0x90, 0x01, 0xF2, 
-0x12, 0x49, 0x7A, 0xE0, 0x90, 0x82, 0x15, 0xF0, 0x90, 0x83, 0xA7, 0xE0, 0x75, 0xF0, 0x04, 0x90, 
-0x01, 0xF3, 0x12, 0x49, 0x7A, 0xE0, 0x90, 0x82, 0x16, 0xF0, 0x90, 0x82, 0x0D, 0xE0, 0xFF, 0x90, 
-0x83, 0xA7, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 
-0x5F, 0x90, 0x82, 0x0D, 0xF0, 0x90, 0x83, 0xA7, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 
-0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x82, 0x0F, 0xE0, 0xFF, 0x7B, 0x01, 
-0x7A, 0x82, 0x79, 0x10, 0x12, 0x5E, 0x1D, 0x90, 0x83, 0xA7, 0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 
-0xF0, 0x21, 0x30, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 
-0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x4E, 0x9C, 0x90, 0x82, 0x1F, 0xEF, 0xF0, 0x60, 0xF0, 0x51, 
-0x63, 0x80, 0xEC, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 0x90, 0x80, 0x9E, 0xE0, 
-0xFE, 0x90, 0x80, 0x9D, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 
-0x64, 0x01, 0x60, 0x32, 0x90, 0x01, 0xAF, 0xE0, 0x70, 0x13, 0xED, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 
-0x07, 0xF9, 0x74, 0x80, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x51, 0xBB, 0x7F, 0x01, 0xEF, 0x60, 0x16, 
-0x90, 0x80, 0x9D, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 
-0x05, 0xE4, 0x90, 0x80, 0x9D, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
-0xC0, 0xD0, 0x90, 0x82, 0x20, 0x12, 0x49, 0x8F, 0x90, 0x83, 0xA8, 0xE0, 0xFF, 0x04, 0xF0, 0x90, 
-0x00, 0x01, 0xEF, 0x12, 0x1F, 0xFC, 0x7F, 0xAF, 0x7E, 0x01, 0x71, 0x1E, 0xEF, 0x60, 0x3A, 0x90, 
-0x82, 0x20, 0x12, 0x49, 0x86, 0x8B, 0x13, 0x8A, 0x14, 0x89, 0x15, 0x90, 0x00, 0x0E, 0x12, 0x1F, 
-0xBD, 0x24, 0x02, 0xF5, 0x16, 0x7B, 0x01, 0x7A, 0x01, 0x79, 0xA0, 0x12, 0x2B, 0xED, 0x90, 0x82, 
-0x20, 0x12, 0x49, 0x86, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x90, 0x01, 0xAE, 0xF0, 0xA3, 0x74, 
-0xFF, 0xF0, 0x90, 0x01, 0xCB, 0xE0, 0x64, 0x80, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 
-0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0x9B, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 
-0xA3, 0xF0, 0x90, 0x83, 0x9B, 0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 0xE0, 0x60, 0x2D, 
-0xC3, 0x90, 0x83, 0x9E, 0xE0, 0x94, 0xE8, 0x90, 0x83, 0x9D, 0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 
-0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 0x15, 0x90, 0x83, 0x9D, 0xE4, 0x75, 0xF0, 
-0x01, 0x12, 0x49, 0x4B, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x80, 0xC5, 0x7F, 0x01, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x4E, 0x9C, 0x90, 0x82, 0x23, 
-0xEF, 0xF0, 0x60, 0xF0, 0xD1, 0xEB, 0xBF, 0x01, 0xEB, 0x71, 0x8D, 0x80, 0xE7, 0xD3, 0x10, 0xAF, 
-0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0x2E, 0x74, 0x08, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 
-0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0xE0, 0x7C, 0x00, 0x24, 0x00, 
-0xFF, 0xEC, 0x3E, 0x90, 0x82, 0x24, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x82, 0xE0, 0x90, 0x82, 
-0x2D, 0xF0, 0x90, 0x80, 0xE4, 0xE0, 0x20, 0xE0, 0x02, 0xA1, 0xA9, 0x90, 0x80, 0xE9, 0xE0, 0x20, 
-0xE0, 0x07, 0x90, 0x01, 0x3F, 0xE0, 0x30, 0xE2, 0x18, 0x90, 0x80, 0x01, 0xE0, 0xB4, 0x01, 0x0E, 
-0x90, 0xFD, 0x01, 0xE0, 0x20, 0xE6, 0x07, 0x90, 0xFD, 0x00, 0xE0, 0x44, 0x10, 0xF0, 0x12, 0x52, 
-0xAE, 0xE4, 0x90, 0x82, 0x2C, 0xF0, 0x90, 0x82, 0x2D, 0xE0, 0xFF, 0x90, 0x82, 0x2C, 0xE0, 0xC3, 
-0x9F, 0x40, 0x02, 0xA1, 0xA9, 0x90, 0x82, 0x24, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xEC, 0xFF, 0x90, 
-0xFD, 0x11, 0xF0, 0x90, 0x82, 0x26, 0xED, 0xF0, 0x90, 0x82, 0x30, 0xEF, 0xF0, 0x90, 0x82, 0x26, 
-0xE0, 0xFF, 0x24, 0x02, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x33, 0x33, 
-0x33, 0x54, 0xF8, 0x90, 0x82, 0x2A, 0xF0, 0xEF, 0x24, 0x18, 0xFF, 0xE0, 0xFE, 0x2F, 0x90, 0x82, 
-0x27, 0xF0, 0x90, 0x82, 0x25, 0xE0, 0x24, 0x18, 0xFD, 0x90, 0x82, 0x24, 0xE0, 0x34, 0x00, 0xFC, 
-0xEE, 0x7E, 0x00, 0x2D, 0xFF, 0xEE, 0x3C, 0x90, 0x82, 0x28, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x82, 
-0x27, 0xE0, 0xFD, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0xFC, 0x90, 
-0x82, 0x2B, 0xF0, 0x74, 0x00, 0x2D, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0x12, 0x5D, 0xF8, 
-0x90, 0x82, 0x2F, 0xEF, 0xF0, 0x90, 0x82, 0x26, 0xE0, 0xFD, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 
-0xFB, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x00, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 
-0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x54, 0x3F, 0xFE, 0x90, 0x82, 0x31, 0xF0, 0xA3, 0xEF, 
-0xF0, 0x90, 0x82, 0x2A, 0xE0, 0x24, 0x18, 0xFD, 0xEC, 0x33, 0xFC, 0xED, 0x2F, 0xFF, 0xEC, 0x3E, 
-0xFE, 0xD1, 0x85, 0x90, 0x82, 0x26, 0xE0, 0x24, 0x0F, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 
-0xE0, 0xFD, 0x90, 0x82, 0x24, 0xEE, 0x8F, 0xF0, 0x12, 0x49, 0x4B, 0x90, 0x80, 0x9F, 0xE0, 0xFE, 
-0xA3, 0xE0, 0xFF, 0xD3, 0x90, 0x82, 0x25, 0xE0, 0x9F, 0x90, 0x82, 0x24, 0xE0, 0x9E, 0x40, 0x1B, 
-0x90, 0x80, 0xA0, 0xE0, 0x24, 0x01, 0xFF, 0x90, 0x80, 0x9F, 0xE0, 0x34, 0x00, 0xFE, 0xC3, 0x90, 
-0x82, 0x25, 0xE0, 0x9F, 0xF0, 0x90, 0x82, 0x24, 0xE0, 0x9E, 0xF0, 0xED, 0x30, 0xE7, 0x06, 0x90, 
-0x01, 0xC7, 0x74, 0x21, 0xF0, 0xED, 0x30, 0xE6, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x22, 0xF0, 0xED, 
-0x30, 0xE5, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x23, 0xF0, 0x90, 0x82, 0x2B, 0xE0, 0x24, 0x40, 0x60, 
-0x04, 0x24, 0x20, 0x70, 0x21, 0x90, 0x80, 0xE5, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 
-0x30, 0xE0, 0x43, 0x90, 0x82, 0x27, 0xE0, 0xFF, 0xF1, 0x28, 0xEF, 0x60, 0x39, 0x90, 0x82, 0x2B, 
-0xE0, 0xFF, 0xD1, 0xAE, 0x80, 0x30, 0x90, 0x82, 0x27, 0xE0, 0xFF, 0x90, 0x82, 0x2F, 0xE0, 0xFD, 
-0x90, 0x82, 0x2E, 0xE0, 0xFB, 0x90, 0x82, 0x30, 0xE0, 0x90, 0x82, 0x36, 0xF0, 0xF1, 0x7B, 0x90, 
-0x80, 0xE4, 0xE0, 0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x0D, 0x90, 0x82, 0x27, 0xE0, 0xFF, 0x90, 0x82, 
-0x2F, 0xE0, 0xFD, 0x12, 0x70, 0x73, 0x90, 0x80, 0xE9, 0xE0, 0x20, 0xE0, 0x07, 0x90, 0x01, 0x3F, 
-0xE0, 0x30, 0xE2, 0x03, 0x12, 0x52, 0xAE, 0xD1, 0xC5, 0xBF, 0x01, 0x0D, 0x90, 0x82, 0x24, 0xB1, 
-0xAE, 0x90, 0x82, 0x2C, 0xE0, 0x04, 0xF0, 0x61, 0xF6, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE0, 0xFE, 
-0xA3, 0xE0, 0xFF, 0x90, 0x02, 0x84, 0xEF, 0xF0, 0xEE, 0xA3, 0xF0, 0xA3, 0xE0, 0x44, 0x01, 0xF0, 
-0x22, 0x90, 0x01, 0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 
-0x3E, 0x90, 0x82, 0x1A, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x87, 0xE0, 0xF9, 0x90, 0x80, 0xE4, 
-0xE0, 0x20, 0xE0, 0x02, 0xC1, 0x84, 0xEC, 0xC3, 0x99, 0x40, 0x02, 0xC1, 0x84, 0x90, 0x82, 0x1A, 
-0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0xEA, 0x90, 0xFD, 0x11, 0xF0, 0xAF, 0x03, 0xAD, 0x07, 0x74, 0x02, 
-0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x33, 0x33, 0x33, 0x54, 0xF8, 
-0xFB, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x00, 0x2D, 
-0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x75, 0x83, 0x00, 0x24, 0x00, 0xFF, 0xE5, 0x83, 
-0x3E, 0x54, 0x3F, 0xFE, 0xEB, 0x24, 0x18, 0xFB, 0xE4, 0x33, 0xFA, 0xEB, 0x2F, 0xFF, 0xEA, 0x3E, 
-0xFE, 0xD1, 0x85, 0x90, 0x82, 0x1A, 0xEE, 0x8F, 0xF0, 0x12, 0x49, 0x4B, 0x90, 0x80, 0x9F, 0xE0, 
-0xFE, 0xA3, 0xE0, 0xFF, 0xD3, 0x90, 0x82, 0x1B, 0xE0, 0x9F, 0x90, 0x82, 0x1A, 0xE0, 0x9E, 0x40, 
-0x1B, 0x90, 0x80, 0xA0, 0xE0, 0x24, 0x01, 0xFF, 0x90, 0x80, 0x9F, 0xE0, 0x34, 0x00, 0xFE, 0xC3, 
-0x90, 0x82, 0x1B, 0xE0, 0x9F, 0xF0, 0x90, 0x82, 0x1A, 0xE0, 0x9E, 0xF0, 0x90, 0x82, 0x1A, 0xB1, 
-0xAE, 0x0C, 0xA1, 0xE6, 0x22, 0x7D, 0x7F, 0xEF, 0x5D, 0xC3, 0x60, 0x14, 0x74, 0xFF, 0x9D, 0xFD, 
-0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x5F, 0x24, 0x80, 0xFF, 0xE4, 0x3E, 0xFE, 0x80, 0x0D, 
-0x74, 0xFF, 0x9D, 0xFD, 0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x5F, 0xFF, 0x22, 0xEF, 0x90, 
-0x01, 0xC7, 0xB4, 0xA0, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x03, 0x74, 0x08, 0xF0, 0x90, 0x80, 0xE9, 
-0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x80, 0xE9, 0xE0, 0xFF, 0x20, 0xE0, 0x07, 0x90, 0x01, 0x3F, 
-0xE0, 0x30, 0xE2, 0x14, 0xEF, 0x44, 0x01, 0x90, 0x80, 0xE9, 0xF0, 0x90, 0x80, 0xE5, 0xE0, 0xC4, 
-0x54, 0x0F, 0x20, 0xE0, 0x03, 0x7F, 0x00, 0x22, 0x7F, 0x01, 0x22, 0xE4, 0x90, 0x83, 0xAF, 0xF0, 
-0xA3, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x2C, 0xC3, 0x90, 0x83, 0xB0, 0xE0, 0x94, 0xD0, 
-0x90, 0x83, 0xAF, 0xE0, 0x94, 0x07, 0x40, 0x0A, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 
-0x00, 0x22, 0x90, 0x83, 0xAF, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x49, 0x4B, 0x7F, 0x0A, 0x7E, 0x00, 
-0x12, 0x32, 0xAA, 0x80, 0xCD, 0x7F, 0x01, 0x22, 0xE4, 0xFE, 0x74, 0x10, 0x2E, 0xF5, 0x82, 0xE4, 
-0x34, 0x06, 0xF5, 0x83, 0xE0, 0xFD, 0x74, 0x39, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 
-0xED, 0xF0, 0xEF, 0x2E, 0x24, 0x04, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFD, 0x74, 
-0x33, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xED, 0xF0, 0x0E, 0xEE, 0xB4, 0x06, 0xCA, 
-0x78, 0x39, 0x7C, 0x82, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x33, 0x7E, 0x00, 0x7F, 0x06, 
-0x12, 0x4B, 0xEC, 0xEF, 0x7F, 0x00, 0x70, 0x02, 0x7F, 0x01, 0x22, 0x74, 0x00, 0x2F, 0xF5, 0x82, 
-0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x0C, 0x64, 0x08, 0x70, 0x64, 0xEF, 0x2D, 0xFE, 0x24, 
-0x06, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x64, 0x88, 0x70, 0x53, 0x74, 0x07, 0x2E, 
-0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x64, 0x8E, 0x70, 0x44, 0xEF, 0x2D, 0x2B, 0xFE, 
-0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x64, 0x03, 0x70, 0x32, 0x74, 0x06, 
-0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x30, 0xE3, 0x1A, 0x90, 0x80, 0xE5, 0xE0, 
-0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x18, 0x90, 0x01, 0xC7, 0x74, 0x01, 0xF0, 0x90, 0x80, 
-0xE9, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x7E, 0x00, 0x90, 0x82, 0x36, 0xE0, 0xFD, 0x12, 0x53, 0x09, 
-0x22, 0x90, 0x83, 0x5F, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 
-0x00, 0xE4, 0x90, 0x83, 0x6D, 0xF0, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0x90, 0x83, 0x65, 
-0x12, 0x20, 0xCE, 0x90, 0x83, 0x5F, 0xE0, 0xFB, 0x70, 0x08, 0x90, 0x83, 0x65, 0x12, 0x49, 0x6E, 
-0x80, 0x16, 0xEB, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x62, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 
-0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x2D, 0x5C, 0x90, 0x83, 0x69, 0x12, 0x20, 0xCE, 0x90, 0x83, 
-0x60, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x17, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 
-0xAA, 0x06, 0xAB, 0x07, 0x90, 0x83, 0x69, 0x12, 0x49, 0x6E, 0xED, 0x54, 0x7F, 0xFD, 0xEC, 0x54, 
-0x80, 0xFC, 0x12, 0x49, 0x61, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x83, 0x69, 0x12, 0x20, 0xCE, 0x90, 
-0x83, 0x65, 0x12, 0x49, 0x6E, 0xEC, 0x54, 0x7F, 0xFC, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 
-0x24, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x83, 0x5F, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x62, 
-0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC0, 0x06, 0xC0, 0x07, 
-0x90, 0x83, 0x69, 0x12, 0x49, 0x6E, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0xD0, 0x07, 0xD0, 0x06, 
-0x12, 0x2E, 0xA2, 0x90, 0x83, 0x65, 0x12, 0x49, 0x6E, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x85, 0xBB, 
-0x12, 0x20, 0xCE, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x83, 0x5F, 0xE0, 0x70, 0x04, 
-0x7F, 0x20, 0x80, 0x09, 0x90, 0x83, 0x5F, 0xE0, 0xB4, 0x01, 0x16, 0x7F, 0x28, 0x7E, 0x08, 0x12, 
-0x2D, 0x5C, 0x78, 0x08, 0x12, 0x20, 0xA8, 0xEF, 0x54, 0x01, 0xFF, 0xE4, 0x90, 0x83, 0x6D, 0xEF, 
-0xF0, 0x90, 0x83, 0x6D, 0xE0, 0x90, 0x83, 0x5F, 0x60, 0x0E, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 
-0x66, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x80, 0x0C, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x64, 0xF5, 
-0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x2D, 0x5C, 0xED, 0x54, 
-0x0F, 0xFD, 0xE4, 0xFC, 0x90, 0x83, 0x61, 0x12, 0x20, 0xCE, 0x90, 0x83, 0x61, 0x02, 0x49, 0x6E, 
-0x90, 0x83, 0x6E, 0xEF, 0xF0, 0xAB, 0x05, 0x90, 0x83, 0x74, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 
-0x00, 0xAF, 0x03, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x14, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 
-0xAA, 0x06, 0xAB, 0x07, 0x90, 0x83, 0x70, 0x12, 0x49, 0x6E, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 
-0x12, 0x49, 0x61, 0xEC, 0x54, 0x0F, 0xFC, 0x90, 0x83, 0x74, 0x12, 0x20, 0xCE, 0x90, 0x83, 0x6E, 
-0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x60, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 
-0xA3, 0xE0, 0xFF, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x83, 0x74, 0x12, 0x49, 0x6E, 0x90, 0x85, 0xBB, 
-0x12, 0x20, 0xCE, 0xD0, 0x07, 0xD0, 0x06, 0x02, 0x2E, 0xA2, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
-0xD0, 0x12, 0x67, 0xF1, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x8E, 0x19, 0x8F, 0x1A, 0xE5, 0x1E, 0x54, 
-0x07, 0xC4, 0x33, 0x54, 0xE0, 0x85, 0x19, 0x83, 0x85, 0x1A, 0x82, 0xF0, 0xE5, 0x1D, 0x54, 0x07, 
-0xC4, 0x33, 0x54, 0xE0, 0xFF, 0xE5, 0x1E, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0xA3, 0xF0, 0xEB, 
-0x54, 0x07, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 0xE5, 0x1D, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0x85, 
-0x1A, 0x82, 0x85, 0x19, 0x83, 0xA3, 0xA3, 0xF0, 0xBD, 0x01, 0x0C, 0x85, 0x1A, 0x82, 0x8E, 0x83, 
-0xA3, 0xA3, 0xA3, 0x74, 0x03, 0xF0, 0x22, 0x85, 0x1A, 0x82, 0x85, 0x19, 0x83, 0xA3, 0xA3, 0xA3, 
-0x74, 0x01, 0xF0, 0x22, 0x90, 0x83, 0x78, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xAD, 0x03, 0xAC, 0x02, 
-0xE4, 0x90, 0x83, 0x80, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0xC4, 0x74, 0x04, 0xF0, 0x74, 0x6A, 0xA3, 
-0xF0, 0xEC, 0x54, 0x3F, 0xFC, 0x90, 0x01, 0x40, 0xED, 0xF0, 0xAE, 0x04, 0xEE, 0xA3, 0xF0, 0x90, 
-0x83, 0x78, 0xE0, 0x24, 0x81, 0x60, 0x34, 0x24, 0xDA, 0x60, 0x1C, 0x24, 0x3C, 0x70, 0x41, 0x90, 
-0x83, 0x79, 0xE0, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0x90, 0x83, 0x7D, 0xF0, 0xA3, 0x74, 0x69, 
-0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x80, 0x2C, 0x90, 0x83, 0x79, 0xE0, 0x54, 0x01, 0x90, 0x83, 0x7D, 
-0xF0, 0xA3, 0x74, 0xA5, 0xF0, 0xA3, 0x74, 0x01, 0xF0, 0x80, 0x18, 0x90, 0x83, 0x79, 0xE0, 0xC4, 
-0x54, 0x10, 0x90, 0x83, 0x7D, 0xF0, 0xA3, 0x74, 0x7F, 0xF0, 0xA3, 0x74, 0x10, 0xF0, 0x80, 0x03, 
-0x7F, 0x00, 0x22, 0x90, 0x83, 0x7E, 0xE0, 0x90, 0x01, 0x06, 0xF0, 0x90, 0x83, 0x7D, 0xE0, 0x60, 
-0x0E, 0x90, 0x01, 0x42, 0xF0, 0x90, 0x83, 0x7C, 0xE0, 0x90, 0x01, 0x43, 0xF0, 0x80, 0x0D, 0x90, 
-0x01, 0x43, 0xE4, 0xF0, 0x90, 0x83, 0x7D, 0xE0, 0x90, 0x01, 0x42, 0xF0, 0x90, 0x83, 0x7F, 0xE0, 
-0xFF, 0x90, 0x01, 0x42, 0xE0, 0x5F, 0xFF, 0x90, 0x83, 0x7D, 0xE0, 0x6F, 0x60, 0xEE, 0x74, 0x04, 
-0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x6A, 0xA3, 0xF0, 0x90, 0x01, 0x43, 0xE4, 0xF0, 0x7F, 0x01, 
-0x22, 0x90, 0x02, 0x09, 0xE0, 0xFD, 0x12, 0x1F, 0xA4, 0xFE, 0xAF, 0x05, 0xED, 0x2E, 0x90, 0x80, 
-0x02, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x80, 0x03, 0xF0, 0x90, 
-0x00, 0x02, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x80, 0x04, 0xF0, 0x90, 0x00, 0x03, 0x12, 
-0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x80, 0x05, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0xFF, 
-0xAE, 0x05, 0xED, 0x2F, 0x90, 0x80, 0x06, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
-0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x80, 0xE3, 0xF0, 0xBF, 0x01, 0x12, 0x90, 0x00, 0x01, 0x12, 0x1F, 
-0xBD, 0x64, 0x01, 0x60, 0x17, 0x90, 0x05, 0x22, 0x74, 0x6F, 0xF0, 0x80, 0x0F, 0x90, 0x00, 0x01, 
-0x12, 0x1F, 0xBD, 0x64, 0x01, 0x60, 0x05, 0x90, 0x05, 0x22, 0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 
-0x22, 0x8F, 0x0F, 0x22, 0x8F, 0x1F, 0x22, 0x22, 0x90, 0x01, 0x30, 0xE4, 0xF0, 0xA3, 0xF0, 0xA3, 
-0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x38, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xFD, 0x7F, 0x50, 
-0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x51, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x52, 0x12, 0x32, 
-0x1E, 0xE4, 0xFD, 0x7F, 0x53, 0x02, 0x32, 0x1E, 0x90, 0x01, 0x34, 0x74, 0xFF, 0xF0, 0xA3, 0xF0, 
-0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x3C, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xFD, 0x7F, 
-0x54, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x56, 0x12, 
-0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x57, 0x02, 0x32, 0x1E, 0x75, 0x3D, 0x10, 0xE4, 0xF5, 0x3E, 0x75, 
-0x3F, 0x07, 0x75, 0x40, 0x02, 0x90, 0x01, 0x30, 0xE5, 0x3D, 0xF0, 0xA3, 0xE5, 0x3E, 0xF0, 0xA3, 
-0xE5, 0x3F, 0xF0, 0xA3, 0xE5, 0x40, 0xF0, 0x22, 0x75, 0x45, 0x0E, 0x75, 0x46, 0x01, 0x75, 0x47, 
-0x03, 0x75, 0x48, 0x62, 0x90, 0x01, 0x38, 0xE5, 0x45, 0xF0, 0xA3, 0xE5, 0x46, 0xF0, 0xA3, 0xE5, 
-0x47, 0xF0, 0xA3, 0xE5, 0x48, 0xF0, 0x22, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 
-0x9C, 0x74, 0x7E, 0xF0, 0xA3, 0x74, 0x92, 0xF0, 0xA3, 0x74, 0xA0, 0xF0, 0xA3, 0x74, 0x24, 0xF0, 
-0x90, 0x01, 0x9B, 0x74, 0x49, 0xF0, 0x90, 0x01, 0x9A, 0x74, 0xE0, 0xF0, 0x90, 0x01, 0x99, 0xE4, 
-0xF0, 0x90, 0x01, 0x98, 0x04, 0xF0, 0x22, 0xE4, 0x90, 0x82, 0x03, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 
-0x98, 0xE0, 0x7F, 0x00, 0x30, 0xE4, 0x02, 0x7F, 0x01, 0xEF, 0x64, 0x01, 0x60, 0x3E, 0xC3, 0x90, 
-0x82, 0x04, 0xE0, 0x94, 0x88, 0x90, 0x82, 0x03, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC1, 
-0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x82, 0x03, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x49, 0x4B, 0x7F, 
-0x14, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0xD3, 0x90, 0x82, 0x04, 0xE0, 0x94, 0x32, 0x90, 0x82, 0x03, 
-0xE0, 0x94, 0x00, 0x40, 0xB9, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xB2, 0x22, 0x90, 0x00, 0x54, 
-0xE0, 0x55, 0x35, 0xF5, 0x39, 0xA3, 0xE0, 0x55, 0x36, 0xF5, 0x3A, 0xA3, 0xE0, 0x55, 0x37, 0xF5, 
-0x3B, 0xA3, 0xE0, 0x55, 0x38, 0xF5, 0x3C, 0xAD, 0x39, 0x7F, 0x54, 0x12, 0x32, 0x1E, 0xAD, 0x3A, 
-0x7F, 0x55, 0x12, 0x32, 0x1E, 0xAD, 0x3B, 0x7F, 0x56, 0x12, 0x32, 0x1E, 0xAD, 0x3C, 0x7F, 0x57, 
-0x12, 0x32, 0x1E, 0x53, 0x91, 0xEF, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x3D, 0xF5, 0x41, 0xA3, 
-0xE0, 0x55, 0x3E, 0xF5, 0x42, 0xA3, 0xE0, 0x55, 0x3F, 0xF5, 0x43, 0xA3, 0xE0, 0x55, 0x40, 0xF5, 
-0x44, 0x90, 0x01, 0x34, 0xE5, 0x41, 0xF0, 0xA3, 0xE5, 0x42, 0xF0, 0xA3, 0xE5, 0x43, 0xF0, 0xA3, 
-0xE5, 0x44, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 
-0x1A, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x90, 0x60, 0x07, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x08, 0xF0, 
-0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE1, 0xE4, 0x7F, 0x00, 0x80, 0x02, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 
-0xAF, 0x22, 0x90, 0x82, 0x49, 0x12, 0x49, 0x8F, 0x91, 0xE4, 0xEF, 0x64, 0x01, 0x60, 0x02, 0xA1, 
-0xE0, 0x90, 0x81, 0xF2, 0x12, 0x51, 0xBD, 0x90, 0x82, 0x50, 0x12, 0x5D, 0xEA, 0x90, 0x82, 0x52, 
-0xEF, 0xF0, 0x90, 0x82, 0x50, 0xA3, 0xE0, 0x24, 0x20, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 
-0x90, 0x82, 0x4F, 0xE0, 0xFD, 0xB1, 0xE1, 0x90, 0x82, 0x50, 0xA3, 0xE0, 0x24, 0x30, 0xF9, 0xE4, 
-0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x82, 0x4C, 0x12, 0x49, 
-0x86, 0x8B, 0x13, 0x8A, 0x14, 0x89, 0x15, 0x75, 0x16, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 
-0x12, 0x2B, 0xED, 0x90, 0x82, 0x50, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x24, 0x3A, 0xF9, 0xE4, 
-0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x82, 0x4C, 0x12, 0x49, 
-0x86, 0x8B, 0x13, 0x8A, 0x14, 0x89, 0x15, 0x75, 0x16, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 
-0x12, 0x2B, 0xED, 0x90, 0x82, 0x50, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x24, 0x40, 0xF9, 0xE4, 
-0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x82, 0x49, 0x12, 0x49, 
-0x86, 0x8B, 0x13, 0x8A, 0x14, 0x89, 0x15, 0x75, 0x16, 0x04, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 
-0x12, 0x2B, 0xED, 0x90, 0x06, 0x30, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 
-0x22, 0x90, 0x82, 0xEE, 0xED, 0xF0, 0x90, 0x82, 0xEB, 0x12, 0x49, 0x8F, 0xE4, 0x90, 0x82, 0xEF, 
-0xF0, 0xA3, 0xF0, 0x12, 0x5D, 0xF8, 0x90, 0x82, 0xEF, 0xEF, 0xF0, 0x90, 0x82, 0xEB, 0x12, 0x49, 
-0x86, 0xD1, 0xF9, 0x90, 0x82, 0xF0, 0xEF, 0xF0, 0x90, 0x80, 0xFA, 0xE0, 0x24, 0xFE, 0x60, 0x1D, 
-0x24, 0xFE, 0x60, 0x19, 0x14, 0x60, 0x07, 0x14, 0x60, 0x04, 0x24, 0x05, 0x70, 0x60, 0x7B, 0x01, 
-0x7A, 0x80, 0x79, 0xFB, 0x90, 0x82, 0xEE, 0xE0, 0xFD, 0xD1, 0x7F, 0x80, 0x23, 0x7B, 0x01, 0x7A, 
-0x81, 0x79, 0x03, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x8F, 0x90, 0x82, 0xEE, 0xE0, 0x90, 0x82, 0xF7, 
-0xF0, 0x90, 0x80, 0xFA, 0xE0, 0x90, 0x82, 0xF8, 0xF0, 0x7A, 0x80, 0x79, 0xFB, 0x12, 0x80, 0xDC, 
-0x90, 0x82, 0xF0, 0xE0, 0xFF, 0x90, 0x82, 0xEB, 0x12, 0x49, 0x86, 0x90, 0x82, 0xEF, 0xE0, 0x7C, 
-0x00, 0x29, 0xF9, 0xEC, 0x3A, 0xFA, 0xC3, 0xE9, 0x9F, 0xF9, 0xEA, 0x94, 0x00, 0xFA, 0x75, 0x13, 
-0x01, 0x75, 0x14, 0x80, 0x75, 0x15, 0xFB, 0xA3, 0xE0, 0xF5, 0x16, 0x12, 0x2B, 0xED, 0x22, 0x90, 
-0x82, 0xF4, 0xED, 0xF0, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x8F, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 
-0x90, 0x82, 0xF8, 0xF0, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0x8B, 0x13, 0x8A, 0x14, 0x89, 0x15, 
-0x75, 0x16, 0x03, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0xF5, 0x12, 0x2B, 0xED, 0x90, 0x82, 0xF4, 0xE0, 
-0x70, 0x46, 0xFF, 0x74, 0xF5, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xB4, 0xFF, 
-0x0E, 0x74, 0xF5, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE4, 0xF0, 0x80, 0x0F, 0x74, 
-0xF5, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0x04, 0xF0, 0x80, 0x05, 0x0F, 0xEF, 
-0xB4, 0x03, 0xD0, 0x75, 0x13, 0x01, 0x75, 0x14, 0x82, 0x75, 0x15, 0xF5, 0x75, 0x16, 0x03, 0x90, 
-0x82, 0xF1, 0x12, 0x49, 0x86, 0x12, 0x2B, 0xED, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
-0x90, 0x83, 0x82, 0x12, 0x49, 0x8F, 0xE4, 0x90, 0x83, 0x85, 0xF0, 0x90, 0x83, 0x82, 0x12, 0x49, 
-0x86, 0xE9, 0x24, 0x04, 0xF9, 0xE4, 0x3A, 0x8B, 0x13, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x06, 
-0x7B, 0x01, 0x7A, 0x83, 0x79, 0x86, 0x12, 0x2B, 0xED, 0x90, 0x83, 0x86, 0xE0, 0x20, 0xE0, 0x05, 
-0x90, 0x81, 0xEF, 0x80, 0x03, 0x90, 0x81, 0xF0, 0xE0, 0x90, 0x80, 0xFA, 0xF0, 0x90, 0x80, 0xFA, 
-0xE0, 0x14, 0x60, 0x11, 0x14, 0x60, 0x16, 0x24, 0xFE, 0x60, 0x12, 0x14, 0x60, 0x07, 0x14, 0x60, 
-0x04, 0x24, 0x06, 0x80, 0x10, 0x90, 0x83, 0x85, 0x74, 0x04, 0xF0, 0x80, 0x0D, 0x90, 0x83, 0x85, 
-0x74, 0x08, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0x83, 0x85, 0xF0, 0x90, 0x83, 0x85, 0xE0, 0xFF, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0xC3, 0xEE, 0x94, 0x01, 0x40, 0x0A, 0x0D, 0xED, 0x13, 0x90, 0xFD, 0x10, 
-0xF0, 0xE4, 0x2F, 0xFF, 0x22, 0xE4, 0x90, 0x83, 0xAB, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 
-0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 
-0x22, 0xD3, 0x90, 0x83, 0xAC, 0xE0, 0x94, 0xE8, 0x90, 0x83, 0xAB, 0xE0, 0x94, 0x03, 0x40, 0x0A, 
-0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x32, 
-0xAA, 0x90, 0x83, 0xAB, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x49, 0x4B, 0x80, 0xBF, 0x74, 0x45, 0x2F, 
-0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 
-0xF0, 0x22, 0x74, 0x45, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 
-0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x14, 
-0x90, 0x80, 0x03, 0xE0, 0xFF, 0xE4, 0xFD, 0x12, 0x51, 0xC1, 0x8E, 0x0D, 0x8F, 0x0E, 0x90, 0x04, 
-0x1F, 0x74, 0x20, 0xF0, 0x22, 0xAB, 0x07, 0xAA, 0x06, 0xED, 0x2B, 0xFB, 0xE4, 0x3A, 0xFA, 0xC3, 
-0x90, 0x80, 0xA0, 0xE0, 0x9B, 0x90, 0x80, 0x9F, 0xE0, 0x9A, 0x50, 0x13, 0xA3, 0xE0, 0x24, 0x01, 
-0xFF, 0x90, 0x80, 0x9F, 0xE0, 0x34, 0x00, 0xFE, 0xC3, 0xEB, 0x9F, 0xFB, 0xEA, 0x9E, 0xFA, 0xEA, 
-0x90, 0xFD, 0x11, 0xF0, 0xAF, 0x03, 0x74, 0x00, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 
-0xE0, 0xFF, 0x22, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x81, 0xFB, 0xE0, 0x54, 0xFE, 
-0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x0A, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x81, 
-0xFC, 0xF0, 0x22, 0x90, 0x82, 0x33, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x78, 0x3B, 0x7C, 0x82, 0x7D, 
-0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xC0, 0x7E, 0x00, 0x7F, 0x06, 0x12, 0x48, 0xD0, 0x78, 0x41, 
-0x7C, 0x82, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xC6, 0x7E, 0x00, 0x7F, 0x04, 0x12, 0x48, 
-0xD0, 0x78, 0x45, 0x7C, 0x82, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xCA, 0x7E, 0x00, 0x7F, 
-0x04, 0x12, 0x48, 0xD0, 0x90, 0x82, 0x34, 0xE0, 0xFF, 0x90, 0x82, 0x33, 0xE0, 0x2F, 0xFF, 0x24, 
-0x06, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x64, 0x08, 0x60, 0x02, 0x21, 0xB8, 0x74, 
-0x07, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x64, 0x06, 0x60, 0x02, 0x21, 0xB8, 
-0x90, 0x06, 0x30, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x82, 0x33, 0xE0, 0x24, 0x0A, 0xF9, 0xE4, 0x34, 
-0xFB, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x06, 0x7B, 0x01, 0x7A, 0x82, 0x79, 
-0x35, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x34, 0xE0, 0xFF, 0x90, 0x82, 0x33, 0xE0, 0x2F, 0x24, 0x10, 
-0xF9, 0xE4, 0x34, 0xFB, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x06, 0x7B, 0x01, 
-0x7A, 0x82, 0x79, 0x3B, 0x12, 0x2B, 0xED, 0x90, 0x82, 0x34, 0xE0, 0xFF, 0x90, 0x82, 0x33, 0xE0, 
-0x2F, 0x24, 0x16, 0xF9, 0xE4, 0x34, 0xFB, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 
-0x04, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x41, 0x12, 0x2B, 0xED, 0x78, 0x35, 0x7C, 0x82, 0x7D, 0x01, 
-0x7B, 0x01, 0x7A, 0x80, 0x79, 0xEA, 0x7E, 0x00, 0x7F, 0x06, 0x12, 0x4B, 0xEC, 0xEF, 0x70, 0x58, 
-0x90, 0x82, 0x34, 0xE0, 0xFF, 0x90, 0x82, 0x33, 0xE0, 0x2F, 0x24, 0x20, 0xF9, 0xE4, 0x34, 0xFB, 
-0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x04, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x45, 
-0x12, 0x2B, 0xED, 0x78, 0x45, 0x7C, 0x82, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x80, 0x79, 0xF6, 0x7E, 
-0x00, 0x7F, 0x04, 0x12, 0x4B, 0xEC, 0xEF, 0x70, 0x18, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x3B, 0x90, 
-0x82, 0x4C, 0x12, 0x49, 0x8F, 0xE4, 0x90, 0x82, 0x4F, 0xF0, 0x7A, 0x82, 0x79, 0x41, 0x02, 0x6D, 
-0x12, 0x90, 0x06, 0x30, 0xE0, 0x44, 0x20, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0x90, 0x82, 0x1A, 
-0xF0, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0xEF, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x81, 
-0xF0, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFD, 0x12, 0x1F, 0xA4, 0xFE, 0xAF, 0x05, 0xED, 0x2E, 
-0x90, 0x81, 0xF1, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x81, 0xF2, 
-0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x81, 0xF3, 0xF0, 0x90, 0x00, 
-0x03, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x81, 0xF4, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 
-0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x81, 0xF5, 0xF0, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 
-0x2F, 0x90, 0x81, 0xF6, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x1F, 0xBD, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 
-0x90, 0x81, 0xF7, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFD, 0x12, 0x1F, 0xA4, 0xFE, 0xAF, 0x05, 
-0xED, 0x2E, 0x90, 0x81, 0xF8, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 
-0x81, 0xF9, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x81, 
-0xFA, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x82, 0xEB, 0x12, 0x49, 0x8F, 
-0x90, 0x82, 0xEE, 0xED, 0xF0, 0xE4, 0x90, 0x83, 0x3A, 0xF0, 0x90, 0x83, 0x3A, 0xE0, 0xFF, 0xC3, 
-0x94, 0x40, 0x50, 0x14, 0x74, 0xF7, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE4, 0xF0, 
-0x90, 0x83, 0x3A, 0xE0, 0x04, 0xF0, 0x80, 0xE2, 0x90, 0x82, 0xEB, 0x12, 0x49, 0x86, 0x8B, 0x13, 
-0x8A, 0x14, 0x89, 0x15, 0x90, 0x82, 0xEE, 0xE0, 0xF5, 0x16, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0xF7, 
-0x12, 0x2B, 0xED, 0xE4, 0x90, 0x82, 0xF6, 0xF0, 0x90, 0x82, 0xF6, 0xE0, 0xFF, 0xC3, 0x94, 0x40, 
-0x50, 0x16, 0x74, 0xF7, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0x64, 0x36, 0xF0, 
-0x90, 0x82, 0xF6, 0xE0, 0x04, 0xF0, 0x80, 0xE0, 0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 0x90, 0x82, 
-0xF2, 0xE0, 0xFF, 0xF5, 0x82, 0x75, 0x83, 0x00, 0x74, 0x80, 0x12, 0x1F, 0xFC, 0xEF, 0x75, 0xF0, 
-0x08, 0xA4, 0x24, 0x00, 0xFF, 0xE5, 0xF0, 0x34, 0x02, 0xFC, 0x90, 0x00, 0x7E, 0x12, 0x1F, 0xFC, 
-0xEF, 0x90, 0x00, 0x7F, 0x12, 0x1F, 0xFC, 0xE4, 0x90, 0x83, 0x37, 0xF0, 0xA3, 0xF0, 0x90, 0x83, 
-0x37, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC3, 0x94, 0xC0, 0xEE, 0x94, 0x00, 0x40, 0x02, 0x81, 0xBD, 
-0xC3, 0xEF, 0x94, 0x40, 0xEE, 0x94, 0x00, 0x50, 0x52, 0xA3, 0x74, 0x40, 0xF0, 0x74, 0xF7, 0x2F, 
-0xF9, 0xE4, 0x34, 0x82, 0xFA, 0x7B, 0x01, 0x74, 0x40, 0x44, 0x88, 0xFD, 0x12, 0x28, 0x08, 0x90, 
-0x83, 0x37, 0xA3, 0xE0, 0x24, 0xFB, 0xF9, 0xE4, 0x34, 0x82, 0xFA, 0x7B, 0x01, 0xA3, 0xE0, 0x44, 
-0x89, 0xFD, 0x12, 0x28, 0x08, 0x90, 0x83, 0x37, 0xA3, 0xE0, 0x24, 0xFF, 0xF9, 0xE4, 0x34, 0x82, 
-0xFA, 0x7B, 0x01, 0xA3, 0xE0, 0x44, 0x8A, 0xFD, 0x12, 0x28, 0x08, 0x90, 0x83, 0x37, 0xA3, 0xE0, 
-0x24, 0x03, 0xF9, 0xE4, 0x34, 0x83, 0xFA, 0x7B, 0x01, 0x61, 0xFE, 0xE4, 0x90, 0x83, 0x39, 0xF0, 
-0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 0x90, 0x83, 0x37, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 
-0x3E, 0xFA, 0xE9, 0x24, 0xC0, 0xF9, 0xEA, 0x34, 0xFF, 0xFA, 0x74, 0x88, 0xFD, 0x12, 0x28, 0x08, 
-0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 0x90, 0x83, 0x37, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 
-0x3E, 0xFA, 0xE9, 0x24, 0xC4, 0xF9, 0xEA, 0x34, 0xFF, 0xFA, 0xA3, 0xE0, 0x44, 0x89, 0xFD, 0x12, 
-0x28, 0x08, 0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 0x90, 0x83, 0x37, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 
-0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 0x24, 0xC8, 0xF9, 0xEA, 0x34, 0xFF, 0xFA, 0xA3, 0xE0, 0x44, 0x8A, 
-0xFD, 0x12, 0x28, 0x08, 0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 0x90, 0x83, 0x37, 0xE0, 0xFE, 0xA3, 
-0xE0, 0x29, 0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 0x24, 0xCC, 0xF9, 0xEA, 0x34, 0xFF, 0xFA, 0xA3, 0xE0, 
-0x44, 0x8B, 0xFD, 0x12, 0x28, 0x08, 0x90, 0x83, 0x39, 0xE0, 0x44, 0x90, 0x90, 0x01, 0x8C, 0xF0, 
-0xE4, 0x90, 0x83, 0x3B, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x8C, 0xE0, 0x30, 0xE4, 0x22, 0xC3, 0x90, 
-0x83, 0x3C, 0xE0, 0x94, 0xE8, 0x90, 0x83, 0x3B, 0xE0, 0x94, 0x03, 0x50, 0x13, 0x7F, 0x01, 0x7E, 
-0x00, 0x12, 0x32, 0xAA, 0x90, 0x83, 0x3B, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x49, 0x4B, 0x80, 0xD7, 
-0x90, 0x83, 0x3B, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC3, 0x94, 0xE8, 0xEE, 0x94, 0x03, 0x40, 0x0C, 
-0x90, 0x06, 0x31, 0xE0, 0x44, 0x01, 0xF0, 0xEE, 0x90, 0x06, 0x36, 0xF0, 0x90, 0x83, 0x38, 0xE0, 
-0x54, 0x3F, 0x64, 0x30, 0x70, 0x4B, 0x90, 0x83, 0x3B, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x8C, 0xE0, 
-0x20, 0xE5, 0x22, 0xC3, 0x90, 0x83, 0x3C, 0xE0, 0x94, 0xE8, 0x90, 0x83, 0x3B, 0xE0, 0x94, 0x03, 
-0x50, 0x13, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x83, 0x3B, 0xE4, 0x75, 0xF0, 0x01, 
-0x12, 0x49, 0x4B, 0x80, 0xD7, 0x90, 0x83, 0x3B, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC3, 0x94, 0xE8, 
-0xEE, 0x94, 0x03, 0x40, 0x0C, 0x90, 0x06, 0x31, 0xE0, 0x44, 0x02, 0xF0, 0xEE, 0x90, 0x06, 0x36, 
-0xF0, 0x90, 0x83, 0x37, 0xE4, 0x75, 0xF0, 0x10, 0x12, 0x49, 0x4B, 0x61, 0x0E, 0x90, 0x82, 0xF3, 
-0x12, 0x49, 0x86, 0xE9, 0x24, 0x10, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x80, 0x12, 0x2A, 0x8F, 0x90, 
-0x82, 0xF3, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x0C, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x81, 0x12, 0x2A, 
-0x8F, 0x90, 0x82, 0xF3, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x08, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x82, 
-0x12, 0x2A, 0x8F, 0x90, 0x82, 0xF3, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x04, 0xF9, 0xE4, 0x3A, 0xFA, 
-0x7D, 0x83, 0x12, 0x2A, 0x8F, 0x90, 0x82, 0xF3, 0x12, 0x49, 0x86, 0x7D, 0x84, 0x12, 0x2A, 0x8F, 
-0xE4, 0x90, 0x83, 0x3A, 0xF0, 0x90, 0x83, 0x3A, 0xE0, 0xFF, 0xC3, 0x94, 0x40, 0x50, 0x14, 0x74, 
-0xF7, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE4, 0xF0, 0x90, 0x83, 0x3A, 0xE0, 0x04, 
-0xF0, 0x80, 0xE2, 0x90, 0x82, 0xEB, 0x12, 0x49, 0x86, 0x8B, 0x13, 0x8A, 0x14, 0x89, 0x15, 0x90, 
-0x82, 0xEE, 0xE0, 0xF5, 0x16, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0xF7, 0x12, 0x2B, 0xED, 0xE4, 0x90, 
-0x82, 0xF6, 0xF0, 0x90, 0x82, 0xF6, 0xE0, 0xFF, 0xC3, 0x94, 0x40, 0x50, 0x16, 0x74, 0xF7, 0x2F, 
-0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0x64, 0x5C, 0xF0, 0x90, 0x82, 0xF6, 0xE0, 0x04, 
-0xF0, 0x80, 0xE0, 0xE4, 0x90, 0x82, 0xF6, 0xF0, 0x90, 0x82, 0xF3, 0x12, 0x49, 0x86, 0x90, 0x82, 
-0xF6, 0xE0, 0xFF, 0xF5, 0x82, 0x75, 0x83, 0x00, 0x12, 0x1F, 0xBD, 0xFE, 0x90, 0x82, 0xEF, 0x12, 
-0x49, 0x86, 0x8F, 0x82, 0x75, 0x83, 0x00, 0xEE, 0x12, 0x1F, 0xFC, 0x90, 0x82, 0xF6, 0xE0, 0x04, 
-0xF0, 0xE0, 0xB4, 0x14, 0xD3, 0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 0x90, 0x00, 0x14, 0x74, 0x80, 
-0x12, 0x1F, 0xFC, 0x90, 0x82, 0xF6, 0x74, 0x15, 0xF0, 0x90, 0x82, 0xF6, 0xE0, 0xFF, 0xC3, 0x94, 
-0x3E, 0x50, 0x17, 0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 0x8F, 0x82, 0x75, 0x83, 0x00, 0xE4, 0x12, 
-0x1F, 0xFC, 0x90, 0x82, 0xF6, 0xE0, 0x04, 0xF0, 0x80, 0xDF, 0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 
-0x90, 0x00, 0x3E, 0x74, 0x02, 0x12, 0x1F, 0xFC, 0x90, 0x00, 0x3F, 0x74, 0xA0, 0x12, 0x1F, 0xFC, 
-0xE4, 0x90, 0x83, 0x37, 0xF0, 0xA3, 0xF0, 0x90, 0x83, 0x37, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC3, 
-0x94, 0x80, 0xEE, 0x94, 0x00, 0x40, 0x02, 0xE1, 0xA6, 0xC3, 0xEF, 0x94, 0x40, 0xEE, 0x94, 0x00, 
-0x50, 0x52, 0xA3, 0x74, 0x40, 0xF0, 0x74, 0xF7, 0x2F, 0xF9, 0xE4, 0x34, 0x82, 0xFA, 0x7B, 0x01, 
-0x74, 0x40, 0x44, 0x88, 0xFD, 0x12, 0x28, 0x08, 0x90, 0x83, 0x37, 0xA3, 0xE0, 0x24, 0xFB, 0xF9, 
-0xE4, 0x34, 0x82, 0xFA, 0x7B, 0x01, 0xA3, 0xE0, 0x44, 0x89, 0xFD, 0x12, 0x28, 0x08, 0x90, 0x83, 
-0x37, 0xA3, 0xE0, 0x24, 0xFF, 0xF9, 0xE4, 0x34, 0x82, 0xFA, 0x7B, 0x01, 0xA3, 0xE0, 0x44, 0x8A, 
-0xFD, 0x12, 0x28, 0x08, 0x90, 0x83, 0x37, 0xA3, 0xE0, 0x24, 0x03, 0xF9, 0xE4, 0x34, 0x83, 0xFA, 
-0x7B, 0x01, 0xC1, 0xE7, 0xE4, 0x90, 0x83, 0x39, 0xF0, 0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 0x90, 
-0x83, 0x37, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 0x24, 0xC0, 0xF9, 0xEA, 
-0x34, 0xFF, 0xFA, 0x74, 0x88, 0xFD, 0x12, 0x28, 0x08, 0x90, 0x82, 0xEF, 0x12, 0x49, 0x86, 0x90, 
-0x83, 0x37, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 0x24, 0xC4, 0xF9, 0xEA, 
-0x34, 0xFF, 0xFA, 0xA3, 0xE0, 0x44, 0x89, 0xFD, 0x12, 0x28, 0x08, 0x90, 0x82, 0xEF, 0x12, 0x49, 
-0x86, 0x90, 0x83, 0x37, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 0x24, 0xC8, 
-0xF9, 0xEA, 0x34, 0xFF, 0xFA, 0xA3, 0xE0, 0x44, 0x8A, 0xFD, 0x12, 0x28, 0x08, 0x90, 0x82, 0xEF, 
-0x12, 0x49, 0x86, 0x90, 0x83, 0x37, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 
-0x24, 0xCC, 0xF9, 0xEA, 0x34, 0xFF, 0xFA, 0xA3, 0xE0, 0x44, 0x8B, 0xFD, 0x12, 0x28, 0x08, 0x90, 
-0x83, 0x39, 0xE0, 0x44, 0x90, 0x90, 0x01, 0x8C, 0xF0, 0xE4, 0x90, 0x83, 0x3B, 0xF0, 0xA3, 0xF0, 
-0x90, 0x01, 0x8C, 0xE0, 0x30, 0xE4, 0x22, 0xC3, 0x90, 0x83, 0x3C, 0xE0, 0x94, 0xE8, 0x90, 0x83, 
-0x3B, 0xE0, 0x94, 0x03, 0x50, 0x13, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x83, 0x3B, 
-0xE4, 0x75, 0xF0, 0x01, 0x12, 0x49, 0x4B, 0x80, 0xD7, 0x90, 0x83, 0x3B, 0xE0, 0xFE, 0xA3, 0xE0, 
-0xFF, 0xC3, 0x94, 0xE8, 0xEE, 0x94, 0x03, 0x40, 0x0C, 0x90, 0x06, 0x31, 0xE0, 0x44, 0x01, 0xF0, 
-0xEE, 0x90, 0x06, 0x36, 0xF0, 0x90, 0x83, 0x38, 0xE0, 0x54, 0x3F, 0x64, 0x30, 0x70, 0x4B, 0x90, 
-0x83, 0x3B, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x8C, 0xE0, 0x20, 0xE5, 0x22, 0xC3, 0x90, 0x83, 0x3C, 
-0xE0, 0x94, 0xE8, 0x90, 0x83, 0x3B, 0xE0, 0x94, 0x03, 0x50, 0x13, 0x7F, 0x01, 0x7E, 0x00, 0x12, 
-0x32, 0xAA, 0x90, 0x83, 0x3B, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x49, 0x4B, 0x80, 0xD7, 0x90, 0x83, 
-0x3B, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC3, 0x94, 0xE8, 0xEE, 0x94, 0x03, 0x40, 0x0C, 0x90, 0x06, 
-0x31, 0xE0, 0x44, 0x02, 0xF0, 0xEE, 0x90, 0x06, 0x36, 0xF0, 0x90, 0x83, 0x37, 0xE4, 0x75, 0xF0, 
-0x10, 0x12, 0x49, 0x4B, 0xA1, 0xF7, 0x90, 0x82, 0xF3, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x10, 0xF9, 
-0xE4, 0x3A, 0xFA, 0x7D, 0x80, 0x12, 0x2A, 0x8F, 0x90, 0x82, 0xF3, 0x12, 0x49, 0x86, 0xE9, 0x24, 
-0x0C, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x81, 0x12, 0x2A, 0x8F, 0x90, 0x82, 0xF3, 0x12, 0x49, 0x86, 
-0xE9, 0x24, 0x08, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x82, 0x12, 0x2A, 0x8F, 0x90, 0x82, 0xF3, 0x12, 
-0x49, 0x86, 0xE9, 0x24, 0x04, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x83, 0x12, 0x2A, 0x8F, 0x90, 0x82, 
-0xF3, 0x12, 0x49, 0x86, 0x7D, 0x84, 0x12, 0x2A, 0x8F, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x82, 
-0x49, 0xED, 0xF0, 0x90, 0x82, 0x47, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x51, 0xF1, 0x90, 0x82, 0x47, 
-0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
-0x82, 0x4A, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x82, 0x62, 0x74, 0x18, 0xF0, 
-0x7E, 0x00, 0x7F, 0x80, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x6A, 0x12, 0x4C, 0x10, 0x90, 
-0x81, 0xF4, 0xE0, 0xFF, 0x12, 0x5D, 0x8E, 0x90, 0x82, 0x61, 0xEF, 0xF0, 0xF9, 0xE0, 0xFE, 0x24, 
-0x21, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x74, 0x41, 0xF0, 0xEE, 0x24, 0x20, 0xFD, 0xE4, 
-0x33, 0xFC, 0x90, 0x82, 0x62, 0xE0, 0x7A, 0x00, 0x2D, 0xFE, 0xEA, 0x3C, 0x90, 0x82, 0x66, 0xF0, 
-0xA3, 0xCE, 0xF0, 0x74, 0x20, 0x29, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x90, 0x82, 0x4C, 
-0xE0, 0xFD, 0x12, 0x6D, 0xE1, 0x90, 0x82, 0x66, 0xE4, 0x75, 0xF0, 0x08, 0x12, 0x49, 0x4B, 0x90, 
-0x82, 0x66, 0xE4, 0x75, 0xF0, 0x08, 0x12, 0x49, 0x4B, 0x90, 0x82, 0x66, 0xE0, 0xFF, 0xA3, 0xE0, 
-0x90, 0x82, 0x64, 0xCF, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x82, 0x6A, 0x74, 0x01, 0xF0, 0xA3, 0x74, 
-0x03, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0x74, 0x5F, 0xF0, 0x90, 0x82, 0x66, 0xE4, 0x75, 0xF0, 0x04, 
-0x12, 0x49, 0x4B, 0x90, 0x81, 0x59, 0xE0, 0xFF, 0x7E, 0x02, 0xB4, 0xFE, 0x02, 0x7E, 0xFE, 0x90, 
-0x82, 0x66, 0xA3, 0xE0, 0xFD, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEE, 0xF0, 
-0x74, 0x00, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x90, 0x82, 0x6E, 0xF0, 0x90, 
-0x82, 0x66, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x49, 0x4B, 0x90, 0x81, 0xEE, 0xE0, 0x90, 0x82, 0x4A, 
-0xB4, 0x01, 0x0B, 0xE0, 0x44, 0x03, 0xFC, 0xA3, 0xE0, 0x44, 0x10, 0xFD, 0x80, 0x09, 0xE0, 0x44, 
-0x03, 0xFC, 0xA3, 0xE0, 0x44, 0x20, 0xFD, 0x90, 0x82, 0x68, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 
-0x82, 0x6F, 0x74, 0x03, 0xF0, 0xA3, 0x74, 0x12, 0xF0, 0x90, 0x82, 0x66, 0xE4, 0x75, 0xF0, 0x02, 
-0x12, 0x49, 0x4B, 0xEF, 0x64, 0xFE, 0x70, 0x37, 0x90, 0x82, 0x66, 0xA3, 0xE0, 0x24, 0x00, 0xF9, 
-0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0x8B, 0x13, 0x75, 0x14, 0x81, 0x75, 0x15, 0x5C, 
-0x75, 0x16, 0x02, 0xD0, 0x03, 0x12, 0x2B, 0xED, 0x75, 0x13, 0x01, 0x75, 0x14, 0x81, 0x75, 0x15, 
-0x5C, 0x75, 0x16, 0x02, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x71, 0x12, 0x2B, 0xED, 0x80, 0x60, 0x90, 
-0x81, 0x0B, 0xE0, 0xFF, 0xB4, 0x02, 0x2B, 0x90, 0x82, 0x66, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0x24, 
-0x00, 0xF5, 0x82, 0x74, 0xFC, 0x3C, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0x74, 
-0xFC, 0x3C, 0xF5, 0x83, 0x74, 0x20, 0xF0, 0xE4, 0x90, 0x82, 0x71, 0xF0, 0xA3, 0x74, 0x20, 0xF0, 
-0x80, 0x2D, 0xEF, 0xB4, 0x04, 0x29, 0x90, 0x82, 0x66, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x24, 0x00, 
-0xF5, 0x82, 0x74, 0xFC, 0x3E, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x01, 0x2F, 0xF5, 0x82, 0x74, 0xFC, 
-0x3E, 0xF5, 0x83, 0x74, 0x10, 0xF0, 0xE4, 0x90, 0x82, 0x71, 0xF0, 0xA3, 0x74, 0x10, 0xF0, 0x90, 
-0x82, 0x66, 0xE4, 0x75, 0xF0, 0x02, 0x12, 0x49, 0x4B, 0xE4, 0x90, 0x82, 0x63, 0xF0, 0x90, 0x82, 
-0x63, 0xE0, 0xFF, 0x24, 0x5E, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFE, 0x90, 0x82, 
-0x66, 0xA3, 0xE0, 0xFD, 0xEF, 0x2D, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEE, 
-0xF0, 0x90, 0x82, 0x63, 0xE0, 0xFF, 0x24, 0x5E, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 
-0xFE, 0x74, 0x73, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xEE, 0xF0, 0x90, 0x82, 0x63, 
-0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x08, 0xB7, 0x90, 0x82, 0x66, 0xE4, 0x75, 0xF0, 0x08, 0x12, 0x49, 
-0x4B, 0x90, 0x82, 0x66, 0xE4, 0x75, 0xF0, 0x20, 0x12, 0x49, 0x4B, 0x90, 0x82, 0x66, 0xE4, 0x75, 
-0xF0, 0x10, 0x12, 0x49, 0x4B, 0x90, 0x82, 0x66, 0xE4, 0x75, 0xF0, 0x08, 0x12, 0x49, 0x4B, 0x90, 
-0x82, 0x66, 0xE4, 0x75, 0xF0, 0x08, 0x12, 0x49, 0x4B, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x6A, 0x90, 
-0x82, 0xEF, 0x12, 0x49, 0x8F, 0x90, 0x82, 0xF2, 0x74, 0x63, 0xF0, 0x7A, 0x82, 0x79, 0x4D, 0xA3, 
-0x12, 0x49, 0x8F, 0x7A, 0x81, 0x79, 0x0D, 0x7D, 0x10, 0x12, 0x72, 0x63, 0xE4, 0x90, 0x82, 0x63, 
-0xF0, 0x90, 0x82, 0x63, 0xE0, 0xFF, 0xC3, 0x94, 0x10, 0x50, 0x42, 0x90, 0x82, 0x66, 0xA3, 0xE0, 
-0xFE, 0xEF, 0x2E, 0xFF, 0x90, 0x82, 0xEA, 0xF0, 0x7E, 0x00, 0x90, 0x81, 0xF4, 0xE0, 0xFD, 0x12, 
-0x6F, 0x74, 0x90, 0x82, 0x61, 0xEF, 0xF0, 0x90, 0x82, 0x63, 0xE0, 0x24, 0x4D, 0xF5, 0x82, 0xE4, 
-0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x82, 0x61, 0xE0, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 
-0xFC, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x82, 0x63, 0xE0, 0x04, 0xF0, 0x80, 0xB4, 0x12, 0x6C, 0xE4, 
-0xBF, 0x01, 0x19, 0x90, 0x81, 0xF4, 0x12, 0x51, 0xBD, 0x90, 0x82, 0x61, 0xEF, 0xF0, 0x90, 0x81, 
-0xF4, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 
-0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x81, 0xF0, 0xE0, 0xFD, 0xB4, 0x02, 0x0C, 
-0x90, 0x82, 0x81, 0x74, 0x80, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x80, 0x0E, 0xED, 0xB4, 0x04, 0x0A, 
-0x90, 0x82, 0x81, 0x74, 0x80, 0xF0, 0xA3, 0x74, 0x10, 0xF0, 0xEF, 0x64, 0x02, 0x4E, 0x60, 0x02, 
-0x61, 0xDC, 0x90, 0x81, 0x56, 0xE0, 0xFF, 0x64, 0xFE, 0x70, 0x02, 0x61, 0xDC, 0xEF, 0x64, 0x02, 
-0x60, 0x07, 0xEF, 0x64, 0x03, 0x60, 0x02, 0x61, 0xDC, 0x90, 0x81, 0xB6, 0xE0, 0xFE, 0xA3, 0xE0, 
-0xFD, 0xED, 0xFF, 0x90, 0x82, 0x85, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x7E, 0x00, 0x7F, 0x20, 0x7D, 
-0x00, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x61, 0x12, 0x4C, 0x10, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xB8, 
-0x90, 0x86, 0x67, 0x12, 0x49, 0x8F, 0x7A, 0x82, 0x79, 0x61, 0x90, 0x86, 0x6A, 0x12, 0x49, 0x8F, 
-0x7A, 0x81, 0x79, 0x1D, 0x7D, 0x03, 0x12, 0x02, 0x00, 0x75, 0x13, 0x01, 0x75, 0x14, 0x82, 0x75, 
-0x15, 0x69, 0x75, 0x16, 0x10, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x4A, 0x12, 0x2B, 0xED, 0x90, 0x82, 
-0x67, 0xE0, 0xFF, 0x54, 0x03, 0x90, 0x82, 0x87, 0xF0, 0x70, 0x02, 0x04, 0xF0, 0xEF, 0x54, 0x04, 
-0x90, 0x82, 0x88, 0xF0, 0x90, 0x82, 0x87, 0xE0, 0xFF, 0x90, 0x82, 0x5A, 0xF0, 0x90, 0x82, 0x82, 
-0xE0, 0x2F, 0xFE, 0x90, 0x82, 0x81, 0xE0, 0x34, 0x00, 0x90, 0x82, 0x83, 0xF0, 0xA3, 0xCE, 0xF0, 
-0x7E, 0x00, 0x7F, 0x06, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x5B, 0x12, 0x4C, 0x10, 0x90, 
-0x82, 0x5A, 0xE0, 0xFF, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x4A, 0x71, 0xE1, 0xD0, 0xD0, 0x92, 0xAF, 
-0x22, 0x90, 0x82, 0x89, 0xEF, 0xF0, 0xA3, 0x12, 0x49, 0x8F, 0x90, 0x82, 0x8A, 0x12, 0x49, 0x86, 
-0x12, 0x1F, 0xA4, 0x90, 0x06, 0x74, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x75, 
-0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x76, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 
-0xBD, 0x90, 0x06, 0x77, 0xF0, 0x90, 0x82, 0x89, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x02, 0x90, 
-0x06, 0x70, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x7F, 0x01, 0x7E, 
-0x00, 0x12, 0x32, 0xAA, 0x90, 0x82, 0x8A, 0x12, 0x49, 0x86, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 
-0x90, 0x06, 0x74, 0xF0, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x75, 0xF0, 0x90, 0x00, 
-0x06, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x76, 0xF0, 0x90, 0x00, 0x07, 0x12, 0x1F, 0xBD, 0x90, 0x06, 
-0x77, 0xF0, 0x90, 0x82, 0x89, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x03, 0x90, 0x06, 0x70, 0xF0, 
-0xA3, 0xE4, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 
-0xAA, 0x90, 0x82, 0x8A, 0x12, 0x49, 0x86, 0x90, 0x00, 0x08, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x74, 
-0xF0, 0x90, 0x00, 0x09, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x75, 0xF0, 0x90, 0x00, 0x0A, 0x12, 0x1F, 
-0xBD, 0x90, 0x06, 0x76, 0xF0, 0x90, 0x00, 0x0B, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x77, 0xF0, 0x90, 
-0x82, 0x89, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x04, 0x90, 0x06, 0x70, 0xF0, 0xA3, 0xE4, 0xF0, 
-0xA3, 0x04, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x82, 
-0x8A, 0x12, 0x49, 0x86, 0x90, 0x00, 0x0C, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x74, 0xF0, 0x90, 0x00, 
-0x0D, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x75, 0xF0, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x90, 0x06, 
-0x76, 0xF0, 0x90, 0x00, 0x0F, 0x12, 0x1F, 0xBD, 0x90, 0x06, 0x77, 0xF0, 0x90, 0x82, 0x89, 0xE0, 
-0x75, 0xF0, 0x08, 0xA4, 0x24, 0x05, 0x90, 0x06, 0x70, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x04, 0xF0, 
-0xA3, 0x74, 0x80, 0xF0, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x82, 0x89, 0xE0, 0xFF, 
-0x44, 0x10, 0x90, 0x06, 0x74, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0xA3, 0xF0, 
-0xEF, 0x75, 0xF0, 0x08, 0xA4, 0x90, 0x06, 0x70, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 
-0x74, 0x80, 0xF0, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x06, 0x74, 0x74, 0xFF, 0xF0, 
-0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x82, 0x89, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x04, 0x90, 
-0x06, 0x70, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x7F, 0x01, 0x7E, 
-0x00, 0x12, 0x32, 0xAA, 0x90, 0x06, 0x72, 0xE4, 0xF0, 0x22, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x8F, 
-0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFD, 0x70, 0x04, 0xFE, 0x7F, 0x01, 0x22, 0xED, 0xC3, 0x94, 
-0x06, 0x40, 0x68, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x02, 0xF9, 0xE4, 0x3A, 0xA8, 
-0x01, 0xFC, 0xAD, 0x03, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0x4F, 0x7E, 0x00, 0x7F, 0x04, 0x12, 0x4B, 
-0xEC, 0xEF, 0x70, 0x47, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0x90, 0x00, 0x06, 0x12, 0x1F, 0xBD, 
-0x64, 0x01, 0x70, 0x37, 0x90, 0x00, 0x07, 0x12, 0x1F, 0xBD, 0x70, 0x2F, 0x90, 0x83, 0x8C, 0x12, 
-0x49, 0x86, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 0x92, 0x12, 0x49, 0x86, 0x12, 0x49, 
-0x98, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x24, 0x02, 0xFF, 
-0x90, 0x83, 0x92, 0x12, 0x49, 0x86, 0x90, 0x00, 0x03, 0xC1, 0xDF, 0x90, 0x83, 0x8F, 0x12, 0x49, 
-0x86, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x05, 
-0xF9, 0xE4, 0x3A, 0xFA, 0xC3, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xE0, 0xE9, 0x95, 0x82, 0xEA, 0x95, 
-0x83, 0x50, 0x53, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xC3, 
-0x94, 0x14, 0x40, 0x42, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x02, 0xF9, 0xE4, 0x3A, 
-0xA8, 0x01, 0xFC, 0xAD, 0x03, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0x5B, 0x7E, 0x00, 0x7F, 0x04, 0x12, 
-0x4B, 0xEC, 0xEF, 0x70, 0x21, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x06, 0xF9, 0xE4, 
-0x3A, 0xFA, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 0x92, 0x12, 0x49, 0x86, 0x90, 0x00, 
-0x08, 0x12, 0x49, 0xE7, 0xE1, 0x54, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0x90, 0x00, 0x01, 0x12, 
-0x1F, 0xBD, 0xD3, 0x94, 0x06, 0x40, 0x5E, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x02, 
-0xF9, 0xE4, 0x3A, 0xA8, 0x01, 0xFC, 0xAD, 0x03, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0x53, 0x7E, 0x00, 
-0x7F, 0x04, 0x12, 0x4B, 0xEC, 0xEF, 0x70, 0x3D, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0xE9, 0x24, 
-0x06, 0xF9, 0xE4, 0x3A, 0xFA, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 0x92, 0x12, 0x49, 
-0x86, 0x90, 0x00, 0x0B, 0x12, 0x49, 0xE7, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0x90, 0x00, 0x01, 
-0x12, 0x1F, 0xBD, 0x24, 0xFC, 0xFF, 0x90, 0x83, 0x92, 0x12, 0x49, 0x86, 0x90, 0x00, 0x0E, 0xEF, 
-0x12, 0x1F, 0xFC, 0x80, 0x6F, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0x90, 0x00, 0x01, 0x12, 0x1F, 
-0xBD, 0xD3, 0x94, 0x06, 0x40, 0x5E, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x02, 0xF9, 
-0xE4, 0x3A, 0xA8, 0x01, 0xFC, 0xAD, 0x03, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0x57, 0x7E, 0x00, 0x7F, 
-0x04, 0x12, 0x4B, 0xEC, 0xEF, 0x70, 0x3D, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x06, 
-0xF9, 0xE4, 0x3A, 0xFA, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 0x92, 0x12, 0x49, 0x86, 
-0x90, 0x00, 0x0F, 0x12, 0x49, 0xE7, 0x90, 0x83, 0x8C, 0x12, 0x49, 0x86, 0x90, 0x00, 0x01, 0x12, 
-0x1F, 0xBD, 0x24, 0xFC, 0xFF, 0x90, 0x83, 0x92, 0x12, 0x49, 0x86, 0x90, 0x00, 0x12, 0xEF, 0x12, 
-0x1F, 0xFC, 0x80, 0x00, 0xE4, 0xFE, 0xFF, 0x22, 0x90, 0x83, 0x40, 0x12, 0x20, 0xCE, 0x90, 0x83, 
-0x3D, 0x12, 0x49, 0x8F, 0xE4, 0x90, 0x83, 0x4D, 0xF0, 0xA3, 0xF0, 0x90, 0x83, 0x47, 0x12, 0x49, 
-0x8F, 0x90, 0x83, 0x40, 0x12, 0x49, 0x6E, 0xE9, 0x2F, 0xF9, 0xEA, 0x3E, 0xFA, 0xEB, 0x3D, 0xFB, 
-0x90, 0x83, 0x4A, 0x12, 0x49, 0x8F, 0x90, 0x83, 0x4A, 0x12, 0x49, 0x86, 0xC0, 0x03, 0xC0, 0x02, 
-0xC0, 0x01, 0x90, 0x83, 0x47, 0x12, 0x49, 0x86, 0xE9, 0x24, 0x01, 0xF9, 0xE4, 0x3A, 0xFA, 0xC3, 
-0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xE0, 0xE9, 0x95, 0x82, 0xEA, 0x95, 0x83, 0x40, 0x03, 0x02, 0x80, 
-0xD3, 0x90, 0x83, 0x47, 0x12, 0x49, 0x86, 0x12, 0x1F, 0xA4, 0xB4, 0xDD, 0x4F, 0x90, 0x83, 0x40, 
-0x12, 0x49, 0x6E, 0x90, 0x83, 0x3D, 0x12, 0x49, 0x86, 0xE9, 0x2F, 0xF9, 0xEA, 0x3E, 0xFA, 0xEB, 
-0x3D, 0xFB, 0xE9, 0x24, 0xFF, 0xF9, 0xEA, 0x34, 0xFF, 0xFA, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 
-0x90, 0x83, 0x47, 0x12, 0x49, 0x86, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xE0, 0x6B, 0x70, 0x08, 0xE9, 
-0x65, 0x82, 0x70, 0x03, 0xEA, 0x65, 0x83, 0x70, 0x03, 0x02, 0x80, 0xD3, 0x90, 0x83, 0x47, 0x12, 
-0x49, 0x86, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x70, 0x02, 0x01, 0xD3, 0x90, 0x83, 0x4A, 0x12, 
-0x49, 0x86, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 0x47, 0x12, 0x49, 0x86, 0x90, 0x00, 
-0x01, 0x12, 0x1F, 0xBD, 0xFF, 0x7E, 0x00, 0xE9, 0x24, 0x02, 0xF9, 0xE4, 0x3A, 0xFA, 0xE9, 0x2F, 
-0xF9, 0xEE, 0x3A, 0xFA, 0xD3, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xE0, 0xE9, 0x95, 0x82, 0xEA, 0x95, 
-0x83, 0x40, 0x02, 0x01, 0xD3, 0x90, 0x83, 0x47, 0x12, 0x49, 0x86, 0x12, 0x1F, 0xA4, 0xFF, 0xB4, 
-0x30, 0x36, 0x90, 0x83, 0x47, 0x12, 0x49, 0x86, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 
-0x44, 0x12, 0x49, 0x86, 0x90, 0x00, 0x04, 0x12, 0x49, 0xE7, 0x90, 0x83, 0x47, 0x12, 0x49, 0x86, 
-0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x24, 0x02, 0xFE, 0x90, 0x83, 0x44, 0x12, 0x49, 0x86, 0x90, 
-0x00, 0x07, 0xEE, 0x12, 0x1F, 0xFC, 0x80, 0x2F, 0xEF, 0xB4, 0xDD, 0x2B, 0x90, 0x83, 0x4A, 0x12, 
-0x49, 0x86, 0x90, 0x83, 0x8F, 0x12, 0x49, 0x8F, 0x90, 0x83, 0x44, 0x12, 0x49, 0x86, 0x90, 0x83, 
-0x92, 0x12, 0x49, 0x8F, 0x90, 0x83, 0x47, 0x12, 0x49, 0x86, 0x12, 0x7D, 0x7A, 0x90, 0x83, 0x4D, 
-0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x80, 0x1C, 0x90, 0x83, 0x47, 0x12, 0x49, 0x86, 0x90, 0x00, 0x01, 
-0x12, 0x1F, 0xBD, 0x24, 0x02, 0xFF, 0xE4, 0x33, 0x90, 0x83, 0x48, 0x8F, 0xF0, 0x12, 0x49, 0x4B, 
-0x02, 0x7F, 0x86, 0x90, 0x83, 0x4D, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0x90, 0x82, 0xF1, 0x12, 
-0x49, 0x8F, 0x90, 0x82, 0xF7, 0xE0, 0x60, 0x02, 0x21, 0xB0, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 
-0x12, 0x1F, 0xA4, 0xF4, 0x60, 0x02, 0x21, 0xA5, 0x12, 0x1F, 0xEA, 0x90, 0x82, 0xF4, 0x12, 0x49, 
-0x86, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xF4, 0x60, 0x02, 0x21, 0x95, 0x90, 0x00, 0x01, 0x12, 
-0x1F, 0xFC, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0xF4, 0x70, 0x6F, 0x90, 0x82, 0xF4, 0x12, 0x49, 
-0x86, 0x90, 0x00, 0x02, 0xE4, 0x12, 0x1F, 0xFC, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0xF4, 0x70, 
-0x4E, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x03, 0xE4, 0x12, 0x1F, 0xFC, 0x90, 0x00, 
-0x04, 0x12, 0x1F, 0xBD, 0xF4, 0x70, 0x2D, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x04, 
-0xE4, 0x12, 0x1F, 0xFC, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0x90, 0x82, 0xF4, 0xB4, 0xFF, 0x0C, 
-0x12, 0x49, 0x86, 0x90, 0x00, 0x05, 0xE4, 0x12, 0x1F, 0xFC, 0x80, 0x44, 0x12, 0x49, 0x86, 0x90, 
-0x00, 0x05, 0x80, 0x2A, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x04, 0x80, 0x1F, 0x90, 
-0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x03, 0x80, 0x14, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 
-0x90, 0x00, 0x02, 0x80, 0x09, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x01, 0x74, 0x01, 
-0x12, 0x49, 0x18, 0x80, 0x0B, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x74, 0x01, 0x12, 0x48, 0xF6, 
-0x90, 0x82, 0xF8, 0xE0, 0xFF, 0x64, 0x04, 0x60, 0x02, 0x41, 0x5F, 0x90, 0x82, 0xF4, 0x12, 0x49, 
-0x86, 0x12, 0x1F, 0xA4, 0xFE, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0xEE, 0x12, 0x1F, 0xEA, 0x90, 
-0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFE, 0x90, 0x82, 0xF1, 0x12, 
-0x49, 0x86, 0x90, 0x00, 0x01, 0xEE, 0x12, 0x1F, 0xFC, 0x90, 0x00, 0x02, 0xE4, 0x12, 0x1F, 0xFC, 
-0x90, 0x00, 0x03, 0x74, 0x20, 0x12, 0x1F, 0xFC, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 
-0x02, 0x12, 0x1F, 0xBD, 0xFE, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0x90, 0x00, 0x04, 0xEE, 0x12, 
-0x1F, 0xFC, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0xFE, 0x90, 
-0x82, 0xF1, 0x12, 0x49, 0x86, 0x90, 0x00, 0x05, 0xEE, 0x12, 0x1F, 0xFC, 0x90, 0x82, 0xF4, 0x12, 
-0x49, 0x86, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0xFE, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0x90, 
-0x00, 0x06, 0xEE, 0x12, 0x1F, 0xFC, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x05, 0x12, 
-0x1F, 0xBD, 0xFE, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0x90, 0x00, 0x07, 0xEE, 0x61, 0x1F, 0xEF, 
-0x64, 0x02, 0x60, 0x02, 0x61, 0x22, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x12, 0x1F, 0xA4, 0xFF, 
-0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0xEF, 0x12, 0x1F, 0xEA, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 
-0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x44, 0x20, 0x54, 0x7F, 0xFF, 0x90, 0x82, 0xF1, 0x12, 0x49, 
-0x86, 0x90, 0x00, 0x01, 0xEF, 0x12, 0x1F, 0xFC, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 
-0x01, 0x12, 0x1F, 0xBD, 0xFF, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0x90, 0x00, 0x02, 0xEF, 0x12, 
-0x1F, 0xFC, 0x90, 0x00, 0x03, 0x74, 0x20, 0x12, 0x1F, 0xFC, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 
-0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0xFF, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0x90, 0x00, 0x04, 
-0xEF, 0x12, 0x1F, 0xFC, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 
-0xFF, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0x90, 0x00, 0x05, 0xEF, 0x12, 0x1F, 0xFC, 0x90, 0x82, 
-0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0xFF, 0x90, 0x82, 0xF1, 0x12, 0x49, 
-0x86, 0x90, 0x00, 0x06, 0xEF, 0x12, 0x1F, 0xFC, 0x90, 0x82, 0xF4, 0x12, 0x49, 0x86, 0x90, 0x00, 
-0x05, 0x12, 0x1F, 0xBD, 0xFF, 0x90, 0x82, 0xF1, 0x12, 0x49, 0x86, 0x90, 0x00, 0x07, 0xEF, 0x12, 
-0x1F, 0xFC, 0x22, 0x00, 0xAF, 0x8C, 
+0xC0, 0xD0, 0x90, 0x82, 0x4F, 0xEE, 0xF0, 0xA3, 0x71, 0x78, 0x90, 0x82, 0x4F, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xF5, 0x82, 0x8E, 0x83, 0xE0, 0x60, 0x29, 0xC3, 0x90, 0x82, 0x52, 0xE0, 0x94, 0xE8, 0x90, 
+0x82, 0x51, 0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 
+0x80, 0x11, 0x90, 0x82, 0x51, 0x12, 0x5F, 0xB6, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x80, 
+0xC9, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 
+0x90, 0x81, 0xA9, 0x71, 0x78, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 
+0x90, 0x81, 0xA9, 0xE0, 0x6F, 0x60, 0x35, 0xC3, 0x90, 0x81, 0xAB, 0xE0, 0x94, 0x88, 0x90, 0x81, 
+0xAA, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x81, 
+0xAA, 0x12, 0x5F, 0xB6, 0x71, 0xCD, 0xD3, 0x90, 0x81, 0xAB, 0xE0, 0x94, 0x32, 0x90, 0x81, 0xAA, 
+0xE0, 0x94, 0x00, 0x40, 0xC0, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xB9, 0x22, 0x7F, 0x14, 0x7E, 
+0x00, 0x02, 0x32, 0xAA, 0xE0, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0x90, 0x81, 
+0x46, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x81, 0x54, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x32, 0x1E, 0x90, 
+0x81, 0x4A, 0xE0, 0x60, 0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 
+0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 0xFD, 0x7F, 0x08, 
+0x12, 0x32, 0x1E, 0x7F, 0x01, 0x71, 0x80, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x90, 
+0x12, 0x32, 0x1E, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x32, 0xAA, 0xE4, 0x90, 0x81, 0xA0, 0xF0, 0xA3, 
+0xF0, 0x90, 0x01, 0x98, 0xE0, 0x7F, 0x00, 0x30, 0xE4, 0x02, 0x7F, 0x01, 0xEF, 0x64, 0x01, 0x60, 
+0x3C, 0xC3, 0x90, 0x81, 0xA1, 0xE0, 0x94, 0x88, 0x90, 0x81, 0xA0, 0xE0, 0x94, 0x13, 0x40, 0x0F, 
+0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0xFD, 0xF0, 0x80, 0x1E, 0x90, 
+0x81, 0xA0, 0x12, 0x5F, 0xB6, 0x71, 0xCD, 0xD3, 0x90, 0x81, 0xA1, 0xE0, 0x94, 0x32, 0x90, 0x81, 
+0xA0, 0xE0, 0x94, 0x00, 0x40, 0xBB, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xB4, 0x90, 0x01, 0xC7, 
+0x74, 0xFE, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x11, 0x7F, 0xF5, 0x7E, 0x00, 0x12, 0x2B, 
+0x27, 0xBF, 0x01, 0x06, 0x90, 0x82, 0x11, 0xE0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x11, 
+0x7F, 0xF6, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0x11, 0xE0, 0x90, 0x82, 
+0x13, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x11, 0x7F, 0xF4, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 
+0x01, 0x08, 0x90, 0x82, 0x11, 0xE0, 0x90, 0x82, 0x14, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x11, 
+0x7F, 0xF3, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 0x01, 0x08, 0x90, 0x82, 0x11, 0xE0, 0x90, 0x82, 
+0x15, 0xF0, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x11, 0x7F, 0xF2, 0x7E, 0x00, 0x12, 0x2B, 0x27, 0xBF, 
+0x01, 0x08, 0x90, 0x82, 0x11, 0xE0, 0x90, 0x82, 0x16, 0xF0, 0x90, 0x82, 0x12, 0xE0, 0xFF, 0xA3, 
+0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 0x82, 0x1A, 0xF0, 0x90, 0x82, 0x16, 0xE0, 0x90, 
+0x82, 0x1B, 0xF0, 0x41, 0x7C, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 0x35, 0xF0, 0xBF, 0x01, 0x07, 
+0x91, 0x84, 0xE4, 0x90, 0x81, 0x35, 0xF0, 0x22, 0x90, 0x82, 0x3A, 0xEF, 0xF0, 0xAB, 0x05, 0x90, 
+0x82, 0x40, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x03, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 
+0x14, 0xB1, 0x7F, 0x90, 0x82, 0x3C, 0x12, 0x44, 0xCF, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x12, 
+0x44, 0xC2, 0xEC, 0x54, 0x0F, 0xFC, 0x90, 0x82, 0x40, 0x12, 0x20, 0xCE, 0x90, 0x82, 0x3A, 0xE0, 
+0x75, 0xF0, 0x08, 0xA4, 0x24, 0x60, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x12, 0x5F, 0x9C, 0xC0, 0x06, 
+0xC0, 0x07, 0x90, 0x82, 0x40, 0x12, 0x5E, 0xA0, 0xD0, 0x07, 0xD0, 0x06, 0x02, 0x2E, 0xA2, 0x12, 
+0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x22, 0x78, 0x10, 0x74, 0x01, 0xF2, 
+0x90, 0x02, 0x09, 0xE0, 0x78, 0x00, 0xF2, 0x08, 0x74, 0x20, 0xF2, 0x18, 0xE2, 0xFF, 0x30, 0xE0, 
+0x05, 0x08, 0xE2, 0x24, 0x80, 0xF2, 0xEF, 0xC3, 0x13, 0x90, 0xFD, 0x10, 0xF0, 0x78, 0x01, 0xE2, 
+0xF1, 0xB4, 0x78, 0x03, 0xF2, 0x64, 0x04, 0x60, 0x0D, 0xE2, 0xFF, 0x64, 0x08, 0x60, 0x07, 0xEF, 
+0x64, 0x0C, 0x60, 0x02, 0xE1, 0xAA, 0xE4, 0x78, 0x02, 0xF2, 0x78, 0x03, 0xE2, 0xFF, 0x18, 0xE2, 
+0xC3, 0x9F, 0x50, 0x25, 0xE2, 0xFD, 0x18, 0xE2, 0x2D, 0x90, 0x81, 0xA9, 0xF0, 0xE0, 0xFF, 0xF1, 
+0xB4, 0xFE, 0x74, 0x04, 0x2D, 0xF8, 0xEE, 0xF2, 0xEF, 0xB4, 0xFF, 0x06, 0x90, 0xFD, 0x10, 0xE0, 
+0x04, 0xF0, 0x78, 0x02, 0xE2, 0x04, 0xF2, 0x80, 0xD1, 0x78, 0x04, 0xE2, 0x78, 0x12, 0xF2, 0xFF, 
+0x78, 0x05, 0xE2, 0x78, 0x11, 0xF2, 0x78, 0x06, 0xE2, 0x78, 0x13, 0xF2, 0x78, 0x07, 0xE2, 0x78, 
+0x14, 0xF2, 0x78, 0x08, 0xE2, 0x78, 0x33, 0xF2, 0x78, 0x09, 0xE2, 0x78, 0x34, 0xF2, 0x78, 0x0A, 
+0xE2, 0x78, 0x35, 0xF2, 0x78, 0x0B, 0xE2, 0x78, 0x36, 0xF2, 0x78, 0x0C, 0xE2, 0x78, 0x37, 0xF2, 
+0x78, 0x0D, 0xE2, 0x78, 0x38, 0xF2, 0x78, 0x0E, 0xE2, 0x78, 0x39, 0xF2, 0x78, 0x0F, 0xE2, 0x78, 
+0x3A, 0xF2, 0xE4, 0x78, 0x15, 0xF2, 0xEF, 0x24, 0xF8, 0x60, 0x56, 0x24, 0xFC, 0x60, 0x4D, 0x24, 
+0x08, 0x60, 0x02, 0xE1, 0x8C, 0x78, 0x11, 0xE2, 0xB4, 0x01, 0x05, 0x12, 0x29, 0xC5, 0xE1, 0x91, 
+0x78, 0x11, 0xE2, 0xB4, 0x02, 0x05, 0x12, 0x11, 0xBD, 0xE1, 0x91, 0x78, 0x11, 0xE2, 0xB4, 0x03, 
+0x05, 0x12, 0x68, 0x03, 0xE1, 0x91, 0x78, 0x11, 0xE2, 0xB4, 0x10, 0x07, 0xF1, 0xBF, 0x12, 0x32, 
+0xAA, 0xE1, 0x91, 0x78, 0x11, 0xE2, 0xB4, 0x11, 0x07, 0xF1, 0xBF, 0x12, 0x32, 0x06, 0xE1, 0x91, 
+0x78, 0x11, 0xE2, 0xF4, 0x60, 0x02, 0xE1, 0x91, 0x18, 0xF2, 0xE1, 0x91, 0x78, 0x15, 0x74, 0x01, 
+0xF2, 0x78, 0x11, 0xE2, 0x64, 0x07, 0x60, 0x02, 0xE1, 0x75, 0x78, 0x34, 0xF1, 0xAD, 0x78, 0x08, 
+0x12, 0x20, 0xBB, 0xC0, 0x04, 0xB1, 0x84, 0x78, 0x33, 0xF1, 0xAD, 0xD0, 0x00, 0x12, 0x44, 0xC2, 
+0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x78, 0x35, 0xF1, 0xAD, 0x78, 0x10, 0x12, 0x20, 
+0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0x78, 0x18, 0x12, 0x44, 
+0xF4, 0x78, 0x15, 0xE2, 0x60, 0x79, 0x18, 0xE2, 0xFF, 0x18, 0xE2, 0xFD, 0xF1, 0xD2, 0x78, 0x1C, 
+0x12, 0x44, 0xF4, 0x78, 0x38, 0xF1, 0xAD, 0x78, 0x08, 0x12, 0x20, 0xBB, 0xC0, 0x04, 0xB1, 0x84, 
+0x78, 0x37, 0xF1, 0xAD, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 
+0x07, 0x78, 0x39, 0xF1, 0xAD, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 
+0xD0, 0x00, 0x12, 0x44, 0xC2, 0x78, 0x20, 0x12, 0x44, 0xF4, 0x78, 0x20, 0x12, 0x44, 0xDB, 0x12, 
+0x20, 0x9B, 0x78, 0x1C, 0x12, 0x44, 0xE7, 0x12, 0x44, 0xB5, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 
+0xC0, 0x07, 0x78, 0x18, 0x12, 0x44, 0xDB, 0x78, 0x20, 0x12, 0x44, 0xE7, 0x12, 0x44, 0xB5, 0xD0, 
+0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x44, 0xC2, 0x78, 0x18, 0x12, 0x44, 0xF4, 0x78, 
+0x18, 0x12, 0x44, 0xDB, 0x90, 0x82, 0x46, 0x12, 0x20, 0xCE, 0x78, 0x13, 0xE2, 0xFD, 0x08, 0xE2, 
+0xFF, 0xF1, 0xE1, 0x80, 0x1C, 0x78, 0x13, 0xE2, 0xFF, 0x08, 0xE2, 0xFD, 0x78, 0x11, 0xE2, 0xFB, 
+0x78, 0x15, 0xE2, 0x90, 0x82, 0x0B, 0xF0, 0x12, 0x6B, 0x2F, 0x80, 0x05, 0x78, 0x10, 0x74, 0x02, 
+0xF2, 0x78, 0x10, 0xE2, 0xFF, 0xC3, 0x94, 0x02, 0x50, 0x10, 0xEF, 0x60, 0x0A, 0x78, 0x02, 0xE2, 
+0xFF, 0x18, 0xE2, 0x2F, 0xF2, 0xA1, 0xAD, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0xE2, 0xFF, 0xE4, 
+0xFC, 0xFD, 0xFE, 0x22, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x78, 
+0x14, 0xE2, 0xFE, 0x18, 0xE2, 0xFD, 0xED, 0xFF, 0x78, 0x16, 0xEE, 0xF2, 0xFE, 0x08, 0xEF, 0xF2, 
+0xFF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x5E, 0xA9, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0x82, 0x46, 0x12, 
+0x44, 0xCF, 0x90, 0x82, 0x3C, 0x12, 0x20, 0xCE, 0xD0, 0x05, 0xD0, 0x07, 0xB1, 0x28, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xE4, 0x90, 0x81, 0xB9, 0xF0, 0x90, 0x87, 0x5F, 0xE0, 0x90, 0x81, 0xB8, 0xF0, 
+0xE4, 0x90, 0x81, 0xC5, 0xF0, 0x90, 0x81, 0xB5, 0xF0, 0x90, 0x81, 0xB5, 0xE0, 0xFF, 0xC3, 0x94, 
+0x40, 0x50, 0x10, 0x74, 0xC8, 0x2F, 0x71, 0x06, 0x74, 0xFF, 0xF0, 0x90, 0x81, 0xB5, 0xE0, 0x04, 
+0xF0, 0x80, 0xE6, 0xE4, 0x90, 0x81, 0xB5, 0xF0, 0x90, 0x81, 0xB8, 0xE0, 0xFF, 0x90, 0x81, 0xB5, 
+0xE0, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0x21, 0x03, 0x74, 0xDF, 0x2E, 0xF9, 0xE4, 0x34, 0x86, 0x51, 
+0xFE, 0x75, 0x16, 0x0A, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xAA, 0x12, 0x2B, 0xED, 0x90, 0x81, 0xAB, 
+0xE0, 0xFF, 0x12, 0x2F, 0x27, 0xEF, 0x04, 0x90, 0x81, 0xC5, 0xF0, 0x90, 0x81, 0xAA, 0xE0, 0xFF, 
+0xA3, 0xE0, 0xFD, 0x12, 0x31, 0xEA, 0xEF, 0x24, 0xC8, 0x90, 0x81, 0xC7, 0xF0, 0x75, 0xF0, 0x08, 
+0xA4, 0xF0, 0x90, 0x81, 0xAB, 0xE0, 0x54, 0x0F, 0x90, 0x81, 0xC6, 0xF0, 0xE4, 0x90, 0x81, 0xB4, 
+0xF0, 0x90, 0x81, 0xB6, 0xF0, 0x90, 0x81, 0xB6, 0xE0, 0xFF, 0xC3, 0x94, 0x04, 0x50, 0x57, 0x90, 
+0x81, 0xC6, 0xE0, 0xFE, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x13, 0xD8, 0xFC, 0x20, 0xE0, 0x3E, 
+0x90, 0x81, 0xB6, 0xE0, 0x25, 0xE0, 0xFF, 0x90, 0x81, 0xC7, 0xE0, 0x2F, 0x24, 0xC8, 0xF9, 0xE4, 
+0x34, 0x81, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x01, 0x90, 0x81, 0xB4, 0xE0, 0x75, 0xF0, 0x02, 
+0xA4, 0x24, 0xAC, 0xF9, 0x74, 0x81, 0x35, 0xF0, 0x8B, 0x13, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 
+0x02, 0xD0, 0x01, 0xD0, 0x03, 0x12, 0x2B, 0xED, 0x90, 0x81, 0xB4, 0xE0, 0x04, 0xF0, 0x90, 0x81, 
+0xB6, 0xE0, 0x04, 0xF0, 0x80, 0x9F, 0x90, 0x81, 0xC5, 0xE0, 0xFF, 0x90, 0x81, 0xB5, 0xE0, 0x2F, 
+0xF0, 0x01, 0x38, 0xE4, 0x90, 0x81, 0xB9, 0xF0, 0x90, 0x81, 0xB9, 0xE0, 0xC3, 0x94, 0x40, 0x40, 
+0x02, 0x41, 0xAB, 0xE0, 0xFF, 0x24, 0xC8, 0x71, 0x06, 0xE0, 0x90, 0x81, 0xBB, 0xF0, 0xE0, 0xFE, 
+0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFD, 0x90, 0x81, 0xBA, 0xF0, 0xEE, 0x54, 0x0F, 0xFE, 0xA3, 0xF0, 
+0x74, 0xC9, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0x90, 0x81, 0xBC, 0xF0, 0xFC, 
+0xEE, 0xFE, 0xEC, 0xFB, 0xEB, 0xFF, 0x90, 0x81, 0xC1, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xED, 0x12, 
+0x45, 0x1E, 0x69, 0x77, 0x00, 0x69, 0xA9, 0x01, 0x6A, 0x16, 0x02, 0x6A, 0x9C, 0x03, 0x6A, 0x21, 
+0x04, 0x6A, 0x32, 0x05, 0x6A, 0x32, 0x06, 0x6A, 0x32, 0x07, 0x6A, 0x32, 0x08, 0x6A, 0x7A, 0x09, 
+0x6A, 0x8B, 0x0A, 0x00, 0x00, 0x6A, 0xAB, 0x90, 0x81, 0xB9, 0xE0, 0xFD, 0x24, 0xCB, 0xF5, 0x82, 
+0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0xCA, 0x2D, 0x51, 0xEB, 0xE0, 0xFD, 0xED, 0xFF, 
+0x90, 0x81, 0xC3, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0x90, 0x81, 0xBC, 0xE0, 0xFF, 0x12, 0x2F, 
+0x96, 0x90, 0x81, 0xB7, 0x74, 0x02, 0xF0, 0x41, 0x9C, 0x51, 0xAC, 0x12, 0x44, 0xC2, 0xC0, 0x04, 
+0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x81, 0xB9, 0xE0, 0x24, 0xCC, 0xF5, 0x82, 0xE4, 0x34, 
+0x81, 0x51, 0xD7, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 
+0x12, 0x44, 0xC2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x81, 0xB9, 0xE0, 0x24, 
+0xCD, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0x51, 0xD7, 0x78, 0x18, 0x12, 0x20, 0xBB, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0x71, 0x0E, 0x90, 0x81, 0xBD, 0x12, 0x44, 0xCF, 0x90, 0x85, 0x96, 
+0x12, 0x20, 0xCE, 0x90, 0x81, 0xC1, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x2E, 0xE4, 0x90, 0x81, 
+0xB7, 0x74, 0x04, 0xF0, 0x41, 0x9C, 0x51, 0xE0, 0xE0, 0xFB, 0xE4, 0xFF, 0x12, 0x30, 0xC7, 0x80, 
+0x09, 0x51, 0xE0, 0xE0, 0xFB, 0xE4, 0xFF, 0x12, 0x30, 0x6A, 0x90, 0x81, 0xB7, 0x74, 0x01, 0xF0, 
+0x80, 0x6A, 0x90, 0x81, 0xB7, 0x74, 0x02, 0xF0, 0x51, 0xAC, 0x12, 0x44, 0xC2, 0xC0, 0x04, 0xC0, 
+0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x81, 0xBB, 0x51, 0xD9, 0x78, 0x10, 0x12, 0x20, 0xBB, 0xD0, 
+0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x71, 0x0E, 0x90, 0x81, 0xBA, 0xE0, 0x24, 0xFB, 0xFF, 
+0xC0, 0x07, 0x90, 0x81, 0xBD, 0x12, 0x44, 0xCF, 0x90, 0x82, 0x46, 0x12, 0x20, 0xCE, 0x90, 0x81, 
+0xBC, 0xE0, 0xFD, 0xD0, 0x07, 0x12, 0x67, 0xE1, 0x80, 0x22, 0x90, 0x81, 0xB7, 0x74, 0x01, 0x51, 
+0xF3, 0x75, 0x16, 0x01, 0x71, 0x17, 0xF0, 0x7B, 0x04, 0x80, 0x0F, 0x90, 0x81, 0xB7, 0x74, 0x04, 
+0x51, 0xF3, 0x75, 0x16, 0x04, 0x71, 0x17, 0xF0, 0x7B, 0x06, 0x71, 0x2F, 0x90, 0x81, 0xB7, 0xE0, 
+0x24, 0x02, 0xFF, 0x90, 0x81, 0xB9, 0xE0, 0x2F, 0xF0, 0x21, 0x08, 0x22, 0x90, 0x81, 0xB9, 0xE0, 
+0x24, 0xCB, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 
+0x08, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x81, 0xB9, 0xE0, 
+0x24, 0xCA, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x22, 
+0x90, 0x81, 0xBC, 0xE0, 0xFD, 0x90, 0x81, 0xB9, 0xE0, 0x24, 0xCA, 0xF5, 0x82, 0xE4, 0x34, 0x81, 
+0xF5, 0x83, 0x22, 0xF0, 0x90, 0x81, 0xB9, 0xE0, 0x24, 0xCA, 0xF9, 0xE4, 0x34, 0x81, 0x75, 0x13, 
+0x01, 0xF5, 0x14, 0x89, 0x15, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 0x12, 0x44, 
+0xC2, 0x90, 0x81, 0xBD, 0x02, 0x20, 0xCE, 0x7B, 0xFE, 0x7A, 0x80, 0x79, 0x33, 0x12, 0x2B, 0xED, 
+0x90, 0x81, 0xBC, 0xE0, 0xFF, 0x90, 0x81, 0xBB, 0xE0, 0xFD, 0xE4, 0x90, 0x82, 0x0B, 0x22, 0xAC, 
+0x07, 0xED, 0xAD, 0x04, 0x78, 0x24, 0xF2, 0xED, 0x08, 0xF2, 0xEB, 0xB4, 0x04, 0x07, 0x78, 0x27, 
+0x74, 0x01, 0xF2, 0x80, 0x0E, 0xEB, 0x78, 0x27, 0xB4, 0x05, 0x05, 0x74, 0x02, 0xF2, 0x80, 0x03, 
+0x74, 0x04, 0xF2, 0x91, 0x71, 0xE2, 0x94, 0x00, 0x50, 0x45, 0xE4, 0x78, 0x26, 0xF2, 0x91, 0x4B, 
+0x9F, 0x40, 0x02, 0x81, 0x4A, 0x91, 0x54, 0x60, 0x1F, 0x74, 0x37, 0x2E, 0xF8, 0xE2, 0x78, 0x32, 
+0xF2, 0xEE, 0xFF, 0x78, 0x25, 0xE2, 0x2F, 0xFF, 0x18, 0xE2, 0x34, 0x00, 0x8F, 0x82, 0xF5, 0x83, 
+0xE0, 0x78, 0x29, 0xF2, 0x78, 0x32, 0x91, 0x87, 0x78, 0x24, 0x08, 0xE2, 0xFF, 0x08, 0xE2, 0x2F, 
+0xFF, 0x78, 0x28, 0xE2, 0xFD, 0x12, 0x32, 0x1E, 0x78, 0x26, 0xE2, 0x04, 0xF2, 0x80, 0xBF, 0x91, 
+0x71, 0xE2, 0x94, 0x07, 0x50, 0x30, 0xE4, 0x78, 0x26, 0xF2, 0x91, 0x4B, 0x9F, 0x40, 0x02, 0x81, 
+0x4A, 0x91, 0x54, 0x60, 0x14, 0x78, 0x26, 0xE2, 0xFF, 0x91, 0x79, 0xE0, 0x78, 0x29, 0xF2, 0x74, 
+0x37, 0x2F, 0xF8, 0xE2, 0x78, 0x32, 0xF2, 0x91, 0x87, 0x91, 0x69, 0x91, 0x79, 0xEF, 0xF0, 0x78, 
+0x26, 0xE2, 0x04, 0xF2, 0x80, 0xD4, 0x90, 0x82, 0x0B, 0xE0, 0x60, 0x0A, 0x91, 0x61, 0x12, 0x2D, 
+0x5C, 0x78, 0x2E, 0x12, 0x44, 0xF4, 0xE4, 0x78, 0x26, 0xF2, 0x91, 0x4B, 0x9F, 0x50, 0x4E, 0x91, 
+0x54, 0x60, 0x2B, 0x78, 0x2E, 0x12, 0x44, 0xDB, 0x78, 0x26, 0xE2, 0xFB, 0x75, 0xF0, 0x08, 0xA4, 
+0xF9, 0xF8, 0x12, 0x20, 0xA8, 0x78, 0x29, 0xEF, 0xF2, 0x74, 0x37, 0x2B, 0xF8, 0xE2, 0x78, 0x32, 
+0xF2, 0xE2, 0xFE, 0xF4, 0x5F, 0xFF, 0x78, 0x28, 0xE2, 0xFD, 0xEE, 0x5D, 0x4F, 0xF2, 0x91, 0x69, 
+0xFD, 0xC3, 0x74, 0x03, 0x9D, 0xFD, 0xE4, 0x94, 0x00, 0xFC, 0x7B, 0xFE, 0x74, 0x2A, 0x2D, 0xF9, 
+0x74, 0x80, 0x3C, 0xFA, 0xEF, 0x12, 0x1F, 0xEA, 0xE2, 0x04, 0xF2, 0x80, 0xAD, 0x78, 0x2A, 0x12, 
+0x44, 0xDB, 0x12, 0x5E, 0xA3, 0x91, 0x61, 0x12, 0x2E, 0xA2, 0x22, 0x78, 0x27, 0xE2, 0xFF, 0x18, 
+0xE2, 0xFE, 0xC3, 0x22, 0x74, 0x33, 0x2E, 0xF8, 0xE2, 0x78, 0x28, 0xF2, 0x90, 0x82, 0x0B, 0xE0, 
+0x22, 0x78, 0x24, 0xE2, 0xFE, 0x08, 0xE2, 0xFF, 0x22, 0x78, 0x28, 0xE2, 0xFF, 0x78, 0x26, 0xE2, 
+0x22, 0xD3, 0x78, 0x25, 0xE2, 0x94, 0xFF, 0x18, 0x22, 0xFD, 0x18, 0xE2, 0x2D, 0xFD, 0x18, 0xE2, 
+0x34, 0x00, 0x8D, 0x82, 0xF5, 0x83, 0x22, 0xE2, 0xFF, 0xF4, 0xFE, 0x78, 0x29, 0xE2, 0x5E, 0xFE, 
+0x18, 0xE2, 0xFD, 0xEF, 0x5D, 0x4E, 0xF2, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 
+0x2D, 0xA7, 0xE4, 0xF5, 0x51, 0x12, 0x32, 0x9E, 0xEF, 0x60, 0x72, 0x63, 0x51, 0x01, 0xE5, 0x51, 
+0x24, 0x98, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x6C, 0xA3, 0xF0, 0x90, 0x00, 0x88, 0xE0, 0xF5, 0x4F, 
+0xF5, 0x50, 0x54, 0x0F, 0x60, 0xDF, 0xE5, 0x4F, 0x30, 0xE0, 0x0B, 0x20, 0xE4, 0x03, 0x12, 0x29, 
+0xC5, 0x53, 0x50, 0xEE, 0x80, 0x3E, 0xE5, 0x4F, 0x30, 0xE1, 0x16, 0x20, 0xE5, 0x0E, 0x12, 0x11, 
+0xBD, 0xEF, 0x70, 0x03, 0x43, 0x50, 0x20, 0x90, 0x01, 0x06, 0xE4, 0xF0, 0x53, 0x50, 0xFD, 0x80, 
+0x23, 0xE5, 0x4F, 0x30, 0xE2, 0x0A, 0x20, 0xE6, 0x02, 0x11, 0x03, 0x53, 0x50, 0xFB, 0x80, 0x14, 
+0xE5, 0x4F, 0x30, 0xE3, 0x0F, 0x20, 0xE7, 0x09, 0x12, 0x65, 0x8B, 0xEF, 0x70, 0x03, 0x43, 0x50, 
+0x80, 0x53, 0x50, 0xF7, 0xAD, 0x50, 0x7F, 0x88, 0x12, 0x32, 0x1E, 0x80, 0x88, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 0x90, 0x81, 0x96, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 
+0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x54, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x8C, 0xF0, 
+0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x94, 0x12, 0x53, 0x47, 0x90, 0x81, 0x95, 0xF0, 0x22, 0xE4, 
+0x90, 0x81, 0x31, 0xF0, 0xA3, 0xF0, 0x90, 0x80, 0x99, 0xF0, 0xA3, 0xF0, 0x22, 0x22, 0x22, 0x75, 
+0x3D, 0x10, 0xE4, 0xF5, 0x3E, 0x75, 0x3F, 0x07, 0x75, 0x40, 0x02, 0x90, 0x01, 0x30, 0xE5, 0x3D, 
+0xF0, 0xA3, 0xE5, 0x3E, 0xF0, 0xA3, 0xE5, 0x3F, 0xF0, 0xA3, 0xE5, 0x40, 0xF0, 0x22, 0x75, 0x45, 
+0x06, 0x75, 0x46, 0x01, 0x43, 0x46, 0x10, 0x75, 0x47, 0x03, 0x75, 0x48, 0x62, 0x90, 0x01, 0x38, 
+0xE5, 0x45, 0xF0, 0xA3, 0xE5, 0x46, 0xF0, 0xA3, 0xE5, 0x47, 0xF0, 0xA3, 0xE5, 0x48, 0xF0, 0x22, 
+0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x01, 
+0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9C, 0x74, 0x7E, 0xF0, 0xA3, 0x74, 0x92, 0xF0, 0xA3, 0x74, 
+0xA0, 0xF0, 0xA3, 0x74, 0x24, 0xF0, 0x90, 0x01, 0x9B, 0x74, 0x49, 0xF0, 0x90, 0x01, 0x9A, 0x74, 
+0xE0, 0xF0, 0x90, 0x01, 0x99, 0xE4, 0xF0, 0x90, 0x01, 0x98, 0x04, 0xF0, 0x22, 0x7D, 0x02, 0x90, 
+0x01, 0xC4, 0x74, 0xDD, 0xF0, 0x74, 0x6D, 0xA3, 0xF0, 0x90, 0x81, 0x93, 0xE0, 0xFF, 0xED, 0xC3, 
+0x9F, 0x50, 0x14, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x07, 0xD1, 0x15, 0xA3, 
+0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xE2, 0x74, 0xDD, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x6D, 
+0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x22, 0xD1, 0xD7, 0xEF, 0x64, 
+0x01, 0x60, 0x04, 0xD1, 0x8D, 0x80, 0x5D, 0x90, 0x81, 0x4D, 0xE0, 0xFF, 0x54, 0x03, 0x60, 0x08, 
+0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x4C, 0x90, 0x81, 0x4B, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 
+0x50, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x3A, 0xEF, 0x30, 0xE2, 0x04, 0xD1, 0x15, 
+0x80, 0x32, 0x90, 0x81, 0x4D, 0xE0, 0x30, 0xE4, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 
+0x23, 0x90, 0x81, 0x46, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 
+0x20, 0xF0, 0x80, 0x10, 0x90, 0x81, 0x8C, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 0xF0, 
+0x80, 0x02, 0x80, 0x4B, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x01, 0xB8, 
+0x74, 0x01, 0xF0, 0x22, 0x90, 0x81, 0x8F, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x27, 0x90, 0x02, 0x87, 
+0xE0, 0x60, 0x04, 0xD1, 0x8D, 0x80, 0x1F, 0x90, 0x02, 0x96, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 
+0x74, 0x10, 0xF0, 0x80, 0x11, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x08, 0x90, 0x01, 0xB8, 0x74, 
+0x04, 0xF0, 0x80, 0x02, 0x80, 0x09, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 0x90, 
+0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 
+0x22, 0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 
+0xD1, 0xD7, 0xEF, 0x70, 0x03, 0x12, 0x4F, 0xBD, 0x22, 0x90, 0x01, 0xE4, 0x74, 0x14, 0xF0, 0xA3, 
+0xE4, 0xF0, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x3D, 0xF5, 0x41, 0xA3, 0xE0, 0x55, 0x3E, 0xF5, 
+0x42, 0xA3, 0xE0, 0x55, 0x3F, 0xF5, 0x43, 0xA3, 0xE0, 0x55, 0x40, 0xF5, 0x44, 0x90, 0x01, 0x34, 
+0xE5, 0x41, 0xF0, 0xA3, 0xE5, 0x42, 0xF0, 0xA3, 0xE5, 0x43, 0xF0, 0xA3, 0xE5, 0x44, 0xF0, 0x22, 
+0x90, 0x01, 0x3C, 0xE0, 0x55, 0x45, 0xF5, 0x49, 0xA3, 0xE0, 0x55, 0x46, 0xF5, 0x4A, 0xA3, 0xE0, 
+0x55, 0x47, 0xF5, 0x4B, 0xA3, 0xE0, 0x55, 0x48, 0xF5, 0x4C, 0x90, 0x01, 0x3C, 0xE5, 0x49, 0xF0, 
+0xA3, 0xE5, 0x4A, 0xF0, 0xA3, 0xE5, 0x4B, 0xF0, 0xA3, 0xE5, 0x4C, 0xF0, 0x53, 0x91, 0xDF, 0x22, 
+0x90, 0x01, 0xCF, 0xE0, 0x90, 0x82, 0x6D, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 
+0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 
+0x01, 0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x52, 0x7C, 0x90, 0x00, 0x03, 
+0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x32, 0x1E, 0x80, 0xFE, 0x22, 0x90, 0x81, 0x40, 0xE0, 
+0x30, 0xE0, 0x05, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x81, 0x95, 0xE0, 0x60, 0x0F, 0xE4, 
+0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x05, 0xFC, 0xE0, 0x04, 0xF0, 0x90, 0x81, 
+0x40, 0xE0, 0x30, 0xE0, 0x11, 0xA3, 0x74, 0x01, 0xF0, 0x90, 0x81, 0x40, 0xE0, 0xFF, 0xC3, 0x13, 
+0x30, 0xE0, 0x03, 0x12, 0x5C, 0x5C, 0x12, 0x74, 0xCF, 0x90, 0x81, 0x8D, 0xE0, 0x30, 0xE0, 0x14, 
+0x12, 0x4F, 0x43, 0x12, 0x55, 0xE5, 0x90, 0x81, 0x8D, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x03, 0x12, 
+0x4D, 0xF9, 0xF1, 0xF5, 0x22, 0x90, 0x81, 0x8D, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x90, 0x81, 0x8D, 
+0xE0, 0x30, 0xE0, 0x0A, 0xE4, 0xF5, 0x1D, 0xA3, 0x12, 0x47, 0x84, 0x12, 0x6F, 0xF5, 0x90, 0x81, 
+0x8D, 0xE0, 0x30, 0xE0, 0x34, 0x90, 0x82, 0x69, 0xE0, 0x70, 0x37, 0x90, 0x82, 0x68, 0xE0, 0x04, 
+0xF0, 0xE0, 0xD3, 0x94, 0x06, 0x40, 0x2B, 0x90, 0x81, 0x54, 0x74, 0xD0, 0xF0, 0x90, 0x82, 0x69, 
+0x74, 0x01, 0xF0, 0x90, 0x81, 0x8D, 0xE0, 0x13, 0x30, 0xE0, 0x17, 0x90, 0x81, 0x45, 0xE0, 0x44, 
+0x01, 0xF0, 0x90, 0x81, 0x54, 0x74, 0xD0, 0xF0, 0x22, 0xE4, 0x90, 0x82, 0x69, 0xF0, 0x90, 0x82, 
+0x68, 0xF0, 0x22, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x06, 0x90, 0x81, 0x42, 0x74, 0x01, 0xF0, 
+0x90, 0x81, 0x49, 0xE0, 0x60, 0x26, 0x11, 0xA3, 0x30, 0xE0, 0x0A, 0x90, 0x01, 0x3B, 0xE0, 0x30, 
+0xE4, 0x03, 0x12, 0x49, 0x7C, 0x90, 0x82, 0x6C, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x80, 0x40, 
+0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0x6F, 0xFD, 0x90, 
+0x81, 0x8F, 0xE0, 0x30, 0xE0, 0x0C, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x05, 0x12, 0x49, 0x7C, 
+0x11, 0xAE, 0x22, 0x90, 0x81, 0x46, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x90, 0x81, 
+0x91, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 0x90, 0x81, 0x40, 0xE0, 0xFF, 0x30, 0xE0, 0x05, 0x12, 
+0x5B, 0xBB, 0x60, 0x1B, 0x90, 0x81, 0x49, 0xE0, 0x70, 0x04, 0xEF, 0x30, 0xE0, 0x0B, 0x90, 0x81, 
+0x4C, 0xE0, 0x64, 0x02, 0x60, 0x09, 0x12, 0x56, 0xB2, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 
+0x31, 0x99, 0x90, 0x81, 0x9C, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 0x01, 0xE4, 0x80, 0x02, 0xE4, 
+0xFD, 0xFF, 0x12, 0x4D, 0xFD, 0x90, 0x81, 0x9C, 0xE0, 0x30, 0xE6, 0x11, 0x90, 0x01, 0x2F, 0xE0, 
+0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 0x90, 0x81, 0x45, 
+0xE0, 0x90, 0x04, 0xEC, 0x30, 0xE0, 0x06, 0xE0, 0x54, 0xDD, 0xF0, 0x80, 0x04, 0xE0, 0x44, 0x22, 
+0xF0, 0x90, 0x81, 0x5B, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x90, 0x81, 0x62, 0xE0, 0xFB, 0xAC, 0x07, 
+0x90, 0x81, 0x45, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x81, 0x7F, 0xE0, 0x24, 0x04, 0x90, 0x81, 0x5E, 
+0xF0, 0x90, 0x81, 0x7F, 0xE0, 0x24, 0x03, 0x90, 0x81, 0x5D, 0xF0, 0x80, 0x0B, 0x90, 0x81, 0x5E, 
+0x74, 0x02, 0xF0, 0x90, 0x81, 0x5D, 0x14, 0xF0, 0x90, 0x81, 0x5D, 0xE0, 0xFA, 0x90, 0x81, 0x5C, 
+0xE0, 0xD3, 0x9A, 0x50, 0x09, 0x90, 0x81, 0x51, 0xEB, 0x31, 0x91, 0x2C, 0x80, 0x0B, 0xAD, 0x02, 
+0xC3, 0xED, 0x9D, 0x2B, 0x90, 0x81, 0x51, 0x31, 0x91, 0x90, 0x81, 0x61, 0xF0, 0x90, 0x81, 0x61, 
+0xE0, 0xFF, 0x7E, 0x00, 0x90, 0x81, 0x55, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x05, 0x58, 0xF0, 
+0x22, 0xF0, 0x90, 0x81, 0x5E, 0xE0, 0xC3, 0x9D, 0x22, 0xE4, 0x90, 0x81, 0x9D, 0xF0, 0xA3, 0xF0, 
+0xA3, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0x90, 0x81, 0x9D, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 0x90, 
+0x81, 0x9D, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x81, 0x9F, 0xE0, 0x94, 0x64, 0x90, 
+0x81, 0x9E, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x81, 
+0x9D, 0xE0, 0xFF, 0x22, 0x90, 0x81, 0x9E, 0x12, 0x5F, 0xB6, 0x80, 0xC6, 0x90, 0x81, 0x94, 0xE0, 
+0x60, 0x0F, 0xE4, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x05, 0xFD, 0xE0, 0x04, 
+0xF0, 0x22, 0x90, 0x81, 0x40, 0xE0, 0xFF, 0x30, 0xE0, 0x3F, 0x90, 0x81, 0x44, 0xE0, 0x7E, 0x00, 
+0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x81, 0x43, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 
+0xED, 0x4E, 0x70, 0x25, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x03, 0x02, 0x5C, 0x5C, 0x12, 0x5B, 0xA4, 
+0x90, 0x81, 0x44, 0xE0, 0xB4, 0x08, 0x06, 0xE4, 0xFD, 0x7F, 0x0C, 0x80, 0x09, 0x90, 0x81, 0x44, 
+0xE0, 0x70, 0x06, 0xFD, 0x7F, 0x04, 0x12, 0x4B, 0xBE, 0x22, 0x90, 0x81, 0x40, 0xE0, 0xFF, 0x30, 
+0xE0, 0x3F, 0x90, 0x81, 0x44, 0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x81, 0x43, 
+0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x25, 0xEF, 0xC3, 0x13, 0x30, 
+0xE0, 0x03, 0x02, 0x5C, 0x5C, 0x51, 0x82, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x0C, 0x06, 0xE4, 0xFD, 
+0x7F, 0x08, 0x80, 0x0A, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x04, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x4B, 
+0xBE, 0x22, 0x90, 0x01, 0x57, 0xE0, 0x60, 0x1B, 0x51, 0xB1, 0xF0, 0x51, 0xA4, 0x30, 0xE0, 0x02, 
+0x80, 0x27, 0x51, 0xC5, 0x9F, 0x40, 0x0C, 0xE4, 0xFF, 0x12, 0x52, 0xC9, 0xBF, 0x01, 0x04, 0x12, 
+0x57, 0xDB, 0xF0, 0x22, 0x90, 0x81, 0x45, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x22, 0x90, 0x01, 
+0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0x22, 0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x4D, 
+0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x81, 0x52, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x4D, 0xE0, 0x54, 
+0xEF, 0xF0, 0x90, 0x81, 0x86, 0xE0, 0xFF, 0x90, 0x81, 0x52, 0xE0, 0xD3, 0x22, 0x22, 0x90, 0x81, 
+0x45, 0xE0, 0xFF, 0x71, 0x0D, 0x30, 0xE0, 0x24, 0xEF, 0x54, 0x7F, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 
+0x90, 0x81, 0x46, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x07, 0xE0, 0x54, 0xFD, 0x71, 
+0x14, 0x04, 0xF0, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x03, 0x12, 0x58, 0x53, 0x22, 0xC4, 0x13, 0x13, 
+0x13, 0x54, 0x01, 0x22, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x22, 0x90, 
+0x01, 0xC4, 0x74, 0x1F, 0xF0, 0x74, 0x73, 0xA3, 0xF0, 0x90, 0x00, 0x90, 0xE0, 0x20, 0xE0, 0xF9, 
+0x74, 0x1F, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x73, 0xA3, 0xF0, 0x22, 0x74, 0x45, 0x71, 0x43, 
+0x02, 0x49, 0x6D, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0x22, 0x90, 0x81, 0x45, 0xE0, 0x54, 
+0xFB, 0xF0, 0xE4, 0x90, 0x81, 0x52, 0xF0, 0xA3, 0xF0, 0x90, 0x81, 0x4D, 0xF0, 0x90, 0x81, 0x46, 
+0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 0x12, 0x49, 0x06, 0x7D, 0x02, 0x7F, 0x02, 0x12, 0x49, 
+0x0A, 0x7D, 0x10, 0x7F, 0x03, 0x80, 0xC5, 0x71, 0xAC, 0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 0xE4, 
+0xF0, 0x90, 0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0xF5, 0x1D, 
+0x90, 0x81, 0x88, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0xF5, 0x1E, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 
+0x01, 0x12, 0x47, 0x8E, 0x90, 0x81, 0x45, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x90, 0x81, 0x45, 0xE0, 
+0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x7E, 0x00, 0x7F, 0x41, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 
+0x79, 0x45, 0x12, 0x45, 0x44, 0x91, 0x6D, 0x12, 0x45, 0x44, 0x90, 0x81, 0x48, 0x74, 0x02, 0xF0, 
+0x90, 0x81, 0x4F, 0x14, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x90, 0x81, 0x55, 0xE4, 0xF0, 
+0xA3, 0x74, 0x02, 0xF0, 0x91, 0x57, 0xF0, 0xE4, 0xFD, 0xFF, 0x12, 0x4D, 0xFD, 0x7D, 0x0C, 0x7F, 
+0x02, 0x12, 0x4D, 0xFD, 0x12, 0x4D, 0xF9, 0x90, 0x80, 0x41, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 
+0x81, 0x54, 0x74, 0x99, 0xF0, 0x80, 0x29, 0xEF, 0xB4, 0x03, 0x08, 0x90, 0x81, 0x54, 0x74, 0x90, 
+0xF0, 0x80, 0x1D, 0x90, 0x81, 0x54, 0x74, 0x40, 0xF0, 0x90, 0x00, 0x2C, 0xE0, 0x54, 0x0F, 0xFF, 
+0xBF, 0x05, 0x08, 0x90, 0x81, 0x7F, 0x74, 0x02, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0x81, 0x7F, 0xF0, 
+0x12, 0x55, 0x14, 0x91, 0x57, 0xF0, 0x7E, 0x00, 0x7F, 0x02, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 
+0x79, 0x8A, 0x12, 0x45, 0x44, 0x91, 0x65, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x12, 0x4F, 
+0x43, 0xE4, 0x90, 0x81, 0x8C, 0xF0, 0x22, 0x90, 0x81, 0x7F, 0xE0, 0x24, 0x04, 0x90, 0x81, 0x61, 
+0xF0, 0xA3, 0x74, 0x08, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x22, 0x7E, 0x00, 0x7F, 
+0x04, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x8F, 0x22, 0xEF, 0x24, 0xFE, 0x60, 0x0B, 0x04, 
+0x70, 0x24, 0x90, 0x81, 0x4F, 0x74, 0x02, 0xF0, 0x80, 0x13, 0xED, 0x70, 0x06, 0x90, 0x81, 0x89, 
+0xE0, 0x80, 0x02, 0xED, 0x14, 0x90, 0x81, 0x4F, 0xF0, 0x90, 0x81, 0x4F, 0xE0, 0xA3, 0xF0, 0x90, 
+0x81, 0x46, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x7D, 0x2E, 0x7F, 0x6F, 0x12, 0x4D, 0xA9, 0x7D, 0x02, 
+0x7F, 0x01, 0x12, 0x4D, 0xFD, 0x12, 0x5F, 0xCC, 0x90, 0x81, 0x44, 0x74, 0x02, 0xF0, 0x22, 0x12, 
+0x4F, 0x43, 0x12, 0x4F, 0xD9, 0x12, 0x5E, 0x88, 0x90, 0x81, 0x44, 0x74, 0x04, 0xF0, 0x22, 0xE4, 
+0xF5, 0x4E, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x7B, 0x12, 0x47, 0xF3, 0x70, 0x76, 0x90, 0x81, 0x47, 
+0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 0x1E, 0x90, 0x81, 
+0x50, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x81, 0x52, 0xE0, 0x60, 0x0E, 0xEF, 0x70, 
+0x08, 0x90, 0x81, 0x4F, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x4E, 0x01, 0x90, 0x81, 0x40, 0xE0, 
+0x30, 0xE0, 0x12, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x02, 0x03, 0xE4, 0xF5, 0x4E, 0x12, 0x5B, 0x42, 
+0xEF, 0x70, 0x02, 0xF5, 0x4E, 0xE5, 0x4E, 0x60, 0x2A, 0xB1, 0x5C, 0x90, 0x81, 0x52, 0xE0, 0x60, 
+0x03, 0xB4, 0x01, 0x04, 0xB1, 0x54, 0x80, 0x08, 0xB1, 0x54, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 
+0xFF, 0x90, 0x81, 0x51, 0xE0, 0x2F, 0x12, 0x47, 0x85, 0x90, 0x81, 0x4C, 0xE0, 0x20, 0xE2, 0x03, 
+0x12, 0x4B, 0xBA, 0x22, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x52, 0xE0, 0x22, 0x90, 0x81, 0x4D, 0xE0, 
+0x44, 0x10, 0xF0, 0x22, 0xE4, 0x90, 0x81, 0x9C, 0xF0, 0x90, 0x81, 0x49, 0xE0, 0x60, 0x4B, 0x12, 
+0x47, 0xF3, 0x70, 0x46, 0xB1, 0xBB, 0xF0, 0x90, 0x81, 0x9C, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x81, 
+0x50, 0xF0, 0x90, 0x81, 0x40, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x81, 0x44, 0xE0, 0xB4, 0x02, 0x05, 
+0xE4, 0x90, 0x81, 0x9C, 0xF0, 0x12, 0x5B, 0x42, 0xEF, 0x70, 0x04, 0x90, 0x81, 0x9C, 0xF0, 0x90, 
+0x81, 0x9C, 0xE0, 0x60, 0x15, 0xB1, 0x5C, 0xE4, 0xF5, 0x1D, 0x90, 0x81, 0x51, 0x12, 0x47, 0x84, 
+0x90, 0x81, 0x4C, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x4B, 0xBA, 0x22, 0x90, 0x81, 0x4F, 0xE0, 0x90, 
+0x05, 0x73, 0x22, 0x90, 0x81, 0x8D, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 0xE4, 0xA3, 0xF0, 
+0x90, 0x81, 0x8D, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x90, 0x81, 0x43, 0xE0, 0x64, 0x02, 0x7F, 0x01, 
+0x60, 0x02, 0x7F, 0x00, 0x22, 0xE4, 0xFE, 0xEF, 0xC3, 0x13, 0xFD, 0xEF, 0x30, 0xE0, 0x02, 0x7E, 
+0x80, 0x90, 0xFD, 0x10, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 
+0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x22, 0xE0, 0x90, 
+0x01, 0xBA, 0xF0, 0x90, 0x81, 0x4B, 0xE0, 0x90, 0x01, 0xBB, 0x22, 0xEF, 0x13, 0x13, 0x13, 0x54, 
+0x1F, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0x22, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x22, 0x90, 
+0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0x22, 0xF0, 0x90, 0x81, 0x55, 0xA3, 0xE0, 
+0x90, 0x05, 0x58, 0xF0, 0x22, 0x7F, 0x70, 0x7E, 0x0E, 0x12, 0x2E, 0xA2, 0x90, 0x82, 0x46, 0x22, 
+0x8B, 0x52, 0x8A, 0x53, 0x89, 0x54, 0x22, 0x90, 0x81, 0x8F, 0xE0, 0x54, 0xFE, 0x4E, 0x22, 0x7D, 
+0x02, 0x7F, 0x02, 0x02, 0x49, 0x86, 0x4D, 0xFF, 0x90, 0x81, 0x40, 0xF0, 0xEE, 0x22, 0x3D, 0xA1, 
 };
-u4Byte ArrayLength_MP_8188E_FW_WoWLAN_S = 17222;
+u4Byte ArrayLength_MP_8188E_FW_NIC_89EM = 13968;
 
 
 void
-ODM_ReadFirmware_MP_8188E_FW_WoWLAN_S(
+ODM_ReadFirmware_MP_8188E_FW_NIC_89EM(
      IN   PDM_ODM_T    pDM_Odm,
      OUT  u1Byte       *pFirmware,
      OUT  u4Byte       *pFirmwareSize
 )
 {
-#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
-	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8188E_FW_WoWLAN_S;
+ #if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+     *((SIZE_PTR*)pFirmware) = (SIZE_PTR)Array_MP_8188E_FW_NIC_89EM;
 #else
-	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8188E_FW_WoWLAN_S, ArrayLength_MP_8188E_FW_WoWLAN_S);
+     ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8188E_FW_NIC_89EM, ArrayLength_MP_8188E_FW_NIC_89EM);
 #endif
-	*pFirmwareSize = ArrayLength_MP_8188E_FW_WoWLAN_S;
+     *pFirmwareSize = ArrayLength_MP_8188E_FW_NIC_89EM;
 }
 
 
-u1Byte Array_MP_8188E_FW_WoWLAN_T[] = {
-0xE1, 0x88, 0x30, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x01, 0x23, 0x32, 0x2A, 0x3D, 0x00, 0x00, 
-0x8C, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x02, 0x46, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0xE1, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+u1Byte Array_MP_8188E_FW_WoWLAN[] = {
+0xE1, 0x88, 0x30, 0x00, 0x14, 0x00, 0x00, 0x00, 0x09, 0x11, 0x20, 0x13, 0x2E, 0x3A, 0x00, 0x00, 
+0xEE, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x46, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0xE1, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-0x00, 0x00, 0x00, 0xE1, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x4F, 0xF5, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0xE1, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x57, 0xFC, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
@@ -4143,937 +2822,890 @@ u1Byte Array_MP_8188E_FW_WoWLAN_T[] = {
 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0xAF, 0xDF, 0xE4, 0xDE, 0xE2, 0x80, 0xA9, 0x88, 
 0xF0, 0xEF, 0x60, 0x01, 0x0E, 0x4E, 0x60, 0xAB, 0xED, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0x98, 
 0xF5, 0x82, 0xEB, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0x8E, 0x23, 0x23, 0x45, 0x82, 0x23, 0x90, 
-0x42, 0xE0, 0x73, 0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x44, 0x17, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 
-0x08, 0xAA, 0xE0, 0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 
-0x8C, 0xD2, 0x8C, 0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 
-0xB4, 0x40, 0x00, 0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 
-0xE6, 0x30, 0xE1, 0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 
-0xE5, 0x0C, 0xFF, 0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 
-0x81, 0xE6, 0x30, 0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 
-0x25, 0x0C, 0xF8, 0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 
-0xCD, 0xF8, 0xE8, 0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 
-0x40, 0x27, 0xE5, 0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 
-0x18, 0xE6, 0xCD, 0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 
-0x0C, 0x24, 0x86, 0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 
-0x04, 0xC2, 0xAF, 0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 
-0xE3, 0x04, 0x7F, 0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 
-0x78, 0x86, 0xA6, 0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 
-0xE4, 0x78, 0x80, 0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x47, 0x50, 
-0x74, 0x01, 0x93, 0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 
-0x8C, 0x79, 0xD2, 0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 
-0x22, 0x74, 0x81, 0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 
-0xD2, 0xAF, 0xAE, 0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 
-0x08, 0xE6, 0x18, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 
-0x19, 0xF7, 0x09, 0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 
-0x81, 0x05, 0x81, 0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 
-0xB5, 0x0C, 0x02, 0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 
-0xE7, 0x09, 0x09, 0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 
-0xF8, 0xEF, 0x2F, 0x04, 0x90, 0x47, 0x50, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 
-0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 
-0x30, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 
-0x74, 0x86, 0x2F, 0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x44, 0x60, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 
-0xE6, 0xBF, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 
-0xFC, 0xE9, 0x6C, 0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 
-0x05, 0x1F, 0xE5, 0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 
-0x18, 0x86, 0x01, 0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 
-0x07, 0x02, 0xAC, 0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 
-0xE5, 0x0C, 0xB5, 0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 
-0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 
-0x02, 0xD2, 0xE4, 0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x44, 
-0x5F, 0x8F, 0xF0, 0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 
-0x0D, 0x7F, 0x08, 0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x30, 0x50, 0x2E, 0x80, 0x07, 0x30, 0xF1, 
-0x06, 0xED, 0xF6, 0x60, 0x25, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 
-0x23, 0x0E, 0x30, 0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x12, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 
-0x13, 0x54, 0xEC, 0x4E, 0xF6, 0xD2, 0xAF, 0x02, 0x44, 0x60, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 
-0xF4, 0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0x02, 0x46, 0xFA, 0x02, 
-0x44, 0xF0, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 0x08, 
-0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 0xC4, 
-0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 0xE4, 
-0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x47, 0x3F, 0xE4, 0x7E, 0x01, 
-0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 0xA3, 
-0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 0xFA, 
-0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xF0, 
-0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 0x00, 
-0x41, 0x83, 0xF1, 0x00, 0x41, 0x83, 0xF2, 0x00, 0x41, 0x84, 0x04, 0x00, 0x41, 0x84, 0x05, 0x00, 
-0x59, 0xA7, 0x5F, 0xDF, 0x61, 0xAD, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 
-0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 
-0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x56, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0x12, 0x67, 0xE5, 
-0xE5, 0x3C, 0x30, 0xE7, 0x02, 0xF1, 0xAD, 0x74, 0x56, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x47, 
-0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 
-0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x7F, 0x01, 0x7E, 
-0x00, 0x12, 0x32, 0x06, 0x90, 0x00, 0xF2, 0xE0, 0x20, 0xE6, 0x0C, 0x90, 0x00, 0x05, 0xE0, 0x44, 
-0x80, 0xFD, 0x7F, 0x05, 0x12, 0x32, 0x1E, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 
-0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 
-0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xC8, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0x12, 
-0x68, 0x1F, 0xE5, 0x41, 0x30, 0xE3, 0x03, 0x12, 0x57, 0xA3, 0xE5, 0x41, 0x30, 0xE4, 0x03, 0x12, 
-0x57, 0x9C, 0xE5, 0x43, 0x30, 0xE0, 0x02, 0x11, 0x66, 0xE5, 0x43, 0x30, 0xE1, 0x03, 0x12, 0x68, 
-0x7C, 0xE5, 0x43, 0x30, 0xE2, 0x03, 0x12, 0x68, 0xF3, 0xE5, 0x43, 0x30, 0xE3, 0x03, 0x12, 0x6F, 
-0xD8, 0xE5, 0x43, 0x30, 0xE4, 0x03, 0x12, 0x6F, 0xF4, 0xE5, 0x43, 0x30, 0xE5, 0x03, 0x12, 0x6E, 
-0x88, 0xE5, 0x43, 0x30, 0xE6, 0x03, 0x12, 0x70, 0x23, 0xE5, 0x44, 0x30, 0xE1, 0x02, 0xF1, 0xDF, 
-0x74, 0xC8, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 
-0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 
-0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xE4, 0xF5, 0x19, 0x90, 0x81, 0x3E, 0xE0, 0x60, 0x72, 0x90, 
-0x80, 0xF9, 0xE0, 0x64, 0x01, 0x70, 0x6A, 0x90, 0x81, 0x3C, 0xE0, 0xC4, 0x54, 0x0F, 0x60, 0x22, 
-0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 0x1E, 0x90, 0x81, 0x45, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 
-0x06, 0x90, 0x81, 0x47, 0xE0, 0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 0x81, 0x44, 0xE0, 0xA3, 0xF0, 
-0x80, 0x00, 0x75, 0x19, 0x01, 0xE5, 0x19, 0x60, 0x38, 0x90, 0x81, 0x42, 0xE0, 0x44, 0x10, 0xF0, 
-0x90, 0x81, 0x47, 0xE0, 0x60, 0x03, 0xB4, 0x01, 0x09, 0xE4, 0xF5, 0x52, 0x90, 0x81, 0x47, 0xE0, 
-0x80, 0x0D, 0xE4, 0xF5, 0x52, 0x90, 0x81, 0x47, 0xE0, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 
-0x90, 0x81, 0x46, 0xE0, 0x2F, 0x12, 0x57, 0xF7, 0x90, 0x81, 0x41, 0xE0, 0x20, 0xE2, 0x02, 0x11, 
-0xE2, 0x22, 0x7D, 0x01, 0x7F, 0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x84, 0x01, 
-0xED, 0xF0, 0x90, 0x81, 0x3A, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x41, 
-0x3D, 0xEE, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x30, 0xE0, 0x02, 0x41, 0x3D, 0x90, 0x81, 0x41, 
-0xE0, 0xFE, 0x6F, 0x70, 0x02, 0x41, 0x3D, 0xEF, 0x70, 0x02, 0x21, 0xA5, 0x24, 0xFE, 0x70, 0x02, 
-0x21, 0xDE, 0x24, 0xFE, 0x60, 0x47, 0x24, 0xFC, 0x70, 0x02, 0x41, 0x18, 0x24, 0xFC, 0x60, 0x02, 
-0x41, 0x2D, 0xEE, 0xB4, 0x0E, 0x02, 0x51, 0xA9, 0x90, 0x81, 0x41, 0xE0, 0x70, 0x04, 0x7F, 0x01, 
-0x51, 0xCC, 0x90, 0x81, 0x41, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x88, 0x90, 0x81, 0x41, 0xE0, 0xB4, 
-0x04, 0x0D, 0x90, 0x84, 0x01, 0xE0, 0xFF, 0x60, 0x04, 0x71, 0xE7, 0x80, 0x02, 0xF1, 0x1F, 0x90, 
-0x81, 0x41, 0xE0, 0x64, 0x08, 0x60, 0x02, 0x41, 0x2D, 0x71, 0xA5, 0x41, 0x2D, 0x90, 0x81, 0x41, 
-0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0xCC, 0x90, 0x81, 0x41, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x88, 
-0x90, 0x81, 0x41, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 0x42, 0xBF, 0x01, 0x02, 0x51, 0xA9, 0x90, 0x81, 
-0x41, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0x41, 0x2D, 0x51, 0x42, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x41, 
-0x2D, 0x51, 0xF8, 0x41, 0x2D, 0x90, 0x81, 0x41, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 0x42, 0xBF, 0x01, 
-0x02, 0x51, 0xA9, 0x90, 0x81, 0x41, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x88, 0x90, 0x81, 0x41, 0xE0, 
-0xB4, 0x0C, 0x07, 0x51, 0x42, 0xBF, 0x01, 0x02, 0x51, 0xF8, 0x90, 0x81, 0x41, 0xE0, 0x64, 0x04, 
-0x70, 0x5B, 0x12, 0x72, 0x9F, 0xEF, 0x64, 0x01, 0x70, 0x53, 0x71, 0xB2, 0x80, 0x4F, 0x90, 0x81, 
-0x41, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 0x42, 0xBF, 0x01, 0x02, 0x51, 0xA9, 0x90, 0x81, 0x41, 0xE0, 
-0xB4, 0x06, 0x02, 0x51, 0x88, 0x90, 0x81, 0x41, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0x42, 0xBF, 0x01, 
-0x02, 0x51, 0xF8, 0x90, 0x81, 0x41, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0xCC, 0x90, 0x81, 0x41, 
-0xE0, 0xB4, 0x04, 0x19, 0xF1, 0x13, 0x80, 0x15, 0x90, 0x81, 0x41, 0xE0, 0xB4, 0x0C, 0x0E, 0x90, 
-0x81, 0x3B, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x02, 0x71, 0x9B, 0x90, 0x81, 0x41, 
-0xE0, 0x90, 0x01, 0xBA, 0xF0, 0x90, 0x81, 0x40, 0xE0, 0x90, 0x01, 0xBB, 0xF0, 0xD0, 0xD0, 0x92, 
-0xAF, 0x22, 0x12, 0x72, 0x86, 0xEF, 0x64, 0x01, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 
-0x80, 0x2D, 0x90, 0x81, 0x3A, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x08, 0x90, 0x01, 
-0xB8, 0x74, 0x02, 0xF0, 0x80, 0x19, 0x90, 0x81, 0x40, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x08, 0x90, 
-0x01, 0xB8, 0x74, 0x08, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 
-0x01, 0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x81, 0x3B, 0xE0, 0x90, 0x06, 0x04, 0x20, 
-0xE0, 0x08, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x04, 0x80, 0x06, 0xE0, 0x54, 0x7F, 0xF0, 0x7D, 0x0C, 
-0x7F, 0x01, 0x71, 0x33, 0xE4, 0xFD, 0xFF, 0x80, 0x44, 0x90, 0x81, 0x3B, 0xE0, 0xC3, 0x13, 0x20, 
-0xE0, 0x04, 0x7D, 0x0C, 0x80, 0x0D, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 
-0xF0, 0x7D, 0x04, 0x7F, 0x01, 0x71, 0x33, 0xE4, 0xFD, 0xFF, 0x80, 0x21, 0x90, 0x84, 0x00, 0xEF, 
-0xF0, 0xD1, 0x98, 0x90, 0x84, 0x00, 0xE0, 0x60, 0x05, 0xE4, 0xFD, 0xFF, 0x51, 0xED, 0x7D, 0x04, 
-0x7F, 0x01, 0x80, 0x4F, 0xE4, 0xFD, 0x7F, 0x0C, 0x11, 0xE6, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 
-0xEF, 0xF0, 0x90, 0x80, 0x05, 0xED, 0xF0, 0x22, 0x90, 0x80, 0xF9, 0xE0, 0x64, 0x01, 0x70, 0x2E, 
-0x90, 0x81, 0x3B, 0xE0, 0x54, 0xFD, 0xF0, 0x7D, 0x2C, 0x7F, 0x6F, 0x51, 0xED, 0x7D, 0x08, 0x7F, 
-0x01, 0x91, 0x29, 0xBF, 0x01, 0x0D, 0x90, 0x81, 0x3A, 0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x0E, 0x7F, 
-0x01, 0x80, 0x10, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x04, 0xF0, 0x22, 0x7D, 
-0x0C, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 0x14, 0x60, 0x15, 
-0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 0x1A, 0xED, 0x54, 0x01, 0xFE, 0x90, 0x81, 0x3A, 0xE0, 0x54, 
-0xFE, 0x4E, 0xF0, 0x80, 0x0C, 0x90, 0x81, 0x41, 0xED, 0xF0, 0x80, 0x05, 0x90, 0x81, 0x40, 0xED, 
-0xF0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE4, 0x2E, 0xEC, 0x14, 0x60, 0x07, 0x14, 0x60, 0x1D, 0x24, 
-0x02, 0x70, 0x23, 0x90, 0x81, 0x3A, 0xE0, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0xFF, 
-0x90, 0x81, 0x41, 0xE0, 0x54, 0x7F, 0x4F, 0xFD, 0x7F, 0x88, 0x80, 0x07, 0x90, 0x81, 0x40, 0xE0, 
-0xFD, 0x7F, 0x89, 0x12, 0x32, 0x1E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7D, 0x2F, 0x91, 0xF4, 0x7D, 
-0x08, 0x7F, 0x01, 0x80, 0x8E, 0xD1, 0x98, 0xE4, 0xFD, 0xFF, 0x51, 0xED, 0x7D, 0x0C, 0x7F, 0x01, 
-0x80, 0x81, 0x7D, 0x2D, 0xB1, 0x6E, 0x90, 0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0xF1, 
-0xCA, 0x91, 0xF8, 0xE4, 0xFD, 0x7F, 0x01, 0x61, 0x33, 0x90, 0x81, 0x3E, 0xE0, 0x64, 0x01, 0x70, 
-0x15, 0x90, 0x81, 0x3C, 0xE0, 0x54, 0x0F, 0x60, 0x05, 0x51, 0xE4, 0x02, 0x56, 0x81, 0x90, 0x81, 
-0x41, 0xE0, 0x70, 0x02, 0x11, 0xE2, 0x22, 0xEF, 0x60, 0x3A, 0x90, 0x80, 0xF9, 0xE0, 0x64, 0x01, 
-0x70, 0x32, 0x90, 0x81, 0x3B, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x2B, 0x7F, 0x0F, 0x51, 0xED, 0x90, 
-0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 0x91, 0x25, 0xBF, 0x01, 0x0D, 0x90, 0x81, 0x3A, 0xE0, 0x44, 
-0x40, 0xF0, 0x7D, 0x06, 0x7F, 0x01, 0x61, 0x33, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 
-0xB8, 0x74, 0x08, 0xF0, 0x22, 0x7D, 0x08, 0xE4, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
-0x90, 0x83, 0xD5, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x80, 0x03, 0xE0, 0x04, 0xF0, 0x90, 0x04, 
-0x1D, 0xE0, 0x60, 0x21, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x83, 0xD9, 0xF0, 0x7D, 0x26, 0xB1, 0x6E, 
-0xEF, 0x64, 0x01, 0x70, 0x03, 0x12, 0x6D, 0x92, 0x90, 0x83, 0xD9, 0xE0, 0xFF, 0x7D, 0x27, 0x51, 
-0xED, 0x91, 0x77, 0x80, 0x05, 0x91, 0x77, 0x12, 0x6D, 0x92, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 
-0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x83, 0xD5, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 
-0xC3, 0xC0, 0xD0, 0x90, 0x84, 0x02, 0xEF, 0xF0, 0x90, 0x80, 0x09, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 
-0xE0, 0x6F, 0x70, 0x4B, 0x90, 0x81, 0x41, 0xE0, 0x64, 0x0E, 0x70, 0x18, 0x90, 0x84, 0x02, 0xE0, 
-0x70, 0x3D, 0x90, 0x81, 0x3A, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 
-0x71, 0x2F, 0x80, 0x26, 0x90, 0x81, 0x41, 0xE0, 0x64, 0x06, 0x70, 0x23, 0x90, 0x84, 0x02, 0xE0, 
-0x60, 0x1D, 0x90, 0x81, 0x3A, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 
-0xE0, 0x44, 0x80, 0xF0, 0x90, 0x81, 0x41, 0x74, 0x04, 0xF0, 0xE4, 0xFD, 0xFF, 0x51, 0xED, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0x12, 0x56, 0x81, 0x90, 0x81, 0x41, 0xE0, 0x64, 0x0C, 0x60, 0x04, 0x51, 
-0xE4, 0x91, 0x25, 0x22, 0x7F, 0xFF, 0x51, 0xED, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xB1, 
-0x72, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0xCC, 0xF0, 0x00, 0xC0, 0x7F, 0x8C, 0x7E, 0x08, 0x12, 
-0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x14, 0x7F, 0x70, 0x7E, 0x0E, 
-0x12, 0x2E, 0xA2, 0x90, 0x83, 0xCB, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFD, 0xFF, 
-0x12, 0x65, 0x00, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x83, 
-0xE6, 0x12, 0x20, 0xCE, 0x90, 0x83, 0xE6, 0x12, 0x42, 0x19, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 
-0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 
-0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0xFF, 
-0x51, 0xED, 0xE4, 0x90, 0x83, 0xF7, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 
-0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 
-0x83, 0xF8, 0xE0, 0x94, 0xE8, 0x90, 0x83, 0xF7, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 
-0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 0x83, 
-0xF7, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x41, 0xF6, 0x80, 0xBF, 0xEF, 0x60, 0x59, 0x90, 0x04, 0xEC, 
-0xE0, 0x54, 0xDD, 0xF0, 0x90, 0x83, 0x30, 0xE0, 0xFF, 0x60, 0x03, 0x12, 0x5F, 0x95, 0x90, 0x01, 
-0xC7, 0xE4, 0xF0, 0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 0x24, 0x00, 
-0xFF, 0xEC, 0x3E, 0x90, 0x80, 0xF7, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x06, 0x09, 0xE0, 0x54, 0xFE, 
-0xF0, 0x7D, 0x35, 0x91, 0xF4, 0x90, 0x02, 0x86, 0xE0, 0x44, 0x04, 0xF0, 0x12, 0x79, 0x09, 0xF1, 
-0xF3, 0xD1, 0x98, 0xE4, 0xFD, 0xFF, 0x51, 0xED, 0x12, 0x7B, 0xCE, 0x90, 0x01, 0x34, 0x74, 0x08, 
-0xF0, 0xFD, 0xE4, 0xFF, 0xE1, 0xCA, 0x90, 0x04, 0xEC, 0xE0, 0x44, 0x22, 0xF0, 0x7D, 0x08, 0xE4, 
-0xFF, 0x12, 0x68, 0xDB, 0x90, 0x06, 0x90, 0xE0, 0x54, 0xF0, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x54, 
-0xFB, 0xF0, 0x12, 0x79, 0x5A, 0xF1, 0xF4, 0x90, 0x81, 0x7D, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x81, 
-0x85, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x20, 0xF0, 0xD3, 0x10, 0xAF, 0x01, 
-0xC3, 0xC0, 0xD0, 0x90, 0x81, 0x80, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 0x54, 0xFB, 0xF0, 
-0x54, 0xF7, 0xF0, 0x54, 0xEF, 0xF0, 0x54, 0xDF, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0xA3, 
-0xE0, 0x54, 0x80, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0x81, 0x84, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x81, 
-0x81, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x81, 0x84, 0xE0, 0x54, 0xFD, 0xF0, 0xE4, 0xFD, 0x7F, 0x8F, 
-0x12, 0x32, 0x1E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
-0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 0xB7, 0x74, 
-0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0xEC, 
-0x54, 0x7F, 0xFC, 0x90, 0x83, 0xE2, 0x12, 0x20, 0xCE, 0x90, 0x83, 0xE2, 0x12, 0x42, 0x19, 0x90, 
-0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x12, 
-0x20, 0xDA, 0xCC, 0xC0, 0x00, 0xC0, 0x7F, 0x8C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x85, 0xBB, 
-0x12, 0x20, 0xDA, 0x00, 0xC0, 0x00, 0x14, 0x7F, 0x70, 0x7E, 0x0E, 0x12, 0x2E, 0xA2, 0x90, 0x83, 
-0xCB, 0x12, 0x20, 0xDA, 0x00, 0x03, 0x3E, 0x60, 0xE4, 0xFD, 0xFF, 0x12, 0x65, 0x00, 0xD0, 0xD0, 
-0x92, 0xAF, 0x22, 0x7D, 0x2E, 0x7F, 0x6F, 0x51, 0xED, 0x7D, 0x02, 0x7F, 0x01, 0x61, 0x33, 0x90, 
-0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0xE4, 0xFD, 0xFF, 0x51, 0xED, 0x7D, 0x0C, 0x7F, 0x01, 0x61, 
-0x33, 0xEF, 0x70, 0x4E, 0x7D, 0x78, 0x7F, 0x02, 0x12, 0x68, 0xDB, 0x7D, 0x02, 0x7F, 0x03, 0x12, 
-0x68, 0xDB, 0x7D, 0xC8, 0x7F, 0x02, 0x12, 0x71, 0x5D, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 
-0x3C, 0x74, 0x02, 0xF0, 0x90, 0x80, 0xF9, 0xE0, 0x70, 0x13, 0xD1, 0x98, 0xF1, 0x1F, 0x90, 0x81, 
-0x3A, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x80, 0x06, 0x7D, 0x01, 0x7F, 
-0x0C, 0x11, 0xE6, 0x90, 0x81, 0x3A, 0xE0, 0x54, 0xF7, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 
-0xF0, 0x22, 0x90, 0x01, 0x36, 0x74, 0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0xF1, 
-0xCA, 0x7D, 0x02, 0x7F, 0x03, 0xF1, 0xCA, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0xF0, 0x90, 0x81, 
-0x49, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x90, 0x80, 0xF9, 0xE0, 0xB4, 0x01, 0x14, 0x90, 0x81, 
-0x3B, 0xE0, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x41, 0xE0, 0x20, 0xE2, 0x0D, 0x7D, 0x01, 0x7F, 0x04, 
-0x01, 0xE6, 0x90, 0x81, 0x3B, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x74, 0x3D, 0x2F, 0xF8, 0xE6, 0x4D, 
-0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 
-0x81, 0x3E, 0xE0, 0x60, 0x02, 0x71, 0xC9, 0x22, 0xE4, 0xFD, 0xFF, 0x51, 0xED, 0x7D, 0x04, 0x7F, 
-0x01, 0x61, 0x33, 0x22, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 
-0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 
-0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xF5, 0xF0, 0x74, 0x4F, 0xA3, 0xF0, 0x12, 0x68, 0x4C, 0xE5, 
-0x49, 0x30, 0xE1, 0x02, 0x11, 0x79, 0xE5, 0x49, 0x30, 0xE2, 0x02, 0x11, 0x94, 0xE5, 0x4A, 0x30, 
-0xE0, 0x03, 0x12, 0x70, 0x3F, 0xE5, 0x4C, 0x30, 0xE1, 0x04, 0x7F, 0x04, 0xF1, 0x8D, 0xE5, 0x4C, 
-0x30, 0xE4, 0x02, 0x11, 0x82, 0xE5, 0x4C, 0x30, 0xE5, 0x02, 0x11, 0xDC, 0xE5, 0x4C, 0x30, 0xE6, 
-0x02, 0x31, 0x60, 0x74, 0xF5, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x4F, 0xA3, 0xF0, 0xD0, 0x07, 
+0x42, 0xE0, 0x73, 0xEF, 0x4E, 0x60, 0x12, 0xEF, 0x60, 0x01, 0x0E, 0xED, 0xBB, 0x01, 0x0B, 0x89, 
+0x82, 0x8A, 0x83, 0xF0, 0xA3, 0xDF, 0xFC, 0xDE, 0xFA, 0x22, 0x89, 0xF0, 0x50, 0x07, 0xF7, 0x09, 
+0xDF, 0xFC, 0xA9, 0xF0, 0x22, 0xBB, 0xFE, 0xFC, 0xF3, 0x09, 0xDF, 0xFC, 0xA9, 0xF0, 0x22, 0xC2, 
+0xAF, 0x80, 0xFE, 0x32, 0x12, 0x44, 0x43, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 0xC2, 
+0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 0xEC, 
+0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 0x40, 
+0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 0x03, 
+0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 0x23, 
+0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 0xE4, 
+0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 0xE6, 
+0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 0x6D, 
+0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 0x0C, 
+0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 0xF8, 
+0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 0xC8, 
+0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 0xE6, 
+0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 0x08, 
+0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 0x81, 
+0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 0xF6, 
+0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x47, 0x7C, 0x74, 0x01, 0x93, 0xC0, 
+0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 0x8C, 
+0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 0x2F, 
+0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 0x0C, 
+0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 0xBE, 
+0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 0x09, 
+0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 0xEE, 
+0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 0xA9, 
+0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 0xF7, 
+0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 0x04, 
+0x90, 0x47, 0x7C, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 
+0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 0xC2, 
+0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 0xF8, 
+0xE6, 0xF5, 0x81, 0x02, 0x44, 0x8C, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 0x02, 
+0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 0x60, 
+0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 0x0C, 
+0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 0x0F, 
+0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 0x81, 
+0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 0x07, 
+0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 
+0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 0xD2, 
+0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x44, 0x8B, 0x8F, 0xF0, 0xE4, 
+0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 0xE6, 
+0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x30, 0x50, 0x2E, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 0x60, 
+0x25, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x23, 0x0E, 0x30, 0xE2, 
+0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x12, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x13, 0x54, 0xEC, 0x4E, 
+0xF6, 0xD2, 0xAF, 0x02, 0x44, 0x8C, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 0xC2, 0xAF, 0x56, 
+0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0x02, 0x47, 0x26, 0x02, 0x45, 0x1C, 0xE4, 0x93, 
+0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 0x08, 0xDF, 0xF4, 0x80, 0x29, 
+0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 0xC4, 0x54, 0x0F, 0x44, 0x20, 
+0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 0xE4, 0x80, 0x0B, 0x01, 0x02, 
+0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x47, 0x6B, 0xE4, 0x7E, 0x01, 0x93, 0x60, 0xBC, 0xA3, 
+0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 
+0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 
+0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 
+0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 0x41, 0x84, 0x2A, 0x00, 0x41, 
+0x84, 0x2B, 0x00, 0x41, 0x84, 0x3C, 0x00, 0x41, 0x84, 0x3D, 0x00, 0x00, 0x67, 0xE3, 0x68, 0x57, 
+0x6B, 0x1A, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 
+0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 
+0x01, 0xC4, 0x74, 0x82, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0x12, 0x71, 0xA8, 0xE5, 0x3C, 0x30, 0xE7, 
+0x02, 0xF1, 0xD9, 0x74, 0x82, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0xD0, 0x07, 
 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 
-0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x81, 0x3E, 0xE0, 0x60, 0x02, 0xF1, 
-0x44, 0x22, 0x11, 0xAD, 0x90, 0x81, 0x44, 0xE0, 0x14, 0x90, 0x05, 0x73, 0xF0, 0x7D, 0x02, 0x7F, 
-0x02, 0x02, 0x4F, 0xCA, 0x90, 0x81, 0x3E, 0xE0, 0x60, 0x12, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 
-0x02, 0xC1, 0x81, 0x90, 0x81, 0x3A, 0xE0, 0x54, 0xF7, 0xF0, 0x31, 0x9D, 0x22, 0x90, 0x81, 0x3E, 
-0xE0, 0x60, 0x28, 0x90, 0x80, 0xF9, 0xE0, 0x64, 0x01, 0x70, 0x20, 0x90, 0x81, 0x45, 0xF0, 0x04, 
-0x60, 0x19, 0x90, 0x81, 0x42, 0xE0, 0x44, 0x10, 0xF0, 0xE4, 0xF5, 0x52, 0x90, 0x81, 0x46, 0xF1, 
-0xF6, 0x90, 0x81, 0x41, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x48, 0xE2, 0x22, 0x90, 0x81, 0x3A, 0xE0, 
-0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x26, 0xEF, 0x54, 0xBF, 0xF0, 0x90, 0x04, 0xE0, 
-0xE0, 0x90, 0x81, 0x3B, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x10, 0xE0, 0x54, 0xFE, 
-0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x31, 0x9D, 0xE4, 
-0xFF, 0x90, 0x83, 0x44, 0xE0, 0x30, 0xE0, 0x47, 0x90, 0x83, 0x49, 0xE0, 0xFD, 0x60, 0x40, 0x74, 
-0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 
-0x90, 0x04, 0xE0, 0xE0, 0xFB, 0xEF, 0x5B, 0x60, 0x0B, 0xE4, 0x90, 0x83, 0x49, 0xF0, 0x90, 0x83, 
-0x4B, 0x04, 0xF0, 0x22, 0x90, 0x83, 0x46, 0xE0, 0xD3, 0x9D, 0x50, 0x0A, 0x31, 0xA7, 0x90, 0x83, 
-0x44, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x12, 0x4C, 0x25, 0x90, 0x83, 0x49, 0xE0, 0x04, 0xF0, 0x22, 
-0x90, 0x81, 0x3A, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x30, 0xE0, 0x2B, 0xEF, 0x54, 
-0x7F, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x81, 0x3B, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 
-0x80, 0x0F, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x04, 
-0xF0, 0x90, 0x81, 0x3E, 0xE0, 0x60, 0x02, 0x31, 0x9D, 0x7F, 0x01, 0x21, 0x11, 0x90, 0x81, 0x40, 
-0xE0, 0xFF, 0x7D, 0x01, 0x02, 0x48, 0xE6, 0x90, 0x01, 0xC7, 0x74, 0x10, 0xF0, 0x7F, 0x01, 0x90, 
-0x84, 0x03, 0xEF, 0xF0, 0x90, 0x80, 0x06, 0xE0, 0x64, 0x02, 0x70, 0x1F, 0x90, 0x84, 0x03, 0xE0, 
-0xFF, 0x64, 0x01, 0x70, 0x24, 0x90, 0x81, 0x81, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 
-0x30, 0xE0, 0x14, 0x90, 0x01, 0x4D, 0xE0, 0x64, 0x80, 0xF0, 0x22, 0x90, 0x06, 0x90, 0xE0, 0x44, 
-0x01, 0xF0, 0x90, 0x84, 0x03, 0xE0, 0xFF, 0x31, 0xEA, 0x22, 0xAD, 0x07, 0x90, 0x81, 0x82, 0xE0, 
-0x75, 0xF0, 0x40, 0xA4, 0xFF, 0x90, 0x83, 0xEA, 0xE5, 0xF0, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xA3, 
-0xF0, 0x90, 0x81, 0x83, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0x83, 0xED, 0xF0, 0xED, 0x64, 0x01, 
-0x60, 0x02, 0x41, 0xBA, 0x90, 0x83, 0xEA, 0xE0, 0x70, 0x02, 0xA3, 0xE0, 0x60, 0x0B, 0x90, 0x83, 
-0xEA, 0x74, 0xFF, 0x75, 0xF0, 0xD0, 0x12, 0x41, 0xF6, 0x90, 0x81, 0x81, 0xE0, 0x54, 0x7F, 0xFF, 
-0x90, 0x81, 0x80, 0xE0, 0xFE, 0xC4, 0x13, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 
-0x51, 0xCC, 0x51, 0xBB, 0x90, 0x81, 0x83, 0xE0, 0x30, 0xE0, 0x6F, 0x90, 0x83, 0xEA, 0xE0, 0xFE, 
-0xA3, 0xE0, 0xFF, 0x12, 0x32, 0xAA, 0x90, 0x81, 0x81, 0xE0, 0x54, 0x7F, 0xFF, 0x90, 0x81, 0x80, 
-0xE0, 0xFE, 0xC4, 0x13, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x51, 0xCC, 0xE4, 
-0x90, 0x83, 0xEC, 0xF0, 0x90, 0x83, 0xED, 0xE0, 0xFF, 0x90, 0x83, 0xEC, 0xE0, 0xC3, 0x9F, 0x50, 
-0x39, 0x90, 0x83, 0xEA, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x32, 0xAA, 0x51, 0xBB, 0x90, 0x83, 
-0xEA, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x32, 0xAA, 0x90, 0x81, 0x81, 0xE0, 0x54, 0x7F, 0xFF, 
-0x90, 0x81, 0x80, 0xE0, 0xFE, 0xC4, 0x13, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 
-0x51, 0xCC, 0x90, 0x83, 0xEC, 0xE0, 0x04, 0xF0, 0x80, 0xBA, 0x22, 0x90, 0x81, 0x81, 0xE0, 0x54, 
-0x7F, 0xFF, 0x90, 0x81, 0x80, 0xE0, 0xFE, 0xC4, 0x13, 0x54, 0x01, 0xFD, 0xD3, 0x10, 0xAF, 0x01, 
-0xC3, 0xC0, 0xD0, 0x90, 0x83, 0xFA, 0xED, 0xF0, 0x90, 0x83, 0xF9, 0xEF, 0xF0, 0xD3, 0x94, 0x07, 
-0x50, 0x70, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 
-0xFF, 0x90, 0x00, 0x47, 0xE0, 0x5F, 0xFD, 0x7F, 0x47, 0x12, 0x32, 0x1E, 0x90, 0x83, 0xF9, 0xE0, 
-0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x46, 
-0xE0, 0x4F, 0xFD, 0x7F, 0x46, 0x12, 0x32, 0x1E, 0x90, 0x83, 0xFA, 0xE0, 0x60, 0x18, 0x90, 0x83, 
-0xF9, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 
-0x00, 0x45, 0xE0, 0x4F, 0x80, 0x17, 0x90, 0x83, 0xF9, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 
+0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x32, 0x06, 
+0x90, 0x00, 0xF2, 0xE0, 0x20, 0xE6, 0x0C, 0x90, 0x00, 0x05, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x05, 
+0x12, 0x32, 0x1E, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 
+0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0x01, 0xC4, 0x74, 0xF4, 0xF0, 0x74, 0x47, 0xA3, 0xF0, 0x12, 0x71, 0xE2, 0xE5, 0x41, 
+0x30, 0xE3, 0x03, 0x12, 0x6E, 0x43, 0xE5, 0x41, 0x30, 0xE4, 0x03, 0x12, 0x6D, 0xB6, 0xE5, 0x43, 
+0x30, 0xE0, 0x02, 0x11, 0x90, 0xE5, 0x43, 0x30, 0xE1, 0x03, 0x12, 0x72, 0x7B, 0xE5, 0x43, 0x30, 
+0xE2, 0x03, 0x12, 0x76, 0x8E, 0xE5, 0x43, 0x30, 0xE3, 0x02, 0x91, 0x99, 0xE5, 0x43, 0x30, 0xE4, 
+0x02, 0x91, 0xC6, 0xE5, 0x43, 0x30, 0xE5, 0x02, 0x91, 0xAC, 0xE5, 0x43, 0x30, 0xE6, 0x03, 0x12, 
+0x76, 0xA5, 0xE5, 0x44, 0x30, 0xE1, 0x03, 0x12, 0x77, 0x69, 0x74, 0xF4, 0x04, 0x90, 0x01, 0xC4, 
+0xF0, 0x74, 0x47, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 
+0xE4, 0xF5, 0x19, 0x90, 0x81, 0x08, 0xE0, 0x60, 0x71, 0x91, 0x5F, 0x64, 0x01, 0x70, 0x6B, 0x12, 
+0x74, 0xC0, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0x12, 0x76, 0x82, 0x90, 0x81, 0x06, 0xE0, 
+0xC4, 0x54, 0x0F, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 0x1E, 0x90, 0x81, 0x0F, 0xE0, 
+0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x81, 0x11, 0xE0, 0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 
+0x81, 0x0E, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x19, 0x01, 0xE5, 0x19, 0x60, 0x2C, 0x12, 0x76, 
+0x51, 0x90, 0x81, 0x11, 0xE0, 0x60, 0x03, 0xB4, 0x01, 0x05, 0x12, 0x7A, 0x1C, 0x80, 0x09, 0x12, 
+0x7A, 0x1C, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 0x90, 0x81, 0x10, 0xE0, 0x2F, 0x12, 0x6F, 
+0xDD, 0x90, 0x81, 0x0B, 0xE0, 0x20, 0xE2, 0x02, 0x31, 0x0B, 0x22, 0x7D, 0x01, 0x7F, 0x04, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x84, 0x39, 0xED, 0xF0, 0x90, 0x81, 0x04, 0xE0, 0xFE, 
+0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x41, 0x5A, 0xEE, 0x12, 0x5E, 0x80, 0x30, 0xE0, 
+0x02, 0x41, 0x5A, 0x90, 0x81, 0x0B, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0x41, 0x5A, 0xEF, 0x70, 0x02, 
+0x21, 0xCD, 0x24, 0xFE, 0x70, 0x02, 0x41, 0x06, 0x24, 0xFE, 0x60, 0x49, 0x24, 0xFC, 0x70, 0x02, 
+0x41, 0x41, 0x24, 0xFC, 0x60, 0x02, 0x41, 0x53, 0xEE, 0xB4, 0x0E, 0x02, 0x51, 0x91, 0x90, 0x81, 
+0x0B, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0xCD, 0x90, 0x81, 0x0B, 0xE0, 0xB4, 0x06, 0x02, 0x51, 
+0xAC, 0x90, 0x81, 0x0B, 0xE0, 0xB4, 0x04, 0x0E, 0x90, 0x84, 0x39, 0xE0, 0xFF, 0x60, 0x04, 0x71, 
+0xD6, 0x80, 0x03, 0x12, 0x59, 0x65, 0x90, 0x81, 0x0B, 0xE0, 0x64, 0x08, 0x60, 0x02, 0x41, 0x53, 
+0x12, 0x5E, 0xF6, 0x41, 0x53, 0x90, 0x81, 0x0B, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0xCD, 0x90, 
+0x81, 0x0B, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0xAC, 0x90, 0x81, 0x0B, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 
+0x5F, 0xBF, 0x01, 0x02, 0x51, 0x91, 0x90, 0x81, 0x0B, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0x41, 0x53, 
+0x51, 0x5F, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x41, 0x53, 0x51, 0xE4, 0x41, 0x53, 0x90, 0x81, 0x0B, 
+0xE0, 0xB4, 0x0E, 0x07, 0x51, 0x5F, 0xBF, 0x01, 0x02, 0x51, 0x91, 0x90, 0x81, 0x0B, 0xE0, 0xB4, 
+0x06, 0x02, 0x51, 0xAC, 0x90, 0x81, 0x0B, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0x5F, 0xBF, 0x01, 0x02, 
+0x51, 0xE4, 0x90, 0x81, 0x0B, 0xE0, 0x64, 0x04, 0x70, 0x59, 0x12, 0x6A, 0x0C, 0xEF, 0x64, 0x01, 
+0x70, 0x51, 0x71, 0xB8, 0x80, 0x4D, 0x90, 0x81, 0x0B, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 0x5F, 0xBF, 
+0x01, 0x02, 0x51, 0x91, 0x90, 0x81, 0x0B, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0xAC, 0x90, 0x81, 0x0B, 
+0xE0, 0xB4, 0x0C, 0x07, 0x51, 0x5F, 0xBF, 0x01, 0x02, 0x51, 0xE4, 0x90, 0x81, 0x0B, 0xE0, 0x70, 
+0x04, 0x7F, 0x01, 0x51, 0xCD, 0x90, 0x81, 0x0B, 0xE0, 0xB4, 0x04, 0x17, 0x12, 0x77, 0xD6, 0x80, 
+0x12, 0x90, 0x81, 0x0B, 0xE0, 0xB4, 0x0C, 0x0B, 0x90, 0x81, 0x05, 0x12, 0x5F, 0xC9, 0x30, 0xE0, 
+0x02, 0x71, 0x92, 0x90, 0x81, 0x0B, 0x12, 0x79, 0xCB, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 
+0x6E, 0x4F, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x12, 0x6A, 0x80, 0x80, 0x1C, 0x12, 0x70, 0x83, 0x30, 
+0xE0, 0x05, 0x12, 0x6A, 0x79, 0x80, 0x11, 0x90, 0x81, 0x0A, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x05, 
+0x12, 0x6A, 0x05, 0x80, 0x03, 0x02, 0x6A, 0x87, 0x90, 0x01, 0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 
+0x22, 0x90, 0x81, 0x05, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x04, 0x7D, 0x0C, 0x80, 0x05, 0x12, 0x78, 
+0x43, 0x7D, 0x04, 0x7F, 0x01, 0x71, 0x2A, 0xE4, 0xFD, 0xFF, 0x80, 0x6F, 0x90, 0x81, 0x05, 0xE0, 
+0x90, 0x06, 0x04, 0x20, 0xE0, 0x08, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x04, 0x80, 0x06, 0xE0, 0x54, 
+0x7F, 0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0x71, 0x2A, 0xE4, 0xFD, 0xFF, 0x80, 0x4E, 0x90, 0x84, 0x38, 
+0xEF, 0xF0, 0x12, 0x59, 0x85, 0x90, 0x84, 0x38, 0xE0, 0x60, 0x03, 0x12, 0x5A, 0xCD, 0x7D, 0x04, 
+0x7F, 0x01, 0x80, 0x46, 0x91, 0x5F, 0x64, 0x01, 0x70, 0x27, 0x90, 0x81, 0x05, 0xE0, 0x54, 0xFD, 
+0xF0, 0x7D, 0x2C, 0x7F, 0x6F, 0x71, 0x1B, 0x7D, 0x08, 0x7F, 0x01, 0x91, 0x0F, 0xBF, 0x01, 0x0D, 
+0x90, 0x81, 0x04, 0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x0E, 0x7F, 0x01, 0x80, 0x1D, 0xF1, 0xFC, 0x04, 
+0xF0, 0x22, 0xE4, 0xFD, 0x7F, 0x0C, 0x31, 0x0F, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 
+0x90, 0x80, 0x05, 0xED, 0xF0, 0x22, 0x7D, 0x0C, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0xAC, 0x07, 0xEF, 0x14, 0x60, 0x15, 0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 0x1A, 0xED, 0x54, 
+0x01, 0xFE, 0x90, 0x81, 0x04, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0x80, 0x0C, 0x90, 0x81, 0x0B, 0xED, 
+0xF0, 0x80, 0x05, 0x90, 0x81, 0x0A, 0xED, 0xF0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE4, 0x2E, 0xEC, 
+0x14, 0x60, 0x07, 0x14, 0x60, 0x1D, 0x24, 0x02, 0x70, 0x23, 0x90, 0x81, 0x04, 0xE0, 0x54, 0x01, 
+0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0xFF, 0x90, 0x81, 0x0B, 0xE0, 0x54, 0x7F, 0x4F, 0xFD, 0x7F, 
+0x88, 0x80, 0x07, 0x90, 0x81, 0x0A, 0xE0, 0xFD, 0x7F, 0x89, 0x12, 0x32, 0x1E, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x7D, 0x2F, 0x12, 0x5B, 0x03, 0x7D, 0x08, 0x7F, 0x01, 0x80, 0x8D, 0x90, 0x81, 0x08, 
+0xE0, 0x64, 0x01, 0x70, 0x12, 0x12, 0x57, 0xDD, 0x60, 0x05, 0x71, 0x12, 0x02, 0x70, 0x4E, 0x90, 
+0x81, 0x0B, 0xE0, 0x70, 0x02, 0x31, 0x0B, 0x22, 0x7D, 0x2D, 0x7F, 0xFF, 0x71, 0x1B, 0x12, 0x6F, 
+0x83, 0x90, 0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 0x58, 0x91, 0x12, 0x5B, 0x08, 
+0xE4, 0xFD, 0x7F, 0x01, 0x61, 0x2A, 0xEF, 0x60, 0x31, 0x91, 0x5F, 0x64, 0x01, 0x70, 0x2B, 0x90, 
+0x81, 0x05, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x2B, 0x7F, 0x0F, 0x71, 0x1B, 0x90, 0x06, 0x04, 0xE0, 
+0x54, 0xBF, 0xF0, 0x91, 0x0B, 0xBF, 0x01, 0x0D, 0x90, 0x81, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 
+0x06, 0x7F, 0x01, 0x61, 0x2A, 0xF1, 0xFC, 0x74, 0x08, 0xF0, 0x22, 0x7D, 0x08, 0xE4, 0xFF, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x84, 0x0E, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x80, 
+0x03, 0xE0, 0x04, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x26, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x84, 
+0x12, 0xF0, 0x7D, 0x26, 0x7F, 0xFF, 0x71, 0x1B, 0x12, 0x6F, 0x83, 0xEF, 0x64, 0x01, 0x70, 0x02, 
+0xB1, 0x03, 0x90, 0x84, 0x12, 0xE0, 0xFF, 0x7D, 0x27, 0x71, 0x1B, 0x12, 0x77, 0xE4, 0x80, 0x05, 
+0x12, 0x77, 0xE4, 0xB1, 0x03, 0xF1, 0xF4, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0xE4, 
+0xFF, 0x91, 0x65, 0xEF, 0x22, 0x12, 0x79, 0xF0, 0x12, 0x5F, 0x83, 0xE0, 0xFD, 0x7C, 0x00, 0x12, 
+0x6D, 0xD2, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5C, 0xFE, 0xEF, 
+0x5D, 0x4E, 0x7F, 0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0x12, 0x70, 0x4E, 0x90, 0x81, 0x0B, 0xE0, 
+0x64, 0x0C, 0x60, 0x04, 0x71, 0x12, 0x91, 0x0B, 0x22, 0x91, 0x5F, 0x64, 0x01, 0x70, 0x0C, 0x90, 
+0x81, 0x08, 0xE0, 0x60, 0x06, 0x12, 0x76, 0x6C, 0x12, 0x6F, 0xD5, 0x22, 0xE4, 0xFF, 0x91, 0x65, 
+0xBF, 0x01, 0x12, 0x90, 0x81, 0x08, 0xE0, 0x60, 0x0C, 0x12, 0x57, 0xDD, 0x64, 0x02, 0x60, 0x03, 
+0x02, 0x76, 0xD7, 0x91, 0x89, 0x22, 0x91, 0x5F, 0x64, 0x01, 0x70, 0x18, 0x90, 0x81, 0x08, 0xE0, 
+0x60, 0x12, 0x12, 0x76, 0x6C, 0xF0, 0x90, 0x81, 0x04, 0xE0, 0x12, 0x76, 0x77, 0x54, 0x07, 0x70, 
+0x03, 0x12, 0x5D, 0x9C, 0x22, 0xF1, 0xB8, 0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x0B, 0xF1, 0xAC, 0xE0, 
+0x44, 0x10, 0xF1, 0xB7, 0x44, 0x80, 0xF0, 0x22, 0xF1, 0xAC, 0xE0, 0x54, 0xEF, 0xF1, 0xB7, 0x44, 
+0x40, 0xF0, 0x22, 0x90, 0x80, 0x09, 0xE0, 0xFF, 0x90, 0x84, 0x0F, 0xE0, 0xFB, 0x7D, 0x01, 0xB1, 
+0x91, 0x90, 0x84, 0x10, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x84, 0x0E, 0xE0, 0xFF, 
+0x91, 0xE5, 0x90, 0x84, 0x10, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x04, 0x80, 0xE0, 0x54, 0x0F, 
+0xFD, 0xAC, 0x07, 0x12, 0x79, 0xE4, 0x44, 0x01, 0xF0, 0x12, 0x79, 0xE4, 0x54, 0xFB, 0xF0, 0xAC, 
+0x07, 0x74, 0x16, 0x2C, 0xF1, 0xDF, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x15, 0x2C, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x0F, 0xF0, 0x90, 0x04, 0x53, 0xE4, 0xF0, 0x90, 0x04, 0x52, 
+0xF0, 0x90, 0x04, 0x51, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0x50, 0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 
+0x12, 0x7A, 0x14, 0xE0, 0x54, 0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 0x12, 0x7A, 0x14, 0xED, 0xF0, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x84, 0x18, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 
+0x90, 0x84, 0x17, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x12, 0x78, 0x4F, 0x7C, 0x00, 0xAD, 0x07, 0x90, 
+0x84, 0x17, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x84, 0x18, 0xE0, 0x60, 0x0E, 0x74, 0x0F, 0x2F, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x08, 0x2F, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x09, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
+0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 0xAF, 0x05, 0xF1, 0xDC, 0xE0, 0x54, 0x01, 0xFE, 0x90, 
+0x84, 0x19, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0xF1, 0xDC, 0xEE, 
+0xF0, 0x74, 0x21, 0x2F, 0xF1, 0xAF, 0xE0, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0xC1, 0x12, 0x42, 0x3A, 
+0x78, 0xCD, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xCE, 0x12, 0x67, 0x32, 0x90, 
+0x05, 0x22, 0xE0, 0x90, 0x83, 0xCC, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x0E, 0x7D, 0x33, 0x7F, 
+0xFF, 0x71, 0x1B, 0x12, 0x6F, 0x83, 0xBF, 0x01, 0x15, 0x80, 0x00, 0x90, 0x83, 0x68, 0xE0, 0xFF, 
+0x7B, 0x18, 0x7D, 0x01, 0xB1, 0x91, 0x90, 0x83, 0xC9, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x83, 
+0xC9, 0x12, 0x78, 0xF8, 0x90, 0x83, 0xCB, 0xEF, 0xF0, 0x90, 0x83, 0xC9, 0xA3, 0xE0, 0x24, 0x20, 
+0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x90, 0x83, 0xC7, 0xE0, 0xFD, 0x12, 0x56, 0x84, 0x90, 
+0x83, 0xC8, 0xE0, 0x70, 0x49, 0xF1, 0xD2, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 
+0xF1, 0xE7, 0x75, 0x16, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0xF1, 0x30, 0xF1, 0xC4, 0xFA, 
+0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xF1, 0xE7, 0x75, 0x16, 0x06, 0xD0, 0x01, 0xD0, 
+0x02, 0xD0, 0x03, 0xF1, 0x30, 0xF1, 0xCB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 
+0x90, 0x83, 0xC1, 0xF1, 0xEA, 0x75, 0x16, 0x04, 0xD0, 0x01, 0xD0, 0x02, 0x80, 0x46, 0x90, 0x83, 
+0xC8, 0xE0, 0x64, 0x01, 0x70, 0x43, 0xF1, 0xD2, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0x8B, 0x13, 0x75, 
+0x14, 0x81, 0x75, 0x15, 0xD3, 0x75, 0x16, 0x06, 0xD0, 0x03, 0xF1, 0x30, 0xF1, 0xC4, 0xFA, 0x7B, 
+0x01, 0xC0, 0x03, 0x8B, 0x13, 0x75, 0x14, 0x81, 0x75, 0x15, 0xDD, 0x75, 0x16, 0x06, 0xD0, 0x03, 
+0xF1, 0x30, 0xF1, 0xCB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0x8B, 0x13, 0x75, 0x14, 0x81, 0x75, 0x15, 
+0xE3, 0x75, 0x16, 0x04, 0xD0, 0x03, 0x12, 0x2B, 0xED, 0x90, 0x06, 0x30, 0xE0, 0x44, 0x10, 0xF0, 
+0x90, 0x83, 0xCC, 0xE0, 0xFF, 0x7D, 0x34, 0x71, 0x1B, 0xF1, 0xF4, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x12, 0x2B, 0xED, 0x90, 0x83, 0xC9, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x22, 0x12, 0x78, 0x4F, 
+0x90, 0x84, 0x27, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x84, 0x27, 0x12, 0x78, 0xF8, 0x90, 0x84, 
+0x29, 0xEF, 0xF0, 0x90, 0x84, 0x27, 0xF1, 0xD3, 0xF1, 0x9D, 0x75, 0x16, 0x06, 0x7B, 0x01, 0x7A, 
+0x81, 0x79, 0xD3, 0xF1, 0xA5, 0xF1, 0x36, 0x24, 0x36, 0xF9, 0xE4, 0x34, 0xFC, 0xF1, 0x9D, 0x75, 
+0x16, 0x04, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xD9, 0xF1, 0xA5, 0xF1, 0x36, 0xF1, 0xC4, 0xF1, 0x9D, 
+0x75, 0x16, 0x06, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xDD, 0xF1, 0xA5, 0xF1, 0x36, 0xF1, 0xCB, 0xF1, 
+0x9D, 0x75, 0x16, 0x04, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xE3, 0x02, 0x2B, 0xED, 0x75, 0x13, 0x01, 
+0xF5, 0x14, 0x89, 0x15, 0x22, 0x12, 0x2B, 0xED, 0x90, 0x84, 0x27, 0x22, 0x74, 0x21, 0x2D, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0xE0, 0x22, 0x24, 0x3A, 0xF9, 0xE4, 0x34, 0xFC, 0x22, 0x24, 0x40, 0xF9, 0xE4, 0x34, 
+0xFC, 0x22, 0xA3, 0xA3, 0xE0, 0x24, 0x30, 0xF9, 0xE4, 0x34, 0xFC, 0x22, 0x74, 0x16, 0x2F, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x90, 0x83, 0xC4, 0x12, 0x42, 0x31, 0x8B, 0x13, 0x8A, 
+0x14, 0x89, 0x15, 0x22, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x22, 0xF0, 0x90, 0x01, 0xB9, 0x74, 
+0x01, 0xF0, 0x90, 0x01, 0xB8, 0x22, 0xF1, 0xAD, 0xFF, 0x54, 0x7F, 0x90, 0x81, 0x08, 0xF0, 0xEF, 
+0x12, 0x5E, 0x80, 0xA3, 0x71, 0x09, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0x81, 0x06, 
+0xE0, 0x54, 0xF0, 0x4E, 0xB1, 0xC9, 0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 0x81, 0x04, 0xE0, 0x54, 
+0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0xF1, 0xDD, 0xB1, 0x86, 0x90, 0x81, 
+0x07, 0x91, 0x65, 0x30, 0xE0, 0x4C, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x81, 
+0x1B, 0x50, 0x04, 0xEF, 0xF0, 0x80, 0x24, 0x74, 0x03, 0x11, 0xB1, 0xE9, 0x24, 0x06, 0xF1, 0xD5, 
+0xFF, 0x74, 0x03, 0x24, 0xFD, 0xFE, 0xEF, 0xC4, 0x54, 0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 0xED, 
+0x2E, 0x54, 0x0F, 0xFE, 0xC4, 0x54, 0xF0, 0x4F, 0x12, 0x1F, 0xEA, 0x11, 0xB2, 0x91, 0x66, 0xC4, 
+0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x81, 0x10, 0x50, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x02, 
+0xEF, 0xF0, 0x11, 0xB2, 0xD1, 0x47, 0xFD, 0x7F, 0x02, 0x12, 0x4B, 0x2A, 0x11, 0xB2, 0xF1, 0x19, 
+0x12, 0x4F, 0xFC, 0xF0, 0x90, 0x81, 0x08, 0x12, 0x79, 0xCB, 0xF1, 0xDC, 0x90, 0x01, 0xBE, 0xF0, 
+0x22, 0xF0, 0x90, 0x83, 0x9A, 0x02, 0x42, 0x31, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 
+0xAD, 0x20, 0xE0, 0x05, 0x12, 0x5A, 0xDE, 0x21, 0x7B, 0x90, 0x82, 0x87, 0x74, 0x05, 0x11, 0xB1, 
+0xF1, 0xA5, 0x90, 0x81, 0xB6, 0x71, 0x18, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x71, 0x10, 0xF1, 
+0xE4, 0x71, 0x26, 0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x71, 0x10, 0xF1, 0xEC, 0x71, 0x26, 0x54, 
+0x40, 0xFD, 0xEF, 0x54, 0xBF, 0x71, 0x10, 0xF1, 0xF4, 0x71, 0x09, 0x54, 0x80, 0xFF, 0x90, 0x81, 
+0xB7, 0xE0, 0x54, 0x7F, 0x4F, 0xF0, 0x12, 0x1F, 0xA4, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 
+0x90, 0x06, 0x90, 0xE0, 0x44, 0x04, 0xF0, 0x11, 0xB2, 0x12, 0x1F, 0xA4, 0x13, 0x13, 0x13, 0x54, 
+0x1F, 0x30, 0xE0, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x08, 0xF0, 0x90, 0x80, 0x06, 0xE0, 0xB4, 
+0x02, 0x0A, 0x90, 0x81, 0xB7, 0xE0, 0x12, 0x5E, 0x80, 0x20, 0xE0, 0x31, 0x71, 0x0A, 0x54, 0x7F, 
+0xFF, 0x90, 0x81, 0xB7, 0xE0, 0x54, 0x80, 0xB1, 0x86, 0x90, 0x81, 0xB8, 0xB1, 0xC9, 0xFF, 0x54, 
+0x01, 0xFE, 0x90, 0x81, 0xB9, 0x12, 0x79, 0xFC, 0x54, 0xFE, 0xFF, 0xEE, 0x54, 0x01, 0x4F, 0xF0, 
+0x51, 0xFA, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x31, 0x80, 0x90, 0x80, 0x06, 
+0xE0, 0xB4, 0x01, 0x07, 0x90, 0xFE, 0x10, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x84, 0x31, 0xED, 0xF0, 0x90, 0x84, 0x30, 0xEF, 
+0xF0, 0xD3, 0x94, 0x07, 0x50, 0x4C, 0x51, 0x53, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 
+0x90, 0x00, 0x47, 0xE0, 0x5F, 0xFD, 0x7F, 0x47, 0x51, 0x4D, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
+0xFF, 0x90, 0x00, 0x46, 0xE0, 0x4F, 0xFD, 0x7F, 0x46, 0x12, 0x7A, 0x24, 0x60, 0x10, 0x51, 0x50, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x45, 0xE0, 0x4F, 0x80, 0x0F, 0x51, 0x50, 
 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x45, 0xE0, 0x5F, 0xFD, 0x7F, 0x45, 
-0x80, 0x7E, 0x90, 0x83, 0xF9, 0xE0, 0x24, 0xF8, 0xF0, 0xE0, 0x24, 0x04, 0xFF, 0x74, 0x01, 0xA8, 
-0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x43, 0xE0, 0x5F, 0xFD, 
-0x7F, 0x43, 0x12, 0x32, 0x1E, 0x90, 0x83, 0xF9, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 
-0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x43, 0xE0, 0x4F, 0xFD, 0x7F, 0x43, 0x12, 0x32, 
-0x1E, 0x90, 0x83, 0xFA, 0xE0, 0x60, 0x1D, 0x90, 0x83, 0xF9, 0xE0, 0x24, 0x04, 0xFF, 0x74, 0x01, 
-0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x42, 0xE0, 0x4F, 0xFD, 
-0x7F, 0x42, 0x80, 0x1C, 0x90, 0x83, 0xF9, 0xE0, 0x24, 0x04, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 
-0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x42, 0xE0, 0x5F, 0xFD, 0x7F, 0x42, 
-0x12, 0x32, 0x1E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
-0x83, 0x65, 0x74, 0x08, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x83, 
-0x6C, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0xE0, 0x7C, 
-0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x90, 0x83, 0x5D, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x82, 
-0xE0, 0x90, 0x83, 0x64, 0xF0, 0x90, 0x81, 0x7D, 0xE0, 0x20, 0xE0, 0x02, 0xC1, 0x7C, 0x90, 0x81, 
-0x85, 0xE0, 0x20, 0xE0, 0x07, 0x90, 0x01, 0x3F, 0xE0, 0x30, 0xE2, 0x19, 0x90, 0x80, 0x06, 0xE0, 
-0xB4, 0x01, 0x0E, 0x90, 0xFD, 0x01, 0xE0, 0x20, 0xE6, 0x07, 0x90, 0xFD, 0x00, 0xE0, 0x44, 0x10, 
-0xF0, 0x7F, 0x01, 0x31, 0xAF, 0xE4, 0x90, 0x83, 0x63, 0xF0, 0x90, 0x83, 0x64, 0xE0, 0xFF, 0x90, 
-0x83, 0x63, 0xE0, 0xC3, 0x9F, 0x40, 0x02, 0xC1, 0x7C, 0x90, 0x83, 0x5D, 0xE0, 0xFC, 0xA3, 0xE0, 
-0xFD, 0xEC, 0xFF, 0x90, 0xFD, 0x11, 0xF0, 0xAE, 0x05, 0xAA, 0x06, 0x90, 0x83, 0x67, 0xEF, 0xF0, 
-0x74, 0x02, 0x2A, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x33, 0x33, 0x33, 
-0x54, 0xF8, 0xFF, 0x74, 0x03, 0x2A, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x03, 
-0xFE, 0xEF, 0x24, 0x18, 0x2E, 0x90, 0x83, 0x6C, 0xF0, 0xE0, 0xFF, 0x2A, 0x90, 0x83, 0x5F, 0xF0, 
-0x7E, 0x00, 0x90, 0x83, 0x5D, 0xE0, 0xFC, 0xA3, 0xE0, 0x2F, 0xFF, 0xEE, 0x3C, 0x90, 0x83, 0x60, 
-0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x83, 0x5F, 0xE0, 0xFD, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 
-0xF5, 0x83, 0xE0, 0xFE, 0x54, 0xFC, 0x90, 0x83, 0x62, 0xF0, 0xAF, 0x06, 0x74, 0x01, 0x2D, 0xF5, 
-0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFD, 0x90, 0x83, 0x5F, 0xE0, 0x24, 0x04, 0xF5, 0x82, 
-0xE4, 0x34, 0xFB, 0xF1, 0x1F, 0x90, 0x83, 0x66, 0xEF, 0xF0, 0x74, 0x01, 0x2A, 0xF5, 0x82, 0xE4, 
-0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x00, 0x2A, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 
-0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x54, 0x3F, 0xFE, 0x90, 0x83, 0x68, 0xF0, 0xA3, 
-0xEF, 0xF0, 0x90, 0x83, 0x6C, 0xE0, 0x2F, 0xFF, 0xEC, 0x3E, 0xFE, 0x12, 0x77, 0xE6, 0x74, 0x0F, 
-0x2A, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFD, 0x90, 0x83, 0x5D, 0xEE, 0x8F, 0xF0, 
-0x12, 0x41, 0xF6, 0x90, 0x80, 0xF7, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x83, 0x5D, 0xE0, 0xFA, 
-0xA3, 0xE0, 0xD3, 0x9F, 0xEA, 0x9E, 0x40, 0x22, 0x90, 0x83, 0x5D, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
-0x90, 0x80, 0xF7, 0xE0, 0xFA, 0xA3, 0xE0, 0x24, 0x01, 0xFB, 0xE4, 0x3A, 0xFA, 0xC3, 0xEF, 0x9B, 
-0xFF, 0xEE, 0x9A, 0x90, 0x83, 0x5D, 0xF0, 0xA3, 0xEF, 0xF0, 0xED, 0x30, 0xE7, 0x06, 0x90, 0x01, 
-0xC7, 0x74, 0x21, 0xF0, 0xED, 0x30, 0xE6, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x22, 0xF0, 0xED, 0x30, 
-0xE5, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x23, 0xF0, 0x90, 0x83, 0x62, 0xE0, 0x24, 0x40, 0x60, 0x04, 
-0x24, 0x20, 0x70, 0x1E, 0x90, 0x81, 0x80, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x20, 
-0xE0, 0x02, 0xC1, 0x23, 0xD1, 0xBD, 0xEF, 0x60, 0x7A, 0x90, 0x83, 0x62, 0xE0, 0xFF, 0xF1, 0xD8, 
-0x80, 0x71, 0xD1, 0xBD, 0xEF, 0x60, 0x26, 0x90, 0x83, 0x60, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 
-0x83, 0x66, 0xE0, 0xFD, 0x90, 0x83, 0x65, 0xE0, 0xFB, 0x90, 0x83, 0x67, 0xE0, 0x90, 0x83, 0x73, 
-0xF0, 0x12, 0x75, 0xE3, 0xEF, 0x60, 0x06, 0x90, 0x83, 0x6E, 0x74, 0x01, 0xF0, 0x90, 0x81, 0x7D, 
-0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x19, 0x90, 0x83, 0x60, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x83, 
-0x66, 0xE0, 0xFD, 0x12, 0x73, 0xF1, 0xEF, 0x60, 0x06, 0x90, 0x83, 0x6E, 0x74, 0x01, 0xF0, 0x90, 
-0x81, 0x7D, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x30, 0xE0, 0x16, 0x90, 0x83, 0x6E, 
-0xE0, 0x70, 0x10, 0x90, 0x83, 0x60, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x83, 0x66, 0xE0, 0xFD, 
-0x12, 0x76, 0xC6, 0x90, 0x81, 0x85, 0xE0, 0x20, 0xE0, 0x07, 0x90, 0x01, 0x3F, 0xE0, 0x30, 0xE2, 
-0x04, 0x7F, 0x01, 0x31, 0xAF, 0x12, 0x7A, 0xE4, 0xEF, 0x64, 0x01, 0x70, 0x3F, 0xF1, 0xC2, 0x90, 
-0x83, 0x6D, 0xEF, 0xF0, 0x64, 0x01, 0x60, 0x27, 0x90, 0x81, 0x85, 0xE0, 0x44, 0x01, 0xF0, 0x90, 
-0x83, 0x6D, 0xE0, 0xFF, 0xB4, 0x02, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x42, 0xF0, 0x80, 0x0A, 0xEF, 
-0xB4, 0x04, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x43, 0xF0, 0x7F, 0x01, 0x31, 0xAF, 0x80, 0x0D, 0x90, 
-0x83, 0x5D, 0xF1, 0xAF, 0x90, 0x83, 0x63, 0xE0, 0x04, 0xF0, 0x81, 0x4A, 0xD0, 0xD0, 0x92, 0xAF, 
-0x22, 0x90, 0x81, 0x3A, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 
-0xE4, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0xF5, 
-0x52, 0x90, 0x81, 0x78, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0xF5, 0x53, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 
-0x7E, 0x01, 0x12, 0x58, 0x00, 0x90, 0x81, 0x3A, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x90, 0x83, 0x5F, 
-0xE0, 0xFF, 0xE4, 0xFE, 0xEF, 0x2E, 0x24, 0x04, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 
-0xFD, 0x74, 0x6F, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0xED, 0xF0, 0x0E, 0xEE, 0xB4, 
-0x06, 0xE2, 0x78, 0x86, 0x7C, 0x81, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0x6F, 0x7E, 0x00, 
-0x7F, 0x06, 0x12, 0x43, 0xEF, 0xEF, 0x7F, 0x00, 0x70, 0x02, 0x7F, 0x01, 0x22, 0xA3, 0xE0, 0xFE, 
-0x24, 0x20, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFF, 0x74, 0x21, 0x2E, 0xF5, 0x82, 
-0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFD, 0x74, 0x24, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
-0x83, 0xE0, 0xFB, 0xE4, 0xFE, 0xEF, 0x30, 0xE7, 0x04, 0x7C, 0x02, 0x80, 0x02, 0xE4, 0xFC, 0xED, 
-0x30, 0xE6, 0x09, 0xAF, 0x03, 0x12, 0x6E, 0xA5, 0xAE, 0x07, 0x80, 0x02, 0xE4, 0xFE, 0xEC, 0x24, 
-0x18, 0x2E, 0xFF, 0x22, 0x90, 0x81, 0x3A, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x11, 
-0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x42, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0x07, 0x70, 0x2D, 0x80, 
-0x29, 0x90, 0x81, 0x47, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x42, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0x81, 
-0x76, 0xE0, 0xFF, 0x90, 0x81, 0x47, 0xE0, 0xD3, 0x9F, 0x40, 0x0F, 0x90, 0x80, 0xF9, 0xE0, 0xB4, 
-0x01, 0x0A, 0x90, 0x81, 0x3B, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x31, 0x9D, 0x22, 0x8F, 0x0D, 0x7F, 
-0x02, 0x12, 0x46, 0x3A, 0x90, 0x80, 0x01, 0xE0, 0x45, 0x0D, 0xF0, 0x22, 0x12, 0x66, 0x2B, 0x7F, 
-0x02, 0x80, 0xEA, 0x90, 0x81, 0x7D, 0xE0, 0x30, 0xE0, 0x04, 0x7F, 0x10, 0xF1, 0x8D, 0x22, 0xE0, 
-0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x02, 0x84, 0xEF, 0xF0, 0xEE, 0xA3, 0xF0, 0xA3, 0xE0, 0x44, 0x01, 
-0xF0, 0x22, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE2, 0x03, 0x7F, 0x04, 0x22, 0x90, 0x02, 0x86, 0xE0, 
-0x7F, 0x01, 0x20, 0xE1, 0x02, 0x7F, 0x02, 0x22, 0xEF, 0x90, 0x01, 0xC7, 0xB4, 0xA0, 0x05, 0x74, 
-0x04, 0xF0, 0x80, 0x03, 0x74, 0x08, 0xF0, 0x90, 0x81, 0x85, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0xF0, 
-0xE4, 0xF5, 0x52, 0x90, 0x81, 0x77, 0xE0, 0xF5, 0x53, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 
-0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8E, 0x4E, 0x8F, 0x4F, 0xE5, 0x53, 0x54, 0x07, 0xC4, 
-0x33, 0x54, 0xE0, 0x85, 0x4E, 0x83, 0x85, 0x4F, 0x82, 0xF0, 0xE5, 0x52, 0x54, 0x07, 0xC4, 0x33, 
-0x54, 0xE0, 0xFF, 0xE5, 0x53, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0xA3, 0xF0, 0xEB, 0x54, 0x07, 
-0xC4, 0x33, 0x54, 0xE0, 0xFF, 0xE5, 0x52, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0x85, 0x4F, 0x82, 
-0x85, 0x4E, 0x83, 0xA3, 0xA3, 0xF0, 0xBD, 0x01, 0x0D, 0x85, 0x4F, 0x82, 0x8E, 0x83, 0xA3, 0xA3, 
-0xA3, 0x74, 0x03, 0xF0, 0x80, 0x0C, 0x85, 0x4F, 0x82, 0x85, 0x4E, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 
-0x01, 0xF0, 0x85, 0x4F, 0x82, 0x85, 0x4E, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 
-0x92, 0xAF, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x20, 0xE7, 0x09, 0xE0, 0x7F, 0x01, 0x20, 0xE6, 0x0C, 
-0x7F, 0x02, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x30, 0xE6, 0x02, 0x7F, 0x03, 0x22, 0x11, 0x73, 0x90, 
-0x80, 0x06, 0xEF, 0xF0, 0x11, 0x9F, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x02, 0x2D, 0xA7, 0x31, 
-0x0B, 0x31, 0x3B, 0x11, 0xCD, 0x11, 0xEC, 0xE4, 0xF5, 0x35, 0xF5, 0x36, 0xF5, 0x37, 0x75, 0x38, 
-0x80, 0xAD, 0x35, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xAD, 0x36, 0x7F, 0x51, 0x12, 0x32, 0x1E, 0xAD, 
-0x37, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xAD, 0x38, 0x7F, 0x53, 0x02, 0x32, 0x1E, 0x75, 0x3D, 0x10, 
-0xE4, 0xF5, 0x3E, 0x75, 0x3F, 0x07, 0x75, 0x40, 0x02, 0x90, 0x01, 0x30, 0xE5, 0x3D, 0xF0, 0xA3, 
-0xE5, 0x3E, 0xF0, 0xA3, 0xE5, 0x3F, 0xF0, 0xA3, 0xE5, 0x40, 0xF0, 0x22, 0x75, 0x45, 0x06, 0x75, 
-0x46, 0x01, 0x75, 0x47, 0x03, 0x75, 0x48, 0x62, 0x90, 0x01, 0x38, 0xE5, 0x45, 0xF0, 0xA3, 0xE5, 
-0x46, 0xF0, 0xA3, 0xE5, 0x47, 0xF0, 0xA3, 0xE5, 0x48, 0xF0, 0x22, 0x90, 0x01, 0x30, 0xE4, 0xF0, 
-0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x38, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 
-0xFD, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x51, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 
-0x52, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x53, 0x02, 0x32, 0x1E, 0x90, 0x01, 0x34, 0x74, 0xFF, 
-0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x3C, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 
-0xF0, 0xFD, 0x7F, 0x54, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 
-0x7F, 0x56, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x57, 0x02, 0x32, 0x1E, 0x90, 0x01, 0xCF, 0xE0, 
-0x90, 0x83, 0xFF, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 
-0xEF, 0x30, 0xE5, 0x22, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 
-0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x31, 0x0B, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 
-0x03, 0x12, 0x32, 0x1E, 0x80, 0xFE, 0x22, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 
-0x12, 0x32, 0x1E, 0x90, 0xFD, 0x00, 0xE0, 0x54, 0xBF, 0xF0, 0x51, 0x39, 0x12, 0x32, 0x77, 0x51, 
-0x1A, 0x51, 0x54, 0x7F, 0x01, 0x12, 0x45, 0x28, 0x90, 0x83, 0x3F, 0x74, 0x02, 0xF0, 0xFF, 0x12, 
-0x45, 0x28, 0x90, 0x83, 0x3F, 0xE0, 0x04, 0xF0, 0x11, 0x8D, 0x31, 0xF6, 0x90, 0x00, 0x80, 0xE0, 
-0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x75, 0x20, 0xFF, 0x51, 0x21, 0x51, 0x28, 0x51, 
-0x2F, 0xE4, 0xFF, 0x02, 0x45, 0xB1, 0x51, 0x1B, 0x51, 0x46, 0x12, 0x71, 0x75, 0x12, 0x4E, 0x37, 
-0x51, 0x62, 0x51, 0x79, 0x90, 0x83, 0x4C, 0xE0, 0x54, 0x7F, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0xDF, 
-0xF0, 0x54, 0xF0, 0xF0, 0xE4, 0x90, 0x83, 0x4E, 0xF0, 0x22, 0x22, 0xE4, 0x90, 0x80, 0xF9, 0xF0, 
-0x22, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x84, 0x22, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0x90, 
-0x01, 0xE4, 0x74, 0x10, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 
-0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0xE4, 0x90, 0x80, 0xF5, 0xF0, 0xA3, 0xF0, 0x90, 0x80, 0x5D, 
-0xF0, 0xA3, 0xF0, 0x22, 0xE4, 0x90, 0x80, 0x01, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 
-0xF0, 0x22, 0x90, 0x83, 0x40, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0x7F, 0xF0, 0x54, 0xFB, 0xF0, 0xA3, 
-0x74, 0x0A, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x83, 0x44, 0xE0, 0x54, 0xFE, 0xF0, 
-0xA3, 0x74, 0x08, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0xE4, 0x90, 0x83, 0x48, 0xF0, 0xA3, 0xF0, 0xA3, 
-0xF0, 0x90, 0x83, 0x44, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x83, 0x47, 0xF0, 0x90, 0x83, 0x4B, 
-0xF0, 0x22, 0x51, 0x79, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x83, 0x44, 0xE0, 0x54, 
-0xFE, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x2C, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 
-0x83, 0x45, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x90, 0x83, 0x46, 0xF0, 0x12, 0x1F, 0xA4, 
-0x54, 0x04, 0xFF, 0x90, 0x83, 0x44, 0xE0, 0x54, 0xFB, 0x4F, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 
-0xBD, 0x90, 0x83, 0x47, 0xF0, 0x22, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x3A, 0x90, 0x83, 0x5D, 0xEF, 
-0xF0, 0x12, 0x42, 0x43, 0x5B, 0x28, 0x00, 0x5B, 0x31, 0x01, 0x5B, 0x39, 0x02, 0x5B, 0x42, 0x03, 
-0x5B, 0x4A, 0x04, 0x5B, 0x52, 0x14, 0x5B, 0x5A, 0x20, 0x5B, 0x62, 0x21, 0x5B, 0x6B, 0x23, 0x5B, 
-0x73, 0x25, 0x5B, 0x83, 0x80, 0x5B, 0x7B, 0x81, 0x5B, 0x8C, 0x82, 0x5B, 0x94, 0x83, 0x5B, 0x9D, 
-0x84, 0x5B, 0xA6, 0x88, 0x00, 0x00, 0x5B, 0xAE, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0x02, 0x65, 
-0x58, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0x81, 0x22, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0x02, 
-0x65, 0xA4, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0xE1, 0xB3, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 
-0x41, 0xA2, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0xE1, 0x37, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 
-0xA1, 0xF5, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0x02, 0x65, 0xE7, 0x90, 0x83, 0x5E, 0x12, 0x42, 
-0x31, 0xE1, 0x27, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0xE1, 0x2F, 0x90, 0x83, 0x5E, 0x12, 0x42, 
-0x31, 0x81, 0xA1, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0x02, 0x79, 0xA8, 0x90, 0x83, 0x5E, 0x12, 
-0x42, 0x31, 0xE1, 0x7B, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0x02, 0x7B, 0x0A, 0x90, 0x83, 0x5E, 
-0x12, 0x42, 0x31, 0x02, 0x7B, 0x6C, 0x90, 0x83, 0x5E, 0x12, 0x42, 0x31, 0xE1, 0x46, 0x90, 0x01, 
-0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x83, 0x5D, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0xD3, 0x10, 
-0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x80, 0x5E, 0xE0, 0xFF, 0x90, 0x80, 0x5D, 0xE0, 0xB5, 0x07, 
-0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x43, 0x90, 0x80, 0x5D, 0xE0, 0xFE, 0x75, 
-0xF0, 0x08, 0x90, 0x80, 0x0D, 0x12, 0x42, 0x25, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 
-0x0E, 0xF9, 0x74, 0x80, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x51, 0xE6, 0x90, 0x80, 0x5D, 
-0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 
-0x80, 0x5D, 0xF0, 0x12, 0x66, 0x2B, 0x90, 0x80, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 
-0xAF, 0x22, 0x8B, 0x1A, 0x8A, 0x1B, 0x89, 0x1C, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0xFF, 0xF5, 
-0x1E, 0x12, 0x1F, 0xA4, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x0A, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 
-0xF5, 0x1F, 0x80, 0x02, 0x8F, 0x1F, 0x85, 0x1E, 0x1D, 0xE5, 0x1D, 0xD3, 0x95, 0x1F, 0x50, 0x33, 
-0xAB, 0x1A, 0xAA, 0x1B, 0xA9, 0x1C, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 0x74, 0xF9, 0x25, 0x1D, 
-0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 0xF9, 0x25, 0x1D, 0xF5, 0x82, 0xE4, 
-0x34, 0x80, 0xF5, 0x83, 0xE0, 0xAF, 0x1D, 0x70, 0x04, 0xF1, 0x26, 0x80, 0x02, 0xF1, 0x25, 0x05, 
-0x1D, 0x80, 0xC6, 0xE5, 0x1E, 0x70, 0x19, 0x90, 0x80, 0xF9, 0xE0, 0x70, 0x13, 0x12, 0x4E, 0x98, 
-0x12, 0x4F, 0x1F, 0x90, 0x81, 0x3A, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 
-0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 
-0x81, 0x7D, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 
-0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 0xFF, 0x90, 0x81, 
-0x7D, 0xF0, 0xEE, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 
-0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x4D, 0xFF, 0x90, 0x81, 0x7D, 0xF0, 0xEE, 0x54, 0x20, 0xFE, 
-0xEF, 0x54, 0xDF, 0x4E, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 
-0x4D, 0xFF, 0x90, 0x81, 0x7D, 0xF0, 0xEE, 0x54, 0x80, 0xFE, 0xEF, 0x54, 0x7F, 0x4E, 0xF0, 0x90, 
-0x00, 0x02, 0x12, 0x1F, 0xBD, 0x54, 0x01, 0xFF, 0x90, 0x81, 0x7F, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 
-0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 
-0x90, 0x80, 0xF7, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x81, 0x7D, 0xE0, 0xC3, 0x13, 0x54, 0x01, 0xFF, 
-0xB1, 0x51, 0x90, 0x81, 0x7D, 0xE0, 0x54, 0x01, 0xFF, 0x12, 0x4D, 0xBA, 0xD0, 0xD0, 0x92, 0xAF, 
-0x22, 0xEF, 0x60, 0x07, 0x90, 0x83, 0x31, 0xE0, 0xFF, 0xB1, 0x5C, 0x22, 0xF1, 0x67, 0x90, 0x83, 
-0xEE, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x83, 0xEE, 0x12, 0x56, 0xFD, 0x90, 0x83, 0xF0, 0xEF, 
-0xF0, 0x90, 0x83, 0xEE, 0xA3, 0xE0, 0x24, 0x30, 0xF9, 0xE4, 0x34, 0xFC, 0x75, 0x13, 0x01, 0xF5, 
-0x14, 0x89, 0x15, 0x75, 0x16, 0x06, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x9C, 0x12, 0x2B, 0xED, 0x90, 
-0x83, 0xEE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x24, 0x36, 0xF9, 0xE4, 0x34, 0xFC, 0x75, 0x13, 
-0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x04, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xA2, 0x12, 0x2B, 
-0xED, 0x90, 0x83, 0xEE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x24, 0x3A, 0xF9, 0xE4, 0x34, 0xFC, 
-0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x06, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xA6, 
-0x12, 0x2B, 0xED, 0x90, 0x83, 0xEE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x24, 0x40, 0xF9, 0xE4, 
-0x34, 0xFC, 0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x04, 0x7B, 0x01, 0x7A, 0x81, 
-0x79, 0xAC, 0x02, 0x2B, 0xED, 0x90, 0x83, 0x61, 0x12, 0x42, 0x3A, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 
-0x7F, 0x90, 0x81, 0x3E, 0xF0, 0xEF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0xA3, 0xF0, 0x90, 0x00, 
-0x01, 0x12, 0x1F, 0xBD, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0x81, 0x3C, 0xE0, 0x54, 
-0xF0, 0x4E, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 0x81, 
-0x3A, 0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0x90, 0x81, 0x3C, 
-0xE0, 0x54, 0x0F, 0x4F, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x90, 0x81, 0x3D, 0xF0, 0x90, 
-0x00, 0x06, 0x12, 0x1F, 0xBD, 0x30, 0xE0, 0x5E, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 0x04, 
-0x90, 0x81, 0x50, 0x50, 0x04, 0xEF, 0xF0, 0x80, 0x2E, 0x74, 0x03, 0xF0, 0x90, 0x83, 0x61, 0x12, 
-0x42, 0x31, 0xE9, 0x24, 0x06, 0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x1F, 0xA4, 0xFF, 0x74, 0x03, 0x24, 
-0xFD, 0xFE, 0xEF, 0xC4, 0x54, 0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 0xED, 0x2E, 0x54, 0x0F, 0xFE, 
-0xC4, 0x54, 0xF0, 0x4F, 0x12, 0x1F, 0xEA, 0x90, 0x83, 0x61, 0x12, 0x42, 0x31, 0x90, 0x00, 0x06, 
-0x12, 0x1F, 0xBD, 0xC4, 0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x81, 0x46, 0x50, 0x05, 0x74, 
-0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 0x90, 0x83, 0x61, 0x12, 0x42, 0x31, 0x90, 0x00, 0x04, 0x12, 
-0x1F, 0xBD, 0xFD, 0x7F, 0x02, 0x12, 0x4B, 0x33, 0x90, 0x83, 0x61, 0x12, 0x42, 0x31, 0xD1, 0xF5, 
-0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0xF0, 0x90, 0x81, 0x3E, 0xE0, 0x90, 0x01, 
-0xBA, 0xF0, 0x90, 0x81, 0x40, 0xE0, 0x90, 0x01, 0xBB, 0xF0, 0x90, 0x81, 0x3C, 0xE0, 0x54, 0x0F, 
-0x90, 0x01, 0xBE, 0xF0, 0x22, 0x90, 0x83, 0x64, 0x12, 0x42, 0x3A, 0xF1, 0x56, 0x90, 0x81, 0x3E, 
-0xE0, 0xFF, 0x12, 0x4F, 0x31, 0x90, 0x81, 0x3E, 0xE0, 0x60, 0x19, 0x90, 0x83, 0x64, 0x12, 0x42, 
-0x31, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x54, 0x0F, 0xFF, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 
-0xFD, 0x12, 0x73, 0x1E, 0x22, 0x22, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x48, 0xF0, 0x22, 0x12, 
-0x1F, 0xA4, 0x90, 0x81, 0x7C, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 0x90, 0x83, 0x51, 
-0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFF, 0x12, 0x1F, 0xA4, 0xFE, 0xEF, 
-0x2E, 0x90, 0x83, 0x3E, 0xF0, 0x22, 0x90, 0x81, 0x3A, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x81, 
-0x47, 0xF0, 0x90, 0x81, 0x42, 0xF0, 0x22, 0xE4, 0xFE, 0xEF, 0xC3, 0x13, 0xFD, 0xEF, 0x30, 0xE0, 
-0x02, 0x7E, 0x80, 0x90, 0xFD, 0x10, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0x90, 0x02, 0x09, 0xE0, 0x90, 
-0x83, 0x61, 0xF0, 0x12, 0x1F, 0xA4, 0x90, 0x83, 0x2E, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 
-0x90, 0x83, 0x2F, 0xF0, 0x22, 0xF1, 0x67, 0x7E, 0x00, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFC, 
-0x75, 0x13, 0x01, 0xF5, 0x14, 0x89, 0x15, 0x75, 0x16, 0x08, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x48, 
-0x02, 0x2B, 0xED, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x83, 0x40, 0xE0, 0x54, 0xFE, 
-0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x04, 0xFF, 0xEE, 0x54, 0xFB, 0x4F, 0xF0, 0x12, 0x1F, 0xA4, 0xC3, 
-0x13, 0x30, 0xE0, 0x0A, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x83, 0x41, 0xF0, 0x22, 0xE4, 
-0x90, 0x83, 0x58, 0xF0, 0x90, 0x83, 0x58, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0xDF, 0x90, 0x01, 0xC4, 
-0xF0, 0x74, 0x5F, 0xA3, 0xF0, 0x90, 0x81, 0x3E, 0xE0, 0x60, 0x0F, 0x90, 0x81, 0x41, 0xE0, 0xFF, 
-0x90, 0x81, 0x40, 0xE0, 0x6F, 0x60, 0x03, 0x12, 0x51, 0x9D, 0xC2, 0xAF, 0x31, 0x1C, 0xBF, 0x01, 
-0x02, 0x11, 0x1C, 0xD2, 0xAF, 0x11, 0xFE, 0x12, 0x44, 0x60, 0x80, 0xC8, 0x90, 0x81, 0x3A, 0xE0, 
-0x30, 0xE0, 0x02, 0x11, 0x26, 0x22, 0x90, 0x81, 0x41, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x0D, 
-0x31, 0x4D, 0xBF, 0x01, 0x08, 0x11, 0x3E, 0x90, 0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 0xD3, 0x10, 
-0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x11, 0xB9, 0x11, 0x4E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x11, 0xFF, 
-0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 0xFD, 0x7F, 0x08, 0x12, 0x32, 0x1E, 0xE4, 0xFF, 0x90, 0x83, 
-0x59, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 
-0x02, 0x7F, 0x01, 0x90, 0x83, 0x59, 0xE0, 0x6F, 0x60, 0x3E, 0xC3, 0x90, 0x83, 0x5B, 0xE0, 0x94, 
-0x88, 0x90, 0x83, 0x5A, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 
-0x22, 0x90, 0x83, 0x5A, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x41, 0xF6, 0x7F, 0x14, 0x7E, 0x00, 0x12, 
-0x32, 0xAA, 0xD3, 0x90, 0x83, 0x5B, 0xE0, 0x94, 0x32, 0x90, 0x83, 0x5A, 0xE0, 0x94, 0x00, 0x40, 
-0xB7, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xB0, 0x22, 0x90, 0x81, 0x48, 0xE0, 0xFD, 0x7F, 0x93, 
-0x12, 0x32, 0x1E, 0x90, 0x81, 0x3F, 0xE0, 0x60, 0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 
-0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 
-0x10, 0xFD, 0x7F, 0x08, 0x12, 0x32, 0x1E, 0x7F, 0x01, 0x11, 0x5E, 0x90, 0x00, 0x90, 0xE0, 0x44, 
-0x01, 0xFD, 0x7F, 0x90, 0x12, 0x32, 0x1E, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x32, 0xAA, 0x22, 0x90, 
-0x01, 0xC4, 0x74, 0xFF, 0xF0, 0x74, 0x60, 0xA3, 0xF0, 0x90, 0x00, 0x90, 0xE0, 0x20, 0xE0, 0xF9, 
-0x74, 0xFF, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x60, 0xA3, 0xF0, 0x22, 0x7D, 0x02, 0x90, 0x01, 
-0xC4, 0x74, 0x1C, 0xF0, 0x74, 0x61, 0xA3, 0xF0, 0x90, 0x83, 0x3F, 0xE0, 0xFF, 0xED, 0xC3, 0x9F, 
-0x50, 0x18, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x0B, 0x90, 0x01, 0xB8, 0x74, 
-0x08, 0xF0, 0xA3, 0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xDE, 0x7F, 0x01, 0x22, 0x90, 0x02, 0x87, 
-0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x80, 0x49, 0x90, 0x81, 0x7D, 0xE0, 0x30, 
-0xE0, 0x0E, 0x90, 0x02, 0x82, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x34, 
-0x90, 0x81, 0x85, 0xE0, 0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x80, 0x25, 0x90, 
-0x02, 0x86, 0xE0, 0x20, 0xE1, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x16, 0x90, 0x04, 
-0x1D, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x40, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 0xE4, 
-0xF0, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 0xE4, 0xFB, 0xFA, 
-0xFD, 0x7F, 0x01, 0x12, 0x46, 0x61, 0x90, 0x83, 0x5C, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x80, 0x01, 
-0xE0, 0xFF, 0x60, 0xE9, 0xC2, 0xAF, 0x30, 0xE1, 0x06, 0x54, 0xFD, 0xF0, 0x12, 0x5B, 0xBE, 0xD2, 
-0xAF, 0xC2, 0xAF, 0x90, 0x80, 0x01, 0xE0, 0xFF, 0x30, 0xE2, 0x05, 0x54, 0xFB, 0xF0, 0x31, 0xFB, 
-0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x80, 0x01, 0xE0, 0xFF, 0x30, 0xE4, 0x0B, 0x54, 0xEF, 0xF0, 0x51, 
-0xB6, 0xBF, 0x01, 0x03, 0x12, 0x53, 0xD8, 0xD2, 0xAF, 0x80, 0xC2, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
-0xC0, 0xD0, 0xE4, 0xFF, 0x90, 0x80, 0xF6, 0xE0, 0xFE, 0x90, 0x80, 0xF5, 0xE0, 0xFD, 0xB5, 0x06, 
-0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x32, 0x90, 0x01, 0xAF, 0xE0, 
-0x70, 0x13, 0xED, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x5F, 0xF9, 0x74, 0x80, 0x35, 0xF0, 0xFA, 0x7B, 
-0x01, 0x51, 0x53, 0x7F, 0x01, 0xEF, 0x60, 0x16, 0x90, 0x80, 0xF5, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 
-0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0xF5, 0xF0, 0xD0, 0xD0, 
-0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0x5D, 0x12, 0x42, 0x3A, 
-0x90, 0x83, 0xF2, 0xE0, 0xFF, 0x04, 0xF0, 0x90, 0x00, 0x01, 0xEF, 0x12, 0x1F, 0xFC, 0x7F, 0xAF, 
-0x7E, 0x01, 0x51, 0xF3, 0xEF, 0x60, 0x3A, 0x90, 0x83, 0x5D, 0x12, 0x42, 0x31, 0x8B, 0x13, 0x8A, 
-0x14, 0x89, 0x15, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x24, 0x02, 0xF5, 0x16, 0x7B, 0x01, 0x7A, 
-0x01, 0x79, 0xA0, 0x12, 0x2B, 0xED, 0x90, 0x83, 0x5D, 0x12, 0x42, 0x31, 0x90, 0x00, 0x0E, 0x12, 
-0x1F, 0xBD, 0x90, 0x01, 0xAE, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0x90, 0x01, 0xCB, 0xE0, 0x64, 0x80, 
-0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0x90, 0x83, 0xFB, 0xF0, 0xA3, 0xF0, 0x90, 0x02, 0x86, 
-0xE0, 0x20, 0xE1, 0x2C, 0xC3, 0x90, 0x83, 0xFC, 0xE0, 0x94, 0xD0, 0x90, 0x83, 0xFB, 0xE0, 0x94, 
-0x07, 0x40, 0x0A, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x83, 0xFB, 
-0xE4, 0x75, 0xF0, 0x01, 0x12, 0x41, 0xF6, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x80, 0xCD, 
-0x7F, 0x01, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0xDA, 0xEE, 0xF0, 0xA3, 
-0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x83, 0xDA, 0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 
-0x8E, 0x83, 0xE0, 0x60, 0x2D, 0xC3, 0x90, 0x83, 0xDD, 0xE0, 0x94, 0xE8, 0x90, 0x83, 0xDC, 0xE0, 
-0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 0x15, 0x90, 
-0x83, 0xDC, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x41, 0xF6, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x32, 0xAA, 
-0x80, 0xC5, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x83, 0x9A, 0xEF, 0xF0, 0xA3, 0xED, 
-0xF0, 0xA3, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x90, 0x83, 0xA8, 0xF0, 0x7F, 0x24, 
-0x7E, 0x08, 0x12, 0x2D, 0x5C, 0x90, 0x83, 0xA0, 0x12, 0x20, 0xCE, 0x90, 0x83, 0x9A, 0xE0, 0xFB, 
-0x70, 0x08, 0x90, 0x83, 0xA0, 0x12, 0x42, 0x19, 0x80, 0x16, 0xEB, 0x75, 0xF0, 0x08, 0xA4, 0x24, 
-0x62, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x2D, 0x5C, 
-0x90, 0x83, 0xA4, 0x12, 0x20, 0xCE, 0x90, 0x83, 0x9B, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 
-0x17, 0x12, 0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x83, 0xA4, 0x12, 
-0x42, 0x19, 0xED, 0x54, 0x7F, 0xFD, 0xEC, 0x54, 0x80, 0xFC, 0x12, 0x42, 0x0C, 0xEC, 0x44, 0x80, 
-0xFC, 0x90, 0x83, 0xA4, 0x12, 0x20, 0xCE, 0x90, 0x83, 0xA0, 0x12, 0x42, 0x19, 0xEC, 0x54, 0x7F, 
-0xFC, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x83, 
-0x9A, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x62, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 
-0xFE, 0xA3, 0xE0, 0xFF, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x83, 0xA4, 0x12, 0x42, 0x19, 0x90, 0x85, 
-0xBB, 0x12, 0x20, 0xCE, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x2E, 0xA2, 0x90, 0x83, 0xA0, 0x12, 0x42, 
-0x19, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0x7F, 0x24, 0x7E, 0x08, 0x12, 
-0x2E, 0xA2, 0x90, 0x83, 0x9A, 0xE0, 0x70, 0x04, 0x7F, 0x20, 0x80, 0x09, 0x90, 0x83, 0x9A, 0xE0, 
+0x80, 0x63, 0x90, 0x84, 0x30, 0xE0, 0x24, 0xF8, 0xF0, 0xE0, 0x24, 0x04, 0x51, 0x54, 0x80, 0x02, 
+0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x43, 0xE0, 0x5F, 0xFD, 0x7F, 0x43, 0x51, 0x4D, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x43, 0xE0, 0x4F, 0xFD, 0x7F, 0x43, 0x12, 
+0x7A, 0x24, 0x60, 0x19, 0x90, 0x84, 0x30, 0xE0, 0x24, 0x04, 0x51, 0x54, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x42, 0xE0, 0x4F, 0xFD, 0x7F, 0x42, 0x80, 0x18, 0x90, 0x84, 0x30, 
+0xE0, 0x24, 0x04, 0x51, 0x54, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x42, 
+0xE0, 0x5F, 0xFD, 0x7F, 0x42, 0x12, 0x32, 0x1E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x32, 0x1E, 
+0x90, 0x84, 0x30, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x22, 0xAD, 0x07, 0x90, 0x81, 0xB8, 
+0xE0, 0x75, 0xF0, 0x40, 0xA4, 0xFF, 0x90, 0x84, 0x23, 0xE5, 0xF0, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 
+0xA3, 0xF0, 0x90, 0x81, 0xB9, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0x84, 0x26, 0xF0, 0xED, 0x64, 
+0x01, 0x70, 0x6B, 0x90, 0x84, 0x23, 0xE0, 0x70, 0x02, 0xA3, 0xE0, 0x60, 0x0B, 0x90, 0x84, 0x23, 
+0x74, 0xFF, 0x75, 0xF0, 0xD0, 0x12, 0x41, 0xF6, 0x51, 0xFA, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 
+0x02, 0x7D, 0x01, 0x31, 0x80, 0x51, 0xFA, 0x54, 0x01, 0xFD, 0x31, 0x80, 0x90, 0x81, 0xB9, 0xE0, 
+0x30, 0xE0, 0x3B, 0x51, 0xEF, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x31, 0x80, 
+0xE4, 0x90, 0x84, 0x25, 0xF0, 0x90, 0x84, 0x26, 0xE0, 0xFF, 0x90, 0x84, 0x25, 0xE0, 0xC3, 0x9F, 
+0x50, 0x1C, 0x51, 0xEF, 0x54, 0x01, 0xFD, 0x31, 0x80, 0x51, 0xEF, 0x54, 0x07, 0x7D, 0x00, 0x20, 
+0xE0, 0x02, 0x7D, 0x01, 0x31, 0x80, 0x90, 0x84, 0x25, 0xE0, 0x04, 0xF0, 0x80, 0xD7, 0x22, 0x90, 
+0x84, 0x23, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x32, 0xAA, 0x90, 0x81, 0xB7, 0xE0, 0x54, 0x7F, 
+0xFF, 0x90, 0x81, 0xB6, 0xE0, 0xFE, 0xC4, 0x13, 0x22, 0xF0, 0x90, 0x00, 0x01, 0x02, 0x1F, 0xBD, 
+0x4D, 0xFF, 0x90, 0x81, 0xB6, 0xF0, 0xEE, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 
+0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0xA5, 0x90, 0x81, 0xB3, 0x71, 0x18, 0x54, 0x04, 0xFD, 0xEF, 0x54, 
+0xFB, 0x71, 0x96, 0xF1, 0xE4, 0x71, 0x26, 0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x71, 0x96, 0xF1, 
+0xEC, 0x71, 0x26, 0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 0x71, 0x96, 0xF1, 0xF4, 0xB1, 0x87, 0x54, 
+0x01, 0xFF, 0x90, 0x81, 0xB5, 0xE0, 0x54, 0xFE, 0x4F, 0x71, 0x09, 0x54, 0x01, 0xFF, 0x90, 0x81, 
+0xB4, 0xE0, 0x54, 0xFE, 0x4F, 0x12, 0x66, 0x3B, 0x12, 0x7A, 0x04, 0x90, 0x81, 0xB3, 0xE0, 0xC3, 
+0x13, 0x54, 0x01, 0xFF, 0x12, 0x79, 0x98, 0x90, 0x81, 0xB3, 0xE0, 0x54, 0x01, 0xFF, 0x12, 0x5A, 
+0x3F, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x4D, 0xFF, 0x90, 0x81, 0xB3, 0xF0, 0xEE, 0x22, 0x90, 0x83, 
+0xE2, 0xF1, 0xB0, 0x90, 0x83, 0xE7, 0x71, 0x09, 0x90, 0x83, 0xE8, 0xD1, 0x46, 0x90, 0x83, 0xE9, 
+0xF1, 0x12, 0x90, 0x83, 0xEA, 0x91, 0x65, 0x90, 0x83, 0xEB, 0xF0, 0x90, 0x00, 0x07, 0x12, 0x1F, 
+0xBD, 0x90, 0x83, 0xEC, 0xB1, 0xC9, 0x90, 0x83, 0xEF, 0xF0, 0xED, 0x70, 0x19, 0xFF, 0x91, 0x6C, 
+0xE0, 0xB4, 0xFF, 0x06, 0x91, 0x6C, 0xE4, 0xF0, 0x80, 0x07, 0x91, 0x6C, 0xE0, 0x04, 0xF0, 0x80, 
+0x05, 0x0F, 0xEF, 0xB4, 0x06, 0xE8, 0x90, 0x83, 0xE6, 0xE0, 0xFF, 0xB4, 0x04, 0x19, 0xA3, 0xE0, 
+0xFE, 0x91, 0x5F, 0xEE, 0x12, 0x7A, 0x0C, 0xFE, 0x91, 0x5F, 0x90, 0x00, 0x01, 0xEE, 0x12, 0x1F, 
+0xFC, 0x90, 0x00, 0x02, 0xE4, 0x80, 0x1D, 0xEF, 0xB4, 0x02, 0x1C, 0x90, 0x83, 0xE8, 0x91, 0x5D, 
+0xEF, 0x12, 0x7A, 0x0C, 0x44, 0x20, 0x54, 0x7F, 0x91, 0x5E, 0x12, 0x6D, 0xC9, 0x90, 0x83, 0xE7, 
+0xE0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xFC, 0x91, 0x5F, 0xE9, 0x24, 0x03, 0xF1, 0xD5, 0x44, 0x20, 
+0x12, 0x1F, 0xEA, 0x90, 0x83, 0xE9, 0x91, 0x5D, 0x90, 0x00, 0x04, 0xEF, 0x12, 0x1F, 0xFC, 0x90, 
+0x83, 0xEA, 0xE0, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xFC, 0x90, 0x83, 0xEB, 0xE0, 0x90, 0x00, 0x06, 
+0x12, 0x1F, 0xFC, 0x90, 0x83, 0xEC, 0xE0, 0x90, 0x00, 0x07, 0x02, 0x1F, 0xFC, 0xE0, 0xFF, 0x90, 
+0x83, 0xE2, 0x02, 0x42, 0x31, 0xF0, 0x90, 0x00, 0x06, 0x02, 0x1F, 0xBD, 0x74, 0xE7, 0x2F, 0xF5, 
+0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0x22, 0x90, 0x83, 0x97, 0x12, 0x42, 0x3A, 0x90, 0x83, 0x96, 
+0xEF, 0xF0, 0x12, 0x42, 0x43, 0x54, 0xB9, 0x00, 0x54, 0xC1, 0x01, 0x54, 0xCA, 0x02, 0x54, 0xD3, 
+0x03, 0x54, 0xDB, 0x04, 0x54, 0xE3, 0x14, 0x54, 0xEC, 0x20, 0x54, 0xF4, 0x21, 0x54, 0xFC, 0x23, 
+0x55, 0x05, 0x25, 0x55, 0x16, 0x80, 0x55, 0x0E, 0x81, 0x55, 0x1E, 0x82, 0x55, 0x27, 0x83, 0x55, 
+0x2F, 0x84, 0x55, 0x37, 0x88, 0x00, 0x00, 0x55, 0x40, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 0xA1, 
+0x8E, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 0x02, 0x59, 0xDF, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 
+0x02, 0x70, 0xA8, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 0xE1, 0xB6, 0x90, 0x83, 0x97, 0x12, 0x42, 
+0x31, 0x80, 0x6D, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 0x02, 0x70, 0xE5, 0x90, 0x83, 0x97, 0x12, 
+0x42, 0x31, 0x01, 0x06, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 0xC1, 0x4D, 0x90, 0x83, 0x97, 0x12, 
+0x42, 0x31, 0x02, 0x70, 0xF4, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 0x02, 0x70, 0xFC, 0x90, 0x83, 
+0x97, 0x12, 0x42, 0x31, 0x61, 0x2D, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 0x01, 0xB8, 0x90, 0x83, 
+0x97, 0x12, 0x42, 0x31, 0x02, 0x79, 0x3E, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 0xA1, 0xD0, 0x90, 
+0x83, 0x97, 0x12, 0x42, 0x31, 0xC1, 0x0B, 0x90, 0x83, 0x97, 0x12, 0x42, 0x31, 0x02, 0x79, 0x54, 
+0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x83, 0x96, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 
+0x90, 0x83, 0x9A, 0x12, 0x42, 0x3A, 0x12, 0x79, 0xA4, 0x11, 0xB2, 0xF1, 0xA5, 0x12, 0x5E, 0x91, 
+0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x1D, 0x71, 0x0A, 0x90, 0x83, 0x7C, 0xB1, 0x87, 0x90, 
+0x83, 0x7D, 0xF0, 0x12, 0x1F, 0xA4, 0x54, 0x04, 0xFF, 0x90, 0x83, 0x7B, 0xE0, 0x54, 0xFB, 0xB1, 
+0xC8, 0x90, 0x83, 0x7E, 0xF0, 0x22, 0x4F, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x1F, 0xBD, 0x90, 0x02, 
+0x09, 0xE0, 0xF5, 0x1A, 0x12, 0x1F, 0xA4, 0x25, 0x1A, 0x90, 0x80, 0x07, 0x71, 0x09, 0x25, 0x1A, 
+0x90, 0x80, 0x08, 0xB1, 0x87, 0x25, 0x1A, 0x90, 0x80, 0x09, 0xB1, 0xC9, 0x25, 0x1A, 0x90, 0x80, 
+0x0A, 0xD1, 0x46, 0x25, 0x1A, 0x90, 0x80, 0x0B, 0xF1, 0x12, 0x25, 0x1A, 0x90, 0x80, 0x0C, 0x91, 
+0x65, 0x25, 0x1A, 0x90, 0x80, 0x0D, 0xF0, 0x22, 0x4F, 0xF0, 0x90, 0x00, 0x03, 0x02, 0x1F, 0xBD, 
+0x12, 0x79, 0xBE, 0x2E, 0x90, 0x83, 0x67, 0x71, 0x09, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x68, 0xB1, 
+0x87, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x69, 0xB1, 0xC9, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x6A, 0xD1, 
+0x46, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x6B, 0xF1, 0x12, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x6C, 0x91, 
+0x65, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x83, 0x6D, 0xF0, 0x22, 0x12, 0x79, 0xBE, 0x2E, 0x90, 
+0x83, 0x6E, 0x71, 0x09, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x6F, 0xB1, 0x87, 0xFF, 0xED, 0x2F, 0x90, 
+0x83, 0x70, 0xB1, 0xC9, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x71, 0xD1, 0x46, 0xFF, 0xED, 0x2F, 0x90, 
+0x83, 0x72, 0xF1, 0x12, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x73, 0x91, 0x65, 0xFF, 0xAE, 0x05, 0xED, 
+0x2F, 0x90, 0x83, 0x74, 0xF0, 0x22, 0xF0, 0x90, 0x00, 0x04, 0x02, 0x1F, 0xBD, 0xB1, 0x88, 0xFF, 
+0x30, 0xE0, 0x1B, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0xAC, 0x71, 0x09, 0x90, 0x81, 0xAD, 0xF0, 0xEF, 
+0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0xB1, 0xC8, 0x90, 0x81, 0xAF, 0xF0, 0x22, 0x90, 0x81, 
+0xAC, 0x74, 0x05, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 0x1E, 0xF0, 0xA3, 
+0x74, 0x05, 0xF0, 0x22, 0x90, 0x84, 0x0B, 0xED, 0xF0, 0x90, 0x84, 0x08, 0x12, 0x42, 0x3A, 0xE4, 
+0x90, 0x84, 0x0C, 0xF0, 0xA3, 0xF0, 0x12, 0x1F, 0xA4, 0xFF, 0x71, 0x0A, 0xFD, 0xD1, 0x47, 0xFB, 
+0x12, 0x79, 0x1E, 0x90, 0x84, 0x0C, 0xEF, 0xF0, 0x90, 0x84, 0x08, 0x12, 0x42, 0x31, 0xD1, 0x47, 
+0xFF, 0x12, 0x78, 0xB9, 0x90, 0x84, 0x0D, 0xEF, 0xF0, 0x90, 0x82, 0x88, 0xE0, 0x24, 0xFE, 0x60, 
+0x15, 0x24, 0xFE, 0x60, 0x11, 0x14, 0x60, 0x07, 0x14, 0x60, 0x04, 0x24, 0x05, 0x70, 0x42, 0x12, 
+0x79, 0xD8, 0xF1, 0x42, 0x80, 0x0D, 0x12, 0x79, 0xD8, 0x90, 0x82, 0x88, 0xE0, 0x90, 0x83, 0xE6, 
+0xF0, 0x71, 0x9E, 0x90, 0x84, 0x0D, 0xE0, 0xFF, 0x90, 0x84, 0x08, 0x12, 0x42, 0x31, 0x90, 0x84, 
+0x0C, 0xE0, 0x7C, 0x00, 0x29, 0xF9, 0xEC, 0x3A, 0xFA, 0xC3, 0xE9, 0x9F, 0xF9, 0xEA, 0x94, 0x00, 
+0xFA, 0x75, 0x13, 0x01, 0x75, 0x14, 0x82, 0x75, 0x15, 0x7F, 0xA3, 0xE0, 0xF5, 0x16, 0x12, 0x2B, 
+0xED, 0x22, 0xF0, 0x90, 0x00, 0x05, 0x02, 0x1F, 0xBD, 0x90, 0x83, 0x9D, 0x12, 0x42, 0x3A, 0x12, 
+0x58, 0x9D, 0x90, 0x81, 0x08, 0xE0, 0xFF, 0x12, 0x59, 0x17, 0x90, 0x81, 0x08, 0xE0, 0x60, 0x11, 
+0x90, 0x83, 0x9D, 0x12, 0x42, 0x31, 0x71, 0x0A, 0x54, 0x0F, 0xFF, 0xB1, 0x88, 0xFD, 0x12, 0x77, 
+0xA9, 0x22, 0x90, 0x83, 0xFD, 0xED, 0xF0, 0x90, 0x83, 0xFA, 0x12, 0x42, 0x3A, 0xB1, 0xCA, 0x90, 
+0x84, 0x01, 0xF0, 0x90, 0x83, 0xFA, 0x12, 0x4F, 0xEA, 0x75, 0x16, 0x03, 0x7B, 0x01, 0x7A, 0x83, 
+0x79, 0xFE, 0x12, 0x2B, 0xED, 0x90, 0x83, 0xFD, 0xE0, 0x70, 0x2E, 0xFF, 0xF1, 0x9A, 0xE0, 0xB4, 
+0xFF, 0x06, 0xF1, 0x9A, 0xE4, 0xF0, 0x80, 0x07, 0xF1, 0x9A, 0xE0, 0x04, 0xF0, 0x80, 0x05, 0x0F, 
+0xEF, 0xB4, 0x03, 0xE8, 0x75, 0x13, 0x01, 0x75, 0x14, 0x83, 0x75, 0x15, 0xFE, 0x75, 0x16, 0x03, 
+0x90, 0x83, 0xFA, 0x12, 0x42, 0x31, 0x12, 0x2B, 0xED, 0x22, 0x74, 0xFE, 0x2F, 0xF5, 0x82, 0xE4, 
+0x34, 0x83, 0xF5, 0x83, 0x22, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 0x01, 0xFE, 0x22, 0x90, 0x83, 0x9A, 
+0x12, 0x42, 0x3A, 0x02, 0x1F, 0xA4, 0xF1, 0xA5, 0x90, 0x83, 0x77, 0x12, 0x79, 0xFC, 0x54, 0x04, 
+0xFF, 0xEE, 0x54, 0xFB, 0x4F, 0xF0, 0x12, 0x1F, 0xA4, 0xC3, 0x13, 0x30, 0xE0, 0x06, 0x71, 0x0A, 
+0x90, 0x83, 0x78, 0xF0, 0x22, 0xF9, 0xE4, 0x3A, 0xFA, 0x02, 0x1F, 0xA4, 0xF0, 0x90, 0x81, 0x06, 
+0xE0, 0x54, 0x0F, 0x22, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 0x22, 0x54, 0x20, 0xFE, 0xEF, 
+0x54, 0xDF, 0x4E, 0x22, 0x54, 0x80, 0xFE, 0xEF, 0x54, 0x7F, 0x4E, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 
+0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 
+0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xFC, 0xF0, 0x74, 
+0x57, 0xA3, 0xF0, 0x12, 0x72, 0x0F, 0xE5, 0x49, 0x30, 0xE1, 0x02, 0x11, 0x81, 0xE5, 0x49, 0x30, 
+0xE2, 0x02, 0x31, 0x70, 0xE5, 0x4A, 0x30, 0xE0, 0x03, 0x12, 0x6E, 0xC7, 0xE5, 0x4C, 0x30, 0xE1, 
+0x05, 0x7F, 0x04, 0x12, 0x6D, 0xBA, 0xE5, 0x4C, 0x30, 0xE4, 0x02, 0x11, 0x8A, 0xE5, 0x4C, 0x30, 
+0xE5, 0x02, 0xB1, 0xA6, 0xE5, 0x4C, 0x30, 0xE6, 0x02, 0xD1, 0x13, 0x74, 0xFC, 0x04, 0x90, 0x01, 
+0xC4, 0xF0, 0x74, 0x57, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 
+0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 
+0x32, 0x90, 0x81, 0x08, 0xE0, 0x60, 0x02, 0x91, 0xF0, 0x22, 0x12, 0x74, 0xF7, 0x7D, 0x02, 0x7F, 
+0x02, 0x74, 0x3D, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x30, 0x80, 0x34, 0x90, 0x81, 0x04, 
+0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x81, 0x11, 0xF0, 0xA3, 0xF0, 0x90, 0x81, 0x0C, 0xF0, 0x90, 
+0x81, 0x05, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 0x7D, 0x01, 0x7F, 0x02, 0x11, 0x91, 0x7D, 
+0x02, 0x7F, 0x02, 0x11, 0x91, 0x7D, 0x10, 0x7F, 0x03, 0x74, 0x45, 0xB1, 0x8B, 0xFE, 0xF6, 0x74, 
+0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 0x01, 0x36, 0x74, 
+0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x11, 0x91, 0x7D, 0x02, 0x7F, 0x03, 0x11, 
+0x91, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0x12, 0x76, 0x62, 0xF0, 0xE4, 0xFF, 0x12, 0x4C, 0x65, 
+0xBF, 0x01, 0x10, 0xB1, 0x57, 0x90, 0x81, 0x0B, 0xE0, 0x20, 0xE2, 0x0A, 0x7D, 0x01, 0x7F, 0x04, 
+0x02, 0x49, 0x0F, 0x12, 0x76, 0x49, 0x22, 0xEF, 0x70, 0x2F, 0x7D, 0x78, 0x7F, 0x02, 0x31, 0x4F, 
+0x7D, 0x02, 0x7F, 0x03, 0x31, 0x4F, 0x7D, 0xC8, 0x7F, 0x02, 0x11, 0xC9, 0x12, 0x76, 0x6C, 0x12, 
+0x4C, 0x5E, 0x70, 0x0A, 0x31, 0x59, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x80, 0x07, 0x7D, 0x01, 
+0x7F, 0x0C, 0x12, 0x49, 0x0F, 0x31, 0x5D, 0xE1, 0xDE, 0x80, 0x91, 0x7D, 0x02, 0x7F, 0x02, 0x74, 
+0x3D, 0xB1, 0x8B, 0xFE, 0xF6, 0x74, 0x30, 0x01, 0xD1, 0x31, 0x85, 0x31, 0x65, 0x90, 0x81, 0x04, 
+0xE0, 0x54, 0xF7, 0xF0, 0x22, 0xF1, 0xD6, 0x51, 0xCD, 0x7D, 0x0C, 0x7F, 0x01, 0x02, 0x4B, 0x2A, 
+0x90, 0x81, 0x08, 0xE0, 0x60, 0x0E, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x03, 0x02, 0x70, 0x4E, 
+0x31, 0x5D, 0xB1, 0x9C, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x01, 0x01, 0xE0, 
+0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 
+0x06, 0xB4, 0x74, 0x86, 0xF0, 0xB1, 0x93, 0x54, 0x7F, 0xFC, 0x90, 0x84, 0x1B, 0x12, 0x20, 0xCE, 
+0x90, 0x84, 0x1B, 0x71, 0x64, 0x7F, 0x7C, 0x51, 0xD5, 0x12, 0x20, 0xDA, 0xCC, 0xC0, 0x00, 0xC0, 
+0x51, 0xD3, 0x12, 0x20, 0xDA, 0x00, 0xC0, 0x00, 0x14, 0xB1, 0x84, 0x90, 0x84, 0x04, 0x12, 0x20, 
+0xDA, 0x00, 0x03, 0x3E, 0x60, 0xE4, 0xFD, 0xFF, 0x91, 0x78, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x8B, 
+0x1A, 0x8A, 0x1B, 0x89, 0x1C, 0x12, 0x53, 0x0A, 0xFF, 0xF5, 0x1E, 0x12, 0x1F, 0xA4, 0xFE, 0xC3, 
+0x13, 0x30, 0xE0, 0x07, 0x12, 0x55, 0x88, 0xF5, 0x1F, 0x80, 0x02, 0x8F, 0x1F, 0x85, 0x1E, 0x1D, 
+0xE5, 0x1D, 0xD3, 0x95, 0x1F, 0x50, 0x24, 0xAB, 0x1A, 0xAA, 0x1B, 0xA9, 0x1C, 0x12, 0x1F, 0xA4, 
+0x54, 0x01, 0xFD, 0xAF, 0x1D, 0xF1, 0x46, 0xAF, 0x1D, 0x12, 0x4C, 0x65, 0xEF, 0xAF, 0x1D, 0x70, 
+0x04, 0xF1, 0xC6, 0x80, 0x02, 0xF1, 0xC5, 0x05, 0x1D, 0x80, 0xD5, 0xE5, 0x1E, 0x70, 0x0F, 0xFF, 
+0x12, 0x4C, 0x65, 0xEF, 0x70, 0x08, 0x31, 0x59, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x22, 0xEF, 
+0x60, 0x41, 0x90, 0x04, 0xEC, 0xE0, 0x54, 0xDD, 0xF0, 0x90, 0x83, 0x67, 0xE0, 0xFF, 0x60, 0x03, 
+0x12, 0x78, 0x63, 0x90, 0x01, 0xC7, 0xE4, 0x12, 0x66, 0x3B, 0x12, 0x7A, 0x04, 0x90, 0x06, 0x09, 
+0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x35, 0x71, 0x03, 0x90, 0x02, 0x86, 0xE0, 0x44, 0x04, 0xF0, 0xD1, 
+0x98, 0xF1, 0xC7, 0x51, 0xCB, 0x12, 0x79, 0x64, 0x90, 0x01, 0x34, 0x74, 0x08, 0xF0, 0xFD, 0xE4, 
+0xFF, 0x01, 0x91, 0x90, 0x04, 0xEC, 0xE0, 0x44, 0x22, 0xF0, 0x7D, 0x08, 0xE4, 0xFF, 0x31, 0x4F, 
+0x90, 0x06, 0x90, 0xE0, 0x54, 0xF0, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x54, 0xFB, 0xF0, 0x51, 0xDE, 
+0xF1, 0xC8, 0x7E, 0x00, 0x7F, 0x20, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xB3, 0x12, 0x44, 
+0x13, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x20, 0xF0, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 
+0xFD, 0x7F, 0x8F, 0x12, 0x32, 0x1E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x31, 0x85, 0xE4, 0xFD, 0xFF, 
+0x02, 0x4B, 0x1B, 0x7F, 0x8C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x85, 0xBB, 0x22, 0x51, 0xB8, 
+0xF1, 0xA5, 0x90, 0x01, 0x3F, 0x74, 0x04, 0xF0, 0x90, 0x80, 0x06, 0xE0, 0xFF, 0xB4, 0x01, 0x07, 
+0x90, 0xFD, 0x00, 0xE0, 0x54, 0xEF, 0xF0, 0xEF, 0xB4, 0x01, 0x07, 0x90, 0xFE, 0x10, 0xE0, 0x54, 
+0xFB, 0xF0, 0x22, 0x7F, 0xFF, 0x12, 0x4B, 0x1B, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 
+0x6F, 0x83, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xDA, 0xCC, 0xF0, 0x00, 0xC0, 0x51, 0xD3, 0x12, 0x20, 
+0xDA, 0x00, 0x00, 0x00, 0x14, 0xB1, 0x84, 0x90, 0x84, 0x04, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 
+0x00, 0xE4, 0xFD, 0xFF, 0x91, 0x78, 0xB1, 0x93, 0x44, 0x80, 0xFC, 0x90, 0x84, 0x1F, 0x12, 0x20, 
+0xCE, 0x90, 0x84, 0x1F, 0x71, 0x64, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2E, 0xA2, 0x90, 0x01, 0x00, 
+0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x12, 0x42, 0x19, 0x90, 0x85, 0xBB, 0x02, 0x20, 0xCE, 0x90, 0x83, 0xD3, 
+0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x90, 0x83, 
+0xE1, 0xF0, 0x7F, 0x24, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0x90, 0x83, 0xD9, 0x12, 0x20, 0xCE, 0x90, 
+0x83, 0xD3, 0xE0, 0xFB, 0x70, 0x04, 0x91, 0x54, 0x80, 0x07, 0xEB, 0x91, 0x5A, 0xFF, 0x12, 0x2D, 
+0x5C, 0x90, 0x83, 0xDD, 0x12, 0x20, 0xCE, 0x90, 0x83, 0xD4, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 
+0x78, 0x17, 0xF1, 0x0B, 0x90, 0x83, 0xDD, 0x12, 0x42, 0x19, 0xED, 0x54, 0x7F, 0xFD, 0xEC, 0x54, 
+0x80, 0xFC, 0x12, 0x42, 0x0C, 0xEC, 0x44, 0x80, 0xFC, 0x90, 0x83, 0xDD, 0x12, 0x20, 0xCE, 0x91, 
+0x54, 0xEC, 0x54, 0x7F, 0xFC, 0x71, 0x67, 0x91, 0x6C, 0x91, 0x5A, 0xFF, 0xC0, 0x06, 0xC0, 0x07, 
+0x90, 0x83, 0xDD, 0x71, 0x64, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x2E, 0xA2, 0x91, 0x54, 0xEC, 0x44, 
+0x80, 0xFC, 0x71, 0x67, 0x91, 0x6C, 0x70, 0x04, 0x7F, 0x20, 0x80, 0x09, 0x90, 0x83, 0xD3, 0xE0, 
 0xB4, 0x01, 0x16, 0x7F, 0x28, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0x78, 0x08, 0x12, 0x20, 0xA8, 0xEF, 
-0x54, 0x01, 0xFF, 0xE4, 0x90, 0x83, 0xA8, 0xEF, 0xF0, 0x90, 0x83, 0xA8, 0xE0, 0x90, 0x83, 0x9A, 
+0x54, 0x01, 0xFF, 0xE4, 0x90, 0x83, 0xE1, 0xEF, 0xF0, 0x90, 0x83, 0xE1, 0xE0, 0x90, 0x83, 0xD3, 
 0x60, 0x0E, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x66, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x80, 0x0C, 
-0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x64, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 
-0xA3, 0xE0, 0xFF, 0x12, 0x2D, 0x5C, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x90, 0x83, 0x9C, 0x12, 
-0x20, 0xCE, 0x90, 0x83, 0x9C, 0x02, 0x42, 0x19, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x71, 
-0x49, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x83, 0xB7, 0xEF, 0xF0, 0xAB, 0x05, 0x90, 0x83, 0xBD, 
-0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x03, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x14, 0x12, 
-0x20, 0xBB, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x83, 0xB9, 0x12, 0x42, 0x19, 
-0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x12, 0x42, 0x0C, 0xEC, 0x54, 0x0F, 0xFC, 0x90, 0x83, 0xBD, 
-0x12, 0x20, 0xCE, 0x90, 0x83, 0xB7, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x60, 0xF5, 0x82, 0xE4, 
-0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x83, 0xBD, 
-0x12, 0x42, 0x19, 0x90, 0x85, 0xBB, 0x12, 0x20, 0xCE, 0xD0, 0x07, 0xD0, 0x06, 0x02, 0x2E, 0xA2, 
-0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0x83, 0xCB, 0x12, 0x42, 
-0x19, 0x90, 0x83, 0xB9, 0x12, 0x20, 0xCE, 0xD0, 0x05, 0xD0, 0x07, 0x91, 0x96, 0xD0, 0xD0, 0x92, 
-0xAF, 0x22, 0x90, 0x83, 0xFD, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x46, 0x3A, 0x90, 0x80, 0x01, 0xE0, 
-0xFF, 0x90, 0x83, 0xFD, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x80, 0x01, 0xF0, 0x22, 0x90, 0x83, 0xFE, 
-0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x46, 0x3A, 0x90, 0x80, 0x02, 0xE0, 0xFF, 0x90, 0x83, 0xFE, 0xE0, 
-0xFE, 0xEF, 0x4E, 0x90, 0x80, 0x02, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xF5, 0x1A, 0x12, 0x1F, 
-0xA4, 0x25, 0x1A, 0x90, 0x80, 0x07, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x25, 0x1A, 0x90, 
-0x80, 0x08, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x25, 0x1A, 0x90, 0x80, 0x09, 0xF0, 0x90, 
-0x00, 0x03, 0x12, 0x1F, 0xBD, 0x25, 0x1A, 0x90, 0x80, 0x0A, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 
-0xBD, 0x25, 0x1A, 0x90, 0x80, 0x0B, 0xF0, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0x25, 0x1A, 0x90, 
-0x80, 0x0C, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8B, 0x1A, 0x8A, 0x1B, 0x89, 
-0x1C, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 0x39, 0xF0, 0xBF, 0x01, 0x10, 0x90, 0x00, 0x01, 0x12, 
-0x1F, 0xBD, 0x64, 0x01, 0x60, 0x1C, 0x7D, 0x13, 0x7F, 0x6F, 0x80, 0x13, 0xAB, 0x1A, 0xAA, 0x1B, 
-0xA9, 0x1C, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x64, 0x01, 0x60, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 
-0x4A, 0xED, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0xFF, 0x30, 0xE0, 
-0x26, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x76, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x81, 
-0x77, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0x4F, 0xF0, 0x90, 0x00, 0x03, 0x12, 
-0x1F, 0xBD, 0x90, 0x81, 0x79, 0xF0, 0x22, 0x90, 0x81, 0x76, 0x74, 0x05, 0xF0, 0xA3, 0xF0, 0xA3, 
-0xE0, 0x54, 0x01, 0x44, 0x28, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x22, 0x90, 0x01, 0xCC, 0xE0, 0x54, 
-0x0F, 0x90, 0x83, 0xF3, 0xF0, 0x90, 0x83, 0xF3, 0xE0, 0xFD, 0x70, 0x02, 0xE1, 0x7A, 0x90, 0x80, 
-0x5D, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x80, 
-0x5E, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x08, 0x90, 0x01, 
-0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x83, 0xF1, 0xE0, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 
-0x07, 0x08, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 
-0xE1, 0x57, 0xE4, 0x90, 0x83, 0xF4, 0xF0, 0x90, 0x83, 0xF4, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 
-0x73, 0x90, 0x83, 0xF1, 0xE0, 0x75, 0xF0, 0x04, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 
-0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 
-0x90, 0x80, 0x5E, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x80, 0x0D, 0x12, 0x42, 0x25, 0xE5, 0x82, 0x29, 
-0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x83, 0xF1, 0xE0, 0x75, 0xF0, 0x04, 
-0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xF0, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 
-0x83, 0xE0, 0xFF, 0x90, 0x80, 0x5E, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x80, 0x11, 0x12, 0x42, 0x25, 
-0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x83, 0xF4, 0xE0, 
-0x04, 0xF0, 0x80, 0x83, 0x90, 0x83, 0xF3, 0xE0, 0xFF, 0x90, 0x83, 0xF1, 0xE0, 0xFE, 0x74, 0x01, 
-0xA8, 0x06, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0x83, 0xF3, 0xF0, 0x90, 
-0x83, 0xF1, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 
-0x01, 0xCC, 0xF0, 0x90, 0x83, 0xF1, 0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0x80, 0x5E, 
-0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x70, 0x02, 0xC1, 0x35, 
-0xE4, 0x90, 0x80, 0x5E, 0xF0, 0xC1, 0x35, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x83, 
-0xF1, 0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0xF0, 0x90, 0x83, 0xF1, 0xE0, 0x75, 0xF0, 0x04, 0x90, 
-0x01, 0xD0, 0x12, 0x42, 0x25, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
-0xC0, 0xD0, 0x90, 0x80, 0xF5, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 
-0x14, 0xFF, 0x90, 0x80, 0xF6, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 
-0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x35, 0xC0, 0x01, 0x90, 0x80, 0xF6, 
-0xE0, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x5F, 0xF9, 0x74, 0x80, 0x35, 0xF0, 0xA8, 0x01, 0xFC, 0x7D, 
-0x01, 0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x41, 0xD0, 0x90, 0x80, 0xF6, 0xE0, 0x04, 0xF0, 
-0xE0, 0x7F, 0x00, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0xF6, 0xF0, 
-0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x00, 0x54, 0xE0, 0x55, 0x35, 0xF5, 0x39, 0xA3, 0xE0, 0x55, 
-0x36, 0xF5, 0x3A, 0xA3, 0xE0, 0x55, 0x37, 0xF5, 0x3B, 0xA3, 0xE0, 0x55, 0x38, 0xF5, 0x3C, 0xAD, 
-0x39, 0x7F, 0x54, 0x12, 0x32, 0x1E, 0xAD, 0x3A, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0xAD, 0x3B, 0x7F, 
-0x56, 0x12, 0x32, 0x1E, 0xAD, 0x3C, 0x7F, 0x57, 0x12, 0x32, 0x1E, 0x53, 0x91, 0xEF, 0x22, 0x90, 
-0x01, 0x34, 0xE0, 0x55, 0x3D, 0xF5, 0x41, 0xA3, 0xE0, 0x55, 0x3E, 0xF5, 0x42, 0xA3, 0xE0, 0x55, 
-0x3F, 0xF5, 0x43, 0xA3, 0xE0, 0x55, 0x40, 0xF5, 0x44, 0x90, 0x01, 0x34, 0xE5, 0x41, 0xF0, 0xA3, 
-0xE5, 0x42, 0xF0, 0xA3, 0xE5, 0x43, 0xF0, 0xA3, 0xE5, 0x44, 0xF0, 0x22, 0x90, 0x01, 0x3C, 0xE0, 
-0x55, 0x45, 0xF5, 0x49, 0xA3, 0xE0, 0x55, 0x46, 0xF5, 0x4A, 0xA3, 0xE0, 0x55, 0x47, 0xF5, 0x4B, 
-0xA3, 0xE0, 0x55, 0x48, 0xF5, 0x4C, 0x90, 0x01, 0x3C, 0xE5, 0x49, 0xF0, 0xA3, 0xE5, 0x4A, 0xF0, 
-0xA3, 0xE5, 0x4B, 0xF0, 0xA3, 0xE5, 0x4C, 0xF0, 0x53, 0x91, 0xDF, 0x22, 0x90, 0x81, 0x3E, 0xE0, 
-0x60, 0x45, 0x90, 0x81, 0x3B, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x12, 0x90, 
-0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x0B, 0x11, 0xD1, 0x90, 0x81, 0x44, 0xE0, 0x14, 0x90, 0x05, 0x73, 
-0xF0, 0x90, 0x83, 0xF5, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x41, 0xF6, 0xC3, 0x90, 0x83, 0xF6, 0xE0, 
-0x94, 0x80, 0x90, 0x83, 0xF5, 0xE0, 0x64, 0x80, 0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 
-0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0xF1, 0x5E, 0x31, 0xE6, 0xE4, 0x90, 0x83, 0x43, 0xF0, 
-0x22, 0x7D, 0x02, 0x7F, 0x02, 0x11, 0xDB, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x3D, 0x2F, 0xF8, 0xE6, 
-0xFE, 0xED, 0xF4, 0x5E, 0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 
-0xEE, 0xF0, 0x22, 0x90, 0x83, 0x4A, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x41, 0xE0, 0x64, 0x02, 0x60, 
-0x28, 0x31, 0x2A, 0x90, 0x81, 0x3B, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x14, 0x90, 
-0x81, 0x44, 0xE0, 0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x0A, 0x31, 0xC2, 0x11, 0xD1, 0x90, 0x81, 0x45, 
-0xE0, 0x14, 0xF0, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x80, 0xF9, 0xE0, 0x64, 0x01, 
-0x60, 0x02, 0x21, 0xC1, 0x90, 0x81, 0x3E, 0xE0, 0x70, 0x02, 0x21, 0xC1, 0x90, 0x81, 0x3C, 0xE0, 
-0xC4, 0x54, 0x0F, 0x64, 0x01, 0x70, 0x26, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x81, 0x45, 0xF0, 0x90, 
-0x06, 0xAA, 0xE0, 0x04, 0x90, 0x81, 0x44, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x81, 0x44, 
-0xE0, 0xFE, 0xFF, 0x80, 0x03, 0xEF, 0x04, 0xFF, 0x90, 0x81, 0x45, 0xEF, 0xF0, 0x90, 0x81, 0x3B, 
-0xE0, 0x44, 0x04, 0xF0, 0xE4, 0x90, 0x81, 0x47, 0xF0, 0x90, 0x81, 0x49, 0xA3, 0xE0, 0x90, 0x05, 
-0x58, 0xF0, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x42, 
-0xE0, 0x54, 0xFD, 0xF0, 0x54, 0xEF, 0xF0, 0x90, 0x81, 0x3C, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x24, 
-0xFD, 0x50, 0x02, 0x80, 0x02, 0x51, 0x4A, 0x90, 0x81, 0x3B, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 
-0x30, 0xE0, 0x0E, 0x90, 0x81, 0x44, 0xE0, 0xFF, 0xA3, 0xE0, 0xB5, 0x07, 0x04, 0x31, 0xC2, 0x11, 
-0xD7, 0x22, 0xEF, 0x14, 0x90, 0x05, 0x73, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 
-0x03, 0x74, 0x45, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
-0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 0x83, 0x40, 0xE0, 0x30, 0xE0, 0x37, 0x90, 0x80, 0xF9, 
-0xE0, 0x64, 0x01, 0x70, 0x2F, 0x90, 0x84, 0x04, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x0A, 0x0B, 0x90, 
-0x83, 0x42, 0xE0, 0x04, 0xF0, 0xE4, 0x90, 0x84, 0x04, 0xF0, 0x90, 0x83, 0x42, 0xE0, 0xFF, 0x90, 
-0x83, 0x41, 0xE0, 0xD3, 0x9F, 0x50, 0x0D, 0x90, 0x83, 0x43, 0xE0, 0x70, 0x07, 0xE4, 0x90, 0x83, 
-0x42, 0xF0, 0x51, 0x25, 0x22, 0x90, 0x83, 0x40, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 
-0x16, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x00, 0x90, 0x83, 0x8B, 0x12, 0x42, 0x3A, 0xE4, 0x90, 0x83, 
-0x8E, 0xF0, 0xA3, 0x04, 0xF0, 0x61, 0x64, 0x02, 0x4C, 0x25, 0xE4, 0xF5, 0x19, 0x90, 0x06, 0xA9, 
-0xE0, 0xF5, 0x19, 0x54, 0xC0, 0x70, 0x0D, 0x90, 0x81, 0x42, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 
-0xF0, 0x02, 0x51, 0x9D, 0xE5, 0x19, 0x30, 0xE6, 0x22, 0x90, 0x81, 0x3E, 0xE0, 0x64, 0x01, 0x70, 
-0x21, 0x90, 0x81, 0x42, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x81, 0x3C, 0xE0, 0x54, 0x0F, 0x64, 0x02, 
-0x60, 0x04, 0x51, 0xAD, 0x80, 0x0C, 0x12, 0x4C, 0xE4, 0x80, 0x07, 0x90, 0x81, 0x42, 0xE0, 0x54, 
-0xFE, 0xF0, 0xE5, 0x19, 0x90, 0x81, 0x42, 0x30, 0xE7, 0x0E, 0xE0, 0x44, 0x02, 0x12, 0x57, 0xEF, 
-0x90, 0x81, 0x3A, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x04, 0x1D, 
-0xE0, 0x70, 0x19, 0x90, 0x80, 0x08, 0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 0x51, 0xCD, 0x90, 0x83, 
-0x52, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 
-0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0xDF, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x83, 0xDE, 0xEF, 
-0xF0, 0xE4, 0xFD, 0xFC, 0x12, 0x5F, 0x67, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0x83, 0xDE, 0xE0, 0x90, 
-0x04, 0x25, 0xF0, 0x90, 0x83, 0xDF, 0xE0, 0x60, 0x0E, 0x74, 0x0F, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
-0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x08, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
-0xFC, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x09, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
-0x54, 0xF0, 0xF0, 0xAF, 0x05, 0x74, 0x16, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
-0x54, 0x01, 0xFE, 0x90, 0x83, 0xE0, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 
-0xFE, 0x74, 0x16, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEE, 0xF0, 0x74, 0x21, 0x2F, 
-0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0x88, 0x12, 0x42, 
-0x3A, 0x78, 0x94, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xCE, 0x7E, 0x00, 0x7F, 
-0x06, 0x12, 0x41, 0xD0, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x83, 0x93, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 
-0x60, 0x0A, 0x7D, 0x33, 0x12, 0x4D, 0x6E, 0xBF, 0x01, 0x15, 0x80, 0x00, 0x90, 0x83, 0x31, 0xE0, 
-0xFF, 0x7B, 0x18, 0x7D, 0x01, 0x51, 0xCD, 0x90, 0x83, 0x90, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
-0x83, 0x90, 0x12, 0x56, 0xFD, 0x90, 0x83, 0x92, 0xEF, 0xF0, 0x90, 0x83, 0x90, 0xA3, 0xE0, 0x24, 
-0x20, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x90, 0x83, 0x8E, 0xE0, 0xFD, 0x91, 0xE8, 0x90, 
-0x83, 0x8F, 0xE0, 0x60, 0x02, 0x81, 0x5E, 0xA3, 0xA3, 0xE0, 0x24, 0x30, 0xF9, 0xE4, 0x34, 0xFC, 
-0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 0x8B, 0x12, 0x42, 0x31, 0x8B, 
-0x13, 0x8A, 0x14, 0x89, 0x15, 0x75, 0x16, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x2B, 
-0xED, 0x90, 0x83, 0x90, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x24, 0x3A, 0xF9, 0xE4, 0x34, 0xFC, 
-0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 0x8B, 0x12, 0x42, 0x31, 0x8B, 
-0x13, 0x8A, 0x14, 0x89, 0x15, 0x75, 0x16, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x2B, 
-0xED, 0x90, 0x83, 0x90, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x24, 0x40, 0xF9, 0xE4, 0x34, 0xFC, 
-0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x83, 0x88, 0x12, 0x42, 0x31, 0x8B, 
-0x13, 0x8A, 0x14, 0x89, 0x15, 0x75, 0x16, 0x04, 0xD0, 0x01, 0xD0, 0x02, 0x80, 0x69, 0x90, 0x83, 
-0x8F, 0xE0, 0x64, 0x01, 0x70, 0x66, 0xA3, 0xA3, 0xE0, 0x24, 0x30, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 
-0x7B, 0x01, 0xC0, 0x03, 0x8B, 0x13, 0x75, 0x14, 0x81, 0x75, 0x15, 0x9C, 0x75, 0x16, 0x06, 0xD0, 
-0x03, 0x12, 0x2B, 0xED, 0x90, 0x83, 0x90, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x2F, 0x24, 0x3A, 0xF9, 
-0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0x8B, 0x13, 0x75, 0x14, 0x81, 0x75, 0x15, 0xA6, 
-0x75, 0x16, 0x06, 0xD0, 0x03, 0x12, 0x2B, 0xED, 0x90, 0x83, 0x90, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 
-0x2F, 0x24, 0x40, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0x8B, 0x13, 0x75, 0x14, 
-0x81, 0x75, 0x15, 0xAC, 0x75, 0x16, 0x04, 0xD0, 0x03, 0x12, 0x2B, 0xED, 0x90, 0x06, 0x30, 0xE0, 
-0x44, 0x10, 0xF0, 0x90, 0x83, 0x93, 0xE0, 0xFF, 0x7D, 0x34, 0x12, 0x4A, 0xED, 0x90, 0x04, 0x1F, 
-0x74, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x83, 0xD2, 0xED, 0xF0, 0x90, 0x83, 0xCF, 
-0x12, 0x42, 0x3A, 0xE4, 0x90, 0x83, 0xD3, 0xF0, 0xA3, 0xF0, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x00, 
-0x01, 0x12, 0x1F, 0xBD, 0xFD, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0xFB, 0x12, 0x57, 0x23, 0x90, 
-0x83, 0xD3, 0xEF, 0xF0, 0x90, 0x83, 0xCF, 0x12, 0x42, 0x31, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 
-0xFF, 0xD1, 0xA5, 0x90, 0x83, 0xD4, 0xEF, 0xF0, 0x90, 0x82, 0x51, 0xE0, 0x24, 0xFE, 0x60, 0x1D, 
-0x24, 0xFE, 0x60, 0x19, 0x14, 0x60, 0x07, 0x14, 0x60, 0x04, 0x24, 0x05, 0x70, 0x53, 0x7B, 0x01, 
-0x7A, 0x82, 0x79, 0x48, 0x90, 0x83, 0xD2, 0xE0, 0xFD, 0xD1, 0xE4, 0x80, 0x16, 0x7B, 0x01, 0x7A, 
-0x82, 0x79, 0x48, 0x90, 0x83, 0xD2, 0xE0, 0xFD, 0x90, 0x82, 0x51, 0xE0, 0x90, 0x83, 0xAD, 0xF0, 
-0x12, 0x7C, 0x06, 0x90, 0x83, 0xD4, 0xE0, 0xFF, 0x90, 0x83, 0xCF, 0x12, 0x42, 0x31, 0x90, 0x83, 
-0xD3, 0xE0, 0x7C, 0x00, 0x29, 0xF9, 0xEC, 0x3A, 0xFA, 0xC3, 0xE9, 0x9F, 0xF9, 0xEA, 0x94, 0x00, 
-0xFA, 0x75, 0x13, 0x01, 0x75, 0x14, 0x82, 0x75, 0x15, 0x48, 0xA3, 0xE0, 0xF5, 0x16, 0x12, 0x2B, 
-0xED, 0x22, 0x90, 0x80, 0x09, 0xE0, 0xFF, 0x90, 0x83, 0xD6, 0xE0, 0xFB, 0x7D, 0x01, 0x51, 0xCD, 
-0x90, 0x83, 0xD7, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x83, 0xD5, 0xE0, 0xFF, 0xD1, 
-0x3D, 0x90, 0x83, 0xD7, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x04, 0x80, 0xE0, 0x54, 0x0F, 0xFD, 
-0xAC, 0x07, 0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x01, 0xF0, 
-0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xFB, 0xF0, 0xAC, 0x07, 
-0x74, 0x16, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x15, 
-0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 
-0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x0F, 0xF0, 0x90, 0x04, 0x53, 0xE4, 
-0xF0, 0x90, 0x04, 0x52, 0xF0, 0x90, 0x04, 0x51, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0x50, 0x74, 0xFD, 
-0xF0, 0x74, 0x14, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0x4D, 0xFD, 
-0x74, 0x14, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xED, 0xF0, 0x22, 0x74, 0x1F, 0x2D, 
-0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x1D, 0x74, 0x21, 
-0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x10, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 
-0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0x22, 0x74, 0x21, 0x2D, 0xF5, 0x82, 
-0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xEF, 0xF0, 0x74, 0x1F, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 
-0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0x90, 0x80, 0xF9, 0xE0, 0xB4, 0x01, 0x15, 0x90, 
-0x81, 0x3E, 0xE0, 0x60, 0x0F, 0x90, 0x81, 0x3C, 0xE0, 0x54, 0x0F, 0x64, 0x02, 0x60, 0x02, 0x41, 
-0xAD, 0x12, 0x4C, 0xE4, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xEF, 0x20, 0xE0, 0x05, 
-0x90, 0x83, 0x2E, 0x80, 0x03, 0x90, 0x83, 0x2F, 0xE0, 0x90, 0x82, 0x51, 0xF0, 0x90, 0x82, 0x51, 
-0xE0, 0x14, 0x60, 0x13, 0x14, 0x60, 0x14, 0x24, 0xFE, 0x60, 0x10, 0x14, 0x60, 0x09, 0x14, 0x60, 
-0x06, 0x24, 0x06, 0xE4, 0xFE, 0x80, 0x06, 0x7E, 0x04, 0x80, 0x02, 0x7E, 0x08, 0xAF, 0x06, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0x90, 0x83, 0xC4, 0xED, 0xF0, 0x90, 0x83, 0xC1, 0x12, 0x42, 0x3A, 0x90, 
-0x00, 0x03, 0x12, 0x1F, 0xBD, 0x90, 0x83, 0xC8, 0xF0, 0x90, 0x83, 0xC1, 0x12, 0x42, 0x31, 0x8B, 
-0x13, 0x8A, 0x14, 0x89, 0x15, 0x75, 0x16, 0x03, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0xC5, 0x12, 0x2B, 
-0xED, 0x90, 0x83, 0xC4, 0xE0, 0x70, 0x46, 0xFF, 0x74, 0xC5, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x83, 
-0xF5, 0x83, 0xE0, 0xB4, 0xFF, 0x0E, 0x74, 0xC5, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 
-0xE4, 0xF0, 0x80, 0x0F, 0x74, 0xC5, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0xE0, 0x04, 
-0xF0, 0x80, 0x05, 0x0F, 0xEF, 0xB4, 0x03, 0xD0, 0x75, 0x13, 0x01, 0x75, 0x14, 0x83, 0x75, 0x15, 
-0xC5, 0x75, 0x16, 0x03, 0x90, 0x83, 0xC1, 0x12, 0x42, 0x31, 0x12, 0x2B, 0xED, 0x22, 0x90, 0x83, 
-0x44, 0xE0, 0x30, 0xE0, 0x72, 0x90, 0x83, 0x48, 0xE0, 0x04, 0xF0, 0x90, 0x83, 0x4B, 0xE0, 0x64, 
-0x01, 0x70, 0x27, 0x90, 0x83, 0x44, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x1C, 0x90, 0x83, 
-0x4A, 0xE0, 0x70, 0x16, 0x90, 0x83, 0x47, 0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x40, 0x0B, 0x12, 
-0x51, 0xA7, 0x90, 0x83, 0x44, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0x83, 0x48, 0xE0, 0xFF, 0x90, 
-0x83, 0x45, 0xE0, 0xD3, 0x9F, 0x50, 0x30, 0x90, 0x06, 0x92, 0xE0, 0x20, 0xE2, 0x1A, 0x90, 0x83, 
-0x4A, 0xE0, 0x70, 0x14, 0x7D, 0x08, 0xFF, 0x12, 0x4C, 0x29, 0x90, 0x83, 0x49, 0xE0, 0x04, 0xF0, 
-0x90, 0x83, 0x43, 0xE0, 0x04, 0xF0, 0x80, 0x06, 0x90, 0x06, 0x92, 0x74, 0x04, 0xF0, 0xE4, 0x90, 
-0x83, 0x48, 0xF0, 0x90, 0x83, 0x4A, 0xF0, 0x22, 0x90, 0x80, 0xF9, 0xE0, 0x64, 0x01, 0x70, 0x13, 
-0x90, 0x81, 0x3E, 0xE0, 0x60, 0x0D, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 
-0x12, 0x57, 0xEF, 0x22, 0x90, 0x80, 0xF9, 0xE0, 0x64, 0x01, 0x70, 0x26, 0x90, 0x81, 0x3E, 0xE0, 
-0x60, 0x20, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x3A, 
-0xE0, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x42, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0x07, 0x70, 0x03, 0x12, 
-0x51, 0x9D, 0x22, 0x90, 0x80, 0xF9, 0xE0, 0xB4, 0x01, 0x14, 0x90, 0x81, 0x3E, 0xE0, 0x60, 0x0E, 
-0x90, 0x81, 0x42, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0x07, 0x70, 0x03, 0x12, 0x51, 0x9D, 0x22, 0x11, 
-0xB2, 0x90, 0x83, 0x54, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 0x01, 0xE4, 0x80, 0x02, 0xE4, 0xFD, 
-0xFF, 0x12, 0x4B, 0x33, 0x90, 0x83, 0x54, 0xE0, 0x30, 0xE6, 0x11, 0x90, 0x01, 0x2F, 0xE0, 0x30, 
-0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 0x90, 0x81, 0x3A, 0xE0, 
-0x30, 0xE0, 0x25, 0x90, 0x81, 0x75, 0xE0, 0x24, 0x07, 0xFF, 0x90, 0x81, 0x50, 0xE0, 0xFE, 0xC3, 
-0xEF, 0x9E, 0xFF, 0x90, 0x81, 0x53, 0xF0, 0x90, 0x81, 0x49, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
-0x04, 0xEC, 0xE0, 0x54, 0xDD, 0xF0, 0x80, 0x10, 0x90, 0x81, 0x49, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 
-0xF0, 0x90, 0x04, 0xEC, 0xE0, 0x44, 0x22, 0xF0, 0x90, 0x81, 0x49, 0xA3, 0xE0, 0x90, 0x05, 0x58, 
-0xF0, 0x22, 0xE4, 0x90, 0x83, 0x55, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0x90, 
-0x83, 0x55, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 0x90, 0x83, 0x55, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 
-0x22, 0xC3, 0x90, 0x83, 0x57, 0xE0, 0x94, 0x64, 0x90, 0x83, 0x56, 0xE0, 0x94, 0x00, 0x40, 0x0D, 
-0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x83, 0x55, 0xE0, 0xFF, 0x22, 0x90, 0x83, 0x56, 
-0xE4, 0x75, 0xF0, 0x01, 0x12, 0x41, 0xF6, 0x80, 0xC2, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
-0x90, 0x04, 0x1D, 0xE0, 0x60, 0x1A, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x90, 0x60, 0x07, 0x90, 0x01, 
-0xC0, 0xE0, 0x44, 0x08, 0xF0, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE1, 0xE4, 0x7F, 0x00, 0x80, 0x02, 
-0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xC3, 0xEE, 0x94, 0x01, 0x40, 0x0A, 0x0D, 0xED, 0x13, 
-0x90, 0xFD, 0x10, 0xF0, 0xE4, 0x2F, 0xFF, 0x22, 0xC3, 0xEE, 0x94, 0x01, 0x40, 0x1E, 0x90, 0xFD, 
-0x11, 0xE0, 0xB5, 0x05, 0x14, 0x90, 0x01, 0x17, 0xE0, 0xB5, 0x05, 0x07, 0x90, 0xFD, 0x11, 0xE4, 
-0xF0, 0x80, 0x06, 0xED, 0x04, 0x90, 0xFD, 0x11, 0xF0, 0xE4, 0x2F, 0xFF, 0x22, 0x74, 0x45, 0x2F, 
-0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 
-0xF5, 0x83, 0xEE, 0xF0, 0x22, 0xE4, 0x90, 0x81, 0x3E, 0xF0, 0xA3, 0xF0, 0x90, 0x81, 0x3C, 0xE0, 
-0x54, 0x0F, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x3C, 0xE0, 0x54, 0xF0, 0xF0, 0x90, 0x81, 
-0x3A, 0xE0, 0x54, 0xFD, 0xF0, 0x54, 0xEF, 0xF0, 0x54, 0xF7, 0xF0, 0x90, 0x81, 0x44, 0x74, 0x01, 
-0xF0, 0xA3, 0xF0, 0x90, 0x81, 0x3A, 0xE0, 0x54, 0xFB, 0xF0, 0xA3, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 
-0x90, 0x81, 0x47, 0xF0, 0x90, 0x81, 0x46, 0x74, 0x08, 0xF0, 0x90, 0x81, 0x49, 0xE4, 0xF0, 0xA3, 
-0x74, 0x02, 0xF0, 0xE4, 0x90, 0x81, 0x42, 0xF0, 0x90, 0x81, 0x3A, 0xE0, 0x54, 0xDF, 0xF0, 0xE4, 
-0xFD, 0xFF, 0x12, 0x4B, 0x33, 0x7D, 0x0C, 0x7F, 0x02, 0x12, 0x4B, 0x33, 0x12, 0x4B, 0x2F, 0x90, 
-0x81, 0x3A, 0xE0, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0xA3, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 
-0xF0, 0x54, 0xF7, 0xF0, 0x90, 0x81, 0x4B, 0x12, 0x20, 0xDA, 0x54, 0x33, 0x77, 0x70, 0xE4, 0x90, 
-0x81, 0x75, 0xF0, 0x90, 0x81, 0x4F, 0xF0, 0x90, 0x80, 0x06, 0xE0, 0xB4, 0x01, 0x08, 0x90, 0x81, 
-0x48, 0x74, 0x99, 0xF0, 0x80, 0x12, 0x90, 0x80, 0x06, 0xE0, 0x90, 0x81, 0x48, 0xB4, 0x03, 0x05, 
-0x74, 0x90, 0xF0, 0x80, 0x03, 0x74, 0x40, 0xF0, 0x90, 0x81, 0x76, 0x74, 0x05, 0xF0, 0xA3, 0xF0, 
-0xA3, 0xE0, 0x54, 0x01, 0x44, 0x28, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0xE4, 0x90, 0x81, 0x50, 0xF0, 
-0x90, 0x81, 0x75, 0xE0, 0x24, 0x07, 0x90, 0x81, 0x53, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0xE4, 0xA3, 
-0xF0, 0x90, 0x81, 0x7A, 0xF0, 0xA3, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xFD, 0xF0, 0x54, 0xFB, 0xF0, 
-0x54, 0xF7, 0xF0, 0x54, 0xEF, 0xF0, 0x54, 0xDF, 0xF0, 0x54, 0xBF, 0xF0, 0x90, 0x06, 0x04, 0xE0, 
-0x54, 0x7F, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0xE4, 0xFD, 0xFF, 0x12, 0x4A, 0xED, 
-0xE4, 0x90, 0x81, 0x7C, 0xF0, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 
-0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0x51, 
-0x86, 0xEF, 0x64, 0x01, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x80, 0x67, 0x90, 0x81, 
-0x42, 0xE0, 0xFF, 0x54, 0x03, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x56, 0x90, 
-0x81, 0x40, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 
-0x44, 0xEF, 0x30, 0xE2, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x80, 0x38, 0x90, 0x81, 0x42, 
-0xE0, 0x30, 0xE4, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 0x29, 0x90, 0x81, 0x3B, 0xE0, 
-0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x20, 0xF0, 0x80, 0x16, 0x90, 
-0x81, 0x7C, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 0xF0, 0x80, 0x08, 0x90, 0x01, 0xB8, 
-0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0xEF, 0x24, 
-0xFE, 0x60, 0x0B, 0x04, 0x70, 0x27, 0x90, 0x81, 0x44, 0x74, 0x02, 0xF0, 0x80, 0x16, 0xED, 0x70, 
-0x0A, 0x90, 0x81, 0x79, 0xE0, 0x90, 0x81, 0x44, 0xF0, 0x80, 0x05, 0x90, 0x81, 0x44, 0xED, 0xF0, 
-0x90, 0x81, 0x44, 0xE0, 0xA3, 0xF0, 0x90, 0x81, 0x3B, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0xAC, 0x07, 
-0x90, 0x81, 0x3A, 0xE0, 0x30, 0xE0, 0x32, 0x90, 0x81, 0x50, 0xE0, 0xD3, 0x94, 0x03, 0x50, 0x07, 
-0x90, 0x81, 0x46, 0xEB, 0xF0, 0x80, 0x0A, 0xED, 0x24, 0xFD, 0x2B, 0x90, 0x81, 0x46, 0xF0, 0x7D, 
-0x03, 0x90, 0x81, 0x75, 0xE0, 0x24, 0x07, 0xC3, 0x9D, 0x2C, 0xFF, 0x90, 0x81, 0x53, 0xF0, 0x90, 
-0x81, 0x49, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x80, 0x0E, 0x90, 0x81, 0x49, 0xE4, 0xF0, 0xA3, 0x74, 
-0x02, 0xF0, 0x90, 0x81, 0x46, 0xEB, 0xF0, 0x90, 0x81, 0x49, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 
-0x22, 0xFD, 0x90, 0x83, 0x6F, 0xE0, 0x34, 0x00, 0xFC, 0x7E, 0x00, 0xED, 0x2F, 0xFF, 0xEE, 0x3C, 
-0xFE, 0xE4, 0xFD, 0xAB, 0x07, 0xAA, 0x06, 0xED, 0x2B, 0xFB, 0xE4, 0x3A, 0xFA, 0xC3, 0x90, 0x80, 
-0xF8, 0xE0, 0x9B, 0x90, 0x80, 0xF7, 0xE0, 0x9A, 0x50, 0x13, 0xA3, 0xE0, 0x24, 0x01, 0xFF, 0x90, 
-0x80, 0xF7, 0xE0, 0x34, 0x00, 0xFE, 0xC3, 0xEB, 0x9F, 0xFB, 0xEA, 0x9E, 0xFA, 0xEA, 0x90, 0xFD, 
-0x11, 0xF0, 0xAF, 0x03, 0x74, 0x00, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFF, 
-0x22, 0x90, 0x83, 0x6F, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x78, 0x78, 0x7C, 0x83, 
-0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xC0, 0x7E, 0x00, 0x7F, 0x06, 0x12, 0x41, 0xD0, 0x78, 
-0x7E, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xC6, 0x7E, 0x00, 0x7F, 0x04, 0x12, 
-0x41, 0xD0, 0x78, 0x82, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xCA, 0x7E, 0x00, 
-0x7F, 0x04, 0x12, 0x41, 0xD0, 0xE4, 0x90, 0x83, 0x87, 0xF0, 0x90, 0x83, 0x71, 0xE0, 0xFF, 0x90, 
-0x83, 0x70, 0xE0, 0x2F, 0xFF, 0x90, 0x83, 0x6F, 0xE0, 0x34, 0x00, 0xCF, 0x24, 0x06, 0xCF, 0x34, 
-0x00, 0xFE, 0xE4, 0xFD, 0x71, 0xB3, 0xEF, 0x64, 0x08, 0x60, 0x02, 0xA1, 0xDD, 0x90, 0x83, 0x71, 
-0xE0, 0xFF, 0x90, 0x83, 0x70, 0xE0, 0x2F, 0xFF, 0x90, 0x83, 0x6F, 0xE0, 0x34, 0x00, 0xCF, 0x24, 
-0x07, 0xCF, 0x34, 0x00, 0xFE, 0xE4, 0xFD, 0x71, 0xB3, 0xEF, 0x64, 0x06, 0x60, 0x02, 0xA1, 0xDD, 
-0x90, 0x83, 0x87, 0x04, 0xF0, 0xE4, 0x90, 0x83, 0x86, 0xF0, 0x90, 0x83, 0x86, 0xE0, 0xFF, 0xC3, 
-0x94, 0x06, 0x50, 0x1F, 0x90, 0x83, 0x70, 0xE0, 0x24, 0x0A, 0x71, 0xA1, 0x90, 0x83, 0x86, 0xE0, 
-0x24, 0x72, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x83, 0x86, 0xE0, 0x04, 
-0xF0, 0x80, 0xD7, 0x78, 0x72, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x8C, 0x7E, 
-0x00, 0x7F, 0x06, 0x12, 0x43, 0xEF, 0xEF, 0x60, 0x02, 0xA1, 0xDD, 0x90, 0x83, 0x86, 0xF0, 0x90, 
-0x83, 0x86, 0xE0, 0xFF, 0xC3, 0x94, 0x04, 0x50, 0x2E, 0x90, 0x83, 0x71, 0xE0, 0xFD, 0x90, 0x83, 
-0x70, 0xE0, 0x2D, 0xFD, 0x90, 0x83, 0x6F, 0xE0, 0x34, 0x00, 0xCD, 0x24, 0x20, 0xCD, 0x71, 0xA6, 
-0x90, 0x83, 0x86, 0xE0, 0x24, 0x82, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 
-0x83, 0x86, 0xE0, 0x04, 0xF0, 0x80, 0xC8, 0x78, 0x82, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 
-0x81, 0x79, 0xA2, 0x7E, 0x00, 0x7F, 0x04, 0x12, 0x43, 0xEF, 0xEF, 0x60, 0x02, 0xA1, 0xD4, 0x90, 
-0x06, 0x30, 0xE0, 0x44, 0x01, 0x54, 0xDF, 0xF0, 0x90, 0x81, 0x7F, 0xE0, 0x30, 0xE0, 0x0F, 0x90, 
-0x01, 0xC7, 0x74, 0x09, 0xF0, 0x90, 0x81, 0x85, 0xE0, 0x44, 0x01, 0xF0, 0xA1, 0xDD, 0xE4, 0x90, 
-0x83, 0x86, 0xF0, 0x90, 0x83, 0x86, 0xE0, 0xFF, 0xC3, 0x94, 0x06, 0x50, 0x2E, 0x90, 0x83, 0x71, 
-0xE0, 0xFD, 0x90, 0x83, 0x70, 0xE0, 0x2D, 0xFD, 0x90, 0x83, 0x6F, 0xE0, 0x34, 0x00, 0xCD, 0x24, 
-0x10, 0xCD, 0x71, 0xA6, 0x90, 0x83, 0x86, 0xE0, 0x24, 0x78, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 
-0x83, 0xEF, 0xF0, 0x90, 0x83, 0x86, 0xE0, 0x04, 0xF0, 0x80, 0xC8, 0xE4, 0x90, 0x83, 0x86, 0xF0, 
-0x90, 0x83, 0x86, 0xE0, 0xFF, 0xC3, 0x94, 0x04, 0x50, 0x2E, 0x90, 0x83, 0x71, 0xE0, 0xFD, 0x90, 
-0x83, 0x70, 0xE0, 0x2D, 0xFD, 0x90, 0x83, 0x6F, 0xE0, 0x34, 0x00, 0xCD, 0x24, 0x16, 0xCD, 0x71, 
-0xA6, 0x90, 0x83, 0x86, 0xE0, 0x24, 0x7E, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0xEF, 0xF0, 
-0x90, 0x83, 0x86, 0xE0, 0x04, 0xF0, 0x80, 0xC8, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0x78, 0x90, 0x83, 
-0x8B, 0x12, 0x42, 0x3A, 0xE4, 0x90, 0x83, 0x8E, 0xF0, 0xA3, 0xF0, 0x7A, 0x83, 0x79, 0x7E, 0x12, 
-0x6B, 0x64, 0x80, 0x09, 0x90, 0x06, 0x30, 0xE0, 0x44, 0x21, 0x54, 0xEF, 0xF0, 0x90, 0x83, 0x87, 
-0xE0, 0xFF, 0x22, 0x90, 0x83, 0x71, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x83, 0x6F, 0xEE, 0xF0, 
-0xA3, 0xEF, 0xF0, 0xE4, 0x90, 0x83, 0x74, 0xF0, 0xFD, 0x71, 0xB3, 0xEF, 0x54, 0x0C, 0x64, 0x08, 
-0x70, 0x74, 0x90, 0x83, 0x6F, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x24, 0x06, 0xFD, 0x71, 
-0xB3, 0xEF, 0x64, 0x88, 0x70, 0x60, 0x90, 0x83, 0x6F, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 
-0x24, 0x07, 0xFD, 0x71, 0xB3, 0xEF, 0x64, 0x8E, 0x70, 0x4C, 0x90, 0x83, 0x74, 0x04, 0xF0, 0x90, 
-0x83, 0x6F, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x83, 0x72, 0xE0, 0xFD, 0x90, 0x83, 0x71, 0xE0, 
-0x2D, 0x04, 0xFD, 0x71, 0xB3, 0xEF, 0x64, 0x03, 0x70, 0x2C, 0x90, 0x83, 0x6F, 0xE0, 0xFE, 0xA3, 
-0xE0, 0xFF, 0x90, 0x83, 0x72, 0xE0, 0xFD, 0x90, 0x83, 0x71, 0xE0, 0x2D, 0x24, 0x06, 0xFD, 0x71, 
-0xB3, 0xEF, 0x90, 0x01, 0xC7, 0x30, 0xE3, 0x04, 0x74, 0x01, 0x80, 0x02, 0x74, 0x02, 0xF0, 0x90, 
-0x81, 0x85, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x83, 0x74, 0xE0, 0xFF, 0x22, 0x90, 0x83, 0x7F, 0xEE, 
-0xF0, 0xA3, 0xEF, 0xF0, 0x7D, 0x09, 0x71, 0xB3, 0xEF, 0x64, 0x06, 0x70, 0x36, 0x90, 0x83, 0x7F, 
-0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x14, 0x71, 0xB3, 0xEF, 0x70, 0x27, 0x90, 0x83, 0x7F, 0xE0, 
-0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x15, 0x71, 0xB3, 0xEF, 0x64, 0x50, 0x70, 0x16, 0x90, 0x83, 0x7F, 
-0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x21, 0x71, 0xB3, 0xEF, 0x20, 0xE0, 0x03, 0x30, 0xE2, 0x03, 
-0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x90, 0x83, 0x6F, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xED, 
-0xF0, 0x78, 0x72, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xD4, 0x7E, 0x00, 0x7F, 
-0x06, 0x12, 0x41, 0xD0, 0x78, 0x79, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xDA, 
-0x7E, 0x00, 0x7F, 0x04, 0x12, 0x41, 0xD0, 0xE4, 0x90, 0x83, 0x78, 0xF0, 0x90, 0x83, 0x78, 0xE0, 
-0xFF, 0xC3, 0x94, 0x06, 0x50, 0x1F, 0x90, 0x83, 0x70, 0xE0, 0x24, 0x04, 0x71, 0xA1, 0x90, 0x83, 
-0x78, 0xE0, 0x24, 0x72, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x83, 0x78, 
-0xE0, 0x04, 0xF0, 0x80, 0xD7, 0x78, 0x72, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x81, 0x79, 
-0x86, 0x7E, 0x00, 0x7F, 0x06, 0x12, 0x43, 0xEF, 0xEF, 0x60, 0x02, 0xE1, 0xE5, 0x90, 0x83, 0x71, 
-0xE0, 0xFF, 0x90, 0x83, 0x70, 0xE0, 0x2F, 0xFF, 0x90, 0x83, 0x6F, 0xE0, 0x34, 0x00, 0xFE, 0x90, 
-0x83, 0x7D, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 0x06, 0xFF, 0xE4, 0x3E, 0xFE, 0xE4, 0xFD, 0x71, 0xB3, 
-0xEF, 0x64, 0x08, 0x60, 0x02, 0xE1, 0xE5, 0x90, 0x83, 0x7E, 0xE0, 0x24, 0x07, 0xFF, 0x90, 0x83, 
-0x7D, 0xE0, 0x34, 0x00, 0xFE, 0xE4, 0xFD, 0x71, 0xB3, 0xEF, 0x70, 0x69, 0x90, 0x83, 0x78, 0xF0, 
-0x90, 0x83, 0x78, 0xE0, 0xFF, 0xC3, 0x94, 0x04, 0x50, 0x23, 0x90, 0x83, 0x7E, 0xE0, 0x24, 0x18, 
-0xFD, 0x90, 0x83, 0x7D, 0x71, 0xA5, 0x90, 0x83, 0x78, 0xE0, 0x24, 0x79, 0xF5, 0x82, 0xE4, 0x34, 
-0x83, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x83, 0x78, 0xE0, 0x04, 0xF0, 0x80, 0xD3, 0x78, 0x79, 0x7C, 
-0x83, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xA2, 0x7E, 0x00, 0x7F, 0x04, 0x12, 0x43, 0xEF, 
-0xEF, 0x70, 0x22, 0x90, 0x83, 0x7E, 0xE0, 0x24, 0x08, 0xFF, 0x90, 0x83, 0x7D, 0xE0, 0x34, 0x00, 
-0xFE, 0xD1, 0x7C, 0xEF, 0x64, 0x01, 0x60, 0x0D, 0x90, 0x01, 0xC7, 0x74, 0x22, 0xF0, 0x90, 0x81, 
-0x85, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x7D, 0x7F, 0xEF, 0x5D, 0xC3, 0x60, 0x14, 0x74, 0xFF, 0x9D, 
-0xFD, 0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x5F, 0x24, 0x80, 0xFF, 0xE4, 0x3E, 0xFE, 0x80, 
-0x0D, 0x74, 0xFF, 0x9D, 0xFD, 0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x5F, 0xFF, 0x22, 0x90, 
-0x01, 0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x90, 
-0x83, 0x61, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x87, 0xE0, 0x90, 0x83, 0x65, 0xF0, 0x90, 0x81, 
-0x7D, 0xE0, 0x20, 0xE0, 0x02, 0x21, 0x08, 0x90, 0x83, 0x65, 0xE0, 0xFF, 0xEC, 0xC3, 0x9F, 0x40, 
-0x02, 0x21, 0x08, 0x90, 0x83, 0x61, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0xEA, 0x90, 0xFD, 0x11, 0xF0, 
-0xAF, 0x03, 0xAD, 0x07, 0x74, 0x02, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 
-0x0F, 0x33, 0x33, 0x33, 0x54, 0xF8, 0xF9, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 
-0x83, 0xE0, 0xFE, 0x74, 0x00, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x7A, 0x00, 
-0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x54, 0x3F, 0x90, 0x83, 0x63, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x03, 
-0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x03, 0xFF, 0x7E, 0x00, 0xAD, 0x01, 
-0xED, 0x24, 0x18, 0xFB, 0xEA, 0x33, 0xCB, 0x2F, 0xFF, 0xEE, 0x3B, 0x90, 0x83, 0x63, 0x8F, 0xF0, 
-0x12, 0x41, 0xF6, 0x90, 0x83, 0x63, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x77, 0xE6, 0x90, 0x83, 
-0x63, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x83, 0x61, 0xEE, 0x8F, 0xF0, 0x12, 0x41, 0xF6, 0x90, 
-0x80, 0xF7, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xD3, 0x90, 0x83, 0x62, 0xE0, 0x9F, 0x90, 0x83, 0x61, 
-0xE0, 0x9E, 0x40, 0x1B, 0x90, 0x80, 0xF8, 0xE0, 0x24, 0x01, 0xFF, 0x90, 0x80, 0xF7, 0xE0, 0x34, 
-0x00, 0xFE, 0xC3, 0x90, 0x83, 0x62, 0xE0, 0x9F, 0xF0, 0x90, 0x83, 0x61, 0xE0, 0x9E, 0xF0, 0x90, 
-0x83, 0x61, 0x12, 0x57, 0xAF, 0x0C, 0x01, 0x37, 0x22, 0x12, 0x57, 0xC2, 0xAD, 0x07, 0x90, 0x01, 
-0xC4, 0x74, 0x09, 0xF0, 0x74, 0x79, 0xA3, 0xF0, 0xED, 0x64, 0x01, 0x60, 0x22, 0x90, 0x81, 0x85, 
-0xE0, 0x44, 0x01, 0xF0, 0xED, 0xB4, 0x02, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x40, 0xF0, 0x80, 0x0A, 
-0xED, 0xB4, 0x04, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x41, 0xF0, 0x7F, 0x01, 0x02, 0x51, 0xAF, 0x11, 
-0x0F, 0x90, 0x02, 0x87, 0xE0, 0x70, 0xF8, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x02, 0xF0, 0x74, 0x09, 
-0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x79, 0xA3, 0xF0, 0x22, 0x12, 0x4E, 0x4C, 0x31, 0x80, 0x90, 
-0x01, 0x3F, 0x74, 0x04, 0xF0, 0x90, 0x80, 0x06, 0xE0, 0xFF, 0xB4, 0x01, 0x07, 0x90, 0xFD, 0x00, 
-0xE0, 0x54, 0xEF, 0xF0, 0xEF, 0xB4, 0x01, 0x07, 0x90, 0xFE, 0x10, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 
-0xE4, 0xFF, 0x74, 0x48, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0xA4, 
-0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x0F, 0xEF, 0xB4, 0x08, 0xE3, 0x90, 
-0x82, 0x50, 0xE0, 0x90, 0x04, 0x4C, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
-0x83, 0x61, 0x12, 0x42, 0x3A, 0x12, 0x1F, 0xA4, 0x20, 0xE0, 0x04, 0x31, 0x5A, 0x41, 0xDF, 0x90, 
-0x82, 0x50, 0x74, 0x05, 0xF0, 0x90, 0x83, 0x61, 0x12, 0x42, 0x31, 0x12, 0x1F, 0xA4, 0xFF, 0x54, 
-0x01, 0xFE, 0x90, 0x81, 0x80, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 
-0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 
-0xFF, 0x90, 0x81, 0x80, 0xF0, 0xEE, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 0xFF, 0xF0, 0x12, 
-0x1F, 0xA4, 0xFE, 0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x4D, 0xFF, 0x90, 0x81, 0x80, 0xF0, 0xEE, 
-0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 0xFF, 0xF0, 0x12, 0x1F, 0xA4, 0xFE, 0x54, 0x40, 0xFD, 
-0xEF, 0x54, 0xBF, 0x4D, 0xFF, 0x90, 0x81, 0x80, 0xF0, 0xEE, 0x54, 0x80, 0xFE, 0xEF, 0x54, 0x7F, 
-0x4E, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x54, 0x80, 0xFF, 0x90, 0x81, 0x81, 0xE0, 0x54, 
-0x7F, 0x4F, 0xF0, 0x12, 0x1F, 0xA4, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0x90, 0x06, 0x90, 
-0xE0, 0x44, 0x04, 0xF0, 0x90, 0x83, 0x61, 0x12, 0x42, 0x31, 0x12, 0x1F, 0xA4, 0x13, 0x13, 0x13, 
-0x54, 0x1F, 0x30, 0xE0, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x08, 0xF0, 0x90, 0x80, 0x06, 0xE0, 
-0xB4, 0x02, 0x0D, 0x90, 0x81, 0x81, 0xE0, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x20, 0xE0, 0x51, 
-0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x54, 0x7F, 0xFF, 0x90, 0x81, 0x81, 0xE0, 0x54, 0x80, 0x4F, 
-0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0x90, 0x81, 0x82, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 
-0xBD, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0x81, 0x83, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 
-0xFE, 0xFF, 0xEE, 0x54, 0x01, 0x4F, 0xF0, 0x90, 0x81, 0x81, 0xE0, 0x54, 0x7F, 0xFF, 0x90, 0x81, 
-0x80, 0xE0, 0xFE, 0xC4, 0x13, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0x52, 
-0xCC, 0x90, 0x80, 0x06, 0xE0, 0xB4, 0x01, 0x07, 0x90, 0xFE, 0x10, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 
-0xD0, 0x92, 0xAF, 0x22, 0x90, 0x81, 0x85, 0xE0, 0xFF, 0x20, 0xE0, 0x07, 0x90, 0x01, 0x3F, 0xE0, 
-0x30, 0xE2, 0x14, 0xEF, 0x44, 0x01, 0x90, 0x81, 0x85, 0xF0, 0x90, 0x81, 0x80, 0xE0, 0xC4, 0x54, 
-0x0F, 0x20, 0xE0, 0x03, 0x7F, 0x00, 0x22, 0x7F, 0x01, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFD, 0x12, 
-0x1F, 0xA4, 0xFE, 0xAF, 0x05, 0xED, 0x2E, 0x90, 0x83, 0x30, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 
-0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x31, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 
-0x2F, 0x90, 0x83, 0x32, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x83, 
-0x33, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x34, 0xF0, 0x90, 
-0x00, 0x05, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x35, 0xF0, 0x90, 0x00, 0x06, 0x12, 
-0x1F, 0xBD, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x83, 0x36, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 
-0xFD, 0x12, 0x1F, 0xA4, 0xFE, 0xAF, 0x05, 0xED, 0x2E, 0x90, 0x83, 0x37, 0xF0, 0x90, 0x00, 0x01, 
-0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x38, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x1F, 0xBD, 
-0xFF, 0xED, 0x2F, 0x90, 0x83, 0x39, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 
-0x90, 0x83, 0x3A, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x3B, 
-0xF0, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0xFF, 0xED, 0x2F, 0x90, 0x83, 0x3C, 0xF0, 0x90, 0x00, 
-0x06, 0x12, 0x1F, 0xBD, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x83, 0x3D, 0xF0, 0x22, 0xE4, 0xFF, 
-0x74, 0x18, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x06, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x8C, 0x2F, 0xF5, 
-0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEE, 0xF0, 0x74, 0x10, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x06, 
-0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x86, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEE, 0xF0, 
-0x0F, 0xEF, 0xB4, 0x06, 0xCB, 0x22, 0x90, 0x83, 0xA9, 0x12, 0x42, 0x3A, 0x12, 0x1F, 0xA4, 0x90, 
-0x83, 0xAE, 0xF0, 0x90, 0x00, 0x01, 0x12, 0x1F, 0xBD, 0x90, 0x83, 0xAF, 0xF0, 0x90, 0x00, 0x04, 
-0x12, 0x1F, 0xBD, 0x90, 0x83, 0xB0, 0xF0, 0x90, 0x00, 0x05, 0x12, 0x1F, 0xBD, 0x90, 0x83, 0xB1, 
-0xF0, 0x90, 0x00, 0x06, 0x12, 0x1F, 0xBD, 0x90, 0x83, 0xB2, 0xF0, 0x90, 0x00, 0x07, 0x12, 0x1F, 
-0xBD, 0x90, 0x83, 0xB3, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x1F, 0xBD, 0x90, 0x83, 0xB6, 0xF0, 0xED, 
-0x70, 0x31, 0xFF, 0x74, 0xAE, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0xE0, 0xB4, 0xFF, 
-0x0E, 0x74, 0xAE, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0xE4, 0xF0, 0x80, 0x0F, 0x74, 
-0xAE, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 0xE0, 0x04, 0xF0, 0x80, 0x05, 0x0F, 0xEF, 
-0xB4, 0x06, 0xD0, 0x90, 0x83, 0xAD, 0xE0, 0xFF, 0xB4, 0x04, 0x25, 0xA3, 0xE0, 0xFE, 0x90, 0x83, 
-0xA9, 0x12, 0x42, 0x31, 0xEE, 0x12, 0x1F, 0xEA, 0x90, 0x83, 0xAF, 0xE0, 0xFE, 0x90, 0x83, 0xA9, 
-0x12, 0x42, 0x31, 0x90, 0x00, 0x01, 0xEE, 0x12, 0x1F, 0xFC, 0x90, 0x00, 0x02, 0xE4, 0x80, 0x30, 
-0xEF, 0xB4, 0x02, 0x2F, 0x90, 0x83, 0xAF, 0xE0, 0xFF, 0x90, 0x83, 0xA9, 0x12, 0x42, 0x31, 0xEF, 
-0x12, 0x1F, 0xEA, 0x90, 0x83, 0xAF, 0xE0, 0x44, 0x20, 0x54, 0x7F, 0xFF, 0x90, 0x83, 0xA9, 0x12, 
-0x42, 0x31, 0x90, 0x00, 0x01, 0xEF, 0x12, 0x1F, 0xFC, 0x90, 0x83, 0xAE, 0xE0, 0x90, 0x00, 0x02, 
-0x12, 0x1F, 0xFC, 0x90, 0x83, 0xA9, 0x12, 0x42, 0x31, 0xE9, 0x24, 0x03, 0xF9, 0xE4, 0x3A, 0xFA, 
-0x12, 0x1F, 0xA4, 0x44, 0x20, 0x12, 0x1F, 0xEA, 0x90, 0x83, 0xB0, 0xE0, 0xFF, 0x90, 0x83, 0xA9, 
-0x12, 0x42, 0x31, 0x90, 0x00, 0x04, 0xEF, 0x12, 0x1F, 0xFC, 0x90, 0x83, 0xB1, 0xE0, 0x90, 0x00, 
-0x05, 0x12, 0x1F, 0xFC, 0x90, 0x83, 0xB2, 0xE0, 0x90, 0x00, 0x06, 0x12, 0x1F, 0xFC, 0x90, 0x83, 
-0xB3, 0xE0, 0x90, 0x00, 0x07, 0x02, 0x1F, 0xFC, 0x66, 0x67, 
+0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x64, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x91, 0x65, 0xFF, 0x12, 
+0x2D, 0x5C, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x90, 0x83, 0xD5, 0x12, 0x20, 0xCE, 0x90, 0x83, 
+0xD5, 0x02, 0x42, 0x19, 0x90, 0x83, 0xD9, 0x02, 0x42, 0x19, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x62, 
+0xF5, 0x82, 0xE4, 0x34, 0x87, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0x22, 0x7F, 0x24, 0x7E, 0x08, 
+0x12, 0x2E, 0xA2, 0x90, 0x83, 0xD3, 0xE0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 
+0x07, 0xC0, 0x05, 0x90, 0x84, 0x04, 0x12, 0x42, 0x19, 0x90, 0x83, 0xF2, 0x12, 0x20, 0xCE, 0xD0, 
+0x05, 0xD0, 0x07, 0x91, 0x9A, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x83, 0xF0, 0xEF, 0xF0, 0xAB, 
+0x05, 0x90, 0x83, 0xF6, 0x12, 0x20, 0xDA, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x03, 0xE4, 0xFC, 0xFD, 
+0xFE, 0x78, 0x14, 0xF1, 0x0B, 0x90, 0x83, 0xF2, 0x12, 0x42, 0x19, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 
+0xFC, 0x12, 0x42, 0x0C, 0xEC, 0x54, 0x0F, 0xFC, 0x90, 0x83, 0xF6, 0x12, 0x20, 0xCE, 0x90, 0x83, 
+0xF0, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x60, 0xF5, 0x82, 0xE4, 0x34, 0x87, 0x91, 0x65, 0xFF, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0x83, 0xF6, 0x71, 0x64, 0xD0, 0x07, 0xD0, 0x06, 0x02, 0x2E, 0xA2, 
+0x12, 0x73, 0x10, 0x30, 0xE0, 0x0B, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x31, 
+0x4B, 0x90, 0x81, 0x04, 0xF1, 0xC9, 0x30, 0xE0, 0x0A, 0xEF, 0x12, 0x76, 0x77, 0x54, 0x07, 0x70, 
+0x45, 0x80, 0x41, 0x90, 0x81, 0x11, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x0C, 0xE0, 0x54, 0xEF, 0xF0, 
+0xD1, 0xFF, 0x40, 0x30, 0x12, 0x4C, 0x5F, 0x64, 0x01, 0x70, 0x2B, 0x12, 0x57, 0xDD, 0x70, 0x04, 
+0xB1, 0x5F, 0x80, 0x23, 0xB1, 0x5F, 0x90, 0x81, 0x12, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 
+0x40, 0x09, 0xB1, 0x57, 0xE4, 0x90, 0x81, 0x12, 0xF0, 0x80, 0x03, 0x12, 0x4C, 0x89, 0xE4, 0x90, 
+0x81, 0x11, 0xF0, 0x22, 0xB1, 0x9C, 0x22, 0x90, 0x81, 0x05, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0xD1, 
+0xFF, 0x40, 0x20, 0x90, 0x81, 0x22, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x94, 0x04, 0x50, 0x14, 0x90, 
+0x81, 0x1A, 0xEF, 0xF0, 0x25, 0xE0, 0x24, 0x08, 0x90, 0x81, 0x21, 0xF0, 0xFB, 0x12, 0x6F, 0x7A, 
+0x12, 0x6F, 0x0F, 0x22, 0x7F, 0x70, 0x7E, 0x0E, 0x02, 0x2E, 0xA2, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 
+0xF4, 0x5E, 0x22, 0x7F, 0x7C, 0x7E, 0x08, 0x12, 0x2D, 0x5C, 0xEC, 0x22, 0x90, 0x81, 0x0A, 0xE0, 
+0xFF, 0x7D, 0x01, 0x02, 0x49, 0x0F, 0x90, 0x81, 0x04, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 
+0x30, 0xE0, 0x19, 0xEF, 0x54, 0xBF, 0xD1, 0xED, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 
+0x09, 0xE0, 0x54, 0xFE, 0x12, 0x4F, 0xFB, 0x74, 0x04, 0xF0, 0xB1, 0x9C, 0xE4, 0xFF, 0x90, 0x83, 
+0x7B, 0xE0, 0x30, 0xE0, 0x3D, 0x90, 0x83, 0x80, 0xE0, 0xFD, 0x60, 0x36, 0x12, 0x6D, 0xD2, 0x80, 
+0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x04, 0xE0, 0xE0, 0xFB, 0xEF, 0x5B, 
+0x60, 0x0B, 0xE4, 0x90, 0x83, 0x80, 0xF0, 0x90, 0x83, 0x82, 0x04, 0xF0, 0x22, 0x90, 0x83, 0x7D, 
+0xE0, 0xD3, 0x9D, 0x50, 0x04, 0xD1, 0x87, 0xF0, 0x22, 0x12, 0x4C, 0x0B, 0x90, 0x83, 0x80, 0xE0, 
+0x04, 0xF0, 0x22, 0x90, 0x81, 0x04, 0xD1, 0x7E, 0x30, 0xE0, 0x1E, 0xEF, 0x54, 0x7F, 0xD1, 0xED, 
+0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x08, 0xE0, 0x54, 0xFD, 0x12, 0x4F, 0xFB, 0x04, 
+0xF0, 0x90, 0x81, 0x08, 0xE0, 0x60, 0x02, 0xB1, 0x9C, 0x7F, 0x01, 0x80, 0x91, 0x90, 0x84, 0x3B, 
+0xEF, 0xF0, 0x90, 0x80, 0x06, 0xE0, 0x64, 0x02, 0x70, 0x21, 0x90, 0x84, 0x3B, 0xE0, 0xFD, 0x64, 
+0x01, 0x70, 0x27, 0xD1, 0xE5, 0x90, 0x81, 0xB7, 0xE0, 0xD1, 0x80, 0x30, 0xE0, 0x09, 0x90, 0x01, 
+0x4D, 0xE0, 0x64, 0x80, 0xF0, 0x80, 0x13, 0xAF, 0x05, 0x80, 0x0C, 0x90, 0x06, 0x90, 0xE0, 0x44, 
+0x01, 0xF0, 0x90, 0x84, 0x3B, 0xE0, 0xFF, 0x12, 0x52, 0x5B, 0xD1, 0x91, 0xF0, 0x22, 0xE0, 0xFF, 
+0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0x90, 0x01, 0xC7, 0x74, 0x10, 0xF0, 0x7F, 0x01, 0xD1, 
+0x3D, 0x90, 0x83, 0x7B, 0xE0, 0x54, 0xFE, 0x22, 0x12, 0x78, 0x7D, 0xAD, 0x07, 0x90, 0x01, 0xC4, 
+0x74, 0x98, 0xF0, 0x74, 0x5E, 0xA3, 0xF0, 0xED, 0x64, 0x01, 0x60, 0x1C, 0xD1, 0xE5, 0xED, 0xB4, 
+0x02, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x40, 0xF0, 0x80, 0x0A, 0xED, 0xB4, 0x04, 0x06, 0x90, 0x01, 
+0xC7, 0x74, 0x41, 0xF0, 0x7F, 0x01, 0xC1, 0x3D, 0x12, 0x66, 0x4D, 0x90, 0x02, 0x87, 0xE0, 0x70, 
+0xF7, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x02, 0xF0, 0x74, 0x98, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 
+0x5E, 0xA3, 0xF0, 0x22, 0xF0, 0x90, 0x81, 0xBC, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0xF0, 0x90, 0x04, 
+0xE0, 0xE0, 0x90, 0x81, 0x05, 0x22, 0x51, 0xCB, 0x7D, 0x0C, 0x7F, 0x01, 0x02, 0x4B, 0x2A, 0x90, 
+0x81, 0xAC, 0xE0, 0xFF, 0x90, 0x81, 0x11, 0xE0, 0xD3, 0x9F, 0x22, 0x12, 0x20, 0xBB, 0xA8, 0x04, 
+0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x22, 0xF1, 0x43, 0x12, 0x71, 0x04, 0x12, 0x75, 0x9F, 0x51, 
+0xA2, 0xF1, 0x8E, 0x12, 0x79, 0xA4, 0x90, 0x83, 0x83, 0xE0, 0x54, 0x7F, 0xF0, 0x54, 0xBF, 0xF0, 
+0x54, 0xDF, 0xF0, 0x54, 0xF0, 0xF0, 0xE4, 0x90, 0x83, 0x85, 0xF0, 0x90, 0x83, 0x83, 0xE0, 0x54, 
+0xEF, 0xF0, 0x22, 0xE4, 0xFD, 0xFF, 0x12, 0x79, 0xF0, 0xED, 0x70, 0x12, 0xF1, 0x83, 0xC0, 0x83, 
+0xC0, 0x82, 0xF1, 0x7B, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x0F, 0xF1, 0x83, 
+0xC0, 0x83, 0xC0, 0x82, 0xF1, 0x7B, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 0xD0, 
+0x83, 0xF0, 0x12, 0x71, 0x12, 0x90, 0x81, 0x02, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 
+0x07, 0x08, 0x22, 0x74, 0xFA, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0x22, 0x90, 0x83, 
+0x77, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0x7F, 0xF0, 0x54, 0xFB, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0xE4, 
+0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xE4, 0xFF, 0x74, 0x7F, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x82, 0xF5, 
+0x83, 0xE0, 0xFE, 0x74, 0xA4, 0x11, 0xD1, 0x0F, 0xEF, 0xB4, 0x08, 0xEB, 0x90, 0x82, 0x87, 0xE0, 
+0x90, 0x04, 0x4C, 0xF0, 0x22, 0x22, 0x22, 0x22, 0x22, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x22, 
+0x7D, 0x01, 0x7F, 0x02, 0x21, 0x4F, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x22, 0x90, 0x06, 
+0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x20, 0xE7, 0x09, 0xE0, 0x7F, 0x01, 
+0x20, 0xE6, 0x0C, 0x7F, 0x02, 0x22, 0x90, 0x00, 0xF7, 0xE0, 0x30, 0xE6, 0x02, 0x7F, 0x03, 0x22, 
+0x12, 0x5F, 0xE6, 0x90, 0x80, 0x06, 0xEF, 0xF0, 0x11, 0x21, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 
+0x90, 0x00, 0x12, 0xE0, 0x54, 0xC7, 0x44, 0x20, 0xFD, 0x7F, 0x12, 0x12, 0x32, 0x1E, 0x02, 0x2D, 
+0xA7, 0x11, 0x51, 0x11, 0x7F, 0x12, 0x71, 0x6A, 0x12, 0x71, 0x89, 0xE4, 0xF5, 0x35, 0xF5, 0x36, 
+0xF5, 0x37, 0x75, 0x38, 0x80, 0xAD, 0x35, 0x7F, 0x50, 0x12, 0x32, 0x1E, 0xAD, 0x36, 0x7F, 0x51, 
+0x12, 0x32, 0x1E, 0xAD, 0x37, 0x7F, 0x52, 0x12, 0x32, 0x1E, 0xAD, 0x38, 0x7F, 0x53, 0x02, 0x32, 
+0x1E, 0x90, 0x01, 0x30, 0xE4, 0x11, 0x77, 0x90, 0x01, 0x38, 0x11, 0x77, 0xFD, 0x7F, 0x50, 0x12, 
+0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x51, 0x12, 0x32, 0x1E, 0xE4, 0xFD, 0x7F, 0x52, 0x12, 0x32, 0x1E, 
+0xE4, 0xFD, 0x7F, 0x53, 0x02, 0x32, 0x1E, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 
+0x01, 0x34, 0x74, 0xFF, 0x11, 0x77, 0x90, 0x01, 0x3C, 0x11, 0x77, 0xFD, 0x7F, 0x54, 0x12, 0x32, 
+0x1E, 0x7D, 0xFF, 0x7F, 0x55, 0x12, 0x32, 0x1E, 0x7D, 0xFF, 0x7F, 0x56, 0x12, 0x32, 0x1E, 0x7D, 
+0xFF, 0x7F, 0x57, 0x02, 0x32, 0x1E, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x83, 0x9E, 
+0x74, 0x08, 0xF0, 0xE4, 0xA3, 0x11, 0x77, 0x90, 0x83, 0xA5, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xF1, 
+0x52, 0xD1, 0x44, 0xD1, 0x15, 0x90, 0x02, 0x82, 0xE0, 0x90, 0x83, 0x9D, 0xF0, 0x90, 0x81, 0xB3, 
+0xE0, 0x20, 0xE0, 0x02, 0x41, 0xB0, 0x90, 0x81, 0xBC, 0xE0, 0x20, 0xE0, 0x07, 0x90, 0x01, 0x3F, 
+0xE0, 0x30, 0xE2, 0x1A, 0x90, 0x80, 0x06, 0xE0, 0xB4, 0x01, 0x0E, 0x90, 0xFD, 0x01, 0xE0, 0x20, 
+0xE6, 0x07, 0x90, 0xFD, 0x00, 0xE0, 0x44, 0x10, 0xF0, 0x7F, 0x01, 0x12, 0x5E, 0x3D, 0xE4, 0x90, 
+0x83, 0x9C, 0xF0, 0x90, 0x83, 0x9D, 0xE0, 0xFF, 0x90, 0x83, 0x9C, 0xE0, 0xC3, 0x9F, 0x40, 0x02, 
+0x41, 0xB0, 0xD1, 0x1D, 0xFD, 0xEC, 0xFF, 0x90, 0xFD, 0x11, 0xF0, 0xAE, 0x05, 0xAA, 0x06, 0x90, 
+0x83, 0xA0, 0xEF, 0xF0, 0x74, 0x02, 0x2A, 0xF1, 0x80, 0xFF, 0x74, 0x03, 0x2A, 0xF1, 0x49, 0x54, 
+0x03, 0xFE, 0xEF, 0x24, 0x18, 0x2E, 0x90, 0x83, 0xA5, 0xF0, 0xE0, 0xFF, 0x2A, 0x90, 0x83, 0x98, 
+0xF0, 0x7E, 0x00, 0xD1, 0x1D, 0x2F, 0xFF, 0xEE, 0x3C, 0x90, 0x83, 0x99, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0x83, 0x98, 0xE0, 0xFD, 0x24, 0x00, 0xB1, 0xB1, 0xE0, 0xFE, 0x54, 0xFC, 0x90, 0x83, 0x9B, 
+0xF0, 0xAF, 0x06, 0xD1, 0x2F, 0xFD, 0x90, 0x83, 0x98, 0xE0, 0xF1, 0x39, 0x12, 0x79, 0x1A, 0x90, 
+0x83, 0x9F, 0xEF, 0xF0, 0x74, 0x01, 0x2A, 0xD1, 0x32, 0xFE, 0x74, 0x00, 0x2A, 0xB1, 0xB1, 0xD1, 
+0x44, 0x54, 0x3F, 0xFE, 0x90, 0x83, 0xA1, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x83, 0xA5, 0xE0, 0x2F, 
+0xFF, 0xEC, 0x3E, 0xFE, 0xF1, 0x10, 0x74, 0x0F, 0x2A, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 
+0xE0, 0xFD, 0x90, 0x83, 0x96, 0xF1, 0x71, 0x90, 0x83, 0x96, 0xE0, 0xFA, 0xA3, 0xE0, 0xD3, 0x9F, 
+0xEA, 0x9E, 0x40, 0x1D, 0x90, 0x83, 0x96, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x80, 0xF8, 0xE0, 
+0xFA, 0xA3, 0xE0, 0x24, 0x01, 0xFB, 0xE4, 0x3A, 0xFA, 0xC3, 0xEF, 0x9B, 0xFF, 0xEE, 0x9A, 0xD1, 
+0x15, 0xED, 0x30, 0xE7, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x21, 0xF0, 0xED, 0x30, 0xE6, 0x06, 0x90, 
+0x01, 0xC7, 0x74, 0x22, 0xF0, 0xED, 0x30, 0xE5, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x23, 0xF0, 0x90, 
+0x83, 0x9B, 0xE0, 0x24, 0x40, 0x60, 0x04, 0x24, 0x20, 0x70, 0x16, 0x90, 0x81, 0xB6, 0x12, 0x5E, 
+0x7E, 0x30, 0xE0, 0x54, 0xB1, 0xC8, 0x60, 0x50, 0x90, 0x83, 0x9B, 0xE0, 0xFF, 0xF1, 0xCA, 0x80, 
+0x47, 0xB1, 0xC8, 0x60, 0x1A, 0x51, 0xB5, 0x90, 0x83, 0x9E, 0xE0, 0xFB, 0x90, 0x83, 0xA0, 0xE0, 
+0x90, 0x83, 0xAC, 0xF0, 0x51, 0xC3, 0xEF, 0x60, 0x06, 0x90, 0x83, 0xA7, 0x74, 0x01, 0xF0, 0x90, 
+0x81, 0xB3, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x0D, 0x51, 0xB5, 0x71, 0x63, 0xEF, 0x60, 0x06, 0x90, 
+0x83, 0xA7, 0x74, 0x01, 0xF0, 0x90, 0x81, 0xB3, 0x12, 0x5E, 0x7E, 0x30, 0xE0, 0x0A, 0x90, 0x83, 
+0xA7, 0xE0, 0x70, 0x04, 0x51, 0xB5, 0x91, 0xFA, 0x90, 0x81, 0xBC, 0xE0, 0x20, 0xE0, 0x07, 0x90, 
+0x01, 0x3F, 0xE0, 0x30, 0xE2, 0x05, 0x7F, 0x01, 0x12, 0x5E, 0x3D, 0x12, 0x78, 0x93, 0xEF, 0x64, 
+0x01, 0x70, 0x3D, 0x12, 0x78, 0x7D, 0x90, 0x83, 0xA6, 0xEF, 0xF0, 0x64, 0x01, 0x60, 0x24, 0x12, 
+0x5E, 0xE5, 0x90, 0x83, 0xA6, 0xE0, 0xFF, 0xB4, 0x02, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x42, 0xF0, 
+0x80, 0x0A, 0xEF, 0xB4, 0x04, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x43, 0xF0, 0x7F, 0x01, 0x12, 0x5E, 
+0x3D, 0x80, 0x0D, 0x90, 0x83, 0x96, 0xF1, 0xA1, 0x90, 0x83, 0x9C, 0xE0, 0x04, 0xF0, 0x21, 0x03, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x83, 0x99, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x83, 0x9F, 
+0xE0, 0xFD, 0x22, 0x90, 0x83, 0xAA, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0xD1, 0x0D, 0xF0, 0xE4, 0x90, 
+0x83, 0xAD, 0xF0, 0xFD, 0x71, 0x39, 0xEF, 0x54, 0x0C, 0x64, 0x08, 0x70, 0x48, 0xD1, 0x25, 0xE0, 
+0xB1, 0xC1, 0x64, 0x88, 0x70, 0x3F, 0xD1, 0x25, 0xE0, 0x24, 0x07, 0xFD, 0x71, 0x39, 0xEF, 0x64, 
+0x8E, 0x70, 0x32, 0x90, 0x83, 0xAD, 0x04, 0xF0, 0xD1, 0xFD, 0x04, 0xFD, 0x71, 0x39, 0xEF, 0x64, 
+0x03, 0x70, 0x22, 0xD1, 0xFD, 0xB1, 0xC1, 0x30, 0xE3, 0x07, 0x90, 0x01, 0xC7, 0x74, 0x01, 0x80, 
+0x11, 0x90, 0x81, 0xB6, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x08, 0x90, 0x01, 0xC7, 
+0x74, 0x02, 0x12, 0x5E, 0xE4, 0x90, 0x83, 0xAD, 0xE0, 0xFF, 0x22, 0xCD, 0x34, 0x00, 0xFC, 0x7E, 
+0x00, 0xED, 0x2F, 0xFF, 0xEE, 0x3C, 0xFE, 0xE4, 0xFD, 0xAB, 0x07, 0xAA, 0x06, 0xED, 0x2B, 0xFB, 
+0xE4, 0x3A, 0xFA, 0xC3, 0x90, 0x80, 0xF9, 0xE0, 0x9B, 0x90, 0x80, 0xF8, 0xE0, 0x9A, 0x50, 0x09, 
+0xA3, 0xF1, 0x64, 0xEB, 0x9F, 0xFB, 0xEA, 0x9E, 0xFA, 0xF1, 0x41, 0x74, 0x00, 0x2F, 0xB1, 0xB1, 
+0xE0, 0xFF, 0x22, 0xD1, 0x0D, 0xF0, 0xA3, 0xED, 0xF0, 0x78, 0xB1, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 
+0xFF, 0x7A, 0x40, 0x79, 0xC0, 0xF1, 0x32, 0x78, 0xB7, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 
+0x40, 0x79, 0xC6, 0xB1, 0xAA, 0x78, 0xBB, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 
+0xCA, 0xB1, 0xAA, 0xE4, 0x90, 0x83, 0xC0, 0xF0, 0x91, 0x9B, 0xCF, 0x24, 0x06, 0xB1, 0xA0, 0x64, 
+0x08, 0x60, 0x02, 0x81, 0x95, 0x91, 0x9B, 0xCF, 0x24, 0x07, 0xB1, 0xA0, 0x64, 0x06, 0x60, 0x02, 
+0x81, 0x95, 0x90, 0x83, 0xC0, 0x04, 0xF0, 0xE4, 0x90, 0x83, 0xBF, 0xF0, 0x91, 0xAD, 0x94, 0x06, 
+0x50, 0x1C, 0x90, 0x83, 0xA9, 0xE0, 0x24, 0x0A, 0xFD, 0x90, 0x83, 0xA8, 0xE0, 0x71, 0x2C, 0x90, 
+0x83, 0xBF, 0xE0, 0x24, 0xAB, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0x91, 0xB4, 0x80, 0xDE, 0x78, 0xAB, 
+0x7C, 0x83, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xC3, 0xF1, 0x5B, 0x60, 0x02, 0x81, 0x95, 
+0x90, 0x83, 0xBF, 0xF0, 0x91, 0xAD, 0x94, 0x04, 0x50, 0x18, 0xD1, 0x01, 0x91, 0xA6, 0xCD, 0x24, 
+0x20, 0x71, 0x2B, 0x90, 0x83, 0xBF, 0xE0, 0x24, 0xBB, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0x91, 0xB4, 
+0x80, 0xE2, 0x78, 0xBB, 0x7C, 0x83, 0xF1, 0x90, 0x70, 0x72, 0x90, 0x06, 0x30, 0xE0, 0x44, 0x01, 
+0x54, 0xDF, 0xF0, 0x90, 0x81, 0xB5, 0xE0, 0x30, 0xE0, 0x0A, 0x90, 0x01, 0xC7, 0x74, 0x09, 0x12, 
+0x5E, 0xE4, 0x80, 0x61, 0xE4, 0x90, 0x83, 0xBF, 0xF0, 0x91, 0xAD, 0x94, 0x06, 0x50, 0x18, 0xD1, 
+0x01, 0x91, 0xA6, 0xCD, 0x24, 0x10, 0x71, 0x2B, 0x90, 0x83, 0xBF, 0xE0, 0x24, 0xB1, 0xF5, 0x82, 
+0xE4, 0x34, 0x83, 0x91, 0xB4, 0x80, 0xE2, 0xE4, 0x90, 0x83, 0xBF, 0xF0, 0x91, 0xAD, 0x94, 0x04, 
+0x50, 0x18, 0xD1, 0x01, 0x91, 0xA6, 0xCD, 0x24, 0x16, 0x71, 0x2B, 0x90, 0x83, 0xBF, 0xE0, 0x24, 
+0xB7, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0x91, 0xB4, 0x80, 0xE2, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0xB1, 
+0xF1, 0xBD, 0xF0, 0x7A, 0x83, 0x79, 0xB7, 0x12, 0x4E, 0x13, 0x80, 0x09, 0x90, 0x06, 0x30, 0xE0, 
+0x44, 0x21, 0x54, 0xEF, 0xF0, 0x90, 0x83, 0xC0, 0xE0, 0xFF, 0x22, 0x90, 0x83, 0xAA, 0xE0, 0xFF, 
+0x90, 0x83, 0xA9, 0xE0, 0x2F, 0xFF, 0x90, 0x83, 0xA8, 0xE0, 0x34, 0x00, 0x22, 0x90, 0x83, 0xBF, 
+0xE0, 0xFF, 0xC3, 0x22, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x83, 0xBF, 0xE0, 0x04, 0xF0, 0x22, 0x90, 
+0x83, 0xB8, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x7D, 0x09, 0x71, 0x39, 0xEF, 0x64, 0x06, 0x70, 0x27, 
+0xB1, 0xB9, 0xFF, 0x7D, 0x14, 0x71, 0x39, 0xEF, 0x70, 0x1D, 0xB1, 0xB9, 0xFF, 0x7D, 0x15, 0x71, 
+0x39, 0xEF, 0x64, 0x50, 0x70, 0x11, 0xB1, 0xB9, 0xFF, 0x7D, 0x21, 0x71, 0x39, 0xEF, 0x20, 0xE0, 
+0x03, 0x30, 0xE2, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0xD1, 0x0D, 0xF0, 0xA3, 0xED, 0xF0, 
+0x78, 0xAB, 0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xD4, 0xF1, 0x32, 0x78, 0xB2, 
+0x7C, 0x83, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0xDA, 0xB1, 0xAA, 0x90, 0x83, 0xA8, 0xA3, 
+0xB1, 0xCB, 0x60, 0x7B, 0x91, 0x9B, 0xFE, 0x90, 0x83, 0xB6, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 0x06, 
+0xFF, 0xE4, 0x3E, 0xB1, 0xA3, 0x64, 0x08, 0x70, 0x66, 0x90, 0x83, 0xB7, 0xE0, 0x24, 0x07, 0xFF, 
+0x90, 0x83, 0xB6, 0xE0, 0xB1, 0xA1, 0x70, 0x57, 0x90, 0x83, 0xB1, 0xF0, 0x90, 0x83, 0xB1, 0xE0, 
+0xFF, 0xC3, 0x94, 0x04, 0x50, 0x24, 0x90, 0x83, 0xB7, 0xE0, 0x24, 0x18, 0xFD, 0x90, 0x83, 0xB6, 
+0xE0, 0x71, 0x2C, 0x90, 0x83, 0xB1, 0xE0, 0x24, 0xB2, 0xF5, 0x82, 0xE4, 0x34, 0x83, 0xF5, 0x83, 
+0xEF, 0xF0, 0x90, 0x83, 0xB1, 0xE0, 0x04, 0xF0, 0x80, 0xD2, 0x78, 0xB2, 0x7C, 0x83, 0xF1, 0x90, 
+0x70, 0x1D, 0x90, 0x83, 0xB7, 0xE0, 0x24, 0x08, 0xFF, 0x90, 0x83, 0xB6, 0xE0, 0x34, 0x00, 0xFE, 
+0x91, 0xBF, 0xEF, 0x64, 0x01, 0x60, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x22, 0x12, 0x5E, 0xE4, 0x22, 
+0xCF, 0x34, 0x00, 0xFE, 0xE4, 0xFD, 0x71, 0x39, 0xEF, 0x22, 0x7E, 0x00, 0x7F, 0x04, 0x02, 0x41, 
+0xD0, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0x22, 0x90, 0x83, 0xB8, 0xE0, 0xFE, 0xA3, 0xE0, 
+0x22, 0x24, 0x06, 0xFD, 0x71, 0x39, 0xEF, 0x22, 0x90, 0x83, 0x98, 0xE0, 0xFF, 0xB1, 0xD1, 0xEF, 
+0x22, 0xE4, 0xFE, 0xEF, 0x2E, 0xF1, 0x39, 0xF5, 0x83, 0xE0, 0xFD, 0x74, 0xB8, 0x2E, 0xF5, 0x82, 
+0xE4, 0x34, 0x83, 0xF5, 0x83, 0xED, 0xF0, 0x0E, 0xEE, 0xB4, 0x06, 0xE7, 0x78, 0xBD, 0x7C, 0x81, 
+0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0xB8, 0xF1, 0x5B, 0x7F, 0x00, 0x70, 0x02, 0x7F, 0x01, 
+0x22, 0x90, 0x83, 0xAA, 0xE0, 0xFD, 0x90, 0x83, 0xA9, 0xE0, 0x2D, 0xFD, 0x22, 0x90, 0x83, 0xA8, 
+0xEE, 0xF0, 0xA3, 0xEF, 0x22, 0x90, 0x83, 0x96, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x90, 0x83, 0x96, 
+0xE0, 0xFC, 0xA3, 0xE0, 0x22, 0x90, 0x83, 0xA8, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xA3, 0x22, 0x74, 
+0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x22, 0xF0, 0x90, 0x01, 0x17, 0xE0, 
+0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x22, 0xF1, 0x52, 0xD1, 
+0x44, 0x90, 0x83, 0x9A, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x87, 0xE0, 0x90, 0x83, 0x9E, 0xF0, 
+0x90, 0x81, 0xB3, 0xE0, 0x20, 0xE0, 0x02, 0xC1, 0xFC, 0x90, 0x83, 0x9E, 0xE0, 0xFF, 0xEC, 0xC3, 
+0x9F, 0x40, 0x02, 0xC1, 0xFC, 0x90, 0x83, 0x9A, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0xF1, 0x41, 0xAD, 
+0x07, 0x74, 0x02, 0x2D, 0xF1, 0x80, 0xF9, 0xD1, 0x2F, 0xFE, 0x74, 0x00, 0x2D, 0xB1, 0xB1, 0xE0, 
+0x7A, 0x00, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x54, 0x3F, 0x90, 0x83, 0x9C, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x74, 0x03, 0x2D, 0xF1, 0x49, 0x54, 0x03, 0xFF, 0x7E, 0x00, 0xAD, 0x01, 0xED, 0x24, 0x18, 0xFB, 
+0xEA, 0x33, 0xCB, 0x2F, 0xFF, 0xEE, 0x3B, 0x90, 0x83, 0x9C, 0x8F, 0xF0, 0x12, 0x41, 0xF6, 0x90, 
+0x83, 0x9C, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xF1, 0x10, 0x90, 0x83, 0x9C, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x90, 0x83, 0x9A, 0xF1, 0x71, 0xD3, 0x90, 0x83, 0x9B, 0xE0, 0x9F, 0x90, 0x83, 0x9A, 0xE0, 
+0x9E, 0x40, 0x11, 0x90, 0x80, 0xF9, 0xF1, 0x64, 0x90, 0x83, 0x9B, 0xE0, 0x9F, 0xF0, 0x90, 0x83, 
+0x9A, 0xE0, 0x9E, 0xF0, 0x90, 0x83, 0x9A, 0xF1, 0xA1, 0x0C, 0xC1, 0x69, 0x22, 0x90, 0x83, 0xA8, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x83, 0xAB, 0xE0, 0xFD, 0x90, 0x83, 0xAA, 0xE0, 0x2D, 0x22, 
+0x7D, 0x7F, 0xEF, 0x5D, 0xC3, 0x60, 0x0A, 0xF1, 0x25, 0x24, 0x80, 0xFF, 0xE4, 0x3E, 0xFE, 0x80, 
+0x03, 0xF1, 0x25, 0xFF, 0x22, 0x74, 0xFF, 0x9D, 0xFD, 0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 
+0x5F, 0x22, 0x7E, 0x00, 0x7F, 0x06, 0x02, 0x41, 0xD0, 0x24, 0x04, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 
+0x22, 0xEA, 0x90, 0xFD, 0x11, 0xF0, 0xAF, 0x03, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 
+0xE0, 0x22, 0x90, 0x01, 0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0x22, 0x7E, 0x00, 0x7F, 0x06, 0x12, 
+0x43, 0xEF, 0xEF, 0x22, 0xE0, 0x24, 0x01, 0xFF, 0x90, 0x80, 0xF8, 0xE0, 0x34, 0x00, 0xFE, 0xC3, 
+0x22, 0xEE, 0x8F, 0xF0, 0x12, 0x41, 0xF6, 0x90, 0x80, 0xF8, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 
+0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x33, 0x33, 0x33, 0x54, 0xF8, 0x22, 
+0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xD9, 0x7E, 0x00, 0x7F, 0x04, 0x12, 0x43, 0xEF, 0xEF, 
+0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x02, 0x84, 0xEF, 0xF0, 0xEE, 0xA3, 0xF0, 0xA3, 0xE0, 
+0x44, 0x01, 0xF0, 0x22, 0xE4, 0x90, 0x80, 0x01, 0x11, 0x77, 0xA3, 0xF0, 0x22, 0x90, 0x83, 0xC4, 
+0x12, 0x42, 0x3A, 0xE4, 0x90, 0x83, 0xC7, 0xF0, 0xA3, 0x22, 0xEF, 0x90, 0x01, 0xC7, 0xB4, 0xA0, 
+0x05, 0x74, 0x04, 0xF0, 0x80, 0x03, 0x74, 0x08, 0xF0, 0x02, 0x5E, 0xE5, 0x75, 0xE8, 0x03, 0x75, 
+0xA8, 0x84, 0x22, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x90, 
+0xFD, 0x00, 0xE0, 0x54, 0xBF, 0xF0, 0x12, 0x68, 0x4A, 0x12, 0x32, 0x77, 0x12, 0x68, 0x38, 0x12, 
+0x67, 0xB4, 0x7F, 0x01, 0x12, 0x45, 0x54, 0x90, 0x83, 0x76, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x45, 
+0x54, 0x90, 0x83, 0x76, 0xE0, 0x04, 0xF0, 0x12, 0x60, 0x00, 0x12, 0x5F, 0x17, 0x90, 0x00, 0x80, 
+0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 0x32, 0x1E, 0x75, 0x20, 0xFF, 0x12, 0x67, 0xDC, 0x11, 
+0x39, 0x11, 0x40, 0xE4, 0xFF, 0x02, 0x45, 0xDD, 0x22, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 
+0x90, 0x01, 0xE4, 0x74, 0x14, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 
+0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0xE4, 0x90, 0x83, 0x91, 0xF0, 0x90, 0x83, 0x91, 0xE0, 
+0x64, 0x01, 0xF0, 0x24, 0x57, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x68, 0xA3, 0xF0, 0x90, 0x81, 0x08, 
+0xE0, 0x60, 0x0F, 0x90, 0x81, 0x0B, 0xE0, 0xFF, 0x90, 0x81, 0x0A, 0xE0, 0x6F, 0x60, 0x03, 0x12, 
+0x5D, 0x9C, 0xC2, 0xAF, 0x11, 0xE0, 0xBF, 0x01, 0x02, 0x11, 0x94, 0xD2, 0xAF, 0x51, 0x8F, 0x12, 
+0x44, 0x8C, 0x80, 0xC8, 0x90, 0x81, 0x04, 0xE0, 0x30, 0xE0, 0x02, 0x11, 0x9E, 0x22, 0x90, 0x81, 
+0x0B, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x0D, 0x31, 0xB7, 0xBF, 0x01, 0x08, 0x11, 0xB6, 0x90, 
+0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x31, 0x18, 0x11, 
+0xC6, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD1, 0x68, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 0xFD, 0x7F, 
+0x08, 0x12, 0x32, 0x1E, 0xE4, 0xFF, 0x31, 0x64, 0x90, 0x81, 0x05, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 
+0x7D, 0x02, 0x90, 0x01, 0xC4, 0x74, 0xE0, 0xF0, 0x74, 0x68, 0xA3, 0xF0, 0x90, 0x83, 0x76, 0xE0, 
+0xFF, 0xED, 0xC3, 0x9F, 0x50, 0x14, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x07, 
+0x51, 0x05, 0xA3, 0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xE2, 0x74, 0xE0, 0x04, 0x90, 0x01, 0xC4, 
+0xF0, 0x74, 0x68, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x81, 0x05, 0xE0, 0x44, 0x10, 0xF0, 0x90, 
+0x81, 0x13, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x32, 0x1E, 0x90, 0x81, 0x09, 0xE0, 0x60, 0x12, 0x90, 
+0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 
+0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x12, 0x32, 0x1E, 0x7F, 0x01, 0x31, 
+0x64, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x90, 0x12, 0x32, 0x1E, 0x7F, 0x14, 0x7E, 
+0x00, 0x02, 0x32, 0xAA, 0x90, 0x83, 0x92, 0xEF, 0x12, 0x5F, 0x9E, 0x90, 0x01, 0x09, 0xE0, 0x7F, 
+0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 0x83, 0x92, 0xE0, 0x6F, 0x60, 0x39, 0xC3, 0x90, 0x83, 
+0x94, 0xE0, 0x94, 0x88, 0x90, 0x83, 0x93, 0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 
+0x44, 0x10, 0xF0, 0x22, 0x90, 0x83, 0x93, 0x51, 0x90, 0x7F, 0x14, 0x7E, 0x00, 0x12, 0x32, 0xAA, 
+0xD3, 0x90, 0x83, 0x94, 0xE0, 0x94, 0x32, 0x90, 0x83, 0x93, 0xE0, 0x94, 0x00, 0x40, 0xBC, 0x90, 
+0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xB5, 0x22, 0x90, 0x02, 0x87, 0xE0, 0x60, 0x04, 0x51, 0x80, 0x80, 
+0x3B, 0x90, 0x81, 0xB3, 0xE0, 0x30, 0xE0, 0x0A, 0x90, 0x02, 0x82, 0xE0, 0x60, 0x04, 0x51, 0x79, 
+0x80, 0x2A, 0x90, 0x81, 0xBC, 0xE0, 0x30, 0xE0, 0x04, 0x51, 0x05, 0x80, 0x1F, 0x90, 0x02, 0x86, 
+0xE0, 0x20, 0xE1, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x10, 0x90, 0x04, 0x1D, 0xE0, 
+0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x40, 0xF0, 0x80, 0x02, 0x41, 0x87, 0x90, 0x01, 0xB9, 0x74, 
+0x08, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x22, 0xD1, 0x4F, 0xEF, 0x64, 
+0x01, 0x60, 0x04, 0x51, 0x80, 0x80, 0x59, 0x90, 0x81, 0x0C, 0xE0, 0xFF, 0x54, 0x03, 0x60, 0x04, 
+0x51, 0x79, 0x80, 0x4C, 0x90, 0x81, 0x0A, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x08, 0x90, 0x01, 
+0xB8, 0x74, 0x04, 0xF0, 0x80, 0x3A, 0xEF, 0x30, 0xE2, 0x04, 0x51, 0x05, 0x80, 0x32, 0x90, 0x81, 
+0x0C, 0xE0, 0x30, 0xE4, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 0x23, 0x90, 0x81, 0x05, 
+0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x20, 0xF0, 0x80, 0x10, 
+0x90, 0x81, 0xB2, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 0xF0, 0x80, 0x02, 0x80, 0x17, 
+0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x22, 
+0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x22, 
+0xE4, 0x75, 0xF0, 0x01, 0x02, 0x41, 0xF6, 0xE4, 0x90, 0x84, 0x32, 0xF0, 0xA3, 0xF0, 0x90, 0x02, 
+0x86, 0xE0, 0x20, 0xE1, 0x22, 0xC3, 0x90, 0x84, 0x33, 0xE0, 0x94, 0xD0, 0x90, 0x84, 0x32, 0xE0, 
+0x94, 0x07, 0x40, 0x0A, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x84, 
+0x32, 0x51, 0x90, 0x71, 0x13, 0x80, 0xD7, 0x7F, 0x01, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x84, 0x13, 0xEE, 0xF0, 0xA3, 0xEF, 0x12, 0x5F, 0x9E, 0x90, 0x84, 0x13, 0xE0, 0xFE, 
+0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 0xE0, 0x60, 0x23, 0xC3, 0x90, 0x84, 0x16, 0xE0, 0x94, 0xE8, 
+0x90, 0x84, 0x15, 0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 
+0x00, 0x80, 0x0B, 0x90, 0x84, 0x15, 0x51, 0x90, 0x71, 0x13, 0x80, 0xCF, 0x7F, 0x01, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x7F, 0x0A, 0x7E, 0x00, 0x02, 0x32, 0xAA, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 
+0x12, 0x46, 0x8D, 0x90, 0x83, 0x95, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x80, 0x01, 0xE0, 0xFF, 0x70, 
+0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 0xEF, 0x30, 0xE1, 0x09, 0x90, 0x80, 0x01, 0xE0, 0x54, 
+0xFD, 0xF0, 0x91, 0x2B, 0x71, 0x62, 0x30, 0xE2, 0x05, 0x54, 0xFB, 0xF0, 0x71, 0xC4, 0x71, 0x62, 
+0x30, 0xE4, 0x0B, 0x54, 0xEF, 0xF0, 0x51, 0x97, 0xBF, 0x01, 0x03, 0x12, 0x60, 0xA6, 0xD2, 0xAF, 
+0x80, 0xC8, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x80, 0x01, 0xE0, 0xFF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0x83, 0x96, 0x12, 0x42, 0x3A, 0x90, 0x84, 0x2B, 0xE0, 0xFF, 0x04, 0xF0, 
+0xB1, 0xC9, 0x7F, 0xAF, 0x7E, 0x01, 0x51, 0xCA, 0xEF, 0x60, 0x34, 0x90, 0x83, 0x96, 0x12, 0x4F, 
+0xEA, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 0x24, 0x02, 0xF5, 0x16, 0x7B, 0x01, 0x7A, 0x01, 0x79, 
+0xA0, 0x12, 0x2B, 0xED, 0x90, 0x83, 0x96, 0x12, 0x42, 0x31, 0x90, 0x00, 0x0E, 0x12, 0x1F, 0xBD, 
+0x90, 0x01, 0xAE, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0x90, 0x01, 0xCB, 0xE0, 0x64, 0x80, 0xF0, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 0x90, 0x80, 0xF7, 
+0xE0, 0xFE, 0x90, 0x80, 0xF6, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 
+0xEE, 0x64, 0x01, 0x60, 0x41, 0x90, 0x01, 0xAF, 0xE0, 0x70, 0x0A, 0xED, 0xB1, 0xDA, 0xFA, 0x7B, 
+0x01, 0x71, 0x6C, 0x7F, 0x01, 0xEF, 0x60, 0x2E, 0x90, 0x80, 0xF6, 0xB1, 0x8D, 0xB4, 0x0A, 0x02, 
+0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0xF6, 0xF0, 0x90, 0x80, 0xF7, 0xE0, 0xFF, 0x90, 
+0x80, 0xF6, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x07, 0x90, 
+0x80, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0x80, 0x5F, 0xE0, 0xFF, 0x90, 0x80, 0x5E, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 
+0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x3F, 0x90, 0x80, 0x5E, 0xE0, 0xFE, 0x75, 0xF0, 0x08, 0x90, 
+0x80, 0x0E, 0x12, 0x42, 0x25, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x0F, 0xF9, 0x74, 
+0x80, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x12, 0x54, 0x77, 0x90, 0x80, 0x5E, 0xB1, 0x8D, 
+0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0x5E, 0xF0, 0x91, 0x8B, 0x90, 
+0x80, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x01, 0xCC, 0xE0, 0x54, 
+0x0F, 0x90, 0x84, 0x2C, 0xF0, 0x90, 0x84, 0x2C, 0xE0, 0xFD, 0x70, 0x02, 0xA1, 0x84, 0x90, 0x80, 
+0x5E, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x80, 
+0x5F, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x08, 0x90, 0x01, 
+0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x84, 0x2A, 0xB1, 0xD0, 0x80, 0x05, 0xC3, 0x33, 0xCE, 
+0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0xA1, 0x66, 0xE4, 0x90, 0x84, 0x2D, 0xF0, 
+0x90, 0x84, 0x2D, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 0x31, 0xB1, 0x85, 0xA4, 0xFF, 0xE9, 0xFD, 
+0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 0xB1, 0xA4, 0x90, 0x80, 0x0E, 0xB1, 
+0x94, 0xB1, 0x85, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xF0, 0xB1, 0xA4, 0x90, 0x80, 
+0x12, 0xB1, 0x94, 0x90, 0x84, 0x2D, 0xE0, 0x04, 0xF0, 0x80, 0xC5, 0x90, 0x84, 0x2C, 0xE0, 0xFF, 
+0x90, 0x84, 0x2A, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
+0xF4, 0x5F, 0x90, 0x84, 0x2C, 0xF0, 0x90, 0x84, 0x2A, 0x12, 0x52, 0x53, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x84, 0x2A, 0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 
+0x90, 0x80, 0x5F, 0xB1, 0x8D, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x70, 0x02, 0x81, 0x95, 0xE4, 
+0x90, 0x80, 0x5F, 0xF0, 0x81, 0x95, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x84, 0x2A, 
+0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0xF0, 0xB1, 0x85, 0x90, 0x01, 0xD0, 0x12, 0x42, 0x25, 0xE0, 
+0x90, 0x01, 0xC3, 0xF0, 0x22, 0x90, 0x84, 0x2A, 0xE0, 0x75, 0xF0, 0x04, 0x22, 0xE0, 0x04, 0xF0, 
+0xE0, 0x7F, 0x00, 0x22, 0x12, 0x42, 0x25, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 
+0x83, 0xEF, 0xF0, 0x22, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x80, 
+0x5F, 0xE0, 0x75, 0xF0, 0x08, 0x22, 0x91, 0x8B, 0x7F, 0x02, 0x8F, 0x0D, 0x7F, 0x02, 0x12, 0x46, 
+0x66, 0x90, 0x80, 0x01, 0xE0, 0x45, 0x0D, 0xF0, 0x22, 0x90, 0x00, 0x01, 0xEF, 0x02, 0x1F, 0xFC, 
+0xE0, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x60, 
+0xF9, 0x74, 0x80, 0x35, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x80, 0xF6, 
+0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x80, 0xF7, 
+0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 
+0xE0, 0x44, 0x02, 0xF0, 0x80, 0x28, 0xC0, 0x01, 0x90, 0x80, 0xF7, 0xE0, 0xB1, 0xDA, 0xA8, 0x01, 
+0xFC, 0x7D, 0x01, 0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x41, 0xD0, 0x90, 0x80, 0xF7, 0xB1, 
+0x8D, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x80, 0xF7, 0xF0, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x81, 0xB3, 0xE0, 0x30, 0xE0, 0x04, 0x7F, 0x10, 0xB1, 0xBA, 0x22, 0x90, 
+0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 
+0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0x90, 0x01, 0xC4, 0x74, 0x68, 0xF0, 0x74, 0x6E, 
+0xA3, 0xF0, 0x90, 0x00, 0x90, 0xE0, 0x20, 0xE0, 0xF9, 0x74, 0x68, 0x04, 0x90, 0x01, 0xC4, 0xF0, 
+0x74, 0x6E, 0xA3, 0xF0, 0x22, 0xE4, 0x90, 0x83, 0x8E, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x00, 
+0x83, 0xE0, 0x90, 0x83, 0x8E, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 0x90, 0x83, 0x8E, 0xE0, 0xFF, 
+0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x83, 0x90, 0xE0, 0x94, 0x64, 0x90, 0x83, 0x8F, 0xE0, 0x94, 
+0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x83, 0x8E, 0xE0, 0xFF, 0x22, 
+0x90, 0x83, 0x8F, 0x51, 0x90, 0x80, 0xC7, 0xD1, 0x85, 0x90, 0x83, 0x8D, 0xEF, 0xF0, 0x30, 0xE0, 
+0x05, 0x7D, 0x01, 0xE4, 0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x4B, 0x2A, 0x90, 0x83, 0x8D, 0xE0, 
+0x30, 0xE6, 0x11, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 
+0x2F, 0x74, 0x80, 0xF0, 0x90, 0x81, 0x04, 0xE0, 0x90, 0x04, 0xEC, 0x30, 0xE0, 0x06, 0xE0, 0x54, 
+0xDD, 0xF0, 0x80, 0x04, 0xE0, 0x44, 0x22, 0xF0, 0xF1, 0x7A, 0x90, 0x81, 0x21, 0xE0, 0xFB, 0xAC, 
+0x07, 0x90, 0x81, 0x04, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x81, 0x3E, 0xE0, 0x24, 0x04, 0x90, 0x81, 
+0x1D, 0xF0, 0x90, 0x81, 0x3E, 0xE0, 0x24, 0x03, 0x90, 0x81, 0x1C, 0xF0, 0x80, 0x0B, 0x90, 0x81, 
+0x1D, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x1C, 0x14, 0xF0, 0x90, 0x81, 0x1C, 0xE0, 0xFA, 0x90, 0x81, 
+0x1B, 0xE0, 0xD3, 0x9A, 0x50, 0x09, 0x90, 0x81, 0x10, 0xEB, 0xF1, 0x72, 0x2C, 0x80, 0x0B, 0xAD, 
+0x02, 0xC3, 0xED, 0x9D, 0x2B, 0x90, 0x81, 0x10, 0xF1, 0x72, 0x90, 0x81, 0x20, 0xF0, 0x90, 0x81, 
+0x20, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0x81, 0x14, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x05, 0x58, 
+0xF0, 0x22, 0xF0, 0x90, 0x81, 0x1D, 0xE0, 0xC3, 0x9D, 0x22, 0x90, 0x81, 0x1A, 0xE0, 0xFF, 0xA3, 
+0xE0, 0xFD, 0x22, 0xE4, 0x90, 0x84, 0x2E, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 
+0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 
+0x90, 0x84, 0x2F, 0xE0, 0x94, 0xE8, 0x90, 0x84, 0x2E, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 
+0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x32, 0xAA, 0x90, 
+0x84, 0x2E, 0x51, 0x90, 0x80, 0xC4, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x5B, 0x6D, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0xE4, 0xF5, 0x52, 0x90, 0x81, 0xAD, 0xE0, 0xF5, 0x53, 0xE4, 
+0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8E, 0x4E, 0x8F, 
+0x4F, 0xE5, 0x53, 0x12, 0x70, 0x3F, 0x85, 0x4E, 0x83, 0x85, 0x4F, 0x82, 0xF0, 0xE5, 0x52, 0x11, 
+0x3F, 0xFF, 0xE5, 0x53, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0xA3, 0xF0, 0xEB, 0x11, 0x3F, 0xFF, 
+0xE5, 0x52, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x4F, 0x11, 0x46, 0xA3, 0xF0, 0xBD, 0x01, 0x0D, 0x85, 
+0x4F, 0x82, 0x8E, 0x83, 0xA3, 0xA3, 0xA3, 0x74, 0x03, 0xF0, 0x80, 0x07, 0x11, 0x46, 0xA3, 0xA3, 
+0x74, 0x01, 0xF0, 0x11, 0x46, 0xA3, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x54, 
+0x07, 0xC4, 0x33, 0x54, 0xE0, 0x22, 0x85, 0x4F, 0x82, 0x85, 0x4E, 0x83, 0xA3, 0x22, 0x11, 0x83, 
+0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x01, 
+0x3C, 0x74, 0x04, 0xF0, 0xE4, 0xF5, 0x52, 0x90, 0x81, 0xAE, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0xF5, 
+0x53, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x12, 0x6F, 0xE6, 0x90, 0x81, 0x04, 0xE0, 0x44, 
+0x08, 0xF0, 0x22, 0x90, 0x81, 0x04, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x90, 0x84, 0x34, 
+0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x46, 0x66, 0x90, 0x80, 0x01, 0xE0, 0xFF, 0x90, 0x84, 0x34, 0xE0, 
+0xFE, 0xEF, 0x4E, 0x90, 0x80, 0x01, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8B, 
+0x1A, 0x8A, 0x1B, 0x89, 0x1C, 0x12, 0x1F, 0xA4, 0xFF, 0x90, 0x81, 0x03, 0xF0, 0xBF, 0x01, 0x0D, 
+0x12, 0x53, 0x0A, 0x64, 0x01, 0x60, 0x19, 0x7D, 0x13, 0x7F, 0x6F, 0x80, 0x10, 0xAB, 0x1A, 0xAA, 
+0x1B, 0xA9, 0x1C, 0x12, 0x53, 0x0A, 0x64, 0x01, 0x60, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x4B, 0x1B, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x1F, 0xA4, 0x54, 0x01, 0xFF, 0x90, 0x83, 0x88, 0xE0, 0x54, 
+0xFE, 0x4F, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 0x81, 0x13, 0xF0, 0x22, 0x12, 0x1F, 0xA4, 0x90, 
+0x81, 0xB2, 0xF0, 0x22, 0xE4, 0x90, 0x80, 0xF6, 0xF0, 0xA3, 0xF0, 0x90, 0x80, 0x5E, 0xF0, 0xA3, 
+0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7D, 0x08, 0xED, 0x14, 0xF9, 0x24, 0xFA, 
+0x12, 0x5F, 0x86, 0xE0, 0x60, 0x3B, 0x7C, 0x08, 0xEC, 0x14, 0x90, 0x84, 0x35, 0xF0, 0x74, 0xFA, 
+0x29, 0x12, 0x5F, 0x86, 0xE0, 0xFB, 0x7A, 0x00, 0x90, 0x84, 0x35, 0x12, 0x6D, 0xD0, 0x80, 0x05, 
+0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 0x5B, 0x4E, 0x60, 0x0F, 
+0xE9, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x90, 0x84, 0x35, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 0x06, 0xDC, 
+0xC7, 0xDD, 0xB8, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x75, 0x3D, 0x10, 0xE4, 0xF5, 0x3E, 
+0x75, 0x3F, 0x07, 0x75, 0x40, 0x02, 0x90, 0x01, 0x30, 0xE5, 0x3D, 0xF0, 0xA3, 0xE5, 0x3E, 0xF0, 
+0xA3, 0xE5, 0x3F, 0xF0, 0xA3, 0xE5, 0x40, 0xF0, 0x22, 0x75, 0x45, 0x06, 0x75, 0x46, 0x01, 0x75, 
+0x47, 0x03, 0x75, 0x48, 0x62, 0x90, 0x01, 0x38, 0xE5, 0x45, 0xF0, 0xA3, 0xE5, 0x46, 0xF0, 0xA3, 
+0xE5, 0x47, 0xF0, 0xA3, 0xE5, 0x48, 0xF0, 0x22, 0x90, 0x00, 0x54, 0xE0, 0x55, 0x35, 0xF5, 0x39, 
+0xA3, 0xE0, 0x55, 0x36, 0xF5, 0x3A, 0xA3, 0xE0, 0x55, 0x37, 0xF5, 0x3B, 0xA3, 0xE0, 0x55, 0x38, 
+0xF5, 0x3C, 0xAD, 0x39, 0x7F, 0x54, 0x12, 0x32, 0x1E, 0xAD, 0x3A, 0x7F, 0x55, 0x12, 0x32, 0x1E, 
+0xAD, 0x3B, 0x7F, 0x56, 0x12, 0x32, 0x1E, 0xAD, 0x3C, 0x7F, 0x57, 0x12, 0x32, 0x1E, 0x53, 0x91, 
+0xEF, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x3D, 0xF5, 0x41, 0xA3, 0xE0, 0x55, 0x3E, 0xF5, 0x42, 
+0xA3, 0xE0, 0x55, 0x3F, 0xF5, 0x43, 0xA3, 0xE0, 0x55, 0x40, 0xF5, 0x44, 0x90, 0x01, 0x34, 0xE5, 
+0x41, 0xF0, 0xA3, 0xE5, 0x42, 0xF0, 0xA3, 0xE5, 0x43, 0xF0, 0xA3, 0xE5, 0x44, 0xF0, 0x22, 0x90, 
+0x01, 0x3C, 0xE0, 0x55, 0x45, 0xF5, 0x49, 0xA3, 0xE0, 0x55, 0x46, 0xF5, 0x4A, 0xA3, 0xE0, 0x55, 
+0x47, 0xF5, 0x4B, 0xA3, 0xE0, 0x55, 0x48, 0xF5, 0x4C, 0x90, 0x01, 0x3C, 0xE5, 0x49, 0xF0, 0xA3, 
+0xE5, 0x4A, 0xF0, 0xA3, 0xE5, 0x4B, 0xF0, 0xA3, 0xE5, 0x4C, 0xF0, 0x53, 0x91, 0xDF, 0x22, 0x90, 
+0x01, 0xCF, 0xE0, 0x90, 0x84, 0x37, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 
+0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 
+0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x60, 0x51, 0x90, 0x00, 0x03, 0xE0, 
+0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x32, 0x1E, 0x80, 0xFE, 0x22, 0x90, 0x81, 0x08, 0xE0, 0x60, 
+0x47, 0x90, 0x81, 0x04, 0xE0, 0x30, 0xE0, 0x17, 0x90, 0x81, 0x1F, 0xE0, 0x04, 0x91, 0xBF, 0xCE, 
+0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x81, 0x3F, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x71, 
+0x10, 0x30, 0xE0, 0x0D, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x06, 0x12, 0x59, 0x4B, 0x12, 0x5F, 
+0xD0, 0x90, 0x84, 0x36, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 
+0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0xD1, 0xF5, 0x51, 0xD2, 0xE4, 0x90, 0x83, 0x7A, 
+0xF0, 0x22, 0x90, 0x83, 0x77, 0xE0, 0x30, 0xE0, 0x36, 0x12, 0x4C, 0x5F, 0x64, 0x01, 0x70, 0x2F, 
+0x90, 0x84, 0x3C, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x0A, 0x0B, 0x90, 0x83, 0x79, 0xE0, 0x04, 0xF0, 
+0xE4, 0x90, 0x84, 0x3C, 0xF0, 0x90, 0x83, 0x79, 0xE0, 0xFF, 0x90, 0x83, 0x78, 0xE0, 0xD3, 0x9F, 
+0x50, 0x0D, 0x90, 0x83, 0x7A, 0xE0, 0x70, 0x07, 0xE4, 0x90, 0x83, 0x79, 0xF0, 0xD1, 0xBD, 0x22, 
+0x90, 0x81, 0x05, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x91, 0xC0, 0xCE, 0xC3, 0x13, 
+0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x83, 0x89, 0xEE, 0xF0, 0xA3, 0xEF, 0x12, 0x4C, 0x5E, 0x64, 
+0x01, 0x60, 0x02, 0x61, 0xB8, 0x90, 0x81, 0x08, 0xE0, 0x60, 0x7D, 0x71, 0xB9, 0x64, 0x01, 0x70, 
+0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x81, 0x0F, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 0x90, 0x81, 0x0E, 
+0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x81, 0x0E, 0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 0x81, 
+0x0F, 0xEF, 0xF0, 0x71, 0xC2, 0xD1, 0x49, 0xE4, 0x90, 0x81, 0x11, 0xD1, 0x62, 0xF0, 0xD1, 0x6C, 
+0xD1, 0x79, 0x54, 0xEF, 0xF0, 0x71, 0xB9, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x02, 0xB1, 0x42, 0x71, 
+0x10, 0x30, 0xE0, 0x34, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x2B, 0x90, 0x81, 0x0E, 
+0xE0, 0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x21, 0x90, 0x81, 0x05, 0xE0, 0x44, 0x40, 0xF0, 0xB1, 0x3A, 
+0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 0x03, 0xD1, 0x59, 0x12, 0x5F, 0xD0, 0x12, 
+0x59, 0x4B, 0x90, 0x81, 0x0F, 0xE0, 0x14, 0xF0, 0x22, 0x90, 0x81, 0x06, 0xE0, 0xFF, 0xC4, 0x54, 
+0x0F, 0x22, 0xE4, 0xFD, 0xF9, 0xFC, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFB, 
+0xEB, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xEE, 0x54, 0x3F, 0x90, 0x81, 
+0x41, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x81, 0x41, 0xE0, 0xFA, 
+0xA3, 0xE0, 0xFB, 0xC3, 0x9F, 0xEA, 0x9E, 0x40, 0x21, 0xEB, 0x9F, 0xFF, 0x90, 0x81, 0x20, 0xE0, 
+0xFE, 0xC3, 0x74, 0x0A, 0x9E, 0x2F, 0xF9, 0xC3, 0x94, 0x19, 0x50, 0x0E, 0x74, 0x25, 0x29, 0x91, 
+0xAF, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x1E, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x1E, 0xE0, 0xC3, 0x94, 
+0x64, 0x50, 0x02, 0x81, 0xAB, 0xE4, 0xFC, 0xFD, 0x91, 0xAC, 0xE0, 0x2C, 0xFC, 0xD3, 0x94, 0x05, 
+0x40, 0x07, 0x90, 0x83, 0x8B, 0xED, 0xF0, 0x80, 0x05, 0x0D, 0xED, 0xB4, 0x19, 0xEA, 0xE4, 0xFC, 
+0xFD, 0x91, 0xAC, 0xE0, 0x2C, 0xFC, 0xD3, 0x94, 0x5F, 0x40, 0x07, 0x90, 0x83, 0x8C, 0xED, 0xF0, 
+0x80, 0x05, 0x0D, 0xED, 0xB4, 0x19, 0xEA, 0x90, 0x83, 0x8B, 0xE0, 0x90, 0x81, 0x23, 0xF0, 0x90, 
+0x83, 0x8C, 0xE0, 0x90, 0x81, 0x24, 0x91, 0xB7, 0x94, 0x0B, 0x40, 0x0A, 0xEF, 0x24, 0xF6, 0x90, 
+0x81, 0x1B, 0xF0, 0xE4, 0x80, 0x09, 0xE4, 0x90, 0x81, 0x1B, 0x91, 0xB7, 0x74, 0x0A, 0x9F, 0x90, 
+0x81, 0x1A, 0xF0, 0x90, 0x81, 0x23, 0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x90, 0x81, 0x21, 0xF0, 
+0xC3, 0x94, 0x08, 0x50, 0x03, 0x74, 0x08, 0xF0, 0x90, 0x81, 0x1B, 0xE0, 0xFD, 0x90, 0x81, 0x21, 
+0xE0, 0xFB, 0xE4, 0xFF, 0x12, 0x6F, 0x0F, 0xE4, 0xFF, 0x91, 0xCE, 0x22, 0x74, 0x25, 0x2D, 0xF5, 
+0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0x22, 0xF0, 0x90, 0x81, 0x23, 0xE0, 0xFF, 0xC3, 0x22, 0xF0, 
+0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 0x02, 0x22, 0xE4, 0xFE, 
+0x74, 0x25, 0x2E, 0x91, 0xAF, 0xE4, 0xF0, 0x0E, 0xEE, 0xB4, 0x19, 0xF4, 0xE4, 0x90, 0x81, 0x1E, 
+0xF0, 0x90, 0x81, 0x22, 0xF0, 0x90, 0x81, 0x1A, 0xF0, 0xEF, 0xB4, 0x01, 0x09, 0x90, 0x81, 0x23, 
+0x74, 0x19, 0xF0, 0xE4, 0xA3, 0xF0, 0x22, 0xE4, 0x90, 0x83, 0x8D, 0xF0, 0x90, 0x81, 0x08, 0xE0, 
+0x60, 0x37, 0x12, 0x4C, 0x5F, 0x64, 0x01, 0x70, 0x30, 0xB1, 0x3A, 0x91, 0xBF, 0xCE, 0xC3, 0x13, 
+0xCE, 0x13, 0xD8, 0xF9, 0xD1, 0x82, 0x90, 0x83, 0x8D, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x81, 0x0F, 
+0xF0, 0x04, 0x60, 0x15, 0xD1, 0x51, 0xE4, 0xF5, 0x52, 0x90, 0x81, 0x10, 0x12, 0x6F, 0xDC, 0x90, 
+0x81, 0x0B, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x49, 0x0B, 0x22, 0x90, 0x81, 0x0E, 0xE0, 0x90, 0x05, 
+0x73, 0x22, 0xE4, 0xF5, 0x19, 0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x19, 0x54, 0xC0, 0x70, 0x08, 0xB1, 
+0x97, 0x54, 0xFD, 0xF0, 0x02, 0x5D, 0x9C, 0xE5, 0x19, 0x30, 0xE6, 0x1E, 0x90, 0x81, 0x08, 0xE0, 
+0x64, 0x01, 0x70, 0x18, 0x90, 0x81, 0x0C, 0xE0, 0x44, 0x01, 0x12, 0x57, 0xDC, 0x64, 0x02, 0x60, 
+0x04, 0xD1, 0xD7, 0x80, 0x07, 0x12, 0x4C, 0x89, 0x80, 0x02, 0xB1, 0x97, 0xE5, 0x19, 0x90, 0x81, 
+0x0C, 0x30, 0xE7, 0x0E, 0xE0, 0x44, 0x02, 0x12, 0x6F, 0xD5, 0x90, 0x81, 0x04, 0xE0, 0x44, 0x04, 
+0xF0, 0x22, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x81, 0x0C, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x7E, 
+0x00, 0x7F, 0xA8, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0x04, 0x12, 0x44, 0x13, 0x90, 0x81, 
+0x07, 0x74, 0x02, 0xF0, 0x90, 0x81, 0x0E, 0x14, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x90, 
+0x81, 0x14, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0xD1, 0x3A, 0xE4, 0xFD, 0xFF, 0x12, 0x4B, 0x2A, 
+0x7D, 0x0C, 0x7F, 0x02, 0x12, 0x4B, 0x2A, 0x12, 0x4B, 0x26, 0x90, 0x80, 0x06, 0xE0, 0xFF, 0xB4, 
+0x01, 0x08, 0x90, 0x81, 0x13, 0x74, 0x99, 0xF0, 0x80, 0x29, 0xEF, 0xB4, 0x03, 0x08, 0x90, 0x81, 
+0x13, 0x74, 0x90, 0xF0, 0x80, 0x1D, 0x90, 0x81, 0x13, 0x74, 0x40, 0xF0, 0x90, 0x00, 0x2C, 0xE0, 
+0x54, 0x0F, 0xFF, 0xBF, 0x05, 0x08, 0x90, 0x81, 0x3E, 0x74, 0x02, 0xF0, 0x80, 0x05, 0xE4, 0x90, 
+0x81, 0x3E, 0xF0, 0x12, 0x56, 0x6E, 0xD1, 0x3A, 0x7F, 0x01, 0x91, 0xCE, 0x7E, 0x00, 0x7F, 0x02, 
+0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x81, 0x79, 0xB0, 0x12, 0x44, 0x13, 0x12, 0x5F, 0xD6, 0x12, 0x5F, 
+0xDE, 0x12, 0x5A, 0xCD, 0xE4, 0x90, 0x81, 0xB2, 0xF0, 0x22, 0x90, 0x81, 0x3E, 0xE0, 0x24, 0x04, 
+0x90, 0x81, 0x20, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x22, 0x90, 0x81, 0x05, 0xE0, 0x44, 0x04, 0xF0, 
+0x22, 0x90, 0x81, 0x0C, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x74, 0x45, 0x2F, 0xF8, 0xE6, 0x4D, 0x02, 
+0x58, 0xCD, 0xF0, 0x90, 0x81, 0x14, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0x22, 0x90, 0x01, 0x57, 0xE4, 
+0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0x22, 0x54, 0xFB, 0xF0, 0x90, 0x81, 0x0C, 0xE0, 0x54, 0xFD, 
+0xF0, 0x22, 0xFF, 0xEE, 0x54, 0x3F, 0x90, 0x81, 0x43, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x90, 0x83, 
+0x81, 0xE0, 0x04, 0xF0, 0x90, 0x81, 0x0B, 0xE0, 0x64, 0x02, 0x60, 0x08, 0x71, 0x1B, 0x90, 0x01, 
+0xE6, 0xE0, 0x04, 0xF0, 0x22, 0xE4, 0xFF, 0x12, 0x4C, 0x65, 0xBF, 0x01, 0x0F, 0x90, 0x81, 0x08, 
+0xE0, 0x60, 0x09, 0xB1, 0x97, 0x54, 0x07, 0x70, 0x03, 0x12, 0x5D, 0x9C, 0x22, 0x90, 0x83, 0x77, 
+0x12, 0x5F, 0xC9, 0x30, 0xE0, 0x0E, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x00, 0x12, 0x67, 0xBD, 0x04, 
+0xF0, 0x02, 0x4E, 0x13, 0x02, 0x4C, 0x0B, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x17, 0x90, 0x80, 0x08, 
+0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 0x12, 0x4D, 0x91, 0x90, 0x83, 0x8B, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x12, 0x4F, 0xF4, 0x22, 0x90, 0x83, 0x7B, 0xE0, 0x30, 0xE0, 0x6C, 0x90, 0x83, 0x7F, 0xE0, 
+0x04, 0xF0, 0x90, 0x83, 0x82, 0xE0, 0x64, 0x01, 0x70, 0x21, 0x90, 0x83, 0x7B, 0xE0, 0x13, 0x13, 
+0x54, 0x3F, 0x30, 0xE0, 0x16, 0x90, 0x83, 0x81, 0xE0, 0x70, 0x10, 0x90, 0x83, 0x7E, 0xE0, 0xFF, 
+0xA3, 0xE0, 0xC3, 0x9F, 0x40, 0x05, 0x12, 0x5E, 0x87, 0xF0, 0x22, 0x90, 0x83, 0x7F, 0xE0, 0xFF, 
+0x90, 0x83, 0x7C, 0xE0, 0xD3, 0x9F, 0x50, 0x30, 0x90, 0x06, 0x92, 0xE0, 0x20, 0xE2, 0x1A, 0x90, 
+0x83, 0x81, 0xE0, 0x70, 0x14, 0x7D, 0x08, 0xFF, 0x12, 0x4C, 0x0F, 0x90, 0x83, 0x80, 0xE0, 0x04, 
+0xF0, 0x90, 0x83, 0x7A, 0xE0, 0x04, 0xF0, 0x80, 0x06, 0x90, 0x06, 0x92, 0x74, 0x04, 0xF0, 0xE4, 
+0x90, 0x83, 0x7F, 0xF0, 0x90, 0x83, 0x81, 0xF0, 0x22, 0x90, 0x81, 0x08, 0xE0, 0x60, 0x03, 0x12, 
+0x4B, 0x9D, 0x22, 0xC3, 0xEE, 0x94, 0x01, 0x40, 0x0A, 0x0D, 0xED, 0x13, 0x90, 0xFD, 0x10, 0xF0, 
+0xE4, 0x2F, 0xFF, 0x22, 0xC3, 0xEE, 0x94, 0x01, 0x40, 0x1E, 0x90, 0xFD, 0x11, 0xE0, 0xB5, 0x05, 
+0x14, 0x90, 0x01, 0x17, 0xE0, 0xB5, 0x05, 0x07, 0x90, 0xFD, 0x11, 0xE4, 0xF0, 0x80, 0x06, 0xED, 
+0x04, 0x90, 0xFD, 0x11, 0xF0, 0xE4, 0x2F, 0xFF, 0x22, 0xEF, 0x24, 0xFE, 0x60, 0x0B, 0x04, 0x70, 
+0x24, 0x90, 0x81, 0x0E, 0x74, 0x02, 0xF0, 0x80, 0x13, 0xED, 0x70, 0x06, 0x90, 0x81, 0xAF, 0xE0, 
+0x80, 0x02, 0xED, 0x14, 0x90, 0x81, 0x0E, 0xF0, 0x90, 0x81, 0x0E, 0xE0, 0xA3, 0xF0, 0x90, 0x81, 
+0x05, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x7D, 0x2E, 0x7F, 0x6F, 0x12, 0x4B, 0x1B, 0x7D, 0x02, 0x7F, 
+0x01, 0x02, 0x4B, 0x2A, 0x90, 0x84, 0x0E, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0x84, 0x3A, 0xEF, 0xF0, 0x90, 0x80, 0x09, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 
+0x3D, 0x90, 0x81, 0x0B, 0xE0, 0x64, 0x0E, 0x70, 0x15, 0x90, 0x84, 0x3A, 0xE0, 0x70, 0x2F, 0x90, 
+0x81, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x12, 0x5F, 0xD6, 0x12, 0x4B, 0x26, 0x80, 0x1D, 0x90, 0x81, 
+0x0B, 0xE0, 0x64, 0x06, 0x70, 0x18, 0x90, 0x84, 0x3A, 0xE0, 0x60, 0x12, 0x90, 0x81, 0x04, 0xE0, 
+0x54, 0xBF, 0xF0, 0x11, 0x43, 0x90, 0x81, 0x0B, 0x74, 0x04, 0xF0, 0x12, 0x5A, 0xCD, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0xF0, 0x22, 0xE4, 
+0xFE, 0xEF, 0xC3, 0x13, 0xFD, 0xEF, 0x30, 0xE0, 0x02, 0x7E, 0x80, 0x90, 0xFD, 0x10, 0xED, 0xF0, 
+0xAF, 0x06, 0x22, 0x11, 0x4F, 0x7E, 0x00, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFC, 0x12, 0x4F, 
+0x9D, 0x75, 0x16, 0x08, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x7F, 0x02, 0x2B, 0xED, 0x90, 0x02, 0x86, 
+0xE0, 0x20, 0xE2, 0x03, 0x7F, 0x04, 0x22, 0x90, 0x02, 0x86, 0xE0, 0x7F, 0x01, 0x20, 0xE1, 0x02, 
+0x7F, 0x02, 0x22, 0x90, 0x81, 0xBC, 0xE0, 0xFF, 0x20, 0xE0, 0x07, 0x90, 0x01, 0x3F, 0xE0, 0x30, 
+0xE2, 0x14, 0xEF, 0x44, 0x01, 0x90, 0x81, 0xBC, 0xF0, 0x90, 0x81, 0xB6, 0xE0, 0xC4, 0x54, 0x0F, 
+0x20, 0xE0, 0x03, 0x7F, 0x00, 0x22, 0x7F, 0x01, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0xEF, 0x20, 0xE0, 0x05, 0x90, 0x83, 0x65, 0x80, 0x03, 0x90, 0x83, 0x66, 0xE0, 0x90, 0x82, 0x88, 
+0xF0, 0x90, 0x82, 0x88, 0xE0, 0x14, 0x60, 0x13, 0x14, 0x60, 0x14, 0x24, 0xFE, 0x60, 0x10, 0x14, 
+0x60, 0x09, 0x14, 0x60, 0x06, 0x24, 0x06, 0xE4, 0xFE, 0x80, 0x06, 0x7E, 0x04, 0x80, 0x02, 0x7E, 
+0x08, 0xAF, 0x06, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xA3, 0xE0, 0xFE, 0x24, 0x20, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFF, 0x74, 0x21, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0xFD, 0x74, 0x24, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFE, 
+0xEF, 0x30, 0xE7, 0x04, 0x7C, 0x02, 0x80, 0x02, 0xE4, 0xFC, 0xED, 0x30, 0xE6, 0x08, 0xAF, 0x03, 
+0x11, 0xB9, 0xAE, 0x07, 0x80, 0x02, 0xE4, 0xFE, 0xEC, 0x24, 0x18, 0x2E, 0xFF, 0x22, 0x90, 0x02, 
+0x09, 0xE0, 0x90, 0x83, 0x9A, 0xF0, 0x12, 0x1F, 0xA4, 0x90, 0x83, 0x65, 0x12, 0x53, 0x09, 0x90, 
+0x83, 0x66, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFF, 0x12, 0x1F, 0xA4, 0xFE, 0xEF, 0x2E, 0x90, 
+0x83, 0x75, 0xF0, 0x22, 0xE4, 0xFF, 0x74, 0x18, 0x31, 0x8E, 0xFE, 0x74, 0xC3, 0x2F, 0xF5, 0x82, 
+0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEE, 0xF0, 0x74, 0x10, 0x31, 0x8E, 0xFE, 0x74, 0xBD, 0x2F, 0xF5, 
+0x82, 0xE4, 0x34, 0x81, 0xF5, 0x83, 0xEE, 0xF0, 0x0F, 0xEF, 0xB4, 0x06, 0xD9, 0x22, 0x2F, 0xF5, 
+0x82, 0xE4, 0x34, 0x06, 0xF5, 0x83, 0xE0, 0x22, 0xEF, 0x60, 0x08, 0x90, 0x83, 0x68, 0xE0, 0xFF, 
+0x12, 0x4F, 0x3D, 0x22, 0x7E, 0x00, 0x7F, 0x08, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x83, 0x79, 0x7B, 
+0x12, 0x44, 0x13, 0x90, 0x83, 0x7C, 0x74, 0x08, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0x22, 0x90, 0x02, 
+0x09, 0xE0, 0xFD, 0x12, 0x1F, 0xA4, 0xFE, 0xAF, 0x05, 0xED, 0x22, 0xE0, 0x90, 0x01, 0xBA, 0xF0, 
+0x90, 0x81, 0x0A, 0xE0, 0x90, 0x01, 0xBB, 0x22, 0x7B, 0x01, 0x7A, 0x82, 0x79, 0x7F, 0x90, 0x84, 
+0x0B, 0xE0, 0xFD, 0x22, 0x74, 0x11, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 
+0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 
+0xFE, 0xF0, 0xEF, 0x22, 0x90, 0x80, 0xF8, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x12, 0x1F, 0xEA, 0x90, 
+0x83, 0xE8, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xE4, 0xF5, 0x52, 0x90, 
+0x81, 0x11, 0xE0, 0x22, 0x12, 0x32, 0x1E, 0x90, 0x84, 0x31, 0xE0, 0x22, 0xA2, 0xB9, 
 };
-u4Byte ArrayLength_MP_8188E_FW_WoWLAN_T = 15690;
+u4Byte ArrayLength_MP_8188E_FW_WoWLAN = 14926;
 
 
 void
-ODM_ReadFirmware_MP_8188E_FW_WoWLAN_T(
+ODM_ReadFirmware_MP_8188E_FW_WoWLAN(
      IN   PDM_ODM_T    pDM_Odm,
      OUT  u1Byte       *pFirmware,
      OUT  u4Byte       *pFirmwareSize
 )
 {
-#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
-	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8188E_FW_WoWLAN_T;
+ #if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+     *((SIZE_PTR*)pFirmware) = (SIZE_PTR)Array_MP_8188E_FW_WoWLAN;
 #else
-	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8188E_FW_WoWLAN_T, ArrayLength_MP_8188E_FW_WoWLAN_T);
+     ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8188E_FW_WoWLAN, ArrayLength_MP_8188E_FW_WoWLAN);
 #endif
-	*pFirmwareSize = ArrayLength_MP_8188E_FW_WoWLAN_T;
+     *pFirmwareSize = ArrayLength_MP_8188E_FW_WoWLAN;
+
 }
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.h
index e43c8861877c..54422388c5c1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_FW.h
@@ -1,21 +1,21 @@
-/******************************************************************************
-*
-* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
-*
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of version 2 of the GNU General Public License as
-* published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful, but WITHOUT
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-* more details.
-*
-* You should have received a copy of the GNU General Public License along with
-* this program; if not, write to the Free Software Foundation, Inc.,
-* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
-*
-*
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
 ******************************************************************************/
 
 #if (RTL8188E_SUPPORT == 1)
@@ -35,44 +35,33 @@ ODM_ReadFirmware_MP_8188E_FW_AP(
 );
 
 /******************************************************************************
-*                           FW_NIC_S.TXT
-******************************************************************************/
-
-void
-ODM_ReadFirmware_MP_8188E_FW_NIC_S(
-     IN   PDM_ODM_T    pDM_Odm,
-     OUT  u1Byte       *pFirmware,
-     OUT  u4Byte       *pFirmwareSize
-);
-
-/******************************************************************************
-*                           FW_NIC_T.TXT
+*                           FW_NIC.TXT
 ******************************************************************************/
 
 void
-ODM_ReadFirmware_MP_8188E_FW_NIC_T(
+ODM_ReadFirmware_MP_8188E_FW_NIC(
      IN   PDM_ODM_T    pDM_Odm,
      OUT  u1Byte       *pFirmware,
      OUT  u4Byte       *pFirmwareSize
 );
 
 /******************************************************************************
-*                           FW_WoWLAN_S.TXT
+*                           FW_NIC_89EM.TXT
 ******************************************************************************/
 
 void
-ODM_ReadFirmware_MP_8188E_FW_WoWLAN_S(
+ODM_ReadFirmware_MP_8188E_FW_NIC_89EM(
      IN   PDM_ODM_T    pDM_Odm,
      OUT  u1Byte       *pFirmware,
      OUT  u4Byte       *pFirmwareSize
 );
 
 /******************************************************************************
-*                           FW_WoWLAN_T.TXT
+*                           FW_WoWLAN.TXT
 ******************************************************************************/
 
 void
-ODM_ReadFirmware_MP_8188E_FW_WoWLAN_T(
+ODM_ReadFirmware_MP_8188E_FW_WoWLAN(
      IN   PDM_ODM_T    pDM_Odm,
      OUT  u1Byte       *pFirmware,
      OUT  u4Byte       *pFirmwareSize
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.c
index 2c7509176e7e..9af9245bead2 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.c
@@ -18,43 +18,95 @@
 * 
 ******************************************************************************/
 
+#include "Mp_Precomp.h"
+#include "../phydm_precomp.h"
 
-#include "../odm_precomp.h"
-#ifdef CONFIG_IOL_IOREG_CFG
-#include <rtw_iol.h>
-#endif
 #if (RTL8188E_SUPPORT == 1)
 static BOOLEAN
-CheckCondition(
-    const u4Byte  Condition,
-    const u4Byte  Hex
+CheckPositive(
+    IN  PDM_ODM_T     pDM_Odm,
+    IN  const u4Byte  Condition1,
+    IN  const u4Byte  Condition2
     )
 {
-    u4Byte _board     = (Hex & 0x000000FF);
-    u4Byte _interface = (Hex & 0x0000FF00) >> 8;
-    u4Byte _platform  = (Hex & 0x00FF0000) >> 16;
-    u4Byte cond = Condition;
-
-    if ( Condition == 0xCDCDCDCD )
-        return TRUE;
-
-    cond = Condition & 0x000000FF;
-    if ( (_board != cond) && (cond != 0xFF) )
-        return FALSE;
-
-    cond = Condition & 0x0000FF00;
-    cond = cond >> 8;
-    if ( ((_interface & cond) == 0) && (cond != 0x07) )
-        return FALSE;
-
-    cond = Condition & 0x00FF0000;
-    cond = cond >> 16;
-    if ( ((_platform & cond) == 0) && (cond != 0x0F) )
+    u1Byte    _BoardType = ((pDM_Odm->BoardType & BIT4) >> 4) << 0 | // _GLNA
+                           ((pDM_Odm->BoardType & BIT3) >> 3) << 1 | // _GPA 
+                           ((pDM_Odm->BoardType & BIT7) >> 7) << 2 | // _ALNA
+                           ((pDM_Odm->BoardType & BIT6) >> 6) << 3 | // _APA 
+                           ((pDM_Odm->BoardType & BIT2) >> 2) << 4;  // _BT  
+
+	u4Byte 	  cond1   = Condition1, cond2 = Condition2;
+	u4Byte    driver1 = pDM_Odm->CutVersion       << 24 |  
+		                pDM_Odm->SupportPlatform  << 16 | 
+		                pDM_Odm->PackageType      << 12 | 
+		                pDM_Odm->SupportInterface << 8  |
+		                _BoardType;
+
+	u4Byte    driver2 = pDM_Odm->TypeGLNA <<  0 |  
+		                pDM_Odm->TypeGPA  <<  8 | 
+		                pDM_Odm->TypeALNA << 16 | 
+		                pDM_Odm->TypeAPA  << 24; 
+
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("===> [8812A] CheckPositive (cond1, cond2) = (0x%X 0x%X)\n", cond1, cond2));
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("===> [8812A] CheckPositive (driver1, driver2) = (0x%X 0x%X)\n", driver1, driver2));
+
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("	(Platform, Interface) = (0x%X, 0x%X)\n", pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface));
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("	(Board, Package) = (0x%X, 0x%X)\n", pDM_Odm->BoardType, pDM_Odm->PackageType));
+
+
+	//============== Value Defined Check ===============//
+	//QFN Type [15:12] and Cut Version [27:24] need to do value check
+	
+	if(((cond1 & 0x0000F000) != 0) &&((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return FALSE;
+	if(((cond1 & 0x0F000000) != 0) &&((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return FALSE;		
+
+	//=============== Bit Defined Check ================//
+    // We don't care [31:28] and [23:20]
+    //
+	cond1   &= 0x000F0FFF; 
+	driver1 &= 0x000F0FFF; 
+
+    if ((cond1 & driver1) == cond1) 
+    {
+        u4Byte bitMask = 0;
+        if ((cond1 & 0x0F) == 0) // BoardType is DONTCARE
+            return TRUE;
+
+        if ((cond1 & BIT0) != 0) //GLNA
+            bitMask |= 0x000000FF;
+        if ((cond1 & BIT1) != 0) //GPA
+            bitMask |= 0x0000FF00;
+        if ((cond1 & BIT2) != 0) //ALNA
+            bitMask |= 0x00FF0000;
+        if ((cond1 & BIT3) != 0) //APA
+            bitMask |= 0xFF000000;
+
+        if ((cond2 & bitMask) == (driver2 & bitMask)) // BoardType of each RF path is matched
+            return TRUE;
+        else
+            return FALSE;
+    }
+    else 
+    {
         return FALSE;
+    }
+}
+static BOOLEAN
+CheckNegative(
+    IN  PDM_ODM_T     pDM_Odm,
+    IN  const u4Byte  Condition1,
+    IN  const u4Byte  Condition2
+    )
+{
     return TRUE;
 }
 
-
 /******************************************************************************
 *                           MAC_REG.TXT
 ******************************************************************************/
@@ -62,11 +114,13 @@ CheckCondition(
 u4Byte Array_MP_8188E_MAC_REG[] = { 
 		0x026, 0x00000041,
 		0x027, 0x00000035,
-	0xFF0F0718, 0xABCD,
+	0x80000003,0x00000000,0x40000000,0x00000000,
+		0x040, 0x0000000C,
+	0x90000001,0x00000000,0x40000000,0x00000000,
 		0x040, 0x0000000C,
-	0xCDCDCDCD, 0xCDCD,
+	0xA0000000,0x00000000,
 		0x040, 0x00000000,
-	0xFF0F0718, 0xDEAD,
+	0xB0000000,0x00000000,
 		0x428, 0x0000000A,
 		0x429, 0x00000010,
 		0x430, 0x00000000,
@@ -158,450 +212,75 @@ u4Byte Array_MP_8188E_MAC_REG[] = {
 
 };
 
-HAL_STATUS
+void
 ODM_ReadAndConfig_MP_8188E_MAC_REG(
  	IN   PDM_ODM_T  pDM_Odm
  	)
 {
-	#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
-
-	u4Byte     hex         = 0;
-	u4Byte     i           = 0;
-	u2Byte     count       = 0;
-	pu4Byte    ptr_array   = NULL;
-	u1Byte     platform    = pDM_Odm->SupportPlatform;
-	u1Byte     _interface   = pDM_Odm->SupportInterface;
-	u1Byte     board       = pDM_Odm->BoardType;  
-	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_MAC_REG)/sizeof(u4Byte);
-	pu4Byte    Array       = Array_MP_8188E_MAC_REG;
-	BOOLEAN		biol = FALSE;	
+    u4Byte     i         = 0;
+    u1Byte     cCond;
+    BOOLEAN bMatched = TRUE, bSkipped = FALSE;
+//ask by Luke.Lee
+    u4Byte     ArrayLen    = sizeof(Array_MP_8188E_MAC_REG)/sizeof(u4Byte);
+    pu4Byte    Array       = Array_MP_8188E_MAC_REG;
 	
-#ifdef CONFIG_IOL_IOREG_CFG 
-	PADAPTER	Adapter =  pDM_Odm->Adapter;	
-	struct xmit_frame	*pxmit_frame;	
-	u8 bndy_cnt = 1;
-	#ifdef CONFIG_IOL_IOREG_CFG_DBG
-	struct cmd_cmp cmpdata[ArrayLen];
-	u4Byte	cmpdata_idx=0;
-	#endif
-#endif //CONFIG_IOL_IOREG_CFG
-	HAL_STATUS rst =HAL_STATUS_SUCCESS;
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8188E_MAC_REG\n"));
 
-	hex += board;
-	hex += _interface << 8;
-	hex += platform << 16;
-	hex += 0xFF000000;
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_8188E_MAC_REG, hex = 0x%X\n", hex));
+	while(( i+1) < ArrayLen)
+	{
+		u4Byte v1 = Array[i];
+		u4Byte v2 = Array[i+1];
 
-#ifdef CONFIG_IOL_IOREG_CFG 			
-	biol = rtw_IOL_applied(Adapter);
-	
-	if(biol){		
-		if((pxmit_frame=rtw_IOL_accquire_xmit_frame(Adapter)) == NULL)
+		if(v1 & (BIT31|BIT30)) //positive & negative condition
 		{
-			printk("rtw_IOL_accquire_xmit_frame failed\n");
-			return HAL_STATUS_FAILURE;
-		}
-	}
-	
-#endif //CONFIG_IOL_IOREG_CFG
-	for (i = 0; i < ArrayLen; i += 2 )
-	{
-	    u4Byte v1 = Array[i];
-	    u4Byte v2 = Array[i+1];
-	
-	    // This (offset, data) pair meets the condition.
-	    if ( v1 < 0xCDCDCDCD )
-	    {
-			#ifdef CONFIG_IOL_IOREG_CFG
-				
-			if(biol){	
-					
-				if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-					bndy_cnt++;
-				rtw_IOL_append_WB_cmd(pxmit_frame,(u2Byte)v1, (u1Byte)v2,0xFF);
-				#ifdef CONFIG_IOL_IOREG_CFG_DBG
-					cmpdata[cmpdata_idx].addr = v1;
-					cmpdata[cmpdata_idx].value= v2;
-					cmpdata_idx++;
-				#endif					
-	 		}
-			else
-			#endif	//endif CONFIG_IOL_IOREG_CFG
+			if(v1 & BIT31) // positive condition
 			{
-	 			odm_ConfigMAC_8188E(pDM_Odm, v1, (u1Byte)v2);
-			}
-		    continue;
-	 	}
-		else
-		{ // This line is the start line of branch.
-		    if ( !CheckCondition(Array[i], hex) )
-		    { // Discard the following (offset, data) pairs.
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        i -= 2; // prevent from for-loop += 2
-		    }
-		    else // Configure matched pairs and skip to end of if-else.
-		    {
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-					#ifdef CONFIG_IOL_IOREG_CFG 
-	 				if(biol){	
-						if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-							bndy_cnt++;
-						rtw_IOL_append_WB_cmd(pxmit_frame,(u2Byte)v1, (u1Byte)v2,0xFF);
-						#ifdef CONFIG_IOL_IOREG_CFG_DBG
-							cmpdata[cmpdata_idx].addr = v1;
-							cmpdata[cmpdata_idx].value= v2;
-							cmpdata_idx++;
-						#endif
-	 				}
+				cCond  = (u1Byte)((v1 & (BIT29|BIT28)) >> 28);
+				if(cCond == COND_ENDIF) //end
+				{
+					bMatched = TRUE;
+					bSkipped = FALSE;
+				}
+				else if(cCond == COND_ELSE) //else
+				{
+					bMatched = bSkipped?FALSE:TRUE;
+				}
+				else //if , else if
+				{
+					if(bSkipped)
+						bMatched = FALSE;
 					else
-					#endif //#ifdef CONFIG_IOL_IOREG_CFG
 					{
-	 					odm_ConfigMAC_8188E(pDM_Odm, v1, (u1Byte)v2);
+						if(CheckPositive(pDM_Odm, v1, v2))
+						{
+							bMatched = TRUE;
+							bSkipped = TRUE;
+						}
+						else
+						{
+							bMatched = FALSE;
+							bSkipped = FALSE;
+						}
 					}
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-
-		        while (v2 != 0xDEAD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        
-		    }
-		}	
-	}
-
-#ifdef CONFIG_IOL_IOREG_CFG 
-	if(biol){
-		//printk("==> %s, pktlen = %d,bndy_cnt = %d\n",__FUNCTION__,pxmit_frame->attrib.pktlen+4+32,bndy_cnt);		
-		
-		if(rtw_IOL_exec_cmds_sync(pDM_Odm->Adapter, pxmit_frame, 1000, bndy_cnt))
-		{			
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG			
-			printk("~~~ IOL Config MAC Success !!! \n");
-			//compare writed data
-			{
-				u4Byte idx;
-				u1Byte cdata;
-				// HAL_STATUS_FAILURE;
-				printk("  MAC data compare => array_len:%d \n",cmpdata_idx);
-				for(idx=0;idx< cmpdata_idx;idx++)
-				{
-					cdata = ODM_Read1Byte(pDM_Odm, cmpdata[idx].addr);
-					if(cdata != cmpdata[idx].value){
-						printk("### MAC data compared failed !! addr:0x%04x, data:(0x%02x : 0x%02x) ###\n",
-							cmpdata[idx].addr,cmpdata[idx].value,cdata);
-						//rst = HAL_STATUS_FAILURE;
-					}					
-				}	
-
-
-				//dump data from TX packet buffer
-				//if(rst == HAL_STATUS_FAILURE)
-				{
-					rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
-				}	
-				
+				}
 			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-		
-		}
-		else{
-			printk("~~~ MAC IOL_exec_cmds Failed !!! \n");
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			{
-				//dump data from TX packet buffer				
-				rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
+			else if(v1 & BIT30){ //negative condition
+			//do nothing
 			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-			rst = HAL_STATUS_FAILURE;			
 		}
-		
-	}
-#endif	//#ifdef CONFIG_IOL_IOREG_CFG 
-	return rst;
-}
-
-/******************************************************************************
-*                           MAC_REG_ICUT.TXT
-******************************************************************************/
-
-u4Byte Array_MP_8188E_MAC_REG_ICUT[] = { 
-		0x026, 0x00000041,
-		0x027, 0x00000035,
-		0x428, 0x0000000A,
-		0x429, 0x00000010,
-		0x430, 0x00000000,
-		0x431, 0x00000001,
-		0x432, 0x00000002,
-		0x433, 0x00000004,
-		0x434, 0x00000005,
-		0x435, 0x00000006,
-		0x436, 0x00000007,
-		0x437, 0x00000008,
-		0x438, 0x00000000,
-		0x439, 0x00000000,
-		0x43A, 0x00000001,
-		0x43B, 0x00000002,
-		0x43C, 0x00000004,
-		0x43D, 0x00000005,
-		0x43E, 0x00000006,
-		0x43F, 0x00000007,
-		0x440, 0x0000005D,
-		0x441, 0x00000001,
-		0x442, 0x00000000,
-		0x444, 0x00000015,
-		0x445, 0x000000F0,
-		0x446, 0x0000000F,
-		0x447, 0x00000000,
-		0x458, 0x00000041,
-		0x459, 0x000000A8,
-		0x45A, 0x00000072,
-		0x45B, 0x000000B9,
-		0x460, 0x00000066,
-		0x461, 0x00000066,
-		0x480, 0x00000008,
-		0x4C8, 0x000000FF,
-		0x4C9, 0x00000008,
-		0x4CC, 0x000000FF,
-		0x4CD, 0x000000FF,
-		0x4CE, 0x00000001,
-		0x4D3, 0x00000001,
-		0x500, 0x00000026,
-		0x501, 0x000000A2,
-		0x502, 0x0000002F,
-		0x503, 0x00000000,
-		0x504, 0x00000028,
-		0x505, 0x000000A3,
-		0x506, 0x0000005E,
-		0x507, 0x00000000,
-		0x508, 0x0000002B,
-		0x509, 0x000000A4,
-		0x50A, 0x0000005E,
-		0x50B, 0x00000000,
-		0x50C, 0x0000004F,
-		0x50D, 0x000000A4,
-		0x50E, 0x00000000,
-		0x50F, 0x00000000,
-		0x512, 0x0000001C,
-		0x514, 0x0000000A,
-		0x516, 0x0000000A,
-		0x525, 0x0000004F,
-		0x550, 0x00000010,
-		0x551, 0x00000010,
-		0x559, 0x00000002,
-		0x55D, 0x000000FF,
-		0x605, 0x00000030,
-		0x608, 0x0000000E,
-		0x609, 0x0000002A,
-		0x620, 0x000000FF,
-		0x621, 0x000000FF,
-		0x622, 0x000000FF,
-		0x623, 0x000000FF,
-		0x624, 0x000000FF,
-		0x625, 0x000000FF,
-		0x626, 0x000000FF,
-		0x627, 0x000000FF,
-		0x652, 0x00000020,
-		0x63C, 0x0000000A,
-		0x63D, 0x0000000A,
-		0x63E, 0x0000000E,
-		0x63F, 0x0000000E,
-		0x640, 0x00000040,
-		0x66E, 0x00000005,
-		0x700, 0x00000021,
-		0x701, 0x00000043,
-		0x702, 0x00000065,
-		0x703, 0x00000087,
-		0x708, 0x00000021,
-		0x709, 0x00000043,
-		0x70A, 0x00000065,
-		0x70B, 0x00000087,
-
-};
-
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_MAC_REG_ICUT(
- 	IN   PDM_ODM_T  pDM_Odm
- 	)
-{
-	#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
-
-	u4Byte     hex         = 0;
-	u4Byte     i           = 0;
-	u2Byte     count       = 0;
-	pu4Byte    ptr_array   = NULL;
-	u1Byte     platform    = pDM_Odm->SupportPlatform;
-	u1Byte     _interface   = pDM_Odm->SupportInterface;
-	u1Byte     board       = pDM_Odm->BoardType;  
-	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_MAC_REG_ICUT)/sizeof(u4Byte);
-	pu4Byte    Array       = Array_MP_8188E_MAC_REG_ICUT;
-	BOOLEAN		biol = FALSE;
-
-#ifdef CONFIG_IOL_IOREG_CFG 
-	PADAPTER	Adapter =  pDM_Odm->Adapter;	
-	struct xmit_frame	*pxmit_frame;	
-	u8 bndy_cnt = 1;
-	#ifdef CONFIG_IOL_IOREG_CFG_DBG
-	struct cmd_cmp cmpdata[ArrayLen];
-	u4Byte	cmpdata_idx=0;
-	#endif
-#endif //CONFIG_IOL_IOREG_CFG
-	HAL_STATUS rst =HAL_STATUS_SUCCESS;
-
-	hex += board;
-	hex += _interface << 8;
-	hex += platform << 16;
-	hex += 0xFF000000;
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_8188E_MAC_REG_ICUT, hex = 0x%X\n", hex));
-
-#ifdef CONFIG_IOL_IOREG_CFG 			
-	biol = rtw_IOL_applied(Adapter);
-	
-	if(biol){		
-		if((pxmit_frame=rtw_IOL_accquire_xmit_frame(Adapter)) == NULL)
+		else
 		{
-			printk("rtw_IOL_accquire_xmit_frame failed\n");
-			return HAL_STATUS_FAILURE;
+			if(bMatched)
+			odm_ConfigMAC_8188E(pDM_Odm, v1, (u1Byte)v2);
 		}
+	i = i + 2;
 	}
-	
-#endif //CONFIG_IOL_IOREG_CFG
-	for (i = 0; i < ArrayLen; i += 2 )
-	{
-	    u4Byte v1 = Array[i];
-	    u4Byte v2 = Array[i+1];
-	
-	    // This (offset, data) pair meets the condition.
-	    if ( v1 < 0xCDCDCDCD )
-	    {
-			#ifdef CONFIG_IOL_IOREG_CFG
-				
-			if(biol){	
-					
-				if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-					bndy_cnt++;
-				rtw_IOL_append_WB_cmd(pxmit_frame,(u2Byte)v1, (u1Byte)v2,0xFF);
-				#ifdef CONFIG_IOL_IOREG_CFG_DBG
-					cmpdata[cmpdata_idx].addr = v1;
-					cmpdata[cmpdata_idx].value= v2;
-					cmpdata_idx++;
-				#endif					
-	 		}
-			else
-			#endif	//endif CONFIG_IOL_IOREG_CFG
-			{
-	 			odm_ConfigMAC_8188E(pDM_Odm, v1, (u1Byte)v2);
-			}
-		    continue;
-	 	}
-		else
-		{ // This line is the start line of branch.
-		    if ( !CheckCondition(Array[i], hex) )
-		    { // Discard the following (offset, data) pairs.
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        i -= 2; // prevent from for-loop += 2
-		    }
-		    else // Configure matched pairs and skip to end of if-else.
-		    {
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-					#ifdef CONFIG_IOL_IOREG_CFG 
-	 				if(biol){	
-						if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-							bndy_cnt++;
-						rtw_IOL_append_WB_cmd(pxmit_frame,(u2Byte)v1, (u1Byte)v2,0xFF);
-						#ifdef CONFIG_IOL_IOREG_CFG_DBG
-							cmpdata[cmpdata_idx].addr = v1;
-							cmpdata[cmpdata_idx].value= v2;
-							cmpdata_idx++;
-						#endif
-	 				}
-					else
-					#endif //#ifdef CONFIG_IOL_IOREG_CFG
-					{
-	 					odm_ConfigMAC_8188E(pDM_Odm, v1, (u1Byte)v2);
-					}
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-
-		        while (v2 != 0xDEAD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        
-		    }
-		}	
-	}
-
-#ifdef CONFIG_IOL_IOREG_CFG 
-	if(biol){
-		//printk("==> %s, pktlen = %d,bndy_cnt = %d\n",__FUNCTION__,pxmit_frame->attrib.pktlen+4+32,bndy_cnt);		
-		
-		if(rtw_IOL_exec_cmds_sync(pDM_Odm->Adapter, pxmit_frame, 1000, bndy_cnt))
-		{			
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG			
-			printk("~~~ IOL Config MAC Success !!! \n");
-			//compare writed data
-			{
-				u4Byte idx;
-				u1Byte cdata;
-				// HAL_STATUS_FAILURE;
-				printk("  MAC data compare => array_len:%d \n",cmpdata_idx);
-				for(idx=0;idx< cmpdata_idx;idx++)
-				{
-					cdata = ODM_Read1Byte(pDM_Odm, cmpdata[idx].addr);
-					if(cdata != cmpdata[idx].value){
-						printk("### MAC data compared failed !! addr:0x%04x, data:(0x%02x : 0x%02x) ###\n",
-							cmpdata[idx].addr,cmpdata[idx].value,cdata);
-						//rst = HAL_STATUS_FAILURE;
-					}					
-				}	
-
+}
 
-				//dump data from TX packet buffer
-				//if(rst == HAL_STATUS_FAILURE)
-				{
-					rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
-				}	
-				
-			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-		
-		}
-		else{
-			printk("~~~ MAC IOL_exec_cmds Failed !!! \n");
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			{
-				//dump data from TX packet buffer				
-				rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
-			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-			rst = HAL_STATUS_FAILURE;			
-		}
-		
-	}
-#endif	//#ifdef CONFIG_IOL_IOREG_CFG 
-	return rst;
+u4Byte
+ODM_GetVersion_MP_8188E_MAC_REG(void)
+{
+	   return 53;
 }
 
 #endif // end of HWIMG_SUPPORT
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.h
index e6b6d8e6d354..a138ffd46e6e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_MAC.h
@@ -22,25 +22,16 @@
 #ifndef __INC_MP_MAC_HW_IMG_8188E_H
 #define __INC_MP_MAC_HW_IMG_8188E_H
 
-//static BOOLEAN CheckCondition(const u4Byte Condition, const u4Byte Hex);
 
 /******************************************************************************
 *                           MAC_REG.TXT
 ******************************************************************************/
 
-HAL_STATUS
+void
 ODM_ReadAndConfig_MP_8188E_MAC_REG( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
-
-/******************************************************************************
-*                           MAC_REG_ICUT.TXT
-******************************************************************************/
-
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_MAC_REG_ICUT( // TC: Test Chip, MP: MP Chip
-	IN   PDM_ODM_T  pDM_Odm
-);
+u4Byte ODM_GetVersion_MP_8188E_MAC_REG(void);
 
 #endif
 #endif // end of HWIMG_SUPPORT
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.c
index f4c32e5d7ba8..72e8c551b856 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.c
@@ -18,58 +18,137 @@
 * 
 ******************************************************************************/
 
-
-#include "../odm_precomp.h"
-
-#ifdef CONFIG_IOL_IOREG_CFG
-#include <rtw_iol.h>
-#endif
+#include "Mp_Precomp.h"
+#include "../phydm_precomp.h"
 
 #if (RTL8188E_SUPPORT == 1)
 static BOOLEAN
-CheckCondition(
-    const u4Byte  Condition,
-    const u4Byte  Hex
+CheckPositive(
+    IN  PDM_ODM_T     pDM_Odm,
+    IN  const u4Byte  Condition1,
+    IN  const u4Byte  Condition2
     )
 {
-    u4Byte _board     = (Hex & 0x000000FF);
-    u4Byte _interface = (Hex & 0x0000FF00) >> 8;
-    u4Byte _platform  = (Hex & 0x00FF0000) >> 16;
-    u4Byte cond = Condition;
+    u1Byte    _BoardType = ((pDM_Odm->BoardType & BIT4) >> 4) << 0 | // _GLNA
+                           ((pDM_Odm->BoardType & BIT3) >> 3) << 1 | // _GPA 
+                           ((pDM_Odm->BoardType & BIT7) >> 7) << 2 | // _ALNA
+                           ((pDM_Odm->BoardType & BIT6) >> 6) << 3 | // _APA 
+                           ((pDM_Odm->BoardType & BIT2) >> 2) << 4;  // _BT  
 
-    if ( Condition == 0xCDCDCDCD )
-        return TRUE;
+	u4Byte 	  cond1   = Condition1, cond2 = Condition2;
+	u4Byte    driver1 = pDM_Odm->CutVersion       << 24 |  
+		                pDM_Odm->SupportPlatform  << 16 | 
+		                pDM_Odm->PackageType      << 12 | 
+		                pDM_Odm->SupportInterface << 8  |
+		                _BoardType;
 
-    cond = Condition & 0x000000FF;
-    if ( (_board != cond) && (cond != 0xFF) )
-        return FALSE;
+	u4Byte    driver2 = pDM_Odm->TypeGLNA <<  0 |  
+		                pDM_Odm->TypeGPA  <<  8 | 
+		                pDM_Odm->TypeALNA << 16 | 
+		                pDM_Odm->TypeAPA  << 24; 
+
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("===> [8812A] CheckPositive (cond1, cond2) = (0x%X 0x%X)\n", cond1, cond2));
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("===> [8812A] CheckPositive (driver1, driver2) = (0x%X 0x%X)\n", driver1, driver2));
+
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("	(Platform, Interface) = (0x%X, 0x%X)\n", pDM_Odm->SupportPlatform, pDM_Odm->SupportInterface));
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, 
+                ("	(Board, Package) = (0x%X, 0x%X)\n", pDM_Odm->BoardType, pDM_Odm->PackageType));
 
-    cond = Condition & 0x0000FF00;
-    cond = cond >> 8;
-    if ( ((_interface & cond) == 0) && (cond != 0x07) )
-        return FALSE;
 
-    cond = Condition & 0x00FF0000;
-    cond = cond >> 16;
-    if ( ((_platform & cond) == 0) && (cond != 0x0F) )
+	//============== Value Defined Check ===============//
+	//QFN Type [15:12] and Cut Version [27:24] need to do value check
+	
+	if(((cond1 & 0x0000F000) != 0) &&((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return FALSE;
+	if(((cond1 & 0x0F000000) != 0) &&((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return FALSE;		
+
+	//=============== Bit Defined Check ================//
+    // We don't care [31:28] and [23:20]
+    //
+	cond1   &= 0x000F0FFF; 
+	driver1 &= 0x000F0FFF; 
+
+    if ((cond1 & driver1) == cond1) 
+    {
+        u4Byte bitMask = 0;
+        if ((cond1 & 0x0F) == 0) // BoardType is DONTCARE
+            return TRUE;
+
+        if ((cond1 & BIT0) != 0) //GLNA
+            bitMask |= 0x000000FF;
+        if ((cond1 & BIT1) != 0) //GPA
+            bitMask |= 0x0000FF00;
+        if ((cond1 & BIT2) != 0) //ALNA
+            bitMask |= 0x00FF0000;
+        if ((cond1 & BIT3) != 0) //APA
+            bitMask |= 0xFF000000;
+
+        if ((cond2 & bitMask) == (driver2 & bitMask)) // BoardType of each RF path is matched
+            return TRUE;
+        else
+            return FALSE;
+    }
+    else 
+    {
         return FALSE;
+    }
+}
+static BOOLEAN
+CheckNegative(
+    IN  PDM_ODM_T     pDM_Odm,
+    IN  const u4Byte  Condition1,
+    IN  const u4Byte  Condition2
+    )
+{
     return TRUE;
 }
 
-
 /******************************************************************************
-*                           RadioA_1T.TXT
+*                           RadioA.TXT
 ******************************************************************************/
 
-u4Byte Array_MP_8188E_RadioA_1T[] = { 
+u4Byte Array_MP_8188E_RadioA[] = { 
 		0x000, 0x00030000,
 		0x008, 0x00084000,
 		0x018, 0x00000407,
 		0x019, 0x00000012,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0x01B, 0x00000084,
+	0x98000001,0x00000000,0x40000000,0x00000000,
+		0x01B, 0x00000084,
+	0x98000400,0x00000000,0x40000000,0x00000000,
+		0x01B, 0x00000084,
+	0x90000003,0x00000000,0x40000000,0x00000000,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+	0x98000000,0x00000000,0x40000000,0x00000000,
+		0x01B, 0x00000084,
+	0x90000400,0x00000000,0x40000000,0x00000000,
+	0xA0000000,0x00000000,
+	0xB0000000,0x00000000,
 		0x01E, 0x00080009,
 		0x01F, 0x00000880,
 		0x02F, 0x0001A060,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0x03F, 0x000C0000,
+	0x98000001,0x00000000,0x40000000,0x00000000,
+		0x03F, 0x000C0000,
+	0x98000400,0x00000000,0x40000000,0x00000000,
+		0x03F, 0x000C0000,
+	0x90000003,0x00000000,0x40000000,0x00000000,
+		0x03F, 0x00000000,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0x03F, 0x00000000,
+	0x98000000,0x00000000,0x40000000,0x00000000,
+		0x03F, 0x000C0000,
+	0x90000400,0x00000000,0x40000000,0x00000000,
+		0x03F, 0x00000000,
+	0xA0000000,0x00000000,
 		0x03F, 0x00000000,
+	0xB0000000,0x00000000,
 		0x042, 0x000060C0,
 		0x057, 0x000D0000,
 		0x058, 0x000BE180,
@@ -98,11 +177,23 @@ u4Byte Array_MP_8188E_RadioA_1T[] = {
 		0x0DF, 0x00000180,
 		0x0EF, 0x000001A0,
 		0x051, 0x0006B27D,
-	0xFF0F0400, 0xABCD,
+	0x88000003,0x00000000,0x40000000,0x00000000,
+		0x052, 0x0007E49D,
+	0x98000001,0x00000000,0x40000000,0x00000000,
+		0x052, 0x0007E49D,
+	0x98000400,0x00000000,0x40000000,0x00000000,
+		0x052, 0x0007E4DD,
+	0x90000003,0x00000000,0x40000000,0x00000000,
+		0x052, 0x0007E49D,
+	0x90000001,0x00000000,0x40000000,0x00000000,
+		0x052, 0x0007E49D,
+	0x98000000,0x00000000,0x40000000,0x00000000,
+		0x052, 0x0007E49D,
+	0x90000400,0x00000000,0x40000000,0x00000000,
 		0x052, 0x0007E4DD,
-	0xCDCDCDCD, 0xCDCD,
+	0xA0000000,0x00000000,
 		0x052, 0x0007E49D,
-	0xFF0F0400, 0xDEAD,
+	0xB0000000,0x00000000,
 		0x053, 0x00000073,
 		0x056, 0x00051FF3,
 		0x035, 0x00000086,
@@ -116,7 +207,7 @@ u4Byte Array_MP_8188E_RadioA_1T[] = {
 		0x018, 0x00000C07,
 		0x05A, 0x0004BD00,
 		0x019, 0x000739D0,
-	0xFF0F0718, 0xABCD,
+	0x88000003,0x00000000,0x40000000,0x00000000,
 		0x034, 0x0000A093,
 		0x034, 0x0000908F,
 		0x034, 0x0000808C,
@@ -128,7 +219,19 @@ u4Byte Array_MP_8188E_RadioA_1T[] = {
 		0x034, 0x00002006,
 		0x034, 0x00001003,
 		0x034, 0x00000000,
-	0xCDCDCDCD, 0xCDCD,
+	0x90000003,0x00000000,0x40000000,0x00000000,
+		0x034, 0x0000A093,
+		0x034, 0x0000908F,
+		0x034, 0x0000808C,
+		0x034, 0x0000704F,
+		0x034, 0x0000604C,
+		0x034, 0x00005049,
+		0x034, 0x0000400C,
+		0x034, 0x00003009,
+		0x034, 0x00002006,
+		0x034, 0x00001003,
+		0x034, 0x00000000,
+	0xA0000000,0x00000000,
 		0x034, 0x0000ADF3,
 		0x034, 0x00009DF0,
 		0x034, 0x00008DED,
@@ -140,7 +243,7 @@ u4Byte Array_MP_8188E_RadioA_1T[] = {
 		0x034, 0x0000246B,
 		0x034, 0x00001468,
 		0x034, 0x0000006D,
-	0xFF0F0718, 0xDEAD,
+	0xB0000000,0x00000000,
 		0x000, 0x00030159,
 		0x084, 0x00068200,
 		0x086, 0x000000CE,
@@ -178,457 +281,82 @@ u4Byte Array_MP_8188E_RadioA_1T[] = {
 
 };
 
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_RadioA_1T(
+void
+ODM_ReadAndConfig_MP_8188E_RadioA(
  	IN   PDM_ODM_T  pDM_Odm
  	)
 {
-	#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
-
-	u4Byte     hex         = 0;
-	u4Byte     i           = 0;
-	u2Byte     count       = 0;
-	pu4Byte    ptr_array   = NULL;
-	u1Byte     platform    = pDM_Odm->SupportPlatform;
-	u1Byte     _interface   = pDM_Odm->SupportInterface;
-	u1Byte     board       = pDM_Odm->BoardType;  
-	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_RadioA_1T)/sizeof(u4Byte);
-	pu4Byte    Array       = Array_MP_8188E_RadioA_1T;
-	BOOLEAN		biol = FALSE;
-#ifdef CONFIG_IOL_IOREG_CFG 
-	PADAPTER	Adapter =  pDM_Odm->Adapter;	
-	struct xmit_frame	*pxmit_frame;	
-	u8 bndy_cnt = 1;
-	#ifdef CONFIG_IOL_IOREG_CFG_DBG
-	struct cmd_cmp cmpdata[ArrayLen];
-	u4Byte	cmpdata_idx=0;
-	#endif
-#endif//#ifdef CONFIG_IOL_IOREG_CFG 
-	HAL_STATUS rst =HAL_STATUS_SUCCESS;
-
-	hex += board;
-	hex += _interface << 8;
-	hex += platform << 16;
-	hex += 0xFF000000;
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_8188E_RadioA_1T, hex = 0x%X\n", hex));
-#ifdef CONFIG_IOL_IOREG_CFG 
-	biol = rtw_IOL_applied(Adapter);
+    u4Byte     i         = 0;
+    u1Byte     cCond;
+    BOOLEAN bMatched = TRUE, bSkipped = FALSE;
+//ask by Luke.Lee
+    u4Byte     ArrayLen    = sizeof(Array_MP_8188E_RadioA)/sizeof(u4Byte);
+    pu4Byte    Array       = Array_MP_8188E_RadioA;
 	
-	if(biol){		
-		if((pxmit_frame=rtw_IOL_accquire_xmit_frame(Adapter)) == NULL)
-		{
-			printk("rtw_IOL_accquire_xmit_frame failed\n");
-			return HAL_STATUS_FAILURE;
-		}
-	}		
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
+    ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8188E_RadioA\n"));
 
-	for (i = 0; i < ArrayLen; i += 2 )
+	while(( i+1) < ArrayLen)
 	{
-	    u4Byte v1 = Array[i];
-	    u4Byte v2 = Array[i+1];
-	
-	    // This (offset, data) pair meets the condition.
-	    if ( v1 < 0xCDCDCDCD )
-	    {
-			#ifdef CONFIG_IOL_IOREG_CFG 	
-	 		if(biol){	
-				if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-					bndy_cnt++;	
-				
-				if(v1 == 0xffe)
-				{ 					
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,50);				
-				}
-				else if (v1 == 0xfd){
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,5);
-				}
-				else if (v1 == 0xfc){
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,1);
-				}
-				else if (v1 == 0xfb){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,50);
-				}
-				else if (v1 == 0xfa){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,5);
+		u4Byte v1 = Array[i];
+		u4Byte v2 = Array[i+1];
+
+		if(v1 & (BIT31|BIT30)) //positive & negative condition
+		{
+			if(v1 & BIT31) // positive condition
+			{
+				cCond  = (u1Byte)((v1 & (BIT29|BIT28)) >> 28);
+				if(cCond == COND_ENDIF) //end
+				{
+					bMatched = TRUE;
+					bSkipped = FALSE;
 				}
-				else if (v1 == 0xf9){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,1);
+				else if(cCond == COND_ELSE) //else
+				{
+					bMatched = bSkipped?FALSE:TRUE;
 				}
-				else{
-					rtw_IOL_append_WRF_cmd(pxmit_frame, ODM_RF_PATH_A,(u2Byte)v1, v2,bRFRegOffsetMask) ;
-					#ifdef CONFIG_IOL_IOREG_CFG_DBG
-					cmpdata[cmpdata_idx].addr = v1;
-					cmpdata[cmpdata_idx].value= v2;
-					cmpdata_idx++;
-					#endif
-				}				
- 
-	 		}
-			else
-			#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-			{
-		    	odm_ConfigRF_RadioA_8188E(pDM_Odm, v1, v2);
-			}
-		    continue;
-	 	}
-		else
-		{ // This line is the start line of branch.
-		    if ( !CheckCondition(Array[i], hex) )
-		    { // Discard the following (offset, data) pairs.
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        i -= 2; // prevent from for-loop += 2
-		    }
-		    else // Configure matched pairs and skip to end of if-else.
-		    {
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-					#ifdef CONFIG_IOL_IOREG_CFG 	
-			 		if(biol){	
-						if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-							bndy_cnt++;	
-						
-						if(v1 == 0xffe)
-						{ 							
-							rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,50);					
-						}
-						else if (v1 == 0xfd){
-							rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,5);
-						}
-						else if (v1 == 0xfc){
-							rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,1);
-						}
-						else if (v1 == 0xfb){
-							rtw_IOL_append_DELAY_US_cmd(pxmit_frame,50);
-						}
-						else if (v1 == 0xfa){
-							rtw_IOL_append_DELAY_US_cmd(pxmit_frame,5);
-						}
-						else if (v1 == 0xf9){
-							rtw_IOL_append_DELAY_US_cmd(pxmit_frame,1);
-						}
-						else{
-							rtw_IOL_append_WRF_cmd(pxmit_frame, ODM_RF_PATH_A,(u2Byte)v1, v2,bRFRegOffsetMask) ;
-							#ifdef CONFIG_IOL_IOREG_CFG_DBG
-							cmpdata[cmpdata_idx].addr = v1;
-							cmpdata[cmpdata_idx].value= v2;
-							cmpdata_idx++;
-							#endif
-	
-						}
-		 			}
+				else //if , else if
+				{
+					if(bSkipped)
+						bMatched = FALSE;
 					else
-					#endif	//#ifdef CONFIG_IOL_IOREG_CFG
 					{
-						odm_ConfigRF_RadioA_8188E(pDM_Odm, v1, v2);
+						if(CheckPositive(pDM_Odm, v1, v2))
+						{
+							bMatched = TRUE;
+							bSkipped = TRUE;
+						}
+						else
+						{
+							bMatched = FALSE;
+							bSkipped = FALSE;
+						}
 					}
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-
-		        while (v2 != 0xDEAD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        
-		    }
-		}	
-	}
-#ifdef CONFIG_IOL_IOREG_CFG 		
-	if(biol){
-		//printk("==> %s, pktlen = %d,bndy_cnt = %d\n",__FUNCTION__,pxmit_frame->attrib.pktlen+4+32,bndy_cnt);
-		if(rtw_IOL_exec_cmds_sync(pDM_Odm->Adapter, pxmit_frame, 1000, bndy_cnt))
-		{			
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			printk("~~~ %s Success !!! \n",__FUNCTION__);
-			{
-				u4Byte idx;
-				u4Byte cdata;
-				printk("  %s data compare => array_len:%d \n",__FUNCTION__,cmpdata_idx);
-				printk("### %s data compared !!###\n",__FUNCTION__);
-				for(idx=0;idx< cmpdata_idx;idx++)
-				{
-					cdata = ODM_GetRFReg(pDM_Odm, ODM_RF_PATH_A,cmpdata[idx].addr,bRFRegOffsetMask);
-					if(cdata != cmpdata[idx].value){
-						printk("addr:0x%04x, data:(0x%02x : 0x%02x) \n",
-							cmpdata[idx].addr,cmpdata[idx].value,cdata);
-						rst = HAL_STATUS_FAILURE;
-					}					
-				}	
-				printk("### %s data compared !!###\n",__FUNCTION__);
-				//if(rst == HAL_STATUS_FAILURE)
-				{//dump data from TX packet buffer				
-					rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
 				}
 			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
-		
-		}
-		else{
-			rst = HAL_STATUS_FAILURE;
-			printk("~~~ IOL Config %s Failed !!! \n",__FUNCTION__);
-			#ifdef CONFIG_IOL_IOREG_CFG_DBG
-			{
-				//dump data from TX packet buffer				
-				rtw_IOL_cmd_tx_pkt_buf_dump(pDM_Odm->Adapter,pxmit_frame->attrib.pktlen+32);
+			else if(v1 & BIT30){ //negative condition
+			//do nothing
 			}
-			#endif //CONFIG_IOL_IOREG_CFG_DBG
 		}
+		else
+		{
+			if(bMatched)
+			odm_ConfigRF_RadioA_8188E(pDM_Odm, v1, v2);
+		}
+	i = i + 2;
 	}
-
-	 
-#endif	//#ifdef CONFIG_IOL_IOREG_CFG 
-	return rst;
 }
 
-/******************************************************************************
-*                           RadioA_1T_ICUT.TXT
-******************************************************************************/
-
-u4Byte Array_MP_8188E_RadioA_1T_ICUT[] = { 
-		0x000, 0x00030000,
-		0x008, 0x00084000,
-		0x018, 0x00000407,
-		0x019, 0x00000012,
-		0x01E, 0x00080009,
-		0x01F, 0x00000880,
-		0x02F, 0x0001A060,
-		0x03F, 0x00000000,
-		0x042, 0x000060C0,
-		0x057, 0x000D0000,
-		0x058, 0x000BE180,
-		0x067, 0x00001552,
-		0x083, 0x00000000,
-		0x0B0, 0x000FF8FC,
-		0x0B1, 0x00054400,
-		0x0B2, 0x000CCC19,
-		0x0B4, 0x00043003,
-		0x0B6, 0x0004953E,
-		0x0B7, 0x0001C718,
-		0x0B8, 0x000060FF,
-		0x0B9, 0x00080001,
-		0x0BA, 0x00040000,
-		0x0BB, 0x00000400,
-		0x0BF, 0x000C0000,
-		0x0C2, 0x00002400,
-		0x0C3, 0x00000009,
-		0x0C4, 0x00040C91,
-		0x0C5, 0x00099999,
-		0x0C6, 0x000000A3,
-		0x0C7, 0x00088820,
-		0x0C8, 0x00076C06,
-		0x0C9, 0x00000000,
-		0x0CA, 0x00080000,
-		0x0DF, 0x00000180,
-		0x0EF, 0x000001A0,
-		0x051, 0x0006B27D,
-	0xFF0F0400, 0xABCD,
-		0x052, 0x0007E4DD,
-	0xCDCDCDCD, 0xCDCD,
-		0x052, 0x0007E49D,
-	0xFF0F0400, 0xDEAD,
-		0x053, 0x00000073,
-		0x056, 0x00051FF3,
-		0x035, 0x00000086,
-		0x035, 0x00000186,
-		0x035, 0x00000286,
-		0x036, 0x00001C25,
-		0x036, 0x00009C25,
-		0x036, 0x00011C25,
-		0x036, 0x00019C25,
-		0x0B6, 0x00048538,
-		0x018, 0x00000C07,
-		0x05A, 0x0004BD00,
-		0x019, 0x000739D0,
-		0x034, 0x0000ADF3,
-		0x034, 0x00009DF0,
-		0x034, 0x00008DED,
-		0x034, 0x00007DEA,
-		0x034, 0x00006DE7,
-		0x034, 0x000054EE,
-		0x034, 0x000044EB,
-		0x034, 0x000034E8,
-		0x034, 0x0000246B,
-		0x034, 0x00001468,
-		0x034, 0x0000006D,
-		0x000, 0x00030159,
-		0x084, 0x00068200,
-		0x086, 0x000000CE,
-		0x087, 0x00048A00,
-		0x08E, 0x00065540,
-		0x08F, 0x00088000,
-		0x0EF, 0x000020A0,
-		0x03B, 0x000F02B0,
-		0x03B, 0x000EF7B0,
-		0x03B, 0x000D4FB0,
-		0x03B, 0x000CF060,
-		0x03B, 0x000B0090,
-		0x03B, 0x000A0080,
-		0x03B, 0x00090080,
-		0x03B, 0x0008F780,
-		0x03B, 0x000722B0,
-		0x03B, 0x0006F7B0,
-		0x03B, 0x00054FB0,
-		0x03B, 0x0004F060,
-		0x03B, 0x00030090,
-		0x03B, 0x00020080,
-		0x03B, 0x00010080,
-		0x03B, 0x0000F780,
-		0x0EF, 0x000000A0,
-		0x000, 0x00010159,
-		0x018, 0x0000F407,
-		0xFFE, 0x00000000,
-		0xFFE, 0x00000000,
-		0x01F, 0x00080003,
-		0xFFE, 0x00000000,
-		0xFFE, 0x00000000,
-		0x01E, 0x00000001,
-		0x01F, 0x00080000,
-		0x000, 0x00033E60,
-
-};
-
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_RadioA_1T_ICUT(
- 	IN   PDM_ODM_T  pDM_Odm
- 	)
+u4Byte
+ODM_GetVersion_MP_8188E_RadioA(void)
 {
-	#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
-
-	u4Byte     hex         = 0;
-	u4Byte     i           = 0;
-	u2Byte     count       = 0;
-	pu4Byte    ptr_array   = NULL;
-	u1Byte     platform    = pDM_Odm->SupportPlatform;
-	u1Byte     _interface   = pDM_Odm->SupportInterface;
-	u1Byte     board       = pDM_Odm->BoardType;  
-	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_RadioA_1T_ICUT)/sizeof(u4Byte);
-	pu4Byte    Array       = Array_MP_8188E_RadioA_1T_ICUT;
-	BOOLEAN		biol = FALSE;
-#ifdef CONFIG_IOL_IOREG_CFG 
-	PADAPTER	Adapter =  pDM_Odm->Adapter;	
-	struct xmit_frame	*pxmit_frame;	
-	u8 bndy_cnt = 1;
-	#ifdef CONFIG_IOL_IOREG_CFG_DBG
-	struct cmd_cmp cmpdata[ArrayLen];
-	u4Byte	cmpdata_idx=0;
-	#endif
-#endif//#ifdef CONFIG_IOL_IOREG_CFG 
-	HAL_STATUS rst =HAL_STATUS_SUCCESS;
-
-	hex += board;
-	hex += _interface << 8;
-	hex += platform << 16;
-	hex += 0xFF000000;
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_8188E_RadioA_1T_ICUT, hex = 0x%X\n", hex));
-#ifdef CONFIG_IOL_IOREG_CFG 
-	biol = rtw_IOL_applied(Adapter);
-	
-	if(biol){		
-		if((pxmit_frame=rtw_IOL_accquire_xmit_frame(Adapter)) == NULL)
-		{
-			printk("rtw_IOL_accquire_xmit_frame failed\n");
-			return HAL_STATUS_FAILURE;
-		}
-	}		
-#endif//#ifdef CONFIG_IOL_IOREG_CFG
-
-	for (i = 0; i < ArrayLen; i += 2 )
-	{
-	    u4Byte v1 = Array[i];
-	    u4Byte v2 = Array[i+1];
-	
-	    // This (offset, data) pair meets the condition.
-	    if ( v1 < 0xCDCDCDCD )
-	    {
-			#ifdef CONFIG_IOL_IOREG_CFG 	
-	 		if(biol){	
-				if(rtw_IOL_cmd_boundary_handle(pxmit_frame))
-					bndy_cnt++;	
-				
-				if(v1 == 0xffe)
-				{ 					
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,50);				
-				}
-				else if (v1 == 0xfd){
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,5);
-				}
-				else if (v1 == 0xfc){
-					rtw_IOL_append_DELAY_MS_cmd(pxmit_frame,1);
-				}
-				else if (v1 == 0xfb){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,50);
-				}
-				else if (v1 == 0xfa){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,5);
-				}
-				else if (v1 == 0xf9){
-					rtw_IOL_append_DELAY_US_cmd(pxmit_frame,1);
-				}
-				else{
-					rtw_IOL_append_WRF_cmd(pxmit_frame, ODM_RF_PATH_A,(u2Byte)v1, v2,bRFRegOffsetMask) ;
-					#ifdef CONFIG_IOL_IOREG_CFG_DBG
-					cmpdata[cmpdata_idx].addr = v1;
-					cmpdata[cmpdata_idx].value= v2;
-					cmpdata_idx++;
-					#endif
-				}				
- 
-	 		}
-			else
-			#endif	//#ifdef CONFIG_IOL_IOREG_CFG
-			{
-		    	odm_ConfigRF_RadioA_8188E(pDM_Odm, v1, v2);
-			}
-		    continue;
-	 	}
-		else
-		{ // This line is the start line of branch.
-		    if ( !CheckCondition(Array[i], hex) )
-		    { // Discard the following (offset, data) pairs.
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        i -= 2; // prevent from for-loop += 2
-		    }
-		    else // Configure matched pairs and skip to end of if-else.
-		    {
-		        READ_NEXT_PAIR(v1, v2, i);
-		        while (v2 != 0xDEAD && 
-		               v2 != 0xCDEF && 
-		               v2 != 0xCDCD && i < ArrayLen -2)
-		        {
-		    		odm_ConfigRF_RadioA_8188E(pDM_Odm, v1, v2);
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-
-		        while (v2 != 0xDEAD && i < ArrayLen -2)
-		        {
-		            READ_NEXT_PAIR(v1, v2, i);
-		        }
-		        
-		    }
-		}	
-	}
-	return rst;
+	   return 53;
 }
 
 /******************************************************************************
 *                           TxPowerTrack_AP.TXT
 ******************************************************************************/
 
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
 u1Byte gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_AP_8188E[][DELTA_SWINGIDX_SIZE] = {
 	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7,  8,  9,  10,  11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 17, 17, 17, 17, 18, 18, 18},
 	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7,  8,  9,  10,  11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
@@ -657,15 +385,17 @@ u1Byte gDeltaSwingTableIdx_MP_2GCCKB_N_TxPowerTrack_AP_8188E[] = {0, 1, 1, 1, 2,
 u1Byte gDeltaSwingTableIdx_MP_2GCCKB_P_TxPowerTrack_AP_8188E[] = {0, 0, 1, 1, 2, 2, 2, 2, 3,  3,  3,  4,  4,  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9,  9};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKA_N_TxPowerTrack_AP_8188E[] = {0, 1, 1, 1, 2, 2, 2, 3, 3,  3,  4,  4,  5,  5,  5,  6,  6,  6,  7,  8,  8,  9,  9,  9, 10, 10, 10, 10, 11, 11};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKA_P_TxPowerTrack_AP_8188E[] = {0, 0, 1, 1, 2, 2, 2, 2, 3,  3,  3,  4,  4,  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9,  9};
+#endif
 
 void
 ODM_ReadAndConfig_MP_8188E_TxPowerTrack_AP(
  	IN   PDM_ODM_T  pDM_Odm
  	)
 {
+#if (DM_ODM_SUPPORT_TYPE & (ODM_AP|ODM_ADSL))
 	PODM_RF_CAL_T  pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
 
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_MP_8188E\n"));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_MP_8188E\n"));
 
 
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GA_P, gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_AP_8188E, DELTA_SWINGIDX_SIZE);
@@ -682,12 +412,14 @@ ODM_ReadAndConfig_MP_8188E_TxPowerTrack_AP(
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GA_N, gDeltaSwingTableIdx_MP_5GA_N_TxPowerTrack_AP_8188E, DELTA_SWINGIDX_SIZE*3);
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_P, gDeltaSwingTableIdx_MP_5GB_P_TxPowerTrack_AP_8188E, DELTA_SWINGIDX_SIZE*3);
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_N, gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_AP_8188E, DELTA_SWINGIDX_SIZE*3);
+#endif
 }
 
 /******************************************************************************
 *                           TxPowerTrack_PCIE.TXT
 ******************************************************************************/
 
+#if DEV_BUS_TYPE == RT_PCI_INTERFACE
 u1Byte gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_PCIE_8188E[][DELTA_SWINGIDX_SIZE] = {
 	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7,  8,  9,  10,  11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 17, 17, 17, 17, 18, 18, 18},
 	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7,  8,  9,  10,  11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
@@ -709,22 +441,24 @@ u1Byte gDeltaSwingTableIdx_MP_5GA_P_TxPowerTrack_PCIE_8188E[][DELTA_SWINGIDX_SIZ
 	{0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
 };
 u1Byte gDeltaSwingTableIdx_MP_2GB_N_TxPowerTrack_PCIE_8188E[]    = {0, 0, 0, 2, 2, 3, 3, 4, 4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11};
-u1Byte gDeltaSwingTableIdx_MP_2GB_P_TxPowerTrack_PCIE_8188E[]    = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+u1Byte gDeltaSwingTableIdx_MP_2GB_P_TxPowerTrack_PCIE_8188E[]    = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  5,  6,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8};
 u1Byte gDeltaSwingTableIdx_MP_2GA_N_TxPowerTrack_PCIE_8188E[]    = {0, 0, 0, 2, 2, 3, 3, 4, 4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11};
-u1Byte gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_PCIE_8188E[]    = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+u1Byte gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_PCIE_8188E[]    = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  5,  6,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKB_N_TxPowerTrack_PCIE_8188E[] = {0, 0, 0, 2, 2, 3, 3, 4, 4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKB_P_TxPowerTrack_PCIE_8188E[] = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKA_N_TxPowerTrack_PCIE_8188E[] = {0, 0, 0, 2, 2, 3, 3, 4, 4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKA_P_TxPowerTrack_PCIE_8188E[] = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+#endif
 
 void
 ODM_ReadAndConfig_MP_8188E_TxPowerTrack_PCIE(
  	IN   PDM_ODM_T  pDM_Odm
  	)
 {
+#if DEV_BUS_TYPE == RT_PCI_INTERFACE
 	PODM_RF_CAL_T  pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
 
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_MP_8188E\n"));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_MP_8188E\n"));
 
 
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GA_P, gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_PCIE_8188E, DELTA_SWINGIDX_SIZE);
@@ -741,12 +475,14 @@ ODM_ReadAndConfig_MP_8188E_TxPowerTrack_PCIE(
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GA_N, gDeltaSwingTableIdx_MP_5GA_N_TxPowerTrack_PCIE_8188E, DELTA_SWINGIDX_SIZE*3);
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_P, gDeltaSwingTableIdx_MP_5GB_P_TxPowerTrack_PCIE_8188E, DELTA_SWINGIDX_SIZE*3);
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_N, gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_PCIE_8188E, DELTA_SWINGIDX_SIZE*3);
+#endif
 }
 
 /******************************************************************************
 *                           TxPowerTrack_USB.TXT
 ******************************************************************************/
 
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
 u1Byte gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_USB_8188E[][DELTA_SWINGIDX_SIZE] = {
 	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7,  8,  9,  10,  11, 11, 12, 12, 13, 13, 14, 14, 15, 16, 17, 17, 17, 17, 18, 18, 18},
 	{0, 1, 2, 3, 3, 5, 5, 6, 6, 7,  8,  9,  10,  11, 11, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 18},
@@ -768,22 +504,24 @@ u1Byte gDeltaSwingTableIdx_MP_5GA_P_TxPowerTrack_USB_8188E[][DELTA_SWINGIDX_SIZE
 	{0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15},
 };
 u1Byte gDeltaSwingTableIdx_MP_2GB_N_TxPowerTrack_USB_8188E[]    = {0, 0, 0, 2, 2, 3, 3, 4, 4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11};
-u1Byte gDeltaSwingTableIdx_MP_2GB_P_TxPowerTrack_USB_8188E[]    = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+u1Byte gDeltaSwingTableIdx_MP_2GB_P_TxPowerTrack_USB_8188E[]    = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  5,  6,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8};
 u1Byte gDeltaSwingTableIdx_MP_2GA_N_TxPowerTrack_USB_8188E[]    = {0, 0, 0, 2, 2, 3, 3, 4, 4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11};
-u1Byte gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_USB_8188E[]    = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+u1Byte gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_USB_8188E[]    = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  5,  6,  7,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKB_N_TxPowerTrack_USB_8188E[] = {0, 0, 0, 2, 2, 3, 3, 4, 4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKB_P_TxPowerTrack_USB_8188E[] = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKA_N_TxPowerTrack_USB_8188E[] = {0, 0, 0, 2, 2, 3, 3, 4, 4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11};
 u1Byte gDeltaSwingTableIdx_MP_2GCCKA_P_TxPowerTrack_USB_8188E[] = {0, 0, 0, 0, 1, 1, 2, 2, 3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+#endif
 
 void
 ODM_ReadAndConfig_MP_8188E_TxPowerTrack_USB(
  	IN   PDM_ODM_T  pDM_Odm
  	)
 {
+#if DEV_BUS_TYPE == RT_USB_INTERFACE
 	PODM_RF_CAL_T  pRFCalibrateInfo = &(pDM_Odm->RFCalibrateInfo);
 
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_MP_8188E\n"));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_MP_8188E\n"));
 
 
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_2GA_P, gDeltaSwingTableIdx_MP_2GA_P_TxPowerTrack_USB_8188E, DELTA_SWINGIDX_SIZE);
@@ -800,6 +538,7 @@ ODM_ReadAndConfig_MP_8188E_TxPowerTrack_USB(
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GA_N, gDeltaSwingTableIdx_MP_5GA_N_TxPowerTrack_USB_8188E, DELTA_SWINGIDX_SIZE*3);
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_P, gDeltaSwingTableIdx_MP_5GB_P_TxPowerTrack_USB_8188E, DELTA_SWINGIDX_SIZE*3);
 	ODM_MoveMemory(pDM_Odm, pRFCalibrateInfo->DeltaSwingTableIdx_5GB_N, gDeltaSwingTableIdx_MP_5GB_N_TxPowerTrack_USB_8188E, DELTA_SWINGIDX_SIZE*3);
+#endif
 }
 
 /******************************************************************************
@@ -1382,8 +1121,7 @@ ODM_ReadAndConfig_MP_8188E_TXPWR_LMT(
 	u4Byte     ArrayLen    = sizeof(Array_MP_8188E_TXPWR_LMT)/sizeof(pu1Byte);
 	pu1Byte    *Array      = Array_MP_8188E_TXPWR_LMT;
 
-
-	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_TRACE, ("===> ODM_ReadAndConfig_MP_8188E_TXPWR_LMT\n"));
+	ODM_RT_TRACE(pDM_Odm, ODM_COMP_INIT, ODM_DBG_LOUD, ("===> ODM_ReadAndConfig_MP_8188E_TXPWR_LMT\n"));
 
 	for (i = 0; i < ArrayLen; i += 7 )
 	{
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.h
index eb59afd755a8..859396678f64 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalHWImg8188E_RF.h
@@ -22,25 +22,16 @@
 #ifndef __INC_MP_RF_HW_IMG_8188E_H
 #define __INC_MP_RF_HW_IMG_8188E_H
 
-//static BOOLEAN CheckCondition(const u4Byte Condition, const u4Byte Hex);
 
 /******************************************************************************
-*                           RadioA_1T.TXT
+*                           RadioA.TXT
 ******************************************************************************/
 
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_RadioA_1T( // TC: Test Chip, MP: MP Chip
-	IN   PDM_ODM_T  pDM_Odm
-);
-
-/******************************************************************************
-*                           RadioA_1T_ICUT.TXT
-******************************************************************************/
-
-HAL_STATUS
-ODM_ReadAndConfig_MP_8188E_RadioA_1T_ICUT( // TC: Test Chip, MP: MP Chip
+void
+ODM_ReadAndConfig_MP_8188E_RadioA( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
+u4Byte ODM_GetVersion_MP_8188E_RadioA(void);
 
 /******************************************************************************
 *                           TxPowerTrack_AP.TXT
@@ -50,6 +41,7 @@ void
 ODM_ReadAndConfig_MP_8188E_TxPowerTrack_AP( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
+u4Byte ODM_GetVersion_MP_8188E_TxPowerTrack_AP(void);
 
 /******************************************************************************
 *                           TxPowerTrack_PCIE.TXT
@@ -59,6 +51,7 @@ void
 ODM_ReadAndConfig_MP_8188E_TxPowerTrack_PCIE( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
+u4Byte ODM_GetVersion_MP_8188E_TxPowerTrack_PCIE(void);
 
 /******************************************************************************
 *                           TxPowerTrack_USB.TXT
@@ -68,6 +61,7 @@ void
 ODM_ReadAndConfig_MP_8188E_TxPowerTrack_USB( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
+u4Byte ODM_GetVersion_MP_8188E_TxPowerTrack_USB(void);
 
 /******************************************************************************
 *                           TXPWR_LMT.TXT
@@ -77,6 +71,7 @@ void
 ODM_ReadAndConfig_MP_8188E_TXPWR_LMT( // TC: Test Chip, MP: MP Chip
 	IN   PDM_ODM_T  pDM_Odm
 );
+u4Byte ODM_GetVersion_MP_8188E_TXPWR_LMT(void);
 
 #endif
 #endif // end of HWIMG_SUPPORT
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c
index 2f3779b773f9..4308d7e18838 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c
@@ -18,8 +18,8 @@
  *
  ******************************************************************************/
 
-
-#include "../odm_precomp.h"
+#include "Mp_Precomp.h"
+#include "../phydm_precomp.h"
 
 
 
@@ -195,8 +195,7 @@ ODM_TxPwrTrackSetPwr88E(
 	u1Byte		Final_CCK_Swing_Index = 0; 
 	u1Byte		i = 0;
 
-#if (MP_DRIVER==1)
-	if ( *(pDM_Odm->mp_mode) == 1)
+	if (pDM_Odm->mp_mode == TRUE)
 	{
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE ))
 	#if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
@@ -208,7 +207,6 @@ ODM_TxPwrTrackSetPwr88E(
 #endif
 	}
 	else
-#endif
 	{
 		u2Byte	rate	 = *(pDM_Odm->pForcedDataRate);
 	
@@ -264,14 +262,13 @@ ODM_TxPwrTrackSetPwr88E(
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN|ODM_CE ))
 
-	#if (MP_DRIVER == 1)
-		if ( *(pDM_Odm->mp_mode) == 1) 
+		if (pDM_Odm->mp_mode == TRUE)
 		{
 			pwr = PHY_QueryBBReg(Adapter, rTxAGC_A_Rate18_06, 0xFF);
 			pwr += pDM_Odm->RFCalibrateInfo.PowerIndexOffset[ODM_RF_PATH_A];
 			PHY_SetBBReg(Adapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, pwr);
 			TxAGC = (pwr<<16)|(pwr<<8)|(pwr);
-			PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, TxAGC);
+			PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskH3Bytes, TxAGC);
 			//RT_DISP(FPHY, PHY_TXPWR, ("ODM_TxPwrTrackSetPwr88E: CCK Tx-rf(A) Power = 0x%x\n", TxAGC));		
 
 			pwr = PHY_QueryBBReg(Adapter, rTxAGC_A_Rate18_06, 0xFF);
@@ -286,7 +283,6 @@ ODM_TxPwrTrackSetPwr88E(
 			//RT_DISP(FPHY, PHY_TXPWR, ("ODM_TxPwrTrackSetPwr88E: OFDM Tx-rf(A) Power = 0x%x\n", TxAGC));		
 		}
 		else
-	#endif
 		{
 			//PHY_SetTxPowerLevel8188E(pDM_Odm->Adapter, *pDM_Odm->pChannel);
 			pDM_Odm->Modify_TxAGC_Flag_PathA = TRUE;
@@ -315,12 +311,12 @@ ODM_TxPwrTrackSetPwr88E(
 		
 		if (Final_OFDM_Swing_Index >= PwrTrackingLimit_OFDM)
 			Final_OFDM_Swing_Index = PwrTrackingLimit_OFDM;
-		else if (Final_OFDM_Swing_Index < 0)
+		else if (Final_OFDM_Swing_Index <= 0)
 			Final_OFDM_Swing_Index = 0;
 
 		if (Final_CCK_Swing_Index >= CCK_TABLE_SIZE)
 			Final_CCK_Swing_Index = CCK_TABLE_SIZE-1;
-		else if (pDM_Odm->BbSwingIdxCck < 0)
+		else if (pDM_Odm->BbSwingIdxCck <= 0)
 			Final_CCK_Swing_Index = 0;
 
 		// Adjust BB swing by OFDM IQ matrix
@@ -376,7 +372,7 @@ ODM_TxPwrTrackSetPwr88E(
 
 			ODM_RT_TRACE(pDM_Odm,ODM_COMP_TX_PWR_TRACK, ODM_DBG_LOUD,("******Path_A Over BBSwing Limit , PwrTrackingLimit = %d , Remnant TxAGC Value = %d \n", PwrTrackingLimit_OFDM, pDM_Odm->Remnant_OFDMSwingIdx[RFPath]));
 		}
-		else if (Final_OFDM_Swing_Index < 0)
+		else if (Final_OFDM_Swing_Index <= 0)
 		{
 			pDM_Odm->Remnant_OFDMSwingIdx[RFPath] = Final_OFDM_Swing_Index ;     
 
@@ -448,7 +444,7 @@ ODM_TxPwrTrackSetPwr88E(
 			PHY_SetTxPowerIndexByRateSection(Adapter, ODM_RF_PATH_A, pHalData->CurrentChannel, CCK );
 			
 		}
-		else if(Final_CCK_Swing_Index < 0)    // Lowest CCK Index = 0
+		else if(Final_CCK_Swing_Index <= 0)    // Lowest CCK Index = 0
 		{
 			pDM_Odm->Remnant_CCKSwingIdx = Final_CCK_Swing_Index;
 
@@ -663,12 +659,12 @@ phy_PathA_RxIQK(
 	//1 Get TXIMR setting
 	//modify RXIQK mode table
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path-A Rx IQK modify RXIQK mode table!\n"));
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);	
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);		
 	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, bRFRegOffsetMask, 0x800a0 );
 	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x30000 );
 	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0000f );
 	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf117B );
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 	
 	//IQK setting
 	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);
@@ -718,12 +714,12 @@ phy_PathA_RxIQK(
 	//1 RX IQK
 	//modify RXIQK mode table
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("Path-A Rx IQK modify RXIQK mode table 2!\n"));
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);		
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);			
 	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_WE_LUT, bRFRegOffsetMask, 0x800a0 );
 	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_RCK_OS, bRFRegOffsetMask, 0x30000 );
 	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G1, bRFRegOffsetMask, 0x0000f );
 	ODM_SetRFReg(pDM_Odm, ODM_RF_PATH_A, RF_TXPA_G2, bRFRegOffsetMask, 0xf7ffa );
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 
 	//IQK setting
 	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);
@@ -1235,9 +1231,9 @@ _PHY_PathAStandBy(
 #endif	
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("Path-A standby mode!\n"));
 
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x0);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x0);
 	ODM_SetBBReg(pDM_Odm, 0x840, bMaskDWord, 0x00010000);
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 }
 
 VOID
@@ -1408,7 +1404,7 @@ phy_IQCalibrate_8188E(
 
 	u4Byte	retryCount = 2;
 
-	if ( *(pDM_Odm->mp_mode) == 1)
+	if (pDM_Odm->mp_mode == TRUE)
 		retryCount = 9;
 
 	// Note: IQ calibration must be performed after loading 
@@ -1505,7 +1501,7 @@ phy_IQCalibrate_8188E(
 
 	// IQ calibration setting
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("IQK setting!\n"));		
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x808000);
 	ODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);
 	ODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x81004800);
 
@@ -1599,7 +1595,7 @@ phy_IQCalibrate_8188E(
 
 	//Back to BB mode, load original value
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("IQK:Back to BB mode, load original value!\n"));
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0);
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0);
 
 	if(t!=0)
 	{
@@ -1848,7 +1844,7 @@ phy_APCalibrate_8188E(
 	PMPT_CONTEXT	pMptCtx = &(pAdapter->MptCtx);	
 #endif
 
-	if ( *(pDM_Odm->mp_mode) == 1)
+	if (pDM_Odm->mp_mode == TRUE)
 	{
 		pMptCtx->APK_bound[0] = 45;
 		pMptCtx->APK_bound[1] = 52;		
@@ -1867,7 +1863,7 @@ phy_APCalibrate_8188E(
 // will disappear after disable/enable card many times on 88CU. RF SD and DD have not find the
 // root cause, so we remove these actions temporarily. Added by tynli and SD3 Allen. 2010.05.31.
 //#if MP_DRIVER != 1
-	if (*(pDM_Odm->mp_mode) != 1)
+	if (pDM_Odm->mp_mode == FALSE)
 		return;
 //#endif
 	//settings adjust for normal chip
@@ -1941,7 +1937,7 @@ phy_APCalibrate_8188E(
 			}	
 			
 			//page-B1
-			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x40000000);
+			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x400000);
 		
 			//path A
 			offset = rPdp_AntA;
@@ -1952,7 +1948,7 @@ phy_APCalibrate_8188E(
 				
 				offset += 0x04;
 			}				
-			ODM_SetBBReg(pDM_Odm,  rFPGA0_IQK, bMaskDWord, 0x00000000);							
+			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);								
 		}
 		else if(path == ODM_RF_PATH_B)
 		{
@@ -1985,7 +1981,7 @@ phy_APCalibrate_8188E(
 			}	
 			
 			//page-B1
-			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x40000000);
+			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x400000);
 			
 			//path B
 			offset = 0xb60;
@@ -1996,7 +1992,7 @@ phy_APCalibrate_8188E(
 				
 				offset += 0x04;
 			}				
-			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0);							
+			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0);							
 		}
 	
 		//save RF default value
@@ -2118,7 +2114,7 @@ phy_APCalibrate_8188E(
 			i = 0;
 			do
 			{
-				ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x80000000);
+				ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x800000);
 				{
 					ODM_SetBBReg(pDM_Odm, APK_offset[path], bMaskDWord, APK_value[0]);		
 					ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("phy_APCalibrate_8188E() offset 0x%x value 0x%x\n", APK_offset[path], ODM_GetBBReg(pDM_Odm, APK_offset[path], bMaskDWord)));
@@ -2128,7 +2124,7 @@ phy_APCalibrate_8188E(
 
 					ODM_delay_ms(20);
 				}
-				ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);
+				ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
 
 				if(path == ODM_RF_PATH_A)
 					tmpReg = ODM_GetBBReg(pDM_Odm, rAPK, 0x03E00000);
@@ -2294,7 +2290,7 @@ PHY_IQCalibrate_8188E(
 #endif		
 
 #if MP_DRIVER == 1	
-	if (*(pDM_Odm->mp_mode) == 1)
+	if (pDM_Odm->mp_mode == TRUE)
 	{
 		bStartContTx = pMptCtx->bStartContTx;
 		bSingleTone = pMptCtx->bSingleTone;
@@ -2538,7 +2534,7 @@ PHY_LCCalibrate_8188E(
 #endif	
 
 #if MP_DRIVER == 1	
-	if (*(pDM_Odm->mp_mode) == 1)
+	if (pDM_Odm->mp_mode == TRUE)
 	{
 		bStartContTx = pMptCtx->bStartContTx;
 		bSingleTone = pMptCtx->bSingleTone;
@@ -2580,6 +2576,7 @@ PHY_LCCalibrate_8188E(
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("LCK ProgressingTime = %d\n", ProgressingTime));
 }
 
+#if 0
 VOID
 PHY_APCalibrate_8188E(
 #if (DM_ODM_SUPPORT_TYPE & ODM_AP)
@@ -2603,7 +2600,7 @@ PHY_APCalibrate_8188E(
 	return;
 #endif
 
-	return;
+#if 0
 #if (DM_ODM_SUPPORT_TYPE == ODM_CE)
 	if(!(pDM_Odm->SupportAbility & ODM_RF_CALIBRATION))
 	{
@@ -2630,7 +2627,10 @@ PHY_APCalibrate_8188E(
 		phy_APCalibrate_8188E(pDM_Odm, delta, FALSE);
 #endif
 	}
+#endif
 }
+#endif
+
 VOID phy_SetRFPathSwitch_8188E(
 #if (DM_ODM_SUPPORT_TYPE & ODM_AP)
 	IN PDM_ODM_T		pDM_Odm,
@@ -2875,9 +2875,9 @@ phy_DigitalPredistortion(
 	// PA gain = 11 & PAD2 => tx_agc 10~0e
 	// PA gain = 01 => tx_agc 0b~0d
 	// PA gain = 00 => tx_agc 0a~00
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x40000000);	
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x400000);	
 	ODM_SetBBReg(pDM_Odm, 0xbc0, bMaskDWord, 0x0005361f);		
-	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);	
+	ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);		
 
 	//do inner loopback DPK 3 times 
 	for(i = 0; i < 3; i++)
@@ -2948,8 +2948,8 @@ phy_DigitalPredistortion(
 		{
 			ODM_SetBBReg(pDM_Odm, rPdp_AntA, bMaskDWord, 0x02017098);
 		
-			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x80000000);
-			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);
+			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x800000);
+			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
 			ODM_delay_ms(1);
 			ODM_SetBBReg(pDM_Odm, rConfig_Pmpd_AntA, bMaskDWord, 0x800477c0);
 			ODM_delay_ms(1);			
@@ -2975,7 +2975,7 @@ phy_DigitalPredistortion(
 		ODM_SetBBReg(pDM_Odm, rPdp_AntA_4, bMaskDWord, 0x776d9f84);
 		ODM_SetBBReg(pDM_Odm, rConfig_Pmpd_AntA, bMaskDWord, 0x0004ab87);
 		ODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x00880000);
-		ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x40000000);
+		ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x400000);
 
 		for(i=rPdp_AntA; i<=0xb3c; i+=4)
 		{
@@ -2995,7 +2995,7 @@ phy_DigitalPredistortion(
 
 		//TX_AGC boundary
 		ODM_SetBBReg(pDM_Odm, 0xbc0, bMaskDWord, 0x0005361f);	
-		ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);					
+		ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);						
 	}
 	else
 	{
@@ -3014,9 +3014,9 @@ phy_DigitalPredistortion(
 		// PA gain = 11 & PAD2, => tx_agc 10 ~0e
 		// PA gain = 01 => tx_agc 0b ~0d
 		// PA gain = 00 => tx_agc 0a ~00
-		ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x40000000);	
+		ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x400000);	
 		ODM_SetBBReg(pDM_Odm, 0xbc4, bMaskDWord, 0x0005361f);		
-		ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);	
+		ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);		
 
 		//do inner loopback DPK 3 times 
 		for(i = 0; i < 3; i++)
@@ -3087,8 +3087,8 @@ phy_DigitalPredistortion(
 			{
 				ODM_SetBBReg(pDM_Odm, rPdp_AntB, bMaskDWord, 0x02017098);		
 			
-				ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x80000000);
-				ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);
+				ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x800000);
+				ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);	
 				ODM_delay_ms(1);
 				ODM_SetBBReg(pDM_Odm, rConfig_Pmpd_AntB, bMaskDWord, 0x800477c0);		
 				ODM_delay_ms(1);	
@@ -3115,7 +3115,7 @@ phy_DigitalPredistortion(
 			ODM_SetBBReg(pDM_Odm, rConfig_Pmpd_AntB, bMaskDWord, 0x0004ab87);
 			ODM_SetBBReg(pDM_Odm, rConfig_AntB, bMaskDWord, 0x00880000);
 			
-			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x40000000);
+			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x400000);
 			for(i=0xb60; i<=0xb9c; i+=4)
 			{
 				ODM_SetBBReg(pDM_Odm, i, bMaskDWord, 0x40004000);	
@@ -3134,7 +3134,7 @@ phy_DigitalPredistortion(
 			
 			// tx_agc boundary
 			ODM_SetBBReg(pDM_Odm, 0xbc4, bMaskDWord, 0x0005361f);	
-			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);			
+			ODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskH3Bytes, 0x000000);				
 			
 		}
 		else
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.h
index 204e1566357c..04e2f17c14ce 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.h
@@ -75,7 +75,7 @@ void
 PHY_LCCalibrate_8188E(
 	IN PDM_ODM_T		pDM_Odm
 );
-
+#if 0
 //
 // AP calibrate
 //
@@ -86,7 +86,9 @@ PHY_APCalibrate_8188E(
 #else
 	IN	PADAPTER	pAdapter,
 #endif
-							IN 	s1Byte		delta);
+	IN 	s1Byte		delta);
+#endif
+
 void	
 PHY_DigitalPredistortion_8188E(		IN	PADAPTER	pAdapter);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Mp_Precomp.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Mp_Precomp.h
new file mode 100644
index 000000000000..43ea006e752b
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/Mp_Precomp.h
@@ -0,0 +1,24 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+//#include <Precomp.h>
+//#include "phydm_precomp.h"
+//#include "../phydm_precomp.h"
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RTL8188E.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RTL8188E.c
similarity index 95%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RTL8188E.c
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RTL8188E.c
index 9ad46410ef26..c778076bf33f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RTL8188E.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RTL8188E.c
@@ -22,7 +22,9 @@
 // include files
 //============================================================
 
-#include "../odm_precomp.h"
+#include "Mp_Precomp.h"
+
+#include "../phydm_precomp.h"
 
 #if (RTL8188E_SUPPORT == 1)
 
@@ -79,7 +81,7 @@ odm_DynamicPrimaryCCA(
 	PRT_WLAN_STA	pEntry;
 #endif	
 
-	PFALSE_ALARM_STATISTICS		FalseAlmCnt = &(pDM_Odm->FalseAlmCnt);
+	PFALSE_ALARM_STATISTICS		FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( pDM_Odm , PHYDM_FALSEALMCNT);
 	pPri_CCA_T		PrimaryCCA = &(pDM_Odm->DM_PriCCA);  
 	
 	BOOLEAN		Is40MHz;
@@ -95,9 +97,12 @@ odm_DynamicPrimaryCCA(
 	u1Byte		SecCHOffset;
 	u1Byte		i;
 	
+	if(!(pDM_Odm->SupportAbility & ODM_BB_PRIMARY_CCA))
+		return;
+	
 #if((DM_ODM_SUPPORT_TYPE==ODM_ADSL) ||( DM_ODM_SUPPORT_TYPE==ODM_CE))
 	return;
-#endif
+#else
 
 	if(pDM_Odm->SupportICType != ODM_RTL8188E) 
 		return;
@@ -434,6 +439,8 @@ odm_DynamicPrimaryCCA(
 	}
 
 	Client_40MHz_pre = Client_40MHz;
+
+#endif
 }
 #else //#if (RTL8188E_SUPPORT == 1)
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RTL8188E.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RTL8188E.h
similarity index 100%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RTL8188E.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RTL8188E.h
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RegConfig8188E.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RegConfig8188E.c
similarity index 93%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RegConfig8188E.c
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RegConfig8188E.c
index 25ad4b1c61e0..6a515fc71ebd 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RegConfig8188E.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RegConfig8188E.c
@@ -18,9 +18,9 @@
  *
  ******************************************************************************/
 
+#include "Mp_Precomp.h"
 
-
-#include "../odm_precomp.h"
+#include "../phydm_precomp.h"
 
 #if (RTL8188E_SUPPORT == 1)  
 
@@ -33,6 +33,13 @@ odm_ConfigRFReg_8188E(
 	IN	u4Byte				    RegAddr
 	)
 {
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+#ifndef SMP_SYNC
+		unsigned long x;
+#endif
+		struct rtl8192cd_priv *priv = pDM_Odm->priv;
+#endif
+
     if(Addr == 0xffe)
 	{ 					  
 		#ifdef CONFIG_LONG_DELAY_ISSUE
@@ -63,7 +70,14 @@ odm_ConfigRFReg_8188E(
 	}
 	else
 	{
+
+#if (DM_ODM_SUPPORT_TYPE == ODM_AP)
+		SAVE_INT_AND_CLI(x);	
+		ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, bRFRegOffsetMask, Data);
+		RESTORE_INT(x);
+#else
 		ODM_SetRFReg(pDM_Odm, RF_PATH, RegAddr, bRFRegOffsetMask, Data);
+#endif		
 		// Add 1us delay between BB/RF register setting.
 		ODM_delay_us(1);
 	}	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RegConfig8188E.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RegConfig8188E.h
similarity index 100%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/odm_RegConfig8188E.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/hal/OUTSRC/rtl8188e/phydm_RegConfig8188E.h
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_btcoex.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_btcoex.c
index 2d843d33924e..211ba42be7a0 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_btcoex.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_btcoex.c
@@ -64,22 +64,39 @@ const char *const h2cStaString[] =
 
 const char *const ioStaString[] =
 {
-	"IO_STATUS_SUCCESS",
-	"IO_STATUS_FAIL_CANNOT_IO",
-	"IO_STATUS_FAIL_RF_OFF",
-	"IO_STATUS_FAIL_FW_READ_CLEAR_TIMEOUT",
-	"IO_STATUS_FAIL_WAIT_IO_EVENT_TIMEOUT",
-	"IO_STATUS_INVALID_LEN",
-	"IO_STATUS_IO_IDLE_QUEUE_EMPTY",
-	"IO_STATUS_IO_INSERT_WAIT_QUEUE_FAIL",
-	"IO_STATUS_UNKNOWN_FAIL",
-	"IO_STATUS_WRONG_LEVEL",
-	"IO_STATUS_H2C_STOPPED",
+	"success",
+	"can not IO",
+	"rf off",
+	"fw not read",
+	"wait io timeout",
+	"invalid len",
+	"idle Q empty",
+	"insert waitQ fail",
+	"unknown fail",
+	"wrong level",
+	"h2c stopped",
+};
+
+const char *const GLBtcWifiBwString[]={
+	"11bg",
+	"HT20",
+	"HT40",
+	"HT80",
+	"HT160"
+};
+
+const char *const GLBtcWifiFreqString[]={
+	"2.4G",
+	"5G"
 };
 
+#define HALBTCOUTSRC_AGG_CHK_WINDOW_IN_MS	8000
+
 BTC_COEXIST GLBtCoexist;
 u8 GLBtcWiFiInScanState;
 u8 GLBtcWiFiInIQKState;
+u8 GLBtcWiFiInIPS;
+u8 GLBtcWiFiInLPS;
 
 u32 GLBtcDbgType[BTC_MSG_MAX];
 u8 GLBtcDbgBuf[BT_TMP_BUF_SIZE];
@@ -167,9 +184,24 @@ static void halbtcoutsrc_DbgInit(void)
 			0;
 }
 
+static u8 halbtcoutsrc_IsCsrBtCoex(PBTC_COEXIST pBtCoexist)
+{
+	if (pBtCoexist->boardInfo.btChipType == BTC_CHIP_CSR_BC4
+		|| pBtCoexist->boardInfo.btChipType == BTC_CHIP_CSR_BC8
+	){
+		return _TRUE;
+	}
+	return _FALSE;
+}
+
 static u8 halbtcoutsrc_IsHwMailboxExist(PBTC_COEXIST pBtCoexist)
 {
-	if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter))
+	if (pBtCoexist->boardInfo.btChipType == BTC_CHIP_CSR_BC4
+		|| pBtCoexist->boardInfo.btChipType == BTC_CHIP_CSR_BC8
+	){
+		return _FALSE;
+	}
+	else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter))
 	{
 		return _FALSE;
 	}
@@ -296,16 +328,41 @@ void halbtcoutsrc_DisableLowPower(PBTC_COEXIST pBtCoexist, u8 bLowPwrDisable)
 void halbtcoutsrc_AggregationCheck(PBTC_COEXIST pBtCoexist)
 {
 	PADAPTER padapter;
-	BOOLEAN bNeedToAct;
-
+	BOOLEAN bNeedToAct = _FALSE;
+	static u32 preTime = 0;
+	u32 curTime = 0;
 
 	padapter = pBtCoexist->Adapter;
-	bNeedToAct = _FALSE;
+
+	//=====================================
+	// To void continuous deleteBA=>addBA=>deleteBA=>addBA
+	// This function is not allowed to continuous called.
+	// It can only be called after 8 seconds.
+	//=====================================
+
+	curTime = rtw_systime_to_ms(rtw_get_current_time());
+	if((curTime - preTime) < HALBTCOUTSRC_AGG_CHK_WINDOW_IN_MS)	// over 8 seconds you can execute this function again.
+	{
+		return;
+	}
+	else
+	{
+		preTime = curTime;
+	}
 
 	if (pBtCoexist->btInfo.bRejectAggPkt)
+	{
 		rtw_btcoex_RejectApAggregatedPacket(padapter, _TRUE);
+		pBtCoexist->btInfo.bPreRejectAggPkt = pBtCoexist->btInfo.bRejectAggPkt;
+	}
 	else
 	{
+		if(pBtCoexist->btInfo.bPreRejectAggPkt)
+		{
+			bNeedToAct = _TRUE;
+			pBtCoexist->btInfo.bPreRejectAggPkt = pBtCoexist->btInfo.bRejectAggPkt;
+		}
+		
 		if (pBtCoexist->btInfo.bPreBtCtrlAggBufSize !=
 			pBtCoexist->btInfo.bBtCtrlAggBufSize)
 		{
@@ -499,7 +556,7 @@ static u8 halbtcoutsrc_GetWifiScanAPNum(PADAPTER padapter)
 	pmlmepriv = &padapter->mlmepriv;
 	pmlmeext = &padapter->mlmeextpriv;
 
-	if (check_fwstate(pmlmepriv, WIFI_SITE_MONITOR) == _FALSE) {
+	if (GLBtcWiFiInScanState == _FALSE) {
 		if (pmlmeext->sitesurvey_res.bss_cnt > 0xFF)
 			scan_AP_num = 0xFF;
 		else
@@ -629,6 +686,17 @@ u8 halbtcoutsrc_Get(void *pBtcContext, u8 getType, void *pOutBuf)
 				*pu8 = _FALSE;
 			break;
 
+		case BTC_GET_BL_WIFI_IS_IN_MP_MODE:
+			if (padapter->registrypriv.mp_mode == 0)
+			{
+				*pu8 = _FALSE;
+			}
+			else
+			{
+				*pu8 = _TRUE;
+			}
+			break;
+
 		case BTC_GET_BL_EXT_SWITCH:
 			*pu8 = _FALSE;
 			break;
@@ -701,6 +769,9 @@ u8 halbtcoutsrc_Get(void *pBtcContext, u8 getType, void *pOutBuf)
 		case BTC_GET_U1_AP_NUM:
 			*pU1Tmp = halbtcoutsrc_GetWifiScanAPNum(padapter);
 			break;
+		case BTC_GET_U1_ANT_TYPE:
+			*pU1Tmp = (u1Byte)BTC_ANT_TYPE_0;
+			break;
 
 		//=======1Ant===========
 		case BTC_GET_U1_LPS_MODE:
@@ -766,6 +837,15 @@ u8 halbtcoutsrc_Set(void *pBtcContext, u8 setType, void *pInBuf)
 
 		case BTC_SET_BL_INC_SCAN_DEV_NUM:
 			pBtCoexist->btInfo.bIncreaseScanDevNum = *pu8;
+			break;
+
+		case BTC_SET_BL_BT_TX_RX_MASK:
+			pBtCoexist->btInfo.bBtTxRxMask = *pu8;
+			break;
+
+		case BTC_SET_BL_MIRACAST_PLUS_BT:
+			pBtCoexist->btInfo.bMiracastPlusBt = *pu8;
+			break;
 
 		// set some u8 type variables.
 		case BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON:
@@ -835,15 +915,24 @@ u8 halbtcoutsrc_Set(void *pBtcContext, u8 setType, void *pInBuf)
 			break;
 
 		case BTC_SET_ACT_SEND_MIMO_PS:
-#if 0 // not implement yet
 			{
-				u8 newMimoPsMode = *pU1Tmp;
+                                u8 newMimoPsMode = 3;
+                                struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	                        struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+                                // *pU1Tmp = 0 use SM_PS static type 
+                                // *pU1Tmp = 1 disable SM_PS
+                                if(*pU1Tmp==0)
+                        		newMimoPsMode = WLAN_HT_CAP_SM_PS_STATIC;
+                        	else if(*pU1Tmp==1)
+                        		newMimoPsMode = WLAN_HT_CAP_SM_PS_DISABLED;
+                                                  
 				if (check_fwstate(&padapter->mlmepriv, WIFI_ASOC_STATE) == _TRUE)
-					SendMimoPsFrame(padapter, padapter->MgntInfo.Bssid, newMimoPsMode);
+				{
+					//issue_action_SM_PS(padapter, get_my_bssid(&(pmlmeinfo->network)), newMimoPsMode);
+                                        issue_action_SM_PS_wait_ack(padapter, get_my_bssid(&(pmlmeinfo->network)), newMimoPsMode, 3, 1);
+				}
 			}
-#else
-			ret = _FALSE;
-#endif
 			break;
 
 		case BTC_SET_ACT_CTRL_BT_INFO:
@@ -877,7 +966,21 @@ u8 halbtcoutsrc_Set(void *pBtcContext, u8 setType, void *pInBuf)
 			ret = _FALSE;
 #endif
 			break;
-
+		case BTC_SET_ACT_CTRL_8723B_ANT:
+#if 0
+			{
+				u1Byte	dataLen=*pU1Tmp;
+				u1Byte	tmpBuf[20];
+				if(dataLen)
+				{
+					PlatformMoveMemory(&tmpBuf[0], pU1Tmp+1, dataLen);
+				}
+				BT_Set8723bAnt(Adapter, dataLen, &tmpBuf[0]);
+			}
+#else
+			ret = _FALSE;
+#endif
+			break;
 		//=====================
 		default:
 			ret = _FALSE;
@@ -887,6 +990,48 @@ u8 halbtcoutsrc_Set(void *pBtcContext, u8 setType, void *pInBuf)
 	return ret;
 }
 
+u8 halbtcoutsrc_UnderIps(PBTC_COEXIST pBtCoexist)
+{
+	PADAPTER padapter;
+	struct pwrctrl_priv *pwrpriv;
+	u8 bMacPwrCtrlOn;
+
+	padapter = pBtCoexist->Adapter;
+	pwrpriv = &padapter->dvobj->pwrctl_priv;
+	bMacPwrCtrlOn = _FALSE;
+
+	if ((_TRUE == pwrpriv->bips_processing)
+		&& (IPS_NONE != pwrpriv->ips_mode_req)
+		)
+	{
+		return _TRUE;
+	}
+
+	if (rf_off == pwrpriv->rf_pwrstate)
+	{
+		return _TRUE;
+	}
+
+	rtw_hal_get_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);
+	if (_FALSE == bMacPwrCtrlOn)
+	{
+		return _TRUE;
+	}
+
+	return _FALSE;
+}
+
+u8 halbtcoutsrc_UnderLps(PBTC_COEXIST pBtCoexist)
+{
+	return GLBtcWiFiInLPS;
+}
+
+u8 halbtcoutsrc_Under32K(PBTC_COEXIST pBtCoexist)
+{
+	/* todo: the method to check whether wifi is under 32K or not */
+	return _FALSE;
+}
+
 void halbtcoutsrc_DisplayCoexStatistics(PBTC_COEXIST pBtCoexist)
 {
 #if 0
@@ -909,14 +1054,24 @@ void halbtcoutsrc_DisplayCoexStatistics(PBTC_COEXIST pBtCoexist)
 			CL_PRINTF(cliBuf);
 		}
 	}
-
+#else
+		for(i=0; i<IO_STATUS_MAX; i++)
+		{
+			if(Adapter->ioComStr.ioH2cStatistics[i])
+			{
+				CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = [%s] = %d", "H2C statistics", \
+					ioStaString[i], Adapter->ioComStr.ioH2cStatistics[i]);
+				CL_PRINTF(cliBuf);
+			}
+		}
+#endif
+#if 0
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x", "lastHMEBoxNum", \
 		pHalData->LastHMEBoxNum);
 	CL_PRINTF(cliBuf);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x / 0x%x", "LastSuccessFwEid/FirstfailedFwEid", \
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = 0x%x / 0x%x", "LastOkH2c/FirstFailH2c(fwNotRead)", \
 		pHalData->lastSuccessH2cEid, pHalData->firstFailedH2cEid);
 	CL_PRINTF(cliBuf);
-#endif
 
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d", "c2hIsr/c2hIntr/clr1AF/noRdy/noBuf", \
 		pHalData->InterruptLog.nIMR_C2HCMD, DBG_Var.c2hInterruptCnt, DBG_Var.c2hClrReadC2hCnt,
@@ -926,12 +1081,13 @@ void halbtcoutsrc_DisplayCoexStatistics(PBTC_COEXIST pBtCoexist)
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d", "c2hPacket", \
 		DBG_Var.c2hPacketCnt);
 	CL_PRINTF(cliBuf);
-
+#endif
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Periodical/ DbgCtrl", \
 		pBtCoexist->statistics.cntPeriodical, pBtCoexist->statistics.cntDbgCtrl);
 	CL_PRINTF(cliBuf);
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "InitHw/InitCoexDm/", \
-		pBtCoexist->statistics.cntInitHwConfig, pBtCoexist->statistics.cntInitCoexDm);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d", "PowerOn/InitHw/InitCoexDm/RfStatus", \
+		pBtCoexist->statistics.cntPowerOn, pBtCoexist->statistics.cntInitHwConfig, pBtCoexist->statistics.cntInitCoexDm,
+		pBtCoexist->statistics.cntRfStatusNotify);
 	CL_PRINTF(cliBuf);
 	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d", "Ips/Lps/Scan/Connect/Mstatus", \
 		pBtCoexist->statistics.cntIpsNotify, pBtCoexist->statistics.cntLpsNotify,
@@ -976,17 +1132,95 @@ void halbtcoutsrc_DisplayBtLinkInfo(PBTC_COEXIST pBtCoexist)
 #endif
 }
 
-void halbtcoutsrc_DisplayFwPwrModeCmd(PBTC_COEXIST pBtCoexist)
+void halbtcoutsrc_DisplayWifiStatus(PBTC_COEXIST pBtCoexist)
 {
-	u8 *cliBuf = pBtCoexist->cliBuf;
+	PADAPTER	padapter = pBtCoexist->Adapter;
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	u8* 			cliBuf=pBtCoexist->cliBuf;
+	s32			wifiRssi=0, btHsRssi=0;
+	BOOLEAN	bScan=_FALSE, bLink=_FALSE, bRoam=_FALSE, bWifiBusy=_FALSE, bWifiUnderBMode=_FALSE;
+	u32			wifiBw=BTC_WIFI_BW_HT20, wifiTrafficDir=BTC_WIFI_TRAFFIC_TX, wifiFreq=BTC_FREQ_2_4G;
+	u32			wifiLinkStatus=0x0;
+	BOOLEAN	bBtHsOn=_FALSE, bLowPower=_FALSE;
+	u8			wifiChnl=0, wifiHsChnl=0, nScanAPNum = 0, FwPSState;
+
+	wifiLinkStatus = halbtcoutsrc_GetWifiLinkStatus(pBtCoexist);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d/ %d/ %d", "STA/vWifi/HS/p2pGo/p2pGc", \
+		((wifiLinkStatus&WIFI_STA_CONNECTED)? 1:0), ((wifiLinkStatus&WIFI_AP_CONNECTED)? 1:0), 
+		((wifiLinkStatus&WIFI_HS_CONNECTED)? 1:0), ((wifiLinkStatus&WIFI_P2P_GO_CONNECTED)? 1:0), 
+		((wifiLinkStatus&WIFI_P2P_GC_CONNECTED)? 1:0) );
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_HS_OPERATION, &bBtHsOn);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifiChnl);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifiHsChnl);	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d / %d(%d)", "Dot11 channel / HsChnl(High Speed)", \
+		wifiChnl, wifiHsChnl, bBtHsOn);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_WIFI_RSSI, &wifiRssi);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_S4_HS_RSSI, &btHsRssi);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d", "Wifi rssi/ HS rssi", \
+		wifiRssi-100, btHsRssi-100);
+	CL_PRINTF(cliBuf);
+
 
-	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x %02x ", "Power mode cmd ", \
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_SCAN, &bScan);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_LINK, &bLink);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_ROAM, &bRoam);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %d/ %d/ %d ", "Wifi bLink/ bRoam/ bScan", \
+		bLink, bRoam, bScan);
+	CL_PRINTF(cliBuf);
+
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifiFreq);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_BW, &wifiBw);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_BUSY, &bWifiBusy);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION, &wifiTrafficDir);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_BL_WIFI_UNDER_B_MODE, &bWifiUnderBMode);
+	pBtCoexist->fBtcGet(pBtCoexist, BTC_GET_U1_AP_NUM, &nScanAPNum);
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s / %s/ %s/ AP=%d ", "Wifi freq/ bw/ traffic", \
+		GLBtcWifiFreqString[wifiFreq], ((bWifiUnderBMode)? "11b": GLBtcWifiBwString[wifiBw]),
+		((!bWifiBusy)? "idle": ((BTC_WIFI_TRAFFIC_TX==wifiTrafficDir)? "uplink":"downlink")), 
+		nScanAPNum);
+	CL_PRINTF(cliBuf);
+
+	// power status
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %s%s%s", "Power Status", \
+		((halbtcoutsrc_UnderIps(pBtCoexist) == _TRUE)? "IPS ON":"IPS OFF"),
+		((halbtcoutsrc_UnderLps(pBtCoexist) == _TRUE)? ", LPS ON":", LPS OFF"), 
+		((halbtcoutsrc_Under32K(pBtCoexist) == _TRUE)? ", 32k":""));
+	CL_PRINTF(cliBuf);
+
+	CL_SPRINTF(cliBuf, BT_TMP_BUF_SIZE, "\r\n %-35s = %02x %02x %02x %02x %02x %02x (0x%x/0x%x)", "Power mode cmd(lps/rpwm)", \
 		pBtCoexist->pwrModeVal[0], pBtCoexist->pwrModeVal[1],
 		pBtCoexist->pwrModeVal[2], pBtCoexist->pwrModeVal[3],
-		pBtCoexist->pwrModeVal[4], pBtCoexist->pwrModeVal[5]);
+		pBtCoexist->pwrModeVal[4], pBtCoexist->pwrModeVal[5],
+		pBtCoexist->btInfo.lpsVal, 
+		pBtCoexist->btInfo.rpwmVal);
 	CL_PRINTF(cliBuf);
 }
 
+void halbtcoutsrc_DisplayDbgMsg(void *pBtcContext, u8 dispType)
+{
+	PBTC_COEXIST pBtCoexist;
+
+
+	pBtCoexist = (PBTC_COEXIST)pBtcContext;
+	switch(dispType)
+	{
+		case BTC_DBG_DISP_COEX_STATISTICS:
+			halbtcoutsrc_DisplayCoexStatistics(pBtCoexist);
+			break;
+		case BTC_DBG_DISP_BT_LINK_INFO:
+			halbtcoutsrc_DisplayBtLinkInfo(pBtCoexist);
+			break;
+		case BTC_DBG_DISP_WIFI_STATUS:
+			halbtcoutsrc_DisplayWifiStatus(pBtCoexist);
+			break;
+		default:
+			break;
+	}
+}
+
 //====================================
 //		IO related function
 //====================================
@@ -1051,7 +1285,7 @@ void halbtcoutsrc_BitMaskWrite1Byte(void *pBtcContext, u32 regAddr, u8 bitMask,
 	originalValue = 0;
 	bitShift = 0;
 
-	if (bitMask != 0xFF)
+	if(bitMask != 0xff)
 	{
 		originalValue = rtw_read8(padapter, regAddr);
 
@@ -1092,6 +1326,21 @@ void halbtcoutsrc_Write4Byte(void *pBtcContext, u32 RegAddr, u32 Data)
 	rtw_write32(padapter, RegAddr, Data);
 }
 
+void halbtcoutsrc_WriteLocalReg1Byte(void *pBtcContext, u32 RegAddr, u8 Data)
+{
+	PBTC_COEXIST		pBtCoexist=(PBTC_COEXIST)pBtcContext;
+	PADAPTER			Adapter=pBtCoexist->Adapter;
+
+	if(BTC_INTF_SDIO == pBtCoexist->chipInterface)
+	{
+		rtw_write8(Adapter, SDIO_LOCAL_BASE | RegAddr, Data);
+	}
+	else
+	{
+		rtw_write8(Adapter, RegAddr, Data);
+	}
+}
+
 void halbtcoutsrc_SetBbReg(void *pBtcContext, u32 RegAddr, u32 BitMask, u32 Data)
 {
 	PBTC_COEXIST pBtCoexist;
@@ -1174,6 +1423,12 @@ void halbtcoutsrc_SetBtReg(void *pBtcContext, u8 RegType, u32 RegAddr, u32 Data)
 	}
 }
 
+u32 halbtcoutsrc_GetBtReg(void *pBtcContext, u8 RegType, u32 RegAddr)
+{
+	/* To be implemented. Always return 0 temporarily */
+	return 0;
+}
+
 void halbtcoutsrc_FillH2cCmd(void *pBtcContext, u8 elementId, u32 cmdLen, u8 *pCmdBuffer)
 {
 	PBTC_COEXIST pBtCoexist;
@@ -1186,76 +1441,51 @@ void halbtcoutsrc_FillH2cCmd(void *pBtcContext, u8 elementId, u32 cmdLen, u8 *pC
 	rtw_hal_fill_h2c_cmd(padapter, elementId, cmdLen, pCmdBuffer);
 }
 
-void halbtcoutsrc_DisplayDbgMsg(void *pBtcContext, u8 dispType)
-{
-	PBTC_COEXIST pBtCoexist;
-
-
-	pBtCoexist = (PBTC_COEXIST)pBtcContext;
-	switch(dispType)
-	{
-		case BTC_DBG_DISP_COEX_STATISTICS:
-			halbtcoutsrc_DisplayCoexStatistics(pBtCoexist);
-			break;
-		case BTC_DBG_DISP_BT_LINK_INFO:
-			halbtcoutsrc_DisplayBtLinkInfo(pBtCoexist);
-			break;
-		case BTC_DBG_DISP_FW_PWR_MODE_CMD:
-			halbtcoutsrc_DisplayFwPwrModeCmd(pBtCoexist);
-			break;
-		default:
-			break;
-	}
-}
-
-u8 halbtcoutsrc_UnderIps(PBTC_COEXIST pBtCoexist)
+//====================================
+//		Extern functions called by other module
+//====================================
+u8 EXhalbtcoutsrc_BindBtCoexWithAdapter(void *padapter)
 {
-	PADAPTER padapter;
-	struct pwrctrl_priv *pwrpriv;
-	u8 bMacPwrCtrlOn;
-
-	padapter = pBtCoexist->Adapter;
-	pwrpriv = &padapter->dvobj->pwrctl_priv;
-	bMacPwrCtrlOn = _FALSE;
+	PBTC_COEXIST		pBtCoexist=&GLBtCoexist;
+	u1Byte	antNum=2, chipType;
+	
+	if(pBtCoexist->bBinded)
+		return _FALSE;
+	else
+		pBtCoexist->bBinded = _TRUE;
 
-	if ((_TRUE == pwrpriv->bips_processing)
-		&& (IPS_NONE != pwrpriv->ips_mode_req)
-		)
-	{
-		return _TRUE;
-	}
+	pBtCoexist->statistics.cntBind++;
+	
+	pBtCoexist->Adapter = padapter;
+	
+	pBtCoexist->stackInfo.bProfileNotified = _FALSE;
 
-	if (rf_off == pwrpriv->rf_pwrstate)
-	{
-		return _TRUE;
-	}
+	pBtCoexist->btInfo.bBtCtrlAggBufSize = _FALSE;
+	pBtCoexist->btInfo.aggBufSize = 5;
 
-	rtw_hal_get_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);
-	if (_FALSE == bMacPwrCtrlOn)
-	{
-		return _TRUE;
-	}
+	pBtCoexist->btInfo.bIncreaseScanDevNum = _FALSE;
+	pBtCoexist->btInfo.bMiracastPlusBt = _FALSE;
 
-	return _FALSE;
+#if 0
+	chipType = HALBT_GetBtChipType(Adapter);
+	EXhalbtcoutsrc_SetChipType(chipType);
+	antNum = HALBT_GetPgAntNum(Adapter);
+	EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_PG, antNum);
+#endif
+	// set default antenna position to main  port
+	pBtCoexist->boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;	
+	
+	return _TRUE;
 }
 
-//====================================
-//		Extern functions called by other module
-//====================================
 u8 EXhalbtcoutsrc_InitlizeVariables(void *padapter)
 {
 	PBTC_COEXIST pBtCoexist = &GLBtCoexist;
 
-
-	pBtCoexist->statistics.cntBind++;
+	//pBtCoexist->statistics.cntBind++;
 
 	halbtcoutsrc_DbgInit();
 
-	if (pBtCoexist->bBinded)
-		return _FALSE;
-	else
-		pBtCoexist->bBinded = _TRUE;
-
 #ifdef CONFIG_PCI_HCI
 	pBtCoexist->chipInterface = BTC_INTF_PCI;
 #elif defined(CONFIG_USB_HCI)
@@ -1266,12 +1496,7 @@ u8 EXhalbtcoutsrc_InitlizeVariables(void *padapter)
 	pBtCoexist->chipInterface = BTC_INTF_UNKNOWN;
 #endif
 
-	if (NULL == pBtCoexist->Adapter)
-	{
-		pBtCoexist->Adapter = padapter;
-	}
-
-	pBtCoexist->stackInfo.bProfileNotified = _FALSE;
+	EXhalbtcoutsrc_BindBtCoexWithAdapter(padapter);
 
 	pBtCoexist->fBtcRead1Byte = halbtcoutsrc_Read1Byte;
 	pBtCoexist->fBtcWrite1Byte = halbtcoutsrc_Write1Byte;
@@ -1280,6 +1505,7 @@ u8 EXhalbtcoutsrc_InitlizeVariables(void *padapter)
 	pBtCoexist->fBtcWrite2Byte = halbtcoutsrc_Write2Byte;
 	pBtCoexist->fBtcRead4Byte = halbtcoutsrc_Read4Byte;
 	pBtCoexist->fBtcWrite4Byte = halbtcoutsrc_Write4Byte;
+	pBtCoexist->fBtcWriteLocalReg1Byte = halbtcoutsrc_WriteLocalReg1Byte;
 
 	pBtCoexist->fBtcSetBbReg = halbtcoutsrc_SetBbReg;
 	pBtCoexist->fBtcGetBbReg = halbtcoutsrc_GetBbReg;
@@ -1287,29 +1513,61 @@ u8 EXhalbtcoutsrc_InitlizeVariables(void *padapter)
 	pBtCoexist->fBtcSetRfReg = halbtcoutsrc_SetRfReg;
 	pBtCoexist->fBtcGetRfReg = halbtcoutsrc_GetRfReg;
 
-	pBtCoexist->fBtcSetBtReg = halbtcoutsrc_SetBtReg;
-
 	pBtCoexist->fBtcFillH2c = halbtcoutsrc_FillH2cCmd;
 	pBtCoexist->fBtcDispDbgMsg = halbtcoutsrc_DisplayDbgMsg;
 
 	pBtCoexist->fBtcGet = halbtcoutsrc_Get;
 	pBtCoexist->fBtcSet = halbtcoutsrc_Set;
+	pBtCoexist->fBtcGetBtReg = halbtcoutsrc_GetBtReg;
+	pBtCoexist->fBtcSetBtReg = halbtcoutsrc_SetBtReg;
 
-	pBtCoexist->cliBuf = GLBtcDbgBuf;
-
-	pBtCoexist->btInfo.bBtCtrlAggBufSize = _FALSE;
-	pBtCoexist->btInfo.aggBufSize = 5;
-
-	pBtCoexist->btInfo.bIncreaseScanDevNum = _FALSE;
+	pBtCoexist->cliBuf = &GLBtcDbgBuf[0];
 
+	pBtCoexist->boardInfo.singleAntPath = 0;
+	
 	GLBtcWiFiInScanState = _FALSE;
 
 	GLBtcWiFiInIQKState = _FALSE;
 
+	GLBtcWiFiInIPS = _FALSE;
+
+	GLBtcWiFiInLPS = _FALSE;
+
 	return _TRUE;
 }
 
-void EXhalbtcoutsrc_InitHwConfig(PBTC_COEXIST pBtCoexist)
+void EXhalbtcoutsrc_PowerOnSetting(PBTC_COEXIST pBtCoexist)
+{
+	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+
+	/* Power on setting function is only added in 8723B currently */
+	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter))
+	{
+		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+			EXhalbtc8723b2ant_PowerOnSetting(pBtCoexist);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
+			EXhalbtc8723b1ant_PowerOnSetting(pBtCoexist);
+	}
+}
+
+void EXhalbtcoutsrc_PreLoadFirmware(PBTC_COEXIST pBtCoexist)
+{
+	if(!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	
+	pBtCoexist->statistics.cntPreLoadFirmware++;
+
+	if(IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter))
+	{
+		if(pBtCoexist->boardInfo.btdmAntNum == 2)
+			EXhalbtc8723b2ant_PreLoadFirmware(pBtCoexist);
+		else if(pBtCoexist->boardInfo.btdmAntNum == 1)
+			EXhalbtc8723b1ant_PreLoadFirmware(pBtCoexist);
+	}
+}
+
+void EXhalbtcoutsrc_InitHwConfig(PBTC_COEXIST pBtCoexist, u8 bWifiOnly)
 {
 	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
 		return;
@@ -1318,46 +1576,48 @@ void EXhalbtcoutsrc_InitHwConfig(PBTC_COEXIST pBtCoexist)
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
-			EXhalbtc8821a2ant_InitHwConfig(pBtCoexist);
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_InitHwConfig(pBtCoexist, bWifiOnly);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
+			EXhalbtc8821a2ant_InitHwConfig(pBtCoexist, bWifiOnly);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
-			EXhalbtc8821a1ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8821a1ant_InitHwConfig(pBtCoexist, bWifiOnly);
 	}
 	else if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter))
 	{
 		if (pBtCoexist->boardInfo.btdmAntNum == 2)
-			EXhalbtc8723b2ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8723b2ant_InitHwConfig(pBtCoexist, bWifiOnly);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
-			EXhalbtc8723b1ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8723b1ant_InitHwConfig(pBtCoexist, bWifiOnly);
 	}
 	else if (IS_HARDWARE_TYPE_8723A(pBtCoexist->Adapter))
 	{
 		if (pBtCoexist->boardInfo.btdmAntNum == 2)
-			EXhalbtc8723a2ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8723a2ant_InitHwConfig(pBtCoexist, bWifiOnly);
 	}
 	else if (IS_HARDWARE_TYPE_8192C(pBtCoexist->Adapter))
 	{
 		if (pBtCoexist->boardInfo.btdmAntNum == 2)
-			EXhalbtc8188c2ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8188c2ant_InitHwConfig(pBtCoexist, bWifiOnly);
 	}
 	else if (IS_HARDWARE_TYPE_8192D(pBtCoexist->Adapter))
 	{
 		if (pBtCoexist->boardInfo.btdmAntNum == 2)
-			EXhalbtc8192d2ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8192d2ant_InitHwConfig(pBtCoexist, bWifiOnly);
 	}
 	else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter))
 	{
 		if (pBtCoexist->boardInfo.btdmAntNum == 2)
-			EXhalbtc8192e2ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8192e2ant_InitHwConfig(pBtCoexist, bWifiOnly);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
-			EXhalbtc8192e1ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8192e1ant_InitHwConfig(pBtCoexist, bWifiOnly);
 	}
 	else if (IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter))
 	{
 		if (pBtCoexist->boardInfo.btdmAntNum == 2)
-			EXhalbtc8812a2ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8812a2ant_InitHwConfig(pBtCoexist, bWifiOnly);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
-			EXhalbtc8812a1ant_InitHwConfig(pBtCoexist);
+			EXhalbtc8812a1ant_InitHwConfig(pBtCoexist, bWifiOnly);
 	}
 }
 
@@ -1370,7 +1630,9 @@ void EXhalbtcoutsrc_InitCoexDm(PBTC_COEXIST pBtCoexist)
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_InitCoexDm(pBtCoexist);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_InitCoexDm(pBtCoexist);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_InitCoexDm(pBtCoexist);
@@ -1427,16 +1689,24 @@ void EXhalbtcoutsrc_IpsNotify(PBTC_COEXIST pBtCoexist, u8 type)
 		return;
 
 	if (IPS_NONE == type)
+	{
 		ipsType = BTC_IPS_LEAVE;
+		GLBtcWiFiInIPS = _FALSE;
+	}
 	else
+	{
 		ipsType = BTC_IPS_ENTER;
-
+		GLBtcWiFiInIPS = _TRUE;
+	}
+	
 	// All notify is called in cmd thread, don't need to leave low power again
 //	halbtcoutsrc_LeaveLowPower(pBtCoexist);
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_IpsNotify(pBtCoexist, ipsType);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_IpsNotify(pBtCoexist, ipsType);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_IpsNotify(pBtCoexist, ipsType);
@@ -1494,13 +1764,21 @@ void EXhalbtcoutsrc_LpsNotify(PBTC_COEXIST pBtCoexist, u8 type)
 		return;
 
 	if (PS_MODE_ACTIVE == type)
+	{
 		lpsType = BTC_LPS_DISABLE;
+		GLBtcWiFiInLPS = _FALSE;
+	}
 	else
+	{
 		lpsType = BTC_LPS_ENABLE;
-
+		GLBtcWiFiInLPS = _TRUE;
+	}
+	
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_LpsNotify(pBtCoexist, lpsType);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_LpsNotify(pBtCoexist, lpsType);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_LpsNotify(pBtCoexist, lpsType);
@@ -1569,7 +1847,9 @@ void EXhalbtcoutsrc_ScanNotify(PBTC_COEXIST pBtCoexist, u8 type)
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_ScanNotify(pBtCoexist, scanType);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_ScanNotify(pBtCoexist, scanType);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_ScanNotify(pBtCoexist, scanType);
@@ -1634,7 +1914,9 @@ void EXhalbtcoutsrc_ConnectNotify(PBTC_COEXIST pBtCoexist, u8 action)
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_ConnectNotify(pBtCoexist, assoType);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_ConnectNotify(pBtCoexist, assoType);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_ConnectNotify(pBtCoexist, assoType);
@@ -1700,7 +1982,9 @@ void EXhalbtcoutsrc_MediaStatusNotify(PBTC_COEXIST pBtCoexist, RT_MEDIA_STATUS m
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_MediaStatusNotify(pBtCoexist, mStatus);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_MediaStatusNotify(pBtCoexist, mStatus);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_MediaStatusNotify(pBtCoexist, mStatus);
@@ -1772,7 +2056,9 @@ void EXhalbtcoutsrc_SpecialPacketNotify(PBTC_COEXIST pBtCoexist, u8 pktType)
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_SpecialPacketNotify(pBtCoexist, packetType);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_SpecialPacketNotify(pBtCoexist, packetType);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_SpecialPacketNotify(pBtCoexist, packetType);
@@ -1829,7 +2115,9 @@ void EXhalbtcoutsrc_BtInfoNotify(PBTC_COEXIST pBtCoexist, u8 *tmpBuf, u8 length)
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_BtInfoNotify(pBtCoexist, tmpBuf, length);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_BtInfoNotify(pBtCoexist, tmpBuf, length);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_BtInfoNotify(pBtCoexist, tmpBuf, length);
@@ -1874,6 +2162,32 @@ void EXhalbtcoutsrc_BtInfoNotify(PBTC_COEXIST pBtCoexist, u8 *tmpBuf, u8 length)
 //	halbtcoutsrc_NormalLowPower(pBtCoexist);
 }
 
+VOID
+EXhalbtcoutsrc_RfStatusNotify(
+	IN	PBTC_COEXIST		pBtCoexist,
+	IN	u1Byte 				type
+	)
+{
+	if(!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
+		return;
+	pBtCoexist->statistics.cntRfStatusNotify++;
+	
+	if(IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
+	{
+	}
+	else if(IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter))
+	{
+		if(pBtCoexist->boardInfo.btdmAntNum == 1)
+			EXhalbtc8723b1ant_RfStatusNotify(pBtCoexist, type);
+	}	
+	else if(IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter))
+	{
+	}
+	else if(IS_HARDWARE_TYPE_8812(pBtCoexist->Adapter))
+	{
+	}
+}
+
 void EXhalbtcoutsrc_StackOperationNotify(PBTC_COEXIST pBtCoexist, u8 type)
 {
 #if 0
@@ -1918,7 +2232,9 @@ void EXhalbtcoutsrc_HaltNotify(PBTC_COEXIST pBtCoexist)
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_HaltNotify(pBtCoexist);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_HaltNotify(pBtCoexist);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_HaltNotify(pBtCoexist);
@@ -1961,9 +2277,11 @@ void EXhalbtcoutsrc_HaltNotify(PBTC_COEXIST pBtCoexist)
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8812a1ant_HaltNotify(pBtCoexist);
 	}
+
+	pBtCoexist->bBinded = FALSE;
 }
 
-void EXhalbtcoutsrc_SwitchGntBt(PBTC_COEXIST pBtCoexist)
+void EXhalbtcoutsrc_SwitchBtTRxMask(PBTC_COEXIST pBtCoexist)
 {
 	if (IS_HARDWARE_TYPE_8723B(pBtCoexist->Adapter))
 	{
@@ -1992,11 +2310,17 @@ void EXhalbtcoutsrc_PnpNotify(PBTC_COEXIST pBtCoexist, u8 pnpState)
 	{
 		if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8723b1ant_PnpNotify(pBtCoexist,pnpState);
+		else if(pBtCoexist->boardInfo.btdmAntNum == 2)
+			EXhalbtc8723b2ant_PnpNotify(pBtCoexist,pnpState);
 	}
 	else if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 1)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_PnpNotify(pBtCoexist, pnpState);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_PnpNotify(pBtCoexist,pnpState);
+		else if(pBtCoexist->boardInfo.btdmAntNum == 2)
+			EXhalbtc8821a2ant_PnpNotify(pBtCoexist,pnpState);
 	}
 	else if (IS_HARDWARE_TYPE_8192E(pBtCoexist->Adapter))
 	{
@@ -2010,7 +2334,7 @@ void EXhalbtcoutsrc_PnpNotify(PBTC_COEXIST pBtCoexist, u8 pnpState)
 	}
 }
 
-void EXhalbtcoutsrc_CoexDmSwitch(PBTC_COEXIST pBtCoexist, BOOLEAN antInverse)
+void EXhalbtcoutsrc_CoexDmSwitch(PBTC_COEXIST pBtCoexist)
 {
 	if (!halbtcoutsrc_IsBtCoexistAvailable(pBtCoexist))
 		return;
@@ -2024,8 +2348,8 @@ void EXhalbtcoutsrc_CoexDmSwitch(PBTC_COEXIST pBtCoexist, BOOLEAN antInverse)
 		{
 			pBtCoexist->bStopCoexDm = TRUE;
 			EXhalbtc8723b1ant_CoexDmReset(pBtCoexist);
-			EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_DETECTED, 2, antInverse);
-			EXhalbtc8723b2ant_InitHwConfig(pBtCoexist);
+			EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_DETECTED, 2);
+			EXhalbtc8723b2ant_InitHwConfig(pBtCoexist, FALSE);
 			EXhalbtc8723b2ant_InitCoexDm(pBtCoexist);
 			pBtCoexist->bStopCoexDm = FALSE;
 		}
@@ -2046,7 +2370,9 @@ void EXhalbtcoutsrc_Periodical(PBTC_COEXIST pBtCoexist)
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_Periodical(pBtCoexist);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_Periodical(pBtCoexist);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 		{
@@ -2219,11 +2545,12 @@ void EXhalbtcoutsrc_SetBtPatchVersion(u16 btHciVersion, u16 btPatchVersion)
 	pBtCoexist->btInfo.btHciVer = btHciVersion;
 }
 
+#if 0
 void EXhalbtcoutsrc_SetBtExist(u8 bBtExist)
 {
 	GLBtCoexist.boardInfo.bBtExist = bBtExist;
 }
-
+#endif
 void EXhalbtcoutsrc_SetChipType(u8 chipType)
 {
 	switch(chipType)
@@ -2253,13 +2580,13 @@ void EXhalbtcoutsrc_SetChipType(u8 chipType)
 	}
 }
 
-void EXhalbtcoutsrc_SetAntNum(u8 type, u8 antNum, BOOLEAN antInverse)
+void EXhalbtcoutsrc_SetAntNum(u8 type, u8 antNum)
 {
 	if (BT_COEX_ANT_TYPE_PG == type)
 	{
 		GLBtCoexist.boardInfo.pgAntNum = antNum;
 		GLBtCoexist.boardInfo.btdmAntNum = antNum;
-
+#if 0
 		//The antenna position: Main (default) or Aux for pgAntNum=2 && btdmAntNum =1
 		//The antenna position should be determined by auto-detect mechanism
 		// The following is assumed to main, and those must be modified if y auto-detect mechanism is ready
@@ -2267,22 +2594,26 @@ void EXhalbtcoutsrc_SetAntNum(u8 type, u8 antNum, BOOLEAN antInverse)
 			GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;
 		else
 			GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;
+#endif
 	}
 	else if (BT_COEX_ANT_TYPE_ANTDIV == type)
 	{
 		GLBtCoexist.boardInfo.btdmAntNum = antNum;
-		GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;
+		//GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;	
 	}
 	else if (BT_COEX_ANT_TYPE_DETECTED == type)
 	{
 		GLBtCoexist.boardInfo.btdmAntNum = antNum;
-		GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;
+		//GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_MAIN_PORT;
 	}
+}
 
-	if (antInverse == _TRUE)
-	{
-		GLBtCoexist.boardInfo.btdmAntPos = BTC_ANTENNA_AT_AUX_PORT;
-	}
+//
+// Currently used by 8723b only, S0 or S1
+//
+void EXhalbtcoutsrc_SetSingleAntPath(u8 singleAntPath)
+{
+	GLBtCoexist.boardInfo.singleAntPath = singleAntPath;
 }
 
 void EXhalbtcoutsrc_DisplayBtCoexInfo(PBTC_COEXIST pBtCoexist)
@@ -2294,7 +2625,9 @@ void EXhalbtcoutsrc_DisplayBtCoexInfo(PBTC_COEXIST pBtCoexist)
 
 	if (IS_HARDWARE_TYPE_8821(pBtCoexist->Adapter))
 	{
-		if (pBtCoexist->boardInfo.btdmAntNum == 2)
+		if (halbtcoutsrc_IsCsrBtCoex(pBtCoexist) == _TRUE)
+			EXhalbtc8821aCsr2ant_DisplayCoexInfo(pBtCoexist);
+		else if (pBtCoexist->boardInfo.btdmAntNum == 2)
 			EXhalbtc8821a2ant_DisplayCoexInfo(pBtCoexist);
 		else if (pBtCoexist->boardInfo.btdmAntNum == 1)
 			EXhalbtc8821a1ant_DisplayCoexInfo(pBtCoexist);
@@ -2405,7 +2738,7 @@ void hal_btcoex_SetBTCoexist(PADAPTER padapter, u8 bBtExist)
 	pHalData = GET_HAL_DATA(padapter);
 	pHalData->bt_coexist.bBtExist = bBtExist;
 
-	EXhalbtcoutsrc_SetBtExist(bBtExist);
+	//EXhalbtcoutsrc_SetBtExist(bBtExist);
 }
 
 /*
@@ -2456,7 +2789,7 @@ u8 hal_btcoex_GetChipType(PADAPTER padapter)
 	return pHalData->bt_coexist.btChipType;
 }
 
-void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum, BOOLEAN antInverse)
+void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum)
 {
 	PHAL_DATA_TYPE	pHalData;
 
@@ -2464,7 +2797,7 @@ void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum, BOOLEAN antInverse)
 	pHalData = GET_HAL_DATA(padapter);
 
 	pHalData->bt_coexist.btTotalAntNum = antNum;
-	EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_PG, antNum, antInverse);
+	EXhalbtcoutsrc_SetAntNum(BT_COEX_ANT_TYPE_PG, antNum);
 }
 
 u8 hal_btcoex_GetPgAntNum(PADAPTER padapter)
@@ -2477,6 +2810,11 @@ u8 hal_btcoex_GetPgAntNum(PADAPTER padapter)
 	return pHalData->bt_coexist.btTotalAntNum;
 }
 
+void hal_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath)
+{
+	EXhalbtcoutsrc_SetSingleAntPath(singleAntPath);
+}
+
 u8 hal_btcoex_Initialize(PADAPTER padapter)
 {
 	u8 ret1;
@@ -2490,7 +2828,17 @@ u8 hal_btcoex_Initialize(PADAPTER padapter)
 	return ret2;
 }
 
-void hal_btcoex_InitHwConfig(PADAPTER padapter)
+void hal_btcoex_PowerOnSetting(PADAPTER padapter)
+{
+	EXhalbtcoutsrc_PowerOnSetting(&GLBtCoexist);
+}
+
+void hal_btcoex_PreLoadFirmware(PADAPTER padapter)
+{
+	EXhalbtcoutsrc_PreLoadFirmware(&GLBtCoexist);
+}
+
+void hal_btcoex_InitHwConfig(PADAPTER padapter, u8 bWifiOnly)
 {
 	if (!hal_btcoex_IsBtExist(padapter))
 		return;
@@ -2504,7 +2852,7 @@ void hal_btcoex_InitHwConfig(PADAPTER padapter)
 		halbt_InitHwConfig92D(padapter);
 	}
 
-	EXhalbtcoutsrc_InitHwConfig(&GLBtCoexist);
+	EXhalbtcoutsrc_InitHwConfig(&GLBtCoexist, bWifiOnly);
 	EXhalbtcoutsrc_InitCoexDm(&GLBtCoexist);
 }
 
@@ -2566,9 +2914,9 @@ void hal_btcoex_HaltNotify(PADAPTER padapter)
 	EXhalbtcoutsrc_HaltNotify(&GLBtCoexist);
 }
 
-void hal_btcoex_SwitchGntBt(PADAPTER padapter)
+void hal_btcoex_SwitchBtTRxMask(PADAPTER padapter)
 {
-	EXhalbtcoutsrc_SwitchGntBt(&GLBtCoexist);
+	EXhalbtcoutsrc_SwitchBtTRxMask(&GLBtCoexist);
 }
 
 void hal_btcoex_Hanlder(PADAPTER padapter)
@@ -2643,13 +2991,15 @@ u8 hal_btcoex_LpsVal(PADAPTER padapter)
 u32 hal_btcoex_GetRaMask(PADAPTER padapter)
 {
 	if (!hal_btcoex_IsBtExist(padapter))
-		return 0;
+                return 0;
 
 	if (GLBtCoexist.btInfo.bBtDisabled)
-		return 0;
+                return 0;
 
-	if (GLBtCoexist.boardInfo.btdmAntNum != 1)
-		return 0;
+        // Modify by YiWei , suggest by Cosa and Jenyu
+        // Remove the limit antenna number , because 2 antenna case (ex: 8192eu)also want to get BT coex report rate mask.
+	//if (GLBtCoexist.boardInfo.btdmAntNum != 1)
+        //        return 0;
 
 	return GLBtCoexist.btInfo.raMask;
 }
@@ -2831,5 +3181,183 @@ u8 hal_btcoex_IsBtLinkExist(PADAPTER padapter)
 
 	return _FALSE;
 }
+
+/*
+ * Description:
+ *	Setting BT coex antenna isolation type .
+ *                         coex mechanisn/ spital stream/ best throughput
+ *      anttype = 0  ,  PSTDMA  / 2SS / 0.5T , bad isolation      (<20dB) for 2,3 antenna
+ *      anttype = 1  ,  PSTDMA  / 1SS / 0.5T , normal isolaiton (>20dB) for 2 antenna
+ *      anttype = 2  ,  TDMA      / 2SS / T      , normal isolaiton (>20dB) for 3 antenna
+ *      anttype = 3  ,  no TDMA / 1SS / 0.5T , good isolation    (>40dB) for 2 antenna
+ *      anttype = 4  ,  no TDMA / 2SS / T      , good isolation    (>40dB) for 3 antenna
+ *    wifi only throughput ~ T
+ *    wifi/BT share one antenna with SPDT
+ */
+void hal_btcoex_SetAntIsolationType(PADAPTER padapter, u8 anttype)
+{
+        PHAL_DATA_TYPE	pHalData;
+
+        //DBG_871X("####%s , anttype = %d  , %d \n", __FUNCTION__,anttype,__LINE__);
+        pHalData = GET_HAL_DATA(padapter);
+
+
+        pHalData->bt_coexist.btAntisolation= anttype;
+
+}
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+int
+hal_btcoex_ParseAntIsolationConfigFile(
+  PADAPTER		Adapter,
+  char*			buffer
+)
+{
+        HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+        u32	i = 0 , j=0;
+        char	*szLine, *ptmp;
+        int	rtStatus = _SUCCESS;
+        char param_value_string[10];
+        u8 param_value;
+        u8 anttype = 4;
+        
+        u8 ant_num=3, ant_distance=50;
+        
+        typedef struct ant_isolation
+        {
+            char *param_name; // antenna isolation config parameter name 
+            u8 *value; // antenna isolation config parameter value
+        }ANT_ISOLATION;
+
+        ANT_ISOLATION ant_isolation_param[]= {
+                                                                                    {"ANT_NUMBER",&ant_num},
+                                                                                    {"ANT_DISTANCE",&ant_distance},
+                                                                                    {NULL,0}
+                                                                           };
+
+
+        
+	//DBG_871X("===>Hal_ParseAntIsolationConfigFile()\n" );
+                    
+	ptmp = buffer;
+	for (szLine = GetLineFromBuffer(ptmp); szLine != NULL; szLine = GetLineFromBuffer(ptmp))
+	{
+		// skip comment 
+		if ( IsCommentString( szLine ) ) {
+			continue;
+		}         
+
+                //DBG_871X("%s : szLine = %s , strlen(szLine) = %d  \n", __FUNCTION__,szLine,strlen(szLine));
+                for ( j=0 ;ant_isolation_param[j].param_name != NULL ; j++ )
+                {
+                        if ( strstr(szLine,ant_isolation_param[j].param_name)!= NULL )
+                        {
+                                i=0;
+                                while ( i < strlen(szLine) )
+                                {
+                                        if (szLine[i] != '"')
+                                                ++i;
+                                        else
+                                        {
+                                                // skip only has one "
+                                                if( strpbrk(szLine, "\"") == strrchr(szLine, '"'))
+                                                {
+                                                        DBG_871X("Fail to parse parameters , format error!\n");
+                                                        break;
+                                                }
+                                                _rtw_memset( ( PVOID ) param_value_string, 0, 10 );
+                                                if ( ! ParseQualifiedString( szLine, &i, param_value_string, '"' , '"' ) ) {
+                                                        DBG_871X("Fail to parse parameters \n");
+                                                        return _FAIL;
+                                                }
+                                                else
+                                                {
+                                                        GetU1ByteIntegerFromStringInDecimal( param_value_string, ant_isolation_param[j].value );                                              
+                                                 }
+                                                break;
+                                        }
+                                }
+                        }
+                }
+        } 
+
+        // YiWei 20140716 , for BT coex antenna isolation control
+        if ( ant_num==3 && ant_distance>=50)
+        {
+                pHalData->EEPROMBluetoothCoexist = 0;
+                anttype = 4;
+        }
+        else if ( ant_num==2 && ant_distance>=50 ) 
+        {
+                anttype = 3;
+        }
+        else if ( ant_num==3 &&  ant_distance>=15 &&  ant_distance<50  ) 
+        {
+                anttype = 2;
+        }
+        else if ( ant_num==2 && ant_distance>=15 &&  ant_distance<50 ) 
+        {
+                anttype = 1;
+        }
+        else if ( (ant_num==2 && ant_distance<15) ||  (ant_num==3 && ant_distance<15)) 
+        {
+                anttype = 0;
+        } 
+        else
+        {
+                pHalData->EEPROMBluetoothCoexist = 1;
+                anttype = 1;             
+        }
+
+        hal_btcoex_SetAntIsolationType(Adapter, anttype); 
+                                                
+        DBG_871X("%s : ant_num = %d   \n", __FUNCTION__,ant_num);
+        DBG_871X("%s : ant_distance = %d  \n", __FUNCTION__,ant_distance);
+        //DBG_871X("<===Hal_ParseAntIsolationConfigFile()\n");
+        return rtStatus;    
+}
+
+
+int
+hal_btcoex_AntIsolationConfig_ParaFile(
+	IN	PADAPTER	Adapter,
+	IN	char*	 	pFileName
+)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	int	rlen = 0, rtStatus = _FAIL;
+	//char	file_path[1024];
+
+	//if(!(Adapter->registrypriv.load_phy_file & LOAD_RF_TXPWR_LMT_PARA_FILE))
+	//	return rtStatus;
+
+	_rtw_memset(pHalData->para_file_buf, 0, MAX_PARA_FILE_BUF_LEN);
+
+
+	rtw_merge_string(file_path, PATH_LENGTH_MAX, rtw_phy_file_path, pFileName);
+
+	if (rtw_is_file_readable(file_path) == _TRUE)
+	{
+		rlen = rtw_retrive_from_file(file_path, pHalData->para_file_buf, MAX_PARA_FILE_BUF_LEN);
+		if (rlen > 0)
+		{
+			rtStatus = _SUCCESS;
+		}
+	}
+
+
+	if(rtStatus == _SUCCESS)
+	{
+		//DBG_871X("%s(): read %s ok\n", __FUNCTION__, pFileName);
+		rtStatus = hal_btcoex_ParseAntIsolationConfigFile( Adapter, pHalData->para_file_buf );
+	}
+	else
+	{
+		DBG_871X("%s(): No File %s, Load from *** Array!\n", __FUNCTION__, pFileName);
+	}
+
+	return rtStatus;
+}
+#endif // CONFIG_LOAD_PHY_PARA_FROM_FILE
 #endif // CONFIG_BT_COEXIST
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_com.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_com.c
index 655f0a3ebdf1..b8c87857f950 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_com.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_com.c
@@ -20,9 +20,45 @@
 #define _HAL_COM_C_
 
 #include <drv_types.h>
+#include "hal_com_h2c.h"
 
-#include "../hal/OUTSRC/odm_precomp.h"
+#include "hal_data.h"
 
+//#define CONFIG_GTK_OL_DBG
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+char	file_path[PATH_LENGTH_MAX];
+#endif
+
+u8 rtw_hal_data_init(_adapter *padapter)
+{
+	if(is_primary_adapter(padapter))
+	{
+		padapter->hal_data_sz = sizeof(HAL_DATA_TYPE);
+		padapter->HalData = rtw_zvmalloc(padapter->hal_data_sz);
+		if(padapter->HalData == NULL){
+			DBG_8192C("cant not alloc memory for HAL DATA \n");
+			return _FAIL;
+		}
+	}
+	return _SUCCESS;
+}
+
+void rtw_hal_data_deinit(_adapter *padapter)
+{	
+	if(is_primary_adapter(padapter))
+	{
+		if (padapter->HalData) 
+		{
+			#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+			phy_free_filebuf(padapter);				
+			#endif
+			rtw_vmfree(padapter->HalData, padapter->hal_data_sz);
+			padapter->HalData = NULL;
+			padapter->hal_data_sz = 0;
+		}	
+	}
+}
 
 void dump_chip_info(HAL_VERSION	ChipVersion)
 {
@@ -436,7 +472,7 @@ _TwoOutPipeMapping(
 		
 		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
 		//{  0, 	1, 	0, 	1, 	0, 	0, 	0, 	0, 		0	};
-		//0:H, 1:N 
+		//0:ep_0 num, 1:ep_1 num 
 		
 		pdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[1];//VO
 		pdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[0];//VI
@@ -454,7 +490,7 @@ _TwoOutPipeMapping(
 		
 		//BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
 		//{  1, 	1, 	0, 	0, 	0, 	0, 	0, 	0, 		0	};			
-		//0:H, 1:N 
+		//0:ep_0 num, 1:ep_1 num
 		
 		pdvobjpriv->Queue2Pipe[0] = pdvobjpriv->RtOutPipe[0];//VO
 		pdvobjpriv->Queue2Pipe[1] = pdvobjpriv->RtOutPipe[0];//VI
@@ -1008,280 +1044,4283 @@ void hw_var_port_switch(_adapter *adapter)
 #endif /* CONFIG_CONCURRENT_MODE */
 }
 
-void SetHwReg(_adapter *adapter, u8 variable, u8 *val)
+void rtw_hal_set_FwRsvdPage_cmd(PADAPTER padapter, PRSVDPAGE_LOC rsvdpageloc)
 {
-	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
-	DM_ODM_T *odm = &(hal_data->odmpriv);
+	struct	hal_ops *pHalFunc = &padapter->HalFunc;
+	u8	u1H2CRsvdPageParm[H2C_RSVDPAGE_LOC_LEN]={0};
+	u8	ret = 0;
+
+	DBG_871X("RsvdPageLoc: ProbeRsp=%d PsPoll=%d Null=%d QoSNull=%d BTNull=%d\n",
+		rsvdpageloc->LocProbeRsp, rsvdpageloc->LocPsPoll,
+		rsvdpageloc->LocNullData, rsvdpageloc->LocQosNull,
+		rsvdpageloc->LocBTQosNull);
+
+	SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(u1H2CRsvdPageParm, rsvdpageloc->LocProbeRsp);
+	SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(u1H2CRsvdPageParm, rsvdpageloc->LocPsPoll);
+	SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(u1H2CRsvdPageParm, rsvdpageloc->LocNullData);
+	SET_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(u1H2CRsvdPageParm, rsvdpageloc->LocQosNull);
+	SET_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(u1H2CRsvdPageParm, rsvdpageloc->LocBTQosNull);
+
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(padapter,
+				H2C_RSVD_PAGE,
+				H2C_RSVDPAGE_LOC_LEN,
+				u1H2CRsvdPageParm);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
+	}
+}
 
-_func_enter_;
+#ifdef CONFIG_GPIO_WAKEUP
+static void rtw_hal_set_output_gpio(_adapter* padapter, u8 index, u8 outputval)
+{
+	if ( index <= 7 ) {
+		/* config GPIO mode */
+		rtw_write8(padapter, REG_GPIO_PIN_CTRL + 3,
+				rtw_read8(padapter, REG_GPIO_PIN_CTRL + 3) & ~BIT(index) );
+
+		/* config GPIO Sel */
+		/* 0: input */
+		/* 1: output */
+		rtw_write8(padapter, REG_GPIO_PIN_CTRL + 2,
+				rtw_read8(padapter, REG_GPIO_PIN_CTRL + 2) | BIT(index));
+
+		/* set output value */
+		if ( outputval ) {
+			rtw_write8(padapter, REG_GPIO_PIN_CTRL + 1,
+					rtw_read8(padapter, REG_GPIO_PIN_CTRL + 1) | BIT(index));
+		} else {
+			rtw_write8(padapter, REG_GPIO_PIN_CTRL + 1,
+					rtw_read8(padapter, REG_GPIO_PIN_CTRL + 1) & ~BIT(index));
+		}
+	} else {
+		/* 88C Series: */
+		/* index: 11~8 transform to 3~0 */
+		/* 8723 Series: */
+		/* index: 12~8 transform to 4~0 */
+		index -= 8;
+
+		/* config GPIO mode */
+		rtw_write8(padapter, REG_GPIO_PIN_CTRL_2 + 3,
+				rtw_read8(padapter, REG_GPIO_PIN_CTRL_2 + 3) & ~BIT(index) );
+
+		/* config GPIO Sel */
+		/* 0: input */
+		/* 1: output */
+		rtw_write8(padapter, REG_GPIO_PIN_CTRL_2 + 2,
+				rtw_read8(padapter, REG_GPIO_PIN_CTRL_2 + 2) | BIT(index));
+
+		/* set output value */
+		if ( outputval ) {
+			rtw_write8(padapter, REG_GPIO_PIN_CTRL_2 + 1,
+					rtw_read8(padapter, REG_GPIO_PIN_CTRL_2 + 1) | BIT(index));
+		} else {
+			rtw_write8(padapter, REG_GPIO_PIN_CTRL_2 + 1,
+					rtw_read8(padapter, REG_GPIO_PIN_CTRL_2 + 1) & ~BIT(index));
+		}
+	}
 
-	switch (variable) {
-	case HW_VAR_PORT_SWITCH:
-		hw_var_port_switch(adapter);
-		break;
-	case HW_VAR_SEC_CFG:
-	{
-		#if defined(CONFIG_CONCURRENT_MODE) && !defined(DYNAMIC_CAMID_ALLOC)
-		// enable tx enc and rx dec engine, and no key search for MC/BC
-		rtw_write8(adapter, REG_SECCFG, SCR_NoSKMC|SCR_RxDecEnable|SCR_TxEncEnable);
-		#elif defined(DYNAMIC_CAMID_ALLOC)
-		u16 reg_scr;
+}
+#endif
 
-		reg_scr = rtw_read16(adapter, REG_SECCFG);
-		rtw_write16(adapter, REG_SECCFG, reg_scr|SCR_CHK_KEYID|SCR_RxDecEnable|SCR_TxEncEnable);
-		#else
-		rtw_write8(adapter, REG_SECCFG, *((u8*)val));
-		#endif
+void rtw_hal_set_FwAoacRsvdPage_cmd(PADAPTER padapter, PRSVDPAGE_LOC rsvdpageloc)
+{
+	struct	hal_ops *pHalFunc = &padapter->HalFunc;
+	struct	pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	u8	res = 0, count = 0, ret = 0;
+#ifdef CONFIG_WOWLAN	
+	u8 u1H2CAoacRsvdPageParm[H2C_AOAC_RSVDPAGE_LOC_LEN]={0};
+
+	DBG_871X("AOACRsvdPageLoc: RWC=%d ArpRsp=%d NbrAdv=%d GtkRsp=%d GtkInfo=%d ProbeReq=%d NetworkList=%d\n",
+			rsvdpageloc->LocRemoteCtrlInfo, rsvdpageloc->LocArpRsp,
+			rsvdpageloc->LocNbrAdv, rsvdpageloc->LocGTKRsp,
+			rsvdpageloc->LocGTKInfo, rsvdpageloc->LocProbeReq,
+			rsvdpageloc->LocNetList);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED)) {
+		SET_H2CCMD_AOAC_RSVDPAGE_LOC_REMOTE_WAKE_CTRL_INFO(u1H2CAoacRsvdPageParm, rsvdpageloc->LocRemoteCtrlInfo);
+		SET_H2CCMD_AOAC_RSVDPAGE_LOC_ARP_RSP(u1H2CAoacRsvdPageParm, rsvdpageloc->LocArpRsp);
+		//SET_H2CCMD_AOAC_RSVDPAGE_LOC_NEIGHBOR_ADV(u1H2CAoacRsvdPageParm, rsvdpageloc->LocNbrAdv);
+		SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_RSP(u1H2CAoacRsvdPageParm, rsvdpageloc->LocGTKRsp);
+		SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_INFO(u1H2CAoacRsvdPageParm, rsvdpageloc->LocGTKInfo);
+#ifdef CONFIG_GTK_OL
+		SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_EXT_MEM(u1H2CAoacRsvdPageParm, rsvdpageloc->LocGTKEXTMEM);
+#endif // CONFIG_GTK_OL
+		if (pHalFunc->fill_h2c_cmd != NULL) {
+			ret = pHalFunc->fill_h2c_cmd(padapter,
+					H2C_AOAC_RSVD_PAGE,
+					H2C_AOAC_RSVDPAGE_LOC_LEN,
+					u1H2CAoacRsvdPageParm);
+		} else {
+			DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+			ret = _FAIL;
+		}
 	}
-		break;
-	case HW_VAR_SEC_DK_CFG:
+#ifdef CONFIG_PNO_SUPPORT
+	else
 	{
-		struct security_priv *sec = &adapter->securitypriv;
-		u8 reg_scr = rtw_read8(adapter, REG_SECCFG);
 
-		if (val) /* Enable default key related setting */
-		{
-			reg_scr |= SCR_TXBCUSEDK;
-			if (sec->dot11AuthAlgrthm != dot11AuthAlgrthm_8021X)
-				reg_scr |= (SCR_RxUseDK|SCR_TxUseDK);
+		if(!pwrpriv->pno_in_resume) {
+			DBG_871X("NLO_INFO=%d\n", rsvdpageloc->LocPNOInfo);
+			_rtw_memset(&u1H2CAoacRsvdPageParm, 0,
+					sizeof(u1H2CAoacRsvdPageParm));
+			SET_H2CCMD_AOAC_RSVDPAGE_LOC_NLO_INFO(u1H2CAoacRsvdPageParm,
+					rsvdpageloc->LocPNOInfo);
+			if (pHalFunc->fill_h2c_cmd != NULL) {
+				ret = pHalFunc->fill_h2c_cmd(padapter,
+						H2C_AOAC_RSVDPAGE3,
+						H2C_AOAC_RSVDPAGE_LOC_LEN,
+						u1H2CAoacRsvdPageParm);
+			} else {
+				DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+				ret = _FAIL;
+			}
 		}
-		else /* Disable default key related setting */
-		{
-			reg_scr &= ~(SCR_RXBCUSEDK|SCR_TXBCUSEDK|SCR_RxUseDK|SCR_TxUseDK);
+	}
+#endif //CONFIG_PNO_SUPPORT
+#endif // CONFIG_WOWLAN
+}
+
+#ifdef CONFIG_WOWLAN
+// rtw_hal_check_wow_ctrl
+// chk_type: _TRUE means to check enable, if 0x690 & bit1, WOW enable successful
+//           _FALSE means to check disable, if 0x690 & bit1, WOW disable fail
+static u8 rtw_hal_check_wow_ctrl(_adapter* adapter, u8 chk_type)
+{
+	u8 mstatus = 0;
+	u8 trycnt = 25;
+	u8 res = _FALSE;
+
+	mstatus = rtw_read8(adapter, REG_WOW_CTRL);
+	DBG_871X_LEVEL(_drv_info_, "%s mstatus:0x%02x\n", __func__, mstatus);
+
+	if (chk_type) {
+		while(!(mstatus&BIT1) && trycnt>1) {
+			mstatus = rtw_read8(adapter, REG_WOW_CTRL);
+			DBG_871X_LEVEL(_drv_always_,
+					"Loop index: %d :0x%02x\n",
+					trycnt, mstatus);
+			trycnt --;
+			rtw_msleep_os(2);
+		}
+		if (mstatus & BIT1)
+			res = _TRUE;
+		else
+			res = _FALSE;
+	} else {
+		while (mstatus&BIT1 && trycnt>1) {
+			mstatus = rtw_read8(adapter, REG_WOW_CTRL);
+			DBG_871X_LEVEL(_drv_always_,
+					"Loop index: %d :0x%02x\n",
+					trycnt, mstatus);
+			trycnt --;
+			rtw_msleep_os(2);
 		}
 
-		rtw_write8(adapter, REG_SECCFG, reg_scr);
+		if (mstatus & BIT1)
+			res = _FALSE;
+		else
+			res = _TRUE;
 	}
-		break;
-	case HW_VAR_DM_FLAG:
-		odm->SupportAbility = *((u32*)val);
-		break;
-	case HW_VAR_DM_FUNC_OP:
-		if (*((u8*)val) == _TRUE) {
-			/* save dm flag */
-			odm->BK_SupportAbility = odm->SupportAbility;				
-		} else {
-			/* restore dm flag */
-			odm->SupportAbility = odm->BK_SupportAbility;
-		}
-		break;
-	case HW_VAR_DM_FUNC_SET:
-		if(*((u32*)val) == DYNAMIC_ALL_FUNC_ENABLE){
-			struct dm_priv	*dm = &hal_data->dmpriv;
-			dm->DMFlag = dm->InitDMFlag;
-			odm->SupportAbility = dm->InitODMFlag;
-		} else {
-			odm->SupportAbility |= *((u32 *)val);
+	DBG_871X_LEVEL(_drv_always_, "%s check_type: %d res: %d trycnt: %d\n",
+			__func__, chk_type, res, (25 - trycnt));
+	return res;
+}
+
+#ifdef CONFIG_PNO_SUPPORT
+static u8 rtw_hal_check_pno_enabled(_adapter* adapter)
+{
+	struct pwrctrl_priv *ppwrpriv = adapter_to_pwrctl(adapter);
+	u8 res = 0, count = 0;
+	u8 ret = _FALSE;
+	if (ppwrpriv->wowlan_pno_enable && ppwrpriv->pno_in_resume == _FALSE) {
+		res = rtw_read8(adapter, REG_PNO_STATUS);
+		while(!(res&BIT(7)) && count < 25) {
+			DBG_871X("[%d] cmd: 0x81 REG_PNO_STATUS: 0x%02x\n",
+					count, res);
+			res = rtw_read8(adapter, REG_PNO_STATUS);
+			count++;
+			rtw_msleep_os(2);
 		}
-		break;
-	case HW_VAR_DM_FUNC_CLR:
-		/*
-		* input is already a mask to clear function
-		* don't invert it again! George,Lucas@20130513
-		*/
-		odm->SupportAbility &= *((u32 *)val);
-		break;
-	case HW_VAR_MAX_AGGR_NUM:
-		DBG_871X("%s HW_VAR_MAX_AGGR_NUM: %04x\n", __func__, *((u16*)val));
-		rtw_write16(adapter, REG_MAX_AGGR_NUM, *((u16*)val));
-		break;
-	default:
-		if (0)
-		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" variable(%d) not defined!\n",
-			FUNC_ADPT_ARG(adapter), variable);
-		break;
+		if (res & BIT(7))
+			ret = _TRUE;
+		else
+			ret = _FALSE;
+		DBG_871X("cmd: 0x81 REG_PNO_STATUS: ret(%d)\n", ret);
 	}
+	return ret;
+}
+#endif
 
-_func_exit_;
+static void rtw_hal_force_enable_rxdma(_adapter* adapter)
+{
+	DBG_871X("%s: Set 0x690=0x00\n", __func__);
+	rtw_write8(adapter, REG_WOW_CTRL,
+			(rtw_read8(adapter, REG_WOW_CTRL)&0xf0));
+	DBG_871X_LEVEL(_drv_always_, "%s: Release RXDMA\n", __func__);
+	rtw_write32(adapter, REG_RXPKT_NUM,
+			(rtw_read32(adapter,REG_RXPKT_NUM)&(~RW_RELEASE_EN)));
 }
 
-void GetHwReg(_adapter *adapter, u8 variable, u8 *val)
+static void rtw_hal_disable_tx_report(_adapter* adapter)
 {
-	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
-	DM_ODM_T *odm = &(hal_data->odmpriv);
+	rtw_write8(adapter, REG_TX_RPT_CTRL,
+			((rtw_read8(adapter, REG_TX_RPT_CTRL)&~BIT(1)))&~BIT(5));
+	DBG_871X("disable TXRPT:0x%02x\n", rtw_read8(adapter, REG_TX_RPT_CTRL));
+}
 
-_func_enter_;
+static void rtw_hal_enable_tx_report(_adapter* adapter)
+{
+	rtw_write8(adapter, REG_TX_RPT_CTRL,
+			((rtw_read8(adapter, REG_TX_RPT_CTRL)|BIT(1)))|BIT(5));
+	DBG_871X("enable TX_RPT:0x%02x\n", rtw_read8(adapter, REG_TX_RPT_CTRL));
+}
 
-	switch (variable) {
-	case HW_VAR_BASIC_RATE:
-		*((u16*)val) = hal_data->BasicRateSet;
-		break;
-	case HW_VAR_DM_FLAG:
-		*((u32*)val) = odm->SupportAbility;
-		break;
-	case HW_VAR_RF_TYPE:
-		*((u8*)val) = hal_data->rf_type;
-		break;
-	default:
-		if (0)
-		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" variable(%d) not defined!\n",
-			FUNC_ADPT_ARG(adapter), variable);
-		break;
+static void rtw_hal_backup_rate(_adapter* adapter)
+{
+	DBG_871X("%s\n", __func__);
+	//backup data rate to register 0x8b for wowlan FW
+	rtw_write8(adapter, 0x8d, 1);
+	rtw_write8(adapter, 0x8c, 0);
+	rtw_write8(adapter, 0x8f, 0x40);
+	rtw_write8(adapter, 0x8b, rtw_read8(adapter, 0x2f0));
+}
+
+static u8 rtw_hal_pause_rx_dma(_adapter* adapter)
+{
+	u8 ret = 0;
+	u8 trycnt = 100;
+	u16 len = 0;
+	u32 tmp = 0;
+	int res = 0;
+	//RX DMA stop
+	DBG_871X_LEVEL(_drv_always_, "Pause DMA\n");
+	rtw_write32(adapter, REG_RXPKT_NUM,
+			(rtw_read32(adapter,REG_RXPKT_NUM)|RW_RELEASE_EN));
+	do{
+		if((rtw_read32(adapter, REG_RXPKT_NUM)&RXDMA_IDLE)) {
+			DBG_871X_LEVEL(_drv_always_, "RX_DMA_IDLE is true\n");
+			ret = _SUCCESS;
+			break;
+		}
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+		else {
+			// If RX_DMA is not idle, receive one pkt from DMA
+			res = sdio_local_read(adapter,
+					SDIO_REG_RX0_REQ_LEN, 4, (u8*)&tmp);
+			len = le16_to_cpu(tmp);
+			DBG_871X_LEVEL(_drv_always_, "RX len:%d\n", len);
+
+			if (len > 0)
+				res = RecvOnePkt(adapter, len);
+			else
+				DBG_871X_LEVEL(_drv_always_, "read length fail %d\n", len);
+
+			DBG_871X_LEVEL(_drv_always_, "RecvOnePkt Result: %d\n", res);
+		}
+#endif //CONFIG_SDIO_HCI || CONFIG_GSPI_HCI
+	}while(trycnt--);
+
+	if(trycnt ==0) {
+		DBG_871X_LEVEL(_drv_always_, "Stop RX DMA failed...... \n");
+		ret = _FAIL;
 	}
 
-_func_exit_;
+	return ret;
 }
 
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+static u8 rtw_hal_enable_cpwm2(_adapter* adapter)
+{
+	u8 ret = 0;
+	int res = 0;
+	u32 tmp = 0;
 
+	DBG_871X_LEVEL(_drv_always_, "%s\n", __func__);
 
+	res = sdio_local_read(adapter, SDIO_REG_HIMR, 4, (u8*)&tmp);
+	if (!res)
+		DBG_871X_LEVEL(_drv_info_, "read SDIO_REG_HIMR: 0x%08x\n", tmp);
+	else
+		DBG_871X_LEVEL(_drv_info_, "sdio_local_read fail\n");
 
-u8
-SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value)
-{	
-	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
-	DM_ODM_T *odm = &(hal_data->odmpriv);
-	u8 bResult = _SUCCESS;
+	tmp = SDIO_HIMR_CPWM2_MSK;
 
-	switch(variable) {
-	case HW_DEF_FA_CNT_DUMP:		
-		//ODM_COMP_COMMON
-		if(*((u8*)value))
-			odm->DebugComponents |= (ODM_COMP_DIG |ODM_COMP_FA_CNT);
-		else
-			odm->DebugComponents &= ~(ODM_COMP_DIG |ODM_COMP_FA_CNT);		
-		break;
-	case HAL_DEF_DBG_RX_INFO_DUMP:
-		{
-			PFALSE_ALARM_STATISTICS FalseAlmCnt = &(odm->FalseAlmCnt);
-			pDIG_T	pDM_DigTable = &odm->DM_DigTable;
+	res = sdio_local_write(adapter, SDIO_REG_HIMR, 4, (u8*)&tmp);
 
-			DBG_871X("============ Rx Info dump ===================\n");
-			DBG_871X("bLinked = %d, RSSI_Min = %d(%%), CurrentIGI = 0x%x \n",
-				odm->bLinked, odm->RSSI_Min, pDM_DigTable->CurIGValue);
-			DBG_871X("Cnt_Cck_fail = %d, Cnt_Ofdm_fail = %d, Total False Alarm = %d\n",	
-				FalseAlmCnt->Cnt_Cck_fail, FalseAlmCnt->Cnt_Ofdm_fail, FalseAlmCnt->Cnt_all);
+	if (!res){
+		res = sdio_local_read(adapter, SDIO_REG_HIMR, 4, (u8*)&tmp);
+		DBG_871X_LEVEL(_drv_info_, "read again SDIO_REG_HIMR: 0x%08x\n", tmp);
+		ret = _SUCCESS;
+	}else {
+		DBG_871X_LEVEL(_drv_info_, "sdio_local_write fail\n");
+		ret = _FAIL;
+	}
 
-			if(odm->bLinked){
-				DBG_871X("RxRate = %s, RSSI_A = %d(%%), RSSI_B = %d(%%)\n", 
-					HDATA_RATE(odm->RxRate), odm->RSSI_A, odm->RSSI_B);	
+	return ret;
+}
+#endif //CONFIG_SDIO_HCI, CONFIG_GSPI_HCI
 
-				#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA
-				rtw_dump_raw_rssi_info(adapter);
-				#endif
-			}
-		}		
-		break;		
-	case HW_DEF_ODM_DBG_FLAG:
-		ODM_CmnInfoUpdate(odm, ODM_CMNINFO_DBG_COMP, *((u8Byte*)value));
-		break;
-	case HW_DEF_ODM_DBG_LEVEL:
-		ODM_CmnInfoUpdate(odm, ODM_CMNINFO_DBG_LEVEL, *((u4Byte*)value));
-		break;
-	case HAL_DEF_DBG_DM_FUNC:
-	{
-		u8 dm_func = *((u8*)value);
-		struct dm_priv *dm = &hal_data->dmpriv;
+#ifdef CONFIG_GTK_OL
+static void rtw_hal_fw_sync_cam_id(_adapter* adapter)
+{
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	u8 null_addr[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+	int cam_id;
+	u32 algorithm = 0;
+	u16 ctrl = 0;
+	u8 *addr;
+	u8 index = 0;
+	u8 get_key[16];
+
+	addr = get_bssid(&adapter->mlmepriv);
+
+	if (addr == NULL) {
+		DBG_871X("%s: get bssid MAC addr fail!!\n", __func__);
+		return;
+	}
 
-		if(dm_func == 0){ //disable all dynamic func
-			odm->SupportAbility = DYNAMIC_FUNC_DISABLE;
-			DBG_8192C("==> Disable all dynamic function...\n");
-		}
-		else if(dm_func == 1){//disable DIG
-			odm->SupportAbility  &= (~DYNAMIC_BB_DIG);
-			DBG_8192C("==> Disable DIG...\n");
-		}
-		else if(dm_func == 2){//disable High power
-			odm->SupportAbility  &= (~DYNAMIC_BB_DYNAMIC_TXPWR);
-		}
-		else if(dm_func == 3){//disable tx power tracking
-			odm->SupportAbility  &= (~DYNAMIC_RF_CALIBRATION);
-			DBG_8192C("==> Disable tx power tracking...\n");
-		}
-		else if(dm_func == 4){//disable BT coexistence
-			dm->DMFlag &= (~DYNAMIC_FUNC_BT);
-		}
-		else if(dm_func == 5){//disable antenna diversity
-			odm->SupportAbility  &= (~DYNAMIC_BB_ANT_DIV);
-		}
-		else if(dm_func == 6){//turn on all dynamic func
-			if(!(odm->SupportAbility  & DYNAMIC_BB_DIG)) {
-				DIG_T	*pDigTable = &odm->DM_DigTable;
-				pDigTable->CurIGValue= rtw_read8(adapter, 0xc50);
-			}
-			dm->DMFlag |= DYNAMIC_FUNC_BT;
-			odm->SupportAbility = DYNAMIC_ALL_FUNC_ENABLE;
-			DBG_8192C("==> Turn on all dynamic function...\n");
+	do{
+		cam_id = rtw_camid_search(adapter, addr, index);
+		if (cam_id == -1) {
+			DBG_871X("%s: cam_id: %d, key_id:%d\n",
+					__func__, cam_id, index);
+		} else if (rtw_camid_is_gk(adapter, cam_id) != _TRUE) {
+			DBG_871X("%s: cam_id: %d key_id(%d) is not GK\n",
+					__func__, cam_id, index);
+		} else {
+			read_cam(adapter ,cam_id, get_key);
+			algorithm = psecuritypriv->dot11PrivacyAlgrthm;
+			ctrl = BIT(15) | BIT6 |(algorithm << 2) | index;
+			write_cam(adapter, index, ctrl, addr, get_key);
+			ctrl = 0;
+			write_cam(adapter, cam_id, ctrl, null_addr, get_key);
 		}
-	}
-		break;
-	case HAL_DEF_DBG_DUMP_RXPKT:
-		hal_data->bDumpRxPkt = *((u8*)value);
-		break;
-	case HAL_DEF_DBG_DUMP_TXPKT:
-		hal_data->bDumpTxPkt = *((u8*)value);
-		break;
-	case HAL_DEF_ANT_DETECT:
-		hal_data->AntDetection = *((u8 *)value);
-		break;
-	default:
-		DBG_871X_LEVEL(_drv_always_, "%s: [WARNING] HAL_DEF_VARIABLE(%d) not defined!\n", __FUNCTION__, variable);
-		bResult = _FAIL;
-		break;
-	}
+		index++;
+	}while(cam_id != -1);
 
-	return bResult;
+	rtw_write8(adapter, REG_SECCFG, 0xcc);
 }
 
-u8
-GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value)
+static void rtw_hal_update_gtk_offload_info(_adapter* adapter)
 {
-	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
-	DM_ODM_T *odm = &(hal_data->odmpriv);
-	u8 bResult = _SUCCESS;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	int cam_id;
+	u8 *addr;
+	u8 null_addr[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+	u8 gtk_keyindex=0;
+	u8 get_key[16];
+	u8 null_key[16];
+	u8 index = 0;
+	u16 ctrl = 0;
+	u32 algorithm = 0;
+
+	addr = get_bssid(&adapter->mlmepriv);
+
+	if (addr == NULL) {
+		DBG_871X("%s: get bssid MAC addr fail!!\n", __func__);
+		return;
+	}
 
-	switch(variable) {
-	case HW_DEF_ODM_DBG_FLAG:
-		*((u8Byte*)value) = odm->DebugComponents;
-		break;
-	case HW_DEF_ODM_DBG_LEVEL:
-		*((u4Byte*)value) = odm->DebugLevel;
-		break;
-	case HAL_DEF_DBG_DM_FUNC:
-		*(( u32*)value) =hal_data->odmpriv.SupportAbility;
-		break;
-	case HAL_DEF_DBG_DUMP_RXPKT:
-		*((u8*)value) = hal_data->bDumpRxPkt;
-		break;
-	case HAL_DEF_DBG_DUMP_TXPKT:
-		*((u8*)value) = hal_data->bDumpTxPkt;
-		break;
-	case HAL_DEF_ANT_DETECT:
-		*((u8 *)value) = hal_data->AntDetection;
-		break;
-	case HAL_DEF_MACID_SLEEP:
-		*(u8*)value = _FALSE;
-		break;
-	case HAL_DEF_TX_PAGE_SIZE:
-		*(( u32*)value) = PAGE_SIZE_128;
-		break;
-	default:
-		DBG_871X_LEVEL(_drv_always_, "%s: [WARNING] HAL_DEF_VARIABLE(%d) not defined!\n", __FUNCTION__, variable);
-		bResult = _FAIL;
-		break;
+	_rtw_memset(null_key, 0, sizeof(null_key));
+
+	algorithm = psecuritypriv->dot11PrivacyAlgrthm;
+
+	if(psecuritypriv->binstallKCK_KEK == _TRUE) {
+		//read gtk key index
+		gtk_keyindex = rtw_read8(adapter, 0x48c);
+
+		do{
+			cam_id = rtw_camid_search(adapter, addr, index);
+			if (cam_id == -1) {
+				DBG_871X("%s: cam_id: %d, key_id:%d\n",
+						__func__, cam_id, index);
+			} else if (read_phy_cam_is_gtk(adapter, cam_id) ==
+					_FALSE){
+				DBG_871X("%s: cam_id: %d, key_id:%d is not GK\n",
+						__func__, cam_id, index);
+			} else if (cam_id >= 4) {
+				DBG_871X("%s: cam_id(%d) is not in default key\n",
+						__func__, cam_id);
+			} else {
+				read_cam(adapter ,cam_id, get_key);
+				algorithm = psecuritypriv->dot11PrivacyAlgrthm;
+				ctrl = BIT(15) | BIT6 |(algorithm << 2) | index;
+				write_cam(adapter, cam_id+4, ctrl,
+						addr, get_key);
+				ctrl = 0;
+				write_cam(adapter, cam_id, ctrl,
+						null_addr, get_key);
+			}
+
+			if (gtk_keyindex < 4 &&(index == gtk_keyindex)) {
+				psecuritypriv->dot118021XGrpKeyid = gtk_keyindex;
+				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey,
+						get_key, 16);
+
+				DBG_871X_LEVEL(_drv_always_, "GTK (%d) = 0x%08x, 0x%08x, 0x%08x, 0x%08x\n",
+						gtk_keyindex,
+				psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].lkey[0], 
+				psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].lkey[1],
+				psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].lkey[2],
+				psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].lkey[3]);
+			}
+			index++;
+		}while(index < 4);
+
+		rtw_write8(adapter, REG_SECCFG, 0x0c);
+#ifdef CONFIG_GTK_OL_DBG
+		//if (gtk_keyindex != 5)
+		dump_cam_table(adapter);
+#endif
 	}
+}
+#endif
 
-	return bResult;
+static void rtw_hal_update_tx_iv(_adapter* adapter)
+{
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(adapter);
+	u64 iv_low = 0, iv_high = 0;
+
+	// 3.1 read fw iv
+	iv_low = rtw_read32(adapter, REG_TXPKTBUF_IV_LOW);
+	//only low two bytes is PN, check AES_IV macro for detail
+	iv_low &= 0xffff;
+	iv_high = rtw_read32(adapter, REG_TXPKTBUF_IV_HIGH);
+	//get the real packet number
+	pwrctl->wowlan_fw_iv = iv_high << 16 | iv_low;
+	DBG_871X_LEVEL(_drv_always_,
+			"fw_iv: 0x%016llx\n", pwrctl->wowlan_fw_iv);
+	//Update TX iv data.
+	rtw_set_sec_pn(adapter);
 }
 
-BOOLEAN 
-eqNByte(
-	u8*	str1,
-	u8*	str2,
-	u32	num
-	)
+static u8 rtw_hal_set_keep_alive_cmd(_adapter *adapter, u8 enable, u8 pkt_type)
 {
-	if(num==0)
-		return _FALSE;
-	while(num>0)
-	{
-		num--;
-		if(str1[num]!=str2[num])
-			return _FALSE;
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+
+	u8 u1H2CKeepAliveParm[H2C_KEEP_ALIVE_CTRL_LEN]={0};
+	u8 adopt = 1, check_period = 5;
+	u8 ret = _FAIL;
+
+	DBG_871X("%s(): enable = %d\n", __func__, enable);
+	SET_H2CCMD_KEEPALIVE_PARM_ENABLE(u1H2CKeepAliveParm, enable);
+	SET_H2CCMD_KEEPALIVE_PARM_ADOPT(u1H2CKeepAliveParm, adopt);
+	SET_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(u1H2CKeepAliveParm, pkt_type);
+	SET_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(u1H2CKeepAliveParm, check_period);
+
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(adapter,
+				H2C_KEEP_ALIVE,
+				H2C_KEEP_ALIVE_CTRL_LEN,
+				u1H2CKeepAliveParm);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
 	}
-	return _TRUE;
+
+	return ret;
 }
 
-//
+static u8 rtw_hal_set_disconnect_decision_cmd(_adapter *adapter, u8 enable)
+{
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+	u8 u1H2CDisconDecisionParm[H2C_DISCON_DECISION_LEN]={0};
+	u8 adopt = 1, check_period = 10, trypkt_num = 0;
+	u8 ret = _FAIL;
+
+	DBG_871X("%s(): enable = %d\n", __func__, enable);
+	SET_H2CCMD_DISCONDECISION_PARM_ENABLE(u1H2CDisconDecisionParm, enable);
+	SET_H2CCMD_DISCONDECISION_PARM_ADOPT(u1H2CDisconDecisionParm, adopt);
+	SET_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(u1H2CDisconDecisionParm, check_period);
+	SET_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(u1H2CDisconDecisionParm, trypkt_num);
+
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(adapter,
+				H2C_DISCON_DECISION,
+				H2C_DISCON_DECISION_LEN,
+				u1H2CDisconDecisionParm);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
+	}
+
+	return ret;
+}
+
+static u8 rtw_hal_set_ap_offload_ctrl_cmd(_adapter *adapter, u8 enable)
+{
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+	u8 u1H2CAPOffloadCtrlParm[H2C_WOWLAN_LEN]={0};
+	u8 ret = _FAIL;
+
+	DBG_871X("%s(): bFuncEn=%d\n", __func__, enable);
+
+	SET_H2CCMD_AP_WOWLAN_EN(u1H2CAPOffloadCtrlParm, enable);
+
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(adapter,
+				H2C_AP_OFFLOAD,
+				H2C_AP_OFFLOAD_LEN,
+				u1H2CAPOffloadCtrlParm);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
+	}
+	return ret;
+}
+
+static u8 rtw_hal_set_ap_rsvdpage_loc_cmd(_adapter *adapter,
+		PRSVDPAGE_LOC rsvdpageloc)
+{
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+	u8 rsvdparm[H2C_AOAC_RSVDPAGE_LOC_LEN]={0};
+	u8 ret = _FAIL, header = 0;
+
+	if (pHalFunc->fill_h2c_cmd == NULL) {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		return ret;
+	}
+
+	header = rtw_read8(adapter, REG_BCNQ_BDNY);
+
+	DBG_871X("%s: beacon: %d, probeRsp: %d, header:0x%02x\n", __func__,
+			rsvdpageloc->LocApOffloadBCN,
+			rsvdpageloc->LocProbeRsp,
+			header);
+
+	SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_BCN(rsvdparm,
+			rsvdpageloc->LocApOffloadBCN + header);
+
+	ret = pHalFunc->fill_h2c_cmd(adapter, H2C_BCN_RSVDPAGE,
+				H2C_BCN_RSVDPAGE_LEN, rsvdparm);
+
+	if (ret == _FAIL)
+		DBG_871X("%s: H2C_BCN_RSVDPAGE cmd fail\n", __func__);
+
+	_rtw_memset(&rsvdparm, 0, sizeof(rsvdparm));
+
+	SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_ProbeRsp(rsvdparm,
+			rsvdpageloc->LocProbeRsp + header);
+
+	ret = pHalFunc->fill_h2c_cmd(adapter, H2C_PROBERSP_RSVDPAGE,
+				H2C_PROBERSP_RSVDPAGE_LEN, rsvdparm);
+
+	if (ret == _FAIL)
+		DBG_871X("%s: H2C_PROBERSP_RSVDPAGE cmd fail\n", __func__);
+
+	return ret;
+}
+
+static u8 rtw_hal_set_wowlan_ctrl_cmd(_adapter *adapter, u8 enable)
+{
+	struct security_priv *psecpriv = &adapter->securitypriv;
+	struct pwrctrl_priv *ppwrpriv = adapter_to_pwrctl(adapter);
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+
+	u8 u1H2CWoWlanCtrlParm[H2C_WOWLAN_LEN]={0};
+	u8 discont_wake = 1, gpionum = 0, gpio_dur = 0;
+	u8 hw_unicast = 0, gpio_pulse_cnt=100;
+	u8 sdio_wakeup_enable = 1;
+	u8 gpio_high_active = 0; //0: low active, 1: high active
+	u8 magic_pkt = 0;
+	u8 ret = _FAIL;
+
+#ifdef CONFIG_GPIO_WAKEUP
+	gpionum = WAKEUP_GPIO_IDX;
+	sdio_wakeup_enable = 0;
+#endif //CONFIG_GPIO_WAKEUP
+
+	if (!ppwrpriv->wowlan_pno_enable)
+		magic_pkt = enable;
+
+	if (psecpriv->dot11PrivacyAlgrthm == _WEP40_ || psecpriv->dot11PrivacyAlgrthm == _WEP104_)
+		hw_unicast = 1;
+	else if (IS_HARDWARE_TYPE_8192E(adapter))
+		hw_unicast = 1;
+	else
+		hw_unicast = 0;
+
+	DBG_871X("%s(): enable=%d\n", __func__, enable);
+
+	SET_H2CCMD_WOWLAN_FUNC_ENABLE(u1H2CWoWlanCtrlParm, enable);
+	SET_H2CCMD_WOWLAN_PATTERN_MATCH_ENABLE(u1H2CWoWlanCtrlParm, 0);
+	SET_H2CCMD_WOWLAN_MAGIC_PKT_ENABLE(u1H2CWoWlanCtrlParm, magic_pkt);
+	SET_H2CCMD_WOWLAN_UNICAST_PKT_ENABLE(u1H2CWoWlanCtrlParm, hw_unicast);
+	SET_H2CCMD_WOWLAN_ALL_PKT_DROP(u1H2CWoWlanCtrlParm, 0);
+	SET_H2CCMD_WOWLAN_GPIO_ACTIVE(u1H2CWoWlanCtrlParm, gpio_high_active);
+#ifndef CONFIG_GTK_OL
+	SET_H2CCMD_WOWLAN_REKEY_WAKE_UP(u1H2CWoWlanCtrlParm, enable);
+#endif
+	SET_H2CCMD_WOWLAN_DISCONNECT_WAKE_UP(u1H2CWoWlanCtrlParm, discont_wake);
+	SET_H2CCMD_WOWLAN_GPIONUM(u1H2CWoWlanCtrlParm, gpionum);
+	SET_H2CCMD_WOWLAN_DATAPIN_WAKE_UP(u1H2CWoWlanCtrlParm, sdio_wakeup_enable);
+	SET_H2CCMD_WOWLAN_GPIO_DURATION(u1H2CWoWlanCtrlParm, gpio_dur);
+	//SET_H2CCMD_WOWLAN_GPIO_PULSE_EN(u1H2CWoWlanCtrlParm, 1);
+#ifdef CONFIG_PLATFORM_ARM_RK3188
+	SET_H2CCMD_WOWLAN_GPIO_PULSE_COUNT(u1H2CWoWlanCtrlParm, 0x09);
+#endif
+
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(adapter,
+				H2C_WOWLAN,
+				H2C_WOWLAN_LEN,
+				u1H2CWoWlanCtrlParm);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
+	}
+	return ret;
+}
+
+static u8 rtw_hal_set_remote_wake_ctrl_cmd(_adapter *adapter, u8 enable)
+{
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+	struct security_priv* psecuritypriv=&(adapter->securitypriv);
+	struct pwrctrl_priv *ppwrpriv = adapter_to_pwrctl(adapter);
+	u8 u1H2CRemoteWakeCtrlParm[H2C_REMOTE_WAKE_CTRL_LEN]={0};
+	u8 ret = _FAIL, count = 0;
+
+	DBG_871X("%s(): enable=%d\n", __func__, enable);
+
+	if (!ppwrpriv->wowlan_pno_enable) {
+		SET_H2CCMD_REMOTE_WAKECTRL_ENABLE(
+				u1H2CRemoteWakeCtrlParm, enable);
+		SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_OFFLOAD_EN(
+				u1H2CRemoteWakeCtrlParm, 1);
+#ifdef CONFIG_GTK_OL
+		if (psecuritypriv->binstallKCK_KEK == _TRUE &&
+				psecuritypriv->dot11PrivacyAlgrthm == _AES_) {
+			SET_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(
+					u1H2CRemoteWakeCtrlParm, 1);
+		} else {
+			DBG_871X("no kck or security is not AES\n");
+			SET_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(
+					u1H2CRemoteWakeCtrlParm, 0);
+		}
+#endif //CONFIG_GTK_OL
+
+		SET_H2CCMD_REMOTE_WAKE_CTRL_FW_UNICAST_EN(
+				u1H2CRemoteWakeCtrlParm, 1);
+		if ((psecuritypriv->dot11PrivacyAlgrthm == _AES_) ||
+			(psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_)) {
+			SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_ACTION(
+					u1H2CRemoteWakeCtrlParm, 0);
+		} else {
+			SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_ACTION(
+					u1H2CRemoteWakeCtrlParm, 1);
+		}
+	}
+#ifdef CONFIG_PNO_SUPPORT
+	else {
+		SET_H2CCMD_REMOTE_WAKECTRL_ENABLE(
+				u1H2CRemoteWakeCtrlParm, enable);
+		SET_H2CCMD_REMOTE_WAKE_CTRL_NLO_OFFLOAD_EN(
+				u1H2CRemoteWakeCtrlParm, enable);
+	}
+#endif
+
+#ifdef CONFIG_P2P_WOWLAN
+	if (_TRUE == ppwrpriv->wowlan_p2p_mode)
+	{
+		DBG_871X("P2P OFFLOAD ENABLE\n");
+		SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(u1H2CRemoteWakeCtrlParm,1);
+	}
+	else
+	{
+		DBG_871X("P2P OFFLOAD DISABLE\n");
+		SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(u1H2CRemoteWakeCtrlParm,0);
+	}
+#endif //CONFIG_P2P_WOWLAN
+
+
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(adapter,
+				H2C_REMOTE_WAKE_CTRL,
+				H2C_REMOTE_WAKE_CTRL_LEN,
+				u1H2CRemoteWakeCtrlParm);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
+	}
+	return ret;
+}
+
+static u8 rtw_hal_set_global_info_cmd(_adapter* adapter, u8 group_alg, u8 pairwise_alg)
+{
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+	u8 ret = _FAIL;
+	u8 u1H2CAOACGlobalInfoParm[H2C_AOAC_GLOBAL_INFO_LEN]={0};
+
+	DBG_871X("%s(): group_alg=%d pairwise_alg=%d\n",
+			__func__, group_alg, pairwise_alg);
+	SET_H2CCMD_AOAC_GLOBAL_INFO_PAIRWISE_ENC_ALG(u1H2CAOACGlobalInfoParm,
+			pairwise_alg);
+	SET_H2CCMD_AOAC_GLOBAL_INFO_GROUP_ENC_ALG(u1H2CAOACGlobalInfoParm,
+			group_alg);
+
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(adapter,
+				H2C_AOAC_GLOBAL_INFO,
+				H2C_AOAC_GLOBAL_INFO_LEN,
+				u1H2CAOACGlobalInfoParm);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_PNO_SUPPORT
+static u8 rtw_hal_set_scan_offload_info_cmd(_adapter* adapter,
+		PRSVDPAGE_LOC rsvdpageloc, u8 enable)
+{
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(adapter);
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+
+	u8 u1H2CScanOffloadInfoParm[H2C_SCAN_OFFLOAD_CTRL_LEN]={0};
+	u8 res = 0, count = 0, ret = _FAIL;
+
+	DBG_871X("%s: loc_probe_packet:%d, loc_scan_info: %d loc_ssid_info:%d\n",
+		__func__, rsvdpageloc->LocProbePacket,
+		rsvdpageloc->LocScanInfo, rsvdpageloc->LocSSIDInfo);
+
+	SET_H2CCMD_AOAC_NLO_FUN_EN(u1H2CScanOffloadInfoParm, enable);
+	SET_H2CCMD_AOAC_RSVDPAGE_LOC_SCAN_INFO(u1H2CScanOffloadInfoParm,
+			rsvdpageloc->LocScanInfo);
+	SET_H2CCMD_AOAC_RSVDPAGE_LOC_PROBE_PACKET(u1H2CScanOffloadInfoParm,
+			rsvdpageloc->LocProbePacket);
+	SET_H2CCMD_AOAC_RSVDPAGE_LOC_SSID_INFO(u1H2CScanOffloadInfoParm,
+			rsvdpageloc->LocSSIDInfo);
+
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(adapter,
+				H2C_D0_SCAN_OFFLOAD_INFO,
+				H2C_SCAN_OFFLOAD_CTRL_LEN,
+				u1H2CScanOffloadInfoParm);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
+	}
+	return ret;
+}
+#endif //CONFIG_PNO_SUPPORT
+
+void rtw_hal_set_fw_wow_related_cmd(_adapter* padapter, u8 enable)
+{
+	struct security_priv *psecpriv = &padapter->securitypriv;
+	struct pwrctrl_priv *ppwrpriv = adapter_to_pwrctl(padapter);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct sta_info *psta = NULL;
+	u16 media_status_rpt;
+	u8	pkt_type = 0;
+	u8 ret = _SUCCESS;
+
+	DBG_871X_LEVEL(_drv_always_, "+%s()+: enable=%d\n", __func__, enable);
+_func_enter_;
+
+	rtw_hal_set_wowlan_ctrl_cmd(padapter, enable);
+
+	if (enable) {
+		rtw_hal_set_global_info_cmd(padapter,
+				psecpriv->dot118021XGrpPrivacy,
+				psecpriv->dot11PrivacyAlgrthm);
+
+		if (!(ppwrpriv->wowlan_pno_enable)) {
+			rtw_hal_set_disconnect_decision_cmd(padapter, enable);
+#ifdef CONFIG_ARP_KEEP_ALIVE
+			if ((psecpriv->dot11PrivacyAlgrthm == _WEP40_) ||
+				(psecpriv->dot11PrivacyAlgrthm == _WEP104_))
+				pkt_type = 0;
+			else
+				pkt_type = 1;
+#else
+			pkt_type = 0;
+#endif //CONFIG_ARP_KEEP_ALIVE
+			rtw_hal_set_keep_alive_cmd(padapter, enable, pkt_type);
+		}
+		rtw_hal_set_remote_wake_ctrl_cmd(padapter, enable);
+#ifdef CONFIG_PNO_SUPPORT
+		rtw_hal_check_pno_enabled(padapter);
+#endif //CONFIG_PNO_SUPPORT
+	} else {
+#if 0
+		{
+			u32 PageSize = 0;
+			rtw_hal_get_def_var(adapter, HAL_DEF_TX_PAGE_SIZE, (u8 *)&PageSize);
+			dump_TX_FIFO(padapter, 4, PageSize);
+		}
+#endif
+
+		rtw_hal_set_remote_wake_ctrl_cmd(padapter, enable);
+		rtw_hal_set_wowlan_ctrl_cmd(padapter, enable);
+	}
+_func_exit_;
+	DBG_871X_LEVEL(_drv_always_, "-%s()-\n", __func__);
+}
+#endif //CONFIG_WOWLAN
+
+#ifdef CONFIG_P2P_WOWLAN
+static int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)
+{
+	u8 *ssid_ie;
+	sint ssid_len_ori;
+	int len_diff = 0;
+	
+	ssid_ie = rtw_get_ie(ies,  WLAN_EID_SSID, &ssid_len_ori, ies_len);
+
+	//DBG_871X("%s hidden_ssid_mode:%u, ssid_ie:%p, ssid_len_ori:%d\n", __FUNCTION__, hidden_ssid_mode, ssid_ie, ssid_len_ori);
+	
+	if(ssid_ie && ssid_len_ori>0)
+	{
+		switch(hidden_ssid_mode)
+		{
+			case 1:
+			{
+				u8 *next_ie = ssid_ie + 2 + ssid_len_ori;
+				u32 remain_len = 0;
+				
+				remain_len = ies_len -(next_ie-ies);
+				
+				ssid_ie[1] = 0;				
+				_rtw_memcpy(ssid_ie+2, next_ie, remain_len);
+				len_diff -= ssid_len_ori;
+				
+				break;
+			}		
+			case 2:
+				_rtw_memset(&ssid_ie[2], 0, ssid_len_ori);
+				break;
+			default:
+				break;
+		}
+	}
+
+	return len_diff;
+}
+
+static void rtw_hal_construct_P2PBeacon(_adapter *padapter, u8 *pframe, u32 *pLength)
+{
+	//struct xmit_frame	*pmgntframe;
+	//struct pkt_attrib	*pattrib;
+	//unsigned char	*pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	unsigned short *fctrl;
+	unsigned int	rate_len;
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	u32	pktlen;
+//#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+//	_irqL irqL;
+//	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+//#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+#ifdef CONFIG_P2P
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
+#endif //CONFIG_P2P
+
+	//for debug
+	u8 *dbgbuf = pframe;
+	u8 dbgbufLen = 0, index = 0;
+
+	DBG_871X("%s\n", __FUNCTION__);
+//#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+//	_enter_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
+//#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+		
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;	
+	
+	
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	
+	_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+	//pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_BEACON);
+	
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);	
+	pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
+	
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		//DBG_871X("ie len=%d\n", cur_network->IELength);
+#ifdef CONFIG_P2P
+		// for P2P : Primary Device Type & Device Name
+		u32 wpsielen=0, insert_len=0;
+		u8 *wpsie=NULL;		
+		wpsie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wpsielen);
+		
+		if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && wpsie && wpsielen>0)
+		{
+			uint wps_offset, remainder_ielen;
+			u8 *premainder_ie, *pframe_wscie;
+	
+			wps_offset = (uint)(wpsie - cur_network->IEs);
+
+			premainder_ie = wpsie + wpsielen;
+
+			remainder_ielen = cur_network->IELength - wps_offset - wpsielen;
+
+#ifdef CONFIG_IOCTL_CFG80211
+			if(pwdinfo->driver_interface == DRIVER_CFG80211 )
+			{
+				if(pmlmepriv->wps_beacon_ie && pmlmepriv->wps_beacon_ie_len>0)
+				{
+					_rtw_memcpy(pframe, cur_network->IEs, wps_offset);
+					pframe += wps_offset;
+					pktlen += wps_offset;
+
+					_rtw_memcpy(pframe, pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len);
+					pframe += pmlmepriv->wps_beacon_ie_len;
+					pktlen += pmlmepriv->wps_beacon_ie_len;
+
+					//copy remainder_ie to pframe
+					_rtw_memcpy(pframe, premainder_ie, remainder_ielen);
+					pframe += remainder_ielen;		
+					pktlen += remainder_ielen;
+				}
+				else
+				{
+					_rtw_memcpy(pframe, cur_network->IEs, cur_network->IELength);
+					pframe += cur_network->IELength;
+					pktlen += cur_network->IELength;
+				}
+			}
+			else
+#endif //CONFIG_IOCTL_CFG80211
+			{
+				pframe_wscie = pframe + wps_offset;
+				_rtw_memcpy(pframe, cur_network->IEs, wps_offset+wpsielen);			
+				pframe += (wps_offset + wpsielen);		
+				pktlen += (wps_offset + wpsielen);
+
+				//now pframe is end of wsc ie, insert Primary Device Type & Device Name
+				//	Primary Device Type
+				//	Type:
+				*(u16*) ( pframe + insert_len) = cpu_to_be16( WPS_ATTR_PRIMARY_DEV_TYPE );
+				insert_len += 2;
+				
+				//	Length:
+				*(u16*) ( pframe + insert_len ) = cpu_to_be16( 0x0008 );
+				insert_len += 2;
+				
+				//	Value:
+				//	Category ID
+				*(u16*) ( pframe + insert_len ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+				insert_len += 2;
+
+				//	OUI
+				*(u32*) ( pframe + insert_len ) = cpu_to_be32( WPSOUI );
+				insert_len += 4;
+
+				//	Sub Category ID
+				*(u16*) ( pframe + insert_len ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+				insert_len += 2;
+
+
+				//	Device Name
+				//	Type:
+				*(u16*) ( pframe + insert_len ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+				insert_len += 2;
+
+				//	Length:
+				*(u16*) ( pframe + insert_len ) = cpu_to_be16( pwdinfo->device_name_len );
+				insert_len += 2;
+
+				//	Value:
+				_rtw_memcpy( pframe + insert_len, pwdinfo->device_name, pwdinfo->device_name_len );
+				insert_len += pwdinfo->device_name_len;
+
+
+				//update wsc ie length
+				*(pframe_wscie+1) = (wpsielen -2) + insert_len;
+
+				//pframe move to end
+				pframe+=insert_len;
+				pktlen += insert_len;
+
+				//copy remainder_ie to pframe
+				_rtw_memcpy(pframe, premainder_ie, remainder_ielen);
+				pframe += remainder_ielen;		
+				pktlen += remainder_ielen;
+			}
+		}
+		else
+#endif //CONFIG_P2P
+		{
+			int len_diff;
+			_rtw_memcpy(pframe, cur_network->IEs, cur_network->IELength);
+			len_diff = update_hidden_ssid(
+				pframe+_BEACON_IE_OFFSET_
+				, cur_network->IELength-_BEACON_IE_OFFSET_
+				, pmlmeinfo->hidden_ssid_mode
+			);
+			pframe += (cur_network->IELength+len_diff);
+			pktlen += (cur_network->IELength+len_diff);
+		}
+#if 0
+		{
+			u8 *wps_ie;
+			uint wps_ielen;
+			u8 sr = 0;
+			wps_ie = rtw_get_wps_ie(pmgntframe->buf_addr+TXDESC_OFFSET+sizeof (struct rtw_ieee80211_hdr_3addr)+_BEACON_IE_OFFSET_,
+				pattrib->pktlen-sizeof (struct rtw_ieee80211_hdr_3addr)-_BEACON_IE_OFFSET_, NULL, &wps_ielen);
+			if (wps_ie && wps_ielen>0) {
+				rtw_get_wps_attr_content(wps_ie,  wps_ielen, WPS_ATTR_SELECTED_REGISTRAR, (u8*)(&sr), NULL);
+			}
+			if (sr != 0)
+				set_fwstate(pmlmepriv, WIFI_UNDER_WPS);
+			else
+				_clr_fwstate_(pmlmepriv, WIFI_UNDER_WPS);
+		}
+#endif 
+#ifdef CONFIG_P2P
+		if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+		{
+			u32 len;
+#ifdef CONFIG_IOCTL_CFG80211
+			if(pwdinfo->driver_interface == DRIVER_CFG80211 )
+			{
+				len = pmlmepriv->p2p_beacon_ie_len;
+				if(pmlmepriv->p2p_beacon_ie && len>0)				
+					_rtw_memcpy(pframe, pmlmepriv->p2p_beacon_ie, len);
+			}
+			else
+#endif //CONFIG_IOCTL_CFG80211
+			{
+				len = build_beacon_p2p_ie(pwdinfo, pframe);
+			}
+
+			pframe += len;
+			pktlen += len;
+#ifdef CONFIG_WFD
+#ifdef CONFIG_IOCTL_CFG80211
+			if(_TRUE == pwdinfo->wfd_info->wfd_enable)
+#endif //CONFIG_IOCTL_CFG80211
+			{
+			len = build_beacon_wfd_ie( pwdinfo, pframe );
+			}
+#ifdef CONFIG_IOCTL_CFG80211
+			else
+			{	
+				len = 0;
+				if(pmlmepriv->wfd_beacon_ie && pmlmepriv->wfd_beacon_ie_len>0)
+				{
+					len = pmlmepriv->wfd_beacon_ie_len;
+					_rtw_memcpy(pframe, pmlmepriv->wfd_beacon_ie, len);	
+				}
+			}		
+#endif //CONFIG_IOCTL_CFG80211
+			pframe += len;
+			pktlen += len;
+#endif //CONFIG_WFD
+		}
+#endif //CONFIG_P2P
+
+		goto _issue_bcn;
+
+	}
+
+	//below for ad-hoc mode
+
+	//timestamp will be inserted by hardware
+	pframe += 8;
+	pktlen += 8;
+
+	// beacon interval: 2 bytes
+
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2); 
+
+	pframe += 2;
+	pktlen += 2;
+
+	// capability info: 2 bytes
+
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pktlen += 2;
+
+	// SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pktlen);
+
+	// supported rates...
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pktlen);
+
+	// DS parameter set
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);
+
+	//if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		u8 erpinfo=0;
+		u32 ATIMWindow;
+		// IBSS Parameter Set...
+		//ATIMWindow = cur->Configuration.ATIMWindow;
+		ATIMWindow = 0;
+		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
+
+		//ERP IE
+		pframe = rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo, &pktlen);
+	}	
+
+
+	// EXTERNDED SUPPORTED RATE
+	if (rate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pktlen);
+	}
+
+
+	//todo:HT for adhoc
+
+_issue_bcn:
+
+//#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+//	pmlmepriv->update_bcn = _FALSE;
+//	
+//	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);	
+//#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+
+	*pLength = pktlen;
+#if 0
+	// printf dbg msg
+	dbgbufLen = pktlen;
+	DBG_871X("======> DBG MSG FOR CONSTRAUCT P2P BEACON\n");
+
+	for(index=0;index<dbgbufLen;index++)
+		printk("%x ",*(dbgbuf+index));
+
+	printk("\n");
+	DBG_871X("<====== DBG MSG FOR CONSTRAUCT P2P BEACON\n");
+	
+#endif
+}
+
+static int get_reg_classes_full_count(struct p2p_channels channel_list) {
+	int cnt = 0;
+	int i;
+
+	for (i = 0; i < channel_list.reg_classes; i++) {
+		cnt += channel_list.reg_class[i].channels;
+	}
+
+	return cnt;
+}
+
+static void rtw_hal_construct_P2PProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength)
+{
+	//struct xmit_frame			*pmgntframe;
+	//struct pkt_attrib			*pattrib;
+	//unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;	
+	unsigned char					*mac;
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	//WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	u16					beacon_interval = 100;
+	u16					capInfo = 0;
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
+	u8					wpsie[255] = { 0x00 };
+	u32					wpsielen = 0, p2pielen = 0;
+	u32					pktlen;
+#ifdef CONFIG_WFD
+	u32					wfdielen = 0;
+#endif //CONFIG_WFD
+#ifdef CONFIG_INTEL_WIDI
+	u8 zero_array_check[L2SDTA_SERVICE_VE_LEN] = { 0x00 };
+#endif //CONFIG_INTEL_WIDI
+
+	//for debug
+	u8 *dbgbuf = pframe;
+	u8 dbgbufLen = 0, index = 0;
+
+	DBG_871X("%s\n", __FUNCTION__);
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;	
+	
+	mac = myid(&(padapter->eeprompriv));
+	
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	//DA filled by FW
+	_rtw_memset(pwlanhdr->addr1, 0, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+	
+	//	Use the device address for BSSID field.	
+	_rtw_memcpy(pwlanhdr->addr3, mac, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0);
+	SetFrameSubType(fctrl, WIFI_PROBERSP);
+
+ 	pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+ 	pframe += pktlen;
+
+
+	//timestamp will be inserted by hardware
+	pframe += 8;
+	pktlen += 8;
+
+	// beacon interval: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *) &beacon_interval, 2); 
+	pframe += 2;
+	pktlen += 2;
+
+	//	capability info: 2 bytes
+	//	ESS and IBSS bits must be 0 (defined in the 3.1.2.1.1 of WiFi Direct Spec)
+	capInfo |= cap_ShortPremble;
+	capInfo |= cap_ShortSlot;
+	
+	_rtw_memcpy(pframe, (unsigned char *) &capInfo, 2);
+	pframe += 2;
+	pktlen += 2;
+
+
+	// SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_, 7, pwdinfo->p2p_wildcard_ssid, &pktlen);
+
+	// supported rates...
+	//	Use the OFDM rate in the P2P probe response frame. ( 6(B), 9(B), 12, 18, 24, 36, 48, 54 )
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate, &pktlen);
+
+	// DS parameter set
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&pwdinfo->listen_channel, &pktlen);
+
+#ifdef CONFIG_IOCTL_CFG80211
+	if(pwdinfo->driver_interface == DRIVER_CFG80211 )
+	{
+		if( pmlmepriv->wps_probe_resp_ie != NULL && pmlmepriv->p2p_probe_resp_ie != NULL )
+		{
+			//WPS IE
+			_rtw_memcpy(pframe, pmlmepriv->wps_probe_resp_ie, pmlmepriv->wps_probe_resp_ie_len);
+			pktlen += pmlmepriv->wps_probe_resp_ie_len;
+			pframe += pmlmepriv->wps_probe_resp_ie_len;
+
+			//P2P IE
+			_rtw_memcpy(pframe, pmlmepriv->p2p_probe_resp_ie, pmlmepriv->p2p_probe_resp_ie_len);
+			pktlen += pmlmepriv->p2p_probe_resp_ie_len;
+			pframe += pmlmepriv->p2p_probe_resp_ie_len;
+		}
+	}
+	else
+#endif //CONFIG_IOCTL_CFG80211		
+	{
+
+		//	Todo: WPS IE
+		//	Noted by Albert 20100907
+		//	According to the WPS specification, all the WPS attribute is presented by Big Endian.
+
+		wpsielen = 0;
+		//	WPS OUI
+		*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+		wpsielen += 4;
+
+		//	WPS version
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+		wpsielen += 2;
+
+		//	Value:
+		wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+
+#ifdef CONFIG_INTEL_WIDI
+		//	Commented by Kurt
+		//	Appended WiDi info. only if we did issued_probereq_widi(), and then we saved ven. ext. in pmlmepriv->sa_ext.
+		if(  _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == _FALSE 
+			|| pmlmepriv->num_p2p_sdt != 0 )
+		{
+			//Sec dev type
+			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_SEC_DEV_TYPE_LIST );
+			wpsielen += 2;
+
+			//	Length:
+			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0008 );
+			wpsielen += 2;
+
+			//	Value:
+			//	Category ID
+			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_CID_DISPLAYS );
+			wpsielen += 2;
+
+			//	OUI
+			*(u32*) ( wpsie + wpsielen ) = cpu_to_be32( INTEL_DEV_TYPE_OUI );
+			wpsielen += 4;
+
+			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_SCID_WIDI_CONSUMER_SINK );
+			wpsielen += 2;
+
+			if(  _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == _FALSE )
+			{
+				//	Vendor Extension
+				_rtw_memcpy( wpsie + wpsielen, pmlmepriv->sa_ext, L2SDTA_SERVICE_VE_LEN );
+				wpsielen += L2SDTA_SERVICE_VE_LEN;
+			}
+		}
+#endif //CONFIG_INTEL_WIDI
+
+		//	WiFi Simple Config State
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_SIMPLE_CONF_STATE );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+		wpsielen += 2;
+
+		//	Value:
+		wpsie[wpsielen++] = WPS_WSC_STATE_NOT_CONFIG;	//	Not Configured.
+
+		//	Response Type
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_RESP_TYPE );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+		wpsielen += 2;
+
+		//	Value:
+		wpsie[wpsielen++] = WPS_RESPONSE_TYPE_8021X;
+
+		//	UUID-E
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_UUID_E );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0010 );
+		wpsielen += 2;
+
+		//	Value:
+		if (pwdinfo->external_uuid == 0) {
+			_rtw_memset( wpsie + wpsielen, 0x0, 16 );
+			_rtw_memcpy( wpsie + wpsielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+		} else {
+			_rtw_memcpy( wpsie + wpsielen, pwdinfo->uuid, 0x10 );
+		}
+		wpsielen += 0x10;
+
+		//	Manufacturer
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_MANUFACTURER );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0007 );
+		wpsielen += 2;
+
+		//	Value:
+		_rtw_memcpy( wpsie + wpsielen, "Realtek", 7 );
+		wpsielen += 7;
+
+		//	Model Name
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_MODEL_NAME );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0006 );
+		wpsielen += 2;	
+
+		//	Value:
+		_rtw_memcpy( wpsie + wpsielen, "8192CU", 6 );
+		wpsielen += 6;
+
+		//	Model Number
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_MODEL_NUMBER );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+		wpsielen += 2;
+
+		//	Value:
+		wpsie[ wpsielen++ ] = 0x31;		//	character 1
+
+		//	Serial Number
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_SERIAL_NUMBER );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( ETH_ALEN );
+		wpsielen += 2;
+
+		//	Value:
+		_rtw_memcpy( wpsie + wpsielen, "123456" , ETH_ALEN );
+		wpsielen += ETH_ALEN;
+
+		//	Primary Device Type
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_PRIMARY_DEV_TYPE );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0008 );
+		wpsielen += 2;
+
+		//	Value:
+		//	Category ID
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+		wpsielen += 2;
+
+		//	OUI
+		*(u32*) ( wpsie + wpsielen ) = cpu_to_be32( WPSOUI );
+		wpsielen += 4;
+
+		//	Sub Category ID
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+		wpsielen += 2;
+
+		//	Device Name
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->device_name_len );
+		wpsielen += 2;
+
+		//	Value:
+		_rtw_memcpy( wpsie + wpsielen, pwdinfo->device_name, pwdinfo->device_name_len );
+		wpsielen += pwdinfo->device_name_len;
+
+		//	Config Method
+		//	Type:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_CONF_METHOD );
+		wpsielen += 2;
+
+		//	Length:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+		wpsielen += 2;
+
+		//	Value:
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->supported_wps_cm );
+		wpsielen += 2;
+		
+
+		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pktlen );
+		
+
+		p2pielen = build_probe_resp_p2p_ie(pwdinfo, pframe);
+		pframe += p2pielen;
+		pktlen += p2pielen;
+	}
+
+#ifdef CONFIG_WFD
+#ifdef CONFIG_IOCTL_CFG80211
+	if ( _TRUE == pwdinfo->wfd_info->wfd_enable )
+#endif //CONFIG_IOCTL_CFG80211
+	{
+		wfdielen = build_probe_resp_wfd_ie(pwdinfo, pframe, 0);
+		pframe += wfdielen;
+		pktlen += wfdielen;
+	}
+#ifdef CONFIG_IOCTL_CFG80211
+	else if (pmlmepriv->wfd_probe_resp_ie != NULL && pmlmepriv->wfd_probe_resp_ie_len>0)
+	{
+		//WFD IE
+		_rtw_memcpy(pframe, pmlmepriv->wfd_probe_resp_ie, pmlmepriv->wfd_probe_resp_ie_len);
+		pktlen += pmlmepriv->wfd_probe_resp_ie_len;
+		pframe += pmlmepriv->wfd_probe_resp_ie_len;		
+	}
+#endif //CONFIG_IOCTL_CFG80211
+#endif //CONFIG_WFD	
+
+	*pLength = pktlen;
+
+#if 0
+	// printf dbg msg
+	dbgbufLen = pktlen;
+	DBG_871X("======> DBG MSG FOR CONSTRAUCT P2P Probe Rsp\n");
+
+	for(index=0;index<dbgbufLen;index++)
+		printk("%x ",*(dbgbuf+index));
+
+	printk("\n");
+	DBG_871X("<====== DBG MSG FOR CONSTRAUCT P2P Probe Rsp\n");
+#endif
+}
+static void rtw_hal_construct_P2PNegoRsp(_adapter *padapter, u8 *pframe, u32 *pLength)
+{
+	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
+	u8			action = P2P_PUB_ACTION_ACTION;
+	u32			p2poui = cpu_to_be32(P2POUI);
+	u8			oui_subtype = P2P_GO_NEGO_RESP;
+	u8			wpsie[ 255 ] = { 0x00 }, p2pie[ 255 ] = { 0x00 };
+	u8			p2pielen = 0, i;
+	uint			wpsielen = 0;
+	u16			wps_devicepassword_id = 0x0000;
+	uint			wps_devicepassword_id_len = 0;
+	u8			channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh;
+	u16			len_channellist_attr = 0;
+	u32			pktlen;
+	u8			dialogToken = 0;
+	
+	//struct xmit_frame			*pmgntframe;
+	//struct pkt_attrib			*pattrib;
+	//unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo);
+	//WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+
+#ifdef CONFIG_WFD
+	u32					wfdielen = 0;
+#endif //CONFIG_WFD
+
+	//for debug
+	u8 *dbgbuf = pframe;
+	u8 dbgbufLen = 0, index = 0;
+
+	DBG_871X( "%s\n", __FUNCTION__);
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	//RA, filled by FW
+	_rtw_memset(pwlanhdr->addr1, 0, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0);
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+	pframe += pktlen;
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pktlen));	
+	
+	//dialog token, filled by FW
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pktlen));
+
+	_rtw_memset( wpsie, 0x00, 255 );
+	wpsielen = 0;
+
+	//	WPS Section
+	wpsielen = 0;
+	//	WPS OUI
+	*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+	wpsielen += 4;
+
+	//	WPS version
+	//	Type:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+	wpsielen += 2;
+
+	//	Length:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+	wpsielen += 2;
+
+	//	Value:
+	wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+
+	//	Device Password ID
+	//	Type:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_DEVICE_PWID );
+	wpsielen += 2;
+
+	//	Length:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+	wpsielen += 2;
+
+	//	Value:
+	if ( wps_devicepassword_id == WPS_DPID_USER_SPEC )
+	{
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_REGISTRAR_SPEC );
+	}
+	else if ( wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC )
+	{
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_USER_SPEC );
+	}
+	else
+	{
+		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_PBC );
+	}
+	wpsielen += 2;
+
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pktlen );
+
+
+	//	P2P IE Section.
+
+	//	P2P OUI
+	p2pielen = 0;
+	p2pie[ p2pielen++ ] = 0x50;
+	p2pie[ p2pielen++ ] = 0x6F;
+	p2pie[ p2pielen++ ] = 0x9A;
+	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+
+	//	Commented by Albert 20100908
+	//	According to the P2P Specification, the group negoitation response frame should contain 9 P2P attributes
+	//	1. Status
+	//	2. P2P Capability
+	//	3. Group Owner Intent
+	//	4. Configuration Timeout
+	//	5. Operating Channel
+	//	6. Intended P2P Interface Address
+	//	7. Channel List
+	//	8. Device Info
+	//	9. Group ID	( Only GO )
+
+
+	//	ToDo:
+
+	//	P2P Status
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
+
+	//	Length:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0001 );
+	p2pielen += 2;
+
+	//	Value, filled by FW
+	p2pie[ p2pielen++ ] = 1;
+	
+	//	P2P Capability
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+
+	//	Length:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	p2pielen += 2;
+
+	//	Value:
+	//	Device Capability Bitmap, 1 byte
+
+	if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) )
+	{
+		//	Commented by Albert 2011/03/08
+		//	According to the P2P specification
+		//	if the sending device will be client, the P2P Capability should be reserved of group negotation response frame
+		p2pie[ p2pielen++ ] = 0;
+	}
+	else
+	{
+		//	Be group owner or meet the error case
+		p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
+	}
+	
+	//	Group Capability Bitmap, 1 byte
+	if ( pwdinfo->persistent_supported )
+	{
+		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
+	}
+	else
+	{
+		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN;
+	}
+
+	//	Group Owner Intent
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_GO_INTENT;
+
+	//	Length:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0001 );
+	p2pielen += 2;
+
+	//	Value:
+	if ( pwdinfo->peer_intent & 0x01 )
+	{
+		//	Peer's tie breaker bit is 1, our tie breaker bit should be 0
+		p2pie[ p2pielen++ ] = ( pwdinfo->intent << 1 );
+	}
+	else
+	{
+		//	Peer's tie breaker bit is 0, our tie breaker bit should be 1
+		p2pie[ p2pielen++ ] = ( ( pwdinfo->intent << 1 ) | BIT(0) );
+	}
+
+
+	//	Configuration Timeout
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
+
+	//	Length:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	p2pielen += 2;
+
+	//	Value:
+	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P GO
+	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P Client
+
+	//	Operating Channel
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
+
+	//	Length:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+	p2pielen += 2;
+
+	//	Value:
+	//	Country String
+	p2pie[ p2pielen++ ] = 'X';
+	p2pie[ p2pielen++ ] = 'X';
+	
+	//	The third byte should be set to 0x04.
+	//	Described in the "Operating Channel Attribute" section.
+	p2pie[ p2pielen++ ] = 0x04;
+
+	//	Operating Class
+	if ( pwdinfo->operating_channel <= 14 )
+	{
+		//	Operating Class
+		p2pie[ p2pielen++ ] = 0x51;
+	}
+	else if ( ( pwdinfo->operating_channel >= 36 ) && ( pwdinfo->operating_channel <= 48 ) )
+	{
+		//	Operating Class
+		p2pie[ p2pielen++ ] = 0x73;
+	}
+	else
+	{
+		//	Operating Class
+		p2pie[ p2pielen++ ] = 0x7c;
+	}
+	
+	//	Channel Number
+	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
+
+	//	Intended P2P Interface Address	
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_INTENTED_IF_ADDR;
+
+	//	Length:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN );
+	p2pielen += 2;
+
+	//	Value:
+	_rtw_memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+	p2pielen += ETH_ALEN;
+
+	//	Channel List
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
+
+	// Country String(3)
+	// + ( Operating Class (1) + Number of Channels(1) ) * Operation Classes (?)
+	// + number of channels in all classes
+	len_channellist_attr = 3
+	   + (1 + 1) * (u16)pmlmeext->channel_list.reg_classes
+	   + get_reg_classes_full_count(pmlmeext->channel_list);
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	{
+		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 5 + 1 );
+	}
+	else
+	{
+		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+	}
+#else
+
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+
+ #endif
+	p2pielen += 2;
+
+	//	Value:
+	//	Country String
+	p2pie[ p2pielen++ ] = 'X';
+	p2pie[ p2pielen++ ] = 'X';
+	
+	//	The third byte should be set to 0x04.
+	//	Described in the "Operating Channel Attribute" section.
+	p2pie[ p2pielen++ ] = 0x04;
+
+	//	Channel Entry List
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	{
+		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;	
+		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+
+		//	Operating Class
+		if ( pbuddy_mlmeext->cur_channel > 14 )
+		{
+			if ( pbuddy_mlmeext->cur_channel >= 149 )
+			{
+				p2pie[ p2pielen++ ] = 0x7c;
+			}
+			else
+			{
+				p2pie[ p2pielen++ ] = 0x73;
+			}
+		}
+		else
+		{
+			p2pie[ p2pielen++ ] = 0x51;
+		}
+
+		//	Number of Channels
+		//	Just support 1 channel and this channel is AP's channel
+		p2pie[ p2pielen++ ] = 1;
+
+		//	Channel List
+		p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
+	}
+	else
+	{
+		int i, j;
+		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
+			//	Operating Class
+			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
+
+			//	Number of Channels
+			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
+
+			//	Channel List
+			for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
+				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
+			}
+		}
+	}
+#else // CONFIG_CONCURRENT_MODE
+	{
+		int i, j;
+		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
+			//	Operating Class
+			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
+
+			//	Number of Channels
+			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
+
+			//	Channel List
+			for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
+				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
+			}
+		}
+	}
+#endif // CONFIG_CONCURRENT_MODE
+
+	
+	//	Device Info
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
+
+	//	Length:
+	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
+	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
+	p2pielen += 2;
+
+	//	Value:
+	//	P2P Device Address
+	_rtw_memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+	p2pielen += ETH_ALEN;
+
+	//	Config Method
+	//	This field should be big endian. Noted by P2P specification.
+
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->supported_wps_cm );
+
+	p2pielen += 2;
+
+	//	Primary Device Type
+	//	Category ID
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+	p2pielen += 2;
+
+	//	OUI
+	*(u32*) ( p2pie + p2pielen ) = cpu_to_be32( WPSOUI );
+	p2pielen += 4;
+
+	//	Sub Category ID
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+	p2pielen += 2;
+
+	//	Number of Secondary Device Types
+	p2pie[ p2pielen++ ] = 0x00;	//	No Secondary Device Type List
+
+	//	Device Name
+	//	Type:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+	p2pielen += 2;
+
+	//	Length:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->device_name_len );
+	p2pielen += 2;
+
+	//	Value:
+	_rtw_memcpy( p2pie + p2pielen, pwdinfo->device_name , pwdinfo->device_name_len );
+	p2pielen += pwdinfo->device_name_len;	
+	
+	if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) )
+	{
+		//	Group ID Attribute
+		//	Type:
+		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
+
+		//	Length:
+		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN + pwdinfo->nego_ssidlen );
+		p2pielen += 2;
+
+		//	Value:
+		//	p2P Device Address
+		_rtw_memcpy( p2pie + p2pielen , pwdinfo->device_addr, ETH_ALEN );
+		p2pielen += ETH_ALEN;
+
+		//	SSID
+		_rtw_memcpy( p2pie + p2pielen, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );
+		p2pielen += pwdinfo->nego_ssidlen;
+		
+	}
+	
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pktlen );	
+	
+#ifdef CONFIG_WFD
+	wfdielen = build_nego_resp_wfd_ie(pwdinfo, pframe);
+	pframe += wfdielen;
+	pktlen += wfdielen;
+#endif //CONFIG_WFD
+	
+	*pLength = pktlen;
+#if 0
+	// printf dbg msg
+	dbgbufLen = pktlen;
+	DBG_871X("======> DBG MSG FOR CONSTRAUCT Nego Rsp\n");
+
+	for(index=0;index<dbgbufLen;index++)
+		printk("%x ",*(dbgbuf+index));
+	
+	printk("\n");
+	DBG_871X("<====== DBG MSG FOR CONSTRAUCT Nego Rsp\n");
+#endif
+}
+
+static void rtw_hal_construct_P2PInviteRsp(_adapter * padapter, u8 * pframe, u32 * pLength)
+{
+	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
+	u8			action = P2P_PUB_ACTION_ACTION;
+	u32			p2poui = cpu_to_be32(P2POUI);
+	u8			oui_subtype = P2P_INVIT_RESP;
+	u8			p2pie[ 255 ] = { 0x00 };
+	u8			p2pielen = 0, i;
+	u8			channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
+	u16			len_channellist_attr = 0;
+	u32			pktlen;
+	u8			dialogToken = 0;
+#ifdef CONFIG_CONCURRENT_MODE
+	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
+	struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
+	struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+#endif	
+#ifdef CONFIG_WFD
+	u32					wfdielen = 0;
+#endif //CONFIG_WFD
+	
+	//struct xmit_frame			*pmgntframe;
+	//struct pkt_attrib			*pattrib;
+	//unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo);
+
+	//for debug
+	u8 *dbgbuf = pframe;
+	u8 dbgbufLen = 0, index = 0;
+
+
+	DBG_871X( "%s\n", __FUNCTION__);
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	//RA fill by FW
+	_rtw_memset(pwlanhdr->addr1, 0, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+
+	//BSSID fill by FW
+	_rtw_memset(pwlanhdr->addr3, 0, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0);
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pktlen));	
+
+	//dialog token, filled by FW
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pktlen));
+
+	//	P2P IE Section.
+
+	//	P2P OUI
+	p2pielen = 0;
+	p2pie[ p2pielen++ ] = 0x50;
+	p2pie[ p2pielen++ ] = 0x6F;
+	p2pie[ p2pielen++ ] = 0x9A;
+	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+
+	//	Commented by Albert 20101005
+	//	According to the P2P Specification, the P2P Invitation response frame should contain 5 P2P attributes
+	//	1. Status
+	//	2. Configuration Timeout
+	//	3. Operating Channel	( Only GO )
+	//	4. P2P Group BSSID	( Only GO )
+	//	5. Channel List
+
+	//	P2P Status
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
+
+	//	Length:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0001 );
+	p2pielen += 2;
+
+	//	Value: filled by FW, defult value is FAIL INFO UNAVAILABLE
+	p2pie[ p2pielen++ ] = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
+	
+	//	Configuration Timeout
+	//	Type:
+	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
+
+	//	Length:
+	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	p2pielen += 2;
+
+	//	Value:
+	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P GO
+	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P Client
+
+	// due to defult value is FAIL INFO UNAVAILABLE, so the following IE is not needed
+#if 0 
+	if( status_code == P2P_STATUS_SUCCESS )
+	{
+		if( rtw_p2p_chk_role( pwdinfo, P2P_ROLE_GO ) )
+		{
+			//	The P2P Invitation request frame asks this Wi-Fi device to be the P2P GO
+			//	In this case, the P2P Invitation response frame should carry the two more P2P attributes.
+			//	First one is operating channel attribute.
+			//	Second one is P2P Group BSSID attribute.
+
+			//	Operating Channel
+			//	Type:
+			p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
+
+			//	Length:
+			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+			p2pielen += 2;
+
+			//	Value:
+			//	Country String
+			p2pie[ p2pielen++ ] = 'X';
+			p2pie[ p2pielen++ ] = 'X';
+		
+			//	The third byte should be set to 0x04.
+			//	Described in the "Operating Channel Attribute" section.
+			p2pie[ p2pielen++ ] = 0x04;
+
+			//	Operating Class
+			p2pie[ p2pielen++ ] = 0x51;	//	Copy from SD7
+		
+			//	Channel Number
+			p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
+			
+
+			//	P2P Group BSSID
+			//	Type:
+			p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_BSSID;
+
+			//	Length:
+			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN );
+			p2pielen += 2;
+
+			//	Value:
+			//	P2P Device Address for GO
+			_rtw_memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+			p2pielen += ETH_ALEN;
+
+		}
+
+		//	Channel List
+		//	Type:
+		p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
+
+		//	Length:
+		// Country String(3)
+		// + ( Operating Class (1) + Number of Channels(1) ) * Operation Classes (?)
+		// + number of channels in all classes
+		len_channellist_attr = 3
+			+ (1 + 1) * (u16)pmlmeext->channel_list.reg_classes
+			+ get_reg_classes_full_count(pmlmeext->channel_list);
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+		{
+			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 5 + 1 );
+		}
+		else
+		{
+			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+		}
+#else
+
+		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+
+#endif
+		p2pielen += 2;
+
+		//	Value:
+		//	Country String
+		p2pie[ p2pielen++ ] = 'X';
+		p2pie[ p2pielen++ ] = 'X';
+
+		//	The third byte should be set to 0x04.
+		//	Described in the "Operating Channel Attribute" section.
+		p2pie[ p2pielen++ ] = 0x04;
+
+		//	Channel Entry List
+#ifdef CONFIG_CONCURRENT_MODE
+		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+		{
+			_adapter *pbuddy_adapter = padapter->pbuddy_adapter;	
+			struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+
+			//	Operating Class
+			if ( pbuddy_mlmeext->cur_channel > 14 )
+			{
+				if ( pbuddy_mlmeext->cur_channel >= 149 )
+				{
+					p2pie[ p2pielen++ ] = 0x7c;
+				}
+				else
+				{
+					p2pie[ p2pielen++ ] = 0x73;
+				}
+			}
+			else
+			{
+				p2pie[ p2pielen++ ] = 0x51;
+			}
+
+			//	Number of Channels
+			//	Just support 1 channel and this channel is AP's channel
+			p2pie[ p2pielen++ ] = 1;
+
+			//	Channel List
+			p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
+		}
+		else
+		{
+			int i, j;
+			for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
+				//	Operating Class
+				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
+
+				//	Number of Channels
+				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
+
+				//	Channel List
+				for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
+					p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
+				}
+			}
+		}
+#else // CONFIG_CONCURRENT_MODE
+		{
+			int i, j;
+			for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
+				//	Operating Class
+				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
+
+				//	Number of Channels
+				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
+
+				//	Channel List
+				for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
+					p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
+				}
+			}
+		}
+#endif // CONFIG_CONCURRENT_MODE
+	}
+#endif
+
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pktlen );	
+	
+#ifdef CONFIG_WFD
+	wfdielen = build_invitation_resp_wfd_ie(pwdinfo, pframe);
+	pframe += wfdielen;
+	pktlen += wfdielen;
+#endif //CONFIG_WFD
+
+	*pLength = pktlen;
+
+#if 0
+	// printf dbg msg
+	dbgbufLen = pktlen;
+	DBG_871X("======> DBG MSG FOR CONSTRAUCT Invite Rsp\n");
+
+	for(index=0;index<dbgbufLen;index++)
+		printk("%x ",*(dbgbuf+index));
+	
+	printk("\n");
+	DBG_871X("<====== DBG MSG FOR CONSTRAUCT Invite Rsp\n");
+#endif
+}
+
+
+static void rtw_hal_construct_P2PProvisionDisRsp(_adapter * padapter, u8 * pframe, u32 * pLength)
+{
+	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
+	u8			action = P2P_PUB_ACTION_ACTION;
+	u8			dialogToken = 0;	
+	u32			p2poui = cpu_to_be32(P2POUI);
+	u8			oui_subtype = P2P_PROVISION_DISC_RESP;
+	u8			wpsie[ 100 ] = { 0x00 };
+	u8			wpsielen = 0;
+	u32			pktlen;
+#ifdef CONFIG_WFD
+	u32					wfdielen = 0;
+#endif //CONFIG_WFD		
+	
+	//struct xmit_frame			*pmgntframe;
+	//struct pkt_attrib			*pattrib;
+	//unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo);
+
+	//for debug
+	u8 *dbgbuf = pframe;
+	u8 dbgbufLen = 0, index = 0;
+
+	DBG_871X( "%s\n", __FUNCTION__);
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	//RA filled by FW
+	_rtw_memset(pwlanhdr->addr1, 0, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr,0);
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pktlen));	
+	//dialog token, filled by FW
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pktlen));		
+
+	wpsielen = 0;
+	//	WPS OUI
+	//*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+	RTW_PUT_BE32(wpsie, WPSOUI);
+	wpsielen += 4;
+
+#if 0
+	//	WPS version
+	//	Type:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+	wpsielen += 2;
+
+	//	Length:
+	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+	wpsielen += 2;
+
+	//	Value:
+	wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+#endif
+
+	//	Config Method
+	//	Type:
+	//*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_CONF_METHOD );
+	RTW_PUT_BE16(wpsie + wpsielen, WPS_ATTR_CONF_METHOD);
+	wpsielen += 2;
+
+	//	Length:
+	//*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+	RTW_PUT_BE16(wpsie + wpsielen, 0x0002);
+	wpsielen += 2;
+
+	//	Value: filled by FW, default value is PBC
+	//*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( config_method );
+	RTW_PUT_BE16(wpsie + wpsielen, WPS_CM_PUSH_BUTTON);
+	wpsielen += 2;
+
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pktlen );	
+
+#ifdef CONFIG_WFD
+	wfdielen = build_provdisc_resp_wfd_ie(pwdinfo, pframe);
+	pframe += wfdielen;
+	pktlen += wfdielen;
+#endif //CONFIG_WFD
+
+	*pLength = pktlen;
+
+	// printf dbg msg
+#if 0
+	dbgbufLen = pktlen;
+	DBG_871X("======> DBG MSG FOR CONSTRAUCT  ProvisionDis Rsp\n");
+
+	for(index=0;index<dbgbufLen;index++)
+		printk("%x ",*(dbgbuf+index));
+
+	printk("\n");
+	DBG_871X("<====== DBG MSG FOR CONSTRAUCT ProvisionDis Rsp\n");
+#endif
+}
+
+u8 rtw_hal_set_FwP2PRsvdPage_cmd(_adapter* adapter, PRSVDPAGE_LOC rsvdpageloc)
+{
+	u8 u1H2CP2PRsvdPageParm[H2C_P2PRSVDPAGE_LOC_LEN]={0};
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+	u8 ret = _FAIL;
+
+	DBG_871X("P2PRsvdPageLoc: P2PBeacon=%d P2PProbeRsp=%d NegoRsp=%d InviteRsp=%d PDRsp=%d\n",  
+		rsvdpageloc->LocP2PBeacon, rsvdpageloc->LocP2PProbeRsp,
+		rsvdpageloc->LocNegoRsp, rsvdpageloc->LocInviteRsp,
+		rsvdpageloc->LocPDRsp);
+
+	SET_H2CCMD_RSVDPAGE_LOC_P2P_BCN(u1H2CP2PRsvdPageParm, rsvdpageloc->LocProbeRsp);
+	SET_H2CCMD_RSVDPAGE_LOC_P2P_PROBE_RSP(u1H2CP2PRsvdPageParm, rsvdpageloc->LocPsPoll);
+	SET_H2CCMD_RSVDPAGE_LOC_P2P_NEGO_RSP(u1H2CP2PRsvdPageParm, rsvdpageloc->LocNullData);
+	SET_H2CCMD_RSVDPAGE_LOC_P2P_INVITE_RSP(u1H2CP2PRsvdPageParm, rsvdpageloc->LocQosNull);
+	SET_H2CCMD_RSVDPAGE_LOC_P2P_PD_RSP(u1H2CP2PRsvdPageParm, rsvdpageloc->LocBTQosNull);
+	
+	//FillH2CCmd8723B(padapter, H2C_8723B_P2P_OFFLOAD_RSVD_PAGE, H2C_P2PRSVDPAGE_LOC_LEN, u1H2CP2PRsvdPageParm);
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(adapter,
+				H2C_P2P_OFFLOAD_RSVD_PAGE,
+				H2C_P2PRSVDPAGE_LOC_LEN,
+				u1H2CP2PRsvdPageParm);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
+	}
+
+	return ret;
+}
+
+u8 rtw_hal_set_p2p_wowlan_offload_cmd(_adapter* adapter)
+{
+
+	u8 offload_cmd[H2C_P2P_OFFLOAD_LEN] = {0};
+	struct wifidirect_info	*pwdinfo = &(adapter->wdinfo);
+	struct P2P_WoWlan_Offload_t *p2p_wowlan_offload = (struct P2P_WoWlan_Offload_t *)offload_cmd;
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+	u8 ret = _FAIL;
+
+	_rtw_memset(p2p_wowlan_offload,0 ,sizeof(struct P2P_WoWlan_Offload_t)); 
+	DBG_871X("%s\n",__func__);	
+	switch(pwdinfo->role)
+	{
+		case P2P_ROLE_DEVICE:
+			DBG_871X("P2P_ROLE_DEVICE\n");
+			p2p_wowlan_offload->role = 0;
+			break;
+		case P2P_ROLE_CLIENT:
+			DBG_871X("P2P_ROLE_CLIENT\n");
+			p2p_wowlan_offload->role = 1;
+			break;
+		case P2P_ROLE_GO:
+			DBG_871X("P2P_ROLE_GO\n");
+			p2p_wowlan_offload->role = 2;
+			break;
+		default: 
+			DBG_871X("P2P_ROLE_DISABLE\n");
+			break;
+		}
+	p2p_wowlan_offload->Wps_Config[0] = pwdinfo->supported_wps_cm>>8;
+	p2p_wowlan_offload->Wps_Config[1] = pwdinfo->supported_wps_cm;
+	offload_cmd = (u8*)p2p_wowlan_offload;
+	DBG_871X("p2p_wowlan_offload: %x:%x:%x\n",offload_cmd[0],offload_cmd[1],offload_cmd[2]);	
+
+	if (pHalFunc->fill_h2c_cmd != NULL) {
+		ret = pHalFunc->fill_h2c_cmd(adapter,
+				H2C_P2P_OFFLOAD,
+				H2C_P2P_OFFLOAD_LEN,
+				offload_cmd);
+	} else {
+		DBG_871X("%s: Please hook fill_h2c_cmd first!\n", __func__);
+		ret = _FAIL;
+	}
+
+	return ret;
+
+	//FillH2CCmd8723B(adapter, H2C_8723B_P2P_OFFLOAD, sizeof(struct P2P_WoWlan_Offload_t), (u8 *)p2p_wowlan_offload);
+}
+#endif //CONFIG_P2P_WOWLAN
+
+static void rtw_hal_construct_beacon(_adapter *padapter,
+		u8 *pframe, u32 *pLength)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16					*fctrl;
+	u32					rate_len, pktlen;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*cur_network = &(pmlmeinfo->network);
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+	//pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_BEACON);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
+
+	//timestamp will be inserted by hardware
+	pframe += 8;
+	pktlen += 8;
+
+	// beacon interval: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pktlen += 2;
+
+	// capability info: 2 bytes
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pktlen += 2;
+
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		//DBG_871X("ie len=%d\n", cur_network->IELength);
+		pktlen += cur_network->IELength - sizeof(NDIS_802_11_FIXED_IEs);
+		_rtw_memcpy(pframe, cur_network->IEs+sizeof(NDIS_802_11_FIXED_IEs), pktlen);
+
+		goto _ConstructBeacon;
+	}
+
+	//below for ad-hoc mode
+
+	// SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pktlen);
+
+	// supported rates...
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pktlen);
+
+	// DS parameter set
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);
+
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		u32 ATIMWindow;
+		// IBSS Parameter Set...
+		//ATIMWindow = cur->Configuration.ATIMWindow;
+		ATIMWindow = 0;
+		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
+	}
+
+
+	//todo: ERP IE
+
+
+	// EXTERNDED SUPPORTED RATE
+	if (rate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pktlen);
+	}
+
+
+	//todo:HT for adhoc
+
+_ConstructBeacon:
+
+	if ((pktlen + TXDESC_SIZE) > 512)
+	{
+		DBG_871X("beacon frame too large\n");
+		return;
+	}
+
+	*pLength = pktlen;
+
+	//DBG_871X("%s bcn_sz=%d\n", __FUNCTION__, pktlen);
+
+}
+
+static void rtw_hal_construct_PSPoll(_adapter *padapter,
+		u8 *pframe, u32 *pLength)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16					*fctrl;
+	u32					pktlen;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	// Frame control.
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	SetPwrMgt(fctrl);
+	SetFrameSubType(pframe, WIFI_PSPOLL);
+
+	// AID.
+	SetDuration(pframe, (pmlmeinfo->aid | 0xc000));
+
+	// BSSID.
+	_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	// TA.
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+
+	*pLength = 16;
+}
+
+static void rtw_hal_construct_NullFunctionData(
+	PADAPTER padapter,
+	u8		*pframe,
+	u32		*pLength,
+	u8		*StaAddr,
+	u8		bQoS,
+	u8		AC,
+	u8		bEosp,
+	u8		bForcePowerSave)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16						*fctrl;
+	u32						pktlen;
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network		*cur_network = &pmlmepriv->cur_network;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+
+	//DBG_871X("%s:%d\n", __FUNCTION__, bForcePowerSave);
+
+	pwlanhdr = (struct rtw_ieee80211_hdr*)pframe;
+
+	fctrl = &pwlanhdr->frame_ctl;
+	*(fctrl) = 0;
+	if (bForcePowerSave)
+	{
+		SetPwrMgt(fctrl);
+	}
+
+	switch(cur_network->network.InfrastructureMode)
+	{
+		case Ndis802_11Infrastructure:
+			SetToDs(fctrl);
+			_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, StaAddr, ETH_ALEN);
+			break;
+		case Ndis802_11APMode:
+			SetFrDs(fctrl);
+			_rtw_memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);
+			break;
+		case Ndis802_11IBSS:
+		default:
+			_rtw_memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+			_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+			break;
+	}
+
+	SetSeqNum(pwlanhdr, 0);
+
+	if (bQoS == _TRUE) {
+		struct rtw_ieee80211_hdr_3addr_qos *pwlanqoshdr;
+
+		SetFrameSubType(pframe, WIFI_QOS_DATA_NULL);
+
+		pwlanqoshdr = (struct rtw_ieee80211_hdr_3addr_qos*)pframe;
+		SetPriority(&pwlanqoshdr->qc, AC);
+		SetEOSP(&pwlanqoshdr->qc, bEosp);
+
+		pktlen = sizeof(struct rtw_ieee80211_hdr_3addr_qos);
+	} else {
+		SetFrameSubType(pframe, WIFI_DATA_NULL);
+
+		pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+	}
+
+	*pLength = pktlen;
+}
+
+#ifdef CONFIG_WOWLAN	
+//
+// Description:
+//	Construct the ARP response packet to support ARP offload.
+//
+static void rtw_hal_construct_ARPRsp(
+	PADAPTER padapter,
+	u8			*pframe,
+	u32			*pLength,
+	u8			*pIPAddress
+	)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16	*fctrl;
+	u32	pktlen;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	static u8	ARPLLCHeader[8] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x08, 0x06};
+	u8	*pARPRspPkt = pframe;
+	//for TKIP Cal MIC
+	u8	*payload = pframe;
+	u8	EncryptionHeadOverhead = 0;
+	//DBG_871X("%s:%d\n", __FUNCTION__, bForcePowerSave);
+
+	pwlanhdr = (struct rtw_ieee80211_hdr*)pframe;
+
+	fctrl = &pwlanhdr->frame_ctl;
+	*(fctrl) = 0;
+
+	//-------------------------------------------------------------------------
+	// MAC Header.
+	//-------------------------------------------------------------------------
+	SetFrameType(fctrl, WIFI_DATA);
+	//SetFrameSubType(fctrl, 0);
+	SetToDs(fctrl);
+	_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0);
+	SetDuration(pwlanhdr, 0);
+	//SET_80211_HDR_FRAME_CONTROL(pARPRspPkt, 0);
+	//SET_80211_HDR_TYPE_AND_SUBTYPE(pARPRspPkt, Type_Data);
+	//SET_80211_HDR_TO_DS(pARPRspPkt, 1);
+	//SET_80211_HDR_ADDRESS1(pARPRspPkt, pMgntInfo->Bssid);
+	//SET_80211_HDR_ADDRESS2(pARPRspPkt, Adapter->CurrentAddress);
+	//SET_80211_HDR_ADDRESS3(pARPRspPkt, pMgntInfo->Bssid);
+
+	//SET_80211_HDR_DURATION(pARPRspPkt, 0);
+	//SET_80211_HDR_FRAGMENT_SEQUENCE(pARPRspPkt, 0);
+#ifdef CONFIG_WAPI_SUPPORT
+	*pLength = sMacHdrLng;
+#else
+	*pLength = 24;
+#endif
+	switch (psecuritypriv->dot11PrivacyAlgrthm) {
+		case _WEP40_:
+		case _WEP104_:
+			EncryptionHeadOverhead = 4;
+			break;
+		case _TKIP_:
+			EncryptionHeadOverhead = 8;
+			break;
+		case _AES_:
+			EncryptionHeadOverhead = 8;
+			break;
+#ifdef CONFIG_WAPI_SUPPORT
+		case _SMS4_:
+			EncryptionHeadOverhead = 18;
+			break;
+#endif
+		default:
+			EncryptionHeadOverhead = 0;
+	}
+
+	if(EncryptionHeadOverhead > 0) {
+		_rtw_memset(&(pframe[*pLength]), 0,EncryptionHeadOverhead);
+		*pLength += EncryptionHeadOverhead;
+		//SET_80211_HDR_WEP(pARPRspPkt, 1);  //Suggested by CCW.
+		SetPrivacy(fctrl);
+	}
+
+	//-------------------------------------------------------------------------
+	// Frame Body.
+	//-------------------------------------------------------------------------
+	pARPRspPkt =  (u8*)(pframe+ *pLength);
+	payload = pARPRspPkt; //Get Payload pointer
+	// LLC header
+	_rtw_memcpy(pARPRspPkt, ARPLLCHeader, 8);
+	*pLength += 8;
+
+	// ARP element
+	pARPRspPkt += 8;
+	SET_ARP_PKT_HW(pARPRspPkt, 0x0100);
+	SET_ARP_PKT_PROTOCOL(pARPRspPkt, 0x0008);	// IP protocol
+	SET_ARP_PKT_HW_ADDR_LEN(pARPRspPkt, 6);
+	SET_ARP_PKT_PROTOCOL_ADDR_LEN(pARPRspPkt, 4);
+	SET_ARP_PKT_OPERATION(pARPRspPkt, 0x0200);	// ARP response
+	SET_ARP_PKT_SENDER_MAC_ADDR(pARPRspPkt, myid(&(padapter->eeprompriv)));
+	SET_ARP_PKT_SENDER_IP_ADDR(pARPRspPkt, pIPAddress);
+#ifdef CONFIG_ARP_KEEP_ALIVE
+	if (rtw_gw_addr_query(padapter)==0) {
+		SET_ARP_PKT_TARGET_MAC_ADDR(pARPRspPkt, pmlmepriv->gw_mac_addr);
+		SET_ARP_PKT_TARGET_IP_ADDR(pARPRspPkt, pmlmepriv->gw_ip);
+	}
+	else
+#endif
+	{
+		SET_ARP_PKT_TARGET_MAC_ADDR(pARPRspPkt,
+				get_my_bssid(&(pmlmeinfo->network)));
+		SET_ARP_PKT_TARGET_IP_ADDR(pARPRspPkt,
+				pIPAddress);
+		DBG_871X("%s Target Mac Addr:" MAC_FMT "\n", __FUNCTION__,
+				MAC_ARG(get_my_bssid(&(pmlmeinfo->network))));
+		DBG_871X("%s Target IP Addr" IP_FMT "\n", __FUNCTION__,
+				IP_ARG(pIPAddress));
+	}
+
+	*pLength += 28;
+
+	if (psecuritypriv->dot11PrivacyAlgrthm == _TKIP_) {
+		u8	mic[8];
+		struct mic_data	micdata;
+		struct sta_info	*psta = NULL;
+		u8	priority[4]={0x0,0x0,0x0,0x0};
+		u8	null_key[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
+
+		DBG_871X("%s(): Add MIC\n",__FUNCTION__);
+
+		psta = rtw_get_stainfo(&padapter->stapriv,
+				get_my_bssid(&(pmlmeinfo->network)));
+		if (psta != NULL) {
+			if(_rtw_memcmp(&psta->dot11tkiptxmickey.skey[0],
+						null_key, 16)==_TRUE) {
+				DBG_871X("%s(): STA dot11tkiptxmickey==0\n",
+						__func__);
+			}
+			//start to calculate the mic code
+			rtw_secmicsetkey(&micdata,
+					&psta->dot11tkiptxmickey.skey[0]);
+		}
+
+		rtw_secmicappend(&micdata, pwlanhdr->addr3, 6);  //DA
+
+		rtw_secmicappend(&micdata, pwlanhdr->addr2, 6); //SA
+
+		priority[0]=0;
+
+		rtw_secmicappend(&micdata, &priority[0], 4);
+
+		rtw_secmicappend(&micdata, payload, 36); //payload length = 8 + 28
+
+		rtw_secgetmic(&micdata,&(mic[0]));
+
+		pARPRspPkt += 28;
+		_rtw_memcpy(pARPRspPkt, &(mic[0]),8);
+
+		*pLength += 8;
+	}
+}
+
+#ifdef CONFIG_PNO_SUPPORT
+static void rtw_hal_construct_ProbeReq(_adapter *padapter, u8 *pframe,
+		u32 *pLength, pno_ssid_t *ssid)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16				*fctrl;
+	u32				pktlen;
+	unsigned char			*mac;
+	unsigned char			bssrate[NumRates];
+	struct xmit_priv		*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	int	bssrate_len = 0;
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+	mac = myid(&(padapter->eeprompriv));
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr3, bc_addr, ETH_ALEN);
+
+	_rtw_memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0);
+	SetFrameSubType(pframe, WIFI_PROBEREQ);
+
+	pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+	pframe += pktlen;
+
+	if (ssid == NULL) {
+		pframe = rtw_set_ie(pframe, _SSID_IE_, 0, NULL, &pktlen);
+	} else {
+		//DBG_871X("%s len:%d\n", ssid->SSID, ssid->SSID_len);
+		pframe = rtw_set_ie(pframe, _SSID_IE_, ssid->SSID_len, ssid->SSID, &pktlen);
+	}
+
+	get_rate_set(padapter, bssrate, &bssrate_len);
+
+	if (bssrate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &pktlen);
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &pktlen);
+	}
+	else
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &pktlen);
+	}
+
+	*pLength = pktlen;
+}
+
+static void rtw_hal_construct_PNO_info(_adapter *padapter,
+		u8 *pframe, u32*pLength)
+{
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
+
+	u8	*pPnoInfoPkt = pframe;
+	pPnoInfoPkt =  (u8*)(pframe+ *pLength);
+	_rtw_memcpy(pPnoInfoPkt, &pwrctl->pnlo_info->ssid_num, 1);
+
+	*pLength+=1;
+	pPnoInfoPkt += 1;
+	_rtw_memcpy(pPnoInfoPkt, &pwrctl->pnlo_info->hidden_ssid_num, 1);
+
+	*pLength+=3;
+	pPnoInfoPkt += 3;
+	_rtw_memcpy(pPnoInfoPkt, &pwrctl->pnlo_info->fast_scan_period, 1);
+
+	*pLength+=4;
+	pPnoInfoPkt += 4;
+	_rtw_memcpy(pPnoInfoPkt, &pwrctl->pnlo_info->fast_scan_iterations, 4);
+
+	*pLength+=4;
+	pPnoInfoPkt += 4;
+	_rtw_memcpy(pPnoInfoPkt, &pwrctl->pnlo_info->slow_scan_period, 4);
+
+	*pLength+=4;
+	pPnoInfoPkt += 4;
+	_rtw_memcpy(pPnoInfoPkt, &pwrctl->pnlo_info->ssid_length,
+			MAX_PNO_LIST_COUNT);
+
+	*pLength+=MAX_PNO_LIST_COUNT;
+	pPnoInfoPkt += MAX_PNO_LIST_COUNT;
+	_rtw_memcpy(pPnoInfoPkt, &pwrctl->pnlo_info->ssid_cipher_info,
+			MAX_PNO_LIST_COUNT);
+
+	*pLength+=MAX_PNO_LIST_COUNT;
+	pPnoInfoPkt += MAX_PNO_LIST_COUNT;
+	_rtw_memcpy(pPnoInfoPkt, &pwrctl->pnlo_info->ssid_channel_info,
+			MAX_PNO_LIST_COUNT);
+
+	*pLength+=MAX_PNO_LIST_COUNT;
+	pPnoInfoPkt += MAX_PNO_LIST_COUNT;
+	_rtw_memcpy(pPnoInfoPkt, &pwrctl->pnlo_info->loc_probe_req,
+			MAX_HIDDEN_AP);
+
+	*pLength+=MAX_HIDDEN_AP;
+	pPnoInfoPkt += MAX_HIDDEN_AP;
+}
+
+static void rtw_hal_construct_ssid_list(_adapter *padapter,
+	u8 *pframe, u32 *pLength)
+{
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
+	u8 *pSSIDListPkt = pframe;
+	int i;
+
+	pSSIDListPkt =  (u8*)(pframe+ *pLength);
+
+	for(i = 0; i < pwrctl->pnlo_info->ssid_num ; i++) {
+		_rtw_memcpy(pSSIDListPkt, &pwrctl->pno_ssid_list->node[i].SSID,
+			pwrctl->pnlo_info->ssid_length[i]);
+
+		*pLength += WLAN_SSID_MAXLEN;
+		pSSIDListPkt += WLAN_SSID_MAXLEN;
+	}
+}
+
+static void rtw_hal_construct_scan_info(_adapter *padapter,
+	u8 *pframe, u32 *pLength)
+{
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
+	u8 *pScanInfoPkt = pframe;
+	int i;
+
+	pScanInfoPkt =  (u8*)(pframe+ *pLength);
+
+	_rtw_memcpy(pScanInfoPkt, &pwrctl->pscan_info->channel_num, 1);
+
+	*pLength+=1;
+	pScanInfoPkt += 1;
+	_rtw_memcpy(pScanInfoPkt, &pwrctl->pscan_info->orig_ch, 1);
+
+
+	*pLength+=1;
+	pScanInfoPkt += 1;
+	_rtw_memcpy(pScanInfoPkt, &pwrctl->pscan_info->orig_bw, 1);
+
+
+	*pLength+=1;
+	pScanInfoPkt += 1;
+	_rtw_memcpy(pScanInfoPkt, &pwrctl->pscan_info->orig_40_offset, 1);
+
+	*pLength+=1;
+	pScanInfoPkt += 1;
+	_rtw_memcpy(pScanInfoPkt, &pwrctl->pscan_info->orig_80_offset, 1);
+
+	*pLength+=1;
+	pScanInfoPkt += 1;
+	_rtw_memcpy(pScanInfoPkt, &pwrctl->pscan_info->periodScan, 1);
+
+	*pLength+=1;
+	pScanInfoPkt += 1;
+	_rtw_memcpy(pScanInfoPkt, &pwrctl->pscan_info->period_scan_time, 1);
+
+	*pLength+=1;
+	pScanInfoPkt += 1;
+	_rtw_memcpy(pScanInfoPkt, &pwrctl->pscan_info->enableRFE, 1);
+
+	*pLength+=1;
+	pScanInfoPkt += 1;
+	_rtw_memcpy(pScanInfoPkt, &pwrctl->pscan_info->rfe_type, 8);
+
+	*pLength+=8;
+	pScanInfoPkt += 8;
+
+	for(i = 0 ; i < MAX_SCAN_LIST_COUNT ; i ++) {
+		_rtw_memcpy(pScanInfoPkt,
+			&pwrctl->pscan_info->ssid_channel_info[i], 4);
+		*pLength+=4;
+		pScanInfoPkt += 4;
+	}
+}
+#endif //CONFIG_PNO_SUPPORT
+
+#ifdef CONFIG_GTK_OL
+static void rtw_hal_construct_GTKRsp(
+	PADAPTER	padapter,
+	u8		*pframe,
+	u32		*pLength
+	)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16	*fctrl;
+	u32	pktlen;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	static u8	LLCHeader[8] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8E};
+	static u8	GTKbody_a[11] ={0x01, 0x03, 0x00, 0x5F, 0x02, 0x03, 0x12, 0x00, 0x10, 0x42, 0x0B};
+	u8	*pGTKRspPkt = pframe;
+	u8	EncryptionHeadOverhead = 0;
+	//DBG_871X("%s:%d\n", __FUNCTION__, bForcePowerSave);
+
+	pwlanhdr = (struct rtw_ieee80211_hdr*)pframe;
+
+	fctrl = &pwlanhdr->frame_ctl;
+	*(fctrl) = 0;
+
+	//-------------------------------------------------------------------------
+	// MAC Header.
+	//-------------------------------------------------------------------------
+	SetFrameType(fctrl, WIFI_DATA);
+	//SetFrameSubType(fctrl, 0);
+	SetToDs(fctrl);
+
+	_rtw_memcpy(pwlanhdr->addr1,
+			get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	_rtw_memcpy(pwlanhdr->addr2,
+			myid(&(padapter->eeprompriv)), ETH_ALEN);
+
+	_rtw_memcpy(pwlanhdr->addr3,
+			get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0);
+	SetDuration(pwlanhdr, 0);
+
+#ifdef CONFIG_WAPI_SUPPORT
+	*pLength = sMacHdrLng;
+#else
+	*pLength = 24;
+#endif //CONFIG_WAPI_SUPPORT
+
+	//-------------------------------------------------------------------------
+	// Security Header: leave space for it if necessary.
+	//-------------------------------------------------------------------------
+	switch (psecuritypriv->dot11PrivacyAlgrthm) {
+		case _WEP40_:
+		case _WEP104_:
+			EncryptionHeadOverhead = 4;
+			break;
+		case _TKIP_:
+			EncryptionHeadOverhead = 8;
+			break;
+		case _AES_:
+			EncryptionHeadOverhead = 8;
+			break;
+#ifdef CONFIG_WAPI_SUPPORT
+		case _SMS4_:
+			EncryptionHeadOverhead = 18;
+			break;
+#endif //CONFIG_WAPI_SUPPORT
+		default:
+			EncryptionHeadOverhead = 0;
+	}
+
+	if (EncryptionHeadOverhead > 0) {
+		_rtw_memset(&(pframe[*pLength]), 0,EncryptionHeadOverhead);
+		*pLength += EncryptionHeadOverhead;
+		//SET_80211_HDR_WEP(pGTKRspPkt, 1);  //Suggested by CCW.
+		//GTK's privacy bit is done by FW
+		//SetPrivacy(fctrl);
+	}
+	//-------------------------------------------------------------------------
+	// Frame Body.
+	//-------------------------------------------------------------------------
+	pGTKRspPkt =  (u8*)(pframe+ *pLength);
+	// LLC header
+	_rtw_memcpy(pGTKRspPkt, LLCHeader, 8);
+	*pLength += 8;
+
+	// GTK element
+	pGTKRspPkt += 8;
+
+	//GTK frame body after LLC, part 1
+	_rtw_memcpy(pGTKRspPkt, GTKbody_a, 11);
+	*pLength += 11;
+	pGTKRspPkt += 11;
+	//GTK frame body after LLC, part 2
+	_rtw_memset(&(pframe[*pLength]), 0, 88);
+	*pLength += 88;
+	pGTKRspPkt += 88;
+
+}
+#endif //CONFIG_GTK_OL
+#endif //CONFIG_WOWLAN
+
+void rtw_hal_fill_fake_txdesc(_adapter* padapter, u8* pDesc, u32 BufferLen,
+		u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame)
+{
+	struct hal_ops *pHalFunc = &padapter->HalFunc;
+	if (pHalFunc->fill_fake_txdesc == NULL) {
+		DBG_871X_LEVEL(_drv_err_,
+				"%s missing fill_fake_txdesc\n", __func__);
+		return;
+	} else {
+		pHalFunc->fill_fake_txdesc(padapter, pDesc, BufferLen,
+				IsPsPoll, IsBTQosNull, bDataFrame);
+	}
+}
+
+//
+// Description: Fill the reserved packets that FW will use to RSVD page.
+//			Now we just send 4 types packet to rsvd page.
+//			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp.
+// Input:
+// finished - FALSE:At the first time we will send all the packets as a large packet to Hw,
+//		    so we need to set the packet length to total lengh.
+//	      TRUE: At the second time, we should send the first packet (default:beacon)
+//		    to Hw again and set the lengh in descriptor to the real beacon lengh.
+// 2009.10.15 by tynli.
+//
+//Page Size = 128: 8188e, 8723a/b, 8192c/d,  
+//Page Size = 256: 8192e, 8821a
+//Page Size = 512: 8812a
+void rtw_hal_set_fw_rsvd_page(_adapter* adapter, bool finished)
+{
+	PHAL_DATA_TYPE pHalData;
+	struct xmit_frame	*pcmdframe;
+	struct pkt_attrib	*pattrib;
+	struct xmit_priv	*pxmitpriv;
+	struct mlme_ext_priv	*pmlmeext;
+	struct mlme_ext_info	*pmlmeinfo;
+	struct pwrctrl_priv *pwrctl;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct hal_ops *pHalFunc = &adapter->HalFunc;
+	u32	BeaconLength = 0, ProbeRspLength = 0, PSPollLength = 0;
+	u32	NullDataLength = 0, QosNullLength = 0, BTQosNullLength = 0;
+	u32	ProbeReqLength = 0, NullFunctionDataLength = 0;
+	u8	TxDescLen = TXDESC_SIZE, TxDescOffset = TXDESC_OFFSET;
+	u8	TotalPageNum=0, CurtPktPageNum=0, RsvdPageNum=0;
+	u8	*ReservedPagePacket;
+	u16	BufIndex = 0;
+	u32	TotalPacketLen = 0, MaxRsvdPageBufSize = 0, PageSize = 0;
+	RSVDPAGE_LOC	RsvdPageLoc;
+#ifdef CONFIG_WOWLAN	
+	u32	ARPLegnth = 0, GTKLegnth = 0, PNOLength = 0, ScanInfoLength = 0;
+	u32	SSIDLegnth = 0;
+	struct security_priv *psecuritypriv = &adapter->securitypriv; //added by xx
+	u8 currentip[4];
+	u8 cur_dot11txpn[8];
+#ifdef CONFIG_GTK_OL
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct sta_info * psta;
+	u8 kek[RTW_KEK_LEN];
+	u8 kck[RTW_KCK_LEN];
+#endif //CONFIG_GTK_OL
+#ifdef	CONFIG_PNO_SUPPORT 
+	int index;
+	u8 ssid_num;
+#endif //CONFIG_PNO_SUPPORT
+#endif
+#ifdef DBG_CONFIG_ERROR_DETECT
+	struct sreset_priv *psrtpriv;
+#endif // DBG_CONFIG_ERROR_DETECT
+
+#ifdef CONFIG_P2P_WOWLAN
+	u32 P2PNegoRspLength = 0, P2PInviteRspLength = 0, P2PPDRspLength = 0, P2PProbeRspLength = 0, P2PBCNLength = 0;
+#endif
+
+	pHalData = GET_HAL_DATA(adapter);
+#ifdef DBG_CONFIG_ERROR_DETECT
+	psrtpriv = &pHalData->srestpriv;
+#endif
+	pxmitpriv = &adapter->xmitpriv;
+	pmlmeext = &adapter->mlmeextpriv;
+	pmlmeinfo = &pmlmeext->mlmext_info;
+	pwrctl = adapter_to_pwrctl(adapter);
+
+	rtw_hal_get_def_var(adapter, HAL_DEF_TX_PAGE_SIZE, (u8 *)&PageSize);
+	DBG_871X("%s PAGE_SIZE: %d\n", __func__, PageSize);
+	if (pHalFunc->hal_get_tx_buff_rsvd_page_num != NULL) {
+		RsvdPageNum =
+			pHalFunc->hal_get_tx_buff_rsvd_page_num(adapter, _TRUE);
+		DBG_871X("%s RsvdPageNUm: %d\n", __func__, RsvdPageNum);
+	} else {
+		DBG_871X("[Error]: %s, missing tx_buff_rsvd_page_num func!!\n",
+				__func__);
+		return;
+	}
+
+	MaxRsvdPageBufSize = RsvdPageNum*PageSize;
+
+	pcmdframe = rtw_alloc_cmdxmitframe(pxmitpriv);
+	if (pcmdframe == NULL) {
+		DBG_871X("%s: alloc ReservedPagePacket fail!\n", __FUNCTION__);
+		return;
+	}
+
+	ReservedPagePacket = pcmdframe->buf_addr;
+	_rtw_memset(&RsvdPageLoc, 0, sizeof(RSVDPAGE_LOC));
+
+	//beacon * 2 pages
+	BufIndex = TxDescOffset;
+	rtw_hal_construct_beacon(adapter,
+			&ReservedPagePacket[BufIndex], &BeaconLength);
+
+	// When we count the first page size, we need to reserve description size for the RSVD
+	// packet, it will be filled in front of the packet in TXPKTBUF.
+	CurtPktPageNum = (u8)PageNum_128(TxDescLen + BeaconLength);
+	//If we don't add 1 more page, the WOWLAN function has a problem. Baron thinks it's a bug of firmware
+	if (CurtPktPageNum == 1)
+		CurtPktPageNum += 1;
+
+	TotalPageNum += CurtPktPageNum;
+
+	BufIndex += (CurtPktPageNum*PageSize);
+
+	//ps-poll * 1 page
+	RsvdPageLoc.LocPsPoll = TotalPageNum;
+	DBG_871X("LocPsPoll: %d\n", RsvdPageLoc.LocPsPoll);
+	rtw_hal_construct_PSPoll(adapter,
+			&ReservedPagePacket[BufIndex], &PSPollLength);
+	rtw_hal_fill_fake_txdesc(adapter,
+			&ReservedPagePacket[BufIndex-TxDescLen],
+			PSPollLength, _TRUE, _FALSE, _FALSE);
+
+	CurtPktPageNum = (u8)PageNum((TxDescLen + PSPollLength), PageSize);
+
+	TotalPageNum += CurtPktPageNum;
+
+	BufIndex += (CurtPktPageNum*PageSize);
+
+#ifdef CONFIG_BT_COEXIST
+	//BT Qos null data * 1 page
+	RsvdPageLoc.LocBTQosNull = TotalPageNum;
+	DBG_871X("LocBTQosNull: %d\n", RsvdPageLoc.LocBTQosNull);
+	rtw_hal_construct_NullFunctionData(
+			adapter,
+			&ReservedPagePacket[BufIndex],
+			&BTQosNullLength,
+			get_my_bssid(&pmlmeinfo->network),
+			_TRUE, 0, 0, _FALSE);
+	rtw_hal_fill_fake_txdesc(adapter,
+			&ReservedPagePacket[BufIndex-TxDescLen],
+			BTQosNullLength, _FALSE, _TRUE, _FALSE);
+
+	CurtPktPageNum = (u8)PageNum(TxDescLen + BTQosNullLength, PageSize);
+
+	TotalPageNum += CurtPktPageNum;
+
+	BufIndex += (CurtPktPageNum*PageSize);
+#endif //CONFIG_BT_COEXIT
+
+	//null data * 1 page
+	RsvdPageLoc.LocNullData = TotalPageNum;
+	DBG_871X("LocNullData: %d\n", RsvdPageLoc.LocNullData);
+	rtw_hal_construct_NullFunctionData(
+			adapter,
+			&ReservedPagePacket[BufIndex],
+			&NullDataLength,
+			get_my_bssid(&pmlmeinfo->network),
+			_FALSE, 0, 0, _FALSE);
+	rtw_hal_fill_fake_txdesc(adapter,
+			&ReservedPagePacket[BufIndex-TxDescLen],
+			NullDataLength, _FALSE, _FALSE, _FALSE);
+
+	CurtPktPageNum = (u8)PageNum(TxDescLen + NullDataLength, PageSize);
+
+	TotalPageNum += CurtPktPageNum;
+
+	BufIndex += (CurtPktPageNum*PageSize);
+
+	//Qos null data * 1 page
+	RsvdPageLoc.LocQosNull = TotalPageNum;
+	DBG_871X("LocQosNull: %d\n", RsvdPageLoc.LocQosNull);
+	rtw_hal_construct_NullFunctionData(
+			adapter,
+			&ReservedPagePacket[BufIndex],
+			&QosNullLength,
+			get_my_bssid(&pmlmeinfo->network),
+			_TRUE, 0, 0, _FALSE);
+	rtw_hal_fill_fake_txdesc(adapter,
+			&ReservedPagePacket[BufIndex-TxDescLen],
+			QosNullLength, _FALSE, _FALSE, _FALSE);
+
+	CurtPktPageNum = (u8)PageNum(TxDescLen + QosNullLength, PageSize);
+
+	TotalPageNum += CurtPktPageNum;
+
+	BufIndex += (CurtPktPageNum*PageSize);
+
+#ifdef CONFIG_WOWLAN
+	if (pwrctl->wowlan_mode == _TRUE &&
+			check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+		//ARP RSP * 1 page
+		rtw_get_current_ip_address(adapter, currentip);
+
+		RsvdPageLoc.LocArpRsp= TotalPageNum;
+
+		rtw_hal_construct_ARPRsp(
+				adapter,
+				&ReservedPagePacket[BufIndex],
+				&ARPLegnth,
+				currentip);
+
+		rtw_hal_fill_fake_txdesc(adapter,
+				&ReservedPagePacket[BufIndex-TxDescLen],
+				ARPLegnth, _FALSE, _FALSE, _TRUE);
+
+		CurtPktPageNum = (u8)PageNum(TxDescLen + ARPLegnth, PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		//3 SEC IV * 1 page
+		rtw_get_sec_iv(adapter, cur_dot11txpn,
+				get_my_bssid(&pmlmeinfo->network));
+
+		RsvdPageLoc.LocRemoteCtrlInfo = TotalPageNum;
+
+		_rtw_memcpy(ReservedPagePacket+BufIndex-TxDescLen,
+				cur_dot11txpn, _AES_IV_LEN_);
+
+		CurtPktPageNum = (u8)PageNum(_AES_IV_LEN_, PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+#ifdef CONFIG_GTK_OL
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		//if the ap staion info. exists, get the kek, kck from staion info.
+		psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+		if (psta == NULL) {
+			_rtw_memset(kek, 0, RTW_KEK_LEN);
+			_rtw_memset(kck, 0, RTW_KCK_LEN);
+			DBG_8192C("%s, KEK, KCK download rsvd page all zero \n",
+					__func__);
+		} else {
+			_rtw_memcpy(kek, psta->kek, RTW_KEK_LEN);
+			_rtw_memcpy(kck, psta->kck, RTW_KCK_LEN);
+		}
+
+		//3 KEK, KCK
+		RsvdPageLoc.LocGTKInfo = TotalPageNum;
+		_rtw_memcpy(ReservedPagePacket+BufIndex-TxDescLen,
+				kck, RTW_KCK_LEN);
+		_rtw_memcpy(ReservedPagePacket+BufIndex-TxDescLen+RTW_KCK_LEN,
+				kek, RTW_KEK_LEN);
+#if 0
+		{
+			int i;
+			printk("\ntoFW KCK: ");
+			for(i=0;i<16; i++)
+				printk(" %02x ", kck[i]);
+			printk("\ntoFW KEK: ");
+			for(i=0;i<16; i++)
+				printk(" %02x ", kek[i]);
+			printk("\n");
+		}
+#endif
+
+		//DBG_871X("%s(): HW_VAR_SET_TX_CMD: KEK KCK %p %d\n", 
+		//	__FUNCTION__, &ReservedPagePacket[BufIndex-TxDescLen],
+		//	(TxDescLen + RTW_KCK_LEN + RTW_KEK_LEN));
+
+		CurtPktPageNum = (u8)PageNum(TxDescLen + RTW_KCK_LEN + RTW_KEK_LEN, PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		//3 GTK Response
+		RsvdPageLoc.LocGTKRsp= TotalPageNum;
+		rtw_hal_construct_GTKRsp(
+				adapter,
+				&ReservedPagePacket[BufIndex],
+				&GTKLegnth);
+
+		rtw_hal_fill_fake_txdesc(adapter,
+				&ReservedPagePacket[BufIndex-TxDescLen],
+				GTKLegnth, _FALSE, _FALSE, _TRUE);
+#if 0
+		{
+			int gj;
+			printk("123GTK pkt=> \n");
+			for(gj=0; gj < GTKLegnth+TxDescLen; gj++) {
+				printk(" %02x ", ReservedPagePacket[BufIndex-TxDescLen+gj]);
+				if ((gj + 1)%16==0)
+					printk("\n");
+			}
+			printk(" <=end\n");
+		}
+#endif
+
+		//DBG_871X("%s(): HW_VAR_SET_TX_CMD: GTK RSP %p %d\n", 
+		//	__FUNCTION__, &ReservedPagePacket[BufIndex-TxDescLen],
+		//	(TxDescLen + GTKLegnth));
+
+		CurtPktPageNum = (u8)PageNum(TxDescLen + GTKLegnth, PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		//below page is empty for GTK extension memory
+		//3(11) GTK EXT MEM
+		RsvdPageLoc.LocGTKEXTMEM= TotalPageNum;
+
+		CurtPktPageNum = 2;
+
+		TotalPageNum += CurtPktPageNum;
+		//extension memory for FW
+		TotalPacketLen = BufIndex-TxDescLen + (PageSize*CurtPktPageNum);
+#else //CONFIG_GTK_OL
+		TotalPacketLen = BufIndex + _AES_IV_LEN_;
+#endif //CONFIG_GTK_OL
+	} else if (pwrctl->wowlan_pno_enable == _TRUE) {
+#ifdef CONFIG_PNO_SUPPORT
+		if (pwrctl->pno_in_resume == _FALSE &&
+				pwrctl->pno_inited == _TRUE) {
+
+			//Broadcast Probe Request
+			RsvdPageLoc.LocProbePacket = TotalPageNum;
+
+			DBG_871X("loc_probe_req: %d\n",
+					RsvdPageLoc.LocProbePacket);
+
+			rtw_hal_construct_ProbeReq(
+				adapter,
+				&ReservedPagePacket[BufIndex],
+				&ProbeReqLength,
+				NULL);
+
+			rtw_hal_fill_fake_txdesc(adapter,
+				&ReservedPagePacket[BufIndex-TxDescLen],
+				ProbeReqLength, _FALSE, _FALSE, _FALSE);
+
+			CurtPktPageNum =
+				(u8)PageNum(TxDescLen + ProbeReqLength, PageSize);
+
+			TotalPageNum += CurtPktPageNum;
+
+			BufIndex += (CurtPktPageNum*PageSize);
+
+			//Hidden SSID Probe Request
+			ssid_num = pwrctl->pnlo_info->hidden_ssid_num;
+
+			for (index = 0 ; index < ssid_num ; index++) {
+				pwrctl->pnlo_info->loc_probe_req[index] =
+					TotalPageNum;
+
+				rtw_hal_construct_ProbeReq(
+					adapter,
+					&ReservedPagePacket[BufIndex],
+					&ProbeReqLength,
+					&pwrctl->pno_ssid_list->node[index]);
+
+				rtw_hal_fill_fake_txdesc(adapter,
+					&ReservedPagePacket[BufIndex-TxDescLen],
+					ProbeReqLength, _FALSE, _FALSE, _FALSE);
+
+				CurtPktPageNum =
+					(u8)PageNum(TxDescLen + ProbeReqLength, PageSize);
+
+				TotalPageNum += CurtPktPageNum;
+
+				BufIndex += (CurtPktPageNum*PageSize);
+			}
+
+			//PNO INFO Page
+			RsvdPageLoc.LocPNOInfo = TotalPageNum;
+			rtw_hal_construct_PNO_info(adapter,
+					&ReservedPagePacket[BufIndex -TxDescLen],
+					&PNOLength);
+
+			CurtPktPageNum = (u8)PageNum_128(PNOLength);
+			TotalPageNum += CurtPktPageNum;
+			BufIndex += (CurtPktPageNum*PageSize);
+
+			//SSID List Page
+			RsvdPageLoc.LocSSIDInfo = TotalPageNum;
+			rtw_hal_construct_ssid_list(adapter,
+					&ReservedPagePacket[BufIndex-TxDescLen],
+					&SSIDLegnth);
+
+			CurtPktPageNum = (u8)PageNum_128(SSIDLegnth);
+			TotalPageNum += CurtPktPageNum;
+			BufIndex += (CurtPktPageNum*PageSize);
+
+			//Scan Info Page
+			RsvdPageLoc.LocScanInfo = TotalPageNum;
+			rtw_hal_construct_scan_info(adapter,
+					&ReservedPagePacket[BufIndex-TxDescLen],
+					&ScanInfoLength);
+
+			CurtPktPageNum = (u8)PageNum(ScanInfoLength, PageSize);
+			TotalPageNum += CurtPktPageNum;
+			BufIndex += (CurtPktPageNum*PageSize);
+			TotalPacketLen = BufIndex + ScanInfoLength;
+		} else {
+			TotalPacketLen = BufIndex + QosNullLength;
+		}
+#endif //CONFIG_PNO_SUPPORT
+	} else {
+		TotalPacketLen = BufIndex + QosNullLength;
+	}
+#else //CONFIG_WOWLAN
+	TotalPacketLen = BufIndex + QosNullLength;
+#endif //CONFIG_WOWLAN
+
+#ifdef CONFIG_P2P_WOWLAN
+	if(_TRUE == pwrctl->wowlan_p2p_mode)
+	{
+
+		// P2P Beacon
+		RsvdPageLoc.LocP2PBeacon= TotalPageNum;
+		rtw_hal_construct_P2PBeacon(
+			adapter,
+			&ReservedPagePacket[BufIndex],
+			&P2PBCNLength);
+		rtw_hal_fill_fake_txdesc(adapter, 
+			&ReservedPagePacket[BufIndex-TxDescLen], 
+			P2PBCNLength, _FALSE, _FALSE, _FALSE);
+
+		//DBG_871X("%s(): HW_VAR_SET_TX_CMD: PROBE RSP %p %d\n", 
+		//	__FUNCTION__, &ReservedPagePacket[BufIndex-TxDescLen], (P2PBCNLength+TxDescLen));
+
+		CurtPktPageNum = (u8)PageNum(TxDescLen + P2PBCNLength, PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		// P2P Probe rsp
+		RsvdPageLoc.LocP2PProbeRsp = TotalPageNum;
+		rtw_hal_construct_P2PProbeRsp(
+			adapter,
+			&ReservedPagePacket[BufIndex],
+			&P2PProbeRspLength);
+		rtw_hal_fill_fake_txdesc(adapter, 
+			&ReservedPagePacket[BufIndex-TxDescLen], 
+			P2PProbeRspLength, _FALSE, _FALSE, _FALSE);
+
+		//DBG_871X("%s(): HW_VAR_SET_TX_CMD: PROBE RSP %p %d\n", 
+		//	__FUNCTION__, &ReservedPagePacket[BufIndex-TxDescLen], (P2PProbeRspLength+TxDescLen));
+
+		CurtPktPageNum = (u8)PageNum(TxDescLen + P2PProbeRspLength, PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		//P2P nego rsp
+		RsvdPageLoc.LocNegoRsp = TotalPageNum;
+		rtw_hal_construct_P2PNegoRsp(
+			adapter,
+			&ReservedPagePacket[BufIndex],
+			&P2PNegoRspLength);
+		rtw_hal_fill_fake_txdesc(adapter, 
+			&ReservedPagePacket[BufIndex-TxDescLen], 
+			P2PNegoRspLength, _FALSE, _FALSE, _FALSE);
+
+		//DBG_871X("%s(): HW_VAR_SET_TX_CMD: QOS NULL DATA %p %d\n", 
+		//	__FUNCTION__, &ReservedPagePacket[BufIndex-TxDescLen], (NegoRspLength+TxDescLen));
+
+		CurtPktPageNum = (u8)PageNum(TxDescLen + P2PNegoRspLength, PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		BufIndex += (CurtPktPageNum*PageSize);
+		
+		//P2P invite rsp
+		RsvdPageLoc.LocInviteRsp = TotalPageNum;
+		rtw_hal_construct_P2PInviteRsp(
+			adapter,
+			&ReservedPagePacket[BufIndex],
+			&P2PInviteRspLength);
+		rtw_hal_fill_fake_txdesc(adapter, 
+			&ReservedPagePacket[BufIndex-TxDescLen], 
+			P2PInviteRspLength, _FALSE, _FALSE, _FALSE);
+
+		//DBG_871X("%s(): HW_VAR_SET_TX_CMD: QOS NULL DATA %p %d\n", 
+		//	__FUNCTION__, &ReservedPagePacket[BufIndex-TxDescLen], (InviteRspLength+TxDescLen));
+
+		CurtPktPageNum = (u8)PageNum(TxDescLen + P2PInviteRspLength, PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		BufIndex += (CurtPktPageNum*PageSize);
+	
+		//P2P provision discovery rsp
+		RsvdPageLoc.LocPDRsp = TotalPageNum;
+		rtw_hal_construct_P2PProvisionDisRsp(
+			adapter,
+			&ReservedPagePacket[BufIndex],
+			&P2PPDRspLength);
+		rtw_hal_fill_fake_txdesc(adapter, 
+			&ReservedPagePacket[BufIndex-TxDescLen], 
+			P2PPDRspLength, _FALSE, _FALSE, _FALSE);
+
+		//DBG_871X("%s(): HW_VAR_SET_TX_CMD: QOS NULL DATA %p %d\n", 
+		//	__FUNCTION__, &ReservedPagePacket[BufIndex-TxDescLen], (PDRspLength+TxDescLen));
+
+		CurtPktPageNum = (u8)PageNum(TxDescLen + P2PPDRspLength, PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		TotalPacketLen = BufIndex + P2PPDRspLength;
+	}
+#endif //CONFIG_P2P_WOWLAN
+
+	if(TotalPacketLen > MaxRsvdPageBufSize) {
+		DBG_871X("%s(ERROR): rsvd page size is not enough!!TotalPacketLen %d, MaxRsvdPageBufSize %d\n",
+				__FUNCTION__, TotalPacketLen,MaxRsvdPageBufSize);
+		goto error;
+	} else {
+		// update attribute
+		pattrib = &pcmdframe->attrib;
+		update_mgntframe_attrib(adapter, pattrib);
+		pattrib->qsel = 0x10;
+		pattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TxDescOffset;
+#ifdef CONFIG_PCI_HCI
+		dump_mgntframe(adapter, pcmdframe);
+#else
+		dump_mgntframe_and_wait(adapter, pcmdframe, 100);
+#endif
+	}
+
+	DBG_871X("%s: Set RSVD page location to Fw ,TotalPacketLen(%d), TotalPageNum(%d)\n",
+			__func__,TotalPacketLen,TotalPageNum);
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+		rtw_hal_set_FwRsvdPage_cmd(adapter, &RsvdPageLoc);
+		if (pwrctl->wowlan_mode == _TRUE)
+			rtw_hal_set_FwAoacRsvdPage_cmd(adapter, &RsvdPageLoc);
+	} else if (pwrctl->wowlan_pno_enable) {
+#ifdef CONFIG_PNO_SUPPORT
+		rtw_hal_set_FwAoacRsvdPage_cmd(adapter, &RsvdPageLoc);
+		if(pwrctl->pno_in_resume)
+			rtw_hal_set_scan_offload_info_cmd(adapter,
+					&RsvdPageLoc, 0);
+		else
+			rtw_hal_set_scan_offload_info_cmd(adapter,
+					&RsvdPageLoc, 1);
+#endif //CONFIG_PNO_SUPPORT
+	}
+#ifdef CONFIG_P2P_WOWLAN
+	if(_TRUE == pwrctl->wowlan_p2p_mode)
+		rtw_hal_set_FwP2PRsvdPage_cmd(adapter, &RsvdPageLoc);
+	
+#endif //CONFIG_P2P_WOWLAN
+	return;
+error:
+	rtw_free_xmitframe(pxmitpriv, pcmdframe);
+}
+
+void SetHwReg(_adapter *adapter, u8 variable, u8 *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	DM_ODM_T *odm = &(hal_data->odmpriv);
+
+_func_enter_;
+
+	switch (variable) {
+		case HW_VAR_INITIAL_GAIN:
+			{				
+				u32 rx_gain = ((u32 *)(val))[0];
+		
+				if(rx_gain == 0xff){//restore rx gain					
+					//ODM_Write_DIG(podmpriv,pDigTable->BackupIGValue);
+					odm_PauseDIG(odm, ODM_RESUME_DIG,rx_gain);
+				}
+				else{
+					//pDigTable->BackupIGValue = pDigTable->CurIGValue;
+					//ODM_Write_DIG(podmpriv,rx_gain);
+					odm_PauseDIG(odm, ODM_PAUSE_DIG,rx_gain);
+				}
+			}
+			break;		
+		case HW_VAR_PORT_SWITCH:
+			hw_var_port_switch(adapter);
+			break;
+		case HW_VAR_INIT_RTS_RATE:
+		{
+			u16 brate_cfg = *((u16*)val);
+			u8 rate_index = 0;
+			HAL_VERSION *hal_ver = &hal_data->VersionID;
+
+			if (IS_81XXC(*hal_ver) ||IS_92D(*hal_ver) || IS_8723_SERIES(*hal_ver) || IS_8188E(*hal_ver)) {
+
+				while (brate_cfg > 0x1) {
+					brate_cfg = (brate_cfg >> 1);
+					rate_index++;
+				}
+				rtw_write8(adapter, REG_INIRTS_RATE_SEL, rate_index);
+			} else {
+				rtw_warn_on(1);
+			}
+		}
+			break;
+		case HW_VAR_SEC_CFG:
+		{
+			#if defined(CONFIG_CONCURRENT_MODE) && !defined(DYNAMIC_CAMID_ALLOC)
+			// enable tx enc and rx dec engine, and no key search for MC/BC
+			rtw_write8(adapter, REG_SECCFG, SCR_NoSKMC|SCR_RxDecEnable|SCR_TxEncEnable);
+			#elif defined(DYNAMIC_CAMID_ALLOC)
+			u16 reg_scr;
+
+			reg_scr = rtw_read16(adapter, REG_SECCFG);
+			rtw_write16(adapter, REG_SECCFG, reg_scr|SCR_CHK_KEYID|SCR_RxDecEnable|SCR_TxEncEnable);
+			#else
+			rtw_write8(adapter, REG_SECCFG, *((u8*)val));
+			#endif
+		}
+			break;
+		case HW_VAR_SEC_DK_CFG:
+		{
+			struct security_priv *sec = &adapter->securitypriv;
+			u8 reg_scr = rtw_read8(adapter, REG_SECCFG);
+
+			if (val) /* Enable default key related setting */
+			{
+				reg_scr |= SCR_TXBCUSEDK;
+				if (sec->dot11AuthAlgrthm != dot11AuthAlgrthm_8021X)
+					reg_scr |= (SCR_RxUseDK|SCR_TxUseDK);
+			}
+			else /* Disable default key related setting */
+			{
+				reg_scr &= ~(SCR_RXBCUSEDK|SCR_TXBCUSEDK|SCR_RxUseDK|SCR_TxUseDK);
+			}
+
+			rtw_write8(adapter, REG_SECCFG, reg_scr);
+		}
+			break;
+		case HW_VAR_DM_FLAG:
+			odm->SupportAbility = *((u32*)val);
+			break;
+		case HW_VAR_DM_FUNC_OP:
+			if (*((u8*)val) == _TRUE) {
+				/* save dm flag */
+				odm->BK_SupportAbility = odm->SupportAbility;				
+			} else {
+				/* restore dm flag */
+				odm->SupportAbility = odm->BK_SupportAbility;
+			}
+			break;
+		case HW_VAR_DM_FUNC_SET:
+			if(*((u32*)val) == DYNAMIC_ALL_FUNC_ENABLE){
+				struct dm_priv	*dm = &hal_data->dmpriv;
+				dm->DMFlag = dm->InitDMFlag;
+				odm->SupportAbility = dm->InitODMFlag;
+			} else {
+				odm->SupportAbility |= *((u32 *)val);
+			}
+			break;
+		case HW_VAR_DM_FUNC_CLR:
+			/*
+			* input is already a mask to clear function
+			* don't invert it again! George,Lucas@20130513
+			*/
+			odm->SupportAbility &= *((u32 *)val);
+			break;
+		case HW_VAR_ASIX_IOT:
+			// enable  ASIX IOT function
+			if (*((u8*)val) == _TRUE) {
+				// 0xa2e[0]=0 (disable rake receiver)
+				rtw_write8(adapter, rCCK0_FalseAlarmReport+2, 
+						rtw_read8(adapter, rCCK0_FalseAlarmReport+2) & ~(BIT0));
+				//  0xa1c=0xa0 (reset channel estimation if signal quality is bad)
+				rtw_write8(adapter, rCCK0_DSPParameter2, 0xa0);
+			} else {
+			// restore reg:0xa2e,   reg:0xa1c
+				rtw_write8(adapter, rCCK0_FalseAlarmReport+2, 
+						rtw_read8(adapter, rCCK0_FalseAlarmReport+2)|(BIT0));
+				rtw_write8(adapter, rCCK0_DSPParameter2, 0x00);
+			}
+			break;
+		case HW_VAR_MAX_AGGR_NUM:
+			DBG_871X("%s HW_VAR_MAX_AGGR_NUM: %04x\n", __func__, *((u16*)val));
+			rtw_write16(adapter, REG_MAX_AGGR_NUM, *((u16*)val));
+		break;
+#ifdef CONFIG_WOWLAN
+	case HW_VAR_WOWLAN:
+	{
+		struct wowlan_ioctl_param *poidparam;
+		struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(adapter);
+		struct security_priv *psecuritypriv = &adapter->securitypriv;
+		struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+		struct hal_ops *pHalFunc = &adapter->HalFunc;
+		struct sta_info *psta = NULL;
+		int res;
+		u16 media_status_rpt;
+		u8 val8;
+
+		poidparam = (struct wowlan_ioctl_param *)val;
+		switch (poidparam->subcode) {
+			case WOWLAN_ENABLE:
+				DBG_871X_LEVEL(_drv_always_, "WOWLAN_ENABLE\n");
+
+#ifdef CONFIG_GTK_OL
+				if (psecuritypriv->dot11PrivacyAlgrthm == _AES_)
+					rtw_hal_fw_sync_cam_id(adapter);
+#endif
+				if (IS_HARDWARE_TYPE_8723B(adapter))
+					rtw_hal_backup_rate(adapter);
+
+				if (pHalFunc->hal_set_wowlan_fw != NULL)
+					pHalFunc->hal_set_wowlan_fw(adapter, _TRUE);
+				else
+					DBG_871X("hal_set_wowlan_fw is null\n");
+
+				media_status_rpt = RT_MEDIA_CONNECT;
+				rtw_hal_set_hwreg(adapter,
+						HW_VAR_H2C_FW_JOINBSSRPT,
+						(u8 *)&media_status_rpt);
+
+				if (!pwrctl->wowlan_pno_enable) {
+					psta = rtw_get_stainfo(&adapter->stapriv,
+							get_bssid(pmlmepriv));
+					media_status_rpt =
+						(u16)((psta->mac_id<<8)|RT_MEDIA_CONNECT);
+					if (psta != NULL) {
+						rtw_hal_set_hwreg(adapter,
+								HW_VAR_H2C_MEDIA_STATUS_RPT,
+								(u8 *)&media_status_rpt);
+					}
+				}
+
+				rtw_msleep_os(2);
+
+				if (IS_HARDWARE_TYPE_8188E(adapter))
+					rtw_hal_disable_tx_report(adapter);
+
+				//RX DMA stop
+				res = rtw_hal_pause_rx_dma(adapter);
+				if (res == _FAIL)
+					DBG_871X_LEVEL(_drv_always_, "[WARNING] pause RX DMA fail\n");
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+				//Enable CPWM2 only.
+				res = rtw_hal_enable_cpwm2(adapter);
+				if (res == _FAIL)
+					DBG_871X_LEVEL(_drv_always_, "[WARNING] enable cpwm2 fail\n");
+#endif
+
+				//Set WOWLAN H2C command.
+				DBG_871X_LEVEL(_drv_always_, "Set WOWLan cmd\n");
+				rtw_hal_set_fw_wow_related_cmd(adapter, 1);
+
+				res = rtw_hal_check_wow_ctrl(adapter, _TRUE);
+				if (res == _FALSE)
+					DBG_871X("[Error]%s: set wowlan CMD fail!!\n", __func__);
+
+				pwrctl->wowlan_wake_reason =
+					rtw_read8(adapter, REG_WOWLAN_WAKE_REASON);
+
+				DBG_871X_LEVEL(_drv_always_,
+						"wowlan_wake_reason: 0x%02x\n",
+						pwrctl->wowlan_wake_reason);
+#ifdef CONFIG_GTK_OL_DBG
+				dump_cam_table(adapter);
+#endif
+#ifdef CONFIG_USB_HCI
+				if (adapter->intf_stop)
+					adapter->intf_stop(adapter);
+
+				/* Invoid SE0 reset signal during suspending*/
+				rtw_write8(adapter, REG_RSV_CTRL, 0x20);
+				rtw_write8(adapter, REG_RSV_CTRL, 0x60);
+#endif //CONFIG_USB_HCI
+				break;
+			case WOWLAN_DISABLE:
+				DBG_871X_LEVEL(_drv_always_, "WOWLAN_DISABLE\n");
+
+				if (!pwrctl->wowlan_pno_enable) {
+					psta = rtw_get_stainfo(&adapter->stapriv,
+								get_bssid(pmlmepriv));
+
+					if (psta != NULL) {
+						media_status_rpt =
+							(u16)((psta->mac_id<<8)|RT_MEDIA_DISCONNECT);
+						rtw_hal_set_hwreg(adapter,
+								HW_VAR_H2C_MEDIA_STATUS_RPT,
+								(u8 *)&media_status_rpt);
+					} else {
+						DBG_871X("%s: psta is null\n", __func__);
+					}
+				}
+
+				if (0) {
+					DBG_871X("0x630:0x%02x\n",
+							rtw_read8(adapter, 0x630));
+					DBG_871X("0x631:0x%02x\n",
+							rtw_read8(adapter, 0x631));
+				}
+
+				pwrctl->wowlan_wake_reason = rtw_read8(adapter,
+						REG_WOWLAN_WAKE_REASON);
+
+				DBG_871X_LEVEL(_drv_always_, "wakeup_reason: 0x%02x\n",
+						pwrctl->wowlan_wake_reason);
+
+				rtw_hal_set_fw_wow_related_cmd(adapter, 0);
+
+				res = rtw_hal_check_wow_ctrl(adapter, _FALSE);
+				if (res == _FALSE) {
+					DBG_871X("[Error]%s: disable WOW cmd fail\n!!", __func__);
+					rtw_hal_force_enable_rxdma(adapter);
+				}
+
+				if (IS_HARDWARE_TYPE_8188E(adapter))
+					rtw_hal_enable_tx_report(adapter);
+
+				rtw_hal_update_tx_iv(adapter);
+
+#ifdef CONFIG_GTK_OL
+				if (psecuritypriv->dot11PrivacyAlgrthm == _AES_)
+					rtw_hal_update_gtk_offload_info(adapter);
+#endif //CONFIG_GTK_OL
+
+				if (pHalFunc->hal_set_wowlan_fw != NULL)
+					pHalFunc->hal_set_wowlan_fw(adapter, _FALSE);
+				else
+					DBG_871X("hal_set_wowlan_fw is null\n");
+#ifdef CONFIG_GPIO_WAKEUP
+				DBG_871X_LEVEL(_drv_always_, "Set Wake GPIO to high for default.\n");
+				rtw_hal_set_output_gpio(adapter, WAKEUP_GPIO_IDX, 1);
+#endif
+				if((pwrctl->wowlan_wake_reason != FWDecisionDisconnect) &&
+					(pwrctl->wowlan_wake_reason != Rx_Pairwisekey) &&
+					(pwrctl->wowlan_wake_reason != Rx_DisAssoc) &&
+					(pwrctl->wowlan_wake_reason != Rx_DeAuth)) {
+
+					//rtw_hal_download_rsvd_page(adapter, RT_MEDIA_CONNECT);
+
+					media_status_rpt = RT_MEDIA_CONNECT;
+					rtw_hal_set_hwreg(adapter,
+						HW_VAR_H2C_FW_JOINBSSRPT,
+						(u8 *)&media_status_rpt);
+
+					if (psta != NULL) {
+						media_status_rpt =
+							(u16)((psta->mac_id<<8)|RT_MEDIA_CONNECT);
+						rtw_hal_set_hwreg(adapter,
+								HW_VAR_H2C_MEDIA_STATUS_RPT,
+								(u8 *)&media_status_rpt);
+					}
+				}
+				break;
+			default:
+				break;
+			}
+		}
+		break;
+#endif //CONFIG_WOWLAN
+		default:
+			if (0)
+			DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" variable(%d) not defined!\n",
+				FUNC_ADPT_ARG(adapter), variable);
+			break;
+	}
+
+_func_exit_;
+}
+
+void GetHwReg(_adapter *adapter, u8 variable, u8 *val)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	DM_ODM_T *odm = &(hal_data->odmpriv);
+
+_func_enter_;
+
+	switch (variable) {
+	case HW_VAR_BASIC_RATE:
+		*((u16*)val) = hal_data->BasicRateSet;
+		break;
+	case HW_VAR_DM_FLAG:
+		*((u32*)val) = odm->SupportAbility;
+		break;
+	case HW_VAR_RF_TYPE:
+		*((u8*)val) = hal_data->rf_type;
+		break;
+	default:
+		if (0)
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" variable(%d) not defined!\n",
+			FUNC_ADPT_ARG(adapter), variable);
+		break;
+	}
+
+_func_exit_;
+}
+
+
+
+
+u8
+SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value)
+{	
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	DM_ODM_T *odm = &(hal_data->odmpriv);
+	u8 bResult = _SUCCESS;
+
+	switch(variable) {
+	case HW_DEF_FA_CNT_DUMP:		
+		//ODM_COMP_COMMON
+		if(*((u8*)value))
+			odm->DebugComponents |= (ODM_COMP_DIG |ODM_COMP_FA_CNT);
+		else
+			odm->DebugComponents &= ~(ODM_COMP_DIG |ODM_COMP_FA_CNT);		
+		break;
+	case HAL_DEF_DBG_RX_INFO_DUMP:
+		{
+			PFALSE_ALARM_STATISTICS FalseAlmCnt = (PFALSE_ALARM_STATISTICS)PhyDM_Get_Structure( odm , PHYDM_FALSEALMCNT);
+			pDIG_T	pDM_DigTable = &odm->DM_DigTable;
+
+			DBG_871X("============ Rx Info dump ===================\n");
+			DBG_871X("bLinked = %d, RSSI_Min = %d(%%), CurrentIGI = 0x%x \n",
+				odm->bLinked, odm->RSSI_Min, pDM_DigTable->CurIGValue);
+			DBG_871X("Cnt_Cck_fail = %d, Cnt_Ofdm_fail = %d, Total False Alarm = %d\n",	
+				FalseAlmCnt->Cnt_Cck_fail, FalseAlmCnt->Cnt_Ofdm_fail, FalseAlmCnt->Cnt_all);
+
+			if(odm->bLinked){
+				DBG_871X("RxRate = %s, RSSI_A = %d(%%), RSSI_B = %d(%%)\n", 
+					HDATA_RATE(odm->RxRate), odm->RSSI_A, odm->RSSI_B);	
+
+				#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA
+				rtw_dump_raw_rssi_info(adapter);
+				#endif
+			}
+		}		
+		break;		
+	case HW_DEF_ODM_DBG_FLAG:
+		ODM_CmnInfoUpdate(odm, ODM_CMNINFO_DBG_COMP, *((u8Byte*)value));
+		break;
+	case HW_DEF_ODM_DBG_LEVEL:
+		ODM_CmnInfoUpdate(odm, ODM_CMNINFO_DBG_LEVEL, *((u4Byte*)value));
+		break;
+	case HAL_DEF_DBG_DM_FUNC:
+	{
+		u8 dm_func = *((u8*)value);
+		struct dm_priv *dm = &hal_data->dmpriv;
+
+		if(dm_func == 0){ //disable all dynamic func
+			pDIG_T	pDM_DigTable = &odm->DM_DigTable;
+			odm->SupportAbility = DYNAMIC_FUNC_DISABLE;
+			pDM_DigTable->bStopDIG = _TRUE;
+			DBG_8192C("==> Disable all dynamic function...\n");
+		}
+		else if(dm_func == 1){//disable DIG
+			pDIG_T	pDM_DigTable = &odm->DM_DigTable;
+			odm->SupportAbility  &= (~DYNAMIC_BB_DIG);
+			pDM_DigTable->bStopDIG = _TRUE;		
+			DBG_8192C("==> Disable DIG...\n");
+		}
+		else if(dm_func == 2){//disable High power
+			odm->SupportAbility  &= (~DYNAMIC_BB_DYNAMIC_TXPWR);
+		}
+		else if(dm_func == 3){//disable tx power tracking
+			odm->SupportAbility  &= (~DYNAMIC_RF_CALIBRATION);
+			DBG_8192C("==> Disable tx power tracking...\n");
+		}
+		else if(dm_func == 4){//disable BT coexistence
+			dm->DMFlag &= (~DYNAMIC_FUNC_BT);
+		}
+		else if(dm_func == 5){//disable antenna diversity
+			odm->SupportAbility  &= (~DYNAMIC_BB_ANT_DIV);
+		}
+		else if(dm_func == 6){//turn on all dynamic func
+			if(!(odm->SupportAbility  & DYNAMIC_BB_DIG)) {
+				DIG_T	*pDigTable = &odm->DM_DigTable;
+				pDigTable->CurIGValue= rtw_read8(adapter, 0xc50);
+				pDigTable->bStopDIG = _FALSE;
+			}
+			dm->DMFlag |= DYNAMIC_FUNC_BT;
+			odm->SupportAbility = DYNAMIC_ALL_FUNC_ENABLE;
+
+			DBG_8192C("==> Turn on all dynamic function...\n");
+		}
+	}
+		break;
+	case HAL_DEF_DBG_DUMP_RXPKT:
+		hal_data->bDumpRxPkt = *((u8*)value);
+		break;
+	case HAL_DEF_DBG_DUMP_TXPKT:
+		hal_data->bDumpTxPkt = *((u8*)value);
+		break;
+	case HAL_DEF_ANT_DETECT:
+		hal_data->AntDetection = *((u8 *)value);
+		break;
+	case HAL_DEF_DBG_DIS_PWT:
+		hal_data->bDisableTXPowerTraining = *((u8*)value);
+		break;	
+	default:
+		DBG_871X_LEVEL(_drv_always_, "%s: [WARNING] HAL_DEF_VARIABLE(%d) not defined!\n", __FUNCTION__, variable);
+		bResult = _FAIL;
+		break;
+	}
+
+	return bResult;
+}
+
+u8
+GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+	DM_ODM_T *odm = &(hal_data->odmpriv);
+	u8 bResult = _SUCCESS;
+
+	switch(variable) {
+		case HAL_DEF_UNDERCORATEDSMOOTHEDPWDB:
+			{
+				struct mlme_priv *pmlmepriv;
+				struct sta_priv *pstapriv;
+				struct sta_info *psta;
+
+				pmlmepriv = &adapter->mlmepriv;
+				pstapriv = &adapter->stapriv;
+				psta = rtw_get_stainfo(pstapriv, pmlmepriv->cur_network.network.MacAddress);
+				if (psta)
+				{
+					*((int*)value) = psta->rssi_stat.UndecoratedSmoothedPWDB;     
+				}
+			}
+			break;
+		case HW_DEF_ODM_DBG_FLAG:
+			*((u8Byte*)value) = odm->DebugComponents;
+			break;
+		case HW_DEF_ODM_DBG_LEVEL:
+			*((u4Byte*)value) = odm->DebugLevel;
+			break;
+		case HAL_DEF_DBG_DM_FUNC:
+			*(( u32*)value) =hal_data->odmpriv.SupportAbility;
+			break;
+		case HAL_DEF_DBG_DUMP_RXPKT:
+			*((u8*)value) = hal_data->bDumpRxPkt;
+			break;
+		case HAL_DEF_DBG_DUMP_TXPKT:
+			*((u8*)value) = hal_data->bDumpTxPkt;
+			break;
+		case HAL_DEF_ANT_DETECT:
+			*((u8 *)value) = hal_data->AntDetection;
+			break;
+		case HAL_DEF_MACID_SLEEP:
+			*(u8*)value = _FALSE;
+			break;
+		case HAL_DEF_TX_PAGE_SIZE:
+			*(( u32*)value) = PAGE_SIZE_128;
+			break;
+		case HAL_DEF_DBG_DIS_PWT:
+			*(u8*)value = hal_data->bDisableTXPowerTraining;
+			break;
+		default:
+			DBG_871X_LEVEL(_drv_always_, "%s: [WARNING] HAL_DEF_VARIABLE(%d) not defined!\n", __FUNCTION__, variable);
+			bResult = _FAIL;
+			break;
+	}
+
+	return bResult;
+}
+
+void GetHalODMVar(	
+	PADAPTER				Adapter,
+	HAL_ODM_VARIABLE		eVariable,
+	PVOID					pValue1,
+	PVOID					pValue2)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T podmpriv = &pHalData->odmpriv;
+	switch(eVariable){
+#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		case HAL_ODM_NOISE_MONITOR:
+			{
+				u8 chan = *(u8*)pValue1;
+				*(s16 *)pValue2 = pHalData->noise[chan];
+				#ifdef DBG_NOISE_MONITOR
+				DBG_8192C("### Noise monitor chan(%d)-noise:%d (dBm) ###\n",
+					chan,pHalData->noise[chan]);
+				#endif			
+						
+			}
+			break;
+#endif//#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+		default:
+			break;
+	}
+}
+
+void SetHalODMVar(
+	PADAPTER				Adapter,
+	HAL_ODM_VARIABLE		eVariable,
+	PVOID					pValue1,
+	BOOLEAN					bSet)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PDM_ODM_T podmpriv = &pHalData->odmpriv;
+	//_irqL irqL;
+	switch(eVariable){
+		case HAL_ODM_STA_INFO:
+			{	
+				struct sta_info *psta = (struct sta_info *)pValue1;				
+				if(bSet){
+					DBG_8192C("### Set STA_(%d) info ###\n",psta->mac_id);
+					ODM_CmnInfoPtrArrayHook(podmpriv, ODM_CMNINFO_STA_STATUS,psta->mac_id,psta);
+				}
+				else{
+					DBG_8192C("### Clean STA_(%d) info ###\n",psta->mac_id);
+					//_enter_critical_bh(&pHalData->odm_stainfo_lock, &irqL);
+					ODM_CmnInfoPtrArrayHook(podmpriv, ODM_CMNINFO_STA_STATUS,psta->mac_id,NULL);
+					
+					//_exit_critical_bh(&pHalData->odm_stainfo_lock, &irqL);
+			            }
+			}
+			break;
+		case HAL_ODM_P2P_STATE:		
+				ODM_CmnInfoUpdate(podmpriv,ODM_CMNINFO_WIFI_DIRECT,bSet);
+			break;
+		case HAL_ODM_WIFI_DISPLAY_STATE:
+				ODM_CmnInfoUpdate(podmpriv,ODM_CMNINFO_WIFI_DISPLAY,bSet);
+			break;
+		case HAL_ODM_REGULATION:
+				ODM_CmnInfoInit(podmpriv, ODM_CMNINFO_DOMAIN_CODE_2G, pHalData->Regulation2_4G);
+				ODM_CmnInfoInit(podmpriv, ODM_CMNINFO_DOMAIN_CODE_5G, pHalData->Regulation5G);
+			break;
+		#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)		
+		case HAL_ODM_NOISE_MONITOR:
+			{
+				struct noise_info *pinfo = (struct noise_info *)pValue1;
+
+				#ifdef DBG_NOISE_MONITOR
+				DBG_8192C("### Noise monitor chan(%d)-bPauseDIG:%d,IGIValue:0x%02x,max_time:%d (ms) ###\n",
+					pinfo->chan,pinfo->bPauseDIG,pinfo->IGIValue,pinfo->max_time);
+				#endif
+				
+				pHalData->noise[pinfo->chan] = ODM_InbandNoise_Monitor(podmpriv,pinfo->bPauseDIG,pinfo->IGIValue,pinfo->max_time);				
+				DBG_871X("chan_%d, noise = %d (dBm)\n",pinfo->chan,pHalData->noise[pinfo->chan]);
+				#ifdef DBG_NOISE_MONITOR
+				DBG_871X("noise_a = %d, noise_b = %d  noise_all:%d \n", 
+					podmpriv->noise_level.noise[ODM_RF_PATH_A], 
+					podmpriv->noise_level.noise[ODM_RF_PATH_B],
+					podmpriv->noise_level.noise_all);						
+				#endif
+			}
+			break;
+		#endif//#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+
+		default:
+			break;
+	}
+}	
+
+
+BOOLEAN 
+eqNByte(
+	u8*	str1,
+	u8*	str2,
+	u32	num
+	)
+{
+	if(num==0)
+		return _FALSE;
+	while(num>0)
+	{
+		num--;
+		if(str1[num]!=str2[num])
+			return _FALSE;
+	}
+	return _TRUE;
+}
+
+//
 //	Description:
 //		Return TRUE if chTmp is represent for hex digit and 
 //		FALSE otherwise.
@@ -1535,18 +5574,17 @@ void rtw_hal_check_rxfifo_full(_adapter *adapter)
 	//switch counter to RX fifo
 	if(IS_81XXC(pHalData->VersionID) || IS_92D(pHalData->VersionID) 
 		|| IS_8188E(pHalData->VersionID) || IS_8723_SERIES(pHalData->VersionID)
-		|| IS_8812_SERIES(pHalData->VersionID) || IS_8821_SERIES(pHalData->VersionID))
+		|| IS_8812_SERIES(pHalData->VersionID) || IS_8821_SERIES(pHalData->VersionID)
+		|| IS_8723B_SERIES(pHalData->VersionID) || IS_8192E(pHalData->VersionID))
 	{
 		rtw_write8(adapter, REG_RXERR_RPT+3, rtw_read8(adapter, REG_RXERR_RPT+3)|0xa0);
 		save_cnt = _TRUE;
 	}
-	else if(IS_8723B_SERIES(pHalData->VersionID) || IS_8192E(pHalData->VersionID))
+	else 
 	{
-		//printk("8723b or 8192e , MAC_667 set 0xf0\n");
-		rtw_write8(adapter, REG_RXERR_RPT+3, rtw_read8(adapter, REG_RXERR_RPT+3)|0xf0);
-		save_cnt = _TRUE;
+		//todo: other chips 
 	}
-	//todo: other chips 
+	
 		
 	if(save_cnt)
 	{
@@ -1583,7 +5621,7 @@ void linked_info_dump(_adapter *padapter,u8 benable)
 		#endif // CONFIG_IPS
 
 		#ifdef CONFIG_LPS	
-		rtw_pm_set_lps(padapter, pwrctrlpriv->ips_org_mode);
+		rtw_pm_set_lps(padapter, pwrctrlpriv->org_power_mgnt );
 		#endif // CONFIG_LPS
 	}
 	padapter->bLinkInfoDump = benable ;	
@@ -1670,30 +5708,290 @@ void rtw_store_phy_info(_adapter *padapter, union recv_frame *prframe)
 }
 #endif
 
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+int check_phy_efuse_tx_power_info_valid(PADAPTER padapter) {
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
+	u8* pContent = pEEPROM->efuse_eeprom_data;
+	int index = 0;
+	u16 tx_index_offset = 0x0000;
+
+	switch(padapter->chip_type) {
+		case RTL8723B:
+			tx_index_offset = EEPROM_TX_PWR_INX_8723B;
+		break;
+		case RTL8188E:
+			tx_index_offset = EEPROM_TX_PWR_INX_88E;
+		break;
+		case RTL8192E:
+			tx_index_offset = EEPROM_TX_PWR_INX_8192E;
+		break;
+		default:
+			tx_index_offset = 0x0010;
+		break;
+	}
+	for (index = 0 ; index < 12 ; index++) {
+		if (pContent[tx_index_offset + index] == 0xFF) {
+			return _FALSE;
+		} else {
+			DBG_871X("0x%02x ,", pContent[EEPROM_TX_PWR_INX_88E+index]);
+		}
+	}
+	DBG_871X("\n");
+	return _TRUE;
+}
+
+int check_phy_efuse_macaddr_info_valid(PADAPTER padapter) {
+
+	u8 val = 0;
+	u16 addr_offset = 0x0000;
+
+	switch(padapter->chip_type) {
+		case RTL8723B:
+			if (padapter->interface_type == RTW_USB) {
+				addr_offset = EEPROM_MAC_ADDR_8723BU;
+				DBG_871X("%s: interface is USB\n", __func__);
+			} else if (padapter->interface_type == RTW_SDIO) {
+				addr_offset = EEPROM_MAC_ADDR_8723BS;
+				DBG_871X("%s: interface is SDIO\n", __func__);
+			} else if (padapter->interface_type == RTW_PCIE) {
+				addr_offset = EEPROM_MAC_ADDR_8723BE;
+				DBG_871X("%s: interface is PCIE\n", __func__);
+			} else if (padapter->interface_type == RTW_GSPI) {
+				//addr_offset = EEPROM_MAC_ADDR_8723BS;
+				DBG_871X("%s: interface is GSPI\n", __func__);
+			}
+		break;
+		case RTL8188E:
+			if (padapter->interface_type == RTW_USB) {
+				addr_offset = EEPROM_MAC_ADDR_88EU;
+				DBG_871X("%s: interface is USB\n", __func__);
+			} else if (padapter->interface_type == RTW_SDIO) {
+				addr_offset = EEPROM_MAC_ADDR_88ES;
+				DBG_871X("%s: interface is SDIO\n", __func__);
+			} else if (padapter->interface_type == RTW_PCIE) {
+				addr_offset = EEPROM_MAC_ADDR_88EE;
+				DBG_871X("%s: interface is PCIE\n", __func__);
+			} else if (padapter->interface_type == RTW_GSPI) {
+				//addr_offset = EEPROM_MAC_ADDR_8723BS;
+				DBG_871X("%s: interface is GSPI\n", __func__);
+			}
+		break;
+	}
+
+	if (addr_offset == 0x0000) {
+		DBG_871X("phy efuse MAC addr offset is 0!!\n");
+		return _FALSE;
+	} else {
+		rtw_efuse_map_read(padapter, addr_offset, 1, &val);
+	}
+
+	if (val == 0xFF) {
+		return _FALSE;
+	} else {
+		DBG_871X("phy efuse with valid MAC addr\n");
+		return _TRUE;
+	}
+}
+
+u32 Hal_readPGDataFromConfigFile(
+	PADAPTER	padapter,
+	struct file *fp)
+{
+	u32 i;
+	mm_segment_t fs;
+	u8 temp[3];
+	loff_t pos = 0;
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
+	u8	*PROMContent = pEEPROM->efuse_eeprom_data;
+
+	temp[2] = 0; // add end of string '\0'
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	for (i = 0 ; i < HWSET_MAX_SIZE ; i++) {
+		vfs_read(fp, temp, 2, &pos);
+		PROMContent[i] = simple_strtoul(temp, NULL, 16);
+		if ((i % EFUSE_FILE_COLUMN_NUM) == (EFUSE_FILE_COLUMN_NUM - 1)) {
+			//Filter the lates space char.
+			vfs_read(fp, temp, 1, &pos);
+			if (strchr(temp, ' ') == NULL) {
+				pos--;
+				vfs_read(fp, temp, 2, &pos);
+			}
+		} else {
+			pos += 1; // Filter the space character
+		}
+	}
+
+	set_fs(fs);
+	pEEPROM->bloadfile_fail_flag = _FALSE;
+
+#ifdef CONFIG_DEBUG
+	DBG_871X("Efuse configure file:\n");
+	for (i=0; i<HWSET_MAX_SIZE; i++)
+	{
+		if (i % 16 == 0)
+			printk("\n");
+
+		printk("%02X ", PROMContent[i]);
+	}
+	printk("\n");
+#endif
+
+	return _SUCCESS;
+}
+
+void Hal_ReadMACAddrFromFile(
+	PADAPTER		padapter,
+	struct file *fp)
+{
+	u32 i;
+	mm_segment_t fs;
+	u8 source_addr[18];
+	loff_t pos = 0;
+	u32	curtime = rtw_get_current_time();
+	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
+	u8 *head, *end;
+
+	_rtw_memset(source_addr, 0, 18);
+	_rtw_memset(pEEPROM->mac_addr, 0, ETH_ALEN);
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	DBG_871X("wifi mac address:\n");
+	vfs_read(fp, source_addr, 18, &pos);
+	source_addr[17] = ':';
+
+	head = end = source_addr;
+	for (i=0; i<ETH_ALEN; i++) {
+		while (end && (*end != ':') )
+			end++;
+
+		if (end && (*end == ':') )
+			*end = '\0';
+
+		pEEPROM->mac_addr[i] = simple_strtoul(head, NULL, 16 );
+
+		if (end) {
+			end++;
+			head = end;
+		}
+	}
+
+	set_fs(fs);
+	pEEPROM->bloadmac_fail_flag = _FALSE;
+
+	if (rtw_check_invalid_mac_address(pEEPROM->mac_addr) == _TRUE) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+		get_random_bytes(pEEPROM->mac_addr, ETH_ALEN);
+		pEEPROM->mac_addr[0] = 0x00;
+		pEEPROM->mac_addr[1] = 0xe0;
+		pEEPROM->mac_addr[2] = 0x4c;
+#else
+		pEEPROM->mac_addr[0] = 0x00;
+		pEEPROM->mac_addr[1] = 0xe0;
+		pEEPROM->mac_addr[2] = 0x4c;
+		pEEPROM->mac_addr[3] = (u8)(curtime & 0xff) ;
+		pEEPROM->mac_addr[4] = (u8)((curtime>>8) & 0xff) ;
+		pEEPROM->mac_addr[5] = (u8)((curtime>>16) & 0xff) ;
+#endif
+                DBG_871X("MAC Address from wifimac error is invalid, assign random MAC !!!\n");
+	}
+
+	DBG_871X("%s: Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
+			__func__, pEEPROM->mac_addr[0], pEEPROM->mac_addr[1],
+			pEEPROM->mac_addr[2], pEEPROM->mac_addr[3],
+			pEEPROM->mac_addr[4], pEEPROM->mac_addr[5]);
+}
+
+void Hal_GetPhyEfuseMACAddr(PADAPTER padapter, u8* mac_addr) {
+	int i = 0;
+	u16 addr_offset = 0x0000;
+
+	switch(padapter->chip_type) {
+		case RTL8723B:
+			if (padapter->interface_type == RTW_USB) {
+				addr_offset = EEPROM_MAC_ADDR_8723BU;
+				DBG_871X("%s: interface is USB\n", __func__);
+			} else if (padapter->interface_type == RTW_SDIO) {
+				addr_offset = EEPROM_MAC_ADDR_8723BS;
+				DBG_871X("%s: interface is SDIO\n", __func__);
+			} else if (padapter->interface_type == RTW_PCIE) {
+				addr_offset = EEPROM_MAC_ADDR_8723BE;
+				DBG_871X("%s: interface is PCIE\n", __func__);
+			} else if (padapter->interface_type == RTW_GSPI){
+				//addr_offset = EEPROM_MAC_ADDR_8723BS;
+				DBG_871X("%s: interface is GSPI\n", __func__);
+			}
+		break;
+		case RTL8188E:
+			if (padapter->interface_type == RTW_USB) {
+				addr_offset = EEPROM_MAC_ADDR_88EU;
+				DBG_871X("%s: interface is USB\n", __func__);
+			} else if (padapter->interface_type == RTW_SDIO) {
+				addr_offset = EEPROM_MAC_ADDR_88ES;
+				DBG_871X("%s: interface is SDIO\n", __func__);
+			} else if (padapter->interface_type == RTW_PCIE) {
+				addr_offset = EEPROM_MAC_ADDR_88EE;
+				DBG_871X("%s: interface is PCIE\n", __func__);
+			} else if (padapter->interface_type == RTW_GSPI){
+				//addr_offset = EEPROM_MAC_ADDR_8723BS;
+				DBG_871X("%s: interface is GSPI\n", __func__);
+			}
+		break;
+	}
+
+	rtw_efuse_map_read(padapter, addr_offset, ETH_ALEN, mac_addr);
+
+	if (rtw_check_invalid_mac_address(mac_addr) == _TRUE) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+		get_random_bytes(mac_addr, ETH_ALEN);
+		mac_addr[0] = 0x00;
+		mac_addr[1] = 0xe0;
+		mac_addr[2] = 0x4c;
+#else
+		mac_addr[0] = 0x00;
+		mac_addr[1] = 0xe0;
+		mac_addr[2] = 0x4c;
+		mac_addr[3] = (u8)(curtime & 0xff) ;
+		mac_addr[4] = (u8)((curtime>>8) & 0xff) ;
+		mac_addr[5] = (u8)((curtime>>16) & 0xff) ;
+#endif
+                DBG_871X("MAC Address from phy efuse error, assign random MAC !!!\n");
+	}
+
+	DBG_871X("%s: Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
+			__func__, mac_addr[0], mac_addr[1], mac_addr[2],
+			mac_addr[3], mac_addr[4], mac_addr[5]);
+}
+#endif //CONFIG_EFUSE_CONFIG_FILE
+
 #ifdef CONFIG_RF_GAIN_OFFSET
 u32 Array_kfreemap[] = { 
-0xf8,0xe,
-0xf6,0xc,
-0xf4,0xa,
-0xf2,0x8,
-0xf0,0x6,
-0xf3,0x4,
-0xf5,0x2,
-0xf7,0x0,
-0xf9,0x0,
-0xfc,0x0,
+0x08,0xe,
+0x06,0xc,
+0x04,0xa,
+0x02,0x8,
+0x00,0x6,
+0x03,0x4,
+0x05,0x2,
+0x07,0x0,
+0x09,0x0,
+0x0c,0x0,
 };
 
 void rtw_bb_rf_gain_offset(_adapter *padapter)
 {
-	u8	value = padapter->eeprompriv.EEPROMRFGainOffset;
-	u8	tmp = 0x3e;
-	u32	res,i=0;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	u8		value = padapter->eeprompriv.EEPROMRFGainOffset;
+	u8		tmp = 0x3e;
+	u32 	res,i=0;
 	u4Byte	   ArrayLen    = sizeof(Array_kfreemap)/sizeof(u32);
 	pu4Byte    Array	   = Array_kfreemap;
-	u4Byte v1=0,v2=0,target=0; 
-	DBG_871X("+%s EEPROMRFGainOffset(0x%02x): 0x%02x+\n",
-			__func__, EEPROM_RF_GAIN_OFFSET, value);
+	u4Byte v1=0,v2=0,GainValue,target=0; 
+	//DBG_871X("+%s value: 0x%02x+\n", __func__, value);
 #if defined(CONFIG_RTL8723A)
 	if (value & BIT0) {
 		DBG_871X("Offset RF Gain.\n");
@@ -1728,32 +6026,39 @@ void rtw_bb_rf_gain_offset(_adapter *padapter)
 	if (value & BIT4) {
 		DBG_871X("Offset RF Gain.\n");
 		DBG_871X("Offset RF Gain.  padapter->eeprompriv.EEPROMRFGainVal=0x%x\n",padapter->eeprompriv.EEPROMRFGainVal);
+		
 		if(padapter->eeprompriv.EEPROMRFGainVal != 0xff){
-			res = rtw_hal_read_rfreg(padapter, RF_PATH_A, 0x7f, 0xffffffff);
-			res &= 0xfff87fff;
-			DBG_871X("Offset RF Gain. before reg 0x7f=0x%08x\n",res);
-			//res &= 0xfff87fff;
+
+			if(pHalData->ant_path == ODM_RF_PATH_A) {
+				GainValue=(padapter->eeprompriv.EEPROMRFGainVal & 0x0f);
+				
+			} else {
+				GainValue=(padapter->eeprompriv.EEPROMRFGainVal & 0xf0)>>4;
+			}
+			DBG_871X("Ant PATH_%d GainValue Offset = 0x%x\n",(pHalData->ant_path == ODM_RF_PATH_A) ? (ODM_RF_PATH_A) : (ODM_RF_PATH_B),GainValue);
+			
 			for (i = 0; i < ArrayLen; i += 2 )
 			{
+				//DBG_871X("ArrayLen in =%d ,Array 1 =0x%x ,Array2 =0x%x \n",i,Array[i],Array[i]+1);
 				v1 = Array[i];
 				v2 = Array[i+1];
-				 if ( v1 == padapter->eeprompriv.EEPROMRFGainVal )
-				 {
+				 if ( v1 == GainValue ) {
 						DBG_871X("Offset RF Gain. got v1 =0x%x ,v2 =0x%x \n",v1,v2);
 						target=v2;
 						break;
 				 }
 			}	 
 			DBG_871X("padapter->eeprompriv.EEPROMRFGainVal=0x%x ,Gain offset Target Value=0x%x\n",padapter->eeprompriv.EEPROMRFGainVal,target);
-			PHY_SetRFReg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, BIT18|BIT17|BIT16|BIT15, target);
 
-			//res |= (padapter->eeprompriv.EEPROMRFGainVal & 0x0f)<< 15;
-			//rtw_hal_write_rfreg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, RF_GAIN_OFFSET_MASK, res);
 			res = rtw_hal_read_rfreg(padapter, RF_PATH_A, 0x7f, 0xffffffff);
+			DBG_871X("Offset RF Gain. before reg 0x7f=0x%08x\n",res);
+			PHY_SetRFReg(padapter, RF_PATH_A, REG_RF_BB_GAIN_OFFSET, BIT18|BIT17|BIT16|BIT15, target);
+			res = rtw_hal_read_rfreg(padapter, RF_PATH_A, 0x7f, 0xffffffff);
+
 			DBG_871X("Offset RF Gain. After reg 0x7f=0x%08x\n",res);
-		}
-		else
-		{
+			
+		}else {
+
 			DBG_871X("Offset RF Gain.  padapter->eeprompriv.EEPROMRFGainVal=0x%x	!= 0xff, didn't run Kfree\n",padapter->eeprompriv.EEPROMRFGainVal);
 		}
 	} else {
@@ -1797,9 +6102,33 @@ void rtw_bb_rf_gain_offset(_adapter *padapter)
 		DBG_871X("Using the default RF gain.\n");
 	}
 #endif
+	
 }
 #endif //CONFIG_RF_GAIN_OFFSET
 
+//To avoid RX affect TX throughput
+void dm_DynamicUsbTxAgg(_adapter *padapter, u8 from_timer)
+{
+	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+#ifdef CONFIG_USB_RX_AGGREGATION	
+	if(IS_HARDWARE_TYPE_8821U(padapter) )//|| IS_HARDWARE_TYPE_8192EU(padapter))
+	{
+		//This AGG_PH_TH only for UsbRxAggMode == USB_RX_AGG_USB
+		if((pHalData->UsbRxAggMode == USB_RX_AGG_USB) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+		{
+			if(pdvobjpriv->traffic_stat.cur_tx_tp > 2 && pdvobjpriv->traffic_stat.cur_rx_tp < 30)
+				rtw_write16(padapter, REG_RXDMA_AGG_PG_TH,0x1003);
+			else
+				rtw_write16(padapter, REG_RXDMA_AGG_PG_TH,0x2005); //dmc agg th 20K
+			
+			//DBG_871X("TX_TP=%u, RX_TP=%u \n", pdvobjpriv->traffic_stat.cur_tx_tp, pdvobjpriv->traffic_stat.cur_rx_tp);
+		}
+	}
+#endif
+}
+
 //bus-agg check for SoftAP mode
 inline u8 rtw_hal_busagg_qsel_check(_adapter *padapter,u8 pre_qsel,u8 next_qsel)
 {
@@ -1819,4 +6148,148 @@ inline u8 rtw_hal_busagg_qsel_check(_adapter *padapter,u8 pre_qsel,u8 next_qsel)
 			chk_rst = _FAIL;
 		}
 	return chk_rst;
-}
\ No newline at end of file
+}
+
+/*
+ * Description:
+ * dump_TX_FIFO: This is only used to dump TX_FIFO for debug WoW mode offload
+ * contant.
+ *
+ * Input:
+ * adapter: adapter pointer.
+ * page_num: The max. page number that user want to dump. 
+ * page_size: page size of each page. eg. 128 bytes, 256 bytes.
+ */
+void dump_TX_FIFO(_adapter* padapter, u8 page_num, u16 page_size){
+
+	int i;
+	u8 val = 0;
+	u8 base = 0;
+	u32 addr = 0;
+	u32 count = (page_size / 8);
+
+	if (page_num <= 0) {
+		DBG_871X("!!%s: incorrect input page_num paramter!\n", __func__);
+		return;
+	}
+
+	if (page_size < 128 || page_size > 256) {
+		DBG_871X("!!%s: incorrect input page_size paramter!\n", __func__);
+		return;
+	}
+
+	DBG_871X("+%s+\n", __func__);
+	val = rtw_read8(padapter, 0x106);
+	rtw_write8(padapter, 0x106, 0x69);
+	DBG_871X("0x106: 0x%02x\n", val);
+	base = rtw_read8(padapter, 0x209);
+	DBG_871X("0x209: 0x%02x\n", base);
+
+	addr = ((base) * page_size)/8;
+	for (i = 0 ; i < page_num * count ; i+=2) {
+		rtw_write32(padapter, 0x140, addr + i);
+		printk(" %08x %08x ", rtw_read32(padapter, 0x144), rtw_read32(padapter, 0x148));
+		rtw_write32(padapter, 0x140, addr + i + 1);
+		printk(" %08x %08x \n", rtw_read32(padapter, 0x144), rtw_read32(padapter, 0x148));
+	}
+}
+
+#ifdef CONFIG_GPIO_API
+u8 rtw_hal_get_gpio(_adapter* adapter, u8 gpio_num)
+{
+	u8 value;
+	u8 direction;	
+	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(adapter);
+
+	rtw_ps_deny(adapter, PS_DENY_IOCTL);
+
+	DBG_871X("rf_pwrstate=0x%02x\n", pwrpriv->rf_pwrstate);
+	LeaveAllPowerSaveModeDirect(adapter);
+
+	/* Read GPIO Direction */
+	direction = (rtw_read8(adapter,REG_GPIO_PIN_CTRL + 2) & BIT(gpio_num)) >> gpio_num;
+
+	/* According the direction to read register value */
+	if( direction )
+		value =  (rtw_read8(adapter, REG_GPIO_PIN_CTRL + 1)& BIT(gpio_num)) >> gpio_num;
+	else
+		value =  (rtw_read8(adapter, REG_GPIO_PIN_CTRL)& BIT(gpio_num)) >> gpio_num;
+
+	rtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);
+	DBG_871X("%s direction=%d value=%d\n",__FUNCTION__,direction,value);
+
+	return value;
+}
+
+int  rtw_hal_set_gpio_output_value(_adapter* adapter, u8 gpio_num, BOOLEAN isHigh)
+{
+	u8 direction = 0;
+	u8 res = -1;
+	if (IS_HARDWARE_TYPE_8188E(adapter)){
+		/* Check GPIO is 4~7 */
+		if( gpio_num > 7 || gpio_num < 4)
+		{
+			DBG_871X("%s The gpio number does not included 4~7.\n",__FUNCTION__);
+			return -1;
+		}
+	}	
+	
+	rtw_ps_deny(adapter, PS_DENY_IOCTL);
+
+	LeaveAllPowerSaveModeDirect(adapter);
+
+	/* Read GPIO direction */
+	direction = (rtw_read8(adapter,REG_GPIO_PIN_CTRL + 2) & BIT(gpio_num)) >> gpio_num;
+
+	/* If GPIO is output direction, setting value. */
+	if( direction )
+	{
+		if(isHigh)
+			rtw_write8(adapter, REG_GPIO_PIN_CTRL + 1, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 1) | BIT(gpio_num));
+		else
+			rtw_write8(adapter, REG_GPIO_PIN_CTRL + 1, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 1) & ~BIT(gpio_num));
+
+		DBG_871X("%s Set gpio %x[%d]=%d\n",__FUNCTION__,REG_GPIO_PIN_CTRL+1,gpio_num,isHigh );
+		res = 0;
+	}
+	else
+	{
+		DBG_871X("%s The gpio is input,not be set!\n",__FUNCTION__);
+		res = -1;
+	}
+
+	rtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);
+	return res;
+}
+
+int rtw_hal_config_gpio(_adapter* adapter, u8 gpio_num, BOOLEAN isOutput)
+{
+	if (IS_HARDWARE_TYPE_8188E(adapter)){
+		if( gpio_num > 7 || gpio_num < 4)
+		{
+			DBG_871X("%s The gpio number does not included 4~7.\n",__FUNCTION__);
+			return -1;
+		}
+	}	
+
+	DBG_871X("%s gpio_num =%d direction=%d\n",__FUNCTION__,gpio_num,isOutput);
+
+	rtw_ps_deny(adapter, PS_DENY_IOCTL);
+
+	LeaveAllPowerSaveModeDirect(adapter);
+
+	if( isOutput )
+	{
+		rtw_write8(adapter, REG_GPIO_PIN_CTRL + 2, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 2) | BIT(gpio_num));
+	}
+	else
+	{
+		rtw_write8(adapter, REG_GPIO_PIN_CTRL + 2, rtw_read8(adapter, REG_GPIO_PIN_CTRL + 2) & ~BIT(gpio_num));
+	}
+
+	rtw_ps_deny_cancel(adapter, PS_DENY_IOCTL);
+
+	return 0;
+}
+
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_com_phycfg.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_com_phycfg.c
index 8bb2747a478c..4866324cc7ec 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_com_phycfg.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_com_phycfg.c
@@ -404,7 +404,7 @@ PHY_GetRateSectionIndexOfTxPowerByRate(
 			case rTxAGC_A_Rate54_24:	 index = 1;		break;
 			case rTxAGC_A_CCK1_Mcs32:	 index = 6;		break;
 			case rTxAGC_B_CCK11_A_CCK2_11:
-				if ( BitMask == 0xffffff00 )
+				if ( BitMask == bMaskH3Bytes )
 					index = 7;
 				else if ( BitMask == 0x000000ff )
 					index = 15;
@@ -2341,7 +2341,7 @@ PHY_GetTxPowerIndex(
 	u8	txPower = 0x3E;
 
 	if (IS_HARDWARE_TYPE_8813A(pAdapter)) {
-//#if (RTL8813A_SUPPORT==1)
+//#if (RTL8814A_SUPPORT==1)
 //		txPower = PHY_GetTxPowerIndex_8813A( pAdapter, PowerIndex, RFPath, Rate );
 //#endif
 	}
@@ -2378,7 +2378,7 @@ PHY_SetTxPowerIndex(
 	)
 {
 	if (IS_HARDWARE_TYPE_8813A(pAdapter)) {
-//#if (RTL8813A_SUPPORT==1)
+//#if (RTL8814A_SUPPORT==1)
 //		PHY_SetTxPowerIndex_8813A( pAdapter, PowerIndex, RFPath, Rate );
 //#endif
 	}
@@ -2410,7 +2410,9 @@ Hal_ChannelPlanToRegulation(
 	IN	u16				ChannelPlan
 	)
 {
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+	DM_ODM_T *odm = &pHalData->odmpriv;
+
 	pHalData->Regulation2_4G = TXPWR_LMT_WW;
 	pHalData->Regulation5G = TXPWR_LMT_WW;
 
@@ -2570,15 +2572,13 @@ Hal_ChannelPlanToRegulation(
 		default:
 			break;
 	}
-}
 
-#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+	DBG_871X("%s ChannelPlan:0x%02x,Regulation(2_4G/5G):0x%02x,0x%02x\n",
+		__FUNCTION__,ChannelPlan,pHalData->Regulation2_4G,pHalData->Regulation5G);
 
-extern char *rtw_phy_file_path;
-char	file_path[PATH_LENGTH_MAX];
-
-#define GetLineFromBuffer(buffer)	 strsep(&buffer, "\n")
+}
 
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
 int
 phy_ConfigMACWithParaFile(
 	IN	PADAPTER	Adapter,
@@ -2605,7 +2605,7 @@ phy_ConfigMACWithParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pHalData->mac_reg = rtw_zmalloc(rlen);
+				pHalData->mac_reg = rtw_zvmalloc(rlen);
 				if(pHalData->mac_reg) {
 					_rtw_memcpy(pHalData->mac_reg, pHalData->para_file_buf, rlen);
 					pHalData->mac_reg_len = rlen;
@@ -2704,7 +2704,7 @@ phy_ConfigBBWithParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pBuf = rtw_zmalloc(rlen);
+				pBuf = rtw_zvmalloc(rlen);
 				if(pBuf) {
 					_rtw_memcpy(pBuf, pHalData->para_file_buf, rlen);
 					*pBufLen = rlen;
@@ -3157,7 +3157,7 @@ phy_ConfigBBWithPgParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pHalData->bb_phy_reg_pg = rtw_zmalloc(rlen);
+				pHalData->bb_phy_reg_pg = rtw_zvmalloc(rlen);
 				if(pHalData->bb_phy_reg_pg) {
 					_rtw_memcpy(pHalData->bb_phy_reg_pg, pHalData->para_file_buf, rlen);
 					pHalData->bb_phy_reg_pg_len = rlen;
@@ -3220,7 +3220,7 @@ phy_ConfigBBWithMpParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pHalData->bb_phy_reg_mp = rtw_zmalloc(rlen);
+				pHalData->bb_phy_reg_mp = rtw_zvmalloc(rlen);
 				if(pHalData->bb_phy_reg_mp) {
 					_rtw_memcpy(pHalData->bb_phy_reg_mp, pHalData->para_file_buf, rlen);
 					pHalData->bb_phy_reg_mp_len = rlen;
@@ -3356,7 +3356,7 @@ PHY_ConfigRFWithParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pBuf = rtw_zmalloc(rlen);
+				pBuf = rtw_zvmalloc(rlen);
 				if(pBuf) {
 					_rtw_memcpy(pBuf, pHalData->para_file_buf, rlen);
 					*pBufLen = rlen;
@@ -3634,7 +3634,7 @@ PHY_ConfigRFWithTxPwrTrackParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pHalData->rf_tx_pwr_track = rtw_zmalloc(rlen);
+				pHalData->rf_tx_pwr_track = rtw_zvmalloc(rlen);
 				if(pHalData->rf_tx_pwr_track) {
 					_rtw_memcpy(pHalData->rf_tx_pwr_track, pHalData->para_file_buf, rlen);
 					pHalData->rf_tx_pwr_track_len = rlen;
@@ -4003,7 +4003,7 @@ PHY_ConfigRFWithPowerLimitTableParaFile(
 			if (rlen > 0)
 			{
 				rtStatus = _SUCCESS;
-				pHalData->rf_tx_pwr_lmt = rtw_zmalloc(rlen);
+				pHalData->rf_tx_pwr_lmt = rtw_zvmalloc(rlen);
 				if(pHalData->rf_tx_pwr_lmt) {
 					_rtw_memcpy(pHalData->rf_tx_pwr_lmt, pHalData->para_file_buf, rlen);
 					pHalData->rf_tx_pwr_lmt_len = rlen;
@@ -4037,6 +4037,30 @@ PHY_ConfigRFWithPowerLimitTableParaFile(
 
 	return rtStatus;
 }
-#endif
 
+void phy_free_filebuf(_adapter *padapter)
+{
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
+	
+	if(pHalData->mac_reg)
+		rtw_vmfree(pHalData->mac_reg, pHalData->mac_reg_len);
+	if(pHalData->bb_phy_reg)
+		rtw_vmfree(pHalData->bb_phy_reg, pHalData->bb_phy_reg_len);
+	if(pHalData->bb_agc_tab)
+		rtw_vmfree(pHalData->bb_agc_tab, pHalData->bb_agc_tab_len);
+	if(pHalData->bb_phy_reg_pg)
+		rtw_vmfree(pHalData->bb_phy_reg_pg, pHalData->bb_phy_reg_pg_len);
+	if(pHalData->bb_phy_reg_mp)
+		rtw_vmfree(pHalData->bb_phy_reg_mp, pHalData->bb_phy_reg_mp_len);
+	if(pHalData->rf_radio_a)
+		rtw_vmfree(pHalData->rf_radio_a, pHalData->rf_radio_a_len);
+	if(pHalData->rf_radio_b)
+		rtw_vmfree(pHalData->rf_radio_b, pHalData->rf_radio_b_len);
+	if(pHalData->rf_tx_pwr_track)
+		rtw_vmfree(pHalData->rf_tx_pwr_track, pHalData->rf_tx_pwr_track_len);
+	if(pHalData->rf_tx_pwr_lmt)
+		rtw_vmfree(pHalData->rf_tx_pwr_lmt, pHalData->rf_tx_pwr_lmt_len);	
+	
+}
 
+#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_dm.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_dm.c
new file mode 100644
index 000000000000..46dab54b0839
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_dm.c
@@ -0,0 +1,196 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2014 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include <drv_types.h>
+#include <hal_data.h>
+
+// A mapping from HalData to ODM.
+ODM_BOARD_TYPE_E boardType(u8 InterfaceSel)
+{
+    ODM_BOARD_TYPE_E        board	= ODM_BOARD_DEFAULT;
+
+#ifdef CONFIG_PCI_HCI
+	INTERFACE_SELECT_PCIE   pcie 	= (INTERFACE_SELECT_PCIE)InterfaceSel;
+	switch (pcie) 
+	{
+        case INTF_SEL0_SOLO_MINICARD:       
+            board |= ODM_BOARD_MINICARD;
+            break;
+        case INTF_SEL1_BT_COMBO_MINICARD:   
+            board |= ODM_BOARD_BT;
+			board |= ODM_BOARD_MINICARD;
+            break;
+        default:
+            board = ODM_BOARD_DEFAULT;
+            break;
+	}                                
+
+#elif defined(CONFIG_USB_HCI)
+	INTERFACE_SELECT_USB    usb 	= (INTERFACE_SELECT_USB)InterfaceSel;
+	switch (usb) 
+	{
+	    case INTF_SEL1_USB_High_Power:      
+	        board |= ODM_BOARD_EXT_LNA;
+	        board |= ODM_BOARD_EXT_PA;			
+	        break;
+	    case INTF_SEL2_MINICARD:            
+	        board |= ODM_BOARD_MINICARD;
+	        break;
+	    case INTF_SEL4_USB_Combo:           
+	        board |= ODM_BOARD_BT;
+	        break;
+	    case INTF_SEL5_USB_Combo_MF:        
+	        board |= ODM_BOARD_BT;
+	        break;
+	    case INTF_SEL0_USB: 			
+	    case INTF_SEL3_USB_Solo:            			
+	    default:
+	        board = ODM_BOARD_DEFAULT;
+	        break;
+	}
+	
+#endif	
+	//DBG_871X("===> boardType(): (pHalData->InterfaceSel, pDM_Odm->BoardType) = (%d, %d)\n", InterfaceSel, board);
+
+	return board;
+}
+
+void Init_ODM_ComInfo(_adapter *adapter)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(adapter);
+	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	PDM_ODM_T		pDM_Odm = &(pHalData->odmpriv);
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(adapter);
+	int i;
+
+	_rtw_memset(pDM_Odm,0,sizeof(*pDM_Odm));
+
+	pDM_Odm->Adapter = adapter;
+
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_PLATFORM, ODM_CE);
+
+	if (adapter->interface_type == RTW_GSPI)
+		ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_INTERFACE, ODM_ITRF_SDIO);
+	else
+		ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_INTERFACE, adapter->interface_type);
+
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_MP_TEST_CHIP, IS_NORMAL_CHIP(pHalData->VersionID));
+
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_PATCH_ID, pEEPROM->CustomerID);
+
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_BWIFI_TEST, adapter->registrypriv.wifi_spec);
+
+	if (pHalData->rf_type == RF_1T1R) {
+		ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_RF_TYPE, ODM_1T1R);
+	}
+	else if (pHalData->rf_type == RF_2T2R){
+		ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_RF_TYPE, ODM_2T2R);
+	}
+	else if (pHalData->rf_type == RF_1T2R){
+		ODM_CmnInfoUpdate(pDM_Odm, ODM_CMNINFO_RF_TYPE, ODM_1T2R);
+	}
+
+{
+	//1 ======= BoardType: ODM_CMNINFO_BOARD_TYPE =======
+	u8 odm_board_type = ODM_BOARD_DEFAULT;
+
+	if (!IS_HARDWARE_TYPE_OLDER_THAN_8723A(adapter))
+	{
+		if (pHalData->ExternalLNA_2G != 0) {
+			odm_board_type |= ODM_BOARD_EXT_LNA;
+			ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_EXT_LNA, 1);
+		}
+		if (pHalData->ExternalLNA_5G != 0) {
+			odm_board_type |= ODM_BOARD_EXT_LNA_5G;
+			ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_5G_EXT_LNA, 1);
+		}
+		if (pHalData->ExternalPA_2G != 0) {
+			odm_board_type |= ODM_BOARD_EXT_PA;
+			ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_EXT_PA, 1);
+		}
+		if (pHalData->ExternalPA_5G != 0) {
+			odm_board_type |= ODM_BOARD_EXT_PA_5G;
+			ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_5G_EXT_PA, 1);
+		}
+		if (pHalData->EEPROMBluetoothCoexist)
+			odm_board_type |= ODM_BOARD_BT;
+
+	} else {
+		#ifdef CONFIG_USB_HCI
+		if (pHalData->InterfaceSel == INTF_SEL1_USB_High_Power
+			|| pHalData->BoardType == BOARD_USB_High_PA	/* This is legacy code for hal_data.BoardType */
+		) {
+			ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_EXT_LNA, 1);
+			ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_EXT_PA, 1);
+		} else
+		#endif
+		{
+			ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_EXT_PA, pHalData->ExternalPA_2G);
+			ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_EXT_LNA, pHalData->ExternalLNA_2G);
+		}
+
+		odm_board_type = boardType(pHalData->InterfaceSel);
+	}
+
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_BOARD_TYPE, odm_board_type);
+	//1 ============== End of BoardType ==============
+}
+
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_DOMAIN_CODE_2G, pHalData->Regulation2_4G);
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_DOMAIN_CODE_5G, pHalData->Regulation5G);
+
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_GPA, pHalData->TypeGPA);
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_APA, pHalData->TypeAPA);
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_GLNA, pHalData->TypeGLNA);
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_ALNA, pHalData->TypeALNA);
+
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_RFE_TYPE, pHalData->RFEType);
+
+	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_EXT_TRSW, 0);
+
+	/* Pointer reference */
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_TX_UNI, &(dvobj->traffic_stat.tx_bytes));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_RX_UNI, &(dvobj->traffic_stat.rx_bytes));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_WM_MODE, &(pmlmeext->cur_wireless_mode));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_BAND, &(pHalData->CurrentBandType));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_FORCED_RATE, &(pHalData->ForcedDataRate));
+
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_SEC_CHNL_OFFSET, &(pHalData->nCur40MhzPrimeSC));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_SEC_MODE, &(adapter->securitypriv.dot11PrivacyAlgrthm));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_BW, &(pHalData->CurrentChannelBW));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_CHNL, &( pHalData->CurrentChannel));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_NET_CLOSED, &(adapter->net_closed));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_FORCED_IGI_LB, &(pHalData->u1ForcedIgiLb));
+
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_SCAN, &(pmlmepriv->bScanInProcess));
+	ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_POWER_SAVING, &(pwrctl->bpower_saving));
+
+	for(i=0; i<ODM_ASSOCIATE_ENTRY_NUM; i++)
+		ODM_CmnInfoPtrArrayHook(pDM_Odm, ODM_CMNINFO_STA_STATUS, i, NULL);
+
+	/* TODO */
+	//ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_BT_OPERATION, _FALSE);
+	//ODM_CmnInfoHook(pDM_Odm, ODM_CMNINFO_BT_DISABLE_EDCA, _FALSE);
+}
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_dm.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_dm.h
new file mode 100644
index 000000000000..2dd95f021600
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_dm.h
@@ -0,0 +1,26 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_DM_H__
+#define __HAL_DM_H__
+
+void Init_ODM_ComInfo(_adapter *adapter);
+
+#endif /* __HAL_DM_H__ */
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_intf.c
index ae83b7ec709d..811cc3dabcb3 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/hal_intf.c
@@ -43,28 +43,53 @@ void rtw_hal_read_chip_version(_adapter *padapter)
 
 void rtw_hal_def_value_init(_adapter *padapter)
 {
-	if (is_primary_adapter(padapter))
+	if (is_primary_adapter(padapter)) {
 		if(padapter->HalFunc.init_default_value)
 			padapter->HalFunc.init_default_value(padapter);
+
+		rtw_init_hal_com_default_value(padapter);
+
+		{
+			struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+			HAL_DATA_TYPE *hal_data = GET_HAL_DATA(padapter);
+
+			/* hal_data..macid_num is ready here */
+			dvobj->macid_ctl.num = rtw_min(hal_data->macid_num, MACID_NUM_SW_LIMIT);
+		}
+	}
 }
 void	rtw_hal_free_data(_adapter *padapter)
 {
+	//free HAL Data 	
+	rtw_hal_data_deinit(padapter);
+	
 	if (is_primary_adapter(padapter))
 		if(padapter->HalFunc.free_hal_data)
 			padapter->HalFunc.free_hal_data(padapter);
 }
-void	rtw_hal_dm_init(_adapter *padapter)
+void rtw_hal_dm_init(_adapter *padapter)
 {
-	if (is_primary_adapter(padapter))
+	if (is_primary_adapter(padapter)) {
+		PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(padapter);
+		struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
 		if(padapter->HalFunc.dm_init)
 			padapter->HalFunc.dm_init(padapter);
+
+		_rtw_spinlock_init(&pdmpriv->IQKSpinLock);
+	}
 }
 void rtw_hal_dm_deinit(_adapter *padapter)
 {
-	// cancel dm  timer
-	if (is_primary_adapter(padapter))
+	if (is_primary_adapter(padapter)) {
+		PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(padapter);
+		struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
 		if(padapter->HalFunc.dm_deinit)
 			padapter->HalFunc.dm_deinit(padapter);
+
+		_rtw_spinlock_free(&pdmpriv->IQKSpinLock);
+	}
 }
 void	rtw_hal_sw_led_init(_adapter *padapter)
 {
@@ -151,11 +176,8 @@ uint	 rtw_hal_init(_adapter *padapter)
 
 	if(status == _SUCCESS){
 
-		rtw_hal_init_opmode(padapter);
-
 		for (i = 0; i<dvobj->iface_nums; i++)
 			dvobj->padapters[i]->hw_init_completed = _TRUE;
-
 			
 		if (padapter->registrypriv.notch_filter == 1)
 			rtw_hal_notch_filter(padapter, 1);
@@ -164,12 +186,12 @@ uint	 rtw_hal_init(_adapter *padapter)
 
 		for (i = 0; i<dvobj->iface_nums; i++)
 			rtw_sec_restore_wep_key(dvobj->padapters[i]);
-		
-		rtw_sec_restore_wep_key(padapter);
 
 		rtw_led_control(padapter, LED_CTL_POWER_ON);
 
 		init_hw_mlme_ext(padapter);
+
+                rtw_hal_init_opmode(padapter);
 		
 #ifdef CONFIG_RF_GAIN_OFFSET
 		rtw_bb_rf_gain_offset(padapter);
@@ -179,7 +201,6 @@ uint	 rtw_hal_init(_adapter *padapter)
 	else{
 		for (i = 0; i<dvobj->iface_nums; i++)
 			dvobj->padapters[i]->hw_init_completed = _FALSE;
-
 		DBG_871X("rtw_hal_init: hal__init fail\n");
 	}
 
@@ -253,10 +274,10 @@ void rtw_hal_set_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID p
 	if(padapter->HalFunc.SetHalODMVarHandler)
 		padapter->HalFunc.SetHalODMVarHandler(padapter,eVariable,pValue1,bSet);
 }
-void	rtw_hal_get_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,BOOLEAN bSet)
+void	rtw_hal_get_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,PVOID pValue2)
 {
 	if(padapter->HalFunc.GetHalODMVarHandler)
-		padapter->HalFunc.GetHalODMVarHandler(padapter,eVariable,pValue1,bSet);
+		padapter->HalFunc.GetHalODMVarHandler(padapter,eVariable,pValue1,pValue2);
 }
 
 void rtw_hal_enable_interrupt(_adapter *padapter)
@@ -487,20 +508,47 @@ s32	rtw_hal_interrupt_handler(_adapter *padapter)
 
 void	rtw_hal_set_bwmode(_adapter *padapter, CHANNEL_WIDTH Bandwidth, u8 Offset)
 {
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(padapter);
+	PDM_ODM_T		pDM_Odm = &(pHalData->odmpriv);
+	
 	if(padapter->HalFunc.set_bwmode_handler)
+	{
+		ODM_AcquireSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
+		if(pDM_Odm->RFCalibrateInfo.bIQKInProgress == _TRUE)
+			DBG_871X_LEVEL(_drv_err_, "%s, %d, IQK may race condition\n", __func__,__LINE__);
+		ODM_ReleaseSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
 		padapter->HalFunc.set_bwmode_handler(padapter, Bandwidth, Offset);
+	}
 }
 
 void	rtw_hal_set_chan(_adapter *padapter, u8 channel)
 {
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(padapter);
+	PDM_ODM_T		pDM_Odm = &(pHalData->odmpriv);
+	
 	if(padapter->HalFunc.set_channel_handler)
+	{
+		ODM_AcquireSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
+		if(pDM_Odm->RFCalibrateInfo.bIQKInProgress == _TRUE)
+			DBG_871X_LEVEL(_drv_err_, "%s, %d, IQK may race condition\n", __func__,__LINE__);
+		ODM_ReleaseSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
 		padapter->HalFunc.set_channel_handler(padapter, channel);
+	}
 }
 
 void	rtw_hal_set_chnl_bw(_adapter *padapter, u8 channel, CHANNEL_WIDTH Bandwidth, u8 Offset40, u8 Offset80)
 {
+	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(padapter);
+	PDM_ODM_T		pDM_Odm = &(pHalData->odmpriv);
+	
 	if(padapter->HalFunc.set_chnl_bw_handler)
+	{
+		ODM_AcquireSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
+		if(pDM_Odm->RFCalibrateInfo.bIQKInProgress == _TRUE)
+			DBG_871X_LEVEL(_drv_err_, "%s, %d, IQK may race condition\n", __func__,__LINE__);
+		ODM_ReleaseSpinLock( pDM_Odm, RT_IQK_SPINLOCK);
 		padapter->HalFunc.set_chnl_bw_handler(padapter, channel, Bandwidth, Offset40, Offset80);
+	}
 }
 
 void	rtw_hal_set_tx_power_level(_adapter *padapter, u8 channel)
@@ -711,37 +759,50 @@ s32 rtw_hal_is_disable_sw_channel_plan(PADAPTER padapter)
 	return GET_HAL_DATA(padapter)->bDisableSWChannelPlan;
 }
 
-s32 rtw_hal_macid_sleep(PADAPTER padapter, u32 macid)
+s32 rtw_hal_macid_sleep(PADAPTER padapter, u8 macid)
 {
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct macid_ctl_t *macid_ctl = dvobj_to_macidctl(dvobj);
 	u8 support;
 
-
 	support = _FALSE;
 	rtw_hal_get_def_var(padapter, HAL_DEF_MACID_SLEEP, &support);
 	if (_FALSE == support)
 		return _FAIL;
 
-	rtw_hal_set_hwreg(padapter, HW_VAR_MACID_SLEEP, (u8*)&macid);
+	if (macid >= macid_ctl->num) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_ADPT_FMT": Invalid macid(%u)\n",
+			FUNC_ADPT_ARG(padapter), macid);
+		return _FAIL;
+	}
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_MACID_SLEEP, &macid);
 
 	return _SUCCESS;
 }
 
-s32 rtw_hal_macid_wakeup(PADAPTER padapter, u32 macid)
+s32 rtw_hal_macid_wakeup(PADAPTER padapter, u8 macid)
 {
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+	struct macid_ctl_t *macid_ctl = dvobj_to_macidctl(dvobj);
 	u8 support;
 
-
 	support = _FALSE;
 	rtw_hal_get_def_var(padapter, HAL_DEF_MACID_SLEEP, &support);
 	if (_FALSE == support)
 		return _FAIL;
 
-	rtw_hal_set_hwreg(padapter, HW_VAR_MACID_WAKEUP, (u8*)&macid);
+	if (macid >= macid_ctl->num) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_ADPT_FMT": Invalid macid(%u)\n",
+			FUNC_ADPT_ARG(padapter), macid);
+		return _FAIL;
+	}
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_MACID_WAKEUP, &macid);
 
 	return _SUCCESS;
 }
 
-#ifdef CONFIG_BT_COEXIST
 s32 rtw_hal_fill_h2c_cmd(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)
 {
 	s32 ret = _FAIL;
@@ -751,10 +812,9 @@ s32 rtw_hal_fill_h2c_cmd(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBu
 	else
 	{
 		DBG_871X("%s:  func[fill_h2c_cmd] not defined!\n", __FUNCTION__);
+		rtw_warn_on(1);
 	}
 
 	return ret;
 }
-#endif // CONFIG_BT_COEXIST
-
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_cmd.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_cmd.c
index bdd5d50bdd81..845f3d79a919 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_cmd.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_cmd.c
@@ -24,7 +24,6 @@
 #include "hal_com_h2c.h"
 
 #define CONFIG_H2C_EF
-//#define WOW_DEBUG
 
 #define RTL88E_MAX_H2C_BOX_NUMS	4
 #define RTL88E_MAX_CMD_LEN	7
@@ -46,7 +45,8 @@ static u8 _is_fw_read_cmd_down(_adapter* padapter, u8 msgbox_num)
 			read_down = _TRUE;
 		}
 #ifdef CONFIG_WOWLAN
-		rtw_msleep_os(2);
+		else
+			rtw_msleep_os(1);
 #endif
 	}while( (!read_down) && (retry_cnts--));
 
@@ -65,13 +65,13 @@ static u8 _is_fw_read_cmd_down(_adapter* padapter, u8 msgbox_num)
 *|31 - 0	  |
 *|ext_msg|
 ******************************************/
-static s32 FillH2CCmd_88E(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)
+s32 FillH2CCmd_88E(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)
 {
 	struct dvobj_priv *dvobj =  adapter_to_dvobj(padapter);
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
 	u8 h2c_box_num;
 	u32	msgbox_addr;
-	u32 msgbox_ex_addr;
+	u32 msgbox_ex_addr = 0;
 	u8 cmd_idx,ext_cmd_len;
 	u32	h2c_cmd = 0;
 	u32	h2c_cmd_ex = 0;
@@ -198,40 +198,79 @@ u8 rtl8188e_set_rssi_cmd(_adapter*padapter, u8 *param)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 _func_enter_;
 
-	if(pHalData->fw_ractrl == _TRUE){
-		#if 0
-	*((u32*) param ) = cpu_to_le32( *((u32*) param ) );
-
-		FillH2CCmd_88E(padapter, RSSI_SETTING_EID, 3, param);
-		#endif
-	}else{
+	if(pHalData->fw_ractrl == _FALSE){		
 		DBG_8192C("==>%s fw dont support RA \n",__FUNCTION__);
-		res=_FAIL;
+		return _FAIL;
 	}
+		
+	*((u32*) param ) = cpu_to_le32( *((u32*) param ) );
+	FillH2CCmd_88E(padapter, H2C_RSSI_REPORT, 3, param);	
 
 _func_exit_;
 
 	return res;
 }
 
-u8 rtl8188e_set_raid_cmd(_adapter*padapter, u32 mask)
-{
-	u8	buf[3];
+u8 rtl8188e_set_raid_cmd(_adapter*padapter, u32 bitmap, u8* arg)
+{	
 	u8	res=_SUCCESS;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-_func_enter_;
-	if(pHalData->fw_ractrl == _TRUE){
-		_rtw_memset(buf, 0, 3);
-		mask = cpu_to_le32( mask );
-		_rtw_memcpy(buf, &mask, 3);		
-
-		FillH2CCmd_88E(padapter, H2C_DM_MACID_CFG, 3, buf);
-	}else{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_info	*psta ;	
+	u8 macid, init_rate, raid, shortGIrate=_FALSE;	
+	u8 H2CCommand[7]={0};
+		
+	if(pHalData->fw_ractrl == _FALSE){		
 		DBG_8192C("==>%s fw dont support RA \n",__FUNCTION__);
-		res=_FAIL;
-	}	
+		return _FAIL;
+	}
 
-_func_exit_;
+	macid = arg[0];
+	raid = arg[1];
+	shortGIrate = arg[2];
+	init_rate = arg[3];	
+	
+	psta = pmlmeinfo->FW_sta_info[macid].psta;
+	if(psta == NULL){
+		DBG_8192C("==>psta==NULL ,%s failed\n",__FUNCTION__);	
+		return _FAIL;
+	}
+		
+	H2CCommand[0] = macid;
+	H2CCommand[1] = raid | (shortGIrate?0x80:0x00) ;	
+	H2CCommand[2] = psta->bw_mode & 0x03; //BW; 
+
+#ifdef CONFIG_INTEL_PROXIM
+	if(padapter->proximity.proxim_on ==_TRUE)
+		pHalData->bDisableTXPowerTraining = _FALSE;
+#endif
+
+	//DisableTXPowerTraining
+	if(pHalData->bDisableTXPowerTraining){
+		H2CCommand[2] |= BIT6;
+		DBG_871X("%s,Disable PWT by driver\n",__FUNCTION__);
+	}
+	else{
+		PDM_ODM_T	pDM_OutSrc = &pHalData->odmpriv;
+
+		if(pDM_OutSrc->bDisablePowerTraining){
+			H2CCommand[2] |= BIT6;
+			DBG_871X("%s,Disable PWT by DM\n",__FUNCTION__);	
+		}
+	}
+	
+	H2CCommand[3] = (u1Byte)(bitmap & 0x000000ff);
+	H2CCommand[4] = (u1Byte)((bitmap & 0x0000ff00) >>8);
+	H2CCommand[5] = (u1Byte)((bitmap & 0x00ff0000) >> 16);
+	H2CCommand[6] = (u1Byte)((bitmap & 0xff000000) >> 24);
+	
+	FillH2CCmd_88E(padapter, H2C_DM_MACID_CFG, 7, H2CCommand);
+
+	//The firmware Rate Adaption function is triggered by TBTT INT, so to
+	// enable the rate adaption, we need to enable the hardware Beacon function Reg 0x550[3]		
+	//SetBcnCtrlReg(padapter, BIT3, 0);		
+	rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT3);
 
 	return res;
 
@@ -266,14 +305,21 @@ void rtl8188e_Add_RateATid(PADAPTER pAdapter, u32 bitmap, u8* arg, u8 rssi_level
 
 
 #if(RATE_ADAPTIVE_SUPPORT == 1)
-	ODM_RA_UpdateRateInfo_8188E(
-			&(pHalData->odmpriv),
-			macid,
-			raid, 
-			bitmap,
-			shortGIrate
-			);
-#endif	
+	if(!pHalData->fw_ractrl ){
+		ODM_RA_UpdateRateInfo_8188E(
+				&(pHalData->odmpriv),
+				macid,
+				raid, 
+				bitmap,
+				shortGIrate
+				);
+	}
+	else
+#endif
+	{
+		 rtl8188e_set_raid_cmd(pAdapter,bitmap,arg);
+	}
+	
 
 }
 
@@ -303,7 +349,7 @@ _func_enter_;
 			break;
 		case PS_MODE_DTIM:
 			RLBM = 2;
-			H2CSetPwrMode.AwakeInterval = 2; //DTIM = 1
+			H2CSetPwrMode.AwakeInterval = 3; //DTIM = 2
 			H2CSetPwrMode.Mode = 1;
 			break;
 		case PS_MODE_UAPSD_WMM:
@@ -827,6 +873,26 @@ CheckFwRsvdPageContent(
  	}
 }
 
+//
+// Description: Get the reserved page number in Tx packet buffer.
+// Retrun value: the page number.
+// 2012.08.09, by tynli.
+//
+u8
+GetTxBufferRsvdPageNum8188E(_adapter *padapter, bool wowlan)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	u8	RsvdPageNum=0;
+	// default reseved 1 page for the IC type which is undefined.
+	u8	TxPageBndy= LAST_ENTRY_OF_TX_PKT_BUFFER_8188E(padapter);
+
+	rtw_hal_get_def_var(padapter, HAL_DEF_TX_PAGE_BOUNDARY, (u8 *)&TxPageBndy);
+
+	RsvdPageNum = LAST_ENTRY_OF_TX_PKT_BUFFER_8188E(padapter) - TxPageBndy + 1;
+
+	return RsvdPageNum;
+}
+
 //
 // Description: Fill the reserved packets that FW will use to RSVD page.
 //			Now we just send 4 types packet to rsvd page.
@@ -845,7 +911,6 @@ static void SetFwRsvdPagePkt(PADAPTER padapter, BOOLEAN bDLFinished)
 	struct xmit_priv	*pxmitpriv;
 	struct mlme_ext_priv	*pmlmeext;
 	struct mlme_ext_info	*pmlmeinfo;
-	struct pwrctrl_priv *pwrctl;
 	u32	BeaconLength, ProbeRspLength, PSPollLength;
 	u32	NullDataLength, QosNullLength, BTQosNullLength;
 	u8	*ReservedPagePacket;
@@ -859,7 +924,7 @@ static void SetFwRsvdPagePkt(PADAPTER padapter, BOOLEAN bDLFinished)
 	struct security_priv *psecuritypriv = &padapter->securitypriv; //added by xx
 	u8 currentip[4];
 	u8 cur_dot11txpn[8];
-
+	struct pwrctrl_priv *pwrctl;
 	pwrctl = adapter_to_pwrctl(padapter);
 #endif
 
@@ -907,8 +972,8 @@ static void SetFwRsvdPagePkt(PADAPTER padapter, BOOLEAN bDLFinished)
 	RsvdPageLoc.LocPsPoll = PageNum;
 	ConstructPSPoll(padapter, &ReservedPagePacket[BufIndex], &PSPollLength);
 	rtl8188e_fill_fake_txdesc(padapter,
-			&ReservedPagePacket[BufIndex-TxDescLen],
-			PSPollLength, _TRUE, _FALSE, _FALSE);
+			&ReservedPagePacket[BufIndex-TxDescLen], PSPollLength,
+			_TRUE, _FALSE, _FALSE);
 
 	PageNeed = (u8)PageNum_128(TxDescLen + PSPollLength);
 	PageNum += PageNeed;
@@ -923,10 +988,9 @@ static void SetFwRsvdPagePkt(PADAPTER padapter, BOOLEAN bDLFinished)
 		&NullDataLength,
 		get_my_bssid(&pmlmeinfo->network),
 		_FALSE, 0, 0, _FALSE);
-
 	rtl8188e_fill_fake_txdesc(padapter,
-			&ReservedPagePacket[BufIndex-TxDescLen],
-			NullDataLength, _FALSE, _FALSE, _FALSE);
+			&ReservedPagePacket[BufIndex-TxDescLen], NullDataLength,
+			_FALSE, _FALSE, _FALSE);
 
 	PageNeed = (u8)PageNum_128(TxDescLen + NullDataLength);
 	PageNum += PageNeed;
@@ -941,49 +1005,34 @@ static void SetFwRsvdPagePkt(PADAPTER padapter, BOOLEAN bDLFinished)
 		&QosNullLength,
 		get_my_bssid(&pmlmeinfo->network),
 		_TRUE, 0, 0, _FALSE);
-
 	rtl8188e_fill_fake_txdesc(padapter,
-			&ReservedPagePacket[BufIndex-TxDescLen],
-			QosNullLength, _FALSE, _FALSE, _FALSE);
+			&ReservedPagePacket[BufIndex-TxDescLen],QosNullLength,
+			_FALSE, _FALSE, _FALSE);
 
 	PageNeed = (u8)PageNum_128(TxDescLen + QosNullLength);
 	PageNum += PageNeed;
 
 	BufIndex += PageNeed * PageSize;
 
-/*
-	//3 (6) BT Qos null data
-	RsvdPageLoc.LocBTQosNull = PageNum;
-	ConstructNullFunctionData(
-		padapter, 
-		&ReservedPagePacket[BufIndex],
-		&BTQosNullLength,
-		get_my_bssid(&pmlmeinfo->network),
-		_TRUE, 0, 0, _FALSE);
-	rtl8188e_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], BTQosNullLength, _FALSE, _TRUE);
-
-	TotalPacketLen = BufIndex + BTQosNullLength;
-*/
-
 #ifdef CONFIG_WOWLAN
 	if (pwrctl->wowlan_mode == _TRUE) {
 		//3(7) ARP
 		rtw_get_current_ip_address(padapter, currentip);
 		RsvdPageLoc.LocArpRsp = PageNum;
-
+	
 		ConstructARPResponse(
-			padapter,
-			&ReservedPagePacket[BufIndex],
-			&ARPLegnth,
-			currentip);
-
+				padapter,
+				&ReservedPagePacket[BufIndex],
+				&ARPLegnth,
+				currentip);
+	
 		rtl8188e_fill_fake_txdesc(padapter,
 				&ReservedPagePacket[BufIndex-TxDescLen],
 				ARPLegnth, _FALSE, _FALSE, _TRUE);
-
+	
 		PageNeed = (u8)PageNum_128(TxDescLen + ARPLegnth);
 	} else {
-		 PageNeed = (u8)PageNum_128(128);
+		PageNeed = (u8)PageNum_128(128);
 	}
 
 	PageNum += PageNeed;
@@ -1000,22 +1049,28 @@ static void SetFwRsvdPagePkt(PADAPTER padapter, BOOLEAN bDLFinished)
 	TotalPacketLen = BufIndex + QosNullLength;
 #endif
 
-	pcmdframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pcmdframe == NULL)
+	pcmdframe = rtw_alloc_cmdxmitframe(pxmitpriv);
+	if (pcmdframe == NULL) {
+		DBG_871X("%s: rtw_alloc_cmdxmitframe fail!\n", __FUNCTION__);
 		goto exit;
+	}
 
 	// update attribute
 	pattrib = &pcmdframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
-	pattrib->qsel = 0x10;
+	pattrib->qsel = QSLT_BEACON;
 	pattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TXDESC_OFFSET;
 
 	if (TotalPacketLen < MaxRsvdPageBufSize)
 		_rtw_memcpy(pcmdframe->buf_addr, ReservedPagePacket, TotalPacketLen);
 	else
 		DBG_871X("%s: memory copy fail at Line:%d\n", __FUNCTION__, __LINE__);
-
-	rtw_hal_mgnt_xmit(padapter, pcmdframe);
+	
+#ifdef CONFIG_PCI_HCI
+	dump_mgntframe(padapter, pcmdframe);
+#else
+	dump_mgntframe_and_wait(padapter, pcmdframe, 100);
+#endif
 
 	DBG_871X("%s: Set RSVD page location to Fw ,TotalPacketLen(%d)\n", __FUNCTION__,TotalPacketLen);
 	rtl8188e_set_FwRsvdPage_cmd(padapter, &RsvdPageLoc);
@@ -1082,7 +1137,8 @@ _func_enter_;
 		do
 		{
 			// download rsvd page.
-			SetFwRsvdPagePkt(padapter, _FALSE);
+			//SetFwRsvdPagePkt(padapter, _FALSE);
+			rtw_hal_set_fw_rsvd_page(padapter, _FALSE);
 			DLBcnCount++;
 			do
 			{
@@ -1183,7 +1239,8 @@ _func_enter_;
 			rtw_write8(padapter,  REG_CR+1, pHalData->RegCR_1);
 		}
 	}
-#ifdef CONFIG_WOWLAN
+#if 0
+//#ifdef CONFIG_WOWLAN
 	if (adapter_to_pwrctl(padapter)->wowlan_mode){
 		JoinBssRptParm.OpMode = mstatus;
 		psta = rtw_get_stainfo(&padapter->stapriv, get_bssid(pmlmepriv));
@@ -1533,7 +1590,7 @@ void rtl8188es_set_wowlan_ctrl_cmd(_adapter* padapter, u8 enable)
 		pwowlan_parm.gpio_index=0x0;
 #endif //CONFIG_USB_HCI
 
-#ifdef CONFIG_SDIO_HCI
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI) 
 		pwowlan_parm.gpio_index = 0x80;
 #endif //CONFIG_SDIO_HCI
 
@@ -1547,12 +1604,6 @@ void rtl8188es_set_wowlan_ctrl_cmd(_adapter* padapter, u8 enable)
 #endif //CONFIG_GPIO_WAKEUP
 	}
 
-	DBG_871X("before H2C 0x%02x, 0x284: 0x%08x\n",
-			H2C_COM_WWLAN, rtw_read32(padapter, 0x284));
-	DBG_871X("before H2C 0x%02x, 0x11c: 0x%08x\n",
-			H2C_COM_WWLAN, rtw_read32(padapter, 0x11c));
-	DBG_871X("before H2C 0x%02x, 0x690: 0x%08x\n",
-			H2C_COM_WWLAN, rtw_read32(padapter, 0x690));
 	FillH2CCmd_88E(padapter, H2C_COM_WWLAN, 2, (u8 *)&pwowlan_parm);
 	rtw_msleep_os(5);
 #ifdef WOW_DEBUG
@@ -1607,127 +1658,13 @@ void rtl8188es_set_remote_wake_ctrl_cmd(_adapter* padapter, u8 enable)
 	DBG_871X("TX_RPT-2:0x%02x\n", rtw_read8(padapter, REG_TX_RPT_CTRL));
 #endif
 }
-
 void rtl8188es_set_wowlan_cmd(_adapter* padapter, u8 enable)
 {
-	u8		res=_SUCCESS;
-	u32		test=0;
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-	SETWOWLAN_PARM		pwowlan_parm;
-	SETAOAC_GLOBAL_INFO     paoac_global_info_parm;
-	struct pwrctrl_priv	*pwrpriv = adapter_to_pwrctl(padapter);
-	struct security_priv *psecpriv = &padapter->securitypriv;
-#ifdef CONFIG_GPIO_WAKEUP
-	u8		gpio_wake_pin = WAKEUP_GPIO_IDX;
-	u8		gpio_high_active = 0;	//default low active
-#endif
-
-_func_enter_;
-		DBG_871X_LEVEL(_drv_always_, "+%s+\n", __func__);
-
-		pwowlan_parm.mode =0;
-		pwowlan_parm.gpio_index=0;
-		pwowlan_parm.gpio_duration=0;
-		pwowlan_parm.second_mode =0;
-		pwowlan_parm.reserve=0;
-
-		if(enable){
-
-			pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
-			pwrpriv->wowlan_magic =_TRUE;
-			if (psecpriv->dot11PrivacyAlgrthm == _WEP40_ || psecpriv->dot11PrivacyAlgrthm == _WEP104_)
-				pwrpriv->wowlan_unicast =_TRUE;
-
-			if(pwrpriv->wowlan_pattern ==_TRUE){
-				pwowlan_parm.mode |= FW_WOWLAN_PATTERN_MATCH;
-				DBG_871X_LEVEL(_drv_info_, "%s 2.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
-			}
-			if(pwrpriv->wowlan_magic ==_TRUE){
-				pwowlan_parm.mode |=FW_WOWLAN_MAGIC_PKT;
-				DBG_871X_LEVEL(_drv_info_, "%s 3.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
-			}
-			if(pwrpriv->wowlan_unicast ==_TRUE){
-				pwowlan_parm.mode |=FW_WOWLAN_UNICAST;
-				DBG_871X_LEVEL(_drv_info_, "%s 4.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
-			}
-
-			pwowlan_parm.mode |=FW_WOWLAN_REKEY_WAKEUP;
-			pwowlan_parm.mode |=FW_WOWLAN_DEAUTH_WAKEUP;
-
-			//DataPinWakeUp
-#ifdef CONFIG_USB_HCI
-			pwowlan_parm.gpio_index=0x0;
-#endif //CONFIG_USB_HCI
-
-#ifdef CONFIG_SDIO_HCI
-			pwowlan_parm.gpio_index = 0x80;
-#endif //CONFIG_SDIO_HCI
-
-#ifdef CONFIG_GPIO_WAKEUP
-			pwowlan_parm.gpio_index = gpio_wake_pin;
-
-			//WOWLAN_GPIO_ACTIVE means GPIO high active
-			//pwowlan_parm.mode |=FW_WOWLAN_GPIO_ACTIVE;
-			if (gpio_high_active)
-				pwowlan_parm.mode |=FW_WOWLAN_GPIO_ACTIVE;
-#endif //CONFIG_GPIO_WAKEUP
-
-			DBG_871X("before H2C 0x80, 0x284: 0x%08x\n", rtw_read32(padapter, 0x284));
-			DBG_871X("before H2C 0x80, 0x11c: 0x%08x\n", rtw_read32(padapter, 0x11c));
-			DBG_871X("before H2C 0x80, 0x690: 0x%08x\n", rtw_read32(padapter, 0x690));
-
-			DBG_871X_LEVEL(_drv_info_, "%s 5.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode);
-			DBG_871X_LEVEL(_drv_info_, "%s 6.pwowlan_parm.index=0x%x \n",__FUNCTION__,pwowlan_parm.gpio_index);
-			res = FillH2CCmd_88E(padapter, H2C_COM_WWLAN, 2, (u8 *)&pwowlan_parm);
-
-			rtw_msleep_os(100);
-			DBG_871X("after H2C 0x80, 0x284: 0x%08x\n", rtw_read32(padapter, 0x284));
-			DBG_871X("after H2C 0x80, 0x11c: 0x%08x\n", rtw_read32(padapter, 0x11c));
-			DBG_871X("after H2C 0x80, 0x690: 0x%08x\n", rtw_read32(padapter, 0x690));
-
-			//disconnect decision
-			pwowlan_parm.mode =1;
-			pwowlan_parm.gpio_index=0;
-			pwowlan_parm.gpio_duration=0;
-			FillH2CCmd_88E(padapter, H2C_COM_DISCNT_DECISION, 3, (u8 *)&pwowlan_parm);
-
-			//keep alive period = 10 * 10 BCN interval
-			pwowlan_parm.mode = FW_WOWLAN_KEEP_ALIVE_EN | FW_ADOPT_USER | FW_WOWLAN_KEEP_ALIVE_PKT_TYPE;
-			pwowlan_parm.gpio_index = 15;
-			res = FillH2CCmd_88E(padapter, H2C_COM_KEEP_ALIVE, 2, (u8 *)&pwowlan_parm);
-
-			rtw_msleep_os(2);
-			//Configure STA security information for GTK rekey wakeup event.
-			paoac_global_info_parm.pairwiseEncAlg =
-					padapter->securitypriv.dot11PrivacyAlgrthm;
-			paoac_global_info_parm.groupEncAlg =
-					padapter->securitypriv.dot118021XGrpPrivacy;
-			FillH2CCmd_88E(padapter, H2C_COM_AOAC_GLOBAL_INFO, 2, (u8 *)&paoac_global_info_parm);
-
-			rtw_msleep_os(2);
-			//enable Remote wake ctrl
-			pwowlan_parm.mode = FW_REMOTE_WAKE_CTRL_EN | FW_WOW_FW_UNICAST_EN | FW_ARP_EN;
-			if (psecpriv->dot11PrivacyAlgrthm == _AES_ || psecpriv->dot11PrivacyAlgrthm == _NO_PRIVACY_)
-			{
-				pwowlan_parm.gpio_duration=0;
-			} else {
-				pwowlan_parm.gpio_duration=1;
-			}
-
-			pwowlan_parm.gpio_index=0;
-
-			res = FillH2CCmd_88E(padapter, H2C_COM_REMOTE_WAKE_CTRL, 3, (u8 *)&pwowlan_parm);
-		} else {
-			pwrpriv->wowlan_magic =_FALSE;
-#ifdef CONFIG_GPIO_WAKEUP
-			rtl8188es_set_output_gpio(padapter, gpio_wake_pin, !gpio_high_active);
-#endif //CONFIG_GPIO_WAKEUP
-			res = FillH2CCmd_88E(padapter, H2C_COM_WWLAN, 2, (u8 *)&pwowlan_parm);
-			rtw_msleep_os(2);
-			res = FillH2CCmd_88E(padapter, H2C_COM_REMOTE_WAKE_CTRL, 3, (u8 *)&pwowlan_parm);
-		}
-_func_exit_;
-		DBG_871X_LEVEL(_drv_always_, "-%s res:%d-\n", __func__, res);
-		return ;
+	DBG_871X("%s, enable: %d\n", __func__, enable);
+	rtl8188es_set_wowlan_ctrl_cmd(padapter, enable);
+	rtl8188es_set_global_info_cmd(padapter, enable);
+	rtl8188es_set_keep_alive_cmd(padapter, enable);
+	rtl8188es_set_disconnect_decision_cmd(padapter, enable);
+	rtl8188es_set_remote_wake_ctrl_cmd(padapter, enable);
 }
 #endif  //CONFIG_WOWLAN
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_dm.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_dm.c
index dc966775a17f..3078cee14f9c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_dm.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_dm.c
@@ -255,63 +255,24 @@ dm_InitGPIOSetting(
 //============================================================
 static void Init_ODM_ComInfo_88E(PADAPTER	Adapter)
 {
-	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
 	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	PDM_ODM_T		pDM_Odm = &(pHalData->odmpriv);
 	u8	cut_ver,fab_ver;
-	
-	//
-	// Init Value
-	//
-	_rtw_memset(pDM_Odm,0,sizeof(*pDM_Odm));
-	
-	pDM_Odm->Adapter = Adapter;	
-	
-	ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_PLATFORM,ODM_CE);
 
-	if (Adapter->interface_type == RTW_GSPI)
-		ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_INTERFACE,ODM_ITRF_SDIO);
-	else
-		ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_INTERFACE,Adapter->interface_type);
-	
+	Init_ODM_ComInfo(Adapter);
+
 	ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_IC_TYPE,ODM_RTL8188E);
 
 	fab_ver = ODM_TSMC;
-	cut_ver = ODM_CUT_A;	
+	cut_ver = ODM_CUT_A;
 
-	if(IS_I_CUT(pHalData->VersionID) || IS_J_CUT(pHalData->VersionID) || IS_K_CUT(pHalData->VersionID))
+	if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
 		cut_ver = ODM_CUT_I;
 
-	ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_FAB_VER,fab_ver);		
+	ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_FAB_VER,fab_ver);
 	ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_CUT_VER,cut_ver);
 
-	ODM_CmnInfoInit(pDM_Odm,	ODM_CMNINFO_MP_TEST_CHIP,IS_NORMAL_CHIP(pHalData->VersionID));
-	
-#if 0	
-//#ifdef CONFIG_USB_HCI	
-	ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_BOARD_TYPE,pHalData->BoardType);
-
-	if(pHalData->BoardType == BOARD_USB_High_PA){
-		ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_EXT_LNA,_TRUE);
-		ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_EXT_PA,_TRUE);
-	}
-#endif	
-	ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_PATCH_ID,pEEPROM->CustomerID);
-	//	ODM_CMNINFO_BINHCT_TEST only for MP Team
-	ODM_CmnInfoInit(pDM_Odm,ODM_CMNINFO_BWIFI_TEST,Adapter->registrypriv.wifi_spec);
-		
-	
-	if(pHalData->rf_type == RF_1T1R){
-		ODM_CmnInfoUpdate(pDM_Odm,ODM_CMNINFO_RF_TYPE,ODM_1T1R);		
-	}
-	else if(pHalData->rf_type == RF_2T2R){
-		ODM_CmnInfoUpdate(pDM_Odm,ODM_CMNINFO_RF_TYPE,ODM_2T2R);		
-	}
-	else if(pHalData->rf_type == RF_1T2R){		
-		ODM_CmnInfoUpdate(pDM_Odm,ODM_CMNINFO_RF_TYPE,ODM_1T2R);		
-	}	
-
  	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_RF_ANTENNA_TYPE, pHalData->TRxAntDivType);
 	
 	#ifdef CONFIG_DISABLE_ODM
@@ -329,9 +290,6 @@ static void Init_ODM_ComInfo_88E(PADAPTER	Adapter)
 }
 static void Update_ODM_ComInfo_88E(PADAPTER	Adapter)
 {
-	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
-	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
-	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(Adapter);
 	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
 	PDM_ODM_T		pDM_Odm = &(pHalData->odmpriv);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;	
@@ -344,14 +302,18 @@ static void Update_ODM_ComInfo_88E(PADAPTER	Adapter)
 		| ODM_BB_FA_CNT
 		| ODM_BB_RSSI_MONITOR
 		| ODM_BB_CCK_PD
-		| ODM_BB_PWR_SAVE		
+		| ODM_BB_PWR_SAVE	
+		| ODM_BB_CFO_TRACKING
 		| ODM_RF_CALIBRATION
 		| ODM_RF_TX_PWR_TRACK
-#ifdef CONFIG_ODM_ADAPTIVITY
-		| ODM_BB_ADAPTIVITY
-#endif
+		| ODM_BB_NHM_CNT
+		| ODM_BB_PRIMARY_CCA
+//		| ODM_BB_PWR_TRAIN
 		;
 
+	if (rtw_odm_adaptivity_needed(Adapter) == _TRUE)
+		pdmpriv->InitODMFlag |= ODM_BB_ADAPTIVITY;
+
 	if (!Adapter->registrypriv.qos_opt_enable) {
 		pdmpriv->InitODMFlag |= ODM_MAC_EDCA_TURBO;
 	}
@@ -373,44 +335,8 @@ static void Update_ODM_ComInfo_88E(PADAPTER	Adapter)
 #endif//CONFIG_DISABLE_ODM
 
 	ODM_CmnInfoUpdate(pDM_Odm,ODM_CMNINFO_ABILITY,pdmpriv->InitODMFlag);
-	
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_TX_UNI,&(Adapter->xmitpriv.tx_bytes));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_RX_UNI,&(Adapter->recvpriv.rx_bytes));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_WM_MODE,&(pmlmeext->cur_wireless_mode));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_SEC_CHNL_OFFSET,&(pHalData->nCur40MhzPrimeSC));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_SEC_MODE,&(Adapter->securitypriv.dot11PrivacyAlgrthm));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_BW,&(pHalData->CurrentChannelBW ));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_CHNL,&( pHalData->CurrentChannel));	
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_NET_CLOSED,&( Adapter->net_closed));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_MP_MODE,&(Adapter->registrypriv.mp_mode));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_FORCED_IGI_LB,&(pHalData->u1ForcedIgiLb));
-	//================= only for 8192D   =================
-	
-	//pHalData->CurrentBandType92D hook fake band_type for power tracking
-	//ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_BAND,&(pDM_Odm->u1Byte_temp));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_BAND,&(pHalData->CurrentBandType));
 
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_FORCED_RATE,&(pHalData->ForcedDataRate));
-	
-	/*
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_DMSP_GET_VALUE,&(pDM_Odm->u1Byte_temp));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_BUDDY_ADAPTOR,&(pDM_Odm->PADAPTER_temp));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_DMSP_IS_MASTER,&(pDM_Odm->u1Byte_temp));
-	//================= only for 8192D   =================
-	// driver havn't those variable now
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_BT_OPERATION,&(pDM_Odm->u1Byte_temp));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_BT_DISABLE_EDCA,&(pDM_Odm->u1Byte_temp));
-	*/
-	
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_SCAN,&(pmlmepriv->bScanInProcess));
-	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_POWER_SAVING,&(pwrctrlpriv->bpower_saving));
 	ODM_CmnInfoInit(pDM_Odm, ODM_CMNINFO_RF_ANTENNA_TYPE, pHalData->TRxAntDivType);
-
-	for(i=0; i< NUM_STA; i++)
-	{
-		//pDM_Odm->pODM_StaInfo[i] = NULL;
-		ODM_CmnInfoPtrArrayHook(pDM_Odm, ODM_CMNINFO_STA_STATUS,i,NULL);
-	}	
 }
 
 void
@@ -543,11 +469,8 @@ void rtl8188e_init_dm_priv(IN PADAPTER Adapter)
 	_rtw_memset(pdmpriv, 0, sizeof(struct dm_priv));
 	//_rtw_spinlock_init(&(pHalData->odm_stainfo_lock));
 	Init_ODM_ComInfo_88E(Adapter);
-#ifdef CONFIG_SW_ANTENNA_DIVERSITY
-	//_init_timer(&(pdmpriv->SwAntennaSwitchTimer),  Adapter->pnetdev , odm_SW_AntennaSwitchCallback, Adapter);	
 	ODM_InitAllTimers(podmpriv );	
-#endif
-	ODM_InitDebugSetting(podmpriv);	
+	PHYDM_InitDebugSetting(podmpriv);	
 }
 
 void rtl8188e_deinit_dm_priv(IN PADAPTER Adapter)
@@ -556,10 +479,7 @@ void rtl8188e_deinit_dm_priv(IN PADAPTER Adapter)
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	PDM_ODM_T 		podmpriv = &pHalData->odmpriv;
 	//_rtw_spinlock_free(&pHalData->odm_stainfo_lock);
-#ifdef CONFIG_SW_ANTENNA_DIVERSITY
-	//_cancel_timer_ex(&pdmpriv->SwAntennaSwitchTimer);	
 	ODM_CancelAllTimers(podmpriv);	
-#endif
 }
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_hal_init.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_hal_init.c
index 45fd34f95448..7f367f07d9b8 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_hal_init.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_hal_init.c
@@ -790,10 +790,14 @@ void _MCUIO_Reset88E(PADAPTER padapter,u8 bReset)
 	u8 u1bTmp;
 
 	if(bReset==_TRUE){
+		u1bTmp = rtw_read8(padapter, REG_RSV_CTRL);
+		rtw_write8(padapter,REG_RSV_CTRL, (u1bTmp&(~BIT1)));
 		// Reset MCU IO Wrapper- sugggest by SD1-Gimmy
 		u1bTmp = rtw_read8(padapter, REG_RSV_CTRL+1);
 		rtw_write8(padapter,REG_RSV_CTRL+1, (u1bTmp&(~BIT3)));
 	}else{
+		u1bTmp = rtw_read8(padapter, REG_RSV_CTRL);
+		rtw_write8(padapter,REG_RSV_CTRL, (u1bTmp&(~BIT1)));
 		// Enable MCU IO Wrapper
 		u1bTmp = rtw_read8(padapter, REG_RSV_CTRL+1);
 		rtw_write8(padapter, REG_RSV_CTRL+1, u1bTmp|BIT3);
@@ -814,7 +818,6 @@ void _8051Reset88E(PADAPTER padapter)
 	DBG_871X("=====> _8051Reset88E(): 8051 reset success .\n");
 }
 
-extern u8 g_fwdl_chksum_fail;
 static s32 polling_fwdl_chksum(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 {
 	s32 ret = _FAIL;
@@ -835,11 +838,8 @@ static s32 polling_fwdl_chksum(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 		goto exit;
 	}
 
-	if (g_fwdl_chksum_fail) {
-		DBG_871X("%s: fwdl test case: fwdl_chksum_fail\n", __FUNCTION__);
-		g_fwdl_chksum_fail--;
+	if (rtw_fwdl_test_trigger_chksum_fail())
 		goto exit;
-	}
 
 	ret = _SUCCESS;
 
@@ -850,7 +850,6 @@ static s32 polling_fwdl_chksum(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 	return ret;
 }
 
-extern u8 g_fwdl_wintint_rdy_fail;
 static s32 _FWFreeToGo(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 {
 	s32 ret = _FAIL;
@@ -878,11 +877,8 @@ static s32 _FWFreeToGo(_adapter *adapter, u32 min_cnt, u32 timeout_ms)
 		goto exit;
 	}
 
-	if (g_fwdl_wintint_rdy_fail) {
-		DBG_871X("%s: fwdl test case: wintint_rdy_fail\n", __FUNCTION__);
-		g_fwdl_wintint_rdy_fail--;
+	if (rtw_fwdl_test_trigger_wintint_rdy_fail())
 		goto exit;
-	}
 
 	ret = _SUCCESS;
 
@@ -922,7 +918,7 @@ s32 rtl8188e_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw)
 	PRT_8188E_FIRMWARE_HDR		pFwHdr = NULL;
 	
 	u8			*pFirmwareBuf;
-	u32			FirmwareLen;
+	u32			FirmwareLen,tmp_fw_len=0;
 #ifdef CONFIG_FILE_FWIMG
 	u8 *fwfilepath;
 #endif // CONFIG_FILE_FWIMG
@@ -975,22 +971,36 @@ s32 rtl8188e_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw)
 		case FW_SOURCE_HEADER_FILE:
 #ifdef CONFIG_WOWLAN
 			if(bUsedWoWLANFw) {
-				ODM_ConfigFWWithHeaderFile(&pHalData->odmpriv, CONFIG_FW_WoWLAN, 
-					(u8 *)&(pFirmware->szFwBuffer), &(pFirmware->ulFwLength));
+				#ifdef CONFIG_SFW_SUPPORTED
+				if(IS_VENDOR_8188E_I_CUT_SERIES(padapter))
+					ODM_ConfigFWWithHeaderFile(&pHalData->odmpriv, CONFIG_FW_WoWLAN_2, 
+						(u8 *)&(pFirmware->szFwBuffer), &(pFirmware->ulFwLength));
+				else	
+				#endif	
+					ODM_ConfigFWWithHeaderFile(&pHalData->odmpriv, CONFIG_FW_WoWLAN, 
+						(u8 *)&(pFirmware->szFwBuffer), &(pFirmware->ulFwLength));
 				DBG_871X("%s fw:%s, size: %d\n",__FUNCTION__, "WoWLAN", pFirmware->ulFwLength);
 			}else
 #endif //CONFIG_WOWLAN
 			{
-				ODM_ConfigFWWithHeaderFile(&pHalData->odmpriv, CONFIG_FW_NIC, 
+				#ifdef CONFIG_SFW_SUPPORTED
+				if(IS_VENDOR_8188E_I_CUT_SERIES(padapter))
+					ODM_ConfigFWWithHeaderFile(&pHalData->odmpriv, CONFIG_FW_NIC_2, 
+					(u8 *)&(pFirmware->szFwBuffer), &(pFirmware->ulFwLength));
+				else				
+				#endif	
+					ODM_ConfigFWWithHeaderFile(&pHalData->odmpriv, CONFIG_FW_NIC, 
 					(u8 *)&(pFirmware->szFwBuffer), &(pFirmware->ulFwLength));
 				DBG_871X("%s fw:%s, size: %d\n", __FUNCTION__, "NIC", pFirmware->ulFwLength);
 			}
 			break;
 	}
 
-	if (pFirmware->ulFwLength > FW_8188E_SIZE) {
+	tmp_fw_len = IS_VENDOR_8188E_I_CUT_SERIES(padapter)?FW_8188E_SIZE_2:FW_8188E_SIZE;
+		
+	if (pFirmware->ulFwLength > tmp_fw_len) {
 		rtStatus = _FAIL;
-		DBG_871X_LEVEL(_drv_emerg_, "Firmware size:%u exceed %u\n", pFirmware->ulFwLength, FW_8188E_SIZE);
+		DBG_871X_LEVEL(_drv_emerg_, "Firmware size:%u exceed %u\n", pFirmware->ulFwLength, tmp_fw_len);
 		goto exit;
 	}
 	
@@ -1116,12 +1126,6 @@ SetFwRelatedForWoWLAN8188ES(
 static void rtl8188e_free_hal_data(PADAPTER padapter)
 {
 _func_enter_;
-
-	if(padapter->HalData)
-	{
-		rtw_vmfree(padapter->HalData, sizeof(HAL_DATA_TYPE));
-		padapter->HalData = NULL;
-	}
 	
 _func_exit_;
 }
@@ -2767,16 +2771,15 @@ static void rtl8188e_read_chip_version(PADAPTER padapter)
 }
 void rtl8188e_GetHalODMVar(	
 	PADAPTER				Adapter,
-	HAL_ODM_VARIABLE		eVariable,
+	HAL_ODM_VARIABLE		eVariable,	
 	PVOID					pValue1,
-	BOOLEAN					bSet)
+	PVOID					pValue2)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	PDM_ODM_T podmpriv = &pHalData->odmpriv;
 	switch(eVariable){
-		case HAL_ODM_STA_INFO:
-			break;
 		default:
+			GetHalODMVar(Adapter,eVariable,pValue1,pValue2);
 			break;
 	}
 }
@@ -2790,39 +2793,15 @@ void rtl8188e_SetHalODMVar(
 	PDM_ODM_T podmpriv = &pHalData->odmpriv;
 	//_irqL irqL;
 	switch(eVariable){
-		case HAL_ODM_STA_INFO:
-			{	
-				struct sta_info *psta = (struct sta_info *)pValue1;				
-				if(bSet){
-					DBG_8192C("### Set STA_(%d) info\n",psta->mac_id);
-					ODM_CmnInfoPtrArrayHook(podmpriv, ODM_CMNINFO_STA_STATUS,psta->mac_id,psta);
-					#if(RATE_ADAPTIVE_SUPPORT==1)
-					ODM_RAInfo_Init(podmpriv,psta->mac_id);
-					#endif
-				}
-				else{
-					DBG_8192C("### Clean STA_(%d) info\n",psta->mac_id);
-					//_enter_critical_bh(&pHalData->odm_stainfo_lock, &irqL);
-					ODM_CmnInfoPtrArrayHook(podmpriv, ODM_CMNINFO_STA_STATUS,psta->mac_id,NULL);
-					
-					//_exit_critical_bh(&pHalData->odm_stainfo_lock, &irqL);
-			            }
-			}
-			break;
-		case HAL_ODM_P2P_STATE:		
-				ODM_CmnInfoUpdate(podmpriv,ODM_CMNINFO_WIFI_DIRECT,bSet);
-			break;
-		case HAL_ODM_WIFI_DISPLAY_STATE:
-				ODM_CmnInfoUpdate(podmpriv,ODM_CMNINFO_WIFI_DISPLAY,bSet);
-			break;
 		default:
+			SetHalODMVar(Adapter,eVariable,pValue1,bSet);
 			break;
 	}
 }	
 
 void rtl8188e_start_thread(_adapter *padapter)
 {
-#ifdef CONFIG_SDIO_HCI
+#if defined(CONFIG_SDIO_HCI) || defined (CONFIG_GSPI_HCI)
 #ifndef CONFIG_SDIO_TX_TASKLET
 	struct xmit_priv *xmitpriv = &padapter->xmitpriv;
 
@@ -2837,10 +2816,9 @@ void rtl8188e_start_thread(_adapter *padapter)
 
 void rtl8188e_stop_thread(_adapter *padapter)
 {
-#ifdef CONFIG_SDIO_HCI
+#if defined(CONFIG_SDIO_HCI) || defined (CONFIG_GSPI_HCI)
 #ifndef CONFIG_SDIO_TX_TASKLET
 	struct xmit_priv *xmitpriv = &padapter->xmitpriv;
-	u8 res = 0;
 
 	// stop xmit_buf_thread
 	if (xmitpriv->SdioXmitThread ) {
@@ -2889,41 +2867,22 @@ void UpdateHalRAMask8188E(PADAPTER padapter, u32 mac_id, u8 rssi_level)
 
 	rate_bitmap = 0xffffffff;					
 	rate_bitmap = ODM_Get_Rate_Bitmap(&pHalData->odmpriv,mac_id,mask,rssi_level);
-	DBG_871X("%s => mac_id:%d, networkType:0x%02x, mask:0x%08x\n\t ==> rssi_level:%d, rate_bitmap:0x%08x\n",
-			__FUNCTION__,mac_id,psta->wireless_mode,mask,rssi_level,rate_bitmap);
+
+	
+	DBG_871X("%s => mac_id:%d, rate_id:%d, networkType:0x%02x, mask:0x%08x\n\t ==> rssi_level:%d, rate_bitmap:0x%08x\n",
+			__FUNCTION__,mac_id,psta->raid,psta->wireless_mode,mask,rssi_level,rate_bitmap);
 
 	mask &= rate_bitmap;
 	
 	if(pHalData->fw_ractrl == _TRUE)
 	{
-		u8 arg = 0;
+		u8 arg[4] ={0};
 
-		//arg = (cam_idx-4)&0x1f;//MACID
-		arg = mac_id&0x1f;//MACID
-		
-		arg |= BIT(7);
-		
-		if (shortGIrate==_TRUE)
-			arg |= BIT(5);
-		mask |= ((psta->raid<<28)&0xf0000000);
-		DBG_871X("update raid entry, mask=0x%x, arg=0x%x\n", mask, arg);
-
-#ifdef CONFIG_INTEL_PROXIM
-		if(padapter->proximity.proxim_on ==_TRUE){
-			arg &= ~BIT(6);
-		}
-		else {
-			arg |= BIT(6);
-		}
-#endif //CONFIG_INTEL_PROXIM
-
-		//to do ,for 8188E-SMIC
-		/*
-		*(pu4Byte)&RateMask=EF4Byte((ratr_bitmap&0x0fffffff) | (ratr_index<<28));
-		RateMask[4] = macId | (bShortGI?0x20:0x00) | 0x80;
-		*/	
-		rtl8188e_set_raid_cmd(padapter, mask);	
-		
+		arg[0] = mac_id;//MACID
+		arg[1] = psta->raid;
+		arg[2] = shortGIrate;
+		arg[3] =  psta->init_rate;
+		rtl8188e_set_raid_cmd(padapter, mask,arg);
 	}
 	else
 	{	
@@ -2942,6 +2901,15 @@ void UpdateHalRAMask8188E(PADAPTER padapter, u32 mac_id, u8 rssi_level)
 	}
 }
 
+void rtl8188e_init_default_value(_adapter *adapter)
+{
+	HAL_DATA_TYPE *hal_data = GET_HAL_DATA(adapter);
+
+	/* hal capability values */
+	hal_data->macid_num = MACID_NUM_88E;
+	hal_data->cam_entry_num = CAM_ENTRY_NUM_88E;
+}
+
 void rtl8188e_set_hal_ops(struct hal_ops *pHalFunc)
 {
 	pHalFunc->free_hal_data = &rtl8188e_free_hal_data;
@@ -3005,7 +2973,12 @@ void rtl8188e_set_hal_ops(struct hal_ops *pHalFunc)
 #endif
 
 	pHalFunc->hal_notch_filter = &hal_notch_filter_8188e;
-
+	pHalFunc->fill_h2c_cmd = &FillH2CCmd_88E;
+	pHalFunc->fill_fake_txdesc = &rtl8188e_fill_fake_txdesc;
+#ifdef CONFIG_WOWLAN
+	pHalFunc->hal_set_wowlan_fw = &SetFwRelatedForWoWLAN8188ES;
+#endif
+	pHalFunc->hal_get_tx_buff_rsvd_page_num = &GetTxBufferRsvdPageNum8188E;
 }
 
 u8 GetEEPROMSize8188E(PADAPTER padapter)
@@ -3022,7 +2995,7 @@ u8 GetEEPROMSize8188E(PADAPTER padapter)
 	return size;
 }
 
-#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_PCI_HCI)
+#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_PCI_HCI) || defined(CONFIG_GSPI_HCI)
 //-------------------------------------------------------------------------
 //
 // LLT R/W/Init function
@@ -3054,7 +3027,7 @@ s32 _LLTWrite(PADAPTER padapter, u32 address, u32 data)
 
 u8 _LLTRead(PADAPTER padapter, u32 address)
 {
-	s32	count = 0;
+	s32	count = POLLING_LLT_THRESHOLD;
 	u32	value = _LLT_INIT_ADDR(address) | _LLT_OP(_LLT_READ_ACCESS);
 	u16	LLTReg = REG_LLT_INIT;
 
@@ -3067,12 +3040,12 @@ u8 _LLTRead(PADAPTER padapter, u32 address)
 		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {
 			return (u8)value;
 		}
-
-		if (count > POLLING_LLT_THRESHOLD) {
-			RT_TRACE(_module_hal_init_c_, _drv_err_, ("Failed to polling read LLT done at address %d!\n", address));
-			break;
-		}
-	} while (count++);
+	} while (--count);
+	
+	if (count <=0 ) {
+		RT_TRACE(_module_hal_init_c_, _drv_err_, ("Failed to polling read LLT done at address %d!\n", address));		
+	}
+	
 
 	return 0xFF;
 }
@@ -3081,7 +3054,7 @@ s32 InitLLTTable(PADAPTER padapter, u8 txpktbuf_bndy)
 {
 	s32	status = _FAIL;
 	u32	i;
-	u32	Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER_8188E;// 176, 22k
+	u32	Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER_8188E(padapter);// 176, 22k
 	HAL_DATA_TYPE *pHalData	= GET_HAL_DATA(padapter);
 
 #if defined(CONFIG_IOL_LLT)
@@ -3140,7 +3113,7 @@ Hal_InitPGData88E(PADAPTER	padapter)
 		if (is_boot_from_eeprom(padapter))
 		{
 			// Read all Content from EEPROM or EFUSE.
-			for(i = 0; i < HWSET_MAX_SIZE_88E; i += 2)
+			for(i = 0; i < HWSET_MAX_SIZE; i += 2)
 			{
 //				value16 = EF2Byte(ReadEEprom(pAdapter, (u2Byte) (i>>1)));
 //				*((u16*)(&PROMContent[i])) = value16;
@@ -3202,22 +3175,15 @@ Hal_ReadPowerValueFromPROM_8188E(
 	_rtw_memset(pwrInfo24G, 0, sizeof(TxPowerInfo24G));
 
 	if(AutoLoadFail)
-	{
+	{	
 		for(rfPath = 0 ; rfPath < pHalData->NumTotalRFPath ; rfPath++)
 		{
-			//2.4G default CCK ITX value 
-			for (group = 0;group < MAX_CHNL_GROUP_24G;group++) {
-				pwrInfo24G->IndexCCK_Base[rfPath][group] =
-					EEPROM_DEFAULT_24G_CCK_TX_INDEX;
-			}
-
-			//2.4G default BW40 ITX value 
-			for (group = 0;group < MAX_CHNL_GROUP_24G-1;group ++) {
-				pwrInfo24G->IndexBW40_Base[rfPath][group] =
-					EEPROM_DEFAULT_24G_BW40_TX_INDEX;
-
+			//2.4G default value
+			for(group = 0 ; group < MAX_CHNL_GROUP_24G; group++)
+			{
+				pwrInfo24G->IndexCCK_Base[rfPath][group] =	EEPROM_DEFAULT_24G_INDEX;
+				pwrInfo24G->IndexBW40_Base[rfPath][group] =	EEPROM_DEFAULT_24G_INDEX;
 			}
-
 			for(TxCount=0;TxCount<MAX_TX_COUNT;TxCount++)
 			{
 				if(TxCount==0)
@@ -3243,7 +3209,7 @@ Hal_ReadPowerValueFromPROM_8188E(
 
 	for(rfPath = 0 ; rfPath < pHalData->NumTotalRFPath ; rfPath++)
 	{
-		//2.4G default CCK ITX value 
+		//2.4G default value
 		for(group = 0 ; group < MAX_CHNL_GROUP_24G; group++)
 		{
 			//printk(" IndexCCK_Base rfPath:%d group:%d,eeAddr:0x%02x ",rfPath,group,eeAddr);
@@ -3251,19 +3217,18 @@ Hal_ReadPowerValueFromPROM_8188E(
 			//printk(" IndexCCK_Base:%02x \n",pwrInfo24G->IndexCCK_Base[rfPath][group] );
 			if(pwrInfo24G->IndexCCK_Base[rfPath][group] == 0xFF)
 			{
-				pwrInfo24G->IndexCCK_Base[rfPath][group] = EEPROM_DEFAULT_24G_CCK_TX_INDEX;
+				pwrInfo24G->IndexCCK_Base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;
 //				pHalData->bNOPG = TRUE; 							
 			}
 		}
-		//2.4G default BW40 ITX value 
 		for(group = 0 ; group < MAX_CHNL_GROUP_24G-1; group++)
 		{
 			//printk(" IndexBW40_Base rfPath:%d group:%d,eeAddr:0x%02x ",rfPath,group,eeAddr);
 			pwrInfo24G->IndexBW40_Base[rfPath][group] =	PROMContent[eeAddr++];
 			//printk(" IndexBW40_Base: %02x \n",pwrInfo24G->IndexBW40_Base[rfPath][group]  );
 			if(pwrInfo24G->IndexBW40_Base[rfPath][group] == 0xFF)
-				pwrInfo24G->IndexBW40_Base[rfPath][group] = EEPROM_DEFAULT_24G_BW40_TX_INDEX;
-		}
+				pwrInfo24G->IndexBW40_Base[rfPath][group] =	EEPROM_DEFAULT_24G_INDEX;
+		}			
 		for(TxCount=0;TxCount<MAX_TX_COUNT_8188E;TxCount++)
 		{
 			if(TxCount==0)
@@ -3616,8 +3581,6 @@ rtl8188e_EfuseParseChnlPlan(
 		, AutoLoadFail
 	);
 
-	Hal_ChannelPlanToRegulation(padapter, padapter->mlmepriv.ChannelPlan);
-
 	DBG_871X("mlmepriv.ChannelPlan = 0x%02x\n", padapter->mlmepriv.ChannelPlan);
 }
 
@@ -3728,14 +3691,23 @@ void Hal_ReadRFGainOffset(
 	IN		u8*		PROMContent,
 	IN		BOOLEAN		AutoloadFail)
 {
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	u8 thermal_offset=0;
 	//
 	// BB_RF Gain Offset from EEPROM
 	//
 
 	if (!AutoloadFail) {
 		Adapter->eeprompriv.EEPROMRFGainOffset =PROMContent[EEPROM_RF_GAIN_OFFSET];
-		DBG_871X("AutoloadFail =%x,\n", AutoloadFail);
-		Adapter->eeprompriv.EEPROMRFGainVal=EFUSE_Read1Byte(Adapter, EEPROM_RF_GAIN_VAL);
+
+		if((Adapter->eeprompriv.EEPROMRFGainOffset  != 0xFF) && 
+			(Adapter->eeprompriv.EEPROMRFGainOffset & BIT4)){
+			Adapter->eeprompriv.EEPROMRFGainVal = EFUSE_Read1Byte(Adapter, EEPROM_RF_GAIN_VAL);
+		}else{
+			Adapter->eeprompriv.EEPROMRFGainOffset = 0;
+			Adapter->eeprompriv.EEPROMRFGainVal = 0;			
+		}
+		
 		DBG_871X("Adapter->eeprompriv.EEPROMRFGainVal=%x\n", Adapter->eeprompriv.EEPROMRFGainVal);
 	} else {
 		Adapter->eeprompriv.EEPROMRFGainVal=EFUSE_Read1Byte(Adapter,EEPROM_RF_GAIN_VAL);
@@ -3743,26 +3715,32 @@ void Hal_ReadRFGainOffset(
 		if(Adapter->eeprompriv.EEPROMRFGainVal != 0xFF)
 			Adapter->eeprompriv.EEPROMRFGainOffset = BIT4;
 		else
-			Adapter->eeprompriv.EEPROMRFGainOffset = 0;		
+			Adapter->eeprompriv.EEPROMRFGainOffset = 0;
 		DBG_871X("else AutoloadFail =%x,\n", AutoloadFail);
 	}
-	
-	if(Adapter->eeprompriv.EEPROMRFGainOffset & BIT4)
-	{
-		HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-		u8 thermal_offset = EFUSE_Read1Byte(Adapter, EEPROM_THERMAL_OFFSET);
+	//
+	// BB_RF Thermal Offset from EEPROM
+	//
+	if(	(Adapter->eeprompriv.EEPROMRFGainOffset!= 0xFF) && 
+		(Adapter->eeprompriv.EEPROMRFGainOffset & BIT4))
+	{	
+		
+		thermal_offset = EFUSE_Read1Byte(Adapter, EEPROM_THERMAL_OFFSET);
 		if( thermal_offset != 0xFF){
 			if(thermal_offset & BIT0)
 				pHalData->EEPROMThermalMeter += ((thermal_offset>>1) & 0x0F);
 			else
 				pHalData->EEPROMThermalMeter -= ((thermal_offset>>1) & 0x0F);
 
-			DBG_871X("pHalData->EEPROMThermalMeter=%x\n", pHalData->EEPROMThermalMeter);
+			DBG_871X("%s =>thermal_offset:0x%02x pHalData->EEPROMThermalMeter=0x%02x\n",__FUNCTION__ ,thermal_offset,pHalData->EEPROMThermalMeter);
 		}		
-	}
+	}	
+
+	DBG_871X("%s => EEPRORFGainOffset = 0x%02x,EEPROMRFGainVal=0x%02x,thermal_offset:0x%02x \n",
+		__FUNCTION__, Adapter->eeprompriv.EEPROMRFGainOffset,Adapter->eeprompriv.EEPROMRFGainVal,thermal_offset);
 	
-	DBG_871X("EEPRORFGainOffset = 0x%02x\n", Adapter->eeprompriv.EEPROMRFGainOffset);
 }
+
 #endif //CONFIG_RF_GAIN_OFFSET
 
 void
@@ -3875,158 +3853,1695 @@ void _InitTransferPageSize(PADAPTER padapter)
 	rtw_write8(padapter, REG_PBP, value8);
 }
 
-void SetHwReg8188E(_adapter *adapter, u8 variable, u8 *val)
+void ResumeTxBeacon(PADAPTER padapter)
 {
-	HAL_DATA_TYPE *HalData = GET_HAL_DATA(adapter);
+	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);
 
-_func_enter_;
+	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
+	// which should be read from register to a global variable.
 
-	switch (variable) {
-		case HW_VAR_BASIC_RATE:
-		{
-			struct mlme_ext_info *mlmext_info = &adapter->mlmeextpriv.mlmext_info;
-			u16 input_b = 0, masked = 0, ioted = 0, BrateCfg = 0, RateIndex = 0;
-			u16 rrsr_2g_force_mask = (RRSR_11M|RRSR_5_5M|RRSR_1M);
-			u16 rrsr_2g_allow_mask = (RRSR_24M|RRSR_12M|
-						RRSR_6M|RRSR_11M|
-						RRSR_5_5M|RRSR_2M|RRSR_1M);
+	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("+ResumeTxBeacon\n"));
 
-			HalSetBrateCfg(adapter, val, &BrateCfg);
-			input_b = BrateCfg;
+	rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
+	pHalData->RegFwHwTxQCtrl |= BIT6;
+	rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0xff);
+	pHalData->RegReg542 |= BIT0;
+	rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
+}
 
-			/* apply force and allow mask */
-			BrateCfg |= rrsr_2g_force_mask;
-			BrateCfg &= rrsr_2g_allow_mask;
-			masked = BrateCfg;
+void StopTxBeacon(PADAPTER padapter)
+{
+	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);
 
-			/* IOT consideration */
-			if (mlmext_info->assoc_AP_vendor == HT_IOT_PEER_CISCO) {
-				/* if peer is cisco and didn't use ofdm rate, we enable 6M ack */
-				if((BrateCfg & (RRSR_24M|RRSR_12M|RRSR_6M)) == 0)
-					BrateCfg |= RRSR_6M;
-			}
+	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
+	// which should be read from register to a global variable.
 
-			ioted = BrateCfg;
+	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("+StopTxBeacon\n"));
 
-			HalData->BasicRateSet = BrateCfg;
+	rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
+	pHalData->RegFwHwTxQCtrl &= (~BIT6);
+	rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0x64);
+	pHalData->RegReg542 &= ~(BIT0);
+	rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
 
-			DBG_8192C("HW_VAR_BASIC_RATE: %#x -> %#x -> %#x\n", input_b, masked, ioted);
+	CheckFwRsvdPageContent(padapter);  // 2010.06.23. Added by tynli.
+}
 
-			// Set RRSR rate table.
-			rtw_write16(adapter, REG_RRSR, BrateCfg);
-			rtw_write8(adapter, REG_RRSR+2, rtw_read8(adapter, REG_RRSR+2)&0xf0);
+static void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
+{
+	u8	val8;
+	u8	mode = *((u8 *)val);	
+
+	DBG_871X( ADPT_FMT "Port-%d  set opmode = %d\n",ADPT_ARG(Adapter),
+		#ifdef CONFIG_CONCURRENT_MODE
+		Adapter->iface_type
+		#else
+		0
+		#endif
+		,mode);
+	
+#ifdef CONFIG_CONCURRENT_MODE
+	if(Adapter->iface_type == IFACE_PORT1)
+	{
+		// disable Port1 TSF update
+		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
+		
+		// set net_type		
+		Set_MSR(Adapter, mode);
 
-			// Set RTS initial rate
-			while(BrateCfg > 0x1)
+		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+		{
+			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))			
 			{
-				BrateCfg = (BrateCfg>> 1);
-				RateIndex++;
+				#ifdef CONFIG_INTERRUPT_BASED_TXBCN
+				#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT	
+				rtw_write8(Adapter, REG_DRVERLYINT, 0x05);//restore early int time to 5ms
+
+				#if defined(CONFIG_USB_HCI)
+				UpdateInterruptMask8188EU(Adapter,_TRUE, 0, IMR_BCNDMAINT0_88E);	
+				#elif defined(CONFIG_SDIO_HCI)
+				UpdateInterruptMask8188ESdio(Adapter, 0, SDIO_HIMR_BCNERLY_INT_MSK);				
+				#endif 
+				
+				#endif // CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+				
+				#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+				#if defined(CONFIG_USB_HCI)
+				UpdateInterruptMask8188EU(Adapter,_TRUE ,0, (IMR_TBDER_88E|IMR_TBDOK_88E));
+				#elif defined(CONFIG_SDIO_HCI)
+				UpdateInterruptMask8188ESdio(Adapter, 0, (SDIO_HIMR_TXBCNOK_MSK|SDIO_HIMR_TXBCNERR_MSK));				
+				#endif
+				
+				#endif// CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+				#endif //CONFIG_INTERRUPT_BASED_TXBCN		
+
+				StopTxBeacon(Adapter);
+				#if defined(CONFIG_PCI_HCI)
+				UpdateInterruptMask8188EE( Adapter, 0, 0, RT_BCN_INT_MASKS, 0);
+				#endif
 			}
-			rtw_write8(adapter, REG_INIRTS_RATE_SEL, RateIndex);
+			
+			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x11);//disable atim wnd and disable beacon function
+			//rtw_write8(Adapter,REG_BCN_CTRL_1, 0x18);
 		}
-		break;
-	case HW_VAR_CHECK_TXBUF:
-	{
-		u8 retry_limit;
-		u16 val16;
-		u32 reg_200 = 0, reg_204 = 0;
-		u32 init_reg_200 = 0, init_reg_204 = 0;
-		u32 start = rtw_get_current_time();
-		u32 pass_ms;
-		int i = 0;
+		else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+		{	
+			//Beacon is polled to TXBUF
+			rtw_write32(Adapter, REG_CR, rtw_read32(Adapter, REG_CR)|BIT(8));
+			
+			ResumeTxBeacon(Adapter);
+			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x1a);
+			//BIT4 - If set 0, hw will clr bcnq when tx becon ok/fail or port 1
+			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
+		}
+		else if(mode == _HW_STATE_AP_)
+		{
+			#ifdef CONFIG_INTERRUPT_BASED_TXBCN			
+			#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+			#if defined(CONFIG_USB_HCI)
+			UpdateInterruptMask8188EU(Adapter,_TRUE ,IMR_BCNDMAINT0_88E, 0);
+			#elif defined(CONFIG_SDIO_HCI)
+			UpdateInterruptMask8188ESdio(Adapter, SDIO_HIMR_BCNERLY_INT_MSK, 0);
+			#endif
+			#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
 
-		retry_limit = 0x01;
+			#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR	
+			#if defined(CONFIG_USB_HCI)
+			UpdateInterruptMask8188EU(Adapter,_TRUE ,(IMR_TBDER_88E|IMR_TBDOK_88E), 0);
+			#elif defined(CONFIG_SDIO_HCI)
+			UpdateInterruptMask8188ESdio(Adapter, (SDIO_HIMR_TXBCNOK_MSK|SDIO_HIMR_TXBCNERR_MSK), 0);
+			#endif
+			#endif//CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+					
+			#endif //CONFIG_INTERRUPT_BASED_TXBCN
 
-		val16 = retry_limit << RETRY_LIMIT_SHORT_SHIFT | retry_limit << RETRY_LIMIT_LONG_SHIFT;
-		rtw_write16(adapter, REG_RL, val16);
+			ResumeTxBeacon(Adapter);
+					
+			rtw_write8(Adapter, REG_BCN_CTRL_1, 0x12);
 
-		while (rtw_get_passing_time_ms(start) < 2000
-			&& !adapter->bDriverStopped && !adapter->bSurpriseRemoved
-		) {
-			reg_200 = rtw_read32(adapter, 0x200);
-			reg_204 = rtw_read32(adapter, 0x204);
+			//Beacon is polled to TXBUF
+			rtw_write32(Adapter, REG_CR, rtw_read32(Adapter, REG_CR)|BIT(8));
 
-			if (i == 0) {
-				init_reg_200 = reg_200;
-				init_reg_204 = reg_204;
-			}
+			//Set RCR
+			//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
+			rtw_write32(Adapter, REG_RCR, 0x7000208e);//CBSSID_DATA must set to 0,Reject ICV_ERROR packets
+			
+			//enable to rx data frame				
+			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
+			//enable to rx ps-poll
+			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
+
+			//Beacon Control related register for first time 
+			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms		
+			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);// 5ms
+			//rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
+			rtw_write8(Adapter, REG_ATIMWND_1, 0x0a); // 10ms for port1
+			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
+			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
+			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
+	
+			//reset TSF2	
+			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
 
-			i++;
-			if ((reg_200 & 0x00ffffff) != (reg_204 & 0x00ffffff)) {
-				//DBG_871X("%s: (HW_VAR_CHECK_TXBUF)TXBUF NOT empty - 0x204=0x%x, 0x200=0x%x (%d)\n", __FUNCTION__, reg_204, reg_200, i);
-				rtw_msleep_os(10);
-			} else {
-				break;
+
+			//BIT4 - If set 0, hw will clr bcnq when tx becon ok/fail or port 1
+			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
+		      	//enable BCN1 Function for if2
+			//don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received)
+			rtw_write8(Adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
+
+#ifdef CONFIG_CONCURRENT_MODE
+			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
+				rtw_write8(Adapter, REG_BCN_CTRL, 
+					rtw_read8(Adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
+#endif
+                    //BCN1 TSF will sync to BCN0 TSF with offset(0x518) if if1_sta linked
+			//rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(5));
+			//rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(3));
+					
+			//dis BCN0 ATIM  WND if if1 is station
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(0));
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+			// Reset TSF for STA+AP concurrent mode
+			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
+				if (reset_tsf(Adapter, IFACE_PORT1) == _FALSE)
+					DBG_871X("ERROR! %s()-%d: Reset port1 TSF fail\n",
+						__FUNCTION__, __LINE__);
+			}
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+#if defined(CONFIG_PCI_HCI) 
+			UpdateInterruptMask8188EE( Adapter, RT_BCN_INT_MASKS, 0, 0, 0);
+#endif	
+		}
+	}
+	else	// (Adapter->iface_type == IFACE_PORT1)
+#endif //CONFIG_CONCURRENT_MODE
+	{
+		// disable Port0 TSF update
+		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+		
+		// set net_type
+		Set_MSR(Adapter, mode);
+		
+		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+		{
+#ifdef CONFIG_CONCURRENT_MODE
+			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))		
+#endif //CONFIG_CONCURRENT_MODE
+			{
+				#ifdef CONFIG_INTERRUPT_BASED_TXBCN	
+				#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+				rtw_write8(Adapter, REG_DRVERLYINT, 0x05);//restore early int time to 5ms	
+				#if defined(CONFIG_USB_HCI)
+				UpdateInterruptMask8188EU(Adapter,_TRUE, 0, IMR_BCNDMAINT0_88E);
+				#elif defined(CONFIG_SDIO_HCI)
+				UpdateInterruptMask8188ESdio(Adapter, 0, SDIO_HIMR_BCNERLY_INT_MSK);	
+				#endif
+				#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+				
+				#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR		
+				#if defined(CONFIG_USB_HCI)
+				UpdateInterruptMask8188EU(Adapter,_TRUE ,0, (IMR_TBDER_88E|IMR_TBDOK_88E));
+				#elif defined(CONFIG_SDIO_HCI)
+				UpdateInterruptMask8188ESdio(Adapter, 0, (SDIO_HIMR_TXBCNOK_MSK|SDIO_HIMR_TXBCNERR_MSK));	
+				#endif
+				#endif //CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+					
+				#endif //CONFIG_INTERRUPT_BASED_TXBCN		
+				StopTxBeacon(Adapter);
+				#if defined(CONFIG_PCI_HCI) 
+				UpdateInterruptMask8188EE(Adapter, 0, 0, RT_BCN_INT_MASKS, 0);
+				#endif
 			}
+			
+			rtw_write8(Adapter,REG_BCN_CTRL, 0x19);//disable atim wnd
+			//rtw_write8(Adapter,REG_BCN_CTRL, 0x18);
+		}
+		else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+		{
+			//Beacon is polled to TXBUF
+			rtw_write16(Adapter, REG_CR, rtw_read16(Adapter, REG_CR)|BIT(8));
+
+			ResumeTxBeacon(Adapter);
+			rtw_write8(Adapter,REG_BCN_CTRL, 0x1a);
+			//BIT3 - If set 0, hw will clr bcnq when tx becon ok/fail or port 0
+			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
 		}
+		else if(mode == _HW_STATE_AP_)
+		{
+			#ifdef CONFIG_INTERRUPT_BASED_TXBCN			
+			#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+			#if defined(CONFIG_USB_HCI)
+			UpdateInterruptMask8188EU(Adapter,_TRUE ,IMR_BCNDMAINT0_88E, 0);
+			#elif defined(CONFIG_SDIO_HCI)
+			UpdateInterruptMask8188ESdio(Adapter, SDIO_HIMR_BCNERLY_INT_MSK, 0);
+			#endif
+			#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+
+			#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR	
+			#if defined(CONFIG_USB_HCI)
+			UpdateInterruptMask8188EU(Adapter,_TRUE ,(IMR_TBDER_88E|IMR_TBDOK_88E), 0);
+			#elif defined(CONFIG_SDIO_HCI)
+			UpdateInterruptMask8188ESdio(Adapter, (SDIO_HIMR_TXBCNOK_MSK|SDIO_HIMR_TXBCNERR_MSK), 0);
+			#endif
+			#endif//CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+					
+			#endif //CONFIG_INTERRUPT_BASED_TXBCN
+
+			ResumeTxBeacon(Adapter);
 
-		pass_ms = rtw_get_passing_time_ms(start);
+			rtw_write8(Adapter, REG_BCN_CTRL, 0x12);		
+			
+			//Beacon is polled to TXBUF
+			rtw_write32(Adapter, REG_CR, rtw_read32(Adapter, REG_CR)|BIT(8));
+			
+			//Set RCR
+			//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
+			rtw_write32(Adapter, REG_RCR, 0x7000208e);//CBSSID_DATA must set to 0,reject ICV_ERR packet
+			//enable to rx data frame
+			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
+			//enable to rx ps-poll
+			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
+
+			//Beacon Control related register for first time
+			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms			
+			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);// 5ms
+			//rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
+			rtw_write8(Adapter, REG_ATIMWND, 0x0a); // 10ms
+			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
+			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
+			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
+
+			//reset TSF
+			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
+
+			//BIT3 - If set 0, hw will clr bcnq when tx becon ok/fail or port 0
+			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
+	
+		        //enable BCN0 Function for if1
+			//don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received)
+			#if defined(CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR)
+			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
+			#else
+			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION |BIT(1)));
+			#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
+				rtw_write8(Adapter, REG_BCN_CTRL_1, 
+					rtw_read8(Adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
+#endif
 
-		if (adapter->bDriverStopped || adapter->bSurpriseRemoved) {
-		} else if (pass_ms >= 2000 || (reg_200 & 0x00ffffff) != (reg_204 & 0x00ffffff)) {
-			DBG_871X_LEVEL(_drv_always_, "%s:(HW_VAR_CHECK_TXBUF)NOT empty(%d) in %d ms\n", __FUNCTION__, i, pass_ms);
-			DBG_871X_LEVEL(_drv_always_, "%s:(HW_VAR_CHECK_TXBUF)0x200=0x%08x, 0x204=0x%08x (0x%08x, 0x%08x)\n",
-				__FUNCTION__, reg_200, reg_204, init_reg_200, init_reg_204);
-			//rtw_warn_on(1);
-		} else {
-			DBG_871X("%s:(HW_VAR_CHECK_TXBUF)TXBUF Empty(%d) in %d ms\n", __FUNCTION__, i, pass_ms);
+			//dis BCN1 ATIM  WND if if2 is station
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(0));	
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+			// Reset TSF for STA+AP concurrent mode
+			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
+				if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
+					DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
+						__FUNCTION__, __LINE__);
+			}
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+#if defined(CONFIG_PCI_HCI) 
+			UpdateInterruptMask8188EE( Adapter, RT_BCN_INT_MASKS, 0, 0, 0);
+#endif
 		}
+	}
+
+}
+static void hw_var_set_macaddr(PADAPTER Adapter, u8 variable, u8* val)
+{
+	u8 idx = 0;
+	u32 reg_macid;
 
-		retry_limit = 0x30;
-		val16 = retry_limit << RETRY_LIMIT_SHORT_SHIFT | retry_limit << RETRY_LIMIT_LONG_SHIFT;
-		rtw_write16(adapter, REG_RL, val16);
+#ifdef CONFIG_CONCURRENT_MODE
+	if(Adapter->iface_type == IFACE_PORT1)
+	{
+		reg_macid = REG_MACID1;
+	}
+	else
+#endif
+	{
+		reg_macid = REG_MACID;
 	}
-		break;
-	case HW_VAR_RESP_SIFS:
+
+	for(idx = 0 ; idx < 6; idx++)
 	{
-		struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+		rtw_write8(GET_PRIMARY_ADAPTER(Adapter), (reg_macid+idx), val[idx]);
+	}
+	
+}
 
-		if((pmlmeext->cur_wireless_mode==WIRELESS_11G) ||
-		(pmlmeext->cur_wireless_mode==WIRELESS_11BG))//WIRELESS_MODE_G){
-		{
-			val[0] = 0x0a;
-			val[1] = 0x0a;
-		} else {
-			val[0] = 0x0e;
-			val[1] = 0x0e;
-		}
+static void hw_var_set_bssid(PADAPTER Adapter, u8 variable, u8* val)
+{
+	u8	idx = 0;
+	u32 reg_bssid;
 
-		// SIFS for OFDM Data ACK
-		rtw_write8(adapter, REG_SIFS_CTX+1, val[0]);
-		// SIFS for OFDM consecutive tx like CTS data!
-		rtw_write8(adapter, REG_SIFS_TRX+1, val[1]);
+#ifdef CONFIG_CONCURRENT_MODE
+	if(Adapter->iface_type == IFACE_PORT1)
+	{
+		reg_bssid = REG_BSSID1;
+	}
+	else
+#endif
+	{
+		reg_bssid = REG_BSSID;
+	}
 
-		rtw_write8(adapter, REG_SPEC_SIFS+1, val[0]);
-		rtw_write8(adapter, REG_MAC_SPEC_SIFS+1, val[0]);
-				
-		//RESP_SIFS for OFDM
-		rtw_write8(adapter, REG_RESP_SIFS_OFDM, val[0]);
-		rtw_write8(adapter, REG_RESP_SIFS_OFDM+1, val[0]);
+	for(idx = 0 ; idx < 6; idx++)
+	{
+		rtw_write8(Adapter, (reg_bssid+idx), val[idx]);
+	}
+
+}
+
+static void hw_var_set_bcn_func(PADAPTER Adapter, u8 variable, u8* val)
+{
+	u32 bcn_ctrl_reg;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if(Adapter->iface_type == IFACE_PORT1)
+	{
+		bcn_ctrl_reg = REG_BCN_CTRL_1;
+	}	
+	else
+#endif		
+	{		
+		bcn_ctrl_reg = REG_BCN_CTRL;
 	}
-		break;
-	default:
-		SetHwReg(adapter, variable, val);
-		break;
+
+	if(*((u8 *)val))
+	{
+		rtw_write8(Adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+	}
+	else
+	{
+		rtw_write8(Adapter, bcn_ctrl_reg, rtw_read8(Adapter, bcn_ctrl_reg)&(~(EN_BCN_FUNCTION | EN_TXBCN_RPT)));
 	}
+	
 
-_func_exit_;
 }
 
-void GetHwReg8188E(_adapter *adapter, u8 variable, u8 *val)
+static void hw_var_set_correct_tsf(PADAPTER Adapter, u8 variable, u8* val)
 {
-	HAL_DATA_TYPE *HalData = GET_HAL_DATA(adapter);
+#ifdef CONFIG_CONCURRENT_MODE
+	u64	tsf;
+	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
 
-_func_enter_;
+	//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
+	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
 
-	switch (variable) {
-	case HW_VAR_SYS_CLKR:
-		*val = rtw_read8(adapter, REG_SYS_CLKR);
-		break;
-	default:
-		GetHwReg(adapter, variable, val);
-		break;
+	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{				
+		//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
+		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
+		StopTxBeacon(Adapter);
 	}
 
-_func_exit_;
+	if(Adapter->iface_type == IFACE_PORT1)
+	{
+		//disable related TSF function
+		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+							
+		rtw_write32(Adapter, REG_TSFTR1, tsf);
+		rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
+
+
+		//enable related TSF function
+		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));	
+
+		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
+		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
+		) { 
+			//disable related TSF function
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
+
+			rtw_write32(Adapter, REG_TSFTR, tsf);
+			rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
+
+			//enable related TSF function
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+		// Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue!
+			if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
+				DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
+					__FUNCTION__, __LINE__);
+
+#endif	// CONFIG_TSF_RESET_OFFLOAD	
+		}		
+		
+	}
+	else
+	{
+		//disable related TSF function
+		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
+							
+		rtw_write32(Adapter, REG_TSFTR, tsf);
+		rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
+
+		//enable related TSF function
+		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
+		
+		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
+		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
+		) { 
+			//disable related TSF function
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+
+			rtw_write32(Adapter, REG_TSFTR1, tsf);
+			rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
+
+			//enable related TSF function
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
+			if (reset_tsf(Adapter, IFACE_PORT1) == _FALSE)
+				DBG_871X("ERROR! %s()-%d: Reset port1 TSF fail\n",
+					__FUNCTION__, __LINE__);
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+		}		
+
+	}
+				
+							
+	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{
+		//pHalData->RegTxPause  &= (~STOP_BCNQ);
+		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
+		ResumeTxBeacon(Adapter);
+	}
+#endif
+}
+
+static void hw_var_set_mlme_disconnect(PADAPTER Adapter, u8 variable, u8* val)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
+			
+				
+	if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))	
+		rtw_write16(Adapter, REG_RXFLTMAP2, 0x00);
+	
+
+	if(Adapter->iface_type == IFACE_PORT1)
+	{
+		//reset TSF1
+		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
+
+		//disable update TSF1
+		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
+
+		// disable Port1's beacon function
+		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+	}
+	else
+	{
+		//reset TSF
+		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
+
+		//disable update TSF
+		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+	}
+#endif
+}
+
+static void hw_var_set_mlme_sitesurvey(PADAPTER Adapter, u8 variable, u8* val)
+{	
+#ifdef CONFIG_CONCURRENT_MODE	
+	struct mlme_priv *pmlmepriv=&(Adapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u32	value_rcr, rcr_clear_bit, value_rxfltmap2;
+
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+
+	rcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);
+
+	// Recieve all data frames
+	 value_rxfltmap2 = 0xFFFF;
+	
+#else /* CONFIG_FIND_BEST_CHANNEL */
+	
+	rcr_clear_bit = RCR_CBSSID_BCN;
+
+	//config RCR to receive different BSSID & not to receive data frame
+	value_rxfltmap2 = 0;
+
+#endif /* CONFIG_FIND_BEST_CHANNEL */
+
+	value_rcr = rtw_read32(Adapter, REG_RCR);
+	if(*((u8 *)val))//under sitesurvey
+	{
+		//config RCR to receive different BSSID & not to receive data frame
+		value_rcr &= ~(rcr_clear_bit);
+		rtw_write32(Adapter, REG_RCR, value_rcr);
+		rtw_write16(Adapter, REG_RXFLTMAP2, value_rxfltmap2);
+
+		//disable update TSF
+		if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+		{
+			if(Adapter->iface_type == IFACE_PORT1)
+			{
+				rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
+			}
+			else
+			{
+				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+			}
+		}
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))		
+		{
+			StopTxBeacon(Adapter);
+		}
+	}
+	else//sitesurvey done
+	{
+		//enable to rx data frame
+		//write32(Adapter, REG_RCR, read32(padapter, REG_RCR)|RCR_ADF);
+		if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE))
+			|| check_buddy_fwstate(Adapter, (_FW_LINKED|WIFI_AP_STATE)))
+			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
+
+		//enable update TSF
+		if(Adapter->iface_type == IFACE_PORT1)
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
+		else
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
+
+		value_rcr |= rcr_clear_bit;
+		rtw_write32(Adapter, REG_RCR, value_rcr);
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))
+		{
+			ResumeTxBeacon(Adapter);
+		}
+	}
+#endif			
+}
+
+static void hw_var_set_mlme_join(PADAPTER Adapter, u8 variable, u8* val)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	u8	RetryLimit = 0x30;
+	u8	type = *((u8 *)val);
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
+	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+
+	if(type == 0) // prepare to join
+	{		
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))		
+		{
+			StopTxBeacon(Adapter);
+		}
+	
+		//enable to rx data frame.Accept all data frame
+		//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+		rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);
+		else
+			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+
+		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+		{
+			RetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;
+		}
+		else // Ad-hoc Mode
+		{
+			RetryLimit = 0x7;
+		}
+	}
+	else if(type == 1) //joinbss_event call back when join res < 0
+	{		
+		if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))		
+			rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))
+		{
+			ResumeTxBeacon(Adapter);			
+			
+			//reset TSF 1/2 after ResumeTxBeacon
+			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));	
+			
+		}
+	}
+	else if(type == 2) //sta add event call back
+	{
+	 
+		//enable update TSF
+		if(Adapter->iface_type == IFACE_PORT1)
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
+		else
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
+		 
+	
+		if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
+		{
+			//fixed beacon issue for 8191su...........
+			rtw_write8(Adapter,0x542 ,0x02);
+			RetryLimit = 0x7;
+		}
+
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))
+		{
+			ResumeTxBeacon(Adapter);			
+			
+			//reset TSF 1/2 after ResumeTxBeacon
+			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));
+		}
+		
+	}
+
+	rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+	
+#endif
+}
+
+
+
+void SetHwReg8188E(_adapter *adapter, u8 variable, u8 *val)
+{
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
+	DM_ODM_T 		*podmpriv = &pHalData->odmpriv;
+_func_enter_;
+
+	switch (variable) {
+		case HW_VAR_MEDIA_STATUS:
+			{
+				u8 val8;
+
+				val8 = rtw_read8(adapter, MSR)&0x0c;
+				val8 |= *((u8 *)val);
+				rtw_write8(adapter, MSR, val8);
+			}
+			break;
+		case HW_VAR_MEDIA_STATUS1:
+			{
+				u8 val8;
+				
+				val8 = rtw_read8(adapter, MSR)&0x03;
+				val8 |= *((u8 *)val) <<2;
+				rtw_write8(adapter, MSR, val8);
+			}
+			break;
+		case HW_VAR_SET_OPMODE:
+			hw_var_set_opmode(adapter, variable, val);
+			break;
+		case HW_VAR_MAC_ADDR:
+			hw_var_set_macaddr(adapter, variable, val);			
+			break;
+		case HW_VAR_BSSID:
+			hw_var_set_bssid(adapter, variable, val);
+			break;
+		case HW_VAR_BASIC_RATE:
+		{
+			struct mlme_ext_info *mlmext_info = &adapter->mlmeextpriv.mlmext_info;
+			u16 input_b = 0, masked = 0, ioted = 0, BrateCfg = 0;
+			u16 rrsr_2g_force_mask = (RRSR_11M|RRSR_5_5M|RRSR_1M);
+			u16 rrsr_2g_allow_mask = (RRSR_24M|RRSR_12M|RRSR_6M|RRSR_CCK_RATES);
+
+			HalSetBrateCfg(adapter, val, &BrateCfg);
+			input_b = BrateCfg;
+
+			/* apply force and allow mask */
+			BrateCfg |= rrsr_2g_force_mask;
+			BrateCfg &= rrsr_2g_allow_mask;
+			masked = BrateCfg;
+
+			/* IOT consideration */
+			if (mlmext_info->assoc_AP_vendor == HT_IOT_PEER_CISCO) {
+				/* if peer is cisco and didn't use ofdm rate, we enable 6M ack */
+				if((BrateCfg & (RRSR_24M|RRSR_12M|RRSR_6M)) == 0)
+					BrateCfg |= RRSR_6M;
+			}
+			ioted = BrateCfg;
+
+			pHalData->BasicRateSet = BrateCfg;
+
+			DBG_8192C("HW_VAR_BASIC_RATE: %#x -> %#x -> %#x\n", input_b, masked, ioted);
+
+			// Set RRSR rate table.
+			rtw_write16(adapter, REG_RRSR, BrateCfg);
+			rtw_write8(adapter, REG_RRSR+2, rtw_read8(adapter, REG_RRSR+2)&0xf0);
+
+			rtw_hal_set_hwreg(adapter, HW_VAR_INIT_RTS_RATE, (u8*)&BrateCfg);
+		}
+			break;
+		case HW_VAR_TXPAUSE:
+			rtw_write8(adapter, REG_TXPAUSE, *((u8 *)val));	
+			break;
+		case HW_VAR_BCN_FUNC:
+			hw_var_set_bcn_func(adapter, variable, val);
+			break;
+			
+		case HW_VAR_CORRECT_TSF:
+#ifdef CONFIG_CONCURRENT_MODE
+			hw_var_set_correct_tsf(adapter, variable, val);
+#else
+			{
+				u64	tsf;
+				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+				//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
+				tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
+
+				if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+				{				
+					//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
+					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
+					StopTxBeacon(adapter);
+				}
+
+				//disable related TSF function
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(3)));
+							
+				rtw_write32(adapter, REG_TSFTR, tsf);
+				rtw_write32(adapter, REG_TSFTR+4, tsf>>32);
+
+				//enable related TSF function
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(3));
+				
+							
+				if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+				{
+					//pHalData->RegTxPause  &= (~STOP_BCNQ);
+					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
+					ResumeTxBeacon(adapter);
+				}
+			}
+#endif
+			break;
+
+		case HW_VAR_CHECK_BSSID:
+			if(*((u8 *)val))
+			{
+				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+			}
+			else
+			{
+				u32	val32;
+
+				val32 = rtw_read32(adapter, REG_RCR);
+
+				val32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);
+
+				rtw_write32(adapter, REG_RCR, val32);
+			}
+			break;
+
+		case HW_VAR_MLME_DISCONNECT:
+#ifdef CONFIG_CONCURRENT_MODE
+			hw_var_set_mlme_disconnect(adapter, variable, val);
+#else
+			{
+				//Set RCR to not to receive data frame when NO LINK state
+				//rtw_write32(Adapter, REG_RCR, rtw_read32(padapter, REG_RCR) & ~RCR_ADF);
+				//reject all data frames
+				rtw_write16(adapter, REG_RXFLTMAP2,0x00);
+
+				//reset TSF
+				rtw_write8(adapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
+
+				//disable update TSF
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));	
+			}
+#endif
+			break;
+
+		case HW_VAR_MLME_SITESURVEY:
+#ifdef CONFIG_CONCURRENT_MODE
+			hw_var_set_mlme_sitesurvey(adapter, variable,  val);
+#else
+			{
+				u32	value_rcr, rcr_clear_bit, value_rxfltmap2;
+	#ifdef CONFIG_FIND_BEST_CHANNEL
+
+				rcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);
+
+				// Recieve all data frames
+				value_rxfltmap2 = 0xFFFF;
+		
+	#else /* CONFIG_FIND_BEST_CHANNEL */
+		
+				rcr_clear_bit = RCR_CBSSID_BCN;
+
+				//config RCR to receive different BSSID & not to receive data frame
+				value_rxfltmap2 = 0;
+
+	#endif /* CONFIG_FIND_BEST_CHANNEL */
+			
+				value_rcr = rtw_read32(adapter, REG_RCR);
+				if(*((u8 *)val))//under sitesurvey
+				{
+					//config RCR to receive different BSSID & not to receive data frame
+					value_rcr &= ~(rcr_clear_bit);
+					rtw_write32(adapter, REG_RCR, value_rcr);
+					rtw_write16(adapter, REG_RXFLTMAP2, value_rxfltmap2);
+
+					//disable update TSF
+					rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
+				}
+				else//sitesurvey done
+				{
+					struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+					struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+					if ((is_client_associated_to_ap(adapter) == _TRUE) ||
+						((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) )
+					{
+						//enable to rx data frame
+						//rtw_write32(Adapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+						rtw_write16(adapter, REG_RXFLTMAP2,0xFFFF);
+
+						//enable update TSF
+						rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
+					}
+					else if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+					{
+						//rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_ADF);
+						rtw_write16(adapter, REG_RXFLTMAP2,0xFFFF);
+
+						//enable update TSF
+						rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
+					}
+
+					value_rcr |= rcr_clear_bit;
+					if(((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE) && (adapter->in_cta_test)) {
+						u32 v = rtw_read32(adapter, REG_RCR);
+						v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
+						rtw_write32(adapter, REG_RCR, v);
+					} else {
+						rtw_write32(adapter, REG_RCR, value_rcr);	
+					}
+				}
+			}
+#endif			
+			break;
+
+		case HW_VAR_MLME_JOIN:
+#ifdef CONFIG_CONCURRENT_MODE
+			hw_var_set_mlme_join(adapter, variable,  val);
+#else
+			{
+				u8	RetryLimit = 0x30;
+				u8	type = *((u8 *)val);
+				struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+				EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+				
+				if(type == 0) // prepare to join
+				{
+					//enable to rx data frame.Accept all data frame
+					//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+					rtw_write16(adapter, REG_RXFLTMAP2,0xFFFF);
+
+					if(adapter->in_cta_test)
+					{
+						u32 v = rtw_read32(adapter, REG_RCR);
+						v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
+						rtw_write32(adapter, REG_RCR, v);
+					}
+					else
+					{
+						rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+					}
+
+					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+					{
+						RetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;
+					}
+					else // Ad-hoc Mode
+					{
+						RetryLimit = 0x7;
+					}
+				}
+				else if(type == 1) //joinbss_event call back when join res < 0
+				{
+					rtw_write16(adapter, REG_RXFLTMAP2,0x00);
+				}
+				else if(type == 2) //sta add event call back
+				{
+					//enable update TSF
+					rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
+
+					if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
+					{
+						RetryLimit = 0x7;
+					}
+				}
+
+				rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+			}
+#endif
+			break;
+
+		case HW_VAR_ON_RCR_AM:
+                        rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_AM);
+                        DBG_871X("%s, %d, RCR= %x \n", __FUNCTION__,__LINE__, rtw_read32(adapter, REG_RCR));
+                        break;
+              case HW_VAR_OFF_RCR_AM:
+                        rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)& (~RCR_AM));
+                        DBG_871X("%s, %d, RCR= %x \n", __FUNCTION__,__LINE__, rtw_read32(adapter, REG_RCR));
+                        break;
+		case HW_VAR_BEACON_INTERVAL:
+			rtw_write16(adapter, REG_BCN_INTERVAL, *((u16 *)val));
+#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+			{
+				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+				u16 bcn_interval = 	*((u16 *)val);
+				if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE){
+					DBG_8192C("%s==> bcn_interval:%d, eraly_int:%d \n",__FUNCTION__,bcn_interval,bcn_interval>>1);
+					rtw_write8(adapter, REG_DRVERLYINT, bcn_interval>>1);// 50ms for sdio 
+				}			
+			}
+#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+
+			break;
+		case HW_VAR_SLOT_TIME:
+			{
+				rtw_write8(adapter, REG_SLOT, val[0]);
+			}
+			break;
+		case HW_VAR_ACK_PREAMBLE:
+			{
+				u8	regTmp;
+				u8	bShortPreamble = *( (PBOOLEAN)val );
+				// Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily)
+				regTmp = (pHalData->nCur40MhzPrimeSC)<<5;
+				rtw_write8(adapter, REG_RRSR+2, regTmp);
+
+				regTmp = rtw_read8(adapter,REG_WMAC_TRXPTCL_CTL+2);
+				if(bShortPreamble)		
+					regTmp |= BIT1;
+				else
+					regTmp &= (~BIT1);
+				rtw_write8(adapter,REG_WMAC_TRXPTCL_CTL+2,regTmp);				
+			}
+			break;
+		case HW_VAR_CAM_EMPTY_ENTRY:
+			{
+				u8	ucIndex = *((u8 *)val);
+				u8	i;
+				u32	ulCommand=0;
+				u32	ulContent=0;
+				u32	ulEncAlgo=CAM_AES;
+
+				for(i=0;i<CAM_CONTENT_COUNT;i++)
+				{
+					// filled id in CAM config 2 byte
+					if( i == 0)
+					{
+						ulContent |=(ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);
+						//ulContent |= CAM_VALID;
+					}
+					else
+					{
+						ulContent = 0;
+					}
+					// polling bit, and No Write enable, and address
+					ulCommand= CAM_CONTENT_COUNT*ucIndex+i;
+					ulCommand= ulCommand | CAM_POLLINIG|CAM_WRITE;
+					// write content 0 is equall to mark invalid
+					rtw_write32(adapter, WCAMI, ulContent);  //delay_ms(40);
+					//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_empty_entry(): WRITE A4: %lx \n",ulContent));
+					rtw_write32(adapter, RWCAM, ulCommand);  //delay_ms(40);
+					//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_empty_entry(): WRITE A0: %lx \n",ulCommand));
+				}
+			}
+			break;
+		case HW_VAR_CAM_INVALID_ALL:
+			rtw_write32(adapter, RWCAM, BIT(31)|BIT(30));
+			break;
+		case HW_VAR_CAM_WRITE:
+			{
+				u32	cmd;
+				u32	*cam_val = (u32 *)val;
+				rtw_write32(adapter, WCAMI, cam_val[0]);
+				
+				cmd = CAM_POLLINIG | CAM_WRITE | cam_val[1];
+				rtw_write32(adapter, RWCAM, cmd);
+			}
+			break;
+		case HW_VAR_AC_PARAM_VO:
+			rtw_write32(adapter, REG_EDCA_VO_PARAM, ((u32 *)(val))[0]);
+			break;
+		case HW_VAR_AC_PARAM_VI:
+			rtw_write32(adapter, REG_EDCA_VI_PARAM, ((u32 *)(val))[0]);
+			break;
+		case HW_VAR_AC_PARAM_BE:
+			pHalData->AcParam_BE = ((u32 *)(val))[0];
+			rtw_write32(adapter, REG_EDCA_BE_PARAM, ((u32 *)(val))[0]);
+			break;
+		case HW_VAR_AC_PARAM_BK:
+			rtw_write32(adapter, REG_EDCA_BK_PARAM, ((u32 *)(val))[0]);
+			break;
+		case HW_VAR_ACM_CTRL:
+			{
+				u8	acm_ctrl = *((u8 *)val);
+				u8	AcmCtrl = rtw_read8( adapter, REG_ACMHWCTRL);
+
+				if(acm_ctrl > 1)
+					AcmCtrl = AcmCtrl | 0x1;
+
+				if(acm_ctrl & BIT(3))
+					AcmCtrl |= AcmHw_VoqEn;
+				else
+					AcmCtrl &= (~AcmHw_VoqEn);
+
+				if(acm_ctrl & BIT(2))
+					AcmCtrl |= AcmHw_ViqEn;
+				else
+					AcmCtrl &= (~AcmHw_ViqEn);
+
+				if(acm_ctrl & BIT(1))
+					AcmCtrl |= AcmHw_BeqEn;
+				else
+					AcmCtrl &= (~AcmHw_BeqEn);
+
+				DBG_871X("[HW_VAR_ACM_CTRL] Write 0x%X\n", AcmCtrl );
+				rtw_write8(adapter, REG_ACMHWCTRL, AcmCtrl );
+			}
+			break;
+		case HW_VAR_AMPDU_FACTOR:
+			{
+				u8	RegToSet_Normal[4]={0x41,0xa8,0x72, 0xb9};
+				u8	RegToSet_BT[4]={0x31,0x74,0x42, 0x97};
+				u8	FactorToSet;
+				u8	*pRegToSet;
+				u8	index = 0;
+
+#ifdef CONFIG_BT_COEXIST
+				if(	(pHalData->bt_coexist.BT_Coexist) &&
+					(pHalData->bt_coexist.BT_CoexistType == BT_CSR_BC4) )
+					pRegToSet = RegToSet_BT; // 0x97427431;
+				else
+#endif
+					pRegToSet = RegToSet_Normal; // 0xb972a841;
+
+				FactorToSet = *((u8 *)val);
+				if(FactorToSet <= 3)
+				{
+					FactorToSet = (1<<(FactorToSet + 2));
+					if(FactorToSet>0xf)
+						FactorToSet = 0xf;
+
+					for(index=0; index<4; index++)
+					{
+						if((pRegToSet[index] & 0xf0) > (FactorToSet<<4))
+							pRegToSet[index] = (pRegToSet[index] & 0x0f) | (FactorToSet<<4);
+					
+						if((pRegToSet[index] & 0x0f) > FactorToSet)
+							pRegToSet[index] = (pRegToSet[index] & 0xf0) | (FactorToSet);
+						
+						rtw_write8(adapter, (REG_AGGLEN_LMT+index), pRegToSet[index]);
+					}
+
+					//RT_TRACE(COMP_MLME, DBG_LOUD, ("Set HW_VAR_AMPDU_FACTOR: %#x\n", FactorToSet));
+				}
+			}
+			break;		
+                case HW_VAR_H2C_FW_PWRMODE:
+			{
+				u8	psmode = (*(u8 *)val);
+			
+				// Forece leave RF low power mode for 1T1R to prevent conficting setting in Fw power
+				// saving sequence. 2010.06.07. Added by tynli. Suggested by SD3 yschang.
+				if( (psmode != PS_MODE_ACTIVE) && (!IS_92C_SERIAL(pHalData->VersionID)))
+				{
+					ODM_RF_Saving(podmpriv, _TRUE);
+				}
+				rtl8188e_set_FwPwrMode_cmd(adapter, psmode);
+			}
+			break;
+		case HW_VAR_H2C_FW_JOINBSSRPT:
+		    {
+				u8	mstatus = (*(u8 *)val);
+				rtl8188e_set_FwJoinBssReport_cmd(adapter, mstatus);
+			}
+			break;
+#ifdef CONFIG_P2P_PS
+		case HW_VAR_H2C_FW_P2P_PS_OFFLOAD:
+			{
+				u8	p2p_ps_state = (*(u8 *)val);
+				rtl8188e_set_p2p_ps_offload_cmd(adapter, p2p_ps_state);
+			}
+			break;
+#endif //CONFIG_P2P_PS
+#ifdef CONFIG_TDLS
+		case HW_VAR_TDLS_WRCR:
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)&(~RCR_CBSSID_DATA ));
+			break;
+		case HW_VAR_TDLS_INIT_CH_SEN:
+			{
+				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)&(~ RCR_CBSSID_DATA )&(~RCR_CBSSID_BCN ));
+				rtw_write16(adapter, REG_RXFLTMAP2,0xffff);
+
+				//disable update TSF
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
+			}
+			break;
+		case HW_VAR_TDLS_DONE_CH_SEN:
+			{
+				//enable update TSF
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~ BIT(4)));
+				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|(RCR_CBSSID_BCN ));
+			}
+			break;
+		case HW_VAR_TDLS_RS_RCR:
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|(RCR_CBSSID_DATA));
+			break;
+#endif //CONFIG_TDLS
+#ifdef CONFIG_BT_COEXIST
+		case HW_VAR_BT_SET_COEXIST:
+			{
+				u8	bStart = (*(u8 *)val);
+				rtl8192c_set_dm_bt_coexist(adapter, bStart);
+			}
+			break;
+		case HW_VAR_BT_ISSUE_DELBA:
+			{
+				u8	dir = (*(u8 *)val);
+				rtl8192c_issue_delete_ba(adapter, dir);
+			}
+			break;
+#endif
+#if (RATE_ADAPTIVE_SUPPORT==1)
+		case HW_VAR_RPT_TIMER_SETTING:
+			{
+				u16	min_rpt_time = (*(u16 *)val);
+
+				//DBG_8192C("==> HW_VAR_ANTENNA_DIVERSITY_SELECT , Ant_(%s)\n",(Optimum_antenna==2)?"A":"B");
+
+				ODM_RA_Set_TxRPT_Time(podmpriv,min_rpt_time);	
+			}
+			break;
+#endif
+
+#ifdef CONFIG_SW_ANTENNA_DIVERSITY
+		case HW_VAR_ANTENNA_DIVERSITY_LINK:
+			//odm_SwAntDivRestAfterLink8192C(Adapter);
+			ODM_SwAntDivRestAfterLink(podmpriv);
+			break;
+#endif			
+#ifdef CONFIG_ANTENNA_DIVERSITY
+		case HW_VAR_ANTENNA_DIVERSITY_SELECT:
+			{
+				u8	Optimum_antenna = (*(u8 *)val);
+				u8 	Ant ; 
+				//switch antenna to Optimum_antenna
+				//DBG_8192C("==> HW_VAR_ANTENNA_DIVERSITY_SELECT , Ant_(%s)\n",(Optimum_antenna==2)?"A":"B");
+				if(pHalData->CurAntenna !=  Optimum_antenna)		
+				{					
+					Ant = (Optimum_antenna==2)?MAIN_ANT:AUX_ANT;
+					ODM_UpdateRxIdleAnt(&pHalData->odmpriv, Ant);
+					
+					pHalData->CurAntenna = Optimum_antenna ;
+					//DBG_8192C("==> HW_VAR_ANTENNA_DIVERSITY_SELECT , Ant_(%s)\n",(Optimum_antenna==2)?"A":"B");
+				}
+			}
+			break;
+#endif
+		case HW_VAR_EFUSE_BYTES: // To set EFUE total used bytes, added by Roger, 2008.12.22.
+			pHalData->EfuseUsedBytes = *((u16 *)val);			
+			break;
+		case HW_VAR_FIFO_CLEARN_UP:
+			{				
+				struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(adapter);
+				u8 trycnt = 100;	
+				
+				//pause tx
+				rtw_write8(adapter,REG_TXPAUSE,0xff);
+			
+				//keep sn
+				adapter->xmitpriv.nqos_ssn = rtw_read16(adapter,REG_NQOS_SEQ);
+
+				if(pwrpriv->bkeepfwalive != _TRUE)
+				{
+					//RX DMA stop
+					rtw_write32(adapter,REG_RXPKT_NUM,(rtw_read32(adapter,REG_RXPKT_NUM)|RW_RELEASE_EN));
+					do{
+						if(!(rtw_read32(adapter,REG_RXPKT_NUM)&RXDMA_IDLE))
+							break;
+					}while(trycnt--);
+					if(trycnt ==0)
+						DBG_8192C("Stop RX DMA failed...... \n");
+
+					//RQPN Load 0
+					rtw_write16(adapter,REG_RQPN_NPQ,0x0);
+					rtw_write32(adapter,REG_RQPN,0x80000000);
+					rtw_mdelay_os(10);
+				}
+			}
+			break;
+
+
+		case HW_VAR_APFM_ON_MAC:
+			pHalData->bMacPwrCtrlOn = *val;
+			DBG_871X("%s: bMacPwrCtrlOn=%d\n", __func__, pHalData->bMacPwrCtrlOn);
+			break;
+	#if (RATE_ADAPTIVE_SUPPORT == 1)
+		case HW_VAR_TX_RPT_MAX_MACID:
+			{
+				if(pHalData->fw_ractrl == _FALSE){
+					u8 maxMacid = *val;				
+					DBG_8192C("### MacID(%d),Set Max Tx RPT MID(%d)\n",maxMacid,maxMacid+1);
+					rtw_write8(adapter, REG_TX_RPT_CTRL+1, maxMacid+1);
+				}
+			}
+			break;
+        #endif	//  (RATE_ADAPTIVE_SUPPORT == 1)		
+		case HW_VAR_H2C_MEDIA_STATUS_RPT:
+			{				
+				rtl8188e_set_FwMediaStatus_cmd(adapter , (*(u16 *)val));
+			}
+			break;
+		case HW_VAR_BCN_VALID:
+			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw
+			rtw_write8(adapter, REG_TDECTRL+2, rtw_read8(adapter, REG_TDECTRL+2) | BIT0); 
+			break;
+			
+			
+		case HW_VAR_CHECK_TXBUF:
+			{
+				u8 retry_limit;
+				u16 val16;
+				u32 reg_200 = 0, reg_204 = 0;
+				u32 init_reg_200 = 0, init_reg_204 = 0;
+				u32 start = rtw_get_current_time();
+				u32 pass_ms;
+				int i = 0;
+
+				retry_limit = 0x01;
+
+				val16 = retry_limit << RETRY_LIMIT_SHORT_SHIFT | retry_limit << RETRY_LIMIT_LONG_SHIFT;
+				rtw_write16(adapter, REG_RL, val16);
+
+				while (rtw_get_passing_time_ms(start) < 2000
+					&& !adapter->bDriverStopped && !adapter->bSurpriseRemoved
+				) {
+					reg_200 = rtw_read32(adapter, 0x200);
+					reg_204 = rtw_read32(adapter, 0x204);
+
+					if (i == 0) {
+						init_reg_200 = reg_200;
+						init_reg_204 = reg_204;
+					}
+
+					i++;
+					if ((reg_200 & 0x00ffffff) != (reg_204 & 0x00ffffff)) {
+						//DBG_871X("%s: (HW_VAR_CHECK_TXBUF)TXBUF NOT empty - 0x204=0x%x, 0x200=0x%x (%d)\n", __FUNCTION__, reg_204, reg_200, i);
+						rtw_msleep_os(10);
+					} else {
+						break;
+					}
+				}
+
+				pass_ms = rtw_get_passing_time_ms(start);
+
+				if (adapter->bDriverStopped || adapter->bSurpriseRemoved) {
+				} else if (pass_ms >= 2000 || (reg_200 & 0x00ffffff) != (reg_204 & 0x00ffffff)) {
+					DBG_871X_LEVEL(_drv_always_, "%s:(HW_VAR_CHECK_TXBUF)NOT empty(%d) in %d ms\n", __FUNCTION__, i, pass_ms);
+					DBG_871X_LEVEL(_drv_always_, "%s:(HW_VAR_CHECK_TXBUF)0x200=0x%08x, 0x204=0x%08x (0x%08x, 0x%08x)\n",
+						__FUNCTION__, reg_200, reg_204, init_reg_200, init_reg_204);
+					//rtw_warn_on(1);
+				} else {
+					DBG_871X("%s:(HW_VAR_CHECK_TXBUF)TXBUF Empty(%d) in %d ms\n", __FUNCTION__, i, pass_ms);
+				}
+
+				retry_limit = 0x30;
+				val16 = retry_limit << RETRY_LIMIT_SHORT_SHIFT | retry_limit << RETRY_LIMIT_LONG_SHIFT;
+				rtw_write16(adapter, REG_RL, val16);
+			}
+			break;
+		case HW_VAR_RESP_SIFS:
+			{
+				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+
+				if((pmlmeext->cur_wireless_mode==WIRELESS_11G) ||
+				(pmlmeext->cur_wireless_mode==WIRELESS_11BG))//WIRELESS_MODE_G){
+				{
+					val[0] = 0x0a;
+					val[1] = 0x0a;
+				} else {
+					val[0] = 0x0e;
+					val[1] = 0x0e;
+				}
+
+				// SIFS for OFDM Data ACK
+				rtw_write8(adapter, REG_SIFS_CTX+1, val[0]);
+				// SIFS for OFDM consecutive tx like CTS data!
+				rtw_write8(adapter, REG_SIFS_TRX+1, val[1]);
+
+				rtw_write8(adapter, REG_SPEC_SIFS+1, val[0]);
+				rtw_write8(adapter, REG_MAC_SPEC_SIFS+1, val[0]);
+						
+				//RESP_SIFS for OFDM
+				rtw_write8(adapter, REG_RESP_SIFS_OFDM, val[0]);
+				rtw_write8(adapter, REG_RESP_SIFS_OFDM+1, val[0]);
+			}
+			break;
+
+		case HW_VAR_MACID_SLEEP:
+		{
+			u32 reg_macid_sleep;
+			u8 bit_shift;
+			u8 id = *(u8*)val;
+			u32 val32;
+
+			if (id < 32){
+				reg_macid_sleep = REG_MACID_PAUSE_0;
+				bit_shift = id;
+			} else if (id < 64) {
+				reg_macid_sleep = REG_MACID_PAUSE_1;
+				bit_shift = id-32;
+			} else {
+				rtw_warn_on(1);
+				break;
+			}
+
+			val32 = rtw_read32(adapter, reg_macid_sleep);
+			DBG_8192C(FUNC_ADPT_FMT ": [HW_VAR_MACID_SLEEP] macid=%d, org reg_0x%03x=0x%08X\n",
+				FUNC_ADPT_ARG(adapter), id, reg_macid_sleep, val32);
+
+			if (val32 & BIT(bit_shift))
+				break;
+
+			val32 |= BIT(bit_shift);
+			rtw_write32(adapter, reg_macid_sleep, val32);
+		}
+			break;
+
+		case HW_VAR_MACID_WAKEUP:
+		{
+			u32 reg_macid_sleep;
+			u8 bit_shift;
+			u8 id = *(u8*)val;
+			u32 val32;
+
+			if (id < 32){
+				reg_macid_sleep = REG_MACID_PAUSE_0;
+				bit_shift = id;
+			} else if (id < 64) {
+				reg_macid_sleep = REG_MACID_PAUSE_1;
+				bit_shift = id-32;
+			} else {
+				rtw_warn_on(1);
+				break;
+			}
+
+			val32 = rtw_read32(adapter, reg_macid_sleep);
+			DBG_8192C(FUNC_ADPT_FMT ": [HW_VAR_MACID_WAKEUP] macid=%d, org reg_0x%03x=0x%08X\n",
+				FUNC_ADPT_ARG(adapter), id, reg_macid_sleep, val32);
+
+			if (!(val32 & BIT(bit_shift)))
+				break;
+
+			val32 &= ~BIT(bit_shift);
+			rtw_write32(adapter, reg_macid_sleep, val32);
+		}
+			break;
+
+		default:
+			SetHwReg(adapter, variable, val);
+			break;
+	}
+
+_func_exit_;
+}
+
+struct qinfo_88e {
+	u32 head:8;
+	u32 pkt_num:8;
+	u32 tail:8;
+	u32 ac:2;
+	u32 macid:6;
+};
+
+struct bcn_qinfo_88e {
+	u16 head:8;
+	u16 pkt_num:8;
+};
+
+void dump_qinfo_88e(void *sel, struct qinfo_88e *info, const char *tag)
+{
+	//if (info->pkt_num)
+	DBG_871X_SEL_NL(sel, "%shead:0x%02x, tail:0x%02x, pkt_num:%u, macid:%u, ac:%u\n"
+		, tag ? tag : "", info->head, info->tail, info->pkt_num, info->macid, info->ac
+	);
+}
+
+void dump_bcn_qinfo_88e(void *sel, struct bcn_qinfo_88e *info, const char *tag)
+{
+	//if (info->pkt_num)
+	DBG_871X_SEL_NL(sel, "%shead:0x%02x, pkt_num:%u\n"
+		, tag ? tag : "", info->head, info->pkt_num
+	);
+}
+
+void dump_mac_qinfo_88e(void *sel, _adapter *adapter)
+{
+	u32 q0_info;
+	u32 q1_info;
+	u32 q2_info;
+	u32 q3_info;
+	/*
+	u32 q4_info;
+	u32 q5_info;
+	u32 q6_info;
+	u32 q7_info;
+	*/
+	u32 mg_q_info;
+	u32 hi_q_info;
+	u16 bcn_q_info;
+
+	q0_info = rtw_read32(adapter, REG_Q0_INFO);
+	q1_info = rtw_read32(adapter, REG_Q1_INFO);
+	q2_info = rtw_read32(adapter, REG_Q2_INFO);
+	q3_info = rtw_read32(adapter, REG_Q3_INFO);
+	/*
+	q4_info = rtw_read32(adapter, REG_Q4_INFO);
+	q5_info = rtw_read32(adapter, REG_Q5_INFO);
+	q6_info = rtw_read32(adapter, REG_Q6_INFO);
+	q7_info = rtw_read32(adapter, REG_Q7_INFO);
+	*/
+	mg_q_info = rtw_read32(adapter, REG_MGQ_INFO);
+	hi_q_info = rtw_read32(adapter, REG_HGQ_INFO);
+	bcn_q_info = rtw_read16(adapter, REG_BCNQ_INFO);
+
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&q0_info, "Q0 ");
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&q1_info, "Q1 ");
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&q2_info, "Q2 ");
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&q3_info, "Q3 ");
+	/*
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&q4_info, "Q4 ");
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&q5_info, "Q5 ");
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&q6_info, "Q6 ");
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&q7_info, "Q7 ");
+	*/
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&mg_q_info, "MG ");
+	dump_qinfo_88e(sel, (struct qinfo_88e *)&hi_q_info, "HI ");
+	dump_bcn_qinfo_88e(sel, (struct bcn_qinfo_88e *)&bcn_q_info, "BCN ");
+}
+
+void GetHwReg8188E(_adapter *adapter, u8 variable, u8 *val)
+{
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(adapter);
+
+_func_enter_;
+
+	switch (variable) {
+		case HW_VAR_SYS_CLKR:
+			*val = rtw_read8(adapter, REG_SYS_CLKR);
+			break;
+
+		case HW_VAR_TXPAUSE:
+			val[0] = rtw_read8(adapter, REG_TXPAUSE);
+			break;
+		case HW_VAR_BCN_VALID:
+			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2
+			val[0] = (BIT0 & rtw_read8(adapter, REG_TDECTRL+2))?_TRUE:_FALSE;
+			break;
+		case HW_VAR_FWLPS_RF_ON:
+			{
+				//When we halt NIC, we should check if FW LPS is leave.
+				if(adapter_to_pwrctl(adapter)->rf_pwrstate == rf_off)
+				{
+					// If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave,
+					// because Fw is unload.
+					val[0] = _TRUE;
+				}
+				else
+				{
+					u32 valRCR;
+					valRCR = rtw_read32(adapter, REG_RCR);
+					valRCR &= 0x00070000;
+					if(valRCR)
+						val[0] = _FALSE;
+					else
+						val[0] = _TRUE;
+				}
+			}
+			break;
+#ifdef CONFIG_ANTENNA_DIVERSITY
+		case HW_VAR_CURRENT_ANTENNA:
+			val[0] = pHalData->CurAntenna;
+			break;
+#endif
+		case HW_VAR_EFUSE_BYTES: // To get EFUE total used bytes, added by Roger, 2008.12.22.
+			*((u16 *)(val)) = pHalData->EfuseUsedBytes;	
+			break;
+		case HW_VAR_APFM_ON_MAC:
+			*val = pHalData->bMacPwrCtrlOn;
+			break;
+		case HW_VAR_CHK_HI_QUEUE_EMPTY:
+			*val = ((rtw_read32(adapter, REG_HGQ_INFO)&0x0000ff00)==0) ? _TRUE:_FALSE;
+			break;
+		case HW_VAR_DUMP_MAC_QUEUE_INFO:
+			dump_mac_qinfo_88e(val, adapter);
+			break;
+		default:
+			GetHwReg(adapter, variable, val);
+			break;
+	}
+
+_func_exit_;
+}
+
+u8
+GetHalDefVar8188E(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+	)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	u8			bResult = _SUCCESS;
+
+	switch(eVariable)
+	{
+		case HAL_DEF_IS_SUPPORT_ANT_DIV:
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			*((u8 *)pValue) = (pHalData->AntDivCfg==0)?_FALSE:_TRUE;
+			#endif
+break;
+		case HAL_DEF_CURRENT_ANTENNA:
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			*(( u8*)pValue) = pHalData->CurAntenna;
+#endif
+			break;
+		case HAL_DEF_DRVINFO_SZ:
+			*(( u32*)pValue) = DRVINFO_SZ;
+			break;	
+		case HAL_DEF_MAX_RECVBUF_SZ:
+			*(( u32*)pValue) = MAX_RECVBUF_SZ;
+			break;
+		case HAL_DEF_RX_PACKET_OFFSET:
+			*(( u32*)pValue) = RXDESC_SIZE + DRVINFO_SZ;
+			break;			
+#if (RATE_ADAPTIVE_SUPPORT == 1)
+		case HAL_DEF_RA_DECISION_RATE:
+			{
+				u8 MacID = *((u8*)pValue);
+				*((u8*)pValue) = ODM_RA_GetDecisionRate_8188E(&(pHalData->odmpriv), MacID);
+			}
+			break;
+		
+		case HAL_DEF_RA_SGI:
+			{
+				u8 MacID = *((u8*)pValue);
+				*((u8*)pValue) = ODM_RA_GetShortGI_8188E(&(pHalData->odmpriv), MacID);
+			}
+			break;		
+#endif
+
+
+		case HAL_DEF_PT_PWR_STATUS:
+#if(POWER_TRAINING_ACTIVE==1)	
+			{
+				u8 MacID = *((u8*)pValue);
+				*((u8*)pValue) = ODM_RA_GetHwPwrStatus_8188E(&(pHalData->odmpriv), MacID);
+			}
+#endif //(POWER_TRAINING_ACTIVE==1)
+			break;		
+		case HAL_DEF_EXPLICIT_BEAMFORMEE:
+		case HAL_DEF_EXPLICIT_BEAMFORMER:
+			*((u8 *)pValue) = _FALSE;
+			break;
+
+		case HW_DEF_RA_INFO_DUMP:
+
+			{
+				u8 mac_id = *((u8*)pValue);				
+				u8 			bLinked = _FALSE;
+#ifdef CONFIG_CONCURRENT_MODE
+				PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
+#endif //CONFIG_CONCURRENT_MODE
+
+				if(rtw_linked_check(Adapter))
+					bLinked = _TRUE;
+		
+#ifdef CONFIG_CONCURRENT_MODE
+				if(pbuddy_adapter && rtw_linked_check(pbuddy_adapter))
+					bLinked = _TRUE;
+#endif			
+				
+				if(bLinked){
+					DBG_871X("============ RA status - Mac_id:%d ===================\n",mac_id);
+					if(pHalData->fw_ractrl == _FALSE){
+						#if (RATE_ADAPTIVE_SUPPORT == 1)											
+						DBG_8192C("Mac_id:%d ,RSSI:%d(%%) ,PTStage = %d\n",
+							mac_id,pHalData->odmpriv.RAInfo[mac_id].RssiStaRA,pHalData->odmpriv.RAInfo[mac_id].PTStage);							
+
+						DBG_8192C("RateID = %d,RAUseRate = 0x%08x,RateSGI = %d, DecisionRate = %s\n",
+							pHalData->odmpriv.RAInfo[mac_id].RateID,
+							pHalData->odmpriv.RAInfo[mac_id].RAUseRate,
+							pHalData->odmpriv.RAInfo[mac_id].RateSGI,
+							HDATA_RATE(pHalData->odmpriv.RAInfo[mac_id].DecisionRate));
+						#endif // (RATE_ADAPTIVE_SUPPORT == 1)
+					}else{
+						u8 cur_rate = rtw_read8(Adapter,REG_ADAPTIVE_DATA_RATE_0+mac_id);
+						u8 sgi = (cur_rate & BIT7)?_TRUE:_FALSE;
+						cur_rate &= 0x7f;
+						DBG_8192C("Mac_id:%d ,SGI:%d ,Rate:%s \n",mac_id,sgi,HDATA_RATE(cur_rate));
+					}
+				}
+			}
+
+			break;
+		case HAL_DEF_TX_PAGE_SIZE:
+			 *(( u32*)pValue) = PAGE_SIZE_128;
+			break;
+		case HAL_DEF_TX_PAGE_BOUNDARY:
+			if (!Adapter->registrypriv.wifi_spec)
+				*(u8*)pValue = TX_PAGE_BOUNDARY_88E(Adapter);
+			else
+				*(u8*)pValue = WMM_NORMAL_TX_PAGE_BOUNDARY_88E(Adapter);
+			break;
+		case HAL_DEF_MACID_SLEEP:
+			*(u8*)pValue = _TRUE; // support macid sleep
+			break;
+		default:
+			bResult = GetHalDefVar(Adapter, eVariable, pValue);
+			break;
+	}
+
+	return bResult;
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_mp.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_mp.c
index 7e63d5c17c21..a26218b0b92e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_mp.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_mp.c
@@ -403,12 +403,12 @@ void Hal_SetCCKTxPower(PADAPTER pAdapter, u8 *TxPower)
 	// rf-A cck tx power
 	write_bbreg(pAdapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, TxPower[RF_PATH_A]);
 	tmpval = (TxPower[RF_PATH_A]<<16) | (TxPower[RF_PATH_A]<<8) | TxPower[RF_PATH_A];
-	write_bbreg(pAdapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);
+	write_bbreg(pAdapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskH3Bytes, tmpval);
 
 	// rf-B cck tx power
 	write_bbreg(pAdapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskByte0, TxPower[RF_PATH_B]);
 	tmpval = (TxPower[RF_PATH_B]<<16) | (TxPower[RF_PATH_B]<<8) | TxPower[RF_PATH_B];
-	write_bbreg(pAdapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
+	write_bbreg(pAdapter, rTxAGC_B_CCK1_55_Mcs32, bMaskH3Bytes, tmpval);
 
 	RT_TRACE(_module_mp_, _drv_notice_,
 		 ("-SetCCKTxPower: A[0x%02x] B[0x%02x]\n",
@@ -760,7 +760,7 @@ s32 Hal_SetThermalMeter(PADAPTER pAdapter, u8 target_ther)
 void Hal_TriggerRFThermalMeter(PADAPTER pAdapter)
 {
   
-	_write_rfreg( pAdapter, RF_PATH_A , RF_T_METER_88E , BIT17 |BIT16 , 0x03 );
+	PHY_SetRFReg(pAdapter, ODM_RF_PATH_A, RF_T_METER_88E, bRFRegOffsetMask, 0x60);
 
 //	RT_TRACE(_module_mp_,_drv_alert_, ("TriggerRFThermalMeter() finished.\n" ));
 }
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_phycfg.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_phycfg.c
index d265a854bd28..6f9314e68598 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_phycfg.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_phycfg.c
@@ -783,8 +783,8 @@ s32 PHY_MACConfig8188E(PADAPTER Adapter)
 {
 	int		rtStatus = _SUCCESS;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	s8			*pszMACRegFile;
-	s8			sz8188EMACRegFile[] = RTL8188E_PHY_MACREG;
+	s8		*pszMACRegFile;
+	s8		sz8188EMACRegFile[] = RTL8188E_PHY_MACREG;
 	u16		val=0;
 
 	pszMACRegFile = sz8188EMACRegFile;
@@ -933,7 +933,7 @@ storePwrIndexDiffRateOffset(
 		//printk("MCSTxPowerLevelOriginalOffset[%d][6]-TxAGC_A_CCK1_Mcs32 = 0x%x\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][6]);
 	}
-	if(RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0xffffff00)
+	if(RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == bMaskH3Bytes)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7] = Data;
 		//printk("MCSTxPowerLevelOriginalOffset[%d][7]-TxAGC_B_CCK11_A_CCK2_11 = 0x%x\n", pHalData->pwrGroupCnt,
@@ -1691,28 +1691,18 @@ phy_SpurCalibration_8188E(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	
-	if(pHalData->CurrentChannelBW == CHANNEL_WIDTH_20 && pHalData->CurrentChannel == 13){
+	//DbgPrint("===> phy_SpurCalibration_8188E  CurrentChannelBW = %d, CurrentChannel = %d\n", pHalData->CurrentChannelBW, pHalData->CurrentChannel);
+	if(pHalData->CurrentChannelBW == CHANNEL_WIDTH_20 &&( pHalData->CurrentChannel == 13 || pHalData->CurrentChannel == 14)){
 		PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT(9), 0x1);                     	//enable notch filter
-		PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT(28)|BIT(27)|BIT(26)|BIT(25)|BIT(24), 0xb);
-		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT(28), 0x1);			 //enable CSI Mask
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask1, BIT(26)|BIT(25), 0x3);	 //Fix CSI Mask Tone
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask2, BIT(26)|BIT(25), 0x0); 
+		PHY_SetBBReg(Adapter, rOFDM1_IntfDet, BIT(8)|BIT(7)|BIT(6), 0x2);	//intf_TH
 	}
 	else if(pHalData->CurrentChannelBW == CHANNEL_WIDTH_40 && pHalData->CurrentChannel == 11){
-		if(Adapter->registrypriv.notch_filter == 0)
-			PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT9, 0x0);                     		//disable notch filter
-		PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT(28)|BIT(27)|BIT(26)|BIT(25)|BIT(24), 0x1f);
-		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT(28), 0x1);			 //enable CSI Mask
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask1, BIT(26)|BIT(25), 0x0); 
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask2, BIT(26)|BIT(25), 0x3); 	//Fix CSI Mask Tone
+		PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT(9), 0x1);                     	//enable notch filter
+		PHY_SetBBReg(Adapter, rOFDM1_IntfDet, BIT(8)|BIT(7)|BIT(6), 0x2);	//intf_TH
 	}
 	else{
 		if(Adapter->registrypriv.notch_filter == 0)
-			PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT9, 0x0);                     		//disable notch filter
-		PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT(28)|BIT(27)|BIT(26)|BIT(25)|BIT(24), 0x1f);
-		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT(28), 0x0);		 	//disable CSI Mask
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask1, BIT(26)|BIT(25), 0x0); 
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask2, BIT(26)|BIT(25), 0x0); 
+			PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT(9), 0x0);	//disable notch filter
 	}
 }
 
@@ -1950,8 +1940,10 @@ PHY_SetBWMode8188E(
 	#else
 		_PHY_SetBWMode88E(Adapter);
 	#endif
-		if (IS_VENDOR_8188E_I_CUT_SERIES(Adapter)&& IS_HARDWARE_TYPE_8188ES(Adapter))
+	#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+		if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
 			phy_SpurCalibration_8188E( Adapter);
+	#endif
 	}
 	else
 	{
@@ -2053,8 +2045,11 @@ PHY_SwChnl8188E(	// Call after initialization
 		_PHY_SwChnl8188E(Adapter, channel);
 		#endif
 
-		if (IS_VENDOR_8188E_I_CUT_SERIES(Adapter)&& IS_HARDWARE_TYPE_8188ES(Adapter))
+		#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+		if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
 			phy_SpurCalibration_8188E( Adapter);
+		#endif
+
 		
 
 		if(bResult)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_rxdesc.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_rxdesc.c
index 0039b76730f1..4bdc6e3792cc 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_rxdesc.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_rxdesc.c
@@ -22,19 +22,6 @@
 #include <drv_types.h>
 #include <rtl8188e_hal.h>
 
-static s32  translate2dbm(u8 signal_strength_idx)
-{
-	s32	signal_power; // in dBm.
-
-
-	// Translate to dBm (x=0.5y-95).
-	signal_power = (s32)((signal_strength_idx + 1) >> 1);
-	signal_power -= 95;
-
-	return signal_power;
-}
-
-
 static void process_rssi(_adapter *padapter,union recv_frame *prframe)
 {
 	u32	last_rssi, tmp_val;
@@ -77,10 +64,10 @@ static void process_rssi(_adapter *padapter,union recv_frame *prframe)
 		
 		if(padapter->recvpriv.is_signal_dbg) {
 			padapter->recvpriv.signal_strength= padapter->recvpriv.signal_strength_dbg;
-			padapter->recvpriv.rssi=(s8)translate2dbm((u8)padapter->recvpriv.signal_strength_dbg);
+			padapter->recvpriv.rssi=(s8)translate_percentage_to_dbm(padapter->recvpriv.signal_strength_dbg);
 		} else {
 			padapter->recvpriv.signal_strength= tmp_val;
-			padapter->recvpriv.rssi=(s8)translate2dbm((u8)tmp_val);
+			padapter->recvpriv.rssi=(s8)translate_percentage_to_dbm(tmp_val);
 		}
 
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("UI RSSI = %d, ui_rssi.TotalVal = %d, ui_rssi.TotalNum = %d\n", tmp_val, padapter->recvpriv.signal_strength_data.total_val,padapter->recvpriv.signal_strength_data.total_num));
@@ -289,6 +276,8 @@ void update_recvframe_phyinfo_88e(
 		!pattrib->icv_err && !pattrib->crc_err &&
 		_rtw_memcmp(get_hdr_bssid(wlanhdr), get_bssid(&padapter->mlmepriv), ETH_ALEN));
 
+	pkt_info.bToSelf = ((!pattrib->icv_err) && (!pattrib->crc_err)) && (_rtw_memcmp(get_ra(wlanhdr), myid(&padapter->eeprompriv), ETH_ALEN));
+
 	pkt_info.bPacketToSelf = pkt_info.bPacketMatchBSSID && (_rtw_memcmp(get_ra(wlanhdr), myid(&padapter->eeprompriv), ETH_ALEN));
 
 	pkt_info.bPacketBeacon = pkt_info.bPacketMatchBSSID && (GetFrameSubType(wlanhdr) == WIFI_BEACON);
@@ -329,6 +318,7 @@ void update_recvframe_phyinfo_88e(
 
 	//_enter_critical_bh(&pHalData->odm_stainfo_lock, &irqL);	
 	ODM_PhyStatusQuery(&pHalData->odmpriv,pPHYInfo,(u8 *)pphy_status,&(pkt_info));
+	if(psta) psta->rssi = pattrib->phy_info.RecvSignalPower;
 	//_exit_critical_bh(&pHalData->odm_stainfo_lock, &irqL);
 
 	precvframe->u.hdr.psta = NULL;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_xmit.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_xmit.c
index 9fd239f9feab..53166d30f1e6 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_xmit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/rtl8188e_xmit.c
@@ -287,4 +287,21 @@ void UpdateEarlyModeInfo8188E(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmit
 }
 #endif
 
+void rtl8188e_cal_txdesc_chksum(struct tx_desc *ptxdesc)
+{
+	u16	*usPtr = (u16*)ptxdesc;
+	u32 count = 16;		// (32 bytes / 2 bytes per XOR) => 16 times
+	u32 index;
+	u16 checksum = 0;
+
+
+	// Clear first
+	ptxdesc->txdw7 &= cpu_to_le32(0xffff0000);
+
+	for (index = 0; index < count; index++) {
+		checksum ^= le16_to_cpu(*(usPtr + index));
+	}
+
+	ptxdesc->txdw7 |= cpu_to_le32(checksum & 0x0000ffff);
+}
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/sdio/rtl8189es_xmit.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/sdio/rtl8189es_xmit.c
index d3253fdc37c0..4b706923697f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/sdio/rtl8189es_xmit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/sdio/rtl8189es_xmit.c
@@ -132,23 +132,6 @@ static void fill_txdesc_phy(struct pkt_attrib *pattrib, PTXDESC_8188E ptxdesc)
 	}
 }
 
-static void rtl8188e_cal_txdesc_chksum(struct tx_desc *ptxdesc)
-{
-	u16	*usPtr = (u16*)ptxdesc;
-	u32 count = 16;		// (32 bytes / 2 bytes per XOR) => 16 times
-	u32 index;
-	u16 checksum = 0;
-
-
-	// Clear first
-	ptxdesc->txdw7 &= cpu_to_le32(0xffff0000);
-
-	for (index = 0; index < count; index++) {
-		checksum ^= le16_to_cpu(*(usPtr + index));
-	}
-
-	ptxdesc->txdw7 |= cpu_to_le32(checksum & 0x0000ffff);
-}
 //
 // Description: In normal chip, we should send some packet to Hw which will be used by Fw
 //			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then
@@ -156,11 +139,11 @@ static void rtl8188e_cal_txdesc_chksum(struct tx_desc *ptxdesc)
 //
 void rtl8188e_fill_fake_txdesc(
 	PADAPTER	padapter,
-	u8*			pDesc,
-	u32			BufferLen,
-	u8			IsPsPoll,
-	u8			IsBTQosNull,
-	u8			bDataFrame)
+	u8*		pDesc,
+	u32		BufferLen,
+	u8		IsPsPoll,
+	u8		IsBTQosNull,
+	u8		bDataFrame)
 {
 	struct tx_desc *ptxdesc;
 
@@ -269,10 +252,13 @@ void rtl8188es_fill_default_txdesc(
 	{
 		ptxdesc->macid = pattrib->mac_id; // CAM_ID(MAC_ID)
 
-		if (pattrib->ampdu_en == _TRUE)
+		if (pattrib->ampdu_en == _TRUE){
 			ptxdesc->agg_en = 1; // AGG EN
-		else
+			ptxdesc->ampdu_density = pattrib->ampdu_spacing; 
+		}
+		else{
 			ptxdesc->bk = 1; // AGG BK
+		}
 
 		ptxdesc->qsel = pattrib->qsel;
 		ptxdesc->rate_id = pattrib->raid;
@@ -283,8 +269,6 @@ void rtl8188es_fill_default_txdesc(
 
 		//todo: qos_en
 
-		ptxdesc->userate = 1; // driver uses rate	
-
 		if ((pattrib->ether_type != 0x888e) &&
 			(pattrib->ether_type != 0x0806) &&
 			(pattrib->dhcp_pkt != 1))
@@ -299,26 +283,32 @@ void rtl8188es_fill_default_txdesc(
 			ptxdesc->rts_ratefb_lmt = 0xF;
 
 #if (RATE_ADAPTIVE_SUPPORT == 1)
-			/* driver-based RA*/
-			if (pattrib->ht_en)
-				ptxdesc->sgi = ODM_RA_GetShortGI_8188E(&pHalData->odmpriv,pattrib->mac_id);
-			ptxdesc->datarate = ODM_RA_GetDecisionRate_8188E(&pHalData->odmpriv,pattrib->mac_id);
-
-			#if (POWER_TRAINING_ACTIVE==1)
-			ptxdesc->pwr_status = ODM_RA_GetHwPwrStatus_8188E(&pHalData->odmpriv,pattrib->mac_id);
-			#endif
-#else /* (RATE_ADAPTIVE_SUPPORT == 1) */
-			/* FW-based RA, TODO */
-			if(pattrib->ht_en)
-				ptxdesc->sgi = 1;
-
-			ptxdesc->datarate = 0x13; //MCS7
+			if(pHalData->fw_ractrl == _FALSE){
+				/* driver-based RA*/
+				ptxdesc->userate = 1; // driver uses rate	
+				if (pattrib->ht_en)
+					ptxdesc->sgi = ODM_RA_GetShortGI_8188E(&pHalData->odmpriv,pattrib->mac_id);
+				ptxdesc->datarate = ODM_RA_GetDecisionRate_8188E(&pHalData->odmpriv,pattrib->mac_id);
+
+				#if (POWER_TRAINING_ACTIVE==1)
+				ptxdesc->pwr_status = ODM_RA_GetHwPwrStatus_8188E(&pHalData->odmpriv,pattrib->mac_id);
+				#endif
+			}
+			else
 #endif /* (RATE_ADAPTIVE_SUPPORT == 1) */
+			{
+				/* FW-based RA, TODO */
+				if(pattrib->ht_en)
+					ptxdesc->sgi = 1;
+
+				ptxdesc->datarate = 0x13; //MCS7
+			}
 
 			if (padapter->fix_rate != 0xFF) {
 				ptxdesc->userate = 1;
 				ptxdesc->datarate = padapter->fix_rate;
-				ptxdesc->disdatafb = 1;
+				if (!padapter->data_fb)
+					ptxdesc->disdatafb = 1;
 				ptxdesc->sgi = (padapter->fix_rate & BIT(7))?1:0;
 			}
 		}
@@ -327,7 +317,7 @@ void rtl8188es_fill_default_txdesc(
 			// EAP data packet and ARP and DHCP packet.
 			// Use the 1M or 6M data rate to send the EAP/ARP packet.
 			// This will maybe make the handshake smooth.
-
+			ptxdesc->userate = 1; // driver uses rate	
 			ptxdesc->bk = 1; // AGG BK	
 
 			if (pmlmeinfo->preamble_mode == PREAMBLE_SHORT)
@@ -341,7 +331,7 @@ void rtl8188es_fill_default_txdesc(
 	else if (pxmitframe->frame_tag == MGNT_FRAMETAG)
 	{
 //		RT_TRACE(_module_hal_xmit_c_, _drv_notice_, ("%s: MGNT_FRAMETAG\n", __FUNCTION__));
-
+		ptxdesc->userate = 1; // driver uses rate	
 		ptxdesc->macid = pattrib->mac_id; // CAM_ID(MAC_ID)
 		ptxdesc->qsel = pattrib->qsel;
 		ptxdesc->rate_id = pattrib->raid; // Rate ID
@@ -1176,7 +1166,7 @@ static s32 xmit_xmitframes(PADAPTER padapter, struct xmit_priv *pxmitpriv)
 				
 				if ((NULL == pxmitbuf) ||
 					((_RND(pxmitbuf->len, 8) + txlen) > max_xmit_len)
-					|| (agg_num>= (rtw_hal_sdio_max_txoqt_free_space(padapter)-1))		
+					|| (agg_num>= (rtw_hal_sdio_max_txoqt_free_space(padapter)-1))
 					|| ((agg_num!=0) && (_FAIL == rtw_hal_busagg_qsel_check(padapter,pre_qsel,next_qsel)))
 				)
 				{
@@ -1386,9 +1376,9 @@ s32 rtl8188es_xmit_handler(PADAPTER padapter)
 thread_return rtl8188es_xmit_thread(thread_context context)
 {
 	s32 ret;
-	PADAPTER padapter= (PADAPTER)context;
+	PADAPTER padapter= (PADAPTER)context;	
 	struct xmit_priv *pxmitpriv= &padapter->xmitpriv;
-
+	
 	ret = _SUCCESS;
 
 	thread_enter("RTWHALXT");
@@ -1406,6 +1396,7 @@ thread_return rtl8188es_xmit_thread(thread_context context)
 
 	RT_TRACE(_module_hal_xmit_c_, _drv_notice_, ("-%s\n", __FUNCTION__));
 	DBG_871X("exit %s\n", __FUNCTION__);
+
 	thread_exit();
 }
 #endif
@@ -1448,11 +1439,9 @@ s32 rtl8188es_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe)
 		rtw_IOL_cmd_buf_dump(padapter,pxmitbuf->len,pxmitbuf->pdata);
 #endif	
 
-		rtw_write_port(padapter, ffaddr2deviceId(pdvobjpriv, pxmitbuf->ff_hwaddr), pxmitbuf->len, (u8 *)pxmitbuf);
-		
-		//rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		
-		//pxmitbuf->priv_data = NULL;
+		ret = rtw_write_port(padapter, ffaddr2deviceId(pdvobjpriv, pxmitbuf->ff_hwaddr), pxmitbuf->len, (u8 *)pxmitbuf);
+		if (ret != _SUCCESS)
+			rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_WRITE_PORT_ERR);
 		
 		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 	}		
@@ -1461,9 +1450,6 @@ s32 rtl8188es_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe)
 		enqueue_pending_xmitbuf(pxmitpriv, pxmitbuf);
 	}
 
-	if  (ret != _SUCCESS)
-		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_UNKNOWN);
-
 	return ret;
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/sdio/sdio_halinit.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/sdio/sdio_halinit.c
index f430a520c901..1919eb31d476 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/sdio/sdio_halinit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/hal/rtl8188e/sdio/sdio_halinit.c
@@ -94,6 +94,24 @@ static int PowerOnCheck(PADAPTER padapter)
 	} else {
 		DBG_871X("%s: fail at cmd52, cmd53.\n", __func__);
 	}
+
+	if (ret == _FAIL) {
+		DBG_871X_LEVEL(_drv_err_, "Dump MAC Page0 register:\n");
+		/* Dump Page0 for check cystal*/
+		for (index = 0 ; index < 0xff ; index++) {
+			if(index%16==0)
+				printk("0x%02x ",index);
+
+			printk("%02x ", rtw_read8(padapter, index)); 
+
+			if(index%16==15)
+				printk("\n");
+			else if(index%8==7)
+				printk("\t");
+		}
+		printk("\n");
+	}
+
 	return ret;
 }
 
@@ -558,7 +576,7 @@ static void _InitQueueReservedPage(PADAPTER padapter)
 	value8 = (u8)_NPQ(numNQ);
 	rtw_write8(padapter, REG_RQPN_NPQ, value8);
 
-	numPubQ = TX_TOTAL_PAGE_NUMBER_88E - numHQ - numLQ - numNQ;
+	numPubQ = TX_TOTAL_PAGE_NUMBER_88E(padapter) - numHQ - numLQ - numNQ;
 
 	// TX DMA
 	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;
@@ -758,7 +776,7 @@ static void _InitQueuePriority(PADAPTER padapter)
 static void _InitPageBoundary(PADAPTER padapter)
 {
 	// RX Page Boundary	
-	u16 rxff_bndy = MAX_RX_DMA_BUFFER_SIZE_88E-1;
+	u16 rxff_bndy = MAX_RX_DMA_BUFFER_SIZE_88E(padapter)-1;
 
 	rtw_write16(padapter, (REG_TRXFF_BNDY + 2), rxff_bndy);
 
@@ -895,8 +913,6 @@ static void HalRxAggr8188ESdio(PADAPTER padapter)
 	else
 	{
 		valueDMATimeout = 0x06;
-		//valueDMAPageCount = 0x0F;
-		//valueDMATimeout = 0x0a;  
 		valueDMAPageCount = 0x24;
 	}
 
@@ -1035,25 +1051,6 @@ void _InitOperationMode(PADAPTER padapter)
 
 	rtw_write8(padapter, REG_BWOPMODE, regBwOpMode);
 
-	// For Min Spacing configuration.
-	switch(pHalData->rf_type)
-	{
-		case RF_1T2R:
-		case RF_1T1R:
-			RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("Initializepadapter: RF_Type%s\n", (pHalData->rf_type==RF_1T1R? "(1T1R)":"(1T2R)")));
-//			padapter->MgntInfo.MinSpaceCfg = (MAX_MSS_DENSITY_1T<<3);
-			MinSpaceCfg = (MAX_MSS_DENSITY_1T << 3);
-			break;
-		case RF_2T2R:
-		case RF_2T2R_GREEN:
-			RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("Initializepadapter:RF_Type(2T2R)\n"));
-//			padapter->MgntInfo.MinSpaceCfg = (MAX_MSS_DENSITY_2T<<3);
-			MinSpaceCfg = (MAX_MSS_DENSITY_2T << 3);
-			break;
-	}
-
-//	rtw_write8(padapter, REG_AMPDU_MIN_SPACE, padapter->MgntInfo.MinSpaceCfg);
-	rtw_write8(padapter, REG_AMPDU_MIN_SPACE, MinSpaceCfg);
 }
 
 
@@ -1236,14 +1233,13 @@ static u32 rtl8188es_hal_init(PADAPTER padapter)
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
 	struct pwrctrl_priv		*pwrctrlpriv = adapter_to_pwrctl(padapter);
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
-	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
 	u8 is92C = IS_92C_SERIAL(pHalData->VersionID);
 	rt_rf_power_state	eRfPowerStateToSet;
 	u8 value8;
+	u8 cpwm_orig, cpwm_now, rpwm;
 	u16 value16;
 
 	u32 init_start_time = rtw_get_current_time();
-	u8 cpwm_orig, cpwm_now, rpwm;
 	u32 start_time;
 
 #ifdef DBG_HAL_INIT_PROFILING
@@ -1348,7 +1344,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 
 	if(rtw_read8(padapter, REG_MCUFWDL) == 0xc6) {
 #ifdef CONFIG_LPS_LCLK
-		_enter_pwrlock(&pwrpriv->lock);
+		_enter_pwrlock(&pwrctrlpriv->lock);
 		cpwm_orig = 0, rpwm = 0;
 		rtw_hal_get_hwreg(padapter, HW_VAR_CPWM, &cpwm_orig);
 
@@ -1383,7 +1379,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 				break;
 			}
 		} while (1);
-		_exit_pwrlock(&pwrpriv->lock);
+		_exit_pwrlock(&pwrctrlpriv->lock);
 		
 		hal_poweroff_8188es(padapter);
 #endif
@@ -1412,10 +1408,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PW_ON);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC01);
 	if (!pregistrypriv->wifi_spec) {
-		txpktbuf_bndy = TX_PAGE_BOUNDARY_88E;
+		txpktbuf_bndy = TX_PAGE_BOUNDARY_88E(padapter);
 	} else {
 		// for WMM
-		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY_88E;
+		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY_88E(padapter);
 	}
 	_InitQueueReservedPage(padapter);	
 	_InitQueuePriority(padapter);
@@ -1446,6 +1442,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 	padapter->bFWReady = _FALSE; //because no fw for test chip	
 	pHalData->fw_ractrl = _FALSE;
 #else
+
 	ret = rtl8188e_FirmwareDownload(padapter, _FALSE);
 
 	if (ret != _SUCCESS) {
@@ -1456,7 +1453,11 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 	} else {
 		RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("Initializepadapter8192CSdio(): Download Firmware Success!!\n"));
 		padapter->bFWReady = _TRUE;
+		#ifdef CONFIG_SFW_SUPPORTED
+		pHalData->fw_ractrl = IS_VENDOR_8188E_I_CUT_SERIES(padapter)?_TRUE:_FALSE;
+		#else
 		pHalData->fw_ractrl = _FALSE;
+		#endif
 	}
 #endif
 	}
@@ -1509,18 +1510,24 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_LLTT);
 		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init LLT Table!\n"));
 		goto exit;
 	}
+ 
+	//Enable TX Report & Tx Report Timer   
+	value8 = rtw_read8(padapter, REG_TX_RPT_CTRL);
+	rtw_write8(padapter,  REG_TX_RPT_CTRL, (value8|BIT1|BIT0));
 
 #if (RATE_ADAPTIVE_SUPPORT==1)
-	{//Enable TX Report
-		//Enable Tx Report Timer   
-		value8 = rtw_read8(padapter, REG_TX_RPT_CTRL);
-		rtw_write8(padapter,  REG_TX_RPT_CTRL, (value8|BIT1|BIT0));
+	if(!pHalData->fw_ractrl ){
 		//Set MAX RPT MACID
 		rtw_write8(padapter,  REG_TX_RPT_CTRL+1, 2);//FOR sta mode ,0: bc/mc ,1:AP
 		//Tx RPT Timer. Unit: 32us
 		rtw_write16(padapter, REG_TX_RPT_TIME, 0xCdf0);
 	}
+	else
 #endif	
+	{
+		//disable tx rpt
+		rtw_write8(padapter,  REG_TX_RPT_CTRL+1, 0);//FOR sta mode ,0: bc/mc ,1:AP
+	}
 
 #if 0
 	if(pHTInfo->bRDGEnable){
@@ -1803,12 +1810,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC31);
 	pHalData->SdioTxOQTMaxFreeSpace = pHalData->SdioTxOQTFreeSpace;
 
 
-	if(pregistrypriv->wifi_spec)
+	if(pregistrypriv->wifi_spec) {
 		rtw_write16(padapter,REG_FAST_EDCA_CTRL ,0);
-
-
-	//TODO:Setting HW_VAR_NAV_UPPER !!!!!!!!!!!!!!!!!!!!
-	//rtw_hal_set_hwreg(Adapter, HW_VAR_NAV_UPPER, ((pu1Byte)&NavUpper));
+		rtw_write8(padapter,REG_NAV_UPPER ,0x0);
+	}
 
 	if(IS_HARDWARE_TYPE_8188ES(padapter))
 	{
@@ -1818,15 +1823,17 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC31);
 
 	//pHalData->PreRpwmVal = PlatformEFSdioLocalCmd52Read1Byte(Adapter, SDIO_REG_HRPWM1)&0x80;
 
-
-	// enable Tx report.
-	rtw_write8(padapter,  REG_FWHW_TXQ_CTRL+1, 0x0F);
+	if(!pHalData->fw_ractrl ){
+		// enable Tx report.
+		rtw_write8(padapter,  REG_FWHW_TXQ_CTRL+1, 0x0F);
+		//tynli_test_tx_report.
+		rtw_write16(padapter, REG_TX_RPT_TIME, 0x3DF0);
+	}
 /*
 	// Suggested by SD1 pisa. Added by tynli. 2011.10.21.
 	PlatformEFIOWrite1Byte(Adapter, REG_EARLY_MODE_CONTROL+3, 0x01);
 
-*/	//tynli_test_tx_report.
-	rtw_write16(padapter, REG_TX_RPT_TIME, 0x3DF0);
+*/	
 	//RT_TRACE(COMP_INIT, DBG_TRACE, ("InitializeAdapter8188EUsb() <====\n"));
 
 	
@@ -1928,6 +1935,9 @@ static void rtl8188es_init_default_value(PADAPTER padapter)
 	pHalData = GET_HAL_DATA(padapter);
 	pwrctrlpriv = adapter_to_pwrctl(padapter);
 	pdmpriv = &pHalData->dmpriv;
+
+	rtl8188e_init_default_value(padapter);
+
 	padapter->registrypriv.wireless_mode = WIRELESS_11BG_24N;
 
 	//init default value
@@ -2015,34 +2025,6 @@ Hal_EfuseParsePIDVID_8188ES(
 //	RT_TRACE(COMP_INIT, DBG_LOUD, ("EEPROM PID = 0x%4x\n", pHalData->EEPROMPID));
 }
 
-static void Hal_GetPhyEfuseMACAddr_8188ES(PADAPTER padapter, u8* mac_addr) {
-	int i = 0;
-
-	rtw_efuse_map_read(padapter, EEPROM_MAC_ADDR_88ES, ETH_ALEN, mac_addr);
-
-	if (rtw_check_invalid_mac_address(mac_addr) == _TRUE) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
-		get_random_bytes(mac_addr, ETH_ALEN);
-		mac_addr[0] = 0x00;
-		mac_addr[1] = 0xe0;
-		mac_addr[2] = 0x4c;
-#else
-		mac_addr[0] = 0x00;
-		mac_addr[1] = 0xe0;
-		mac_addr[2] = 0x4c;
-		mac_addr[3] = (u8)(curtime & 0xff) ;
-		mac_addr[4] = (u8)((curtime>>8) & 0xff) ;
-		mac_addr[5] = (u8)((curtime>>16) & 0xff) ;
-#endif
-                DBG_871X("MAC Address from phy efuse error, assign random MAC !!!\n");
-	}
-
-	DBG_871X("%s: Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
-			__func__, mac_addr[0], mac_addr[1], mac_addr[2],
-			mac_addr[3], mac_addr[4], mac_addr[5]);
-}
-
-
 static void
 Hal_EfuseParseMACAddr_8188ES(
 	IN	PADAPTER		padapter,
@@ -2091,185 +2073,39 @@ Hal_EfuseParseMACAddr_8188ES(
 		  pEEPROM->mac_addr[4], pEEPROM->mac_addr[5]);
 }
 
-
-static u32 Hal_readPGDataFromConfigFile(
-	PADAPTER	padapter,
-	struct file *fp)
-{
-	u32 i;
-	mm_segment_t fs;
-	u8 temp[3];
-	loff_t pos = 0;
-	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
-	u8	*PROMContent = pEEPROM->efuse_eeprom_data;
-
-	temp[2] = 0; // add end of string '\0'
-
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	for (i = 0 ; i < HWSET_MAX_SIZE_88E ; i++) {
-		vfs_read(fp, temp, 2, &pos);
-		PROMContent[i] = simple_strtoul(temp, NULL, 16);
-		if ((i % EFUSE_FILE_COLUMN_NUM) == (EFUSE_FILE_COLUMN_NUM - 1)) {
-			//Filter the lates space char.
-			vfs_read(fp, temp, 1, &pos);
-			if (strchr(temp, ' ') == NULL) {
-				pos--;
-				vfs_read(fp, temp, 2, &pos);
-			}
-		} else {
-			pos += 1; // Filter the space character
-		}
-	}
-
-	set_fs(fs);
-	pEEPROM->bloadfile_fail_flag = _FALSE;
-
-#ifdef CONFIG_DEBUG
-	DBG_871X("Efuse configure file:\n");
-	for (i=0; i<HWSET_MAX_SIZE_88E; i++)
-	{
-		if (i % 16 == 0)
-			printk("\n");
-
-		printk("%02X ", PROMContent[i]);
-	}
-	printk("\n");
-#endif
-
-	return _SUCCESS;
-}
-
-static void
-Hal_ReadMACAddrFromFile_8188ES(
-	PADAPTER		padapter,
-	struct file *fp)
-{
-	u32 i;
-	mm_segment_t fs;
-	u8 source_addr[18];
-	loff_t pos = 0;
-	u32	curtime = rtw_get_current_time();
-	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
-	u8 *head, *end;
-
-	_rtw_memset(source_addr, 0, 18);
-	_rtw_memset(pEEPROM->mac_addr, 0, ETH_ALEN);
-
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-
-	DBG_871X("wifi mac address:\n");
-	vfs_read(fp, source_addr, 18, &pos);
-	source_addr[17] = ':';
-
-	head = end = source_addr;
-	for (i=0; i<ETH_ALEN; i++) {
-		while (end && (*end != ':') )
-			end++;
-
-		if (end && (*end == ':') )
-			*end = '\0';
-
-		pEEPROM->mac_addr[i] = simple_strtoul(head, NULL, 16 );
-
-		if (end) {
-			end++;
-			head = end;
-		}
-	}
-
-	set_fs(fs);
-	pEEPROM->bloadmac_fail_flag = _FALSE;
-
-	if (rtw_check_invalid_mac_address(pEEPROM->mac_addr) == _TRUE) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
-		get_random_bytes(pEEPROM->mac_addr, ETH_ALEN);
-		pEEPROM->mac_addr[0] = 0x00;
-		pEEPROM->mac_addr[1] = 0xe0;
-		pEEPROM->mac_addr[2] = 0x4c;
-#else
-		pEEPROM->mac_addr[0] = 0x00;
-		pEEPROM->mac_addr[1] = 0xe0;
-		pEEPROM->mac_addr[2] = 0x4c;
-		pEEPROM->mac_addr[3] = (u8)(curtime & 0xff) ;
-		pEEPROM->mac_addr[4] = (u8)((curtime>>8) & 0xff) ;
-		pEEPROM->mac_addr[5] = (u8)((curtime>>16) & 0xff) ;
-#endif
-                DBG_871X("MAC Address from wifimac error is invalid, assign random MAC !!!\n");
-	}
-
-	DBG_871X("%s: Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
-			__func__, pEEPROM->mac_addr[0], pEEPROM->mac_addr[1],
-			pEEPROM->mac_addr[2], pEEPROM->mac_addr[3],
-			pEEPROM->mac_addr[4], pEEPROM->mac_addr[5]);
-}
-
-static int check_phy_efuse_tx_power_info_valid(PADAPTER padapter) {
-	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
-	u8* pContent = pEEPROM->efuse_eeprom_data;
-	int index = 0;
-
-	for (index = 0 ; index < 12 ; index++) {
-		if (pContent[EEPROM_TX_PWR_INX_88E+index] == 0xFF) {
-			return _FALSE;
-		} else {
-			DBG_871X("0x%02x ,", pContent[EEPROM_TX_PWR_INX_88E+index]);
-		}
-	}
-	DBG_871X("\n");
-	return _TRUE;
-}
-
-static int check_phy_efuse_macaddr_info_valid(PADAPTER padapter) {
-
-	u8 val = 0;
-
-	rtw_efuse_map_read(padapter, EEPROM_MAC_ADDR_88ES, 1, &val);
-
-	if (val == 0xFF) {
-		return _FALSE;
-	} else {
-		DBG_871X("phy efuse with valid MAC addr\n");
-		return _TRUE;
-	}
-}
-
 static VOID
 readAdapterInfo_8188ES(
 	IN PADAPTER			padapter
 	)
 {
 	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
+
+#ifdef CONFIG_EFUSE_CONFIG_FILE
 	struct file *fp = NULL;
+#endif
 
 	/* parse the eeprom/efuse content */
 	Hal_EfuseParseIDCode88E(padapter, pEEPROM->efuse_eeprom_data);
 	Hal_EfuseParsePIDVID_8188ES(padapter, pEEPROM->efuse_eeprom_data, pEEPROM->bautoload_fail_flag);
 
-#if 1
+#ifdef CONFIG_EFUSE_CONFIG_FILE
 	if (check_phy_efuse_macaddr_info_valid(padapter) == _TRUE) {
 		DBG_871X("using phy efuse mac\n");
-		Hal_GetPhyEfuseMACAddr_8188ES(padapter, pEEPROM->mac_addr);
+		Hal_GetPhyEfuseMACAddr(padapter, pEEPROM->mac_addr);
 	} else {
 		fp = filp_open(WIFIMAC_PATH, O_RDONLY, 0);
 		if (fp == NULL || IS_ERR(fp)) {
 			DBG_871X("wifimac does not exist!!\n");
-			Hal_GetPhyEfuseMACAddr_8188ES(padapter, pEEPROM->mac_addr);
+			Hal_GetPhyEfuseMACAddr(padapter, pEEPROM->mac_addr);
 		} else {
-			Hal_ReadMACAddrFromFile_8188ES(padapter, fp);
+			Hal_ReadMACAddrFromFile(padapter, fp);
 			filp_close(fp, NULL);
 		}
 	}
-#else
-#ifdef CONFIG_EFUSE_CONFIG_FILE
-	Hal_ReadMACAddrFromFile_8188ES(padapter);
 #else //CONFIG_EFUSE_CONFIG_FILE
 	Hal_EfuseParseMACAddr_8188ES(padapter, pEEPROM->efuse_eeprom_data, pEEPROM->bautoload_fail_flag);
 #endif //CONFIG_EFUSE_CONFIG_FILE
-#endif
-	
+
 	Hal_ReadPowerSavingMode88E(padapter, pEEPROM->efuse_eeprom_data, pEEPROM->bautoload_fail_flag);
 	Hal_ReadTxPowerInfo88E(padapter, pEEPROM->efuse_eeprom_data, pEEPROM->bautoload_fail_flag);
 	Hal_EfuseParseEEPROMVer88E(padapter, pEEPROM->efuse_eeprom_data, pEEPROM->bautoload_fail_flag);
@@ -2297,7 +2133,9 @@ static void _ReadPROMContent(
 {
 	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);
 	u8			eeValue;
+#ifdef CONFIG_EFUSE_CONFIG_FILE
 	struct file *fp;
+#endif //CONFIG_EFUSE_CONFIG_FILE	
 
 	/* check system boot selection */
 	eeValue = rtw_read8(padapter, REG_9346CR);
@@ -2312,8 +2150,10 @@ static void _ReadPROMContent(
 //	pHalData->EEType = IS_BOOT_FROM_EEPROM(Adapter) ? EEPROM_93C46 : EEPROM_BOOT_EFUSE;
 
 
-#if 1
+
 	Hal_InitPGData88E(padapter);
+
+#ifdef CONFIG_EFUSE_CONFIG_FILE
 	if (check_phy_efuse_tx_power_info_valid(padapter) == _FALSE) {
 		fp = filp_open(EFUSE_MAP_PATH, O_RDONLY, 0);
 		if (fp == NULL || IS_ERR(fp)) {
@@ -2323,19 +2163,14 @@ static void _ReadPROMContent(
 			filp_close(fp, NULL);
 		}
 	}
-#else
-#ifdef CONFIG_EFUSE_CONFIG_FILE
-	Hal_readPGDataFromConfigFile(padapter);
-#else //CONFIG_EFUSE_CONFIG_FILE
-	Hal_InitPGData88E(padapter);
 #endif //CONFIG_EFUSE_CONFIG_FILE	
-#endif
+
 	readAdapterInfo_8188ES(padapter);
 }
 
 static VOID
 _InitOtherVariable(
-	IN PADAPTER 		Adapter
+	IN PADAPTER		Adapter
 	)
 {
 	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
@@ -2401,41 +2236,10 @@ static void ReadAdapterInfo8188ES(PADAPTER padapter)
 	_ReadAdapterInfo8188ES(padapter);
 }
 
-static void ResumeTxBeacon(PADAPTER padapter)
-{
-	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);
-
-	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
-	// which should be read from register to a global variable.
-
-	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("+ResumeTxBeacon\n"));
-
-	rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
-	pHalData->RegFwHwTxQCtrl |= BIT6;
-	rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0xff);
-	pHalData->RegReg542 |= BIT0;
-	rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
-}
-
-static void StopTxBeacon(PADAPTER padapter)
-{
-	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);
-
-	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
-	// which should be read from register to a global variable.
-
-	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("+StopTxBeacon\n"));
-
-	rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
-	pHalData->RegFwHwTxQCtrl &= (~BIT6);
-	rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0x64);
-	pHalData->RegReg542 &= ~(BIT0);
-	rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
 
-	CheckFwRsvdPageContent(padapter);  // 2010.06.23. Added by tynli.
-}
 
 // todo static 
+#if 0
 void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
 {
 	u8	val8;
@@ -2666,1327 +2470,105 @@ void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
 	}
 
 }
+#endif
 
-static void hw_var_set_macaddr(PADAPTER Adapter, u8 variable, u8* val)
+static void SetHwReg8188ES(PADAPTER Adapter, u8 variable, u8* val)
 {
-	u8 idx = 0;
-	u32 reg_macid;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	
+_func_enter_;
 
-#ifdef CONFIG_CONCURRENT_MODE
-	if(Adapter->iface_type == IFACE_PORT1)
-	{
-		reg_macid = REG_MACID1;
-	}
-	else
+	switch(variable)
+	{			
+		case HW_VAR_RXDMA_AGG_PG_TH:
+		break;
+		case HW_VAR_SET_RPWM:
+#ifdef CONFIG_LPS_LCLK
+			{
+				u8	ps_state = *((u8 *)val);
+				//rpwm value only use BIT0(clock bit) ,BIT6(Ack bit), and BIT7(Toggle bit) for 88e.
+				//BIT0 value - 1: 32k, 0:40MHz.
+				//BIT6 value - 1: report cpwm value after success set, 0:do not report.
+				//BIT7 value - Toggle bit change.
+				//modify by Thomas. 2012/4/2.
+				ps_state = ps_state & 0xC1;
+
+#ifdef CONFIG_EXT_CLK //for sprd
+				if(ps_state&BIT(6)) // want to leave 32k
+				{
+					//enable ext clock req before leave LPS-32K
+					//DBG_871X("enable ext clock req before leaving LPS-32K\n");					
+					EnableGpio5ClockReq(Adapter, _FALSE, 1);
+				}
+#endif //CONFIG_EXT_CLK
+
+				//DBG_871X("##### Change RPWM value to = %x for switch clk #####\n",ps_state);
+				rtw_write8(Adapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1, ps_state);
+			}
 #endif
-	{
-		reg_macid = REG_MACID;
+			break;
+		default:
+			SetHwReg8188E(Adapter, variable, val);
+			break;
 	}
 
-	for(idx = 0 ; idx < 6; idx++)
-	{
-		rtw_write8(GET_PRIMARY_ADAPTER(Adapter), (reg_macid+idx), val[idx]);
-	}
+_func_exit_;
 }
 
-static void hw_var_set_bssid(PADAPTER Adapter, u8 variable, u8* val)
+static void GetHwReg8188ES(PADAPTER padapter, u8 variable, u8 *val)
 {
-	u8	idx = 0;
-	u32 reg_bssid;
-
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if(Adapter->iface_type == IFACE_PORT1)
-	{
-		reg_bssid = REG_BSSID1;
-	}
-	else
-#endif
-	{
-		reg_bssid = REG_BSSID;
-	}
-
-printk("hw_var_set_bssid   reg=%x \n", reg_bssid);
+	PHAL_DATA_TYPE 	pHalData= GET_HAL_DATA(padapter);	
+_func_enter_;
 
-	for(idx = 0 ; idx < 6; idx++)
+	switch (variable)
 	{
-		rtw_write8(Adapter, (reg_bssid+idx), val[idx]);
+		case HW_VAR_CPWM:
+			*val = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HCPWM1);
+			break;
+		default:
+			GetHwReg8188E(padapter, variable, val);
+			break;
 	}
 
+_func_exit_;
 }
 
-static void hw_var_set_bcn_func(PADAPTER Adapter, u8 variable, u8* val)
+//
+//	Description:
+//		Query setting of specified variable.
+//
+u8
+GetHalDefVar8188ESDIO(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+	)
 {
-	u32 bcn_ctrl_reg;
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
+	u8			bResult = _SUCCESS;
 
-#ifdef CONFIG_CONCURRENT_MODE
-	if(Adapter->iface_type == IFACE_PORT1)
+	switch(eVariable)
 	{
-		bcn_ctrl_reg = REG_BCN_CTRL_1;
-	}	
-	else
-#endif		
-	{		
-		bcn_ctrl_reg = REG_BCN_CTRL;
-	}
+		case HW_VAR_MAX_RX_AMPDU_FACTOR:
+			*(( u32*)pValue) = MAX_AMPDU_FACTOR_16K;
+			break;
 
-	if(*((u8 *)val))
-	{
-		rtw_write8(Adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
-	}
-	else
-	{
-		rtw_write8(Adapter, bcn_ctrl_reg, rtw_read8(Adapter, bcn_ctrl_reg)&(~(EN_BCN_FUNCTION | EN_TXBCN_RPT)));
+		case HAL_DEF_TX_LDPC:
+		case HAL_DEF_RX_LDPC:
+			*((u8 *)pValue) = _FALSE;
+			break;
+		case HAL_DEF_TX_STBC:
+			*((u8 *)pValue) = 0;
+			break;
+		case HAL_DEF_RX_STBC:
+			*((u8 *)pValue) = 1;
+			break;
+		default:
+			bResult = GetHalDefVar8188E(Adapter, eVariable, pValue);
+			break;
 	}
-	
 
-}
-
-static void hw_var_set_correct_tsf(PADAPTER Adapter, u8 variable, u8* val)
-{
-#ifdef CONFIG_CONCURRENT_MODE
-	u64	tsf;
-	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
-
-	//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
-	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
-
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-	{				
-		//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
-		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
-		StopTxBeacon(Adapter);
-	}
-
-	if(Adapter->iface_type == IFACE_PORT1)
-	{
-		//disable related TSF function
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-							
-		rtw_write32(Adapter, REG_TSFTR1, tsf);
-		rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
-		//enable related TSF function
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
-		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
-		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
-		) { 
-			//disable related TSF function
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
-
-			rtw_write32(Adapter, REG_TSFTR, tsf);
-			rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
-
-			//enable related TSF function
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
-#ifdef CONFIG_TSF_RESET_OFFLOAD
-		// Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue!
-			if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
-				DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
-					__FUNCTION__, __LINE__);
-
-#endif	// CONFIG_TSF_RESET_OFFLOAD	
-		}		
-	
-	}
-	else
-	{
-		//disable related TSF function
-		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
-							
-		rtw_write32(Adapter, REG_TSFTR, tsf);
-		rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
-
-		//enable related TSF function
-		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));		
-		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
-		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
-		) { 
-			//disable related TSF function
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-
-			rtw_write32(Adapter, REG_TSFTR1, tsf);
-			rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
-
-			//enable related TSF function
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
-#ifdef CONFIG_TSF_RESET_OFFLOAD
-		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
-			if (reset_tsf(Adapter, IFACE_PORT1) == _FALSE)
-				DBG_871X("ERROR! %s()-%d: Reset port1 TSF fail\n",
-					__FUNCTION__, __LINE__);
-#endif	// CONFIG_TSF_RESET_OFFLOAD
-		}		
-	}
-				
-							
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-	{
-		//pHalData->RegTxPause  &= (~STOP_BCNQ);
-		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
-		ResumeTxBeacon(Adapter);
-	}
-#endif
-}
-
-static void hw_var_set_mlme_disconnect(PADAPTER Adapter, u8 variable, u8* val)
-{
-#ifdef CONFIG_CONCURRENT_MODE
-	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
-			
-				
-	if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))	
-		rtw_write16(Adapter, REG_RXFLTMAP2, 0x00);
-	
-
-	if(Adapter->iface_type == IFACE_PORT1)
-	{
-		//reset TSF1
-		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
-
-		//disable update TSF1
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
-
-		// disable Port1's beacon function
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-	}
-	else
-	{
-		//reset TSF
-		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
-
-		//disable update TSF
-		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
-	}
-#endif
-}
-
-static void hw_var_set_mlme_sitesurvey(PADAPTER Adapter, u8 variable, u8* val)
-{	
-#ifdef CONFIG_CONCURRENT_MODE	
-	//HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
-
-	struct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
-
-	if(*((u8 *)val))//under sitesurvey
-	{
-		//config RCR to receive different BSSID & not to receive data frame
-		u32 v = rtw_read32(Adapter, REG_RCR);
-		v &= ~(RCR_CBSSID_BCN);
-		rtw_write32(Adapter, REG_RCR, v);
-
-		//disable update TSF
-		if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
-		{
-			if(Adapter->iface_type == IFACE_PORT1)
-			{
-				rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
-			}
-			else
-			{
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
-			}				
-		}
-				
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))		
-		{
-			StopTxBeacon(Adapter);
-		}		
-				
-	}
-	else//sitesurvey done
-	{
-		//enable to rx data frame
-		//write32(Adapter, REG_RCR, read32(padapter, REG_RCR)|RCR_ADF);
-		rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-
-		//enable update TSF
-		if(Adapter->iface_type == IFACE_PORT1)
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
-		else
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-
-		rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);
-
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
-		{
-			ResumeTxBeacon(Adapter);			
-		}
-					
-	}
-#endif			
-}
-
-static void hw_var_set_mlme_join(PADAPTER Adapter, u8 variable, u8* val)
-{
-#ifdef CONFIG_CONCURRENT_MODE
-	u8	RetryLimit = 0x30;
-	u8	type = *((u8 *)val);
-	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
-	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
-
-	if(type == 0) // prepare to join
-	{		
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))		
-		{
-			StopTxBeacon(Adapter);
-		}
-	
-		//enable to rx data frame.Accept all data frame
-		//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
-		rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);
-		else
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
-
-		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
-		{
-			RetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;
-		}
-		else // Ad-hoc Mode
-		{
-			RetryLimit = 0x7;
-		}
-	}
-	else if(type == 1) //joinbss_event call back when join res < 0
-	{		
-		if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))		
-			rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
-
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
-		{
-			ResumeTxBeacon(Adapter);			
-			
-			//reset TSF 1/2 after ResumeTxBeacon
-			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));	
-			
-		}
-	}
-	else if(type == 2) //sta add event call back
-	{
-	 
-		//enable update TSF
-		if(Adapter->iface_type == IFACE_PORT1)
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
-		else
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-		 
-	
-		if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
-		{
-			//fixed beacon issue for 8191su...........
-			rtw_write8(Adapter,0x542 ,0x02);
-			RetryLimit = 0x7;
-		}
-
-
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
-		{
-			ResumeTxBeacon(Adapter);			
-			
-			//reset TSF 1/2 after ResumeTxBeacon
-			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));
-		}
-		
-	}
-
-	rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-	
-#endif
-}
-static void SetHwReg8188ES(PADAPTER Adapter, u8 variable, u8* val)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	DM_ODM_T 		*podmpriv = &pHalData->odmpriv;
-_func_enter_;
-
-	switch(variable)
-	{
-		case HW_VAR_MEDIA_STATUS:
-			{
-				u8 val8;
-
-				val8 = rtw_read8(Adapter, MSR)&0x0c;
-				val8 |= *((u8 *)val);
-				rtw_write8(Adapter, MSR, val8);
-			}
-			break;
-		case HW_VAR_MEDIA_STATUS1:
-			{
-				u8 val8;
-
-				val8 = rtw_read8(Adapter, MSR)&0x03;
-				val8 |= *((u8 *)val) <<2;
-				rtw_write8(Adapter, MSR, val8);
-			}
-			break;
-		case HW_VAR_SET_OPMODE:
-			hw_var_set_opmode(Adapter, variable, val);
-			break;
-		case HW_VAR_MAC_ADDR:
-			hw_var_set_macaddr(Adapter, variable, val);
-			break;
-		case HW_VAR_BSSID:
-			hw_var_set_bssid(Adapter, variable, val);
-			break;
-		case HW_VAR_TXPAUSE:
-			rtw_write8(Adapter, REG_TXPAUSE, *((u8 *)val));
-			break;
-		case HW_VAR_BCN_FUNC:
-			hw_var_set_bcn_func(Adapter, variable, val);
-			break;
-		case HW_VAR_CORRECT_TSF:
-#ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_correct_tsf(Adapter, variable, val);
-#else
-			{
-				u64	tsf;
-				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
-				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-				//f = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
-				tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) - 1024; //us
-
-				if (((pmlmeinfo->state & 0x03) == WIFI_FW_ADHOC_STATE) ||
-					((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE))
-				{
-					//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
-					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
-					StopTxBeacon(Adapter);
-				}
-
-				// disable related TSF function
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
-
-				rtw_write32(Adapter, REG_TSFTR, tsf);
-				rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
-
-				// enable related TSF function
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
-
-				if (((pmlmeinfo->state & 0x03) == WIFI_FW_ADHOC_STATE) ||
-					((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE))
-				{
-					//pHalData->RegTxPause  &= (~STOP_BCNQ);
-					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
-					ResumeTxBeacon(Adapter);
-				}
-			}
-#endif
-			break;
-		case HW_VAR_CHECK_BSSID:
-			if(*((u8 *)val))
-			{ 
-				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN); 
-			}
-			else
-			{
-				u32	val32;
-
-				val32 = rtw_read32(Adapter, REG_RCR);
- 
-				val32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);
-
-				rtw_write32(Adapter, REG_RCR, val32);
-			}
-			break;
-		case HW_VAR_MLME_DISCONNECT:
-#ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_mlme_disconnect(Adapter, variable, val);
-#else
-			{
-				//Set RCR to not to receive data frame when NO LINK state
-				//rtw_write32(Adapter, REG_RCR, rtw_read32(padapter, REG_RCR) & ~RCR_ADF);
-				//reject all data frames
-				rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
-
-				//reset TSF
-				rtw_write8(Adapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
-
-				//disable update TSF
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));	
-			}
-#endif
-			break;
-		case HW_VAR_MLME_SITESURVEY:
-#ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_mlme_sitesurvey(Adapter, variable,  val);
-#else
-			if(*((u8 *)val))//under sitesurvey
-			{
-				//config RCR to receive different BSSID & not to receive data frame
-				u32 v = rtw_read32(Adapter, REG_RCR);
-				v &= ~(RCR_CBSSID_BCN);
-				rtw_write32(Adapter, REG_RCR, v);
-				//reject all data frame
-				rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
-
-				//disable update TSF
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
-			}
-			else//sitesurvey done
-			{
-				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
-				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-				if ((is_client_associated_to_ap(Adapter) == _TRUE) ||
-					((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) )
-				{
-					//enable to rx data frame
-					//rtw_write32(Adapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
-					rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-
-					//enable update TSF
-					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-				}
-				else if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
-				{
-					//rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_ADF);
-					rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-
-					//enable update TSF
-					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-				}
-
-				if(Adapter->in_cta_test)
-				{
-					if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
-					{
-						rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);
-					}
-					else
-					{
-						u32 v = rtw_read32(Adapter, REG_RCR);
-						v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
-						rtw_write32(Adapter, REG_RCR, v);
-					}
-				}
-				else
-				{
-					rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);
-				}
-			}
-#endif
-			break;
-		case HW_VAR_MLME_JOIN:
-#ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_mlme_join(Adapter, variable,  val);
-#else
-			{
-				u8	RetryLimit = 0x30;
-				u8	type = *((u8 *)val);
-				struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
-				EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
-				
-				if(type == 0) // prepare to join
-				{
-					//enable to rx data frame.Accept all data frame
-					//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
-					rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-					if(Adapter->in_cta_test)
-					{
-						u32 v = rtw_read32(Adapter, REG_RCR);
-						v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
-						rtw_write32(Adapter, REG_RCR, v);
-					}
-					else
-					{
-						rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
-					}
-					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
-					{
-						RetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;
-					}
-					else // Ad-hoc Mode
-					{
-						RetryLimit = 0x7;
-					}
-				}
-				else if(type == 1) //joinbss_event call back when join res < 0
-				{
-					rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
-				}
-				else if(type == 2) //sta add event call back
-				{
-					// enable update TSF
-					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-
-					if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
-					{
-						RetryLimit = 0x7;
-					}
-				}
-
-				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-			}
-#endif
-			break;
-		case HW_VAR_ON_RCR_AM:
-                        rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_AM);
-                        DBG_871X("%s, %d, RCR= %x \n", __FUNCTION__,__LINE__, rtw_read32(Adapter, REG_RCR));
-                        break;
-              case HW_VAR_OFF_RCR_AM:
-                        rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)& (~RCR_AM));
-                        DBG_871X("%s, %d, RCR= %x \n", __FUNCTION__,__LINE__, rtw_read32(Adapter, REG_RCR));
-                        break;
-		case HW_VAR_BEACON_INTERVAL:
-			rtw_write16(Adapter, REG_BCN_INTERVAL, *((u16 *)val));
-
-#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-			{
-				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
-				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-				u16 bcn_interval = 	*((u16 *)val);
-				if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE){
-					DBG_8192C("%s==> bcn_interval:%d, eraly_int:%d \n",__FUNCTION__,bcn_interval,bcn_interval>>1);
-					rtw_write8(Adapter, REG_DRVERLYINT, bcn_interval>>1);// 50ms for sdio 
-				}
-				else{
-					
-				}
-			}
-#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-
-			break;
-		case HW_VAR_SLOT_TIME:
-			{
-				rtw_write8(Adapter, REG_SLOT, val[0]);
-			}
-			break;
-		case HW_VAR_ACK_PREAMBLE:
-			{
-				u8	regTmp;
-				u8	bShortPreamble = *( (PBOOLEAN)val );
-				// Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily)
-				regTmp = (pHalData->nCur40MhzPrimeSC)<<5;
-				rtw_write8(Adapter, REG_RRSR+2, regTmp);
-
-				regTmp = rtw_read8(Adapter,REG_WMAC_TRXPTCL_CTL+2);
-				if(bShortPreamble)		
-					regTmp |= BIT1;
-				else
-					regTmp &= (~BIT1);
-				rtw_write8(Adapter,REG_WMAC_TRXPTCL_CTL+2,regTmp);				
-			}
-			break;
-		case HW_VAR_CAM_EMPTY_ENTRY:
-			{
-				u8	ucIndex = *((u8 *)val);
-				u8	i;
-				u32	ulCommand=0;
-				u32	ulContent=0;
-				u32	ulEncAlgo=CAM_AES;
-
-				for(i=0;i<CAM_CONTENT_COUNT;i++)
-				{
-					// filled id in CAM config 2 byte
-					if( i == 0)
-					{
-						ulContent |=(ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);
-						//ulContent |= CAM_VALID;
-					}
-					else
-					{
-						ulContent = 0;
-					}
-					// polling bit, and No Write enable, and address
-					ulCommand= CAM_CONTENT_COUNT*ucIndex+i;
-					ulCommand= ulCommand | CAM_POLLINIG|CAM_WRITE;
-					// write content 0 is equall to mark invalid
-					rtw_write32(Adapter, WCAMI, ulContent);  //delay_ms(40);
-					//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_empty_entry(): WRITE A4: %lx \n",ulContent));
-					rtw_write32(Adapter, RWCAM, ulCommand);  //delay_ms(40);
-					//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_empty_entry(): WRITE A0: %lx \n",ulCommand));
-				}
-			}
-			break;
-		case HW_VAR_CAM_INVALID_ALL:
-			rtw_write32(Adapter, RWCAM, BIT(31)|BIT(30));
-			break;
-		case HW_VAR_CAM_WRITE:
-			{
-				u32	cmd;
-				u32	*cam_val = (u32 *)val;
-				rtw_write32(Adapter, WCAMI, cam_val[0]);
-
-				cmd = CAM_POLLINIG | CAM_WRITE | cam_val[1];
-				rtw_write32(Adapter, RWCAM, cmd);
-			}
-			break;
-		case HW_VAR_AC_PARAM_VO:
-			rtw_write32(Adapter, REG_EDCA_VO_PARAM, ((u32 *)(val))[0]);
-			break;
-		case HW_VAR_AC_PARAM_VI:
-			rtw_write32(Adapter, REG_EDCA_VI_PARAM, ((u32 *)(val))[0]);
-			break;
-		case HW_VAR_AC_PARAM_BE:
-			pHalData->AcParam_BE = ((u32 *)(val))[0];
-			rtw_write32(Adapter, REG_EDCA_BE_PARAM, ((u32 *)(val))[0]);
-			break;
-		case HW_VAR_AC_PARAM_BK:
-			rtw_write32(Adapter, REG_EDCA_BK_PARAM, ((u32 *)(val))[0]);
-			break;
-		case HW_VAR_AMPDU_MIN_SPACE:
-			{
-				u8	MinSpacingToSet;
-				u8	SecMinSpace;
-
-				MinSpacingToSet = *((u8 *)val);
-				if(MinSpacingToSet <= 7)
-				{
-					switch(Adapter->securitypriv.dot11PrivacyAlgrthm)
-					{
-						case _NO_PRIVACY_:
-						case _AES_:
-							SecMinSpace = 0;
-							break;
-
-						case _WEP40_:
-						case _WEP104_:
-						case _TKIP_:
-						case _TKIP_WTMIC_:
-							SecMinSpace = 6;
-							break;
-						default:
-							SecMinSpace = 7;
-							break;
-					}
-
-					if(MinSpacingToSet < SecMinSpace){
-						MinSpacingToSet = SecMinSpace;
-					}
-
-					//RT_TRACE(COMP_MLME, DBG_LOUD, ("Set HW_VAR_AMPDU_MIN_SPACE: %#x\n", Adapter->MgntInfo.MinSpaceCfg));
-					rtw_write8(Adapter, REG_AMPDU_MIN_SPACE, (rtw_read8(Adapter, REG_AMPDU_MIN_SPACE) & 0xf8) | MinSpacingToSet);
-				}
-			}
-			break;
-		case HW_VAR_AMPDU_FACTOR:
-			{
-				u8	RegToSet_Normal[4]={0x41,0xa8,0x72, 0xb9};
-				u8	RegToSet_BT[4]={0x31,0x74,0x42, 0x97};
-				u8	FactorToSet;
-				u8	*pRegToSet;
-				u8	index = 0;
-
-#ifdef CONFIG_BT_COEXIST
-				if(	(pHalData->bt_coexist.BT_Coexist) &&
-					(pHalData->bt_coexist.BT_CoexistType == BT_CSR_BC4) )
-					pRegToSet = RegToSet_BT; // 0x97427431;
-				else
-#endif
-					pRegToSet = RegToSet_Normal; // 0xb972a841;
-
-				FactorToSet = *((u8 *)val);
-				if(FactorToSet <= 3)
-				{
-					FactorToSet = (1<<(FactorToSet + 2));
-					if(FactorToSet>0xf)
-						FactorToSet = 0xf;
-
-					for(index=0; index<4; index++)
-					{
-						if((pRegToSet[index] & 0xf0) > (FactorToSet<<4))
-							pRegToSet[index] = (pRegToSet[index] & 0x0f) | (FactorToSet<<4);
-
-						if((pRegToSet[index] & 0x0f) > FactorToSet)
-							pRegToSet[index] = (pRegToSet[index] & 0xf0) | (FactorToSet);
-
-						rtw_write8(Adapter, (REG_AGGLEN_LMT+index), pRegToSet[index]);
-					}
-
-					//RT_TRACE(COMP_MLME, DBG_LOUD, ("Set HW_VAR_AMPDU_FACTOR: %#x\n", FactorToSet));
-				}
-			}
-			break;
-		case HW_VAR_RXDMA_AGG_PG_TH:
-			rtw_write8(Adapter, REG_RXDMA_AGG_PG_TH, *((u8 *)val));
-			break;
-		case HW_VAR_SET_RPWM:
-#ifdef CONFIG_LPS_LCLK
-			{
-				u8	ps_state = *((u8 *)val);
-				//rpwm value only use BIT0(clock bit) ,BIT6(Ack bit), and BIT7(Toggle bit) for 88e.
-				//BIT0 value - 1: 32k, 0:40MHz.
-				//BIT6 value - 1: report cpwm value after success set, 0:do not report.
-				//BIT7 value - Toggle bit change.
-				//modify by Thomas. 2012/4/2.
-				ps_state = ps_state & 0xC1;
-
-#ifdef CONFIG_EXT_CLK //for sprd
-				if(ps_state&BIT(6)) // want to leave 32k
-				{
-					//enable ext clock req before leave LPS-32K
-					//DBG_871X("enable ext clock req before leaving LPS-32K\n");					
-					EnableGpio5ClockReq(Adapter, _FALSE, 1);
-				}
-#endif //CONFIG_EXT_CLK
-
-				//DBG_871X("##### Change RPWM value to = %x for switch clk #####\n",ps_state);
-				rtw_write8(Adapter, SDIO_LOCAL_BASE|SDIO_REG_HRPWM1, ps_state);
-			}
-#endif
-			break;
-		case HW_VAR_H2C_FW_PWRMODE:
-			{
-				u8	psmode = (*(u8 *)val);
-
-				// Forece leave RF low power mode for 1T1R to prevent conficting setting in Fw power
-				// saving sequence. 2010.06.07. Added by tynli. Suggested by SD3 yschang.
-				if( (psmode != PS_MODE_ACTIVE) && (!IS_92C_SERIAL(pHalData->VersionID)))
-				{
-					ODM_RF_Saving(podmpriv, _TRUE);
-				}
-				rtl8188e_set_FwPwrMode_cmd(Adapter, psmode);
-			}
-			break;
-		case HW_VAR_H2C_FW_JOINBSSRPT:
-			{
-				u8	mstatus = (*(u8 *)val);
-				rtl8188e_set_FwJoinBssReport_cmd(Adapter, mstatus);
-			}
-			break;
-#ifdef CONFIG_P2P_PS
-		case HW_VAR_H2C_FW_P2P_PS_OFFLOAD:
-			{
-				u8	p2p_ps_state = (*(u8 *)val);
-				rtl8188e_set_p2p_ps_offload_cmd(Adapter, p2p_ps_state);
-			}
-			break;
-#endif // CONFIG_P2P_PS
-		case HW_VAR_INITIAL_GAIN:
-			{				
-				DIG_T	*pDigTable = &podmpriv->DM_DigTable;					
-				u32 		rx_gain = ((u32 *)(val))[0];
-		
-				if(rx_gain == 0xff){//restore rx gain					
-					ODM_Write_DIG(podmpriv,pDigTable->BackupIGValue);
-				}
-				else{
-					pDigTable->BackupIGValue = pDigTable->CurIGValue;
-					ODM_Write_DIG(podmpriv,rx_gain);
-				}
-			}		
-			break;
-		case HW_VAR_TRIGGER_GPIO_0:
-//			rtl8192cu_trigger_gpio_0(Adapter);
-			break;
-#ifdef CONFIG_BT_COEXIST
-		case HW_VAR_BT_SET_COEXIST:
-			{
-				u8	bStart = (*(u8 *)val);
-				rtl8192c_set_dm_bt_coexist(Adapter, bStart);
-			}
-			break;
-		case HW_VAR_BT_ISSUE_DELBA:
-			{
-				u8	dir = (*(u8 *)val);
-				rtl8192c_issue_delete_ba(Adapter, dir);
-			}
-			break;
-#endif
-#if (RATE_ADAPTIVE_SUPPORT==1)
-		case HW_VAR_RPT_TIMER_SETTING:
-			{
-				u16	min_rpt_time = (*(u16 *)val);
-
-				//DBG_8192C("==> HW_VAR_ANTENNA_DIVERSITY_SELECT , Ant_(%s)\n",(Optimum_antenna==2)?"A":"B");
-
-				//PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, Optimum_antenna);
-				ODM_RA_Set_TxRPT_Time(podmpriv,min_rpt_time);	
-			}
-			break;
-#endif
-
-#ifdef CONFIG_SW_ANTENNA_DIVERSITY
-		case HW_VAR_ANTENNA_DIVERSITY_LINK:
-			//SwAntDivRestAfterLink8192C(Adapter);
-			ODM_SwAntDivRestAfterLink(podmpriv);
-			break;
-#endif
-#ifdef CONFIG_ANTENNA_DIVERSITY
-		case HW_VAR_ANTENNA_DIVERSITY_SELECT:
-			{
-				u8	Optimum_antenna = (*(u8 *)val);
-				u8 	Ant ; 
-				//switch antenna to Optimum_antenna
-				//DBG_8192C("==> HW_VAR_ANTENNA_DIVERSITY_SELECT , Ant_(%s)\n",(Optimum_antenna==2)?"A":"B");
-				if(pHalData->CurAntenna !=  Optimum_antenna)		
-				{					
-					Ant = (Optimum_antenna==2)?MAIN_ANT:AUX_ANT;
-					ODM_UpdateRxIdleAnt_88E(&pHalData->odmpriv, Ant);
-					
-					pHalData->CurAntenna = Optimum_antenna ;
-					//DBG_8192C("==> HW_VAR_ANTENNA_DIVERSITY_SELECT , Ant_(%s)\n",(Optimum_antenna==2)?"A":"B");
-				}
-			}
-			break;
-#endif
-		case HW_VAR_EFUSE_BYTES: // To set EFUE total used bytes, added by Roger, 2008.12.22.
-			pHalData->EfuseUsedBytes = *((u16 *)val);
-			break;
-		case HW_VAR_FIFO_CLEARN_UP:
-			{				
-				struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(Adapter);
-				u8 trycnt = 100;
-
-				//pause tx
-				rtw_write8(Adapter,REG_TXPAUSE,0xff);
-
-				//keep sn
-				Adapter->xmitpriv.nqos_ssn = rtw_read16(Adapter,REG_NQOS_SEQ);
-
-				//RX DMA stop
-				rtw_write32(Adapter,REG_RXPKT_NUM,(rtw_read32(Adapter,REG_RXPKT_NUM)|RW_RELEASE_EN));
-				do{
-					if(!(rtw_read32(Adapter,REG_RXPKT_NUM)&RXDMA_IDLE))
-						break;
-				}while(trycnt--);
-				if(trycnt ==0)
-					DBG_8192C("Stop RX DMA failed...... \n");
-
-				//RQPN Load 0
-				rtw_write16(Adapter,REG_RQPN_NPQ,0x0);
-				rtw_write32(Adapter,REG_RQPN,0x80000000);
-				rtw_mdelay_os(10);
-
-			}
-			break;
-#ifdef CONFIG_WOWLAN
-		case HW_VAR_WOWLAN:
-		{
-			struct wowlan_ioctl_param *poidparam;
-			struct recv_buf *precvbuf;
-			struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(Adapter);
-			struct security_priv *psecuritypriv = &Adapter->securitypriv;
-			int res, i;
-			u32 tmp;
-			u64 iv_low = 0, iv_high = 0;
-			u16 len = 0;
-			u8 mstatus = (*(u8 *)val);
-			u8 trycnt = 100;
-			u8 data[4];
-			u8 val8;
-
-			poidparam = (struct wowlan_ioctl_param *)val;
-			switch (poidparam->subcode){
-				case WOWLAN_ENABLE:
-					DBG_871X_LEVEL(_drv_always_, "WOWLAN_ENABLE\n");
-
-#ifndef DYNAMIC_CAMID_ALLOC
-					val8 = (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)? 0xcc: 0xcf;
-					rtw_write8(Adapter, REG_SECCFG, val8);
-					DBG_871X_LEVEL(_drv_always_, "REG_SECCFG: %02x\n", rtw_read8(Adapter, REG_SECCFG));
-#endif
-
-					SetFwRelatedForWoWLAN8188ES(Adapter, _TRUE);
-
-					rtl8188e_set_FwJoinBssReport_cmd(Adapter, 1);
-					rtw_msleep_os(2);
-
-					//Set Pattern
-					//if(pwrctl->wowlan_pattern==_TRUE)
-					//	rtw_wowlan_reload_pattern(Adapter);
-
-					//disable TX Report, only use in 88e
-					rtw_write8(Adapter, REG_TX_RPT_CTRL,
-							((rtw_read8(Adapter, REG_TX_RPT_CTRL)&~BIT(1)))&~BIT(5));
-					DBG_871X("disable TXRPT:0x%02x\n",
-							rtw_read8(Adapter, REG_TX_RPT_CTRL));
-
-					//RX DMA stop
-					DBG_871X_LEVEL(_drv_always_, "Pause DMA\n");
-					rtw_write32(Adapter,REG_RXPKT_NUM,(rtw_read32(Adapter,REG_RXPKT_NUM)|RW_RELEASE_EN));
-					do{
-						if((rtw_read32(Adapter, REG_RXPKT_NUM)&RXDMA_IDLE)) {
-							DBG_871X_LEVEL(_drv_always_, "RX_DMA_IDLE is true\n");
-							DBG_871X("0x284-1:0x%08x\n", rtw_read32(Adapter, 0x284));
-							break;
-						} else {
-							// If RX_DMA is not idle, receive one pkt from DMA
-							res = sdio_local_read(Adapter, SDIO_REG_RX0_REQ_LEN, 4, (u8*)&tmp);
-							len = le16_to_cpu(tmp);
-							DBG_871X_LEVEL(_drv_always_, "RX len:%d\n", len);
-
-							if (len > 0)
-								res = RecvOnePkt(Adapter, len);
-							else
-								DBG_871X_LEVEL(_drv_always_, "read length fail %d\n", len);
-
-							DBG_871X_LEVEL(_drv_always_, "RecvOnePkt Result: %d\n", res);
-						}
-					}while(trycnt--);
-
-					DBG_871X("0x284-2:0x%08x\n", rtw_read32(Adapter, 0x284));
-					DBG_871X("TX_RPT-2:0x%02x\n", rtw_read8(Adapter, REG_TX_RPT_CTRL));
-
-					if(trycnt ==0)
-						DBG_871X_LEVEL(_drv_always_, "Stop RX DMA failed...... \n");
-
-					//Enable CPWM2 only.
-					DBG_871X_LEVEL(_drv_always_, "Enable only CPWM2\n");
-					res = sdio_local_read(Adapter, SDIO_REG_HIMR, 4, (u8*)&tmp);
-					if (!res)
-					    DBG_871X_LEVEL(_drv_info_, "read SDIO_REG_HIMR: 0x%08x\n", tmp);
-					else
-					    DBG_871X_LEVEL(_drv_info_, "sdio_local_read fail\n");
-
-					tmp = SDIO_HIMR_CPWM2_MSK;
-
-					res = sdio_local_write(Adapter, SDIO_REG_HIMR, 4, (u8*)&tmp);
-
-					if (!res){
-					    res = sdio_local_read(Adapter, SDIO_REG_HIMR, 4, (u8*)&tmp);
-					    DBG_871X_LEVEL(_drv_info_, "read again SDIO_REG_HIMR: 0x%08x\n", tmp);
-					}else
-					    DBG_871X_LEVEL(_drv_info_, "sdio_local_write fail\n");
-
-					//Set WOWLAN H2C command.
-					DBG_871X_LEVEL(_drv_always_, "Set WOWLan cmd\n");
-					rtl8188es_set_wowlan_ctrl_cmd(Adapter, 1);
-					rtl8188es_set_global_info_cmd(Adapter, 1);
-					rtl8188es_set_keep_alive_cmd(Adapter, 1);
-					rtl8188es_set_disconnect_decision_cmd(Adapter, 1);
-					rtl8188es_set_remote_wake_ctrl_cmd(Adapter, 1);
-
-					mstatus = rtw_read8(Adapter, REG_WOW_CTRL);
-					trycnt = 10;
-
-					while(!(mstatus&BIT1) && trycnt>1) {
-						mstatus = rtw_read8(Adapter, REG_WOW_CTRL);
-						DBG_871X_LEVEL(_drv_always_, "Loop index: %d :0x%02x\n", trycnt, mstatus);
-						DBG_871X_LEVEL(_drv_always_, "0x284 0x%08x\n", rtw_read32(Adapter, 0x284));
-						DBG_871X_LEVEL(_drv_always_, "0x11c 0x%08x\n", rtw_read32(Adapter, 0x11c));
-						DBG_871X_LEVEL(_drv_always_, "0x1c4 0x%08x\n", rtw_read32(Adapter, 0x1c4));
-						DBG_871X_LEVEL(_drv_always_, "0x690 0x%08x\n", rtw_read32(Adapter, 0x690));
-						trycnt --;
-						rtw_msleep_os(20);
-					}
-
-					pwrctl->wowlan_wake_reason = rtw_read8(Adapter, REG_WOWLAN_WAKE_REASON);
-					DBG_871X_LEVEL(_drv_always_, "wowlan_wake_reason: 0x%02x\n",
-										pwrctl->wowlan_wake_reason);
-					//rtw_msleep_os(10);
-					break;
-				case WOWLAN_DISABLE:
-					trycnt = 10;
-					
-					DBG_871X_LEVEL(_drv_always_, "WOWLAN_DISABLE\n");
-					rtl8188e_set_FwJoinBssReport_cmd(Adapter, 0);
-					
-#ifndef DYNAMIC_CAMID_ALLOC
-					rtw_write8(	Adapter, REG_SECCFG, 0x0c|BIT(5));// enable tx enc and rx dec engine, and no key search for MC/BC
-					DBG_871X_LEVEL(_drv_always_, "REG_SECCFG: %02x\n", rtw_read8(Adapter, REG_SECCFG));
-#endif
-
-					pwrctl->wowlan_wake_reason = rtw_read8(Adapter, REG_WOWLAN_WAKE_REASON);
-					DBG_871X_LEVEL(_drv_always_, "wakeup_reason: 0x%02x\n",
-												pwrctl->wowlan_wake_reason);
-					//rtl8188es_set_wowlan_cmd(Adapter, 0);
-					rtl8188es_set_wowlan_ctrl_cmd(Adapter, 0);
-					rtl8188es_set_global_info_cmd(Adapter, 0);
-					rtl8188es_set_keep_alive_cmd(Adapter, 0);
-					rtl8188es_set_disconnect_decision_cmd(Adapter, 0);
-					rtl8188es_set_remote_wake_ctrl_cmd(Adapter, 0);
-
-					mstatus = rtw_read8(Adapter, REG_WOW_CTRL);
-					DBG_871X_LEVEL(_drv_info_, "%s mstatus:0x%02x\n", __func__, mstatus);
-
-					while(mstatus&BIT1 && trycnt>1) {
-						mstatus = rtw_read8(Adapter, REG_WOW_CTRL);
-						DBG_871X_LEVEL(_drv_always_, "Loop index: %d :0x%02x\n", trycnt, mstatus);
-						DBG_871X_LEVEL(_drv_always_, "0x284 0x%08x\n", rtw_read32(Adapter, 0x284));
-						DBG_871X_LEVEL(_drv_always_, "0x11c 0x%08x\n", rtw_read32(Adapter, 0x11c));
-						DBG_871X_LEVEL(_drv_always_, "0x1c4 0x%08x\n", rtw_read32(Adapter, 0x1c4));
-						DBG_871X_LEVEL(_drv_always_, "0x690 0x%08x\n", rtw_read32(Adapter, 0x690));
-						trycnt --;
-						rtw_msleep_os(2);
-					}
-
-					if (mstatus & BIT1) {
-						DBG_871X_LEVEL(_drv_always_, "Disable WOW mode fail!!\n");
-						DBG_871X("Set 0x690=0x00\n");
-						rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&0xf0));
-						DBG_871X_LEVEL(_drv_always_, "Release RXDMA\n");
-						rtw_write32(Adapter, REG_RXPKT_NUM,(rtw_read32(Adapter,REG_RXPKT_NUM)&(~RW_RELEASE_EN)));
-					}
-
-					//enable TX Report, only use in 88e
-					rtw_write8(Adapter, REG_TX_RPT_CTRL,
-							((rtw_read8(Adapter, REG_TX_RPT_CTRL)|BIT(1)))|BIT(5));
-					DBG_871X("enable TX_RPT:0x%02x\n", rtw_read8(Adapter, REG_TX_RPT_CTRL));
-
-					// 3.1 read fw iv
-					iv_low = rtw_read32(Adapter, REG_TXPKTBUF_IV_LOW);
-					//only low two bytes is PN, check AES_IV macro for detail
-					iv_low &= 0xffff;
-					iv_high = rtw_read32(Adapter, REG_TXPKTBUF_IV_HIGH);
-					//get the real packet number
-					pwrctl->wowlan_fw_iv = iv_high << 16 | iv_low;
-					DBG_871X_LEVEL(_drv_always_, "fw_iv: 0x%016llx\n", pwrctl->wowlan_fw_iv);
-					//Update TX iv data.
-					rtw_set_sec_pn(Adapter);
-
-					SetFwRelatedForWoWLAN8188ES(Adapter, _FALSE);
-#ifdef CONFIG_GPIO_WAKEUP
-					DBG_871X_LEVEL(_drv_always_, "Set Wake GPIO to high for default.\n");
-					HalSetOutPutGPIO(Adapter, WAKEUP_GPIO_IDX, 1);
-#endif
-					if((pwrctl->wowlan_wake_reason != FWDecisionDisconnect) &&
-						(pwrctl->wowlan_wake_reason != Rx_Pairwisekey) &&
-						(pwrctl->wowlan_wake_reason != Rx_DisAssoc) &&
-						(pwrctl->wowlan_wake_reason != Rx_DeAuth))
-						rtl8188e_set_FwJoinBssReport_cmd(Adapter, 1);
-
-					rtw_msleep_os(5);
-
-					break;
-				default:
-					break;
-			}
-		}
-		break;
-#endif //CONFIG_WOWLAN
-		case HW_VAR_APFM_ON_MAC:
-			pHalData->bMacPwrCtrlOn = *val;
-			DBG_871X("%s: bMacPwrCtrlOn=%d\n", __func__, pHalData->bMacPwrCtrlOn);
-			break;
-#if (RATE_ADAPTIVE_SUPPORT == 1)
-		case HW_VAR_TX_RPT_MAX_MACID:
-			{
-				u8 maxMacid = *val;
-				DBG_8192C("### MacID(%d),Set Max Tx RPT MID(%d)\n",maxMacid,maxMacid+1);
-				rtw_write8(Adapter, REG_TX_RPT_CTRL+1, maxMacid+1);
-			}
-			break;
-#endif	//  (RATE_ADAPTIVE_SUPPORT == 1)		
-		case HW_VAR_H2C_MEDIA_STATUS_RPT:
-			{				
-				rtl8188e_set_FwMediaStatus_cmd(Adapter , (*(u16 *)val));
-			}
-			break;
-		case HW_VAR_BCN_VALID:
-			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw
-			rtw_write8(Adapter, REG_TDECTRL+2, rtw_read8(Adapter, REG_TDECTRL+2) | BIT0); 
-			break;
-		default:
-			SetHwReg8188E(Adapter, variable, val);
-			break;
-	}
-
-_func_exit_;
-}
-
-static void GetHwReg8188ES(PADAPTER padapter, u8 variable, u8 *val)
-{
-	PHAL_DATA_TYPE 	pHalData= GET_HAL_DATA(padapter);
-	DM_ODM_T 		*podmpriv = &pHalData->odmpriv;
-_func_enter_;
-
-	switch (variable)
-	{
-		case HW_VAR_CPWM:
-			*val = rtw_read8(padapter, SDIO_LOCAL_BASE|SDIO_REG_HCPWM1);
-			break;
-		case HW_VAR_TXPAUSE:
-			val[0] = rtw_read8(padapter, REG_TXPAUSE);
-			break;
-
-		case HW_VAR_BCN_VALID:
-			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2
-			val[0] = (BIT0 & rtw_read8(padapter, REG_TDECTRL+2))?_TRUE:_FALSE;
-			break;
-
-		case HW_VAR_FWLPS_RF_ON:
-			{
-				//When we halt NIC, we should check if FW LPS is leave.				
-				if ((padapter->bSurpriseRemoved == _TRUE) ||
-					(adapter_to_pwrctl(padapter)->rf_pwrstate == rf_off))
-				{
-					// If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave,
-					// because Fw is unload.
-					val[0] = _TRUE;
-				}
-				else
-				{
-					u32	valRCR;
-					valRCR = rtw_read32(padapter, REG_RCR);
-					valRCR &= 0x00070000;
-					if(valRCR)
-						val[0] = _FALSE;
-					else
-						val[0] = _TRUE;
-				}
-			}
-			break;
-#ifdef CONFIG_ANTENNA_DIVERSITY
-		case HW_VAR_CURRENT_ANTENNA:
-			val[0] = pHalData->CurAntenna;
-			break;
-#endif
-		case HW_VAR_EFUSE_BYTES: // To get EFUE total used bytes, added by Roger, 2008.12.22.
-			*((u16*)val) = pHalData->EfuseUsedBytes;
-			break;
-
-		case HW_VAR_APFM_ON_MAC:
-			*val = pHalData->bMacPwrCtrlOn;
-			break;
-		case HW_VAR_CHK_HI_QUEUE_EMPTY:
-			*val = ((rtw_read32(padapter, REG_HGQ_INFORMATION)&0x0000ff00)==0) ? _TRUE:_FALSE;
-			break;
-		default:
-			GetHwReg8188E(padapter, variable, val);
-			break;
-	}
-
-_func_exit_;
-}
-
-//
-//	Description:
-//		Query setting of specified variable.
-//
-u8
-GetHalDefVar8188ESDIO(
-	IN	PADAPTER				Adapter,
-	IN	HAL_DEF_VARIABLE		eVariable,
-	IN	PVOID					pValue
-	)
-{
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
-	u8			bResult = _SUCCESS;
-
-	switch(eVariable)
-	{
-		case HAL_DEF_UNDERCORATEDSMOOTHEDPWDB:
-			{
-				struct mlme_priv *pmlmepriv = &Adapter->mlmepriv;
-				struct sta_priv * pstapriv = &Adapter->stapriv;
-				struct sta_info * psta;
-				psta = rtw_get_stainfo(pstapriv, pmlmepriv->cur_network.network.MacAddress);
-				if(psta)
-				{
-					*((int *)pValue) = psta->rssi_stat.UndecoratedSmoothedPWDB;     
-				}
-			}
-
-			break;
-		case HAL_DEF_IS_SUPPORT_ANT_DIV:
-			#ifdef CONFIG_ANTENNA_DIVERSITY
-			*((u8 *)pValue) = (pHalData->AntDivCfg==0)?_FALSE:_TRUE;
-			#endif
-			break;
-		case HAL_DEF_CURRENT_ANTENNA:
-#ifdef CONFIG_ANTENNA_DIVERSITY
-			*(( u8*)pValue) = pHalData->CurAntenna;
-#endif
-			break;
-		case HAL_DEF_DRVINFO_SZ:
-			*(( u32*)pValue) = DRVINFO_SZ;
-			break;	
-		case HAL_DEF_MAX_RECVBUF_SZ:
-			*(( u32*)pValue) = MAX_RECVBUF_SZ;
-			break;
-		case HAL_DEF_RX_PACKET_OFFSET:
-			*(( u32*)pValue) = RXDESC_SIZE + DRVINFO_SZ;
-			break;	
-#if (RATE_ADAPTIVE_SUPPORT == 1)
-		case HAL_DEF_RA_DECISION_RATE:
-			{
-				u8 MacID = *((u8*)pValue);
-				*((u8*)pValue) = ODM_RA_GetDecisionRate_8188E(&(pHalData->odmpriv), MacID);
-			}
-			break;
-		
-		case HAL_DEF_RA_SGI:
-			{
-				u8 MacID = *((u8*)pValue);
-				*((u8*)pValue) = ODM_RA_GetShortGI_8188E(&(pHalData->odmpriv), MacID);
-			}
-			break;		
-#endif
-
-
-		case HAL_DEF_PT_PWR_STATUS:
-#if(POWER_TRAINING_ACTIVE==1)	
-			{
-				u8 MacID = *((u8*)pValue);
-				*((u8*)pValue) = ODM_RA_GetHwPwrStatus_8188E(&(pHalData->odmpriv), MacID);
-			}
-#endif //(POWER_TRAINING_ACTIVE==1)
-			break;		
-
-		case HW_VAR_MAX_RX_AMPDU_FACTOR:
-			*(HT_CAP_AMPDU_FACTOR*)pValue = MAX_AMPDU_FACTOR_16K;
-			break;
-
-		case HAL_DEF_TX_LDPC:
-		case HAL_DEF_RX_LDPC:
-			*((u8 *)pValue) = _FALSE;
-			break;
-		case HAL_DEF_TX_STBC:
-			*((u8 *)pValue) = 0;
-			break;
-		case HAL_DEF_RX_STBC:
-			*((u8 *)pValue) = 1;
-			break;
-		case HAL_DEF_EXPLICIT_BEAMFORMEE:
-		case HAL_DEF_EXPLICIT_BEAMFORMER:
-			*((u8 *)pValue) = _FALSE;
-			break;
-
-		case HW_DEF_RA_INFO_DUMP:
-#if (RATE_ADAPTIVE_SUPPORT == 1)	
-			{
-				u8 mac_id = *((u8*)pValue);				
-				u8 			bLinked = _FALSE;
-#ifdef CONFIG_CONCURRENT_MODE
-				PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
-#endif //CONFIG_CONCURRENT_MODE
-
-				if(rtw_linked_check(Adapter))
-					bLinked = _TRUE;
-		
-#ifdef CONFIG_CONCURRENT_MODE
-				if(pbuddy_adapter && rtw_linked_check(pbuddy_adapter))
-					bLinked = _TRUE;
-#endif			
-				
-				if(bLinked){					
-					DBG_871X("============ RA status - Mac_id:%d ===================\n",mac_id);					
-					DBG_8192C("Mac_id:%d ,RSSI:%d(%%) ,PTStage = %d\n",
-						mac_id,pHalData->odmpriv.RAInfo[mac_id].RssiStaRA,pHalData->odmpriv.RAInfo[mac_id].PTStage);							
-
-					DBG_8192C("RateID = %d,RAUseRate = 0x%08x,RateSGI = %d, DecisionRate = %s\n",
-						pHalData->odmpriv.RAInfo[mac_id].RateID,
-						pHalData->odmpriv.RAInfo[mac_id].RAUseRate,
-						pHalData->odmpriv.RAInfo[mac_id].RateSGI,
-						HDATA_RATE(pHalData->odmpriv.RAInfo[mac_id].DecisionRate));				
-				}
-			}
-#endif // (RATE_ADAPTIVE_SUPPORT == 1)
-			break;
-
-		default:
-			bResult = GetHalDefVar(Adapter, eVariable, pValue);
-			break;
-	}
-
-	return bResult;
+	return bResult;
 }
 
 
@@ -4104,20 +2686,6 @@ void rtl8188es_set_hal_ops(PADAPTER padapter)
 
 _func_enter_;
 
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->isprimary)
-#endif //CONFIG_CONCURRENT_MODE
-	{
-		//set hardware operation functions
-		padapter->HalData = rtw_zvmalloc(sizeof(HAL_DATA_TYPE));
-		if(padapter->HalData == NULL){
-			DBG_8192C("cant not alloc memory for HAL DATA \n");
-		}
-	}
-
-	padapter->hal_data_sz = sizeof(HAL_DATA_TYPE);
-
 	pHalFunc->hal_power_on = _InitPowerOn_8188ES;
 	pHalFunc->hal_power_off = hal_poweroff_8188es;
 	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8188EPhyReg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8188EPhyReg.h
index 763cceadf4b6..2ef34ed802d3 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8188EPhyReg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8188EPhyReg.h
@@ -1059,6 +1059,7 @@
 #define		bMaskHWord                		0xffff0000
 #define		bMaskLWord                		0x0000ffff
 #define		bMaskDWord                		0xffffffff
+#define		bMaskH3Bytes				0xffffff00
 #define		bMask12Bits				0xfff	
 #define		bMaskH4Bits				0xf0000000	
 #define 		bMaskOFDM_D			0xffc00000
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192CPhyReg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192CPhyReg.h
index e4e977c67fbb..1c7cd5d1ed1e 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192CPhyReg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192CPhyReg.h
@@ -1082,6 +1082,7 @@
 #define		bMaskHWord		0xffff0000
 #define		bMaskLWord			0x0000ffff
 #define		bMaskDWord		0xffffffff
+#define		bMaskH3Bytes		0xffffff00
 #define		bMask12Bits			0xfff
 #define		bMaskH4Bits			0xf0000000	
 #define		bMaskOFDM_D		0xffc00000
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192DPhyReg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192DPhyReg.h
index fb32eacd90ae..b5af827275de 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192DPhyReg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192DPhyReg.h
@@ -482,7 +482,7 @@
 #define		RF_TX_G3					0x22	// 
 
 #define		RF_TX_BB1					0x23	// 
-
+#define		RF_T_METER_92D			0x42
 #define		RF_T_METER					0x42	// 
 
 #define		RF_SYN_G1					0x25	// RF TX Power control
@@ -1112,6 +1112,7 @@
 #define		bMaskHWord		0xffff0000
 #define		bMaskLWord			0x0000ffff
 #define		bMaskDWord		0xffffffff
+#define		bMaskH3Bytes		0xffffff00
 #define		bMask12Bits			0xfff
 #define		bMaskH4Bits			0xf0000000	
 #define		bMaskOFDM_D		0xffc00000
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192EPhyCfg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192EPhyCfg.h
index d76863be2fae..a11804197d4b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192EPhyCfg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192EPhyCfg.h
@@ -139,8 +139,7 @@ PHY_SetSwChnlBWMode8192E(
 
 void 
 phy_SpurCalibration_8192E(
-	IN	PADAPTER			Adapter,
-	IN	SPUR_CAL_METHOD	Method
+	IN	PADAPTER			Adapter
 );
 //
 // BB/MAC/RF other monitor API
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192EPhyReg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192EPhyReg.h
index 0621fb96fb18..02a3f865a96b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192EPhyReg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8192EPhyReg.h
@@ -425,10 +425,8 @@
 
 #define		RF_TX_BB1					0x23	// 
 
-//#if HARDWARE_TYPE_IS_RTL8192D	== 1
-#define		RF_T_METER_92D					0x42	// 
-//#else
-#define		RF_T_METER_88E					0x42	// 
+#define		RF_T_METER_8192E			0x42	// 
+#define		RF_T_METER_88E				0x42	//
 #define		RF_T_METER					0x24	// 
 
 //#endif
@@ -1065,6 +1063,7 @@
 #define		bMaskHWord                		0xffff0000
 #define		bMaskLWord                		0x0000ffff
 #define		bMaskDWord                		0xffffffff
+#define		bMaskH3Bytes				0xffffff00
 #define		bMask12Bits				0xfff	
 #define		bMaskH4Bits				0xf0000000	
 #define 		bMaskOFDM_D			0xffc00000
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8812PhyReg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8812PhyReg.h
index 5125e227dc23..929718951f79 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8812PhyReg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8812PhyReg.h
@@ -420,6 +420,8 @@
 #define rFPGA0_AdDaClockEn			0x888	// enable ad/da clock1 for dual-phy
 #define rFPGA0_AnalogParameter4	0x88c
 #define rFPGA0_XB_LSSIReadBack		0x8a4
+#define rFPGA0_XCD_RFPara	0x8b4
+
 //
 // 4. Page9(0x900)
 //
@@ -434,9 +436,11 @@
 //
 #define rCCK0_System				0xa00
 #define rCCK0_AFESetting				0xa04	// Disable init gain now // Select RX path by RSSI
+#define	rCCK0_DSPParameter2			0xa1c	//SQ threshold
 #define rCCK0_TxFilter1				0xa20
 #define rCCK0_TxFilter2				0xa24
 #define rCCK0_DebugPort				0xa28	//debug port and Tx filter3
+#define	rCCK0_FalseAlarmReport			0xa2c	//0xa2d	useless now 0xa30-a4f channel report
 
 //
 // PageB(0xB00)
@@ -717,6 +721,7 @@
 #define bMaskHWord                	0xffff0000
 #define bMaskLWord                		0x0000ffff
 #define bMaskDWord                	0xffffffff
+#define bMaskH3Bytes				0xffffff00
 #define bMask12Bits				0xfff	
 #define bMaskH4Bits				0xf0000000	
 #define bMaskOFDM_D			0xffc00000
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8812PwrSeq.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8812PwrSeq.h
index 0d0c2f76775c..5d6a7ad22b6f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8812PwrSeq.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/Hal8812PwrSeq.h
@@ -61,7 +61,7 @@
 	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
 	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
-	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/ \
+	/*{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0}, disable HWPDN 0x04[15]=0*/ \
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT3, 0},/* disable WL suspend*/	\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0, BIT0},/* polling until return 0*/	\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT0, 0},/**/
@@ -76,7 +76,7 @@
 	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, 0},  /* Whole BB is reset*/			\
 	/*{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},//0x1F[7:0] = 0 turn off RF*/	\
 	/*{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT7, 0},//0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */	\
-	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x28}, /* 0x07[7:0] = 0x28 sps pwm mode */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x2A}, /* 0x07[7:0] = 0x28 sps pwm mode 0x2a for BT coex*/	\
 	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk =500k */	\
 	/*{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT0|BIT1, 0}, //  0x02[1:0] = 0	reset BB */	\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/autoconf.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/autoconf.h
index 052011111b29..8b9b838615e4 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/autoconf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/autoconf.h
@@ -1,322 +1,309 @@
-/******************************************************************************
- *
- * Copyright(c) 2010 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-/*
- * Automatically generated C config: don't edit
- */
-//***** temporarily flag *******
-#define CONFIG_SINGLE_IMG
-
-//***** temporarily flag *******
-
-//***** temporarily flag *******
-
-
-#define AUTOCONF_INCLUDED
-#define RTL871X_MODULE_NAME "8189ES"
-#define DRV_NAME "rtl8189es"
-#define EFUSE_MAP_PATH "/system/etc/wifi/wifi_efuse_8189e.map"
-#define WIFIMAC_PATH "/data/wifimac.txt"
-
-#define CONFIG_SDIO_HCI
-#define PLATFORM_LINUX
-
-//#define CONFIG_IOCTL_CFG80211
-
-#ifdef CONFIG_IOCTL_CFG80211
-	//#define RTW_USE_CFG80211_STA_EVENT /* Indecate new sta asoc through cfg80211_new_sta */
-	#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
-	//#define CONFIG_DEBUG_CFG80211
-	#define CONFIG_SET_SCAN_DENY_TIMER
-#endif
-
-#define CONFIG_EMBEDDED_FWIMG
-//#define CONFIG_FILE_FWIMG
-
-#define CONFIG_XMIT_ACK
-#ifdef CONFIG_XMIT_ACK
-	#define CONFIG_ACTIVE_KEEP_ALIVE_CHECK
-#endif
-#define CONFIG_80211N_HT
-#define CONFIG_RECV_REORDERING_CTRL
-
-//#define CONFIG_CONCURRENT_MODE
-#ifdef CONFIG_CONCURRENT_MODE
-	#define CONFIG_TSF_RESET_OFFLOAD		// For 2 PORT TSF SYNC.
-	//#define CONFIG_HWPORT_SWAP				//Port0->Sec , Port1 -> Pri
-	#define CONFIG_RUNTIME_PORT_SWITCH
-	//#define DBG_RUNTIME_PORT_SWITCH
-	#define CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-#endif
-
-#define CONFIG_AP_MODE
-#ifdef CONFIG_AP_MODE
-
-	#define CONFIG_INTERRUPT_BASED_TXBCN // Tx Beacon when driver early interrupt occurs	
-	#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_INTERRUPT_BASED_TXBCN)
-		#undef CONFIG_INTERRUPT_BASED_TXBCN
-	#endif
-	#ifdef CONFIG_INTERRUPT_BASED_TXBCN
-		//#define CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-		#define CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR		
-	#endif
-	
-	#define CONFIG_NATIVEAP_MLME
-	#ifndef CONFIG_NATIVEAP_MLME
-		#define CONFIG_HOSTAPD_MLME
-	#endif
-	#define CONFIG_FIND_BEST_CHANNEL
-	//#define CONFIG_NO_WIRELESS_HANDLERS
-#endif
-
-#define CONFIG_TX_MCAST2UNI		// Support IP multicast->unicast
-//#define CONFIG_CHECK_AC_LIFETIME 	// Check packet lifetime of 4 ACs.
-
-#define CONFIG_P2P
-#ifdef CONFIG_P2P
-	//The CONFIG_WFD is for supporting the Wi-Fi display
-	#define CONFIG_WFD
-	
-	#ifndef CONFIG_WIFI_TEST
-		#define CONFIG_P2P_REMOVE_GROUP_INFO
-	#endif
-	//#define CONFIG_DBG_P2P
-
-	#define CONFIG_P2P_PS
-	//#define CONFIG_P2P_IPS
-	#define CONFIG_P2P_OP_CHK_SOCIAL_CH
-	#define CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT  //replace CONFIG_P2P_CHK_INVITE_CH_LIST flag
-	#define CONFIG_P2P_INVITE_IOT
-#endif
-
-//	Added by Kurt 20110511
-//#define CONFIG_TDLS
-#ifdef CONFIG_TDLS
-//	#ifndef CONFIG_WFD
-//		#define CONFIG_WFD	
-//	#endif
-//	#define CONFIG_TDLS_AUTOSETUP			
-//	#define CONFIG_TDLS_AUTOCHECKALIVE		
-#endif
-
-#define CONFIG_SKB_COPY	//for amsdu
-
-#define CONFIG_LAYER2_ROAMING
-#define CONFIG_LAYER2_ROAMING_RESUME
-
-#define CONFIG_LONG_DELAY_ISSUE
-#define CONFIG_NEW_SIGNAL_STAT_PROCESS
-#define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable, */
-#define CONFIG_DEAUTH_BEFORE_CONNECT
-
-/*
- * Hardware Related Config
- */
-
-//#define SUPPORT_HW_RFOFF_DETECTED
-
-//#define CONFIG_SW_LED
-
-/*
- * Interface Related Config
- */
-#define CONFIG_TX_AGGREGATION
-//#define CONFIG_SDIO_TX_TASKLET
-#define CONFIG_SDIO_RX_COPY
-#define CONFIG_SDIO_TX_ENABLE_AVAL_INT
-
-/*
- * Others
- */
-//#define CONFIG_MAC_LOOPBACK_DRIVER
-
-
-/*
- * Auto Config Section
- */
-#if defined(CONFIG_RTL8188E) && defined(CONFIG_SDIO_HCI)
-#define CONFIG_RTL8188E_SDIO 
-#define CONFIG_XMIT_THREAD_MODE
-#endif
-
-#define CONFIG_IPS
-#define CONFIG_LPS
-#if defined(CONFIG_LPS) && defined(CONFIG_SDIO_HCI)
-#define CONFIG_LPS_LCLK
-
-#ifdef CONFIG_LPS_LCLK
-#define LPS_RPWM_WAIT_MS 300
-
-//#define CONFIG_DETECT_CPWM_BY_POLLING
-//#define CONFIG_LPS_RPWM_TIMER
-
-#if defined(CONFIG_LPS_RPWM_TIMER) || defined(CONFIG_DETECT_CPWM_BY_POLLING)
-#define LPS_RPWM_WAIT_MS 300
-#endif
-//#define CONFIG_LPS_LCLK_WD_TIMER // Watch Dog timer in LPS LCLK
-#endif
-	
-#endif
-
-#ifdef CONFIG_MAC_LOOPBACK_DRIVER
-#undef CONFIG_AP_MODE
-#undef CONFIG_NATIVEAP_MLME
-#undef CONFIG_POWER_SAVING
-#undef SUPPORT_HW_RFOFF_DETECTED
-#endif
-
-#ifdef CONFIG_MP_INCLUDED
-
-	#define MP_DRIVER		1
-	#define CONFIG_MP_IWPRIV_SUPPORT
-
-	// disable unnecessary functions for MP
-	//#undef CONFIG_IPS
-	//#undef CONFIG_LPS
-	//#undef CONFIG_LPS_LCLK
-	//#undef SUPPORT_HW_RFOFF_DETECTED
-
-#else// #ifdef CONFIG_MP_INCLUDED
-
-	#define MP_DRIVER		0
-	
-#endif // #ifdef CONFIG_MP_INCLUDED
-
-#define CONFIG_IOL
-#ifdef CONFIG_IOL
-	#define CONFIG_IOL_NEW_GENERATION
-	#define CONFIG_IOL_READ_EFUSE_MAP
-	//#define DBG_IOL_READ_EFUSE_MAP
-	//#define CONFIG_IOL_LLT
-	#define CONFIG_IOL_EFUSE_PATCH
-	//#define CONFIG_IOL_IOREG_CFG
-	//#define CONFIG_IOL_IOREG_CFG_DBG
-#endif
-
-
-#ifdef CONFIG_PLATFORM_ACTIONS_ATV5201
-#define CONFIG_SDIO_DISABLE_RXFIFO_POLLING_LOOP 
-#endif
-
-/*
- * Outsource  Related Config
- */
-
-#define 	RTL8192CE_SUPPORT 				0
-#define 	RTL8192CU_SUPPORT 			0
-#define 	RTL8192C_SUPPORT 				(RTL8192CE_SUPPORT|RTL8192CU_SUPPORT)	
-
-#define 	RTL8192DE_SUPPORT 				0
-#define 	RTL8192DU_SUPPORT 			0
-#define 	RTL8192D_SUPPORT 				(RTL8192DE_SUPPORT|RTL8192DU_SUPPORT)	
-
-#define 	RTL8723_FPGA_VERIFICATION		0
-#define 	RTL8723AU_SUPPORT				0
-#define 	RTL8723AS_SUPPORT				0
-#define 	RTL8723AE_SUPPORT				0
-#define 	RTL8723A_SUPPORT				(RTL8723AU_SUPPORT|RTL8723AS_SUPPORT|RTL8723AE_SUPPORT)
-
-#define RTL8188EE_SUPPORT				0
-#define RTL8188EU_SUPPORT				0
-#define RTL8188ES_SUPPORT				1
-#define RTL8188E_SUPPORT				(RTL8188EE_SUPPORT|RTL8188EU_SUPPORT|RTL8188ES_SUPPORT)
-#define TESTCHIP_SUPPORT			0
-
-#define RTL8812E_SUPPORT				0
-#define RTL8812AU_SUPPORT				0
-#define RTL8812A_SUPPORT				(RTL8812E_SUPPORT|RTL8812AU_SUPPORT)
-
-#define RTL8821A_SUPPORT				0
-
-#define RTL8723B_SUPPORT				0
-
-#define RTL8192E_SUPPORT				0
-
-#define RTL8813A_SUPPORT				0
-
-//#if (RTL8188E_SUPPORT==1)
-#define RATE_ADAPTIVE_SUPPORT 			1
-#define POWER_TRAINING_ACTIVE			1
-//#define 	CONFIG_TX_EARLY_MODE
-
-#ifdef CONFIG_TX_EARLY_MODE
-#define	RTL8188E_EARLY_MODE_PKT_NUM_10	0
-#endif
-//#endif
-
-#define CONFIG_ATTEMPT_TO_FIX_AP_BEACON_ERROR
-
-#ifdef CONFIG_GPIO_WAKEUP
-#define WAKEUP_GPIO_IDX 7
-#endif
-
-#define CONFIG_GPIO_API
-/*
- * HAL	Related Config
- */
-
-//for FPGA VERIFICATION config
-#define RTL8188E_FPGA_TRUE_PHY_VERIFICATION 0
-
-#define DISABLE_BB_RF	0
-
-#define CONFIG_RF_GAIN_OFFSET
-#define CONFIG_80211D
-
-#define CONFIG_ARP_KEEP_ALIVE
-
-/*
- * Debug Related Config
- */
-#define DBG	0
-
-#define CONFIG_DEBUG /* DBG_871X, etc... */
-//#define CONFIG_DEBUG_RTL871X /* RT_TRACE, RT_PRINT_DATA, _func_enter_, _func_exit_ */
-
-#define CONFIG_PROC_DEBUG
-
-#define DBG_CONFIG_ERROR_DETECT
-#define DBG_CONFIG_ERROR_RESET
-
-//#define CONFIG_DISABLE_ODM
-
-//#define DBG_IO
-//#define DBG_DELAY_OS
-//#define DBG_MEM_ALLOC
-//#define DBG_IOCTL
-
-//#define DBG_TX
-//#define DBG_XMIT_BUF
-//#define DBG_XMIT_BUF_EXT
-//#define DBG_TX_DROP_FRAME
-
-//#define DBG_RX_DROP_FRAME
-//#define DBG_RX_SEQ
-//#define DBG_RX_SIGNAL_DISPLAY_PROCESSING
-//#define DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED "jeff-ap"
-
-
-//#define HAL_8195A_USB 0
-
-//#define RTL8188E_FOR_MP_TEST 1
-
-//#define DOWNLOAD_FW_TO_TXPKT_BUF 0
-
-//#define DBG_HAL_INIT_PROFILING
-
+/******************************************************************************
+ *
+ * Copyright(c) 2010 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+/*
+ * Automatically generated C config: don't edit
+ */
+//***** temporarily flag *******
+#define CONFIG_SINGLE_IMG
+
+//***** temporarily flag *******
+
+//***** temporarily flag *******
+
+
+#define AUTOCONF_INCLUDED
+#define RTL871X_MODULE_NAME "8189ES"
+#define DRV_NAME "rtl8189es"
+
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+#ifndef EFUSE_MAP_PATH
+#define EFUSE_MAP_PATH "/system/etc/wifi/wifi_efuse_8189e.map"
+#endif //EFUSE_MAP_PATH
+#endif
+
+#define CONFIG_SDIO_HCI
+#define PLATFORM_LINUX
+
+#define CONFIG_IOCTL_CFG80211
+
+#ifdef CONFIG_IOCTL_CFG80211
+	#define RTW_USE_CFG80211_STA_EVENT /* Indecate new sta asoc through cfg80211_new_sta */
+	#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
+	//#define CONFIG_DEBUG_CFG80211
+	#define CONFIG_SET_SCAN_DENY_TIMER
+#endif
+
+#define CONFIG_EMBEDDED_FWIMG
+//#define CONFIG_FILE_FWIMG
+
+#define CONFIG_XMIT_ACK
+#ifdef CONFIG_XMIT_ACK
+	#define CONFIG_ACTIVE_KEEP_ALIVE_CHECK
+#endif
+#define CONFIG_80211N_HT
+#define CONFIG_RECV_REORDERING_CTRL
+
+#define CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE
+	#define CONFIG_TSF_RESET_OFFLOAD		// For 2 PORT TSF SYNC.
+	//#define CONFIG_HWPORT_SWAP				//Port0->Sec , Port1 -> Pri
+	#define CONFIG_RUNTIME_PORT_SWITCH
+	//#define DBG_RUNTIME_PORT_SWITCH
+	#define CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+#endif
+
+#define CONFIG_AP_MODE
+#ifdef CONFIG_AP_MODE
+
+	#define CONFIG_INTERRUPT_BASED_TXBCN // Tx Beacon when driver early interrupt occurs	
+	#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_INTERRUPT_BASED_TXBCN)
+		#undef CONFIG_INTERRUPT_BASED_TXBCN
+	#endif
+	#ifdef CONFIG_INTERRUPT_BASED_TXBCN
+		//#define CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+		#define CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR		
+	#endif
+	
+	#define CONFIG_NATIVEAP_MLME
+	#ifndef CONFIG_NATIVEAP_MLME
+		#define CONFIG_HOSTAPD_MLME
+	#endif
+	//#define CONFIG_FIND_BEST_CHANNEL
+	//#define CONFIG_NO_WIRELESS_HANDLERS
+#endif
+
+#define CONFIG_TX_MCAST2UNI		// Support IP multicast->unicast
+//#define CONFIG_CHECK_AC_LIFETIME 	// Check packet lifetime of 4 ACs.
+
+#define CONFIG_P2P
+#ifdef CONFIG_P2P
+	//The CONFIG_WFD is for supporting the Wi-Fi display
+	#define CONFIG_WFD
+	
+	#ifndef CONFIG_WIFI_TEST
+		#define CONFIG_P2P_REMOVE_GROUP_INFO
+	#endif
+	//#define CONFIG_DBG_P2P
+
+	#define CONFIG_P2P_PS
+	#define CONFIG_P2P_IPS
+	#define CONFIG_P2P_OP_CHK_SOCIAL_CH
+	#define CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT  //replace CONFIG_P2P_CHK_INVITE_CH_LIST flag
+	#define CONFIG_P2P_INVITE_IOT
+#endif
+
+//	Added by Kurt 20110511
+//#define CONFIG_TDLS
+#ifdef CONFIG_TDLS
+//	#ifndef CONFIG_WFD
+//		#define CONFIG_WFD	
+//	#endif
+//	#define CONFIG_TDLS_AUTOSETUP			
+//	#define CONFIG_TDLS_AUTOCHECKALIVE		
+#endif
+
+#define CONFIG_SKB_COPY	//for amsdu
+
+#define CONFIG_LAYER2_ROAMING
+#define CONFIG_LAYER2_ROAMING_RESUME
+
+#define CONFIG_LONG_DELAY_ISSUE
+#define CONFIG_NEW_SIGNAL_STAT_PROCESS
+#define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable, */
+#define CONFIG_DEAUTH_BEFORE_CONNECT
+
+/*
+ * Hardware Related Config
+ */
+
+//#define SUPPORT_HW_RFOFF_DETECTED
+
+//#define CONFIG_SW_LED
+
+/*
+ * Interface Related Config
+ */
+#define CONFIG_TX_AGGREGATION
+//#define CONFIG_SDIO_TX_TASKLET
+#define CONFIG_SDIO_RX_COPY
+#define CONFIG_SDIO_TX_ENABLE_AVAL_INT
+
+/*
+ * Others
+ */
+//#define CONFIG_MAC_LOOPBACK_DRIVER
+
+
+/*
+ * Auto Config Section
+ */
+#if defined(CONFIG_RTL8188E) && defined(CONFIG_SDIO_HCI)
+#define CONFIG_RTL8188E_SDIO 
+#define CONFIG_XMIT_THREAD_MODE
+#endif
+
+#define CONFIG_IPS
+#define CONFIG_LPS
+#if defined(CONFIG_LPS) && defined(CONFIG_SDIO_HCI)
+#define CONFIG_LPS_LCLK
+
+#ifdef CONFIG_LPS_LCLK
+#define LPS_RPWM_WAIT_MS 300
+
+//#define CONFIG_DETECT_CPWM_BY_POLLING
+//#define CONFIG_LPS_RPWM_TIMER
+
+#if defined(CONFIG_LPS_RPWM_TIMER) || defined(CONFIG_DETECT_CPWM_BY_POLLING)
+#define LPS_RPWM_WAIT_MS 300
+#endif
+//#define CONFIG_LPS_LCLK_WD_TIMER // Watch Dog timer in LPS LCLK
+#endif
+	
+#endif
+
+#ifdef CONFIG_MAC_LOOPBACK_DRIVER
+#undef CONFIG_AP_MODE
+#undef CONFIG_NATIVEAP_MLME
+#undef CONFIG_POWER_SAVING
+#undef SUPPORT_HW_RFOFF_DETECTED
+#endif
+
+#ifdef CONFIG_MP_INCLUDED
+
+	#define MP_DRIVER		1
+	#define CONFIG_MP_IWPRIV_SUPPORT
+
+	// disable unnecessary functions for MP
+	//#undef CONFIG_IPS
+	//#undef CONFIG_LPS
+	//#undef CONFIG_LPS_LCLK
+	//#undef SUPPORT_HW_RFOFF_DETECTED
+
+#else// #ifdef CONFIG_MP_INCLUDED
+
+	#define MP_DRIVER		0
+	
+#endif // #ifdef CONFIG_MP_INCLUDED
+
+#define CONFIG_IOL
+#ifdef CONFIG_IOL
+	#define CONFIG_IOL_NEW_GENERATION
+	#define CONFIG_IOL_READ_EFUSE_MAP
+	//#define DBG_IOL_READ_EFUSE_MAP
+	//#define CONFIG_IOL_LLT
+	#define CONFIG_IOL_EFUSE_PATCH
+	//#define CONFIG_IOL_IOREG_CFG
+	//#define CONFIG_IOL_IOREG_CFG_DBG
+#endif
+
+#ifdef CONFIG_WOWLAN
+#define CONFIG_ARP_KEEP_ALIVE
+#endif
+
+/*
+ * Outsource  Related Config
+ */
+#define TESTCHIP_SUPPORT				0
+
+#define 	RTL8192CE_SUPPORT 				0
+#define 	RTL8192CU_SUPPORT 			0
+#define 	RTL8192C_SUPPORT 				(RTL8192CE_SUPPORT|RTL8192CU_SUPPORT)	
+
+#define 	RTL8192DE_SUPPORT 				0
+#define 	RTL8192DU_SUPPORT 			0
+#define 	RTL8192D_SUPPORT 				(RTL8192DE_SUPPORT|RTL8192DU_SUPPORT)	
+
+#define 	RTL8723_FPGA_VERIFICATION		0
+#define 	RTL8723AU_SUPPORT				0
+#define 	RTL8723AS_SUPPORT				0
+#define 	RTL8723AE_SUPPORT				0
+#define 	RTL8723A_SUPPORT				(RTL8723AU_SUPPORT|RTL8723AS_SUPPORT|RTL8723AE_SUPPORT)
+
+#define 	RTL8188E_SUPPORT				1
+#define 	RTL8812A_SUPPORT				0
+#define 	RTL8821A_SUPPORT				0
+#define 	RTL8723B_SUPPORT				0
+#define 	RTL8192E_SUPPORT				0
+#define 	RTL8814A_SUPPORT				0
+#define 	RTL8195A_SUPPORT				0
+
+//#if (RTL8188E_SUPPORT==1)
+#define RATE_ADAPTIVE_SUPPORT 			1
+#define POWER_TRAINING_ACTIVE			1
+
+//#define 	CONFIG_TX_EARLY_MODE
+#ifdef CONFIG_TX_EARLY_MODE
+#define	RTL8188E_EARLY_MODE_PKT_NUM_10	0
+#endif
+//#endif
+
+#define CONFIG_ATTEMPT_TO_FIX_AP_BEACON_ERROR
+
+/*
+ * HAL	Related Config
+ */
+
+//for FPGA VERIFICATION config
+#define RTL8188E_FPGA_TRUE_PHY_VERIFICATION 0
+
+#define DISABLE_BB_RF	0
+
+#define CONFIG_RF_GAIN_OFFSET
+#define CONFIG_80211D
+
+#ifdef CONFIG_GPIO_WAKEUP
+#define WAKEUP_GPIO_IDX 7
+#endif
+
+#define CONFIG_GPIO_API
+
+/*
+ * Debug Related Config
+ */
+#define DBG	0
+
+#define CONFIG_DEBUG /* DBG_871X, etc... */
+//#define CONFIG_DEBUG_RTL871X /* RT_TRACE, RT_PRINT_DATA, _func_enter_, _func_exit_ */
+
+#define CONFIG_PROC_DEBUG
+
+#define DBG_CONFIG_ERROR_DETECT
+#define DBG_CONFIG_ERROR_RESET
+
+//#define DBG_IO
+//#define DBG_DELAY_OS
+//#define DBG_MEM_ALLOC
+//#define DBG_IOCTL
+
+//#define DBG_TX
+//#define DBG_XMIT_BUF
+//#define DBG_XMIT_BUF_EXT
+//#define DBG_TX_DROP_FRAME
+
+//#define DBG_RX_DROP_FRAME
+//#define DBG_RX_SEQ
+//#define DBG_RX_SIGNAL_DISPLAY_PROCESSING
+//#define DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED "jeff-ap"
+
+
+//#define DOWNLOAD_FW_TO_TXPKT_BUF 0
+
+//#define DBG_HAL_INIT_PROFILING
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/drv_conf.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/drv_conf.h
index a793f208d26c..09befee96811 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/drv_conf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/drv_conf.h
@@ -45,6 +45,7 @@
 //Android expect dbm as the rx signal strength unit
 #define CONFIG_SIGNAL_DISPLAY_DBM
 #endif
+
 /*
 #if defined(CONFIG_HAS_EARLYSUSPEND) && defined (CONFIG_RESUME_IN_WORKQUEUE)
 	#warning "You have CONFIG_HAS_EARLYSUSPEND enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
@@ -56,6 +57,7 @@
 	#undef CONFIG_RESUME_IN_WORKQUEUE
 #endif
 */
+
 #ifdef CONFIG_RESUME_IN_WORKQUEUE //this can be removed, because there is no case for this...
 	#if !defined( CONFIG_WAKELOCK) && !defined(CONFIG_ANDROID_POWER)
 	#error "enable CONFIG_RESUME_IN_WORKQUEUE without CONFIG_WAKELOCK or CONFIG_ANDROID_POWER will suffer from the danger of wifi's unfunctionality..."
@@ -75,6 +77,33 @@
 
 #define DYNAMIC_CAMID_ALLOC
 
+#ifndef CONFIG_RTW_HIQ_FILTER
+	#define CONFIG_RTW_HIQ_FILTER 1
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_EN
+	#define CONFIG_RTW_ADAPTIVITY_EN 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_MODE
+	#define CONFIG_RTW_ADAPTIVITY_MODE 0
+#endif
+
+#ifndef CONFIG_RTW_NHM_EN
+	#define CONFIG_RTW_NHM_EN 0
+#endif
+
+#ifndef CONFIG_RTW_AMPLIFIER_TYPE_2G
+	#define CONFIG_RTW_AMPLIFIER_TYPE_2G 0
+#endif
+
+#ifndef CONFIG_RTW_AMPLIFIER_TYPE_5G
+	#define CONFIG_RTW_AMPLIFIER_TYPE_5G 0
+#endif
+
+#define MACID_NUM_SW_LIMIT 32
+#define CAM_ENTRY_NUM_SW_LIMIT 32
+
 //#include <rtl871x_byteorder.h>
 
 #endif // __DRV_CONF_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/drv_types.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/drv_types.h
index 1dedbad7435f..b42c42bab969 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/drv_types.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/drv_types.h
@@ -60,8 +60,6 @@ enum _NIC_VERSION {
 
 };
 
-#define CONFIG_SUSPEND_REFINE	
-
 typedef struct _ADAPTER _adapter, ADAPTER,*PADAPTER;
 
 #include <rtw_debug.h>
@@ -96,6 +94,7 @@ typedef struct _ADAPTER _adapter, ADAPTER,*PADAPTER;
 #include <hal_intf.h>
 #include <hal_com.h>
 #include <hal_com_led.h>
+#include "../hal/hal_dm.h"
 #include <rtw_qos.h>
 #include <rtw_pwrctrl.h>
 #include <rtw_mlme.h>
@@ -115,6 +114,10 @@ typedef struct _ADAPTER _adapter, ADAPTER,*PADAPTER;
 #include <rtw_version.h>
 #include <rtw_odm.h>
 
+#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+#include <rtw_mem.h>
+#endif
+
 #ifdef CONFIG_P2P
 #include <rtw_p2p.h>
 #endif // CONFIG_P2P
@@ -143,14 +146,6 @@ typedef struct _ADAPTER _adapter, ADAPTER,*PADAPTER;
 #include <rtw_iol.h>
 #endif // CONFIG_IOL
 
-#ifdef CONFIG_IOCTL_CFG80211
-#include "ioctl_cfg80211.h"
-#endif //CONFIG_IOCTL_CFG80211
-
-#ifdef CONFIG_RTL8188E  
-#include <Hal8188EPhyCfg.h>
-#endif
-
 #include <ip.h>
 #include <if_ether.h>
 #include <ethernet.h>
@@ -255,7 +250,7 @@ struct registry_priv
 	u8	low_power ;
 
 	u8	wifi_spec;// !turbo_mode
-
+	u8	special_rf_path; // 0: 2T2R ,1: only turn on path A 1T1R
 	u8	channel_plan;
 #ifdef CONFIG_BT_COEXIST
 	u8	btcoex;
@@ -327,12 +322,28 @@ struct registry_priv
 	u8 ext_iface_num;//primary/secondary iface is excluded
 #endif
 	u8 qos_opt_enable;
+
+	u8 hiq_filter;
+	u8 adaptivity_en;
+	u8 adaptivity_mode;
+	u8 nhm_en;
 };
 
 
 //For registry parameters
 #define RGTRY_OFT(field) ((ULONG)FIELD_OFFSET(struct registry_priv,field))
 #define RGTRY_SZ(field)   sizeof(((struct registry_priv*) 0)->field)
+
+#define GetRegAmplifierType2G(_Adapter)	(_Adapter->registrypriv.AmplifierType_2G)
+#define GetRegAmplifierType5G(_Adapter)	(_Adapter->registrypriv.AmplifierType_5G)
+
+#define GetRegTxBBSwing_2G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_2G)
+#define GetRegTxBBSwing_5G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_5G)
+
+#define GetRegbENRFEType(_Adapter)	(_Adapter->registrypriv.bEn_RFE)
+#define GetRegRFEType(_Adapter)	(_Adapter->registrypriv.RFE_Type)
+
+
 #define BSSID_OFT(field) ((ULONG)FIELD_OFFSET(WLAN_BSSID_EX,field))
 #define BSSID_SZ(field)   sizeof(((PWLAN_BSSID_EX) 0)->field)
 
@@ -359,6 +370,8 @@ struct registry_priv
 #define GET_IFACE_NUMS(padapter) (((_adapter *)padapter)->dvobj->iface_nums)
 #define GET_ADAPTER(padapter, iface_id) (((_adapter *)padapter)->dvobj->padapters[iface_id])
 
+#define GetDefaultAdapter(padapter)	padapter
+
 enum _IFACE_ID {
 	IFACE_ID0, //maping to PRIMARY_ADAPTER
 	IFACE_ID1, //maping to SECONDARY_ADAPTER
@@ -367,6 +380,131 @@ enum _IFACE_ID {
 	IFACE_ID_MAX,
 };
 
+#ifdef CONFIG_DBG_COUNTER
+
+struct rx_logs {
+	u32 intf_rx;
+	u32 intf_rx_err_recvframe;
+	u32 intf_rx_err_skb;
+	u32 intf_rx_report;
+	u32 core_rx;
+	u32 core_rx_pre;
+	u32 core_rx_pre_ver_err;
+	u32 core_rx_pre_mgmt;
+	u32 core_rx_pre_mgmt_err_80211w;
+	u32 core_rx_pre_mgmt_err;
+	u32 core_rx_pre_ctrl;
+	u32 core_rx_pre_ctrl_err;
+	u32 core_rx_pre_data;
+	u32 core_rx_pre_data_wapi_seq_err;
+	u32 core_rx_pre_data_wapi_key_err;
+	u32 core_rx_pre_data_handled;
+	u32 core_rx_pre_data_err;
+	u32 core_rx_pre_data_unknown;
+	u32 core_rx_pre_unknown;
+	u32 core_rx_enqueue;
+	u32 core_rx_dequeue;
+	u32 core_rx_post;
+	u32 core_rx_post_decrypt;
+	u32 core_rx_post_decrypt_wep;
+	u32 core_rx_post_decrypt_tkip;
+	u32 core_rx_post_decrypt_aes;
+	u32 core_rx_post_decrypt_wapi;
+	u32 core_rx_post_decrypt_hw;
+	u32 core_rx_post_decrypt_unknown;
+	u32 core_rx_post_decrypt_err;
+	u32 core_rx_post_defrag_err;
+	u32 core_rx_post_portctrl_err;
+	u32 core_rx_post_indicate;
+	u32 core_rx_post_indicate_in_oder;
+	u32 core_rx_post_indicate_reoder;
+	u32 core_rx_post_indicate_err;
+	u32 os_indicate;
+	u32 os_indicate_ap_mcast;
+	u32 os_indicate_ap_forward;
+	u32 os_indicate_ap_self;
+	u32 os_indicate_err;
+	u32 os_netif_ok;
+	u32 os_netif_err;
+};
+
+struct tx_logs {
+	u32 os_tx;
+	u32 os_tx_err_up;
+	u32 os_tx_err_xmit;
+	u32 os_tx_m2u;
+	u32 os_tx_m2u_ignore_fw_linked;
+	u32 os_tx_m2u_ignore_self;
+	u32 os_tx_m2u_entry;
+	u32 os_tx_m2u_entry_err_xmit;
+	u32 os_tx_m2u_entry_err_skb;
+	u32 os_tx_m2u_stop;
+	u32 core_tx;
+	u32 core_tx_err_pxmitframe;
+	u32 core_tx_err_brtx;
+	u32 core_tx_upd_attrib;
+	u32 core_tx_upd_attrib_adhoc;
+	u32 core_tx_upd_attrib_sta;
+	u32 core_tx_upd_attrib_ap;
+	u32 core_tx_upd_attrib_unknown;
+	u32 core_tx_upd_attrib_dhcp;
+	u32 core_tx_upd_attrib_icmp;
+	u32 core_tx_upd_attrib_active;
+	u32 core_tx_upd_attrib_err_ucast_sta;
+	u32 core_tx_upd_attrib_err_ucast_ap_link;
+	u32 core_tx_upd_attrib_err_sta;
+	u32 core_tx_upd_attrib_err_link;
+	u32 core_tx_upd_attrib_err_sec;
+	u32 core_tx_ap_enqueue_warn_fwstate;
+	u32 core_tx_ap_enqueue_warn_sta;
+	u32 core_tx_ap_enqueue_warn_nosta;
+	u32 core_tx_ap_enqueue_warn_link;
+	u32 core_tx_ap_enqueue_warn_trigger;
+	u32 core_tx_ap_enqueue_mcast;
+	u32 core_tx_ap_enqueue_ucast;
+	u32 core_tx_ap_enqueue;
+	u32 intf_tx;
+	u32 intf_tx_pending_ac;
+	u32 intf_tx_pending_fw_under_survey;
+	u32 intf_tx_pending_fw_under_linking;
+	u32 intf_tx_pending_xmitbuf;
+	u32 intf_tx_enqueue;
+	u32 core_tx_enqueue;
+	u32 core_tx_enqueue_class;
+	u32 core_tx_enqueue_class_err_sta;
+	u32 core_tx_enqueue_class_err_nosta;
+	u32 core_tx_enqueue_class_err_fwlink;
+	u32 intf_tx_direct;
+	u32 intf_tx_direct_err_coalesce;
+	u32 intf_tx_dequeue;
+	u32 intf_tx_dequeue_err_coalesce;
+	u32 intf_tx_dump_xframe;
+	u32 intf_tx_dump_xframe_err_txdesc;
+	u32 intf_tx_dump_xframe_err_port;
+};
+
+struct int_logs {
+	u32 all;
+	u32 err;
+	u32 tbdok;
+	u32 tbder;
+	u32 bcnderr;
+	u32 bcndma;
+	u32 bcndma_e;
+	u32 rx;
+	u32 rx_rdu;
+	u32 rx_fovw;
+	u32 txfovw;
+	u32 mgntok;
+	u32 highdok;
+	u32 bkdok;
+	u32 bedok;
+	u32 vidok;
+	u32 vodok;
+};
+
+#endif // CONFIG_DBG_COUNTER
+
 struct debug_priv {
 	u32 dbg_sdio_free_irq_error_cnt;
 	u32 dbg_sdio_alloc_irq_error_cnt;
@@ -441,6 +579,28 @@ struct cam_entry_cache {
 	((u8*)(x))[6],((u8*)(x))[7],((u8*)(x))[8],((u8*)(x))[9],((u8*)(x))[10],((u8*)(x))[11], \
 	((u8*)(x))[12],((u8*)(x))[13],((u8*)(x))[14],((u8*)(x))[15]
 
+struct macid_bmp {
+	u32 m0;
+#if (MACID_NUM_SW_LIMIT > 32)
+	u32 m1;
+#endif
+#if (MACID_NUM_SW_LIMIT > 64)
+	u32 m2;
+#endif
+#if (MACID_NUM_SW_LIMIT > 96)
+	u32 m3;
+#endif
+};
+
+struct macid_ctl_t {
+	_lock lock;
+	u8 num;
+	struct macid_bmp used;
+	struct macid_bmp bmc;
+	struct macid_bmp if_g[IFACE_ID_MAX];
+	struct macid_bmp ch_g[2]; /* 2 ch concurrency */
+};
+
 struct dvobj_priv
 {
 	/*-------- below is common data --------*/	
@@ -451,11 +611,6 @@ struct dvobj_priv
 
 	struct debug_priv drv_dbg;
 
-	//for local/global synchronization
-	//
-	_lock	lock;
-	int macid[NUM_STA];
-
 	_mutex hw_init_mutex;
 	_mutex h2c_fwcmd_mutex;
 	_mutex setch_mutex;
@@ -471,7 +626,9 @@ struct dvobj_priv
 	//padapters[IFACE_ID1] == if2
 	_adapter *padapters[IFACE_ID_MAX];
 	u8 iface_nums; // total number of ifaces used runtime
-	
+
+	struct macid_ctl_t macid_ctl;
+
 	struct cam_ctl_t cam_ctl;
 	struct cam_entry_cache cam_cache[TOTAL_CAM_ENTRY];
 
@@ -600,6 +757,7 @@ struct dvobj_priv
 
 #define dvobj_to_pwrctl(dvobj) (&(dvobj->pwrctl_priv))
 #define pwrctl_to_dvobj(pwrctl) container_of(pwrctl, struct dvobj_priv, pwrctl_priv)
+#define dvobj_to_macidctl(dvobj) (&(dvobj->macid_ctl))
 
 #ifdef PLATFORM_LINUX
 static struct device *dvobj_to_dev(struct dvobj_priv *dvobj)
@@ -748,7 +906,9 @@ struct _ADAPTER{
 	u8	bDriverIsGoingToUnload;
 	u8	init_adpt_in_progress;
 	u8	bHaltInProgress;
-
+#ifdef CONFIG_GPIO_API	
+	u8	pre_gpio_pin;
+#endif	
 	_thread_hdl_ cmdThread;
 	_thread_hdl_ evtThread;
 	_thread_hdl_ xmitThread;
@@ -882,9 +1042,22 @@ struct _ADAPTER{
 	PLOOPBACKDATA ploopback;
 #endif
 
+	//for debug purpose
 	u8 fix_rate;
-
+	u8 data_fb; /* data rate fallback, valid only when fix_rate is not 0xff */
+	u8 driver_vcs_en; //Enable=1, Disable=0 driver control vrtl_carrier_sense for tx
+	u8 driver_vcs_type;//force 0:disable VCS, 1:RTS-CTS, 2:CTS-to-self when vcs_en=1.
+	u8 driver_ampdu_spacing;//driver control AMPDU Density for peer sta's rx
+	u8 driver_rx_ampdu_factor;//0xff: disable drv ctrl, 0:8k, 1:16k, 2:32k, 3:64k;
+	u8 fix_ba_rxbuf_bz; /* 0~127, TODO:consider each sta and each TID */
+	u8 driver_rx_ampdu_spacing;  //driver control Rx AMPDU Density 
 	unsigned char     in_cta_test;
+
+#ifdef CONFIG_DBG_COUNTER	
+	struct rx_logs rx_logs;
+	struct tx_logs tx_logs;
+	struct int_logs int_logs;
+#endif
 };
 
 #define adapter_to_dvobj(adapter) (adapter->dvobj)
@@ -941,11 +1114,11 @@ void rtw_dev_pno_debug(struct net_device *net);
 #endif //CONFIG_PNO_SET_DEBUG
 #endif //CONFIG_PNO_SUPPORT
 
-#ifdef CONFIG_GPIO_API
-int rtw_get_gpio(struct net_device *netdev, int gpio_num);
-int rtw_set_gpio_output_value(struct net_device *netdev, int gpio_num, BOOLEAN isHigh);
-int rtw_config_gpio(struct net_device *netdev, int gpio_num, BOOLEAN isOutput);
+#ifdef CONFIG_WOWLAN
+int rtw_suspend_wow(_adapter *padapter);
+int rtw_resume_process_wow(_adapter *padapter);
 #endif
+
 __inline static u8 *myid(struct eeprom_priv *peepriv)
 {
 	return (peepriv->mac_addr);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/gspi_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/gspi_hal.h
index efe1afbac8ac..77a16f5a0d18 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/gspi_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/gspi_hal.h
@@ -21,7 +21,7 @@
 #define __GSPI_HAL_H__
 
 
-void spi_int_dpc(PADAPTER padapter);
+void spi_int_dpc(PADAPTER padapter, u32 sdio_hisr);
 void rtw_set_hal_ops(_adapter *padapter);
 
 #ifdef CONFIG_RTL8723A
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/gspi_ops.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/gspi_ops.h
index 1e77ccc183b7..c280503029bc 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/gspi_ops.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/gspi_ops.h
@@ -156,6 +156,7 @@ void rtl8188es_set_hal_ops(PADAPTER padapter);
 #define set_hal_ops rtl8188es_set_hal_ops
 #endif
 extern void spi_set_chip_endian(PADAPTER padapter);
+extern unsigned int spi_write8_endian(ADAPTER *Adapter, unsigned int addr, unsigned int buf, u32 big);
 extern void spi_set_intf_ops(_adapter *padapter,struct _io_ops *pops);
 extern void spi_set_chip_endian(PADAPTER padapter);
 extern void InitInterrupt8723ASdio(PADAPTER padapter);
@@ -164,9 +165,6 @@ extern void EnableInterrupt8723ASdio(PADAPTER padapter);
 extern void DisableInterrupt8723ASdio(PADAPTER padapter);
 extern void spi_int_hdl(PADAPTER padapter);
 extern u8 HalQueryTxBufferStatus8723ASdio(PADAPTER padapter);
-extern void InitInterrupt8188ESdio(PADAPTER padapter);
-extern void EnableInterrupt8188ESdio(PADAPTER padapter);
-extern void DisableInterrupt8188ESdio(PADAPTER padapter);
 #ifdef CONFIG_RTL8723B
 extern void InitInterrupt8723BSdio(PADAPTER padapter);
 extern void InitSysInterrupt8723BSdio(PADAPTER padapter);
@@ -175,4 +173,18 @@ extern void DisableInterrupt8723BSdio(PADAPTER padapter);
 extern u8 HalQueryTxBufferStatus8723BSdio(PADAPTER padapter);
 #endif
 
+#ifdef CONFIG_RTL8188E
+extern void InitInterrupt8188EGspi(PADAPTER padapter);
+extern void EnableInterrupt8188EGspi(PADAPTER padapter);
+extern void DisableInterrupt8188EGspi(PADAPTER padapter);
+extern void UpdateInterruptMask8188EGspi(PADAPTER padapter, u32 AddMSR, u32 RemoveMSR);
+extern u8 HalQueryTxBufferStatus8189EGspi(PADAPTER padapter);
+extern u8 HalQueryTxOQTBufferStatus8189EGspi(PADAPTER padapter);
+extern void ClearInterrupt8188EGspi(PADAPTER padapter);
+extern u8 CheckIPSStatus(PADAPTER padapter);
+#endif // CONFIG_RTL8188E
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+extern u8 RecvOnePkt(PADAPTER padapter, u32 size);
+#endif // CONFIG_WOWLAN
+
 #endif //__GSPI_OPS_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_btcoex.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_btcoex.h
index 206fcb783ca5..84aa63ac49bf 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_btcoex.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_btcoex.h
@@ -30,6 +30,7 @@ typedef struct _BT_COEXIST
 	u8 btTotalAntNum;
 	u8 btChipType;
 	u8 bInitlized;
+	u8 btAntisolation;
 } BT_COEXIST, *PBT_COEXIST;
 
 void DBG_BT_INFO(u8 *dbgmsg);
@@ -39,11 +40,14 @@ u8 hal_btcoex_IsBtExist(PADAPTER padapter);
 u8 hal_btcoex_IsBtDisabled(PADAPTER);
 void hal_btcoex_SetChipType(PADAPTER padapter, u8 chipType);
 u8 hal_btcoex_GetChipType(PADAPTER padapter);
-void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum, BOOLEAN antInverse);
+void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum);
 u8 hal_btcoex_GetPgAntNum(PADAPTER padapter);
+void hal_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath);
 
 u8 hal_btcoex_Initialize(PADAPTER padapter);
-void hal_btcoex_InitHwConfig(PADAPTER padapter);
+void hal_btcoex_PowerOnSetting(PADAPTER padapter);
+void hal_btcoex_PreLoadFirmware(PADAPTER padapter);
+void hal_btcoex_InitHwConfig(PADAPTER padapter, u8 bWifiOnly);
 
 void hal_btcoex_IpsNotify(PADAPTER padapter, u8 type);
 void hal_btcoex_LpsNotify(PADAPTER padapter, u8 type);
@@ -55,7 +59,7 @@ void hal_btcoex_IQKNotify(PADAPTER padapter, u8 state);
 void hal_btcoex_BtInfoNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
 void hal_btcoex_SuspendNotify(PADAPTER padapter, u8 state);
 void hal_btcoex_HaltNotify(PADAPTER padapter);
-void hal_btcoex_SwitchGntBt(PADAPTER padapter);
+void hal_btcoex_SwitchBtTRxMask(PADAPTER padapter);
 
 void hal_btcoex_Hanlder(PADAPTER padapter);
 
@@ -74,6 +78,10 @@ void hal_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
 u32 hal_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
 u8 hal_btcoex_IncreaseScanDeviceNum(PADAPTER);
 u8 hal_btcoex_IsBtLinkExist(PADAPTER);
-
+void hal_btcoex_SetAntIsolationType(PADAPTER padapter, u8 anttype);
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+int hal_btcoex_AntIsolationConfig_ParaFile(IN PADAPTER	Adapter,IN char* pFileName);
+int hal_btcoex_ParseAntIsolationConfigFile(PADAPTER Adapter, char*	buffer);
+#endif // CONFIG_LOAD_PHY_PARA_FROM_FILE
 #endif // !__HAL_BTCOEX_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com.h
index 5af576813692..493ffea980f0 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com.h
@@ -189,6 +189,17 @@ typedef enum _FIRMWARE_SOURCE {
 	FW_SOURCE_HEADER_FILE = 1,		//from header file
 } FIRMWARE_SOURCE, *PFIRMWARE_SOURCE;
 
+//
+// Queue Select Value in TxDesc
+//
+#define QSLT_BK							0x2//0x01
+#define QSLT_BE							0x0
+#define QSLT_VI							0x5//0x4
+#define QSLT_VO							0x7//0x6
+#define QSLT_BEACON						0x10
+#define QSLT_HIGH						0x11
+#define QSLT_MGNT						0x12
+#define QSLT_CMD						0x13
 
 // BK, BE, VI, VO, HCCA, MANAGEMENT, COMMAND, HIGH, BEACON.
 //#define MAX_TX_QUEUE		9
@@ -204,6 +215,9 @@ typedef enum _FIRMWARE_SOURCE {
 #define PageNum(_Len, _Size)		(u32)(((_Len)/(_Size)) + ((_Len)&((_Size) - 1) ? 1:0))
 
 
+u8 rtw_hal_data_init(_adapter *padapter);
+void rtw_hal_data_deinit(_adapter *padapter);
+
 void dump_chip_info(HAL_VERSION	ChipVersion);
 
 u8	//return the final channel plan decision
@@ -322,10 +336,56 @@ void rtw_store_phy_info(_adapter *padapter, union recv_frame *prframe);
 void rtw_dump_raw_rssi_info(_adapter *padapter);
 #endif
 
+#define		HWSET_MAX_SIZE			512
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+#define		EFUSE_FILE_COLUMN_NUM		16
+u32 Hal_readPGDataFromConfigFile(PADAPTER padapter, struct file *fp);
+void Hal_ReadMACAddrFromFile(PADAPTER padapter, struct file *fp);
+void Hal_GetPhyEfuseMACAddr(PADAPTER padapter, u8* mac_addr);
+int check_phy_efuse_tx_power_info_valid(PADAPTER padapter);
+int check_phy_efuse_macaddr_info_valid(PADAPTER padapter);
+#endif //CONFIG_EFUSE_CONFIG_FILE
 
 #ifdef CONFIG_RF_GAIN_OFFSET
 void rtw_bb_rf_gain_offset(_adapter *padapter);
 #endif //CONFIG_RF_GAIN_OFFSET
+
+void dm_DynamicUsbTxAgg(_adapter *padapter, u8 from_timer);
 u8 rtw_hal_busagg_qsel_check(_adapter *padapter,u8 pre_qsel,u8 next_qsel);
+void GetHalODMVar(	
+	PADAPTER				Adapter,
+	HAL_ODM_VARIABLE		eVariable,
+	PVOID					pValue1,
+	PVOID					pValue2);
+void SetHalODMVar(
+	PADAPTER				Adapter,
+	HAL_ODM_VARIABLE		eVariable,
+	PVOID					pValue1,
+	BOOLEAN					bSet);
+
+#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+struct noise_info
+{
+	u8 		bPauseDIG;
+	u8 		IGIValue;
+	u32 	max_time;//ms	
+	u8		chan;
+};
+#endif
+
+void rtw_hal_set_fw_rsvd_page(_adapter* adapter, bool finished);
+
+#ifdef CONFIG_GPIO_API
+u8 rtw_hal_get_gpio(_adapter* adapter, u8 gpio_num);
+int rtw_hal_set_gpio_output_value(_adapter* adapter, u8 gpio_num, BOOLEAN isHigh);
+int rtw_hal_config_gpio(_adapter* adapter, u8 gpio_num, BOOLEAN isOutput);
+#endif
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+extern char *rtw_phy_file_path;
+extern char file_path[PATH_LENGTH_MAX];
+#define GetLineFromBuffer(buffer)   strsep(&buffer, "\n")
+#endif
+
 #endif //__HAL_COMMON_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_h2c.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_h2c.h
index 7983e4b1af33..bc473acdf9f4 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_h2c.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_h2c.h
@@ -80,11 +80,14 @@ enum h2c_cmd{
 	H2C_D0_SCAN_OFFLOAD_INFO = 0x86,
 	H2C_CHNL_SWITCH_OFFLOAD = 0x87,
 	H2C_AOAC_RSVDPAGE3 = 0x88,
+	H2C_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
+	H2C_P2P_OFFLOAD = 0x8B,
 
 	H2C_RESET_TSF = 0xC0,
 	H2C_MAXID,
 };
 
+#define H2C_INACTIVE_PS_LEN		3
 #define H2C_RSVDPAGE_LOC_LEN		5
 #define H2C_MEDIA_STATUS_RPT_LEN		3
 #define H2C_KEEP_ALIVE_CTRL_LEN	2
@@ -96,7 +99,7 @@ enum h2c_cmd{
 #define H2C_PSTUNEPARAM_LEN			4
 #define H2C_MACID_CFG_LEN	 	7
 #define H2C_BTMP_OPER_LEN			4
-#define H2C_WOWLAN_LEN			4
+#define H2C_WOWLAN_LEN			5
 #define H2C_REMOTE_WAKE_CTRL_LEN	3
 #define H2C_AOAC_GLOBAL_INFO_LEN	2
 #define H2C_AOAC_RSVDPAGE_LOC_LEN	7
@@ -107,6 +110,8 @@ enum h2c_cmd{
 #define H2C_FORCE_BT_TXPWR_LEN		3
 #define H2C_BCN_RSVDPAGE_LEN		5
 #define H2C_PROBERSP_RSVDPAGE_LEN	5
+#define H2C_P2PRSVDPAGE_LOC_LEN	5
+#define H2C_P2P_OFFLOAD_LEN	3
 
 #ifdef CONFIG_WOWLAN	
 #define eqMacAddr(a,b)						( ((a)[0]==(b)[0] && (a)[1]==(b)[1] && (a)[2]==(b)[2] && (a)[3]==(b)[3] && (a)[4]==(b)[4] && (a)[5]==(b)[5]) ? 1:0 )
@@ -187,7 +192,6 @@ enum h2c_cmd{
 #define SET_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+1, 0, 8, __Value)
 #define SET_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+2, 0, 8, __Value)
 
-#ifdef CONFIG_AP_WOWLAN
 //_AP_Offload 0x08
 #define SET_H2CCMD_AP_WOWLAN_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
 //_BCN_RsvdPage	0x09
@@ -207,7 +211,6 @@ enum h2c_cmd{
 #define SET_H2CCMD_AP_WOW_PS_32K_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
 #define SET_H2CCMD_AP_WOW_PS_RF(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
 #define SET_H2CCMD_AP_WOW_PS_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+1, 0, 8, __Value)
-#endif
 
 // _WoWLAN PARAM_CMD_0x80
 #define SET_H2CCMD_WOWLAN_FUNC_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
@@ -221,8 +224,9 @@ enum h2c_cmd{
 #define SET_H2CCMD_WOWLAN_GPIONUM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 7, __Value)
 #define SET_H2CCMD_WOWLAN_DATAPIN_WAKE_UP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 7, 1, __Value)
 #define SET_H2CCMD_WOWLAN_GPIO_DURATION(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
-//#define SET_H2CCMD_WOWLAN_GPIO_PULSE_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 1, __Value)
-#define SET_H2CCMD_WOWLAN_GPIO_PULSE_COUNT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_PULSE_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 1, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_PULSE_COUNT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 1, 7, __Value)
+#define SET_H2CCMD_WOWLAN_LOWPR_RX(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 1, __Value)
 
 // _REMOTE_WAKEUP_CMD_0x81
 #define SET_H2CCMD_REMOTE_WAKECTRL_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
@@ -231,6 +235,7 @@ enum h2c_cmd{
 #define SET_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
 #define SET_H2CCMD_REMOTE_WAKE_CTRL_NLO_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
 #define SET_H2CCMD_REMOTE_WAKE_CTRL_FW_UNICAST_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 1, __Value)
 #define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_ACTION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 1, __Value)
 
 // AOAC_GLOBAL_INFO_0x82
@@ -258,6 +263,15 @@ enum h2c_cmd{
 #define SET_H2CCMD_AOAC_RSVDPAGE_LOC_SSID_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
 #endif //CONFIG_PNO_SUPPORT
 
+#ifdef CONFIG_P2P_WOWLAN
+//P2P_RsvdPage_0x8a
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_BCN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PROBE_RSP(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_NEGO_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_INVITE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PD_RSP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+#endif //CONFIG_P2P_WOWLAN
+
 //---------------------------------------------------------------------------------------------------------//
 //-------------------------------------------    Structure    --------------------------------------------------//
 //---------------------------------------------------------------------------------------------------------//
@@ -285,16 +299,31 @@ typedef struct _RSVDPAGE_LOC {
 	u8 LocProbePacket;
 #endif //CONFIG_PNO_SUPPORT
 #endif //CONFIG_WOWLAN	
-#ifdef CONFIG_AP_WOWLAN
 	u8 LocApOffloadBCN;
-#endif //CONFIG_AP_WOWLAN
+#ifdef CONFIG_P2P_WOWLAN
+	u8 LocP2PBeacon;
+	u8 LocP2PProbeRsp;
+	u8 LocNegoRsp;
+	u8 LocInviteRsp;
+	u8 LocPDRsp;
+#endif //CONFIG_P2P_WOWLAN
 } RSVDPAGE_LOC, *PRSVDPAGE_LOC;
 
 #endif
 void dump_TX_FIFO(PADAPTER padapter, u8 page_num, u16 page_size);
 u8 rtw_check_invalid_mac_address (u8 *mac_addr);
+u8 rtw_hal_set_fw_media_status_cmd(_adapter* adapter, u8 mstatus, u8 macid);
 #if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
 void rtw_get_current_ip_address(PADAPTER padapter, u8 *pcurrentip);
 void rtw_get_sec_iv(PADAPTER padapter, u8*pcur_dot11txpn, u8 *StaAddr);
 void rtw_set_sec_pn(_adapter *padapter);
+
+//WOW command function
+void rtw_hal_set_fw_wow_related_cmd(_adapter* padapter, u8 enable);
+#ifdef CONFIG_P2P_WOWLAN
+//H2C 0x8A
+u8 rtw_hal_set_FwP2PRsvdPage_cmd(_adapter* adapter, PRSVDPAGE_LOC rsvdpageloc);
+//H2C 0x8B
+u8 rtw_hal_set_p2p_wowlan_offload_cmd(_adapter* adapter);
+#endif //CONFIG_P2P_WOWLAN
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_phycfg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_phycfg.h
index 6aaf8ec3e437..19276ea53628 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_phycfg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_phycfg.h
@@ -285,7 +285,9 @@ int PHY_ConfigRFWithParaFile(IN	PADAPTER	Adapter, IN char*	pFileName, IN u8	eRFP
 int PHY_ConfigRFWithTxPwrTrackParaFile(IN PADAPTER	Adapter, IN char*	pFileName);
 
 int PHY_ConfigRFWithPowerLimitTableParaFile(IN PADAPTER	Adapter, IN char*	pFileName);
-#endif
+
+void phy_free_filebuf(_adapter *padapter);
+#endif //CONFIG_LOAD_PHY_PARA_FROM_FILE
 
 
 #endif //__HAL_COMMON_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_reg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_reg.h
old mode 100644
new mode 100755
index 530065b70d20..6a0faf00c4ab
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_reg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_com_reg.h
@@ -226,13 +226,22 @@
 //	0x0400h ~ 0x047Fh	Protocol Configuration
 //
 //-----------------------------------------------------
-#define REG_VOQ_INFORMATION			0x0400
-#define REG_VIQ_INFORMATION			0x0404
-#define REG_BEQ_INFORMATION			0x0408
-#define REG_BKQ_INFORMATION			0x040C
-#define REG_MGQ_INFORMATION			0x0410
-#define REG_HGQ_INFORMATION			0x0414
-#define REG_BCNQ_INFORMATION			0x0418
+
+/* 92C, 92D */
+#define REG_VOQ_INFO	0x0400
+#define REG_VIQ_INFO	0x0404
+#define REG_BEQ_INFO	0x0408
+#define REG_BKQ_INFO	0x040C
+
+/* 88E, 8723A, 8812A, 8821A, 92E, 8723B */
+#define REG_Q0_INFO	0x400
+#define REG_Q1_INFO	0x404
+#define REG_Q2_INFO	0x408
+#define REG_Q3_INFO	0x40C
+
+#define REG_MGQ_INFO	0x0410
+#define REG_HGQ_INFO	0x0414
+#define REG_BCNQ_INFO	0x0418
 #define REG_TXPKT_EMPTY				0x041A
 #define REG_CPU_MGQ_INFORMATION		0x041C
 #define REG_FWHW_TXQ_CTRL				0x0420
@@ -258,22 +267,44 @@
 #define REG_FAST_EDCA_CTRL				0x0460
 #define REG_RD_RESP_PKT_TH				0x0463
 
+/* 8723A, 8812A, 8821A, 92E, 8723B */
+#define REG_Q4_INFO	0x468
+#define REG_Q5_INFO	0x46C
+#define REG_Q6_INFO	0x470
+#define REG_Q7_INFO	0x474
+
 #define REG_INIRTS_RATE_SEL				0x0480
 #define REG_INIDATA_RATE_SEL			0x0484
 
+/* 8723B, 92E, 8812A, 8821A*/
+#define REG_MACID_SLEEP_3				0x0484
+#define REG_MACID_SLEEP_1				0x0488
+
 #define REG_POWER_STAGE1				0x04B4
 #define REG_POWER_STAGE2				0x04B8
 #define REG_PKT_VO_VI_LIFE_TIME		0x04C0
 #define REG_PKT_BE_BK_LIFE_TIME		0x04C2
 #define REG_STBC_SETTING				0x04C4
 #define REG_QUEUE_CTRL					0x04C6
+#define REG_SINGLE_AMPDU_CTRL			0x04c7
 #define REG_PROT_MODE_CTRL			0x04C8
 #define REG_MAX_AGGR_NUM				0x04CA
 #define REG_RTS_MAX_AGGR_NUM			0x04CB
 #define REG_BAR_MODE_CTRL				0x04CC
 #define REG_RA_TRY_RATE_AGG_LMT		0x04CF
-#define REG_EARLY_MODE_CONTROL		0x04D0
-#define REG_MACID_SLEEP				0x04D4
+
+/* 8723A */
+#define REG_MACID_DROP	0x04D0
+
+/* 88E */
+#define REG_EARLY_MODE_CONTROL	0x04D0
+
+/* 8723B, 92E, 8812A, 8821A */
+#define REG_MACID_SLEEP_2	0x04D0
+
+/* 8723A, 8723B, 92E, 8812A, 8821A */
+#define REG_MACID_SLEEP	0x04D4
+
 #define REG_NQOS_SEQ					0x04DC
 #define REG_QOS_SEQ					0x04DE
 #define REG_NEED_CPU_HANDLE			0x04E0
@@ -638,6 +669,9 @@ Default: 00b.
 #define RRSR_MCS6				BIT18
 #define RRSR_MCS7				BIT19
 
+#define RRSR_CCK_RATES (RRSR_11M|RRSR_5_5M|RRSR_2M|RRSR_1M)
+#define RRSR_OFDM_RATES (RRSR_54M|RRSR_48M|RRSR_36M|RRSR_24M|RRSR_18M|RRSR_12M|RRSR_9M|RRSR_6M)
+
 // WOL bit information
 #define HAL92C_WOL_PTK_UPDATE_EVENT		BIT0
 #define HAL92C_WOL_GTK_UPDATE_EVENT		BIT1
@@ -762,14 +796,6 @@ Default: 00b.
 #define CAM_READ				0x00000000
 #define CAM_POLLINIG			BIT31
 
-#define SCR_UseDK				0x01
-#define SCR_TxSecEnable			0x02
-#define SCR_RxSecEnable			0x04
-
-#define SCR_UseDK				0x01
-#define SCR_TxSecEnable			0x02
-#define SCR_RxSecEnable			0x04
-
 //
 // 10. Power Save Control Registers	 
 //
@@ -1520,7 +1546,6 @@ Current IOREG MAP
 #define SCR_RXBCUSEDK			BIT(7)			// Force Rx Broadcast packets Use Default Key
 #define SCR_CHK_KEYID			BIT(8)
 
-
 //-----------------------------------------------------
 //
 //	SDIO Bus Specification
@@ -1722,7 +1747,7 @@ Current IOREG MAP
 // General definitions
 //========================================================
 
-#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188E		176
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188E(__Adapter)	   ( IS_VENDOR_8188E_I_CUT_SERIES(__Adapter) ? 255 : 175 )
 #define LAST_ENTRY_OF_TX_PKT_BUFFER_8812			255
 #define LAST_ENTRY_OF_TX_PKT_BUFFER_8723B		255
 #define LAST_ENTRY_OF_TX_PKT_BUFFER_8192C		255
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_data.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_data.h
old mode 100644
new mode 100755
index 2b7014d3c00f..ac6007e8977e
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_data.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_data.h
@@ -22,7 +22,7 @@
 
 #if 1//def  CONFIG_SINGLE_IMG
 
-#include "../hal/OUTSRC/odm_precomp.h"
+#include "../hal/OUTSRC/phydm_precomp.h"
 #ifdef CONFIG_BT_COEXIST
 #include <hal_btcoex.h>
 #endif
@@ -30,7 +30,9 @@
 #ifdef CONFIG_SDIO_HCI
 #include <hal_sdio.h>
 #endif
-
+#ifdef CONFIG_GSPI_HCI
+#include <hal_gspi.h>
+#endif
 //
 // <Roger_Notes> For RTL8723 WiFi/BT/GPS multi-function configuration. 2010.10.06.
 //
@@ -73,6 +75,22 @@ typedef	enum _INTERFACE_SELECT_USB{
 	INTF_SEL5_USB_Combo_MF	= 5,		// USB WiFi+BT Multi-Function Combo, i.e., Proprietary layout(AS-VAU) which is the same as SDIO card
 } INTERFACE_SELECT_USB, *PINTERFACE_SELECT_USB;
 
+#ifdef CONFIG_USB_HCI
+//should be sync with INTERFACE_SELECT_USB
+typedef	enum _BOARD_TYPE_8192CUSB{
+	BOARD_USB_DONGLE 			= 0,		// USB dongle
+	BOARD_USB_High_PA 		= 1,		// USB dongle with high power PA
+	BOARD_MINICARD		  	= 2,		// Minicard
+	BOARD_USB_SOLO 		 	= 3,		// USB solo-Slim module
+	BOARD_USB_COMBO			= 4,		// USB Combo-Slim module
+} BOARD_TYPE_8192CUSB, *PBOARD_TYPE_8192CUSB;
+
+#define	SUPPORT_HW_RADIO_DETECT(pHalData) \
+	(pHalData->BoardType == BOARD_MINICARD||\
+	pHalData->BoardType == BOARD_USB_SOLO||\
+	pHalData->BoardType == BOARD_USB_COMBO)
+#endif
+
 typedef enum _RT_AMPDU_BRUST_MODE{
 	RT_AMPDU_BRUST_NONE 		= 0,
 	RT_AMPDU_BRUST_92D 		= 1,
@@ -245,6 +263,7 @@ struct dm_priv
 
 	// Add for Reading Initial Data Rate SEL Register 0x484 during watchdog. Using for fill tx desc. 2011.3.21 by Thomas
 	u8	INIDATA_RATE[32];
+	_lock IQKSpinLock;
 };
 
 
@@ -364,18 +383,18 @@ typedef struct hal_com_data
 	u8	TxPwrLevelCck[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];
 	u8	TxPwrLevelHT40_1S[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
 	u8	TxPwrLevelHT40_2S[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
-	u8	TxPwrHt20Diff[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];// HT 20<->40 Pwr diff
+	s8	TxPwrHt20Diff[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];// HT 20<->40 Pwr diff
 	u8	TxPwrLegacyHtDiff[RF_PATH_MAX_92C_88E][CHANNEL_MAX_NUMBER];// For HT<->legacy pwr diff
 
 	// Power Limit Table for 2.4G
-	u8	TxPwrLimit_2_4G[MAX_REGULATION_NUM]
+	s8	TxPwrLimit_2_4G[MAX_REGULATION_NUM]
 						[MAX_2_4G_BANDWITH_NUM]
 	                                [MAX_RATE_SECTION_NUM]
 	                                [CHANNEL_MAX_NUMBER_2G]
 						[MAX_RF_PATH_NUM];
 
 	// Power Limit Table for 5G
-	u8	TxPwrLimit_5G[MAX_REGULATION_NUM]
+	s8	TxPwrLimit_5G[MAX_REGULATION_NUM]
 						[MAX_5G_BANDWITH_NUM]
 						[MAX_RATE_SECTION_NUM]
 						[CHANNEL_MAX_NUMBER_5G]
@@ -461,13 +480,13 @@ typedef struct hal_com_data
 	u8	RegReg542;
 	u8	RegCR_1;
 	u8	Reg837;
-	u8	RegRFPathS1;
 	u16	RegRRSR;
 
 	u8	CurAntenna;
 	u8	AntDivCfg;
 	u8	AntDetection;
 	u8	TRxAntDivType;
+	u8	ant_path; //for 8723B s0/s1 selection
 
 	u8	u1ForcedIgiLb;			// forced IGI lower bound
 
@@ -495,17 +514,17 @@ typedef struct hal_com_data
 	u8	p2p_ps_offload;
 #endif
 
-	u8	AMPDUDensity;
+	//u8	AMPDUDensity;
 
 	// Auto FSM to Turn On, include clock, isolation, power control for MAC only
 	u8	bMacPwrCtrlOn;
-
+	u8 	bDisableTXPowerTraining;
 	u8	RegIQKFWOffload;
 	struct submit_ctx 	iqk_sctx;
 
 	RT_AMPDU_BRUST		AMPDUBurstMode; //92C maybe not use, but for compile successfully
 
-#ifdef CONFIG_SDIO_HCI
+#if defined (CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 	//
 	// For SDIO Interface HAL related
 	//
@@ -593,6 +612,8 @@ typedef struct hal_com_data
 	
 	u8	bInterruptMigration;
 	u8	bDisableTxInt;
+
+	u16	RxTag;	
 #endif //CONFIG_PCI_HCI
 
 	struct dm_priv	dmpriv;
@@ -678,6 +699,14 @@ typedef struct hal_com_data
 	char *rf_tx_pwr_lmt;
 	u32	rf_tx_pwr_lmt_len;
 #endif
+
+#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+	s16 noise[ODM_MAX_CHANNEL_NUM];
+#endif
+
+	u8 macid_num;
+	u8 cam_entry_num;
+
 } HAL_DATA_COMMON, *PHAL_DATA_COMMON;
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_gspi.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_gspi.h
new file mode 100644
index 000000000000..f5880e274512
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_gspi.h
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_GSPI_H_
+#define __HAL_GSPI_H_
+
+#define ffaddr2deviceId(pdvobj, addr)	(pdvobj->Queue2Pipe[addr])
+
+u8 rtw_hal_gspi_max_txoqt_free_space(_adapter *padapter);
+u8 rtw_hal_gspi_query_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
+void rtw_hal_gspi_update_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
+void rtw_hal_set_gspi_tx_max_length(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ);
+u32 rtw_hal_get_gspi_tx_max_length(PADAPTER padapter, u8 queue_idx);
+
+#endif 
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_intf.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_intf.h
index bd455ea92cd5..458cb5e0b46c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_intf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_intf.h
@@ -146,6 +146,8 @@ typedef enum _HW_VARIABLES{
 	HW_VAR_DL_RSVD_PAGE,
 	HW_VAR_MACID_SLEEP,
 	HW_VAR_MACID_WAKEUP,
+	HW_VAR_DUMP_MAC_QUEUE_INFO,
+	HW_VAR_ASIX_IOT,
 	HW_VAR_MAX_AGGR_NUM,
 }HW_VARIABLES;
 
@@ -182,12 +184,15 @@ typedef enum _HAL_DEF_VARIABLE{
 	HAL_DEF_PCI_ASPM_OSC, // Support for ASPM OSC, added by Roger, 2013.03.27.
 	HAL_DEF_MACID_SLEEP, // Support for MACID sleep
 	HAL_DEF_DBG_RX_INFO_DUMP,
+	HAL_DEF_DBG_DIS_PWT, //disable Tx power training or not.
 }HAL_DEF_VARIABLE;
 
 typedef enum _HAL_ODM_VARIABLE{
 	HAL_ODM_STA_INFO,	
 	HAL_ODM_P2P_STATE,
 	HAL_ODM_WIFI_DISPLAY_STATE,
+	HAL_ODM_NOISE_MONITOR,
+	HAL_ODM_REGULATION,
 }HAL_ODM_VARIABLE;
 
 typedef enum _HAL_INTF_PS_FUNC{
@@ -254,7 +259,7 @@ struct hal_ops {
 	u8	(*GetHalDefVarHandler)(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
 	u8	(*SetHalDefVarHandler)(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
 
-	void	(*GetHalODMVarHandler)(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,BOOLEAN bSet);
+	void	(*GetHalODMVarHandler)(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,PVOID pValue2);
 	void	(*SetHalODMVarHandler)(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,BOOLEAN bSet);
 
 	void	(*UpdateRAMaskHandler)(_adapter *padapter, u32 mac_id, u8 rssi_level);
@@ -318,10 +323,13 @@ struct hal_ops {
 	void (*hal_reset_security_engine)(_adapter * adapter);
 	s32 (*c2h_handler)(_adapter *padapter, u8 *c2h_evt);
 	c2h_id_filter c2h_id_filter_ccx;
-
-#ifdef CONFIG_BT_COEXIST
 	s32 (*fill_h2c_cmd)(PADAPTER, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
-#endif // CONFIG_BT_COEXIST
+	void (*fill_fake_txdesc)(PADAPTER, u8 *pDesc, u32 BufferLen,
+			u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
+#ifdef CONFIG_WOWLAN
+	void (*hal_set_wowlan_fw)(_adapter *adapter, u8 sleep);
+#endif //CONFIG_WOWLAN
+	u8 (*hal_get_tx_buff_rsvd_page_num)(_adapter *adapter, bool wowlan);
 };
 
 typedef	enum _RT_EEPROM_TYPE{
@@ -395,6 +403,9 @@ typedef enum _HARDWARE_TYPE{
 #define	IS_HARDWARE_TYPE_8192D(_Adapter)			\
 (IS_HARDWARE_TYPE_8192DE(_Adapter) || IS_HARDWARE_TYPE_8192DU(_Adapter))
 
+#define IS_HARDWARE_TYPE_OLDER_THAN_8723A(_Adapter)	\
+(IS_HARDWARE_TYPE_8192D(_Adapter) || IS_HARDWARE_TYPE_8192C(_Adapter))
+
 //
 // RTL8723A Series
 //
@@ -413,6 +424,11 @@ typedef enum _HARDWARE_TYPE{
 #define	IS_HARDWARE_TYPE_8188E(_Adapter)	\
 (IS_HARDWARE_TYPE_8188EE(_Adapter) || IS_HARDWARE_TYPE_8188EU(_Adapter) || IS_HARDWARE_TYPE_8188ES(_Adapter))
 
+
+#define	IS_HARDWARE_TYPE_8188E_before(_Adapter)			\
+(IS_HARDWARE_TYPE_8192C(_Adapter) ||IS_HARDWARE_TYPE_8192D(_Adapter) ||IS_HARDWARE_TYPE_8723A(_Adapter))
+
+
 #define IS_HARDWARE_TYPE_OLDER_THAN_8812A(_Adapter)	\
 (IS_HARDWARE_TYPE_8192D(_Adapter) || IS_HARDWARE_TYPE_8192C(_Adapter) ||\
  IS_HARDWARE_TYPE_8723AE(_Adapter) || IS_HARDWARE_TYPE_8723AU(_Adapter) || IS_HARDWARE_TYPE_8723AS(_Adapter) ||\
@@ -531,7 +547,7 @@ u8 rtw_hal_set_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pVa
 u8 rtw_hal_get_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
 
 void rtw_hal_set_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,BOOLEAN bSet);
-void	rtw_hal_get_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,BOOLEAN bSet);
+void	rtw_hal_get_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1,PVOID pValue2);
 	
 void rtw_hal_enable_interrupt(_adapter *padapter);
 void rtw_hal_disable_interrupt(_adapter *padapter);
@@ -624,12 +640,10 @@ c2h_id_filter rtw_hal_c2h_id_filter_ccx(_adapter *adapter);
 
 s32 rtw_hal_is_disable_sw_channel_plan(PADAPTER padapter);
 
-s32 rtw_hal_macid_sleep(PADAPTER padapter, u32 macid);
-s32 rtw_hal_macid_wakeup(PADAPTER padapter, u32 macid);
+s32 rtw_hal_macid_sleep(PADAPTER padapter, u8 macid);
+s32 rtw_hal_macid_wakeup(PADAPTER padapter, u8 macid);
 
-#ifdef CONFIG_BT_COEXIST
 s32 rtw_hal_fill_h2c_cmd(PADAPTER, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
-#endif // CONFIG_BT_COEXIST
 
 #endif //__HAL_INTF_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_pg.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_pg.h
index 410b93d19733..9d9911f3cf3b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_pg.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/hal_pg.h
@@ -236,7 +236,7 @@
 #define EEPROM_MAC_ADDR_88EU					0xD7
 #define EEPROM_VID_88EU						0xD0
 #define EEPROM_PID_88EU						0xD2
-#define EEPROM_USB_OPTIONAL_FUNCTION0		0xD4 //92EU is the same
+#define EEPROM_USB_OPTIONAL_FUNCTION0		0xD4 //8192EU, 8812AU is the same
 #define EEPROM_USB_OPTIONAL_FUNCTION0_8811AU 0x104
 
 // RTL88ES
@@ -517,11 +517,9 @@
 #define EEPROM_Default_LNAType						0
 
 //New EFUSE deafult value
-#define EEPROM_DEFAULT_24G_INDEX		0x2D
-#define EEPROM_DEFAULT_24G_CCK_TX_INDEX		0x25
-#define EEPROM_DEFAULT_24G_BW40_TX_INDEX	0x28
+#define EEPROM_DEFAULT_24G_INDEX			0x2D
 #define EEPROM_DEFAULT_24G_HT20_DIFF		0X02
-#define EEPROM_DEFAULT_24G_OFDM_DIFF		0X02
+#define EEPROM_DEFAULT_24G_OFDM_DIFF	0X04
 
 #define EEPROM_DEFAULT_5G_INDEX			0X2A
 #define EEPROM_DEFAULT_5G_HT20_DIFF		0X00
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/ieee80211.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/ieee80211.h
index fc293c457598..5dfc421366cb 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/ieee80211.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/ieee80211.h
@@ -1671,13 +1671,18 @@ u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8
 #define for_each_ie(ie, buf, buf_len) \
 	for (ie = (void*)buf; (((u8*)ie) - ((u8*)buf) + 1) < buf_len; ie = (void*)(((u8*)ie) + *(((u8*)ie)+1) + 2))
 
-void dump_ies(u8 *buf, u32 buf_len);
-void dump_wps_ie(u8 *ie, u32 ie_len);
+void dump_ies(void *sel, u8 *buf, u32 buf_len);
+	
+#ifdef CONFIG_80211N_HT
+void dump_ht_cap_ie_content(void *sel, u8 *buf, u32 buf_len);
+#endif
+
+void dump_wps_ie(void *sel, u8 *ie, u32 ie_len);
 
 #ifdef CONFIG_P2P
 u32 rtw_get_p2p_merged_ies_len(u8 *in_ie, u32 in_len);
 int rtw_p2p_merge_ies(u8 *in_ie, u32 in_len, u8 *merge_ie);
-void dump_p2p_ie(u8 *ie, u32 ie_len);
+void dump_p2p_ie(void *sel, u8 *ie, u32 ie_len);
 u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen);
 u8 *rtw_get_p2p_ie_from_scan_queue(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen, u8 frame_type);
 u8 *rtw_get_p2p_attr(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *buf_attr, u32 *len_attr);
@@ -1687,7 +1692,7 @@ void rtw_WLAN_BSSID_EX_remove_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id);
 #endif
 
 #ifdef CONFIG_WFD
-void dump_wfd_ie(u8 *ie, u32 ie_len);
+void dump_wfd_ie(void *sel, u8 *ie, u32 ie_len);
 int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen);
 int rtw_get_wfd_ie_from_scan_queue(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen, u8 frame_type);
 int rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id ,u8 *attr_content, uint *attr_contentlen);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/linux/wireless.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/linux/wireless.h
index 955ea8d316e2..d79caeb592bc 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/linux/wireless.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/linux/wireless.h
@@ -35,7 +35,13 @@
 #endif
 
 /****************************** TYPES ******************************/
-
+#ifdef CONFIG_COMPAT
+struct compat_iw_point {
+         compat_caddr_t pointer;
+         __u16 length;
+         __u16 flags;
+};
+#endif
 /* --------------------------- SUBTYPES --------------------------- */
 /*
  *	For all data larger than 16 octets, we need to use a
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_intf.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_intf.h
index 40286ea4e01d..805f3b2f5eeb 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_intf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_intf.h
@@ -120,6 +120,11 @@ int rtw_ndev_notifier_register(void);
 void rtw_ndev_notifier_unregister(void);
 
 #include "../os_dep/linux/rtw_proc.h"
+
+#ifdef CONFIG_IOCTL_CFG80211
+#include "../os_dep/linux/ioctl_cfg80211.h"
+#endif //CONFIG_IOCTL_CFG80211
+
 #endif //PLATFORM_LINUX
 
 
@@ -154,11 +159,8 @@ void rtw_ndev_destructor(_nic_hdl ndev);
 int	rtw_gw_addr_query(_adapter *padapter);
 #endif
 
-#ifdef CONFIG_SUSPEND_REFINE
 int rtw_suspend_common(_adapter *padapter);
 int rtw_resume_common(_adapter *padapter);
-#endif
-
 
 #endif	//_OSDEP_INTF_H_
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_service.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_service.h
index d4cb887d650f..b5901766e262 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_service.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_service.h
@@ -118,7 +118,8 @@ enum mstat_f {
 	MSTAT_FUNC_RX_IO = 0x03<<8,
 	MSTAT_FUNC_TX = 0x04<<8,
 	MSTAT_FUNC_RX = 0x05<<8,
-	MSTAT_FUNC_MAX = 0x06<<8,
+	MSTAT_FUNC_CFG_VENDOR = 0x06<<8,
+	MSTAT_FUNC_MAX = 0x07<<8,
 };
 
 #define mstat_tf_idx(flags) ((flags)&0xff)
@@ -252,7 +253,7 @@ void _rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_a
 #endif /* CONFIG_USB_HCI */
 #endif /* DBG_MEM_ALLOC */
 
-extern void*	rtw_malloc2d(int h, int w, int size);
+extern void*	rtw_malloc2d(int h, int w, size_t size);
 extern void	rtw_mfree2d(void *pbuf, int h, int w, int size);
 
 extern void	_rtw_memcpy(void* dec, void* sour, u32 sz);
@@ -474,6 +475,8 @@ __inline static u32 bitshift(u32 bitmask)
 	return i;
 }
 
+#define rtw_min(a, b) ((a>b)?b:a)
+
 #ifndef MAC_FMT
 #define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
 #endif
@@ -493,9 +496,6 @@ extern void rtw_lock_traffic_suspend_timeout(u32 timeout_ms);
 extern void rtw_lock_resume_scan_timeout(u32 timeout_ms);
 extern void rtw_resume_lock_suspend(void);
 extern void rtw_resume_unlock_suspend(void);
-extern void rtw_ap_connection_lock_suspend(void);
-extern void rtw_ap_connection_unlock_suspend(void);
-
 #ifdef CONFIG_AP_WOWLAN
 extern void rtw_softap_lock_suspend(void);
 extern void rtw_softap_unlock_suspend(void);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_service_linux.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_service_linux.h
index 7b2ffd5b77a1..894169dd1e58 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_service_linux.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/osdep_service_linux.h
@@ -84,7 +84,9 @@
 	#include <linux/earlysuspend.h>
 #endif //CONFIG_HAS_EARLYSUSPEND
 
+#ifdef CONFIG_EFUSE_CONFIG_FILE
 	#include <linux/fs.h>
+#endif //CONFIG_EFUSE_CONFIG_FILE
 
 #ifdef CONFIG_USB_HCI
 	#include <linux/usb.h>
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_hal.h
old mode 100644
new mode 100755
index 3180a4c40e84..a37040b741a5
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_hal.h
@@ -36,6 +36,10 @@ void rtl8188ee_set_hal_ops(_adapter * padapter);
 void rtl8812ae_set_hal_ops(_adapter * padapter);
 #endif
 
+#if defined(CONFIG_RTL8192E)
+void rtl8192ee_set_hal_ops(_adapter * padapter);
+#endif
+
 #ifdef CONFIG_RTL8723B
 void rtl8723be_set_hal_ops(_adapter * padapter);
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_ops.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_ops.h
old mode 100644
new mode 100755
index 75de6def613e..cc2f45dab3b1
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_ops.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/pci_ops.h
@@ -68,6 +68,16 @@ void	rtl8812ae_prepare_bcn_tasklet(void *priv);
 void	rtl8812ae_set_intf_ops(struct _io_ops	*pops);
 #endif
 
+#ifdef CONFIG_RTL8192E
+u32	rtl8192ee_init_desc_ring(_adapter * padapter);
+u32	rtl8192ee_free_desc_ring(_adapter * padapter);
+void	rtl8192ee_reset_desc_ring(_adapter * padapter);
+void	rtl8192ee_recv_tasklet(void *priv);
+void	rtl8192ee_prepare_bcn_tasklet(void *priv);
+int	rtl8192ee_interrupt(PADAPTER Adapter);
+void	rtl8192ee_set_intf_ops(struct _io_ops	*pops);
+#endif
+
 #ifdef CONFIG_RTL8723B
 u32	rtl8723be_init_desc_ring(_adapter * padapter);
 u32	rtl8723be_free_desc_ring(_adapter * padapter);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_cmd.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_cmd.h
index a4c9a47a265b..839b1e03bb65 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_cmd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_cmd.h
@@ -65,7 +65,7 @@ typedef enum _RTL8188E_H2C_CMD_ID
 	//Class DM
 	H2C_DM_MACID_CFG				=0x40,
 	H2C_DM_TXBF					=0x41,
-
+	H2C_RSSI_REPORT 				=0x42,
 	//Class BT
 	H2C_BT_COEX_MASK				=0x60,
 	H2C_BT_COEX_GPIO_MODE		=0x61,
@@ -142,9 +142,11 @@ typedef struct _RSVDPAGE_LOC_88E {
 void rtl8188e_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
 void rtl8188e_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
 u8 rtl8188e_set_rssi_cmd(PADAPTER padapter, u8 *param);
-u8 rtl8188e_set_raid_cmd(PADAPTER padapter, u32 mask);
+u8 rtl8188e_set_raid_cmd(_adapter*padapter, u32 bitmap, u8* arg);
 void rtl8188e_Add_RateATid(PADAPTER padapter, u32 bitmap, u8* arg, u8 rssi_level);
+s32 FillH2CCmd_88E(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
 //u8 rtl8192c_set_FwSelectSuspend_cmd(PADAPTER padapter, u8 bfwpoll, u16 period);
+u8 GetTxBufferRsvdPageNum8188E(_adapter *padapter, bool wowlan);
 
 
 #ifdef CONFIG_P2P
@@ -226,11 +228,6 @@ typedef struct _SETAOAC_GLOBAL_INFO{
 #define FW_ADOPT_USER					BIT(1)
 */
 void rtl8188es_set_wowlan_cmd(_adapter* padapter, u8 enable);
-void rtl8188es_set_global_info_cmd(_adapter* padapter, u8 enable);
-void rtl8188es_set_keep_alive_cmd(_adapter* padapter, u8 enable);
-void rtl8188es_set_disconnect_decision_cmd(_adapter* padapter, u8 enable);
-void rtl8188es_set_wowlan_ctrl_cmd(_adapter* padapter, u8 enable);
-void rtl8188es_set_remote_wake_ctrl_cmd(_adapter* padapter, u8 enable);
 void SetFwRelatedForWoWLAN8188ES(_adapter* padapter, u8 bHostIsGoingtoSleep);
 
 #endif//CONFIG_WOWLAN
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_hal.h
index 51e66f99d8f5..e0dc8ef902cd 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_hal.h
@@ -21,11 +21,7 @@
 #define __RTL8188E_HAL_H__
 
 //#include "hal_com.h"
-#if 1
 #include "hal_data.h"
-#else
-#include "../hal/OUTSRC/odm_precomp.h"
-#endif
 
 //include HAL Related header after HAL Related compiling flags 
 #include "rtl8188e_spec.h"
@@ -80,13 +76,15 @@
 
 
 #if 1 // download firmware related data structure
+#define MAX_FW_8188E_SIZE			0x8000 //32768,32k / 16384,16k
+
 #define FW_8188E_SIZE				0x4000 //16384,16k
+#define FW_8188E_SIZE_2			0x8000 //32768,32k 
+
 #define FW_8188E_START_ADDRESS	0x1000
 #define FW_8188E_END_ADDRESS		0x1FFF //0x5FFF
 
 
-
-
 #define IS_FW_HEADER_EXIST_88E(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x88E0)
 
 typedef struct _RT_FIRMWARE_8188E {
@@ -94,7 +92,7 @@ typedef struct _RT_FIRMWARE_8188E {
 #ifdef CONFIG_EMBEDDED_FWIMG
 	u8*			szFwBuffer;
 #else
-	u8			szFwBuffer[FW_8188E_SIZE];
+	u8			szFwBuffer[MAX_FW_8188E_SIZE];
 #endif
 	u32			ulFwLength;
 } RT_FIRMWARE_8188E, *PRT_FIRMWARE_8188E;
@@ -140,8 +138,8 @@ typedef struct _RT_8188E_FIRMWARE_HDR
 #define BCN_DMA_ATIME_INT_TIME_8188E		0x02
 
 
-#define MAX_RX_DMA_BUFFER_SIZE_88E	      0x2400 //9k for 88E nornal chip , //MaxRxBuff=10k-max(TxReportSize(64*8), WOLPattern(16*24))
-//#define MAX_RX_DMA_BUFFER_SIZE_88E(__Adapter)	((!IS_VENDOR_8188E_I_CUT_SERIES(__Adapter))?0x2400:0x3C00)
+//#define MAX_RX_DMA_BUFFER_SIZE_88E	      0x2400 //9k for 88E nornal chip , //MaxRxBuff=10k-max(TxReportSize(64*8), WOLPattern(16*24))
+#define MAX_RX_DMA_BUFFER_SIZE_88E(__Adapter)	((!IS_VENDOR_8188E_I_CUT_SERIES(__Adapter))?0x2400:0x3C00)
 
 
 #define MAX_TX_REPORT_BUFFER_SIZE			0x0400 // 1k 
@@ -161,11 +159,11 @@ typedef struct _RT_8188E_FIRMWARE_HDR
 #define WOWLAN_PAGE_NUM_88E	0x00
 #endif
 
-#define TX_TOTAL_PAGE_NUMBER_88E	(0xB0 - BCNQ_PAGE_NUM_88E - WOWLAN_PAGE_NUM_88E)
-#define TX_PAGE_BOUNDARY_88E		(TX_TOTAL_PAGE_NUMBER_88E + 1)
+#define TX_TOTAL_PAGE_NUMBER_88E(_Adapter)	( (IS_VENDOR_8188E_I_CUT_SERIES(_Adapter)?0x100:0xB0) - BCNQ_PAGE_NUM_88E - WOWLAN_PAGE_NUM_88E)
+#define TX_PAGE_BOUNDARY_88E(_Adapter)		(TX_TOTAL_PAGE_NUMBER_88E(_Adapter) + 1)
 
-#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E	TX_TOTAL_PAGE_NUMBER_88E
-#define WMM_NORMAL_TX_PAGE_BOUNDARY_88E		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E + 1)
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E(_Adapter)	TX_TOTAL_PAGE_NUMBER_88E(_Adapter)
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_88E(_Adapter)		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E(_Adapter) + 1)
 
 // For Normal Chip Setting
 // (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8723B
@@ -191,6 +189,7 @@ typedef struct _RT_8188E_FIRMWARE_HDR
 //	Channel Plan
 //-------------------------------------------------------------------------
 
+
 #define EFUSE_REAL_CONTENT_LEN		512
 #define EFUSE_MAP_LEN				128
 #define EFUSE_MAX_SECTION			16
@@ -207,9 +206,6 @@ typedef struct _RT_8188E_FIRMWARE_HDR
 //
 #define EFUSE_OOB_PROTECT_BYTES 		15	// PG data exclude header, dummy 6 bytes frome CP test and reserved 1byte.
 
-#define		HWSET_MAX_SIZE_88E		512
-#define		EFUSE_FILE_COLUMN_NUM		16
-
 #define		EFUSE_REAL_CONTENT_LEN_88E	256
 #define		EFUSE_MAP_LEN_88E		512
 #define		EFUSE_MAX_SECTION_88E		64
@@ -283,6 +279,8 @@ void Hal_InitChannelPlan(PADAPTER padapter);
 void Hal_ReadRFGainOffset(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLoadFail);
 #endif //CONFIG_RF_GAIN_OFFSET
 
+void rtl8188e_init_default_value(_adapter *adapter);
+
 void rtl8188e_set_hal_ops(struct hal_ops *pHalFunc);
 
 // register
@@ -299,6 +297,13 @@ void _InitTransferPageSize(PADAPTER padapter);
 
 void SetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);
 void GetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);
-
+void ResumeTxBeacon(PADAPTER padapter);
+void StopTxBeacon(PADAPTER padapter);
+u8
+GetHalDefVar8188E(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+	);
 #endif //__RTL8188E_HAL_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_led.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_led.h
index c5e38009a6f4..4b05994a8ba0 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_led.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_led.h
@@ -32,7 +32,7 @@ void rtl8188eu_DeInitSwLeds(PADAPTER padapter);
 void rtl8188ee_InitSwLeds(PADAPTER padapter);
 void rtl8188ee_DeInitSwLeds(PADAPTER padapter);
 #endif
-#ifdef CONFIG_SDIO_HCI
+#if defined (CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 void rtl8188es_InitSwLeds(PADAPTER padapter);
 void rtl8188es_DeInitSwLeds(PADAPTER padapter);
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_recv.h
index df6e59ff562f..5d4e62888dcd 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_recv.h
@@ -109,7 +109,7 @@ typedef struct rxreport_8188e
 } RXREPORT, *PRXREPORT;
 
 
-#ifdef CONFIG_SDIO_HCI
+#if defined (CONFIG_SDIO_HCI)||defined(CONFIG_GSPI_HCI)
 s32 rtl8188es_init_recv_priv(PADAPTER padapter);
 void rtl8188es_free_recv_priv(PADAPTER padapter);
 void rtl8188es_recv_hdl(PADAPTER padapter, struct recv_buf *precvbuf);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_spec.h
index 535862c6ece2..287efee84e8a 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_spec.h
@@ -49,6 +49,8 @@
 #define REG_HISRE_88E					0x00BC //RTL8188E
 #define REG_MACID_NO_LINK_0			0x0484
 #define REG_MACID_NO_LINK_1			0x0488
+#define REG_MACID_PAUSE_0			0x048c
+#define REG_MACID_PAUSE_1			0x0490
 
 //-----------------------------------------------------
 //
@@ -145,6 +147,8 @@
 // General definitions
 //========================================================
 
+#define MACID_NUM_88E 64
+#define CAM_ENTRY_NUM_88E 32
 
 //----------------------------------------------------------------------------
 //       8192C EEPROM/EFUSE share register definition.
@@ -153,5 +157,5 @@
 #define EFUSE_ACCESS_ON			0x69	// For RTL8723 only.
 #define EFUSE_ACCESS_OFF			0x00	// For RTL8723 only.
 
-#endif //__RTL8188E_SPEC_H__
+#endif /* __RTL8188E_SPEC_H__ */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_xmit.h
index 24bbb9bce9a0..793a66bfbc14 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8188e_xmit.h
@@ -21,17 +21,7 @@
 #define __RTL8188E_XMIT_H__
 
 
-//
-// Queue Select Value in TxDesc
-//
-#define QSLT_BK							0x2//0x01
-#define QSLT_BE							0x0
-#define QSLT_VI							0x5//0x4
-#define QSLT_VO							0x7//0x6
-#define QSLT_BEACON						0x10
-#define QSLT_HIGH						0x11
-#define QSLT_MGNT						0x12
-#define QSLT_CMD						0x13
+
 
 //For 88e early mode
 #define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
@@ -249,9 +239,13 @@ struct txrpt_ccx_88e {
 #define txrpt_ccx_sw_88e(txrpt_ccx) ((txrpt_ccx)->sw0 + ((txrpt_ccx)->sw1<<8))
 #define txrpt_ccx_qtime_88e(txrpt_ccx) ((txrpt_ccx)->ccx_qtime0+((txrpt_ccx)->ccx_qtime1<<8))
 
-void rtl8188e_fill_fake_txdesc(PADAPTER	padapter, u8*pDesc, u32 BufferLen,
-		u8 IsPsPoll, u8	IsBTQosNull, u8 bDataFrame);
-#ifdef CONFIG_SDIO_HCI
+#define SET_TX_DESC_SEC_TYPE_8188E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+
+void rtl8188e_fill_fake_txdesc(PADAPTER	padapter,u8*pDesc,u32 BufferLen,
+		u8 IsPsPoll,u8	IsBTQosNull, u8 bDataFrame);
+void rtl8188e_cal_txdesc_chksum(struct tx_desc	*ptxdesc);
+
+#if defined(CONFIG_SDIO_HCI)||defined (CONFIG_GSPI_HCI)
 s32 rtl8188es_init_xmit_priv(PADAPTER padapter);
 void rtl8188es_free_xmit_priv(PADAPTER padapter);
 s32 rtl8188es_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
@@ -279,14 +273,14 @@ s32 rtl8188eu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 #ifdef CONFIG_PCI_HCI
 s32 rtl8188ee_init_xmit_priv(PADAPTER padapter);
 void rtl8188ee_free_xmit_priv(PADAPTER padapter);
-struct xmit_buf *rtl8188ee_dequeue_xmitbuf(struct rtw_tx_ring *ring);
 void	rtl8188ee_xmitframe_resume(_adapter *padapter);
 s32 rtl8188ee_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
 s32 rtl8188ee_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8188ee_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
 void rtl8188ee_xmit_tasklet(void *priv);
 #endif
 
-#define SET_TX_DESC_SEC_TYPE_8188E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+
 
 #ifdef CONFIG_TX_EARLY_MODE
 void UpdateEarlyModeInfo8188E(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf );
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_cmd.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_cmd.h
index 4febe67c8e8a..3f254d6a1114 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_cmd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_cmd.h
@@ -78,6 +78,7 @@ u8	rtl8192c_set_rssi_cmd(_adapter*padapter, u8 *param);
 void	rtl8192c_set_raid_cmd(_adapter*padapter, u32 mask, u8* arg);
 void	rtl8192c_Add_RateATid(PADAPTER pAdapter, u32 bitmap, u8* arg, u8 rssi_level);
 u8	rtl8192c_set_FwSelectSuspend_cmd(_adapter*padapter,u8 bfwpoll, u16 period);
+int rtl8192c_FillH2CCmd(_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBuffer);
 #ifdef CONFIG_P2P
 void	rtl8192c_set_p2p_ps_offload_cmd(_adapter* padapter, u8 p2p_ps_state);
 #endif //CONFIG_P2P
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_hal.h
index 795e39696666..ccde9d54af39 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_hal.h
@@ -21,13 +21,7 @@
 #define __RTL8192C_HAL_H__
 
 //#include "hal_com.h"
-
-#if 1
 #include "hal_data.h"
-#else
-#include "../hal/OUTSRC/odm_precomp.h"
-#endif
-
 
 #include "drv_types.h"
 #include "rtl8192c_spec.h"
@@ -402,8 +396,9 @@ void rtl8192c_EfuseParseChnlPlan(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoad
 
 HAL_VERSION rtl8192c_ReadChipVersion(IN PADAPTER Adapter);
 void rtl8192c_ReadBluetoothCoexistInfo(PADAPTER Adapter, u8 *PROMContent, BOOLEAN AutoloadFail);
-//void rtl8192c_free_hal_data(_adapter * padapter);
+
 VOID rtl8192c_EfuseParseIDCode(PADAPTER pAdapter, u8 *hwinfo);
+void rtl8192c_init_default_value(_adapter *adapter);
 void rtl8192c_set_hal_ops(struct hal_ops *pHalFunc);
 
 s32 c2h_id_filter_ccx_8192c(u8 *buf);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_recv.h
index 85716b4105e4..ad4d37010700 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_recv.h
@@ -26,6 +26,7 @@
 
 #if defined(CONFIG_USB_HCI)
 
+#ifndef MAX_RECVBUF_SZ
 #ifdef PLATFORM_OS_CE
 #define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
 #else
@@ -43,6 +44,7 @@
 		#define MAX_RECVBUF_SZ (4000) // about 4K
 	#endif
 #endif
+#endif //!MAX_RECVBUF_SZ
 
 #elif defined(CONFIG_PCI_HCI)
 //#ifndef CONFIG_MINIMAL_MEMORY_USAGE
@@ -52,7 +54,7 @@
 //#endif
 
 
-#elif defined(CONFIG_SDIO_HCI)
+#elif defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 
 #define MAX_RECVBUF_SZ (10240)
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_spec.h
index 040651f95439..80927de1cd8a 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_spec.h
@@ -109,26 +109,8 @@
 //
 // Interface type.
 //
-#endif 
-
-#ifdef CONFIG_USB_HCI
-
-//should be renamed and moved to another file
-typedef	enum _BOARD_TYPE_8192CUSB{
-	BOARD_USB_DONGLE 			= 0,		// USB dongle
-	BOARD_USB_High_PA 		= 1,		// USB dongle with high power PA
-	BOARD_MINICARD		  	= 2,		// Minicard
-	BOARD_USB_SOLO 		 	= 3,		// USB solo-Slim module
-	BOARD_USB_COMBO			= 4,		// USB Combo-Slim module
-} BOARD_TYPE_8192CUSB, *PBOARD_TYPE_8192CUSB;
-
-#define	SUPPORT_HW_RADIO_DETECT(pHalData)	(pHalData->BoardType == BOARD_MINICARD||\
-													pHalData->BoardType == BOARD_USB_SOLO||\
-													pHalData->BoardType == BOARD_USB_COMBO)
-
 #endif
 
-
 #define EFUSE_ACCESS_ON			0x69	// For RTL8723 only.
 #define EFUSE_ACCESS_OFF			0x00	// For RTL8723 only.
 
@@ -136,8 +118,10 @@ typedef	enum _BOARD_TYPE_8192CUSB{
 // General definitions
 //========================================================
 
+#define MACID_NUM_92C 32
+#define CAM_ENTRY_NUM_92C 32
 
 #include "basic_types.h"
 
-#endif
+#endif /* __RTL8192C_SPEC_H__ */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_xmit.h
index c48847117179..c1108eb0c4be 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192c_xmit.h
@@ -61,17 +61,7 @@
 //OFFSET 20
 #define SGI		BIT(6)
 
-//
-// Queue Select Value in TxDesc
-//
-#define QSLT_BK							0x2//0x01
-#define QSLT_BE							0x0
-#define QSLT_VI							0x5//0x4
-#define QSLT_VO							0x7//0x6
-#define QSLT_BEACON					0x10
-#define QSLT_HIGH						0x11
-#define QSLT_MGNT						0x12
-#define QSLT_CMD						0x13
+
 
 struct txrpt_ccx_8192c {
 	/* offset 0 */
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_cmd.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_cmd.h
index 3896b7daa751..deb03a0465f6 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_cmd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_cmd.h
@@ -28,24 +28,24 @@
 // User Define Message [31:8]
 
 //_SETPWRMODE_PARM
-#define SET_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-#define SET_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-#define SET_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
 
 //JOINBSSRPT_PARM
-#define SET_H2CCMD_JOINBSSRPT_PARM_OPMODE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_JOINBSSRPT_PARM_OPMODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
 
 //_RSVDPAGE_LOC
-#define SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
 
 
-#define SET_H2CCMD_P2P_PS_OFFLOAD_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_H2CCMD_P2P_PS_OFFLOAD_CTW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
-#define SET_H2CCMD_P2P_PS_OFFLOAD_NOA0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
-#define SET_H2CCMD_P2P_PS_OFFLOAD_NOA1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_EN(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_CTW(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_NOA0(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_NOA1(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
 #define SET_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
 #define SET_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
 
@@ -53,13 +53,13 @@
 // Fisrt constructed by tynli. 2009.10.09.
 typedef enum _RTL8192D_H2C_CMD 
 {
-	H2C_AP_OFFLOAD = 0,		/*0*/
+	H2C_92D_AP_OFFLOAD = 0,		/*0*/
 	H2C_SETPWRMODE = 1,		/*1*/
 	H2C_JOINBSSRPT = 2,		/*2*/
 	H2C_RSVDPAGE = 3,
 	H2C_RSSI_REPORT = 5,
 	H2C_RA_MASK = 6,
-	H2C_P2P_PS_OFFLOAD = 8,
+	H2C_92D_P2P_PS_OFFLOAD = 8,
 	H2C_MAC_MODE_SEL = 9,
 	H2C_PWRM=15,
 	H2C_P2P_PS_CTW_CMD = 24,
@@ -76,7 +76,7 @@ struct cmd_msg_parm {
 };
 
 
-void	FillH2CCmd92D(_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBuffer);
+int FillH2CCmd92D(_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBuffer);
 
 // host message to firmware cmd
 void	rtl8192d_set_FwPwrMode_cmd(_adapter*padapter, u8 Mode);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_hal.h
index b9779d597195..7190694c9c14 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_hal.h
@@ -22,11 +22,7 @@
 
 //#include "hal_com.h"
 
-#if 1
 #include "hal_data.h"
-#else
-#include "../hal/OUTSRC/odm_precomp.h"
-#endif
 
 #include "rtl8192d_spec.h"
 #include "Hal8192DPhyReg.h"
@@ -401,6 +397,7 @@ BOOLEAN PHY_CheckPowerOffFor8192D(PADAPTER Adapter);
 VOID PHY_SetPowerOnFor8192D(PADAPTER Adapter);
 //void PHY_ConfigMacPhyMode92D(PADAPTER Adapter);
 void rtl8192d_free_hal_data(_adapter * padapter);
+void rtl8192d_init_default_value(_adapter *adapter);
 void rtl8192d_set_hal_ops(struct hal_ops *pHalFunc);
 
 void SetHwReg8192D(_adapter *adapter, u8 variable, u8 *val);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_recv.h
index eff00fe7d6cc..8ebdfdf3f0ea 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_recv.h
@@ -27,6 +27,7 @@
 
 #if defined(CONFIG_USB_HCI)
 
+#ifndef MAX_RECVBUF_SZ
 #ifdef PLATFORM_OS_CE
 #define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
 #else
@@ -43,6 +44,7 @@
 		#define MAX_RECVBUF_SZ (4000) // about 4K
 	#endif
 #endif
+#endif //!MAX_RECVBUF_SZ
 
 #elif defined(CONFIG_PCI_HCI)
 //#ifndef CONFIG_MINIMAL_MEMORY_USAGE
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_spec.h
index f1184a6831b9..b316b7c4b621 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_spec.h
@@ -109,7 +109,10 @@
 // General definitions
 //========================================================
 
+#define MACID_NUM_92D 32
+#define CAM_ENTRY_NUM_92D 32
+
 #include "basic_types.h"
 
-#endif
+#endif /* __RTL8192D_SPEC_H__ */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_xmit.h
index bddc3385e03b..8add5a1a3b01 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192d_xmit.h
@@ -61,17 +61,7 @@
 //OFFSET 20
 #define SGI		BIT(6)
 
-//
-// Queue Select Value in TxDesc
-//
-#define QSLT_BK							0x2//0x01
-#define QSLT_BE							0x0
-#define QSLT_VI							0x5//0x4
-#define QSLT_VO							0x7//0x6
-#define QSLT_BEACON					0x10
-#define QSLT_HIGH						0x11
-#define QSLT_MGNT						0x12
-#define QSLT_CMD						0x13
+
 
 //Because we open EM for normal case, we just always insert 2*8 bytes.by wl
 #ifdef USB_PACKET_OFFSET_SZ
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_cmd.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_cmd.h
index 54502455040a..37dd341300ab 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_cmd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_cmd.h
@@ -114,22 +114,22 @@ typedef struct _RSVDPAGE_LOC_92E {
 
 
 //_SETPWRMODE_PARM
-#define SET_8192E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-#define SET_8192E_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
-#define SET_8192E_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
-#define SET_8192E_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
-#define SET_8192E_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
-#define SET_8192E_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
-#define SET_8192E_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
-#define GET_8192E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8192E_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+5, 0, 8, __Value)
+#define GET_8192E_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)						LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
 
 //_P2P_PS_OFFLOAD
 #define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
 #define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
-#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
-#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
-#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_8192E_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
 
 
 // host message to firmware cmd
@@ -138,9 +138,13 @@ void rtl8192e_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
 u8 rtl8192e_set_rssi_cmd(PADAPTER padapter, u8 *param);
 void rtl8192e_set_raid_cmd(PADAPTER padapter, u32 bitmap, u8* arg);
 void rtl8192e_Add_RateATid(PADAPTER padapter, u32 bitmap, u8 *arg, u8 rssi_level);
+s32 FillH2CCmd_8192E(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+u8 GetTxBufferRsvdPageNum8192E(_adapter *padapter, bool wowlan);
 //u8 rtl8192c_set_FwSelectSuspend_cmd(PADAPTER padapter, u8 bfwpoll, u16 period);
-
-
+s32 c2h_handler_8192e(PADAPTER padapter, u8 *buf);
+#ifdef CONFIG_BT_COEXIST
+void rtl8192e_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
+#endif // CONFIG_BT_COEXIST
 #ifdef CONFIG_P2P_PS
 void rtl8192e_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
 //void rtl8723a_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
@@ -150,7 +154,6 @@ void CheckFwRsvdPageContent(PADAPTER padapter);
 void rtl8192e_set_FwMediaStatus_cmd(PADAPTER padapter, u16 mstatus_rpt );
 
 #ifdef CONFIG_TSF_RESET_OFFLOAD
-//u8 rtl8188e_reset_tsf(_adapter *padapter, u8 reset_port);
 int reset_tsf(PADAPTER Adapter, u8 reset_port );
 #endif	// CONFIG_TSF_RESET_OFFLOAD
 
@@ -212,4 +215,4 @@ C2HPacketHandler_8192E(
 	IN	u1Byte			Length
 );
 
-#endif//__RTL8188E_CMD_H__
+#endif//__RTL8192E_CMD_H__
\ No newline at end of file
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_hal.h
index 2b76b8cc95b7..363f00d59578 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_hal.h
@@ -22,11 +22,7 @@
 
 //#include "hal_com.h"
 
-#if 1
 #include "hal_data.h"
-#else
-#include "../hal/OUTSRC/odm_precomp.h"
-#endif
 
 //include HAL Related header after HAL Related compiling flags 
 #include "rtl8192e_spec.h"
@@ -59,7 +55,8 @@
 	#define RTL8192E_PHY_MACREG 				"rtl8192e/MAC_REG.txt"
 	#define RTL8192E_PHY_REG_PG				"rtl8192e/PHY_REG_PG.txt"
 	#define RTL8192E_PHY_REG_MP 				"rtl8192e/PHY_REG_MP.txt" 
-	#define RTL8192E_TXPWR_LMT				"rtl8192e/TXPWR_LMT.txt" 
+	#define RTL8192E_TXPWR_LMT					"rtl8192e/TXPWR_LMT.txt"
+	#define RTL8192E_WIFI_ANT_ISOLATION		"rtl8192e/wifi_ant_isolation.txt"
 
 //---------------------------------------------------------------------
 //		RTL8192E Power Configuration CMDs for PCIe interface
@@ -135,41 +132,56 @@ typedef struct _RT_FIRMWARE_8192E {
 #define MAX_RX_DMA_BUFFER_SIZE_8192E		0x3d00 //0x3E80   //0x3FFF	// RX 16K reserved for WOW ?
 
 
-#define TX_TOTAL_PAGE_NUMBER_8192E		243 //0x00~0xF3 totoal pages: F4
+//For General Reserved Page Number(Beacon Queue is reserved page)
+//if (CONFIG_2BCN_EN) Beacon:4, PS-Poll:1, Null Data:1,Prob Rsp:1,Qos Null Data:1
+//Beacon:2, PS-Poll:1, Null Data:1,Prob Rsp:1,Qos Null Data:1
+#define RSVD_PAGE_NUM_8192E		0x08
+//For WoWLan , more reserved page
+//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2, PNO: 6
+#ifdef CONFIG_WOWLAN
+#define WOWLAN_PAGE_NUM_8192E	0x07
+#else
+#define WOWLAN_PAGE_NUM_8192E	0x00
+#endif
+
+#ifdef CONFIG_PNO_SUPPORT
+#undef WOWLAN_PAGE_NUM_8192E
+#define WOWLAN_PAGE_NUM_8192E	0x0d
+#endif
+
+#define	TOTAL_RSVD_PAGE_NUMBER_8192E 	(RSVD_PAGE_NUM_8192E+WOWLAN_PAGE_NUM_8192E)
+#define	TX_TOTAL_PAGE_NUMBER_8192E	(0x100 - TOTAL_RSVD_PAGE_NUMBER_8192E)
+
+#define	TX_PAGE_BOUNDARY_8192E	TX_TOTAL_PAGE_NUMBER_8192E
+
 
-#define TX_PAGE_BOUNDARY_8192E			(TX_TOTAL_PAGE_NUMBER_8192E + 1)//0xF4,Rserved 12 pages for BCN/PS-POLL..
 #define TX_PAGE_LOAD_FW_BOUNDARY_8192E		0x47 //0xA5
 #define TX_PAGE_BOUNDARY_WOWLAN_8192E		0xE0
 
 // For Normal Chip Setting
 // (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_92C
-#define NORMAL_PAGE_NUM_PUBQ_8192E			0xE0
-#define NORMAL_PAGE_NUM_LPQ_8192E			0x0C
-#define NORMAL_PAGE_NUM_HPQ_8192E			0x08
-#define NORMAL_PAGE_NUM_NPQ_8192E			0x00
-#define NORMAL_PAGE_NUM_EPQ_8192E			0x00
 
+#define NORMAL_PAGE_NUM_HPQ_8192E			0x10
+#define NORMAL_PAGE_NUM_LPQ_8192E			0x10
+#define NORMAL_PAGE_NUM_NPQ_8192E			0x10
+#define NORMAL_PAGE_NUM_EPQ_8192E			0x00
 
 
 //Note: For WMM Normal Chip Setting ,modify later
-#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8192E	TX_PAGE_BOUNDARY_8192E
-#define WMM_NORMAL_TX_PAGE_BOUNDARY_8192E		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8192E + 1)
-
-#define WMM_NORMAL_PAGE_NUM_PUBQ_8192E	NORMAL_PAGE_NUM_PUBQ_8192E
 #define WMM_NORMAL_PAGE_NUM_HPQ_8192E		NORMAL_PAGE_NUM_HPQ_8192E
 #define WMM_NORMAL_PAGE_NUM_LPQ_8192E		NORMAL_PAGE_NUM_LPQ_8192E
 #define WMM_NORMAL_PAGE_NUM_NPQ_8192E		NORMAL_PAGE_NUM_NPQ_8192E
 
-#define USB_JAGUAR_DUMMY_OFFSET_8192EU		2
-#define USB_JAGUAR_DUMMY_UNIT_8192EU			8
-#define USB_JAGUAR_ALL_DUMMY_LENGTH_8192EU			(USB_JAGUAR_DUMMY_OFFSET_8192EU * USB_JAGUAR_DUMMY_UNIT_8192EU)
-#define USB_HWDESC_HEADER_LEN_8192EU		(TX_DESC_SIZE_8192E + USB_JAGUAR_ALL_DUMMY_LENGTH_8192EU)
-
 
 //-------------------------------------------------------------------------
 //	Chip specific
 //-------------------------------------------------------------------------
 
+// pic buffer descriptor
+#define RTL8192EE_SEG_NUM			TX_BUFFER_SEG_NUM
+#define TX_DESC_NUM_92E			128
+#define RX_DESC_NUM_92E			128
+
 //-------------------------------------------------------------------------
 //	Channel Plan
 //-------------------------------------------------------------------------
@@ -203,7 +215,7 @@ typedef struct _RT_FIRMWARE_8192E {
 #define		EFUSE_BT_MAX_SECTION_8192E				128		// 1024/8
 
 #define		EFUSE_PROTECT_BYTES_BANK_8192E			16
-#define 	EFUSE_MAX_BANK_8192E					3
+#define 		EFUSE_MAX_BANK_8192E					3
 //===========================================================
 
 #define INCLUDE_MULTI_FUNC_BT(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
@@ -213,8 +225,6 @@ typedef struct _RT_FIRMWARE_8192E {
 
 //#define RT_IS_FUNC_DISABLED(__pAdapter, __FuncBits) ( (__pAdapter)->DisabledFunctions & (__FuncBits) )
 
-#define GetDefaultAdapter(padapter)	padapter
-
 // rtl8812_hal_init.c
 void	_8051Reset8192E(PADAPTER padapter);
 s32	FirmwareDownload8192E(PADAPTER Adapter, BOOLEAN bUsedWoWLANFw);
@@ -246,6 +256,8 @@ void Hal_DetectWoWMode(PADAPTER pAdapter);
 
 /***********************************************************/
 // RTL8192E-MAC Setting
+VOID _InitQueueReservedPage_8192E(IN  PADAPTER Adapter);
+VOID _InitQueuePriority_8192E(IN	PADAPTER Adapter);
 VOID _InitTxBufferBoundary_8192E(IN PADAPTER Adapter,IN u8 txpktbuf_bndy);
 VOID _InitPageBoundary_8192E(IN PADAPTER Adapter);
 //VOID _InitTransferPageSize_8192E(IN PADAPTER Adapter);
@@ -255,15 +267,16 @@ VOID _InitRDGSetting_8192E(PADAPTER Adapter);
 void _InitID_8192E(IN  PADAPTER Adapter);
 VOID _InitNetworkType_8192E(IN  PADAPTER Adapter);
 VOID _InitWMACSetting_8192E(IN PADAPTER Adapter);
-VOID _InitAdaptiveCtrl_8192E(IN  PADAPTER Adapter);
+VOID _InitAdaptiveCtrl_8192E(IN  PADAPTER Adapter);
+VOID _InitRateFallback_8192E(IN  PADAPTER Adapter);
 VOID _InitEDCA_8192E( IN  PADAPTER Adapter);
 VOID _InitRetryFunction_8192E(	IN  PADAPTER Adapter);
+VOID _BBTurnOnBlock_8192E(IN	PADAPTER Adapter);
 VOID _InitBeaconParameters_8192E(IN  PADAPTER Adapter);
 VOID _InitBeaconMaxError_8192E(
 	IN  PADAPTER	Adapter,
 	IN	BOOLEAN		InfraMode
 	);
-void _BBTurnOnBlock_8192E(PADAPTER padapter);
 void SetBeaconRelatedRegisters8192E(PADAPTER padapter);
 VOID hal_ReadRFType_8192E(PADAPTER	Adapter);
 // RTL8192E-MAC Setting
@@ -291,5 +304,21 @@ void SetBcnCtrlReg(PADAPTER padapter, u8 SetBits, u8 ClearBits);
 
 void rtl8192e_start_thread(_adapter *padapter);
 void rtl8192e_stop_thread(_adapter *padapter);
+
+#ifdef CONFIG_PCI_HCI
+BOOLEAN	InterruptRecognized8192EE(PADAPTER Adapter);
+u16	get_txdesc_buf_addr(u16 ff_hwaddr);
+#endif
+
+#ifdef CONFIG_SDIO_HCI
+#ifdef CONFIG_SDIO_TX_ENABLE_AVAL_INT
+void _init_available_page_threshold(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ);
+#endif
+#endif
+
+#ifdef CONFIG_BT_COEXIST
+void rtl8192e_combo_card_WifiOnlyHwInit(PADAPTER Adapter);
+#endif
+
 #endif //__RTL8192E_HAL_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_recv.h
index a8404849669c..34537c23c22a 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_recv.h
@@ -22,19 +22,25 @@
 
 #if defined(CONFIG_USB_HCI)
 
+#ifndef MAX_RECVBUF_SZ
 #ifdef PLATFORM_OS_CE
 #define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
 #else
 	#ifdef CONFIG_MINIMAL_MEMORY_USAGE
 		#define MAX_RECVBUF_SZ (4000) // about 4K
 	#else
+		#ifdef CONFIG_PLATFORM_MSTAR
+			#define MAX_RECVBUF_SZ (8192) // 8K
+		#else
 		#define MAX_RECVBUF_SZ (32768) // 32k
+		#endif
 		//#define MAX_RECVBUF_SZ (20480) //20K
 		//#define MAX_RECVBUF_SZ (10240) //10K 
 		//#define MAX_RECVBUF_SZ (16384) //  16k - 92E RX BUF :16K
 		//#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k		
 	#endif
 #endif
+#endif //!MAX_RECVBUF_SZ
 
 #elif defined(CONFIG_PCI_HCI)
 //#ifndef CONFIG_MINIMAL_MEMORY_USAGE
@@ -55,7 +61,28 @@
 #define Rx_Smooth_Factor (20)
 
 //=============
+// [1] Rx Buffer Descriptor (for PCIE) buffer descriptor architecture
+//DWORD 0
+#define SET_RX_BUFFER_DESC_DATA_LENGTH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc,__Value)	SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 15, 1, __Value)
+#define SET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 16, 1, __Value)
+#define SET_RX_BUFFER_DESC_TOTAL_LENGTH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 16, 15, __Value)
+
+#define GET_RX_BUFFER_DESC_OWN_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
+#define GET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
+#define GET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 1)
+#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 15)
+
 
+//DWORD 1
+#define SET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+4, 0, 32, __Value)
+#define GET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 0, 32)
+
+//DWORD 2
+#define SET_RX_BUFFER_PHYSICAL_HIGH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+8, 0, 32, __Value)
+
+//=============
+// [2] Rx Descriptor
 //DWORD 0
 #define GET_RX_STATUS_DESC_PKT_LEN_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
 #define GET_RX_STATUS_DESC_CRC32_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
@@ -67,6 +94,12 @@
 #define GET_RX_STATUS_DESC_PHY_STATUS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 26, 1)
 #define GET_RX_STATUS_DESC_SWDEC_92E(__pRxStatusDesc)			LE_BITS_TO_4BYTE( __pRxStatusDesc, 27, 1)
 #define GET_RX_STATUS_DESC_EOR_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 30, 1)
+#define GET_RX_STATUS_DESC_OWN_92E(__pRxStatusDesc)				LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
+
+
+#define SET_RX_STATUS_DESC_PKT_LEN_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
+#define SET_RX_STATUS_DESC_EOR_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 30, 1, __Value)
+#define SET_RX_STATUS_DESC_OWN_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 31, 1, __Value)
 
 //DWORD 1
 #define GET_RX_STATUS_DESC_MACID_92E(__pRxDesc) 					LE_BITS_TO_4BYTE(__pRxDesc+4, 0, 7)
@@ -116,13 +149,11 @@
 #define GET_RX_STATUS_DESC_BUFF_ADDR_92E(__pRxDesc) 		LE_BITS_TO_4BYTE(__pRxDesc+24, 0, 32)
 #define GET_RX_STATUS_DESC_BUFF_ADDR64_92E(__pRxDesc) 		LE_BITS_TO_4BYTE(__pRxDesc+28, 0, 32)
 
-#define SET_RX_STATUS_DESC_BUFF_ADDR_92E(__pRxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pRxDesc+24, 0, 32, __Value)
-
 
 #ifdef CONFIG_SDIO_HCI
-s32 rtl8812s_init_recv_priv(PADAPTER padapter);
-void rtl8812s_free_recv_priv(PADAPTER padapter);
-void rtl8812s_recv_hdl(PADAPTER padapter, struct recv_buf *precvbuf);
+s32 rtl8192es_init_recv_priv(PADAPTER padapter);
+void rtl8192es_free_recv_priv(PADAPTER padapter);
+void rtl8192es_recv_hdl(PADAPTER padapter, struct recv_buf *precvbuf);
 #endif
 
 #ifdef CONFIG_USB_HCI
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_spec.h
index c3f9316b0882..8f19f5e9e1f4 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_spec.h
@@ -35,6 +35,8 @@
 //	0x0000h ~ 0x00FFh	System Configuration
 //
 //-----------------------------------------------------
+#define REG_SYS_SWR_CTRL1_8192E		0x0010	// 1 Byte        
+#define REG_SYS_SWR_CTRL2_8192E		0x0014	// 1 Byte      
 #define REG_AFE_CTRL1_8192E			0x0024
 #define REG_AFE_CTRL2_8192E			0x0028
 #define REG_AFE_CTRL3_8192E			0x002c
@@ -79,6 +81,8 @@
 //	0x0200h ~ 0x027Fh	TXDMA Configuration
 //
 //-----------------------------------------------------
+#define REG_DWBCN0_CTRL             0x0208
+#define REG_DWBCN1_CTRL             0x0228
 
 //-----------------------------------------------------
 //
@@ -98,7 +102,62 @@
 //	0x0300h ~ 0x03FFh	PCIe
 //
 //-----------------------------------------------------
-#define	REG_PCIE_MULTIFET_CTRL_8192E	0x036A	//PCIE Multi-Fethc Control
+#define	REG_PCIE_CTRL_REG_8192E			0x0300
+#define	REG_INT_MIG_8192E					0x0304	// Interrupt Migration 
+#define	REG_BCNQ_TXBD_DESA_8192E		0x0308	// TX Beacon Descriptor Address
+#define	REG_MGQ_TXBD_DESA_8192E			0x0310	// TX Manage Queue Descriptor Address
+#define	REG_VOQ_TXBD_DESA_8192E			0x0318	// TX VO Queue Descriptor Address
+#define	REG_VIQ_TXBD_DESA_8192E			0x0320	// TX VI Queue Descriptor Address
+#define	REG_BEQ_TXBD_DESA_8192E			0x0328	// TX BE Queue Descriptor Address
+#define	REG_BKQ_TXBD_DESA_8192E			0x0330	// TX BK Queue Descriptor Address
+#define	REG_RXQ_RXBD_DESA_8192E			0x0338	// RX Queue	Descriptor Address
+#define 	REG_HI0Q_TXBD_DESA_8192E			0x0340
+#define 	REG_HI1Q_TXBD_DESA_8192E			0x0348
+#define 	REG_HI2Q_TXBD_DESA_8192E			0x0350
+#define 	REG_HI3Q_TXBD_DESA_8192E			0x0358
+#define	REG_HI4Q_TXBD_DESA_8192E			0x0360
+#define 	REG_HI5Q_TXBD_DESA_8192E			0x0368
+#define 	REG_HI6Q_TXBD_DESA_8192E			0x0370
+#define 	REG_HI7Q_TXBD_DESA_8192E			0x0378
+#define	REG_MGQ_TXBD_NUM_8192E			0x0380
+#define	REG_RX_RXBD_NUM_8192E			0x0382
+#define	REG_VOQ_TXBD_NUM_8192E			0x0384
+#define	REG_VIQ_TXBD_NUM_8192E			0x0386
+#define	REG_BEQ_TXBD_NUM_8192E			0x0388
+#define	REG_BKQ_TXBD_NUM_8192E			0x038A
+#define	REG_HI0Q_TXBD_NUM_8192E			0x038C
+#define	REG_HI1Q_TXBD_NUM_8192E			0x038E
+#define	REG_HI2Q_TXBD_NUM_8192E			0x0390
+#define	REG_HI3Q_TXBD_NUM_8192E			0x0392
+#define	REG_HI4Q_TXBD_NUM_8192E			0x0394
+#define	REG_HI5Q_TXBD_NUM_8192E			0x0396
+#define	REG_HI6Q_TXBD_NUM_8192E			0x0398
+#define	REG_HI7Q_TXBD_NUM_8192E			0x039A
+#define	REG_TSFTIMER_HCI_8192E			0x039C
+
+//Read Write Point
+#define	REG_VOQ_TXBD_IDX_8192E			0x03A0
+#define	REG_VIQ_TXBD_IDX_8192E			0x03A4
+#define	REG_BEQ_TXBD_IDX_8192E			0x03A8
+#define	REG_BKQ_TXBD_IDX_8192E			0x03AC
+#define	REG_MGQ_TXBD_IDX_8192E			0x03B0
+#define	REG_RXQ_TXBD_IDX_8192E			0x03B4
+#define	REG_HI0Q_TXBD_IDX_8192E			0x03B8
+#define	REG_HI1Q_TXBD_IDX_8192E			0x03BC
+#define	REG_HI2Q_TXBD_IDX_8192E			0x03C0
+#define	REG_HI3Q_TXBD_IDX_8192E			0x03C4
+#define	REG_HI4Q_TXBD_IDX_8192E			0x03C8
+#define	REG_HI5Q_TXBD_IDX_8192E			0x03CC
+#define	REG_HI6Q_TXBD_IDX_8192E			0x03D0
+#define	REG_HI7Q_TXBD_IDX_8192E			0x03D4
+
+#define	REG_PCIE_HCPWM_8192EE			0x03D8 // ??????
+#define	REG_PCIE_HRPWM_8192EE			0x03DC	//PCIe RPWM // ??????
+#define	REG_DBI_WDATA_V1_8192E			0x03E8
+#define	REG_DBI_RDATA_V1_8192E			0x03EC
+#define	REG_DBI_FLAG_V1_8192E				0x03F0
+#define 	REG_MDIO_V1_8192E					0x3F4
+#define 	REG_PCIE_MIX_CFG_8192E				0x3F8
 
 //-----------------------------------------------------
 //
@@ -106,14 +165,22 @@
 //
 //-----------------------------------------------------
 #define REG_TXBF_CTRL_8192E				0x042C
+#define REG_ARFR0_8192E					0x0444
 #define REG_ARFR1_8192E					0x044C
 #define REG_CCK_CHECK_8192E				0x0454
 #define REG_AMPDU_MAX_TIME_8192E			0x0456
 #define REG_BCNQ1_BDNY_8192E				0x0457
 
 #define REG_AMPDU_MAX_LENGTH_8192E	0x0458
+#define REG_WMAC_LBK_BUF_HD_8192E			0x045D
 #define REG_NDPA_OPT_CTRL_8192E		0x045F
 #define REG_DATA_SC_8192E				0x0483
+#ifdef CONFIG_WOWLAN
+#define REG_TXPKTBUF_IV_LOW             0x0484
+#define REG_TXPKTBUF_IV_HIGH            0x0488
+#endif
+#define REG_ARFR2_8192E					0x048C
+#define REG_ARFR3_8192E					0x0494
 #define REG_TXRPT_START_OFFSET			0x04AC
 #define REG_AMPDU_BURST_MODE_8192E	0x04BC
 #define REG_HT_SINGLE_AMPDU_8192E		0x04C7
@@ -246,8 +313,12 @@
 #define	AcmHw_ViqStatus_8192E			BIT(6)
 #define	AcmHw_BeqStatus_8192E			BIT(7)
 
+//========================================================
+// General definitions
+//========================================================
 
-
+#define MACID_NUM_8192E 128
+#define CAM_ENTRY_NUM_8192E 64
 
 #endif //__RTL8192E_SPEC_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_xmit.h
index 200a111b20e7..04b629e7ac82 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8192e_xmit.h
@@ -127,17 +127,7 @@ typedef struct txdescriptor_8192e
 	u32 mcs15_sgi_max_len:4;
 }TXDESC_8192E, *PTXDESC_8192E; 
 
-//
-// Queue Select Value in TxDesc
-//
-#define QSLT_BK							0x2//0x01
-#define QSLT_BE							0x0
-#define QSLT_VI							0x5//0x4
-#define QSLT_VO							0x7//0x6
-#define QSLT_BEACON					0x10
-#define QSLT_HIGH						0x11
-#define QSLT_MGNT						0x12
-#define QSLT_CMD						0x13
+
 
 //For 88e early mode
 #define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
@@ -207,16 +197,48 @@ typedef struct txdescriptor_8192e
 #define USB_TXAGG_NUM_SHT	24
 
 
+//=====Tx Desc Buffer content
+
+// config element for each tx buffer 
+/*
+#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 0, 16, __Valeu)
+#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 31, 1, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+4, 0, 32, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
+*/
+#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 0, 16, __Valeu)
+#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 31, 1, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8)+4, 0, 32, __Valeu)
+#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
+
+
+// Dword 0
+#define SET_TX_BUFF_DESC_LEN_0_92E(__pTxDesc, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 14, __Valeu)
+#define SET_TX_BUFF_DESC_PSB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 15, __Value)
+#define SET_TX_BUFF_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+// Dword 1
+#define SET_TX_BUFF_DESC_ADDR_LOW_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
+#define GET_TX_DESC_TX_BUFFER_ADDRESS_92E(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+4, 0,32)
+
+
+// Dword 2
+#define SET_TX_BUFF_DESC_ADDR_HIGH_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0, 32, __Value)
+// Dword 3, RESERVED 
+
 
-//=====Desc content
+//=====Tx Desc content
 // Dword 0
 #define SET_TX_DESC_PKT_SIZE_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Value)
 #define SET_TX_DESC_OFFSET_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
 #define SET_TX_DESC_BMC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 24, 1, __Value)
 #define SET_TX_DESC_HTC_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 25, 1, __Value)
+#define SET_TX_DESC_LAST_SEG_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 26, 1, __Value)
+#define SET_TX_DESC_FIRST_SEG_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 27, 1, __Value)
 #define SET_TX_DESC_LINIP_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 28, 1, __Value)
 #define SET_TX_DESC_NO_ACM_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 29, 1, __Value)
 #define SET_TX_DESC_GF_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 30, 1, __Value)
+#define SET_TX_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
+#define GET_TX_DESC_OWN_92E(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc, 31, 1)
 
 // Dword 1
 #define SET_TX_DESC_MACID_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 7, __Value)
@@ -324,13 +346,8 @@ typedef struct txdescriptor_8192e
 #define SET_TX_DESC_TXBF_PATH_92E(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 11, 1, __Value)
 #define SET_TX_DESC_SEQ_92E(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 12, 12, __Value)
 #define SET_TX_DESC_FINAL_DATA_RATE_92E(__pTxDesc, __Value) 					SET_BITS_TO_LE_4BYTE(__pTxDesc+36, 24, 8, __Value)
-// Dword 10
-#define SET_TX_DESC_TX_BUFFER_ADDRESS_92E(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+40, 0, 32, __Value)
 
 
-// Dword 11
-#define SET_TX_DESC_NEXT_DESC_ADDRESS_92E(__pTxDesc, __Value) 	SET_BITS_TO_LE_4BYTE(__pTxDesc+48, 0, 32, __Value)
-
 #define SET_EARLYMODE_PKTNUM_92E(__pAddr, __Value)					SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
 #define SET_EARLYMODE_LEN0_92E(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
 #define SET_EARLYMODE_LEN1_1_92E(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
@@ -338,9 +355,8 @@ typedef struct txdescriptor_8192e
 #define SET_EARLYMODE_LEN2_92E(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,  __Value)
 #define SET_EARLYMODE_LEN3_92E(__pAddr, __Value) 					SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)
 
-
-
 void rtl8192e_fill_fake_txdesc(PADAPTER	padapter,u8*pDesc,u32 BufferLen,u8 IsPsPoll,u8	IsBTQosNull);
+void rtl8192e_cal_txdesc_chksum(u8 *ptxdesc);
 
 #ifdef CONFIG_USB_HCI
 s32 rtl8192eu_init_xmit_priv(PADAPTER padapter);
@@ -358,12 +374,27 @@ s32 rtl8192eu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 s32 rtl8192ee_init_xmit_priv(PADAPTER padapter);
 void rtl8192ee_free_xmit_priv(PADAPTER padapter);
 struct xmit_buf *rtl8192ee_dequeue_xmitbuf(struct rtw_tx_ring *ring);
+s32	rtl8192ee_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
 void	rtl8192ee_xmitframe_resume(_adapter *padapter);
 s32 rtl8192ee_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
 s32 rtl8192ee_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
 void rtl8192ee_xmit_tasklet(void *priv);
 #endif
 
+#if defined(CONFIG_SDIO_HCI)||defined (CONFIG_GSPI_HCI)
+s32 rtl8192es_init_xmit_priv(PADAPTER padapter);
+void rtl8192es_free_xmit_priv(PADAPTER padapter);
+
+s32 rtl8192es_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+s32 rtl8192es_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+s32	rtl8192es_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+thread_return rtl8192es_xmit_thread(thread_context context);
+s32 rtl8192es_xmit_buf_handler(PADAPTER padapter);
+
+#ifdef CONFIG_SDIO_TX_TASKLET
+void rtl8192es_xmit_tasklet(void *priv);
+#endif
+#endif
 
 struct txrpt_ccx_92e {
 	/* offset 0 */
@@ -402,12 +433,19 @@ struct txrpt_ccx_92e {
 #ifdef CONFIG_TX_EARLY_MODE
 void UpdateEarlyModeInfo8192E(struct xmit_priv *pxmitpriv,struct xmit_buf *pxmitbuf );
 #endif
-
+ s32	rtl8192e_init_xmit_priv(_adapter *padapter);
 void _dbg_dump_tx_info(_adapter	*padapter,int frame_tag,u8 *ptxdesc);
 
-u8	BWMapping_92E(PADAPTER Adapter, struct pkt_attrib *pattrib);
+void rtl8192e_fill_fake_txdesc(PADAPTER	padapter,u8*pDesc,u32 BufferLen,u8 IsPsPoll,u8	IsBTQosNull);
+void rtl8192e_cal_txdesc_chksum(u8 *ptxdesc);
 
+u8	BWMapping_92E(PADAPTER Adapter, struct pkt_attrib *pattrib);
 u8	SCMapping_92E(PADAPTER Adapter, struct pkt_attrib	*pattrib);
+void fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
+void fill_txdesc_vcs(struct pkt_attrib *pattrib, u8 *ptxdesc);
+void fill_txdesc_sectype(struct pkt_attrib *pattrib, u8 *ptxdesc);
+void rtl8192e_fixed_rate(_adapter *padapter,u8 *ptxdesc);
 
 #endif //__RTL8192E_XMIT_H__
 
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_cmd.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_cmd.h
index 43523d440f07..ced4a49623ef 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_cmd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_cmd.h
@@ -21,7 +21,7 @@
 #define __RTL8723A_CMD_H__
 
 
-#define H2C_BT_FW_PATCH_LEN 		3
+#define H2C_8723A_BT_FW_PATCH_LEN 		3
 #define H2C_BT_PWR_FORCE_LEN		3
 
 enum cmd_msg_element_id
@@ -49,11 +49,11 @@ enum cmd_msg_element_id
 	BT_PTA_MANAGER_UPDATE_ENABLE_EID = 38,
 	DAC_SWING_VALUE_EID = 41,
 	TRADITIONAL_TDMA_EN_EID = 51,
-	H2C_BT_FW_PATCH = 54,
+	H2C_8723A_BT_FW_PATCH = 54,
 	B_TYPE_TDMA_EID = 58,
 	SCAN_EN_EID = 59,
 	LOWPWR_LPS_EID = 71,
-	H2C_RESET_TSF = 75,
+	H2C_8723A_RESET_TSF = 75,
 	MAX_CMDMSG_EID	 
 };
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_hal.h
index 13c68614c035..d7f7b8fb0a63 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_hal.h
@@ -22,11 +22,7 @@
 
 
 //#include "hal_com.h"
-#if 1
 #include "hal_data.h"
-#else
-#include "../hal/OUTSRC/odm_precomp.h"
-#endif
 
 #include "rtl8723a_spec.h"
 #include "rtl8723a_pg.h"
@@ -155,13 +151,6 @@ typedef struct _RT_FIRMWARE_8723A {
 	u8			szFwBuffer[FW_8723A_SIZE];
 #endif
 	u32			ulFwLength;
-
-#ifdef CONFIG_EMBEDDED_FWIMG
-	u8*			szBTFwBuffer;
-#else
-	u8			szBTFwBuffer[FW_8723A_SIZE];
-#endif
-	u32			ulBTFwLength;
 } RT_FIRMWARE_8723A, *PRT_FIRMWARE_8723A;
 
 //
@@ -448,6 +437,7 @@ void Hal_InitChannelPlan(PADAPTER padapter);
 void rtl8723a_set_hal_ops(struct hal_ops *pHalFunc);
 void SetHwReg8723A(PADAPTER padapter, u8 variable, u8 *val);
 void GetHwReg8723A(PADAPTER padapter, u8 variable, u8 *val);
+u8 GetHalDefVar8723A(PADAPTER Adapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
 #ifdef CONFIG_BT_COEXIST
 void rtl8723a_SingleDualAntennaDetection(PADAPTER padapter);
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_spec.h
index 6f67856f3296..de2c28e281ad 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_spec.h
@@ -98,6 +98,8 @@
 //	General definitions
 //============================================================================
 
+#define MACID_NUM_8723A 32
+#define CAM_ENTRY_NUM_8723A 32
 
-#endif
+#endif /* __RTL8723A_SPEC_H__ */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_xmit.h
index a4bc48d1d04a..0613b87947bc 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723a_xmit.h
@@ -48,7 +48,7 @@
 
 //OFFSET 8
 #define AGG_EN		BIT(29)
-
+#define AMPDU_DENSITY_SHT 20
 //OFFSET 12
 #define SEQ_SHT		16
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_cmd.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_cmd.h
index c7727c4c9f42..9826d0da30ed 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_cmd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_cmd.h
@@ -80,6 +80,8 @@ enum h2c_cmd_8723B{
 	H2C_8723B_D0_SCAN_OFFLOAD_CTRL = 0x85,
 	H2C_8723B_D0_SCAN_OFFLOAD_INFO = 0x86,
 	H2C_8723B_CHNL_SWITCH_OFFLOAD = 0x87,
+	H2C_8723B_P2P_OFFLOAD_RSVD_PAGE = 0x8A,	
+	H2C_8723B_P2P_OFFLOAD = 0x8B,
 
 	H2C_8723B_RESET_TSF = 0xC0,
 	H2C_8723B_MAXID,
@@ -156,38 +158,38 @@ enum h2c_cmd_8723B{
 //----------------------------------    H2C CMD CONTENT    --------------------------------------------------//
 //---------------------------------------------------------------------------------------------------------//
 //_RSVDPAGE_LOC_CMD_0x00
-#define SET_8723B_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-#define SET_8723B_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-#define SET_8723B_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
-#define SET_8723B_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
-#define SET_8723B_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8723B_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
 
 //_MEDIA_STATUS_RPT_PARM_CMD_0x01
-#define SET_8723B_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_8723B_H2CCMD_MSRRPT_PARM_MACID_IND(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_8723B_H2CCMD_MSRRPT_PARM_MACID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-#define SET_8723B_H2CCMD_MSRRPT_PARM_MACID_END(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+#define SET_8723B_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8723B_H2CCMD_MSRRPT_PARM_MACID_IND(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8723B_H2CCMD_MSRRPT_PARM_MACID(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8723B_H2CCMD_MSRRPT_PARM_MACID_END(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+2, 0, 8, __Value)
 
 //_KEEP_ALIVE_CMD_0x03
-#define SET_8723B_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_8723B_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_8723B_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
-#define SET_8723B_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8723B_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8723B_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8723B_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8723B_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+1, 0, 8, __Value)
 
 //_DISCONNECT_DECISION_CMD_0x04
-#define SET_8723B_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_8723B_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_8723B_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-#define SET_8723B_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+#define SET_8723B_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8723B_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8723B_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8723B_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd+2, 0, 8, __Value)
 
 // _PWR_MOD_CMD_0x20
-#define SET_8723B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-#define SET_8723B_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
-#define SET_8723B_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
-#define SET_8723B_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
-#define SET_8723B_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
-#define SET_8723B_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
-#define SET_8723B_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_8723B_H2CCMD_PWRMODE_PARM_BYTE5(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+5, 0, 8, __Value)
 
 #define GET_8723B_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
 
@@ -354,12 +356,16 @@ void rtl8723b_set_ap_wowlan_cmd(_adapter* padapter, u8 enable);
 void SetFwRelatedForWoWLAN8723b(_adapter* padapter, u8 bHostIsGoingtoSleep);
 #endif//CONFIG_WOWLAN
 
+#ifdef CONFIG_P2P_WOWLAN
+void rtl8723b_set_p2p_wowlan_offload_cmd(PADAPTER padapter);
+#endif
+
 void rtl8723b_set_FwPwrModeInIPS_cmd(PADAPTER padapter, u8 cmd_param);
 
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 u8 rtl8723b_reset_tsf(_adapter *padapter, u8 reset_port);
 #endif	// CONFIG_TSF_RESET_OFFLOAD
 s32 FillH2CCmd8723B(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
-
-#define FillH2CCmd FillH2CCmd8723B
+u8 GetTxBufferRsvdPageNum8723B(_adapter *padapter, bool wowlan);
 #endif
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_hal.h
old mode 100644
new mode 100755
index d7a99a470b0a..b80fb451efe3
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_hal.h
@@ -82,14 +82,6 @@ typedef struct _RT_FIRMWARE {
 	u8			szFwBuffer[FW_8723B_SIZE];
 #endif
 	u32			ulFwLength;
-
-#ifdef CONFIG_EMBEDDED_FWIMG
-	u8*			szBTFwBuffer;
-	u8			myBTFwBuffer[FW_8723B_SIZE];
-#else
-	u8			szBTFwBuffer[FW_8723B_SIZE];
-#endif
-	u32			ulBTFwLength;
 } RT_FIRMWARE_8723B, *PRT_FIRMWARE_8723B;
 
 //
@@ -133,7 +125,11 @@ typedef struct _RT_8723B_FIRMWARE_HDR
 #define PAGE_SIZE_RX_8723B			8
 
 #define RX_DMA_SIZE_8723B			0x4000	// 16K
+#ifdef CONFIG_FW_C2H_DEBUG 
+#define RX_DMA_RESERVED_SIZE_8723B	0x100	// 256B, reserved for c2h debug message
+#else
 #define RX_DMA_RESERVED_SIZE_8723B	0x80	// 128B, reserved for tx report
+#endif
 #define RX_DMA_BOUNDARY_8723B		(RX_DMA_SIZE_8723B - RX_DMA_RESERVED_SIZE_8723B - 1)
 
 
@@ -164,7 +160,7 @@ typedef struct _RT_8723B_FIRMWARE_HDR
 
 #ifdef CONFIG_PNO_SUPPORT
 #undef WOWLAN_PAGE_NUM_8723B
-#define WOWLAN_PAGE_NUM_8723B	0x0d
+#define WOWLAN_PAGE_NUM_8723B	0x15
 #endif
 
 #ifdef CONFIG_AP_WOWLAN
@@ -231,6 +227,10 @@ typedef enum _C2H_EVT
 	C2H_8723B_BT_INFO = 9,
 	C2H_HW_INFO_EXCH = 10,
 	C2H_8723B_BT_MP_INFO = 11,
+	C2H_8723B_P2P_RPORT = 0x16,
+#ifdef CONFIG_FW_C2H_DEBUG
+	C2H_8723B_FW_DEBUG = 0xff,
+#endif //CONFIG_FW_C2H_DEBUG
 	MAX_C2HEVENT
 } C2H_EVT;
 
@@ -284,13 +284,16 @@ VOID Hal_EfuseParsePackageType_8723B(PADAPTER pAdapter,u8* hwinfo,BOOLEAN AutoLo
 VOID Hal_EfuseParseVoltage_8723B(PADAPTER pAdapter,u8* hwinfo,BOOLEAN 	AutoLoadFail); 
 
 #ifdef CONFIG_C2H_PACKET_EN
-void C2HPacketHandler_8723B(PADAPTER padapter, u8 *pbuffer, u16 length);
+void rtl8723b_c2h_packet_handler(PADAPTER padapter, u8 *pbuf, u16 length);
 #endif
 
 
 void rtl8723b_set_hal_ops(struct hal_ops *pHalFunc);
 void SetHwReg8723B(PADAPTER padapter, u8 variable, u8 *val);
 void GetHwReg8723B(PADAPTER padapter, u8 variable, u8 *val);
+#ifdef CONFIG_C2H_PACKET_EN
+void SetHwRegWithBuf8723B(PADAPTER padapter, u8 variable, u8 *pbuf, int len);
+#endif // CONFIG_C2H_PACKET_EN
 u8 SetHalDefVar8723B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
 u8 GetHalDefVar8723B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
 
@@ -320,6 +323,9 @@ void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
 int FirmwareDownloadBT(IN PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware);
 
 void CCX_FwC2HTxRpt_8723b(PADAPTER padapter, u8 *pdata, u8 len);
+#ifdef CONFIG_FW_C2H_DEBUG
+void Debug_FwC2H_8723b(PADAPTER padapter, u8 *pdata, u8 len);
+#endif //CONFIG_FW_C2H_DEBUG
 s32 c2h_id_filter_ccx_8723b(u8 *buf);
 s32 c2h_handler_8723b(PADAPTER padapter, u8 *pC2hEvent);
 u8 MRateToHwRate8723B(u8  rate);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_led.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_led.h
old mode 100644
new mode 100755
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_recv.h
old mode 100644
new mode 100755
index 3f0990fd649e..4218f50999b3
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_recv.h
@@ -29,135 +29,13 @@
 #endif // !CONFIG_SDIO_RX_COPY
 #endif // CONFIG_SDIO_HCI
 
-typedef struct rxreport_8723b
-{
-	//DWORD 0
-	u32 pktlen:14;
-	u32 crc32:1;
-	u32 icverr:1;
-	u32 drvinfosize:4;
-	u32 security:3;
-	u32 qos:1;
-	u32 shift:2;
-	u32 physt:1;
-	u32 swdec:1;
-	u32 rsvd0028:2;
-	u32 eor:1;
-	u32 rsvd0031:1;
-
-	//DWORD 1
-	u32 macid:7;
-	u32 rsvd0407:1;
-	u32 tid:4;
-	u32 macid_vld:1;
-	u32 amsdu:1;
-	u32 rxid_match:1;
-	u32 paggr:1;
-	u32 a1fit:4;
-	u32 chkerr:1;  //20
-	u32 rx_ipv:1;
-	u32 rx_is_tcp_udp:1;
-	u32 chk_vld:1;   //23
-	u32 pam:1;
-	u32 pwr:1;
-	u32 md:1;
-	u32 mf:1;
-	u32 type:2;
-	u32 mc:1;
-	u32 bc:1;
-
-	//DWORD 2
-	u32 seq:12;
-	u32 frag:4;
-	u32 rx_is_qos:1;
-	u32 rsvd0817:1;
-	u32 wlanhd_iv_len:6;
-	u32 hwrsvd0824:4;
-	u32 c2h_ind:1;
-	u32 rsvd0829:2;
-	u32 fcs_ok:1;
-
-	//DWORD 3
-	u32 rx_rate:7;
-	u32 rsvd1207:3;
-	u32 htc:1;
-	u32 esop:1;
-	u32 bssid_fit:2;
-	u32 rsvd1214:2;
-	u32 dma_agg_num:8;
-	u32 rsvd1224:5;
-	u32 patternmatch:1;
-	u32 unicastwake:1;
-	u32 magicwake:1;
-	
-	//DWORD 4
-	u32 splcp:1;	//Ofdm sgi or cck_splcp
-	u32 ldpc:1;
-	u32 stbc:1;
-	u32 not_sounding:1;
-	u32 bw:2;
-	u32 rsvd1606:26;
-
-	//DWORD 5
-	u32 tsfl;
-} RXREPORT, *PRXREPORT;
-
-typedef struct phystatus_8723b
-{
-	u32 rxgain_a:7;
-	u32 trsw_a:1;
-	u32 rxgain_b:7;
-	u32 trsw_b:1;
-	u32 chcorr_l:16;
-
-	u32 sigqualcck:8;
-	u32 cfo_a:8;
-	u32 cfo_b:8;
-	u32 chcorr_h:8;
-
-	u32 noisepwrdb_h:8;
-	u32 cfo_tail_a:8;
-	u32 cfo_tail_b:8;
-	u32 rsvd0824:8;
-
-	u32 rsvd1200:8;
-	u32 rxevm_a:8;
-	u32 rxevm_b:8;
-	u32 rxsnr_a:8;
-
-	u32 rxsnr_b:8;
-	u32 noisepwrdb_l:8;
-	u32 rsvd1616:8;
-	u32 postsnr_a:8;
-
-	u32 postsnr_b:8;
-	u32 csi_a:8;
-	u32 csi_b:8;
-	u32 targetcsi_a:8;
-
-	u32 targetcsi_b:8;
-	u32 sigevm:8;
-	u32 maxexpwr:8;
-	u32 exintflag:1;
-	u32 sgien:1;
-	u32 rxsc:2;
-	u32 idlelong:1;
-	u32 anttrainen:1;
-	u32 antselb:1;
-	u32 antsel:1;
-} PHYSTATUS, *PPHYSTATUS;
-
 #if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 s32 rtl8723bs_init_recv_priv(PADAPTER padapter);
 void rtl8723bs_free_recv_priv(PADAPTER padapter);
 #endif
 
-void rtl8723b_query_rx_phy_status(union recv_frame *prframe, struct phy_stat *pphy_stat);
-void rtl8723b_process_phy_info(PADAPTER padapter, void *prframe);
 #ifdef CONFIG_USB_HCI
-void update_recvframe_attrib(PADAPTER padapter, union recv_frame *precvframe, struct recv_stat *prxstat);
-void update_recvframe_phyinfo(union recv_frame *precvframe, struct phy_stat *pphy_info);
-int	rtl8723bu_init_recv_priv(_adapter *padapter);
+int rtl8723bu_init_recv_priv(_adapter *padapter);
 void rtl8723bu_free_recv_priv (_adapter *padapter);
 void rtl8723bu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
 #endif
@@ -167,7 +45,8 @@ s32 rtl8723be_init_recv_priv(PADAPTER padapter);
 void rtl8723be_free_recv_priv(PADAPTER padapter);
 #endif
 
-void	rtl8723b_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);
+void rtl8723b_query_rx_phy_status(union recv_frame *precvframe, struct phy_stat *pphy_status);
+void rtl8723b_query_rx_desc_status(union recv_frame *precvframe, u8 *pdesc);
 
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_spec.h
old mode 100644
new mode 100755
index b1fba0f1b502..aa4bc2cf3552
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_spec.h
@@ -278,16 +278,12 @@
 #define RT_AC_INT_MASKS	(IMR_VIDOK_8723B | IMR_VODOK_8723B | IMR_BEDOK_8723B|IMR_BKDOK_8723B)
 #endif
 
-#endif
+//========================================================
+// General definitions
+//========================================================
 
-#ifdef CONFIG_USB_HCI
-//should be renamed and moved to another file
-typedef	enum _BOARD_TYPE_8192CUSB{
-	BOARD_USB_DONGLE 			= 0,		// USB dongle
-	BOARD_USB_High_PA 		= 1,		// USB dongle with high power PA
-	BOARD_MINICARD		  	= 2,		// Minicard
-	BOARD_USB_SOLO 		 	= 3,		// USB solo-Slim module
-	BOARD_USB_COMBO			= 4,		// USB Combo-Slim module
-} BOARD_TYPE_8723BUSB, *PBOARD_TYPE_8723BUSB;
+#define MACID_NUM_8723B 128
+#define CAM_ENTRY_NUM_8723B 64
+
+#endif /* __RTL8723B_SPEC_H__ */
 
-#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_xmit.h
old mode 100644
new mode 100755
index 2de6a6829c1e..b998233610e2
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8723b_xmit.h
@@ -20,176 +20,9 @@
 #ifndef __RTL8723B_XMIT_H__
 #define __RTL8723B_XMIT_H__
 
-//
-// Queue Select Value in TxDesc
-//
-#define QSLT_BK							0x2//0x01
-#define QSLT_BE							0x0
-#define QSLT_VI							0x5//0x4
-#define QSLT_VO							0x7//0x6
-#define QSLT_BEACON						0x10
-#define QSLT_HIGH						0x11
-#define QSLT_MGNT						0x12
-#define QSLT_CMD						0x13
 
 #define MAX_TID (15)
 
-//OFFSET 0
-#define OFFSET_SZ	0
-#define OFFSET_SHT	16
-#define BMC		BIT(24)
-#define LSG		BIT(26)
-#define FSG		BIT(27)
-#define OWN 		BIT(31)
-
-
-//OFFSET 4
-#define PKT_OFFSET_SZ	0
-#define BK		BIT(6)
-#define QSEL_SHT	8
-#define Rate_ID_SHT	16
-#define NAVUSEHDR	BIT(20)
-#define PKT_OFFSET_SHT	26
-#define HWPC		BIT(31)
-
-//OFFSET 8
-#define AGG_EN		BIT(29)
-
-//OFFSET 12
-#define SEQ_SHT		16
-
-//OFFSET 16
-#define QoS		BIT(6)
-#define HW_SEQ_EN	BIT(7)
-#define USERATE		BIT(8)
-#define DISDATAFB	BIT(10)
-#define DATA_SHORT	BIT(24)
-#define DATA_BW		BIT(25)
-
-//OFFSET 20
-#define SGI		BIT(6)
-
-//
-//defined for TX DESC Operation
-//
-typedef struct txdesc_8723b
-{
-	// Offset 0
-	u32 pktlen:16;
-	u32 offset:8;
-	u32 bmc:1;
-	u32 htc:1;
-	u32 rsvd0026:1;
-	u32 rsvd0027:1;
-	u32 linip:1;
-	u32 noacm:1;
-	u32 gf:1;
-	u32 rsvd0031:1;
-
-	// Offset 4
-	u32 macid:7;
-	u32 rsvd0407:1;
-	u32 qsel:5;
-	u32 rdg_nav_ext:1;
-	u32 lsig_txop_en:1;
-	u32 pifs:1;
-	u32 rate_id:5;
-	u32 en_desc_id:1;
-	u32 sectype:2;
-	u32 pkt_offset:5; // unit: 8 bytes
-	u32 moredata:1;
-	u32 txop_ps_cap:1;
-	u32 txop_ps_mode:1;
-
-	// Offset 8
-	u32 p_aid:9;
-	u32 rsvd0809:1;
-	u32 cca_rts:2;
-	u32 agg_en:1;
-	u32 rdg_en:1;
-	u32 null_0:1;
-	u32 null_1:1;
-	u32 bk:1;
-	u32 morefrag:1;
-	u32 raw:1;
-	u32 spe_rpt:1;
-	u32 ampdu_density:3;
-	u32 bt_null:1;
-	u32 g_id:6;
-	u32 rsvd0830:2;
-
-	// Offset 12
-	u32 wheader_len:4;
-	u32 chk_en:1;
-	u32 early_rate:1;
-	u32 hw_ssn_sel:2;
-	u32 userate:1;
-	u32 disrtsfb:1;
-	u32 disdatafb:1;
-	u32 cts2self:1;
-	u32 rtsen:1;
-	u32 hw_rts_en:1;
-	u32 port_id:1;
-	u32 navusehdr:1;
-	u32 use_max_len:1;
-	u32 max_agg_num:5;
-	u32 ndpa:2;
-	u32 ampdu_max_time:8;
-
-	// Offset 16
-	u32 datarate:7;
-	u32 try_rate:1;
-	u32 data_ratefb_lmt:5;
-	u32 rts_ratefb_lmt:4;
-	u32 rty_lmt_en:1;
-	u32 data_rt_lmt:6;
-	u32 rtsrate:5;
-	u32 pcts_en:1;
-	u32 pcts_mask_idx:2;
-
-	// Offset 20
-	u32 data_sc:4;
-	u32 data_short:1;
-	u32 data_bw:2;
-	u32 data_ldpc:1;
-	u32 data_stbc:2;
-	u32 vcs_stbc:2;
-	u32 rts_short:1;
-	u32 rts_sc:4;
-	u32 rsvd2016:7;
-	u32 tx_ant:4;
-	u32 txpwr_offset:3;
-	u32 rsvd2031:1;
-
-	// Offset 24
-	u32 sw_define:12;
-	u32 mbssid:4;
-	u32 antsel_A:3;
-	u32 antsel_B:3;
-	u32 antsel_C:3;
-	u32 antsel_D:3;
-	u32 rsvd2428:4;
-
-	// Offset 28
-	u32 checksum:16;
-	u32 rsvd2816:8;
-	u32 usb_txagg_num:8;
-
-	// Offset 32
-	u32 rts_rc:6;
-	u32 bar_rty_th:2;
-	u32 data_rc:6;
-	u32 rsvd3214:1;
-	u32 en_hwseq:1;
-	u32 nextneadpage:8;
-	u32 tailpage:8;
-
-	// Offset 36
-	u32 padding_len:11;
-	u32 txbf_path:1;
-	u32 seq:12;
-	u32 final_data_rate:8;
-}TXDESC_8723B, *PTXDESC_8723B;
 
 #ifndef __INC_HAL8723BDESC_H
 #define __INC_HAL8723BDESC_H
@@ -349,6 +182,7 @@ typedef struct txdesc_8723b
 
 // Dword 6
 #define SET_TX_DESC_SW_DEFINE_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 0, 12, __Value)
+#define SET_TX_DESC_MBSSID_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 12, 4, __Value)
 #define SET_TX_DESC_ANTSEL_A_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 16, 3, __Value)
 #define SET_TX_DESC_ANTSEL_B_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 19, 3, __Value)
 #define SET_TX_DESC_ANTSEL_C_8723B(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+24, 22, 3, __Value)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_cmd.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_cmd.h
index 31b7809e43cf..2aee39b36578 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_cmd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_cmd.h
@@ -41,6 +41,7 @@ typedef enum _RTL8812_H2C_CMD
 	H2C_8812_RA_MASK = 0x40,
 	H2C_8812_TxBF = 0x41,
 	H2C_8812_RSSI_REPORT = 0x42,
+	H2C_8812_IQ_CALIBRATION = 0x45,
 
 	H2C_8812_BT_FW_PATCH = 0x6a,
 
@@ -105,7 +106,7 @@ struct H2C_SS_RFOFF_PARAM{
 
 //_SETPWRMODE_PARM
 #define SET_8812_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE_8BIT(__pH2CCmd, 0, 8, __Value)
-#define SET_8812_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
 #define SET_8812_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
 #define SET_8812_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+2, 0, 8, __Value)
 #define SET_8812_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE_8BIT((__pH2CCmd)+3, 0, 8, __Value)
@@ -134,7 +135,12 @@ u8 rtl8812_set_rssi_cmd(PADAPTER padapter, u8 *param);
 void rtl8812_set_raid_cmd(PADAPTER padapter, u32 bitmap, u8* arg);
 void rtl8812_Add_RateATid(PADAPTER padapter, u32 bitmap, u8* arg, u8 rssi_level);
 void rtl8812_set_wowlan_cmd(_adapter* padapter, u8 enable);
+s32 FillH2CCmd_8812(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+u8 GetTxBufferRsvdPageNum8812(_adapter *padapter, bool wowlan);
 
+#ifdef CONFIG_BT_COEXIST
+void rtl8812a_download_BTCoex_AP_mode_rsvd_page(PADAPTER padapter);
+#endif // CONFIG_BT_COEXIST
 #ifdef CONFIG_P2P_PS
 void rtl8812_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
 #endif //CONFIG_P2P
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_hal.h
index 79718ee5933d..67a6518c0037 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_hal.h
@@ -21,11 +21,7 @@
 #define __RTL8812A_HAL_H__
 
 //#include "hal_com.h"
-#if 1
 #include "hal_data.h"
-#else
-#include "../hal/OUTSRC/odm_precomp.h"
-#endif
 
 //include HAL Related header after HAL Related compiling flags 
 #include "rtl8812a_spec.h"
@@ -271,17 +267,6 @@ typedef enum _TX_PWR_PERCENTAGE{
 
 //#define RT_IS_FUNC_DISABLED(__pAdapter, __FuncBits) ( (__pAdapter)->DisabledFunctions & (__FuncBits) )
 
-#define GetRegTxBBSwing_2G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_2G)
-#define GetRegTxBBSwing_5G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_5G)
-
-#define GetRegAmplifierType2G(_Adapter)	(_Adapter->registrypriv.AmplifierType_2G)
-#define GetRegAmplifierType5G(_Adapter)	(_Adapter->registrypriv.AmplifierType_5G)
-
-#define GetRegbENRFEType(_Adapter)	(_Adapter->registrypriv.bEn_RFE)
-#define GetRegRFEType(_Adapter)	(_Adapter->registrypriv.RFE_Type)
-
-#define GetDefaultAdapter(padapter)	padapter
-
 // rtl8812_hal_init.c
 void	_8051Reset8812(PADAPTER padapter);
 s32	FirmwareDownload8812(PADAPTER Adapter, BOOLEAN bUsedWoWLANFw);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_recv.h
index d1c202995fb2..1ad222dc9905 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_recv.h
@@ -22,11 +22,16 @@
 
 #if defined(CONFIG_USB_HCI)
 
+#ifndef MAX_RECVBUF_SZ
 #ifdef PLATFORM_OS_CE
 #define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
 #else
 	#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+		#ifdef CONFIG_PLATFORM_MSTAR
+			#define MAX_RECVBUF_SZ (8192) // 8K
+		#else
 		#define MAX_RECVBUF_SZ (32768) // 32k
+		#endif
 		//#define MAX_RECVBUF_SZ (24576) // 24k
 		//#define MAX_RECVBUF_SZ (20480) //20K
 		//#define MAX_RECVBUF_SZ (10240) //10K
@@ -36,6 +41,7 @@
 		#define MAX_RECVBUF_SZ (4000) // about 4K
 	#endif
 #endif
+#endif //!MAX_RECVBUF_SZ
 
 #elif defined(CONFIG_PCI_HCI)
 //#ifndef CONFIG_MINIMAL_MEMORY_USAGE
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_spec.h
index f1e266f14e7b..c5b56c8494a9 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_spec.h
@@ -59,6 +59,7 @@
 #define REG_PKTBUF_DBG_ADDR 			(REG_PKTBUF_DBG_CTRL)
 #define REG_RXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+2)
 #define REG_TXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+3)
+#define REG_WOWLAN_WAKE_REASON          REG_MCUTST_WOWLAN
 
 #define REG_RSVD3_8812					0x0168
 #define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
@@ -122,6 +123,10 @@
 #define REG_TXPKTBUF_WMAC_LBK_BF_HD_8812	0x045D
 #define REG_NDPA_OPT_CTRL_8812		0x045F
 #define REG_DATA_SC_8812				0x0483
+#ifdef CONFIG_WOWLAN
+#define REG_TXPKTBUF_IV_LOW             0x0484
+#define REG_TXPKTBUF_IV_HIGH            0x0488
+#endif
 #define REG_ARFR2_8812					0x048C
 #define REG_ARFR3_8812					0x0494
 #define REG_TXRPT_START_OFFSET		0x04AC
@@ -244,9 +249,16 @@
 #define	AcmHw_ViqStatus_8812			BIT(6)
 #define	AcmHw_BeqStatus_8812			BIT(7)
 
-#endif //__RTL8188E_SPEC_H__
+//========================================================
+// General definitions
+//========================================================
+
+#define MACID_NUM_8812A 128
+#define CAM_ENTRY_NUM_8812A 64
+
+#endif /* __RTL8812A_SPEC_H__ */
 
 #ifdef CONFIG_RTL8821A
 #include "rtl8821a_spec.h"
-#endif // CONFIG_RTL8821A
+#endif /* CONFIG_RTL8821A */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_xmit.h
index cc87890450f3..42e1a8895c7f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8812a_xmit.h
@@ -20,17 +20,6 @@
 #ifndef __RTL8812A_XMIT_H__
 #define __RTL8812A_XMIT_H__
 
-//
-// Queue Select Value in TxDesc
-//
-#define QSLT_BK							0x2//0x01
-#define QSLT_BE							0x0
-#define QSLT_VI							0x5//0x4
-#define QSLT_VO							0x7//0x6
-#define QSLT_BEACON						0x10
-#define QSLT_HIGH						0x11
-#define QSLT_MGNT						0x12
-#define QSLT_CMD						0x13
 
 //For 88e early mode
 #define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
@@ -331,7 +320,7 @@ typedef struct txdescriptor_8812
 
 
 void rtl8812a_cal_txdesc_chksum(u8 *ptxdesc);
-void rtl8812a_fill_fake_txdesc(PADAPTER	padapter,u8*pDesc,u32 BufferLen,u8 IsPsPoll,u8	IsBTQosNull);
+void rtl8812a_fill_fake_txdesc(PADAPTER	padapter,u8*pDesc,u32 BufferLen,u8 IsPsPoll,u8	IsBTQosNull, u8 bDataFrame);
 void rtl8812a_fill_txdesc_sectype(struct pkt_attrib *pattrib, u8 *ptxdesc);
 void rtl8812a_fill_txdesc_vcs(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
 void rtl8812a_fill_txdesc_phy(PADAPTER padapter, struct pkt_attrib *pattrib, u8 *ptxdesc);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8821a_spec.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8821a_spec.h
index a6fe31b34221..4c79b3a1fa0b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8821a_spec.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtl8821a_spec.h
@@ -42,6 +42,7 @@
 //-----------------------------------------------------
 //	0x0100h ~ 0x01FFh	MACTOP General Configuration
 //-----------------------------------------------------
+#define REG_WOWLAN_WAKE_REASON          REG_MCUTST_WOWLAN
 
 //-----------------------------------------------------
 //	0x0200h ~ 0x027Fh	TXDMA Configuration
@@ -92,6 +93,12 @@
 //       Regsiter Bit and Content definition
 //============================================================
 
+//========================================================
+// General definitions
+//========================================================
 
-#endif // __RTL8821A_SPEC_H__
+#define MACID_NUM_8821A 128
+#define CAM_ENTRY_NUM_8821A 64
+
+#endif /* __RTL8821A_SPEC_H__ */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_android.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_android.h
index 5f3892ca555a..cc59417397a1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_android.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_android.h
@@ -45,6 +45,9 @@ enum ANDROID_WIFI_CMD {
 	ANDROID_WIFI_CMD_P2P_GET_NOA,	
 	ANDROID_WIFI_CMD_P2P_SET_PS,	
 	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE,
+
+	ANDROID_WIFI_CMD_MIRACAST,
+
 #ifdef CONFIG_PNO_SUPPORT
 	ANDROID_WIFI_CMD_PNOSSIDCLR_SET,
 	ANDROID_WIFI_CMD_PNOSETUP_SET,
@@ -76,6 +79,12 @@ enum ANDROID_WIFI_CMD {
 int rtw_android_cmdstr_to_num(char *cmdstr);
 int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);
 
+#if defined(CONFIG_PNO_SUPPORT) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+int rtw_android_pno_enable(struct net_device *net, int pno_enable);
+int rtw_android_cfg80211_pno_setup(struct net_device *net,
+		struct cfg80211_ssid *ssid, int n_ssids, int interval);
+#endif
+
 #if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
 int rtw_android_wifictrl_func_add(void);
 void rtw_android_wifictrl_func_del(void);
@@ -90,5 +99,13 @@ static int rtw_android_wifictrl_func_add(void) { return 0; }
 static void rtw_android_wifictrl_func_del(void) {}
 #endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
 
+#ifdef CONFIG_GPIO_WAKEUP
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+int wifi_configure_gpio(void);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+void wifi_free_gpio(unsigned int gpio);
+#endif //CONFIG_GPIO_WAKEUP
+
+
 #endif //__RTW_ANDROID_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_ap.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_ap.h
index dccd5faa7b57..ed8598fca746 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_ap.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_ap.h
@@ -33,7 +33,8 @@ void free_mlme_ap_info(_adapter *padapter);
 //void update_BCNTIM(_adapter *padapter);
 void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len);
 void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index);
-void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx);
+void _update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx, const char *tag);
+#define update_beacon(adapter, ie_id, oui, tx) _update_beacon((adapter), (ie_id), (oui), (tx), __func__)
 void add_RATid(_adapter *padapter, struct sta_info *psta, u8 rssi_level);
 void expire_timeout_chk(_adapter *padapter);
 void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_bt_mp.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_bt_mp.h
index 7a1fa0d52422..9ede51af8d6a 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_bt_mp.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_bt_mp.h
@@ -75,7 +75,7 @@ typedef enum _MP_BT_PAYLOAD_TYPE{
 	MP_BT_PAYLOAD_ALL_0						= 2,
 	MP_BT_PAYLOAD_11110000					= 3,
 	MP_BT_PAYLOAD_PRBS9						= 4,
-	MP_BT_PAYLOAD_MAX
+	MP_BT_PAYLOAD_MAX						= 8,
 }MP_BT_PAYLOAD_TYPE,*PMP_BT_PAYLOAD_TYPE;
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_btcoex.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_btcoex.h
index dc3e623c3ac4..e7b2fa0a5d6f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_btcoex.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_btcoex.h
@@ -29,7 +29,9 @@
 #define	PACKET_EAPOL			3
 
 void rtw_btcoex_Initialize(PADAPTER);
-void rtw_btcoex_HAL_Initialize(PADAPTER padapter);
+void rtw_btcoex_PowerOnSetting(PADAPTER padapter);
+void rtw_btcoex_PreLoadFirmware(PADAPTER padapter);
+void rtw_btcoex_HAL_Initialize(PADAPTER padapter, u8 bWifiOnly);
 void rtw_btcoex_IpsNotify(PADAPTER, u8 type);
 void rtw_btcoex_LpsNotify(PADAPTER, u8 type);
 void rtw_btcoex_ScanNotify(PADAPTER, u8 type);
@@ -40,7 +42,7 @@ void rtw_btcoex_IQKNotify(PADAPTER padapter, u8 state);
 void rtw_btcoex_BtInfoNotify(PADAPTER, u8 length, u8 *tmpBuf);
 void rtw_btcoex_SuspendNotify(PADAPTER, u8 state);
 void rtw_btcoex_HaltNotify(PADAPTER);
-void rtw_btcoex_SwitchGntBt(PADAPTER);
+void rtw_btcoex_SwitchBtTRxMask(PADAPTER);
 void rtw_btcoex_Switch(PADAPTER, u8 enable);
 u8 rtw_btcoex_IsBtDisabled(PADAPTER);
 void rtw_btcoex_Handler(PADAPTER);
@@ -54,8 +56,9 @@ u8 rtw_btcoex_RpwmVal(PADAPTER);
 u8 rtw_btcoex_LpsVal(PADAPTER);
 void rtw_btcoex_SetBTCoexist(PADAPTER, u8 bBtExist);
 void rtw_btcoex_SetChipType(PADAPTER, u8 chipType);
-void rtw_btcoex_SetPGAntNum(PADAPTER, u8 antNum, u8 antInverse);
+void rtw_btcoex_SetPGAntNum(PADAPTER, u8 antNum);
 u8 rtw_btcoex_GetPGAntNum(PADAPTER);
+void rtw_btcoex_SetSingleAntPath(PADAPTER padapter, u8 singleAntPath);
 u32 rtw_btcoex_GetRaMask(PADAPTER);
 void rtw_btcoex_RecordPwrMode(PADAPTER, u8 *pCmdBuf, u8 cmdLen);
 void rtw_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_cmd.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_cmd.h
index d0635d37fd14..eb0e33ea10f1 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_cmd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_cmd.h
@@ -173,6 +173,16 @@ struct P2P_PS_CTWPeriod_t {
 	u8 CTWPeriod;	//TU
 };
 
+#ifdef CONFIG_P2P_WOWLAN
+
+struct P2P_WoWlan_Offload_t{
+	u8 Disconnect_Wkup_Drv:1;
+	u8 role:2;
+	u8 Wps_Config[2];
+};
+
+#endif //CONFIG_P2P_WOWLAN
+
 extern u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
 extern struct cmd_obj *rtw_dequeue_cmd(struct cmd_priv *pcmdpriv);
 extern void rtw_free_cmd_obj(struct cmd_obj *pcmd);
@@ -222,6 +232,7 @@ enum rtw_drvextra_cmd_id
 	DM_RA_MSK_WK_CID, //add for STA update RAMask when bandwith change.
 	BEAMFORMING_WK_CID,
 	LPS_CHANGE_DTIM_CID,
+	BTINFO_WK_CID,
 	MAX_WK_CID
 };
 
@@ -234,6 +245,9 @@ enum LPS_CTRL_TYPE
 	LPS_CTRL_SPECIAL_PACKET=4,
 	LPS_CTRL_LEAVE=5,
 	LPS_CTRL_TRAFFIC_BUSY = 6,
+	LPS_CTRL_TX_TRAFFIC_LEAVE = 7,
+	LPS_CTRL_RX_TRAFFIC_LEAVE = 8,	
+	LPS_CTRL_ENTER = 9,
 };
 
 enum RFINTFS {
@@ -951,6 +965,14 @@ struct TDLSoption_param
 	u8 option;
 };
 
+/*H2C Handler index: 64 */
+struct RunInThread_param
+{
+	void (*func)(void*);
+	void *context;
+};
+
+
 #define GEN_CMD_CODE(cmd)	cmd ## _CMD_
 
 
@@ -1031,6 +1053,10 @@ extern u8 rtw_ps_cmd(_adapter*padapter);
 u8 rtw_chk_hi_queue_cmd(_adapter*padapter);
 #endif
 
+#ifdef CONFIG_BT_COEXIST
+u8 rtw_btinfo_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
+#endif
+
 u8 rtw_set_ch_cmd(_adapter*padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue);
 extern u8 rtw_set_chplan_cmd(_adapter*padapter, u8 chplan, u8 enqueue, u8 swconfig);
 extern u8 rtw_led_blink_cmd(_adapter*padapter, PVOID pLed);
@@ -1043,6 +1069,8 @@ extern u8 rtw_c2h_packet_wk_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
 extern u8 rtw_c2h_wk_cmd(PADAPTER padapter, u8 *c2h_evt);
 //#endif
 
+u8 rtw_run_in_thread_cmd(PADAPTER padapter, void (*func)(void*), void* context);
+
 u8 rtw_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf);
 
 extern void rtw_survey_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
@@ -1136,7 +1164,9 @@ enum rtw_h2c_cmd
 	GEN_CMD_CODE(_SetChannelSwitch), /*61*/
 	GEN_CMD_CODE(_TDLS), /*62*/
 	GEN_CMD_CODE(_ChkBMCSleepq), /*63*/
-	
+
+	GEN_CMD_CODE(_RunInThreadCMD), /*64*/
+
 	MAX_H2CCMD
 };
 
@@ -1219,6 +1249,8 @@ struct _cmd_callback 	rtw_cmd_callback[] =
 	{GEN_CMD_CODE(_SetChannelSwitch), NULL},/*61*/
 	{GEN_CMD_CODE(_TDLS), NULL},/*62*/
 	{GEN_CMD_CODE(_ChkBMCSleepq), NULL}, /*63*/
+
+	{GEN_CMD_CODE(_RunInThreadCMD), NULL},/*64*/
 };
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_debug.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_debug.h
index 09490bc00cff..67edf7f0a6d0 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_debug.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_debug.h
@@ -194,6 +194,8 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 
 #if defined(_dbgdump)
 
+#define DBG_871X_EXP(level, EXP) do { if (level <= GlobalDebugLevel) EXP; } while (0)
+
 /* with driver-defined prefix */
 #undef DBG_871X_LEVEL
 #define DBG_871X_LEVEL(level, fmt, arg...)     \
@@ -317,6 +319,12 @@ extern void rtl871x_cedbg(const char *fmt, ...);
 #endif /* defined(_dbgdump) */
 #endif /* CONFIG_DEBUG_RTL871X */
 
+#ifdef CONFIG_DBG_COUNTER
+#define DBG_COUNTER(counter) counter++
+#else
+#define DBG_COUNTER(counter) 
+#endif
+
 void dump_drv_version(void *sel);
 void dump_log_level(void *sel);
 
@@ -328,6 +336,12 @@ void mac_reg_dump(void *sel, _adapter *adapter);
 void bb_reg_dump(void *sel, _adapter *adapter);
 void rf_reg_dump(void *sel, _adapter *adapter);
 
+bool rtw_fwdl_test_trigger_chksum_fail(void);
+bool rtw_fwdl_test_trigger_wintint_rdy_fail(void);
+
+u32 rtw_get_wait_hiq_empty_ms(void);
+void rtw_sink_rtp_seq_dbg( _adapter *adapter,_pkt *pkt);
+
 #ifdef CONFIG_PROC_DEBUG
 ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 int proc_get_read_reg(struct seq_file *m, void *v);
@@ -351,7 +365,11 @@ int proc_get_ap_info(struct seq_file *m, void *v);
 int proc_get_adapter_state(struct seq_file *m, void *v);
 int proc_get_trx_info(struct seq_file *m, void *v);
 int proc_get_rate_ctl(struct seq_file *m, void *v);
+int proc_get_wifi_spec(struct seq_file *m, void *v);
 ssize_t proc_set_rate_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_dis_pwt(struct seq_file *m, void *v);
+ssize_t proc_set_dis_pwt(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);	
+
 int proc_get_suspend_resume_info(struct seq_file *m, void *v);
 
 ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
@@ -389,14 +407,24 @@ ssize_t proc_set_rx_ampdu(struct file *file, const char __user *buffer, size_t c
 
 int proc_get_rx_stbc(struct seq_file *m, void *v);
 ssize_t proc_set_rx_stbc(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+
+int proc_get_rx_ampdu_factor(struct seq_file *m, void *v);
+ssize_t proc_set_rx_ampdu_factor(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_rx_ampdu_density(struct seq_file *m, void *v);
+ssize_t proc_set_rx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_tx_ampdu_density(struct seq_file *m, void *v);
+ssize_t proc_set_tx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 #endif /* CONFIG_80211N_HT */
 
 int proc_get_en_fwps(struct seq_file *m, void *v);
 ssize_t proc_set_en_fwps(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
 //int proc_get_two_path_rssi(struct seq_file *m, void *v);
-int proc_get_rssi_disp(struct seq_file *m, void *v);
-ssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+//int proc_get_rssi_disp(struct seq_file *m, void *v);
+//ssize_t proc_set_rssi_disp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
 #ifdef CONFIG_BT_COEXIST
 int proc_get_btcoex_dbg(struct seq_file *m, void *v);
@@ -417,6 +445,24 @@ ssize_t proc_set_odm_dbg_level(struct file *file, const char __user *buffer, siz
 int proc_get_odm_adaptivity(struct seq_file *m, void *v);
 ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
+#ifdef CONFIG_DBG_COUNTER
+int proc_get_rx_logs(struct seq_file *m, void *v);
+int proc_get_tx_logs(struct seq_file *m, void *v);
+int proc_get_int_logs(struct seq_file *m, void *v);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+int proc_get_rx_ring(struct seq_file *m, void *v);
+int proc_get_tx_ring(struct seq_file *m, void *v);
+#endif
+
+#ifdef CONFIG_P2P_WOWLAN
+int proc_get_p2p_wowlan_info(struct seq_file *m, void *v);
+#endif /* CONFIG_P2P_WOWLAN */
+
+int proc_get_new_bcn_max(struct seq_file *m, void *v);
+ssize_t proc_set_new_bcn_max(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
 #endif /* CONFIG_PROC_DEBUG */
 
 #endif	//__RTW_DEBUG_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_eeprom.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_eeprom.h
index 0bb448adc7ed..7705adc9bd52 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_eeprom.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_eeprom.h
@@ -129,7 +129,7 @@ struct eeprom_priv
 #endif //CONFIG_RF_GAIN_OFFSET
 
 #ifdef CONFIG_SDIO_HCI
-	u8		sdio_setting;
+	u8		sdio_setting;	
 	u32		ocr;
 	u8		cis0[eeprom_cis0_sz];
 	u8		cis1[eeprom_cis1_sz];	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_event.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_event.h
index e2c63248d3a7..2fb9503e89c5 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_event.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_event.h
@@ -82,6 +82,10 @@ struct addba_event
  	unsigned int tid;
 };
 
+struct wmm_event
+{
+ 	unsigned char wmm;
+};
 
 #ifdef CONFIG_H2CLBK
 struct c2hlbk_event{
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_ht.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_ht.h
index fb9948a10436..84b3bfb13443 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_ht.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_ht.h
@@ -32,6 +32,8 @@ struct ht_priv
 	u32	tx_amsdu_maxlen; // 1: 8k, 0:4k ; default:8k, for tx
 	u32	rx_ampdu_maxlen; //for rx reordering ctrl win_sz, updated when join_callback.
 	
+	u8 	rx_ampdu_min_spacing;
+	
 	u8	ch_offset;//PRIME_CHNL_OFFSET
 	u8	sgi_20m;
 	u8	sgi_40m;
@@ -94,29 +96,74 @@ typedef enum _RT_HT_INF1_CAP{
 //------------------------------------------------------------
 // The HT Control field
 //------------------------------------------------------------
-#define SET_HT_CTRL_CSI_STEERING(_pEleStart, _val)					SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 6, 2, _val)
-#define SET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE((_pEleStart)+3, 0, 1, _val)
-#define GET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+3, 0, 1)
+#define SET_HT_CTRL_CSI_STEERING(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8*)(_pEleStart))+2, 6, 2, _val)
+#define SET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8*)(_pEleStart))+3, 0, 1, _val)
+#define GET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+3, 0, 1)
 
 // 20/40 BSS Coexist
-#define SET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE((_pEleStart), 0, 1, _val)
-#define GET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart), 0, 1)
-
-
-#define GET_HT_CAPABILITY_ELE_LDPC_CAP(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 0, 1)
-#define GET_HT_CAPABILITY_ELE_TX_STBC(_pEleStart)					LE_BITS_TO_1BYTE(_pEleStart, 7, 1)
-
-#define GET_HT_CAPABILITY_ELE_RX_STBC(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+1, 0, 2)
+#define SET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8*)(_pEleStart)), 0, 1, _val)
+#define GET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart)), 0, 1)
+
+/* HT Capabilities Info field */
+#define HT_CAP_ELE_CAP_INFO(_pEleStart)					((u8*)(_pEleStart))
+#define GET_HT_CAP_ELE_LDPC_CAP(_pEleStart)				LE_BITS_TO_1BYTE(((u8*)(_pEleStart)), 0, 1)
+#define GET_HT_CAP_ELE_CHL_WIDTH(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart)), 1, 1)
+#define GET_HT_CAP_ELE_SM_PS(_pEleStart)				LE_BITS_TO_1BYTE(((u8*)(_pEleStart)), 2, 2)
+#define GET_HT_CAP_ELE_GREENFIELD(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart)), 4, 1)
+#define GET_HT_CAP_ELE_SHORT_GI20M(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart)), 5, 1)
+#define GET_HT_CAP_ELE_SHORT_GI40M(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart)), 6, 1)
+#define GET_HT_CAP_ELE_TX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(((u8*)(_pEleStart)), 7, 1)
+#define GET_HT_CAP_ELE_RX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+1, 0, 2)
+#define GET_HT_CAP_ELE_DELAYED_BA(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+1, 2, 1)
+#define GET_HT_CAP_ELE_MAX_AMSDU_LENGTH(_pEleStart)		LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+1, 3, 1)
+#define GET_HT_CAP_ELE_DSSS_CCK_40M(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+1, 4, 1)
+#define GET_HT_CAP_ELE_FORTY_INTOLERANT(_pEleStart)		LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+1, 6, 1)
+#define GET_HT_CAP_ELE_LSIG_TXOP_PROTECT(_pEleStart)	LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+1, 7, 1)
+
+#define SET_HT_CAP_ELE_FORTY_INTOLERANT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8*)(_pEleStart))+1, 6, 1, _val)
+
+/* A-MPDU Parameters field */
+#define HT_CAP_ELE_AMPDU_PARA(_pEleStart)				(((u8*)(_pEleStart))+2)
+#define GET_HT_CAP_ELE_MAX_AMPDU_LEN_EXP(_pEleStart)	LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+2, 0, 2)
+#define GET_HT_CAP_ELE_MIN_MPDU_S_SPACE(_pEleStart)		LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+2, 2, 3)
+
+#define HT_AMPDU_PARA_FMT "%02x " \
+	"MAX AMPDU len:%u bytes, MIN MPDU Start Spacing:%u"
+
+#define HT_AMPDU_PARA_ARG(x) \
+	*((u8*)(x)) \
+	, (1 << (13+GET_HT_CAP_ELE_MAX_AMPDU_LEN_EXP(((u8*)x)-2)))-1 \
+	, GET_HT_CAP_ELE_MIN_MPDU_S_SPACE(((u8*)x)-2)
+
+/* Supported MCS Set field */
+#define HT_CAP_ELE_SUP_MCS_SET(_pEleStart)				(((u8*)(_pEleStart))+3)
+#define HT_CAP_ELE_RX_MCS_MAP(_pEleStart)				HT_CAP_ELE_SUP_MCS_SET(_pEleStart)
+#define GET_HT_CAP_ELE_RX_HIGHEST_DATA_RATE(_pEleStart)	LE_BITS_TO_2BYTE(((u8*)(_pEleStart))+13, 0, 10)
+#define GET_HT_CAP_ELE_TX_MCS_DEF(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+15, 0, 1)
+#define GET_HT_CAP_ELE_TRX_MCS_NEQ(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+15, 1, 1)
+#define GET_HT_CAP_ELE_TX_MAX_SS(_pEleStart)			LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+15, 2, 2)
+#define GET_HT_CAP_ELE_TX_UEQM(_pEleStart)				LE_BITS_TO_1BYTE(((u8*)(_pEleStart))+15, 4, 1)
+
+#define HT_SUP_MCS_SET_FMT "%02x %02x %02x %02x %02x%02x%02x%02x%02x%02x" \
+	/* "\n%02x%02x%02x%02x%02x%02x" */\
+	" %uMbps %s%s%s"
+#define HT_SUP_MCS_SET_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5], \
+	((u8*)(x))[6],((u8*)(x))[7],((u8*)(x))[8],((u8*)(x))[9] \
+	/*,((u8*)(x))[10],((u8*)(x))[11], ((u8*)(x))[12],((u8*)(x))[13],((u8*)(x))[14],((u8*)(x))[15] */\
+	, GET_HT_CAP_ELE_RX_HIGHEST_DATA_RATE(((u8*)x)-3) \
+	, GET_HT_CAP_ELE_TX_MCS_DEF(((u8*)x)-3) ? "TX_MCS_DEF " : "" \
+	, GET_HT_CAP_ELE_TRX_MCS_NEQ(((u8*)x)-3) ? "TRX_MCS_NEQ " : "" \
+	, GET_HT_CAP_ELE_TX_UEQM(((u8*)x)-3) ? "TX_UEQM " : ""
 
 //TXBF Capabilities
-#define SET_HT_CAP_TXBF_RECEIVE_NDP_CAP(_pEleStart, _val)					SET_BITS_TO_LE_4BYTE( ((u8 *)(_pEleStart))+21, 3, 1, ((u8)_val) )
-#define SET_HT_CAP_TXBF_TRANSMIT_NDP_CAP(_pEleStart, _val)				SET_BITS_TO_LE_4BYTE( ((u8 *)(_pEleStart))+21, 4, 1, ((u8)_val) )
-#define SET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart, _val)		SET_BITS_TO_LE_4BYTE( ((u8 *)(_pEleStart))+21, 10, 1, ((u8)_val) )
-#define SET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart, _val)		SET_BITS_TO_LE_4BYTE( ((u8 *)(_pEleStart))+21, 15, 2, ((u8)_val) )
+#define SET_HT_CAP_TXBF_RECEIVE_NDP_CAP(_pEleStart, _val)					SET_BITS_TO_LE_4BYTE( ((u8*)(_pEleStart))+21, 3, 1, ((u8)_val) )
+#define SET_HT_CAP_TXBF_TRANSMIT_NDP_CAP(_pEleStart, _val)				SET_BITS_TO_LE_4BYTE( ((u8*)(_pEleStart))+21, 4, 1, ((u8)_val) )
+#define SET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart, _val)		SET_BITS_TO_LE_4BYTE( ((u8*)(_pEleStart))+21, 10, 1, ((u8)_val) )
+#define SET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart, _val)		SET_BITS_TO_LE_4BYTE( ((u8*)(_pEleStart))+21, 15, 2, ((u8)_val) )
 #define SET_HT_CAP_TXBF_COMP_STEERING_NUM_ANTENNAS(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE( ((u8 *)(_pEleStart))+21, 23, 2, ((u8)_val) )
 
-#define GET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart)			LE_BITS_TO_4BYTE((_pEleStart)+21, 10, 1)
-#define GET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart)			LE_BITS_TO_4BYTE((_pEleStart)+21, 15, 2)
+#define GET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart)			LE_BITS_TO_4BYTE(((u8*)(_pEleStart))+21, 10, 1)
+#define GET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart)			LE_BITS_TO_4BYTE(((u8*)(_pEleStart))+21, 15, 2)
 
 #endif	//_RTL871X_HT_H_
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_io.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_io.h
index 10b21477426e..bad0acc5f4d9 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_io.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_io.h
@@ -312,6 +312,11 @@ struct reg_protocol_wt {
 #define MAX_CONTINUAL_IO_ERR SD_IO_TRY_CNT
 #endif
 
+#ifdef CONFIG_GSPI_HCI
+#define SD_IO_TRY_CNT (8)
+#define MAX_CONTINUAL_IO_ERR SD_IO_TRY_CNT
+#endif
+
 
 int rtw_inc_and_chk_continual_io_error(struct dvobj_priv *dvobj);
 void rtw_reset_continual_io_error(struct dvobj_priv *dvobj);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mem.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mem.h
new file mode 100644
index 000000000000..5283d777827f
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mem.h
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_MEM_H__
+#define __RTW_MEM_H__
+
+#include <drv_conf.h>
+#include <basic_types.h>
+#include <osdep_service.h>
+
+
+#ifndef MAX_RECVBUF_SZ
+#define MAX_RECVBUF_SZ (32768-RECVBUFF_ALIGN_SZ) // 32k
+#endif
+
+struct u8* rtw_alloc_revcbuf_premem(void);
+struct sk_buff *rtw_alloc_skb_premem(void);
+int rtw_free_skb_premem(struct sk_buff *pskb);
+
+
+#endif //__RTW_MEM_H__
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mlme.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mlme.h
index 5615fecf3010..908a1733bd9f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mlme.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mlme.h
@@ -254,11 +254,33 @@ struct cfg80211_wifidirect_info{
 	struct ieee80211_channel	remain_on_ch_channel;
 	enum nl80211_channel_type	remain_on_ch_type;
 	u64						remain_on_ch_cookie;
+	bool not_indic_ro_ch_exp;
 	bool is_ro_ch;
 	u32 last_ro_ch_time; /* this will be updated at the beginning and end of ro_ch */
 };
 #endif //CONFIG_IOCTL_CFG80211
 
+#ifdef CONFIG_P2P_WOWLAN
+
+enum P2P_WOWLAN_RECV_FRAME_TYPE
+{
+	P2P_WOWLAN_RECV_NEGO_REQ = 0,
+	P2P_WOWLAN_RECV_INVITE_REQ = 1,
+	P2P_WOWLAN_RECV_PROVISION_REQ = 2,
+};
+
+struct p2p_wowlan_info{
+
+	u8 						is_trigger;
+	enum P2P_WOWLAN_RECV_FRAME_TYPE	wowlan_recv_frame_type;
+	u8 						wowlan_peer_addr[ETH_ALEN];
+	u16						wowlan_peer_wpsconfig;
+	u8						wowlan_peer_is_persistent;
+	u8						wowlan_peer_invitation_type;
+};
+
+#endif //CONFIG_P2P_WOWLAN
+
 struct wifidirect_info{
 	_adapter*				padapter;
 	_timer					find_phase_timer;
@@ -284,6 +306,11 @@ struct wifidirect_info{
 #ifdef CONFIG_WFD
 	struct wifi_display_info		*wfd_info;
 #endif	
+
+#ifdef CONFIG_P2P_WOWLAN
+	struct p2p_wowlan_info		p2p_wow_info;
+#endif //CONFIG_P2P_WOWLAN
+
 	enum P2P_ROLE			role;
 	enum P2P_STATE			pre_p2p_state;
 	enum P2P_STATE			p2p_state;
@@ -401,6 +428,18 @@ enum {
 	RTW_ROAM_ACTIVE = BIT2,
 };
 
+struct beacon_keys {
+	u8 ssid[IW_ESSID_MAX_SIZE];
+	u32 ssid_len;
+	u8 bcn_channel;
+	u16 ht_cap_info;
+	u8 ht_info_infos_0_sco; // bit0 & bit1 in infos[0] is second channel offset
+	int encryp_protocol;
+	int pairwise_cipher;
+	int group_cipher;
+	int is_8021x;
+};
+
 struct mlme_priv {
 
 	_lock	lock;
@@ -431,6 +470,12 @@ struct mlme_priv {
 
 	struct wlan_network	cur_network;
 	struct wlan_network *cur_network_scanned;
+
+	// bcn check info
+	struct beacon_keys cur_beacon_keys; // save current beacon keys
+	struct beacon_keys new_beacon_keys; // save new beacon keys
+	u8 new_beacon_cnts; // if new_beacon_cnts >= threshold, ap beacon is changed
+
 #ifdef CONFIG_ARP_KEEP_ALIVE
 	// for arp offload keep alive
 	u8	gw_mac_addr[6];
@@ -618,9 +663,9 @@ struct mlme_priv {
 #ifdef CONFIG_CONCURRENT_MODE
 	u8	scanning_via_buddy_intf;
 #endif
-	u8       NumOfBcnInfoChkFail;
-	u32     timeBcnInfoChkStart;
 
+//	u8 	NumOfBcnInfoChkFail;
+//	u32	timeBcnInfoChkStart;
 };
 
 #define rtw_mlme_set_auto_scan_int(adapter, ms) \
@@ -656,6 +701,7 @@ extern void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf);
 extern void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf);
 extern void rtw_atimdone_event_callback(_adapter *adapter, u8 *pbuf);
 extern void rtw_cpwm_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_wmm_event_callback(PADAPTER padapter, u8 *pbuf);
 
 extern void rtw_join_timeout_handler(RTW_TIMER_HDL_ARGS);
 extern void _rtw_scan_timeout_handler(RTW_TIMER_HDL_ARGS);
@@ -784,7 +830,8 @@ struct wlan_network *rtw_find_same_network(_queue *scanned_queue, struct wlan_ne
 extern void rtw_free_assoc_resources(_adapter* adapter, int lock_scanned_queue);
 extern void rtw_indicate_disconnect(_adapter* adapter);
 extern void rtw_indicate_connect(_adapter* adapter);
-extern void rtw_free_network_nolock(_adapter* adapter, struct wlan_network *pnetwork );
+extern void rtw_free_network_nolock(_adapter* adapter,
+		struct wlan_network *pnetwork);
 void rtw_indicate_scan_done( _adapter *padapter, bool aborted);
 void rtw_scan_abort(_adapter *adapter);
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mlme_ext.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mlme_ext.h
index c40fca01df73..3c781d0e5648 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mlme_ext.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mlme_ext.h
@@ -104,6 +104,15 @@
 #define		_48M_RATE_	10
 #define		_54M_RATE_	11
 
+/********************************************************
+MCS rate definitions
+*********************************************************/
+#define MCS_RATE_1R	(0x000000ff)
+#define MCS_RATE_2R	(0x0000ffff)
+#define MCS_RATE_3R	(0x00ffffff)
+#define MCS_RATE_4R	(0xffffffff)
+#define MCS_RATE_2R_13TO15_OFF	(0x00001fff)
+
 
 extern unsigned char RTW_WPA_OUI[];
 extern unsigned char WMM_OUI[];
@@ -187,6 +196,7 @@ typedef enum _RT_CHANNEL_DOMAIN
 	RT_CHANNEL_DOMAIN_FCC1_FCC9 = 0x55,
 	RT_CHANNEL_DOMAIN_WORLD_ETSI13 = 0x56,
 	RT_CHANNEL_DOMAIN_FCC1_FCC10 = 0x57,
+	RT_CHANNEL_DOMAIN_WORLD_MKK4 = 0x58,
 	//===== Add new channel plan above this line===============//
 	RT_CHANNEL_DOMAIN_MAX,
 	RT_CHANNEL_DOMAIN_REALTEK_DEFINE = 0x7F,
@@ -239,11 +249,15 @@ typedef enum _RT_CHANNEL_DOMAIN_5G
 	RT_CHANNEL_DOMAIN_5G_FCC9 = 0x1D,		//(w/o Weather radar)
 	RT_CHANNEL_DOMAIN_5G_ETSI13 = 0x1E,		//(w/o Weather radar)
 	RT_CHANNEL_DOMAIN_5G_FCC10 = 0x1F,		//Argentina (w/o Weather radar)
+	RT_CHANNEL_DOMAIN_5G_KCC2 = 0x20,		//Korea 5G
+	RT_CHANNEL_DOMAIN_5G_FCC11 = 0x21,		//US/Canada
+	RT_CHANNEL_DOMAIN_5G_NCC5 = 0x22,		//Taiwan
+	RT_CHANNEL_DOMAIN_5G_MKK4 = 0x23,		//Japan W52
 	//===== Add new channel plan above this line===============//
 	//===== Driver Self Defined =====//
-	RT_CHANNEL_DOMAIN_5G_FCC = 0x20,
-	RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS = 0x21,
-	RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS = 0x22,
+	RT_CHANNEL_DOMAIN_5G_FCC = 0x30,
+	RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS = 0x31,
+	RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS = 0x32,
 	RT_CHANNEL_DOMAIN_5G_MAX,
 }RT_CHANNEL_DOMAIN_5G, *PRT_CHANNEL_DOMAIN_5G;
 
@@ -288,26 +302,26 @@ enum Associated_AP
 
 typedef enum _HT_IOT_PEER
 {
-	HT_IOT_PEER_UNKNOWN			= 0,
-	HT_IOT_PEER_REALTEK			= 1,
-	HT_IOT_PEER_REALTEK_92SE		= 2,
-	HT_IOT_PEER_BROADCOM			= 3,
-	HT_IOT_PEER_RALINK			= 4,
-	HT_IOT_PEER_ATHEROS			= 5,
-	HT_IOT_PEER_CISCO			= 6,
-	HT_IOT_PEER_MERU			= 7,
-	HT_IOT_PEER_MARVELL			= 8,
-	HT_IOT_PEER_REALTEK_SOFTAP	= 9,// peer is RealTek SOFT_AP, by Bohn, 2009.12.17
-	HT_IOT_PEER_SELF_SOFTAP			= 10, // Self is SoftAP
-	HT_IOT_PEER_AIRGO			= 11,
-	HT_IOT_PEER_INTEL			= 12,
-	HT_IOT_PEER_RTK_APCLIENT		= 13,
-	HT_IOT_PEER_REALTEK_81XX		= 14,
-	HT_IOT_PEER_REALTEK_WOW			= 15,
-	HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP	= 16,
-	HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP	= 17,
+	HT_IOT_PEER_UNKNOWN 			= 0,
+	HT_IOT_PEER_REALTEK 			= 1,
+	HT_IOT_PEER_REALTEK_92SE 		= 2,
+	HT_IOT_PEER_BROADCOM 		= 3,
+	HT_IOT_PEER_RALINK 			= 4,
+	HT_IOT_PEER_ATHEROS 			= 5,
+	HT_IOT_PEER_CISCO 				= 6,
+	HT_IOT_PEER_MERU 				= 7,	
+	HT_IOT_PEER_MARVELL 			= 8,
+	HT_IOT_PEER_REALTEK_SOFTAP 	= 9,// peer is RealTek SOFT_AP, by Bohn, 2009.12.17
+	HT_IOT_PEER_SELF_SOFTAP 		= 10, // Self is SoftAP
+	HT_IOT_PEER_AIRGO 				= 11,
+	HT_IOT_PEER_INTEL 				= 12, 
+	HT_IOT_PEER_RTK_APCLIENT 		= 13, 
+	HT_IOT_PEER_REALTEK_81XX 		= 14,	
+	HT_IOT_PEER_REALTEK_WOW 		= 15,
+	HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
+	HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
 	HT_IOT_PEER_TPLINK_745N			= 18,
-	HT_IOT_PEER_MAX				= 19
+	HT_IOT_PEER_MAX 				= 19
 }HT_IOT_PEER_E, *PHTIOT_PEER_E;
 
 
@@ -554,6 +568,9 @@ struct mlme_ext_priv
 	struct p2p_channels channel_list;
 	unsigned char	basicrate[NumRates];
 	unsigned char	datarate[NumRates];
+#ifdef CONFIG_80211N_HT
+	unsigned char default_supported_mcs_set[16];
+#endif
 	
 	struct ss_res		sitesurvey_res;		
 	struct mlme_ext_info	mlmext_info;//for sta/adhoc mode, including current scanning/connecting/connected related info.
@@ -601,6 +618,7 @@ struct mlme_ext_priv
 	
 };
 
+void init_mlme_default_rate_set(_adapter* padapter);
 int init_mlme_ext_priv(_adapter* padapter);
 int init_hw_mlme_ext(_adapter *padapter);
 void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext);
@@ -616,6 +634,7 @@ unsigned char networktype_to_raid_ex(_adapter *adapter, struct sta_info *psta);
 
 u8 judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen);
 void get_rate_set(_adapter *padapter, unsigned char *pbssrate, int *bssrate_len);
+void set_mcs_rate_by_mask(u8 *mcs_set, u32 mask);
 void UpdateBrateTbl(_adapter *padapter,u8 *mBratesOS);
 void UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen);
 void change_band_update_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork);
@@ -647,6 +666,7 @@ void SetBWMode(_adapter *padapter, unsigned short bwmode, unsigned char channel_
 unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval);
 
 void read_cam(_adapter *padapter ,u8 entry, u8 *get_key);
+void dump_cam_table(_adapter *padapter);
 
 /* modify HW only */
 void _write_cam(_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key);
@@ -698,8 +718,11 @@ void ERP_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
 void VCS_update(_adapter *padapter, struct sta_info *psta);
 void	update_ldpc_stbc_cap(struct sta_info *psta);
 
-void update_beacon_info(_adapter *padapter, u8 *pframe, uint len, struct sta_info *psta);
+int rtw_get_bcn_keys(ADAPTER *Adapter, u8 *pframe, u32 packet_len,
+		struct beacon_keys *recv_beacon);
+void rtw_dump_bcn_keys(struct beacon_keys *recv_beacon);
 int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len);
+void update_beacon_info(_adapter *padapter, u8 *pframe, uint len, struct sta_info *psta);
 #ifdef CONFIG_DFS
 void process_csa_ie(_adapter *padapter, u8 *pframe, uint len);
 #endif //CONFIG_DFS
@@ -730,10 +753,22 @@ s16 rtw_get_camid(_adapter *adapter, struct sta_info* sta, s16 kid);
 s16 rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid);
 s16 rtw_camid_alloc(_adapter *adapter, struct sta_info *sta, u8 kid);
 void rtw_camid_free(_adapter *adapter, u8 cam_id);
-
-extern void rtw_alloc_macid(_adapter *padapter, struct sta_info *psta);
-extern void rtw_release_macid(_adapter *padapter, struct sta_info *psta);
-extern u8 rtw_search_max_mac_id(_adapter *padapter);
+bool rtw_camid_is_gk(_adapter *padapter, u8 entry);
+bool read_phy_cam_is_gtk(_adapter *padapter, u8 entry);
+
+struct macid_bmp;
+struct macid_ctl_t;
+void dump_macid_map(void *sel, struct macid_bmp *map, u8 max_num);
+bool rtw_macid_is_set(struct macid_bmp *map, u8 id);
+bool rtw_macid_is_used(struct macid_ctl_t *macid_ctl, u8 id);
+bool rtw_macid_is_bmc(struct macid_ctl_t *macid_ctl, u8 id);
+s8 rtw_macid_get_if_g(struct macid_ctl_t *macid_ctl, u8 id);
+s8 rtw_macid_get_ch_g(struct macid_ctl_t *macid_ctl, u8 id);
+void rtw_alloc_macid(_adapter *padapter, struct sta_info *psta);
+void rtw_release_macid(_adapter *padapter, struct sta_info *psta);
+u8 rtw_search_max_mac_id(_adapter *padapter);
+void rtw_macid_ctl_init(struct macid_ctl_t *macid_ctl);
+void rtw_macid_ctl_deinit(struct macid_ctl_t *macid_ctl);
 
 void report_join_res(_adapter *padapter, int res);
 void report_survey_event(_adapter *padapter, union recv_frame *precv_frame);
@@ -741,6 +776,7 @@ void report_surveydone_event(_adapter *padapter);
 void report_del_sta_event(_adapter *padapter, unsigned char* MacAddr, unsigned short reason);
 void report_add_sta_event(_adapter *padapter, unsigned char* MacAddr, int cam_idx);
 bool rtw_port_switch_chk(_adapter *adapter);
+void report_wmm_edca_update(_adapter *padapter);
 
 void beacon_timing_control(_adapter *padapter);
 u8 chk_bmc_sleepq_cmd(_adapter* padapter);
@@ -770,7 +806,7 @@ void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status
 void issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da);
 s32 issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8* da, u8 ch, bool append_wps, int try_cnt, int wait_ms);
 int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
-s32 issue_nulldata_in_interrupt(PADAPTER padapter, u8 *da);
+s32 issue_nulldata_in_interrupt(PADAPTER padapter, u8 *da, unsigned int power_mode);
 int issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms);
 int issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason);
 int issue_deauth_ex(_adapter *padapter, u8 *da, unsigned short reason, int try_cnt, int wait_ms);
@@ -779,6 +815,8 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 #ifdef CONFIG_IEEE80211W
 void issue_action_SA_Query(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short tid);
 #endif //CONFIG_IEEE80211W
+int issue_action_SM_PS(_adapter *padapter ,  unsigned char *raddr , u8 NewMimoPsMode);
+int issue_action_SM_PS_wait_ack(_adapter *padapter, unsigned char *raddr, u8 NewMimoPsMode, int try_cnt, int wait_ms);
 unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr);
 unsigned int send_beacon(_adapter *padapter);
 
@@ -818,7 +856,7 @@ void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res);
 void mlmeext_sta_del_event_callback(_adapter *padapter);
 void mlmeext_sta_add_event_callback(_adapter *padapter, struct sta_info *psta);
 
-void linked_status_chk(_adapter *padapter);
+void linked_status_chk(_adapter *padapter, u8 from_timer);
 
 void _linked_info_dump(_adapter *padapter);
 
@@ -859,6 +897,7 @@ extern void correct_TSF(_adapter *padapter, struct mlme_ext_priv *pmlmeext);
 extern void adaptive_early_32k(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len);
 extern u8 traffic_status_watchdog(_adapter *padapter, u8 from_timer);
 
+
 #ifdef CONFIG_CONCURRENT_MODE
  sint check_buddy_mlmeinfo_state(_adapter *padapter, u32 state);
 void concurrent_chk_joinbss_done(_adapter *padapter, int join_res);
@@ -918,6 +957,7 @@ u8 set_chplan_hdl(_adapter *padapter, unsigned char *pbuf);
 u8 led_blink_hdl(_adapter *padapter, unsigned char *pbuf);
 u8 set_csa_hdl(_adapter *padapter, unsigned char *pbuf);	//Kurt: Handling DFS channel switch announcement ie.
 u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 run_in_thread_hdl(_adapter *padapter, u8 *pbuf);
 
 
 #define GEN_DRV_CMD_HANDLER(size, cmd)	{size, &cmd ## _hdl},
@@ -994,6 +1034,7 @@ struct cmd_hdl wlancmds[] =
 	GEN_MLME_EXT_HANDLER(sizeof(struct SetChannelSwitch_param), set_csa_hdl) /*61*/
 	GEN_MLME_EXT_HANDLER(sizeof(struct TDLSoption_param), tdls_hdl) /*62*/
 	GEN_MLME_EXT_HANDLER(0, chk_bmc_sleepq_hdl) /*63*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct RunInThread_param), run_in_thread_hdl) /*64*/
 };
 
 #endif
@@ -1054,6 +1095,7 @@ enum rtw_c2h_event
 	GEN_EVT_CODE(_C2HBCN),
 	GEN_EVT_CODE(_ReportPwrState),		//filen: only for PCIE, USB	
 	GEN_EVT_CODE(_CloseRF),				//filen: only for PCIE, work around ASPM
+	GEN_EVT_CODE(_WMM),					/*25*/
  	MAX_C2HEVT
 };
 
@@ -1088,6 +1130,8 @@ static struct fwevent wlanevents[] =
 	{0, NULL},
 	{0, &rtw_cpwm_event_callback},
 	{0, NULL},
+	{0, &rtw_wmm_event_callback},
+
 };
 
 #endif//_RTL8192C_CMD_C_
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mp.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mp.h
index b36c8889bb8f..e5f11415a411 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mp.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mp.h
@@ -53,6 +53,7 @@
 #define MPT_GET_THERMAL_METER		33
 #endif
 
+#define RTWPRIV_VER_INFO	1
 
 #define MAX_MP_XMITBUF_SZ 	2048
 #define NR_MP_XMITFRAME		8
@@ -347,6 +348,10 @@ enum {
 	CTA_TEST,
 	MP_DISABLE_BT_COEXIST,
 	MP_PwrCtlDM,
+	MP_GETVER,
+#ifdef CONFIG_WOWLAN
+	MP_WOW_ENABLE,
+#endif
 #ifdef CONFIG_AP_WOWLAN
 	MP_AP_WOW_ENABLE,
 #endif
@@ -379,7 +384,7 @@ struct mp_priv
 	u32 rx_pktcount_filter_out;
 	u32 rx_crcerrpktcount;
 	u32 rx_pktloss;
-
+	BOOLEAN  rx_bindicatePkt;
 	struct recv_stat rxstat;
 
 	//RF/BB relative
@@ -471,14 +476,6 @@ typedef struct _MP_FIRMWARE {
 	u8			szFwBuffer[0x8000];
 #endif
 	u32 		ulFwLength;
-
-#ifdef CONFIG_EMBEDDED_FWIMG
-	u8* 		szBTFwBuffer;
-	u8			myBTFwBuffer[0x8000];
-#else
-	u8			szBTFwBuffer[0x8000];
-#endif
-	u32 		ulBTFwLength;
 } RT_MP_FIRMWARE, *PRT_MP_FIRMWARE;
 
 
@@ -568,27 +565,63 @@ typedef enum _MPT_RATE_INDEX
 	MPT_RATE_MCS13,
 	MPT_RATE_MCS14,
 	MPT_RATE_MCS15,	/* 27 */
+	MPT_RATE_MCS16,
+	MPT_RATE_MCS17, // #29
+	MPT_RATE_MCS18,
+	MPT_RATE_MCS19,
+	MPT_RATE_MCS20,
+	MPT_RATE_MCS21,
+	MPT_RATE_MCS22, // #34
+	MPT_RATE_MCS23,
+	MPT_RATE_MCS24,
+	MPT_RATE_MCS25,
+	MPT_RATE_MCS26,
+	MPT_RATE_MCS27, // #39
+	MPT_RATE_MCS28, // #40
+	MPT_RATE_MCS29, // #41
+	MPT_RATE_MCS30, // #42
+	MPT_RATE_MCS31, // #43
 	/* VHT rate. Total: 20*/
-	MPT_RATE_VHT1SS_MCS0 = 100,// To reserve MCS16~MCS31, the index starts from #100.
-	MPT_RATE_VHT1SS_MCS1, // #101
+	MPT_RATE_VHT1SS_MCS0,//  #44
+	MPT_RATE_VHT1SS_MCS1, // #
 	MPT_RATE_VHT1SS_MCS2,
 	MPT_RATE_VHT1SS_MCS3,
 	MPT_RATE_VHT1SS_MCS4,
 	MPT_RATE_VHT1SS_MCS5,
-	MPT_RATE_VHT1SS_MCS6, // #106
+	MPT_RATE_VHT1SS_MCS6, // #
 	MPT_RATE_VHT1SS_MCS7,
 	MPT_RATE_VHT1SS_MCS8,
-	MPT_RATE_VHT1SS_MCS9,
-	MPT_RATE_VHT2SS_MCS0,
-	MPT_RATE_VHT2SS_MCS1, // #111
+	MPT_RATE_VHT1SS_MCS9, //#53
+	MPT_RATE_VHT2SS_MCS0, //#54
+	MPT_RATE_VHT2SS_MCS1, 
 	MPT_RATE_VHT2SS_MCS2,
 	MPT_RATE_VHT2SS_MCS3,
 	MPT_RATE_VHT2SS_MCS4,
 	MPT_RATE_VHT2SS_MCS5,
-	MPT_RATE_VHT2SS_MCS6, // #116
+	MPT_RATE_VHT2SS_MCS6,
 	MPT_RATE_VHT2SS_MCS7,
 	MPT_RATE_VHT2SS_MCS8,
-	MPT_RATE_VHT2SS_MCS9,
+	MPT_RATE_VHT2SS_MCS9, //#63
+	MPT_RATE_VHT3SS_MCS0,
+	MPT_RATE_VHT3SS_MCS1, 
+	MPT_RATE_VHT3SS_MCS2,
+	MPT_RATE_VHT3SS_MCS3,
+	MPT_RATE_VHT3SS_MCS4,
+	MPT_RATE_VHT3SS_MCS5,
+	MPT_RATE_VHT3SS_MCS6, // #126
+	MPT_RATE_VHT3SS_MCS7,
+	MPT_RATE_VHT3SS_MCS8,
+	MPT_RATE_VHT3SS_MCS9,
+	MPT_RATE_VHT4SS_MCS0,
+	MPT_RATE_VHT4SS_MCS1, // #131
+	MPT_RATE_VHT4SS_MCS2,
+	MPT_RATE_VHT4SS_MCS3,
+	MPT_RATE_VHT4SS_MCS4,
+	MPT_RATE_VHT4SS_MCS5,
+	MPT_RATE_VHT4SS_MCS6, // #136
+	MPT_RATE_VHT4SS_MCS7,
+	MPT_RATE_VHT4SS_MCS8,
+	MPT_RATE_VHT4SS_MCS9,
 	MPT_RATE_LAST
 }MPT_RATE_E, *PMPT_RATE_E;
 
@@ -684,6 +717,9 @@ typedef enum	_MPT_TXPWR_DEF{
 #elif defined(CONFIG_RTL8188E)
 	#define 	REG_RF_BB_GAIN_OFFSET	0x55
 	#define 	RF_GAIN_OFFSET_MASK 	0xfffff
+#else
+	#define 	REG_RF_BB_GAIN_OFFSET	0x55
+	#define 	RF_GAIN_OFFSET_MASK 	0xfffff
 #endif	//CONFIG_RTL8723A
 
 #endif //CONFIG_RF_GAIN_OFFSET
@@ -783,11 +819,12 @@ extern u8 Hal_ReadRFThermalMeter(PADAPTER pAdapter);
 extern void Hal_SetCCKContinuousTx(PADAPTER pAdapter, u8 bStart);
 extern void Hal_SetOFDMContinuousTx(PADAPTER pAdapter, u8 bStart);
 extern void Hal_ProSetCrystalCap (PADAPTER pAdapter , u32 CrystalCapVal);
-extern void _rtw_mp_xmit_priv(struct xmit_priv *pxmitpriv);
+//extern void _rtw_mp_xmit_priv(struct xmit_priv *pxmitpriv);
 extern void MP_PHY_SetRFPathSwitch(PADAPTER pAdapter ,BOOLEAN bMain);
 extern ULONG mpt_ProQueryCalTxPower(PADAPTER	pAdapter,u8 RfPath);
 extern void MPT_PwrCtlDM(PADAPTER padapter, u32 bstart);
 extern u8 MptToMgntRate(u32	MptRateIdx);
+extern u8 rtw_mpRateParseFunc(PADAPTER pAdapter, u8 *targetStr);
 
 #endif //_RTW_MP_H_
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mp_phy_regdef.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mp_phy_regdef.h
index 781bb8219948..340015cd3b2b 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mp_phy_regdef.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_mp_phy_regdef.h
@@ -1014,11 +1014,12 @@
 #define		bMaskByte1		0xff00
 #define		bMaskByte2		0xff0000
 #define		bMaskByte3		0xff000000
-#define		bMaskHWord		0xffff0000
+#define		bMaskHWord	0xffff0000
 #define		bMaskLWord		0x0000ffff
-#define		bMaskDWord		0xffffffff
-#define		bMaskH4Bits		0xf0000000	
-#define 	bMaskOFDM_D		0xffc00000
+#define		bMaskDWord	0xffffffff
+#define		bMaskH4Bits		0xf0000000
+#define		bMaskH3Bytes	0xffffff00
+#define 		bMaskOFDM_D	0xffc00000
 #define		bMaskCCK		0x3f3f3f3f
 #define		bMask12Bits		0xfff
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_odm.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_odm.h
index 50edd0124aee..a1d81ac4c923 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_odm.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_odm.h
@@ -21,7 +21,7 @@
 #define __RTW_ODM_H__
 
 #include <drv_types.h>
-
+#include "../hal/OUTSRC/phydm_types.h"
 /*
 * This file provides utilities/wrappers for rtw driver to use ODM
 */
@@ -34,9 +34,12 @@ void rtw_odm_dbg_level_set(_adapter *adapter, u32 level);
 void rtw_odm_ability_msg(void *sel, _adapter *adapter);
 void rtw_odm_ability_set(_adapter *adapter, u32 ability);
 
+bool rtw_odm_adaptivity_needed(_adapter *adapter);
 void rtw_odm_adaptivity_parm_msg(void *sel,_adapter *adapter);
 void rtw_odm_adaptivity_parm_set(_adapter *adapter, s8 TH_L2H_ini, s8 TH_EDCCA_HL_diff,
 	s8 IGI_Base, bool ForceEDCCA, u8 AdapEn_RSSI, u8 IGI_LowerBound);
 void rtw_odm_get_perpkt_rssi(void *sel, _adapter *adapter);
+void rtw_odm_acquirespinlock(_adapter *adapter,	RT_SPINLOCK_TYPE type);
+void rtw_odm_releasespinlock(_adapter *adapter,	RT_SPINLOCK_TYPE type);
 #endif // __RTW_ODM_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_pwrctrl.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_pwrctrl.h
index a843e30e9648..565a4849d15a 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_pwrctrl.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_pwrctrl.h
@@ -63,7 +63,8 @@ enum Power_Mgnt
 
 #ifdef CONFIG_PNO_SUPPORT
 #define MAX_PNO_LIST_COUNT 16
-#define MAX_SCAN_LIST_COUNT 14 //2.4G only
+#define MAX_SCAN_LIST_COUNT 14	//2.4G only
+#define MAX_HIDDEN_AP 8		//8 hidden AP
 #endif
 
 /*
@@ -205,13 +206,15 @@ typedef enum _PS_DENY_REASON
 typedef struct pno_nlo_info
 {
 	u32 fast_scan_period;				//Fast scan period
-	u32	ssid_num;				//number of entry
+	u8	ssid_num;				//number of entry
+	u8	hidden_ssid_num;
 	u32	slow_scan_period;			//slow scan period
 	u32	fast_scan_iterations;			//Fast scan iterations
 	u8	ssid_length[MAX_PNO_LIST_COUNT];	//SSID Length Array
 	u8	ssid_cipher_info[MAX_PNO_LIST_COUNT];	//Cipher information for security
 	u8	ssid_channel_info[MAX_PNO_LIST_COUNT];	//channel information
-}pno_nlo_info_t;	
+	u8	loc_probe_req[MAX_HIDDEN_AP];		//loc_probeReq
+}pno_nlo_info_t;
 
 typedef struct pno_ssid {
 	u32		SSID_len;
@@ -316,14 +319,17 @@ struct pwrctrl_priv
 	u8		wowlan_wake_reason;
 	u8		wowlan_ap_mode;
 	u8		wowlan_mode;
+	u8		wowlan_p2p_mode;
+	u8		wowlan_pno_enable;
 #ifdef CONFIG_WOWLAN
 	u8		wowlan_pattern;
 	u8		wowlan_magic;
 	u8		wowlan_unicast;
 	u8		wowlan_pattern_idx;
-	u8		wowlan_pno_enable;
+	u8		wowlan_from_cmd;
 #ifdef CONFIG_PNO_SUPPORT
 	u8		pno_in_resume;
+	u8		pno_inited;
 	pno_nlo_info_t	*pnlo_info;
 	pno_scan_info_t	*pscan_info;
 	pno_ssid_list_t	*pno_ssid_list;
@@ -402,8 +408,6 @@ extern void cpwm_int_hdl(PADAPTER padapter, struct reportpwrstate_parm *preportp
 extern void LPS_Leave_check(PADAPTER padapter);
 #endif
 
-extern void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode, const char *msg);
-extern void rtw_set_rpwm(_adapter * padapter, u8 val8);
 extern void LeaveAllPowerSaveMode(PADAPTER Adapter);
 extern void LeaveAllPowerSaveModeDirect(PADAPTER Adapter);
 #ifdef CONFIG_IPS
@@ -429,7 +433,10 @@ int rtw_fw_ps_state(PADAPTER padapter);
 s32 LPS_RF_ON_check(PADAPTER padapter, u32 delay_ms);
 void LPS_Enter(PADAPTER padapter, const char *msg);
 void LPS_Leave(PADAPTER padapter, const char *msg);
-void	traffic_check_for_leave_lps(PADAPTER padapter, u8 tx, u32 tx_packets);
+void traffic_check_for_leave_lps(PADAPTER padapter, u8 tx, u32 tx_packets);
+void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode, const char *msg);
+void rtw_set_fw_in_ips_mode(PADAPTER padapter, u8 enable);
+void rtw_set_rpwm(_adapter * padapter, u8 val8);
 #endif
 
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_recv.h
index 271a7870d73d..dab240e3efdc 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_recv.h
@@ -206,8 +206,8 @@ struct rx_raw_rssi
 	u8 mimo_singal_strength[4];// in 0~100 index
 	u8 mimo_singal_quality[4];
 	
-	s8 ofdm_pwr[4];
-	u8 ofdm_snr[4];
+	s8 ofdm_pwr[4];
+	u8 ofdm_snr[4];
 
 };
 #endif
@@ -278,7 +278,16 @@ struct rx_pkt_attrib	{
 
 #define RECVBUFF_ALIGN_SZ 8
 
+#if defined (CONFIG_RTL8192E)
+	#ifdef CONFIG_PCI_HCI
+		#define RXDESC_SIZE 16
+		#define RX_WIFI_INFO_SIZE	24
+	#else
+		#define RXDESC_SIZE	24
+	#endif
+#else
 #define RXDESC_SIZE	24
+#endif
 #define RXDESC_OFFSET RXDESC_SIZE
 
 struct recv_stat
@@ -287,10 +296,13 @@ struct recv_stat
 
 	unsigned int rxdw1;
 
+#if !(defined(CONFIG_RTL8192E) && defined(CONFIG_PCI_HCI)) //exclude 8192ee
 	unsigned int rxdw2;
 
 	unsigned int rxdw3;
+#endif
 
+#ifndef BUF_DESC_ARCH
 	unsigned int rxdw4;
 
 	unsigned int rxdw5;
@@ -300,6 +312,7 @@ struct recv_stat
 
 	unsigned int rxdw7;
 #endif
+#endif //if BUF_DESC_ARCH is defined, rx_buf_desc occupy 4 double words
 };
 
 #define EOR BIT(30)
@@ -371,7 +384,7 @@ struct recv_priv
 	//u8 *pallocated_urb_buf;
 	_sema allrxreturnevt;
 	uint	ff_hwaddr;
-	u8	rx_pending_cnt;
+	ATOMIC_T	rx_pending_cnt;
 
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 #ifdef PLATFORM_LINUX
@@ -397,9 +410,6 @@ struct recv_priv
 	struct ifqueue rx_indicate_queue;
 #endif	// CONFIG_RX_INDICATE_QUEUE
 
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-	_queue	recv_buf_pending_queue;
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_RX
 #endif //defined(PLATFORM_LINUX) || defined(PLATFORM_FREEBSD)
 
 	u8 *pallocated_recv_buf;
@@ -407,7 +417,7 @@ struct recv_priv
 	_queue	free_recv_buf_queue;
 	u32	free_recv_buf_queue_cnt;
 
-#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI) || defined(CONFIG_USB_HCI) 
 	_queue	recv_buf_pending_queue;
 #endif
 
@@ -429,7 +439,7 @@ struct recv_priv
 	struct rx_raw_rssi raw_rssi_info;
 	#endif
 	//s8 rxpwdb;	
-	u8 noise;	
+	s16 noise;	
 	//int RxSNRdB[2];
 	//s8 RxRssi[2];
 	//int FalseAlmCnt_all;
@@ -445,7 +455,7 @@ struct recv_priv
 	struct smooth_rssi_data signal_qual_data;
 	struct smooth_rssi_data signal_strength_data;
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
-
+	u16 sink_udpport,pre_rtp_rxseq,cur_rtp_rxseq;
 };
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
@@ -825,9 +835,14 @@ __inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
 {
 	s32	SignalPower; // in dBm.
 
+#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+	// Translate to dBm (x=y-100)
+	SignalPower = SignalStrengthIndex - 100;
+#else
 	// Translate to dBm (x=0.5y-95).
 	SignalPower = (s32)((SignalStrengthIndex + 1) >> 1); 
 	SignalPower -= 95; 
+#endif
 
 	return SignalPower;
 }
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_security.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_security.h
index 12da861d6a93..00b08fd75e46 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_security.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_security.h
@@ -209,7 +209,7 @@ struct security_priv
 	//u8				szCapability[256];				// For WPA2-PSK using zero-config, by Annie, 2005-09-20.
 
 	u8 bWepDefaultKeyIdxSet;
-	
+
 #define DBG_SW_SEC_CNT
 #ifdef DBG_SW_SEC_CNT
 	u64 wep_sw_enc_cnt_bc;
@@ -232,7 +232,7 @@ struct security_priv
 	u64 aes_sw_dec_cnt_bc;
 	u64 aes_sw_dec_cnt_mc;
 	u64 aes_sw_dec_cnt_uc;
-#endif /* DBG_SW_SEC_CNT */	
+#endif /* DBG_SW_SEC_CNT */
 };
 
 struct sha256_state {
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_version.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_version.h
index f47a43d73468..a8c2f5aecbba 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_version.h
@@ -1 +1 @@
-#define DRIVERVERSION	"v4.3.0.4_11916.20140724_COB"
+#define DRIVERVERSION	"v4.3.10_12447.20141008"
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_wifi_regd.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_wifi_regd.h
index 8b28be34b0ae..aea6365290f8 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_wifi_regd.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_wifi_regd.h
@@ -19,10 +19,8 @@ enum country_code_type_t {
 	COUNTRY_CODE_MAX
 }; 
 
-int rtw_regd_init(_adapter *padapter,
-	void (*reg_notifier)(struct wiphy *wiphy,
-		struct regulatory_request *request));
-void rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
+int rtw_regd_init(_adapter *padapter);
+void rtw_reg_notify_by_driver(_adapter *adapter);
 
+#endif /* __RTW_WIFI_REGD_H__ */
 
-#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_xmit.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_xmit.h
index 03df9dc4dcbc..07bc84893da6 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_xmit.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/rtw_xmit.h
@@ -77,9 +77,14 @@
 
 // xmit extension buff defination
 #define MAX_XMIT_EXTBUF_SZ	(1536)
+
+#ifdef CONFIG_SINGLE_XMIT_BUF
+#define NR_XMIT_EXTBUFF	(1)
+#else
 #define NR_XMIT_EXTBUFF	(32)
+#endif
 
-#define MAX_CMDBUF_SZ	(4096)
+#define MAX_CMDBUF_SZ	(5120)	//(4096)
 
 #define MAX_NUMBLKS		(1)
 
@@ -144,8 +149,24 @@ do{\
 
 #define HWXMIT_ENTRY	4
 
-#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)|| defined(CONFIG_RTL8192E) || defined(CONFIG_RTL8723B)
+// For Buffer Descriptor ring architecture
+#ifdef BUF_DESC_ARCH	
+#if defined (CONFIG_RTL8192E)
+#define TX_BUFFER_SEG_NUM 	1 // 0:2 seg, 1: 4 seg, 2: 8 seg.  	
+#endif
+#endif
+
+#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)|| defined(CONFIG_RTL8723B)
 #define TXDESC_SIZE 40
+//8192EE_TODO
+#elif defined (CONFIG_RTL8192E) // this section is defined for buffer descriptor ring architecture
+	#ifdef CONFIG_PCI_HCI
+		#define TXDESC_SIZE ((TX_BUFFER_SEG_NUM ==0)?16: ((TX_BUFFER_SEG_NUM ==1)? 32:64) )
+		#define TX_WIFI_INFO_SIZE 40  
+	#else  //8192E USB or SDIO
+		#define TXDESC_SIZE 40
+	#endif
+//8192EE_TODO
 #else
 #define TXDESC_SIZE 32
 #endif
@@ -169,9 +190,13 @@ do{\
 #endif
 
 #ifdef CONFIG_PCI_HCI
+#if defined(CONFIG_RTL8192E) // this section is defined for buffer descriptor ring architecture
+#define TXDESC_OFFSET TX_WIFI_INFO_SIZE
+#else
 #define TXDESC_OFFSET 0
+#endif 
 #define TX_DESC_NEXT_DESC_OFFSET	(TXDESC_SIZE + 8)
-#endif
+#endif //CONFIG_PCI_HCI
 
 enum TXDESC_SC{
 	SC_DONT_CARE = 0x00,
@@ -186,6 +211,20 @@ enum TXDESC_SC{
 #define TXDESC_40_BYTES
 #endif
 
+#if defined(CONFIG_RTL8192E) && defined(CONFIG_PCI_HCI) //8192ee
+//8192EE_TODO
+struct tx_desc
+{
+	unsigned int txdw0;
+	unsigned int txdw1;
+	unsigned int txdw2;
+	unsigned int txdw3;
+	unsigned int txdw4;
+	unsigned int txdw5;
+	unsigned int txdw6;
+	unsigned int txdw7;
+};
+#else
 struct tx_desc
 {
 	unsigned int txdw0;
@@ -216,7 +255,7 @@ struct tx_desc
 	unsigned int txdw15;
 #endif
 };
-
+#endif
 
 union txdesc {
 	struct tx_desc txdesc;
@@ -227,12 +266,13 @@ union txdesc {
 #define PCI_MAX_TX_QUEUE_COUNT	8
 
 struct rtw_tx_ring {
+	unsigned char	qid;
 	struct tx_desc	*desc;
-	dma_addr_t		dma;
-	unsigned int		idx;
-	unsigned int		entries;
-	_queue			queue;
-	u32				qlen;
+	dma_addr_t	dma;
+	unsigned int	idx;
+	unsigned int	entries;
+	_queue		queue;
+	u32		qlen;
 };
 #endif
 
@@ -305,6 +345,7 @@ struct pkt_attrib
 	u8	dhcp_pkt;
 	u16	ether_type;
 	u16	seqnum;
+	u8 	hw_ssn_sel;	//for HW_SEQ0,1,2,3
 	u16	pkt_hdrlen;	//the original 802.3 pkt header len
 	u16	hdrlen;		//the WLAN Header Len
 	u32	pktlen;		//the original 802.3 pkt raw_data len (not include ether_hdr data)
@@ -331,6 +372,7 @@ struct pkt_attrib
 	u8	ch_offset;//PRIME_CHNL_OFFSET
 	u8	sgi;//short GI
 	u8	ampdu_en;//tx ampdu enable
+	u8	ampdu_spacing; //ampdu_min_spacing for peer sta's rx
 	u8	mdata;//more data bit
 	u8	pctrl;//per packet txdesc control enable
 	u8	triggered;//for ap mode handling Power Saving sta
@@ -491,6 +533,10 @@ struct xmit_buf
 #endif
 #endif
 
+#ifdef CONFIG_PCI_HCI
+	struct tx_desc *desc;
+#endif
+
 #if defined(DBG_XMIT_BUF )|| defined(DBG_XMIT_BUF_EXT)
 	u8 no;
 #endif
@@ -587,6 +633,14 @@ struct agg_pkt_info{
 	u16 pkt_len;
 };
 
+enum cmdbuf_type {
+	CMDBUF_BEACON = 0x00,
+	CMDBUF_RSVD,
+	CMDBUF_MAX
+};
+
+u8 rtw_get_hwseq_no(_adapter *padapter);
+
 struct	xmit_priv	{
 
 	_lock	lock;
@@ -674,7 +728,7 @@ struct	xmit_priv	{
 #endif
 #endif
 
-#ifdef CONFIG_SDIO_HCI
+#if defined (CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 #ifdef CONFIG_SDIO_TX_TASKLET
 	#ifdef PLATFORM_LINUX
 	struct tasklet_struct xmit_tasklet;
@@ -697,8 +751,8 @@ struct	xmit_priv	{
 	u8 *pxmit_extbuf;
 	uint free_xmit_extbuf_cnt;
 
-	struct xmit_buf	pcmd_xmitbuf;
-
+	struct xmit_buf	pcmd_xmitbuf[CMDBUF_MAX];
+	u8   hw_ssn_seq_no;//mapping to REG_HW_SEQ 0,1,2,3
 	u16	nqos_ssn;
 	#ifdef CONFIG_TX_EARLY_MODE
 
@@ -720,9 +774,10 @@ struct	xmit_priv	{
 	_lock lock_sctx;
 };
 
-extern struct xmit_frame *rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv);
-extern struct xmit_buf *rtw_alloc_cmd_xmitbuf(struct xmit_priv *pxmitpriv);
-extern s32	rtw_free_cmd_xmitbuf(struct xmit_priv *pxmitpriv);
+extern struct xmit_frame *__rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv,
+		enum cmdbuf_type buf_type);
+#define rtw_alloc_cmdxmitframe(p) __rtw_alloc_cmdxmitframe(p, CMDBUF_RSVD)
+#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe(p, CMDBUF_BEACON)
 
 extern struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv);
 extern s32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
@@ -776,7 +831,7 @@ void rtw_free_hwxmits(_adapter *padapter);
 
 
 s32 rtw_xmit(_adapter *padapter, _pkt **pkt);
-
+bool xmitframe_hiq_filter(struct xmit_frame *xmitframe);
 #if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
 sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe);
 void stop_sta_xmit(_adapter *padapter, struct sta_info *psta);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/sdio_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/sdio_hal.h
index a3a0b2f865bc..a918a768d666 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/sdio_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/sdio_hal.h
@@ -44,5 +44,9 @@ void rtl8723bs_set_hal_ops(PADAPTER padapter);
 void rtl8821as_set_hal_ops(PADAPTER padapter);
 #endif
 
+#ifdef CONFIG_RTL8192E
+void rtl8192es_set_hal_ops(PADAPTER padapter);
+#endif
+
 #endif //__SDIO_HAL_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/sdio_ops.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/sdio_ops.h
index e142871e0bb8..0dcd86f28e17 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/sdio_ops.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/sdio_ops.h
@@ -104,5 +104,18 @@ extern void ClearInterrupt8723BSdio(PADAPTER padapter);
 #endif //CONFIG_WOWLAN
 #endif
 
+
+#ifdef CONFIG_RTL8192E
+extern void InitInterrupt8192ESdio(PADAPTER padapter);
+extern void EnableInterrupt8192ESdio(PADAPTER padapter);
+extern void DisableInterrupt8192ESdio(PADAPTER padapter);
+extern void UpdateInterruptMask8192ESdio(PADAPTER padapter, u32 AddMSR, u32 RemoveMSR);
+extern u8 HalQueryTxBufferStatus8192ESdio(PADAPTER padapter);
+extern u8 HalQueryTxOQTBufferStatus8192ESdio(PADAPTER padapter);
+extern void ClearInterrupt8192ESdio(PADAPTER padapter);
+#endif // CONFIG_RTL8192E
+
+
+
 #endif // !__SDIO_OPS_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/usb_ops_linux.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/usb_ops_linux.h
index a048e83bda3d..83c1c74c2ce2 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/usb_ops_linux.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/usb_ops_linux.h
@@ -65,5 +65,20 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
 void usb_write_port_cancel(struct intf_hdl *pintfhdl);
 
 int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype);
+#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
+int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request,
+	u16 value, u16 index, void *pdata, u16 len, u8 requesttype);
+#endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
+
+u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr);
+u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr);
+u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr);
+int usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+int usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+int usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+int usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);
+u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+void usb_recv_tasklet(void *priv);
+
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/wifi.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/wifi.h
index d73aa1b5a548..dff95b413506 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/wifi.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/wifi.h
@@ -48,6 +48,7 @@
 #define WLAN_MIN_ETHFRM_LEN	60
 #define WLAN_MAX_ETHFRM_LEN	1514
 #define WLAN_ETHHDR_LEN		14
+#define WLAN_WMM_LEN		24
 
 #define P80211CAPTURE_VERSION	0x80211001
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/xmit_osdep.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/xmit_osdep.h
index 79d0a8864bfe..d489ebfcf642 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/xmit_osdep.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/include/xmit_osdep.h
@@ -92,5 +92,9 @@ extern sint rtw_endofpktfile (struct pkt_file *pfile);
 extern void rtw_os_pkt_complete(_adapter *padapter, _pkt *pkt);
 extern void rtw_os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe);
 
+void rtw_os_wake_queue_at_free_stainfo(_adapter *padapter, int *qcnt_freed);
+
+void dump_os_queue(void *sel, _adapter *padapter);
+
 #endif //__XMIT_OSDEP_H_
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/custom_gpio_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/custom_gpio_linux.c
index 46ae1d140c68..45606cdde5d7 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/custom_gpio_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/custom_gpio_linux.c
@@ -277,7 +277,42 @@ void rtw_wifi_gpio_wlan_ctrl(int onoff)
 }
 #endif //ANDROID_2X
 
-#else // !CONFIG_PLATFORM_SPRD
+#elif defined(CONFIG_PLATFORM_ARM_RK3066) 
+#include <mach/iomux.h>
+
+#define GPIO_WIFI_IRQ		RK30_PIN2_PC2
+extern unsigned int oob_irq;
+int rtw_wifi_gpio_init(void)
+{
+#ifdef CONFIG_GSPI_HCI
+	if (GPIO_WIFI_IRQ > 0) {
+		rk30_mux_api_set(GPIO2C2_LCDC1DATA18_SMCBLSN1_HSADCDATA5_NAME, GPIO2C_GPIO2C2);//jacky_test
+		gpio_request(GPIO_WIFI_IRQ, "oob_irq");
+		gpio_direction_input(GPIO_WIFI_IRQ);
+
+		oob_irq = gpio_to_irq(GPIO_WIFI_IRQ);
+
+		DBG_8192C("%s oob_irq:%d\n", __func__, oob_irq);
+	}
+#endif
+	return 0;
+}
+
+
+int rtw_wifi_gpio_deinit(void)
+{
+#ifdef CONFIG_GSPI_HCI
+	if (GPIO_WIFI_IRQ > 0)
+		gpio_free(GPIO_WIFI_IRQ);
+#endif
+	return 0;
+}
+
+void rtw_wifi_gpio_wlan_ctrl(int onoff)
+{
+}
+
+#else
 
 int rtw_wifi_gpio_init(void)
 {
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_cfg80211.c
index 6a27ec25d4f3..ad259219b696 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_cfg80211.c
@@ -28,7 +28,7 @@
 #define RTW_MAX_MGMT_TX_CNT (8)
 
 #define RTW_SCAN_IE_LEN_MAX      2304
-#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 3000 //ms
+#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 5000 //ms
 #define RTW_MAX_NUM_PMKIDS 4
 
 #define RTW_CH_MAX_2G_CHANNEL               14      /* Max channel in 2G band */
@@ -53,7 +53,11 @@
 
 #endif
 
+#ifdef CONFIG_PLATFORM_ARM_SUN8I
 #define BUSY_TRAFFIC_SCAN_DENY_PERIOD	8000
+#else
+#define BUSY_TRAFFIC_SCAN_DENY_PERIOD	12000
+#endif
 
 static const u32 rtw_cipher_suites[] = {
 	WLAN_CIPHER_SUITE_WEP40,
@@ -379,7 +383,10 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	u8 *notify_ie;
 	size_t notify_ielen;
 	s32 notify_signal;
-	u8 buf[MAX_BSSINFO_LEN], *pbuf;
+	//u8 buf[MAX_BSSINFO_LEN];
+
+	u8 *pbuf;
+	size_t buf_size = MAX_BSSINFO_LEN;
 	size_t len,bssinf_len=0;
 	struct rtw_ieee80211_hdr *pwlanhdr;
 	unsigned short *fctrl;
@@ -389,12 +396,17 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	struct wiphy *wiphy = wdev->wiphy;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-
+	pbuf = rtw_zmalloc(buf_size);
+	if(pbuf == NULL){
+		DBG_871X("%s pbuf allocate failed  !! \n",__FUNCTION__);
+		return bss;
+	}
+		
 	//DBG_8192C("%s\n", __func__);
 
 	bssinf_len = pnetwork->network.IELength+sizeof (struct rtw_ieee80211_hdr_3addr);
-	if(bssinf_len > MAX_BSSINFO_LEN){
-		DBG_871X("%s IE Length too long > %d byte \n",__FUNCTION__,MAX_BSSINFO_LEN);
+	if(bssinf_len > buf_size){
+		DBG_871X("%s IE Length too long > %zu byte \n",__FUNCTION__,buf_size);
 		goto exit;
 	}
 
@@ -493,21 +505,17 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+	
+	notify_channel = ieee80211_get_channel(wiphy, freq);
 
 	if (0)
 		notify_timestamp = le64_to_cpu(*(u64*)rtw_get_timestampe_from_ie(pnetwork->network.IEs));
 	else
 		notify_timestamp = rtw_get_systime_us();
 
-	notify_channel = ieee80211_get_channel(wiphy, freq);
-
-	//rtw_get_timestampe_from_ie()
-	notify_timestamp = jiffies_to_msecs(jiffies)*1000; /* uSec */
-
 	notify_interval = le16_to_cpu(*(u16*)rtw_get_beacon_interval_from_ie(pnetwork->network.IEs));
 	notify_capability = le16_to_cpu(*(u16*)rtw_get_capability_from_ie(pnetwork->network.IEs));		
 
-	
 	notify_ie = pnetwork->network.IEs+_FIXED_IE_LENGTH_;
 	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
 
@@ -528,7 +536,7 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	DBG_8192C("notify_timestamp: %llu\n", notify_timestamp);
 	#endif
 
-	pbuf = buf;
+	//pbuf = buf;
 	
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pbuf;	
 	fctrl = &(pwlanhdr->frame_ctl);
@@ -549,13 +557,12 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	_rtw_memcpy(pwlanhdr->addr3, pnetwork->network.MacAddress, ETH_ALEN);
 
 
-	pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);	
+	//pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);
 	len = sizeof (struct rtw_ieee80211_hdr_3addr);
-
-	_rtw_memcpy(pbuf, pnetwork->network.IEs, pnetwork->network.IELength);
-	len += pnetwork->network.IELength;
-
-	*((u64*)pbuf) = cpu_to_le64(notify_timestamp);
+	_rtw_memcpy((pbuf+len), pnetwork->network.IEs, pnetwork->network.IELength);
+	*((u64*)(pbuf+len)) = cpu_to_le64(notify_timestamp);
+	
+	len += pnetwork->network.IELength;	
 
 	//#ifdef CONFIG_P2P
 	//if(rtw_get_p2p_ie(pnetwork->network.IEs+12, pnetwork->network.IELength-12, NULL, NULL))
@@ -563,9 +570,9 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 	//	DBG_8192C("%s, got p2p_ie\n", __func__);
 	//}
 	//#endif
-	
+
 #if 1	
-	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,
+	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)pbuf,
 		len, notify_signal, GFP_ATOMIC);
 #else			 
 			
@@ -615,8 +622,10 @@ struct cfg80211_bss *rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_net
 #else
 	cfg80211_put_bss(bss);
 #endif
-
-exit:	
+	
+exit:
+	if(pbuf)
+		rtw_mfree(pbuf, buf_size);	
 	return bss;
 	
 }
@@ -663,6 +672,11 @@ void rtw_cfg80211_ibss_indicate_connect(_adapter *padapter)
 	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
 	struct wireless_dev *pwdev = padapter->rtw_wdev;
 	struct cfg80211_bss *bss = NULL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+	struct wiphy *wiphy = pwdev->wiphy;
+	int freq = (int)cur_network->network.Configuration.DSConfig;
+	struct ieee80211_channel *chan;
+#endif
 
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 	if (pwdev->iftype != NL80211_IFTYPE_ADHOC) 
@@ -714,7 +728,12 @@ void rtw_cfg80211_ibss_indicate_connect(_adapter *padapter)
 			DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" BSS not found !!\n", FUNC_ADPT_ARG(padapter));
 	}
 	//notify cfg80211 that device joined an IBSS
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+	chan = ieee80211_get_channel(wiphy, freq);
+	cfg80211_ibss_joined(padapter->pnetdev, cur_network->network.MacAddress, chan, GFP_ATOMIC);
+#else
 	cfg80211_ibss_joined(padapter->pnetdev, cur_network->network.MacAddress, GFP_ATOMIC);
+#endif
 }
 
 void rtw_cfg80211_indicate_connect(_adapter *padapter)
@@ -813,14 +832,18 @@ void rtw_cfg80211_indicate_connect(_adapter *padapter)
 	}
 	else
 	{
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0) || defined(COMPAT_KERNEL_RELEASE)	
 		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
+	#endif
 		cfg80211_connect_result(padapter->pnetdev, cur_network->network.MacAddress
 			, pmlmepriv->assoc_req+sizeof(struct rtw_ieee80211_hdr_3addr)+2
 			, pmlmepriv->assoc_req_len-sizeof(struct rtw_ieee80211_hdr_3addr)-2
 			, pmlmepriv->assoc_rsp+sizeof(struct rtw_ieee80211_hdr_3addr)+6
 			, pmlmepriv->assoc_rsp_len-sizeof(struct rtw_ieee80211_hdr_3addr)-6
 			, WLAN_STATUS_SUCCESS, GFP_ATOMIC);
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0) || defined(COMPAT_KERNEL_RELEASE)	
 		DBG_8192C("pwdev->sme_state(a)=%d\n", pwdev->sme_state);
+	#endif
 	}
 }
 
@@ -859,6 +882,7 @@ void rtw_cfg80211_indicate_disconnect(_adapter *padapter)
 #endif //CONFIG_P2P
 
 	if (!padapter->mlmepriv.not_indic_disco) {
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0) || defined(COMPAT_KERNEL_RELEASE)			
 		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
 
 		if(pwdev->sme_state==CFG80211_SME_CONNECTING)
@@ -870,6 +894,14 @@ void rtw_cfg80211_indicate_disconnect(_adapter *padapter)
 			//DBG_8192C("pwdev->sme_state=%d\n", pwdev->sme_state);
 
 		DBG_8192C("pwdev->sme_state(a)=%d\n", pwdev->sme_state);
+		#else
+
+		if(check_fwstate(&padapter->mlmepriv, _FW_LINKED))		
+			cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0, GFP_ATOMIC);
+		else
+			cfg80211_connect_result(padapter->pnetdev, NULL, NULL, 0, NULL, 0, 
+				WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC/*GFP_KERNEL*/);
+		#endif
 	}
 }
  	
@@ -1315,7 +1347,6 @@ _func_enter_;
 						DBG_871X(" ~~~~set sta key:groupkey\n");
 	
 						padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
-
 						rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1, _TRUE);
 					}
 #ifdef CONFIG_IEEE80211W
@@ -1540,13 +1571,13 @@ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 	
 	if (params->seq_len && params->seq) 
 	{	
-		_rtw_memcpy(param->u.crypt.seq, params->seq, params->seq_len);
+		_rtw_memcpy(param->u.crypt.seq, (u8 *)params->seq, params->seq_len);
 	}
 
 	if(params->key_len && params->key)
 	{
 		param->u.crypt.key_len = params->key_len;		
-		_rtw_memcpy(param->u.crypt.key, params->key, params->key_len);
+		_rtw_memcpy(param->u.crypt.key, (u8 *)params->key, params->key_len);
 	}	
 
 	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
@@ -1562,6 +1593,12 @@ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 		ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
 #endif
 	}
+        else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE
+                || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)
+        {
+                //DBG_8192C("@@@@@@@@@@ fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
+                ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);
+        }
 	else
 	{
 		DBG_8192C("error! fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
@@ -1674,8 +1711,13 @@ static int cfg80211_rtw_set_default_key(struct wiphy *wiphy,
 }
 
 static int cfg80211_rtw_get_station(struct wiphy *wiphy,
-				    struct net_device *ndev,
-				    u8 *mac, struct station_info *sinfo)
+				struct net_device *ndev,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0))
+				u8 *mac, 
+#else
+				const u8 *mac,
+#endif
+				struct station_info *sinfo)
 {
 	int ret = 0;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
@@ -1691,7 +1733,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 		goto exit;
 	}
 
-	psta = rtw_get_stainfo(pstapriv, mac);
+	psta = rtw_get_stainfo(pstapriv, (u8 *)mac);
 	if (psta == NULL) {
 		DBG_8192C("%s, sta_info is null\n", __func__);
 		ret = -ENOENT;
@@ -1709,7 +1751,7 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 	{
 		struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
 
-		if (_rtw_memcmp(mac, cur_network->network.MacAddress, ETH_ALEN) == _FALSE) {
+		if (_rtw_memcmp((u8 *)mac, cur_network->network.MacAddress, ETH_ALEN) == _FALSE) {
 			DBG_871X("%s, mismatch bssid="MAC_FMT"\n", __func__, MAC_ARG(cur_network->network.MacAddress));
 			ret = -ENOENT;
 			goto exit;
@@ -1924,12 +1966,12 @@ void rtw_cfg80211_unlink_bss(_adapter *padapter, struct wlan_network *pnetwork)
 	struct wiphy *wiphy = pwdev->wiphy;
 	struct cfg80211_bss *bss = NULL;
 	WLAN_BSSID_EX select_network = pnetwork->network;
-
+	
 	bss = cfg80211_get_bss(wiphy, NULL/*notify_channel*/,
 		select_network.MacAddress, select_network.Ssid.Ssid,
 		select_network.Ssid.SsidLength, 0/*WLAN_CAPABILITY_ESS*/, 
 		0/*WLAN_CAPABILITY_ESS*/);
-
+	
 	if (bss) {
 		cfg80211_unlink_bss(wiphy, bss);
 		DBG_8192C("%s(): cfg80211_unlink %s!! () ",__func__,select_network.Ssid.Ssid );
@@ -1982,7 +2024,16 @@ void rtw_cfg80211_surveydone_event_callback(_adapter *padapter)
 			//ev=translate_scan(padapter, a, pnetwork, ev, stop);
 			rtw_cfg80211_inform_bss(padapter, pnetwork);		
 		}
-
+		/* //check ralink testbed RSN IE length
+		{
+			if(_rtw_memcmp(pnetwork->network.Ssid.Ssid, "Ralink_11n_AP",13))
+			{
+				uint ie_len=0;
+				u8 *p=NULL;
+				p = rtw_get_ie(pnetwork->network.IEs + _BEACON_IE_OFFSET_, _RSN_IE_2_, &ie_len, (pnetwork->network.IELength - _BEACON_IE_OFFSET_));
+				DBG_871X("ie_len=%d\n", ie_len);
+			}
+		}*/
 		plist = get_next(plist);
 	
 	}
@@ -2341,18 +2392,15 @@ if (padapter->registrypriv.mp_mode == 1)
 #endif /* CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_P2P
-	if( pwdinfo->driver_interface == DRIVER_CFG80211 )
+	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 	{
-		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
-		{
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-			rtw_free_network_queue(padapter, _TRUE);
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
+		rtw_free_network_queue(padapter, _TRUE);
 
-			if(social_channel == 0)
-				rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
-			else
-				rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
-		}
+		if(social_channel == 0)
+			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
+		else
+			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
 	}
 #endif //CONFIG_P2P
 
@@ -2888,7 +2936,7 @@ static int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,
 	
 	_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));			
 	ndis_ssid.SsidLength = params->ssid_len;
-	_rtw_memcpy(ndis_ssid.Ssid, params->ssid, params->ssid_len);
+	_rtw_memcpy(ndis_ssid.Ssid, (u8 *)params->ssid, params->ssid_len);
 
 	//DBG_8192C("ssid=%s, len=%zu\n", ndis_ssid.Ssid, params->ssid_len);
 	
@@ -3033,7 +3081,7 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 	
 	_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));			
 	ndis_ssid.SsidLength = sme->ssid_len;
-	_rtw_memcpy(ndis_ssid.Ssid, sme->ssid, sme->ssid_len);
+	_rtw_memcpy(ndis_ssid.Ssid, (u8 *)sme->ssid, sme->ssid_len);
 
 	DBG_8192C("ssid=%s, len=%zu\n", ndis_ssid.Ssid, sme->ssid_len);
 	
@@ -3087,7 +3135,7 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 
 	DBG_8192C("%s, ie_len=%zu\n", __func__, sme->ie_len);
 			
-	ret = rtw_cfg80211_set_wpa_ie(padapter, sme->ie, sme->ie_len);
+	ret = rtw_cfg80211_set_wpa_ie(padapter, (u8 *)sme->ie, sme->ie_len);
 	if (ret < 0)
 		goto exit;
 
@@ -3183,7 +3231,7 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 
 	//rtw_set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
 
-	if (rtw_set_802_11_connect(padapter, sme->bssid, &ndis_ssid) == _FALSE) {
+	if (rtw_set_802_11_connect(padapter, (u8 *)sme->bssid, &ndis_ssid) == _FALSE) {
 		ret = -1;
 		goto exit;
 	}
@@ -3228,7 +3276,7 @@ static int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,
 		rtw_indicate_disconnect(padapter);
 		
 		rtw_free_assoc_resources(padapter, 1);
-
+		
 		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 		// remove the network entry in scanned_queue
 		do {
@@ -3244,14 +3292,13 @@ static int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,
 		}while(pwlan != NULL);
 
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-
-		rtw_pwr_wakeup(padapter);
+		
+		rtw_pwr_wakeup(padapter);		
 	}
 
 	padapter->mlmepriv.not_indic_disco = _FALSE;
 
 	DBG_871X(FUNC_NDEV_FMT" return 0\n", FUNC_NDEV_ARG(ndev));
-
 	return 0;
 }
 
@@ -3340,26 +3387,33 @@ static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
 {
 	u8	index,blInserted = _FALSE;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_priv *mlme = &padapter->mlmepriv;
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	u8	strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
 
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	DBG_871X(FUNC_NDEV_FMT" "MAC_FMT" "KEY_FMT"\n", FUNC_NDEV_ARG(ndev)
+		, MAC_ARG(pmksa->bssid), KEY_ARG(pmksa->pmkid));
 
-	if ( _rtw_memcmp( pmksa->bssid, strZeroMacAddress, ETH_ALEN ) == _TRUE )
+	if ( _rtw_memcmp((u8 *)pmksa->bssid, strZeroMacAddress, ETH_ALEN ) == _TRUE )
 	{
 		return -EINVAL;
 	}
 
+	if (check_fwstate(mlme, _FW_LINKED) == _FALSE) {
+		DBG_871X(FUNC_NDEV_FMT" not set pmksa cause not in linked state\n", FUNC_NDEV_ARG(ndev));
+		return -EINVAL;
+	}
+
 	blInserted = _FALSE;
 	
 	//overwrite PMKID
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
-		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==_TRUE )
+		if( _rtw_memcmp(psecuritypriv->PMKIDList[index].Bssid, (u8 *)pmksa->bssid, ETH_ALEN) ==_TRUE )
 		{ // BSSID is matched, the same AP => rewrite with new PMKID.
 			DBG_871X(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(ndev));
 
-			_rtw_memcpy( psecuritypriv->PMKIDList[index].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
+			_rtw_memcpy( psecuritypriv->PMKIDList[index].PMKID, (u8 *)pmksa->pmkid, WLAN_PMKID_LEN);
 			psecuritypriv->PMKIDList[index].bUsed = _TRUE;
 			psecuritypriv->PMKIDIndex = index+1;
 			blInserted = _TRUE;
@@ -3373,8 +3427,8 @@ static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
 		DBG_871X(FUNC_NDEV_FMT" Use the new entry index = %d for this PMKID.\n",
 			FUNC_NDEV_ARG(ndev), psecuritypriv->PMKIDIndex );
 
-		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, pmksa->bssid, ETH_ALEN);
-		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
+		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, (u8 *)pmksa->bssid, ETH_ALEN);
+		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, (u8 *)pmksa->pmkid, WLAN_PMKID_LEN);
 
 		psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = _TRUE;
 		psecuritypriv->PMKIDIndex++ ;
@@ -3395,16 +3449,18 @@ static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	DBG_871X(FUNC_NDEV_FMT" "MAC_FMT" "KEY_FMT"\n", FUNC_NDEV_ARG(ndev)
+		, MAC_ARG(pmksa->bssid), KEY_ARG(pmksa->pmkid));
 
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
-		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==_TRUE )
+		if( _rtw_memcmp(psecuritypriv->PMKIDList[index].Bssid, (u8 *)pmksa->bssid, ETH_ALEN) ==_TRUE )
 		{ // BSSID is matched, the same AP => Remove this PMKID information and reset it. 
-			_rtw_memset( psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN );
-			_rtw_memset( psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN );
+			_rtw_memset(psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN );
+			_rtw_memset(psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN );
 			psecuritypriv->PMKIDList[index].bUsed = _FALSE;
 			bMatched = _TRUE;
+			DBG_871X(FUNC_NDEV_FMT" clear id:%hhu\n", FUNC_NDEV_ARG(ndev), index);		
 			break;
 		}	
 	}
@@ -4089,7 +4145,7 @@ static int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,
 		WLAN_BSSID_EX *pbss_network_ext = &adapter->mlmeextpriv.mlmext_info.network;
 
 		if(0)
-		DBG_871X(FUNC_ADPT_FMT" ssid:(%s,%d), from ie:(%s,%d)\n", FUNC_ADPT_ARG(adapter),
+		DBG_871X(FUNC_ADPT_FMT" ssid:(%s,%zu), from ie:(%s,%d)\n", FUNC_ADPT_ARG(adapter),
 			settings->ssid, settings->ssid_len,
 			pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength);
 
@@ -4129,7 +4185,12 @@ static int cfg80211_rtw_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
 #endif //(LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))
 
 static int	cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev,
-			       u8 *mac, struct station_parameters *params)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0))
+				u8 *mac, 
+#else
+				const u8 *mac,
+#endif
+			       struct station_parameters *params)
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	
@@ -4137,7 +4198,12 @@ static int	cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev
 }
 
 static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,
-			       u8 *mac)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0))
+				u8 *mac
+#else
+				const u8 *mac
+#endif
+			       )
 {
 	int ret=0;	
 	_irqL irqL;
@@ -4191,7 +4257,7 @@ static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev
 		
 		plist = get_next(plist);	
 	
-		if(_rtw_memcmp(mac, psta->hwaddr, ETH_ALEN))		
+		if(_rtw_memcmp((u8 *)mac, psta->hwaddr, ETH_ALEN))		
 		{
 			if(psta->dot8021xalg == 1 && psta->bpairwise_key_installed == _FALSE)
 			{
@@ -4228,21 +4294,65 @@ static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev
 }
 
 static int	cfg80211_rtw_change_station(struct wiphy *wiphy, struct net_device *ndev,
-				  u8 *mac, struct station_parameters *params)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0))
+				u8 *mac, 
+#else
+				const u8 *mac,
+#endif
+				struct station_parameters *params)
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	
 	return 0;
 }
 
+struct sta_info *rtw_sta_info_get_by_idx(const int idx, struct sta_priv *pstapriv)
+
+{
+	_list	*phead, *plist;
+	struct sta_info *psta = NULL;
+	int i = 0;
+	
+	phead = &pstapriv->asoc_list;
+	plist = get_next(phead);
+
+	//check asoc_queue
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)	
+	{
+		if(idx == i) psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
+		plist = get_next(plist);	
+		i++;
+	}
+	return psta;
+}
+
 static int	cfg80211_rtw_dump_station(struct wiphy *wiphy, struct net_device *ndev,
 			       int idx, u8 *mac, struct station_info *sinfo)
 {
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	//TODO: dump scanned queue
+	int ret = 0;
+	_irqL irqL;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	return -ENOENT;
+	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	psta = rtw_sta_info_get_by_idx(idx, pstapriv);
+	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	if(NULL == psta)
+	{
+		DBG_871X("Station is not found\n");
+		ret = -ENOENT;
+		goto exit;
+	}
+	_rtw_memcpy(mac, psta->hwaddr, ETH_ALEN);
+	sinfo->filled = 0;
+	sinfo->filled |= STATION_INFO_SIGNAL;
+	sinfo->signal = psta->rssi;
+	
+exit:
+	return ret;
 }
 
 static int	cfg80211_rtw_change_bss(struct wiphy *wiphy, struct net_device *ndev,
@@ -4650,7 +4760,8 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 	struct mlme_ext_priv *pmlmeext;
 	struct wifidirect_info *pwdinfo;
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo;
-
+	u8 is_p2p_find = _FALSE;
+	
 	if (ndev == NULL) {
 		return  -EINVAL;
 	}
@@ -4660,20 +4771,21 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 	pmlmeext = &padapter->mlmeextpriv;
 	pwdinfo = &padapter->wdinfo;
 	pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
-
+	#ifdef CONFIG_CONCURRENT_MODE
+	is_p2p_find=(duration < (pwdinfo->ext_listen_interval))? _TRUE : _FALSE;
+	#endif
 	DBG_871X(FUNC_ADPT_FMT" ch:%u duration:%d\n", FUNC_ADPT_ARG(padapter), remain_ch, duration);
 
 	if(pcfg80211_wdinfo->is_ro_ch == _TRUE)
 	{
+		pcfg80211_wdinfo->not_indic_ro_ch_exp = _TRUE;
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
-		
 		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
-
-#ifdef CONFIG_CONCURRENT_MODE
-                ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);			
-#endif //CONFIG_CONCURRENT_MODE	
-
+		#ifdef CONFIG_CONCURRENT_MODE
+		ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
+		#endif //CONFIG_CONCURRENT_MODE
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
+		pcfg80211_wdinfo->not_indic_ro_ch_exp = _FALSE;
 	}
 
 	pcfg80211_wdinfo->is_ro_ch = _TRUE;
@@ -4692,7 +4804,7 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 
 	rtw_scan_abort(padapter);
 #ifdef CONFIG_CONCURRENT_MODE		
-	if(rtw_buddy_adapter_up(padapter))	
+	if ((rtw_buddy_adapter_up(padapter)) && is_p2p_find)		//don't scan_abort during p2p_listen.
 		rtw_scan_abort(padapter->pbuddy_adapter);			
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -4733,10 +4845,13 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 
 
 #ifdef	CONFIG_CONCURRENT_MODE
-	if(check_buddy_fwstate(padapter, _FW_LINKED) &&
-		(duration<pwdinfo->ext_listen_interval)) 
+	if   (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
-		duration = duration + 	pwdinfo->ext_listen_interval;
+		if (is_p2p_find)				// p2p_find , duration<1000
+			duration = duration + 	pwdinfo->ext_listen_interval;
+		else							// p2p_listen, duration=5000
+			duration = pwdinfo->ext_listen_interval  
+				     + (pwdinfo->ext_listen_interval/4);
 	}
 #endif
 
@@ -4854,12 +4969,14 @@ static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 
 	if (pcfg80211_wdinfo->is_ro_ch == _TRUE) {
+		pcfg80211_wdinfo->not_indic_ro_ch_exp = _TRUE;
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
 		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
 		#ifdef CONFIG_CONCURRENT_MODE
 		ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
 		#endif
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
+		pcfg80211_wdinfo->not_indic_ro_ch_exp = _FALSE;
 	}
 
 	#if 0
@@ -5056,30 +5173,43 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 #else
 	struct net_device *ndev,
 #endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)) || defined(COMPAT_KERNEL_RELEASE)
 	struct ieee80211_channel *chan,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
 	bool offchan,
-#endif
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+	#endif
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
 	enum nl80211_channel_type channel_type,
 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	bool channel_type_valid,
 	#endif
-#endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
+	#endif
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
 	unsigned int wait,
-#endif
+	#endif
 	const u8 *buf, size_t len,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	bool no_cck,
-#endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+	#endif
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 	bool dont_wait_for_ack,
+	#endif
+#else
+	struct cfg80211_mgmt_tx_params *params,
 #endif
 	u64 *cookie)
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
 	struct net_device *ndev = wdev_to_ndev(wdev);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)) || defined(COMPAT_KERNEL_RELEASE)
+	struct ieee80211_channel *chan = params->chan;
+	bool offchan = params->offchan;
+	unsigned int wait = params->wait;
+	const u8 *buf = params->buf;
+	size_t len = params->len;
+	bool no_cck = params->no_cck;
+	bool dont_wait_for_ack = params->dont_wait_for_ack;
 #endif
 	int ret = 0;
 	int tx_ret;
@@ -5351,12 +5481,61 @@ static int cfg80211_rtw_tdls_oper(struct wiphy *wiphy,
 		case NL80211_TDLS_ENABLE_LINK:
 			break;
 		case NL80211_TDLS_DISABLE_LINK:
-			break;			
+			break;
 	}
 	return 0;
 }
 #endif /* CONFIG_TDLS */
 
+#if defined(CONFIG_PNO_SUPPORT) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+static int cfg80211_rtw_sched_scan_start(struct wiphy *wiphy,
+		struct net_device *dev,
+		struct cfg80211_sched_scan_request *request) {
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8 ret;
+
+	if (padapter->bup == _FALSE) {
+		DBG_871X("%s: net device is down.\n", __func__);
+		return -EIO;
+	}
+
+	if(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE ||
+		check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE  ||
+		check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
+		DBG_871X("%s: device is busy.\n", __func__);
+		rtw_scan_abort(padapter);
+	}
+
+	if (request == NULL) {
+		DBG_871X("%s: invalid cfg80211_requests parameters.\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = rtw_android_cfg80211_pno_setup(dev, request->ssids,
+			request->n_ssids, request->interval);
+
+	if (ret < 0) {
+		DBG_871X("%s ret: %d\n", __func__, ret);
+		goto exit;
+	}
+
+	ret = rtw_android_pno_enable(dev, _TRUE);
+	if (ret < 0) {
+		DBG_871X("%s ret: %d\n", __func__, ret);
+		goto exit;
+	}
+exit:
+	return ret;
+}
+
+static int cfg80211_rtw_sched_scan_stop(struct wiphy *wiphy,
+		struct net_device *dev) {
+	return rtw_android_pno_enable(dev, _FALSE);
+}
+#endif /* CONFIG_PNO_SUPPORT */
+
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {	
 	int ret = 0;
@@ -5812,7 +5991,7 @@ void rtw_cfg80211_init_wiphy(_adapter *padapter)
 	}
 
 	/* init regulary domain */
-	rtw_regd_init(padapter, rtw_reg_notifier);
+	rtw_regd_init(padapter);
 
 	/* copy mac_addr to wiphy */
 	_rtw_memcpy(wiphy->perm_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
@@ -5900,7 +6079,18 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 #endif
 
 #if defined(CONFIG_PM) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#ifdef CONFIG_PNO_SUPPORT
+	wiphy->max_sched_scan_ssids = MAX_PNO_LIST_COUNT;
+#endif
+#endif
+
+#if defined(CONFIG_PM) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0))
 	wiphy->wowlan = wowlan_stub;
+#else
+	wiphy->wowlan = &wowlan_stub;
+#endif
 #endif
 
 #if defined(CONFIG_TDLS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
@@ -5916,6 +6106,10 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	//wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
 #endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)
+	rtw_cfgvendor_attach(wiphy);
+#endif
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -5980,6 +6174,11 @@ static struct cfg80211_ops rtw_cfg80211_ops = {
 	.tdls_mgmt = cfg80211_rtw_tdls_mgmt,
 	.tdls_oper = cfg80211_rtw_tdls_oper,
 #endif /* CONFIG_TDLS */
+
+#if defined(CONFIG_PNO_SUPPORT) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+	.sched_scan_start = cfg80211_rtw_sched_scan_start,
+	.sched_scan_stop = cfg80211_rtw_sched_scan_stop,
+#endif /* CONFIG_PNO_SUPPORT */
 };
 
 int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
@@ -6103,6 +6302,10 @@ void rtw_wdev_unregister(struct wireless_dev *wdev)
 		unregister_netdev(pwdev_priv->pmon_ndev);
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)
+	rtw_cfgvendor_detach(wdev->wiphy);
+#endif
+
 	wiphy_unregister(wdev->wiphy);
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/ioctl_cfg80211.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_cfg80211.h
similarity index 94%
rename from drivers/net/wireless/rockchip_wlan/rtl8189es/include/ioctl_cfg80211.h
rename to drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_cfg80211.h
index 6fe9f86f1bda..3727922c43ba 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/include/ioctl_cfg80211.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_cfg80211.h
@@ -144,8 +144,10 @@ bool rtw_cfg80211_pwr_mgmt(_adapter *adapter);
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, buf, len, gfp)
 #elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, sig_dbm, buf, len, gfp)
-#else
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, gfp)
+#else
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len,0,gfp)
 #endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))  && !defined(COMPAT_KERNEL_RELEASE)
@@ -171,5 +173,7 @@ bool rtw_cfg80211_pwr_mgmt(_adapter *adapter);
 #define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->rtw_wdev, cookie, chan, gfp)
 #endif
 
+#include "rtw_cfgvendor.h"
+
 #endif //__IOCTL_CFG80211_H__
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_linux.c
index 38be708bb55e..0035054c5bf4 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/ioctl_linux.c
@@ -23,7 +23,7 @@
 
 //#ifdef CONFIG_MP_INCLUDED
 #include <rtw_mp_ioctl.h>
-#include "../../hal/OUTSRC/odm_precomp.h"
+#include "../../hal/OUTSRC/phydm_precomp.h"
 //#endif
 
 #if defined(CONFIG_RTL8723A)
@@ -40,6 +40,10 @@
 #define  iwe_stream_add_point(a, b, c, d, e)  iwe_stream_add_point(b, c, d, e)
 #endif
 
+#ifdef CONFIG_80211N_HT
+extern int rtw_ht_enable;
+#endif
+
 
 #define RTL_IOCTL_WPA_SUPPLICANT	SIOCIWFIRSTPRIV+30
 
@@ -300,28 +304,12 @@ uint	rtw_is_cckratesonly_included(u8 *rate)
 }
 */
 
-static char *translate_scan(_adapter *padapter, 
+static int search_p2p_wfd_ie(_adapter *padapter,
 				struct iw_request_info* info, struct wlan_network *pnetwork,
 				char *start, char *stop)
 {
-	struct iw_event iwe;
-	u16 cap;
-	u32 ht_ielen = 0, vht_ielen = 0;
-	char custom[MAX_CUSTOM_LEN];
-	char *p;
-	u16 max_rate=0, rate, ht_cap=_FALSE, vht_cap = _FALSE;
-	u32 i = 0;	
-	char	*current_val;
-	long rssi;
-	u8 bw_40MHz=0, short_GI=0, bw_160MHz=0, vht_highest_rate = 0;
-	u16 mcs_rate=0, vht_data_rate=0;
-	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);
-	struct registry_priv *pregpriv = &padapter->registrypriv;
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
-#endif //CONFIG_P2P
-
-#ifdef CONFIG_P2P
 #ifdef CONFIG_WFD
 	if ( SCAN_RESULT_ALL == pwdinfo->wfd_info->scan_result_type )
 	{
@@ -353,7 +341,7 @@ static char *translate_scan(_adapter *padapter,
 
 			if ( blnGotP2PIE == _FALSE )
 			{
-				return start;
+				return _FALSE;
 			}
 			
 		}
@@ -397,12 +385,547 @@ static char *translate_scan(_adapter *padapter,
 		
 		if ( blnGotWFD == _FALSE )
 		{
-			return start;
+			return _FALSE;
 		}
 	}
 #endif // CONFIG_WFD
 
 #endif //CONFIG_P2P
+	return _TRUE;
+}
+ static inline char *iwe_stream_mac_addr_proess(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{	
+	/*  AP MAC address  */
+	iwe->cmd = SIOCGIWAP;
+	iwe->u.ap_addr.sa_family = ARPHRD_ETHER;
+
+	_rtw_memcpy(iwe->u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_ADDR_LEN);	
+	return start;
+}
+ static inline char * iwe_stream_essid_proess(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	
+	/* Add the ESSID */
+	iwe->cmd = SIOCGIWESSID;
+	iwe->u.data.flags = 1;	
+	iwe->u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
+	start = iwe_stream_add_point(info, start, stop, iwe, pnetwork->network.Ssid.Ssid);		
+	return start;
+}
+
+ static inline char * iwe_stream_chan_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	if(pnetwork->network.Configuration.DSConfig<1 /*|| pnetwork->network.Configuration.DSConfig>14*/)
+		pnetwork->network.Configuration.DSConfig = 1;
+
+	 /* Add frequency/channel */
+	iwe->cmd = SIOCGIWFREQ;
+	iwe->u.freq.m = rtw_ch2freq(pnetwork->network.Configuration.DSConfig) * 100000;
+	iwe->u.freq.e = 1;
+	iwe->u.freq.i = pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_FREQ_LEN);
+	return start;
+}
+ static inline char * iwe_stream_mode_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe,u16 cap)
+{
+	/* Add mode */
+	if(cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
+		iwe->cmd = SIOCGIWMODE;
+		if (cap & WLAN_CAPABILITY_BSS)
+			iwe->u.mode = IW_MODE_MASTER;
+		else
+			iwe->u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_UINT_LEN);
+	}
+	return start;
+ }
+ static inline char * iwe_stream_encryption_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe,u16 cap)
+{	
+
+	/* Add encryption capability */
+	iwe->cmd = SIOCGIWENCODE;
+	if (cap & WLAN_CAPABILITY_PRIVACY)
+		iwe->u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe->u.data.flags = IW_ENCODE_DISABLED;
+	iwe->u.data.length = 0;
+	start = iwe_stream_add_point(info, start, stop, iwe, pnetwork->network.Ssid.Ssid);
+	return start;
+
+}	
+
+ static inline char * iwe_stream_protocol_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+ {
+ 	u16 ht_cap=_FALSE,vht_cap = _FALSE;
+	u32 ht_ielen = 0, vht_ielen = 0;
+	char *p;
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);// Probe Request	
+		
+	//parsing HT_CAP_IE	
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-ie_offset);	
+	if(p && ht_ielen>0)		
+		ht_cap = _TRUE;			
+
+	#ifdef CONFIG_80211AC_VHT
+	//parsing VHT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], EID_VHTCapability, &vht_ielen, pnetwork->network.IELength-ie_offset);
+	if(p && vht_ielen>0)
+		vht_cap = _TRUE;	
+	#endif
+	 /* Add the protocol name */
+	iwe->cmd = SIOCGIWNAME;
+	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)		
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11bn");
+		else
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11b");
+	}	
+	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)	
+	{
+		if(ht_cap == _TRUE)
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11bgn");
+		else
+			snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11bg");
+	}	
+	else
+	{
+		if(pnetwork->network.Configuration.DSConfig > 14)
+		{
+			#ifdef CONFIG_80211AC_VHT
+			if(vht_cap == _TRUE){
+				snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11AC");
+			}
+			else 
+			#endif	
+			{
+				if(ht_cap == _TRUE)
+					snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11an");
+				else
+					snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11a");
+			}
+		}
+		else
+		{
+			if(ht_cap == _TRUE)
+				snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11gn");
+			else
+				snprintf(iwe->u.name, IFNAMSIZ, "IEEE 802.11g");
+		}
+	}
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_CHAR_LEN);
+	return start;
+ }
+				
+ static inline char * iwe_stream_rate_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	u32 ht_ielen = 0, vht_ielen = 0;
+	char *p;
+	u16 max_rate=0, rate, ht_cap=_FALSE, vht_cap = _FALSE;
+	u32 i = 0;		
+	u8 bw_40MHz=0, short_GI=0, bw_160MHz=0, vht_highest_rate = 0;
+	u16 mcs_rate=0, vht_data_rate=0;
+	char custom[MAX_CUSTOM_LEN]={0};
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);// Probe Request	
+ 	
+	//parsing HT_CAP_IE	
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-ie_offset);	
+	if(p && ht_ielen>0)
+	{
+		struct rtw_ieee80211_ht_cap *pht_capie;
+		ht_cap = _TRUE;			
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);		
+		_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+	}
+
+#ifdef CONFIG_80211AC_VHT
+	//parsing VHT_CAP_IE
+	p = rtw_get_ie(&pnetwork->network.IEs[ie_offset], EID_VHTCapability, &vht_ielen, pnetwork->network.IELength-ie_offset);
+	if(p && vht_ielen>0)
+	{
+		u8	mcs_map[2];
+
+		vht_cap = _TRUE;		
+		bw_160MHz = GET_VHT_CAPABILITY_ELE_CHL_WIDTH(p+2);
+		if(bw_160MHz)
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI160M(p+2);
+		else
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI80M(p+2);
+
+		_rtw_memcpy(mcs_map, GET_VHT_CAPABILITY_ELE_TX_MCS(p+2), 2);
+
+		vht_highest_rate = rtw_get_vht_highest_rate(mcs_map);
+		vht_data_rate = rtw_vht_mcs_to_data_rate(CHANNEL_WIDTH_80, short_GI, vht_highest_rate);
+	}
+#endif	
+	
+	/*Add basic and extended rates */	
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
+	while(pnetwork->network.SupportedRates[i]!=0)
+	{
+		rate = pnetwork->network.SupportedRates[i]&0x7F; 
+		if (rate > max_rate)
+			max_rate = rate;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+		i++;
+	}
+#ifdef CONFIG_80211AC_VHT
+	if(vht_cap == _TRUE) {
+		max_rate = vht_data_rate;
+	}
+	else
+#endif		
+	if(ht_cap == _TRUE)
+	{
+		if(mcs_rate&0x8000)//MCS15
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+			
+		}
+		else if(mcs_rate&0x0080)//MCS7
+		{
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+		else//default MCS7
+		{
+			//DBG_871X("wx_get_scan, mcs_rate_bitmap=0x%x\n", mcs_rate);
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+
+		max_rate = max_rate*2;//Mbps/2;		
+	}
+
+	iwe->cmd = SIOCGIWRATE;
+	iwe->u.bitrate.fixed = iwe->u.bitrate.disabled = 0;
+	iwe->u.bitrate.value = max_rate * 500000;
+	start =iwe_stream_add_event(info, start, stop, iwe, IW_EV_PARAM_LEN);
+	return start ;
+}
+
+static inline char * iwe_stream_wpa_wpa2_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	int buf_size = MAX_WPA_IE_LEN*2;
+	//u8 pbuf[buf_size]={0};	
+	u8 *pbuf = rtw_zmalloc(buf_size);
+
+	u8 wpa_ie[255]={0},rsn_ie[255]={0};
+	u16 i, wpa_len=0,rsn_len=0;
+	u8 *p;
+	sint out_len=0;
+		
+	
+	if(pbuf){
+		p=pbuf;	
+	
+		//parsing WPA/WPA2 IE
+		if (pnetwork->network.Reserved[0] != 2) // Probe Request
+		{	
+			out_len=rtw_get_sec_ie(pnetwork->network.IEs ,pnetwork->network.IELength,rsn_ie,&rsn_len,wpa_ie,&wpa_len);
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wpa_len=%d rsn_len=%d\n",wpa_len,rsn_len));
+
+			if (wpa_len > 0){
+				
+				_rtw_memset(pbuf, 0, buf_size);
+				p += sprintf(p, "wpa_ie=");
+				for (i = 0; i < wpa_len; i++) {
+					p += sprintf(p, "%02x", wpa_ie[i]);
+				}
+
+				if (wpa_len > 100) {
+					printk("-----------------Len %d----------------\n", wpa_len);
+					for (i = 0; i < wpa_len; i++) {
+						printk("%02x ", wpa_ie[i]);
+					}
+					printk("\n");
+					printk("-----------------Len %d----------------\n", wpa_len);
+				}
+		
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd = IWEVCUSTOM;
+				iwe->u.data.length = strlen(pbuf);
+				start = iwe_stream_add_point(info, start, stop, iwe,pbuf);
+				
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd =IWEVGENIE;
+				iwe->u.data.length = wpa_len;
+				start = iwe_stream_add_point(info, start, stop, iwe, wpa_ie);			
+			}
+			if (rsn_len > 0){
+				
+				_rtw_memset(pbuf, 0, buf_size);
+				p += sprintf(p, "rsn_ie=");
+				for (i = 0; i < rsn_len; i++) {
+					p += sprintf(p, "%02x", rsn_ie[i]);
+				}
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd = IWEVCUSTOM;
+				iwe->u.data.length = strlen(pbuf);
+				start = iwe_stream_add_point(info, start, stop, iwe,pbuf);
+			
+				_rtw_memset(iwe, 0, sizeof(*iwe));
+				iwe->cmd =IWEVGENIE;
+				iwe->u.data.length = rsn_len;
+				start = iwe_stream_add_point(info, start, stop, iwe, rsn_ie);		
+			}
+		}
+	
+		rtw_mfree(pbuf, buf_size);	
+	}
+	return start;
+}
+
+static inline char * iwe_stream_wps_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{	
+ 	//parsing WPS IE
+	uint cnt = 0,total_ielen;	
+	u8 *wpsie_ptr=NULL;
+	uint wps_ielen = 0;		
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);
+	
+	u8 *ie_ptr = pnetwork->network.IEs + ie_offset;
+	total_ielen= pnetwork->network.IELength - ie_offset;
+
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	{
+		ie_ptr = pnetwork->network.IEs;
+		total_ielen = pnetwork->network.IELength;
+	}
+	else     // Beacon or Probe Respones
+	{
+		ie_ptr = pnetwork->network.IEs + _FIXED_IE_LENGTH_;
+		total_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;
+	}    
+	while(cnt < total_ielen)
+	{
+		if(rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))			
+		{
+			wpsie_ptr = &ie_ptr[cnt];
+			iwe->cmd =IWEVGENIE;
+			iwe->u.data.length = (u16)wps_ielen;
+			start = iwe_stream_add_point(info, start, stop,iwe, wpsie_ptr);						
+		}			
+		cnt+=ie_ptr[cnt+1]+2; //goto next
+	}
+	return start;
+}
+
+static inline char * iwe_stream_wapi_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+#ifdef CONFIG_WAPI_SUPPORT
+	char *p;
+		
+	if (pnetwork->network.Reserved[0] != 2) // Probe Request
+	{		
+		sint out_len_wapi=0;
+		/* here use static for stack size */
+		static u8 buf_wapi[MAX_WAPI_IE_LEN*2]={0};
+		static u8 wapi_ie[MAX_WAPI_IE_LEN]={0};
+		u16 wapi_len=0;
+		u16  i;
+
+		out_len_wapi=rtw_get_wapi_ie(pnetwork->network.IEs ,pnetwork->network.IELength,wapi_ie,&wapi_len);
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: ssid=%s\n",pnetwork->network.Ssid.Ssid));
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan: wapi_len=%d \n",wapi_len));
+
+		DBG_871X("rtw_wx_get_scan: %s ",pnetwork->network.Ssid.Ssid);
+		DBG_871X("rtw_wx_get_scan: ssid = %d ",wapi_len);
+
+
+		if (wapi_len > 0)
+		{
+			p=buf_wapi;
+			//_rtw_memset(buf_wapi, 0, MAX_WAPI_IE_LEN*2);
+			p += sprintf(p, "wapi_ie=");
+			for (i = 0; i < wapi_len; i++) {
+				p += sprintf(p, "%02x", wapi_ie[i]);
+			}
+
+			_rtw_memset(iwe, 0, sizeof(*iwe));
+			iwe->cmd = IWEVCUSTOM;
+			iwe->u.data.length = strlen(buf_wapi);
+			start = iwe_stream_add_point(info, start, stop, iwe,buf_wapi);
+
+			_rtw_memset(iwe, 0, sizeof(*iwe));
+			iwe->cmd =IWEVGENIE;
+			iwe->u.data.length = wapi_len;
+			start = iwe_stream_add_point(info, start, stop, iwe, wapi_ie);
+		}
+	}
+#endif//#ifdef CONFIG_WAPI_SUPPORT
+	return start;
+}
+
+static inline char *  iwe_stream_rssi_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{
+	u8 ss, sq;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	
+	/* Add quality statistics */
+	iwe->cmd = IWEVQUAL;
+	iwe->u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED 
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		| IW_QUAL_NOISE_UPDATED
+	#else
+		| IW_QUAL_NOISE_INVALID
+	#endif
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+		| IW_QUAL_DBM
+	#endif
+	;
+
+	if ( check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
+		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)){
+		ss = padapter->recvpriv.signal_strength;
+		sq = padapter->recvpriv.signal_qual;
+	} else {
+		ss = pnetwork->network.PhyInfo.SignalStrength;
+		sq = pnetwork->network.PhyInfo.SignalQuality;
+	}
+	
+	
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+	iwe->u.qual.level = (u8) translate_percentage_to_dbm(ss);//dbm
+	#else
+	#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+	{
+		/* Do signal scale mapping when using percentage as the unit of signal strength, since the scale mapping is skipped in odm */
+		
+		HAL_DATA_TYPE *pHal = GET_HAL_DATA(padapter);
+		
+		iwe->u.qual.level = (u8)odm_SignalScaleMapping(&pHal->odmpriv, ss);
+	}
+	#else
+	iwe->u.qual.level = (u8)ss;//%
+	#endif
+	#endif
+	
+	iwe->u.qual.qual = (u8)sq;   // signal quality
+
+	#ifdef CONFIG_PLATFORM_ROCKCHIPS
+	iwe->u.qual.noise = -100; // noise level suggest by zhf@rockchips
+	#else 
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+	{
+		s16 tmp_noise=0;
+		rtw_hal_get_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&(pnetwork->network.Configuration.DSConfig), &(tmp_noise));
+		iwe->u.qual.noise = tmp_noise ;
+	}
+	#else
+	iwe->u.qual.noise = 0; // noise level
+	#endif	
+	#endif //CONFIG_PLATFORM_ROCKCHIPS
+	
+	//DBG_871X("iqual=%d, ilevel=%d, inoise=%d, iupdated=%d\n", iwe.u.qual.qual, iwe.u.qual.level , iwe.u.qual.noise, iwe.u.qual.updated);
+
+	start = iwe_stream_add_event(info, start, stop, iwe, IW_EV_QUAL_LEN);
+	return start;
+}
+
+static inline char *  iwe_stream_net_rsv_process(_adapter *padapter,
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop,struct iw_event *iwe)
+{	
+	u8 buf[32] = {0};
+	u8 * p,*pos;
+	int len;
+	p = buf;
+	pos = pnetwork->network.Reserved;
+	
+	p += sprintf(p, "fm=%02X%02X", pos[1], pos[0]);
+	_rtw_memset(iwe, 0, sizeof(*iwe));
+	iwe->cmd = IWEVCUSTOM;
+	iwe->u.data.length = strlen(buf);
+	start = iwe_stream_add_point(info, start, stop,iwe, buf);
+	return start;
+}
+
+#if 1
+static char *translate_scan(_adapter *padapter, 
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop)
+{	
+	struct iw_event iwe;
+	u16 cap = 0;
+	_rtw_memset(&iwe, 0, sizeof(iwe));
+	
+	if(_FALSE == search_p2p_wfd_ie(padapter,info,pnetwork,start,stop))
+		return start;
+
+	start = iwe_stream_mac_addr_proess(padapter,info,pnetwork,start,stop,&iwe);	
+	start = iwe_stream_essid_proess(padapter,info,pnetwork,start,stop,&iwe);	
+	start = iwe_stream_protocol_process(padapter,info,pnetwork,start,stop,&iwe);
+	if (pnetwork->network.Reserved[0] == 2) // Probe Request
+	{
+		cap = 0;
+	}
+	else
+	{
+		_rtw_memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
+		cap = le16_to_cpu(cap);
+	}
+
+	start = iwe_stream_mode_process(padapter,info,pnetwork,start,stop,&iwe,cap);	
+	start = iwe_stream_chan_process(padapter,info,pnetwork,start,stop,&iwe);	
+	start = iwe_stream_encryption_process(padapter,info,pnetwork,start,stop,&iwe,cap);	
+	start = iwe_stream_rate_process(padapter,info,pnetwork,start,stop,&iwe);	
+	start = iwe_stream_wpa_wpa2_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_wps_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_wapi_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_rssi_process(padapter,info,pnetwork,start,stop,&iwe);
+	start = iwe_stream_net_rsv_process(padapter,info,pnetwork,start,stop,&iwe);	
+	
+	return start;	
+}
+#else
+static char *translate_scan(_adapter *padapter, 
+				struct iw_request_info* info, struct wlan_network *pnetwork,
+				char *start, char *stop)
+{
+	struct iw_event iwe;
+	u16 cap;
+	u32 ht_ielen = 0, vht_ielen = 0;
+	char custom[MAX_CUSTOM_LEN];
+	char *p;
+	u16 max_rate=0, rate, ht_cap=_FALSE, vht_cap = _FALSE;
+	u32 i = 0;	
+	char	*current_val;
+	long rssi;
+	u8 bw_40MHz=0, short_GI=0, bw_160MHz=0, vht_highest_rate = 0;
+	u16 mcs_rate=0, vht_data_rate=0;
+	u8 ie_offset = (pnetwork->network.Reserved[0] == 2? 0:12);
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+	
+	if(_FALSE == search_p2p_wfd_ie(padapter,info,pnetwork,start,stop))
+		return start;
 
 	/*  AP MAC address  */
 	iwe.cmd = SIOCGIWAP;
@@ -410,7 +933,7 @@ static char *translate_scan(_adapter *padapter,
 
 	_rtw_memcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
 	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
-
+	
 	/* Add the ESSID */
 	iwe.cmd = SIOCGIWESSID;
 	iwe.u.data.flags = 1;	
@@ -718,7 +1241,12 @@ static char *translate_scan(_adapter *padapter,
 	
 	/* Add quality statistics */
 	iwe.cmd = IWEVQUAL;
-	iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID
+	iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED 
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		| IW_QUAL_NOISE_UPDATED
+	#else
+		| IW_QUAL_NOISE_INVALID
+	#endif
 	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 		| IW_QUAL_DBM
 	#endif
@@ -737,15 +1265,33 @@ static char *translate_scan(_adapter *padapter,
 	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 	iwe.u.qual.level = (u8) translate_percentage_to_dbm(ss);//dbm
 	#else
+	#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+	{
+		/* Do signal scale mapping when using percentage as the unit of signal strength, since the scale mapping is skipped in odm */
+		
+		HAL_DATA_TYPE *pHal = GET_HAL_DATA(padapter);
+		
+		iwe.u.qual.level = (u8)odm_SignalScaleMapping(&pHal->odmpriv, ss);
+	}
+	#else
 	iwe.u.qual.level = (u8)ss;//%
 	#endif
+	#endif
 	
 	iwe.u.qual.qual = (u8)sq;   // signal quality
 
 	#ifdef CONFIG_PLATFORM_ROCKCHIPS
 	iwe.u.qual.noise = -100; // noise level suggest by zhf@rockchips
 	#else 
+	#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+	{
+		s16 tmp_noise=0;
+		rtw_hal_get_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&(pnetwork->network.Configuration.DSConfig), &(tmp_noise));
+		iwe.u.qual.noise = tmp_noise ;
+	}
+	#else
 	iwe.u.qual.noise = 0; // noise level
+	#endif	
 	#endif //CONFIG_PLATFORM_ROCKCHIPS
 	
 	//DBG_871X("iqual=%d, ilevel=%d, inoise=%d, iupdated=%d\n", iwe.u.qual.qual, iwe.u.qual.level , iwe.u.qual.noise, iwe.u.qual.updated);
@@ -769,6 +1315,7 @@ static char *translate_scan(_adapter *padapter,
 	
 	return start;	
 }
+#endif
 
 static int wpa_set_auth_algs(struct net_device *dev, u32 value)
 {	
@@ -1377,12 +1924,18 @@ static int rtw_wx_get_name(struct net_device *dev,
 		{
 			if(pcur_bss->Configuration.DSConfig > 14)
 			{
-				if(vht_cap == _TRUE)
+			#ifdef CONFIG_80211AC_VHT
+				if(vht_cap == _TRUE){
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11AC");
-				else if(ht_cap == _TRUE)
-					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11an");
+				}
 				else
-					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11a");
+			#endif
+				{
+					if(ht_cap == _TRUE)
+						snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11an");
+					else
+						snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11a");
+				}
 			}
 			else
 			{
@@ -5220,7 +5773,14 @@ static int rtw_p2p_connect(struct net_device *dev,
 		DBG_871X( "[%s] WiFi Direct is disable!\n", __FUNCTION__ );
 		return ret;
 	}
-	
+
+#ifdef CONFIG_INTEL_WIDI
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+		DBG_871X( "[%s] WiFi is under survey!\n", __FUNCTION__ );
+		return ret;
+	}
+#endif //CONFIG_INTEL_WIDI	
+
 	if ( pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO )
 	{
 		return -1;
@@ -5309,6 +5869,19 @@ static int rtw_p2p_connect(struct net_device *dev,
 	else
 	{
 		DBG_871X( "[%s] Not Found in Scanning Queue~\n", __FUNCTION__ );
+#ifdef CONFIG_INTEL_WIDI
+		_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
+		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
+		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
+		rtw_free_network_queue(padapter, _TRUE);
+		/** 
+		 * For WiDi, if we can't find candidate device in scanning queue,
+		 * driver will do scanning itself
+		 */
+		_enter_critical_bh(&pmlmepriv->lock, &irqL);
+		rtw_sitesurvey_cmd(padapter, NULL, 0, NULL, 0);
+		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+#endif //CONFIG_INTEL_WIDI 
 		ret = -1;
 	}
 exit:	
@@ -5988,7 +6561,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 	else
 	{
 #ifdef CONFIG_INTEL_WIDI
-		if(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE){
+		if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
 			DBG_871X( "[%s] WiFi is under survey!\n", __FUNCTION__ );
 			return ret;
 		}
@@ -6202,6 +6775,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 	{
 		DBG_871X( "[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__ );
 #ifdef CONFIG_INTEL_WIDI
+		_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
 		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
 		rtw_free_network_queue(padapter, _TRUE);		
@@ -6627,6 +7201,10 @@ static int rtw_rereg_nd_name(struct net_device *dev,
 #ifdef CONFIG_IOL
 #include <rtw_iol.h>
 #endif
+
+#ifdef DBG_CMD_QUEUE
+u8 dump_cmd_id=0;
+#endif
 static int rtw_dbg_port(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
@@ -6999,7 +7577,7 @@ static int rtw_dbg_port(struct net_device *dev,
 							pxmitpriv->free_xmit_extbuf_cnt, pxmitpriv->free_xframe_ext_cnt,
 							precvpriv->free_recvframe_cnt);
 						#ifdef CONFIG_USB_HCI
-						DBG_871X("rx_urb_pending_cn=%d\n", precvpriv->rx_pending_cnt);
+						DBG_871X("rx_urb_pending_cn=%d\n", ATOMIC_READ(&(precvpriv->rx_pending_cnt)));
 						#endif
 					}
 					break;	
@@ -7074,6 +7652,26 @@ static int rtw_dbg_port(struct net_device *dev,
 						printk("%s ==> max_mac_id = %d \n",__FUNCTION__,max_mac_id);
 					}	
 					break;
+				case 0x0b: //Enable=1, Disable=0 driver control vrtl_carrier_sense.
+					{
+						//u8 driver_vcs_en; //Enable=1, Disable=0 driver control vrtl_carrier_sense.
+						//u8 driver_vcs_type;//force 0:disable VCS, 1:RTS-CTS, 2:CTS-to-self when vcs_en=1.
+
+						if(arg == 0){
+							DBG_871X("disable driver ctrl vcs\n");						
+							padapter->driver_vcs_en = 0;					
+						}
+						else if(arg == 1){							
+							DBG_871X("enable driver ctrl vcs = %d\n", extra_arg);
+							padapter->driver_vcs_en = 1;
+	
+							if(extra_arg>2)
+								padapter->driver_vcs_type = 1;						
+							else
+								padapter->driver_vcs_type = extra_arg;
+						}
+					}
+					break;
 				case 0x0c://dump rx/tx packet
 					{
 						if(arg == 0){
@@ -7098,6 +7696,23 @@ static int rtw_dbg_port(struct net_device *dev,
 					}				
 					break;
 #endif
+				case 0x0e:
+					{
+						if(arg == 0){
+							DBG_871X("disable driver ctrl rx_ampdu_factor\n");						
+							padapter->driver_rx_ampdu_factor = 0xFF;
+						}
+						else if(arg == 1){
+							
+							DBG_871X("enable driver ctrl rx_ampdu_factor = %d\n", extra_arg);	
+	
+							if(extra_arg > 0x03)
+								padapter->driver_rx_ampdu_factor = 0xFF;						
+							else
+								padapter->driver_rx_ampdu_factor = extra_arg;
+						}					
+					}
+					break;
 		#ifdef DBG_CONFIG_ERROR_DETECT
 				case 0x0f:
 						{
@@ -7126,7 +7741,22 @@ static int rtw_dbg_port(struct net_device *dev,
 					break;
 				case 0x11://dump linked status
 					{
-						 linked_info_dump(padapter,extra_arg);
+						int pre_mode;
+						pre_mode=padapter->bLinkInfoDump;
+						// linked_info_dump(padapter,extra_arg);
+						 if(extra_arg==1 || (extra_arg==0 && pre_mode==1) ) //not consider pwr_saving 0:
+						{
+							padapter->bLinkInfoDump = extra_arg;	
+		
+						}
+						else if( (extra_arg==2 ) || (extra_arg==0 && pre_mode==2))//consider power_saving
+						{		
+						//DBG_871X("linked_info_dump =%s \n", (padapter->bLinkInfoDump)?"enable":"disable")
+							linked_info_dump(padapter,extra_arg);	
+						}
+
+
+						 
 					}					
 					break;
 #ifdef CONFIG_80211N_HT
@@ -7172,28 +7802,142 @@ static int rtw_dbg_port(struct net_device *dev,
 					if(arg == 0xff){
 						rtw_odm_dbg_comp_msg(RTW_DBGDUMP,padapter);
 					}
-					else{
-						u64 dbg_comp = (u64)extra_arg;
-						rtw_odm_dbg_comp_set(padapter, dbg_comp);
+					else{
+						u64 dbg_comp = (u64)extra_arg;
+						rtw_odm_dbg_comp_set(padapter, dbg_comp);
+					}
+				}
+					break;
+#ifdef DBG_FIXED_CHAN
+				case 0x17:
+					{
+						struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);						
+						printk("===>  Fixed channel to %d \n",extra_arg);
+						pmlmeext->fixed_chan = extra_arg;	
+						
+					}
+					break;
+#endif
+				case 0x18:
+					{
+						printk("===>  Switch USB Mode %d \n",extra_arg);
+						rtw_hal_set_hwreg(padapter, HW_VAR_USB_MODE, (u8 *)&extra_arg);
+					}
+					break;
+#ifdef CONFIG_80211N_HT			
+				case 0x19:
+					{
+						struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+						// extra_arg :
+						// BIT0: Enable VHT LDPC Rx, BIT1: Enable VHT LDPC Tx, 
+						// BIT4: Enable HT LDPC Rx, BIT5: Enable HT LDPC Tx
+						if(arg == 0){
+							DBG_871X("driver disable LDPC\n");						
+							pregistrypriv->ldpc_cap = 0x00;
+						}
+						else if(arg == 1){							
+							DBG_871X("driver set LDPC cap = 0x%x\n", extra_arg);
+							pregistrypriv->ldpc_cap = (u8)(extra_arg&0x33);						
+						}						
+					}
+                                        break;
+				case 0x1a:
+					{
+						struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+						// extra_arg :
+						// BIT0: Enable VHT STBC Rx, BIT1: Enable VHT STBC Tx, 
+						// BIT4: Enable HT STBC Rx, BIT5: Enable HT STBC Tx
+						if(arg == 0){
+							DBG_871X("driver disable STBC\n");						
+							pregistrypriv->stbc_cap = 0x00;
+						}
+						else if(arg == 1){							
+							DBG_871X("driver set STBC cap = 0x%x\n", extra_arg);
+							pregistrypriv->stbc_cap = (u8)(extra_arg&0x33);						
+						}						
+					}
+                                        break;
+#endif //CONFIG_80211N_HT
+				case 0x1b:
+					{	
+						struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+						
+						if(arg == 0){
+							DBG_871X("disable driver ctrl max_rx_rate, reset to default_rate_set\n");							
+							init_mlme_default_rate_set(padapter);
+#ifdef CONFIG_80211N_HT						
+							pregistrypriv->ht_enable = (u8)rtw_ht_enable;
+#endif //CONFIG_80211N_HT
+						}
+						else if(arg == 1){
+
+							int i;
+							u8 max_rx_rate;						
+							
+							DBG_871X("enable driver ctrl max_rx_rate = 0x%x\n", extra_arg);	
+
+							max_rx_rate = (u8)extra_arg;
+
+							if(max_rx_rate < 0xc) // max_rx_rate < MSC0 -> B or G -> disable HT
+							{
+#ifdef CONFIG_80211N_HT						
+								pregistrypriv->ht_enable = 0;
+#endif //CONFIG_80211N_HT
+								for(i=0; i<NumRates; i++)
+								{
+									if(pmlmeext->datarate[i] > max_rx_rate)
+										pmlmeext->datarate[i] = 0xff;									
+								}	
+
+							}
+#ifdef CONFIG_80211N_HT	
+							else if(max_rx_rate < 0x1c) // mcs0~mcs15
+							{
+								u32 mcs_bitmap=0x0;
+													
+								for(i=0; i<((max_rx_rate+1)-0xc); i++)
+									mcs_bitmap |= BIT(i);
+								
+								set_mcs_rate_by_mask(pmlmeext->default_supported_mcs_set, mcs_bitmap);
+							}
+#endif //CONFIG_80211N_HT							
+						}											
+					}
+                                        break;
+				case 0x1c: //enable/disable driver control AMPDU Density for peer sta's rx
+					{
+						if(arg == 0){
+							DBG_871X("disable driver ctrl ampdu density\n");						
+							padapter->driver_ampdu_spacing = 0xFF;
+						}
+						else if(arg == 1){
+							
+							DBG_871X("enable driver ctrl ampdu density = %d\n", extra_arg);	
+	
+							if(extra_arg > 0x07)
+								padapter->driver_ampdu_spacing = 0xFF;						
+							else
+								padapter->driver_ampdu_spacing = extra_arg;
+						}
 					}
-				}
 					break;
-#ifdef DBG_FIXED_CHAN
-				case 0x17:
+#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+				case 0x1e:
 					{
-						struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);						
-						printk("===>  Fixed channel to %d \n",extra_arg);
-						pmlmeext->fixed_chan = extra_arg;	
+						HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+						PDM_ODM_T pDM_Odm = &pHalData->odmpriv;
+						u8 chan = rtw_get_oper_ch(padapter);
+						DBG_871X("===========================================\n");
+						ODM_InbandNoise_Monitor(pDM_Odm,_TRUE,0x1e,100);
+						DBG_871X("channel(%d),noise_a = %d, noise_b = %d , noise_all:%d \n", 
+							chan,pDM_Odm->noise_level.noise[ODM_RF_PATH_A], 
+							pDM_Odm->noise_level.noise[ODM_RF_PATH_B],
+							pDM_Odm->noise_level.noise_all);
+						DBG_871X("===========================================\n");
 						
 					}
 					break;
 #endif
-				case 0x18:
-					{
-						printk("===>  Switch USB Mode %d \n",extra_arg);
-						rtw_hal_set_hwreg(padapter, HW_VAR_USB_MODE, (u8 *)&extra_arg);
-					}
-					break;
 				case 0x23:
 					{
 						DBG_871X("turn %s the bNotifyChannelChange Variable\n",(extra_arg==1)?"on":"off");
@@ -7215,9 +7959,9 @@ static int rtw_dbg_port(struct net_device *dev,
 			                    * dbg 0x7f250000 [gpio_num], Get gpio value, gpio_num:0~7
 			                    */                
                               
-			                    int value;
+			                    u8 value;
 			                    DBG_871X("Read GPIO Value  extra_arg = %d\n",extra_arg);
-			                    value = rtw_get_gpio(dev,extra_arg);
+			                    value = rtw_hal_get_gpio(padapter,extra_arg);
 			                    DBG_871X("Read GPIO Value = %d\n",value);                                        
 			                    break;
 		                    }
@@ -7230,7 +7974,7 @@ static int rtw_dbg_port(struct net_device *dev,
                                         
 			                    int value;
 			                    DBG_871X("Set GPIO Direction! arg = %d ,extra_arg=%d\n",arg ,extra_arg);
-			                    value = rtw_config_gpio(dev, arg, extra_arg);
+			                    value = rtw_hal_config_gpio(padapter, arg, extra_arg);
 			                    DBG_871X("Set GPIO Direction %s \n",(value==-1)?"Fail!!!":"Success");
 			                    break;
 					}
@@ -7243,11 +7987,19 @@ static int rtw_dbg_port(struct net_device *dev,
                                         
 						int value;
 						DBG_871X("Set GPIO Value! arg = %d ,extra_arg=%d\n",arg ,extra_arg);
-						value = rtw_set_gpio_output_value(dev,arg,extra_arg);
+						value = rtw_hal_set_gpio_output_value(padapter,arg,extra_arg);
 						DBG_871X("Set GPIO Value %s \n",(value==-1)?"Fail!!!":"Success");
 						break;
 					}
-#endif                            
+#endif          
+#ifdef DBG_CMD_QUEUE
+				case 0x28:
+					{
+						dump_cmd_id = extra_arg;
+						DBG_871X("dump_cmd_id:%d\n",dump_cmd_id);
+					}
+					break;
+#endif //DBG_CMD_QUEUE
 				case 0xaa:
 					{
 						if((extra_arg & 0x7F)> 0x3F) extra_arg = 0xFF;
@@ -7966,9 +8718,9 @@ static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
 	if(psta)
 	{
 		DBG_871X("rtw_add_sta(), free has been added psta=%p\n", psta);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 		rtw_free_stainfo(padapter,  psta);		
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 
 		psta = NULL;
 	}	
@@ -8784,6 +9536,74 @@ static int rtw_wx_set_priv(struct net_device *dev,
 	return ret;
 	
 }
+#ifdef CONFIG_WOWLAN
+static int rtw_wowlan_ctrl(struct net_device *dev,
+						struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+	_adapter *padapter =  (_adapter *)rtw_netdev_priv(dev);
+	struct wowlan_ioctl_param poidparam;
+	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct net_device *pnetdev = padapter->pnetdev;
+#ifdef CONFIG_CONCURRENT_MODE
+	struct net_device *pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;	
+#endif
+	struct sta_info	*psta = NULL;
+	int ret = 0;
+	u32 start_time = rtw_get_current_time();
+	poidparam.subcode = 0;
+
+	DBG_871X("+rtw_wowlan_ctrl: %s\n", extra);
+	
+	if(pwrctrlpriv->bSupportRemoteWakeup==_FALSE){
+		ret = -EPERM;
+		DBG_871X("+rtw_wowlan_ctrl: Device didn't support the remote wakeup!!\n");
+		goto _rtw_wowlan_ctrl_exit_free;
+	}
+
+	if (!check_fwstate(pmlmepriv, _FW_LINKED) && 
+			check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+#ifdef CONFIG_PNO_SUPPORT
+			pwrctrlpriv->wowlan_pno_enable = _TRUE;
+#else
+			DBG_871X("[%s] WARNING: Please Connect With AP First!!\n", __func__);
+			goto _rtw_wowlan_ctrl_exit_free;
+#endif //CONFIG_PNO_SUPPORT
+	}
+
+	if (_rtw_memcmp( extra, "enable", 6 )) {
+
+		padapter->registrypriv.mp_mode = 1;
+
+		pwrctrlpriv->wowlan_from_cmd = _TRUE;
+
+		rtw_suspend_common(padapter);
+
+	} else if (_rtw_memcmp( extra, "disable", 6 )) {
+
+		rtw_resume_common(padapter);
+
+		pwrctrlpriv->wowlan_from_cmd = _FALSE;
+
+#ifdef CONFIG_PNO_SUPPORT
+		pwrctrlpriv->wowlan_pno_enable = _FALSE;
+#endif //CONFIG_PNO_SUPPORT
+
+		padapter->registrypriv.mp_mode = 0;
+	} else {
+		DBG_871X("[%s] Invalid Parameter.\n", __func__);
+		goto _rtw_wowlan_ctrl_exit_free;
+	}
+	//mutex_lock(&ioctl_mutex);
+_rtw_wowlan_ctrl_exit_free:
+	DBG_871X("-rtw_wowlan_ctrl( subcode = %d)\n", poidparam.subcode);
+	DBG_871X_LEVEL(_drv_always_, "%s in %d ms\n", __func__,
+			rtw_get_passing_time_ms(start_time));
+_rtw_wowlan_ctrl_exit:
+	return ret;
+}
+#endif //CONFIG_WOWLAN
 
 #ifdef CONFIG_AP_WOWLAN
 static int rtw_ap_wowlan_ctrl(struct net_device *dev,
@@ -9572,7 +10392,7 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 	u8 *ShadowMapWiFi = NULL;
 	u8 *setrawdata = NULL;
 	char *pch, *ptmp, *token, *tmp[3]={0x00,0x00,0x00};
-	u16 addr=0, cnts=0, BTStatus=0 , max_available_size=0;
+	u16 addr=0xFF, cnts=0, BTStatus=0 , max_available_size=0;
 	int err;
 
 	wrqu = (struct iw_point*)wdata;
@@ -9827,7 +10647,20 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 		addr = EEPROM_MAC_ADDR_8723BU;
 		#endif
 		#endif // CONFIG_RTL8723B
-
+		
+		#if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
+		#ifdef CONFIG_SDIO_HCI
+				addr = EEPROM_MAC_ADDR_8821AS;
+		#endif
+		#ifdef CONFIG_PCI_HCI
+				addr = EEPROM_MAC_ADDR_8821AE;
+		#endif
+		#ifdef CONFIG_USB_HCI
+				addr = EEPROM_MAC_ADDR_8821AU;
+		#endif
+		
+		#endif // CONFIG_RTL8812A/CONFIG_RTL8821A
+		
 		cnts = strlen(tmp[1]);
 		if (cnts%2)
 		{
@@ -10601,6 +11434,8 @@ static int rtw_mp_read_rf(struct net_device *dev,
 				while( *pch != '\0' )
 				{
 					pnext = strpbrk(pch, " ");
+					if (!pnext)
+						break;
 					pnext++;
 					if ( *pnext != '\0' )
 					{
@@ -10627,29 +11462,21 @@ static int rtw_mp_start(struct net_device *dev,
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct hal_ops *pHalFunc = &padapter->HalFunc;
 
+	rtw_pm_set_ips(padapter,IPS_NONE);
+	LeaveAllPowerSaveMode(padapter);
+
 	if(padapter->registrypriv.mp_mode ==0)
 	{
-		#if (defined(CONFIG_RTL8723A) || defined(CONFIG_RTL8723B))
-		DBG_871X("_rtw_mp_xmit_priv for Download BT patch FW\n");
-		_rtw_mp_xmit_priv(&padapter->xmitpriv);
-		#endif
-	
-		padapter->registrypriv.mp_mode =1;
 
-		rtw_pm_set_ips(padapter,IPS_NONE);
-		LeaveAllPowerSaveMode(padapter);
-
-		MPT_InitializeAdapter(padapter, 1);
 #ifdef CONFIG_BT_COEXIST
-		rtw_btcoex_HaltNotify(padapter);
-		rtw_btcoex_SetManualControl(padapter, _TRUE);
 		pdmpriv->DMFlag &= ~DYNAMIC_FUNC_BT;
-		// Force to switch Antenna to WiFi
-		padapter->registrypriv.mp_mode=0;
+#endif		
+		pHalFunc->hal_deinit(padapter);
+		padapter->registrypriv.mp_mode =1;
 		pHalFunc->hal_init(padapter);
-		padapter->registrypriv.mp_mode=1;
-		//rtw_btcoex_HaltNotify(padapter);
-#endif
+
+		rtw_pm_set_ips(padapter,IPS_NONE);
+		LeaveAllPowerSaveMode(padapter);
 	}
 
 	if (padapter->registrypriv.mp_mode == 0)
@@ -10663,6 +11490,17 @@ static int rtw_mp_start(struct net_device *dev,
 	}
 	padapter->mppriv.bmac_filter = _FALSE;
 #ifdef CONFIG_RTL8723B
+#ifdef CONFIG_USB_HCI
+	rtw_write32(padapter, 0x765, 0x0000);
+	rtw_write32(padapter, 0x948, 0x0280);
+#else
+	rtw_write32(padapter, 0x765, 0x0000);
+	rtw_write32(padapter, 0x948, 0x0000);
+#endif	
+#ifdef CONFIG_FOR_RTL8723BS_VQ0
+	rtw_write32(padapter, 0x765, 0x0000);
+	rtw_write32(padapter, 0x948, 0x0280);
+#endif
 	rtw_write8(padapter, 0x66, 0x27); //Open BT uart Log
 	rtw_write8(padapter, 0xc50, 0x20); //for RX init Gain
 #endif	
@@ -10680,10 +11518,6 @@ static int rtw_mp_stop(struct net_device *dev,
 
 	if(padapter->registrypriv.mp_mode ==1)
 	{
-		#if (defined(CONFIG_RTL8723A) || defined(CONFIG_RTL8723B))
-		DBG_871X("_rtw_mp_xmit_priv reinit for normal mode\n");
-		_rtw_mp_xmit_priv(&padapter->xmitpriv);
-		#endif
 		
 		MPT_DeInitAdapter(padapter);
 		pHalFunc->hal_deinit(padapter);
@@ -10712,19 +11546,26 @@ static int rtw_mp_rate(struct net_device *dev,
 	if (copy_from_user(input, wrqu->pointer, wrqu->length))
 			return -EFAULT;
 			
-	rate = rtw_atoi(input);
-	sprintf( extra, "Set data rate to %d" , rate );
-		
+	rate = rtw_mpRateParseFunc(padapter,input);
+
+	if (rate ==0 && strcmp(input,"1M")!=0)
+	{
+	rate = rtw_atoi(input);	
 	if(rate <= 0x7f)
 		rate = wifirate2_ratetbl_inx( (u8)rate);	
-	else if (rate < 0x90)
-        //HT  rate 0x80(MCS0)        ~ 0x8F(MCS15)       128~143
+	else if (rate < 0xC8)
 		rate =(rate - 0x80 + MPT_RATE_MCS0);
-	else 
+		//HT  rate 0x80(MCS0)  ~ 0x8F(MCS15) ~ 0x9F(MCS31) 128~159 
+        //VHT1SS~2SS rate 0xA0 (VHT1SS_MCS0 44) ~ 0xB3 (VHT2SS_MCS9 #63) 160~179
+        //VHT rate 0xB4 (VHT3SS_MCS0 64) ~ 0xC7 (VHT2SS_MCS9 #83) 180~199 
+	//else
 		//VHT rate 0x90(VHT1SS_MCS0) ~ 0x99(VHT1SS_MCS9) 144~153
-		rate =(rate - MPT_RATE_VHT1SS_MCS0); 
+	//	rate =(rate - MPT_RATE_VHT1SS_MCS0); 
+	}
+	_rtw_memset(extra, 0, wrqu->length);
 
-	//DBG_871X("%s: rate=%d\n", __func__, rate);
+	sprintf( extra, "Set data rate to %s index %d" ,input,rate );
+	DBG_871X("%s: %s rate index=%d \n", __func__,input,rate);
 	
 	if (rate >= MPT_RATE_LAST )	
 	return -EINVAL;
@@ -10732,7 +11573,7 @@ static int rtw_mp_rate(struct net_device *dev,
 	padapter->mppriv.rateidx = rate;
 	Hal_SetDataRate(padapter);
 	
-	wrqu->length = strlen(extra) + 1;
+	wrqu->length = strlen(extra);
 	return 0;
 }
 
@@ -10752,14 +11593,13 @@ static int rtw_mp_channel(struct net_device *dev,
 	
 	channel = rtw_atoi(input);
 	//DBG_871X("%s: channel=%d\n", __func__, channel);
+	_rtw_memset(extra, 0, wrqu->length);
 	sprintf( extra, "Change channel %d to channel %d", padapter->mppriv.channel , channel );
 	padapter->mppriv.channel = channel;
-	pHalData->CurrentChannel = channel;
 	Hal_SetChannel(padapter);
+	pHalData->CurrentChannel = channel;
 
-	//cur_ch_offset =  rtw_get_offset_by_ch(padapter->mppriv.channel);
-	//set_channel_bwmode(padapter, padapter->mppriv.channel, cur_ch_offset, padapter->mppriv.bandwidth);
-	wrqu->length = strlen(extra) + 1;
+	wrqu->length = strlen(extra);
 	return 0;
 }
 
@@ -10786,10 +11626,10 @@ static int rtw_mp_bandwidth(struct net_device *dev,
 	DBG_871X("%s: bw=%d sg=%d \n", __func__, bandwidth , sg);
 	
 	padapter->mppriv.bandwidth = (u8)bandwidth;
-	pHalData->CurrentChannelBW = bandwidth;
 	padapter->mppriv.preamble = sg;
 	
 	SetBandwidth(padapter);
+	pHalData->CurrentChannelBW = bandwidth;
 	//cur_ch_offset =  rtw_get_offset_by_ch(padapter->mppriv.channel);
 	//set_channel_bwmode(padapter, padapter->mppriv.channel, cur_ch_offset, bandwidth);
 
@@ -10815,7 +11655,7 @@ static int rtw_mp_txpower_index(struct net_device *dev,
 	rfpath = rtw_atoi(input);
 	txpower_inx = mpt_ProQueryCalTxPower(padapter, rfpath);
 	sprintf(extra, " %d", txpower_inx);
-	wrqu->length = strlen(extra) + 1;
+	wrqu->length = strlen(extra);
 
 	return 0;
 }
@@ -10849,7 +11689,7 @@ static int rtw_mp_txpower(struct net_device *dev,
 	padapter->mppriv.bSetTxPower = 1;
 		Hal_SetAntennaPathPower(padapter);
 	}
-	wrqu->length = strlen(extra) + 1;
+	wrqu->length = strlen(extra);
 	return 0;
 }
 
@@ -10867,7 +11707,7 @@ static int rtw_mp_ant_tx(struct net_device *dev,
 			
 	//DBG_871X("%s: input=%s\n", __func__, input);	
 	
-	sprintf( extra, "switch Tx antenna to %s", input );
+	sprintf( extra, "switch Tx antenna to %s", input);
 	
 	for (i=0; i < strlen(input); i++)
 	{
@@ -10884,11 +11724,12 @@ static int rtw_mp_ant_tx(struct net_device *dev,
 	//antenna |= BIT(extra[i]-'a');
 	//DBG_871X("%s: antenna=0x%x\n", __func__, antenna);		
 	padapter->mppriv.antenna_tx = antenna;
+	padapter->mppriv.antenna_rx = antenna;
 	//DBG_871X("%s:mppriv.antenna_rx=%d\n", __func__, padapter->mppriv.antenna_tx);
 	
 	Hal_SetAntenna(padapter);
 
-	wrqu->length = strlen(extra) + 1;
+	wrqu->length = strlen(extra);
 	return 0;
 }
 
@@ -10924,6 +11765,7 @@ static int rtw_mp_ant_rx(struct net_device *dev,
 	}
 	
 	//DBG_871X("%s: antenna=0x%x\n", __func__, antenna);		
+	padapter->mppriv.antenna_tx = antenna;
 	padapter->mppriv.antenna_rx = antenna;
 	//DBG_871X("%s:mppriv.antenna_rx=%d\n", __func__, padapter->mppriv.antenna_rx);
 	Hal_SetAntenna(padapter);
@@ -11047,8 +11889,8 @@ static int rtw_mp_ctx(struct net_device *dev,
 			//DBG_871X("%s: cotuTx %d\n", __func__, bStartTest);
 			if (bStartTest != 0){
 				sprintf( extra, "Start continuous DA=ffffffffffff len=1500 \n infinite=yes.");
-           		 }
-           	Hal_SetContinuousTx(padapter, (u8)bStartTest);
+			 }
+			Hal_SetContinuousTx(padapter, (u8)bStartTest);
 			break;
 
 		case MP_CARRIER_SUPPRISSION_TX:
@@ -11159,7 +12001,7 @@ static int rtw_mp_arx(struct net_device *dev,
 	u32		mac_cck_err=0, mac_ofdm_err=0, mac_ht_err=0, mac_vht_err=0;
 	u8 		input[wrqu->length];
 	char *pch, *ptmp, *token, *tmp[2]={0x00,0x00};
-	u32 i=0,ii=0,jj=0,kk=0,cnts=0;
+	u32 i=0,ii=0,jj=0,kk=0,cnts=0,bmon=0;
 	PADAPTER padapter = rtw_netdev_priv(dev);
 	struct mp_priv *pmppriv = &padapter->mppriv;
 
@@ -11175,7 +12017,7 @@ static int rtw_mp_arx(struct net_device *dev,
 	bSetBssid = (strncmp(input, "setbssid=", 8)==0)?1:0; // strncmp TRUE is 0
 	//bfilter_init = (strncmp(input, "filter_init",11)==0)?1:0;
 	bmac_filter = (strncmp(input, "accept_mac",10)==0)?1:0;
-
+	bmon = (strncmp(input, "mon=",4)==0)?1:0;
 
 	if(bSetBssid==1){
 		pch = input;
@@ -11250,7 +12092,7 @@ static int rtw_mp_arx(struct net_device *dev,
 		    	cckcrc     = PHY_QueryBBReg(padapter, 0xF04, 0x3FFF0000); // [29:16]						
 		    	ofdmcrc    = PHY_QueryBBReg(padapter, 0xF14, 0x3FFF0000); // [29:16]
 		    	htcrc      = PHY_QueryBBReg(padapter, 0xF10, 0x3FFF0000); // [29:16]		
-		    	vht_err     = PHY_QueryBBReg(padapter, 0xF0C, 0x3FFF0000); // [29:16]		
+		    	vht_err     = PHY_QueryBBReg(padapter, 0xF0C, 0x3FFF0000); // [29:16]	
 		    	
 		    	CCK_FA = PHY_QueryBBReg(padapter, 0xa5c, bMaskLWord);
 		    	OFDM_FA = PHY_QueryBBReg(padapter, 0xF48, bMaskLWord);
@@ -11259,7 +12101,7 @@ static int rtw_mp_arx(struct net_device *dev,
 		{
 		    	cckok      = PHY_QueryBBReg(padapter, 0xF88, bMaskDWord);		
 		    	ofdmok     = PHY_QueryBBReg(padapter, 0xF94, bMaskLWord);		
-			htok       = PHY_QueryBBReg(padapter, 0xF90, bMaskLWord);
+			    htok       = PHY_QueryBBReg(padapter, 0xF90, bMaskLWord);
 	        	vht_ok      = 0;
 		    
 		    	cckcrc     = PHY_QueryBBReg(padapter, 0xF84, bMaskDWord);						
@@ -11304,9 +12146,22 @@ static int rtw_mp_arx(struct net_device *dev,
 		sprintf( extra, "Mac Received packet OK: %d , CRC error: %d , Drop Packets: %d\n",
 				mac_cck_ok+mac_ofdm_ok+mac_ht_ok+mac_vht_ok,mac_cck_err+mac_ofdm_err+mac_ht_err+mac_vht_err,DropPacket);			
 	}
-	wrqu->length = strlen(extra) + 1;
 
+	if( bmon==1 ) {	
+		sscanf(input, "mon=%d", &bmon);
+		
+		if(bmon==1)
+		{
+			pmppriv->rx_bindicatePkt= _TRUE;
+			sprintf( extra, "Indicating Receive Packet to network start\n");
+		}else {
+			pmppriv->rx_bindicatePkt= _FALSE;
+			sprintf( extra, "Indicating Receive Packet to network Stop\n");
+		}	
+	}
 	
+	wrqu->length = strlen(extra) + 1;
+
 	return 0;
 }
 
@@ -11360,11 +12215,11 @@ static int rtw_mp_pwrtrk(struct net_device *dev,
 		}
 		else if (sscanf(input, "ther=%d", &thermal)) {
 			pHalData->TxPowerTrackControl = _TRUE;
-				ret = Hal_SetThermalMeter(padapter, (u8)thermal);
-				if (ret == _FAIL) return -EPERM;
+			ret = Hal_SetThermalMeter(padapter, (u8)thermal);
+			if (ret == _FAIL) return -EPERM;
 				sprintf(extra, "mp tx power tracking start,target value=%d ok ",thermal);
-		}else	{
-				return -EINVAL;
+		}else{
+			return -EINVAL;
 		}
 	}
 
@@ -11398,7 +12253,7 @@ static int rtw_mp_thermal(struct net_device *dev,
 			struct iw_point *wrqu, char *extra)
 {
 	u8 val;
-	u16 bwrite=1;
+	int bwrite=1;
 	
 	#ifdef CONFIG_RTL8192C
 			u16 addr=EEPROM_THERMAL_METER_92C;
@@ -11639,7 +12494,7 @@ static int rtw_mp_PwrCtlDM(struct net_device *dev,
 {
 	PADAPTER padapter = rtw_netdev_priv(dev);
 	u8		input[wrqu->length];
-	u8		bstart=1;
+	int		bstart=1;
 	
 	if (copy_from_user(input, wrqu->pointer, wrqu->length))
 			return -EFAULT;
@@ -11657,6 +12512,23 @@ static int rtw_mp_PwrCtlDM(struct net_device *dev,
 	return 0;
 }
 
+static int rtw_mp_getver(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
+{
+	PADAPTER padapter = rtw_netdev_priv(dev);
+	struct mp_priv *pmp_priv;
+	
+	pmp_priv = &padapter->mppriv;
+	
+	if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length))
+			return -EFAULT;
+
+	sprintf(extra, "rtwpriv=%d\n",RTWPRIV_VER_INFO);
+	wrqu->data.length = strlen(extra);
+	return 0;
+}
+
 #if (defined(CONFIG_RTL8723A) || defined(CONFIG_RTL8723B))
 /* update Tx AGC offset */
 static int rtw_mp_SetBT(struct net_device *dev,
@@ -11764,12 +12636,6 @@ static int rtw_mp_SetBT(struct net_device *dev,
 	}
 	if ( strncmp(extra, "dlfw", 4) == 0)
 	{
-		#ifdef CONFIG_BT_COEXIST
-		rtw_btcoex_HaltNotify(padapter);
-		//DBG_871X("SetBT bt1ant !\n");
-		//hal_btcoex1ant_SetAntPath(padapter);
-		rtw_btcoex_SetManualControl(padapter, _TRUE);
-		#endif
 		pHalData->LastHMEBoxNum=0;
 		padapter->bBTFWReady = _FALSE;
 		rtw_write8(padapter, 0xa3, 0x05);
@@ -11817,6 +12683,12 @@ static int rtw_mp_SetBT(struct net_device *dev,
 #endif
 		DBG_871X("Wait for FirmwareDownloadBT fw boot!\n");
 		rtw_msleep_os(1000);
+#ifdef CONFIG_BT_COEXIST
+		rtw_btcoex_HaltNotify(padapter);
+		DBG_871X("SetBT btcoex HaltNotify !\n");
+		//hal_btcoex1ant_SetAntPath(padapter);
+		rtw_btcoex_SetManualControl(padapter, _TRUE);
+#endif		
 		_rtw_memset(extra,'\0', wrqu->data.length);
 		BtReq.opCodeVer = 1;
 		BtReq.OpCode = 0;
@@ -11835,7 +12707,7 @@ static int rtw_mp_SetBT(struct net_device *dev,
 			else
 			{
 				#ifdef CONFIG_BT_COEXIST
-				rtw_btcoex_SwitchGntBt(padapter);
+				rtw_btcoex_SwitchBtTRxMask(padapter);
 				#endif
 				rtw_msleep_os(200);
 				sprintf(extra, "download FW OK.\n");
@@ -11846,9 +12718,15 @@ static int rtw_mp_SetBT(struct net_device *dev,
 
 	if ( strncmp(extra, "down", 4) == 0){
 		DBG_871X("SetBT down for to hal_init !\n");
-		mp_stop_test(padapter);
+#ifdef CONFIG_BT_COEXIST		
+		rtw_btcoex_SetManualControl(padapter, _FALSE);
+		rtw_btcoex_Initialize(padapter);
+#endif		
+		pHalFunc->read_adapter_info(padapter);
+		pHalFunc->hal_deinit(padapter);
 		pHalFunc->hal_init(padapter);
-		mp_start_test(padapter);
+		rtw_pm_set_ips(padapter,IPS_NONE);
+		LeaveAllPowerSaveMode(padapter);
 		MPT_PwrCtlDM(padapter,0);
 		rtw_write32(padapter, 0xcc, (rtw_read32(padapter, 0xcc)| 0x00000004));
 		rtw_write32(padapter, 0x6b, (rtw_read32(padapter, 0x6b)& 0xFFFFFFEF));
@@ -11874,7 +12752,7 @@ static int rtw_mp_SetBT(struct net_device *dev,
 	if ( strncmp(extra, "h2c", 3) == 0){
 			DBG_871X("SetBT h2c !\n");
 			padapter->bBTFWReady = _TRUE;
-			FillH2CCmd(padapter, 0x63, 1, u1H2CBtMpOperParm);
+			rtw_hal_fill_h2c_cmd(padapter, 0x63, 1, u1H2CBtMpOperParm);
 			goto exit;
 		}
 	if ( strncmp(extra, "2ant", 4) == 0){
@@ -12094,6 +12972,12 @@ static int rtw_mp_set(struct net_device *dev,
 			DBG_871X("set case MP_DISABLE_BT_COEXIST \n");
 			rtw_mp_disable_bt_coexist(dev, info, wdata, extra);
 		break;
+#ifdef CONFIG_WOWLAN
+	case MP_WOW_ENABLE:
+			DBG_871X("set case MP_WOW_ENABLE: %s \n", extra);
+			rtw_wowlan_ctrl(dev, info, wdata, extra);
+	break;
+#endif
 #ifdef CONFIG_AP_WOWLAN
 	case MP_AP_WOW_ENABLE:
 			DBG_871X("set case MP_AP_WOW_ENABLE: %s \n", extra);
@@ -12240,7 +13124,9 @@ static int rtw_mp_get(struct net_device *dev,
 			DBG_871X("mp_get MP_GET_TXPOWER_INX \n");
 			rtw_mp_txpower_index(dev,info,wrqu,extra);
 		break;
-
+	case MP_GETVER:
+			DBG_871X("mp_get MP_GETVER \n");
+			rtw_mp_getver(dev,info,wdata,extra);
 #if defined(CONFIG_RTL8723A) || defined(CONFIG_RTL8723B)
 	case MP_SetBT:		
 			DBG_871X("set MP_SetBT \n");
@@ -13040,6 +13926,14 @@ extern void rtl8723b_cal_txdesc_chksum(struct tx_desc *ptxdesc);
 extern void rtl8723b_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf);
 #define fill_default_txdesc rtl8723b_fill_default_txdesc
 #endif // CONFIG_RTL8723B
+#if defined(CONFIG_RTL8192E)
+extern void rtl8192e_cal_txdesc_chksum(struct tx_desc *ptxdesc);
+#define cal_txdesc_chksum rtl8192e_cal_txdesc_chksum
+#ifdef CONFIG_SDIO_HCI || defined(CONFIG_GSPI_HCI)
+extern void rtl8192es_fill_default_txdesc(struct xmit_frame *pxmitframe, u8 *pbuf);
+#define fill_default_txdesc rtl8192es_fill_default_txdesc
+#endif // CONFIG_SDIO_HCI
+#endif //CONFIG_RTL8192E
 
 static s32 initLoopback(PADAPTER padapter)
 {
@@ -13666,13 +14560,11 @@ static int rtw_test(
 	{
 		rtw_btcoex_SetManualControl(padapter, _FALSE);
 	}
-
-	if (strcmp(pch, "btoff") == 0)
+	else if (strcmp(pch, "btoff") == 0)
 	{
 		rtw_btcoex_SetManualControl(padapter, _TRUE);
 	}
-
-	if (strcmp(pch, "h2c") == 0)
+	else if (strcmp(pch, "h2c") == 0)
 	{
 		u8 param[8];
 		u8 count = 0;
@@ -13709,6 +14601,20 @@ static int rtw_test(
 
 		wrqu->data.length = strlen(extra) + 1;
 	}
+	else if (strcmp(pch, "ba_rxbuf_sz") == 0)
+	{
+		u8 ba_rxbuf_bz;
+
+		pch = strsep(&ptmp, delim);
+		if ((pch != NULL) && (strlen(pch) != 0)) {
+			sscanf(pch, "%hhu", &ba_rxbuf_bz);
+			DBG_871X("%s set ba_rxbuf_bz as %u\n", __func__, ba_rxbuf_bz);
+			padapter->fix_ba_rxbuf_bz = ba_rxbuf_bz;
+			rtw_btcoex_RejectApAggregatedPacket(padapter, _TRUE);
+			rtw_btcoex_RejectApAggregatedPacket(padapter, _FALSE);
+		}
+	}
+
 #endif // CONFIG_BT_COEXIST
 
 	rtw_mfree(pbuf, len);
@@ -13775,64 +14681,6 @@ static iw_handler rtw_handlers[] =
 	NULL,					/*---hole---*/
 }; 
 
-#if 0
-//defined(CONFIG_MP_INCLUDED) && defined(CONFIG_MP_IWPRIV_SUPPORT)
-static const struct iw_priv_args rtw_private_args[] =
-{	
-	{ SIOCIWFIRSTPRIV + 0x00, IW_PRIV_TYPE_CHAR | 1024, 0 , ""},  //set 
-	{ SIOCIWFIRSTPRIV + 0x01, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , ""},//get
-/* --- sub-ioctls definitions --- */   
-		{ MP_START , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_start" }, //set
-		{ MP_PHYPARA, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_phypara" },//get
-		{ MP_STOP , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_stop" }, //set
-		{ MP_CHANNEL , IW_PRIV_TYPE_CHAR | 1024 , IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_channel" },//get
-		{ MP_BANDWIDTH , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_bandwidth"}, //set
-		{ MP_RATE , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_rate" },//get
-		{ MP_RESET_STATS , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_reset_stats"},
-		{ MP_QUERY , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , "mp_query"}, //get
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ READ_REG , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "read_reg" },
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_RATE , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_rate" },
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ READ_RF , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "read_rf" },
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_PSD , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_psd"}, 
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_DUMP, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_dump" },
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_TXPOWER , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_txpower"},
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_ANT_TX , IW_PRIV_TYPE_CHAR | 1024,  IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ant_tx"},
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_ANT_RX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ant_rx"},
-		{ WRITE_REG, IW_PRIV_TYPE_CHAR | 1024, 0,"write_reg"},//set
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "NULL" },
-		{ WRITE_RF, IW_PRIV_TYPE_CHAR | 1024, 0,"write_rf"},//set
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "NULL" },
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_CTX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ctx"},
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_ARX , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_arx"},
-		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_THER , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_ther"},
-		{ EFUSE_SET, IW_PRIV_TYPE_CHAR | 1024, 0, "efuse_set" },
-		{ EFUSE_GET, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_get" },
-		{ MP_PWRTRK , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_pwrtrk"},
-		{ MP_QueryDrvStats, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_drvquery" },
-		{ MP_IOCTL, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_ioctl"}, // mp_ioctl	
-		{ MP_SetRFPathSwh, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_setrfpath" },
-#ifdef CONFIG_RTL8723A
-		{ MP_SetBT, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_setbt" },
-#endif
-	{ SIOCIWFIRSTPRIV + 0x02, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , "test"},//set
-};
-static iw_handler rtw_private_handler[] = 
-{
-	rtw_mp_set,
-	rtw_mp_get,
-};
-#else // not inlucde MP
 
 static const struct iw_priv_args rtw_private_args[] = {
 	{
@@ -13984,6 +14832,7 @@ static const struct iw_priv_args rtw_private_args[] = {
 		{ MP_SetRFPathSwh, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_setrfpath" },		
 		{ MP_PwrCtlDM, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_pwrctldm" },		
 		{ MP_GET_TXPOWER_INX, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_get_txpower" },
+		{ MP_GETVER, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_priv_ver" },
 		
 #if defined(CONFIG_RTL8723A) || defined(CONFIG_RTL8723B)
 		{ MP_SetBT, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_setbt" },
@@ -13991,8 +14840,11 @@ static const struct iw_priv_args rtw_private_args[] = {
 #endif
 		{ CTA_TEST, IW_PRIV_TYPE_CHAR | 1024, 0, "cta_test"},
 #endif
+#ifdef CONFIG_WOWLAN
+		{ MP_WOW_ENABLE , IW_PRIV_TYPE_CHAR | 1024, 0, "wow_mode" }, //set 
+#endif
 #ifdef CONFIG_AP_WOWLAN
-		{ MP_AP_WOW_ENABLE , IW_PRIV_TYPE_CHAR | 1024, 0, "ap_wow_enable" }, //set 
+		{ MP_AP_WOW_ENABLE , IW_PRIV_TYPE_CHAR | 1024, 0, "ap_wow_mode" }, //set 
 #endif
 };
 
@@ -14055,7 +14907,6 @@ static iw_handler rtw_private_handler[] =
 #endif // CONFIG_INTEL_WIDI
 };
 
-#endif // #if defined(CONFIG_MP_INCLUDED) && defined(CONFIG_MP_IWPRIV_SUPPORT)
 
 #if WIRELESS_EXT >= 17	
 static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
@@ -14077,11 +14928,41 @@ static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
 		#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength); 
 		#else
+		#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+		{
+			/* Do signal scale mapping when using percentage as the unit of signal strength, since the scale mapping is skipped in odm */
+			
+			HAL_DATA_TYPE *pHal = GET_HAL_DATA(padapter);
+			
+			tmp_level = (u8)odm_SignalScaleMapping(&pHal->odmpriv, padapter->recvpriv.signal_strength);
+		}
+		#else
 		tmp_level = padapter->recvpriv.signal_strength;
 		#endif
+		#endif
 		
 		tmp_qual = padapter->recvpriv.signal_qual;
-		tmp_noise =padapter->recvpriv.noise;		
+#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		if(rtw_linked_check(padapter)){			
+			struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+			struct noise_info info;
+			info.bPauseDIG = _TRUE;
+			info.IGIValue = 0x1e;
+			info.max_time = 100;//ms		
+			info.chan = pmlmeext->cur_channel ;//rtw_get_oper_ch(padapter);
+			rtw_ps_deny(padapter, PS_DENY_IOCTL);	
+			LeaveAllPowerSaveModeDirect(padapter);	
+
+			rtw_hal_set_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&info, _FALSE);	
+			//ODM_InbandNoise_Monitor(podmpriv,_TRUE,0x20,100);
+			rtw_ps_deny_cancel(padapter, PS_DENY_IOCTL);
+			rtw_hal_get_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&(info.chan), &(padapter->recvpriv.noise));	
+			#ifdef DBG_NOISE_MONITOR
+			DBG_871X("chan:%d,noise_level:%d\n",info.chan,padapter->recvpriv.noise);
+			#endif
+		}
+#endif		
+		tmp_noise = padapter->recvpriv.noise;
 		//DBG_871X("level:%d, qual:%d, noise:%d, rssi (%d)\n", tmp_level, tmp_qual, tmp_noise,padapter->recvpriv.rssi);
 
 		piwstats->qual.level = tmp_level;
@@ -14150,7 +15031,8 @@ static int get_priv_size(__u16 args)
 }
 // copy from net/wireless/wext.c end
 
-static int rtw_ioctl_wext_private(struct net_device *dev, union iwreq_data *wrq_data)
+
+static int _rtw_ioctl_wext_private(struct net_device *dev, union iwreq_data *wrq_data)
 {
 	int err = 0;
 	u8 *input = NULL;
@@ -14180,7 +15062,6 @@ static int rtw_ioctl_wext_private(struct net_device *dev, union iwreq_data *wrq_
 
 	union iwreq_data wdata;
 
-
 	_rtw_memcpy(&wdata, wrq_data, sizeof(wdata));
 
 	input_len = wdata.data.length;
@@ -14193,17 +15074,16 @@ static int rtw_ioctl_wext_private(struct net_device *dev, union iwreq_data *wrq_
 	}
 	ptr = input;
 	len = input_len;
-
 	sscanf(ptr, "%16s", cmdname);
 	cmdlen = strlen(cmdname);
-	DBG_8192C("%s: cmd=%s\n", __func__, cmdname);
+	DBG_871X("%s: cmd=%s\n", __func__, cmdname);
 
 	// skip command string
 	if (cmdlen > 0)
 		cmdlen += 1; // skip one space
 	ptr += cmdlen;
 	len -= cmdlen;
-	DBG_8192C("%s: parameters=%s\n", __func__, ptr);
+	DBG_871X("%s: parameters=%s\n", __func__, ptr);
 
 	priv = rtw_private_handler;
 	priv_args = rtw_private_args;
@@ -14489,6 +15369,61 @@ static int rtw_ioctl_wext_private(struct net_device *dev, union iwreq_data *wrq_
 	return err;
 }
 
+#ifdef CONFIG_COMPAT
+static int rtw_ioctl_compat_wext_private(struct net_device *dev, struct ifreq *rq)
+{
+	struct compat_iw_point iwp_compat;
+	union iwreq_data wrq_data;
+	int err = 0;
+	DBG_871X("%s:...\n", __func__);
+	if (copy_from_user(&iwp_compat, rq->ifr_ifru.ifru_data, sizeof(struct compat_iw_point)))
+			return -EFAULT;
+	
+	wrq_data.data.pointer = compat_ptr(iwp_compat.pointer);
+	wrq_data.data.length = iwp_compat.length;
+	wrq_data.data.flags = iwp_compat.flags;
+
+	err = _rtw_ioctl_wext_private(dev, &wrq_data);
+
+	iwp_compat.pointer = ptr_to_compat(wrq_data.data.pointer);
+	iwp_compat.length = wrq_data.data.length;
+	iwp_compat.flags = wrq_data.data.flags;
+	if (copy_to_user(rq->ifr_ifru.ifru_data, &iwp_compat, sizeof(struct compat_iw_point)))
+			return -EFAULT;
+
+	return err;
+}
+#endif // CONFIG_COMPAT
+
+static int rtw_ioctl_standard_wext_private(struct net_device *dev, struct ifreq *rq)
+{
+	struct iw_point *iwp;
+	struct ifreq ifrq;
+	union iwreq_data wrq_data;
+	int err = 0;
+	iwp = &wrq_data.data;
+	DBG_871X("%s:...\n", __func__);
+	if (copy_from_user(iwp, rq->ifr_ifru.ifru_data, sizeof(struct iw_point)))
+		return -EFAULT;
+
+	err = _rtw_ioctl_wext_private(dev, &wrq_data);
+
+	if (copy_to_user(rq->ifr_ifru.ifru_data, iwp, sizeof(struct iw_point)))
+		return -EFAULT;
+
+	return err;
+}
+ 
+static int rtw_ioctl_wext_private(struct net_device *dev, struct ifreq *rq)
+{
+#ifdef CONFIG_COMPAT
+	if(is_compat_task())
+		return rtw_ioctl_compat_wext_private( dev, rq );
+	else
+#endif // CONFIG_COMPAT
+		return rtw_ioctl_standard_wext_private( dev, rq );
+}
+
 int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct iwreq *wrq = (struct iwreq *)rq;
@@ -14509,8 +15444,8 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 			break;
 #endif
 #endif // CONFIG_AP_MODE
-		case SIOCDEVPRIVATE:
-			ret = rtw_ioctl_wext_private(dev, &wrq->u);
+		case SIOCDEVPRIVATE:				
+			 ret = rtw_ioctl_wext_private(dev, rq);
 			break;
 		case (SIOCDEVPRIVATE+1):
 			ret = rtw_android_priv_cmd(dev, rq, cmd);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/mlme_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/mlme_linux.c
index 78ea10176705..ba0ab12f46e6 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/mlme_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/mlme_linux.c
@@ -285,39 +285,41 @@ _func_enter_;
 	if(authmode==_WPA_IE_ID_)
 	{
 		RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("rtw_report_sec_ie, authmode=%d\n", authmode));
-		
-		buff = rtw_malloc(IW_CUSTOM_MAX);
-		
-		_rtw_memset(buff,0,IW_CUSTOM_MAX);
-		
-		p=buff;
-		
+
+		buff = rtw_zmalloc(IW_CUSTOM_MAX);
+		if (NULL == buff) {
+			DBG_871X(FUNC_ADPT_FMT ": alloc memory FAIL!!\n",
+				FUNC_ADPT_ARG(adapter));
+			return;
+		}
+		p = buff;
+
 		p+=sprintf(p,"ASSOCINFO(ReqIEs=");
 
 		len = sec_ie[1]+2;
-		len =  (len < IW_CUSTOM_MAX) ? len:IW_CUSTOM_MAX;
+		len = (len < IW_CUSTOM_MAX) ? len:IW_CUSTOM_MAX;
 			
 		for(i=0;i<len;i++){
 			p+=sprintf(p,"%02x",sec_ie[i]);
 		}
 
 		p+=sprintf(p,")");
-		
+
 		_rtw_memset(&wrqu,0,sizeof(wrqu));
-		
+
 		wrqu.data.length=p-buff;
-		
+
 		wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
-		
+
 #ifndef CONFIG_IOCTL_CFG80211
 		wireless_send_event(adapter->pnetdev,IWEVCUSTOM,&wrqu,buff);
 #endif
 
-		if(buff)
-		    rtw_mfree(buff, IW_CUSTOM_MAX);
-		
+		rtw_mfree(buff, IW_CUSTOM_MAX);
 	}
 
+exit:
+
 _func_exit_;
 
 }
@@ -462,11 +464,7 @@ static int mgnt_netdev_open(struct net_device *pnetdev)
 
 	init_usb_anchor(&phostapdpriv->anchored);
 	
-	if(!rtw_netif_queue_stopped(pnetdev))
-		rtw_netif_start_queue(pnetdev);
-	else
-		rtw_netif_wake_queue(pnetdev);
-
+	rtw_netif_wake_queue(pnetdev);
 
 	netif_carrier_on(pnetdev);
 		
@@ -484,9 +482,8 @@ static int mgnt_netdev_close(struct net_device *pnetdev)
 
 	netif_carrier_off(pnetdev);
 
-	if (!rtw_netif_queue_stopped(pnetdev))
-		rtw_netif_stop_queue(pnetdev);
-	
+	rtw_netif_stop_queue(pnetdev);
+
 	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x3f3f);
 	
 	return 0;	
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/os_intfs.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/os_intfs.c
index 0cf3e58c30db..0004e9a77992 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/os_intfs.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/os_intfs.c
@@ -54,7 +54,11 @@ int rtw_adhoc_tx_pwr = 1;
 int rtw_soft_ap = 0;
 //int smart_ps = 1;
 #ifdef CONFIG_POWER_SAVING
-int rtw_power_mgnt = 1;
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+int rtw_power_mgnt = PS_MODE_MAX;
+#else
+int rtw_power_mgnt = PS_MODE_MIN;
+#endif 
 #ifdef CONFIG_IPS_LEVEL_2
 int rtw_ips_mode = IPS_LEVEL_2;
 #else
@@ -107,9 +111,9 @@ int rtw_ht_enable = 1;
 // 0x21 means enable 2.4G 40MHz & 5G 80MHz
 int rtw_bw_mode = 0x21;
 int rtw_cbw40_enable = 3; // 0 :diable, bit(0): enable 2.4g, bit(1): enable 5g
-int rtw_ampdu_enable = 1;//for enable tx_ampdu
+int rtw_ampdu_enable = 1;//for enable tx_ampdu ,// 0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec)
 int rtw_rx_stbc = 1;// 0: disable, bit(0):enable 2.4g, bit(1):enable 5g, default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ
-int rtw_ampdu_amsdu = 0;// 0: disabled, 1:enabled, 2:auto
+int rtw_ampdu_amsdu = 0;// 0: disabled, 1:enabled, 2:auto . There is an IOT issu with DLINK DIR-629 when the flag turn on
 // Short GI support Bit Map
 // BIT0 - 20MHz, 0: non-support, 1: support
 // BIT1 - 40MHz, 0: non-support, 1: support
@@ -140,6 +144,9 @@ int rtw_wifi_spec = 1;//for wifi test
 #else
 int rtw_wifi_spec = 0;
 #endif
+
+int rtw_special_rf_path = 0; //0: 2T2R ,1: only turn on path A 1T1R
+
 int rtw_channel_plan = RT_CHANNEL_DOMAIN_MAX;
 
 #ifdef CONFIG_BT_COEXIST
@@ -210,7 +217,11 @@ char* ifname = "wlan%d";
 module_param(ifname, charp, 0644);
 MODULE_PARM_DESC(ifname, "The default name to allocate for first interface");
 
-char* if2name = "p2p0";
+#ifdef CONFIG_PLATFORM_ANDROID
+char* if2name = "p2p%d";
+#else //CONFIG_PLATFORM_ANDROID
+char* if2name = "wlan%d";
+#endif //CONFIG_PLATFORM_ANDROID
 module_param(if2name, charp, 0644);
 MODULE_PARM_DESC(if2name, "The default name to allocate for second interface");
 
@@ -223,6 +234,7 @@ module_param(rtw_ext_iface_num, int, 0644);
 
 module_param(rtw_initmac, charp, 0644);
 module_param(rtw_channel_plan, int, 0644);
+module_param(rtw_special_rf_path, int, 0644);
 module_param(rtw_chip_version, int, 0644);
 module_param(rtw_rfintfs, int, 0644);
 module_param(rtw_lbkmode, int, 0644);
@@ -316,6 +328,42 @@ uint rtw_notch_filter = RTW_NOTCH_FILTER;
 module_param(rtw_notch_filter, uint, 0644);
 MODULE_PARM_DESC(rtw_notch_filter, "0:Disable, 1:Enable, 2:Enable only for P2P");
 
+uint rtw_hiq_filter = CONFIG_RTW_HIQ_FILTER;
+module_param(rtw_hiq_filter, uint, 0644);
+MODULE_PARM_DESC(rtw_hiq_filter, "0:allow all, 1:allow special, 2:deny all");
+
+uint rtw_adaptivity_en = CONFIG_RTW_ADAPTIVITY_EN;
+module_param(rtw_adaptivity_en, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_en, "0:disable, 1:enable, 2:auto");
+
+uint rtw_adaptivity_mode = CONFIG_RTW_ADAPTIVITY_MODE;
+module_param(rtw_adaptivity_mode, uint, 0644);
+MODULE_PARM_DESC(rtw_adaptivity_mode, "0:normal, 1:carrier sense");
+
+uint rtw_nhm_en = CONFIG_RTW_NHM_EN;
+module_param(rtw_nhm_en, uint, 0644);
+MODULE_PARM_DESC(rtw_nhm_en, "0:disable, 1:enable");
+
+uint rtw_amplifier_type_2g = CONFIG_RTW_AMPLIFIER_TYPE_2G;
+module_param(rtw_amplifier_type_2g, uint, 0644);
+MODULE_PARM_DESC(rtw_amplifier_type_2g, "BIT3:2G ext-PA, BIT4:2G ext-LNA");
+
+uint rtw_amplifier_type_5g = CONFIG_RTW_AMPLIFIER_TYPE_5G;
+module_param(rtw_amplifier_type_5g, uint, 0644);
+MODULE_PARM_DESC(rtw_amplifier_type_5g, "BIT6:5G ext-PA, BIT7:5G ext-LNA");
+
+uint rtw_RFE_type = 64;
+module_param(rtw_RFE_type, uint, 0644);
+MODULE_PARM_DESC(rtw_RFE_type, "default init value:64");
+
+uint rtw_TxBBSwing_2G = 0xFF;
+module_param(rtw_TxBBSwing_2G, uint, 0644);
+MODULE_PARM_DESC(rtw_TxBBSwing_2G, "default init value:0xFF");
+
+uint rtw_TxBBSwing_5G = 0xFF;
+module_param(rtw_TxBBSwing_5G, uint, 0644);
+MODULE_PARM_DESC(rtw_TxBBSwing_5G, "default init value:0xFF");
+
 #if defined(CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY) //eFuse: Regulatory selection=1
 int rtw_tx_pwr_lmt_enable = 1;
 int rtw_tx_pwr_by_rate = 1;
@@ -323,8 +371,13 @@ int rtw_tx_pwr_by_rate = 1;
 int rtw_tx_pwr_lmt_enable = 0;
 int rtw_tx_pwr_by_rate = 1;
 #else //eFuse: Regulatory selection=2
+#ifdef CONFIG_PCI_HCI
+int rtw_tx_pwr_lmt_enable = 2; // 2- Depend on efuse
+int rtw_tx_pwr_by_rate = 2;// 2- Depend on efuse
+#else // USB & SDIO
 int rtw_tx_pwr_lmt_enable = 0;
 int rtw_tx_pwr_by_rate = 0;
+#endif 
 #endif
 
 module_param(rtw_tx_pwr_lmt_enable, int, 0644);
@@ -334,7 +387,7 @@ module_param(rtw_tx_pwr_by_rate, int, 0644);
 MODULE_PARM_DESC(rtw_tx_pwr_by_rate,"0:Disable, 1:Enable, 2: Depend on efuse");
 
 #ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
-char *rtw_phy_file_path = "";
+char *rtw_phy_file_path = REALTEK_CONFIG_PATH;
 module_param(rtw_phy_file_path, charp, 0644);
 MODULE_PARM_DESC(rtw_phy_file_path, "The path of phy parameter");
 // PHY FILE Bit Map
@@ -357,6 +410,9 @@ static uint loadparam(PADAPTER padapter, _nic_hdl pnetdev);
 int _netdev_open(struct net_device *pnetdev);
 int netdev_open (struct net_device *pnetdev);
 static int netdev_close (struct net_device *pnetdev);
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+extern int rtw_sdio_set_power(int on);
+#endif //CONFIG_PLATFORM_INTEL_BYT
 
 //#ifdef RTK_DMP_PLATFORM
 uint loadparam( _adapter *padapter,  _nic_hdl	pnetdev)
@@ -451,6 +507,7 @@ _func_enter_;
 	registry_par->wifi_spec = (u8)rtw_wifi_spec;
 
 	registry_par->channel_plan = (u8)rtw_channel_plan;
+	registry_par->special_rf_path = (u8)rtw_special_rf_path;
 
 #ifdef CONFIG_BT_COEXIST
 	registry_par->btcoex = (u8)rtw_btcoex_enable;
@@ -517,10 +574,12 @@ _func_enter_;
 	registry_par->RegEnableTxPowerByRate = (u8)rtw_tx_pwr_by_rate;
 
 	registry_par->RegPowerBase = 14;
-	registry_par->TxBBSwing_2G = 0xFF;
-	registry_par->TxBBSwing_5G = 0xFF;
+	registry_par->TxBBSwing_2G = (s8)rtw_TxBBSwing_2G;
+	registry_par->TxBBSwing_5G = (s8)rtw_TxBBSwing_5G;
 	registry_par->bEn_RFE = 1;
-	registry_par->RFE_Type = 64;
+	registry_par->RFE_Type = (u8)rtw_RFE_type;
+	registry_par->AmplifierType_2G = (u8)rtw_amplifier_type_2g;
+	registry_par->AmplifierType_5G = (u8)rtw_amplifier_type_5g;
 
 #ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
 	registry_par->load_phy_file = (u8)rtw_load_phy_file;
@@ -528,6 +587,12 @@ _func_enter_;
 #endif
 	registry_par->qos_opt_enable = (u8)rtw_qos_opt_enable;
 
+	registry_par->hiq_filter = (u8)rtw_hiq_filter;
+
+	registry_par->adaptivity_en = (u8)rtw_adaptivity_en;
+	registry_par->adaptivity_mode = (u8)rtw_adaptivity_mode;
+	registry_par->nhm_en = (u8)rtw_nhm_en;
+
 _func_exit_;
 
 	return status;
@@ -601,7 +666,16 @@ unsigned int rtw_classify8021d(struct sk_buff *skb)
 	return dscp >> 5;
 }
 
-static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb)
+ 
+static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0) 	
+				, void *accel_priv
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) 
+				, select_queue_fallback_t fallback
+#endif
+
+#endif
+)
 {
 	_adapter	*padapter = rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -645,10 +719,13 @@ u16 rtw_recv_select_queue(struct sk_buff *skb)
 }
 
 #endif
-
-static int rtw_ndev_notifier_call(struct notifier_block * nb, unsigned long state, void *ndev)
-{
-	struct net_device *dev = ndev;
+static int rtw_ndev_notifier_call(struct notifier_block * nb, unsigned long state, void *ptr)
+{	
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(3,11,0))
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+#else
+	struct net_device *dev = ptr;
+#endif
 
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 	if (dev->netdev_ops->ndo_do_ioctl != rtw_ioctl)
@@ -905,7 +982,6 @@ u32 rtw_start_drv_threads(_adapter *padapter)
 
 void rtw_stop_drv_threads (_adapter *padapter)
 {
-	u8 res = 0;
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_stop_drv_threads\n"));
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -932,7 +1008,6 @@ void rtw_stop_drv_threads (_adapter *padapter)
 	_rtw_up_sema(&padapter->xmitpriv.xmit_sema);
 	_rtw_down_sema(&padapter->xmitpriv.terminate_xmitthread_sema);
 	}
-
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt: rtw_xmit_thread can be terminated ! \n"));
 #endif
 
@@ -1016,7 +1091,13 @@ u8 rtw_init_default_value(_adapter *padapter)
 	padapter->bShowGetP2PState = 1;
 #endif
 
+	//for debug purpose
 	padapter->fix_rate = 0xFF;
+	padapter->data_fb = 0;
+	padapter->driver_ampdu_spacing = 0xFF;
+	padapter->driver_rx_ampdu_factor =  0xFF;
+	padapter->driver_rx_ampdu_spacing = 0xFF;
+	padapter->fix_ba_rxbuf_bz = 0xFF;
 
 	return ret;
 }
@@ -1035,14 +1116,11 @@ struct dvobj_priv *devobj_init(void)
 	_rtw_mutex_init(&pdvobj->setch_mutex);
 	_rtw_mutex_init(&pdvobj->setbw_mutex);
 
-	_rtw_spinlock_init(&pdvobj->lock);
-
-	pdvobj->macid[1] = _TRUE; //macid=1 for bc/mc stainfo
-
 	pdvobj->processing_dev_remove = _FALSE;
 
 	ATOMIC_SET(&pdvobj->disable_func, 0);
 
+	rtw_macid_ctl_init(&pdvobj->macid_ctl);
 	_rtw_spinlock_init(&pdvobj->cam_ctl.lock);
 
 	return pdvobj;
@@ -1054,13 +1132,12 @@ void devobj_deinit(struct dvobj_priv *pdvobj)
 	if(!pdvobj)
 		return;
 
-	_rtw_spinlock_free(&pdvobj->lock);
-
 	_rtw_mutex_free(&pdvobj->hw_init_mutex);
 	_rtw_mutex_free(&pdvobj->h2c_fwcmd_mutex);
 	_rtw_mutex_free(&pdvobj->setch_mutex);
 	_rtw_mutex_free(&pdvobj->setbw_mutex);
 
+	rtw_macid_ctl_deinit(&pdvobj->macid_ctl);
 	_rtw_spinlock_free(&pdvobj->cam_ctl.lock);
 
 	rtw_mfree((u8*)pdvobj, sizeof(*pdvobj));
@@ -1125,8 +1202,6 @@ _func_enter_;
 
 	ret8 = rtw_init_default_value(padapter);
 
-	rtw_init_hal_com_default_value(padapter);
-
 	if ((rtw_init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
 	{
 		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init cmd_priv\n"));
@@ -1211,6 +1286,8 @@ _func_enter_;
 	padapter->stapriv.padapter = padapter;
 	padapter->setband = GHZ24_50;
 	padapter->fix_rate = 0xFF;
+	padapter->data_fb = 0;
+	padapter->fix_ba_rxbuf_bz = 0xFF;
 	rtw_init_bcmc_stainfo(padapter);
 
 	rtw_init_pwrctrl_priv(padapter);
@@ -1444,11 +1521,7 @@ int _netdev_vir_if_open(struct net_device *pnetdev)
 
 	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
-	if(!rtw_netif_queue_stopped(pnetdev))
-		rtw_netif_start_queue(pnetdev);
-	else
-		rtw_netif_wake_queue(pnetdev);
-
+	rtw_netif_wake_queue(pnetdev);
 
 	DBG_871X(FUNC_NDEV_FMT" exit\n", FUNC_NDEV_ARG(pnetdev));
 	return 0;
@@ -1489,8 +1562,7 @@ static int netdev_vir_if_close(struct net_device *pnetdev)
 
 	if(pnetdev)
 	{
-		if (!rtw_netif_queue_stopped(pnetdev))
-			rtw_netif_stop_queue(pnetdev);
+		rtw_netif_stop_queue(pnetdev);
 	}
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -1762,6 +1834,42 @@ int _netdev_if2_open(struct net_device *pnetdev)
 
 	DBG_871X("+871x_drv - if2_open, bup=%d\n", padapter->bup);
 
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+	if (padapter->bup == _FALSE)
+	{
+	        u8 mac[ETH_ALEN];
+
+		//get mac address from primary_padapter
+		if (primary_padapter->bup == _FALSE)
+			rtw_macaddr_cfg(primary_padapter->eeprompriv.mac_addr);
+
+		_rtw_memcpy(mac, primary_padapter->eeprompriv.mac_addr, ETH_ALEN);
+
+		if (((mac[0] == 0xff) && (mac[1] == 0xff) && (mac[2] == 0xff) &&
+		     (mac[3] == 0xff) && (mac[4] == 0xff) && (mac[5] == 0xff)) ||
+		    ((mac[0] == 0x0) && (mac[1] == 0x0) && (mac[2] == 0x0) &&
+		     (mac[3] == 0x0) && (mac[4] == 0x0) && (mac[5] == 0x0)))
+		{
+			mac[0] = 0x00;
+			mac[1] = 0xe0;
+			mac[2] = 0x4c;
+			mac[3] = 0x87;
+			mac[4] = 0x11;
+			mac[5] = 0x22;
+		}
+		else
+		{
+			//If the BIT1 is 0, the address is universally administered.
+			//If it is 1, the address is locally administered
+			mac[0] |= BIT(1); // locally administered
+		}
+
+		_rtw_memcpy(padapter->eeprompriv.mac_addr, mac, ETH_ALEN);
+		rtw_init_wifidirect_addrs(padapter, padapter->eeprompriv.mac_addr, padapter->eeprompriv.mac_addr);
+		_rtw_memcpy(pnetdev->dev_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
+	}
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
 	if(primary_padapter->bup == _FALSE || primary_padapter->hw_init_completed == _FALSE)
 	{
 		_netdev_open(primary_padapter->pnetdev);
@@ -1807,10 +1915,7 @@ int _netdev_if2_open(struct net_device *pnetdev)
 	// secondary interface shares the timer with primary interface.
 	//_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
-	if(!rtw_netif_queue_stopped(pnetdev))
-		rtw_netif_start_queue(pnetdev);
-	else
-		rtw_netif_wake_queue(pnetdev);
+	rtw_netif_wake_queue(pnetdev);
 
 	DBG_871X("-871x_drv - if2_open, bup=%d\n", padapter->bup);
 	return 0;
@@ -1830,6 +1935,13 @@ int netdev_if2_open(struct net_device *pnetdev)
 {
 	int ret;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
+	struct pwrctrl_priv *pwrctrlpriv = adapter_to_pwrctl(padapter);
+
+	if (pwrctrlpriv->bInSuspend == _TRUE)
+	{
+		DBG_871X("+871x_drv - netdev_if2_open, bInSuspend=%d\n", pwrctrlpriv->bInSuspend);
+		return 0;
+	}
 
 	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex), NULL);
 	ret = _netdev_if2_open(pnetdev);
@@ -1851,8 +1963,7 @@ static int netdev_if2_close(struct net_device *pnetdev)
 
 	if(pnetdev)
 	{
-		if (!rtw_netif_queue_stopped(pnetdev))
-			rtw_netif_stop_queue(pnetdev);
+		rtw_netif_stop_queue(pnetdev);
 	}
 
 #ifdef CONFIG_P2P
@@ -2198,6 +2309,10 @@ int _netdev_open(struct net_device *pnetdev)
 
 	padapter->netif_up = _TRUE;
 
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+	rtw_sdio_set_power(1);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
 	if(pwrctrlpriv->ps_flag == _TRUE){
 		padapter->net_closed = _FALSE;
 		goto netdev_open_normal_process;
@@ -2205,6 +2320,12 @@ int _netdev_open(struct net_device *pnetdev)
 
 	if(padapter->bup == _FALSE)
 	{
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+		rtw_macaddr_cfg(padapter->eeprompriv.mac_addr);
+		rtw_init_wifidirect_addrs(padapter, padapter->eeprompriv.mac_addr, padapter->eeprompriv.mac_addr);
+		_rtw_memcpy(pnetdev->dev_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
 		padapter->bDriverStopped = _FALSE;
 	 	padapter->bSurpriseRemoved = _FALSE;
 		padapter->bCardDisableWOHSM = _FALSE;
@@ -2242,20 +2363,23 @@ int _netdev_open(struct net_device *pnetdev)
 
 		padapter->bup = _TRUE;
 		pwrctrlpriv->bips_processing = _FALSE;
+
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+#ifdef CONFIG_BT_COEXIST	
+		rtw_btcoex_IpsNotify(padapter, IPS_NONE);
+#endif // CONFIG_BT_COEXIST
+#endif //CONFIG_PLATFORM_INTEL_BYT		
 	}
 	padapter->net_closed = _FALSE;
 
 	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
 #ifndef CONFIG_IPS_CHECK_IN_WD
-	//rtw_set_pwr_state_check_timer(pwrctrlpriv);
+	rtw_set_pwr_state_check_timer(pwrctrlpriv);
 #endif 
 
 	//netif_carrier_on(pnetdev);//call this func when rtw_joinbss_event_callback return success
-	if(!rtw_netif_queue_stopped(pnetdev))
-		rtw_netif_start_queue(pnetdev);
-	else
-		rtw_netif_wake_queue(pnetdev);
+	rtw_netif_wake_queue(pnetdev);
 
 #ifdef CONFIG_BR_EXT
 	netdev_br_init(pnetdev);
@@ -2271,10 +2395,6 @@ int _netdev_open(struct net_device *pnetdev)
 	}
 	#endif
 
-#ifndef CONFIG_IPS_CHECK_IN_WD
-	_rtw_set_pwr_state_check_timer(pwrctrlpriv, 1);
-#endif 
-
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - dev_open\n"));
 	DBG_871X("-871x_drv - drv_open, bup=%d\n", padapter->bup);
 
@@ -2426,6 +2546,7 @@ void rtw_ips_dev_unload(_adapter *padapter)
 
 }
 
+
 int pm_netdev_open(struct net_device *pnetdev,u8 bnormal)
 {
 	int status = 0;
@@ -2453,6 +2574,7 @@ static int netdev_close(struct net_device *pnetdev)
 
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+871x_drv - drv_close\n"));
 
+#ifndef CONFIG_PLATFORM_INTEL_BYT
 	if(pwrctl->bInternalAutoSuspend == _TRUE)
 	{
 		//rtw_pwr_wakeup(padapter);
@@ -2477,8 +2599,7 @@ static int netdev_close(struct net_device *pnetdev)
 		//s1.
 		if(pnetdev)
 		{
-			if (!rtw_netif_queue_stopped(pnetdev))
-				rtw_netif_stop_queue(pnetdev);
+			rtw_netif_stop_queue(pnetdev);
 		}
 
 #ifndef CONFIG_ANDROID
@@ -2517,6 +2638,24 @@ static int netdev_close(struct net_device *pnetdev)
 #ifdef CONFIG_WAPI_SUPPORT
 	rtw_wapi_disable_tx(padapter);
 #endif
+#else //!CONFIG_PLATFORM_INTEL_BYT
+
+	if (pwrctl->bInSuspend == _TRUE)
+	{
+		DBG_871X("+871x_drv - drv_close, bInSuspend=%d\n", pwrctl->bInSuspend);
+		return 0;
+	}
+
+	rtw_scan_abort(padapter); // stop scanning process before wifi is going to down
+
+	DBG_871X("netdev_close, bips_processing=%d\n", pwrctl->bips_processing);
+	while (pwrctl->bips_processing == _TRUE) // waiting for ips_processing done before call rtw_dev_unload()
+		rtw_msleep_os(1);	
+
+	rtw_dev_unload(padapter);
+	rtw_sdio_set_power(0);
+
+#endif //!CONFIG_PLATFORM_INTEL_BYT
 
 	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - drv_close\n"));
 	DBG_871X("-871x_drv - drv_close, bup=%d\n", padapter->bup);
@@ -2797,11 +2936,17 @@ static int get_defaultgw(u32 *ip_addr ,char mac[])
 int	rtw_gw_addr_query(_adapter *padapter)
 {
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
 	u32 gw_addr = 0; // default gw address
 	unsigned char gw_mac[32] = {0}; // default gw mac
 	int i;
 	int res;
 
+	if (pwrctl->wowlan_from_cmd == _TRUE) {
+		DBG_871X("%s: return cuz wowlan_from_cmd\n", __func__);
+		return 0;
+	}
+
 	res = get_defaultgw(&gw_addr, gw_mac);
 	if(!res)
 	{
@@ -2875,6 +3020,9 @@ void rtw_dev_unload(PADAPTER padapter)
 
 		if (padapter->bSurpriseRemoved == _FALSE)
 		{
+#ifdef CONFIG_BT_COEXIST
+			rtw_btcoex_IpsNotify(padapter, pwrctl->ips_mode_req);
+#endif
 #ifdef CONFIG_WOWLAN
 			if (pwrctl->bSupportRemoteWakeup == _TRUE && 
 				pwrctl->wowlan_mode ==_TRUE) {
@@ -2902,19 +3050,23 @@ void rtw_dev_unload(PADAPTER padapter)
 	RT_TRACE(_module_hci_intfs_c_, _drv_notice_, ("-%s\n",__FUNCTION__));
 }
 
-#ifdef CONFIG_SUSPEND_REFINE
 int rtw_suspend_free_assoc_resource(_adapter *padapter)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct net_device *pnetdev = padapter->pnetdev;
+#ifdef CONFIG_P2P
 	struct wifidirect_info*	pwdinfo = &padapter->wdinfo;
+#endif // CONFIG_P2P
 
 	DBG_871X("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));
 
 	if (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME)) {
 		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
 			&& check_fwstate(pmlmepriv, _FW_LINKED)
-			&& rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+#ifdef CONFIG_P2P
+			&& rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
+#endif // CONFIG_P2P
+			)
 		{
 			DBG_871X("%s %s(" MAC_FMT "), length:%d assoc_ssid.length:%d\n",__FUNCTION__,
 					pmlmepriv->cur_network.network.Ssid.Ssid,
@@ -2977,10 +3129,13 @@ int rtw_suspend_wow(_adapter *padapter)
 	int ret = _SUCCESS;
 
 	DBG_871X("==> "FUNC_ADPT_FMT" entry....\n", FUNC_ADPT_ARG(padapter));
-	
+
 
 	DBG_871X("wowlan_mode: %d\n", pwrpriv->wowlan_mode);
 	DBG_871X("wowlan_pno_enable: %d\n", pwrpriv->wowlan_pno_enable);
+#ifdef CONFIG_P2P_WOWLAN
+	DBG_871X("wowlan_p2p_enable: %d\n", pwrpriv->wowlan_p2p_enable);
+#endif
 	
 	if (pwrpriv->wowlan_mode == _TRUE) {
 		if(pnetdev)
@@ -3004,11 +3159,11 @@ int rtw_suspend_wow(_adapter *padapter)
 		}
 		#endif // CONFIG_CONCURRENT_MODE
 
-		//#ifdef CONFIG_POWER_SAVING
+		//#ifdef CONFIG_LPS
 		//rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "WOWLAN");
 		//#endif
 
-#ifdef CONFIG_SDIO_HCI
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 		// 2. disable interrupt
 		if (padapter->intf_stop) {
 			padapter->intf_stop(padapter);
@@ -3073,13 +3228,15 @@ int rtw_suspend_wow(_adapter *padapter)
 			rtw_suspend_free_assoc_resource(padapter->pbuddy_adapter);
 		}
 		#endif	
-		
-		#ifdef CONFIG_POWER_SAVING
-		if(pwrpriv->wowlan_pno_enable)
-			DBG_871X_LEVEL(_drv_always_, "%s: pno: %d\n", __func__, pwrpriv->wowlan_pno_enable);
+
+		if(pwrpriv->wowlan_pno_enable) {
+			DBG_871X_LEVEL(_drv_always_, "%s: pno: %d\n", __func__,
+					pwrpriv->wowlan_pno_enable);
+		}
+		#ifdef CONFIG_LPS
 		else
 			rtw_set_ps_mode(padapter, PS_MODE_DTIM, 0, 0, "WOWLAN");
-		#endif
+		#endif //#ifdef CONFIG_LPS
 
 	}
 	else
@@ -3099,9 +3256,9 @@ int rtw_suspend_ap_wow(_adapter *padapter)
 	struct net_device *pnetdev = padapter->pnetdev;
 	#ifdef CONFIG_CONCURRENT_MODE
 	struct net_device *pbuddy_netdev;
-	#endif	
+	#endif
 	struct dvobj_priv *psdpriv = padapter->dvobj;
-	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;	
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
 	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
 	struct wowlan_ioctl_param poidparam;
 	u8 ps_mode;
@@ -3114,7 +3271,7 @@ int rtw_suspend_ap_wow(_adapter *padapter)
 	DBG_871X("wowlan_ap_mode: %d\n", pwrpriv->wowlan_ap_mode);
 	
 	if(pnetdev)
-		rtw_netif_stop_queue(pnetdev);	
+		rtw_netif_stop_queue(pnetdev);
 	#ifdef CONFIG_CONCURRENT_MODE
 	if (rtw_buddy_adapter_up(padapter)) {
 		pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;
@@ -3134,11 +3291,12 @@ int rtw_suspend_ap_wow(_adapter *padapter)
 		padapter->pbuddy_adapter->bDriverStopped = _FALSE;	//for 32k command
 	}
 	#endif // CONFIG_CONCURRENT_MODE
-
-	//#ifdef CONFIG_POWER_SAVING
+	
+	//#ifdef CONFIG_LPS
 	//rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "WOWLAN");
 	//#endif
 
+#ifdef CONFIG_SDIO_HCI
 	// 2. disable interrupt
 	rtw_hal_disable_interrupt(padapter); // It need wait for leaving 32K.
 
@@ -3151,6 +3309,7 @@ int rtw_suspend_ap_wow(_adapter *padapter)
 	// 2.1 clean interupt
 	if (padapter->HalFunc.clear_interrupt)
 		padapter->HalFunc.clear_interrupt(padapter);
+#endif //CONFIG_SDIO_HCI
 
 	// 2.2 free irq
 	//sdio_free_irq(adapter_to_dvobj(padapter));
@@ -3162,14 +3321,14 @@ int rtw_suspend_ap_wow(_adapter *padapter)
 		DBG_871X(" ### PORT SWITCH ### \n");
 		rtw_hal_set_hwreg(padapter, HW_VAR_PORT_SWITCH, NULL);
 	}
-	#endif		
-		
+	#endif
+
 	poidparam.subcode = WOWLAN_AP_ENABLE;
 	padapter->HalFunc.SetHwRegHandler(padapter,
 					HW_VAR_AP_WOWLAN,(u8 *)&poidparam);
 
 	DBG_871X_LEVEL(_drv_always_, "%s: wowmode suspending\n", __func__);
-		
+
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, WIFI_AP_STATE) == _TRUE) {
 		if (rtw_get_ch_setting_union(padapter->pbuddy_adapter, &ch, &bw, &offset) != 0) {
@@ -3194,11 +3353,11 @@ int rtw_suspend_ap_wow(_adapter *padapter)
 	}
 #endif
 
-#ifdef CONFIG_POWER_SAVING
+
 #ifdef CONFIG_LPS
 	rtw_set_ps_mode(padapter, PS_MODE_MIN, 0, 0, "AP-WOWLAN");
 #endif
-	#endif
+
 
 	DBG_871X("<== "FUNC_ADPT_FMT" exit....\n", FUNC_ADPT_ARG(padapter));
 	return ret;
@@ -3338,8 +3497,17 @@ int rtw_suspend_common(_adapter *padapter)
 			pwrpriv->wowlan_mode |= pwrpriv->wowlan_pno_enable;
 		}
 
-		if (pwrpriv->wowlan_mode == _TRUE)	
-		rtw_suspend_wow(padapter);
+	#ifdef CONFIG_P2P_WOWLAN
+		if(!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE) || P2P_ROLE_DISABLE != padapter->wdinfo.role)
+		{
+			pwrpriv->wowlan_p2p_mode = _TRUE;
+		}
+		if(_TRUE == pwrpriv->wowlan_p2p_mode)
+			pwrpriv->wowlan_mode |= pwrpriv->wowlan_p2p_mode;
+	#endif //CONFIG_P2P_WOWLAN
+
+		if (pwrpriv->wowlan_mode == _TRUE)
+			rtw_suspend_wow(padapter);
 		else
 			rtw_suspend_normal(padapter);
 		
@@ -3383,8 +3551,8 @@ int rtw_suspend_common(_adapter *padapter)
 int rtw_resume_process_wow(_adapter *padapter)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct mlme_ext_priv    *pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info    *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct net_device *pnetdev = padapter->pnetdev;
 	#ifdef CONFIG_CONCURRENT_MODE
 	struct net_device *pbuddy_netdev;	
@@ -3420,11 +3588,10 @@ _func_enter_;
 #endif
 
 	if (pwrpriv->wowlan_mode == _TRUE){
-#ifdef CONFIG_POWER_SAVING
 #ifdef CONFIG_LPS
 		rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "WOWLAN");
 #endif //CONFIG_LPS
-#endif
+
 		pwrpriv->bFwCurrentInPSMode = _FALSE;
 
 #ifdef CONFIG_SDIO_HCI
@@ -3497,10 +3664,7 @@ _func_enter_;
 
 		// start netif queue
 		if (pnetdev) {
-			if(!rtw_netif_queue_stopped(pnetdev))
-				rtw_netif_start_queue(pnetdev);
-			else 
-				rtw_netif_wake_queue(pnetdev);
+			rtw_netif_wake_queue(pnetdev);
 		}
 	}
 	else{
@@ -3521,25 +3685,38 @@ _func_enter_;
 			DBG_871X("%s: disconnect reason: %02x\n", __func__,
 						pwrpriv->wowlan_wake_reason);
 			rtw_indicate_disconnect(padapter);
-			rtw_sta_media_status_rpt(padapter, rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv)), 0);
+
+			rtw_sta_media_status_rpt(padapter,
+				rtw_get_stainfo(&padapter->stapriv,
+					get_bssid(&padapter->mlmepriv)), 0);
+
 			rtw_free_assoc_resources(padapter, 1);
 			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
 		} else {
 			DBG_871X("%s: do roaming\n", __func__);
 			rtw_roaming(padapter, NULL);
 		}
 	}
-#ifdef CONFIG_RESUME_IN_WORKQUEUE
-	rtw_unlock_suspend();
-#endif //CONFIG_RESUME_IN_WORKQUEUE
+
+	if (pwrpriv->wowlan_wake_reason == FWDecisionDisconnect) {
+		rtw_lock_ext_suspend_timeout(2000);
+	}
 
 	if (pwrpriv->wowlan_wake_reason == Rx_GTK ||
 		pwrpriv->wowlan_wake_reason == Rx_DisAssoc ||
-		pwrpriv->wowlan_wake_reason == Rx_DeAuth ||
-		pwrpriv->wowlan_wake_reason == RX_PNOWakeUp) {
+		pwrpriv->wowlan_wake_reason == Rx_DeAuth) {
 		rtw_lock_ext_suspend_timeout(8000);
 	}
 
+	if (pwrpriv->wowlan_wake_reason == RX_PNOWakeUp) {
+#ifdef CONFIG_IOCTL_CFG80211	
+		cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0,
+				GFP_ATOMIC);
+#endif
+		rtw_lock_ext_suspend_timeout(10000);
+	}
+
 	if (pwrpriv->wowlan_mode == _TRUE) {
 		pwrpriv->bips_processing = _FALSE;
 		_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
@@ -3589,11 +3766,11 @@ _func_enter_;
 		goto exit;
 	}
 
-#ifdef CONFIG_POWER_SAVING
+
 #ifdef CONFIG_LPS
 	rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "AP-WOWLAN");
 #endif //CONFIG_LPS
-#endif
+
 	pwrpriv->bFwCurrentInPSMode = _FALSE;
 
 	rtw_hal_disable_interrupt(padapter);
@@ -3663,20 +3840,14 @@ _func_enter_;
 	if (rtw_buddy_adapter_up(padapter)) {			
 		pbuddy_netdev = padapter->pbuddy_adapter->pnetdev;			
 		if(pbuddy_netdev){
-			if (!rtw_netif_queue_stopped(pbuddy_netdev))
-				rtw_netif_start_queue(pbuddy_netdev);
-			else
-				rtw_netif_wake_queue(pbuddy_netdev);
+			rtw_netif_wake_queue(pbuddy_netdev);
 		}
 	}
 #endif
 	
 	// start netif queue
 	if (pnetdev) {
-		if(!rtw_netif_queue_stopped(pnetdev))
-			rtw_netif_start_queue(pnetdev);
-		else 
-			rtw_netif_wake_queue(pnetdev);
+		rtw_netif_wake_queue(pnetdev);
 	}
 
 	if( padapter->pid[1]!=0) {
@@ -3685,7 +3856,7 @@ _func_enter_;
 	}	
 
 	#ifdef CONFIG_RESUME_IN_WORKQUEUE
-	rtw_unlock_suspend();
+	//rtw_unlock_suspend();
 	#endif //CONFIG_RESUME_IN_WORKQUEUE
 
 	if (pwrpriv->wowlan_wake_reason == AP_WakeUp)
@@ -3819,7 +3990,7 @@ _func_enter_;
 	#endif
 
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
-	rtw_unlock_suspend();
+	//rtw_unlock_suspend();
 #endif //CONFIG_RESUME_IN_WORKQUEUE
 	DBG_871X("<== "FUNC_ADPT_FMT" exit....\n", FUNC_ADPT_ARG(padapter));
 
@@ -3837,6 +4008,9 @@ int rtw_resume_common(_adapter *padapter)
 	
 	_func_enter_;
 
+	if (pwrpriv->bInSuspend == _FALSE)
+		return 0;
+
 	DBG_871X_LEVEL(_drv_always_, "resume start\n");
 	DBG_871X("==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);	
 
@@ -3847,7 +4021,7 @@ int rtw_resume_common(_adapter *padapter)
 	) {
 	#ifdef CONFIG_WOWLAN
 		if (pwrpriv->wowlan_mode == _TRUE)
-		rtw_resume_process_wow(padapter);
+			rtw_resume_process_wow(padapter);
 		else
 			rtw_resume_process_normal(padapter);
 	#else
@@ -3894,6 +4068,29 @@ int rtw_resume_common(_adapter *padapter)
 	
 	return ret;
 }
-#endif
 
+#ifdef CONFIG_GPIO_API
+u8 rtw_get_gpio(struct net_device *netdev, u8 gpio_num)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
+	return rtw_hal_get_gpio(adapter, gpio_num);
+}
+EXPORT_SYMBOL(rtw_get_gpio);
+
+int  rtw_set_gpio_output_value(struct net_device *netdev, u8 gpio_num, BOOLEAN isHigh)
+{
+	u8 direction = 0;
+	u8 res = -1;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
+	return rtw_hal_set_gpio_output_value(adapter, gpio_num,isHigh);
+}
+EXPORT_SYMBOL(rtw_set_gpio_output_value);
+
+int rtw_config_gpio(struct net_device *netdev, u8 gpio_num, BOOLEAN isOutput)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);	
+	return rtw_hal_config_gpio(adapter,gpio_num,isOutput);	
+}
+EXPORT_SYMBOL(rtw_config_gpio);
+#endif //#ifdef CONFIG_GPIO_API 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/recv_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/recv_linux.c
index 2f965d2b3433..2c2a47ab66a3 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/recv_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/recv_linux.c
@@ -233,9 +233,12 @@ int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf)
 
 
 	if(precvbuf->pskb)
+	{
+#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+		if(rtw_free_skb_premem(precvbuf->pskb)!=0)
+#endif
 		rtw_skb_free(precvbuf->pskb);
-
-
+	}
 	return ret;
 
 }
@@ -299,9 +302,11 @@ _pkt *rtw_os_alloc_msdu_pkt(union recv_frame *prframe, u16 nSubframe_Length, u8
 void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attrib *pattrib)
 {
 	struct mlme_priv*pmlmepriv = &padapter->mlmepriv;
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
 #ifdef CONFIG_BR_EXT
 	void *br_port = NULL;
 #endif
+	int ret;
 
 	/* Indicat the packets to upper layer */
 	if (pkt) {
@@ -342,7 +347,9 @@ void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attri
 
 					if(bmcast && (pskb2 != NULL) ) {
 						pkt = pskb2;
+						DBG_COUNTER(padapter->rx_logs.os_indicate_ap_mcast);
 					} else {
+						DBG_COUNTER(padapter->rx_logs.os_indicate_ap_forward);
 						return;
 					}
 				}
@@ -350,6 +357,7 @@ void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attri
 			else// to APself
 			{
 				//DBG_871X("to APSelf\n");
+				DBG_COUNTER(padapter->rx_logs.os_indicate_ap_self);
 			}
 		}
 		
@@ -381,7 +389,8 @@ void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attri
 			}							
 		}
 #endif	// CONFIG_BR_EXT
-
+		if( precvpriv->sink_udpport > 0)
+			rtw_sink_rtp_seq_dbg(padapter,pkt);
 		pkt->protocol = eth_type_trans(pkt, padapter->pnetdev);
 		pkt->dev = padapter->pnetdev;
 
@@ -395,7 +404,11 @@ void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attri
 		pkt->ip_summed = CHECKSUM_NONE;
 #endif //CONFIG_TCP_CSUM_OFFLOAD_RX
 
-		rtw_netif_rx(padapter->pnetdev, pkt);
+		ret = rtw_netif_rx(padapter->pnetdev, pkt);
+		if (ret == NET_RX_SUCCESS)
+			DBG_COUNTER(padapter->rx_logs.os_netif_ok);
+		else
+			DBG_COUNTER(padapter->rx_logs.os_netif_err);
 	}
 }
 
@@ -558,10 +571,13 @@ int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
 	_queue	*pfree_recv_queue;
 	_pkt *skb;
 	struct mlme_priv*pmlmepriv = &padapter->mlmepriv;
-	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
-
-_func_enter_;
+	struct rx_pkt_attrib *pattrib;
+	
+	if(NULL == precv_frame)
+		goto _recv_indicatepkt_drop;
 
+	DBG_COUNTER(padapter->rx_logs.os_indicate);
+	pattrib = &precv_frame->u.hdr.attrib;
 	precvpriv = &(padapter->recvpriv);
 	pfree_recv_queue = &(precvpriv->free_recv_queue);
 
@@ -629,7 +645,6 @@ _func_enter_;
 
 	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n rtw_recv_indicatepkt :after rtw_os_recv_indicate_pkt!!!!\n"));
 
-_func_exit_;
 
         return _SUCCESS;
 
@@ -639,9 +654,9 @@ _func_exit_;
 	 if(precv_frame)
 		 rtw_free_recvframe(precv_frame, pfree_recv_queue);
 
-	 return _FAIL;
+	 DBG_COUNTER(padapter->rx_logs.os_indicate_err);
 
-_func_exit_;
+	 return _FAIL;
 
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_android.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_android.c
index 59ce0dc418e8..d6fe5924452c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_android.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_android.c
@@ -64,6 +64,9 @@ const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
 	"P2P_GET_NOA",
 	"P2P_SET_PS",
 	"SET_AP_WPS_P2P_IE",
+
+	"MIRACAST",
+
 #ifdef CONFIG_PNO_SUPPORT
 	"PNOSSIDCLR",
 	"PNOSETUP",
@@ -135,16 +138,18 @@ char pno_in_example[] = {
 #endif /* PNO_SUPPORT */
 
 typedef struct android_wifi_priv_cmd {
+	char *buf;
+	int used_len;
+	int total_len;
+} android_wifi_priv_cmd;
 
 #ifdef CONFIG_COMPAT
+typedef struct compat_android_wifi_priv_cmd {
 	compat_uptr_t buf;
-#else
-	char *buf;
-#endif
-
 	int used_len;
 	int total_len;
-} android_wifi_priv_cmd;
+} compat_android_wifi_priv_cmd;
+#endif /* CONFIG_COMPAT */
 
 /**
  * Local (static) functions and variables
@@ -156,9 +161,21 @@ typedef struct android_wifi_priv_cmd {
  */
 static int g_wifi_on = _TRUE;
 
-unsigned int oob_irq;
+unsigned int oob_irq = 0;
+unsigned int oob_gpio = 0;
 
 #ifdef CONFIG_PNO_SUPPORT
+/* 
+ * rtw_android_pno_setup
+ * Description: 
+ * This is used for private command.
+ * 
+ * Parameter:
+ * net: net_device
+ * command: parameters from private command
+ * total_len: the length of the command.
+ *
+ * */
 static int rtw_android_pno_setup(struct net_device *net, char *command, int total_len) {
 	pno_ssid_t pno_ssids_local[MAX_PNO_LIST_COUNT];
 	int res = -1;
@@ -248,10 +265,56 @@ static int rtw_android_pno_setup(struct net_device *net, char *command, int tota
 	return res;
 }
 
-static int rtw_android_pno_enable(struct net_device *net, int pno_enable) {
+/* 
+ * rtw_android_cfg80211_pno_setup
+ * Description: 
+ * This is used for cfg80211 sched_scan.
+ * 
+ * Parameter:
+ * net: net_device
+ * request: cfg80211_request
+ * */
+
+int rtw_android_cfg80211_pno_setup(struct net_device *net,
+		struct cfg80211_ssid *ssids, int n_ssids, int interval) {
+	int res = -1;
+	int nssid = 0;
+	int pno_time = 0;
+	int pno_repeat = 0;
+	int pno_freq_expo_max = 0;
+	int index = 0;
+	pno_ssid_t pno_ssids_local[MAX_PNO_LIST_COUNT];
+
+	if (n_ssids > MAX_PNO_LIST_COUNT || n_ssids < 0) {
+		DBG_871X("%s: nssids(%d) is invalid.\n", __func__, n_ssids);
+		return -EINVAL;
+	}
+
+	memset(pno_ssids_local, 0, sizeof(pno_ssids_local));
+
+	nssid = n_ssids;
+
+	for (index = 0 ; index < nssid ; index++) {
+		pno_ssids_local[index].SSID_len = ssids[index].ssid_len;
+		memcpy(pno_ssids_local[index].SSID, ssids[index].ssid,
+				ssids[index].ssid_len);
+	}
+
+	pno_time = (interval / 1000);
+
+	DBG_871X("%s: nssids: %d, pno_time=%d\n", __func__, nssid, pno_time);
+
+	res = rtw_dev_pno_set(net, pno_ssids_local, nssid, pno_time,
+			pno_repeat, pno_freq_expo_max);
+
+exit_proc:
+	return res;
+}
+
+int rtw_android_pno_enable(struct net_device *net, int pno_enable) {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
 	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(padapter);
-	
+
 	if (pwrctl) {
 		pwrctl->wowlan_pno_enable = pno_enable;
 		DBG_871X("%s: wowlan_pno_enable: %d\n", __func__, pwrctl->wowlan_pno_enable);
@@ -381,6 +444,46 @@ int rtw_android_getband(struct net_device *net, char *command, int total_len)
 	return bytes_written;
 }
 
+enum {
+	MIRACAST_DISABLED = 0,
+	MIRACAST_SOURCE,
+	MIRACAST_SINK,
+	MIRACAST_INVALID,
+};
+
+static const char *miracast_mode_str[] = {
+	"DISABLED",
+	"SOURCE",
+	"SINK",
+	"INVALID",
+};
+
+static const char *get_miracast_mode_str(int mode)
+{
+	if (mode < MIRACAST_DISABLED || mode >= MIRACAST_INVALID)
+		mode = MIRACAST_INVALID;
+
+	return miracast_mode_str[mode];
+}
+
+int rtw_android_set_miracast_mode(struct net_device *net, char *command, int total_len)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
+	char *arg = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_MIRACAST]) + 1;
+	u8 mode;
+	int num;
+	int ret = _FAIL;
+
+	num = sscanf(arg, "%hhu", &mode);
+
+	if (num >= 1) {
+		DBG_871X("Miracast mode: %s(%u)\n", get_miracast_mode_str(mode), mode);
+		ret = _SUCCESS;
+	}
+
+	return (ret==_SUCCESS)?0:-1;
+}
+
 int get_int_from_command( char* pcmd )
 {
 	int i = 0;
@@ -460,12 +563,27 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 #ifdef CONFIG_WFD
 	struct wifi_display_info		*pwfd_info;
 #endif
+
 	rtw_lock_suspend();
 
 	if (!ifr->ifr_data) {
 		ret = -EINVAL;
 		goto exit;
 	}
+#ifdef CONFIG_COMPAT
+	if (is_compat_task()) {
+		/* User space is 32-bit, use compat ioctl */
+		compat_android_wifi_priv_cmd compat_priv_cmd;
+
+		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
+			ret = -EFAULT;
+			goto exit;
+		}
+		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
+		priv_cmd.used_len = compat_priv_cmd.used_len;
+		priv_cmd.total_len = compat_priv_cmd.total_len;
+	} else
+#endif /* CONFIG_COMPAT */
 	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
 		ret = -EFAULT;
 		goto exit;
@@ -488,11 +606,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		ret = -EFAULT;
 		goto exit;
 	 }
-#ifdef CONFIG_COMPAT
-	if (copy_from_user(command, compat_ptr(priv_cmd.buf), (unsigned long) priv_cmd.total_len)) {
-#else
 	if (copy_from_user(command, (void *)priv_cmd.buf, priv_cmd.total_len)) {
-#endif
 		ret = -EFAULT;
 		goto exit;
 	}
@@ -595,7 +709,11 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	case ANDROID_WIFI_CMD_GETBAND:
 		bytes_written = rtw_android_getband(net, command, priv_cmd.total_len);
 		break;
-		
+
+	case ANDROID_WIFI_CMD_MIRACAST:
+		bytes_written = rtw_android_set_miracast_mode(net, command, priv_cmd.total_len);
+		break;
+
 	case ANDROID_WIFI_CMD_COUNTRY:
 		bytes_written = rtw_android_set_country(net, command, priv_cmd.total_len);
 		break;
@@ -671,12 +789,8 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		pwfd_info = &padapter->wfd_info;
 		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
 		{
-#ifdef CONFIG_COMPAT
-			pwfd_info->rtsp_ctrlport = ( u16 ) get_int_from_command( compat_ptr(priv_cmd.buf) );
-#else
 			pwfd_info->rtsp_ctrlport = ( u16 ) get_int_from_command( priv_cmd.buf );
-#endif
-		}
+	}
 		break;
 	}
 	case ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT:
@@ -691,12 +805,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		pwfd_info = &padapter->wfd_info;
 		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
 		{
-#ifdef CONFIG_COMPAT
-			pwfd_info->wfd_device_type = ( u8 ) get_int_from_command( compat_ptr(priv_cmd.buf) );
-#else
 			pwfd_info->wfd_device_type = ( u8 ) get_int_from_command( priv_cmd.buf );
-#endif
-		
 			pwfd_info->wfd_device_type &= WFD_DEVINFO_DUAL;
 		}
 		break;
@@ -706,7 +815,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		{
 #ifdef CONFIG_LPS
 			u8 dtim;
-			u8 *ptr = priv_cmd.buf;
+			u8 *ptr =(u8 *) &priv_cmd.buf;
 			
 			ptr += 9;//string command length of  "SET_DTIM";
 
@@ -740,17 +849,18 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	}
 #ifdef CONFIG_GTK_OL
 	case ANDROID_WIFI_CMD_GTK_REKEY_OFFLOAD:
-		rtw_gtk_offload(net, priv_cmd.buf);
+		rtw_gtk_offload(net, (u8*)command);
 		break;
 #endif //CONFIG_GTK_OL		
 	case ANDROID_WIFI_CMD_P2P_DISABLE:
 	{
+#ifdef CONFIG_P2P
 		struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;	
-		struct wifidirect_info 	*pwdinfo= &(padapter->wdinfo);
 		u8 channel, ch_offset;
 		u16 bwmode;
 
 		rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
+#endif // CONFIG_P2P
 		break;
 	}
 	default:
@@ -770,11 +880,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 			bytes_written++;
 		}
 		priv_cmd.used_len = bytes_written;
-#ifdef CONFIG_COMPAT
-		if (copy_to_user(compat_ptr(priv_cmd.buf), command, bytes_written)) {
-#else
 		if (copy_to_user((void *)priv_cmd.buf, command, bytes_written)) {
-#endif
 			DBG_871X("%s: failed to copy data to user buffer\n", __FUNCTION__);
 			ret = -EFAULT;
 		}
@@ -932,9 +1038,13 @@ static int wifi_probe(struct platform_device *pdev)
 			wifi_irqres->start, wifi_wake_gpio);
 
 	if (wifi_wake_gpio > 0) {
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+		wifi_configure_gpio();
+#else //CONFIG_PLATFORM_INTEL_BYT
 		gpio_request(wifi_wake_gpio, "oob_irq");
 		gpio_direction_input(wifi_wake_gpio);
 		oob_irq = gpio_to_irq(wifi_wake_gpio);
+#endif //CONFIG_PLATFORM_INTEL_BYT
 		printk("%s oob_irq:%d\n", __func__, oob_irq);
 	}
 	else if(wifi_irqres)
@@ -1122,3 +1232,34 @@ static void wifi_del_dev(void)
 }
 #endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
 
+#ifdef CONFIG_GPIO_WAKEUP
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+int wifi_configure_gpio(void)
+{
+	if (gpio_request(oob_gpio, "oob_irq")) {
+		DBG_871X("## %s Cannot request GPIO\n", __FUNCTION__);
+		return -1;
+	}
+	gpio_export(oob_gpio, 0);
+	if (gpio_direction_input(oob_gpio)) {
+		DBG_871X("## %s Cannot set GPIO direction input\n", __FUNCTION__);
+		return -1;
+	}
+	if ((oob_irq = gpio_to_irq(oob_gpio)) < 0) {
+		DBG_871X("## %s Cannot convert GPIO to IRQ\n", __FUNCTION__);
+		return -1;
+	}
+
+	DBG_871X("## %s OOB_IRQ=%d\n", __FUNCTION__, oob_irq);
+
+	return 0;
+}
+#endif //CONFIG_PLATFORM_INTEL_BYT
+void wifi_free_gpio(unsigned int gpio)
+{
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+	if(gpio)
+		gpio_free(gpio);
+#endif //CONFIG_PLATFORM_INTEL_BYT
+}
+#endif //CONFIG_GPIO_WAKEUP
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_cfgvendor.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_cfgvendor.c
new file mode 100644
index 000000000000..2e249c92c6dd
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_cfgvendor.c
@@ -0,0 +1,1319 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2014 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include <drv_types.h>
+
+/*
+#include <linux/kernel.h>
+#include <linux/if_arp.h>
+#include <asm/uaccess.h>
+
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/netdevice.h>
+#include <linux/sched.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/ieee80211.h>
+#include <linux/wait.h>
+#include <net/cfg80211.h>
+*/
+
+#include <net/rtnetlink.h>
+
+#ifdef CONFIG_IOCTL_CFG80211
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)
+
+#ifdef DBG_MEM_ALLOC
+extern bool match_mstat_sniff_rules(const enum mstat_f flags, const size_t size);
+struct sk_buff * dbg_rtw_cfg80211_vendor_event_alloc(struct wiphy *wiphy, int len, int event_id, gfp_t gfp
+	, const enum mstat_f flags, const char *func, const int line)
+{
+	struct sk_buff *skb;
+	unsigned int truesize = 0;
+
+	skb = cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp);
+
+	if(skb)
+		truesize = skb->truesize;
+
+	if(!skb || truesize < len || match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d), skb:%p, truesize=%u\n", func, line, __FUNCTION__, len, skb, truesize);
+
+	rtw_mstat_update(
+		flags
+		, skb ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, truesize
+	);
+
+	return skb;
+}
+
+void dbg_rtw_cfg80211_vendor_event(struct sk_buff *skb, gfp_t gfp
+	, const enum mstat_f flags, const char *func, const int line)
+{
+	unsigned int truesize = skb->truesize;
+
+	if(match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
+
+	cfg80211_vendor_event(skb, gfp);
+
+	rtw_mstat_update(
+		flags
+		, MSTAT_FREE
+		, truesize
+	);
+}
+
+struct sk_buff *dbg_rtw_cfg80211_vendor_cmd_alloc_reply_skb(struct wiphy *wiphy, int len
+	, const enum mstat_f flags, const char *func, const int line)
+{
+	struct sk_buff *skb;
+	unsigned int truesize = 0;
+
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len);
+
+	if(skb)
+		truesize = skb->truesize;
+
+	if(!skb || truesize < len || match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d), skb:%p, truesize=%u\n", func, line, __FUNCTION__, len, skb, truesize);
+
+	rtw_mstat_update(
+		flags
+		, skb ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
+		, truesize
+	);
+
+	return skb;
+}
+
+int dbg_rtw_cfg80211_vendor_cmd_reply(struct sk_buff *skb
+	, const enum mstat_f flags, const char *func, const int line)
+{
+	unsigned int truesize = skb->truesize;
+	int ret;
+
+	if(match_mstat_sniff_rules(flags, truesize))
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
+
+	ret = cfg80211_vendor_cmd_reply(skb);
+
+	rtw_mstat_update(
+		flags
+		, MSTAT_FREE
+		, truesize
+	);
+
+	return ret;
+}
+
+#define rtw_cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp) \
+	dbg_rtw_cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp, MSTAT_FUNC_CFG_VENDOR|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+	
+#define rtw_cfg80211_vendor_event(skb, gfp) \
+	dbg_rtw_cfg80211_vendor_event(skb, gfp, MSTAT_FUNC_CFG_VENDOR|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+	
+#define rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len) \
+	dbg_rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len, MSTAT_FUNC_CFG_VENDOR|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+
+#define rtw_cfg80211_vendor_cmd_reply(skb) \
+		dbg_rtw_cfg80211_vendor_cmd_reply(skb, MSTAT_FUNC_CFG_VENDOR|MSTAT_TYPE_SKB, __FUNCTION__, __LINE__)
+#else
+#define rtw_cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp) \
+	cfg80211_vendor_event_alloc(wiphy, len, event_id, gfp)
+	
+#define rtw_cfg80211_vendor_event(skb, gfp) \
+	cfg80211_vendor_event(skb, gfp)
+	
+#define rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len) \
+	cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len)
+
+#define rtw_cfg80211_vendor_cmd_reply(skb) \
+	cfg80211_vendor_cmd_reply(skb)
+#endif /* DBG_MEM_ALLOC */
+
+/*
+ * This API is to be used for asynchronous vendor events. This
+ * shouldn't be used in response to a vendor command from its
+ * do_it handler context (instead rtw_cfgvendor_send_cmd_reply should
+ * be used).
+ */
+int rtw_cfgvendor_send_async_event(struct wiphy *wiphy,
+	struct net_device *dev, int event_id, const void  *data, int len)
+{
+	u16 kflags;
+	struct sk_buff *skb;
+
+	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_event_alloc(wiphy, len, event_id, kflags);
+	if (!skb) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" skb alloc failed", FUNC_NDEV_ARG(dev));
+		return -ENOMEM;
+	}
+
+	/* Push the data to the skb */
+	nla_put_nohdr(skb, len, data);
+
+	rtw_cfg80211_vendor_event(skb, kflags);
+
+	return 0;
+}
+
+static int rtw_cfgvendor_send_cmd_reply(struct wiphy *wiphy,
+	struct net_device *dev, const void  *data, int len)
+{
+	struct sk_buff *skb;
+
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, len);
+	if (unlikely(!skb)) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" skb alloc failed", FUNC_NDEV_ARG(dev));
+		return -ENOMEM;
+	}
+
+	/* Push the data to the skb */
+	nla_put_nohdr(skb, len, data);
+
+	return rtw_cfg80211_vendor_cmd_reply(skb);
+}
+
+#define WIFI_FEATURE_INFRA              0x0001      /* Basic infrastructure mode        */
+#define WIFI_FEATURE_INFRA_5G           0x0002      /* Support for 5 GHz Band           */
+#define WIFI_FEATURE_HOTSPOT            0x0004      /* Support for GAS/ANQP             */
+#define WIFI_FEATURE_P2P                0x0008      /* Wifi-Direct                      */
+#define WIFI_FEATURE_SOFT_AP            0x0010      /* Soft AP                          */
+#define WIFI_FEATURE_GSCAN              0x0020      /* Google-Scan APIs                 */
+#define WIFI_FEATURE_NAN                0x0040      /* Neighbor Awareness Networking    */
+#define WIFI_FEATURE_D2D_RTT            0x0080      /* Device-to-device RTT             */
+#define WIFI_FEATURE_D2AP_RTT           0x0100      /* Device-to-AP RTT                 */
+#define WIFI_FEATURE_BATCH_SCAN         0x0200      /* Batched Scan (legacy)            */
+#define WIFI_FEATURE_PNO                0x0400      /* Preferred network offload        */
+#define WIFI_FEATURE_ADDITIONAL_STA     0x0800      /* Support for two STAs             */
+#define WIFI_FEATURE_TDLS               0x1000      /* Tunnel directed link setup       */
+#define WIFI_FEATURE_TDLS_OFFCHANNEL    0x2000      /* Support for TDLS off channel     */
+#define WIFI_FEATURE_EPR                0x4000      /* Enhanced power reporting         */
+#define WIFI_FEATURE_AP_STA             0x8000      /* Support for AP STA Concurrency   */
+
+#define MAX_FEATURE_SET_CONCURRRENT_GROUPS  3
+
+#include <hal_data.h>
+int rtw_dev_get_feature_set(struct net_device *dev)
+{
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	HAL_DATA_TYPE *HalData = GET_HAL_DATA(adapter);
+	HAL_VERSION *hal_ver = &HalData->VersionID;
+
+	int feature_set = 0;
+
+	feature_set |= WIFI_FEATURE_INFRA;
+
+	if(IS_92D(*hal_ver) || IS_8812_SERIES(*hal_ver) || IS_8821_SERIES(*hal_ver))
+		feature_set |= WIFI_FEATURE_INFRA_5G;
+
+	feature_set |= WIFI_FEATURE_P2P;
+	feature_set |= WIFI_FEATURE_SOFT_AP;
+
+	feature_set |= WIFI_FEATURE_ADDITIONAL_STA;
+
+	return feature_set;
+}
+
+int *rtw_dev_get_feature_set_matrix(struct net_device *dev, int *num)
+{
+	int feature_set_full, mem_needed;
+	int *ret;
+
+	*num = 0;
+	mem_needed = sizeof(int) * MAX_FEATURE_SET_CONCURRRENT_GROUPS;
+	ret = (int *)rtw_malloc(mem_needed);
+
+	if (!ret) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" failed to allocate %d bytes\n"
+			, FUNC_NDEV_ARG(dev), mem_needed);
+		return ret;
+	}
+
+	feature_set_full = rtw_dev_get_feature_set(dev);
+
+	ret[0] = (feature_set_full & WIFI_FEATURE_INFRA) |
+	         (feature_set_full & WIFI_FEATURE_INFRA_5G) |
+	         (feature_set_full & WIFI_FEATURE_NAN) |
+	         (feature_set_full & WIFI_FEATURE_D2D_RTT) |
+	         (feature_set_full & WIFI_FEATURE_D2AP_RTT) |
+	         (feature_set_full & WIFI_FEATURE_PNO) |
+	         (feature_set_full & WIFI_FEATURE_BATCH_SCAN) |
+	         (feature_set_full & WIFI_FEATURE_GSCAN) |
+	         (feature_set_full & WIFI_FEATURE_HOTSPOT) |
+	         (feature_set_full & WIFI_FEATURE_ADDITIONAL_STA) |
+	         (feature_set_full & WIFI_FEATURE_EPR);
+
+	ret[1] = (feature_set_full & WIFI_FEATURE_INFRA) |
+	         (feature_set_full & WIFI_FEATURE_INFRA_5G) |
+	         /* Not yet verified NAN with P2P */
+	         /* (feature_set_full & WIFI_FEATURE_NAN) | */
+	         (feature_set_full & WIFI_FEATURE_P2P) |
+	         (feature_set_full & WIFI_FEATURE_D2AP_RTT) |
+	         (feature_set_full & WIFI_FEATURE_D2D_RTT) |
+	         (feature_set_full & WIFI_FEATURE_EPR);
+
+	ret[2] = (feature_set_full & WIFI_FEATURE_INFRA) |
+	         (feature_set_full & WIFI_FEATURE_INFRA_5G) |
+	         (feature_set_full & WIFI_FEATURE_NAN) |
+	         (feature_set_full & WIFI_FEATURE_D2D_RTT) |
+	         (feature_set_full & WIFI_FEATURE_D2AP_RTT) |
+	         (feature_set_full & WIFI_FEATURE_TDLS) |
+	         (feature_set_full & WIFI_FEATURE_TDLS_OFFCHANNEL) |
+	         (feature_set_full & WIFI_FEATURE_EPR);
+	*num = MAX_FEATURE_SET_CONCURRRENT_GROUPS;
+
+	return ret;
+}
+
+static int rtw_cfgvendor_get_feature_set(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	int reply;
+
+	reply = rtw_dev_get_feature_set(wdev_to_ndev(wdev));
+
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), &reply, sizeof(int));
+
+	if (unlikely(err))
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" Vendor Command reply failed ret:%d \n"
+			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);
+
+	return err;
+}
+
+static int rtw_cfgvendor_get_feature_set_matrix(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct sk_buff *skb;
+	int *reply;
+	int num, mem_needed, i;
+
+	reply = rtw_dev_get_feature_set_matrix(wdev_to_ndev(wdev), &num);
+
+	if (!reply) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" Could not get feature list matrix\n"
+			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)));
+		err = -EINVAL;
+		return err;
+	}
+
+	mem_needed = VENDOR_REPLY_OVERHEAD + (ATTRIBUTE_U32_LEN * num) +
+	             ATTRIBUTE_U32_LEN;
+
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, mem_needed);
+	if (unlikely(!skb)) {
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" skb alloc failed", FUNC_NDEV_ARG(wdev_to_ndev(wdev)));
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	nla_put_u32(skb, ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET, num);
+	for (i = 0; i < num; i++) {
+		nla_put_u32(skb, ANDR_WIFI_ATTRIBUTE_FEATURE_SET, reply[i]);
+	}
+
+	err =  rtw_cfg80211_vendor_cmd_reply(skb);
+
+	if (unlikely(err))
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT" Vendor Command reply failed ret:%d \n"
+			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);
+exit:
+	rtw_mfree((u8*)reply, sizeof(int)*num);
+	return err;
+}
+
+#if defined(GSCAN_SUPPORT) && 0
+int wl_cfgvendor_send_hotlist_event(struct wiphy *wiphy,
+	struct net_device *dev, void  *data, int len, wl_vendor_event_t event)
+{
+	u16 kflags;
+	const void *ptr;
+	struct sk_buff *skb;
+	int malloc_len, total, iter_cnt_to_send, cnt;
+	gscan_results_cache_t *cache = (gscan_results_cache_t *)data;
+
+	total = len/sizeof(wifi_gscan_result_t);
+	while (total > 0) {
+		malloc_len = (total * sizeof(wifi_gscan_result_t)) + VENDOR_DATA_OVERHEAD;
+		if (malloc_len > NLMSG_DEFAULT_SIZE) {
+			malloc_len = NLMSG_DEFAULT_SIZE;
+		}
+		iter_cnt_to_send =
+		   (malloc_len - VENDOR_DATA_OVERHEAD)/sizeof(wifi_gscan_result_t);
+		total = total - iter_cnt_to_send;
+
+		kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+
+		/* Alloc the SKB for vendor_event */
+		skb = rtw_cfg80211_vendor_event_alloc(wiphy, malloc_len, event, kflags);
+		if (!skb) {
+			WL_ERR(("skb alloc failed"));
+			return -ENOMEM;
+		}
+
+		while (cache && iter_cnt_to_send) {
+			ptr = (const void *) &cache->results[cache->tot_consumed];
+
+			if (iter_cnt_to_send < (cache->tot_count - cache->tot_consumed))
+				cnt = iter_cnt_to_send;
+			else
+				cnt = (cache->tot_count - cache->tot_consumed);
+
+			iter_cnt_to_send -= cnt;
+			cache->tot_consumed += cnt;
+			/* Push the data to the skb */
+			nla_append(skb, cnt * sizeof(wifi_gscan_result_t), ptr);
+			if (cache->tot_consumed == cache->tot_count)
+				cache = cache->next;
+
+		}
+
+		rtw_cfg80211_vendor_event(skb, kflags);
+	}
+
+	return 0;
+}
+
+
+static int wl_cfgvendor_gscan_get_capabilities(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	dhd_pno_gscan_capabilities_t *reply = NULL;
+	uint32 reply_len = 0;
+
+
+	reply = dhd_dev_pno_get_gscan(bcmcfg_to_prmry_ndev(cfg),
+	   DHD_PNO_GET_CAPABILITIES, NULL, &reply_len);
+	if (!reply) {
+		WL_ERR(("Could not get capabilities\n"));
+		err = -EINVAL;
+		return err;
+	}
+
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
+	        reply, reply_len);
+
+	if (unlikely(err))
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+
+	kfree(reply);
+	return err;
+}
+
+static int wl_cfgvendor_gscan_get_channel_list(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0, type, band;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	uint16 *reply = NULL;
+	uint32 reply_len = 0, num_channels, mem_needed;
+	struct sk_buff *skb;
+
+	type = nla_type(data);
+
+	if (type == GSCAN_ATTRIBUTE_BAND) {
+		band = nla_get_u32(data);
+	} else {
+		return -1;
+	}
+
+	reply = dhd_dev_pno_get_gscan(bcmcfg_to_prmry_ndev(cfg),
+	   DHD_PNO_GET_CHANNEL_LIST, &band, &reply_len);
+
+	if (!reply) {
+		WL_ERR(("Could not get channel list\n"));
+		err = -EINVAL;
+		return err;
+	}
+	num_channels =  reply_len/ sizeof(uint32);
+	mem_needed = reply_len + VENDOR_REPLY_OVERHEAD + (ATTRIBUTE_U32_LEN * 2);
+
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, mem_needed);
+	if (unlikely(!skb)) {
+		WL_ERR(("skb alloc failed"));
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	nla_put_u32(skb, GSCAN_ATTRIBUTE_NUM_CHANNELS, num_channels);
+	nla_put(skb, GSCAN_ATTRIBUTE_CHANNEL_LIST, reply_len, reply);
+
+	err =  rtw_cfg80211_vendor_cmd_reply(skb);
+
+	if (unlikely(err))
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+exit:
+	kfree(reply);
+	return err;
+}
+
+static int wl_cfgvendor_gscan_get_batch_results(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_results_cache_t *results, *iter;
+	uint32 reply_len, complete = 0, num_results_iter;
+	int32 mem_needed;
+	wifi_gscan_result_t *ptr;
+	uint16 num_scan_ids, num_results;
+	struct sk_buff *skb;
+	struct nlattr *scan_hdr;
+
+	dhd_dev_wait_batch_results_complete(bcmcfg_to_prmry_ndev(cfg));
+	dhd_dev_pno_lock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
+	results = dhd_dev_pno_get_gscan(bcmcfg_to_prmry_ndev(cfg),
+	             DHD_PNO_GET_BATCH_RESULTS, NULL, &reply_len);
+
+	if (!results) {
+		WL_ERR(("No results to send %d\n", err));
+		err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
+		        results, 0);
+
+		if (unlikely(err))
+			WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+		dhd_dev_pno_unlock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
+		return err;
+	}
+	num_scan_ids = reply_len & 0xFFFF;
+	num_results = (reply_len & 0xFFFF0000) >> 16;
+	mem_needed = (num_results * sizeof(wifi_gscan_result_t)) +
+	             (num_scan_ids * GSCAN_BATCH_RESULT_HDR_LEN) +
+	             VENDOR_REPLY_OVERHEAD + SCAN_RESULTS_COMPLETE_FLAG_LEN;
+
+	if (mem_needed > (int32)NLMSG_DEFAULT_SIZE) {
+		mem_needed = (int32)NLMSG_DEFAULT_SIZE;
+		complete = 0;
+	} else {
+		complete = 1;
+	}
+
+	WL_TRACE(("complete %d mem_needed %d max_mem %d\n", complete, mem_needed,
+		(int)NLMSG_DEFAULT_SIZE));
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_cmd_alloc_reply_skb(wiphy, mem_needed);
+	if (unlikely(!skb)) {
+		WL_ERR(("skb alloc failed"));
+		dhd_dev_pno_unlock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
+		return -ENOMEM;
+	}
+	iter = results;
+
+	nla_put_u32(skb, GSCAN_ATTRIBUTE_SCAN_RESULTS_COMPLETE, complete);
+
+	mem_needed = mem_needed - (SCAN_RESULTS_COMPLETE_FLAG_LEN + VENDOR_REPLY_OVERHEAD);
+
+	while (iter && ((mem_needed - GSCAN_BATCH_RESULT_HDR_LEN)  > 0)) {
+		scan_hdr = nla_nest_start(skb, GSCAN_ATTRIBUTE_SCAN_RESULTS);
+		nla_put_u32(skb, GSCAN_ATTRIBUTE_SCAN_ID, iter->scan_id);
+		nla_put_u8(skb, GSCAN_ATTRIBUTE_SCAN_FLAGS, iter->flag);
+		num_results_iter =
+		    (mem_needed - GSCAN_BATCH_RESULT_HDR_LEN)/sizeof(wifi_gscan_result_t);
+
+		if ((iter->tot_count - iter->tot_consumed) < num_results_iter)
+			num_results_iter = iter->tot_count - iter->tot_consumed;
+
+		nla_put_u32(skb, GSCAN_ATTRIBUTE_NUM_OF_RESULTS, num_results_iter);
+		if (num_results_iter) {
+			ptr = &iter->results[iter->tot_consumed];
+			iter->tot_consumed += num_results_iter;
+			nla_put(skb, GSCAN_ATTRIBUTE_SCAN_RESULTS,
+			 num_results_iter * sizeof(wifi_gscan_result_t), ptr);
+		}
+		nla_nest_end(skb, scan_hdr);
+		mem_needed -= GSCAN_BATCH_RESULT_HDR_LEN +
+		    (num_results_iter * sizeof(wifi_gscan_result_t));
+		iter = iter->next;
+	}
+
+	dhd_dev_gscan_batch_cache_cleanup(bcmcfg_to_prmry_ndev(cfg));
+	dhd_dev_pno_unlock_access_batch_results(bcmcfg_to_prmry_ndev(cfg));
+
+	return rtw_cfg80211_vendor_cmd_reply(skb);
+}
+
+static int wl_cfgvendor_initiate_gscan(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	int type, tmp = len;
+	int run = 0xFF;
+	int flush = 0;
+	const struct nlattr *iter;
+
+	nla_for_each_attr(iter, data, len, tmp) {
+		type = nla_type(iter);
+		if (type == GSCAN_ATTRIBUTE_ENABLE_FEATURE)
+			run = nla_get_u32(iter);
+		else if (type == GSCAN_ATTRIBUTE_FLUSH_FEATURE)
+			flush = nla_get_u32(iter);
+	}
+
+	if (run != 0xFF) {
+		err = dhd_dev_pno_run_gscan(bcmcfg_to_prmry_ndev(cfg), run, flush);
+
+		if (unlikely(err))
+			WL_ERR(("Could not run gscan:%d \n", err));
+		return err;
+	} else {
+		return -1;
+	}
+
+
+}
+
+static int wl_cfgvendor_enable_full_scan_result(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	int type;
+	bool real_time = FALSE;
+
+	type = nla_type(data);
+
+	if (type == GSCAN_ATTRIBUTE_ENABLE_FULL_SCAN_RESULTS) {
+		real_time = nla_get_u32(data);
+
+		err = dhd_dev_pno_enable_full_scan_result(bcmcfg_to_prmry_ndev(cfg), real_time);
+
+		if (unlikely(err))
+			WL_ERR(("Could not run gscan:%d \n", err));
+
+	} else {
+		err = -1;
+	}
+
+	return err;
+}
+
+static int wl_cfgvendor_set_scan_cfg(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_scan_params_t *scan_param;
+	int j = 0;
+	int type, tmp, tmp1, tmp2, k = 0;
+	const struct nlattr *iter, *iter1, *iter2;
+	struct dhd_pno_gscan_channel_bucket  *ch_bucket;
+
+	scan_param = kzalloc(sizeof(gscan_scan_params_t), GFP_KERNEL);
+	if (!scan_param) {
+		WL_ERR(("Could not set GSCAN scan cfg, mem alloc failure\n"));
+		err = -EINVAL;
+		return err;
+
+	}
+
+	scan_param->scan_fr = PNO_SCAN_MIN_FW_SEC;
+	nla_for_each_attr(iter, data, len, tmp) {
+		type = nla_type(iter);
+
+		if (j >= GSCAN_MAX_CH_BUCKETS)
+			break;
+
+		switch (type) {
+			case GSCAN_ATTRIBUTE_BASE_PERIOD:
+				scan_param->scan_fr = nla_get_u32(iter)/1000;
+				break;
+			case GSCAN_ATTRIBUTE_NUM_BUCKETS:
+				scan_param->nchannel_buckets = nla_get_u32(iter);
+				break;
+			case GSCAN_ATTRIBUTE_CH_BUCKET_1:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_2:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_3:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_4:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_5:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_6:
+			case GSCAN_ATTRIBUTE_CH_BUCKET_7:
+				nla_for_each_nested(iter1, iter, tmp1) {
+					type = nla_type(iter1);
+					ch_bucket =
+					scan_param->channel_bucket;
+
+					switch (type) {
+						case GSCAN_ATTRIBUTE_BUCKET_ID:
+						break;
+						case GSCAN_ATTRIBUTE_BUCKET_PERIOD:
+							ch_bucket[j].bucket_freq_multiple =
+							    nla_get_u32(iter1)/1000;
+							break;
+						case GSCAN_ATTRIBUTE_BUCKET_NUM_CHANNELS:
+							ch_bucket[j].num_channels =
+							     nla_get_u32(iter1);
+							break;
+						case GSCAN_ATTRIBUTE_BUCKET_CHANNELS:
+							nla_for_each_nested(iter2, iter1, tmp2) {
+								if (k >= PFN_SWC_RSSI_WINDOW_MAX)
+									break;
+								ch_bucket[j].chan_list[k] =
+								     nla_get_u32(iter2);
+								k++;
+							}
+							k = 0;
+							break;
+						case GSCAN_ATTRIBUTE_BUCKETS_BAND:
+							ch_bucket[j].band = (uint16)
+							     nla_get_u32(iter1);
+							break;
+						case GSCAN_ATTRIBUTE_REPORT_EVENTS:
+							ch_bucket[j].report_flag = (uint8)
+							     nla_get_u32(iter1);
+							break;
+					}
+				}
+				j++;
+				break;
+		}
+	}
+
+	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
+	     DHD_PNO_SCAN_CFG_ID, scan_param, 0) < 0) {
+		WL_ERR(("Could not set GSCAN scan cfg\n"));
+		err = -EINVAL;
+	}
+
+	kfree(scan_param);
+	return err;
+
+}
+
+static int wl_cfgvendor_hotlist_cfg(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_hotlist_scan_params_t *hotlist_params;
+	int tmp, tmp1, tmp2, type, j = 0, dummy;
+	const struct nlattr *outer, *inner, *iter;
+	uint8 flush = 0;
+	struct bssid_t *pbssid;
+
+	hotlist_params = (gscan_hotlist_scan_params_t *)kzalloc(len, GFP_KERNEL);
+	if (!hotlist_params) {
+		WL_ERR(("Cannot Malloc mem to parse config commands size - %d bytes \n", len));
+		return -1;
+	}
+
+	hotlist_params->lost_ap_window = GSCAN_LOST_AP_WINDOW_DEFAULT;
+
+	nla_for_each_attr(iter, data, len, tmp2) {
+		type = nla_type(iter);
+		switch (type) {
+			case GSCAN_ATTRIBUTE_HOTLIST_BSSIDS:
+				pbssid = hotlist_params->bssid;
+				nla_for_each_nested(outer, iter, tmp) {
+					nla_for_each_nested(inner, outer, tmp1) {
+						type = nla_type(inner);
+
+						switch (type) {
+							case GSCAN_ATTRIBUTE_BSSID:
+								memcpy(&(pbssid[j].macaddr),
+								  nla_data(inner), ETHER_ADDR_LEN);
+								break;
+							case GSCAN_ATTRIBUTE_RSSI_LOW:
+								pbssid[j].rssi_reporting_threshold =
+								         (int8) nla_get_u8(inner);
+								break;
+							case GSCAN_ATTRIBUTE_RSSI_HIGH:
+								dummy = (int8) nla_get_u8(inner);
+								break;
+						}
+					}
+					j++;
+				}
+				hotlist_params->nbssid = j;
+				break;
+			case GSCAN_ATTRIBUTE_HOTLIST_FLUSH:
+				flush = nla_get_u8(iter);
+				break;
+			case GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE:
+				hotlist_params->lost_ap_window = nla_get_u32(iter);
+				break;
+			}
+
+	}
+
+	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
+	      DHD_PNO_GEOFENCE_SCAN_CFG_ID, hotlist_params, flush) < 0) {
+		WL_ERR(("Could not set GSCAN HOTLIST cfg\n"));
+		err = -EINVAL;
+		goto exit;
+	}
+exit:
+	kfree(hotlist_params);
+	return err;
+}
+static int wl_cfgvendor_set_batch_scan_cfg(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0, tmp, type;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_batch_params_t batch_param;
+	const struct nlattr *iter;
+
+	batch_param.mscan = batch_param.bestn = 0;
+	batch_param.buffer_threshold = GSCAN_BATCH_NO_THR_SET;
+
+	nla_for_each_attr(iter, data, len, tmp) {
+		type = nla_type(iter);
+
+		switch (type) {
+			case GSCAN_ATTRIBUTE_NUM_AP_PER_SCAN:
+				batch_param.bestn = nla_get_u32(iter);
+				break;
+			case GSCAN_ATTRIBUTE_NUM_SCANS_TO_CACHE:
+				batch_param.mscan = nla_get_u32(iter);
+				break;
+			case GSCAN_ATTRIBUTE_REPORT_THRESHOLD:
+				batch_param.buffer_threshold = nla_get_u32(iter);
+				break;
+		}
+	}
+
+	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
+	       DHD_PNO_BATCH_SCAN_CFG_ID, &batch_param, 0) < 0) {
+		WL_ERR(("Could not set batch cfg\n"));
+		err = -EINVAL;
+		return err;
+	}
+
+	return err;
+}
+
+static int wl_cfgvendor_significant_change_cfg(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	gscan_swc_params_t *significant_params;
+	int tmp, tmp1, tmp2, type, j = 0;
+	const struct nlattr *outer, *inner, *iter;
+	uint8 flush = 0;
+	wl_pfn_significant_bssid_t *pbssid;
+
+	significant_params = (gscan_swc_params_t *) kzalloc(len, GFP_KERNEL);
+	if (!significant_params) {
+		WL_ERR(("Cannot Malloc mem to parse config commands size - %d bytes \n", len));
+		return -1;
+	}
+
+
+	nla_for_each_attr(iter, data, len, tmp2) {
+		type = nla_type(iter);
+
+		switch (type) {
+			case GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH:
+			flush = nla_get_u8(iter);
+			break;
+			case GSCAN_ATTRIBUTE_RSSI_SAMPLE_SIZE:
+				significant_params->rssi_window = nla_get_u16(iter);
+				break;
+			case GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE:
+				significant_params->lost_ap_window = nla_get_u16(iter);
+				break;
+			case GSCAN_ATTRIBUTE_MIN_BREACHING:
+				significant_params->swc_threshold = nla_get_u16(iter);
+				break;
+			case GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_BSSIDS:
+				pbssid = significant_params->bssid_elem_list;
+				nla_for_each_nested(outer, iter, tmp) {
+					nla_for_each_nested(inner, outer, tmp1) {
+							switch (nla_type(inner)) {
+								case GSCAN_ATTRIBUTE_BSSID:
+								memcpy(&(pbssid[j].macaddr),
+								     nla_data(inner),
+								     ETHER_ADDR_LEN);
+								break;
+								case GSCAN_ATTRIBUTE_RSSI_HIGH:
+								pbssid[j].rssi_high_threshold =
+								       (int8) nla_get_u8(inner);
+								break;
+								case GSCAN_ATTRIBUTE_RSSI_LOW:
+								pbssid[j].rssi_low_threshold =
+								      (int8) nla_get_u8(inner);
+								break;
+							}
+						}
+					j++;
+				}
+				break;
+		}
+	}
+	significant_params->nbssid = j;
+
+	if (dhd_dev_pno_set_cfg_gscan(bcmcfg_to_prmry_ndev(cfg),
+	    DHD_PNO_SIGNIFICANT_SCAN_CFG_ID, significant_params, flush) < 0) {
+		WL_ERR(("Could not set GSCAN significant cfg\n"));
+		err = -EINVAL;
+		goto exit;
+	}
+exit:
+	kfree(significant_params);
+	return err;
+}
+#endif /* GSCAN_SUPPORT */
+
+#if defined(RTT_SUPPORT) && 0
+void wl_cfgvendor_rtt_evt(void *ctx, void *rtt_data)
+{
+	struct wireless_dev *wdev = (struct wireless_dev *)ctx;
+	struct wiphy *wiphy;
+	struct sk_buff *skb;
+	uint32 tot_len = NLMSG_DEFAULT_SIZE, entry_len = 0;
+	gfp_t kflags;
+	rtt_report_t *rtt_report = NULL;
+	rtt_result_t *rtt_result = NULL;
+	struct list_head *rtt_list;
+	wiphy = wdev->wiphy;
+
+	WL_DBG(("In\n"));
+	/* Push the data to the skb */
+	if (!rtt_data) {
+		WL_ERR(("rtt_data is NULL\n"));
+		goto exit;
+	}
+	rtt_list = (struct list_head *)rtt_data;
+	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	/* Alloc the SKB for vendor_event */
+	skb = rtw_cfg80211_vendor_event_alloc(wiphy, tot_len, GOOGLE_RTT_COMPLETE_EVENT, kflags);
+	if (!skb) {
+		WL_ERR(("skb alloc failed"));
+		goto exit;
+	}
+	/* fill in the rtt results on each entry */
+	list_for_each_entry(rtt_result, rtt_list, list) {
+		entry_len = 0;
+		if (rtt_result->TOF_type == TOF_TYPE_ONE_WAY) {
+			entry_len = sizeof(rtt_report_t);
+			rtt_report = kzalloc(entry_len, kflags);
+			if (!rtt_report) {
+				WL_ERR(("rtt_report alloc failed"));
+				goto exit;
+			}
+			rtt_report->addr = rtt_result->peer_mac;
+			rtt_report->num_measurement = 1; /* ONE SHOT */
+			rtt_report->status = rtt_result->err_code;
+			rtt_report->type = (rtt_result->TOF_type == TOF_TYPE_ONE_WAY) ? RTT_ONE_WAY: RTT_TWO_WAY;
+			rtt_report->peer = rtt_result->target_info->peer;
+			rtt_report->channel = rtt_result->target_info->channel;
+			rtt_report->rssi = rtt_result->avg_rssi;
+			/* tx_rate */
+			rtt_report->tx_rate = rtt_result->tx_rate;
+			/* RTT */
+			rtt_report->rtt = rtt_result->meanrtt;
+			rtt_report->rtt_sd = rtt_result->sdrtt;
+			/* convert to centi meter */
+			if (rtt_result->distance != 0xffffffff)
+				rtt_report->distance = (rtt_result->distance >> 2) * 25;
+			else /* invalid distance */
+				rtt_report->distance = -1;
+
+			rtt_report->ts = rtt_result->ts;
+			nla_append(skb, entry_len, rtt_report);
+			kfree(rtt_report);
+		}
+	}
+	rtw_cfg80211_vendor_event(skb, kflags);
+exit:
+	return;
+}
+
+static int wl_cfgvendor_rtt_set_config(struct wiphy *wiphy, struct wireless_dev *wdev,
+					const void *data, int len) {
+	int err = 0, rem, rem1, rem2, type;
+	rtt_config_params_t rtt_param;
+	rtt_target_info_t* rtt_target = NULL;
+	const struct nlattr *iter, *iter1, *iter2;
+	int8 eabuf[ETHER_ADDR_STR_LEN];
+	int8 chanbuf[CHANSPEC_STR_LEN];
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+
+	WL_DBG(("In\n"));
+	err = dhd_dev_rtt_register_noti_callback(wdev->netdev, wdev, wl_cfgvendor_rtt_evt);
+	if (err < 0) {
+		WL_ERR(("failed to register rtt_noti_callback\n"));
+		goto exit;
+	}
+	memset(&rtt_param, 0, sizeof(rtt_param));
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case RTT_ATTRIBUTE_TARGET_CNT:
+			rtt_param.rtt_target_cnt = nla_get_u8(iter);
+			if (rtt_param.rtt_target_cnt > RTT_MAX_TARGET_CNT) {
+				WL_ERR(("exceed max target count : %d\n",
+					rtt_param.rtt_target_cnt));
+				err = BCME_RANGE;
+			}
+			break;
+		case RTT_ATTRIBUTE_TARGET_INFO:
+			rtt_target = rtt_param.target_info;
+			nla_for_each_nested(iter1, iter, rem1) {
+				nla_for_each_nested(iter2, iter1, rem2) {
+					type = nla_type(iter2);
+					switch (type) {
+					case RTT_ATTRIBUTE_TARGET_MAC:
+						memcpy(&rtt_target->addr, nla_data(iter2), ETHER_ADDR_LEN);
+						break;
+					case RTT_ATTRIBUTE_TARGET_TYPE:
+						rtt_target->type = nla_get_u8(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_PEER:
+						rtt_target->peer= nla_get_u8(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_CHAN:
+						memcpy(&rtt_target->channel, nla_data(iter2),
+							sizeof(rtt_target->channel));
+						break;
+					case RTT_ATTRIBUTE_TARGET_MODE:
+						rtt_target->continuous = nla_get_u8(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_INTERVAL:
+						rtt_target->interval = nla_get_u32(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_NUM_MEASUREMENT:
+						rtt_target->measure_cnt = nla_get_u32(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_NUM_PKT:
+						rtt_target->ftm_cnt = nla_get_u32(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_NUM_RETRY:
+						rtt_target->retry_cnt = nla_get_u32(iter2);
+					}
+				}
+				/* convert to chanspec value */
+				rtt_target->chanspec = dhd_rtt_convert_to_chspec(rtt_target->channel);
+				if (rtt_target->chanspec == 0) {
+					WL_ERR(("Channel is not valid \n"));
+					goto exit;
+				}
+				WL_INFORM(("Target addr %s, Channel : %s for RTT \n",
+					bcm_ether_ntoa((const struct ether_addr *)&rtt_target->addr, eabuf),
+					wf_chspec_ntoa(rtt_target->chanspec, chanbuf)));
+				rtt_target++;
+			}
+			break;
+		}
+	}
+	WL_DBG(("leave :target_cnt : %d\n", rtt_param.rtt_target_cnt));
+	if (dhd_dev_rtt_set_cfg(bcmcfg_to_prmry_ndev(cfg), &rtt_param) < 0) {
+		WL_ERR(("Could not set RTT configuration\n"));
+		err = -EINVAL;
+	}
+exit:
+	return err;
+}
+
+static int wl_cfgvendor_rtt_cancel_config(struct wiphy *wiphy, struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	int err = 0, rem, type, target_cnt = 0;
+	const struct nlattr *iter;
+	struct ether_addr *mac_list = NULL, *mac_addr = NULL;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case RTT_ATTRIBUTE_TARGET_CNT:
+			target_cnt = nla_get_u8(iter);
+			mac_list = (struct ether_addr *)kzalloc(target_cnt * ETHER_ADDR_LEN , GFP_KERNEL);
+			if (mac_list == NULL) {
+				WL_ERR(("failed to allocate mem for mac list\n"));
+				goto exit;
+			}
+			mac_addr = &mac_list[0];
+			break;
+		case RTT_ATTRIBUTE_TARGET_MAC:
+			if (mac_addr)
+				memcpy(mac_addr++, nla_data(iter), ETHER_ADDR_LEN);
+			else {
+				WL_ERR(("mac_list is NULL\n"));
+				goto exit;
+			}
+			break;
+		}
+		if (dhd_dev_rtt_cancel_cfg(bcmcfg_to_prmry_ndev(cfg), mac_list, target_cnt) < 0) {
+			WL_ERR(("Could not cancel RTT configuration\n"));
+			err = -EINVAL;
+			goto exit;
+		}
+	}
+exit:
+	if (mac_list)
+		kfree(mac_list);
+	return err;
+}
+static int wl_cfgvendor_rtt_get_capability(struct wiphy *wiphy, struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	rtt_capabilities_t capability;
+
+	err = dhd_dev_rtt_capability(bcmcfg_to_prmry_ndev(cfg), &capability);
+	if (unlikely(err)) {
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+		goto exit;
+	}
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
+	        &capability, sizeof(capability));
+
+	if (unlikely(err)) {
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+	}
+exit:
+	return err;
+}
+
+#endif /* RTT_SUPPORT */
+static int wl_cfgvendor_priv_string_handler(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+	int err = 0;
+	u8 resp[1] = {'\0'};
+
+	DBG_871X_LEVEL(_drv_always_, FUNC_NDEV_FMT" %s\n", FUNC_NDEV_ARG(wdev_to_ndev(wdev)), (char*)data);
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, wdev_to_ndev(wdev), resp, 1);
+	if (unlikely(err))
+		DBG_871X_LEVEL(_drv_err_, FUNC_NDEV_FMT"Vendor Command reply failed ret:%d \n"
+			, FUNC_NDEV_ARG(wdev_to_ndev(wdev)), err);
+
+	return err;
+#if 0
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	int err = 0;
+	int data_len = 0;
+
+	bzero(cfg->ioctl_buf, WLC_IOCTL_MAXLEN);
+
+	if (strncmp((char *)data, BRCM_VENDOR_SCMD_CAPA, strlen(BRCM_VENDOR_SCMD_CAPA)) == 0) {
+		err = wldev_iovar_getbuf(bcmcfg_to_prmry_ndev(cfg), "cap", NULL, 0,
+			cfg->ioctl_buf, WLC_IOCTL_MAXLEN, &cfg->ioctl_buf_sync);
+		if (unlikely(err)) {
+			WL_ERR(("error (%d)\n", err));
+			return err;
+		}
+		data_len = strlen(cfg->ioctl_buf);
+		cfg->ioctl_buf[data_len] = '\0';
+	}
+
+	err =  rtw_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
+		cfg->ioctl_buf, data_len+1);
+	if (unlikely(err))
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+	else
+		WL_INFORM(("Vendor Command reply sent successfully!\n"));
+
+	return err;
+#endif
+}
+
+static const struct wiphy_vendor_command rtw_vendor_cmds [] = {
+	{
+		{
+			.vendor_id = OUI_BRCM,
+			.subcmd = BRCM_VENDOR_SCMD_PRIV_STR
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_priv_string_handler
+	},
+#if defined(GSCAN_SUPPORT) && 0
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_GET_CAPABILITIES
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_gscan_get_capabilities
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_SET_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_set_scan_cfg
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_SET_SCAN_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_set_batch_scan_cfg
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_ENABLE_GSCAN
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_initiate_gscan
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_enable_full_scan_result
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_SET_HOTLIST
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_hotlist_cfg
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_significant_change_cfg
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_GET_SCAN_RESULTS
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_gscan_get_batch_results
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = GSCAN_SUBCMD_GET_CHANNEL_LIST
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_gscan_get_channel_list
+	},
+#endif /* GSCAN_SUPPORT */
+#if defined(RTT_SUPPORT) && 0
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = RTT_SUBCMD_SET_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_rtt_set_config
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = RTT_SUBCMD_CANCEL_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_rtt_cancel_config
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = RTT_SUBCMD_GETCAPABILITY
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_rtt_get_capability
+	},
+#endif /* RTT_SUPPORT */
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = ANDR_WIFI_SUBCMD_GET_FEATURE_SET
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = rtw_cfgvendor_get_feature_set
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = ANDR_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = rtw_cfgvendor_get_feature_set_matrix
+	}
+};
+
+static const struct  nl80211_vendor_cmd_info rtw_vendor_events [] = {
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_UNSPEC },
+		{ OUI_BRCM, BRCM_VENDOR_EVENT_PRIV_STR },
+#if defined(GSCAN_SUPPORT) && 0
+		{ OUI_GOOGLE, GOOGLE_GSCAN_SIGNIFICANT_EVENT },
+		{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT },
+		{ OUI_GOOGLE, GOOGLE_GSCAN_BATCH_SCAN_EVENT },
+		{ OUI_GOOGLE, GOOGLE_SCAN_FULL_RESULTS_EVENT },
+#endif /* GSCAN_SUPPORT */
+#if defined(RTT_SUPPORT) && 0
+		{ OUI_GOOGLE, GOOGLE_RTT_COMPLETE_EVENT },
+#endif /* RTT_SUPPORT */
+#if defined(GSCAN_SUPPORT) && 0
+		{ OUI_GOOGLE, GOOGLE_SCAN_COMPLETE_EVENT },
+		{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_LOST_EVENT }
+#endif /* GSCAN_SUPPORT */
+};
+
+int rtw_cfgvendor_attach(struct wiphy *wiphy)
+{
+
+	DBG_871X("Register RTW cfg80211 vendor cmd(0x%x) interface \n", NL80211_CMD_VENDOR);
+
+	wiphy->vendor_commands	= rtw_vendor_cmds;
+	wiphy->n_vendor_commands = ARRAY_SIZE(rtw_vendor_cmds);
+	wiphy->vendor_events	= rtw_vendor_events;
+	wiphy->n_vendor_events	= ARRAY_SIZE(rtw_vendor_events);
+
+	return 0;
+}
+
+int rtw_cfgvendor_detach(struct wiphy *wiphy)
+{
+	DBG_871X("Vendor: Unregister RTW cfg80211 vendor interface \n");
+
+	wiphy->vendor_commands  = NULL;
+	wiphy->vendor_events    = NULL;
+	wiphy->n_vendor_commands = 0;
+	wiphy->n_vendor_events  = 0;
+
+	return 0;
+}
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT) */
+
+#endif /* CONFIG_IOCTL_CFG80211 */
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_cfgvendor.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_cfgvendor.h
new file mode 100644
index 000000000000..7c349e79daa2
--- /dev/null
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_cfgvendor.h
@@ -0,0 +1,246 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2014 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef _RTW_CFGVENDOR_H_
+#define _RTW_CFGVENDOR_H_
+
+#define OUI_BRCM    0x001018
+#define OUI_GOOGLE  0x001A11
+#define BRCM_VENDOR_SUBCMD_PRIV_STR	1
+#define ATTRIBUTE_U32_LEN                  (NLA_HDRLEN  + 4)
+#define VENDOR_ID_OVERHEAD                 ATTRIBUTE_U32_LEN
+#define VENDOR_SUBCMD_OVERHEAD             ATTRIBUTE_U32_LEN
+#define VENDOR_DATA_OVERHEAD               (NLA_HDRLEN)
+
+#define SCAN_RESULTS_COMPLETE_FLAG_LEN       ATTRIBUTE_U32_LEN
+#define SCAN_INDEX_HDR_LEN                   (NLA_HDRLEN)
+#define SCAN_ID_HDR_LEN                      ATTRIBUTE_U32_LEN
+#define SCAN_FLAGS_HDR_LEN                   ATTRIBUTE_U32_LEN
+#define GSCAN_NUM_RESULTS_HDR_LEN            ATTRIBUTE_U32_LEN
+#define GSCAN_RESULTS_HDR_LEN                (NLA_HDRLEN)
+#define GSCAN_BATCH_RESULT_HDR_LEN  (SCAN_INDEX_HDR_LEN + SCAN_ID_HDR_LEN + \
+									SCAN_FLAGS_HDR_LEN + \
+							        GSCAN_NUM_RESULTS_HDR_LEN + \
+									GSCAN_RESULTS_HDR_LEN)
+
+#define VENDOR_REPLY_OVERHEAD       (VENDOR_ID_OVERHEAD + \
+									VENDOR_SUBCMD_OVERHEAD + \
+									VENDOR_DATA_OVERHEAD)
+typedef enum {
+	/* don't use 0 as a valid subcommand */
+	VENDOR_NL80211_SUBCMD_UNSPECIFIED,
+
+	/* define all vendor startup commands between 0x0 and 0x0FFF */
+	VENDOR_NL80211_SUBCMD_RANGE_START = 0x0001,
+	VENDOR_NL80211_SUBCMD_RANGE_END   = 0x0FFF,
+
+	/* define all GScan related commands between 0x1000 and 0x10FF */
+	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START = 0x1000,
+	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_END   = 0x10FF,
+
+	/* define all NearbyDiscovery related commands between 0x1100 and 0x11FF */
+	ANDROID_NL80211_SUBCMD_NBD_RANGE_START = 0x1100,
+	ANDROID_NL80211_SUBCMD_NBD_RANGE_END   = 0x11FF,
+
+	/* define all RTT related commands between 0x1100 and 0x11FF */
+	ANDROID_NL80211_SUBCMD_RTT_RANGE_START = 0x1100,
+	ANDROID_NL80211_SUBCMD_RTT_RANGE_END   = 0x11FF,
+
+	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START = 0x1200,
+	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_END   = 0x12FF,
+
+	ANDROID_NL80211_SUBCMD_TDLS_RANGE_START = 0x1300,
+	ANDROID_NL80211_SUBCMD_TDLS_RANGE_END	= 0x13FF,
+	/* This is reserved for future usage */
+
+} ANDROID_VENDOR_SUB_COMMAND;
+
+enum wl_vendor_subcmd {
+	BRCM_VENDOR_SCMD_UNSPEC,
+	BRCM_VENDOR_SCMD_PRIV_STR,
+	GSCAN_SUBCMD_GET_CAPABILITIES = ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START,
+	GSCAN_SUBCMD_SET_CONFIG,
+	GSCAN_SUBCMD_SET_SCAN_CONFIG,
+	GSCAN_SUBCMD_ENABLE_GSCAN,
+	GSCAN_SUBCMD_GET_SCAN_RESULTS,
+	GSCAN_SUBCMD_SCAN_RESULTS,
+	GSCAN_SUBCMD_SET_HOTLIST,
+	GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,
+	GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS,
+	GSCAN_SUBCMD_GET_CHANNEL_LIST,
+	ANDR_WIFI_SUBCMD_GET_FEATURE_SET,
+	ANDR_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX,
+	RTT_SUBCMD_SET_CONFIG = ANDROID_NL80211_SUBCMD_RTT_RANGE_START,
+	RTT_SUBCMD_CANCEL_CONFIG,
+	RTT_SUBCMD_GETCAPABILITY,
+    /* Add more sub commands here */
+    VENDOR_SUBCMD_MAX
+};
+
+enum gscan_attributes {
+    GSCAN_ATTRIBUTE_NUM_BUCKETS = 10,
+    GSCAN_ATTRIBUTE_BASE_PERIOD,
+    GSCAN_ATTRIBUTE_BUCKETS_BAND,
+    GSCAN_ATTRIBUTE_BUCKET_ID,
+    GSCAN_ATTRIBUTE_BUCKET_PERIOD,
+    GSCAN_ATTRIBUTE_BUCKET_NUM_CHANNELS,
+    GSCAN_ATTRIBUTE_BUCKET_CHANNELS,
+    GSCAN_ATTRIBUTE_NUM_AP_PER_SCAN,
+    GSCAN_ATTRIBUTE_REPORT_THRESHOLD,
+    GSCAN_ATTRIBUTE_NUM_SCANS_TO_CACHE,
+    GSCAN_ATTRIBUTE_BAND = GSCAN_ATTRIBUTE_BUCKETS_BAND,
+
+    GSCAN_ATTRIBUTE_ENABLE_FEATURE = 20,
+    GSCAN_ATTRIBUTE_SCAN_RESULTS_COMPLETE,
+    GSCAN_ATTRIBUTE_FLUSH_FEATURE,
+    GSCAN_ATTRIBUTE_ENABLE_FULL_SCAN_RESULTS,
+    GSCAN_ATTRIBUTE_REPORT_EVENTS,
+    /* remaining reserved for additional attributes */
+    GSCAN_ATTRIBUTE_NUM_OF_RESULTS = 30,
+    GSCAN_ATTRIBUTE_FLUSH_RESULTS,
+    GSCAN_ATTRIBUTE_SCAN_RESULTS,                       /* flat array of wifi_scan_result */
+    GSCAN_ATTRIBUTE_SCAN_ID,                            /* indicates scan number */
+    GSCAN_ATTRIBUTE_SCAN_FLAGS,                         /* indicates if scan was aborted */
+    GSCAN_ATTRIBUTE_AP_FLAGS,                           /* flags on significant change event */
+    GSCAN_ATTRIBUTE_NUM_CHANNELS,
+    GSCAN_ATTRIBUTE_CHANNEL_LIST,
+
+	/* remaining reserved for additional attributes */
+
+    GSCAN_ATTRIBUTE_SSID = 40,
+    GSCAN_ATTRIBUTE_BSSID,
+    GSCAN_ATTRIBUTE_CHANNEL,
+    GSCAN_ATTRIBUTE_RSSI,
+    GSCAN_ATTRIBUTE_TIMESTAMP,
+    GSCAN_ATTRIBUTE_RTT,
+    GSCAN_ATTRIBUTE_RTTSD,
+
+    /* remaining reserved for additional attributes */
+
+    GSCAN_ATTRIBUTE_HOTLIST_BSSIDS = 50,
+    GSCAN_ATTRIBUTE_RSSI_LOW,
+    GSCAN_ATTRIBUTE_RSSI_HIGH,
+    GSCAN_ATTRIBUTE_HOSTLIST_BSSID_ELEM,
+    GSCAN_ATTRIBUTE_HOTLIST_FLUSH,
+
+    /* remaining reserved for additional attributes */
+    GSCAN_ATTRIBUTE_RSSI_SAMPLE_SIZE = 60,
+    GSCAN_ATTRIBUTE_LOST_AP_SAMPLE_SIZE,
+    GSCAN_ATTRIBUTE_MIN_BREACHING,
+    GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_BSSIDS,
+    GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH,
+    GSCAN_ATTRIBUTE_MAX
+};
+
+enum gscan_bucket_attributes {
+	GSCAN_ATTRIBUTE_CH_BUCKET_1,
+	GSCAN_ATTRIBUTE_CH_BUCKET_2,
+	GSCAN_ATTRIBUTE_CH_BUCKET_3,
+	GSCAN_ATTRIBUTE_CH_BUCKET_4,
+	GSCAN_ATTRIBUTE_CH_BUCKET_5,
+	GSCAN_ATTRIBUTE_CH_BUCKET_6,
+	GSCAN_ATTRIBUTE_CH_BUCKET_7
+};
+
+enum gscan_ch_attributes {
+	GSCAN_ATTRIBUTE_CH_ID_1,
+	GSCAN_ATTRIBUTE_CH_ID_2,
+	GSCAN_ATTRIBUTE_CH_ID_3,
+	GSCAN_ATTRIBUTE_CH_ID_4,
+	GSCAN_ATTRIBUTE_CH_ID_5,
+	GSCAN_ATTRIBUTE_CH_ID_6,
+	GSCAN_ATTRIBUTE_CH_ID_7
+};
+
+enum rtt_attributes {
+	RTT_ATTRIBUTE_TARGET_CNT,
+	RTT_ATTRIBUTE_TARGET_INFO,
+	RTT_ATTRIBUTE_TARGET_MAC,
+	RTT_ATTRIBUTE_TARGET_TYPE,
+	RTT_ATTRIBUTE_TARGET_PEER,
+	RTT_ATTRIBUTE_TARGET_CHAN,
+	RTT_ATTRIBUTE_TARGET_MODE,
+	RTT_ATTRIBUTE_TARGET_INTERVAL,
+	RTT_ATTRIBUTE_TARGET_NUM_MEASUREMENT,
+	RTT_ATTRIBUTE_TARGET_NUM_PKT,
+	RTT_ATTRIBUTE_TARGET_NUM_RETRY
+};
+
+typedef enum wl_vendor_event {
+	BRCM_VENDOR_EVENT_UNSPEC,
+	BRCM_VENDOR_EVENT_PRIV_STR,
+	GOOGLE_GSCAN_SIGNIFICANT_EVENT,
+	GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT,
+	GOOGLE_GSCAN_BATCH_SCAN_EVENT,
+	GOOGLE_SCAN_FULL_RESULTS_EVENT,
+	GOOGLE_RTT_COMPLETE_EVENT,
+	GOOGLE_SCAN_COMPLETE_EVENT,
+	GOOGLE_GSCAN_GEOFENCE_LOST_EVENT
+} wl_vendor_event_t;
+
+enum andr_wifi_feature_set_attr {
+    ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET,
+    ANDR_WIFI_ATTRIBUTE_FEATURE_SET
+};
+
+typedef enum wl_vendor_gscan_attribute {
+	ATTR_START_GSCAN,
+	ATTR_STOP_GSCAN,
+	ATTR_SET_SCAN_BATCH_CFG_ID, /* set batch scan params */
+	ATTR_SET_SCAN_GEOFENCE_CFG_ID, /* set list of bssids to track */
+	ATTR_SET_SCAN_SIGNIFICANT_CFG_ID, /* set list of bssids, rssi threshold etc.. */
+	ATTR_SET_SCAN_CFG_ID, /* set common scan config params here */
+	ATTR_GET_GSCAN_CAPABILITIES_ID,
+    /* Add more sub commands here */
+    ATTR_GSCAN_MAX
+} wl_vendor_gscan_attribute_t;
+
+typedef enum gscan_batch_attribute {
+	ATTR_GSCAN_BATCH_BESTN,
+	ATTR_GSCAN_BATCH_MSCAN,
+	ATTR_GSCAN_BATCH_BUFFER_THRESHOLD
+} gscan_batch_attribute_t;
+
+typedef enum gscan_geofence_attribute {
+	ATTR_GSCAN_NUM_HOTLIST_BSSID,
+	ATTR_GSCAN_HOTLIST_BSSID
+} gscan_geofence_attribute_t;
+
+typedef enum gscan_complete_event {
+	WIFI_SCAN_BUFFER_FULL,
+	WIFI_SCAN_COMPLETE
+} gscan_complete_event_t;
+
+/* Capture the BRCM_VENDOR_SUBCMD_PRIV_STRINGS* here */
+#define BRCM_VENDOR_SCMD_CAPA	"cap"
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT)
+extern int rtw_cfgvendor_attach(struct wiphy *wiphy);
+extern int rtw_cfgvendor_detach(struct wiphy *wiphy);
+extern int rtw_cfgvendor_send_async_event(struct wiphy *wiphy,
+                  struct net_device *dev, int event_id, const void  *data, int len);
+#if defined(GSCAN_SUPPORT) && 0
+extern int wl_cfgvendor_send_hotlist_event(struct wiphy *wiphy,
+                struct net_device *dev, void  *data, int len, wl_vendor_event_t event);
+#endif
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) || defined(RTW_VENDOR_EXT_SUPPORT) */
+
+#endif /* _RTW_CFGVENDOR_H_ */
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_proc.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_proc.c
index af10d8e082ea..c752173b69cd 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_proc.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_proc.c
@@ -19,6 +19,7 @@
  ******************************************************************************/
 
 #include <drv_types.h>
+#include <hal_data.h>
 #include "rtw_proc.h"
 
 #ifdef CONFIG_PROC_DEBUG
@@ -69,9 +70,9 @@ inline struct proc_dir_entry *rtw_proc_create_entry(const char *name, struct pro
 	struct proc_dir_entry *entry;
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
-	entry = proc_create_data(name,  S_IFREG|S_IRUGO, parent, fops, data);
+	entry = proc_create_data(name,  S_IFREG|S_IRUGO|S_IWUGO, parent, fops, data);
 #else
-	entry = create_proc_entry(name, S_IFREG|S_IRUGO, parent);
+	entry = create_proc_entry(name, S_IFREG|S_IRUGO|S_IWUGO, parent);
 	if (entry) {
 		entry->data = data;
 		entry->proc_fops = fops;
@@ -261,14 +262,93 @@ static int proc_get_rf_reg_dump(struct seq_file *m, void *v)
 
 	return 0;
 }
-static int proc_get_linked_info_dump(struct seq_file *m, void *v)
+
+
+//gpio setting
+#ifdef CONFIG_GPIO_API
+static ssize_t proc_set_config_gpio(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32]={0}; 
+	int num=0,gpio_pin=0,gpio_mode=0;//gpio_mode:0 input  1:output;
+	
+	if (count < 2)
+		return -EFAULT;
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) 
+	{
+		num	=sscanf(tmp, "%d %d",&gpio_pin,&gpio_mode);
+		DBG_871X("num=%d gpio_pin=%d mode=%d\n",num,gpio_pin,gpio_mode);
+      		padapter->pre_gpio_pin=gpio_pin;
+
+		if(gpio_mode==0 || gpio_mode==1  )
+			rtw_hal_config_gpio(padapter, gpio_pin,gpio_mode);	
+	}
+	return count;
+
+}
+static ssize_t proc_set_gpio_output_value(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32]={0}; 
+	int num=0,gpio_pin=0,pin_mode=0;//pin_mode: 1 high         0:low
+	
+	if (count < 2)
+		return -EFAULT;
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) 
+	{
+		num	=sscanf(tmp, "%d %d",&gpio_pin,&pin_mode);
+		DBG_871X("num=%d gpio_pin=%d pin_high=%d\n",num,gpio_pin,pin_mode);
+		padapter->pre_gpio_pin=gpio_pin;
+		
+		if(pin_mode==0 || pin_mode==1  )
+			rtw_hal_set_gpio_output_value(padapter, gpio_pin,pin_mode);	
+	}
+	return count;
+}
+static int proc_get_gpio(struct seq_file *m, void *v)
+{
+	u8 gpioreturnvalue=0;
 	struct net_device *dev = m->private;
+	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	if(!padapter)	
+		return -EFAULT;
+	gpioreturnvalue = rtw_hal_get_gpio(padapter, padapter->pre_gpio_pin);
+	DBG_871X_SEL_NL(m, "get_gpio %d:%d \n",padapter->pre_gpio_pin ,gpioreturnvalue);
 	
-	if(padapter)
-		DBG_871X_SEL_NL(m, "linked_info_dump :%s \n", (padapter->bLinkInfoDump)?"enable":"disable");
+	return 0;
+
+}
+static ssize_t proc_set_gpio(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32]={0}; 
+	int num=0,gpio_pin=0;
+	
+	if (count < 1)
+		return -EFAULT;
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) 
+	{
+		num	=sscanf(tmp, "%d",&gpio_pin);
+		DBG_871X("num=%d gpio_pin=%d\n",num,gpio_pin);
+		padapter->pre_gpio_pin=gpio_pin;
+		
+	}
+		return count;
+}
+#endif
+
 
+static int proc_get_linked_info_dump(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	if(padapter)	
+		DBG_871X_SEL_NL(m, "linked_info_dump :%s \n", (padapter->bLinkInfoDump)?"enable":"disable");
+	
 	return 0;
 }
 
@@ -276,28 +356,40 @@ static ssize_t proc_set_linked_info_dump(struct file *file, const char __user *b
 {
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	
-	char tmp[2];
-	int mode=0;
+
+	char tmp[32]={0}; 
+	int mode=0,pre_mode=0;
+	int num=0;	
 
 	if (count < 1)
 		return -EFAULT;
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+	pre_mode=padapter->bLinkInfoDump;
+	DBG_871X("pre_mode=%d \n",pre_mode);
 
-		int num = sscanf(tmp, "%d ", &mode);
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) 
+	{
+		num	=sscanf(tmp, "%d ", &mode);
+		DBG_871X("num=%d mode=%d\n",num,mode);
 
-		if( padapter )
+		if(num!=1)
 		{
-			//padapter->bLinkInfoDump = mode;
-			//DBG_871X("linked_info_dump =%s \n", (padapter->bLinkInfoDump)?"enable":"disable");
-			 linked_info_dump(padapter,mode);		
+			DBG_871X("argument number is wrong\n");
+				return -EFAULT;
 		}
-
-	}
 	
+		if(mode==1 || (mode==0 && pre_mode==1) ) //not consider pwr_saving 0:
+		{
+			padapter->bLinkInfoDump = mode;	
+		
+		}
+		else if( (mode==2 ) || (mode==0 && pre_mode==2))//consider power_saving
+		{		
+			//DBG_871X("linked_info_dump =%s \n", (padapter->bLinkInfoDump)?"enable":"disable")
+			linked_info_dump(padapter,mode);	
+		}
+	}
 	return count;
-	
 }
 
 int proc_get_rx_info(struct seq_file *m, void *v)
@@ -318,6 +410,167 @@ int proc_get_rx_info(struct seq_file *m, void *v)
 	return 0;
 }	
 
+static int proc_get_mac_qinfo(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	rtw_hal_get_hwreg(adapter, HW_VAR_DUMP_MAC_QUEUE_INFO, (u8 *)m);
+
+	return 0;
+}
+
+ssize_t proc_reset_rx_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct dvobj_priv *psdpriv = padapter->dvobj;
+	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
+	char cmd[32];
+	if (buffer && !copy_from_user(cmd, buffer, sizeof(cmd))) {
+		if('0' == cmd[0]){
+			pdbgpriv->dbg_rx_ampdu_drop_count = 0;
+			pdbgpriv->dbg_rx_ampdu_forced_indicate_count = 0;
+			pdbgpriv->dbg_rx_ampdu_loss_count = 0;
+			pdbgpriv->dbg_rx_dup_mgt_frame_drop_count = 0;
+			pdbgpriv->dbg_rx_ampdu_window_shift_cnt = 0;
+		}
+	}
+
+	return count;
+}
+
+int proc_get_wifi_spec(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	
+	DBG_871X_SEL_NL(m,"wifi_spec=%d\n",pregpriv->wifi_spec);
+	return 0;
+}
+
+static int proc_get_chan_plan(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	DBG_871X_SEL_NL(m,"Channel plan=0x%02x\n",padapter->mlmepriv.ChannelPlan);	
+	return 0;
+}
+static ssize_t proc_set_chan_plan(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct SetChannelPlan_param setChannelPlan_param;
+	
+	char tmp[32];
+	u8 chan_plan = RT_CHANNEL_DOMAIN_REALTEK_DEFINE;
+	
+	if (!padapter)
+		return -EFAULT;
+
+	if (count < 1)
+	{
+		DBG_871X("argument size is less than 1\n");
+		return -EFAULT;
+	}	
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%hhx", &chan_plan);
+
+		if (num !=  1) {
+			DBG_871X("invalid read_reg parameter!\n");
+			return count;
+		}
+
+	}
+	setChannelPlan_param.channel_plan = chan_plan;
+	if( H2C_SUCCESS != set_chplan_hdl(padapter, (unsigned char *)&setChannelPlan_param) )
+		return -EFAULT;
+		
+	return count;
+
+}
+
+static int proc_get_udpport(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	DBG_871X_SEL_NL(m,"%d\n",precvpriv->sink_udpport);	
+	return 0;
+}
+static ssize_t proc_set_udpport(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+	int sink_udpport = 0;	
+	char tmp[32];
+	
+	
+	if (!padapter)
+		return -EFAULT;
+
+	if (count < 1)
+	{
+		DBG_871X("argument size is less than 1\n");
+		return -EFAULT;
+	}	
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%d", &sink_udpport);
+
+		if (num !=  1) {
+			DBG_871X("invalid input parameter number!\n");
+			return count;
+		}
+
+	}
+	precvpriv->sink_udpport = sink_udpport;
+	
+	return count;
+
+}
+
+static int proc_get_macid_info(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct macid_ctl_t *macid_ctl = dvobj_to_macidctl(dvobj);
+	u8 i;
+
+	DBG_871X_SEL_NL(m, "max_num:%u\n", macid_ctl->num);
+	DBG_871X_SEL_NL(m, "\n");
+
+	DBG_871X_SEL_NL(m, "used:\n");
+	dump_macid_map(m, &macid_ctl->used, macid_ctl->num);
+	DBG_871X_SEL_NL(m, "\n");
+
+	DBG_871X_SEL_NL(m, "%-3s %-3s %-4s %-4s"
+		"\n"
+		, "id", "bmc", "if_g", "ch_g"
+	);
+
+	for (i=0;i<macid_ctl->num;i++) {
+		if (rtw_macid_is_used(macid_ctl, i))
+			DBG_871X_SEL_NL(m, "%3u %3u %4d %4d"
+				"\n"
+				, i
+				, rtw_macid_is_bmc(macid_ctl, i)
+				, rtw_macid_get_if_g(macid_ctl, i)
+				, rtw_macid_get_ch_g(macid_ctl, i)
+			);
+	}
+
+	return 0;
+}
+
 static int proc_get_cam(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -397,6 +650,38 @@ static int proc_get_cam_cache(struct seq_file *m, void *v)
 	return 0;
 }
 
+#ifdef CONFIG_BT_COEXIST
+ssize_t proc_set_btinfo_evt(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u8 btinfo[8];
+
+	if (count < 6)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+		int num = 0;
+
+		_rtw_memset(btinfo, 0, 8);
+		
+		num = sscanf(tmp, "%hhx %hhx %hhx %hhx %hhx %hhx %hhx %hhx"
+			, &btinfo[0], &btinfo[1], &btinfo[2], &btinfo[3]
+			, &btinfo[4], &btinfo[5], &btinfo[6], &btinfo[7]);
+
+		if (num < 6)
+			return -EINVAL;
+
+		btinfo[1] = num-2;
+
+		rtw_btinfo_cmd(padapter, btinfo, btinfo[1]+2);
+	}
+	
+	return count;
+}
+#endif
+
 /*
 * rtw_adapter_proc:
 * init/deinit when register/unregister net_device
@@ -415,11 +700,14 @@ const struct rtw_proc_hdl adapter_proc_hdls [] = {
 	{"adapter_state", proc_get_adapter_state, NULL},
 	{"trx_info", proc_get_trx_info, NULL},
 	{"rate_ctl", proc_get_rate_ctl, proc_set_rate_ctl},
+	{"dis_pwt_ctl", proc_get_dis_pwt, proc_set_dis_pwt},
+	{"mac_qinfo", proc_get_mac_qinfo, NULL},
+	{"macid_info", proc_get_macid_info, NULL},
 	{"cam", proc_get_cam, proc_set_cam},
 	{"cam_cache", proc_get_cam_cache, NULL},
 	{"suspend_info", proc_get_suspend_resume_info, NULL},
-	{"rx_info", proc_get_rx_info,NULL},
-
+	{"rx_info", proc_get_rx_info, proc_reset_rx_info},
+	{"wifi_spec",proc_get_wifi_spec,NULL},
 #ifdef CONFIG_LAYER2_ROAMING
 	{"roam_flags", proc_get_roam_flags, proc_set_roam_flags},
 	{"roam_param", proc_get_roam_param, proc_set_roam_param},
@@ -458,22 +746,49 @@ const struct rtw_proc_hdl adapter_proc_hdls [] = {
 	{"ampdu_enable", proc_get_ampdu_enable, proc_set_ampdu_enable},
 	{"rx_stbc", proc_get_rx_stbc, proc_set_rx_stbc},
 	{"rx_ampdu", proc_get_rx_ampdu, proc_set_rx_ampdu},
+	{"rx_ampdu_factor",proc_get_rx_ampdu_factor,proc_set_rx_ampdu_factor},
+	{"rx_ampdu_density",proc_get_rx_ampdu_density,proc_set_rx_ampdu_density},
+	{"tx_ampdu_density",proc_get_tx_ampdu_density,proc_set_tx_ampdu_density},	 
 #endif /* CONFIG_80211N_HT */
 
 	{"en_fwps", proc_get_en_fwps, proc_set_en_fwps},
 
 	//{"path_rssi", proc_get_two_path_rssi, NULL},
-	{"rssi_disp",proc_get_rssi_disp, proc_set_rssi_disp},
+//	{"rssi_disp",proc_get_rssi_disp, proc_set_rssi_disp},
 
 #ifdef CONFIG_BT_COEXIST
 	{"btcoex_dbg", proc_get_btcoex_dbg, proc_set_btcoex_dbg},
 	{"btcoex", proc_get_btcoex_info, NULL},
+	{"btinfo_evt", proc_get_dummy, proc_set_btinfo_evt},
 #endif /* CONFIG_BT_COEXIST */
 
 #if defined(DBG_CONFIG_ERROR_DETECT)
 	{"sreset", proc_get_sreset, proc_set_sreset},
 #endif /* DBG_CONFIG_ERROR_DETECT */
 	{"linked_info_dump",proc_get_linked_info_dump,proc_set_linked_info_dump},
+
+#ifdef CONFIG_GPIO_API
+	{"get_gpio",proc_get_gpio,proc_set_gpio},
+	{"set_gpio_output_value",proc_get_dummy,proc_set_gpio_output_value},
+	{"config_gpio",proc_get_dummy,proc_set_config_gpio},
+#endif
+
+#ifdef CONFIG_DBG_COUNTER
+	{"rx_logs", proc_get_rx_logs, NULL},
+	{"tx_logs", proc_get_tx_logs, NULL},
+	{"int_logs", proc_get_int_logs, NULL},
+#endif
+
+#ifdef CONFIG_PCI_HCI
+	{"rx_ring", proc_get_rx_ring, NULL},
+	{"tx_ring", proc_get_tx_ring, NULL},
+#endif
+#ifdef CONFIG_P2P_WOWLAN
+	{"p2p_wowlan_info", proc_get_p2p_wowlan_info, NULL},
+#endif
+	{"chan_plan",proc_get_chan_plan,proc_set_chan_plan},
+	{"new_bcn_max", proc_get_new_bcn_max, proc_set_new_bcn_max},
+	{"sink_udpport",proc_get_udpport,proc_set_udpport},
 };
 
 const int adapter_proc_hdls_num = sizeof(adapter_proc_hdls) / sizeof(struct rtw_proc_hdl);
@@ -648,6 +963,78 @@ ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, si
 	return count;
 }
 
+static char *phydm_msg = NULL;
+#define PHYDM_MSG_LEN	80*24
+
+int proc_get_phydm_cmd(struct seq_file *m, void *v)
+{
+	struct net_device *netdev;
+	PADAPTER padapter;
+	PHAL_DATA_TYPE pHalData;
+	PDM_ODM_T phydm;
+
+
+	netdev = m->private;
+	padapter = (PADAPTER)rtw_netdev_priv(netdev);
+	pHalData = GET_HAL_DATA(padapter);
+	phydm = &pHalData->odmpriv;
+
+	if (NULL == phydm_msg) {
+		phydm_msg = rtw_zmalloc(PHYDM_MSG_LEN);
+		if (NULL == phydm_msg)
+			return -ENOMEM;
+
+		PhyDM_Cmd(phydm, NULL, 0, 0, phydm_msg, PHYDM_MSG_LEN);
+	}
+
+	DBG_871X_SEL(m, "%s\n", phydm_msg);
+
+	rtw_mfree(phydm_msg, PHYDM_MSG_LEN);
+	phydm_msg = NULL;
+
+	return 0;
+}
+
+ssize_t proc_set_phydm_cmd(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	struct net_device *netdev;
+	PADAPTER padapter;
+	PHAL_DATA_TYPE pHalData;
+	PDM_ODM_T phydm;
+	char tmp[64] = {0};
+
+
+	netdev = (struct net_device*)data;
+	padapter = (PADAPTER)rtw_netdev_priv(netdev);
+	pHalData = GET_HAL_DATA(padapter);
+	phydm = &pHalData->odmpriv;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (count > sizeof(tmp))
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, count)) {
+		if (NULL == phydm_msg) {
+			phydm_msg = rtw_zmalloc(PHYDM_MSG_LEN);
+			if (NULL == phydm_msg)
+				return -ENOMEM;
+		} else {
+			_rtw_memset(phydm_msg, 0, PHYDM_MSG_LEN);
+		}
+
+		PhyDM_Cmd(phydm, tmp, count, 1, phydm_msg, PHYDM_MSG_LEN);
+
+		if (strlen(phydm_msg) == 0) {
+			rtw_mfree(phydm_msg, PHYDM_MSG_LEN);
+			phydm_msg = NULL;
+		}
+	}
+
+	return count;
+}
+
 /*
 * rtw_odm_proc:
 * init/deinit when register/unregister net_device, along with rtw_adapter_proc
@@ -657,6 +1044,7 @@ const struct rtw_proc_hdl odm_proc_hdls [] = {
 	{"dbg_level", proc_get_odm_dbg_level, proc_set_odm_dbg_level},
 	{"ability", proc_get_odm_ability, proc_set_odm_ability},
 	{"adaptivity", proc_get_odm_adaptivity, proc_set_odm_adaptivity},
+	{"cmd", proc_get_phydm_cmd, proc_set_phydm_cmd},
 };
 
 const int odm_proc_hdls_num = sizeof(odm_proc_hdls) / sizeof(struct rtw_proc_hdl);
@@ -745,6 +1133,11 @@ void rtw_odm_proc_deinit(_adapter	*adapter)
 	remove_proc_entry("odm", adapter->dir_dev);
 
 	adapter->dir_odm = NULL;
+
+	if (phydm_msg) {
+		rtw_mfree(phydm_msg, PHYDM_MSG_LEN);
+		phydm_msg = NULL;
+	}
 }
 
 struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_proc.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_proc.h
index d45a28e2bb46..9aee7bf56f68 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_proc.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/rtw_proc.h
@@ -40,12 +40,12 @@ void rtw_adapter_proc_replace(struct net_device *dev);
 
 #else //!CONFIG_PROC_DEBUG
 
-struct proc_dir_entry *get_rtw_drv_proc(void) {return NULL;}
-int rtw_drv_proc_init(void) {return 0;}
-void rtw_drv_proc_deinit(void) {}
-struct proc_dir_entry *rtw_adapter_proc_init(struct net_device *dev){return NULL;}
-void rtw_adapter_proc_deinit(struct net_device *dev){}
-void rtw_adapter_proc_replace(struct net_device *dev){}
+#define get_rtw_drv_proc() NULL
+#define rtw_drv_proc_init() 0
+#define rtw_drv_proc_deinit() do {} while (0)
+#define rtw_adapter_proc_init(dev) NULL
+#define rtw_adapter_proc_deinit(dev) do {} while (0)
+#define rtw_adapter_proc_replace(dev) do {} while (0)
 
 #endif //!CONFIG_PROC_DEBUG
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/sdio_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/sdio_intf.c
index 87c89f281138..0e9d5ecae0e7 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/sdio_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/sdio_intf.c
@@ -26,6 +26,15 @@
 #error "CONFIG_SDIO_HCI shall be on!\n"
 #endif
 
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+#ifdef CONFIG_ACPI
+#include <linux/acpi.h>
+#include <linux/acpi_gpio.h>
+#include "rtw_android.h"
+#endif
+static int wlan_en_gpio = -1;
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
 #ifndef dev_to_sdio_func
 #define dev_to_sdio_func(d)     container_of(d, struct sdio_func, dev)
 #endif
@@ -45,20 +54,28 @@ static const struct sdio_device_id sdio_ids[] =
 #ifdef CONFIG_RTL8188E
 	{ SDIO_DEVICE(0x024c, 0x8179),.driver_data = RTL8188E},
 #endif //CONFIG_RTL8188E
+
 #ifdef CONFIG_RTL8821A
 	{ SDIO_DEVICE(0x024c, 0x8821),.driver_data = RTL8821},
-#endif //CONFIG_RTL8188E
+#endif //CONFIG_RTL8821A
+
+#ifdef CONFIG_RTL8192E
+	{ SDIO_DEVICE(0x024c, 0x818B),.driver_data = RTL8192E},
+#endif //CONFIG_RTL8192E
 
 #if defined(RTW_ENABLE_WIFI_CONTROL_FUNC) /* temporarily add this to accept all sdio wlan id */
 	{ SDIO_DEVICE_CLASS(SDIO_CLASS_WLAN) },
 #endif
-//	{ /* end: all zeroes */				},
+	{ /* end: all zeroes */				},
 };
 
+MODULE_DEVICE_TABLE(sdio, sdio_ids);
+
 static int rtw_drv_init(struct sdio_func *func, const struct sdio_device_id *id);
 static void rtw_dev_remove(struct sdio_func *func);
 static int rtw_sdio_resume(struct device *dev);
 static int rtw_sdio_suspend(struct device *dev);
+extern void rtw_dev_unload(PADAPTER padapter);
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)) 
 static const struct dev_pm_ops rtw_sdio_pm_ops = {
@@ -88,7 +105,6 @@ static void sd_sync_int_hdl(struct sdio_func *func)
 {
 	struct dvobj_priv *psdpriv;
 
-
 	psdpriv = sdio_get_drvdata(func);
 
 	if (!psdpriv->if1) {
@@ -157,6 +173,7 @@ void sdio_free_irq(struct dvobj_priv *dvobj)
 
 #ifdef CONFIG_GPIO_WAKEUP
 extern unsigned int oob_irq;
+extern unsigned int oob_gpio;
 static irqreturn_t gpio_hostwakeup_irq_thread(int irq, void *data)
 {
 	PADAPTER padapter = (PADAPTER)data;
@@ -174,8 +191,13 @@ static irqreturn_t gpio_hostwakeup_irq_thread(int irq, void *data)
 static u8 gpio_hostwakeup_alloc_irq(PADAPTER padapter)
 {
 	int err;
-	if (oob_irq == 0)
+	if (oob_irq == 0) {
+		DBG_871X("oob_irq ZERO!\n");
 		return _FAIL;
+	}
+
+	DBG_871X("%s : oob_irq = %d\n", __func__, oob_irq);
+	
 	/* dont set it IRQF_TRIGGER_LOW, or wowlan */
 	/* power is high after suspend */
 	/* and failing can prevent can not sleep issue if */
@@ -199,6 +221,8 @@ static u8 gpio_hostwakeup_alloc_irq(PADAPTER padapter)
 
 static void gpio_hostwakeup_free_irq(PADAPTER padapter)
 {
+	wifi_free_gpio(oob_gpio);
+
 	if (oob_irq == 0)
 		return;
 		
@@ -362,10 +386,22 @@ static void rtw_decide_chip_type_by_device_id(PADAPTER padapter, const struct sd
 		DBG_871X("CHIP TYPE: RTL8821A\n");
 	}
 #endif
+
+#if defined(CONFIG_RTL8192E)
+	if (padapter->chip_type == RTL8192E) {
+		padapter->HardwareType = HARDWARE_TYPE_RTL8192E;
+		DBG_871X("CHIP TYPE: RTL8192E\n");
+	}
+#endif
+
+
 }
 
 void rtw_set_hal_ops(PADAPTER padapter)
 {
+	//alloc memory for HAL DATA
+	rtw_hal_data_init(padapter);
+	
 #if defined(CONFIG_RTL8723A)
 	if( padapter->chip_type == RTL8723A){
 		rtl8723as_set_hal_ops(padapter);
@@ -386,6 +422,13 @@ void rtw_set_hal_ops(PADAPTER padapter)
 		rtl8821as_set_hal_ops(padapter);
 	}
 #endif
+
+#if defined(CONFIG_RTL8192E)
+	if(padapter->chip_type == RTL8192E){
+		rtl8192es_set_hal_ops(padapter);
+	}
+#endif
+
 }
 
 static void sd_intf_start(PADAPTER padapter)
@@ -615,6 +658,43 @@ static int rtw_drv_init(
 	PADAPTER if1 = NULL, if2 = NULL;
 	struct dvobj_priv *dvobj;
 
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+
+#ifdef CONFIG_ACPI
+        acpi_handle handle;
+        struct acpi_device *adev;
+#endif
+
+#if defined(CONFIG_ACPI) && defined(CONFIG_GPIO_WAKEUP)
+	handle = ACPI_HANDLE(&func->dev);
+
+	if (handle) {
+		/* Dont try to do acpi pm for the wifi module */
+		if (!handle || acpi_bus_get_device(handle, &adev))
+			DBG_871X("Could not get acpi pointer!\n");
+		else {
+			adev->flags.power_manageable = 0;
+			DBG_871X("Disabling ACPI power management support!\n");
+		}
+		oob_gpio = acpi_get_gpio_by_index(&func->dev, 0, NULL);
+		DBG_871X("rtw_drv_init: ACPI_HANDLE found oob_gpio %d!\n", oob_gpio);
+		wifi_configure_gpio();
+	}
+	else
+		DBG_871X("rtw_drv_init: ACPI_HANDLE NOT found!\n");
+#endif
+
+#if defined(CONFIG_ACPI)
+	if (&func->dev && ACPI_HANDLE(&func->dev)) {
+		wlan_en_gpio = acpi_get_gpio_by_index(&func->dev, 1, NULL);
+		DBG_871X("rtw_drv_init: ACPI_HANDLE found wlan_en %d!\n", wlan_en_gpio);
+	}
+	else
+		DBG_871X("rtw_drv_init: ACPI_HANDLE NOT found!\n");
+#endif
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
+
 	RT_TRACE(_module_hci_intfs_c_, _drv_info_,
 		("+rtw_drv_init: vendor=0x%04x device=0x%04x class=0x%02x\n",
 		func->vendor, func->device, func->class));
@@ -754,8 +834,6 @@ _func_exit_;
 extern int pm_netdev_open(struct net_device *pnetdev,u8 bnormal);
 extern int pm_netdev_close(struct net_device *pnetdev,u8 bnormal);
 
-
-#ifdef CONFIG_SUSPEND_REFINE	
 static int rtw_sdio_suspend(struct device *dev)
 {
 	struct sdio_func *func =dev_to_sdio_func(dev);
@@ -783,6 +861,7 @@ static int rtw_sdio_suspend(struct device *dev)
 
 exit:
 #ifdef CONFIG_RTW_SDIO_PM_KEEP_POWER 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
 	//Android 4.0 don't support WIFI close power
 	//or power down or clock will close after wifi resume,
 	//this is sprd's bug in Android 4.0, but sprd don't
@@ -801,6 +880,7 @@ static int rtw_sdio_suspend(struct device *dev)
 			sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
 		}
 	}
+#endif	
 #endif
 	return ret;
 }
@@ -809,7 +889,7 @@ int rtw_resume_process(_adapter *padapter)
 	struct pwrctrl_priv *pwrpriv = adapter_to_pwrctl(padapter);
 	struct dvobj_priv *psdpriv = padapter->dvobj;
 	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
-
+		
 	if (pwrpriv->bInSuspend == _FALSE)
 	{
 		pdbgpriv->dbg_resume_error_cnt++;
@@ -820,516 +900,6 @@ int rtw_resume_process(_adapter *padapter)
 	return rtw_resume_common(padapter);
 }
 
-
-#else //CONFIG_SUSPEND_REFINE
-static int rtw_sdio_suspend(struct device *dev)
-{
-	struct sdio_func *func =dev_to_sdio_func(dev);
-	struct dvobj_priv *psdpriv = sdio_get_drvdata(func);
-	struct pwrctrl_priv *pwrpriv = dvobj_to_pwrctl(psdpriv);
-	_adapter *padapter = psdpriv->if1;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct net_device *pnetdev = padapter->pnetdev;
-	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
-		
-	int ret = 0;
-#ifdef CONFIG_PLATFORM_SPRD
-	u32 value;
-#endif // CONFIG_PLATFORM_SPRD
-
-#ifdef CONFIG_WOWLAN
-	struct wowlan_ioctl_param poidparam;
-	u8 ch, bw, offset;
-	u8 ps_mode;
-#endif //CONFIG_WOWLAN
-
-	u32 start_time = rtw_get_current_time();
-
-	_func_enter_;
-
-	DBG_871X_LEVEL(_drv_always_, "sdio suspend start\n");
-	DBG_871X("==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
-	pdbgpriv->dbg_suspend_cnt++;
-	
-	if (pwrpriv->bInSuspend == _TRUE)
-	{
-		DBG_871X("%s bInSuspend = %d\n", __FUNCTION__, pwrpriv->bInSuspend);
-		pdbgpriv->dbg_suspend_error_cnt++;
-		goto exit;
-	}
-	
-	pwrpriv->bInSuspend = _TRUE;
-#ifdef CONFIG_PNO_SUPPORT
-	pwrpriv->pno_in_resume = _FALSE;
-#endif
-
-#ifdef CONFIG_WOWLAN
-	if (check_fwstate(pmlmepriv, _FW_LINKED))
-		pwrpriv->wowlan_mode = _TRUE;
-	else
-		pwrpriv->wowlan_mode = _FALSE;
-#endif
-
-#ifdef CONFIG_PNO_SUPPORT
-	pwrpriv->wowlan_mode |= pwrpriv->wowlan_pno_enable;
-#endif
-
-	while (pwrpriv->bips_processing == _TRUE)
-		rtw_msleep_os(1);
-
-#ifdef CONFIG_IOL_READ_EFUSE_MAP
-	if(!padapter->bup){
-		u8 bMacPwrCtrlOn = _FALSE;
-		rtw_hal_get_hwreg(padapter, HW_VAR_APFM_ON_MAC, &bMacPwrCtrlOn);
-		if(bMacPwrCtrlOn)
-			rtw_hal_power_off(padapter);
-	}
-#endif
-
-	if((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
-	{
-		DBG_871X("%s bup=%d bDriverStopped=%d bSurpriseRemoved = %d\n", __FUNCTION__
-			,padapter->bup, padapter->bDriverStopped,padapter->bSurpriseRemoved);
-		pdbgpriv->dbg_suspend_error_cnt++;
-		goto exit;
-	}
-
-	rtw_ps_deny(padapter, PS_DENY_SUSPEND);
-
-	if(pnetdev) {
-#ifdef CONFIG_WOWLAN
-		if(pwrpriv->wowlan_mode == _TRUE) {
-			rtw_netif_stop_queue(pnetdev);
-		}
-		else
-#endif
-		{
-			netif_carrier_off(pnetdev);
-			rtw_netif_stop_queue(pnetdev);
-		}
-	}
-
-	rtw_cancel_all_timer(padapter);
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (padapter->pbuddy_adapter)
-	{
-		rtw_cancel_all_timer(padapter->pbuddy_adapter);
-	}
-#endif // CONFIG_CONCURRENT_MODE
-
-	LeaveAllPowerSaveModeDirect(padapter);
-
-	rtw_stop_cmd_thread(padapter);
-	
-#ifdef CONFIG_WOWLAN
-	if (pwrpriv->wowlan_mode == _TRUE)
-	{
-		// 1. stop thread
-		padapter->bDriverStopped = _TRUE;	//for stop thread
-		rtw_stop_drv_threads(padapter);
-		padapter->bDriverStopped = _FALSE;	//for 32k command
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (padapter->pbuddy_adapter)
-		{
-			padapter->pbuddy_adapter->bDriverStopped = _TRUE;	//for stop thread
-			rtw_stop_drv_threads(padapter->pbuddy_adapter);
-			padapter->pbuddy_adapter->bDriverStopped = _FALSE;	//for 32k command
-		}
-#endif // CONFIG_CONCURRENT_MODE
-
-		// 2. disable interrupt
-		rtw_hal_disable_interrupt(padapter); // It need wait for leaving 32K.
-
-		// 2.1 clean interupt
-		if (padapter->HalFunc.clear_interrupt)
-			padapter->HalFunc.clear_interrupt(padapter);
-
-		// 2.2 free irq
-		sdio_free_irq(adapter_to_dvobj(padapter));
-	}
-#endif // CONFIG_WOWLAN
-
-#ifdef CONFIG_BT_COEXIST
-	rtw_btcoex_SuspendNotify(padapter, 1);
-#endif // CONFIG_BT_COEXIST
-
-	rtw_ps_deny_cancel(padapter, PS_DENY_SUSPEND);
-
-#ifdef CONFIG_WOWLAN
-	DBG_871X("wowlan_mode: %d\n", pwrpriv->wowlan_mode);
-
- 	if ((pwrpriv->bSupportRemoteWakeup == _TRUE) &&
-		(pwrpriv->wowlan_mode == _TRUE))
-	{
-		if (rtw_port_switch_chk(padapter))
-			rtw_hal_set_hwreg(padapter, HW_VAR_PORT_SWITCH, NULL);
-
-		poidparam.subcode = WOWLAN_ENABLE;
-		padapter->HalFunc.SetHwRegHandler(padapter,HW_VAR_WOWLAN,(u8 *)&poidparam);
-	}
-	else
-#endif // CONFIG_WOWLAN
-	{
-	//s2-1.  issue rtw_disassoc_cmd to fw
-		rtw_disassoc_cmd(padapter, 0, _FALSE);
-	}
-
-	if (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME)) {
-		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
-			&& check_fwstate(pmlmepriv, _FW_LINKED))
-		{
-			DBG_871X("%s %s(" MAC_FMT "), length:%d assoc_ssid.length:%d\n",__FUNCTION__,
-					pmlmepriv->cur_network.network.Ssid.Ssid,
-					MAC_ARG(pmlmepriv->cur_network.network.MacAddress),
-					pmlmepriv->cur_network.network.Ssid.SsidLength,
-					pmlmepriv->assoc_ssid.SsidLength);
-			#ifdef CONFIG_WOWLAN
-			if (pwrpriv->wowlan_mode != _TRUE)
-				rtw_set_to_roam(padapter, 1);
-			else
-				rtw_set_to_roam(padapter, 0);
-			#else // !CONFIG_WOWLAN
-			rtw_set_to_roam(padapter, 1);
-			#endif // !CONFIG_WOWLAN
-		}
-	}
-
-#ifdef CONFIG_WOWLAN
-	if (pwrpriv->wowlan_mode == _TRUE)
-	{
-		DBG_871X_LEVEL(_drv_always_, "%s: wowmode suspending\n", __func__);
-
-		if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE)
-		{
-			DBG_871X_LEVEL(_drv_always_, "%s: fw_under_survey\n", __func__);
-			rtw_indicate_scan_done(padapter, 1);
-			clr_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
-		}
-		
-		if (rtw_get_ch_setting_union(padapter, &ch, &bw, &offset) != 0) {
-			DBG_871X(FUNC_ADPT_FMT" back to linked/linking union - ch:%u, bw:%u, offset:%u\n",
-				FUNC_ADPT_ARG(padapter), ch, bw, offset);
-			set_channel_bwmode(padapter, ch, offset, bw);
-		}
-
-#ifdef CONFIG_POWER_SAVING
-#ifdef CONFIG_PNO_SUPPORT
-		if(pwrpriv->wowlan_pno_enable)
-			DBG_871X_LEVEL(_drv_always_, "%s: pno: %d\n", __func__, pwrpriv->wowlan_pno_enable);
-		else
-#endif //CONFIG_PNO_SUPPORT
-			rtw_set_ps_mode(padapter, PS_MODE_SELF_DEFINED, 0, 0);
-#endif
-	}
-	else
-#endif // CONFIG_WOWLAN
-	{
-		//s2-2.  indicate disconnect to os
-		rtw_indicate_disconnect(padapter);
-		//s2-3.
-		rtw_free_assoc_resources(padapter, 1);
-		//s2-4.
-		rtw_free_network_queue(padapter, _TRUE);
-		//s2-5 dev unload and stop thread
-		rtw_dev_unload(padapter);
-
-		if ((rtw_hal_check_ips_status(padapter) == _TRUE)
-			|| (adapter_to_pwrctl(padapter)->rf_pwrstate == rf_off))
-		{
-			DBG_871X_LEVEL(_drv_always_, "%s: driver in IPS\n", __FUNCTION__);
-			LeaveAllPowerSaveMode(padapter);
-			DBG_871X_LEVEL(_drv_always_, "%s: driver not in IPS\n", __FUNCTION__);
-		}
-
-		if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE)
-		{
-			DBG_871X_LEVEL(_drv_always_, "%s: fw_under_survey\n", __FUNCTION__);
-			rtw_indicate_scan_done(padapter, 1);
-		}
-
-		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
-		{
-			DBG_871X_LEVEL(_drv_always_, "%s: fw_under_linking\n", __FUNCTION__);
-			rtw_indicate_disconnect(padapter);
-		}
-
-		// interface deinit
-		sdio_deinit(adapter_to_dvobj(padapter));
-	}
-
-	DBG_871X_LEVEL(_drv_always_, "sdio suspend success in %d ms\n",
-			rtw_get_passing_time_ms(start_time));
-
-exit:
-
-#ifdef CONFIG_RTW_SDIO_PM_KEEP_POWER  
-	//Android 4.0 don't support WIFI close power
-	//or power down or clock will close after wifi resume,
-	//this is sprd's bug in Android 4.0, but sprd don't
-	//want to fix it.
-	//we have test power under 8723as, power consumption is ok
-	if (func) {
-		mmc_pm_flag_t pm_flag = 0;
-		pm_flag = sdio_get_host_pm_caps(func);
-		DBG_871X("cmd: %s: suspend: PM flag = 0x%x\n", sdio_func_id(func), pm_flag);
-		if (!(pm_flag & MMC_PM_KEEP_POWER)) {
-			DBG_871X("%s: cannot remain alive while host is suspended\n", sdio_func_id(func));
-			pdbgpriv->dbg_suspend_error_cnt++;
-			return -ENOSYS;
-		} else {
-			DBG_871X("cmd: suspend with MMC_PM_KEEP_POWER\n");
-			sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
-		}
-	}
-#endif
-
-	DBG_871X("<===  %s return %d.............. in %dms\n", __FUNCTION__
-		, ret, rtw_get_passing_time_ms(start_time));
-
-	_func_exit_;
-	return ret;
-}
-
-
-
-int rtw_resume_process(_adapter *padapter)
-{
-	struct net_device *pnetdev;
-	struct pwrctrl_priv *pwrpriv = NULL;
-	u8 is_pwrlock_hold_by_caller;
-	u8 is_directly_called_by_auto_resume;
-	int ret = 0;
-	u32 start_time = rtw_get_current_time();
-	struct dvobj_priv *psdpriv = padapter->dvobj;
-	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
-#ifdef CONFIG_WOWLAN
-	u32 value = 0;
-	struct wowlan_ioctl_param poidparam;
-	struct sta_info	*psta = NULL;
-#endif // CONFIG_WOWLAN
-
-	_func_enter_;
-
-	DBG_871X_LEVEL(_drv_always_, "sdio resume start\n");
-	DBG_871X("==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
-
-	if (padapter) {
-		pnetdev = padapter->pnetdev;
-		pwrpriv = adapter_to_pwrctl(padapter);
-	} else {
-		pdbgpriv->dbg_resume_error_cnt++;
-		ret = -1;
-		goto exit;
-	}
-	
-	if (pwrpriv->bInSuspend == _FALSE)
-	{
-		ret = -1;
-		pdbgpriv->dbg_resume_error_cnt++;
-		DBG_871X("%s bInSuspend = %d\n", __FUNCTION__, pwrpriv->bInSuspend);
-		goto exit;
-	}
-
-#ifdef CONFIG_PNO_SUPPORT
-	pwrpriv->pno_in_resume = _TRUE;
-#endif
-
-#ifdef CONFIG_WOWLAN
-	if (pwrpriv->wowlan_mode == _FALSE){
-
-	// interface init
-	if (sdio_init(adapter_to_dvobj(padapter)) != _SUCCESS)
-	{
-		ret = -1;
-		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: initialize SDIO Failed!!\n", __FUNCTION__));
-		goto exit;
-	}
-
-	rtw_hal_disable_interrupt(padapter);
-
-		if (padapter->HalFunc.clear_interrupt)
-			padapter->HalFunc.clear_interrupt(padapter);
-
-	if (sdio_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS)
-	{
-		ret = -1;
-		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: sdio_alloc_irq Failed!!\n", __FUNCTION__));
-		goto exit;
-	}
-
-	rtw_reset_drv_sw(padapter);
-	pwrpriv->bkeepfwalive = _FALSE;
-
-	DBG_871X("bkeepfwalive(%x)\n",pwrpriv->bkeepfwalive);
-
-	if(pm_netdev_open(pnetdev,_TRUE) != 0) {
-		ret = -1;
-		pdbgpriv->dbg_resume_error_cnt++;
-		goto exit;
-	}
-
-	netif_device_attach(pnetdev);	
-	netif_carrier_on(pnetdev);
-	} else {
-
-#ifdef CONFIG_POWER_SAVING
-#ifdef CONFIG_LPS
-		rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0, "WOWLAN");
-#endif //CONFIG_LPS
-#endif
-
-		pwrpriv->bFwCurrentInPSMode = _FALSE;
-
-		rtw_hal_disable_interrupt(padapter);
-
-		if (padapter->HalFunc.clear_interrupt)
-			padapter->HalFunc.clear_interrupt(padapter);
-
-		if (sdio_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS) {
-			ret = -1;
-			RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: sdio_alloc_irq Failed!!\n", __FUNCTION__));
-			goto exit;
-		}
-
-		//Disable WOW, set H2C command
-		poidparam.subcode=WOWLAN_DISABLE;
-		padapter->HalFunc.SetHwRegHandler(padapter,HW_VAR_WOWLAN,(u8 *)&poidparam);
-
-		psta = rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv));
-		if (psta) {
-			set_sta_rate(padapter, psta);
-		}
-
-		padapter->bDriverStopped = _FALSE;
-		DBG_871X("%s: wowmode resuming, DriverStopped:%d\n", __func__, padapter->bDriverStopped);
-		rtw_start_drv_threads(padapter);
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (padapter->pbuddy_adapter)
-		{
-			padapter->pbuddy_adapter->bDriverStopped = _FALSE;
-			DBG_871X("%s: wowmode resuming, pbuddy_adapter->DriverStopped:%d\n",
-				__FUNCTION__, padapter->pbuddy_adapter->bDriverStopped);
-			rtw_start_drv_threads(padapter->pbuddy_adapter);
-		}
-#endif // CONFIG_CONCURRENT_MODE
-
-		rtw_hal_enable_interrupt(padapter);
-
-		// start netif queue
-		if (pnetdev) {
-			if(!rtw_netif_queue_stopped(pnetdev))
-				rtw_netif_start_queue(pnetdev);
-			else 
-				rtw_netif_wake_queue(pnetdev);
-		}
-	}
-#else //!CONFIG_WOWLAN
-
-		// interface init
-		if (sdio_init(adapter_to_dvobj(padapter)) != _SUCCESS)
-		{
-			ret = -1;
-			RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: initialize SDIO Failed!!\n", __FUNCTION__));
-			goto exit;
-		}
-		rtw_hal_disable_interrupt(padapter);
-		if (sdio_alloc_irq(adapter_to_dvobj(padapter)) != _SUCCESS)
-		{
-			ret = -1;
-			RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("%s: sdio_alloc_irq Failed!!\n", __FUNCTION__));
-			goto exit;
-		}
-
-		rtw_reset_drv_sw(padapter);
-		pwrpriv->bkeepfwalive = _FALSE;
-
-		DBG_871X("bkeepfwalive(%x)\n",pwrpriv->bkeepfwalive);
-		if(pm_netdev_open(pnetdev,_TRUE) != 0) {
-			ret = -1;
-			pdbgpriv->dbg_resume_error_cnt++;
-			goto exit;
-		}
-
-		netif_device_attach(pnetdev);
-		netif_carrier_on(pnetdev);
-#endif
-	if( padapter->pid[1]!=0) {
-		DBG_871X("pid[1]:%d\n",padapter->pid[1]);
-		rtw_signal_process(padapter->pid[1], SIGUSR2);
-	}	
-
-	if (rtw_chk_roam_flags(padapter, RTW_ROAM_ON_RESUME)) {
-#ifdef CONFIG_WOWLAN
-		if (pwrpriv->wowlan_wake_reason == FWDecisionDisconnect ||
-			pwrpriv->wowlan_wake_reason == Rx_DisAssoc ||
-			pwrpriv->wowlan_wake_reason == Rx_DeAuth) {
-
-			DBG_871X("%s: disconnect reason: %02x\n", __func__,
-						pwrpriv->wowlan_wake_reason);
-			rtw_indicate_disconnect(padapter);
-			rtw_sta_media_status_rpt(padapter, rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv)), 0);
-			rtw_free_assoc_resources(padapter, 1);
-		} else {
-			DBG_871X("%s: do roaming\n", __func__);
-			rtw_roaming(padapter, NULL);
-		}
-#else
-		rtw_roaming(padapter, NULL);
-#endif //CONFOG_WOWLAN
-	}
-
-	#ifdef CONFIG_RESUME_IN_WORKQUEUE
-	rtw_unlock_suspend();
-	#endif //CONFIG_RESUME_IN_WORKQUEUE
-
-#ifdef CONFIG_WOWLAN
-	if (pwrpriv->wowlan_wake_reason == Rx_GTK ||
-		pwrpriv->wowlan_wake_reason == Rx_DisAssoc ||
-		pwrpriv->wowlan_wake_reason == Rx_DeAuth ||
-		pwrpriv->wowlan_wake_reason == RX_PNOWakeUp) {
-		rtw_lock_ext_suspend_timeout(8000);
-	}
-
-	if (pwrpriv->wowlan_mode == _TRUE) {
-		pwrpriv->bips_processing = _FALSE;
-		_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
-#ifndef CONFIG_IPS_CHECK_IN_WD
-		rtw_set_pwr_state_check_timer(pwrpriv);
-#endif
-	} else {
-		DBG_871X_LEVEL(_drv_always_, "do not reset timer\n");
-	}
-
-	pwrpriv->wowlan_mode =_FALSE;
-
-	//clean driver side wake up reason.
-	pwrpriv->wowlan_wake_reason = 0;
-#endif //CONFIG_WOWLAN
-
-#ifdef CONFIG_BT_COEXIST
-	rtw_btcoex_SuspendNotify(padapter, 0);
-#endif // CONFIG_BT_COEXIST
-
-exit:
-	if (pwrpriv) {
-		pwrpriv->bInSuspend = _FALSE;
-#ifdef CONFIG_PNO_SUPPORT
-		pwrpriv->pno_in_resume = _FALSE;
-#endif
-	}
-	DBG_871X_LEVEL(_drv_always_, "sdio resume ret:%d in %d ms\n", ret,
-		rtw_get_passing_time_ms(start_time));
-
-	_func_exit_;
-	
-	return ret;
-}
-
-
-#endif
 static int rtw_sdio_resume(struct device *dev)
 {
 	struct sdio_func *func =dev_to_sdio_func(dev);
@@ -1341,17 +911,22 @@ static int rtw_sdio_resume(struct device *dev)
 	struct debug_priv *pdbgpriv = &psdpriv->drv_dbg;
 
 	DBG_871X("==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
+
 	pdbgpriv->dbg_resume_cnt++;
 
 	if(pwrpriv->bInternalAutoSuspend)
 	{
-		ret = rtw_resume_process(padapter);
+ 		ret = rtw_resume_process(padapter);
 	}
 	else
 	{
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+		if(0)
+#else
 		if(pwrpriv->wowlan_mode || pwrpriv->wowlan_ap_mode)
+#endif
 		{
-			rtw_resume_lock_suspend();
+			rtw_resume_lock_suspend();			
 			ret = rtw_resume_process(padapter);
 			rtw_resume_unlock_suspend();
 		}
@@ -1359,22 +934,21 @@ static int rtw_sdio_resume(struct device *dev)
 		{
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
 			rtw_resume_in_workqueue(pwrpriv);
-#else
+#else			
 			if (rtw_is_earlysuspend_registered(pwrpriv))
 			{
 				/* jeff: bypass resume here, do in late_resume */
 				rtw_set_do_late_resume(pwrpriv, _TRUE);
-			}
+			}	
 			else
 			{
-				rtw_resume_lock_suspend();
+				rtw_resume_lock_suspend();			
 				ret = rtw_resume_process(padapter);
 				rtw_resume_unlock_suspend();
 			}
 #endif
 		}
 	}
-
 	pmlmeext->last_scan_time = rtw_get_current_time();
 	DBG_871X("<========  %s return %d\n", __FUNCTION__, ret);
 	return ret;
@@ -1385,7 +959,6 @@ static int rtw_drv_entry(void)
 {
 	int ret = 0;
 
-
 	DBG_871X_LEVEL(_drv_always_, "module init start\n");
 	dump_drv_version(RTW_DBGDUMP);
 #ifdef BTCOEXVERSION
@@ -1416,8 +989,9 @@ static int rtw_drv_entry(void)
 		goto poweroff;
 	}
 
+#ifndef CONFIG_PLATFORM_INTEL_BYT
 	rtw_android_wifictrl_func_add();
-
+#endif //!CONFIG_PLATFORM_INTEL_BYT
 	goto exit;
 
 poweroff:
@@ -1449,6 +1023,21 @@ static void rtw_drv_halt(void)
 	rtw_mstat_dump(RTW_DBGDUMP);
 }
 
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+int rtw_sdio_set_power(int on)
+{
+
+	if(wlan_en_gpio >= 0){
+		if(on)
+			gpio_set_value(wlan_en_gpio,1);
+		else
+			gpio_set_value(wlan_en_gpio,0);
+	}
+
+	return 0;
+}
+#endif //CONFIG_PLATFORM_INTEL_BYT
+
 #include "wifi_version.h"
 #include <linux/rfkill-wlan.h>
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/wifi_regd.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/wifi_regd.c
index e7f8d534f954..04ffe781a410 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/wifi_regd.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/wifi_regd.c
@@ -268,10 +268,15 @@ static void _rtw_reg_apply_radar_flags(struct wiphy *wiphy)
 		if (!_rtw_is_radar_freq(ch->center_freq))
 			continue;
 #ifdef CONFIG_DFS
-		if (!(ch->flags & IEEE80211_CHAN_DISABLED))
-			ch->flags |= IEEE80211_CHAN_RADAR |
-			    IEEE80211_CHAN_NO_IBSS;
-#endif
+		if (!(ch->flags & IEEE80211_CHAN_DISABLED)) {
+			ch->flags |= IEEE80211_CHAN_RADAR;
+			#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0))
+			ch->flags |= (IEEE80211_CHAN_NO_IBSS|IEEE80211_CHAN_PASSIVE_SCAN);
+			#else
+			ch->flags |= IEEE80211_CHAN_NO_IR;
+			#endif
+		}
+#endif //CONFIG_DFS
 
 #if 0
 		/*
@@ -354,12 +359,19 @@ static void _rtw_reg_apply_flags(struct wiphy *wiphy)
 			    rtw_ieee80211_channel_to_frequency(channel,
 							       IEEE80211_BAND_5GHZ);
 
+
 		ch = ieee80211_get_channel(wiphy, freq);
 		if (ch) {
-			if (channel_set[i].ScanType == SCAN_PASSIVE)
-				ch->flags = IEEE80211_CHAN_PASSIVE_SCAN;
-			else
+			if (channel_set[i].ScanType == SCAN_PASSIVE) {
+				#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0))
+				ch->flags = (IEEE80211_CHAN_NO_IBSS|IEEE80211_CHAN_PASSIVE_SCAN);
+				#else
+				ch->flags = IEEE80211_CHAN_NO_IR;
+				#endif
+			}
+			else {
 				ch->flags = 0;
+			}
 		}
 	}
 
@@ -474,20 +486,52 @@ static const struct ieee80211_regdomain *_rtw_regdomain_select(struct
 #endif
 }
 
-static int _rtw_regd_init_wiphy(struct rtw_regulatory *reg,
-				struct wiphy *wiphy,
-				void (*reg_notifier) (struct wiphy * wiphy,
-						     struct regulatory_request *
-						     request))
+void _rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
+{
+	struct rtw_regulatory *reg = NULL;
+
+	DBG_8192C("%s\n", __func__);
+
+	_rtw_reg_notifier_apply(wiphy, request, reg);
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0))
+int rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
+#else
+void rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
+#endif
+{
+	_rtw_reg_notifier(wiphy, request);
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0))
+	return 0;
+	#endif
+}
+
+void rtw_reg_notify_by_driver(_adapter *adapter)
+{
+	if ((adapter->rtw_wdev != NULL) && (adapter->rtw_wdev->wiphy)) {
+		struct regulatory_request request;
+		request.initiator = NL80211_REGDOM_SET_BY_DRIVER;
+		rtw_reg_notifier(adapter->rtw_wdev->wiphy, &request);
+	}
+}
+
+static void _rtw_regd_init_wiphy(struct rtw_regulatory *reg, struct wiphy *wiphy)
 {
 	const struct ieee80211_regdomain *regd;
 
-	wiphy->reg_notifier = reg_notifier;
+	wiphy->reg_notifier = rtw_reg_notifier;
 
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0))
 	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
 	wiphy->flags &= ~WIPHY_FLAG_STRICT_REGULATORY;
 	wiphy->flags &= ~WIPHY_FLAG_DISABLE_BEACON_HINTS;
-
+	#else
+	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+	wiphy->regulatory_flags &= ~REGULATORY_STRICT_REG;
+	wiphy->regulatory_flags &= ~REGULATORY_DISABLE_BEACON_HINTS;
+	#endif
+	
 	regd = _rtw_regdomain_select(reg);
 	wiphy_apply_custom_regulatory(wiphy, regd);
 
@@ -495,7 +539,6 @@ static int _rtw_regd_init_wiphy(struct rtw_regulatory *reg,
 	_rtw_reg_apply_flags(wiphy);
 	_rtw_reg_apply_radar_flags(wiphy);
 	_rtw_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
-	return 0;
 }
 
 static struct country_code_to_enum_rd *_rtw_regd_find_country(u16 countrycode)
@@ -509,11 +552,8 @@ static struct country_code_to_enum_rd *_rtw_regd_find_country(u16 countrycode)
 	return NULL;
 }
 
-int rtw_regd_init(_adapter * padapter,
-		  void (*reg_notifier) (struct wiphy * wiphy,
-				       struct regulatory_request * request))
+int rtw_regd_init(_adapter * padapter)
 {
-	//struct registry_priv  *registrypriv = &padapter->registrypriv;
 	struct wiphy *wiphy = padapter->rtw_wdev->wiphy;
 
 #if 0
@@ -531,17 +571,9 @@ int rtw_regd_init(_adapter * padapter,
 		  __func__, rtw_regd->alpha2[0], rtw_regd->alpha2[1]);
 #endif
 
-	_rtw_regd_init_wiphy(NULL, wiphy, reg_notifier);
+	_rtw_regd_init_wiphy(NULL, wiphy);
 
 	return 0;
 }
-
-void rtw_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
-{
-	struct rtw_regulatory *reg = NULL;
-
-	DBG_8192C("%s\n", __func__);
-
-	_rtw_reg_notifier_apply(wiphy, request, reg);
-}
 #endif //CONFIG_IOCTL_CFG80211
+
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/wifi_version.h b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/wifi_version.h
index b3b69aa28a6d..9c8bfe52fdc5 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/wifi_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/wifi_version.h
@@ -7,7 +7,7 @@
 /*
  * Broadcom BCM4319 driver version.
  */
-#define RTL8192_DRV_VERSION "3.00"
+#define RTL8192_DRV_VERSION "4.00"
 
 #endif /* WIFI_VERSION_H */
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/xmit_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/xmit_linux.c
index 0539e65e94a9..db9b311f321f 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/xmit_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/linux/xmit_linux.c
@@ -21,6 +21,7 @@
 
 #include <drv_types.h>
 
+#define DBG_DUMP_OS_QUEUE_CTL 0
 
 uint rtw_remainder_len(struct pkt_file *pfile)
 {
@@ -143,11 +144,11 @@ int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf, u3
 		for(i=0; i<8; i++)
 	      	{
 	      		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
-	             	if(pxmitbuf->pxmit_urb[i] == NULL) 
-	             	{
-	             		DBG_871X("pxmitbuf->pxmit_urb[i]==NULL");
-		        	return _FAIL;	 
-	             	}
+	             if(pxmitbuf->pxmit_urb[i] == NULL) 
+	             {
+	             	DBG_871X("pxmitbuf->pxmit_urb[i]==NULL");
+		       	return _FAIL;	 
+	             }
 	      	}
 #endif
 	}
@@ -187,28 +188,78 @@ void rtw_os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf,u32
 	}
 }
 
+void dump_os_queue(void *sel, _adapter *padapter)
+{
+	struct net_device *ndev = padapter->pnetdev;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	int i;
+
+	for (i=0;i<4;i++) {
+		DBG_871X_SEL_NL(sel, "os_queue[%d]:%s\n"
+			, i, __netif_subqueue_stopped(ndev, i)?"stopped":"waked");
+	}
+#else
+	DBG_871X_SEL_NL(sel, "os_queue:%s\n"
+			, netif_queue_stopped(ndev)?"stopped":"waked");
+#endif
+}
+
 #define WMM_XMIT_THRESHOLD	(NR_XMITFRAME*2/5)
 
-void rtw_os_pkt_complete(_adapter *padapter, _pkt *pkt)
+inline static bool rtw_os_need_wake_queue(_adapter *padapter, u16 qidx)
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
-	u16	queue;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
-	queue = skb_get_queue_mapping(pkt);
 	if (padapter->registrypriv.wifi_spec) {
-		if(__netif_subqueue_stopped(padapter->pnetdev, queue) &&
-			(pxmitpriv->hwxmits[queue].accnt < WMM_XMIT_THRESHOLD))
-		{
-			netif_wake_subqueue(padapter->pnetdev, queue);
-		}
+		if (pxmitpriv->hwxmits[qidx].accnt < WMM_XMIT_THRESHOLD)
+			return _TRUE;
+	} else {
+		return _TRUE;
+	}
+	return _FALSE;
+#else
+	return _TRUE;
+#endif
+}
+
+inline static bool rtw_os_need_stop_queue(_adapter *padapter, u16 qidx)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	if (padapter->registrypriv.wifi_spec) {
+		/* No free space for Tx, tx_worker is too slow */
+		if (pxmitpriv->hwxmits[qidx].accnt > WMM_XMIT_THRESHOLD)
+			return _TRUE;
 	} else {
-		if(__netif_subqueue_stopped(padapter->pnetdev, queue))
-			netif_wake_subqueue(padapter->pnetdev, queue);
+		if(pxmitpriv->free_xmitframe_cnt<=4)
+			return _TRUE;
+	}
+#else
+	if(pxmitpriv->free_xmitframe_cnt<=4)
+		return _TRUE;
+#endif
+	return _FALSE;
+}
+
+void rtw_os_pkt_complete(_adapter *padapter, _pkt *pkt)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	u16	qidx;
+
+	qidx = skb_get_queue_mapping(pkt);
+	if (rtw_os_need_wake_queue(padapter, qidx)) {
+		if (DBG_DUMP_OS_QUEUE_CTL)
+			DBG_871X(FUNC_ADPT_FMT": netif_wake_subqueue[%d]\n", FUNC_ADPT_ARG(padapter), qidx);
+		netif_wake_subqueue(padapter->pnetdev, qidx);
 	}
 #else
-	if (netif_queue_stopped(padapter->pnetdev))
+	if (rtw_os_need_wake_queue(padapter, 0)) {
+		if (DBG_DUMP_OS_QUEUE_CTL)
+			DBG_871X(FUNC_ADPT_FMT": netif_wake_queue\n", FUNC_ADPT_ARG(padapter));
 		netif_wake_queue(padapter->pnetdev);
+	}
 #endif
 
 	rtw_skb_free(pkt);
@@ -259,30 +310,53 @@ void rtw_os_xmit_schedule(_adapter *padapter)
 #endif
 }
 
-static void rtw_check_xmit_resource(_adapter *padapter, _pkt *pkt)
+static bool rtw_check_xmit_resource(_adapter *padapter, _pkt *pkt)
 {
+	bool busy = _FALSE;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
-	u16	queue;
+	u16	qidx;
+
+	qidx = skb_get_queue_mapping(pkt);
+	if (rtw_os_need_stop_queue(padapter, qidx)) {
+		if (DBG_DUMP_OS_QUEUE_CTL)
+			DBG_871X(FUNC_ADPT_FMT": netif_stop_subqueue[%d]\n", FUNC_ADPT_ARG(padapter), qidx);
+		netif_stop_subqueue(padapter->pnetdev, qidx);
+		busy = _TRUE;
+	}
+#else
+	if (rtw_os_need_stop_queue(padapter, 0)) {
+		if (DBG_DUMP_OS_QUEUE_CTL)
+			DBG_871X(FUNC_ADPT_FMT": netif_stop_queue\n", FUNC_ADPT_ARG(padapter));
+		rtw_netif_stop_queue(padapter->pnetdev);
+		busy = _TRUE;
+	}
+#endif
+	return busy;
+}
 
-	queue = skb_get_queue_mapping(pkt);
-	if (padapter->registrypriv.wifi_spec) {
-		/* No free space for Tx, tx_worker is too slow */
-		if (pxmitpriv->hwxmits[queue].accnt > WMM_XMIT_THRESHOLD) {
-			//DBG_871X("%s(): stop netif_subqueue[%d]\n", __FUNCTION__, queue);
-			netif_stop_subqueue(padapter->pnetdev, queue);
-		}
-	} else {
-		if(pxmitpriv->free_xmitframe_cnt<=4) {
-			if (!netif_tx_queue_stopped(netdev_get_tx_queue(padapter->pnetdev, queue)))
-				netif_stop_subqueue(padapter->pnetdev, queue);
+void rtw_os_wake_queue_at_free_stainfo(_adapter *padapter, int *qcnt_freed)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	int i;
+
+	for (i=0;i<4;i++) {
+		if (qcnt_freed[i] == 0)
+			continue;
+
+		if(rtw_os_need_wake_queue(padapter, i)) {
+			if (DBG_DUMP_OS_QUEUE_CTL)
+				DBG_871X(FUNC_ADPT_FMT": netif_wake_subqueue[%d]\n", FUNC_ADPT_ARG(padapter), i);
+			netif_wake_subqueue(padapter->pnetdev, i);
 		}
 	}
 #else
-	if(pxmitpriv->free_xmitframe_cnt<=4)
-	{
-		if (!rtw_netif_queue_stopped(padapter->pnetdev))
-			rtw_netif_stop_queue(padapter->pnetdev);
+	if (qcnt_freed[0] || qcnt_freed[1] || qcnt_freed[2] || qcnt_freed[3]) {
+		if(rtw_os_need_wake_queue(padapter, 0)) {
+			if (DBG_DUMP_OS_QUEUE_CTL)
+				DBG_871X(FUNC_ADPT_FMT": netif_wake_queue\n", FUNC_ADPT_ARG(padapter));
+			netif_wake_queue(padapter->pnetdev);
+		}
 	}
 #endif
 }
@@ -304,6 +378,8 @@ int rtw_mlcst2unicst(_adapter *padapter, struct sk_buff *skb)
 	int i;
 	s32	res;
 
+	DBG_COUNTER(padapter->tx_logs.os_tx_m2u);
+
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
@@ -324,14 +400,22 @@ int rtw_mlcst2unicst(_adapter *padapter, struct sk_buff *skb)
 	for (i = 0; i < chk_alive_num; i++) {
 		psta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);
 		if(!(psta->state &_FW_LINKED))
+		{
+			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_ignore_fw_linked);
 			continue;		
+		}
 		
 		/* avoid come from STA1 and send back STA1 */ 
 		if (_rtw_memcmp(psta->hwaddr, &skb->data[6], 6) == _TRUE
 			|| _rtw_memcmp(psta->hwaddr, null_addr, 6) == _TRUE
 			|| _rtw_memcmp(psta->hwaddr, bc_addr, 6) == _TRUE
 		)
+		{
+			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_ignore_self);
 			continue;
+		}
+
+		DBG_COUNTER(padapter->tx_logs.os_tx_m2u_entry);
 
 		newskb = rtw_skb_copy(skb);
 
@@ -339,11 +423,13 @@ int rtw_mlcst2unicst(_adapter *padapter, struct sk_buff *skb)
 			_rtw_memcpy(newskb->data, psta->hwaddr, 6);
 			res = rtw_xmit(padapter, &newskb);
 			if (res < 0) {
+				DBG_COUNTER(padapter->tx_logs.os_tx_m2u_entry_err_xmit);
 				DBG_871X("%s()-%d: rtw_xmit() return error!\n", __FUNCTION__, __LINE__);
 				pxmitpriv->tx_drop++;
 				rtw_skb_free(newskb);
 			}
 		} else {
+			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_entry_err_skb);
 			DBG_871X("%s-%d: rtw_skb_copy() failed!\n", __FUNCTION__, __LINE__);
 			pxmitpriv->tx_drop++;
 			//rtw_skb_free(skb);
@@ -372,9 +458,16 @@ int _rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
 
 _func_enter_;
 
+	if(padapter->registrypriv.mp_mode)
+	{
+		DBG_871X("MP_TX_DROP_OS_FRAME\n");
+		goto drop_packet;
+	}
+	DBG_COUNTER(padapter->tx_logs.os_tx);
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));
 
 	if (rtw_if_up(padapter) == _FALSE) {
+		DBG_COUNTER(padapter->tx_logs.os_tx_err_up);
 		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit_entry: rtw_if_up fail\n"));
 		#ifdef DBG_TX_DROP_FRAME
 		DBG_871X("DBG_TX_DROP_FRAME %s if_up fail\n", __FUNCTION__);
@@ -388,7 +481,11 @@ _func_enter_;
 	if ( !rtw_mc2u_disable
 		&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE
 		&& ( IP_MCAST_MAC(pkt->data)
-			|| ICMPV6_MCAST_MAC(pkt->data) )
+			|| ICMPV6_MCAST_MAC(pkt->data)
+			#ifdef CONFIG_TX_BCAST2UNI
+			|| is_broadcast_mac_addr(pkt->data)
+			#endif
+			)
 		&& (padapter->registrypriv.wifi_spec == 0)
 		)
 	{
@@ -400,6 +497,7 @@ _func_enter_;
 		} else {
 			//DBG_871X("Stop M2U(%d, %d)! ", pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmitbuf_cnt);
 			//DBG_871X("!m2u );
+			DBG_COUNTER(padapter->tx_logs.os_tx_m2u_stop);
 		}
 	}	
 #endif	// CONFIG_TX_MCAST2UNI	
@@ -417,7 +515,7 @@ _func_enter_;
 
 drop_packet:
 	pxmitpriv->tx_drop++;
-	rtw_skb_free(pkt);
+	rtw_os_pkt_complete(padapter, pkt);
 	RT_TRACE(_module_xmit_osdep_c_, _drv_notice_, ("rtw_xmit_entry: drop, tx_drop=%d\n", (u32)pxmitpriv->tx_drop));
 
 exit:
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/osdep_service.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/osdep_service.c
index 43c02fcc9f29..dcef0e75acf5 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/osdep_service.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/os_dep/osdep_service.c
@@ -751,7 +751,7 @@ inline void *dbg_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_a
 	void *p;
 
 	if(match_mstat_sniff_rules(flags, size))
-		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, size);
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%zu)\n", func, line, __FUNCTION__, size);
 
 	p = _rtw_usb_buffer_alloc(dev, size, dma);
 	
@@ -768,7 +768,7 @@ inline void dbg_rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *a
 {
 
 	if(match_mstat_sniff_rules(flags, size))
-		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, size);
+		DBG_871X("DBG_MEM_ALLOC %s:%d %s(%zu)\n", func, line, __FUNCTION__, size);
 
 	_rtw_usb_buffer_free(dev, size, addr, dma);
 
@@ -782,7 +782,7 @@ inline void dbg_rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *a
 
 #endif /* defined(DBG_MEM_ALLOC) */
 
-void* rtw_malloc2d(int h, int w, int size)
+void* rtw_malloc2d(int h, int w, size_t size)
 {
 	int j;
 
@@ -1404,7 +1404,12 @@ void rtw_msleep_os(int ms)
 {
 
 #ifdef PLATFORM_LINUX
-
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36))
+	if (ms < 20) {
+		unsigned long us = ms * 1000UL;
+		usleep_range(us, us + 1000UL);
+	} else
+	#endif
   	msleep((unsigned int)ms);
 
 #endif	
@@ -1423,16 +1428,19 @@ void rtw_msleep_os(int ms)
 }
 void rtw_usleep_os(int us)
 {
-
 #ifdef PLATFORM_LINUX
-  	
-      // msleep((unsigned int)us);
-      if ( 1 < (us/1000) )
-                msleep(1);
+
+	// msleep((unsigned int)us);
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36))
+	usleep_range(us, us + 1);	
+	#else
+	if ( 1 < (us/1000) )
+      		msleep(1);
       else
 		msleep( (us/1000) + 1);
+	#endif
+#endif
 
-#endif	
 #ifdef PLATFORM_FREEBSD
 	//Delay for delay microseconds 
 	DELAY(us);
@@ -1562,7 +1570,6 @@ void rtw_yield_os()
 #define RTW_SUSPEND_TRAFFIC_LOCK_NAME "rtw_wifi_traffic"
 #define RTW_SUSPEND_RESUME_LOCK_NAME "rtw_wifi_resume"
 #define RTW_RESUME_SCAN_LOCK_NAME "rtw_wifi_scan"
-#define RTW_AP_CONNECTION_LOCK_NAME "rtw_ap_connection"
 #ifdef CONFIG_WAKELOCK
 static struct wake_lock rtw_suspend_lock;
 static struct wake_lock rtw_suspend_ext_lock;
@@ -1570,7 +1577,6 @@ static struct wake_lock rtw_suspend_rx_lock;
 static struct wake_lock rtw_suspend_traffic_lock;
 static struct wake_lock rtw_suspend_resume_lock;
 static struct wake_lock rtw_resume_scan_lock;
-static struct wake_lock rtw_ap_connection_lock;
 #elif defined(CONFIG_ANDROID_POWER)
 static android_suspend_lock_t rtw_suspend_lock ={
 	.name = RTW_SUSPEND_LOCK_NAME
@@ -1590,9 +1596,6 @@ static android_suspend_lock_t rtw_suspend_resume_lock ={
 static android_suspend_lock_t rtw_resume_scan_lock ={
 	.name = RTW_RESUME_SCAN_LOCK_NAME
 };
-static android_suspend_lock_t rtw_ap_connection_lock ={
-	.name = RTW_AP_CONNECTION_LOCK_NAME
-};
 #endif
 
 inline void rtw_suspend_lock_init()
@@ -1604,7 +1607,6 @@ inline void rtw_suspend_lock_init()
 	wake_lock_init(&rtw_suspend_traffic_lock, WAKE_LOCK_SUSPEND, RTW_SUSPEND_TRAFFIC_LOCK_NAME);
 	wake_lock_init(&rtw_suspend_resume_lock, WAKE_LOCK_SUSPEND, RTW_SUSPEND_RESUME_LOCK_NAME);
 	wake_lock_init(&rtw_resume_scan_lock, WAKE_LOCK_SUSPEND, RTW_RESUME_SCAN_LOCK_NAME);
-	wake_lock_init(&rtw_ap_connection_lock, WAKE_LOCK_SUSPEND, RTW_AP_CONNECTION_LOCK_NAME);
 	#elif defined(CONFIG_ANDROID_POWER)
 	android_init_suspend_lock(&rtw_suspend_lock);
 	android_init_suspend_lock(&rtw_suspend_ext_lock);
@@ -1612,7 +1614,6 @@ inline void rtw_suspend_lock_init()
 	android_init_suspend_lock(&rtw_suspend_traffic_lock);
 	android_init_suspend_lock(&rtw_suspend_resume_lock);
 	android_init_suspend_lock(&rtw_resume_scan_lock);
-	android_init_suspend_lock(&rtw_ap_connection_lock);
 	#endif
 }
 
@@ -1625,7 +1626,6 @@ inline void rtw_suspend_lock_uninit()
 	wake_lock_destroy(&rtw_suspend_traffic_lock);
 	wake_lock_destroy(&rtw_suspend_resume_lock);
 	wake_lock_destroy(&rtw_resume_scan_lock);
-	wake_lock_destroy(&rtw_ap_connection_lock);
 	#elif defined(CONFIG_ANDROID_POWER)
 	android_uninit_suspend_lock(&rtw_suspend_lock);
 	android_uninit_suspend_lock(&rtw_suspend_ext_lock);
@@ -1633,7 +1633,6 @@ inline void rtw_suspend_lock_uninit()
 	android_uninit_suspend_lock(&rtw_suspend_traffic_lock);
 	android_uninit_suspend_lock(&rtw_suspend_resume_lock);
 	android_uninit_suspend_lock(&rtw_resume_scan_lock);
-	android_uninit_suspend_lock(&rtw_ap_connection_lock);
 	#endif
 }
 
@@ -1739,32 +1738,6 @@ inline void rtw_lock_resume_scan_timeout(u32 timeout_ms)
 	//DBG_871X("resume scan lock:%d\n", timeout_ms);
 }
 
-inline void rtw_ap_connection_lock_suspend(void)
-{
-	#ifdef CONFIG_WAKELOCK
-	wake_lock(&rtw_ap_connection_lock);
-	#elif defined(CONFIG_ANDROID_POWER)
-	android_lock_suspend(&rtw_ap_connection_lock);
-	#endif
-
-	#if  defined(CONFIG_WAKELOCK) || defined(CONFIG_ANDROID_POWER)
-	//DBG_871X("####%s: suspend_lock_count:%d####\n", __FUNCTION__, rtw_suspend_lock.stat.count);
-	#endif
-}
-
-inline void rtw_ap_connection_unlock_suspend(void)
-{
-	#ifdef CONFIG_WAKELOCK
-	wake_unlock(&rtw_ap_connection_lock);
-	#elif defined(CONFIG_ANDROID_POWER)
-	android_unlock_suspend(&rtw_ap_connection_lock);
-	#endif
-
-	#if  defined(CONFIG_WAKELOCK) || defined(CONFIG_ANDROID_POWER)
-	//DBG_871X("####%s: suspend_lock_count:%d####\n", __FUNCTION__, rtw_suspend_lock.stat.count);
-	#endif
-}
-
 inline void ATOMIC_SET(ATOMIC_T *v, int i)
 {
 	#ifdef PLATFORM_LINUX
@@ -2345,6 +2318,10 @@ inline u32 rtw_random32(void)
 #ifdef PLATFORM_LINUX
 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
 	return prandom_u32();
+	#elif (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18))
+	u32 random_int;
+	get_random_bytes( &random_int , 4 );
+	return random_int;
 	#else
 	return random32();
 	#endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8189es/platform/platform_ARM_SUNnI_sdio.c b/drivers/net/wireless/rockchip_wlan/rtl8189es/platform/platform_ARM_SUNnI_sdio.c
index 0493066b2d5c..d384141eba0c 100644
--- a/drivers/net/wireless/rockchip_wlan/rtl8189es/platform/platform_ARM_SUNnI_sdio.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8189es/platform/platform_ARM_SUNnI_sdio.c
@@ -70,8 +70,6 @@ int platform_wifi_power_on(void)
 		sdc_id = val.val;
 		DBG_871X("----- %s sdc_id: %d, mod_sel: %d\n", __FUNCTION__, sdc_id, mod_sel);
 
-		wifi_pm_power(0);
-		mdelay(50);
 #if defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I)
 		sw_mci_rescan_card(sdc_id, 1);
 #elif defined(CONFIG_PLATFORM_ARM_SUN8I)
-- 
2.35.3

