From 7e7d72bb18236606c902be03f586af4e778df6c4 Mon Sep 17 00:00:00 2001
From: hwg <hwg@rock-chips.com>
Date: Thu, 18 Jun 2015 18:28:07 +0800
Subject: [PATCH] rtl8188eu: update driver to v4.3.0.8_13968.20150417

---
 .../wireless/rockchip_wlan/rtl8188eu/Makefile |   7 +-
 .../rockchip_wlan/rtl8188eu/core/rtw_ap.c     |   4 +-
 .../rockchip_wlan/rtl8188eu/core/rtw_cmd.c    |   3 +-
 .../rockchip_wlan/rtl8188eu/core/rtw_debug.c  | 213 ++++-
 .../rtl8188eu/core/rtw_ioctl_set.c            |   5 +-
 .../rockchip_wlan/rtl8188eu/core/rtw_mlme.c   |  16 +-
 .../rtl8188eu/core/rtw_mlme_ext.c             |  17 +-
 .../rockchip_wlan/rtl8188eu/core/rtw_recv.c   | 405 +++++++++-
 .../rtl8188eu/core/rtw_sta_mgt.c              |   2 +-
 .../rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c   |   5 +-
 .../rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h   |   2 +-
 .../rtl8188eu/hal/OUTSRC/odm_HWConfig.c       |   9 +
 .../rtl8188eu/hal/OUTSRC/odm_HWConfig.h       |   6 +
 .../hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c      |  10 +-
 .../hal/rtl8188e/rtl8188e_hal_init.c          | 760 +++++++++++++++++-
 .../rtl8188eu/hal/rtl8188e/rtl8188e_phycfg.c  | 103 +--
 .../rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c  |  17 +-
 .../rtl8188eu/hal/rtl8188e/usb/usb_halinit.c  | 703 ----------------
 .../rtl8188eu/include/autoconf.h              |   2 +-
 .../rtl8188eu/include/drv_conf.h              |   1 +
 .../rtl8188eu/include/ioctl_cfg80211.h        |   4 +-
 .../rtl8188eu/include/osdep_service_linux.h   |  14 +-
 .../rtl8188eu/include/recv_osdep.h            |   2 +
 .../rtl8188eu/include/rtl8188e_hal.h          |   3 +
 .../rtl8188eu/include/rtw_debug.h             |   8 +-
 .../rtl8188eu/include/rtw_mlme.h              |  91 ++-
 .../rtl8188eu/include/rtw_mlme_ext.h          |   1 +
 .../rtl8188eu/include/rtw_recv.h              |  15 +-
 .../rtl8188eu/include/rtw_version.h           |   2 +-
 .../rtl8188eu/include/wlan_bssdef.h           |   3 +-
 .../rtl8188eu/os_dep/linux/ioctl_cfg80211.c   |  87 +-
 .../rtl8188eu/os_dep/linux/ioctl_linux.c      |  68 +-
 .../rtl8188eu/os_dep/linux/recv_linux.c       |  49 ++
 .../rtl8188eu/os_dep/linux/rtw_android.c      |  49 +-
 .../rtl8188eu/os_dep/linux/rtw_proc.c         |  16 +-
 .../rtl8188eu/os_dep/linux/usb_intf.c         |   8 +-
 .../rtl8188eu/os_dep/linux/wifi_version.h     |   2 +-
 37 files changed, 1765 insertions(+), 947 deletions(-)

diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/Makefile b/drivers/net/wireless/rockchip_wlan/rtl8188eu/Makefile
index 1ee2464ce3c6..537ad72b29dd 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/Makefile
@@ -55,6 +55,7 @@ CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY = n
 CONFIG_CALIBRATE_TX_POWER_TO_MAX = n
 CONFIG_RTW_ADAPTIVITY_EN = disable
 CONFIG_RTW_ADAPTIVITY_MODE = normal
+CONFIG_SKIP_SIGNAL_SCALE_MAPPING = n
 ######################## Wake On Lan ##########################
 CONFIG_WOWLAN = n
 CONFIG_GPIO_WAKEUP = n
@@ -726,6 +727,10 @@ else ifeq ($(CONFIG_RTW_ADAPTIVITY_MODE), carrier_sense)
 EXTRA_CFLAGS += -DCONFIG_RTW_ADAPTIVITY_MODE=1
 endif
 
+ifeq ($(CONFIG_SKIP_SIGNAL_SCALE_MAPPING), y)
+EXTRA_CFLAGS += -DCONFIG_SKIP_SIGNAL_SCALE_MAPPING
+endif
+
 ifeq ($(CONFIG_WOWLAN), y)
 EXTRA_CFLAGS += -DCONFIG_WOWLAN
 ifeq ($(CONFIG_SDIO_HCI), y)
@@ -1043,7 +1048,7 @@ EXTRA_CFLAGS += -DCONFIG_RADIO_WORK
 ARCH := arm
 CROSS_COMPILE := /home/android_sdk/Rockchip/Rk3188/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
 KSRC := /home/android_sdk/Rockchip/Rk3188/kernel
-MODULE_NAME := wlan
+MODULE_NAME := 8188eu
 endif
 
 ifeq ($(CONFIG_PLATFORM_ARM_RK3066), y)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ap.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ap.c
index ce46a12e6360..15b2ac25da0e 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ap.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ap.c
@@ -2969,12 +2969,10 @@ int rtw_sta_flush(_adapter *padapter)
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(padapter->pnetdev));
-
 	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		return ret;
 
-
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(padapter->pnetdev));
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_cmd.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_cmd.c
index 6d8aa0438098..ca1ac28ba118 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_cmd.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_cmd.c
@@ -524,8 +524,6 @@ _func_enter_;
 
 		pcmdpriv->cmd_issued_cnt++;
 
-		pcmd->cmdsz = _RND4((pcmd->cmdsz));//_RND4
-
 		_rtw_memcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
 
 		if(pcmd->cmdcode < (sizeof(wlancmds) /sizeof(struct cmd_hdl)))
@@ -1345,6 +1343,7 @@ _func_enter_;
 			case Ndis802_11APMode:
 			case Ndis802_11AutoUnknown:
 			case Ndis802_11InfrastructureMax:
+			case Ndis802_11Monitor:
 				break;
 
 		}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_debug.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_debug.c
index b63b77990dc2..ba3cdb214c6d 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_debug.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_debug.c
@@ -151,6 +151,49 @@ void rf_reg_dump(void *sel, _adapter *adapter)
 	}
 }
 
+void dump_adapters_status(void *sel, struct dvobj_priv *dvobj)
+{
+	int i;
+	_adapter *iface;
+	u8 u_ch, u_bw, u_offset;
+
+	DBG_871X_SEL_NL(sel, "%-2s %-8s %-4s %-7s %s\n"
+		, "id", "ifname", "port", "ch", "status");
+
+	DBG_871X_SEL_NL(sel, "------------------------\n");
+
+	for (i = 0; i < dvobj->iface_nums; i++) {
+		iface = dvobj->padapters[i];
+		if (iface) {
+			DBG_871X_SEL_NL(sel, "%2d %-8s %4hhu %3u,%u,%u "MLME_STATE_FMT" %s%s\n"
+				, i, ADPT_ARG(iface)
+				, get_iface_type(iface)
+				, iface->mlmeextpriv.cur_channel
+				, iface->mlmeextpriv.cur_bwmode
+				, iface->mlmeextpriv.cur_ch_offset
+				, ADPT_MLME_S_ARG(iface)
+				, iface->bSurpriseRemoved?" SR":""
+				, iface->bDriverStopped?" DS":""
+			);
+		}
+	}
+
+	DBG_871X_SEL_NL(sel, "------------------------\n");
+
+	rtw_get_ch_setting_union(dvobj->padapters[IFACE_ID0], &u_ch, &u_bw, &u_offset);
+	DBG_871X_SEL_NL(sel, "%16s %3u,%u,%u\n"
+		, "union:"
+		, u_ch, u_bw, u_offset
+	);
+
+	DBG_871X_SEL_NL(sel, "%16s %3u,%u,%u\n"
+		, "oper:"
+		, dvobj->oper_channel
+		, dvobj->oper_bwmode
+		, dvobj->oper_ch_offset
+	);
+}
+
 #ifdef CONFIG_PROC_DEBUG
 ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
@@ -466,15 +509,23 @@ int proc_get_survey_info(struct seq_file *m, void *v)
 	struct wlan_network	*pnetwork = NULL;
 	_list	*plist, *phead;
 	s32 notify_signal;
-	u16  index = 0;
+	s16 notify_noise = 0;
+	u16  index = 0, ie_cap = 0;
+	unsigned char *ie_wpa = NULL, *ie_wpa2 = NULL, *ie_wps = NULL;
+	unsigned char *ie_p2p = NULL, *ssid = NULL;
+	char flag_str[64];
+	int ielen = 0;
+	u32 wpsielen = 0;
 
 	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);	
 	phead = get_list_head(queue);
+	if(!phead)
+		return 0;
 	plist = get_next(phead);
-	if ((!phead) || (!plist))
+	if (!plist)
 		return 0;
 
-	DBG_871X_SEL_NL(m, "%5s  %-17s  %3s  %-3s  %-4s  %5s  %s\n","index", "bssid", "ch", "dBm", "SdBm", "age", "ssid");
+	DBG_871X_SEL_NL(m, "%5s  %-17s  %3s  %-3s  %-4s  %-4s  %5s  %32s  %32s\n", "index", "bssid", "ch", "RSSI", "SdBm", "Noise", "age", "flag", "ssid");
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
@@ -490,15 +541,34 @@ int proc_get_survey_info(struct seq_file *m, void *v)
 		} else {
 			notify_signal = translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);//dbm
 		}
+
+		#if defined(CONFIG_SIGNAL_DISPLAY_DBM) && defined(CONFIG_BACKGROUND_NOISE_MONITOR)
+		rtw_hal_get_odm_var(padapter, HAL_ODM_NOISE_MONITOR,&(pnetwork->network.Configuration.DSConfig), &(notify_noise));
+		#endif
 	
-		DBG_871X_SEL_NL(m, "%5d  "MAC_FMT"  %3d  %3d  %4d  %5d  %s\n", 
+		ie_wpa = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &ielen, pnetwork->network.IELength-12);	
+		ie_wpa2 = rtw_get_wpa2_ie(&pnetwork->network.IEs[12], &ielen, pnetwork->network.IELength-12);
+		ie_cap = rtw_get_capability(&pnetwork->network);
+		ie_wps = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength-12, NULL, &wpsielen);
+		ie_p2p = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength-12, NULL, &ielen);
+		ssid = pnetwork->network.Ssid.Ssid;
+		sprintf(flag_str, "%s%s%s%s%s%s%s",
+					(ie_wpa) ? "[WPA]":"",
+					(ie_wpa2) ? "[WPA2]":"",
+					(!ie_wpa && !ie_wpa && ie_cap & BIT(4)) ? "[WEP]":"",
+					(ie_wps) ? "[WPS]":"",
+					(pnetwork->network.InfrastructureMode == Ndis802_11IBSS) ? "[IBSS]":"",
+					(ie_cap & BIT(0)) ? "[ESS]":"",
+					(ie_p2p) ? "[P2P]":"");
+		DBG_871X_SEL_NL(m, "%5d  "MAC_FMT"  %3d  %3d  %4d  %4d    %5d  %32s  %32s\n", 
 			++index,
 			MAC_ARG(pnetwork->network.MacAddress), 
 			pnetwork->network.Configuration.DSConfig,
 			(int)pnetwork->network.Rssi,
 			notify_signal,
+			notify_noise,
 			rtw_get_passing_time_ms((u32)pnetwork->last_scanned),
-			//translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength),
+			flag_str,
 			pnetwork->network.Ssid.Ssid);
 		plist = get_next(plist);
 	}
@@ -507,6 +577,82 @@ int proc_get_survey_info(struct seq_file *m, void *v)
 	return 0;
 }
 
+ssize_t proc_set_survey_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	_irqL irqL;
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	bool need_indicate_scan_done = _FALSE;
+	u8 _status = _FALSE;
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+
+	if (count < 1)
+		return -EFAULT;
+
+#ifdef CONFIG_MP_INCLUDED
+		if ((padapter->registrypriv.mp_mode == 1)
+#ifdef CONFIG_CONCURRENT_MODE
+		|| ((padapter->pbuddy_adapter) && (padapter->pbuddy_adapter->registrypriv.mp_mode == 1))
+#endif			
+		){
+			DBG_871X(FUNC_ADPT_FMT ": MP mode block Scan request\n", FUNC_ADPT_ARG(padapter));	
+			goto exit;
+		}
+#endif
+	rtw_ps_deny(padapter, PS_DENY_SCAN);
+	if (_FAIL == rtw_pwr_wakeup(padapter))
+		goto exit;
+
+	if (padapter->bDriverStopped) {
+		DBG_871X("scan abort!! bDriverStopped=%d\n", padapter->bDriverStopped);
+		goto exit;
+	}
+	
+	if (!padapter->bup) {
+		DBG_871X("scan abort!! bup=%d\n", padapter->bup);
+		goto exit;
+	}
+	
+	if (padapter->hw_init_completed == _FALSE) {
+		DBG_871X("scan abort!! hw_init_completed=FALSE\n");
+		goto exit;
+	}
+	
+	if (rtw_is_scan_deny(padapter)) {
+		DBG_871X(FUNC_ADPT_FMT  ": scan deny\n", FUNC_ADPT_ARG(padapter));
+		goto exit;
+	}
+	
+	if ((pmlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE)
+#ifdef CONFIG_CONCURRENT_MODE
+	|| (rtw_get_buddy_bBusyTraffic(padapter) == _TRUE)
+#endif
+	) {
+		DBG_871X("scan abort!! BusyTraffic == _TRUE\n");
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) {
+		DBG_8192C("scan abort!! fwstate=0x%x\n", pmlmepriv->fw_state);
+		goto exit;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter,
+		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE) {
+		DBG_871X("scan abort!! buddy_fwstate=0x%x\n",
+				get_fwstate(&(padapter->pbuddy_adapter->mlmepriv)));
+		goto exit;
+	}
+#endif
+	_status = rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
+
+exit:
+	rtw_ps_deny_cancel(padapter, PS_DENY_SCAN);
+	return count;
+}
+
 int proc_get_ap_info(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -558,17 +704,6 @@ int proc_get_ap_info(struct seq_file *m, void *v)
 
 	return 0;
 }
-
-int proc_get_adapter_state(struct seq_file *m, void *v)
-{
-	struct net_device *dev = m->private;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-
-	DBG_871X_SEL_NL(m, "bSurpriseRemoved=%d, bDriverStopped=%d\n", 
-						padapter->bSurpriseRemoved, padapter->bDriverStopped);
-
-	return 0;
-}
 	
 int proc_get_trx_info(struct seq_file *m, void *v)
 {
@@ -1405,5 +1540,51 @@ ssize_t proc_set_sreset(struct file *file, const char __user *buffer, size_t cou
 }
 #endif /* DBG_CONFIG_ERROR_DETECT */
 
+int proc_get_monitor(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	if (WIFI_MONITOR_STATE == get_fwstate(pmlmepriv)) {
+		DBG_871X_SEL_NL(m, "Monitor mode : Enable\n");
+
+		DBG_871X_SEL_NL(m, "ch=%d, ch_offset=%d, bw=%d\n",
+						rtw_get_oper_ch(padapter), rtw_get_oper_choffset(padapter), rtw_get_oper_bw(padapter));
+	} else {
+		DBG_871X_SEL_NL(m, "Monitor mode : Disable\n");
+	}
+
+	return 0;
+}
+
+ssize_t proc_set_monitor(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
+{
+	char tmp[32];
+	struct net_device *dev = data;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	u8 target_chan, target_offset, target_bw;
+
+	if (count < 3) {
+		DBG_871X("argument size is less than 3\n");
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%hhu %hhu %hhu", &target_chan, &target_offset, &target_bw);
+
+		if (num != 3) {
+			DBG_871X("invalid write_reg parameter!\n");
+			return count;
+		}
+
+		padapter->mlmeextpriv.cur_channel  = target_chan;
+		set_channel_bwmode(padapter, target_chan, target_offset, target_bw);
+	}
+
+	return count;
+}
+
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ioctl_set.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ioctl_set.c
index 59b88f4d5c10..c8ad4264d3d6 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ioctl_set.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_ioctl_set.c
@@ -673,7 +673,10 @@ _func_enter_;
 
 			case Ndis802_11AutoUnknown:
 			case Ndis802_11InfrastructureMax:
-				break;                        				
+				break;
+			case Ndis802_11Monitor:
+				set_fwstate(pmlmepriv, WIFI_MONITOR_STATE);
+				break;
 		}
 
 		//SecClearAllKeys(adapter);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme.c
index 17346eaa97da..f88ad4ebac9c 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme.c
@@ -1265,7 +1265,7 @@ _func_enter_;
 					rtw_update_registrypriv_dev_network(adapter);
 					rtw_generate_random_ibss(pibss);
 
-                       			pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+					pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
 			
 					if(rtw_createbss_cmd(adapter)!=_SUCCESS)
 					{
@@ -1501,7 +1501,7 @@ _func_enter_;
 	if(lock_scanned_queue)
 		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 	
-	pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
+	pwlan = _rtw_find_same_network(&pmlmepriv->scanned_queue, tgt_network);
 	if(pwlan)		
 	{
 		pwlan->fixed = _FALSE;
@@ -1543,7 +1543,8 @@ _func_enter_;
 	if((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) && (adapter->stapriv.asoc_sta_count== 1))
 		/*||check_fwstate(pmlmepriv, WIFI_STATION_STATE)*/)
 	{
-		rtw_free_network_nolock(pmlmepriv, pwlan); 
+		if (pwlan)
+			rtw_free_network_nolock(pmlmepriv, pwlan);
 	}
 
 	if(lock_scanned_queue)
@@ -3667,6 +3668,7 @@ void rtw_update_registrypriv_dev_network(_adapter* adapter)
 	struct	security_priv*	psecuritypriv = &adapter->securitypriv;
 	struct	wlan_network	*cur_network = &adapter->mlmepriv.cur_network;
 	//struct	xmit_priv	*pxmitpriv = &adapter->xmitpriv;
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 
 _func_enter_;
 
@@ -3714,9 +3716,15 @@ _func_enter_;
 	pdev_network->Configuration.DSConfig = (pregistrypriv->channel);
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("pregistrypriv->channel=%d, pdev_network->Configuration.DSConfig=0x%x\n", pregistrypriv->channel, pdev_network->Configuration.DSConfig));	
 
-	if(cur_network->network.InfrastructureMode == Ndis802_11IBSS)
+	if (cur_network->network.InfrastructureMode == Ndis802_11IBSS) {
 		pdev_network->Configuration.ATIMWindow = (0);
 
+		if (pmlmeext->cur_channel != 0)
+			pdev_network->Configuration.DSConfig = pmlmeext->cur_channel;
+		else 
+			pdev_network->Configuration.DSConfig = 1;
+	}
+
 	pdev_network->InfrastructureMode = (cur_network->network.InfrastructureMode);
 
 	// 1. Supported rates
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme_ext.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme_ext.c
index 85c89c729697..7ab93df61be3 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_mlme_ext.c
@@ -9448,6 +9448,12 @@ void site_survey(_adapter *padapter)
 			} else {
 				pmlmeinfo->scan_cnt++;
 			}
+		} else {
+			if (pmlmeinfo->backop_cnt > 0) {
+				stay_buddy_ch = 2;
+				pmlmeinfo->scan_cnt = 1;
+				pmlmeinfo->backop_cnt = 0;
+			}	
 		}
 #endif
 		if(pmlmeext->sitesurvey_res.channel_idx == 0)
@@ -11990,6 +11996,8 @@ u8 setopmode_hdl(_adapter *padapter, u8 *pbuf)
 	else if(psetop->mode == Ndis802_11IBSS)
 	{
 		type = _HW_STATE_ADHOC_;
+	} else if (psetop->mode == Ndis802_11Monitor) {
+		type = _HW_STATE_MONITOR_;
 	}
 	else
 	{
@@ -12203,7 +12211,11 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 	
 	if(pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
 		return H2C_PARAMETERS_ERROR;	
-		
+	
+	if (pnetwork->IELength < 2) {
+		report_join_res(padapter, (-4));
+		return H2C_SUCCESS;
+	}
 	_rtw_memcpy(pnetwork->IEs, ((WLAN_BSSID_EX *)pbuf)->IEs, pnetwork->IELength); 
 
 	pmlmeext->cur_channel = (u8)pnetwork->Configuration.DSConfig;
@@ -12213,8 +12225,7 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 	//pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->IEs, pnetwork->IELength);
 
 	//sizeof(NDIS_802_11_FIXED_IEs)	
-	for (i = _FIXED_IE_LENGTH_; i < pnetwork->IELength;)
-	{
+	for (i = _FIXED_IE_LENGTH_ ; i < pnetwork->IELength - 2 ;) {
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(pnetwork->IEs + i);
 
 		switch (pIE->ElementID)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_recv.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_recv.c
index 1fd632d6e8b8..1aa6304aa898 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_recv.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_recv.c
@@ -20,6 +20,7 @@
 #define _RTW_RECV_C_
 
 #include <drv_types.h>
+#include <hal_data.h>
 
 #if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
 
@@ -30,8 +31,23 @@
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS);
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
 
+enum {
+	SIGNAL_STAT_CALC_PROFILE_0 = 0,
+	SIGNAL_STAT_CALC_PROFILE_1,
+	SIGNAL_STAT_CALC_PROFILE_MAX
+};
+
+u8 signal_stat_calc_profile[SIGNAL_STAT_CALC_PROFILE_MAX][2] = {
+	{4, 1},	/* Profile 0 => pre_stat : curr_stat = 4 : 1 */
+	{3, 7}	/* Profile 1 => pre_stat : curr_stat = 3 : 7 */
+};
+
+#ifndef RTW_SIGNAL_STATE_CALC_PROFILE	
+#define RTW_SIGNAL_STATE_CALC_PROFILE SIGNAL_STAT_CALC_PROFILE_0
+#endif
+
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
 
 void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
 {
@@ -3699,6 +3715,357 @@ _func_exit_;
 
 }
 
+static sint fill_radiotap_hdr(_adapter *padapter, union recv_frame *precvframe, u8 *buf)
+{
+#define CHAN2FREQ(a) ((a < 14)?(2407+5*a):(5000+5*a))
+
+#if 0
+#define RTW_RX_RADIOTAP_PRESENT (                 \
+		(1 << IEEE80211_RADIOTAP_TSFT)              | \
+		(1 << IEEE80211_RADIOTAP_FLAGS)             | \
+		(1 << IEEE80211_RADIOTAP_RATE)              | \
+		(1 << IEEE80211_RADIOTAP_CHANNEL)           | \
+		(0 << IEEE80211_RADIOTAP_FHSS)              | \
+		(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL)     | \
+		(1 << IEEE80211_RADIOTAP_DBM_ANTNOISE)      | \
+		(0 << IEEE80211_RADIOTAP_LOCK_QUALITY)      | \
+		(0 << IEEE80211_RADIOTAP_TX_ATTENUATION)    | \
+		(0 << IEEE80211_RADIOTAP_DB_TX_ATTENUATION) | \
+		(0 << IEEE80211_RADIOTAP_DBM_TX_POWER)      | \
+		(1 << IEEE80211_RADIOTAP_ANTENNA)           | \
+		(1 << IEEE80211_RADIOTAP_DB_ANTSIGNAL)      | \
+		(0 << IEEE80211_RADIOTAP_DB_ANTNOISE)       | \
+		(0 << IEEE80211_RADIOTAP_RX_FLAGS)          | \
+		(0 << IEEE80211_RADIOTAP_TX_FLAGS)          | \
+		(0 << IEEE80211_RADIOTAP_RTS_RETRIES)       | \
+		(0 << IEEE80211_RADIOTAP_DATA_RETRIES)      | \
+		(0 << IEEE80211_RADIOTAP_MCS)               | \
+		(0 << IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE)| \
+		(0 << IEEE80211_RADIOTAP_VENDOR_NAMESPACE)  | \
+		(0 << IEEE80211_RADIOTAP_EXT)               | \
+		0)
+
+	/* (0 << IEEE80211_RADIOTAP_AMPDU_STATUS)      | \ */
+	/* (0 << IEEE80211_RADIOTAP_VHT)               | \ */
+#endif
+#ifndef IEEE80211_RADIOTAP_MCS
+#define IEEE80211_RADIOTAP_MCS 19
+#endif
+#ifndef IEEE80211_RADIOTAP_VHT
+#define IEEE80211_RADIOTAP_VHT 21
+#endif
+
+#ifndef IEEE80211_RADIOTAP_F_BADFCS
+#define IEEE80211_RADIOTAP_F_BADFCS 0x40 /* bad FCS */
+#endif
+
+	sint ret = _SUCCESS;
+	_adapter			*adapter = precvframe->u.hdr.adapter;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	struct rx_pkt_attrib *pattrib = &precvframe->u.hdr.attrib;
+
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
+
+	u16 tmp_16bit = 0;
+
+	u8 data_rate[] = {
+		2, 4, 11, 22, /* CCK */
+		12, 18, 24, 36, 48, 72, 93, 108, /* OFDM */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, /* HT MCS index */
+		16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, /* VHT Nss 1 */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, /* VHT Nss 2 */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, /* VHT Nss 3 */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, /* VHT Nss 4 */
+	};
+
+	_pkt *pskb = NULL;
+
+	struct ieee80211_radiotap_header *rtap_hdr = NULL;
+	u8 *ptr = NULL;
+
+	u8 hdr_buf[64] = {0};
+	u16 rt_len = 8;
+
+	/* create header */
+	rtap_hdr = (struct ieee80211_radiotap_header *)&hdr_buf[0];
+	rtap_hdr->it_version = PKTHDR_RADIOTAP_VERSION;
+
+	/* tsft */
+	if (pattrib->tsfl) {
+		u64 tmp_64bit;
+
+		rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_TSFT);
+		tmp_64bit = cpu_to_le64(pattrib->tsfl);
+		memcpy(&hdr_buf[rt_len], &tmp_64bit, 8);
+		rt_len += 8;
+	}
+
+	/* flags */
+	rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_FLAGS);
+	if (0)
+		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_CFP;
+
+	if (0)
+		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_SHORTPRE;
+
+	if ((pattrib->encrypt == 1) || (pattrib->encrypt == 5))
+		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_WEP;
+
+	if (pattrib->mfrag)
+		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FRAG;
+
+#ifndef CONFIG_RX_PACKET_APPEND_FCS
+		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_FCS;
+#endif
+
+	if (0)
+		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_DATAPAD;
+
+	if (pattrib->crc_err)
+		hdr_buf[rt_len] |= IEEE80211_RADIOTAP_F_BADFCS;
+
+	if (pattrib->sgi) {
+		/* Currently unspecified but used */
+		hdr_buf[rt_len] |= 0x80;
+	}
+	rt_len += 1;
+
+	/* rate */
+	if (pattrib->data_rate < 12) {
+		rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_RATE);
+		if (pattrib->data_rate < 4) {
+			/* CCK */
+			hdr_buf[rt_len] = data_rate[pattrib->data_rate];
+		} else {
+			/* OFDM */
+			hdr_buf[rt_len] = data_rate[pattrib->data_rate];
+		}
+	}
+	rt_len += 1; /* force padding 1 byte for aligned */
+
+	/* channel */
+	tmp_16bit = 0;
+	rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_CHANNEL);
+	tmp_16bit = CHAN2FREQ(rtw_get_oper_ch(padapter));
+	/*tmp_16bit = CHAN2FREQ(pHalData->CurrentChannel);*/
+	memcpy(&hdr_buf[rt_len], &tmp_16bit, 2);
+	rt_len += 2;
+
+	/* channel flags */
+	tmp_16bit = 0;
+	if (pHalData->CurrentBandType == 0) 
+		tmp_16bit |= cpu_to_le16(IEEE80211_CHAN_2GHZ);
+	else 
+		tmp_16bit |= cpu_to_le16(IEEE80211_CHAN_5GHZ);
+
+	if (pattrib->data_rate < 12) {
+		if (pattrib->data_rate < 4) {
+			/* CCK */
+			tmp_16bit |= cpu_to_le16(IEEE80211_CHAN_CCK);
+		} else {
+			/* OFDM */
+			tmp_16bit |= cpu_to_le16(IEEE80211_CHAN_OFDM);
+		}
+	} else {
+		tmp_16bit |= cpu_to_le16(IEEE80211_CHAN_DYN);
+	}
+	memcpy(&hdr_buf[rt_len], &tmp_16bit, 2);
+	rt_len += 2;
+
+	/* dBm Antenna Signal */
+	rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL);
+	hdr_buf[rt_len] = pattrib->phy_info.RecvSignalPower;
+	rt_len += 1;
+
+#if 0
+	/* dBm Antenna Noise */
+	rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE);
+	hdr_buf[rt_len] = 0;
+	rt_len += 1;
+
+	/* Signal Quality */
+	rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_LOCK_QUALITY);
+	hdr_buf[rt_len] = pattrib->phy_info.SignalQuality;
+	rt_len += 1;
+#endif
+
+	/* Antenna */
+	rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_ANTENNA);
+	hdr_buf[rt_len] = 0; /* pHalData->rf_type; */
+	rt_len += 1;
+
+	/* RX flags */
+	rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_RX_FLAGS);
+#if 0
+	tmp_16bit = cpu_to_le16(0);
+	memcpy(ptr, &tmp_16bit, 1);
+#endif
+	rt_len += 2;
+
+	/* MCS information */
+	if (pattrib->data_rate >= 12 && pattrib->data_rate < 44) {
+		rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_MCS);
+		/* known, flag */
+		hdr_buf[rt_len] |= BIT1; /* MCS index known */
+
+		/* bandwidth */
+		hdr_buf[rt_len] |= BIT0;
+		hdr_buf[rt_len+1] |= (pattrib->bw & 0x03);
+
+		/* guard interval */
+		hdr_buf[rt_len] |= BIT2;
+		hdr_buf[rt_len+1] |= (pattrib->sgi & 0x01) << 2;
+
+		/* STBC */
+		hdr_buf[rt_len] |= BIT5;
+		hdr_buf[rt_len+1] |= (pattrib->stbc & 0x03) << 5;
+
+		rt_len += 2;
+
+		/* MCS rate index */
+		hdr_buf[rt_len] = data_rate[pattrib->data_rate];
+		rt_len += 1;
+	}
+
+	/* VHT */
+	if (pattrib->data_rate >= 44 && pattrib->data_rate < 84) {
+		rtap_hdr->it_present |= (1 << IEEE80211_RADIOTAP_VHT);
+
+		/* known 16 bit, flag 8 bit */
+		tmp_16bit = 0;
+
+		/* Bandwidth */
+		tmp_16bit |= BIT6;
+
+		/* Group ID */
+		tmp_16bit |= BIT7;
+
+		/* Partial AID */
+		tmp_16bit |= BIT8;
+
+		/* STBC */
+		tmp_16bit |= BIT0;
+		hdr_buf[rt_len+2] |= (pattrib->stbc & 0x01);
+
+		/* Guard interval */
+		tmp_16bit |= BIT2;
+		hdr_buf[rt_len+2] |= (pattrib->sgi & 0x01) << 2;
+
+		/* LDPC extra OFDM symbol */
+		tmp_16bit |= BIT4;
+		hdr_buf[rt_len+2] |= (pattrib->ldpc & 0x01) << 4;
+
+		memcpy(&hdr_buf[rt_len], &tmp_16bit, 2);
+		rt_len += 3;
+
+		/* bandwidth */
+		if (pattrib->bw == 0) 
+			hdr_buf[rt_len] |= 0;
+		else if (pattrib->bw == 1) 
+			hdr_buf[rt_len] |= 1;
+		else if (pattrib->bw == 2) 
+			hdr_buf[rt_len] |= 4;
+		else if (pattrib->bw == 3) 
+			hdr_buf[rt_len] |= 11;
+		rt_len += 1;
+
+		/* mcs_nss */
+		if (pattrib->data_rate >= 44 && pattrib->data_rate < 54) {
+			hdr_buf[rt_len] |= 1;
+			hdr_buf[rt_len] |= data_rate[pattrib->data_rate] << 4;
+		} else if (pattrib->data_rate >= 54 && pattrib->data_rate < 64) {
+			hdr_buf[rt_len + 1] |= 2;
+			hdr_buf[rt_len + 1] |= data_rate[pattrib->data_rate] << 4;
+		} else if (pattrib->data_rate >= 64 && pattrib->data_rate < 74) {
+			hdr_buf[rt_len + 2] |= 3;
+			hdr_buf[rt_len + 2] |= data_rate[pattrib->data_rate] << 4;
+		} else if (pattrib->data_rate >= 74 && pattrib->data_rate < 84) {
+			hdr_buf[rt_len + 3] |= 4;
+			hdr_buf[rt_len + 3] |= data_rate[pattrib->data_rate] << 4;
+		}
+		rt_len += 4;
+
+		/* coding */
+		hdr_buf[rt_len] = 0;
+		rt_len += 1;
+
+		/* group_id */
+		hdr_buf[rt_len] = 0;
+		rt_len += 1;
+
+		/* partial_aid */
+		tmp_16bit = 0;
+		memcpy(&hdr_buf[rt_len], &tmp_16bit, 2);
+		rt_len += 2;
+	}
+
+	/* push to skb */
+	pskb = (_pkt *)buf;
+	if (skb_headroom(pskb) < rt_len) {
+		DBG_871X("%s:%d %s headroom is too small.\n", __FILE__, __LINE__, __func__);
+		ret = _FAIL;
+		return ret;
+	}
+
+	ptr = skb_push(pskb, rt_len);
+	if (ptr) {
+		rtap_hdr->it_len = cpu_to_le16(rt_len);
+		memcpy(ptr, rtap_hdr, rt_len);
+	} else {
+		ret = _FAIL;
+	}
+
+	return ret;
+
+}
+
+int recv_frame_monitor(_adapter *padapter, union recv_frame *rframe)
+{
+	int ret = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &rframe->u.hdr.attrib;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	_queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+	_pkt *pskb = NULL;
+
+	/* read skb information from recv frame */
+	pskb = rframe->u.hdr.pkt;
+	pskb->len = rframe->u.hdr.len;
+	pskb->data = rframe->u.hdr.rx_data;
+	skb_set_tail_pointer(pskb, rframe->u.hdr.len);
+
+	/* fill radiotap header */
+	if (fill_radiotap_hdr(padapter, rframe, (u8 *)pskb) == _FAIL) {
+		ret = _FAIL;
+		rtw_free_recvframe(rframe, pfree_recv_queue); /* free this recv_frame */
+		goto exit;
+	}
+
+	/* write skb information to recv frame */
+	skb_reset_mac_header(pskb);
+	rframe->u.hdr.len = pskb->len;
+	rframe->u.hdr.rx_data = pskb->data;
+	rframe->u.hdr.rx_head = pskb->head;
+	rframe->u.hdr.rx_tail = skb_tail_pointer(pskb);
+	rframe->u.hdr.rx_end = skb_end_pointer(pskb);
+
+	if ((padapter->bDriverStopped == _FALSE) && (padapter->bSurpriseRemoved == _FALSE)) {
+		/* indicate this recv_frame */
+		ret = rtw_recv_monitor(padapter, rframe);
+		if (ret != _SUCCESS) {
+			ret = _FAIL;
+			rtw_free_recvframe(rframe, pfree_recv_queue); /* free this recv_frame */
+			goto exit;
+		}
+	} else {
+		ret = _FAIL;
+		rtw_free_recvframe(rframe, pfree_recv_queue); /* free this recv_frame */
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
 
 int recv_func_prehandle(_adapter *padapter, union recv_frame *rframe)
 {
@@ -4039,6 +4406,13 @@ int recv_func(_adapter *padapter, union recv_frame *rframe)
 	struct security_priv *psecuritypriv=&padapter->securitypriv;
 	struct mlme_priv *mlmepriv = &padapter->mlmepriv;
 
+	if (check_fwstate(mlmepriv, WIFI_MONITOR_STATE)) {
+		/* monitor mode */
+		recv_frame_monitor(padapter, rframe);
+		ret = _SUCCESS;
+		goto exit;
+	} else
+
 	/* check if need to handle uc_swdec_pending_queue*/
 	if (check_fwstate(mlmepriv, WIFI_STATION_STATE) && psecuritypriv->busetkipkey)
 	{
@@ -4139,7 +4513,7 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS){
 	u8 avg_signal_qual = 0;
 	u32 num_signal_strength = 0;
 	u32 num_signal_qual = 0;
-	u8 _alpha = 5; // this value is based on converging_constant = 5000 and sampling_interval = 1000
+	u8 ratio_pre_stat = 0, ratio_curr_stat = 0, ratio_total = 0, ratio_profile = SIGNAL_STAT_CALC_PROFILE_0;
 
 	if(adapter->recvpriv.is_signal_dbg) {
 		//update the user specific value, signal_strength_dbg, to signal_strength, rssi
@@ -4180,21 +4554,28 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS){
 			goto set_timer;
 		#endif
 
+		if (RTW_SIGNAL_STATE_CALC_PROFILE < SIGNAL_STAT_CALC_PROFILE_MAX)
+			ratio_profile = RTW_SIGNAL_STATE_CALC_PROFILE;
+
+		ratio_pre_stat = signal_stat_calc_profile[ratio_profile][0];
+		ratio_curr_stat = signal_stat_calc_profile[ratio_profile][1];
+		ratio_total = ratio_pre_stat + ratio_curr_stat;
+
 		//update value of signal_strength, rssi, signal_qual
-		tmp_s = (avg_signal_strength+(_alpha-1)*recvpriv->signal_strength);
-		if(tmp_s %_alpha)
-			tmp_s = tmp_s/_alpha + 1;
+		tmp_s = (ratio_curr_stat * avg_signal_strength + ratio_pre_stat * recvpriv->signal_strength);
+		if (tmp_s % ratio_total)
+			tmp_s = tmp_s / ratio_total + 1;
 		else
-			tmp_s = tmp_s/_alpha;
-		if(tmp_s>100)
+			tmp_s = tmp_s / ratio_total;
+		if (tmp_s > 100)
 			tmp_s = 100;
 
-		tmp_q = (avg_signal_qual+(_alpha-1)*recvpriv->signal_qual);
-		if(tmp_q %_alpha)
-			tmp_q = tmp_q/_alpha + 1;
+		tmp_q = (ratio_curr_stat * avg_signal_qual + ratio_pre_stat * recvpriv->signal_qual);
+		if (tmp_q % ratio_total)
+			tmp_q = tmp_q / ratio_total + 1;
 		else
-			tmp_q = tmp_q/_alpha;
-		if(tmp_q>100)
+			tmp_q = tmp_q / ratio_total;
+		if (tmp_q > 100)
 			tmp_q = 100;
 
 		recvpriv->signal_strength = tmp_s;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_sta_mgt.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_sta_mgt.c
index f25fa5421203..d62976c7649e 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_sta_mgt.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/core/rtw_sta_mgt.c
@@ -695,7 +695,7 @@ _func_enter_;
 	
 	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
-	for (index = 0; index < free_sta_num; free_sta_num++) 
+	for (index = 0; index < free_sta_num; index++) 
 	{
 		psta = rtw_get_stainfo_by_offset(pstapriv, free_sta_list[index]);
 		rtw_free_stainfo(padapter , psta);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c
index 3395559149ec..c39d8c7f90a1 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.c
@@ -368,7 +368,7 @@ Phydm_SearchPwdBLowerBound(
 	PDM_ODM_T		pDM_Odm = (PDM_ODM_T)pDM_VOID;
 	PADAPTIVITY_STATISTICS	Adaptivity = (PADAPTIVITY_STATISTICS)PhyDM_Get_Structure(pDM_Odm, PHYDM_ADAPTIVITY);
 	u4Byte			value32 = 0;
-	u1Byte			cnt, IGI_Pause = 0x7f, IGI_Resume = 0x20, IGI = 0x50;		/*IGI = 0x50 for cal EDCCA lower bound*/
+	u1Byte			cnt, IGI_Pause = 0x7f, IGI_Resume = 0x20, IGI = 0x45;		/*IGI = 0x50 for cal EDCCA lower bound*/
 	u1Byte			txEdcca1 = 0, txEdcca0 = 0;
 	BOOLEAN			bAdjust = TRUE;
 	s1Byte 			TH_L2H_dmc, TH_H2L_dmc, IGI_target = 0x32;
@@ -387,7 +387,7 @@ Phydm_SearchPwdBLowerBound(
 	ODM_delay_ms(5);
 
 	while (bAdjust) {
-		for (cnt = 0; cnt < 250; cnt++) {
+		for (cnt = 0; cnt < 20; cnt++) {
 			if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
 				value32 = ODM_GetBBReg(pDM_Odm, ODM_REG_RPT_11N, bMaskDWord);
 #if (RTL8195A_SUPPORT == 0)
@@ -538,7 +538,6 @@ Phydm_AdaptivityInit(
 #else
 	if (pDM_Odm->SupportICType & ODM_RTL8814A) {		/*8814a no need to find pwdB lower bound, maybe*/
 		ODM_SetBBReg(pDM_Odm, ODM_REG_EDCCA_DOWN_OPT, BIT30 | BIT29 | BIT28, 0x7);		/*interfernce need > 2^x us, and then EDCCA will be 1*/
-		ODM_SetBBReg(pDM_Odm, ODM_REG_EDCCA_POWER_CAL, BIT5, 1);						/*0:mean, 1:max pwdB*/
 		ODM_SetBBReg(pDM_Odm, ODM_REG_ACBB_EDCCA_ENHANCE, BIT29 | BIT28, 0x1);		/*0:rx_dfir, 1: dcnf_out, 2 :rx_iq, 3: rx_nbi_nf_out*/
 	} else
 		Phydm_SearchPwdBLowerBound(pDM_Odm);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h
index 136c5dca79ef..c95b0a7d97ee 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/PhyDM_Adaptivity.h
@@ -21,7 +21,7 @@
 #ifndef	__PHYDMADAPTIVITY_H__
 #define    __PHYDMADAPTIVITY_H__
 
-#define ADAPTIVITY_VERSION	"8.5"
+#define ADAPTIVITY_VERSION	"8.5.1"
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN))
 typedef enum _tag_PhyDM_REGULATION_Type {
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.c
index bbe652377427..c155990f7c43 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.c
@@ -1020,8 +1020,12 @@ odm_RxPhyStatus92CSeries_Parsing(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 		// 2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/	
 		pPhyInfo->SignalStrength = (u1Byte)(SignalScaleMapping(pDM_Odm->Adapter, PWDB_ALL));//PWDB_ALL;
+#else
+#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+		pPhyInfo->SignalStrength = (u1Byte)PWDB_ALL;
 #else
 		pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, PWDB_ALL));//PWDB_ALL;
+#endif
 #endif
 	}
 	else
@@ -1031,8 +1035,13 @@ odm_RxPhyStatus92CSeries_Parsing(
 #if (DM_ODM_SUPPORT_TYPE == ODM_WIN)
 			// 2012/01/12 MH Use customeris signal strength from HalComRxdDesc.c/	
 			pPhyInfo->SignalStrength = (u1Byte)(SignalScaleMapping(pDM_Odm->Adapter, total_rssi/=rf_rx_num));//PWDB_ALL;
+#else
+#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+			total_rssi/=rf_rx_num;
+			pPhyInfo->SignalStrength = (u1Byte)total_rssi;
 #else
 			pPhyInfo->SignalStrength = (u1Byte)(odm_SignalScaleMapping(pDM_Odm, total_rssi/=rf_rx_num));
+#endif
 #endif
 		}
 	}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.h
index 16a26f6da780..90ab84b7ec45 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/odm_HWConfig.h
@@ -225,6 +225,12 @@ ODM_GetHWImgVersion(
 	IN	PDM_ODM_T	pDM_Odm
 	);
 
+s4Byte
+odm_SignalScaleMapping(	
+	IN OUT PDM_ODM_T pDM_Odm,
+	IN	s4Byte CurrSig 
+	);
+
 #endif
 
 #endif
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c
index 2f3779b773f9..5b7aeb8a8d63 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/OUTSRC/rtl8188e/HalPhyRf_8188e.c
@@ -2313,11 +2313,6 @@ PHY_IQCalibrate_8188E(
 	if (pDM_Odm->RFCalibrateInfo.bIQKInProgress) 
 		return;
 
-	ODM_AcquireSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
-	pDM_Odm->RFCalibrateInfo.bIQKInProgress = TRUE;
-	ODM_ReleaseSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
-
-
 #if (DM_ODM_SUPPORT_TYPE & (ODM_CE|ODM_AP))
 	if(bReCovery)
 #else//for ODM_WIN
@@ -2332,6 +2327,11 @@ PHY_IQCalibrate_8188E(
 #endif
 		return;		
 	}
+
+	ODM_AcquireSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
+	pDM_Odm->RFCalibrateInfo.bIQKInProgress = TRUE;
+	ODM_ReleaseSpinLock(pDM_Odm, RT_IQK_SPINLOCK);
+
 	StartTime = ODM_GetCurrentTime( pDM_Odm);
 	ODM_RT_TRACE(pDM_Odm,ODM_COMP_CALIBRATION, ODM_DBG_LOUD,  ("IQK:Start!!!\n"));
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_hal_init.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_hal_init.c
index 10dd48ade6e6..78a3fcaa1b65 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_hal_init.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_hal_init.c
@@ -3824,6 +3824,589 @@ void _InitTransferPageSize(PADAPTER padapter)
 	rtw_write8(padapter, REG_PBP, value8);
 }
 
+void ResumeTxBeacon(_adapter *padapter)
+{
+	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);	
+
+	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
+	// which should be read from register to a global variable.
+
+	rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
+	pHalData->RegFwHwTxQCtrl |= BIT6;
+	rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0xff);
+	pHalData->RegReg542 |= BIT0;
+	rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
+}
+
+void StopTxBeacon(_adapter *padapter)
+{
+	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);
+
+	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
+	// which should be read from register to a global variable.
+
+	rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
+	pHalData->RegFwHwTxQCtrl &= (~BIT6);
+	rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0x64);
+	pHalData->RegReg542 &= ~(BIT0);
+	rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
+
+	CheckFwRsvdPageContent(padapter);  // 2010.06.23. Added by tynli.
+}
+
+static void hw_var_set_monitor(PADAPTER Adapter, u8 variable, u8 *val)
+{
+	u32	value_rcr, rcr_bits;
+	u16	value_rxfltmap2;
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
+
+	if (*((u8 *)val) == _HW_STATE_MONITOR_) {
+
+		/* Leave IPS */
+		rtw_pm_set_ips(Adapter, IPS_NONE);
+		LeaveAllPowerSaveMode(Adapter);
+
+		/* Receive all type */
+		rcr_bits = RCR_AAP | RCR_APM | RCR_AM | RCR_AB | RCR_APWRMGT | RCR_ADF | RCR_ACF | RCR_AMF | RCR_APP_PHYST_RXFF;
+
+		/* Append FCS */
+		rcr_bits |= RCR_APPFCS;
+
+		#if 0
+		/* 
+		   CRC and ICV packet will drop in recvbuf2recvframe()
+		   We no turn on it.
+		 */
+		rcr_bits |= (RCR_ACRC32 | RCR_AICV);
+		#endif
+
+		/* Receive all data frames */
+		value_rxfltmap2 = 0xFFFF;
+
+		value_rcr = rcr_bits;
+		rtw_write32(Adapter, REG_RCR, value_rcr);
+
+		rtw_write16(Adapter, REG_RXFLTMAP2, value_rxfltmap2);
+
+		#if 0
+		/* tx pause */
+		rtw_write8(padapter, REG_TXPAUSE, 0xFF);
+		#endif
+	} else {
+		/* do nothing */
+	}
+
+}
+
+static void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
+{
+	u8	val8;
+	u8	mode = *((u8 *)val);
+
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+
+	/* reset RCR */
+	rtw_write32(Adapter, REG_RCR, pHalData->ReceiveConfig);
+
+	if (mode == _HW_STATE_MONITOR_) {
+		/* set net_type */
+		Set_MSR(Adapter, _HW_STATE_NOLINK_);
+
+		hw_var_set_monitor(Adapter, variable, val);
+		return;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if(Adapter->iface_type == IFACE_PORT1)
+	{
+		// disable Port1 TSF update
+		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
+		
+		// set net_type
+		val8 = rtw_read8(Adapter, MSR)&0x03;
+		val8 |= (mode<<2);
+		rtw_write8(Adapter, MSR, val8);
+		
+		DBG_871X("%s()-%d mode = %d\n", __FUNCTION__, __LINE__, mode);
+
+		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+		{
+			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))			
+			{
+				#ifdef CONFIG_INTERRUPT_BASED_TXBCN	
+
+				#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT	
+				rtw_write8(Adapter, REG_DRVERLYINT, 0x05);//restore early int time to 5ms
+				UpdateInterruptMask8188EU(Adapter,_TRUE, 0, IMR_BCNDMAINT0_88E);	
+				#endif // CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+				
+				#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR		
+				UpdateInterruptMask8188EU(Adapter,_TRUE ,0, (IMR_TBDER_88E|IMR_TBDOK_88E));	
+				#endif// CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+					
+				#endif //CONFIG_INTERRUPT_BASED_TXBCN		
+			
+
+				StopTxBeacon(Adapter);
+			}
+			
+			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x11);//disable atim wnd and disable beacon function
+			//rtw_write8(Adapter,REG_BCN_CTRL_1, 0x18);
+		}
+		else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+		{
+			ResumeTxBeacon(Adapter);
+			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x1a);
+			//BIT4 - If set 0, hw will clr bcnq when tx becon ok/fail or port 1
+			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
+		}
+		else if(mode == _HW_STATE_AP_)
+		{
+#ifdef CONFIG_INTERRUPT_BASED_TXBCN			
+			#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+			UpdateInterruptMask8188EU(Adapter,_TRUE ,IMR_BCNDMAINT0_88E, 0);
+			#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+
+			#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR	
+			UpdateInterruptMask8188EU(Adapter,_TRUE ,(IMR_TBDER_88E|IMR_TBDOK_88E), 0);
+			#endif//CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+					
+#endif //CONFIG_INTERRUPT_BASED_TXBCN
+
+			ResumeTxBeacon(Adapter);
+					
+			rtw_write8(Adapter, REG_BCN_CTRL_1, 0x12);
+
+			//Set RCR
+			//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
+			//rtw_write32(Adapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
+			rtw_write32(Adapter, REG_RCR, 0x7000208e);//CBSSID_DATA must set to 0,reject ICV_ERR packet
+			//enable to rx data frame				
+			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
+			//enable to rx ps-poll
+			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
+
+			//Beacon Control related register for first time 
+			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms		
+
+			//rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
+			rtw_write8(Adapter, REG_ATIMWND_1, 0x0a); // 10ms for port1
+			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
+			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
+			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
+	
+			//reset TSF2	
+			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
+
+
+			//BIT4 - If set 0, hw will clr bcnq when tx becon ok/fail or port 1
+			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
+		       	//enable BCN1 Function for if2
+			//don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received)
+			rtw_write8(Adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
+
+#ifdef CONFIG_CONCURRENT_MODE
+			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
+				rtw_write8(Adapter, REG_BCN_CTRL, 
+					rtw_read8(Adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
+#endif
+                        //BCN1 TSF will sync to BCN0 TSF with offset(0x518) if if1_sta linked
+			//rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(5));
+			//rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(3));
+					
+			//dis BCN0 ATIM  WND if if1 is station
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(0));
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+			// Reset TSF for STA+AP concurrent mode
+			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
+				if (reset_tsf(Adapter, IFACE_PORT1) == _FALSE)
+					DBG_871X("ERROR! %s()-%d: Reset port1 TSF fail\n",
+						__FUNCTION__, __LINE__);
+			}
+#endif	// CONFIG_TSF_RESET_OFFLOAD	
+		}
+	}
+	else
+#endif //CONFIG_CONCURRENT_MODE
+	{
+		// disable Port0 TSF update
+		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+		
+		// set net_type
+		val8 = rtw_read8(Adapter, MSR)&0x0c;
+		val8 |= mode;
+		rtw_write8(Adapter, MSR, val8);
+		
+		DBG_871X("%s()-%d mode = %d\n", __FUNCTION__, __LINE__, mode);
+		
+		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+		{
+#ifdef CONFIG_CONCURRENT_MODE
+			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))		
+#endif //CONFIG_CONCURRENT_MODE
+			{
+			#ifdef CONFIG_INTERRUPT_BASED_TXBCN	
+				#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+				rtw_write8(Adapter, REG_DRVERLYINT, 0x05);//restore early int time to 5ms					
+				UpdateInterruptMask8188EU(Adapter,_TRUE, 0, IMR_BCNDMAINT0_88E);	
+				#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+				
+				#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR		
+				UpdateInterruptMask8188EU(Adapter,_TRUE ,0, (IMR_TBDER_88E|IMR_TBDOK_88E));	
+				#endif //CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+					
+			#endif //CONFIG_INTERRUPT_BASED_TXBCN		
+				StopTxBeacon(Adapter);
+			}
+			
+			rtw_write8(Adapter,REG_BCN_CTRL, 0x19);//disable atim wnd
+			//rtw_write8(Adapter,REG_BCN_CTRL, 0x18);
+		}
+		else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+		{
+			ResumeTxBeacon(Adapter);
+			rtw_write8(Adapter,REG_BCN_CTRL, 0x1a);
+			//BIT3 - If set 0, hw will clr bcnq when tx becon ok/fail or port 0
+			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
+		}
+		else if(mode == _HW_STATE_AP_)
+		{
+
+#ifdef CONFIG_INTERRUPT_BASED_TXBCN			
+			#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+			UpdateInterruptMask8188EU(Adapter,_TRUE ,IMR_BCNDMAINT0_88E, 0);
+			#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
+
+			#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR	
+			UpdateInterruptMask8188EU(Adapter,_TRUE ,(IMR_TBDER_88E|IMR_TBDOK_88E), 0);
+			#endif//CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+					
+#endif //CONFIG_INTERRUPT_BASED_TXBCN
+
+
+			ResumeTxBeacon(Adapter);
+
+			rtw_write8(Adapter, REG_BCN_CTRL, 0x12);
+
+			//Set RCR
+			//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
+			//rtw_write32(Adapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
+			rtw_write32(Adapter, REG_RCR, 0x7000208e);//CBSSID_DATA must set to 0,reject ICV_ERR packet
+			//enable to rx data frame
+			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
+			//enable to rx ps-poll
+			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
+
+			//Beacon Control related register for first time
+			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms			
+			
+			//rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
+			rtw_write8(Adapter, REG_ATIMWND, 0x0a); // 10ms
+			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
+			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
+			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
+
+			//reset TSF
+			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
+
+			//BIT3 - If set 0, hw will clr bcnq when tx becon ok/fail or port 0
+			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
+	
+		        //enable BCN0 Function for if1
+			//don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received)
+			#if defined(CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR)
+			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
+			#else
+			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION |BIT(1)));
+			#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
+				rtw_write8(Adapter, REG_BCN_CTRL_1, 
+					rtw_read8(Adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
+#endif
+
+			//dis BCN1 ATIM  WND if if2 is station
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(0));	
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+			// Reset TSF for STA+AP concurrent mode
+			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
+				if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
+					DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
+						__FUNCTION__, __LINE__);
+			}
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+		}
+	}
+}
+
+static void hw_var_set_correct_tsf(PADAPTER Adapter, u8 variable, u8* val)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	u64	tsf;
+	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
+
+	//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
+	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
+
+	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{				
+		//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
+		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
+		StopTxBeacon(Adapter);
+	}
+
+	if(Adapter->iface_type == IFACE_PORT1)
+	{
+		//disable related TSF function
+		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+							
+		rtw_write32(Adapter, REG_TSFTR1, tsf);
+		rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
+
+
+		//enable related TSF function
+		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));	
+
+		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
+		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
+		) { 
+			//disable related TSF function
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
+
+			rtw_write32(Adapter, REG_TSFTR, tsf);
+			rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
+
+			//enable related TSF function
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+		// Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue!
+			if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
+				DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
+					__FUNCTION__, __LINE__);
+
+#endif	// CONFIG_TSF_RESET_OFFLOAD	
+		}		
+
+		
+	}
+	else
+	{
+		//disable related TSF function
+		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
+							
+		rtw_write32(Adapter, REG_TSFTR, tsf);
+		rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
+
+		//enable related TSF function
+		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
+		
+		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
+		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
+		) { 
+			//disable related TSF function
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+
+			rtw_write32(Adapter, REG_TSFTR1, tsf);
+			rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
+
+			//enable related TSF function
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
+			if (reset_tsf(Adapter, IFACE_PORT1) == _FALSE)
+				DBG_871X("ERROR! %s()-%d: Reset port1 TSF fail\n",
+					__FUNCTION__, __LINE__);
+#endif	// CONFIG_TSF_RESET_OFFLOAD
+		}		
+
+	}
+				
+							
+	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{
+		//pHalData->RegTxPause  &= (~STOP_BCNQ);
+		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
+		ResumeTxBeacon(Adapter);
+	}
+#endif
+}
+
+static void hw_var_set_mlme_sitesurvey(PADAPTER Adapter, u8 variable, u8* val)
+{	
+#ifdef CONFIG_CONCURRENT_MODE	
+	struct mlme_priv *pmlmepriv=&(Adapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u32	value_rcr, rcr_clear_bit, value_rxfltmap2;
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	rcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);
+	// Recieve all data frames
+	 value_rxfltmap2 = 0xFFFF;
+#else /* CONFIG_FIND_BEST_CHANNEL */
+	rcr_clear_bit = RCR_CBSSID_BCN;
+	//config RCR to receive different BSSID & not to receive data frame
+	value_rxfltmap2 = 0;
+#endif /* CONFIG_FIND_BEST_CHANNEL */
+
+	if( (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		#ifdef CONFIG_CONCURRENT_MODE
+		|| (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE)
+		#endif
+	){
+		rcr_clear_bit = RCR_CBSSID_BCN; 
+	}
+#ifdef CONFIG_TDLS
+	// TDLS will clear RCR_CBSSID_DATA bit for connection.
+	else if (Adapter->tdlsinfo.link_established == _TRUE)
+	{
+		rcr_clear_bit = RCR_CBSSID_BCN;
+	}
+#endif // CONFIG_TDLS
+
+	value_rcr = rtw_read32(Adapter, REG_RCR);
+	if(*((u8 *)val))//under sitesurvey
+	{
+		value_rcr &= ~(rcr_clear_bit);
+		rtw_write32(Adapter, REG_RCR, value_rcr);
+		rtw_write16(Adapter, REG_RXFLTMAP2, value_rxfltmap2);
+
+		//disable update TSF
+		if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+		{
+			if(Adapter->iface_type == IFACE_PORT1)
+			{
+				rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
+			}
+			else
+			{
+				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+			}
+		}
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))
+		{
+			StopTxBeacon(Adapter);
+		}
+	}
+	else//sitesurvey done
+	{
+		//enable to rx data frame
+		//write32(Adapter, REG_RCR, read32(padapter, REG_RCR)|RCR_ADF);
+		if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE))
+			|| check_buddy_fwstate(Adapter, (_FW_LINKED|WIFI_AP_STATE)))
+			rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
+
+		//enable update TSF
+		if(Adapter->iface_type == IFACE_PORT1)
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
+		else
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
+
+		value_rcr |= rcr_clear_bit;
+		rtw_write32(Adapter, REG_RCR, value_rcr);
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))
+		{
+			ResumeTxBeacon(Adapter);
+		}
+	}
+#endif
+}
+
+static void hw_var_set_mlme_join(PADAPTER Adapter, u8 variable, u8* val)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	u8	RetryLimit = 0x30;
+	u8	type = *((u8 *)val);
+	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
+	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
+	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+
+	if(type == 0) // prepare to join
+	{		
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))		
+		{
+			StopTxBeacon(Adapter);
+		}
+	
+		//enable to rx data frame.Accept all data frame
+		//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+		rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);
+		else
+			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+
+		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+		{
+			RetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;
+		}
+		else // Ad-hoc Mode
+		{
+			RetryLimit = 0x7;
+		}
+	}
+	else if(type == 1) //joinbss_event call back when join res < 0
+	{		
+		if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))		
+			rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))
+		{
+			ResumeTxBeacon(Adapter);			
+			
+			//reset TSF 1/2 after ResumeTxBeacon
+			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));	
+			
+		}
+	}
+	else if(type == 2) //sta add event call back
+	{
+	 
+		//enable update TSF
+		if(Adapter->iface_type == IFACE_PORT1)
+			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
+		else
+			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
+		 
+	
+		if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
+		{
+			//fixed beacon issue for 8191su...........
+			rtw_write8(Adapter,0x542 ,0x02);
+			RetryLimit = 0x7;
+		}
+
+
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(Adapter, _FW_LINKED))
+		{
+			ResumeTxBeacon(Adapter);			
+			
+			//reset TSF 1/2 after ResumeTxBeacon
+			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));
+		}
+		
+	}
+
+	rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+	
+#endif
+}
+
 void SetHwReg8188E(_adapter *adapter, u8 variable, u8 *val)
 {
 	HAL_DATA_TYPE *HalData = GET_HAL_DATA(adapter);
@@ -3831,11 +4414,14 @@ void SetHwReg8188E(_adapter *adapter, u8 variable, u8 *val)
 _func_enter_;
 
 	switch (variable) {
+	case HW_VAR_SET_OPMODE:
+		hw_var_set_opmode(adapter, variable, val);
+		break;
 	case HW_VAR_BASIC_RATE:
 	{
 		struct mlme_ext_info *mlmext_info = &adapter->mlmeextpriv.mlmext_info;
 		u16 input_b = 0, masked = 0, ioted = 0, BrateCfg = 0, RateIndex = 0;
-		u16 rrsr_2g_force_mask = (RRSR_11M|RRSR_5_5M|RRSR_1M);
+		u16 rrsr_2g_force_mask = (RRSR_11M|RRSR_5_5M|RRSR_2M|RRSR_1M);
 		u16 rrsr_2g_allow_mask = (RRSR_24M|RRSR_12M|RRSR_6M|RRSR_11M|RRSR_5_5M|RRSR_2M|RRSR_1M);
 
 		HalSetBrateCfg(adapter, val, &BrateCfg);
@@ -3871,6 +4457,178 @@ _func_enter_;
 		rtw_write8(adapter, REG_INIRTS_RATE_SEL, RateIndex);
 	}
 		break;
+	case HW_VAR_CORRECT_TSF:
+#ifdef CONFIG_CONCURRENT_MODE
+		hw_var_set_correct_tsf(adapter, variable, val);
+#else			
+	{
+		u64 tsf;
+		struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+		struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+		//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
+		tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
+
+		if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+		{				
+			//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
+			//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
+			StopTxBeacon(adapter);
+		}
+
+		//disable related TSF function
+		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(3)));
+					
+		rtw_write32(adapter, REG_TSFTR, tsf);
+		rtw_write32(adapter, REG_TSFTR+4, tsf>>32);
+
+		//enable related TSF function
+		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(3));
+		
+					
+		if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+		{
+			//pHalData->RegTxPause &= (~STOP_BCNQ);
+			//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
+			ResumeTxBeacon(adapter);
+		}
+	}
+#endif
+		break;
+	case HW_VAR_MLME_SITESURVEY:
+#ifdef CONFIG_CONCURRENT_MODE
+		hw_var_set_mlme_sitesurvey(adapter, variable,  val);
+#else
+	{
+		u32 value_rcr, rcr_clear_bit, value_rxfltmap2;
+#ifdef CONFIG_FIND_BEST_CHANNEL
+
+		rcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);
+
+		// Recieve all data frames
+		value_rxfltmap2 = 0xFFFF;
+
+#else /* CONFIG_FIND_BEST_CHANNEL */
+
+		rcr_clear_bit = RCR_CBSSID_BCN;
+
+		//config RCR to receive different BSSID & not to receive data frame
+		value_rxfltmap2 = 0;
+
+#endif /* CONFIG_FIND_BEST_CHANNEL */
+
+		if (check_fwstate(&adapter->mlmepriv, WIFI_AP_STATE) == _TRUE) {
+			rcr_clear_bit = RCR_CBSSID_BCN;
+		}
+#ifdef CONFIG_TDLS
+		// TDLS will clear RCR_CBSSID_DATA bit for connection.
+		else if (adapter->tdlsinfo.link_established == _TRUE) {
+			rcr_clear_bit = RCR_CBSSID_BCN;
+		}
+#endif // CONFIG_TDLS
+
+		value_rcr = rtw_read32(adapter, REG_RCR);
+		if(*((u8 *)val))//under sitesurvey
+		{
+			//config RCR to receive different BSSID & not to receive data frame
+			value_rcr &= ~(rcr_clear_bit);
+			rtw_write32(adapter, REG_RCR, value_rcr);
+			rtw_write16(adapter, REG_RXFLTMAP2, value_rxfltmap2);
+
+			//disable update TSF
+			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
+		}
+		else//sitesurvey done
+		{
+			struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+			struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+			if ((is_client_associated_to_ap(adapter) == _TRUE) ||
+				((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) )
+			{
+				//enable to rx data frame
+				//rtw_write32(Adapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+				rtw_write16(adapter, REG_RXFLTMAP2,0xFFFF);
+
+				//enable update TSF
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
+			}
+			else if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+			{
+				//rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_ADF);
+				rtw_write16(adapter, REG_RXFLTMAP2,0xFFFF);
+
+				//enable update TSF
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
+			}
+
+			value_rcr |= rcr_clear_bit;
+			if(((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE) && (adapter->in_cta_test)) {
+				u32 v = rtw_read32(adapter, REG_RCR);
+				v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
+				rtw_write32(adapter, REG_RCR, v);
+			} else {
+				rtw_write32(adapter, REG_RCR, value_rcr);	
+			}
+		}
+	}
+#endif			
+		break;
+	case HW_VAR_MLME_JOIN:
+#ifdef CONFIG_CONCURRENT_MODE
+		hw_var_set_mlme_join(adapter, variable,  val);
+#else
+	{
+		u8	RetryLimit = 0x30;
+		u8	type = *((u8 *)val);
+		struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+		EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+		
+		if(type == 0) // prepare to join
+		{
+			//enable to rx data frame.Accept all data frame
+			//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+			rtw_write16(adapter, REG_RXFLTMAP2,0xFFFF);
+
+			if(adapter->in_cta_test)
+			{
+				u32 v = rtw_read32(adapter, REG_RCR);
+				v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
+				rtw_write32(adapter, REG_RCR, v);
+			}
+			else
+			{
+				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+			}
+
+			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+			{
+				RetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;
+			}
+			else // Ad-hoc Mode
+			{
+				RetryLimit = 0x7;
+			}
+		}
+		else if(type == 1) //joinbss_event call back when join res < 0
+		{
+			rtw_write16(adapter, REG_RXFLTMAP2,0x00);
+		}
+		else if(type == 2) //sta add event call back
+		{
+			//enable update TSF
+			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
+
+			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
+			{
+				RetryLimit = 0x7;
+			}
+		}
+
+		rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+	}
+#endif
+		break;
 	case HW_VAR_CHECK_TXBUF:
 	{
 		u8 retry_limit;
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_phycfg.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_phycfg.c
index b4445d2340c5..d573cd26d6b5 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_phycfg.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_phycfg.c
@@ -867,40 +867,6 @@ phy_InitBBRFRegisterDefinition(
 
 }
 
-//****************************************
-// The following is for High Power PA
-//****************************************
-VOID
-phy_ConfigBBExternalPA(
-	IN	PADAPTER			Adapter
-)
-{
-#ifdef CONFIG_USB_HCI
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u16 i=0;
-	u32 temp=0;
-
-	if(!pHalData->ExternalPA)
-	{
-		return;
-	}
-
-	// 2010/10/19 MH According to Jenyu/EEChou 's opinion, we need not to execute the
-	// same code as SU. It is already updated in PHY_REG_1T_HP.txt.
-#if 0
-	PHY_SetBBReg(Adapter, 0xee8, BIT28, 1);
-	temp = PHY_QueryBBReg(Adapter, 0x860, bMaskDWord);
-	temp |= (BIT26|BIT21|BIT10|BIT5);
-	PHY_SetBBReg(Adapter, 0x860, bMaskDWord, temp);
-	PHY_SetBBReg(Adapter, 0x870, BIT10, 0);
-	PHY_SetBBReg(Adapter, 0xc80, bMaskDWord, 0x20000080);
-	PHY_SetBBReg(Adapter, 0xc88, bMaskDWord, 0x40000100);
-#endif
-
-#endif
-}
-
-
 VOID
 storePwrIndexDiffRateOffset(
 	IN	PADAPTER	Adapter,
@@ -1070,7 +1036,6 @@ phy_BB8188E_Config_ParaFile(
 	IN	PADAPTER	Adapter
 	)
 {
-	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	int			rtStatus = _SUCCESS;
 
@@ -1258,7 +1223,6 @@ PHY_BBConfig8188E(
 
 #ifdef CONFIG_PCI_HCI
 	// Force use left antenna by default for 88C.
-	//	if(!IS_92C_SERIAL(pHalData->VersionID) || IS_92C_1T2R(pHalData->VersionID))
 	if(Adapter->ledpriv.LedStrategy != SW_LED_MODE10)
 	{
 		RegVal = rtw_read32(Adapter, REG_LEDCFG0);
@@ -1367,36 +1331,6 @@ u32 Rtl8192S_HighPower_RadioA_Array[HighPowerRadioAArrayLen] = {
 0x013,0x00000240,
 };
 
-int
-PHY_ConfigRFExternalPA(
-	IN	PADAPTER		Adapter,
-	IN	u8				eRFPath
-)
-{
-	int	rtStatus = _SUCCESS;
-#ifdef CONFIG_USB_HCI
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u16 i=0;
-
-	if(!pHalData->ExternalPA)
-	{
-		return rtStatus;
-	}
-
-	// 2010/10/19 MH According to Jenyu/EEChou 's opinion, we need not to execute the
-	// same code as SU. It is already updated in radio_a_1T_HP.txt.
-#if 0
-	//add for SU High Power PA
-	for(i = 0;i<HighPowerRadioAArrayLen; i=i+2)
-	{
-		RT_TRACE(COMP_INIT, DBG_LOUD, ("External PA, write RF 0x%lx=0x%lx\n", Rtl8192S_HighPower_RadioA_Array[i], Rtl8192S_HighPower_RadioA_Array[i+1]));
-		PHY_SetRFReg(Adapter, eRFPath, Rtl8192S_HighPower_RadioA_Array[i], bRFRegOffsetMask, Rtl8192S_HighPower_RadioA_Array[i+1]);
-	}
-#endif
-
-#endif
-	return rtStatus;
-}
 //****************************************
 /*-----------------------------------------------------------------------------
  * Function:    GetTxPowerLevel8190()
@@ -1626,8 +1560,8 @@ PHY_GetTxPowerIndex_8188E(
 		txPower = MAX_POWER_INDEX;
 
 	if (0)
-	DBG_871X("RF-%c ch%d TxPwrIdx = %d(0x%X) [%2u %2d %2d %2d]\n"
-		, ((RFPath==0)?'A':'B'), Channel, txPower, txPower, base_index, by_rate_diff, track_diff, extra_bias);
+		DBG_871X("RF-%c ch%d TxPwrIdx = %d(0x%X) [%2u %2d %2d %2d]\n"
+			, ((RFPath==0)?'A':'B'), Channel, txPower, txPower, base_index, by_rate_diff, track_diff, extra_bias);
 
 	return (u8)txPower;	
 }
@@ -1687,22 +1621,19 @@ phy_SpurCalibration_8188E(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	
-	if(pHalData->CurrentChannelBW == CHANNEL_WIDTH_20 && pHalData->CurrentChannel == 13){
-		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT(28), 0x1); //enable CSI Mask
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask1, BIT(26)|BIT(25), 0x3); //Fix CSI Mask Tone
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask2, BIT(26)|BIT(25), 0x0); 
+	//DbgPrint("===> phy_SpurCalibration_8188E  CurrentChannelBW = %d, CurrentChannel = %d\n", pHalData->CurrentChannelBW, pHalData->CurrentChannel);
+	if(pHalData->CurrentChannelBW == CHANNEL_WIDTH_20 &&( pHalData->CurrentChannel == 13 || pHalData->CurrentChannel == 14)){
+		PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT(9), 0x1);                     	//enable notch filter
+		PHY_SetBBReg(Adapter, rOFDM1_IntfDet, BIT(8)|BIT(7)|BIT(6), 0x2);	//intf_TH
 	}
 	else if(pHalData->CurrentChannelBW == CHANNEL_WIDTH_40 && pHalData->CurrentChannel == 11){
-		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT(28), 0x1); //enable CSI Mask
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask1, BIT(26)|BIT(25), 0x0); 
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask2, BIT(26)|BIT(25), 0x3); //Fix CSI Mask Tone
+		PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT(9), 0x1);                     	//enable notch filter
+		PHY_SetBBReg(Adapter, rOFDM1_IntfDet, BIT(8)|BIT(7)|BIT(6), 0x2);	//intf_TH
 	}
 	else{
-		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT(28), 0x0); //disable CSI Mask
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask1, BIT(26)|BIT(25), 0x0); 
-		PHY_SetBBReg(Adapter, rOFDM1_csi_fix_mask2, BIT(26)|BIT(25), 0x0); 
+		if(Adapter->registrypriv.notch_filter == 0)
+			PHY_SetBBReg(Adapter, rOFDM0_RxDSP, BIT(9), 0x0);	//disable notch filter
 	}
-
 }
 
 /*-----------------------------------------------------------------------------
@@ -1939,8 +1870,10 @@ PHY_SetBWMode8188E(
 	#else
 		_PHY_SetBWMode88E(Adapter);
 	#endif
-		if (IS_VENDOR_8188E_I_CUT_SERIES(Adapter)&& IS_HARDWARE_TYPE_8188ES(Adapter))
+	#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+		if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
 			phy_SpurCalibration_8188E( Adapter);
+	#endif
 	}
 	else
 	{
@@ -2002,6 +1935,11 @@ PHY_SwChnl8188E(	// Call after initialization
 	//if(pHalData->SetBWModeInProgress)
 	//	return;
 
+	while(pHalData->odmpriv.RFCalibrateInfo.bLCKInProgress) {
+		DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" bLCKInProgress\n", FUNC_ADPT_ARG(Adapter));
+		rtw_msleep_os(50);
+	}	
+
 	//--------------------------------------------
 	switch(pHalData->CurrentWirelessMode)
 	{
@@ -2042,8 +1980,11 @@ PHY_SwChnl8188E(	// Call after initialization
 		_PHY_SwChnl8188E(Adapter, channel);
 		#endif
 
-		if (IS_VENDOR_8188E_I_CUT_SERIES(Adapter)&& IS_HARDWARE_TYPE_8188ES(Adapter))
+		#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
+		if(IS_VENDOR_8188E_I_CUT_SERIES(Adapter))
 			phy_SpurCalibration_8188E( Adapter);
+		#endif
+
 		
 
 		if(bResult)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c
index db0f41d741d7..98305e26d3ac 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/rtl8188e_rxdesc.c
@@ -22,19 +22,6 @@
 #include <drv_types.h>
 #include <rtl8188e_hal.h>
 
-static s32  translate2dbm(u8 signal_strength_idx)
-{
-	s32	signal_power; // in dBm.
-
-
-	// Translate to dBm (x=0.5y-95).
-	signal_power = (s32)((signal_strength_idx + 1) >> 1);
-	signal_power -= 95;
-
-	return signal_power;
-}
-
-
 static void process_rssi(_adapter *padapter,union recv_frame *prframe)
 {
 	u32	last_rssi, tmp_val;
@@ -77,10 +64,10 @@ static void process_rssi(_adapter *padapter,union recv_frame *prframe)
 		
 		if(padapter->recvpriv.is_signal_dbg) {
 			padapter->recvpriv.signal_strength= padapter->recvpriv.signal_strength_dbg;
-			padapter->recvpriv.rssi=(s8)translate2dbm((u8)padapter->recvpriv.signal_strength_dbg);
+			padapter->recvpriv.rssi=(s8)translate_percentage_to_dbm(padapter->recvpriv.signal_strength_dbg);
 		} else {
 			padapter->recvpriv.signal_strength= tmp_val;
-			padapter->recvpriv.rssi=(s8)translate2dbm((u8)tmp_val);
+			padapter->recvpriv.rssi=(s8)translate_percentage_to_dbm(tmp_val);
 		}
 
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("UI RSSI = %d, ui_rssi.TotalVal = %d, ui_rssi.TotalNum = %d\n", tmp_val, padapter->recvpriv.signal_strength_data.total_val,padapter->recvpriv.signal_strength_data.total_num));
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/usb/usb_halinit.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/usb/usb_halinit.c
index b384481b6c00..366b4bd17d33 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/usb/usb_halinit.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/hal/rtl8188e/usb/usb_halinit.c
@@ -2751,19 +2751,6 @@ static void rtl8192cu_trigger_gpio_0(_adapter *padapter)
 #endif
 }
 
-static void ResumeTxBeacon(_adapter *padapter)
-{
-	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);	
-
-	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
-	// which should be read from register to a global variable.
-
-	rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
-	pHalData->RegFwHwTxQCtrl |= BIT6;
-	rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0xff);
-	pHalData->RegReg542 |= BIT0;
-	rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
-}
 void UpdateInterruptMask8188EU(PADAPTER padapter,u8 bHIMR0 ,u32 AddMSR, u32 RemoveMSR)
 {
 	HAL_DATA_TYPE *pHalData;
@@ -2789,256 +2776,6 @@ void UpdateInterruptMask8188EU(PADAPTER padapter,u8 bHIMR0 ,u32 AddMSR, u32 Remo
 
 }
 
-static void StopTxBeacon(_adapter *padapter)
-{
-	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);
-
-	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
-	// which should be read from register to a global variable.
-
-	rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
-	pHalData->RegFwHwTxQCtrl &= (~BIT6);
-	rtw_write8(padapter, REG_TBTT_PROHIBIT+1, 0x64);
-	pHalData->RegReg542 &= ~(BIT0);
-	rtw_write8(padapter, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
-
-	 //todo: CheckFwRsvdPageContent(Adapter);  // 2010.06.23. Added by tynli.
-
-}
-
-
-static void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
-{
-	u8	val8;
-	u8	mode = *((u8 *)val);
-	//HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if(Adapter->iface_type == IFACE_PORT1)
-	{
-		// disable Port1 TSF update
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
-		
-		// set net_type
-		val8 = rtw_read8(Adapter, MSR)&0x03;
-		val8 |= (mode<<2);
-		rtw_write8(Adapter, MSR, val8);
-		
-		DBG_871X("%s()-%d mode = %d\n", __FUNCTION__, __LINE__, mode);
-
-		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
-		{
-			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))			
-			{
-				#ifdef CONFIG_INTERRUPT_BASED_TXBCN	
-
-				#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT	
-				rtw_write8(Adapter, REG_DRVERLYINT, 0x05);//restore early int time to 5ms
-				UpdateInterruptMask8188EU(Adapter,_TRUE, 0, IMR_BCNDMAINT0_88E);	
-				#endif // CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-				
-				#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR		
-				UpdateInterruptMask8188EU(Adapter,_TRUE ,0, (IMR_TBDER_88E|IMR_TBDOK_88E));	
-				#endif// CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
-					
-				#endif //CONFIG_INTERRUPT_BASED_TXBCN		
-			
-
-				StopTxBeacon(Adapter);
-			}
-			
-			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x11);//disable atim wnd and disable beacon function
-			//rtw_write8(Adapter,REG_BCN_CTRL_1, 0x18);
-		}
-		else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
-		{
-			ResumeTxBeacon(Adapter);
-			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x1a);
-			//BIT4 - If set 0, hw will clr bcnq when tx becon ok/fail or port 1
-			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
-		}
-		else if(mode == _HW_STATE_AP_)
-		{
-#ifdef CONFIG_INTERRUPT_BASED_TXBCN			
-			#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-			UpdateInterruptMask8188EU(Adapter,_TRUE ,IMR_BCNDMAINT0_88E, 0);
-			#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-
-			#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR	
-			UpdateInterruptMask8188EU(Adapter,_TRUE ,(IMR_TBDER_88E|IMR_TBDOK_88E), 0);
-			#endif//CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
-					
-#endif //CONFIG_INTERRUPT_BASED_TXBCN
-
-			ResumeTxBeacon(Adapter);
-					
-			rtw_write8(Adapter, REG_BCN_CTRL_1, 0x12);
-
-			//Set RCR
-			//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
-			//rtw_write32(Adapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
-			rtw_write32(Adapter, REG_RCR, 0x7000208e);//CBSSID_DATA must set to 0,reject ICV_ERR packet
-			//enable to rx data frame				
-			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
-			//enable to rx ps-poll
-			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
-
-			//Beacon Control related register for first time 
-			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms		
-
-			//rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
-			rtw_write8(Adapter, REG_ATIMWND_1, 0x0a); // 10ms for port1
-			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
-			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
-			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
-	
-			//reset TSF2	
-			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
-
-
-			//BIT4 - If set 0, hw will clr bcnq when tx becon ok/fail or port 1
-			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
-		       	//enable BCN1 Function for if2
-			//don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received)
-			rtw_write8(Adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
-
-#ifdef CONFIG_CONCURRENT_MODE
-			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
-				rtw_write8(Adapter, REG_BCN_CTRL, 
-					rtw_read8(Adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
-#endif
-                        //BCN1 TSF will sync to BCN0 TSF with offset(0x518) if if1_sta linked
-			//rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(5));
-			//rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(3));
-					
-			//dis BCN0 ATIM  WND if if1 is station
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(0));
-
-#ifdef CONFIG_TSF_RESET_OFFLOAD
-			// Reset TSF for STA+AP concurrent mode
-			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
-				if (reset_tsf(Adapter, IFACE_PORT1) == _FALSE)
-					DBG_871X("ERROR! %s()-%d: Reset port1 TSF fail\n",
-						__FUNCTION__, __LINE__);
-			}
-#endif	// CONFIG_TSF_RESET_OFFLOAD	
-		}
-	}
-	else
-#endif //CONFIG_CONCURRENT_MODE
-	{
-		// disable Port0 TSF update
-		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
-		
-		// set net_type
-		val8 = rtw_read8(Adapter, MSR)&0x0c;
-		val8 |= mode;
-		rtw_write8(Adapter, MSR, val8);
-		
-		DBG_871X("%s()-%d mode = %d\n", __FUNCTION__, __LINE__, mode);
-		
-		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
-		{
-#ifdef CONFIG_CONCURRENT_MODE
-			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))		
-#endif //CONFIG_CONCURRENT_MODE
-			{
-			#ifdef CONFIG_INTERRUPT_BASED_TXBCN	
-				#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-				rtw_write8(Adapter, REG_DRVERLYINT, 0x05);//restore early int time to 5ms					
-				UpdateInterruptMask8188EU(Adapter,_TRUE, 0, IMR_BCNDMAINT0_88E);	
-				#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-				
-				#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR		
-				UpdateInterruptMask8188EU(Adapter,_TRUE ,0, (IMR_TBDER_88E|IMR_TBDOK_88E));	
-				#endif //CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
-					
-			#endif //CONFIG_INTERRUPT_BASED_TXBCN		
-				StopTxBeacon(Adapter);
-			}
-			
-			rtw_write8(Adapter,REG_BCN_CTRL, 0x19);//disable atim wnd
-			//rtw_write8(Adapter,REG_BCN_CTRL, 0x18);
-		}
-		else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
-		{
-			ResumeTxBeacon(Adapter);
-			rtw_write8(Adapter,REG_BCN_CTRL, 0x1a);
-			//BIT3 - If set 0, hw will clr bcnq when tx becon ok/fail or port 0
-			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
-		}
-		else if(mode == _HW_STATE_AP_)
-		{
-
-#ifdef CONFIG_INTERRUPT_BASED_TXBCN			
-			#ifdef  CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-			UpdateInterruptMask8188EU(Adapter,_TRUE ,IMR_BCNDMAINT0_88E, 0);
-			#endif//CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT
-
-			#ifdef CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR	
-			UpdateInterruptMask8188EU(Adapter,_TRUE ,(IMR_TBDER_88E|IMR_TBDOK_88E), 0);
-			#endif//CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
-					
-#endif //CONFIG_INTERRUPT_BASED_TXBCN
-
-
-			ResumeTxBeacon(Adapter);
-
-			rtw_write8(Adapter, REG_BCN_CTRL, 0x12);
-
-			//Set RCR
-			//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
-			//rtw_write32(Adapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
-			rtw_write32(Adapter, REG_RCR, 0x7000208e);//CBSSID_DATA must set to 0,reject ICV_ERR packet
-			//enable to rx data frame
-			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
-			//enable to rx ps-poll
-			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
-
-			//Beacon Control related register for first time
-			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms			
-			
-			//rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
-			rtw_write8(Adapter, REG_ATIMWND, 0x0a); // 10ms
-			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
-			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
-			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
-
-			//reset TSF
-			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
-
-			//BIT3 - If set 0, hw will clr bcnq when tx becon ok/fail or port 0
-			rtw_write8(Adapter, REG_MBID_NUM, rtw_read8(Adapter, REG_MBID_NUM)|BIT(3)|BIT(4));
-	
-		        //enable BCN0 Function for if1
-			//don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received)
-			#if defined(CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR)
-			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
-			#else
-			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION |BIT(1)));
-			#endif
-
-#ifdef CONFIG_CONCURRENT_MODE
-			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
-				rtw_write8(Adapter, REG_BCN_CTRL_1, 
-					rtw_read8(Adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
-#endif
-
-			//dis BCN1 ATIM  WND if if2 is station
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(0));	
-#ifdef CONFIG_TSF_RESET_OFFLOAD
-			// Reset TSF for STA+AP concurrent mode
-			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
-				if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
-					DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
-						__FUNCTION__, __LINE__);
-			}
-#endif	// CONFIG_TSF_RESET_OFFLOAD
-		}
-	}
-
-}
-
 static void hw_var_set_macaddr(PADAPTER Adapter, u8 variable, u8* val)
 {
 	u8 idx = 0;
@@ -3112,102 +2849,6 @@ static void hw_var_set_bcn_func(PADAPTER Adapter, u8 variable, u8* val)
 
 }
 
-static void hw_var_set_correct_tsf(PADAPTER Adapter, u8 variable, u8* val)
-{
-#ifdef CONFIG_CONCURRENT_MODE
-	u64	tsf;
-	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
-
-	//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
-	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
-
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-	{				
-		//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
-		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
-		StopTxBeacon(Adapter);
-	}
-
-	if(Adapter->iface_type == IFACE_PORT1)
-	{
-		//disable related TSF function
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-							
-		rtw_write32(Adapter, REG_TSFTR1, tsf);
-		rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
-
-
-		//enable related TSF function
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));	
-
-		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
-		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
-		) { 
-			//disable related TSF function
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
-
-			rtw_write32(Adapter, REG_TSFTR, tsf);
-			rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
-
-			//enable related TSF function
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
-#ifdef CONFIG_TSF_RESET_OFFLOAD
-		// Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue!
-			if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
-				DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
-					__FUNCTION__, __LINE__);
-
-#endif	// CONFIG_TSF_RESET_OFFLOAD	
-		}		
-
-		
-	}
-	else
-	{
-		//disable related TSF function
-		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
-							
-		rtw_write32(Adapter, REG_TSFTR, tsf);
-		rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
-
-		//enable related TSF function
-		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
-		
-		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
-		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
-		) { 
-			//disable related TSF function
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-
-			rtw_write32(Adapter, REG_TSFTR1, tsf);
-			rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
-
-			//enable related TSF function
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
-#ifdef CONFIG_TSF_RESET_OFFLOAD
-		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
-			if (reset_tsf(Adapter, IFACE_PORT1) == _FALSE)
-				DBG_871X("ERROR! %s()-%d: Reset port1 TSF fail\n",
-					__FUNCTION__, __LINE__);
-#endif	// CONFIG_TSF_RESET_OFFLOAD
-		}		
-
-	}
-				
-							
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-	{
-		//pHalData->RegTxPause  &= (~STOP_BCNQ);
-		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
-		ResumeTxBeacon(Adapter);
-	}
-#endif
-}
-
 static void hw_var_set_mlme_disconnect(PADAPTER Adapter, u8 variable, u8* val)
 {
 #ifdef CONFIG_CONCURRENT_MODE
@@ -3241,175 +2882,6 @@ static void hw_var_set_mlme_disconnect(PADAPTER Adapter, u8 variable, u8* val)
 #endif
 }
 
-static void hw_var_set_mlme_sitesurvey(PADAPTER Adapter, u8 variable, u8* val)
-{	
-#ifdef CONFIG_CONCURRENT_MODE	
-	struct mlme_priv *pmlmepriv=&(Adapter->mlmepriv);
-	struct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
-	u32	value_rcr, rcr_clear_bit, value_rxfltmap2;
-
-#ifdef CONFIG_FIND_BEST_CHANNEL
-	rcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);
-	// Recieve all data frames
-	 value_rxfltmap2 = 0xFFFF;
-#else /* CONFIG_FIND_BEST_CHANNEL */
-	rcr_clear_bit = RCR_CBSSID_BCN;
-	//config RCR to receive different BSSID & not to receive data frame
-	value_rxfltmap2 = 0;
-#endif /* CONFIG_FIND_BEST_CHANNEL */
-
-	if( (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
-		#ifdef CONFIG_CONCURRENT_MODE
-		|| (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE)
-		#endif
-	){
-		rcr_clear_bit = RCR_CBSSID_BCN; 
-	}
-#ifdef CONFIG_TDLS
-	// TDLS will clear RCR_CBSSID_DATA bit for connection.
-	else if (Adapter->tdlsinfo.link_established == _TRUE)
-	{
-		rcr_clear_bit = RCR_CBSSID_BCN;
-	}
-#endif // CONFIG_TDLS
-
-	value_rcr = rtw_read32(Adapter, REG_RCR);
-	if(*((u8 *)val))//under sitesurvey
-	{
-		value_rcr &= ~(rcr_clear_bit);
-		rtw_write32(Adapter, REG_RCR, value_rcr);
-		rtw_write16(Adapter, REG_RXFLTMAP2, value_rxfltmap2);
-
-		//disable update TSF
-		if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
-		{
-			if(Adapter->iface_type == IFACE_PORT1)
-			{
-				rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
-			}
-			else
-			{
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
-			}
-		}
-
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
-		{
-			StopTxBeacon(Adapter);
-		}
-	}
-	else//sitesurvey done
-	{
-		//enable to rx data frame
-		//write32(Adapter, REG_RCR, read32(padapter, REG_RCR)|RCR_ADF);
-		if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE))
-			|| check_buddy_fwstate(Adapter, (_FW_LINKED|WIFI_AP_STATE)))
-			rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-
-		//enable update TSF
-		if(Adapter->iface_type == IFACE_PORT1)
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
-		else
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-
-		value_rcr |= rcr_clear_bit;
-		rtw_write32(Adapter, REG_RCR, value_rcr);
-
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
-		{
-			ResumeTxBeacon(Adapter);
-		}
-	}
-#endif
-}
-
-static void hw_var_set_mlme_join(PADAPTER Adapter, u8 variable, u8* val)
-{
-#ifdef CONFIG_CONCURRENT_MODE
-	u8	RetryLimit = 0x30;
-	u8	type = *((u8 *)val);
-	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
-	EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
-
-	if(type == 0) // prepare to join
-	{		
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))		
-		{
-			StopTxBeacon(Adapter);
-		}
-	
-		//enable to rx data frame.Accept all data frame
-		//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
-		rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);
-		else
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
-
-		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
-		{
-			RetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;
-		}
-		else // Ad-hoc Mode
-		{
-			RetryLimit = 0x7;
-		}
-	}
-	else if(type == 1) //joinbss_event call back when join res < 0
-	{		
-		if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))		
-			rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
-
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
-		{
-			ResumeTxBeacon(Adapter);			
-			
-			//reset TSF 1/2 after ResumeTxBeacon
-			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));	
-			
-		}
-	}
-	else if(type == 2) //sta add event call back
-	{
-	 
-		//enable update TSF
-		if(Adapter->iface_type == IFACE_PORT1)
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
-		else
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-		 
-	
-		if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
-		{
-			//fixed beacon issue for 8191su...........
-			rtw_write8(Adapter,0x542 ,0x02);
-			RetryLimit = 0x7;
-		}
-
-
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
-		{
-			ResumeTxBeacon(Adapter);			
-			
-			//reset TSF 1/2 after ResumeTxBeacon
-			rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));
-		}
-		
-	}
-
-	rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-	
-#endif
-}
-
 void SetHwReg8188EU(PADAPTER Adapter, u8 variable, u8* val)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
@@ -3437,9 +2909,6 @@ _func_enter_;
 				rtw_write8(Adapter, MSR, val8);
 			}
 			break;
-		case HW_VAR_SET_OPMODE:
-			hw_var_set_opmode(Adapter, variable, val);
-			break;
 		case HW_VAR_MAC_ADDR:
 			hw_var_set_macaddr(Adapter, variable, val);			
 			break;
@@ -3452,44 +2921,6 @@ _func_enter_;
 		case HW_VAR_BCN_FUNC:
 			hw_var_set_bcn_func(Adapter, variable, val);
 			break;
-		case HW_VAR_CORRECT_TSF:
-#ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_correct_tsf(Adapter, variable, val);
-#else			
-			{
-				u64	tsf;
-				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
-				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-				//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
-				tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
-
-				if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-				{				
-					//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
-					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
-					StopTxBeacon(Adapter);
-				}
-
-				//disable related TSF function
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
-							
-				rtw_write32(Adapter, REG_TSFTR, tsf);
-				rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
-
-				//enable related TSF function
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
-				
-							
-				if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-				{
-					//pHalData->RegTxPause  &= (~STOP_BCNQ);
-					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
-					ResumeTxBeacon(Adapter);
-				}
-			}
-#endif
-			break;
 		case HW_VAR_CHECK_BSSID:
 			if(*((u8 *)val))
 			{ 
@@ -3522,140 +2953,6 @@ _func_enter_;
 				//disable update TSF
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));	
 			}
-#endif
-			break;
-		case HW_VAR_MLME_SITESURVEY:
-#ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_mlme_sitesurvey(Adapter, variable,  val);
-#else
-			{
-				u32 value_rcr, rcr_clear_bit, value_rxfltmap2;
-#ifdef CONFIG_FIND_BEST_CHANNEL
-	
-				rcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);
-	
-				// Recieve all data frames
-				value_rxfltmap2 = 0xFFFF;
-		
-#else /* CONFIG_FIND_BEST_CHANNEL */
-		
-				rcr_clear_bit = RCR_CBSSID_BCN;
-	
-				//config RCR to receive different BSSID & not to receive data frame
-				value_rxfltmap2 = 0;
-	
-#endif /* CONFIG_FIND_BEST_CHANNEL */
-	
-				if (check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE) == _TRUE) {
-					rcr_clear_bit = RCR_CBSSID_BCN;
-				}
-	#ifdef CONFIG_TDLS
-				// TDLS will clear RCR_CBSSID_DATA bit for connection.
-				else if (Adapter->tdlsinfo.link_established == _TRUE) {
-					rcr_clear_bit = RCR_CBSSID_BCN;
-				}
-	#endif // CONFIG_TDLS
-	
-				value_rcr = rtw_read32(Adapter, REG_RCR);
-				if(*((u8 *)val))//under sitesurvey
-				{
-					//config RCR to receive different BSSID & not to receive data frame
-					value_rcr &= ~(rcr_clear_bit);
-					rtw_write32(Adapter, REG_RCR, value_rcr);
-					rtw_write16(Adapter, REG_RXFLTMAP2, value_rxfltmap2);
-	
-					//disable update TSF
-					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
-				}
-				else//sitesurvey done
-				{
-					struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
-					struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	
-					if ((is_client_associated_to_ap(Adapter) == _TRUE) ||
-						((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) )
-					{
-						//enable to rx data frame
-						//rtw_write32(Adapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
-						rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-	
-						//enable update TSF
-						rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-					}
-					else if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
-					{
-						//rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_ADF);
-						rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-	
-						//enable update TSF
-						rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-					}
-	
-					value_rcr |= rcr_clear_bit;
-					if(((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE) && (Adapter->in_cta_test)) {
-						u32 v = rtw_read32(Adapter, REG_RCR);
-						v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
-						rtw_write32(Adapter, REG_RCR, v);
-					} else {
-						rtw_write32(Adapter, REG_RCR, value_rcr);	
-					}
-				}
-			}
-#endif			
-			break;
-		case HW_VAR_MLME_JOIN:
-#ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_mlme_join(Adapter, variable,  val);
-#else
-			{
-				u8	RetryLimit = 0x30;
-				u8	type = *((u8 *)val);
-				struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
-				EEPROM_EFUSE_PRIV	*pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
-				
-				if(type == 0) // prepare to join
-				{
-					//enable to rx data frame.Accept all data frame
-					//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
-					rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
-
-					if(Adapter->in_cta_test)
-					{
-						u32 v = rtw_read32(Adapter, REG_RCR);
-						v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
-						rtw_write32(Adapter, REG_RCR, v);
-					}
-					else
-					{
-						rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
-					}
-
-					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
-					{
-						RetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;
-					}
-					else // Ad-hoc Mode
-					{
-						RetryLimit = 0x7;
-					}
-				}
-				else if(type == 1) //joinbss_event call back when join res < 0
-				{
-					rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
-				}
-				else if(type == 2) //sta add event call back
-				{
-					//enable update TSF
-					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-
-					if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
-					{
-						RetryLimit = 0x7;
-					}
-				}
-
-				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-			}
 #endif
 			break;
 		case HW_VAR_ON_RCR_AM:
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/autoconf.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/autoconf.h
index 384fe534913a..0f312e47631a 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/autoconf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/autoconf.h
@@ -233,7 +233,7 @@
 #else
 	#define CONFIG_PREALLOC_RECV_SKB
 	#ifdef CONFIG_PREALLOC_RECV_SKB
-		//#define CONFIG_FIX_NR_BULKIN_BUFFER /* only use PREALLOC_RECV_SKB buffer, don't alloc skb at runtime */
+		#define CONFIG_FIX_NR_BULKIN_BUFFER /* only use PREALLOC_RECV_SKB buffer, don't alloc skb at runtime */
 	#endif
 #endif
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_conf.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_conf.h
index a8f219d2fbec..d8fe59ac1197 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_conf.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/drv_conf.h
@@ -98,6 +98,7 @@
 	#define CONFIG_RTW_ADAPTIVITY_DC_BACKOFF 2
 #endif
 
+/*#define CONFIG_WEXT_DONT_JOIN_BYSSID	*/
 //#include <rtl871x_byteorder.h>
 
 #endif // __DRV_CONF_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/ioctl_cfg80211.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/ioctl_cfg80211.h
index e8e933133084..9bcdbe4ca1b2 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/ioctl_cfg80211.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/ioctl_cfg80211.h
@@ -146,8 +146,10 @@ bool rtw_cfg80211_pwr_mgmt(_adapter *adapter);
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, sig_dbm, buf, len, gfp)
 #elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, gfp)
-#else
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3 , 18 , 0))
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, 0, gfp)
+#else
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, 0)
 #endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))  && !defined(COMPAT_KERNEL_RELEASE)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/osdep_service_linux.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/osdep_service_linux.h
index 894169dd1e58..b45c848e6915 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/osdep_service_linux.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/osdep_service_linux.h
@@ -62,6 +62,12 @@
 	#include <linux/tqueue.h>
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0))
+	#include <uapi/linux/limits.h>
+#else
+	#include <linux/limits.h>
+#endif
+
 #ifdef RTK_DMP_PLATFORM
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12))
 	#include <linux/pageremap.h>
@@ -69,10 +75,12 @@
 	#include <asm/io.h>
 #endif
 
+	/* Monitor mode */
+	#include <net/ieee80211_radiotap.h>
+
 #ifdef CONFIG_IOCTL_CFG80211	
-//	#include <linux/ieee80211.h>        
-        #include <net/ieee80211_radiotap.h>
-	#include <net/cfg80211.h>	
+/*	#include <linux/ieee80211.h> */
+	#include <net/cfg80211.h>
 #endif //CONFIG_IOCTL_CFG80211
 
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/recv_osdep.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/recv_osdep.h
index e1013379f11f..269ce2460c2c 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/recv_osdep.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/recv_osdep.h
@@ -29,6 +29,8 @@ extern s32  rtw_recv_entry(union recv_frame *precv_frame);
 extern int rtw_recv_indicatepkt(_adapter *adapter, union recv_frame *precv_frame);
 extern void rtw_recv_returnpacket(IN _nic_hdl cnxt, IN _pkt *preturnedpkt);
 
+extern int rtw_recv_monitor(_adapter *padapter, union recv_frame *precv_frame);
+
 extern void rtw_hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame);
 extern void rtw_handle_tkip_mic_err(_adapter *padapter,u8 bgroup);
 		
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtl8188e_hal.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtl8188e_hal.h
index bf9a8bd55d24..3680a8008022 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtl8188e_hal.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtl8188e_hal.h
@@ -295,6 +295,9 @@ void _InitTransferPageSize(PADAPTER padapter);
 
 void SetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);
 void GetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);
+void ResumeTxBeacon(PADAPTER padapter);
+void StopTxBeacon(PADAPTER padapter);
+
 u8 GetHalDefVar8188E(PADAPTER Adapter, HAL_DEF_VARIABLE eVariable, PVOID pValue);
 
 #endif //__RTL8188E_HAL_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_debug.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_debug.h
index 09490bc00cff..bf36357c021d 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_debug.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_debug.h
@@ -328,6 +328,9 @@ void mac_reg_dump(void *sel, _adapter *adapter);
 void bb_reg_dump(void *sel, _adapter *adapter);
 void rf_reg_dump(void *sel, _adapter *adapter);
 
+struct dvobj_priv;
+void dump_adapters_status(void *sel, struct dvobj_priv *dvobj);
+
 #ifdef CONFIG_PROC_DEBUG
 ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 int proc_get_read_reg(struct seq_file *m, void *v);
@@ -347,8 +350,8 @@ int proc_get_qos_option(struct seq_file *m, void *v);
 int proc_get_ht_option(struct seq_file *m, void *v);
 int proc_get_rf_info(struct seq_file *m, void *v);
 int proc_get_survey_info(struct seq_file *m, void *v);
+ssize_t proc_set_survey_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 int proc_get_ap_info(struct seq_file *m, void *v);
-int proc_get_adapter_state(struct seq_file *m, void *v);
 int proc_get_trx_info(struct seq_file *m, void *v);
 int proc_get_rate_ctl(struct seq_file *m, void *v);
 ssize_t proc_set_rate_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
@@ -417,6 +420,9 @@ ssize_t proc_set_odm_dbg_level(struct file *file, const char __user *buffer, siz
 int proc_get_odm_adaptivity(struct seq_file *m, void *v);
 ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 
+int proc_get_monitor(struct seq_file *m, void *v);
+ssize_t proc_set_monitor(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
 #endif /* CONFIG_PROC_DEBUG */
 
 #endif	//__RTW_DEBUG_H__
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme.h
index 79eeb00fdf2d..f3a90c898935 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme.h
@@ -41,48 +41,57 @@
 #define	SCANQUEUE_LIFETIME 20000 // 20sec, unit:msec
 #endif
 
-#define WIFI_NULL_STATE		0x00000000
-#define WIFI_ASOC_STATE		0x00000001		// Under Linked state...
-#define WIFI_REASOC_STATE	0x00000002
-#define WIFI_SLEEP_STATE	0x00000004
-#define WIFI_STATION_STATE	0x00000008
-#define	WIFI_AP_STATE			0x00000010
-#define	WIFI_ADHOC_STATE		0x00000020
-#define WIFI_ADHOC_MASTER_STATE	0x00000040
-#define WIFI_UNDER_LINKING	0x00000080
-
-#define WIFI_UNDER_WPS			0x00000100
-//#define	WIFI_UNDER_CMD			0x00000200
-//#define	WIFI_UNDER_P2P			0x00000400
-#define	WIFI_STA_ALIVE_CHK_STATE	0x00000400
-#define	WIFI_SITE_MONITOR			0x00000800		//to indicate the station is under site surveying
-#ifdef WDS
-#define	WIFI_WDS				0x00001000
-#define	WIFI_WDS_RX_BEACON	0x00002000		// already rx WDS AP beacon
-#endif
-#ifdef AUTO_CONFIG
-#define	WIFI_AUTOCONF			0x00004000
-#define	WIFI_AUTOCONF_IND	0x00008000
-#endif
-
-/*
-// ========== P2P Section Start ===============
-#define	WIFI_P2P_LISTEN_STATE		0x00010000
-#define	WIFI_P2P_GROUP_FORMATION_STATE		0x00020000
-// ========== P2P Section End ===============
-*/
+#define WIFI_NULL_STATE					0x00000000
+#define WIFI_ASOC_STATE					0x00000001 /* Linked */
+#define WIFI_REASOC_STATE				0x00000002
+#define WIFI_SLEEP_STATE				0x00000004
+#define WIFI_STATION_STATE				0x00000008
+#define WIFI_AP_STATE					0x00000010
+#define WIFI_ADHOC_STATE				0x00000020
+#define WIFI_ADHOC_MASTER_STATE			0x00000040
+#define WIFI_UNDER_LINKING				0x00000080
+#define WIFI_UNDER_WPS					0x00000100
+#define WIFI_UNDER_CAC					0x00000200
+#define WIFI_STA_ALIVE_CHK_STATE		0x00000400
+#define WIFI_SITE_MONITOR				0x00000800 /* under site surveying */
+#define WIFI_WDS						0x00001000
+#define WIFI_WDS_RX_BEACON				0x00002000 /* already rx WDS AP beacon */
+#define WIFI_AUTOCONF					0x00004000
+#define WIFI_AUTOCONF_IND				0x00008000
+#define WIFI_MP_STATE					0x00010000
+#define WIFI_MP_CTX_BACKGROUND			0x00020000 /* in continuous tx background */
+#define WIFI_MP_CTX_ST					0x00040000 /* in continuous tx with single-tone */
+#define WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000 /* pending in continuous tx background due to out of skb */
+#define WIFI_MP_CTX_CCK_HW				0x00100000 /* in continuous tx */
+#define WIFI_MP_CTX_CCK_CS				0x00200000 /* in continuous tx with carrier suppression */
+#define WIFI_MP_LPBK_STATE				0x00400000
+#define WIFI_OP_CH_SWITCHING			0x00800000
+/*#define WIFI_UNDEFINED_STATE			0x01000000*/
+/*#define WIFI_UNDEFINED_STATE			0x02000000*/
+/*#define WIFI_UNDEFINED_STATE			0x04000000*/
+/*#define WIFI_UNDEFINED_STATE			0x08000000*/
+/*#define WIFI_UNDEFINED_STATE			0x10000000*/
+/*#define WIFI_UNDEFINED_STATE			0x20000000*/
+/*#define WIFI_UNDEFINED_STATE			0x40000000*/
+#define WIFI_MONITOR_STATE				0x80000000
+
+#define MLME_STATE_FMT "%s%s%s%s%s%s%s%s%s%s%s%s"
+#define MLME_STATE_ARG(state) \
+	((state) & WIFI_STATION_STATE)?" STA":"", \
+	((state) & WIFI_AP_STATE)?" AP":"", \
+	((state) & WIFI_ADHOC_STATE)?" ADHOC":"", \
+	((state) & WIFI_ADHOC_MASTER_STATE)?" ADHOC_M":"", \
+	((state) & WIFI_MONITOR_STATE)?" MONITOR":"", \
+	((state) & WIFI_MP_STATE)?" MP":"", \
+	((state) & WIFI_SITE_MONITOR)?" SCAN":"", \
+	((state) & WIFI_UNDER_LINKING)?" LINKING":"", \
+	((state) & WIFI_ASOC_STATE)?" ASOC":"", \
+	((state) & WIFI_OP_CH_SWITCHING)?" OP_CH_SW":"", \
+	((state) & WIFI_UNDER_WPS)?" WPS":"", \
+	((state) & WIFI_SLEEP_STATE)?" SLEEP":""
+
+#define ADPT_MLME_S_ARG(adapter) MLME_STATE_ARG(get_fwstate(&((adapter)->mlmepriv)))
 
-//#ifdef UNDER_MPTEST
-#define	WIFI_MP_STATE							0x00010000
-#define	WIFI_MP_CTX_BACKGROUND				0x00020000	// in continous tx background
-#define	WIFI_MP_CTX_ST						0x00040000	// in continous tx with single-tone
-#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000	// pending in continous tx background due to out of skb
-#define	WIFI_MP_CTX_CCK_HW					0x00100000	// in continous tx
-#define	WIFI_MP_CTX_CCK_CS					0x00200000	// in continous tx with carrier suppression
-#define   WIFI_MP_LPBK_STATE					0x00400000
-//#endif
-
-//#define _FW_UNDER_CMD		WIFI_UNDER_CMD
 #define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
 #define _FW_LINKED			WIFI_ASOC_STATE
 #define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme_ext.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme_ext.h
index 3bb9c5287e1d..db573468a6b5 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme_ext.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_mlme_ext.h
@@ -89,6 +89,7 @@
 #define _HW_STATE_ADHOC_		0x01
 #define _HW_STATE_STATION_ 	0x02
 #define _HW_STATE_AP_			0x03
+#define _HW_STATE_MONITOR_ 0x04
 
 
 #define		_1M_RATE_	0
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_recv.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_recv.h
index 0124ed142206..2f7c964bc845 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_recv.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_recv.h
@@ -206,8 +206,8 @@ struct rx_raw_rssi
 	u8 mimo_singal_strength[4];// in 0~100 index
 	u8 mimo_singal_quality[4];
 	
-	s8 ofdm_pwr[4];
-	u8 ofdm_snr[4];
+	s8 ofdm_pwr[4];
+	u8 ofdm_snr[4];
 
 };
 #endif
@@ -254,8 +254,12 @@ struct rx_pkt_attrib	{
 	u8 	key_index;
 
 	u8	data_rate;
+	u8	bw;
+	u8	stbc;
+	u8	ldpc;
 	u8 	sgi;
 	u8 	pkt_rpt_type;
+	u32 tsfl;
 	u32	MacIDValidEntry[2];	// 64 bits present 64 entry.
 
 /*
@@ -265,7 +269,7 @@ struct rx_pkt_attrib	{
 	u32	RxPWDBAll;	
 	s32	RecvSignalPower;
 */
-	struct phy_info phy_info;	
+	struct phy_info phy_info;
 };
 
 
@@ -822,9 +826,14 @@ __inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
 {
 	s32	SignalPower; // in dBm.
 
+#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+	// Translate to dBm (x=y-100)
+	SignalPower = SignalStrengthIndex - 100;
+#else
 	// Translate to dBm (x=0.5y-95).
 	SignalPower = (s32)((SignalStrengthIndex + 1) >> 1); 
 	SignalPower -= 95; 
+#endif
 
 	return SignalPower;
 }
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_version.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_version.h
index a0e3beb5b83f..6590e95c476b 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/rtw_version.h
@@ -1 +1 @@
-#define DRIVERVERSION	"v4.3.0.8_13522.20150213_beta"
+#define DRIVERVERSION	"v4.3.0.8_13968.20150417"
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/wlan_bssdef.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/wlan_bssdef.h
index dac17a05bb44..3a885311f965 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/wlan_bssdef.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/include/wlan_bssdef.h
@@ -85,7 +85,8 @@ typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
     Ndis802_11Infrastructure,
     Ndis802_11AutoUnknown,
     Ndis802_11InfrastructureMax,     // Not a real value, defined as upper bound
-    Ndis802_11APMode
+	Ndis802_11APMode,
+	Ndis802_11Monitor,
 } NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
 
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_cfg80211.c
index 37029ddfa093..631007160e42 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_cfg80211.c
@@ -670,11 +670,22 @@ void rtw_cfg80211_ibss_indicate_connect(_adapter *padapter)
 	struct cfg80211_bss *bss = NULL;
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
 	struct wiphy *wiphy = pwdev->wiphy;
-	int freq = (int)cur_network->network.Configuration.DSConfig;
-	struct ieee80211_channel *chan;
+	int freq = 2412;
+	struct ieee80211_channel *notify_channel;
 #endif
 
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))	
+	if (cur_network->network.Configuration.DSConfig <= RTW_CH_MAX_2G_CHANNEL)
+		freq = rtw_ieee80211_channel_to_frequency(cur_network->network.Configuration.DSConfig, IEEE80211_BAND_2GHZ);
+	else
+		freq = rtw_ieee80211_channel_to_frequency(cur_network->network.Configuration.DSConfig, IEEE80211_BAND_5GHZ);
+	
+	if (0)
+		DBG_871X("chan: %d, freq: %d\n", cur_network->network.Configuration.DSConfig, freq);
+#endif
+
 	if (pwdev->iftype != NL80211_IFTYPE_ADHOC) 
 	{
 		return;
@@ -725,8 +736,8 @@ void rtw_cfg80211_ibss_indicate_connect(_adapter *padapter)
 	}
 	//notify cfg80211 that device joined an IBSS
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
-	chan = ieee80211_get_channel(wiphy, freq);
-	cfg80211_ibss_joined(padapter->pnetdev, cur_network->network.MacAddress, chan, GFP_ATOMIC);
+	notify_channel = ieee80211_get_channel(wiphy, freq);
+	cfg80211_ibss_joined(padapter->pnetdev, cur_network->network.MacAddress, notify_channel, GFP_ATOMIC);
 #else
 	cfg80211_ibss_joined(padapter->pnetdev, cur_network->network.MacAddress, GFP_ATOMIC);
 #endif
@@ -1589,6 +1600,12 @@ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 		ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
 #endif
 	}
+        else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE
+                || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)
+        {
+                //DBG_8192C("@@@@@@@@@@ fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
+                ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);
+        }
 	else
 	{
 		DBG_8192C("error! fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
@@ -1857,7 +1874,10 @@ static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 		pmlmeext->action_public_rxseq = 0xffff;
 		pmlmeext->action_public_dialog_token = 0xff;
 	}	
-		
+
+	/* initial default type */
+	ndev->type = ARPHRD_ETHER;
+
 	switch (type) {
 	case NL80211_IFTYPE_ADHOC:
 		networkType = Ndis802_11IBSS;
@@ -1896,7 +1916,14 @@ static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 			}
 		}
 		#endif //CONFIG_P2P
-		break;		
+		break;
+	case NL80211_IFTYPE_MONITOR:
+		networkType = Ndis802_11Monitor;
+#if 0
+		ndev->type = ARPHRD_IEEE80211; /* IEEE 802.11 : 801 */
+#endif
+		ndev->type = ARPHRD_IEEE80211_RADIOTAP; /* IEEE 802.11 + radiotap header : 803 */
+		break;
 	default:
 		ret = -EOPNOTSUPP;
 		goto exit;
@@ -1911,7 +1938,7 @@ static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 		goto exit;
 	}
 
-	rtw_setopmode_cmd(padapter, networkType,_TRUE);	
+	rtw_setopmode_cmd(padapter, networkType, _TRUE);
 	
 exit:
 
@@ -2864,7 +2891,21 @@ static int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,
 	NDIS_802_11_SSID ndis_ssid;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX *)(&(pmlmeinfo->network));
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
+	struct cfg80211_chan_def *pch_def;
+#endif
+	struct ieee80211_channel *pch;
 	int ret=0;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
+	pch_def = (struct cfg80211_chan_def *)(&params->chandef); 
+	pch = (struct ieee80211_channel *) pch_def->chan;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31))
+	pch = (struct ieee80211_channel *)(params->channel); 
+#endif
 	
 	if(_FAIL == rtw_pwr_wakeup(padapter)) {
 		ret= -EPERM;
@@ -2913,6 +2954,9 @@ static int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,
 	
 	ret = rtw_cfg80211_set_auth_type(psecuritypriv, NL80211_AUTHTYPE_OPEN_SYSTEM);
 	rtw_set_802_11_authentication_mode(padapter, psecuritypriv->ndisauthtype);
+
+	DBG_871X("%s: center_freq = %d\n", __func__, pch->center_freq);
+	pmlmeext->cur_channel = rtw_freq2ch(pch->center_freq);
 	
 	if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == _FALSE) 
 	{
@@ -4291,10 +4335,37 @@ static int	cfg80211_rtw_set_channel(struct wiphy *wiphy
 	#endif
 	, struct ieee80211_channel *chan, enum nl80211_channel_type channel_type)
 {
+	int chan_target = (u8) ieee80211_frequency_to_channel(chan->center_freq);
+	int chan_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	int chan_width = CHANNEL_WIDTH_20;
+	_adapter *padapter = wiphy_to_adapter(wiphy);
+
 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	#endif
-	
+
+	switch (channel_type) {
+	case NL80211_CHAN_NO_HT:
+	case NL80211_CHAN_HT20:
+		chan_width = CHANNEL_WIDTH_20;
+		chan_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	case NL80211_CHAN_HT40MINUS:
+		chan_width = CHANNEL_WIDTH_40;
+		chan_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+		break;
+	case NL80211_CHAN_HT40PLUS:
+		chan_width = CHANNEL_WIDTH_40;
+		chan_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+		break;
+	default:
+		chan_width = CHANNEL_WIDTH_20;
+		chan_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		break;
+	}
+
+	set_channel_bwmode(padapter, chan_target, chan_offset, chan_width);
+
 	return 0;
 }
 
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_linux.c
index bb005df69465..e1184f5d6285 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/ioctl_linux.c
@@ -1536,10 +1536,51 @@ static int rtw_wx_set_freq(struct net_device *dev,
 			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {	
+
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+	int exp = 1, freq = 0, div = 0;
+
 	_func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_wx_set_freq\n"));
 
+	if (wrqu->freq.m <= 1000) {
+		if (wrqu->freq.flags == IW_FREQ_AUTO) {
+			padapter->mlmeextpriv.cur_channel = 1;
+			DBG_871X("%s: channel is auto, set to channel 1\n", __func__);
+		} else {
+			padapter->mlmeextpriv.cur_channel = wrqu->freq.m;
+			DBG_871X("%s: set to channel %d\n", __func__, padapter->mlmeextpriv.cur_channel);
+		}
+	} else {
+		while (wrqu->freq.e) {
+			exp *= 10;
+			wrqu->freq.e--;
+		}
+
+		freq = wrqu->freq.m;
+		while (!(freq%10)) {
+			freq /= 10;
+			exp *= 10;
+		}
+
+		/* freq unit is MHz here */
+		div = 1000000/exp;
+
+		if (div)
+			freq /= div;
+		else {
+			div = exp/1000000;
+			freq *= div;
+		}
+
+		/* If freq is invalid, rtw_freq2ch() will return channel 1 */
+		padapter->mlmeextpriv.cur_channel = rtw_freq2ch(freq);
+		DBG_871X("%s: set to channel %d\n", __func__, padapter->mlmeextpriv.cur_channel);
+	}
+
 	_func_exit_;
 	
 	return 0;
@@ -1588,9 +1629,21 @@ static int rtw_wx_set_mode(struct net_device *dev, struct iw_request_info *a,
 		ret = -EPERM;
 		goto exit;
 	}
-	
+
+	/* initial default type */
+	dev->type = ARPHRD_ETHER;
+
 	switch(wrqu->mode)
 	{
+		case IW_MODE_MONITOR:
+			networkType = Ndis802_11Monitor;
+#if 0
+			dev->type = ARPHRD_IEEE80211; /* IEEE 802.11 : 801 */
+#endif
+			dev->type = ARPHRD_IEEE80211_RADIOTAP; /* IEEE 802.11 + radiotap header : 803 */
+			DBG_871X("set_mode = IW_MODE_MONITOR\n");
+			break;
+
 		case IW_MODE_AUTO:
 			networkType = Ndis802_11AutoUnknown;
 			DBG_871X("set_mode = IW_MODE_AUTO\n");	
@@ -2573,7 +2626,10 @@ static int rtw_wx_set_essid(struct net_device *dev,
 	#ifdef DBG_IOCTL
 	DBG_871X("DBG_IOCTL %s:%d\n",__FUNCTION__, __LINE__);
 	#endif
-	
+	#ifdef CONFIG_WEXT_DONT_JOIN_BYSSID
+	DBG_871X("%s: CONFIG_WEXT_DONT_JOIN_BYSSID be defined!! only allow bssid joining\n", __func__);
+	return -EPERM;
+	#endif
 /*
 #ifdef CONFIG_CONCURRENT_MODE
 	if(padapter->iface_type > PRIMARY_IFACE)
@@ -14184,8 +14240,16 @@ static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
 		#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength); 
 		#else
+		#ifdef CONFIG_SKIP_SIGNAL_SCALE_MAPPING
+		{
+			/* Do signal scale mapping when using percentage as the unit of signal strength, since the scale mapping is skipped in odm */
+			HAL_DATA_TYPE *pHal = GET_HAL_DATA(padapter);
+			tmp_level = (u8)odm_SignalScaleMapping(&pHal->odmpriv, padapter->recvpriv.signal_strength);
+		}
+		#else
 		tmp_level = padapter->recvpriv.signal_strength;
 		#endif
+		#endif
 		
 		tmp_qual = padapter->recvpriv.signal_qual;
 		tmp_noise =padapter->recvpriv.noise;		
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/recv_linux.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/recv_linux.c
index 2f965d2b3433..d4ce0fc9f950 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/recv_linux.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/recv_linux.c
@@ -552,6 +552,52 @@ static void rtw_os_ksocket_send(_adapter *padapter, union recv_frame *precv_fram
 }
 #endif //CONFIG_AUTO_AP_MODE
 
+int rtw_recv_monitor(_adapter *padapter, union recv_frame *precv_frame)
+{
+	int ret = _FAIL;
+	struct recv_priv *precvpriv;
+	_queue	*pfree_recv_queue;
+	_pkt *skb;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct rx_pkt_attrib *pattrib;
+
+	if (NULL == precv_frame)
+		goto _recv_drop;
+
+	pattrib = &precv_frame->u.hdr.attrib;
+	precvpriv = &(padapter->recvpriv);
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+
+	skb = precv_frame->u.hdr.pkt;
+	if (skb == NULL) {
+		DBG_871X("%s :skb==NULL something wrong!!!!\n", __func__);
+		goto _recv_drop;
+	}
+
+	skb->data = precv_frame->u.hdr.rx_data;
+	skb_set_tail_pointer(skb, precv_frame->u.hdr.len);
+	skb->len = precv_frame->u.hdr.len;
+	skb->ip_summed = CHECKSUM_NONE;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(0x0019); /* ETH_P_80211_RAW */
+
+	rtw_netif_rx(padapter->pnetdev, skb);
+
+	/* pointers to NULL before rtw_free_recvframe() */
+	precv_frame->u.hdr.pkt = NULL;
+
+	ret = _SUCCESS;
+
+_recv_drop:
+
+	/* enqueue back to free_recv_queue */
+	if (precv_frame)
+		rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+	return ret;
+
+}
+
 int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
 {
 	struct recv_priv *precvpriv;
@@ -599,6 +645,9 @@ _func_enter_;
 
 	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n skb->head=%p skb->data=%p skb->tail=%p skb->end=%p skb->len=%d\n", skb->head, skb->data, skb_tail_pointer(skb), skb_end_pointer(skb), skb->len));
 
+	if (pattrib->eth_type == 0x888e)
+		DBG_871X_LEVEL(_drv_always_, "recv eapol packet\n");
+
 #ifdef CONFIG_AUTO_AP_MODE	
 #if 1 //for testing
 #if 1
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_android.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_android.c
index f069ea4ab02e..a807602e25fb 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_android.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_android.c
@@ -139,16 +139,18 @@ char pno_in_example[] = {
 #endif /* PNO_SUPPORT */
 
 typedef struct android_wifi_priv_cmd {
+	char *buf;
+	int used_len;
+	int total_len;
+} android_wifi_priv_cmd;
 
 #ifdef CONFIG_COMPAT
+typedef struct compat_android_wifi_priv_cmd {
 	compat_uptr_t buf;
-#else
-	char *buf;
-#endif
-
 	int used_len;
 	int total_len;
-} android_wifi_priv_cmd;
+} compat_android_wifi_priv_cmd;
+#endif /* CONFIG_COMPAT */
 
 /**
  * Local (static) functions and variables
@@ -498,12 +500,27 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 #ifdef CONFIG_WFD
 	struct wifi_display_info		*pwfd_info;
 #endif
+
 	rtw_lock_suspend();
 
 	if (!ifr->ifr_data) {
 		ret = -EINVAL;
 		goto exit;
 	}
+#ifdef CONFIG_COMPAT
+	if (is_compat_task()) {
+		/* User space is 32-bit, use compat ioctl */
+		compat_android_wifi_priv_cmd compat_priv_cmd;
+
+		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
+			ret = -EFAULT;
+			goto exit;
+		}
+		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
+		priv_cmd.used_len = compat_priv_cmd.used_len;
+		priv_cmd.total_len = compat_priv_cmd.total_len;
+	} else
+#endif /* CONFIG_COMPAT */
 	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
 		ret = -EFAULT;
 		goto exit;
@@ -526,11 +543,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		ret = -EFAULT;
 		goto exit;
 	 }
-#ifdef CONFIG_COMPAT
-	if (copy_from_user(command, compat_ptr(priv_cmd.buf), (unsigned long) priv_cmd.total_len)) {
-#else
 	if (copy_from_user(command, (void *)priv_cmd.buf, priv_cmd.total_len)) {
-#endif
 		ret = -EFAULT;
 		goto exit;
 	}
@@ -718,11 +731,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		pwfd_info = &padapter->wfd_info;
 		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
 		{
-#ifdef CONFIG_COMPAT
-			pwfd_info->rtsp_ctrlport = ( u16 ) get_int_from_command( compat_ptr(priv_cmd.buf) );
-#else
 			pwfd_info->rtsp_ctrlport = ( u16 ) get_int_from_command( priv_cmd.buf );
-#endif
 		}
 		break;
 	}
@@ -738,12 +747,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		pwfd_info = &padapter->wfd_info;
 		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
 		{
-#ifdef CONFIG_COMPAT
-			pwfd_info->wfd_device_type = ( u8 ) get_int_from_command( compat_ptr(priv_cmd.buf) );
-#else
 			pwfd_info->wfd_device_type = ( u8 ) get_int_from_command( priv_cmd.buf );
-#endif
-		
 			pwfd_info->wfd_device_type &= WFD_DEVINFO_DUAL;
 		}
 		break;
@@ -753,11 +757,8 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		{
 #ifdef CONFIG_LPS
 			u8 dtim;
-#ifdef CONFIG_COMPAT
-                        u8 *ptr = compat_ptr(priv_cmd.buf);
-#else
 			u8 *ptr = priv_cmd.buf;
-#endif			
+			
 			ptr += 9;//string command length of  "SET_DTIM";
 
 			dtim = rtw_atoi(ptr);
@@ -820,11 +821,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 			bytes_written++;
 		}
 		priv_cmd.used_len = bytes_written;
-#ifdef CONFIG_COMPAT
-		if (copy_to_user(compat_ptr(priv_cmd.buf), command, bytes_written)) {
-#else
 		if (copy_to_user((void *)priv_cmd.buf, command, bytes_written)) {
-#endif
 			DBG_871X("%s: failed to copy data to user buffer\n", __FUNCTION__);
 			ret = -EFAULT;
 		}
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_proc.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_proc.c
index 37435041d1ae..9ecc5421f6de 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_proc.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/rtw_proc.c
@@ -261,6 +261,17 @@ static int proc_get_rf_reg_dump(struct seq_file *m, void *v)
 
 	return 0;
 }
+
+static int proc_get_dump_adapters_status(struct seq_file *m, void *v)
+{
+	struct net_device *dev = m->private;
+	_adapter *adapter = (_adapter *)rtw_netdev_priv(dev);
+
+	dump_adapters_status(m, adapter_to_dvobj(adapter));
+
+	return 0;
+}
+
 static int proc_get_linked_info_dump(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -424,15 +435,15 @@ static int proc_get_cam_cache(struct seq_file *m, void *v)
 const struct rtw_proc_hdl adapter_proc_hdls [] = {
 	{"write_reg", proc_get_dummy, proc_set_write_reg},
 	{"read_reg", proc_get_read_reg, proc_set_read_reg},
+	{"adapters_status", proc_get_dump_adapters_status, NULL},
 	{"fwstate", proc_get_fwstate, NULL},
 	{"sec_info", proc_get_sec_info, NULL},
 	{"mlmext_state", proc_get_mlmext_state, NULL},
 	{"qos_option", proc_get_qos_option, NULL},
 	{"ht_option", proc_get_ht_option, NULL},
 	{"rf_info", proc_get_rf_info, NULL},
-	{"survey_info", proc_get_survey_info, NULL},
+	{"survey_info", proc_get_survey_info, proc_set_survey_info},
 	{"ap_info", proc_get_ap_info, NULL},
-	{"adapter_state", proc_get_adapter_state, NULL},
 	{"trx_info", proc_get_trx_info, NULL},
 	{"rate_ctl", proc_get_rate_ctl, proc_set_rate_ctl},
 	{"mac_qinfo", proc_get_mac_qinfo, NULL},
@@ -496,6 +507,7 @@ const struct rtw_proc_hdl adapter_proc_hdls [] = {
 	{"sreset", proc_get_sreset, proc_set_sreset},
 #endif /* DBG_CONFIG_ERROR_DETECT */
 	{"linked_info_dump",proc_get_linked_info_dump,proc_set_linked_info_dump},
+	{"monitor", proc_get_monitor, proc_set_monitor},
 };
 
 const int adapter_proc_hdls_num = sizeof(adapter_proc_hdls) / sizeof(struct rtw_proc_hdl);
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/usb_intf.c b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/usb_intf.c
index 90e3b61dcbc1..b4c92bfd516d 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/usb_intf.c
@@ -1942,7 +1942,7 @@ extern int get_wifi_chip_type(void);
 
 int rockchip_wifi_init_module_rtkwifi(void)
 {
-#ifdef CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP
+#if 0//def CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP
     int type = get_wifi_chip_type();
     if (type < WIFI_AP6XXX_SERIES || type == WIFI_ESP8089) return 0;
 #endif
@@ -1951,14 +1951,14 @@ int rockchip_wifi_init_module_rtkwifi(void)
     printk("==== Launching Wi-Fi driver! (Powered by Rockchip) ====\n");
     printk("=======================================================\n");
     printk("Realtek 8188EU USB WiFi driver (Powered by Rockchip,Ver %s) init.\n", RTL8192_DRV_VERSION);
-    rockchip_wifi_power(1);
+    rockchip_wifi_power(0);
 
     return rtw_drv_entry();
 }
 
 void rockchip_wifi_exit_module_rtkwifi(void)
 {
-#ifdef CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP
+#if 0//def CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP
     int type = get_wifi_chip_type();
     if (type < WIFI_AP6XXX_SERIES || type == WIFI_ESP8089) return;
 #endif
@@ -1968,7 +1968,7 @@ void rockchip_wifi_exit_module_rtkwifi(void)
     printk("=======================================================\n");
     printk("Realtek 8188EU USB WiFi driver (Powered by Rockchip,Ver %s) init.\n", RTL8192_DRV_VERSION);
     rtw_drv_halt();
-    rockchip_wifi_power(0);
+    rockchip_wifi_power(1);
 }
 
 #ifdef CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/wifi_version.h b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/wifi_version.h
index 0de8f110bd9c..ae090384fdff 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/wifi_version.h
+++ b/drivers/net/wireless/rockchip_wlan/rtl8188eu/os_dep/linux/wifi_version.h
@@ -7,7 +7,7 @@
 /*
  * Broadcom BCM4319 driver version.
  */
-#define RTL8192_DRV_VERSION "3.80.WFD.beta"
+#define RTL8192_DRV_VERSION "3.90.WFD"
 
 #endif /* WIFI_VERSION_H */
 
-- 
2.35.3

