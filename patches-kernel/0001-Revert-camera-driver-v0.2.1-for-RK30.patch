From 446f291f45884d1d281ef2ab39e215d5239e32e4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E9=BB=84=E6=B6=9B?= <huangtao@rock-chips.com>
Date: Fri, 9 Mar 2012 20:06:01 +0800
Subject: [PATCH] Revert "camera driver v0.2.1 for RK30"

This reverts commit 64df168943b21c448c1333954b23a8e80646f009.
---
 arch/arm/mach-rk29/include/mach/rk29_camera.h |  203 +
 arch/arm/mach-rk30/board-rk30-sdk.c           |  330 -
 arch/arm/mach-rk30/devices.c                  |   20 +-
 arch/arm/mach-rk30/include/mach/rk_camera.h   |  222 -
 drivers/media/video/Kconfig                   |   50 +-
 drivers/media/video/Makefile                  |    4 +-
 drivers/media/video/gc0307.c                  |  122 +-
 drivers/media/video/gc0308.c                  |  111 +-
 drivers/media/video/gc0309.c                  |  110 +-
 drivers/media/video/gc0309_for_td8801.c       |   26 +-
 drivers/media/video/gc2015.c                  |  110 +-
 drivers/media/video/gt2005.c                  |  110 +-
 drivers/media/video/hi253.c                   |  110 +-
 drivers/media/video/hi704.c                   |  110 +-
 drivers/media/video/mt9d112.c                 |  108 +-
 drivers/media/video/mt9d113.c                 |  108 +-
 drivers/media/video/mt9m112.c                 |   16 +-
 drivers/media/video/mt9p111.c                 |  115 +-
 drivers/media/video/mt9t111.c                 |  111 +-
 drivers/media/video/nt99250.c                 |  110 +-
 drivers/media/video/ov2640.c                  | 1323 +++-
 drivers/media/video/ov2640_rk.c               | 5888 ++++++++---------
 drivers/media/video/ov2655.c                  |  110 +-
 drivers/media/video/ov2659.c                  |  131 +-
 drivers/media/video/ov3640.c                  |  108 +-
 drivers/media/video/ov5640.c                  |   26 +-
 drivers/media/video/ov5640_for_td8801.c       |   26 +-
 drivers/media/video/ov5642.c                  |  110 +-
 drivers/media/video/ov7675.c                  |  110 +-
 drivers/media/video/ov7690.c                  |  111 +-
 drivers/media/video/rk29_camera.c             | 1740 +++++
 ...mera_oneframe.c => rk29_camera_oneframe.c} | 1454 ++--
 drivers/media/video/rk_camera.c               | 1775 -----
 drivers/media/video/s5k6aa.c                  |  112 +-
 drivers/media/video/sid130B.c                 |  411 +-
 drivers/media/video/siv120b.c                 |  109 +-
 36 files changed, 7583 insertions(+), 8167 deletions(-)
 create mode 100755 arch/arm/mach-rk29/include/mach/rk29_camera.h
 delete mode 100755 arch/arm/mach-rk30/include/mach/rk_camera.h
 mode change 100644 => 100755 drivers/media/video/gc0307.c
 mode change 100644 => 100755 drivers/media/video/gc0308.c
 mode change 100644 => 100755 drivers/media/video/gc0309.c
 mode change 100755 => 100644 drivers/media/video/gc0309_for_td8801.c
 mode change 100644 => 100755 drivers/media/video/gc2015.c
 mode change 100644 => 100755 drivers/media/video/gt2005.c
 mode change 100644 => 100755 drivers/media/video/hi253.c
 mode change 100644 => 100755 drivers/media/video/hi704.c
 mode change 100644 => 100755 drivers/media/video/mt9d112.c
 mode change 100644 => 100755 drivers/media/video/mt9d113.c
 mode change 100644 => 100755 drivers/media/video/mt9t111.c
 mode change 100644 => 100755 drivers/media/video/nt99250.c
 mode change 100644 => 100755 drivers/media/video/ov2655.c
 mode change 100644 => 100755 drivers/media/video/ov2659.c
 mode change 100755 => 100644 drivers/media/video/ov5640_for_td8801.c
 mode change 100644 => 100755 drivers/media/video/ov5642.c
 mode change 100644 => 100755 drivers/media/video/ov7675.c
 create mode 100755 drivers/media/video/rk29_camera.c
 rename drivers/media/video/{rk_camera_oneframe.c => rk29_camera_oneframe.c} (52%)
 mode change 100644 => 100755
 delete mode 100644 drivers/media/video/rk_camera.c
 mode change 100644 => 100755 drivers/media/video/sid130B.c
 mode change 100644 => 100755 drivers/media/video/siv120b.c

diff --git a/arch/arm/mach-rk29/include/mach/rk29_camera.h b/arch/arm/mach-rk29/include/mach/rk29_camera.h
new file mode 100755
index 000000000000..2d78c35cda2b
--- /dev/null
+++ b/arch/arm/mach-rk29/include/mach/rk29_camera.h
@@ -0,0 +1,203 @@
+/*
+    camera.h - PXA camera driver header file
+
+    Copyright (C) 2003, Intel Corporation
+    Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef __ASM_ARCH_CAMERA_H_
+#define __ASM_ARCH_CAMERA_H_
+
+#include <linux/videodev2.h>
+
+#define RK29_CAM_DRV_NAME "rk29xx-camera"
+#define RK29_CAM_PLATFORM_DEV_ID 33
+
+#define INVALID_GPIO -1
+
+#define RK29_CAM_IO_SUCCESS 0
+#define RK29_CAM_EIO_INVALID -1
+#define RK29_CAM_EIO_REQUESTFAIL -2
+
+/*---------------- Camera Sensor Must Define Macro Begin  ------------------------*/
+#define RK29_CAM_SENSOR_OV7675 ov7675
+#define RK29_CAM_SENSOR_OV9650 ov9650
+#define RK29_CAM_SENSOR_OV2640 ov2640
+#define RK29_CAM_SENSOR_OV2655 ov2655
+#define RK29_CAM_SENSOR_OV2659 ov2659
+#define RK29_CAM_SENSOR_OV7690 ov7690
+#define RK29_CAM_SENSOR_OV3640 ov3640
+#define RK29_CAM_SENSOR_OV5640 ov5640
+#define RK29_CAM_SENSOR_OV5642 ov5642
+#define RK29_CAM_SENSOR_S5K6AA s5k6aa
+#define RK29_CAM_SENSOR_MT9D112 mt9d112
+#define RK29_CAM_SENSOR_MT9D113 mt9d113
+#define RK29_CAM_SENSOR_MT9P111 mt9p111
+#define RK29_CAM_SENSOR_MT9T111 mt9t111
+#define RK29_CAM_SENSOR_GT2005  gt2005
+#define RK29_CAM_SENSOR_GC0307  gc0307
+#define RK29_CAM_SENSOR_GC0308  gc0308
+#define RK29_CAM_SENSOR_GC0309  gc0309
+#define RK29_CAM_SENSOR_GC2015  gc2015
+#define RK29_CAM_SENSOR_SIV120B  siv120b
+#define RK29_CAM_SENSOR_SID130B  sid130B
+#define RK29_CAM_SENSOR_HI253  hi253
+#define RK29_CAM_SENSOR_HI704  hi704
+#define RK29_CAM_SENSOR_NT99250 nt99250
+
+#define RK29_CAM_SENSOR_NAME_OV7675 "ov7675"
+#define RK29_CAM_SENSOR_NAME_OV9650 "ov9650"
+#define RK29_CAM_SENSOR_NAME_OV2640 "ov2640"
+#define RK29_CAM_SENSOR_NAME_OV2655 "ov2655"
+#define RK29_CAM_SENSOR_NAME_OV2659 "ov2659"
+#define RK29_CAM_SENSOR_NAME_OV7690 "ov7690"
+#define RK29_CAM_SENSOR_NAME_OV3640 "ov3640"
+#define RK29_CAM_SENSOR_NAME_OV5640 "ov5640"
+#define RK29_CAM_SENSOR_NAME_OV5642 "ov5642"
+#define RK29_CAM_SENSOR_NAME_S5K6AA "s5k6aa"
+#define RK29_CAM_SENSOR_NAME_MT9D112 "mt9d112"
+#define RK29_CAM_SENSOR_NAME_MT9D113 "mt9d113"
+#define RK29_CAM_SENSOR_NAME_MT9P111 "mt9p111"
+#define RK29_CAM_SENSOR_NAME_MT9T111 "mt9t111"
+#define RK29_CAM_SENSOR_NAME_GT2005  "gt2005"
+#define RK29_CAM_SENSOR_NAME_GC0307  "gc0307"
+#define RK29_CAM_SENSOR_NAME_GC0308  "gc0308"
+#define RK29_CAM_SENSOR_NAME_GC0309  "gc0309"
+#define RK29_CAM_SENSOR_NAME_GC2015  "gc2015"
+#define RK29_CAM_SENSOR_NAME_SIV120B "siv120b"
+#define RK29_CAM_SENSOR_NAME_SID130B "sid130B"
+#define RK29_CAM_SENSOR_NAME_HI253  "hi253"
+#define RK29_CAM_SENSOR_NAME_HI704  "hi704"
+#define RK29_CAM_SENSOR_NAME_NT99250 "nt99250"
+
+#define ov7675_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define ov9650_FULL_RESOLUTION     0x130000           // 1.3 megapixel   
+#define ov2640_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define ov2655_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define ov2659_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define ov7690_FULL_RESOLUTION     0x300000           // 2 megapixel
+#define ov3640_FULL_RESOLUTION     0x300000           // 3 megapixel
+#define ov5640_FULL_RESOLUTION     0x500000           // 5 megapixel
+#define ov5642_FULL_RESOLUTION     0x500000           // 5 megapixel
+#define s5k6aa_FULL_RESOLUTION     0x130000           // 1.3 megapixel
+#define mt9d112_FULL_RESOLUTION    0x200000           // 2 megapixel
+#define mt9d113_FULL_RESOLUTION    0x200000           // 2 megapixel
+#define mt9t111_FULL_RESOLUTION    0x300000           // 3 megapixel
+#define mt9p111_FULL_RESOLUTION    0x500000           // 5 megapixel
+#define gt2005_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define gc0308_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define gc0309_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define gc2015_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define siv120b_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define sid130B_FULL_RESOLUTION     0x200000           // 2 megapixel    
+#define hi253_FULL_RESOLUTION       0x200000           // 2 megapixel
+#define hi704_FULL_RESOLUTION       0x30000            // 0.3 megapixel
+#define nt99250_FULL_RESOLUTION     0x200000           // 2 megapixel
+/*---------------- Camera Sensor Must Define Macro End  ------------------------*/
+
+
+#define RK29_CAM_POWERACTIVE_BITPOS	0x00
+#define RK29_CAM_POWERACTIVE_MASK	(1<<RK29_CAM_POWERACTIVE_BITPOS)
+#define RK29_CAM_POWERACTIVE_H	(0x01<<RK29_CAM_POWERACTIVE_BITPOS)
+#define RK29_CAM_POWERACTIVE_L	(0x00<<RK29_CAM_POWERACTIVE_BITPOS)
+
+#define RK29_CAM_RESETACTIVE_BITPOS	0x01
+#define RK29_CAM_RESETACTIVE_MASK	(1<<RK29_CAM_RESETACTIVE_BITPOS)
+#define RK29_CAM_RESETACTIVE_H	(0x01<<RK29_CAM_RESETACTIVE_BITPOS)
+#define RK29_CAM_RESETACTIVE_L  (0x00<<RK29_CAM_RESETACTIVE_BITPOS)
+
+#define RK29_CAM_POWERDNACTIVE_BITPOS	0x02
+#define RK29_CAM_POWERDNACTIVE_MASK	(1<<RK29_CAM_POWERDNACTIVE_BITPOS)
+#define RK29_CAM_POWERDNACTIVE_H	(0x01<<RK29_CAM_POWERDNACTIVE_BITPOS)
+#define RK29_CAM_POWERDNACTIVE_L	(0x00<<RK29_CAM_POWERDNACTIVE_BITPOS)
+
+#define RK29_CAM_FLASHACTIVE_BITPOS	0x03
+#define RK29_CAM_FLASHACTIVE_MASK	(1<<RK29_CAM_FLASHACTIVE_BITPOS)
+#define RK29_CAM_FLASHACTIVE_H	(0x01<<RK29_CAM_FLASHACTIVE_BITPOS)
+#define RK29_CAM_FLASHACTIVE_L  (0x00<<RK29_CAM_FLASHACTIVE_BITPOS)
+
+/* v4l2_subdev_core_ops.ioctl  ioctl_cmd macro */
+#define RK29_CAM_SUBDEV_ACTIVATE            0x00
+#define RK29_CAM_SUBDEV_DEACTIVATE          0x01
+#define RK29_CAM_SUBDEV_IOREQUEST			0x02
+#define RK29_CAM_SUBDEV_CB_REGISTER         0x03
+
+enum rk29camera_ioctrl_cmd
+{
+	Cam_Power,
+	Cam_Reset,
+	Cam_PowerDown,
+	Cam_Flash
+};
+
+enum rk29sensor_power_cmd
+{
+	Sensor_Reset,
+	Sensor_PowerDown,
+	Sensor_Flash
+};
+
+enum rk29camera_flash_cmd
+{
+    Flash_Off,
+    Flash_On,
+    Flash_Torch
+};
+
+struct rk29camera_gpio_res {
+    unsigned int gpio_reset;
+    unsigned int gpio_power;
+	unsigned int gpio_powerdown;
+	unsigned int gpio_flash;
+    unsigned int gpio_flag;
+	unsigned int gpio_init;
+    
+    const char *dev_name;
+};
+
+struct rk29camera_mem_res {
+	const char *name;
+	unsigned int start;
+	unsigned int size;
+};
+struct rk29camera_info {
+    const char *dev_name;
+    unsigned int orientation;
+    struct v4l2_frmivalenum fival[10];
+};
+struct rk29camera_platform_data {
+    int (*io_init)(void);
+    int (*io_deinit)(int sensor);
+	int (*sensor_ioctrl)(struct device *dev,enum rk29camera_ioctrl_cmd cmd,int on);
+    struct rk29camera_gpio_res gpio_res[2];
+	struct rk29camera_mem_res meminfo;
+    struct rk29camera_info info[2];
+};
+
+struct rk29camera_platform_ioctl_cb {
+    int (*sensor_power_cb)(struct rk29camera_gpio_res *res, int on);
+    int (*sensor_reset_cb)(struct rk29camera_gpio_res *res, int on);
+    int (*sensor_powerdown_cb)(struct rk29camera_gpio_res *res, int on);
+    int (*sensor_flash_cb)(struct rk29camera_gpio_res *res, int on);    
+};
+
+typedef struct rk29_camera_sensor_cb {
+    int (*sensor_cb)(void *arg); 
+}rk29_camera_sensor_cb_s;
+
+#endif /* __ASM_ARCH_CAMERA_H_ */
+
diff --git a/arch/arm/mach-rk30/board-rk30-sdk.c b/arch/arm/mach-rk30/board-rk30-sdk.c
index 3ac13577848a..53feb9812e5b 100755
--- a/arch/arm/mach-rk30/board-rk30-sdk.c
+++ b/arch/arm/mach-rk30/board-rk30-sdk.c
@@ -54,317 +54,6 @@
 
 #define RK30_FB0_MEM_SIZE 8*SZ_1M
 
-#ifdef CONFIG_VIDEO_RK
-/*---------------- Camera Sensor Macro Define Begin  ------------------------*/
-/*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
-#define CONFIG_SENSOR_0 RK_CAM_SENSOR_OV2659//RK_CAM_SENSOR_OV5642						/* back camera sensor */
-#define CONFIG_SENSOR_IIC_ADDR_0		0x60//0x78
-#define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  1
-#define CONFIG_SENSOR_CIF_INDEX_0                    0
-#define CONFIG_SENSOR_ORIENTATION_0 	  90
-#define CONFIG_SENSOR_POWER_PIN_0		  INVALID_GPIO
-#define CONFIG_SENSOR_RESET_PIN_0		  INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_0 	  INVALID_GPIO
-#define CONFIG_SENSOR_FALSH_PIN_0		  INVALID_GPIO
-#define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK_CAM_POWERACTIVE_L
-#define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK_CAM_RESETACTIVE_L
-#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0 RK_CAM_POWERDNACTIVE_H
-#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0 RK_CAM_FLASHACTIVE_L
-
-#define CONFIG_SENSOR_QCIF_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_QVGA_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_CIF_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_VGA_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_480P_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_SVGA_FPS_FIXED_0		15000
-#define CONFIG_SENSOR_720P_FPS_FIXED_0		30000
-
-#define CONFIG_SENSOR_1 RK_CAM_SENSOR_OV2659						/* front camera sensor */
-#define CONFIG_SENSOR_IIC_ADDR_1		0x60
-#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  1
-#define CONFIG_SENSOR_CIF_INDEX_1				  1
-#define CONFIG_SENSOR_ORIENTATION_1 	  270
-#define CONFIG_SENSOR_POWER_PIN_1		  INVALID_GPIO
-#define CONFIG_SENSOR_RESET_PIN_1		  INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_1 	  INVALID_GPIO
-#define CONFIG_SENSOR_FALSH_PIN_1		  INVALID_GPIO
-#define CONFIG_SENSOR_POWERACTIVE_LEVEL_1 RK_CAM_POWERACTIVE_L
-#define CONFIG_SENSOR_RESETACTIVE_LEVEL_1 RK_CAM_RESETACTIVE_L
-#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1 RK_CAM_POWERDNACTIVE_H
-#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1 RK_CAM_FLASHACTIVE_L
-
-#define CONFIG_SENSOR_QCIF_FPS_FIXED_1		15000
-#define CONFIG_SENSOR_QVGA_FPS_FIXED_1		15000
-#define CONFIG_SENSOR_CIF_FPS_FIXED_1		15000
-#define CONFIG_SENSOR_VGA_FPS_FIXED_1		15000
-#define CONFIG_SENSOR_480P_FPS_FIXED_1		15000
-#define CONFIG_SENSOR_SVGA_FPS_FIXED_1		15000
-#define CONFIG_SENSOR_720P_FPS_FIXED_1		30000
-
-#define CONFIG_USE_CIF_0	1
-#define CONFIG_USE_CIF_1      0
-#endif	//#ifdef CONFIG_VIDEO_RK29
-/*---------------- Camera Sensor Configuration Macro End------------------------*/
-#include "../../../drivers/media/video/rk_camera.c"
-/*---------------- Camera Sensor Macro Define End  ---------*/
-
-#define PMEM_CAM_SIZE		PMEM_CAM_NECESSARY
-#ifdef CONFIG_VIDEO_RK_WORK_IPP
-#define MEM_CAMIPP_SIZE 	PMEM_CAMIPP_NECESSARY
-#else
-#define MEM_CAMIPP_SIZE 	0
-#endif
-/*****************************************************************************************
- * camera  devices
- * author: ddl@rock-chips.com
- *****************************************************************************************/
-#ifdef CONFIG_VIDEO_RK
-#define CONFIG_SENSOR_POWER_IOCTL_USR	   0
-#define CONFIG_SENSOR_RESET_IOCTL_USR	   0
-#define CONFIG_SENSOR_POWERDOWN_IOCTL_USR	   0
-#define CONFIG_SENSOR_FLASH_IOCTL_USR	   0
-
-#if CONFIG_SENSOR_POWER_IOCTL_USR
-static int sensor_power_usr_cb (struct rkcamera_gpio_res *res,int on)
-{
-	#error "CONFIG_SENSOR_POWER_IOCTL_USR is 1, sensor_power_usr_cb function must be writed!!";
-}
-#endif
-
-#if CONFIG_SENSOR_RESET_IOCTL_USR
-static int sensor_reset_usr_cb (struct rkcamera_gpio_res *res,int on)
-{
-	#error "CONFIG_SENSOR_RESET_IOCTL_USR is 1, sensor_reset_usr_cb function must be writed!!";
-}
-#endif
-
-#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
-static int sensor_powerdown_usr_cb (struct rkcamera_gpio_res *res,int on)
-{
-	#error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
-}
-#endif
-
-#if CONFIG_SENSOR_FLASH_IOCTL_USR
-static int sensor_flash_usr_cb (struct rkcamera_gpio_res *res,int on)
-{
-	#error "CONFIG_SENSOR_FLASH_IOCTL_USR is 1, sensor_flash_usr_cb function must be writed!!";
-}
-#endif
-
-static struct rkcamera_platform_ioctl_cb	sensor_ioctl_cb = {
-	#if CONFIG_SENSOR_POWER_IOCTL_USR
-	.sensor_power_cb = sensor_power_usr_cb,
-	#else
-	.sensor_power_cb = NULL,
-	#endif
-
-	#if CONFIG_SENSOR_RESET_IOCTL_USR
-	.sensor_reset_cb = sensor_reset_usr_cb,
-	#else
-	.sensor_reset_cb = NULL,
-	#endif
-
-	#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
-	.sensor_powerdown_cb = sensor_powerdown_usr_cb,
-	#else
-	.sensor_powerdown_cb = NULL,
-	#endif
-
-	#if CONFIG_SENSOR_FLASH_IOCTL_USR
-	.sensor_flash_cb = sensor_flash_usr_cb,
-	#else
-	.sensor_flash_cb = NULL,
-	#endif
-};
-static struct reginfo_t rk_init_data_sensor_reg_0[] =
-{
-		{0x3000, 0x0f,0,0},
-		{0x3001, 0xff,0,0},
-		{0x3002, 0xff,0,0},
-		//{0x0100, 0x01},	//software sleep : Sensor vsync singal may not output if haven't sleep the sensor when transfer the array
-		{0x3633, 0x3d,0,0},
-		{0x3620, 0x02,0,0},
-		{0x3631, 0x11,0,0},
-		{0x3612, 0x04,0,0},
-		{0x3630, 0x20,0,0},
-		{0x4702, 0x02,0,0},
-		{0x370c, 0x34,0,0},
-		{0x3004, 0x10,0,0},
-		{0x3005, 0x18,0,0},
-		{0x3800, 0x00,0,0},
-		{0x3801, 0x00,0,0},
-		{0x3802, 0x00,0,0},
-		{0x3803, 0x00,0,0},
-		{0x3804, 0x06,0,0},
-		{0x3805, 0x5f,0,0},
-		{0x3806, 0x04,0,0},
-		{0x3807, 0xb7,0,0},
-		{0x3808, 0x03,0,0},
-		{0x3809, 0x20,0,0},
-		{0x380a, 0x02,0,0},
-		{0x380b, 0x58,0,0},
-		{0x380c, 0x05,0,0},
-		{0x380d, 0x14,0,0},
-		{0x380e, 0x02,0,0},
-		{0x380f, 0x68,0,0},
-		{0x3811, 0x08,0,0},
-		{0x3813, 0x02,0,0},
-		{0x3814, 0x31,0,0},
-		{0x3815, 0x31,0,0},
-		{0x3a02, 0x02,0,0},
-		{0x3a03, 0x68,0,0},
-		{0x3a08, 0x00,0,0},
-		{0x3a09, 0x5c,0,0},
-		{0x3a0a, 0x00,0,0},
-		{0x3a0b, 0x4d,0,0},
-		{0x3a0d, 0x08,0,0},
-		{0x3a0e, 0x06,0,0},
-		{0x3a14, 0x02,0,0},
-		{0x3a15, 0x28,0,0},
-			{0x4708, 0x01,0,0},
-		{0x3623, 0x00,0,0},
-		{0x3634, 0x76,0,0},
-		{0x3701, 0x44,0,0},
-		{0x3702, 0x18,0,0},
-		{0x3703, 0x24,0,0},
-		{0x3704, 0x24,0,0},
-		{0x3705, 0x0c,0,0},
-		{0x3820, 0x81,0,0},
-		{0x3821, 0x01,0,0},
-		{0x370a, 0x52,0,0},
-		{0x4608, 0x00,0,0},
-		{0x4609, 0x80,0,0},
-		{0x4300, 0x32,0,0},
-		{0x5086, 0x02,0,0},
-		{0x5000, 0xfb,0,0},
-		{0x5001, 0x1f,0,0},
-		{0x5002, 0x00,0,0},
-		{0x5025, 0x0e,0,0},
-		{0x5026, 0x18,0,0},
-		{0x5027, 0x34,0,0},
-		{0x5028, 0x4c,0,0},
-		{0x5029, 0x62,0,0},
-		{0x502a, 0x74,0,0},
-		{0x502b, 0x85,0,0},
-		{0x502c, 0x92,0,0},
-		{0x502d, 0x9e,0,0},
-		{0x502e, 0xb2,0,0},
-		{0x502f, 0xc0,0,0},
-		{0x5030, 0xcc,0,0},
-		{0x5031, 0xe0,0,0},
-		{0x5032, 0xee,0,0},
-		{0x5033, 0xf6,0,0},
-		{0x5034, 0x11,0,0},
-		{0x5070, 0x1c,0,0},
-		{0x5071, 0x5b,0,0},
-		{0x5072, 0x05,0,0},
-		{0x5073, 0x20,0,0},
-		{0x5074, 0x94,0,0},
-		{0x5075, 0xb4,0,0},
-		{0x5076, 0xb4,0,0},
-		{0x5077, 0xaf,0,0},
-		{0x5078, 0x05,0,0},
-		{0x5079, 0x98,0,0},
-		{0x507a, 0x21,0,0},
-		{0x5035, 0x6a,0,0},
-		{0x5036, 0x11,0,0},
-		{0x5037, 0x92,0,0},
-		{0x5038, 0x21,0,0},
-	
-		{0x5039, 0xe1,0,0},
-		{0x503a, 0x01,0,0},
-		{0x503c, 0x05,0,0},
-		{0x503d, 0x08,0,0},
-		{0x503e, 0x08,0,0},
-		{0x503f, 0x64,0,0},
-		{0x5040, 0x58,0,0},
-		{0x5041, 0x2a,0,0},
-		{0x5042, 0xc5,0,0},
-		{0x5043, 0x2e,0,0},
-		{0x5044, 0x3a,0,0},
-		{0x5045, 0x3c,0,0},
-		{0x5046, 0x44,0,0},
-		{0x5047, 0xf8,0,0},
-		{0x5048, 0x08,0,0},
-		{0x5049, 0x70,0,0},
-		{0x504a, 0xf0,0,0},
-		{0x504b, 0xf0,0,0},
-		{0x500c, 0x03,0,0},
-		{0x500d, 0x20,0,0},
-		{0x500e, 0x02,0,0},
-		{0x500f, 0x5c,0,0},
-		{0x5010, 0x48,0,0},
-		{0x5011, 0x00,0,0},
-		{0x5012, 0x66,0,0},
-		{0x5013, 0x03,0,0},
-		{0x5014, 0x30,0,0},
-		{0x5015, 0x02,0,0},
-		{0x5016, 0x7c,0,0},
-		{0x5017, 0x40,0,0},
-		{0x5018, 0x00,0,0},
-		{0x5019, 0x66,0,0},
-		{0x501a, 0x03,0,0},
-		{0x501b, 0x10,0,0},
-		{0x501c, 0x02,0,0},
-		{0x501d, 0x7c,0,0},
-		{0x501e, 0x3a,0,0},
-		{0x501f, 0x00,0,0},
-		{0x5020, 0x66,0,0},
-		{0x506e, 0x44,0,0},
-		{0x5064, 0x08,0,0},
-		{0x5065, 0x10,0,0},
-		{0x5066, 0x12,0,0},
-		{0x5067, 0x02,0,0},
-		{0x506c, 0x08,0,0},
-		{0x506d, 0x10,0,0},
-		{0x506f, 0xa6,0,0},
-		{0x5068, 0x08,0,0},
-	
-	
-		{0x5069, 0x10,0,0},
-		{0x506a, 0x04,0,0},
-		{0x506b, 0x12,0,0},
-		{0x507e, 0x40,0,0},
-		{0x507f, 0x20,0,0},
-		{0x507b, 0x02,0,0},
-		{0x507a, 0x01,0,0},
-		{0x5084, 0x0c,0,0},
-		{0x5085, 0x3e,0,0},
-		{0x5005, 0x80,0,0},
-		{0x3a0f, 0x30,0,0},
-		{0x3a10, 0x28,0,0},
-		{0x3a1b, 0x32,0,0},
-		{0x3a1e, 0x26,0,0},
-		{0x3a11, 0x60,0,0},
-		{0x3a1f, 0x14,0,0},
-		{0x5060, 0x69,0,0},
-		{0x5061, 0x7d,0,0},
-		{0x5062, 0x7d,0,0},
-		{0x5063, 0x69,0,0},
-		{0x3004, 0x20,0,0},
-			{0x0100, 0x01,0,0},
-		{0x0000, 0x00,0,0}
-	};
-static struct reginfo_t rk_init_data_sensor_winseqreg_0[] ={
-	{0x0000, 0x00,0,0}
-	};
-static rk_sensor_user_init_data_s rk_init_data_sensor_0 = 
-{	
-	.rk_sensor_init_width = INVALID_VALUE,
-	.rk_sensor_init_height = INVALID_VALUE,
-	.rk_sensor_init_bus_param = INVALID_VALUE,
-	.rk_sensor_init_pixelcode = INVALID_VALUE,
-	.rk_sensor_init_data = rk_init_data_sensor_reg_0,
-	.rk_sensor_init_winseq = NULL,//rk_init_data_sensor_winseqreg_0,
-	.rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_0) / sizeof(struct reginfo_t),
-	
-};
-static rk_sensor_user_init_data_s* rk_init_data_sensor_0_p = &rk_init_data_sensor_0;
-static rk_sensor_user_init_data_s* rk_init_data_sensor_1_p = NULL;
-#include "../../../drivers/media/video/rk_camera.c"
-
-#endif
 
 #if defined(CONFIG_TOUCHSCREEN_GT8XX)
 #define TOUCH_RESET_PIN  RK30_PIN4_PD0
@@ -1033,25 +722,6 @@ static void __init rk30_reserve(void)
 	resource_fb[2].start = board_mem_reserve_add("fb2",RK30_FB0_MEM_SIZE);
 	resource_fb[2].end = resource_fb[2].start + RK30_FB0_MEM_SIZE - 1;	
 #endif
-
-#if (MEM_CAMIPP_SIZE != 0)
-	#if CONFIG_USE_CIF_0
-	rk_camera_platform_data_host_0.meminfo.name = "camera_ipp_mem_0";
-	rk_camera_platform_data_host_0.meminfo.start = board_mem_reserve_add("camera_ipp_mem_0",MEM_CAMIPP_SIZE);
-	rk_camera_platform_data_host_0.meminfo.size= MEM_CAMIPP_SIZE;
-	#endif
-	#if CONFIG_USE_CIF_1
-	rk_camera_platform_data_host_1.meminfo.name = "camera_ipp_mem_1";
-	rk_camera_platform_data_host_1.meminfo.start =board_mem_reserve_add("camera_ipp_mem_1",MEM_CAMIPP_SIZE);
-	rk_camera_platform_data_host_1.meminfo.size= MEM_CAMIPP_SIZE;
-	#endif
-#endif
-
-#if (PMEM_CAM_SIZE != 0)
-	android_pmem_cam_pdata.start = board_mem_reserve_add("camera_pmem",PMEM_CAM_SIZE);
-	android_pmem_cam_pdata.size = PMEM_CAM_SIZE;
-#endif
-
 	board_mem_reserved();
 }
 
diff --git a/arch/arm/mach-rk30/devices.c b/arch/arm/mach-rk30/devices.c
index 1f1c9c95a0ae..dc608b7aee2b 100755
--- a/arch/arm/mach-rk30/devices.c
+++ b/arch/arm/mach-rk30/devices.c
@@ -502,18 +502,6 @@ static struct platform_device device_i2c4 = {
 
 static void __init rk30_init_i2c(void)
 {
-//config i2c gpio
-int err = 0;
-err = gpio_request(RK30_PIN3_PC1, "i2c");
-if (err) {
-	gpio_free(RK30_PIN3_PC1);
-	printk("-------request RK30_PIN3_PC1 fail--------\n");
-	//return ;
-}
-//
-gpio_direction_output(RK30_PIN3_PC1, GPIO_HIGH);
-gpio_set_value(RK30_PIN3_PC1, GPIO_HIGH);
-
 #ifdef CONFIG_I2C0_RK30
 	platform_device_register(&device_i2c0);
 #endif
@@ -985,9 +973,7 @@ static void __init rk30_init_sdmmc(void)
 	platform_device_register(&device_sdmmc1);
 #endif
 }
-#if CONFIG_VIDEO_RK
-extern void  rk_register_camera_devices();
-#endif
+
 static int __init rk30_init_devices(void)
 {
 	rk30_init_dma();
@@ -1017,9 +1003,7 @@ static int __init rk30_init_devices(void)
 	rk_serial_debug_init(RK30_UART1_PHYS, IRQ_UART1, IRQ_UART_SIGNAL, -1);
 #endif
 	rk30_init_i2s();
-#if CONFIG_VIDEO_RK
-	rk_register_camera_devices();
-#endif	
+
         return 0;
 }
 arch_initcall(rk30_init_devices);
diff --git a/arch/arm/mach-rk30/include/mach/rk_camera.h b/arch/arm/mach-rk30/include/mach/rk_camera.h
deleted file mode 100755
index 2469e55fe697..000000000000
--- a/arch/arm/mach-rk30/include/mach/rk_camera.h
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
-    camera.h - PXA camera driver header file
-
-    Copyright (C) 2003, Intel Corporation
-    Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#ifndef __ASM_ARCH_CAMERA_H_
-#define __ASM_ARCH_CAMERA_H_
-
-#include <linux/videodev2.h>
-#include <media/soc_camera.h>
-#define RK_CAM_DRV_NAME "rkxx-camera"
-#define RK_CAM_PLATFORM_DEV_ID_0 33
-#define RK_CAM_PLATFORM_DEV_ID_1 (RK_CAM_PLATFORM_DEV_ID_0+1)
-#define INVALID_GPIO -1
-#define INVALID_VALUE -1
-#define RK_CAM_IO_SUCCESS 0
-#define RK_CAM_EIO_INVALID -1
-#define RK_CAM_EIO_REQUESTFAIL -2
-
-#define RK_CAM_NUM_PER_HOST 2
-/*---------------- Camera Sensor Must Define Macro Begin  ------------------------*/
-#define RK_CAM_SENSOR_OV7675 ov7675
-#define RK_CAM_SENSOR_OV9650 ov9650
-#define RK_CAM_SENSOR_OV2640 ov2640
-#define RK_CAM_SENSOR_OV2655 ov2655
-#define RK_CAM_SENSOR_OV2659 ov2659
-#define RK_CAM_SENSOR_OV7690 ov7690
-#define RK_CAM_SENSOR_OV3640 ov3640
-#define RK_CAM_SENSOR_OV5640 ov5640
-#define RK_CAM_SENSOR_OV5642 ov5642
-#define RK_CAM_SENSOR_S5K6AA s5k6aa
-#define RK_CAM_SENSOR_MT9D112 mt9d112
-#define RK_CAM_SENSOR_MT9D113 mt9d113
-#define RK_CAM_SENSOR_MT9P111 mt9p111
-#define RK_CAM_SENSOR_MT9T111 mt9t111
-#define RK_CAM_SENSOR_GT2005  gt2005
-#define RK_CAM_SENSOR_GC0307  gc0307
-#define RK_CAM_SENSOR_GC0308  gc0308
-#define RK_CAM_SENSOR_GC0309  gc0309
-#define RK_CAM_SENSOR_GC2015  gc2015
-#define RK_CAM_SENSOR_SIV120B  siv120b
-#define RK_CAM_SENSOR_SID130B  sid130B
-#define RK_CAM_SENSOR_HI253  hi253
-#define RK_CAM_SENSOR_HI704  hi704
-#define RK_CAM_SENSOR_NT99250 nt99250
-
-#define RK_CAM_SENSOR_NAME_OV7675 "ov7675"
-#define RK_CAM_SENSOR_NAME_OV9650 "ov9650"
-#define RK_CAM_SENSOR_NAME_OV2640 "ov2640"
-#define RK_CAM_SENSOR_NAME_OV2655 "ov2655"
-#define RK_CAM_SENSOR_NAME_OV2659 "ov2659"
-#define RK_CAM_SENSOR_NAME_OV7690 "ov7690"
-#define RK_CAM_SENSOR_NAME_OV3640 "ov3640"
-#define RK_CAM_SENSOR_NAME_OV5640 "ov5640"
-#define RK_CAM_SENSOR_NAME_OV5642 "ov5642"
-#define RK_CAM_SENSOR_NAME_S5K6AA "s5k6aa"
-#define RK_CAM_SENSOR_NAME_MT9D112 "mt9d112"
-#define RK_CAM_SENSOR_NAME_MT9D113 "mt9d113"
-#define RK_CAM_SENSOR_NAME_MT9P111 "mt9p111"
-#define RK_CAM_SENSOR_NAME_MT9T111 "mt9t111"
-#define RK_CAM_SENSOR_NAME_GT2005  "gt2005"
-#define RK_CAM_SENSOR_NAME_GC0307  "gc0307"
-#define RK_CAM_SENSOR_NAME_GC0308  "gc0308"
-#define RK_CAM_SENSOR_NAME_GC0309  "gc0309"
-#define RK_CAM_SENSOR_NAME_GC2015  "gc2015"
-#define RK_CAM_SENSOR_NAME_SIV120B "siv120b"
-#define RK_CAM_SENSOR_NAME_SID130B "sid130B"
-#define RK_CAM_SENSOR_NAME_HI253  "hi253"
-#define RK_CAM_SENSOR_NAME_HI704  "hi704"
-#define RK_CAM_SENSOR_NAME_NT99250 "nt99250"
-
-#define ov7675_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define ov9650_FULL_RESOLUTION     0x130000           // 1.3 megapixel   
-#define ov2640_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define ov2655_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define ov2659_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define ov7690_FULL_RESOLUTION     0x300000           // 2 megapixel
-#define ov3640_FULL_RESOLUTION     0x300000           // 3 megapixel
-#define ov5640_FULL_RESOLUTION     0x500000           // 5 megapixel
-#define ov5642_FULL_RESOLUTION     0x500000           // 5 megapixel
-#define s5k6aa_FULL_RESOLUTION     0x130000           // 1.3 megapixel
-#define mt9d112_FULL_RESOLUTION    0x200000           // 2 megapixel
-#define mt9d113_FULL_RESOLUTION    0x200000           // 2 megapixel
-#define mt9t111_FULL_RESOLUTION    0x300000           // 3 megapixel
-#define mt9p111_FULL_RESOLUTION    0x500000           // 5 megapixel
-#define gt2005_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define gc0308_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define gc0309_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define gc2015_FULL_RESOLUTION     0x200000           // 2 megapixel
-#define siv120b_FULL_RESOLUTION     0x30000            // 0.3 megapixel
-#define sid130B_FULL_RESOLUTION     0x200000           // 2 megapixel    
-#define hi253_FULL_RESOLUTION       0x200000           // 2 megapixel
-#define hi704_FULL_RESOLUTION       0x30000            // 0.3 megapixel
-#define nt99250_FULL_RESOLUTION     0x200000           // 2 megapixel
-/*---------------- Camera Sensor Must Define Macro End  ------------------------*/
-
-
-#define RK_CAM_POWERACTIVE_BITPOS	0x00
-#define RK_CAM_POWERACTIVE_MASK	(1<<RK_CAM_POWERACTIVE_BITPOS)
-#define RK_CAM_POWERACTIVE_H	(0x01<<RK_CAM_POWERACTIVE_BITPOS)
-#define RK_CAM_POWERACTIVE_L	(0x00<<RK_CAM_POWERACTIVE_BITPOS)
-
-#define RK_CAM_RESETACTIVE_BITPOS	0x01
-#define RK_CAM_RESETACTIVE_MASK	(1<<RK_CAM_RESETACTIVE_BITPOS)
-#define RK_CAM_RESETACTIVE_H	(0x01<<RK_CAM_RESETACTIVE_BITPOS)
-#define RK_CAM_RESETACTIVE_L  (0x00<<RK_CAM_RESETACTIVE_BITPOS)
-
-#define RK_CAM_POWERDNACTIVE_BITPOS	0x02
-#define RK_CAM_POWERDNACTIVE_MASK	(1<<RK_CAM_POWERDNACTIVE_BITPOS)
-#define RK_CAM_POWERDNACTIVE_H	(0x01<<RK_CAM_POWERDNACTIVE_BITPOS)
-#define RK_CAM_POWERDNACTIVE_L	(0x00<<RK_CAM_POWERDNACTIVE_BITPOS)
-
-#define RK_CAM_FLASHACTIVE_BITPOS	0x03
-#define RK_CAM_FLASHACTIVE_MASK	(1<<RK_CAM_FLASHACTIVE_BITPOS)
-#define RK_CAM_FLASHACTIVE_H	(0x01<<RK_CAM_FLASHACTIVE_BITPOS)
-#define RK_CAM_FLASHACTIVE_L  (0x00<<RK_CAM_FLASHACTIVE_BITPOS)
-
-/* v4l2_subdev_core_ops.ioctl  ioctl_cmd macro */
-#define RK_CAM_SUBDEV_ACTIVATE            0x00
-#define RK_CAM_SUBDEV_DEACTIVATE          0x01
-#define RK_CAM_SUBDEV_IOREQUEST			0x02
-#define RK_CAM_SUBDEV_CB_REGISTER         0x03
-
-enum rkcamera_ioctrl_cmd
-{
-	Cam_Power,
-	Cam_Reset,
-	Cam_PowerDown,
-	Cam_Flash
-};
-
-enum rksensor_power_cmd
-{
-	Sensor_Reset,
-	Sensor_PowerDown,
-	Sensor_Flash
-};
-
-enum rkcamera_flash_cmd
-{
-    Flash_Off,
-    Flash_On,
-    Flash_Torch
-};
-
-struct rkcamera_gpio_res {
-	unsigned int gpio_reset;
-	unsigned int gpio_power;
-	unsigned int gpio_powerdown;
-	unsigned int gpio_flash;
-	unsigned int gpio_flag;
-	unsigned int gpio_init;
-	const char *dev_name;
-};
-
-struct rkcamera_mem_res {
-	const char *name;
-	unsigned int start;
-	unsigned int size;
-};
-struct rkcamera_info {
-    const char *dev_name;
-    unsigned int orientation;
-    struct v4l2_frmivalenum fival[10];
-};
-
-struct reginfo_t
-{
-	u16 reg;
-	u16 val;
-	u16 reg_len;
-	u16 rev;
-};
-typedef struct rk_sensor_user_init_data{
-	int rk_sensor_init_width;
-	int rk_sensor_init_height;
-	unsigned long rk_sensor_init_bus_param;
-	enum v4l2_mbus_pixelcode rk_sensor_init_pixelcode;
-	struct reginfo_t * rk_sensor_init_data;
-	int rk_sensor_winseq_size;
-	struct reginfo_t * rk_sensor_init_winseq;
-}rk_sensor_user_init_data_s;
-struct rkcamera_platform_data {
-	int (*io_init)(int);
-	int (*io_deinit)(int);
-	int (*sensor_ioctrl)(struct device *dev,enum rkcamera_ioctrl_cmd cmd,int on);
-	rk_sensor_user_init_data_s* sensor_init_data[RK_CAM_NUM_PER_HOST];
-	struct rkcamera_gpio_res gpio_res[RK_CAM_NUM_PER_HOST];
-	struct rkcamera_mem_res meminfo;
-	struct rkcamera_info info[RK_CAM_NUM_PER_HOST];
-};
-
-struct rkcamera_platform_ioctl_cb {
-    int (*sensor_power_cb)(struct rkcamera_gpio_res *res, int on);
-    int (*sensor_reset_cb)(struct rkcamera_gpio_res *res, int on);
-    int (*sensor_powerdown_cb)(struct rkcamera_gpio_res *res, int on);
-    int (*sensor_flash_cb)(struct rkcamera_gpio_res *res, int on);    
-};
-
-typedef struct rk_camera_sensor_cb {
-    int (*sensor_cb)(void *arg); 
-}rk_camera_sensor_cb_s;
-
-
-#endif /* __ASM_ARCH_CAMERA_H_ */
-
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 3a8a64d39f69..609f968c4039 100755
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -1136,52 +1136,52 @@ config VIDEO_OMAP2
 	---help---
 	  This is a v4l2 driver for the TI OMAP2 camera capture interface
 
-config VIDEO_RK
-	tristate "RKXX Camera Sensor Interface driver"
-	depends on VIDEO_DEV && ARCH_RK30 && SOC_CAMERA && HAS_DMA
+config VIDEO_RK29
+	tristate "RK29XX Camera Sensor Interface driver"
+	depends on VIDEO_DEV && ARCH_RK29 && SOC_CAMERA && HAS_DMA
 	select VIDEOBUF_DMA_CONTIG
 	---help---
-	  This is a v4l2 driver for the RKXX Camera Sensor Interface
+	  This is a v4l2 driver for the RK29XX Camera Sensor Interface
 
 choice
-	prompt "RKXX Camera Sensor Interface Work Mode"
-	depends on VIDEO_RK
-	default VIDEO_RK_WORK_ONEFRAME
+	prompt "RK29XX Camera Sensor Interface Work Mode"
+	depends on VIDEO_RK29
+	default VIDEO_RK29_WORK_ONEFRAME
 	---help---
-		RK Camera Sensor Interface(CIF) can work in 2 modes, ie:OneFrame,PingPong.
+		RK29 Camera Sensor Interface(VIP) can work in 2 modes, ie:OneFrame,PingPong.
 
-config VIDEO_RK_WORK_ONEFRAME
-	bool "CIF OneFrame Mode"
+config VIDEO_RK29_WORK_ONEFRAME
+	bool "VIP OneFrame Mode"
 
-config VIDEO_RK_WORK_PINGPONG
-	bool "CIF PingPong Mode"
+config VIDEO_RK29_WORK_PINGPONG
+	bool "VIP PingPong Mode"
 
 endchoice
 
 choice
-	prompt "RKXX camera sensor interface work with IPP "
-	depends on VIDEO_RK && RK29_IPP
-	default VIDEO_RK_WORK_IPP
+	prompt "RK29XX camera sensor interface work with IPP "
+	depends on VIDEO_RK29 && RK29_IPP
+	default VIDEO_RK29_WORK_IPP
 	---help---
-		RK Camera Sensor Interface(CIF) can work with IPP or not IPP
+		RK29 Camera Sensor Interface(VIP) can work with IPP or not IPP
 
-config VIDEO_RK_WORK_IPP
-	bool "CIF work with IPP"
+config VIDEO_RK29_WORK_IPP
+	bool "VIP work with IPP"
 
-config VIDEO_RK_WORK_NOT_IPP
-	bool "CIF don't work with IPP"
+config VIDEO_RK29_WORK_NOT_IPP
+	bool "VIP don't work with IPP"
 
 endchoice
 choice
-	prompt "RKXX camera digital zoom with IPP "
-	depends on VIDEO_RK && RK29_IPP && VIDEO_RK_WORK_IPP
+	prompt "RK29XX camera digital zoom with IPP "
+	depends on VIDEO_RK29 && RK29_IPP && VIDEO_RK29_WORK_IPP
 	default VIDEO_RK29_DIGITALZOOM_IPP_ON
 	---help---
-		RK Camera digital zoom with IPP
-config VIDEO_RK_DIGITALZOOM_IPP_ON
+		RK29 Camera digital zoom with IPP
+config VIDEO_RK29_DIGITALZOOM_IPP_ON
 	bool "Digital zoom with IPP on"
 
-config VIDEO_RK_DIGITALZOOM_IPP_OFF
+config VIDEO_RK29_DIGITALZOOM_IPP_OFF
 	bool "Digital zoom with IPP off"
 endchoice
 
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index a7a60d271b27..bd2a658eb592 100755
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -189,8 +189,8 @@ obj-$(CONFIG_VIDEO_MX1)			+= mx1_camera.o
 obj-$(CONFIG_VIDEO_MX2)			+= mx2_camera.o
 obj-$(CONFIG_VIDEO_MX3)			+= mx3_camera.o
 obj-$(CONFIG_VIDEO_PXA27x)		+= pxa_camera.o
-obj-$(CONFIG_VIDEO_RK_WORK_ONEFRAME)	+= rk_camera_oneframe.o
-obj-$(CONFIG_VIDEO_RK_WORK_PINGPONG)	+= rk_camera_pingpong.o
+obj-$(CONFIG_VIDEO_RK29_WORK_ONEFRAME)	+= rk29_camera_oneframe.o
+obj-$(CONFIG_VIDEO_RK29_WORK_PINGPONG)	+= rk29_camera_pingpong.o
 obj-$(CONFIG_VIDEO_RK29XX_VOUT)		+= rk29xx/
 obj-$(CONFIG_VIDEO_SH_MOBILE_CSI2)	+= sh_mobile_csi2.o
 obj-$(CONFIG_VIDEO_SH_MOBILE_CEU)	+= sh_mobile_ceu_camera.o
diff --git a/drivers/media/video/gc0307.c b/drivers/media/video/gc0307.c
old mode 100644
new mode 100755
index 7d4c0f21fba4..38f120d99f4c
--- a/drivers/media/video/gc0307.c
+++ b/drivers/media/video/gc0307.c
@@ -20,8 +20,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -44,18 +44,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_GC0307
+#define SENSOR_NAME RK29_CAM_SENSOR_GC0307
 #define SENSOR_V4L2_IDENT V4L2_IDENT_GC0307
 #define SENSOR_ID 0x99
 #define SENSOR_MIN_WIDTH    640//176
 #define SENSOR_MIN_HEIGHT   480//144
 #define SENSOR_MAX_WIDTH    800//1600
 #define SENSOR_MAX_HEIGHT   600//1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -75,6 +74,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -97,14 +100,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 640X480 VGA */
 static struct reginfo sensor_init_data[] =
 {
 //========= close output
@@ -1349,8 +1345,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1573,7 +1569,7 @@ static int sensor_check_array(struct i2c_client *client, struct reginfo *regarra
   	
   return 0;
 }
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1585,13 +1581,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1625,63 +1621,9 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-    char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret;
+
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1702,7 +1644,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 
     mdelay(5); */ //delay 5 microseconds
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -1713,14 +1655,14 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	int i;
 	u8 val;
 	printk("****************** check init data\n");
-	for(i=0; sensor_init_data_p[i].reg!=0xff; i++)
+	for(i=0; sensor_init_data[i].reg!=0xff; i++)
 	{
-		sensor_read(client, sensor_init_data_p[i].reg, &val);
+		sensor_read(client, sensor_init_data[i].reg, &val);
 		printk("reg 0x%02x: org=0x%02x, val=0x%02x, %s\n", 
-			sensor_init_data_p[i].reg,
-			sensor_init_data_p[i].val,
+			sensor_init_data[i].reg,
+			sensor_init_data[i].val,
 			val,
-			sensor_init_data_p[i].val==val?"O":"X");
+			sensor_init_data[i].val==val?"O":"X");
 	}
 	printk("**********************************\n");
 
@@ -2872,25 +2814,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/gc0308.c b/drivers/media/video/gc0308.c
old mode 100644
new mode 100755
index d2bb78b13b74..67669ac38f73
--- a/drivers/media/video/gc0308.c
+++ b/drivers/media/video/gc0308.c
@@ -20,8 +20,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -44,18 +44,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_GC0308
+#define SENSOR_NAME RK29_CAM_SENSOR_GC0308
 #define SENSOR_V4L2_IDENT V4L2_IDENT_GC0308
 #define SENSOR_ID 0x9b
 #define SENSOR_MIN_WIDTH    640//176
 #define SENSOR_MIN_HEIGHT   480//144
 #define SENSOR_MAX_WIDTH    640
 #define SENSOR_MAX_HEIGHT   480
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -75,6 +74,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -98,14 +101,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 640X480 VGA */
 static struct reginfo sensor_init_data[] =
 {
 
@@ -1253,8 +1249,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1448,7 +1444,7 @@ static int sensor_check_array(struct i2c_client *client, struct reginfo *regarra
   return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1460,13 +1456,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1500,63 +1496,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-    char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1577,7 +1518,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 
     mdelay(5); */ //delay 5 microseconds
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2715,25 +2656,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/gc0309.c b/drivers/media/video/gc0309.c
old mode 100644
new mode 100755
index 9dfee32330c6..dff2a47c92be
--- a/drivers/media/video/gc0309.c
+++ b/drivers/media/video/gc0309.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -43,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_GC0309
+#define SENSOR_NAME RK29_CAM_SENSOR_GC0309
 #define SENSOR_V4L2_IDENT V4L2_IDENT_GC0309
 #define SENSOR_ID 0xa0
 #define SENSOR_MIN_WIDTH    176
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    640
 #define SENSOR_MAX_HEIGHT   480
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640		/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -74,6 +73,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_HIGH |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -97,14 +100,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init SVGA preview */
 static struct reginfo sensor_init_data[] =
 {
 	  /*init registers code.*/
@@ -1198,8 +1194,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1405,7 +1401,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1417,13 +1413,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1457,63 +1453,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
-    SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
+    int ret;
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
 		ret = -ENODEV;
@@ -1548,7 +1488,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2669,25 +2609,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/gc0309_for_td8801.c b/drivers/media/video/gc0309_for_td8801.c
old mode 100755
new mode 100644
index 5bb714726cb6..f23c4d81a15f
--- a/drivers/media/video/gc0309_for_td8801.c
+++ b/drivers/media/video/gc0309_for_td8801.c
@@ -19,7 +19,7 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
+#include <mach/rk29_camera.h>
 
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
@@ -43,7 +43,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_GC0309
+#define SENSOR_NAME RK29_CAM_SENSOR_GC0309
 #define SENSOR_V4L2_IDENT V4L2_IDENT_GC0309
 #define SENSOR_ID 0xa0
 #define SENSOR_MIN_WIDTH    176
@@ -1194,8 +1194,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1401,7 +1401,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1413,13 +1413,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -2610,25 +2610,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/gc2015.c b/drivers/media/video/gc2015.c
old mode 100644
new mode 100755
index a82202d261b8..4f9e18f7a1b8
--- a/drivers/media/video/gc2015.c
+++ b/drivers/media/video/gc2015.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -43,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_GC2015
+#define SENSOR_NAME RK29_CAM_SENSOR_GC2015
 #define SENSOR_V4L2_IDENT V4L2_IDENT_GC2015
 #define SENSOR_ID 0x2005
 #define SENSOR_MIN_WIDTH    640
 #define SENSOR_MIN_HEIGHT   480
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	800//1024			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  600//768
+#define SENSOR_INIT_WINSEQADR sensor_svga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -74,6 +73,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -97,14 +100,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init SVGA preview */
 static struct reginfo sensor_init_data[] =
 
 {
@@ -1351,8 +1347,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1557,7 +1553,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1569,13 +1565,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1609,62 +1605,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_svga;
-	sensor_init_width = 800;
-	sensor_init_height = 600;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret,pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1711,7 +1653,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2880,25 +2822,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/gt2005.c b/drivers/media/video/gt2005.c
old mode 100644
new mode 100755
index 90fce9147d2f..607be6ed8a74
--- a/drivers/media/video/gt2005.c
+++ b/drivers/media/video/gt2005.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -43,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_GT2005
+#define SENSOR_NAME RK29_CAM_SENSOR_GT2005
 #define SENSOR_V4L2_IDENT  V4L2_IDENT_GT2005
 #define SENSOR_ID 0x5138
 #define SENSOR_MIN_WIDTH    640
 #define SENSOR_MIN_HEIGHT   480
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -74,6 +73,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_HIGH |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -97,14 +100,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 352X288 SVGA */
 static struct reginfo sensor_init_data[] =
 {
     {0x0101 , 0x00},
@@ -2007,8 +2003,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -2203,7 +2199,7 @@ static int sensor_check_array(struct i2c_client *client, struct reginfo *regarra
   return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -2215,13 +2211,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -2256,62 +2252,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_svga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret,pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -2358,7 +2300,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -3519,25 +3461,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/hi253.c b/drivers/media/video/hi253.c
old mode 100644
new mode 100755
index f331d21196ec..343a22c73c98
--- a/drivers/media/video/hi253.c
+++ b/drivers/media/video/hi253.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -43,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_HI253
+#define SENSOR_NAME RK29_CAM_SENSOR_HI253
 #define SENSOR_V4L2_IDENT V4L2_IDENT_HI253
 #define SENSOR_ID 0x92
 #define SENSOR_MIN_WIDTH    176
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	1600			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  1200
+#define SENSOR_INIT_WINSEQADR sensor_uxga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -74,6 +73,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -98,14 +101,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init SVGA preview */
 static struct reginfo sensor_init_data[] =
 {
 //	{0x01, 0xf9}, 
@@ -1934,8 +1930,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -2115,7 +2111,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -2127,13 +2123,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -2167,62 +2163,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;    
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_uxga;
-	sensor_init_width = 1600;
-	sensor_init_height = 1200;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -2261,7 +2203,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 #endif
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -3420,25 +3362,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/hi704.c b/drivers/media/video/hi704.c
old mode 100644
new mode 100755
index 734815102260..6c2c2659cd36
--- a/drivers/media/video/hi704.c
+++ b/drivers/media/video/hi704.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -43,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_HI704
+#define SENSOR_NAME RK29_CAM_SENSOR_HI704
 #define SENSOR_V4L2_IDENT V4L2_IDENT_HI704
 #define SENSOR_ID 0x96
 #define SENSOR_MIN_WIDTH    176
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    640
 #define SENSOR_MAX_HEIGHT   480
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -74,6 +73,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -98,14 +101,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init SVGA preview */
 static struct reginfo sensor_init_data[] =
 {
 	    //PAGE 0
@@ -1391,8 +1387,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1593,7 +1589,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1605,13 +1601,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1645,62 +1641,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1739,7 +1681,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 #endif
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2874,25 +2816,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/mt9d112.c b/drivers/media/video/mt9d112.c
old mode 100644
new mode 100755
index 585484f664b3..ce7e3b709e59
--- a/drivers/media/video/mt9d112.c
+++ b/drivers/media/video/mt9d112.c
@@ -19,8 +19,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
 #include "mt9d112.h"
 
 static int debug;
@@ -44,7 +43,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_MT9D112
+#define SENSOR_NAME RK29_CAM_SENSOR_MT9D112
 #define SENSOR_V4L2_IDENT V4L2_IDENT_MT9D112
 #define SENSOR_ID 0x1580
 #define SENSOR_ID_REG 0x3000
@@ -54,11 +53,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_MIN_HEIGHT   240
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -79,6 +77,11 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_HIGH |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -105,13 +108,6 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_AF_MODE_CLOSE       5
 #endif
 #define SENSOR_CCM_ONLY
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
 /* init 640X480 VGA */
 static struct reginfo sensor_init_data[] =
 {
@@ -1485,8 +1481,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1727,7 +1723,7 @@ static int sensor_af_init(struct i2c_client *client)
 }
 #endif
 
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1739,13 +1735,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1779,66 +1775,10 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-	    int ret,i = 0,j=0;
+    int ret;
 #if (SENSOR_ID_REG != SEQUENCE_END)    
     u16 pid = 0;
 #endif
-   struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_svga;
-	sensor_init_width = 800;
-	sensor_init_height = 600;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
-
 
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
@@ -1883,7 +1823,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -3172,24 +3112,24 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/mt9d113.c b/drivers/media/video/mt9d113.c
old mode 100644
new mode 100755
index d8ddde8d620b..66f9c8ff8f37
--- a/drivers/media/video/mt9d113.c
+++ b/drivers/media/video/mt9d113.c
@@ -20,8 +20,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
 #include "mt9d113.h"
 
 static int debug;
@@ -45,7 +44,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_MT9D113
+#define SENSOR_NAME RK29_CAM_SENSOR_MT9D113
 #define SENSOR_V4L2_IDENT V4L2_IDENT_MT9D113
 #define SENSOR_ID 0x2580
 #define SENSOR_ID_REG 0x00
@@ -57,11 +56,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_MIN_HEIGHT   600
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	800			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  600
+#define SENSOR_INIT_WINSEQADR sensor_init_data
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	0
 #define CONFIG_SENSOR_Brightness	0
@@ -81,6 +79,9 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   1
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_FALLING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_HIGH |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8 |SOCAM_MCLK_24MHZ)
 
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
@@ -106,13 +107,6 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_AF_MODE_CLOSE       5
 #endif
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
 /* init 800x600 SVGA */
 static struct reginfo sensor_init_data[] =
 {
@@ -1214,8 +1208,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1523,7 +1517,7 @@ static int sensor_af_init(struct i2c_client *client)
 }
 #endif
 
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1535,13 +1529,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1575,63 +1569,9 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-    char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_svga;
-	sensor_init_width = 800;
-	sensor_init_height = 600;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret;
+    u16 pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1685,7 +1625,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2986,24 +2926,24 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/mt9m112.c b/drivers/media/video/mt9m112.c
index fbaf30f3ad3c..348fe2ad7980 100755
--- a/drivers/media/video/mt9m112.c
+++ b/drivers/media/video/mt9m112.c
@@ -20,7 +20,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
+#include <mach/rk29_camera.h>
 #include "mt9m112.h"
 
 static int debug;
@@ -1049,7 +1049,7 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
+	struct rk29camera_platform_data *sensor_io_request;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1314,7 +1314,7 @@ static int sensor_af_init(struct i2c_client *client)
 }
 #endif
 
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1326,13 +1326,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -2670,14 +2670,14 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;
 			break;
 		}
 		default:
diff --git a/drivers/media/video/mt9p111.c b/drivers/media/video/mt9p111.c
index b2a836f67d6d..d65188294379 100644
--- a/drivers/media/video/mt9p111.c
+++ b/drivers/media/video/mt9p111.c
@@ -22,8 +22,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
 #include "mt9p111.h"
 
 static int debug;
@@ -47,7 +46,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_MT9P111
+#define SENSOR_NAME RK29_CAM_SENSOR_MT9P111
 #define SENSOR_V4L2_IDENT V4L2_IDENT_MT9P111
 #define SENSOR_ID SEQUENCE_END
 #define SENSOR_ID_REG SEQUENCE_END
@@ -58,11 +57,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    2592
 #define SENSOR_MAX_HEIGHT   1944
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT  V4L2_MBUS_FMT_UYVY8_2X8
 #define YUV420_BUFFER_MAX_SIZE  7558272     /* 2592*1944*1.5*/ 
 
 #define CONFIG_SENSOR_WhiteBalance	1
@@ -86,6 +84,11 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_HIGH|\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN    6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -114,14 +117,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_AF_MODE_CLOSE       5
 #endif
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 640X480 VGA */
 static struct reginfo sensor_init_data[] =
 {
 //[Step2-PLL_Timing]
@@ -2250,8 +2246,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -2818,7 +2814,7 @@ static int sensor_af_init(struct i2c_client *client)
 }
 #endif
 
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -2830,13 +2826,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -2872,66 +2868,11 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
 #endif
     const struct sensor_datafmt *fmt;
-    int ret,pid = 0,i = 0,j=0;
+    int ret,pid = 0;
     int index  =0 ;
 #if (SENSOR_RESET_REG != SEQUENCE_END)
     struct reginfo reg_info;
 #endif
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
 
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
@@ -2982,7 +2923,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     
     SENSOR_DG("\n sensor_init_data..%s.\n",SENSOR_NAME_STRING());
  
-    ret =sensor_write_init_data(client, sensor_init_data_p);
+    ret =sensor_write_init_data(client, sensor_init_data);
     if (ret != 0) {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
         goto sensor_INIT_ERR;
@@ -4685,29 +4626,29 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 #endif
     int ret = 0;
     
-    rk_camera_sensor_cb_s *icd_cb =NULL;
+    rk29_camera_sensor_cb_s *icd_cb =NULL;
     
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
@@ -4728,9 +4669,9 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
             #endif
 			break;
 		}
-        case RK_CAM_SUBDEV_CB_REGISTER:
+        case RK29_CAM_SUBDEV_CB_REGISTER:
         {
-           icd_cb = (rk_camera_sensor_cb_s*)(arg);
+           icd_cb = (rk29_camera_sensor_cb_s*)(arg);
            icd_cb->sensor_cb = sensor_cb;
            break;    
         }
diff --git a/drivers/media/video/mt9t111.c b/drivers/media/video/mt9t111.c
old mode 100644
new mode 100755
index cda158700afa..63cfb5fb4378
--- a/drivers/media/video/mt9t111.c
+++ b/drivers/media/video/mt9t111.c
@@ -20,8 +20,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
 #include "mt9t111.h"
 
 static int debug;
@@ -45,7 +44,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_MT9T111
+#define SENSOR_NAME RK29_CAM_SENSOR_MT9T111
 #define SENSOR_V4L2_IDENT V4L2_IDENT_MT9T111
 #define SENSOR_ID SEQUENCE_END
 #define SENSOR_ID_REG SEQUENCE_END
@@ -56,11 +55,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    2048
 #define SENSOR_MAX_HEIGHT   1536
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -84,6 +82,11 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_HIGH|\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN    6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -110,14 +113,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_AF_MODE_CLOSE       5
 #endif
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 640X480 VGA */
 static struct reginfo sensor_init_data[] =
 {
 //[Step2-PLL_Timing]
@@ -6260,8 +6256,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -6651,7 +6647,7 @@ static int sensor_af_init(struct i2c_client *client)
 }
 #endif
 
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -6663,13 +6659,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -6703,65 +6699,10 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-    int ret,pid = 0,i = 0,j=0;
+    int ret,pid = 0;
 #if (SENSOR_RESET_REG != SEQUENCE_END)
     struct reginfo reg_info;
 #endif
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
 		ret = -ENODEV;
@@ -6805,8 +6746,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         ret = -ENODEV;
         goto sensor_INIT_ERR;
     }
-
-    ret = sensor_write_array(client, sensor_init_data_p);
+	
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -8318,24 +8259,24 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/nt99250.c b/drivers/media/video/nt99250.c
old mode 100644
new mode 100755
index 3e2712b7fb8e..4aaaecee8aff
--- a/drivers/media/video/nt99250.c
+++ b/drivers/media/video/nt99250.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -43,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_NT99250
+#define SENSOR_NAME RK29_CAM_SENSOR_NT99250
 #define SENSOR_V4L2_IDENT V4L2_IDENT_NT99250
 #define SENSOR_ID 0x0105
 #define SENSOR_MIN_WIDTH    176
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	800			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  600
+#define SENSOR_INIT_WINSEQADR sensor_svga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	0
 #define CONFIG_SENSOR_Brightness	0
@@ -74,6 +73,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -97,14 +100,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 352X288 SVGA */
 static struct reginfo sensor_init_data[] =
 {
 {0x3024,0x02}, //TG   //0x02     
@@ -1219,8 +1215,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 
@@ -1404,7 +1400,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1416,13 +1412,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1456,62 +1452,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_svga;
-	sensor_init_width = 800;
-	sensor_init_height = 600;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret,pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1561,7 +1503,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     }
 	#endif
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2762,25 +2704,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/ov2640.c b/drivers/media/video/ov2640.c
index 1d1cb7facf62..9b2ac56310ef 100644
--- a/drivers/media/video/ov2640.c
+++ b/drivers/media/video/ov2640.c
@@ -1,3 +1,1216 @@
+/*
+<<<<<<< HEAD
+ * ov2640 Camera Driver
+ *
+ * Copyright (C) 2010 Alberto Panizzo <maramaopercheseimorto@gmail.com>
+ *
+ * Based on ov772x, ov9640 drivers and previous non merged implementations.
+ *
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2006, OmniVision
+=======
+o* Driver for MT9M001 CMOS Image Sensor from Micron
+ *
+ * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
+>>>>>>> parent of 15f7fab... temp revert rk change
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+<<<<<<< HEAD
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-subdev.h>
+#include <media/soc_camera.h>
+#include <media/soc_mediabus.h>
+
+#define VAL_SET(x, mask, rshift, lshift)  \
+		((((x) >> rshift) & mask) << lshift)
+/*
+ * DSP registers
+ * register offset for BANK_SEL == BANK_SEL_DSP
+ */
+#define R_BYPASS    0x05 /* Bypass DSP */
+#define   R_BYPASS_DSP_BYPAS    0x01 /* Bypass DSP, sensor out directly */
+#define   R_BYPASS_USE_DSP      0x00 /* Use the internal DSP */
+#define QS          0x44 /* Quantization Scale Factor */
+#define CTRLI       0x50
+#define   CTRLI_LP_DP           0x80
+#define   CTRLI_ROUND           0x40
+#define   CTRLI_V_DIV_SET(x)    VAL_SET(x, 0x3, 0, 3)
+#define   CTRLI_H_DIV_SET(x)    VAL_SET(x, 0x3, 0, 0)
+#define HSIZE       0x51 /* H_SIZE[7:0] (real/4) */
+#define   HSIZE_SET(x)          VAL_SET(x, 0xFF, 2, 0)
+#define VSIZE       0x52 /* V_SIZE[7:0] (real/4) */
+#define   VSIZE_SET(x)          VAL_SET(x, 0xFF, 2, 0)
+#define XOFFL       0x53 /* OFFSET_X[7:0] */
+#define   XOFFL_SET(x)          VAL_SET(x, 0xFF, 0, 0)
+#define YOFFL       0x54 /* OFFSET_Y[7:0] */
+#define   YOFFL_SET(x)          VAL_SET(x, 0xFF, 0, 0)
+#define VHYX        0x55 /* Offset and size completion */
+#define   VHYX_VSIZE_SET(x)     VAL_SET(x, 0x1, (8+2), 7)
+#define   VHYX_HSIZE_SET(x)     VAL_SET(x, 0x1, (8+2), 3)
+#define   VHYX_YOFF_SET(x)      VAL_SET(x, 0x3, 8, 4)
+#define   VHYX_XOFF_SET(x)      VAL_SET(x, 0x3, 8, 0)
+#define DPRP        0x56
+#define TEST        0x57 /* Horizontal size completion */
+#define   TEST_HSIZE_SET(x)     VAL_SET(x, 0x1, (9+2), 7)
+#define ZMOW        0x5A /* Zoom: Out Width  OUTW[7:0] (real/4) */
+#define   ZMOW_OUTW_SET(x)      VAL_SET(x, 0xFF, 2, 0)
+#define ZMOH        0x5B /* Zoom: Out Height OUTH[7:0] (real/4) */
+#define   ZMOH_OUTH_SET(x)      VAL_SET(x, 0xFF, 2, 0)
+#define ZMHH        0x5C /* Zoom: Speed and H&W completion */
+#define   ZMHH_ZSPEED_SET(x)    VAL_SET(x, 0x0F, 0, 4)
+#define   ZMHH_OUTH_SET(x)      VAL_SET(x, 0x1, (8+2), 2)
+#define   ZMHH_OUTW_SET(x)      VAL_SET(x, 0x3, (8+2), 0)
+#define BPADDR      0x7C /* SDE Indirect Register Access: Address */
+#define BPDATA      0x7D /* SDE Indirect Register Access: Data */
+#define CTRL2       0x86 /* DSP Module enable 2 */
+#define   CTRL2_DCW_EN          0x20
+#define   CTRL2_SDE_EN          0x10
+#define   CTRL2_UV_ADJ_EN       0x08
+#define   CTRL2_UV_AVG_EN       0x04
+#define   CTRL2_CMX_EN          0x01
+#define CTRL3       0x87 /* DSP Module enable 3 */
+#define   CTRL3_BPC_EN          0x80
+#define   CTRL3_WPC_EN          0x40
+#define SIZEL       0x8C /* Image Size Completion */
+#define   SIZEL_HSIZE8_11_SET(x) VAL_SET(x, 0x1, 11, 6)
+#define   SIZEL_HSIZE8_SET(x)    VAL_SET(x, 0x7, 0, 3)
+#define   SIZEL_VSIZE8_SET(x)    VAL_SET(x, 0x7, 0, 0)
+#define HSIZE8      0xC0 /* Image Horizontal Size HSIZE[10:3] */
+#define   HSIZE8_SET(x)         VAL_SET(x, 0xFF, 3, 0)
+#define VSIZE8      0xC1 /* Image Vertical Size VSIZE[10:3] */
+#define   VSIZE8_SET(x)         VAL_SET(x, 0xFF, 3, 0)
+#define CTRL0       0xC2 /* DSP Module enable 0 */
+#define   CTRL0_AEC_EN       0x80
+#define   CTRL0_AEC_SEL      0x40
+#define   CTRL0_STAT_SEL     0x20
+#define   CTRL0_VFIRST       0x10
+#define   CTRL0_YUV422       0x08
+#define   CTRL0_YUV_EN       0x04
+#define   CTRL0_RGB_EN       0x02
+#define   CTRL0_RAW_EN       0x01
+#define CTRL1       0xC3 /* DSP Module enable 1 */
+#define   CTRL1_CIP          0x80
+#define   CTRL1_DMY          0x40
+#define   CTRL1_RAW_GMA      0x20
+#define   CTRL1_DG           0x10
+#define   CTRL1_AWB          0x08
+#define   CTRL1_AWB_GAIN     0x04
+#define   CTRL1_LENC         0x02
+#define   CTRL1_PRE          0x01
+#define R_DVP_SP    0xD3 /* DVP output speed control */
+#define   R_DVP_SP_AUTO_MODE 0x80
+#define   R_DVP_SP_DVP_MASK  0x3F /* DVP PCLK = sysclk (48)/[6:0] (YUV0);
+				   *          = sysclk (48)/(2*[6:0]) (RAW);*/
+#define IMAGE_MODE  0xDA /* Image Output Format Select */
+#define   IMAGE_MODE_Y8_DVP_EN   0x40
+#define   IMAGE_MODE_JPEG_EN     0x10
+#define   IMAGE_MODE_YUV422      0x00
+#define   IMAGE_MODE_RAW10       0x04 /* (DVP) */
+#define   IMAGE_MODE_RGB565      0x08
+#define   IMAGE_MODE_HREF_VSYNC  0x02 /* HREF timing select in DVP JPEG output
+				       * mode (0 for HREF is same as sensor) */
+#define   IMAGE_MODE_LBYTE_FIRST 0x01 /* Byte swap enable for DVP
+				       *    1: Low byte first UYVY (C2[4] =0)
+				       *        VYUY (C2[4] =1)
+				       *    0: High byte first YUYV (C2[4]=0)
+				       *        YVYU (C2[4] = 1) */
+#define RESET       0xE0 /* Reset */
+#define   RESET_MICROC       0x40
+#define   RESET_SCCB         0x20
+#define   RESET_JPEG         0x10
+#define   RESET_DVP          0x04
+#define   RESET_IPU          0x02
+#define   RESET_CIF          0x01
+#define REGED       0xED /* Register ED */
+#define   REGED_CLK_OUT_DIS  0x10
+#define MS_SP       0xF0 /* SCCB Master Speed */
+#define SS_ID       0xF7 /* SCCB Slave ID */
+#define SS_CTRL     0xF8 /* SCCB Slave Control */
+#define   SS_CTRL_ADD_AUTO_INC  0x20
+#define   SS_CTRL_EN            0x08
+#define   SS_CTRL_DELAY_CLK     0x04
+#define   SS_CTRL_ACC_EN        0x02
+#define   SS_CTRL_SEN_PASS_THR  0x01
+#define MC_BIST     0xF9 /* Microcontroller misc register */
+#define   MC_BIST_RESET           0x80 /* Microcontroller Reset */
+#define   MC_BIST_BOOT_ROM_SEL    0x40
+#define   MC_BIST_12KB_SEL        0x20
+#define   MC_BIST_12KB_MASK       0x30
+#define   MC_BIST_512KB_SEL       0x08
+#define   MC_BIST_512KB_MASK      0x0C
+#define   MC_BIST_BUSY_BIT_R      0x02
+#define   MC_BIST_MC_RES_ONE_SH_W 0x02
+#define   MC_BIST_LAUNCH          0x01
+#define BANK_SEL    0xFF /* Register Bank Select */
+#define   BANK_SEL_DSP     0x00
+#define   BANK_SEL_SENS    0x01
+
+/*
+ * Sensor registers
+ * register offset for BANK_SEL == BANK_SEL_SENS
+ */
+#define GAIN        0x00 /* AGC - Gain control gain setting */
+#define COM1        0x03 /* Common control 1 */
+#define   COM1_1_DUMMY_FR          0x40
+#define   COM1_3_DUMMY_FR          0x80
+#define   COM1_7_DUMMY_FR          0xC0
+#define   COM1_VWIN_LSB_UXGA       0x0F
+#define   COM1_VWIN_LSB_SVGA       0x0A
+#define   COM1_VWIN_LSB_CIF        0x06
+#define REG04       0x04 /* Register 04 */
+#define   REG04_DEF             0x20 /* Always set */
+#define   REG04_HFLIP_IMG       0x80 /* Horizontal mirror image ON/OFF */
+#define   REG04_VFLIP_IMG       0x40 /* Vertical flip image ON/OFF */
+#define   REG04_VREF_EN         0x10
+#define   REG04_HREF_EN         0x08
+#define   REG04_AEC_SET(x)      VAL_SET(x, 0x3, 0, 0)
+#define REG08       0x08 /* Frame Exposure One-pin Control Pre-charge Row Num */
+#define COM2        0x09 /* Common control 2 */
+#define   COM2_SOFT_SLEEP_MODE  0x10 /* Soft sleep mode */
+				     /* Output drive capability */
+#define   COM2_OCAP_Nx_SET(N)   (((N) - 1) & 0x03) /* N = [1x .. 4x] */
+#define PID         0x0A /* Product ID Number MSB */
+#define VER         0x0B /* Product ID Number LSB */
+#define COM3        0x0C /* Common control 3 */
+#define   COM3_BAND_50H        0x04 /* 0 For Banding at 60H */
+#define   COM3_BAND_AUTO       0x02 /* Auto Banding */
+#define   COM3_SING_FR_SNAPSH  0x01 /* 0 For enable live video output after the
+				     * snapshot sequence*/
+#define AEC         0x10 /* AEC[9:2] Exposure Value */
+#define CLKRC       0x11 /* Internal clock */
+#define   CLKRC_EN             0x80
+#define   CLKRC_DIV_SET(x)     (((x) - 1) & 0x1F) /* CLK = XVCLK/(x) */
+#define COM7        0x12 /* Common control 7 */
+#define   COM7_SRST            0x80 /* Initiates system reset. All registers are
+				     * set to factory default values after which
+				     * the chip resumes normal operation */
+#define   COM7_RES_UXGA        0x00 /* Resolution selectors for UXGA */
+#define   COM7_RES_SVGA        0x40 /* SVGA */
+#define   COM7_RES_CIF         0x20 /* CIF */
+#define   COM7_ZOOM_EN         0x04 /* Enable Zoom mode */
+#define   COM7_COLOR_BAR_TEST  0x02 /* Enable Color Bar Test Pattern */
+#define COM8        0x13 /* Common control 8 */
+#define   COM8_DEF             0xC0 /* Banding filter ON/OFF */
+#define   COM8_BNDF_EN         0x20 /* Banding filter ON/OFF */
+#define   COM8_AGC_EN          0x04 /* AGC Auto/Manual control selection */
+#define   COM8_AEC_EN          0x01 /* Auto/Manual Exposure control */
+#define COM9        0x14 /* Common control 9
+			  * Automatic gain ceiling - maximum AGC value [7:5]*/
+#define   COM9_AGC_GAIN_2x     0x00 /* 000 :   2x */
+#define   COM9_AGC_GAIN_4x     0x20 /* 001 :   4x */
+#define   COM9_AGC_GAIN_8x     0x40 /* 010 :   8x */
+#define   COM9_AGC_GAIN_16x    0x60 /* 011 :  16x */
+#define   COM9_AGC_GAIN_32x    0x80 /* 100 :  32x */
+#define   COM9_AGC_GAIN_64x    0xA0 /* 101 :  64x */
+#define   COM9_AGC_GAIN_128x   0xC0 /* 110 : 128x */
+#define COM10       0x15 /* Common control 10 */
+#define   COM10_PCLK_HREF      0x20 /* PCLK output qualified by HREF */
+#define   COM10_PCLK_RISE      0x10 /* Data is updated at the rising edge of
+				     * PCLK (user can latch data at the next
+				     * falling edge of PCLK).
+				     * 0 otherwise. */
+#define   COM10_HREF_INV       0x08 /* Invert HREF polarity:
+				     * HREF negative for valid data*/
+#define   COM10_VSINC_INV      0x02 /* Invert VSYNC polarity */
+#define HSTART      0x17 /* Horizontal Window start MSB 8 bit */
+#define HEND        0x18 /* Horizontal Window end MSB 8 bit */
+#define VSTART      0x19 /* Vertical Window start MSB 8 bit */
+#define VEND        0x1A /* Vertical Window end MSB 8 bit */
+#define MIDH        0x1C /* Manufacturer ID byte - high */
+#define MIDL        0x1D /* Manufacturer ID byte - low  */
+#define AEW         0x24 /* AGC/AEC - Stable operating region (upper limit) */
+#define AEB         0x25 /* AGC/AEC - Stable operating region (lower limit) */
+#define VV          0x26 /* AGC/AEC Fast mode operating region */
+#define   VV_HIGH_TH_SET(x)      VAL_SET(x, 0xF, 0, 4)
+#define   VV_LOW_TH_SET(x)       VAL_SET(x, 0xF, 0, 0)
+#define REG2A       0x2A /* Dummy pixel insert MSB */
+#define FRARL       0x2B /* Dummy pixel insert LSB */
+#define ADDVFL      0x2D /* LSB of insert dummy lines in Vertical direction */
+#define ADDVFH      0x2E /* MSB of insert dummy lines in Vertical direction */
+#define YAVG        0x2F /* Y/G Channel Average value */
+#define REG32       0x32 /* Common Control 32 */
+#define   REG32_PCLK_DIV_2    0x80 /* PCLK freq divided by 2 */
+#define   REG32_PCLK_DIV_4    0xC0 /* PCLK freq divided by 4 */
+#define ARCOM2      0x34 /* Zoom: Horizontal start point */
+#define REG45       0x45 /* Register 45 */
+#define FLL         0x46 /* Frame Length Adjustment LSBs */
+#define FLH         0x47 /* Frame Length Adjustment MSBs */
+#define COM19       0x48 /* Zoom: Vertical start point */
+#define ZOOMS       0x49 /* Zoom: Vertical start point */
+#define COM22       0x4B /* Flash light control */
+#define COM25       0x4E /* For Banding operations */
+#define BD50        0x4F /* 50Hz Banding AEC 8 LSBs */
+#define BD60        0x50 /* 60Hz Banding AEC 8 LSBs */
+#define REG5D       0x5D /* AVGsel[7:0],   16-zone average weight option */
+#define REG5E       0x5E /* AVGsel[15:8],  16-zone average weight option */
+#define REG5F       0x5F /* AVGsel[23:16], 16-zone average weight option */
+#define REG60       0x60 /* AVGsel[31:24], 16-zone average weight option */
+#define HISTO_LOW   0x61 /* Histogram Algorithm Low Level */
+#define HISTO_HIGH  0x62 /* Histogram Algorithm High Level */
+
+/*
+ * ID
+ */
+#define MANUFACTURER_ID	0x7FA2
+#define PID_OV2640	0x2642
+#define VERSION(pid, ver) ((pid << 8) | (ver & 0xFF))
+
+/*
+ * Struct
+ */
+struct regval_list {
+	u8 reg_num;
+	u8 value;
+};
+
+/* Supported resolutions */
+enum ov2640_width {
+	W_QCIF	= 176,
+	W_QVGA	= 320,
+	W_CIF	= 352,
+	W_VGA	= 640,
+	W_SVGA	= 800,
+	W_XGA	= 1024,
+	W_SXGA	= 1280,
+	W_UXGA	= 1600,
+};
+
+enum ov2640_height {
+	H_QCIF	= 144,
+	H_QVGA	= 240,
+	H_CIF	= 288,
+	H_VGA	= 480,
+	H_SVGA	= 600,
+	H_XGA	= 768,
+	H_SXGA	= 1024,
+	H_UXGA	= 1200,
+};
+
+struct ov2640_win_size {
+	char				*name;
+	enum ov2640_width		width;
+	enum ov2640_height		height;
+	const struct regval_list	*regs;
+};
+
+
+struct ov2640_priv {
+	struct v4l2_subdev		subdev;
+	struct ov2640_camera_info	*info;
+	enum v4l2_mbus_pixelcode	cfmt_code;
+	const struct ov2640_win_size	*win;
+	int				model;
+	u16				flag_vflip:1;
+	u16				flag_hflip:1;
+};
+
+/*
+ * Registers settings
+ */
+
+#define ENDMARKER { 0xff, 0xff }
+
+static const struct regval_list ov2640_init_regs[] = {
+	{ BANK_SEL, BANK_SEL_DSP },
+	{ 0x2c,   0xff },
+	{ 0x2e,   0xdf },
+	{ BANK_SEL, BANK_SEL_SENS },
+	{ 0x3c,   0x32 },
+	{ CLKRC, CLKRC_DIV_SET(1) },
+	{ COM2, COM2_OCAP_Nx_SET(3) },
+	{ REG04, REG04_DEF | REG04_HREF_EN },
+	{ COM8,  COM8_DEF | COM8_BNDF_EN | COM8_AGC_EN | COM8_AEC_EN },
+	{ COM9, COM9_AGC_GAIN_8x | 0x08},
+	{ 0x2c,   0x0c },
+	{ 0x33,   0x78 },
+	{ 0x3a,   0x33 },
+	{ 0x3b,   0xfb },
+	{ 0x3e,   0x00 },
+	{ 0x43,   0x11 },
+	{ 0x16,   0x10 },
+	{ 0x39,   0x02 },
+	{ 0x35,   0x88 },
+	{ 0x22,   0x0a },
+	{ 0x37,   0x40 },
+	{ 0x23,   0x00 },
+	{ ARCOM2, 0xa0 },
+	{ 0x06,   0x02 },
+	{ 0x06,   0x88 },
+	{ 0x07,   0xc0 },
+	{ 0x0d,   0xb7 },
+	{ 0x0e,   0x01 },
+	{ 0x4c,   0x00 },
+	{ 0x4a,   0x81 },
+	{ 0x21,   0x99 },
+	{ AEW,    0x40 },
+	{ AEB,    0x38 },
+	{ VV,     VV_HIGH_TH_SET(0x08) | VV_LOW_TH_SET(0x02) },
+	{ 0x5c,   0x00 },
+	{ 0x63,   0x00 },
+	{ FLL,    0x22 },
+	{ COM3,   0x38 | COM3_BAND_AUTO },
+	{ REG5D,  0x55 },
+	{ REG5E,  0x7d },
+	{ REG5F,  0x7d },
+	{ REG60,  0x55 },
+	{ HISTO_LOW,   0x70 },
+	{ HISTO_HIGH,  0x80 },
+	{ 0x7c,   0x05 },
+	{ 0x20,   0x80 },
+	{ 0x28,   0x30 },
+	{ 0x6c,   0x00 },
+	{ 0x6d,   0x80 },
+	{ 0x6e,   0x00 },
+	{ 0x70,   0x02 },
+	{ 0x71,   0x94 },
+	{ 0x73,   0xc1 },
+	{ 0x3d,   0x34 },
+	{ COM7, COM7_RES_UXGA | COM7_ZOOM_EN },
+	{ 0x5a,   0x57 },
+	{ BD50,   0xbb },
+	{ BD60,   0x9c },
+	{ BANK_SEL, BANK_SEL_DSP },
+	{ 0xe5,   0x7f },
+	{ MC_BIST, MC_BIST_RESET | MC_BIST_BOOT_ROM_SEL },
+	{ 0x41,   0x24 },
+	{ RESET, RESET_JPEG | RESET_DVP },
+	{ 0x76,   0xff },
+	{ 0x33,   0xa0 },
+	{ 0x42,   0x20 },
+	{ 0x43,   0x18 },
+	{ 0x4c,   0x00 },
+	{ CTRL3, CTRL3_BPC_EN | CTRL3_WPC_EN | 0x10 },
+	{ 0x88,   0x3f },
+	{ 0xd7,   0x03 },
+	{ 0xd9,   0x10 },
+	{ R_DVP_SP , R_DVP_SP_AUTO_MODE | 0x2 },
+	{ 0xc8,   0x08 },
+	{ 0xc9,   0x80 },
+	{ BPADDR, 0x00 },
+	{ BPDATA, 0x00 },
+	{ BPADDR, 0x03 },
+	{ BPDATA, 0x48 },
+	{ BPDATA, 0x48 },
+	{ BPADDR, 0x08 },
+	{ BPDATA, 0x20 },
+	{ BPDATA, 0x10 },
+	{ BPDATA, 0x0e },
+	{ 0x90,   0x00 },
+	{ 0x91,   0x0e },
+	{ 0x91,   0x1a },
+	{ 0x91,   0x31 },
+	{ 0x91,   0x5a },
+	{ 0x91,   0x69 },
+	{ 0x91,   0x75 },
+	{ 0x91,   0x7e },
+	{ 0x91,   0x88 },
+	{ 0x91,   0x8f },
+	{ 0x91,   0x96 },
+	{ 0x91,   0xa3 },
+	{ 0x91,   0xaf },
+	{ 0x91,   0xc4 },
+	{ 0x91,   0xd7 },
+	{ 0x91,   0xe8 },
+	{ 0x91,   0x20 },
+	{ 0x92,   0x00 },
+	{ 0x93,   0x06 },
+	{ 0x93,   0xe3 },
+	{ 0x93,   0x03 },
+	{ 0x93,   0x03 },
+	{ 0x93,   0x00 },
+	{ 0x93,   0x02 },
+	{ 0x93,   0x00 },
+	{ 0x93,   0x00 },
+	{ 0x93,   0x00 },
+	{ 0x93,   0x00 },
+	{ 0x93,   0x00 },
+	{ 0x93,   0x00 },
+	{ 0x93,   0x00 },
+	{ 0x96,   0x00 },
+	{ 0x97,   0x08 },
+	{ 0x97,   0x19 },
+	{ 0x97,   0x02 },
+	{ 0x97,   0x0c },
+	{ 0x97,   0x24 },
+	{ 0x97,   0x30 },
+	{ 0x97,   0x28 },
+	{ 0x97,   0x26 },
+	{ 0x97,   0x02 },
+	{ 0x97,   0x98 },
+	{ 0x97,   0x80 },
+	{ 0x97,   0x00 },
+	{ 0x97,   0x00 },
+	{ 0xa4,   0x00 },
+	{ 0xa8,   0x00 },
+	{ 0xc5,   0x11 },
+	{ 0xc6,   0x51 },
+	{ 0xbf,   0x80 },
+	{ 0xc7,   0x10 },
+	{ 0xb6,   0x66 },
+	{ 0xb8,   0xA5 },
+	{ 0xb7,   0x64 },
+	{ 0xb9,   0x7C },
+	{ 0xb3,   0xaf },
+	{ 0xb4,   0x97 },
+	{ 0xb5,   0xFF },
+	{ 0xb0,   0xC5 },
+	{ 0xb1,   0x94 },
+	{ 0xb2,   0x0f },
+	{ 0xc4,   0x5c },
+	{ 0xa6,   0x00 },
+	{ 0xa7,   0x20 },
+	{ 0xa7,   0xd8 },
+	{ 0xa7,   0x1b },
+	{ 0xa7,   0x31 },
+	{ 0xa7,   0x00 },
+	{ 0xa7,   0x18 },
+	{ 0xa7,   0x20 },
+	{ 0xa7,   0xd8 },
+	{ 0xa7,   0x19 },
+	{ 0xa7,   0x31 },
+	{ 0xa7,   0x00 },
+	{ 0xa7,   0x18 },
+	{ 0xa7,   0x20 },
+	{ 0xa7,   0xd8 },
+	{ 0xa7,   0x19 },
+	{ 0xa7,   0x31 },
+	{ 0xa7,   0x00 },
+	{ 0xa7,   0x18 },
+	{ 0x7f,   0x00 },
+	{ 0xe5,   0x1f },
+	{ 0xe1,   0x77 },
+	{ 0xdd,   0x7f },
+	{ CTRL0,  CTRL0_YUV422 | CTRL0_YUV_EN | CTRL0_RGB_EN },
+	ENDMARKER,
+};
+
+/*
+ * Register settings for window size
+ * The preamble, setup the internal DSP to input an UXGA (1600x1200) image.
+ * Then the different zooming configurations will setup the output image size.
+ */
+static const struct regval_list ov2640_size_change_preamble_regs[] = {
+	{ BANK_SEL, BANK_SEL_DSP },
+	{ RESET, RESET_DVP },
+	{ HSIZE8, HSIZE8_SET(W_UXGA) },
+	{ VSIZE8, VSIZE8_SET(H_UXGA) },
+	{ CTRL2, CTRL2_DCW_EN | CTRL2_SDE_EN |
+		 CTRL2_UV_AVG_EN | CTRL2_CMX_EN | CTRL2_UV_ADJ_EN },
+	{ HSIZE, HSIZE_SET(W_UXGA) },
+	{ VSIZE, VSIZE_SET(H_UXGA) },
+	{ XOFFL, XOFFL_SET(0) },
+	{ YOFFL, YOFFL_SET(0) },
+	{ VHYX, VHYX_HSIZE_SET(W_UXGA) | VHYX_VSIZE_SET(H_UXGA) |
+		VHYX_XOFF_SET(0) | VHYX_YOFF_SET(0)},
+	{ TEST, TEST_HSIZE_SET(W_UXGA) },
+	ENDMARKER,
+};
+
+#define PER_SIZE_REG_SEQ(x, y, v_div, h_div, pclk_div)	\
+	{ CTRLI, CTRLI_LP_DP | CTRLI_V_DIV_SET(v_div) |	\
+		 CTRLI_H_DIV_SET(h_div)},		\
+	{ ZMOW, ZMOW_OUTW_SET(x) },			\
+	{ ZMOH, ZMOH_OUTH_SET(y) },			\
+	{ ZMHH, ZMHH_OUTW_SET(x) | ZMHH_OUTH_SET(y) },	\
+	{ R_DVP_SP, pclk_div },				\
+	{ RESET, 0x00}
+
+static const struct regval_list ov2640_qcif_regs[] = {
+	PER_SIZE_REG_SEQ(W_QCIF, H_QCIF, 3, 3, 4),
+	ENDMARKER,
+};
+
+static const struct regval_list ov2640_qvga_regs[] = {
+	PER_SIZE_REG_SEQ(W_QVGA, H_QVGA, 2, 2, 4),
+	ENDMARKER,
+};
+
+static const struct regval_list ov2640_cif_regs[] = {
+	PER_SIZE_REG_SEQ(W_CIF, H_CIF, 2, 2, 8),
+	ENDMARKER,
+};
+
+static const struct regval_list ov2640_vga_regs[] = {
+	PER_SIZE_REG_SEQ(W_VGA, H_VGA, 0, 0, 2),
+	ENDMARKER,
+};
+
+static const struct regval_list ov2640_svga_regs[] = {
+	PER_SIZE_REG_SEQ(W_SVGA, H_SVGA, 1, 1, 2),
+	ENDMARKER,
+};
+
+static const struct regval_list ov2640_xga_regs[] = {
+	PER_SIZE_REG_SEQ(W_XGA, H_XGA, 0, 0, 2),
+	{ CTRLI,    0x00},
+	ENDMARKER,
+};
+
+static const struct regval_list ov2640_sxga_regs[] = {
+	PER_SIZE_REG_SEQ(W_SXGA, H_SXGA, 0, 0, 2),
+	{ CTRLI,    0x00},
+	{ R_DVP_SP, 2 | R_DVP_SP_AUTO_MODE },
+	ENDMARKER,
+};
+
+static const struct regval_list ov2640_uxga_regs[] = {
+	PER_SIZE_REG_SEQ(W_UXGA, H_UXGA, 0, 0, 0),
+	{ CTRLI,    0x00},
+	{ R_DVP_SP, 0 | R_DVP_SP_AUTO_MODE },
+	ENDMARKER,
+};
+
+#define OV2640_SIZE(n, w, h, r) \
+	{.name = n, .width = w , .height = h, .regs = r }
+
+static const struct ov2640_win_size ov2640_supported_win_sizes[] = {
+	OV2640_SIZE("QCIF", W_QCIF, H_QCIF, ov2640_qcif_regs),
+	OV2640_SIZE("QVGA", W_QVGA, H_QVGA, ov2640_qvga_regs),
+	OV2640_SIZE("CIF", W_CIF, H_CIF, ov2640_cif_regs),
+	OV2640_SIZE("VGA", W_VGA, H_VGA, ov2640_vga_regs),
+	OV2640_SIZE("SVGA", W_SVGA, H_SVGA, ov2640_svga_regs),
+	OV2640_SIZE("XGA", W_XGA, H_XGA, ov2640_xga_regs),
+	OV2640_SIZE("SXGA", W_SXGA, H_SXGA, ov2640_sxga_regs),
+	OV2640_SIZE("UXGA", W_UXGA, H_UXGA, ov2640_uxga_regs),
+};
+
+/*
+ * Register settings for pixel formats
+ */
+static const struct regval_list ov2640_format_change_preamble_regs[] = {
+	{ BANK_SEL, BANK_SEL_DSP },
+	{ R_BYPASS, R_BYPASS_USE_DSP },
+	ENDMARKER,
+};
+
+static const struct regval_list ov2640_yuv422_regs[] = {
+	{ IMAGE_MODE, IMAGE_MODE_LBYTE_FIRST | IMAGE_MODE_YUV422 },
+	{ 0xD7, 0x01 },
+	{ 0x33, 0xa0 },
+	{ 0xe1, 0x67 },
+	{ RESET,  0x00 },
+	{ R_BYPASS, R_BYPASS_USE_DSP },
+	ENDMARKER,
+};
+
+static const struct regval_list ov2640_rgb565_regs[] = {
+	{ IMAGE_MODE, IMAGE_MODE_LBYTE_FIRST | IMAGE_MODE_RGB565 },
+	{ 0xd7, 0x03 },
+	{ RESET,  0x00 },
+	{ R_BYPASS, R_BYPASS_USE_DSP },
+	ENDMARKER,
+};
+
+static enum v4l2_mbus_pixelcode ov2640_codes[] = {
+	V4L2_MBUS_FMT_UYVY8_2X8,
+	V4L2_MBUS_FMT_RGB565_2X8_LE,
+};
+
+/*
+ * Supported controls
+ */
+static const struct v4l2_queryctrl ov2640_controls[] = {
+	{
+		.id		= V4L2_CID_VFLIP,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Flip Vertically",
+		.minimum	= 0,
+		.maximum	= 1,
+		.step		= 1,
+		.default_value	= 0,
+	}, {
+		.id		= V4L2_CID_HFLIP,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Flip Horizontally",
+		.minimum	= 0,
+		.maximum	= 1,
+		.step		= 1,
+		.default_value	= 0,
+	},
+};
+
+/*
+ * General functions
+ */
+static struct ov2640_priv *to_ov2640(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov2640_priv,
+			    subdev);
+}
+
+static int ov2640_write_array(struct i2c_client *client,
+			      const struct regval_list *vals)
+{
+	int ret;
+
+	while ((vals->reg_num != 0xff) || (vals->value != 0xff)) {
+		ret = i2c_smbus_write_byte_data(client,
+						vals->reg_num, vals->value);
+		dev_vdbg(&client->dev, "array: 0x%02x, 0x%02x",
+			 vals->reg_num, vals->value);
+
+		if (ret < 0)
+			return ret;
+		vals++;
+	}
+	return 0;
+}
+
+static int ov2640_mask_set(struct i2c_client *client,
+			   u8  reg, u8  mask, u8  set)
+{
+	s32 val = i2c_smbus_read_byte_data(client, reg);
+	if (val < 0)
+		return val;
+
+	val &= ~mask;
+	val |= set & mask;
+
+	dev_vdbg(&client->dev, "masks: 0x%02x, 0x%02x", reg, val);
+
+	return i2c_smbus_write_byte_data(client, reg, val);
+}
+
+static int ov2640_reset(struct i2c_client *client)
+{
+	int ret;
+	const struct regval_list reset_seq[] = {
+		{BANK_SEL, BANK_SEL_SENS},
+		{COM7, COM7_SRST},
+		ENDMARKER,
+	};
+
+	ret = ov2640_write_array(client, reset_seq);
+	if (ret)
+		goto err;
+
+	msleep(5);
+err:
+	dev_dbg(&client->dev, "%s: (ret %d)", __func__, ret);
+	return ret;
+}
+
+/*
+ * soc_camera_ops functions
+ */
+static int ov2640_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov2640_set_bus_param(struct soc_camera_device *icd,
+				unsigned long flags)
+{
+	struct soc_camera_link *icl = to_soc_camera_link(icd);
+	unsigned long width_flag = flags & SOCAM_DATAWIDTH_MASK;
+
+	/* Only one width bit may be set */
+	if (!is_power_of_2(width_flag))
+		return -EINVAL;
+
+	if (icl->set_bus_param)
+		return icl->set_bus_param(icl, width_flag);
+
+	/*
+	 * Without board specific bus width settings we support only the
+	 * sensors native bus width witch are tested working
+	 */
+	if (width_flag & (SOCAM_DATAWIDTH_10 | SOCAM_DATAWIDTH_8))
+		return 0;
+
+	return 0;
+}
+
+static unsigned long ov2640_query_bus_param(struct soc_camera_device *icd)
+{
+	struct soc_camera_link *icl = to_soc_camera_link(icd);
+	unsigned long flags = SOCAM_PCLK_SAMPLE_RISING | SOCAM_MASTER |
+		SOCAM_VSYNC_ACTIVE_HIGH | SOCAM_HSYNC_ACTIVE_HIGH |
+		SOCAM_DATA_ACTIVE_HIGH;
+
+	if (icl->query_bus_param)
+		flags |= icl->query_bus_param(icl) & SOCAM_DATAWIDTH_MASK;
+	else
+		flags |= SOCAM_DATAWIDTH_10;
+
+	return soc_camera_apply_sensor_flags(icl, flags);
+}
+
+static int ov2640_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct i2c_client  *client = v4l2_get_subdevdata(sd);
+	struct ov2640_priv *priv = to_ov2640(client);
+
+	switch (ctrl->id) {
+	case V4L2_CID_VFLIP:
+		ctrl->value = priv->flag_vflip;
+		break;
+	case V4L2_CID_HFLIP:
+		ctrl->value = priv->flag_hflip;
+		break;
+	}
+	return 0;
+}
+
+static int ov2640_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct i2c_client  *client = v4l2_get_subdevdata(sd);
+	struct ov2640_priv *priv = to_ov2640(client);
+	int ret = 0;
+	u8 val;
+
+	switch (ctrl->id) {
+	case V4L2_CID_VFLIP:
+		val = ctrl->value ? REG04_VFLIP_IMG : 0x00;
+		priv->flag_vflip = ctrl->value ? 1 : 0;
+		ret = ov2640_mask_set(client, REG04, REG04_VFLIP_IMG, val);
+		break;
+	case V4L2_CID_HFLIP:
+		val = ctrl->value ? REG04_HFLIP_IMG : 0x00;
+		priv->flag_hflip = ctrl->value ? 1 : 0;
+		ret = ov2640_mask_set(client, REG04, REG04_HFLIP_IMG, val);
+		break;
+	}
+
+	return ret;
+}
+
+static int ov2640_g_chip_ident(struct v4l2_subdev *sd,
+			       struct v4l2_dbg_chip_ident *id)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2640_priv *priv = to_ov2640(client);
+
+	id->ident    = priv->model;
+	id->revision = 0;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov2640_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	reg->size = 1;
+	if (reg->reg > 0xff)
+		return -EINVAL;
+
+	ret = i2c_smbus_read_byte_data(client, reg->reg);
+	if (ret < 0)
+		return ret;
+
+	reg->val = ret;
+
+	return 0;
+}
+
+static int ov2640_s_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (reg->reg > 0xff ||
+	    reg->val > 0xff)
+		return -EINVAL;
+
+	return i2c_smbus_write_byte_data(client, reg->reg, reg->val);
+}
+#endif
+
+/* Select the nearest higher resolution for capture */
+static const struct ov2640_win_size *ov2640_select_win(u32 *width, u32 *height)
+{
+	int i, default_size = ARRAY_SIZE(ov2640_supported_win_sizes) - 1;
+
+	for (i = 0; i < ARRAY_SIZE(ov2640_supported_win_sizes); i++) {
+		if (ov2640_supported_win_sizes[i].width  >= *width &&
+		    ov2640_supported_win_sizes[i].height >= *height) {
+			*width = ov2640_supported_win_sizes[i].width;
+			*height = ov2640_supported_win_sizes[i].height;
+			return &ov2640_supported_win_sizes[i];
+		}
+	}
+
+	*width = ov2640_supported_win_sizes[default_size].width;
+	*height = ov2640_supported_win_sizes[default_size].height;
+	return &ov2640_supported_win_sizes[default_size];
+}
+
+static int ov2640_set_params(struct i2c_client *client, u32 *width, u32 *height,
+			     enum v4l2_mbus_pixelcode code)
+{
+	struct ov2640_priv       *priv = to_ov2640(client);
+	const struct regval_list *selected_cfmt_regs;
+	int ret;
+
+	/* select win */
+	priv->win = ov2640_select_win(width, height);
+
+	/* select format */
+	priv->cfmt_code = 0;
+	switch (code) {
+	case V4L2_MBUS_FMT_RGB565_2X8_LE:
+		dev_dbg(&client->dev, "%s: Selected cfmt RGB565", __func__);
+		selected_cfmt_regs = ov2640_rgb565_regs;
+		break;
+	default:
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		dev_dbg(&client->dev, "%s: Selected cfmt YUV422", __func__);
+		selected_cfmt_regs = ov2640_yuv422_regs;
+	}
+
+	/* reset hardware */
+	ov2640_reset(client);
+
+	/* initialize the sensor with default data */
+	dev_dbg(&client->dev, "%s: Init default", __func__);
+	ret = ov2640_write_array(client, ov2640_init_regs);
+	if (ret < 0)
+		goto err;
+
+	/* select preamble */
+	dev_dbg(&client->dev, "%s: Set size to %s", __func__, priv->win->name);
+	ret = ov2640_write_array(client, ov2640_size_change_preamble_regs);
+	if (ret < 0)
+		goto err;
+
+	/* set size win */
+	ret = ov2640_write_array(client, priv->win->regs);
+	if (ret < 0)
+		goto err;
+
+	/* cfmt preamble */
+	dev_dbg(&client->dev, "%s: Set cfmt", __func__);
+	ret = ov2640_write_array(client, ov2640_format_change_preamble_regs);
+	if (ret < 0)
+		goto err;
+
+	/* set cfmt */
+	ret = ov2640_write_array(client, selected_cfmt_regs);
+	if (ret < 0)
+		goto err;
+
+	priv->cfmt_code = code;
+	*width = priv->win->width;
+	*height = priv->win->height;
+
+	return 0;
+
+err:
+	dev_err(&client->dev, "%s: Error %d", __func__, ret);
+	ov2640_reset(client);
+	priv->win = NULL;
+
+	return ret;
+}
+
+static int ov2640_g_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *mf)
+{
+	struct i2c_client  *client = v4l2_get_subdevdata(sd);
+	struct ov2640_priv *priv = to_ov2640(client);
+
+	if (!priv->win) {
+		u32 width = W_SVGA, height = H_SVGA;
+		int ret = ov2640_set_params(client, &width, &height,
+					    V4L2_MBUS_FMT_UYVY8_2X8);
+		if (ret < 0)
+			return ret;
+	}
+
+	mf->width	= priv->win->width;
+	mf->height	= priv->win->height;
+	mf->code	= priv->cfmt_code;
+
+	switch (mf->code) {
+	case V4L2_MBUS_FMT_RGB565_2X8_LE:
+		mf->colorspace = V4L2_COLORSPACE_SRGB;
+		break;
+	default:
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		mf->colorspace = V4L2_COLORSPACE_JPEG;
+	}
+	mf->field	= V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov2640_s_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *mf)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+
+	switch (mf->code) {
+	case V4L2_MBUS_FMT_RGB565_2X8_LE:
+		mf->colorspace = V4L2_COLORSPACE_SRGB;
+		break;
+	default:
+		mf->code = V4L2_MBUS_FMT_UYVY8_2X8;
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		mf->colorspace = V4L2_COLORSPACE_JPEG;
+	}
+
+	ret = ov2640_set_params(client, &mf->width, &mf->height, mf->code);
+
+	return ret;
+}
+
+static int ov2640_try_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_mbus_framefmt *mf)
+{
+	const struct ov2640_win_size *win;
+
+	/*
+	 * select suitable win
+	 */
+	win = ov2640_select_win(&mf->width, &mf->height);
+
+	mf->field	= V4L2_FIELD_NONE;
+
+	switch (mf->code) {
+	case V4L2_MBUS_FMT_RGB565_2X8_LE:
+		mf->colorspace = V4L2_COLORSPACE_SRGB;
+		break;
+	default:
+		mf->code = V4L2_MBUS_FMT_UYVY8_2X8;
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+		mf->colorspace = V4L2_COLORSPACE_JPEG;
+	}
+
+	return 0;
+}
+
+static int ov2640_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			   enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(ov2640_codes))
+		return -EINVAL;
+
+	*code = ov2640_codes[index];
+	return 0;
+}
+
+static int ov2640_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
+{
+	a->c.left	= 0;
+	a->c.top	= 0;
+	a->c.width	= W_UXGA;
+	a->c.height	= H_UXGA;
+	a->type		= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	return 0;
+}
+
+static int ov2640_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)
+{
+	a->bounds.left			= 0;
+	a->bounds.top			= 0;
+	a->bounds.width			= W_UXGA;
+	a->bounds.height		= H_UXGA;
+	a->defrect			= a->bounds;
+	a->type				= V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	a->pixelaspect.numerator	= 1;
+	a->pixelaspect.denominator	= 1;
+
+	return 0;
+}
+
+static int ov2640_video_probe(struct soc_camera_device *icd,
+			      struct i2c_client *client)
+{
+	struct ov2640_priv *priv = to_ov2640(client);
+	u8 pid, ver, midh, midl;
+	const char *devname;
+	int ret;
+
+	/*
+	 * we must have a parent by now. And it cannot be a wrong one.
+	 * So this entire test is completely redundant.
+	 */
+	if (!icd->dev.parent ||
+	    to_soc_camera_host(icd->dev.parent)->nr != icd->iface) {
+		dev_err(&client->dev, "Parent missing or invalid!\n");
+		ret = -ENODEV;
+		goto err;
+	}
+
+	/*
+	 * check and show product ID and manufacturer ID
+	 */
+	i2c_smbus_write_byte_data(client, BANK_SEL, BANK_SEL_SENS);
+	pid  = i2c_smbus_read_byte_data(client, PID);
+	ver  = i2c_smbus_read_byte_data(client, VER);
+	midh = i2c_smbus_read_byte_data(client, MIDH);
+	midl = i2c_smbus_read_byte_data(client, MIDL);
+
+	switch (VERSION(pid, ver)) {
+	case PID_OV2640:
+		devname     = "ov2640";
+		priv->model = V4L2_IDENT_OV2640;
+		break;
+	default:
+		dev_err(&client->dev,
+			"Product ID error %x:%x\n", pid, ver);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	dev_info(&client->dev,
+		 "%s Product ID %0x:%0x Manufacturer ID %x:%x\n",
+		 devname, pid, ver, midh, midl);
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static struct soc_camera_ops ov2640_ops = {
+	.set_bus_param		= ov2640_set_bus_param,
+	.query_bus_param	= ov2640_query_bus_param,
+	.controls		= ov2640_controls,
+	.num_controls		= ARRAY_SIZE(ov2640_controls),
+};
+
+static struct v4l2_subdev_core_ops ov2640_subdev_core_ops = {
+	.g_ctrl		= ov2640_g_ctrl,
+	.s_ctrl		= ov2640_s_ctrl,
+	.g_chip_ident	= ov2640_g_chip_ident,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= ov2640_g_register,
+	.s_register	= ov2640_s_register,
+#endif
+};
+
+static struct v4l2_subdev_video_ops ov2640_subdev_video_ops = {
+	.s_stream	= ov2640_s_stream,
+	.g_mbus_fmt	= ov2640_g_fmt,
+	.s_mbus_fmt	= ov2640_s_fmt,
+	.try_mbus_fmt	= ov2640_try_fmt,
+	.cropcap	= ov2640_cropcap,
+	.g_crop		= ov2640_g_crop,
+	.enum_mbus_fmt	= ov2640_enum_fmt,
+};
+
+static struct v4l2_subdev_ops ov2640_subdev_ops = {
+	.core	= &ov2640_subdev_core_ops,
+	.video	= &ov2640_subdev_video_ops,
+};
+
+/*
+ * i2c_driver functions
+ */
+static int ov2640_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{
+	struct ov2640_priv        *priv;
+	struct soc_camera_device  *icd = client->dev.platform_data;
+	struct i2c_adapter        *adapter = to_i2c_adapter(client->dev.parent);
+	struct soc_camera_link    *icl;
+	int                        ret;
+
+	if (!icd) {
+		dev_err(&adapter->dev, "OV2640: missing soc-camera data!\n");
+		return -EINVAL;
+	}
+
+	icl = to_soc_camera_link(icd);
+	if (!icl) {
+		dev_err(&adapter->dev,
+			"OV2640: Missing platform_data for driver\n");
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&adapter->dev,
+			"OV2640: I2C-Adapter doesn't support SMBUS\n");
+		return -EIO;
+	}
+
+	priv = kzalloc(sizeof(struct ov2640_priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&adapter->dev,
+			"Failed to allocate memory for private data!\n");
+		return -ENOMEM;
+	}
+
+	priv->info = icl->priv;
+
+	v4l2_i2c_subdev_init(&priv->subdev, client, &ov2640_subdev_ops);
+
+	icd->ops = &ov2640_ops;
+
+	ret = ov2640_video_probe(icd, client);
+	if (ret) {
+		icd->ops = NULL;
+		kfree(priv);
+	} else {
+		dev_info(&adapter->dev, "OV2640 Probed\n");
+	}
+
+	return ret;
+}
+
+static int ov2640_remove(struct i2c_client *client)
+{
+	struct ov2640_priv       *priv = to_ov2640(client);
+	struct soc_camera_device *icd = client->dev.platform_data;
+
+	icd->ops = NULL;
+	kfree(priv);
+	return 0;
+}
+
+static const struct i2c_device_id ov2640_id[] = {
+	{ "ov2640", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2640_id);
+
+static struct i2c_driver ov2640_i2c_driver = {
+	.driver = {
+		.name = "ov2640",
+	},
+	.probe    = ov2640_probe,
+	.remove   = ov2640_remove,
+	.id_table = ov2640_id,
+};
+
+/*
+ * Module functions
+ */
+static int __init ov2640_module_init(void)
+{
+	return i2c_add_driver(&ov2640_i2c_driver);
+}
+
+static void __exit ov2640_module_exit(void)
+{
+	i2c_del_driver(&ov2640_i2c_driver);
+}
+
+module_init(ov2640_module_init);
+module_exit(ov2640_module_exit);
+
+MODULE_DESCRIPTION("SoC Camera driver for Omni Vision 2640 sensor");
+MODULE_AUTHOR("Alberto Panizzo");
+MODULE_LICENSE("GPL v2");
+=======
 #include <linux/videodev2.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
@@ -9,8 +1222,8 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -33,7 +1246,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV2640
+#define SENSOR_NAME RK29_CAM_SENSOR_OV2640
 #define SENSOR_V4L2_IDENT V4L2_IDENT_OV2640
 #define SENSOR_ID 0x2642
 #define SENSOR_ID1 0x2641
@@ -41,11 +1254,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_MIN_HEIGHT   480
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	0
 #define CONFIG_SENSOR_Brightness	1
@@ -65,6 +1277,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -83,13 +1299,6 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
 /* init 800*600 SVGA */
 static struct reginfo sensor_init_data[] =
 {
@@ -1332,8 +2541,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1512,7 +2721,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1525,13 +2734,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1565,62 +2774,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret,pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1669,7 +2824,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2835,25 +3990,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
@@ -3014,4 +4169,4 @@ MODULE_AUTHOR("ddl <kernel@rock-chips>");
 MODULE_LICENSE("GPL");
 
 
-
+>>>>>>> parent of 15f7fab... temp revert rk change
diff --git a/drivers/media/video/ov2640_rk.c b/drivers/media/video/ov2640_rk.c
index ad7f114802af..d6b1e385668a 100755
--- a/drivers/media/video/ov2640_rk.c
+++ b/drivers/media/video/ov2640_rk.c
@@ -1,2956 +1,2956 @@
 #include <linux/videodev2.h>
-#include <linux/slab.h>
-#include <linux/i2c.h>
-#include <linux/log2.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/circ_buf.h>
-#include <linux/miscdevice.h>
-#include <media/v4l2-common.h>
-#include <media/v4l2-chip-ident.h>
-#include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-
-static int debug;
-module_param(debug, int, S_IRUGO|S_IWUSR);
-
-#define dprintk(level, fmt, arg...) do {			\
-	if (debug >= level) 					\
-	printk(KERN_WARNING fmt , ## arg); } while (0)
-
-#define SENSOR_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
-#define SENSOR_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)
-
-
-#define _CONS(a,b) a##b
-#define CONS(a,b) _CONS(a,b)
-
-#define __STR(x) #x
-#define _STR(x) __STR(x)
-#define STR(x) _STR(x)
-
-#define MIN(x,y)   ((x<y) ? x: y)
-#define MAX(x,y)    ((x>y) ? x: y)
-
-/* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV2640
-#define SENSOR_V4L2_IDENT V4L2_IDENT_OV2640
-#define SENSOR_ID 0x2642
-#define SENSOR_ID1 0x2641
-#define SENSOR_MIN_WIDTH    640
-#define SENSOR_MIN_HEIGHT   480
-#define SENSOR_MAX_WIDTH    1600
-#define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  480
-#define SENSOR_INIT_WINSEQADR sensor_vga
-#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
-
-#define CONFIG_SENSOR_WhiteBalance	0
-#define CONFIG_SENSOR_Brightness	1
-#define CONFIG_SENSOR_Contrast      0
-#define CONFIG_SENSOR_Saturation    1
-#define CONFIG_SENSOR_Effect        1
-#define CONFIG_SENSOR_Scene         0
-#define CONFIG_SENSOR_DigitalZoom   0
-#define CONFIG_SENSOR_Focus         0
-#define CONFIG_SENSOR_Exposure      0
-#define CONFIG_SENSOR_Flash         0
-#define CONFIG_SENSOR_Mirror        0
-#define CONFIG_SENSOR_Flip          0
-
-#define CONFIG_SENSOR_I2C_SPEED     250000       /* Hz */
-/* Sensor write register continues by preempt_disable/preempt_enable for current process not be scheduled */
-#define CONFIG_SENSOR_I2C_NOSCHED   0
-#define CONFIG_SENSOR_I2C_RDWRCHK   0
-
-#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
-                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
-                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
-
-#define COLOR_TEMPERATURE_CLOUDY_DN  6500
-#define COLOR_TEMPERATURE_CLOUDY_UP    8000
-#define COLOR_TEMPERATURE_CLEARDAY_DN  5000
-#define COLOR_TEMPERATURE_CLEARDAY_UP    6500
-#define COLOR_TEMPERATURE_OFFICE_DN     3500
-#define COLOR_TEMPERATURE_OFFICE_UP     5000
-#define COLOR_TEMPERATURE_HOME_DN       2500
-#define COLOR_TEMPERATURE_HOME_UP       3500
-
-#define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
-#define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)
-
-struct reginfo
-{
-    u8 reg;
-    u8 val;
-};
-
-/* init 800*600 SVGA */
-static struct reginfo sensor_init_data[] =
-{
-#if 1
-    {0xff,0x01},
-    {0x12,0x80},
-    {0xff,0x00},
-    {0x2c,0xff},
-    {0x2e,0xdf},
-    {0xff,0x01},
-
-    {0x03,0x4f},
-    {0x0f,0x4b},
-
-
-    {0x3c,0x32},
-    {0x11,0x00},
-    {0x09,0x02},
-    {0x04,0xF8},//b7,b6 directs
-    {0x13,0xe5},
-    {0x14,0x48},
-    {0x2c,0x0c},
-    {0x33,0x78},
-    {0x3a,0x33},
-    {0x3b,0xfB},
-    {0x3e,0x00},
-    {0x43,0x11},
-    {0x16,0x10},
-    {0x39,0x02},
-    {0x35,0x88},
-    {0x22,0x09},
-    {0x37,0x40},
-    {0x23,0x00},
-    {0x34,0xa0},
-    {0x36,0x1a},
-    {0x06,0x02},
-    {0x07,0xc0},
-    {0x0d,0xb7},
-    {0x0e,0x01},
-    {0x4c,0x00},
-    {0x4a,0x81},
-    {0x21,0x99},
-    
-    //{0x24,0x58},
-    //{0x25,0x50},
-    //{0x26,0x92},
-    
-    {0x24, 0x70},
-    {0x25, 0x60},
-    {0x26, 0xa4},    
-    
-    {0x5c,0x00},
-    {0x63,0x00},
-    {0x46,0x3f},
-    {0x0c,0x3c},
-    {0x61,0x70},
-    {0x62,0x80},
-    {0x7c,0x05},
-    {0x20,0x80},
-    {0x28,0x30},
-    {0x6c,0x00},
-    {0x6d,0x80},
-    {0x6e,0x00},
-    {0x70,0x02},
-    {0x71,0x94},
-    {0x73,0xc1},
-    {0x3d,0x34},
-    {0x5a,0x57},
-    {0x4f,0xbb},
-    {0x50,0x9c},
-    {0xff,0x00},
-    {0xe5,0x7f},
-    {0xf9,0xc0},
-    {0x41,0x24},
-    {0xe0,0x14},
-    {0x76,0xff},
-    {0x33,0xa0},
-    {0x42,0x20},
-    {0x43,0x18},
-    {0x4c,0x00},
-    {0x87,0xd0},
-    {0x88,0x3f},
-    {0xd7,0x03},
-    {0xd9,0x10},
-    {0xd3,0x82},
-    {0xc8,0x08},
-    {0xc9,0x80},
-    {0x7c,0x00},
-    {0x7d,0x00},//0x00//0x07
-    {0x7c,0x03},
-    {0x7d,0x48},//0x48//0x40
-    {0x7d,0x48},//0x48//0x40
-    {0x7c,0x08},
-    {0x7d,0x20},
-    {0x7d,0x10},//0x10
-    {0x7d,0x0e},//0x0e
-
-    {0x92,0x00},
-    {0x93,0x06},
-    {0x93,0xc8},//e3
-    {0x93,0x05},
-    {0x93,0x05},
-    {0x93,0x00},
-    {0x93,0x04},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x93,0x00},
-    {0x96,0x00},
-    {0x97,0x08},
-    {0x97,0x19},
-    {0x97,0x02},
-    {0x97,0x0c},
-    {0x97,0x24},
-    {0x97,0x30},
-    {0x97,0x28},
-    {0x97,0x26},
-    {0x97,0x02},
-    {0x97,0x98},
-    {0x97,0x80},
-    {0x97,0x00},
-    {0x97,0x00},
-    {0xc3,0xef},//ed
-    {0xa4,0x00},
-    {0xa8,0x00},
-
-    {0xbf, 0x00},
-    {0xba, 0xdc},
-    {0xbb, 0x08},
-    {0xb6, 0x20},
-    {0xb8, 0x30},
-    {0xb7, 0x20},
-    {0xb9, 0x30},
-    {0xb3, 0xb4},
-    {0xb4, 0xca},
-    {0xb5, 0x34},
-    {0xb0, 0x46},
-    {0xb1, 0x46},
-    {0xb2, 0x06},
-    {0xc7, 0x00},
-    {0xc6, 0x51},
-    {0xc5, 0x11},
-    {0xc4, 0x9c},
-////
-    {0xc0,0xc8},
-    {0xc1,0x96},
-    {0x86,0x3d},
-    {0x50,0x92},
-    {0x51,0x90},
-    {0x52,0x2c},
-    {0x53,0x00},
-    {0x54,0x00},
-    {0x55,0x88},
-    {0x57,0x00},
-    {0x5a,0x50},
-    {0x5b,0x3c},
-    {0x5c,0x00},
-    {0xc3,0xed},
-    {0x7f,0x00},
-    {0xda,0x01},
-    {0xe5,0x1f},
-    {0xe1,0x67},
-    {0xe0,0x00},
-    {0xdd,0xff},
-    {0x05,0x00},
-
-#endif
-#if 1
-    {0xff, 0x01},
-    {0x5d, 0x00},
-    {0x5e, 0x3c},
-    {0x5f, 0x28},
-    {0x60, 0x55},
-
-
-    {0xff, 0x00},
-    {0xc3, 0xef},
-    {0xa6, 0x00},
-    {0xa7, 0x0f},
-    {0xa7, 0x4e},
-    {0xa7, 0x7a},
-    {0xa7, 0x33},
-    {0xa7, 0x00},
-    {0xa7, 0x23},
-    {0xa7, 0x27},
-    {0xa7, 0x3a},
-    {0xa7, 0x70},
-    {0xa7, 0x33},
-    {0xa7, 0x00},//L
-    {0xa7, 0x23},
-    {0xa7, 0x20},
-    {0xa7, 0x0c},
-    {0xa7, 0x66},
-    {0xa7, 0x33},
-    {0xa7, 0x00},
-    {0xa7, 0x23},
-    {0xc3, 0xef},
-#endif
-
-
-#if 1
-    {0xff,0x00},
-    {0x92,0x00},
-    {0x93,0x06},
-    {0x93,0xc1},//e
-    {0x93,0x02},
-    {0x93,0x02},
-    {0x93,0x00},
-    {0x93,0x04},
-#endif
-
-    {0x03, 0x0f},
-    {0xe0, 0x04},
-    {0xc0, 0xc8},
-    {0xc1, 0x96},
-    {0x86, 0x3d},
-    {0x50, 0x89},
-    {0x51, 0x90},
-    {0x52, 0x2c},
-    {0x53, 0x00},
-    {0x54, 0x00},
-    {0x55, 0x88},
-    {0x57, 0x00},
-    {0x5a, 0xa0},
-    {0x5b, 0x78},
-    {0x5c, 0x00},
-    {0xd3, 0x04},
-    {0xe0, 0x00},
-
-  {0x0, 0x0}   //end flag
-
-};
-
-/* 1600X1200 UXGA */
-static struct reginfo sensor_uxga[] =
-{
-    {0xff, 0x00},
-    {0xe0, 0x04},
-    {0xc0, 0xc8},
-    {0xc1, 0x96},
-    {0x86, 0x3d},
-    {0x50, 0x00},
-    {0x51, 0x90},
-    {0x52, 0x2c},
-    {0x53, 0x00},
-    {0x54, 0x00},
-    {0x55, 0x88},
-    {0x57, 0x00},
-    {0x5a, 0x90},
-    {0x5b, 0x2c},
-    {0x5c, 0x05},
-    {0xd3, 0x82},
-    {0xe0, 0x00},
-  {0x0, 0x0}   //end flag
-};
-
-/* 1280X1024 SXGA */
-static struct reginfo sensor_sxga[] =
-{
-    {0xff, 0x00},
-    {0xe0, 0x04},
-    {0xc0, 0xc8},
-    {0xc1, 0x96},
-    {0x86, 0x3d},
-    {0x50, 0x00},
-    {0x51, 0x90},
-    {0x52, 0x2c},
-    {0x53, 0x00},
-    {0x54, 0x00},
-    {0x55, 0x88},
-    {0x57, 0x00},
-    {0x5a, 0x40},
-    {0x5b, 0x00},
-    {0x5c, 0x05},
-    {0xd3, 0x82},
-    {0xe0, 0x00},
-  {0x0, 0x0}   //end flag
-};
-
-
-static struct reginfo sensor_xga[] =
-{
-    {0xff, 0x00},
-    {0xe0, 0x04},
-    {0xc0, 0xc8},
-    {0xc1, 0x96},
-    {0x86, 0x3d},
-    {0x50, 0x00},
-    {0x51, 0x90},
-    {0x52, 0x2c},
-    {0x53, 0x00},
-    {0x54, 0x00},
-    {0x55, 0x88},
-    {0x57, 0x00},
-    {0x5a, 0x40},
-    {0x5b, 0x00},
-    {0x5c, 0x05},
-    {0xd3, 0x82},
-    {0xe0, 0x00},
-  {0x0, 0x0}   //end flag
-
-
-};
-
-
-/* 800X600 SVGA*/
-static struct reginfo sensor_svga[] =
-{
-  {0x0, 0x0}   //end flag
-};
-
-/* 640X480 VGA */
-static struct reginfo sensor_vga[] =
-{
-   {0x0, 0x0}   //end flag
- };
-
-/* 352X288 CIF */
-static struct reginfo sensor_cif[] =
-{
-  {0x0, 0x0}   //end flag
-};
-
-/* 320*240 QVGA */
-static  struct reginfo sensor_qvga[] =
-{
-  {0x0, 0x0}   //end flag
-};
-
-/* 176X144 QCIF*/
-static struct reginfo sensor_qcif[] =
-{
-  {0x0, 0x0}   //end flag
-};
-#if 0
-/* 160X120 QQVGA*/
-static struct reginfo ov2655_qqvga[] =
-{
-
-    {0x300E, 0x34},
-    {0x3011, 0x01},
-    {0x3012, 0x10},
-    {0x302a, 0x02},
-    {0x302b, 0xE6},
-    {0x306f, 0x14},
-    {0x3362, 0x90},
-
-    {0x3070, 0x5d},
-    {0x3072, 0x5d},
-    {0x301c, 0x07},
-    {0x301d, 0x07},
-
-    {0x3020, 0x01},
-    {0x3021, 0x18},
-    {0x3022, 0x00},
-    {0x3023, 0x06},
-    {0x3024, 0x06},
-    {0x3025, 0x58},
-    {0x3026, 0x02},
-    {0x3027, 0x61},
-    {0x3088, 0x00},
-    {0x3089, 0xa0},
-    {0x308a, 0x00},
-    {0x308b, 0x78},
-    {0x3316, 0x64},
-    {0x3317, 0x25},
-    {0x3318, 0x80},
-    {0x3319, 0x08},
-    {0x331a, 0x0a},
-    {0x331b, 0x07},
-    {0x331c, 0x80},
-    {0x331d, 0x38},
-    {0x3100, 0x00},
-    {0x3302, 0x11},
-
-    {0x0, 0x0},
-};
-
-
-
-static  struct reginfo ov2655_Sharpness_auto[] =
-{
-    {0x3306, 0x00},
-};
-
-static  struct reginfo ov2655_Sharpness1[] =
-{
-    {0x3306, 0x08},
-    {0x3371, 0x00},
-};
-
-static  struct reginfo ov2655_Sharpness2[][3] =
-{
-    //Sharpness 2
-    {0x3306, 0x08},
-    {0x3371, 0x01},
-};
-
-static  struct reginfo ov2655_Sharpness3[] =
-{
-    //default
-    {0x3306, 0x08},
-    {0x332d, 0x02},
-};
-static  struct reginfo ov2655_Sharpness4[]=
-{
-    //Sharpness 4
-    {0x3306, 0x08},
-    {0x332d, 0x03},
-};
-
-static  struct reginfo ov2655_Sharpness5[] =
-{
-    //Sharpness 5
-    {0x3306, 0x08},
-    {0x332d, 0x04},
-};
-#endif
-
-static  struct reginfo sensor_ClrFmt_YUYV[]=
-{
-    //{0x4300, 0x30},
-    {0x00, 0x00}
-};
-
-static  struct reginfo sensor_ClrFmt_UYVY[]=
-{
-    //{0x4300, 0x32},
-    {0x00, 0x00}
-};
-
-#if CONFIG_SENSOR_WhiteBalance
-static  struct reginfo sensor_WhiteB_Auto[]=
-{
-    {0x3406, 0x00},  //AWB auto, bit[1]:0,auto
-    {0x0000, 0x00}
-};
-/* Cloudy Colour Temperature : 6500K - 8000K  */
-static  struct reginfo sensor_WhiteB_Cloudy[]=
-{
-    {0x3406, 0x01},
-    {0x3400, 0x07},
-    {0x3401, 0x08},
-    {0x3402, 0x04},
-    {0x3403, 0x00},
-    {0x3404, 0x05},
-    {0x3405, 0x00},
-    {0x0000, 0x00}
-};
-/* ClearDay Colour Temperature : 5000K - 6500K  */
-static  struct reginfo sensor_WhiteB_ClearDay[]=
-{
-    //Sunny
-    {0x3406, 0x01},
-    {0x3400, 0x07},
-    {0x3401, 0x02},
-    {0x3402, 0x04},
-    {0x3403, 0x00},
-    {0x3404, 0x05},
-    {0x3405, 0x15},
-    {0x0000, 0x00}
-};
-/* Office Colour Temperature : 3500K - 5000K  */
-static  struct reginfo sensor_WhiteB_TungstenLamp1[]=
-{
-    //Office
-    {0x3406, 0x01},
-    {0x3400, 0x06},
-    {0x3401, 0x2a},
-    {0x3402, 0x04},
-    {0x3403, 0x00},
-    {0x3404, 0x07},
-    {0x3405, 0x24},
-    {0x0000, 0x00}
-
-};
-/* Home Colour Temperature : 2500K - 3500K  */
-static  struct reginfo sensor_WhiteB_TungstenLamp2[]=
-{
-    //Home
-    {0x3406, 0x01},
-    {0x3400, 0x04},
-    {0x3401, 0x58},
-    {0x3402, 0x04},
-    {0x3403, 0x00},
-    {0x3404, 0x07},
-    {0x3405, 0x24},
-    {0x0000, 0x00}
-};
-static struct reginfo *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,
-    sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,
-};
-#endif
-
-#if CONFIG_SENSOR_Brightness
-static  struct reginfo sensor_Brightness0[]=
-{
-    // Brightness -2
-    {0xff, 0x01},
-    {0x24, 0x34},
-    {0x25, 0x22},
-    {0x26, 0x70},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness1[]=
-{
-    // Brightness -1
-
-    {0xff, 0x01},
-    {0x24, 0x58},
-    {0x25, 0x50},
-    {0x26, 0x92},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness2[]=
-{
-    //  Brightness 0
-
-	{0xff, 0x01},
-	{0x24, 0xa8},
-	{0x25, 0x90},
-	{0x26, 0xd6},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness3[]=
-{
-    // Brightness +1
-
-    {0xff, 0x01},
-    {0x24, 0x48},
-    {0x25, 0x40},
-    {0x26, 0x81},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness4[]=
-{
-    //  Brightness +2
-
-    {0xff, 0x01},
-    {0x24, 0x58},
-    {0x25, 0x50},
-    {0x26, 0x92},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Brightness5[]=
-{
-    //  Brightness +3
-    {0xff, 0x01},
-    {0x24, 0x70},
-    {0x25, 0x60},
-    {0x26, 0xa4},
-  {0x0, 0x0}   //end flag
-};
-static struct reginfo *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,
-    sensor_Brightness4, sensor_Brightness5,NULL,
-};
-
-#endif
-
-#if CONFIG_SENSOR_Effect
-static  struct reginfo sensor_Effect_Normal[] =
-{
-	{0xff,0x00},
-	{0x7c,0x00},
-	{0x7d,0x00},
-	{0x7c,0x05},
-	{0x7d,0x80},
-	{0x7d,0x80},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_WandB[] =
-{
-    {0xff,0x00},
-    {0x7c,0x00},
-    {0x7d,0x18},
-    {0x7c,0x05},
-    {0x7d,0x80},
-    {0x7d,0x80},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_Sepia[] =
-{
-    {0xff,0x00},
-    {0x7c,0x00},
-    {0x7d,0x18},
-    {0x7c,0x05},
-    {0x7d,0x40},
-    {0x7d,0xc0},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_Negative[] =
-{
-    {0xff,0x00},
-    {0x7c,0x00},
-    {0x7d,0x40},
-    {0x7c,0x05},
-    {0x7d,0x80},
-    {0x7d,0x80},
-  {0x0, 0x0}   //end flag
-};
-static  struct reginfo sensor_Effect_Bluish[] =
-{
-    {0Xff, 0X00},
-    {0X7c, 0X00},
-    {0X7d, 0X18},
-    {0X7c, 0X05},
-    {0X7d, 0Xa0},
-    {0X7d, 0X40},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_Green[] =
-{
-    {0Xff, 0X00},
-    {0X7c, 0X00},
-    {0X7d, 0X18},
-    {0X7c, 0X05},
-    {0X7d, 0X40},
-    {0X7d, 0X40},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Effect_Exp_Windows_Half[] =
-{
-	{0xff, 0x01},
-	{0x5d, 0x00},
-	{0x5e, 0x3c},
-	{0x5f, 0x28},
-	{0x60, 0x55},
-  {0x0, 0x0}   //end flag
-};
-static struct reginfo *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_WandB, sensor_Effect_Negative,sensor_Effect_Sepia,
-    sensor_Effect_Bluish, sensor_Effect_Green,NULL,
-};
-#endif
-#if CONFIG_SENSOR_Exposure
-static  struct reginfo sensor_Exposure0[]=
-{
-	{0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure1[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure2[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure3[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure4[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure5[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_Exposure6[]=
-{
-    {0x0000, 0x00}
-};
-
-static struct reginfo *sensor_ExposureSeqe[] = {sensor_Exposure0, sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,
-    sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,NULL,
-};
-#endif
-#if CONFIG_SENSOR_Saturation
-static  struct reginfo sensor_Saturation0[]=
-{
-	{0xff, 0x00},
-	{0x90, 0x00},
-	{0x91, 0x0e},
-	{0x91, 0x1a},
-	{0x91, 0x31},
-	{0x91, 0x5a},
-	{0x91, 0x69},
-	{0x91, 0x75},
-	{0x91, 0x7e},
-	{0x91, 0x88},
-	{0x91, 0x8f},
-	{0x91, 0x96},
-	{0x91, 0xa3},
-	{0x91, 0xaf},
-	{0x91, 0xc4},
-	{0x91, 0xd7},
-	{0x91, 0xe8},
-	{0x91, 0x20},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Saturation1[]=
-{
-    {0xff, 0x00},
-    {0x90, 0x00},
-    {0x91, 0x03},
-    {0x91, 0x0a},
-    {0x91, 0x1a},
-    {0x91, 0x3f},
-    {0x91, 0x4e},
-    {0x91, 0x5b},
-    {0x91, 0x68},
-    {0x91, 0x75},
-    {0x91, 0x7f},
-    {0x91, 0x89},
-    {0x91, 0x9a},
-    {0x91, 0xa6},
-    {0x91, 0xbd},
-    {0x91, 0xd3},
-    {0x91, 0xe5},
-    {0x91, 0x24},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Saturation2[]=
-{
-    {0xff, 0x00},
-    {0x90, 0x00},
-    {0x91, 0x04},
-    {0x91, 0x07},
-    {0x91, 0x10},
-    {0x91, 0x28},
-    {0x91, 0x36},
-    {0x91, 0x44},
-    {0x91, 0x52},
-    {0x91, 0x60},
-    {0x91, 0x6c},
-    {0x91, 0x78},
-    {0x91, 0x8c},
-    {0x91, 0x9e},
-    {0x91, 0xbb},
-    {0x91, 0xd3},
-    {0x91, 0xe5},
-    {0x91, 0x24},
-  {0x0, 0x0}   //end flag	
-};
-static struct reginfo *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};
-
-
-#endif
-#if CONFIG_SENSOR_Contrast
-static  struct reginfo sensor_Contrast0[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x10},
-    {0x7d, 0x4a},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-
-};
-
-static  struct reginfo sensor_Contrast1[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x14},
-    {0x7d, 0x40},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast2[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x18},
-    {0x7d, 0x34},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast3[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x1c},
-    {0x7d, 0x2a},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast4[]=
-{
-    {0xff,0x00},
-    {0x7c,0x00},
-    {0x7d,0x04},
-    {0x7c,0x07},
-    {0x7d,0x20},
-    {0x7d,0x24},
-    {0x7d,0x16},
-    {0x7d,0x06},
-  {0x0, 0x0}   //end flag
-};
-
-
-static  struct reginfo sensor_Contrast5[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x20},
-    {0x7d, 0x20},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast6[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x24},
-    {0x7d, 0x16},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-
-static  struct reginfo sensor_Contrast7[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x28},
-    {0x7d, 0x0c},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast8[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x2c},
-    {0x7d, 0x02},
-    {0x7d, 0x06},
-  {0x0, 0x0}   //end flag
-};
-
-static  struct reginfo sensor_Contrast9[]=
-{
-    {0xff, 0x00},
-    {0x7c, 0x00},
-    {0x7d, 0x04},
-    {0x7c, 0x07},
-    {0x7d, 0x20},
-    {0x7d, 0x30},
-    {0x7d, 0x08},
-    {0x7d, 0x0e},
-  {0x0, 0x0}   //end flag
-};
-
-
-
-static struct reginfo *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,
-    sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,
-};
-
-#endif
-#if CONFIG_SENSOR_Mirror
-static  struct reginfo sensor_MirrorOn[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_MirrorOff[]=
-{
-    {0x0000, 0x00}
-};
-static struct reginfo *sensor_MirrorSeqe[] = {sensor_MirrorOff, sensor_MirrorOn,NULL,};
-#endif
-#if CONFIG_SENSOR_Flip
-static  struct reginfo sensor_FlipOn[]=
-{
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_FlipOff[]=
-{
-    {0x0000, 0x00}
-};
-static struct reginfo *sensor_FlipSeqe[] = {sensor_FlipOff, sensor_FlipOn,NULL,};
-
-#endif
-#if CONFIG_SENSOR_Scene
-static  struct reginfo sensor_SceneAuto[] =
-{
-    {0x3a00, 0x78},
-    {0x0000, 0x00}
-};
-
-static  struct reginfo sensor_SceneNight[] =
-{
-    {0x3003, 0x80},
-	{0x3004, 0x20},
-	{0x3005, 0x18},
-	{0x3006, 0x0d},
-	{0x3a00, 0x7c},
-	{0x3a02 ,0x07},
-	{0x3a03 ,0x38},
-	{0x3a14 ,0x07},
-	{0x3a15 ,0x38},
-    {0x0000, 0x00}
-};
-static struct reginfo *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight,NULL,};
-
-#endif
-#if CONFIG_SENSOR_DigitalZoom
-static struct reginfo sensor_Zoom0[] =
-{
-    {0x0, 0x0},
-};
-
-static struct reginfo sensor_Zoom1[] =
-{
-     {0x0, 0x0},
-};
-
-static struct reginfo sensor_Zoom2[] =
-{
-    {0x0, 0x0},
-};
-
-
-static struct reginfo sensor_Zoom3[] =
-{
-    {0x0, 0x0},
-};
-static struct reginfo *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL,};
-#endif
-static const struct v4l2_querymenu sensor_menus[] =
-{
-	#if CONFIG_SENSOR_WhiteBalance
-    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 0,  .name = "auto",  .reserved = 0, }, {  .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 1, .name = "incandescent",  .reserved = 0,},
-    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 2,  .name = "fluorescent", .reserved = 0,}, {  .id = V4L2_CID_DO_WHITE_BALANCE, .index = 3,  .name = "daylight", .reserved = 0,},
-    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 4,  .name = "cloudy-daylight", .reserved = 0,},
-    #endif
-
-	#if CONFIG_SENSOR_Effect
-    { .id = V4L2_CID_EFFECT,  .index = 0,  .name = "none",  .reserved = 0, }, {  .id = V4L2_CID_EFFECT,  .index = 1, .name = "mono",  .reserved = 0,},
-    { .id = V4L2_CID_EFFECT,  .index = 2,  .name = "negative", .reserved = 0,}, {  .id = V4L2_CID_EFFECT, .index = 3,  .name = "sepia", .reserved = 0,},
-    { .id = V4L2_CID_EFFECT,  .index = 4, .name = "posterize", .reserved = 0,} ,{ .id = V4L2_CID_EFFECT,  .index = 5,  .name = "aqua", .reserved = 0,},
-    #endif
-
-	#if CONFIG_SENSOR_Scene
-    { .id = V4L2_CID_SCENE,  .index = 0, .name = "auto", .reserved = 0,} ,{ .id = V4L2_CID_SCENE,  .index = 1,  .name = "night", .reserved = 0,},
-    #endif
-
-	#if CONFIG_SENSOR_Flash
-    { .id = V4L2_CID_FLASH,  .index = 0,  .name = "off",  .reserved = 0, }, {  .id = V4L2_CID_FLASH,  .index = 1, .name = "auto",  .reserved = 0,},
-    { .id = V4L2_CID_FLASH,  .index = 2,  .name = "on", .reserved = 0,}, {  .id = V4L2_CID_FLASH, .index = 3,  .name = "torch", .reserved = 0,},
-    #endif
-};
-
-static const struct v4l2_queryctrl sensor_controls[] =
-{
-	#if CONFIG_SENSOR_WhiteBalance
-    {
-        .id		= V4L2_CID_DO_WHITE_BALANCE,
-        .type		= V4L2_CTRL_TYPE_MENU,
-        .name		= "White Balance Control",
-        .minimum	= 0,
-        .maximum	= 4,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Brightness
-	{
-        .id		= V4L2_CID_BRIGHTNESS,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Brightness Control",
-        .minimum	= -3,
-        .maximum	= 2,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Effect
-	{
-        .id		= V4L2_CID_EFFECT,
-        .type		= V4L2_CTRL_TYPE_MENU,
-        .name		= "Effect Control",
-        .minimum	= 0,
-        .maximum	= 5,
-        .step		= 1,
-        .default_value = 0,
-    },
-	#endif
-
-	#if CONFIG_SENSOR_Exposure
-	{
-        .id		= V4L2_CID_EXPOSURE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Exposure Control",
-        .minimum	= 0,
-        .maximum	= 6,
-        .step		= 1,
-        .default_value = 0,
-    },
-	#endif
-
-	#if CONFIG_SENSOR_Saturation
-	{
-        .id		= V4L2_CID_SATURATION,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Saturation Control",
-        .minimum	= 0,
-        .maximum	= 2,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Contrast
-	{
-        .id		= V4L2_CID_CONTRAST,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Contrast Control",
-        .minimum	= -3,
-        .maximum	= 3,
-        .step		= 1,
-        .default_value = 0,
-    },
-	#endif
-
-	#if CONFIG_SENSOR_Mirror
-	{
-        .id		= V4L2_CID_HFLIP,
-        .type		= V4L2_CTRL_TYPE_BOOLEAN,
-        .name		= "Mirror Control",
-        .minimum	= 0,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 1,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Flip
-	{
-        .id		= V4L2_CID_VFLIP,
-        .type		= V4L2_CTRL_TYPE_BOOLEAN,
-        .name		= "Flip Control",
-        .minimum	= 0,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 1,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Scene
-    {
-        .id		= V4L2_CID_SCENE,
-        .type		= V4L2_CTRL_TYPE_MENU,
-        .name		= "Scene Control",
-        .minimum	= 0,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_DigitalZoom
-    {
-        .id		= V4L2_CID_ZOOM_RELATIVE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "DigitalZoom Control",
-        .minimum	= -1,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 0,
-    }, {
-        .id		= V4L2_CID_ZOOM_ABSOLUTE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "DigitalZoom Control",
-        .minimum	= 0,
-        .maximum	= 3,
-        .step		= 1,
-        .default_value = 0,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Focus
-	{
-        .id		= V4L2_CID_FOCUS_RELATIVE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Focus Control",
-        .minimum	= -1,
-        .maximum	= 1,
-        .step		= 1,
-        .default_value = 0,
-    }, {
-        .id		= V4L2_CID_FOCUS_ABSOLUTE,
-        .type		= V4L2_CTRL_TYPE_INTEGER,
-        .name		= "Focus Control",
-        .minimum	= 0,
-        .maximum	= 255,
-        .step		= 1,
-        .default_value = 125,
-    },
-    #endif
-
-	#if CONFIG_SENSOR_Flash
-	{
-        .id		= V4L2_CID_FLASH,
-        .type		= V4L2_CTRL_TYPE_MENU,
-        .name		= "Flash Control",
-        .minimum	= 0,
-        .maximum	= 3,
-        .step		= 1,
-        .default_value = 0,
-    },
-	#endif
-};
-
-static int sensor_probe(struct i2c_client *client, const struct i2c_device_id *did);
-static int sensor_video_probe(struct soc_camera_device *icd, struct i2c_client *client);
-static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
-static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
-static int sensor_g_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
-static int sensor_s_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
-static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);
-static int sensor_resume(struct soc_camera_device *icd);
-static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);
-static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);
-#if CONFIG_SENSOR_Effect
-static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
-#endif
-#if CONFIG_SENSOR_WhiteBalance
-static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
-#endif
-static int sensor_deactivate(struct i2c_client *client);
-
-static struct soc_camera_ops sensor_ops =
-{
-    .suspend                     = sensor_suspend,
-    .resume                       = sensor_resume,
-    .set_bus_param		= sensor_set_bus_param,
-    .query_bus_param	= sensor_query_bus_param,
-    .controls		= sensor_controls,
-    .menus                         = sensor_menus,
-    .num_controls		= ARRAY_SIZE(sensor_controls),
-    .num_menus		= ARRAY_SIZE(sensor_menus),
-};
-
-/* only one fixed colorspace per pixelcode */
-struct sensor_datafmt {
-	enum v4l2_mbus_pixelcode code;
-	enum v4l2_colorspace colorspace;
-};
-
-/* Find a data format by a pixel code in an array */
-static const struct sensor_datafmt *sensor_find_datafmt(
-	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
-	int n)
-{
-	int i;
-	for (i = 0; i < n; i++)
-		if (fmt[i].code == code)
-			return fmt + i;
-
-	return NULL;
-}
-
-static const struct sensor_datafmt sensor_colour_fmts[] = {
-    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
-    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
-};
-
-typedef struct sensor_info_priv_s
-{
-    int whiteBalance;
-    int brightness;
-    int contrast;
-    int saturation;
-    int effect;
-    int scene;
-    int digitalzoom;
-    int focus;
-    int flash;
-    int exposure;
-	bool snap2preview;
-	bool video2preview;
-    unsigned char mirror;                                        /* HFLIP */
-    unsigned char flip;                                          /* VFLIP */
-    unsigned int winseqe_cur_addr;
-    struct sensor_datafmt fmt;
-
-} sensor_info_priv_t;
-
-struct sensor
-{
-    struct v4l2_subdev subdev;
-    struct i2c_client *client;
-    sensor_info_priv_t info_priv;
-    int model;	/* V4L2_IDENT_OV* codes from v4l2-chip-ident.h */
-#if CONFIG_SENSOR_I2C_NOSCHED
-	atomic_t tasklock_cnt;
-#endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
-};
-
-static struct sensor* to_sensor(const struct i2c_client *client)
-{
-    return container_of(i2c_get_clientdata(client), struct sensor, subdev);
-}
-
-static int sensor_task_lock(struct i2c_client *client, int lock)
-{
-#if CONFIG_SENSOR_I2C_NOSCHED
-	int cnt = 3;
-    struct sensor *sensor = to_sensor(client);
-
-	if (lock) {
-		if (atomic_read(&sensor->tasklock_cnt) == 0) {
-			while ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt>0)) {
-				SENSOR_TR("\n %s will obtain i2c in atomic, but i2c bus is locked! Wait...\n",SENSOR_NAME_STRING());
-				msleep(35);
-				cnt--;
-			}
-			if ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt<=0)) {
-				SENSOR_TR("\n %s obtain i2c fail in atomic!!\n",SENSOR_NAME_STRING());
-				goto sensor_task_lock_err;
-			}
-			preempt_disable();
-		}
-
-		atomic_add(1, &sensor->tasklock_cnt);
-	} else {
-		if (atomic_read(&sensor->tasklock_cnt) > 0) {
-			atomic_sub(1, &sensor->tasklock_cnt);
-
-			if (atomic_read(&sensor->tasklock_cnt) == 0)
-				preempt_enable();
-		}
-	}
-	return 0;
-sensor_task_lock_err:
-	return -1;  
-#else
-    return 0;
-#endif
-
-}
-static int sensor_write(struct i2c_client *client, u8 reg, u8 val)
-{
-    int err,cnt;
-    u8 buf[2];
-    struct i2c_msg msg[1];
-
-    buf[0] = reg & 0xFF;
-    buf[1] = val;
-
-    msg->addr = client->addr;
-    msg->flags = client->flags;
-    msg->buf = buf;
-    msg->len = sizeof(buf);
-    msg->scl_rate = CONFIG_SENSOR_I2C_SPEED;                                        /* ddl@rock-chips.com : 100kHz */
-    msg->read_type = 0;               /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */
-
-    cnt = 3;
-    err = -EAGAIN;
-
-    while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
-        err = i2c_transfer(client->adapter, msg, 1);
-
-        if (err >= 0) {
-            return 0;
-        } else {
-            SENSOR_TR("\n %s write reg(0x%x, val:0x%x) failed, try to write again!\n",SENSOR_NAME_STRING(),reg, val);
-            udelay(10);
-        }
-    }
-
-    return err;
-}
-
-/* sensor register read */
-static int sensor_read(struct i2c_client *client, u8 reg, u8 *val)
-{
-    int err,cnt;
-    u8 buf[1];
-    struct i2c_msg msg[2];
-
-    buf[0] = reg ;//>> 8;
-   // buf[1] = 0;
-
-    msg[0].addr = client->addr;
-    msg[0].flags = client->flags;
-    msg[0].buf = buf;
-    msg[0].len = sizeof(buf);
-    msg[0].scl_rate = CONFIG_SENSOR_I2C_SPEED;       /* ddl@rock-chips.com : 100kHz */
-    msg[0].read_type = 2;//0x55;   /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
-
-    msg[1].addr = client->addr;
-    msg[1].flags = client->flags|I2C_M_RD;
-    msg[1].buf = buf;
-    msg[1].len = 1;
-    msg[1].scl_rate = CONFIG_SENSOR_I2C_SPEED;                       /* ddl@rock-chips.com : 100kHz */
-    msg[1].read_type = 2;                             /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
-
-    cnt = 3;
-    err = -EAGAIN;
-    while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
-        err = i2c_transfer(client->adapter, msg, 2);
-
-        if (err >= 0) {
-            *val = buf[0];
-            return 0;
-        } else {
-        	SENSOR_TR("\n %s read reg(0x%x val:0x%x) failed, try to read again! \n",SENSOR_NAME_STRING(),reg, *val);
-            udelay(10);
-        }
-    }
-
-    return err;
-}
-
-/* write a array of registers  */
-static int sensor_write_array(struct i2c_client *client, struct reginfo *regarray)
-{
-    int err = 0, cnt;
-    int i = 0;
-#if CONFIG_SENSOR_I2C_RDWRCHK    
-	char valchk;
-#endif
-
-	cnt = 0;
-	if (sensor_task_lock(client, 1) < 0)
-		goto sensor_write_array_end;
-    while (regarray[i].reg != 0)
-    {
-        err = sensor_write(client, regarray[i].reg, regarray[i].val);
-        if (err < 0)
-        {
-            if (cnt-- > 0) {
-			    SENSOR_TR("%s..write failed current reg:0x%x, Write array again !\n", SENSOR_NAME_STRING(),regarray[i].reg);
-				i = 0;
-				continue;
-            } else {
-                SENSOR_TR("%s..write array failed!!!\n", SENSOR_NAME_STRING());
-                err = -EPERM;
-				goto sensor_write_array_end;
-            }
-        } else {
-        #if CONFIG_SENSOR_I2C_RDWRCHK
-			sensor_read(client, regarray[i].reg, &valchk);
-			if (valchk != regarray[i].val)
-				SENSOR_TR("%s Reg:0x%x write(0x%x, 0x%x) fail\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
-		#endif
-        }
-        i++;
-    }
-
-sensor_write_array_end:
-	sensor_task_lock(client,0);
-	return err;
-}
-#if CONFIG_SENSOR_I2C_RDWRCHK
-static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regarray)
-{
-    int cnt;
-    int i = 0;
-	char valchk;
-
-	cnt = 0;
-	valchk = 0;
-    while (regarray[i].reg != 0)
-    {
-		sensor_read(client, regarray[i].reg, &valchk);
-		if (valchk != regarray[i].val)
-			SENSOR_TR("%s Reg:0x%x read(0x%x, 0x%x) error\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
-
-        i++;
-    }
-    return 0;
-}
-#endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
-{
-	struct soc_camera_link *icl = to_soc_camera_link(icd);
-	int ret = 0;
-
-    SENSOR_DG("%s %s  cmd(%d) on(%d)\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd,on);
-
-	switch (cmd)
-	{
-		case Sensor_PowerDown:
-		{
-			if (icl->powerdown) {
-				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
-					if (on == 0) {
-						mdelay(2);
-						if (icl->reset)
-							icl->reset(icd->pdev);
-					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
-					ret = -ENODEV;
-					goto sensor_power_end;
-				}
-			}
-			break;
-		}
-		case Sensor_Flash:
-		{
-			struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    		struct sensor *sensor = to_sensor(client);
-
-			if (sensor->sensor_io_request && sensor->sensor_io_request->sensor_ioctrl) {
-				sensor->sensor_io_request->sensor_ioctrl(icd->pdev,Cam_Flash, on);
-			}
-            break;
-		}
-		default:
-		{
-			SENSOR_TR("%s %s cmd(0x%x) is unknown!",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
-			break;
-		}
-	}
-sensor_power_end:
-	return ret;
-}
-static int sensor_init(struct v4l2_subdev *sd, u32 val)
-{
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/log2.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/circ_buf.h>
+#include <linux/miscdevice.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/soc_camera.h>
+#include <mach/rk29_camera.h>
+
+static int debug;
+module_param(debug, int, S_IRUGO|S_IWUSR);
+
+#define dprintk(level, fmt, arg...) do {			\
+	if (debug >= level) 					\
+	printk(KERN_WARNING fmt , ## arg); } while (0)
+
+#define SENSOR_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
+#define SENSOR_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)
+
+
+#define _CONS(a,b) a##b
+#define CONS(a,b) _CONS(a,b)
+
+#define __STR(x) #x
+#define _STR(x) __STR(x)
+#define STR(x) _STR(x)
+
+#define MIN(x,y)   ((x<y) ? x: y)
+#define MAX(x,y)    ((x>y) ? x: y)
+
+/* Sensor Driver Configuration */
+#define SENSOR_NAME RK29_CAM_SENSOR_OV2640
+#define SENSOR_V4L2_IDENT V4L2_IDENT_OV2640
+#define SENSOR_ID 0x2642
+#define SENSOR_ID1 0x2641
+#define SENSOR_MIN_WIDTH    640
+#define SENSOR_MIN_HEIGHT   480
+#define SENSOR_MAX_WIDTH    1600
+#define SENSOR_MAX_HEIGHT   1200
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
+
+#define CONFIG_SENSOR_WhiteBalance	0
+#define CONFIG_SENSOR_Brightness	1
+#define CONFIG_SENSOR_Contrast      0
+#define CONFIG_SENSOR_Saturation    1
+#define CONFIG_SENSOR_Effect        1
+#define CONFIG_SENSOR_Scene         0
+#define CONFIG_SENSOR_DigitalZoom   0
+#define CONFIG_SENSOR_Focus         0
+#define CONFIG_SENSOR_Exposure      0
+#define CONFIG_SENSOR_Flash         0
+#define CONFIG_SENSOR_Mirror        0
+#define CONFIG_SENSOR_Flip          0
+
+#define CONFIG_SENSOR_I2C_SPEED     250000       /* Hz */
+/* Sensor write register continues by preempt_disable/preempt_enable for current process not be scheduled */
+#define CONFIG_SENSOR_I2C_NOSCHED   0
+#define CONFIG_SENSOR_I2C_RDWRCHK   0
+
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
+#define COLOR_TEMPERATURE_CLOUDY_DN  6500
+#define COLOR_TEMPERATURE_CLOUDY_UP    8000
+#define COLOR_TEMPERATURE_CLEARDAY_DN  5000
+#define COLOR_TEMPERATURE_CLEARDAY_UP    6500
+#define COLOR_TEMPERATURE_OFFICE_DN     3500
+#define COLOR_TEMPERATURE_OFFICE_UP     5000
+#define COLOR_TEMPERATURE_HOME_DN       2500
+#define COLOR_TEMPERATURE_HOME_UP       3500
+
+#define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
+#define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)
+
+struct reginfo
+{
+    u8 reg;
+    u8 val;
+};
+
+/* init 800*600 SVGA */
+static struct reginfo sensor_init_data[] =
+{
+#if 1
+    {0xff,0x01},
+    {0x12,0x80},
+    {0xff,0x00},
+    {0x2c,0xff},
+    {0x2e,0xdf},
+    {0xff,0x01},
+
+    {0x03,0x4f},
+    {0x0f,0x4b},
+
+
+    {0x3c,0x32},
+    {0x11,0x00},
+    {0x09,0x02},
+    {0x04,0xF8},//b7,b6 directs
+    {0x13,0xe5},
+    {0x14,0x48},
+    {0x2c,0x0c},
+    {0x33,0x78},
+    {0x3a,0x33},
+    {0x3b,0xfB},
+    {0x3e,0x00},
+    {0x43,0x11},
+    {0x16,0x10},
+    {0x39,0x02},
+    {0x35,0x88},
+    {0x22,0x09},
+    {0x37,0x40},
+    {0x23,0x00},
+    {0x34,0xa0},
+    {0x36,0x1a},
+    {0x06,0x02},
+    {0x07,0xc0},
+    {0x0d,0xb7},
+    {0x0e,0x01},
+    {0x4c,0x00},
+    {0x4a,0x81},
+    {0x21,0x99},
+    
+    //{0x24,0x58},
+    //{0x25,0x50},
+    //{0x26,0x92},
+    
+    {0x24, 0x70},
+    {0x25, 0x60},
+    {0x26, 0xa4},    
+    
+    {0x5c,0x00},
+    {0x63,0x00},
+    {0x46,0x3f},
+    {0x0c,0x3c},
+    {0x61,0x70},
+    {0x62,0x80},
+    {0x7c,0x05},
+    {0x20,0x80},
+    {0x28,0x30},
+    {0x6c,0x00},
+    {0x6d,0x80},
+    {0x6e,0x00},
+    {0x70,0x02},
+    {0x71,0x94},
+    {0x73,0xc1},
+    {0x3d,0x34},
+    {0x5a,0x57},
+    {0x4f,0xbb},
+    {0x50,0x9c},
+    {0xff,0x00},
+    {0xe5,0x7f},
+    {0xf9,0xc0},
+    {0x41,0x24},
+    {0xe0,0x14},
+    {0x76,0xff},
+    {0x33,0xa0},
+    {0x42,0x20},
+    {0x43,0x18},
+    {0x4c,0x00},
+    {0x87,0xd0},
+    {0x88,0x3f},
+    {0xd7,0x03},
+    {0xd9,0x10},
+    {0xd3,0x82},
+    {0xc8,0x08},
+    {0xc9,0x80},
+    {0x7c,0x00},
+    {0x7d,0x00},//0x00//0x07
+    {0x7c,0x03},
+    {0x7d,0x48},//0x48//0x40
+    {0x7d,0x48},//0x48//0x40
+    {0x7c,0x08},
+    {0x7d,0x20},
+    {0x7d,0x10},//0x10
+    {0x7d,0x0e},//0x0e
+
+    {0x92,0x00},
+    {0x93,0x06},
+    {0x93,0xc8},//e3
+    {0x93,0x05},
+    {0x93,0x05},
+    {0x93,0x00},
+    {0x93,0x04},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x96,0x00},
+    {0x97,0x08},
+    {0x97,0x19},
+    {0x97,0x02},
+    {0x97,0x0c},
+    {0x97,0x24},
+    {0x97,0x30},
+    {0x97,0x28},
+    {0x97,0x26},
+    {0x97,0x02},
+    {0x97,0x98},
+    {0x97,0x80},
+    {0x97,0x00},
+    {0x97,0x00},
+    {0xc3,0xef},//ed
+    {0xa4,0x00},
+    {0xa8,0x00},
+
+    {0xbf, 0x00},
+    {0xba, 0xdc},
+    {0xbb, 0x08},
+    {0xb6, 0x20},
+    {0xb8, 0x30},
+    {0xb7, 0x20},
+    {0xb9, 0x30},
+    {0xb3, 0xb4},
+    {0xb4, 0xca},
+    {0xb5, 0x34},
+    {0xb0, 0x46},
+    {0xb1, 0x46},
+    {0xb2, 0x06},
+    {0xc7, 0x00},
+    {0xc6, 0x51},
+    {0xc5, 0x11},
+    {0xc4, 0x9c},
+////
+    {0xc0,0xc8},
+    {0xc1,0x96},
+    {0x86,0x3d},
+    {0x50,0x92},
+    {0x51,0x90},
+    {0x52,0x2c},
+    {0x53,0x00},
+    {0x54,0x00},
+    {0x55,0x88},
+    {0x57,0x00},
+    {0x5a,0x50},
+    {0x5b,0x3c},
+    {0x5c,0x00},
+    {0xc3,0xed},
+    {0x7f,0x00},
+    {0xda,0x01},
+    {0xe5,0x1f},
+    {0xe1,0x67},
+    {0xe0,0x00},
+    {0xdd,0xff},
+    {0x05,0x00},
+
+#endif
+#if 1
+    {0xff, 0x01},
+    {0x5d, 0x00},
+    {0x5e, 0x3c},
+    {0x5f, 0x28},
+    {0x60, 0x55},
+
+
+    {0xff, 0x00},
+    {0xc3, 0xef},
+    {0xa6, 0x00},
+    {0xa7, 0x0f},
+    {0xa7, 0x4e},
+    {0xa7, 0x7a},
+    {0xa7, 0x33},
+    {0xa7, 0x00},
+    {0xa7, 0x23},
+    {0xa7, 0x27},
+    {0xa7, 0x3a},
+    {0xa7, 0x70},
+    {0xa7, 0x33},
+    {0xa7, 0x00},//L
+    {0xa7, 0x23},
+    {0xa7, 0x20},
+    {0xa7, 0x0c},
+    {0xa7, 0x66},
+    {0xa7, 0x33},
+    {0xa7, 0x00},
+    {0xa7, 0x23},
+    {0xc3, 0xef},
+#endif
+
+
+#if 1
+    {0xff,0x00},
+    {0x92,0x00},
+    {0x93,0x06},
+    {0x93,0xc1},//e
+    {0x93,0x02},
+    {0x93,0x02},
+    {0x93,0x00},
+    {0x93,0x04},
+#endif
+
+    {0x03, 0x0f},
+    {0xe0, 0x04},
+    {0xc0, 0xc8},
+    {0xc1, 0x96},
+    {0x86, 0x3d},
+    {0x50, 0x89},
+    {0x51, 0x90},
+    {0x52, 0x2c},
+    {0x53, 0x00},
+    {0x54, 0x00},
+    {0x55, 0x88},
+    {0x57, 0x00},
+    {0x5a, 0xa0},
+    {0x5b, 0x78},
+    {0x5c, 0x00},
+    {0xd3, 0x04},
+    {0xe0, 0x00},
+
+  {0x0, 0x0}   //end flag
+
+};
+
+/* 1600X1200 UXGA */
+static struct reginfo sensor_uxga[] =
+{
+    {0xff, 0x00},
+    {0xe0, 0x04},
+    {0xc0, 0xc8},
+    {0xc1, 0x96},
+    {0x86, 0x3d},
+    {0x50, 0x00},
+    {0x51, 0x90},
+    {0x52, 0x2c},
+    {0x53, 0x00},
+    {0x54, 0x00},
+    {0x55, 0x88},
+    {0x57, 0x00},
+    {0x5a, 0x90},
+    {0x5b, 0x2c},
+    {0x5c, 0x05},
+    {0xd3, 0x82},
+    {0xe0, 0x00},
+  {0x0, 0x0}   //end flag
+};
+
+/* 1280X1024 SXGA */
+static struct reginfo sensor_sxga[] =
+{
+    {0xff, 0x00},
+    {0xe0, 0x04},
+    {0xc0, 0xc8},
+    {0xc1, 0x96},
+    {0x86, 0x3d},
+    {0x50, 0x00},
+    {0x51, 0x90},
+    {0x52, 0x2c},
+    {0x53, 0x00},
+    {0x54, 0x00},
+    {0x55, 0x88},
+    {0x57, 0x00},
+    {0x5a, 0x40},
+    {0x5b, 0x00},
+    {0x5c, 0x05},
+    {0xd3, 0x82},
+    {0xe0, 0x00},
+  {0x0, 0x0}   //end flag
+};
+
+
+static struct reginfo sensor_xga[] =
+{
+    {0xff, 0x00},
+    {0xe0, 0x04},
+    {0xc0, 0xc8},
+    {0xc1, 0x96},
+    {0x86, 0x3d},
+    {0x50, 0x00},
+    {0x51, 0x90},
+    {0x52, 0x2c},
+    {0x53, 0x00},
+    {0x54, 0x00},
+    {0x55, 0x88},
+    {0x57, 0x00},
+    {0x5a, 0x40},
+    {0x5b, 0x00},
+    {0x5c, 0x05},
+    {0xd3, 0x82},
+    {0xe0, 0x00},
+  {0x0, 0x0}   //end flag
+
+
+};
+
+
+/* 800X600 SVGA*/
+static struct reginfo sensor_svga[] =
+{
+  {0x0, 0x0}   //end flag
+};
+
+/* 640X480 VGA */
+static struct reginfo sensor_vga[] =
+{
+   {0x0, 0x0}   //end flag
+ };
+
+/* 352X288 CIF */
+static struct reginfo sensor_cif[] =
+{
+  {0x0, 0x0}   //end flag
+};
+
+/* 320*240 QVGA */
+static  struct reginfo sensor_qvga[] =
+{
+  {0x0, 0x0}   //end flag
+};
+
+/* 176X144 QCIF*/
+static struct reginfo sensor_qcif[] =
+{
+  {0x0, 0x0}   //end flag
+};
+#if 0
+/* 160X120 QQVGA*/
+static struct reginfo ov2655_qqvga[] =
+{
+
+    {0x300E, 0x34},
+    {0x3011, 0x01},
+    {0x3012, 0x10},
+    {0x302a, 0x02},
+    {0x302b, 0xE6},
+    {0x306f, 0x14},
+    {0x3362, 0x90},
+
+    {0x3070, 0x5d},
+    {0x3072, 0x5d},
+    {0x301c, 0x07},
+    {0x301d, 0x07},
+
+    {0x3020, 0x01},
+    {0x3021, 0x18},
+    {0x3022, 0x00},
+    {0x3023, 0x06},
+    {0x3024, 0x06},
+    {0x3025, 0x58},
+    {0x3026, 0x02},
+    {0x3027, 0x61},
+    {0x3088, 0x00},
+    {0x3089, 0xa0},
+    {0x308a, 0x00},
+    {0x308b, 0x78},
+    {0x3316, 0x64},
+    {0x3317, 0x25},
+    {0x3318, 0x80},
+    {0x3319, 0x08},
+    {0x331a, 0x0a},
+    {0x331b, 0x07},
+    {0x331c, 0x80},
+    {0x331d, 0x38},
+    {0x3100, 0x00},
+    {0x3302, 0x11},
+
+    {0x0, 0x0},
+};
+
+
+
+static  struct reginfo ov2655_Sharpness_auto[] =
+{
+    {0x3306, 0x00},
+};
+
+static  struct reginfo ov2655_Sharpness1[] =
+{
+    {0x3306, 0x08},
+    {0x3371, 0x00},
+};
+
+static  struct reginfo ov2655_Sharpness2[][3] =
+{
+    //Sharpness 2
+    {0x3306, 0x08},
+    {0x3371, 0x01},
+};
+
+static  struct reginfo ov2655_Sharpness3[] =
+{
+    //default
+    {0x3306, 0x08},
+    {0x332d, 0x02},
+};
+static  struct reginfo ov2655_Sharpness4[]=
+{
+    //Sharpness 4
+    {0x3306, 0x08},
+    {0x332d, 0x03},
+};
+
+static  struct reginfo ov2655_Sharpness5[] =
+{
+    //Sharpness 5
+    {0x3306, 0x08},
+    {0x332d, 0x04},
+};
+#endif
+
+static  struct reginfo sensor_ClrFmt_YUYV[]=
+{
+    //{0x4300, 0x30},
+    {0x00, 0x00}
+};
+
+static  struct reginfo sensor_ClrFmt_UYVY[]=
+{
+    //{0x4300, 0x32},
+    {0x00, 0x00}
+};
+
+#if CONFIG_SENSOR_WhiteBalance
+static  struct reginfo sensor_WhiteB_Auto[]=
+{
+    {0x3406, 0x00},  //AWB auto, bit[1]:0,auto
+    {0x0000, 0x00}
+};
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static  struct reginfo sensor_WhiteB_Cloudy[]=
+{
+    {0x3406, 0x01},
+    {0x3400, 0x07},
+    {0x3401, 0x08},
+    {0x3402, 0x04},
+    {0x3403, 0x00},
+    {0x3404, 0x05},
+    {0x3405, 0x00},
+    {0x0000, 0x00}
+};
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static  struct reginfo sensor_WhiteB_ClearDay[]=
+{
+    //Sunny
+    {0x3406, 0x01},
+    {0x3400, 0x07},
+    {0x3401, 0x02},
+    {0x3402, 0x04},
+    {0x3403, 0x00},
+    {0x3404, 0x05},
+    {0x3405, 0x15},
+    {0x0000, 0x00}
+};
+/* Office Colour Temperature : 3500K - 5000K  */
+static  struct reginfo sensor_WhiteB_TungstenLamp1[]=
+{
+    //Office
+    {0x3406, 0x01},
+    {0x3400, 0x06},
+    {0x3401, 0x2a},
+    {0x3402, 0x04},
+    {0x3403, 0x00},
+    {0x3404, 0x07},
+    {0x3405, 0x24},
+    {0x0000, 0x00}
+
+};
+/* Home Colour Temperature : 2500K - 3500K  */
+static  struct reginfo sensor_WhiteB_TungstenLamp2[]=
+{
+    //Home
+    {0x3406, 0x01},
+    {0x3400, 0x04},
+    {0x3401, 0x58},
+    {0x3402, 0x04},
+    {0x3403, 0x00},
+    {0x3404, 0x07},
+    {0x3405, 0x24},
+    {0x0000, 0x00}
+};
+static struct reginfo *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,
+    sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,
+};
+#endif
+
+#if CONFIG_SENSOR_Brightness
+static  struct reginfo sensor_Brightness0[]=
+{
+    // Brightness -2
+    {0xff, 0x01},
+    {0x24, 0x34},
+    {0x25, 0x22},
+    {0x26, 0x70},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness1[]=
+{
+    // Brightness -1
+
+    {0xff, 0x01},
+    {0x24, 0x58},
+    {0x25, 0x50},
+    {0x26, 0x92},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness2[]=
+{
+    //  Brightness 0
+
+	{0xff, 0x01},
+	{0x24, 0xa8},
+	{0x25, 0x90},
+	{0x26, 0xd6},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness3[]=
+{
+    // Brightness +1
+
+    {0xff, 0x01},
+    {0x24, 0x48},
+    {0x25, 0x40},
+    {0x26, 0x81},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness4[]=
+{
+    //  Brightness +2
+
+    {0xff, 0x01},
+    {0x24, 0x58},
+    {0x25, 0x50},
+    {0x26, 0x92},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness5[]=
+{
+    //  Brightness +3
+    {0xff, 0x01},
+    {0x24, 0x70},
+    {0x25, 0x60},
+    {0x26, 0xa4},
+  {0x0, 0x0}   //end flag
+};
+static struct reginfo *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,
+    sensor_Brightness4, sensor_Brightness5,NULL,
+};
+
+#endif
+
+#if CONFIG_SENSOR_Effect
+static  struct reginfo sensor_Effect_Normal[] =
+{
+	{0xff,0x00},
+	{0x7c,0x00},
+	{0x7d,0x00},
+	{0x7c,0x05},
+	{0x7d,0x80},
+	{0x7d,0x80},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_WandB[] =
+{
+    {0xff,0x00},
+    {0x7c,0x00},
+    {0x7d,0x18},
+    {0x7c,0x05},
+    {0x7d,0x80},
+    {0x7d,0x80},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_Sepia[] =
+{
+    {0xff,0x00},
+    {0x7c,0x00},
+    {0x7d,0x18},
+    {0x7c,0x05},
+    {0x7d,0x40},
+    {0x7d,0xc0},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_Negative[] =
+{
+    {0xff,0x00},
+    {0x7c,0x00},
+    {0x7d,0x40},
+    {0x7c,0x05},
+    {0x7d,0x80},
+    {0x7d,0x80},
+  {0x0, 0x0}   //end flag
+};
+static  struct reginfo sensor_Effect_Bluish[] =
+{
+    {0Xff, 0X00},
+    {0X7c, 0X00},
+    {0X7d, 0X18},
+    {0X7c, 0X05},
+    {0X7d, 0Xa0},
+    {0X7d, 0X40},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_Green[] =
+{
+    {0Xff, 0X00},
+    {0X7c, 0X00},
+    {0X7d, 0X18},
+    {0X7c, 0X05},
+    {0X7d, 0X40},
+    {0X7d, 0X40},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_Exp_Windows_Half[] =
+{
+	{0xff, 0x01},
+	{0x5d, 0x00},
+	{0x5e, 0x3c},
+	{0x5f, 0x28},
+	{0x60, 0x55},
+  {0x0, 0x0}   //end flag
+};
+static struct reginfo *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_WandB, sensor_Effect_Negative,sensor_Effect_Sepia,
+    sensor_Effect_Bluish, sensor_Effect_Green,NULL,
+};
+#endif
+#if CONFIG_SENSOR_Exposure
+static  struct reginfo sensor_Exposure0[]=
+{
+	{0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure1[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure2[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure3[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure4[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure5[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure6[]=
+{
+    {0x0000, 0x00}
+};
+
+static struct reginfo *sensor_ExposureSeqe[] = {sensor_Exposure0, sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,
+    sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,NULL,
+};
+#endif
+#if CONFIG_SENSOR_Saturation
+static  struct reginfo sensor_Saturation0[]=
+{
+	{0xff, 0x00},
+	{0x90, 0x00},
+	{0x91, 0x0e},
+	{0x91, 0x1a},
+	{0x91, 0x31},
+	{0x91, 0x5a},
+	{0x91, 0x69},
+	{0x91, 0x75},
+	{0x91, 0x7e},
+	{0x91, 0x88},
+	{0x91, 0x8f},
+	{0x91, 0x96},
+	{0x91, 0xa3},
+	{0x91, 0xaf},
+	{0x91, 0xc4},
+	{0x91, 0xd7},
+	{0x91, 0xe8},
+	{0x91, 0x20},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Saturation1[]=
+{
+    {0xff, 0x00},
+    {0x90, 0x00},
+    {0x91, 0x03},
+    {0x91, 0x0a},
+    {0x91, 0x1a},
+    {0x91, 0x3f},
+    {0x91, 0x4e},
+    {0x91, 0x5b},
+    {0x91, 0x68},
+    {0x91, 0x75},
+    {0x91, 0x7f},
+    {0x91, 0x89},
+    {0x91, 0x9a},
+    {0x91, 0xa6},
+    {0x91, 0xbd},
+    {0x91, 0xd3},
+    {0x91, 0xe5},
+    {0x91, 0x24},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Saturation2[]=
+{
+    {0xff, 0x00},
+    {0x90, 0x00},
+    {0x91, 0x04},
+    {0x91, 0x07},
+    {0x91, 0x10},
+    {0x91, 0x28},
+    {0x91, 0x36},
+    {0x91, 0x44},
+    {0x91, 0x52},
+    {0x91, 0x60},
+    {0x91, 0x6c},
+    {0x91, 0x78},
+    {0x91, 0x8c},
+    {0x91, 0x9e},
+    {0x91, 0xbb},
+    {0x91, 0xd3},
+    {0x91, 0xe5},
+    {0x91, 0x24},
+  {0x0, 0x0}   //end flag	
+};
+static struct reginfo *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};
+
+
+#endif
+#if CONFIG_SENSOR_Contrast
+static  struct reginfo sensor_Contrast0[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x10},
+    {0x7d, 0x4a},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+
+};
+
+static  struct reginfo sensor_Contrast1[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x14},
+    {0x7d, 0x40},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast2[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x18},
+    {0x7d, 0x34},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast3[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x1c},
+    {0x7d, 0x2a},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast4[]=
+{
+    {0xff,0x00},
+    {0x7c,0x00},
+    {0x7d,0x04},
+    {0x7c,0x07},
+    {0x7d,0x20},
+    {0x7d,0x24},
+    {0x7d,0x16},
+    {0x7d,0x06},
+  {0x0, 0x0}   //end flag
+};
+
+
+static  struct reginfo sensor_Contrast5[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x20},
+    {0x7d, 0x20},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast6[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x24},
+    {0x7d, 0x16},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+
+static  struct reginfo sensor_Contrast7[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x28},
+    {0x7d, 0x0c},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast8[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x2c},
+    {0x7d, 0x02},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast9[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x30},
+    {0x7d, 0x08},
+    {0x7d, 0x0e},
+  {0x0, 0x0}   //end flag
+};
+
+
+
+static struct reginfo *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,
+    sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,
+};
+
+#endif
+#if CONFIG_SENSOR_Mirror
+static  struct reginfo sensor_MirrorOn[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_MirrorOff[]=
+{
+    {0x0000, 0x00}
+};
+static struct reginfo *sensor_MirrorSeqe[] = {sensor_MirrorOff, sensor_MirrorOn,NULL,};
+#endif
+#if CONFIG_SENSOR_Flip
+static  struct reginfo sensor_FlipOn[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_FlipOff[]=
+{
+    {0x0000, 0x00}
+};
+static struct reginfo *sensor_FlipSeqe[] = {sensor_FlipOff, sensor_FlipOn,NULL,};
+
+#endif
+#if CONFIG_SENSOR_Scene
+static  struct reginfo sensor_SceneAuto[] =
+{
+    {0x3a00, 0x78},
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_SceneNight[] =
+{
+    {0x3003, 0x80},
+	{0x3004, 0x20},
+	{0x3005, 0x18},
+	{0x3006, 0x0d},
+	{0x3a00, 0x7c},
+	{0x3a02 ,0x07},
+	{0x3a03 ,0x38},
+	{0x3a14 ,0x07},
+	{0x3a15 ,0x38},
+    {0x0000, 0x00}
+};
+static struct reginfo *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight,NULL,};
+
+#endif
+#if CONFIG_SENSOR_DigitalZoom
+static struct reginfo sensor_Zoom0[] =
+{
+    {0x0, 0x0},
+};
+
+static struct reginfo sensor_Zoom1[] =
+{
+     {0x0, 0x0},
+};
+
+static struct reginfo sensor_Zoom2[] =
+{
+    {0x0, 0x0},
+};
+
+
+static struct reginfo sensor_Zoom3[] =
+{
+    {0x0, 0x0},
+};
+static struct reginfo *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL,};
+#endif
+static const struct v4l2_querymenu sensor_menus[] =
+{
+	#if CONFIG_SENSOR_WhiteBalance
+    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 0,  .name = "auto",  .reserved = 0, }, {  .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 1, .name = "incandescent",  .reserved = 0,},
+    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 2,  .name = "fluorescent", .reserved = 0,}, {  .id = V4L2_CID_DO_WHITE_BALANCE, .index = 3,  .name = "daylight", .reserved = 0,},
+    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 4,  .name = "cloudy-daylight", .reserved = 0,},
+    #endif
+
+	#if CONFIG_SENSOR_Effect
+    { .id = V4L2_CID_EFFECT,  .index = 0,  .name = "none",  .reserved = 0, }, {  .id = V4L2_CID_EFFECT,  .index = 1, .name = "mono",  .reserved = 0,},
+    { .id = V4L2_CID_EFFECT,  .index = 2,  .name = "negative", .reserved = 0,}, {  .id = V4L2_CID_EFFECT, .index = 3,  .name = "sepia", .reserved = 0,},
+    { .id = V4L2_CID_EFFECT,  .index = 4, .name = "posterize", .reserved = 0,} ,{ .id = V4L2_CID_EFFECT,  .index = 5,  .name = "aqua", .reserved = 0,},
+    #endif
+
+	#if CONFIG_SENSOR_Scene
+    { .id = V4L2_CID_SCENE,  .index = 0, .name = "auto", .reserved = 0,} ,{ .id = V4L2_CID_SCENE,  .index = 1,  .name = "night", .reserved = 0,},
+    #endif
+
+	#if CONFIG_SENSOR_Flash
+    { .id = V4L2_CID_FLASH,  .index = 0,  .name = "off",  .reserved = 0, }, {  .id = V4L2_CID_FLASH,  .index = 1, .name = "auto",  .reserved = 0,},
+    { .id = V4L2_CID_FLASH,  .index = 2,  .name = "on", .reserved = 0,}, {  .id = V4L2_CID_FLASH, .index = 3,  .name = "torch", .reserved = 0,},
+    #endif
+};
+
+static const struct v4l2_queryctrl sensor_controls[] =
+{
+	#if CONFIG_SENSOR_WhiteBalance
+    {
+        .id		= V4L2_CID_DO_WHITE_BALANCE,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "White Balance Control",
+        .minimum	= 0,
+        .maximum	= 4,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Brightness
+	{
+        .id		= V4L2_CID_BRIGHTNESS,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Brightness Control",
+        .minimum	= -3,
+        .maximum	= 2,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Effect
+	{
+        .id		= V4L2_CID_EFFECT,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "Effect Control",
+        .minimum	= 0,
+        .maximum	= 5,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+
+	#if CONFIG_SENSOR_Exposure
+	{
+        .id		= V4L2_CID_EXPOSURE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Exposure Control",
+        .minimum	= 0,
+        .maximum	= 6,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+
+	#if CONFIG_SENSOR_Saturation
+	{
+        .id		= V4L2_CID_SATURATION,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Saturation Control",
+        .minimum	= 0,
+        .maximum	= 2,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Contrast
+	{
+        .id		= V4L2_CID_CONTRAST,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Contrast Control",
+        .minimum	= -3,
+        .maximum	= 3,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+
+	#if CONFIG_SENSOR_Mirror
+	{
+        .id		= V4L2_CID_HFLIP,
+        .type		= V4L2_CTRL_TYPE_BOOLEAN,
+        .name		= "Mirror Control",
+        .minimum	= 0,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 1,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Flip
+	{
+        .id		= V4L2_CID_VFLIP,
+        .type		= V4L2_CTRL_TYPE_BOOLEAN,
+        .name		= "Flip Control",
+        .minimum	= 0,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 1,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Scene
+    {
+        .id		= V4L2_CID_SCENE,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "Scene Control",
+        .minimum	= 0,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_DigitalZoom
+    {
+        .id		= V4L2_CID_ZOOM_RELATIVE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "DigitalZoom Control",
+        .minimum	= -1,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 0,
+    }, {
+        .id		= V4L2_CID_ZOOM_ABSOLUTE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "DigitalZoom Control",
+        .minimum	= 0,
+        .maximum	= 3,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Focus
+	{
+        .id		= V4L2_CID_FOCUS_RELATIVE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Focus Control",
+        .minimum	= -1,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 0,
+    }, {
+        .id		= V4L2_CID_FOCUS_ABSOLUTE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Focus Control",
+        .minimum	= 0,
+        .maximum	= 255,
+        .step		= 1,
+        .default_value = 125,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Flash
+	{
+        .id		= V4L2_CID_FLASH,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "Flash Control",
+        .minimum	= 0,
+        .maximum	= 3,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+};
+
+static int sensor_probe(struct i2c_client *client, const struct i2c_device_id *did);
+static int sensor_video_probe(struct soc_camera_device *icd, struct i2c_client *client);
+static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+static int sensor_g_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
+static int sensor_s_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
+static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);
+static int sensor_resume(struct soc_camera_device *icd);
+static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);
+static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);
+#if CONFIG_SENSOR_Effect
+static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
+#endif
+#if CONFIG_SENSOR_WhiteBalance
+static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
+#endif
+static int sensor_deactivate(struct i2c_client *client);
+
+static struct soc_camera_ops sensor_ops =
+{
+    .suspend                     = sensor_suspend,
+    .resume                       = sensor_resume,
+    .set_bus_param		= sensor_set_bus_param,
+    .query_bus_param	= sensor_query_bus_param,
+    .controls		= sensor_controls,
+    .menus                         = sensor_menus,
+    .num_controls		= ARRAY_SIZE(sensor_controls),
+    .num_menus		= ARRAY_SIZE(sensor_menus),
+};
+
+/* only one fixed colorspace per pixelcode */
+struct sensor_datafmt {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+};
+
+/* Find a data format by a pixel code in an array */
+static const struct sensor_datafmt *sensor_find_datafmt(
+	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
+	int n)
+{
+	int i;
+	for (i = 0; i < n; i++)
+		if (fmt[i].code == code)
+			return fmt + i;
+
+	return NULL;
+}
+
+static const struct sensor_datafmt sensor_colour_fmts[] = {
+    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
+    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
+};
+
+typedef struct sensor_info_priv_s
+{
+    int whiteBalance;
+    int brightness;
+    int contrast;
+    int saturation;
+    int effect;
+    int scene;
+    int digitalzoom;
+    int focus;
+    int flash;
+    int exposure;
+	bool snap2preview;
+	bool video2preview;
+    unsigned char mirror;                                        /* HFLIP */
+    unsigned char flip;                                          /* VFLIP */
+    unsigned int winseqe_cur_addr;
+    struct sensor_datafmt fmt;
+
+} sensor_info_priv_t;
+
+struct sensor
+{
+    struct v4l2_subdev subdev;
+    struct i2c_client *client;
+    sensor_info_priv_t info_priv;
+    int model;	/* V4L2_IDENT_OV* codes from v4l2-chip-ident.h */
+#if CONFIG_SENSOR_I2C_NOSCHED
+	atomic_t tasklock_cnt;
+#endif
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
+};
+
+static struct sensor* to_sensor(const struct i2c_client *client)
+{
+    return container_of(i2c_get_clientdata(client), struct sensor, subdev);
+}
+
+static int sensor_task_lock(struct i2c_client *client, int lock)
+{
+#if CONFIG_SENSOR_I2C_NOSCHED
+	int cnt = 3;
+    struct sensor *sensor = to_sensor(client);
+
+	if (lock) {
+		if (atomic_read(&sensor->tasklock_cnt) == 0) {
+			while ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt>0)) {
+				SENSOR_TR("\n %s will obtain i2c in atomic, but i2c bus is locked! Wait...\n",SENSOR_NAME_STRING());
+				msleep(35);
+				cnt--;
+			}
+			if ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt<=0)) {
+				SENSOR_TR("\n %s obtain i2c fail in atomic!!\n",SENSOR_NAME_STRING());
+				goto sensor_task_lock_err;
+			}
+			preempt_disable();
+		}
+
+		atomic_add(1, &sensor->tasklock_cnt);
+	} else {
+		if (atomic_read(&sensor->tasklock_cnt) > 0) {
+			atomic_sub(1, &sensor->tasklock_cnt);
+
+			if (atomic_read(&sensor->tasklock_cnt) == 0)
+				preempt_enable();
+		}
+	}
+	return 0;
+sensor_task_lock_err:
+	return -1;  
+#else
+    return 0;
+#endif
+
+}
+static int sensor_write(struct i2c_client *client, u8 reg, u8 val)
+{
+    int err,cnt;
+    u8 buf[2];
+    struct i2c_msg msg[1];
+
+    buf[0] = reg & 0xFF;
+    buf[1] = val;
+
+    msg->addr = client->addr;
+    msg->flags = client->flags;
+    msg->buf = buf;
+    msg->len = sizeof(buf);
+    msg->scl_rate = CONFIG_SENSOR_I2C_SPEED;                                        /* ddl@rock-chips.com : 100kHz */
+    msg->read_type = 0;               /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */
+
+    cnt = 3;
+    err = -EAGAIN;
+
+    while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
+        err = i2c_transfer(client->adapter, msg, 1);
+
+        if (err >= 0) {
+            return 0;
+        } else {
+            SENSOR_TR("\n %s write reg(0x%x, val:0x%x) failed, try to write again!\n",SENSOR_NAME_STRING(),reg, val);
+            udelay(10);
+        }
+    }
+
+    return err;
+}
+
+/* sensor register read */
+static int sensor_read(struct i2c_client *client, u8 reg, u8 *val)
+{
+    int err,cnt;
+    u8 buf[1];
+    struct i2c_msg msg[2];
+
+    buf[0] = reg ;//>> 8;
+   // buf[1] = 0;
+
+    msg[0].addr = client->addr;
+    msg[0].flags = client->flags;
+    msg[0].buf = buf;
+    msg[0].len = sizeof(buf);
+    msg[0].scl_rate = CONFIG_SENSOR_I2C_SPEED;       /* ddl@rock-chips.com : 100kHz */
+    msg[0].read_type = 2;//0x55;   /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
+
+    msg[1].addr = client->addr;
+    msg[1].flags = client->flags|I2C_M_RD;
+    msg[1].buf = buf;
+    msg[1].len = 1;
+    msg[1].scl_rate = CONFIG_SENSOR_I2C_SPEED;                       /* ddl@rock-chips.com : 100kHz */
+    msg[1].read_type = 2;                             /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
+
+    cnt = 3;
+    err = -EAGAIN;
+    while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
+        err = i2c_transfer(client->adapter, msg, 2);
+
+        if (err >= 0) {
+            *val = buf[0];
+            return 0;
+        } else {
+        	SENSOR_TR("\n %s read reg(0x%x val:0x%x) failed, try to read again! \n",SENSOR_NAME_STRING(),reg, *val);
+            udelay(10);
+        }
+    }
+
+    return err;
+}
+
+/* write a array of registers  */
+static int sensor_write_array(struct i2c_client *client, struct reginfo *regarray)
+{
+    int err = 0, cnt;
+    int i = 0;
+#if CONFIG_SENSOR_I2C_RDWRCHK    
+	char valchk;
+#endif
+
+	cnt = 0;
+	if (sensor_task_lock(client, 1) < 0)
+		goto sensor_write_array_end;
+    while (regarray[i].reg != 0)
+    {
+        err = sensor_write(client, regarray[i].reg, regarray[i].val);
+        if (err < 0)
+        {
+            if (cnt-- > 0) {
+			    SENSOR_TR("%s..write failed current reg:0x%x, Write array again !\n", SENSOR_NAME_STRING(),regarray[i].reg);
+				i = 0;
+				continue;
+            } else {
+                SENSOR_TR("%s..write array failed!!!\n", SENSOR_NAME_STRING());
+                err = -EPERM;
+				goto sensor_write_array_end;
+            }
+        } else {
+        #if CONFIG_SENSOR_I2C_RDWRCHK
+			sensor_read(client, regarray[i].reg, &valchk);
+			if (valchk != regarray[i].val)
+				SENSOR_TR("%s Reg:0x%x write(0x%x, 0x%x) fail\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
+		#endif
+        }
+        i++;
+    }
+
+sensor_write_array_end:
+	sensor_task_lock(client,0);
+	return err;
+}
+#if CONFIG_SENSOR_I2C_RDWRCHK
+static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regarray)
+{
+    int cnt;
+    int i = 0;
+	char valchk;
+
+	cnt = 0;
+	valchk = 0;
+    while (regarray[i].reg != 0)
+    {
+		sensor_read(client, regarray[i].reg, &valchk);
+		if (valchk != regarray[i].val)
+			SENSOR_TR("%s Reg:0x%x read(0x%x, 0x%x) error\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
+
+        i++;
+    }
+    return 0;
+}
+#endif
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
+{
+	struct soc_camera_link *icl = to_soc_camera_link(icd);
+	int ret = 0;
+
+    SENSOR_DG("%s %s  cmd(%d) on(%d)\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd,on);
+
+	switch (cmd)
+	{
+		case Sensor_PowerDown:
+		{
+			if (icl->powerdown) {
+				ret = icl->powerdown(icd->pdev, on);
+				if (ret == RK29_CAM_IO_SUCCESS) {
+					if (on == 0) {
+						mdelay(2);
+						if (icl->reset)
+							icl->reset(icd->pdev);
+					}
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
+					ret = -ENODEV;
+					goto sensor_power_end;
+				}
+			}
+			break;
+		}
+		case Sensor_Flash:
+		{
+			struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    		struct sensor *sensor = to_sensor(client);
+
+			if (sensor->sensor_io_request && sensor->sensor_io_request->sensor_ioctrl) {
+				sensor->sensor_io_request->sensor_ioctrl(icd->pdev,Cam_Flash, on);
+			}
+            break;
+		}
+		default:
+		{
+			SENSOR_TR("%s %s cmd(0x%x) is unknown!",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
+			break;
+		}
+	}
+sensor_power_end:
+	return ret;
+}
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    struct sensor *sensor = to_sensor(client);
-	const struct v4l2_queryctrl *qctrl;
-    const struct sensor_datafmt *fmt;
-    char value;
-    int ret,pid = 0;
-
-    SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
-
-	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
-		ret = -ENODEV;
-		goto sensor_INIT_ERR;
-	}
-
-    /* soft reset */
-	if (sensor_task_lock(client,1)<0)
-		goto sensor_INIT_ERR;
-    ret = sensor_write(client, 0xff, 1);
-    ret |= sensor_write(client, 0x12, 0x80);
-    if (ret != 0)
-    {
-        SENSOR_TR("%s soft reset sensor failed\n",SENSOR_NAME_STRING());
-        ret = -ENODEV;
-		goto sensor_INIT_ERR;
-    }
-
-    mdelay(5);  //delay 5 microseconds
-	/* check if it is an sensor sensor */
-    ret = sensor_write(client, 0xff, 1);
-    ret |= sensor_read(client, 0x0a, &value);
-    if (ret != 0) {
-        SENSOR_TR("read chip id high byte failed\n");
-        ret = -ENODEV;
-        goto sensor_INIT_ERR;
-    }
-
-    pid = value << 8;
-    ret = sensor_read(client, 0x0b, &value);
-    if (ret != 0) {
-        SENSOR_TR("read chip id low byte failed\n");
-        ret = -ENODEV;
-        goto sensor_INIT_ERR;
-    }
-
-    pid |= (value & 0xff);
-
-    SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
-    if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
-        sensor->model = SENSOR_V4L2_IDENT;
-    } else {
-        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
-        ret = -ENODEV;
-        goto sensor_INIT_ERR;
-    }
-
-    ret = sensor_write_array(client, sensor_init_data);
-    if (ret != 0)
-    {
-        SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
-        goto sensor_INIT_ERR;
-    }
-	sensor_task_lock(client,0);
-    sensor->info_priv.winseqe_cur_addr  = (int)SENSOR_INIT_WINSEQADR;
-    fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
-    if (!fmt) {
-        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
-        ret = -EINVAL;
-        goto sensor_INIT_ERR;
-    }
-	sensor->info_priv.fmt = *fmt;
-
-    /* sensor sensor information for initialization  */
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
-	if (qctrl)
-    	sensor->info_priv.whiteBalance = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_BRIGHTNESS);
-	if (qctrl)
-    	sensor->info_priv.brightness = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
-	if (qctrl)
-    	sensor->info_priv.effect = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EXPOSURE);
-	if (qctrl)
-        sensor->info_priv.exposure = qctrl->default_value;
-
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SATURATION);
-	if (qctrl)
-        sensor->info_priv.saturation = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_CONTRAST);
-	if (qctrl)
-        sensor->info_priv.contrast = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_HFLIP);
-	if (qctrl)
-        sensor->info_priv.mirror = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_VFLIP);
-	if (qctrl)
-        sensor->info_priv.flip = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SCENE);
-	if (qctrl)
-        sensor->info_priv.scene = qctrl->default_value;
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
-	if (qctrl)
-        sensor->info_priv.digitalzoom = qctrl->default_value;
-
-    /* ddl@rock-chips.com : if sensor support auto focus and flash, programer must run focus and flash code  */
-	#if CONFIG_SENSOR_Focus
-    sensor_set_focus();
-    qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FOCUS_ABSOLUTE);
-	if (qctrl)
-        sensor->info_priv.focus = qctrl->default_value;
-	#endif
-
-	#if CONFIG_SENSOR_Flash
-	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FLASH);
-	if (qctrl)
-        sensor->info_priv.flash = qctrl->default_value;
-    #endif
-
-    SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),((val == 0)?__FUNCTION__:"sensor_reinit"),icd->user_width,icd->user_height);
-
-    return 0;
-sensor_INIT_ERR:
-	sensor_task_lock(client,0);
-	sensor_deactivate(client);
-    return ret;
-}
-
-static int sensor_deactivate(struct i2c_client *client)
-{
-	struct soc_camera_device *icd = client->dev.platform_data;
-
-	SENSOR_DG("\n%s..%s.. Enter\n",SENSOR_NAME_STRING(),__FUNCTION__);
-
-	/* ddl@rock-chips.com : all sensor output pin must change to input for other sensor */
-#if 0	
-	sensor_task_lock(client, 1);
-    sensor_write(client, 0x3000, reg_val&0xfc);
-	sensor_write(client, 0x3001, 0x00);
-	sensor_task_lock(client, 0);
-#endif
-	sensor_ioctrl(icd, Sensor_PowerDown, 1);
-	/* ddl@rock-chips.com : sensor config init width , because next open sensor quickly(soc_camera_open -> Try to configure with default parameters) */
-	icd->user_width = SENSOR_INIT_WIDTH;
-    icd->user_height = SENSOR_INIT_HEIGHT;
-	msleep(100);
-	return 0;
-}
-
-static  struct reginfo sensor_power_down_sequence[]=
-{
-    {0x00,0x00}
-};
-static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)
-{
-    int ret;
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if (pm_msg.event == PM_EVENT_SUSPEND) {
-        SENSOR_DG("\n %s Enter Suspend.. \n", SENSOR_NAME_STRING());
-        ret = sensor_write_array(client, sensor_power_down_sequence) ;
-        if (ret != 0) {
-            SENSOR_TR("\n %s..%s WriteReg Fail.. \n", SENSOR_NAME_STRING(),__FUNCTION__);
-            return ret;
-        } else {
-            ret = sensor_ioctrl(icd, Sensor_PowerDown, 1);
-            if (ret < 0) {
-			    SENSOR_TR("\n %s suspend fail for turn on power!\n", SENSOR_NAME_STRING());
-                return -EINVAL;
-            }
-        }
-    } else {
-        SENSOR_TR("\n %s cann't suppout Suspend..\n",SENSOR_NAME_STRING());
-        return -EINVAL;
-    }
-    return 0;
-}
-
-static int sensor_resume(struct soc_camera_device *icd)
-{
-	int ret;
-
-    ret = sensor_ioctrl(icd, Sensor_PowerDown, 0);
-    if (ret < 0) {
-		SENSOR_TR("\n %s resume fail for turn on power!\n", SENSOR_NAME_STRING());
-        return -EINVAL;
-    }
-
-	SENSOR_DG("\n %s Enter Resume.. \n", SENSOR_NAME_STRING());
-
-    return 0;
-
-}
-
-static int sensor_set_bus_param(struct soc_camera_device *icd,
-                                unsigned long flags)
-{
-
-    return 0;
-}
-
-static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
-{
-    struct soc_camera_link *icl = to_soc_camera_link(icd);
-    unsigned long flags = SENSOR_BUS_PARAM;
-
-    return soc_camera_apply_sensor_flags(icl, flags);
-}
-
-static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct sensor *sensor = to_sensor(client);
+	const struct v4l2_queryctrl *qctrl;
+    const struct sensor_datafmt *fmt;
+    char value;
+    int ret,pid = 0;
+
+    SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
+
+	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
+		ret = -ENODEV;
+		goto sensor_INIT_ERR;
+	}
+
+    /* soft reset */
+	if (sensor_task_lock(client,1)<0)
+		goto sensor_INIT_ERR;
+    ret = sensor_write(client, 0xff, 1);
+    ret |= sensor_write(client, 0x12, 0x80);
+    if (ret != 0)
+    {
+        SENSOR_TR("%s soft reset sensor failed\n",SENSOR_NAME_STRING());
+        ret = -ENODEV;
+		goto sensor_INIT_ERR;
+    }
+
+    mdelay(5);  //delay 5 microseconds
+	/* check if it is an sensor sensor */
+    ret = sensor_write(client, 0xff, 1);
+    ret |= sensor_read(client, 0x0a, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id high byte failed\n");
+        ret = -ENODEV;
+        goto sensor_INIT_ERR;
+    }
+
+    pid = value << 8;
+    ret = sensor_read(client, 0x0b, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id low byte failed\n");
+        ret = -ENODEV;
+        goto sensor_INIT_ERR;
+    }
+
+    pid |= (value & 0xff);
+
+    SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+    if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
+        sensor->model = SENSOR_V4L2_IDENT;
+    } else {
+        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+        ret = -ENODEV;
+        goto sensor_INIT_ERR;
+    }
+
+    ret = sensor_write_array(client, sensor_init_data);
+    if (ret != 0)
+    {
+        SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
+        goto sensor_INIT_ERR;
+    }
+	sensor_task_lock(client,0);
+    sensor->info_priv.winseqe_cur_addr  = (int)SENSOR_INIT_WINSEQADR;
+    fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
+    if (!fmt) {
+        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
+        ret = -EINVAL;
+        goto sensor_INIT_ERR;
+    }
+	sensor->info_priv.fmt = *fmt;
+
+    /* sensor sensor information for initialization  */
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
+	if (qctrl)
+    	sensor->info_priv.whiteBalance = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_BRIGHTNESS);
+	if (qctrl)
+    	sensor->info_priv.brightness = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
+	if (qctrl)
+    	sensor->info_priv.effect = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EXPOSURE);
+	if (qctrl)
+        sensor->info_priv.exposure = qctrl->default_value;
+
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SATURATION);
+	if (qctrl)
+        sensor->info_priv.saturation = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_CONTRAST);
+	if (qctrl)
+        sensor->info_priv.contrast = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_HFLIP);
+	if (qctrl)
+        sensor->info_priv.mirror = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_VFLIP);
+	if (qctrl)
+        sensor->info_priv.flip = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SCENE);
+	if (qctrl)
+        sensor->info_priv.scene = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
+	if (qctrl)
+        sensor->info_priv.digitalzoom = qctrl->default_value;
+
+    /* ddl@rock-chips.com : if sensor support auto focus and flash, programer must run focus and flash code  */
+	#if CONFIG_SENSOR_Focus
+    sensor_set_focus();
+    qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FOCUS_ABSOLUTE);
+	if (qctrl)
+        sensor->info_priv.focus = qctrl->default_value;
+	#endif
+
+	#if CONFIG_SENSOR_Flash
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FLASH);
+	if (qctrl)
+        sensor->info_priv.flash = qctrl->default_value;
+    #endif
+
+    SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),((val == 0)?__FUNCTION__:"sensor_reinit"),icd->user_width,icd->user_height);
+
+    return 0;
+sensor_INIT_ERR:
+	sensor_task_lock(client,0);
+	sensor_deactivate(client);
+    return ret;
+}
+
+static int sensor_deactivate(struct i2c_client *client)
+{
+	struct soc_camera_device *icd = client->dev.platform_data;
+
+	SENSOR_DG("\n%s..%s.. Enter\n",SENSOR_NAME_STRING(),__FUNCTION__);
+
+	/* ddl@rock-chips.com : all sensor output pin must change to input for other sensor */
+#if 0	
+	sensor_task_lock(client, 1);
+    sensor_write(client, 0x3000, reg_val&0xfc);
+	sensor_write(client, 0x3001, 0x00);
+	sensor_task_lock(client, 0);
+#endif
+	sensor_ioctrl(icd, Sensor_PowerDown, 1);
+	/* ddl@rock-chips.com : sensor config init width , because next open sensor quickly(soc_camera_open -> Try to configure with default parameters) */
+	icd->user_width = SENSOR_INIT_WIDTH;
+    icd->user_height = SENSOR_INIT_HEIGHT;
+	msleep(100);
+	return 0;
+}
+
+static  struct reginfo sensor_power_down_sequence[]=
+{
+    {0x00,0x00}
+};
+static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)
+{
+    int ret;
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if (pm_msg.event == PM_EVENT_SUSPEND) {
+        SENSOR_DG("\n %s Enter Suspend.. \n", SENSOR_NAME_STRING());
+        ret = sensor_write_array(client, sensor_power_down_sequence) ;
+        if (ret != 0) {
+            SENSOR_TR("\n %s..%s WriteReg Fail.. \n", SENSOR_NAME_STRING(),__FUNCTION__);
+            return ret;
+        } else {
+            ret = sensor_ioctrl(icd, Sensor_PowerDown, 1);
+            if (ret < 0) {
+			    SENSOR_TR("\n %s suspend fail for turn on power!\n", SENSOR_NAME_STRING());
+                return -EINVAL;
+            }
+        }
+    } else {
+        SENSOR_TR("\n %s cann't suppout Suspend..\n",SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+    return 0;
+}
+
+static int sensor_resume(struct soc_camera_device *icd)
+{
+	int ret;
+
+    ret = sensor_ioctrl(icd, Sensor_PowerDown, 0);
+    if (ret < 0) {
+		SENSOR_TR("\n %s resume fail for turn on power!\n", SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+
+	SENSOR_DG("\n %s Enter Resume.. \n", SENSOR_NAME_STRING());
+
+    return 0;
+
+}
+
+static int sensor_set_bus_param(struct soc_camera_device *icd,
+                                unsigned long flags)
+{
+
+    return 0;
+}
+
+static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
+{
+    struct soc_camera_link *icl = to_soc_camera_link(icd);
+    unsigned long flags = SENSOR_BUS_PARAM;
+
+    return soc_camera_apply_sensor_flags(icl, flags);
+}
+
+static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    struct sensor *sensor = to_sensor(client);
-
-    mf->width	= icd->user_width;
-	mf->height	= icd->user_height;
-	mf->code	= sensor->info_priv.fmt.code;
-	mf->colorspace	= sensor->info_priv.fmt.colorspace;
-	mf->field	= V4L2_FIELD_NONE;
-
-    return 0;
-}
-static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    bool ret = false;
-
-	if ((mf->width == 1024) && (mf->height == 768)) {
-		ret = true;
-	} else if ((mf->width == 1280) && (mf->height == 1024)) {
-		ret = true;
-	} else if ((mf->width == 1600) && (mf->height == 1200)) {
-		ret = true;
-	} else if ((mf->width == 2048) && (mf->height == 1536)) {
-		ret = true;
-	} else if ((mf->width == 2592) && (mf->height == 1944)) {
-		ret = true;
-	}
-
-	if (ret == true)
-		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
-	return ret;
-}
-
-static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    bool ret = false;
-
-	if ((mf->width == 1280) && (mf->height == 720)) {
-		ret = true;
-	} else if ((mf->width == 1920) && (mf->height == 1080)) {
-		ret = true;
-	}
-
-	if (ret == true)
-		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
-	return ret;
-}
-static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct sensor *sensor = to_sensor(client);
+
+    mf->width	= icd->user_width;
+	mf->height	= icd->user_height;
+	mf->code	= sensor->info_priv.fmt.code;
+	mf->colorspace	= sensor->info_priv.fmt.colorspace;
+	mf->field	= V4L2_FIELD_NONE;
+
+    return 0;
+}
+static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    bool ret = false;
+
+	if ((mf->width == 1024) && (mf->height == 768)) {
+		ret = true;
+	} else if ((mf->width == 1280) && (mf->height == 1024)) {
+		ret = true;
+	} else if ((mf->width == 1600) && (mf->height == 1200)) {
+		ret = true;
+	} else if ((mf->width == 2048) && (mf->height == 1536)) {
+		ret = true;
+	} else if ((mf->width == 2592) && (mf->height == 1944)) {
+		ret = true;
+	}
+
+	if (ret == true)
+		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
+	return ret;
+}
+
+static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    bool ret = false;
+
+	if ((mf->width == 1280) && (mf->height == 720)) {
+		ret = true;
+	} else if ((mf->width == 1920) && (mf->height == 1080)) {
+		ret = true;
+	}
+
+	if (ret == true)
+		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
+	return ret;
+}
+static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct sensor *sensor = to_sensor(client);
-    const struct sensor_datafmt *fmt;
-	const struct v4l2_queryctrl *qctrl;
-	struct soc_camera_device *icd = client->dev.platform_data;
-    struct reginfo *winseqe_set_addr=NULL;
-    int ret=0, set_w,set_h;
-
-	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
-				   ARRAY_SIZE(sensor_colour_fmts));
-	if (!fmt) {
-        ret = -EINVAL;
-        goto sensor_s_fmt_end;
-    }
-
-	if (sensor->info_priv.fmt.code != mf->code) {
-		switch (mf->code)
-		{
-			case V4L2_MBUS_FMT_YUYV8_2X8:
-			{
-				winseqe_set_addr = sensor_ClrFmt_YUYV;
-				break;
-			}
-			case V4L2_MBUS_FMT_UYVY8_2X8:
-			{
-				winseqe_set_addr = sensor_ClrFmt_UYVY;
-				break;
-			}
-			default:
-				break;
-		}
-		if (winseqe_set_addr != NULL) {
-            sensor_write_array(client, winseqe_set_addr);
-			sensor->info_priv.fmt.code = mf->code;
-            sensor->info_priv.fmt.colorspace= mf->colorspace;            
-			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
-		} else {
-			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
-		}
-	}
-
-    set_w = mf->width;
-    set_h = mf->height;
-
-	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
-	{
-		winseqe_set_addr = sensor_qcif;
-        set_w = 176;
-        set_h = 144;
-	}
-	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
-    {
-        winseqe_set_addr = sensor_qvga;
-        set_w = 320;
-        set_h = 240;
-    }
-    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
-    {
-        winseqe_set_addr = sensor_cif;
-        set_w = 352;
-        set_h = 288;
-    }
-    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
-    {
-        winseqe_set_addr = sensor_vga;
-        set_w = 640;
-        set_h = 480;
-    }
-    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
-    {
-        winseqe_set_addr = sensor_svga;
-        set_w = 800;
-        set_h = 600;
-    }
-	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
-    {
-        winseqe_set_addr = sensor_xga;
-        set_w = 1024;
-        set_h = 768;
-    }
-    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
-    {
-        winseqe_set_addr = sensor_sxga;
-        set_w = 1280;
-        set_h = 1024;
-    }
-    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
-    {
-        winseqe_set_addr = sensor_uxga;
-        set_w = 1600;
-        set_h = 1200;
-    }
-    else
-    {
-        winseqe_set_addr = SENSOR_INIT_WINSEQADR;               /* ddl@rock-chips.com : Sensor output smallest size if  isn't support app  */
-        set_w = SENSOR_INIT_WIDTH;
-        set_h = SENSOR_INIT_HEIGHT;
-		SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,mf->width,mf->height);
-    }
-
-    if ((int)winseqe_set_addr  != sensor->info_priv.winseqe_cur_addr) {
-        #if CONFIG_SENSOR_Flash
-        if (sensor_fmt_capturechk(sd,mf) == true) {      /* ddl@rock-chips.com : Capture */
-            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
-                sensor_ioctrl(icd, Sensor_Flash, Flash_On);
-                SENSOR_DG("%s flash on in capture!\n", SENSOR_NAME_STRING());
-            }           
-        } else {                                        /* ddl@rock-chips.com : Video */
-            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
-                sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
-                SENSOR_DG("%s flash off in preivew!\n", SENSOR_NAME_STRING());
-            }
-        }
-        #endif        
-        ret |= sensor_write_array(client, winseqe_set_addr);
-        if (ret != 0) {
-            SENSOR_TR("%s set format capability failed\n", SENSOR_NAME_STRING());
-            #if CONFIG_SENSOR_Flash
-            if (sensor_fmt_capturechk(sd,mf) == true) {
-                if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
-                    sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
-                    SENSOR_TR("%s Capture format set fail, flash off !\n", SENSOR_NAME_STRING());
-                }
-            }
-            #endif
-            goto sensor_s_fmt_end;
-        }
-
-        sensor->info_priv.winseqe_cur_addr  = (int)winseqe_set_addr;
-
-		if (sensor_fmt_capturechk(sd,mf) == true) {				    /* ddl@rock-chips.com : Capture */
-        #if CONFIG_SENSOR_Effect
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
-			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
-        #endif
-        #if CONFIG_SENSOR_WhiteBalance
-			if (sensor->info_priv.whiteBalance != 0) {
-				qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
-				sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
-			}
-        #endif
-			sensor->info_priv.snap2preview = true;
-		} else if (sensor_fmt_videochk(sd,mf) == true) {			/* ddl@rock-chips.com : Video */
-		#if CONFIG_SENSOR_Effect
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
-			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
-        #endif
-        #if CONFIG_SENSOR_WhiteBalance
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
-			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
-        #endif
-			sensor->info_priv.video2preview = true;
-		} else if ((sensor->info_priv.snap2preview == true) || (sensor->info_priv.video2preview == true)) {
-		#if CONFIG_SENSOR_Effect
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
-			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
-        #endif
-        #if CONFIG_SENSOR_WhiteBalance    
-			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
-			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
-        #endif    
-			sensor->info_priv.video2preview = false;            
-			sensor->info_priv.snap2preview = false;
-		}
-        SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),__FUNCTION__,set_w,set_h);
-    }
-    else
-    {
-        SENSOR_DG("\n %s .. Current Format is validate. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),set_w,set_h);
-    }
-
-	mf->width = set_w;
-    mf->height = set_h;
-
-sensor_s_fmt_end:
-    return ret;
-}
-
-static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
+    struct sensor *sensor = to_sensor(client);
+    const struct sensor_datafmt *fmt;
+	const struct v4l2_queryctrl *qctrl;
+	struct soc_camera_device *icd = client->dev.platform_data;
+    struct reginfo *winseqe_set_addr=NULL;
+    int ret=0, set_w,set_h;
+
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (!fmt) {
+        ret = -EINVAL;
+        goto sensor_s_fmt_end;
+    }
+
+	if (sensor->info_priv.fmt.code != mf->code) {
+		switch (mf->code)
+		{
+			case V4L2_MBUS_FMT_YUYV8_2X8:
+			{
+				winseqe_set_addr = sensor_ClrFmt_YUYV;
+				break;
+			}
+			case V4L2_MBUS_FMT_UYVY8_2X8:
+			{
+				winseqe_set_addr = sensor_ClrFmt_UYVY;
+				break;
+			}
+			default:
+				break;
+		}
+		if (winseqe_set_addr != NULL) {
+            sensor_write_array(client, winseqe_set_addr);
+			sensor->info_priv.fmt.code = mf->code;
+            sensor->info_priv.fmt.colorspace= mf->colorspace;            
+			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
+		} else {
+			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
+		}
+	}
+
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+		winseqe_set_addr = sensor_qcif;
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        winseqe_set_addr = sensor_qvga;
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        winseqe_set_addr = sensor_cif;
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        winseqe_set_addr = sensor_vga;
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        winseqe_set_addr = sensor_svga;
+        set_w = 800;
+        set_h = 600;
+    }
+	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
+    {
+        winseqe_set_addr = sensor_xga;
+        set_w = 1024;
+        set_h = 768;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {
+        winseqe_set_addr = sensor_sxga;
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
+    {
+        winseqe_set_addr = sensor_uxga;
+        set_w = 1600;
+        set_h = 1200;
+    }
+    else
+    {
+        winseqe_set_addr = SENSOR_INIT_WINSEQADR;               /* ddl@rock-chips.com : Sensor output smallest size if  isn't support app  */
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;
+		SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,mf->width,mf->height);
+    }
+
+    if ((int)winseqe_set_addr  != sensor->info_priv.winseqe_cur_addr) {
+        #if CONFIG_SENSOR_Flash
+        if (sensor_fmt_capturechk(sd,mf) == true) {      /* ddl@rock-chips.com : Capture */
+            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
+                sensor_ioctrl(icd, Sensor_Flash, Flash_On);
+                SENSOR_DG("%s flash on in capture!\n", SENSOR_NAME_STRING());
+            }           
+        } else {                                        /* ddl@rock-chips.com : Video */
+            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
+                sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
+                SENSOR_DG("%s flash off in preivew!\n", SENSOR_NAME_STRING());
+            }
+        }
+        #endif        
+        ret |= sensor_write_array(client, winseqe_set_addr);
+        if (ret != 0) {
+            SENSOR_TR("%s set format capability failed\n", SENSOR_NAME_STRING());
+            #if CONFIG_SENSOR_Flash
+            if (sensor_fmt_capturechk(sd,mf) == true) {
+                if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
+                    sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
+                    SENSOR_TR("%s Capture format set fail, flash off !\n", SENSOR_NAME_STRING());
+                }
+            }
+            #endif
+            goto sensor_s_fmt_end;
+        }
+
+        sensor->info_priv.winseqe_cur_addr  = (int)winseqe_set_addr;
+
+		if (sensor_fmt_capturechk(sd,mf) == true) {				    /* ddl@rock-chips.com : Capture */
+        #if CONFIG_SENSOR_Effect
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
+			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
+        #endif
+        #if CONFIG_SENSOR_WhiteBalance
+			if (sensor->info_priv.whiteBalance != 0) {
+				qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
+				sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
+			}
+        #endif
+			sensor->info_priv.snap2preview = true;
+		} else if (sensor_fmt_videochk(sd,mf) == true) {			/* ddl@rock-chips.com : Video */
+		#if CONFIG_SENSOR_Effect
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
+			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
+        #endif
+        #if CONFIG_SENSOR_WhiteBalance
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
+			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
+        #endif
+			sensor->info_priv.video2preview = true;
+		} else if ((sensor->info_priv.snap2preview == true) || (sensor->info_priv.video2preview == true)) {
+		#if CONFIG_SENSOR_Effect
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
+			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
+        #endif
+        #if CONFIG_SENSOR_WhiteBalance    
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
+			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
+        #endif    
+			sensor->info_priv.video2preview = false;            
+			sensor->info_priv.snap2preview = false;
+		}
+        SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),__FUNCTION__,set_w,set_h);
+    }
+    else
+    {
+        SENSOR_DG("\n %s .. Current Format is validate. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),set_w,set_h);
+    }
+
+	mf->width = set_w;
+    mf->height = set_h;
+
+sensor_s_fmt_end:
+    return ret;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct sensor *sensor = to_sensor(client);
-    const struct sensor_datafmt *fmt;
-    int ret = 0;
-   
-	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
-				   ARRAY_SIZE(sensor_colour_fmts));
-	if (fmt == NULL) {
-		fmt = &sensor->info_priv.fmt;
-        mf->code = fmt->code;
-	} 
-
-    if (mf->height > SENSOR_MAX_HEIGHT)
-        mf->height = SENSOR_MAX_HEIGHT;
-    else if (mf->height < SENSOR_MIN_HEIGHT)
-        mf->height = SENSOR_MIN_HEIGHT;
-
-    if (mf->width > SENSOR_MAX_WIDTH)
-        mf->width = SENSOR_MAX_WIDTH;
-    else if (mf->width < SENSOR_MIN_WIDTH)
-        mf->width = SENSOR_MIN_WIDTH;
-
-    mf->colorspace = fmt->colorspace;
-    
-    return ret;
-}
- static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
-{
+    struct sensor *sensor = to_sensor(client);
+    const struct sensor_datafmt *fmt;
+    int ret = 0;
+   
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (fmt == NULL) {
+		fmt = &sensor->info_priv.fmt;
+        mf->code = fmt->code;
+	} 
+
+    if (mf->height > SENSOR_MAX_HEIGHT)
+        mf->height = SENSOR_MAX_HEIGHT;
+    else if (mf->height < SENSOR_MIN_HEIGHT)
+        mf->height = SENSOR_MIN_HEIGHT;
+
+    if (mf->width > SENSOR_MAX_WIDTH)
+        mf->width = SENSOR_MAX_WIDTH;
+    else if (mf->width < SENSOR_MIN_WIDTH)
+        mf->width = SENSOR_MIN_WIDTH;
+
+    mf->colorspace = fmt->colorspace;
+    
+    return ret;
+}
+ static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-    if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
-        return -EINVAL;
-
-    if (id->match.addr != client->addr)
-        return -ENODEV;
-
-    id->ident = SENSOR_V4L2_IDENT;      /* ddl@rock-chips.com :  Return OV2655  identifier */
-    id->revision = 0;
-
-    return 0;
-}
-#if CONFIG_SENSOR_Brightness
-static int sensor_set_brightness(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_BrightnessSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_BrightnessSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Effect
-static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_EffectSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_EffectSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Exposure
-static int sensor_set_exposure(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_ExposureSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_ExposureSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Saturation
-static int sensor_set_saturation(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_SaturationSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_SaturationSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Contrast
-static int sensor_set_contrast(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_ContrastSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_ContrastSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Mirror
-static int sensor_set_mirror(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_MirrorSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_MirrorSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Flip
-static int sensor_set_flip(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_FlipSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_FlipSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Scene
-static int sensor_set_scene(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_SceneSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_SceneSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_WhiteBalance
-static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
-    {
-        if (sensor_WhiteBalanceSeqe[value - qctrl->minimum] != NULL)
-        {
-            if (sensor_write_array(client, sensor_WhiteBalanceSeqe[value - qctrl->minimum]) != 0)
-            {
-                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-                return -EINVAL;
-            }
-            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-            return 0;
-        }
-    }
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_DigitalZoom
-static int sensor_set_digitalzoom(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int *value)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    struct sensor *sensor = to_sensor(client);
-	const struct v4l2_queryctrl *qctrl_info;
-    int digitalzoom_cur, digitalzoom_total;
-
-	qctrl_info = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
-	if (qctrl_info)
-		return -EINVAL;
-
-    digitalzoom_cur = sensor->info_priv.digitalzoom;
-    digitalzoom_total = qctrl_info->maximum;
-
-    if ((*value > 0) && (digitalzoom_cur >= digitalzoom_total))
-    {
-        SENSOR_TR("%s digitalzoom is maximum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
-        return -EINVAL;
-    }
-
-    if  ((*value < 0) && (digitalzoom_cur <= qctrl_info->minimum))
-    {
-        SENSOR_TR("%s digitalzoom is minimum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
-        return -EINVAL;
-    }
-
-    if ((*value > 0) && ((digitalzoom_cur + *value) > digitalzoom_total))
-    {
-        *value = digitalzoom_total - digitalzoom_cur;
-    }
-
-    if ((*value < 0) && ((digitalzoom_cur + *value) < 0))
-    {
-        *value = 0 - digitalzoom_cur;
-    }
-
-    digitalzoom_cur += *value;
-
-    if (sensor_ZoomSeqe[digitalzoom_cur] != NULL)
-    {
-        if (sensor_write_array(client, sensor_ZoomSeqe[digitalzoom_cur]) != 0)
-        {
-            SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
-            return -EINVAL;
-        }
-        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, *value);
-        return 0;
-    }
-
-    return -EINVAL;
-}
-#endif
-#if CONFIG_SENSOR_Flash
-static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
-{    
-    if ((value >= qctrl->minimum) && (value <= qctrl->maximum)) {
-        if (value == 3) {       /* ddl@rock-chips.com: torch */
-            sensor_ioctrl(icd, Sensor_Flash, Flash_Torch);   /* Flash On */
-        } else {
-            sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
-        }
-        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
-        return 0;
-    }
-    
-	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
-    return -EINVAL;
-}
-#endif
-
-static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
+
+    if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
+        return -EINVAL;
+
+    if (id->match.addr != client->addr)
+        return -ENODEV;
+
+    id->ident = SENSOR_V4L2_IDENT;      /* ddl@rock-chips.com :  Return OV2655  identifier */
+    id->revision = 0;
+
+    return 0;
+}
+#if CONFIG_SENSOR_Brightness
+static int sensor_set_brightness(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_BrightnessSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_BrightnessSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Effect
+static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_EffectSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_EffectSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Exposure
+static int sensor_set_exposure(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_ExposureSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_ExposureSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Saturation
+static int sensor_set_saturation(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_SaturationSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_SaturationSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Contrast
+static int sensor_set_contrast(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_ContrastSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_ContrastSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Mirror
+static int sensor_set_mirror(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_MirrorSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_MirrorSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Flip
+static int sensor_set_flip(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_FlipSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_FlipSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Scene
+static int sensor_set_scene(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_SceneSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_SceneSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_WhiteBalance
+static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_WhiteBalanceSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_WhiteBalanceSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_DigitalZoom
+static int sensor_set_digitalzoom(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int *value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct sensor *sensor = to_sensor(client);
+	const struct v4l2_queryctrl *qctrl_info;
+    int digitalzoom_cur, digitalzoom_total;
+
+	qctrl_info = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
+	if (qctrl_info)
+		return -EINVAL;
+
+    digitalzoom_cur = sensor->info_priv.digitalzoom;
+    digitalzoom_total = qctrl_info->maximum;
+
+    if ((*value > 0) && (digitalzoom_cur >= digitalzoom_total))
+    {
+        SENSOR_TR("%s digitalzoom is maximum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
+        return -EINVAL;
+    }
+
+    if  ((*value < 0) && (digitalzoom_cur <= qctrl_info->minimum))
+    {
+        SENSOR_TR("%s digitalzoom is minimum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
+        return -EINVAL;
+    }
+
+    if ((*value > 0) && ((digitalzoom_cur + *value) > digitalzoom_total))
+    {
+        *value = digitalzoom_total - digitalzoom_cur;
+    }
+
+    if ((*value < 0) && ((digitalzoom_cur + *value) < 0))
+    {
+        *value = 0 - digitalzoom_cur;
+    }
+
+    digitalzoom_cur += *value;
+
+    if (sensor_ZoomSeqe[digitalzoom_cur] != NULL)
+    {
+        if (sensor_write_array(client, sensor_ZoomSeqe[digitalzoom_cur]) != 0)
+        {
+            SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+            return -EINVAL;
+        }
+        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, *value);
+        return 0;
+    }
+
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Flash
+static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{    
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum)) {
+        if (value == 3) {       /* ddl@rock-chips.com: torch */
+            sensor_ioctrl(icd, Sensor_Flash, Flash_Torch);   /* Flash On */
+        } else {
+            sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
+        }
+        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+        return 0;
+    }
+    
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+
+static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct sensor *sensor = to_sensor(client);
-    const struct v4l2_queryctrl *qctrl;
-
-    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
-
-    if (!qctrl)
-    {
-        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
-        return -EINVAL;
-    }
-
-    switch (ctrl->id)
-    {
-        case V4L2_CID_BRIGHTNESS:
-            {
-                ctrl->value = sensor->info_priv.brightness;
-                break;
-            }
-        case V4L2_CID_SATURATION:
-            {
-                ctrl->value = sensor->info_priv.saturation;
-                break;
-            }
-        case V4L2_CID_CONTRAST:
-            {
-                ctrl->value = sensor->info_priv.contrast;
-                break;
-            }
-        case V4L2_CID_DO_WHITE_BALANCE:
-            {
-                ctrl->value = sensor->info_priv.whiteBalance;
-                break;
-            }
-        case V4L2_CID_EXPOSURE:
-            {
-                ctrl->value = sensor->info_priv.exposure;
-                break;
-            }
-        case V4L2_CID_HFLIP:
-            {
-                ctrl->value = sensor->info_priv.mirror;
-                break;
-            }
-        case V4L2_CID_VFLIP:
-            {
-                ctrl->value = sensor->info_priv.flip;
-                break;
-            }
-        default :
-                break;
-    }
-    return 0;
-}
-
-
-
-static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
+    struct sensor *sensor = to_sensor(client);
+    const struct v4l2_queryctrl *qctrl;
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
+        return -EINVAL;
+    }
+
+    switch (ctrl->id)
+    {
+        case V4L2_CID_BRIGHTNESS:
+            {
+                ctrl->value = sensor->info_priv.brightness;
+                break;
+            }
+        case V4L2_CID_SATURATION:
+            {
+                ctrl->value = sensor->info_priv.saturation;
+                break;
+            }
+        case V4L2_CID_CONTRAST:
+            {
+                ctrl->value = sensor->info_priv.contrast;
+                break;
+            }
+        case V4L2_CID_DO_WHITE_BALANCE:
+            {
+                ctrl->value = sensor->info_priv.whiteBalance;
+                break;
+            }
+        case V4L2_CID_EXPOSURE:
+            {
+                ctrl->value = sensor->info_priv.exposure;
+                break;
+            }
+        case V4L2_CID_HFLIP:
+            {
+                ctrl->value = sensor->info_priv.mirror;
+                break;
+            }
+        case V4L2_CID_VFLIP:
+            {
+                ctrl->value = sensor->info_priv.flip;
+                break;
+            }
+        default :
+                break;
+    }
+    return 0;
+}
+
+
+
+static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct sensor *sensor = to_sensor(client);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    const struct v4l2_queryctrl *qctrl;
-
-
-    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
-
-    if (!qctrl)
-    {
-        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
-        return -EINVAL;
-    }
-
-    switch (ctrl->id)
-    {
-#if CONFIG_SENSOR_Brightness
-        case V4L2_CID_BRIGHTNESS:
-            {
-                if (ctrl->value != sensor->info_priv.brightness)
-                {
-                    if (sensor_set_brightness(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.brightness = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Exposure
-        case V4L2_CID_EXPOSURE:
-            {
-                if (ctrl->value != sensor->info_priv.exposure)
-                {
-                    if (sensor_set_exposure(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.exposure = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Saturation
-        case V4L2_CID_SATURATION:
-            {
-                if (ctrl->value != sensor->info_priv.saturation)
-                {
-                    if (sensor_set_saturation(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.saturation = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Contrast
-        case V4L2_CID_CONTRAST:
-            {
-                if (ctrl->value != sensor->info_priv.contrast)
-                {
-                    if (sensor_set_contrast(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.contrast = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_WhiteBalance
-        case V4L2_CID_DO_WHITE_BALANCE:
-            {
-                if (ctrl->value != sensor->info_priv.whiteBalance)
-                {
-                    if (sensor_set_whiteBalance(icd, qctrl,ctrl->value) != 0)
-                    {
-                        return -EINVAL;
-                    }
-                    sensor->info_priv.whiteBalance = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Mirror
-        case V4L2_CID_HFLIP:
-            {
-                if (ctrl->value != sensor->info_priv.mirror)
-                {
-                    if (sensor_set_mirror(icd, qctrl,ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.mirror = ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Flip
-        case V4L2_CID_VFLIP:
-            {
-                if (ctrl->value != sensor->info_priv.flip)
-                {
-                    if (sensor_set_flip(icd, qctrl,ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.flip = ctrl->value;
-                }
-                break;
-            }
-#endif
-        default:
-            break;
-    }
-
-    return 0;
-}
-static int sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)
-{
-    const struct v4l2_queryctrl *qctrl;
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    struct sensor *sensor = to_sensor(client);
-
-    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
-
-    if (!qctrl)
-    {
-        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
-        return -EINVAL;
-    }
-
-    switch (ext_ctrl->id)
-    {
-        case V4L2_CID_SCENE:
-            {
-                ext_ctrl->value = sensor->info_priv.scene;
-                break;
-            }
-        case V4L2_CID_EFFECT:
-            {
-                ext_ctrl->value = sensor->info_priv.effect;
-                break;
-            }
-        case V4L2_CID_ZOOM_ABSOLUTE:
-            {
-                ext_ctrl->value = sensor->info_priv.digitalzoom;
-                break;
-            }
-        case V4L2_CID_ZOOM_RELATIVE:
-            {
-                return -EINVAL;
-            }
-        case V4L2_CID_FOCUS_ABSOLUTE:
-            {
-                ext_ctrl->value = sensor->info_priv.focus;
-                break;
-            }
-        case V4L2_CID_FOCUS_RELATIVE:
-            {
-                return -EINVAL;
-            }
-        case V4L2_CID_FLASH:
-            {
-                ext_ctrl->value = sensor->info_priv.flash;
-                break;
-            }
-        default :
-            break;
-    }
-    return 0;
-}
-static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)
-{
-    const struct v4l2_queryctrl *qctrl;
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    struct sensor *sensor = to_sensor(client);
-    int val_offset;
-
-    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
-
-    if (!qctrl)
-    {
-        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
-        return -EINVAL;
-    }
-
-	val_offset = 0;
-    switch (ext_ctrl->id)
-    {
-#if CONFIG_SENSOR_Scene
-        case V4L2_CID_SCENE:
-            {
-                if (ext_ctrl->value != sensor->info_priv.scene)
-                {
-                    if (sensor_set_scene(icd, qctrl,ext_ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.scene = ext_ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Effect
-        case V4L2_CID_EFFECT:
-            {
-                if (ext_ctrl->value != sensor->info_priv.effect)
-                {
-                    if (sensor_set_effect(icd, qctrl,ext_ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.effect= ext_ctrl->value;
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_DigitalZoom
-        case V4L2_CID_ZOOM_ABSOLUTE:
-            {
-                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
-                    return -EINVAL;
-
-                if (ext_ctrl->value != sensor->info_priv.digitalzoom)
-                {
-                    val_offset = ext_ctrl->value -sensor->info_priv.digitalzoom;
-
-                    if (sensor_set_digitalzoom(icd, qctrl,&val_offset) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.digitalzoom += val_offset;
-
-                    SENSOR_DG("%s digitalzoom is %x\n",SENSOR_NAME_STRING(),  sensor->info_priv.digitalzoom);
-                }
-
-                break;
-            }
-        case V4L2_CID_ZOOM_RELATIVE:
-            {
-                if (ext_ctrl->value)
-                {
-                    if (sensor_set_digitalzoom(icd, qctrl,&ext_ctrl->value) != 0)
-                        return -EINVAL;
-                    sensor->info_priv.digitalzoom += ext_ctrl->value;
-
-                    SENSOR_DG("%s digitalzoom is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.digitalzoom);
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Focus
-        case V4L2_CID_FOCUS_ABSOLUTE:
-            {
-                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
-                    return -EINVAL;
-
-                if (ext_ctrl->value != sensor->info_priv.focus)
-                {
-                    val_offset = ext_ctrl->value -sensor->info_priv.focus;
-
-                    sensor->info_priv.focus += val_offset;
-                }
-
-                break;
-            }
-        case V4L2_CID_FOCUS_RELATIVE:
-            {
-                if (ext_ctrl->value)
-                {
-                    sensor->info_priv.focus += ext_ctrl->value;
-
-                    SENSOR_DG("%s focus is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.focus);
-                }
-                break;
-            }
-#endif
-#if CONFIG_SENSOR_Flash
-        case V4L2_CID_FLASH:
-            {
-                if (sensor_set_flash(icd, qctrl,ext_ctrl->value) != 0)
-                    return -EINVAL;
-                sensor->info_priv.flash = ext_ctrl->value;
-
-                SENSOR_DG("%s flash is %x\n",SENSOR_NAME_STRING(), sensor->info_priv.flash);
-                break;
-            }
-#endif
-        default:
-            break;
-    }
-
-    return 0;
-}
-
-static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
-{
+    struct sensor *sensor = to_sensor(client);
+    struct soc_camera_device *icd = client->dev.platform_data;
+    const struct v4l2_queryctrl *qctrl;
+
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
+        return -EINVAL;
+    }
+
+    switch (ctrl->id)
+    {
+#if CONFIG_SENSOR_Brightness
+        case V4L2_CID_BRIGHTNESS:
+            {
+                if (ctrl->value != sensor->info_priv.brightness)
+                {
+                    if (sensor_set_brightness(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.brightness = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Exposure
+        case V4L2_CID_EXPOSURE:
+            {
+                if (ctrl->value != sensor->info_priv.exposure)
+                {
+                    if (sensor_set_exposure(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.exposure = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Saturation
+        case V4L2_CID_SATURATION:
+            {
+                if (ctrl->value != sensor->info_priv.saturation)
+                {
+                    if (sensor_set_saturation(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.saturation = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Contrast
+        case V4L2_CID_CONTRAST:
+            {
+                if (ctrl->value != sensor->info_priv.contrast)
+                {
+                    if (sensor_set_contrast(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.contrast = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_WhiteBalance
+        case V4L2_CID_DO_WHITE_BALANCE:
+            {
+                if (ctrl->value != sensor->info_priv.whiteBalance)
+                {
+                    if (sensor_set_whiteBalance(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.whiteBalance = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Mirror
+        case V4L2_CID_HFLIP:
+            {
+                if (ctrl->value != sensor->info_priv.mirror)
+                {
+                    if (sensor_set_mirror(icd, qctrl,ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.mirror = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Flip
+        case V4L2_CID_VFLIP:
+            {
+                if (ctrl->value != sensor->info_priv.flip)
+                {
+                    if (sensor_set_flip(icd, qctrl,ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.flip = ctrl->value;
+                }
+                break;
+            }
+#endif
+        default:
+            break;
+    }
+
+    return 0;
+}
+static int sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)
+{
+    const struct v4l2_queryctrl *qctrl;
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct sensor *sensor = to_sensor(client);
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
+        return -EINVAL;
+    }
+
+    switch (ext_ctrl->id)
+    {
+        case V4L2_CID_SCENE:
+            {
+                ext_ctrl->value = sensor->info_priv.scene;
+                break;
+            }
+        case V4L2_CID_EFFECT:
+            {
+                ext_ctrl->value = sensor->info_priv.effect;
+                break;
+            }
+        case V4L2_CID_ZOOM_ABSOLUTE:
+            {
+                ext_ctrl->value = sensor->info_priv.digitalzoom;
+                break;
+            }
+        case V4L2_CID_ZOOM_RELATIVE:
+            {
+                return -EINVAL;
+            }
+        case V4L2_CID_FOCUS_ABSOLUTE:
+            {
+                ext_ctrl->value = sensor->info_priv.focus;
+                break;
+            }
+        case V4L2_CID_FOCUS_RELATIVE:
+            {
+                return -EINVAL;
+            }
+        case V4L2_CID_FLASH:
+            {
+                ext_ctrl->value = sensor->info_priv.flash;
+                break;
+            }
+        default :
+            break;
+    }
+    return 0;
+}
+static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)
+{
+    const struct v4l2_queryctrl *qctrl;
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct sensor *sensor = to_sensor(client);
+    int val_offset;
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
+        return -EINVAL;
+    }
+
+	val_offset = 0;
+    switch (ext_ctrl->id)
+    {
+#if CONFIG_SENSOR_Scene
+        case V4L2_CID_SCENE:
+            {
+                if (ext_ctrl->value != sensor->info_priv.scene)
+                {
+                    if (sensor_set_scene(icd, qctrl,ext_ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.scene = ext_ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Effect
+        case V4L2_CID_EFFECT:
+            {
+                if (ext_ctrl->value != sensor->info_priv.effect)
+                {
+                    if (sensor_set_effect(icd, qctrl,ext_ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.effect= ext_ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_DigitalZoom
+        case V4L2_CID_ZOOM_ABSOLUTE:
+            {
+                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
+                    return -EINVAL;
+
+                if (ext_ctrl->value != sensor->info_priv.digitalzoom)
+                {
+                    val_offset = ext_ctrl->value -sensor->info_priv.digitalzoom;
+
+                    if (sensor_set_digitalzoom(icd, qctrl,&val_offset) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.digitalzoom += val_offset;
+
+                    SENSOR_DG("%s digitalzoom is %x\n",SENSOR_NAME_STRING(),  sensor->info_priv.digitalzoom);
+                }
+
+                break;
+            }
+        case V4L2_CID_ZOOM_RELATIVE:
+            {
+                if (ext_ctrl->value)
+                {
+                    if (sensor_set_digitalzoom(icd, qctrl,&ext_ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.digitalzoom += ext_ctrl->value;
+
+                    SENSOR_DG("%s digitalzoom is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.digitalzoom);
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Focus
+        case V4L2_CID_FOCUS_ABSOLUTE:
+            {
+                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
+                    return -EINVAL;
+
+                if (ext_ctrl->value != sensor->info_priv.focus)
+                {
+                    val_offset = ext_ctrl->value -sensor->info_priv.focus;
+
+                    sensor->info_priv.focus += val_offset;
+                }
+
+                break;
+            }
+        case V4L2_CID_FOCUS_RELATIVE:
+            {
+                if (ext_ctrl->value)
+                {
+                    sensor->info_priv.focus += ext_ctrl->value;
+
+                    SENSOR_DG("%s focus is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.focus);
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Flash
+        case V4L2_CID_FLASH:
+            {
+                if (sensor_set_flash(icd, qctrl,ext_ctrl->value) != 0)
+                    return -EINVAL;
+                sensor->info_priv.flash = ext_ctrl->value;
+
+                SENSOR_DG("%s flash is %x\n",SENSOR_NAME_STRING(), sensor->info_priv.flash);
+                break;
+            }
+#endif
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    int i, error_cnt=0, error_idx=-1;
-
-
-    for (i=0; i<ext_ctrl->count; i++) {
-        if (sensor_g_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
-            error_cnt++;
-            error_idx = i;
-        }
-    }
-
-    if (error_cnt > 1)
-        error_idx = ext_ctrl->count;
-
-    if (error_idx != -1) {
-        ext_ctrl->error_idx = error_idx;
-        return -EINVAL;
-    } else {
-        return 0;
-    }
-}
-
-static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
-{
+    struct soc_camera_device *icd = client->dev.platform_data;
+    int i, error_cnt=0, error_idx=-1;
+
+
+    for (i=0; i<ext_ctrl->count; i++) {
+        if (sensor_g_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
+            error_cnt++;
+            error_idx = i;
+        }
+    }
+
+    if (error_cnt > 1)
+        error_idx = ext_ctrl->count;
+
+    if (error_idx != -1) {
+        ext_ctrl->error_idx = error_idx;
+        return -EINVAL;
+    } else {
+        return 0;
+    }
+}
+
+static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    int i, error_cnt=0, error_idx=-1;
-
-
-    for (i=0; i<ext_ctrl->count; i++) {
-        if (sensor_s_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
-            error_cnt++;
-            error_idx = i;
-        }
-    }
-
-    if (error_cnt > 1)
-        error_idx = ext_ctrl->count;
-
-    if (error_idx != -1) {
-        ext_ctrl->error_idx = error_idx;
-        return -EINVAL;
-    } else {
-        return 0;
-    }
-}
-
-/* Interface active, can use i2c. If it fails, it can indeed mean, that
- * this wasn't our capture interface, so, we wait for the right one */
-static int sensor_video_probe(struct soc_camera_device *icd,
-			       struct i2c_client *client)
-{
-    char value;
-    int ret,pid = 0;
-    struct sensor *sensor = to_sensor(client);
-
-    /* We must have a parent by now. And it cannot be a wrong one.
-     * So this entire test is completely redundant. */
-    if (!icd->dev.parent ||
-	    to_soc_camera_host(icd->dev.parent)->nr != icd->iface)
-		return -ENODEV;
-
-	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
-		ret = -ENODEV;
-		goto sensor_video_probe_err;
-	}
-
-    /* soft reset */
-    ret = sensor_write(client, 0xff, 0x1);
-    if (ret != 0) {
-        SENSOR_TR("soft reset %s failed\n",SENSOR_NAME_STRING());
-        ret = -ENODEV;
-		goto sensor_video_probe_err;
-    }
-    mdelay(5);          //delay 5 microseconds
-
-    /* check if it is an sensor sensor */
-    ret = sensor_read(client, 0x0a, &value);
-    if (ret != 0) {
-        SENSOR_TR("read chip id high byte failed\n");
-        ret = -ENODEV;
-        goto sensor_video_probe_err;
-    }
-    pid = value << 8;
-
-    ret = sensor_read(client, 0x0b, &value);
-    if (ret != 0) {
-        SENSOR_TR("read chip id low byte failed\n");
-        ret = -ENODEV;
-        goto sensor_video_probe_err;
-    }
-
-    pid |= (value & 0xff);
-    SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
-
-    if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
-        sensor->model = SENSOR_V4L2_IDENT;
-    } else {
-        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
-        ret = -ENODEV;
-        goto sensor_video_probe_err;
-    }
-
-    return 0;
-
-sensor_video_probe_err:
-
-    return ret;
-}
-
-static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
-{
+    struct soc_camera_device *icd = client->dev.platform_data;
+    int i, error_cnt=0, error_idx=-1;
+
+
+    for (i=0; i<ext_ctrl->count; i++) {
+        if (sensor_s_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
+            error_cnt++;
+            error_idx = i;
+        }
+    }
+
+    if (error_cnt > 1)
+        error_idx = ext_ctrl->count;
+
+    if (error_idx != -1) {
+        ext_ctrl->error_idx = error_idx;
+        return -EINVAL;
+    } else {
+        return 0;
+    }
+}
+
+/* Interface active, can use i2c. If it fails, it can indeed mean, that
+ * this wasn't our capture interface, so, we wait for the right one */
+static int sensor_video_probe(struct soc_camera_device *icd,
+			       struct i2c_client *client)
+{
+    char value;
+    int ret,pid = 0;
+    struct sensor *sensor = to_sensor(client);
+
+    /* We must have a parent by now. And it cannot be a wrong one.
+     * So this entire test is completely redundant. */
+    if (!icd->dev.parent ||
+	    to_soc_camera_host(icd->dev.parent)->nr != icd->iface)
+		return -ENODEV;
+
+	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
+		ret = -ENODEV;
+		goto sensor_video_probe_err;
+	}
+
+    /* soft reset */
+    ret = sensor_write(client, 0xff, 0x1);
+    if (ret != 0) {
+        SENSOR_TR("soft reset %s failed\n",SENSOR_NAME_STRING());
+        ret = -ENODEV;
+		goto sensor_video_probe_err;
+    }
+    mdelay(5);          //delay 5 microseconds
+
+    /* check if it is an sensor sensor */
+    ret = sensor_read(client, 0x0a, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id high byte failed\n");
+        ret = -ENODEV;
+        goto sensor_video_probe_err;
+    }
+    pid = value << 8;
+
+    ret = sensor_read(client, 0x0b, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id low byte failed\n");
+        ret = -ENODEV;
+        goto sensor_video_probe_err;
+    }
+
+    pid |= (value & 0xff);
+    SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+
+    if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
+        sensor->model = SENSOR_V4L2_IDENT;
+    } else {
+        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+        ret = -ENODEV;
+        goto sensor_video_probe_err;
+    }
+
+    return 0;
+
+sensor_video_probe_err:
+
+    return ret;
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct soc_camera_device *icd = client->dev.platform_data;  
-    struct sensor *sensor = to_sensor(client);
-    int ret = 0;
-    
-	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
-	switch (cmd)
-	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
-		{
-			sensor_deactivate(client);
-			break;
-		}
-
-		case RK_CAM_SUBDEV_IOREQUEST:
-		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
-            if (sensor->sensor_io_request != NULL) { 
-                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
-                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
-                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
-                }
-            } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
-                ret = -EINVAL;
-                goto sensor_ioctl_end;
-            }
-            /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
-               for this project */
-            #if CONFIG_SENSOR_Flash	
-        	if (sensor->sensor_gpio_res) { 
-                if (sensor->sensor_gpio_res->gpio_flash == INVALID_GPIO) {
-                    for (i = 0; i < icd->ops->num_controls; i++) {
-                		if (V4L2_CID_FLASH == icd->ops->controls[i].id) {
-                			memset((char*)&icd->ops->controls[i],0x00,sizeof(struct v4l2_queryctrl));                			
-                		}
-                    }
-                    sensor->info_priv.flash = 0xff;
-                    SENSOR_DG("%s flash gpio is invalidate!\n",SENSOR_NAME_STRING());
-                }
-        	}
-            #endif
-			break;
-		}
-		default:
-		{
-			SENSOR_TR("%s %s cmd(0x%x) is unknown !\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
-			break;
-		}
-	}
-
-sensor_ioctl_end:
-	return ret;
-
-}
-static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
-			    enum v4l2_mbus_pixelcode *code)
-{
-	if (index >= ARRAY_SIZE(sensor_colour_fmts))
-		return -EINVAL;
-
-	*code = sensor_colour_fmts[index].code;
-	return 0;
-}
-static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
-	.init		= sensor_init,
-	.g_ctrl		= sensor_g_control,
-	.s_ctrl		= sensor_s_control,
-	.g_ext_ctrls          = sensor_g_ext_controls,
-	.s_ext_ctrls          = sensor_s_ext_controls,
-	.g_chip_ident	= sensor_g_chip_ident,
-	.ioctl = sensor_ioctl,
-};
-
-static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
-	.s_mbus_fmt	= sensor_s_fmt,
-	.g_mbus_fmt	= sensor_g_fmt,
-	.try_mbus_fmt	= sensor_try_fmt,
-	.enum_mbus_fmt	= sensor_enum_fmt,
-};
-
-static struct v4l2_subdev_ops sensor_subdev_ops = {
-	.core	= &sensor_subdev_core_ops,
-	.video = &sensor_subdev_video_ops,
-};
-
-static int sensor_probe(struct i2c_client *client,
-			 const struct i2c_device_id *did)
-{
-    struct sensor *sensor;
-    struct soc_camera_device *icd = client->dev.platform_data;
-    struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
-    struct soc_camera_link *icl;
-    int ret;
-
-    SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
-    if (!icd) {
-        dev_err(&client->dev, "%s: missing soc-camera data!\n",SENSOR_NAME_STRING());
-        return -EINVAL;
-    }
-
-    icl = to_soc_camera_link(icd);
-    if (!icl) {
-        dev_err(&client->dev, "%s driver needs platform data\n", SENSOR_NAME_STRING());
-        return -EINVAL;
-    }
-
-    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
-        dev_warn(&adapter->dev,
-        	 "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
-        return -EIO;
-    }
-
-    sensor = kzalloc(sizeof(struct sensor), GFP_KERNEL);
-    if (!sensor)
-        return -ENOMEM;
-
-    v4l2_i2c_subdev_init(&sensor->subdev, client, &sensor_subdev_ops);
-
-    /* Second stage probe - when a capture adapter is there */
-    icd->ops		= &sensor_ops;
-    sensor->info_priv.fmt = sensor_colour_fmts[0];
-	#if CONFIG_SENSOR_I2C_NOSCHED
-	atomic_set(&sensor->tasklock_cnt,0);
-	#endif
-
-    ret = sensor_video_probe(icd, client);
-    if (ret < 0) {
-        icd->ops = NULL;
-        i2c_set_clientdata(client, NULL);
-        kfree(sensor);
-		sensor = NULL;
-    }
-    SENSOR_DG("\n%s..%s..%d  ret = %x \n",__FUNCTION__,__FILE__,__LINE__,ret);
-    return ret;
-}
-
-static int sensor_remove(struct i2c_client *client)
-{
-    struct sensor *sensor = to_sensor(client);
-    struct soc_camera_device *icd = client->dev.platform_data;
-
-    icd->ops = NULL;
-    i2c_set_clientdata(client, NULL);
-    client->driver = NULL;
-    kfree(sensor);
-	sensor = NULL;
-    return 0;
-}
-
-static const struct i2c_device_id sensor_id[] = {
-	{SENSOR_NAME_STRING(), 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, sensor_id);
-
-static struct i2c_driver sensor_i2c_driver = {
-	.driver = {
-		.name = SENSOR_NAME_STRING(),
-	},
-	.probe		= sensor_probe,
-	.remove		= sensor_remove,
-	.id_table	= sensor_id,
-};
-
-static int __init sensor_mod_init(void)
-{
-    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());
-    return i2c_add_driver(&sensor_i2c_driver);
-}
-
-static void __exit sensor_mod_exit(void)
-{
-    i2c_del_driver(&sensor_i2c_driver);
-}
-
-device_initcall_sync(sensor_mod_init);
-module_exit(sensor_mod_exit);
-
-MODULE_DESCRIPTION(SENSOR_NAME_STRING(Camera sensor driver));
-MODULE_AUTHOR("ddl <kernel@rock-chips>");
+    struct soc_camera_device *icd = client->dev.platform_data;  
+    struct sensor *sensor = to_sensor(client);
+    int ret = 0;
+    
+	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
+	switch (cmd)
+	{
+		case RK29_CAM_SUBDEV_DEACTIVATE:
+		{
+			sensor_deactivate(client);
+			break;
+		}
+
+		case RK29_CAM_SUBDEV_IOREQUEST:
+		{
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
+            if (sensor->sensor_io_request != NULL) { 
+                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
+                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
+                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                }
+            } else {
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                ret = -EINVAL;
+                goto sensor_ioctl_end;
+            }
+            /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
+               for this project */
+            #if CONFIG_SENSOR_Flash	
+        	if (sensor->sensor_gpio_res) { 
+                if (sensor->sensor_gpio_res->gpio_flash == INVALID_GPIO) {
+                    for (i = 0; i < icd->ops->num_controls; i++) {
+                		if (V4L2_CID_FLASH == icd->ops->controls[i].id) {
+                			memset((char*)&icd->ops->controls[i],0x00,sizeof(struct v4l2_queryctrl));                			
+                		}
+                    }
+                    sensor->info_priv.flash = 0xff;
+                    SENSOR_DG("%s flash gpio is invalidate!\n",SENSOR_NAME_STRING());
+                }
+        	}
+            #endif
+			break;
+		}
+		default:
+		{
+			SENSOR_TR("%s %s cmd(0x%x) is unknown !\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
+			break;
+		}
+	}
+
+sensor_ioctl_end:
+	return ret;
+
+}
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			    enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(sensor_colour_fmts))
+		return -EINVAL;
+
+	*code = sensor_colour_fmts[index].code;
+	return 0;
+}
+static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
+	.init		= sensor_init,
+	.g_ctrl		= sensor_g_control,
+	.s_ctrl		= sensor_s_control,
+	.g_ext_ctrls          = sensor_g_ext_controls,
+	.s_ext_ctrls          = sensor_s_ext_controls,
+	.g_chip_ident	= sensor_g_chip_ident,
+	.ioctl = sensor_ioctl,
+};
+
+static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
+	.s_mbus_fmt	= sensor_s_fmt,
+	.g_mbus_fmt	= sensor_g_fmt,
+	.try_mbus_fmt	= sensor_try_fmt,
+	.enum_mbus_fmt	= sensor_enum_fmt,
+};
+
+static struct v4l2_subdev_ops sensor_subdev_ops = {
+	.core	= &sensor_subdev_core_ops,
+	.video = &sensor_subdev_video_ops,
+};
+
+static int sensor_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+    struct sensor *sensor;
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+    struct soc_camera_link *icl;
+    int ret;
+
+    SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
+    if (!icd) {
+        dev_err(&client->dev, "%s: missing soc-camera data!\n",SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+
+    icl = to_soc_camera_link(icd);
+    if (!icl) {
+        dev_err(&client->dev, "%s driver needs platform data\n", SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+
+    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+        dev_warn(&adapter->dev,
+        	 "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
+        return -EIO;
+    }
+
+    sensor = kzalloc(sizeof(struct sensor), GFP_KERNEL);
+    if (!sensor)
+        return -ENOMEM;
+
+    v4l2_i2c_subdev_init(&sensor->subdev, client, &sensor_subdev_ops);
+
+    /* Second stage probe - when a capture adapter is there */
+    icd->ops		= &sensor_ops;
+    sensor->info_priv.fmt = sensor_colour_fmts[0];
+	#if CONFIG_SENSOR_I2C_NOSCHED
+	atomic_set(&sensor->tasklock_cnt,0);
+	#endif
+
+    ret = sensor_video_probe(icd, client);
+    if (ret < 0) {
+        icd->ops = NULL;
+        i2c_set_clientdata(client, NULL);
+        kfree(sensor);
+		sensor = NULL;
+    }
+    SENSOR_DG("\n%s..%s..%d  ret = %x \n",__FUNCTION__,__FILE__,__LINE__,ret);
+    return ret;
+}
+
+static int sensor_remove(struct i2c_client *client)
+{
+    struct sensor *sensor = to_sensor(client);
+    struct soc_camera_device *icd = client->dev.platform_data;
+
+    icd->ops = NULL;
+    i2c_set_clientdata(client, NULL);
+    client->driver = NULL;
+    kfree(sensor);
+	sensor = NULL;
+    return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{SENSOR_NAME_STRING(), 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+static struct i2c_driver sensor_i2c_driver = {
+	.driver = {
+		.name = SENSOR_NAME_STRING(),
+	},
+	.probe		= sensor_probe,
+	.remove		= sensor_remove,
+	.id_table	= sensor_id,
+};
+
+static int __init sensor_mod_init(void)
+{
+    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());
+    return i2c_add_driver(&sensor_i2c_driver);
+}
+
+static void __exit sensor_mod_exit(void)
+{
+    i2c_del_driver(&sensor_i2c_driver);
+}
+
+device_initcall_sync(sensor_mod_init);
+module_exit(sensor_mod_exit);
+
+MODULE_DESCRIPTION(SENSOR_NAME_STRING(Camera sensor driver));
+MODULE_AUTHOR("ddl <kernel@rock-chips>");
 MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/ov2655.c b/drivers/media/video/ov2655.c
old mode 100644
new mode 100755
index 30eb89e0fc07..6d7853134ed5
--- a/drivers/media/video/ov2655.c
+++ b/drivers/media/video/ov2655.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -43,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV2655
+#define SENSOR_NAME RK29_CAM_SENSOR_OV2655
 #define SENSOR_V4L2_IDENT V4L2_IDENT_OV2655
 #define SENSOR_ID 0x2656
 #define SENSOR_MIN_WIDTH    176
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -74,6 +73,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   1
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -94,14 +97,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 352X288 SVGA */
 static struct reginfo sensor_init_data[] =
 {
     {0x308c, 0x80},
@@ -1460,8 +1456,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1643,7 +1639,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1656,13 +1652,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1696,62 +1692,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret,pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1802,7 +1744,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2965,25 +2907,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/ov2659.c b/drivers/media/video/ov2659.c
old mode 100644
new mode 100755
index 875f7f1968ab..85f5c20e7b8f
--- a/drivers/media/video/ov2659.c
+++ b/drivers/media/video/ov2659.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -43,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV2659
+#define SENSOR_NAME RK29_CAM_SENSOR_OV2659
 #define SENSOR_V4L2_IDENT V4L2_IDENT_OV2659
 #define SENSOR_ID 0x2656
 #define SENSOR_MIN_WIDTH    800
 #define SENSOR_MIN_HEIGHT   600
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	800			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  600
+#define SENSOR_INIT_WINSEQADR sensor_svga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -69,11 +68,15 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_Mirror        0 
 #define CONFIG_SENSOR_Flip          0
 
-#define CONFIG_SENSOR_I2C_SPEED     100000       /* Hz */
+#define CONFIG_SENSOR_I2C_SPEED     350000       /* Hz */
 /* Sensor write register continues by preempt_disable/preempt_enable for current process not be scheduled */
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -90,19 +93,12 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_AF_IS_OK		(0x01<<0)
 #define SENSOR_INIT_IS_ERR   (0x00<<28)
 #define SENSOR_INIT_IS_OK    (0x01<<28)
+
 struct reginfo
 {
-	u16 reg;
-	u8 val;
+    u16 reg;
+    u8 val;
 };
-
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
 /* init 800*600 SVGA */
 static struct reginfo sensor_init_data[] =
 {
@@ -1276,8 +1272,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 
@@ -1461,11 +1457,11 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
-	return 0;
+
     SENSOR_DG("%s %s  cmd(%d) on(%d)\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd,on);
 	switch (cmd)
 	{
@@ -1473,13 +1469,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1513,62 +1509,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_svga;
-	sensor_init_width = 800;
-	sensor_init_height = 600;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret,pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1616,7 +1558,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2753,7 +2695,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 			       struct i2c_client *client)
 {
     char value;
-    int ret,pid = 0,i=0;
+    int ret,pid = 0;
     struct sensor *sensor = to_sensor(client);
 
     /* We must have a parent by now. And it cannot be a wrong one.
@@ -2764,9 +2706,9 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
 		ret = -ENODEV;
-		printk("sensor ioctrl powdown erro!!!");
 		goto sensor_video_probe_err;
 	}
+
     /* soft reset */
     ret = sensor_write(client, 0x0103, 0x01);
     if (ret != 0) {
@@ -2792,6 +2734,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
         ret = -ENODEV;
         goto sensor_video_probe_err;
     }
+
     pid |= (value & 0xff);
     SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
     if (pid == SENSOR_ID) {
@@ -2801,11 +2744,10 @@ static int sensor_video_probe(struct soc_camera_device *icd,
         ret = -ENODEV;
         goto sensor_video_probe_err;
     }
-	
+
     return 0;
 
 sensor_video_probe_err:
-	printk("the erro value = %d\n",i);
 
     return ret;
 }
@@ -2823,25 +2765,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
@@ -2965,11 +2907,6 @@ static int sensor_remove(struct i2c_client *client)
     client->driver = NULL;
     kfree(sensor);
 	sensor = NULL;
-	if(sensor_init_winseq_board)
-		{
-		vfree(sensor_init_winseq_board);
-		sensor_init_winseq_board = NULL;
-		}
     return 0;
 }
 
diff --git a/drivers/media/video/ov3640.c b/drivers/media/video/ov3640.c
index fc3b4628abdb..366516658510 100644
--- a/drivers/media/video/ov3640.c
+++ b/drivers/media/video/ov3640.c
@@ -19,9 +19,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
 #include "ov3640.h"
 
 static int debug;
@@ -45,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV3640
+#define SENSOR_NAME RK29_CAM_SENSOR_OV3640
 #define SENSOR_V4L2_IDENT V4L2_IDENT_OV3640
 #define SENSOR_ID 0x364c
 #define SENSOR_MIN_WIDTH    176
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    2048
 #define SENSOR_MAX_HEIGHT   1536
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_init_data
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -81,6 +78,11 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -185,12 +187,6 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define StepFocus_Spec_Tag       0x10
 #endif
 
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
 /* init VGA 640*480 */
 static struct reginfo sensor_init_data[] =
 {
@@ -1995,8 +1991,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -2500,7 +2496,7 @@ static void sensor_af_workqueue(struct work_struct *work)
 }
 #endif
 
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -2513,13 +2509,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -2554,62 +2550,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;    
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret,pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -2658,7 +2600,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -4036,24 +3978,24 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/ov5640.c b/drivers/media/video/ov5640.c
index 3daa639dba11..055ab274d045 100755
--- a/drivers/media/video/ov5640.c
+++ b/drivers/media/video/ov5640.c
@@ -19,7 +19,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
+#include <mach/rk29_camera.h>
 #include "ov5640.h"
 
 static int debug;
@@ -43,7 +43,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV5640
+#define SENSOR_NAME RK29_CAM_SENSOR_OV5640
 #define SENSOR_V4L2_IDENT V4L2_IDENT_OV5640
 #define SENSOR_ID 0x5640
 #define SENSOR_MIN_WIDTH    176
@@ -1457,8 +1457,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -2317,7 +2317,7 @@ static int sensor_ae_transfer(struct i2c_client *client)
 	mdelay(100);
 	return 0;
 }
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -2330,13 +2330,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -3779,24 +3779,24 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/ov5640_for_td8801.c b/drivers/media/video/ov5640_for_td8801.c
old mode 100755
new mode 100644
index c959b511aef9..69be80bf4c54
--- a/drivers/media/video/ov5640_for_td8801.c
+++ b/drivers/media/video/ov5640_for_td8801.c
@@ -19,7 +19,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
+#include <mach/rk29_camera.h>
 #include "ov5640.h"
 
 static int debug = 1;
@@ -43,7 +43,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV5640
+#define SENSOR_NAME RK29_CAM_SENSOR_OV5640
 #define SENSOR_V4L2_IDENT V4L2_IDENT_OV5640
 #define SENSOR_ID 0x5640
 #define SENSOR_MIN_WIDTH    176
@@ -1457,8 +1457,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -2317,7 +2317,7 @@ static int sensor_ae_transfer(struct i2c_client *client)
 	mdelay(100);
 	return 0;
 }
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -2330,13 +2330,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -3779,24 +3779,24 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/ov5642.c b/drivers/media/video/ov5642.c
old mode 100644
new mode 100755
index 6d656a3a31f9..98816754ee17
--- a/drivers/media/video/ov5642.c
+++ b/drivers/media/video/ov5642.c
@@ -19,8 +19,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
 #include "ov5642.h"
 
 static int debug;
@@ -44,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV5642
+#define SENSOR_NAME RK29_CAM_SENSOR_OV5642
 #define SENSOR_V4L2_IDENT V4L2_IDENT_OV5642
 #define SENSOR_ID 0x5642
 #define SENSOR_MIN_WIDTH    176
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    2592
 #define SENSOR_MAX_HEIGHT   1944
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	800			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  600
+#define SENSOR_INIT_WINSEQADR sensor_svga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -80,6 +78,11 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -162,12 +165,6 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define StepFocus_Spec_Tag       0x10
 #endif
 
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
 /* init 800X600 SVGA */
 static struct reginfo sensor_init_data[] =
 {
@@ -3377,8 +3374,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt; 
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -4200,7 +4197,7 @@ static int sensor_ae_transfer(struct i2c_client *client)
 	mdelay(100);
 	return 0;
 }
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -4213,13 +4210,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -4254,62 +4251,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
     char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_svga;
-	sensor_init_width = 800;
-	sensor_init_height = 600;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret,pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -4356,9 +4299,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
-    if (ret != 0)
-    {
+    ret = sensor_write_array(client, sensor_init_data);
+    if (ret != 0) {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
         goto sensor_INIT_ERR;
     }
@@ -5754,25 +5696,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;    
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;    
             
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];          
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];          
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/ov7675.c b/drivers/media/video/ov7675.c
old mode 100644
new mode 100755
index e159437dedb6..03d19f88929f
--- a/drivers/media/video/ov7675.c
+++ b/drivers/media/video/ov7675.c
@@ -20,8 +20,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -44,18 +44,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV7675
+#define SENSOR_NAME RK29_CAM_SENSOR_OV7675
 #define SENSOR_V4L2_IDENT V4L2_IDENT_OV7675
 #define SENSOR_ID 0x76
 #define SENSOR_MIN_WIDTH    640//176
 #define SENSOR_MIN_HEIGHT   480//144
 #define SENSOR_MAX_WIDTH    640
 #define SENSOR_MAX_HEIGHT   480
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	0
 #define CONFIG_SENSOR_Brightness	0
@@ -75,6 +74,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -92,14 +95,8 @@ struct reginfo
     u8 reg;
     u8 val;
 };
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+
+/* init 640X480 VGA */
 static struct reginfo sensor_init_data[] =
 {
 	{0x12, 0x80},
@@ -1160,8 +1157,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1340,7 +1337,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     }
     return 0;
 }
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1354,13 +1351,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 				if (on == 0)
 					mdelay(1);
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(20);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1393,62 +1390,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-	int ret,pid = 0,i = 0,j=0;
-	struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_svga;
-	sensor_init_width = 800;
-	sensor_init_height = 600;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret;
 
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
@@ -1470,7 +1412,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 
     mdelay(5);  //delay 5 microseconds
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2619,25 +2561,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/ov7690.c b/drivers/media/video/ov7690.c
index 2b7992747276..3e9884ec330b 100644
--- a/drivers/media/video/ov7690.c
+++ b/drivers/media/video/ov7690.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -43,18 +43,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_OV7690
+#define SENSOR_NAME RK29_CAM_SENSOR_OV7690
 #define SENSOR_V4L2_IDENT V4L2_IDENT_OV7690
 #define SENSOR_ID 0x76
 #define SENSOR_MIN_WIDTH    176
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    640
 #define SENSOR_MAX_HEIGHT   480
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -74,6 +73,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -91,15 +94,7 @@ struct reginfo
     u8 reg;
     u8 val;
 };
-
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 640X480 VGA */
 static struct reginfo sensor_init_data[] =
 {
 	{0x12, 0x80},
@@ -955,8 +950,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 
@@ -1138,7 +1133,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1152,13 +1147,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 				if (on == 0)
 					mdelay(1);
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(20);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1191,62 +1186,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1266,7 +1207,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     }
     mdelay(5);  //delay 5 microseconds
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -2437,25 +2378,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/rk29_camera.c b/drivers/media/video/rk29_camera.c
new file mode 100755
index 000000000000..e8c4898f4f94
--- /dev/null
+++ b/drivers/media/video/rk29_camera.c
@@ -0,0 +1,1740 @@
+#include <mach/rk29_camera.h> 
+#include <mach/iomux.h>
+#ifndef PMEM_CAM_SIZE
+#ifdef CONFIG_VIDEO_RK29 
+/*---------------- Camera Sensor Fixed Macro Begin  ------------------------*/
+// Below Macro is fixed, programer don't change it!!!!!!
+#define _CONS(a,b) a##b
+#define CONS(a,b) _CONS(a,b)
+
+#define __STR(x) #x
+#define _STR(x) __STR(x)
+#define STR(x) _STR(x)
+
+#if (CONFIG_SENSOR_IIC_ADDR_0 != 0x00)
+#define PMEM_SENSOR_FULL_RESOLUTION_0  CONS(CONFIG_SENSOR_0,_FULL_RESOLUTION)
+#if !(PMEM_SENSOR_FULL_RESOLUTION_0)
+#undef PMEM_SENSOR_FULL_RESOLUTION_0
+#define PMEM_SENSOR_FULL_RESOLUTION_0  0x500000
+#endif
+#else
+#define PMEM_SENSOR_FULL_RESOLUTION_0  0x00
+#endif
+ 
+#if (CONFIG_SENSOR_IIC_ADDR_1 != 0x00)
+#define PMEM_SENSOR_FULL_RESOLUTION_1  CONS(CONFIG_SENSOR_1,_FULL_RESOLUTION)
+#if !(PMEM_SENSOR_FULL_RESOLUTION_1)
+#undef PMEM_SENSOR_FULL_RESOLUTION_1
+#define PMEM_SENSOR_FULL_RESOLUTION_1  0x500000
+#endif
+#else
+#define PMEM_SENSOR_FULL_RESOLUTION_1  0x00
+#endif
+
+#if (PMEM_SENSOR_FULL_RESOLUTION_0 > PMEM_SENSOR_FULL_RESOLUTION_1)
+#define PMEM_CAM_FULL_RESOLUTION   PMEM_SENSOR_FULL_RESOLUTION_0
+#else
+#define PMEM_CAM_FULL_RESOLUTION   PMEM_SENSOR_FULL_RESOLUTION_1
+#endif
+
+#if (PMEM_CAM_FULL_RESOLUTION == 0x500000)
+#define PMEM_CAM_NECESSARY   0x1400000       /* 1280*720*1.5*4(preview) + 7.5M(capture raw) + 4M(jpeg encode output) */
+#define PMEM_CAMIPP_NECESSARY    0x800000
+#elif (PMEM_CAM_FULL_RESOLUTION == 0x300000)
+#define PMEM_CAM_NECESSARY   0xe00000        /* 1280*720*1.5*4(preview) + 4.5M(capture raw) + 3M(jpeg encode output) */
+#define PMEM_CAMIPP_NECESSARY    0x500000
+#elif (PMEM_CAM_FULL_RESOLUTION == 0x200000) /* 1280*720*1.5*4(preview) + 3M(capture raw) + 3M(jpeg encode output) */
+#define PMEM_CAM_NECESSARY   0xc00000
+#define PMEM_CAMIPP_NECESSARY    0x400000
+#elif ((PMEM_CAM_FULL_RESOLUTION == 0x100000) || (PMEM_CAM_FULL_RESOLUTION == 0x130000))
+#define PMEM_CAM_NECESSARY   0x800000        /* 800*600*1.5*4(preview) + 2M(capture raw) + 2M(jpeg encode output) */
+#define PMEM_CAMIPP_NECESSARY    0x400000
+#elif (PMEM_CAM_FULL_RESOLUTION == 0x30000)
+#define PMEM_CAM_NECESSARY   0x400000        /* 640*480*1.5*4(preview) + 1M(capture raw) + 1M(jpeg encode output) */
+#define PMEM_CAMIPP_NECESSARY    0x400000
+#else
+#define PMEM_CAM_NECESSARY   0x1200000
+#define PMEM_CAMIPP_NECESSARY    0x800000
+#endif
+/*---------------- Camera Sensor Fixed Macro End  ------------------------*/
+#else   //#ifdef CONFIG_VIDEO_RK29 
+#define PMEM_CAM_NECESSARY   0x00000000
+#endif
+#else   // #ifdef PMEM_CAM_SIZE
+
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_VIDEO_RK29 
+static int camera_debug;
+module_param(camera_debug, int, S_IRUGO|S_IWUSR);
+
+#define ddprintk(level, fmt, arg...) do {			\
+	if (camera_debug >= level) 					\
+	    printk(KERN_WARNING"rk29_cam_io: " fmt , ## arg); } while (0)
+
+#define dprintk(format, ...) ddprintk(1, format, ## __VA_ARGS__)    
+
+#define SENSOR_NAME_0 STR(CONFIG_SENSOR_0)			/* back camera sensor */
+#define SENSOR_NAME_1 STR(CONFIG_SENSOR_1)			/* front camera sensor */
+#define SENSOR_DEVICE_NAME_0  STR(CONS(CONFIG_SENSOR_0, _back))
+#define SENSOR_DEVICE_NAME_1  STR(CONS(CONFIG_SENSOR_1, _front))
+
+static int rk29_sensor_io_init(void);
+static int rk29_sensor_io_deinit(int sensor);
+static int rk29_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd,int on);
+
+static struct rk29camera_platform_data rk29_camera_platform_data = {
+    .io_init = rk29_sensor_io_init,
+    .io_deinit = rk29_sensor_io_deinit,
+    .sensor_ioctrl = rk29_sensor_ioctrl,
+    .gpio_res = {
+        {
+            .gpio_reset = CONFIG_SENSOR_RESET_PIN_0,
+            .gpio_power = CONFIG_SENSOR_POWER_PIN_0,
+            .gpio_powerdown = CONFIG_SENSOR_POWERDN_PIN_0,
+            .gpio_flash = CONFIG_SENSOR_FALSH_PIN_0,
+            .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_0|CONFIG_SENSOR_RESETACTIVE_LEVEL_0|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0|CONFIG_SENSOR_FLASHACTIVE_LEVEL_0),
+            .gpio_init = 0,            
+            .dev_name = SENSOR_DEVICE_NAME_0,
+        }, {
+            .gpio_reset = CONFIG_SENSOR_RESET_PIN_1,
+            .gpio_power = CONFIG_SENSOR_POWER_PIN_1,
+            .gpio_powerdown = CONFIG_SENSOR_POWERDN_PIN_1,
+            .gpio_flash = CONFIG_SENSOR_FALSH_PIN_1,
+            .gpio_flag = (CONFIG_SENSOR_POWERACTIVE_LEVEL_1|CONFIG_SENSOR_RESETACTIVE_LEVEL_1|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1|CONFIG_SENSOR_FLASHACTIVE_LEVEL_1),
+            .gpio_init = 0,
+            .dev_name = SENSOR_DEVICE_NAME_1,
+        }
+    },
+	#ifdef CONFIG_VIDEO_RK29_WORK_IPP
+	.meminfo = {
+	    .name  = "camera_ipp_mem",
+		.start = MEM_CAMIPP_BASE,
+		.size   = MEM_CAMIPP_SIZE,
+	},
+	#endif
+    .info = {
+        {
+            .dev_name = SENSOR_DEVICE_NAME_0,
+            .orientation = CONFIG_SENSOR_ORIENTATION_0, 
+	    },{
+            .dev_name = SENSOR_DEVICE_NAME_1,
+            .orientation = CONFIG_SENSOR_ORIENTATION_1,
+        }
+	}
+};
+
+static int rk29_sensor_iomux(int pin)
+{    
+    switch (pin)
+    {
+        case RK29_PIN0_PA0:        
+        case RK29_PIN0_PA1:        
+        case RK29_PIN0_PA2:
+        case RK29_PIN0_PA3:
+        case RK29_PIN0_PA4:
+        {
+            break;	
+        }
+        case RK29_PIN0_PA5:
+        {
+             rk29_mux_api_set(GPIO0A5_FLASHDQS_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PA6:
+        {
+             rk29_mux_api_set(GPIO0A6_MIIMD_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PA7:
+        {
+             rk29_mux_api_set(GPIO0A7_MIIMDCLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB0:
+        {
+             rk29_mux_api_set(GPIO0B0_EBCSDCE0_SMCADDR0_HOSTDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB1:
+        {
+             rk29_mux_api_set(GPIO0B1_EBCSDCE1_SMCADDR1_HOSTDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB2:
+        {
+             rk29_mux_api_set(GPIO0B2_EBCSDCE2_SMCADDR2_HOSTDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB3:
+        {
+             rk29_mux_api_set(GPIO0B3_EBCBORDER0_SMCADDR3_HOSTDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB4:
+        {
+             rk29_mux_api_set(GPIO0B4_EBCBORDER1_SMCWEN_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB5:
+        {
+             rk29_mux_api_set(GPIO0B5_EBCVCOM_SMCBLSN0_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB6:
+        {
+             rk29_mux_api_set(GPIO0B6_EBCSDSHR_SMCBLSN1_HOSTINT_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PB7:
+        {
+             rk29_mux_api_set(GPIO0B7_EBCGDOE_SMCOEN_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC0:
+        {
+             rk29_mux_api_set(GPIO0C0_EBCGDSP_SMCDATA8_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC1:
+        {
+             rk29_mux_api_set(GPIO0C1_EBCGDR1_SMCDATA9_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC2:
+        {
+             rk29_mux_api_set(GPIO0C2_EBCSDCE0_SMCDATA10_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC3:
+        {
+             rk29_mux_api_set(GPIO0C3_EBCSDCE1_SMCDATA11_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC4:
+        {
+             rk29_mux_api_set(GPIO0C4_EBCSDCE2_SMCDATA12_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC5:
+        {
+             rk29_mux_api_set(GPIO0C5_EBCSDCE3_SMCDATA13_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC6:
+        {
+             rk29_mux_api_set(GPIO0C6_EBCSDCE4_SMCDATA14_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PC7:
+        {
+             rk29_mux_api_set(GPIO0C7_EBCSDCE5_SMCDATA15_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD0:
+        {
+             rk29_mux_api_set(GPIO0D0_EBCSDOE_SMCADVN_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD1:
+        {
+             rk29_mux_api_set(GPIO0D1_EBCGDCLK_SMCADDR4_HOSTDATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD2:
+        {
+             rk29_mux_api_set(GPIO0D2_FLASHCSN1_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD3:
+        {
+             rk29_mux_api_set(GPIO0D3_FLASHCSN2_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD4:
+        {
+             rk29_mux_api_set(GPIO0D4_FLASHCSN3_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD5:
+        {
+             rk29_mux_api_set(GPIO0D5_FLASHCSN4_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD6:
+        {
+             rk29_mux_api_set(GPIO0D6_FLASHCSN5_NAME,0);
+            break;	
+        }
+        case RK29_PIN0_PD7:
+        {
+             rk29_mux_api_set(GPIO0D7_FLASHCSN6_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA0:
+        {
+             rk29_mux_api_set(GPIO1A0_FLASHCS7_MDDRTQ_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA1:
+        {
+             rk29_mux_api_set(GPIO1A1_SMCCSN0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA2:
+        {
+             rk29_mux_api_set(GPIO1A2_SMCCSN1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA3:
+        {
+             rk29_mux_api_set(GPIO1A3_EMMCDETECTN_SPI1CS1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA4:
+        {
+             rk29_mux_api_set(GPIO1A4_EMMCWRITEPRT_SPI0CS1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA5:
+        {
+             rk29_mux_api_set(GPIO1A5_EMMCPWREN_PWM3_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA6:
+        {
+             rk29_mux_api_set(GPIO1A6_I2C1SDA_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PA7:
+        {
+             rk29_mux_api_set(GPIO1A7_I2C1SCL_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB0:
+        {
+             rk29_mux_api_set(GPIO1B0_VIPDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB1:
+        {
+             rk29_mux_api_set(GPIO1B1_VIPDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB2:
+        {
+             rk29_mux_api_set(GPIO1B2_VIPDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB3:
+        {
+             rk29_mux_api_set(GPIO1B3_VIPDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB4:
+        {
+             rk29_mux_api_set(GPIO1B4_VIPCLKOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB5:
+        {
+             rk29_mux_api_set(GPIO1B5_PWM0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB6:
+        {
+             rk29_mux_api_set(GPIO1B6_UART0SIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PB7:
+        {
+             rk29_mux_api_set(GPIO1B7_UART0SOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC0:
+        {
+             rk29_mux_api_set(GPIO1C0_UART0CTSN_SDMMC1DETECTN_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC1:
+        {
+             rk29_mux_api_set(GPIO1C1_UART0RTSN_SDMMC1WRITEPRT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC2:
+        {
+             rk29_mux_api_set(GPIO1C2_SDMMC1CMD_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC3:
+        {
+             rk29_mux_api_set(GPIO1C3_SDMMC1DATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC4:
+        {
+             rk29_mux_api_set(GPIO1C4_SDMMC1DATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC5:
+        {
+             rk29_mux_api_set(GPIO1C5_SDMMC1DATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC6:
+        {
+             rk29_mux_api_set(GPIO1C6_SDMMC1DATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PC7:
+        {
+             rk29_mux_api_set(GPIO1C7_SDMMC1CLKOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD0:
+        {
+             rk29_mux_api_set(GPIO1D0_SDMMC0CLKOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD1:
+        {
+             rk29_mux_api_set(GPIO1D1_SDMMC0CMD_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD2:
+        {
+             rk29_mux_api_set(GPIO1D2_SDMMC0DATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD3:
+        {
+             rk29_mux_api_set(GPIO1D3_SDMMC0DATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD4:
+        {
+             rk29_mux_api_set(GPIO1D4_SDMMC0DATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD5:
+        {
+             rk29_mux_api_set(GPIO1D5_SDMMC0DATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD6:
+        {
+             rk29_mux_api_set(GPIO1D6_SDMMC0DATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN1_PD7:
+        {
+             rk29_mux_api_set(GPIO1D7_SDMMC0DATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA0:
+        {
+             rk29_mux_api_set(GPIO2A0_SDMMC0DATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA1:
+        {
+             rk29_mux_api_set(GPIO2A1_SDMMC0DATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA2:
+        {
+             rk29_mux_api_set(GPIO2A2_SDMMC0DETECTN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA3:
+        {
+             rk29_mux_api_set(GPIO2A3_SDMMC0WRITEPRT_PWM2_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA4:
+        {
+             rk29_mux_api_set(GPIO2A4_UART1SIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA5:
+        {
+             rk29_mux_api_set(GPIO2A5_UART1SOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA6:
+        {
+             rk29_mux_api_set(GPIO2A6_UART2CTSN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PA7:
+        {
+             rk29_mux_api_set(GPIO2A7_UART2RTSN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB0:
+        {
+             rk29_mux_api_set(GPIO2B0_UART2SIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB1:
+        {
+             rk29_mux_api_set(GPIO2B1_UART2SOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB2:
+        {
+             rk29_mux_api_set(GPIO2B2_UART3SIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB3:
+        {
+             rk29_mux_api_set(GPIO2B3_UART3SOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB4:
+        {
+             rk29_mux_api_set(GPIO2B4_UART3CTSN_I2C3SDA_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB5:
+        {
+             rk29_mux_api_set(GPIO2B5_UART3RTSN_I2C3SCL_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB6:
+        {
+             rk29_mux_api_set(GPIO2B6_I2C0SDA_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PB7:
+        {
+             rk29_mux_api_set(GPIO2B7_I2C0SCL_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC0:
+        {
+             rk29_mux_api_set(GPIO2C0_SPI0CLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC1:
+        {
+             rk29_mux_api_set(GPIO2C1_SPI0CSN0_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC2:
+        {
+             rk29_mux_api_set(GPIO2C2_SPI0TXD_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC3:
+        {
+             rk29_mux_api_set(GPIO2C3_SPI0RXD_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC4:
+        {
+             rk29_mux_api_set(GPIO2C4_SPI1CLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC5:
+        {
+             rk29_mux_api_set(GPIO2C5_SPI1CSN0_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC6:
+        {
+             rk29_mux_api_set(GPIO2C6_SPI1TXD_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PC7:
+        {
+             rk29_mux_api_set(GPIO2C7_SPI1RXD_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD0:
+        {
+             rk29_mux_api_set(GPIO2D0_I2S0CLK_MIIRXCLKIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD1:
+        {
+             rk29_mux_api_set(GPIO2D1_I2S0SCLK_MIICRS_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD2:
+        {
+             rk29_mux_api_set(GPIO2D2_I2S0LRCKRX_MIITXERR_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD3:
+        {
+             rk29_mux_api_set(GPIO2D3_I2S0SDI_MIICOL_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD4:
+        {
+             rk29_mux_api_set(GPIO2D4_I2S0SDO0_MIIRXD2_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD5:
+        {
+             rk29_mux_api_set(GPIO2D5_I2S0SDO1_MIIRXD3_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD6:
+        {
+             rk29_mux_api_set(GPIO2D6_I2S0SDO2_MIITXD2_NAME,0);
+            break;	
+        }
+        case RK29_PIN2_PD7:
+        {
+             rk29_mux_api_set(GPIO2D7_I2S0SDO3_MIITXD3_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA0:
+        {
+             rk29_mux_api_set(GPIO3A0_I2S1CLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA1:
+        {
+             rk29_mux_api_set(GPIO3A1_I2S1SCLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA2:
+        {
+             rk29_mux_api_set(GPIO3A2_I2S1LRCKRX_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA3:
+        {
+             rk29_mux_api_set(GPIO3A3_I2S1SDI_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA4:
+        {
+             rk29_mux_api_set(GPIO3A4_I2S1SDO_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA5:
+        {
+             rk29_mux_api_set(GPIO3A5_I2S1LRCKTX_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA6:
+        {
+             rk29_mux_api_set(GPIO3A6_SMCADDR14_HOSTDATA14_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PA7:
+        {
+             rk29_mux_api_set(GPIO3A7_SMCADDR15_HOSTDATA15_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB0:
+        {
+             rk29_mux_api_set(GPIO3B0_EMMCLKOUT_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB1:
+        {
+             rk29_mux_api_set(GPIO3B1_EMMCMD_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB2:
+        {
+             rk29_mux_api_set(GPIO3B2_EMMCDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB3:
+        {
+             rk29_mux_api_set(GPIO3B3_EMMCDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB4:
+        {
+             rk29_mux_api_set(GPIO3B4_EMMCDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB5:
+        {
+             rk29_mux_api_set(GPIO3B5_EMMCDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB6:
+        {
+             rk29_mux_api_set(GPIO3B6_EMMCDATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PB7:
+        {
+             rk29_mux_api_set(GPIO3B7_EMMCDATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC0:
+        {
+             rk29_mux_api_set(GPIO3C0_EMMCDATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC1:
+        {
+             rk29_mux_api_set(GPIO3C1_EMMCDATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC2:
+        {
+             rk29_mux_api_set(GPIO3C2_SMCADDR13_HOSTDATA13_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC3:
+        {
+             rk29_mux_api_set(GPIO3C3_SMCADDR10_HOSTDATA10_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC4:
+        {
+             rk29_mux_api_set(GPIO3C4_SMCADDR11_HOSTDATA11_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC5:
+        {
+             rk29_mux_api_set(GPIO3C5_SMCADDR12_HOSTDATA12_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC6:
+        {
+             rk29_mux_api_set(GPIO3C6_SMCADDR16_HOSTDATA16_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PC7:
+        {
+             rk29_mux_api_set(GPIO3C7_SMCADDR17_HOSTDATA17_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD0:
+        {
+             rk29_mux_api_set(GPIO3D0_SMCADDR18_HOSTADDR0_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD1:
+        {
+             rk29_mux_api_set(GPIO3D1_SMCADDR19_HOSTADDR1_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD2:
+        {
+             rk29_mux_api_set(GPIO3D2_HOSTCSN_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD3:
+        {
+             rk29_mux_api_set(GPIO3D3_HOSTRDN_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD4:
+        {
+             rk29_mux_api_set(GPIO3D4_HOSTWRN_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD5:
+        {
+             rk29_mux_api_set(GPIO3D5_SMCADDR7_HOSTDATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD6:
+        {
+             rk29_mux_api_set(GPIO3D6_SMCADDR8_HOSTDATA8_NAME,0);
+            break;	
+        }
+        case RK29_PIN3_PD7:
+        {
+             rk29_mux_api_set(GPIO3D7_SMCADDR9_HOSTDATA9_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PA0:
+        case RK29_PIN4_PA1:
+        case RK29_PIN4_PA2:
+        case RK29_PIN4_PA3:
+        case RK29_PIN4_PA4:
+        {            
+            break;	
+        }
+        case RK29_PIN4_PA5:
+        {
+             rk29_mux_api_set(GPIO4A5_OTG0DRVVBUS_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PA6:
+        {
+             rk29_mux_api_set(GPIO4A6_OTG1DRVVBUS_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PA7:
+        {
+             rk29_mux_api_set(GPIO4A7_SPDIFTX_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB0:
+        {
+             rk29_mux_api_set(GPIO4B0_FLASHDATA8_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB1:
+        {
+             rk29_mux_api_set(GPIO4B1_FLASHDATA9_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB2:
+        {
+             rk29_mux_api_set(GPIO4B2_FLASHDATA10_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB3:
+        {
+             rk29_mux_api_set(GPIO4B3_FLASHDATA11_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB4:
+        {
+             rk29_mux_api_set(GPIO4B4_FLASHDATA12_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB5:
+        {
+             rk29_mux_api_set(GPIO4B5_FLASHDATA13_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PB6:
+        {
+             rk29_mux_api_set(GPIO4B6_FLASHDATA14_NAME ,0);
+            break;	
+        }
+        case RK29_PIN4_PB7:
+        {
+             rk29_mux_api_set(GPIO4B7_FLASHDATA15_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC0:
+        {
+             rk29_mux_api_set(GPIO4C0_RMIICLKOUT_RMIICLKIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC1:
+        {
+             rk29_mux_api_set(GPIO4C1_RMIITXEN_MIITXEN_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC2:
+        {
+             rk29_mux_api_set(GPIO4C2_RMIITXD1_MIITXD1_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC3:
+        {
+             rk29_mux_api_set(GPIO4C3_RMIITXD0_MIITXD0_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC4:
+        {
+             rk29_mux_api_set(GPIO4C4_RMIIRXERR_MIIRXERR_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC5:
+        {
+             rk29_mux_api_set(GPIO4C5_RMIICSRDVALID_MIIRXDVALID_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PC6:
+        {
+             rk29_mux_api_set(GPIO4C6_RMIIRXD1_MIIRXD1_NAME,0);
+            break;	
+        }
+
+        case RK29_PIN4_PC7:
+        {
+             rk29_mux_api_set(GPIO4C7_RMIIRXD0_MIIRXD0_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PD0:
+        case RK29_PIN4_PD1:
+        {
+             rk29_mux_api_set(GPIO4D10_CPUTRACEDATA10_NAME,0);             
+            break;	
+        }
+        case RK29_PIN4_PD2:
+        case RK29_PIN4_PD3:
+        {
+             rk29_mux_api_set(GPIO4D32_CPUTRACEDATA32_NAME,0);           
+            break;	
+        }
+        case RK29_PIN4_PD4:
+        {
+             rk29_mux_api_set(GPIO4D4_CPUTRACECLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PD5:
+        {
+             rk29_mux_api_set(GPIO4D5_CPUTRACECTL_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PD6:
+        {
+             rk29_mux_api_set(GPIO4D6_I2S0LRCKTX0_NAME,0);
+            break;	
+        }
+        case RK29_PIN4_PD7:
+        {
+             rk29_mux_api_set(GPIO4D7_I2S0LRCKTX1_NAME,0);
+            break;	
+        } 
+        case RK29_PIN5_PA0:
+        case RK29_PIN5_PA1:
+        case RK29_PIN5_PA2:
+        {      
+            break;	
+        }
+        case RK29_PIN5_PA3:
+        {
+             rk29_mux_api_set(GPIO5A3_MIITXCLKIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PA4:
+        {
+             rk29_mux_api_set(GPIO5A4_TSSYNC_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PA5:
+        {
+             rk29_mux_api_set(GPIO5A5_HSADCDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PA6:
+        {
+             rk29_mux_api_set(GPIO5A6_HSADCDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PA7:
+        {
+             rk29_mux_api_set(GPIO5A7_HSADCDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB0:
+        {
+             rk29_mux_api_set(GPIO5B0_HSADCDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB1:
+        {
+             rk29_mux_api_set(GPIO5B1_HSADCDATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB2:
+        {
+             rk29_mux_api_set(GPIO5B2_HSADCDATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB3:
+        {
+             rk29_mux_api_set(GPIO5B3_HSADCDATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB4:
+        {
+             rk29_mux_api_set(GPIO5B4_HSADCDATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB5:
+        {
+             rk29_mux_api_set(GPIO5B5_HSADCDATA8_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB6:
+        {
+             rk29_mux_api_set(GPIO5B6_HSADCDATA9_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PB7:
+        {
+             rk29_mux_api_set(GPIO5B7_HSADCCLKOUTGPSCLK_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC0:
+        {
+             rk29_mux_api_set(GPIO5C0_EBCSDDO0_SMCDATA0_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC1:
+        {
+             rk29_mux_api_set(GPIO5C1_EBCSDDO1_SMCDATA1_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC2:
+        {
+             rk29_mux_api_set(GPIO5C2_EBCSDDO2_SMCDATA2_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC3:
+        {
+             rk29_mux_api_set(GPIO5C3_EBCSDDO3_SMCDATA3_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC4:
+        {
+             rk29_mux_api_set(GPIO5C4_EBCSDDO4_SMCDATA4_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC5:
+        {
+             rk29_mux_api_set(GPIO5C5_EBCSDDO5_SMCDATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC6:
+        {
+             rk29_mux_api_set(GPIO5C6_EBCSDDO6_SMCDATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PC7:
+        {
+             rk29_mux_api_set(GPIO5C7_EBCSDDO7_SMCDATA7_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD0:
+        {
+             rk29_mux_api_set(GPIO5D0_EBCSDLE_SMCADDR5_HOSTDATA5_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD1:
+        {
+             rk29_mux_api_set(GPIO5D1_EBCSDCLK_SMCADDR6_HOSTDATA6_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD2:
+        {
+             rk29_mux_api_set(GPIO5D2_PWM1_UART1SIRIN_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD3:
+        {
+             rk29_mux_api_set(GPIO5D3_I2C2SDA_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD4:
+        {
+             rk29_mux_api_set(GPIO5D4_I2C2SCL_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD5:
+        {
+             rk29_mux_api_set(GPIO5D5_SDMMC0PWREN_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD6:
+        {
+             rk29_mux_api_set(GPIO5D6_SDMMC1PWREN_NAME,0);
+            break;	
+        }
+        case RK29_PIN5_PD7:
+        case RK29_PIN6_PA0:
+        case RK29_PIN6_PA1:
+        case RK29_PIN6_PA2:
+        case RK29_PIN6_PA3:
+        case RK29_PIN6_PA4:
+        case RK29_PIN6_PA5:
+        case RK29_PIN6_PA6:
+        case RK29_PIN6_PA7:
+        case RK29_PIN6_PB0:
+        case RK29_PIN6_PB1:
+        case RK29_PIN6_PB2:
+        case RK29_PIN6_PB3:
+        case RK29_PIN6_PB4:
+        case RK29_PIN6_PB5:
+        case RK29_PIN6_PB6:
+        case RK29_PIN6_PB7:
+        case RK29_PIN6_PC0:
+        case RK29_PIN6_PC1:
+        case RK29_PIN6_PC2:
+        case RK29_PIN6_PC3:
+        {
+            break;
+        }
+        case RK29_PIN6_PC4:
+        case RK29_PIN6_PC5:
+        {
+             rk29_mux_api_set(GPIO6C54_CPUTRACEDATA54_NAME,0);
+            break;	
+        }
+        case RK29_PIN6_PC6:
+        case RK29_PIN6_PC7:
+        {
+             rk29_mux_api_set(GPIO6C76_CPUTRACEDATA76_NAME,0);
+            break;	
+        }
+        case RK29_PIN6_PD0:
+        case RK29_PIN6_PD1:
+        case RK29_PIN6_PD2:
+        case RK29_PIN6_PD3:
+        case RK29_PIN6_PD4:
+        case RK29_PIN6_PD5:
+        case RK29_PIN6_PD6:
+        case RK29_PIN6_PD7:
+        {
+            break;	
+        }    
+        default:
+        {
+            printk("Pin=%d isn't RK29 GPIO, Please init it's iomux yourself!",pin);
+            break;
+        }
+    }
+    return 0;
+}
+
+static int sensor_power_default_cb (struct rk29camera_gpio_res *res, int on)
+{
+    int camera_power = res->gpio_power;
+    int camera_ioflag = res->gpio_flag;
+    int camera_io_init = res->gpio_init;
+    int ret = 0;
+    
+    if (camera_power != INVALID_GPIO)  {
+		     if (camera_io_init & RK29_CAM_POWERACTIVE_MASK) {
+            if (on) {
+            	gpio_set_value(camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+    			dprintk("%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+    			msleep(10);
+    		} else {
+    			gpio_set_value(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+    			dprintk("%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+    		}
+		} else {
+			ret = RK29_CAM_EIO_REQUESTFAIL;
+			printk("%s..%s..PowerPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_power);
+	    }        
+    } else {
+		ret = RK29_CAM_EIO_INVALID;
+    } 
+
+    return ret;
+}
+
+static int sensor_reset_default_cb (struct rk29camera_gpio_res *res, int on)
+{
+    int camera_reset = res->gpio_reset;
+    int camera_ioflag = res->gpio_flag;
+    int camera_io_init = res->gpio_init;  
+    int ret = 0;
+    
+    if (camera_reset != INVALID_GPIO) {
+		if (camera_io_init & RK29_CAM_RESETACTIVE_MASK) {
+			if (on) {
+	        	gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+	        	dprintk("%s..%s..ResetPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+			} else {
+				gpio_set_value(camera_reset,(((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+        		dprintk("%s..%s..ResetPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_reset, (((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+	        }
+		} else {
+			ret = RK29_CAM_EIO_REQUESTFAIL;
+			printk("%s..%s..ResetPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_reset);
+		}
+    } else {
+		ret = RK29_CAM_EIO_INVALID;
+    }
+
+    return ret;
+}
+
+static int sensor_powerdown_default_cb (struct rk29camera_gpio_res *res, int on)
+{
+    int camera_powerdown = res->gpio_powerdown;
+    int camera_ioflag = res->gpio_flag;
+    int camera_io_init = res->gpio_init;  
+    int ret = 0;    
+
+    if (camera_powerdown != INVALID_GPIO) {
+		if (camera_io_init & RK29_CAM_POWERDNACTIVE_MASK) {
+			if (on) {
+	        	gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+	        	dprintk("%s..%s..PowerDownPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+			} else {
+				gpio_set_value(camera_powerdown,(((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+        		dprintk("%s..%s..PowerDownPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_powerdown, (((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+	        }
+		} else {
+			ret = RK29_CAM_EIO_REQUESTFAIL;
+			dprintk("%s..%s..PowerDownPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_powerdown);
+		}
+    } else {
+		ret = RK29_CAM_EIO_INVALID;
+    }
+    return ret;
+}
+
+
+static int sensor_flash_default_cb (struct rk29camera_gpio_res *res, int on)
+{
+    int camera_flash = res->gpio_flash;
+    int camera_ioflag = res->gpio_flag;
+    int camera_io_init = res->gpio_init;  
+    int ret = 0;    
+
+    if (camera_flash != INVALID_GPIO) {
+		if (camera_io_init & RK29_CAM_FLASHACTIVE_MASK) {
+            switch (on)
+            {
+                case Flash_Off:
+                {
+                    gpio_set_value(camera_flash,(((~camera_ioflag)&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+        		    dprintk("\n%s..%s..FlashPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_flash, (((~camera_ioflag)&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS)); 
+        		    break;
+                }
+
+                case Flash_On:
+                {
+                    gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    dprintk("%s..%s..FlashPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    break;
+                }
+
+                case Flash_Torch:
+                {
+                    gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    dprintk("%s..%s..FlashPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    break;
+                }
+
+                default:
+                {
+                    printk("%s..%s..Flash command(%d) is invalidate \n",__FUNCTION__,res->dev_name,on);
+                    break;
+                }
+            }
+		} else {
+			ret = RK29_CAM_EIO_REQUESTFAIL;
+			printk("%s..%s..FlashPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_flash);
+		}
+    } else {
+		ret = RK29_CAM_EIO_INVALID;
+    }
+    return ret;
+}
+
+
+static int rk29_sensor_io_init(void)
+{
+    int ret = 0, i,j;
+    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
+	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO;
+	unsigned int camera_ioflag;
+
+    if (sensor_ioctl_cb.sensor_power_cb == NULL)
+        sensor_ioctl_cb.sensor_power_cb = sensor_power_default_cb;
+    if (sensor_ioctl_cb.sensor_reset_cb == NULL)
+        sensor_ioctl_cb.sensor_reset_cb = sensor_reset_default_cb;
+    if (sensor_ioctl_cb.sensor_powerdown_cb == NULL)
+        sensor_ioctl_cb.sensor_powerdown_cb = sensor_powerdown_default_cb;
+    if (sensor_ioctl_cb.sensor_flash_cb == NULL)
+        sensor_ioctl_cb.sensor_flash_cb = sensor_flash_default_cb;
+    
+    for (i=0; i<2; i++) {
+        camera_reset = rk29_camera_platform_data.gpio_res[i].gpio_reset;
+        camera_power = rk29_camera_platform_data.gpio_res[i].gpio_power;
+		camera_powerdown = rk29_camera_platform_data.gpio_res[i].gpio_powerdown;
+        camera_flash = rk29_camera_platform_data.gpio_res[i].gpio_flash;
+		camera_ioflag = rk29_camera_platform_data.gpio_res[i].gpio_flag;
+		rk29_camera_platform_data.gpio_res[i].gpio_init = 0;
+
+        if (camera_power != INVALID_GPIO) {
+            ret = gpio_request(camera_power, "camera power");
+            if (ret) {
+                if (i == 0) {
+                    printk("%s..%s..power pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
+				    goto sensor_io_int_loop_end;
+                } else {
+                    if (camera_power != rk29_camera_platform_data.gpio_res[0].gpio_power) {
+                        printk("%s..%s..power pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
+                        goto sensor_io_int_loop_end;
+                    }
+                }
+            }
+
+            if (rk29_sensor_iomux(camera_power) < 0) {
+                printk(KERN_ERR "%s..%s..power pin(%d) iomux init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_power);
+                goto sensor_io_int_loop_end;
+            }
+            
+			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_POWERACTIVE_MASK;
+            gpio_set_value(camera_reset, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+            gpio_direction_output(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+
+			dprintk("%s....power pin(%d) init success(0x%x)  \n",__FUNCTION__,camera_power,(((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+
+        }
+
+        if (camera_reset != INVALID_GPIO) {
+            ret = gpio_request(camera_reset, "camera reset");
+            if (ret) {
+                printk("%s..%s..reset pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_reset);
+                goto sensor_io_int_loop_end;
+            }
+
+            if (rk29_sensor_iomux(camera_reset) < 0) {
+                printk(KERN_ERR "%s..%s..reset pin(%d) iomux init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_reset);
+                goto sensor_io_int_loop_end;
+            }
+            
+			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_RESETACTIVE_MASK;
+            gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+            gpio_direction_output(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+
+			dprintk("%s....reset pin(%d) init success(0x%x)\n",__FUNCTION__,camera_reset,((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+
+        }
+
+		if (camera_powerdown != INVALID_GPIO) {
+            ret = gpio_request(camera_powerdown, "camera powerdown");
+            if (ret) {
+                printk("%s..%s..powerdown pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_powerdown);
+                goto sensor_io_int_loop_end;
+            }
+
+            if (rk29_sensor_iomux(camera_powerdown) < 0) {
+                printk(KERN_ERR "%s..%s..powerdown pin(%d) iomux init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_powerdown);
+                goto sensor_io_int_loop_end;
+            }
+            
+			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_POWERDNACTIVE_MASK;
+            gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+            gpio_direction_output(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+
+			dprintk("%s....powerdown pin(%d) init success(0x%x) \n",__FUNCTION__,camera_powerdown,((camera_ioflag&RK29_CAM_POWERDNACTIVE_BITPOS)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+
+        }
+
+		if (camera_flash != INVALID_GPIO) {
+            ret = gpio_request(camera_flash, "camera flash");
+            if (ret) {
+                printk("%s..%s..flash pin(%d) init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_flash);
+				goto sensor_io_int_loop_end;
+            }
+
+            if (rk29_sensor_iomux(camera_flash) < 0) {
+                printk(KERN_ERR "%s..%s..flash pin(%d) iomux init failed\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[i].dev_name,camera_flash);                
+            }
+            
+			rk29_camera_platform_data.gpio_res[i].gpio_init |= RK29_CAM_FLASHACTIVE_MASK;
+            gpio_set_value(camera_flash, ((~camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));    /* falsh off */
+            gpio_direction_output(camera_flash, ((~camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+
+			dprintk("%s....flash pin(%d) init success(0x%x) \n",__FUNCTION__,camera_flash,((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+
+        }  
+
+        
+        for (j=0; j<10; j++) {
+            memset(&rk29_camera_platform_data.info[i].fival[j],0x00,sizeof(struct v4l2_frmivalenum));
+        }
+        j=0;
+        if (strstr(rk29_camera_platform_data.info[i].dev_name,"_back")) {
+            
+            #if CONFIG_SENSOR_QCIF_FPS_FIXED_0
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QCIF_FPS_FIXED_0;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 176;
+            rk29_camera_platform_data.info[i].fival[j].height = 144;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_QVGA_FPS_FIXED_0
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QVGA_FPS_FIXED_0;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 320;
+            rk29_camera_platform_data.info[i].fival[j].height = 240;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_CIF_FPS_FIXED_0
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_CIF_FPS_FIXED_0;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 352;
+            rk29_camera_platform_data.info[i].fival[j].height = 288;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_VGA_FPS_FIXED_0
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_VGA_FPS_FIXED_0;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 640;
+            rk29_camera_platform_data.info[i].fival[j].height = 480;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_480P_FPS_FIXED_0
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_480P_FPS_FIXED_0;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 720;
+            rk29_camera_platform_data.info[i].fival[j].height = 480;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif            
+
+            #if CONFIG_SENSOR_SVGA_FPS_FIXED_0
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_SVGA_FPS_FIXED_0;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 800;
+            rk29_camera_platform_data.info[i].fival[j].height = 600;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_720P_FPS_FIXED_0
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_720P_FPS_FIXED_0;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 1280;
+            rk29_camera_platform_data.info[i].fival[j].height = 720;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+        } else {
+            #if CONFIG_SENSOR_QCIF_FPS_FIXED_1
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QCIF_FPS_FIXED_1;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 176;
+            rk29_camera_platform_data.info[i].fival[j].height = 144;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_QVGA_FPS_FIXED_1
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QVGA_FPS_FIXED_1;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 320;
+            rk29_camera_platform_data.info[i].fival[j].height = 240;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_CIF_FPS_FIXED_1
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_CIF_FPS_FIXED_1;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 352;
+            rk29_camera_platform_data.info[i].fival[j].height = 288;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_VGA_FPS_FIXED_1
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_VGA_FPS_FIXED_1;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 640;
+            rk29_camera_platform_data.info[i].fival[j].height = 480;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_480P_FPS_FIXED_1
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_480P_FPS_FIXED_1;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 720;
+            rk29_camera_platform_data.info[i].fival[j].height = 480;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif 
+
+            #if CONFIG_SENSOR_SVGA_FPS_FIXED_1
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_SVGA_FPS_FIXED_1;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 800;
+            rk29_camera_platform_data.info[i].fival[j].height = 600;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+
+            #if CONFIG_SENSOR_720P_FPS_FIXED_1
+            rk29_camera_platform_data.info[i].fival[j].discrete.denominator = CONFIG_SENSOR_720P_FPS_FIXED_1;
+            rk29_camera_platform_data.info[i].fival[j].discrete.numerator= 1000;
+            rk29_camera_platform_data.info[i].fival[j].index = 0;
+            rk29_camera_platform_data.info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
+            rk29_camera_platform_data.info[i].fival[j].width = 1280;
+            rk29_camera_platform_data.info[i].fival[j].height = 720;
+            rk29_camera_platform_data.info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
+            j++;
+            #endif
+        }
+        
+		continue;
+sensor_io_int_loop_end:
+		rk29_sensor_io_deinit(i);
+		continue;
+    }
+
+    return 0;
+}
+
+static int rk29_sensor_io_deinit(int sensor)
+{
+    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
+	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO;
+
+    camera_reset = rk29_camera_platform_data.gpio_res[sensor].gpio_reset;
+    camera_power = rk29_camera_platform_data.gpio_res[sensor].gpio_power;
+	camera_powerdown = rk29_camera_platform_data.gpio_res[sensor].gpio_powerdown;
+    camera_flash = rk29_camera_platform_data.gpio_res[sensor].gpio_flash;
+
+    printk("%s..%s enter..\n",__FUNCTION__,rk29_camera_platform_data.gpio_res[sensor].dev_name);
+
+	if (rk29_camera_platform_data.gpio_res[sensor].gpio_init & RK29_CAM_POWERACTIVE_MASK) {
+	    if (camera_power != INVALID_GPIO) {
+	        gpio_direction_input(camera_power);
+	        gpio_free(camera_power);
+	    }
+	}
+
+	if (rk29_camera_platform_data.gpio_res[sensor].gpio_init & RK29_CAM_RESETACTIVE_MASK) {
+	    if (camera_reset != INVALID_GPIO)  {
+	        gpio_direction_input(camera_reset);
+	        gpio_free(camera_reset);
+	    }
+	}
+
+	if (rk29_camera_platform_data.gpio_res[sensor].gpio_init & RK29_CAM_POWERDNACTIVE_MASK) {
+	    if (camera_powerdown != INVALID_GPIO)  {
+	        gpio_direction_input(camera_powerdown);
+	        gpio_free(camera_powerdown);
+	    }
+	}
+
+	if (rk29_camera_platform_data.gpio_res[sensor].gpio_init & RK29_CAM_FLASHACTIVE_MASK) {
+	    if (camera_flash != INVALID_GPIO)  {
+	        gpio_direction_input(camera_flash);
+	        gpio_free(camera_flash);
+	    }
+	}
+
+	rk29_camera_platform_data.gpio_res[sensor].gpio_init = 0;
+    return 0;
+}
+static int rk29_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd, int on)
+{
+    struct rk29camera_gpio_res *res = NULL;    
+	int ret = RK29_CAM_IO_SUCCESS;
+
+    if(rk29_camera_platform_data.gpio_res[0].dev_name &&  (strcmp(rk29_camera_platform_data.gpio_res[0].dev_name, dev_name(dev)) == 0)) {
+		res = (struct rk29camera_gpio_res *)&rk29_camera_platform_data.gpio_res[0];
+    } else if (rk29_camera_platform_data.gpio_res[1].dev_name && (strcmp(rk29_camera_platform_data.gpio_res[1].dev_name, dev_name(dev)) == 0)) {
+    	res = (struct rk29camera_gpio_res *)&rk29_camera_platform_data.gpio_res[1];
+    } else {
+        printk(KERN_ERR "%s is not regisiterd in rk29_camera_platform_data!!\n",dev_name(dev));
+        ret = RK29_CAM_EIO_INVALID;
+        goto rk29_sensor_ioctrl_end;
+    }
+
+ 	switch (cmd)
+ 	{
+ 		case Cam_Power:
+		{
+			if (sensor_ioctl_cb.sensor_power_cb) {
+                ret = sensor_ioctl_cb.sensor_power_cb(res, on);
+			} else {
+                printk(KERN_ERR "sensor_ioctl_cb.sensor_power_cb is NULL");
+                WARN_ON(1);
+			}
+			break;
+		}
+		case Cam_Reset:
+		{
+			if (sensor_ioctl_cb.sensor_reset_cb) {
+                ret = sensor_ioctl_cb.sensor_reset_cb(res, on);
+			} else {
+                printk(KERN_ERR "sensor_ioctl_cb.sensor_reset_cb is NULL");
+                WARN_ON(1);
+			}
+			break;
+		}
+
+		case Cam_PowerDown:
+		{
+			if (sensor_ioctl_cb.sensor_powerdown_cb) {
+                ret = sensor_ioctl_cb.sensor_powerdown_cb(res, on);
+			} else {
+                printk(KERN_ERR "sensor_ioctl_cb.sensor_powerdown_cb is NULL");
+                WARN_ON(1);
+			}
+			break;
+		}
+
+		case Cam_Flash:
+		{
+			if (sensor_ioctl_cb.sensor_flash_cb) {
+                ret = sensor_ioctl_cb.sensor_flash_cb(res, on);
+			} else {
+                printk(KERN_ERR "sensor_ioctl_cb.sensor_flash_cb is NULL!");
+                WARN_ON(1);
+			}
+			break;
+		}
+		default:
+		{
+			printk("%s cmd(0x%x) is unknown!\n",__FUNCTION__, cmd);
+			break;
+		}
+ 	}
+rk29_sensor_ioctrl_end:
+    return ret;
+}
+static int rk29_sensor_power(struct device *dev, int on)
+{
+	rk29_sensor_ioctrl(dev,Cam_Power,on);
+    return 0;
+}
+#if (CONFIG_SENSOR_RESET_PIN_0 != INVALID_GPIO) || (CONFIG_SENSOR_RESET_PIN_1 != INVALID_GPIO)
+static int rk29_sensor_reset(struct device *dev)
+{
+	rk29_sensor_ioctrl(dev,Cam_Reset,1);
+	msleep(2);
+	rk29_sensor_ioctrl(dev,Cam_Reset,0);
+	return 0;
+}
+#endif
+static int rk29_sensor_powerdown(struct device *dev, int on)
+{
+	return rk29_sensor_ioctrl(dev,Cam_PowerDown,on);
+}
+#if (CONFIG_SENSOR_IIC_ADDR_0 != 0x00)
+static struct i2c_board_info rk29_i2c_cam_info_0[] = {
+	{
+		I2C_BOARD_INFO(SENSOR_NAME_0, CONFIG_SENSOR_IIC_ADDR_0>>1)
+	},
+};
+
+static struct soc_camera_link rk29_iclink_0 = {
+	.bus_id		= RK29_CAM_PLATFORM_DEV_ID,
+	.power		= rk29_sensor_power,
+#if (CONFIG_SENSOR_RESET_PIN_0 != INVALID_GPIO)
+    .reset      = rk29_sensor_reset,
+#endif    
+	.powerdown  = rk29_sensor_powerdown,
+	.board_info	= &rk29_i2c_cam_info_0[0],
+	.i2c_adapter_id	= CONFIG_SENSOR_IIC_ADAPTER_ID_0,
+	.module_name	= SENSOR_NAME_0,
+};
+
+/*platform_device : soc-camera need  */
+static struct platform_device rk29_soc_camera_pdrv_0 = {
+	.name	= "soc-camera-pdrv",
+	.id	= 0,
+	.dev	= {
+		.init_name = SENSOR_DEVICE_NAME_0,
+		.platform_data = &rk29_iclink_0,
+	},
+};
+#endif
+#if (CONFIG_SENSOR_IIC_ADDR_1 != 0x00)
+static struct i2c_board_info rk29_i2c_cam_info_1[] = {
+	{
+		I2C_BOARD_INFO(SENSOR_NAME_1, CONFIG_SENSOR_IIC_ADDR_1>>1)
+	},
+};
+
+static struct soc_camera_link rk29_iclink_1 = {
+	.bus_id		= RK29_CAM_PLATFORM_DEV_ID,
+	.power		= rk29_sensor_power,
+#if (CONFIG_SENSOR_RESET_PIN_1 != INVALID_GPIO)
+    .reset      = rk29_sensor_reset,
+#endif  	
+	.powerdown  = rk29_sensor_powerdown,
+	.board_info	= &rk29_i2c_cam_info_1[0],
+	.i2c_adapter_id	= CONFIG_SENSOR_IIC_ADAPTER_ID_1,
+	.module_name	= SENSOR_NAME_1,
+};
+
+/*platform_device : soc-camera need  */
+static struct platform_device rk29_soc_camera_pdrv_1 = {
+	.name	= "soc-camera-pdrv",
+	.id	= 1,
+	.dev	= {
+		.init_name = SENSOR_DEVICE_NAME_1,
+		.platform_data = &rk29_iclink_1,
+	},
+};
+#endif
+
+static u64 rockchip_device_camera_dmamask = 0xffffffffUL;
+static struct resource rk29_camera_resource[] = {
+	[0] = {
+		.start = RK29_VIP_PHYS,
+		.end   = RK29_VIP_PHYS + RK29_VIP_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_VIP,
+		.end   = IRQ_VIP,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+/*platform_device : */
+static struct platform_device rk29_device_camera = {
+	.name		  = RK29_CAM_DRV_NAME,
+	.id		  = RK29_CAM_PLATFORM_DEV_ID,               /* This is used to put cameras on this interface */
+	.num_resources	  = ARRAY_SIZE(rk29_camera_resource),
+	.resource	  = rk29_camera_resource,
+	.dev            = {
+		.dma_mask = &rockchip_device_camera_dmamask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data  = &rk29_camera_platform_data,
+	}
+};
+
+static struct android_pmem_platform_data android_pmem_cam_pdata = {
+	.name		= "pmem_cam",
+	.start		= PMEM_CAM_BASE,
+	.size		= PMEM_CAM_SIZE,
+	.no_allocator	= 1,
+	.cached		= 1,
+};
+
+static struct platform_device android_pmem_cam_device = {
+	.name		= "android_pmem",
+	.id		= 1,
+	.dev		= {
+		.platform_data = &android_pmem_cam_pdata,
+	},
+};
+
+#endif
+
+#endif //#ifdef CONFIG_VIDEO_RK29
diff --git a/drivers/media/video/rk_camera_oneframe.c b/drivers/media/video/rk29_camera_oneframe.c
old mode 100644
new mode 100755
similarity index 52%
rename from drivers/media/video/rk_camera_oneframe.c
rename to drivers/media/video/rk29_camera_oneframe.c
index 4b6f178843dc..53232ef559e1
--- a/drivers/media/video/rk_camera_oneframe.c
+++ b/drivers/media/video/rk29_camera_oneframe.c
@@ -29,15 +29,15 @@
 #include <linux/platform_device.h>
 #include <linux/mutex.h>
 #include <linux/videodev2.h>
-#include <mach/rk_camera.h>
+#include <mach/rk29_camera.h>
+#include <mach/rk29_iomap.h>
 #include <mach/iomux.h>
 #include <media/v4l2-common.h>
 #include <media/v4l2-dev.h>
 #include <media/videobuf-dma-contig.h>
 #include <media/soc_camera.h>
 #include <media/soc_mediabus.h>
-#include <mach/io.h>
-#include <plat/ipp.h>
+#include <mach/rk29-ipp.h>
 
 
 static int debug;
@@ -45,142 +45,114 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 
 #define dprintk(level, fmt, arg...) do {			\
 	if (debug >= level) 					\
-	printk(KERN_WARNING"rk_camera: " fmt , ## arg); } while (0)
-
-#define RKCAMERA_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
-#define RKCAMERA_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)
-
-// CIF Reg Offset
-#define  CIF_CIF_CTRL                0x00
-#define  CIF_CIF_INTEN                 0x04
-#define  CIF_CIF_INTSTAT                  0x08
-#define  CIF_CIF_FOR                      0x0c
-#define  CIF_CIF_LINE_NUM_ADDR                     0x10
-#define  CIF_CIF_FRM0_ADDR_Y           0x14
-#define  CIF_CIF_FRM0_ADDR_UV          0x18
-#define  CIF_CIF_FRM1_ADDR_Y          0x1c
-#define  CIF_CIF_FRM1_ADDR_UV           0x20
-#define  CIF_CIF_VIR_LINE_WIDTH          0x24
-#define  CIF_CIF_SET_SIZE          0x28
-#define  CIF_CIF_SCM_ADDR_Y                    0x2c
-#define  CIF_CIF_SCM_ADDR_U                       0x30
-#define  CIF_CIF_SCM_ADDR_V              0x34
-#define  CIF_CIF_WB_UP_FILTER                     0x38
-#define  CIF_CIF_WB_LOW_FILTER                      0x3c
-#define  CIF_CIF_WBC_CNT                    0x40
-#define  CIF_CIF_CROP                   0x44
-#define  CIF_CIF_SCL_CTRL		0x48
-#define	CIF_CIF_SCL_DST		0x4c
-#define	CIF_CIF_SCL_FCT		0x50
-#define	CIF_CIF_SCL_VALID_NUM		0x54
-#define	CIF_CIF_LINE_LOOP_CTR		0x58
-#define	CIF_CIF_FRAME_STATUS		0x60
-#define	CIF_CIF_CUR_DST			0x64
-#define	CIF_CIF_LAST_LINE			0x68
-#define	CIF_CIF_LAST_PIX			0x6c
+	printk(KERN_WARNING"rk29xx_camera: " fmt , ## arg); } while (0)
+
+#define RK29CAMERA_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
+#define RK29CAMERA_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)
+
+// VIP Reg Offset
+#define RK29_VIP_AHBR_CTRL                0x00
+#define RK29_VIP_INT_MASK                 0x04
+#define RK29_VIP_INT_STS                  0x08
+#define RK29_VIP_STS                      0x0c
+#define RK29_VIP_CTRL                     0x10
+#define RK29_VIP_CAPTURE_F1SA_Y           0x14
+#define RK29_VIP_CAPTURE_F1SA_UV          0x18
+#define RK29_VIP_CAPTURE_F1SA_Cr          0x1c
+#define RK29_VIP_CAPTURE_F2SA_Y           0x20
+#define RK29_VIP_CAPTURE_F2SA_UV          0x24
+#define RK29_VIP_CAPTURE_F2SA_Cr          0x28
+#define RK29_VIP_FB_SR                    0x2c
+#define RK29_VIP_FS                       0x30
+#define RK29_VIP_VIPRESERVED              0x34
+#define RK29_VIP_CROP                     0x38
+#define RK29_VIP_CRM                      0x3c
+#define RK29_VIP_RESET                    0x40
+#define RK29_VIP_L_SFT                    0x44
 
 //The key register bit descrition
-// CIF_CTRL Reg , ignore SCM,WBC,ISP,
+// VIP_CTRL Reg
 #define  DISABLE_CAPTURE              (0x00<<0)
 #define  ENABLE_CAPTURE               (0x01<<0)
-#define  MODE_ONEFRAME			(0x00<<1)
-#define  	MODE_PINGPONG		(0x01<<1)
-#define 	MODE_LINELOOP		(0x02<<1)
-#define  AXI_BURST_16			(0x0F << 12)
-
-//CIF_CIF_INTEN
-#define 	FRAME_END_EN			(0x01<<1)
-#define 	BUS_ERR_EN				(0x01<<6)
-#define	SCL_ERR_EN				(0x01<<7)
-
-//CIF_CIF_FOR
-#define  VSY_HIGH_ACTIVE              (0x01<<0)
-#define  VSY_LOW_ACTIVE               (0x00<<0)
-#define  HSY_LOW_ACTIVE 			  (0x01<<1)
-#define  HSY_HIGH_ACTIVE			  (0x00<<1)
-#define  INPUT_MODE_YUV 			(0x00<<2)
-#define  INPUT_MODE_PAL 			(0x02<<2)
-#define  INPUT_MODE_NTSC 			(0x03<<2)
-#define  INPUT_MODE_RAW 			(0x04<<2)
-#define  INPUT_MODE_JPEG 			(0x05<<2)
-#define  INPUT_MODE_MIPI			(0x06<<2)
-#define	YUV_INPUT_ORDER_UYVY	(0x00<<5)
-#define YUV_INPUT_ORDER_YVYU		(0x01<<5)
-#define YUV_INPUT_ORDER_VYUY		(0x02<<5)
-#define YUV_INPUT_ORDER_YUYV		(0x03<<5)
-#define YUV_INPUT_422		(0x00<<7)
-#define YUV_INPUT_420		(0x01<<7)
-#define INPUT_420_ORDER_EVEN		(0x00<<8)
-#define INPUT_420_ORDER_ODD		(0x01<<8)
-#define CCIR_INPUT_ORDER_ODD		(0x00<<9)
-#define CCIR_INPUT_ORDER_EVEN		(0x01<<9)
-#define RAW_DATA_WIDTH_8			(0x00<<11)
-#define RAW_DATA_WIDTH_10		(0x01<<11)
-#define RAW_DATA_WIDTH_12		(0x02<<11)	
-#define YUV_OUTPUT_422				(0x00<<16)
-#define YUV_OUTPUT_420				(0x01<<16)
-#define OUTPUT_420_ORDER_EVEN		(0x00<<17)
-#define OUTPUT_420_ORDER_ODD 	(0x01<<17)
-#define RAWD_DATA_LITTLE_ENDIAN	(0x00<<18)
-#define RAWD_DATA_BIG_ENDIAN		(0x01<<18)
-#define UV_STORAGE_ORDER_UVUV	(0x00<<19)
-#define UV_STORAGE_ORDER_VUVU	(0x01<<19)
-
-//CIF_CIF_SCL_CTRL
-#define ENABLE_SCL_DOWN		(0x01<<0)		
-#define DISABLE_SCL_DOWN 		(0x00<<0)
-#define ENABLE_SCL_UP 	(0x01<<1)		
-#define DISABLE_SCL_UP		(0x00<<1)
-#define ENABLE_YUV_16BIT_BYPASS	(0x01<<4)
-#define DISABLE_YUV_16BIT_BYPASS	(0x00<<4)
-#define ENABLE_RAW_16BIT_BYPASS (0x01<<5)
-#define DISABLE_RAW_16BIT_BYPASS	(0x00<<5)
-#define ENABLE_32BIT_BYPASS (0x01<<6)
-#define DISABLE_32BIT_BYPASS	(0x00<<6)
-
-//CRU,PIXCLOCK
-#define CRU_PCLK_REG30 		0xbc
-#define ENANABLE_INVERT_PCLK_CIF0 		((0x1<<24)|(0x1<<8))
-#define DISABLE_INVERT_PCLK_CIF0		((0x1<<24)|(0x0<<8))
-#define ENANABLE_INVERT_PCLK_CIF1		((0x1<<28)|(0x1<<12))
-#define DISABLE_INVERT_PCLK_CIF1		((0x1<<28)|(0x0<<12))
+#define  HSY_HIGH_ACTIVE              (0x00<<1)
+#define  HSY_LOW_ACTIVE               (0x01<<1)
+#define  VIP_CCIR656                  (0x00<<2)
+#define  VIP_SENSOR                   (0x01<<2)
+#define  SENSOR_UYVY                  (0x00<<3)
+#define  SENSOR_YUYV                  (0x01<<3)
+#define  VIP_YUV                      (0x00<<4)
+#define  VIP_RAW                      (0x01<<4)
+#define  CON_OR_PIN                   (0x00<<5)
+#define  ONEFRAME                     (0x01<<5)
+#define  VIPREGYUV420                 (0x00<<6)
+#define  VIPREGYUV422                 (0x01<<6)
+#define  FIELD0_START                 (0x00<<7)
+#define  FIELD1_START                 (0x01<<7)
+#define  CONTINUOUS                   (0x00<<8)
+#define  PING_PONG                    (0x01<<8)
+#define  POSITIVE_EDGE                (0x00<<9)
+#define  NEGATIVE_EDGE                (0x01<<9)
+#define  VIPREGNTSC                   (0x00<<10)
+#define  VIPREGPAL                    (0x01<<10)
+#define  VIP_DATA_LITTLEEND           (0x00<<11)
+#define  VIP_DATA_BIGEND              (0x01<<11)
+#define  VSY_LOW_ACTIVE               (0x00<<12)
+#define  VSY_HIGH_ACTIVE              (0x01<<12)
+#define  VIP_RAWINPUT_BYPASS          (0x00<<13)
+#define  VIP_RAWINPUT_POSITIVE_EDGE   (0x01<<13)
+#define  VIP_RAWINPUT_NEGATIVE_EDGE   (0x02<<13)
+
+// GRF_SOC_CON0 Reg
+#define  GRF_SOC_CON0_Reg             0xbc
+#define  VIP_AXIMASTER                (0x00<<0)
+#define  VIP_AHBMASTER                (0x01<<2)
+
+// GRF_OS_REG0
+#define  GRF_OS_REG0                  0xd0
+#define  VIP_ACLK_DIV_HCLK_1          (0x00<<0)
+#define  VIP_ACLK_DIV_HCLK_2          (0x01<<0)
+
 
 #define MIN(x,y)   ((x<y) ? x: y)
 #define MAX(x,y)    ((x>y) ? x: y)
-#define RK_SENSOR_24MHZ      24           /* MHz */
-#define RK_SENSOR_48MHZ      48
+#define RK29_SENSOR_24MHZ      24           /* MHz */
+#define RK29_SENSOR_48MHZ      48
 
-#define write_cif_reg(base,addr, val)  __raw_writel(val, addr+(base))
-#define read_cif_reg(base,addr) __raw_readl(addr+(base))
-#define mask_cif_reg(addr, msk, val)    write_cif_reg(addr, (val)|((~(msk))&read_cif_reg(addr)))
+#define write_vip_reg(addr, val)  __raw_writel(val, addr+(rk29_camdev_info_ptr->base))
+#define read_vip_reg(addr) __raw_readl(addr+(rk29_camdev_info_ptr->base))
+#define mask_vip_reg(addr, msk, val)    write_vip_reg(addr, (val)|((~(msk))&read_vip_reg(addr)))
 
-#define write_cru_reg(addr, val)  __raw_writel(val, addr+RK30_CRU_BASE)
-#define read_cru_reg(addr) __raw_readl(addr+RK30_CRU_BASE)
-#define mask_cru_reg(addr, msk, val)	write_cif_reg(addr+RK30_CRU_BASE, (val)|((~(msk))&read_cif_reg(addr+RK30_CRU_BASE)))
+#define write_grf_reg(addr, val)  __raw_writel(val, addr+RK29_GRF_BASE)
+#define read_grf_reg(addr) __raw_readl(addr+RK29_GRF_BASE)
+#define mask_grf_reg(addr, msk, val)    write_vip_reg(addr, (val)|((~(msk))&read_vip_reg(addr)))
 
-#ifdef CONFIG_VIDEO_RK_DIGITALZOOM_IPP_OFF
+#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_OFF
 #define CAM_WORKQUEUE_IS_EN()   ((pcdev->host_width != pcdev->icd->user_width) || (pcdev->host_height != pcdev->icd->user_height)\
                                   || (pcdev->icd_cb.sensor_cb))
 #define CAM_IPPWORK_IS_EN()     ((pcdev->host_width != pcdev->icd->user_width) || (pcdev->host_height != pcdev->icd->user_height))                                  
 #else
-#define CAM_WORKQUEUE_IS_EN()  (true)
+#define CAM_WORKQUEUE_IS_EN()   (true)
 #define CAM_IPPWORK_IS_EN()     ((pcdev->zoominfo.a.c.width != pcdev->icd->user_width) || (pcdev->zoominfo.a.c.height != pcdev->icd->user_height))
 #endif
-
-#define IS_CIF0()		(pcdev->hostid == RK_CAM_PLATFORM_DEV_ID_0)
 //Configure Macro
 /*
 *            Driver Version Note
 *
-*v0.2.x : this driver is chip RK30 kernel driver;
-	 support VIDIOC_ENUM_FRAMEINTERVALS;
-	 support digital zoom;
-	 support test framerate and query framerate from board file configuration;
+*v0.0.x : this driver is 2.6.32 kernel driver;
+*v0.1.x : this driver is 3.0.8 kernel driver;
+*
+*v0.x.1 : this driver first support rk2918;
+*v0.x.2 : fix this driver support v4l2 format is V4L2_PIX_FMT_NV12 and V4L2_PIX_FMT_NV16,is not V4L2_PIX_FMT_YUV420 
+*         and V4L2_PIX_FMT_YUV422P;
+*v0.x.3 : this driver support VIDIOC_ENUM_FRAMEINTERVALS;
+*v0.x.4 : this driver support digital zoom;
+*v0.x.5 : this driver support test framerate and query framerate from board file configuration;
+*v0.x.6 : this driver improve test framerate method;
 */
-#define RK_CAM_VERSION_CODE KERNEL_VERSION(0, 2, 1)
+#define RK29_CAM_VERSION_CODE KERNEL_VERSION(0, 1, 6)
 
 /* limit to rk29 hardware capabilities */
-#define RK_CAM_BUS_PARAM   (SOCAM_MASTER |\
+#define RK29_CAM_BUS_PARAM   (SOCAM_MASTER |\
                 SOCAM_HSYNC_ACTIVE_HIGH |\
                 SOCAM_HSYNC_ACTIVE_LOW |\
                 SOCAM_VSYNC_ACTIVE_HIGH |\
@@ -192,76 +164,75 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
                 SOCAM_DATAWIDTH_8|SOCAM_DATAWIDTH_10|\
                 SOCAM_MCLK_24MHZ |SOCAM_MCLK_48MHZ)
 
-#define RK_CAM_W_MIN        48
-#define RK_CAM_H_MIN        32
-#define RK_CAM_W_MAX        3856            /* ddl@rock-chips.com : 10M Pixel */
-#define RK_CAM_H_MAX        2764
-#define RK_CAM_FRAME_INVAL_INIT 3
-#define RK_CAM_FRAME_INVAL_DC 3          /* ddl@rock-chips.com :  */
+#define RK29_CAM_W_MIN        48
+#define RK29_CAM_H_MIN        32
+#define RK29_CAM_W_MAX        3856            /* ddl@rock-chips.com : 10M Pixel */
+#define RK29_CAM_H_MAX        2764
+#define RK29_CAM_FRAME_INVAL_INIT 3
+#define RK29_CAM_FRAME_INVAL_DC 3          /* ddl@rock-chips.com :  */
+#define RK29_CAM_FRAME_MEASURE  5
+
+#define RK29_CAM_AXI   0
+#define RK29_CAM_AHB   1
+#define CONFIG_RK29_CAM_WORK_BUS    RK29_CAM_AXI
 
 extern void videobuf_dma_contig_free(struct videobuf_queue *q, struct videobuf_buffer *buf);
 extern dma_addr_t videobuf_to_dma_contig(struct videobuf_buffer *buf);
 
 /* buffer for one video frame */
-struct rk_camera_buffer
+struct rk29_buffer
 {
     /* common v4l buffer stuff -- must be first */
     struct videobuf_buffer vb;
     enum v4l2_mbus_pixelcode	code;
     int			inwork;
 };
-enum rk_camera_reg_state
+enum rk29_camera_reg_state
 {
 	Reg_Invalidate,
 	Reg_Validate
 };
 
-struct rk_camera_reg
+struct rk29_camera_reg
 {
-	unsigned int cifCtrl;
-	unsigned int cifCrop;
-	unsigned int cifFs;
-	unsigned int cifIntEn;
-	unsigned int cifFmt;
-//	unsigned int VipCrm;
-	enum rk_camera_reg_state Inval;
+	unsigned int VipCtrl;
+	unsigned int VipCrop;
+	unsigned int VipFs;
+	unsigned int VipIntMsk;
+	unsigned int VipCrm;
+	enum rk29_camera_reg_state Inval;
 };
-struct rk_camera_work
+struct rk29_camera_work
 {
 	struct videobuf_buffer *vb;
-	struct rk_camera_dev *pcdev;
+	struct rk29_camera_dev *pcdev;
 	struct work_struct work;
 };
-struct rk_camera_frmivalenum
+struct rk29_camera_frmivalenum
 {
     struct v4l2_frmivalenum fival;
-    struct rk_camera_frmivalenum *nxt;
+    struct rk29_camera_frmivalenum *nxt;
 };
-struct rk_camera_frmivalinfo
+struct rk29_camera_frmivalinfo
 {
     struct soc_camera_device *icd;
-    struct rk_camera_frmivalenum *fival_list;
+    struct rk29_camera_frmivalenum *fival_list;
 };
-struct rk_camera_zoominfo
+struct rk29_camera_zoominfo
 {
     struct semaphore sem;
     struct v4l2_crop a;
     int zoom_rate;
 };
-struct rk_camera_timer{
-	struct rk_camera_dev *pcdev;
-	struct hrtimer timer;
-	};
-struct rk_camera_dev
+struct rk29_camera_dev
 {
-	struct soc_camera_host	soc_host;
-	struct device		*dev;
-	/* RK2827x is only supposed to handle one camera on its Quick Capture
-	 * interface. If anyone ever builds hardware to enable more than
-	 * one camera, they will have to modify this driver too */
-	struct soc_camera_device *icd;
-
-	//************must modify start************/
+    struct soc_camera_host	soc_host;
+    struct device		*dev;
+    /* RK2827x is only supposed to handle one camera on its Quick Capture
+     * interface. If anyone ever builds hardware to enable more than
+     * one camera, they will have to modify this driver too */
+    struct soc_camera_device *icd;
+
 	struct clk *aclk_ddr_lcdc;
 	struct clk *aclk_disp_matrix;
 
@@ -276,45 +247,45 @@ struct rk_camera_dev
 	struct clk *vip_matrix;
 
 	struct clk *pd_display;
-	//************must modify end************/
-	void __iomem *base;
-	int frame_inval;           /* ddl@rock-chips.com : The first frames is invalidate  */
-	unsigned int irq;
+
+    void __iomem *base;
+	void __iomem *grf_base;
+    int frame_inval;           /* ddl@rock-chips.com : The first frames is invalidate  */
+    unsigned int irq;
 	unsigned int fps;
+    unsigned long frame_interval;
 	unsigned int pixfmt;
-	//for ipp	
 	unsigned int vipmem_phybase;
 	unsigned int vipmem_size;
 	unsigned int vipmem_bsize;
-
-	int host_width;	//croped size
+	int host_width;
 	int host_height;
-	int host_left;  //sensor output size ?
-	int host_top;
-	int hostid;
+    int icd_width;
+    int icd_height;
 
-	struct rkcamera_platform_data *pdata;
-	struct resource		*res;
-	struct list_head	capture;
-	struct rk_camera_zoominfo zoominfo;
+    struct rk29camera_platform_data *pdata;
+    struct resource		*res;
 
-	spinlock_t		lock;
+    struct list_head	capture;
+    struct rk29_camera_zoominfo zoominfo;
+    
+    spinlock_t		lock;
 
-	struct videobuf_buffer	*active;
-	struct rk_camera_reg reginfo_suspend;
+    struct videobuf_buffer	*active;
+	struct rk29_camera_reg reginfo_suspend;
 	struct workqueue_struct *camera_wq;
-	struct rk_camera_work *camera_work;
+	struct rk29_camera_work *camera_work;
 	unsigned int camera_work_count;
-	struct rk_camera_timer fps_timer;
-	struct rk_camera_work camera_reinit_work;
-	int icd_init;
-	rk_camera_sensor_cb_s icd_cb;
-	struct rk_camera_frmivalinfo icd_frmival[2];
+	struct hrtimer fps_timer;
+	struct work_struct camera_reinit_work;
+    int icd_init;
+    rk29_camera_sensor_cb_s icd_cb;
+    struct rk29_camera_frmivalinfo icd_frmival[2];
 };
 
-static const struct v4l2_queryctrl rk_camera_controls[] =
+static const struct v4l2_queryctrl rk29_camera_controls[] =
 {
-	#ifdef CONFIG_VIDEO_RK_DIGITALZOOM_IPP_ON
+	#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON
     {
         .id		= V4L2_CID_ZOOM_ABSOLUTE,
         .type		= V4L2_CTRL_TYPE_INTEGER,
@@ -328,39 +299,36 @@ static const struct v4l2_queryctrl rk_camera_controls[] =
 };
 
 static DEFINE_MUTEX(camera_lock);
-static const char *rk_cam_driver_description = "RK_Camera";
-static struct rk_camera_dev *rk_camdev_info_ptr;
+static const char *rk29_cam_driver_description = "RK29_Camera";
+static struct rk29_camera_dev *rk29_camdev_info_ptr;
 
-static int rk_camera_s_stream(struct soc_camera_device *icd, int enable);
+static int rk29_camera_s_stream(struct soc_camera_device *icd, int enable);
 
 
 /*
  *  Videobuf operations
  */
-static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
+static int rk29_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
                                unsigned int *size)
 {
     struct soc_camera_device *icd = vq->priv_data;
 	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
-	int bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,
-						icd->current_fmt->host_fmt);
-	int bytes_per_line_host = soc_mbus_bytes_per_line(pcdev->host_width,
+    struct rk29_camera_dev *pcdev = ici->priv;
+    int bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,
 						icd->current_fmt->host_fmt);
 
     dev_dbg(&icd->dev, "count=%d, size=%d\n", *count, *size);
 
-	if (bytes_per_line_host < 0)
-		return bytes_per_line_host;
+	if (bytes_per_line < 0)
+		return bytes_per_line;
 
 	/* planar capture requires Y, U and V buffers to be page aligned */
-	//*size = PAGE_ALIGN(bytes_per_line*icd->user_height);       /* Y pages UV pages, yuv422*/
-	*size = PAGE_ALIGN(bytes_per_line*icd->user_height);	   /* Y pages UV pages, yuv422*/
-	pcdev->vipmem_bsize = PAGE_ALIGN(bytes_per_line_host * pcdev->host_height);
+	*size = PAGE_ALIGN(bytes_per_line*icd->user_height);       /* Y pages UV pages, yuv422*/
+	pcdev->vipmem_bsize = PAGE_ALIGN(bytes_per_line * pcdev->host_height);
 
 
 	if (CAM_WORKQUEUE_IS_EN()) {
-        #ifdef CONFIG_VIDEO_RK_DIGITALZOOM_IPP_OFF
+        #ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_OFF
         if (CAM_IPPWORK_IS_EN()) 
         #endif
         {
@@ -376,20 +344,20 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 		}
 
 		if (pcdev->camera_work == NULL) {
-			pcdev->camera_work = kmalloc(sizeof(struct rk_camera_work)*(*count), GFP_KERNEL);
+			pcdev->camera_work = kmalloc(sizeof(struct rk29_camera_work)*(*count), GFP_KERNEL);
 			if (pcdev->camera_work == NULL) {
-				RKCAMERA_TR("\n %s kmalloc fail\n", __FUNCTION__);
+				RK29CAMERA_TR("\n %s kmalloc fail\n", __FUNCTION__);
 				BUG();
 			}
 			pcdev->camera_work_count = *count;
 		}
 	}
 
-    RKCAMERA_DG("%s..%d.. videobuf size:%d, vipmem_buf size:%d, count:%d \n",__FUNCTION__,__LINE__, *size,pcdev->vipmem_size, *count);
+    RK29CAMERA_DG("%s..%d.. videobuf size:%d, vipmem_buf size:%d, count:%d \n",__FUNCTION__,__LINE__, *size,pcdev->vipmem_size, *count);
 
     return 0;
 }
-static void rk_videobuf_free(struct videobuf_queue *vq, struct rk_camera_buffer *buf)
+static void rk29_videobuf_free(struct videobuf_queue *vq, struct rk29_buffer *buf)
 {
     struct soc_camera_device *icd = vq->priv_data;
 
@@ -412,19 +380,17 @@ static void rk_videobuf_free(struct videobuf_queue *vq, struct rk_camera_buffer
     buf->vb.state = VIDEOBUF_NEEDS_INIT;
 	return;
 }
-static int rk_videobuf_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb, enum v4l2_field field)
+static int rk29_videobuf_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb, enum v4l2_field field)
 {
     struct soc_camera_device *icd = vq->priv_data;
-    struct rk_camera_buffer *buf;
+    struct rk29_buffer *buf;
     int ret;
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-	struct rk_camera_dev *pcdev = ici->priv;
     int bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,
 						icd->current_fmt->host_fmt);
 	if (bytes_per_line < 0)
 		return bytes_per_line;
 
-    buf = container_of(vb, struct rk_camera_buffer, vb);
+    buf = container_of(vb, struct rk29_buffer, vb);
 
     dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,
             vb, vb->baddr, vb->bsize);
@@ -467,22 +433,23 @@ static int rk_videobuf_prepare(struct videobuf_queue *vq, struct videobuf_buffer
     //RK29CAMERA_TR("\n%s..%d.. \n",__FUNCTION__,__LINE__);
     return 0;
 fail:
-    rk_videobuf_free(vq, buf);
+    rk29_videobuf_free(vq, buf);
 out:
     return ret;
 }
 
-static inline void rk_videobuf_capture(struct videobuf_buffer *vb,struct rk_camera_dev *rk_pcdev)
+static inline void rk29_videobuf_capture(struct videobuf_buffer *vb)
 {
 	unsigned int y_addr,uv_addr;
-	struct rk_camera_dev *pcdev = rk_pcdev;
+	struct rk29_camera_dev *pcdev = rk29_camdev_info_ptr;
 
     if (vb) {
 		if (CAM_WORKQUEUE_IS_EN()) {
 			y_addr = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
 			uv_addr = y_addr + pcdev->host_width*pcdev->host_height;
+
 			if (y_addr > (pcdev->vipmem_phybase + pcdev->vipmem_size - pcdev->vipmem_bsize)) {
-				RKCAMERA_TR("vipmem for IPP is overflow! %dx%d -> %dx%d vb_index:%d\n",pcdev->host_width,pcdev->host_height,
+				RK29CAMERA_TR("vipmem for IPP is overflow! %dx%d -> %dx%d vb_index:%d\n",pcdev->host_width,pcdev->host_height,
 					          pcdev->icd->user_width,pcdev->icd->user_height, vb->i);
 				BUG();
 			}
@@ -490,21 +457,20 @@ static inline void rk_videobuf_capture(struct videobuf_buffer *vb,struct rk_came
 			y_addr = vb->boff;
 			uv_addr = y_addr + vb->width * vb->height;
 		}
-        write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y, y_addr);
-        write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV, uv_addr);
-	//printk("y_addr = 0x%x, uv_addr = 0x%x \n",read_cif_reg(pcdev->base, CIF_CIF_FRM0_ADDR_Y),read_cif_reg(pcdev->base, CIF_CIF_FRM0_ADDR_UV));		
-        write_cif_reg(pcdev->base,CIF_CIF_FRM1_ADDR_Y, y_addr);
-        write_cif_reg(pcdev->base,CIF_CIF_FRM1_ADDR_UV, uv_addr);
-        write_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS,  0x00000002);//frame1 has been ready to receive data,frame 2 is not used
+        write_vip_reg(RK29_VIP_CAPTURE_F1SA_Y, y_addr);
+        write_vip_reg(RK29_VIP_CAPTURE_F1SA_UV, uv_addr);
+        write_vip_reg(RK29_VIP_CAPTURE_F2SA_Y, y_addr);
+        write_vip_reg(RK29_VIP_CAPTURE_F2SA_UV, uv_addr);
+        write_vip_reg(RK29_VIP_FB_SR,  0x00000002);//frame1 has been ready to receive data,frame 2 is not used
     }
 }
 /* Locking: Caller holds q->irqlock */
-static void rk_videobuf_queue(struct videobuf_queue *vq,
+static void rk29_videobuf_queue(struct videobuf_queue *vq,
                                 struct videobuf_buffer *vb)
 {
     struct soc_camera_device *icd = vq->priv_data;
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
 
     dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,
             vb, vb->baddr, vb->bsize);
@@ -521,43 +487,42 @@ static void rk_videobuf_queue(struct videobuf_queue *vq,
 	}
     if (!pcdev->active) {
         pcdev->active = vb;
-        rk_videobuf_capture(vb,pcdev);
+        rk29_videobuf_capture(vb);
     }
 }
-static int rk_pixfmt2ippfmt(unsigned int pixfmt, int *ippfmt)
+static int rk29_pixfmt2ippfmt(unsigned int pixfmt, int *ippfmt)
 {
 	switch (pixfmt)
 	{
 		case V4L2_PIX_FMT_NV16:
-		case V4L2_PIX_FMT_NV61:
+        case V4L2_PIX_FMT_YUV422P:
 		{
 			*ippfmt = IPP_Y_CBCR_H2V1;
 			break;
 		}
 		case V4L2_PIX_FMT_NV12:
-		case V4L2_PIX_FMT_NV21:
+        case V4L2_PIX_FMT_YUV420:
 		{
 			*ippfmt = IPP_Y_CBCR_H2V2;
 			break;
 		}
 		default:
-			goto rk_pixfmt2ippfmt_err;
+			goto rk29_pixfmt2ippfmt_err;
 	}
 
 	return 0;
-rk_pixfmt2ippfmt_err:
+rk29_pixfmt2ippfmt_err:
 	return -1;
 }
-static void rk_camera_capture_process(struct work_struct *work)
+static void rk29_camera_capture_process(struct work_struct *work)
 {
-	struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);
+	struct rk29_camera_work *camera_work = container_of(work, struct rk29_camera_work, work);
 	struct videobuf_buffer *vb = camera_work->vb;
-	struct rk_camera_dev *pcdev = camera_work->pcdev;
+	struct rk29_camera_dev *pcdev = camera_work->pcdev;
 	struct rk29_ipp_req ipp_req;
 	unsigned long int flags;
     int src_y_offset,src_uv_offset,dst_y_offset,dst_uv_offset,src_y_size,dst_y_size;
     int scale_times,w,h,vipdata_base;
-	int i = 0;
 	
     /*
     *ddl@rock-chips.com: 
@@ -573,26 +538,28 @@ static void rk_camera_capture_process(struct work_struct *work)
     memset(&ipp_req, 0, sizeof(struct rk29_ipp_req));
     
     down(&pcdev->zoominfo.sem);
-
+    
     ipp_req.timeout = 100;
-    ipp_req.flag = IPP_ROT_0; 
+    ipp_req.flag = IPP_ROT_0;    
     ipp_req.src0.w = pcdev->zoominfo.a.c.width/scale_times;
     ipp_req.src0.h = pcdev->zoominfo.a.c.height/scale_times;
-    ipp_req.src_vir_w = pcdev->zoominfo.a.c.width; 
-    rk_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.src0.fmt);
+    ipp_req.src_vir_w = pcdev->host_width;
+    rk29_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.src0.fmt);
     ipp_req.dst0.w = pcdev->icd->user_width/scale_times;
     ipp_req.dst0.h = pcdev->icd->user_height/scale_times;
     ipp_req.dst_vir_w = pcdev->icd->user_width;        
-    rk_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.dst0.fmt);
+    rk29_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.dst0.fmt);
+
     vipdata_base = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
-    src_y_size = pcdev->zoominfo.a.c.width*pcdev->zoominfo.a.c.height;
+    src_y_size = pcdev->host_width*pcdev->host_height;
     dst_y_size = pcdev->icd->user_width*pcdev->icd->user_height;
+    
     for (h=0; h<scale_times; h++) {
         for (w=0; w<scale_times; w++) {
             
-            src_y_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->zoominfo.a.c.width 
+            src_y_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->host_width 
                         + pcdev->zoominfo.a.c.left + w*pcdev->zoominfo.a.c.width/scale_times;
-		    src_uv_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->zoominfo.a.c.width/2
+		    src_uv_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->host_width/2
                         + pcdev->zoominfo.a.c.left + w*pcdev->zoominfo.a.c.width/scale_times;
 
             dst_y_offset = pcdev->icd->user_width*pcdev->icd->user_height*h/scale_times + pcdev->icd->user_width*w/scale_times;
@@ -608,17 +575,17 @@ static void rk_camera_capture_process(struct work_struct *work)
     			vb->state = VIDEOBUF_ERROR;
     			spin_unlock_irqrestore(&pcdev->lock, flags);
 
-			RKCAMERA_TR("Capture image(vb->i:0x%x) which IPP operated is error:\n",vb->i);
-			RKCAMERA_TR("widx:%d hidx:%d ",w,h);
-			RKCAMERA_TR("%dx%d@(%d,%d)->%dx%d\n",pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height,pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,pcdev->icd->user_width,pcdev->icd->user_height);
-			RKCAMERA_TR("ipp_req.src0.YrgbMst:0x%x ipp_req.src0.CbrMst:0x%x \n", ipp_req.src0.YrgbMst,ipp_req.src0.CbrMst);
-			RKCAMERA_TR("ipp_req.src0.w:0x%x ipp_req.src0.h:0x%x \n",ipp_req.src0.w,ipp_req.src0.h);
-			RKCAMERA_TR("ipp_req.src0.fmt:0x%x\n",ipp_req.src0.fmt);
-			RKCAMERA_TR("ipp_req.dst0.YrgbMst:0x%x ipp_req.dst0.CbrMst:0x%x \n",ipp_req.dst0.YrgbMst,ipp_req.dst0.CbrMst);
-			RKCAMERA_TR("ipp_req.dst0.w:0x%x ipp_req.dst0.h:0x%x \n",ipp_req.dst0.w ,ipp_req.dst0.h);
-			RKCAMERA_TR("ipp_req.dst0.fmt:0x%x\n",ipp_req.dst0.fmt);
-			RKCAMERA_TR("ipp_req.src_vir_w:0x%x ipp_req.dst_vir_w :0x%x\n",ipp_req.src_vir_w ,ipp_req.dst_vir_w);
-			RKCAMERA_TR("ipp_req.timeout:0x%x ipp_req.flag :0x%x\n",ipp_req.timeout,ipp_req.flag);
+                RK29CAMERA_TR("Capture image(vb->i:0x%x) which IPP operated is error:\n",vb->i);
+                RK29CAMERA_TR("widx:%d hidx:%d ",w,h);
+                RK29CAMERA_TR("%dx%d@(%d,%d)->%dx%d\n",pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height,pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,pcdev->icd->user_width,pcdev->icd->user_height);
+            	RK29CAMERA_TR("ipp_req.src0.YrgbMst:0x%x ipp_req.src0.CbrMst:0x%x \n", ipp_req.src0.YrgbMst,ipp_req.src0.CbrMst);
+            	RK29CAMERA_TR("ipp_req.src0.w:0x%x ipp_req.src0.h:0x%x \n",ipp_req.src0.w,ipp_req.src0.h);
+            	RK29CAMERA_TR("ipp_req.src0.fmt:0x%x\n",ipp_req.src0.fmt);
+            	RK29CAMERA_TR("ipp_req.dst0.YrgbMst:0x%x ipp_req.dst0.CbrMst:0x%x \n",ipp_req.dst0.YrgbMst,ipp_req.dst0.CbrMst);
+            	RK29CAMERA_TR("ipp_req.dst0.w:0x%x ipp_req.dst0.h:0x%x \n",ipp_req.dst0.w ,ipp_req.dst0.h);
+            	RK29CAMERA_TR("ipp_req.dst0.fmt:0x%x\n",ipp_req.dst0.fmt);
+            	RK29CAMERA_TR("ipp_req.src_vir_w:0x%x ipp_req.dst_vir_w :0x%x\n",ipp_req.src_vir_w ,ipp_req.dst_vir_w);
+            	RK29CAMERA_TR("ipp_req.timeout:0x%x ipp_req.flag :0x%x\n",ipp_req.timeout,ipp_req.flag);
                 
     			goto do_ipp_err;
     		}
@@ -633,27 +600,39 @@ static void rk_camera_capture_process(struct work_struct *work)
     wake_up(&(camera_work->vb->done)); 
 	return;
 }
-static irqreturn_t rk_camera_irq(int irq, void *data)
+static irqreturn_t rk29_camera_irq(int irq, void *data)
 {
-    struct rk_camera_dev *pcdev = data;
+    struct rk29_camera_dev *pcdev = data;
     struct videobuf_buffer *vb;
-	struct rk_camera_work *wk;
-	write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0xFFFFFFFF);  /* clear vip interrupte single  */
+	struct rk29_camera_work *wk;
+    static struct timeval first_tv;
+    struct timeval tv;
+
+    read_vip_reg(RK29_VIP_INT_STS);    /* clear vip interrupte single  */
     /* ddl@rock-chps.com : Current VIP is run in One Frame Mode, Frame 1 is validate */
-    if (read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS) & 0x01) {
+    if (read_vip_reg(RK29_VIP_FB_SR) & 0x01) {
+        if (!pcdev->fps) {
+            do_gettimeofday(&first_tv);            
+        }
 		pcdev->fps++;
 		if (!pcdev->active)
-			goto RK_CAMERA_IRQ_END;
+			goto RK29_CAMERA_IRQ_END;
 
-        if (pcdev->frame_inval>0) {
+        if (pcdev->frame_inval>0) {            
             pcdev->frame_inval--;
-            rk_videobuf_capture(pcdev->active,pcdev);
-            goto RK_CAMERA_IRQ_END;
+            rk29_videobuf_capture(pcdev->active);
+            goto RK29_CAMERA_IRQ_END;
         } else if (pcdev->frame_inval) {
-        	RKCAMERA_TR("frame_inval : %0x",pcdev->frame_inval);
+        	RK29CAMERA_TR("frame_inval : %0x",pcdev->frame_inval);
             pcdev->frame_inval = 0;
         }
 
+        if(pcdev->fps == RK29_CAM_FRAME_MEASURE) {
+            do_gettimeofday(&tv);            
+            pcdev->frame_interval = ((tv.tv_sec*1000000 + tv.tv_usec) - (first_tv.tv_sec*1000000 + first_tv.tv_usec))
+                                    /(RK29_CAM_FRAME_MEASURE-1);
+        }
+
         vb = pcdev->active;
 		/* ddl@rock-chips.com : this vb may be deleted from queue */
 		if ((vb->state == VIDEOBUF_QUEUED) || (vb->state == VIDEOBUF_ACTIVE)) {
@@ -664,45 +643,43 @@ static irqreturn_t rk_camera_irq(int irq, void *data)
         if (!list_empty(&pcdev->capture)) {
             pcdev->active = list_entry(pcdev->capture.next, struct videobuf_buffer, queue);
 			if (pcdev->active) {
-				rk_videobuf_capture(pcdev->active,pcdev);
+				rk29_videobuf_capture(pcdev->active);
 			}
         }
 
         if (pcdev->active == NULL) {
-			RKCAMERA_DG("%s video_buf queue is empty!\n",__FUNCTION__);
-		}
+			RK29CAMERA_DG("%s video_buf queue is empty!\n",__FUNCTION__);
+        }
 
 		if ((vb->state == VIDEOBUF_QUEUED) || (vb->state == VIDEOBUF_ACTIVE)) {
 	        vb->state = VIDEOBUF_DONE;
 	        do_gettimeofday(&vb->ts);
 	        vb->field_count++;
 		}
-		
+
 		if (CAM_WORKQUEUE_IS_EN()) {
 			wk = pcdev->camera_work + vb->i;
-			INIT_WORK(&(wk->work), rk_camera_capture_process);
+			INIT_WORK(&(wk->work), rk29_camera_capture_process);
 			wk->vb = vb;
 			wk->pcdev = pcdev;
 			queue_work(pcdev->camera_wq, &(wk->work));
-			
-		} else {
+		} else {		    
 			wake_up(&vb->done);
 		}
-		
     }
 
-RK_CAMERA_IRQ_END:
+RK29_CAMERA_IRQ_END:
     return IRQ_HANDLED;
 }
 
 
-static void rk_videobuf_release(struct videobuf_queue *vq,
+static void rk29_videobuf_release(struct videobuf_queue *vq,
                                   struct videobuf_buffer *vb)
 {
-    struct rk_camera_buffer *buf = container_of(vb, struct rk_camera_buffer, vb);
+    struct rk29_buffer *buf = container_of(vb, struct rk29_buffer, vb);
     struct soc_camera_device *icd = vq->priv_data;
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
 #ifdef DEBUG
     dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,
             vb, vb->baddr, vb->bsize);
@@ -724,59 +701,59 @@ static void rk_videobuf_release(struct videobuf_queue *vq,
     }
 #endif	
 	if (vb == pcdev->active) {
-		RKCAMERA_DG("%s Wait for this video buf(0x%x) write finished!\n ",__FUNCTION__,(unsigned int)vb);
+		RK29CAMERA_DG("%s Wait for this video buf(0x%x) write finished!\n ",__FUNCTION__,(unsigned int)vb);
 		interruptible_sleep_on_timeout(&vb->done, 100);
-		RKCAMERA_DG("%s This video buf(0x%x) write finished, release now!!\n",__FUNCTION__,(unsigned int)vb);
+		RK29CAMERA_DG("%s This video buf(0x%x) write finished, release now!!\n",__FUNCTION__,(unsigned int)vb);
 	}
-    rk_videobuf_free(vq, buf);
+    rk29_videobuf_free(vq, buf);
 }
 
-static struct videobuf_queue_ops rk_videobuf_ops =
+static struct videobuf_queue_ops rk29_videobuf_ops =
 {
-    .buf_setup      = rk_videobuf_setup,
-    .buf_prepare    = rk_videobuf_prepare,
-    .buf_queue      = rk_videobuf_queue,
-    .buf_release    = rk_videobuf_release,
+    .buf_setup      = rk29_videobuf_setup,
+    .buf_prepare    = rk29_videobuf_prepare,
+    .buf_queue      = rk29_videobuf_queue,
+    .buf_release    = rk29_videobuf_release,
 };
 
-static void rk_camera_init_videobuf(struct videobuf_queue *q,
+static void rk29_camera_init_videobuf(struct videobuf_queue *q,
                                       struct soc_camera_device *icd)
 {
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
 
     /* We must pass NULL as dev pointer, then all pci_* dma operations
      * transform to normal dma_* ones. */
     videobuf_queue_dma_contig_init(q,
-                                   &rk_videobuf_ops,
+                                   &rk29_videobuf_ops,
                                    ici->v4l2_dev.dev, &pcdev->lock,
                                    V4L2_BUF_TYPE_VIDEO_CAPTURE,
                                    V4L2_FIELD_NONE,
-                                   sizeof(struct rk_camera_buffer),
+                                   sizeof(struct rk29_buffer),
                                    icd,&icd->video_lock);
 }
-static int rk_camera_activate(struct rk_camera_dev *pcdev, struct soc_camera_device *icd)
+static int rk29_camera_activate(struct rk29_camera_dev *pcdev, struct soc_camera_device *icd)
 {
     unsigned long sensor_bus_flags = SOCAM_MCLK_24MHZ;
     struct clk *parent;
 
-    RKCAMERA_TR("%s..%d.. \n",__FUNCTION__,__LINE__);
-	#if 0
+    RK29CAMERA_DG("%s..%d.. \n",__FUNCTION__,__LINE__);
     if (!pcdev->aclk_ddr_lcdc || !pcdev->aclk_disp_matrix ||  !pcdev->hclk_cpu_display ||
 		!pcdev->vip_slave || !pcdev->vip_out || !pcdev->vip_input || !pcdev->vip_bus || !pcdev->pd_display ||
 		IS_ERR(pcdev->aclk_ddr_lcdc) || IS_ERR(pcdev->aclk_disp_matrix) ||  IS_ERR(pcdev->hclk_cpu_display) || IS_ERR(pcdev->pd_display) ||
 		IS_ERR(pcdev->vip_slave) || IS_ERR(pcdev->vip_out) || IS_ERR(pcdev->vip_input) || IS_ERR(pcdev->vip_bus))  {
 
-        RKCAMERA_TR(KERN_ERR "failed to get vip_clk(axi) source\n");
-        goto RK_CAMERA_ACTIVE_ERR;
+        RK29CAMERA_TR(KERN_ERR "failed to get vip_clk(axi) source\n");
+        goto RK29_CAMERA_ACTIVE_ERR;
     }
-	RKCAMERA_TR("%s..%d.. \n",__FUNCTION__,__LINE__);
+
 	if (!pcdev->hclk_disp_matrix || !pcdev->vip_matrix ||
 		IS_ERR(pcdev->hclk_disp_matrix) || IS_ERR(pcdev->vip_matrix))  {
 
-        RKCAMERA_TR(KERN_ERR "failed to get vip_clk(ahb) source\n");
-        goto RK_CAMERA_ACTIVE_ERR;
+        RK29CAMERA_TR(KERN_ERR "failed to get vip_clk(ahb) source\n");
+        goto RK29_CAMERA_ACTIVE_ERR;
     }
+
 	clk_enable(pcdev->pd_display);
 
 	clk_enable(pcdev->aclk_ddr_lcdc);
@@ -784,7 +761,11 @@ static int rk_camera_activate(struct rk_camera_dev *pcdev, struct soc_camera_dev
 
 	clk_enable(pcdev->hclk_cpu_display);
 	clk_enable(pcdev->vip_slave);
-	RK29CAMERA_TR("%s..%d.. \n",__FUNCTION__,__LINE__);
+
+#if (CONFIG_RK29_CAM_WORK_BUS==RK29_CAM_AHB)
+	clk_enable(pcdev->hclk_disp_matrix);
+	clk_enable(pcdev->vip_matrix);
+#endif
 
 	clk_enable(pcdev->vip_input);
 	clk_enable(pcdev->vip_bus);
@@ -795,47 +776,61 @@ static int rk_camera_activate(struct rk_camera_dev *pcdev, struct soc_camera_dev
     if (sensor_bus_flags & SOCAM_MCLK_48MHZ) {
         parent = clk_get(NULL, "clk48m");
         if (!parent || IS_ERR(parent))
-             goto RK_CAMERA_ACTIVE_ERR;
+             goto RK29_CAMERA_ACTIVE_ERR;
     } else if (sensor_bus_flags & SOCAM_MCLK_27MHZ) {
         parent = clk_get(NULL, "extclk");
         if (!parent || IS_ERR(parent))
-             goto RK_CAMERA_ACTIVE_ERR;
+             goto RK29_CAMERA_ACTIVE_ERR;
     } else {
         parent = clk_get(NULL, "xin24m");
         if (!parent || IS_ERR(parent))
-             goto RK_CAMERA_ACTIVE_ERR;
+             goto RK29_CAMERA_ACTIVE_ERR;
     }
+
     clk_set_parent(pcdev->vip_out, parent);
 
     clk_enable(pcdev->vip_out);
-   // rk30_mux_api_set(GPIO1B4_VIPCLKOUT_NAME, GPIO1L_VIP_CLKOUT);
+    rk29_mux_api_set(GPIO1B4_VIPCLKOUT_NAME, GPIO1L_VIP_CLKOUT);
     ndelay(10);
 
-	ndelay(10);
-//    write_vip_reg(pcdev->base,RK29_VIP_RESET, 0x76543210);  /* ddl@rock-chips.com : vip software reset */
-//    udelay(10);
+#if (CONFIG_RK29_CAM_WORK_BUS==RK29_CAM_AHB)
+	write_grf_reg(GRF_SOC_CON0_Reg, read_grf_reg(GRF_SOC_CON0_Reg)|VIP_AHBMASTER);  //VIP Config to AHB
+	write_grf_reg(GRF_OS_REG0, read_grf_reg(GRF_OS_REG0)&(~VIP_ACLK_DIV_HCLK_2));   //aclk:hclk = 1:1
+#else
+	write_grf_reg(GRF_SOC_CON0_Reg, read_grf_reg(GRF_SOC_CON0_Reg)&(~VIP_AHBMASTER));  //VIP Config to AXI
+    write_grf_reg(GRF_OS_REG0, read_grf_reg(GRF_OS_REG0)|VIP_ACLK_DIV_HCLK_2);   //aclk:hclk = 2:1
 #endif
-    write_cif_reg(pcdev->base,CIF_CIF_CTRL,AXI_BURST_16|MODE_ONEFRAME|DISABLE_CAPTURE);   /* ddl@rock-chips.com : vip ahb burst 16 */
-    write_cif_reg(pcdev->base,CIF_CIF_INTEN, 0x01);    //capture complete interrupt enable
-   RKCAMERA_TR("%s..%d.. CIF_CIF_CTRL = 0x%x\n",__FUNCTION__,__LINE__,read_cif_reg(pcdev->base, CIF_CIF_CTRL));
+	ndelay(10);
+
+    write_vip_reg(RK29_VIP_RESET, 0x76543210);  /* ddl@rock-chips.com : vip software reset */
+    udelay(10);
+
+    write_vip_reg(RK29_VIP_AHBR_CTRL, 0x07);   /* ddl@rock-chips.com : vip ahb burst 16 */
+    write_vip_reg(RK29_VIP_INT_MASK, 0x01);    //capture complete interrupt enable
+    write_vip_reg(RK29_VIP_CRM,  0x00000000);  //Y/CB/CR color modification
+
     return 0;
-RK_CAMERA_ACTIVE_ERR:
+RK29_CAMERA_ACTIVE_ERR:
     return -ENODEV;
 }
 
-static void rk_camera_deactivate(struct rk_camera_dev *pcdev)
+static void rk29_camera_deactivate(struct rk29_camera_dev *pcdev)
 {
     //pcdev->active = NULL;
-#if 0
-    write_cif_reg(pcdev->base,CIF_CIF_CTRL, 0);
-    read_cif_reg(pcdev->base,CIF_CIF_INTSTAT);             //clear vip interrupte single
 
-//    rk29_mux_api_set(GPIO1B4_VIPCLKOUT_NAME, GPIO1L_GPIO1B4);
+    write_vip_reg(RK29_VIP_CTRL, 0);
+    read_vip_reg(RK29_VIP_INT_STS);             //clear vip interrupte single
+
+    rk29_mux_api_set(GPIO1B4_VIPCLKOUT_NAME, GPIO1L_GPIO1B4);
     clk_disable(pcdev->vip_out);
 
 	clk_disable(pcdev->vip_input);
 	clk_disable(pcdev->vip_bus);
 
+#if (CONFIG_RK29_CAM_WORK_BUS==RK29_CAM_AHB)
+	clk_disable(pcdev->hclk_disp_matrix);
+	clk_disable(pcdev->vip_matrix);
+#endif
 
 	clk_disable(pcdev->hclk_cpu_display);
 	clk_disable(pcdev->vip_slave);
@@ -844,20 +839,19 @@ static void rk_camera_deactivate(struct rk_camera_dev *pcdev)
 	clk_disable(pcdev->aclk_disp_matrix);
 
 	clk_disable(pcdev->pd_display);
-	#endif
     return;
 }
 
 /* The following two functions absolutely depend on the fact, that
  * there can be only one camera on RK28 quick capture interface */
-static int rk_camera_add_device(struct soc_camera_device *icd)
+static int rk29_camera_add_device(struct soc_camera_device *icd)
 {
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
     struct device *control = to_soc_camera_control(icd);
     struct v4l2_subdev *sd;
     int ret,i,icd_catch;
-    struct rk_camera_frmivalenum *fival_list,*fival_nxt;
+    struct rk29_camera_frmivalenum *fival_list,*fival_nxt;
     
     mutex_lock(&camera_lock);
 
@@ -866,10 +860,10 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
         goto ebusy;
     }
 
-    dev_info(&icd->dev, "RK Camera driver attached to camera%d(%s)\n",
+    dev_info(&icd->dev, "RK29 Camera driver attached to camera%d(%s)\n",
              icd->devnum,dev_name(icd->pdev));
 
-	pcdev->frame_inval = RK_CAM_FRAME_INVAL_INIT;
+	pcdev->frame_inval = RK29_CAM_FRAME_INVAL_INIT;
     pcdev->active = NULL;
     pcdev->icd = NULL;
 	pcdev->reginfo_suspend.Inval = Reg_Invalidate;
@@ -880,20 +874,22 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
 	*/
     INIT_LIST_HEAD(&pcdev->capture);
 
-    ret = rk_camera_activate(pcdev,icd);
+    ret = rk29_camera_activate(pcdev,icd);
     if (ret)
         goto ebusy;
+
     /* ddl@rock-chips.com : v4l2_subdev is not created when ici->ops->add called in soc_camera_probe  */
     if (control) {
         sd = dev_get_drvdata(control);
-		v4l2_subdev_call(sd, core, ioctl, RK_CAM_SUBDEV_IOREQUEST,(void*)pcdev->pdata);
+		v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_IOREQUEST,(void*)pcdev->pdata);
         #if 0
         ret = v4l2_subdev_call(sd,core, init, 0);
         if (ret)
             goto ebusy;
         #endif
-        v4l2_subdev_call(sd, core, ioctl, RK_CAM_SUBDEV_CB_REGISTER,(void*)(&pcdev->icd_cb));
+        v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_CB_REGISTER,(void*)(&pcdev->icd_cb));
     }
+    
     pcdev->icd = icd;
     pcdev->icd_init = 0;
 
@@ -906,6 +902,7 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
             icd_catch = 1;
         }
     }
+
     if (icd_catch == 0) {
         fival_list = pcdev->icd_frmival[0].fival_list;
         fival_nxt = fival_list;
@@ -915,34 +912,33 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
             fival_list = fival_nxt;
         }
         pcdev->icd_frmival[0].icd = icd;
-        pcdev->icd_frmival[0].fival_list = kzalloc(sizeof(struct rk_camera_frmivalenum),GFP_KERNEL);
+        pcdev->icd_frmival[0].fival_list = kzalloc(sizeof(struct rk29_camera_frmivalenum),GFP_KERNEL);
     }
-	RKCAMERA_TR("%s..%d.. \n",__FUNCTION__,__LINE__);
 ebusy:
     mutex_unlock(&camera_lock);
 
     return ret;
 }
-static void rk_camera_remove_device(struct soc_camera_device *icd)
+static void rk29_camera_remove_device(struct soc_camera_device *icd)
 {
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
 	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
 
 	mutex_lock(&camera_lock);
     BUG_ON(icd != pcdev->icd);
 
-    dev_info(&icd->dev, "RK Camera driver detached from camera%d(%s)\n",
+    dev_info(&icd->dev, "RK29 Camera driver detached from camera%d(%s)\n",
              icd->devnum,dev_name(icd->pdev));
 
 	/* ddl@rock-chips.com: Application will call VIDIOC_STREAMOFF before close device, but
 	   stream may be turn on again before close device, if suspend and resume happened. */
-	if (read_cif_reg(pcdev->base,CIF_CIF_CTRL) & ENABLE_CAPTURE) {
-		rk_camera_s_stream(icd,0);
+	if (read_vip_reg(RK29_VIP_CTRL) & ENABLE_CAPTURE) {
+		rk29_camera_s_stream(icd,0);
 	}
 
-    v4l2_subdev_call(sd, core, ioctl, RK_CAM_SUBDEV_DEACTIVATE,NULL);
-	rk_camera_deactivate(pcdev);
+    v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_DEACTIVATE,NULL);
+	rk29_camera_deactivate(pcdev);
 
 	if (pcdev->camera_work) {
 		kfree(pcdev->camera_work);
@@ -960,25 +956,24 @@ static void rk_camera_remove_device(struct soc_camera_device *icd)
     INIT_LIST_HEAD(&pcdev->capture);
 
 	mutex_unlock(&camera_lock);
-	RKCAMERA_DG("%s exit\n",__FUNCTION__);
+	RK29CAMERA_DG("%s exit\n",__FUNCTION__);
 
 	return;
 }
-static int rk_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
+static int rk29_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
 {
     unsigned long bus_flags, camera_flags, common_flags;
-    unsigned int cif_ctrl_val = 0;
+    unsigned int vip_ctrl_val = 0;
 	const struct soc_mbus_pixelfmt *fmt;
 	int ret = 0;
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-	struct rk_camera_dev *pcdev = ici->priv;
-    RKCAMERA_DG("%s..%d..\n",__FUNCTION__,__LINE__);
+
+    RK29CAMERA_DG("%s..%d..\n",__FUNCTION__,__LINE__);
 
 	fmt = soc_mbus_get_fmtdesc(icd->current_fmt->code);
 	if (!fmt)
 		return -EINVAL;
 
-    bus_flags = RK_CAM_BUS_PARAM;
+    bus_flags = RK29_CAM_BUS_PARAM;
 	/* If requested data width is supported by the platform, use it */
 	switch (fmt->bits_per_sample) {
     	case 10:
@@ -1005,67 +1000,49 @@ static int rk_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
     common_flags = soc_camera_bus_param_compatible(camera_flags, bus_flags);
     if (!common_flags) {
         ret = -EINVAL;
-        goto RK_CAMERA_SET_BUS_PARAM_END;
+        goto RK29_CAMERA_SET_BUS_PARAM_END;
     }
 
     ret = icd->ops->set_bus_param(icd, common_flags);
     if (ret < 0)
-        goto RK_CAMERA_SET_BUS_PARAM_END;
+        goto RK29_CAMERA_SET_BUS_PARAM_END;
 
-    cif_ctrl_val = read_cif_reg(pcdev->base,CIF_CIF_FOR);
-	RKCAMERA_DG("%s..%d..cif_ctrl_val = 0x%x\n",__FUNCTION__,__LINE__,cif_ctrl_val);
+    vip_ctrl_val = read_vip_reg(RK29_VIP_CTRL);
     if (common_flags & SOCAM_PCLK_SAMPLE_FALLING) {
-   	if(IS_CIF0())
-   		{
-		RKCAMERA_DG("%s..%d.. before set CRU_PCLK_REG30 = 0X%x\n",__FUNCTION__,__LINE__,read_cru_reg(CRU_PCLK_REG30));
-		write_cru_reg(CRU_PCLK_REG30, read_cru_reg(CRU_PCLK_REG30) | ENANABLE_INVERT_PCLK_CIF0);
-		RKCAMERA_DG("%s..%d..  after set CRU_PCLK_REG30 = 0X%x\n",__FUNCTION__,__LINE__,read_cru_reg(CRU_PCLK_REG30));
-   		}
-	else
-		{
-		write_cru_reg(CRU_PCLK_REG30, read_cru_reg(CRU_PCLK_REG30) | ENANABLE_INVERT_PCLK_CIF1);
-		}
+        vip_ctrl_val |= NEGATIVE_EDGE;
     } else {
-		if(IS_CIF0())
-			{
-			RKCAMERA_DG("%s..%d.. before set CRU_PCLK_REG30 = 0X%x\n",__FUNCTION__,__LINE__,read_cru_reg(CRU_PCLK_REG30));
-			write_cru_reg(CRU_PCLK_REG30, (read_cru_reg(CRU_PCLK_REG30) ) & 0xFFFEFFF | DISABLE_INVERT_PCLK_CIF0);
-			RKCAMERA_DG("%s..%d..  after set CRU_PCLK_REG30 = 0X%x\n",__FUNCTION__,__LINE__,read_cru_reg(CRU_PCLK_REG30));
-			}
-		else
-			{
-			write_cru_reg(CRU_PCLK_REG30, (read_cru_reg(CRU_PCLK_REG30) & 0xFFFEFFF) | DISABLE_INVERT_PCLK_CIF1);
-			}
+		vip_ctrl_val &= ~NEGATIVE_EDGE;
     }
     if (common_flags & SOCAM_HSYNC_ACTIVE_LOW) {
-        cif_ctrl_val |= HSY_LOW_ACTIVE;
+        vip_ctrl_val |= HSY_LOW_ACTIVE;
     } else {
-		cif_ctrl_val &= ~HSY_LOW_ACTIVE;
+		vip_ctrl_val &= ~HSY_LOW_ACTIVE;
     }
     if (common_flags & SOCAM_VSYNC_ACTIVE_HIGH) {
-        cif_ctrl_val |= VSY_HIGH_ACTIVE;
+        vip_ctrl_val |= VSY_HIGH_ACTIVE;
     } else {
-		cif_ctrl_val &= ~VSY_HIGH_ACTIVE;
+		vip_ctrl_val &= ~VSY_HIGH_ACTIVE;
     }
 
     /* ddl@rock-chips.com : Don't enable capture here, enable in stream_on */
     //vip_ctrl_val |= ENABLE_CAPTURE;
-	RKCAMERA_DG("%s..%d.. 0X%x\n",__FUNCTION__,__LINE__,pcdev->base);
-    write_cif_reg(pcdev->base,CIF_CIF_FOR, cif_ctrl_val);
-    RKCAMERA_DG("%s..ctrl:0x%x CIF_CIF_FOR=%x  \n",__FUNCTION__,cif_ctrl_val,read_cif_reg(pcdev->base,CIF_CIF_FOR));
 
-RK_CAMERA_SET_BUS_PARAM_END:
+    write_vip_reg(RK29_VIP_CTRL, vip_ctrl_val);
+    RK29CAMERA_DG("%s..ctrl:0x%x CtrReg=%x AXI_AHB:0x%x aclk_hclk:0x%x \n",__FUNCTION__,vip_ctrl_val,read_vip_reg(RK29_VIP_CTRL),
+		read_grf_reg(GRF_SOC_CON0_Reg)&VIP_AHBMASTER, read_grf_reg(GRF_OS_REG0)&VIP_ACLK_DIV_HCLK_2);
+
+RK29_CAMERA_SET_BUS_PARAM_END:
 	if (ret)
-    	RKCAMERA_TR("\n%s..%d.. ret = %d \n",__FUNCTION__,__LINE__, ret);
+    	RK29CAMERA_TR("\n%s..%d.. ret = %d \n",__FUNCTION__,__LINE__, ret);
     return ret;
 }
 
-static int rk_camera_try_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
+static int rk29_camera_try_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
 {
     unsigned long bus_flags, camera_flags;
     int ret;
 
-    bus_flags = RK_CAM_BUS_PARAM;
+    bus_flags = RK29_CAM_BUS_PARAM;
 	if (icd->ops->query_bus_param) {
         camera_flags = icd->ops->query_bus_param(icd);
 	} else {
@@ -1080,7 +1057,7 @@ static int rk_camera_try_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
     return ret;
 }
 
-static const struct soc_mbus_pixelfmt rk_camera_formats[] = {
+static const struct soc_mbus_pixelfmt rk29_camera_formats[] = {
    {
 		.fourcc			= V4L2_PIX_FMT_NV12,
 		.name			= "YUV420 NV12",
@@ -1094,104 +1071,84 @@ static const struct soc_mbus_pixelfmt rk_camera_formats[] = {
 		.packing		= SOC_MBUS_PACKING_2X8_PADHI,
 		.order			= SOC_MBUS_ORDER_LE,
 	},{
-		.fourcc 		= V4L2_PIX_FMT_NV21,
-		.name			= "YUV420 NV21",
+		.fourcc			= V4L2_PIX_FMT_YUV420,
+		.name			= "NV12(v0.0.1)",
 		.bits_per_sample	= 8,
 		.packing		= SOC_MBUS_PACKING_1_5X8,
 		.order			= SOC_MBUS_ORDER_LE,
 	},{
-		.fourcc 		= V4L2_PIX_FMT_NV61,
-		.name			= "YUV422 NV61",
+		.fourcc			= V4L2_PIX_FMT_YUV422P,
+		.name			= "NV16(v0.0.1)",
 		.bits_per_sample	= 8,
 		.packing		= SOC_MBUS_PACKING_2X8_PADHI,
 		.order			= SOC_MBUS_ORDER_LE,
 	}
 };
 
-static void rk_camera_setup_format(struct soc_camera_device *icd, __u32 host_pixfmt, enum v4l2_mbus_pixelcode icd_code, struct v4l2_rect *rect)
+static void rk29_camera_setup_format(struct soc_camera_device *icd, __u32 host_pixfmt, enum v4l2_mbus_pixelcode icd_code, struct v4l2_rect *rect)
 {
 	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
-    unsigned int cif_fs = 0,cif_crop = 0;
-    unsigned int cif_fmt_val = INPUT_MODE_YUV|YUV_INPUT_422|INPUT_420_ORDER_EVEN|OUTPUT_420_ORDER_EVEN;
+    struct rk29_camera_dev *pcdev = ici->priv;
+    unsigned int vip_fs = 0,vip_crop = 0;
+    unsigned int vip_ctrl_val = VIP_SENSOR|ONEFRAME|DISABLE_CAPTURE;
+
     switch (host_pixfmt)
     {
         case V4L2_PIX_FMT_NV16:
-            cif_fmt_val |= YUV_OUTPUT_422;
-		cif_fmt_val |= UV_STORAGE_ORDER_UVUV;
-		pcdev->frame_inval = RK_CAM_FRAME_INVAL_DC;
-		pcdev->pixfmt = host_pixfmt;
+        case V4L2_PIX_FMT_YUV422P:  /* ddl@rock-chips.com: V4L2_PIX_FMT_YUV422P is V4L2_PIX_FMT_NV16 actually in 0.0.1 driver */
+            vip_ctrl_val |= VIPREGYUV422;
+			pcdev->frame_inval = RK29_CAM_FRAME_INVAL_DC;
+			pcdev->pixfmt = host_pixfmt;
             break;
-	case V4L2_PIX_FMT_NV61:
-		cif_fmt_val |= YUV_OUTPUT_422;
-		cif_fmt_val |= UV_STORAGE_ORDER_VUVU;
-		pcdev->frame_inval = RK_CAM_FRAME_INVAL_DC;
-		pcdev->pixfmt = host_pixfmt;
-		break;
         case V4L2_PIX_FMT_NV12:
-            cif_fmt_val |= YUV_OUTPUT_420;
-		cif_fmt_val |= UV_STORAGE_ORDER_UVUV;
-			if (pcdev->frame_inval != RK_CAM_FRAME_INVAL_INIT)
-				pcdev->frame_inval = RK_CAM_FRAME_INVAL_INIT;
+        case V4L2_PIX_FMT_YUV420:   /* ddl@rock-chips.com: V4L2_PIX_FMT_YUV420 is V4L2_PIX_FMT_NV12 actually in 0.0.1 driver */
+            vip_ctrl_val |= VIPREGYUV420;
+			if (pcdev->frame_inval != RK29_CAM_FRAME_INVAL_INIT)
+				pcdev->frame_inval = RK29_CAM_FRAME_INVAL_INIT;
 			pcdev->pixfmt = host_pixfmt;
             break;
-	case V4L2_PIX_FMT_NV21:
-		cif_fmt_val |= YUV_OUTPUT_420;
-		cif_fmt_val |= UV_STORAGE_ORDER_VUVU;
-		if (pcdev->frame_inval != RK_CAM_FRAME_INVAL_INIT)
-			pcdev->frame_inval = RK_CAM_FRAME_INVAL_INIT;
-		pcdev->pixfmt = host_pixfmt;
-		break;
         default:                                                                                /* ddl@rock-chips.com : vip output format is hold when pixfmt is invalidate */
-			cif_fmt_val |= YUV_OUTPUT_422;
+            vip_ctrl_val |= (read_vip_reg(RK29_VIP_CTRL) & VIPREGYUV422);
             break;
     }
+
     switch (icd_code)
     {
         case V4L2_MBUS_FMT_UYVY8_2X8:
-            cif_fmt_val |= YUV_INPUT_ORDER_UYVY;
+            vip_ctrl_val |= SENSOR_UYVY;
             break;
         case V4L2_MBUS_FMT_YUYV8_2X8:
-            cif_fmt_val |= YUV_INPUT_ORDER_YUYV;
+            vip_ctrl_val |= SENSOR_YUYV;
             break;
-	case V4L2_MBUS_FMT_YVYU8_2X8:
-		cif_fmt_val |= YUV_INPUT_ORDER_YVYU;
-		break;
-	case V4L2_MBUS_FMT_VYUY8_2X8:
-		cif_fmt_val |= YUV_INPUT_ORDER_VYUY;
-		break;
         default :
-			cif_fmt_val |= YUV_INPUT_ORDER_YUYV;
+            vip_ctrl_val |= (read_vip_reg(RK29_VIP_CTRL) & SENSOR_YUYV);
             break;
     }
-    write_cif_reg(pcdev->base,CIF_CIF_FOR, read_cif_reg(pcdev->base,CIF_CIF_FOR) |cif_fmt_val);         /* ddl@rock-chips.com: VIP capture mode and capture format must be set before FS register set */
 
-   // read_cif_reg(pcdev->base,CIF_CIF_INTSTAT);                     /* clear vip interrupte single  */
-   write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0xFFFFFFFF); 
-	if((read_cif_reg(pcdev->base,CIF_CIF_CTRL) & MODE_PINGPONG)
-		||(read_cif_reg(pcdev->base,CIF_CIF_CTRL) & MODE_LINELOOP)) // it is one frame mode
-	{
-		BUG();
-	}
-       else{ // this is one frame mode
-		cif_crop = (rect->left+ (rect->top<<16));
-		cif_fs	= ((rect->width ) + (rect->height<<16));
-	 }
-	RKCAMERA_TR("%s..%d.. \n",__FUNCTION__,__LINE__);
-
-	write_cif_reg(pcdev->base,CIF_CIF_CROP, cif_crop);
-	write_cif_reg(pcdev->base,CIF_CIF_SET_SIZE, cif_fs);
-	write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH, rect->width);
-	write_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS,  0x00000003);
-	//MUST bypass scale 
-	write_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL,0x10);
-	//pcdev->host_width = rect->width;
-//	pcdev->host_height = rect->height;
-    RKCAMERA_DG("%s.. crop:0x%x fs:0x%x cif_fmt_val:0x%x CIF_CIF_FOR:0x%x\n",__FUNCTION__,cif_crop,cif_fs,cif_fmt_val,read_cif_reg(pcdev->base,CIF_CIF_FOR));
+    write_vip_reg(RK29_VIP_CTRL, vip_ctrl_val);         /* ddl@rock-chips.com: VIP capture mode and capture format must be set before FS register set */
+
+    read_vip_reg(RK29_VIP_INT_STS);                     /* clear vip interrupte single  */
+
+    if (vip_ctrl_val & ONEFRAME)  {
+        vip_crop = ((rect->left<<16) + rect->top);
+        vip_fs  = (((rect->width + rect->left)<<16) + (rect->height+rect->top));
+    } else if (vip_ctrl_val & PING_PONG) {
+        BUG();
+    }
+
+    write_vip_reg(RK29_VIP_CROP, vip_crop);
+    write_vip_reg(RK29_VIP_FS, vip_fs);
+
+    write_vip_reg(RK29_VIP_FB_SR,  0x00000003);
+
+	pcdev->host_width = rect->width;
+	pcdev->host_height = rect->height;
+
+    RK29CAMERA_DG("%s.. crop:0x%x fs:0x%x ctrl:0x%x CtrlReg:0x%x\n",__FUNCTION__,vip_crop,vip_fs,vip_ctrl_val,read_vip_reg(RK29_VIP_CTRL));
 	return;
 }
 
-static int rk_camera_get_formats(struct soc_camera_device *icd, unsigned int idx,
+static int rk29_camera_get_formats(struct soc_camera_device *icd, unsigned int idx,
 				  struct soc_camera_format_xlate *xlate)
 {
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
@@ -1211,49 +1168,47 @@ static int rk_camera_get_formats(struct soc_camera_device *icd, unsigned int idx
 		return 0;
 	}
 
-    ret = rk_camera_try_bus_param(icd, fmt->bits_per_sample);
+    ret = rk29_camera_try_bus_param(icd, fmt->bits_per_sample);
     if (ret < 0)
         return 0;
 
     switch (code) {
         case V4L2_MBUS_FMT_UYVY8_2X8:
         case V4L2_MBUS_FMT_YUYV8_2X8:
-	 case V4L2_MBUS_FMT_YVYU8_2X8:
-	 case V4L2_MBUS_FMT_VYUY8_2X8:
             formats++;
             if (xlate) {
-                xlate->host_fmt = &rk_camera_formats[0];
+                xlate->host_fmt = &rk29_camera_formats[0];
                 xlate->code	= code;
                 xlate++;
                 dev_dbg(dev, "Providing format %s using code %d\n",
-                	rk_camera_formats[0].name,code);
+                	rk29_camera_formats[0].name,code);
             }
 
             formats++;
             if (xlate) {
-                xlate->host_fmt = &rk_camera_formats[1];
+                xlate->host_fmt = &rk29_camera_formats[1];
                 xlate->code	= code;
                 xlate++;
                 dev_dbg(dev, "Providing format %s using code %d\n",
-                	rk_camera_formats[1].name,code);
+                	rk29_camera_formats[1].name,code);
             }
 
             formats++;
             if (xlate) {
-                xlate->host_fmt = &rk_camera_formats[2];
+                xlate->host_fmt = &rk29_camera_formats[2];
                 xlate->code	= code;
                 xlate++;
                 dev_dbg(dev, "Providing format %s using code %d\n",
-                	rk_camera_formats[2].name,code);
+                	rk29_camera_formats[2].name,code);
             } 
 
             formats++;
             if (xlate) {
-                xlate->host_fmt = &rk_camera_formats[3];
+                xlate->host_fmt = &rk29_camera_formats[3];
                 xlate->code	= code;
                 xlate++;
                 dev_dbg(dev, "Providing format %s using code %d\n",
-                	rk_camera_formats[3].name,code);
+                	rk29_camera_formats[3].name,code);;
             }
 			break;		
         default:
@@ -1263,12 +1218,12 @@ static int rk_camera_get_formats(struct soc_camera_device *icd, unsigned int idx
     return formats;
 }
 
-static void rk_camera_put_formats(struct soc_camera_device *icd)
+static void rk29_camera_put_formats(struct soc_camera_device *icd)
 {
 	return;
 }
 
-static int rk_camera_set_crop(struct soc_camera_device *icd,
+static int rk29_camera_set_crop(struct soc_camera_device *icd,
 			       struct v4l2_crop *a)
 {
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
@@ -1285,8 +1240,8 @@ static int rk_camera_set_crop(struct soc_camera_device *icd,
         mf.width = a->c.left + a->c.width;
         mf.height = a->c.top + a->c.height;
 
-        v4l_bound_align_image(&mf.width, RK_CAM_W_MIN, RK_CAM_W_MAX, 1,
-            &mf.height, RK_CAM_H_MIN, RK_CAM_H_MAX, 0,
+        v4l_bound_align_image(&mf.width, RK29_CAM_W_MIN, RK29_CAM_W_MAX, 1,
+            &mf.height, RK29_CAM_H_MIN, RK29_CAM_H_MAX, 0,
             fourcc == V4L2_PIX_FMT_NV16 ?4 : 0);
 
         ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
@@ -1294,7 +1249,7 @@ static int rk_camera_set_crop(struct soc_camera_device *icd,
             return ret;
     }
 
-    rk_camera_setup_format(icd, fourcc, mf.code, &a->c);
+    rk29_camera_setup_format(icd, fourcc, mf.code, &a->c);
 
     icd->user_width = mf.width;
     icd->user_height = mf.height;
@@ -1302,129 +1257,115 @@ static int rk_camera_set_crop(struct soc_camera_device *icd,
     return 0;
 }
 
-static int rk_camera_set_fmt(struct soc_camera_device *icd,
+static int rk29_camera_set_fmt(struct soc_camera_device *icd,
 			      struct v4l2_format *f)
 {
     struct device *dev = icd->dev.parent;
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     const struct soc_camera_format_xlate *xlate = NULL;
 	struct soc_camera_host *ici =to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
     struct v4l2_pix_format *pix = &f->fmt.pix;
     struct v4l2_mbus_framefmt mf;
     struct v4l2_rect rect;
-    int ret,usr_w,usr_h;
+    int ret,usr_w,usr_h,icd_width,icd_height;
     int stream_on = 0;
 
 	usr_w = pix->width;
 	usr_h = pix->height;
-    RKCAMERA_TR("%s enter width:%d  height:%d\n",__FUNCTION__,usr_w,usr_h);
+    RK29CAMERA_DG("%s enter width:%d  height:%d\n",__FUNCTION__,usr_w,usr_h);
+
     xlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);
     if (!xlate) {
         dev_err(dev, "Format %x not found\n", pix->pixelformat);
         ret = -EINVAL;
-        goto RK_CAMERA_SET_FMT_END;
+        goto RK29_CAMERA_SET_FMT_END;
     }
     
     /* ddl@rock-chips.com: sensor init code transmit in here after open */
     if (pcdev->icd_init == 0) {
-        v4l2_subdev_call(sd,core, init, (void*)pcdev->pdata);        
+        v4l2_subdev_call(sd,core, init, 0);        
         pcdev->icd_init = 1;
     }
-    stream_on = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
+
+    stream_on = read_vip_reg(RK29_VIP_CTRL);
     if (stream_on & ENABLE_CAPTURE)
-        write_cif_reg(pcdev->base,CIF_CIF_CTRL, (stream_on & (~ENABLE_CAPTURE)));
+        write_vip_reg(RK29_VIP_CTRL, (stream_on & (~ENABLE_CAPTURE)));
     
 	mf.width	= pix->width;
 	mf.height	= pix->height;
 	mf.field	= pix->field;
 	mf.colorspace	= pix->colorspace;
 	mf.code		= xlate->code;
+
 	ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
 
 	if (mf.code != xlate->code)
 		return -EINVAL;
-	#ifdef CONFIG_VIDEO_RK_WORK_IPP
+    
+    icd_width = mf.width;
+    icd_height = mf.height;
+	#ifdef CONFIG_VIDEO_RK29_WORK_IPP
 	if ((mf.width != usr_w) || (mf.height != usr_h)) {
-	  int ratio;
         if (unlikely((mf.width <16) || (mf.width > 8190) || (mf.height < 16) || (mf.height > 8190))) {
-    		RKCAMERA_TR("Senor and IPP both invalid source resolution(%dx%d)\n",mf.width,mf.height);
+    		RK29CAMERA_TR("Senor and IPP both invalid source resolution(%dx%d)\n",mf.width,mf.height);
     		ret = -EINVAL;
-    		goto RK_CAMERA_SET_FMT_END;
+    		goto RK29_CAMERA_SET_FMT_END;
     	}    	
     	if (unlikely((usr_w <16)||(usr_h < 16))) {
-    		RKCAMERA_TR("Senor and IPP both invalid destination resolution(%dx%d)\n",usr_w,usr_h);
+    		RK29CAMERA_TR("Senor and IPP both invalid destination resolution(%dx%d)\n",usr_w,usr_h);
     		ret = -EINVAL;
-            goto RK_CAMERA_SET_FMT_END;
+            goto RK29_CAMERA_SET_FMT_END;
     	}
-		//need crop ?
-		if(1/*(mf.width/mf.height) != (usr_w/usr_h)*/){
-			ratio = ((mf.width/usr_w) >= (mf.height/usr_h))?(mf.height/usr_h):(mf.width/usr_w);
-			pcdev->host_width = ratio*usr_w;
-			pcdev->host_height = ratio*usr_h;
-			printk("ratio = %d ,host:%d*%d\n",ratio,pcdev->host_width,pcdev->host_height);
-			}
-		else{ // needn't crop ,just scaled by ipp
-			pcdev->host_width = usr_w;
-			pcdev->host_height = usr_h;
-			}
+		mf.width = usr_w;
+		mf.height = usr_h;
 	}
-	else{
-		pcdev->host_width = usr_w;
-		pcdev->host_height = usr_h;
-		}
-	#else
-	//according to crop and scale capability to change , here just cropt to user needed
-	pcdev->host_width = usr_w;
-	pcdev->host_height = usr_h;
 	#endif
     icd->sense = NULL;
+
     if (!ret) {
-	rect.left = ((mf.width - pcdev->host_width )>>1)&(~0x01);
-	rect.top = ((mf.height - pcdev->host_height )>>1)&(~0x01);
-	pcdev->host_left = rect.left;
-	pcdev->host_top = rect.top;
-      //  rect.left = 0;
-      //  rect.top = 0;
-        rect.width = pcdev->host_width;
-        rect.height = pcdev->host_height;
-	  RKCAMERA_DG("%s..%d.. host:%d*%d , sensor output:%d*%d,user demand:%d*%d\n",__FUNCTION__,__LINE__,
-	  	pcdev->host_width,pcdev->host_height,mf.width,mf.height,usr_w,usr_h);
+        rect.left = 0;
+        rect.top = 0;
+        rect.width = mf.width;
+        rect.height = mf.height;
+
         down(&pcdev->zoominfo.sem);        
         pcdev->zoominfo.a.c.width = rect.width*100/pcdev->zoominfo.zoom_rate;
 		pcdev->zoominfo.a.c.width &= ~0x03;
 		pcdev->zoominfo.a.c.height = rect.height*100/pcdev->zoominfo.zoom_rate;
 		pcdev->zoominfo.a.c.height &= ~0x03;
-		//pcdev->zoominfo.a.c.left = ((rect.width - pcdev->zoominfo.a.c.width)>>1)&(~0x01);
-		//pcdev->zoominfo.a.c.top = ((rect.height - pcdev->zoominfo.a.c.height)>>1)&(~0x01);
-		pcdev->zoominfo.a.c.left = 0;
-		pcdev->zoominfo.a.c.top = 0;
+		pcdev->zoominfo.a.c.left = ((rect.width - pcdev->zoominfo.a.c.width)>>1)&(~0x01);
+		pcdev->zoominfo.a.c.top = ((rect.height - pcdev->zoominfo.a.c.height)>>1)&(~0x01);
         up(&pcdev->zoominfo.sem);
 
         /* ddl@rock-chips.com: IPP work limit check */
         if ((pcdev->zoominfo.a.c.width != usr_w) || (pcdev->zoominfo.a.c.height != usr_h)) {
             if (usr_w > 0x7f0) {
                 if (((usr_w>>1)&0x3f) && (((usr_w>>1)&0x3f) <= 8)) {
-                    RKCAMERA_TR("IPP Destination resolution(%dx%d, ((%d div 1) mod 64)=%d is <= 8)",usr_w,usr_h, usr_w, (int)((usr_w>>1)&0x3f));
+                    RK29CAMERA_TR("IPP Destination resolution(%dx%d, ((%d div 1) mod 64)=%d is <= 8)",usr_w,usr_h, usr_w, (int)((usr_w>>1)&0x3f));
                     ret = -EINVAL;
-                    goto RK_CAMERA_SET_FMT_END;
+                    goto RK29_CAMERA_SET_FMT_END;
                 }
             } else {
                 if ((usr_w&0x3f) && ((usr_w&0x3f) <= 8)) {
-                    RKCAMERA_TR("IPP Destination resolution(%dx%d, %d mod 64=%d is <= 8)",usr_w,usr_h, usr_w, (int)(usr_w&0x3f));
+                    RK29CAMERA_TR("IPP Destination resolution(%dx%d, %d mod 64=%d is <= 8)",usr_w,usr_h, usr_w, (int)(usr_w&0x3f));
                     ret = -EINVAL;
-                    goto RK_CAMERA_SET_FMT_END;
+                    goto RK29_CAMERA_SET_FMT_END;
                 }
             }
         }
-        RKCAMERA_DG("%s..%s icd width:%d  host width:%d (zoom: %dx%d@(%d,%d)->%dx%d)\n",__FUNCTION__,xlate->host_fmt->name,
+        
+        RK29CAMERA_DG("%s..%s icd width:%d  host width:%d (zoom: %dx%d@(%d,%d)->%dx%d)\n",__FUNCTION__,xlate->host_fmt->name,
 			           rect.width, pix->width, pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height, pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,
 			           pix->width, pix->height);
-        rk_camera_setup_format(icd, pix->pixelformat, mf.code, &rect); 
+        rk29_camera_setup_format(icd, pix->pixelformat, mf.code, &rect); 
         
 		if (CAM_IPPWORK_IS_EN()) {
 			BUG_ON(pcdev->vipmem_phybase == 0);
 		}
+        pcdev->icd_width = icd_width;
+        pcdev->icd_height = icd_height;
+
         pix->width = mf.width;
     	pix->height = mf.height;
     	pix->field = mf.field;
@@ -1432,14 +1373,14 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     	icd->current_fmt = xlate;        
     }
 
-RK_CAMERA_SET_FMT_END:
+RK29_CAMERA_SET_FMT_END:
     if (stream_on & ENABLE_CAPTURE)
-        write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL) | ENABLE_CAPTURE));
+        write_vip_reg(RK29_VIP_CTRL, (read_vip_reg(RK29_VIP_CTRL) | ENABLE_CAPTURE));
 	if (ret)
-    	RKCAMERA_TR("\n%s..%d.. ret = %d  \n",__FUNCTION__,__LINE__, ret);
+    	RK29CAMERA_TR("\n%s..%d.. ret = %d  \n",__FUNCTION__,__LINE__, ret);
     return ret;
 }
-static bool rk_camera_fmt_capturechk(struct v4l2_format *f)
+static bool rk29_camera_fmt_capturechk(struct v4l2_format *f)
 {
     bool ret = false;
 
@@ -1456,44 +1397,44 @@ static bool rk_camera_fmt_capturechk(struct v4l2_format *f)
 	}
 
 	if (ret == true)
-		RKCAMERA_DG("%s %dx%d is capture format\n", __FUNCTION__, f->fmt.pix.width, f->fmt.pix.height);
+		RK29CAMERA_DG("%s %dx%d is capture format\n", __FUNCTION__, f->fmt.pix.width, f->fmt.pix.height);
 	return ret;
 }
-static int rk_camera_try_fmt(struct soc_camera_device *icd,
+static int rk29_camera_try_fmt(struct soc_camera_device *icd,
                                    struct v4l2_format *f)
 {
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-	struct rk_camera_dev *pcdev = ici->priv;
+	struct rk29_camera_dev *pcdev = ici->priv;
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     const struct soc_camera_format_xlate *xlate;
     struct v4l2_pix_format *pix = &f->fmt.pix;
     __u32 pixfmt = pix->pixelformat;
     int ret,usr_w,usr_h,i;
-	bool is_capture = rk_camera_fmt_capturechk(f);
+	bool is_capture = rk29_camera_fmt_capturechk(f);
 	bool vipmem_is_overflow = false;
     struct v4l2_mbus_framefmt mf;
 
 	usr_w = pix->width;
 	usr_h = pix->height;
-	RKCAMERA_DG("%s enter width:%d  height:%d\n",__FUNCTION__,usr_w,usr_h);
+	RK29CAMERA_DG("%s enter width:%d  height:%d\n",__FUNCTION__,usr_w,usr_h);
 
     xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
     if (!xlate) {
         dev_err(icd->dev.parent, "Format (%c%c%c%c) not found\n", pixfmt & 0xFF, (pixfmt >> 8) & 0xFF,
 			(pixfmt >> 16) & 0xFF, (pixfmt >> 24) & 0xFF);
         ret = -EINVAL;
-        RKCAMERA_TR("%s(version:%c%c%c) support format:\n",rk_cam_driver_description,(RK_CAM_VERSION_CODE&0xff0000)>>16,
-            (RK_CAM_VERSION_CODE&0xff00)>>8,(RK_CAM_VERSION_CODE&0xff));
+        RK29CAMERA_TR("%s(version:%c%c%c) support format:\n",rk29_cam_driver_description,(RK29_CAM_VERSION_CODE&0xff0000)>>16,
+            (RK29_CAM_VERSION_CODE&0xff00)>>8,(RK29_CAM_VERSION_CODE&0xff));
         for (i = 0; i < icd->num_user_formats; i++)
-		    RKCAMERA_TR("(%c%c%c%c)-%s\n",
+		    RK29CAMERA_TR("(%c%c%c%c)-%s\n",
 		    icd->user_formats[i].host_fmt->fourcc & 0xFF, (icd->user_formats[i].host_fmt->fourcc >> 8) & 0xFF,
 			(icd->user_formats[i].host_fmt->fourcc >> 16) & 0xFF, (icd->user_formats[i].host_fmt->fourcc >> 24) & 0xFF,
 			icd->user_formats[i].host_fmt->name);
-        goto RK_CAMERA_TRY_FMT_END;
+        goto RK29_CAMERA_TRY_FMT_END;
     }
    /* limit to rk29 hardware capabilities */
-    v4l_bound_align_image(&pix->width, RK_CAM_W_MIN, RK_CAM_W_MAX, 1,
-    	      &pix->height, RK_CAM_H_MIN, RK_CAM_H_MAX, 0,
+    v4l_bound_align_image(&pix->width, RK29_CAM_W_MIN, RK29_CAM_W_MAX, 1,
+    	      &pix->height, RK29_CAM_H_MIN, RK29_CAM_H_MAX, 0,
     	      pixfmt == V4L2_PIX_FMT_NV16 ? 4 : 0);
 
     pix->bytesperline = soc_mbus_bytes_per_line(pix->width,
@@ -1510,9 +1451,9 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
 
 	ret = v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);
 	if (ret < 0)
-		goto RK_CAMERA_TRY_FMT_END;
-    RKCAMERA_DG("%s mf.width:%d  mf.height:%d\n",__FUNCTION__,mf.width,mf.height);
-	#ifdef CONFIG_VIDEO_RK_WORK_IPP       
+		goto RK29_CAMERA_TRY_FMT_END;
+    RK29CAMERA_DG("%s mf.width:%d  mf.height:%d\n",__FUNCTION__,mf.width,mf.height);
+	#ifdef CONFIG_VIDEO_RK29_WORK_IPP       
 	if ((mf.width > usr_w) && (mf.height > usr_h)) {
 		if (is_capture) {
 			vipmem_is_overflow = (PAGE_ALIGN(pix->bytesperline*pix->height) > pcdev->vipmem_size);
@@ -1524,7 +1465,7 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
 			pix->width = usr_w;
 			pix->height = usr_h;
 		} else {
-			RKCAMERA_TR("vipmem for IPP is overflow, This resolution(%dx%d -> %dx%d) is invalidate!\n",mf.width,mf.height,usr_w,usr_h);
+			RK29CAMERA_TR("vipmem for IPP is overflow, This resolution(%dx%d -> %dx%d) is invalidate!\n",mf.width,mf.height,usr_w,usr_h);
             pix->width = mf.width;
             pix->height = mf.height;            
 		}
@@ -1539,18 +1480,17 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
 				pix->width = usr_w;
 				pix->height = usr_h;
 			} else {
-				RKCAMERA_TR("vipmem for IPP is overflow, This resolution(%dx%d -> %dx%d) is invalidate!\n",mf.width,mf.height,usr_w,usr_h);
-		                pix->width = mf.width;
-		                pix->height = mf.height;
+				RK29CAMERA_TR("vipmem for IPP is overflow, This resolution(%dx%d -> %dx%d) is invalidate!\n",mf.width,mf.height,usr_w,usr_h);
+                pix->width = mf.width;
+                pix->height = mf.height;
 			}
 		} else {
-			RKCAMERA_TR("The aspect ratio(%dx%d/%dx%d) is bigger than 2 !\n",mf.width,mf.height,usr_w,usr_h);
-		            pix->width = mf.width;
-		            pix->height = mf.height;
+			RK29CAMERA_TR("The aspect ratio(%dx%d/%dx%d) is bigger than 2 !\n",mf.width,mf.height,usr_w,usr_h);
+            pix->width = mf.width;
+            pix->height = mf.height;
 		}
 	}
 	#else
-	//need to change according to crop and scale capablicity
     pix->width	= mf.width;
 	pix->height	= mf.height;	
     #endif
@@ -1565,16 +1505,16 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
 		/* TODO: support interlaced at least in pass-through mode */
 		dev_err(icd->dev.parent, "Field type %d unsupported.\n",
 			mf.field);
-		goto RK_CAMERA_TRY_FMT_END;
+		goto RK29_CAMERA_TRY_FMT_END;
 	}
 
-RK_CAMERA_TRY_FMT_END:
+RK29_CAMERA_TRY_FMT_END:
 	if (ret)
-    	RKCAMERA_TR("\n%s..%d.. ret = %d  \n",__FUNCTION__,__LINE__, ret);
+    	RK29CAMERA_TR("\n%s..%d.. ret = %d  \n",__FUNCTION__,__LINE__, ret);
     return ret;
 }
 
-static int rk_camera_reqbufs(struct soc_camera_device *icd,
+static int rk29_camera_reqbufs(struct soc_camera_device *icd,
                                struct v4l2_requestbuffers *p)
 {
     int i;
@@ -1584,8 +1524,8 @@ static int rk_camera_reqbufs(struct soc_camera_device *icd,
      * a dma IRQ can occur for an in-work or unlinked buffer. Until now
      * it hadn't triggered */
     for (i = 0; i < p->count; i++) {
-        struct rk_camera_buffer *buf = container_of(icd->vb_vidq.bufs[i],
-                                                           struct rk_camera_buffer, vb);
+        struct rk29_buffer *buf = container_of(icd->vb_vidq.bufs[i],
+                                                           struct rk29_buffer, vb);
         buf->inwork = 0;
         INIT_LIST_HEAD(&buf->vb.queue);
     }
@@ -1593,13 +1533,13 @@ static int rk_camera_reqbufs(struct soc_camera_device *icd,
     return 0;
 }
 
-static unsigned int rk_camera_poll(struct file *file, poll_table *pt)
+static unsigned int rk29_camera_poll(struct file *file, poll_table *pt)
 {
     struct soc_camera_device *icd = file->private_data;
-    struct rk_camera_buffer *buf;
+    struct rk29_buffer *buf;
 
-    buf = list_entry(icd->vb_vidq.stream.next, struct rk_camera_buffer,
-                    vb.stream);
+    buf = list_entry(icd->vb_vidq.stream.next, struct rk29_buffer,
+                     vb.stream);
 
     poll_wait(file, &buf->vb.done, pt);
 
@@ -1610,10 +1550,10 @@ static unsigned int rk_camera_poll(struct file *file, poll_table *pt)
     return 0;
 }
 
-static int rk_camera_querycap(struct soc_camera_host *ici,
+static int rk29_camera_querycap(struct soc_camera_host *ici,
                                 struct v4l2_capability *cap)
 {
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
     char orientation[5];
 
     strlcpy(cap->card, dev_name(pcdev->icd->pdev), sizeof(cap->card));    
@@ -1623,152 +1563,127 @@ static int rk_camera_querycap(struct soc_camera_host *ici,
         sprintf(orientation,"-%d",pcdev->pdata->info[1].orientation);
     }
     strcat(cap->card,orientation); 
-    cap->version = RK_CAM_VERSION_CODE;
+    cap->version = RK29_CAM_VERSION_CODE;
     cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
 
     return 0;
 }
 
-static int rk_camera_suspend(struct soc_camera_device *icd, pm_message_t state)
+static int rk29_camera_suspend(struct soc_camera_device *icd, pm_message_t state)
 {
     struct soc_camera_host *ici =
                     to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
 	struct v4l2_subdev *sd;
     int ret = 0,tmp;
 
 	mutex_lock(&camera_lock);
 	if ((pcdev->icd == icd) && (icd->ops->suspend)) {
-		rk_camera_s_stream(icd, 0);
+		rk29_camera_s_stream(icd, 0);
 		sd = soc_camera_to_subdev(icd);
 		v4l2_subdev_call(sd, video, s_stream, 0);
 		ret = icd->ops->suspend(icd, state);
 
-		pcdev->reginfo_suspend.cifCtrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
-		pcdev->reginfo_suspend.cifCrop = read_cif_reg(pcdev->base,CIF_CIF_CROP);
-		pcdev->reginfo_suspend.cifFs = read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE);
-		pcdev->reginfo_suspend.cifIntEn = read_cif_reg(pcdev->base,CIF_CIF_INTEN);
-		pcdev->reginfo_suspend.cifFmt= read_cif_reg(pcdev->base,CIF_CIF_FOR);
-		//pcdev->reginfo_suspend.VipCrm = read_vip_reg(pcdev->base,RK29_VIP_CRM);
+		pcdev->reginfo_suspend.VipCtrl = read_vip_reg(RK29_VIP_CTRL);
+		pcdev->reginfo_suspend.VipCrop = read_vip_reg(RK29_VIP_CROP);
+		pcdev->reginfo_suspend.VipFs = read_vip_reg(RK29_VIP_FS);
+		pcdev->reginfo_suspend.VipIntMsk = read_vip_reg(RK29_VIP_INT_MASK);
+		pcdev->reginfo_suspend.VipCrm = read_vip_reg(RK29_VIP_CRM);
 
-		tmp = pcdev->reginfo_suspend.cifFs>>16;		/* ddl@rock-chips.com */
-		tmp += pcdev->reginfo_suspend.cifCrop>>16;
-		pcdev->reginfo_suspend.cifFs = (pcdev->reginfo_suspend.cifFs & 0xffff) | (tmp<<16);
+		tmp = pcdev->reginfo_suspend.VipFs>>16;		/* ddl@rock-chips.com */
+		tmp += pcdev->reginfo_suspend.VipCrop>>16;
+		pcdev->reginfo_suspend.VipFs = (pcdev->reginfo_suspend.VipFs & 0xffff) | (tmp<<16);
 
 		pcdev->reginfo_suspend.Inval = Reg_Validate;
-		rk_camera_deactivate(pcdev);
+		rk29_camera_deactivate(pcdev);
 
-		RKCAMERA_DG("%s Enter Success...\n", __FUNCTION__);
+		RK29CAMERA_DG("%s Enter Success...\n", __FUNCTION__);
 	} else {
-		RKCAMERA_DG("%s icd has been deattach, don't need enter suspend\n", __FUNCTION__);
+		RK29CAMERA_DG("%s icd has been deattach, don't need enter suspend\n", __FUNCTION__);
 	}
 	mutex_unlock(&camera_lock);
     return ret;
 }
 
-static int rk_camera_resume(struct soc_camera_device *icd)
+static int rk29_camera_resume(struct soc_camera_device *icd)
 {
     struct soc_camera_host *ici =
                     to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
 	struct v4l2_subdev *sd;
     int ret = 0;
 
 	mutex_lock(&camera_lock);
 	if ((pcdev->icd == icd) && (icd->ops->resume)) {
 		if (pcdev->reginfo_suspend.Inval == Reg_Validate) {
-			rk_camera_activate(pcdev, icd);
-			write_cif_reg(pcdev->base,CIF_CIF_INTEN, pcdev->reginfo_suspend.cifIntEn);
-			//write_cif_reg(pcdev->base,RK29_VIP_CRM, pcdev->reginfo_suspend.VipCrm);
-			write_cif_reg(pcdev->base,CIF_CIF_CTRL, pcdev->reginfo_suspend.cifCtrl&~ENABLE_CAPTURE);
-			write_cif_reg(pcdev->base,CIF_CIF_CROP, pcdev->reginfo_suspend.cifCrop);
-			write_cif_reg(pcdev->base,CIF_CIF_SET_SIZE, pcdev->reginfo_suspend.cifFs);
-			write_cif_reg(pcdev->base,CIF_CIF_FOR, pcdev->reginfo_suspend.cifFmt);
-			
-			rk_videobuf_capture(pcdev->active,pcdev);
-			rk_camera_s_stream(icd, 1);
+			rk29_camera_activate(pcdev, icd);
+			write_vip_reg(RK29_VIP_INT_MASK, pcdev->reginfo_suspend.VipIntMsk);
+			write_vip_reg(RK29_VIP_CRM, pcdev->reginfo_suspend.VipCrm);
+			write_vip_reg(RK29_VIP_CTRL, pcdev->reginfo_suspend.VipCtrl&~ENABLE_CAPTURE);
+			write_vip_reg(RK29_VIP_CROP, pcdev->reginfo_suspend.VipCrop);
+			write_vip_reg(RK29_VIP_FS, pcdev->reginfo_suspend.VipFs);
+
+			rk29_videobuf_capture(pcdev->active);
+			rk29_camera_s_stream(icd, 1);
 			pcdev->reginfo_suspend.Inval = Reg_Invalidate;
 		} else {
-			RKCAMERA_TR("Resume fail, vip register recored is invalidate!!\n");
-			goto rk_camera_resume_end;
+			RK29CAMERA_TR("Resume fail, vip register recored is invalidate!!\n");
+			goto rk29_camera_resume_end;
 		}
 
 		ret = icd->ops->resume(icd);
 		sd = soc_camera_to_subdev(icd);
 		v4l2_subdev_call(sd, video, s_stream, 1);
 
-		RKCAMERA_DG("%s Enter success\n",__FUNCTION__);
+		RK29CAMERA_DG("%s Enter success\n",__FUNCTION__);
 	} else {
-		RKCAMERA_DG("%s icd has been deattach, don't need enter resume\n", __FUNCTION__);
+		RK29CAMERA_DG("%s icd has been deattach, don't need enter resume\n", __FUNCTION__);
 	}
 
-rk_camera_resume_end:
+rk29_camera_resume_end:
 	mutex_unlock(&camera_lock);
     return ret;
 }
 
-static void rk_camera_reinit_work(struct work_struct *work)
+static void rk29_camera_reinit_work(struct work_struct *work)
 {
 	struct device *control;
     struct v4l2_subdev *sd;
 	struct v4l2_mbus_framefmt mf;
 	const struct soc_camera_format_xlate *xlate;
 	int ret;
-	struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);
-	struct rk_camera_dev *pcdev = camera_work->pcdev;
-	//dump regs
-	{
-		RKCAMERA_TR("CIF_CIF_CTRL = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_CTRL));
-		RKCAMERA_TR("CIF_CIF_INTEN = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_INTEN));
-		RKCAMERA_TR("CIF_CIF_INTSTAT = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_INTSTAT));
-		RKCAMERA_TR("CIF_CIF_FOR = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_FOR));
-		RKCAMERA_TR("CIF_CIF_CROP = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_CROP));
-		RKCAMERA_TR("CIF_CIF_SET_SIZE = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE));
-		RKCAMERA_TR("CIF_CIF_SCL_CTRL = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL));
-		RKCAMERA_TR("CRU_PCLK_REG30 = 0X%x\n",read_cru_reg(CRU_PCLK_REG30));
-		RKCAMERA_TR("CIF_CIF_LAST_LINE = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_LINE));
-		
-		RKCAMERA_TR("CIF_CIF_LAST_PIX = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_PIX));
-		RKCAMERA_TR("CIF_CIF_VIR_LINE_WIDTH = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH));
-	RKCAMERA_TR("CIF_CIF_LINE_NUM_ADDR = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_LINE_NUM_ADDR));
-	RKCAMERA_TR("CIF_CIF_FRM0_ADDR_Y = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y));
-	RKCAMERA_TR("CIF_CIF_FRM0_ADDR_UV = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV));
-	RKCAMERA_TR("CIF_CIF_FRAME_STATUS = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS));
-	}
-	write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)&(~ENABLE_CAPTURE)));
 
-	control = to_soc_camera_control(pcdev->icd);
+	write_vip_reg(RK29_VIP_CTRL, (read_vip_reg(RK29_VIP_CTRL)&(~ENABLE_CAPTURE)));
+
+	control = to_soc_camera_control(rk29_camdev_info_ptr->icd);
 	sd = dev_get_drvdata(control);
 	ret = v4l2_subdev_call(sd,core, init, 1);
 
-	mf.width = pcdev->icd->user_width;
-	mf.height = pcdev->icd->user_height;
-	xlate = soc_camera_xlate_by_fourcc(pcdev->icd, pcdev->icd->current_fmt->host_fmt->fourcc);	
+	mf.width = rk29_camdev_info_ptr->icd->user_width;
+	mf.height = rk29_camdev_info_ptr->icd->user_height;
+	xlate = soc_camera_xlate_by_fourcc(rk29_camdev_info_ptr->icd, rk29_camdev_info_ptr->icd->current_fmt->host_fmt->fourcc);	
 	mf.code = xlate->code;
 
 	ret |= v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
 
-	write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)|ENABLE_CAPTURE));
+	write_vip_reg(RK29_VIP_CTRL, (read_vip_reg(RK29_VIP_CTRL)|ENABLE_CAPTURE));
 
-	RKCAMERA_TR("Camera host haven't recevie data from sensor,Reinit sensor now! ret:0x%x\n",ret);
+	RK29CAMERA_TR("Camera host haven't recevie data from sensor,Reinit sensor now! ret:0x%x\n",ret);
 }
-static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
+static enum hrtimer_restart rk29_camera_fps_func(struct hrtimer *timer)
 {
-    struct rk_camera_frmivalenum *fival_nxt=NULL,*fival_pre=NULL, *fival_rec=NULL;
-	struct rk_camera_timer *fps_timer = container_of(timer, struct rk_camera_timer, timer);
-	struct rk_camera_dev *pcdev = fps_timer->pcdev;
+    struct rk29_camera_frmivalenum *fival_nxt=NULL,*fival_pre=NULL, *fival_rec=NULL;
     int rec_flag,i;
     
-	RKCAMERA_DG("rk_camera_fps_func fps:0x%x\n",pcdev->fps);
-	if (pcdev->fps < 2) {
-		RKCAMERA_TR("Camera host haven't recevie data from sensor,Reinit sensor delay!\n");
-		pcdev->camera_reinit_work.pcdev = pcdev;
-		INIT_WORK(&(pcdev->camera_reinit_work.work), rk_camera_reinit_work);
-		queue_work(pcdev->camera_wq,&(pcdev->camera_reinit_work.work));
+	RK29CAMERA_DG("rk29_camera_fps_func fps:0x%x\n",rk29_camdev_info_ptr->fps);
+	if (rk29_camdev_info_ptr->fps < 2) {
+		RK29CAMERA_TR("Camera host haven't recevie data from sensor,Reinit sensor delay!\n");
+		INIT_WORK(&rk29_camdev_info_ptr->camera_reinit_work, rk29_camera_reinit_work);
+		queue_work(rk29_camdev_info_ptr->camera_wq,&(rk29_camdev_info_ptr->camera_reinit_work));
 	} else {
 	    for (i=0; i<2; i++) {
-            if (pcdev->icd == pcdev->icd_frmival[i].icd) {
-                fival_nxt = pcdev->icd_frmival[i].fival_list;                
+            if (rk29_camdev_info_ptr->icd == rk29_camdev_info_ptr->icd_frmival[i].icd) {
+                fival_nxt = rk29_camdev_info_ptr->icd_frmival[i].fival_list;                
             }
         }
         
@@ -1776,32 +1691,27 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
         fival_pre = fival_nxt;
         while (fival_nxt != NULL) {
 
-            RKCAMERA_DG("%s %c%c%c%c %dx%d framerate : %d/%d\n", dev_name(&pcdev->icd->dev), 
+            RK29CAMERA_DG("%s %c%c%c%c %dx%d framerate : %d/%d\n", dev_name(&rk29_camdev_info_ptr->icd->dev), 
                 fival_nxt->fival.pixel_format & 0xFF, (fival_nxt->fival.pixel_format >> 8) & 0xFF,
 			    (fival_nxt->fival.pixel_format >> 16) & 0xFF, (fival_nxt->fival.pixel_format >> 24),
 			    fival_nxt->fival.width, fival_nxt->fival.height, fival_nxt->fival.discrete.denominator,
 			    fival_nxt->fival.discrete.numerator);
             
-            if (((fival_nxt->fival.pixel_format == pcdev->pixfmt) 
-                && (fival_nxt->fival.height == pcdev->icd->user_height)
-                && (fival_nxt->fival.width == pcdev->icd->user_width))
+            if (((fival_nxt->fival.pixel_format == rk29_camdev_info_ptr->pixfmt) 
+                && (fival_nxt->fival.height == rk29_camdev_info_ptr->icd->user_height)
+                && (fival_nxt->fival.width == rk29_camdev_info_ptr->icd->user_width))
                 || (fival_nxt->fival.discrete.denominator == 0)) {
-
-                if (fival_nxt->fival.discrete.denominator == 0) {
-                    fival_nxt->fival.index = 0;
-                    fival_nxt->fival.width = pcdev->icd->user_width;
-                    fival_nxt->fival.height= pcdev->icd->user_height;
-                    fival_nxt->fival.pixel_format = pcdev->pixfmt;
-                    fival_nxt->fival.discrete.denominator = pcdev->fps+2;
-                    fival_nxt->fival.discrete.numerator = 1;
-                    fival_nxt->fival.type = V4L2_FRMIVAL_TYPE_DISCRETE;
-                } else {                
-                    if (abs(pcdev->fps + 2 - fival_nxt->fival.discrete.numerator) > 2) {
-                        fival_nxt->fival.discrete.denominator = pcdev->fps+2;
-                        fival_nxt->fival.discrete.numerator = 1;
-                        fival_nxt->fival.type = V4L2_FRMIVAL_TYPE_DISCRETE;
-                    }
-                }
+                
+                fival_nxt->fival.index = 0;
+                fival_nxt->fival.width = rk29_camdev_info_ptr->icd->user_width;
+                fival_nxt->fival.height= rk29_camdev_info_ptr->icd->user_height;
+                fival_nxt->fival.pixel_format = rk29_camdev_info_ptr->pixfmt;
+                fival_nxt->fival.discrete.denominator = rk29_camdev_info_ptr->frame_interval;                
+                fival_nxt->fival.reserved[1] = (rk29_camdev_info_ptr->icd_width<<16)
+                                                    |(rk29_camdev_info_ptr->icd_height);
+                fival_nxt->fival.discrete.numerator = 1000000;
+                fival_nxt->fival.type = V4L2_FRMIVAL_TYPE_DISCRETE;
+                
                 rec_flag = 1;
                 fival_rec = fival_nxt;
             }
@@ -1810,15 +1720,19 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
         }
 
         if ((rec_flag == 0) && fival_pre) {
-            fival_pre->nxt = kzalloc(sizeof(struct rk_camera_frmivalenum), GFP_ATOMIC);
+            fival_pre->nxt = kzalloc(sizeof(struct rk29_camera_frmivalenum), GFP_ATOMIC);
             if (fival_pre->nxt != NULL) {
                 fival_pre->nxt->fival.index = fival_pre->fival.index++;
-                fival_pre->nxt->fival.width = pcdev->icd->user_width;
-                fival_pre->nxt->fival.height= pcdev->icd->user_height;
-                fival_pre->nxt->fival.pixel_format = pcdev->pixfmt;
+                fival_pre->nxt->fival.width = rk29_camdev_info_ptr->icd->user_width;
+                fival_pre->nxt->fival.height= rk29_camdev_info_ptr->icd->user_height;
+                fival_pre->nxt->fival.pixel_format = rk29_camdev_info_ptr->pixfmt;
 
-                fival_pre->nxt->fival.discrete.denominator = pcdev->fps+2;
-                fival_pre->nxt->fival.discrete.numerator = 1;
+                fival_pre->nxt->fival.discrete.denominator = rk29_camdev_info_ptr->frame_interval;
+                
+                fival_pre->nxt->fival.reserved[1] = (rk29_camdev_info_ptr->icd_width<<16)
+                                                    |(rk29_camdev_info_ptr->icd_height);
+                
+                fival_pre->nxt->fival.discrete.numerator = 1000000;
                 fival_pre->nxt->fival.type = V4L2_FRMIVAL_TYPE_DISCRETE;
                 rec_flag = 1;
                 fival_rec = fival_pre->nxt;
@@ -1828,38 +1742,37 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
 
 	return HRTIMER_NORESTART;
 }
-static int rk_camera_s_stream(struct soc_camera_device *icd, int enable)
+static int rk29_camera_s_stream(struct soc_camera_device *icd, int enable)
 {
 	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
-    int cif_ctrl_val;
+    struct rk29_camera_dev *pcdev = ici->priv;
+    int vip_ctrl_val;
 	int ret;
 
 	WARN_ON(pcdev->icd != icd);
-
-	cif_ctrl_val = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
+    pcdev->frame_interval = 0;
+	vip_ctrl_val = read_vip_reg(RK29_VIP_CTRL);
 	if (enable) {
 		pcdev->fps = 0;
-		hrtimer_cancel(&(pcdev->fps_timer.timer));
-		pcdev->fps_timer.pcdev = pcdev;
-		hrtimer_start(&(pcdev->fps_timer.timer),ktime_set(5, 0),HRTIMER_MODE_REL);
-		cif_ctrl_val |= ENABLE_CAPTURE;
+		hrtimer_cancel(&pcdev->fps_timer);
+		hrtimer_start(&pcdev->fps_timer,ktime_set(1, 0),HRTIMER_MODE_REL);
+		vip_ctrl_val |= ENABLE_CAPTURE;
 	} else {
-        cif_ctrl_val &= ~ENABLE_CAPTURE;
-		ret = hrtimer_cancel(&pcdev->fps_timer.timer);
-		ret |= flush_work(&(pcdev->camera_reinit_work.work));
-		RKCAMERA_DG("STREAM_OFF cancel timer and flush work:0x%x \n", ret);
+        vip_ctrl_val &= ~ENABLE_CAPTURE;
+		ret = hrtimer_cancel(&pcdev->fps_timer);
+		ret |= flush_work(&rk29_camdev_info_ptr->camera_reinit_work);
+		RK29CAMERA_DG("STREAM_OFF cancel timer and flush work:0x%x \n", ret);
 	}
-	write_cif_reg(pcdev->base,CIF_CIF_CTRL, cif_ctrl_val);
+	write_vip_reg(RK29_VIP_CTRL, vip_ctrl_val);
 
-	RKCAMERA_DG("%s.. enable : 0x%x , CIF_CIF_CTRL = 0x%x\n", __FUNCTION__, enable,read_cif_reg(pcdev->base,CIF_CIF_CTRL));
+	RK29CAMERA_DG("%s.. enable : 0x%x \n", __FUNCTION__, enable);
 	return 0;
 }
-int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frmivalenum *fival)
+int rk29_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frmivalenum *fival)
 {
     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
-    struct rk_camera_frmivalenum *fival_list = NULL;
+    struct rk29_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_frmivalenum *fival_list = NULL;
     struct v4l2_frmivalenum *fival_head;
     int i,ret = 0,index;
     
@@ -1890,7 +1803,7 @@ int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frm
                 ret = -EINVAL;
             }
         } else {
-            RKCAMERA_TR("%s: fival_list is NULL\n",__FUNCTION__);
+            RK29CAMERA_TR("%s: fival_list is NULL\n",__FUNCTION__);
             ret = -EINVAL;
         }
     } else {
@@ -1914,20 +1827,20 @@ int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frm
 
         if ((i == index) && (fival->height == fival_head->height) && (fival->width == fival_head->width)) {
             memcpy(fival, fival_head, sizeof(struct v4l2_frmivalenum));
-            RKCAMERA_DG("%s %dx%d@%c%c%c%c framerate : %d/%d\n", dev_name(&pcdev->icd->dev),
+            RK29CAMERA_DG("%s %dx%d@%c%c%c%c framerate : %d/%d\n", dev_name(&rk29_camdev_info_ptr->icd->dev),
                 fival->width, fival->height,
                 fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
 			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
 			     fival->discrete.denominator,fival->discrete.numerator);			    
         } else {
             if (index == 0)
-                RKCAMERA_TR("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(&pcdev->icd->dev),
+                RK29CAMERA_TR("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(&rk29_camdev_info_ptr->icd->dev),
                     fival->width,fival->height, 
                     fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
     			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
     			    index);
             else
-                RKCAMERA_DG("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(&pcdev->icd->dev),
+                RK29CAMERA_DG("%s have not catch %d%d@%c%c%c%c index(%d) framerate\n",dev_name(&rk29_camdev_info_ptr->icd->dev),
                     fival->width,fival->height, 
                     fival->pixel_format & 0xFF, (fival->pixel_format >> 8) & 0xFF,
     			    (fival->pixel_format >> 16) & 0xFF, (fival->pixel_format >> 24),
@@ -1939,51 +1852,38 @@ int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frm
     return ret;
 }
 
-#ifdef CONFIG_VIDEO_RK_DIGITALZOOM_IPP_ON
-static int rk_camera_set_digit_zoom(struct soc_camera_device *icd,
+#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON
+static int rk29_camera_set_digit_zoom(struct soc_camera_device *icd,
 								const struct v4l2_queryctrl *qctrl, int zoom_rate)
 {
 	struct v4l2_crop a;
 	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-	struct rk_camera_dev *pcdev = ici->priv;
-	unsigned int cif_fs = 0,cif_crop = 0;
-	#if 1
+	struct rk29_camera_dev *pcdev = ici->priv;
+	
 /* ddl@rock-chips.com : The largest resolution is 2047x1088, so larger resolution must be operated some times
    (Assume operate times is 4),but resolution which ipp can operate ,it is width and height must be even. */
 	a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	a.c.width = icd->user_width*100/zoom_rate;
+	a.c.width = pcdev->host_width*100/zoom_rate;
 	a.c.width &= ~0x03;    
-	a.c.height = icd->user_height*100/zoom_rate;
+	a.c.height = pcdev->host_height*100/zoom_rate;
 	a.c.height &= ~0x03;
-
-	a.c.left = ((pcdev->host_width - a.c.width)>>1 +pcdev->host_left)&(~0x01);
-	a.c.top = ((pcdev->host_height - a.c.height)>>1 + pcdev->host_top)&(~0x01);
+	
+	a.c.left = ((pcdev->host_width - a.c.width)>>1)&(~0x01);
+	a.c.top = ((pcdev->host_height - a.c.height)>>1)&(~0x01);
 
     down(&pcdev->zoominfo.sem);
 	pcdev->zoominfo.a.c.height = a.c.height;
 	pcdev->zoominfo.a.c.width = a.c.width;
-	pcdev->zoominfo.a.c.top = 0;
-	pcdev->zoominfo.a.c.left = 0;
+	pcdev->zoominfo.a.c.top = a.c.top;
+	pcdev->zoominfo.a.c.left = a.c.left;
     up(&pcdev->zoominfo.sem);
-
-	cif_crop = (a.c.left+ (a.c.top<<16));
-	cif_fs	= ((a.c.width ) + (a.c.height<<16));
-//cif do the crop , ipp do the scale
-	write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)&(~ENABLE_CAPTURE)));
-	write_cif_reg(pcdev->base,CIF_CIF_CROP, cif_crop);
-	write_cif_reg(pcdev->base,CIF_CIF_SET_SIZE, cif_fs);
-	write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH, a.c.width);
-	write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)|(ENABLE_CAPTURE)));
-	//MUST bypass scale 
-	#else
-	//change the crop and scale parameters
-    #endif
-	RKCAMERA_DG("%s..zoom_rate:%d (%dx%d at (%d,%d)-> %dx%d)\n",__FUNCTION__, zoom_rate,a.c.width, a.c.height, a.c.left, a.c.top, pcdev->host_width, pcdev->host_height );
+    
+	RK29CAMERA_DG("%s..zoom_rate:%d (%dx%d at (%d,%d)-> %dx%d)\n",__FUNCTION__, zoom_rate,a.c.width, a.c.height, a.c.left, a.c.top, pcdev->host_width, pcdev->host_height );
 
 	return 0;
 }
 #endif
-static inline struct v4l2_queryctrl const *rk_camera_soc_camera_find_qctrl(
+static inline struct v4l2_queryctrl const *rk29_camera_soc_camera_find_qctrl(
 	struct soc_camera_host_ops *ops, int id)
 {
 	int i;
@@ -1996,35 +1896,35 @@ static inline struct v4l2_queryctrl const *rk_camera_soc_camera_find_qctrl(
 }
 
 
-static int rk_camera_set_ctrl(struct soc_camera_device *icd,
+static int rk29_camera_set_ctrl(struct soc_camera_device *icd,
 								struct v4l2_control *sctrl)
 {
 
 	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
 	const struct v4l2_queryctrl *qctrl;
-    struct rk_camera_dev *pcdev = ici->priv;
+    struct rk29_camera_dev *pcdev = ici->priv;
     int ret = 0;
 
-	qctrl = rk_camera_soc_camera_find_qctrl(ici->ops, sctrl->id);
+	qctrl = rk29_camera_soc_camera_find_qctrl(ici->ops, sctrl->id);
 	if (!qctrl) {
 		ret = -ENOIOCTLCMD;
-        goto rk_camera_set_ctrl_end;
+        goto rk29_camera_set_ctrl_end;
 	}
 
 	switch (sctrl->id)
 	{
-	#ifdef CONFIG_VIDEO_RK_DIGITALZOOM_IPP_ON
+	#ifdef CONFIG_VIDEO_RK29_DIGITALZOOM_IPP_ON
 		case V4L2_CID_ZOOM_ABSOLUTE:
 		{
 			if ((sctrl->value < qctrl->minimum) || (sctrl->value > qctrl->maximum)){
         		ret = -EINVAL;
-                goto rk_camera_set_ctrl_end;
+                goto rk29_camera_set_ctrl_end;
         	}
-            ret = rk_camera_set_digit_zoom(icd, qctrl, sctrl->value);
+            ret = rk29_camera_set_digit_zoom(icd, qctrl, sctrl->value);
 			if (ret == 0) {
 				pcdev->zoominfo.zoom_rate = sctrl->value;
             } else { 
-                goto rk_camera_set_ctrl_end;
+                goto rk29_camera_set_ctrl_end;
             }
 			break;
 		}
@@ -2033,59 +1933,59 @@ static int rk_camera_set_ctrl(struct soc_camera_device *icd,
 			ret = -ENOIOCTLCMD;
 			break;
 	}
-rk_camera_set_ctrl_end:
+rk29_camera_set_ctrl_end:
 	return ret;
 }
 
-static struct soc_camera_host_ops rk_soc_camera_host_ops =
+static struct soc_camera_host_ops rk29_soc_camera_host_ops =
 {
     .owner		= THIS_MODULE,
-    .add		= rk_camera_add_device,
-    .remove		= rk_camera_remove_device,
-    .suspend	= rk_camera_suspend,
-    .resume		= rk_camera_resume,
-    .enum_frameinervals = rk_camera_enum_frameintervals,
-    .set_crop	= rk_camera_set_crop,
-    .get_formats	= rk_camera_get_formats, 
-    .put_formats	= rk_camera_put_formats,
-    .set_fmt	= rk_camera_set_fmt,
-    .try_fmt	= rk_camera_try_fmt,
-    .init_videobuf	= rk_camera_init_videobuf,
-    .reqbufs	= rk_camera_reqbufs,
-    .poll		= rk_camera_poll,
-    .querycap	= rk_camera_querycap,
-    .set_bus_param	= rk_camera_set_bus_param,
-    .s_stream = rk_camera_s_stream,   /* ddl@rock-chips.com : Add stream control for host */
-    .set_ctrl = rk_camera_set_ctrl,
-    .controls = rk_camera_controls,
-    .num_controls = ARRAY_SIZE(rk_camera_controls)
+    .add		= rk29_camera_add_device,
+    .remove		= rk29_camera_remove_device,
+    .suspend	= rk29_camera_suspend,
+    .resume		= rk29_camera_resume,
+    .enum_frameinervals = rk29_camera_enum_frameintervals,
+    .set_crop	= rk29_camera_set_crop,
+    .get_formats	= rk29_camera_get_formats, 
+    .put_formats	= rk29_camera_put_formats,
+    .set_fmt	= rk29_camera_set_fmt,
+    .try_fmt	= rk29_camera_try_fmt,
+    .init_videobuf	= rk29_camera_init_videobuf,
+    .reqbufs	= rk29_camera_reqbufs,
+    .poll		= rk29_camera_poll,
+    .querycap	= rk29_camera_querycap,
+    .set_bus_param	= rk29_camera_set_bus_param,
+    .s_stream = rk29_camera_s_stream,   /* ddl@rock-chips.com : Add stream control for host */
+    .set_ctrl = rk29_camera_set_ctrl,
+    .controls = rk29_camera_controls,
+    .num_controls = ARRAY_SIZE(rk29_camera_controls)
     
 };
-static int rk_camera_probe(struct platform_device *pdev)
+static int rk29_camera_probe(struct platform_device *pdev)
 {
-    struct rk_camera_dev *pcdev;
+    struct rk29_camera_dev *pcdev;
     struct resource *res;
-    struct rk_camera_frmivalenum *fival_list,*fival_nxt;
+    struct rk29_camera_frmivalenum *fival_list,*fival_nxt;
     int irq,i;
     int err = 0;
 
-    RKCAMERA_DG("%s..%s..%d  \n",__FUNCTION__,__FILE__,__LINE__);
+    RK29CAMERA_DG("%s..%s..%d  \n",__FUNCTION__,__FILE__,__LINE__);
     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
     irq = platform_get_irq(pdev, 0);
     if (!res || irq < 0) {
         err = -ENODEV;
         goto exit;
     }
+
     pcdev = kzalloc(sizeof(*pcdev), GFP_KERNEL);
     if (!pcdev) {
         dev_err(&pdev->dev, "Could not allocate pcdev\n");
         err = -ENOMEM;
         goto exit_alloc;
     }
+    rk29_camdev_info_ptr = pcdev;
 
-
-    /*config output clk*/ // must modify start
-    #if 0
+    /*config output clk*/
 	pcdev->aclk_ddr_lcdc = clk_get(&pdev->dev, "aclk_ddr_lcdc");
 	pcdev->aclk_disp_matrix = clk_get(&pdev->dev, "aclk_disp_matrix");
 
@@ -2106,35 +2006,34 @@ static int rk_camera_probe(struct platform_device *pdev)
 		!pcdev->vip_slave || !pcdev->vip_out || !pcdev->vip_input || !pcdev->vip_bus || !pcdev->pd_display ||
 		IS_ERR(pcdev->aclk_ddr_lcdc) || IS_ERR(pcdev->aclk_disp_matrix) ||  IS_ERR(pcdev->hclk_cpu_display) || IS_ERR(pcdev->pd_display) ||
 		IS_ERR(pcdev->vip_slave) || IS_ERR(pcdev->vip_out) || IS_ERR(pcdev->vip_input) || IS_ERR(pcdev->vip_bus))  {
-//must modify end
-        RKCAMERA_TR(KERN_ERR "failed to get vip_clk(axi) source\n");
+
+        RK29CAMERA_TR(KERN_ERR "failed to get vip_clk(axi) source\n");
         err = -ENOENT;
-        goto exit_reqmem_vip;
+        goto exit_reqmem;
     }
 
 	if (!pcdev->hclk_disp_matrix || !pcdev->vip_matrix ||
 		IS_ERR(pcdev->hclk_disp_matrix) || IS_ERR(pcdev->vip_matrix))  {
 
-        RKCAMERA_TR(KERN_ERR "failed to get vip_clk(ahb) source\n");
+        RK29CAMERA_TR(KERN_ERR "failed to get vip_clk(ahb) source\n");
         err = -ENOENT;
-        goto exit_reqmem_vip;
+        goto exit_reqmem;
     }
-#endif
+
     dev_set_drvdata(&pdev->dev, pcdev);
     pcdev->res = res;
-    pcdev->pdata = pdev->dev.platform_data;             /* ddl@rock-chips.com : Request IO in init function */
-	pcdev->hostid = pdev->id;
 
-	if (pcdev->pdata && pcdev->pdata->io_init) {
-        pcdev->pdata->io_init(pcdev->hostid);
+    pcdev->pdata = pdev->dev.platform_data;             /* ddl@rock-chips.com : Request IO in init function */
+    if (pcdev->pdata && pcdev->pdata->io_init) {
+        pcdev->pdata->io_init();
     }
-	#ifdef CONFIG_VIDEO_RK_WORK_IPP
+	#ifdef CONFIG_VIDEO_RK29_WORK_IPP
 	if (pcdev->pdata && (strcmp(pcdev->pdata->meminfo.name,"camera_ipp_mem")==0)) {
 		pcdev->vipmem_phybase = pcdev->pdata->meminfo.start;
 		pcdev->vipmem_size = pcdev->pdata->meminfo.size;
-		RKCAMERA_DG("\n%s Memory(start:0x%x size:0x%x) for IPP obtain \n",__FUNCTION__, pcdev->pdata->meminfo.start,pcdev->pdata->meminfo.size);
+		RK29CAMERA_DG("\n%s Memory(start:0x%x size:0x%x) for IPP obtain \n",__FUNCTION__, pcdev->pdata->meminfo.start,pcdev->pdata->meminfo.size);
 	} else {
-		RKCAMERA_TR("\n%s Memory for IPP have not obtain! IPP Function is fail\n",__FUNCTION__);
+		RK29CAMERA_TR("\n%s Memory for IPP have not obtain! IPP Function is fail\n",__FUNCTION__);
 		pcdev->vipmem_phybase = 0;
 		pcdev->vipmem_size = 0;
 	}
@@ -2146,48 +2045,44 @@ static int rk_camera_probe(struct platform_device *pdev)
     /*
      * Request the regions.
      */
-	 //for test ,zyc
-     if(res){
-	    if (!request_mem_region(res->start, res->end - res->start + 1,
-	                            RK_CAM_DRV_NAME)) {
-	        err = -EBUSY;
-	        goto exit_reqmem_vip;
-	    }
-	    pcdev->base = ioremap(res->start, res->end - res->start + 1);
-	    if (pcdev->base == NULL) {
-	        dev_err(pcdev->dev, "ioremap() of registers failed\n");
-	        err = -ENXIO;
-	        goto exit_ioremap_vip;
-	    }
-		printk("pcdev->base = 0x%x,\n",pcdev->base);
-     	}
-	
+    if (!request_mem_region(res->start, res->end - res->start + 1,
+                            RK29_CAM_DRV_NAME)) {
+        err = -EBUSY;
+        goto exit_reqmem;
+    }
+
+    pcdev->base = ioremap(res->start, res->end - res->start + 1);
+    if (pcdev->base == NULL) {
+        dev_err(pcdev->dev, "ioremap() of registers failed\n");
+        err = -ENXIO;
+        goto exit_ioremap;
+    }
+
     pcdev->irq = irq;
     pcdev->dev = &pdev->dev;
 
     /* config buffer address */
     /* request irq */
-   if(irq > 0){
-    err = request_irq(pcdev->irq, rk_camera_irq, 0, RK_CAM_DRV_NAME,
+    err = request_irq(pcdev->irq, rk29_camera_irq, 0, RK29_CAM_DRV_NAME,
                       pcdev);
     if (err) {
         dev_err(pcdev->dev, "Camera interrupt register failed \n");
         goto exit_reqirq;
     }
-   	}
+
 	pcdev->camera_wq = create_workqueue("rk_camera_workqueue");
 	if (pcdev->camera_wq == NULL)
 		goto exit_free_irq;
-	pcdev->camera_reinit_work.pcdev = pcdev;
-	INIT_WORK(&(pcdev->camera_reinit_work.work), rk_camera_reinit_work);
+	INIT_WORK(&pcdev->camera_reinit_work, rk29_camera_reinit_work);
 
     for (i=0; i<2; i++) {
         pcdev->icd_frmival[i].icd = NULL;
-        pcdev->icd_frmival[i].fival_list = kzalloc(sizeof(struct rk_camera_frmivalenum),GFP_KERNEL);
+        pcdev->icd_frmival[i].fival_list = kzalloc(sizeof(struct rk29_camera_frmivalenum),GFP_KERNEL);
         
     }
-    pcdev->soc_host.drv_name	= RK_CAM_DRV_NAME;
-    pcdev->soc_host.ops		= &rk_soc_camera_host_ops;
+
+    pcdev->soc_host.drv_name	= RK29_CAM_DRV_NAME;
+    pcdev->soc_host.ops		= &rk29_soc_camera_host_ops;
     pcdev->soc_host.priv		= pcdev;
     pcdev->soc_host.v4l2_dev.dev	= &pdev->dev;
     pcdev->soc_host.nr		= pdev->id;
@@ -2195,12 +2090,12 @@ static int rk_camera_probe(struct platform_device *pdev)
     err = soc_camera_host_register(&pcdev->soc_host);
     if (err)
         goto exit_free_irq;
-	pcdev->fps_timer.pcdev = pcdev;
-	hrtimer_init(&(pcdev->fps_timer.timer), CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	pcdev->fps_timer.timer.function = rk_camera_fps_func;
+
+	hrtimer_init(&pcdev->fps_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	pcdev->fps_timer.function = rk29_camera_fps_func;
     pcdev->icd_cb.sensor_cb = NULL;
-//	rk29_camdev_info_ptr = pcdev;
-    RKCAMERA_DG("%s..%s..%d  \n",__FUNCTION__,__FILE__,__LINE__);
+
+    RK29CAMERA_DG("%s..%s..%d  \n",__FUNCTION__,__FILE__,__LINE__);
     return 0;
 
 exit_free_irq:
@@ -2222,10 +2117,9 @@ static int rk_camera_probe(struct platform_device *pdev)
 	}
 exit_reqirq:
     iounmap(pcdev->base);
-exit_ioremap_vip:
+exit_ioremap:
     release_mem_region(res->start, res->end - res->start + 1);
-
-exit_reqmem_vip:
+exit_reqmem:
     if (pcdev->aclk_ddr_lcdc) {
 		clk_put(pcdev->aclk_ddr_lcdc);
 		pcdev->aclk_ddr_lcdc = NULL;
@@ -2264,16 +2158,16 @@ static int rk_camera_probe(struct platform_device *pdev)
     }
     kfree(pcdev);
 exit_alloc:
-//    rk_camdev_info_ptr = NULL;
+    rk29_camdev_info_ptr = NULL;
 exit:
     return err;
 }
 
-static int __devexit rk_camera_remove(struct platform_device *pdev)
+static int __devexit rk29_camera_remove(struct platform_device *pdev)
 {
-    struct rk_camera_dev *pcdev = platform_get_drvdata(pdev);
+    struct rk29_camera_dev *pcdev = platform_get_drvdata(pdev);
     struct resource *res;
-    struct rk_camera_frmivalenum *fival_list,*fival_nxt;
+    struct rk29_camera_frmivalenum *fival_list,*fival_nxt;
     int i;
     
     free_irq(pcdev->irq, pcdev);
@@ -2297,41 +2191,43 @@ static int __devexit rk_camera_remove(struct platform_device *pdev)
 
     res = pcdev->res;
     release_mem_region(res->start, res->end - res->start + 1);
+
     if (pcdev->pdata && pcdev->pdata->io_deinit) {         /* ddl@rock-chips.com : Free IO in deinit function */
-        pcdev->pdata->io_deinit(pcdev->hostid);
+        pcdev->pdata->io_deinit(0);
+		pcdev->pdata->io_deinit(1);
     }
 
     kfree(pcdev);
- //   rk_camdev_info_ptr = NULL;
+    rk29_camdev_info_ptr = NULL;
     dev_info(&pdev->dev, "RK28 Camera driver unloaded\n");
 
     return 0;
 }
 
-static struct platform_driver rk_camera_driver =
+static struct platform_driver rk29_camera_driver =
 {
     .driver 	= {
-        .name	= RK_CAM_DRV_NAME,
+        .name	= RK29_CAM_DRV_NAME,
     },
-    .probe		= rk_camera_probe,
-    .remove		= __devexit_p(rk_camera_remove),
+    .probe		= rk29_camera_probe,
+    .remove		= __devexit_p(rk29_camera_remove),
 };
 
 
-static int __devinit rk_camera_init(void)
+static int __devinit rk29_camera_init(void)
 {
-    RKCAMERA_DG("%s..%s..%d  \n",__FUNCTION__,__FILE__,__LINE__);
-    return platform_driver_register(&rk_camera_driver);
+    RK29CAMERA_DG("%s..%s..%d  \n",__FUNCTION__,__FILE__,__LINE__);
+    return platform_driver_register(&rk29_camera_driver);
 }
 
-static void __exit rk_camera_exit(void)
+static void __exit rk29_camera_exit(void)
 {
-    platform_driver_unregister(&rk_camera_driver);
+    platform_driver_unregister(&rk29_camera_driver);
 }
 
-device_initcall_sync(rk_camera_init);
-module_exit(rk_camera_exit);
+device_initcall_sync(rk29_camera_init);
+module_exit(rk29_camera_exit);
 
-MODULE_DESCRIPTION("RKSoc Camera Host driver");
+MODULE_DESCRIPTION("RK29 Soc Camera Host driver");
 MODULE_AUTHOR("ddl <ddl@rock-chips>");
 MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/rk_camera.c b/drivers/media/video/rk_camera.c
deleted file mode 100644
index efcd64664b7e..000000000000
--- a/drivers/media/video/rk_camera.c
+++ /dev/null
@@ -1,1775 +0,0 @@
-#include <mach/rk_camera.h> 
-#include <mach/iomux.h>
-#include <media/soc_camera.h>
-#include <linux/android_pmem.h>
-#ifndef PMEM_CAM_SIZE
-#ifdef CONFIG_VIDEO_RK 
-/*---------------- Camera Sensor Fixed Macro Begin  ------------------------*/
-// Below Macro is fixed, programer don't change it!!!!!!
-#define _CONS(a,b) a##b
-#define CONS(a,b) _CONS(a,b)
-
-#define __STR(x) #x
-#define _STR(x) __STR(x)
-#define STR(x) _STR(x)
-
-#if (CONFIG_SENSOR_IIC_ADDR_0 != 0x00)
-#define PMEM_SENSOR_FULL_RESOLUTION_0  CONS(CONFIG_SENSOR_0,_FULL_RESOLUTION)
-#define SENSOR_CIF_BUSID_0				CONS(RK_CAM_PLATFORM_DEV_ID_,CONFIG_SENSOR_CIF_INDEX_0)
-#if !(PMEM_SENSOR_FULL_RESOLUTION_0)
-#undef PMEM_SENSOR_FULL_RESOLUTION_0
-#define PMEM_SENSOR_FULL_RESOLUTION_0  0x500000
-#endif
-#else
-#define PMEM_SENSOR_FULL_RESOLUTION_0  0x00
-#endif
- 
-#if (CONFIG_SENSOR_IIC_ADDR_1 != 0x00)
-#define PMEM_SENSOR_FULL_RESOLUTION_1  CONS(CONFIG_SENSOR_1,_FULL_RESOLUTION)
-#define SENSOR_CIF_BUSID_1				CONS(RK_CAM_PLATFORM_DEV_ID_,CONFIG_SENSOR_CIF_INDEX_1)
-#if !(PMEM_SENSOR_FULL_RESOLUTION_1)
-#undef PMEM_SENSOR_FULL_RESOLUTION_1
-#define PMEM_SENSOR_FULL_RESOLUTION_1  0x500000
-#endif
-#else
-#define PMEM_SENSOR_FULL_RESOLUTION_1  0x00
-#endif
-
-#if (PMEM_SENSOR_FULL_RESOLUTION_0 > PMEM_SENSOR_FULL_RESOLUTION_1)
-#define PMEM_CAM_FULL_RESOLUTION   PMEM_SENSOR_FULL_RESOLUTION_0
-#else
-#define PMEM_CAM_FULL_RESOLUTION   PMEM_SENSOR_FULL_RESOLUTION_1
-#endif
-
-#if (PMEM_CAM_FULL_RESOLUTION == 0x500000)
-#define PMEM_CAM_NECESSARY   0x1400000       /* 1280*720*1.5*4(preview) + 7.5M(capture raw) + 4M(jpeg encode output) */
-#define PMEM_CAMIPP_NECESSARY    0x800000
-#elif (PMEM_CAM_FULL_RESOLUTION == 0x300000)
-#define PMEM_CAM_NECESSARY   0xe00000        /* 1280*720*1.5*4(preview) + 4.5M(capture raw) + 3M(jpeg encode output) */
-#define PMEM_CAMIPP_NECESSARY    0x500000
-#elif (PMEM_CAM_FULL_RESOLUTION == 0x200000) /* 1280*720*1.5*4(preview) + 3M(capture raw) + 3M(jpeg encode output) */
-#define PMEM_CAM_NECESSARY   0xc00000
-#define PMEM_CAMIPP_NECESSARY    0x400000
-#elif ((PMEM_CAM_FULL_RESOLUTION == 0x100000) || (PMEM_CAM_FULL_RESOLUTION == 0x130000))
-#define PMEM_CAM_NECESSARY   0x800000        /* 800*600*1.5*4(preview) + 2M(capture raw) + 2M(jpeg encode output) */
-#define PMEM_CAMIPP_NECESSARY    0x400000
-#elif (PMEM_CAM_FULL_RESOLUTION == 0x30000)
-#define PMEM_CAM_NECESSARY   0x400000        /* 640*480*1.5*4(preview) + 1M(capture raw) + 1M(jpeg encode output) */
-#define PMEM_CAMIPP_NECESSARY    0x400000
-#else
-#define PMEM_CAM_NECESSARY   0x1200000
-#define PMEM_CAMIPP_NECESSARY    0x800000
-#endif
-/*---------------- Camera Sensor Fixed Macro End  ------------------------*/
-#else   //#ifdef CONFIG_VIDEO_RK 
-#define PMEM_CAM_NECESSARY   0x00000000
-#endif
-#else   // #ifdef PMEM_CAM_SIZE
-
-/*****************************************************************************************
- * camera  devices
- * author: ddl@rock-chips.com
- *****************************************************************************************/
-#ifdef CONFIG_VIDEO_RK 
-static int camera_debug;
-module_param(camera_debug, int, S_IRUGO|S_IWUSR);
-
-#define ddprintk(level, fmt, arg...) do {			\
-	if (camera_debug >= level) 					\
-	    printk(KERN_WARNING"rk_cam_io: " fmt , ## arg); } while (0)
-
-#define dprintk(format, ...) ddprintk(1, format, ## __VA_ARGS__)    
-
-#define SENSOR_NAME_0 STR(CONFIG_SENSOR_0)			/* back camera sensor */
-#define SENSOR_NAME_1 STR(CONFIG_SENSOR_1)			/* front camera sensor */
-#define SENSOR_DEVICE_NAME_0  STR(CONS(CONFIG_SENSOR_0, _back))
-#define SENSOR_DEVICE_NAME_1  STR(CONS(CONFIG_SENSOR_1, _front))
-
-static int rk_sensor_io_init(int hostDevId);
-static int rk_sensor_io_deinit(int hostDevId);
-static int rk_sensor_ioctrl(struct device *dev,enum rkcamera_ioctrl_cmd cmd, int on);
-static int rk_sensor_power(struct device *dev, int on);
-static int rk_sensor_reset(struct device *dev);
-static int rk_sensor_powerdown(struct device *dev, int on);
-static struct rkcamera_platform_data rk_camera_platform_data_host_0 = {
-    .io_init = rk_sensor_io_init,
-    .io_deinit = rk_sensor_io_deinit,
-    .sensor_ioctrl = rk_sensor_ioctrl,
-    
-    .gpio_res[0] = {
-		.gpio_reset = INVALID_GPIO,
-		.gpio_power = INVALID_GPIO,
-		.gpio_powerdown = INVALID_GPIO,
-		.gpio_flash = INVALID_GPIO,
-		.gpio_flag = 0,
-		.gpio_init = 0, 		   
-		.dev_name = NULL,
-    },
-	.gpio_res[1] = {
-		.gpio_reset = INVALID_GPIO,
-		.gpio_power = INVALID_GPIO,
-		.gpio_powerdown = INVALID_GPIO,
-		.gpio_flash = INVALID_GPIO,
-		.gpio_flag = 0,
-		.gpio_init = 0, 		   
-		.dev_name = NULL,
-	},
-    .info[0] = {
-            .dev_name = NULL,
-            .orientation = 0, 
-	},
-    .info[1] = {
-		.dev_name = NULL,
-		.orientation = 0, 
-	},
-    .sensor_init_data[0] = NULL,
-    .sensor_init_data[1] = NULL,
-};
-static struct rkcamera_platform_data rk_camera_platform_data_host_1 = {
-	.io_init = rk_sensor_io_init,
-	.io_deinit = rk_sensor_io_deinit,
-	.sensor_ioctrl = rk_sensor_ioctrl,
-	.gpio_res[0] = {
-		.gpio_reset = INVALID_GPIO,
-		.gpio_power = INVALID_GPIO,
-		.gpio_powerdown = INVALID_GPIO,
-		.gpio_flash = INVALID_GPIO,
-		.gpio_flag = 0,
-		.gpio_init = 0, 		   
-		.dev_name = NULL,
-	},
-	.gpio_res[1] = {
-		.gpio_reset = INVALID_GPIO,
-		.gpio_power = INVALID_GPIO,
-		.gpio_powerdown = INVALID_GPIO,
-		.gpio_flash = INVALID_GPIO,
-		.gpio_flag = 0,
-		.gpio_init = 0, 		   
-		.dev_name = NULL,
-	},
-	.info[0] = {
-			.dev_name = NULL,
-			.orientation = 0, 
-	},
-	.info[1] = {
-		.dev_name = NULL,
-		.orientation = 0, 
-	},
-	.sensor_init_data[0] = NULL,
-	.sensor_init_data[1] = NULL,
-};
-
-#if (CONFIG_SENSOR_IIC_ADDR_0 != 0x00)
-static struct i2c_board_info rk_i2c_cam_info_0[] = {
-	{
-		I2C_BOARD_INFO(SENSOR_NAME_0, CONFIG_SENSOR_IIC_ADDR_0>>1)
-	},
-};
-
-static struct soc_camera_link rk_iclink_0 = {
-	.bus_id= SENSOR_CIF_BUSID_0,
-	.power		= rk_sensor_power,
-#if (CONFIG_SENSOR_RESET_PIN_0 != INVALID_GPIO)
-	.reset		= rk_sensor_reset,
-#endif	  
-	.powerdown	= rk_sensor_powerdown,
-	.board_info = &rk_i2c_cam_info_0[0],
-	
-	.i2c_adapter_id = CONFIG_SENSOR_IIC_ADAPTER_ID_0,
-	.module_name	= SENSOR_NAME_0,
-};
-
-/*platform_device: soc-camera need  */
- struct platform_device rk_soc_camera_pdrv_0 = {
-	.name	= "soc-camera-pdrv",
-	.id = 0,
-	.dev	= {
-		.init_name = SENSOR_DEVICE_NAME_0,
-		.platform_data = &rk_iclink_0,
-	},
-};
-#else
- struct platform_device rk_soc_camera_pdrv_0 = {
-	.name	= NULL,
-};
-#endif
-#if (CONFIG_SENSOR_IIC_ADDR_1 != 0x00)
-static struct i2c_board_info rk_i2c_cam_info_1[] = {
-	{
-		I2C_BOARD_INFO(SENSOR_NAME_1, CONFIG_SENSOR_IIC_ADDR_1>>1)
-	},
-};
-
-static struct soc_camera_link rk_iclink_1 = {
-	.bus_id 	= SENSOR_CIF_BUSID_1,
-	.power		= rk_sensor_power,
-#if (CONFIG_SENSOR_RESET_PIN_1 != INVALID_GPIO)
-	.reset		= rk_sensor_reset,
-#endif		
-	.powerdown	= rk_sensor_powerdown,
-	.board_info = &rk_i2c_cam_info_1[0],
-	.i2c_adapter_id = CONFIG_SENSOR_IIC_ADAPTER_ID_1,
-	.module_name	= SENSOR_NAME_1,
-};
-
-/*platform_device : soc-camera need  */
- struct platform_device rk_soc_camera_pdrv_1 = {
-	.name	= "soc-camera-pdrv",
-	.id = 1,
-	.dev	= {
-		.init_name = SENSOR_DEVICE_NAME_1,
-		.platform_data = &rk_iclink_1,
-	},
-};
-#else
- struct platform_device rk_soc_camera_pdrv_1 = {
-	.name	= NULL,
-};
-#endif
-
-static u64 rockchip_device_camera_dmamask = 0xffffffffUL;
-static struct resource rk_camera_resource_host_0[] = {
-	[0] = {
-		.start = RK30_CIF0_PHYS,
-		.end   = RK30_CIF0_PHYS + RK30_CIF0_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = IRQ_CIF0,
-		.end   = IRQ_CIF0,
-		.flags = IORESOURCE_IRQ,
-	}
-};
-static struct resource rk_camera_resource_host_1[] = {
-	[0] = {
-		.start = RK30_CIF1_PHYS,
-		.end   = RK30_CIF1_PHYS + RK30_CIF1_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = IRQ_CIF1,
-		.end   = IRQ_CIF1,
-		.flags = IORESOURCE_IRQ,
-	}
-};
-/*platform_device : */
- struct platform_device rk_device_camera_host_0 = {
-	.name		  = RK_CAM_DRV_NAME,
-	.id 	  = RK_CAM_PLATFORM_DEV_ID_0,				/* This is used to put cameras on this interface */
-	.num_resources	  = ARRAY_SIZE(rk_camera_resource_host_0),
-	.resource	  = rk_camera_resource_host_0,
-	.dev			= {
-		.dma_mask = &rockchip_device_camera_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-		.platform_data	= &rk_camera_platform_data_host_0,
-	}
-};
-/*platform_device : */
- struct platform_device rk_device_camera_host_1 = {
-	.name		  = RK_CAM_DRV_NAME,
-	.id 	  = RK_CAM_PLATFORM_DEV_ID_1,				/* This is used to put cameras on this interface */
-	.num_resources	  = ARRAY_SIZE(rk_camera_resource_host_1),
-	.resource	  = rk_camera_resource_host_1,
-	.dev			= {
-		.dma_mask = &rockchip_device_camera_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-		.platform_data	= &rk_camera_platform_data_host_1,
-	}
-};
-
-static void rk_init_camera_plateform_data()
-{
-	struct rkcamera_platform_data* tmp_host_plateform_data = NULL;
-	int cam_index_in = 0; 
-#if (CONFIG_SENSOR_IIC_ADDR_0 != 0x00)
-	if(SENSOR_CIF_BUSID_0 == RK_CAM_PLATFORM_DEV_ID_0)
-		tmp_host_plateform_data = &rk_camera_platform_data_host_0;
-	else
-		tmp_host_plateform_data = &rk_camera_platform_data_host_1;
-	for(cam_index_in = 0;cam_index_in < RK_CAM_NUM_PER_HOST;cam_index_in++){
-		if(tmp_host_plateform_data->info[cam_index_in].dev_name)
-			continue;
-		else
-			break;
-		}
-	if(cam_index_in < RK_CAM_NUM_PER_HOST){
-		tmp_host_plateform_data->sensor_init_data[cam_index_in] = rk_init_data_sensor_0_p;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_reset= CONFIG_SENSOR_RESET_PIN_0;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_power= CONFIG_SENSOR_POWER_PIN_0;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_powerdown= CONFIG_SENSOR_POWERDN_PIN_0;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_flash= CONFIG_SENSOR_FALSH_PIN_0;
-		tmp_host_plateform_data->gpio_res[cam_index_in].dev_name= SENSOR_DEVICE_NAME_0;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_flag= (CONFIG_SENSOR_POWERACTIVE_LEVEL_0|CONFIG_SENSOR_RESETACTIVE_LEVEL_0|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0|CONFIG_SENSOR_FLASHACTIVE_LEVEL_0);
-		tmp_host_plateform_data->gpio_res[cam_index_in].dev_name= SENSOR_DEVICE_NAME_0;
-		tmp_host_plateform_data->info[cam_index_in].dev_name= SENSOR_DEVICE_NAME_0;
-		tmp_host_plateform_data->info[cam_index_in].orientation= CONFIG_SENSOR_ORIENTATION_0;
-	}
-	cam_index_in = 0;
-	tmp_host_plateform_data = NULL;
-#endif
-#if (CONFIG_SENSOR_IIC_ADDR_1 != 0x00)
-	if(SENSOR_CIF_BUSID_1 == RK_CAM_PLATFORM_DEV_ID_0)
-		tmp_host_plateform_data = &rk_camera_platform_data_host_0;
-	else
-		tmp_host_plateform_data = &rk_camera_platform_data_host_1;
-	for(cam_index_in = 0;cam_index_in < RK_CAM_NUM_PER_HOST;cam_index_in++){
-		if(tmp_host_plateform_data->info[cam_index_in].dev_name)
-			continue;
-		else
-			break;
-		}
-	if(cam_index_in < RK_CAM_NUM_PER_HOST){
-		tmp_host_plateform_data->sensor_init_data[cam_index_in] = rk_init_data_sensor_1_p;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_reset= CONFIG_SENSOR_RESET_PIN_1;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_power= CONFIG_SENSOR_POWER_PIN_1;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_powerdown= CONFIG_SENSOR_POWERDN_PIN_1;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_flash= CONFIG_SENSOR_FALSH_PIN_1;
-		tmp_host_plateform_data->gpio_res[cam_index_in].dev_name= SENSOR_DEVICE_NAME_1;
-		tmp_host_plateform_data->gpio_res[cam_index_in].gpio_flag= (CONFIG_SENSOR_POWERACTIVE_LEVEL_1|CONFIG_SENSOR_RESETACTIVE_LEVEL_1|CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1|CONFIG_SENSOR_FLASHACTIVE_LEVEL_1);
-		tmp_host_plateform_data->gpio_res[cam_index_in].dev_name= SENSOR_DEVICE_NAME_1;
-		tmp_host_plateform_data->info[cam_index_in].dev_name= SENSOR_DEVICE_NAME_1;
-		tmp_host_plateform_data->info[cam_index_in].orientation= CONFIG_SENSOR_ORIENTATION_1;
-	}
-	cam_index_in = 0;
-	tmp_host_plateform_data = NULL;
-#endif
-}
-
-static int rk_sensor_iomux(int pin)
-{    
-    switch (pin)
-    {
-        case RK30_PIN0_PA0: 
-		{
-			 rk30_mux_api_set(GPIO0A0_HDMIHOTPLUGIN_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA1: 
-		{
-			 rk30_mux_api_set(GPIO0A1_HDMII2CSCL_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA2:
-		{
-			 rk30_mux_api_set(GPIO0A2_HDMII2CSDA_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA3:
-		{
-			 rk30_mux_api_set(GPIO0A3_PWM0_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA4:
-		{
-			 rk30_mux_api_set(GPIO0A4_PWM1_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA5:
-		{
-			 rk30_mux_api_set(GPIO0A5_OTGDRVVBUS_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA6:
-        {
-             rk30_mux_api_set(GPIO0A6_HOSTDRVVBUS_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PA7:
-        {
-             rk30_mux_api_set(GPIO0A7_I2S8CHSDI_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB0:
-        {
-             rk30_mux_api_set(GPIO0B0_I2S8CHCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB1:
-        {
-             rk30_mux_api_set(GPIO0B1_I2S8CHSCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB2:
-        {
-             rk30_mux_api_set(GPIO0B2_I2S8CHLRCKRX_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB3:
-        {
-             rk30_mux_api_set(GPIO0B3_I2S8CHLRCKTX_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB4:
-        {
-             rk30_mux_api_set(GPIO0B4_I2S8CHSDO0_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB5:
-        {
-             rk30_mux_api_set(GPIO0B5_I2S8CHSDO1_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB6:
-        {
-             rk30_mux_api_set(GPIO0B6_I2S8CHSDO2_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB7:
-        {
-             rk30_mux_api_set(GPIO0B7_I2S8CHSDO3_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC0:
-        {
-             rk30_mux_api_set(GPIO0C0_I2S12CHCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC1:
-        {
-             rk30_mux_api_set(GPIO0C1_I2S12CHSCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC2:
-        {
-             rk30_mux_api_set(GPIO0C2_I2S12CHLRCKRX_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC3:
-        {
-             rk30_mux_api_set(GPIO0C3_I2S12CHLRCKTX_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC4:
-        {
-             rk30_mux_api_set(GPIO0C4_I2S12CHSDI_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC5:
-        {
-             rk30_mux_api_set(GPIO0C5_I2S12CHSDO_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC6:
-        {
-             rk30_mux_api_set(GPIO0C6_TRACECLK_SMCADDR2_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC7:
-        {
-             rk30_mux_api_set(GPIO0C7_TRACECTL_SMCADDR3_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD0:
-        {
-             rk30_mux_api_set(GPIO0D0_I2S22CHCLK_SMCCSN0_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD1:
-        {
-             rk30_mux_api_set(GPIO0D1_I2S22CHSCLK_SMCWEN_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD2:
-        {
-             rk30_mux_api_set(GPIO0D2_I2S22CHLRCKRX_SMCOEN_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD3:
-        {
-             rk30_mux_api_set(GPIO0D3_I2S22CHLRCKTX_SMCADVN_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD4:
-        {
-             rk30_mux_api_set(GPIO0D4_I2S22CHSDI_SMCADDR0_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD5:
-        {
-             rk30_mux_api_set(GPIO0D5_I2S22CHSDO_SMCADDR1_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD6:
-        {
-             rk30_mux_api_set(GPIO0D6_PWM2_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD7:
-        {
-             rk30_mux_api_set(GPIO0D7_PWM3_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA0:
-        {
-             rk30_mux_api_set(GPIO1A0_UART0SIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA1:
-        {
-             rk30_mux_api_set(GPIO1A1_UART0SOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA2:
-        {
-             rk30_mux_api_set(GPIO1A2_UART0CTSN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA3:
-        {
-             rk30_mux_api_set(GPIO1A3_UART0RTSN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA4:
-        {
-             rk30_mux_api_set(GPIO1A4_UART1SIN_SPI0CSN0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA5:
-        {
-             rk30_mux_api_set(GPIO1A5_UART1SOUT_SPI0CLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA6:
-        {
-             rk30_mux_api_set(GPIO1A6_UART1CTSN_SPI0RXD_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA7:
-        {
-             rk30_mux_api_set(GPIO1A7_UART1RTSN_SPI0TXD_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB0:
-        {
-             rk30_mux_api_set(GPIO1B0_UART2SIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB1:
-        {
-             rk30_mux_api_set(GPIO1B1_UART2SOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB2:
-        {
-             rk30_mux_api_set(GPIO1B2_SPDIFTX_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB3:
-        {
-             rk30_mux_api_set(GPIO1B3_CIF0CLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB4:
-        {
-             rk30_mux_api_set(GPIO1B4_CIF0DATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB5:
-        {
-             rk30_mux_api_set(GPIO1B5_CIF0DATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB6:
-        {
-             rk30_mux_api_set(GPIO1B6_CIFDATA10_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB7:
-        {
-             rk30_mux_api_set(GPIO1B7_CIFDATA11_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC0:
-        {
-             rk30_mux_api_set(GPIO1C0_CIF1DATA2_RMIICLKOUT_RMIICLKIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC1:
-        {
-             rk30_mux_api_set(GPIO1C1_CIFDATA3_RMIITXEN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC2:
-        {
-             rk30_mux_api_set(GPIO1C2_CIF1DATA4_RMIITXD1_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC3:
-        {
-             rk30_mux_api_set(GPIO1C3_CIFDATA5_RMIITXD0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC4:
-        {
-             rk30_mux_api_set(GPIO1C4_CIFDATA6_RMIIRXERR_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC5:
-        {
-             rk29_mux_api_set(GPIO1C5_CIFDATA7_RMIICRSDVALID_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC6:
-        {
-             rk30_mux_api_set(GPIO1C6_CIFDATA8_RMIIRXD1_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC7:
-        {
-             rk30_mux_api_set(GPIO1C7_CIFDATA9_RMIIRXD0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD0:
-        {
-             rk30_mux_api_set(GPIO1D0_CIF1VSYNC_MIIMD_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD1:
-        {
-             rk30_mux_api_set(GPIO1D1_CIF1HREF_MIIMDCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD2:
-        {
-             rk30_mux_api_set(GPIO1D2_CIF1CLKIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD3:
-        {
-             rk30_mux_api_set(GPIO1D3_CIF1DATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD4:
-        {
-             rk30_mux_api_set(GPIO1D4_CIF1DATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD5:
-        {
-             rk30_mux_api_set(GPIO1D5_CIF1DATA10_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD6:
-        {
-             rk30_mux_api_set(GPIO1D6_CIF1DATA11_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD7:
-        {
-             rk30_mux_api_set(GPIO1D7_CIF1CLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA0:
-        {
-             rk30_mux_api_set(GPIO2A0_LCDC1DATA0_SMCADDR4_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA1:
-        {
-             rk30_mux_api_set(GPIO2A1_LCDC1DATA1_SMCADDR5_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA2:
-        {
-             rk30_mux_api_set(GPIO2A2_LCDCDATA2_SMCADDR6_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA3:
-        {
-             rk30_mux_api_set(GPIO2A3_LCDCDATA3_SMCADDR7_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA4:
-        {
-             rk30_mux_api_set(GPIO2A4_LCDC1DATA4_SMCADDR8_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA5:
-        {
-             rk30_mux_api_set(GPIO2A5_LCDC1DATA5_SMCADDR9_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA6:
-        {
-             rk30_mux_api_set(GPIO2A6_LCDC1DATA6_SMCADDR10_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA7:
-        {
-             rk30_mux_api_set(GPIO2A7_LCDC1DATA7_SMCADDR11_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB0:
-        {
-             rk30_mux_api_set(GPIO2B0_LCDC1DATA8_SMCADDR12_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB1:
-        {
-             rk30_mux_api_set(GPIO2B1_LCDC1DATA9_SMCADDR13_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB2:
-        {
-             rk30_mux_api_set(GPIO2B2_LCDC1DATA10_SMCADDR14_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB3:
-        {
-             rk30_mux_api_set(GPIO2B3_LCDC1DATA11_SMCADDR15_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB4:
-        {
-             rk30_mux_api_set(GPIO2B4_LCDC1DATA12_SMCADDR16_HSADCDATA9_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB5:
-        {
-             rk30_mux_api_set(GPIO2B5_LCDC1DATA13_SMCADDR17_HSADCDATA8_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB6:
-        {
-             rk30_mux_api_set(GPIO2B6_LCDC1DATA14_SMCADDR18_TSSYNC_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB7:
-        {
-             rk30_mux_api_set(GPIO2B7_LCDC1DATA15_SMCADDR19_HSADCDATA7_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC0:
-        {
-             rk30_mux_api_set(GPIO2C0_LCDCDATA16_GPSCLK_HSADCCLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC1:
-        {
-             rk30_mux_api_set(GPIO2C1_LCDC1DATA17_SMCBLSN0_HSADCDATA6_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC2:
-        {
-             rk30_mux_api_set(GPIO2C2_LCDC1DATA18_SMCBLSN1_HSADCDATA5_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC3:
-        {
-             rk29_mux_api_set(GPIO2C3_LCDC1DATA19_SPI1CLK_HSADCDATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC4:
-        {
-             rk30_mux_api_set(GPIO2C4_LCDC1DATA20_SPI1CSN0_HSADCDATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC5:
-        {
-             rk30_mux_api_set(GPIO2C5_LCDC1DATA21_SPI1TXD_HSADCDATA2_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC6:
-        {
-             rk30_mux_api_set(GPIO2C6_LCDC1DATA22_SPI1RXD_HSADCDATA3_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC7:
-        {
-             rk30_mux_api_set(GPIO2C7_LCDC1DATA23_SPI1CSN1_HSADCDATA4_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD0:
-        {
-             rk30_mux_api_set(GPIO2D0_LCDC1DCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD1:
-        {
-             rk30_mux_api_set(GPIO2D1_LCDC1DEN_SMCCSN1_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD2:
-        {
-             rk30_mux_api_set(GPIO2D2_LCDC1HSYNC_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD3:
-        {
-             rk30_mux_api_set(GPIO2D3_LCDC1VSYNC_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD4:
-        {
-             rk30_mux_api_set(GPIO2D4_I2C0SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD5:
-        {
-             rk30_mux_api_set(GPIO2D5_I2C0SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD6:
-        {
-             rk30_mux_api_set(GPIO2D6_I2C1SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD7:
-        {
-             rk30_mux_api_set(GPIO2D7_I2C1SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA0:
-        {
-             rk30_mux_api_set(GPIO3A0_I2C2SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA1:
-        {
-             rk30_mux_api_set(GPIO3A1_I2C2SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA2:
-        {
-             rk30_mux_api_set(GPIO3A2_I2C3SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA3:
-        {
-             rk30_mux_api_set(GPIO3A3_I2C3SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA4:
-        {
-             rk30_mux_api_set(GPIO3A4_I2C4SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA5:
-        {
-             rk30_mux_api_set(GPIO3A5_I2C4SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA6:
-        {
-             rk30_mux_api_set(GPIO3A6_SDMMC0RSTNOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA7:
-        {
-             rk30_mux_api_set(GPIO3A7_SDMMC0WRITEPRT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB0:
-        {
-             rk30_mux_api_set(GPIO3B0_SDMMC0CLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB1:
-        {
-             rk30_mux_api_set(GPIO3B1_SDMMC0CMD_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB2:
-        {
-             rk30_mux_api_set(GPIO3B2_SDMMC0DATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB3:
-        {
-             rk30_mux_api_set(GPIO3B3_SDMMC0DATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB4:
-        {
-             rk30_mux_api_set(GPIO3B4_SDMMC0DATA2_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB5:
-        {
-             rk30_mux_api_set(GPIO3B5_SDMMC0DATA3_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB6:
-        {
-             rk30_mux_api_set(GPIO3B6_SDMMC0DETECTN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB7:
-        {
-             rk30_mux_api_set(GPIO3B7_SDMMC0WRITEPRT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC0:
-        {
-             rk30_mux_api_set(GPIO3C0_SMMC1CMD_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC1:
-        {
-             rk30_mux_api_set(GPIO3C1_SDMMC1DATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC2:
-        {
-             rk30_mux_api_set(GPIO3C2_SDMMC1DATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC3:
-        {
-             rk30_mux_api_set(GPIO3C3_SDMMC1DATA2_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC4:
-        {
-             rk30_mux_api_set(GPIO3C4_SDMMC1DATA3_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC5:
-        {
-             rk30_mux_api_set(GPIO3C5_SDMMC1CLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC6:
-        {
-             rk30_mux_api_set(GPIO3C6_SDMMC1DETECTN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC7:
-        {
-             rk30_mux_api_set(GPIO3C7_SDMMC1WRITEPRT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD0:
-        {
-             rk30_mux_api_set(GPIO3D0_SDMMC1PWREN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD1:
-        {
-             rk30_mux_api_set(GPIO3D1_SDMMC1BACKENDPWR_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD2:
-        {
-             rk30_mux_api_set(GPIO3D2_SDMMC1INTN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD3:
-        {
-             rk30_mux_api_set(GPIO3D3_UART3SIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD4:
-        {
-             rk30_mux_api_set(GPIO3D4_UART3SOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD5:
-        {
-             rk30_mux_api_set(GPIO3D5_UART3CTSN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD6:
-        {
-             rk30_mux_api_set(GPIO3D6_UART3RTSN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD7:
-        {
-             rk30_mux_api_set(GPIO3D7_FLASHDQS_EMMCCLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PA0:
-	{
-		 rk30_mux_api_set(GPIO4A0_FLASHDATA8_NAME,0);
-		break;	
-	}
-        case RK30_PIN4_PA1:
-	{
-		 rk30_mux_api_set(GPIO4A1_FLASHDATA9_NAME,0);
-		break;	
-	}
-        case RK30_PIN4_PA2:
-	{
-		 rk30_mux_api_set(GPIO4A2_FLASHDATA10_NAME,0);
-		break;	
-	}
-			
-        case RK30_PIN4_PA3:
-	{
-		 rk30_mux_api_set(GPIO4A3_FLASHDATA11_NAME,0);
-		break;	
-	}
-        case RK30_PIN4_PA4:
-	{
-		 rk30_mux_api_set(GPIO4A4_FLASHDATA12_NAME,0);
-		break;	
-	}
-        case RK30_PIN4_PA5:
-        {
-             rk30_mux_api_set(GPIO4A5_FLASHDATA13_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PA6:
-        {
-             rk30_mux_api_set(GPIO4A6_FLASHDATA14_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PA7:
-        {
-             rk30_mux_api_set(GPIO4A7_FLASHDATA15_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB0:
-        {
-             rk30_mux_api_set(GPIO4B0_FLASHCSN1_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB1:
-        {
-             rk30_mux_api_set(GPIO4B1_FLASHCSN2_EMMCCMD_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB2:
-        {
-             rk30_mux_api_set(GPIO4B2_FLASHCSN3_EMMCRSTNOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB3:
-        {
-             rk30_mux_api_set(GPIO4B3_FLASHCSN4_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB4:
-        {
-             rk30_mux_api_set(GPIO4B4_FLASHCSN5_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB5:
-        {
-             rk30_mux_api_set(GPIO4B5_FLASHCSN6_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB6:
-        {
-             rk30_mux_api_set(GPIO4B6_FLASHCSN7_NAME ,0);
-            break;	
-        }
-        case RK30_PIN4_PB7:
-        {
-             rk30_mux_api_set(GPIO4B7_SPI0CSN1_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC0:
-        {
-             rk30_mux_api_set(GPIO4C0_SMCDATA0_TRACEDATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC1:
-        {
-             rk30_mux_api_set(GPIO4C1_SMCDATA1_TRACEDATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC2:
-        {
-             rk30_mux_api_set(GPIO4C2_SMCDATA2_TRACEDATA2_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC3:
-        {
-             rk30_mux_api_set(GPIO4C3_SMCDATA3_TRACEDATA3_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC4:
-        {
-             rk30_mux_api_set(GPIO4C4_SMCDATA4_TRACEDATA4_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC5:
-        {
-             rk30_mux_api_set(GPIO4C5_SMCDATA5_TRACEDATA5_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC6:
-        {
-             rk30_mux_api_set(GPIO4C6_SMCDATA6_TRACEDATA6_NAME,0);
-            break;	
-        }
-
-
-        case RK30_PIN4_PC7:
-        {
-             rk30_mux_api_set(GPIO4C7_SMCDATA7_TRACEDATA7_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PD0:
-	{
-		 rk30_mux_api_set(GPIO4D0_SMCDATA8_TRACEDATA8_NAME,0);			   
-		break;	
-	}
-        case RK30_PIN4_PD1:
-        {
-             rk30_mux_api_set(GPIO4D1_SMCDATA9_TRACEDATA9_NAME,0);             
-            break;	
-        }
-        case RK30_PIN4_PD2:
-	{
-		 rk30_mux_api_set(GPIO4D2_SMCDATA10_TRACEDATA10_NAME,0);			   
-		break;	
-	}
-        case RK30_PIN4_PD3:
-        {
-             rk30_mux_api_set(GPIO4D3_SMCDATA11_TRACEDATA11_NAME,0);           
-            break;	
-        }
-        case RK30_PIN4_PD4:
-        {
-             rk30_mux_api_set(GPIO4D4_SMCDATA12_TRACEDATA12_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PD5:
-        {
-             rk30_mux_api_set(GPIO4D5_SMCDATA13_TRACEDATA13_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PD6:
-        {
-             rk30_mux_api_set(GPIO4D6_SMCDATA14_TRACEDATA14_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PD7:
-        {
-             rk30_mux_api_set(GPIO4D7_SMCDATA15_TRACEDATA15_NAME,0);
-            break;	
-        } 
-        case RK30_PIN6_PA0:
-        case RK30_PIN6_PA1:
-        case RK30_PIN6_PA2:
-        case RK30_PIN6_PA3:
-        case RK30_PIN6_PA4:
-        case RK30_PIN6_PA5:
-        case RK30_PIN6_PA6:
-        case RK30_PIN6_PA7:
-        case RK30_PIN6_PB0:
-        case RK30_PIN6_PB1:
-        case RK30_PIN6_PB2:
-        case RK30_PIN6_PB3:
-        case RK30_PIN6_PB4:
-        case RK30_PIN6_PB5:
-        case RK30_PIN6_PB6:
-			break;
-        case RK30_PIN6_PB7:
-		{
-			 rk30_mux_api_set(GPIO6B7_TESTCLOCKOUT_NAME,0);
-			break;	
-		} 
-        default:
-        {
-            printk("Pin=%d isn't RK GPIO, Please init it's iomux yourself!",pin);
-            break;
-        }
-    }
-    return 0;
-}
-
-static int sensor_power_default_cb (struct rkcamera_gpio_res *res, int on)
-{
-    int camera_power = res->gpio_power;
-    int camera_ioflag = res->gpio_flag;
-    int camera_io_init = res->gpio_init;
-    int ret = 0;
-    
-    if (camera_power != INVALID_GPIO)  {
-		     if (camera_io_init & RK_CAM_POWERACTIVE_MASK) {
-            if (on) {
-            	gpio_set_value(camera_power, ((camera_ioflag&RK_CAM_POWERACTIVE_MASK)>>RK_CAM_POWERACTIVE_BITPOS));
-    			dprintk("%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_power, ((camera_ioflag&RK_CAM_POWERACTIVE_MASK)>>RK_CAM_POWERACTIVE_BITPOS));
-    			msleep(10);
-    		} else {
-    			gpio_set_value(camera_power, (((~camera_ioflag)&RK_CAM_POWERACTIVE_MASK)>>RK_CAM_POWERACTIVE_BITPOS));
-    			dprintk("%s..%s..PowerPin=%d ..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_power, (((~camera_ioflag)&RK_CAM_POWERACTIVE_MASK)>>RK_CAM_POWERACTIVE_BITPOS));
-    		}
-		} else {
-			ret = RK_CAM_EIO_REQUESTFAIL;
-			printk("%s..%s..PowerPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_power);
-	    }        
-    } else {
-		ret = RK_CAM_EIO_INVALID;
-    } 
-
-    return ret;
-}
-
-static int sensor_reset_default_cb (struct rkcamera_gpio_res *res, int on)
-{
-    int camera_reset = res->gpio_reset;
-    int camera_ioflag = res->gpio_flag;
-    int camera_io_init = res->gpio_init;  
-    int ret = 0;
-    
-    if (camera_reset != INVALID_GPIO) {
-		if (camera_io_init & RK_CAM_RESETACTIVE_MASK) {
-			if (on) {
-	        	gpio_set_value(camera_reset, ((camera_ioflag&RK_CAM_RESETACTIVE_MASK)>>RK_CAM_RESETACTIVE_BITPOS));
-	        	dprintk("%s..%s..ResetPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_reset, ((camera_ioflag&RK_CAM_RESETACTIVE_MASK)>>RK_CAM_RESETACTIVE_BITPOS));
-			} else {
-				gpio_set_value(camera_reset,(((~camera_ioflag)&RK_CAM_RESETACTIVE_MASK)>>RK_CAM_RESETACTIVE_BITPOS));
-        		dprintk("%s..%s..ResetPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_reset, (((~camera_ioflag)&RK_CAM_RESETACTIVE_MASK)>>RK_CAM_RESETACTIVE_BITPOS));
-	        }
-		} else {
-			ret = RK_CAM_EIO_REQUESTFAIL;
-			printk("%s..%s..ResetPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_reset);
-		}
-    } else {
-		ret = RK_CAM_EIO_INVALID;
-    }
-
-    return ret;
-}
-
-static int sensor_powerdown_default_cb (struct rkcamera_gpio_res *res, int on)
-{
-    int camera_powerdown = res->gpio_powerdown;
-    int camera_ioflag = res->gpio_flag;
-    int camera_io_init = res->gpio_init;  
-    int ret = 0;    
-
-    if (camera_powerdown != INVALID_GPIO) {
-		if (camera_io_init & RK_CAM_POWERDNACTIVE_MASK) {
-			if (on) {
-	        	gpio_set_value(camera_powerdown, ((camera_ioflag&RK_CAM_POWERDNACTIVE_MASK)>>RK_CAM_POWERDNACTIVE_BITPOS));
-	        	dprintk("%s..%s..PowerDownPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_powerdown, ((camera_ioflag&RK_CAM_POWERDNACTIVE_MASK)>>RK_CAM_POWERDNACTIVE_BITPOS));
-			} else {
-				gpio_set_value(camera_powerdown,(((~camera_ioflag)&RK_CAM_POWERDNACTIVE_MASK)>>RK_CAM_POWERDNACTIVE_BITPOS));
-        		dprintk("%s..%s..PowerDownPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_powerdown, (((~camera_ioflag)&RK_CAM_POWERDNACTIVE_MASK)>>RK_CAM_POWERDNACTIVE_BITPOS));
-	        }
-		} else {
-			ret = RK_CAM_EIO_REQUESTFAIL;
-			dprintk("%s..%s..PowerDownPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_powerdown);
-		}
-    } else {
-		ret = RK_CAM_EIO_INVALID;
-    }
-    return ret;
-}
-
-
-static int sensor_flash_default_cb (struct rkcamera_gpio_res *res, int on)
-{
-    int camera_flash = res->gpio_flash;
-    int camera_ioflag = res->gpio_flag;
-    int camera_io_init = res->gpio_init;  
-    int ret = 0;    
-
-    if (camera_flash != INVALID_GPIO) {
-		if (camera_io_init & RK_CAM_FLASHACTIVE_MASK) {
-            switch (on)
-            {
-                case Flash_Off:
-                {
-                    gpio_set_value(camera_flash,(((~camera_ioflag)&RK_CAM_FLASHACTIVE_MASK)>>RK_CAM_FLASHACTIVE_BITPOS));
-        		    dprintk("\n%s..%s..FlashPin= %d..PinLevel = %x   \n",__FUNCTION__,res->dev_name, camera_flash, (((~camera_ioflag)&RK_CAM_FLASHACTIVE_MASK)>>RK_CAM_FLASHACTIVE_BITPOS)); 
-        		    break;
-                }
-
-                case Flash_On:
-                {
-                    gpio_set_value(camera_flash, ((camera_ioflag&RK_CAM_FLASHACTIVE_MASK)>>RK_CAM_FLASHACTIVE_BITPOS));
-	        	    dprintk("%s..%s..FlashPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_flash, ((camera_ioflag&RK_CAM_FLASHACTIVE_MASK)>>RK_CAM_FLASHACTIVE_BITPOS));
-	        	    break;
-                }
-
-                case Flash_Torch:
-                {
-                    gpio_set_value(camera_flash, ((camera_ioflag&RK_CAM_FLASHACTIVE_MASK)>>RK_CAM_FLASHACTIVE_BITPOS));
-	        	    dprintk("%s..%s..FlashPin=%d ..PinLevel = %x \n",__FUNCTION__,res->dev_name,camera_flash, ((camera_ioflag&RK_CAM_FLASHACTIVE_MASK)>>RK_CAM_FLASHACTIVE_BITPOS));
-	        	    break;
-                }
-
-                default:
-                {
-                    printk("%s..%s..Flash command(%d) is invalidate \n",__FUNCTION__,res->dev_name,on);
-                    break;
-                }
-            }
-		} else {
-			ret = RK_CAM_EIO_REQUESTFAIL;
-			printk("%s..%s..FlashPin=%d request failed!\n",__FUNCTION__,res->dev_name,camera_flash);
-		}
-    } else {
-		ret = RK_CAM_EIO_INVALID;
-    }
-    return ret;
-}
-
-
-static int rk_sensor_io_init(int hostid)
-{
-    int ret = 0, i,j;
-    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
-	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO;
-	unsigned int camera_ioflag;
-	struct rkcamera_platform_data* plat_data = NULL;
-//	int bus_id = (soc_camera_link*)dev->platform_data->bus_id;
-    if (sensor_ioctl_cb.sensor_power_cb == NULL)
-        sensor_ioctl_cb.sensor_power_cb = sensor_power_default_cb;
-    if (sensor_ioctl_cb.sensor_reset_cb == NULL)
-        sensor_ioctl_cb.sensor_reset_cb = sensor_reset_default_cb;
-    if (sensor_ioctl_cb.sensor_powerdown_cb == NULL)
-        sensor_ioctl_cb.sensor_powerdown_cb = sensor_powerdown_default_cb;
-    if (sensor_ioctl_cb.sensor_flash_cb == NULL)
-        sensor_ioctl_cb.sensor_flash_cb = sensor_flash_default_cb;
-    if(hostid == rk_device_camera_host_0.id)
-		plat_data = &rk_camera_platform_data_host_0;
-    else if(hostid == rk_device_camera_host_1.id)
-		plat_data = &rk_camera_platform_data_host_0;
-    else
-		return -1;
-	for(i = 0;i < RK_CAM_NUM_PER_HOST ; i++){
-		camera_reset = plat_data->gpio_res[i].gpio_reset;
-		camera_power = plat_data->gpio_res[i].gpio_power;
-		camera_powerdown = plat_data->gpio_res[i].gpio_powerdown;
-		camera_flash = plat_data->gpio_res[i].gpio_flash;
-		camera_ioflag = plat_data->gpio_res[i].gpio_flag;
-		plat_data->gpio_res[i].gpio_init = 0;
-
-        if (camera_power != INVALID_GPIO) {
-            ret = gpio_request(camera_power, "camera power");
-            if (ret) {
-                if (i == 0) {
-                    printk("%s..%s..power pin(%d) init failed\n",__FUNCTION__,plat_data->gpio_res[i].dev_name,camera_power);
-				    goto sensor_io_init_erro;
-                } else {
-                    if (camera_power != plat_data->gpio_res[i].gpio_power) {
-                        printk("%s..%s..power pin(%d) init failed\n",__FUNCTION__,plat_data->gpio_res[i].dev_name,camera_power);
-                        goto sensor_io_init_erro;
-                    }
-                }
-            }
-
-            if (rk_sensor_iomux(camera_power) < 0) {
-                printk(KERN_ERR "%s..%s..power pin(%d) iomux init failed\n",__FUNCTION__,plat_data->gpio_res[i].dev_name,camera_power);
-                goto sensor_io_init_erro;
-            }
-            
-			plat_data->gpio_res[i].gpio_init |= RK_CAM_POWERACTIVE_MASK;
-            gpio_set_value(camera_reset, (((~camera_ioflag)&RK_CAM_POWERACTIVE_MASK)>>RK_CAM_POWERACTIVE_BITPOS));
-            gpio_direction_output(camera_power, (((~camera_ioflag)&RK_CAM_POWERACTIVE_MASK)>>RK_CAM_POWERACTIVE_BITPOS));
-
-			dprintk("%s....power pin(%d) init success(0x%x)  \n",__FUNCTION__,camera_power,(((~camera_ioflag)&RK_CAM_POWERACTIVE_MASK)>>RK_CAM_POWERACTIVE_BITPOS));
-
-        }
-
-        if (camera_reset != INVALID_GPIO) {
-            ret = gpio_request(camera_reset, "camera reset");
-            if (ret) {
-                printk("%s..%s..reset pin(%d) init failed\n",__FUNCTION__,plat_data->gpio_res[i].dev_name,camera_reset);
-                goto sensor_io_init_erro;
-            }
-
-            if (rk_sensor_iomux(camera_reset) < 0) {
-                printk(KERN_ERR "%s..%s..reset pin(%d) iomux init failed\n",__FUNCTION__,plat_data->gpio_res[i].dev_name,camera_reset);
-                goto sensor_io_init_erro;
-            }
-            
-			plat_data->gpio_res[i].gpio_init |= RK_CAM_RESETACTIVE_MASK;
-            gpio_set_value(camera_reset, ((camera_ioflag&RK_CAM_RESETACTIVE_MASK)>>RK_CAM_RESETACTIVE_BITPOS));
-            gpio_direction_output(camera_reset, ((camera_ioflag&RK_CAM_RESETACTIVE_MASK)>>RK_CAM_RESETACTIVE_BITPOS));
-
-			dprintk("%s....reset pin(%d) init success(0x%x)\n",__FUNCTION__,camera_reset,((camera_ioflag&RK_CAM_RESETACTIVE_MASK)>>RK_CAM_RESETACTIVE_BITPOS));
-
-        }
-
-		if (camera_powerdown != INVALID_GPIO) {
-            ret = gpio_request(camera_powerdown, "camera powerdown");
-            if (ret) {
-                printk("%s..%s..powerdown pin(%d) init failed\n",__FUNCTION__,plat_data->gpio_res[i].dev_name,camera_powerdown);
-                goto sensor_io_init_erro;
-            }
-
-            if (rk_sensor_iomux(camera_powerdown) < 0) {
-                printk(KERN_ERR "%s..%s..powerdown pin(%d) iomux init failed\n",__FUNCTION__,plat_data->gpio_res[i].dev_name,camera_powerdown);
-                goto sensor_io_init_erro;
-            }
-            
-			plat_data->gpio_res[i].gpio_init |= RK_CAM_POWERDNACTIVE_MASK;
-            gpio_set_value(camera_powerdown, ((camera_ioflag&RK_CAM_POWERDNACTIVE_MASK)>>RK_CAM_POWERDNACTIVE_BITPOS));
-            gpio_direction_output(camera_powerdown, ((camera_ioflag&RK_CAM_POWERDNACTIVE_MASK)>>RK_CAM_POWERDNACTIVE_BITPOS));
-
-			dprintk("%s....powerdown pin(%d) init success(0x%x) \n",__FUNCTION__,camera_powerdown,((camera_ioflag&RK_CAM_POWERDNACTIVE_BITPOS)>>RK_CAM_POWERDNACTIVE_BITPOS));
-
-        }
-
-		if (camera_flash != INVALID_GPIO) {
-            ret = gpio_request(camera_flash, "camera flash");
-            if (ret) {
-                printk("%s..%s..flash pin(%d) init failed\n",__FUNCTION__,plat_data->gpio_res[i].dev_name,camera_flash);
-				goto sensor_io_init_erro;
-            }
-
-            if (rk_sensor_iomux(camera_flash) < 0) {
-                printk(KERN_ERR "%s..%s..flash pin(%d) iomux init failed\n",__FUNCTION__,plat_data->gpio_res[i].dev_name,camera_flash);                
-            }
-            
-			plat_data->gpio_res[i].gpio_init |= RK_CAM_FLASHACTIVE_MASK;
-            gpio_set_value(camera_flash, ((~camera_ioflag&RK_CAM_FLASHACTIVE_MASK)>>RK_CAM_FLASHACTIVE_BITPOS));    /* falsh off */
-            gpio_direction_output(camera_flash, ((~camera_ioflag&RK_CAM_FLASHACTIVE_MASK)>>RK_CAM_FLASHACTIVE_BITPOS));
-
-			dprintk("%s....flash pin(%d) init success(0x%x) \n",__FUNCTION__,camera_flash,((camera_ioflag&RK_CAM_FLASHACTIVE_MASK)>>RK_CAM_FLASHACTIVE_BITPOS));
-
-        }  
-
-        
-        for (j=0; j<10; j++) {
-            memset(&plat_data->info[i].fival[j],0x00,sizeof(struct v4l2_frmivalenum));
-        }
-        j=0;
-        if (plat_data->info[i].dev_name && strstr(plat_data->info[i].dev_name,"_back")) {
-            
-            #if CONFIG_SENSOR_QCIF_FPS_FIXED_0
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QCIF_FPS_FIXED_0;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 176;
-            plat_data->info[i].fival[j].height = 144;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_QVGA_FPS_FIXED_0
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QVGA_FPS_FIXED_0;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 320;
-            plat_data->info[i].fival[j].height = 240;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_CIF_FPS_FIXED_0
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_CIF_FPS_FIXED_0;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 352;
-            plat_data->info[i].fival[j].height = 288;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_VGA_FPS_FIXED_0
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_VGA_FPS_FIXED_0;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 640;
-            plat_data->info[i].fival[j].height = 480;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_480P_FPS_FIXED_0
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_480P_FPS_FIXED_0;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 720;
-            plat_data->info[i].fival[j].height = 480;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif            
-
-            #if CONFIG_SENSOR_SVGA_FPS_FIXED_0
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_SVGA_FPS_FIXED_0;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 800;
-            plat_data->info[i].fival[j].height = 600;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_720P_FPS_FIXED_0
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_720P_FPS_FIXED_0;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 1280;
-            plat_data->info[i].fival[j].height = 720;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-        } else {
-            #if CONFIG_SENSOR_QCIF_FPS_FIXED_1
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QCIF_FPS_FIXED_1;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 176;
-            plat_data->info[i].fival[j].height = 144;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_QVGA_FPS_FIXED_1
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_QVGA_FPS_FIXED_1;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 320;
-            plat_data->info[i].fival[j].height = 240;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_CIF_FPS_FIXED_1
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_CIF_FPS_FIXED_1;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 352;
-            plat_data->info[i].fival[j].height = 288;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_VGA_FPS_FIXED_1
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_VGA_FPS_FIXED_1;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 640;
-            plat_data->info[i].fival[j].height = 480;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_480P_FPS_FIXED_1
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_480P_FPS_FIXED_1;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 720;
-            plat_data->info[i].fival[j].height = 480;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif 
-
-            #if CONFIG_SENSOR_SVGA_FPS_FIXED_1
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_SVGA_FPS_FIXED_1;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 800;
-            plat_data->info[i].fival[j].height = 600;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-
-            #if CONFIG_SENSOR_720P_FPS_FIXED_1
-            plat_data->info[i].fival[j].discrete.denominator = CONFIG_SENSOR_720P_FPS_FIXED_1;
-            plat_data->info[i].fival[j].discrete.numerator= 1;
-            plat_data->info[i].fival[j].index = 0;
-            plat_data->info[i].fival[j].pixel_format = V4L2_PIX_FMT_NV12;
-            plat_data->info[i].fival[j].width = 1280;
-            plat_data->info[i].fival[j].height = 720;
-            plat_data->info[i].fival[j].type = V4L2_FRMIVAL_TYPE_DISCRETE;
-            j++;
-            #endif
-        }
-	continue;
-	sensor_io_init_erro:
-		rk_sensor_io_deinit(hostid);
-	}
-	return 0;
-}
-
-static int rk_sensor_io_deinit(int hostid)
-{
-    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
-	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO;
-	struct rkcamera_platform_data* plat_data = NULL;
-	int i = 0;
-	//int bus_id = (soc_camera_link*)dev->platform_data->bus_id;
-	if(hostid == rk_device_camera_host_0.id)
-		plat_data = &rk_camera_platform_data_host_0;
-	else if(hostid == rk_device_camera_host_1.id)
-		plat_data = &rk_camera_platform_data_host_0;
-	else
-		return -1;
-for(i = 0;i < RK_CAM_NUM_PER_HOST ; i++){
-    camera_reset = plat_data->gpio_res[i].gpio_reset;
-    camera_power = plat_data->gpio_res[i].gpio_power;
-	camera_powerdown = plat_data->gpio_res[i].gpio_powerdown;
-    camera_flash = plat_data->gpio_res[i].gpio_flash;
-
-    printk("%s..%s enter..\n",__FUNCTION__,plat_data->gpio_res[i].dev_name);
-
-	if (plat_data->gpio_res[i].gpio_init & RK_CAM_POWERACTIVE_MASK) {
-	    if (camera_power != INVALID_GPIO) {
-	        gpio_direction_input(camera_power);
-	        gpio_free(camera_power);
-	    }
-	}
-
-	if (plat_data->gpio_res[i].gpio_init & RK_CAM_RESETACTIVE_MASK) {
-	    if (camera_reset != INVALID_GPIO)  {
-	        gpio_direction_input(camera_reset);
-	        gpio_free(camera_reset);
-	    }
-	}
-
-	if (plat_data->gpio_res[i].gpio_init & RK_CAM_POWERDNACTIVE_MASK) {
-	    if (camera_powerdown != INVALID_GPIO)  {
-	        gpio_direction_input(camera_powerdown);
-	        gpio_free(camera_powerdown);
-	    }
-	}
-
-	if (plat_data->gpio_res[i].gpio_init & RK_CAM_FLASHACTIVE_MASK) {
-	    if (camera_flash != INVALID_GPIO)  {
-	        gpio_direction_input(camera_flash);
-	        gpio_free(camera_flash);
-	    }
-	}
-	plat_data->gpio_res[i].gpio_init = 0;
-	
-	}
-    return 0;
-}
-static int rk_sensor_ioctrl(struct device *dev,enum rkcamera_ioctrl_cmd cmd, int on)
-{
-    struct rkcamera_gpio_res *res = NULL;    
-	int ret = RK_CAM_IO_SUCCESS,i = 0;
-
-	struct rkcamera_platform_data* plat_data = NULL;
-	int bus_id =  ((struct soc_camera_link*)(dev->platform_data))->bus_id;
-	if(bus_id == rk_device_camera_host_0.id)
-		plat_data = &rk_camera_platform_data_host_0;
-	else if(bus_id == rk_device_camera_host_1.id)
-		plat_data = &rk_camera_platform_data_host_0;
-	else
-		return -1;
-	//for test reg
-	for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-		if(plat_data->gpio_res[i].dev_name &&  (strcmp(plat_data->gpio_res[i].dev_name, dev_name(dev)) == 0)) {
-				res = (struct rkcamera_gpio_res *)&plat_data->gpio_res[i];
-				break;
-		    } 
-		} 
-     if(i == RK_CAM_NUM_PER_HOST){
-		ret = RK_CAM_EIO_INVALID;
-		goto rk_sensor_ioctrl_end;
-     	}
-	
-	switch (cmd)
- 	{
- 		case Cam_Power:
-		{
-			if (sensor_ioctl_cb.sensor_power_cb) {
-                ret = sensor_ioctl_cb.sensor_power_cb(res, on);
-			} else {
-                printk(KERN_ERR "sensor_ioctl_cb.sensor_power_cb is NULL");
-                WARN_ON(1);
-			}
-			break;
-		}
-		case Cam_Reset:
-		{
-			if (sensor_ioctl_cb.sensor_reset_cb) {
-                ret = sensor_ioctl_cb.sensor_reset_cb(res, on);
-			} else {
-                printk(KERN_ERR "sensor_ioctl_cb.sensor_reset_cb is NULL");
-                WARN_ON(1);
-			}
-			break;
-		}
-
-		case Cam_PowerDown:
-		{
-			if (sensor_ioctl_cb.sensor_powerdown_cb) {
-                ret = sensor_ioctl_cb.sensor_powerdown_cb(res, on);
-			} else {
-                printk(KERN_ERR "sensor_ioctl_cb.sensor_powerdown_cb is NULL");
-                WARN_ON(1);
-			}
-			break;
-		}
-
-		case Cam_Flash:
-		{
-			if (sensor_ioctl_cb.sensor_flash_cb) {
-                ret = sensor_ioctl_cb.sensor_flash_cb(res, on);
-			} else {
-                printk(KERN_ERR "sensor_ioctl_cb.sensor_flash_cb is NULL!");
-                WARN_ON(1);
-			}
-			break;
-		}
-		default:
-		{
-			printk("%s cmd(0x%x) is unknown!\n",__FUNCTION__, cmd);
-			break;
-		}
- 	}
-rk_sensor_ioctrl_end:
-    return ret;
-}
-static int rk_sensor_power(struct device *dev, int on)
-{
-	rk_sensor_ioctrl(dev,Cam_Power,on);
-    return 0;
-}
-#if (CONFIG_SENSOR_RESET_PIN_0 != INVALID_GPIO) || (CONFIG_SENSOR_RESET_PIN_1 != INVALID_GPIO)
-static int rk_sensor_reset(struct device *dev)
-{
-	rk_sensor_ioctrl(dev,Cam_Reset,1);
-	msleep(2);
-	rk_sensor_ioctrl(dev,Cam_Reset,0);
-	return 0;
-}
-#endif
-static int rk_sensor_powerdown(struct device *dev, int on)
-{
-	return rk_sensor_ioctrl(dev,Cam_PowerDown,on);
-}
-
-static struct android_pmem_platform_data android_pmem_cam_pdata = {
-	.name		= "pmem_cam",
-	//.start		= PMEM_CAM_BASE,
-	.size		= 0,
-	.no_allocator	= 1,
-	.cached		= 1,
-};
-
- struct platform_device android_pmem_cam_device = {
-	.name		= "android_pmem",
-	.id		= 1,
-	.dev		= {
-		.platform_data = &android_pmem_cam_pdata,
-	},
-};
-
-void rk_register_camera_devices()
-{
-	rk_init_camera_plateform_data();
-#if CONFIG_USE_CIF_0
-	platform_device_register(&rk_device_camera_host_0);
-#endif
-#if CONFIG_USE_CIF_1
-	platform_device_register(&rk_device_camera_host_1);
-#endif
-	if(rk_soc_camera_pdrv_0.name)
-		platform_device_register(&rk_soc_camera_pdrv_0);
-	if(rk_soc_camera_pdrv_1.name)
-		platform_device_register(&rk_soc_camera_pdrv_1);
-	if(((struct android_pmem_platform_data*)(android_pmem_cam_device.dev.platform_data))->size)
-		platform_device_register(&android_pmem_cam_device);
-}
-#endif
-
-#endif //#ifdef CONFIG_VIDEO_RK
diff --git a/drivers/media/video/s5k6aa.c b/drivers/media/video/s5k6aa.c
index 775376242eb2..cfe412a1733d 100644
--- a/drivers/media/video/s5k6aa.c
+++ b/drivers/media/video/s5k6aa.c
@@ -19,8 +19,7 @@
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
 #include <linux/delay.h>
 #include "s5k6aa.h"
 static int debug;
@@ -45,7 +44,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_S5K6AA
+#define SENSOR_NAME RK29_CAM_SENSOR_S5K6AA
 #define SENSOR_V4L2_IDENT V4L2_IDENT_S5K66A 
 #define SENSOR_ID 0x06aa
 #define SENSOR_ID_REG SEQUENCE_END//0x015a
@@ -55,11 +54,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_MIN_HEIGHT   480
 #define SENSOR_MAX_WIDTH    1280
 #define SENSOR_MAX_HEIGHT   1024
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	0
 #define CONFIG_SENSOR_Brightness	0
@@ -81,6 +79,11 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_HIGH |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -107,14 +110,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_AF_MODE_CLOSE       5
 #endif
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 640X480 SVGA */
 static struct reginfo sensor_init_data[] =
 {
 	{0x0010,0x0001}, 	// Reset
@@ -3025,8 +3021,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -3264,7 +3260,7 @@ static int sensor_af_init(struct i2c_client *client)
 }
 #endif
 
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
@@ -3284,13 +3280,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -3322,63 +3318,9 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-    char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret;
+    u16 pid = 0;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	sensor_ioctrl(icd,Sensor_Reset, 1);
@@ -3426,7 +3368,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -4656,24 +4598,24 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
diff --git a/drivers/media/video/sid130B.c b/drivers/media/video/sid130B.c
old mode 100644
new mode 100755
index f086e8e6b404..ef1f427615a2
--- a/drivers/media/video/sid130B.c
+++ b/drivers/media/video/sid130B.c
@@ -19,8 +19,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -50,11 +50,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_MIN_HEIGHT   144
 #define SENSOR_MAX_WIDTH    1600
 #define SENSOR_MAX_HEIGHT   1200
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance 1
 #define CONFIG_SENSOR_Brightness	0
@@ -74,6 +73,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW|\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -86,9 +89,9 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
 #define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)
 
-#define SENSOR_AF_IS_ERR    (0x00<<0)
-#define SENSOR_AF_IS_OK		(0x01<<0)
-#define SENSOR_INIT_IS_ERR   (0x00<<28)
+#define SENSOR_AF_IS_ERR    (0x00<<0)
+#define SENSOR_AF_IS_OK		(0x01<<0)
+#define SENSOR_INIT_IS_ERR   (0x00<<28)
 #define SENSOR_INIT_IS_OK    (0x01<<28)
 
 struct reginfo
@@ -97,14 +100,7 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
-/* init 800*600 SVGA */
+/* init 352X288 SVGA */
 static struct reginfo sensor_init_data[] =
 {
        {0x00,  0x00},  
@@ -1397,28 +1393,28 @@ static struct soc_camera_ops sensor_ops =
     .num_menus		= ARRAY_SIZE(sensor_menus),
 };
 
-/* only one fixed colorspace per pixelcode */
-struct sensor_datafmt {
-	enum v4l2_mbus_pixelcode code;
-	enum v4l2_colorspace colorspace;
-};
-
-/* Find a data format by a pixel code in an array */
-static const struct sensor_datafmt *sensor_find_datafmt(
-	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
-	int n)
-{
-	int i;
-	for (i = 0; i < n; i++)
-		if (fmt[i].code == code)
-			return fmt + i;
-
-	return NULL;
-}
-
-static const struct sensor_datafmt sensor_colour_fmts[] = {
-    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
-    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
+/* only one fixed colorspace per pixelcode */
+struct sensor_datafmt {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+};
+
+/* Find a data format by a pixel code in an array */
+static const struct sensor_datafmt *sensor_find_datafmt(
+	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
+	int n)
+{
+	int i;
+	for (i = 0; i < n; i++)
+		if (fmt[i].code == code)
+			return fmt + i;
+
+	return NULL;
+}
+
+static const struct sensor_datafmt sensor_colour_fmts[] = {
+    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
+    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
 };
 
 typedef struct sensor_info_priv_s
@@ -1451,8 +1447,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1634,7 +1630,7 @@ static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regar
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1646,13 +1642,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1685,63 +1681,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-    char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
      if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1801,7 +1742,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
         goto sensor_INIT_ERR;
     }
 #endif
-    ret = sensor_write_array(client, sensor_init_data_p);
+    ret = sensor_write_array(client, sensor_init_data);
     if (ret != 0)
     {
         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
@@ -1810,11 +1751,11 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     sensor_task_lock(client,0);
     sensor->info_priv.winseqe_cur_addr  = (int)SENSOR_INIT_WINSEQADR;
     fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
-    if (!fmt) {
-        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
-        ret = -EINVAL;
-        goto sensor_INIT_ERR;
-    }
+    if (!fmt) {
+        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
+        ret = -EINVAL;
+        goto sensor_INIT_ERR;
+    }
 	sensor->info_priv.fmt = *fmt;
 
     /* sensor sensor information for initialization  */
@@ -1955,55 +1896,55 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
     return soc_camera_apply_sensor_flags(icl, flags);
 }
 
-static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
+static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    struct sensor *sensor = to_sensor(client);
-
-    mf->width	= icd->user_width;
-	mf->height	= icd->user_height;
-	mf->code	= sensor->info_priv.fmt.code;
-	mf->colorspace	= sensor->info_priv.fmt.colorspace;
-	mf->field	= V4L2_FIELD_NONE;
-
-    return 0;
-}
-static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    bool ret = false;
-
-	if ((mf->width == 1024) && (mf->height == 768)) {
-		ret = true;
-	} else if ((mf->width == 1280) && (mf->height == 1024)) {
-		ret = true;
-	} else if ((mf->width == 1600) && (mf->height == 1200)) {
-		ret = true;
-	} else if ((mf->width == 2048) && (mf->height == 1536)) {
-		ret = true;
-	} else if ((mf->width == 2592) && (mf->height == 1944)) {
-		ret = true;
-	}
-
-	if (ret == true)
-		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
-	return ret;
-}
-
-static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    bool ret = false;
-
-	if ((mf->width == 1280) && (mf->height == 720)) {
-		ret = true;
-	} else if ((mf->width == 1920) && (mf->height == 1080)) {
-		ret = true;
-	}
-
-	if (ret == true)
-		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
-	return ret;
-}
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct sensor *sensor = to_sensor(client);
+
+    mf->width	= icd->user_width;
+	mf->height	= icd->user_height;
+	mf->code	= sensor->info_priv.fmt.code;
+	mf->colorspace	= sensor->info_priv.fmt.colorspace;
+	mf->field	= V4L2_FIELD_NONE;
+
+    return 0;
+}
+static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    bool ret = false;
+
+	if ((mf->width == 1024) && (mf->height == 768)) {
+		ret = true;
+	} else if ((mf->width == 1280) && (mf->height == 1024)) {
+		ret = true;
+	} else if ((mf->width == 1600) && (mf->height == 1200)) {
+		ret = true;
+	} else if ((mf->width == 2048) && (mf->height == 1536)) {
+		ret = true;
+	} else if ((mf->width == 2592) && (mf->height == 1944)) {
+		ret = true;
+	}
+
+	if (ret == true)
+		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
+	return ret;
+}
+
+static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    bool ret = false;
+
+	if ((mf->width == 1280) && (mf->height == 720)) {
+		ret = true;
+	} else if ((mf->width == 1920) && (mf->height == 1080)) {
+		ret = true;
+	}
+
+	if (ret == true)
+		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
+	return ret;
+}
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
     struct i2c_client *client = v4l2_get_subdevdata(sd);
@@ -2014,40 +1955,40 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     struct reginfo *winseqe_set_addr=NULL;
     int ret=0, set_w,set_h;
 
-	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
-				   ARRAY_SIZE(sensor_colour_fmts));
-	if (!fmt) {
-        ret = -EINVAL;
-        goto sensor_s_fmt_end;
-    }
-
-	if (sensor->info_priv.fmt.code != mf->code) {
-		switch (mf->code)
-		{
-			case V4L2_MBUS_FMT_YUYV8_2X8:
-			{
-				winseqe_set_addr = sensor_ClrFmt_YUYV;
-				break;
-			}
-			case V4L2_MBUS_FMT_UYVY8_2X8:
-			{
-				winseqe_set_addr = sensor_ClrFmt_UYVY;
-				break;
-			}
-			default:
-				break;
-		}
-		if (winseqe_set_addr != NULL) {
-            sensor_write_array(client, winseqe_set_addr);
-			sensor->info_priv.fmt.code = mf->code;
-            sensor->info_priv.fmt.colorspace= mf->colorspace;            
-			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
-		} else {
-			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
-		}
-	}
-
-    set_w = mf->width;
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (!fmt) {
+        ret = -EINVAL;
+        goto sensor_s_fmt_end;
+    }
+
+	if (sensor->info_priv.fmt.code != mf->code) {
+		switch (mf->code)
+		{
+			case V4L2_MBUS_FMT_YUYV8_2X8:
+			{
+				winseqe_set_addr = sensor_ClrFmt_YUYV;
+				break;
+			}
+			case V4L2_MBUS_FMT_UYVY8_2X8:
+			{
+				winseqe_set_addr = sensor_ClrFmt_UYVY;
+				break;
+			}
+			default:
+				break;
+		}
+		if (winseqe_set_addr != NULL) {
+            sensor_write_array(client, winseqe_set_addr);
+			sensor->info_priv.fmt.code = mf->code;
+            sensor->info_priv.fmt.colorspace= mf->colorspace;            
+			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
+		} else {
+			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
+		}
+	}
+
+    set_w = mf->width;
     set_h = mf->height;
 
 	if (((set_w <= 176) && (set_h <= 144)) &&( sensor_qcif[0].reg!=0xff))
@@ -2184,33 +2125,33 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
     return ret;
 }
 
-static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
+static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
     struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct sensor *sensor = to_sensor(client);
-    const struct sensor_datafmt *fmt;
-    int ret = 0;
-   
-	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
-				   ARRAY_SIZE(sensor_colour_fmts));
-	if (fmt == NULL) {
-		fmt = &sensor->info_priv.fmt;
-        mf->code = fmt->code;
-	} 
-
-    if (mf->height > SENSOR_MAX_HEIGHT)
-        mf->height = SENSOR_MAX_HEIGHT;
-    else if (mf->height < SENSOR_MIN_HEIGHT)
-        mf->height = SENSOR_MIN_HEIGHT;
-
-    if (mf->width > SENSOR_MAX_WIDTH)
-        mf->width = SENSOR_MAX_WIDTH;
-    else if (mf->width < SENSOR_MIN_WIDTH)
-        mf->width = SENSOR_MIN_WIDTH;
-
-    mf->colorspace = fmt->colorspace;
-    
-    return ret;
+    struct sensor *sensor = to_sensor(client);
+    const struct sensor_datafmt *fmt;
+    int ret = 0;
+   
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (fmt == NULL) {
+		fmt = &sensor->info_priv.fmt;
+        mf->code = fmt->code;
+	} 
+
+    if (mf->height > SENSOR_MAX_HEIGHT)
+        mf->height = SENSOR_MAX_HEIGHT;
+    else if (mf->height < SENSOR_MIN_HEIGHT)
+        mf->height = SENSOR_MIN_HEIGHT;
+
+    if (mf->width > SENSOR_MAX_WIDTH)
+        mf->width = SENSOR_MAX_WIDTH;
+    else if (mf->width < SENSOR_MIN_WIDTH)
+        mf->width = SENSOR_MIN_WIDTH;
+
+    mf->colorspace = fmt->colorspace;
+    
+    return ret;
 }
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
@@ -2970,25 +2911,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
@@ -3019,14 +2960,14 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	return ret;
 
 }
-static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
-			    enum v4l2_mbus_pixelcode *code)
-{
-	if (index >= ARRAY_SIZE(sensor_colour_fmts))
-		return -EINVAL;
-
-	*code = sensor_colour_fmts[index].code;
-	return 0;
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			    enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(sensor_colour_fmts))
+		return -EINVAL;
+
+	*code = sensor_colour_fmts[index].code;
+	return 0;
 }
 static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
 	.init		= sensor_init,
@@ -3038,11 +2979,11 @@ static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
 	.ioctl = sensor_ioctl,
 };
 
-static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
-	.s_mbus_fmt	= sensor_s_fmt,
-	.g_mbus_fmt	= sensor_g_fmt,
-	.try_mbus_fmt	= sensor_try_fmt,
-	.enum_mbus_fmt	= sensor_enum_fmt,
+static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
+	.s_mbus_fmt	= sensor_s_fmt,
+	.g_mbus_fmt	= sensor_g_fmt,
+	.try_mbus_fmt	= sensor_try_fmt,
+	.enum_mbus_fmt	= sensor_enum_fmt,
 };
 
 static struct v4l2_subdev_ops sensor_subdev_ops = {
diff --git a/drivers/media/video/siv120b.c b/drivers/media/video/siv120b.c
old mode 100644
new mode 100755
index bea0597012ff..a300398eaad4
--- a/drivers/media/video/siv120b.c
+++ b/drivers/media/video/siv120b.c
@@ -20,8 +20,8 @@ o* Driver for MT9M001 CMOS Image Sensor from Micron
 #include <media/v4l2-common.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
-#include <mach/rk_camera.h>
-#include <linux/vmalloc.h>
+#include <mach/rk29_camera.h>
+
 static int debug;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
@@ -44,18 +44,17 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define MAX(x,y)    ((x>y) ? x: y)
 
 /* Sensor Driver Configuration */
-#define SENSOR_NAME RK_CAM_SENSOR_SIV120B
+#define SENSOR_NAME RK29_CAM_SENSOR_SIV120B
 #define SENSOR_V4L2_IDENT V4L2_IDENT_SIV120B
 #define SENSOR_ID 0x12
 #define SENSOR_MIN_WIDTH    640//176
 #define SENSOR_MIN_HEIGHT   480//144
 #define SENSOR_MAX_WIDTH    640
 #define SENSOR_MAX_HEIGHT   480
-#define SENSOR_INIT_WIDTH	sensor_init_width			/* Sensor pixel size for sensor_init_data array */
-#define SENSOR_INIT_HEIGHT  sensor_init_height
-#define SENSOR_INIT_WINSEQADR  sensor_init_winseq_p
-#define SENSOR_INIT_PIXFMT sensor_init_pixelcode
-#define SENSOR_BUS_PARAM  sensor_init_busparam
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	0
 #define CONFIG_SENSOR_Brightness	0
@@ -75,6 +74,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_I2C_NOSCHED   0
 #define CONFIG_SENSOR_I2C_RDWRCHK   0
 
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
 #define COLOR_TEMPERATURE_CLOUDY_DN  6500
 #define COLOR_TEMPERATURE_CLOUDY_UP    8000
 #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
@@ -97,13 +100,6 @@ struct reginfo
     u8 val;
 };
 
-static s32 sensor_init_width = 0;
-static s32 sensor_init_height = 0;
-static unsigned long sensor_init_busparam = (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ);
-static enum v4l2_mbus_pixelcode sensor_init_pixelcode = V4L2_MBUS_FMT_YUYV8_2X8;
-static struct reginfo* sensor_init_data_p = NULL;
-static struct reginfo* sensor_init_winseq_p = NULL;
-static struct reginfo* sensor_init_winseq_board = NULL;
 /* init 640X480 VGA */
 static struct reginfo sensor_init_data[] =
 {
@@ -1253,8 +1249,8 @@ struct sensor
 #if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_t tasklock_cnt;
 #endif
-	struct rkcamera_platform_data *sensor_io_request;
-    struct rkcamera_gpio_res *sensor_gpio_res;
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
 };
 
 static struct sensor* to_sensor(const struct i2c_client *client)
@@ -1417,7 +1413,7 @@ static int sensor_write_array(struct i2c_client *client, struct reginfo *regarra
     return 0;
 }
 #endif
-static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd cmd, int on)
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
 {
 	struct soc_camera_link *icl = to_soc_camera_link(icd);
 	int ret = 0;
@@ -1429,13 +1425,13 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rksensor_power_cmd c
 		{
 			if (icl->powerdown) {
 				ret = icl->powerdown(icd->pdev, on);
-				if (ret == RK_CAM_IO_SUCCESS) {
+				if (ret == RK29_CAM_IO_SUCCESS) {
 					if (on == 0) {
 						mdelay(2);
 						if (icl->reset)
 							icl->reset(icd->pdev);
 					}
-				} else if (ret == RK_CAM_EIO_REQUESTFAIL) {
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
 					ret = -ENODEV;
 					goto sensor_power_end;
 				}
@@ -1469,63 +1465,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-    char value;
-    int ret,pid = 0,i = 0,j=0;
-    struct rkcamera_platform_data* tmp_plat_data =(struct rkcamera_platform_data*)val;
-    sensor_init_data_p = sensor_init_data;
-	sensor_init_winseq_p = sensor_vga;
-	sensor_init_width = 640;
-	sensor_init_height = 480;
-	if (tmp_plat_data != NULL) { 
-		for(i = 0;i < RK_CAM_NUM_PER_HOST;i++){
-			if ((tmp_plat_data->sensor_init_data[i])&& tmp_plat_data->info[i].dev_name &&
-				(strcmp(tmp_plat_data->info[i].dev_name, dev_name(icd->pdev)) == 0))
-					break;
-			}
-		}
-	if(tmp_plat_data  && (i < RK_CAM_NUM_PER_HOST) && tmp_plat_data->sensor_init_data[i]){
-	//user has defined the init data
-		//init reg
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			for(j = 0;j< sizeof(sensor_init_data)/sizeof(struct reginfo);j++){
-				sensor_init_data[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].reg;
-				sensor_init_data[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data[j].val;
-				}
-			sensor_init_data_p = sensor_init_data;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data){
-			sensor_init_data_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_data);
-			}
-		//init winseq
-		if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq && (sizeof(struct reginfo) != sizeof(struct reginfo_t))){
-			int tmp_winseq_size = tmp_plat_data->sensor_init_data[i]->rk_sensor_winseq_size;
-			if(sensor_init_winseq_board)
-				{
-				vfree(sensor_init_winseq_board);
-				sensor_init_winseq_board = NULL;
-				}
-			sensor_init_winseq_board = (struct reginfo*)vmalloc(tmp_winseq_size);
-			if(!sensor_init_winseq_board)
-				SENSOR_TR("%s :vmalloc erro !",__FUNCTION__);
-			for(j = 0;j< tmp_winseq_size;j++){
-				sensor_init_winseq_board[j].reg = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].reg;
-				sensor_init_winseq_board[j].val = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq[j].val;
-				}
-			sensor_init_winseq_p = sensor_init_winseq_board;
-			}
-		else if(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq){
-			sensor_init_winseq_p = (struct reginfo*)(tmp_plat_data->sensor_init_data[i]->rk_sensor_init_winseq);
-			}
-		//init width,height,bus,pixelcode
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width != INVALID_VALUE)
-			sensor_init_width = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_width;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height != INVALID_VALUE)
-			sensor_init_height = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_height;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param != INVALID_VALUE)
-			sensor_init_busparam = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_bus_param;
-		if(tmp_plat_data->sensor_init_data[i] && tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode != INVALID_VALUE)
-			sensor_init_pixelcode = tmp_plat_data->sensor_init_data[i]->rk_sensor_init_pixelcode;
-	}
+    int ret, i;
+
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
@@ -1550,7 +1491,7 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 		
     //	ret = sensor_write(client, sensor_init_data + i*2, sensor_init_data + i*2 + 1);
     //	printk("write to reg[0x%x] 0x%x\n",sensor_init_data[i].reg,sensor_init_data[i].val);
-    	ret = sensor_write(client, sensor_init_data_p[i].reg, sensor_init_data_p[i].val);
+    	ret = sensor_write(client, sensor_init_data[i].reg, sensor_init_data[i].val);
     //ret = sensor_write_array(client, sensor_init_data);
     	if (ret != 0)
     	{
@@ -2658,25 +2599,25 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
 	switch (cmd)
 	{
-		case RK_CAM_SUBDEV_DEACTIVATE:
+		case RK29_CAM_SUBDEV_DEACTIVATE:
 		{
 			sensor_deactivate(client);
 			break;
 		}
 
-		case RK_CAM_SUBDEV_IOREQUEST:
+		case RK29_CAM_SUBDEV_IOREQUEST:
 		{
-			sensor->sensor_io_request = (struct rkcamera_platform_data*)arg;           
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
             if (sensor->sensor_io_request != NULL) { 
                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
-                    sensor->sensor_gpio_res = (struct rkcamera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
                 }
             } else {
-                SENSOR_TR("%s %s RK_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
                 ret = -EINVAL;
                 goto sensor_ioctl_end;
             }
-- 
2.35.3

