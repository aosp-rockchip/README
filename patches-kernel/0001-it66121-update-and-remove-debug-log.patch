From 1fd7e074d480f7ac38383fe2cf190967255ea58c Mon Sep 17 00:00:00 2001
From: yzq <yzq@rock-chips.com>
Date: Mon, 28 Jan 2013 10:44:54 +0800
Subject: [PATCH] it66121: update and remove debug log

---
 arch/arm/mach-rk3188/board-rk3188-ds1006h.c   |  33 +-
 arch/arm/plat-rk/include/plat/board.h         |   3 +
 .../rockchip/hdmi/chips/cat66121/Makefile     |   2 +
 .../hdmi/chips/cat66121/cat66121_hdmi.c       | 677 +++++++++---------
 .../hdmi/chips/cat66121/cat66121_hdmi.h       |  68 +-
 .../hdmi/chips/cat66121/cat66121_hdmi_hw.c    | 450 ++++++------
 .../hdmi/chips/cat66121/cat66121_sys.c        | 434 +++++------
 .../hdmi/chips/cat66121/cat66121_sys.h        | 328 ++++-----
 .../rockchip/hdmi/chips/cat66121/config.h     | 276 +++----
 drivers/video/rockchip/hdmi/rk_hdmi_task.c    |  20 +-
 10 files changed, 1153 insertions(+), 1138 deletions(-)

diff --git a/arch/arm/mach-rk3188/board-rk3188-ds1006h.c b/arch/arm/mach-rk3188/board-rk3188-ds1006h.c
index 938a2cc04121..8a66f4a82ce0 100755
--- a/arch/arm/mach-rk3188/board-rk3188-ds1006h.c
+++ b/arch/arm/mach-rk3188/board-rk3188-ds1006h.c
@@ -539,6 +539,30 @@ static struct rk610_codec_platform_data rk610_codec_pdata = {
 };
 #endif
 
+#ifdef CONFIG_RK_HDMI
+#define RK_HDMI_RST_PIN 			RK30_PIN3_PB2
+static int rk_hdmi_power_init(void)
+{
+	int ret;
+
+	if(RK_HDMI_RST_PIN != INVALID_GPIO)
+	{
+		if (gpio_request(RK_HDMI_RST_PIN, NULL)) {
+			printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
+			return -1;
+		}
+		gpio_direction_output(RK_HDMI_RST_PIN, GPIO_LOW);
+		gpio_set_value(RK_HDMI_RST_PIN, GPIO_LOW);
+		msleep(100);
+		gpio_set_value(RK_HDMI_RST_PIN, GPIO_HIGH);
+		msleep(50);
+	}
+	return 0;
+}
+static struct rk_hdmi_platform_data rk_hdmi_pdata = {
+	.io_init = rk_hdmi_power_init,
+};
+#endif
 #ifdef CONFIG_ION
 #define ION_RESERVE_SIZE        (80 * SZ_1M)
 static struct ion_platform_data rk30_ion_pdata = {
@@ -1568,10 +1592,11 @@ static struct i2c_board_info __initdata i2c2_info[] = {
 #endif
 #if defined(CONFIG_HDMI_CAT66121)
 	{
-	.type			= "cat66121_hdmi",
-	.addr			= 0x4c,
-	.flags			= 0,
-	.irq			= RK30_PIN2_PD6,
+		.type		= "cat66121_hdmi",
+		.addr		= 0x4c,
+		.flags		= 0,
+		.irq		= RK30_PIN2_PD6,
+		.platform_data 	= &rk_hdmi_pdata,
 	},
 #endif
 };
diff --git a/arch/arm/plat-rk/include/plat/board.h b/arch/arm/plat-rk/include/plat/board.h
index 9de7cb23bb30..518e3185646f 100755
--- a/arch/arm/plat-rk/include/plat/board.h
+++ b/arch/arm/plat-rk/include/plat/board.h
@@ -426,6 +426,9 @@ struct rk610_codec_platform_data {
 	int boot_depop;//if found boot pop,set boot_depop 1 test
 };
 
+struct rk_hdmi_platform_data {
+	int (*io_init)(void);
+};
 #define BOOT_MODE_NORMAL		0
 #define BOOT_MODE_FACTORY2		1
 #define BOOT_MODE_RECOVERY		2
diff --git a/drivers/video/rockchip/hdmi/chips/cat66121/Makefile b/drivers/video/rockchip/hdmi/chips/cat66121/Makefile
index 7d0ffda6f61d..be259dd185d6 100755
--- a/drivers/video/rockchip/hdmi/chips/cat66121/Makefile
+++ b/drivers/video/rockchip/hdmi/chips/cat66121/Makefile
@@ -1,3 +1,5 @@
+ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
+
 obj-$(CONFIG_HDMI_CAT66121)       += cat66121_hdmi.o \
 					cat66121_hdmi_hw.o \
 				 	hdmitx_sys.o \
diff --git a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi.c b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi.c
index c3a6834bdeec..3756b9a24bd0 100755
--- a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi.c
+++ b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi.c
@@ -1,340 +1,337 @@
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-#include <linux/i2c.h>
-#include "cat66121_hdmi.h"
-
-struct cat66121_hdmi_pdata *cat66121_hdmi = NULL;
-struct hdmi *hdmi=NULL;
-
-extern struct rk_lcdc_device_driver * rk_get_lcdc_drv(char *name);
-extern void hdmi_register_display_sysfs(struct hdmi *hdmi, struct device *parent);
-extern void hdmi_unregister_display_sysfs(struct hdmi *hdmi);
-
-int cat66121_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
-					 void (*hdcp_irq_cb)(int status),
-					 int (*hdcp_power_on_cb)(void),
-					 void (*hdcp_power_off_cb)(void))
-{
-	hdmi->hdcp_cb = hdcp_cb;
-	hdmi->hdcp_irq_cb = hdcp_irq_cb;
-	hdmi->hdcp_power_on_cb = hdcp_power_on_cb;
-	hdmi->hdcp_power_off_cb = hdcp_power_off_cb;
-	
-	return HDMI_ERROR_SUCESS;
-}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void hdmi_early_suspend(struct early_suspend *h)
-{
-	hdmi_dbg(hdmi->dev, "hdmi enter early suspend pwr %d state %d\n", hdmi->pwr_mode, hdmi->state);
-	flush_delayed_work(&hdmi->delay_work);	
-	mutex_lock(&hdmi->enable_mutex);
-	hdmi->suspend = 1;
-	if(!hdmi->enable) {
-		mutex_unlock(&hdmi->enable_mutex);
-		return;
-	}
-	
-	#ifdef HDMI_USE_IRQ
-	if(hdmi->irq)
-		disable_irq(hdmi->irq);
-	#endif
-	
-	mutex_unlock(&hdmi->enable_mutex);
-	hdmi->command = HDMI_CONFIG_ENABLE;
-	init_completion(&hdmi->complete);
-	hdmi->wait = 1;
-	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
-	wait_for_completion_interruptible_timeout(&hdmi->complete,
-							msecs_to_jiffies(5000));
-	flush_delayed_work(&hdmi->delay_work);
-	return;
-}
-
-static void hdmi_early_resume(struct early_suspend *h)
-{
-	hdmi_dbg(hdmi->dev, "hdmi exit early resume\n");
-	mutex_lock(&hdmi->enable_mutex);
-	
-	hdmi->suspend = 0;
-	#ifdef HDMI_USE_IRQ
-	if(hdmi->enable && hdmi->irq) {
-		enable_irq(hdmi->irq);
-	}
-	#else
-	queue_delayed_work(cat66121_hdmi->workqueue, &cat66121_hdmi->delay_work, 100);
-	#endif
-	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));	
-	mutex_unlock(&hdmi->enable_mutex);
-	return;
-}
-#endif
-
-static void cat66121_irq_work_func(struct work_struct *work)
-{
-	if(hdmi->suspend == 0) {
-		if(hdmi->enable == 1) {
-			cat66121_hdmi_interrupt();
-			if(hdmi->hdcp_irq_cb)
-				hdmi->hdcp_irq_cb(0);
-		}
-		#ifndef HDMI_USE_IRQ
-		queue_delayed_work(cat66121_hdmi->workqueue, &cat66121_hdmi->delay_work, 50);
-		#endif
-	}
-}
-
-#ifdef HDMI_USE_IRQ
-static irqreturn_t cat66121_irq(int irq, void *dev_id)
-{
-	printk(KERN_INFO "cat66121 irq triggered.\n");
-	schedule_work(&cat66121_hdmi->irq_work);
-    return IRQ_HANDLED;
-}
-#endif
-static int rk610_read_p0_reg(struct i2c_client *client, char reg, char *val)
-{
-	return i2c_master_reg8_recv(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
-}
-
-static int rk610_write_p0_reg(struct i2c_client *client, char reg, char *val)
-{
-	return i2c_master_reg8_send(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
-}
-static ssize_t rk610_show_reg_attrs(struct device *dev,
-					      struct device_attribute *attr,
-					      char *buf)
-{
-
-	int i,size=0;
-	char val;
-	struct i2c_client *client=cat66121_hdmi->client;
-
-	for(i=0;i<256;i++)
-	{
-		rk610_read_p0_reg(client, i,  &val);
-		if(i%16==0)
-			size += sprintf(buf+size,"\n>>>rk610_hdmi %x:",i);
-		size += sprintf(buf+size," %2x",val);
-	}
-
-	return size;
-}
-static ssize_t rk610_store_reg_attrs(struct device *dev,
-						struct device_attribute *attr,
-			 			const char *buf, size_t size)
-{
-	struct i2c_client *client=NULL;
-	static char val=0,reg=0;
-	client = cat66121_hdmi->client;
-	printk("/**********rk610 reg config******/");
-
-	sscanf(buf, "%x%x", &val,&reg);
-	printk("reg=%x val=%x\n",reg,val);
-	rk610_write_p0_reg(client, reg,  &val);
-	printk("val=%x\n",val);
-	return size;
-}
-
-static struct device_attribute rk610_attrs[] = {
-	__ATTR(reg_ctl, 0777,rk610_show_reg_attrs,rk610_store_reg_attrs),
-};
-static int cat66121_hdmi_i2c_probe(struct i2c_client *client,const struct i2c_device_id *id)
-{
-    int rc = 0;
-	
-	cat66121_hdmi = kzalloc(sizeof(struct cat66121_hdmi_pdata), GFP_KERNEL);
-	if(!cat66121_hdmi)
-	{
-        dev_err(&client->dev, "no memory for state\n");
-    	return -ENOMEM;
-    }
-	cat66121_hdmi->client = client;
-	i2c_set_clientdata(client, cat66121_hdmi);
-	
-	hdmi = kmalloc(sizeof(struct hdmi), GFP_KERNEL);
-	if(!hdmi)
-	{
-    	dev_err(&client->dev, "cat66121 hdmi kmalloc fail!");
-    	goto err_kzalloc_hdmi;
-	}
-	memset(hdmi, 0, sizeof(struct hdmi));
-	hdmi->dev = &client->dev;
-	
-	if(HDMI_SOURCE_DEFAULT == HDMI_SOURCE_LCDC0)
-		hdmi->lcdc = rk_get_lcdc_drv("lcdc0");
-	else
-		hdmi->lcdc = rk_get_lcdc_drv("lcdc1");
-	if(hdmi->lcdc == NULL)
-	{
-		dev_err(hdmi->dev, "can not connect to video source lcdc\n");
-		rc = -ENXIO;
-		goto err_request_lcdc;
-	}
-	hdmi->xscale = 100;
-	hdmi->yscale = 100;
-	hdmi->insert = cat66121_hdmi_sys_insert;
-	hdmi->remove = cat66121_hdmi_sys_remove;
-	hdmi->control_output = cat66121_hdmi_sys_enalbe_output;
-	hdmi->config_video = cat66121_hdmi_sys_config_video;
-	hdmi->config_audio = cat66121_hdmi_sys_config_audio;
-	hdmi->detect_hotplug = cat66121_hdmi_sys_detect_hpd;
-	hdmi->read_edid = cat66121_hdmi_sys_read_edid;
-	hdmi_sys_init();
-	
-	hdmi->workqueue = create_singlethread_workqueue("hdmi");
-	INIT_DELAYED_WORK(&(hdmi->delay_work), hdmi_work);
-	
-	#ifdef CONFIG_HAS_EARLYSUSPEND
-	hdmi->early_suspend.suspend = hdmi_early_suspend;
-	hdmi->early_suspend.resume = hdmi_early_resume;
-	hdmi->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 10;
-	register_early_suspend(&hdmi->early_suspend);
-	#endif
-	
-	hdmi_register_display_sysfs(hdmi, NULL);
-	#ifdef CONFIG_SWITCH
-	hdmi->switch_hdmi.name="hdmi";
-	switch_dev_register(&(hdmi->switch_hdmi));
-	#endif
-		
-	spin_lock_init(&hdmi->irq_lock);
-	mutex_init(&hdmi->enable_mutex);
-	
-	cat66121_hdmi_sys_init();
-	rc = gpio_request(client->irq, "cat66121 rst");
-	if (rc != 0) {
-		gpio_free(client->irq);
-		printk("goodix power error\n");
-		return -EIO;
-	}
-	gpio_direction_output(client->irq, GPIO_HIGH);
-	gpio_set_value(client->irq, GPIO_HIGH);
-	msleep(10);
-	gpio_set_value(client->irq, GPIO_LOW);
-	msleep(200);
-	gpio_set_value(client->irq, GPIO_HIGH);
-#ifdef HDMI_USE_IRQ
-	if(client->irq != INVALID_GPIO) {
-		INIT_WORK(&cat66121_hdmi->irq_work, cat66121_irq_work_func);
-		schedule_work(&cat66121_hdmi->irq_work);
-		if((rc = gpio_request(client->irq, "hdmi gpio")) < 0)
-	    {
-	        dev_err(&client->dev, "fail to request gpio %d\n", client->irq);
-	        goto err_request_lcdc;
-	    }
-	    hdmi->irq = gpio_to_irq(client->irq);
-		cat66121_hdmi->gpio = client->irq;
-	    gpio_pull_updown(client->irq, GPIOPullUp);
-	    gpio_direction_input(client->irq);
-	    if((rc = request_irq(hdmi->irq, cat66121_irq, IRQF_TRIGGER_RISING, NULL, hdmi)) < 0)
-	    {
-	        dev_err(&client->dev, "fail to request hdmi irq\n");
-	        goto err_request_irq;
-	    }
-	}
-	else
-#else
-	{
-		cat66121_hdmi->workqueue = create_singlethread_workqueue("cat66121 irq");
-		INIT_DELAYED_WORK(&(cat66121_hdmi->delay_work), cat66121_irq_work_func);
-		cat66121_irq_work_func(NULL);
-	}
-#endif
-
-	device_create_file(&(client->dev), &rk610_attrs[0]);
-	dev_info(&client->dev, "cat66121 hdmi i2c probe ok\n");
-	
-    return 0;
-	
-err_request_irq:
-	gpio_free(client->irq);
-err_request_lcdc:
-	kfree(hdmi);
-	hdmi = NULL;
-err_kzalloc_hdmi:
-	kfree(cat66121_hdmi);
-	cat66121_hdmi = NULL;
-	dev_err(&client->dev, "cat66121 hdmi probe error\n");
-	return rc;
-
-}
-
-static int __devexit cat66121_hdmi_i2c_remove(struct i2c_client *client)
-{	
-	hdmi_dbg(hdmi->dev, "%s\n", __func__);
-	if(hdmi) {
-		mutex_lock(&hdmi->enable_mutex);
-		if(!hdmi->suspend && hdmi->enable && hdmi->irq)
-			disable_irq(hdmi->irq);
-		mutex_unlock(&hdmi->enable_mutex);
-		if(hdmi->irq)
-			free_irq(hdmi->irq, NULL);
-		flush_workqueue(hdmi->workqueue);
-		destroy_workqueue(hdmi->workqueue);
-		#ifdef CONFIG_SWITCH
-		switch_dev_unregister(&(hdmi->switch_hdmi));
-		#endif
-		hdmi_unregister_display_sysfs(hdmi);
-		#ifdef CONFIG_HAS_EARLYSUSPEND
-		unregister_early_suspend(&hdmi->early_suspend);
-		#endif
-		fb_destroy_modelist(&hdmi->edid.modelist);
-		if(hdmi->edid.audio)
-			kfree(hdmi->edid.audio);
-		if(hdmi->edid.specs)
-		{
-			if(hdmi->edid.specs->modedb)
-				kfree(hdmi->edid.specs->modedb);
-			kfree(hdmi->edid.specs);
-		}
-		kfree(hdmi);
-		hdmi = NULL;
-	}
-    return 0;
-}
-
-static void cat66121_hdmi_i2c_shutdown(struct i2c_client *client)
-{
-	if(hdmi) {
-		#ifdef CONFIG_HAS_EARLYSUSPEND
-		unregister_early_suspend(&hdmi->early_suspend);
-		#endif
-	}
-	printk(KERN_INFO "cat66121 hdmi shut down.\n");
-}
-
-static const struct i2c_device_id cat66121_hdmi_id[] = {
-	{ "cat66121_hdmi", 0 },
-	{ }
-};
-
-static struct i2c_driver cat66121_hdmi_i2c_driver = {
-    .driver = {
-        .name  = "cat66121_hdmi",
-        .owner = THIS_MODULE,
-    },
-    .probe      = cat66121_hdmi_i2c_probe,
-    .remove     = cat66121_hdmi_i2c_remove,
-    .shutdown	= cat66121_hdmi_i2c_shutdown,
-    .id_table	= cat66121_hdmi_id,
-};
-
-static int __init cat66121_hdmi_init(void)
-{
-    return i2c_add_driver(&cat66121_hdmi_i2c_driver);
-}
-
-static void __exit cat66121_hdmi_exit(void)
-{
-    i2c_del_driver(&cat66121_hdmi_i2c_driver);
-}
-
-module_init(cat66121_hdmi_init);
-//fs_initcall(cat66121_init);
-module_exit(cat66121_hdmi_exit);
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <linux/i2c.h>
+#include "cat66121_hdmi.h"
+
+struct cat66121_hdmi_pdata *cat66121_hdmi = NULL;
+struct hdmi *hdmi=NULL;
+
+extern struct rk_lcdc_device_driver * rk_get_lcdc_drv(char *name);
+extern void hdmi_register_display_sysfs(struct hdmi *hdmi, struct device *parent);
+extern void hdmi_unregister_display_sysfs(struct hdmi *hdmi);
+
+int cat66121_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
+					 void (*hdcp_irq_cb)(int status),
+					 int (*hdcp_power_on_cb)(void),
+					 void (*hdcp_power_off_cb)(void))
+{
+	hdmi->hdcp_cb = hdcp_cb;
+	hdmi->hdcp_irq_cb = hdcp_irq_cb;
+	hdmi->hdcp_power_on_cb = hdcp_power_on_cb;
+	hdmi->hdcp_power_off_cb = hdcp_power_off_cb;
+	
+	return HDMI_ERROR_SUCESS;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void hdmi_early_suspend(struct early_suspend *h)
+{
+	hdmi_dbg(hdmi->dev, "hdmi enter early suspend pwr %d state %d\n", hdmi->pwr_mode, hdmi->state);
+	flush_delayed_work(&hdmi->delay_work);	
+	mutex_lock(&hdmi->enable_mutex);
+	hdmi->suspend = 1;
+	if(!hdmi->enable) {
+		mutex_unlock(&hdmi->enable_mutex);
+		return;
+	}
+	
+	#ifdef HDMI_USE_IRQ
+	if(hdmi->irq)
+		disable_irq(hdmi->irq);
+	#endif
+	
+	mutex_unlock(&hdmi->enable_mutex);
+	hdmi->command = HDMI_CONFIG_ENABLE;
+	init_completion(&hdmi->complete);
+	hdmi->wait = 1;
+	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
+	wait_for_completion_interruptible_timeout(&hdmi->complete,
+							msecs_to_jiffies(5000));
+	flush_delayed_work(&hdmi->delay_work);
+	return;
+}
+
+static void hdmi_early_resume(struct early_suspend *h)
+{
+	hdmi_dbg(hdmi->dev, "hdmi exit early resume\n");
+	mutex_lock(&hdmi->enable_mutex);
+	
+	hdmi->suspend = 0;
+	#ifdef HDMI_USE_IRQ
+	if(hdmi->enable && hdmi->irq) {
+		enable_irq(hdmi->irq);
+	}
+	#else
+	queue_delayed_work(cat66121_hdmi->workqueue, &cat66121_hdmi->delay_work, 100);
+	#endif
+	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));	
+	mutex_unlock(&hdmi->enable_mutex);
+	return;
+}
+#endif
+
+static void cat66121_irq_work_func(struct work_struct *work)
+{
+	if(hdmi->suspend == 0) {
+		if(hdmi->enable == 1) {
+			cat66121_hdmi_interrupt();
+			if(hdmi->hdcp_irq_cb)
+				hdmi->hdcp_irq_cb(0);
+		}
+		#ifndef HDMI_USE_IRQ
+		queue_delayed_work(cat66121_hdmi->workqueue, &cat66121_hdmi->delay_work, 50);
+		#endif
+	}
+}
+
+#ifdef HDMI_USE_IRQ
+static irqreturn_t cat66121_irq(int irq, void *dev_id)
+{
+	printk(KERN_INFO "cat66121 irq triggered.\n");
+	schedule_work(&cat66121_hdmi->irq_work);
+    return IRQ_HANDLED;
+}
+#endif
+#ifdef HDMI_DEBUG
+static int hdmi_read_p0_reg(struct i2c_client *client, char reg, char *val)
+{
+	return i2c_master_reg8_recv(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
+}
+
+static int hdmi_write_p0_reg(struct i2c_client *client, char reg, char *val)
+{
+	return i2c_master_reg8_send(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
+}
+static ssize_t hdmi_show_reg_attrs(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+
+	int i,size=0;
+	char val;
+	struct i2c_client *client=cat66121_hdmi->client;
+
+	for(i=0;i<256;i++)
+	{
+		hdmi_read_p0_reg(client, i,  &val);
+		if(i%16==0)
+			size += sprintf(buf+size,"\n>>>hdmi_hdmi %x:",i);
+		size += sprintf(buf+size," %2x",val);
+	}
+
+	return size;
+}
+static ssize_t hdmi_store_reg_attrs(struct device *dev,
+						struct device_attribute *attr,
+			 			const char *buf, size_t size)
+{
+	struct i2c_client *client=NULL;
+	static char val=0,reg=0;
+	client = cat66121_hdmi->client;
+	printk("/**********hdmi reg config******/");
+
+	sscanf(buf, "%x%x", &val,&reg);
+	hdmi_write_p0_reg(client, reg,  &val);
+	return size;
+}
+
+static struct device_attribute hdmi_attrs[] = {
+	__ATTR(reg_ctl, 0777,hdmi_show_reg_attrs,hdmi_store_reg_attrs),
+};
+#endif
+static int cat66121_hdmi_i2c_probe(struct i2c_client *client,const struct i2c_device_id *id)
+{
+    int rc = 0;
+	struct rk_hdmi_platform_data *pdata = client->dev.platform_data;
+	
+	cat66121_hdmi = kzalloc(sizeof(struct cat66121_hdmi_pdata), GFP_KERNEL);
+	if(!cat66121_hdmi)
+	{
+        dev_err(&client->dev, "no memory for state\n");
+    	return -ENOMEM;
+    }
+	cat66121_hdmi->client = client;
+	i2c_set_clientdata(client, cat66121_hdmi);
+	
+	hdmi = kmalloc(sizeof(struct hdmi), GFP_KERNEL);
+	if(!hdmi)
+	{
+    	dev_err(&client->dev, "cat66121 hdmi kmalloc fail!");
+    	goto err_kzalloc_hdmi;
+	}
+	memset(hdmi, 0, sizeof(struct hdmi));
+	hdmi->dev = &client->dev;
+	
+	if(HDMI_SOURCE_DEFAULT == HDMI_SOURCE_LCDC0)
+		hdmi->lcdc = rk_get_lcdc_drv("lcdc0");
+	else
+		hdmi->lcdc = rk_get_lcdc_drv("lcdc1");
+	if(hdmi->lcdc == NULL)
+	{
+		dev_err(hdmi->dev, "can not connect to video source lcdc\n");
+		rc = -ENXIO;
+		goto err_request_lcdc;
+	}
+	hdmi->xscale = 100;
+	hdmi->yscale = 100;
+	hdmi->insert = cat66121_hdmi_sys_insert;
+	hdmi->remove = cat66121_hdmi_sys_remove;
+	hdmi->control_output = cat66121_hdmi_sys_enalbe_output;
+	hdmi->config_video = cat66121_hdmi_sys_config_video;
+	hdmi->config_audio = cat66121_hdmi_sys_config_audio;
+	hdmi->detect_hotplug = cat66121_hdmi_sys_detect_hpd;
+	hdmi->read_edid = cat66121_hdmi_sys_read_edid;
+	hdmi_sys_init();
+	
+	hdmi->workqueue = create_singlethread_workqueue("hdmi");
+	INIT_DELAYED_WORK(&(hdmi->delay_work), hdmi_work);
+	
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+	hdmi->early_suspend.suspend = hdmi_early_suspend;
+	hdmi->early_suspend.resume = hdmi_early_resume;
+	hdmi->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 10;
+	register_early_suspend(&hdmi->early_suspend);
+	#endif
+	
+	hdmi_register_display_sysfs(hdmi, NULL);
+	#ifdef CONFIG_SWITCH
+	hdmi->switch_hdmi.name="hdmi";
+	switch_dev_register(&(hdmi->switch_hdmi));
+	#endif
+		
+	spin_lock_init(&hdmi->irq_lock);
+	mutex_init(&hdmi->enable_mutex);
+	
+	if(pdata->io_init){
+		if(pdata->io_init()<0){
+			dev_err(&client->dev, "fail to rst chip\n");
+			goto err_request_lcdc;
+		}
+	}
+	cat66121_hdmi_sys_init();
+#ifdef HDMI_USE_IRQ
+	if(client->irq != INVALID_GPIO) {
+		INIT_WORK(&cat66121_hdmi->irq_work, cat66121_irq_work_func);
+		schedule_work(&cat66121_hdmi->irq_work);
+		if((rc = gpio_request(client->irq, "hdmi gpio")) < 0)
+	    {
+	        dev_err(&client->dev, "fail to request gpio %d\n", client->irq);
+	        goto err_request_lcdc;
+	    }
+	    hdmi->irq = gpio_to_irq(client->irq);
+		cat66121_hdmi->gpio = client->irq;
+	    gpio_pull_updown(client->irq, GPIOPullUp);
+	    gpio_direction_input(client->irq);
+	    if((rc = request_irq(hdmi->irq, cat66121_irq, IRQF_TRIGGER_RISING, NULL, hdmi)) < 0)
+	    {
+	        dev_err(&client->dev, "fail to request hdmi irq\n");
+	        goto err_request_irq;
+	    }
+	}
+	else
+#else
+	{
+		cat66121_hdmi->workqueue = create_singlethread_workqueue("cat66121 irq");
+		INIT_DELAYED_WORK(&(cat66121_hdmi->delay_work), cat66121_irq_work_func);
+		cat66121_irq_work_func(NULL);
+	}
+#endif
+
+#ifdef HDMI_DEBUG
+	device_create_file(&(client->dev), &hdmi_attrs[0]);
+#endif
+	dev_info(&client->dev, "cat66121 hdmi i2c probe ok\n");
+	
+    return 0;
+	
+err_request_irq:
+	gpio_free(client->irq);
+err_request_lcdc:
+	kfree(hdmi);
+	hdmi = NULL;
+err_kzalloc_hdmi:
+	kfree(cat66121_hdmi);
+	cat66121_hdmi = NULL;
+	dev_err(&client->dev, "cat66121 hdmi probe error\n");
+	return rc;
+
+}
+
+static int __devexit cat66121_hdmi_i2c_remove(struct i2c_client *client)
+{	
+	hdmi_dbg(hdmi->dev, "%s\n", __func__);
+	if(hdmi) {
+		mutex_lock(&hdmi->enable_mutex);
+		if(!hdmi->suspend && hdmi->enable && hdmi->irq)
+			disable_irq(hdmi->irq);
+		mutex_unlock(&hdmi->enable_mutex);
+		if(hdmi->irq)
+			free_irq(hdmi->irq, NULL);
+		flush_workqueue(hdmi->workqueue);
+		destroy_workqueue(hdmi->workqueue);
+		#ifdef CONFIG_SWITCH
+		switch_dev_unregister(&(hdmi->switch_hdmi));
+		#endif
+		hdmi_unregister_display_sysfs(hdmi);
+		#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&hdmi->early_suspend);
+		#endif
+		fb_destroy_modelist(&hdmi->edid.modelist);
+		if(hdmi->edid.audio)
+			kfree(hdmi->edid.audio);
+		if(hdmi->edid.specs)
+		{
+			if(hdmi->edid.specs->modedb)
+				kfree(hdmi->edid.specs->modedb);
+			kfree(hdmi->edid.specs);
+		}
+		kfree(hdmi);
+		hdmi = NULL;
+	}
+    return 0;
+}
+
+static void cat66121_hdmi_i2c_shutdown(struct i2c_client *client)
+{
+	if(hdmi) {
+		#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&hdmi->early_suspend);
+		#endif
+	}
+	printk(KERN_INFO "cat66121 hdmi shut down.\n");
+}
+
+static const struct i2c_device_id cat66121_hdmi_id[] = {
+	{ "cat66121_hdmi", 0 },
+	{ }
+};
+
+static struct i2c_driver cat66121_hdmi_i2c_driver = {
+    .driver = {
+        .name  = "cat66121_hdmi",
+        .owner = THIS_MODULE,
+    },
+    .probe      = cat66121_hdmi_i2c_probe,
+    .remove     = cat66121_hdmi_i2c_remove,
+    .shutdown	= cat66121_hdmi_i2c_shutdown,
+    .id_table	= cat66121_hdmi_id,
+};
+
+static int __init cat66121_hdmi_init(void)
+{
+    return i2c_add_driver(&cat66121_hdmi_i2c_driver);
+}
+
+static void __exit cat66121_hdmi_exit(void)
+{
+    i2c_del_driver(&cat66121_hdmi_i2c_driver);
+}
+
+module_init(cat66121_hdmi_init);
+//fs_initcall(cat66121_init);
+module_exit(cat66121_hdmi_exit);
diff --git a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi.h b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi.h
index 0a3bdc40148d..2bc85dfc11f9 100755
--- a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi.h
+++ b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi.h
@@ -1,34 +1,34 @@
-#ifndef __cat66121_HDMI_H__
-#define __cat66121_HDMI_H__
-#include "../../rk_hdmi.h"
-
-#define HDMI_SOURCE_DEFAULT HDMI_SOURCE_LCDC0
-//#define HDMI_USE_IRQ
-
-struct cat66121_hdmi_pdata {
-	int gpio;
-	struct i2c_client *client;
-	struct delayed_work delay_work;
-	#ifdef HDMI_USE_IRQ
-	struct work_struct	irq_work;
-	#else
-	struct workqueue_struct *workqueue;
-	#endif
-};
-
-extern struct cat66121_hdmi_pdata *cat66121_hdmi;
-
-extern int cat66121_hdmi_sys_init(void);
-extern void cat66121_hdmi_interrupt(void);
-extern int cat66121_hdmi_sys_detect_hpd(void);
-extern int cat66121_hdmi_sys_insert(void);
-extern int cat66121_hdmi_sys_remove(void);
-extern int cat66121_hdmi_sys_read_edid(int block, unsigned char *buff);
-extern int cat66121_hdmi_sys_config_video(struct hdmi_video_para *vpara);
-extern int cat66121_hdmi_sys_config_audio(struct hdmi_audio *audio);
-extern void cat66121_hdmi_sys_enalbe_output(int enable);
-extern int cat66121_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
-					 void (*hdcp_irq_cb)(int status),
-					 int (*hdcp_power_on_cb)(void),
-					 void (*hdcp_power_off_cb)(void));
-#endif
+#ifndef __cat66121_HDMI_H__
+#define __cat66121_HDMI_H__
+#include "../../rk_hdmi.h"
+
+#define HDMI_SOURCE_DEFAULT HDMI_SOURCE_LCDC0
+//#define HDMI_USE_IRQ
+
+struct cat66121_hdmi_pdata {
+	int gpio;
+	struct i2c_client *client;
+	struct delayed_work delay_work;
+	#ifdef HDMI_USE_IRQ
+	struct work_struct	irq_work;
+	#else
+	struct workqueue_struct *workqueue;
+	#endif
+};
+
+extern struct cat66121_hdmi_pdata *cat66121_hdmi;
+
+extern int cat66121_hdmi_sys_init(void);
+extern void cat66121_hdmi_interrupt(void);
+extern int cat66121_hdmi_sys_detect_hpd(void);
+extern int cat66121_hdmi_sys_insert(void);
+extern int cat66121_hdmi_sys_remove(void);
+extern int cat66121_hdmi_sys_read_edid(int block, unsigned char *buff);
+extern int cat66121_hdmi_sys_config_video(struct hdmi_video_para *vpara);
+extern int cat66121_hdmi_sys_config_audio(struct hdmi_audio *audio);
+extern void cat66121_hdmi_sys_enalbe_output(int enable);
+extern int cat66121_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
+					 void (*hdcp_irq_cb)(int status),
+					 int (*hdcp_power_on_cb)(void),
+					 void (*hdcp_power_off_cb)(void));
+#endif
diff --git a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi_hw.c b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi_hw.c
index 4aa324660034..46b558bd1f44 100755
--- a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi_hw.c
+++ b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_hdmi_hw.c
@@ -1,231 +1,219 @@
-#include <linux/delay.h>
-#include "cat66121_hdmi.h"
-#include "cat66121_hdmi_hw.h"
-#include <asm/atomic.h>
-#include <mach/io.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-
-#define HDMITX_INPUT_SIGNAL_TYPE 0  // for default(Sync Sep Mode)
-#define INPUT_SPDIF_ENABLE	0
-extern int CAT66121_Interrupt_Process(void);
-/*******************************
- * Global Data
- ******************************/
-static _XDATA AVI_InfoFrame AviInfo;
-static _XDATA Audio_InfoFrame AudioInfo;
-static unsigned long VideoPixelClock;
-static unsigned int pixelrep;
-
-/* I2C read/write funcs */
-BYTE HDMITX_ReadI2C_Byte(BYTE RegAddr)
-{
-	struct i2c_msg msgs[2];
-	SYS_STATUS ret = -1;
-	BYTE buf[1];
-
-	buf[0] = RegAddr;
-
-	/* Write device addr fisrt */
-	msgs[0].addr	= cat66121_hdmi->client->addr;
-	msgs[0].flags	= !I2C_M_RD;
-	msgs[0].len		= 1;
-	msgs[0].buf		= &buf[0];
-	msgs[0].scl_rate= 100*1000;
-	/* Then, begin to read data */
-	msgs[1].addr	= cat66121_hdmi->client->addr;
-	msgs[1].flags	= I2C_M_RD;
-	msgs[1].len		= 1;
-	msgs[1].buf		= &buf[0];
-	msgs[1].scl_rate= 100*1000;
-	
-	ret = i2c_transfer(cat66121_hdmi->client->adapter, msgs, 2);
-	if(ret != 2)
-		printk("I2C transfer Error! ret = %d\n", ret);
-
-	//ErrorF("Reg%02xH: 0x%02x\n", RegAddr, buf[0]);
-	return buf[0];
-}
-
-SYS_STATUS HDMITX_WriteI2C_Byte(BYTE RegAddr, BYTE data)
-{
-	struct i2c_msg msg;
-	SYS_STATUS ret = -1;
-	BYTE buf[2];
-
-	buf[0] = RegAddr;
-	buf[1] = data;
-
-	msg.addr	= cat66121_hdmi->client->addr;
-	msg.flags	= !I2C_M_RD;
-	msg.len		= 2;
-	msg.buf		= buf;		
-	msg.scl_rate= 100*1000;
-	
-	ret = i2c_transfer(cat66121_hdmi->client->adapter, &msg, 1);
-	if(ret != 1)
-		printk("I2C transfer Error!\n");
-
-	return ret;
-}
-
-SYS_STATUS HDMITX_ReadI2C_ByteN(BYTE RegAddr, BYTE *pData, int N)
-{
-	struct i2c_msg msgs[2];
-	SYS_STATUS ret = -1;
-
-	pData[0] = RegAddr;
-
-	msgs[0].addr	= cat66121_hdmi->client->addr;
-	msgs[0].flags	= !I2C_M_RD;
-	msgs[0].len		= 1;
-	msgs[0].buf		= &pData[0];
-	msgs[0].scl_rate= 100*1000;
-
-	msgs[1].addr	= cat66121_hdmi->client->addr;
-	msgs[1].flags	= I2C_M_RD;
-	msgs[1].len		= N;
-	msgs[1].buf		= pData;
-	msgs[1].scl_rate= 100*1000;
-	
-	ret = i2c_transfer(cat66121_hdmi->client->adapter, msgs, 2);
-	if(ret != 2)
-		printk("I2C transfer Error! ret = %d\n", ret);
-
-	return ret;
-}
-
-SYS_STATUS HDMITX_WriteI2C_ByteN(BYTE RegAddr, BYTE *pData, int N)
-{
-	struct i2c_msg msg;
-	SYS_STATUS ret = -1;
-	BYTE buf[N + 1];
-
-	buf[0] = RegAddr;
-    memcpy(&buf[1], pData, N);
-
-	msg.addr	= cat66121_hdmi->client->addr;
-	msg.flags	= !I2C_M_RD;
-	msg.len		= N + 1;
-	msg.buf		= buf;		// gModify.Exp."Include RegAddr"
-	msg.scl_rate= 100*1000;
-	
-	ret = i2c_transfer(cat66121_hdmi->client->adapter, &msg, 1);
-	if(ret != 1)
-		printk("I2C transfer Error! ret = %d\n", ret);
-
-	return ret;
-}
-SYS_STATUS HDMITX_SetI2C_Byte(BYTE Reg,BYTE Mask,BYTE Value)
-{
-    BYTE Temp;
-    if( Mask != 0xFF )
-    {
-        Temp=HDMITX_ReadI2C_Byte(Reg);
-        Temp&=(~Mask);
-        Temp|=Value&Mask;
-    }
-    else
-    {
-        Temp=Value;
-    }
-    return HDMITX_WriteI2C_Byte(Reg,Temp);
-}
-int cat66121_hdmi_sys_init(void)
-{
-	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
-#if 0
-	if (gpio_request(RK30_PIN3_PB2, NULL)) {
-		printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
-		return -1;
-	}
-	gpio_direction_output(RK30_PIN3_PB2, GPIO_LOW);
-	gpio_set_value(RK30_PIN3_PB2, GPIO_LOW);
-	msleep(200);
-	gpio_set_value(RK30_PIN3_PB2, GPIO_HIGH);
-#endif
-	mdelay(5);
-	VideoPixelClock = 0;
-	pixelrep = 0;
-    InitHDMITX_Variable();
-    InitHDMITX();
-	msleep(100);
-	return HDMI_ERROR_SUCESS;
-}
-
-void cat66121_hdmi_interrupt()
-{
-	char interrupt = 0;
-
-	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
-	if(hdmi->state == HDMI_SLEEP)
-		hdmi->state = WAIT_HOTPLUG;
-	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));	
-}
-
-int cat66121_hdmi_sys_detect_hpd(void)
-{
-	char hdmi_status = 0;
-	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
-	//	BYTE sysstat;
-
-	//sysstat = HDMITX_ReadI2C_Byte(REG_SYS_STATUS) ;   
-	//*hpdstatus = ((sysstat & B_HPDETECT) == B_HPDETECT)?TRUE:FALSE ;
-	hdmi_status = HDMITX_DevLoopProc();
-	if(hdmi_status)
-		return HDMI_HPD_ACTIVED;
-	else
-		return HDMI_HPD_REMOVED;
-}
-
-int cat66121_hdmi_sys_read_edid(int block, unsigned char *buff)
-{
-	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
-	return (getHDMITX_EDIDBlock(block, buff) == TRUE)?HDMI_ERROR_SUCESS:HDMI_ERROR_FALSE;
-}
-
-static void cat66121_sys_config_avi(int VIC, int bOutputColorMode, int aspec, int Colorimetry, int pixelrep)
-{
-	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
-//     AVI_InfoFrame AviInfo;
-
-}
-
-int cat66121_hdmi_sys_config_video(struct hdmi_video_para *vpara)
-{
-    HDMITX_ChangeDisplayOption(vpara->vic,HDMI_RGB444) ;
-
-	return HDMI_ERROR_SUCESS;
-}
-
-static void cat66121_hdmi_config_aai(void)
-{
-	printk( "[%s]\n", __FUNCTION__);
-}
-
-int cat66121_hdmi_sys_config_audio(struct hdmi_audio *audio)
-{
-	printk( "[%s]\n", __FUNCTION__);
-	return HDMI_ERROR_SUCESS;
-}
-
-void cat66121_hdmi_sys_enalbe_output(int enable)
-{
-	
-	printk( "[%s]\n", __FUNCTION__);
-}
-
-int cat66121_hdmi_sys_insert(void)
-{
-	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
-	printk( "[%s]\n", __FUNCTION__);
-	return 0;
-}
-
-int cat66121_hdmi_sys_remove(void)
-{
-	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
-//	printk( "[%s]\n", __FUNCTION__);
-
-	return 0;
-}
+#include <linux/delay.h>
+#include "cat66121_hdmi.h"
+#include "cat66121_hdmi_hw.h"
+#include <asm/atomic.h>
+#include <mach/io.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+
+#define HDMITX_INPUT_SIGNAL_TYPE 0  // for default(Sync Sep Mode)
+#define INPUT_SPDIF_ENABLE	0
+extern int CAT66121_Interrupt_Process(void);
+/*******************************
+ * Global Data
+ ******************************/
+static _XDATA AVI_InfoFrame AviInfo;
+static _XDATA Audio_InfoFrame AudioInfo;
+static unsigned long VideoPixelClock;
+static unsigned int pixelrep;
+
+/* I2C read/write funcs */
+BYTE HDMITX_ReadI2C_Byte(BYTE RegAddr)
+{
+	struct i2c_msg msgs[2];
+	SYS_STATUS ret = -1;
+	BYTE buf[1];
+
+	buf[0] = RegAddr;
+
+	/* Write device addr fisrt */
+	msgs[0].addr	= cat66121_hdmi->client->addr;
+	msgs[0].flags	= !I2C_M_RD;
+	msgs[0].len		= 1;
+	msgs[0].buf		= &buf[0];
+	msgs[0].scl_rate= 100*1000;
+	/* Then, begin to read data */
+	msgs[1].addr	= cat66121_hdmi->client->addr;
+	msgs[1].flags	= I2C_M_RD;
+	msgs[1].len		= 1;
+	msgs[1].buf		= &buf[0];
+	msgs[1].scl_rate= 100*1000;
+	
+	ret = i2c_transfer(cat66121_hdmi->client->adapter, msgs, 2);
+	if(ret != 2)
+		printk("I2C transfer Error! ret = %d\n", ret);
+
+	//ErrorF("Reg%02xH: 0x%02x\n", RegAddr, buf[0]);
+	return buf[0];
+}
+
+SYS_STATUS HDMITX_WriteI2C_Byte(BYTE RegAddr, BYTE data)
+{
+	struct i2c_msg msg;
+	SYS_STATUS ret = -1;
+	BYTE buf[2];
+
+	buf[0] = RegAddr;
+	buf[1] = data;
+
+	msg.addr	= cat66121_hdmi->client->addr;
+	msg.flags	= !I2C_M_RD;
+	msg.len		= 2;
+	msg.buf		= buf;		
+	msg.scl_rate= 100*1000;
+	
+	ret = i2c_transfer(cat66121_hdmi->client->adapter, &msg, 1);
+	if(ret != 1)
+		printk("I2C transfer Error!\n");
+
+	return ret;
+}
+
+SYS_STATUS HDMITX_ReadI2C_ByteN(BYTE RegAddr, BYTE *pData, int N)
+{
+	struct i2c_msg msgs[2];
+	SYS_STATUS ret = -1;
+
+	pData[0] = RegAddr;
+
+	msgs[0].addr	= cat66121_hdmi->client->addr;
+	msgs[0].flags	= !I2C_M_RD;
+	msgs[0].len		= 1;
+	msgs[0].buf		= &pData[0];
+	msgs[0].scl_rate= 100*1000;
+
+	msgs[1].addr	= cat66121_hdmi->client->addr;
+	msgs[1].flags	= I2C_M_RD;
+	msgs[1].len		= N;
+	msgs[1].buf		= pData;
+	msgs[1].scl_rate= 100*1000;
+	
+	ret = i2c_transfer(cat66121_hdmi->client->adapter, msgs, 2);
+	if(ret != 2)
+		printk("I2C transfer Error! ret = %d\n", ret);
+
+	return ret;
+}
+
+SYS_STATUS HDMITX_WriteI2C_ByteN(BYTE RegAddr, BYTE *pData, int N)
+{
+	struct i2c_msg msg;
+	SYS_STATUS ret = -1;
+	BYTE buf[N + 1];
+
+	buf[0] = RegAddr;
+	memcpy(&buf[1], pData, N);
+
+	msg.addr	= cat66121_hdmi->client->addr;
+	msg.flags	= !I2C_M_RD;
+	msg.len		= N + 1;
+	msg.buf		= buf;		// gModify.Exp."Include RegAddr"
+	msg.scl_rate= 100*1000;
+	
+	ret = i2c_transfer(cat66121_hdmi->client->adapter, &msg, 1);
+	if(ret != 1)
+		printk("I2C transfer Error! ret = %d\n", ret);
+
+	return ret;
+}
+SYS_STATUS HDMITX_SetI2C_Byte(BYTE Reg,BYTE Mask,BYTE Value)
+{
+    BYTE Temp;
+    if( Mask != 0xFF )
+    {
+        Temp=HDMITX_ReadI2C_Byte(Reg);
+        Temp&=(~Mask);
+        Temp|=Value&Mask;
+    }
+    else
+    {
+        Temp=Value;
+    }
+    return HDMITX_WriteI2C_Byte(Reg,Temp);
+}
+int cat66121_hdmi_sys_init(void)
+{
+	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
+	VideoPixelClock = 0;
+	pixelrep = 0;
+	InitHDMITX_Variable();
+	InitHDMITX();
+	msleep(100);
+	return HDMI_ERROR_SUCESS;
+}
+
+void cat66121_hdmi_interrupt()
+{
+	char interrupt = 0;
+
+	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
+	if(hdmi->state == HDMI_SLEEP)
+		hdmi->state = WAIT_HOTPLUG;
+	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));	
+}
+
+int cat66121_hdmi_sys_detect_hpd(void)
+{
+	char hdmi_status = 0;
+	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
+	//	BYTE sysstat;
+
+	//sysstat = HDMITX_ReadI2C_Byte(REG_SYS_STATUS) ;   
+	//*hpdstatus = ((sysstat & B_HPDETECT) == B_HPDETECT)?TRUE:FALSE ;
+	hdmi_status = HDMITX_DevLoopProc();
+	if(hdmi_status)
+		return HDMI_HPD_ACTIVED;
+	else
+		return HDMI_HPD_REMOVED;
+}
+
+int cat66121_hdmi_sys_read_edid(int block, unsigned char *buff)
+{
+	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
+	return (getHDMITX_EDIDBlock(block, buff) == TRUE)?HDMI_ERROR_SUCESS:HDMI_ERROR_FALSE;
+}
+
+static void cat66121_sys_config_avi(int VIC, int bOutputColorMode, int aspec, int Colorimetry, int pixelrep)
+{
+	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
+//     AVI_InfoFrame AviInfo;
+
+}
+
+int cat66121_hdmi_sys_config_video(struct hdmi_video_para *vpara)
+{
+	HDMITX_ChangeDisplayOption(vpara->vic,HDMI_RGB444) ;
+	return HDMI_ERROR_SUCESS;
+}
+
+static void cat66121_hdmi_config_aai(void)
+{
+	printk( "[%s]\n", __FUNCTION__);
+}
+
+int cat66121_hdmi_sys_config_audio(struct hdmi_audio *audio)
+{
+	printk( "[%s]\n", __FUNCTION__);
+	return HDMI_ERROR_SUCESS;
+}
+
+void cat66121_hdmi_sys_enalbe_output(int enable)
+{
+	
+	printk( "[%s]\n", __FUNCTION__);
+}
+
+int cat66121_hdmi_sys_insert(void)
+{
+	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
+	printk( "[%s]\n", __FUNCTION__);
+	return 0;
+}
+
+int cat66121_hdmi_sys_remove(void)
+{
+	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
+//	printk( "[%s]\n", __FUNCTION__);
+
+	return 0;
+}
diff --git a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_sys.c b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_sys.c
index c8b158228365..11f0f2875efe 100644
--- a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_sys.c
+++ b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_sys.c
@@ -1,217 +1,217 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   >cat66121_sys.c<
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2009/08/24
-//   @fileversion: cat66121_SAMPLEINTERFACE_1.12
-//******************************************/
-
-///////////////////////////////////////////////////////////////////////////////
-// This is the sample program for cat66121 driver usage.
-///////////////////////////////////////////////////////////////////////////////
-
-#include "hdmitx.h"
-#include "hdmitx_sys.h"
-#include "cat66121_hdmi.h"
-
-#if 0
-BYTE HDMITX_ReadI2C_Byte(BYTE RegAddr);
-SYS_STATUS HDMITX_WriteI2C_Byte(BYTE RegAddr,BYTE d);
-SYS_STATUS HDMITX_ReadI2C_ByteN(BYTE RegAddr,BYTE *pData,int N);
-SYS_STATUS HDMITX_WriteI2C_ByteN(BYTE RegAddr,BYTE *pData,int N);
-SYS_STATUS HDMITX_SetI2C_Byte(BYTE Reg,BYTE Mask,BYTE Value);
-#endif
-/* I2C read/write funcs */
-BYTE HDMITX_ReadI2C_Byte(BYTE RegAddr)
-{
-	struct i2c_msg msgs[2];
-	SYS_STATUS ret = -1;
-	BYTE buf[1];
-
-	buf[0] = RegAddr;
-
-	/* Write device addr fisrt */
-	msgs[0].addr	= cat66121_hdmi->client->addr;
-	msgs[0].flags	= !I2C_M_RD;
-	msgs[0].len		= 1;
-	msgs[0].buf		= &buf[0];
-	msgs[0].scl_rate= 100*1000;
-	/* Then, begin to read data */
-	msgs[1].addr	= cat66121_hdmi->client->addr;
-	msgs[1].flags	= I2C_M_RD;
-	msgs[1].len		= 1;
-	msgs[1].buf		= &buf[0];
-	msgs[1].scl_rate= 100*1000;
-	
-	ret = i2c_transfer(cat66121_hdmi->client->adapter, msgs, 2);
-	if(ret != 2)
-		printk("I2C transfer Error! ret = %d\n", ret);
-
-	//ErrorF("Reg%02xH: 0x%02x\n", RegAddr, buf[0]);
-	return buf[0];
-}
-
-SYS_STATUS HDMITX_WriteI2C_Byte(BYTE RegAddr, BYTE data)
-{
-	struct i2c_msg msg;
-	SYS_STATUS ret = -1;
-	BYTE buf[2];
-
-	buf[0] = RegAddr;
-	buf[1] = data;
-
-	msg.addr	= cat66121_hdmi->client->addr;
-	msg.flags	= !I2C_M_RD;
-	msg.len		= 2;
-	msg.buf		= buf;		
-	msg.scl_rate= 100*1000;
-	
-	ret = i2c_transfer(cat66121_hdmi->client->adapter, &msg, 1);
-	if(ret != 1)
-		printk("I2C transfer Error!\n");
-
-	return ret;
-}
-
-SYS_STATUS HDMITX_ReadI2C_ByteN(BYTE RegAddr, BYTE *pData, int N)
-{
-	struct i2c_msg msgs[2];
-	SYS_STATUS ret = -1;
-
-	pData[0] = RegAddr;
-
-	msgs[0].addr	= cat66121_hdmi->client->addr;
-	msgs[0].flags	= !I2C_M_RD;
-	msgs[0].len		= 1;
-	msgs[0].buf		= &pData[0];
-	msgs[0].scl_rate= 100*1000;
-
-	msgs[1].addr	= cat66121_hdmi->client->addr;
-	msgs[1].flags	= I2C_M_RD;
-	msgs[1].len		= N;
-	msgs[1].buf		= pData;
-	msgs[1].scl_rate= 100*1000;
-	
-	ret = i2c_transfer(cat66121_hdmi->client->adapter, msgs, 2);
-	if(ret != 2)
-		printk("I2C transfer Error! ret = %d\n", ret);
-
-	return ret;
-}
-
-SYS_STATUS HDMITX_WriteI2C_ByteN(BYTE RegAddr, BYTE *pData, int N)
-{
-	struct i2c_msg msg;
-	SYS_STATUS ret = -1;
-	BYTE buf[N + 1];
-
-	buf[0] = RegAddr;
-    memcpy(&buf[1], pData, N);
-
-	msg.addr	= cat66121_hdmi->client->addr;
-	msg.flags	= !I2C_M_RD;
-	msg.len		= N + 1;
-	msg.buf		= buf;		// gModify.Exp."Include RegAddr"
-	msg.scl_rate= 100*1000;
-	
-	ret = i2c_transfer(cat66121_hdmi->client->adapter, &msg, 1);
-	if(ret != 1)
-		printk("I2C transfer Error! ret = %d\n", ret);
-
-	return ret;
-}
-static int cat66121_hdmi_i2c_read_reg(char reg, char *val)
-{
-	if(i2c_master_reg8_recv(cat66121_hdmi->client, reg, val, 1, 100*1000) > 0)
-		return  0;
-	else {
-		printk("[%s] reg %02x error\n", __FUNCTION__, reg);
-		return -EINVAL;
-	}
-}
-/*******************************
- * Global Data
- ******************************/
-
-/*******************************
- * Functions
- ******************************/
-int cat66121_detect_device(void)
-{
-	printk(">>>%s \n",__func__);
-	return 0;
-}
-
-int cat66121_sys_init(struct hdmi *hdmi)
-{
-	printk(">>>%s \n",__func__);
-	InitHDMITX_Variable();
-	InitHDMITX();
-	HDMITX_ChangeDisplayOption(HDMI_720p60,HDMI_RGB444) ;
-            HDMITX_DevLoopProc();
-	return HDMI_ERROR_SUCESS;
-}
-
-int cat66121_sys_unplug(struct hdmi *hdmi)
-{
-	printk(">>>%s \n",__func__);
-	return HDMI_ERROR_SUCESS;
-}
-
-int cat66121_sys_detect_hpd(struct hdmi *hdmi, int *hpdstatus)
-{
-	printk(">>>%s \n",__func__);
-    *hpdstatus = TRUE;
-    
-    return HDMI_ERROR_SUCESS;
-}
-
-int cat66121_sys_detect_sink(struct hdmi *hdmi, int *sink_status)
-{
-	printk(">>>%s \n",__func__);
-    *sink_status = TRUE;
-    return HDMI_ERROR_SUCESS;
-}
-
-int cat66121_sys_read_edid(struct hdmi *hdmi, int block, unsigned char *buff)
-{
-	printk(">>>%s \n",__func__);
-	return HDMI_ERROR_SUCESS;
-}
-
-static void cat66121_sys_config_avi(int VIC, int bOutputColorMode, int aspec, int Colorimetry, int pixelrep)
-{
-}
-
-int cat66121_sys_config_video(struct hdmi *hdmi, int vic, int input_color, int output_color)
-{
-	printk(">>>%s \n",__func__);
-            HDMITX_DevLoopProc();
-	return HDMI_ERROR_SUCESS ;
-}
-
-static void cat66121_sys_config_aai(void)
-{
-	printk(">>>%s \n",__func__);
-}
-
-int cat66121_sys_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
-{
-	printk(">>>%s \n",__func__);
-	return HDMI_ERROR_SUCESS;
-}
-
-int cat66121_sys_config_hdcp(struct hdmi *hdmi, int enable)
-{
-	printk(">>>%s \n",__func__);
-	return HDMI_ERROR_SUCESS;
-}
-
-int cat66121_sys_enalbe_output(struct hdmi *hdmi, int enable)
-{
-	printk(">>>%s \n",__func__);
-	return HDMI_ERROR_SUCESS;
-}
+///*****************************************
+//  Copyright (C) 2009-2014
+//  ITE Tech. Inc. All Rights Reserved
+//  Proprietary and Confidential
+///*****************************************
+//   @file   >cat66121_sys.c<
+//   @author Jau-Chih.Tseng@ite.com.tw
+//   @date   2009/08/24
+//   @fileversion: cat66121_SAMPLEINTERFACE_1.12
+//******************************************/
+
+///////////////////////////////////////////////////////////////////////////////
+// This is the sample program for cat66121 driver usage.
+///////////////////////////////////////////////////////////////////////////////
+
+#include "hdmitx.h"
+#include "hdmitx_sys.h"
+#include "cat66121_hdmi.h"
+
+#if 0
+BYTE HDMITX_ReadI2C_Byte(BYTE RegAddr);
+SYS_STATUS HDMITX_WriteI2C_Byte(BYTE RegAddr,BYTE d);
+SYS_STATUS HDMITX_ReadI2C_ByteN(BYTE RegAddr,BYTE *pData,int N);
+SYS_STATUS HDMITX_WriteI2C_ByteN(BYTE RegAddr,BYTE *pData,int N);
+SYS_STATUS HDMITX_SetI2C_Byte(BYTE Reg,BYTE Mask,BYTE Value);
+#endif
+/* I2C read/write funcs */
+BYTE HDMITX_ReadI2C_Byte(BYTE RegAddr)
+{
+	struct i2c_msg msgs[2];
+	SYS_STATUS ret = -1;
+	BYTE buf[1];
+
+	buf[0] = RegAddr;
+
+	/* Write device addr fisrt */
+	msgs[0].addr	= cat66121_hdmi->client->addr;
+	msgs[0].flags	= !I2C_M_RD;
+	msgs[0].len		= 1;
+	msgs[0].buf		= &buf[0];
+	msgs[0].scl_rate= 100*1000;
+	/* Then, begin to read data */
+	msgs[1].addr	= cat66121_hdmi->client->addr;
+	msgs[1].flags	= I2C_M_RD;
+	msgs[1].len		= 1;
+	msgs[1].buf		= &buf[0];
+	msgs[1].scl_rate= 100*1000;
+	
+	ret = i2c_transfer(cat66121_hdmi->client->adapter, msgs, 2);
+	if(ret != 2)
+		printk("I2C transfer Error! ret = %d\n", ret);
+
+	//ErrorF("Reg%02xH: 0x%02x\n", RegAddr, buf[0]);
+	return buf[0];
+}
+
+SYS_STATUS HDMITX_WriteI2C_Byte(BYTE RegAddr, BYTE data)
+{
+	struct i2c_msg msg;
+	SYS_STATUS ret = -1;
+	BYTE buf[2];
+
+	buf[0] = RegAddr;
+	buf[1] = data;
+
+	msg.addr	= cat66121_hdmi->client->addr;
+	msg.flags	= !I2C_M_RD;
+	msg.len		= 2;
+	msg.buf		= buf;		
+	msg.scl_rate= 100*1000;
+	
+	ret = i2c_transfer(cat66121_hdmi->client->adapter, &msg, 1);
+	if(ret != 1)
+		printk("I2C transfer Error!\n");
+
+	return ret;
+}
+
+SYS_STATUS HDMITX_ReadI2C_ByteN(BYTE RegAddr, BYTE *pData, int N)
+{
+	struct i2c_msg msgs[2];
+	SYS_STATUS ret = -1;
+
+	pData[0] = RegAddr;
+
+	msgs[0].addr	= cat66121_hdmi->client->addr;
+	msgs[0].flags	= !I2C_M_RD;
+	msgs[0].len		= 1;
+	msgs[0].buf		= &pData[0];
+	msgs[0].scl_rate= 100*1000;
+
+	msgs[1].addr	= cat66121_hdmi->client->addr;
+	msgs[1].flags	= I2C_M_RD;
+	msgs[1].len		= N;
+	msgs[1].buf		= pData;
+	msgs[1].scl_rate= 100*1000;
+	
+	ret = i2c_transfer(cat66121_hdmi->client->adapter, msgs, 2);
+	if(ret != 2)
+		printk("I2C transfer Error! ret = %d\n", ret);
+
+	return ret;
+}
+
+SYS_STATUS HDMITX_WriteI2C_ByteN(BYTE RegAddr, BYTE *pData, int N)
+{
+	struct i2c_msg msg;
+	SYS_STATUS ret = -1;
+	BYTE buf[N + 1];
+
+	buf[0] = RegAddr;
+    memcpy(&buf[1], pData, N);
+
+	msg.addr	= cat66121_hdmi->client->addr;
+	msg.flags	= !I2C_M_RD;
+	msg.len		= N + 1;
+	msg.buf		= buf;		// gModify.Exp."Include RegAddr"
+	msg.scl_rate= 100*1000;
+	
+	ret = i2c_transfer(cat66121_hdmi->client->adapter, &msg, 1);
+	if(ret != 1)
+		printk("I2C transfer Error! ret = %d\n", ret);
+
+	return ret;
+}
+static int cat66121_hdmi_i2c_read_reg(char reg, char *val)
+{
+	if(i2c_master_reg8_recv(cat66121_hdmi->client, reg, val, 1, 100*1000) > 0)
+		return  0;
+	else {
+		printk("[%s] reg %02x error\n", __FUNCTION__, reg);
+		return -EINVAL;
+	}
+}
+/*******************************
+ * Global Data
+ ******************************/
+
+/*******************************
+ * Functions
+ ******************************/
+int cat66121_detect_device(void)
+{
+	printk(">>>%s \n",__func__);
+	return 0;
+}
+
+int cat66121_sys_init(struct hdmi *hdmi)
+{
+	printk(">>>%s \n",__func__);
+	InitHDMITX_Variable();
+	InitHDMITX();
+	HDMITX_ChangeDisplayOption(HDMI_720p60,HDMI_RGB444) ;
+            HDMITX_DevLoopProc();
+	return HDMI_ERROR_SUCESS;
+}
+
+int cat66121_sys_unplug(struct hdmi *hdmi)
+{
+	printk(">>>%s \n",__func__);
+	return HDMI_ERROR_SUCESS;
+}
+
+int cat66121_sys_detect_hpd(struct hdmi *hdmi, int *hpdstatus)
+{
+	printk(">>>%s \n",__func__);
+    *hpdstatus = TRUE;
+    
+    return HDMI_ERROR_SUCESS;
+}
+
+int cat66121_sys_detect_sink(struct hdmi *hdmi, int *sink_status)
+{
+	printk(">>>%s \n",__func__);
+    *sink_status = TRUE;
+    return HDMI_ERROR_SUCESS;
+}
+
+int cat66121_sys_read_edid(struct hdmi *hdmi, int block, unsigned char *buff)
+{
+	printk(">>>%s \n",__func__);
+	return HDMI_ERROR_SUCESS;
+}
+
+static void cat66121_sys_config_avi(int VIC, int bOutputColorMode, int aspec, int Colorimetry, int pixelrep)
+{
+}
+
+int cat66121_sys_config_video(struct hdmi *hdmi, int vic, int input_color, int output_color)
+{
+	printk(">>>%s \n",__func__);
+            HDMITX_DevLoopProc();
+	return HDMI_ERROR_SUCESS ;
+}
+
+static void cat66121_sys_config_aai(void)
+{
+	printk(">>>%s \n",__func__);
+}
+
+int cat66121_sys_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio)
+{
+	printk(">>>%s \n",__func__);
+	return HDMI_ERROR_SUCESS;
+}
+
+int cat66121_sys_config_hdcp(struct hdmi *hdmi, int enable)
+{
+	printk(">>>%s \n",__func__);
+	return HDMI_ERROR_SUCESS;
+}
+
+int cat66121_sys_enalbe_output(struct hdmi *hdmi, int enable)
+{
+	printk(">>>%s \n",__func__);
+	return HDMI_ERROR_SUCESS;
+}
diff --git a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_sys.h b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_sys.h
index 38f1c9a67833..8d3994b4c76b 100755
--- a/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_sys.h
+++ b/drivers/video/rockchip/hdmi/chips/cat66121/cat66121_sys.h
@@ -1,164 +1,164 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   >cat66121_sys.h<
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2009/08/24
-//   @fileversion: cat66121_SAMPLEINTERFACE_1.12
-//******************************************/
-
-#ifndef _CAT66121_SYS_H_
-#define _CAT66121_SYS_H_
-////////////////////////////////////////////////////////////////////////////////
-// Internal Data Type
-////////////////////////////////////////////////////////////////////////////////
-
-typedef enum tagHDMI_Video_Type {
-    HDMI_Unkown = 0 ,
-    HDMI_640x480p60 = 1 ,
-    HDMI_480p60,
-    HDMI_480p60_16x9,
-    HDMI_720p60,
-    HDMI_1080i60,
-    HDMI_480i60,
-    HDMI_480i60_16x9,
-    HDMI_1080p60 = 16,
-    HDMI_576p50,
-    HDMI_576p50_16x9,
-    HDMI_720p50,
-    HDMI_1080i50,
-    HDMI_576i50,
-    HDMI_576i50_16x9,
-    HDMI_1080p50 = 31,
-    HDMI_1080p24,
-    HDMI_1080p25,
-    HDMI_1080p30,
-} HDMI_Video_Type ;
-
-typedef enum tagHDMI_Aspec {
-    HDMI_4x3 ,
-    HDMI_16x9
-} HDMI_Aspec;
-
-typedef enum tagHDMI_OutputColorMode {
-    HDMI_RGB444,
-    HDMI_YUV444,
-    HDMI_YUV422
-} HDMI_OutputColorMode ;
-
-typedef enum tagHDMI_Colorimetry {
-    HDMI_ITU601,
-    HDMI_ITU709
-} HDMI_Colorimetry ;
-
-typedef enum tagMODE_ID{    
-	CEA_640x480p60,	
-	CEA_720x480p60,		
-	CEA_1280x720p60,		
-	CEA_1920x1080i60,		
-	CEA_720x480i60,		
-	CEA_720x240p60,		
-	CEA_1440x480i60,		
-	CEA_1440x240p60,		
-	CEA_2880x480i60,		
-	CEA_2880x240p60,		
-	CEA_1440x480p60,		
-	CEA_1920x1080p60,
-	CEA_720x576p50,		
-	CEA_1280x720p50,		
-	CEA_1920x1080i50,		
-	CEA_720x576i50,		
-	CEA_1440x576i50,		
-	CEA_720x288p50,		
-	CEA_1440x288p50,
-	CEA_2880x576i50,
-	CEA_2880x288p50,
-	CEA_1440x576p50,
-	CEA_1920x1080p50,
-	CEA_1920x1080p24,
-	CEA_1920x1080p25,
-	CEA_1920x1080p30,
-	VESA_640x350p85,
-	VESA_640x400p85,
-	VESA_720x400p85,
-	VESA_640x480p60,
-	VESA_640x480p72,
-	VESA_640x480p75,
-	VESA_640x480p85,
-	VESA_800x600p56,
-	VESA_800x600p60,
-	VESA_800x600p72,
-	VESA_800x600p75,
-	VESA_800X600p85,
-	VESA_840X480p60,
-	VESA_1024x768p60,
-	VESA_1024x768p70,
-	VESA_1024x768p75,
-	VESA_1024x768p85,
-	VESA_1152x864p75,
-	VESA_1280x768p60R,
-	VESA_1280x768p60,
-	VESA_1280x768p75,
-	VESA_1280x768p85,
-	VESA_1280x960p60,
-	VESA_1280x960p85,
-	VESA_1280x1024p60,
-	VESA_1280x1024p75,
-	VESA_1280X1024p85,
-	VESA_1360X768p60,
-	VESA_1400x768p60R,
-	VESA_1400x768p60,
-	VESA_1400x1050p75,
-	VESA_1400x1050p85,
-	VESA_1440x900p60R,
-	VESA_1440x900p60,
-	VESA_1440x900p75,
-	VESA_1440x900p85,
-	VESA_1600x1200p60,
-	VESA_1600x1200p65,
-	VESA_1600x1200p70,
-	VESA_1600x1200p75,
-	VESA_1600x1200p85,
-	VESA_1680x1050p60R,
-	VESA_1680x1050p60,
-	VESA_1680x1050p75,
-	VESA_1680x1050p85,
-	VESA_1792x1344p60,
-	VESA_1792x1344p75,
-	VESA_1856x1392p60,
-	VESA_1856x1392p75,
-	VESA_1920x1200p60R,
-	VESA_1920x1200p60,
-	VESA_1920x1200p75,
-	VESA_1920x1200p85,
-	VESA_1920x1440p60,
-	VESA_1920x1440p75,
-	UNKNOWN_MODE    
-} MODE_ID;
-///////////////////////////////////////////////////////////////////////
-// Output Mode Type
-///////////////////////////////////////////////////////////////////////
-
-#define RES_ASPEC_4x3 0
-#define RES_ASPEC_16x9 1
-#define F_MODE_REPT_NO 0
-#define F_MODE_REPT_TWICE 1
-#define F_MODE_REPT_QUATRO 3
-#define F_MODE_CSC_ITU601 0
-#define F_MODE_CSC_ITU709 1
-
-/* Follow prototypes need accomplish by ourself */
-int cat66121_detect_device(void);
-int cat66121_sys_init(struct hdmi *hdmi);
-int cat66121_sys_unplug(struct hdmi *hdmi);
-int cat66121_sys_detect_hpd(struct hdmi *hdmi, int *hpdstatus);
-int cat66121_sys_detect_sink(struct hdmi *hdmi, int *sink_status);
-int cat66121_sys_read_edid(struct hdmi *hdmi, int block, unsigned char *buff);
-int cat66121_sys_config_video(struct hdmi *hdmi, int vic, int input_color, int output_color);
-int cat66121_sys_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio);
-int cat66121_sys_config_hdcp(struct hdmi *hdmi, int enable);
-int cat66121_sys_enalbe_output(struct hdmi *hdmi, int enable);
-int cat66121_sys_check_status(struct hdmi *hdmi);
-#endif // _cat66121_SYS_H_
+///*****************************************
+//  Copyright (C) 2009-2014
+//  ITE Tech. Inc. All Rights Reserved
+//  Proprietary and Confidential
+///*****************************************
+//   @file   >cat66121_sys.h<
+//   @author Jau-Chih.Tseng@ite.com.tw
+//   @date   2009/08/24
+//   @fileversion: cat66121_SAMPLEINTERFACE_1.12
+//******************************************/
+
+#ifndef _CAT66121_SYS_H_
+#define _CAT66121_SYS_H_
+////////////////////////////////////////////////////////////////////////////////
+// Internal Data Type
+////////////////////////////////////////////////////////////////////////////////
+
+typedef enum tagHDMI_Video_Type {
+    HDMI_Unkown = 0 ,
+    HDMI_640x480p60 = 1 ,
+    HDMI_480p60,
+    HDMI_480p60_16x9,
+    HDMI_720p60,
+    HDMI_1080i60,
+    HDMI_480i60,
+    HDMI_480i60_16x9,
+    HDMI_1080p60 = 16,
+    HDMI_576p50,
+    HDMI_576p50_16x9,
+    HDMI_720p50,
+    HDMI_1080i50,
+    HDMI_576i50,
+    HDMI_576i50_16x9,
+    HDMI_1080p50 = 31,
+    HDMI_1080p24,
+    HDMI_1080p25,
+    HDMI_1080p30,
+} HDMI_Video_Type ;
+
+typedef enum tagHDMI_Aspec {
+    HDMI_4x3 ,
+    HDMI_16x9
+} HDMI_Aspec;
+
+typedef enum tagHDMI_OutputColorMode {
+    HDMI_RGB444,
+    HDMI_YUV444,
+    HDMI_YUV422
+} HDMI_OutputColorMode ;
+
+typedef enum tagHDMI_Colorimetry {
+    HDMI_ITU601,
+    HDMI_ITU709
+} HDMI_Colorimetry ;
+
+typedef enum tagMODE_ID{    
+	CEA_640x480p60,	
+	CEA_720x480p60,		
+	CEA_1280x720p60,		
+	CEA_1920x1080i60,		
+	CEA_720x480i60,		
+	CEA_720x240p60,		
+	CEA_1440x480i60,		
+	CEA_1440x240p60,		
+	CEA_2880x480i60,		
+	CEA_2880x240p60,		
+	CEA_1440x480p60,		
+	CEA_1920x1080p60,
+	CEA_720x576p50,		
+	CEA_1280x720p50,		
+	CEA_1920x1080i50,		
+	CEA_720x576i50,		
+	CEA_1440x576i50,		
+	CEA_720x288p50,		
+	CEA_1440x288p50,
+	CEA_2880x576i50,
+	CEA_2880x288p50,
+	CEA_1440x576p50,
+	CEA_1920x1080p50,
+	CEA_1920x1080p24,
+	CEA_1920x1080p25,
+	CEA_1920x1080p30,
+	VESA_640x350p85,
+	VESA_640x400p85,
+	VESA_720x400p85,
+	VESA_640x480p60,
+	VESA_640x480p72,
+	VESA_640x480p75,
+	VESA_640x480p85,
+	VESA_800x600p56,
+	VESA_800x600p60,
+	VESA_800x600p72,
+	VESA_800x600p75,
+	VESA_800X600p85,
+	VESA_840X480p60,
+	VESA_1024x768p60,
+	VESA_1024x768p70,
+	VESA_1024x768p75,
+	VESA_1024x768p85,
+	VESA_1152x864p75,
+	VESA_1280x768p60R,
+	VESA_1280x768p60,
+	VESA_1280x768p75,
+	VESA_1280x768p85,
+	VESA_1280x960p60,
+	VESA_1280x960p85,
+	VESA_1280x1024p60,
+	VESA_1280x1024p75,
+	VESA_1280X1024p85,
+	VESA_1360X768p60,
+	VESA_1400x768p60R,
+	VESA_1400x768p60,
+	VESA_1400x1050p75,
+	VESA_1400x1050p85,
+	VESA_1440x900p60R,
+	VESA_1440x900p60,
+	VESA_1440x900p75,
+	VESA_1440x900p85,
+	VESA_1600x1200p60,
+	VESA_1600x1200p65,
+	VESA_1600x1200p70,
+	VESA_1600x1200p75,
+	VESA_1600x1200p85,
+	VESA_1680x1050p60R,
+	VESA_1680x1050p60,
+	VESA_1680x1050p75,
+	VESA_1680x1050p85,
+	VESA_1792x1344p60,
+	VESA_1792x1344p75,
+	VESA_1856x1392p60,
+	VESA_1856x1392p75,
+	VESA_1920x1200p60R,
+	VESA_1920x1200p60,
+	VESA_1920x1200p75,
+	VESA_1920x1200p85,
+	VESA_1920x1440p60,
+	VESA_1920x1440p75,
+	UNKNOWN_MODE    
+} MODE_ID;
+///////////////////////////////////////////////////////////////////////
+// Output Mode Type
+///////////////////////////////////////////////////////////////////////
+
+#define RES_ASPEC_4x3 0
+#define RES_ASPEC_16x9 1
+#define F_MODE_REPT_NO 0
+#define F_MODE_REPT_TWICE 1
+#define F_MODE_REPT_QUATRO 3
+#define F_MODE_CSC_ITU601 0
+#define F_MODE_CSC_ITU709 1
+
+/* Follow prototypes need accomplish by ourself */
+int cat66121_detect_device(void);
+int cat66121_sys_init(struct hdmi *hdmi);
+int cat66121_sys_unplug(struct hdmi *hdmi);
+int cat66121_sys_detect_hpd(struct hdmi *hdmi, int *hpdstatus);
+int cat66121_sys_detect_sink(struct hdmi *hdmi, int *sink_status);
+int cat66121_sys_read_edid(struct hdmi *hdmi, int block, unsigned char *buff);
+int cat66121_sys_config_video(struct hdmi *hdmi, int vic, int input_color, int output_color);
+int cat66121_sys_config_audio(struct hdmi *hdmi, struct hdmi_audio *audio);
+int cat66121_sys_config_hdcp(struct hdmi *hdmi, int enable);
+int cat66121_sys_enalbe_output(struct hdmi *hdmi, int enable);
+int cat66121_sys_check_status(struct hdmi *hdmi);
+#endif // _cat66121_SYS_H_
diff --git a/drivers/video/rockchip/hdmi/chips/cat66121/config.h b/drivers/video/rockchip/hdmi/chips/cat66121/config.h
index 681d29640bc8..b30af5e15a7b 100755
--- a/drivers/video/rockchip/hdmi/chips/cat66121/config.h
+++ b/drivers/video/rockchip/hdmi/chips/cat66121/config.h
@@ -1,138 +1,138 @@
-///*****************************************
-//  Copyright (C) 2009-2014
-//  ITE Tech. Inc. All Rights Reserved
-//  Proprietary and Confidential
-///*****************************************
-//   @file   <config.h>
-//   @author Jau-Chih.Tseng@ite.com.tw
-//   @date   2012/12/20
-//   @fileversion: ITE_HDMITX_SAMPLE_3.14
-//******************************************/
-#ifndef _CONFIG_H_
-#define _CONFIG_H_
-#pragma message("config.h")
-
-#ifdef EXTERN_HDCPROM
-#pragma message("Defined EXTERN_HDCPROM")
-#endif // EXTERN_HDCPROM
-
-#define SUPPORT_EDID
-//#define SUPPORT_HDCP
-//#define SUPPORT_SHA
-//#define SUPPORT_AUDIO_MONITOR
-#define AudioOutDelayCnt 250
-
-
-
-//////////////////////////////////////////////////////////////////////////////////////////
-// Video Configuration
-//////////////////////////////////////////////////////////////////////////////////////////
-// 2010/01/26 added a option to disable HDCP.
-#define SUPPORT_OUTPUTYUV
-#define SUPPORT_OUTPUTRGB
-// #define DISABLE_HDMITX_CSC
-
-#define SUPPORT_INPUTRGB
-#define SUPPORT_INPUTYUV444
-#define SUPPORT_INPUTYUV422
-// #define SUPPORT_SYNCEMBEDDED
-// #define SUPPORT_DEGEN
-#define NON_SEQUENTIAL_YCBCR422
-
-
-
-#define INPUT_COLOR_MODE F_MODE_RGB444
-//#define INPUT_COLOR_MODE F_MODE_YUV422
-//#define INPUT_COLOR_MODE F_MODE_YUV444
-
-#define INPUT_COLOR_DEPTH 24
-// #define INPUT_COLOR_DEPTH 30
-// #define INPUT_COLOR_DEPTH 36
-
-//#define OUTPUT_COLOR_MODE F_MODE_YUV422
-//#define OUTPUT_COLOR_MODE F_MODE_YUV444
-#define OUTPUT_COLOR_MODE F_MODE_RGB444
-
-//#define OUTPUT_3D_MODE Frame_Pcaking
-//#define OUTPUT_3D_MODE Top_and_Botton
-//#define OUTPUT_3D_MODE Side_by_Side
-
-// #define INV_INPUT_ACLK
-#define INV_INPUT_PCLK
-
-#ifdef SUPPORT_SYNCEMBEDDED
-    // #define INPUT_SIGNAL_TYPE (T_MODE_SYNCEMB)                 // 16 bit sync embedded
-    // #define INPUT_SIGNAL_TYPE (T_MODE_SYNCEMB | T_MODE_CCIR656) // 8 bit sync embedded
-    #define INPUT_SIGNAL_TYPE (T_MODE_SYNCEMB|T_MODE_INDDR|T_MODE_PCLKDIV2) // 16 bit sync embedded DDR
-    // #define INPUT_SIGNAL_TYPE (T_MODE_SYNCEMB|T_MODE_INDDR)      // 8  bit sync embedded DDR
-
-    #define SUPPORT_INPUTYUV422
-    #ifdef INPUT_COLOR_MODE
-    #undef INPUT_COLOR_MODE
-    #endif // INPUT_COLOR_MODE
-    #define INPUT_COLOR_MODE F_MODE_YUV422
-#else
-    #pragma message ("Defined seperated sync.")
-    #define INPUT_SIGNAL_TYPE 0 // 24 bit sync seperate
-    //#define INPUT_SIGNAL_TYPE ( T_MODE_DEGEN )
-    //#define INPUT_SIGNAL_TYPE ( T_MODE_INDDR)
-    //#define INPUT_SIGNAL_TYPE ( T_MODE_SYNCEMB)
-    //#define INPUT_SIGNAL_TYPE ( T_MODE_CCIR656 | T_MODE_SYNCEMB )
-#endif
-
-
-#if defined(SUPPORT_INPUTYUV444) || defined(SUPPORT_INPUTYUV422)
-#define SUPPORT_INPUTYUV
-#endif
-
-#ifdef SUPPORT_SYNCEMBEDDED
-#pragma message("defined SUPPORT_SYNCEMBEDDED for Sync Embedded timing input or CCIR656 input.")
-#endif
-
-
-//////////////////////////////////////////////////////////////////////////////////////////
-// Audio Configuration
-//////////////////////////////////////////////////////////////////////////////////////////
-
-// #define SUPPORT_HBR_AUDIO
-#define USE_SPDIF_CHSTAT
-#ifndef SUPPORT_HBR_AUDIO
-    #define INPUT_SAMPLE_FREQ AUDFS_48KHz
-    #define INPUT_SAMPLE_FREQ_HZ 48000L
-    #define OUTPUT_CHANNEL 2 // 3 // 4 // 5//6 //7 //8
-
-    #define CNOFIG_INPUT_AUDIO_TYPE T_AUDIO_LPCM
-    // #define CNOFIG_INPUT_AUDIO_TYPE T_AUDIO_NLPCM
-    #define CONFIG_INPUT_AUDIO_SPDIF FALSE // I2S
-    // #define CONFIG_INPUT_AUDIO_SPDIF TRUE // SPDIF
-
-    // #define I2S_FORMAT 0x00 // 24bit I2S audio
-    #define I2S_FORMAT 0x01 // 32bit I2S audio
-    // #define I2S_FORMAT 0x02 // 24bit I2S audio, right justify
-    // #define I2S_FORMAT 0x03 // 32bit I2S audio, right justify
-
-#else // SUPPORT_HBR_AUDIO
-
-    #define INPUT_SAMPLE_FREQ AUDFS_768KHz
-    #define INPUT_SAMPLE_FREQ_HZ 768000L
-    #define OUTPUT_CHANNEL 8
-    #define CNOFIG_INPUT_AUDIO_TYPE T_AUDIO_HBR
-    #define CONFIG_INPUT_AUDIO_SPDIF FALSE // I2S
-    // #define CONFIG_INPUT_AUDIO_SPDIF TRUE // SPDIF
-    #define I2S_FORMAT 0x47 // 32bit audio
-#endif
-
-
-
-//////////////////////////////////////////////////////////////////////////////////////////
-// Audio Monitor Configuration
-//////////////////////////////////////////////////////////////////////////////////////////
-// #define HDMITX_AUTO_MONITOR_INPUT
-// #define HDMITX_INPUT_INFO
-
-#ifdef  HDMITX_AUTO_MONITOR_INPUT
-#define HDMITX_INPUT_INFO
-#endif
-
-
-#endif
+///*****************************************
+//  Copyright (C) 2009-2014
+//  ITE Tech. Inc. All Rights Reserved
+//  Proprietary and Confidential
+///*****************************************
+//   @file   <config.h>
+//   @author Jau-Chih.Tseng@ite.com.tw
+//   @date   2012/12/20
+//   @fileversion: ITE_HDMITX_SAMPLE_3.14
+//******************************************/
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+#pragma message("config.h")
+
+#ifdef EXTERN_HDCPROM
+#pragma message("Defined EXTERN_HDCPROM")
+#endif // EXTERN_HDCPROM
+
+#define SUPPORT_EDID
+//#define SUPPORT_HDCP
+//#define SUPPORT_SHA
+//#define SUPPORT_AUDIO_MONITOR
+#define AudioOutDelayCnt 250
+
+
+
+//////////////////////////////////////////////////////////////////////////////////////////
+// Video Configuration
+//////////////////////////////////////////////////////////////////////////////////////////
+// 2010/01/26 added a option to disable HDCP.
+#define SUPPORT_OUTPUTYUV
+#define SUPPORT_OUTPUTRGB
+// #define DISABLE_HDMITX_CSC
+
+#define SUPPORT_INPUTRGB
+#define SUPPORT_INPUTYUV444
+#define SUPPORT_INPUTYUV422
+// #define SUPPORT_SYNCEMBEDDED
+// #define SUPPORT_DEGEN
+#define NON_SEQUENTIAL_YCBCR422
+
+
+
+#define INPUT_COLOR_MODE F_MODE_RGB444
+//#define INPUT_COLOR_MODE F_MODE_YUV422
+//#define INPUT_COLOR_MODE F_MODE_YUV444
+
+#define INPUT_COLOR_DEPTH 24
+// #define INPUT_COLOR_DEPTH 30
+// #define INPUT_COLOR_DEPTH 36
+
+//#define OUTPUT_COLOR_MODE F_MODE_YUV422
+//#define OUTPUT_COLOR_MODE F_MODE_YUV444
+#define OUTPUT_COLOR_MODE F_MODE_RGB444
+
+//#define OUTPUT_3D_MODE Frame_Pcaking
+//#define OUTPUT_3D_MODE Top_and_Botton
+//#define OUTPUT_3D_MODE Side_by_Side
+
+// #define INV_INPUT_ACLK
+#define INV_INPUT_PCLK
+
+#ifdef SUPPORT_SYNCEMBEDDED
+    // #define INPUT_SIGNAL_TYPE (T_MODE_SYNCEMB)                 // 16 bit sync embedded
+    // #define INPUT_SIGNAL_TYPE (T_MODE_SYNCEMB | T_MODE_CCIR656) // 8 bit sync embedded
+    #define INPUT_SIGNAL_TYPE (T_MODE_SYNCEMB|T_MODE_INDDR|T_MODE_PCLKDIV2) // 16 bit sync embedded DDR
+    // #define INPUT_SIGNAL_TYPE (T_MODE_SYNCEMB|T_MODE_INDDR)      // 8  bit sync embedded DDR
+
+    #define SUPPORT_INPUTYUV422
+    #ifdef INPUT_COLOR_MODE
+    #undef INPUT_COLOR_MODE
+    #endif // INPUT_COLOR_MODE
+    #define INPUT_COLOR_MODE F_MODE_YUV422
+#else
+    #pragma message ("Defined seperated sync.")
+    #define INPUT_SIGNAL_TYPE 0 // 24 bit sync seperate
+    //#define INPUT_SIGNAL_TYPE ( T_MODE_DEGEN )
+    //#define INPUT_SIGNAL_TYPE ( T_MODE_INDDR)
+    //#define INPUT_SIGNAL_TYPE ( T_MODE_SYNCEMB)
+    //#define INPUT_SIGNAL_TYPE ( T_MODE_CCIR656 | T_MODE_SYNCEMB )
+#endif
+
+
+#if defined(SUPPORT_INPUTYUV444) || defined(SUPPORT_INPUTYUV422)
+#define SUPPORT_INPUTYUV
+#endif
+
+#ifdef SUPPORT_SYNCEMBEDDED
+#pragma message("defined SUPPORT_SYNCEMBEDDED for Sync Embedded timing input or CCIR656 input.")
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////////////////////
+// Audio Configuration
+//////////////////////////////////////////////////////////////////////////////////////////
+
+// #define SUPPORT_HBR_AUDIO
+#define USE_SPDIF_CHSTAT
+#ifndef SUPPORT_HBR_AUDIO
+    #define INPUT_SAMPLE_FREQ AUDFS_48KHz
+    #define INPUT_SAMPLE_FREQ_HZ 48000L
+    #define OUTPUT_CHANNEL 2 // 3 // 4 // 5//6 //7 //8
+
+    #define CNOFIG_INPUT_AUDIO_TYPE T_AUDIO_LPCM
+    // #define CNOFIG_INPUT_AUDIO_TYPE T_AUDIO_NLPCM
+    #define CONFIG_INPUT_AUDIO_SPDIF FALSE // I2S
+    // #define CONFIG_INPUT_AUDIO_SPDIF TRUE // SPDIF
+
+    // #define I2S_FORMAT 0x00 // 24bit I2S audio
+    #define I2S_FORMAT 0x01 // 32bit I2S audio
+    // #define I2S_FORMAT 0x02 // 24bit I2S audio, right justify
+    // #define I2S_FORMAT 0x03 // 32bit I2S audio, right justify
+
+#else // SUPPORT_HBR_AUDIO
+
+    #define INPUT_SAMPLE_FREQ AUDFS_768KHz
+    #define INPUT_SAMPLE_FREQ_HZ 768000L
+    #define OUTPUT_CHANNEL 8
+    #define CNOFIG_INPUT_AUDIO_TYPE T_AUDIO_HBR
+    #define CONFIG_INPUT_AUDIO_SPDIF FALSE // I2S
+    // #define CONFIG_INPUT_AUDIO_SPDIF TRUE // SPDIF
+    #define I2S_FORMAT 0x47 // 32bit audio
+#endif
+
+
+
+//////////////////////////////////////////////////////////////////////////////////////////
+// Audio Monitor Configuration
+//////////////////////////////////////////////////////////////////////////////////////////
+// #define HDMITX_AUTO_MONITOR_INPUT
+// #define HDMITX_INPUT_INFO
+
+#ifdef  HDMITX_AUTO_MONITOR_INPUT
+#define HDMITX_INPUT_INFO
+#endif
+
+
+#endif
diff --git a/drivers/video/rockchip/hdmi/rk_hdmi_task.c b/drivers/video/rockchip/hdmi/rk_hdmi_task.c
index 3fe5274551f0..82be97724ff2 100755
--- a/drivers/video/rockchip/hdmi/rk_hdmi_task.c
+++ b/drivers/video/rockchip/hdmi/rk_hdmi_task.c
@@ -16,34 +16,34 @@ static void hdmi_sys_show_state(int state)
 	switch(state)
 	{
 		case HDMI_SLEEP:
-			dev_printk(KERN_INFO, hdmi->dev, "HDMI_SLEEP\n");
+			hdmi_dbg(hdmi->dev, "HDMI_SLEEP\n");
 			break;
 		case HDMI_INITIAL:
-			dev_printk(KERN_INFO, hdmi->dev, "HDMI_INITIAL\n");
+			hdmi_dbg(hdmi->dev, "HDMI_INITIAL\n");
 			break;
 		case WAIT_HOTPLUG:
-			dev_printk(KERN_INFO, hdmi->dev, "WAIT_HOTPLUG\n");
+			hdmi_dbg(hdmi->dev, "WAIT_HOTPLUG\n");
 			break;
 		case READ_PARSE_EDID:
-			dev_printk(KERN_INFO, hdmi->dev, "READ_PARSE_EDID\n");
+			hdmi_dbg(hdmi->dev, "READ_PARSE_EDID\n");
 			break;
 		case WAIT_HDMI_ENABLE:
-			dev_printk(KERN_INFO, hdmi->dev, "WAIT_HDMI_ENABLE\n");
+			hdmi_dbg(hdmi->dev, "WAIT_HDMI_ENABLE\n");
 			break;
 		case SYSTEM_CONFIG:
-			dev_printk(KERN_INFO, hdmi->dev, "SYSTEM_CONFIG\n");
+			hdmi_dbg(hdmi->dev, "SYSTEM_CONFIG\n");
 			break;
 		case CONFIG_VIDEO:
-			dev_printk(KERN_INFO, hdmi->dev, "CONFIG_VIDEO\n");
+			hdmi_dbg(hdmi->dev, "CONFIG_VIDEO\n");
 			break;
 		case CONFIG_AUDIO:
-			dev_printk(KERN_INFO, hdmi->dev, "CONFIG_AUDIO\n");
+			hdmi_dbg(hdmi->dev, "CONFIG_AUDIO\n");
 			break;
 		case PLAY_BACK:
-			dev_printk(KERN_INFO, hdmi->dev, "PLAY_BACK\n");
+			hdmi_dbg(hdmi->dev, "PLAY_BACK\n");
 			break;
 		default:
-			dev_printk(KERN_INFO, hdmi->dev, "Unkown State %d\n", state);
+			hdmi_dbg(hdmi->dev, "Unkown State %d\n", state);
 			break;
 	}
 }
-- 
2.35.3

