From fda2986fecd6e140656d2b20e0ae12be6b425ee0 Mon Sep 17 00:00:00 2001
From: hjc <hjc@rock-chips.com>
Date: Sat, 3 Aug 2013 11:25:49 +0800
Subject: [PATCH] rk3026_86v: add board and defconfig

---
 arch/arm/configs/rk3028a_86v_defconfig        |  433 ++++++
 arch/arm/mach-rk3026/Kconfig                  |    3 +
 arch/arm/mach-rk3026/Makefile                 |    1 +
 .../mach-rk3026/board-rk3028a-86v-camera.c    |  492 +++++++
 .../board-rk3028a-86v-sdmmc-config.c          |  165 +++
 arch/arm/mach-rk3026/board-rk3028a-86v.c      | 1293 +++++++++++++++++
 drivers/video/rockchip/lcdc/rk3188_lcdc.c     |   15 +-
 7 files changed, 2396 insertions(+), 6 deletions(-)
 create mode 100644 arch/arm/configs/rk3028a_86v_defconfig
 create mode 100755 arch/arm/mach-rk3026/board-rk3028a-86v-camera.c
 create mode 100644 arch/arm/mach-rk3026/board-rk3028a-86v-sdmmc-config.c
 create mode 100755 arch/arm/mach-rk3026/board-rk3028a-86v.c

diff --git a/arch/arm/configs/rk3028a_86v_defconfig b/arch/arm/configs/rk3028a_86v_defconfig
new file mode 100644
index 000000000000..3eb6db0ef4ab
--- /dev/null
+++ b/arch/arm/configs/rk3028a_86v_defconfig
@@ -0,0 +1,433 @@
+CONFIG_EXPERIMENTAL=y
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_LZO=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_PANIC_TIMEOUT=1
+# CONFIG_SYSCTL_SYSCALL is not set
+# CONFIG_ELF_CORE is not set
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_ARCH_RK3026=y
+CONFIG_DDR_FREQ=y
+# CONFIG_DDR_TEST is not set
+CONFIG_RK_USB_UART=y
+CONFIG_MACH_RK3028A_86V=y
+CONFIG_ARM_ERRATA_761320=y
+CONFIG_ARM_ERRATA_775420=y
+CONFIG_FIQ_DEBUGGER=y
+CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+CONFIG_NR_CPUS=2
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HIGHMEM=y
+CONFIG_COMPACTION=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyFIQ0 androidboot.console=ttyFIQ0 init=/init"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_WAKELOCK=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+# CONFIG_BRIDGE_NETFILTER is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_BRIDGE=y
+# CONFIG_BRIDGE_IGMP_SNOOPING is not set
+CONFIG_PHONET=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIBCM4325=y
+CONFIG_BT_AUTOSLEEP=y
+CONFIG_RFKILL=y
+CONFIG_RFKILL_RK=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_NAND_IDS=y
+CONFIG_MTD_RKNAND=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_MISC_DEVICES=y
+CONFIG_UID_STAT=y
+CONFIG_APANIC=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_NETDEVICES=y
+CONFIG_PHYLIB=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN_80211=y
+CONFIG_RKWIFI=y
+CONFIG_BCM4330=y
+CONFIG_USB_USBNET=y
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_KEYRESET=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_INPUT_TABLET=y
+CONFIG_TABLET_USB_ACECAD=y
+CONFIG_TABLET_USB_AIPTEK=y
+CONFIG_TABLET_USB_GTCO=y
+CONFIG_TABLET_USB_HANWANG=y
+CONFIG_TABLET_USB_KBTAB=y
+CONFIG_TABLET_USB_WACOM=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GSLX680_RK3028=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_SENSOR_DEVICE=y
+CONFIG_GSENSOR_DEVICE=y
+CONFIG_GS_MXC6225=y
+# CONFIG_SERIO is not set
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_RK29=y
+CONFIG_UART0_RK29=y
+CONFIG_UART0_CTS_RTS_RK29=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C0_CONTROLLER_RK30=y
+CONFIG_I2C1_CONTROLLER_RK30=y
+CONFIG_I2C2_CONTROLLER_RK30=y
+CONFIG_I2C3_CONTROLLER_RK30=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_WM831X=y
+CONFIG_EXPANDED_GPIO_NUM=0
+CONFIG_EXPANDED_GPIO_IRQ_NUM=0
+CONFIG_SPI_FPGA_GPIO_NUM=0
+CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
+CONFIG_POWER_SUPPLY=y
+CONFIG_TEST_POWER=y
+# CONFIG_HWMON is not set
+CONFIG_MFD_TPS65910=y
+CONFIG_MFD_WM831X_I2C=y
+CONFIG_MFD_TPS65090=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_TPS65910=y
+CONFIG_REGULATOR_WM831X=y
+CONFIG_REGULATOR_ACT8846=y
+CONFIG_RK30_PWM_REGULATOR=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_VIDEO_DEV=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_OV2659=y
+CONFIG_VIDEO_RK29=y
+CONFIG_VIDEO_RK29_CAMMEM_ION=y
+CONFIG_ION=y
+CONFIG_ION_ROCKCHIP=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_DISPLAY_SUPPORT=y
+CONFIG_FB_ROCKCHIP=y
+CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL=y
+CONFIG_LCDC_RK3188=y
+CONFIG_LCDC0_RK3188=y
+CONFIG_LCDC1_RK3188=y
+CONFIG_LCD_RK3028_86V=y
+CONFIG_RK_TRSM=y
+CONFIG_RK_HDMI=y
+CONFIG_HDMI_SOURCE_LCDC1=y
+CONFIG_RGA_RK30=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_RK29_SOC=y
+CONFIG_SND_I2SO_USE_DOUBLE_CHANNELS=y
+CONFIG_SND_I2S_DMA_EVENT_STATIC=y
+CONFIG_SND_RK_SOC_HDMI_I2S=y
+CONFIG_SND_RK_SOC_RK3026=y
+CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
+CONFIG_UHID=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=y
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT_ARVO=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_HID_ROCCAT_KONEPLUS=y
+CONFIG_HID_ROCCAT_KOVAPLUS=y
+CONFIG_HID_ROCCAT_PYRA=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB20_HOST=y
+CONFIG_USB20_OTG=y
+CONFIG_DWC_OTG_BOTH_HOST_SLAVE=y
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_BLOCK_MINORS=12
+CONFIG_SDMMC_RK29=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_WM831X=y
+CONFIG_TPS65910_RTC=y
+CONFIG_STAGING=y
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_CMMB is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_FUSE_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/arm/mach-rk3026/Kconfig b/arch/arm/mach-rk3026/Kconfig
index c219e1d5b4c3..fd855ac4f5db 100644
--- a/arch/arm/mach-rk3026/Kconfig
+++ b/arch/arm/mach-rk3026/Kconfig
@@ -11,4 +11,7 @@ config MACH_RK3026_TB
 config MACH_RK3028A_TB
 	bool "RK3028A Top Board"
 
+config MACH_RK3028A_86V
+	bool "RK3028A 86V Board"
+
 endchoice
diff --git a/arch/arm/mach-rk3026/Makefile b/arch/arm/mach-rk3026/Makefile
index 0154f62694ea..0cfab8b0ad08 100644
--- a/arch/arm/mach-rk3026/Makefile
+++ b/arch/arm/mach-rk3026/Makefile
@@ -22,3 +22,4 @@ obj-y += board.o
 board-$(CONFIG_MACH_RK3026_FPGA) += board-rk3026-fpga.o
 board-$(CONFIG_MACH_RK3026_TB) += board-rk3026-tb.o
 board-$(CONFIG_MACH_RK3028A_TB) += board-rk3028a-tb.o
+board-$(CONFIG_MACH_RK3028A_86V) += board-rk3028a-86v.o
diff --git a/arch/arm/mach-rk3026/board-rk3028a-86v-camera.c b/arch/arm/mach-rk3026/board-rk3028a-86v-camera.c
new file mode 100755
index 000000000000..1b355f74eda8
--- /dev/null
+++ b/arch/arm/mach-rk3026/board-rk3028a-86v-camera.c
@@ -0,0 +1,492 @@
+#ifdef CONFIG_VIDEO_RK29
+#include <plat/rk_camera.h>
+/* Notes:
+
+Simple camera device registration:
+
+       new_camera_device(sensor_name,\       // sensor name, it is equal to CONFIG_SENSOR_X
+                          face,\              // sensor face information, it can be back or front
+                          pwdn_io,\           // power down gpio configuration, it is equal to CONFIG_SENSOR_POWERDN_PIN_XX
+                          flash_attach,\      // sensor is attach flash or not
+                          mir,\               // sensor image mirror and flip control information
+                          i2c_chl,\           // i2c channel which the sensor attached in hardware, it is equal to CONFIG_SENSOR_IIC_ADAPTER_ID_X
+                          cif_chl)  \         // cif channel which the sensor attached in hardware, it is equal to CONFIG_SENSOR_CIF_INDEX_X
+
+Comprehensive camera device registration:
+
+      new_camera_device_ex(sensor_name,\
+                             face,\
+                             ori,\            // sensor orientation, it is equal to CONFIG_SENSOR_ORIENTATION_X
+                             pwr_io,\         // sensor power gpio configuration, it is equal to CONFIG_SENSOR_POWER_PIN_XX
+                             pwr_active,\     // sensor power active level, is equal to CONFIG_SENSOR_RESETACTIVE_LEVEL_X
+                             rst_io,\         // sensor reset gpio configuration, it is equal to CONFIG_SENSOR_RESET_PIN_XX
+                             rst_active,\     // sensor reset active level, is equal to CONFIG_SENSOR_RESETACTIVE_LEVEL_X
+                             pwdn_io,\
+                             pwdn_active,\    // sensor power down active level, is equal to CONFIG_SENSOR_POWERDNACTIVE_LEVEL_X
+                             flash_attach,\
+                             res,\            // sensor resolution, this is real resolution or resoltuion after interpolate
+                             mir,\
+                             i2c_chl,\
+                             i2c_spd,\        // i2c speed , 100000 = 100KHz
+                             i2c_addr,\       // the i2c slave device address for sensor
+                             cif_chl,\
+                             mclk)\           // sensor input clock rate, 24 or 48
+                          
+*/
+static struct rkcamera_platform_data new_camera[] = { 
+    new_camera_device(RK29_CAM_SENSOR_OV5642,
+                        back,
+                        RK2928_PIN3_PB3,
+                        0,
+                        0,
+                        0,
+                        0),
+    new_camera_device_end
+};
+/*---------------- Camera Sensor Macro Define Begin  ------------------------*/
+/*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
+#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5642						/* back camera sensor */
+#define CONFIG_SENSOR_IIC_ADDR_0		0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  0
+#define CONFIG_SENSOR_CIF_INDEX_0                    0
+#define CONFIG_SENSOR_ORIENTATION_0 	  90
+#define CONFIG_SENSOR_POWER_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_0 	  RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_0   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_0		30000
+
+#define CONFIG_SENSOR_01  RK29_CAM_SENSOR_OV5642                   /* back camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_01 	    0x00
+#define CONFIG_SENSOR_CIF_INDEX_01                    0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_01    4
+#define CONFIG_SENSOR_ORIENTATION_01       90
+#define CONFIG_SENSOR_POWER_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_01       RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_01 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_01 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_01 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_01 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_01   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_01     30000
+
+#define CONFIG_SENSOR_02 RK29_CAM_SENSOR_OV5640                      /* back camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_02 	    0x00
+#define CONFIG_SENSOR_CIF_INDEX_02                    0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_02    4
+#define CONFIG_SENSOR_ORIENTATION_02       90
+#define CONFIG_SENSOR_POWER_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_02       RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_02 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_02 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_02 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_02   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_02      30000
+
+#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 0 */
+#define CONFIG_SENSOR_IIC_ADDR_1 	   0// 0x60
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  3
+#define CONFIG_SENSOR_CIF_INDEX_1				  0
+#define CONFIG_SENSOR_ORIENTATION_1       270
+#define CONFIG_SENSOR_POWER_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_1 	  RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_1   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_1		30000
+
+#define CONFIG_SENSOR_11 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_11 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_11    3
+#define CONFIG_SENSOR_CIF_INDEX_11				  0
+#define CONFIG_SENSOR_ORIENTATION_11       270
+#define CONFIG_SENSOR_POWER_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_11       INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_11 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_11 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_11 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_11 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_11   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_11      30000
+
+#define CONFIG_SENSOR_12 RK29_CAM_SENSOR_OV2659//RK29_CAM_SENSOR_OV2655                      /* front camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_12 	   0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_12    3
+#define CONFIG_SENSOR_CIF_INDEX_12				  0
+#define CONFIG_SENSOR_ORIENTATION_12       270
+#define CONFIG_SENSOR_POWER_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_12       INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_12 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_12 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_12 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_12 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_12   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_12      30000
+
+
+#endif  //#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Configuration Macro End------------------------*/
+#include "../../../drivers/media/video/rk2928_camera.c"
+/*---------------- Camera Sensor Macro Define End  ---------*/
+
+#define PMEM_CAM_SIZE PMEM_CAM_NECESSARY
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_VIDEO_RK29
+#define CONFIG_SENSOR_POWER_IOCTL_USR	   0 //define this refer to your board layout
+#define CONFIG_SENSOR_RESET_IOCTL_USR	   0
+#define CONFIG_SENSOR_POWERDOWN_IOCTL_USR	   0
+#define CONFIG_SENSOR_FLASH_IOCTL_USR	   0
+
+static void rk_cif_power(int on)
+{
+    struct regulator *ldo_18,*ldo_28;
+	ldo_28 = regulator_get(NULL, "ldo7");	// vcc28_cif
+	ldo_18 = regulator_get(NULL, "ldo1");	// vcc18_cif
+	if (ldo_28 == NULL || IS_ERR(ldo_28) || ldo_18 == NULL || IS_ERR(ldo_18)){
+        printk("get cif ldo failed!\n");
+		return;
+	    }
+    if(on == 0){	
+    	regulator_disable(ldo_28);
+    	regulator_put(ldo_28);
+    	regulator_disable(ldo_18);
+    	regulator_put(ldo_18);
+    	mdelay(500);
+        }
+    else{
+    	regulator_set_voltage(ldo_28, 2800000, 2800000);
+    	regulator_enable(ldo_28);
+   // 	printk("%s set ldo7 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_28));
+    	regulator_put(ldo_28);
+
+    	regulator_set_voltage(ldo_18, 1800000, 1800000);
+    //	regulator_set_suspend_voltage(ldo, 1800000);
+    	regulator_enable(ldo_18);
+    //	printk("%s set ldo1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_18));
+    	regulator_put(ldo_18);
+        }
+}
+
+#if CONFIG_SENSOR_POWER_IOCTL_USR
+static int sensor_power_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	//#error "CONFIG_SENSOR_POWER_IOCTL_USR is 1, sensor_power_usr_cb function must be writed!!";
+    rk_cif_power(on);
+}
+#endif
+
+#if CONFIG_SENSOR_RESET_IOCTL_USR
+static int sensor_reset_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_RESET_IOCTL_USR is 1, sensor_reset_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+static int sensor_powerdown_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_FLASH_IOCTL_USR
+static int sensor_flash_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_FLASH_IOCTL_USR is 1, sensor_flash_usr_cb function must be writed!!";
+}
+#endif
+
+static struct rk29camera_platform_ioctl_cb	sensor_ioctl_cb = {
+	#if CONFIG_SENSOR_POWER_IOCTL_USR
+	.sensor_power_cb = sensor_power_usr_cb,
+	#else
+	.sensor_power_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_RESET_IOCTL_USR
+	.sensor_reset_cb = sensor_reset_usr_cb,
+	#else
+	.sensor_reset_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+	.sensor_powerdown_cb = sensor_powerdown_usr_cb,
+	#else
+	.sensor_powerdown_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_FLASH_IOCTL_USR
+	.sensor_flash_cb = sensor_flash_usr_cb,
+	#else
+	.sensor_flash_cb = NULL,
+	#endif
+};
+
+#if CONFIG_SENSOR_IIC_ADDR_0
+static struct reginfo_t rk_init_data_sensor_reg_0[] =
+{
+		{0x0000, 0x00,0,0}
+	};
+static struct reginfo_t rk_init_data_sensor_winseqreg_0[] ={
+	{0x0000, 0x00,0,0}
+	};
+#endif
+
+#if CONFIG_SENSOR_IIC_ADDR_1
+static struct reginfo_t rk_init_data_sensor_reg_1[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_1[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_01
+static struct reginfo_t rk_init_data_sensor_reg_01[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_01[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_02
+static struct reginfo_t rk_init_data_sensor_reg_02[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_02[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_11
+static struct reginfo_t rk_init_data_sensor_reg_11[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_11[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_12
+static struct reginfo_t rk_init_data_sensor_reg_12[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_12[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+static rk_sensor_user_init_data_s rk_init_data_sensor[RK_CAM_NUM] = 
+{
+    #if CONFIG_SENSOR_IIC_ADDR_0
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_0,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_0,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_0) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_0) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_1
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_1,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_1,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_1) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_1) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_01
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_01,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_01,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_01) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_01) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_02
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_02,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_02,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_02) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_02) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_11
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_11,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_11,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_11) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_11) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_12
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_12,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_12,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_12) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_12) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+
+ };
+#include "../../../drivers/media/video/rk2928_camera.c"
+
+#endif /* CONFIG_VIDEO_RK29 */
diff --git a/arch/arm/mach-rk3026/board-rk3028a-86v-sdmmc-config.c b/arch/arm/mach-rk3026/board-rk3028a-86v-sdmmc-config.c
new file mode 100644
index 000000000000..9626c1b80a89
--- /dev/null
+++ b/arch/arm/mach-rk3026/board-rk3028a-86v-sdmmc-config.c
@@ -0,0 +1,165 @@
+/*****************************************************************************************
+ * arch/arm/mach-rkxx/baord-xxx-sdmmc-config.c
+ *
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ *
+ * Description: 
+ *     define the gpio for SD-MMC-SDIO-Wifi functions  according to your own projects.
+ *
+ * Author: Michael Xie
+ *         15 Jan,2013
+ * E-mail: xbw@rock-chips.com
+ *
+ ******************************************************************************************/
+
+/*
+** If you select the macro of CONFIG_SDMMC0_RK29_WRITE_PROTECT, You must define the following values.
+** Otherwise, there is no need to define the following values。
+*/
+//#define SDMMC0_WRITE_PROTECT_PIN	            RK30_PIN3_PB2	//According to your own project to set the value of write-protect-pin.
+//#define SDMMC0_WRITE_PROTECT_ENABLE_VALUE     GPIO_HIGH
+
+/*
+** If you select the macro of CONFIG_SDMMC1_RK29_WRITE_PROTECT, You must define the following values.
+** Otherwise, there is no need to define the following values。
+*/
+//#define SDMMC1_WRITE_PROTECT_PIN	            RK30_PIN3_PB3	//According to your own project to set the value of write-protect-pin.
+//#define SDMMC1_WRITE_PROTECT_ENABLE_VALUE     GPIO_HIGH
+    
+/*
+** If you select the macro of CONFIG_RK29_SDIO_IRQ_FROM_GPIO, You must define the following values.
+** Otherwise, there is no need to define the following values。
+*/
+//#define RK29SDK_WIFI_SDIO_CARD_INT         RK30_PIN3_PD2
+
+
+/*
+* define sdcard PowerEn-pin
+*/
+#define RK29SDK_SD_CARD_PWR_EN                  RK30_PIN3_PA1
+#define RK29SDK_SD_CARD_PWR_EN_LEVEL            GPIO_LOW 
+int rk31sdk_get_sdmmc0_pin_io_voltage(void)
+{
+    int voltage;
+#define RK31SDK_SET_SDMMC0_PIN_VOLTAGE
+
+    /**************************************************************************************
+    **  Please tell me how much voltage of your SDMMC0-pin in your project. 
+    **
+    **     例如: 有的项目，它的SDMMC0所在的RK主控的IO组，想用1.8V, 而卡本身用3.3V, 
+    **  而中间通过个电平转换.那么，您此时，应该设置下面的voltage值为 1.8V(即1800mv)
+    ***************************************************************************************/
+    voltage = 3300;  //default the voltage 3300mv. 
+
+    return voltage;
+}
+
+/*
+* define the card-detect-pin.
+*/
+#define RK29SDK_SD_CARD_DETECT_N                RK30_PIN3_PB0  //According to your own project to set the value of card-detect-pin.
+#define RK29SDK_SD_CARD_INSERT_LEVEL            GPIO_LOW       // set the voltage of insert-card. Please pay attention to the default setting.
+
+/*
+* Define wifi module's power and reset gpio, and gpio sensitive level.
+* Please set the value according to your own project.
+*
+* Well, you just own engineering module to set the value in the corresponding module branch.
+* Otherwise, you do not define this macro, eliminate it.
+*
+*/          
+#if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) 
+    #define RK30SDK_WIFI_GPIO_POWER_N               RK30_PIN3_PD0            
+    #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_LOW//GPIO_HIGH        
+    
+#elif defined(CONFIG_BCM4330) || defined(CONFIG_BCM4329) || defined(CONFIG_BCM4319) || defined(CONFIG_RK903) || defined(CONFIG_RK901)
+	#define RK30SDK_WIFI_GPIO_POWER_N               RK30_PIN3_PD0                 
+    #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH
+
+    #define RK30SDK_WIFI_GPIO_RESET_N               RK30_PIN2_PA7
+    #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE    GPIO_HIGH 
+
+#elif defined(CONFIG_MT5931_MT6622) || defined(CONFIG_MT5931)
+
+	#ifdef  CONFIG_MACH_RK3168_LR097 
+    	#define RK30SDK_WIFI_GPIO_POWER_N               RK30_PIN3_PD0 
+    	#define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH
+
+    	//#define RK30SDK_WIFI_GPIO_RESET_N 	            RK30_PIN3_PD1
+    	//#define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE    GPIO_HIGH
+
+	#else
+    	#define RK30SDK_WIFI_GPIO_POWER_N               RK30_PIN0_PA5
+    	#define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE    GPIO_HIGH
+
+    	#define RK30SDK_WIFI_GPIO_RESET_N               RK30_PIN3_PD1
+    	#define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE    GPIO_HIGH	
+	#endif
+
+#elif defined(CONFIG_MT6620)
+    #define COMBO_MODULE_MT6620_CDT    1  // to control antsel2,antsel3 and gps_lan foot when using AcSip or Cdtech chip. 
+	                                      //- 1--use Cdtech chip; 0--unuse CDT chip
+
+    //power, PMU_EN
+    #define RK30SDK_WIFI_GPIO_POWER_N                   RK30_PIN3_PC7            
+    #define RK30SDK_WIFI_GPIO_POWER_ENABLE_VALUE        GPIO_HIGH        
+    //reset, DAIRST,SYSRST_B
+    #define RK30SDK_WIFI_GPIO_RESET_N                   RK30_PIN3_PD1
+    #define RK30SDK_WIFI_GPIO_RESET_ENABLE_VALUE        GPIO_HIGH 
+    //VDDIO
+    //#define RK30SDK_WIFI_GPIO_VCCIO_WL                  RK30_PIN0_PD2 //You do not get control of the foot, and you do not need to define the macro 
+    //#define RK30SDK_WIFI_GPIO_VCCIO_WL_ENABLE_VALUE     GPIO_HIGH
+    //WIFI_INT_B
+    #define RK30SDK_WIFI_GPIO_WIFI_INT_B                RK30_PIN3_PD2
+    #define RK30SDK_WIFI_GPIO_WIFI_INT_B_ENABLE_VALUE   GPIO_HIGH 
+    //BGF_INT_B
+    #define RK30SDK_WIFI_GPIO_BGF_INT_B                 RK30_PIN6_PA7
+    #define RK30SDK_WIFI_GPIO_BGF_INT_B_ENABLE_VALUE    GPIO_HIGH 
+    //GPS_SYNC
+    #define RK30SDK_WIFI_GPIO_GPS_SYNC                  RK30_PIN3_PD0
+    #define RK30SDK_WIFI_GPIO_GPS_SYNC_ENABLE_VALUE     GPIO_HIGH 
+
+    #if COMBO_MODULE_MT6620_CDT
+    //ANTSEL2
+    #define RK30SDK_WIFI_GPIO_ANTSEL2                   RK30_PIN4_PD4
+    #define RK30SDK_WIFI_GPIO_ANTSEL2_ENABLE_VALUE      GPIO_LOW    //use 6620 in CDT chip, LOW--work; High--no work.
+    //ANTSEL3
+    #define RK30SDK_WIFI_GPIO_ANTSEL3                   RK30_PIN4_PD3
+    #define RK30SDK_WIFI_GPIO_ANTSEL3_ENABLE_VALUE      GPIO_HIGH    //use 6620 in CDT chip, High--work; Low--no work..
+    //GPS_LAN
+    #define RK30SDK_WIFI_GPIO_GPS_LAN                   RK30_PIN4_PD6
+    #define RK30SDK_WIFI_GPIO_GPS_LAN_ENABLE_VALUE      GPIO_HIGH    //use 6620 in CDT chip, High--work; Low--no work..
+    #endif // #if COMBO_MODULE_MT6620_CDT--#endif
+#endif 
+
+#ifndef RK30SDK_WIFI_GPIO_WIFI_INT_B
+#define RK30SDK_WIFI_GPIO_WIFI_INT_B              INVALID_GPIO
+#define RK30SDK_WIFI_GPIO_WIFI_INT_B_ENABLE_VALUE   GPIO_HIGH 
+#endif
+
+int rk31sdk_get_sdio_wifi_voltage(void)
+{
+    int voltage;
+    
+    /******************************************************************************
+    **  Please tell me how much wifi-module uses voltage in your project.  
+    ******************************************************************************/
+#if defined(CONFIG_BCM4330) || defined(CONFIG_BCM4329) || defined(CONFIG_BCM4319) || defined(CONFIG_RK903) || defined(CONFIG_RK901)
+    voltage = 1800 ; //power 1800mV
+    
+#elif defined(CONFIG_MT5931_MT6622)||defined(CONFIG_MT5931)
+    voltage = 1800 ; //power 1800V
+#elif defined(CONFIG_MT6620) 
+    voltage = 2800 ; //power 2800V
+#elif defined(CONFIG_RDA5990)||defined(CONFIG_RTL8723AS)  
+    voltage = 3300 ; //power 3300V
+#else
+    //default, sdio use 3.0V
+    voltage = 3000 ; //power 3000V
+#endif
+
+    return voltage;
+}
+
+
+   
diff --git a/arch/arm/mach-rk3026/board-rk3028a-86v.c b/arch/arm/mach-rk3026/board-rk3028a-86v.c
new file mode 100755
index 000000000000..0a503bddeea8
--- /dev/null
+++ b/arch/arm/mach-rk3026/board-rk3028a-86v.c
@@ -0,0 +1,1293 @@
+/*
+ * Copyright (C) 2013 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/skbuff.h>
+#include <linux/spi/spi.h>
+#include <linux/mmc/host.h>
+#include <linux/ion.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+#include <linux/rk_fb.h>
+#include <linux/regulator/machine.h>
+#include <linux/rfkill-rk.h>
+#include <linux/sensor-dev.h>
+#include <linux/mfd/tps65910.h>
+#include <linux/regulator/act8846.h>
+#include <linux/regulator/rk29-pwm-regulator.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/gic.h>
+
+#include <mach/dvfs.h>
+#include <mach/board.h>
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+
+#if defined(CONFIG_SPIM_RK29)
+#include "../../../drivers/spi/rk29_spim.h"
+#endif
+
+#ifdef CONFIG_SND_SOC_RK3026
+#include "../../../sound/soc/codecs/rk3026_codec.h"
+#endif
+
+#if defined(CONFIG_RK_HDMI)
+        #include "../../../drivers/video/rockchip/hdmi/rk_hdmi.h"
+#endif
+
+#include "board-rk3028a-86v-camera.c"
+
+/***********************************************************
+*	board config
+************************************************************/
+//system power on
+#define POWER_ON_PIN		RK30_PIN1_PA1  //PWR_HOLD
+
+//touchscreen
+#define TOUCH_RST_PIN		RK30_PIN3_PC3
+#define TOUCH_RST_VALUE		GPIO_HIGH
+#define TOUCH_PWR_PIN		RK30_PIN2_PD0
+#define TOUCH_PWR_VALUE		GPIO_LOW
+#define TOUCH_INT_PIN		RK30_PIN3_PC7
+
+//backlight
+#define LCD_DISP_ON_PIN
+#define BL_PWM			0  // (0 ~ 2)
+#define PWM_EFFECT_VALUE  	0
+#define BL_EN_PIN		RK30_PIN3_PC5
+#define BL_EN_VALUE		GPIO_HIGH
+
+//fb
+#define LCD_EN_PIN		RK30_PIN3_PD2
+#define LCD_EN_VALUE		GPIO_LOW
+#define LCD_CS_PIN		INVALID_GPIO
+#define LCD_CS_VALUE		GPIO_LOW
+
+//gsensor
+#define GS_INT_PIN		RK30_PIN3_PD1
+
+//sdmmc
+//Reference to board-rk3028a-tb-sdmmc-config.c
+
+//keyboard
+//#define RK31XX_MAINBOARD_V1      //if mainboard is RK31XX_MAINBOARD_V1.0
+#define PLAY_ON_PIN		RK30_PIN0_PD1	//wakeup key		
+
+//pwm regulator
+#define REG_PWM			1  // (0 ~ 2)
+
+//pmic
+#define PMU_INT_PIN		RK30_PIN3_PC6
+#define PMU_SLEEP_PIN		RK30_PIN3_PC4
+
+//ion reserve memory
+#define ION_RESERVE_SIZE        (80 * SZ_1M)
+
+static int pwm_mode[] = {PWM0, PWM1, PWM2};
+static inline int rk_gpio_request(int gpio, int direction, int value, const char *label)
+{
+	int ret = 0;
+	unsigned long flags = 0;
+
+	if(!gpio_is_valid(gpio))
+		return 0;
+
+	if(direction == GPIOF_DIR_IN)
+		flags = GPIOF_IN;
+	else if(value == GPIO_LOW)
+		flags = GPIOF_OUT_INIT_LOW;
+	else
+		flags = GPIOF_OUT_INIT_HIGH;
+
+	ret = gpio_request_one(gpio, flags, label);
+	if(ret < 0)
+		pr_err("Failed to request '%s'\n", label);
+
+	return ret;
+}
+
+static struct spi_board_info board_spi_devices[] = {
+};
+
+/***********************************************************
+*	touchscreen
+************************************************************/
+#if defined(CONFIG_TOUCHSCREEN_GSLX680_RK3028)
+//#define TOUCH_RESET_PIN RK30_PIN0_PC1
+//#define TOUCH_EN_PIN NULL
+//#define TOUCH_INT_PIN RK30_PIN0_PB4
+	
+	int gslx680_init_platform_hw(void)
+	{
+	
+	       if(gpio_request(TOUCH_RST_PIN,NULL) != 0){
+			gpio_free(TOUCH_RST_PIN);
+			printk("gslx680_init_platform_hw gpio_request error\n");
+			return -EIO;
+		}
+		if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+			gpio_free(TOUCH_INT_PIN);
+			printk("gslx680_init_platform_hw  gpio_request error\n");
+			return -EIO;
+		}
+		gpio_direction_output(TOUCH_RST_PIN, TOUCH_RST_VALUE);
+		mdelay(10);
+		gpio_set_value(TOUCH_RST_PIN,!TOUCH_RST_VALUE);
+		mdelay(10);
+		gpio_set_value(TOUCH_RST_PIN,TOUCH_RST_VALUE);
+		msleep(300);
+		return 0;
+	
+	}
+	
+	struct ts_hw_data     gslx680_info = {
+		.reset_gpio = TOUCH_RST_PIN,
+		.touch_en_gpio = TOUCH_INT_PIN,
+		.init_platform_hw = gslx680_init_platform_hw,
+	};
+#endif
+
+
+#if defined(CONFIG_TOUCHSCREEN_GT8XX)
+static int goodix_init_platform_hw(void)
+{
+	int ret  = 0;
+
+	ret = rk_gpio_request(TOUCH_PWR_PIN, GPIOF_DIR_OUT, TOUCH_PWR_VALUE, "touch_pwr");
+	if(ret < 0)
+		return ret; 
+	msleep(100);
+
+	ret = rk_gpio_request(TOUCH_RST_PIN, GPIOF_DIR_OUT, TOUCH_RST_VALUE, "touch_rst");
+	if(ret < 0)
+		return ret; 
+	msleep(100);
+
+	return 0;
+}
+
+struct goodix_platform_data goodix_info = {
+	.model = 8105,
+	.irq_pin = TOUCH_INT_PIN,
+	.rest_pin = TOUCH_RST_PIN,
+	.init_platform_hw = goodix_init_platform_hw,
+};
+#endif
+
+/***********************************************************
+*	rk30  backlight
+************************************************************/
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+static int rk29_backlight_io_init(void)
+{
+	int ret = 0;
+
+	iomux_set(pwm_mode[BL_PWM]);
+#ifdef  LCD_DISP_ON_PIN
+	ret = rk_gpio_request(BL_EN_PIN, GPIOF_DIR_OUT, BL_EN_VALUE, "bl_en");
+	if(ret < 0)
+		return ret;
+#endif
+	return 0;
+}
+
+static int rk29_backlight_io_deinit(void)
+{
+	int pwm_gpio;
+#ifdef  LCD_DISP_ON_PIN
+	gpio_free(BL_EN_PIN);
+#endif
+	pwm_gpio = iomux_mode_to_gpio(pwm_mode[BL_PWM]);
+	return rk_gpio_request(BL_EN_PIN, GPIOF_DIR_OUT, GPIO_LOW, "BL_PWM");
+}
+
+static int rk29_backlight_pwm_suspend(void)
+{
+	int ret, pwm_gpio = iomux_mode_to_gpio(pwm_mode[BL_PWM]);
+
+	ret = rk_gpio_request(pwm_gpio, GPIOF_DIR_OUT, GPIO_LOW, "BL_PWM");
+	if(ret < 0)
+		return ret;
+#ifdef  LCD_DISP_ON_PIN
+	gpio_direction_output(BL_EN_PIN, !BL_EN_VALUE);
+#endif
+	return ret;
+}
+
+static int rk29_backlight_pwm_resume(void)
+{
+	int pwm_gpio = iomux_mode_to_gpio(pwm_mode[BL_PWM]);
+
+	gpio_free(pwm_gpio);
+	iomux_set(pwm_mode[BL_PWM]);
+#ifdef  LCD_DISP_ON_PIN
+	msleep(30);
+	gpio_direction_output(BL_EN_PIN, BL_EN_VALUE);
+#endif
+	return 0;
+}
+
+static struct rk29_bl_info rk29_bl_info = {
+	.pwm_id = BL_PWM,
+	.min_brightness=60,
+	.max_brightness=255,
+	.brightness_mode = BRIGHTNESS_MODE_CONIC,
+	.bl_ref = PWM_EFFECT_VALUE,
+	.io_init = rk29_backlight_io_init,
+	.io_deinit = rk29_backlight_io_deinit,
+	.pwm_suspend = rk29_backlight_pwm_suspend,
+	.pwm_resume = rk29_backlight_pwm_resume,
+};
+
+static struct platform_device rk29_device_backlight = {
+	.name	= "rk29_backlight",
+	.id 	= -1,
+	.dev	= {
+		.platform_data  = &rk29_bl_info,
+	}
+};
+#endif
+
+/***********************************************************
+*	fb
+************************************************************/
+#ifdef CONFIG_FB_ROCKCHIP
+static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
+{
+	int ret = 0;
+
+	ret = rk_gpio_request(LCD_CS_PIN, GPIOF_DIR_OUT, LCD_CS_VALUE, "lcd_cs");
+	if(ret < 0)
+		return ret;
+
+	return rk_gpio_request(LCD_EN_PIN, GPIOF_DIR_OUT, LCD_EN_VALUE, "lcd_en");
+}
+
+static int rk_fb_io_disable(void)
+{
+	gpio_set_value(LCD_CS_PIN, !LCD_CS_VALUE);
+	gpio_set_value(LCD_EN_PIN, !LCD_EN_VALUE);
+
+	return 0;
+}
+
+static int rk_fb_io_enable(void)
+{
+	gpio_set_value(LCD_CS_PIN, LCD_CS_VALUE);
+	gpio_set_value(LCD_EN_PIN, LCD_EN_VALUE);
+
+	return 0;
+}
+
+#if defined(CONFIG_LCDC0_RK3066B) || defined(CONFIG_LCDC0_RK3188)
+struct rk29fb_info lcdc0_screen_info = {
+#if defined(CONFIG_RK_HDMI) && defined(CONFIG_HDMI_SOURCE_LCDC0) && defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
+	.prop	   = EXTEND,	//extend display device
+	.io_init    = NULL,
+	.io_disable = NULL,
+	.io_enable = NULL,
+	.set_screen_info = hdmi_init_lcdc,
+#else
+	.prop	   = PRMRY,		//primary display device
+	.io_init   = rk_fb_io_init,
+	.io_disable = rk_fb_io_disable,
+	.io_enable = rk_fb_io_enable,
+	.set_screen_info = set_lcd_info,
+#endif
+};
+#endif
+
+#if defined(CONFIG_LCDC1_RK3066B) || defined(CONFIG_LCDC1_RK3188)
+struct rk29fb_info lcdc1_screen_info = {
+#if defined(CONFIG_RK_HDMI) && defined(CONFIG_HDMI_SOURCE_LCDC1) && defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
+	.prop	   = EXTEND,	//extend display device
+	.io_init    = NULL,
+	.io_disable = NULL,
+	.io_enable = NULL,
+	.set_screen_info = hdmi_init_lcdc,
+#else
+	.prop	   = PRMRY,		//primary display device
+	.io_init   = rk_fb_io_init,
+	.io_disable = rk_fb_io_disable,
+	.io_enable = rk_fb_io_enable,
+	.set_screen_info = set_lcd_info,
+#endif
+};
+#endif
+
+static struct resource resource_fb[] = {
+	[0] = {
+		.name  = "fb0 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name  = "ipp buf",  //for rotate
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.name  = "fb2 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device device_fb = {
+	.name		= "rk-fb",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(resource_fb),
+	.resource	= resource_fb,
+};
+#endif
+
+#if defined(CONFIG_LCDC0_RK3066B) || defined(CONFIG_LCDC0_RK3188)
+static struct resource resource_lcdc0[] = {
+	[0] = {
+		.name  = "lcdc0 reg",
+		.start = RK3026_LCDC0_PHYS,
+		.end   = RK3026_LCDC0_PHYS + RK3026_LCDC0_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	
+	[1] = {
+		.name  = "lcdc0 irq",
+		.start = IRQ_LCDC,
+		.end   = IRQ_LCDC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device device_lcdc0 = {
+	.name		  = "rk30-lcdc",
+	.id		  = 0,
+	.num_resources	  = ARRAY_SIZE(resource_lcdc0),
+	.resource	  = resource_lcdc0,
+	.dev 		= {
+		.platform_data = &lcdc0_screen_info,
+	},
+};
+#endif
+
+#if defined(CONFIG_LCDC1_RK3066B) || defined(CONFIG_LCDC1_RK3188)
+static struct resource resource_lcdc1[] = {
+	[0] = {
+		.name  = "lcdc1 reg",
+		.start = RK3026_LCDC1_PHYS,
+		.end   = RK3026_LCDC1_PHYS + RK3026_LCDC1_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name  = "lcdc1 irq",
+		.start = IRQ_LCDC1,
+		.end   = IRQ_LCDC1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device device_lcdc1 = {
+	.name		  = "rk30-lcdc",
+	.id		  = 1,
+	.num_resources	  = ARRAY_SIZE(resource_lcdc1),
+	.resource	  = resource_lcdc1,
+	.dev 		= {
+		.platform_data = &lcdc1_screen_info,
+	},
+};
+#endif
+
+static int rk_platform_add_display_devices(void)
+{
+	struct platform_device *fb = NULL;  //fb
+	struct platform_device *lcdc0 = NULL; //lcdc0
+	struct platform_device *lcdc1 = NULL; //lcdc1
+	struct platform_device *bl = NULL; //backlight
+#ifdef CONFIG_FB_ROCKCHIP
+	fb = &device_fb;
+#endif
+
+#if defined(CONFIG_LCDC0_RK3066B) || defined(CONFIG_LCDC0_RK3188)
+	lcdc0 = &device_lcdc0,
+#endif
+
+#if defined(CONFIG_LCDC1_RK3066B) || defined(CONFIG_LCDC1_RK3188)
+	lcdc1 = &device_lcdc1,
+#endif
+
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+	bl = &rk29_device_backlight,
+#endif
+	__rk_platform_add_display_devices(fb,lcdc0,lcdc1,bl);
+
+	return 0;
+}
+
+
+/***********************************************************
+*	gsensor
+************************************************************/
+#if defined (CONFIG_GS_MMA8452)
+static int mma8452_init_platform_hw(void)
+{
+	return 0;
+}
+
+static struct sensor_platform_data mma8452_info = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+        .init_platform_hw = mma8452_init_platform_hw,
+        .orientation = {-1, 0, 0, 0, -1, 0, 0, 0, 1},
+};
+#endif
+
+#if defined (CONFIG_GS_MXC6225)
+#define MXC6225_INT_PIN   RK30_PIN3_PD1
+
+static int mxc6225_init_platform_hw(void)
+{
+        return 0;
+}
+
+static struct sensor_platform_data mxc6225_info = {
+        .type = SENSOR_TYPE_ACCEL,
+        .irq_enable = 0,
+        .poll_delay_ms = 30,
+        .init_platform_hw = mxc6225_init_platform_hw,
+        .orientation = { 0, -1, 0, 1, 0, 0, 0, 0, 0},
+};
+#endif
+
+
+/***********************************************************
+*	keyboard
+************************************************************/
+#include <plat/key.h>
+
+static struct rk29_keys_button key_button[] = {
+#ifdef RK31XX_MAINBOARD_V1
+        {
+                .desc   = "vol-",
+                .code   = KEY_VOLUMEDOWN,
+		.adc_value      = 744,
+                .gpio   = INVALID_GPIO,
+                .active_low = PRESS_LEV_LOW,
+        },
+        {
+                .desc   = "play",
+                .code   = KEY_POWER,
+                .gpio   = PLAY_ON_PIN,
+                .active_low = PRESS_LEV_LOW,
+                .wakeup = 1,
+        },
+        {
+                .desc   = "vol+",
+                .code   = KEY_VOLUMEUP,
+                .adc_value      = 558,
+                .gpio = INVALID_GPIO,
+                .active_low = PRESS_LEV_LOW,
+        },
+	{
+                .desc   = "menu",
+                .code   = EV_MENU,
+                .adc_value      = 1,
+                .gpio = INVALID_GPIO,
+                .active_low = PRESS_LEV_LOW,
+        },
+        {
+                .desc   = "home",
+                .code   = KEY_HOME,
+                .adc_value      = 354,
+                .gpio = INVALID_GPIO,
+                .active_low = PRESS_LEV_LOW,
+        },
+        {
+                .desc   = "esc",
+                .code   = KEY_BACK,
+                .adc_value      = 169,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+#else
+        {
+                .desc   = "vol-",
+                .code   = KEY_VOLUMEDOWN,
+		.adc_value      = 900,
+                .gpio   = INVALID_GPIO,
+                .active_low = PRESS_LEV_LOW,
+        },
+        {
+                .desc   = "play",
+                .code   = KEY_POWER,
+                .gpio   = PLAY_ON_PIN,
+                .active_low = PRESS_LEV_LOW,
+                .wakeup = 1,
+        },
+        {
+                .desc   = "vol+",
+                .code   = KEY_VOLUMEUP,
+                .adc_value      = 1,
+                .gpio = INVALID_GPIO,
+                .active_low = PRESS_LEV_LOW,
+        },
+	{
+                .desc   = "menu",
+                .code   = EV_MENU,
+                .adc_value      = 133,
+                .gpio = INVALID_GPIO,
+                .active_low = PRESS_LEV_LOW,
+        },
+        {
+                .desc   = "home",
+                .code   = KEY_HOME,
+                .adc_value      = 550,
+                .gpio = INVALID_GPIO,
+                .active_low = PRESS_LEV_LOW,
+        },
+        {
+                .desc   = "esc",
+                .code   = KEY_BACK,
+                .adc_value      = 333,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+	{
+		.desc	= "camera",
+		.code	= KEY_CAMERA,
+		.adc_value	= 742,
+		.gpio = INVALID_GPIO,
+		.active_low = PRESS_LEV_LOW,
+	},
+#endif
+};
+
+struct rk29_keys_platform_data rk29_keys_pdata = {
+	.buttons	= key_button,
+	.nbuttons	= ARRAY_SIZE(key_button),
+	.chn	= 1,  //chn: 0-7, if do not use ADC,set 'chn' -1
+};
+
+/***********************************************************
+*	sdmmc
+************************************************************/
+#ifdef CONFIG_SDMMC_RK29
+#include "board-rk3028a-86v-sdmmc-config.c"
+#include "../plat-rk/rk-sdmmc-ops.c"
+#include "../plat-rk/rk-sdmmc-wifi.c"
+#endif //endif ---#ifdef CONFIG_SDMMC_RK29
+
+#ifdef CONFIG_SDMMC0_RK29
+#define CONFIG_SDMMC0_USE_DMA
+static int rk29_sdmmc0_cfg_gpio(void)
+{
+	rk29_sdmmc_set_iomux(0, 0xFFFF);
+	#if defined(CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO)
+        iomux_set_gpio_mode(iomux_gpio_to_mode(RK29SDK_SD_CARD_DETECT_N));
+    	#else
+        iomux_set(MMC0_DETN);
+    	#endif	
+
+	#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	gpio_request(SDMMC0_WRITE_PROTECT_PIN, "sdmmc-wp");
+	gpio_direction_input(SDMMC0_WRITE_PROTECT_PIN);
+	#endif
+	return 0;
+}
+
+struct rk29_sdmmc_platform_data default_sdmmc0_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36),
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+	.io_init = rk29_sdmmc0_cfg_gpio,
+
+	.set_iomux = rk29_sdmmc_set_iomux,
+
+	.dma_name = "sd_mmc",
+#ifdef CONFIG_SDMMC0_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+
+#if defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC) && defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
+	.status = rk29sdk_wifi_mmc0_status,
+	.register_status_notify = rk29sdk_wifi_mmc0_status_register,
+#endif
+
+#if defined(RK29SDK_SD_CARD_PWR_EN) || (INVALID_GPIO != RK29SDK_SD_CARD_PWR_EN)
+	.power_en = RK29SDK_SD_CARD_PWR_EN,
+	.power_en_level = RK29SDK_SD_CARD_PWR_EN_LEVEL,
+#else
+	.power_en = INVALID_GPIO,
+	.power_en_level = GPIO_LOW,
+#endif    
+	.enable_sd_wakeup = 0,
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	.write_prt = SDMMC0_WRITE_PROTECT_PIN,
+	.write_prt_enalbe_level = SDMMC0_WRITE_PROTECT_ENABLE_VALUE;
+#else
+	.write_prt = INVALID_GPIO,
+#endif
+
+	.det_pin_info = {    
+    		#if defined(RK29SDK_SD_CARD_DETECT_N) || (INVALID_GPIO != RK29SDK_SD_CARD_DETECT_N)  
+        	.io             = RK29SDK_SD_CARD_DETECT_N, //INVALID_GPIO,
+        	.enable         = RK29SDK_SD_CARD_INSERT_LEVEL,
+    		#else
+        	.io             = INVALID_GPIO,
+        	.enable         = GPIO_LOW,
+    		#endif    
+    	}, 
+
+};
+#endif // CONFIG_SDMMC0_RK29
+
+#ifdef CONFIG_SDMMC1_RK29
+#define CONFIG_SDMMC1_USE_DMA
+static int rk29_sdmmc1_cfg_gpio(void)
+{
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+	gpio_request(SDMMC1_WRITE_PROTECT_PIN, "sdio-wp");
+	gpio_direction_input(SDMMC1_WRITE_PROTECT_PIN);
+#endif
+	return 0;
+}
+
+struct rk29_sdmmc_platform_data default_sdmmc1_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34),
+
+#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
+	.host_caps = (MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
+		      MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#else
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+#endif
+
+	.io_init = rk29_sdmmc1_cfg_gpio,
+
+	.set_iomux = rk29_sdmmc_set_iomux,
+
+	.dma_name = "sdio",
+#ifdef CONFIG_SDMMC1_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+
+#if defined(CONFIG_WIFI_CONTROL_FUNC) || defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC)
+	.status = rk29sdk_wifi_status,
+	.register_status_notify = rk29sdk_wifi_status_register,
+#endif
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+	.write_prt = SDMMC1_WRITE_PROTECT_PIN,
+	.write_prt_enalbe_level = SDMMC1_WRITE_PROTECT_ENABLE_VALUE;
+#else
+	.write_prt = INVALID_GPIO,
+#endif
+
+    #if defined(CONFIG_RK29_SDIO_IRQ_FROM_GPIO)
+	.sdio_INT_gpio = RK29SDK_WIFI_SDIO_CARD_INT,
+    #endif
+
+	.det_pin_info = {    
+	#if defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
+		#if defined(RK29SDK_SD_CARD_DETECT_N) || (INVALID_GPIO != RK29SDK_SD_CARD_DETECT_N)  
+        	.io             = RK29SDK_SD_CARD_DETECT_N,
+     		#else
+         	.io             = INVALID_GPIO,
+		#endif   
+
+        	.enable         = RK29SDK_SD_CARD_INSERT_LEVEL,
+	#else
+        	.io             = INVALID_GPIO,
+        	.enable         = GPIO_LOW,
+	#endif
+	},
+	.enable_sd_wakeup = 0,
+};
+#endif //endif--#ifdef CONFIG_SDMMC1_RK29
+
+/***********************************************************
+*	rfkill
+************************************************************/
+#ifdef CONFIG_RFKILL_RK
+// bluetooth rfkill device, its driver in net/rfkill/rfkill-rk.c
+static struct rfkill_rk_platform_data rfkill_rk_platdata = {
+	.type               = RFKILL_TYPE_BLUETOOTH,
+
+	.poweron_gpio       = { // BT_REG_ON
+		.io             = INVALID_GPIO, //RK30_PIN3_PC7,
+		.enable         = GPIO_HIGH,
+		.iomux          = {
+			.name       = "bt_poweron",
+			//.fgpio      = GPIO3_C7,
+		},
+	},
+
+	.reset_gpio         = { // BT_RST
+		.io             = RK30_PIN1_PB3, // set io to INVALID_GPIO for disable it
+		.enable         = GPIO_LOW,
+		.iomux          = {
+			.name       = "bt_reset",
+			.fgpio      = GPIO1_B3,
+		},
+	}, 
+
+	.wake_gpio          = { // BT_WAKE, use to control bt's sleep and wakeup
+		.io             = RK30_PIN1_PB2, // set io to INVALID_GPIO for disable it
+		.enable         = GPIO_HIGH,
+		.iomux          = {
+			.name       = "bt_wake",
+			.fgpio      = GPIO1_B2,
+		},
+	},
+
+	.wake_host_irq      = { // BT_HOST_WAKE, for bt wakeup host when it is in deep sleep
+		.gpio           = {
+			.io         = RK30_PIN0_PA4, // set io to INVALID_GPIO for disable it
+			.enable     = GPIO_LOW,      // set GPIO_LOW for falling, set 0 for rising
+			.iomux      = {
+				.name   = "bt_wake_host",
+				//.fgpio  = GPIO0_A4,  
+			},
+		},
+	},
+
+	.rts_gpio           = { // UART_RTS, enable or disable BT's data coming
+		.io             = RK30_PIN1_PA3, // set io to INVALID_GPIO for disable it
+		.enable         = GPIO_LOW,
+		.iomux          = {
+			.name       = "bt_rts",
+			.fgpio      = GPIO1_A3,
+			.fmux       = UART0_RTSN,
+		},
+	}
+};
+
+static struct platform_device device_rfkill_rk = {
+    .name   = "rfkill_rk",
+    .id     = -1,
+    .dev    = {
+        .platform_data = &rfkill_rk_platdata,
+    },
+};
+#endif
+
+/***********************************************************
+*	ion
+************************************************************/
+#ifdef CONFIG_ION
+static struct ion_platform_data rk30_ion_pdata = {
+	.nr = 1,
+	.heaps = {
+		{
+			.type = ION_HEAP_TYPE_CARVEOUT,
+			.id = ION_NOR_HEAP_ID,
+			.name = "norheap",
+			.size = ION_RESERVE_SIZE,
+		}
+	},
+};
+
+static struct platform_device device_ion = {
+	.name = "ion-rockchip",
+	.id = 0,
+	.dev = {
+		.platform_data = &rk30_ion_pdata,
+	},
+};
+#endif
+
+#ifdef CONFIG_SND_SOC_RK3026
+struct rk3026_codec_pdata rk3026_codec_pdata_info={
+	    .spk_ctl_gpio = INVALID_GPIO,
+	    .hp_ctl_gpio = RK2928_PIN3_PD4,
+	};
+
+static struct resource resources_acodec[] = {
+	{
+		.start 	= RK2928_ACODEC_PHYS,
+		.end 	= RK2928_ACODEC_PHYS + RK2928_ACODEC_SIZE - 1,
+		.flags 	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device rk3026_codec = {
+	.name   = "rk3026-codec",
+   	.id     = -1,
+	.resource = resources_acodec,
+	.dev = {
+	       .platform_data = &rk3026_codec_pdata_info,
+		    }
+	};
+#endif
+
+/***********************************************************
+*	pwm regulator
+************************************************************/
+#ifdef CONFIG_RK30_PWM_REGULATOR
+static int pwm_voltage_map[] = {
+	800000,  825000,  850000,  875000,  900000,  925000 ,
+	950000,  975000,  1000000, 1025000, 1050000, 1075000, 
+	1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 
+	1250000, 1275000, 1300000, 1325000, 1350000, 1375000
+};
+
+static struct regulator_consumer_supply pwm_dcdc1_consumers[] = {
+	{
+		.supply = "vdd_core",
+	}
+};
+
+struct regulator_init_data pwm_regulator_init_dcdc[1] = {
+	{
+		.constraints = {
+			.name = "PWM_DCDC1",
+			.min_uV = 600000,
+			.max_uV = 1800000,      //0.6-1.8V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(pwm_dcdc1_consumers),
+		.consumer_supplies = pwm_dcdc1_consumers,
+	},
+};
+
+static struct pwm_platform_data pwm_regulator_info[1] = {
+	{
+		.pwm_id = REG_PWM,
+		.pwm_voltage = 1200000,
+		.suspend_voltage = 1050000,
+		.min_uV = 950000,
+		.max_uV = 1400000,
+		.coefficient = 504,     //50.4%
+		.pwm_voltage_map = pwm_voltage_map,
+		.init_data      = &pwm_regulator_init_dcdc[0],
+	},
+};
+struct platform_device pwm_regulator_device[1] = {
+	{
+		.name = "pwm-voltage-regulator",
+		.id = 0,
+		.dev            = {
+			.platform_data = &pwm_regulator_info[0],
+		}
+	},
+};
+
+static void pwm_regulator_init(void)
+{
+	pwm_regulator_info[0].pwm_gpio = iomux_mode_to_gpio(pwm_mode[REG_PWM]);
+	pwm_regulator_info[0].pwm_iomux_pwm = pwm_mode[REG_PWM];
+	pwm_regulator_info[0].pwm_iomux_gpio = iomux_switch_gpio_mode(pwm_mode[REG_PWM]);
+}
+#endif
+
+int __sramdata pwm_iomux, pwm_do, pwm_dir, pwm_en;
+#define grf_readl(offset)       readl_relaxed(RK30_GRF_BASE + offset)
+#define grf_writel(v, offset)   do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
+
+#define GPIO0_D2_OFFSET		10
+void __sramfunc rk30_pwm_logic_suspend_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	#if 0
+	/* pwm0: GPIO0_D2, pwm1: GPIO0_D3, pwm2: GPIO0_D4 */
+	int off = GPIO0_D2_OFFSET + REG_PWM;
+
+	sram_udelay(10000);
+	pwm_iomux = grf_readl(GRF_GPIO0D_IOMUX);
+	pwm_dir = grf_readl(GRF_GPIO0H_DIR);
+	pwm_do = grf_readl(GRF_GPIO0H_DO);
+	pwm__en = grf_readl(GRF_GPIO0H_EN);
+
+	grf_writel((1<<(2 * off), GRF_GPIO0D_IOMUX);
+	grf_writel((1<<(16 + off))|(1<<off), GRF_GPIO0H_DIR);
+	grf_writel((1<<(16 + off))|(1<<off), GRF_GPIO0H_DO);
+	#endif
+#endif
+}
+
+void __sramfunc rk30_pwm_logic_resume_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	#if 0
+	/* pwm0: GPIO0_D2, pwm1: GPIO0_D3, pwm2: GPIO0_D4 */
+	int off = GPIO0_D2_OFFSET + REG_PWM;
+
+	grf_writel((1<<(2 * off))|pwm_iomux, GRF_GPIO0D_IOMUX);
+	grf_writel(((1<<(16 + off))|pwm_dir), GRF_GPIO0L_DIR);
+	grf_writel(((1<<(16 + off))|pwm_do), GRF_GPIO0L_DO);
+	grf_writel(((1<<(16 + off))|pwm_en), GRF_GPIO0L_EN);
+	sram_udelay(10000);
+	#endif
+#endif
+}
+extern void pwm_suspend_voltage(void);
+extern void pwm_resume_voltage(void);
+
+void  rk30_pwm_suspend_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_suspend_voltage();
+#endif
+}
+
+void  rk30_pwm_resume_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_resume_voltage();
+#endif
+}
+
+/***********************************************************
+*	pmic
+************************************************************/
+int __sramdata g_pmic_type =  0;
+
+#ifdef CONFIG_MFD_TPS65910
+#define TPS65910_HOST_IRQ 	PMU_INT_PIN
+#define PMU_POWER_SLEEP		PMU_SLEEP_PIN
+static struct pmu_info  tps65910_dcdc_info[] = {
+	{
+		.name          = "vdd_core",   //logic
+		.min_uv          = 1100000,
+		.max_uv         = 1100000,
+	},
+	{
+		.name          = "vdd_cpu",    //arm
+		.min_uv          = 1100000,
+		.max_uv         = 1100000,
+	},
+	{
+		.name          = "vio",   //vcc_io
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+	},
+	
+};
+static  struct pmu_info  tps65910_ldo_info[] = {
+	/*{
+		.name          = "vpll",   //vdd10
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+	},*/
+	{
+		.name          = "vdig1",    //vcc18_cif
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+	{
+		.name          = "vdig2",   //vdd11
+		.min_uv          = 1100000,
+		.max_uv         = 1100000,
+	},
+	{
+		.name          = "vaux1",   //vcc28_cif
+		.min_uv          = 2800000,
+		.max_uv         = 2800000,
+	},
+	{
+		.name          = "vaux2",   //vcc33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "vaux33",   //vcc_tp
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "vmmc",   //vcca30
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+	},
+	{
+		.name          = "vdac",   //
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+};
+#include "../mach-rk30/board-pmu-tps65910.c"
+#endif
+
+void __sramfunc board_pmu_suspend(void)
+{
+	#if defined (CONFIG_MFD_TPS65910)
+	if(pmic_is_tps65910())
+		board_pmu_tps65910_suspend();
+	#endif
+}
+
+void __sramfunc board_pmu_resume(void)
+{
+	#if defined (CONFIG_MFD_TPS65910)
+	if(pmic_is_tps65910())
+		board_pmu_tps65910_resume();
+	#endif
+}
+
+/***********************************************************
+*	i2c
+************************************************************/
+#ifdef CONFIG_I2C0_RK30
+static struct i2c_board_info __initdata i2c0_info[] = {
+#if defined (CONFIG_GS_MMA8452)
+	{
+		.type	        = "gs_mma8452",
+		.addr	        = 0x1d,
+		.flags	        = 0,
+		.irq	        = GS_INT_PIN,
+		.platform_data = &mma8452_info,
+	},
+#endif
+#if defined (CONFIG_MFD_TPS65910)
+	{
+		.type           = "tps65910",
+		.addr           = TPS65910_I2C_ID0,
+		.flags          = 0,
+		.irq            = TPS65910_HOST_IRQ,
+		.platform_data = &tps65910_data,
+	},
+#endif
+
+};
+#endif
+
+#ifdef CONFIG_I2C1_RK30
+static struct i2c_board_info __initdata i2c1_info[] = {
+#if defined (CONFIG_GS_MXC6225)
+        {
+                .type           = "gs_mxc6225",
+                .addr           = 0x15,
+                .flags          = 0,
+                .irq            = MXC6225_INT_PIN,
+                .platform_data  = &mxc6225_info,
+        },
+#endif
+
+};
+#endif
+
+#ifdef CONFIG_I2C2_RK30
+static struct i2c_board_info __initdata i2c2_info[] = {
+#if defined (CONFIG_TOUCHSCREEN_GT8XX)
+	{
+		.type          = "Goodix-TS",
+		.addr          = 0x55,
+		.flags         = 0,
+		.irq           = TOUCH_INT_PIN,
+		.platform_data = &goodix_info,
+	},
+#endif
+#if defined (CONFIG_TOUCHSCREEN_GSLX680_RK3028)
+    {
+        .type           = "gslX680",
+        .addr           = 0x40,
+        .flags          = 0,
+        .platform_data =&gslx680_info,
+    },
+#endif
+
+};
+#endif
+
+#ifdef CONFIG_I2C3_RK30
+static struct i2c_board_info __initdata i2c3_info[] = {
+};
+#endif
+
+#ifdef CONFIG_I2C_GPIO_RK30
+#define I2C_SDA_PIN     INVALID_GPIO// RK30_PIN2_PD6   //set sda_pin here
+#define I2C_SCL_PIN     INVALID_GPIO//RK30_PIN2_PD7   //set scl_pin here
+static int rk30_i2c_io_init(void)
+{
+        return 0;
+}
+
+struct i2c_gpio_platform_data default_i2c_gpio_data = {
+       .sda_pin = I2C_SDA_PIN,
+       .scl_pin = I2C_SCL_PIN,
+       .udelay = 5, // clk = 500/udelay = 100Khz
+       .timeout = 100,//msecs_to_jiffies(100),
+       .bus_num    = 5,
+       .io_init = rk30_i2c_io_init,
+};
+
+static struct i2c_board_info __initdata i2c_gpio_info[] = {
+};
+#endif
+
+static void __init rk30_i2c_register_board_info(void)
+{
+#ifdef CONFIG_I2C0_RK30
+	i2c_register_board_info(0, i2c0_info, ARRAY_SIZE(i2c0_info));
+#endif
+#ifdef CONFIG_I2C1_RK30
+	i2c_register_board_info(1, i2c1_info, ARRAY_SIZE(i2c1_info));
+#endif
+#ifdef CONFIG_I2C2_RK30
+	i2c_register_board_info(2, i2c2_info, ARRAY_SIZE(i2c2_info));
+#endif
+#ifdef CONFIG_I2C3_RK30
+	i2c_register_board_info(3, i2c3_info, ARRAY_SIZE(i2c3_info));
+#endif
+#ifdef CONFIG_I2C_GPIO_RK30
+	i2c_register_board_info(4, i2c_gpio_info, ARRAY_SIZE(i2c_gpio_info));
+#endif
+}
+
+/***********************************************************
+*	board init
+************************************************************/
+static struct platform_device *devices[] __initdata = {
+#ifdef CONFIG_ION
+	&device_ion,
+#endif
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	&rk29sdk_wifi_device,
+#endif
+#ifdef CONFIG_RFKILL_RK
+	&device_rfkill_rk,
+#endif
+#ifdef CONFIG_SND_SOC_RK3026
+	&rk3026_codec,
+#endif
+};
+
+static void rk30_pm_power_off(void)
+{
+#if defined(CONFIG_MFD_TPS65910)
+	tps65910_device_shutdown();//tps65910 shutdown
+#endif
+	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
+	while(1);
+}
+
+static void __init machine_rk30_board_init(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_regulator_init();
+#endif
+	avs_init();
+	pm_power_off = rk30_pm_power_off;
+	rk_gpio_request(POWER_ON_PIN, GPIOF_DIR_OUT, GPIO_HIGH, "system power on");
+	rk30_i2c_register_board_info();
+	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+	rk_platform_add_display_devices();	
+#if defined(CONFIG_WIFI_CONTROL_FUNC)
+	rk29sdk_wifi_bt_gpio_control_init();
+#elif defined(CONFIG_WIFI_COMBO_MODULE_CONTROL_FUNC)
+    rk29sdk_wifi_combo_module_gpio_init();
+#endif
+}
+
+static void __init rk30_reserve(void)
+{
+	//fb reserve
+#ifdef CONFIG_FB_ROCKCHIP
+	resource_fb[0].start = board_mem_reserve_add("fb0 buf", get_fb_size());
+	resource_fb[0].end = resource_fb[0].start + get_fb_size()- 1;
+	#if 0
+	resource_fb[1].start = board_mem_reserve_add("ipp buf", RK30_FB0_MEM_SIZE);
+	resource_fb[1].end = resource_fb[1].start + RK30_FB0_MEM_SIZE - 1;
+	#endif
+
+	#if defined(CONFIG_FB_ROTATE) || !defined(CONFIG_THREE_FB_BUFFER)
+	resource_fb[2].start = board_mem_reserve_add("fb2 buf",get_fb_size());
+	resource_fb[2].end = resource_fb[2].start + get_fb_size() - 1;
+	#endif
+#endif
+	//ion reserve
+#ifdef CONFIG_ION
+	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
+#endif
+	board_mem_reserved();
+}
+
+/***********************************************************
+*	clock
+************************************************************/
+static struct cpufreq_frequency_table dvfs_arm_table[] = {
+	{.frequency = 312 * 1000,       .index = 1200 * 1000},
+	{.frequency = 504 * 1000,       .index = 1200 * 1000},
+	{.frequency = 816 * 1000,       .index = 1200 * 1000},
+	//{.frequency = 1008 * 1000,      .index = 1200 * 1000},
+	//{.frequency = 1200 * 1000,      .index = 1300 * 1000},
+	//{.frequency = 1416 * 1000,      .index = 1200 * 1000},
+	//{.frequency = 1608 * 1000,      .index = 1200 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+static struct cpufreq_frequency_table dvfs_gpu_table[] = {
+	{.frequency = 100 * 1000,       .index = 1200 * 1000},
+	{.frequency = 200 * 1000,       .index = 1200 * 1000},
+	{.frequency = 266 * 1000,       .index = 1200 * 1000},
+	{.frequency = 300 * 1000,       .index = 1200 * 1000},
+	{.frequency = 400 * 1000,       .index = 1200 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+static struct cpufreq_frequency_table dvfs_ddr_table[] = {
+	{.frequency = 200 * 1000 + DDR_FREQ_SUSPEND,    .index = 1200 * 1000},
+	{.frequency = 300 * 1000 + DDR_FREQ_VIDEO,      .index = 1200 * 1000},
+	{.frequency = 400 * 1000 + DDR_FREQ_NORMAL,     .index = 1200 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+void __init board_clock_init(void)
+{
+	rk2928_clock_data_init(periph_pll_default, codec_pll_default, RK30_CLOCKS_DEFAULT_FLAGS);
+	//dvfs_set_arm_logic_volt(dvfs_cpu_logic_table, cpu_dvfs_table, dep_cpu2core_table);	
+	dvfs_set_freq_volt_table(clk_get(NULL, "cpu"), dvfs_arm_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "gpu"), dvfs_gpu_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "ddr"), dvfs_ddr_table);
+}
+
+/************************ end *****************************/
+MACHINE_START(RK30, "RK30board")
+	.boot_params	= PLAT_PHYS_OFFSET + 0x800,
+	.fixup		= rk2928_fixup,
+	.reserve	= &rk30_reserve,
+	.map_io		= rk2928_map_io,
+	.init_irq	= rk2928_init_irq,
+	.timer		= &rk2928_timer,
+	.init_machine	= machine_rk30_board_init,
+MACHINE_END
diff --git a/drivers/video/rockchip/lcdc/rk3188_lcdc.c b/drivers/video/rockchip/lcdc/rk3188_lcdc.c
index 7901e3e03c3b..c7a6507a93db 100755
--- a/drivers/video/rockchip/lcdc/rk3188_lcdc.c
+++ b/drivers/video/rockchip/lcdc/rk3188_lcdc.c
@@ -647,12 +647,15 @@ static int rk3188_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initsc
 		iomux_set(LCDC0_D15);
 		iomux_set(LCDC0_D16);
 		iomux_set(LCDC0_D17);
-		iomux_set(LCDC0_D18);
-		iomux_set(LCDC0_D19);
-		iomux_set(LCDC0_D20);
-		iomux_set(LCDC0_D21);
-		iomux_set(LCDC0_D22);
-		iomux_set(LCDC0_D23);
+		if(!((dev_drv->screen0->face == OUT_P666)||(dev_drv->screen0->face == OUT_P565)))
+		{
+			iomux_set(LCDC0_D18);
+			iomux_set(LCDC0_D19);
+			iomux_set(LCDC0_D20);//iomux uart2 in
+			iomux_set(LCDC0_D21);//iomux uart2 out
+			iomux_set(LCDC0_D22);
+			iomux_set(LCDC0_D23);
+		}
 	}
 	#endif
 	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
-- 
2.35.3

