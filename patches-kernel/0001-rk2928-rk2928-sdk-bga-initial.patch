From 031c9a58425e31a601bf48336e527cc1664fc10e Mon Sep 17 00:00:00 2001
From: kfx <kfx@rock-chips.com>
Date: Tue, 16 Oct 2012 17:09:47 +0800
Subject: [PATCH] rk2928: rk2928 sdk(bga) initial

---
 arch/arm/configs/rk2926_m713_defconfig        |  417 ----
 arch/arm/configs/rk2928_sdk_defconfig         |   33 +-
 arch/arm/mach-rk2928/Kconfig                  |    2 +-
 arch/arm/mach-rk2928/board-rk2926-sdk.c       |    6 +-
 .../mach-rk2928/board-rk2928-sdk-act8931.c    |    5 +
 .../arm/mach-rk2928/board-rk2928-sdk-camera.c |   19 +-
 arch/arm/mach-rk2928/board-rk2928-sdk-key.c   |   40 +-
 .../mach-rk2928/board-rk2928-sdk-tps65910.c   |   50 +-
 arch/arm/mach-rk2928/board-rk2928-sdk.c       | 1998 ++++++++--------
 arch/arm/mach-rk2928/board-rk2928-tb-camera.c |  448 ++++
 arch/arm/mach-rk2928/board-rk2928-tb.c        |    4 +-
 drivers/input/touchscreen/Kconfig             |    4 +
 drivers/input/touchscreen/Makefile            |    1 +
 drivers/input/touchscreen/gt811_firmware.h    |  274 +++
 drivers/input/touchscreen/gt811_ts.c          | 2017 +++++++++++++++++
 drivers/input/touchscreen/gt811_ts.h          |  277 +++
 sound/soc/codecs/rk2928_codec.c               |    4 +-
 17 files changed, 4055 insertions(+), 1544 deletions(-)
 delete mode 100644 arch/arm/configs/rk2926_m713_defconfig
 mode change 100644 => 100755 arch/arm/mach-rk2928/board-rk2928-sdk-camera.c
 create mode 100644 arch/arm/mach-rk2928/board-rk2928-tb-camera.c
 create mode 100755 drivers/input/touchscreen/gt811_firmware.h
 create mode 100755 drivers/input/touchscreen/gt811_ts.c
 create mode 100755 drivers/input/touchscreen/gt811_ts.h

diff --git a/arch/arm/configs/rk2926_m713_defconfig b/arch/arm/configs/rk2926_m713_defconfig
deleted file mode 100644
index 4b4afe1e2018..000000000000
--- a/arch/arm/configs/rk2926_m713_defconfig
+++ /dev/null
@@ -1,417 +0,0 @@
-CONFIG_EXPERIMENTAL=y
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_KERNEL_LZO=y
-CONFIG_LOG_BUF_SHIFT=19
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-CONFIG_CGROUP_FREEZER=y
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-CONFIG_CGROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_PANIC_TIMEOUT=1
-# CONFIG_SYSCTL_SYSCALL is not set
-# CONFIG_ELF_CORE is not set
-CONFIG_ASHMEM=y
-# CONFIG_AIO is not set
-CONFIG_EMBEDDED=y
-# CONFIG_SLUB_DEBUG is not set
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-CONFIG_ARCH_RK2928=y
-CONFIG_RK_CLOCK_PROC=y
-CONFIG_RK_USB_UART=y
-CONFIG_MACH_RK2928_A720=y
-CONFIG_MACH_RK2926_M713=y
-CONFIG_FIQ_DEBUGGER=y
-CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
-CONFIG_FIQ_DEBUGGER_CONSOLE=y
-CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_PREEMPT=y
-CONFIG_AEABI=y
-# CONFIG_OABI_COMPAT is not set
-CONFIG_HIGHMEM=y
-CONFIG_COMPACTION=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
-CONFIG_ZBOOT_ROM_TEXT=0x0
-CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="console=ttyFIQ0 androidboot.console=ttyFIQ0 init=/init"
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
-CONFIG_CPU_IDLE=y
-CONFIG_VFP=y
-CONFIG_NEON=y
-CONFIG_WAKELOCK=y
-CONFIG_PM_RUNTIME=y
-CONFIG_PM_DEBUG=y
-CONFIG_SUSPEND_TIME=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_XFRM_USER=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_INET_ESP=y
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_LRO is not set
-CONFIG_IPV6=y
-CONFIG_IPV6_PRIVACY=y
-CONFIG_IPV6_ROUTER_PREF=y
-CONFIG_IPV6_OPTIMISTIC_DAD=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_MIP6=y
-CONFIG_IPV6_TUNNEL=y
-CONFIG_IPV6_MULTIPLE_TABLES=y
-CONFIG_NETFILTER=y
-# CONFIG_BRIDGE_NETFILTER is not set
-CONFIG_NF_CONNTRACK=y
-CONFIG_NF_CONNTRACK_EVENTS=y
-CONFIG_NF_CT_PROTO_DCCP=y
-CONFIG_NF_CT_PROTO_SCTP=y
-CONFIG_NF_CT_PROTO_UDPLITE=y
-CONFIG_NF_CONNTRACK_AMANDA=y
-CONFIG_NF_CONNTRACK_FTP=y
-CONFIG_NF_CONNTRACK_H323=y
-CONFIG_NF_CONNTRACK_IRC=y
-CONFIG_NF_CONNTRACK_NETBIOS_NS=y
-CONFIG_NF_CONNTRACK_PPTP=y
-CONFIG_NF_CONNTRACK_SANE=y
-CONFIG_NF_CONNTRACK_SIP=y
-CONFIG_NF_CONNTRACK_TFTP=y
-CONFIG_NF_CT_NETLINK=y
-CONFIG_NETFILTER_TPROXY=y
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
-CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
-CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
-CONFIG_NETFILTER_XT_TARGET_MARK=y
-CONFIG_NETFILTER_XT_TARGET_NFLOG=y
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_TPROXY=y
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-CONFIG_NETFILTER_XT_MATCH_COMMENT=y
-CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
-CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
-CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
-CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
-CONFIG_NETFILTER_XT_MATCH_HELPER=y
-CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
-CONFIG_NETFILTER_XT_MATCH_LENGTH=y
-CONFIG_NETFILTER_XT_MATCH_LIMIT=y
-CONFIG_NETFILTER_XT_MATCH_MAC=y
-CONFIG_NETFILTER_XT_MATCH_MARK=y
-CONFIG_NETFILTER_XT_MATCH_POLICY=y
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
-CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
-CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
-CONFIG_NETFILTER_XT_MATCH_SOCKET=y
-CONFIG_NETFILTER_XT_MATCH_STATE=y
-CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
-CONFIG_NETFILTER_XT_MATCH_STRING=y
-CONFIG_NETFILTER_XT_MATCH_TIME=y
-CONFIG_NETFILTER_XT_MATCH_U32=y
-CONFIG_NF_CONNTRACK_IPV4=y
-CONFIG_IP_NF_IPTABLES=y
-CONFIG_IP_NF_MATCH_AH=y
-CONFIG_IP_NF_MATCH_ECN=y
-CONFIG_IP_NF_MATCH_TTL=y
-CONFIG_IP_NF_FILTER=y
-CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_REJECT_SKERR=y
-CONFIG_IP_NF_TARGET_LOG=y
-CONFIG_NF_NAT=y
-CONFIG_IP_NF_TARGET_MASQUERADE=y
-CONFIG_IP_NF_TARGET_NETMAP=y
-CONFIG_IP_NF_TARGET_REDIRECT=y
-CONFIG_IP_NF_MANGLE=y
-CONFIG_IP_NF_RAW=y
-CONFIG_IP_NF_ARPTABLES=y
-CONFIG_IP_NF_ARPFILTER=y
-CONFIG_IP_NF_ARP_MANGLE=y
-CONFIG_NF_CONNTRACK_IPV6=y
-CONFIG_IP6_NF_IPTABLES=y
-CONFIG_IP6_NF_TARGET_LOG=y
-CONFIG_IP6_NF_FILTER=y
-CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
-CONFIG_IP6_NF_MANGLE=y
-CONFIG_IP6_NF_RAW=y
-CONFIG_BRIDGE=y
-# CONFIG_BRIDGE_IGMP_SNOOPING is not set
-CONFIG_PHONET=y
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_HTB=y
-CONFIG_NET_SCH_INGRESS=y
-CONFIG_NET_CLS_U32=y
-CONFIG_NET_EMATCH=y
-CONFIG_NET_EMATCH_U32=y
-CONFIG_NET_CLS_ACT=y
-CONFIG_NET_ACT_POLICE=y
-CONFIG_NET_ACT_GACT=y
-CONFIG_NET_ACT_MIRRED=y
-CONFIG_BT=y
-CONFIG_BT_L2CAP=y
-CONFIG_BT_SCO=y
-CONFIG_BT_RFCOMM=y
-CONFIG_BT_RFCOMM_TTY=y
-CONFIG_BT_BNEP=y
-CONFIG_BT_HIDP=y
-CONFIG_BT_HCIUART=y
-CONFIG_BT_HCIUART_H4=y
-CONFIG_BT_HCIUART_LL=y
-CONFIG_BT_HCIBCM4325=y
-CONFIG_BT_AUTOSLEEP=y
-CONFIG_CFG80211=y
-CONFIG_MAC80211=y
-CONFIG_RFKILL=y
-CONFIG_RFKILL_RK=y
-CONFIG_DEVTMPFS=y
-CONFIG_DEVTMPFS_MOUNT=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_CHAR=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_NAND_IDS=y
-CONFIG_MTD_RKNAND=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_MISC_DEVICES=y
-CONFIG_UID_STAT=y
-CONFIG_APANIC=y
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_SCSI_MULTI_LUN=y
-CONFIG_MD=y
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_CRYPT=y
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_PHYLIB=y
-# CONFIG_NETDEV_1000 is not set
-# CONFIG_NETDEV_10000 is not set
-CONFIG_WLAN_80211=y
-CONFIG_RTL8188EU=y
-CONFIG_USB_USBNET=y
-CONFIG_PPP=y
-CONFIG_PPP_MULTILINK=y
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_ASYNC=y
-CONFIG_PPP_SYNC_TTY=y
-CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=y
-CONFIG_PPP_MPPE=y
-CONFIG_PPPOLAC=y
-CONFIG_PPPOPNS=y
-# CONFIG_INPUT_MOUSEDEV is not set
-CONFIG_INPUT_EVDEV=y
-CONFIG_INPUT_KEYRESET=y
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_INPUT_MOUSE is not set
-CONFIG_INPUT_JOYSTICK=y
-CONFIG_JOYSTICK_XPAD=y
-CONFIG_JOYSTICK_XPAD_FF=y
-CONFIG_INPUT_TABLET=y
-CONFIG_TABLET_USB_ACECAD=y
-CONFIG_TABLET_USB_AIPTEK=y
-CONFIG_TABLET_USB_GTCO=y
-CONFIG_TABLET_USB_HANWANG=y
-CONFIG_TABLET_USB_KBTAB=y
-CONFIG_TABLET_USB_WACOM=y
-CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_SITRONIX_A720=y
-CONFIG_INPUT_MISC=y
-CONFIG_INPUT_KEYCHORD=y
-CONFIG_INPUT_UINPUT=y
-CONFIG_GS_MMA7660=y
-CONFIG_SENSOR_DEVICE=y
-CONFIG_GSENSOR_DEVICE=y
-# CONFIG_SERIO is not set
-# CONFIG_CONSOLE_TRANSLATIONS is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-CONFIG_I2C=y
-# CONFIG_I2C_COMPAT is not set
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C0_CONTROLLER_RK30=y
-CONFIG_I2C1_CONTROLLER_RK30=y
-CONFIG_I2C2_CONTROLLER_RK30=y
-CONFIG_ADC_RK30=y
-CONFIG_GPIO_SYSFS=y
-CONFIG_EXPANDED_GPIO_NUM=0
-CONFIG_EXPANDED_GPIO_IRQ_NUM=0
-CONFIG_SPI_FPGA_GPIO_NUM=0
-CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
-CONFIG_POWER_SUPPLY=y
-CONFIG_BATTERY_RK30_ADC_FAC=y
-CONFIG_BATTERY_RK30_AC_CHARGE=y
-CONFIG_BATTERY_RK30_VOL3V8=y
-# CONFIG_HWMON is not set
-CONFIG_MFD_TPS65910=y
-CONFIG_MFD_TPS65090=y
-CONFIG_REGULATOR=y
-CONFIG_REGULATOR_TPS65910=y
-CONFIG_REGULATOR_ACT8931=y
-CONFIG_RK30_PWM_REGULATOR=y
-CONFIG_MEDIA_SUPPORT=y
-CONFIG_VIDEO_DEV=y
-CONFIG_SOC_CAMERA=y
-CONFIG_SOC_CAMERA_GC0308=y
-CONFIG_GC0308_USER_DEFINED_SERIES=y
-CONFIG_VIDEO_RK29=y
-CONFIG_VIDEO_RK29_CAMMEM_ION=y
-CONFIG_ION=y
-CONFIG_ION_ROCKCHIP=y
-CONFIG_FB=y
-CONFIG_BACKLIGHT_LCD_SUPPORT=y
-# CONFIG_LCD_CLASS_DEVICE is not set
-CONFIG_BACKLIGHT_CLASS_DEVICE=y
-# CONFIG_BACKLIGHT_GENERIC is not set
-CONFIG_DISPLAY_SUPPORT=y
-CONFIG_LCD_RK2928_A720=y
-CONFIG_FB_ROCKCHIP=y
-CONFIG_LCDC_RK2928=y
-CONFIG_RK_HDMI=y
-CONFIG_HDMI_RK2928=y
-CONFIG_RGA_RK30=y
-CONFIG_RK_LVDS=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-CONFIG_SOUND=y
-CONFIG_SND=y
-# CONFIG_SND_SUPPORT_OLD_API is not set
-# CONFIG_SND_VERBOSE_PROCFS is not set
-# CONFIG_SND_DRIVERS is not set
-# CONFIG_SND_ARM is not set
-CONFIG_SND_SOC=y
-CONFIG_SND_RK29_SOC=y
-CONFIG_SND_I2S_DMA_EVENT_STATIC=y
-CONFIG_SND_RK_SOC_RK2928=y
-CONFIG_SND_RK29_CODEC_SOC_SLAVE=y
-CONFIG_HID_A4TECH=y
-CONFIG_HID_ACRUX=y
-CONFIG_HID_ACRUX_FF=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_DRAGONRISE=y
-CONFIG_DRAGONRISE_FF=y
-CONFIG_HID_EMS_FF=y
-CONFIG_HID_ELECOM=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_KEYTOUCH=y
-CONFIG_HID_KYE=y
-CONFIG_HID_UCLOGIC=y
-CONFIG_HID_WALTOP=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_TWINHAN=y
-CONFIG_HID_KENSINGTON=y
-CONFIG_HID_LCPOWER=y
-CONFIG_HID_LOGITECH=y
-CONFIG_LOGITECH_FF=y
-CONFIG_LOGIRUMBLEPAD2_FF=y
-CONFIG_LOGIG940_FF=y
-CONFIG_LOGIWII_FF=y
-CONFIG_HID_MAGICMOUSE=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_MULTITOUCH=y
-CONFIG_HID_NTRIG=y
-CONFIG_HID_ORTEK=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_PANTHERLORD_FF=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_PICOLCD=y
-CONFIG_HID_QUANTA=y
-CONFIG_HID_ROCCAT_ARVO=y
-CONFIG_HID_ROCCAT_KONE=y
-CONFIG_HID_ROCCAT_KONEPLUS=y
-CONFIG_HID_ROCCAT_KOVAPLUS=y
-CONFIG_HID_ROCCAT_PYRA=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_HID_GREENASIA=y
-CONFIG_GREENASIA_FF=y
-CONFIG_HID_SMARTJOYPLUS=y
-CONFIG_SMARTJOYPLUS_FF=y
-CONFIG_HID_TOPSEED=y
-CONFIG_HID_THRUSTMASTER=y
-CONFIG_THRUSTMASTER_FF=y
-CONFIG_HID_WACOM=y
-CONFIG_HID_ZEROPLUS=y
-CONFIG_ZEROPLUS_FF=y
-CONFIG_HID_ZYDACRON=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_DEVICEFS=y
-CONFIG_USB_OTG_BLACKLIST_HUB=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_SERIAL=y
-CONFIG_USB_SERIAL_GENERIC=y
-CONFIG_USB_SERIAL_OPTION=y
-CONFIG_USB_GADGET=y
-CONFIG_USB20_HOST=y
-CONFIG_USB20_OTG=y
-CONFIG_DWC_OTG_BOTH_HOST_SLAVE=y
-CONFIG_MMC=y
-CONFIG_MMC_UNSAFE_RESUME=y
-CONFIG_MMC_EMBEDDED_SDIO=y
-CONFIG_MMC_PARANOID_SD_INIT=y
-CONFIG_SDMMC_RK29=y
-CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO=y
-# CONFIG_SDMMC1_RK29 is not set
-CONFIG_SWITCH=y
-CONFIG_SWITCH_GPIO=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_HYM8563=y
-CONFIG_TPS65910_RTC=y
-CONFIG_STAGING=y
-CONFIG_ANDROID=y
-CONFIG_ANDROID_BINDER_IPC=y
-CONFIG_ANDROID_LOGGER=y
-CONFIG_ANDROID_LOW_MEMORY_KILLER=y
-# CONFIG_CMMB is not set
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_FS_XATTR is not set
-CONFIG_EXT4_FS=y
-# CONFIG_EXT4_FS_XATTR is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_FUSE_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_TMPFS=y
-# CONFIG_MISC_FILESYSTEMS is not set
-# CONFIG_NETWORK_FILESYSTEMS is not set
-CONFIG_PARTITION_ADVANCED=y
-CONFIG_EFI_PARTITION=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_PRINTK_TIME=y
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_SCHEDSTATS=y
-# CONFIG_DEBUG_PREEMPT is not set
-# CONFIG_EVENT_POWER_TRACING_DEPRECATED is not set
-CONFIG_ENABLE_DEFAULT_TRACERS=y
-CONFIG_CRYPTO_SHA256=y
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/arm/configs/rk2928_sdk_defconfig b/arch/arm/configs/rk2928_sdk_defconfig
index cf15f6e70784..2259638a18f6 100755
--- a/arch/arm/configs/rk2928_sdk_defconfig
+++ b/arch/arm/configs/rk2928_sdk_defconfig
@@ -176,6 +176,8 @@ CONFIG_BT_HCIUART_H4=y
 CONFIG_BT_HCIUART_LL=y
 CONFIG_BT_HCIBCM4325=y
 CONFIG_BT_AUTOSLEEP=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
 CONFIG_RFKILL=y
 CONFIG_RFKILL_RK=y
 CONFIG_DEVTMPFS=y
@@ -203,7 +205,7 @@ CONFIG_PHYLIB=y
 # CONFIG_NETDEV_1000 is not set
 # CONFIG_NETDEV_10000 is not set
 CONFIG_WLAN_80211=y
-CONFIG_RKWIFI=y
+CONFIG_RTL8188EU=y
 CONFIG_USB_USBNET=y
 CONFIG_PPP=y
 CONFIG_PPP_MULTILINK=y
@@ -231,27 +233,16 @@ CONFIG_TABLET_USB_HANWANG=y
 CONFIG_TABLET_USB_KBTAB=y
 CONFIG_TABLET_USB_WACOM=y
 CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_EETI_EGALAX=y
-CONFIG_EETI_EGALAX_MAX_X=1087
-CONFIG_EETI_EGALAX_MAX_Y=800
+CONFIG_TOUCHSCREEN_GT811_IIC=y
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_KEYCHORD=y
 CONFIG_INPUT_UINPUT=y
-CONFIG_COMPASS_AK8975=y
-CONFIG_GS_MMA8452=y
-CONFIG_GYRO_L3G4200D=y
-CONFIG_LS_CM3217=y
+CONFIG_GS_MMA7660=y
 CONFIG_SENSOR_DEVICE=y
 CONFIG_GSENSOR_DEVICE=y
-CONFIG_COMPASS_DEVICE=y
-CONFIG_GYROSCOPE_DEVICE=y
-CONFIG_LIGHT_DEVICE=y
 # CONFIG_SERIO is not set
 # CONFIG_CONSOLE_TRANSLATIONS is not set
 # CONFIG_LEGACY_PTYS is not set
-CONFIG_SERIAL_RK29=y
-CONFIG_UART0_RK29=y
-CONFIG_UART0_CTS_RTS_RK29=y
 # CONFIG_HW_RANDOM is not set
 CONFIG_I2C=y
 # CONFIG_I2C_COMPAT is not set
@@ -266,18 +257,22 @@ CONFIG_EXPANDED_GPIO_IRQ_NUM=0
 CONFIG_SPI_FPGA_GPIO_NUM=0
 CONFIG_SPI_FPGA_GPIO_IRQ_NUM=0
 CONFIG_POWER_SUPPLY=y
-CONFIG_TEST_POWER=y
+CONFIG_BATTERY_RK30_ADC_FAC=y
+CONFIG_BATTERY_RK30_AC_CHARGE=y
+CONFIG_BATTERY_RK30_VOL3V8=y
+CONFIG_POWER_ON_CHARGER_DISPLAY=y
 # CONFIG_HWMON is not set
 CONFIG_MFD_TPS65910=y
 CONFIG_MFD_TPS65090=y
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_TPS65910=y
+CONFIG_REGULATOR_ACT8931=y
 CONFIG_RK30_PWM_REGULATOR=y
 CONFIG_MEDIA_SUPPORT=y
 CONFIG_VIDEO_DEV=y
 CONFIG_SOC_CAMERA=y
-CONFIG_SOC_CAMERA_OV2659=y
-CONFIG_SOC_CAMERA_OV5642=y
+CONFIG_SOC_CAMERA_GC0308=y
+CONFIG_GC0308_USER_DEFINED_SERIES=y
 CONFIG_VIDEO_RK29=y
 CONFIG_VIDEO_RK29_CAMMEM_ION=y
 CONFIG_ION=y
@@ -288,7 +283,7 @@ CONFIG_BACKLIGHT_LCD_SUPPORT=y
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
 # CONFIG_BACKLIGHT_GENERIC is not set
 CONFIG_DISPLAY_SUPPORT=y
-CONFIG_LCD_HSD100PXN=y
+CONFIG_LCD_RK2928_A720=y
 CONFIG_FB_ROCKCHIP=y
 CONFIG_LCDC_RK2928=y
 CONFIG_RK_HDMI=y
@@ -375,11 +370,13 @@ CONFIG_USB_SERIAL_OPTION=y
 CONFIG_USB_GADGET=y
 CONFIG_USB20_HOST=y
 CONFIG_USB20_OTG=y
+CONFIG_DWC_OTG_BOTH_HOST_SLAVE=y
 CONFIG_MMC=y
 CONFIG_MMC_UNSAFE_RESUME=y
 CONFIG_MMC_EMBEDDED_SDIO=y
 CONFIG_MMC_PARANOID_SD_INIT=y
 CONFIG_SDMMC_RK29=y
+# CONFIG_SDMMC1_RK29 is not set
 CONFIG_SWITCH=y
 CONFIG_SWITCH_GPIO=y
 CONFIG_RTC_CLASS=y
diff --git a/arch/arm/mach-rk2928/Kconfig b/arch/arm/mach-rk2928/Kconfig
index 6c8548090d2c..ed6ec9fadffb 100644
--- a/arch/arm/mach-rk2928/Kconfig
+++ b/arch/arm/mach-rk2928/Kconfig
@@ -10,7 +10,7 @@ config MACH_RK2928
 
 
 config MACH_RK2928_SDK
-	bool "RK2928 SDK board"
+	bool "RK2928(BGA) SDK board"
 
 config MACH_RK2926_SDK
 	bool "RK2926 SDK board"
diff --git a/arch/arm/mach-rk2928/board-rk2926-sdk.c b/arch/arm/mach-rk2928/board-rk2926-sdk.c
index f477c7c25c6b..4e408ef1d73c 100755
--- a/arch/arm/mach-rk2928/board-rk2926-sdk.c
+++ b/arch/arm/mach-rk2928/board-rk2926-sdk.c
@@ -55,8 +55,8 @@
 #include "../../../drivers/spi/rk29_spim.h"
 #endif
 
-#include "board-rk2928-a720-camera.c" 
-#include "board-rk2928-a720-key.c"
+#include "board-rk2928-sdk-camera.c" 
+#include "board-rk2928-sdk-key.c"
 
 int __sramdata g_pmic_type =  0;
 #define PMIC_TYPE_TPS65910	2
@@ -619,7 +619,7 @@ static struct platform_device *devices[] __initdata = {
 #ifdef CONFIG_I2C0_RK30
 #ifdef CONFIG_MFD_TPS65910
 #define TPS65910_HOST_IRQ        RK2928_PIN1_PB2
-#include "board-rk2928-a720-tps65910.c"
+#include "board-rk2928-sdk-tps65910.c"
 #endif
 #ifdef CONFIG_REGULATOR_ACT8931
 #define ACT8931_HOST_IRQ		RK2928_PIN1_PB1
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c b/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c
index d495acb3251a..dfcf48910200 100755
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk-act8931.c
@@ -8,7 +8,12 @@
 
 #ifdef CONFIG_REGULATOR_ACT8931
 
+#if defined(CONFIG_MACH_RK2928_SDK)
+#define ACT8931_CHGSEL_PIN RK2928_PIN0_PD0
+#else
 #define ACT8931_CHGSEL_PIN RK2928_PIN1_PA1
+#endif
+
 #define ACT8931_CHGSEL_VALUE GPIO_LOW /* Decline to 20% current */
 
 extern int platform_device_register(struct platform_device *pdev);
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-camera.c b/arch/arm/mach-rk2928/board-rk2928-sdk-camera.c
old mode 100644
new mode 100755
index ad549249f5c2..670fc7f6650c
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-camera.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk-camera.c
@@ -2,13 +2,13 @@
 /*---------------- Camera Sensor Macro Define Begin  ------------------------*/
 /*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
 #define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5642						/* back camera sensor */
-#define CONFIG_SENSOR_IIC_ADDR_0		0x78//	0
+#define CONFIG_SENSOR_IIC_ADDR_0		0
 #define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  0
 #define CONFIG_SENSOR_CIF_INDEX_0                    0
 #define CONFIG_SENSOR_ORIENTATION_0 	  90
 #define CONFIG_SENSOR_POWER_PIN_0		  INVALID_GPIO
 #define CONFIG_SENSOR_RESET_PIN_0		  INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_0 	  RK2928_PIN3_PB3
+#define CONFIG_SENSOR_POWERDN_PIN_0 	        INVALID_GPIO//RK2928_PIN3_PB3
 #define CONFIG_SENSOR_FALSH_PIN_0		  INVALID_GPIO
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
@@ -31,7 +31,7 @@
 #define CONFIG_SENSOR_ORIENTATION_01       90
 #define CONFIG_SENSOR_POWER_PIN_01         INVALID_GPIO
 #define CONFIG_SENSOR_RESET_PIN_01         INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_01       RK2928_PIN3_PB3
+#define CONFIG_SENSOR_POWERDN_PIN_01       INVALID_GPIO//RK2928_PIN3_PB3
 #define CONFIG_SENSOR_FALSH_PIN_01         INVALID_GPIO
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_01 RK29_CAM_POWERACTIVE_L
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_01 RK29_CAM_RESETACTIVE_L
@@ -54,7 +54,7 @@
 #define CONFIG_SENSOR_ORIENTATION_02       90
 #define CONFIG_SENSOR_POWER_PIN_02         INVALID_GPIO
 #define CONFIG_SENSOR_RESET_PIN_02         INVALID_GPIO
-#define CONFIG_SENSOR_POWERDN_PIN_02       RK2928_PIN3_PB3
+#define CONFIG_SENSOR_POWERDN_PIN_02       INVALID_GPIO//RK2928_PIN3_PB3
 #define CONFIG_SENSOR_FALSH_PIN_02         INVALID_GPIO
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_02 RK29_CAM_POWERACTIVE_L
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_02 RK29_CAM_RESETACTIVE_L
@@ -70,14 +70,19 @@
 #define CONFIG_SENSOR_SVGA_FPS_FIXED_02      15000
 #define CONFIG_SENSOR_720P_FPS_FIXED_02      30000
 
-#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 0 */
-#define CONFIG_SENSOR_IIC_ADDR_1 	   0// 0x60
-#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  3
+#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_GC0308                      /* front camera sensor 0 */
+#define CONFIG_SENSOR_IIC_ADDR_1 	   0x42
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  1
 #define CONFIG_SENSOR_CIF_INDEX_1				  0
 #define CONFIG_SENSOR_ORIENTATION_1       270
 #define CONFIG_SENSOR_POWER_PIN_1         INVALID_GPIO
 #define CONFIG_SENSOR_RESET_PIN_1         INVALID_GPIO
+
+#if defined(CONFIG_MACH_RK2928_SDK)
+#define CONFIG_SENSOR_POWERDN_PIN_1       RK2928_PIN3_PD7
+#else
 #define CONFIG_SENSOR_POWERDN_PIN_1 	  RK2928_PIN3_PB3
+#endif
 #define CONFIG_SENSOR_FALSH_PIN_1         INVALID_GPIO
 #define CONFIG_SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_L
 #define CONFIG_SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-key.c b/arch/arm/mach-rk2928/board-rk2928-sdk-key.c
index 1074027e5515..9c9b32f9caa6 100755
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-key.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk-key.c
@@ -8,16 +8,14 @@
 #define PRESS_LEV_HIGH			0
 
 static struct rk29_keys_button key_button[] = {
-	{
-		.desc	= "vol-",
-		.code	= KEY_VOLUMEDOWN,
-		.gpio	= RK2928_PIN0_PD1,
-		.active_low = PRESS_LEV_LOW,
-	},
 	{
 		.desc	= "play",
 		.code	= KEY_POWER,
-		.gpio	= RK2928_PIN3_PC5,
+                #if defined(CONFIG_MACH_RK2928_SDK)
+                .gpio	= RK2928_PIN0_PD1,
+                #else
+ 		.gpio   = RK2928_PIN1_PA4,
+                #endif
 		.active_low = PRESS_LEV_LOW,
 		//.code_long_press = EV_ENCALL,
 		.wakeup	= 1,
@@ -25,35 +23,15 @@ static struct rk29_keys_button key_button[] = {
 	{
 		.desc	= "vol+",
 		.code	= KEY_VOLUMEUP,
-		.gpio = RK2928_PIN0_PD0,
-		.active_low = PRESS_LEV_LOW,
-	},
-	{
-		.desc	= "menu",
-		.code	= EV_MENU,
-		.adc_value	= 135,
-		.gpio = INVALID_GPIO,
-		.active_low = PRESS_LEV_LOW,
-	},
-	{
-		.desc	= "home",
-		.code	= KEY_HOME,
-		.adc_value	= 550,
 		.gpio = INVALID_GPIO,
+		.adc_value	= 1,
 		.active_low = PRESS_LEV_LOW,
 	},
 	{
-		.desc	= "esc",
-		.code	= KEY_BACK,
-		.adc_value	= 334,
-		.gpio = INVALID_GPIO,
-		.active_low = PRESS_LEV_LOW,
-	},
-	{
-		.desc	= "camera",
-		.code	= KEY_CAMERA,
-		.adc_value	= 743,
+		.desc	= "vol-",
+		.code	= KEY_VOLUMEDOWN,
 		.gpio = INVALID_GPIO,
+		.adc_value	= 512,
 		.active_low = PRESS_LEV_LOW,
 	},
 };
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c b/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
index 1a8773b6d1bb..7215da55b8b7 100755
--- a/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk-tps65910.c
@@ -7,18 +7,22 @@
 #include <mach/gpio.h>
 #include <mach/iomux.h>
 
-#define gpio_readl(offset)	readl_relaxed(RK2928_GPIO3_BASE + offset)
-#define gpio_writel(v, offset)	do { writel_relaxed(v, RK2928_GPIO3_BASE + offset); dsb(); } while (0)
+#define gpio_readl(offset)	readl_relaxed(RK2928_GPIO1_BASE + offset)
+#define gpio_writel(v, offset)	do { writel_relaxed(v, RK2928_GPIO1_BASE + offset); dsb(); } while (0)
 
 #define GPIO_SWPORTA_DR  0x0000
 #define GPIO_SWPORTA_DDR 0x0004
 
-#define GPIO3_D2_OUTPUT  (1<<26)
-#define GPIO3_D2_OUTPUT_HIGH  (1<<26)
-#define GPIO3_D2_OUTPUT_LOW  (~(1<<26))
+#define GPIO1_A1_OUTPUT  (1<<1)
+#define GPIO1_A1_OUTPUT_HIGH  (1<<1)
+#define GPIO1_A1_OUTPUT_LOW  (~(1<<1))
 
 #ifdef CONFIG_MFD_TPS65910
-#define PMU_POWER_SLEEP RK2928_PIN3_PD2	
+#if defined(CONFIG_MACH_RK2928_SDK)
+#define PMU_POWER_SLEEP RK2928_PIN0_PD0	
+#else
+#define PMU_POWER_SLEEP RK2928_PIN1_PA1	
+#endif
 extern int platform_device_register(struct platform_device *pdev);
 
 int tps65910_pre_init(struct tps65910 *tps65910){
@@ -224,12 +228,16 @@ int tps65910_pre_init(struct tps65910 *tps65910){
 	return 0;
 
 }
+
 int tps65910_post_init(struct tps65910 *tps65910)
 {
 	struct regulator *dcdc;
 	struct regulator *ldo;
 	printk("%s,line=%d\n", __func__,__LINE__);
 
+	g_pmic_type = PMIC_TYPE_TPS65910;
+	printk("%s:g_pmic_type=%d\n",__func__,g_pmic_type);
+
 	#ifdef CONFIG_RK30_PWM_REGULATOR
 	platform_device_register(&pwm_regulator_device[0]);
 	#endif
@@ -240,14 +248,14 @@ int tps65910_post_init(struct tps65910 *tps65910)
 	printk("%s set vio vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
 	regulator_put(dcdc);
 	udelay(100);
-
+        /*
 	ldo = regulator_get(NULL, "vpll");	// vcc25
 	regulator_set_voltage(ldo, 2500000, 2500000);
 	regulator_enable(ldo);
 	printk("%s set vpll vcc25=%dmV end\n", __func__, regulator_get_voltage(ldo));
 	regulator_put(ldo);
 	udelay(100);
-
+        */
 	ldo = regulator_get(NULL, "vdig2");	// vdd12
 	regulator_set_voltage(ldo, 1200000, 1200000);
 	regulator_enable(ldo);
@@ -277,7 +285,7 @@ int tps65910_post_init(struct tps65910 *tps65910)
 	udelay(100);
 	
 	ldo = regulator_get(NULL, "vdig1");	//vcc18_cif
-	regulator_set_voltage(ldo, 1800000, 1800000);
+	regulator_set_voltage(ldo, 1500000, 1500000);
 	regulator_enable(ldo);
 	printk("%s set vdig1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo));
 	regulator_put(ldo);
@@ -296,18 +304,19 @@ int tps65910_post_init(struct tps65910 *tps65910)
 	printk("%s set vaux2 vcca33=%dmV end\n", __func__, regulator_get_voltage(ldo));
 	regulator_put(ldo);
 	udelay(100);
-
-	ldo = regulator_get(NULL, "vdac"); // 
+        /*
+	ldo = regulator_get(NULL, "vdac"); // vccio_wl
 	regulator_set_voltage(ldo,1800000,1800000);
 	regulator_enable(ldo); 
-	printk("%s set vdac =%dmV end\n", __func__, regulator_get_voltage(ldo));
+	printk("%s set vdac vccio_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
 	regulator_put(ldo);
 	udelay(100);
-
+        */
 	ldo = regulator_get(NULL, "vmmc");  //vccio_wl
 	regulator_set_voltage(ldo,3300000,3300000);
 	regulator_enable(ldo); 
 	printk("%s set vmmc vccio_wl=%dmV end\n", __func__, regulator_get_voltage(ldo));
+	regulator_disable(ldo); 
 	regulator_put(ldo);
 	udelay(100);
 
@@ -315,7 +324,6 @@ int tps65910_post_init(struct tps65910 *tps65910)
 	
 	return 0;
 }
-
 static struct regulator_consumer_supply tps65910_smps1_supply[] = {
 	{
 		.supply = "vdd1",
@@ -570,25 +578,23 @@ static struct regulator_init_data tps65910_ldo8 = {
 	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo8_supply),
 	.consumer_supplies =  tps65910_ldo8_supply,
 };
-
-void __sramfunc board_pmu_suspend(void)
+void __sramfunc board_pmu_tps65910_suspend(void)
 {	
 	int ret;
 	ret = gpio_readl(GPIO_SWPORTA_DDR);
-	gpio_writel(ret | GPIO3_D2_OUTPUT, GPIO_SWPORTA_DDR);
+	gpio_writel(ret | GPIO1_A1_OUTPUT, GPIO_SWPORTA_DDR);
 	ret = gpio_readl(GPIO_SWPORTA_DR);
-	gpio_writel(ret | GPIO3_D2_OUTPUT_HIGH, GPIO_SWPORTA_DR);  //set pmu_sleep output high
+	gpio_writel(ret | GPIO1_A1_OUTPUT_HIGH, GPIO_SWPORTA_DR);  //set pmu_sleep output high
 }
-void __sramfunc board_pmu_resume(void)
+void __sramfunc board_pmu_tps65910_resume(void)
 {
 	int ret;
 	ret = gpio_readl(GPIO_SWPORTA_DDR);
-	gpio_writel(ret | GPIO3_D2_OUTPUT, GPIO_SWPORTA_DDR);
+	gpio_writel(ret | GPIO1_A1_OUTPUT, GPIO_SWPORTA_DDR);
 	ret = gpio_readl(GPIO_SWPORTA_DR);
-	gpio_writel(ret & GPIO3_D2_OUTPUT_LOW, GPIO_SWPORTA_DR);   //set pmu_sleep output low
+	gpio_writel(ret & GPIO1_A1_OUTPUT_LOW, GPIO_SWPORTA_DR);   //set pmu_sleep output low
 	sram_udelay(2000);
 }
-
 static struct tps65910_board tps65910_data = {
 	.irq 	= (unsigned)TPS65910_HOST_IRQ,		
 	.irq_base = NR_GIC_IRQS + NR_GPIO_IRQS,
diff --git a/arch/arm/mach-rk2928/board-rk2928-sdk.c b/arch/arm/mach-rk2928/board-rk2928-sdk.c
index ba63ef7a7ae2..4e2a00f5faad 100755
--- a/arch/arm/mach-rk2928/board-rk2928-sdk.c
+++ b/arch/arm/mach-rk2928/board-rk2928-sdk.c
@@ -1,1041 +1,957 @@
-/* arch/arm/mach-rk2928/board-rk2928-fpga.c
- *
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/input.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/skbuff.h>
-#include <linux/spi/spi.h>
-#include <linux/mmc/host.h>
-#include <linux/ion.h>
-#include <linux/cpufreq.h>
-#include <linux/clk.h>
-
-#include <asm/setup.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <asm/mach/flash.h>
-#include <asm/hardware/gic.h>
-#include <mach/dvfs.h>
-
-#include <mach/board.h>
-#include <mach/hardware.h>
-#include <mach/io.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-#include <linux/fb.h>
-#include <linux/regulator/machine.h>
-#include <linux/rfkill-rk.h>
-#include <linux/sensor-dev.h>
-#include <linux/mfd/tps65910.h>
-#include <linux/regulator/rk29-pwm-regulator.h>
-#if defined(CONFIG_HDMI_RK30)
-	#include "../../../drivers/video/rockchip/hdmi/rk_hdmi.h"
-#endif
-
-#if defined(CONFIG_SPIM_RK29)
-#include "../../../drivers/spi/rk29_spim.h"
-#endif
-#if defined(CONFIG_GPS_RK)
-#include "../../../drivers/misc/gps/rk_gps/rk_gps.h"
-#endif
-
-
-#ifdef  CONFIG_THREE_FB_BUFFER
-#define RK30_FB0_MEM_SIZE 12*SZ_1M
-#else
-#define RK30_FB0_MEM_SIZE 8*SZ_1M
-#endif
-
-#include "board-rk2928-sdk-camera.c"
-#include "board-rk2928-sdk-key.c"
-
-#if defined (CONFIG_EETI_EGALAX)
-#define TOUCH_RESET_PIN  RK2928_PIN3_PC3
-#define TOUCH_INT_PIN    RK2928_PIN3_PC7
-
-static int EETI_EGALAX_init_platform_hw(void)
-{
-    if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
-      gpio_free(TOUCH_RESET_PIN);
-      printk("p1003_init_platform_hw gpio_request error\n");
-      return -EIO;
-    }
-
-    if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
-      gpio_free(TOUCH_INT_PIN);
-      printk("p1003_init_platform_hw gpio_request error\n");
-      return -EIO;
-    }
-    gpio_pull_updown(TOUCH_INT_PIN, 1);
-    gpio_direction_output(TOUCH_RESET_PIN, 0);
-    msleep(500);
-    gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
-    msleep(500);
-    gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
-
-    return 0;
-}
-
-
-static struct eeti_egalax_platform_data eeti_egalax_info = {
-  .model= 1003,
-  .init_platform_hw= EETI_EGALAX_init_platform_hw,
-  .standby_pin = INVALID_GPIO,
-  //.standby_value = GPIO_HIGH,
-  .disp_on_pin = INVALID_GPIO,
-  //.disp_on_value = GPIO_HIGH,
-};
-#endif
-
-static struct spi_board_info board_spi_devices[] = {
-};
-
-/***********************************************************
-*	rk30  backlight
-************************************************************/
-#ifdef CONFIG_BACKLIGHT_RK29_BL
-#define PWM_ID            0
-#define PWM_MUX_NAME      GPIO0D2_PWM_0_NAME
-#define PWM_MUX_MODE      GPIO0D_PWM_0
-#define PWM_MUX_MODE_GPIO GPIO0D_GPIO0D2
-#define PWM_GPIO 	  RK2928_PIN0_PD2
-#define PWM_EFFECT_VALUE  1
-
-#define LCD_DISP_ON_PIN
-
-#ifdef  LCD_DISP_ON_PIN
-
-#define BL_EN_PIN         RK2928_PIN3_PC4
-#define BL_EN_VALUE       GPIO_HIGH
-#endif
-static int rk29_backlight_io_init(void)
-{
-	int ret = 0;
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
-#ifdef  LCD_DISP_ON_PIN
-	// rk30_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
-
-	ret = gpio_request(BL_EN_PIN, NULL);
-	if (ret != 0) {
-		gpio_free(BL_EN_PIN);
-	}
-
-	gpio_direction_output(BL_EN_PIN, 0);
-	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
-#endif
-	return ret;
-}
-
-static int rk29_backlight_io_deinit(void)
-{
-	int ret = 0;
-#ifdef  LCD_DISP_ON_PIN
-	gpio_free(BL_EN_PIN);
-#endif
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
-	return ret;
-}
-
-static int rk29_backlight_pwm_suspend(void)
-{
-	int ret = 0;
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
-	if (gpio_request(PWM_GPIO, NULL)) {
-		printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
-		return -1;
-	}
-	gpio_direction_output(PWM_GPIO, GPIO_LOW);
-#ifdef  LCD_DISP_ON_PIN
-	gpio_direction_output(BL_EN_PIN, 0);
-	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
-#endif
-
-	return ret;
-}
-
-static int rk29_backlight_pwm_resume(void)
-{
-	gpio_free(PWM_GPIO);
-	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
-#ifdef  LCD_DISP_ON_PIN
-	msleep(30);
-	gpio_direction_output(BL_EN_PIN, 1);
-	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
-#endif
-	return 0;
-}
-
-static struct rk29_bl_info rk29_bl_info = {
-	.pwm_id = PWM_ID,
-	.bl_ref = PWM_EFFECT_VALUE,
-	.io_init = rk29_backlight_io_init,
-	.io_deinit = rk29_backlight_io_deinit,
-	.pwm_suspend = rk29_backlight_pwm_suspend,
-	.pwm_resume = rk29_backlight_pwm_resume,
-};
-
-static struct platform_device rk29_device_backlight = {
-	.name	= "rk29_backlight",
-	.id 	= -1,
-	.dev	= {
-		.platform_data  = &rk29_bl_info,
-	}
-};
-
-#endif
-
-/*MMA8452 gsensor*/
-#if defined (CONFIG_GS_MMA8452)
-
-static int mma8452_init_platform_hw(void)
-{
-	return 0;
-}
-
-static struct sensor_platform_data mma8452_info = {
-	.type = SENSOR_TYPE_ACCEL,
-	.irq_enable = 1,
-	.poll_delay_ms = 30,
-        .init_platform_hw = mma8452_init_platform_hw,
-        .orientation = {-1, 0, 0, 0, 0, 1, 0, -1, 0},
-};
-#endif
-#if defined (CONFIG_COMPASS_AK8975)
-static struct sensor_platform_data akm8975_info =
-{
-	.type = SENSOR_TYPE_COMPASS,
-	.irq_enable = 1,
-	.poll_delay_ms = 30,
-	.m_layout = 
-	{
-		{
-			{1, 0, 0},
-			{0, 1, 0},
-			{0, 0, 1},
-		},
-
-		{
-			{1, 0, 0},
-			{0, 1, 0},
-			{0, 0, 1},
-		},
-
-		{
-			{1, 0, 0},
-			{0, 1, 0},
-			{0, 0, 1},
-		},
-
-		{
-			{1, 0, 0},
-			{0, 1, 0},
-			{0, 0, 1},
-		},
-	}
-};
-
-#endif
-
-#if defined(CONFIG_GYRO_L3G4200D)
-
-#include <linux/l3g4200d.h>
-
-static int l3g4200d_init_platform_hw(void)
-{
-	return 0;
-}
-
-static struct sensor_platform_data l3g4200d_info = {
-	.type = SENSOR_TYPE_GYROSCOPE,
-	.irq_enable = 1,
-	.poll_delay_ms = 30,
-	.orientation = {0, 1, 0, -1, 0, 0, 0, 0, 1},
-	.init_platform_hw = l3g4200d_init_platform_hw,
-	.x_min = 40,//x_min,y_min,z_min = (0-100) according to hardware
-	.y_min = 40,
-	.z_min = 20,
-};
-
-#endif
-
-#ifdef CONFIG_LS_CM3217
-static struct sensor_platform_data cm3217_info = {
-	.type = SENSOR_TYPE_LIGHT,
-	.irq_enable = 0,
-	.poll_delay_ms = 500,
-};
-
-#endif
-
-#ifdef CONFIG_FB_ROCKCHIP
-
-#define LCD_CABC_MUX_NAME  GPIO2D1_LCDC0_D23_LCDC1_D23_NAME
-#define LCD_CABC_GPIO_MODE GPIO2D_GPIO2D1
-
-#define LCD_CABC_EN        RK2928_PIN2_PD1
-#define LCD_CABC_EN_VALUE  GPIO_HIGH
-
-static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
-{
-	int ret = 0;
-
-        rk30_mux_api_set(LCD_CABC_MUX_NAME, LCD_CABC_GPIO_MODE);
-
-	ret = gpio_request(LCD_CABC_EN, NULL);
-	if (ret != 0)
-	{
-		gpio_free(LCD_CABC_EN);
-		printk(KERN_ERR "request lcd cabc en pin fail!\n");
-		return -1;
-	}
-	else
-	{
-		gpio_direction_output(LCD_CABC_EN, !LCD_CABC_EN_VALUE); //disable
-	}
-	return 0;
-}
-static int rk_fb_io_disable(void)
-{
-	return 0;
-}
-static int rk_fb_io_enable(void)
-{
-	return 0;
-}
-
-#if defined(CONFIG_LCDC_RK2928)
-struct rk29fb_info lcdc_screen_info = {
-	.prop	   = PRMRY,		//primary display device
-	.io_init   = rk_fb_io_init,
-	.io_disable = rk_fb_io_disable,
-	.io_enable = rk_fb_io_enable,
-	.set_screen_info = set_lcd_info,
-};
-#endif
-
-static struct resource resource_fb[] = {
-	[0] = {
-		.name  = "fb0 buf",
-		.start = 0,
-		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.name  = "ipp buf",  //for rotate
-		.start = 0,
-		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[2] = {
-		.name  = "fb2 buf",
-		.start = 0,
-		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device device_fb = {
-	.name		= "rk-fb",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(resource_fb),
-	.resource	= resource_fb,
-};
-#endif
-
-//LCDC
-#ifdef CONFIG_LCDC_RK2928
-static struct resource resource_lcdc[] = {
-	[0] = {
-		.name  = "lcdc reg",
-		.start = RK2928_LCDC_PHYS,
-		.end   = RK2928_LCDC_PHYS + RK2928_LCDC_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	
-	[1] = {
-		.name  = "lcdc irq",
-		.start = IRQ_LCDC,
-		.end   = IRQ_LCDC,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device device_lcdc = {
-	.name		  = "rk2928-lcdc",
-	.id		  = 0,
-	.num_resources	  = ARRAY_SIZE(resource_lcdc),
-	.resource	  = resource_lcdc,
-	.dev 		= {
-		.platform_data = &lcdc_screen_info,
-	},
-};
-#endif
-
-#ifdef CONFIG_ION
-#define ION_RESERVE_SIZE        (80 * SZ_1M)
-static struct ion_platform_data rk30_ion_pdata = {
-	.nr = 1,
-	.heaps = {
-		{
-			.type = ION_HEAP_TYPE_CARVEOUT,
-			.id = ION_NOR_HEAP_ID,
-			.name = "norheap",
-			.size = ION_RESERVE_SIZE,
-		}
-	},
-};
-
-static struct platform_device device_ion = {
-	.name = "ion-rockchip",
-	.id = 0,
-	.dev = {
-		.platform_data = &rk30_ion_pdata,
-	},
-};
-#endif
-
-#ifdef CONFIG_RK30_PWM_REGULATOR
-const static int pwm_voltage_map[] = {
-	1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000, 1400000
-};
-
-static struct regulator_consumer_supply pwm_dcdc1_consumers[] = {
-	{
-		.supply = "vdd_core",
-	}
-};
-
-struct regulator_init_data pwm_regulator_init_dcdc[1] =
-{
-	{
-		.constraints = {
-			.name = "PWM_DCDC1",
-			.min_uV = 600000,
-			.max_uV = 1800000,	//0.6-1.8V
-			.apply_uV = true,
-			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
-		},
-		.num_consumer_supplies = ARRAY_SIZE(pwm_dcdc1_consumers),
-		.consumer_supplies = pwm_dcdc1_consumers,
-	},
-};
-
-static struct pwm_platform_data pwm_regulator_info[1] = {
-	{
-		.pwm_id = 2,
-		.pwm_gpio = RK2928_PIN0_PD4,
-		.pwm_iomux_name = GPIO0D4_PWM_2_NAME,
-		.pwm_iomux_pwm = GPIO0D_PWM_2, 
-		.pwm_iomux_gpio = GPIO0D_GPIO0D4,
-		.pwm_voltage = 1200000,
-		.suspend_voltage = 1050000,
-		.min_uV = 1000000,
-		.max_uV	= 1400000,
-		.coefficient = 455,	//45.5%
-		.pwm_voltage_map = pwm_voltage_map,
-		.init_data	= &pwm_regulator_init_dcdc[0],
-	},
-};
-
-struct platform_device pwm_regulator_device[1] = {
-	{
-		.name = "pwm-voltage-regulator",
-		.id = 0,
-		.dev		= {
-			.platform_data = &pwm_regulator_info[0],
-		}
-	},
-};
-#endif
-/**************************************************************************************************
- * SDMMC devices,  include the module of SD,MMC,and sdio.noted by xbw at 2012-03-05
-**************************************************************************************************/
-#ifdef CONFIG_SDMMC_RK29
-#include "board-rk2928-sdk-sdmmc.c"
-
-#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
-#define SDMMC0_WRITE_PROTECT_PIN	RK2928_PIN1_PA7	//According to your own project to set the value of write-protect-pin.
-#endif
-
-#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
-#define SDMMC1_WRITE_PROTECT_PIN	RK2928_PIN0_PD5	//According to your own project to set the value of write-protect-pin.
-#endif
-
-#define RK29SDK_WIFI_SDIO_CARD_DETECT_N    RK2928_PIN0_PB2
-
-#endif //endif ---#ifdef CONFIG_SDMMC_RK29
-
-#ifdef CONFIG_SDMMC0_RK29
-static int rk29_sdmmc0_cfg_gpio(void)
-{
-	rk29_sdmmc_set_iomux(0, 0xFFFF);
-
-	rk30_mux_api_set(GPIO1C1_MMC0_DETN_NAME, GPIO1C_MMC0_DETN);
-
-#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
-	gpio_request(SDMMC0_WRITE_PROTECT_PIN, "sdmmc-wp");
-	gpio_direction_input(SDMMC0_WRITE_PROTECT_PIN);
-#endif
-
-	return 0;
-}
-
-#define CONFIG_SDMMC0_USE_DMA
-struct rk29_sdmmc_platform_data default_sdmmc0_data = {
-	.host_ocr_avail =
-	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
-	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
-	     MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36),
-	.host_caps =
-	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
-	.io_init = rk29_sdmmc0_cfg_gpio,
-
-#if !defined(CONFIG_SDMMC_RK29_OLD)
-	.set_iomux = rk29_sdmmc_set_iomux,
-#endif
-
-	.dma_name = "sd_mmc",
-#ifdef CONFIG_SDMMC0_USE_DMA
-	.use_dma = 1,
-#else
-	.use_dma = 0,
-#endif
-	.detect_irq = RK2928_PIN1_PC1,	// INVALID_GPIO
-	.enable_sd_wakeup = 0,
-
-#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
-	.write_prt = SDMMC0_WRITE_PROTECT_PIN,
-#else
-	.write_prt = INVALID_GPIO,
-#endif
-};
-#endif // CONFIG_SDMMC0_RK29
-
-#ifdef CONFIG_SDMMC1_RK29
-#define CONFIG_SDMMC1_USE_DMA
-static int rk29_sdmmc1_cfg_gpio(void)
-{
-#if defined(CONFIG_SDMMC_RK29_OLD)
-	rk30_mux_api_set(GPIO0B0_MMC1_CMD_NAME, GPIO0B_MMC1_CMD);
-	rk30_mux_api_set(GPIO0B1_MMC1_CLKOUT_NAME, GPIO0B_MMC1_CLKOUT);
-	rk30_mux_api_set(GPIO0B3_MMC1_D0_NAME, GPIO0B_MMC1_D0);
-	rk30_mux_api_set(GPIO0B4_MMC1_D1_NAME, GPIO0B_MMC1_D1);
-	rk30_mux_api_set(GPIO0B5_MMC1_D2_NAME, GPIO0B_MMC1_D2);
-	rk30_mux_api_set(GPIO0B6_MMC1_D3_NAME, GPIO0B_MMC1_D3);
-	//rk30_mux_api_set(GPIO0B2_MMC1_DETN_NAME, GPIO0B_MMC1_DETN);
-
-#else
-
-#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
-	gpio_request(SDMMC1_WRITE_PROTECT_PIN, "sdio-wp");
-	gpio_direction_input(SDMMC1_WRITE_PROTECT_PIN);
-#endif
-
-#endif
-
-	return 0;
-}
-
-struct rk29_sdmmc_platform_data default_sdmmc1_data = {
-	.host_ocr_avail =
-	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
-	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
-	     MMC_VDD_33_34),
-
-#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
-	.host_caps = (MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
-		      MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
-#else
-	.host_caps =
-	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
-#endif
-
-	.io_init = rk29_sdmmc1_cfg_gpio,
-
-#if !defined(CONFIG_SDMMC_RK29_OLD)
-	.set_iomux = rk29_sdmmc_set_iomux,
-#endif
-
-	.dma_name = "sdio",
-#ifdef CONFIG_SDMMC1_USE_DMA
-	.use_dma = 1,
-#else
-	.use_dma = 0,
-#endif
-
-#if !defined(CONFIG_USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD)
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-	.status = rk29sdk_wifi_status,
-	.register_status_notify = rk29sdk_wifi_status_register,
-#endif
-#if 0
-	.detect_irq = RK29SDK_WIFI_SDIO_CARD_DETECT_N,
-#endif
-
-#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
-	.write_prt = SDMMC1_WRITE_PROTECT_PIN,
-#else
-	.write_prt = INVALID_GPIO,
-#endif
-
-#else
-	.detect_irq = INVALID_GPIO,
-	.enable_sd_wakeup = 0,
-#endif
-
-};
-#endif //endif--#ifdef CONFIG_SDMMC1_RK29
-
-/**************************************************************************************************
- * the end of setting for SDMMC devices
-**************************************************************************************************/
-
-
-
-#ifdef CONFIG_RFKILL_RK
-// bluetooth rfkill device, its driver in net/rfkill/rfkill-rk.c
-static struct rfkill_rk_platform_data rfkill_rk_platdata = {
-    .type               = RFKILL_TYPE_BLUETOOTH,
-
-    .poweron_gpio       = { // BT_REG_ON
-        .io             = INVALID_GPIO,
-        .enable         = GPIO_HIGH,
-        .iomux          = {
-            .name       = NULL,
-        },
-    },
-
-    .reset_gpio         = { // BT_RST
-        .io             = RK2928_PIN3_PD5, // set io to INVALID_GPIO for disable it
-        .enable         = GPIO_LOW,
-        .iomux          = {
-            .name       = NULL,
-        },
-    },
-
-    .wake_gpio          = { // BT_WAKE, use to control bt's sleep and wakeup
-        .io             = RK2928_PIN0_PC6, // set io to INVALID_GPIO for disable it
-        .enable         = GPIO_HIGH,
-        .iomux          = {
-            .name       = NULL,
-        },
-    },
-
-    .wake_host_irq      = { // BT_HOST_WAKE, for bt wakeup host when it is in deep sleep
-        .gpio           = {
-            .io         = RK2928_PIN0_PC5, // set io to INVALID_GPIO for disable it
-            .enable     = GPIO_LOW,      // set GPIO_LOW for falling, set 0 for rising
-            .iomux      = {
-                .name   = NULL,
-            },
-        },
-    },
-
-    .rts_gpio           = { // UART_RTS, enable or disable BT's data coming
-        .io             = RK2928_PIN0_PC3, // set io to INVALID_GPIO for disable it
-        .enable         = GPIO_LOW,
-        .iomux          = {
-            .name       = GPIO0C3_UART0_CTSN_NAME,
-            .fgpio      = GPIO0C_GPIO0C3,
-            .fmux       = GPIO0C_UART0_CTSN,
-        },
-    },
-};
-
-static struct platform_device device_rfkill_rk = {
-    .name   = "rfkill_rk",
-    .id     = -1,
-    .dev    = {
-        .platform_data = &rfkill_rk_platdata,
-    },
-};
-#endif
-
-#ifdef CONFIG_SND_SOC_RK2928
-static struct resource resources_acodec[] = {
-	{
-		.start 	= RK2928_ACODEC_PHYS,
-		.end 	= RK2928_ACODEC_PHYS + RK2928_ACODEC_SIZE - 1,
-		.flags 	= IORESOURCE_MEM,
-	},
-	{
-		.start	= RK2928_PIN3_PD4,
-		.end	= RK2928_PIN3_PD4,
-		.flags	= IORESOURCE_IO,
-	},
-};
-
-static struct platform_device device_acodec = {
-	.name	= "rk2928-codec",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(resources_acodec),
-	.resource	= resources_acodec,
-};
-#endif
-
-#if defined(CONFIG_GPS_RK)
-int rk_gps_io_init(void)
-{
-	printk("%s \n", __FUNCTION__);
-	rk30_mux_api_set(GPIO1B1_SPI_TXD_UART1_SOUT_NAME, GPIO1B_GPIO1B1);//VCC_EN
-	gpio_request(RK2928_PIN1_PB1, NULL);
-	gpio_direction_output(RK2928_PIN1_PB1, GPIO_LOW);
-
-	rk30_mux_api_set(GPIO1A2_I2S_LRCKRX_GPS_CLK_NAME, GPIO1A_GPS_CLK);//GPS_CLK
-	rk30_mux_api_set(GPIO1A4_I2S_SDO_GPS_MAG_NAME, GPIO1A_GPS_MAG);//GPS_MAG
-	rk30_mux_api_set(GPIO1A5_I2S_SDI_GPS_SIGN_NAME, GPIO1A_GPS_SIGN);//GPS_SIGN
-
-	rk30_mux_api_set(GPIO1B0_SPI_CLK_UART1_CTSN_NAME, GPIO1B_GPIO1B0);//SPI_CLK
-	gpio_request(RK2928_PIN1_PB0, NULL);
-	gpio_direction_output(RK2928_PIN1_PB0, GPIO_LOW);
-
-	rk30_mux_api_set(GPIO1B2_SPI_RXD_UART1_SIN_NAME, GPIO1B_GPIO1B2);//SPI_MOSI
-	gpio_request(RK2928_PIN1_PB2, NULL);
-	gpio_direction_output(RK2928_PIN1_PB2, GPIO_LOW);	
-
-	rk30_mux_api_set(GPIO1B3_SPI_CSN0_UART1_RTSN_NAME, GPIO1B_GPIO1B3);//SPI_CS
-	gpio_request(RK2928_PIN1_PB3, NULL);
-	gpio_direction_output(RK2928_PIN1_PB3, GPIO_LOW);		
-	return 0;
-}
-int rk_gps_power_up(void)
-{
-	printk("%s \n", __FUNCTION__);
-
-	return 0;
-}
-
-int rk_gps_power_down(void)
-{
-	printk("%s \n", __FUNCTION__);
-
-	return 0;
-}
-
-int rk_gps_reset_set(int level)
-{
-	return 0;
-}
-int rk_enable_hclk_gps(void)
-{
-	printk("%s \n", __FUNCTION__);
-	clk_enable(clk_get(NULL, "aclk_gps"));
-	return 0;
-}
-int rk_disable_hclk_gps(void)
-{
-	printk("%s \n", __FUNCTION__);
-	clk_disable(clk_get(NULL, "aclk_gps"));
-	return 0;
-}
-struct rk_gps_data rk_gps_info = {
-	.io_init = rk_gps_io_init,
-	.power_up = rk_gps_power_up,
-	.power_down = rk_gps_power_down,
-	.reset = rk_gps_reset_set,
-	.enable_hclk_gps = rk_enable_hclk_gps,
-	.disable_hclk_gps = rk_disable_hclk_gps,
-	.GpsSign = RK2928_PIN1_PA5,
-	.GpsMag = RK2928_PIN1_PA4,        //GPIO index
-	.GpsClk = RK2928_PIN1_PA2,        //GPIO index
-	.GpsVCCEn = RK2928_PIN1_PB1,     //GPIO index
-	.GpsSpi_CSO = RK2928_PIN1_PB3,    //GPIO index
-	.GpsSpiClk = RK2928_PIN1_PB0,     //GPIO index
-	.GpsSpiMOSI = RK2928_PIN1_PB2,	  //GPIO index	
-	.GpsIrq = IRQ_GPS,
-	.GpsSpiEn = 1,
-	.GpsAdcCh = 2,
-	.u32GpsPhyAddr = RK2928_GPS_PHYS,
-	.u32GpsPhySize = RK2928_GPS_SIZE,
-};
-
-struct platform_device rk_device_gps = {
-	.name = "gps_hv5820b",
-	.id = -1,
-	.dev		= {
-	.platform_data = &rk_gps_info,
-		}
-	};
-#endif
-
-
-static struct platform_device *devices[] __initdata = {
-#ifdef CONFIG_FB_ROCKCHIP
-	&device_fb,
-#endif
-#ifdef CONFIG_LCDC_RK2928
-	&device_lcdc,
-#endif
-#ifdef CONFIG_BACKLIGHT_RK29_BL
-	&rk29_device_backlight,
-#endif
-#ifdef CONFIG_ION
-	&device_ion,
-#endif
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-	&rk29sdk_wifi_device,
-#endif
-#ifdef CONFIG_RFKILL_RK
-	&device_rfkill_rk,
-#endif
-#ifdef CONFIG_SND_SOC_RK2928
-	&device_acodec,
-#endif
-#ifdef CONFIG_GPS_RK
-	&rk_device_gps,
-#endif
-
-};
-//i2c
-#ifdef CONFIG_I2C0_RK30
-static struct i2c_board_info __initdata i2c0_info[] = {
-#if defined (CONFIG_GS_MMA8452)
-	{
-		.type	        = "gs_mma8452",
-		.addr	        = 0x1d,
-		.flags	        = 0,
-		.irq	        = RK2928_PIN3_PD1,
-		.platform_data = &mma8452_info,
-	},
-#endif
-#if defined (CONFIG_COMPASS_AK8975)
-	{
-		.type          = "ak8975",
-		.addr          = 0x0d,
-		.flags         = 0,
-		.irq           = RK2928_PIN3_PD2,
-		.platform_data = &akm8975_info,
-	},
-#endif
-#if defined (CONFIG_GYRO_L3G4200D)
-	{
-		.type          = "l3g4200d_gryo",
-		.addr          = 0x69,
-		.flags         = 0,
-		.irq           = RK2928_PIN3_PD3,
-		.platform_data = &l3g4200d_info,
-	},
-#endif
-};
-#endif
-#ifdef CONFIG_I2C1_RK30
-#ifdef CONFIG_MFD_TPS65910
-#define TPS65910_HOST_IRQ        RK2928_PIN3_PC6
-#include "board-rk2928-sdk-tps65910.c"
-#endif
-static struct i2c_board_info __initdata i2c1_info[] = {
-
-#if defined (CONFIG_MFD_TPS65910)
-	{
-        .type           = "tps65910",
-        .addr           = TPS65910_I2C_ID0,
-        .flags          = 0,
-        .irq            = TPS65910_HOST_IRQ,
-    	.platform_data = &tps65910_data,
-	},
-#endif
-
-};
-#endif
-#ifdef CONFIG_I2C2_RK30
-static struct i2c_board_info __initdata i2c2_info[] = {
-#if defined (CONFIG_EETI_EGALAX)
-        {
-                .type           = "egalax_i2c",
-                .addr           = 0x04,
-                .flags          = 0,
-                .irq            = RK2928_PIN3_PC7,
-                .platform_data  = &eeti_egalax_info,
-        },
-#endif
-#if defined (CONFIG_LS_CM3217)
-	{
-		.type          = "lightsensor",
-		.addr          = 0x10,
-		.flags         = 0,
-		.platform_data = &cm3217_info,
-	},
-#endif
-};
-#endif
-#ifdef CONFIG_I2C3_RK30
-static struct i2c_board_info __initdata i2c3_info[] = {
-};
-#endif
-#ifdef CONFIG_I2C_GPIO_RK30
-#define I2C_SDA_PIN     INVALID_GPIO   //set sda_pin here
-#define I2C_SCL_PIN     INVALID_GPIO   //set scl_pin here
-static int rk30_i2c_io_init(void)
-{
-        //set iomux (gpio) here
-
-        return 0;
-}
-struct i2c_gpio_platform_data default_i2c_gpio_data = {
-       .sda_pin = I2C_SDA_PIN,
-       .scl_pin = I2C_SCL_PIN,
-       .udelay = 5, // clk = 500/udelay = 100Khz
-       .timeout = 100,//msecs_to_jiffies(100),
-       .bus_num    = 5,
-       .io_init = rk30_i2c_io_init,
-};
-static struct i2c_board_info __initdata i2c_gpio_info[] = {
-};
-#endif
-static void __init rk30_i2c_register_board_info(void)
-{
-#ifdef CONFIG_I2C0_RK30
-	i2c_register_board_info(0, i2c0_info, ARRAY_SIZE(i2c0_info));
-#endif
-#ifdef CONFIG_I2C1_RK30
-	i2c_register_board_info(1, i2c1_info, ARRAY_SIZE(i2c1_info));
-#endif
-#ifdef CONFIG_I2C2_RK30
-	i2c_register_board_info(2, i2c2_info, ARRAY_SIZE(i2c2_info));
-#endif
-#ifdef CONFIG_I2C3_RK30
-	i2c_register_board_info(3, i2c3_info, ARRAY_SIZE(i2c3_info));
-#endif
-#ifdef CONFIG_I2C_GPIO_RK30
-	i2c_register_board_info(4, i2c_gpio_info, ARRAY_SIZE(i2c_gpio_info));
-#endif
-}
-//end of i2c
-
-#define POWER_ON_PIN RK2928_PIN3_PC5   //power_hold
-static void rk2928_pm_power_off(void)
-{
-	printk(KERN_ERR "rk2928_pm_power_off start...\n");
-	
-	#if defined(CONFIG_MFD_TPS65910)
-		tps65910_device_shutdown();//tps65910 shutdown
-	#endif
-	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
-	
-};
-
-static void __init rk2928_board_init(void)
-{
-	gpio_request(POWER_ON_PIN, "poweronpin");
-	gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
-        gpio_free(POWER_ON_PIN);
-	
-	pm_power_off = rk2928_pm_power_off;
-	
-	rk30_i2c_register_board_info();
-	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-        //RK2928 USB DETECT IRQ: IRQ_OTG_BVALID
-	//board_usb_detect_init(RK30_PIN6_PA3);
-
-#ifdef CONFIG_WIFI_CONTROL_FUNC
-	rk29sdk_wifi_bt_gpio_control_init();
-#endif
-}
-
-static void __init rk2928_reserve(void)
-{
-#ifdef CONFIG_ION
-	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
-#endif
-#ifdef CONFIG_FB_ROCKCHIP
-	resource_fb[0].start = board_mem_reserve_add("fb0", RK30_FB0_MEM_SIZE);
-	resource_fb[0].end = resource_fb[0].start + RK30_FB0_MEM_SIZE - 1;
-#if 0
-	resource_fb[1].start = board_mem_reserve_add("ipp buf", RK30_FB0_MEM_SIZE);
-	resource_fb[1].end = resource_fb[1].start + RK30_FB0_MEM_SIZE - 1;
-	resource_fb[2].start = board_mem_reserve_add("fb2", RK30_FB0_MEM_SIZE);
-	resource_fb[2].end = resource_fb[2].start + RK30_FB0_MEM_SIZE - 1;
-#endif
-#endif
-#ifdef CONFIG_VIDEO_RK29
-	rk30_camera_request_reserve_mem();
-#endif
-	
-#ifdef CONFIG_GPS_RK
-	//it must be more than 8MB
-	rk_gps_info.u32MemoryPhyAddr = board_mem_reserve_add("gps", SZ_8M);
-#endif
-
-	board_mem_reserved();
-}
-/**
- * dvfs_cpu_logic_table: table for arm and logic dvfs 
- * @frequency	: arm frequency
- * @cpu_volt	: arm voltage depend on frequency
- * @logic_volt	: logic voltage arm requests depend on frequency
- * comments	: min arm/logic voltage
- */
-static struct dvfs_arm_table dvfs_cpu_logic_table[] = {
-	{.frequency = 216 * 1000,	.cpu_volt = 1200 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 312 * 1000,	.cpu_volt = 1200 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 408 * 1000,	.cpu_volt = 1200 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 504 * 1000,	.cpu_volt = 1200 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 600 * 1000,	.cpu_volt = 1200 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 696 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 816 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 912 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
-#if 0
-	{.frequency = 1008 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 1104 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 1200 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 1104 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = 1248 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
-#endif
-	//{.frequency = 1000 * 1000,	.cpu_volt = 1225 * 1000,	.logic_volt = 1200 * 1000},
-	{.frequency = CPUFREQ_TABLE_END},
-};
-
-static struct cpufreq_frequency_table dvfs_gpu_table[] = {
-	{.frequency = 266 * 1000,	.index = 1050 * 1000},
-	{.frequency = 400 * 1000,	.index = 1275 * 1000},
-	{.frequency = CPUFREQ_TABLE_END},
-};
-
-static struct cpufreq_frequency_table dvfs_ddr_table[] = {
-	{.frequency = 300 * 1000,	.index = 1050 * 1000},
-	{.frequency = 400 * 1000,	.index = 1125 * 1000},
-	{.frequency = CPUFREQ_TABLE_END},
-};
-
-#define DVFS_CPU_TABLE_SIZE	(ARRAY_SIZE(dvfs_cpu_logic_table))
-static struct cpufreq_frequency_table cpu_dvfs_table[DVFS_CPU_TABLE_SIZE];
-static struct cpufreq_frequency_table dep_cpu2core_table[DVFS_CPU_TABLE_SIZE];
-
-void __init board_clock_init(void)
-{
-	rk2928_clock_data_init(periph_pll_default, codec_pll_default, RK30_CLOCKS_DEFAULT_FLAGS);
-	dvfs_set_arm_logic_volt(dvfs_cpu_logic_table, cpu_dvfs_table, dep_cpu2core_table);
-	dvfs_set_freq_volt_table(clk_get(NULL, "gpu"), dvfs_gpu_table);
-	//dvfs_set_freq_volt_table(clk_get(NULL, "ddr"), dvfs_ddr_table);
-	printk("%s end\n", __func__);
-}
-
-
-MACHINE_START(RK2928, "RK2928board")
-	.boot_params	= PLAT_PHYS_OFFSET + 0x800,
-	.fixup		= rk2928_fixup,
-	.reserve	= &rk2928_reserve,
-	.map_io		= rk2928_map_io,
-	.init_irq	= rk2928_init_irq,
-	.timer		= &rk2928_timer,
-	.init_machine	= rk2928_board_init,
-MACHINE_END
+/* arch/arm/mach-rk2928/board-rk2928-fpga.c
+ *
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/skbuff.h>
+#include <linux/spi/spi.h>
+#include <linux/mmc/host.h>
+#include <linux/ion.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/hardware/gic.h>
+#include <mach/dvfs.h>
+
+#include <mach/board.h>
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <linux/fb.h>
+#include <linux/regulator/machine.h>
+#include <linux/rfkill-rk.h>
+#include <linux/sensor-dev.h>
+#include <linux/mfd/tps65910.h>
+#include <linux/regulator/act8931.h>
+#include <linux/regulator/rk29-pwm-regulator.h>
+#if defined(CONFIG_HDMI_RK30)
+	#include "../../../drivers/video/rockchip/hdmi/rk_hdmi.h"
+#endif
+
+#if defined(CONFIG_SPIM_RK29)
+#include "../../../drivers/spi/rk29_spim.h"
+#endif
+
+#include "board-rk2928-sdk-camera.c" 
+#include "board-rk2928-sdk-key.c"
+
+int __sramdata g_pmic_type =  0;
+#define PMIC_TYPE_TPS65910	2
+#define PMIC_TYPE_ACT8931	3
+
+#ifdef  CONFIG_THREE_FB_BUFFER
+#define RK30_FB0_MEM_SIZE 12*SZ_1M
+#else
+#define RK30_FB0_MEM_SIZE 8*SZ_1M
+#endif
+
+static struct spi_board_info board_spi_devices[] = {
+};
+
+/***********************************************************
+*	rk30  backlight
+************************************************************/
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+#define PWM_ID            0
+#define PWM_MUX_NAME      GPIO0D2_PWM_0_NAME
+#define PWM_MUX_MODE      GPIO0D_PWM_0
+#define PWM_MUX_MODE_GPIO GPIO0D_GPIO0D2
+#define PWM_GPIO 	  RK2928_PIN0_PD2
+#define PWM_EFFECT_VALUE  0
+
+#define LCD_DISP_ON_PIN
+
+#ifdef  LCD_DISP_ON_PIN
+
+#define BL_EN_PIN         RK2928_PIN3_PC5
+#define BL_EN_VALUE       GPIO_HIGH
+#endif
+static int rk29_backlight_io_init(void)
+{
+	int ret = 0;
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
+#ifdef  LCD_DISP_ON_PIN
+	// rk30_mux_api_set(BL_EN_MUX_NAME, BL_EN_MUX_MODE);
+
+	ret = gpio_request(BL_EN_PIN, NULL);
+	if (ret != 0) {
+		gpio_free(BL_EN_PIN);
+	}
+
+	gpio_direction_output(BL_EN_PIN, 0);
+	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#endif
+	return ret;
+}
+
+static int rk29_backlight_io_deinit(void)
+{
+	int ret = 0;
+#ifdef  LCD_DISP_ON_PIN
+	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
+	gpio_free(BL_EN_PIN);
+#endif
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
+	return ret;
+}
+
+static int rk29_backlight_pwm_suspend(void)
+{
+	int ret = 0;
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE_GPIO);
+	if (gpio_request(PWM_GPIO, NULL)) {
+		printk("func %s, line %d: request gpio fail\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+	#if defined(CONFIG_MFD_TPS65910)	
+	if(g_pmic_type == PMIC_TYPE_TPS65910)
+	{
+		gpio_direction_output(PWM_GPIO, GPIO_LOW);
+	}
+	#endif
+	#if defined(CONFIG_REGULATOR_ACT8931)
+	if(g_pmic_type == PMIC_TYPE_ACT8931)
+	{
+		gpio_direction_output(PWM_GPIO, GPIO_HIGH);
+	}
+	#endif
+#ifdef  LCD_DISP_ON_PIN
+	gpio_direction_output(BL_EN_PIN, 0);
+	gpio_set_value(BL_EN_PIN, !BL_EN_VALUE);
+#endif
+
+	return ret;
+}
+
+static int rk29_backlight_pwm_resume(void)
+{
+	gpio_free(PWM_GPIO);
+	rk30_mux_api_set(PWM_MUX_NAME, PWM_MUX_MODE);
+#ifdef  LCD_DISP_ON_PIN
+	msleep(30);
+	gpio_direction_output(BL_EN_PIN, 1);
+	gpio_set_value(BL_EN_PIN, BL_EN_VALUE);
+#endif
+	return 0;
+}
+
+static struct rk29_bl_info rk29_bl_info = {
+	.pwm_id = PWM_ID,
+        .min_brightness = 80,
+	.bl_ref = PWM_EFFECT_VALUE,
+	.io_init = rk29_backlight_io_init,
+	.io_deinit = rk29_backlight_io_deinit,
+	.pwm_suspend = rk29_backlight_pwm_suspend,
+	.pwm_resume = rk29_backlight_pwm_resume,
+};
+
+static struct platform_device rk29_device_backlight = {
+	.name	= "rk29_backlight",
+	.id 	= -1,
+	.dev	= {
+		.platform_data  = &rk29_bl_info,
+	}
+};
+
+#endif
+
+#ifdef CONFIG_FB_ROCKCHIP
+
+#define LCD_MUX_NAME  GPIO0C2_UART0_RTSN_NAME
+#define LCD_GPIO_MODE GPIO0C_GPIO0C2
+
+#define LCD_EN        RK2928_PIN3_PB3
+#define LCD_EN_VALUE  GPIO_LOW
+
+static int rk_fb_io_init(struct rk29_fb_setting_info *fb_setting)
+{
+	int ret = 0;
+
+        rk30_mux_api_set(LCD_MUX_NAME, LCD_GPIO_MODE);
+
+	ret = gpio_request(LCD_EN, NULL);
+	if (ret != 0)
+	{
+		gpio_free(LCD_EN);
+		printk(KERN_ERR "request lcd en pin fail!\n");
+		return -1;
+	}
+	else
+	{
+		gpio_direction_output(LCD_EN, LCD_EN_VALUE); //disable
+	}
+	return 0;
+}
+static int rk_fb_io_disable(void)
+{
+
+	#if 0//defined(CONFIG_REGULATOR_ACT8931)
+	if(g_pmic_type == PMIC_TYPE_ACT8931)
+	{
+		struct regulator *ldo;
+		ldo = regulator_get(NULL, "act_ldo4");	 //vcc_lcd
+		regulator_disable(ldo);
+		regulator_put(ldo);
+		udelay(100);
+	}
+	#endif
+        gpio_set_value(LCD_EN, !LCD_EN_VALUE);
+	return 0;
+}
+static int rk_fb_io_enable(void)
+{
+	#if 0//defined(CONFIG_REGULATOR_ACT8931)
+	if(g_pmic_type == PMIC_TYPE_ACT8931)
+	{
+		struct regulator *ldo;
+		ldo = regulator_get(NULL, "act_ldo4");	 //vcc_lcd
+		regulator_enable(ldo);
+		regulator_put(ldo);
+		udelay(100);
+		msleep(300);	// wait for powering on LED circuit
+	}
+	#endif
+
+        gpio_set_value(LCD_EN, LCD_EN_VALUE);
+	return 0;
+}
+
+#if defined(CONFIG_LCDC_RK2928)
+struct rk29fb_info lcdc_screen_info = {
+	.prop	   = PRMRY,		//primary display device
+	.io_init   = rk_fb_io_init,
+	.io_disable = rk_fb_io_disable,
+	.io_enable = rk_fb_io_enable,
+	.set_screen_info = set_lcd_info,
+};
+#endif
+
+static struct resource resource_fb[] = {
+	[0] = {
+		.name  = "fb0 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name  = "ipp buf",  //for rotate
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.name  = "fb2 buf",
+		.start = 0,
+		.end   = 0,//RK30_FB0_MEM_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device device_fb = {
+	.name		= "rk-fb",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(resource_fb),
+	.resource	= resource_fb,
+};
+#endif
+
+//LCDC
+#ifdef CONFIG_LCDC_RK2928
+static struct resource resource_lcdc[] = {
+	[0] = {
+		.name  = "lcdc reg",
+		.start = RK2928_LCDC_PHYS,
+		.end   = RK2928_LCDC_PHYS + RK2928_LCDC_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	
+	[1] = {
+		.name  = "lcdc irq",
+		.start = IRQ_LCDC,
+		.end   = IRQ_LCDC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device device_lcdc = {
+	.name		  = "rk2928-lcdc",
+	.id		  = 0,
+	.num_resources	  = ARRAY_SIZE(resource_lcdc),
+	.resource	  = resource_lcdc,
+	.dev 		= {
+		.platform_data = &lcdc_screen_info,
+	},
+};
+#endif
+
+#ifdef CONFIG_ION
+#define ION_RESERVE_SIZE        (80 * SZ_1M)
+static struct ion_platform_data rk30_ion_pdata = {
+	.nr = 1,
+	.heaps = {
+		{
+			.type = ION_HEAP_TYPE_CARVEOUT,
+			.id = ION_NOR_HEAP_ID,
+			.name = "norheap",
+			.size = ION_RESERVE_SIZE,
+		}
+	},
+};
+
+static struct platform_device device_ion = {
+	.name = "ion-rockchip",
+	.id = 0,
+	.dev = {
+		.platform_data = &rk30_ion_pdata,
+	},
+};
+#endif
+
+#if defined (CONFIG_TOUCHSCREEN_GT811_IIC)
+#define TOUCH_RESET_PIN  RK2928_PIN3_PC3
+#define TOUCH_INT_PIN    RK2928_PIN3_PC7
+int gt811_init_platform_hw(void)
+{
+    if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
+      gpio_free(TOUCH_RESET_PIN);
+      printk("gt811_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+
+    if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+      gpio_free(TOUCH_INT_PIN);
+      printk("gt811_init_platform_hw gpio_request error\n");
+      return -EIO;
+    }
+    //gpio_pull_updown(TOUCH_INT_PIN, 1);
+    gpio_direction_output(TOUCH_RESET_PIN, 0);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+    msleep(500);
+    gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+	mdelay(100);
+
+    return 0;
+}
+
+
+static struct goodix_platform_data gt811_info = {
+  .model= 811,
+  .init_platform_hw= gt811_init_platform_hw,
+
+};
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_SITRONIX_A720)
+
+#define TOUCH_RESET_PIN	 RK2928_PIN1_PA3
+#define TOUCH_INT_PIN 	 RK2928_PIN1_PB3
+int ft5306_init_platform_hw(void)
+{
+
+        //printk("ft5306_init_platform_hw\n");
+        if(gpio_request(TOUCH_RESET_PIN,NULL) != 0){
+                gpio_free(TOUCH_RESET_PIN);
+                printk("ft5306_init_platform_hw gpio_request error\n");
+                return -EIO;
+        }
+
+        if(gpio_request(TOUCH_INT_PIN,NULL) != 0){
+                gpio_free(TOUCH_INT_PIN);
+                printk("ift5306_init_platform_hw gpio_request error\n");
+                return -EIO;
+        }
+        gpio_direction_output(TOUCH_RESET_PIN, GPIO_HIGH);
+        mdelay(10);
+        gpio_set_value(TOUCH_RESET_PIN,GPIO_LOW);
+        mdelay(10);
+        gpio_set_value(TOUCH_RESET_PIN,GPIO_HIGH);
+        msleep(300);
+        return 0;
+
+}
+
+struct ft5x0x_platform_data sitronix_info = {
+        .model = 5007,
+        .init_platform_hw= ft5306_init_platform_hw,
+};
+#endif
+
+
+
+/*MMA7660 gsensor*/
+#if defined (CONFIG_GS_MMA7660)
+#define MMA7660_INT_PIN   RK2928_PIN3_PD1
+
+static int mma7660_init_platform_hw(void)
+{
+	rk30_mux_api_set(GPIO1B1_SPI_TXD_UART1_SOUT_NAME, GPIO1B_GPIO1B1);
+
+	return 0;
+}
+
+static struct sensor_platform_data mma7660_info = {
+	.type = SENSOR_TYPE_ACCEL,
+	.irq_enable = 1,
+	.poll_delay_ms = 30,
+        .init_platform_hw = mma7660_init_platform_hw,
+        .orientation = {-1, 0, 0, 0, 0, 1, 0, -1, 0},
+};
+#endif
+
+
+#if CONFIG_RK30_PWM_REGULATOR
+static int pwm_voltage_map[] = {
+	1000000, 1025000, 1050000, 1075000, 1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 1250000, 1275000, 1300000, 1325000, 1350000, 1375000, 1400000
+};
+
+static struct regulator_consumer_supply pwm_dcdc1_consumers[] = {
+	{
+		.supply = "vdd_core",
+	}
+};
+
+struct regulator_init_data pwm_regulator_init_dcdc[1] =
+{
+	{
+		.constraints = {
+			.name = "PWM_DCDC1",
+			.min_uV = 600000,
+			.max_uV = 1800000,	//0.6-1.8V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(pwm_dcdc1_consumers),
+		.consumer_supplies = pwm_dcdc1_consumers,
+	},
+};
+
+static struct pwm_platform_data pwm_regulator_info[1] = {
+	{
+		.pwm_id = 2,
+		.pwm_gpio = RK2928_PIN0_PD4,
+		.pwm_iomux_name = GPIO0D4_PWM_2_NAME,
+		.pwm_iomux_pwm = GPIO0D_PWM_2, 
+		.pwm_iomux_gpio = GPIO0D_GPIO0D4,
+		.pwm_voltage = 1200000,
+		.suspend_voltage = 1050000,
+		.min_uV = 1000000,
+		.max_uV	= 1400000,
+		.coefficient = 455,	//45.5%
+		.pwm_voltage_map = pwm_voltage_map,
+		.init_data	= &pwm_regulator_init_dcdc[0],
+	},
+};
+
+struct platform_device pwm_regulator_device[1] = {
+	{
+		.name = "pwm-voltage-regulator",
+		.id = 0,
+		.dev		= {
+			.platform_data = &pwm_regulator_info[0],
+		}
+	},
+};
+#endif
+
+/***********************************************************
+*	usb wifi
+************************************************************/
+#if defined(CONFIG_RTL8192CU) || defined(CONFIG_RTL8188EU) 
+
+static void rkusb_wifi_power(int on) {
+	struct regulator *ldo = NULL;
+	
+#if defined(CONFIG_MFD_TPS65910)	
+	if(g_pmic_type == PMIC_TYPE_TPS65910) {
+		ldo = regulator_get(NULL, "vmmc");  //vccio_wl
+	}
+#endif
+#if defined(CONFIG_REGULATOR_ACT8931)
+	if(g_pmic_type == PMIC_TYPE_ACT8931) {
+		ldo = regulator_get(NULL, "act_ldo4");  //vccio_wl
+	}
+#endif	
+	
+	if(on) {
+		regulator_enable(ldo);
+		printk("%s: vccio_wl enable\n", __func__);
+	} else {
+		printk("%s: vccio_wl disable\n", __func__);
+		regulator_disable(ldo);
+	}
+	
+	regulator_put(ldo);
+	udelay(100);
+}
+
+#endif
+
+/**************************************************************************************************
+ * SDMMC devices,  include the module of SD,MMC,and sdio.noted by xbw at 2012-03-05
+**************************************************************************************************/
+#ifdef CONFIG_SDMMC_RK29
+#include "board-rk2928-sdk-sdmmc.c"
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+#define SDMMC0_WRITE_PROTECT_PIN	RK2928_PIN1_PA7	//According to your own project to set the value of write-protect-pin.
+#endif
+
+#if defined(CONFIG_SDMMC1_RK29_WRITE_PROTECT)
+#define SDMMC1_WRITE_PROTECT_PIN	RK2928_PIN0_PD5	//According to your own project to set the value of write-protect-pin.
+#endif
+
+#define RK29SDK_WIFI_SDIO_CARD_DETECT_N    RK2928_PIN0_PB2
+
+#define RK29SDK_SD_CARD_DETECT_N        RK2928_PIN2_PA7  //According to your own project to set the value of card-detect-pin.
+#define RK29SDK_SD_CARD_INSERT_LEVEL    GPIO_LOW         // set the voltage of insert-card. Please pay attention to the default setting.
+
+
+#endif //endif ---#ifdef CONFIG_SDMMC_RK29
+
+#ifdef CONFIG_SDMMC0_RK29
+static int rk29_sdmmc0_cfg_gpio(void)
+{
+	rk29_sdmmc_set_iomux(0, 0xFFFF);
+
+#if defined(CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO)
+    rk30_mux_api_set(GPIO1C1_MMC0_DETN_NAME, GPIO1C_GPIO1C1);
+   // gpio_request(RK29SDK_SD_CARD_DETECT_N, "sd-detect");
+   // gpio_direction_output(RK29SDK_SD_CARD_DETECT_N,GPIO_HIGH);//set mmc0-data1 to high.
+#else
+	rk30_mux_api_set(GPIO1C1_MMC0_DETN_NAME, GPIO1C_MMC0_DETN);
+#endif	
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	gpio_request(SDMMC0_WRITE_PROTECT_PIN, "sdmmc-wp");
+	gpio_direction_input(SDMMC0_WRITE_PROTECT_PIN);
+#endif
+
+	return 0;
+}
+
+#define CONFIG_SDMMC0_USE_DMA
+struct rk29_sdmmc_platform_data default_sdmmc0_data = {
+	.host_ocr_avail =
+	    (MMC_VDD_25_26 | MMC_VDD_26_27 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+	     MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 |
+	     MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36),
+	.host_caps =
+	    (MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED),
+	.io_init = rk29_sdmmc0_cfg_gpio,
+
+#if !defined(CONFIG_SDMMC_RK29_OLD)
+	.set_iomux = rk29_sdmmc_set_iomux,
+#endif
+
+	.dma_name = "sd_mmc",
+#ifdef CONFIG_SDMMC0_USE_DMA
+	.use_dma = 1,
+#else
+	.use_dma = 0,
+#endif
+
+#if defined(CONFIG_SDMMC0_RK29_SDCARD_DET_FROM_GPIO)
+    .detect_irq = RK29SDK_SD_CARD_DETECT_N,
+    .insert_card_level = RK29SDK_SD_CARD_INSERT_LEVEL,
+#else
+	.detect_irq = INVALID_GPIO,
+#endif
+
+	.enable_sd_wakeup = 0,
+
+#if defined(CONFIG_SDMMC0_RK29_WRITE_PROTECT)
+	.write_prt = SDMMC0_WRITE_PROTECT_PIN,
+#else
+	.write_prt = INVALID_GPIO,
+#endif
+};
+#endif // CONFIG_SDMMC0_RK29
+
+#ifdef CONFIG_SND_SOC_RK2928
+static struct resource resources_acodec[] = {
+	{
+		.start 	= RK2928_ACODEC_PHYS,
+		.end 	= RK2928_ACODEC_PHYS + RK2928_ACODEC_SIZE - 1,
+		.flags 	= IORESOURCE_MEM,
+	},
+	{
+		.start	= RK2928_PIN3_PD4,
+		.end	= RK2928_PIN3_PD4,
+		.flags	= IORESOURCE_IO,
+	},
+};
+
+static struct platform_device device_acodec = {
+	.name	= "rk2928-codec",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(resources_acodec),
+	.resource	= resources_acodec,
+};
+#endif
+
+#ifdef CONFIG_BATTERY_RK30_ADC_FAC
+static struct rk30_adc_battery_platform_data rk30_adc_battery_platdata = {
+        .dc_det_pin      = RK2928_PIN1_PB4,//INVALID_GPIO,
+        .batt_low_pin    = INVALID_GPIO,
+        .charge_set_pin  = INVALID_GPIO,
+	 .charge_ok_pin   = RK2928_PIN1_PA0,
+        .dc_det_level    = GPIO_LOW,
+        .charge_ok_level = GPIO_HIGH,
+};
+
+static struct platform_device rk30_device_adc_battery = {
+        .name   = "rk30-battery",
+        .id     = -1,
+        .dev = {
+                .platform_data = &rk30_adc_battery_platdata,
+        },
+};
+#endif
+
+static struct platform_device *devices[] __initdata = {
+#ifdef CONFIG_FB_ROCKCHIP
+	&device_fb,
+#endif
+#ifdef CONFIG_LCDC_RK2928
+	&device_lcdc,
+#endif
+#ifdef CONFIG_BACKLIGHT_RK29_BL
+	&rk29_device_backlight,
+#endif
+#ifdef CONFIG_ION
+	&device_ion,
+#endif
+#ifdef CONFIG_SND_SOC_RK2928
+	&device_acodec,
+#endif
+#ifdef CONFIG_BATTERY_RK30_ADC_FAC
+	&rk30_device_adc_battery,
+#endif
+};
+//i2c
+#ifdef CONFIG_I2C0_RK30
+#ifdef CONFIG_MFD_TPS65910
+#define TPS65910_HOST_IRQ        RK2928_PIN1_PB2
+#include "board-rk2928-sdk-tps65910.c"
+#endif
+#ifdef CONFIG_REGULATOR_ACT8931
+#define ACT8931_HOST_IRQ		RK2928_PIN3_PC6
+#include "board-rk2928-sdk-act8931.c"
+#endif
+
+static struct i2c_board_info __initdata i2c0_info[] = {
+#if defined (CONFIG_MFD_TPS65910)
+	{
+        .type           = "tps65910",
+        .addr           = TPS65910_I2C_ID0,
+        .flags          = 0,
+        .irq            = TPS65910_HOST_IRQ,
+    	.platform_data = &tps65910_data,
+	},
+#endif
+#if defined (CONFIG_REGULATOR_ACT8931)
+	{
+		.type    		= "act8931",
+		.addr           = 0x5b, 
+		.flags			= 0,
+		.irq            = ACT8931_HOST_IRQ,
+		.platform_data=&act8931_data,
+	},
+#endif
+#ifdef CONFIG_MACH_RK2926_M713
+#if defined (CONFIG_RTC_HYM8563)
+	{
+		.type    		= "rtc_hym8563",
+		.addr           = 0x51,
+		.flags			= 0,
+		.irq            = RK2928_PIN1_PA5,
+	},
+#endif
+#endif
+};
+#endif
+
+int __sramdata gpio0d4_iomux,gpio0d4_do,gpio0d4_dir;
+
+#define gpio0_readl(offset)	readl_relaxed(RK2928_GPIO0_BASE + offset)
+#define gpio0_writel(v, offset)	do { writel_relaxed(v, RK2928_GPIO0_BASE + offset); dsb(); } while (0)
+
+void __sramfunc rk30_pwm_logic_suspend_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+
+//	int gpio0d7_iomux,gpio0d7_do,gpio0d7_dir,gpio0d7_en;
+	sram_udelay(10000);
+	gpio0d4_iomux = readl_relaxed(GRF_GPIO0D_IOMUX);
+	gpio0d4_do = gpio0_readl(GPIO_SWPORTA_DR);
+	gpio0d4_dir = gpio0_readl(GPIO_SWPORTA_DDR);
+
+	writel_relaxed((gpio0d4_iomux |(1<<24)) & (~(1<<8)), GRF_GPIO0D_IOMUX);
+	gpio0_writel(gpio0d4_dir |(1<<28), GPIO_SWPORTA_DDR);
+	gpio0_writel(gpio0d4_do |(1<<28), GPIO_SWPORTA_DR);
+	
+#endif 
+}
+void __sramfunc rk30_pwm_logic_resume_voltage(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	writel_relaxed((1<<24)|gpio0d4_iomux, GRF_GPIO0D_IOMUX);
+	gpio0_writel(gpio0d4_dir, GPIO_SWPORTA_DDR);
+	gpio0_writel(gpio0d4_do, GPIO_SWPORTA_DR);
+	sram_udelay(10000);
+
+#endif
+
+}
+extern void pwm_suspend_voltage(void);
+extern void pwm_resume_voltage(void);
+void  rk30_pwm_suspend_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_suspend_voltage();
+#endif
+}
+void  rk30_pwm_resume_voltage_set(void)
+{
+#ifdef CONFIG_RK30_PWM_REGULATOR
+	pwm_resume_voltage();
+#endif
+}
+
+void __sramfunc board_pmu_suspend(void)
+{      
+	#if defined (CONFIG_MFD_TPS65910)
+       if(g_pmic_type == PMIC_TYPE_TPS65910)
+       board_pmu_tps65910_suspend(); 
+   	#endif   
+}
+void __sramfunc board_pmu_resume(void)
+{      
+	#if defined (CONFIG_MFD_TPS65910)
+       if(g_pmic_type == PMIC_TYPE_TPS65910)
+       board_pmu_tps65910_resume(); 
+	#endif
+}
+
+#ifdef CONFIG_I2C1_RK30
+static struct i2c_board_info __initdata i2c1_info[] = {
+#if defined (CONFIG_GS_MMA7660)
+		{
+			.type		= "gs_mma7660",
+			.addr		= 0x4c,
+			.flags		= 0,
+			.irq		= MMA7660_INT_PIN,
+			.platform_data = &mma7660_info,
+		},
+#endif
+
+};
+#endif
+#ifdef CONFIG_I2C2_RK30
+static struct i2c_board_info __initdata i2c2_info[] = {
+
+#if defined (CONFIG_TOUCHSCREEN_GT811_IIC)
+	{
+		.type			= "gt811_ts",
+		.addr			= 0x5d,
+		.flags			= 0,
+		.irq			= TOUCH_INT_PIN,
+		.platform_data = &gt811_info,
+	},	
+#endif
+
+#if defined (CONFIG_TOUCHSCREEN_SITRONIX_A720)
+{
+        .type	        ="sitronix",
+	.addr           = 0x60,
+	.flags          = 0,
+	.irq            = TOUCH_INT_PIN,
+	.platform_data = &sitronix_info,
+},
+#endif
+};
+#endif
+#ifdef CONFIG_I2C3_RK30
+static struct i2c_board_info __initdata i2c3_info[] = {
+};
+#endif
+#ifdef CONFIG_I2C_GPIO_RK30
+#define I2C_SDA_PIN     INVALID_GPIO   //set sda_pin here
+#define I2C_SCL_PIN     INVALID_GPIO   //set scl_pin here
+static int rk30_i2c_io_init(void)
+{
+        //set iomux (gpio) here
+
+        return 0;
+}
+struct i2c_gpio_platform_data default_i2c_gpio_data = {
+       .sda_pin = I2C_SDA_PIN,
+       .scl_pin = I2C_SCL_PIN,
+       .udelay = 5, // clk = 500/udelay = 100Khz
+       .timeout = 100,//msecs_to_jiffies(100),
+       .bus_num    = 5,
+       .io_init = rk30_i2c_io_init,
+};
+static struct i2c_board_info __initdata i2c_gpio_info[] = {
+};
+#endif
+static void __init rk30_i2c_register_board_info(void)
+{
+#ifdef CONFIG_I2C0_RK30
+	i2c_register_board_info(0, i2c0_info, ARRAY_SIZE(i2c0_info));
+#endif
+#ifdef CONFIG_I2C1_RK30
+	i2c_register_board_info(1, i2c1_info, ARRAY_SIZE(i2c1_info));
+#endif
+#ifdef CONFIG_I2C2_RK30
+	i2c_register_board_info(2, i2c2_info, ARRAY_SIZE(i2c2_info));
+#endif
+#ifdef CONFIG_I2C3_RK30
+	i2c_register_board_info(3, i2c3_info, ARRAY_SIZE(i2c3_info));
+#endif
+#ifdef CONFIG_I2C_GPIO_RK30
+	i2c_register_board_info(4, i2c_gpio_info, ARRAY_SIZE(i2c_gpio_info));
+#endif
+}
+//end of i2c
+
+#define POWER_ON_PIN RK2928_PIN1_PA1   //power_hold
+#if defined(CONFIG_REGULATOR_ACT8931)
+extern  int act8931_charge_det ;
+#endif
+static void rk2928_pm_power_off(void)
+{
+	printk(KERN_ERR "rk2928_pm_power_off start...\n");
+        
+        #if defined(CONFIG_REGULATOR_ACT8931)
+        if(g_pmic_type == PMIC_TYPE_ACT8931)
+        {
+                 #ifdef CONFIG_BATTERY_RK30_ADC_FAC
+              if (gpio_get_value (rk30_adc_battery_platdata.dc_det_pin) == rk30_adc_battery_platdata.dc_det_level)//if(act8931_charge_det)
+                 #endif
+                   arm_pm_restart(0, NULL);
+        }
+        #endif
+	
+	#if defined(CONFIG_MFD_TPS65910)	
+	if(g_pmic_type == PMIC_TYPE_TPS65910)
+	{
+		tps65910_device_shutdown();//tps65910 shutdown
+	}
+	#endif
+	gpio_direction_output(POWER_ON_PIN, GPIO_LOW);
+	
+};
+
+static void __init rk2928_board_init(void)
+{
+	gpio_request(POWER_ON_PIN, "poweronpin");
+	gpio_direction_output(POWER_ON_PIN, GPIO_HIGH);
+ 
+	pm_power_off = rk2928_pm_power_off;
+	
+	rk30_i2c_register_board_info();
+	spi_register_board_info(board_spi_devices, ARRAY_SIZE(board_spi_devices));
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+}
+
+static void __init rk2928_reserve(void)
+{
+#ifdef CONFIG_ION
+	rk30_ion_pdata.heaps[0].base = board_mem_reserve_add("ion", ION_RESERVE_SIZE);
+#endif
+#ifdef CONFIG_FB_ROCKCHIP
+	resource_fb[0].start = board_mem_reserve_add("fb0", RK30_FB0_MEM_SIZE);
+	resource_fb[0].end = resource_fb[0].start + RK30_FB0_MEM_SIZE - 1;
+#endif
+#ifdef CONFIG_VIDEO_RK29
+	rk30_camera_request_reserve_mem();
+#endif
+	board_mem_reserved();
+}
+/**
+ * dvfs_cpu_logic_table: table for arm and logic dvfs 
+ * @frequency	: arm frequency
+ * @cpu_volt	: arm voltage depend on frequency
+ * @logic_volt	: logic voltage arm requests depend on frequency
+ * comments	: min arm/logic voltage
+ */
+static struct dvfs_arm_table dvfs_cpu_logic_table[] = {
+	{.frequency = 216 * 1000,	.cpu_volt =  850 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 312 * 1000,	.cpu_volt =  900 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 408 * 1000,	.cpu_volt =  950 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 504 * 1000,	.cpu_volt = 1000 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 600 * 1000,	.cpu_volt = 1100 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 696 * 1000,	.cpu_volt = 1175 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 816 * 1000,	.cpu_volt = 1250 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 912 * 1000,	.cpu_volt = 1350 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 1008 * 1000,	.cpu_volt = 1450 * 1000,	.logic_volt = 1200 * 1000},
+#if 0
+	{.frequency = 1104 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 1200 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 1104 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
+	{.frequency = 1248 * 1000,	.cpu_volt = 1400 * 1000,	.logic_volt = 1200 * 1000},
+#endif
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+static struct cpufreq_frequency_table dvfs_gpu_table[] = {
+	{.frequency = 266 * 1000,	.index = 1050 * 1000},
+	{.frequency = 400 * 1000,	.index = 1275 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+static struct cpufreq_frequency_table dvfs_ddr_table[] = {
+	{.frequency = 300 * 1000,	.index = 1050 * 1000},
+	{.frequency = 400 * 1000,	.index = 1125 * 1000},
+	{.frequency = CPUFREQ_TABLE_END},
+};
+
+#define DVFS_CPU_TABLE_SIZE	(ARRAY_SIZE(dvfs_cpu_logic_table))
+static struct cpufreq_frequency_table cpu_dvfs_table[DVFS_CPU_TABLE_SIZE];
+static struct cpufreq_frequency_table dep_cpu2core_table[DVFS_CPU_TABLE_SIZE];
+
+void __init board_clock_init(void)
+{
+	rk2928_clock_data_init(periph_pll_default, codec_pll_default, RK30_CLOCKS_DEFAULT_FLAGS);
+	dvfs_set_arm_logic_volt(dvfs_cpu_logic_table, cpu_dvfs_table, dep_cpu2core_table);
+	dvfs_set_freq_volt_table(clk_get(NULL, "gpu"), dvfs_gpu_table);
+	//dvfs_set_freq_volt_table(clk_get(NULL, "ddr"), dvfs_ddr_table);
+	printk("%s end\n", __func__);
+}
+
+
+MACHINE_START(RK2928, "RK2928board")
+	.boot_params	= PLAT_PHYS_OFFSET + 0x800,
+	.fixup		= rk2928_fixup,
+	.reserve	= &rk2928_reserve,
+	.map_io		= rk2928_map_io,
+	.init_irq	= rk2928_init_irq,
+	.timer		= &rk2928_timer,
+	.init_machine	= rk2928_board_init,
+MACHINE_END
diff --git a/arch/arm/mach-rk2928/board-rk2928-tb-camera.c b/arch/arm/mach-rk2928/board-rk2928-tb-camera.c
new file mode 100644
index 000000000000..ad549249f5c2
--- /dev/null
+++ b/arch/arm/mach-rk2928/board-rk2928-tb-camera.c
@@ -0,0 +1,448 @@
+#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Macro Define Begin  ------------------------*/
+/*---------------- Camera Sensor Configuration Macro Begin ------------------------*/
+#define CONFIG_SENSOR_0 RK29_CAM_SENSOR_OV5642						/* back camera sensor */
+#define CONFIG_SENSOR_IIC_ADDR_0		0x78//	0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_0	  0
+#define CONFIG_SENSOR_CIF_INDEX_0                    0
+#define CONFIG_SENSOR_ORIENTATION_0 	  90
+#define CONFIG_SENSOR_POWER_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_0 	  RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_0		  INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_0 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_0 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_0 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_0 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_0   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_0		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_0		30000
+
+#define CONFIG_SENSOR_01  RK29_CAM_SENSOR_OV5642                   /* back camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_01 	    0x00
+#define CONFIG_SENSOR_CIF_INDEX_01                    0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_01    4
+#define CONFIG_SENSOR_ORIENTATION_01       90
+#define CONFIG_SENSOR_POWER_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_01       RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_01         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_01 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_01 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_01 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_01 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_01   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_01       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_01      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_01     30000
+
+#define CONFIG_SENSOR_02 RK29_CAM_SENSOR_OV5640                      /* back camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_02 	    0x00
+#define CONFIG_SENSOR_CIF_INDEX_02                    0
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_02    4
+#define CONFIG_SENSOR_ORIENTATION_02       90
+#define CONFIG_SENSOR_POWER_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_02       RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_02         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_02 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_02 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_02 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_02 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_02   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_02       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_02      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_02      30000
+
+#define CONFIG_SENSOR_1 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 0 */
+#define CONFIG_SENSOR_IIC_ADDR_1 	   0// 0x60
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_1	  3
+#define CONFIG_SENSOR_CIF_INDEX_1				  0
+#define CONFIG_SENSOR_ORIENTATION_1       270
+#define CONFIG_SENSOR_POWER_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_1 	  RK2928_PIN3_PB3
+#define CONFIG_SENSOR_FALSH_PIN_1         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_1 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_1 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_1 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_1 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_1   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_1		15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_1		30000
+
+#define CONFIG_SENSOR_11 RK29_CAM_SENSOR_OV2659                      /* front camera sensor 1 */
+#define CONFIG_SENSOR_IIC_ADDR_11 	    0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_11    3
+#define CONFIG_SENSOR_CIF_INDEX_11				  0
+#define CONFIG_SENSOR_ORIENTATION_11       270
+#define CONFIG_SENSOR_POWER_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_11       INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_11         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_11 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_11 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_11 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_11 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_11   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_11       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_11      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_11      30000
+
+#define CONFIG_SENSOR_12 RK29_CAM_SENSOR_OV2659//RK29_CAM_SENSOR_OV2655                      /* front camera sensor 2 */
+#define CONFIG_SENSOR_IIC_ADDR_12 	   0x00
+#define CONFIG_SENSOR_IIC_ADAPTER_ID_12    3
+#define CONFIG_SENSOR_CIF_INDEX_12				  0
+#define CONFIG_SENSOR_ORIENTATION_12       270
+#define CONFIG_SENSOR_POWER_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_RESET_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERDN_PIN_12       INVALID_GPIO
+#define CONFIG_SENSOR_FALSH_PIN_12         INVALID_GPIO
+#define CONFIG_SENSOR_POWERACTIVE_LEVEL_12 RK29_CAM_POWERACTIVE_L
+#define CONFIG_SENSOR_RESETACTIVE_LEVEL_12 RK29_CAM_RESETACTIVE_L
+#define CONFIG_SENSOR_POWERDNACTIVE_LEVEL_12 RK29_CAM_POWERDNACTIVE_H
+#define CONFIG_SENSOR_FLASHACTIVE_LEVEL_12 RK29_CAM_FLASHACTIVE_L
+
+#define CONFIG_SENSOR_QCIF_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_240X160_FPS_FIXED_12   15000
+#define CONFIG_SENSOR_QVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_CIF_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_VGA_FPS_FIXED_12       15000
+#define CONFIG_SENSOR_480P_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_SVGA_FPS_FIXED_12      15000
+#define CONFIG_SENSOR_720P_FPS_FIXED_12      30000
+
+
+#endif  //#ifdef CONFIG_VIDEO_RK29
+/*---------------- Camera Sensor Configuration Macro End------------------------*/
+#include "../../../drivers/media/video/rk2928_camera.c"
+/*---------------- Camera Sensor Macro Define End  ---------*/
+
+#define PMEM_CAM_SIZE PMEM_CAM_NECESSARY
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#ifdef CONFIG_VIDEO_RK29
+#define CONFIG_SENSOR_POWER_IOCTL_USR	   0 //define this refer to your board layout
+#define CONFIG_SENSOR_RESET_IOCTL_USR	   0
+#define CONFIG_SENSOR_POWERDOWN_IOCTL_USR	   0
+#define CONFIG_SENSOR_FLASH_IOCTL_USR	   0
+
+static void rk_cif_power(int on)
+{
+    struct regulator *ldo_18,*ldo_28;
+	ldo_28 = regulator_get(NULL, "ldo7");	// vcc28_cif
+	ldo_18 = regulator_get(NULL, "ldo1");	// vcc18_cif
+	if (ldo_28 == NULL || IS_ERR(ldo_28) || ldo_18 == NULL || IS_ERR(ldo_18)){
+        printk("get cif ldo failed!\n");
+		return;
+	    }
+    if(on == 0){	
+    	regulator_disable(ldo_28);
+    	regulator_put(ldo_28);
+    	regulator_disable(ldo_18);
+    	regulator_put(ldo_18);
+    	mdelay(500);
+        }
+    else{
+    	regulator_set_voltage(ldo_28, 2800000, 2800000);
+    	regulator_enable(ldo_28);
+   // 	printk("%s set ldo7 vcc28_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_28));
+    	regulator_put(ldo_28);
+
+    	regulator_set_voltage(ldo_18, 1800000, 1800000);
+    //	regulator_set_suspend_voltage(ldo, 1800000);
+    	regulator_enable(ldo_18);
+    //	printk("%s set ldo1 vcc18_cif=%dmV end\n", __func__, regulator_get_voltage(ldo_18));
+    	regulator_put(ldo_18);
+        }
+}
+
+#if CONFIG_SENSOR_POWER_IOCTL_USR
+static int sensor_power_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	//#error "CONFIG_SENSOR_POWER_IOCTL_USR is 1, sensor_power_usr_cb function must be writed!!";
+    rk_cif_power(on);
+}
+#endif
+
+#if CONFIG_SENSOR_RESET_IOCTL_USR
+static int sensor_reset_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_RESET_IOCTL_USR is 1, sensor_reset_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+static int sensor_powerdown_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_FLASH_IOCTL_USR
+static int sensor_flash_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	#error "CONFIG_SENSOR_FLASH_IOCTL_USR is 1, sensor_flash_usr_cb function must be writed!!";
+}
+#endif
+
+static struct rk29camera_platform_ioctl_cb	sensor_ioctl_cb = {
+	#if CONFIG_SENSOR_POWER_IOCTL_USR
+	.sensor_power_cb = sensor_power_usr_cb,
+	#else
+	.sensor_power_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_RESET_IOCTL_USR
+	.sensor_reset_cb = sensor_reset_usr_cb,
+	#else
+	.sensor_reset_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+	.sensor_powerdown_cb = sensor_powerdown_usr_cb,
+	#else
+	.sensor_powerdown_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_FLASH_IOCTL_USR
+	.sensor_flash_cb = sensor_flash_usr_cb,
+	#else
+	.sensor_flash_cb = NULL,
+	#endif
+};
+
+#if CONFIG_SENSOR_IIC_ADDR_0
+static struct reginfo_t rk_init_data_sensor_reg_0[] =
+{
+		{0x0000, 0x00,0,0}
+	};
+static struct reginfo_t rk_init_data_sensor_winseqreg_0[] ={
+	{0x0000, 0x00,0,0}
+	};
+#endif
+
+#if CONFIG_SENSOR_IIC_ADDR_1
+static struct reginfo_t rk_init_data_sensor_reg_1[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_1[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_01
+static struct reginfo_t rk_init_data_sensor_reg_01[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_01[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_02
+static struct reginfo_t rk_init_data_sensor_reg_02[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_02[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_11
+static struct reginfo_t rk_init_data_sensor_reg_11[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_11[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+#if CONFIG_SENSOR_IIC_ADDR_12
+static struct reginfo_t rk_init_data_sensor_reg_12[] =
+{
+    {0x0000, 0x00,0,0}
+};
+static struct reginfo_t rk_init_data_sensor_winseqreg_12[] =
+{
+       {0x0000, 0x00,0,0}
+};
+#endif
+static rk_sensor_user_init_data_s rk_init_data_sensor[RK_CAM_NUM] = 
+{
+    #if CONFIG_SENSOR_IIC_ADDR_0
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_0,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_0,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_0) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_0) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_1
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_1,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_1,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_1) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_1) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_01
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_01,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_01,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_01) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_01) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_02
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_02,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_02,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_02) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_02) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_11
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_11,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_11,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_11) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_11) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+    #if CONFIG_SENSOR_IIC_ADDR_12
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = rk_init_data_sensor_reg_12,
+       .rk_sensor_init_winseq = rk_init_data_sensor_winseqreg_12,
+       .rk_sensor_winseq_size = sizeof(rk_init_data_sensor_winseqreg_12) / sizeof(struct reginfo_t),
+       .rk_sensor_init_data_size = sizeof(rk_init_data_sensor_reg_12) / sizeof(struct reginfo_t),
+    },
+    #else
+    {
+       .rk_sensor_init_width = INVALID_VALUE,
+       .rk_sensor_init_height = INVALID_VALUE,
+       .rk_sensor_init_bus_param = INVALID_VALUE,
+       .rk_sensor_init_pixelcode = INVALID_VALUE,
+       .rk_sensor_init_data = NULL,
+       .rk_sensor_init_winseq = NULL,
+       .rk_sensor_winseq_size = 0,
+       .rk_sensor_init_data_size = 0,
+    },
+    #endif
+
+ };
+#include "../../../drivers/media/video/rk2928_camera.c"
+
+#endif /* CONFIG_VIDEO_RK29 */
diff --git a/arch/arm/mach-rk2928/board-rk2928-tb.c b/arch/arm/mach-rk2928/board-rk2928-tb.c
index 7c592250152f..51ae93133d71 100755
--- a/arch/arm/mach-rk2928/board-rk2928-tb.c
+++ b/arch/arm/mach-rk2928/board-rk2928-tb.c
@@ -64,8 +64,8 @@
 #define RK30_FB0_MEM_SIZE 8*SZ_1M
 #endif
 
-#include "board-rk2928-sdk-camera.c"
-#include "board-rk2928-sdk-key.c"
+#include "board-rk2928-tb-camera.c"
+#include "board-rk2928-tb-key.c"
 
 #if defined (CONFIG_EETI_EGALAX)
 #define TOUCH_RESET_PIN  RK2928_PIN3_PC3
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 58ef75385191..5e02303f19e1 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -969,6 +969,10 @@ config LAIBAO_TS
 config TOUCHSCREEN_GT801_IIC
 	tristate "GT801_IIC based touchscreens"
 	depends on I2C2_RK29
+
+config TOUCHSCREEN_GT811_IIC
+	tristate "GT811_IIC based touchscreens"
+	depends on I2C2_RK29 || I2C2_RK30
 	
 config TOUCHSCREEN_GT82X_IIC
 	tristate "GT82x_IIC based touchscreens"
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 159f846c813a..b624bdc544a1 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -75,6 +75,7 @@ obj-$(CONFIG_EETI_EGALAX)		+= eeti_egalax_i2c.o
 obj-$(CONFIG_ATMEL_MXT224)		+= atmel_maxtouch.o
 obj-$(CONFIG_ATMEL_MXT1386)		+= atmel_mxt1386.o
 obj-$(CONFIG_TOUCHSCREEN_GT801_IIC)	+= gt801_ts.o
+obj-$(CONFIG_TOUCHSCREEN_GT811_IIC)	+= gt811_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT82X_IIC)	+= goodix_touch_82x.o
 obj-$(CONFIG_TOUCHSCREEN_GT818_IIC)	+= gt818_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GT8110)        += gt8110_ts.o
diff --git a/drivers/input/touchscreen/gt811_firmware.h b/drivers/input/touchscreen/gt811_firmware.h
new file mode 100755
index 000000000000..a19bac40959d
--- /dev/null
+++ b/drivers/input/touchscreen/gt811_firmware.h
@@ -0,0 +1,274 @@
+/* drivers/input/touchscreen/gt811_update.h
+ *
+ * Copyright (C) 2010 - 2011 Goodix, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ *Any problem,please contact andrew@goodix.com,+86 755-33338828
+ *
+ */
+
+#ifndef 	_LINUX_GT811_UPDATE_H
+#define		_LINUX_GT811_UPDATE_H
+static unsigned char goodix_gt811_firmware[] = {
+    0x11,
+    0x10,0x10,
+    0x45,
+    0x00,0x00,0x00,
+    0x41,0x00,
+    0x0e,0xf0,
+    0x06,0x24,0xad,
+    0x00,0x00,0x00,0x00,0x00,0x00,
+    /*'G','O','O','D','I','X',*/
+    
+    0x4f,0xce,0x01,0x00,0x20,0x03,0xa7,0x00,0x08,0x8c,0x05,0xdf,
+    0x26,0xf8,0x8e,0x05,0xdf,0xbd,0x41,0x16,0x20,0xfe,0x0e,0xbd,0xc2,0xd4,0xbd,0x4d,
+    0x8c,0xbd,0x4d,0xc2,0xbd,0x41,0xb0,0xbd,0x47,0x61,0xbd,0x46,0x59,0xbd,0xf7,0x38,
+    0x20,0x10,0x01,0x01,0x01,0x01,0x13,0xe6,0x01,0x08,0xd6,0xeb,0x26,0x04,0x01,0xcf,
+    0x01,0x01,0xd6,0xeb,0x27,0xec,0xd6,0xe7,0x5c,0x26,0xe7,0xd7,0xeb,0xbd,0x46,0xf4,
+    0xbd,0xc4,0x73,0xf6,0x07,0x0b,0x27,0x0f,0xbd,0x46,0xf8,0xbd,0x46,0x59,0xc6,0x80,
+    0xd7,0xea,0xbd,0xf7,0x38,0x20,0xdb,0xbd,0xd4,0xb8,0xd6,0xea,0x5a,0x27,0x08,0xbd,
+    0xf5,0x3c,0xbd,0xf7,0x38,0x20,0xcb,0x8d,0x64,0xbd,0x4c,0x90,0xbd,0xe9,0xd4,0xbd,
+    0x4b,0xd7,0xbd,0x49,0x4c,0xbd,0xeb,0xe8,0xbd,0xf7,0x38,0xbd,0x42,0xa9,0xbd,0x47,
+    0x87,0xbd,0x48,0xde,0xbd,0xd7,0xa2,0xbd,0x4b,0x41,0xbd,0xdb,0x6a,0xbd,0xef,0x1c,
+    0xbd,0xdf,0x8d,0xbd,0xe3,0x51,0xbd,0xe3,0x71,0xbd,0xd5,0xa8,0xbd,0x4e,0x29,0xbd,
+    0xef,0x95,0x20,0x8e,0x3c,0x34,0x30,0xbd,0xc7,0x1c,0xc6,0x5d,0x18,0xce,0x14,0x01,
+    0x18,0xe7,0x00,0xbd,0x46,0x27,0xf7,0x07,0x10,0x56,0x56,0x56,0xc4,0xc0,0xe7,0x00,
+    0xf6,0x07,0x21,0xc4,0x3f,0xea,0x00,0xf7,0x07,0x21,0x31,0x38,0x39,0xd6,0xef,0x26,
+    0x1a,0xc6,0x01,0xd7,0xef,0xfe,0x01,0x28,0x3c,0xcc,0x0b,0x00,0xfd,0x01,0x28,0xbd,
+    0x48,0x38,0xdd,0xf2,0xfd,0x02,0xf7,0x38,0xff,0x01,0x28,0x39,0x3c,0xd6,0xf5,0x26,
+    0x03,0x7e,0x42,0x86,0xd6,0xac,0x5a,0x26,0x6e,0xfc,0x02,0x89,0x83,0x0d,0x80,0xce,
+    0x00,0x14,0x02,0x8f,0x37,0xce,0x0b,0xa0,0x18,0xfe,0x01,0x28,0x32,0x81,0x08,0x23,
+    0x0a,0x80,0x08,0xc6,0xa0,0x3a,0x3a,0x18,0x3a,0x18,0x3a,0xc6,0x14,0x3d,0x3a,0x18,
+    0x3a,0x5f,0xd7,0x69,0xec,0x00,0x18,0xa3,0x00,0x7d,0x00,0x69,0x26,0x06,0xfd,0x02,
+    0xfc,0xfd,0x02,0xfe,0x1a,0xb3,0x02,0xfc,0x2f,0x03,0xfd,0x02,0xfc,0x1a,0xb3,0x02,
+    0xfe,0x2c,0x03,0xfd,0x02,0xfe,0x08,0x08,0x18,0x08,0x18,0x08,0x7c,0x00,0x69,0xd6,
+    0x69,0xd1,0xc2,0x25,0xcf,0xd6,0xca,0x4f,0xf3,0x02,0xfe,0xb3,0x02,0xfc,0x2d,0x07,
+    0xf6,0x02,0xf1,0xcb,0x02,0x20,0x06,0xf6,0x02,0xf1,0x27,0x01,0x5a,0xf7,0x02,0xf1,
+    0xc1,0xfa,0x25,0x06,0xbd,0x49,0x43,0x7f,0x00,0xf5,0x38,0x39,0x3c,0xce,0x07,0x12,
+    0xc6,0xa0,0xe7,0x00,0x5f,0xce,0x07,0x1d,0xe7,0x00,0x08,0x8c,0x07,0x48,0x23,0xf8,
+    0xce,0x02,0xc4,0xe7,0x00,0x08,0x8c,0x02,0xec,0x25,0xf8,0x38,0x39,0x7f,0x03,0x33,
+    0xbd,0xc5,0x25,0x13,0xe6,0x04,0x02,0x8d,0x49,0xbd,0x44,0x46,0xcc,0x01,0xc2,0xd0,
+    0xda,0x82,0x00,0xd0,0xda,0x82,0x00,0xf3,0x02,0x90,0xfd,0x02,0x90,0x39,0x3c,0x18,
+    0x3c,0x86,0x14,0xf6,0x03,0x33,0x3d,0xc3,0x0d,0x80,0x18,0x8f,0xce,0x02,0x2c,0xd6,
+    0xc2,0xd7,0x6a,0xec,0x00,0x13,0xe6,0x40,0x02,0x47,0x56,0x18,0xed,0x00,0xc6,0x02,
+    0x3a,0x18,0x3a,0x7a,0x00,0x6a,0x26,0xeb,0x4f,0x97,0xd1,0x7c,0x03,0x33,0x18,0x38,
+    0x38,0x39,0x3c,0x18,0x3c,0xce,0x03,0x34,0x4f,0xc6,0xa0,0xa7,0x00,0x08,0x5a,0x26,
+    0xfa,0x96,0xc1,0xb7,0x02,0x6f,0x18,0xce,0x0d,0x80,0xce,0x03,0x34,0xd6,0xc2,0xf7,
+    0x02,0x6e,0x18,0x3c,0x4f,0x5f,0x18,0xe3,0x00,0x18,0x08,0x18,0x08,0x7a,0x02,0x6e,
+    0x26,0xf4,0xfd,0x03,0x31,0x18,0x38,0x3c,0x4f,0xd6,0xc2,0x8f,0xfc,0x03,0x31,0x2a,
+    0x0c,0x40,0x50,0x82,0x00,0x02,0x8f,0x40,0x50,0x82,0x00,0x20,0x02,0x02,0x8f,0xfd,
+    0x03,0x31,0x38,0x96,0xc2,0xb7,0x02,0x6e,0x18,0x3c,0x18,0xec,0x00,0xb3,0x03,0x31,
+    0x18,0xed,0x00,0x2d,0x04,0x2e,0x0d,0x20,0x18,0x6c,0x01,0x1a,0xa3,0x06,0x2c,0x11,
+    0xed,0x06,0x20,0x0d,0x6c,0x00,0x1a,0xa3,0x04,0x2f,0x02,0xed,0x04,0xe3,0x02,0xed,
+    0x02,0x18,0x08,0x18,0x08,0x7a,0x02,0x6e,0x26,0xd0,0x18,0x38,0xc6,0x0a,0x3a,0x58,
+    0x18,0x3a,0x7a,0x02,0x6f,0x26,0x86,0xce,0x03,0x34,0x96,0xc1,0xb7,0x02,0x6f,0x4a,
+    0xb7,0x03,0x29,0xb7,0x03,0x2a,0x4f,0xd6,0xc9,0xc0,0x0a,0xa3,0x04,0xe3,0x06,0x2b,
+    0x15,0xd6,0xc1,0xf0,0x02,0x6f,0xb6,0x03,0x29,0xb1,0x03,0x2a,0x27,0x05,0xf7,0x03,
+    0x29,0x20,0x03,0xf7,0x03,0x2a,0xc6,0x0a,0x3a,0x7a,0x02,0x6f,0x26,0xd8,0x8d,0x11,
+    0xf6,0x03,0x29,0xf7,0x03,0x2a,0x8d,0x09,0xbd,0x45,0xff,0x8d,0x3a,0x18,0x38,0x38,
+    0x39,0x7f,0x03,0x2c,0xf6,0x03,0x2a,0xf7,0x02,0x6f,0xd6,0xc2,0xd7,0x68,0xbd,0x45,
+    0x1a,0xbd,0x45,0xc2,0x7c,0x02,0x6f,0xf6,0x02,0x6f,0xd1,0xc1,0x26,0xf0,0x7f,0x03,
+    0x2c,0xf6,0x03,0x2a,0xf7,0x02,0x6f,0xd6,0xc2,0xd7,0x68,0xbd,0x45,0x1a,0xbd,0x45,
+    0xc2,0x7a,0x02,0x6f,0x2a,0xf5,0x39,0x18,0xce,0x03,0x34,0xce,0x0d,0x80,0x96,0xc1,
+    0xb7,0x02,0x6f,0x18,0x67,0x08,0x18,0x66,0x09,0x96,0xc2,0xb7,0x02,0x6e,0x3c,0xec,
+    0x00,0x18,0xe3,0x08,0xed,0x00,0x08,0x08,0x7a,0x02,0x6e,0x26,0xf2,0x38,0xc6,0x0a,
+    0x18,0x3a,0x58,0x3a,0x7a,0x02,0x6f,0x26,0xda,0x39,0x3c,0x4f,0x5f,0xb7,0x02,0x81,
+    0xb7,0x02,0x80,0x97,0xe2,0x97,0xe1,0x97,0x68,0x97,0x67,0x18,0xce,0x0d,0x80,0xce,
+    0x0d,0x80,0xff,0x02,0x89,0xff,0x02,0x87,0xd6,0xc1,0xd7,0x6a,0x3c,0x18,0x3c,0xd6,
+    0xc2,0xd7,0x69,0x18,0xec,0x00,0x18,0x6f,0x00,0x18,0x6f,0x01,0x4d,0x2a,0x28,0x40,
+    0x50,0x82,0x00,0x4d,0x27,0x02,0xc6,0xff,0xd1,0xc9,0x23,0x03,0x7c,0x00,0xe1,0xf1,
+    0x02,0x7f,0x23,0x03,0x7c,0x02,0x80,0x4f,0xa7,0x00,0xf3,0x02,0x90,0xfd,0x02,0x90,
+    0x86,0x02,0xb7,0x03,0x25,0x20,0x4d,0xd0,0xfb,0x82,0x00,0x2a,0x02,0x4f,0x5f,0x4d,
+    0x27,0x02,0xc6,0xff,0xd1,0xc9,0x22,0x04,0x86,0x02,0x20,0x04,0x7c,0x00,0xe2,0x4f,
+    0xb7,0x03,0x25,0xf1,0x02,0x7f,0x23,0x03,0x7c,0x02,0x81,0xe7,0x00,0x4f,0xf3,0x02,
+    0x90,0xfd,0x02,0x90,0xe6,0x00,0xd1,0x68,0x23,0x11,0x96,0x68,0x97,0x67,0xd7,0x68,
+    0xfc,0x02,0x89,0xfd,0x02,0x87,0xff,0x02,0x89,0x20,0x09,0xd1,0x67,0x23,0x05,0xd7,
+    0x67,0xff,0x02,0x87,0x3c,0xc6,0xa0,0x3a,0x3a,0xf6,0x03,0x25,0xe7,0x00,0x38,0x08,
+    0xc6,0x02,0x18,0x3a,0x7a,0x00,0x69,0x27,0x03,0x7e,0x44,0x6f,0x18,0x38,0x38,0xc6,
+    0x14,0x3a,0x18,0x3a,0x7a,0x00,0x6a,0x27,0x03,0x7e,0x44,0x68,0x38,0x39,0xce,0x03,
+    0x34,0xf6,0x02,0x6f,0x86,0x0a,0x3d,0x3a,0xec,0x00,0x3d,0x5d,0xfd,0x03,0x26,0x27,
+    0x6e,0x86,0x01,0xf6,0x03,0x2c,0x27,0x10,0x5a,0x27,0x18,0x5a,0x27,0x26,0xf6,0x03,
+    0x2b,0x27,0x05,0x5a,0x27,0x28,0x20,0x08,0xe6,0x00,0xe1,0x01,0x22,0x02,0x20,0x1e,
+    0x4f,0x20,0x1b,0xf6,0x03,0x2b,0xc1,0x02,0x27,0x14,0xe6,0x00,0xd0,0x68,0xc1,0x04,
+    0x2e,0xe6,0x20,0x1a,0x4f,0xf6,0x03,0x2b,0xc1,0x01,0x27,0x02,0x20,0x08,0xb7,0x03,
+    0x28,0x4f,0xd6,0xc2,0x20,0x0e,0xb7,0x03,0x28,0x4f,0xe6,0x00,0x20,0x06,0xb7,0x03,
+    0x28,0x4f,0xe6,0x01,0xfd,0x03,0x31,0xec,0x02,0x3c,0xfe,0x03,0x31,0x02,0x8f,0x38,
+    0xfd,0x03,0x26,0x4f,0xf6,0x03,0x28,0x26,0x06,0xb3,0x03,0x26,0xfd,0x03,0x26,0xec,
+    0x04,0xf3,0x03,0x26,0xfd,0x03,0x2f,0xec,0x06,0xf3,0x03,0x26,0xfd,0x03,0x2d,0xec,
+    0x08,0xf3,0x03,0x26,0xed,0x08,0xfc,0x03,0x2d,0x47,0x56,0x47,0x56,0xe3,0x08,0xed,
+    0x08,0xe6,0x00,0xd7,0x68,0x39,0xf6,0x03,0x2c,0xc1,0x03,0x2c,0x03,0xf7,0x03,0x2b,
+    0x7f,0x03,0x2c,0x4f,0xd6,0xc9,0xc0,0x0a,0x1a,0xb3,0x03,0x2f,0x2c,0x03,0x7c,0x03,
+    0x2c,0x40,0x50,0x82,0x00,0x1a,0xb3,0x03,0x2d,0x2f,0x06,0x7c,0x03,0x2c,0x7c,0x03,
+    0x2c,0xf6,0x03,0x2c,0xc1,0x03,0x26,0x0a,0xf6,0x03,0x2b,0x26,0x05,0xc6,0x01,0xf7,
+    0x03,0x2c,0x39,0x3c,0x18,0x3c,0xce,0x03,0x34,0x18,0xce,0x03,0x05,0xd6,0xc1,0x37,
+    0xec,0x08,0x18,0xe3,0x00,0x47,0x56,0xed,0x08,0x18,0xed,0x00,0xc6,0x08,0x3a,0x18,
+    0x08,0x18,0x08,0x33,0x5a,0x26,0xe8,0x18,0x38,0x38,0x39,0x3c,0xce,0x16,0x00,0x1d,
+    0x00,0x02,0x1c,0x06,0x02,0x1d,0x07,0x02,0xbd,0xef,0x0d,0x1e,0x02,0x02,0x07,0x1d,
+    0x06,0x02,0xc6,0x02,0x20,0x15,0x1d,0x06,0x02,0x1c,0x07,0x02,0xbd,0xef,0x0d,0x1f,
+    0x02,0x02,0x07,0x1d,0x07,0x02,0xc6,0x01,0x20,0x01,0x5f,0x38,0x39,0x3c,0x34,0x30,
+    0xbd,0xc8,0x97,0xd6,0x6a,0x4f,0xc3,0x07,0x92,0x18,0x8f,0xcc,0x42,0xca,0x18,0xed,
+    0x01,0xbd,0x42,0x88,0x8d,0xb5,0xf7,0x07,0x10,0x56,0x56,0x56,0xc4,0xc0,0xe7,0x00,
+    0xf6,0x07,0x21,0xc4,0x3f,0xea,0x00,0xf7,0x07,0x21,0x7f,0x02,0xc2,0xcc,0x80,0x00,
+    0xfd,0x01,0x2e,0xf6,0x06,0xec,0xc4,0x0f,0xd7,0xfb,0x5f,0xd7,0xf5,0xd7,0xf4,0xf7,
+    0x02,0xfb,0xd7,0xef,0xd7,0xc8,0xd7,0x6a,0x86,0x03,0x3d,0x4f,0xc3,0x03,0xd8,0xfd,
+    0x03,0xd6,0xbd,0x4d,0x69,0xd6,0x6a,0x86,0x05,0x3d,0x4f,0xc3,0x03,0xe7,0x18,0x8f,
+    0x18,0x6f,0x04,0x7c,0x00,0x6a,0xd6,0x6a,0xc1,0x05,0x25,0xdc,0xbd,0x48,0x20,0xd6,
+    0xe6,0xc4,0x30,0xd7,0x68,0x26,0x0d,0xc6,0x0c,0xf7,0x02,0xed,0x5c,0xf7,0x02,0xee,
+    0xc6,0x0f,0x20,0x09,0xc6,0x0c,0xf7,0x02,0xed,0x5c,0xf7,0x02,0xee,0xf7,0x02,0xef,
+    0xc6,0x0a,0xf7,0x02,0xf0,0x31,0x38,0x39,0x7f,0x13,0x01,0x39,0xf6,0x07,0x21,0xc4,
+    0xc0,0xca,0x20,0xf7,0x07,0x21,0xc6,0xf0,0xf7,0x07,0x22,0x5f,0xd7,0xfa,0x8d,0xe8,
+    0xf6,0x07,0x0b,0x27,0x24,0x7f,0x07,0x0b,0xbd,0xf1,0x9e,0xf6,0x01,0x32,0x5a,0x26,
+    0x18,0xf6,0x07,0x21,0xc4,0xc0,0xf7,0x07,0x21,0x7f,0x07,0x22,0xbd,0xf1,0x4e,0xfc,
+    0x01,0x30,0xf7,0x07,0x0c,0xb7,0x07,0x0d,0x39,0x4f,0x5f,0xdd,0x75,0x8d,0xb9,0xbd,
+    0xef,0x0d,0xf6,0x07,0x0b,0x26,0xce,0xdc,0x75,0xc3,0x00,0x01,0xdd,0x75,0x83,0x07,
+    0xd0,0x25,0xea,0xd6,0xfa,0x26,0x05,0xbd,0xf7,0xd6,0x20,0x03,0xbd,0xf7,0xed,0xd6,
+    0xfa,0xc8,0x01,0x20,0xa7,0x7f,0x07,0x11,0xc6,0x02,0xf7,0x06,0x92,0xbd,0xf3,0x11,
+    0x39,0x39,0xd6,0xf5,0x26,0x0b,0x12,0xec,0x08,0x07,0xc6,0x01,0xd7,0xf5,0xbd,0x48,
+    0xbc,0x7f,0x02,0xf1,0xbd,0xd2,0x22,0x7f,0x02,0x84,0x39,0xd6,0xcb,0xc5,0x80,0x26,
+    0x01,0x39,0xbd,0x48,0x38,0x1a,0xb3,0x02,0xf7,0x24,0x03,0xfd,0x02,0xf7,0x37,0xf6,
+    0x02,0xf9,0x33,0x26,0x03,0xfd,0x02,0xf3,0x1a,0xb3,0x02,0xf3,0x23,0x05,0xb3,0x02,
+    0xf3,0x20,0x05,0xfc,0x02,0xf3,0x93,0xf0,0x1a,0x83,0x00,0xc8,0x25,0x03,0x8d,0x64,
+    0x39,0xdc,0xf0,0xd3,0xed,0x24,0x03,0x7c,0x02,0xfa,0xdd,0xed,0xd6,0xac,0xc1,0x02,
+    0x24,0x04,0x13,0xec,0x02,0x05,0xc6,0x01,0xf7,0x02,0xf2,0x7c,0x02,0xf9,0xf6,0x02,
+    0xf9,0xc1,0x10,0x26,0x3e,0xc6,0x04,0xd7,0x6a,0xdc,0xed,0x74,0x02,0xfa,0x46,0x56,
+    0x7a,0x00,0x6a,0x26,0xf6,0xfd,0x02,0xf5,0x93,0xf2,0x24,0x0c,0xdc,0xf2,0xb3,0x02,
+    0xf5,0x83,0x01,0xf4,0x23,0x02,0x8d,0x2a,0xfc,0x02,0xf7,0x37,0x36,0xfc,0x02,0xf5,
+    0xbd,0xf7,0xbb,0x31,0x31,0x83,0x00,0xc8,0x24,0x07,0xf6,0x02,0xf2,0x27,0x02,0x8d,
+    0x11,0x8d,0x01,0x39,0x5f,0xf7,0x02,0xf9,0xf7,0x02,0xfa,0x4f,0xb7,0x02,0xf2,0xdd,
+    0xed,0x39,0x7f,0x02,0x95,0x7f,0x02,0x94,0xbd,0x49,0x43,0x39,0x3c,0x18,0xfe,0x01,
+    0x28,0xfe,0x01,0x28,0xc6,0x14,0x3a,0x4f,0x5f,0xdd,0xf0,0xd7,0xbe,0x20,0x66,0xd6,
+    0xbe,0xc1,0x07,0x26,0x05,0xc6,0xa0,0x3a,0x20,0x08,0xc1,0x08,0x26,0x04,0xc6,0xa0,
+    0x18,0x3a,0x5f,0xd7,0xbf,0x20,0x3f,0x3c,0x18,0x3c,0x3c,0x18,0x3c,0x3c,0xce,0x06,
+    0xa2,0xd6,0xbf,0x3a,0xec,0x00,0x38,0x36,0x3a,0x18,0x3a,0xec,0x00,0x18,0xa3,0x00,
+    0xdd,0xcf,0x33,0x18,0x38,0x38,0x3a,0x18,0x3a,0x18,0xec,0x00,0xa3,0x00,0xd3,0xcf,
+    0x2a,0x05,0x43,0x53,0xc3,0x00,0x01,0xd3,0xf0,0x24,0x03,0xcc,0xff,0xff,0xdd,0xf0,
+    0x18,0x38,0x38,0x7c,0x00,0xbf,0xd6,0xc2,0x5a,0xd1,0xbf,0x22,0xba,0xc6,0x14,0x3a,
+    0x18,0x3a,0x7c,0x00,0xbe,0xd6,0xc0,0x5a,0xd1,0xbe,0x22,0x93,0xdc,0xf0,0x38,0x39,
+    0x3c,0x18,0x3c,0xce,0x0b,0x00,0x18,0xce,0x0c,0x40,0xec,0x00,0xed,0xa0,0x18,0xec,
+    0x00,0x18,0xed,0xa0,0xc6,0x02,0x3a,0x18,0x3a,0x8c,0x0b,0xa0,0x25,0xec,0x18,0x38,
+    0x38,0x39,0x13,0xcb,0x80,0x2a,0xd6,0xe2,0xd1,0xe1,0x22,0x02,0xd6,0xe1,0x86,0x0a,
+    0x3d,0xdd,0xf0,0xd6,0xda,0x86,0x07,0x3d,0x93,0xf0,0x24,0x05,0xbd,0x47,0x6e,0x20,
+    0x0f,0xbd,0xce,0x22,0x13,0xec,0x08,0x05,0xbd,0x41,0xf8,0x20,0x03,0x5f,0xd7,0xf5,
+    0x39,0x3c,0x3c,0x7e,0xce,0x98,0x3c,0x3c,0xbd,0xd0,0x9b,0x13,0xe6,0x02,0x06,0x7c,
+    0x02,0x8c,0x7c,0x02,0x8b,0xfe,0x02,0x6c,0xe6,0x00,0xd1,0xca,0x25,0x16,0xf6,0x02,
+    0x8b,0xc1,0x02,0x24,0x07,0xf6,0x02,0x8c,0xc1,0x02,0x25,0x08,0xc6,0x03,0xf7,0x02,
+    0x8c,0xf7,0x02,0x8b,0x38,0x38,0x39,0xbd,0x48,0x38,0xdd,0xf2,0xbd,0xd1,0x6b,0x39,
+    0xf6,0x07,0x11,0xf7,0x02,0x75,0xc1,0xc3,0x26,0x06,0x7f,0x07,0x11,0x7e,0xc0,0x00,
+    0x15,0xe9,0xc0,0xf6,0x06,0x92,0x56,0x56,0x56,0xc4,0xc0,0xda,0xe9,0xd7,0xe9,0xf6,
+    0x06,0x92,0xc5,0x03,0x26,0x05,0xca,0x02,0xf7,0x06,0x92,0xbd,0xec,0xc3,0xd6,0xb7,
+    0x27,0x08,0xf6,0x02,0x16,0xca,0x20,0xf7,0x02,0x16,0x8d,0x0a,0xbd,0x4b,0x05,0xbd,
+    0x4b,0x23,0xbd,0xe8,0xf5,0x39,0x3c,0x3c,0x34,0x30,0x6f,0x02,0xf6,0x01,0xb4,0x5a,
+    0x27,0x03,0x7e,0x4a,0xbf,0xd6,0xb7,0xf7,0x07,0x22,0x5f,0xd7,0x6a,0x18,0xce,0x02,
+    0xc4,0x58,0x58,0x58,0x18,0x3a,0x18,0xe6,0x00,0xd7,0x68,0x27,0x48,0x4f,0x05,0xc3,
+    0x00,0xa0,0x37,0x36,0xd6,0x6a,0x58,0x58,0x58,0x4f,0xc3,0x02,0xc4,0x18,0x8f,0x18,
+    0xa6,0x02,0x5f,0xed,0x00,0x18,0xe6,0x01,0x4f,0xe3,0x00,0x18,0x38,0x18,0xed,0x00,
+    0xd6,0x68,0x4f,0x05,0xc3,0x00,0x96,0x37,0x36,0xd6,0x6a,0x58,0x58,0x58,0x4f,0xc3,
+    0x02,0xc4,0x18,0x8f,0x18,0xa6,0x04,0x5f,0xed,0x00,0x18,0xe6,0x03,0x4f,0xe3,0x00,
+    0x18,0x38,0x18,0xed,0x00,0x7c,0x00,0x6a,0xd6,0x6a,0xc1,0x05,0x25,0x9f,0x5f,0xd7,
+    0x6a,0xc6,0x91,0xd7,0x68,0xbd,0x4a,0xc3,0xbd,0x4a,0xc3,0xbd,0x4a,0xc3,0xd6,0x6a,
+    0x4f,0x05,0x18,0x8f,0x18,0xec,0xa2,0xdd,0x91,0x18,0xec,0x98,0xdd,0x8f,0xd6,0x91,
+    0xf7,0x07,0x32,0xd6,0x92,0xf7,0x07,0x39,0xd6,0x8f,0xf7,0x07,0x3a,0xd6,0x90,0xf7,
+    0x07,0x3b,0xd6,0x6a,0x4f,0x18,0x8f,0x18,0xe6,0x93,0xf7,0x07,0x3c,0xc6,0xab,0xd7,
+    0x68,0x7c,0x00,0x6a,0x8d,0x71,0x5f,0xd7,0x68,0xd7,0x6a,0x74,0x00,0x68,0x4f,0x18,
+    0x8f,0x18,0xe6,0x93,0x27,0x03,0x14,0x68,0x10,0x7c,0x00,0x6a,0xd6,0x6a,0xc1,0x05,
+    0x25,0xe9,0xd6,0xb7,0x27,0x03,0x14,0x68,0x20,0xf6,0x07,0x21,0xc4,0xc0,0xda,0x68,
+    0xf7,0x07,0x21,0xd6,0x68,0xd7,0x6a,0xc6,0x07,0xd7,0x68,0x13,0x6a,0x02,0x04,0xc6,
+    0x0c,0xd7,0x68,0x13,0x6a,0x1c,0x04,0xc6,0x21,0xd7,0x68,0x5f,0xd7,0x6a,0x20,0x12,
+    0x4f,0xc3,0x06,0x92,0x18,0x8f,0xe6,0x02,0x18,0xeb,0x8f,0xe7,0x02,0x7c,0x00,0x6a,
+    0xd6,0x6a,0xd1,0x68,0x25,0xea,0xd6,0x68,0x4f,0xc3,0x06,0x92,0x18,0x8f,0xe6,0x02,
+    0x18,0xe7,0x8f,0x31,0x38,0x38,0x39,0x3c,0x3c,0xd6,0x6a,0x4f,0x05,0x8f,0xec,0xa2,
+    0xdd,0x91,0xec,0x98,0xdd,0x8f,0xce,0x06,0x92,0xd6,0x68,0x3a,0xd6,0x91,0xe7,0x00,
+    0xd6,0x68,0x4f,0xc3,0x06,0x92,0x8f,0xd6,0x92,0xe7,0x01,0xd6,0x8f,0xe7,0x02,0xd6,
+    0x90,0xe7,0x03,0x3c,0xd6,0x6a,0x4f,0x8f,0xe6,0x93,0x38,0xe7,0x04,0x7c,0x00,0x6a,
+    0xd6,0x68,0xcb,0x05,0xd7,0x68,0x38,0x38,0x39,0x7f,0x01,0xb4,0xd6,0xc6,0xc5,0x3f,
+    0x26,0x04,0x13,0xbd,0x3f,0x05,0xc6,0x01,0xf7,0x01,0xb4,0xf6,0x02,0x75,0x5a,0x26,
+    0x05,0xc6,0x01,0xf7,0x01,0xb4,0x39,0xf6,0x01,0xb4,0x5a,0x26,0x17,0x13,0xe6,0x08,
+    0x0a,0xbd,0xf7,0xed,0xbd,0xef,0x0d,0xbd,0xf7,0xd6,0x39,0xbd,0xf7,0xd6,0xbd,0xef,
+    0x0d,0xbd,0xf7,0xed,0x39,0x3c,0x3c,0x5f,0xd7,0x6a,0x7e,0x4b,0xcd,0x4f,0x05,0x05,
+    0xc3,0x00,0x29,0xfd,0x03,0xd4,0x8f,0xe6,0x00,0x5a,0x27,0x09,0xe6,0x01,0xd1,0xc2,
+    0x26,0x31,0xfe,0x03,0xd4,0xe6,0x01,0xe1,0x00,0x26,0x0e,0xe6,0x00,0x5a,0x26,0x04,
+    0x6c,0x01,0x20,0x05,0xfe,0x03,0xd4,0x6a,0x00,0xe6,0x03,0xe1,0x02,0x26,0x14,0xd1,
+    0xc0,0x24,0x05,0x6c,0x03,0xfe,0x03,0xd4,0xe6,0x02,0xc1,0x01,0x23,0x05,0x6a,0x02,
+    0xfe,0x03,0xd4,0xe6,0x02,0x5a,0x27,0x09,0xe6,0x03,0xd1,0xc0,0x26,0x2e,0xfe,0x03,
+    0xd4,0xe6,0x03,0xe1,0x02,0x26,0x0e,0xe6,0x02,0x5a,0x26,0x04,0x6c,0x03,0x20,0x05,
+    0xfe,0x03,0xd4,0x6a,0x02,0xe6,0x01,0xe1,0x00,0x26,0x11,0xd1,0xc2,0x24,0x05,0x6c,
+    0x01,0xfe,0x03,0xd4,0xe6,0x00,0xc1,0x01,0x23,0x02,0x6a,0x00,0x7c,0x00,0x6a,0xd6,
+    0x6a,0xd1,0xc8,0x24,0x03,0x7e,0x4b,0x49,0x38,0x38,0x39,0x3c,0x3c,0x5f,0xd7,0x6a,
+    0x7e,0x4c,0x86,0x4f,0x8f,0xe6,0x93,0x26,0x05,0xce,0x03,0x00,0x20,0x18,0xce,0x03,
+    0x00,0xd6,0x6a,0x3a,0x6c,0x00,0xe6,0x00,0xc1,0x05,0x23,0x04,0xc6,0x05,0xe7,0x00,
+    0x5a,0x26,0x0a,0xce,0x01,0x3e,0xd6,0x6a,0x3a,0x6f,0x00,0x20,0x38,0xe6,0x00,0xc1,
+    0x02,0x26,0x32,0xd6,0x6a,0x58,0x58,0x4f,0xc3,0x01,0x5c,0x37,0x36,0xd6,0x6a,0x58,
+    0x58,0x58,0x4f,0xc3,0x01,0xc2,0x8f,0xec,0x02,0x38,0xed,0x02,0xd6,0x6a,0x58,0x58,
+    0x4f,0xc3,0x01,0x48,0x37,0x36,0xd6,0x6a,0x58,0x58,0x58,0x4f,0xc3,0x01,0xea,0x8f,
+    0xec,0x02,0x38,0xed,0x02,0xce,0x01,0x39,0xd6,0x6a,0x3a,0xa6,0x00,0x27,0x36,0x4f,
+    0x05,0x37,0x36,0xce,0x01,0x5c,0xd6,0x6a,0x58,0x58,0x3a,0xec,0x00,0x38,0xed,0xa2,
+    0xd6,0x6a,0x4f,0x05,0x37,0x36,0xce,0x01,0x48,0xd6,0x6a,0x58,0x58,0x3a,0xec,0x00,
+    0x38,0xed,0x98,0xd6,0x6a,0x4f,0x8f,0xc6,0x01,0xe7,0x93,0xce,0x01,0x43,0xd6,0x6a,
+    0x3a,0xc6,0x1f,0xe7,0x00,0x7c,0x00,0x6a,0xd6,0x6a,0xd1,0xc5,0x24,0x03,0x7e,0x4b,
+    0xdf,0x38,0x38,0x39,0x12,0xcb,0x20,0x03,0x7e,0x4d,0x68,0x5f,0xd7,0x6a,0x18,0xce,
+    0x03,0xe7,0x7e,0x4d,0x61,0x4f,0x97,0x67,0x05,0x8f,0xec,0xa2,0xdd,0x91,0xec,0x98,
+    0xdd,0x8f,0xd6,0x6a,0x86,0x03,0x3d,0xc3,0x03,0xd8,0xfd,0x03,0xd6,0x4f,0xd6,0x6a,
+    0x8f,0xe6,0x93,0x26,0x09,0xbd,0x4d,0x69,0x18,0x6f,0x04,0x7e,0x4d,0x58,0x18,0x6d,
+    0x04,0x26,0x0f,0x18,0xe7,0x04,0xdc,0x91,0x18,0xed,0x00,0xdc,0x8f,0x18,0xed,0x02,
+    0x20,0x7a,0xfe,0x03,0xd6,0xe6,0x00,0xc1,0x01,0x26,0x0a,0xce,0x01,0x3e,0xd6,0x6a,
+    0x3a,0x6f,0x00,0x20,0x67,0xdc,0x91,0x18,0xa3,0x00,0x2f,0x0a,0x05,0xb3,0x01,0x78,
+    0x23,0x13,0x86,0x02,0x20,0x0d,0x43,0x53,0xc3,0x00,0x01,0x05,0xb3,0x01,0x78,0x23,
+    0x04,0x86,0x01,0x97,0x67,0x96,0x67,0xfe,0x03,0xd6,0xe6,0x01,0x27,0x07,0x11,0x26,
+    0x04,0xc6,0x01,0xe7,0x00,0xa7,0x01,0x7f,0x00,0x67,0xdc,0x8f,0x18,0xa3,0x02,0x2f,
+    0x0a,0x05,0xb3,0x01,0x76,0x23,0x13,0x86,0x02,0x20,0x0d,0x43,0x53,0xc3,0x00,0x01,
+    0x05,0xb3,0x01,0x76,0x23,0x04,0x86,0x01,0x97,0x67,0x96,0x67,0xfe,0x03,0xd6,0xe6,
+    0x02,0x27,0x07,0x11,0x26,0x04,0xc6,0x01,0xe7,0x00,0xa7,0x02,0xc6,0x05,0x18,0x3a,
+    0x7c,0x00,0x6a,0xd6,0x6a,0xd1,0xc5,0x24,0x03,0x7e,0x4c,0xa1,0x39,0x3c,0xfe,0x03,
+    0xd6,0x6f,0x00,0x6f,0x01,0x6f,0x02,0x38,0x39,0xbd,0xd6,0x07,0xd6,0xb9,0x27,0x03,
+    0x14,0xb9,0x80,0x39,0xd6,0x81,0x26,0x04,0xd6,0x68,0xd7,0x80,0xbd,0xd9,0x29,0x39,
+    0xce,0x05,0xe0,0xcc,0x4d,0x80,0xed,0x68,0xcc,0x4d,0x75,0xed,0x5e,0xcc,0x49,0x12,
+    0xed,0x48,0xcc,0x46,0xf8,0xed,0x06,0xcc,0x49,0x43,0xed,0x58,0xcc,0x47,0x6d,0xed,
+    0x56,0xcc,0x47,0x6e,0xed,0x4e,0xcc,0x4d,0xd8,0xed,0x60,0xcc,0x49,0x0d,0xed,0x50,
+    0xcc,0x4e,0x33,0xed,0x6e,0x39,0xbd,0xc4,0x92,0xce,0x06,0x92,0xcc,0x00,0x00,0xed,
+    0x81,0xcc,0xe8,0x11,0xed,0x83,0xcc,0x10,0x10,0xed,0x85,0x39,0x3c,0x3c,0xd6,0xc8,
+    0xd1,0xac,0x26,0x20,0xf6,0x02,0xfb,0xd1,0xac,0x27,0x08,0xd6,0xac,0xf7,0x02,0xfb,
+    0x5f,0xd7,0xf4,0xd6,0xac,0x27,0x0b,0xd6,0xf4,0xc1,0xff,0x24,0x07,0x7c,0x00,0xf4,
+    0x20,0x02,0xd7,0xf4,0xd6,0xc8,0x27,0x10,0xd6,0xac,0x27,0x0c,0xd6,0xc8,0xd1,0xac,
+    0x27,0x06,0xd6,0xf4,0xc1,0x04,0x22,0x03,0x7e,0xf4,0x76,0xd6,0xad,0x27,0x04,0xd1,
+    0xc8,0x27,0x07,0xd6,0xc8,0xd7,0xad,0x5f,0xd7,0xae,0x7e,0xf4,0xae,0xd6,0xac,0x37,
+    0xbd,0xd6,0x93,0x33,0xd7,0xac,0x39,0xbd,0xf8,0xdb,0x10,0x4f,0x5f,0xfd,0x01,0x7e,
+    0xd6,0x68,0x26,0x04,0xdc,0x7d,0x20,0x02,0xdc,0x7b,0xfd,0x01,0x80,0x86,0x09,0x27,
+    0x0f,0x78,0x01,0xbc,0x79,0x01,0xbb,0x79,0x01,0xba,0x79,0x01,0xb9,0x4a,0x26,0xf1,
+    0xdc,0x8d,0x6f,0x02,0x6f,0x03,0xed,0x0a,0xec,0x02,0xed,0x08,0xfc,0x01,0xb9,0xed,
+    0x02,0xec,0x00,0xc3,0xff,0xf9,0x18,0x8f,0xfc,0x01,0xbb,0xbd,0xf9,0x9d,0x18,0xce,
+    0x4f,0xb5,0xbd,0xfb,0xa9,0xdd,0x91,0x83,0x04,0x00,0x25,0x03,0x7e,0x4f,0x27,0xcc,
+    0x04,0x00,0xed,0x0e,0x93,0x91,0xed,0x0c,0x83,0x01,0x00,0x22,0x1f,0xf6,0x02,0xf0,
+    0x4f,0xed,0x0a,0xf6,0x02,0xed,0x18,0x8f,0xec,0x0c,0xbd,0xf9,0x08,0x3c,0xee,0x0a,
+    0x02,0x8f,0x38,0xed,0x08,0xcc,0x04,0x00,0xa3,0x08,0x20,0x60,0xec,0x0c,0x83,0x02,
+    0x00,0x22,0x2a,0xf6,0x02,0xf0,0x4f,0xed,0x0a,0xf6,0x02,0xee,0x18,0x8f,0xec,0x0c,
+    0x83,0x01,0x00,0xbd,0xf9,0x08,0xed,0x08,0xb6,0x02,0xed,0x5f,0xe3,0x08,0x3c,0xee,
+    0x0a,0x02,0x8f,0x38,0xed,0x06,0xcc,0x04,0x00,0xa3,0x06,0x20,0x2f,0xf6,0x02,0xf0,
+    0x4f,0xed,0x0a,0xf6,0x02,0xef,0x18,0x8f,0xec,0x0c,0x83,0x02,0x00,0xbd,0xf9,0x08,
+    0xed,0x08,0xb6,0x02,0xee,0x5f,0xed,0x06,0xb6,0x02,0xed,0xe3,0x06,0xe3,0x08,0x3c,
+    0xee,0x0a,0x02,0x8f,0x38,0xed,0x04,0xcc,0x04,0x00,0xa3,0x04,0xdd,0x91,0xb3,0x01,
+    0x80,0x22,0x03,0x7e,0x4f,0xb1,0x4f,0x5f,0x7e,0x4f,0xaf,0xfc,0x01,0x80,0x83,0x04,
+    0x00,0x93,0x91,0x24,0xee,0xfc,0x01,0x80,0x83,0x04,0x00,0xed,0x0e,0xdc,0x91,0xa3,
+    0x0e,0xed,0x0c,0x83,0x01,0x00,0x22,0x12,0xf6,0x02,0xf0,0x4f,0xed,0x0a,0xf6,0x02,
+    0xed,0x18,0x8f,0xec,0x0c,0xbd,0xf9,0x08,0x20,0x44,0xec,0x0c,0x83,0x02,0x00,0x22,
+    0x1b,0xf6,0x02,0xf0,0x4f,0xed,0x0a,0xf6,0x02,0xee,0x18,0x8f,0xec,0x0c,0x83,0x01,
+    0x00,0xbd,0xf9,0x08,0xed,0x08,0xb6,0x02,0xed,0x5f,0x20,0x20,0xf6,0x02,0xf0,0x4f,
+    0xed,0x0a,0xf6,0x02,0xef,0x18,0x8f,0xec,0x0c,0x83,0x02,0x00,0xbd,0xf9,0x08,0xed,
+    0x08,0xb6,0x02,0xee,0x5f,0xed,0x06,0xb6,0x02,0xed,0xe3,0x06,0xe3,0x08,0x3c,0xee,
+    0x0a,0x02,0x8f,0x38,0xe3,0x0e,0xdd,0x91,0xb3,0x01,0x80,0x25,0x08,0xfc,0x01,0x80,
+    0x83,0x00,0x01,0xdd,0x91,0xae,0x00,0x38,0x39,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,
+};
+
+#endif
diff --git a/drivers/input/touchscreen/gt811_ts.c b/drivers/input/touchscreen/gt811_ts.c
new file mode 100755
index 000000000000..c2cd505c1c15
--- /dev/null
+++ b/drivers/input/touchscreen/gt811_ts.c
@@ -0,0 +1,2017 @@
+/* drivers/input/touchscreen/gt811.c
+ *
+ * Copyright (C) 2010 - 2011 Goodix, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ *Any problem,please contact andrew@goodix.com,+86 755-33338828
+ *
+ */
+ 
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/earlysuspend.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <mach/gpio.h>
+//#include <plat/gpio-cfg.h>
+//#include <plat/gpio-bank-l.h>
+//#include <plat/gpio-bank-f.h>
+#include <linux/irq.h>
+#include <linux/syscalls.h>
+#include <linux/reboot.h>
+#include <linux/proc_fs.h>
+#include "gt811_ts.h"
+#include "gt811_firmware.h"
+
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <linux/input/mt.h>
+#include <mach/iomux.h>
+
+static struct workqueue_struct *goodix_wq;
+static const char *s3c_ts_name = "gt811_ts";
+//static struct point_queue finger_list;
+struct i2c_client * i2c_connect_client = NULL;
+//EXPORT_SYMBOL(i2c_connect_client);
+static struct proc_dir_entry *goodix_proc_entry;
+static short  goodix_read_version(struct gt811_ts_data *ts);	
+//static int tpd_button(struct gt811_ts_data *ts, unsigned int x, unsigned int y, unsigned int down);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h);
+static void goodix_ts_late_resume(struct early_suspend *h);
+int  gt811_downloader( struct gt811_ts_data *ts, unsigned char * data);
+#endif
+//used by firmware update CRC
+unsigned int oldcrc32 = 0xFFFFFFFF;
+unsigned int crc32_table[256];
+unsigned int ulPolynomial = 0x04c11db7;
+
+unsigned int raw_data_ready = RAW_DATA_NON_ACTIVE;
+
+//#define DEBUG
+#ifdef DEBUG
+int sum = 0;
+int access_count = 0;
+int int_count = 0;
+#endif
+#define HAVE_TOUCH_KEY
+ //#define READ_KEY_VALUE
+ //#define READ_KEY_COOR
+
+#ifdef HAVE_TOUCH_KEY
+    const uint16_t touch_key_array[]={
+                                       KEY_MENU,             //MENU
+                                       KEY_HOMEPAGE,                                    
+                                       KEY_BACK,
+                                       KEY_SEARCH
+                                      };
+#define MAX_KEY_NUM  (sizeof(touch_key_array)/sizeof(touch_key_array[0]))
+#endif
+
+/*******************************************************	
+Function:
+	Read data from the slave
+	Each read operation with two i2c_msg composition, for the first message sent from the machine address,
+	Article 2 reads the address used to send and retrieve data; each message sent before the start signal
+Parameters:
+	client: i2c devices, including device address
+	buf [0]: The first byte to read Address
+	buf [1] ~ buf [len]: data buffer
+	len: the length of read data
+return:
+	Execution messages
+*********************************************************/
+/*Function as i2c_master_send */
+static int i2c_read_bytes(struct i2c_client *client, uint8_t *buf, int len)
+{
+	struct i2c_msg msgs[2];
+	int ret=-1;
+	
+	msgs[0].flags=!I2C_M_RD;
+	msgs[0].addr=client->addr;
+	msgs[0].len=2;
+	msgs[0].buf=&buf[0];
+	msgs[0].scl_rate=200000;
+
+	msgs[1].flags=I2C_M_RD;
+	msgs[1].addr=client->addr;
+	msgs[1].len=len-2;
+	msgs[1].buf=&buf[2];
+	msgs[1].scl_rate=200000;
+	
+	ret=i2c_transfer(client->adapter,msgs, 2);
+	return ret;
+}
+
+/*******************************************************	
+Function:
+	Write data to a slave
+Parameters:
+	client: i2c devices, including device address
+	buf [0]: The first byte of the write address
+	buf [1] ~ buf [len]: data buffer
+	len: data length
+return:
+	Execution messages
+*******************************************************/
+/*Function as i2c_master_send */
+static int i2c_write_bytes(struct i2c_client *client,uint8_t *data,int len)
+{
+	struct i2c_msg msg;
+	int ret=-1;
+	//
+	msg.flags=!I2C_M_RD;//?	msg.addr=client->addr;
+	msg.len=len;
+	msg.buf=data;	
+	msg.scl_rate=200000;
+    msg.addr=client->addr;
+	
+	ret=i2c_transfer(client->adapter,&msg, 1);
+	return ret;
+}
+
+/*******************************************************
+Function:
+	Send a prefix command
+	
+Parameters:
+	ts: client private data structure
+	
+return:
+	Results of the implementation code, 0 for normal execution
+*******************************************************/
+static int i2c_pre_cmd(struct gt811_ts_data *ts)
+{
+	int ret;
+	uint8_t pre_cmd_data[2]={0};	
+	pre_cmd_data[0]=0x0f;
+	pre_cmd_data[1]=0xff;
+	ret=i2c_write_bytes(ts->client,pre_cmd_data,2);
+	//msleep(2);
+	return ret;
+}
+
+/*******************************************************
+Function:
+	Send a suffix command
+	
+Parameters:
+	ts: client private data structure
+	
+return:
+	Results of the implementation code, 0 for normal execution
+*******************************************************/
+static int i2c_end_cmd(struct gt811_ts_data *ts)
+{
+	int ret;
+	uint8_t end_cmd_data[2]={0};	
+	end_cmd_data[0]=0x80;
+	end_cmd_data[1]=0x00;
+	ret=i2c_write_bytes(ts->client,end_cmd_data,2);
+	//msleep(2);
+	return ret;
+}
+
+/********************************************************************
+
+*********************************************************************/
+#ifdef COOR_TO_KEY
+static int list_key(s32 x_value, s32 y_value, u8* key)
+{
+	s32 i;
+
+#ifdef AREA_Y
+	if (y_value <= AREA_Y)
+#else
+	if (x_value <= AREA_X)
+#endif
+	{
+		return 0;
+	}
+
+	for (i = 0; i < MAX_KEY_NUM; i++)
+	{
+		if (abs(key_center[i][x] - x_value) < KEY_X 
+		&& abs(key_center[i][y] - y_value) < KEY_Y)
+		{
+			(*key) |= (0x01<<i);
+        	}
+   	 }
+
+    return 1;
+}
+#endif 
+
+/*******************************************************
+Function:
+	Guitar initialization function, used to send configuration information, access to version information
+Parameters:
+	ts: client private data structure
+return:
+	Results of the implementation code, 0 for normal execution
+*******************************************************/
+static int goodix_init_panel(struct gt811_ts_data *ts)
+{
+	short ret=-1;
+	uint8_t config_info[] = {
+	0x06,0xA2,
+/*
+	0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x60,0x00,0x50,0x00,0x40,0x00,
+	0x30,0x00,0x20,0x00,0x10,0x00,0x00,0x00,0x70,0x00,0x80,0x00,0x90,0x00,0xA0,0x00,
+	0xB0,0x00,0xC0,0x00,0xD0,0x00,0xE0,0x00,0xF0,0x00,0x05,0x03,0x90,0x90,0x90,0x30,
+	0x30,0x30,0x0F,0x0F,0x0A,0x50,0x3C,0x08,0x03,0x3C,0x05,0x00,0x14,0x00,0x20,0x04,
+	0x04,0x64,0x5A,0x40,0x40,0x00,0x00,0x03,0x19,0x00,0x05,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x10,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x50,
+	0x3C,0x3C,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01
+*/
+/*	0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,0x13,0x33,0x23,0x33,0x33,0x33,
+	0x43,0x33,0x53,0x33,0x63,0x33,0x73,0x33,0x83,0x33,0x93,0x33,0xA3,0x33,0xB3,0x33,
+	0xC3,0x33,0xD3,0x33,0xE3,0x33,0xF3,0x33,0x03,0x33,0x3B,0x03,0x88,0x88,0x88,0x1B,
+	0x1B,0x1B,0x0F,0x0F,0x0A,0x40,0x30,0x0F,0x03,0x00,0x05,0x00,0x14,0x00,0x1E,0x04,
+	0x04,0x64,0x5A,0x40,0x40,0x00,0x00,0x05,0x19,0x05,0x05,0x00,0x00,0x00,0x00,0x00,
+	0x20,0x10,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x50,
+	0x3C,0x3C,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01
+*/	
+
+   /* 0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,
+    0x02,0x22,0x12,0x22,0x22,0x22,0x32,0x22,0x42,0x22,
+    0x52,0x22,0x62,0x22,0x72,0x22,0x82,0x22,0x92,0x22,
+    0xA2,0x22,0xB2,0x22,0xC2,0x22,0xD2,0x22,0xE2,0x22,
+    0xF2,0x22,0x1B,0x03,0x88,0x88,0x88,0x1D,0x1D,0x1D,
+    0x10,0x0F,0x0A,0x47,0x2A,0x0D,0x03,0x00,0x05,0x00,
+    0x03,0x00,0x04,0x00,0x00,0x38,0x33,0x35,0x30,0x00,
+    0x00,0x07,0x20,0x05,0x05,0x00,0x00,0x00,0x00,0x00,
+    0x32,0x16,0x80,0x03,0x00,0x40,0x17,0x88,0x1B,0x00,
+    0x71,0x80,0x90,0xA0,0x0A,0x45,0x30,0x20,0x14,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x01*/
+     
+	/* 0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,
+	 0x52,0x22,0x62,0x22,0x72,0x22,0x82,0x22,0x92,0x22,
+	 0xA2,0x22,0xB2,0x22,0xC2,0x22,0xD2,0x22,0xE2,0x22,
+	 0xF2,0x22,0x02,0x22,0x12,0x22,0x22,0x22,0x32,0x22,
+	 0x42,0x22,0x07,0x03,0x88,0x88,0x88,0x27,0x27,0x27,
+	 0x0B,0x0A,0x09,0x40,0x30,0x01,0x03,0x00,0x05,0xE0,
+	 0x01,0x20,0x03,0x00,0x00,0xFF,0xFF,0x42,0x2B,0x00,
+	 0x00,0x23,0x14,0x05,0x06,0x00,0x00,0x00,0x00,0x00,
+	 0x14,0x10,0xC6,0x02,0x00,0x40,0x17,0x88,0x20,0x00,
+	 0x60,0x70,0x80,0x90,0x0D,0x40,0x30,0x25,0x20,0x00,
+	 0x00,0x00,0x00,0x00,0x00,0x01*/
+	   0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,
+	   0x02,0x22,0x12,0x22,0x22,0x22,0x32,0x22,0x42,0x22,
+	   0x52,0x22,0x62,0x22,0x72,0x22,0x83,0x22,0x92,0x22,
+	   0xA2,0x22,0xB2,0x22,0xC2,0x22,0xD2,0x22,0xE2,0x22,
+	   0xF2,0x22,0x1B,0x03,0x28,0x28,0x28,0x20,0x20,0x20,
+	   0x0F,0x0F,0x0A,0x45,0x30,0x04,0x03,0x00,0x05,0xE0,
+	   0x01,0x20,0x03,0x00,0x00,0x38,0x33,0x35,0x30,0x00,
+	   0x00,0x26,0x14,0x02,0x0A,0x00,0x00,0x00,0x00,0x00,
+	   0x14,0x10,0x30,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
+	   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	   0x00,0x00,0x00,0x00,0x00,0x01
+    
+    };
+
+	config_info[62] = TOUCH_MAX_WIDTH >> 8;
+    	config_info[61] = TOUCH_MAX_WIDTH & 0xff;
+    	config_info[64] = TOUCH_MAX_HEIGHT >> 8;
+    	config_info[63] = TOUCH_MAX_HEIGHT & 0xff;
+	
+	ret = i2c_write_bytes(ts->client, config_info, sizeof(config_info)/sizeof(config_info[0]));
+	if(ret < 0)
+	{
+		dev_info(&ts->client->dev, "GT811 Send config failed!\n");
+		return ret;
+	}
+	ts->abs_y_max = (config_info[62]<<8) + config_info[61];
+	ts->abs_x_max = (config_info[64]<<8) + config_info[63];
+	ts->max_touch_num = config_info[60];
+	ts->int_trigger_type = ((config_info[57]>>3)&0x01);
+	dev_info(&ts->client->dev, "GT811 init info:X_MAX=%d,Y_MAX=%d,TRIG_MODE=%s\n",
+	ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type?"RISING EDGE":"FALLING EDGE");
+
+	return 0;
+}
+
+/*******************************************************
+FUNCTION:
+	Read gt811 IC Version
+Argument:
+	ts:	client
+return:
+	0:success
+       -1:error
+*******************************************************/
+static short  goodix_read_version(struct gt811_ts_data *ts)
+{
+	short ret;
+	uint8_t version_data[5]={0x07,0x17,0,0};	//store touchscreen version infomation
+	uint8_t version_data2[5]={0x07,0x17,0,0};	//store touchscreen version infomation
+
+	char i = 0;
+	char cpf = 0;
+	memset(version_data, 0, 5);
+	version_data[0]=0x07;
+	version_data[1]=0x17;	
+
+      	ret=i2c_read_bytes(ts->client, version_data, 4);
+	if (ret < 0) 
+		return ret;
+	
+	for(i = 0;i < 10;i++)
+	{
+		i2c_read_bytes(ts->client, version_data2, 4);
+		if((version_data[2] !=version_data2[2])||(version_data[3] != version_data2[3]))
+		{
+			version_data[2] = version_data2[2];
+			version_data[3] = version_data2[3];
+			msleep(5);
+			break;
+		}
+		msleep(5);
+		cpf++;
+	}
+
+	if(cpf == 10)
+	{
+		ts->version = (version_data[2]<<8)+version_data[3];
+		dev_info(&ts->client->dev, "GT811 Verion:0x%04x\n", ts->version);
+		ret = 0;
+	}
+	else
+	{
+		dev_info(&ts->client->dev," Guitar Version Read Error: %d.%d\n",version_data[3],version_data[2]);
+		ts->version = 0xffff;
+		ret = -1;
+	}
+	
+	return ret;
+	
+}
+/******************start add by kuuga*******************/
+static void gt811_irq_enable(struct gt811_ts_data *ts)
+{	
+	unsigned long irqflags;	
+	spin_lock_irqsave(&ts->irq_lock, irqflags);
+	if (ts->irq_is_disable) 
+	{		
+		enable_irq(ts->irq);		
+		ts->irq_is_disable = 0;	
+	}	
+	spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+}
+
+static void gt811_irq_disable(struct gt811_ts_data *ts)
+{	
+	unsigned long irqflags;
+	spin_lock_irqsave(&ts->irq_lock, irqflags);
+	if (!ts->irq_is_disable) 
+	{		
+		disable_irq_nosync(ts->irq);		
+		ts->irq_is_disable = 1;	
+	}	
+	spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+}
+
+/*****************end add by kuuga****************/
+
+/*******************************************************	
+Function:
+	Touch-screen work function
+	Triggered by the interruption, to accept a set of coordinate data,
+	and then analyze the output parity
+Parameters:
+	ts: client private data structure
+return:
+	Results of the implementation code, 0 for normal execution
+********************************************************/
+static void goodix_ts_work_func(struct work_struct *work)
+{	
+	uint8_t  point_data[READ_BYTES_NUM] = {READ_TOUCH_ADDR_H,READ_TOUCH_ADDR_L,0};//point_data[8*MAX_FINGER_NUM+2]={ 0 };  
+	uint8_t  check_sum = 0;
+	uint8_t  read_position = 0;
+	uint8_t  track_id[MAX_FINGER_NUM];
+	uint8_t  point_index = 0;
+	uint8_t  point_tmp = 0;
+	uint8_t  point_count = 0;
+	uint16_t input_x = 0;
+	uint16_t input_y = 0;
+	uint8_t  input_w = 0;
+	static uint8_t  last_key = 0;
+	uint8_t  finger = 0;
+	uint8_t  key = 0;
+	unsigned int  count = 0;
+	unsigned int position = 0;	
+	int ret=-1;
+	int tmp = 0;
+	
+	struct gt811_ts_data *ts = container_of(work, struct gt811_ts_data, work);
+#ifdef DEBUG
+    	printk("int count :%d\n", ++int_count);
+   	printk("ready?:%d\n", raw_data_ready);
+#endif     
+    	if (RAW_DATA_ACTIVE == raw_data_ready)
+	{
+	    raw_data_ready = RAW_DATA_READY;
+#ifdef DEBUG	    
+	    printk("ready!\n");
+#endif
+	}
+	
+#ifndef INT_PORT
+COORDINATE_POLL:
+#endif
+	if( tmp > 9) 
+	{
+		dev_info(&(ts->client->dev), "Because of transfer error,touchscreen stop working.\n");
+		goto XFER_ERROR ;
+	}
+	
+	ret=i2c_read_bytes(ts->client, point_data, sizeof(point_data)/sizeof(point_data[0]));
+	if(ret <= 0) 
+	{
+       dev_err(&(ts->client->dev),"I2C transfer error. Number:%d\n ", ret);
+       ts->bad_data = 1;
+       tmp ++;
+       ts->retry++;
+#ifndef INT_PORT
+       goto COORDINATE_POLL;
+#else   
+       goto XFER_ERROR;
+#endif  
+   }
+#if 0
+	for(count=0;count<(sizeof(point_data)/sizeof(point_data[0])); count++)
+	{
+		printk("[%2d]:0x%2x", count, point_data[count]);
+		if((count+1)%10==0)printk("\n");
+	}
+	printk("\n");
+#endif	
+	if(point_data[2]&0x20)
+	{
+		if(point_data[3]==0xF0)
+		{
+			gpio_direction_output(SHUTDOWN_PORT, 0);
+			msleep(1);
+		//	gpio_direction_input(SHUTDOWN_PORT);
+            gpio_set_value(SHUTDOWN_PORT,0);
+            msleep(100);
+            gpio_set_value(SHUTDOWN_PORT,1);
+            msleep(100);
+
+			goodix_init_panel(ts);
+			goto WORK_FUNC_END;
+		}
+	}
+	switch(point_data[2]& 0x1f)
+	{
+		case 0:
+		case 1:
+			for(count=2; count<9; count++)
+				check_sum += (int)point_data[count];
+			read_position = 9;
+			break;
+		case 2:
+		case 3:
+			for(count=2; count<14;count++)
+				check_sum += (int)point_data[count];
+			read_position = 14;
+			break;	
+		default:		//touch finger larger than 3
+			for(count=2; count<35;count++)
+				check_sum += (int)point_data[count];
+			read_position = 35;
+	}
+	if(check_sum != point_data[read_position])
+	{
+		dev_info(&ts->client->dev, "coor chksum error!\n");
+		goto XFER_ERROR;
+	}
+    
+	point_index = point_data[2]&0x1f;
+	point_tmp = point_index;
+	for(position=0; (position<MAX_FINGER_NUM)&&point_tmp; position++)
+	{
+		if(point_tmp&0x01)
+		{
+			track_id[point_count++] = position;
+		}	
+		point_tmp >>= 1;
+	}	
+	finger = point_count;
+	if(finger)
+	{
+		for(count=0; count<finger; count++)
+		{
+			if(track_id[count]!=3)
+			{
+				if(track_id[count]<3)
+					position = 4+track_id[count]*5;
+				else
+					position = 30;
+				input_x = (uint16_t)(point_data[position]<<8)+(uint16_t)point_data[position+1];
+				input_y = (uint16_t)(point_data[position+2]<<8)+(uint16_t)point_data[position+3];
+				input_w = point_data[position+4];
+			}
+			else
+			{
+				input_x = (uint16_t)(point_data[19]<<8)+(uint16_t)point_data[26];
+        input_y = (uint16_t)(point_data[27]<<8)+(uint16_t)point_data[28];
+        input_w = point_data[29];	
+			}
+			
+			//printk("real_input_y = %d,TOUCH_MAX_HEIGHT=%d,TOUCH_MAX_WIDTH=%d,input_x=%d,input_y=%d,input_w=%d\n",input_y, TOUCH_MAX_HEIGHT,TOUCH_MAX_WIDTH,TOUCH_MAX_HEIGHT - input_y,TOUCH_MAX_WIDTH-input_x,  input_w);
+			//if((input_y > ts->abs_x_max)||(TOUCH_MAX_WIDTH-input_x > ts->abs_y_max))continue;
+			input_mt_slot(ts->input_dev, track_id[count]);	
+			//input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+			//printk("DOWN\n")
+; ;
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_y);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_x);			
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
+			//input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, input_w);
+			//input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, track_id[count]);
+			//input_mt_sync(ts->input_dev);	
+		}
+	}
+	else
+	{
+		for(tmp=0; tmp< MAX_FINGER_NUM; tmp++)
+		{
+		//printk("tmp=%d\n", tmp);
+		input_mt_slot(ts->input_dev, tmp);//?		//input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+		}
+		//input_mt_sync(ts->input_dev);
+	}
+	
+	//input_report_key(ts->input_dev, BTN_TOUCH, finger > 0);
+	input_sync(ts->input_dev);
+
+#ifdef HAVE_TOUCH_KEY
+	key = point_data[3]&0x0F;
+	if((last_key != 0)||(key != 0))
+	{
+		for(count = 0; count < MAX_KEY_NUM; count++)
+		{
+      //printk("####################input_report_key++++++++++++%d\n",key);
+			input_report_key(ts->input_dev, touch_key_array[count], !!(key&(0x01<<count)));	
+		}
+	}		
+	last_key = key;	
+#endif
+
+XFER_ERROR:
+WORK_FUNC_END:
+#ifndef STOP_IRQ_TYPE
+	if(ts->use_irq)
+		gt811_irq_enable(ts);     //KT ADD 1202
+#endif
+}
+
+/*******************************************************	
+Function:
+	Response function timer
+	Triggered by a timer, scheduling the work function of the touch screen operation; after re-timing
+Parameters:
+	timer: the timer function is associated
+return:
+	Timer mode, HRTIMER_NORESTART that do not automatically restart
+********************************************************/
+static enum hrtimer_restart goodix_ts_timer_func(struct hrtimer *timer)
+{
+	struct gt811_ts_data *ts = container_of(timer, struct gt811_ts_data, timer);
+	queue_work(goodix_wq, &ts->work);
+	hrtimer_start(&ts->timer, ktime_set(0, (POLL_TIME+6)*1000000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+/*******************************************************	
+Function:
+	Interrupt response function
+	Triggered by an interrupt, the scheduler runs the touch screen handler
+********************************************************/
+static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
+{
+	struct gt811_ts_data *ts = dev_id;
+
+#ifndef STOP_IRQ_TYPE
+	gt811_irq_disable(ts);     //KT ADD 1202
+#endif
+	//disable_irq_nosync(ts->client->irq);
+	queue_work(goodix_wq, &ts->work);
+	
+	return IRQ_HANDLED;
+}
+
+/*******************************************************	
+Function:
+	Power management gt811, gt811 allowed to sleep or to wake up
+Parameters:
+	on: 0 that enable sleep, wake up 1
+return:
+	Is set successfully, 0 for success
+	Error code: -1 for the i2c error, -2 for the GPIO error;-EINVAL on error as a parameter
+********************************************************/
+static int goodix_ts_power(struct gt811_ts_data * ts, int on)
+{
+	int ret = -1;
+
+	unsigned char i2c_control_buf[3] = {0x06,0x92,0x01};		//suspend cmd
+	
+#ifdef INT_PORT	
+	if(ts != NULL && !ts->use_irq)
+		return -2;
+#endif		
+	switch(on)
+	{
+		case 0:
+			ret = i2c_write_bytes(ts->client, i2c_control_buf, 3);
+            printk("ret++++++++++++++++= %d=\n",ret);
+			dev_info(&ts->client->dev, "Send suspend cmd\n");
+			if(ret < 0)						//failed
+				ret = 0;
+			return ret;
+			
+		case 1:
+			gpio_direction_output(SHUTDOWN_PORT,0);
+			msleep(1);
+	    gpio_set_value(SHUTDOWN_PORT,0);
+	    msleep(100);
+	    gpio_set_value(SHUTDOWN_PORT,1);
+	    msleep(100);
+			ret = 0;
+			return ret;
+				
+		default:
+			dev_info(&ts->client->dev, "%s: Cant't support this command.", s3c_ts_name);
+			return -EINVAL;
+	}
+
+}
+/*******************************************************	
+Function:
+	Touch-screen detection function
+	Called when the registration drive (required for a corresponding client);
+	For IO, interrupts and other resources to apply; equipment registration; touch screen initialization, etc.
+Parameters:
+	client: the device structure to be driven
+	id: device ID
+return:
+	Results of the implementation code, 0 for normal execution
+********************************************************/
+static int goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret = 0;
+	int retry=0;
+        char test_data = 1;
+		char buf[2]={0};   //w++
+	unsigned char read_data[2] = {0,0 };        
+	const char irq_table[2] = {IRQF_TRIGGER_FALLING,IRQF_TRIGGER_RISING};
+	struct gt811_ts_data *ts;
+ //   struct gt811_platform_data *811data = client->dev.platform_data;
+	struct gt811_platform_data *pdata;
+	dev_info(&client->dev,"Install gt811 driver.\n");
+	dev_info(&client->dev,"Driver Release Date:2012-02-08\n");	
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) 
+	{
+		dev_err(&client->dev, "Must have I2C_FUNC_I2C.\n");
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+#if 0	
+	ret=i2c_read_bytes(client, read_data, sizeof(read_data)/sizeof(read_data[0]));
+	if(ret <= 0)  
+		{
+	dev_err(&client->dev, "Must have GT811.\n");
+	goto err_check_functionality_failed;	
+		}
+#endif	
+	
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	i2c_connect_client = client;
+	
+	gpio_free(SHUTDOWN_PORT);
+	ret = gpio_request(SHUTDOWN_PORT, "RESET_INT");
+	if (ret < 0)
+        {
+		dev_err(&client->dev, "Failed to request RESET GPIO:%d, ERRNO:%d\n",(int)SHUTDOWN_PORT,ret);
+		goto err_gpio_request;
+	}
+	
+	rk29_mux_api_set(GPIO0D3_PWM_1_NAME,GPIO0D_GPIO0D3);
+	 gpio_pull_updown(SHUTDOWN_PORT, 1);		//set GPIO pull-up
+	
+	for(retry=0;retry <= 10; retry++)
+	{
+	gpio_direction_output(SHUTDOWN_PORT,0);
+	msleep(1);
+	//		gpio_direction_input(SHUTDOWN_PORT);//setinput means not ack so set the reset high
+	//		msleep(100);
+	gpio_set_value(SHUTDOWN_PORT,1);
+	msleep(100);
+	gpio_set_value(SHUTDOWN_PORT,0);
+	msleep(100);
+	gpio_set_value(SHUTDOWN_PORT,1);
+	msleep(100);
+	int val_ret = 1;
+	val_ret = gpio_get_value(SHUTDOWN_PORT);
+    ret = i2c_write_bytes(client, &test_data, 1);
+	//ret =i2c_master_reg8_recv(client, 0x00, buf, 2, 200*1000);//i2c_write_bytes(client, &test_data, 1);	//Test I2C connection.
+	if (ret == 1)
+	break;
+	dev_info(&client->dev, "GT811 I2C TEST FAILED!Please check the HARDWARE connect\n");
+	}
+
+	if(ret <= 0)
+	{
+		dev_err(&client->dev, "Warnning: I2C communication might be ERROR!\n");
+		goto err_i2c_failed;
+	}	
+
+	INIT_WORK(&ts->work, goodix_ts_work_func);		//init work_struct
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+	pdata = client->dev.platform_data;
+/////////////////////////////// UPDATE STEP 1 START/////////////////////////////////////////////////////////////////
+#ifdef AUTO_UPDATE_GT811		//modify by andrew
+	msleep(20);
+  goodix_read_version(ts);
+      
+  ret = gt811_downloader( ts, goodix_gt811_firmware);
+  if(ret < 0)
+  {
+          dev_err(&client->dev, "Warnning: gt811 update might be ERROR!\n");
+          //goto err_input_dev_alloc_failed;
+  }
+#endif
+///////////////////////////////UPDATE STEP 1 END////////////////////////////////////////////////////////////////      
+#ifdef INT_PORT	
+	client->irq=TS_INT;		//If not defined in client
+	if (client->irq)
+	{
+		gpio_free(INT_PORT);
+		ret = gpio_request(INT_PORT, "TS_INT");	//Request IO
+        if (ret < 0) 
+		{
+			dev_err(&client->dev, "Failed to request GPIO:%d, ERRNO:%d\n",(int)INT_PORT,ret);
+			goto err_gpio_request_failed;
+		}
+		
+		 gpio_pull_updown(INT_PORT, NULL);	//ret > 0 ?
+		
+	
+	#ifndef STOP_IRQ_TYPE
+		ts->irq = TS_INT;     //KT ADD 1202
+		ts->irq_is_disable = 0;           // enable irq
+	#endif	
+	}
+#endif	
+
+err_gpio_request_failed:
+	for(retry=0; retry<3; retry++)
+	{
+		ret=goodix_init_panel(ts);
+		msleep(2);
+		if(ret != 0)	//Initiall failed
+			continue;
+		else
+			break;
+	}
+	if(ret != 0) 
+	{
+		ts->bad_data=1;
+		goto err_init_godix_ts;
+	}
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) 
+	{
+		ret = -ENOMEM;
+		dev_dbg(&client->dev,"goodix_ts_probe: Failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+	
+	//ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
+	//ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	//////ts->input_dev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+#ifdef HAVE_TOUCH_KEY
+	for(retry = 0; retry < MAX_KEY_NUM; retry++)
+	{
+		input_set_capability(ts->input_dev,EV_KEY,touch_key_array[retry]);	
+	}
+#endif
+/*
+	input_set_abs_params(ts->input_dev, ABS_X, 0,  ts->abs_x_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0, ts->abs_y_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+*/	
+#ifdef GOODIX_MULTI_TOUCH
+
+	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+	__set_bit(EV_ABS, ts->input_dev->evbit);
+	
+	input_mt_init_slots(ts->input_dev, ts->max_touch_num);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max, 0, 0);	
+	
+	
+#endif	
+
+	sprintf(ts->phys, "input/ts");
+	ts->input_dev->name = s3c_ts_name;
+	ts->input_dev->phys = ts->phys;
+	ts->input_dev->id.bustype = BUS_I2C;
+	ts->input_dev->id.vendor = 0xDEAD;
+	ts->input_dev->id.product = 0xBEEF;
+	ts->input_dev->id.version = 10427;	//screen firmware version
+	
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		dev_err(&client->dev,"Probe: Unable to register %s input device\n", ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+	ts->bad_data = 0;
+
+#ifdef INT_PORT		
+	ret  = request_irq(TS_INT, goodix_ts_irq_handler ,irq_table[ts->int_trigger_type],
+			client->name, ts);
+	if (ret != 0)
+	{
+		dev_err(&client->dev,"Cannot allocate ts INT!ERRNO:%d\n", ret);
+		gpio_direction_input(INT_PORT);
+		gpio_free(INT_PORT);
+		goto err_init_godix_ts;
+	}
+	else 
+	{	
+	#ifndef STOP_IRQ_TYPE
+		gt811_irq_disable(ts);     //KT ADD 1202
+	//#define
+	//	disable_irq(client->irq);
+	#endif
+		ts->use_irq = 1;
+		dev_dbg(&client->dev,"Reques EIRQ %d succesd on GPIO:%d\n",TS_INT,INT_PORT);
+	}	
+#endif	
+
+	
+	if (!ts->use_irq) 
+	{
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = goodix_ts_timer_func;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+	}
+	
+	if(ts->use_irq)
+	#ifndef STOP_IRQ_TYPE
+		gt811_irq_enable(ts);     //KT ADD 1202
+	//#elif
+	//	enable_irq(client->irq);
+	#endif
+		
+	ts->power = goodix_ts_power;
+
+	goodix_read_version(ts);
+	
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB;//EARLY_SUSPEND_LEVEL_BLANK_SCREEN +1;
+	ts->early_suspend.suspend = goodix_ts_early_suspend;
+	ts->early_suspend.resume = goodix_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+/////////////////////////////// UPDATE STEP 2 START /////////////////////////////////////////////////////////////////
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+	goodix_proc_entry = create_proc_entry("goodix-update", 0666, NULL);
+	if(goodix_proc_entry == NULL)
+	{
+		dev_info(&client->dev, "Couldn't create proc entry!\n");
+		ret = -ENOMEM;
+		goto err_create_proc_entry;
+	}
+	else
+	{
+		dev_info(&client->dev, "Create proc entry success!\n");
+		goodix_proc_entry->write_proc = goodix_update_write;
+		goodix_proc_entry->read_proc = goodix_update_read;
+	}
+#endif
+///////////////////////////////UPDATE STEP 2 END /////////////////////////////////////////////////////////////////
+	dev_info(&client->dev,"Start %s in %s mode,Driver Modify Date:2012-01-05\n", 
+		ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");
+	return 0;
+
+err_init_godix_ts:
+	i2c_end_cmd(ts);
+	if(ts->use_irq)
+	{
+		ts->use_irq = 0;
+		free_irq(client->irq,ts);
+	#ifdef INT_PORT	
+		gpio_direction_input(INT_PORT);
+		gpio_free(INT_PORT);
+	#endif	
+	}
+	else 
+		hrtimer_cancel(&ts->timer);
+
+err_input_register_device_failed:
+	input_free_device(ts->input_dev);
+
+err_input_dev_alloc_failed:
+	i2c_set_clientdata(client, NULL);
+err_gpio_request:
+	gpio_free(SHUTDOWN_PORT);
+err_i2c_failed:	
+	kfree(ts);	
+err_alloc_data_failed:
+err_check_functionality_failed:
+err_create_proc_entry:
+	return ret;
+}
+
+
+/*******************************************************	
+Function:
+	Drive the release of resources
+Parameters:
+	client: the device structure
+return:
+	Results of the implementation code, 0 for normal execution
+********************************************************/
+static int goodix_ts_remove(struct i2c_client *client)
+{
+	struct gt811_ts_data *ts = i2c_get_clientdata(client);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+/////////////////////////////// UPDATE STEP 3 START/////////////////////////////////////////////////////////////////
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+	remove_proc_entry("goodix-update", NULL);
+#endif
+/////////////////////////////////UPDATE STEP 3 END///////////////////////////////////////////////////////////////
+
+	if (ts && ts->use_irq) 
+	{
+	#ifdef INT_PORT
+		gpio_direction_input(INT_PORT);
+		gpio_free(INT_PORT);
+	#endif	
+		free_irq(client->irq, ts);
+	}	
+	else if(ts)
+		hrtimer_cancel(&ts->timer);
+	
+	dev_notice(&client->dev,"The driver is removing...\n");
+	i2c_set_clientdata(client, NULL);
+	input_unregister_device(ts->input_dev);
+	kfree(ts);
+	return 0;
+}
+
+//
+static int goodix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct gt811_ts_data *ts = i2c_get_clientdata(client);
+	disable_irq(client->irq);
+	if (ts->power) 
+	{	
+	}
+}
+static int goodix_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct gt811_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->power) {
+		ret = ts->power(ts, 1);
+		printk("resume >>>>>>>>>ret=%d",ret);
+		if (ret < 0)
+		printk(KERN_ERR "goodix_ts_resume power on failed\n");
+	}
+ 	enable_irq(client->irq);
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void goodix_ts_early_suspend(struct early_suspend *h)
+{
+	struct gt811_ts_data *ts;
+	ts = container_of(h, struct gt811_ts_data, early_suspend);
+	goodix_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void goodix_ts_late_resume(struct early_suspend *h)
+{
+	struct gt811_ts_data *ts;
+	ts = container_of(h, struct gt811_ts_data, early_suspend);
+	goodix_ts_resume(ts->client);
+}
+#endif
+/////////////////////////////// UPDATE STEP 4 START/////////////////////////////////////////////////////////////////
+//******************************Begin of firmware update surpport*******************************
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+static struct file * update_file_open(char * path, mm_segment_t * old_fs_p)
+{
+	struct file * filp = NULL;
+	int errno = -1;
+		
+	filp = filp_open(path, O_RDONLY, 0644);
+	
+	if(!filp || IS_ERR(filp))
+	{
+		if(!filp)
+			errno = -ENOENT;
+		else 
+			errno = PTR_ERR(filp);					
+		printk(KERN_ERR "The update file for Guitar open error.\n");
+		return NULL;
+	}
+	*old_fs_p = get_fs();
+	set_fs(get_ds());
+
+	filp->f_op->llseek(filp,0,0);
+	return filp ;
+}
+
+static void update_file_close(struct file * filp, mm_segment_t old_fs)
+{
+	set_fs(old_fs);
+	if(filp)
+		filp_close(filp, NULL);
+}
+static int update_get_flen(char * path)
+{
+	struct file * file_ck = NULL;
+	mm_segment_t old_fs;
+	int length ;
+	
+	file_ck = update_file_open(path, &old_fs);
+	if(file_ck == NULL)
+		return 0;
+
+	length = file_ck->f_op->llseek(file_ck, 0, SEEK_END);
+	//printk("File length: %d\n", length);
+	if(length < 0)
+		length = 0;
+	update_file_close(file_ck, old_fs);
+	return length;	
+}
+
+static int goodix_update_write(struct file *filp, const char __user *buff, unsigned long len, void *data)
+{
+	unsigned char cmd[120];
+	int ret = -1;
+        int retry = 0;
+	static unsigned char update_path[60];
+	struct gt811_ts_data *ts;
+	struct file * file_data = NULL;
+    	mm_segment_t old_fs;
+	unsigned char *file_ptr = NULL;
+	unsigned int file_len;
+	
+	ts = i2c_get_clientdata(i2c_connect_client);
+	if(ts==NULL)
+	{
+            printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+		return 0;
+	}
+	
+	//printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+	if(copy_from_user(&cmd, buff, len))
+	{
+            printk(KERN_INFO"goodix write to kernel via proc file!@@@@@@\n");
+		return -EFAULT;
+	}
+	//printk(KERN_INFO"Write cmd is:%d,write len is:%ld\n",cmd[0], len);
+	switch(cmd[0])
+	{
+            case APK_UPDATE_TP:
+            printk(KERN_INFO"Write cmd is:%d,cmd arg is:%s,write len is:%ld\n",cmd[0], &cmd[1], len);
+            memset(update_path, 0, 60);
+            strncpy(update_path, cmd+1, 60);
+			
+#ifndef STOP_IRQ_TYPE
+		gt811_irq_disable(ts);     //KT ADD 1202
+//#elif
+//		disable_irq(ts->client->irq);
+#endif
+	file_data = update_file_open(update_path, &old_fs);
+        if(file_data == NULL)   //file_data has been opened at the last time
+        {
+		dev_info(&ts->client->dev, "cannot open update file\n");
+		return 0;
+        }
+
+        file_len = update_get_flen(update_path);
+	dev_info(&ts->client->dev, "Update file length:%d\n", file_len);
+	file_ptr = (unsigned char*)vmalloc(file_len);
+	if(file_ptr==NULL)
+	{
+		dev_info(&ts->client->dev, "cannot malloc memory!\n");
+		return 0;
+	}	
+
+        ret = file_data->f_op->read(file_data, file_ptr, file_len, &file_data->f_pos);
+        if(ret <= 0)
+        {
+		dev_info(&ts->client->dev, "read file data failed\n");
+		return 0;
+        }
+        update_file_close(file_data, old_fs);	
+
+        ret = gt811_downloader(ts, file_ptr);
+        vfree(file_ptr);
+	if(ret < 0)
+        {
+                printk(KERN_INFO"Warnning: GT811 update might be ERROR!\n");
+                return 0;
+        }
+             
+ //       i2c_pre_cmd(ts);
+	
+	gpio_direction_output(SHUTDOWN_PORT, 0);
+        msleep(5);
+        gpio_direction_input(SHUTDOWN_PORT);
+	msleep(20);
+	for(retry=0; retry<3; retry++)
+	{
+		ret=goodix_init_panel(ts);
+		msleep(2);
+		if(ret != 0)	//Initiall failed
+		{
+			dev_info(&ts->client->dev, "Init panel failed!\n");
+			continue;
+		}
+		else
+			break;
+		
+	}
+
+   //     s3c_gpio_cfgpin(INT_PORT, INT_CFG);     //Set IO port function 
+	//gpio_direction_input(INT_PORT);
+//	s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_UP); 
+//        s3c_gpio_cfgpin(INT_PORT, INT_CFG);	//Set IO port as interrupt port	
+	//s3c_gpio_setpull(INT_PORT, S3C_GPIO_PULL_NONE);
+//	while(1);		
+#ifndef STOP_IRQ_TYPE
+	gt811_irq_enable(ts);     //KT ADD 1202
+//#elif
+//	enable_irq(ts->client->irq);
+#endif   
+//        i2c_end_cmd(ts);
+        return 1;
+    
+    case APK_READ_FUN:							//functional command
+		if(cmd[1] == CMD_READ_VER)
+		{
+			printk(KERN_INFO"Read version!\n");
+			ts->read_mode = MODE_RD_VER;
+		}
+        else if(cmd[1] == CMD_READ_CFG)
+		{
+			printk(KERN_INFO"Read config info!\n");
+
+			ts->read_mode = MODE_RD_CFG;
+		}
+		else if (cmd[1] == CMD_READ_RAW)
+		{
+		    printk(KERN_INFO"Read raw data!\n");
+
+			ts->read_mode = MODE_RD_RAW;
+		}
+        else if (cmd[1] == CMD_READ_CHIP_TYPE)
+		{
+		    printk(KERN_INFO"Read chip type!\n");
+
+			ts->read_mode = MODE_RD_CHIP_TYPE;
+		}
+        return 1;
+        
+    case APK_WRITE_CFG:			
+		printk(KERN_INFO"Begin write config info!Config length:%d\n",cmd[1]);
+		i2c_pre_cmd(ts);
+        ret = i2c_write_bytes(ts->client, cmd+2, cmd[1]+2); 
+        i2c_end_cmd(ts);
+        if(ret != 1)
+        {
+            printk("Write Config failed!return:%d\n",ret);
+            return -1;
+        }
+        return 1;
+            
+    default:
+	    return 0;
+	}
+	return 0;
+}
+
+static int goodix_update_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int ret = -1;
+    	int len = 0;
+    	int read_times = 0;
+	struct gt811_ts_data *ts;
+
+	unsigned char read_data[360] = {80, };
+
+	ts = i2c_get_clientdata(i2c_connect_client);
+	if(ts==NULL)
+		return 0;
+    
+       	printk("___READ__\n");
+	if(ts->read_mode == MODE_RD_VER)		//read version data
+	{
+		i2c_pre_cmd(ts);
+		ret = goodix_read_version(ts);
+             	i2c_end_cmd(ts);
+		if(ret < 0)
+		{
+			printk(KERN_INFO"Read version data failed!\n");
+			return 0;
+		}
+        
+             	read_data[1] = (char)(ts->version&0xff);
+             	read_data[0] = (char)((ts->version>>8)&0xff);
+
+		memcpy(page, read_data, 2);
+		//*eof = 1;
+		return 2;
+	}
+    else if (ts->read_mode == MODE_RD_CHIP_TYPE)
+    {
+        page[0] = GT811;
+        return 1;
+    }
+    else if(ts->read_mode == MODE_RD_CFG)
+	{
+
+            read_data[0] = 0x06;
+            read_data[1] = 0xa2;       // cfg start address
+            printk("read config addr is:%x,%x\n", read_data[0],read_data[1]);
+
+	     len = 106;
+           i2c_pre_cmd(ts);
+	     ret = i2c_read_bytes(ts->client, read_data, len+2);
+            i2c_end_cmd(ts);
+            if(ret <= 0)
+		{
+			printk(KERN_INFO"Read config info failed!\n");
+			return 0;
+		}
+              
+		memcpy(page, read_data+2, len);
+		return len;
+	}
+	else if (ts->read_mode == MODE_RD_RAW)
+	{
+#define TIMEOUT (-100)
+	    int retry = 0;
+        if (raw_data_ready != RAW_DATA_READY)
+        {
+            raw_data_ready = RAW_DATA_ACTIVE;
+        }
+
+RETRY:
+        read_data[0] = 0x07;
+        read_data[1] = 0x11;
+        read_data[2] = 0x01;
+        
+        ret = i2c_write_bytes(ts->client, read_data, 3);
+        
+#ifdef DEBUG
+        sum += read_times;
+        printk("count :%d\n", ++access_count);
+        printk("A total of try times:%d\n", sum);
+#endif
+               
+        read_times = 0;
+	    while (RAW_DATA_READY != raw_data_ready)
+	    {
+	        msleep(4);
+
+	        if (read_times++ > 10)
+	        {
+    	        if (retry++ > 5)
+    	        {
+    	            return TIMEOUT;
+    	        }
+                goto RETRY;
+	        }
+	    }
+#ifdef DEBUG	    
+        printk("read times:%d\n", read_times);
+#endif	    
+        read_data[0] = 0x08;
+        read_data[1] = 0x80;       // raw data address
+        
+	    len = 160;
+
+	   // msleep(4);
+
+        i2c_pre_cmd(ts);
+	    ret = i2c_read_bytes(ts->client, read_data, len+2);    	    
+  //      i2c_end_cmd(ts);
+        
+        if(ret <= 0)
+		{
+			printk(KERN_INFO"Read raw data failed!\n");
+			return 0;
+		}
+		memcpy(page, read_data+2, len);
+
+		read_data[0] = 0x09;
+        read_data[1] = 0xC0;
+	//	i2c_pre_cmd(ts);
+	    ret = i2c_read_bytes(ts->client, read_data, len+2);    	    
+        i2c_end_cmd(ts);
+        
+        if(ret <= 0)
+		{
+			printk(KERN_INFO"Read raw data failed!\n");
+			return 0;
+		}
+		memcpy(&page[160], read_data+2, len);
+
+#ifdef DEBUG
+//**************
+        for (i = 0; i < 300; i++)
+        {
+            printk("%6x", page[i]);
+
+            if ((i+1) % 10 == 0)
+            {
+                printk("\n");
+            }
+        }
+//********************/  
+#endif
+        raw_data_ready = RAW_DATA_NON_ACTIVE;
+    
+		return (2*len);   
+		
+    }
+	return 0;
+#endif
+}             
+//********************************************************************************************
+static u8  is_equal( u8 *src , u8 *dst , int len )
+{
+    int i;
+
+#if 0    
+    for( i = 0 ; i < len ; i++ )
+    {
+        printk(KERN_INFO"[%02X:%02X]", src[i], dst[i]);
+       if((i+1)%10==0)printk("\n");
+    }
+#endif
+
+    for( i = 0 ; i < len ; i++ )
+    {
+        if ( src[i] != dst[i] )
+        {
+            return 0;
+        }
+    }
+    
+    return 1;
+}
+
+static  u8 gt811_nvram_store( struct gt811_ts_data *ts )
+{
+    int ret;
+    int i;
+    u8 inbuf[3] = {REG_NVRCS_H,REG_NVRCS_L,0};
+    //u8 outbuf[3] = {};
+    ret = i2c_read_bytes( ts->client, inbuf, 3 );
+    
+    if ( ret < 0 )
+    {
+        return 0;
+    }
+    
+    if ( ( inbuf[2] & BIT_NVRAM_LOCK ) == BIT_NVRAM_LOCK )
+    {
+        return 0;
+    }
+    
+    inbuf[2] = (1<<BIT_NVRAM_STROE);		//store command
+	    
+    for ( i = 0 ; i < 300 ; i++ )
+    {
+        ret = i2c_write_bytes( ts->client, inbuf, 3 );
+        
+        if ( ret < 0 )
+            break;
+    }
+    
+    return ret;
+}
+
+static u8  gt811_nvram_recall( struct gt811_ts_data *ts )
+{
+    int ret;
+    u8 inbuf[3] = {REG_NVRCS_H,REG_NVRCS_L,0};
+    
+    ret = i2c_read_bytes( ts->client, inbuf, 3 );
+    
+    if ( ret < 0 )
+    {
+        return 0;
+    }
+    
+    if ( ( inbuf[2]&BIT_NVRAM_LOCK) == BIT_NVRAM_LOCK )
+    {
+        return 0;
+    }
+    
+    inbuf[2] = ( 1 << BIT_NVRAM_RECALL );		//recall command
+    ret = i2c_write_bytes( ts->client , inbuf, 3);
+    return ret;
+}
+
+static  int gt811_reset( struct gt811_ts_data *ts )
+{
+    int ret = 1;
+    u8 retry;
+    
+    unsigned char outbuf[3] = {0,0xff,0};
+    unsigned char inbuf[3] = {0,0xff,0};
+    //outbuf[1] = 1;
+
+    gpio_direction_output(SHUTDOWN_PORT,0);
+    msleep(20);
+    gpio_direction_input(SHUTDOWN_PORT);
+    msleep(100);
+    for(retry=0;retry < 80; retry++)
+    {
+        ret =i2c_write_bytes(ts->client, inbuf, 0);	//Test I2C connection.
+        if (ret > 0)
+        {
+            msleep(10);
+            ret =i2c_read_bytes(ts->client, inbuf, 3);	//Test I2C connection.
+            if (ret > 0)
+            {
+                if(inbuf[2] == 0x55)
+                {
+			ret =i2c_write_bytes(ts->client, outbuf, 3);
+			msleep(10);
+			break;						
+		}
+	    }			
+	}
+	else
+	{
+		gpio_direction_output(SHUTDOWN_PORT,0);
+		msleep(20);
+		gpio_direction_input(SHUTDOWN_PORT);
+		msleep(20);
+		dev_info(&ts->client->dev, "i2c address failed\n");
+	}	
+		
+    }
+    dev_info(&ts->client->dev, "Detect address %0X\n", ts->client->addr);
+    //msleep(500);
+    return ret;	
+}
+
+static  int gt811_reset2( struct gt811_ts_data *ts )
+{
+    int ret = 1;
+    u8 retry;
+    
+    //unsigned char outbuf[3] = {0,0xff,0};
+    unsigned char inbuf[3] = {0,0xff,0};
+    //outbuf[1] = 1;
+
+    gpio_direction_output(SHUTDOWN_PORT,0);
+    msleep(20);
+    gpio_direction_input(SHUTDOWN_PORT);
+    msleep(100);
+    for(retry=0;retry < 80; retry++)
+    {
+        ret =i2c_write_bytes(ts->client, inbuf, 0);	//Test I2C connection.
+        if (ret > 0)
+        {
+            msleep(10);
+            ret =i2c_read_bytes(ts->client, inbuf, 3);	//Test I2C connection.
+            if (ret > 0)
+            {
+             //   if(inbuf[2] == 0x55)
+             //       {
+		//	    ret =i2c_write_bytes(ts->client, outbuf, 3);
+		//	    msleep(10);
+			    break;						
+	//		}
+				}			
+			}	
+		
+		}
+    dev_info(&ts->client->dev, "Detect address %0X\n", ts->client->addr);
+    //msleep(500);
+    return ret;	
+}
+static  int gt811_set_address_2( struct gt811_ts_data *ts )
+{
+    unsigned char inbuf[3] = {0,0,0};
+    int i;
+
+    for ( i = 0 ; i < 12 ; i++ )
+    {
+        if ( i2c_read_bytes( ts->client, inbuf, 3) )
+        {
+            dev_info(&ts->client->dev, "Got response\n");
+            return 1;
+        }
+        dev_info(&ts->client->dev, "wait for retry\n");
+        msleep(50);
+    } 
+    return 0;
+}
+static u8  gt811_update_firmware( u8 *nvram, u16 start_addr, u16 length, struct gt811_ts_data *ts)
+{
+    u8 ret,err,retry_time,i;
+    u16 cur_code_addr;
+    u16 cur_frame_num, total_frame_num, cur_frame_len;
+    u32 gt80x_update_rate;
+
+    unsigned char i2c_data_buf[PACK_SIZE+2] = {0,};
+    unsigned char i2c_chk_data_buf[PACK_SIZE+2] = {0,};
+    
+    if( length > NVRAM_LEN - NVRAM_BOOT_SECTOR_LEN )
+    {
+        dev_info(&ts->client->dev, "Fw length %d is bigger than limited length %d\n", length, NVRAM_LEN - NVRAM_BOOT_SECTOR_LEN );
+        return 0;
+    }
+    	
+    total_frame_num = ( length + PACK_SIZE - 1) / PACK_SIZE;  
+
+    //gt80x_update_sta = _UPDATING;
+    gt80x_update_rate = 0;
+
+    for( cur_frame_num = 0 ; cur_frame_num < total_frame_num ; cur_frame_num++ )	  
+    {
+        retry_time = 5;
+       
+	dev_info(&ts->client->dev, "PACK[%d]\n",cur_frame_num); 
+        cur_code_addr = /*NVRAM_UPDATE_START_ADDR*/start_addr + cur_frame_num * PACK_SIZE; 	
+        i2c_data_buf[0] = (cur_code_addr>>8)&0xff;
+        i2c_data_buf[1] = cur_code_addr&0xff;
+        
+        i2c_chk_data_buf[0] = i2c_data_buf[0];
+        i2c_chk_data_buf[1] = i2c_data_buf[1];
+        
+        if( cur_frame_num == total_frame_num - 1 )
+        {
+            cur_frame_len = length - cur_frame_num * PACK_SIZE;
+        }
+        else
+        {
+            cur_frame_len = PACK_SIZE;
+        }
+        
+        //strncpy(&i2c_data_buf[2], &nvram[cur_frame_num*PACK_SIZE], cur_frame_len);
+        for(i=0;i<cur_frame_len;i++)
+        {
+            i2c_data_buf[2+i] = nvram[cur_frame_num*PACK_SIZE+i];
+        }
+        do
+        {
+            err = 0;
+
+            //ret = gt811_i2c_write( guitar_i2c_address, cur_code_addr, &nvram[cur_frame_num*I2C_FRAME_MAX_LENGTH], cur_frame_len );		
+	    ret = i2c_write_bytes(ts->client, i2c_data_buf, (cur_frame_len+2));
+            if ( ret <= 0 )
+            {
+                dev_info(&ts->client->dev, "write fail\n");
+                err = 1;
+            }
+            
+            ret = i2c_read_bytes(ts->client, i2c_chk_data_buf, (cur_frame_len+2));
+            // ret = gt811_i2c_read( guitar_i2c_address, cur_code_addr, inbuf, cur_frame_len);
+            if ( ret <= 0 )
+            {
+                dev_info(&ts->client->dev, "read fail\n");
+                err = 1;
+            }
+	    
+            if( is_equal( &i2c_data_buf[2], &i2c_chk_data_buf[2], cur_frame_len ) == 0 )
+            {
+                dev_info(&ts->client->dev, "not equal\n");
+                err = 1;
+            }
+			
+        } while ( err == 1 && (--retry_time) > 0 );
+        
+        if( err == 1 )
+        {
+            break;
+        }
+		
+        gt80x_update_rate = ( cur_frame_num + 1 )*128/total_frame_num;
+    
+    }
+
+    if( err == 1 )
+    {
+        dev_info(&ts->client->dev, "write nvram fail\n");
+        return 0;
+    }
+    
+    ret = gt811_nvram_store(ts);
+    
+    msleep( 20 );
+
+    if( ret == 0 )
+    {
+        dev_info(&ts->client->dev, "nvram store fail\n");
+        return 0;
+    }
+    
+    ret = gt811_nvram_recall(ts);
+
+    msleep( 20 );
+    
+    if( ret == 0 )
+    {
+        dev_info(&ts->client->dev, "nvram recall fail\n");
+        return 0;
+    }
+
+    for ( cur_frame_num = 0 ; cur_frame_num < total_frame_num ; cur_frame_num++ )		 //	read out all the code
+    {
+
+        cur_code_addr = NVRAM_UPDATE_START_ADDR + cur_frame_num*PACK_SIZE;
+        retry_time=5;
+        i2c_chk_data_buf[0] = (cur_code_addr>>8)&0xff;
+        i2c_chk_data_buf[1] = cur_code_addr&0xff;
+        
+        
+        if ( cur_frame_num == total_frame_num-1 )
+        {
+            cur_frame_len = length - cur_frame_num*PACK_SIZE;
+        }
+        else
+        {
+            cur_frame_len = PACK_SIZE;
+        }
+        
+        do
+        {
+            err = 0;
+            //ret = gt811_i2c_read( guitar_i2c_address, cur_code_addr, inbuf, cur_frame_len);
+            ret = i2c_read_bytes(ts->client, i2c_chk_data_buf, (cur_frame_len+2));
+
+            if ( ret == 0 )
+            {
+                err = 1;
+            }
+            
+            if( is_equal( &nvram[cur_frame_num*PACK_SIZE], &i2c_chk_data_buf[2], cur_frame_len ) == 0 )
+            {
+                err = 1;
+            }
+        } while ( err == 1 && (--retry_time) > 0 );
+        
+        if( err == 1 )
+        {
+            break;
+        }
+        
+        gt80x_update_rate = 127 + ( cur_frame_num + 1 )*128/total_frame_num;
+    }
+    
+    gt80x_update_rate = 255;
+    //gt80x_update_sta = _UPDATECHKCODE;
+
+    if( err == 1 )
+    {
+        dev_info(&ts->client->dev, "nvram validate fail\n");
+        return 0;
+    }
+    
+    return 1;
+}
+
+static u8  gt811_update_proc( u8 *nvram, u16 start_addr , u16 length, struct gt811_ts_data *ts )
+{
+    u8 ret;
+    u8 error = 0;
+    //struct tpd_info_t tpd_info;
+    GT811_SET_INT_PIN( 0 );
+    msleep( 20 );
+    ret = gt811_reset(ts);
+    if ( ret < 0 )
+    {
+        error = 1;
+        dev_info(&ts->client->dev, "reset fail\n");
+        goto end;
+    }
+
+    ret = gt811_set_address_2( ts );
+    if ( ret == 0 )
+    {
+        error = 1;
+        dev_info(&ts->client->dev, "set address fail\n");
+        goto end;
+    }
+
+    ret = gt811_update_firmware( nvram, start_addr, length, ts);
+    if ( ret == 0 )
+    {
+        error=1;
+       	dev_info(&ts->client->dev, "firmware update fail\n");
+        goto end;
+    }
+
+end:
+    GT811_SET_INT_PIN( 1 );
+//    gpio_free(INT_PORT);
+    gpio_pull_updown(INT_PORT, NULL);
+    
+    msleep( 500 );
+    ret = gt811_reset2(ts);
+    if ( ret < 0 )
+    {
+        error=1;
+        dev_info(&ts->client->dev, "final reset fail\n");
+        goto end;
+    }
+    if ( error == 1 )
+    {
+        return 0; 
+    }
+	
+//    i2c_pre_cmd(ts);
+    while(goodix_read_version(ts)<0);
+    
+//    i2c_end_cmd(ts);
+    return 1;
+}
+
+u16 Little2BigEndian(u16 little_endian)
+{
+	u16 temp = 0;
+	temp = little_endian&0xff;
+	return (temp<<8)+((little_endian>>8)&0xff);
+}
+
+int  gt811_downloader( struct gt811_ts_data *ts,  unsigned char * data)
+{
+    struct tpd_firmware_info_t *fw_info = (struct tpd_firmware_info_t *)data;
+    //int i;
+    //unsigned short checksum = 0;
+    //unsigned int  checksum = 0;
+    unsigned int  fw_checksum = 0;
+    //unsigned char fw_chip_type;
+    unsigned short fw_version;
+    unsigned short fw_start_addr;
+    unsigned short fw_length;
+    unsigned char *data_ptr;
+    //unsigned char *file_ptr = &(fw_info->chip_type);
+    int retry = 0,ret;
+    int err = 0;
+    unsigned char rd_buf[4] = {0};
+    unsigned char *mandatory_base = "GOODIX";
+    unsigned char rd_rom_version;
+    unsigned char rd_chip_type;
+    unsigned char rd_nvram_flag;
+
+    //struct file * file_data = NULL;
+    //mm_segment_t old_fs;
+    //unsigned int rd_len;
+    //unsigned int file_len = 0;
+    //unsigned char i2c_data_buf[PACK_SIZE] = {0,};
+    
+    rd_buf[0]=0x14;
+    rd_buf[1]=0x00;
+    rd_buf[2]=0x80;
+    ret = i2c_write_bytes(ts->client, rd_buf, 3);
+    if(ret<0)
+    {
+            dev_info(&ts->client->dev, "i2c write failed\n");
+            goto exit_downloader;
+    }
+    rd_buf[0]=0x40;
+    rd_buf[1]=0x11;
+    ret = i2c_read_bytes(ts->client, rd_buf, 3);
+    if(ret<=0)
+    {
+            dev_info(&ts->client->dev, "i2c request failed!\n");
+            goto exit_downloader;
+    }
+    rd_chip_type = rd_buf[2];
+    rd_buf[0]=0xFB;
+    rd_buf[1]=0xED;
+    ret = i2c_read_bytes(ts->client, rd_buf, 3);
+    if(ret<=0)
+    {
+            dev_info(&ts->client->dev, "i2c read failed!\n");
+            goto exit_downloader;
+    }
+    rd_rom_version = rd_buf[2];
+    rd_buf[0]=0x06;
+    rd_buf[1]=0x94;
+    ret = i2c_read_bytes(ts->client, rd_buf, 3);
+    if(ret<=0)
+    {
+            dev_info(&ts->client->dev, "i2c read failed!\n");
+            goto exit_downloader;
+    }
+    rd_nvram_flag = rd_buf[2];
+
+    fw_version = Little2BigEndian(fw_info->version);
+    fw_start_addr = Little2BigEndian(fw_info->start_addr);
+    fw_length = Little2BigEndian(fw_info->length);	
+    data_ptr = &(fw_info->data);	
+
+    dev_info(&ts->client->dev,"chip_type=0x%02x\n", fw_info->chip_type);
+    dev_info(&ts->client->dev,"version=0x%04x\n", fw_version);
+    dev_info(&ts->client->dev,"rom_version=0x%02x\n",fw_info->rom_version);
+    dev_info(&ts->client->dev,"start_addr=0x%04x\n",fw_start_addr);
+    dev_info(&ts->client->dev,"file_size=0x%04x\n",fw_length);
+    fw_checksum = ((u32)fw_info->checksum[0]<<16) + ((u32)fw_info->checksum[1]<<8) + ((u32)fw_info->checksum[2]);
+    dev_info(&ts->client->dev,"fw_checksum=0x%06x\n",fw_checksum);
+    dev_info(&ts->client->dev,"%s\n", __func__ );
+    dev_info(&ts->client->dev,"current version 0x%04X, target verion 0x%04X\n", ts->version, fw_version );
+
+//chk_chip_type:
+    if(rd_chip_type!=fw_info->chip_type)
+    {
+	dev_info(&ts->client->dev, "Chip type not match,exit downloader\n");
+	goto exit_downloader;
+    }
+	
+//chk_mask_version:	
+    if(!rd_rom_version)
+    {
+ 	if(fw_info->rom_version!=0x45)
+	{
+		dev_info(&ts->client->dev, "Rom version not match,exit downloader\n");
+		goto exit_downloader;
+	}
+	dev_info(&ts->client->dev, "Rom version E.\n");
+	goto chk_fw_version;
+    }
+    else if(rd_rom_version!=fw_info->rom_version);
+    {
+	dev_info(&ts->client->dev, "Rom version not match,exidownloader\n");
+	goto exit_downloader;
+    }
+    dev_info(&ts->client->dev, "Rom version %c\n",rd_rom_version);
+
+//chk_nvram:	
+    if(rd_nvram_flag==0x55)
+    {
+	dev_info(&ts->client->dev, "NVRAM correct!\n");
+	goto chk_fw_version;
+    }
+    else if(rd_nvram_flag==0xAA)
+    {
+	dev_info(&ts->client->dev, "NVRAM incorrect!Need update.\n");
+	goto begin_upgrade;
+    }
+    else
+    {
+	dev_info(&ts->client->dev, "NVRAM other error![0x694]=0x%02x\n", rd_nvram_flag);
+	goto begin_upgrade;
+    }
+chk_fw_version:
+//	ts->version -= 1;               //test by andrew        
+    if( ts->version >= fw_version )   // current low byte higher than back-up low byte
+    {
+            dev_info(&ts->client->dev, "Fw verison not match.\n");
+            goto chk_mandatory_upgrade;
+    }
+    dev_info(&ts->client->dev,"Need to upgrade\n");
+    goto begin_upgrade;
+chk_mandatory_upgrade:
+//	dev_info(&ts->client->dev, "%s\n", mandatory_base);
+//	dev_info(&ts->client->dev, "%s\n", fw_info->mandatory_flag);
+    ret = memcmp(mandatory_base, fw_info->mandatory_flag, 6);
+    if(ret)
+    {
+ 	dev_info(&ts->client->dev,"Not meet mandatory upgrade,exit downloader!ret:%d\n", ret);
+	goto exit_downloader;
+    }
+    dev_info(&ts->client->dev, "Mandatory upgrade!\n");
+begin_upgrade:
+    dev_info(&ts->client->dev, "Begin upgrade!\n");
+ //   goto exit_downloader;
+    dev_info(&ts->client->dev,"STEP_0:\n");
+
+   
+    dev_info(&ts->client->dev, "STEP_1:\n");
+    err = -1;
+    while( retry < 3 ) 
+    {
+//        ret = gt811_update_proc( data_ptr,fw_start_addr, fw_length, ts);
+        if(ret == 1)
+        {
+            err = 1;
+            break;
+        }
+        retry++;
+    }
+    
+exit_downloader:
+    //mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
+   // mt_set_gpio_out(GPIO_CTP_EN_PIN, GPIO_OUT_ONE);
+       // gpio_direction_output(INT_PORT,1);
+       // msleep(1);
+    gpio_free(INT_PORT);
+    gpio_pull_updown(INT_PORT, NULL);
+    return err;
+
+}
+//******************************End of firmware update surpport*******************************
+/////////////////////////////// UPDATE STEP 4 END /////////////////////////////////////////////////////////////////
+
+//?ID 
+//only one client
+static const struct i2c_device_id goodix_ts_id[] = {
+	{ GOODIX_I2C_NAME, 0 },
+	{ }
+};
+
+//?
+static struct i2c_driver goodix_ts_driver = {
+	.probe		= goodix_ts_probe,
+	.remove		= goodix_ts_remove,
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	.suspend	= goodix_ts_suspend,
+	.resume		= goodix_ts_resume,
+#endif
+	.id_table	= goodix_ts_id,
+	.driver = {
+		.name	= GOODIX_I2C_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+/*******************************************************	
+?	
+return?	0
+********************************************************/
+static int __devinit goodix_ts_init(void)
+{
+	int ret;
+	
+	goodix_wq = create_workqueue("goodix_wq");		//create a work queue and worker thread
+	if (!goodix_wq) {
+		printk(KERN_ALERT "creat workqueue faiked\n");
+		return -ENOMEM;
+		
+	}
+	ret=i2c_add_driver(&goodix_ts_driver);
+	return ret; 
+}
+
+/*******************************************************	
+?	
+?	client
+********************************************************/
+static void __exit goodix_ts_exit(void)
+{
+	printk(KERN_ALERT "Touchscreen driver of guitar exited.\n");
+	i2c_del_driver(&goodix_ts_driver);
+	if (goodix_wq)
+		destroy_workqueue(goodix_wq);		//release our work queue
+}
+
+late_initcall_sync(goodix_ts_init); 				//felix
+module_exit(goodix_ts_exit);
+
+MODULE_DESCRIPTION("Goodix Touchscreen Driver");
+MODULE_LICENSE("GPL");
+               
diff --git a/drivers/input/touchscreen/gt811_ts.h b/drivers/input/touchscreen/gt811_ts.h
new file mode 100755
index 000000000000..7eb59a865248
--- /dev/null
+++ b/drivers/input/touchscreen/gt811_ts.h
@@ -0,0 +1,277 @@
+/* drivers/input/touchscreen/gt811.h
+ *
+ * Copyright (C) 2010 - 2011 Goodix, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ *Any problem,please contact andrew@goodix.com,+86 755-33338828
+ *
+ */
+
+#ifndef 	_LINUX_GT811_H
+#define		_LINUX_GT811_H
+
+#include <linux/earlysuspend.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+
+//*************************TouchScreen Work Part*****************************
+#define GOODIX_I2C_NAME "gt811_ts"
+#define GT801_PLUS
+#define GT801_NUVOTON
+#define GUITAR_UPDATE_STATE 0x02
+
+//define resolution of the touchscreen
+#define TOUCH_MAX_HEIGHT 	800			
+#define TOUCH_MAX_WIDTH		480
+//#define STOP_IRQ_TYPE                     // if define then   no stop irq in irq_handle   kuuga add 1202S
+#define REFRESH 0     //0~0x64   Scan rate = 10000/(100+REFRESH)//define resolution of the LCD
+
+#define SHUTDOWN_PORT 	     RK2928_PIN3_PC3 
+#define INT_PORT 	         RK2928_PIN3_PC7  
+
+
+#ifdef INT_PORT
+	#define TS_INT 		        gpio_to_irq(INT_PORT)			//Interrupt Number,EINT18(119)
+//	#define INT_CFG    	      S3C_GPIO_SFN(3) 					//IO configer as EINT
+#else
+	#define TS_INT	0
+#endif	
+
+/////////////////////////////// UPDATE STEP 5 START /////////////////////////////////////////////////////////////////
+#define TPD_CHIP_VERSION_C_FIRMWARE_BASE 0x5A
+#define TPD_CHIP_VERSION_D1_FIRMWARE_BASE 0x7A
+#define TPD_CHIP_VERSION_E_FIRMWARE_BASE 0x9A
+#define TPD_CHIP_VERSION_D2_FIRMWARE_BASE 0xBA
+
+
+/////////////////////////////// UPDATE STEP 5 END /////////////////////////////////////////////////////////////////
+
+#define FLAG_UP		0
+#define FLAG_DOWN		1
+//set GT801 PLUS trigger mode,01 
+//#define INT_TRIGGER		1	   // 1=rising 0=falling
+#define POLL_TIME		10	//actual query spacing interval:POLL_TIME+6
+
+#define GOODIX_MULTI_TOUCH
+#ifdef GOODIX_MULTI_TOUCH
+	#define MAX_FINGER_NUM	5	
+#else
+	#define MAX_FINGER_NUM	1	
+#endif
+
+#if defined(INT_PORT)
+	#if MAX_FINGER_NUM <= 3
+	#define READ_BYTES_NUM 2+2+MAX_FINGER_NUM*5
+	#elif MAX_FINGER_NUM == 4
+	#define READ_BYTES_NUM 2+28
+	#elif MAX_FINGER_NUM == 5
+	#define READ_BYTES_NUM 2+34
+	#endif
+#else	
+	#define READ_BYTES_NUM 2+34
+#endif
+
+#define swap(x, y) do { typeof(x) z = x; x = y; y = z; } while (0)
+
+#define READ_TOUCH_ADDR_H 0x07
+#define READ_TOUCH_ADDR_L 0x21				//GT811 0x721
+#define READ_KEY_ADDR_H 0x07
+#define READ_KEY_ADDR_L 0x21
+#define READ_COOR_ADDR_H 0x07
+#define READ_COOR_ADDR_L 0x22
+#define READ_ID_ADDR_H 0x00
+#define READ_ID_ADDR_L 0xff
+//**********************************************************************
+
+//******************************************************************************
+struct gt811_ts_data {
+	uint16_t addr;
+	uint8_t bad_data;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	int use_reset;		//use RESET flag
+	int use_irq;		//use EINT flag
+	int read_mode;		//read moudle mode,20110221 by andrew
+	struct hrtimer timer;
+	struct work_struct  work;
+	char phys[32];
+	int retry;
+	int irq;
+	spinlock_t				irq_lock;      //add by kuuga
+	int 				 irq_is_disable; /* 0: irq enable */ //add by kuuga
+	uint16_t abs_x_max;
+	uint16_t abs_y_max;
+	uint8_t max_touch_num;
+	uint8_t int_trigger_type;
+	uint8_t btn_state;                    // key states
+/////////////////////////////// UPDATE STEP 6 START /////////////////////////////////////////////////////////////////
+       unsigned int version;
+/////////////////////////////// UPDATE STEP 6 END /////////////////////////////////////////////////////////////////
+
+	struct early_suspend early_suspend;
+	int (*power)(struct gt811_ts_data * ts, int on);
+};
+
+//*****************************End of Part I *********************************
+
+//*************************Touchkey Surpport Part*****************************
+/*#define HAVE_TOUCH_KEY
+//#define READ_KEY_VALUE
+//#define READ_KEY_COOR
+
+#ifdef HAVE_TOUCH_KEY
+	const uint16_t toucher_key_array[]={
+									  KEY_MENU,				//MENU
+									  KEY_HOME,
+									  KEY_BACK,				
+									  KEY_SEARCH		
+									 }; 
+	#define MAX_KEY_NUM	 (sizeof(toucher_key_array)/sizeof(toucher_key_array[0]))
+#endif
+*/
+//#define COOR_TO_KEY
+    #ifdef COOR_TO_KEY
+
+    #define KEY_X       40
+    #define KEY_Y       20
+    #if 0
+    #define AREA_X      0
+    #else
+    #define AREA_Y      800
+    #endif
+
+    enum {x, y};
+    s32 key_center[MAX_KEY_NUM][2] = {
+		
+	{48,840},{124,840},{208,840},{282,840}
+	
+                           };
+
+    #endif 
+
+//*****************************End of Part II*********************************
+
+/////////////////////////////// UPDATE STEP 7 START /////////////////////////////////////////////////////////////////
+//*************************Firmware Update part*******************************
+//#define AUTO_UPDATE_GT811
+
+#define CONFIG_TOUCHSCREEN_GOODIX_IAP        
+#ifdef CONFIG_TOUCHSCREEN_GOODIX_IAP
+static int goodix_update_write(struct file *filp, const char __user *buff, unsigned long len, void *data);
+static int goodix_update_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+
+#define PACK_SIZE 					64					//update file package size
+//#define MAX_TIMEOUT					30000				//update time out conut
+//#define MAX_I2C_RETRIES				10					//i2c retry times
+
+//write cmd
+#define APK_UPDATE_TP               1
+#define APK_READ_FUN                 10
+#define APK_WRITE_CFG               11
+
+//fun cmd
+//#define CMD_DISABLE_TP             0
+//#define CMD_ENABLE_TP              1
+#define CMD_READ_VER               2
+#define CMD_READ_RAW               3
+#define CMD_READ_DIF               4
+#define CMD_READ_CFG               5
+#define CMD_READ_CHIP_TYPE         6
+//#define CMD_SYS_REBOOT             101
+
+//read mode
+#define MODE_RD_VER                1
+#define MODE_RD_RAW                2
+#define MODE_RD_DIF                3
+#define MODE_RD_CFG                4
+#define MODE_RD_CHIP_TYPE          5
+
+#if 0
+struct tpd_firmware_info_t
+{
+    int magic_number_1;
+    int magic_number_2;
+    unsigned short version;
+    unsigned short length;    
+    unsigned short checksum;
+    unsigned char data;
+};
+#else
+#pragma pack(1)
+struct tpd_firmware_info_t
+{
+	unsigned char  chip_type;
+	unsigned short version;
+	unsigned char  rom_version;
+	unsigned char  reserved[3];
+	unsigned short start_addr;
+	unsigned short length;
+	unsigned char  checksum[3];
+	unsigned char  mandatory_flag[6];
+	unsigned char  data;	
+};
+#pragma pack()
+#endif
+
+#define  NVRAM_LEN               0x0FF0   //	nvram total space
+#define  NVRAM_BOOT_SECTOR_LEN	 0x0100	// boot sector 
+#define  NVRAM_UPDATE_START_ADDR 0x4100
+
+#define  BIT_NVRAM_STROE	    0
+#define  BIT_NVRAM_RECALL	    1
+#define BIT_NVRAM_LOCK 2
+#define  REG_NVRCS_H 0X12
+#define  REG_NVRCS_L 0X01
+#define GT811_SET_INT_PIN( level ) gpio_direction_output(INT_PORT, level) //null macro now
+#endif
+//*****************************End of Part III********************************
+/////////////////////////////// UPDATE STEP 7 END /////////////////////////////////////////////////////////////////
+
+struct gt811_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+    u16     model;          /* 801. */
+    bool    swap_xy;        /* swap x and y axes */
+    u16     x_min, x_max;
+    u16     y_min, y_max;
+    bool    x_reverse, y_reverse;
+    int     (*get_pendown_state)(void);
+    int     (*init_platform_hw)(void);
+    int     (*platform_sleep)(void);
+    int     (*platform_wakeup)(void);
+    void    (*exit_platform_hw)(void);
+    int     gpio_reset;
+    bool    gpio_reset_active_low;
+    
+
+    //reservation
+};
+
+#define RAW_DATA_READY          1
+#define RAW_DATA_NON_ACTIVE     0xffffffff
+#define RAW_DATA_ACTIVE         0
+
+
+enum CHIP_TYPE
+{
+    GT800 = 1,
+    GT800PLUS,
+    GT800PLUS3,
+    GT816,
+    GT811,
+    GT8105,
+    GT8110,
+    GT818PLUS
+};
+
+
+#endif /* _LINUX_GOODIX_TOUCH_H */
diff --git a/sound/soc/codecs/rk2928_codec.c b/sound/soc/codecs/rk2928_codec.c
index 8db61f6e7362..85a958cea143 100755
--- a/sound/soc/codecs/rk2928_codec.c
+++ b/sound/soc/codecs/rk2928_codec.c
@@ -61,7 +61,7 @@ static const struct snd_soc_dapm_widget rk2928_dapm_widgets[] = {
 //	SND_SOC_DAPM_OUT_DRV("DACR Drv", CODEC_REG_DAC_MUTE, 0, 1, NULL, 0),
 	SND_SOC_DAPM_OUTPUT("SPKL"),
 	SND_SOC_DAPM_OUTPUT("SPKR"),
-	#ifndef CONFIG_MACH_RK2928_A720
+	#ifndef CONFIG_MACH_RK2926_SDK
 	SND_SOC_DAPM_ADC("ADCL", "HIFI Capture", CODEC_REG_POWER, 3, 1),
 	SND_SOC_DAPM_INPUT("MICL"),
 	#endif
@@ -74,7 +74,7 @@ static const struct snd_soc_dapm_route rk2928_audio_map[] = {
 	{"SPKR", "DACR Amp", "DACR"},
 //	{"SPKL", NULL, "DACL Drv"},
 //	{"SPKR", NULL, "DACR Drv"},
-	#ifndef CONFIG_MACH_RK2928_A720
+	#ifndef CONFIG_MACH_RK2926_SDK
 	{"ADCL", NULL, "MICL"},
 	#endif
 	{"ADCR", NULL, "MICR"},
-- 
2.35.3

