From 2a0c02961ee9f572c0b0776f81aa390efea37bce Mon Sep 17 00:00:00 2001
From: Cody Xie <Cody.Xie@rock-chips.com>
Date: Wed, 9 Apr 2014 11:50:23 +0800
Subject: [PATCH] rk3288 gpu : update GPU driver r4p0_eac version

---
 arch/arm/configs/rockchip_defconfig           |   10 +-
 drivers/gpu/arm/Kbuild                        |    2 +-
 drivers/gpu/arm/Kconfig                       |    2 +-
 drivers/gpu/arm/midgard/Kbuild                |  228 ++
 .../gpu/arm/{t6xx/kbase => midgard}/Kconfig   |   64 +-
 .../arm/{t6xx/kbase/src => midgard}/Makefile  |   10 +-
 .../kbase/src => midgard}/Makefile.kbase      |    2 +-
 .../arm/{t6xx/kbase => midgard}/docs/Doxyfile |    6 +-
 .../docs/policy_operation_diagram.dot         |    0
 .../docs/policy_overview.dot                  |    0
 .../kbase => midgard}/mali_base_hwconfig.h    |  240 +-
 .../kbase => midgard}/mali_base_kernel.h      |  180 +-
 .../kbase => midgard}/mali_base_kernel_sync.h |    0
 .../src => midgard}/mali_base_mem_priv.h      |    0
 .../mali_base_vendor_specific_func.h          |    0
 .../kbase/src/common => midgard}/mali_kbase.h |   20 +-
 .../mali_kbase_10969_workaround.c             |   72 +-
 .../mali_kbase_10969_workaround.h             |    0
 .../mali_kbase_cache_policy.c                 |    0
 .../mali_kbase_cache_policy.h                 |    2 +-
 drivers/gpu/arm/midgard/mali_kbase_config.c   |  358 +++
 .../kbase => midgard}/mali_kbase_config.h     |  204 +-
 .../arm/midgard/mali_kbase_config_defaults.h  |  202 ++
 .../common => midgard}/mali_kbase_context.c   |   77 +-
 .../linux => midgard}/mali_kbase_core_linux.c |  664 +++---
 .../common => midgard}/mali_kbase_cpuprops.c  |    2 +-
 .../common => midgard}/mali_kbase_cpuprops.h  |    0
 .../src/common => midgard}/mali_kbase_debug.c |   28 +-
 .../kbase => midgard}/mali_kbase_debug.h      |   99 +-
 .../src/common => midgard}/mali_kbase_defs.h  |  118 +-
 .../common => midgard}/mali_kbase_device.c    |   49 +-
 .../src/common => midgard}/mali_kbase_event.c |   19 +-
 .../src/common => midgard}/mali_kbase_gator.h |    0
 .../mali_kbase_gpu_memory_debugfs.c           |   18 +-
 .../mali_kbase_gpu_memory_debugfs.h           |    2 +-
 .../common => midgard}/mali_kbase_gpuprops.c  |   10 +-
 .../common => midgard}/mali_kbase_gpuprops.h  |    0
 .../mali_kbase_gpuprops_types.h               |    2 +-
 .../src/common => midgard}/mali_kbase_hw.c    |   53 +-
 .../src/common => midgard}/mali_kbase_hw.h    |    0
 .../src/common => midgard}/mali_kbase_instr.c |   10 +-
 .../src/common => midgard}/mali_kbase_jd.c    |  263 ++-
 .../src/common => midgard}/mali_kbase_jm.c    |  107 +-
 .../src/common => midgard}/mali_kbase_jm.h    |    5 +-
 .../src/common => midgard}/mali_kbase_js.c    |   71 +-
 .../src/common => midgard}/mali_kbase_js.h    |    5 +-
 .../mali_kbase_js_affinity.c                  |   70 +-
 .../mali_kbase_js_affinity.h                  |    5 -
 .../mali_kbase_js_ctx_attr.c                  |    2 +-
 .../mali_kbase_js_ctx_attr.h                  |    0
 .../common => midgard}/mali_kbase_js_defs.h   |    3 +
 .../common => midgard}/mali_kbase_js_policy.h |    0
 .../mali_kbase_js_policy_cfs.c                |   41 +-
 .../mali_kbase_js_policy_cfs.h                |    0
 .../src/linux => midgard}/mali_kbase_linux.h  |   35 -
 .../src/common => midgard}/mali_kbase_mem.c   |  407 ++--
 .../src/common => midgard}/mali_kbase_mem.h   |  229 +-
 .../common => midgard}/mali_kbase_mem_alloc.c |    2 +-
 .../common => midgard}/mali_kbase_mem_alloc.h |    0
 .../linux => midgard}/mali_kbase_mem_linux.c  |  577 +++--
 .../linux => midgard}/mali_kbase_mem_linux.h  |    1 +
 .../mali_kbase_mem_lowlevel.c                 |    6 +-
 .../mali_kbase_mem_lowlevel.h                 |    0
 .../src/common => midgard}/mali_kbase_mmu.c   |  298 ++-
 .../mali_kbase_platform_fake.c                |   21 +-
 .../src/common => midgard}/mali_kbase_pm.c    |   17 +-
 .../src/common => midgard}/mali_kbase_pm.h    |    4 +-
 .../mali_kbase_pm_always_on.c                 |    4 +-
 .../mali_kbase_pm_always_on.h                 |    0
 .../src/common => midgard}/mali_kbase_pm_ca.c |    4 +-
 .../src/common => midgard}/mali_kbase_pm_ca.h |    0
 .../mali_kbase_pm_ca_fixed.c                  |    4 +-
 .../mali_kbase_pm_ca_fixed.h                  |    0
 .../mali_kbase_pm_coarse_demand.c             |    4 +-
 .../mali_kbase_pm_coarse_demand.h             |    0
 .../common => midgard}/mali_kbase_pm_demand.c |    4 +-
 .../common => midgard}/mali_kbase_pm_demand.h |    0
 .../common => midgard}/mali_kbase_pm_driver.c |   17 +-
 .../mali_kbase_pm_metrics.c                   |    8 +-
 .../mali_kbase_pm_metrics_dummy.c             |    4 +-
 .../common => midgard}/mali_kbase_pm_policy.c |    8 +-
 .../common => midgard}/mali_kbase_pm_policy.h |    0
 .../mali_kbase_profiling_gator_api.h          |    0
 drivers/gpu/arm/midgard/mali_kbase_replay.c   | 1069 +++++++++
 .../common => midgard}/mali_kbase_security.c  |    4 +-
 .../common => midgard}/mali_kbase_security.h  |    0
 .../common => midgard}/mali_kbase_softjobs.c  |   22 +-
 .../src/linux => midgard}/mali_kbase_sync.c   |    4 +-
 .../src/linux => midgard}/mali_kbase_sync.h   |    1 -
 .../linux => midgard}/mali_kbase_sync_user.c  |    4 +-
 .../mali_kbase_trace_defs.h                   |    0
 .../mali_kbase_trace_timeline.c               |    8 +-
 .../mali_kbase_trace_timeline.h               |    0
 .../mali_kbase_trace_timeline_defs.h          |    0
 .../src/common => midgard}/mali_kbase_uku.h   |   39 +-
 .../common => midgard}/mali_kbase_utility.c   |    2 +-
 .../common => midgard}/mali_kbase_utility.h   |    0
 .../src/linux => midgard}/mali_linux_trace.h  |    4 +-
 .../src/common => midgard}/mali_midg_regmap.h |   26 +-
 .../src/common => midgard}/mali_timeline.h    |    2 +-
 .../gpu/arm/{t6xx/kbase => midgard}/mali_uk.h |    0
 .../malisw/arm_cstd/arm_cstd.h                |    0
 .../malisw/arm_cstd/arm_cstd_compilers.h      |    0
 .../malisw/arm_cstd/arm_cstd_pack_pop.h       |    0
 .../malisw/arm_cstd/arm_cstd_pack_push.h      |    0
 .../malisw/arm_cstd/arm_cstd_types.h          |    0
 .../malisw/arm_cstd/arm_cstd_types_gcc.h      |    0
 .../malisw/arm_cstd/arm_cstd_types_rvct.h     |    0
 .../kbase => midgard}/malisw/mali_malisw.h    |    0
 .../kbase => midgard}/malisw/mali_stdtypes.h  |    0
 .../kbase/src => midgard}/platform/Kbuild     |    0
 .../kbase/src => midgard}/platform/Kconfig    |    2 +-
 .../platform/mali_kbase_platform_common.h     |    0
 .../kbase/src => midgard}/platform/rk/Kbuild  |    4 +-
 .../platform/rk/mali_kbase_config_rk.c        |   71 +-
 .../platform/rk/mali_kbase_dvfs.c             |  199 +-
 .../platform/rk/mali_kbase_dvfs.h             |   20 +-
 .../platform/rk/mali_kbase_platform.c         |  184 +-
 .../platform/rk/mali_kbase_platform.h         |    3 +-
 .../platform/vexpress/Kbuild}                 |    5 +-
 .../vexpress/mali_kbase_config_vexpress.c     |  323 +++
 .../vexpress/mali_kbase_cpu_vexpress.c        |  180 ++
 .../vexpress/mali_kbase_cpu_vexpress.h        |   28 +
 .../platform/vexpress_6xvirtex7_10mhz}/Kbuild |    3 +-
 .../mali_kbase_config_vexpress.c              |  324 +++
 .../mali_kbase_cpu_vexpress.c                 |   71 +
 .../mali_kbase_cpu_vexpress.h                 |   28 +
 .../platform/vexpress_virtex7_40mhz}/Kbuild   |    5 +-
 .../mali_kbase_config_vexpress.c              |  323 +++
 .../mali_kbase_cpu_vexpress.c                 |  178 ++
 .../mali_kbase_cpu_vexpress.h                 |   26 +
 .../platform_dummy/mali_ukk_os.h              |    0
 drivers/gpu/arm/midgard/sconscript            |  114 +
 .../tests/customer/sconscript                 |    0
 .../{t6xx/kbase => midgard}/tests/sconscript  |    0
 drivers/gpu/arm/sconscript                    |    2 +-
 drivers/gpu/arm/t6xx/kbase/Makefile           |  103 -
 drivers/gpu/arm/t6xx/kbase/src/Kbuild         |  298 ---
 .../t6xx/kbase/src/common/mali_kbase_config.c |  610 -----
 .../src/integration_kit/MaliDefines-t760.h    | 1977 ----------------
 .../src/integration_kit/MaliFns-generic.c     |  219 --
 .../kbase/src/integration_kit/MaliFns-t760.c  |  366 ---
 .../src/integration_kit/MaliFns-t760perf.c    |   37 -
 .../t6xx/kbase/src/integration_kit/MaliFns.h  |  125 -
 .../kbase/src/integration_kit/sim1_t760_run.c |  417 ----
 .../kbase/src/integration_kit/sim2_t760_run.c |  193 --
 .../src/integration_kit/sim3_t760_check_0_a.c |   27 -
 .../src/integration_kit/sim3_t760_check_0_a.h |   22 -
 .../src/integration_kit/sim3_t760_mem_0.c     | 2084 -----------------
 .../src/integration_kit/sim3_t760_mem_0.h     |   28 -
 .../kbase/src/integration_kit/sim3_t760_run.c |  160 --
 .../kbase/src/integration_kit/sim4_t760_run.c |  189 --
 drivers/gpu/arm/t6xx/kbase/src/sconscript     |  114 -
 drivers/gpu/arm/t6xx/license.txt              |  198 --
 drivers/gpu/arm/t6xx/sconscript               |   17 -
 drivers/video/Kconfig                         |    2 +-
 156 files changed, 6305 insertions(+), 9138 deletions(-)
 mode change 100644 => 100755 drivers/gpu/arm/Kbuild
 mode change 100644 => 100755 drivers/gpu/arm/Kconfig
 create mode 100755 drivers/gpu/arm/midgard/Kbuild
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/Kconfig (73%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/Makefile (76%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/Makefile.kbase (81%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/docs/Doxyfile (86%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/docs/policy_operation_diagram.dot (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/docs/policy_overview.dot (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/mali_base_hwconfig.h (86%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/mali_base_kernel.h (90%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/mali_base_kernel_sync.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/mali_base_mem_priv.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/mali_base_vendor_specific_func.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase.h (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_10969_workaround.c (69%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_10969_workaround.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_cache_policy.c (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_cache_policy.h (97%)
 mode change 100644 => 100755
 create mode 100755 drivers/gpu/arm/midgard/mali_kbase_config.c
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/mali_kbase_config.h (89%)
 mode change 100644 => 100755
 create mode 100755 drivers/gpu/arm/midgard/mali_kbase_config_defaults.h
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_context.c (75%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_core_linux.c (80%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_cpuprops.c (99%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_cpuprops.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_debug.c (53%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/mali_kbase_debug.h (66%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_defs.h (90%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_device.c (94%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_event.c (90%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_gator.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_gpu_memory_debugfs.c (81%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_gpu_memory_debugfs.h (96%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_gpuprops.c (96%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_gpuprops.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_gpuprops_types.h (98%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_hw.c (67%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_hw.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_instr.c (98%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_jd.c (87%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_jm.c (92%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_jm.h (96%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js.c (95%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js.h (99%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js_affinity.c (85%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js_affinity.h (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js_ctx_attr.c (99%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js_ctx_attr.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js_defs.h (98%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js_policy.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js_policy_cfs.c (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_js_policy_cfs.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_linux.h (61%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_mem.c (77%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_mem.h (79%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_mem_alloc.c (99%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_mem_alloc.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_mem_linux.c (72%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_mem_linux.h (95%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_mem_lowlevel.c (89%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_mem_lowlevel.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_mmu.c (84%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_platform_fake.c (86%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm.c (96%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm.h (99%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_always_on.c (94%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_always_on.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_ca.c (98%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_ca.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_ca_fixed.c (94%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_ca_fixed.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_coarse_demand.c (95%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_coarse_demand.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_demand.c (94%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_demand.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_driver.c (98%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_metrics.c (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_metrics_dummy.c (91%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_policy.c (99%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_pm_policy.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/mali_kbase_profiling_gator_api.h (100%)
 mode change 100644 => 100755
 create mode 100755 drivers/gpu/arm/midgard/mali_kbase_replay.c
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_security.c (93%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_security.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_softjobs.c (94%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_sync.c (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_sync.h (98%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_kbase_sync_user.c (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_trace_defs.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_trace_timeline.c (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_trace_timeline.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_trace_timeline_defs.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_uku.h (90%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_utility.c (94%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_kbase_utility.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/linux => midgard}/mali_linux_trace.h (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_midg_regmap.h (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src/common => midgard}/mali_timeline.h (99%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/mali_uk.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/malisw/arm_cstd/arm_cstd.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/malisw/arm_cstd/arm_cstd_compilers.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/malisw/arm_cstd/arm_cstd_pack_pop.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/malisw/arm_cstd/arm_cstd_pack_push.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/malisw/arm_cstd/arm_cstd_types.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/malisw/arm_cstd/arm_cstd_types_gcc.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/malisw/arm_cstd/arm_cstd_types_rvct.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/malisw/mali_malisw.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/malisw/mali_stdtypes.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/platform/Kbuild (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/platform/Kconfig (91%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/platform/mali_kbase_platform_common.h (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/platform/rk/Kbuild (91%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/platform/rk/mali_kbase_config_rk.c (86%)
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/platform/rk/mali_kbase_dvfs.c (76%)
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/platform/rk/mali_kbase_dvfs.h (79%)
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/platform/rk/mali_kbase_platform.c (87%)
 rename drivers/gpu/arm/{t6xx/kbase/src => midgard}/platform/rk/mali_kbase_platform.h (97%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase/sconscript => midgard/platform/vexpress/Kbuild} (76%)
 mode change 100644 => 100755
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_config_vexpress.c
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_cpu_vexpress.c
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_cpu_vexpress.h
 rename drivers/gpu/arm/{t6xx => midgard/platform/vexpress_6xvirtex7_10mhz}/Kbuild (87%)
 mode change 100644 => 100755
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.h
 rename drivers/gpu/arm/{t6xx/kbase => midgard/platform/vexpress_virtex7_40mhz}/Kbuild (87%)
 mode change 100644 => 100755
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_config_vexpress.c
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.c
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.h
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/platform_dummy/mali_ukk_os.h (100%)
 mode change 100644 => 100755
 create mode 100755 drivers/gpu/arm/midgard/sconscript
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/tests/customer/sconscript (100%)
 mode change 100644 => 100755
 rename drivers/gpu/arm/{t6xx/kbase => midgard}/tests/sconscript (100%)
 mode change 100644 => 100755
 mode change 100644 => 100755 drivers/gpu/arm/sconscript
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/Makefile
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/Kbuild
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_config.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliDefines-t760.h
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-generic.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-t760.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-t760perf.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns.h
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim1_t760_run.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim2_t760_run.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_check_0_a.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_check_0_a.h
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_mem_0.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_mem_0.h
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_run.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim4_t760_run.c
 delete mode 100644 drivers/gpu/arm/t6xx/kbase/src/sconscript
 delete mode 100644 drivers/gpu/arm/t6xx/license.txt
 delete mode 100644 drivers/gpu/arm/t6xx/sconscript

diff --git a/arch/arm/configs/rockchip_defconfig b/arch/arm/configs/rockchip_defconfig
index 65b0cda06099..38610083cc2d 100755
--- a/arch/arm/configs/rockchip_defconfig
+++ b/arch/arm/configs/rockchip_defconfig
@@ -34,6 +34,7 @@ CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
 CONFIG_PARTITION_ADVANCED=y
 CONFIG_ARCH_ROCKCHIP=y
+CONFIG_BLOCK_RKNAND=y
 # CONFIG_SWP_EMULATE is not set
 CONFIG_ARM_ERRATA_720789=y
 CONFIG_PL310_ERRATA_753970=y
@@ -209,7 +210,6 @@ CONFIG_RFKILL=y
 CONFIG_RFKILL_RK=y
 CONFIG_DEVTMPFS=y
 CONFIG_CMA=y
-CONFIG_BLOCK_RKNAND=y
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_UID_STAT=y
 CONFIG_SRAM=y
@@ -333,10 +333,10 @@ CONFIG_MEDIA_RC_SUPPORT=y
 CONFIG_MEDIA_CONTROLLER=y
 CONFIG_VIDEO_V4L2_SUBDEV_API=y
 CONFIG_V4L_PLATFORM_DRIVERS=y
-CONFIG_MALI_T6XX=y
-CONFIG_MALI_T6XX_DVFS=y
-CONFIG_MALI_T6XX_RT_PM=y
-CONFIG_MALI_T6XX_DEBUG_SYS=y
+CONFIG_MALI_MIDGARD=y
+CONFIG_MALI_MIDGARD_DVFS=y
+CONFIG_MALI_MIDGARD_RT_PM=y
+CONFIG_MALI_MIDGARD_DEBUG_SYS=y
 CONFIG_MALI_EXPERT=y
 CONFIG_MALI_DEBUG_SHADER_SPLIT_FS=y
 CONFIG_MALI_PLATFORM_THIRDPARTY_NAME="rk"
diff --git a/drivers/gpu/arm/Kbuild b/drivers/gpu/arm/Kbuild
old mode 100644
new mode 100755
index 1f8f6d692204..19c7e9a2659d
--- a/drivers/gpu/arm/Kbuild
+++ b/drivers/gpu/arm/Kbuild
@@ -14,4 +14,4 @@
 
 
 
-obj-$(CONFIG_MALI_T6XX) += t6xx/
+obj-$(CONFIG_MALI_MIDGARD) += midgard/
diff --git a/drivers/gpu/arm/Kconfig b/drivers/gpu/arm/Kconfig
old mode 100644
new mode 100755
index 98cd41aec757..1f30eb541d65
--- a/drivers/gpu/arm/Kconfig
+++ b/drivers/gpu/arm/Kconfig
@@ -15,5 +15,5 @@
 
 
 menu "ARM GPU Configuration"
-source "drivers/gpu/arm/t6xx/kbase/Kconfig"
+source "drivers/gpu/arm/midgard/Kconfig"
 endmenu
diff --git a/drivers/gpu/arm/midgard/Kbuild b/drivers/gpu/arm/midgard/Kbuild
new file mode 100755
index 000000000000..ea8c86489b06
--- /dev/null
+++ b/drivers/gpu/arm/midgard/Kbuild
@@ -0,0 +1,228 @@
+#
+# (C) COPYRIGHT 2012 ARM Limited. All rights reserved.
+#
+# This program is free software and is provided to you under the terms of the
+# GNU General Public License version 2 as published by the Free Software
+# Foundation, and any use by you of this program is subject to the terms
+# of such GNU licence.
+#
+# A copy of the licence is included with the program, and can also be obtained
+# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+# Boston, MA  02110-1301, USA.
+#
+#
+
+
+
+# Driver version string which is returned to userspace via an ioctl
+MALI_RELEASE_NAME ?= "r4p0-02rel0"
+
+# Paths required for build
+KBASE_PATH = $(src)
+KBASE_PLATFORM_PATH = $(KBASE_PATH)/platform_dummy
+UMP_PATH = $(src)/../../../base
+
+ifeq ($(CONFIG_MALI_ERROR_INJECTION),y)
+MALI_ERROR_INJECT_ON = 1
+endif
+
+# Set up defaults if not defined by build system
+MALI_CUSTOMER_RELEASE ?= 1
+MALI_UNIT_TEST ?= 0
+MALI_KERNEL_TEST_API ?= 0
+MALI_ERROR_INJECT_ON ?= 0
+MALI_MOCK_TEST ?= 0
+MALI_COVERAGE ?= 0
+MALI_INSTRUMENTATION_LEVEL ?= 0
+# This workaround is for what seems to be a compiler bug we observed in
+# GCC 4.7 on AOSP 4.3.  The bug caused an intermittent failure compiling
+# the "_Pragma" syntax, where an error message is returned:
+#
+# "internal compiler error: unspellable token PRAGMA"
+#
+# This regression has thus far only been seen on the GCC 4.7 compiler bundled
+# with AOSP 4.3.0.  So this makefile, intended for in-tree kernel builds
+# which are not known to be used with AOSP, is hardcoded to disable the
+# workaround, i.e. set the define to 0.
+MALI_GCC_WORKAROUND_MIDCOM_4598 ?= 0
+
+# Set up our defines, which will be passed to gcc
+DEFINES = \
+	-DMALI_CUSTOMER_RELEASE=$(MALI_CUSTOMER_RELEASE) \
+	-DMALI_KERNEL_TEST_API=$(MALI_KERNEL_TEST_API) \
+	-DMALI_UNIT_TEST=$(MALI_UNIT_TEST) \
+	-DMALI_ERROR_INJECT_ON=$(MALI_ERROR_INJECT_ON) \
+	-DMALI_MOCK_TEST=$(MALI_MOCK_TEST) \
+	-DMALI_COVERAGE=$(MALI_COVERAGE) \
+	-DMALI_INSTRUMENTATION_LEVEL=$(MALI_INSTRUMENTATION_LEVEL) \
+	-DMALI_RELEASE_NAME=\"$(MALI_RELEASE_NAME)\" \
+	-DMALI_GCC_WORKAROUND_MIDCOM_4598=$(MALI_GCC_WORKAROUND_MIDCOM_4598)
+
+ifeq ($(KBUILD_EXTMOD),)
+# in-tree
+DEFINES +=-DMALI_KBASE_THIRDPARTY_PATH=../../$(src)/platform/$(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME)
+else
+# out-of-tree
+DEFINES +=-DMALI_KBASE_THIRDPARTY_PATH=$(src)/platform/$(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME)
+endif
+
+# Use our defines when compiling
+ccflags-y += $(DEFINES) -I$(KBASE_PATH)   -I$(KBASE_PLATFORM_PATH) -I$(UMP_PATH) -I$(srctree)/drivers/staging/android
+subdir-ccflags-y += $(DEFINES) -I$(KBASE_PATH)   -I$(KBASE_PLATFORM_PATH) -I$(OSK_PATH) -I$(UMP_PATH)
+
+SRC := \
+	mali_kbase_device.c \
+	mali_kbase_cache_policy.c \
+	mali_kbase_mem.c \
+	mali_kbase_mmu.c \
+	mali_kbase_jd.c \
+	mali_kbase_jm.c \
+	mali_kbase_cpuprops.c \
+	mali_kbase_gpuprops.c \
+	mali_kbase_js.c \
+	mali_kbase_js_affinity.c \
+	mali_kbase_js_ctx_attr.c \
+	mali_kbase_event.c \
+	mali_kbase_context.c \
+	mali_kbase_pm.c \
+	mali_kbase_pm_driver.c \
+	mali_kbase_pm_metrics.c \
+	mali_kbase_pm_ca.c \
+	mali_kbase_pm_ca_fixed.c \
+	mali_kbase_pm_always_on.c \
+	mali_kbase_pm_coarse_demand.c \
+	mali_kbase_pm_demand.c \
+	mali_kbase_pm_policy.c \
+	mali_kbase_config.c \
+	mali_kbase_security.c \
+	mali_kbase_instr.c \
+	mali_kbase_softjobs.c \
+	mali_kbase_10969_workaround.c \
+	mali_kbase_hw.c \
+	mali_kbase_utility.c \
+	mali_kbase_mem_lowlevel.c \
+	mali_kbase_debug.c \
+	mali_kbase_trace_timeline.c \
+	mali_kbase_gpu_memory_debugfs.c \
+	mali_kbase_mem_linux.c \
+	mali_kbase_core_linux.c \
+	mali_kbase_sync.c \
+	mali_kbase_sync_user.c \
+	mali_kbase_replay.c \
+
+ifeq ($(MALI_CUSTOMER_RELEASE),0)
+SRC += \
+     mali_kbase_pm_ca_random.c \
+     mali_kbase_pm_demand_always_powered.c \
+     mali_kbase_pm_fast_start.c
+endif
+
+# Job Scheduler Policy: Completely Fair Scheduler
+SRC += mali_kbase_js_policy_cfs.c
+
+ifeq ($(CONFIG_MACH_MANTA),y)
+	SRC += mali_kbase_mem_alloc_carveout.c
+else
+	SRC += mali_kbase_mem_alloc.c
+endif
+
+# ensure GPL version of malisw gets pulled in
+ccflags-y += -I$(KBASE_PATH)
+
+ifeq ($(CONFIG_MALI_NO_MALI),y)
+	# Dummy model
+	SRC += mali_kbase_model_dummy.c
+	SRC += mali_kbase_model_linux.c
+	# HW error simulation
+	SRC += mali_kbase_model_error_generator.c
+endif
+
+ifeq ($(MALI_MOCK_TEST),1)
+	# Test functionality
+	SRC += tests/internal/src/mock/mali_kbase_pm_driver_mock.c
+endif
+
+# in-tree/out-of-tree logic needs to be slightly different to determine if a file is present
+ifeq ($(KBUILD_EXTMOD),)
+# in-tree
+MALI_METRICS_PATH = $(srctree)/drivers/gpu/arm/midgard
+else
+# out-of-tree
+MALI_METRICS_PATH = $(KBUILD_EXTMOD)
+endif
+
+# Use vsync metrics example using PL111 driver, if available
+ifeq ($(wildcard $(MALI_METRICS_PATH)/mali_kbase_pm_metrics_linux.c),)
+	SRC += mali_kbase_pm_metrics_dummy.c
+else
+	SRC += mali_kbase_pm_metrics_linux.c
+endif
+
+ifeq ($(CONFIG_MALI_PLATFORM_FAKE),y)
+	SRC += mali_kbase_platform_fake.c
+
+	ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS),y)
+		SRC += platform/vexpress/mali_kbase_config_vexpress.c \
+		platform/vexpress/mali_kbase_cpu_vexpress.c
+	endif
+
+	ifeq ($(CONFIG_MALI_PLATFORM_RTSM_VE),y)
+		SRC += platform/rtsm_ve/mali_kbase_config_vexpress.c
+	endif
+
+	ifeq ($(CONFIG_MALI_PLATFORM_JUNO),y)
+		SRC += platform/juno/mali_kbase_config_vexpress.c
+	endif
+
+	ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS_VIRTEX7_40MHZ),y)
+		SRC += platform/vexpress_virtex7_40mhz/mali_kbase_config_vexpress.c \
+		platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.c
+	endif
+
+	ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS_6XVIRTEX7_10MHZ),y)
+		SRC += platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c \
+		platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c
+	endif
+
+	ifeq ($(CONFIG_MALI_PLATFORM_GOLDFISH),y)
+		SRC += platform/goldfish/mali_kbase_config_goldfish.c
+	endif
+
+	ifeq ($(CONFIG_MALI_PLATFORM_PBX),y)
+		SRC += platform/pbx/mali_kbase_config_pbx.c
+	endif
+
+	ifeq ($(CONFIG_MALI_PLATFORM_PANDA),y)
+		SRC += platform/panda/mali_kbase_config_panda.c
+	endif
+
+	ifeq ($(CONFIG_MALI_PLATFORM_THIRDPARTY),y)
+	ifeq ($(CONFIG_MALI_MIDGARD),m)
+	# remove begin and end quotes from the Kconfig string type
+	platform_name := $(shell echo $(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME))
+	MALI_PLATFORM_THIRDPARTY_DIR := platform/$(platform_name)
+	include  $(src)/platform/$(platform_name)/Kbuild
+	else ifeq ($(CONFIG_MALI_MIDGARD),y)
+	obj-$(CONFIG_MALI_MIDGARD) += platform/
+	endif
+	endif
+endif # CONFIG_MALI_PLATFORM_FAKE=y
+
+ifeq ($(CONFIG_MALI_PLATFORM_THIRDPARTY),y)
+ifeq ($(CONFIG_MALI_MIDGARD),m)
+# remove begin and end quotes from the Kconfig string type
+platform_name := $(shell echo $(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME))
+MALI_PLATFORM_THIRDPARTY_DIR := platform/$(platform_name)
+include  $(src)/platform/$(platform_name)/Kbuild
+else ifeq ($(CONFIG_MALI_MIDGARD),y)
+obj-$(CONFIG_MALI_MIDGARD) += platform/
+endif
+endif
+
+# Tell the Linux build system from which .o file to create the kernel module
+obj-$(CONFIG_MALI_MIDGARD) += mali_kbase.o
+
+# Tell the Linux build system to enable building of our .c files
+mali_kbase-y := $(SRC:.c=.o)
+
+
diff --git a/drivers/gpu/arm/t6xx/kbase/Kconfig b/drivers/gpu/arm/midgard/Kconfig
old mode 100644
new mode 100755
similarity index 73%
rename from drivers/gpu/arm/t6xx/kbase/Kconfig
rename to drivers/gpu/arm/midgard/Kconfig
index cc2e50fca65c..71be8bbe0d18
--- a/drivers/gpu/arm/t6xx/kbase/Kconfig
+++ b/drivers/gpu/arm/midgard/Kconfig
@@ -14,58 +14,58 @@
 
 
 
-menuconfig MALI_T6XX
-	tristate "Mali-T6XX support"
+menuconfig MALI_MIDGARD
+	tristate "Mali Midgard series support"
 	default n
 	help
-	  Enable this option to build support for the ARM Mali-T6XX GPU.
+	  Enable this option to build support for a ARM Mali Midgard GPU.
 
 	  To compile this driver as a module, choose M here:
 	  this will generate a single module, called mali_kbase.
 
 config MALI_GATOR_SUPPORT
 	bool "Streamline Debug support"
-	depends on MALI_T6XX
+	depends on MALI_MIDGARD
 	default n
 	help
 	  Adds diagnostic support for use with the ARM Streamline Performance Analyzer.
 	  You will need the Gator device driver already loaded before loading this driver when enabling
 	  Streamline debug support.
 
-config MALI_T6XX_DVFS
+config MALI_MIDGARD_DVFS
 	bool "Enable DVFS"
-	depends on MALI_T6XX
+	depends on MALI_MIDGARD
 	default n
 	help
-	  Choose this option to enable DVFS on MALI T6XX DDK.
+	  Choose this option to enable DVFS in the Mali Midgard DDK.
 
-config MALI_T6XX_RT_PM
+config MALI_MIDGARD_RT_PM
 	bool "Enable Runtime power management"
-	depends on MALI_T6XX
+	depends on MALI_MIDGARD
 	depends on PM_RUNTIME
 	default n
 	help
-	  Choose this option to enable runtime power management on MALI T6XX DDK.
+	  Choose this option to enable runtime power management in the Mali Midgard DDK.
 
-config MALI_T6XX_ENABLE_TRACE
+config MALI_MIDGARD_ENABLE_TRACE
 	bool "Enable kbase tracing"
-	depends on MALI_T6XX
+	depends on MALI_MIDGARD
 	default n
 	help
 	  Enables tracing in kbase.  Trace log available through
 	  the "mali_trace" debugfs file, when the CONFIG_DEBUG_FS is enabled
 
-config MALI_T6XX_DEBUG_SYS
-	bool "Enable sysfs for mali t6xx"
-	depends on MALI_T6XX && SYSFS
+config MALI_MIDGARD_DEBUG_SYS
+	bool "Enable sysfs for the Mali Midgard DDK "
+	depends on MALI_MIDGARD && SYSFS
 	default n
 	help
-	  Enables sysfs for mali t6xx device. Set/Monitor Mali T6xx Device
+	  Enables sysfs for the Mali Midgard DDK. Set/Monitor the Mali Midgard DDK
 
 # MALI_EXPERT configuration options
 
 menuconfig MALI_EXPERT
-	depends on MALI_T6XX
+	depends on MALI_MIDGARD
 	bool "Enable Expert Settings"
 	default n
 	help
@@ -74,28 +74,28 @@ menuconfig MALI_EXPERT
 
 config MALI_DEBUG_SHADER_SPLIT_FS
 	bool "Allow mapping of shader cores via sysfs"
-	depends on MALI_T6XX && MALI_T6XX_DEBUG_SYS && MALI_EXPERT
+	depends on MALI_MIDGARD && MALI_MIDGARD_DEBUG_SYS && MALI_EXPERT
 	default n
 	help
 	  Select this option to provide a sysfs entry for runtime configuration of shader
 	  core affinity masks.
 
 config MALI_PLATFORM_FAKE
-	tristate "Enable fake platform device support"
-	depends on MALI_T6XX && MALI_EXPERT
+	bool "Enable fake platform device support"
+	depends on MALI_MIDGARD && MALI_EXPERT
 	default n
 	help
-	  When you start to work with the Mali-T600 Series device driver the platform-specific code of
+	  When you start to work with the Mali Midgard series device driver the platform-specific code of
 	  the Linux kernel for your platform may not be complete. In this situation the kernel device driver
 	  supports creating the platform device outside of the Linux platform-specific code.
 	  Enable this option if would like to use a platform device configuration from within the device driver.
 
 choice
 	prompt "Platform configuration"
-	depends on MALI_T6XX && MALI_EXPERT
+	depends on MALI_MIDGARD && MALI_EXPERT
 	default MALI_PLATFORM_VEXPRESS
 	help
-	  Select the SOC platform that contains a Mali-T6XX
+	  Select the SOC platform that contains a Mali Midgard GPU
 
 config MALI_PLATFORM_VEXPRESS
 	depends on ARCH_VEXPRESS && (ARCH_VEXPRESS_CA9X4 || ARCH_VEXPRESS_CA15X4)
@@ -114,23 +114,23 @@ config MALI_PLATFORM_THIRDPARTY
 endchoice
 
 config MALI_PLATFORM_THIRDPARTY_NAME
-	depends on MALI_T6XX && MALI_PLATFORM_THIRDPARTY && MALI_EXPERT
+	depends on MALI_MIDGARD && MALI_PLATFORM_THIRDPARTY && MALI_EXPERT
 	string "Third party platform name"
 	help
 	  Enter the name of a third party platform that is supported. The third part configuration
-	  file must be in kbase/src/linux/config/tpip/mali_kbase_config_xxx.c where xxx is the name
+	  file must be in midgard/config/tpip/mali_kbase_config_xxx.c where xxx is the name
 	  specified here.
 
 config MALI_DEBUG
 	bool "Debug build"
-	depends on MALI_T6XX && MALI_EXPERT
+	depends on MALI_MIDGARD && MALI_EXPERT
 	default n
 	help
 	  Select this option for increased checking and reporting of errors.
 
 config MALI_NO_MALI
 	bool "No Mali"
-	depends on MALI_T6XX && MALI_EXPERT
+	depends on MALI_MIDGARD && MALI_EXPERT
 	default n
 	help
 	  This can be used to test the driver in a simulated environment
@@ -142,21 +142,21 @@ config MALI_NO_MALI
 
 config MALI_ERROR_INJECT
 	bool "Error injection"
-	depends on MALI_T6XX && MALI_EXPERT && MALI_NO_MALI
+	depends on MALI_MIDGARD && MALI_EXPERT && MALI_NO_MALI
 	default n
 	help
 	  Enables insertion of errors to test module failure and recovery mechanisms.
 
 config MALI_TRACE_TIMELINE
 	bool "Timeline tracing"
-	depends on MALI_T6XX && MALI_EXPERT
+	depends on MALI_MIDGARD && MALI_EXPERT
 	default n
 	help
 	  Enables timeline tracing through the kernel tracepoint system.
 
 config MALI_SYSTEM_TRACE
 	bool "Enable system event tracing support"
-	depends on MALI_T6XX && MALI_EXPERT
+	depends on MALI_MIDGARD && MALI_EXPERT
 	default n
 	help
 	  Choose this option to enable system trace events for each
@@ -166,9 +166,9 @@ config MALI_SYSTEM_TRACE
 
 config MALI_GPU_TRACEPOINTS
 	bool "Enable GPU tracepoints"
-	depends on MALI_T6XX && ANDROID
+	depends on MALI_MIDGARD && ANDROID
 	select GPU_TRACEPOINTS
 	help
 	  Enables GPU tracepoints using Android trace event definitions.
 
-source "drivers/gpu/arm/t6xx/kbase/src/platform/Kconfig"
+source "drivers/gpu/arm/midgard/platform/Kconfig"
diff --git a/drivers/gpu/arm/t6xx/kbase/src/Makefile b/drivers/gpu/arm/midgard/Makefile
old mode 100644
new mode 100755
similarity index 76%
rename from drivers/gpu/arm/t6xx/kbase/src/Makefile
rename to drivers/gpu/arm/midgard/Makefile
index a6d98a165dce..9820be2b4446
--- a/drivers/gpu/arm/t6xx/kbase/src/Makefile
+++ b/drivers/gpu/arm/midgard/Makefile
@@ -1,5 +1,5 @@
 #
-# (C) COPYRIGHT 2010-2012 ARM Limited. All rights reserved.
+# (C) COPYRIGHT 2010-2013 ARM Limited. All rights reserved.
 #
 # This program is free software and is provided to you under the terms of the
 # GNU General Public License version 2 as published by the Free Software
@@ -16,9 +16,9 @@
 
 KDIR ?= /lib/modules/$(shell uname -r)/build
 
-UMP_PATH_RELATIVE = $(CURDIR)/../../../../../base/ump
-KBASE_PATH_RELATIVE = $(CURDIR)/../../kbase
-KDS_PATH_RELATIVE = $(CURDIR)/../../../../../..
+UMP_PATH_RELATIVE = $(CURDIR)/../../../base/ump
+KBASE_PATH_RELATIVE = $(CURDIR)
+KDS_PATH_RELATIVE = $(CURDIR)/../../../..
 EXTRA_SYMBOLS = $(UMP_PATH_RELATIVE)/src/Module.symvers
 
 ifeq ($(MALI_UNIT_TEST), 1)
@@ -30,7 +30,7 @@ EXTRA_SYMBOLS += $(KDS_PATH_RELATIVE)/drivers/base/kds/Module.symvers
 
 # we get the symbols from modules using KBUILD_EXTRA_SYMBOLS to prevent warnings about unknown functions
 all:
-	$(MAKE) -C $(KDIR) M=$(CURDIR) EXTRA_CFLAGS="-I$(CURDIR)/../../../../../../include $(SCONS_CFLAGS)" $(SCONS_CONFIGS) KBUILD_EXTRA_SYMBOLS="$(EXTRA_SYMBOLS)" modules
+	$(MAKE) -C $(KDIR) M=$(CURDIR) EXTRA_CFLAGS="-I$(CURDIR)/../../../../include $(SCONS_CFLAGS)" $(SCONS_CONFIGS) KBUILD_EXTRA_SYMBOLS="$(EXTRA_SYMBOLS)" modules
 
 clean:
 	$(MAKE) -C $(KDIR) M=$(CURDIR) clean
diff --git a/drivers/gpu/arm/t6xx/kbase/src/Makefile.kbase b/drivers/gpu/arm/midgard/Makefile.kbase
old mode 100644
new mode 100755
similarity index 81%
rename from drivers/gpu/arm/t6xx/kbase/src/Makefile.kbase
rename to drivers/gpu/arm/midgard/Makefile.kbase
index aab2cd00d154..2bef9c25eaeb
--- a/drivers/gpu/arm/t6xx/kbase/src/Makefile.kbase
+++ b/drivers/gpu/arm/midgard/Makefile.kbase
@@ -13,5 +13,5 @@
 #
 
 
-EXTRA_CFLAGS += -I$(ROOT) -I$(KBASE_PATH)/.. -I$(OSK_PATH)/src/linux/include -I$(KBASE_PATH)/platform_$(PLATFORM)
+EXTRA_CFLAGS += -I$(ROOT) -I$(KBASE_PATH) -I$(OSK_PATH)/src/linux/include -I$(KBASE_PATH)/platform_$(PLATFORM)
 
diff --git a/drivers/gpu/arm/t6xx/kbase/docs/Doxyfile b/drivers/gpu/arm/midgard/docs/Doxyfile
old mode 100644
new mode 100755
similarity index 86%
rename from drivers/gpu/arm/t6xx/kbase/docs/Doxyfile
rename to drivers/gpu/arm/midgard/docs/Doxyfile
index 6a7278e45016..e2662c2dfaeb
--- a/drivers/gpu/arm/t6xx/kbase/docs/Doxyfile
+++ b/drivers/gpu/arm/midgard/docs/Doxyfile
@@ -32,7 +32,7 @@
 # directories like "/usr/src/myproject". Separate the files or directories
 # with spaces.
 
-INPUT                  += ../../kernel/drivers/gpu/arm/t6xx/kbase/src/common/ ../../kernel/drivers/gpu/arm/t6xx/kbase/mali_base_kernel.h ../../kernel/drivers/gpu/arm/t6xx/kbase/src/mali_base_mem_priv.h ../../kernel/drivers/gpu/arm/t6xx/kbase/mali_kbase_config.h
+INPUT                  += ../../kernel/drivers/gpu/arm/midgard/ 
 
 ##############################################################################
 # Everything below here is optional, and in most cases not required
@@ -64,8 +64,8 @@ FILE_PATTERNS          +=
 # The EXCLUDE tag can be used to specify files and/or directories that should
 # excluded from the INPUT source files. This way you can easily exclude a
 # subdirectory from a directory tree whose root is specified with the INPUT tag.
+EXCLUDE                += ../../kernel/drivers/gpu/arm/midgard/malisw/ ../../kernel/drivers/gpu/arm/midgard/platform ../../kernel/drivers/gpu/arm/midgard/platform_dummy ../../kernel/drivers/gpu/arm/midgard/scripts ../../kernel/drivers/gpu/arm/midgard/tests ../../kernel/drivers/gpu/arm/midgard/Makefile ../../kernel/drivers/gpu/arm/midgard/Makefile.kbase ../../kernel/drivers/gpu/arm/midgard/Kbuild ../../kernel/drivers/gpu/arm/midgard/Kconfig ../../kernel/drivers/gpu/arm/midgard/sconscript ../../kernel/drivers/gpu/arm/midgard/docs ../../kernel/drivers/gpu/arm/midgard/pm_test_script.sh ../../kernel/drivers/gpu/arm/midgard/mali_uk.h ../../kernel/drivers/gpu/arm/midgard/Makefile
 
-EXCLUDE                +=
 
 # If the value of the INPUT tag contains directories, you can use the
 # EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
@@ -122,5 +122,5 @@ EXPAND_AS_DEFINED      +=
 # contain dot files that are included in the documentation (see the
 # \dotfile command).
 
-DOTFILE_DIRS           += ../../kernel/drivers/gpu/arm/t6xx/kbase/docs
+DOTFILE_DIRS           += ../../kernel/drivers/gpu/arm/midgard/docs
 
diff --git a/drivers/gpu/arm/t6xx/kbase/docs/policy_operation_diagram.dot b/drivers/gpu/arm/midgard/docs/policy_operation_diagram.dot
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/docs/policy_operation_diagram.dot
rename to drivers/gpu/arm/midgard/docs/policy_operation_diagram.dot
diff --git a/drivers/gpu/arm/t6xx/kbase/docs/policy_overview.dot b/drivers/gpu/arm/midgard/docs/policy_overview.dot
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/docs/policy_overview.dot
rename to drivers/gpu/arm/midgard/docs/policy_overview.dot
diff --git a/drivers/gpu/arm/t6xx/kbase/mali_base_hwconfig.h b/drivers/gpu/arm/midgard/mali_base_hwconfig.h
old mode 100644
new mode 100755
similarity index 86%
rename from drivers/gpu/arm/t6xx/kbase/mali_base_hwconfig.h
rename to drivers/gpu/arm/midgard/mali_base_hwconfig.h
index f8d257bc0f9b..d770cfdd91a8
--- a/drivers/gpu/arm/t6xx/kbase/mali_base_hwconfig.h
+++ b/drivers/gpu/arm/midgard/mali_base_hwconfig.h
@@ -233,7 +233,6 @@ typedef enum base_hw_issue {
 	BASE_HW_ISSUE_10684,
 
 	/* Chicken bit on (t67x_r1p0 and t72x) to work for a HW workaround in compiler */
-
 	BASE_HW_ISSUE_10797,
 
 	/* Soft-stopping fragment jobs might fail with TILE_RANGE_FAULT */
@@ -258,22 +257,34 @@ typedef enum base_hw_issue {
 	/* Soft-stopped fragment shader job can restart with out-of-bound restart index  */
 	BASE_HW_ISSUE_10969,
 
+	/* Instanced arrays conformance fail, workaround by unrolling */
+	BASE_HW_ISSUE_10984,
+
 	/* TEX_INDEX lod selection (immediate , register) not working with 8.8 encoding for levels > 1 */
 	/* NOTE: compiler workaround: keep in sync with _essl_hwrev_needs_workaround() */
 	BASE_HW_ISSUE_10995,
 
+	/* LD_SPECIAL instruction reads incorrect RAW tile buffer value when internal tib format is RGB565 or RGBA5551 */
+	BASE_HW_ISSUE_11012,
+
+	/* Race condition can cause tile list corruption */
+	BASE_HW_ISSUE_11020,
+
+	/* Write buffer can cause tile list corruption */
+	BASE_HW_ISSUE_11024,
+
 	/* T76X hw issues */
 
-	/* 16xMSAA implementation wasn't finished */
+	/* Partial 16xMSAA support */
 	BASE_HW_ISSUE_T76X_26,
 
 	/* Forward pixel kill doesn't work with MRT */
 	BASE_HW_ISSUE_T76X_2121,
 
-    /* CRC not working with MFBD and more than one render target */
+	/* CRC not working with MFBD and more than one render target */
 	BASE_HW_ISSUE_T76X_2315,
 
-    /* Some indexed formats not supported for MFBD preload. */
+	/* Some indexed formats not supported for MFBD preload. */
 	BASE_HW_ISSUE_T76X_2686,
 
 	/* Must disable CRC if the tile output size is 8 bytes or less. */
@@ -288,6 +299,25 @@ typedef enum base_hw_issue {
 	/* Prevent MMU deadlock for T76X beta. */
 	BASE_HW_ISSUE_T76X_3285,
 
+	/* Clear encoder state for a hard stopped fragment job which is AFBC
+	 * encoded by soft resetting the GPU. Only for T76X r0p0 and r0p1
+	 */
+	BASE_HW_ISSUE_T76X_3542,
+
+	/* Do not use 8xMSAA with 16x8 pixel tile size or 16xMSAA with 8x8 pixel
+	 * tile size.
+	 */
+	BASE_HW_ISSUE_T76X_3556,
+
+	/* T76X cannot disable uses_discard even if depth and stencil are read-only. */
+	BASE_HW_ISSUE_T76X_3700,
+
+	/* ST_TILEBUFFER is not supported on T76X-r0p0-beta */
+	BASE_HW_ISSUE_T76X_3759,
+
+	/* Preload ignores any size or bounding box restrictions of the output image. */
+	BASE_HW_ISSUE_T76X_3793,
+
 	/* The BASE_HW_ISSUE_END value must be the last issue listed in this enumeration
 	 * and must be the last value in each array that contains the list of workarounds
 	 * for a particular HW version.
@@ -350,7 +380,10 @@ static const base_hw_issue base_hw_issues_t60x_r0p0_15dev0[] = {
 	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
 	BASE_HW_ISSUE_10969,
+	BASE_HW_ISSUE_10984,
 	BASE_HW_ISSUE_10995,
+	BASE_HW_ISSUE_11012,
+	BASE_HW_ISSUE_11020,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
@@ -385,6 +418,8 @@ static const base_hw_issue base_hw_issues_t60x_r0p0_eac[] = {
 	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
 	BASE_HW_ISSUE_10969,
+	BASE_HW_ISSUE_11012,
+	BASE_HW_ISSUE_11020,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
@@ -416,23 +451,19 @@ static const base_hw_issue base_hw_issues_t60x_r0p1[] = {
 	BASE_HW_ISSUE_10883,
 	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
+	BASE_HW_ISSUE_11012,
+	BASE_HW_ISSUE_11020,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T65x r0p1 */
-static const base_hw_issue base_hw_issues_t65x_r0p1[] = {
-	BASE_HW_ISSUE_6367,
+/* Mali T62x r0p1 */
+static const base_hw_issue base_hw_issues_t62x_r0p1[] = {
 	BASE_HW_ISSUE_6402,
-	BASE_HW_ISSUE_6787,
-	BASE_HW_ISSUE_7027,
-	BASE_HW_ISSUE_8408,
-	BASE_HW_ISSUE_8564,
 	BASE_HW_ISSUE_8803,
-	BASE_HW_ISSUE_9010,
-	BASE_HW_ISSUE_9275,
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_9510,
+	BASE_HW_ISSUE_10127,
+	BASE_HW_ISSUE_10327,
 	BASE_HW_ISSUE_10410,
 	BASE_HW_ISSUE_10471,
 	BASE_HW_ISSUE_10472,
@@ -443,202 +474,183 @@ static const base_hw_issue base_hw_issues_t65x_r0p1[] = {
 	BASE_HW_ISSUE_10676,
 	BASE_HW_ISSUE_10682,
 	BASE_HW_ISSUE_10684,
+	BASE_HW_ISSUE_10817,
+	BASE_HW_ISSUE_10821,
 	BASE_HW_ISSUE_10883,
 	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
+	BASE_HW_ISSUE_10959,
+	BASE_HW_ISSUE_11012,
+	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11024,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T62x r0p0 */
-static const base_hw_issue base_hw_issues_t62x_r0p0[] = {
+/* Mali T62x r1p0 */
+static const base_hw_issue base_hw_issues_t62x_r1p0[] = {
 	BASE_HW_ISSUE_6402,
 	BASE_HW_ISSUE_8803,
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_10127,
-	BASE_HW_ISSUE_10327,
-	BASE_HW_ISSUE_10410,
 	BASE_HW_ISSUE_10471,
 	BASE_HW_ISSUE_10472,
-	BASE_HW_ISSUE_10487,
-	BASE_HW_ISSUE_10607,
-	BASE_HW_ISSUE_10632,
 	BASE_HW_ISSUE_10649,
-	BASE_HW_ISSUE_10676,
-	BASE_HW_ISSUE_10682,
 	BASE_HW_ISSUE_10684,
-	BASE_HW_ISSUE_10817,
 	BASE_HW_ISSUE_10821,
 	BASE_HW_ISSUE_10883,
 	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
 	BASE_HW_ISSUE_10959,
+	BASE_HW_ISSUE_11012,
+	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11024,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T67x r0p0 */
-static const base_hw_issue base_hw_issues_t67x_r0p0[] = {
+/* Mali T67x r1p0 */
+static const base_hw_issue base_hw_issues_t67x_r1p0[] = {
 	BASE_HW_ISSUE_6402,
 	BASE_HW_ISSUE_8803,
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_10127,
-	BASE_HW_ISSUE_10327,
-	BASE_HW_ISSUE_10410,
 	BASE_HW_ISSUE_10471,
 	BASE_HW_ISSUE_10472,
-	BASE_HW_ISSUE_10487,
-	BASE_HW_ISSUE_10607,
-	BASE_HW_ISSUE_10632,
 	BASE_HW_ISSUE_10649,
-	BASE_HW_ISSUE_10676,
-	BASE_HW_ISSUE_10682,
 	BASE_HW_ISSUE_10684,
-	BASE_HW_ISSUE_10817,
+	BASE_HW_ISSUE_10797,
 	BASE_HW_ISSUE_10821,
 	BASE_HW_ISSUE_10883,
 	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
 	BASE_HW_ISSUE_10959,
+	BASE_HW_ISSUE_11012,
+	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11024,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T62x r0p1 */
-static const base_hw_issue base_hw_issues_t62x_r0p1[] = {
-	BASE_HW_ISSUE_6402,
+/* Mali T76x r0p0 beta */
+static const base_hw_issue base_hw_issues_t76x_r0p0_beta[] = {
 	BASE_HW_ISSUE_8803,
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_10127,
-	BASE_HW_ISSUE_10327,
-	BASE_HW_ISSUE_10410,
-	BASE_HW_ISSUE_10471,
-	BASE_HW_ISSUE_10472,
-	BASE_HW_ISSUE_10487,
-	BASE_HW_ISSUE_10607,
-	BASE_HW_ISSUE_10632,
 	BASE_HW_ISSUE_10649,
-	BASE_HW_ISSUE_10676,
-	BASE_HW_ISSUE_10682,
-	BASE_HW_ISSUE_10684,
-	BASE_HW_ISSUE_10817,
 	BASE_HW_ISSUE_10821,
 	BASE_HW_ISSUE_10883,
-	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
 	BASE_HW_ISSUE_10959,
+	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11024,
+	BASE_HW_ISSUE_T76X_26,
+	BASE_HW_ISSUE_T76X_2121,
+	BASE_HW_ISSUE_T76X_2315,
+	BASE_HW_ISSUE_T76X_2686,
+	BASE_HW_ISSUE_T76X_2712,
+	BASE_HW_ISSUE_T76X_2772,
+	BASE_HW_ISSUE_T76X_2906,
+	BASE_HW_ISSUE_T76X_3285,
+	BASE_HW_ISSUE_T76X_3700,
+	BASE_HW_ISSUE_T76X_3759,
+	BASE_HW_ISSUE_T76X_3793,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T67x r0p1 */
-static const base_hw_issue base_hw_issues_t67x_r0p1[] = {
-	BASE_HW_ISSUE_6402,
+/* Mali T76x r0p0 */
+static const base_hw_issue base_hw_issues_t76x_r0p0[] = {
 	BASE_HW_ISSUE_8803,
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_10127,
-	BASE_HW_ISSUE_10327,
-	BASE_HW_ISSUE_10410,
-	BASE_HW_ISSUE_10471,
-	BASE_HW_ISSUE_10472,
-	BASE_HW_ISSUE_10487,
-	BASE_HW_ISSUE_10607,
-	BASE_HW_ISSUE_10632,
 	BASE_HW_ISSUE_10649,
-	BASE_HW_ISSUE_10676,
-	BASE_HW_ISSUE_10682,
-	BASE_HW_ISSUE_10684,
-	BASE_HW_ISSUE_10817,
 	BASE_HW_ISSUE_10821,
 	BASE_HW_ISSUE_10883,
-	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
-	BASE_HW_ISSUE_10959,
+	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11024,
+	BASE_HW_ISSUE_T76X_26,
+	BASE_HW_ISSUE_T76X_3542,
+	BASE_HW_ISSUE_T76X_3556,
+	BASE_HW_ISSUE_T76X_3700,
+	BASE_HW_ISSUE_T76X_3793,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T62x r1p0 */
-static const base_hw_issue base_hw_issues_t62x_r1p0[] = {
-	BASE_HW_ISSUE_6402,
+/* Mali T76x r0p1 */
+static const base_hw_issue base_hw_issues_t76x_r0p1[] = {
 	BASE_HW_ISSUE_8803,
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_10471,
-	BASE_HW_ISSUE_10472,
 	BASE_HW_ISSUE_10649,
-	BASE_HW_ISSUE_10684,
 	BASE_HW_ISSUE_10821,
 	BASE_HW_ISSUE_10883,
-	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
-	BASE_HW_ISSUE_10959,
+	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11024,
+	BASE_HW_ISSUE_T76X_26,
+	BASE_HW_ISSUE_T76X_3542,
+	BASE_HW_ISSUE_T76X_3556,
+	BASE_HW_ISSUE_T76X_3700,
+	BASE_HW_ISSUE_T76X_3793,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T67x r1p0 */
-static const base_hw_issue base_hw_issues_t67x_r1p0[] = {
-	BASE_HW_ISSUE_6402,
+/* Mali T76x r0p2 */
+static const base_hw_issue base_hw_issues_t76x_r0p2[] = {
 	BASE_HW_ISSUE_8803,
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_10471,
-	BASE_HW_ISSUE_10472,
 	BASE_HW_ISSUE_10649,
-	BASE_HW_ISSUE_10684,
-	BASE_HW_ISSUE_10797,
 	BASE_HW_ISSUE_10821,
 	BASE_HW_ISSUE_10883,
-	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
-	BASE_HW_ISSUE_10959,
+	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11024,
+	BASE_HW_ISSUE_T76X_26,
+	BASE_HW_ISSUE_T76X_3542,
+	BASE_HW_ISSUE_T76X_3556,
+	BASE_HW_ISSUE_T76X_3700,
+	BASE_HW_ISSUE_T76X_3793,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T76x r0p0 beta */
-static const base_hw_issue base_hw_issues_t76x_r0p0_beta[] = {
+/* Mali T76x r1p0 */
+static const base_hw_issue base_hw_issues_t76x_r1p0[] = {
 	BASE_HW_ISSUE_8803,
 	BASE_HW_ISSUE_9435,
 	BASE_HW_ISSUE_10649,
 	BASE_HW_ISSUE_10821,
 	BASE_HW_ISSUE_10883,
 	BASE_HW_ISSUE_10946,
-	BASE_HW_ISSUE_10959,
-	BASE_HW_ISSUE_T76X_26,
-	BASE_HW_ISSUE_T76X_2121,
-	BASE_HW_ISSUE_T76X_2315,
-	BASE_HW_ISSUE_T76X_2686,
-	BASE_HW_ISSUE_T76X_2712,
-	BASE_HW_ISSUE_T76X_2772,
-	BASE_HW_ISSUE_T76X_2906,
-	BASE_HW_ISSUE_T76X_3285,
-    /* List of hardware issues must end with BASE_HW_ISSUE_END */
+	BASE_HW_ISSUE_T76X_3700,
+	BASE_HW_ISSUE_T76X_3793,
+	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T76x r0p0 */
-static const base_hw_issue base_hw_issues_t76x_r0p0[] = {
+
+/* Mali T72x r0p0 */
+static const base_hw_issue base_hw_issues_t72x_r0p0[] = {
+	BASE_HW_ISSUE_6402,
 	BASE_HW_ISSUE_8803,
 	BASE_HW_ISSUE_9435,
+	BASE_HW_ISSUE_10471,
 	BASE_HW_ISSUE_10649,
+	BASE_HW_ISSUE_10684,
+	BASE_HW_ISSUE_10797,
 	BASE_HW_ISSUE_10821,
 	BASE_HW_ISSUE_10883,
+	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
-	BASE_HW_ISSUE_10959,
-	BASE_HW_ISSUE_T76X_26,
-	BASE_HW_ISSUE_T76X_2712,
-	BASE_HW_ISSUE_T76X_3285,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
 
-/* Mali T72x r0p0 */
-static const base_hw_issue base_hw_issues_t72x_r0p0[] = {
+/* Mali T72x r1p0 */
+static const base_hw_issue base_hw_issues_t72x_r1p0[] = {
 	BASE_HW_ISSUE_6402,
 	BASE_HW_ISSUE_8803,
-	BASE_HW_ISSUE_8975,
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_10472,
+	BASE_HW_ISSUE_10471,
 	BASE_HW_ISSUE_10649,
 	BASE_HW_ISSUE_10684,
 	BASE_HW_ISSUE_10797,
@@ -646,7 +658,6 @@ static const base_hw_issue base_hw_issues_t72x_r0p0[] = {
 	BASE_HW_ISSUE_10883,
 	BASE_HW_ISSUE_10931,
 	BASE_HW_ISSUE_10946,
-	BASE_HW_ISSUE_10959,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
@@ -659,8 +670,7 @@ static const base_hw_issue base_hw_issues_model_t72x[] =
 	BASE_HW_ISSUE_6402, /* NOTE: Fix is present in model r125162 but is not enabled until RTL is fixed */
 	BASE_HW_ISSUE_9275,
 	BASE_HW_ISSUE_9435,
-	BASE_HW_ISSUE_10472,
-	BASE_HW_ISSUE_10632,
+	BASE_HW_ISSUE_10471,
 	BASE_HW_ISSUE_10797,
 	BASE_HW_ISSUE_10931,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
@@ -673,6 +683,10 @@ static const base_hw_issue base_hw_issues_model_t7xx[] =
 	BASE_HW_ISSUE_9275,
 	BASE_HW_ISSUE_9435,
 	BASE_HW_ISSUE_10931,
+	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11024,
+	BASE_HW_ISSUE_T76X_3700,
+	BASE_HW_ISSUE_T76X_3793,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
@@ -684,8 +698,10 @@ static const base_hw_issue base_hw_issues_model_t6xx[] =
 	BASE_HW_ISSUE_9275,
 	BASE_HW_ISSUE_9435,
 	BASE_HW_ISSUE_10472,
-	BASE_HW_ISSUE_10632,
 	BASE_HW_ISSUE_10931,
+	BASE_HW_ISSUE_11012,
+	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11024,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
diff --git a/drivers/gpu/arm/t6xx/kbase/mali_base_kernel.h b/drivers/gpu/arm/midgard/mali_base_kernel.h
old mode 100644
new mode 100755
similarity index 90%
rename from drivers/gpu/arm/t6xx/kbase/mali_base_kernel.h
rename to drivers/gpu/arm/midgard/mali_base_kernel.h
index 286c83b448fa..4aff2bdf270b
--- a/drivers/gpu/arm/t6xx/kbase/mali_base_kernel.h
+++ b/drivers/gpu/arm/midgard/mali_base_kernel.h
@@ -30,8 +30,8 @@
 
 typedef mali_addr64 base_mem_handle;
 
-#include <kbase/src/mali_base_mem_priv.h>
-#include <kbase/src/mali_kbase_profiling_gator_api.h>
+#include "mali_base_mem_priv.h"
+#include "mali_kbase_profiling_gator_api.h"
 
 /*
  * Dependency stuff, keep it private for now. May want to expose it if
@@ -161,6 +161,23 @@ typedef enum base_mem_import_type {
 #define BASE_TMEM_IMPORT_TYPE_UMP      BASE_MEM_IMPORT_TYPE_UMP
 #define BASE_TMEM_IMPORT_TYPE_UMM      BASE_MEM_IMPORT_TYPE_UMM
 
+/**
+ * @brief Invalid memory handle type.
+ * Return value from functions returning @a base_mem_handle on error.
+ */
+#define BASE_MEM_INVALID_HANDLE                (0ull  << 12)
+#define BASE_MEM_MMU_DUMP_HANDLE               (1ull  << 12)
+#define BASE_MEM_TRACE_BUFFER_HANDLE           (2ull  << 12)
+#define BASE_MEM_MAP_TRACKING_HANDLE           (3ull  << 12)
+#define BASE_MEM_WRITE_ALLOC_PAGES_HANDLE      (4ull  << 12)
+/* reserved handles ..-64<<PAGE_SHIFT> for future special handles */
+#define BASE_MEM_COOKIE_BASE                   (64ul  << 12)
+#define BASE_MEM_FIRST_FREE_ADDRESS            ((BITS_PER_LONG << 12) + \
+						BASE_MEM_COOKIE_BASE)
+
+/* Bit mask of cookies used for for memory allocation setup */
+#define KBASE_COOKIE_MASK  ~1UL /* bit 0 is reserved */
+
 /**
  * @brief Number of bits used as flags for base memory management
  *
@@ -271,6 +288,33 @@ typedef struct base_jd_udata {
 	u64 blob[2];	 /**< per-job data array */
 } base_jd_udata;
 
+/**
+ * @brief Memory aliasing info
+ *
+ * Describes a memory handle to be aliased.
+ * A subset of the handle can be chosen for aliasing, given an offset and a
+ * length.
+ * A special handle BASE_MEM_WRITE_ALLOC_PAGES_HANDLE is used to represent a
+ * region where a special page is mapped with a write-alloc cache setup,
+ * typically used when the write result of the GPU isn't needed, but the GPU
+ * must write anyway.
+ *
+ * Offset and length are specified in pages.
+ * Offset must be within the size of the handle.
+ * Offset+length must not overrun the size of the handle.
+ *
+ * @handle Handle to alias, can be BASE_MEM_WRITE_ALLOC_PAGES_HANDLE
+ * @offset Offset within the handle to start aliasing from, in pages.
+ *         Not used with BASE_MEM_WRITE_ALLOC_PAGES_HANDLE.
+ * @length Length to alias, in pages. For BASE_MEM_WRITE_ALLOC_PAGES_HANDLE
+ *         specifies the number of times the special page is needed.
+ */
+struct base_mem_aliasing_info {
+	base_mem_handle handle;
+	u64 offset;
+	u64 length;
+};
+
 /**
  * @brief Job chain hardware requirements.
  *
@@ -303,6 +347,10 @@ typedef u16 base_jd_core_req;
 #define BASE_JD_REQ_V   (1U << 4)   /**< Requires value writeback */
 
 /* SW-only requirements - the HW does not expose these as part of the job slot capabilities */
+
+/* Requires fragment job with AFBC encoding */
+#define BASE_JD_REQ_FS_AFBC  (1U << 13)
+
 /**
  * SW Only requirement: the job chain requires a coherent core group. We don't
  * mind which coherent core group is used.
@@ -335,6 +383,44 @@ typedef u16 base_jd_core_req;
 #define BASE_JD_REQ_SOFT_FENCE_TRIGGER          (BASE_JD_REQ_SOFT_JOB | 0x2)
 #define BASE_JD_REQ_SOFT_FENCE_WAIT             (BASE_JD_REQ_SOFT_JOB | 0x3)
 
+/**
+ * SW Only requirement : Replay job.
+ *
+ * If the preceeding job fails, the replay job will cause the jobs specified in
+ * the list of base_jd_replay_payload pointed to by the jc pointer to be
+ * replayed.
+ *
+ * A replay job will only cause jobs to be replayed up to BASEP_JD_REPLAY_LIMIT
+ * times. If a job fails more than BASEP_JD_REPLAY_LIMIT times then the replay
+ * job is failed, as well as any following dependencies.
+ *
+ * The replayed jobs will require a number of atom IDs. If there are not enough
+ * free atom IDs then the replay job will fail.
+ *
+ * If the preceeding job does not fail, then the replay job is returned as
+ * completed.
+ *
+ * The replayed jobs will never be returned to userspace. The preceeding failed
+ * job will be returned to userspace as failed; the status of this job should
+ * be ignored. Completion should be determined by the status of the replay soft
+ * job.
+ *
+ * In order for the jobs to be replayed, the job headers will have to be
+ * modified. The Status field will be reset to NOT_STARTED. If the Job Type
+ * field indicates a Vertex Shader Job then it will be changed to Null Job.
+ *
+ * The replayed jobs have the following assumptions :
+ *
+ * - No external resources. Any required external resources will be held by the
+ *   replay atom.
+ * - Pre-dependencies are created based on job order.
+ * - Atom numbers are automatically assigned.
+ * - device_nr is set to 0. This is not relevant as
+ *   BASE_JD_REQ_SPECIFIC_COHERENT_GROUP should not be set.
+ * - Priority is inherited from the replay job.
+ */
+#define BASE_JD_REQ_SOFT_REPLAY                 (BASE_JD_REQ_SOFT_JOB | 0x4)
+
 /**
  * HW Requirement: Requires Compute shaders (but not Vertex or Geometry Shaders)
  *
@@ -367,21 +453,25 @@ typedef u16 base_jd_core_req;
  */
 #define BASE_JD_REQ_EVENT_ONLY_ON_FAILURE   (1U << 12)
 
+/**
+ * SW Flag: If this bit is set then completion of this atom will not cause an
+ * event to be sent to userspace, whether successful or not.
+ */
+#define BASEP_JD_REQ_EVENT_NEVER (1U << 14)
+
 /**
 * These requirement bits are currently unused in base_jd_core_req (currently a u16)
 */
 
-#define BASEP_JD_REQ_RESERVED_BIT5  (1U << 5)
-#define BASEP_JD_REQ_RESERVED_BIT13 (1U << 13)
-#define BASEP_JD_REQ_RESERVED_BIT14 (1U << 14)
+#define BASEP_JD_REQ_RESERVED_BIT5 (1U << 5)
 #define BASEP_JD_REQ_RESERVED_BIT15 (1U << 15)
 
 /**
 * Mask of all the currently unused requirement bits in base_jd_core_req.
 */
 
-#define BASEP_JD_REQ_RESERVED (BASEP_JD_REQ_RESERVED_BIT5 | BASEP_JD_REQ_RESERVED_BIT13 |\
-				BASEP_JD_REQ_RESERVED_BIT14 | BASEP_JD_REQ_RESERVED_BIT15)
+#define BASEP_JD_REQ_RESERVED (BASEP_JD_REQ_RESERVED_BIT5 | \
+				BASEP_JD_REQ_RESERVED_BIT15)
 
 /**
  * Mask of all bits in base_jd_core_req that control the type of the atom.
@@ -389,7 +479,7 @@ typedef u16 base_jd_core_req;
  * This allows dependency only atoms to have flags set
  */
 #define BASEP_JD_REQ_ATOM_TYPE (~(BASEP_JD_REQ_RESERVED | BASE_JD_REQ_EVENT_ONLY_ON_FAILURE |\
-				BASE_JD_REQ_EXTERNAL_RESOURCES))
+				BASE_JD_REQ_EXTERNAL_RESOURCES | BASEP_JD_REQ_EVENT_NEVER))
 
 #if BASE_LEGACY_JD_API
 /**
@@ -840,7 +930,7 @@ typedef struct base_jd_event_v2 {
 } base_jd_event_v2;
 
 /**
- * Padding required to ensure that the @ref basep_dump_cpu_gpu_counters structure fills
+ * Padding required to ensure that the @ref base_dump_cpu_gpu_counters structure fills
  * a full cache line.
  */
 
@@ -1572,6 +1662,78 @@ typedef struct base_cpu_props {
 } base_cpu_props;
 /** @} end group basecpuprops */
 
+/**
+ * @brief The payload for a replay job. This must be in GPU memory.
+ */
+typedef struct base_jd_replay_payload {
+	/**
+	 * Pointer to the first entry in the base_jd_replay_jc list.  These
+	 * will be replayed in @b reverse order (so that extra ones can be added
+	 * to the head in future soft jobs without affecting this soft job)
+	 */
+	mali_addr64 tiler_jc_list;
+
+	/**
+	 * Pointer to the fragment job chain.
+	 */
+	mali_addr64 fragment_jc;
+
+	/**
+	 * Pointer to the tiler heap free FBD field to be modified.
+	 */
+	mali_addr64 tiler_heap_free;
+
+	/**
+	 * Hierarchy mask for the replayed fragment jobs. May be zero.
+	 */
+	u16 fragment_hierarchy_mask;
+
+	/**
+	 * Hierarchy mask for the replayed tiler jobs. May be zero.
+	 */
+	u16 tiler_hierarchy_mask;
+
+	/**
+	 * Default weight to be used for hierarchy levels not in the original
+	 * mask.
+	 */
+	u32 hierarchy_default_weight;
+
+	/**
+	 * Core requirements for the tiler job chain
+	 */
+	base_jd_core_req tiler_core_req;
+
+	/**
+	 * Core requirements for the fragment job chain
+	 */
+	base_jd_core_req fragment_core_req;
+
+	u8 padding[4];
+} base_jd_replay_payload;
+
+/**
+ * @brief An entry in the linked list of job chains to be replayed. This must
+ *        be in GPU memory.
+ */
+typedef struct base_jd_replay_jc {
+	/**
+	 * Pointer to next entry in the list. A setting of NULL indicates the
+	 * end of the list.
+	 */
+	mali_addr64 next;
+
+	/**
+	 * Pointer to the job chain.
+	 */
+	mali_addr64 jc;
+
+} base_jd_replay_jc;
+
+/* Maximum number of jobs allowed in a fragment chain in the payload of a
+ * replay job */
+#define BASE_JD_REPLAY_F_CHAIN_JOB_LIMIT 256
+
 /** @} end group base_api */
 
 typedef struct base_profiling_controls {
diff --git a/drivers/gpu/arm/t6xx/kbase/mali_base_kernel_sync.h b/drivers/gpu/arm/midgard/mali_base_kernel_sync.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/mali_base_kernel_sync.h
rename to drivers/gpu/arm/midgard/mali_base_kernel_sync.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/mali_base_mem_priv.h b/drivers/gpu/arm/midgard/mali_base_mem_priv.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/mali_base_mem_priv.h
rename to drivers/gpu/arm/midgard/mali_base_mem_priv.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/mali_base_vendor_specific_func.h b/drivers/gpu/arm/midgard/mali_base_vendor_specific_func.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/mali_base_vendor_specific_func.h
rename to drivers/gpu/arm/midgard/mali_base_vendor_specific_func.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase.h b/drivers/gpu/arm/midgard/mali_kbase.h
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase.h
rename to drivers/gpu/arm/midgard/mali_kbase.h
index a94bb0b1df28..5fd4b847a86d
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase.h
+++ b/drivers/gpu/arm/midgard/mali_kbase.h
@@ -22,7 +22,7 @@
 
 #include <malisw/mali_malisw.h>
 
-#include <kbase/mali_kbase_debug.h>
+#include <mali_kbase_debug.h>
 
 #include <asm/page.h>
 
@@ -41,9 +41,9 @@
 #include <linux/wait.h>
 #include <linux/workqueue.h>
 
-#include <kbase/mali_base_kernel.h>
-#include <kbase/src/common/mali_kbase_uku.h>
-#include <kbase/src/linux/mali_kbase_linux.h>
+#include "mali_base_kernel.h"
+#include <mali_kbase_uku.h>
+#include <mali_kbase_linux.h>
 
 #include "mali_kbase_pm.h"
 #include "mali_kbase_mem_lowlevel.h"
@@ -53,7 +53,7 @@
 #include "mali_kbase_mem.h"
 #include "mali_kbase_security.h"
 #include "mali_kbase_utility.h"
-#include <kbase/src/linux/mali_kbase_gpu_memory_debugfs.h>
+#include <mali_kbase_gpu_memory_debugfs.h>
 #include "mali_kbase_cpuprops.h"
 #include "mali_kbase_gpuprops.h"
 #ifdef CONFIG_GPU_TRACEPOINTS
@@ -124,9 +124,6 @@ void kbase_clean_caches_done(kbase_device *kbdev);
  */
 void kbase_instr_hwcnt_sample_done(kbase_device *kbdev);
 
-mali_error kbase_create_os_context(kbase_os_context * const osctx);
-void kbase_destroy_os_context(kbase_os_context *osctx);
-
 mali_error kbase_jd_init(kbase_context *kctx);
 void kbase_jd_exit(kbase_context *kctx);
 mali_error kbase_jd_submit(kbase_context *kctx, const kbase_uk_job_submit *user_bag);
@@ -136,6 +133,9 @@ void kbase_jd_cancel(kbase_device *kbdev, kbase_jd_atom *katom);
 void kbase_jd_zap_context(kbase_context *kctx);
 mali_bool jd_done_nolock(kbase_jd_atom *katom);
 void kbase_jd_free_external_resources(kbase_jd_atom *katom);
+mali_bool jd_submit_atom(kbase_context *kctx,
+			 const base_jd_atom_v2 *user_atom,
+			 kbase_jd_atom *katom);
 
 mali_error kbase_job_slot_init(kbase_device *kbdev);
 void kbase_job_slot_halt(kbase_device *kbdev);
@@ -160,6 +160,8 @@ void kbase_finish_soft_job(kbase_jd_atom *katom);
 void kbase_cancel_soft_job(kbase_jd_atom *katom);
 void kbase_resume_suspended_soft_jobs(kbase_device *kbdev);
 
+int kbase_replay_process(kbase_jd_atom *katom);
+
 /* api used internally for register access. Contains validation and tracing */
 void kbase_reg_write(kbase_device *kbdev, u16 offset, u32 value, kbase_context *kctx);
 u32 kbase_reg_read(kbase_device *kbdev, u16 offset, kbase_context *kctx);
@@ -353,7 +355,7 @@ void kbasep_trace_clear(kbase_device *kbdev);
 #else
 #ifdef CONFIG_MALI_SYSTEM_TRACE
 /* Dispatch kbase trace events as system trace events */
-#include <kbase/src/linux/mali_linux_kbase_trace.h>
+#include <mali_linux_kbase_trace.h>
 #define KBASE_TRACE_ADD_SLOT( kbdev, code, ctx, katom, gpu_addr, jobslot )\
 	trace_mali_##code(jobslot, 0)
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_10969_workaround.c b/drivers/gpu/arm/midgard/mali_kbase_10969_workaround.c
old mode 100644
new mode 100755
similarity index 69%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_10969_workaround.c
rename to drivers/gpu/arm/midgard/mali_kbase_10969_workaround.c
index 599dfad46d0c..b08143020aa0
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_10969_workaround.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_10969_workaround.c
@@ -15,7 +15,7 @@
 
 
 
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 
 /* This function is used to solve an HW issue with single iterator GPUs.
  * If a fragment job is soft-stopped on the edge of its bounding box, can happen that the
@@ -42,8 +42,9 @@
 
 int kbasep_10969_workaround_clamp_coordinates(kbase_jd_atom *katom)
 {
+	struct device *dev = katom->kctx->kbdev->dev;
 	u32   clamped = 0;
-	KBASE_DEBUG_PRINT_WARN(KBASE_JD,"Called TILE_RANGE_FAULT workaround clamping function. \n");
+	dev_warn(dev,"Called TILE_RANGE_FAULT workaround clamping function. \n");
 	if (katom->core_req & BASE_JD_REQ_FS){
 		kbase_va_region * region = kbase_region_tracker_find_region_enclosing_address(katom->kctx, katom->jc );
 
@@ -93,46 +94,47 @@ int kbasep_10969_workaround_clamp_coordinates(kbase_jd_atom *katom)
 					restartX = job_header[JOB_DESC_FAULT_ADDR_LOW_WORD] & X_COORDINATE_MASK;
 					restartY = job_header[JOB_DESC_FAULT_ADDR_LOW_WORD] & Y_COORDINATE_MASK;
 
-					KBASE_DEBUG_PRINT_WARN(KBASE_JD, "Before Clamping: \n" \
-					                                 "Jobstatus: %08x  \n" \
-					                                 "restartIdx: %08x  \n" \
-					                                 "Fault_addr_low: %08x \n" \
-					                                 "minCoordsX: %08x minCoordsY: %08x \n" \
-					                                 "maxCoordsX: %08x maxCoordsY: %08x \n", 
-					                       job_header[JOB_DESC_STATUS_WORD],
-					                       job_header[JOB_DESC_RESTART_INDEX_WORD],
-					                       job_header[JOB_DESC_FAULT_ADDR_LOW_WORD],
-					                       minX,minY,
-					                       maxX,maxY );
+					dev_warn(dev, "Before Clamping: \n" \
+					              "Jobstatus: %08x  \n" \
+					              "restartIdx: %08x  \n" \
+					              "Fault_addr_low: %08x \n" \
+					              "minCoordsX: %08x minCoordsY: %08x \n" \
+					              "maxCoordsX: %08x maxCoordsY: %08x \n", 
+					              job_header[JOB_DESC_STATUS_WORD],
+					              job_header[JOB_DESC_RESTART_INDEX_WORD],
+					              job_header[JOB_DESC_FAULT_ADDR_LOW_WORD],
+					              minX,minY,
+					              maxX,maxY );
 
 					/* Set the restart index to the one which generated the fault*/
 					job_header[JOB_DESC_RESTART_INDEX_WORD] = job_header[JOB_DESC_FAULT_ADDR_LOW_WORD];
 
 					if (restartX < minX){
 						job_header[JOB_DESC_RESTART_INDEX_WORD] = (minX) | restartY;
-						KBASE_DEBUG_PRINT_WARN(KBASE_JD,
-						                       "Clamping restart X index to minimum. %08x clamped to %08x \n",
-						                       restartX, minX );
+						dev_warn(dev,
+						         "Clamping restart X index to minimum. %08x clamped to %08x \n",
+						         restartX, minX );
 						clamped =  1;
 					}
 					if (restartY < minY){
 						job_header[JOB_DESC_RESTART_INDEX_WORD] = (minY) | restartX;
-						KBASE_DEBUG_PRINT_WARN(KBASE_JD,
-						                       "Clamping restart Y index to minimum. %08x clamped to %08x \n",
-						                        restartY, minY );
+						dev_warn(dev,
+						         "Clamping restart Y index to minimum. %08x clamped to %08x \n",
+						         restartY, minY );
 						clamped =  1;
 					}
 					if (restartX > maxX){
 						job_header[JOB_DESC_RESTART_INDEX_WORD] = (maxX) | restartY;
-						KBASE_DEBUG_PRINT_WARN(KBASE_JD,
-						                       "Clamping restart X index to maximum. %08x clamped to %08x \n",
-						                        restartX, maxX );
+						dev_warn(dev,
+						         "Clamping restart X index to maximum. %08x clamped to %08x \n",
+						         restartX, maxX );
 						clamped =  1;
 					}
 					if (restartY > maxY){
 						job_header[JOB_DESC_RESTART_INDEX_WORD] = (maxY) | restartX;
-						KBASE_DEBUG_PRINT_WARN(KBASE_JD,"Clamping restart Y index to maximum. %08x clamped to %08x \n",
-						                        restartY, maxY );
+						dev_warn(dev,
+						         "Clamping restart Y index to maximum. %08x clamped to %08x \n",
+						         restartY, maxY );
 						clamped =  1;
 					}
 
@@ -140,17 +142,17 @@ int kbasep_10969_workaround_clamp_coordinates(kbase_jd_atom *katom)
 						/* Reset the fault address low word and set the job status to STOPPED */
 						job_header[JOB_DESC_FAULT_ADDR_LOW_WORD] = 0x0;
 						job_header[JOB_DESC_STATUS_WORD] = BASE_JD_EVENT_STOPPED;
-						KBASE_DEBUG_PRINT_WARN(KBASE_JD, "After Clamping: \n"                   \
-						                                 "Jobstatus: %08x  \n"                  \
-						                                 "restartIdx: %08x  \n"                 \
-						                                 "Fault_addr_low: %08x \n"              \
-						                                 "minCoordsX: %08x minCoordsY: %08x \n" \
-						                                 "maxCoordsX: %08x maxCoordsY: %08x \n", 
-						                       job_header[JOB_DESC_STATUS_WORD],
-						                       job_header[JOB_DESC_RESTART_INDEX_WORD],
-						                       job_header[JOB_DESC_FAULT_ADDR_LOW_WORD],
-						                       minX,minY,
-						                       maxX,maxY );
+						dev_warn(dev, "After Clamping: \n"                   \
+						              "Jobstatus: %08x  \n"                  \
+						              "restartIdx: %08x  \n"                 \
+						              "Fault_addr_low: %08x \n"              \
+						              "minCoordsX: %08x minCoordsY: %08x \n" \
+						              "maxCoordsX: %08x maxCoordsY: %08x \n", 
+						              job_header[JOB_DESC_STATUS_WORD],
+						              job_header[JOB_DESC_RESTART_INDEX_WORD],
+						              job_header[JOB_DESC_FAULT_ADDR_LOW_WORD],
+						              minX,minY,
+						              maxX,maxY );
 
 						/* Flush CPU cache to update memory for future GPU reads*/
 						memcpy(page_1, dst, copy_size);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_10969_workaround.h b/drivers/gpu/arm/midgard/mali_kbase_10969_workaround.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_10969_workaround.h
rename to drivers/gpu/arm/midgard/mali_kbase_10969_workaround.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cache_policy.c b/drivers/gpu/arm/midgard/mali_kbase_cache_policy.c
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cache_policy.c
rename to drivers/gpu/arm/midgard/mali_kbase_cache_policy.c
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cache_policy.h b/drivers/gpu/arm/midgard/mali_kbase_cache_policy.h
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cache_policy.h
rename to drivers/gpu/arm/midgard/mali_kbase_cache_policy.h
index 2a26d9eb782a..70f8a4c8ada2
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cache_policy.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_cache_policy.h
@@ -27,7 +27,7 @@
 
 #include <malisw/mali_malisw.h>
 #include "mali_kbase.h"
-#include <kbase/mali_base_kernel.h>
+#include "mali_base_kernel.h"
 
 /**
  * @brief Choose the cache policy for a specific region
diff --git a/drivers/gpu/arm/midgard/mali_kbase_config.c b/drivers/gpu/arm/midgard/mali_kbase_config.c
new file mode 100755
index 000000000000..fe9f02764559
--- /dev/null
+++ b/drivers/gpu/arm/midgard/mali_kbase_config.c
@@ -0,0 +1,358 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+
+
+#include <mali_kbase.h>
+#include <mali_kbase_defs.h>
+#include <mali_kbase_cpuprops.h>
+#include <mali_kbase_config_defaults.h>
+
+/* Specifies how many attributes are permitted in the config (excluding terminating attribute).
+ * This is used in validation function so we can detect if configuration is properly terminated. This value can be
+ * changed if we need to introduce more attributes or many memory regions need to be defined */
+#define ATTRIBUTE_COUNT_MAX 32
+
+/* Limits for gpu frequency configuration parameters. These will use for config validation. */
+#define MAX_GPU_ALLOWED_FREQ_KHZ 1000000
+#define MIN_GPU_ALLOWED_FREQ_KHZ 1
+
+int kbasep_get_config_attribute_count(const kbase_attribute *attributes)
+{
+	int count = 1;
+
+	if (!attributes)
+		return -EINVAL;
+
+	while (attributes->id != KBASE_CONFIG_ATTR_END) {
+		attributes++;
+		count++;
+	}
+
+	return count;
+}
+
+const kbase_attribute *kbasep_get_next_attribute(const kbase_attribute *attributes, int attribute_id)
+{
+	KBASE_DEBUG_ASSERT(attributes != NULL);
+
+	while (attributes->id != KBASE_CONFIG_ATTR_END) {
+		if (attributes->id == attribute_id)
+			return attributes;
+
+		attributes++;
+	}
+	return NULL;
+}
+
+KBASE_EXPORT_TEST_API(kbasep_get_next_attribute)
+
+uintptr_t kbasep_get_config_value(struct kbase_device *kbdev, const kbase_attribute *attributes, int attribute_id)
+{
+	const kbase_attribute *attr;
+
+	KBASE_DEBUG_ASSERT(attributes != NULL);
+
+	attr = kbasep_get_next_attribute(attributes, attribute_id);
+	if (attr != NULL)
+		return attr->data;
+
+	/* default values */
+	switch (attribute_id) {
+	case KBASE_CONFIG_ATTR_GPU_IRQ_THROTTLE_TIME_US:
+		return DEFAULT_IRQ_THROTTLE_TIME_US;
+		/* Begin scheduling defaults */
+	case KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS:
+		return DEFAULT_JS_SCHEDULING_TICK_NS;
+	case KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS:
+		return DEFAULT_JS_SOFT_STOP_TICKS;
+	case KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL:
+		return DEFAULT_JS_SOFT_STOP_TICKS_CL;
+	case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS:
+		if (kbase_hw_has_issue(kbdev, BASE_HW_ISSUE_8408))
+			return DEFAULT_JS_HARD_STOP_TICKS_SS_HW_ISSUE_8408;
+		else
+			return DEFAULT_JS_HARD_STOP_TICKS_SS;
+	case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL:
+		return DEFAULT_JS_HARD_STOP_TICKS_CL;
+	case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS:
+		return DEFAULT_JS_HARD_STOP_TICKS_NSS;
+	case KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS:
+		return DEFAULT_JS_CTX_TIMESLICE_NS;
+	case KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_INIT_SLICES:
+		return DEFAULT_JS_CFS_CTX_RUNTIME_INIT_SLICES;
+	case KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_MIN_SLICES:
+		return DEFAULT_JS_CFS_CTX_RUNTIME_MIN_SLICES;
+	case KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS:
+		if (kbase_hw_has_issue(kbdev, BASE_HW_ISSUE_8408))
+			return DEFAULT_JS_RESET_TICKS_SS_HW_ISSUE_8408;
+		else
+			return DEFAULT_JS_RESET_TICKS_SS;
+	case KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL:
+		return DEFAULT_JS_RESET_TICKS_CL;
+	case KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS:
+		return DEFAULT_JS_RESET_TICKS_NSS;
+	case KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS:
+		return DEFAULT_JS_RESET_TIMEOUT_MS;
+		/* End scheduling defaults */
+	case KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS:
+		return 0;
+	case KBASE_CONFIG_ATTR_PLATFORM_FUNCS:
+		return 0;
+	case KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE:
+		return DEFAULT_SECURE_BUT_LOSS_OF_PERFORMANCE;
+	case KBASE_CONFIG_ATTR_CPU_SPEED_FUNC:
+		return DEFAULT_CPU_SPEED_FUNC;
+	case KBASE_CONFIG_ATTR_GPU_SPEED_FUNC:
+		return 0;
+	case KBASE_CONFIG_ATTR_ARID_LIMIT:
+		return DEFAULT_ARID_LIMIT;
+	case KBASE_CONFIG_ATTR_AWID_LIMIT:
+		return DEFAULT_AWID_LIMIT;
+	case KBASE_CONFIG_ATTR_POWER_MANAGEMENT_DVFS_FREQ:
+		return DEFAULT_PM_DVFS_FREQ;
+	case KBASE_CONFIG_ATTR_PM_GPU_POWEROFF_TICK_NS:
+		return DEFAULT_PM_GPU_POWEROFF_TICK_NS;
+	case KBASE_CONFIG_ATTR_PM_POWEROFF_TICK_SHADER:
+		return DEFAULT_PM_POWEROFF_TICK_SHADER;
+	case KBASE_CONFIG_ATTR_PM_POWEROFF_TICK_GPU:
+		return DEFAULT_PM_POWEROFF_TICK_GPU;
+
+	default:
+		dev_err(kbdev->dev, "kbasep_get_config_value. Cannot get value of attribute with id=%d and no default value defined", attribute_id);
+		return 0;
+	}
+}
+
+KBASE_EXPORT_TEST_API(kbasep_get_config_value)
+
+mali_bool kbasep_platform_device_init(kbase_device *kbdev)
+{
+	kbase_platform_funcs_conf *platform_funcs;
+
+	platform_funcs = (kbase_platform_funcs_conf *) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_PLATFORM_FUNCS);
+	if (platform_funcs) {
+		if (platform_funcs->platform_init_func)
+			return platform_funcs->platform_init_func(kbdev);
+	}
+	return MALI_TRUE;
+}
+
+void kbasep_platform_device_term(kbase_device *kbdev)
+{
+	kbase_platform_funcs_conf *platform_funcs;
+
+	platform_funcs = (kbase_platform_funcs_conf *) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_PLATFORM_FUNCS);
+	if (platform_funcs) {
+		if (platform_funcs->platform_term_func)
+			platform_funcs->platform_term_func(kbdev);
+	}
+}
+
+static mali_bool kbasep_validate_gpu_clock_freq(kbase_device *kbdev, const kbase_attribute *attributes)
+{
+	uintptr_t freq_min = kbasep_get_config_value(kbdev, attributes, KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN);
+	uintptr_t freq_max = kbasep_get_config_value(kbdev, attributes, KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX);
+
+	if ((freq_min > MAX_GPU_ALLOWED_FREQ_KHZ) || (freq_min < MIN_GPU_ALLOWED_FREQ_KHZ) || (freq_max > MAX_GPU_ALLOWED_FREQ_KHZ) || (freq_max < MIN_GPU_ALLOWED_FREQ_KHZ) || (freq_min > freq_max)) {
+		dev_warn(kbdev->dev, "Invalid GPU frequencies found in configuration: min=%ldkHz, max=%ldkHz.", freq_min, freq_max);
+		return MALI_FALSE;
+	}
+
+	return MALI_TRUE;
+}
+
+static mali_bool kbasep_validate_pm_callback(const kbase_pm_callback_conf *callbacks, const kbase_device * kbdev )
+{
+	if (callbacks == NULL) {
+		/* Having no callbacks is valid */
+		return MALI_TRUE;
+	}
+
+	if ((callbacks->power_off_callback != NULL && callbacks->power_on_callback == NULL) || (callbacks->power_off_callback == NULL && callbacks->power_on_callback != NULL)) {
+		dev_warn(kbdev->dev, "Invalid power management callbacks: Only one of power_off_callback and power_on_callback was specified");
+		return MALI_FALSE;
+	}
+	return MALI_TRUE;
+}
+
+static mali_bool kbasep_validate_cpu_speed_func(kbase_cpuprops_clock_speed_function fcn)
+{
+	return fcn != NULL;
+}
+
+mali_bool kbasep_validate_configuration_attributes(kbase_device *kbdev, const kbase_attribute *attributes)
+{
+	int i;
+	mali_bool had_gpu_freq_min = MALI_FALSE, had_gpu_freq_max = MALI_FALSE;
+
+	KBASE_DEBUG_ASSERT(attributes);
+
+	for (i = 0; attributes[i].id != KBASE_CONFIG_ATTR_END; i++) {
+		if (i >= ATTRIBUTE_COUNT_MAX) {
+			dev_warn(kbdev->dev, "More than ATTRIBUTE_COUNT_MAX=%d configuration attributes defined. Is attribute list properly terminated?", ATTRIBUTE_COUNT_MAX);
+			return MALI_FALSE;
+		}
+
+		switch (attributes[i].id) {
+		case KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN:
+			had_gpu_freq_min = MALI_TRUE;
+			if (MALI_FALSE == kbasep_validate_gpu_clock_freq(kbdev, attributes)) {
+				/* Warning message handled by kbasep_validate_gpu_clock_freq() */
+				return MALI_FALSE;
+			}
+			break;
+
+		case KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX:
+			had_gpu_freq_max = MALI_TRUE;
+			if (MALI_FALSE == kbasep_validate_gpu_clock_freq(kbdev, attributes)) {
+				/* Warning message handled by kbasep_validate_gpu_clock_freq() */
+				return MALI_FALSE;
+			}
+			break;
+
+			/* Only non-zero unsigned 32-bit values accepted */
+		case KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS:
+#if CSTD_CPU_64BIT
+			if (attributes[i].data == 0u || (u64) attributes[i].data > (u64) U32_MAX)
+#else
+			if (attributes[i].data == 0u)
+#endif
+			{
+				dev_warn(kbdev->dev, "Invalid Job Scheduling Configuration attribute for " "KBASE_CONFIG_ATTR_JS_SCHEDULING_TICKS_NS: %d", (int)attributes[i].data);
+				return MALI_FALSE;
+			}
+			break;
+
+			/* All these Job Scheduling attributes are FALLTHROUGH: only unsigned 32-bit values accepted */
+		case KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS:
+		case KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL:
+		case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS:
+		case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL:
+		case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS:
+		case KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS:
+		case KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL:
+		case KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS:
+		case KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS:
+		case KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS:
+		case KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_INIT_SLICES:
+		case KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_MIN_SLICES:
+#if CSTD_CPU_64BIT
+			if ((u64) attributes[i].data > (u64) U32_MAX) {
+				dev_warn(kbdev->dev, "Job Scheduling Configuration attribute exceeds 32-bits: " "id==%d val==%d", attributes[i].id, (int)attributes[i].data);
+				return MALI_FALSE;
+			}
+#endif
+			break;
+
+		case KBASE_CONFIG_ATTR_GPU_IRQ_THROTTLE_TIME_US:
+#if CSTD_CPU_64BIT
+			if ((u64) attributes[i].data > (u64) U32_MAX) {
+				dev_warn(kbdev->dev, "IRQ throttle time attribute exceeds 32-bits: " "id==%d val==%d", attributes[i].id, (int)attributes[i].data);
+				return MALI_FALSE;
+			}
+#endif
+			break;
+
+		case KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS:
+			if (MALI_FALSE == kbasep_validate_pm_callback((kbase_pm_callback_conf *) attributes[i].data, kbdev)) {
+				/* Warning message handled by kbasep_validate_pm_callback() */
+				return MALI_FALSE;
+			}
+			break;
+
+		case KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE:
+			if (attributes[i].data != MALI_TRUE && attributes[i].data != MALI_FALSE) {
+				dev_warn(kbdev->dev, "Value for KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE was not " "MALI_TRUE or MALI_FALSE: %u", (unsigned int)attributes[i].data);
+				return MALI_FALSE;
+			}
+			break;
+
+		case KBASE_CONFIG_ATTR_CPU_SPEED_FUNC:
+			if (MALI_FALSE == kbasep_validate_cpu_speed_func((kbase_cpuprops_clock_speed_function) attributes[i].data)) {
+				dev_warn(kbdev->dev, "Invalid function pointer in KBASE_CONFIG_ATTR_CPU_SPEED_FUNC");
+				return MALI_FALSE;
+			}
+			break;
+
+		case KBASE_CONFIG_ATTR_GPU_SPEED_FUNC:
+			if (0 == attributes[i].data) {
+				dev_warn(kbdev->dev, "Invalid function pointer in KBASE_CONFIG_ATTR_GPU_SPEED_FUNC");
+				return MALI_FALSE;
+			}
+			break;
+
+		case KBASE_CONFIG_ATTR_PLATFORM_FUNCS:
+			/* any value is allowed */
+			break;
+
+		case KBASE_CONFIG_ATTR_AWID_LIMIT:
+		case KBASE_CONFIG_ATTR_ARID_LIMIT:
+			if ((u32) attributes[i].data > 0x3) {
+				dev_warn(kbdev->dev, "Invalid AWID or ARID limit");
+				return MALI_FALSE;
+			}
+			break;
+
+		case KBASE_CONFIG_ATTR_POWER_MANAGEMENT_DVFS_FREQ:
+#if CSTD_CPU_64BIT
+			if ((u64) attributes[i].data > (u64) U32_MAX) {
+				dev_warn(kbdev->dev, "PM DVFS interval exceeds 32-bits: " "id==%d val==%d", attributes[i].id, (int)attributes[i].data);
+				return MALI_FALSE;
+			}
+#endif
+			break;
+
+		case KBASE_CONFIG_ATTR_PM_GPU_POWEROFF_TICK_NS:
+#if CSTD_CPU_64BIT
+			if (attributes[i].data == 0u || (u64) attributes[i].data > (u64) U32_MAX) {
+#else
+			if (attributes[i].data == 0u) {
+#endif
+				dev_warn(kbdev->dev, "Invalid Power Manager Configuration attribute for " "KBASE_CONFIG_ATTR_PM_GPU_POWEROFF_TICK_NS: %d", (int)attributes[i].data);
+				return MALI_FALSE;
+			}
+			break;
+
+	case KBASE_CONFIG_ATTR_PM_POWEROFF_TICK_SHADER:
+	case KBASE_CONFIG_ATTR_PM_POWEROFF_TICK_GPU:
+#if CSTD_CPU_64BIT
+			if ((u64) attributes[i].data > (u64) U32_MAX) {
+				dev_warn(kbdev->dev, "Power Manager Configuration attribute exceeds 32-bits: " "id==%d val==%d", attributes[i].id, (int)attributes[i].data);
+				return MALI_FALSE;
+			}
+#endif
+			break;
+
+		default:
+			dev_warn(kbdev->dev, "Invalid attribute found in configuration: %d", attributes[i].id);
+			return MALI_FALSE;
+		}
+	}
+
+	if (!had_gpu_freq_min) {
+		dev_warn(kbdev->dev, "Configuration does not include mandatory attribute KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN");
+		return MALI_FALSE;
+	}
+
+	if (!had_gpu_freq_max) {
+		dev_warn(kbdev->dev, "Configuration does not include mandatory attribute KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX");
+		return MALI_FALSE;
+	}
+
+	return MALI_TRUE;
+}
diff --git a/drivers/gpu/arm/t6xx/kbase/mali_kbase_config.h b/drivers/gpu/arm/midgard/mali_kbase_config.h
old mode 100644
new mode 100755
similarity index 89%
rename from drivers/gpu/arm/t6xx/kbase/mali_kbase_config.h
rename to drivers/gpu/arm/midgard/mali_kbase_config.h
index 725aa66e7d4e..52d9eda78575
--- a/drivers/gpu/arm/t6xx/kbase/mali_kbase_config.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_config.h
@@ -51,17 +51,6 @@
 
 #include <linux/rbtree.h>
 
-/**
- * Relative memory performance indicators. Enum elements should always be defined in slowest to fastest order.
- */
-typedef enum kbase_memory_performance {
-	KBASE_MEM_PERF_SLOW,
-	KBASE_MEM_PERF_NORMAL,
-	KBASE_MEM_PERF_FAST,
-
-	KBASE_MEM_PERF_MAX_VALUE = KBASE_MEM_PERF_FAST
-} kbase_memory_performance;
-
 /**
  * Device wide configuration
  */
@@ -74,58 +63,6 @@ enum {
 	 * */
 	KBASE_CONFIG_ATTR_INVALID,
 
-	/**
-	 * Memory resource object.
-	 * Multiple resources can be listed.
-	 * The resources will be used in the order listed
-	 * in the configuration attribute list if they have no other
-	 * preferred order based on the memory resource property list
-	 * (see ::kbase_memory_attribute).
-	 *
-	 * Attached value: Pointer to a kbase_memory_resource object.
-	 * Default value: No resources
-	 * */
-
-	KBASE_CONFIG_ATTR_MEMORY_RESOURCE,
-	/**
-	 * Maximum of memory which can be allocated from the OS
-	 * to be used by the GPU (shared memory).
-	 * This must be greater than 0 as the GPU page tables
-	 * are currently stored in a shared memory allocation.
-	 *
-	 * Attached value: number in bytes
-	 * Default value: Limited by available memory
-	 */
-	KBASE_CONFIG_ATTR_MEMORY_OS_SHARED_MAX,
-
-	/**
-	 * Relative performance for the GPU to access
-	 * OS shared memory.
-	 *
-	 * Attached value: ::kbase_memory_performance member
-	 * Default value: ::KBASE_MEM_PERF_NORMAL
-	 */
-	KBASE_CONFIG_ATTR_MEMORY_OS_SHARED_PERF_GPU,
-
-	/**
-	 * Limit (in bytes) the amount of memory a single process
-	 * can allocate across all memory banks (including OS shared memory)
-	 * for use by the GPU.
-	 *
-	 * Attached value: number in bytes
-	 * Default value: Limited by available memory
-	 */
-	KBASE_CONFIG_ATTR_MEMORY_PER_PROCESS_LIMIT,
-
-	/**
-	 * UMP device mapping.
-	 * Which UMP device this GPU should be mapped to.
-	 *
-	 * Attached value: UMP_DEVICE_<device>_SHIFT
-	 * Default value: UMP_DEVICE_W_SHIFT
-	 */
-	KBASE_CONFIG_ATTR_UMP_DEVICE,
-
 	/**
 	 * Maximum frequency GPU will be clocked at. Given in kHz.
 	 * This must be specified as there is no default value.
@@ -195,7 +132,8 @@ enum {
 	KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
 
 	/**
-	 * Job Scheduler minimum number of scheduling ticks before jobs are soft-stopped.
+	 * Job Scheduler minimum number of scheduling ticks before non-CL jobs
+	 * are soft-stopped.
 	 *
 	 * This defines the amount of time a job is allowed to stay on the GPU,
 	 * before it is soft-stopped to allow other jobs to run.
@@ -214,8 +152,8 @@ enum {
 	 * which is somewhere between instant and one tick later.
 	 *
 	 * @note this value is allowed to be greater than
-	 * @ref KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS or
-	 * @ref KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS. This effectively disables
+	 * @ref KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS or
+	 * @ref KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS. This effectively disables
 	 * soft-stop, and just uses hard-stop instead. In this case, this value
 	 * should be much greater than any of the hard stop values (to avoid
 	 * soft-stop-after-hard-stop)
@@ -225,7 +163,39 @@ enum {
 	KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
 
 	/**
-	 * Job Scheduler minimum number of scheduling ticks before jobs are hard-stopped.
+	 * Job Scheduler minimum number of scheduling ticks before CL jobs
+	 * are soft-stopped.
+	 *
+	 * This defines the amount of time a job is allowed to stay on the GPU,
+	 * before it is soft-stopped to allow other jobs to run.
+	 *
+	 * That is, this defines the 'timeslice' of the job. It is separate
+	 * from the timeslice of the context that contains the job (see
+	 * @ref KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS).
+	 *
+	 * This value is supported by the following scheduling policies:
+	 * - The Completely Fair Share (CFS) policy
+	 *
+	 * Attached value: unsigned 32-bit
+	 *                         kbasep_js_device_data::soft_stop_ticks_cl<br>
+	 * Default value: @ref DEFAULT_JS_SOFT_STOP_TICKS_CL
+	 *
+	 * @note a value of zero means "the quickest time to soft-stop a job",
+	 * which is somewhere between instant and one tick later.
+	 *
+	 * @note this value is allowed to be greater than
+	 * @ref KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL. This effectively
+	 * disables soft-stop, and just uses hard-stop instead. In this case,
+	 * this value should be much greater than any of the hard stop values
+	 * (to avoid soft-stop-after-hard-stop)
+	 *
+	 * @see KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS
+	 */
+	KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL,
+
+	/**
+	 * Job Scheduler minimum number of scheduling ticks before non-CL jobs
+	 * are hard-stopped.
 	 *
 	 * This defines the amount of time a job is allowed to spend on the GPU before it
 	 * is killed. Such jobs won't be resumed if killed.
@@ -243,6 +213,25 @@ enum {
 	 */
 	KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
 
+	/**
+	 * Job Scheduler minimum number of scheduling ticks before CL jobs are hard-stopped.
+	 *
+	 * This defines the amount of time a job is allowed to spend on the GPU before it
+	 * is killed. Such jobs won't be resumed if killed.
+	 *
+	 * This value is supported by the following scheduling policies:
+	 * - The Completely Fair Share (CFS) policy
+	 *
+	 * Attached value: unsigned 32-bit kbasep_js_device_data::hard_stop_ticks_cl<br>
+	 * Default value: @ref DEFAULT_JS_HARD_STOP_TICKS_CL
+	 *
+	 * @note a value of zero means "the quickest time to hard-stop a job",
+	 * which is somewhere between instant and one tick later.
+	 *
+	 * @see KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS
+	 */
+	KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL,
+
 	/**
 	 * Job Scheduler minimum number of scheduling ticks before jobs are hard-stopped
 	 * when dumping.
@@ -337,8 +326,8 @@ enum {
 	KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_MIN_SLICES,
 
 	/**
-	 * Job Scheduler minimum number of scheduling ticks before jobs cause the GPU to be
-	 * reset.
+	 * Job Scheduler minimum number of scheduling ticks before non-CL jobs
+	 * cause the GPU to be reset.
 	 *
 	 * This defines the amount of time a job is allowed to spend on the GPU before it
 	 * is assumed that the GPU has hung and needs to be reset. The assumes that the job
@@ -355,6 +344,25 @@ enum {
 	 */
 	KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
 
+	/**
+	 * Job Scheduler minimum number of scheduling ticks before CL jobs
+	 * cause the GPU to be reset.
+	 *
+	 * This defines the amount of time a job is allowed to spend on the GPU before it 
+	 * is assumed that the GPU has hung and needs to be reset. The assumes that the job
+	 * has been hard-stopped already and so the presence of a job that has remained on
+	 * the GPU for so long indicates that the GPU has in some way hung.
+	 *
+	 * This value is supported by the following scheduling policies:
+	 * - The Completely Fair Share (CFS) policy
+	 *
+	 * Attached value: unsigned 32-bit kbasep_js_device_data::gpu_reset_ticks_cl<br>
+	 * Default value: @ref DEFAULT_JS_RESET_TICKS_CL
+	 *
+	 * @see KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS
+	 */
+	KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL,
+
 	/**
 	 * Job Scheduler minimum number of scheduling ticks before jobs cause the GPU to be
 	 * reset when dumping.
@@ -473,14 +481,6 @@ enum {
 	 */
 	KBASE_CONFIG_ATTR_AWID_LIMIT,
 
-	/**
-	 * Enable alternative hardware counter capture for the Mali shader cores.
-	 *
-	 * Attached value: mali_bool value
-	 * Default value: @ref MALI_FALSE
-	 */
-	KBASE_CONFIG_ATTR_ALTERNATIVE_HWC,
-
 	/**
 	 * Rate at which dvfs data should be collected.
 	 *
@@ -532,44 +532,6 @@ enum {
 	KBASE_CONFIG_ATTR_END = 0x1FFFUL
 };
 
-enum {
-	/**
-	 * Invalid attribute ID (reserve 0).
-	 *
-	 * Attached value: Ignored
-	 * Default value: NA
-	 */
-	KBASE_MEM_ATTR_INVALID,
-
-	/**
-	 * Relative performance for the CPU to access
-	 * the memory resource.
-	 *
-	 * Attached value: ::kbase_memory_performance member
-	 * Default value: ::KBASE_MEM_PERF_NORMAL
-	 */
-	KBASE_MEM_ATTR_PERF_CPU,
-
-	/**
-	 * Relative performance for the GPU to access
-	 * the memory resource.
-	 *
-	 * Attached value: ::kbase_memory_performance member
-	 * Default value: ::KBASE_MEM_PERF_NORMAL
-	 */
-	KBASE_MEM_ATTR_PERF_GPU,
-
-	/**
-	 * End of attribute list indicator.
-	 * The memory resource loader will stop processing any more
-	 * elements when it encounters this attribute.
-	 *
-	 * Attached value: Ignored
-	 * Default value: NA
-	 */
-	KBASE_MEM_ATTR_END = 0x1FFFUL
-};
-
 enum {
 	/**
 	 * Use unrestricted Address ID width on the AXI bus.
@@ -605,18 +567,6 @@ typedef struct kbase_attribute {
 	uintptr_t data;
 } kbase_attribute;
 
-/*
- * @brief Specifies dedicated memory bank
- *
- * Specifies base, size and attributes of a memory bank
- */
-typedef struct kbase_memory_resource {
-	u64 base;
-	u64 size;
-	struct kbase_attribute *attributes;
-	const char *name;
-} kbase_memory_resource;
-
 /* Forward declaration of kbase_device */
 struct kbase_device;
 
diff --git a/drivers/gpu/arm/midgard/mali_kbase_config_defaults.h b/drivers/gpu/arm/midgard/mali_kbase_config_defaults.h
new file mode 100755
index 000000000000..7c735815b6d1
--- /dev/null
+++ b/drivers/gpu/arm/midgard/mali_kbase_config_defaults.h
@@ -0,0 +1,202 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+/**
+ * @file mali_kbase_config_defaults.h
+ *
+ * Default values for configuration settings
+ *
+ */
+
+#ifndef _KBASE_CONFIG_DEFAULTS_H_
+#define _KBASE_CONFIG_DEFAULTS_H_
+
+/* Default irq throttle time. This is the default desired minimum time in
+ * between two consecutive interrupts from the gpu. The irq throttle gpu
+ * register is set after this value. */
+#define DEFAULT_IRQ_THROTTLE_TIME_US 20
+
+/*** Begin Scheduling defaults ***/
+
+/**
+ * Default scheduling tick granuality, in nanoseconds
+ */
+/* 50ms */
+#define DEFAULT_JS_SCHEDULING_TICK_NS 50000000u
+
+/**
+ * Default minimum number of scheduling ticks before jobs are soft-stopped.
+ *
+ * This defines the time-slice for a job (which may be different from that of
+ * a context)
+ */
+/* Between 0.1 and 0.15s before soft-stop */
+#define DEFAULT_JS_SOFT_STOP_TICKS 2
+
+/**
+ * Default minimum number of scheduling ticks before CL jobs are soft-stopped.
+ */
+/* Between 0.05 and 0.1s before soft-stop */
+#define DEFAULT_JS_SOFT_STOP_TICKS_CL 1
+
+/**
+ * Default minimum number of scheduling ticks before jobs are hard-stopped
+ */
+/* 1.2s before hard-stop, for a certain GLES2 test at 128x128 (bound by
+ * combined vertex+tiler job)
+ */
+#define DEFAULT_JS_HARD_STOP_TICKS_SS_HW_ISSUE_8408 24
+/* Between 0.2 and 0.25s before hard-stop */
+#define DEFAULT_JS_HARD_STOP_TICKS_SS 4
+
+/**
+ * Default minimum number of scheduling ticks before CL jobs are hard-stopped.
+ */
+/* Between 0.1 and 0.15s before hard-stop */
+#define DEFAULT_JS_HARD_STOP_TICKS_CL 2
+
+/**
+ * Default minimum number of scheduling ticks before jobs are hard-stopped
+ * during dumping
+ */
+/* 60s @ 50ms tick */
+#define DEFAULT_JS_HARD_STOP_TICKS_NSS 1200
+
+/**
+ * Default minimum number of scheduling ticks before the GPU is reset
+ * to clear a "stuck" job
+ */
+/* 1.8s before resetting GPU, for a certain GLES2 test at 128x128 (bound by
+ * combined vertex+tiler job)
+ */
+#define DEFAULT_JS_RESET_TICKS_SS_HW_ISSUE_8408 36
+/* 0.3-0.35s before GPU is reset */
+#define DEFAULT_JS_RESET_TICKS_SS 6
+
+/**
+ * Default minimum number of scheduling ticks before the GPU is reset
+ * to clear a "stuck" CL job.
+ */
+/* 0.2-0.25s before GPU is reset */
+#define DEFAULT_JS_RESET_TICKS_CL 4
+
+/**
+ * Default minimum number of scheduling ticks before the GPU is reset
+ * to clear a "stuck" job during dumping.
+ */
+/* 60.1s @ 100ms tick */
+#define DEFAULT_JS_RESET_TICKS_NSS 1202
+
+/**
+ * Number of milliseconds given for other jobs on the GPU to be
+ * soft-stopped when the GPU needs to be reset.
+ */
+#define DEFAULT_JS_RESET_TIMEOUT_MS 3000
+
+/**
+ * Default timeslice that a context is scheduled in for, in nanoseconds.
+ *
+ * When a context has used up this amount of time across its jobs, it is
+ * scheduled out to let another run.
+ *
+ * @note the resolution is nanoseconds (ns) here, because that's the format
+ * often used by the OS.
+ */
+/* 0.05s - at 20fps a ctx does at least 1 frame before being scheduled out.
+ * At 40fps, 2 frames, etc
+ */
+#define DEFAULT_JS_CTX_TIMESLICE_NS 50000000
+
+/**
+ * Default initial runtime of a context for CFS, in ticks.
+ *
+ * This value is relative to that of the least-run context, and defines where
+ * in the CFS queue a new context is added.
+ */
+#define DEFAULT_JS_CFS_CTX_RUNTIME_INIT_SLICES 1
+
+/**
+ * Default minimum runtime value of a context for CFS, in ticks.
+ *
+ * This value is relative to that of the least-run context. This prevents
+ * "stored-up timeslices" DoS attacks.
+ */
+#define DEFAULT_JS_CFS_CTX_RUNTIME_MIN_SLICES 2
+
+/**
+ * Default setting for whether to prefer security or performance.
+ *
+ * Currently affects only r0p0-15dev0 HW and earlier.
+ */
+#define DEFAULT_SECURE_BUT_LOSS_OF_PERFORMANCE MALI_FALSE
+
+/**
+ * Default setting for read Address ID limiting on AXI.
+ */
+#define DEFAULT_ARID_LIMIT KBASE_AID_32
+
+/**
+ * Default setting for write Address ID limiting on AXI.
+ */
+#define DEFAULT_AWID_LIMIT KBASE_AID_32
+
+/**
+ * Default setting for using alternative hardware counters.
+ */
+#define DEFAULT_ALTERNATIVE_HWC MALI_FALSE
+
+/*** End Scheduling defaults ***/
+
+/*** Begin Power Manager defaults */
+
+/* Milliseconds */
+#define DEFAULT_PM_DVFS_FREQ 500
+
+/**
+ * Default poweroff tick granuality, in nanoseconds
+ */
+/* 400us */
+#define DEFAULT_PM_GPU_POWEROFF_TICK_NS 400000
+
+/**
+ * Default number of poweroff ticks before shader cores are powered off
+ */
+/* 400-800us */
+#define DEFAULT_PM_POWEROFF_TICK_SHADER 2
+
+/**
+ * Default number of poweroff ticks before GPU is powered off
+ */
+#define DEFAULT_PM_POWEROFF_TICK_GPU 2         /* 400-800us */
+
+/*** End Power Manager defaults ***/
+
+/**
+ * Default UMP device mapping. A UMP_DEVICE_<device>_SHIFT value which
+ * defines which UMP device this GPU should be mapped to.
+ */
+#define DEFAULT_UMP_GPU_DEVICE_SHIFT UMP_DEVICE_Z_SHIFT
+
+/**
+ * Default value for KBASE_CONFIG_ATTR_CPU_SPEED_FUNC.
+ * Points to @ref kbase_cpuprops_get_default_clock_speed.
+ */
+#define DEFAULT_CPU_SPEED_FUNC \
+	((uintptr_t)kbase_cpuprops_get_default_clock_speed)
+
+#endif /* _KBASE_CONFIG_DEFAULTS_H_ */
+
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_context.c b/drivers/gpu/arm/midgard/mali_kbase_context.c
old mode 100644
new mode 100755
similarity index 75%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_context.c
rename to drivers/gpu/arm/midgard/mali_kbase_context.c
index 9db757b7b679..43697f5f744a
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_context.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_context.c
@@ -22,16 +22,15 @@
  * Base kernel context APIs
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_midg_regmap.h>
+#include <mali_kbase.h>
+#include <mali_midg_regmap.h>
 
 #define MEMPOOL_PAGES 16384
 
 /**
  * @brief Create a kernel base context.
  *
- * Allocate and init a kernel base context. Calls
- * kbase_create_os_context() to setup OS specific structures.
+ * Allocate and init a kernel base context.
  */
 kbase_context *kbase_create_context(kbase_device *kbdev)
 {
@@ -62,12 +61,10 @@ kbase_context *kbase_create_context(kbase_device *kbdev)
 		goto free_kctx;
 
 	kctx->pgd_allocator = &kctx->osalloc;
-	if (kbase_mem_usage_init(&kctx->usage, kctx->kbdev->memdev.per_process_memory_limit >> PAGE_SHIFT))
-		goto free_allocator;
-
+	atomic_set(&kctx->used_pages, 0);
 
 	if (kbase_jd_init(kctx))
-		goto free_memctx;
+		goto free_allocator;
 
 	mali_err = kbasep_js_kctx_init(kctx);
 	if (MALI_ERROR_NONE != mali_err)
@@ -92,12 +89,18 @@ kbase_context *kbase_create_context(kbase_device *kbdev)
 	if (!kctx->pgd)
 		goto free_mmu;
 
-	if (kbase_create_os_context(&kctx->osctx))
-		goto free_pgd;
+	if (MALI_ERROR_NONE != kbase_mem_allocator_alloc(&kctx->osalloc, 1, &kctx->aliasing_sink_page))
+		goto no_sink_page;
+
+	kctx->tgid = current->tgid;
+	kctx->pid = current->pid; 
+	init_waitqueue_head(&kctx->event_queue);
+
+	kctx->cookies = KBASE_COOKIE_MASK;
 
 	/* Make sure page 0 is not used... */
 	if (kbase_region_tracker_init(kctx))
-		goto free_osctx;
+		goto no_region_tracker;
 #ifdef CONFIG_GPU_TRACEPOINTS
 	atomic_set(&kctx->jctx.work_id, 0);
 #endif
@@ -107,30 +110,35 @@ kbase_context *kbase_create_context(kbase_device *kbdev)
 
 	return kctx;
 
- free_osctx:
-	kbase_destroy_os_context(&kctx->osctx);
- free_pgd:
+no_region_tracker:
+no_sink_page:
+	kbase_mem_allocator_free(&kctx->osalloc, 1, &kctx->aliasing_sink_page, 0);
 	kbase_mmu_free_pgd(kctx);
- free_mmu:
+free_mmu:
 	kbase_mmu_term(kctx);
- free_event:
+free_event:
 	kbase_event_cleanup(kctx);
- free_jd:
+free_jd:
 	/* Safe to call this one even when didn't initialize (assuming kctx was sufficiently zeroed) */
 	kbasep_js_kctx_term(kctx);
 	kbase_jd_exit(kctx);
- free_memctx:
-	kbase_mem_usage_term(&kctx->usage);
- free_allocator:
+free_allocator:
 	kbase_mem_allocator_term(&kctx->osalloc);
- free_kctx:
+free_kctx:
     vfree(kctx);
- out:
+out:
 	return NULL;
 
 }
 KBASE_EXPORT_SYMBOL(kbase_create_context)
 
+static void kbase_reg_pending_dtor(struct kbase_va_region *reg)
+{
+	KBASE_LOG(2, reg->kctx->kbdev->dev, "Freeing pending unmapped region\n");
+	kbase_mem_phy_alloc_put(reg->alloc);
+	kfree(reg);
+}
+
 /**
  * @brief Destroy a kernel base context.
  *
@@ -140,6 +148,8 @@ KBASE_EXPORT_SYMBOL(kbase_create_context)
 void kbase_destroy_context(kbase_context *kctx)
 {
 	kbase_device *kbdev;
+	int pages;
+	unsigned long pending_regions_to_clean;
 
 	KBASE_DEBUG_ASSERT(NULL != kctx);
 
@@ -156,7 +166,7 @@ void kbase_destroy_context(kbase_context *kctx)
 	if (kbdev->hwcnt.kctx == kctx) {
 		/* disable the use of the hw counters if the app didn't use the API correctly or crashed */
 		KBASE_TRACE_ADD(kbdev, CORE_CTX_HWINSTR_TERM, kctx, NULL, 0u, 0u);
-		KBASE_DEBUG_PRINT_WARN(KBASE_CTX, "The privileged process asking for instrumentation forgot to disable it " "before exiting. Will end instrumentation for them");
+		dev_warn(kbdev->dev, "The privileged process asking for instrumentation forgot to disable it " "before exiting. Will end instrumentation for them");
 		kbase_instr_hwcnt_disable(kctx);
 	}
 
@@ -167,8 +177,23 @@ void kbase_destroy_context(kbase_context *kctx)
 
 	/* MMU is disabled as part of scheduling out the context */
 	kbase_mmu_free_pgd(kctx);
+
+	/* drop the aliasing sink page now that it can't be mapped anymore */
+	kbase_mem_allocator_free(&kctx->osalloc, 1, &kctx->aliasing_sink_page, 0);
+
+	/* free pending region setups */
+	pending_regions_to_clean = (~kctx->cookies) & KBASE_COOKIE_MASK;
+	while (pending_regions_to_clean) {
+		unsigned int cookie = __ffs(pending_regions_to_clean);
+		BUG_ON(!kctx->pending_regions[cookie]);
+
+		kbase_reg_pending_dtor(kctx->pending_regions[cookie]);
+
+		kctx->pending_regions[cookie] = NULL;
+		pending_regions_to_clean &= ~(1UL << cookie);
+	}
+
 	kbase_region_tracker_term(kctx);
-	kbase_destroy_os_context(&kctx->osctx);
 	kbase_gpu_vm_unlock(kctx);
 
 	/* Safe to call this one even when didn't initialize (assuming kctx was sufficiently zeroed) */
@@ -180,7 +205,9 @@ void kbase_destroy_context(kbase_context *kctx)
 
 	kbase_mmu_term(kctx);
 
-	kbase_mem_usage_term(&kctx->usage);
+	pages = atomic_read(&kctx->used_pages);
+	if (pages != 0)
+		dev_warn(kbdev->dev, "%s: %d pages in use!\n", __func__, pages);
 
 	if (kctx->keep_gpu_powered) {
 		atomic_dec(&kbdev->keep_gpu_powered_count);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_core_linux.c b/drivers/gpu/arm/midgard/mali_kbase_core_linux.c
old mode 100644
new mode 100755
similarity index 80%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_core_linux.c
rename to drivers/gpu/arm/midgard/mali_kbase_core_linux.c
index 5e17cdd4b2c2..8c75f4bebfd7
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_core_linux.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_core_linux.c
@@ -23,11 +23,11 @@
  * Base kernel driver init.
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_uku.h>
-#include <kbase/src/common/mali_midg_regmap.h>
-#include <kbase/src/common/mali_kbase_gator.h>
-#include <kbase/src/linux/mali_kbase_mem_linux.h>
+#include <mali_kbase.h>
+#include <mali_kbase_uku.h>
+#include <mali_midg_regmap.h>
+#include <mali_kbase_gator.h>
+#include <mali_kbase_mem_linux.h>
 #ifdef CONFIG_MALI_NO_MALI
 #include "mali_kbase_model_linux.h"
 #endif /* CONFIG_MALI_NO_MALI */
@@ -53,10 +53,10 @@
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/compat.h>	/* is_compat_task */
-#include <kbase/src/common/mali_kbase_hw.h>
-#include <kbase/src/platform/mali_kbase_platform_common.h>
+#include <mali_kbase_hw.h>
+#include <platform/mali_kbase_platform_common.h>
 #ifdef CONFIG_SYNC
-#include <kbase/src/linux/mali_kbase_sync.h>
+#include <mali_kbase_sync.h>
 #endif /* CONFIG_SYNC */
 
 /*
@@ -64,13 +64,13 @@
  * use the platform fake code for registering the kbase config attributes.
  */
 #ifdef CONFIG_OF
-#include <kbase/mali_kbase_config.h>
+#include <mali_kbase_config.h>
 #endif
 
-//chenli: add for integration tests
-#ifdef CONFIG_MALI_DEBUG
-#include <kbase/src/integration_kit/MaliFns.h>
+#ifdef CONFIG_MACH_MANTA
+#include <plat/devs.h>
 #endif
+
 #define	JOB_IRQ_TAG	0
 #define MMU_IRQ_TAG	1
 #define GPU_IRQ_TAG	2
@@ -418,6 +418,51 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 			}
 			break;
 		}
+	case KBASE_FUNC_MEM_ALIAS: {
+			kbase_uk_mem_alias *alias = args;
+			struct base_mem_aliasing_info *__user user_ai;
+			struct base_mem_aliasing_info *ai;
+
+			if (sizeof(*alias) != args_size)
+				goto bad_size;
+
+			if (alias->nents > 4) {
+				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
+				break;
+			}
+
+#ifdef CONFIG_64BIT
+			if (is_compat_task())
+				user_ai = compat_ptr(alias->ai.compat_value);
+			else
+#endif
+				user_ai = alias->ai.value;
+
+			ai = kmalloc(GFP_KERNEL, sizeof(*ai) * alias->nents);
+			if (!ai) {
+				ukh->ret = MALI_ERROR_OUT_OF_MEMORY;
+				break;
+			}
+
+			if (copy_from_user(ai, user_ai,
+					   sizeof(*ai) * alias->nents)) {
+				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
+				goto copy_failed;
+			}
+
+			alias->gpu_va = kbase_mem_alias(kctx, &alias->flags,
+							alias->stride,
+							alias->nents, ai,
+							&alias->va_pages);
+			if (!alias->gpu_va) {
+				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
+				goto no_alias;
+			}
+no_alias:
+copy_failed:
+			kfree(ai);
+			break;
+		}
 	case KBASE_FUNC_MEM_COMMIT:
 		{
 			kbase_uk_mem_commit *commit = args;
@@ -426,7 +471,7 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 				goto bad_size;
 
 			if (commit->gpu_addr & ~PAGE_MASK) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "kbase_dispatch case KBASE_FUNC_MEM_COMMIT: commit->gpu_addr: passed parameter is invalid");
+				dev_warn(kbdev->dev, "kbase_dispatch case KBASE_FUNC_MEM_COMMIT: commit->gpu_addr: passed parameter is invalid");
 				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
 				break;
 			}
@@ -443,14 +488,14 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 				goto bad_size;
 
 			if (query->gpu_addr & ~PAGE_MASK) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "kbase_dispatch case KBASE_FUNC_MEM_QUERY: query->gpu_addr: passed parameter is invalid");
+				dev_warn(kbdev->dev, "kbase_dispatch case KBASE_FUNC_MEM_QUERY: query->gpu_addr: passed parameter is invalid");
 				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
 				break;
 			}
 			if (query->query != KBASE_MEM_QUERY_COMMIT_SIZE &&
 			    query->query != KBASE_MEM_QUERY_VA_SIZE &&
 				query->query != KBASE_MEM_QUERY_FLAGS) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "kbase_dispatch case KBASE_FUNC_MEM_QUERY: query->query = %lld unknown", (unsigned long long)query->query);
+				dev_warn(kbdev->dev, "kbase_dispatch case KBASE_FUNC_MEM_QUERY: query->query = %lld unknown", (unsigned long long)query->query);
 				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
 				break;
 			}
@@ -467,7 +512,7 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 				goto bad_size;
 
 			if ((fc->gpu_va & ~PAGE_MASK) && (fc->gpu_va >= PAGE_SIZE)) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "kbase_dispatch case KBASE_FUNC_MEM_FLAGS_CHANGE: mem->gpu_va: passed parameter is invalid");
+				dev_warn(kbdev->dev, "kbase_dispatch case KBASE_FUNC_MEM_FLAGS_CHANGE: mem->gpu_va: passed parameter is invalid");
 				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
 				break;
 			}
@@ -485,7 +530,7 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 				goto bad_size;
 
 			if ((mem->gpu_addr & ~PAGE_MASK) && (mem->gpu_addr >= PAGE_SIZE)) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "kbase_dispatch case KBASE_FUNC_MEM_FREE: mem->gpu_addr: passed parameter is invalid");
+				dev_warn(kbdev->dev, "kbase_dispatch case KBASE_FUNC_MEM_FREE: mem->gpu_addr: passed parameter is invalid");
 				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
 				break;
 			}
@@ -515,7 +560,7 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 				goto bad_size;
 
 			if (sn->sset.basep_sset.mem_handle & ~PAGE_MASK) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "kbase_dispatch case KBASE_FUNC_SYNC: sn->sset.basep_sset.mem_handle: passed parameter is invalid");
+				dev_warn(kbdev->dev, "kbase_dispatch case KBASE_FUNC_SYNC: sn->sset.basep_sset.mem_handle: passed parameter is invalid");
 				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
 				break;
 			}
@@ -582,30 +627,34 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
 			break;
 		}
-	case KBASE_FUNC_FIND_CPU_MAPPING:
+	case KBASE_FUNC_FIND_CPU_OFFSET:
 		{
-			kbase_uk_find_cpu_mapping *find = args;
-			struct kbase_cpu_mapping *map;
+			kbase_uk_find_cpu_offset *find = args;
 
 			if (sizeof(*find) != args_size)
 				goto bad_size;
 
 			if (find->gpu_addr & ~PAGE_MASK) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "kbase_dispatch case KBASE_FUNC_FIND_CPU_MAPPING: find->gpu_addr: passed parameter is invalid");
+				dev_warn(kbdev->dev,	
+					"kbase_dispatch case KBASE_FUNC_FIND_CPU_OFFSET:"
+					"find->gpu_addr: passed parameter is invalid");
 				goto out_bad;
 			}
 
-			KBASE_DEBUG_ASSERT(find != NULL);
 			if (find->size > SIZE_MAX || find->cpu_addr > ULONG_MAX)
-				map = NULL;
-			else
-				map = kbasep_find_enclosing_cpu_mapping(kctx, find->gpu_addr, (uintptr_t) find->cpu_addr, (size_t) find->size);
-
-			if (NULL != map) {
-				find->uaddr = PTR_TO_U64(map->vma->vm_start);
-				find->page_off = map->page_off;
-			} else {
 				ukh->ret = MALI_ERROR_FUNCTION_FAILED;
+			else {
+				mali_error err;
+
+				err = kbasep_find_enclosing_cpu_mapping_offset(
+						kctx,
+						find->gpu_addr,
+						(uintptr_t) find->cpu_addr,
+						(size_t) find->size,
+						&find->offset);
+
+				if (err != MALI_ERROR_NONE)
+					ukh->ret = MALI_ERROR_FUNCTION_FAILED;
 			}
 			break;
 		}
@@ -681,9 +730,9 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 			unsigned long flags;
 			kbase_error_params params = ((kbase_uk_error_params *) args)->params;
 			/*mutex lock */
-			spin_lock_irqsave(&kbdev->osdev.reg_op_lock, flags);
+			spin_lock_irqsave(&kbdev->reg_op_lock, flags);
 			ukh->ret = job_atom_inject_error(&params);
-			spin_unlock_irqrestore(&kbdev->osdev.reg_op_lock, flags);
+			spin_unlock_irqrestore(&kbdev->reg_op_lock, flags);
 			/*mutex unlock */
 #endif /* CONFIG_MALI_ERROR_INJECT */
 			break;
@@ -695,9 +744,9 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 			unsigned long flags;
 			kbase_model_control_params params = ((kbase_uk_model_control_params *) args)->params;
 			/*mutex lock */
-			spin_lock_irqsave(&kbdev->osdev.reg_op_lock, flags);
-			ukh->ret = midg_model_control(kbdev->osdev.model, &params);
-			spin_unlock_irqrestore(&kbdev->osdev.reg_op_lock, flags);
+			spin_lock_irqsave(&kbdev->reg_op_lock, flags);
+			ukh->ret = midg_model_control(kbdev->model, &params);
+			spin_unlock_irqrestore(&kbdev->reg_op_lock, flags);
 			/*mutex unlock */
 #endif /* CONFIG_MALI_NO_MALI */
 			break;
@@ -761,14 +810,14 @@ static mali_error kbase_dispatch(kbase_context *kctx, void * const args, u32 arg
 		}
 
 	default:
-		dev_err(kbdev->osdev.dev, "unknown ioctl %u", id);
+		dev_err(kbdev->dev, "unknown ioctl %u", id);
 		goto out_bad;
 	}
 
 	return MALI_ERROR_NONE;
 
  bad_size:
-	dev_err(kbdev->osdev.dev, "Wrong syscall size (%d) for %08x\n", args_size, id);
+	dev_err(kbdev->dev, "Wrong syscall size (%d) for %08x\n", args_size, id);
  out_bad:
 	return MALI_ERROR_FUNCTION_FAILED;
 }
@@ -804,10 +853,10 @@ struct kbase_device *kbase_find_device(int minor)
 	list_for_each(entry, &kbase_dev_list) {
 		struct kbase_device *tmp;
 
-		tmp = list_entry(entry, struct kbase_device, osdev.entry);
-		if (tmp->osdev.mdev.minor == minor || minor == -1) {
+		tmp = list_entry(entry, struct kbase_device, entry);
+		if (tmp->mdev.minor == minor || minor == -1) {
 			kbdev = tmp;
-			get_device(kbdev->osdev.dev);
+			get_device(kbdev->dev);
 			break;
 		}
 	}
@@ -819,7 +868,7 @@ EXPORT_SYMBOL(kbase_find_device);
 
 void kbase_release_device(struct kbase_device *kbdev)
 {
-	put_device(kbdev->osdev.dev);
+	put_device(kbdev->dev);
 }
 EXPORT_SYMBOL(kbase_release_device);
 
@@ -840,10 +889,10 @@ static int kbase_open(struct inode *inode, struct file *filp)
 		goto out;
 	}
 
-	init_waitqueue_head(&kctx->osctx.event_queue);
+	init_waitqueue_head(&kctx->event_queue);
 	filp->private_data = kctx;
 
-	dev_dbg(kbdev->osdev.dev, "created base context\n");
+	KBASE_LOG(1, kbdev->dev, "created base context\n");
 
 	{
 		kbasep_kctx_list_element *element;
@@ -856,7 +905,7 @@ static int kbase_open(struct inode *inode, struct file *filp)
 			mutex_unlock(&kbdev->kctx_list_lock);
 		} else {
 			/* we don't treat this as a fail - just warn about it */
-			printk(KERN_WARNING KBASE_DRV_NAME "couldn't add kctx to kctx_list\n");
+			dev_warn(kbdev->dev, "couldn't add kctx to kctx_list\n");
 		}
 	}
 	return 0;
@@ -883,12 +932,12 @@ static int kbase_release(struct inode *inode, struct file *filp)
 	}
 	mutex_unlock(&kbdev->kctx_list_lock);
 	if (!found_element)
-		printk(KERN_WARNING KBASE_DRV_NAME "kctx not in kctx_list\n");
+		dev_warn(kbdev->dev, "kctx not in kctx_list\n");
 
 	filp->private_data = NULL;
 	kbase_destroy_context(kctx);
 
-	dev_dbg(kbdev->osdev.dev, "deleted base context\n");
+	KBASE_LOG(1, kbdev->dev, "deleted base context\n");
 	kbase_release_device(kbdev);
 	return 0;
 }
@@ -905,7 +954,7 @@ static long kbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		return -ENOTTY;
 
 	if (0 != copy_from_user(&msg, (void *)arg, size)) {
-		pr_err("failed to copy ioctl argument into kernel space\n");
+		dev_err(kctx->kbdev->dev, "failed to copy ioctl argument into kernel space\n");
 		return -EFAULT;
 	}
 
@@ -913,7 +962,7 @@ static long kbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		return -EFAULT;
 
 	if (0 != copy_to_user((void *)arg, &msg, size)) {
-		pr_err("failed to copy results of UK call back to user space\n");
+		dev_err(kctx->kbdev->dev, "failed to copy results of UK call back to user space\n");
 		return -EFAULT;
 	}
 	return 0;
@@ -936,7 +985,7 @@ static ssize_t kbase_read(struct file *filp, char __user *buf, size_t count, lof
 			if (filp->f_flags & O_NONBLOCK)
 				return -EAGAIN;
 
-			if (wait_event_interruptible(kctx->osctx.event_queue, kbase_event_pending(kctx)))
+			if (wait_event_interruptible(kctx->event_queue, kbase_event_pending(kctx)))
 				return -ERESTARTSYS;
 		}
 		if (uevent.event_code == BASE_JD_EVENT_DRV_TERMINATED) {
@@ -961,7 +1010,7 @@ static unsigned int kbase_poll(struct file *filp, poll_table *wait)
 {
 	kbase_context *kctx = filp->private_data;
 
-	poll_wait(filp, &kctx->osctx.event_queue, wait);
+	poll_wait(filp, &kctx->event_queue, wait);
 	if (kbase_event_pending(kctx))
 		return POLLIN | POLLRDNORM;
 
@@ -972,7 +1021,7 @@ void kbase_event_wakeup(kbase_context *kctx)
 {
 	KBASE_DEBUG_ASSERT(kctx);
 
-	wake_up_interruptible(&kctx->osctx.event_queue);
+	wake_up_interruptible(&kctx->event_queue);
 }
 
 KBASE_EXPORT_TEST_API(kbase_event_wakeup)
@@ -1003,12 +1052,12 @@ static const struct file_operations kbase_fops = {
 #ifndef CONFIG_MALI_NO_MALI
 void kbase_os_reg_write(kbase_device *kbdev, u16 offset, u32 value)
 {
-	writel(value, kbdev->osdev.reg + offset);
+	writel(value, kbdev->reg + offset);
 }
 
 u32 kbase_os_reg_read(kbase_device *kbdev, u16 offset)
 {
-	return readl(kbdev->osdev.reg + offset);
+	return readl(kbdev->reg + offset);
 }
 
 static void *kbase_tag(void *ptr, u32 tag)
@@ -1039,7 +1088,7 @@ static irqreturn_t kbase_job_irq_handler(int irq, void *data)
 
 #ifdef CONFIG_MALI_DEBUG
 	if (!kbdev->pm.driver_ready_for_irqs)
-		dev_dbg(kbdev->osdev.dev, "%s: irq %d irqstatus 0x%x before driver is ready\n",
+		dev_warn(kbdev->dev, "%s: irq %d irqstatus 0x%x before driver is ready\n",
 				__func__, irq, val );
 #endif /* CONFIG_MALI_DEBUG */
 	spin_unlock_irqrestore(&kbdev->pm.gpu_powered_lock, flags);
@@ -1047,7 +1096,7 @@ static irqreturn_t kbase_job_irq_handler(int irq, void *data)
 	if (!val)
 		return IRQ_NONE;
 
-	dev_dbg(kbdev->osdev.dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
+	KBASE_LOG(3, kbdev->dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
 
 	kbase_job_done(kbdev, val);
 
@@ -1074,7 +1123,7 @@ static irqreturn_t kbase_mmu_irq_handler(int irq, void *data)
 
 #ifdef CONFIG_MALI_DEBUG
 	if (!kbdev->pm.driver_ready_for_irqs)
-		dev_dbg(kbdev->osdev.dev, "%s: irq %d irqstatus 0x%x before driver is ready\n",
+		dev_warn(kbdev->dev, "%s: irq %d irqstatus 0x%x before driver is ready\n",
 				__func__, irq, val );
 #endif /* CONFIG_MALI_DEBUG */
 	spin_unlock_irqrestore(&kbdev->pm.gpu_powered_lock, flags);
@@ -1082,7 +1131,7 @@ static irqreturn_t kbase_mmu_irq_handler(int irq, void *data)
 	if (!val)
 		return IRQ_NONE;
 
-	dev_dbg(kbdev->osdev.dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
+	KBASE_LOG(3, kbdev->dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
 
 	kbase_mmu_interrupt(kbdev, val);
 
@@ -1107,7 +1156,7 @@ static irqreturn_t kbase_gpu_irq_handler(int irq, void *data)
 
 #ifdef CONFIG_MALI_DEBUG
 	if (!kbdev->pm.driver_ready_for_irqs)
-		dev_dbg(kbdev->osdev.dev, "%s: irq %d irqstatus 0x%x before driver is ready\n",
+		KBASE_LOG(3, kbdev->dev, "%s: irq %d irqstatus 0x%x before driver is ready\n",
 				__func__, irq, val );
 #endif /* CONFIG_MALI_DEBUG */
 	spin_unlock_irqrestore(&kbdev->pm.gpu_powered_lock, flags);
@@ -1115,7 +1164,7 @@ static irqreturn_t kbase_gpu_irq_handler(int irq, void *data)
 	if (!val)
 		return IRQ_NONE;
 
-	dev_dbg(kbdev->osdev.dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
+	KBASE_LOG(3, kbdev->dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
 
 	kbase_gpu_interrupt(kbdev, val);
 
@@ -1144,22 +1193,21 @@ static irq_handler_t kbase_handler_table[] = {
  */
 static mali_error kbase_set_custom_irq_handler(kbase_device *kbdev, irq_handler_t custom_handler, int irq_type)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
 	mali_error result = MALI_ERROR_NONE;
 	irq_handler_t requested_irq_handler = NULL;
 	KBASE_DEBUG_ASSERT((JOB_IRQ_HANDLER <= irq_type) && (GPU_IRQ_HANDLER >= irq_type));
 
 	/* Release previous handler */
-	if (osdev->irqs[irq_type].irq)
-		free_irq(osdev->irqs[irq_type].irq, kbase_tag(kbdev, irq_type));
+	if (kbdev->irqs[irq_type].irq)
+		free_irq(kbdev->irqs[irq_type].irq, kbase_tag(kbdev, irq_type));
 
 	requested_irq_handler = (NULL != custom_handler) ? custom_handler : kbase_handler_table[irq_type];
 
-	if (0 != request_irq(osdev->irqs[irq_type].irq, requested_irq_handler, osdev->irqs[irq_type].flags | IRQF_SHARED, dev_name(osdev->dev), kbase_tag(kbdev, irq_type))) {
+	if (0 != request_irq(kbdev->irqs[irq_type].irq, requested_irq_handler, kbdev->irqs[irq_type].flags | IRQF_SHARED, dev_name(kbdev->dev), kbase_tag(kbdev, irq_type))) {
 		result = MALI_ERROR_FUNCTION_FAILED;
-		dev_err(osdev->dev, "Can't request interrupt %d (index %d)\n", osdev->irqs[irq_type].irq, irq_type);
+		dev_err(kbdev->dev, "Can't request interrupt %d (index %d)\n", kbdev->irqs[irq_type].irq, irq_type);
 #ifdef CONFIG_SPARSE_IRQ
-		dev_err(osdev->dev, "You have CONFIG_SPARSE_IRQ support enabled - is the interrupt number correct for this configuration?\n");
+		dev_err(kbdev->dev, "You have CONFIG_SPARSE_IRQ support enabled - is the interrupt number correct for this configuration?\n");
 #endif /* CONFIG_SPARSE_IRQ */
 	}
 
@@ -1201,7 +1249,7 @@ static irqreturn_t kbase_job_irq_test_handler(int irq, void *data)
 	if (!val)
 		return IRQ_NONE;
 
-	dev_dbg(kbdev->osdev.dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
+	KBASE_LOG(3, kbdev->dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
 
 	kbasep_irq_test_data.triggered = 1;
 	wake_up(&kbasep_irq_test_data.wait);
@@ -1232,7 +1280,7 @@ static irqreturn_t kbase_mmu_irq_test_handler(int irq, void *data)
 	if (!val)
 		return IRQ_NONE;
 
-	dev_dbg(kbdev->osdev.dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
+	KBASE_LOG(3, kbdev->dev, "%s: irq %d irqstatus 0x%x\n", __func__, irq, val);
 
 	kbasep_irq_test_data.triggered = 1;
 	wake_up(&kbasep_irq_test_data.wait);
@@ -1254,7 +1302,6 @@ static enum hrtimer_restart kbasep_test_interrupt_timeout(struct hrtimer *timer)
 
 static mali_error kbasep_common_test_interrupt(kbase_device * const kbdev, u32 tag)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
 	mali_error err = MALI_ERROR_NONE;
 	irq_handler_t test_handler;
 
@@ -1284,7 +1331,7 @@ static mali_error kbasep_common_test_interrupt(kbase_device * const kbdev, u32 t
 	/* mask interrupts */
 	kbase_reg_write(kbdev, mask_offset, 0x0, NULL);
 
-	if (osdev->irqs[tag].irq) {
+	if (kbdev->irqs[tag].irq) {
 		/* release original handler and install test handler */
 		if (MALI_ERROR_NONE != kbase_set_custom_irq_handler(kbdev, test_handler, tag)) {
 			err = MALI_ERROR_FUNCTION_FAILED;
@@ -1302,10 +1349,10 @@ static mali_error kbasep_common_test_interrupt(kbase_device * const kbdev, u32 t
 			wait_event(kbasep_irq_test_data.wait, kbasep_irq_test_data.triggered != 0);
 
 			if (kbasep_irq_test_data.timeout != 0) {
-				dev_err(osdev->dev, "Interrupt %d (index %d) didn't reach CPU.\n", osdev->irqs[tag].irq, tag);
+				dev_err(kbdev->dev, "Interrupt %d (index %d) didn't reach CPU.\n", kbdev->irqs[tag].irq, tag);
 				err = MALI_ERROR_FUNCTION_FAILED;
 			} else {
-				dev_dbg(osdev->dev, "Interrupt %d (index %d) reached CPU.\n", osdev->irqs[tag].irq, tag);
+				KBASE_LOG(2, kbdev->dev, "Interrupt %d (index %d) reached CPU.\n", kbdev->irqs[tag].irq, tag);
 			}
 
 			hrtimer_cancel(&kbasep_irq_test_data.timer);
@@ -1315,12 +1362,12 @@ static mali_error kbasep_common_test_interrupt(kbase_device * const kbdev, u32 t
 			kbase_reg_write(kbdev, mask_offset, 0x0, NULL);
 
 			/* release test handler */
-			free_irq(osdev->irqs[tag].irq, kbase_tag(kbdev, tag));
+			free_irq(kbdev->irqs[tag].irq, kbase_tag(kbdev, tag));
 		}
 
 		/* restore original interrupt */
-		if (request_irq(osdev->irqs[tag].irq, kbase_handler_table[tag], osdev->irqs[tag].flags | IRQF_SHARED, dev_name(osdev->dev), kbase_tag(kbdev, tag))) {
-			dev_err(osdev->dev, "Can't restore original interrupt %d (index %d)\n", osdev->irqs[tag].irq, tag);
+		if (request_irq(kbdev->irqs[tag].irq, kbase_handler_table[tag], kbdev->irqs[tag].flags | IRQF_SHARED, dev_name(kbdev->dev), kbase_tag(kbdev, tag))) {
+			dev_err(kbdev->dev, "Can't restore original interrupt %d (index %d)\n", kbdev->irqs[tag].irq, tag);
 			err = MALI_ERROR_FUNCTION_FAILED;
 		}
 	}
@@ -1332,7 +1379,6 @@ static mali_error kbasep_common_test_interrupt(kbase_device * const kbdev, u32 t
 
 static mali_error kbasep_common_test_interrupt_handlers(kbase_device * const kbdev)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
 	mali_error err;
 
 	init_waitqueue_head(&kbasep_irq_test_data.wait);
@@ -1343,17 +1389,17 @@ static mali_error kbasep_common_test_interrupt_handlers(kbase_device * const kbd
 
 	err = kbasep_common_test_interrupt(kbdev, JOB_IRQ_TAG);
 	if (MALI_ERROR_NONE != err) {
-		dev_err(osdev->dev, "Interrupt JOB_IRQ didn't reach CPU. Check interrupt assignments.\n");
+		dev_err(kbdev->dev, "Interrupt JOB_IRQ didn't reach CPU. Check interrupt assignments.\n");
 		goto out;
 	}
 
 	err = kbasep_common_test_interrupt(kbdev, MMU_IRQ_TAG);
 	if (MALI_ERROR_NONE != err) {
-		dev_err(osdev->dev, "Interrupt MMU_IRQ didn't reach CPU. Check interrupt assignments.\n");
+		dev_err(kbdev->dev, "Interrupt MMU_IRQ didn't reach CPU. Check interrupt assignments.\n");
 		goto out;
 	}
 
-	dev_err(osdev->dev, "Interrupts are correctly assigned.\n");
+	dev_err(kbdev->dev, "Interrupts are correctly assigned.\n");
 
  out:
 	kbase_pm_context_idle(kbdev);
@@ -1365,53 +1411,49 @@ static mali_error kbasep_common_test_interrupt_handlers(kbase_device * const kbd
 
 static int kbase_install_interrupts(kbase_device *kbdev)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
 	u32 nr = ARRAY_SIZE(kbase_handler_table);
 	int err;
 	u32 i;
 
 	for (i = 0; i < nr; i++) {
-		err = request_irq(osdev->irqs[i].irq, kbase_handler_table[i], osdev->irqs[i].flags | IRQF_SHARED, dev_name(osdev->dev), kbase_tag(kbdev, i));
+		err = request_irq(kbdev->irqs[i].irq, kbase_handler_table[i], kbdev->irqs[i].flags | IRQF_SHARED, dev_name(kbdev->dev), kbase_tag(kbdev, i));
 		if (err) {
-			dev_err(osdev->dev, "Can't request interrupt %d (index %d)\n", osdev->irqs[i].irq, i);
+			dev_err(kbdev->dev, "Can't request interrupt %d (index %d)\n", kbdev->irqs[i].irq, i);
 #ifdef CONFIG_SPARSE_IRQ
-			dev_err(osdev->dev, "You have CONFIG_SPARSE_IRQ support enabled - is the interrupt number correct for this configuration?\n");
+			dev_err(kbdev->dev, "You have CONFIG_SPARSE_IRQ support enabled - is the interrupt number correct for this configuration?\n");
 #endif /* CONFIG_SPARSE_IRQ */
 			goto release;
 		}
-		printk("%s,request irq %d ok\n",__func__,osdev->irqs[i].irq + 32 );
 	}
 
 	return 0;
 
  release:
 	while (i-- > 0)
-		free_irq(osdev->irqs[i].irq, kbase_tag(kbdev, i));
+		free_irq(kbdev->irqs[i].irq, kbase_tag(kbdev, i));
 
 	return err;
 }
 
 static void kbase_release_interrupts(kbase_device *kbdev)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
 	u32 nr = ARRAY_SIZE(kbase_handler_table);
 	u32 i;
 
 	for (i = 0; i < nr; i++) {
-		if (osdev->irqs[i].irq)
-			free_irq(osdev->irqs[i].irq, kbase_tag(kbdev, i));
+		if (kbdev->irqs[i].irq)
+			free_irq(kbdev->irqs[i].irq, kbase_tag(kbdev, i));
 	}
 }
 
 void kbase_synchronize_irqs(kbase_device *kbdev)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
 	u32 nr = ARRAY_SIZE(kbase_handler_table);
 	u32 i;
 
 	for (i = 0; i < nr; i++) {
-		if (osdev->irqs[i].irq)
-			synchronize_irq(osdev->irqs[i].irq);
+		if (kbdev->irqs[i].irq)
+			synchronize_irq(kbdev->irqs[i].irq);
 	}
 }
 
@@ -1797,7 +1839,7 @@ static ssize_t set_split(struct device *dev, struct device_attribute *attr, cons
 			mali_js0_affinity_mask  = config->js0_mask;
 			mali_js1_affinity_mask  = config->js1_mask;
 			mali_js2_affinity_mask  = config->js2_mask;
-			dev_info(dev, "Setting sc_split: '%s'\n", config->tag);
+			KBASE_LOG(2, dev, "Setting sc_split: '%s'\n", config->tag);
 			return count;
 		}
 		config++;
@@ -1845,27 +1887,38 @@ static ssize_t set_js_timeouts(struct device *dev, struct device_attribute *attr
 	struct kbase_device *kbdev;
 	int items;
 	unsigned long js_soft_stop_ms;
+	unsigned long js_soft_stop_ms_cl;
 	unsigned long js_hard_stop_ms_ss;
+	unsigned long js_hard_stop_ms_cl;
 	unsigned long js_hard_stop_ms_nss;
 	unsigned long js_reset_ms_ss;
+	unsigned long js_reset_ms_cl;
 	unsigned long js_reset_ms_nss;
 
 	kbdev = to_kbase_device(dev);
 	if (!kbdev)
 		return -ENODEV;
 
-	items = sscanf(buf, "%lu %lu %lu %lu %lu", &js_soft_stop_ms, &js_hard_stop_ms_ss, &js_hard_stop_ms_nss, &js_reset_ms_ss, &js_reset_ms_nss);
-	if (items == 5) {
+	items = sscanf(buf, "%lu %lu %lu %lu %lu %lu %lu %lu", &js_soft_stop_ms, &js_soft_stop_ms_cl, &js_hard_stop_ms_ss, &js_hard_stop_ms_cl, &js_hard_stop_ms_nss, &js_reset_ms_ss, &js_reset_ms_cl, &js_reset_ms_nss);
+	if (items == 8) {
 		u64 ticks;
 
 		ticks = js_soft_stop_ms * 1000000ULL;
 		do_div(ticks, kbdev->js_data.scheduling_tick_ns);
 		kbdev->js_soft_stop_ticks = ticks;
 
+		ticks = js_soft_stop_ms_cl * 1000000ULL;
+		do_div(ticks, kbdev->js_data.scheduling_tick_ns);
+		kbdev->js_soft_stop_ticks_cl = ticks;
+
 		ticks = js_hard_stop_ms_ss * 1000000ULL;
 		do_div(ticks, kbdev->js_data.scheduling_tick_ns);
 		kbdev->js_hard_stop_ticks_ss = ticks;
 
+		ticks = js_hard_stop_ms_cl * 1000000ULL;
+		do_div(ticks, kbdev->js_data.scheduling_tick_ns);
+		kbdev->js_hard_stop_ticks_cl = ticks;
+
 		ticks = js_hard_stop_ms_nss * 1000000ULL;
 		do_div(ticks, kbdev->js_data.scheduling_tick_ns);
 		kbdev->js_hard_stop_ticks_nss = ticks;
@@ -1874,19 +1927,26 @@ static ssize_t set_js_timeouts(struct device *dev, struct device_attribute *attr
 		do_div(ticks, kbdev->js_data.scheduling_tick_ns);
 		kbdev->js_reset_ticks_ss = ticks;
 
+		ticks = js_reset_ms_cl * 1000000ULL;
+		do_div(ticks, kbdev->js_data.scheduling_tick_ns);
+		kbdev->js_reset_ticks_cl = ticks;
+
 		ticks = js_reset_ms_nss * 1000000ULL;
 		do_div(ticks, kbdev->js_data.scheduling_tick_ns);
 		kbdev->js_reset_ticks_nss = ticks;
 
-		dev_info(kbdev->osdev.dev, "Overriding KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_soft_stop_ticks, js_soft_stop_ms);
-		dev_info(kbdev->osdev.dev, "Overriding KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_hard_stop_ticks_ss, js_hard_stop_ms_ss);
-		dev_info(kbdev->osdev.dev, "Overriding KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_hard_stop_ticks_nss, js_hard_stop_ms_nss);
-		dev_info(kbdev->osdev.dev, "Overriding KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_reset_ticks_ss, js_reset_ms_ss);
-		dev_info(kbdev->osdev.dev, "Overriding KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_reset_ticks_nss, js_reset_ms_nss);
+		KBASE_LOG(2, kbdev->dev, "Overriding KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_soft_stop_ticks, js_soft_stop_ms);
+		KBASE_LOG(2, kbdev->dev, "Overriding KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_soft_stop_ticks_cl, js_soft_stop_ms_cl);
+		KBASE_LOG(2, kbdev->dev, "Overriding KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_hard_stop_ticks_ss, js_hard_stop_ms_ss);
+		KBASE_LOG(2, kbdev->dev, "Overriding KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_hard_stop_ticks_cl, js_hard_stop_ms_cl);
+		KBASE_LOG(2, kbdev->dev, "Overriding KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_hard_stop_ticks_nss, js_hard_stop_ms_nss);
+		KBASE_LOG(2, kbdev->dev, "Overriding KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_reset_ticks_ss, js_reset_ms_ss);
+		KBASE_LOG(2, kbdev->dev, "Overriding KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_reset_ticks_cl, js_reset_ms_cl);
+		KBASE_LOG(2, kbdev->dev, "Overriding KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS with %lu ticks (%lu ms)\n", (unsigned long)kbdev->js_reset_ticks_nss, js_reset_ms_nss);
 
 		return count;
 	} else {
-		dev_err(kbdev->osdev.dev, "Couldn't process js_timeouts write operation.\nUse format " "<soft_stop_ms> <hard_stop_ms_ss> <hard_stop_ms_nss> <reset_ms_ss> <reset_ms_nss>\n");
+		dev_err(kbdev->dev, "Couldn't process js_timeouts write operation.\nUse format " "<soft_stop_ms> <hard_stop_ms_ss> <hard_stop_ms_nss> <reset_ms_ss> <reset_ms_nss>\n");
 		return -EINVAL;
 	}
 }
@@ -1909,9 +1969,12 @@ static ssize_t show_js_timeouts(struct device *dev, struct device_attribute *att
 	ssize_t ret;
 	u64 ms;
 	unsigned long js_soft_stop_ms;
+	unsigned long js_soft_stop_ms_cl;
 	unsigned long js_hard_stop_ms_ss;
+	unsigned long js_hard_stop_ms_cl;
 	unsigned long js_hard_stop_ms_nss;
 	unsigned long js_reset_ms_ss;
+	unsigned long js_reset_ms_cl;
 	unsigned long js_reset_ms_nss;
 
 	kbdev = to_kbase_device(dev);
@@ -1922,10 +1985,18 @@ static ssize_t show_js_timeouts(struct device *dev, struct device_attribute *att
 	do_div(ms, 1000000UL);
 	js_soft_stop_ms = (unsigned long)ms;
 
+	ms = (u64) kbdev->js_soft_stop_ticks_cl * kbdev->js_data.scheduling_tick_ns;
+	do_div(ms, 1000000UL);
+	js_soft_stop_ms_cl = (unsigned long)ms;
+
 	ms = (u64) kbdev->js_hard_stop_ticks_ss * kbdev->js_data.scheduling_tick_ns;
 	do_div(ms, 1000000UL);
 	js_hard_stop_ms_ss = (unsigned long)ms;
 
+	ms = (u64) kbdev->js_hard_stop_ticks_cl * kbdev->js_data.scheduling_tick_ns;
+	do_div(ms, 1000000UL);
+	js_hard_stop_ms_cl = (unsigned long)ms;
+
 	ms = (u64) kbdev->js_hard_stop_ticks_nss * kbdev->js_data.scheduling_tick_ns;
 	do_div(ms, 1000000UL);
 	js_hard_stop_ms_nss = (unsigned long)ms;
@@ -1934,11 +2005,15 @@ static ssize_t show_js_timeouts(struct device *dev, struct device_attribute *att
 	do_div(ms, 1000000UL);
 	js_reset_ms_ss = (unsigned long)ms;
 
+	ms = (u64) kbdev->js_reset_ticks_cl * kbdev->js_data.scheduling_tick_ns;
+	do_div(ms, 1000000UL);
+	js_reset_ms_cl = (unsigned long)ms;
+
 	ms = (u64) kbdev->js_reset_ticks_nss * kbdev->js_data.scheduling_tick_ns;
 	do_div(ms, 1000000UL);
 	js_reset_ms_nss = (unsigned long)ms;
 
-	ret = scnprintf(buf, PAGE_SIZE, "%lu %lu %lu %lu %lu\n", js_soft_stop_ms, js_hard_stop_ms_ss, js_hard_stop_ms_nss, js_reset_ms_ss, js_reset_ms_nss);
+	ret = scnprintf(buf, PAGE_SIZE, "%lu %lu %lu %lu %lu %lu %lu %lu\n", js_soft_stop_ms, js_soft_stop_ms_cl, js_hard_stop_ms_ss, js_hard_stop_ms_cl, js_hard_stop_ms_nss, js_reset_ms_ss, js_reset_ms_cl, js_reset_ms_nss);
 
 	if (ret >= PAGE_SIZE) {
 		buf[PAGE_SIZE - 2] = '\n';
@@ -1953,12 +2028,115 @@ static ssize_t show_js_timeouts(struct device *dev, struct device_attribute *att
  *
  * This is used to override the current job scheduler values for
  * KBASE_CONFIG_ATTR_JS_STOP_STOP_TICKS_SS
+ * KBASE_CONFIG_ATTR_JS_STOP_STOP_TICKS_CL
  * KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS
+ * KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL
  * KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS
  * KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS
+ * KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL
  * KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS.
  */
 DEVICE_ATTR(js_timeouts, S_IRUGO | S_IWUSR, show_js_timeouts, set_js_timeouts);
+
+
+
+/** Store callback for the @c force_replay sysfs file.
+ *
+ * @param dev	The device with sysfs file is for
+ * @param attr	The attributes of the sysfs file
+ * @param buf	The value written to the sysfs file
+ * @param count	The number of bytes written to the sysfs file
+ *
+ * @return @c count if the function succeeded. An error code on failure.
+ */
+static ssize_t set_force_replay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct kbase_device *kbdev;
+
+	kbdev = to_kbase_device(dev);
+	if (!kbdev)
+		return -ENODEV;
+
+	if (!strncmp("limit=", buf, MIN(6, count))) {
+		int force_replay_limit;
+		int items = sscanf(buf, "limit=%u", &force_replay_limit);
+
+		if (items == 1) {
+			kbdev->force_replay_random = MALI_FALSE;
+			kbdev->force_replay_limit = force_replay_limit;
+			kbdev->force_replay_count = 0;
+
+			return count;
+		}
+	} else if (!strncmp("random_limit", buf, MIN(12, count))) {
+		kbdev->force_replay_random = MALI_TRUE;
+		kbdev->force_replay_count = 0;
+
+		return count;
+	} else if (!strncmp("norandom_limit", buf, MIN(14, count))) {
+		kbdev->force_replay_random = MALI_FALSE;
+		kbdev->force_replay_limit = KBASEP_FORCE_REPLAY_DISABLED;
+		kbdev->force_replay_count = 0;
+
+		return count;
+	} else if (!strncmp("core_req=", buf, MIN(9, count))) {
+		unsigned int core_req;
+		int items = sscanf(buf, "core_req=%x", &core_req);
+
+		if (items == 1) {
+			kbdev->force_replay_core_req = (base_jd_core_req)core_req;
+
+			return count;
+		}
+	}
+	dev_err(kbdev->dev, "Couldn't process force_replay write operation.\nPossible settings: limit=<limit>, random_limit, norandom_limit, core_req=<core_req>\n");
+	return -EINVAL;
+}
+
+/** Show callback for the @c force_replay sysfs file.
+ *
+ * This function is called to get the contents of the @c force_replay sysfs
+ * file. It returns the last set value written to the force_replay sysfs file.
+ * If the file didn't get written yet, the values will be 0.
+ *
+ * @param dev	The device this sysfs file is for
+ * @param attr	The attributes of the sysfs file
+ * @param buf	The output buffer for the sysfs file contents
+ *
+ * @return The number of bytes output to @c buf.
+ */
+static ssize_t show_force_replay(struct device *dev, struct device_attribute *attr, char * const buf)
+{
+	struct kbase_device *kbdev;
+	ssize_t ret;
+
+	kbdev = to_kbase_device(dev);
+	if (!kbdev)
+		return -ENODEV;
+
+	if (kbdev->force_replay_random)
+		ret = scnprintf(buf, PAGE_SIZE,
+				"limit=0\nrandom_limit\ncore_req=%x\n",
+				kbdev->force_replay_core_req);
+	else
+		ret = scnprintf(buf, PAGE_SIZE,
+				"limit=%u\nnorandom_limit\ncore_req=%x\n",
+				kbdev->force_replay_limit,
+				kbdev->force_replay_core_req);
+
+	if (ret >= PAGE_SIZE) {
+		buf[PAGE_SIZE - 2] = '\n';
+		buf[PAGE_SIZE - 1] = '\0';
+		ret = PAGE_SIZE - 1;
+	}
+
+	return ret;
+}
+
+/** The sysfs file @c force_replay.
+ *
+ */
+DEVICE_ATTR(force_replay, S_IRUGO | S_IWUSR, show_force_replay, set_force_replay);
 #endif /* MALI_CUSTOMER_RELEASE == 0 */
 
 #ifdef CONFIG_MALI_DEBUG
@@ -1976,10 +2154,10 @@ static ssize_t set_js_softstop_always(struct device *dev, struct device_attribut
 	if ((items == 1) && ((softstop_always == 0) || (softstop_always == 1))) {
 		kbdev->js_data.softstop_always = (mali_bool) softstop_always;
 
-		dev_info(kbdev->osdev.dev, "Support for softstop on a single context: %s\n", (kbdev->js_data.softstop_always == MALI_FALSE) ? "Disabled" : "Enabled");
+		KBASE_LOG(2, kbdev->dev, "Support for softstop on a single context: %s\n", (kbdev->js_data.softstop_always == MALI_FALSE) ? "Disabled" : "Enabled");
 		return count;
 	} else {
-		dev_err(kbdev->osdev.dev, "Couldn't process js_softstop_always write operation.\nUse format " "<soft_stop_always>\n");
+		dev_err(kbdev->dev, "Couldn't process js_softstop_always write operation.\nUse format " "<soft_stop_always>\n");
 		return -EINVAL;
 	}
 }
@@ -2017,10 +2195,7 @@ typedef void (kbasep_debug_command_func) (kbase_device *);
 
 typedef enum {
 	KBASEP_DEBUG_COMMAND_DUMPTRACE,
-	KBASEP_DEBUG_COMMAND_SIM1,
-	KBASEP_DEBUG_COMMAND_SIM2,
-	KBASEP_DEBUG_COMMAND_SIM3,
-	KBASEP_DEBUG_COMMAND_SIM4,
+
 	/* This must be the last enum */
 	KBASEP_DEBUG_COMMAND_COUNT
 } kbasep_debug_command_code;
@@ -2035,23 +2210,7 @@ static const kbasep_debug_command debug_commands[] = {
 	{
 	 .str = "dumptrace",
 	 .func = &kbasep_trace_dump,
-	 },
-	{
-    .str = "sim1",
-    .func = &RunMaliTest_sim1_t760,
-    },
-    {
-    .str = "sim2",
-    .func = &RunMaliTest_sim2_t760,
-    },
-    {
-    .str = "sim3",
-    .func = &RunMaliTest_sim3_t760,
-    },
-    {
-    .str = "sim4",
-    .func = &RunMaliTest_sim4_t760,
-    }
+	 }
 };
 
 /** Show callback for the @c debug_command sysfs file.
@@ -2114,14 +2273,7 @@ static ssize_t issue_debug(struct device *dev, struct device_attribute *attr, co
 
 	for (i = 0; i < KBASEP_DEBUG_COMMAND_COUNT; i++) {
 		if (sysfs_streq(debug_commands[i].str, buf)) {
-			//chenli: modify for integration kits
-			if(i==0)//kbasep_trace_dump
-				debug_commands[i].func(kbdev);
-			else	//integration kits
-			{
-				struct kbase_os_device *osdev = &kbdev->osdev;
-				debug_commands[i].func((int *)osdev->reg);
-			}
+			debug_commands[i].func(kbdev);
 			return count;
 		}
 	}
@@ -2152,47 +2304,42 @@ static void kbase_common_reg_unmap(kbase_device * const kbdev)
 #else /* CONFIG_MALI_NO_MALI */
 static int kbase_common_reg_map(kbase_device *kbdev)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
 	int err = -ENOMEM;
 
-	osdev->reg_res = request_mem_region(osdev->reg_start, osdev->reg_size, dev_name(osdev->dev));
-	if (!osdev->reg_res) {
-		dev_err(osdev->dev, "Register window unavailable\n");
+	kbdev->reg_res = request_mem_region(kbdev->reg_start, kbdev->reg_size, dev_name(kbdev->dev));
+	if (!kbdev->reg_res) {
+		dev_err(kbdev->dev, "Register window unavailable\n");
 		err = -EIO;
 		goto out_region;
 	}
-	printk("%s,request_mem_region ok\n",__func__);
-	osdev->reg = ioremap(osdev->reg_start, osdev->reg_size);
-	if (!osdev->reg) {
-		dev_err(osdev->dev, "Can't remap register window\n");
+
+	kbdev->reg = ioremap(kbdev->reg_start, kbdev->reg_size);
+	if (!kbdev->reg) {
+		dev_err(kbdev->dev, "Can't remap register window\n");
 		err = -EINVAL;
 		goto out_ioremap;
 	}
 
-	printk("%s,ioremap ok\n",__func__);
 	return 0;
 
  out_ioremap:
-	release_resource(osdev->reg_res);
-	kfree(osdev->reg_res);
+	release_resource(kbdev->reg_res);
+	kfree(kbdev->reg_res);
  out_region:
 	return err;
 }
 
 static void kbase_common_reg_unmap(kbase_device * const kbdev)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
-
-	iounmap(osdev->reg);
-	release_resource(osdev->reg_res);
-	kfree(osdev->reg_res);
+	iounmap(kbdev->reg);
+	release_resource(kbdev->reg_res);
+	kfree(kbdev->reg_res);
 }
 #endif /* CONFIG_MALI_NO_MALI */
 
 
 static int kbase_common_device_init(kbase_device *kbdev)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
 	int err = -ENOMEM;
 	mali_error mali_err;
 	enum {
@@ -2205,11 +2352,11 @@ static int kbase_common_device_init(kbase_device *kbdev)
 		inited_js_softstop = (1u << 6),
 #if MALI_CUSTOMER_RELEASE == 0
 		inited_js_timeouts = (1u << 7),
+		inited_force_replay = (1u << 13),
 #endif /* MALI_CUSTOMER_RELEASE == 0 */
 		inited_pm_runtime_init = (1u << 8),
 #ifdef CONFIG_DEBUG_FS
 		inited_gpu_memory = (1u << 9),
-		inited_debugfs = (1u << 10),
 #endif /* CONFIG_DEBUG_FS */
 #ifdef CONFIG_MALI_DEBUG_SHADER_SPLIT_FS
 		inited_sc_split = (1u << 11),
@@ -2221,50 +2368,40 @@ static int kbase_common_device_init(kbase_device *kbdev)
 
 	int inited = 0;
 
-	dev_set_drvdata(osdev->dev, kbdev);
+	dev_set_drvdata(kbdev->dev, kbdev);
 
-	osdev->mdev.minor = MISC_DYNAMIC_MINOR;
-	osdev->mdev.name = osdev->devname;
-	osdev->mdev.fops = &kbase_fops;
-	osdev->mdev.parent = get_device(osdev->dev);
+	kbdev->mdev.minor = MISC_DYNAMIC_MINOR;
+	kbdev->mdev.name = kbdev->devname;
+	kbdev->mdev.fops = &kbase_fops;
+	kbdev->mdev.parent = get_device(kbdev->dev);
 
-	scnprintf(osdev->devname, DEVNAME_SIZE, "%s%d", kbase_drv_name, kbase_dev_nr++);
+	scnprintf(kbdev->devname, DEVNAME_SIZE, "%s%d", kbase_drv_name, kbase_dev_nr++);
 
-#ifdef CONFIG_DEBUG_FS
-	kbdev->mali_debugfs_directory = debugfs_create_dir("mali", NULL);
-	if (NULL == kbdev->mali_debugfs_directory) {
-		dev_err(osdev->dev, "Couldn't create mali debugfs directory\n");
-		goto out_partial;
-	}
-	inited |= inited_debugfs;
-#endif /* CONFIG_DEBUG_FS */
-
-
-	if (misc_register(&osdev->mdev)) {
-		dev_err(osdev->dev, "Couldn't register misc dev %s\n", osdev->devname);
+	if (misc_register(&kbdev->mdev)) {
+		dev_err(kbdev->dev, "Couldn't register misc dev %s\n", kbdev->devname);
 		err = -EINVAL;
 		goto out_misc;
 	}
 
-	if (device_create_file(osdev->dev, &dev_attr_power_policy)) {
-		dev_err(osdev->dev, "Couldn't create power_policy sysfs file\n");
+	if (device_create_file(kbdev->dev, &dev_attr_power_policy)) {
+		dev_err(kbdev->dev, "Couldn't create power_policy sysfs file\n");
 		goto out_file;
 	}
 
-	if (device_create_file(osdev->dev, &dev_attr_core_availability_policy)) {
-		dev_err(osdev->dev, "Couldn't create core_availability_policy sysfs file\n");
+	if (device_create_file(kbdev->dev, &dev_attr_core_availability_policy)) {
+		dev_err(kbdev->dev, "Couldn't create core_availability_policy sysfs file\n");
 		goto out_file_core_availability_policy;
 	}
 
-	if (device_create_file(osdev->dev, &dev_attr_core_mask)) {
-		dev_err(osdev->dev, "Couldn't create core_mask sysfs file\n");
+	if (device_create_file(kbdev->dev, &dev_attr_core_mask)) {
+		dev_err(kbdev->dev, "Couldn't create core_mask sysfs file\n");
 		goto out_file_core_mask;
 	}
 
 	down(&kbase_dev_list_lock);
-	list_add(&osdev->entry, &kbase_dev_list);
+	list_add(&kbdev->entry, &kbase_dev_list);
 	up(&kbase_dev_list_lock);
-	dev_info(osdev->dev, "Probed as %s\n", dev_name(osdev->mdev.this_device));
+	dev_info(kbdev->dev, "Probed as %s\n", dev_name(kbdev->mdev.this_device));
 
 	mali_err = kbase_pm_init(kbdev);
 	if (MALI_ERROR_NONE != mali_err)
@@ -2305,9 +2442,9 @@ static int kbase_common_device_init(kbase_device *kbdev)
 	inited |= inited_irqs;
 
 #ifdef CONFIG_MALI_DEBUG_SHADER_SPLIT_FS
-	if (device_create_file(osdev->dev, &dev_attr_sc_split))
+	if (device_create_file(kbdev->dev, &dev_attr_sc_split))
 	{
-		dev_err(osdev->dev, "Couldn't create sc_split sysfs file\n");
+		dev_err(kbdev->dev, "Couldn't create sc_split sysfs file\n");
 		goto out_partial;
 	}
 
@@ -2316,7 +2453,7 @@ static int kbase_common_device_init(kbase_device *kbdev)
 
 #ifdef CONFIG_DEBUG_FS
 	if (kbasep_gpu_memory_debugfs_init(kbdev)) {
-		dev_err(osdev->dev, "Couldn't create gpu_memory debugfs file\n");
+		dev_err(kbdev->dev, "Couldn't create gpu_memory debugfs file\n");
 		goto out_partial;
 	}
 	inited |= inited_gpu_memory;
@@ -2324,30 +2461,36 @@ static int kbase_common_device_init(kbase_device *kbdev)
 
 #ifdef CONFIG_MALI_DEBUG
 
-	if (device_create_file(osdev->dev, &dev_attr_debug_command)) {
-		dev_err(osdev->dev, "Couldn't create debug_command sysfs file\n");
+	if (device_create_file(kbdev->dev, &dev_attr_debug_command)) {
+		dev_err(kbdev->dev, "Couldn't create debug_command sysfs file\n");
 		goto out_partial;
 	}
 	inited |= inited_debug;
 
-	if (device_create_file(osdev->dev, &dev_attr_js_softstop_always)) {
-		dev_err(osdev->dev, "Couldn't create js_softstop_always sysfs file\n");
+	if (device_create_file(kbdev->dev, &dev_attr_js_softstop_always)) {
+		dev_err(kbdev->dev, "Couldn't create js_softstop_always sysfs file\n");
 		goto out_partial;
 	}
 	inited |= inited_js_softstop;
 #endif /* CONFIG_MALI_DEBUG */
 
 #if MALI_CUSTOMER_RELEASE == 0
-	if (device_create_file(osdev->dev, &dev_attr_js_timeouts)) {
-		dev_err(osdev->dev, "Couldn't create js_timeouts sysfs file\n");
+	if (device_create_file(kbdev->dev, &dev_attr_js_timeouts)) {
+		dev_err(kbdev->dev, "Couldn't create js_timeouts sysfs file\n");
 		goto out_partial;
 	}
 	inited |= inited_js_timeouts;
+
+	if (device_create_file(kbdev->dev, &dev_attr_force_replay)) {
+		dev_err(kbdev->dev, "Couldn't create force_replay sysfs file\n");
+		goto out_partial;
+	}
+	inited |= inited_force_replay;
 #endif /* MALI_CUSTOMER_RELEASE */
 
 #ifdef CONFIG_MALI_TRACE_TIMELINE
 	if (kbasep_trace_timeline_debugfs_init(kbdev)) {
-		dev_err(osdev->dev, "Couldn't create mali_timeline_defs debugfs file\n");
+		dev_err(kbdev->dev, "Couldn't create mali_timeline_defs debugfs file\n");
 		goto out_partial;
 	}
 	inited |= inited_timeline;
@@ -2358,7 +2501,7 @@ static int kbase_common_device_init(kbase_device *kbdev)
 #ifdef CONFIG_MALI_DEBUG
 #ifndef CONFIG_MALI_NO_MALI
 		if (MALI_ERROR_NONE != kbasep_common_test_interrupt_handlers(kbdev)) {
-			dev_err(osdev->dev, "Interrupt assigment check failed.\n");
+			dev_err(kbdev->dev, "Interrupt assigment check failed.\n");
 			err = -EINVAL;
 			goto out_partial;
 		}
@@ -2377,29 +2520,29 @@ static int kbase_common_device_init(kbase_device *kbdev)
 		kbasep_trace_timeline_debugfs_term(kbdev);
 #endif /* CONFIG_MALI_TRACE_TIMELINE */
 #if MALI_CUSTOMER_RELEASE == 0
+	if (inited & inited_force_replay)
+		device_remove_file(kbdev->dev, &dev_attr_force_replay);
 	if (inited & inited_js_timeouts)
-		device_remove_file(kbdev->osdev.dev, &dev_attr_js_timeouts);
+		device_remove_file(kbdev->dev, &dev_attr_js_timeouts);
 #endif /* MALI_CUSTOMER_RELEASE */
 #ifdef CONFIG_MALI_DEBUG
 	if (inited & inited_js_softstop)
-		device_remove_file(kbdev->osdev.dev, &dev_attr_js_softstop_always);
+		device_remove_file(kbdev->dev, &dev_attr_js_softstop_always);
 
 	if (inited & inited_debug)
-		device_remove_file(kbdev->osdev.dev, &dev_attr_debug_command);
+		device_remove_file(kbdev->dev, &dev_attr_debug_command);
 
 #endif /* CONFIG_MALI_DEBUG */
 
 #ifdef CONFIG_DEBUG_FS
 	if (inited & inited_gpu_memory)
 		kbasep_gpu_memory_debugfs_term(kbdev);
-	if (inited & inited_debugfs)
-		debugfs_remove(kbdev->mali_debugfs_directory);
 #endif /* CONFIG_DEBUG_FS */
 
 #ifdef CONFIG_MALI_DEBUG_SHADER_SPLIT_FS
 	if (inited & inited_sc_split)
 	{
-		device_remove_file(kbdev->osdev.dev, &dev_attr_sc_split);
+		device_remove_file(kbdev->dev, &dev_attr_sc_split);
 	}
 #endif /* CONFIG_MALI_DEBUG_SHADER_SPLIT_FS */
 
@@ -2436,25 +2579,24 @@ static int kbase_common_device_init(kbase_device *kbdev)
 		kbase_pm_term(kbdev);
 
 	down(&kbase_dev_list_lock);
-	list_del(&osdev->entry);
+	list_del(&kbdev->entry);
 	up(&kbase_dev_list_lock);
 
-	device_remove_file(kbdev->osdev.dev, &dev_attr_core_mask);
+	device_remove_file(kbdev->dev, &dev_attr_core_mask);
  out_file_core_mask:
-	device_remove_file(kbdev->osdev.dev, &dev_attr_core_availability_policy);
+	device_remove_file(kbdev->dev, &dev_attr_core_availability_policy);
  out_file_core_availability_policy:
-	device_remove_file(kbdev->osdev.dev, &dev_attr_power_policy);
+	device_remove_file(kbdev->dev, &dev_attr_power_policy);
  out_file:
-	misc_deregister(&kbdev->osdev.mdev);
+	misc_deregister(&kbdev->mdev);
  out_misc:
-	put_device(osdev->dev);
+	put_device(kbdev->dev);
 	return err;
 }
 
 static int kbase_platform_device_probe(struct platform_device *pdev)
 {
 	struct kbase_device *kbdev;
-	struct kbase_os_device *osdev;
 	struct resource *reg_res;
 	kbase_attribute *platform_data;
 	int err;
@@ -2463,19 +2605,6 @@ static int kbase_platform_device_probe(struct platform_device *pdev)
 #ifdef CONFIG_MALI_NO_MALI
 	mali_error mali_err;
 #endif /* CONFIG_MALI_NO_MALI */
-
-const char *dbgname = NULL;
-#if 0
-if(pdev->dev.of_node)
-{
-	of_property_read_string(pdev->dev.of_node,"dbgname",&dbgname);
-	printk("%p,dbgname = %s\r\n",pdev->dev.of_node,dbgname);
-}
-else
-{
-	printk("pdev->dev.of_node null\r\n");
-}
-#endif
 #ifdef CONFIG_OF
 	kbase_platform_config *config;
 	int attribute_count;
@@ -2507,18 +2636,17 @@ else
 	}
 #endif /* CONFIG_MALI_NO_MALI */
 
-	osdev = &kbdev->osdev;
-	osdev->dev = &pdev->dev;
-	platform_data = (kbase_attribute *) osdev->dev->platform_data;
+	kbdev->dev = &pdev->dev;
+	platform_data = (kbase_attribute *) kbdev->dev->platform_data;
 
 	if (NULL == platform_data) {
-		dev_err(osdev->dev, "Platform data not specified\n");
+		dev_err(kbdev->dev, "Platform data not specified\n");
 		err = -ENOENT;
 		goto out_free_dev;
 	}
 
 	if (MALI_TRUE != kbasep_validate_configuration_attributes(kbdev, platform_data)) {
-		dev_err(osdev->dev, "Configuration attributes failed to validate\n");
+		dev_err(kbdev->dev, "Configuration attributes failed to validate\n");
 		err = -EINVAL;
 		goto out_free_dev;
 	}
@@ -2531,10 +2659,11 @@ else
 
 		irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, i);
 		if (!irq_res) {
-			dev_err(osdev->dev, "No IRQ resource at index %d\n", i);
+			dev_err(kbdev->dev, "No IRQ resource at index %d\n", i);
 			err = -ENOENT;
 			goto out_free_dev;
 		}
+
 #ifdef CONFIG_OF
 		if (!strcmp(irq_res->name, "JOB"))
 			irqtag = JOB_IRQ_TAG;
@@ -2551,37 +2680,38 @@ else
 #else
 		irqtag = i;
 #endif /* CONFIG_OF */
-		printk("irq_res->start = 0x%x,irq_res->name = %s\r\n",irq_res->start,irq_res->name);
-	
-		osdev->irqs[irqtag].irq = irq_res->start;
-		osdev->irqs[irqtag].flags = (irq_res->flags & IRQF_TRIGGER_MASK);
+		kbdev->irqs[irqtag].irq = irq_res->start;
+		kbdev->irqs[irqtag].flags = (irq_res->flags & IRQF_TRIGGER_MASK);
 	}
 
 	/* the first memory resource is the physical address of the GPU registers */
 	reg_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!reg_res) {
-		dev_err(&pdev->dev, "Invalid register resource\n");
+		dev_err(kbdev->dev, "Invalid register resource\n");
 		err = -ENOENT;
 		goto out_free_dev;
 	}
-	printk("reg_res->start = 0x%0x,size = 0x%0x\r\n",reg_res->start,resource_size(reg_res));
-	osdev->reg_start = reg_res->start;
-	osdev->reg_size = resource_size(reg_res);
+
+	kbdev->reg_start = reg_res->start;
+	kbdev->reg_size = resource_size(reg_res);
 
 	err = kbase_common_reg_map(kbdev);
 	if (err)
 		goto out_free_dev;
 
-	if (MALI_ERROR_NONE != kbase_device_init(kbdev)) {
-		dev_err(&pdev->dev, "Can't initialize device\n");
-		err = -ENOMEM;
+#ifdef CONFIG_DEBUG_FS
+	kbdev->mali_debugfs_directory = debugfs_create_dir("mali", NULL);
+	if (NULL == kbdev->mali_debugfs_directory) {
+		dev_err(kbdev->dev, "Couldn't create mali debugfs directory\n");
 		goto out_reg_unmap;
 	}
-#ifdef CONFIG_UMP
-	kbdev->memdev.ump_device_id = kbasep_get_config_value(kbdev, platform_data, KBASE_CONFIG_ATTR_UMP_DEVICE);
-#endif /* CONFIG_UMP */
+#endif /* CONFIG_DEBUG_FS */
 
-	kbdev->memdev.per_process_memory_limit = kbasep_get_config_value(kbdev, platform_data, KBASE_CONFIG_ATTR_MEMORY_PER_PROCESS_LIMIT);
+	if (MALI_ERROR_NONE != kbase_device_init(kbdev)) {
+		dev_err(kbdev->dev, "Can't initialize device\n");
+		err = -ENOMEM;
+		goto out_debugfs_remove;
+	}
 
 	/* obtain min/max configured gpu frequencies */
 	core_props = &(kbdev->gpu_props.props.core_props);
@@ -2591,22 +2721,26 @@ else
 
 	err = kbase_common_device_init(kbdev);
 	if (err) {
-		dev_err(osdev->dev, "Failed kbase_common_device_init\n");
+		dev_err(kbdev->dev, "Failed kbase_common_device_init\n");
 		goto out_term_dev;
 	}
 	return 0;
 
- out_term_dev:
+out_term_dev:
 	kbase_device_term(kbdev);
- out_reg_unmap:
+out_debugfs_remove:
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(kbdev->mali_debugfs_directory);
+out_reg_unmap:
+#endif /* CONFIG_DEBUG_FS */
 	kbase_common_reg_unmap(kbdev);
- out_free_dev:
+out_free_dev:
 #ifdef CONFIG_MALI_NO_MALI
 	midg_device_destroy(kbdev);
- out_midg:
+out_midg:
 #endif /* CONFIG_MALI_NO_MALI */
 	kbase_device_free(kbdev);
- out:
+out:
 	return err;
 }
 
@@ -2616,28 +2750,27 @@ static int kbase_common_device_remove(struct kbase_device *kbdev)
 		kbdev->pm.callback_power_runtime_term(kbdev);
 
 	/* Remove the sys power policy file */
-	device_remove_file(kbdev->osdev.dev, &dev_attr_power_policy);
-	device_remove_file(kbdev->osdev.dev, &dev_attr_core_availability_policy);
-	device_remove_file(kbdev->osdev.dev, &dev_attr_core_mask);
+	device_remove_file(kbdev->dev, &dev_attr_power_policy);
+	device_remove_file(kbdev->dev, &dev_attr_core_availability_policy);
+	device_remove_file(kbdev->dev, &dev_attr_core_mask);
 
 #ifdef CONFIG_MALI_TRACE_TIMELINE
 	kbasep_trace_timeline_debugfs_term(kbdev);
 #endif /* CONFIG_MALI_TRACE_TIMELINE */
 
 #ifdef CONFIG_MALI_DEBUG
-	device_remove_file(kbdev->osdev.dev, &dev_attr_js_softstop_always);
-	device_remove_file(kbdev->osdev.dev, &dev_attr_debug_command);
+	device_remove_file(kbdev->dev, &dev_attr_js_softstop_always);
+	device_remove_file(kbdev->dev, &dev_attr_debug_command);
 #endif /* CONFIG_MALI_DEBUG */
 #if MALI_CUSTOMER_RELEASE == 0
-	device_remove_file(kbdev->osdev.dev, &dev_attr_js_timeouts);
+	device_remove_file(kbdev->dev, &dev_attr_js_timeouts);
 #endif /* MALI_CUSTOMER_RELEASE */
 #ifdef CONFIG_DEBUG_FS
 	kbasep_gpu_memory_debugfs_term(kbdev);
-	debugfs_remove(kbdev->mali_debugfs_directory);
-#endif /* CONFIG_DEBUG_FS */
+#endif
 
 #ifdef CONFIG_MALI_DEBUG_SHADER_SPLIT_FS
-	device_remove_file(kbdev->osdev.dev, &dev_attr_sc_split);
+	device_remove_file(kbdev->dev, &dev_attr_sc_split);
 #endif /* CONFIG_MALI_DEBUG_SHADER_SPLIT_FS */
 
 	kbasep_js_devdata_halt(kbdev);
@@ -2653,13 +2786,16 @@ static int kbase_common_device_remove(struct kbase_device *kbdev)
 	kbase_pm_term(kbdev);
 
 	down(&kbase_dev_list_lock);
-	list_del(&kbdev->osdev.entry);
+	list_del(&kbdev->entry);
 	up(&kbase_dev_list_lock);
 
-	misc_deregister(&kbdev->osdev.mdev);
-	put_device(kbdev->osdev.dev);
+	misc_deregister(&kbdev->mdev);
+	put_device(kbdev->dev);
 	kbase_common_reg_unmap(kbdev);
 	kbase_device_term(kbdev);
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(kbdev->mali_debugfs_directory);
+#endif /* CONFIG_DEBUG_FS */
 #ifdef CONFIG_MALI_NO_MALI
 	midg_device_destroy(kbdev);
 #endif /* CONFIG_MALI_NO_MALI */
@@ -2735,7 +2871,7 @@ static int kbase_device_runtime_suspend(struct device *dev)
 
 	if (kbdev->pm.callback_power_runtime_off) {
 		kbdev->pm.callback_power_runtime_off(kbdev);
-		KBASE_DEBUG_PRINT_INFO(KBASE_PM, "runtime suspend\n");
+		KBASE_LOG(1, dev, "runtime suspend\n");
 	}
 	return 0;
 }
@@ -2761,7 +2897,7 @@ int kbase_device_runtime_resume(struct device *dev)
 
 	if (kbdev->pm.callback_power_runtime_on) {
 		ret = kbdev->pm.callback_power_runtime_on(kbdev);
-		KBASE_DEBUG_PRINT_INFO(KBASE_PM, "runtime resume\n");
+		KBASE_LOG(1, dev, "runtime resume\n");
 	}
 	return ret;
 }
@@ -2824,7 +2960,7 @@ static struct platform_driver kbase_platform_driver = {
 #ifdef CONFIG_OF
 #if 0
 module_platform_driver(kbase_platform_driver);
-#else
+#else 
 static int __init rockchip_gpu_init_driver(void)
 {
 	return platform_driver_register(&kbase_platform_driver);
@@ -2832,14 +2968,11 @@ static int __init rockchip_gpu_init_driver(void)
 
 late_initcall(rockchip_gpu_init_driver);
 #endif
-#else /* CONFIG_MALI_PLATFORM_FAKE */
-
+#else
 #ifdef CONFIG_MALI_PLATFORM_FAKE
-#ifndef MALI_PLATFORM_FAKE_MODULE
 extern int kbase_platform_fake_register(void);
 extern void kbase_platform_fake_unregister(void);
 #endif
-#endif
 
 static int __init kbase_driver_init(void)
 {
@@ -2850,18 +2983,14 @@ static int __init kbase_driver_init(void)
 		return ret;
 
 #ifdef CONFIG_MALI_PLATFORM_FAKE
-#ifndef MALI_PLATFORM_FAKE_MODULE
 	ret = kbase_platform_fake_register();
 	if (ret)
 		return ret;
-#endif
 #endif
 	ret = platform_driver_register(&kbase_platform_driver);
 #ifdef CONFIG_MALI_PLATFORM_FAKE
-#ifndef MALI_PLATFORM_FAKE_MODULE
 	if (ret)
 		kbase_platform_fake_unregister();
-#endif
 #endif
 
 	return ret;
@@ -2871,10 +3000,8 @@ static void __exit kbase_driver_exit(void)
 {
 	platform_driver_unregister(&kbase_platform_driver);
 #ifdef CONFIG_MALI_PLATFORM_FAKE
-#ifndef MALI_PLATFORM_FAKE_MODULE
 	kbase_platform_fake_unregister();
 #endif
-#endif
 }
 
 module_init(kbase_driver_init);
@@ -2885,6 +3012,11 @@ module_exit(kbase_driver_exit);
 MODULE_LICENSE("GPL");
 MODULE_VERSION(MALI_RELEASE_NAME);
 
+/* Module parameter to control log level */
+int mali_debug_level = 0;
+module_param(mali_debug_level, int, S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH); /* rw-rw-r-- */
+MODULE_PARM_DESC(mali_debug_level, "Higher number, more dmesg output");
+
 #ifdef CONFIG_MALI_GATOR_SUPPORT
 /* Create the trace points (otherwise we just get code to call a tracepoint) */
 #define CREATE_TRACE_POINTS
@@ -2907,7 +3039,7 @@ void kbase_trace_mali_pm_power_on(u32 event, u64 value)
 
 void kbase_trace_mali_job_slots_event(u32 event, const kbase_context *kctx, u8 atom_id)
 {
-	trace_mali_job_slots_event(event, (kctx != NULL ? kctx->osctx.tgid : 0), (kctx != NULL ? kctx->osctx.pid : 0), atom_id);
+	trace_mali_job_slots_event(event, (kctx != NULL ? kctx->tgid : 0), (kctx != NULL ? kctx->pid : 0), atom_id);
 }
 
 void kbase_trace_mali_page_fault_insert_pages(int event, u32 value)
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cpuprops.c b/drivers/gpu/arm/midgard/mali_kbase_cpuprops.c
old mode 100644
new mode 100755
similarity index 99%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cpuprops.c
rename to drivers/gpu/arm/midgard/mali_kbase_cpuprops.c
index d47d09ba43f5..b37d22ae72b4
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cpuprops.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_cpuprops.c
@@ -23,7 +23,7 @@
 #include "mali_kbase.h"
 #include "mali_kbase_cpuprops.h"
 #include "mali_kbase_uku.h"
-#include <kbase/mali_kbase_config.h>
+#include <mali_kbase_config.h>
 #include <linux/cache.h>
 #include <linux/cpufreq.h>
 #if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cpuprops.h b/drivers/gpu/arm/midgard/mali_kbase_cpuprops.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_cpuprops.h
rename to drivers/gpu/arm/midgard/mali_kbase_cpuprops.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_debug.c b/drivers/gpu/arm/midgard/mali_kbase_debug.c
old mode 100644
new mode 100755
similarity index 53%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_debug.c
rename to drivers/gpu/arm/midgard/mali_kbase_debug.c
index a7cf9bdac998..247ca40bb6cb
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_debug.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_debug.c
@@ -17,7 +17,7 @@
 
 
 
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 
 kbasep_debug_assert_cb kbasep_debug_assert_registered_cb = {
 	NULL,
@@ -37,29 +37,3 @@ void kbasep_debug_assert_call_hook(void)
 }
 KBASE_EXPORT_SYMBOL(kbasep_debug_assert_call_hook);
 
-/**
- * @brief Contains the module names (modules in the same order as for the kbase_module enumeration)
- * @sa kbasep_module_to_str
- */
-static const char *CONST kbasep_str_modules[] = {
-	"UNKNOWN",     /**< Unknown module */
-	"BASE_MMU",    /**< Base MMU */
-	"BASE_JD",     /**< Base Job Dispatch */
-	"BASE_JM",     /**< Base Job Manager */
-	"BASE_CORE",   /**< Base Core */
-	"BASE_MEM",    /**< Base Memory */
-	"BASE_EVENT",  /**< Base Event */
-	"BASE_CTX",    /**< Base Context */
-	"BASE_PM"      /**< Base Power Management */
-};
-
-#define MODULE_STRING_ARRAY_SIZE (sizeof(kbasep_str_modules)/sizeof(kbasep_str_modules[0]))
-
-const char *kbasep_debug_module_to_str(const kbase_module module)
-{
-	if (MODULE_STRING_ARRAY_SIZE <= module)
-		return "";
-
-	return kbasep_str_modules[module];
-}
-KBASE_EXPORT_SYMBOL(kbasep_debug_module_to_str);
diff --git a/drivers/gpu/arm/t6xx/kbase/mali_kbase_debug.h b/drivers/gpu/arm/midgard/mali_kbase_debug.h
old mode 100644
new mode 100755
similarity index 66%
rename from drivers/gpu/arm/t6xx/kbase/mali_kbase_debug.h
rename to drivers/gpu/arm/midgard/mali_kbase_debug.h
index f66d387dbd53..54edc4b11790
--- a/drivers/gpu/arm/t6xx/kbase/mali_kbase_debug.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_debug.h
@@ -22,6 +22,30 @@
 
 #include <linux/bug.h>
 
+extern int mali_debug_level;
+/**
+ * @def KBASEP_LOG(level, ...)
+ * @brief Logs a debug message using dev_dbg().
+ *
+ * Logs a debug message using dev_dbg if the debug level specified for the
+ * message is lower or equal than the current debug level. Use higher
+ * numbers to log messages with increasing verbosity.
+ *
+ * The current debug level is controlled by the module parameter
+ * 'mali_debug_level' which is 0 by default.
+ * 
+ * No special meaning is assigned to debug levels but the recommendation is
+ * 0 = driver init/exit messages
+ * 1 = function entry/exit messages
+ * 2 = function detailed messages
+ * 3 = irq/callback messages
+ * 4 = register read/write messages
+ *
+ * @param level debug level for the message    
+ * @param ... Arguments you would normally pass to dev_dbg()
+ */
+#define KBASE_LOG(level, ...) if ((level) <= mali_debug_level) dev_dbg(__VA_ARGS__)
+
 /** @brief If equals to 0, a trace containing the file, line, and function will be displayed before each message. */
 #define KBASE_DEBUG_SKIP_TRACE 0
 
@@ -37,20 +61,6 @@
 #endif
 #endif				/* KBASE_DEBUG_DISABLE_ASSERTS */
 
-typedef enum {
-	KBASE_UNKNOWN = 0, /**< @brief Unknown module */
-	KBASE_MMU,	   /**< @brief ID of Base MMU */
-	KBASE_JD,	   /**< @brief ID of Base Job Dispatch */
-	KBASE_JM,	   /**< @brief ID of Base Job Manager */
-	KBASE_CORE,	   /**< @brief ID of Base Core */
-	KBASE_MEM,	   /**< @brief ID of Base Memory */
-	KBASE_EVENT,	   /**< @brief ID of Base Event */
-	KBASE_CTX,	   /**< @brief ID of Base Context */
-	KBASE_PM,	   /**< @brief ID of Base Power Management */
-	KBASE_DEV, /**< @brief ID of Base Device */
-	KBASE_MODULES_ALL  /**< @brief Select all the modules at once / Also gives the number of modules in the enum */
-} kbase_module;
-
 /** Function type that is called on an KBASE_DEBUG_ASSERT() or KBASE_DEBUG_ASSERT_MSG() */
 typedef void (kbase_debug_assert_hook) (void *);
 
@@ -88,9 +98,9 @@ typedef struct kbasep_debug_assert_cb {
 #ifdef CONFIG_MALI_DEBUG
 #define KBASEP_DEBUG_ASSERT_OUT(trace, function, ...)\
 		do { \
-			printk(KERN_ERR "Mali<ASSERT>: %s function:%s ", trace, function);\
-			printk(KERN_ERR __VA_ARGS__);\
-			printk(KERN_ERR "\n");\
+			pr_err("Mali<ASSERT>: %s function:%s ", trace, function);\
+			pr_err(__VA_ARGS__);\
+			pr_err("\n");\
 		} while (MALI_FALSE)
 #else
 #define KBASEP_DEBUG_ASSERT_OUT(trace, function, ...) CSTD_NOP()
@@ -135,50 +145,6 @@ typedef struct kbasep_debug_assert_cb {
 		} while (MALI_FALSE)
 #endif				/* KBASE_DEBUG_DISABLE_ASSERTS */
 
-/**
- * @def KBASEP_DEBUG_WARN_OUT(module, trace, ...)
- * @brief (Private) system printing function associated to the @see KBASE_DEBUG_PRINT_WARN event.
- * @param module module ID
- * @param trace location in the code from where the message is printed
- * @param function function from where the message is printed
- * @param ... Format string followed by format arguments.
- * @note function parameter cannot be concatenated with other strings
- */
-#ifdef CONFIG_MALI_DEBUG
-#define KBASE_DEBUG_PRINT_WARN(module, ...)\
-		do {\
-			printk(KERN_WARNING "Mali<WARN, %s>: %s function:%s ", kbasep_debug_module_to_str(module), KBASEP_DEBUG_PRINT_TRACE, KBASEP_DEBUG_PRINT_FUNCTION);\
-			printk(KERN_WARNING __VA_ARGS__);\
-			printk(KERN_WARNING "\n");\
-		} while (MALI_FALSE)
-#else
-#define KBASE_DEBUG_PRINT_WARN(module, ...) CSTD_NOP()
-#endif
-
-#define KBASE_DEBUG_PRINT_ERROR(module, ...)\
-	do {\
-		printk(KERN_ERR "Mali<ERROR, %s>: %s function:%s ", kbasep_debug_module_to_str(module), KBASEP_DEBUG_PRINT_TRACE, KBASEP_DEBUG_PRINT_FUNCTION);\
-		printk(KERN_ERR __VA_ARGS__);\
-		printk(KERN_ERR "\n");\
-	} while (MALI_FALSE)
-
-/*If this is not disabled then Android boot times out*/
-#define KBASE_DEBUG_PRINT_INFO(module, ...) CSTD_NOP()
-
-#define KBASE_DEBUG_PRINT_RAW(module, ...)\
-	do {\
-		printk(__VA_ARGS__);\
-		printk("\n");\
-	} while (MALI_FALSE)
-
-#define KBASE_DEBUG_PRINT_RAW_LEVEL(level, module, ...)\
-	do {\
-		printk(level __VA_ARGS__);\
-		printk(level "\n");\
-	} while (MALI_FALSE)
-
-#define KBASE_DEBUG_PRINT(module, ...) KBASE_DEBUG_PRINT_RAW(module, __VA_ARGS__)
-
 /**
  * @def KBASE_DEBUG_CODE( X )
  * @brief Executes the code inside the macro only in debug mode
@@ -191,6 +157,8 @@ typedef struct kbasep_debug_assert_cb {
 #define KBASE_DEBUG_CODE(X) CSTD_NOP()
 #endif				/* CONFIG_MALI_DEBUG */
 
+/** @} */
+
 /**
  * @brief Register a function to call on ASSERT
  *
@@ -217,13 +185,4 @@ void kbase_debug_assert_register_hook(kbase_debug_assert_hook *func, void *param
  */
 void kbasep_debug_assert_call_hook(void);
 
-/**
- * @brief Convert a module id into a module name.
- *
- * @param module ID of the module to convert
- * @note module names are stored in : @see kbasep_str_modules.
- * @return the name of the given module ID as a string of characters.
- */
-const char *kbasep_debug_module_to_str(const kbase_module module);
-
 #endif				/* _KBASE_DEBUG_H */
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_defs.h b/drivers/gpu/arm/midgard/mali_kbase_defs.h
old mode 100644
new mode 100755
similarity index 90%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_defs.h
rename to drivers/gpu/arm/midgard/mali_kbase_defs.h
index 37a5f7dc0c69..6340cba770a2
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_defs.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_defs.h
@@ -27,10 +27,10 @@
 #ifndef _KBASE_DEFS_H_
 #define _KBASE_DEFS_H_
 
-#include <kbase/mali_kbase_config.h>
-#include <kbase/mali_base_hwconfig.h>
-#include <kbase/src/common/mali_kbase_mem_lowlevel.h>
-#include <kbase/src/common/mali_kbase_mem_alloc.h>
+#include <mali_kbase_config.h>
+#include <mali_base_hwconfig.h>
+#include <mali_kbase_mem_lowlevel.h>
+#include <mali_kbase_mem_alloc.h>
 
 
 #include <linux/atomic.h>
@@ -47,7 +47,7 @@
 #endif				/* CONFIG_SYNC */
 
 /** Enable SW tracing when set */
-#ifdef CONFIG_MALI_T6XX_ENABLE_TRACE
+#ifdef CONFIG_MALI_MIDGARD_ENABLE_TRACE
 #define KBASE_TRACE_ENABLE 1
 #endif
 
@@ -155,6 +155,11 @@ typedef struct kbase_device kbase_device;
 
 #include "mali_kbase_js_defs.h"
 
+#define KBASEP_FORCE_REPLAY_DISABLED 0
+
+/* Maximum force replay limit when randomization is enabled */
+#define KBASEP_FORCE_REPLAY_RANDOM_LIMIT 16
+
 /**
  * @brief States to model state machine processed by kbasep_js_job_check_ref_cores(), which
  * handles retaining cores for power management and affinity management.
@@ -270,6 +275,10 @@ struct kbase_jd_atom {
 	int slot_nr;
 
 	u32 atom_flags;
+
+	/* Number of times this atom has been retried. Used by replay soft job.
+	 */
+	int retry_count;
 };
 
 /*
@@ -392,13 +401,6 @@ typedef struct kbase_as {
 	struct hrtimer poke_timer;
 } kbase_as;
 
-/* tracking of memory usage */
-typedef struct kbasep_mem_usage {
-	u32 max_pages;
-	atomic_t cur_pages;
-} kbasep_mem_usage;
-
-
 /**
  * Instrumentation State Machine States
  */
@@ -425,15 +427,8 @@ typedef enum {
 } kbase_instr_state;
 
 typedef struct kbasep_mem_device {
-#ifdef CONFIG_UMP
-	u32 ump_device_id;	/* Which UMP device this GPU should be mapped to.
-				   Read-only, copied from platform configuration on startup. */
-#endif				/* CONFIG_UMP */
-
-	u32 per_process_memory_limit;	/* How much memory (in bytes) a single process can access.
-					   Read-only, copied from platform configuration on startup. */
-	kbasep_mem_usage usage;	/* Tracks usage of OS shared memory. Initialized with platform
-				   configuration data, updated when OS memory is allocated/freed. */
+	atomic_t used_pages;   /* Tracks usage of OS shared memory. Updated
+				   when OS memory is allocated/freed. */
 
 } kbasep_mem_device;
 
@@ -563,11 +558,36 @@ typedef struct kbasep_kctx_list_element {
 	kbase_context    *kctx;
 } kbasep_kctx_list_element;
 
+#define DEVNAME_SIZE	16
+
 struct kbase_device {
 	/** jm_slots is protected by kbasep_js_device_data::runpool_irq::lock */
 	kbase_jm_slot jm_slots[BASE_JM_MAX_NR_SLOTS];
 	s8 slot_submit_count_irq[BASE_JM_MAX_NR_SLOTS];
-	kbase_os_device osdev;
+
+	struct list_head entry;
+	struct device *dev;
+	struct miscdevice mdev;
+	u64 reg_start;
+	size_t reg_size;
+	void __iomem *reg;
+	struct resource *reg_res;
+	struct {
+		int irq;
+		int flags;
+	} irqs[3];
+	char devname[DEVNAME_SIZE];
+
+#ifdef CONFIG_MALI_NO_MALI
+	void *model;
+	struct kmem_cache *irq_slab;
+	struct workqueue_struct *irq_workq;
+	atomic_t serving_job_irq;
+	atomic_t serving_gpu_irq;
+	atomic_t serving_mmu_irq;
+	spinlock_t reg_op_lock;
+#endif				/* CONFIG_MALI_NO_MALI */
+
 	kbase_pm_device_data pm;
 	kbasep_js_device_data js_data;
 	kbasep_mem_device memdev;
@@ -679,17 +699,23 @@ struct kbase_device {
 #if MALI_CUSTOMER_RELEASE == 0
 	/* This is used to override the current job scheduler values for
 	 * KBASE_CONFIG_ATTR_JS_STOP_STOP_TICKS_SS
+	 * KBASE_CONFIG_ATTR_JS_STOP_STOP_TICKS_CL
 	 * KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS
+	 * KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL
 	 * KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS
 	 * KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS
+	 * KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL
 	 * KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS.
 	 *
 	 * These values are set via the js_timeouts sysfs file.
 	 */
 	u32 js_soft_stop_ticks;
+	u32 js_soft_stop_ticks_cl;
 	u32 js_hard_stop_ticks_ss;
+	u32 js_hard_stop_ticks_cl;
 	u32 js_hard_stop_ticks_nss;
 	u32 js_reset_ticks_ss;
+	u32 js_reset_ticks_cl;
 	u32 js_reset_ticks_nss;
 #endif
 
@@ -705,7 +731,7 @@ struct kbase_device {
 	struct list_head        kctx_list;
 	struct mutex            kctx_list_lock;
 
-#ifdef CONFIG_MALI_T6XX_RT_PM
+#ifdef CONFIG_MALI_MIDGARD_RT_PM
 	struct delayed_work runtime_pm_workqueue;
 #endif
 
@@ -724,6 +750,24 @@ struct kbase_device {
 
 	/* fbdump profiling controls set by gator */
 	u32 kbase_profiling_controls[FBDUMP_CONTROL_MAX];
+
+
+#if MALI_CUSTOMER_RELEASE == 0
+	/* Number of jobs that are run before a job is forced to fail and
+	 * replay. May be KBASEP_FORCE_REPLAY_DISABLED, to disable forced
+	 * failures. */
+	int force_replay_limit;
+	/* Count of jobs between forced failures. Incremented on each job. A
+	 * job is forced to fail once this is greater than or equal to
+	 * force_replay_limit. */
+	int force_replay_count;
+	/* Core requirement for jobs to be failed and replayed. May be zero. */
+	base_jd_core_req force_replay_core_req;
+	/* MALI_TRUE if force_replay_limit should be randomized. The random
+	 * value will be in the range of 1 - KBASEP_FORCE_REPLAY_RANDOM_LIMIT.
+	 */
+	mali_bool force_replay_random;
+#endif
 };
 
 struct kbase_context {
@@ -734,6 +778,8 @@ struct kbase_context {
 	mali_bool event_closed;
 	struct workqueue_struct *event_workq;
 
+	u64 mem_attrs;
+
 	atomic_t                setup_complete;
 	atomic_t                setup_in_progress;
 
@@ -741,12 +787,20 @@ struct kbase_context {
 
 	u64 *mmu_teardown_pages;
 
+	phys_addr_t aliasing_sink_page;
+
 	struct mutex            reg_lock; /* To be converted to a rwlock? */
 	struct rb_root          reg_rbtree; /* Red-Black tree of GPU regions (live regions) */
 
-	kbase_os_context osctx;
+	unsigned long    cookies;
+	struct kbase_va_region *pending_regions[BITS_PER_LONG];
+	
+	wait_queue_head_t event_queue;
+	pid_t tgid;
+	pid_t pid;
+
 	kbase_jd_context jctx;
-	kbasep_mem_usage usage;
+	atomic_t used_pages;
 	atomic_t         nonmapped_pages;
 
 	kbase_mem_allocator osalloc;
@@ -803,4 +857,18 @@ typedef enum kbase_share_attr_bits {
 /* Maximum number of loops polling the GPU for an AS flush to complete before we assume the GPU has hung */
 #define KBASE_AS_FLUSH_MAX_LOOPS        100000
 
+/* Return values from kbase_replay_process */
+
+/* Replay job has completed */
+#define MALI_REPLAY_STATUS_COMPLETE  0
+/* Replay job is replaying and will continue once replayed jobs have completed.
+ */
+#define MALI_REPLAY_STATUS_REPLAYING 1
+#define MALI_REPLAY_STATUS_MASK      0xff
+/* Caller must call kbasep_js_try_schedule_head_ctx */
+#define MALI_REPLAY_FLAG_JS_RESCHED  0x100
+
+/* Maximum number of times a job can be replayed */
+#define BASEP_JD_REPLAY_LIMIT 15
+
 #endif				/* _KBASE_DEFS_H_ */
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_device.c b/drivers/gpu/arm/midgard/mali_kbase_device.c
old mode 100644
new mode 100755
similarity index 94%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_device.c
rename to drivers/gpu/arm/midgard/mali_kbase_device.c
index 8b545827dbb9..c321ebf8c01a
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_device.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_device.c
@@ -27,11 +27,11 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_defs.h>
-#include <kbase/src/common/mali_kbase_hw.h>
+#include <mali_kbase.h>
+#include <mali_kbase_defs.h>
+#include <mali_kbase_hw.h>
 
-#include <kbase/src/mali_kbase_profiling_gator_api.h>
+#include <mali_kbase_profiling_gator_api.h>
 
 /* NOTE: Magic - 0x45435254 (TRCE in ASCII).
  * Supports tracing feature provided in the base module.
@@ -325,7 +325,8 @@ void kbase_reg_write(kbase_device *kbdev, u16 offset, u32 value, kbase_context *
 {
 	KBASE_DEBUG_ASSERT(kbdev->pm.gpu_powered);
 	KBASE_DEBUG_ASSERT(kctx == NULL || kctx->as_nr != KBASEP_AS_NR_INVALID);
-	KBASE_DEBUG_PRINT_INFO(KBASE_CORE, "w: reg %04x val %08x", offset, value);
+	KBASE_DEBUG_ASSERT(kbdev->dev != NULL);
+	KBASE_LOG(4, kbdev->dev, "w: reg %04x val %08x", offset, value);
 	kbase_os_reg_write(kbdev, offset, value);
 	if (kctx && kctx->jctx.tb)
 		kbase_device_trace_register_access(kctx, REG_WRITE, offset, value);
@@ -338,8 +339,9 @@ u32 kbase_reg_read(kbase_device *kbdev, u16 offset, kbase_context *kctx)
 	u32 val;
 	KBASE_DEBUG_ASSERT(kbdev->pm.gpu_powered);
 	KBASE_DEBUG_ASSERT(kctx == NULL || kctx->as_nr != KBASEP_AS_NR_INVALID);
+	KBASE_DEBUG_ASSERT(kbdev->dev != NULL);
 	val = kbase_os_reg_read(kbdev, offset);
-	KBASE_DEBUG_PRINT_INFO(KBASE_CORE, "r: reg %04x val %08x", offset, val);
+	KBASE_LOG(4, kbdev->dev, "r: reg %04x val %08x", offset, val);
 	if (kctx && kctx->jctx.tb)
 		kbase_device_trace_register_access(kctx, REG_READ, offset, val);
 	return val;
@@ -356,9 +358,9 @@ void kbase_report_gpu_fault(kbase_device *kbdev, int multiple)
 	address = (u64) kbase_reg_read(kbdev, GPU_CONTROL_REG(GPU_FAULTADDRESS_HI), NULL) << 32;
 	address |= kbase_reg_read(kbdev, GPU_CONTROL_REG(GPU_FAULTADDRESS_LO), NULL);
 
-	KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "GPU Fault 0x%08x (%s) at 0x%016llx", status, kbase_exception_name(status), address);
+	dev_warn(kbdev->dev, "GPU Fault 0x%08x (%s) at 0x%016llx", status & 0xFF, kbase_exception_name(status), address);
 	if (multiple)
-		KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "There were multiple GPU faults - some have not been reported\n");
+		dev_warn(kbdev->dev, "There were multiple GPU faults - some have not been reported\n");
 }
 
 void kbase_gpu_interrupt(kbase_device *kbdev, u32 val)
@@ -483,12 +485,12 @@ void kbasep_trace_format_msg(kbase_trace *trace_msg, char *buffer, int len)
 
 }
 
-void kbasep_trace_dump_msg(kbase_trace *trace_msg)
+void kbasep_trace_dump_msg(kbase_device *kbdev, kbase_trace *trace_msg)
 {
 	char buffer[DEBUG_MESSAGE_SIZE];
 
 	kbasep_trace_format_msg(trace_msg, buffer, DEBUG_MESSAGE_SIZE);
-	KBASE_DEBUG_PRINT(KBASE_CORE, "%s", buffer);
+	KBASE_LOG(1, kbdev->dev, "%s", buffer);
 }
 
 void kbasep_trace_add(kbase_device *kbdev, kbase_trace_code code, void *ctx, kbase_jd_atom *katom, u64 gpu_addr, u8 flags, int refcount, int jobslot, unsigned long info_val)
@@ -548,18 +550,18 @@ void kbasep_trace_dump(kbase_device *kbdev)
 	u32 start;
 	u32 end;
 
-	KBASE_DEBUG_PRINT(KBASE_CORE, "Dumping trace:\nsecs,nthread,cpu,code,ctx,katom,gpu_addr,jobslot,refcount,info_val");
+	KBASE_LOG(1, kbdev->dev, "Dumping trace:\nsecs,nthread,cpu,code,ctx,katom,gpu_addr,jobslot,refcount,info_val");
 	spin_lock_irqsave(&kbdev->trace_lock, flags);
 	start = kbdev->trace_first_out;
 	end = kbdev->trace_next_in;
 
 	while (start != end) {
 		kbase_trace *trace_msg = &kbdev->trace_rbuf[start];
-		kbasep_trace_dump_msg(trace_msg);
+		kbasep_trace_dump_msg(kbdev, trace_msg);
 
 		start = (start + 1) & KBASE_TRACE_MASK;
 	}
-	KBASE_DEBUG_PRINT(KBASE_CORE, "TRACE_END");
+	KBASE_LOG(1, kbdev->dev, "TRACE_END");
 
 	spin_unlock_irqrestore(&kbdev->trace_lock, flags);
 
@@ -584,11 +586,16 @@ void *kbasep_trace_seq_start(struct seq_file *s, loff_t *pos)
 	struct trace_seq_state *state = s->private;
 	int i;
 
-	i = (state->start + *pos) & KBASE_TRACE_MASK;
-	if (i >= state-> end)
+	if (*pos > KBASE_TRACE_SIZE)
+		return NULL;
+	i = state->start + *pos;
+	if ((state->end >= state->start && i >= state->end) ||
+			i >= state->end + KBASE_TRACE_SIZE)
 		return NULL;
 
-	return state;
+	i &= KBASE_TRACE_MASK;
+
+	return &state->trace_buf[i];
 }
 
 void kbasep_trace_seq_stop(struct seq_file *s, void *data)
@@ -603,7 +610,7 @@ void *kbasep_trace_seq_next(struct seq_file *s, void *data, loff_t *pos)
 	(*pos)++;
 
 	i = (state->start + *pos) & KBASE_TRACE_MASK;
-	if (i >= state->end)
+	if (i == state->end)
 		return NULL;
 
 	return &state->trace_buf[i];
@@ -655,7 +662,9 @@ static const struct file_operations kbasep_trace_debugfs_fops = {
 
 STATIC void kbasep_trace_debugfs_init(kbase_device *kbdev)
 {
-	kbdev->trace_dentry = debugfs_create_file("mali_trace", S_IRUGO, NULL, kbdev, &kbasep_trace_debugfs_fops);
+	kbdev->trace_dentry = debugfs_create_file("mali_trace", S_IRUGO,
+			kbdev->mali_debugfs_directory, kbdev,
+			&kbasep_trace_debugfs_fops);
 }
 #else
 STATIC void kbasep_trace_debugfs_init(kbase_device *kbdev)
@@ -718,7 +727,7 @@ void kbase_set_profiling_control(struct kbase_device *kbdev, u32 control, u32 va
 		kbdev->kbase_profiling_controls[control] = value;
 		break;
 	default:
-		KBASE_DEBUG_PRINT_ERROR(KBASE_DEV, "Profiling control %d not found\n", control);
+		dev_err(kbdev->dev, "Profiling control %d not found\n", control);
 		break;
 	}
 }
@@ -738,7 +747,7 @@ u32 kbase_get_profiling_control(struct kbase_device *kbdev, u32 control)
 		ret_value = kbdev->kbase_profiling_controls[control];
 		break;
 	default:
-		KBASE_DEBUG_PRINT_ERROR(KBASE_DEV, "Profiling control %d not found\n", control);
+		dev_err(kbdev->dev, "Profiling control %d not found\n", control);
 		break;
 	}
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_event.c b/drivers/gpu/arm/midgard/mali_kbase_event.c
old mode 100644
new mode 100755
similarity index 90%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_event.c
rename to drivers/gpu/arm/midgard/mali_kbase_event.c
index 111d3f7666a0..acbccaabf6ea
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_event.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_event.c
@@ -17,9 +17,8 @@
 
 
 
-#include <kbase/src/common/mali_kbase.h>
-
-#define beenthere(f, a...)	pr_debug("%s:" f, __func__, ##a)
+#include <mali_kbase.h>
+#include <mali_kbase_debug.h>
 
 STATIC base_jd_udata kbase_event_process(kbase_context *kctx, kbase_jd_atom *katom)
 {
@@ -33,7 +32,9 @@ STATIC base_jd_udata kbase_event_process(kbase_context *kctx, kbase_jd_atom *kat
 
 	KBASE_TIMELINE_ATOMS_IN_FLIGHT(kctx, atomic_sub_return(1, &kctx->timeline.jd_atoms_in_flight));
 
+	mutex_lock(&kctx->jctx.lock);
 	katom->status = KBASE_JD_ATOM_STATE_UNUSED;
+	mutex_unlock(&kctx->jctx.lock);
 
 	wake_up(&katom->completed);
 
@@ -69,7 +70,9 @@ int kbase_event_dequeue(kbase_context *ctx, base_jd_event_v2 *uevent)
 			mutex_unlock(&ctx->event_mutex);
 			uevent->event_code = BASE_JD_EVENT_DRV_TERMINATED;
 			memset(&uevent->udata, 0, sizeof(uevent->udata));
-			beenthere("event system closed, returning BASE_JD_EVENT_DRV_TERMINATED(0x%X)\n", BASE_JD_EVENT_DRV_TERMINATED);
+			KBASE_LOG(2, ctx->kbdev->dev,
+				"event system closed, returning BASE_JD_EVENT_DRV_TERMINATED(0x%X)\n",
+				BASE_JD_EVENT_DRV_TERMINATED);
 			return 0;
 		} else {
 			mutex_unlock(&ctx->event_mutex);
@@ -83,7 +86,7 @@ int kbase_event_dequeue(kbase_context *ctx, base_jd_event_v2 *uevent)
 
 	mutex_unlock(&ctx->event_mutex);
 
-	beenthere("event dequeuing %p\n", (void *)atom);
+	KBASE_LOG(2, ctx->kbdev->dev, "event dequeuing %p\n", (void *)atom);
 	uevent->event_code = atom->event_code;
 	uevent->atom_number = (atom - ctx->jctx.atoms);
 	uevent->udata = kbase_event_process(ctx, atom);
@@ -109,6 +112,12 @@ static void kbase_event_post_worker(struct work_struct *data)
 		}
 	}
 
+	if (atom->core_req & BASEP_JD_REQ_EVENT_NEVER) {
+		/* Don't report the event */
+		kbase_event_process(ctx, atom);
+		return;
+	}
+
 	mutex_lock(&ctx->event_mutex);
 	list_add_tail(&atom->dep_item[0], &ctx->event_list);
 	mutex_unlock(&ctx->event_mutex);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gator.h b/drivers/gpu/arm/midgard/mali_kbase_gator.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gator.h
rename to drivers/gpu/arm/midgard/mali_kbase_gator.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_gpu_memory_debugfs.c b/drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.c
old mode 100644
new mode 100755
similarity index 81%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_gpu_memory_debugfs.c
rename to drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.c
index ade0cef328d7..e2948b1b501c
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_gpu_memory_debugfs.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.c
@@ -15,7 +15,7 @@
 
 
 
-#include <kbase/src/linux/mali_kbase_gpu_memory_debugfs.h>
+#include <mali_kbase_gpu_memory_debugfs.h>
 
 /** Show callback for the @c gpu_memory debugfs file.
  *
@@ -34,28 +34,24 @@ static int kbasep_gpu_memory_seq_show(struct seq_file *sfile, void *data)
 	ssize_t ret = 0;
 	struct list_head *entry;
 	const struct list_head *kbdev_list;
-	ret = seq_printf(sfile, "Name              cap(pages) usage(pages)\n" \
-				"========================================\n");
 	kbdev_list = kbase_dev_list_get();
 	list_for_each(entry, kbdev_list) {
 		struct kbase_device *kbdev = NULL;
 		kbasep_kctx_list_element *element;
 
-		kbdev = list_entry(entry, struct kbase_device, osdev.entry);
+		kbdev = list_entry(entry, struct kbase_device, entry);
 		/* output the total memory usage and cap for this device */
-		ret = seq_printf(sfile, "%-16s  %10u   %10u\n", \
-				kbdev->osdev.devname, \
-				kbdev->memdev.usage.max_pages, \
-				atomic_read(&(kbdev->memdev.usage.cur_pages)));
+		ret = seq_printf(sfile, "%-16s  %10u\n", \
+				kbdev->devname, \
+				atomic_read(&(kbdev->memdev.used_pages)));
 		mutex_lock(&kbdev->kctx_list_lock);
 		list_for_each_entry(element, &kbdev->kctx_list, link) {
 			/* output the memory usage and cap for each kctx
 			* opened on this device */
-			ret = seq_printf(sfile, "  %s-0x%p %10u   %10u\n", \
+			ret = seq_printf(sfile, "  %s-0x%p %10u\n", \
 				"kctx",
 				element->kctx, \
-				element->kctx->usage.max_pages, \
-				atomic_read(&(element->kctx->usage.cur_pages)));
+				atomic_read(&(element->kctx->used_pages)));
 		}
 		mutex_unlock(&kbdev->kctx_list_lock);
 	}
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_gpu_memory_debugfs.h b/drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.h
old mode 100644
new mode 100755
similarity index 96%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_gpu_memory_debugfs.h
rename to drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.h
index 4fefcead9220..b53a9ffdedf9
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_gpu_memory_debugfs.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.h
@@ -26,7 +26,7 @@
 #ifndef _KBASE_GPU_MEMORY_H
 #define _KBASE_GPU_MEMORY_H
 
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gpuprops.c b/drivers/gpu/arm/midgard/mali_kbase_gpuprops.c
old mode 100644
new mode 100755
similarity index 96%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gpuprops.c
rename to drivers/gpu/arm/midgard/mali_kbase_gpuprops.c
index 4d09b7e0cc33..0fbefea11af8
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gpuprops.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_gpuprops.c
@@ -22,9 +22,9 @@
  * Base kernel property query APIs
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_midg_regmap.h>
-#include <kbase/src/common/mali_kbase_gpuprops.h>
+#include <mali_kbase.h>
+#include <mali_midg_regmap.h>
+#include <mali_kbase_gpuprops.h>
 
 /**
  * @brief Extracts bits from a 32-bit bitfield.
@@ -62,7 +62,7 @@ mali_error kbase_gpuprops_uk_get_props(kbase_context *kctx, kbase_uk_gpuprops *
 		if (rc == 0) {
 			u32 gpu_speed_khz = gpu_speed_mhz * 1000;
 			if (gpu_speed_khz < kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_min || gpu_speed_khz > kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_max)
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "GPU Speed is outside of min/max range (got %lu Khz, min %lu Khz, max %lu Khz)\n", (unsigned long)gpu_speed_khz, (unsigned long)kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_min, (unsigned long)kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_max);
+				dev_warn(kctx->kbdev->dev, "GPU Speed is outside of min/max range (got %lu Khz, min %lu Khz, max %lu Khz)\n", (unsigned long)gpu_speed_khz, (unsigned long)kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_min, (unsigned long)kctx->kbdev->gpu_props.props.core_props.gpu_freq_khz_max);
 		}
 #endif				/* CONFIG_MALI_DEBUG */
 	}
@@ -183,7 +183,7 @@ STATIC void kbase_gpuprops_construct_coherent_groups(base_gpu_props * const prop
 	}
 
 	if (group_present != 0)
-		KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Too many coherent groups (keeping only %d groups).\n", BASE_MAX_COHERENT_GROUPS);
+		pr_warn("Too many coherent groups (keeping only %d groups).\n", BASE_MAX_COHERENT_GROUPS);
 
 	props->coherency_info.num_groups = num_groups;
 }
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gpuprops.h b/drivers/gpu/arm/midgard/mali_kbase_gpuprops.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gpuprops.h
rename to drivers/gpu/arm/midgard/mali_kbase_gpuprops.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gpuprops_types.h b/drivers/gpu/arm/midgard/mali_kbase_gpuprops_types.h
old mode 100644
new mode 100755
similarity index 98%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gpuprops_types.h
rename to drivers/gpu/arm/midgard/mali_kbase_gpuprops_types.h
index d5414ff795bb..8793e0aff664
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_gpuprops_types.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_gpuprops_types.h
@@ -25,7 +25,7 @@
 #ifndef _KBASE_GPUPROPS_TYPES_H_
 #define _KBASE_GPUPROPS_TYPES_H_
 
-#include <kbase/mali_base_kernel.h>
+#include "mali_base_kernel.h"
 
 #define KBASE_GPU_SPEED_MHZ    123
 #define KBASE_GPU_PC_SIZE_LOG2 24U
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_hw.c b/drivers/gpu/arm/midgard/mali_kbase_hw.c
old mode 100644
new mode 100755
similarity index 67%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_hw.c
rename to drivers/gpu/arm/midgard/mali_kbase_hw.c
index ccecf888ce53..1fe4100a4844
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_hw.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_hw.c
@@ -22,8 +22,8 @@
  * Run-time work-arounds helpers
  */
 
-#include <kbase/mali_base_hwconfig.h>
-#include <kbase/src/common/mali_midg_regmap.h>
+#include <mali_base_hwconfig.h>
+#include <mali_midg_regmap.h>
 #include "mali_kbase.h"
 #include "mali_kbase_hw.h"
 
@@ -37,6 +37,11 @@ void kbase_hw_set_features_mask(kbase_device *kbdev)
 	switch (gpu_id) {
 	case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 0, 0):
 	case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 0, 1):
+	case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 1, 1):
+	case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 1, 9):
+	case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 2, 1):
+	case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 3, 1):
+	case GPU_ID_MAKE(GPU_ID_PI_T76X, 1, 0, 0):
 		features = base_hw_features_t76x;
 		break;
 	default:
@@ -68,13 +73,6 @@ mali_error kbase_hw_set_issues_mask(kbase_device *kbdev)
 		case GPU_ID_MAKE(GPU_ID_PI_T60X, 0, 1, 0):
 			issues = base_hw_issues_t60x_r0p1;
 			break;
-		case GPU_ID_MAKE(GPU_ID_PI_T65X, 0, 1, 0):
-			issues = base_hw_issues_t65x_r0p1;
-			break;
-		case GPU_ID_MAKE(GPU_ID_PI_T62X, 0, 0, 0):
-		case GPU_ID_MAKE(GPU_ID_PI_T62X, 0, 0, 1):
-			issues = base_hw_issues_t62x_r0p0;
-			break;
 		case GPU_ID_MAKE(GPU_ID_PI_T62X, 0, 1, 0):
 			issues = base_hw_issues_t62x_r0p1;
 			break;
@@ -82,13 +80,6 @@ mali_error kbase_hw_set_issues_mask(kbase_device *kbdev)
 		case GPU_ID_MAKE(GPU_ID_PI_T62X, 1, 0, 1):
 			issues = base_hw_issues_t62x_r1p0;
 	 		break;
-		case GPU_ID_MAKE(GPU_ID_PI_T67X, 0, 0, 0):
-		case GPU_ID_MAKE(GPU_ID_PI_T67X, 0, 0, 1):
-			issues = base_hw_issues_t67x_r0p0;
-			break;
-		case GPU_ID_MAKE(GPU_ID_PI_T67X, 0, 1, 0):
-			issues = base_hw_issues_t67x_r0p1;
-			break;
 		case GPU_ID_MAKE(GPU_ID_PI_T67X, 1, 0, 0):
 		case GPU_ID_MAKE(GPU_ID_PI_T67X, 1, 0, 1):
 			issues = base_hw_issues_t67x_r1p0;
@@ -99,12 +90,33 @@ mali_error kbase_hw_set_issues_mask(kbase_device *kbdev)
 		case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 0, 1):
 			issues = base_hw_issues_t76x_r0p0;
 			break;
-
+		case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 1, 1):
+			issues = base_hw_issues_t76x_r0p1;
+			break;
+		case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 1, 9):
+			/* TODO: MIDBASE-3084 - confirm hw issue list */
+			issues = base_hw_issues_t76x_r0p1;
+			break;
+		case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 2, 1):
+			issues = base_hw_issues_t76x_r0p2;
+			break;
+		case GPU_ID_MAKE(GPU_ID_PI_T76X, 0, 3, 1):
+			/* TODO: MIDBASE-3086 - confirm hw issue list */
+			issues = base_hw_issues_t76x_r0p2;
+			break;
+		case GPU_ID_MAKE(GPU_ID_PI_T76X, 1, 0, 0):
+			issues = base_hw_issues_t76x_r1p0;
+			break;
 		case GPU_ID_MAKE(GPU_ID_PI_T72X, 0, 0, 0):
+		case GPU_ID_MAKE(GPU_ID_PI_T72X, 0, 0, 1):
+		case GPU_ID_MAKE(GPU_ID_PI_T72X, 0, 0, 2):
 			issues = base_hw_issues_t72x_r0p0;
 			break;
+		case GPU_ID_MAKE(GPU_ID_PI_T72X, 1, 0, 0):
+			issues = base_hw_issues_t72x_r1p0;
+			break;
 		default:
-			KBASE_DEBUG_PRINT_ERROR(KBASE_CORE, "Unknown GPU ID %x", gpu_id);
+			dev_err(kbdev->dev, "Unknown GPU ID %x", gpu_id);
 			return MALI_ERROR_FUNCTION_FAILED;
 		}
 	} else {
@@ -112,7 +124,6 @@ mali_error kbase_hw_set_issues_mask(kbase_device *kbdev)
 		switch (gpu_id >> GPU_ID_VERSION_PRODUCT_ID_SHIFT) {
 		case GPU_ID_PI_T60X:
 		case GPU_ID_PI_T62X:
-		case GPU_ID_PI_T65X:
 		case GPU_ID_PI_T67X:
 			issues = base_hw_issues_model_t6xx;
 			break;
@@ -124,12 +135,12 @@ mali_error kbase_hw_set_issues_mask(kbase_device *kbdev)
 			break;
 
 		default:
-			KBASE_DEBUG_PRINT_ERROR(KBASE_CORE, "Unknown GPU ID %x", gpu_id);
+			dev_err(kbdev->dev, "Unknown GPU ID %x", gpu_id);
 			return MALI_ERROR_FUNCTION_FAILED;
 		}
 	}
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_CORE, "GPU identified as 0x%04x r%dp%d status %d", (gpu_id & GPU_ID_VERSION_PRODUCT_ID) >> GPU_ID_VERSION_PRODUCT_ID_SHIFT, (gpu_id & GPU_ID_VERSION_MAJOR) >> GPU_ID_VERSION_MAJOR_SHIFT, (gpu_id & GPU_ID_VERSION_MINOR) >> GPU_ID_VERSION_MINOR_SHIFT, (gpu_id & GPU_ID_VERSION_STATUS) >> GPU_ID_VERSION_STATUS_SHIFT);
+	dev_info(kbdev->dev, "GPU identified as 0x%04x r%dp%d status %d", (gpu_id & GPU_ID_VERSION_PRODUCT_ID) >> GPU_ID_VERSION_PRODUCT_ID_SHIFT, (gpu_id & GPU_ID_VERSION_MAJOR) >> GPU_ID_VERSION_MAJOR_SHIFT, (gpu_id & GPU_ID_VERSION_MINOR) >> GPU_ID_VERSION_MINOR_SHIFT, (gpu_id & GPU_ID_VERSION_STATUS) >> GPU_ID_VERSION_STATUS_SHIFT);
 
 	for (; *issues != BASE_HW_ISSUE_END; issues++)
 		set_bit(*issues, &kbdev->hw_issues_mask[0]);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_hw.h b/drivers/gpu/arm/midgard/mali_kbase_hw.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_hw.h
rename to drivers/gpu/arm/midgard/mali_kbase_hw.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_instr.c b/drivers/gpu/arm/midgard/mali_kbase_instr.c
old mode 100644
new mode 100755
similarity index 98%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_instr.c
rename to drivers/gpu/arm/midgard/mali_kbase_instr.c
index ed53213fce3e..1e87476b3f3e
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_instr.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_instr.c
@@ -22,8 +22,8 @@
  * Base kernel instrumentation APIs.
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_midg_regmap.h>
+#include <mali_kbase.h>
+#include <mali_midg_regmap.h>
 
 /**
  * @brief Issue Cache Clean & Invalidate command to hardware
@@ -177,7 +177,7 @@ STATIC mali_error kbase_instr_hwcnt_enable_internal(kbase_device *kbdev, kbase_c
 
 	err = MALI_ERROR_NONE;
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_CORE, "HW counters dumping set-up for context %p", kctx);
+	KBASE_LOG(1, kbdev->dev, "HW counters dumping set-up for context %p", kctx);
 	return err;
  out_unrequest_cores:
 	kbase_pm_unrequest_cores(kbdev, MALI_TRUE, shader_cores_needed);
@@ -275,7 +275,7 @@ mali_error kbase_instr_hwcnt_disable(kbase_context *kctx)
 	/* Also release our Power Manager Active reference */
 	kbase_pm_context_idle(kbdev);
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_CORE, "HW counters dumping disabled for context %p", kctx);
+	KBASE_LOG(1, kbdev->dev, "HW counters dumping disabled for context %p", kctx);
 
 	err = MALI_ERROR_NONE;
 
@@ -355,7 +355,7 @@ mali_error kbase_instr_hwcnt_dump_irq(kbase_context *kctx)
 	KBASE_TRACE_ADD(kbdev, CORE_GPU_PRFCNT_SAMPLE, NULL, NULL, kbdev->hwcnt.addr, 0);
 	kbase_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_PRFCNT_SAMPLE, kctx);
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_CORE, "HW counters dumping done for context %p", kctx);
+	KBASE_LOG(1, kbdev->dev, "HW counters dumping done for context %p", kctx);
 
 	err = MALI_ERROR_NONE;
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_jd.c b/drivers/gpu/arm/midgard/mali_kbase_jd.c
old mode 100644
new mode 100755
similarity index 87%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_jd.c
rename to drivers/gpu/arm/midgard/mali_kbase_jd.c
index da9544480e38..0f877d152efd
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_jd.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_jd.c
@@ -23,15 +23,21 @@
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
 #endif
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_uku.h>
-#include <kbase/src/common/mali_kbase_js_affinity.h>
-#include <kbase/src/common/mali_kbase_10969_workaround.h>
+#include <mali_kbase.h>
+#include <mali_kbase_uku.h>
+#include <mali_kbase_js_affinity.h>
+#include <mali_kbase_10969_workaround.h>
 #ifdef CONFIG_UMP
 #include <linux/ump.h>
 #endif				/* CONFIG_UMP */
+#include <linux/random.h>
 
-#define beenthere(f, a...)  KBASE_DEBUG_PRINT_INFO(KBASE_JD, "%s:" f, __func__, ##a)
+#define beenthere(kctx,f, a...)  KBASE_LOG(1, kctx->kbdev->dev, "%s:" f, __func__, ##a)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+/* random32 was renamed to prandom_u32 in 3.8 */
+#define prandom_u32 random32
+#endif
 
 /*
  * This is the kernel side of the API. Only entry points are:
@@ -71,7 +77,17 @@ static int jd_run_atom(kbase_jd_atom *katom)
 		return 0;
 	} else if (katom->core_req & BASE_JD_REQ_SOFT_JOB) {
 		/* Soft-job */
-		if (kbase_process_soft_job(katom) == 0) {
+		if ((katom->core_req & BASEP_JD_REQ_ATOM_TYPE)
+						  == BASE_JD_REQ_SOFT_REPLAY) {
+			int status = kbase_replay_process(katom);
+
+			if ((status & MALI_REPLAY_STATUS_MASK)
+					       == MALI_REPLAY_STATUS_REPLAYING)
+				return status & MALI_REPLAY_FLAG_JS_RESCHED;
+			else
+				katom->status = KBASE_JD_ATOM_STATE_COMPLETED;
+			return 0;
+		} else if (kbase_process_soft_job(katom) == 0) {
 			kbase_finish_soft_job(katom);
 			katom->status = KBASE_JD_ATOM_STATE_COMPLETED;
 		} else {
@@ -80,6 +96,7 @@ static int jd_run_atom(kbase_jd_atom *katom)
 		}
 		return 0;
 	}
+
 	katom->status = KBASE_JD_ATOM_STATE_IN_JS;
 	/* Queue an action about whether we should try scheduling a context */
 	return kbasep_js_add_job(kctx, katom);
@@ -193,15 +210,36 @@ static mali_error kbase_jd_umm_map(kbase_context *kctx, struct kbase_va_region *
 
 	for_each_sg(sgt->sgl, s, sgt->nents, i) {
 		int j;
-		size_t pages = PFN_DOWN(sg_dma_len(s));
+		size_t pages = PFN_UP(sg_dma_len(s));
+
+		WARN_ONCE(sg_dma_len(s) & (PAGE_SIZE-1),
+		"sg_dma_len(s)=%u is not a multiple of PAGE_SIZE\n",
+		sg_dma_len(s));
+
+		WARN_ONCE(sg_dma_address(s) & (PAGE_SIZE-1),
+		"sg_dma_address(s)=%llx is not aligned to PAGE_SIZE\n",
+		(unsigned long long) sg_dma_address(s));
 
 		for (j = 0; (j < pages) && (count < reg->nr_pages); j++, count++)
 			*pa++ = sg_dma_address(s) + (j << PAGE_SHIFT);
-		WARN_ONCE(j < pages, "sg list returned by dma_buf_map_attachment is larger than dma_buf->size=%zu\n", reg->alloc->imported.umm.dma_buf->size);
+		WARN_ONCE(j < pages,
+		"sg list from dma_buf_map_attachment > dma_buf->size=%zu\n",
+		reg->alloc->imported.umm.dma_buf->size);
 	}
 
+	if (WARN_ONCE(count < reg->nr_pages,
+				  "sg list from dma_buf_map_attachment < dma_buf->size=%zu\n",
+				  reg->alloc->imported.umm.dma_buf->size)) {
+		err = MALI_ERROR_FUNCTION_FAILED;
+		goto out;
+	}
+
+	/* Update nents as we now have pages to map */
+	reg->alloc->nents = count;
+
 	err = kbase_mmu_insert_pages(kctx, reg->start_pfn, kbase_get_phy_pages(reg), kbase_reg_current_backed_size(reg), reg->flags | KBASE_REG_GPU_WR | KBASE_REG_GPU_RD);
 
+out:
 	if (MALI_ERROR_NONE != err) {
 		dma_buf_unmap_attachment(reg->alloc->imported.umm.dma_attachment, reg->alloc->imported.umm.sgt, DMA_BIDIRECTIONAL);
 		reg->alloc->imported.umm.sgt = NULL;
@@ -220,6 +258,7 @@ static void kbase_jd_umm_unmap(kbase_context *kctx, struct kbase_va_region *reg,
 		kbase_mmu_teardown_pages(kctx, reg->start_pfn, kbase_reg_current_backed_size(reg));
 	dma_buf_unmap_attachment(reg->alloc->imported.umm.dma_attachment, reg->alloc->imported.umm.sgt, DMA_BIDIRECTIONAL);
 	reg->alloc->imported.umm.sgt = NULL;
+	reg->alloc->nents = 0;
 }
 #endif				/* CONFIG_DMA_SHARED_BUFFER */
 
@@ -521,7 +560,6 @@ STATIC INLINE void jd_resolve_dep(struct list_head *out_list, kbase_jd_atom *kat
 		list_del(katom->dep_head[d].next);
 
 		dep_atom->dep_atom[d] = NULL;
-
 		if (katom->event_code != BASE_JD_EVENT_DONE) {
 			/* Atom failed, so remove the other dependencies and immediately fail the atom */
 			if (dep_atom->dep_atom[other_d]) {
@@ -541,18 +579,76 @@ STATIC INLINE void jd_resolve_dep(struct list_head *out_list, kbase_jd_atom *kat
 			KBASE_DEBUG_ASSERT(dep_atom->status != KBASE_JD_ATOM_STATE_UNUSED);
 			dep_atom->status = KBASE_JD_ATOM_STATE_COMPLETED;
 
-			list_add(&dep_atom->dep_item[0], out_list);
+			list_add_tail(&dep_atom->dep_item[0], out_list);
 		} else if (!dep_atom->dep_atom[other_d]) {
 #ifdef CONFIG_KDS
 			if (dep_atom->kds_dep_satisfied)
 #endif
-				list_add(&dep_atom->dep_item[0], out_list);
+				list_add_tail(&dep_atom->dep_item[0], out_list);
 		}
 	}
 }
 
 KBASE_EXPORT_TEST_API(jd_resolve_dep)
 
+#if MALI_CUSTOMER_RELEASE == 0
+static void jd_force_failure(kbase_device *kbdev, kbase_jd_atom *katom)
+{
+	kbdev->force_replay_count++;
+
+	if (kbdev->force_replay_count >= kbdev->force_replay_limit) {
+		kbdev->force_replay_count = 0;
+		katom->event_code = BASE_JD_EVENT_DATA_INVALID_FAULT;
+
+		if (kbdev->force_replay_random)
+			kbdev->force_replay_limit =
+			   (prandom_u32() % KBASEP_FORCE_REPLAY_RANDOM_LIMIT) + 1;
+
+		dev_info(kbdev->dev, "force_replay : promoting to error\n");
+	}
+}
+
+/** Test to see if atom should be forced to fail.
+ *
+ * This function will check if an atom has a replay job as a dependent. If so
+ * then it will be considered for forced failure. */
+static void jd_check_force_failure(kbase_jd_atom *katom)
+{
+	struct kbase_context *kctx = katom->kctx;
+	kbase_device *kbdev = kctx->kbdev;
+	int i;
+	if ((kbdev->force_replay_limit == KBASEP_FORCE_REPLAY_DISABLED) ||
+	    (katom->core_req & BASEP_JD_REQ_EVENT_NEVER))
+		return;
+	for (i = 1; i < BASE_JD_ATOM_COUNT; i++) {
+		if (kctx->jctx.atoms[i].dep_atom[0] == katom ||
+		    kctx->jctx.atoms[i].dep_atom[1] == katom) {
+			kbase_jd_atom *dep_atom = &kctx->jctx.atoms[i];
+
+			if ((dep_atom->core_req & BASEP_JD_REQ_ATOM_TYPE) ==
+						     BASE_JD_REQ_SOFT_REPLAY &&
+			    (dep_atom->core_req & kbdev->force_replay_core_req)
+					     == kbdev->force_replay_core_req) {
+				jd_force_failure(kbdev, katom);
+				return;
+			}
+		}
+	}
+}
+#endif
+
+static mali_bool jd_replay(kbase_jd_atom *katom)
+{
+	int status = kbase_replay_process(katom);
+
+	if ((status & MALI_REPLAY_STATUS_MASK) ==
+						MALI_REPLAY_STATUS_REPLAYING) {
+		if (status & MALI_REPLAY_FLAG_JS_RESCHED)
+			return MALI_TRUE;
+	}
+	return MALI_FALSE;
+}
+
 /*
  * Perform the necessary handling of an atom that has finished running
  * on the GPU.
@@ -576,6 +672,11 @@ mali_bool jd_done_nolock(kbase_jd_atom *katom)
 
 	KBASE_DEBUG_ASSERT(katom->status != KBASE_JD_ATOM_STATE_UNUSED);
 
+#if MALI_CUSTOMER_RELEASE == 0
+	jd_check_force_failure(katom);
+#endif
+
+
 	/* This is needed in case an atom is failed due to being invalid, this
 	 * can happen *before* the jobs that the atom depends on have completed */
 	for (i = 0; i < 2; i++) {
@@ -613,6 +714,9 @@ mali_bool jd_done_nolock(kbase_jd_atom *katom)
 		for (i = 0; i < 2; i++)
 			jd_resolve_dep(&runnable_jobs, katom, i);
 
+		if (katom->core_req & BASE_JD_REQ_EXTERNAL_RESOURCES)
+			kbase_jd_post_external_resources(katom);
+
 		while (!list_empty(&runnable_jobs)) {
 			kbase_jd_atom *node = list_entry(runnable_jobs.prev, kbase_jd_atom, dep_item[0]);
 			list_del(runnable_jobs.prev);
@@ -625,11 +729,12 @@ mali_bool jd_done_nolock(kbase_jd_atom *katom)
 				node->event_code = katom->event_code;
 				node->status = KBASE_JD_ATOM_STATE_COMPLETED;
 
-				if (node->core_req & BASE_JD_REQ_SOFT_JOB) {
-					/* If this is a fence wait then remove it from the list of sync waiters. */
-					if ( BASE_JD_REQ_SOFT_FENCE_WAIT == node->core_req )
-						list_del(&node->dep_item[0]);
-
+				if ((node->core_req & BASEP_JD_REQ_ATOM_TYPE)
+						  == BASE_JD_REQ_SOFT_REPLAY) {
+					need_to_try_schedule_context |=
+							       jd_replay(node);
+				} else if (node->core_req &
+							BASE_JD_REQ_SOFT_JOB) {
 					kbase_finish_soft_job(node);
 				}
 			}
@@ -638,9 +743,6 @@ mali_bool jd_done_nolock(kbase_jd_atom *katom)
 				list_add_tail(&node->dep_item[0], &completed_jobs);
 		}
 
-		if (katom->core_req & BASE_JD_REQ_EXTERNAL_RESOURCES)
-			kbase_jd_post_external_resources(katom);
-
 		kbase_event_post(kctx, katom);
 
 		/* Decrement and check the TOTAL number of jobs. This includes
@@ -711,35 +813,16 @@ static const char *kbasep_map_core_reqs_to_string(base_jd_core_req core_req)
 }
 #endif
 
-static mali_bool jd_submit_atom(kbase_context *kctx, const base_jd_atom_v2 *user_atom)
+mali_bool jd_submit_atom(kbase_context *kctx,
+			 const base_jd_atom_v2 *user_atom,
+			 kbase_jd_atom *katom)
 {
 	kbase_jd_context *jctx = &kctx->jctx;
-	kbase_jd_atom *katom;
 	base_jd_core_req core_req;
-	base_atom_id atom_number = user_atom->atom_number;
 	int queued = 0;
 	int i;
 	mali_bool ret;
 
-	katom = &jctx->atoms[atom_number];
-
-	mutex_lock(&jctx->lock);
-	while (katom->status != KBASE_JD_ATOM_STATE_UNUSED) {
-		/* Atom number is already in use, wait for the atom to complete */
-		mutex_unlock(&jctx->lock);
-		
-		/* This thread will wait for the atom to complete. Due to thread scheduling we are not sure that
-		 * the other thread that owns the atom will also schedule the context, so we force the scheduler
-		 * to be active and hence eventually schedule this context at some point later. 
-		 */
-		kbasep_js_try_schedule_head_ctx(kctx->kbdev);
-		if (wait_event_killable(katom->completed, katom->status == KBASE_JD_ATOM_STATE_UNUSED)) {
-			/* We're being killed so the result code doesn't really matter */
-			return MALI_FALSE;
-		}
-		mutex_lock(&jctx->lock);
-	}
-
 	/* Update the TOTAL number of jobs. This includes those not tracked by
 	 * the scheduler: 'not ready to run' and 'dependency-only' jobs. */
 	jctx->job_nr++;
@@ -757,7 +840,7 @@ static mali_bool jd_submit_atom(kbase_context *kctx, const base_jd_atom_v2 *user
 	katom->core_req = core_req;
 	katom->nice_prio = user_atom->prio;
 	katom->atom_flags = 0;
-
+	katom->retry_count = 0;
 #ifdef CONFIG_KDS
 	/* Start by assuming that the KDS dependencies are satisfied,
 	 * kbase_jd_pre_external_resources will correct this if there are dependencies */
@@ -782,6 +865,20 @@ static mali_bool jd_submit_atom(kbase_context *kctx, const base_jd_atom_v2 *user
 					/* Atom has completed, propagate the error code if any */
 					katom->event_code = dep_atom->event_code;
 					katom->status = KBASE_JD_ATOM_STATE_QUEUED;
+					if ((katom->core_req & 
+							BASEP_JD_REQ_ATOM_TYPE)
+						  == BASE_JD_REQ_SOFT_REPLAY) {
+						int status =
+						   kbase_replay_process(katom);
+
+						if ((status &
+						       MALI_REPLAY_STATUS_MASK)
+					     == MALI_REPLAY_STATUS_REPLAYING) {
+							ret = (status &
+						  MALI_REPLAY_FLAG_JS_RESCHED);
+							goto out;
+						}
+					}					
 					ret = jd_done_nolock(katom);
 					goto out;
 				}
@@ -802,7 +899,7 @@ static mali_bool jd_submit_atom(kbase_context *kctx, const base_jd_atom_v2 *user
 	/* Reject atoms with job chain = NULL, as these cause issues with soft-stop */
 	if (0 == katom->jc && (katom->core_req & BASEP_JD_REQ_ATOM_TYPE) != BASE_JD_REQ_DEP)
 	{
-		KBASE_DEBUG_PRINT_WARN(KBASE_JD, "Rejecting atom with jc = NULL");
+		dev_warn(kctx->kbdev->dev, "Rejecting atom with jc = NULL");
 		katom->event_code = BASE_JD_EVENT_JOB_INVALID;
 		ret = jd_done_nolock(katom);
 		goto out;
@@ -880,7 +977,18 @@ static mali_bool jd_submit_atom(kbase_context *kctx, const base_jd_atom_v2 *user
 	}
 #endif				/* CONFIG_KDS */
 
-	if (katom->core_req & BASE_JD_REQ_SOFT_JOB) {
+	if ((katom->core_req & BASEP_JD_REQ_ATOM_TYPE)
+						  == BASE_JD_REQ_SOFT_REPLAY) {
+		int status = kbase_replay_process(katom);
+
+		if ((status & MALI_REPLAY_STATUS_MASK)
+					       == MALI_REPLAY_STATUS_REPLAYING)
+			ret = status & MALI_REPLAY_FLAG_JS_RESCHED;
+		else
+			ret = jd_done_nolock(katom);
+
+		goto out;
+	} else if (katom->core_req & BASE_JD_REQ_SOFT_JOB) {
 		if (kbase_process_soft_job(katom) == 0) {
 			kbase_finish_soft_job(katom);
 			ret = jd_done_nolock(katom);
@@ -898,12 +1006,12 @@ static mali_bool jd_submit_atom(kbase_context *kctx, const base_jd_atom_v2 *user
 	}
 
  out:
-	mutex_unlock(&jctx->lock);
 	return ret;
 }
 
 mali_error kbase_jd_submit(kbase_context *kctx, const kbase_uk_job_submit *submit_data)
 {
+	kbase_jd_context *jctx = &kctx->jctx;
 	mali_error err = MALI_ERROR_NONE;
 	int i;
 	mali_bool need_to_try_schedule_context = MALI_FALSE;
@@ -916,15 +1024,15 @@ mali_error kbase_jd_submit(kbase_context *kctx, const kbase_uk_job_submit *submi
 	 */
 	kbdev = kctx->kbdev;
 
-	beenthere("%s", "Enter");
+	beenthere(kctx,"%s", "Enter");
 
 	if ((kctx->jctx.sched_info.ctx.flags & KBASE_CTX_FLAG_SUBMIT_DISABLED) != 0) {
-		KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Attempt to submit to a context that has SUBMIT_DISABLED set on it");
+		dev_err(kbdev->dev, "Attempt to submit to a context that has SUBMIT_DISABLED set on it");
 		return MALI_ERROR_FUNCTION_FAILED;
 	}
 
 	if (submit_data->stride != sizeof(base_jd_atom_v2)) {
-		KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Stride passed to job_submit doesn't match kernel");
+		dev_err(kbdev->dev, "Stride passed to job_submit doesn't match kernel");
 		return MALI_ERROR_FUNCTION_FAILED;
 	}
 
@@ -934,6 +1042,7 @@ mali_error kbase_jd_submit(kbase_context *kctx, const kbase_uk_job_submit *submi
 
 	for (i = 0; i < submit_data->nr_atoms; i++) {
 		base_jd_atom_v2 user_atom;
+		kbase_jd_atom *katom;
 
 		if (copy_from_user(&user_atom, user_addr, sizeof(user_atom)) != 0) {
 			err = MALI_ERROR_FUNCTION_FAILED;
@@ -943,7 +1052,36 @@ mali_error kbase_jd_submit(kbase_context *kctx, const kbase_uk_job_submit *submi
 
 		user_addr = (void *)((uintptr_t) user_addr + submit_data->stride);
 
-		need_to_try_schedule_context |= jd_submit_atom(kctx, &user_atom);
+		mutex_lock(&jctx->lock);
+		katom = &jctx->atoms[user_atom.atom_number];
+
+		while (katom->status != KBASE_JD_ATOM_STATE_UNUSED) {
+			/* Atom number is already in use, wait for the atom to
+			 * complete
+			 */
+			mutex_unlock(&jctx->lock);
+		
+			/* This thread will wait for the atom to complete. Due
+			 * to thread scheduling we are not sure that the other
+			 * thread that owns the atom will also schedule the
+			 * context, so we force the scheduler to be active and
+			 * hence eventually schedule this context at some point
+			 * later.
+			 */
+			kbasep_js_try_schedule_head_ctx(kctx->kbdev);
+			if (wait_event_killable(katom->completed,
+				katom->status == KBASE_JD_ATOM_STATE_UNUSED)) {
+				/* We're being killed so the result code
+				 * doesn't really matter
+				 */
+				return MALI_ERROR_NONE;
+			}
+			mutex_lock(&jctx->lock);
+		}
+
+		need_to_try_schedule_context |=
+				       jd_submit_atom(kctx, &user_atom, katom);
+		mutex_unlock(&jctx->lock);
 	}
 
 	if (need_to_try_schedule_context)
@@ -1029,7 +1167,7 @@ static void jd_done_worker(struct work_struct *data)
 		if (kbdev->gpu_props.num_core_groups > 1 && 
 		    !(katom->affinity & kbdev->gpu_props.props.coherency_info.group[0].core_mask) &&
 		    (katom->affinity & kbdev->gpu_props.props.coherency_info.group[1].core_mask)) {
-			KBASE_DEBUG_PRINT_INFO(KBASE_JD, "JD: Flushing cache due to PRLAM-10676\n");
+			KBASE_LOG(2, kbdev->dev, "JD: Flushing cache due to PRLAM-10676\n");
 			kbasep_jd_cacheclean(kbdev);
 		}
 	}
@@ -1039,15 +1177,15 @@ static void jd_done_worker(struct work_struct *data)
 	    katom->event_code == BASE_JD_EVENT_TILE_RANGE_FAULT       &&
 	    (katom->atom_flags & KBASE_KATOM_FLAG_BEEN_SOFT_STOPPPED) &&
 	    !(katom->atom_flags & KBASE_KATOM_FLAGS_RERUN)){
-		KBASE_DEBUG_PRINT_INFO(KBASE_JD,
-				       " Soft-stopped fragment shader job got a TILE_RANGE_FAULT." \
-				       "Possible HW issue, trying SW workaround \n " );
+		KBASE_LOG(2, kbdev->dev,
+				       "Soft-stopped fragment shader job got a TILE_RANGE_FAULT." \
+				       "Possible HW issue, trying SW workaround\n" );
 		if (kbasep_10969_workaround_clamp_coordinates(katom)){
 			/* The job had a TILE_RANGE_FAULT after was soft-stopped.
 			 * Due to an HW issue we try to execute the job
 			 * again.
 			 */
-			KBASE_DEBUG_PRINT_INFO(KBASE_JD, " Clamping has been executed, try to rerun the job \n" );
+			KBASE_LOG(2, kbdev->dev, "Clamping has been executed, try to rerun the job\n" );
 			katom->event_code = BASE_JD_EVENT_STOPPED;
 			katom->atom_flags |= KBASE_KATOM_FLAGS_RERUN;
 
@@ -1083,7 +1221,7 @@ static void jd_done_worker(struct work_struct *data)
 	if (!kbasep_js_has_atom_finished(&katom_retained_state)) {
 		unsigned long flags;
 		/* Requeue the atom on soft-stop / removed from NEXT registers */
-		KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: Soft Stopped/Removed from next on Ctx %p; Requeuing", kctx);
+		KBASE_LOG(2, kbdev->dev, "JS: Soft Stopped/Removed from next on Ctx %p; Requeuing", kctx);
 
 		mutex_lock(&js_devdata->runpool_mutex);
 		kbasep_js_clear_job_retry_submit(katom);
@@ -1287,7 +1425,7 @@ static enum hrtimer_restart zap_timeout_callback(struct hrtimer *timer)
 		goto out;
 
 	if (kbase_prepare_to_reset_gpu(kbdev)) {
-		KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Issueing GPU soft-reset because jobs failed to be killed (within %d ms) as part of context termination (e.g. process exit)\n", ZAP_TIMEOUT);
+		dev_err(kbdev->dev, "Issueing GPU soft-reset because jobs failed to be killed (within %d ms) as part of context termination (e.g. process exit)\n", ZAP_TIMEOUT);
 		kbase_reset_gpu(kbdev);
 	}
 
@@ -1302,9 +1440,7 @@ static enum hrtimer_restart zap_timeout_callback(struct hrtimer *timer)
 void kbase_jd_zap_context(kbase_context *kctx)
 {
 	kbase_jd_atom *katom;
-#ifdef CONFIG_KDS
 	struct list_head *entry;
-#endif
 	kbase_device *kbdev;
 	zap_reset_data reset_data;
 	unsigned long flags;
@@ -1322,13 +1458,12 @@ void kbase_jd_zap_context(kbase_context *kctx)
 	 * While holding the kbase_jd_context lock clean up jobs which are known to kbase but are
 	 * queued outside the job scheduler.
 	 */
-	while (!list_empty(&kctx->waiting_soft_jobs)) {
-		katom = list_first_entry(&kctx->waiting_soft_jobs,
-					kbase_jd_atom,
-					dep_item[0]);
-		list_del(&katom->dep_item[0]);
+
+	list_for_each( entry, &kctx->waiting_soft_jobs) {
+		katom = list_entry(entry, kbase_jd_atom, dep_item[0]);
 		kbase_cancel_soft_job(katom);
 	}
+	/* kctx->waiting_soft_jobs is not valid after this point */
 
 #ifdef CONFIG_KDS
 
@@ -1383,7 +1518,7 @@ void kbase_jd_zap_context(kbase_context *kctx)
 	}
 	destroy_hrtimer_on_stack(&reset_data.timer);
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Zap: Finished Context %p", kctx);
+	KBASE_LOG(1, kbdev->dev, "Zap: Finished Context %p", kctx);
 
 	/* Ensure that the signallers of the waitqs have finished */
 	mutex_lock(&kctx->jctx.lock);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_jm.c b/drivers/gpu/arm/midgard/mali_kbase_jm.c
old mode 100644
new mode 100755
similarity index 92%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_jm.c
rename to drivers/gpu/arm/midgard/mali_kbase_jm.c
index 13e6097876ee..c85f63ed05af
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_jm.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_jm.c
@@ -22,15 +22,15 @@
  * Base kernel job manager APIs
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_midg_regmap.h>
-#include <kbase/src/common/mali_kbase_gator.h>
-#include <kbase/src/common/mali_kbase_js_affinity.h>
-#include <kbase/src/common/mali_kbase_hw.h>
+#include <mali_kbase.h>
+#include <mali_midg_regmap.h>
+#include <mali_kbase_gator.h>
+#include <mali_kbase_js_affinity.h>
+#include <mali_kbase_hw.h>
 
 #include "mali_kbase_jm.h"
 
-#define beenthere(f, a...)  KBASE_DEBUG_PRINT_INFO(KBASE_JM, "%s:" f, __func__, ##a)
+#define beenthere(kctx, f, a...)  KBASE_LOG(1, kctx->kbdev->dev, "%s:" f, __func__, ##a)
 
 #ifdef CONFIG_MALI_DEBUG_SHADER_SPLIT_FS
 u64 mali_js0_affinity_mask = 0xFFFFFFFFFFFFFFFFULL;
@@ -122,7 +122,7 @@ static void kbase_job_hw_submit(kbase_device *kbdev, kbase_jd_atom *katom, int j
 	katom->start_timestamp = ktime_get();
 
 	/* GO ! */
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: Submitting atom %p from ctx %p to js[%d] with head=0x%llx, affinity=0x%llx", katom, kctx, js, jc_head, katom->affinity);
+	KBASE_LOG(2, kbdev->dev, "JS: Submitting atom %p from ctx %p to js[%d] with head=0x%llx, affinity=0x%llx", katom, kctx, js, jc_head, katom->affinity);
 
 	KBASE_TRACE_ADD_SLOT_INFO(kbdev, JM_SUBMIT, kctx, katom, jc_head, js, (u32) katom->affinity);
 
@@ -173,7 +173,7 @@ void kbase_job_done_slot(kbase_device *kbdev, int s, u32 completion_code, u64 jo
 	KBASE_DEBUG_ASSERT(kbdev);
 
 	if (completion_code != BASE_JD_EVENT_DONE && completion_code != BASE_JD_EVENT_STOPPED)
-		KBASE_DEBUG_PRINT_ERROR(KBASE_JM, "t6xx: GPU fault 0x%02lx from job slot %d\n", (unsigned long)completion_code, s);
+		dev_err(kbdev->dev, "t6xx: GPU fault 0x%02lx from job slot %d\n", (unsigned long)completion_code, s);
 
 	/* IMPORTANT: this function must only contain work necessary to complete a
 	 * job from a Real IRQ (and not 'fake' completion, e.g. from
@@ -336,7 +336,7 @@ void kbase_job_done(kbase_device *kbdev, u32 done)
 					completion_code = BASE_JD_EVENT_TERMINATED;
 					/* fall throught */
 				default:
-					KBASE_DEBUG_PRINT_WARN(KBASE_JD, "error detected from slot %d, job status 0x%08x (%s)", i, completion_code, kbase_exception_name(completion_code));
+					dev_warn(kbdev->dev, "error detected from slot %d, job status 0x%08x (%s)", i, completion_code, kbase_exception_name(completion_code));
 				}
 			}
 
@@ -375,14 +375,14 @@ void kbase_job_done(kbase_device *kbdev, u32 done)
 				}
 			}
 
-			KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Job ended with status 0x%08X\n", completion_code);
+			KBASE_LOG(2, kbdev->dev, "Job ended with status 0x%08X\n", completion_code);
 
 			nr_done = kbasep_jm_nr_jobs_submitted(slot);
 			nr_done -= (active >> i) & 1;
 			nr_done -= (active >> (i + 16)) & 1;
 
 			if (nr_done <= 0) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_JM, "Spurious interrupt on slot %d", i);
+				dev_warn(kbdev->dev, "Spurious interrupt on slot %d", i);
 				goto spurious;
 			}
 
@@ -471,7 +471,7 @@ static void kbasep_job_slot_soft_or_hard_stop_do_action(kbase_device *kbdev, int
 		mali_bool soft_stop_allowed = kbasep_soft_stop_allowed(kbdev, core_reqs);
 		if (!soft_stop_allowed) {
 #ifdef CONFIG_MALI_DEBUG
-			KBASE_DEBUG_PRINT(KBASE_JM, "Attempt made to soft-stop a job that cannot be soft-stopped. core_reqs = 0x%X", (unsigned int)core_reqs);
+			KBASE_LOG(2, kbdev->dev, "Attempt made to soft-stop a job that cannot be soft-stopped. core_reqs = 0x%X", (unsigned int)core_reqs);
 #endif				/* CONFIG_MALI_DEBUG */
 			return;
 		}
@@ -496,7 +496,7 @@ static void kbasep_job_slot_soft_or_hard_stop_do_action(kbase_device *kbdev, int
 			 * All three cases result in the GPU being reset if the hard-stop fails,
 			 * so it is safe to just return and ignore the hard-stop request.
 			 */
-			KBASE_DEBUG_PRINT_WARN(KBASE_JM, "Attempt made to hard-stop a job that cannot be hard-stopped. core_reqs = 0x%X", (unsigned int)core_reqs);
+			dev_warn(kbdev->dev, "Attempt made to hard-stop a job that cannot be hard-stopped. core_reqs = 0x%X", (unsigned int)core_reqs);
 			return;
 		}
 	}
@@ -692,7 +692,7 @@ static void kbasep_job_slot_soft_or_hard_stop(kbase_device *kbdev, kbase_context
 				kbasep_job_slot_soft_or_hard_stop_do_action(kbdev, js, action, core_reqs, katom);
 			else {
 				/* The job is in the next registers */
-				beenthere("clearing job from next registers on slot %d", js);
+				beenthere(kctx, "clearing job from next registers on slot %d", js);
 				kbase_reg_write(kbdev, JOB_SLOT_REG(js, JSn_COMMAND_NEXT), JSn_COMMAND_NOP, NULL);
 				/* Check to see if we did remove a job from the next registers */
 				if (kbase_reg_read(kbdev, JOB_SLOT_REG(js, JSn_HEAD_NEXT_LO), NULL) != 0 || kbase_reg_read(kbdev, JOB_SLOT_REG(js, JSn_HEAD_NEXT_HI), NULL) != 0) {
@@ -717,7 +717,7 @@ static void kbasep_job_slot_soft_or_hard_stop(kbase_device *kbdev, kbase_context
 				} else {
 					/* The job transitioned into the current registers before we managed to evict it,
 					 * in this case we fall back to soft/hard-stopping the job */
-					beenthere("missed job in next register, soft/hard-stopping slot %d", js);
+					beenthere(kctx, "missed job in next register, soft/hard-stopping slot %d", js);
 					kbasep_job_slot_soft_or_hard_stop_do_action(kbdev, js, action, core_reqs, katom);
 				}
 			}
@@ -754,7 +754,7 @@ static void kbasep_job_slot_soft_or_hard_stop(kbase_device *kbdev, kbase_context
 					continue;
 
 				if (!can_safely_stop) {
-					beenthere("clearing job from next registers on slot %d", js);
+					beenthere(kctx, "clearing job from next registers on slot %d", js);
 					kbase_reg_write(kbdev, JOB_SLOT_REG(js, JSn_COMMAND_NEXT), JSn_COMMAND_NOP, NULL);
 
 					/* Check to see if we did remove a job from the next registers */
@@ -780,7 +780,7 @@ static void kbasep_job_slot_soft_or_hard_stop(kbase_device *kbdev, kbase_context
 				}
 
 				/* Next is now free, so we can soft/hard-stop the slot */
-				beenthere("soft/hard-stopped slot %d (there was a job in next which was successfully cleared)\n", js);
+				beenthere(kctx, "soft/hard-stopped slot %d (there was a job in next which was successfully cleared)\n", js);
 				kbasep_job_slot_soft_or_hard_stop_do_action(kbdev, js, action, core_reqs, katom);
 			}
 			/* If there was no job in the next registers, then the job we were
@@ -806,6 +806,11 @@ void kbase_job_kill_jobs_from_context(kbase_context *kctx)
 
 	/* Cancel any remaining running jobs for this kctx  */
 	spin_lock_irqsave(&js_devdata->runpool_irq.lock, flags);
+
+	/* Invalidate all jobs in context, to prevent re-submitting */
+	for (i = 0; i < BASE_JD_ATOM_COUNT; i++)
+		kctx->jctx.atoms[i].event_code = BASE_JD_EVENT_JOB_CANCELLED;
+
 	for (i = 0; i < kbdev->gpu_props.num_job_slots; i++)
 		kbase_job_slot_hardstop(kctx, i, NULL);
 
@@ -839,7 +844,7 @@ void kbase_job_zap_context(kbase_context *kctx)
 	mutex_lock(&js_kctx_info->ctx.jsctx_mutex);
 	js_kctx_info->ctx.is_dying = MALI_TRUE;
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Zap: Try Evict Ctx %p", kctx);
+	KBASE_LOG(1, kbdev->dev, "Zap: Try Evict Ctx %p", kctx);
 	mutex_lock(&js_devdata->queue_mutex);
 	evict_success = kbasep_js_policy_try_evict_ctx(&js_devdata->policy, kctx);
 	mutex_unlock(&js_devdata->queue_mutex);
@@ -892,7 +897,7 @@ void kbase_job_zap_context(kbase_context *kctx)
 
 		KBASE_TRACE_ADD(kbdev, JM_ZAP_NON_SCHEDULED, kctx, NULL, 0u, js_kctx_info->ctx.is_scheduled);
 
-		KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Zap: Ctx %p evict_success=%d, scheduled=%d", kctx, evict_success, js_kctx_info->ctx.is_scheduled);
+		KBASE_LOG(2, kbdev->dev, "Zap: Ctx %p evict_success=%d, scheduled=%d", kctx, evict_success, js_kctx_info->ctx.is_scheduled);
 
 		if (evict_success != MALI_FALSE) {
 			/* Only cancel jobs when we evicted from the policy queue. No Power
@@ -907,7 +912,7 @@ void kbase_job_zap_context(kbase_context *kctx)
 		mali_bool was_retained;
 		/* Case c: didn't evict, but it is scheduled - it's in the Run Pool */
 		KBASE_TRACE_ADD(kbdev, JM_ZAP_SCHEDULED, kctx, NULL, 0u, js_kctx_info->ctx.is_scheduled);
-		KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Zap: Ctx %p is in RunPool", kctx);
+		KBASE_LOG(2, kbdev->dev, "Zap: Ctx %p is in RunPool", kctx);
 
 		/* Disable the ctx from submitting any more jobs */
 		spin_lock_irqsave(&js_devdata->runpool_irq.lock, flags);
@@ -920,7 +925,7 @@ void kbase_job_zap_context(kbase_context *kctx)
 		/* Since it's scheduled and we have the jsctx_mutex, it must be retained successfully */
 		KBASE_DEBUG_ASSERT(was_retained != MALI_FALSE);
 
-		KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Zap: Ctx %p Kill Any Running jobs", kctx);
+		KBASE_LOG(2, kbdev->dev, "Zap: Ctx %p Kill Any Running jobs", kctx);
 		/* Cancel any remaining running jobs for this kctx - if any. Submit is disallowed
 		 * which takes effect immediately, so no more new jobs will appear after we do this.  */
 		for (i = 0; i < kbdev->gpu_props.num_job_slots; i++)
@@ -929,7 +934,7 @@ void kbase_job_zap_context(kbase_context *kctx)
 		spin_unlock_irqrestore(&js_devdata->runpool_irq.lock, flags);
 		mutex_unlock(&js_kctx_info->ctx.jsctx_mutex);
 
-		KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Zap: Ctx %p Release (may or may not schedule out immediately)", kctx);
+		KBASE_LOG(2, kbdev->dev, "Zap: Ctx %p Release (may or may not schedule out immediately)", kctx);
 		kbasep_js_runpool_release_ctx(kbdev, kctx);
 	}
 	KBASE_TRACE_ADD(kbdev, JM_ZAP_DONE, kctx, NULL, 0u, 0u);
@@ -988,55 +993,67 @@ void kbase_job_slot_softstop(kbase_device *kbdev, int js, kbase_jd_atom *target_
  *
  * The job slot lock must be held when calling this function.
  *
- * @param kctx          The kbase context that contains the job(s) that should be hard-stopped
- * @param js            The job slot to hard-stop
- * @param target_katom  The job that should be hard-stopped (or NULL for all jobs from the context)
+ * @param kctx		The kbase context that contains the job(s) that should
+ *			be hard-stopped
+ * @param js		The job slot to hard-stop
+ * @param target_katom	The job that should be hard-stopped (or NULL for all
+ *			jobs from the context)
  */
-void kbase_job_slot_hardstop(kbase_context *kctx, int js, kbase_jd_atom *target_katom)
+void kbase_job_slot_hardstop(kbase_context *kctx, int js,
+				kbase_jd_atom *target_katom)
 {
 	kbase_device *kbdev = kctx->kbdev;
-	kbasep_job_slot_soft_or_hard_stop(kbdev, kctx, js, target_katom, JSn_COMMAND_HARD_STOP);
 
-	if (kbase_hw_has_issue(kctx->kbdev, BASE_HW_ISSUE_8401) || kbase_hw_has_issue(kctx->kbdev, BASE_HW_ISSUE_9510)) {
-		/* The workaround for HW issue 8401 has an issue, so instead of hard-stopping
-		 * just reset the GPU. This will ensure that the jobs leave the GPU.
-		 */
+	kbasep_job_slot_soft_or_hard_stop(kbdev, kctx, js, target_katom,
+						JSn_COMMAND_HARD_STOP);
+	if (kbase_hw_has_issue(kctx->kbdev, BASE_HW_ISSUE_8401) ||
+		kbase_hw_has_issue(kctx->kbdev, BASE_HW_ISSUE_9510) ||
+		(kbase_hw_has_issue(kctx->kbdev, BASE_HW_ISSUE_T76X_3542) &&
+		(target_katom == NULL || target_katom->core_req & BASE_JD_REQ_FS_AFBC))) {
+		/* MIDBASE-2916 if a fragment job with AFBC encoding is
+		 * hardstopped, ensure to do a soft reset also in order to
+		 * clear the GPU status.
+		 * Workaround for HW issue 8401 has an issue,so after
+		 * hard-stopping just reset the GPU. This will ensure that the
+		 * jobs leave the GPU.*/
 		if (kbase_prepare_to_reset_gpu_locked(kbdev)) {
-			KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Issueing GPU soft-reset instead of hard stopping job due to a hardware issue");
+			dev_err(kbdev->dev, "Issueing GPU\
+			soft-reset after hard stopping due to hardware issue");
 			kbase_reset_gpu_locked(kbdev);
 		}
 	}
 }
 
+
 void kbase_debug_dump_registers(kbase_device *kbdev)
 {
 	int i;
-	dev_err(kbdev->osdev.dev, "Register state:");
-	dev_err(kbdev->osdev.dev, "  GPU_IRQ_RAWSTAT=0x%08x GPU_STATUS=0x%08x",
+	dev_err(kbdev->dev, "Register state:");
+	dev_err(kbdev->dev, "  GPU_IRQ_RAWSTAT=0x%08x GPU_STATUS=0x%08x",
 		kbase_reg_read(kbdev, GPU_CONTROL_REG(GPU_IRQ_RAWSTAT), NULL),
 		kbase_reg_read(kbdev, GPU_CONTROL_REG(GPU_STATUS), NULL));
-	dev_err(kbdev->osdev.dev, "  JOB_IRQ_RAWSTAT=0x%08x JOB_IRQ_JS_STATE=0x%08x JOB_IRQ_THROTTLE=0x%08x",
+	dev_err(kbdev->dev, "  JOB_IRQ_RAWSTAT=0x%08x JOB_IRQ_JS_STATE=0x%08x JOB_IRQ_THROTTLE=0x%08x",
 		kbase_reg_read(kbdev, JOB_CONTROL_REG(JOB_IRQ_RAWSTAT), NULL),
 		kbase_reg_read(kbdev, JOB_CONTROL_REG(JOB_IRQ_JS_STATE), NULL),
 		kbase_reg_read(kbdev, JOB_CONTROL_REG(JOB_IRQ_THROTTLE), NULL));
 	for (i = 0; i < 3; i++) {
-		dev_err(kbdev->osdev.dev, "  JS%d_STATUS=0x%08x      JS%d_HEAD_LO=0x%08x",
+		dev_err(kbdev->dev, "  JS%d_STATUS=0x%08x      JS%d_HEAD_LO=0x%08x",
 			i, kbase_reg_read(kbdev, JOB_SLOT_REG(i, JSn_STATUS),
 					NULL),
 			i, kbase_reg_read(kbdev, JOB_SLOT_REG(i, JSn_HEAD_LO),
 					NULL));
 	}
-	dev_err(kbdev->osdev.dev, "  MMU_IRQ_RAWSTAT=0x%08x GPU_FAULTSTATUS=0x%08x",
+	dev_err(kbdev->dev, "  MMU_IRQ_RAWSTAT=0x%08x GPU_FAULTSTATUS=0x%08x",
 		kbase_reg_read(kbdev, MMU_REG(MMU_IRQ_RAWSTAT), NULL),
 		kbase_reg_read(kbdev, GPU_CONTROL_REG(GPU_FAULTSTATUS), NULL));
-	dev_err(kbdev->osdev.dev, "  GPU_IRQ_MASK=0x%08x    JOB_IRQ_MASK=0x%08x     MMU_IRQ_MASK=0x%08x",
+	dev_err(kbdev->dev, "  GPU_IRQ_MASK=0x%08x    JOB_IRQ_MASK=0x%08x     MMU_IRQ_MASK=0x%08x",
 		kbase_reg_read(kbdev, GPU_CONTROL_REG(GPU_IRQ_MASK), NULL),
 		kbase_reg_read(kbdev, JOB_CONTROL_REG(JOB_IRQ_MASK), NULL),
 		kbase_reg_read(kbdev, MMU_REG(MMU_IRQ_MASK), NULL));
-	dev_err(kbdev->osdev.dev, "  PWR_OVERRIDE0=0x%08x   PWR_OVERRIDE1=0x%08x",
+	dev_err(kbdev->dev, "  PWR_OVERRIDE0=0x%08x   PWR_OVERRIDE1=0x%08x",
 		kbase_reg_read(kbdev, GPU_CONTROL_REG(PWR_OVERRIDE0), NULL),
 		kbase_reg_read(kbdev, GPU_CONTROL_REG(PWR_OVERRIDE1), NULL));
-	dev_err(kbdev->osdev.dev, "  SHADER_CONFIG=0x%08x   L2_MMU_CONFIG=0x%08x",
+	dev_err(kbdev->dev, "  SHADER_CONFIG=0x%08x   L2_MMU_CONFIG=0x%08x",
 		kbase_reg_read(kbdev, GPU_CONTROL_REG(SHADER_CONFIG), NULL),
 		kbase_reg_read(kbdev, GPU_CONTROL_REG(L2_MMU_CONFIG), NULL));
 }
@@ -1079,7 +1096,7 @@ void kbasep_reset_timeout_worker(struct work_struct *data)
 	/* All slot have been soft-stopped and we've waited SOFT_STOP_RESET_TIMEOUT for the slots to clear, at this point
 	 * we assume that anything that is still left on the GPU is stuck there and we'll kill it when we reset the GPU */
 
-	KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Resetting GPU (allowing up to %d ms)", RESET_TIMEOUT);
+	dev_err(kbdev->dev, "Resetting GPU (allowing up to %d ms)", RESET_TIMEOUT);
 
 	spin_lock_irqsave(&kbdev->hwcnt.lock, flags);
 
@@ -1195,7 +1212,7 @@ void kbasep_reset_timeout_worker(struct work_struct *data)
 
 		nr_done = kbasep_jm_nr_jobs_submitted(slot);
 		while (nr_done) {
-			KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Job stuck in slot %d on the GPU was cancelled", i);
+			dev_err(kbdev->dev, "Job stuck in slot %d on the GPU was cancelled", i);
 			kbase_job_done_slot(kbdev, i, BASE_JD_EVENT_JOB_CANCELLED, 0, &end_timestamp);
 			nr_done--;
 		}
@@ -1216,7 +1233,7 @@ void kbasep_reset_timeout_worker(struct work_struct *data)
 
 	atomic_set(&kbdev->reset_gpu, KBASE_RESET_GPU_NOT_PENDING);
 	wake_up(&kbdev->reset_wait);
-	KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Reset complete");
+	dev_err(kbdev->dev, "Reset complete");
 
 	/* Find out what cores are required now */
 	kbase_pm_update_cores_state(kbdev);
@@ -1356,7 +1373,7 @@ void kbase_reset_gpu(kbase_device *kbdev)
 	atomic_set(&kbdev->reset_gpu, KBASE_RESET_GPU_COMMITTED);
 
 	timeout_ms = kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS);
-	KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Preparing to soft-reset GPU: Waiting (upto %d ms) for all jobs to complete soft-stop\n", timeout_ms);
+	dev_err(kbdev->dev, "Preparing to soft-reset GPU: Waiting (upto %d ms) for all jobs to complete soft-stop\n", timeout_ms);
 	hrtimer_start(&kbdev->reset_timer, HR_TIMER_DELAY_MSEC(timeout_ms), HRTIMER_MODE_REL);
 
 	/* Try resetting early */
@@ -1375,7 +1392,7 @@ void kbase_reset_gpu_locked(kbase_device *kbdev)
 	atomic_set(&kbdev->reset_gpu, KBASE_RESET_GPU_COMMITTED);
 
 	timeout_ms = kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS);
-	KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Preparing to soft-reset GPU: Waiting (upto %d ms) for all jobs to complete soft-stop\n", timeout_ms);
+	dev_err(kbdev->dev, "Preparing to soft-reset GPU: Waiting (upto %d ms) for all jobs to complete soft-stop\n", timeout_ms);
 	hrtimer_start(&kbdev->reset_timer, HR_TIMER_DELAY_MSEC(timeout_ms), HRTIMER_MODE_REL);
 
 	/* Try resetting early */
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_jm.h b/drivers/gpu/arm/midgard/mali_kbase_jm.h
old mode 100644
new mode 100755
similarity index 96%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_jm.h
rename to drivers/gpu/arm/midgard/mali_kbase_jm.h
index bf50e5ea5631..9d004d91a491
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_jm.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_jm.h
@@ -25,7 +25,8 @@
 #ifndef _KBASE_JM_H_
 #define _KBASE_JM_H_
 
-#include <kbase/src/common/mali_kbase_hw.h>
+#include <mali_kbase_hw.h>
+#include <mali_kbase_debug.h>
 #include <linux/atomic.h>
 
 /**
@@ -114,7 +115,7 @@ static INLINE kbase_jd_atom *kbasep_jm_dequeue_submit_slot(kbase_jm_slot *slot)
 	slot->submitted_head = (slot->submitted_head + 1) & BASE_JM_SUBMIT_SLOTS_MASK;
 	slot->submitted_nr--;
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "katom %p new head %u", (void *)katom, (unsigned int)slot->submitted_head);
+	KBASE_LOG(2, katom->kctx->kbdev->dev, "katom %p new head %u", (void *)katom, (unsigned int)slot->submitted_head);
 
 	return katom;
 }
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js.c b/drivers/gpu/arm/midgard/mali_kbase_js.c
old mode 100644
new mode 100755
similarity index 95%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js.c
rename to drivers/gpu/arm/midgard/mali_kbase_js.c
index 65f96c9ead1f..85b82d86c820
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_js.c
@@ -20,14 +20,14 @@
 /*
  * Job Scheduler Implementation
  */
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_js.h>
-#include <kbase/src/common/mali_kbase_js_affinity.h>
-#include <kbase/src/common/mali_kbase_gator.h>
-#include <kbase/src/common/mali_kbase_hw.h>
+#include <mali_kbase.h>
+#include <mali_kbase_js.h>
+#include <mali_kbase_js_affinity.h>
+#include <mali_kbase_gator.h>
+#include <mali_kbase_hw.h>
 
 #include "mali_kbase_jm.h"
-#include <kbase/src/common/mali_kbase_defs.h>
+#include <mali_kbase_defs.h>
 
 /*
  * Private types
@@ -485,7 +485,7 @@ mali_error kbasep_js_devdata_init(kbase_device * const kbdev)
 		mali_bool use_workaround_for_security;
 		use_workaround_for_security = (mali_bool) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE);
 		if (use_workaround_for_security != MALI_FALSE) {
-			KBASE_DEBUG_PRINT(KBASE_JM, "GPU has HW ISSUE 8987, and driver configured for security workaround: 1 address space only");
+			KBASE_LOG(2, kbdev->dev, "GPU has HW ISSUE 8987, and driver configured for security workaround: 1 address space only");
 			kbdev->nr_user_address_spaces = 1;
 		}
 	}
@@ -506,33 +506,39 @@ mali_error kbasep_js_devdata_init(kbase_device * const kbdev)
 	/* Config attributes */
 	js_devdata->scheduling_tick_ns = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS);
 	js_devdata->soft_stop_ticks = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS);
+	js_devdata->soft_stop_ticks_cl = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL);
 	js_devdata->hard_stop_ticks_ss = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS);
+	js_devdata->hard_stop_ticks_cl = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL);
 	js_devdata->hard_stop_ticks_nss = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS);
 	js_devdata->gpu_reset_ticks_ss = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS);
+	js_devdata->gpu_reset_ticks_cl = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL);
 	js_devdata->gpu_reset_ticks_nss = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS);
 	js_devdata->ctx_timeslice_ns = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS);
 	js_devdata->cfs_ctx_runtime_init_slices = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_INIT_SLICES);
 	js_devdata->cfs_ctx_runtime_min_slices = (u32) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_MIN_SLICES);
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS Config Attribs: ");
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "\tjs_devdata->scheduling_tick_ns:%u", js_devdata->scheduling_tick_ns);
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "\tjs_devdata->soft_stop_ticks:%u", js_devdata->soft_stop_ticks);
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "\tjs_devdata->hard_stop_ticks_ss:%u", js_devdata->hard_stop_ticks_ss);
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "\tjs_devdata->hard_stop_ticks_nss:%u", js_devdata->hard_stop_ticks_nss);
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "\tjs_devdata->gpu_reset_ticks_ss:%u", js_devdata->gpu_reset_ticks_ss);
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "\tjs_devdata->gpu_reset_ticks_nss:%u", js_devdata->gpu_reset_ticks_nss);
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "\tjs_devdata->ctx_timeslice_ns:%u", js_devdata->ctx_timeslice_ns);
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "\tjs_devdata->cfs_ctx_runtime_init_slices:%u", js_devdata->cfs_ctx_runtime_init_slices);
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "\tjs_devdata->cfs_ctx_runtime_min_slices:%u", js_devdata->cfs_ctx_runtime_min_slices);
+	KBASE_LOG(2, kbdev->dev, "JS Config Attribs: ");
+	KBASE_LOG(2, kbdev->dev, "\tscheduling_tick_ns:%u", js_devdata->scheduling_tick_ns);
+	KBASE_LOG(2, kbdev->dev, "\tsoft_stop_ticks:%u", js_devdata->soft_stop_ticks);
+	KBASE_LOG(2, kbdev->dev, "\tsoft_stop_ticks_cl:%u", js_devdata->soft_stop_ticks_cl);
+	KBASE_LOG(2, kbdev->dev, "\thard_stop_ticks_ss:%u", js_devdata->hard_stop_ticks_ss);
+	KBASE_LOG(2, kbdev->dev, "\thard_stop_ticks_cl:%u", js_devdata->hard_stop_ticks_cl);
+	KBASE_LOG(2, kbdev->dev, "\thard_stop_ticks_nss:%u", js_devdata->hard_stop_ticks_nss);
+	KBASE_LOG(2, kbdev->dev, "\tgpu_reset_ticks_ss:%u", js_devdata->gpu_reset_ticks_ss);
+	KBASE_LOG(2, kbdev->dev, "\tgpu_reset_ticks_cl:%u", js_devdata->gpu_reset_ticks_cl);
+	KBASE_LOG(2, kbdev->dev, "\tgpu_reset_ticks_nss:%u", js_devdata->gpu_reset_ticks_nss);
+	KBASE_LOG(2, kbdev->dev, "\tctx_timeslice_ns:%u", js_devdata->ctx_timeslice_ns);
+	KBASE_LOG(2, kbdev->dev, "\tcfs_ctx_runtime_init_slices:%u", js_devdata->cfs_ctx_runtime_init_slices);
+	KBASE_LOG(2, kbdev->dev, "\tcfs_ctx_runtime_min_slices:%u", js_devdata->cfs_ctx_runtime_min_slices);
 
 #if KBASE_DISABLE_SCHEDULING_SOFT_STOPS != 0
-	KBASE_DEBUG_PRINT(KBASE_JM, "Job Scheduling Policy Soft-stops disabled, ignoring value for soft_stop_ticks==%u at %uns per tick. Other soft-stops may still occur.", js_devdata->soft_stop_ticks, js_devdata->scheduling_tick_ns);
+	KBASE_LOG(2, kbdev->dev, "Job Scheduling Policy Soft-stops disabled, ignoring value for soft_stop_ticks==%u at %uns per tick. Other soft-stops may still occur.", js_devdata->soft_stop_ticks, js_devdata->scheduling_tick_ns);
 #endif
 #if KBASE_DISABLE_SCHEDULING_HARD_STOPS != 0
-	KBASE_DEBUG_PRINT(KBASE_JM, "Job Scheduling Policy Hard-stops disabled, ignoring values for hard_stop_ticks_ss==%d and hard_stop_ticks_nss==%u at %uns per tick. Other hard-stops may still occur.", js_devdata->hard_stop_ticks_ss, js_devdata->hard_stop_ticks_nss, js_devdata->scheduling_tick_ns);
+	KBASE_LOG(2, kbdev->dev, "Job Scheduling Policy Hard-stops disabled, ignoring values for hard_stop_ticks_ss==%d and hard_stop_ticks_nss==%u at %uns per tick. Other hard-stops may still occur.", js_devdata->hard_stop_ticks_ss, js_devdata->hard_stop_ticks_nss, js_devdata->scheduling_tick_ns);
 #endif
 #if KBASE_DISABLE_SCHEDULING_SOFT_STOPS != 0 && KBASE_DISABLE_SCHEDULING_HARD_STOPS != 0
-	KBASE_DEBUG_PRINT(KBASE_JM, "Note: The JS policy's tick timer (if coded) will still be run, but do nothing.");
+	KBASE_LOG(2, kbdev->dev, "Note: The JS policy's tick timer (if coded) will still be run, but do nothing.");
 #endif
 
 	/* setup the number of irq throttle cycles base on given time */
@@ -908,7 +914,7 @@ mali_bool kbasep_js_add_job(kbase_context *kctx, kbase_jd_atom *atom)
 		} else if (js_kctx_info->ctx.nr_jobs == 1) {
 			/* Handle Refcount going from 0 to 1: schedule the context on the Policy Queue */
 			KBASE_DEBUG_ASSERT(js_kctx_info->ctx.is_scheduled == MALI_FALSE);
-			KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: Enqueue Context %p", kctx);
+			KBASE_LOG(1, kbdev->dev, "JS: Enqueue Context %p", kctx);
 
 			mutex_lock(&js_devdata->queue_mutex);
 			kbasep_js_policy_enqueue_ctx(js_policy, kctx);
@@ -1176,7 +1182,7 @@ STATIC kbasep_js_release_result kbasep_js_runpool_release_ctx_internal(kbase_dev
 	/* Make a set of checks to see if the context should be scheduled out */
 	if (new_ref_count == 0 && (kctx->jctx.sched_info.ctx.nr_jobs == 0 || kbasep_js_is_submit_allowed(js_devdata, kctx) == MALI_FALSE)) {
 		/* Last reference, and we've been told to remove this context from the Run Pool */
-		KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: RunPool Remove Context %p because as_busy_refcount=%d, jobs=%d, allowed=%d", kctx, new_ref_count, js_kctx_info->ctx.nr_jobs, kbasep_js_is_submit_allowed(js_devdata, kctx));
+		KBASE_LOG(2, kbdev->dev, "JS: RunPool Remove Context %p because as_busy_refcount=%d, jobs=%d, allowed=%d", kctx, new_ref_count, js_kctx_info->ctx.nr_jobs, kbasep_js_is_submit_allowed(js_devdata, kctx));
 
 		kbasep_js_policy_runpool_remove_ctx(js_policy, kctx);
 
@@ -1267,20 +1273,20 @@ void kbasep_js_runpool_requeue_or_kill_ctx(kbase_device *kbdev, kbase_context *k
 	if (js_kctx_info->ctx.is_dying != MALI_FALSE) {
 		/* Dying: don't requeue, but kill all jobs on the context. This happens
 		 * asynchronously */
-		KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: ** Killing Context %p on RunPool Remove **", kctx);
+		KBASE_LOG(2, kbdev->dev, "JS: ** Killing Context %p on RunPool Remove **", kctx);
 		kbasep_js_policy_foreach_ctx_job(js_policy, kctx, &kbase_jd_cancel, MALI_TRUE);
 	} else if (js_kctx_info->ctx.nr_jobs > 0) {
 		/* Not dying, has jobs: de-ref core counts from each job before addding
 		 * back to the queue */
 		kbasep_js_policy_foreach_ctx_job(js_policy, kctx, &kbasep_js_job_check_deref_cores, MALI_FALSE);
 
-		KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: Requeue Context %p", kctx);
+		KBASE_LOG(1, kbdev->dev, "JS: Requeue Context %p", kctx);
 		mutex_lock(&js_devdata->queue_mutex);
 		kbasep_js_policy_enqueue_ctx(js_policy, kctx);
 		mutex_unlock(&js_devdata->queue_mutex);
 	} else {
 		/* Not dying, no jobs: don't add back to the queue */
-		KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: Idling Context %p (not requeued)", kctx);
+		KBASE_LOG(1, kbdev->dev, "JS: Idling Context %p (not requeued)", kctx);
 	}
 
 	if (has_pm_ref) {
@@ -1638,7 +1644,7 @@ mali_bool kbasep_js_try_run_next_job_on_slot_irq_nolock(kbase_device *kbdev, int
 				kbasep_js_ref_permon_check_and_enable_cycle_counter(kbdev, dequeued_atom);
 
 				if (dequeued_atom->event_code == BASE_JD_EVENT_PM_EVENT) {
-					KBASE_DEBUG_PRINT_WARN(KBASE_PM, "Rejecting atom due to BASE_JD_EVENT_PM_EVENT\n");
+					dev_warn(kbdev->dev, "Rejecting atom due to BASE_JD_EVENT_PM_EVENT\n");
 					/* The job has failed due to the specified core group being unavailable */
 					kbase_jd_done(dequeued_atom, js, NULL, 0);
 				} else {
@@ -1735,7 +1741,7 @@ void kbasep_js_try_run_next_job_on_slot_nolock(kbase_device *kbdev, int js)
 					kbasep_js_ref_permon_check_and_enable_cycle_counter(kbdev, dequeued_atom);
 
 					if (dequeued_atom->event_code == BASE_JD_EVENT_PM_EVENT) {
-						KBASE_DEBUG_PRINT_WARN(KBASE_PM, "Rejecting atom due to BASE_JD_EVENT_PM_EVENT\n");
+						dev_warn(kbdev->dev, "Rejecting atom due to BASE_JD_EVENT_PM_EVENT\n");
 						/* The job has failed due to the specified core group being unavailable */
 						kbase_jd_done(dequeued_atom, js, NULL, 0);
 					} else {
@@ -1782,7 +1788,7 @@ void kbasep_js_try_schedule_head_ctx(kbase_device *kbdev)
 	}
 	js_kctx_info = &head_kctx->jctx.sched_info;
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: Dequeue Context %p", head_kctx);
+	KBASE_LOG(1, kbdev->dev, "JS: Dequeue Context %p", head_kctx);
 
 	pm_active_err = kbase_pm_context_active_handle_suspend(kbdev, KBASE_PM_SUSPEND_HANDLER_DONT_INCREASE);
 
@@ -1824,15 +1830,24 @@ void kbasep_js_try_schedule_head_ctx(kbase_device *kbdev)
 		if (kbdev->js_soft_stop_ticks != 0)
 			js_devdata->soft_stop_ticks = kbdev->js_soft_stop_ticks;
 
+		if (kbdev->js_soft_stop_ticks_cl != 0)
+			js_devdata->soft_stop_ticks_cl = kbdev->js_soft_stop_ticks_cl;
+
 		if (kbdev->js_hard_stop_ticks_ss != 0)
 			js_devdata->hard_stop_ticks_ss = kbdev->js_hard_stop_ticks_ss;
 
+		if (kbdev->js_hard_stop_ticks_cl != 0)
+			js_devdata->hard_stop_ticks_cl = kbdev->js_hard_stop_ticks_cl;
+
 		if (kbdev->js_hard_stop_ticks_nss != 0)
 			js_devdata->hard_stop_ticks_nss = kbdev->js_hard_stop_ticks_nss;
 
 		if (kbdev->js_reset_ticks_ss != 0)
 			js_devdata->gpu_reset_ticks_ss = kbdev->js_reset_ticks_ss;
 
+		if (kbdev->js_reset_ticks_cl != 0)
+			js_devdata->gpu_reset_ticks_cl = kbdev->js_reset_ticks_cl;
+
 		if (kbdev->js_reset_ticks_nss != 0)
 			js_devdata->gpu_reset_ticks_nss = kbdev->js_reset_ticks_nss;
 	}
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js.h b/drivers/gpu/arm/midgard/mali_kbase_js.h
old mode 100644
new mode 100755
similarity index 99%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js.h
rename to drivers/gpu/arm/midgard/mali_kbase_js.h
index 5ac4a7fcedd8..ec20c9d45c74
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_js.h
@@ -30,6 +30,7 @@
 #include "mali_kbase_js_defs.h"
 #include "mali_kbase_js_policy.h"
 #include "mali_kbase_defs.h"
+#include "mali_kbase_debug.h"
 
 #include "mali_kbase_js_ctx_attr.h"
 
@@ -670,7 +671,7 @@ static INLINE void kbasep_js_set_submit_allowed(kbasep_js_device_data *js_devdat
 
 	set_bit = (u16) (1u << kctx->as_nr);
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: Setting Submit Allowed on %p (as=%d)", kctx, kctx->as_nr);
+	KBASE_LOG(3, kctx->kbdev->dev, "JS: Setting Submit Allowed on %p (as=%d)", kctx, kctx->as_nr);
 
 	js_devdata->runpool_irq.submit_allowed |= set_bit;
 }
@@ -695,7 +696,7 @@ static INLINE void kbasep_js_clear_submit_allowed(kbasep_js_device_data *js_devd
 	clear_bit = (u16) (1u << kctx->as_nr);
 	clear_mask = ~clear_bit;
 
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "JS: Clearing Submit Allowed on %p (as=%d)", kctx, kctx->as_nr);
+	KBASE_LOG(3, kctx->kbdev->dev, "JS: Clearing Submit Allowed on %p (as=%d)", kctx, kctx->as_nr);
 
 	js_devdata->runpool_irq.submit_allowed &= clear_mask;
 }
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_affinity.c b/drivers/gpu/arm/midgard/mali_kbase_js_affinity.c
old mode 100644
new mode 100755
similarity index 85%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_affinity.c
rename to drivers/gpu/arm/midgard/mali_kbase_js_affinity.c
index 654f9a5156de..6ded87dfe85d
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_affinity.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_js_affinity.c
@@ -22,36 +22,9 @@
  * Base kernel affinity manager APIs
  */
 
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 #include "mali_kbase_js_affinity.h"
 
-#if defined(CONFIG_MALI_DEBUG) && 0	/* disabled to avoid compilation warnings */
-
-STATIC void debug_get_binary_string(const u64 n, char *buff, const int size)
-{
-	unsigned int i;
-	for (i = 0; i < size; i++)
-		buff[i] = ((n >> i) & 1) ? '*' : '-';
-
-	buff[size] = '\0';
-}
-
-#define N_CORES 8
-STATIC void debug_print_affinity_info(const kbase_device *kbdev, const kbase_jd_atom *katom, int js, u64 affinity)
-{
-	char buff[N_CORES + 1];
-	char buff2[N_CORES + 1];
-	base_jd_core_req core_req = katom->atom->core_req;
-	u64 shader_present_bitmap = kbdev->shader_present_bitmap;
-
-	debug_get_binary_string(shader_present_bitmap, buff, N_CORES);
-	debug_get_binary_string(affinity, buff2, N_CORES);
-
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Job: COH FS  CS   T  CF   V  JS | GPU:12345678 | AFF:12345678");
-	KBASE_DEBUG_PRINT_INFO(KBASE_JM, "      %s   %s   %s   %s   %s   %s   %u |     %s |     %s", core_req & BASE_JD_REQ_COHERENT_GROUP ? "*" : "-", core_req & BASE_JD_REQ_FS ? "*" : "-", core_req & BASE_JD_REQ_CS ? "*" : "-", core_req & BASE_JD_REQ_T ? "*" : "-", core_req & BASE_JD_REQ_CF ? "*" : "-", core_req & BASE_JD_REQ_V ? "*" : "-", js, buff, buff2);
-}
-
-#endif				/* CONFIG_MALI_DEBUG */
 
 STATIC INLINE mali_bool affinity_job_uses_high_cores(kbase_device *kbdev, kbase_jd_atom *katom)
 {
@@ -141,52 +114,13 @@ mali_bool kbase_js_can_run_job_on_slot_no_lock(kbase_device *kbdev, int js)
 	return MALI_FALSE;
 }
 
-#ifdef AFFINITY_MASK_ENABLE
-static u64 affinity_mask = 0xFFFF;
-static spinlock_t affinity_mask_spinlock;
-static int init_once;
-void kbase_js_set_affinity_mask(u64 mask)
-{
-	unsigned long flags;
-	if (!init_once) {
-		spin_lock_init(&affinity_mask_spinlock);
-		init_once = 1;
-	}
-	if (mask) {
-		spin_lock_irqsave(&affinity_mask_spinlock, flags);
-		affinity_mask = mask;
-		spin_unlock_irqrestore(&affinity_mask_spinlock, flags);
-		pr_info("affinity mask is set to 0x%x.\n", (u32)mask);
-	} else {
-		pr_info("Invalid mask!!!\n");
-	}
-	return;
-}
-
-u64 kbase_js_get_affinity_mask(void)
-{
-	u64 val;
-	unsigned long flags;
-	if (!init_once) {
-		spin_lock_init(&affinity_mask_spinlock);
-		init_once = 1;
-	}
-	spin_lock_irqsave(&affinity_mask_spinlock, flags);
-	val = affinity_mask;
-	spin_unlock_irqrestore(&affinity_mask_spinlock, flags);
-
-	return val;
-}
-#endif
-
-
 /*
  * As long as it has been decided to have a deeper modification of
  * what job scheduler, power manager and affinity manager will
  * implement, this function is just an intermediate step that
  * assumes:
  * - all working cores will be powered on when this is called.
- * - largest current configuration is a T658 (2x4 cores).
+ * - largest current configuration is 2 core groups.
  * - It has been decided not to have hardcoded values so the low
  *   and high cores in a core split will be evently distributed.
  * - Odd combinations of core requirements have been filtered out
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_affinity.h b/drivers/gpu/arm/midgard/mali_kbase_js_affinity.h
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_affinity.h
rename to drivers/gpu/arm/midgard/mali_kbase_js_affinity.h
index 03d0ce08e440..38de8b31a5c3
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_affinity.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_js_affinity.h
@@ -153,10 +153,5 @@ static INLINE void kbase_js_debug_log_current_affinities(kbase_device *kbdev)
 	  /** @} *//* end group base_kbase_api */
 	  /** @} *//* end group base_api */
 
-#define AFFINITY_MASK_ENABLE
-#ifdef AFFINITY_MASK_ENABLE
-void kbase_js_set_affinity_mask(u64 mask);
-u64 kbase_js_get_affinity_mask(void);
-#endif
 
 #endif				/* _KBASE_JS_AFFINITY_H_ */
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_ctx_attr.c b/drivers/gpu/arm/midgard/mali_kbase_js_ctx_attr.c
old mode 100644
new mode 100755
similarity index 99%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_ctx_attr.c
rename to drivers/gpu/arm/midgard/mali_kbase_js_ctx_attr.c
index 2af635cd646b..6e051b18a63c
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_ctx_attr.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_js_ctx_attr.c
@@ -16,7 +16,7 @@
 
 
 
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 
 /*
  * Private functions follow
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_ctx_attr.h b/drivers/gpu/arm/midgard/mali_kbase_js_ctx_attr.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_ctx_attr.h
rename to drivers/gpu/arm/midgard/mali_kbase_js_ctx_attr.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_defs.h b/drivers/gpu/arm/midgard/mali_kbase_js_defs.h
old mode 100644
new mode 100755
similarity index 98%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_defs.h
rename to drivers/gpu/arm/midgard/mali_kbase_js_defs.h
index 2ff42f60501b..695bf466c79e
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_defs.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_js_defs.h
@@ -347,9 +347,12 @@ typedef struct kbasep_js_device_data {
 
 	u32 scheduling_tick_ns;		 /**< Value for KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS */
 	u32 soft_stop_ticks;		 /**< Value for KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS */
+	u32 soft_stop_ticks_cl;		 /**< Value for KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL */
 	u32 hard_stop_ticks_ss;		 /**< Value for KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS */
+	u32 hard_stop_ticks_cl;		 /**< Value for KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL */
 	u32 hard_stop_ticks_nss;	 /**< Value for KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS */
 	u32 gpu_reset_ticks_ss;		 /**< Value for KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS */
+	u32 gpu_reset_ticks_cl;		 /**< Value for KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL */
 	u32 gpu_reset_ticks_nss;	 /**< Value for KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS */
 	u32 ctx_timeslice_ns;		 /**< Value for KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS */
 	u32 cfs_ctx_runtime_init_slices; /**< Value for KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_INIT_SLICES */
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_policy.h b/drivers/gpu/arm/midgard/mali_kbase_js_policy.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_policy.h
rename to drivers/gpu/arm/midgard/mali_kbase_js_policy.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_policy_cfs.c b/drivers/gpu/arm/midgard/mali_kbase_js_policy_cfs.c
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_policy_cfs.c
rename to drivers/gpu/arm/midgard/mali_kbase_js_policy_cfs.c
index 2ac9be9a6e37..78c0fd290b56
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_policy_cfs.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_js_policy_cfs.c
@@ -21,14 +21,14 @@
  * Job Scheduler: Completely Fair Policy Implementation
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_jm.h>
-#include <kbase/src/common/mali_kbase_js.h>
-#include <kbase/src/common/mali_kbase_js_policy_cfs.h>
+#include <mali_kbase.h>
+#include <mali_kbase_jm.h>
+#include <mali_kbase_js.h>
+#include <mali_kbase_js_policy_cfs.h>
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 #include <linux/sched/rt.h>
 #endif
-#include <linux/version.h>
+
 /**
  * Define for when dumping is enabled.
  * This should not be based on the instrumentation level as whether dumping is enabled for a particular level is down to the integrator.
@@ -49,7 +49,7 @@
 
 /** Core requirements that all the variants support */
 #define JS_CORE_REQ_ALL_OTHERS \
-	(BASE_JD_REQ_CF | BASE_JD_REQ_V | BASE_JD_REQ_PERMON | BASE_JD_REQ_EXTERNAL_RESOURCES)
+	(BASE_JD_REQ_CF | BASE_JD_REQ_V | BASE_JD_REQ_PERMON | BASE_JD_REQ_EXTERNAL_RESOURCES | BASEP_JD_REQ_EVENT_NEVER)
 
 /** Context requirements the all the variants support */
 
@@ -270,7 +270,7 @@ typedef u32 kbasep_js_check;
  * Private Functions
  */
 
-/* Table autogenerated using util built from: kbase/scripts/gen_cfs_weight_of_prio.c */
+/* Table autogenerated using util built from: midgard/scripts/gen_cfs_weight_of_prio.c */
 
 /* weight = 1.25 */
 static const int weight_of_priority[] = {
@@ -716,25 +716,36 @@ static enum hrtimer_restart timer_callback(struct hrtimer *timer)
 				u32 ticks = atom->sched_info.cfs.ticks++;
 
 #if !CINSTR_DUMPING_ENABLED
+				u32 soft_stop_ticks, hard_stop_ticks, gpu_reset_ticks;
+				if (atom->core_req & BASE_JD_REQ_ONLY_COMPUTE) {
+					soft_stop_ticks = js_devdata->soft_stop_ticks_cl;
+					hard_stop_ticks = js_devdata->hard_stop_ticks_cl;
+					gpu_reset_ticks = js_devdata->gpu_reset_ticks_cl;
+				} else {
+					soft_stop_ticks = js_devdata->soft_stop_ticks;
+					hard_stop_ticks = js_devdata->hard_stop_ticks_ss;
+					gpu_reset_ticks = js_devdata->gpu_reset_ticks_ss;
+				}
+
 				/* Job is Soft-Stoppable */
-				if (ticks == js_devdata->soft_stop_ticks) {
+				if (ticks == soft_stop_ticks) {
 					/* Job has been scheduled for at least js_devdata->soft_stop_ticks ticks.
 					 * Soft stop the slot so we can run other jobs.
 					 */
-					KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Soft-stop");
+					KBASE_LOG(1, kbdev->dev, "Soft-stop");
 
 #if KBASE_DISABLE_SCHEDULING_SOFT_STOPS == 0
 					kbase_job_slot_softstop(kbdev, s, atom);
 #endif
-				} else if (ticks == js_devdata->hard_stop_ticks_ss) {
+				} else if (ticks == hard_stop_ticks) {
 					/* Job has been scheduled for at least js_devdata->hard_stop_ticks_ss ticks.
 					 * It should have been soft-stopped by now. Hard stop the slot.
 					 */
 #if KBASE_DISABLE_SCHEDULING_HARD_STOPS == 0
-					KBASE_DEBUG_PRINT_WARN(KBASE_JM, "JS: Job Hard-Stopped (took more than %lu ticks at %lu ms/tick)", (unsigned long)ticks, (unsigned long)(js_devdata->scheduling_tick_ns / 1000000u));
+					dev_warn(kbdev->dev, "JS: Job Hard-Stopped (took more than %lu ticks at %lu ms/tick)", (unsigned long)ticks, (unsigned long)(js_devdata->scheduling_tick_ns / 1000000u));
 					kbase_job_slot_hardstop(atom->kctx, s, atom);
 #endif
-				} else if (ticks == js_devdata->gpu_reset_ticks_ss) {
+				} else if (ticks == gpu_reset_ticks) {
 					/* Job has been scheduled for at least js_devdata->gpu_reset_ticks_ss ticks.
 					 * It should have left the GPU by now. Signal that the GPU needs to be reset.
 					 */
@@ -748,13 +759,13 @@ static enum hrtimer_restart timer_callback(struct hrtimer *timer)
 					/* Job has been scheduled for at least js_devdata->soft_stop_ticks.
 					 * We do not soft-stop during CINSTR_DUMPING_ENABLED, however.
 					 */
-					KBASE_DEBUG_PRINT_INFO(KBASE_JM, "Soft-stop");
+					KBASE_LOG(1, kbdev->dev, "Soft-stop");
 				} else if (ticks == js_devdata->hard_stop_ticks_nss) {
 					/* Job has been scheduled for at least js_devdata->hard_stop_ticks_nss ticks.
 					 * Hard stop the slot.
 					 */
 #if KBASE_DISABLE_SCHEDULING_HARD_STOPS == 0
-					KBASE_DEBUG_PRINT_WARN(KBASE_JM, "JS: Job Hard-Stopped (took more than %lu ticks at %lu ms/tick)", (unsigned long)ticks, (unsigned long)(js_devdata->scheduling_tick_ns / 1000000u));
+					dev_warn(kbdev->dev, "JS: Job Hard-Stopped (took more than %lu ticks at %lu ms/tick)", (unsigned long)ticks, (unsigned long)(js_devdata->scheduling_tick_ns / 1000000u));
 					kbase_job_slot_hardstop(atom->kctx, s, atom);
 #endif
 				} else if (ticks == js_devdata->gpu_reset_ticks_nss) {
@@ -769,7 +780,7 @@ static enum hrtimer_restart timer_callback(struct hrtimer *timer)
 	}
 
 	if (reset_needed) {
-		KBASE_DEBUG_PRINT_ERROR(KBASE_JM, "JS: Job has been on the GPU for too long (KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS/NSS timeout hit). Issueing GPU soft-reset to resolve.");
+		dev_err(kbdev->dev, "JS: Job has been on the GPU for too long (KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS/NSS timeout hit). Issueing GPU soft-reset to resolve.");
 
 		if (kbase_prepare_to_reset_gpu_locked(kbdev))
 			kbase_reset_gpu_locked(kbdev);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_policy_cfs.h b/drivers/gpu/arm/midgard/mali_kbase_js_policy_cfs.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_js_policy_cfs.h
rename to drivers/gpu/arm/midgard/mali_kbase_js_policy_cfs.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_linux.h b/drivers/gpu/arm/midgard/mali_kbase_linux.h
old mode 100644
new mode 100755
similarity index 61%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_linux.h
rename to drivers/gpu/arm/midgard/mali_kbase_linux.h
index 36c1887a82f7..0d024f279761
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_linux.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_linux.h
@@ -32,41 +32,6 @@
 #include <linux/module.h>
 #include <linux/atomic.h>
 
-typedef struct kbase_os_context {
-	u64 cookies;
-	struct list_head reg_pending;
-	wait_queue_head_t event_queue;
-	pid_t tgid;
-	pid_t pid;
-} kbase_os_context;
-
-#define DEVNAME_SIZE	16
-
-typedef struct kbase_os_device {
-	struct list_head entry;
-	struct device *dev;
-	struct miscdevice mdev;
-	u64 reg_start;
-	size_t reg_size;
-	void __iomem *reg;
-	struct resource *reg_res;
-	struct {
-		int irq;
-		int flags;
-	} irqs[3];
-	char devname[DEVNAME_SIZE];
-
-#ifdef CONFIG_MALI_NO_MALI
-	void *model;
-	struct kmem_cache *irq_slab;
-	struct workqueue_struct *irq_workq;
-	atomic_t serving_job_irq;
-	atomic_t serving_gpu_irq;
-	atomic_t serving_mmu_irq;
-	spinlock_t reg_op_lock;
-#endif				/* CONFIG_MALI_NO_MALI */
-} kbase_os_device;
-
 #if defined(MALI_KERNEL_TEST_API)
 #if (1 == MALI_KERNEL_TEST_API)
 #define KBASE_EXPORT_TEST_API(func)		EXPORT_SYMBOL(func);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem.c b/drivers/gpu/arm/midgard/mali_kbase_mem.c
old mode 100644
new mode 100755
similarity index 77%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem.c
rename to drivers/gpu/arm/midgard/mali_kbase_mem.c
index 326f426d335a..c913c14708d1
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem.c
@@ -28,12 +28,12 @@
 #include <linux/bug.h>
 #include <linux/compat.h>
 
-#include <kbase/mali_kbase_config.h>
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_midg_regmap.h>
-#include <kbase/src/common/mali_kbase_cache_policy.h>
-#include <kbase/src/common/mali_kbase_hw.h>
-#include <kbase/src/common/mali_kbase_gator.h>
+#include <mali_kbase_config.h>
+#include <mali_kbase.h>
+#include <mali_midg_regmap.h>
+#include <mali_kbase_cache_policy.h>
+#include <mali_kbase_hw.h>
+#include <mali_kbase_gator.h>
 
 /**
  * @brief Check the zone compatibility of two regions.
@@ -357,26 +357,27 @@ mali_error kbase_add_va_region(kbase_context *kctx, struct kbase_va_region *reg,
 
 	/* Path 1: Map a specific address. Find the enclosing region, which *must* be free. */
 	if (gpu_pfn) {
+		struct device *dev = kctx->kbdev->dev;
 		KBASE_DEBUG_ASSERT(!(gpu_pfn & (align - 1)));
 
 		tmp = kbase_region_tracker_find_region_enclosing_range_free(kctx, gpu_pfn, nr_pages);
 		if (!tmp) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Enclosing region not found: 0x%08llx gpu_pfn, %zu nr_pages", gpu_pfn, nr_pages);
+			dev_warn(dev, "Enclosing region not found: 0x%08llx gpu_pfn, %zu nr_pages", gpu_pfn, nr_pages);
 			err = MALI_ERROR_OUT_OF_GPU_MEMORY;
 			goto exit;
 		}
 
 		if ((!kbase_region_tracker_match_zone(tmp, reg)) || (!(tmp->flags & KBASE_REG_FREE))) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Zone mismatch: %lu != %lu", tmp->flags & KBASE_REG_ZONE_MASK, reg->flags & KBASE_REG_ZONE_MASK);
-			KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "!(tmp->flags & KBASE_REG_FREE): tmp->start_pfn=0x%llx tmp->flags=0x%lx tmp->nr_pages=0x%zx gpu_pfn=0x%llx nr_pages=0x%zx\n", tmp->start_pfn, tmp->flags, tmp->nr_pages, gpu_pfn, nr_pages);
-			KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "in function %s (%p, %p, 0x%llx, 0x%zx, 0x%zx)\n", __func__, kctx, reg, addr, nr_pages, align);
+			dev_warn(dev, "Zone mismatch: %lu != %lu", tmp->flags & KBASE_REG_ZONE_MASK, reg->flags & KBASE_REG_ZONE_MASK);
+			dev_warn(dev, "!(tmp->flags & KBASE_REG_FREE): tmp->start_pfn=0x%llx tmp->flags=0x%lx tmp->nr_pages=0x%zx gpu_pfn=0x%llx nr_pages=0x%zx\n", tmp->start_pfn, tmp->flags, tmp->nr_pages, gpu_pfn, nr_pages);
+			dev_warn(dev, "in function %s (%p, %p, 0x%llx, 0x%zx, 0x%zx)\n", __func__, kctx, reg, addr, nr_pages, align);
 			err = MALI_ERROR_OUT_OF_GPU_MEMORY;
 			goto exit;
 		}
 
 		err = kbase_insert_va_region_nolock(kctx, reg, tmp, gpu_pfn, nr_pages);
 		if (err) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Failed to insert va region");
+			dev_warn(dev, "Failed to insert va region");
 			err = MALI_ERROR_OUT_OF_GPU_MEMORY;
 			goto exit;
 		}
@@ -439,10 +440,18 @@ mali_error kbase_region_tracker_init(kbase_context *kctx)
 	struct kbase_va_region *same_va_reg;
 	struct kbase_va_region *exec_reg = NULL;
 	struct kbase_va_region *custom_va_reg = NULL;
-	size_t same_va_bits = sizeof(void*) * BITS_PER_BYTE;
+	size_t same_va_bits = sizeof(void *) * BITS_PER_BYTE;
 	u64 custom_va_size = KBASE_REG_ZONE_CUSTOM_VA_SIZE;
 	u64 gpu_va_limit = (1ULL << kctx->kbdev->gpu_props.mmu.va_bits) >> PAGE_SHIFT;
 
+#if defined(CONFIG_ARM64)
+	same_va_bits = VA_BITS;
+#elif defined(CONFIG_X86_64)
+	same_va_bits = 47;
+#elif defined(CONFIG_64BIT)
+#error Unsupported 64-bit architecture
+#endif
+
 #ifdef CONFIG_64BIT
 	if (is_compat_task())
 		same_va_bits = 32;
@@ -495,16 +504,12 @@ mali_error kbase_region_tracker_init(kbase_context *kctx)
 mali_error kbase_mem_init(struct kbase_device *kbdev)
 {
 	kbasep_mem_device *memdev;
-	size_t max_shared_memory;
 	KBASE_DEBUG_ASSERT(kbdev);
 
 	memdev = &kbdev->memdev;
 
-	max_shared_memory = (size_t)kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_MEMORY_OS_SHARED_MAX);
-
-	if (MALI_ERROR_NONE != kbase_mem_usage_init(&memdev->usage, max_shared_memory >> PAGE_SHIFT)) {
-		return MALI_ERROR_FUNCTION_FAILED;
-	}
+	/* Initialize memory usage */
+	atomic_set(&memdev->used_pages, 0);
 
 	/* nothing to do, zero-inited when kbase_device was created */
 	return MALI_ERROR_NONE;
@@ -518,98 +523,19 @@ void kbase_mem_halt(kbase_device *kbdev)
 void kbase_mem_term(kbase_device *kbdev)
 {
 	kbasep_mem_device *memdev;
+	int pages;
+
 	KBASE_DEBUG_ASSERT(kbdev);
 
 	memdev = &kbdev->memdev;
 
-	kbase_mem_usage_term(&memdev->usage);
+	pages = atomic_read(&memdev->used_pages);
+	if (pages != 0)
+		dev_warn(kbdev->dev, "%s: %d pages in use!\n", __func__, pages);
 }
 
 KBASE_EXPORT_TEST_API(kbase_mem_term)
 
-mali_error kbase_mem_usage_init(struct kbasep_mem_usage *usage, size_t max_pages)
-{
-	KBASE_DEBUG_ASSERT(usage);
-
-	atomic_set(&usage->cur_pages, 0);
-	/* query the max page count */
-	usage->max_pages = max_pages;
-
-	return MALI_ERROR_NONE;
-}
-
-void kbase_mem_usage_term(kbasep_mem_usage *usage)
-{
-	KBASE_DEBUG_ASSERT(usage);
-	/* No memory should be in use now */
-	if (0 != atomic_read(&usage->cur_pages)) {
-		printk(KERN_ERR "Pages in use! %d\n", atomic_read(&usage->cur_pages));
-	}
-	/* So any new alloc requests will fail */
-	usage->max_pages = 0;
-	/* So we printk on double term */
-	atomic_set(&usage->cur_pages, INT_MAX);
-}
-
-mali_error kbase_mem_usage_request_pages(kbasep_mem_usage *usage, size_t nr_pages)
-{
-	int cur_pages;
-	int old_cur_pages;
-
-	KBASE_DEBUG_ASSERT(usage);
-	KBASE_DEBUG_ASSERT(nr_pages);	/* 0 pages would be an error in the calling code */
-
-	/*
-	 * Fetch the initial cur_pages value
-	 * each loop iteration below fetches
-	 * it as part of the store attempt
-	 */
-	cur_pages = atomic_read(&usage->cur_pages);
-
-	/* this check allows the simple if test in the loop below */
-	if (usage->max_pages < nr_pages)
-		goto usage_cap_exceeded;
-
-	do {
-		int new_cur_pages;
-		/* enough pages to fullfill the request? */
-		if (usage->max_pages - nr_pages < cur_pages) {
- usage_cap_exceeded:
-			KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Memory usage cap has been reached:\n" "\t%lu pages currently used\n" "\t%lu pages usage cap\n" "\t%lu new pages requested\n" "\twould result in %lu pages over the cap\n", (unsigned long)cur_pages, (unsigned long)usage->max_pages, (unsigned long)nr_pages, (unsigned long)(cur_pages + nr_pages - usage->max_pages));
-			return MALI_ERROR_OUT_OF_MEMORY;
-		}
-
-		/* try to atomically commit the new count */
-		old_cur_pages = cur_pages;
-		new_cur_pages = cur_pages + nr_pages;
-		cur_pages = atomic_cmpxchg(&usage->cur_pages, old_cur_pages,
-					    new_cur_pages);
-		/* cur_pages will be like old_cur_pages if there was no race */
-	} while (cur_pages != old_cur_pages);
-
-#ifdef CONFIG_MALI_GATOR_SUPPORT
-	kbase_trace_mali_total_alloc_pages_change((long long int)cur_pages);
-#endif				/* CONFIG_MALI_GATOR_SUPPORT */
-
-	return MALI_ERROR_NONE;
-}
-
-KBASE_EXPORT_TEST_API(kbase_mem_usage_request_pages)
-
-void kbase_mem_usage_release_pages(kbasep_mem_usage *usage, size_t nr_pages)
-{
-	int new_val;
-	KBASE_DEBUG_ASSERT(usage);
-	KBASE_DEBUG_ASSERT(nr_pages <= atomic_read(&usage->cur_pages));
-
-	new_val = atomic_sub_return(nr_pages, &usage->cur_pages);
-#ifdef CONFIG_MALI_GATOR_SUPPORT
-	kbase_trace_mali_total_alloc_pages_change((long long int)new_val);
-#endif				/* CONFIG_MALI_GATOR_SUPPORT */
-}
-
-KBASE_EXPORT_TEST_API(kbase_mem_usage_release_pages)
-
 /**
  * @brief Wait for GPU write flush - only in use for BASE_HW_ISSUE_6367
  *
@@ -666,7 +592,7 @@ struct kbase_va_region *kbase_alloc_free_region(kbase_context *kctx, u64 start_p
 	new_reg = kzalloc(sizeof(*new_reg), GFP_KERNEL);
 
 	if (!new_reg) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "kzalloc failed");
+		dev_warn(kctx->kbdev->dev, "kzalloc failed");
 		return NULL;
 	}
 
@@ -676,6 +602,9 @@ struct kbase_va_region *kbase_alloc_free_region(kbase_context *kctx, u64 start_p
 
 	new_reg->flags |= KBASE_REG_GROWABLE;
 
+	/* Set up default MEMATTR usage */
+	new_reg->flags |= KBASE_REG_MEMATTR_INDEX(ASn_MEMATTR_INDEX_DEFAULT);
+
 	new_reg->start_pfn = start_pfn;
 	new_reg->nr_pages = nr_pages;
 
@@ -698,7 +627,6 @@ void kbase_free_alloced_region(struct kbase_va_region *reg)
 {
 	KBASE_DEBUG_ASSERT(NULL != reg);
 	if (!(reg->flags & KBASE_REG_FREE)) {
-		KBASE_DEBUG_ASSERT(reg->alloc);
 		kbase_mem_phy_alloc_put(reg->alloc);
 		KBASE_DEBUG_CODE(
 					/* To detect use-after-free in debug builds */
@@ -712,10 +640,11 @@ KBASE_EXPORT_TEST_API(kbase_free_alloced_region)
 void kbase_mmu_update(kbase_context *kctx)
 {
 	/* Use GPU implementation-defined caching policy. */
-	u32 memattr = ASn_MEMATTR_IMPL_DEF_CACHE_POLICY;
+	u64 mem_attrs;
 	u32 pgd_high;
 
 	KBASE_DEBUG_ASSERT(NULL != kctx);
+	mem_attrs = kctx->mem_attrs;
 	/* ASSERT that the context has a valid as_nr, which is only the case
 	 * when it's scheduled in.
 	 *
@@ -724,20 +653,28 @@ void kbase_mmu_update(kbase_context *kctx)
 
 	pgd_high = sizeof(kctx->pgd) > 4 ? (kctx->pgd >> 32) : 0;
 
-	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_TRANSTAB_LO), (kctx->pgd & ASn_TRANSTAB_ADDR_SPACE_MASK) | ASn_TRANSTAB_READ_INNER | ASn_TRANSTAB_ADRMODE_TABLE, kctx);
+	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_TRANSTAB_LO),
+			(kctx->pgd & ASn_TRANSTAB_ADDR_SPACE_MASK) |
+			ASn_TRANSTAB_READ_INNER | ASn_TRANSTAB_ADRMODE_TABLE,
+			kctx);
 
-	/* Need to use a conditional expression to avoid "right shift count >= width of type"
-	 * error when using an if statement - although the size_of condition is evaluated at compile
-	 * time the unused branch is not removed until after it is type-checked and the error
-	 * produced.
+	/* Need to use a conditional expression to avoid
+	 * "right shift count >= width of type" error when using an if statement
+	 * - although the size_of condition is evaluated at compile time the
+	 * unused branch is not removed until after it is type-checked and the
+	 * error produced.
 	 */
 	pgd_high = sizeof(kctx->pgd) > 4 ? (kctx->pgd >> 32) : 0;
 
-	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_TRANSTAB_HI), pgd_high, kctx);
+	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_TRANSTAB_HI),
+			pgd_high, kctx);
 
-	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_MEMATTR_LO), memattr, kctx);
-	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_MEMATTR_HI), memattr, kctx);
-	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_COMMAND), ASn_COMMAND_UPDATE, kctx);
+	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_MEMATTR_LO),
+			mem_attrs        & 0xFFFFFFFFUL, kctx);
+	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_MEMATTR_HI),
+			(mem_attrs >> 32) & 0xFFFFFFFFUL, kctx);
+	kbase_reg_write(kctx->kbdev, MMU_AS_REG(kctx->as_nr, ASn_COMMAND),
+			ASn_COMMAND_UPDATE, kctx);
 }
 
 KBASE_EXPORT_TEST_API(kbase_mmu_update)
@@ -761,6 +698,7 @@ KBASE_EXPORT_TEST_API(kbase_mmu_disable)
 mali_error kbase_gpu_mmap(kbase_context *kctx, struct kbase_va_region *reg, mali_addr64 addr, size_t nr_pages, size_t align)
 {
 	mali_error err;
+	size_t i = 0;
 	KBASE_DEBUG_ASSERT(NULL != kctx);
 	KBASE_DEBUG_ASSERT(NULL != reg);
 
@@ -768,9 +706,57 @@ mali_error kbase_gpu_mmap(kbase_context *kctx, struct kbase_va_region *reg, mali
 	if (MALI_ERROR_NONE != err)
 		return err;
 
-	err = kbase_mmu_insert_pages(kctx, reg->start_pfn, kbase_get_phy_pages(reg), kbase_reg_current_backed_size(reg) , reg->flags & ((1 << KBASE_REG_FLAGS_NR_BITS) - 1));
-	if (MALI_ERROR_NONE != err)
-		kbase_remove_va_region(kctx, reg);
+	if (reg->alloc->type == KBASE_MEM_TYPE_ALIAS) {
+		u64 stride;
+		stride = reg->alloc->imported.alias.stride;
+		KBASE_DEBUG_ASSERT(reg->alloc->imported.alias.aliased);
+		for (i = 0; i < reg->alloc->imported.alias.nents; i++) {
+			if (reg->alloc->imported.alias.aliased[i].alloc) {
+				err = kbase_mmu_insert_pages(kctx,
+						reg->start_pfn + (i * stride),
+						reg->alloc->imported.alias.aliased[i].alloc->pages + reg->alloc->imported.alias.aliased[i].offset,
+						reg->alloc->imported.alias.aliased[i].length,
+						reg->flags);
+				if (MALI_ERROR_NONE != err)
+					goto bad_insert;
+
+				kbase_mem_phy_alloc_gpu_mapped(reg->alloc->imported.alias.aliased[i].alloc);
+			} else {
+				err = kbase_mmu_insert_single_page(kctx,
+						reg->start_pfn + i * stride,
+						kctx->aliasing_sink_page,
+						reg->alloc->imported.alias.aliased[i].length,
+						(reg->flags & ~KBASE_REG_MEMATTR_MASK) | KBASE_REG_MEMATTR_INDEX(ASn_MEMATTR_INDEX_WRITE_ALLOC)
+						);
+				if (MALI_ERROR_NONE != err)
+					goto bad_insert;
+			}
+		}
+	} else {
+		err = kbase_mmu_insert_pages(kctx, reg->start_pfn,
+				kbase_get_phy_pages(reg),
+				kbase_reg_current_backed_size(reg),
+				reg->flags);
+		if (MALI_ERROR_NONE != err)
+			goto bad_insert;
+		kbase_mem_phy_alloc_gpu_mapped(reg->alloc);
+	}
+
+	return err;
+
+bad_insert:
+	if (reg->alloc->type == KBASE_MEM_TYPE_ALIAS) {
+		u64 stride;
+		stride = reg->alloc->imported.alias.stride;
+		KBASE_DEBUG_ASSERT(reg->alloc->imported.alias.aliased);
+		while (i--)
+			if (reg->alloc->imported.alias.aliased[i].alloc) {
+				kbase_mmu_teardown_pages(kctx, reg->start_pfn + (i * stride), reg->alloc->imported.alias.aliased[i].length);
+				kbase_mem_phy_alloc_gpu_unmapped(reg->alloc->imported.alias.aliased[i].alloc);
+			}
+	}
+
+	kbase_remove_va_region(kctx, reg);
 
 	return err;
 }
@@ -784,7 +770,18 @@ mali_error kbase_gpu_munmap(kbase_context *kctx, struct kbase_va_region *reg)
 	if (reg->start_pfn == 0)
 		return MALI_ERROR_NONE;
 
-	err = kbase_mmu_teardown_pages(kctx, reg->start_pfn, kbase_reg_current_backed_size(reg));
+	if (reg->alloc && reg->alloc->type == KBASE_MEM_TYPE_ALIAS) {
+		size_t i;
+		err = kbase_mmu_teardown_pages(kctx, reg->start_pfn, reg->nr_pages);
+		KBASE_DEBUG_ASSERT(reg->alloc->imported.alias.aliased);
+		for (i = 0; i < reg->alloc->imported.alias.nents; i++)
+			if (reg->alloc->imported.alias.aliased[i].alloc)
+				kbase_mem_phy_alloc_gpu_unmapped(reg->alloc->imported.alias.aliased[i].alloc);
+	} else {
+		err = kbase_mmu_teardown_pages(kctx, reg->start_pfn, kbase_reg_current_backed_size(reg));
+		kbase_mem_phy_alloc_gpu_unmapped(reg->alloc);
+	}
+
 	if (MALI_ERROR_NONE != err)
 		return err;
 
@@ -805,7 +802,7 @@ STATIC struct kbase_cpu_mapping *kbasep_find_enclosing_cpu_mapping_of_region(con
 
 	list_for_each(pos, &reg->alloc->mappings) {
 		map = list_entry(pos, kbase_cpu_mapping, mappings_list);
-		if (map->vma->vm_start <= uaddr && map->vma->vm_end >= uaddr + size)
+		if (map->vm_start <= uaddr && map->vm_end >= uaddr + size)
 			return map;
 	}
 
@@ -814,25 +811,37 @@ STATIC struct kbase_cpu_mapping *kbasep_find_enclosing_cpu_mapping_of_region(con
 
 KBASE_EXPORT_TEST_API(kbasep_find_enclosing_cpu_mapping_of_region)
 
-struct kbase_cpu_mapping *kbasep_find_enclosing_cpu_mapping(kbase_context *kctx, mali_addr64 gpu_addr, unsigned long uaddr, size_t size)
+mali_error kbasep_find_enclosing_cpu_mapping_offset(kbase_context *kctx,
+							  mali_addr64 gpu_addr,
+							   unsigned long uaddr,
+								   size_t size,
+							   mali_size64 *offset)
 {
 	struct kbase_cpu_mapping *map = NULL;
 	const struct kbase_va_region *reg;
-
+	mali_error err = MALI_ERROR_FUNCTION_FAILED;
 	KBASE_DEBUG_ASSERT(kctx != NULL);
 
 	kbase_gpu_vm_lock(kctx);
 
-	reg = kbase_region_tracker_find_region_enclosing_address(kctx, gpu_addr);
-	if (NULL != reg)
-		map = kbasep_find_enclosing_cpu_mapping_of_region(reg, uaddr, size);
+	reg = kbase_region_tracker_find_region_enclosing_address(kctx,
+								     gpu_addr);
+	if (reg) {
+		map = kbasep_find_enclosing_cpu_mapping_of_region(reg, uaddr,
+									 size);
+		if (map) {
+			*offset = (uaddr - PTR_TO_U64(map->vm_start)) +
+						 (map->page_off << PAGE_SHIFT);
+			err = MALI_ERROR_NONE;
+		}
+	}
 
 	kbase_gpu_vm_unlock(kctx);
 
-	return map;
+	return err;
 }
 
-KBASE_EXPORT_TEST_API(kbasep_find_enclosing_cpu_mapping)
+KBASE_EXPORT_TEST_API(kbasep_find_enclosing_cpu_mapping_offset)
 
 static mali_error kbase_do_syncset(kbase_context *kctx, struct base_syncset *set, kbase_sync_kmem_fn sync_fn)
 {
@@ -857,7 +866,7 @@ static mali_error kbase_do_syncset(kbase_context *kctx, struct base_syncset *set
 	/* find the region where the virtual address is contained */
 	reg = kbase_region_tracker_find_region_enclosing_address(kctx, sset->mem_handle);
 	if (!reg) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Can't find region at VA 0x%016llX", sset->mem_handle);
+		dev_warn(kctx->kbdev->dev, "Can't find region at VA 0x%016llX", sset->mem_handle);
 		err = MALI_ERROR_FUNCTION_FAILED;
 		goto out_unlock;
 	}
@@ -870,20 +879,29 @@ static mali_error kbase_do_syncset(kbase_context *kctx, struct base_syncset *set
 
 	map = kbasep_find_enclosing_cpu_mapping_of_region(reg, start, size);
 	if (!map) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Can't find CPU mapping 0x%016lX for VA 0x%016llX", start, sset->mem_handle);
+		dev_warn(kctx->kbdev->dev, "Can't find CPU mapping 0x%016lX for VA 0x%016llX", start, sset->mem_handle);
 		err = MALI_ERROR_FUNCTION_FAILED;
 		goto out_unlock;
 	}
 
 	offset_within_page = start & (PAGE_SIZE - 1);
-	page_off = map->page_off + ((start - map->vma->vm_start) >> PAGE_SHIFT);
+	page_off = map->page_off + ((start - map->vm_start) >> PAGE_SHIFT);
 	page_count = ((size + offset_within_page + (PAGE_SIZE - 1)) & PAGE_MASK) >> PAGE_SHIFT;
 	pa = kbase_get_phy_pages(reg);
 
+	pagefault_disable();
+
 	for (i = 0; i < page_count; i++) {
 		u32 offset = start & (PAGE_SIZE - 1);
 		phys_addr_t paddr = pa[page_off + i] + offset;
 		size_t sz = MIN(((size_t) PAGE_SIZE - offset), size);
+		u8 tmp;
+
+		if (copy_from_user(&tmp, (void*)(uintptr_t)start, 1)) {
+			/* Not accessible */
+			err = MALI_ERROR_FUNCTION_FAILED;
+			goto out_enable_pagefaults;
+		}
 
 		if (paddr == base_phy_addr + area_size && start == ((uintptr_t) base_virt_addr + area_size)) {
 			area_size += sz;
@@ -907,7 +925,9 @@ static mali_error kbase_do_syncset(kbase_context *kctx, struct base_syncset *set
 
 	KBASE_DEBUG_ASSERT(size == 0);
 
- out_unlock:
+out_enable_pagefaults:
+	pagefault_enable();
+out_unlock:
 	kbase_gpu_vm_unlock(kctx);
 	kbase_os_mem_map_unlock(kctx);
 	return err;
@@ -933,7 +953,7 @@ mali_error kbase_sync_now(kbase_context *kctx, struct base_syncset *syncset)
 		break;
 
 	default:
-		KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Unknown msync op %d\n", sset->type);
+		dev_warn(kctx->kbdev->dev, "Unknown msync op %d\n", sset->type);
 		break;
 	}
 
@@ -951,7 +971,7 @@ mali_error kbase_mem_free_region(kbase_context *kctx, kbase_va_region *reg)
 	BUG_ON(!mutex_is_locked(&kctx->reg_lock));
 	err = kbase_gpu_munmap(kctx, reg);
 	if (err) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Could not unmap from the GPU...\n");
+		dev_warn(reg->kctx->kbdev->dev, "Could not unmap from the GPU...\n");
 		goto out;
 	}
 
@@ -983,21 +1003,24 @@ mali_error kbase_mem_free(kbase_context *kctx, mali_addr64 gpu_addr)
 	KBASE_DEBUG_ASSERT(kctx != NULL);
 
 	if (0 == gpu_addr) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "gpu_addr 0 is reserved for the ringbuffer and it's an error to try to free it using kbase_mem_free\n");
+		dev_warn(kctx->kbdev->dev, "gpu_addr 0 is reserved for the ringbuffer and it's an error to try to free it using kbase_mem_free\n");
 		return MALI_ERROR_FUNCTION_FAILED;
 	}
 	kbase_gpu_vm_lock(kctx);
 
-	if (gpu_addr < PAGE_SIZE) {
-		/* an OS specific cookie, ask the OS specific code to validate it */
-		reg = kbase_lookup_cookie(kctx, gpu_addr);
+	if (gpu_addr >= BASE_MEM_COOKIE_BASE &&
+	    gpu_addr < BASE_MEM_FIRST_FREE_ADDRESS) {
+		int cookie = PFN_DOWN(gpu_addr - BASE_MEM_COOKIE_BASE);
+		reg = kctx->pending_regions[cookie];
 		if (!reg) {
 			err = MALI_ERROR_FUNCTION_FAILED;
 			goto out_unlock;
 		}
 
 		/* ask to unlink the cookie as we'll free it */
-		kbase_unlink_cookie(kctx, gpu_addr, reg);
+
+		kctx->pending_regions[cookie] = NULL;
+		kctx->cookies |= (1UL << cookie);
 
 		kbase_free_alloced_region(reg);
 	} else {
@@ -1006,7 +1029,17 @@ mali_error kbase_mem_free(kbase_context *kctx, mali_addr64 gpu_addr)
 		/* Validate the region */
 		reg = kbase_region_tracker_find_region_base_address(kctx, gpu_addr);
 		if (!reg) {
-			KBASE_DEBUG_ASSERT_MSG(0, "Trying to free nonexistent region\n 0x%llX", gpu_addr);
+			dev_warn(kctx->kbdev->dev,
+			    "kbase_mem_free called with nonexistent gpu_addr 0x%llX",
+			    gpu_addr);
+			err = MALI_ERROR_FUNCTION_FAILED;
+			goto out_unlock;
+		}
+
+		if ((reg->flags & KBASE_REG_ZONE_MASK) == KBASE_REG_ZONE_SAME_VA) {
+			/* SAME_VA must be freed through munmap */
+			dev_warn(kctx->kbdev->dev,
+			    "%s called on SAME_VA memory 0x%llX", __func__, gpu_addr);
 			err = MALI_ERROR_FUNCTION_FAILED;
 			goto out_unlock;
 		}
@@ -1056,20 +1089,19 @@ void kbase_update_region_flags(struct kbase_va_region *reg, unsigned long flags)
 }
 KBASE_EXPORT_TEST_API(kbase_update_region_flags)
 
-int kbase_alloc_phy_pages_helper(struct kbase_mem_phy_alloc * alloc, size_t nr_pages_requested)
+int kbase_alloc_phy_pages_helper(
+	struct kbase_mem_phy_alloc *alloc,
+	size_t nr_pages_requested)
 {
 	KBASE_DEBUG_ASSERT(alloc);
 	KBASE_DEBUG_ASSERT(alloc->type == KBASE_MEM_TYPE_NATIVE);
 	KBASE_DEBUG_ASSERT(alloc->imported.kctx);
 
-	if (0 == nr_pages_requested)
+	if (nr_pages_requested == 0)
 		goto done; /*nothing to do*/
 
-	if (MALI_ERROR_NONE != kbase_mem_usage_request_pages(&alloc->imported.kctx->usage, nr_pages_requested))
-		goto no_kctx_usage;
-
-	if (MALI_ERROR_NONE != kbase_mem_usage_request_pages(&alloc->imported.kctx->kbdev->memdev.usage, nr_pages_requested))
-		goto no_memdev_usage;
+	kbase_atomic_add_pages(nr_pages_requested, &alloc->imported.kctx->used_pages);
+	kbase_atomic_add_pages(nr_pages_requested, &alloc->imported.kctx->kbdev->memdev.used_pages);
 
 	if (MALI_ERROR_NONE != kbase_mem_allocator_alloc(&alloc->imported.kctx->osalloc, nr_pages_requested, alloc->pages + alloc->nents))
 		goto no_alloc;
@@ -1081,14 +1113,15 @@ int kbase_alloc_phy_pages_helper(struct kbase_mem_phy_alloc * alloc, size_t nr_p
 	return 0;
 
 no_alloc:
-	kbase_mem_usage_release_pages(&alloc->imported.kctx->kbdev->memdev.usage, nr_pages_requested);
-no_memdev_usage:
-	kbase_mem_usage_release_pages(&alloc->imported.kctx->usage, nr_pages_requested);
-no_kctx_usage:
+	kbase_atomic_sub_pages(nr_pages_requested, &alloc->imported.kctx->used_pages);
+	kbase_atomic_sub_pages(nr_pages_requested, &alloc->imported.kctx->kbdev->memdev.used_pages);
+
 	return -ENOMEM;
 }
 
-int kbase_free_phy_pages_helper(struct kbase_mem_phy_alloc * alloc, size_t nr_pages_to_free)
+int kbase_free_phy_pages_helper(
+	struct kbase_mem_phy_alloc *alloc,
+	size_t nr_pages_to_free)
 {
 	mali_bool syncback;
 	phys_addr_t *start_free;
@@ -1112,49 +1145,61 @@ int kbase_free_phy_pages_helper(struct kbase_mem_phy_alloc * alloc, size_t nr_pa
 
 	alloc->nents -= nr_pages_to_free;
 	kbase_process_page_usage_dec(alloc->imported.kctx, nr_pages_to_free);
-	kbase_mem_usage_release_pages(&alloc->imported.kctx->usage, nr_pages_to_free);
-	kbase_mem_usage_release_pages(&alloc->imported.kctx->kbdev->memdev.usage, nr_pages_to_free);
+	kbase_atomic_sub_pages(nr_pages_to_free, &alloc->imported.kctx->used_pages);
+	kbase_atomic_sub_pages(nr_pages_to_free, &alloc->imported.kctx->kbdev->memdev.used_pages);
 
 	return 0;
 }
 
-void kbase_mem_kref_free(struct kref * kref)
+void kbase_mem_kref_free(struct kref *kref)
 {
-	struct kbase_mem_phy_alloc * alloc;
+	struct kbase_mem_phy_alloc *alloc;
 	alloc = container_of(kref, struct kbase_mem_phy_alloc, kref);
 
 	switch (alloc->type) {
-		case KBASE_MEM_TYPE_NATIVE:
-		{
-			KBASE_DEBUG_ASSERT(alloc->imported.kctx);
-			kbase_free_phy_pages_helper(alloc, alloc->nents);
-			break;
-		}
-		case KBASE_MEM_TYPE_RAW:
-			/* raw pages, external cleanup */
-			break;
+	case KBASE_MEM_TYPE_NATIVE: {
+		KBASE_DEBUG_ASSERT(alloc->imported.kctx);
+		kbase_free_phy_pages_helper(alloc, alloc->nents);
+		break;
+	}
+	case KBASE_MEM_TYPE_ALIAS: {
+		/* just call put on the underlying phy allocs */
+		size_t i;
+		struct kbase_aliased *aliased;
+		aliased = alloc->imported.alias.aliased;
+		if (aliased) {
+				for (i = 0; i < alloc->imported.alias.nents; i++)
+					if (aliased[i].alloc)
+						kbase_mem_phy_alloc_put(aliased[i].alloc);
+				vfree(aliased);
+		}				
+		break;
+	}
+	case KBASE_MEM_TYPE_RAW:
+		/* raw pages, external cleanup */
+		break;
  #ifdef CONFIG_UMP
-		case KBASE_MEM_TYPE_IMPORTED_UMP:
-			ump_dd_release(alloc->imported.ump_handle);
-			break;
+	case KBASE_MEM_TYPE_IMPORTED_UMP:
+		ump_dd_release(alloc->imported.ump_handle);
+		break;
 #endif
 #ifdef CONFIG_DMA_SHARED_BUFFER
-		case KBASE_MEM_TYPE_IMPORTED_UMM:
-			dma_buf_detach(alloc->imported.umm.dma_buf, alloc->imported.umm.dma_attachment);
-			dma_buf_put(alloc->imported.umm.dma_buf);
-			break;
+	case KBASE_MEM_TYPE_IMPORTED_UMM:
+		dma_buf_detach(alloc->imported.umm.dma_buf,
+			       alloc->imported.umm.dma_attachment);
+		dma_buf_put(alloc->imported.umm.dma_buf);
+		break;
 #endif
-		case KBASE_MEM_TYPE_TB:
-		{
-			void * tb;
-			tb = alloc->imported.kctx->jctx.tb;
-			kbase_device_trace_buffer_uninstall(alloc->imported.kctx);
-			vfree(tb);
-			break;
-		}
-		default:
-			WARN(1, "Unexecpted free of type %d\n", alloc->type);
-			break;
+	case KBASE_MEM_TYPE_TB:{
+		void *tb;
+		tb = alloc->imported.kctx->jctx.tb;
+		kbase_device_trace_buffer_uninstall(alloc->imported.kctx);
+		vfree(tb);
+		break;
+	}
+	default:
+		WARN(1, "Unexecpted free of type %d\n", alloc->type);
+		break;
 	}
 	vfree(alloc);
 }
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem.h b/drivers/gpu/arm/midgard/mali_kbase_mem.h
old mode 100644
new mode 100755
similarity index 79%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem.h
rename to drivers/gpu/arm/midgard/mali_kbase_mem.h
index b5c87ca8dadd..8cbde3210a45
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem.h
@@ -35,10 +35,13 @@
 #ifdef CONFIG_UMP
 #include <linux/ump.h>
 #endif				/* CONFIG_UMP */
-#include <kbase/mali_base_kernel.h>
-#include <kbase/src/common/mali_kbase_hw.h>
+#include "mali_base_kernel.h"
+#include <mali_kbase_hw.h>
 #include "mali_kbase_pm.h"
 #include "mali_kbase_defs.h"
+#ifdef CONFIG_MALI_GATOR_SUPPORT
+#include "mali_kbase_gator.h"
+#endif  /*CONFIG_MALI_GATOR_SUPPORT*/
 
 /* Part of the workaround for uTLB invalid pages is to ensure we grow/shrink tmem by 4 pages at a time */
 #define KBASEP_TMEM_GROWABLE_BLOCKSIZE_PAGES_LOG2_HW_ISSUE_8316 (2)	/* round to 4 pages */
@@ -61,21 +64,32 @@ updates and generates duplicate page faults as the page table information used b
 typedef struct kbase_cpu_mapping {
 	struct  list_head mappings_list;
 	struct  kbase_mem_phy_alloc *alloc;
-	struct  vm_area_struct *vma;
 	struct  kbase_context *kctx;
 	struct  kbase_va_region *region;
 	pgoff_t page_off;
 	int     count;
+
+	unsigned long vm_start;
+	unsigned long vm_end;
 } kbase_cpu_mapping;
 
 enum kbase_memory_type {
 	KBASE_MEM_TYPE_NATIVE,
 	KBASE_MEM_TYPE_IMPORTED_UMP,
 	KBASE_MEM_TYPE_IMPORTED_UMM,
+	KBASE_MEM_TYPE_ALIAS,
 	KBASE_MEM_TYPE_TB,
 	KBASE_MEM_TYPE_RAW
 };
 
+/* internal structure, mirroring base_mem_aliasing_info,
+ * but with alloc instead of a gpu va (handle) */
+struct kbase_aliased {
+	struct kbase_mem_phy_alloc *alloc; /* NULL for special, non-NULL for native */
+	u64 offset; /* in pages */
+	u64 length; /* in pages */
+};
+
 /* physical pages tracking object.
  * Set up to track N pages.
  * N not stored here, the creator holds that info.
@@ -87,6 +101,7 @@ enum kbase_memory_type {
 struct kbase_mem_phy_alloc
 {
 	struct kref           kref; /* number of users of this alloc */
+	atomic_t              gpu_mappings;
 	size_t                nents; /* 0..N */
 	phys_addr_t *         pages; /* N elements, only 0..nents are valid */
 
@@ -111,11 +126,35 @@ struct kbase_mem_phy_alloc
 			struct sg_table *sgt;
 		} umm;
 #endif /* defined(CONFIG_DMA_SHARED_BUFFER) */
+		struct {
+			mali_size64 stride;
+			size_t nents;
+			struct kbase_aliased *aliased;
+		} alias;
 		/* Used by type = (KBASE_MEM_TYPE_NATIVE, KBASE_MEM_TYPE_TB) */
 		struct kbase_context *kctx;
 	} imported;
 };
 
+static inline void kbase_mem_phy_alloc_gpu_mapped(struct kbase_mem_phy_alloc *alloc)
+{
+	KBASE_DEBUG_ASSERT(alloc);
+	/* we only track mappings of NATIVE buffers */
+	if (alloc->type == KBASE_MEM_TYPE_NATIVE)
+		atomic_inc(&alloc->gpu_mappings);
+}
+
+static inline void kbase_mem_phy_alloc_gpu_unmapped(struct kbase_mem_phy_alloc *alloc)
+{
+	KBASE_DEBUG_ASSERT(alloc);
+	/* we only track mappings of NATIVE buffers */
+	if (alloc->type == KBASE_MEM_TYPE_NATIVE)
+		if (0 > atomic_dec_return(&alloc->gpu_mappings)) {
+			pr_err("Mismatched %s:\n", __func__);
+			dump_stack();
+		}
+}
+
 void kbase_mem_kref_free(struct kref * kref);
 
 mali_error kbase_mem_init(kbase_device * kbdev);
@@ -134,7 +173,6 @@ static inline struct kbase_mem_phy_alloc * kbase_mem_phy_alloc_put(struct kbase_
 	return NULL;
 }
 
-
 /**
  * A GPU memory region, and attributes for CPU mappings.
  */
@@ -147,32 +185,49 @@ typedef struct kbase_va_region {
 	u64 start_pfn;		/* The PFN in GPU space */
 	size_t nr_pages;
 
-#define KBASE_REG_FREE       (1ul << 0)	/* Free region */
-#define KBASE_REG_CPU_WR     (1ul << 1)	/* CPU write access */
-#define KBASE_REG_GPU_WR     (1ul << 2)	/* GPU write access */
-#define KBASE_REG_GPU_NX     (1ul << 3)	/* No eXecute flag */
-#define KBASE_REG_CPU_CACHED (1ul << 4)	/* Is CPU cached? */
-#define KBASE_REG_GPU_CACHED (1ul << 5)	/* Is GPU cached? */
-
-#define KBASE_REG_GROWABLE   (1ul << 6)
-#define KBASE_REG_PF_GROW    (1ul << 7)	/* Can grow on pf? */
-
-#define KBASE_REG_CUSTOM_VA  (1ul << 8) /* VA managed by us */
-
-#define KBASE_REG_SHARE_IN   (1ul << 9)	/* inner shareable coherency */
-#define KBASE_REG_SHARE_BOTH (1ul << 10)	/* inner & outer shareable coherency */
-
-#define KBASE_REG_ZONE_MASK  (3ul << 11)	/* Space for 4 different zones */
-#define KBASE_REG_ZONE(x)    (((x) & 3) << 11)
-
-#define KBASE_REG_GPU_RD     (1ul<<13)	/* GPU write access */
-#define KBASE_REG_CPU_RD     (1ul<<14)	/* CPU read access */
-
-#define KBASE_REG_ALIGNED    (1ul<<15) /* Aligned for GPU EX in SAME_VA */
-
-#define KBASE_REG_FLAGS_NR_BITS    16	/* Number of bits used by kbase_va_region flags */
-
-#define KBASE_REG_ZONE_SAME_VA  KBASE_REG_ZONE(0)
+/* Free region */
+#define KBASE_REG_FREE              (1ul << 0)
+/* CPU write access */
+#define KBASE_REG_CPU_WR            (1ul << 1)
+/* GPU write access */
+#define KBASE_REG_GPU_WR            (1ul << 2)
+/* No eXecute flag */
+#define KBASE_REG_GPU_NX            (1ul << 3)
+/* Is CPU cached? */
+#define KBASE_REG_CPU_CACHED        (1ul << 4)
+/* Is GPU cached? */
+#define KBASE_REG_GPU_CACHED        (1ul << 5)
+
+#define KBASE_REG_GROWABLE          (1ul << 6)
+/* Can grow on pf? */
+#define KBASE_REG_PF_GROW           (1ul << 7)
+
+/* VA managed by us */
+#define KBASE_REG_CUSTOM_VA         (1ul << 8)
+
+/* inner shareable coherency */
+#define KBASE_REG_SHARE_IN          (1ul << 9)
+/* inner & outer shareable coherency */
+#define KBASE_REG_SHARE_BOTH        (1ul << 10)
+
+/* Space for 4 different zones */
+#define KBASE_REG_ZONE_MASK         (3ul << 11)
+#define KBASE_REG_ZONE(x)           (((x) & 3) << 11)
+
+/* GPU read access */
+#define KBASE_REG_GPU_RD            (1ul<<13)
+/* CPU read access */
+#define KBASE_REG_CPU_RD            (1ul<<14)
+
+/* Aligned for GPU EX in SAME_VA */
+#define KBASE_REG_ALIGNED           (1ul<<15)
+
+/* Index of chosen MEMATTR for this region (0..7) */
+#define KBASE_REG_MEMATTR_MASK      (7ul << 16)
+#define KBASE_REG_MEMATTR_INDEX(x)  (((x) & 7) << 16)
+#define KBASE_REG_MEMATTR_VALUE(x)  (((x) & KBASE_REG_MEMATTR_MASK) >> 16)
+
+#define KBASE_REG_ZONE_SAME_VA      KBASE_REG_ZONE(0)
 
 /* only used with 32-bit clients */
 /*
@@ -191,19 +246,6 @@ typedef struct kbase_va_region {
 #define KBASE_REG_ZONE_CUSTOM_VA_SIZE    (((1ULL << 44) >> PAGE_SHIFT) - KBASE_REG_ZONE_CUSTOM_VA_BASE)
 /* end 32-bit clients only */
 
-#define KBASE_REG_COOKIE_MASK       (~((1ul << KBASE_REG_FLAGS_NR_BITS)-1))
-#define KBASE_REG_COOKIE(x)         ((x << KBASE_REG_FLAGS_NR_BITS) & KBASE_REG_COOKIE_MASK)
-
-/* The reserved cookie values */
-#define KBASE_REG_COOKIE_RB         0
-#define KBASE_REG_COOKIE_MMU_DUMP   1
-#define KBASE_REG_COOKIE_TB         2
-#define KBASE_REG_COOKIE_MTP        3
-#define KBASE_REG_COOKIE_FIRST_FREE 4
-
-/* Bit mask of cookies reserved for other uses */
-#define KBASE_REG_RESERVED_COOKIES  ((1ULL << (KBASE_REG_COOKIE_FIRST_FREE))-1)
-
 	unsigned long flags;
 
 	size_t extent; /* nr of pages alloc'd on PF */
@@ -248,6 +290,7 @@ static INLINE struct kbase_mem_phy_alloc * kbase_alloc_create(size_t nr_pages, e
 		return ERR_PTR(-ENOMEM);
 
 	kref_init(&alloc->kref);
+	atomic_set(&alloc->gpu_mappings, 0);
 	alloc->nents = 0;
 	alloc->pages = (void*)(alloc + 1);
 	INIT_LIST_HEAD(&alloc->mappings);
@@ -272,8 +315,23 @@ static INLINE int kbase_reg_prepare_native(struct kbase_va_region * reg, struct
 	return 0;
 }
 
+static inline int kbase_atomic_add_pages(int num_pages, atomic_t *used_pages)
+{
+	int new_val = atomic_add_return(num_pages, used_pages);
+#ifdef CONFIG_MALI_GATOR_SUPPORT
+	kbase_trace_mali_total_alloc_pages_change((long long int)new_val);
+#endif
+	return new_val;
+}
 
-
+static inline int kbase_atomic_sub_pages(int num_pages, atomic_t *used_pages)
+{
+	int new_val = atomic_sub_return(num_pages, used_pages);
+#ifdef CONFIG_MALI_GATOR_SUPPORT
+	kbase_trace_mali_total_alloc_pages_change((long long int)new_val);
+#endif
+	return new_val;
+}
 
 /**
  * @brief Initialize an OS based memory allocator.
@@ -323,47 +381,7 @@ void kbase_mem_allocator_free(kbase_mem_allocator * allocator, size_t nr_pages,
  */
 void kbase_mem_allocator_term(kbase_mem_allocator * allocator);
 
-/**
- * @brief Initializes memory context which tracks memory usage.
- *
- * Function initializes memory context with given max_pages value.
- *
- * @param[in]   usage      usage tracker
- * @param[in]   max_pages  maximum pages allowed to be allocated within this memory context
- *
- * @return  MALI_ERROR_NONE in case of error. Error code otherwise.
- */
-mali_error kbase_mem_usage_init(kbasep_mem_usage *usage, size_t max_pages);
-
-/*
- * @brief Terminates given memory context
- *
- * @param[in]    usage  usage tracker
- *
- * @return MALI_ERROR_NONE in case of error. Error code otherwise.
- */
-void kbase_mem_usage_term(kbasep_mem_usage *usage);
-
-/*
- * @brief Requests a number of pages from the given context.
- *
- * Function requests a number of pages from the given context. Context is updated only if it contains enough number of
- * free pages. Otherwise function returns error and no pages are claimed.
- *
- * @param[in]    usage     usage tracker
- * @param[in]    nr_pages  number of pages requested
- *
- * @return  MALI_ERROR_NONE when context page request succeeded. Error code otherwise.
- */
-mali_error kbase_mem_usage_request_pages(kbasep_mem_usage *usage, size_t nr_pages);
 
-/*
- * @brief Release a number of pages from the given context.
- *
- * @param[in]    usage     usage tracker
- * @param[in]    nr_pages  number of pages to be released
- */
-void kbase_mem_usage_release_pages(kbasep_mem_usage *usage, size_t nr_pages);
 
 mali_error kbase_region_tracker_init(kbase_context *kctx);
 void kbase_region_tracker_term(kbase_context *kctx);
@@ -397,7 +415,13 @@ void kbase_mmu_term(kbase_context *kctx);
 
 phys_addr_t kbase_mmu_alloc_pgd(kbase_context *kctx);
 void kbase_mmu_free_pgd(kbase_context *kctx);
-mali_error kbase_mmu_insert_pages(kbase_context *kctx, u64 vpfn, phys_addr_t *phys, size_t nr, unsigned long flags);
+mali_error kbase_mmu_insert_pages(kbase_context *kctx, u64 vpfn,
+				  phys_addr_t *phys, size_t nr,
+				  unsigned long flags);
+mali_error kbase_mmu_insert_single_page(kbase_context *kctx, u64 vpfn,
+					phys_addr_t phys, size_t nr,
+					unsigned long flags);
+
 mali_error kbase_mmu_teardown_pages(kbase_context *kctx, u64 vpfn, size_t nr);
 mali_error kbase_mmu_update_pages(kbase_context* kctx, u64 vpfn, phys_addr_t* phys, size_t nr, unsigned long flags);
 
@@ -459,7 +483,7 @@ void kbase_post_job_sync(kbase_context *kctx, base_syncset *syncsets, size_t nr)
  * of imported external memory
  *
  * @param[in]  kctx  	    The kbase context which the tmem belongs to
- * @param[in]  gpu_addr     The base address of the tmem region
+ * @param[in]  gpu_adr     The base address of the tmem region
  * @param[in]  attributes   The attributes of tmem region to be set
  *
  * @return MALI_ERROR_NONE on success.  Any other value indicates failure.
@@ -472,7 +496,7 @@ mali_error kbase_tmem_set_attributes(kbase_context *kctx, mali_addr64 gpu_adr, u
  * This function retrieves the attributes of imported external memory
  *
  * @param[in]  kctx  	    The kbase context which the tmem belongs to
- * @param[in]  gpu_addr     The base address of the tmem region
+ * @param[in]  gpu_adr     The base address of the tmem region
  * @param[out] attributes   The actual attributes of tmem region
  *
  * @return MALI_ERROR_NONE on success.  Any other value indicates failure.
@@ -480,8 +504,6 @@ mali_error kbase_tmem_set_attributes(kbase_context *kctx, mali_addr64 gpu_adr, u
 mali_error kbase_tmem_get_attributes(kbase_context *kctx, mali_addr64 gpu_adr, u32 * const attributes );
 
 /* OS specific functions */
-struct kbase_va_region *kbase_lookup_cookie(kbase_context *kctx, mali_addr64 cookie);
-void kbase_unlink_cookie(kbase_context *kctx, mali_addr64 cookie, struct kbase_va_region *reg);
 mali_error kbase_mem_free(kbase_context *kctx, mali_addr64 gpu_addr);
 mali_error kbase_mem_free_region(kbase_context *kctx, struct kbase_va_region *reg);
 void kbase_os_mem_map_lock(kbase_context *kctx);
@@ -493,6 +515,7 @@ void kbase_os_mem_map_unlock(kbase_context *kctx);
  * OS specific call to updates the current memory allocation counters for the current process with
  * the supplied delta.
  *
+ * @param[in] kctx  The kbase context 
  * @param[in] pages The desired delta to apply to the memory usage counters.
  */
 
@@ -529,23 +552,31 @@ static INLINE void kbase_process_page_usage_dec( struct kbase_context *kctx, int
 }
 
 /**
- * @brief Find a CPU mapping of a memory allocation containing a given address range
+ * @brief Find the offset of the CPU mapping of a memory allocation containing
+ *        a given address range
  *
- * Searches for a CPU mapping of any part of the region starting at @p gpu_addr that
- * fully encloses the CPU virtual address range specified by @p uaddr and @p size.
- * Returns a failure indication if only part of the address range lies within a
- * CPU mapping, or the address range lies within a CPU mapping of a different region.
+ * Searches for a CPU mapping of any part of the region starting at @p gpu_addr
+ * that fully encloses the CPU virtual address range specified by @p uaddr and
+ * @p size. Returns a failure indication if only part of the address range lies
+ * within a CPU mapping, or the address range lies within a CPU mapping of a
+ * different region.
  *
  * @param[in,out] kctx      The kernel base context used for the allocation.
  * @param[in]     gpu_addr  GPU address of the start of the allocated region
  *                          within which to search.
  * @param[in]     uaddr     Start of the CPU virtual address range.
  * @param[in]     size      Size of the CPU virtual address range (in bytes).
+ * @param[out]    offset    The offset from the start of the allocation to the
+ *                          specified CPU virtual address.
  *
- * @return A pointer to a descriptor of the CPU mapping that fully encloses
- *         the specified address range, or NULL if none was found.
+ * @return MALI_ERROR_NONE if offset was obtained successfully. Error code
+ *         otherwise.
  */
-struct kbase_cpu_mapping *kbasep_find_enclosing_cpu_mapping(kbase_context *kctx, mali_addr64 gpu_addr, unsigned long uaddr, size_t size);
+mali_error kbasep_find_enclosing_cpu_mapping_offset(kbase_context *kctx,
+							mali_addr64 gpu_addr,
+							unsigned long uaddr,
+							size_t size,
+							mali_size64 *offset);
 
 enum hrtimer_restart kbasep_as_poke_timer_callback(struct hrtimer *timer);
 void kbase_as_poking_timer_retain_atom(kbase_device *kbdev, kbase_context *kctx, kbase_jd_atom *katom);
@@ -557,7 +588,7 @@ void kbase_as_poking_timer_release_atom(kbase_device *kbdev, kbase_context *kctx
 * Allocates \a nr_pages_requested and updates the alloc object.
 *
 * @param[in] alloc allocation object to add pages to
-* @param[in] nr_pages number of physical pages to allocate
+* @param[in] nr_pages_requested number of physical pages to allocate
 *
 * @return 0 if all pages have been successfully allocated. Error code otherwise
 */
@@ -569,7 +600,7 @@ int kbase_alloc_phy_pages_helper(struct kbase_mem_phy_alloc * alloc, size_t nr_p
 * Frees \a nr_pages and updates the alloc object.
 *
 * @param[in] alloc allocation object to free pages from
-* @param[in] nr_pages number of physical pages to free
+* @param[in] nr_pages_to_free number of physical pages to free
 */
 int kbase_free_phy_pages_helper(struct kbase_mem_phy_alloc * alloc, size_t nr_pages_to_free);
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_alloc.c b/drivers/gpu/arm/midgard/mali_kbase_mem_alloc.c
old mode 100644
new mode 100755
similarity index 99%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_alloc.c
rename to drivers/gpu/arm/midgard/mali_kbase_mem_alloc.c
index 5fd9f1f2f015..f05320087b65
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_alloc.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem_alloc.c
@@ -21,7 +21,7 @@
  * @file mali_kbase_mem.c
  * Base kernel memory APIs
  */
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 #include <linux/highmem.h>
 #include <linux/mempool.h>
 #include <linux/mm.h>
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_alloc.h b/drivers/gpu/arm/midgard/mali_kbase_mem_alloc.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_alloc.h
rename to drivers/gpu/arm/midgard/mali_kbase_mem_alloc.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_mem_linux.c b/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c
old mode 100644
new mode 100755
similarity index 72%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_mem_linux.c
rename to drivers/gpu/arm/midgard/mali_kbase_mem_linux.c
index 92f8fa73ac31..39c909904dc9
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_mem_linux.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c
@@ -36,10 +36,12 @@
 #include <linux/dma-buf.h>
 #endif				/* defined(CONFIG_DMA_SHARED_BUFFER) */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/linux/mali_kbase_mem_linux.h>
+#include <mali_kbase.h>
+#include <mali_kbase_mem_linux.h>
+#include <mali_kbase_config_defaults.h>
 
 static int kbase_tracking_page_setup(struct kbase_context *kctx, struct vm_area_struct *vma);
+static const struct vm_operations_struct kbase_vm_ops;
 
 struct kbase_va_region *kbase_mem_alloc(kbase_context *kctx, u64 va_pages, u64 commit_pages, u64 extent, u64 *flags, u64 *gpu_va, u16 *va_alignment)
 {
@@ -47,11 +49,13 @@ struct kbase_va_region *kbase_mem_alloc(kbase_context *kctx, u64 va_pages, u64 c
 	int gpu_pc_bits;
 	int cpu_va_bits;
 	struct kbase_va_region *reg;
+	struct device *dev;
 	KBASE_DEBUG_ASSERT(kctx);
 	KBASE_DEBUG_ASSERT(flags);
 	KBASE_DEBUG_ASSERT(gpu_va);
 	KBASE_DEBUG_ASSERT(va_alignment);
 
+	dev = kctx->kbdev->dev;
 	*va_alignment = 0; /* no alignment by default */
 	*gpu_va = 0; /* return 0 on failure */
 
@@ -59,8 +63,7 @@ struct kbase_va_region *kbase_mem_alloc(kbase_context *kctx, u64 va_pages, u64 c
 	cpu_va_bits = BITS_PER_LONG;
 
 	if (0 == va_pages) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MEM,
-				"kbase_mem_alloc called with 0 va_pages!");
+		dev_warn(dev, "kbase_mem_alloc called with 0 va_pages!");
 		goto zero_size;
 	}
 
@@ -73,7 +76,7 @@ struct kbase_va_region *kbase_mem_alloc(kbase_context *kctx, u64 va_pages, u64 c
 #endif
 
 	if (!kbase_check_alloc_flags(*flags)) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MEM,
+		dev_warn(dev,
 				"kbase_mem_alloc called with bad flags (%llx)",
 				(unsigned long long)*flags);
 		goto bad_flags;
@@ -94,13 +97,12 @@ struct kbase_va_region *kbase_mem_alloc(kbase_context *kctx, u64 va_pages, u64 c
 
 	reg = kbase_alloc_free_region(kctx, 0, va_pages, zone);
 	if (!reg) {
-		KBASE_DEBUG_PRINT_ERROR(KBASE_MEM,
-					 "Failed to allocate free region");
+		dev_err(dev, "Failed to allocate free region");
 		goto no_region;
 	}
 
 	if (MALI_ERROR_NONE != kbase_reg_prepare_native(reg, kctx)) {
-		KBASE_DEBUG_PRINT_ERROR(KBASE_MEM, "Failed to prepare region");
+		dev_err(dev, "Failed to prepare region");
 		goto prepare_failed;
 	}
 
@@ -112,8 +114,8 @@ struct kbase_va_region *kbase_mem_alloc(kbase_context *kctx, u64 va_pages, u64 c
 		reg->extent = 0;
 
 	if (kbase_alloc_phy_pages(reg, va_pages, commit_pages)) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Failed to allocate %lld pages (va_pages=%lld)", 
-		                       (unsigned long long)commit_pages, (unsigned long long)va_pages);
+		dev_warn(dev, "Failed to allocate %lld pages (va_pages=%lld)", 
+		              (unsigned long long)commit_pages, (unsigned long long)va_pages);
 		goto no_mem;
 	}
 
@@ -122,16 +124,19 @@ struct kbase_va_region *kbase_mem_alloc(kbase_context *kctx, u64 va_pages, u64 c
 	/* mmap needed to setup VA? */
 	if (*flags & BASE_MEM_SAME_VA) {
 		/* Bind to a cookie */
-		if (!kctx->osctx.cookies) {
-			KBASE_DEBUG_PRINT_ERROR(KBASE_MEM, "No cookies available for allocation!");
+		if (!kctx->cookies) {
+			dev_err(dev, "No cookies available for allocation!");
 			goto no_cookie;
 		}
 		/* return a cookie */
-		*gpu_va = __ffs(kctx->osctx.cookies);
-		kctx->osctx.cookies &= ~(1UL << *gpu_va);
-		reg->flags &= ~KBASE_REG_COOKIE_MASK;
-		reg->flags |= KBASE_REG_COOKIE(*gpu_va);
-		list_add(&reg->link, &kctx->osctx.reg_pending);
+		*gpu_va = __ffs(kctx->cookies);
+		kctx->cookies &= ~(1UL << *gpu_va);
+		BUG_ON(kctx->pending_regions[*gpu_va]);
+		kctx->pending_regions[*gpu_va] = reg;
+
+		/* relocate to correct base */
+		*gpu_va += PFN_DOWN(BASE_MEM_COOKIE_BASE);
+		*gpu_va <<= PAGE_SHIFT;
 
 		/* See if we must align memory due to GPU PC bits vs CPU VA */
 		if ((*flags & BASE_MEM_PROT_GPU_EX) &&
@@ -141,7 +146,7 @@ struct kbase_va_region *kbase_mem_alloc(kbase_context *kctx, u64 va_pages, u64 c
 		}
 	} else /* we control the VA */ {
 		if (MALI_ERROR_NONE != kbase_gpu_mmap(kctx, reg, 0, va_pages, 1)) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MEM, "Failed to map memory on GPU");
+			dev_warn(dev, "Failed to map memory on GPU");
 			goto no_mmap;
 		}
 		/* return real GPU VA */
@@ -182,7 +187,16 @@ mali_error kbase_mem_query(kbase_context *kctx, mali_addr64 gpu_addr, int query,
 
 	switch (query) {
 		case KBASE_MEM_QUERY_COMMIT_SIZE:
-			*out = reg->alloc->nents;
+			if (reg->alloc->type != KBASE_MEM_TYPE_ALIAS) {
+				*out = kbase_reg_current_backed_size(reg);
+			} else {
+				size_t i;
+				struct kbase_aliased *aliased;
+				*out = 0;
+				aliased = reg->alloc->imported.alias.aliased;
+				for (i = 0; i < reg->alloc->imported.alias.nents; i++)
+					*out += aliased[i].length;
+			}
 			break;
 		case KBASE_MEM_QUERY_VA_SIZE:
 			*out = reg->nr_pages;
@@ -322,7 +336,8 @@ static struct kbase_va_region *kbase_mem_from_ump(kbase_context *kctx, ump_secur
 
 	ump_flags = ump_dd_allocation_flags_get(umph);
 	cpu_flags = (ump_flags >> UMP_DEVICE_CPU_SHIFT) & UMP_DEVICE_MASK;
-	gpu_flags = (ump_flags >> kctx->kbdev->memdev.ump_device_id) & UMP_DEVICE_MASK;
+	gpu_flags = (ump_flags >> DEFAULT_UMP_GPU_DEVICE_SHIFT) &
+			UMP_DEVICE_MASK;
 
 	*va_pages = ump_dd_size_get_64(umph);
 	*va_pages >>= PAGE_SHIFT;
@@ -351,23 +366,35 @@ static struct kbase_va_region *kbase_mem_from_ump(kbase_context *kctx, ump_secur
 	reg->flags |= KBASE_REG_GPU_NX;	/* UMP is always No eXecute */
 	reg->flags &= ~KBASE_REG_GROWABLE;	/* UMP cannot be grown */
 
-	if ((cpu_flags & (UMP_HINT_DEVICE_RD | UMP_HINT_DEVICE_WR)) == (UMP_HINT_DEVICE_RD | UMP_HINT_DEVICE_WR))
+	if ((cpu_flags & (UMP_HINT_DEVICE_RD | UMP_HINT_DEVICE_WR)) ==
+	    (UMP_HINT_DEVICE_RD | UMP_HINT_DEVICE_WR)) {
 		reg->flags |= KBASE_REG_CPU_CACHED;
+		*flags |= BASE_MEM_CACHED_CPU;
+	}
 
-	if (cpu_flags & UMP_PROT_DEVICE_WR)
+	if (cpu_flags & UMP_PROT_DEVICE_WR) {
 		reg->flags |= KBASE_REG_CPU_WR;
+		*flags |= BASE_MEM_PROT_CPU_WR;
+	}
 
-	if (cpu_flags & UMP_PROT_DEVICE_RD)
+	if (cpu_flags & UMP_PROT_DEVICE_RD) {
 		reg->flags |= KBASE_REG_CPU_RD;
+		*flags |= BASE_MEM_PROT_CPU_RD;
+	}
 
-	if ((gpu_flags & (UMP_HINT_DEVICE_RD | UMP_HINT_DEVICE_WR)) == (UMP_HINT_DEVICE_RD | UMP_HINT_DEVICE_WR))
+	if ((gpu_flags & (UMP_HINT_DEVICE_RD | UMP_HINT_DEVICE_WR)) ==
+	    (UMP_HINT_DEVICE_RD | UMP_HINT_DEVICE_WR))
 		reg->flags |= KBASE_REG_GPU_CACHED;
 
-	if (gpu_flags & UMP_PROT_DEVICE_WR)
+	if (gpu_flags & UMP_PROT_DEVICE_WR) {
 		reg->flags |= KBASE_REG_GPU_WR;
+		*flags |= BASE_MEM_PROT_GPU_WR;
+	}
 
-	if (gpu_flags & UMP_PROT_DEVICE_RD)
+	if (gpu_flags & UMP_PROT_DEVICE_RD) {
 		reg->flags |= KBASE_REG_GPU_RD;
+		*flags |= BASE_MEM_PROT_GPU_RD;
+	}
 
 	/* ump phys block query */
 	ump_dd_phys_blocks_get_64(umph, &block_count, &block_array);
@@ -405,7 +432,7 @@ static struct kbase_va_region *kbase_mem_from_umm(kbase_context *kctx, int fd, u
 	if (IS_ERR_OR_NULL(dma_buf))
 		goto no_buf;
 
-	dma_attachment = dma_buf_attach(dma_buf, kctx->kbdev->osdev.dev);
+	dma_attachment = dma_buf_attach(dma_buf, kctx->kbdev->dev);
 	if (!dma_attachment)
 		goto no_attachment;
 
@@ -419,7 +446,7 @@ static struct kbase_va_region *kbase_mem_from_umm(kbase_context *kctx, int fd, u
 #ifdef CONFIG_64BIT
 	if (!is_compat_task()) {
 		/* 64-bit tasks must MMAP anyway, but not expose this address to clients */
-		*flags |= KBASE_MEM_IMPORT_MMAP;
+		*flags |= KBASE_MEM_NEED_MMAP;
 		reg = kbase_alloc_free_region(kctx, 0, *va_pages, KBASE_REG_ZONE_SAME_VA);
 	} else {
 #else
@@ -435,13 +462,26 @@ static struct kbase_va_region *kbase_mem_from_umm(kbase_context *kctx, int fd, u
 	if (IS_ERR_OR_NULL(reg->alloc))
 		goto no_alloc_obj;
 
-	reg->alloc->nents = *va_pages;
+	/* No pages to map yet */
+	reg->alloc->nents = 0;
 
 	reg->flags &= ~KBASE_REG_FREE;
 	reg->flags |= KBASE_REG_GPU_NX;	/* UMM is always No eXecute */
 	reg->flags &= ~KBASE_REG_GROWABLE;	/* UMM cannot be grown */
 	reg->flags |= KBASE_REG_GPU_CACHED;
 
+	if (*flags & BASE_MEM_PROT_CPU_WR)
+		reg->flags |= KBASE_REG_CPU_WR;
+
+	if (*flags & BASE_MEM_PROT_CPU_RD)
+		reg->flags |= KBASE_REG_CPU_RD;
+
+	if (*flags & BASE_MEM_PROT_GPU_WR)
+		reg->flags |= KBASE_REG_GPU_WR;
+
+	if (*flags & BASE_MEM_PROT_GPU_RD)
+		reg->flags |= KBASE_REG_GPU_RD;
+
 	/* no read or write permission given on import, only on run do we give the right permissions */
 
 	reg->alloc->type = BASE_TMEM_IMPORT_TYPE_UMM;
@@ -465,6 +505,175 @@ static struct kbase_va_region *kbase_mem_from_umm(kbase_context *kctx, int fd, u
 }
 #endif  /* CONFIG_DMA_SHARED_BUFFER */
 
+u64 kbase_mem_alias(kbase_context *kctx, u64 *flags, u64 stride,
+		    u64 nents, struct base_mem_aliasing_info *ai,
+		    u64 *num_pages)
+{
+	kbase_va_region *reg;
+	u64 gpu_va;
+	size_t i;
+
+	KBASE_DEBUG_ASSERT(kctx);
+	KBASE_DEBUG_ASSERT(flags);
+	KBASE_DEBUG_ASSERT(ai);
+	KBASE_DEBUG_ASSERT(num_pages);
+
+	/* mask to only allowed flags */
+	*flags &= (BASE_MEM_PROT_GPU_RD | BASE_MEM_PROT_GPU_WR |
+		   BASE_MEM_HINT_GPU_RD | BASE_MEM_HINT_GPU_WR |
+		   BASE_MEM_COHERENT_SYSTEM | BASE_MEM_COHERENT_LOCAL);
+
+	if (!(*flags & (BASE_MEM_PROT_GPU_RD | BASE_MEM_PROT_GPU_WR) )) {
+		dev_warn(kctx->kbdev->dev,
+				"kbase_mem_alias called with bad flags (%llx)",
+				(unsigned long long)*flags);
+		goto bad_flags;
+	}
+
+	if (!stride)
+		goto bad_stride;
+
+	if (!nents)
+		goto bad_nents;
+
+	/* calculate the number of pages this alias will cover */
+	*num_pages = nents * stride;
+
+#ifdef CONFIG_64BIT
+	if (!is_compat_task()) {
+		/* 64-bit tasks must MMAP anyway, but not expose this address to
+		 * clients */
+		*flags |= KBASE_MEM_NEED_MMAP;
+		reg = kbase_alloc_free_region(kctx, 0, *num_pages,
+					      KBASE_REG_ZONE_SAME_VA);
+	} else {
+#else
+	if (1) {
+#endif
+		reg = kbase_alloc_free_region(kctx, 0, *num_pages,
+					      KBASE_REG_ZONE_CUSTOM_VA);
+	}
+
+	if (!reg)
+		goto no_reg;
+
+	/* zero-sized page array, as we don't need one/can support one */
+	reg->alloc = kbase_alloc_create(0, KBASE_MEM_TYPE_ALIAS);
+	if (IS_ERR_OR_NULL(reg->alloc))
+		goto no_alloc_obj;
+
+	kbase_update_region_flags(reg, *flags);
+
+	reg->alloc->imported.alias.nents = nents;
+	reg->alloc->imported.alias.stride = stride;
+	reg->alloc->imported.alias.aliased = vzalloc(sizeof(*reg->alloc->imported.alias.aliased) * nents);
+	if (!reg->alloc->imported.alias.aliased)
+		goto no_aliased_array;
+
+	kbase_gpu_vm_lock(kctx);
+
+	/* validate and add src handles */
+	for (i = 0; i < nents; i++) {
+		if (ai[i].handle < BASE_MEM_FIRST_FREE_ADDRESS) {
+			if (ai[i].handle != BASE_MEM_WRITE_ALLOC_PAGES_HANDLE)
+				goto bad_handle; /* unsupported magic handle */
+			if (!ai[i].length)
+				goto bad_handle; /* must be > 0 */
+			if (ai[i].length > stride)
+				goto bad_handle; /* can't be larger than the
+						    stride */
+			reg->alloc->imported.alias.aliased[i].length = ai[i].length;
+		} else {
+			struct kbase_va_region *aliasing_reg;
+			struct kbase_mem_phy_alloc *alloc;
+			aliasing_reg = kbase_region_tracker_find_region_base_address(kctx, (ai[i].handle >> PAGE_SHIFT) << PAGE_SHIFT);
+
+			/* validate found region */
+			if (!aliasing_reg)
+				goto bad_handle; /* Not found */
+			if (aliasing_reg->flags & KBASE_REG_FREE)
+				goto bad_handle; /* Free region */
+			if (!aliasing_reg->alloc)
+				goto bad_handle; /* No alloc */
+			if (aliasing_reg->alloc->type != KBASE_MEM_TYPE_NATIVE)
+				goto bad_handle; /* Not a native alloc */
+
+			/* check size against stride */
+			if (!ai[i].length)
+				goto bad_handle; /* must be > 0 */
+			if (ai[i].length > stride)
+				goto bad_handle; /* can't be larger than the
+						    stride */
+
+			alloc = aliasing_reg->alloc;
+
+			/* check against the alloc's size */
+			if (ai[i].offset > alloc->nents)
+				goto bad_handle; /* beyond end */
+			if (ai[i].offset + ai[i].length > alloc->nents)
+				goto bad_handle; /* beyond end */
+
+			reg->alloc->imported.alias.aliased[i].alloc = kbase_mem_phy_alloc_get(alloc);
+			reg->alloc->imported.alias.aliased[i].length = ai[i].length;
+			reg->alloc->imported.alias.aliased[i].offset = ai[i].offset;
+		}
+	}
+
+#ifdef CONFIG_64BIT
+	if (!is_compat_task()) {
+		/* Bind to a cookie */
+		if (!kctx->cookies) {
+			dev_err(kctx->kbdev->dev, "No cookies "
+						"available for allocation!");
+			goto no_cookie;
+		}
+		/* return a cookie */
+		gpu_va = __ffs(kctx->cookies);
+		kctx->cookies &= ~(1UL << gpu_va);
+		BUG_ON(kctx->pending_regions[gpu_va]);
+		kctx->pending_regions[gpu_va] = reg;
+
+		/* relocate to correct base */
+		gpu_va += PFN_DOWN(BASE_MEM_COOKIE_BASE);
+		gpu_va <<= PAGE_SHIFT;
+	} else /* we control the VA */ {
+#else
+	if (1) {
+#endif
+		if (MALI_ERROR_NONE != kbase_gpu_mmap(kctx, reg, 0,
+						      *num_pages, 1)) {
+			dev_warn(kctx->kbdev->dev,
+					       "Failed to map memory on GPU");
+			goto no_mmap;
+		}
+		/* return real GPU VA */
+		gpu_va = reg->start_pfn << PAGE_SHIFT;
+	}
+
+	reg->flags &= ~KBASE_REG_FREE;
+	reg->flags &= ~KBASE_REG_GROWABLE;
+
+	kbase_gpu_vm_unlock(kctx);
+
+	return gpu_va;
+
+#ifdef CONFIG_64BIT
+no_cookie:
+#endif
+no_mmap:
+bad_handle:
+	kbase_gpu_vm_unlock(kctx);
+no_aliased_array:
+	kbase_mem_phy_alloc_put(reg->alloc);
+no_alloc_obj:
+	kfree(reg);
+no_reg:
+bad_nents:
+bad_stride:
+bad_flags:
+	return 0;
+}
+
 int kbase_mem_import(kbase_context *kctx, base_mem_import_type type, int handle, mali_addr64 * gpu_va, u64 * va_pages, u64 * flags)
 {
 	kbase_va_region * reg;
@@ -501,16 +710,20 @@ int kbase_mem_import(kbase_context *kctx, base_mem_import_type type, int handle,
 	kbase_gpu_vm_lock(kctx);
 
 	/* mmap needed to setup VA? */
-	if (*flags & (BASE_MEM_SAME_VA | KBASE_MEM_IMPORT_MMAP)) {
+	if (*flags & (BASE_MEM_SAME_VA | KBASE_MEM_NEED_MMAP)) {
 		/* Bind to a cookie */
-		if (!kctx->osctx.cookies)
+		if (!kctx->cookies)
 			goto no_cookie;
 		/* return a cookie */
-		*gpu_va = __ffs(kctx->osctx.cookies);
-		kctx->osctx.cookies &= ~(1UL << *gpu_va);
-		reg->flags &= ~KBASE_REG_COOKIE_MASK;
-		reg->flags |= KBASE_REG_COOKIE(*gpu_va);
-		list_add(&reg->link, &kctx->osctx.reg_pending);
+		*gpu_va = __ffs(kctx->cookies);
+		kctx->cookies &= ~(1UL << *gpu_va);
+		BUG_ON(kctx->pending_regions[*gpu_va]);
+		kctx->pending_regions[*gpu_va] = reg;
+
+		/* relocate to correct base */
+		*gpu_va += PFN_DOWN(BASE_MEM_COOKIE_BASE);
+		*gpu_va <<= PAGE_SHIFT;
+
 	} else if (*flags & KBASE_MEM_IMPORT_HAVE_PAGES)  {
 		/* we control the VA, mmap now to the GPU */
 		if (MALI_ERROR_NONE != kbase_gpu_mmap(kctx, reg, 0, *va_pages, 1))
@@ -542,6 +755,42 @@ int kbase_mem_import(kbase_context *kctx, base_mem_import_type type, int handle,
 }
 
 
+
+static int zap_range_nolock(struct mm_struct *mm,
+		const struct vm_operations_struct *vm_ops,
+		unsigned long start, unsigned long end)
+{
+	struct vm_area_struct *vma;
+	int err = -EINVAL; /* in case end < start */
+
+	while (start < end) {
+		unsigned long local_end;
+
+		vma = find_vma_intersection(mm, start, end);
+		if (!vma)
+			break;
+
+		/* is it ours? */
+		if (vma->vm_ops != vm_ops)
+			goto try_next;
+
+		local_end = vma->vm_end;
+
+		if (end < local_end)
+			local_end = end;
+
+		err = zap_vma_ptes(vma, start, local_end - start);
+		if (unlikely(err))
+			break;
+
+try_next:
+		/* go to next vma, if any */
+		start = vma->vm_end;
+	}
+
+	return err;
+}
+
 int kbase_mem_commit(kbase_context * kctx, mali_addr64 gpu_addr, u64 new_pages, base_backing_threshold_status * failure_reason)
 {
 	u64 old_pages;
@@ -554,6 +803,7 @@ int kbase_mem_commit(kbase_context * kctx, mali_addr64 gpu_addr, u64 new_pages,
 	KBASE_DEBUG_ASSERT(failure_reason);
 	KBASE_DEBUG_ASSERT(gpu_addr != 0);
 
+	down_read(&current->mm->mmap_sem);
 	kbase_gpu_vm_lock(kctx);
 
 	/* Validate the region */
@@ -581,6 +831,12 @@ int kbase_mem_commit(kbase_context * kctx, mali_addr64 gpu_addr, u64 new_pages,
 		goto out_unlock;
 	}
 
+	/* can't be mapped more than once on the GPU */
+	if (atomic_read(&reg->alloc->gpu_mappings) > 1) {
+		*failure_reason = BASE_BACKING_THRESHOLD_ERROR_NOT_GROWABLE;
+		goto out_unlock;
+	}
+
 	if (new_pages == reg->alloc->nents) {
 		/* no change */
 		res = 0;
@@ -612,8 +868,7 @@ int kbase_mem_commit(kbase_context * kctx, mali_addr64 gpu_addr, u64 new_pages,
 
 		/* first, unmap from any mappings affected */
 		list_for_each_entry(mapping, &reg->alloc->mappings, mappings_list) {
-			struct vm_area_struct * vma = mapping->vma;
-			unsigned long mapping_size = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+			unsigned long mapping_size = (mapping->vm_end - mapping->vm_start) >> PAGE_SHIFT;
 
 			/* is this mapping affected ?*/
 			if ((mapping->page_off + mapping_size) > new_pages) {
@@ -623,8 +878,17 @@ int kbase_mem_commit(kbase_context * kctx, mali_addr64 gpu_addr, u64 new_pages,
 				if (new_pages > mapping->page_off)
 					first_bad = new_pages - mapping->page_off;
 
-				zap_res = zap_vma_ptes(vma, vma->vm_start + (first_bad << PAGE_SHIFT), (mapping_size - first_bad) << PAGE_SHIFT);
-				WARN(zap_res, "Failed to zap vma %p (0x%lx - 0x%lx), tried %ld pages from 0x%lx\n", vma, vma->vm_start, vma->vm_end, (mapping_size - first_bad), vma->vm_start + (first_bad << PAGE_SHIFT));
+				zap_res = zap_range_nolock(current->mm,
+						&kbase_vm_ops,
+						mapping->vm_start +
+						(first_bad << PAGE_SHIFT),
+						mapping->vm_end);
+				WARN(zap_res,
+				     "Failed to zap VA range (0x%lx -0x%lx);\n",
+				     mapping->vm_start +
+				     (first_bad << PAGE_SHIFT),
+				     mapping->vm_end
+				     );
 			}
 		}
 
@@ -648,6 +912,7 @@ int kbase_mem_commit(kbase_context * kctx, mali_addr64 gpu_addr, u64 new_pages,
 
 out_unlock:
 	kbase_gpu_vm_unlock(kctx);
+	up_read(&current->mm->mmap_sem);
 
 	return res;
 
@@ -672,7 +937,6 @@ STATIC void kbase_cpu_vm_close(struct vm_area_struct *vma)
 	if (--map->count)
 		return;
 
-	KBASE_DEBUG_ASSERT(map->vma == vma);
 	KBASE_DEBUG_ASSERT(map->kctx);
 	KBASE_DEBUG_ASSERT(map->alloc);
 
@@ -701,22 +965,26 @@ STATIC int kbase_cpu_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 	size_t i;
 
 	KBASE_DEBUG_ASSERT(map);
-	KBASE_DEBUG_ASSERT(map->vma == vma);
 	KBASE_DEBUG_ASSERT(map->count > 0);
 	KBASE_DEBUG_ASSERT(map->kctx);
 	KBASE_DEBUG_ASSERT(map->alloc);
 
 	/* we don't use vmf->pgoff as it's affected by our mmap with offset being a GPU VA or a cookie */
-	rel_pgoff = ((unsigned long)vmf->virtual_address - vma->vm_start) >> PAGE_SHIFT;
+	rel_pgoff = ((unsigned long)vmf->virtual_address - map->vm_start) >> PAGE_SHIFT;
 
 	kbase_gpu_vm_lock(map->kctx);
 	if (map->page_off + rel_pgoff >= map->alloc->nents)
 		goto locked_bad_fault;
 
 	/* insert all valid pages from the fault location */
-	for (i = rel_pgoff; i < MIN((vma->vm_end - vma->vm_start) >> PAGE_SHIFT, map->alloc->nents - map->page_off); i++)
-		if (vm_insert_pfn(vma, vma->vm_start + (i << PAGE_SHIFT), PFN_DOWN(map->alloc->pages[map->page_off + i])))
+	for (i = rel_pgoff;
+			   i < MIN((vma->vm_end - vma->vm_start) >> PAGE_SHIFT,
+				     map->alloc->nents - map->page_off); i++) {
+		int ret = vm_insert_pfn(vma, map->vm_start + (i << PAGE_SHIFT),
+			       PFN_DOWN(map->alloc->pages[map->page_off + i]));
+		if (ret < 0 && ret != -EBUSY)
 			goto locked_bad_fault;
+	}
 
 	kbase_gpu_vm_unlock(map->kctx);
 	/* we resolved it, nothing for VM to do */
@@ -774,7 +1042,8 @@ static int kbase_cpu_mmap(struct kbase_va_region *reg, struct vm_area_struct *vm
 
 	page_array = kbase_get_phy_pages(reg);
 
-	if (!(reg->flags & KBASE_REG_CPU_CACHED)) {
+	if (!(reg->flags & KBASE_REG_CPU_CACHED) &&
+	    (reg->flags & (KBASE_REG_CPU_WR|KBASE_REG_CPU_RD))) {
 		/* We can't map vmalloc'd memory uncached.
 		 * Other memory will have been returned from
 		 * kbase_mem_allocator_alloc which would be
@@ -808,7 +1077,8 @@ static int kbase_cpu_mmap(struct kbase_va_region *reg, struct vm_area_struct *vm
 	map->page_off = start_off;
 	map->region = free_on_close ? reg : NULL;
 	map->kctx = reg->kctx;
-	map->vma = vma;
+	map->vm_start = vma->vm_start;
+	map->vm_end = vma->vm_end;
 	map->alloc = kbase_mem_phy_alloc_get(reg->alloc);
 	map->count = 1; /* start with one ref */
 
@@ -830,7 +1100,7 @@ static int kbase_trace_buffer_mmap(kbase_context *kctx, struct vm_area_struct *v
 	u32 *tb;
 	int owns_tb = 1;
 
-	pr_debug("in %s\n", __func__);
+	KBASE_LOG(1, kctx->kbdev->dev, "in %s\n", __func__);
 	size = (vma->vm_end - vma->vm_start);
 	nr_pages = size >> PAGE_SHIFT;
 
@@ -882,10 +1152,10 @@ static int kbase_trace_buffer_mmap(kbase_context *kctx, struct vm_area_struct *v
 	*reg = new_reg;
 
 	/* map read only, noexec */
-	vma->vm_flags &= ~(VM_WRITE | VM_EXEC);
+	vma->vm_flags &= ~(VM_WRITE | VM_MAYWRITE | VM_EXEC | VM_MAYEXEC);
 	/* the rest of the flags is added by the cpu_mmap handler */
 
-	pr_debug("%s done\n", __func__);
+	KBASE_LOG(1, kctx->kbdev->dev, "%s done\n", __func__);
 	return 0;
 
 out_no_va_region:
@@ -909,7 +1179,7 @@ static int kbase_mmu_dump_mmap(kbase_context *kctx, struct vm_area_struct *vma,
 	size_t size;
 	int err = 0;
 
-	pr_debug("in kbase_mmu_dump_mmap\n");
+	KBASE_LOG(1, kctx->kbdev->dev, "in kbase_mmu_dump_mmap\n");
 	size = (vma->vm_end - vma->vm_start);
 	nr_pages = size >> PAGE_SHIFT;
 
@@ -946,7 +1216,7 @@ static int kbase_mmu_dump_mmap(kbase_context *kctx, struct vm_area_struct *vma,
 	*kmap_addr = kaddr;
 	*reg = new_reg;
 
-	pr_debug("kbase_mmu_dump_mmap done\n");
+	KBASE_LOG(1, kctx->kbdev->dev, "kbase_mmu_dump_mmap done\n");
 	return 0;
 
 out_no_alloc:
@@ -956,43 +1226,6 @@ static int kbase_mmu_dump_mmap(kbase_context *kctx, struct vm_area_struct *vma,
 	return err;
 }
 
-/* must be called with the gpu vm lock held */
-
-struct kbase_va_region *kbase_lookup_cookie(kbase_context *kctx, mali_addr64 cookie)
-{
-	struct kbase_va_region *reg;
-	struct list_head *pos;
-	mali_addr64 test_cookie;
-
-	KBASE_DEBUG_ASSERT(kctx != NULL);
-	BUG_ON(!mutex_is_locked(&kctx->reg_lock));
-
-	test_cookie = KBASE_REG_COOKIE(cookie);
-
-	list_for_each(pos, &kctx->osctx.reg_pending) {
-		reg = list_entry(pos, struct kbase_va_region, link);
-		if ((reg->flags & KBASE_REG_COOKIE_MASK) == test_cookie)
-			return reg;
-	}
-
-	return NULL;		/* not found */
-}
-
-KBASE_EXPORT_TEST_API(kbase_lookup_cookie)
-
-void kbase_unlink_cookie(kbase_context *kctx, mali_addr64 cookie, struct kbase_va_region *reg)
-{
-	KBASE_DEBUG_ASSERT(kctx != NULL);
-	KBASE_DEBUG_ASSERT(reg != NULL);
-	KBASE_DEBUG_ASSERT(MALI_TRUE == kbasep_list_member_of(&kctx->osctx.reg_pending, &reg->link));
-	KBASE_DEBUG_ASSERT(KBASE_REG_COOKIE(cookie) == (reg->flags & KBASE_REG_COOKIE_MASK));
-	KBASE_DEBUG_ASSERT((kctx->osctx.cookies & (1UL << cookie)) == 0);
-
-	list_del(&reg->link);
-	kctx->osctx.cookies |= (1UL << cookie);	/* mark as resolved */
-}
-
-KBASE_EXPORT_TEST_API(kbase_unlink_cookie)
 
 void kbase_os_mem_map_lock(kbase_context *kctx)
 {
@@ -1016,10 +1249,14 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 	size_t nr_pages;
 	int err = 0;
 	int free_on_close = 0;
+	struct device *dev = kctx->kbdev->dev;
 
-	pr_debug("kbase_mmap\n");
+	KBASE_LOG(1, dev, "kbase_mmap\n");
 	nr_pages = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
 
+	/* strip away corresponding VM_MAY% flags to the VM_% flags requested */
+	vma->vm_flags &= ~((vma->vm_flags & (VM_READ | VM_WRITE)) << 4);
+
 	if (0 == nr_pages) {
 		err = -EINVAL;
 		goto out;
@@ -1032,8 +1269,7 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 
 	kbase_gpu_vm_lock(kctx);
 
-	if (vma->vm_pgoff == KBASE_REG_COOKIE_MTP)
-	{
+	if (vma->vm_pgoff == PFN_DOWN(BASE_MEM_MAP_TRACKING_HANDLE)) {
 		/* The non-mapped tracking helper page */
 		err = kbase_tracking_page_setup(kctx, vma);
 		goto out_unlock;
@@ -1041,49 +1277,44 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 
 	/* if not the MTP, verify that the MTP has been mapped */
 	rcu_read_lock();
-	/* catches both when the special page isn't present or when we've forked */
-	if (rcu_dereference(kctx->process_mm) != current->mm)
-	{
+	/* catches both when the special page isn't present or
+	 * when we've forked */
+	if (rcu_dereference(kctx->process_mm) != current->mm) {
 		err = -EINVAL;
 		rcu_read_unlock();
 		goto out_unlock;
 	}
 	rcu_read_unlock();
 
-	if (vma->vm_pgoff == KBASE_REG_COOKIE_RB) {
-		/* Ring buffer doesn't exist any more */
+	switch (vma->vm_pgoff) {
+	case PFN_DOWN(BASE_MEM_INVALID_HANDLE):
+	case PFN_DOWN(BASE_MEM_WRITE_ALLOC_PAGES_HANDLE):
+		/* Illegal handle for direct map */
 		err = -EINVAL;
 		goto out_unlock;
-	} else if (vma->vm_pgoff == KBASE_REG_COOKIE_TB) {
+	case PFN_DOWN(BASE_MEM_TRACE_BUFFER_HANDLE):
 		err = kbase_trace_buffer_mmap(kctx, vma, &reg, &kaddr);
-		if (0 != err) {
+		if (0 != err)
 			goto out_unlock;
-		}
-		pr_debug("kbase_trace_buffer_mmap ok\n");
-
+		KBASE_LOG(1, dev, "kbase_trace_buffer_mmap ok\n");
 		/* free the region on munmap */
 		free_on_close = 1;
-
 		goto map;
-	} else if (vma->vm_pgoff == KBASE_REG_COOKIE_MMU_DUMP) {
+	case PFN_DOWN(BASE_MEM_MMU_DUMP_HANDLE):
 		/* MMU dump */
 		err = kbase_mmu_dump_mmap(kctx, vma, &reg, &kaddr);
-		if (0 != err) {
+		if (0 != err)
 			goto out_unlock;
-		}
-
 		/* free the region on munmap */
 		free_on_close = 1;
-
 		goto map;
-	}
-
-	/* first 4096 pages (16MB) is reserved for cookie resolution */
-	if (vma->vm_pgoff < PAGE_SIZE) {
+	case PFN_DOWN(BASE_MEM_COOKIE_BASE) ...
+	     PFN_DOWN(BASE_MEM_FIRST_FREE_ADDRESS) - 1: {
 		/* SAME_VA stuff, fetch the right region */
 		int gpu_pc_bits;
+		int cookie = vma->vm_pgoff - PFN_DOWN(BASE_MEM_COOKIE_BASE);
 		gpu_pc_bits = kctx->kbdev->gpu_props.props.core_props.log2_program_counter_size;
-		reg = kbase_lookup_cookie(kctx, vma->vm_pgoff);
+		reg = kctx->pending_regions[cookie];
 		if (NULL != reg) {
 			size_t aligned_offset = 0;
 
@@ -1103,7 +1334,7 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 
 				aligned_offset = (vma->vm_start +
 						  (1UL << gpu_pc_bits) - 1) &
-						  ~((1UL << gpu_pc_bits) - 1);
+						 ~((1UL << gpu_pc_bits) - 1);
 				aligned_offset -= vma->vm_start;
 			} else if (reg->nr_pages != nr_pages) {
 				/* incorrect mmap size */
@@ -1114,31 +1345,35 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 				goto out_unlock;
 			}
 
-			if ((vma->vm_flags & VM_READ && !(reg->flags & KBASE_REG_CPU_RD)) ||
-			    (vma->vm_flags & VM_WRITE && !(reg->flags & KBASE_REG_CPU_WR))) {
+			if ((vma->vm_flags & VM_READ &&
+			     !(reg->flags & KBASE_REG_CPU_RD)) ||
+			    (vma->vm_flags & VM_WRITE &&
+			     !(reg->flags & KBASE_REG_CPU_WR))) {
 				/* VM flags inconsistent with region flags */
 				err = -EPERM;
-				printk(KERN_ERR "%s:%d inconsistent VM flags\n", __FILE__, __LINE__);
+				dev_err(dev, "%s:%d inconsistent VM flags\n",
+					__FILE__, __LINE__);
 				goto out_unlock;
 			}
 
 			/* adjust down nr_pages to what we have physically */
-			nr_pages = reg->alloc->nents;
-
-			kbase_unlink_cookie(kctx, vma->vm_pgoff, reg);
-
-			if (MALI_ERROR_NONE != kbase_gpu_mmap(kctx, reg, vma->vm_start + aligned_offset, reg->nr_pages, 1)) {
-				printk(KERN_ERR "%s:%d\n", __FILE__, __LINE__);
-				/* Unable to map in GPU space. Recover from kbase_unlink_cookie */
-				list_add(&reg->link, &kctx->osctx.reg_pending);
-				kctx->osctx.cookies &= ~(1UL << vma->vm_pgoff);
+			nr_pages = kbase_reg_current_backed_size(reg);
+
+			if (MALI_ERROR_NONE != kbase_gpu_mmap(kctx, reg,
+							      vma->vm_start +
+							      aligned_offset,
+							      reg->nr_pages,
+							      1)) {
+				dev_err(dev, "%s:%d\n", __FILE__, __LINE__);
+				/* Unable to map in GPU space. */
 				WARN_ON(1);
 				err = -ENOMEM;
 				goto out_unlock;
 			}
 
-			/* clear off the cookie bits */
-			reg->flags &= ~(KBASE_REG_COOKIE_MASK);
+			/* no need for the cookie anymore */
+			kctx->pending_regions[cookie] = NULL;
+			kctx->cookies |= (1UL << cookie);
 
 			/*
 			 * Overwrite the offset with the
@@ -1154,28 +1389,30 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 
 		err = -ENOMEM;
 		goto out_unlock;
-	} else {
-		int zone;
-
-		/* CUSTOM_VA case or EXEC case */
-		if (vma->vm_pgoff < KBASE_REG_ZONE_EXEC_BASE)
-			zone = KBASE_REG_ZONE_SAME_VA;
-		else if (vma->vm_pgoff < KBASE_REG_ZONE_CUSTOM_VA_BASE)
-			zone = KBASE_REG_ZONE_EXEC;
-		else
-			zone = KBASE_REG_ZONE_CUSTOM_VA;
-
+	}
+	default: {
 		reg = kbase_region_tracker_find_region_enclosing_address(kctx, (u64)vma->vm_pgoff << PAGE_SHIFT);
 
-		if (reg && (reg->flags & (KBASE_REG_ZONE_MASK | KBASE_REG_FREE)) == zone) {
+		if (reg && !(reg->flags & KBASE_REG_FREE)) {
 			/* will this mapping overflow the size of the region? */
 			if (nr_pages > (reg->nr_pages - (vma->vm_pgoff - reg->start_pfn)))
 				goto overflow;
 
+			if ((vma->vm_flags & VM_READ &&
+			     !(reg->flags & KBASE_REG_CPU_RD)) ||
+			    (vma->vm_flags & VM_WRITE &&
+			     !(reg->flags & KBASE_REG_CPU_WR))) {
+				/* VM flags inconsistent with region flags */
+				err = -EPERM;
+				printk(KERN_ERR "%s:%d inconsistent VM flags\n",
+					__FILE__, __LINE__);
+				goto out_unlock;
+			}
+
 #ifdef CONFIG_DMA_SHARED_BUFFER
 			if (reg->alloc->type == KBASE_MEM_TYPE_IMPORTED_UMM)
 				goto dma_map;
-#endif				/* CONFIG_DMA_SHARED_BUFFER */
+#endif /* CONFIG_DMA_SHARED_BUFFER */
 
 			/* limit what we map to the amount currently backed */
 			if (reg->alloc->nents < (vma->vm_pgoff - reg->start_pfn + nr_pages)) {
@@ -1191,11 +1428,12 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 overflow:
 		err = -ENOMEM;
 		goto out_unlock;
-	}
+	} /* default */
+	} /* switch */
 map:
 	err = kbase_cpu_mmap(reg, vma, kaddr, nr_pages, free_on_close);
 
-	if (vma->vm_pgoff == KBASE_REG_COOKIE_MMU_DUMP) {
+	if (vma->vm_pgoff == PFN_DOWN(BASE_MEM_MMU_DUMP_HANDLE)) {
 		/* MMU dump - userspace should now have a reference on
 		 * the pages, so we can now free the kernel mapping */
 		vfree(kaddr);
@@ -1210,50 +1448,13 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 	kbase_gpu_vm_unlock(kctx);
 out:
 	if (err)
-		pr_err("mmap failed %d\n", err);
+		dev_err(dev, "mmap failed %d\n", err);
 
 	return err;
 }
 
 KBASE_EXPORT_TEST_API(kbase_mmap)
 
-mali_error kbase_create_os_context(kbase_os_context * const osctx)
-{
-	KBASE_DEBUG_ASSERT(osctx != NULL);
-
-	INIT_LIST_HEAD(&osctx->reg_pending);
-	osctx->cookies = ~KBASE_REG_RESERVED_COOKIES;
-	osctx->tgid = current->tgid; 
-	osctx->pid = current->pid; 
-	init_waitqueue_head(&osctx->event_queue);
-
-	return MALI_ERROR_NONE;
-}
-
-KBASE_EXPORT_TEST_API(kbase_create_os_context)
-
-static void kbase_reg_pending_dtor(struct kbase_va_region *reg)
-{
-	pr_info("Freeing pending unmapped region\n");
-	kbase_mem_phy_alloc_put(reg->alloc);
-	kfree(reg);
-}
-
-void kbase_destroy_os_context(kbase_os_context *osctx)
-{
-	struct kbase_va_region *reg;
-
-	KBASE_DEBUG_ASSERT(osctx != NULL);
-
-	while (!list_empty(&osctx->reg_pending)) {
-		reg = list_entry(osctx->reg_pending.next, struct kbase_va_region, link);
-		list_del(osctx->reg_pending.next);
-		kbase_reg_pending_dtor(reg);
-	}
-}
-
-KBASE_EXPORT_TEST_API(kbase_destroy_os_context)
-
 void kbasep_os_process_page_usage_update( kbase_context *kctx, int pages )
 {
 	struct mm_struct *mm;
@@ -1327,7 +1528,7 @@ static int kbase_tracking_page_setup(struct kbase_context * kctx, struct vm_area
 	spin_unlock(&kctx->mm_update_lock);
 
 	/* no real access */
-	vma->vm_flags &= ~(VM_READ | VM_WRITE | VM_EXEC);
+	vma->vm_flags &= ~(VM_READ | VM_MAYREAD | VM_WRITE | VM_MAYWRITE | VM_EXEC | VM_MAYEXEC);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0))
 	vma->vm_flags |= VM_DONTCOPY | VM_DONTEXPAND | VM_DONTDUMP | VM_IO;
 #else
@@ -1363,9 +1564,9 @@ void *kbase_va_alloc(kbase_context *kctx, u32 size, kbase_hwc_dma_mapping *handl
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
 	dma_set_attr(DMA_ATTR_WRITE_COMBINE, &attrs);
-	va = dma_alloc_attrs(kctx->kbdev->osdev.dev, size, &dma_pa, GFP_KERNEL, &attrs);
+	va = dma_alloc_attrs(kctx->kbdev->dev, size, &dma_pa, GFP_KERNEL, &attrs);
 #else
-	va = dma_alloc_writecombine(kctx->kbdev->osdev.dev, size, &dma_pa, GFP_KERNEL);
+	va = dma_alloc_writecombine(kctx->kbdev->dev, size, &dma_pa, GFP_KERNEL);
 #endif
 	if (!va)
 		goto err;
@@ -1411,9 +1612,9 @@ void *kbase_va_alloc(kbase_context *kctx, u32 size, kbase_hwc_dma_mapping *handl
 	kfree(reg);
 no_reg:
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
-	dma_free_attrs(kctx->kbdev->osdev.dev, size, va, dma_pa, &attrs);
+	dma_free_attrs(kctx->kbdev->dev, size, va, dma_pa, &attrs);
 #else
-	dma_free_writecombine(kctx->kbdev->osdev.dev, size, va, dma_pa);
+	dma_free_writecombine(kctx->kbdev->dev, size, va, dma_pa);
 #endif
 err:
 	return NULL;
@@ -1443,10 +1644,10 @@ void kbase_va_free(kbase_context *kctx, kbase_hwc_dma_mapping *handle)
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
 	dma_set_attr(DMA_ATTR_WRITE_COMBINE, &attrs);
-	dma_free_attrs(kctx->kbdev->osdev.dev, handle->size,
+	dma_free_attrs(kctx->kbdev->dev, handle->size,
 			handle->cpu_va, handle->dma_pa, &attrs);
 #else
-	dma_free_writecombine(kctx->kbdev->osdev.dev, handle->size,
+	dma_free_writecombine(kctx->kbdev->dev, handle->size,
 				handle->cpu_va, handle->dma_pa);
 #endif
 }
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_mem_linux.h b/drivers/gpu/arm/midgard/mali_kbase_mem_linux.h
old mode 100644
new mode 100755
similarity index 95%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_mem_linux.h
rename to drivers/gpu/arm/midgard/mali_kbase_mem_linux.h
index 53b7ccf74ebc..e7482a5cd450
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_mem_linux.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem_linux.h
@@ -43,6 +43,7 @@ typedef struct kbase_hwc_dma_mapping {
 struct kbase_va_region * kbase_mem_alloc(kbase_context * kctx, u64 va_pages, u64 commit_pages, u64 extent, u64 * flags, u64 * gpu_va, u16 * va_alignment);
 mali_error kbase_mem_query(kbase_context *kctx, mali_addr64 gpu_addr, int query, u64 * const pages);
 int kbase_mem_import(kbase_context *kctx, base_mem_import_type type, int handle, mali_addr64 * gpu_va, u64 * va_pages, u64 * flags);
+u64 kbase_mem_alias(kbase_context *kctx, u64* flags, u64 stride, u64 nents, struct base_mem_aliasing_info* ai, u64 * num_pages);
 mali_error kbase_mem_flags_change(kbase_context *kctx, mali_addr64 gpu_addr, unsigned int flags, unsigned int mask);
 int kbase_mem_commit(kbase_context * kctx, mali_addr64 gpu_addr, u64 new_pages, base_backing_threshold_status * failure_reason);
 int kbase_mmap(struct file *file, struct vm_area_struct *vma);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_lowlevel.c b/drivers/gpu/arm/midgard/mali_kbase_mem_lowlevel.c
old mode 100644
new mode 100755
similarity index 89%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_lowlevel.c
rename to drivers/gpu/arm/midgard/mali_kbase_mem_lowlevel.c
index f1af48514a97..62e5c9f219b0
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_lowlevel.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem_lowlevel.c
@@ -17,7 +17,7 @@
 
 
 
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 
 #include <linux/io.h>
 #include <linux/mm.h>
@@ -32,7 +32,7 @@ void kbase_sync_to_memory(phys_addr_t paddr, void *vaddr, size_t sz)
 	__cpuc_flush_dcache_area(vaddr, sz);
 	outer_flush_range(paddr, paddr + sz);
 #elif defined(CONFIG_ARM64)
-	/* FIXME (MID64-46): There's no other suitable cache flush function for ARM64 */
+	/* TODO (MID64-46): There's no other suitable cache flush function for ARM64 */
 	flush_cache_all();
 #elif defined(CONFIG_X86)
 	struct scatterlist scl = { 0, };
@@ -50,7 +50,7 @@ void kbase_sync_to_cpu(phys_addr_t paddr, void *vaddr, size_t sz)
 	__cpuc_flush_dcache_area(vaddr, sz);
 	outer_flush_range(paddr, paddr + sz);
 #elif defined(CONFIG_ARM64)
-	/* FIXME (MID64-46): There's no other suitable cache flush function for ARM64 */
+	/* TODO (MID64-46): There's no other suitable cache flush function for ARM64 */
 	flush_cache_all();
 #elif defined(CONFIG_X86)
 	struct scatterlist scl = { 0, };
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_lowlevel.h b/drivers/gpu/arm/midgard/mali_kbase_mem_lowlevel.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mem_lowlevel.h
rename to drivers/gpu/arm/midgard/mali_kbase_mem_lowlevel.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mmu.c b/drivers/gpu/arm/midgard/mali_kbase_mmu.c
old mode 100644
new mode 100755
similarity index 84%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mmu.c
rename to drivers/gpu/arm/midgard/mali_kbase_mmu.c
index 334bafe0aa86..4aedadbaf45d
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_mmu.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_mmu.c
@@ -23,14 +23,15 @@
  */
 
 /* #define DEBUG    1 */
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_midg_regmap.h>
-#include <kbase/src/common/mali_kbase_gator.h>
+#include <mali_kbase.h>
+#include <mali_midg_regmap.h>
+#include <mali_kbase_gator.h>
+#include <mali_kbase_debug.h>
 
-#define beenthere(f, a...)  KBASE_DEBUG_PRINT_INFO(KBASE_MMU, "%s:" f, __func__, ##a)
+#define beenthere(kctx, f, a...)  KBASE_LOG(1, kctx->kbdev->dev, "%s:" f, __func__, ##a)
 
-#include <kbase/src/common/mali_kbase_defs.h>
-#include <kbase/src/common/mali_kbase_hw.h>
+#include <mali_kbase_defs.h>
+#include <mali_kbase_hw.h>
 
 #define KBASE_MMU_PAGE_ENTRIES 512
 
@@ -162,7 +163,7 @@ static void page_fault_worker(struct work_struct *data)
 	}
 
 	if ((((faulting_as->fault_status & ASn_FAULTSTATUS_ACCESS_TYPE_MASK) == ASn_FAULTSTATUS_ACCESS_TYPE_READ) && !(region->flags & KBASE_REG_GPU_RD)) || (((faulting_as->fault_status & ASn_FAULTSTATUS_ACCESS_TYPE_MASK) == ASn_FAULTSTATUS_ACCESS_TYPE_WRITE) && !(region->flags & KBASE_REG_GPU_WR)) || (((faulting_as->fault_status & ASn_FAULTSTATUS_ACCESS_TYPE_MASK) == ASn_FAULTSTATUS_ACCESS_TYPE_EX) && (region->flags & KBASE_REG_GPU_NX))) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "Access permissions don't match: region->flags=0x%lx", region->flags);
+		dev_warn(kbdev->dev, "Access permissions don't match: region->flags=0x%lx", region->flags);
 		kbase_gpu_vm_unlock(kctx);
 		kbase_mmu_report_fault_and_kill(kctx, faulting_as);
 		goto fault_done;
@@ -174,7 +175,7 @@ static void page_fault_worker(struct work_struct *data)
 	fault_rel_pfn = fault_pfn - region->start_pfn;
 
 	if (fault_rel_pfn < kbase_reg_current_backed_size(region)) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "Page fault in allocated region of growable TMEM: Ignoring");
+		dev_warn(kbdev->dev, "Page fault in allocated region of growable TMEM: Ignoring");
 		mmu_mask_reenable(kbdev, kctx, faulting_as);
 		kbase_gpu_vm_unlock(kctx);
 		goto fault_done;
@@ -273,27 +274,15 @@ phys_addr_t kbase_mmu_alloc_pgd(kbase_context *kctx)
 	int i;
 
 	KBASE_DEBUG_ASSERT(NULL != kctx);
-	if (MALI_ERROR_NONE != kbase_mem_usage_request_pages(&kctx->usage, 1))
-		return 0;
+	kbase_atomic_add_pages(1, &kctx->used_pages);
+	kbase_atomic_add_pages(1, &kctx->kbdev->memdev.used_pages);
 
-	if (MALI_ERROR_NONE != kbase_mem_usage_request_pages(&kctx->kbdev->memdev.usage, 1))
-	{
-		kbase_mem_usage_release_pages(&kctx->usage, 1);
-		return 0;
-	}
-	if (MALI_ERROR_NONE != kbase_mem_allocator_alloc(kctx->pgd_allocator, 1, &pgd)){
-		kbase_mem_usage_release_pages(&kctx->usage, 1);
-		kbase_mem_usage_release_pages(&kctx->kbdev->memdev.usage, 1);
-		return 0;
-	}
+	if (MALI_ERROR_NONE != kbase_mem_allocator_alloc(kctx->pgd_allocator, 1, &pgd))
+		goto sub_pages;
 
 	page = kmap(pfn_to_page(PFN_DOWN(pgd)));
-	if (NULL == page) {
-		kbase_mem_allocator_free(kctx->pgd_allocator, 1, &pgd, MALI_FALSE);
-		kbase_mem_usage_release_pages(&kctx->usage, 1);
-		kbase_mem_usage_release_pages(&kctx->kbdev->memdev.usage, 1);
-		return 0;
-	}
+	if (NULL == page)
+		goto alloc_free;
 
 	kbase_process_page_usage_inc(kctx, 1);
 
@@ -304,6 +293,14 @@ phys_addr_t kbase_mmu_alloc_pgd(kbase_context *kctx)
 	ksync_kern_vrange_gpu(pgd, page, KBASE_MMU_PAGE_ENTRIES * sizeof(u64));
 	kunmap(pfn_to_page(PFN_DOWN(pgd)));
 	return pgd;
+
+alloc_free:
+	kbase_mem_allocator_free(kctx->pgd_allocator, 1, &pgd, MALI_FALSE);
+sub_pages:
+	kbase_atomic_sub_pages(1, &kctx->used_pages);
+	kbase_atomic_sub_pages(1, &kctx->kbdev->memdev.used_pages);
+
+	return 0;
 }
 
 KBASE_EXPORT_TEST_API(kbase_mmu_alloc_pgd)
@@ -346,7 +343,7 @@ static phys_addr_t mmu_get_next_pgd(kbase_context *kctx, phys_addr_t pgd, u64 vp
 
 	page = kmap(pfn_to_page(PFN_DOWN(pgd)));
 	if (NULL == page) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "mmu_get_next_pgd: kmap failure\n");
+		dev_warn(kctx->kbdev->dev, "mmu_get_next_pgd: kmap failure\n");
 		return 0;
 	}
 
@@ -355,7 +352,7 @@ static phys_addr_t mmu_get_next_pgd(kbase_context *kctx, phys_addr_t pgd, u64 vp
 	if (!target_pgd) {
 		target_pgd = kbase_mmu_alloc_pgd(kctx);
 		if (!target_pgd) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "mmu_get_next_pgd: kbase_mmu_alloc_pgd failure\n");
+			dev_warn(kctx->kbdev->dev, "mmu_get_next_pgd: kbase_mmu_alloc_pgd failure\n");
 			kunmap(pfn_to_page(PFN_DOWN(pgd)));
 			return 0;
 		}
@@ -381,7 +378,7 @@ static phys_addr_t mmu_get_bottom_pgd(kbase_context *kctx, u64 vpfn)
 		pgd = mmu_get_next_pgd(kctx, pgd, vpfn, l);
 		/* Handle failure condition */
 		if (!pgd) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "mmu_get_bottom_pgd: mmu_get_next_pgd failure\n");
+			dev_warn(kctx->kbdev->dev, "mmu_get_bottom_pgd: mmu_get_next_pgd failure\n");
 			return 0;
 		}
 	}
@@ -434,14 +431,16 @@ static phys_addr_t mmu_insert_pages_recover_get_bottom_pgd(kbase_context *kctx,
 	return pgd;
 }
 
-static void mmu_insert_pages_failure_recovery(kbase_context *kctx, u64 vpfn, phys_addr_t *phys, size_t nr)
+static void mmu_insert_pages_failure_recovery(kbase_context *kctx, u64 vpfn,
+					      size_t nr)
 {
 	phys_addr_t pgd;
 	u64 *pgd_page;
 
 	KBASE_DEBUG_ASSERT(NULL != kctx);
 	KBASE_DEBUG_ASSERT(0 != vpfn);
-	KBASE_DEBUG_ASSERT(vpfn <= (UINT64_MAX / PAGE_SIZE));	/* 64-bit address range is the max */
+	/* 64-bit address range is the max */
+	KBASE_DEBUG_ASSERT(vpfn <= (UINT64_MAX / PAGE_SIZE));
 
 	lockdep_assert_held(&kctx->reg_lock);
 
@@ -461,13 +460,14 @@ static void mmu_insert_pages_failure_recovery(kbase_context *kctx, u64 vpfn, phy
 
 		/* Invalidate the entries we added */
 		for (i = 0; i < count; i++)
-			page_table_entry_set( kctx->kbdev, &pgd_page[index + i], ENTRY_IS_INVAL );
+			page_table_entry_set(kctx->kbdev, &pgd_page[index + i],
+					     ENTRY_IS_INVAL);
 
-		phys += count;
 		vpfn += count;
 		nr -= count;
 
-		ksync_kern_vrange_gpu(pgd + (index * sizeof(u64)), pgd_page + index, count * sizeof(u64));
+		ksync_kern_vrange_gpu(pgd + (index * sizeof(u64)),
+				      pgd_page + index, count * sizeof(u64));
 
 		kunmap_atomic(pgd_page);
 	}
@@ -478,11 +478,17 @@ static void mmu_insert_pages_failure_recovery(kbase_context *kctx, u64 vpfn, phy
  */
 static u64 kbase_mmu_get_mmu_flags(unsigned long flags)
 {
-	u64 mmu_flags = 0;
+	u64 mmu_flags;
 
-	mmu_flags |= (flags & KBASE_REG_GPU_WR) ? ENTRY_WR_BIT : 0;	/* write perm if requested */
-	mmu_flags |= (flags & KBASE_REG_GPU_RD) ? ENTRY_RD_BIT : 0;	/* read perm if requested */
-	mmu_flags |= (flags & KBASE_REG_GPU_NX) ? ENTRY_NX_BIT : 0;	/* nx if requested */
+	/* store mem_attr index as 4:2 (macro called ensures 3 bits already) */
+	mmu_flags = KBASE_REG_MEMATTR_VALUE(flags) << 2;
+
+	/* write perm if requested */
+	mmu_flags |= (flags & KBASE_REG_GPU_WR) ? ENTRY_WR_BIT : 0;
+	/* read perm if requested */
+	mmu_flags |= (flags & KBASE_REG_GPU_RD) ? ENTRY_RD_BIT : 0;
+	/* nx if requested */
+	mmu_flags |= (flags & KBASE_REG_GPU_NX) ? ENTRY_NX_BIT : 0;
 
 	if (flags & KBASE_REG_SHARE_BOTH) {
 		/* inner and outer shareable */
@@ -494,24 +500,121 @@ static u64 kbase_mmu_get_mmu_flags(unsigned long flags)
 
 	return mmu_flags;
 }
+
+/*
+ * Map the single page 'phys' 'nr' of times, starting at GPU PFN 'vpfn'
+ */
+mali_error kbase_mmu_insert_single_page(kbase_context *kctx, u64 vpfn,
+					phys_addr_t phys, size_t nr,
+					unsigned long flags)
+{
+	phys_addr_t pgd;
+	u64 *pgd_page;
+	u64 pte_entry;
+	/* In case the insert_single_page only partially completes we need to be
+	 * able to recover */
+	mali_bool recover_required = MALI_FALSE;
+	u64 recover_vpfn = vpfn;
+	size_t recover_count = 0;
+
+	KBASE_DEBUG_ASSERT(NULL != kctx);
+	KBASE_DEBUG_ASSERT(0 != vpfn);
+	/* 64-bit address range is the max */
+	KBASE_DEBUG_ASSERT(vpfn <= (UINT64_MAX / PAGE_SIZE));
+
+	lockdep_assert_held(&kctx->reg_lock);
+
+	/* the one entry we'll populate everywhere */
+	pte_entry = mmu_phyaddr_to_ate(phys, kbase_mmu_get_mmu_flags(flags));
+
+	while (nr) {
+		unsigned int i;
+		unsigned int index = vpfn & 0x1FF;
+		unsigned int count = KBASE_MMU_PAGE_ENTRIES - index;
+
+		if (count > nr)
+			count = nr;
+
+		/*
+		 * Repeatedly calling mmu_get_bottom_pte() is clearly
+		 * suboptimal. We don't have to re-parse the whole tree
+		 * each time (just cache the l0-l2 sequence).
+		 * On the other hand, it's only a gain when we map more than
+		 * 256 pages at once (on average). Do we really care?
+		 */
+		pgd = mmu_get_bottom_pgd(kctx, vpfn);
+		if (!pgd) {
+			dev_warn(kctx->kbdev->dev,
+					       "kbase_mmu_insert_pages: "
+					       "mmu_get_bottom_pgd failure\n");
+			if (recover_required) {
+				/* Invalidate the pages we have partially
+				 * completed */
+				mmu_insert_pages_failure_recovery(kctx,
+								  recover_vpfn,
+								  recover_count);
+			}
+			return MALI_ERROR_FUNCTION_FAILED;
+		}
+
+		pgd_page = kmap(pfn_to_page(PFN_DOWN(pgd)));
+		if (!pgd_page) {
+			dev_warn(kctx->kbdev->dev,
+					       "kbase_mmu_insert_pages: "
+					       "kmap failure\n");
+			if (recover_required) {
+				/* Invalidate the pages we have partially
+				 * completed */
+				mmu_insert_pages_failure_recovery(kctx,
+								  recover_vpfn,
+								  recover_count);
+			}
+			return MALI_ERROR_OUT_OF_MEMORY;
+		}
+
+		for (i = 0; i < count; i++) {
+			unsigned int ofs = index + i;
+			KBASE_DEBUG_ASSERT(0 == (pgd_page[ofs] & 1UL));
+			page_table_entry_set(kctx->kbdev, &pgd_page[ofs],
+					     pte_entry);
+		}
+
+		vpfn += count;
+		nr -= count;
+
+		ksync_kern_vrange_gpu(pgd + (index * sizeof(u64)),
+				      pgd_page + index, count * sizeof(u64));
+
+		kunmap(pfn_to_page(PFN_DOWN(pgd)));
+		/* We have started modifying the page table.
+		 * If further pages need inserting and fail we need to undo what
+		 * has already taken place */
+		recover_required = MALI_TRUE;
+		recover_count += count;
+	}
+	return MALI_ERROR_NONE;
+}
+
 /*
  * Map 'nr' pages pointed to by 'phys' at GPU PFN 'vpfn'
  */
-mali_error kbase_mmu_insert_pages(kbase_context *kctx, u64 vpfn, phys_addr_t *phys, size_t nr, unsigned long flags)
+mali_error kbase_mmu_insert_pages(kbase_context *kctx, u64 vpfn,
+				  phys_addr_t *phys, size_t nr,
+				  unsigned long flags)
 {
 	phys_addr_t pgd;
 	u64 *pgd_page;
 	u64 mmu_flags = 0;
-	/* In case the insert_pages only partially completes we need to be able to recover */
+	/* In case the insert_pages only partially completes we need to be able
+	 * to recover */
 	mali_bool recover_required = MALI_FALSE;
 	u64 recover_vpfn = vpfn;
-	phys_addr_t *recover_phys = phys;
 	size_t recover_count = 0;
 
 	KBASE_DEBUG_ASSERT(NULL != kctx);
 	KBASE_DEBUG_ASSERT(0 != vpfn);
-	KBASE_DEBUG_ASSERT((flags & ~((1 << KBASE_REG_FLAGS_NR_BITS) - 1)) == 0);
-	KBASE_DEBUG_ASSERT(vpfn <= (UINT64_MAX / PAGE_SIZE));	/* 64-bit address range is the max */
+	/* 64-bit address range is the max */
+	KBASE_DEBUG_ASSERT(vpfn <= (UINT64_MAX / PAGE_SIZE));
 
 	lockdep_assert_held(&kctx->reg_lock);
 
@@ -534,20 +637,30 @@ mali_error kbase_mmu_insert_pages(kbase_context *kctx, u64 vpfn, phys_addr_t *ph
 		 */
 		pgd = mmu_get_bottom_pgd(kctx, vpfn);
 		if (!pgd) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "kbase_mmu_insert_pages: mmu_get_bottom_pgd failure\n");
+			dev_warn(kctx->kbdev->dev,
+					       "kbase_mmu_insert_pages: "
+					       "mmu_get_bottom_pgd failure\n");
 			if (recover_required) {
-				/* Invalidate the pages we have partially completed */
-				mmu_insert_pages_failure_recovery(kctx, recover_vpfn, recover_phys, recover_count);
+				/* Invalidate the pages we have partially
+				 * completed */
+				mmu_insert_pages_failure_recovery(kctx,
+								  recover_vpfn,
+								  recover_count);
 			}
 			return MALI_ERROR_FUNCTION_FAILED;
 		}
 
 		pgd_page = kmap(pfn_to_page(PFN_DOWN(pgd)));
 		if (!pgd_page) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "kbase_mmu_insert_pages: kmap failure\n");
+			dev_warn(kctx->kbdev->dev,
+					       "kbase_mmu_insert_pages: "
+					       "kmap failure\n");
 			if (recover_required) {
-				/* Invalidate the pages we have partially completed */
-				mmu_insert_pages_failure_recovery(kctx, recover_vpfn, recover_phys, recover_count);
+				/* Invalidate the pages we have partially
+				 * completed */
+				mmu_insert_pages_failure_recovery(kctx,
+								  recover_vpfn,
+								  recover_count);
 			}
 			return MALI_ERROR_OUT_OF_MEMORY;
 		}
@@ -555,18 +668,23 @@ mali_error kbase_mmu_insert_pages(kbase_context *kctx, u64 vpfn, phys_addr_t *ph
 		for (i = 0; i < count; i++) {
 			unsigned int ofs = index + i;
 			KBASE_DEBUG_ASSERT(0 == (pgd_page[ofs] & 1UL));
-			page_table_entry_set( kctx->kbdev, &pgd_page[ofs], mmu_phyaddr_to_ate(phys[i], mmu_flags) );
+			page_table_entry_set(kctx->kbdev, &pgd_page[ofs],
+					     mmu_phyaddr_to_ate(phys[i],
+								mmu_flags)
+					     );
 		}
 
 		phys += count;
 		vpfn += count;
 		nr -= count;
 
-		ksync_kern_vrange_gpu(pgd + (index * sizeof(u64)), pgd_page + index, count * sizeof(u64));
+		ksync_kern_vrange_gpu(pgd + (index * sizeof(u64)),
+				      pgd_page + index, count * sizeof(u64));
 
 		kunmap(pfn_to_page(PFN_DOWN(pgd)));
-		/* We have started modifying the page table. If further pages need inserting and fail we need to
-		 * undo what has already taken place */
+		/* We have started modifying the page table. If further pages
+		 * need inserting and fail we need to undo what has already
+		 * taken place */
 		recover_required = MALI_TRUE;
 		recover_count += count;
 	}
@@ -626,7 +744,7 @@ static void kbase_mmu_flush(kbase_context *kctx, u64 vpfn, size_t nr)
 
 			if (!max_loops) {
 				/* Flush failed to complete, assume the GPU has hung and perform a reset to recover */
-				KBASE_DEBUG_PRINT_ERROR(KBASE_MMU, "Flush for GPU page table update did not complete. Issueing GPU soft-reset to recover\n");
+				dev_err(kbdev->dev, "Flush for GPU page table update did not complete. Issueing GPU soft-reset to recover\n");
 				if (kbase_prepare_to_reset_gpu(kbdev))
 					kbase_reset_gpu(kbdev);
 			}
@@ -670,9 +788,8 @@ mali_error kbase_mmu_teardown_pages(kbase_context *kctx, u64 vpfn, size_t nr)
 	kbase_device *kbdev;
 	size_t requested_nr = nr;
 
-	beenthere("kctx %p vpfn %lx nr %d", (void *)kctx, (unsigned long)vpfn, nr);
-
 	KBASE_DEBUG_ASSERT(NULL != kctx);
+	beenthere(kctx, "kctx %p vpfn %lx nr %d", (void *)kctx, (unsigned long)vpfn, nr);
 
 	lockdep_assert_held(&kctx->reg_lock);
 
@@ -692,13 +809,13 @@ mali_error kbase_mmu_teardown_pages(kbase_context *kctx, u64 vpfn, size_t nr)
 
 		pgd = mmu_get_bottom_pgd(kctx, vpfn);
 		if (!pgd) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "kbase_mmu_teardown_pages: mmu_get_bottom_pgd failure\n");
+			dev_warn(kbdev->dev, "kbase_mmu_teardown_pages: mmu_get_bottom_pgd failure\n");
 			return MALI_ERROR_FUNCTION_FAILED;
 		}
 
 		pgd_page = kmap(pfn_to_page(PFN_DOWN(pgd)));
 		if (!pgd_page) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "kbase_mmu_teardown_pages: kmap failure\n");
+			dev_warn(kbdev->dev, "kbase_mmu_teardown_pages: kmap failure\n");
 			return MALI_ERROR_OUT_OF_MEMORY;
 		}
 
@@ -747,7 +864,7 @@ mali_error kbase_mmu_update_pages(kbase_context* kctx, u64 vpfn, phys_addr_t* ph
 
 	mmu_flags = kbase_mmu_get_mmu_flags(flags);
 
-	dev_warn( kctx->kbdev->osdev.dev, "kbase_mmu_update_pages(): updating page share flags "\
+	dev_warn(kctx->kbdev->dev, "kbase_mmu_update_pages(): updating page share flags "\
 			"on GPU PFN 0x%llx from phys %p, %zu pages", 
 			vpfn, phys, nr);
 
@@ -762,13 +879,13 @@ mali_error kbase_mmu_update_pages(kbase_context* kctx, u64 vpfn, phys_addr_t* ph
 
 		pgd = mmu_get_bottom_pgd(kctx, vpfn);
 		if (!pgd) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "mmu_get_bottom_pgd failure\n");
+			dev_warn(kctx->kbdev->dev, "mmu_get_bottom_pgd failure\n");
 			return MALI_ERROR_FUNCTION_FAILED;
 		}
 
 		pgd_page = kmap(pfn_to_page(PFN_DOWN(pgd)));
 		if (!pgd_page) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "kmap failure\n");
+			dev_warn(kctx->kbdev->dev, "kmap failure\n");
 			return MALI_ERROR_OUT_OF_MEMORY;
 		}
 
@@ -800,7 +917,6 @@ static void mmu_check_unused(kbase_context *kctx, phys_addr_t pgd)
 {
 	u64 *page;
 	int i;
-	CSTD_UNUSED(kctx);
 
 	page = kmap_atomic(pfn_to_page(PFN_DOWN(pgd)));
 	/* kmap_atomic should NEVER fail. */
@@ -808,7 +924,7 @@ static void mmu_check_unused(kbase_context *kctx, phys_addr_t pgd)
 
 	for (i = 0; i < KBASE_MMU_PAGE_ENTRIES; i++) {
 		if (mmu_pte_is_valid(page[i]))
-			beenthere("live pte %016lx", (unsigned long)page[i]);
+			beenthere(kctx, "live pte %016lx", (unsigned long)page[i]);
 	}
 	kunmap_atomic(page);
 }
@@ -845,12 +961,12 @@ static void mmu_teardown_level(kbase_context *kctx, phys_addr_t pgd, int level,
 				mmu_check_unused(kctx, target_pgd);
 			}
 
-			beenthere("pte %lx level %d", (unsigned long)target_pgd, level + 1);
+			beenthere(kctx, "pte %lx level %d", (unsigned long)target_pgd, level + 1);
 			if (zap) {
 				kbase_mem_allocator_free(kctx->pgd_allocator, 1, &target_pgd, MALI_TRUE);
 				kbase_process_page_usage_dec(kctx, 1 );
-				kbase_mem_usage_release_pages(&kctx->usage, 1);
-				kbase_mem_usage_release_pages(&kctx->kbdev->memdev.usage, 1);
+				kbase_atomic_sub_pages(1, &kctx->used_pages);
+				kbase_atomic_sub_pages(1, &kctx->kbdev->memdev.used_pages);
 			}
 		}
 	}
@@ -864,6 +980,14 @@ mali_error kbase_mmu_init(kbase_context *kctx)
 	/* Preallocate MMU depth of four pages for mmu_teardown_level to use */
 	kctx->mmu_teardown_pages = kmalloc(PAGE_SIZE * 4, GFP_KERNEL);
 
+	kctx->mem_attrs = (ASn_MEMATTR_IMPL_DEF_CACHE_POLICY <<
+			   (ASn_MEMATTR_INDEX_IMPL_DEF_CACHE_POLICY * 8)) |
+			  (ASn_MEMATTR_FORCE_TO_CACHE_ALL    <<
+			   (ASn_MEMATTR_INDEX_FORCE_TO_CACHE_ALL * 8)) |
+			  (ASn_MEMATTR_WRITE_ALLOC           <<
+			   (ASn_MEMATTR_INDEX_WRITE_ALLOC * 8)) |
+			  0; /* The other indices are unused for now */
+
 	if (NULL == kctx->mmu_teardown_pages)
 		return MALI_ERROR_OUT_OF_MEMORY;
 
@@ -888,11 +1012,11 @@ void kbase_mmu_free_pgd(kbase_context *kctx)
 
 	mmu_teardown_level(kctx, kctx->pgd, MIDGARD_MMU_TOPLEVEL, 1, kctx->mmu_teardown_pages);
 
-	beenthere("pgd %lx", (unsigned long)kctx->pgd);
+	beenthere(kctx, "pgd %lx", (unsigned long)kctx->pgd);
 	kbase_mem_allocator_free(kctx->pgd_allocator, 1, &kctx->pgd, MALI_TRUE);
 	kbase_process_page_usage_dec(kctx, 1 );
-	kbase_mem_usage_release_pages(&kctx->usage, 1);
-	kbase_mem_usage_release_pages(&kctx->kbdev->memdev.usage, 1);
+	kbase_atomic_sub_pages(1, &kctx->used_pages);
+	kbase_atomic_sub_pages(1, &kctx->kbdev->memdev.used_pages);
 }
 
 KBASE_EXPORT_TEST_API(kbase_mmu_free_pgd)
@@ -910,7 +1034,7 @@ static size_t kbasep_mmu_dump_level(kbase_context *kctx, phys_addr_t pgd, int le
 
 	pgd_page = kmap(pfn_to_page(PFN_DOWN(pgd)));
 	if (!pgd_page) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "kbasep_mmu_dump_level: kmap failure\n");
+		dev_warn(kctx->kbdev->dev, "kbasep_mmu_dump_level: kmap failure\n");
 		return 0;
 	}
 
@@ -1055,7 +1179,7 @@ static void bus_fault_worker(struct work_struct *data)
 		 * We start the reset before switching to UNMAPPED to ensure that unrelated jobs
 		 * are evicted from the GPU before the switch.
 		 */
-		KBASE_DEBUG_PRINT_ERROR(KBASE_MMU, "GPU bus error occurred. For this GPU version we now soft-reset as part of bus error recovery\n");
+		dev_err(kbdev->dev, "GPU bus error occurred. For this GPU version we now soft-reset as part of bus error recovery\n");
 		reset_status = kbase_prepare_to_reset_gpu(kbdev);
 	}
 
@@ -1143,9 +1267,9 @@ void kbase_mmu_interrupt(kbase_device *kbdev, u32 irq_stat)
 			kbasep_js_clear_submit_allowed(js_devdata, kctx);
 			spin_unlock_irqrestore(&js_devdata->runpool_irq.lock, flags);
 
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "Bus error in AS%d at 0x%016llx\n", as_no, as->fault_addr);
+			dev_warn(kbdev->dev, "Bus error in AS%d at 0x%016llx\n", as_no, as->fault_addr);
 		} else {
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "Bus error in AS%d at 0x%016llx with no context present! " "Suprious IRQ or SW Design Error?\n", as_no, as->fault_addr);
+			dev_warn(kbdev->dev, "Bus error in AS%d at 0x%016llx with no context present! " "Suprious IRQ or SW Design Error?\n", as_no, as->fault_addr);
 		}
 
 		/* remove the queued BFs from the mask */
@@ -1184,7 +1308,7 @@ void kbase_mmu_interrupt(kbase_device *kbdev, u32 irq_stat)
 		kbase_reg_write(kbdev, MMU_REG(MMU_IRQ_CLEAR), 1UL << MMU_REGS_PAGE_FAULT_FLAG(as_no), kctx);
 
 		if (kctx == NULL)
-			KBASE_DEBUG_PRINT_WARN(KBASE_MMU, "Page fault in AS%d at 0x%016llx with no context present! " "Suprious IRQ or SW Design Error?\n", as_no, as->fault_addr);
+			dev_warn(kbdev->dev, "Page fault in AS%d at 0x%016llx with no context present! " "Suprious IRQ or SW Design Error?\n", as_no, as->fault_addr);
 
 		/* remove the queued PFs from the mask */
 		new_mask &= ~((1UL << as_no) | (1UL << (as_no + num_as)));
@@ -1355,18 +1479,18 @@ static void kbase_mmu_report_fault_and_kill(kbase_context *kctx, kbase_as *as)
 	source_id = (as->fault_status >> 16);
 
 	/* terminal fault, print info about the fault */
-	KBASE_DEBUG_PRINT_ERROR(KBASE_MMU, "Unhandled Page fault in AS%d at VA 0x%016llX\n"
-	                                   "raw fault status 0x%X\n"
-	                                   "decoded fault status: %s\n"
-	                                   "exception type 0x%X: %s\n"
-	                                   "access type 0x%X: %s\n"
-	                                   "source id 0x%X\n",
-	                                   as_no, as->fault_addr,
-	                                   as->fault_status,
-	                                   (as->fault_status & (1 << 10) ? "DECODER FAULT" : "SLAVE FAULT"),
-	                                   exception_type, kbase_exception_name(exception_type),
-	                                   access_type, access_type_names[access_type],
-	                                   source_id);
+	dev_err(kbdev->dev, "Unhandled Page fault in AS%d at VA 0x%016llX\n"
+	                    "raw fault status 0x%X\n"
+	                    "decoded fault status: %s\n"
+	                    "exception type 0x%X: %s\n"
+	                    "access type 0x%X: %s\n"
+	                    "source id 0x%X\n",
+	                    as_no, as->fault_addr,
+	                    as->fault_status,
+	                    (as->fault_status & (1 << 10) ? "DECODER FAULT" : "SLAVE FAULT"),
+	                    exception_type, kbase_exception_name(exception_type),
+	                    access_type, access_type_names[access_type],
+	                    source_id);
 
 	/* hardware counters dump fault handling */
 	if ((kbdev->hwcnt.kctx) && (kbdev->hwcnt.kctx->as_nr == as_no) && (kbdev->hwcnt.state == KBASE_INSTR_STATE_DUMPING)) {
@@ -1392,7 +1516,7 @@ static void kbase_mmu_report_fault_and_kill(kbase_context *kctx, kbase_as *as)
 		 * We start the reset before switching to UNMAPPED to ensure that unrelated jobs
 		 * are evicted from the GPU before the switch.
 		 */
-		KBASE_DEBUG_PRINT_ERROR(KBASE_MMU, "Unhandled page fault. For this GPU version we now soft-reset the GPU as part of page fault recovery.");
+		dev_err(kbdev->dev, "Unhandled page fault. For this GPU version we now soft-reset the GPU as part of page fault recovery.");
 		reset_status = kbase_prepare_to_reset_gpu(kbdev);
 	}
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_platform_fake.c b/drivers/gpu/arm/midgard/mali_kbase_platform_fake.c
old mode 100644
new mode 100755
similarity index 86%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_platform_fake.c
rename to drivers/gpu/arm/midgard/mali_kbase_platform_fake.c
index 3d005b29d2b9..b33f0b3bb4d1
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_platform_fake.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_platform_fake.c
@@ -15,12 +15,11 @@
 
 
 
-#if defined(CONFIG_MALI_PLATFORM_FAKE) || defined(CONFIG_MALI_PLATFORM_FAKE_MODULE)
+#ifdef CONFIG_MALI_PLATFORM_FAKE
 
 #include <linux/errno.h>
 #include <linux/export.h>
 #include <linux/ioport.h>
-#include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/string.h>
 
@@ -33,7 +32,7 @@
  * specific platform folders. Do not add dependencies with symbols that are
  * defined somewhere else.
  */
-#include <kbase/mali_kbase_config.h>
+#include <mali_kbase_config.h>
 
 #define PLATFORM_CONFIG_RESOURCE_COUNT 4
 #define PLATFORM_CONFIG_IRQ_RES_COUNT  3
@@ -54,7 +53,7 @@ static struct platform_device *mali_device;
 static void kbasep_config_parse_io_resources(const kbase_io_resources *io_resources, struct resource *const linux_resources)
 {
 	if (!io_resources || !linux_resources) {
-		printk(KERN_ERR "%s: couldn't find proper resources\n", __func__);
+		pr_err("%s: couldn't find proper resources\n", __func__);
 		return;
 	}
 
@@ -79,16 +78,15 @@ int kbase_platform_fake_register(void)
 {
 	kbase_platform_config *config;
 	int attribute_count;
-		
 #ifndef CONFIG_OF
 	struct resource resources[PLATFORM_CONFIG_RESOURCE_COUNT];
 #endif
 	int err;
 
-	config = kbase_get_platform_config(); /* declared in kbase/mali_kbase_config.h but defined in platform folder */
+	config = kbase_get_platform_config(); /* declared in midgard/mali_kbase_config.h but defined in platform folder */
 	if (config == NULL)
 	{
-		printk(KERN_ERR "%s: couldn't get platform config\n", __func__);
+		pr_err("%s: couldn't get platform config\n", __func__);
 		return -ENODEV;
 	}
 
@@ -127,6 +125,7 @@ int kbase_platform_fake_register(void)
 		return err;
 	}
 #endif /* CONFIG_CONFIG_MACH_MANTA */
+
 	return 0;
 }
 
@@ -136,16 +135,8 @@ void kbase_platform_fake_unregister(void)
 		platform_device_unregister(mali_device);
 }
 
-#ifdef MALI_PLATFORM_FAKE_MODULE
-module_init(kbase_platform_fake_register);
-module_exit(kbase_platform_fake_unregister);
-
-MODULE_LICENSE("GPL");
-MODULE_VERSION("mali_kbase_platform_fake");
-#else
 EXPORT_SYMBOL(kbase_platform_fake_register);
 EXPORT_SYMBOL(kbase_platform_fake_unregister);
-#endif
 
 #endif /* CONFIG_MALI_PLATFORM_FAKE */
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm.c b/drivers/gpu/arm/midgard/mali_kbase_pm.c
old mode 100644
new mode 100755
similarity index 96%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm.c
index c692908980af..212221f94fda
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm.c
@@ -22,10 +22,10 @@
  * Base kernel power management APIs
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_midg_regmap.h>
+#include <mali_kbase.h>
+#include <mali_midg_regmap.h>
 
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase_pm.h>
 
 void kbase_pm_register_access_enable(kbase_device *kbdev)
 {
@@ -401,6 +401,13 @@ void kbase_pm_suspend(struct kbase_device *kbdev)
 	 * reaches zero. */
 	wait_event(kbdev->pm.zero_active_count_wait, kbdev->pm.active_count == 0);
 
+	/* Suspend PM Metric timer on system suspend.
+	 * It is ok if kbase_pm_context_idle() is still running, it is safe
+	 * to still complete the last active time period - the pm stats will
+	 * get reset on resume anyway.
+	 */
+	kbasep_pm_metrics_term(kbdev);
+
 	/* NOTE: We synchronize with anything that was just finishing a
 	 * kbase_pm_context_idle() call by locking the pm.lock below */
 
@@ -424,6 +431,10 @@ void kbase_pm_resume(struct kbase_device *kbdev)
 
 	kbase_pm_do_poweron(kbdev, MALI_TRUE);
 
+	/* Restart PM Metric timer on resume */
+	kbasep_pm_metrics_init(kbdev);
+	kbasep_pm_record_gpu_idle(kbdev);
+
 	/* Initial active call, to power on the GPU/cores if needed */
 	kbase_pm_context_active(kbdev);
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm.h b/drivers/gpu/arm/midgard/mali_kbase_pm.h
old mode 100644
new mode 100755
similarity index 99%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm.h
rename to drivers/gpu/arm/midgard/mali_kbase_pm.h
index 5496e6038b46..a9baff977dda
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm.h
@@ -25,7 +25,7 @@
 #ifndef _KBASE_PM_H_
 #define _KBASE_PM_H_
 
-#include <kbase/src/common/mali_midg_regmap.h>
+#include <mali_midg_regmap.h>
 #include <linux/atomic.h>
 
 /* Forward definition - see mali_kbase.h */
@@ -833,7 +833,7 @@ void kbase_pm_do_poweron(struct kbase_device *kbdev, mali_bool is_resume);
  */
 void kbase_pm_do_poweroff(struct kbase_device *kbdev, mali_bool is_suspend);
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 
 /**
  * Function provided by platform specific code when DVFS is enabled to allow
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_always_on.c b/drivers/gpu/arm/midgard/mali_kbase_pm_always_on.c
old mode 100644
new mode 100755
similarity index 94%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_always_on.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm_always_on.c
index d6c06cee9710..b457ca229337
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_always_on.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_always_on.c
@@ -22,8 +22,8 @@
  * "Always on" power management policy
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase.h>
+#include <mali_kbase_pm.h>
 
 static u64 always_on_get_core_mask(struct kbase_device *kbdev)
 {
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_always_on.h b/drivers/gpu/arm/midgard/mali_kbase_pm_always_on.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_always_on.h
rename to drivers/gpu/arm/midgard/mali_kbase_pm_always_on.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca.c b/drivers/gpu/arm/midgard/mali_kbase_pm_ca.c
old mode 100644
new mode 100755
similarity index 98%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm_ca.c
index e5af0d5031f0..e7cfba5b50fe
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_ca.c
@@ -20,8 +20,8 @@
  * Base kernel core availability APIs
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase.h>
+#include <mali_kbase_pm.h>
 
 extern const kbase_pm_ca_policy kbase_pm_ca_fixed_policy_ops;
 #if MALI_CUSTOMER_RELEASE == 0
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca.h b/drivers/gpu/arm/midgard/mali_kbase_pm_ca.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca.h
rename to drivers/gpu/arm/midgard/mali_kbase_pm_ca.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca_fixed.c b/drivers/gpu/arm/midgard/mali_kbase_pm_ca_fixed.c
old mode 100644
new mode 100755
similarity index 94%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca_fixed.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm_ca_fixed.c
index 034222e4bfc9..e391ecfce9b9
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca_fixed.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_ca_fixed.c
@@ -20,8 +20,8 @@
  * A power policy implementing fixed core availability
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase.h>
+#include <mali_kbase_pm.h>
 
 static void fixed_init(struct kbase_device *kbdev)
 {
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca_fixed.h b/drivers/gpu/arm/midgard/mali_kbase_pm_ca_fixed.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_ca_fixed.h
rename to drivers/gpu/arm/midgard/mali_kbase_pm_ca_fixed.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_coarse_demand.c b/drivers/gpu/arm/midgard/mali_kbase_pm_coarse_demand.c
old mode 100644
new mode 100755
similarity index 95%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_coarse_demand.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm_coarse_demand.c
index e252859ee07c..095e6f097ece
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_coarse_demand.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_coarse_demand.c
@@ -22,8 +22,8 @@
  * "Coarse Demand" power management policy
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase.h>
+#include <mali_kbase_pm.h>
 
 static u64 coarse_demand_get_core_mask(struct kbase_device *kbdev)
 {
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_coarse_demand.h b/drivers/gpu/arm/midgard/mali_kbase_pm_coarse_demand.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_coarse_demand.h
rename to drivers/gpu/arm/midgard/mali_kbase_pm_coarse_demand.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_demand.c b/drivers/gpu/arm/midgard/mali_kbase_pm_demand.c
old mode 100644
new mode 100755
similarity index 94%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_demand.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm_demand.c
index f6392b006933..fd94294433f7
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_demand.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_demand.c
@@ -22,8 +22,8 @@
  * A simple demand based power management policy
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase.h>
+#include <mali_kbase_pm.h>
 
 static u64 demand_get_core_mask(struct kbase_device *kbdev)
 {
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_demand.h b/drivers/gpu/arm/midgard/mali_kbase_pm_demand.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_demand.h
rename to drivers/gpu/arm/midgard/mali_kbase_pm_demand.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_driver.c b/drivers/gpu/arm/midgard/mali_kbase_pm_driver.c
old mode 100644
new mode 100755
similarity index 98%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_driver.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm_driver.c
index 4b42dafb516a..1a8cdacd50ed
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_driver.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_driver.c
@@ -22,10 +22,11 @@
  * Base kernel Power Management hardware control
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_midg_regmap.h>
-#include <kbase/src/common/mali_kbase_gator.h>
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase.h>
+#include <mali_midg_regmap.h>
+#include <mali_kbase_gator.h>
+#include <mali_kbase_pm.h>
+#include <mali_kbase_config_defaults.h>
 
 #if MALI_MOCK_TEST
 #define MOCKABLE(function) function##_original
@@ -758,7 +759,7 @@ static void kbase_pm_hw_issues(kbase_device *kbdev)
 		value |= SC_SDC_DISABLE_OQ_DISCARD;
 
 	/* Enable alternative hardware counter selection if configured. */
-	if (kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_ALTERNATIVE_HWC))
+	if (DEFAULT_ALTERNATIVE_HWC)
 		value |= SC_ALT_COUNTERS;
 
 	/* Use software control of forward pixel kill when needed. See MIDEUR-174. */
@@ -853,14 +854,14 @@ mali_error kbase_pm_init_hw(kbase_device *kbdev, mali_bool enable_irqs )
 	/* No interrupt has been received - check if the RAWSTAT register says the reset has completed */
 	if (kbase_reg_read(kbdev, GPU_CONTROL_REG(GPU_IRQ_RAWSTAT), NULL) & RESET_COMPLETED) {
 		/* The interrupt is set in the RAWSTAT; this suggests that the interrupts are not getting to the CPU */
-		KBASE_DEBUG_PRINT_WARN(KBASE_PM, "Reset interrupt didn't reach CPU. Check interrupt assignments.\n");
+		dev_warn(kbdev->dev, "Reset interrupt didn't reach CPU. Check interrupt assignments.\n");
 		/* If interrupts aren't working we can't continue. */
 		destroy_hrtimer_on_stack(&rtdata.timer);
 		goto out;
 	}
 
 	/* The GPU doesn't seem to be responding to the reset so try a hard reset */
-	KBASE_DEBUG_PRINT_ERROR(KBASE_PM, "Failed to soft-reset GPU (timed out after %d ms), now attempting a hard reset\n", RESET_TIMEOUT);
+	dev_err(kbdev->dev, "Failed to soft-reset GPU (timed out after %d ms), now attempting a hard reset\n", RESET_TIMEOUT);
 	KBASE_TRACE_ADD(kbdev, CORE_GPU_HARD_RESET, NULL, NULL, 0u, 0);
 	kbase_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_HARD_RESET, NULL);
 
@@ -881,7 +882,7 @@ mali_error kbase_pm_init_hw(kbase_device *kbdev, mali_bool enable_irqs )
 
 	destroy_hrtimer_on_stack(&rtdata.timer);
 
-	KBASE_DEBUG_PRINT_ERROR(KBASE_PM, "Failed to hard-reset the GPU (timed out after %d ms)\n", RESET_TIMEOUT);
+	dev_err(kbdev->dev, "Failed to hard-reset the GPU (timed out after %d ms)\n", RESET_TIMEOUT);
 
 	/* The GPU still hasn't reset, give up */
 	return MALI_ERROR_FUNCTION_FAILED;
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_metrics.c b/drivers/gpu/arm/midgard/mali_kbase_pm_metrics.c
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_metrics.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm_metrics.c
index 1b73a5065a8b..50450ed6dc3a
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_metrics.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_metrics.c
@@ -22,8 +22,8 @@
  * Metrics for power management
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase.h>
+#include <mali_kbase_pm.h>
 
 /* When VSync is being hit aim for utilisation between 70-90% */
 #define KBASE_PM_VSYNC_MIN_UTILISATION          70
@@ -239,9 +239,9 @@ kbase_pm_dvfs_action kbase_pm_get_dvfs_action(kbase_device *kbdev)
 
 	kbdev->pm.metrics.utilisation = utilisation;
  out:
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	kbase_platform_dvfs_event(kbdev, utilisation);
-#endif				/*CONFIG_MALI_T6XX_DVFS */
+#endif				/*CONFIG_MALI_MIDGARD_DVFS */
 	kbdev->pm.metrics.time_idle = 0;
 	kbdev->pm.metrics.time_busy = 0;
 	spin_unlock_irqrestore(&kbdev->pm.metrics.lock, flags);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_metrics_dummy.c b/drivers/gpu/arm/midgard/mali_kbase_pm_metrics_dummy.c
old mode 100644
new mode 100755
similarity index 91%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_metrics_dummy.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm_metrics_dummy.c
index e04b28f9a09f..81dd06b5ed67
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_metrics_dummy.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_metrics_dummy.c
@@ -22,8 +22,8 @@
  * Dummy Metrics for power management.
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase.h>
+#include <mali_kbase_pm.h>
 
 void kbase_pm_register_vsync_callback(kbase_device *kbdev)
 {
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_policy.c b/drivers/gpu/arm/midgard/mali_kbase_pm_policy.c
old mode 100644
new mode 100755
similarity index 99%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_policy.c
rename to drivers/gpu/arm/midgard/mali_kbase_pm_policy.c
index b12ece81c95e..7ac2d86e8009
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_policy.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_policy.c
@@ -20,10 +20,10 @@
  * Power policy API implementations
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_midg_regmap.h>
-#include <kbase/src/common/mali_kbase_gator.h>
-#include <kbase/src/common/mali_kbase_pm.h>
+#include <mali_kbase.h>
+#include <mali_midg_regmap.h>
+#include <mali_kbase_gator.h>
+#include <mali_kbase_pm.h>
 
 extern const kbase_pm_policy kbase_pm_always_on_policy_ops;
 extern const kbase_pm_policy kbase_pm_coarse_demand_policy_ops;
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_policy.h b/drivers/gpu/arm/midgard/mali_kbase_pm_policy.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_pm_policy.h
rename to drivers/gpu/arm/midgard/mali_kbase_pm_policy.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/mali_kbase_profiling_gator_api.h b/drivers/gpu/arm/midgard/mali_kbase_profiling_gator_api.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/mali_kbase_profiling_gator_api.h
rename to drivers/gpu/arm/midgard/mali_kbase_profiling_gator_api.h
diff --git a/drivers/gpu/arm/midgard/mali_kbase_replay.c b/drivers/gpu/arm/midgard/mali_kbase_replay.c
new file mode 100755
index 000000000000..91381329881c
--- /dev/null
+++ b/drivers/gpu/arm/midgard/mali_kbase_replay.c
@@ -0,0 +1,1069 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+/**
+ * @file mali_kbase_replay.c
+ * Replay soft job handlers
+ */
+
+#include <mali_kbase_config.h>
+#include <mali_kbase.h>
+#include <mali_kbase_mem.h>
+#include <mali_kbase_debug.h>
+
+#define JOB_NOT_STARTED 0
+
+#define JOB_TYPE_MASK      0xfe
+#define JOB_TYPE_NULL      (1 << 1)
+#define JOB_TYPE_VERTEX    (5 << 1)
+#define JOB_TYPE_TILER     (7 << 1)
+#define JOB_TYPE_FUSED     (8 << 1)
+#define JOB_TYPE_FRAGMENT  (9 << 1)
+
+#define JOB_FLAG_DESC_SIZE           (1 << 0)
+#define JOB_FLAG_PERFORM_JOB_BARRIER (1 << 8)
+
+#define JOB_HEADER_32_FBD_OFFSET (31*4)
+
+#define FBD_POINTER_MASK (~0x3f)
+
+#define SFBD_TILER_OFFSET (48*4)
+
+#define MFBD_TILER_FLAGS_OFFSET (15*4)
+#define MFBD_TILER_OFFSET       (16*4)
+
+#define FBD_HIERARCHY_WEIGHTS 8
+#define FBD_HIERARCHY_MASK_MASK 0x1fff
+
+#define FBD_TYPE 1
+
+#define HIERARCHY_WEIGHTS 13
+
+#define JOB_HEADER_ID_MAX                 0xffff
+
+typedef struct job_head
+{
+	u32 status;
+	u32 not_complete_index;
+	u64 fault_addr;
+	u16 flags;
+	u16 index;
+	u16 dependencies[2];
+	union
+	{
+		u64 _64;
+		u32 _32;
+	} next;
+	u32 x[2];
+	union
+	{
+		u64 _64;
+		u32 _32;
+	} fragment_fbd;
+} job_head;
+
+static void dump_job_head(kbase_context *kctx, char *head_str, job_head *job)
+{
+#ifdef CONFIG_MALI_DEBUG
+	struct device *dev = kctx->kbdev->dev;
+
+	KBASE_LOG(2, dev, "%s\n", head_str);
+	KBASE_LOG(2, dev, "addr               = %p\n"
+					"status             = %x\n"
+					"not_complete_index = %x\n"
+					"fault_addr         = %llx\n"
+					"flags              = %x\n"
+					"index              = %x\n"
+					"dependencies       = %x,%x\n",
+									   job,
+								   job->status,
+						       job->not_complete_index,
+							       job->fault_addr,
+								    job->flags,
+								    job->index,
+							  job->dependencies[0],
+							 job->dependencies[1]);
+
+	if (job->flags & JOB_FLAG_DESC_SIZE)
+		KBASE_LOG(2, dev, "next               = %llx\n", job->next._64);
+	else
+		KBASE_LOG(2, dev, "next               = %x\n", job->next._32);
+#endif
+}
+
+
+static void *kbasep_map_page(kbase_context *kctx, mali_addr64 gpu_addr,
+								u64 *phys_addr)
+{
+	void *cpu_addr = NULL;
+	u64 page_index;
+	kbase_va_region *region;
+	phys_addr_t *page_array;
+
+	region = kbase_region_tracker_find_region_enclosing_address(kctx,
+								     gpu_addr);
+	if (!region || (region->flags & KBASE_REG_FREE))
+		return NULL;
+
+	page_index = (gpu_addr >> PAGE_SHIFT) - region->start_pfn;
+	if (page_index >= kbase_reg_current_backed_size(region))
+		return NULL;
+
+	page_array = kbase_get_phy_pages(region);
+	if (!page_array)
+		return NULL;
+
+	cpu_addr = kmap_atomic(pfn_to_page(PFN_DOWN(page_array[page_index])));
+	if (!cpu_addr)
+		return NULL;
+
+	if (phys_addr)
+		*phys_addr = page_array[page_index];
+
+	return cpu_addr + (gpu_addr & ~PAGE_MASK);
+}
+
+static void *kbasep_map_page_sync(kbase_context *kctx, mali_addr64 gpu_addr,
+								u64 *phys_addr)
+{
+	void *cpu_addr = kbasep_map_page(kctx, gpu_addr, phys_addr);
+
+	if (!cpu_addr)
+		return NULL;
+
+	kbase_sync_to_cpu(*phys_addr,
+				 (void *)((uintptr_t)cpu_addr & PAGE_MASK),
+								    PAGE_SIZE);
+
+	return cpu_addr;
+}
+
+static void kbasep_unmap_page(void *cpu_addr)
+{
+	kunmap_atomic((void *)((uintptr_t)cpu_addr & PAGE_MASK));
+}
+
+static void kbasep_unmap_page_sync(void *cpu_addr, u64 phys_addr)
+{
+	kbase_sync_to_memory(phys_addr,
+				 (void *)((uintptr_t)cpu_addr & PAGE_MASK),
+								    PAGE_SIZE);
+
+	kunmap_atomic((void *)((uintptr_t)cpu_addr & PAGE_MASK));
+}
+
+static mali_error kbasep_replay_reset_sfbd(kbase_context *kctx,
+					   mali_addr64 fbd_address,
+					   mali_addr64 tiler_heap_free,
+					   u16 hierarchy_mask,
+					   u32 default_weight)
+{
+	u64 phys_addr;
+	struct
+	{
+		u32 padding_1[1];
+		u32 flags;
+		u64 padding_2[2];
+		u64 heap_free_address;
+		u32 padding[8];
+		u32 weights[FBD_HIERARCHY_WEIGHTS];
+	} *fbd_tiler;
+	struct device *dev = kctx->kbdev->dev;
+
+	KBASE_LOG(2, dev, "fbd_address: %llx\n", fbd_address);
+
+	fbd_tiler = kbasep_map_page_sync(kctx, fbd_address + SFBD_TILER_OFFSET,
+								   &phys_addr);
+	if (!fbd_tiler) {
+		dev_err(dev, "kbasep_replay_reset_fbd: failed to map fbd\n");
+		return MALI_ERROR_FUNCTION_FAILED;
+	}
+#ifdef CONFIG_MALI_DEBUG
+	KBASE_LOG(2, dev, "FBD tiler:\n"
+				"flags = %x\n"
+				"heap_free_address = %llx\n",
+							      fbd_tiler->flags,
+						 fbd_tiler->heap_free_address);
+#endif
+	if (hierarchy_mask) {
+		u32 weights[HIERARCHY_WEIGHTS];
+		u16 old_hierarchy_mask = fbd_tiler->flags &
+						       FBD_HIERARCHY_MASK_MASK;
+		int i, j = 0;
+
+		for (i = 0; i < HIERARCHY_WEIGHTS; i++) {
+			if (old_hierarchy_mask & (1 << i)) {
+				KBASE_DEBUG_ASSERT(j < FBD_HIERARCHY_WEIGHTS);
+				weights[i] = fbd_tiler->weights[j++];
+			} else {
+				weights[i] = default_weight;
+			}
+		}
+
+
+		KBASE_LOG(2, dev,
+			      "Old hierarchy mask=%x  New hierarchy mask=%x\n",
+					   old_hierarchy_mask, hierarchy_mask);
+		for (i = 0; i < HIERARCHY_WEIGHTS; i++)
+			KBASE_LOG(2, dev, " Hierarchy weight %02d: %08x\n",
+								i, weights[i]);
+
+		j = 0;
+
+		for (i = 0; i < HIERARCHY_WEIGHTS; i++) {
+			if (hierarchy_mask & (1 << i)) {
+				KBASE_DEBUG_ASSERT(j < FBD_HIERARCHY_WEIGHTS);
+
+				KBASE_LOG(2, dev,
+				" Writing hierarchy level %02d (%08x) to %d\n",
+							     i, weights[i], j);
+
+				fbd_tiler->weights[j++] = weights[i];
+			}
+		}
+
+		for (; j < FBD_HIERARCHY_WEIGHTS; j++)
+			fbd_tiler->weights[j] = 0;
+
+		fbd_tiler->flags = hierarchy_mask | (1 << 16);
+	}
+
+	fbd_tiler->heap_free_address = tiler_heap_free;
+
+	KBASE_LOG(2, dev, "heap_free_address=%llx flags=%x\n",
+			       fbd_tiler->heap_free_address, fbd_tiler->flags);
+
+	kbasep_unmap_page_sync(fbd_tiler, phys_addr);
+
+	return MALI_ERROR_NONE;
+}
+
+static mali_error kbasep_replay_reset_mfbd(kbase_context *kctx,
+					   mali_addr64 fbd_address,
+					   mali_addr64 tiler_heap_free,
+					   u16 hierarchy_mask,
+					   u32 default_weight)
+{
+	u64 phys_addr, phys_addr_flags;
+	struct
+	{
+		u64 padding_1[2];
+		u64 heap_free_address;
+		u64 padding_2;
+		u32 weights[FBD_HIERARCHY_WEIGHTS];
+	} *fbd_tiler;
+	u32 *fbd_tiler_flags;
+	mali_bool flags_different_page;
+	struct device *dev = kctx->kbdev->dev;
+
+	KBASE_LOG(2, dev, "fbd_address: %llx\n", fbd_address);
+
+	fbd_tiler = kbasep_map_page_sync(kctx, fbd_address + MFBD_TILER_OFFSET,
+								   &phys_addr);
+	if (((fbd_address + MFBD_TILER_OFFSET) & PAGE_MASK) !=
+	    ((fbd_address + MFBD_TILER_FLAGS_OFFSET) & PAGE_MASK)) {
+		flags_different_page = MALI_TRUE;
+		fbd_tiler_flags = kbasep_map_page_sync(kctx,
+					 fbd_address + MFBD_TILER_FLAGS_OFFSET,
+							     &phys_addr_flags);
+	} else {
+		flags_different_page = MALI_FALSE;
+		fbd_tiler_flags = (u32 *)((uintptr_t)fbd_tiler -
+				  MFBD_TILER_OFFSET + MFBD_TILER_FLAGS_OFFSET);
+	}
+
+	if (!fbd_tiler || !fbd_tiler_flags) {
+		dev_err(dev, "kbasep_replay_reset_fbd: failed to map fbd\n");
+
+		if (fbd_tiler_flags && flags_different_page)
+			kbasep_unmap_page_sync(fbd_tiler_flags,
+							      phys_addr_flags);
+		if (fbd_tiler)
+			kbasep_unmap_page_sync(fbd_tiler, phys_addr);
+
+		return MALI_ERROR_FUNCTION_FAILED;
+	}
+#ifdef CONFIG_MALI_DEBUG
+	KBASE_LOG(2, dev, "FBD tiler:\n"
+				"heap_free_address = %llx\n",
+				 fbd_tiler->heap_free_address);
+#endif
+	if (hierarchy_mask) {
+		u32 weights[HIERARCHY_WEIGHTS];
+		u16 old_hierarchy_mask = (*fbd_tiler_flags) &
+						       FBD_HIERARCHY_MASK_MASK;
+		int i, j = 0;
+
+		for (i = 0; i < HIERARCHY_WEIGHTS; i++) {
+			if (old_hierarchy_mask & (1 << i)) {
+				KBASE_DEBUG_ASSERT(j < FBD_HIERARCHY_WEIGHTS);
+				weights[i] = fbd_tiler->weights[j++];
+			}
+			else
+				weights[i] = default_weight;
+		}
+
+
+		KBASE_LOG(2, dev,
+			      "Old hierarchy mask=%x  New hierarchy mask=%x\n",
+					   old_hierarchy_mask, hierarchy_mask);
+		for (i = 0; i < HIERARCHY_WEIGHTS; i++)
+			KBASE_LOG(2, dev, " Hierarchy weight %02d: %08x\n",
+								i, weights[i]);
+
+		j = 0;
+
+		for (i = 0; i < HIERARCHY_WEIGHTS; i++) {
+			if (hierarchy_mask & (1 << i)) {
+				KBASE_DEBUG_ASSERT(j < FBD_HIERARCHY_WEIGHTS);
+
+				KBASE_LOG(2, dev,
+				" Writing hierarchy level %02d (%08x) to %d\n",
+							     i, weights[i], j);
+
+				fbd_tiler->weights[j++] = weights[i];
+			}
+		}
+
+		for (; j < FBD_HIERARCHY_WEIGHTS; j++)
+			fbd_tiler->weights[j] = 0;
+
+		*fbd_tiler_flags = hierarchy_mask | (1 << 16);
+	}
+
+	fbd_tiler->heap_free_address = tiler_heap_free;
+
+	if (flags_different_page)
+		kbasep_unmap_page_sync(fbd_tiler_flags, phys_addr_flags);
+
+	kbasep_unmap_page_sync(fbd_tiler, phys_addr);
+
+	return MALI_ERROR_NONE;
+}
+
+/**
+ * @brief Reset the status of an FBD pointed to by a tiler job
+ *
+ * This performs two functions :
+ * - Set the hierarchy mask
+ * - Reset the tiler free heap address
+ *
+ * @param[in] kctx              Context pointer
+ * @param[in] job_header        Address of job header to reset.
+ * @param[in] tiler_heap_free   The value to reset Tiler Heap Free to
+ * @param[in] hierarchy_mask    The hierarchy mask to use
+ * @param[in] default_weight    Default hierarchy weight to write when no other
+ *                              weight is given in the FBD
+ * @param[in] job_64            MALI_TRUE if this job is using 64-bit
+ *                              descriptors
+ *
+ * @return MALI_ERROR_NONE on success, error code on failure
+ */
+static mali_error kbasep_replay_reset_tiler_job(kbase_context *kctx,
+						mali_addr64 job_header,
+						mali_addr64 tiler_heap_free,
+						u16 hierarchy_mask,
+						u32 default_weight,
+						mali_bool job_64)
+{
+	mali_addr64 fbd_address;
+
+	if (job_64) {
+		dev_err(kctx->kbdev->dev,
+				      "64-bit job descriptor not supported\n");
+		return MALI_ERROR_FUNCTION_FAILED;
+	} else {
+		u32 *job_ext;	
+
+		job_ext = kbasep_map_page(kctx,
+					 job_header + JOB_HEADER_32_FBD_OFFSET,
+									 NULL);
+		if (!job_ext) {
+			dev_err(kctx->kbdev->dev,
+			  "kbasep_replay_reset_tiler_job: failed to map jc\n");
+			return MALI_ERROR_FUNCTION_FAILED;
+		}
+
+		fbd_address = *job_ext;
+
+		kbasep_unmap_page(job_ext);
+	}
+
+	if (fbd_address & FBD_TYPE) {
+		return kbasep_replay_reset_mfbd(kctx,
+						fbd_address & FBD_POINTER_MASK,
+						tiler_heap_free,
+						hierarchy_mask,
+						default_weight);
+	} else {
+		return kbasep_replay_reset_sfbd(kctx,
+						fbd_address & FBD_POINTER_MASK,
+						tiler_heap_free,
+						hierarchy_mask,
+						default_weight);
+	}
+}
+
+/**
+ * @brief Reset the status of a job
+ *
+ * This performs the following functions :
+ *
+ * - Reset the Job Status field of each job to NOT_STARTED.
+ * - Set the Job Type field of any Vertex Jobs to Null Job.
+ * - For any jobs using an FBD, set the Tiler Heap Free field to the value of
+ *   the tiler_heap_free parameter, and set the hierarchy level mask to the
+ *   hier_mask parameter.
+ * - Offset HW dependencies by the hw_job_id_offset parameter
+ * - Set the Perform Job Barrier flag if this job is the first in the chain
+ * - Read the address of the next job header
+ *
+ * @param[in] kctx              Context pointer
+ * @param[in,out] job_header    Address of job header to reset. Set to address
+ *                              of next job header on exit.
+ * @param[in] prev_jc           Previous job chain to link to, if this job is
+ *                              the last in the chain.
+ * @param[in] hw_job_id_offset  Offset for HW job IDs
+ * @param[in] tiler_heap_free   The value to reset Tiler Heap Free to
+ * @param[in] hierarchy_mask    The hierarchy mask to use
+ * @param[in] default_weight    Default hierarchy weight to write when no other
+ *                              weight is given in the FBD
+ * @param[in] first_in_chain    MALI_TRUE if this job is the first in the chain
+ * @param[in] fragment_chain    MALI_TRUE if this job is in the fragment chain
+ *
+ * @return MALI_ERROR_NONE on success, error code on failure
+ */
+static mali_error kbasep_replay_reset_job(kbase_context *kctx,
+						mali_addr64 *job_header,
+						mali_addr64 prev_jc,
+						mali_addr64 tiler_heap_free,
+						u16 hierarchy_mask,
+						u32 default_weight,
+						u16 hw_job_id_offset,
+						mali_bool first_in_chain,
+						mali_bool fragment_chain)
+{
+	job_head *job;
+	u64 phys_addr;
+	mali_addr64 new_job_header;
+	struct device *dev = kctx->kbdev->dev;
+
+	job = kbasep_map_page_sync(kctx, *job_header, &phys_addr);
+	if (!job) {
+		dev_err(dev, "kbasep_replay_parse_jc: failed to map jc\n");
+		return MALI_ERROR_FUNCTION_FAILED;
+	}
+
+	dump_job_head(kctx, "Job header:", job);
+
+	if (job->status == JOB_NOT_STARTED && !fragment_chain) {
+		dev_err(dev, "Job already not started\n");
+		kbasep_unmap_page_sync(job, phys_addr);
+		return MALI_ERROR_FUNCTION_FAILED;
+	}
+	job->status = JOB_NOT_STARTED;
+
+	if ((job->flags & JOB_TYPE_MASK) == JOB_TYPE_VERTEX)
+		job->flags = (job->flags & ~JOB_TYPE_MASK) | JOB_TYPE_NULL;
+
+	if ((job->flags & JOB_TYPE_MASK) == JOB_TYPE_FUSED) {
+		dev_err(dev, "Fused jobs can not be replayed\n");
+		kbasep_unmap_page_sync(job, phys_addr);
+		return MALI_ERROR_FUNCTION_FAILED;
+	}
+
+	if (first_in_chain)
+		job->flags |= JOB_FLAG_PERFORM_JOB_BARRIER;
+
+	if ((job->dependencies[0] + hw_job_id_offset) > JOB_HEADER_ID_MAX ||
+	    (job->dependencies[1] + hw_job_id_offset) > JOB_HEADER_ID_MAX ||
+	    (job->index + hw_job_id_offset) > JOB_HEADER_ID_MAX) {
+		dev_err(dev, "Job indicies/dependencies out of valid range\n");
+		kbasep_unmap_page_sync(job, phys_addr);
+		return MALI_ERROR_FUNCTION_FAILED;
+	}
+
+	if (job->dependencies[0])
+		job->dependencies[0] += hw_job_id_offset;
+	if (job->dependencies[1])
+		job->dependencies[1] += hw_job_id_offset;
+
+	job->index += hw_job_id_offset;
+
+	if (job->flags & JOB_FLAG_DESC_SIZE) {
+		new_job_header = job->next._64;
+		if (!job->next._64)
+			job->next._64 = prev_jc;
+	} else {
+		new_job_header = job->next._32;
+		if (!job->next._32)
+			job->next._32 = prev_jc;
+	}
+	dump_job_head(kctx, "Updated to:", job);
+
+	if ((job->flags & JOB_TYPE_MASK) == JOB_TYPE_TILER) {
+		kbasep_unmap_page_sync(job, phys_addr);
+		if (kbasep_replay_reset_tiler_job(kctx, *job_header,
+					tiler_heap_free, hierarchy_mask, 
+					default_weight,
+					job->flags & JOB_FLAG_DESC_SIZE) !=
+							MALI_ERROR_NONE)
+			return MALI_ERROR_FUNCTION_FAILED;
+
+	} else if ((job->flags & JOB_TYPE_MASK) == JOB_TYPE_FRAGMENT) {
+		u64 fbd_address;
+
+		if (job->flags & JOB_FLAG_DESC_SIZE) {
+			kbasep_unmap_page_sync(job, phys_addr);
+			dev_err(dev, "64-bit job descriptor not supported\n");
+			return MALI_ERROR_FUNCTION_FAILED;
+		} else {
+			fbd_address = (u64)job->fragment_fbd._32;
+		}
+
+		kbasep_unmap_page_sync(job, phys_addr);
+
+		if (fbd_address & FBD_TYPE) {
+			if (kbasep_replay_reset_mfbd(kctx,
+						fbd_address & FBD_POINTER_MASK,
+						tiler_heap_free,
+						hierarchy_mask,
+						default_weight) !=
+							       MALI_ERROR_NONE)
+				return MALI_ERROR_FUNCTION_FAILED;
+		} else {
+			if (kbasep_replay_reset_sfbd(kctx,
+						fbd_address & FBD_POINTER_MASK,
+						tiler_heap_free,
+						hierarchy_mask,
+						default_weight) !=
+							       MALI_ERROR_NONE)
+				return MALI_ERROR_FUNCTION_FAILED;
+		}
+	} else {
+		kbasep_unmap_page_sync(job, phys_addr);
+	}
+
+	*job_header = new_job_header;
+
+	return MALI_ERROR_NONE;
+}
+
+/**
+ * @brief Find the highest job ID in a job chain
+ *
+ * @param[in] kctx        Context pointer
+ * @param[in] jc          Job chain start address
+ * @param[out] hw_job_id  Highest job ID in chain
+ *
+ * @return MALI_ERROR_NONE on success, error code on failure
+ */
+static mali_error kbasep_replay_find_hw_job_id(kbase_context *kctx,
+						mali_addr64 jc,
+						u16 *hw_job_id)
+{
+	while (jc) {
+		job_head *job;
+		u64 phys_addr;
+
+		KBASE_LOG(2, kctx->kbdev->dev,
+			"kbasep_replay_find_hw_job_id: parsing jc=%llx\n", jc);
+
+		job = kbasep_map_page_sync(kctx, jc, &phys_addr);
+		if (!job) {
+			dev_err(kctx->kbdev->dev, "failed to map jc\n");
+
+			return MALI_ERROR_FUNCTION_FAILED;
+		}
+
+		if (job->index > *hw_job_id)
+			*hw_job_id = job->index;
+
+		if (job->flags & JOB_FLAG_DESC_SIZE)
+			jc = job->next._64;
+		else
+			jc = job->next._32;
+
+		kbasep_unmap_page_sync(job, phys_addr);
+	}
+
+	return MALI_ERROR_NONE;
+}
+
+/**
+ * @brief Reset the status of a number of jobs
+ *
+ * This function walks the provided job chain, and calls
+ * kbasep_replay_reset_job for each job. It also links the job chain to the
+ * provided previous job chain.
+ *
+ * The function will fail if any of the jobs passed already have status of
+ * NOT_STARTED.
+ *
+ * @param[in] kctx              Context pointer
+ * @param[in] jc                Job chain to be processed
+ * @param[in] prev_jc           Job chain to be added to. May be NULL
+ * @param[in] tiler_heap_free   The value to reset Tiler Heap Free to
+ * @param[in] hierarchy_mask    The hierarchy mask to use
+ * @param[in] default_weight    Default hierarchy weight to write when no other
+ *                              weight is given in the FBD
+ * @param[in] hw_job_id_offset  Offset for HW job IDs
+ * @param[in] fragment_chain    MAIL_TRUE if this chain is the fragment chain
+ *
+ * @return MALI_ERROR_NONE on success, error code otherwise
+ */
+static mali_error kbasep_replay_parse_jc(kbase_context *kctx,
+						mali_addr64 jc,
+						mali_addr64 prev_jc,
+						mali_addr64 tiler_heap_free,
+						u16 hierarchy_mask,
+						u32 default_weight,
+						u16 hw_job_id_offset,
+						mali_bool fragment_chain)
+{
+	mali_bool first_in_chain = MALI_TRUE;
+	int nr_jobs = 0;
+
+	KBASE_LOG(2, kctx->kbdev->dev,
+			      "kbasep_replay_parse_jc: jc=%llx hw_job_id=%x\n",
+							 jc, hw_job_id_offset);
+
+	while (jc) {
+		KBASE_LOG(2, kctx->kbdev->dev,
+				   "kbasep_replay_parse_jc: parsing jc=%llx\n",
+									   jc);
+
+		if (kbasep_replay_reset_job(kctx, &jc, prev_jc,
+				tiler_heap_free, hierarchy_mask,
+				default_weight, hw_job_id_offset,
+				first_in_chain, fragment_chain) != 
+							     MALI_ERROR_NONE)
+			return MALI_ERROR_FUNCTION_FAILED;
+
+		first_in_chain = MALI_FALSE;
+
+		nr_jobs++;
+		if (fragment_chain &&
+                		nr_jobs >= BASE_JD_REPLAY_F_CHAIN_JOB_LIMIT) {
+			dev_err(kctx->kbdev->dev,
+				"Exceeded maximum number of jobs in fragment chain\n");
+			return MALI_ERROR_FUNCTION_FAILED;
+		}
+	}
+
+	return MALI_ERROR_NONE;
+}
+
+/**
+ * @brief Reset the status of a replay job, and set up dependencies
+ *
+ * This performs the actions to allow the replay job to be re-run following
+ * completion of the passed dependency.
+ *
+ * @param[in] katom     The atom to be reset
+ * @param[in] dep_atom  The dependency to be attached to the atom
+ */
+static void kbasep_replay_reset_softjob(kbase_jd_atom *katom,
+						       kbase_jd_atom *dep_atom)
+{
+	katom->status = KBASE_JD_ATOM_STATE_QUEUED;
+	katom->dep_atom[0] = dep_atom;
+	list_add_tail(&katom->dep_item[0], &dep_atom->dep_head[0]);
+}
+
+/**
+ * @brief Allocate an unused katom
+ *
+ * This will search the provided context for an unused katom, and will mark it
+ * as KBASE_JD_ATOM_STATE_QUEUED.
+ *
+ * If no atoms are available then the function will fail.
+ *
+ * @param[in] kctx      Context pointer
+ * @return An atom ID, or -1 on failure
+ */
+static int kbasep_allocate_katom(kbase_context *kctx)
+{
+	kbase_jd_context *jctx = &kctx->jctx;
+	int i;
+
+	for (i = BASE_JD_ATOM_COUNT-1; i > 0; i--) {
+		if (jctx->atoms[i].status == KBASE_JD_ATOM_STATE_UNUSED) {
+			jctx->atoms[i].status = KBASE_JD_ATOM_STATE_QUEUED;
+			KBASE_LOG(2, kctx->kbdev->dev,
+				  "kbasep_allocate_katom: Allocated atom %d\n",
+									    i);
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+/**
+ * @brief Release a katom
+ *
+ * This will mark the provided atom as available, and remove any dependencies.
+ *
+ * For use on error path.
+ *
+ * @param[in] kctx      Context pointer
+ * @param[in] atom_id   ID of atom to release
+ */
+static void kbasep_release_katom(kbase_context *kctx, int atom_id)
+{
+	kbase_jd_context *jctx = &kctx->jctx;
+
+	KBASE_LOG(2, kctx->kbdev->dev,
+				    "kbasep_release_katom: Released atom %d\n",
+								      atom_id);
+
+	while (!list_empty(&jctx->atoms[atom_id].dep_head[0]))
+		list_del(jctx->atoms[atom_id].dep_head[0].next);
+	while (!list_empty(&jctx->atoms[atom_id].dep_head[1]))
+		list_del(jctx->atoms[atom_id].dep_head[1].next);
+
+	jctx->atoms[atom_id].status = KBASE_JD_ATOM_STATE_UNUSED;
+}
+
+static void kbasep_replay_create_atom(kbase_context *kctx,
+				      base_jd_atom_v2 *atom,
+				      int atom_nr,
+				      int prio)
+{
+	atom->nr_extres = 0;
+	atom->extres_list.value = NULL;
+	atom->device_nr = 0;
+	/* Convert priority back from NICE range */
+	atom->prio = ((prio << 16) / ((20 << 16) / 128)) - 128;
+	atom->atom_number = atom_nr;
+
+	atom->pre_dep[0] = 0;
+	atom->pre_dep[1] = 0;
+
+	atom->udata.blob[0] = 0;
+	atom->udata.blob[1] = 0;
+}
+
+/**
+ * @brief Create two atoms for the purpose of replaying jobs
+ *
+ * Two atoms are allocated and created. The jc pointer is not set at this
+ * stage. The second atom has a dependency on the first. The remaining fields
+ * are set up as follows :
+ *
+ * - No external resources. Any required external resources will be held by the
+ *   replay atom.
+ * - device_nr is set to 0. This is not relevant as
+ *   BASE_JD_REQ_SPECIFIC_COHERENT_GROUP should not be set.
+ * - Priority is inherited from the replay job.
+ *
+ * @param[out] t_atom      Atom to use for tiler jobs
+ * @param[out] f_atom      Atom to use for fragment jobs
+ * @param[in]  prio        Priority of new atom (inherited from replay soft
+ *                         job)
+ * @return MALI_ERROR_NONE on success, error code on failure
+ */
+static mali_error kbasep_replay_create_atoms(kbase_context *kctx,
+					     base_jd_atom_v2 *t_atom,
+					     base_jd_atom_v2 *f_atom,
+					     int prio)
+{
+	int t_atom_nr, f_atom_nr;
+
+	t_atom_nr = kbasep_allocate_katom(kctx);
+	if (t_atom_nr < 0) {
+		dev_err(kctx->kbdev->dev, "Failed to allocate katom\n");
+		return MALI_ERROR_FUNCTION_FAILED;
+	}
+
+	f_atom_nr = kbasep_allocate_katom(kctx);
+	if (f_atom_nr < 0) {
+		dev_err(kctx->kbdev->dev, "Failed to allocate katom\n");
+		kbasep_release_katom(kctx, t_atom_nr);
+		return MALI_ERROR_FUNCTION_FAILED;
+	}
+
+	kbasep_replay_create_atom(kctx, t_atom, t_atom_nr, prio);
+	kbasep_replay_create_atom(kctx, f_atom, f_atom_nr, prio);
+
+	f_atom->pre_dep[0] = t_atom_nr;
+
+	return MALI_ERROR_NONE;
+}
+
+#ifdef CONFIG_MALI_DEBUG
+static void payload_dump(kbase_context *kctx, base_jd_replay_payload *payload)
+{
+	mali_addr64 next;
+
+	KBASE_LOG(2, kctx->kbdev->dev, "Tiler jc list :\n");
+	next = payload->tiler_jc_list;
+
+	while (next) {
+		base_jd_replay_jc *jc_struct = kbasep_map_page(kctx, next, NULL);
+
+		if (!jc_struct)
+			return;
+
+		KBASE_LOG(2, kctx->kbdev->dev,
+					  "* jc_struct=%p jc=%llx next=%llx\n",
+								     jc_struct,
+								 jc_struct->jc,
+							      jc_struct->next);
+		next = jc_struct->next;
+
+		kbasep_unmap_page(jc_struct);
+	}
+}
+#endif
+
+/**
+ * @brief Parse a base_jd_replay_payload provided by userspace
+ *
+ * This will read the payload from userspace, and parse the job chains.
+ *
+ * @param[in] kctx         Context pointer
+ * @param[in] replay_atom  Replay soft job atom
+ * @param[in] t_atom       Atom to use for tiler jobs
+ * @param[in] f_atom       Atom to use for fragment jobs
+ * @return  MALI_ERROR_NONE on success, error code on failure
+ */
+static mali_error kbasep_replay_parse_payload(kbase_context *kctx, 
+					      kbase_jd_atom *replay_atom,
+					      base_jd_atom_v2 *t_atom,
+					      base_jd_atom_v2 *f_atom)
+{
+	base_jd_replay_payload *payload;
+	mali_addr64 next;
+	mali_addr64 prev_jc = 0;
+	u16 hw_job_id_offset = 0;
+	mali_error ret = MALI_ERROR_FUNCTION_FAILED;
+	u64 phys_addr;
+	struct device *dev = kctx->kbdev->dev;
+
+	KBASE_LOG(2, dev,
+			"kbasep_replay_parse_payload: replay_atom->jc = %llx  "
+			"sizeof(payload) = %d\n",
+					     replay_atom->jc, sizeof(payload));
+
+	kbase_gpu_vm_lock(kctx);
+
+	payload = kbasep_map_page_sync(kctx, replay_atom->jc, &phys_addr);
+
+	if (!payload) {
+		kbase_gpu_vm_unlock(kctx);
+		dev_err(dev, "kbasep_replay_parse_payload: failed to map payload into kernel space\n");
+		return MALI_ERROR_FUNCTION_FAILED;
+	}
+
+#ifdef CONFIG_MALI_DEBUG
+	KBASE_LOG(2, dev, "kbasep_replay_parse_payload: payload=%p\n", payload);
+	KBASE_LOG(2, dev, "Payload structure:\n"
+					"tiler_jc_list            = %llx\n"
+					"fragment_jc              = %llx\n"
+					"tiler_heap_free          = %llx\n"
+					"fragment_hierarchy_mask  = %x\n"
+					"tiler_hierarchy_mask     = %x\n"
+					"hierarchy_default_weight = %x\n"
+					"tiler_core_req           = %x\n"
+					"fragment_core_req        = %x\n",
+							payload->tiler_jc_list,
+							  payload->fragment_jc,
+						      payload->tiler_heap_free,
+					      payload->fragment_hierarchy_mask,
+						 payload->tiler_hierarchy_mask,
+					     payload->hierarchy_default_weight,
+						       payload->tiler_core_req,
+						   payload->fragment_core_req);
+	payload_dump(kctx, payload);
+#endif
+
+	t_atom->core_req = payload->tiler_core_req | BASEP_JD_REQ_EVENT_NEVER;
+	f_atom->core_req = payload->fragment_core_req | BASEP_JD_REQ_EVENT_NEVER;
+
+	/* Sanity check core requirements*/
+	if ((t_atom->core_req & BASEP_JD_REQ_ATOM_TYPE &
+			       ~BASE_JD_REQ_COHERENT_GROUP) != BASE_JD_REQ_T ||
+	    (f_atom->core_req & BASEP_JD_REQ_ATOM_TYPE &
+			      ~BASE_JD_REQ_COHERENT_GROUP) != BASE_JD_REQ_FS ||
+	     t_atom->core_req & BASE_JD_REQ_EXTERNAL_RESOURCES ||
+	     f_atom->core_req & BASE_JD_REQ_EXTERNAL_RESOURCES) {
+		dev_err(dev, "Invalid core requirements\n");
+		goto out;
+	}
+	
+	/* Process tiler job chains */
+	next = payload->tiler_jc_list;
+	if (!next) {
+		dev_err(dev, "Invalid tiler JC list\n");
+		goto out;
+	}
+
+	while (next) {
+		base_jd_replay_jc *jc_struct = kbasep_map_page(kctx, next, NULL);
+		mali_addr64 jc;
+
+		if (!jc_struct) {
+			dev_err(dev, "Failed to map jc struct\n");
+			goto out;
+		}
+
+		jc = jc_struct->jc;
+		next = jc_struct->next;
+		if (next)
+			jc_struct->jc = 0;
+
+		kbasep_unmap_page(jc_struct);
+
+		if (jc) {
+			u16 max_hw_job_id = 0;
+
+			if (kbasep_replay_find_hw_job_id(kctx, jc,
+					    &max_hw_job_id) != MALI_ERROR_NONE)
+				goto out;
+
+			if (kbasep_replay_parse_jc(kctx, jc, prev_jc,
+					     payload->tiler_heap_free,
+					     payload->tiler_hierarchy_mask,
+					     payload->hierarchy_default_weight,
+				             hw_job_id_offset, MALI_FALSE) !=
+							     MALI_ERROR_NONE) {
+				goto out;
+			}
+
+			hw_job_id_offset += max_hw_job_id;
+
+			prev_jc = jc;
+		}
+	}
+	t_atom->jc = prev_jc;
+
+	/* Process fragment job chain */
+	f_atom->jc = payload->fragment_jc;
+	if (kbasep_replay_parse_jc(kctx, payload->fragment_jc, 0,
+					 payload->tiler_heap_free,
+					 payload->fragment_hierarchy_mask,
+					 payload->hierarchy_default_weight, 0,
+					       MALI_TRUE) != MALI_ERROR_NONE) {
+		goto out;
+	}
+
+	if (!t_atom->jc || !f_atom->jc) {
+		dev_err(dev, "Invalid payload\n");
+		goto out;
+	}
+
+	KBASE_LOG(2, dev, "t_atom->jc=%llx f_atom->jc=%llx\n",
+						       t_atom->jc, f_atom->jc);
+	ret = MALI_ERROR_NONE;
+
+out:	
+	kbasep_unmap_page_sync(payload, phys_addr);
+
+	kbase_gpu_vm_unlock(kctx);
+
+	return ret;
+}
+
+/**
+ * @brief Process a replay job
+ *
+ * Called from kbase_process_soft_job.
+ *
+ * On exit, if the job has completed, katom->event_code will have been updated.
+ * If the job has not completed, and is replaying jobs, then the atom status
+ * will have been reset to KBASE_JD_ATOM_STATE_QUEUED.
+ *
+ * @param[in] katom  The atom to be processed
+ * @return           MALI_REPLAY_STATUS_COMPLETE  if the atom has completed
+ *                   MALI_REPLAY_STATUS_REPLAYING if the atom is replaying jobs
+ *                   Set MALI_REPLAY_FLAG_JS_RESCHED if 
+ *                   kbasep_js_try_schedule_head_ctx required
+ */
+int kbase_replay_process(kbase_jd_atom *katom)
+{
+	kbase_context *kctx = katom->kctx;
+	kbase_jd_context *jctx = &kctx->jctx;
+	mali_bool need_to_try_schedule_context = MALI_FALSE;
+	base_jd_atom_v2 t_atom, f_atom;
+	kbase_jd_atom *t_katom, *f_katom;
+	struct device *dev = kctx->kbdev->dev;
+
+	if (katom->event_code == BASE_JD_EVENT_DONE) {
+		KBASE_LOG(2, dev, "Previous job succeeded - not replaying\n");
+		return MALI_REPLAY_STATUS_COMPLETE;
+	}
+
+	if (jctx->sched_info.ctx.is_dying) {
+		KBASE_LOG(2, dev, "Not replaying; context is dying\n");
+		return MALI_REPLAY_STATUS_COMPLETE;
+	}
+
+	dev_warn(dev, "Replaying jobs retry=%d\n", katom->retry_count);
+
+	katom->retry_count++;
+	if (katom->retry_count > BASEP_JD_REPLAY_LIMIT) {
+		dev_err(dev, "Replay exceeded limit - failing jobs\n");
+		/* katom->event_code is already set to the failure code of the
+		   previous job */
+		return MALI_REPLAY_STATUS_COMPLETE;
+	}
+
+	if (kbasep_replay_create_atoms(kctx, &t_atom, &f_atom,
+				       katom->nice_prio) != MALI_ERROR_NONE) {
+		katom->event_code = BASE_JD_EVENT_JOB_CANCELLED;
+		return MALI_REPLAY_STATUS_COMPLETE;
+	}
+
+	t_katom = &jctx->atoms[t_atom.atom_number];
+	f_katom = &jctx->atoms[f_atom.atom_number];
+
+	if (kbasep_replay_parse_payload(kctx, katom, &t_atom, &f_atom) !=
+							     MALI_ERROR_NONE) {
+		kbasep_release_katom(kctx, t_atom.atom_number);
+		kbasep_release_katom(kctx, f_atom.atom_number);
+		katom->event_code = BASE_JD_EVENT_JOB_CANCELLED;
+		return MALI_REPLAY_STATUS_COMPLETE;
+	}
+
+	kbasep_replay_reset_softjob(katom, f_katom);
+
+	need_to_try_schedule_context |= jd_submit_atom(kctx, &t_atom, t_katom);
+	if (t_katom->event_code == BASE_JD_EVENT_JOB_INVALID) {
+		dev_err(dev, "Replay failed to submit atom\n");
+		kbasep_release_katom(kctx, f_atom.atom_number);
+		katom->event_code = BASE_JD_EVENT_JOB_CANCELLED;
+		katom->status = KBASE_JD_ATOM_STATE_COMPLETED;
+		return MALI_REPLAY_STATUS_COMPLETE;
+	}
+	need_to_try_schedule_context |= jd_submit_atom(kctx, &f_atom, f_katom);
+	if (f_katom->event_code == BASE_JD_EVENT_JOB_INVALID) {
+		dev_err(dev, "Replay failed to submit atom\n");
+		katom->event_code = BASE_JD_EVENT_JOB_CANCELLED;
+		katom->status = KBASE_JD_ATOM_STATE_COMPLETED;
+		return MALI_REPLAY_STATUS_COMPLETE;
+	}
+
+	katom->event_code = BASE_JD_EVENT_DONE;
+
+	if (need_to_try_schedule_context)
+		return MALI_REPLAY_STATUS_REPLAYING | 
+						MALI_REPLAY_FLAG_JS_RESCHED;
+	return MALI_REPLAY_STATUS_REPLAYING;
+}
+
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_security.c b/drivers/gpu/arm/midgard/mali_kbase_security.c
old mode 100644
new mode 100755
similarity index 93%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_security.c
rename to drivers/gpu/arm/midgard/mali_kbase_security.c
index 3390a9fe9091..babde223891a
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_security.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_security.c
@@ -22,7 +22,7 @@
  * Base kernel security capability API
  */
 
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 
 static inline mali_bool kbasep_am_i_root(void)
 {
@@ -69,7 +69,7 @@ mali_bool kbase_security_has_capability(kbase_context *kctx, kbase_security_capa
 	/* Report problem if requested */
 	if (MALI_FALSE == access_allowed) {
 		if (MALI_FALSE != audit)
-			KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Security capability failure: %d, %p", cap, (void *)kctx);
+			dev_warn(kctx->kbdev->dev, "Security capability failure: %d, %p", cap, (void *)kctx);
 	}
 
 	return access_allowed;
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_security.h b/drivers/gpu/arm/midgard/mali_kbase_security.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_security.h
rename to drivers/gpu/arm/midgard/mali_kbase_security.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_softjobs.c b/drivers/gpu/arm/midgard/mali_kbase_softjobs.c
old mode 100644
new mode 100755
similarity index 94%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_softjobs.c
rename to drivers/gpu/arm/midgard/mali_kbase_softjobs.c
index f06b60c593c0..92bf0b754b43
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_softjobs.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_softjobs.c
@@ -17,13 +17,13 @@
 
 
 
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 
 #ifdef CONFIG_SYNC
 //#include <linux/sync.h>
 #include "sync.h"
 #include <linux/syscalls.h>
-#include "../linux/mali_kbase_sync.h"
+#include "mali_kbase_sync.h"
 #endif
 
 
@@ -275,7 +275,8 @@ static void kbase_fence_cancel_wait(kbase_jd_atom *katom)
 
 int kbase_process_soft_job(kbase_jd_atom *katom)
 {
-	switch (katom->core_req) {
+	int status;
+	switch (katom->core_req & BASEP_JD_REQ_ATOM_TYPE) {
 	case BASE_JD_REQ_SOFT_DUMP_CPU_GPU_TIME:
 		return kbase_dump_cpu_gpu_time(katom);
 #ifdef CONFIG_SYNC
@@ -289,6 +290,11 @@ int kbase_process_soft_job(kbase_jd_atom *katom)
 	case BASE_JD_REQ_SOFT_FENCE_WAIT:
 		return kbase_fence_wait(katom);
 #endif				/* CONFIG_SYNC */
+	case BASE_JD_REQ_SOFT_REPLAY:
+		status = kbase_replay_process(katom);
+		if (status & MALI_REPLAY_FLAG_JS_RESCHED)
+			pr_err("replay called from kbase_process_soft_job - missing resched!\n");
+		return status & MALI_REPLAY_STATUS_MASK;
 	}
 
 	/* Atom is complete */
@@ -297,7 +303,7 @@ int kbase_process_soft_job(kbase_jd_atom *katom)
 
 void kbase_cancel_soft_job(kbase_jd_atom *katom)
 {
-	switch (katom->core_req) {
+	switch (katom->core_req & BASEP_JD_REQ_ATOM_TYPE) {
 #ifdef CONFIG_SYNC
 	case BASE_JD_REQ_SOFT_FENCE_WAIT:
 		kbase_fence_cancel_wait(katom);
@@ -311,7 +317,7 @@ void kbase_cancel_soft_job(kbase_jd_atom *katom)
 
 mali_error kbase_prepare_soft_job(kbase_jd_atom *katom)
 {
-	switch (katom->core_req) {
+	switch (katom->core_req & BASEP_JD_REQ_ATOM_TYPE) {
 	case BASE_JD_REQ_SOFT_DUMP_CPU_GPU_TIME:
 		{
 			if(0 != (katom->jc & KBASE_CACHE_ALIGNMENT_MASK))
@@ -358,6 +364,8 @@ mali_error kbase_prepare_soft_job(kbase_jd_atom *katom)
 		}
 		break;
 #endif				/* CONFIG_SYNC */
+	case BASE_JD_REQ_SOFT_REPLAY:
+		break;
 	default:
 		/* Unsupported soft-job */
 		return MALI_ERROR_FUNCTION_FAILED;
@@ -367,7 +375,7 @@ mali_error kbase_prepare_soft_job(kbase_jd_atom *katom)
 
 void kbase_finish_soft_job(kbase_jd_atom *katom)
 {
-	switch (katom->core_req) {
+	switch (katom->core_req & BASEP_JD_REQ_ATOM_TYPE) {
 	case BASE_JD_REQ_SOFT_DUMP_CPU_GPU_TIME:
 		/* Nothing to do */
 		break;
@@ -422,6 +430,8 @@ void kbase_resume_suspended_soft_jobs(kbase_device *kbdev)
 			resched |= jd_done_nolock(katom_iter);
 		} else {
 			/* The job has not completed */
+			KBASE_DEBUG_ASSERT((katom_iter->core_req & BASEP_JD_REQ_ATOM_TYPE)
+						  		!= BASE_JD_REQ_SOFT_REPLAY);
 			list_add_tail(&katom_iter->dep_item[0], &kctx->waiting_soft_jobs);
 		}
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_sync.c b/drivers/gpu/arm/midgard/mali_kbase_sync.c
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_sync.c
rename to drivers/gpu/arm/midgard/mali_kbase_sync.c
index b09c1813c703..57b2d7433500
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_sync.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_sync.c
@@ -26,7 +26,7 @@
 
 //#include <linux/sync.h>
 #include "sync.h"
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 
 struct mali_sync_timeline {
 	struct sync_timeline timeline;
@@ -186,7 +186,7 @@ void kbase_sync_signal_pt(struct sync_pt *pt, int result)
 			 * a malicious user being able to spam dmesg.
 			 */
 #ifdef CONFIG_MALI_DEBUG
-			KBASE_DEBUG_PRINT_ERROR(KBASE_JD, "Fences were triggered in a different order to allocation!");
+			pr_err("Fences were triggered in a different order to allocation!");
 #endif				/* CONFIG_MALI_DEBUG */
 			return;
 		}
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_sync.h b/drivers/gpu/arm/midgard/mali_kbase_sync.h
old mode 100644
new mode 100755
similarity index 98%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_sync.h
rename to drivers/gpu/arm/midgard/mali_kbase_sync.h
index a0d99c7af3b8..b9f295146c7c
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_sync.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_sync.h
@@ -25,7 +25,6 @@
 #ifndef MALI_KBASE_SYNC_H
 #define MALI_KBASE_SYNC_H
 
-//#include <linux/sync.h>
 #include "sync.h"
 #include <malisw/mali_malisw.h>
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_sync_user.c b/drivers/gpu/arm/midgard/mali_kbase_sync_user.c
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_sync_user.c
rename to drivers/gpu/arm/midgard/mali_kbase_sync_user.c
index 6610a206bcb9..53a936f6b05c
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_kbase_sync_user.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_sync_user.c
@@ -32,8 +32,8 @@
 #include <linux/anon_inodes.h>
 #include <linux/version.h>
 #include <linux/uaccess.h>
-#include <kbase/src/linux/mali_kbase_sync.h>
-#include <kbase/mali_base_kernel_sync.h>
+#include <mali_kbase_sync.h>
+#include <mali_base_kernel_sync.h>
 
 static int kbase_stream_close(struct inode *inode, struct file *file)
 {
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_trace_defs.h b/drivers/gpu/arm/midgard/mali_kbase_trace_defs.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_trace_defs.h
rename to drivers/gpu/arm/midgard/mali_kbase_trace_defs.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_trace_timeline.c b/drivers/gpu/arm/midgard/mali_kbase_trace_timeline.c
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_trace_timeline.c
rename to drivers/gpu/arm/midgard/mali_kbase_trace_timeline.c
index e2503ca67a95..0968025359c1
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_trace_timeline.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_trace_timeline.c
@@ -17,8 +17,8 @@
 
 
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_jm.h>
+#include <mali_kbase.h>
+#include <mali_kbase_jm.h>
 
 #define CREATE_TRACE_POINTS
 
@@ -97,7 +97,9 @@ static const struct file_operations kbasep_trace_timeline_debugfs_fops = {
 
 mali_error kbasep_trace_timeline_debugfs_init(kbase_device *kbdev)
 {
-	kbdev->timeline.dentry = debugfs_create_file("mali_timeline_defs", S_IRUGO, NULL, NULL, &kbasep_trace_timeline_debugfs_fops);
+	kbdev->timeline.dentry = debugfs_create_file("mali_timeline_defs",
+			S_IRUGO, kbdev->mali_debugfs_directory, NULL,
+			&kbasep_trace_timeline_debugfs_fops);
 	if (IS_ERR(kbdev->timeline.dentry))
 		return MALI_ERROR_FUNCTION_FAILED;
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_trace_timeline.h b/drivers/gpu/arm/midgard/mali_kbase_trace_timeline.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_trace_timeline.h
rename to drivers/gpu/arm/midgard/mali_kbase_trace_timeline.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_trace_timeline_defs.h b/drivers/gpu/arm/midgard/mali_kbase_trace_timeline_defs.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_trace_timeline_defs.h
rename to drivers/gpu/arm/midgard/mali_kbase_trace_timeline_defs.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_uku.h b/drivers/gpu/arm/midgard/mali_kbase_uku.h
old mode 100644
new mode 100755
similarity index 90%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_uku.h
rename to drivers/gpu/arm/midgard/mali_kbase_uku.h
index eaa6d04d418d..a6c277176c28
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_uku.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_uku.h
@@ -20,9 +20,9 @@
 #ifndef _KBASE_UKU_H_
 #define _KBASE_UKU_H_
 
-#include <kbase/mali_uk.h>
+#include "mali_uk.h"
 #include <malisw/mali_malisw.h>
-#include <kbase/mali_base_kernel.h>
+#include "mali_base_kernel.h"
 
 /* This file needs to support being included from kernel and userside (which use different defines) */
 #if defined(CONFIG_MALI_ERROR_INJECT)
@@ -41,12 +41,12 @@
 #endif
 
 #if defined(SUPPORT_MALI_NO_MALI) || defined(SUPPORT_MALI_ERROR_INJECT)
-#include <kbase/src/common/mali_kbase_model_dummy.h>
+#include "mali_kbase_model_dummy.h"
 #endif
 
 #include "mali_kbase_gpuprops_types.h"
 
-#define BASE_UK_VERSION_MAJOR 5
+#define BASE_UK_VERSION_MAJOR 6
 #define BASE_UK_VERSION_MINOR 0
 
 typedef struct kbase_uk_mem_alloc {
@@ -70,6 +70,22 @@ typedef struct kbase_uk_mem_free {
 	/* OUT */
 } kbase_uk_mem_free;
 
+/* used by both aliasing and importing */
+#define KBASE_MEM_NEED_MMAP         (1UL << BASE_MEM_FLAGS_NR_BITS)
+
+typedef struct kbase_uk_mem_alias {
+	uk_header header;
+	/* IN/OUT */
+	u64 flags;
+	/* IN */
+	u64 stride;
+	u64 nents;
+	kbase_pointer ai;
+	/* OUT */
+	u64         gpu_va;
+	u64         va_pages;
+} kbase_uk_mem_alias;
+
 typedef struct kbase_uk_mem_import {
 	uk_header header;
 	/* IN */
@@ -77,7 +93,6 @@ typedef struct kbase_uk_mem_import {
 	u32 type;
 	u32 padding;
 	/* IN/OUT */
-#define KBASE_MEM_IMPORT_MMAP         (1UL << BASE_MEM_FLAGS_NR_BITS)
 #define KBASE_MEM_IMPORT_HAVE_PAGES   (1UL << (BASE_MEM_FLAGS_NR_BITS + 1))
 	u64         flags;
 	/* OUT */
@@ -192,16 +207,15 @@ typedef struct kbase_uk_mem_commit {
 	u32 padding;
 } kbase_uk_mem_commit;
 
-typedef struct kbase_uk_find_cpu_mapping {
+typedef struct kbase_uk_find_cpu_offset {
 	uk_header header;
 	/* IN */
 	mali_addr64 gpu_addr;
 	u64 cpu_addr;
 	u64 size;
 	/* OUT */
-	u64 uaddr;
-	mali_size64 page_off;
-} kbase_uk_find_cpu_mapping;
+	mali_size64 offset;
+} kbase_uk_find_cpu_offset;
 
 #define KBASE_GET_VERSION_BUFFER_SIZE 64
 typedef struct kbase_uk_get_ddk_version {
@@ -283,6 +297,7 @@ typedef enum kbase_uk_function_id {
 	KBASE_FUNC_MEM_QUERY,
 	KBASE_FUNC_MEM_FREE,
 	KBASE_FUNC_MEM_FLAGS_CHANGE,
+	KBASE_FUNC_MEM_ALIAS,
 
 	KBASE_FUNC_JOB_SUBMIT,
 
@@ -297,7 +312,7 @@ typedef enum kbase_uk_function_id {
 	KBASE_FUNC_CPU_PROPS_REG_DUMP,
 	KBASE_FUNC_GPU_PROPS_REG_DUMP,
 
-	KBASE_FUNC_FIND_CPU_MAPPING,
+	KBASE_FUNC_FIND_CPU_OFFSET,
 
 	KBASE_FUNC_GET_VERSION,
 	KBASE_FUNC_EXT_BUFFER_LOCK,
@@ -312,7 +327,9 @@ typedef enum kbase_uk_function_id {
 	KBASE_FUNC_FENCE_VALIDATE,
 	KBASE_FUNC_STREAM_CREATE,
 	KBASE_FUNC_GET_PROFILING_CONTROLS,
-	KBASE_FUNC_SET_PROFILING_CONTROLS /* to be used only for testing purposes, otherwise these controls are set through gator API */
+	KBASE_FUNC_SET_PROFILING_CONTROLS /* to be used only for testing
+					   * purposes, otherwise these controls
+					   * are set through gator API */
 } kbase_uk_function_id;
 
 #endif				/* _KBASE_UKU_H_ */
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_utility.c b/drivers/gpu/arm/midgard/mali_kbase_utility.c
old mode 100644
new mode 100755
similarity index 94%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_utility.c
rename to drivers/gpu/arm/midgard/mali_kbase_utility.c
index 9c2aef9d1d1b..c11c678e3b18
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_utility.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_utility.c
@@ -17,7 +17,7 @@
 
 
 
-#include <kbase/src/common/mali_kbase.h>
+#include <mali_kbase.h>
 
 mali_bool kbasep_list_member_of(const struct list_head *base, struct list_head *entry)
 {
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_utility.h b/drivers/gpu/arm/midgard/mali_kbase_utility.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_utility.h
rename to drivers/gpu/arm/midgard/mali_kbase_utility.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_linux_trace.h b/drivers/gpu/arm/midgard/mali_linux_trace.h
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/linux/mali_linux_trace.h
rename to drivers/gpu/arm/midgard/mali_linux_trace.h
index 5ed9f61fc0ce..537610b49d36
--- a/drivers/gpu/arm/t6xx/kbase/src/linux/mali_linux_trace.h
+++ b/drivers/gpu/arm/midgard/mali_linux_trace.h
@@ -101,8 +101,8 @@ TRACE_EVENT(mali_mmu_as_released, TP_PROTO(int event_id), TP_ARGS(event_id), TP_
 	);
 
 /**
- * mali_total_alloc_pages_change - Called by kbase_mem_usage_request_pages()
- *                                 and by kbase_mem_usage_release_pages
+ * mali_total_alloc_pages_change - Called by kbase_atomic_add_pages()
+ *                                 and by kbase_atomic_sub_pages()
  * it reports that the total number of allocated pages is changed.
  * @event_id: number of pages to be added or subtracted (according to the sign).
  */
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_midg_regmap.h b/drivers/gpu/arm/midgard/mali_midg_regmap.h
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_midg_regmap.h
rename to drivers/gpu/arm/midgard/mali_midg_regmap.h
index 1b4c6ef62896..c40d74004ec1
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_midg_regmap.h
+++ b/drivers/gpu/arm/midgard/mali_midg_regmap.h
@@ -52,8 +52,7 @@
 #define CLEAN_CACHES_COMPLETED  (1 << 17)	/* Set when a cache clean operation has completed. */
 
 #define GPU_IRQ_REG_ALL (GPU_FAULT | MULTIPLE_GPU_FAULTS | RESET_COMPLETED \
-			| POWER_CHANGED_ALL | PRFCNT_SAMPLE_COMPLETED \
-			| CLEAN_CACHES_COMPLETED)
+			| POWER_CHANGED_ALL | PRFCNT_SAMPLE_COMPLETED)
 
 #define GPU_COMMAND             0x030	/* (WO) */
 #define GPU_STATUS              0x034	/* (RO) */
@@ -332,7 +331,7 @@
 #define ASn_COMMAND_LOCK        0x02	/* Issue a lock region command to all MMUs */
 #define ASn_COMMAND_UNLOCK      0x03	/* Issue a flush region command to all MMUs */
 #define ASn_COMMAND_FLUSH       0x04	/* Flush all L2 caches then issue a flush region command to all MMUs
-					   (deprecated - only for use with T60x/T65x) */
+					   (deprecated - only for use with T60x) */
 #define ASn_COMMAND_FLUSH_PT    0x04	/* Flush all L2 caches then issue a flush region command to all MMUs */
 #define ASn_COMMAND_FLUSH_MEM   0x05	/* Wait for memory accesses to complete, flush all the L1s cache then
 					   flush all L2 caches then issue a flush region command to all MMUs */
@@ -410,9 +409,21 @@
 #define PRFCNT_CONFIG_MODE_MANUAL 1	/* The performance counters are enabled, but are only written out when a PRFCNT_SAMPLE command is issued using the GPU_COMMAND register. */
 #define PRFCNT_CONFIG_MODE_TILE   2	/* The performance counters are enabled, and are written out each time a tile finishes rendering. */
 
-/* AS<n>_MEMATTR values */
-#define ASn_MEMATTR_IMPL_DEF_CACHE_POLICY 0x48484848	/* Use GPU implementation-defined caching policy. */
-#define ASn_MEMATTR_FORCE_TO_CACHE_ALL    0x4F4F4F4F	/* The attribute set to force all resources to be cached. */
+/* AS<n>_MEMATTR values: */
+/* Use GPU implementation-defined  caching policy. */
+#define ASn_MEMATTR_IMPL_DEF_CACHE_POLICY 0x48
+/* The attribute set to force all resources to be cached. */
+#define ASn_MEMATTR_FORCE_TO_CACHE_ALL    0x4F
+/* Inner write-alloc cache setup, no outer caching */
+#define ASn_MEMATTR_WRITE_ALLOC           0x4D
+/* symbol for default MEMATTR to use */
+#define ASn_MEMATTR_INDEX_DEFAULT               0
+/* HW implementation defined caching */
+#define ASn_MEMATTR_INDEX_IMPL_DEF_CACHE_POLICY 0
+/* Force cache on */
+#define ASn_MEMATTR_INDEX_FORCE_TO_CACHE_ALL    1
+/* Write-alloc inner */
+#define ASn_MEMATTR_INDEX_WRITE_ALLOC           2
 
 /* GPU_ID register */
 #define GPU_ID_VERSION_STATUS_SHIFT       0
@@ -426,13 +437,12 @@
 
 /* Values for GPU_ID_VERSION_PRODUCT_ID bitfield */
 #define GPU_ID_PI_T60X                    0x6956
-#define GPU_ID_PI_T65X                    0x3456
 #define GPU_ID_PI_T62X                    0x0620
 #define GPU_ID_PI_T67X                    0x0670
 #define GPU_ID_PI_T76X                    0x0750
 #define GPU_ID_PI_T72X                    0x0720
 
-/* Values for GPU_ID_VERSION_STATUS field for PRODUCT_ID GPU_ID_PI_T60X and GPU_ID_PI_T65X */
+/* Values for GPU_ID_VERSION_STATUS field for PRODUCT_ID GPU_ID_PI_T60X */
 #define GPU_ID_S_15DEV0                   0x1
 #define GPU_ID_S_EAC                      0x2
 
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_timeline.h b/drivers/gpu/arm/midgard/mali_timeline.h
old mode 100644
new mode 100755
similarity index 99%
rename from drivers/gpu/arm/t6xx/kbase/src/common/mali_timeline.h
rename to drivers/gpu/arm/midgard/mali_timeline.h
index d0c2f303df93..f8b8710fcf9e
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_timeline.h
+++ b/drivers/gpu/arm/midgard/mali_timeline.h
@@ -362,7 +362,7 @@ TRACE_EVENT(mali_timeline_pm_checktrans,
 #endif				/* _MALI_TIMELINE_H */
 
 #undef TRACE_INCLUDE_PATH
-#define TRACE_INCLUDE_PATH kbase/src/common
+#define TRACE_INCLUDE_PATH .
 
 /* This part must be outside protection */
 #include <trace/define_trace.h>
diff --git a/drivers/gpu/arm/t6xx/kbase/mali_uk.h b/drivers/gpu/arm/midgard/mali_uk.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/mali_uk.h
rename to drivers/gpu/arm/midgard/mali_uk.h
diff --git a/drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd.h b/drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd.h
rename to drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd.h
diff --git a/drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_compilers.h b/drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_compilers.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_compilers.h
rename to drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_compilers.h
diff --git a/drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_pack_pop.h b/drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_pack_pop.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_pack_pop.h
rename to drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_pack_pop.h
diff --git a/drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_pack_push.h b/drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_pack_push.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_pack_push.h
rename to drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_pack_push.h
diff --git a/drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_types.h b/drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_types.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_types.h
rename to drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_types.h
diff --git a/drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_types_gcc.h b/drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_types_gcc.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_types_gcc.h
rename to drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_types_gcc.h
diff --git a/drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_types_rvct.h b/drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_types_rvct.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/malisw/arm_cstd/arm_cstd_types_rvct.h
rename to drivers/gpu/arm/midgard/malisw/arm_cstd/arm_cstd_types_rvct.h
diff --git a/drivers/gpu/arm/t6xx/kbase/malisw/mali_malisw.h b/drivers/gpu/arm/midgard/malisw/mali_malisw.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/malisw/mali_malisw.h
rename to drivers/gpu/arm/midgard/malisw/mali_malisw.h
diff --git a/drivers/gpu/arm/t6xx/kbase/malisw/mali_stdtypes.h b/drivers/gpu/arm/midgard/malisw/mali_stdtypes.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/malisw/mali_stdtypes.h
rename to drivers/gpu/arm/midgard/malisw/mali_stdtypes.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/platform/Kbuild b/drivers/gpu/arm/midgard/platform/Kbuild
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/platform/Kbuild
rename to drivers/gpu/arm/midgard/platform/Kbuild
diff --git a/drivers/gpu/arm/t6xx/kbase/src/platform/Kconfig b/drivers/gpu/arm/midgard/platform/Kconfig
old mode 100644
new mode 100755
similarity index 91%
rename from drivers/gpu/arm/t6xx/kbase/src/platform/Kconfig
rename to drivers/gpu/arm/midgard/platform/Kconfig
index 3d96a0808506..8fb4e917c4fa
--- a/drivers/gpu/arm/t6xx/kbase/src/platform/Kconfig
+++ b/drivers/gpu/arm/midgard/platform/Kconfig
@@ -17,7 +17,7 @@
 
 # Add your platform specific Kconfig file here
 #
-# "drivers/gpu/arm/t6xx/kbase/src/platform/xxx/Kconfig"
+# "drivers/gpu/arm/midgard/platform/xxx/Kconfig"
 #
 # Where xxx is the platform name is the name set in MALI_PLATFORM_THIRDPARTY_NAME
 #
diff --git a/drivers/gpu/arm/t6xx/kbase/src/platform/mali_kbase_platform_common.h b/drivers/gpu/arm/midgard/platform/mali_kbase_platform_common.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/src/platform/mali_kbase_platform_common.h
rename to drivers/gpu/arm/midgard/platform/mali_kbase_platform_common.h
diff --git a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/Kbuild b/drivers/gpu/arm/midgard/platform/rk/Kbuild
old mode 100644
new mode 100755
similarity index 91%
rename from drivers/gpu/arm/t6xx/kbase/src/platform/rk/Kbuild
rename to drivers/gpu/arm/midgard/platform/rk/Kbuild
index 726489895375..0e323b2c3256
--- a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/Kbuild
+++ b/drivers/gpu/arm/midgard/platform/rk/Kbuild
@@ -13,11 +13,11 @@
 #
 
 ccflags-y += -I$(srctree)/drivers/staging/android
-ifeq ($(CONFIG_MALI_T6XX),y)
+ifeq ($(CONFIG_MALI_MIDGARD),y)
 obj-y += mali_kbase_config_rk.o
 obj-y += mali_kbase_dvfs.o
 obj-y += mali_kbase_platform.o
-else ifeq ($(CONFIG_MALI_T6XX),m)
+else ifeq ($(CONFIG_MALI_MIDGARD),m)
 SRC += platform/rk/mali_kbase_config_rk.c
 SRC += platform/rk/mali_kbase_dvfs.c
 SRC += platform/rk/mali_kbase_platform.c
diff --git a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_config_rk.c b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_config_rk.c
similarity index 86%
rename from drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_config_rk.c
rename to drivers/gpu/arm/midgard/platform/rk/mali_kbase_config_rk.c
index bd7a913ebc10..ac66fd035d2b 100755
--- a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_config_rk.c
+++ b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_config_rk.c
@@ -18,21 +18,21 @@
 
 
 #include <linux/ioport.h>
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_defs.h>
-#include <kbase/mali_kbase_config.h>
+#include <mali_kbase.h>
+#include <mali_kbase_defs.h>
+#include <mali_kbase_config.h>
 #ifdef CONFIG_UMP
 #include <linux/ump-common.h>
 #endif				/* CONFIG_UMP */
-#include <kbase/src/platform/rk/mali_kbase_platform.h>
-#include <kbase/src/platform/rk/mali_kbase_dvfs.h>
+#include <platform/rk/mali_kbase_platform.h>
+#include <platform/rk/mali_kbase_dvfs.h>
 #include <linux/pm_runtime.h>
 #include <linux/suspend.h>
 
 int get_cpu_clock_speed(u32 *cpu_clock);
 
 #define HZ_IN_MHZ                           (1000000)
-#ifdef CONFIG_MALI_T6XX_RT_PM
+#ifdef CONFIG_MALI_MIDGARD_RT_PM
 #define RUNTIME_PM_DELAY_TIME 100
 #endif
 
@@ -107,14 +107,16 @@ static int mali_pm_notifier(struct notifier_block *nb,unsigned long event,void*
 	int err = NOTIFY_OK;
 	switch (event) {
 		case PM_SUSPEND_PREPARE:
-#ifdef CONFIG_MALI_T6XX_DVFS
-			if (kbase_platform_dvfs_enable(false, MALI_DVFS_BL_CONFIG_FREQ)!= MALI_TRUE)
+#ifdef CONFIG_MALI_MIDGARD_DVFS
+			//if (kbase_platform_dvfs_enable(false, MALI_DVFS_BL_CONFIG_FREQ)!= MALI_TRUE)
+			if (kbase_platform_dvfs_enable(false, p_mali_dvfs_infotbl[MALI_DVFS_STEP-1].clock)!= MALI_TRUE)
 				err = NOTIFY_BAD;
 #endif
 			break;
 		case PM_POST_SUSPEND:
-#ifdef CONFIG_MALI_T6XX_DVFS
-			if (kbase_platform_dvfs_enable(true, MALI_DVFS_START_FREQ)!= MALI_TRUE)
+#ifdef CONFIG_MALI_MIDGARD_DVFS
+			//if (kbase_platform_dvfs_enable(true, MALI_DVFS_START_FREQ)!= MALI_TRUE)
+			if (kbase_platform_dvfs_enable(true, p_mali_dvfs_infotbl[0].clock)!= MALI_TRUE)
 				err = NOTIFY_BAD;
 #endif
 			break;
@@ -145,9 +147,9 @@ mali_bool kbase_platform_rk_init(kbase_device *kbdev)
 void kbase_platform_rk_term(kbase_device *kbdev)
 {
 	unregister_pm_notifier(&mali_pm_nb);
-#ifdef CONFIG_MALI_T6XX_DEBUG_SYS
-	kbase_platform_remove_sysfs_file(kbdev->osdev.dev);
-#endif				/* CONFIG_MALI_T6XX_DEBUG_SYS */
+#ifdef CONFIG_MALI_MIDGARD_DEBUG_SYS
+	kbase_platform_remove_sysfs_file(kbdev->dev);
+#endif				/* CONFIG_MALI_MIDGARD_DEBUG_SYS */
 	kbase_platform_term(kbdev);
 }
 
@@ -156,27 +158,27 @@ kbase_platform_funcs_conf platform_funcs = {
 	.platform_term_func = &kbase_platform_rk_term,
 };
 
-#ifdef CONFIG_MALI_T6XX_RT_PM
+#ifdef CONFIG_MALI_MIDGARD_RT_PM
 static int pm_callback_power_on(kbase_device *kbdev)
 {
 	int result;
 	int ret_val;
-	struct kbase_os_device *osdev = &kbdev->osdev;
+	struct device *dev = kbdev->dev;
 	struct rk_context *platform;
 
 	platform = (struct rk_context *)kbdev->platform_context;
 
-	if (pm_runtime_status_suspended(osdev->dev))
+	if (pm_runtime_status_suspended(dev))
 		ret_val = 1;
 	else
 		ret_val = 0;
 
-	if(osdev->dev->power.disable_depth > 0) {
+	if(dev->power.disable_depth > 0) {
 		if(platform->cmu_pmu_status == 0)
 			kbase_platform_cmu_pmu_control(kbdev, 1);
 		return ret_val;
 	}
-	result = pm_runtime_resume(osdev->dev);
+	result = pm_runtime_resume(dev);
 
 	if (result < 0 && result == -EAGAIN)
 		kbase_platform_cmu_pmu_control(kbdev, 1);
@@ -188,35 +190,36 @@ static int pm_callback_power_on(kbase_device *kbdev)
 
 static void pm_callback_power_off(kbase_device *kbdev)
 {
-	struct kbase_os_device *osdev = &kbdev->osdev;
-	pm_schedule_suspend(osdev->dev, RUNTIME_PM_DELAY_TIME);
+	struct device *dev = kbdev->dev;
+	pm_schedule_suspend(dev, RUNTIME_PM_DELAY_TIME);
 }
 
 mali_error kbase_device_runtime_init(struct kbase_device *kbdev)
 {
-	pm_suspend_ignore_children(kbdev->osdev.dev, true);
-	pm_runtime_enable(kbdev->osdev.dev);
-#ifdef CONFIG_MALI_T6XX_DEBUG_SYS
-	if (kbase_platform_create_sysfs_file(kbdev->osdev.dev))
+	pm_suspend_ignore_children(kbdev->dev, true);
+	pm_runtime_enable(kbdev->dev);
+#ifdef CONFIG_MALI_MIDGARD_DEBUG_SYS
+	if (kbase_platform_create_sysfs_file(kbdev->dev))
 		return MALI_ERROR_FUNCTION_FAILED;
-#endif				/* CONFIG_MALI_T6XX_DEBUG_SYS */
+#endif				/* CONFIG_MALI_MIDGARD_DEBUG_SYS */
 	return MALI_ERROR_NONE;
 }
 
 void kbase_device_runtime_disable(struct kbase_device *kbdev)
 {
-	pm_runtime_disable(kbdev->osdev.dev);
+	pm_runtime_disable(kbdev->dev);
 }
 
 static int pm_callback_runtime_on(kbase_device *kbdev)
 {
-#ifdef CONFIG_MALI_T6XX_DVFS	
+#ifdef CONFIG_MALI_MIDGARD_DVFS	
 	struct rk_context *platform = (struct rk_context *)kbdev->platform_context;
 #endif
 	kbase_platform_clock_on(kbdev);
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	if (platform->dvfs_enabled) {
-		if (kbase_platform_dvfs_enable(true, MALI_DVFS_START_FREQ)!= MALI_TRUE)
+		//if (kbase_platform_dvfs_enable(true, MALI_DVFS_START_FREQ)!= MALI_TRUE)
+		if (kbase_platform_dvfs_enable(true, p_mali_dvfs_infotbl[0].clock)!= MALI_TRUE)
 			return -EPERM;
 	} else {
 		if (kbase_platform_dvfs_enable(false, MALI_DVFS_CURRENT_FREQ)!= MALI_TRUE)
@@ -229,7 +232,7 @@ static int pm_callback_runtime_on(kbase_device *kbdev)
 static void pm_callback_runtime_off(kbase_device *kbdev)
 {
 	kbase_platform_clock_off(kbdev);
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	if (kbase_platform_dvfs_enable(false, MALI_DVFS_CURRENT_FREQ)!= MALI_TRUE)
 		printk("[err] disabling dvfs is faled\n");
 #endif
@@ -257,7 +260,7 @@ static kbase_pm_callback_conf pm_callbacks = {
 
 /* Please keep table config_attributes in sync with config_attributes_hw_issue_8408 */
 static kbase_attribute config_attributes[] = {
-#if 0
+#if 0	
 	{
 	 KBASE_CONFIG_ATTR_MEMORY_PER_PROCESS_LIMIT,
 	 KBASE_VE_MEMORY_PER_PROCESS_LIMIT},
@@ -267,7 +270,7 @@ static kbase_attribute config_attributes[] = {
 	 KBASE_CONFIG_ATTR_UMP_DEVICE,
 	 KBASE_VE_UMP_DEVICE},
 #endif				/* CONFIG_UMP */
-#ifdef CONFIG_MALI_T6XX_RT_PM
+#ifdef CONFIG_MALI_MIDGARD_RT_PM
 	{
 	 KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS,
 	 (uintptr_t)&pm_callbacks},
@@ -277,11 +280,11 @@ static kbase_attribute config_attributes[] = {
 	 KBASE_CONFIG_ATTR_MEMORY_OS_SHARED_MAX,
 	 KBASE_VE_MEMORY_OS_SHARED_MAX},
 #endif
-#if 1
+#if 0
 	{
 	 KBASE_CONFIG_ATTR_MEMORY_OS_SHARED_PERF_GPU,
 	 KBASE_VE_MEMORY_OS_SHARED_PERF_GPU},
-#endif
+#endif	
 	{
 	 KBASE_CONFIG_ATTR_PLATFORM_FUNCS,
 	 (uintptr_t) &platform_funcs},
diff --git a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_dvfs.c b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_dvfs.c
similarity index 76%
rename from drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_dvfs.c
rename to drivers/gpu/arm/midgard/platform/rk/mali_kbase_dvfs.c
index b395b3ac1991..47e13fa13155 100755
--- a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_dvfs.c
+++ b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_dvfs.c
@@ -1,5 +1,6 @@
-/* drivers/gpu/t6xx/kbase/src/platform/rk/mali_kbase_dvfs.c
- *
+/* drivers/gpu/t6xx/kbase/src/platform/manta/mali_kbase_dvfs.c
+  * 
+  *
  * Rockchip SoC Mali-T764 DVFS driver
  *
  * This program is free software; you can redistribute it and/or modify
@@ -12,11 +13,11 @@
  * DVFS
  */
 
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_uku.h>
-#include <kbase/src/common/mali_kbase_mem.h>
-#include <kbase/src/common/mali_midg_regmap.h>
-#include <kbase/src/linux/mali_kbase_mem_linux.h>
+#include <mali_kbase.h>
+#include <mali_kbase_uku.h>
+#include <mali_kbase_mem.h>
+#include <mali_midg_regmap.h>
+#include <mali_kbase_mem_linux.h>
 
 #include <linux/module.h>
 #include <linux/init.h>
@@ -32,45 +33,39 @@
 #include <linux/uaccess.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
-
+#include <linux/cpufreq.h>
 #include <linux/fb.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/driver.h>
-#include <kbase/src/platform/rk/mali_kbase_platform.h>
-#include <kbase/src/platform/rk/mali_kbase_dvfs.h>
-#include <kbase/src/common/mali_kbase_gator.h>
-
+#include <platform/rk/mali_kbase_platform.h>
+#include <platform/rk/mali_kbase_dvfs.h>
+#include <mali_kbase_gator.h>
+#include <linux/rockchip/dvfs.h>
 /***********************************************************/
 /*  This table and variable are using the check time share of GPU Clock  */
 /***********************************************************/
 
-typedef struct _mali_dvfs_info {
-	unsigned int voltage;
-	unsigned int clock;
-	int min_threshold;
-	int max_threshold;
-	unsigned long long time;
-} mali_dvfs_info;
-
 static mali_dvfs_info mali_dvfs_infotbl[] = {
-	  {925000, 100, 0, 70, 0},
-      {925000, 160, 50, 65, 0},
-      {1025000, 266, 60, 78, 0},
-      {1075000, 350, 65, 75, 0},
-      {1125000, 400, 70, 75, 0},
-      {1200000, 500, 90, 100, 0},
+	  {925000, 100000, 0, 70, 0},
+      {925000, 160000, 50, 65, 0},
+      {1025000, 266000, 60, 78, 0},
+      {1075000, 350000, 65, 75, 0},
+      {1125000, 400000, 70, 75, 0},
+      {1200000, 500000, 90, 100, 0},
 };
+mali_dvfs_info *p_mali_dvfs_infotbl = NULL;
 
-#define MALI_DVFS_STEP	ARRAY_SIZE(mali_dvfs_infotbl)
+unsigned int MALI_DVFS_STEP = ARRAY_SIZE(mali_dvfs_infotbl);
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+static struct cpufreq_frequency_table *mali_freq_table = NULL;
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 typedef struct _mali_dvfs_status_type {
 	kbase_device *kbdev;
 	int step;
 	int utilisation;
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	int upper_lock;
 	int under_lock;
 #endif
@@ -82,7 +77,7 @@ spinlock_t mali_dvfs_spinlock;
 struct mutex mali_set_clock_lock;
 struct mutex mali_enable_clock_lock;
 
-#ifdef CONFIG_MALI_T6XX_DEBUG_SYS
+#ifdef CONFIG_MALI_MIDGARD_DEBUG_SYS
 static void update_time_in_state(int level);
 #endif
 
@@ -131,7 +126,7 @@ static void mali_dvfs_event_proc(struct work_struct *w)
 		BUG_ON(dvfs_status->step <= 0);
 		dvfs_status->step--;
 	}
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	if ((dvfs_status->upper_lock >= 0) && (dvfs_status->step > dvfs_status->upper_lock)) 
 	{
 		dvfs_status->step = dvfs_status->upper_lock;
@@ -144,6 +139,7 @@ static void mali_dvfs_event_proc(struct work_struct *w)
 	}
 #endif
 	spin_unlock_irqrestore(&mali_dvfs_spinlock, flags);
+	//printk("%n",__func__);
 	kbase_platform_dvfs_set_level(dvfs_status->kbdev, dvfs_status->step);
 
 	mutex_unlock(&mali_enable_clock_lock);
@@ -246,7 +242,7 @@ int kbase_platform_dvfs_enable(bool enable, int freq)
 		platform->utilisation = 0;
 		dvfs_status->step = kbase_platform_dvfs_get_level(freq);
 		spin_unlock_irqrestore(&mali_dvfs_spinlock, flags);
-
+		//printk("%s,freq = %d\n",__func__,freq);
 		kbase_platform_dvfs_set_level(dvfs_status->kbdev, dvfs_status->step);
  	}
  
@@ -261,6 +257,65 @@ int kbase_platform_dvfs_init(struct kbase_device *kbdev)
 	/*default status
 	   add here with the right function to get initilization value.
 	 */
+	struct rk_context *platform;
+	int i;
+	
+	platform = (struct rk_context *)kbdev->platform_context;
+	if (NULL == platform)
+		panic("oops");
+		    
+	mali_freq_table = dvfs_get_freq_volt_table(platform->mali_clk_node);
+	
+	if (mali_freq_table == NULL) 
+	{
+		printk("mali freq table not assigned yet,use default\n");
+		goto not_assigned ;
+	}
+	else 
+	{
+		/*recalculte step*/
+		MALI_DVFS_STEP = 0;
+		for (i = 0; mali_freq_table[i].frequency != CPUFREQ_TABLE_END; i++) 
+		{
+			if((mali_freq_table[i].frequency > 0) && (mali_freq_table[i].frequency <= 100000))
+			{
+				mali_dvfs_infotbl[i].clock = mali_freq_table[i].frequency;
+				mali_dvfs_infotbl[i].min_threshold = 0;
+				mali_dvfs_infotbl[i].max_threshold = 70;
+				MALI_DVFS_STEP++;
+			}
+			else if ((mali_freq_table[i].frequency > 100000) && (mali_freq_table[i].frequency <= 200000))
+			{
+				mali_dvfs_infotbl[i].clock = mali_freq_table[i].frequency;
+				mali_dvfs_infotbl[i].min_threshold = 50;
+				mali_dvfs_infotbl[i].max_threshold = 65;
+				MALI_DVFS_STEP++;
+			}
+			else if ((mali_freq_table[i].frequency > 200000) && (mali_freq_table[i].frequency <= 300000))
+			{
+				mali_dvfs_infotbl[i].clock = mali_freq_table[i].frequency;
+				mali_dvfs_infotbl[i].min_threshold = 60;
+				mali_dvfs_infotbl[i].max_threshold = 78;
+				MALI_DVFS_STEP++;
+			}
+			else if ((mali_freq_table[i].frequency > 300000) && (mali_freq_table[i].frequency <= 400000))
+			{
+				mali_dvfs_infotbl[i].clock = mali_freq_table[i].frequency;
+				mali_dvfs_infotbl[i].min_threshold = 65;
+				mali_dvfs_infotbl[i].max_threshold = 75;		
+				MALI_DVFS_STEP++;
+			}
+			else if ((mali_freq_table[i].frequency > 400000) && (mali_freq_table[i].frequency <= 500000))
+			{
+				mali_dvfs_infotbl[i].clock = mali_freq_table[i].frequency;
+				mali_dvfs_infotbl[i].min_threshold = 90;
+				mali_dvfs_infotbl[i].max_threshold = 100;
+				MALI_DVFS_STEP++;
+			}			
+		}
+		p_mali_dvfs_infotbl = mali_dvfs_infotbl;				
+	}
+not_assigned :
 	if (!mali_dvfs_wq)
 		mali_dvfs_wq = create_singlethread_workqueue("mali_dvfs");
 
@@ -271,9 +326,9 @@ int kbase_platform_dvfs_init(struct kbase_device *kbdev)
 	/*add a error handling here */
 	spin_lock_irqsave(&mali_dvfs_spinlock, flags);
 	mali_dvfs_status_current.kbdev = kbdev;
-	mali_dvfs_status_current.utilisation = 100;
-	mali_dvfs_status_current.step = MALI_DVFS_STEP - 1;
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+	mali_dvfs_status_current.utilisation = 0;
+	mali_dvfs_status_current.step = 0;
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	mali_dvfs_status_current.upper_lock = -1;
 	mali_dvfs_status_current.under_lock = -1;
 #endif
@@ -290,14 +345,14 @@ void kbase_platform_dvfs_term(void)
 
 	mali_dvfs_wq = NULL;
 }
-#endif /*CONFIG_MALI_T6XX_DVFS*/
+#endif /*CONFIG_MALI_MIDGARD_DVFS*/
 
 int mali_get_dvfs_upper_locked_freq(void)
 {
 	unsigned long flags;
 	int locked_level = -1;
 
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	spin_lock_irqsave(&mali_dvfs_spinlock, flags);
 	if (mali_dvfs_status_current.upper_lock >= 0)
 		locked_level = mali_dvfs_infotbl[mali_dvfs_status_current.upper_lock].clock;
@@ -311,7 +366,7 @@ int mali_get_dvfs_under_locked_freq(void)
 	unsigned long flags;
 	int locked_level = -1;
 
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	spin_lock_irqsave(&mali_dvfs_spinlock, flags);
 	if (mali_dvfs_status_current.under_lock >= 0)
 		locked_level = mali_dvfs_infotbl[mali_dvfs_status_current.under_lock].clock;
@@ -325,7 +380,7 @@ int mali_get_dvfs_current_level(void)
 	unsigned long flags;
 	int current_level = -1;
 
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	spin_lock_irqsave(&mali_dvfs_spinlock, flags);
 	current_level = mali_dvfs_status_current.step;
 	spin_unlock_irqrestore(&mali_dvfs_spinlock, flags);
@@ -336,7 +391,7 @@ int mali_get_dvfs_current_level(void)
 int mali_dvfs_freq_lock(int level)
 {
 	unsigned long flags;
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	spin_lock_irqsave(&mali_dvfs_spinlock, flags);
 	if (mali_dvfs_status_current.under_lock >= 0 && mali_dvfs_status_current.under_lock > level) {
 		printk(KERN_ERR " Upper lock Error : Attempting to set upper lock to below under lock\n");
@@ -354,7 +409,7 @@ int mali_dvfs_freq_lock(int level)
 void mali_dvfs_freq_unlock(void)
 {
 	unsigned long flags;
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	spin_lock_irqsave(&mali_dvfs_spinlock, flags);
 	mali_dvfs_status_current.upper_lock = -1;
 	spin_unlock_irqrestore(&mali_dvfs_spinlock, flags);
@@ -365,7 +420,7 @@ void mali_dvfs_freq_unlock(void)
 int mali_dvfs_freq_under_lock(int level)
 {
 	unsigned long flags;
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	spin_lock_irqsave(&mali_dvfs_spinlock, flags);
 	if (mali_dvfs_status_current.upper_lock >= 0 && mali_dvfs_status_current.upper_lock < level) {
 		printk(KERN_ERR "mali Under lock Error : Attempting to set under lock to above upper lock\n");
@@ -383,7 +438,7 @@ int mali_dvfs_freq_under_lock(int level)
 void mali_dvfs_freq_under_unlock(void)
 {
 	unsigned long flags;
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	spin_lock_irqsave(&mali_dvfs_spinlock, flags);
 	mali_dvfs_status_current.under_lock = -1;
 	spin_unlock_irqrestore(&mali_dvfs_spinlock, flags);
@@ -393,7 +448,6 @@ void mali_dvfs_freq_under_unlock(void)
 
 void kbase_platform_dvfs_set_clock(kbase_device *kbdev, int freq)
 {
-	unsigned long aclk_400_rate = 0;
 	struct rk_context *platform;
 
 	if (!kbdev)
@@ -408,36 +462,8 @@ void kbase_platform_dvfs_set_clock(kbase_device *kbdev, int freq)
 		printk("mali_clk_node not init\n");
 		return;
 	}
-	switch (freq) {
-		case 500:
-			aclk_400_rate = 500000000;
-			break;
-		case 400:
-			aclk_400_rate = 400000000;
-			break;
-		case 350:
-			aclk_400_rate = 350000000;
-			break;
-		case 266:
-			aclk_400_rate = 266000000;
-			break;
-		case 160:
-			aclk_400_rate = 160000000;
-			break;
-		case 100:
-			aclk_400_rate = 100000000;
-			break;
-		default:
-			return;
-	}
-
-	mali_dvfs_clk_set(platform->mali_clk_node,aclk_400_rate);
-	/* Waiting for clock is stable
-	do {
-		tmp = __raw_readl(EXYNOS5_CLKDIV_STAT_TOP0);
-	} while (tmp & 0x1000000);
-	*/
-
+	mali_dvfs_clk_set(platform->mali_clk_node,freq);
+	
 	return;
 }
 
@@ -459,33 +485,32 @@ void kbase_platform_dvfs_set_level(kbase_device *kbdev, int level)
 		return;
 
 	if (WARN_ON((level >= MALI_DVFS_STEP) || (level < 0)))
-		panic("invalid level");
-
-#ifdef CONFIG_MALI_T6XX_FREQ_LOCK
+	{
+		printk("unkown mali dvfs level:level = %d,set clock not done \n",level);
+	 	return  ;
+	}
+	//panic("invalid level");
+#ifdef CONFIG_MALI_MIDGARD_FREQ_LOCK
 	if (mali_dvfs_status_current.upper_lock >= 0 && level > mali_dvfs_status_current.upper_lock)
 		level = mali_dvfs_status_current.upper_lock;
-
 	if (mali_dvfs_status_current.under_lock >= 0 && level < mali_dvfs_status_current.under_lock)
 		level = mali_dvfs_status_current.under_lock;
 #endif
-
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	mutex_lock(&mali_set_clock_lock);
 #endif
-
 	kbase_platform_dvfs_set_clock(kbdev, mali_dvfs_infotbl[level].clock);
-
-#if defined(CONFIG_MALI_T6XX_DEBUG_SYS) && defined(CONFIG_MALI_T6XX_DVFS)
+#if defined(CONFIG_MALI_MIDGARD_DEBUG_SYS) && defined(CONFIG_MALI_MIDGARD_DVFS)
 	update_time_in_state(prev_level);
 #endif
 	prev_level = level;
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	mutex_unlock(&mali_set_clock_lock);
 #endif
 }
 
-#ifdef CONFIG_MALI_T6XX_DEBUG_SYS
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DEBUG_SYS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 static void update_time_in_state(int level)
 {
 	u64 current_time;
@@ -515,7 +540,7 @@ ssize_t show_time_in_state(struct device *dev, struct device_attribute *attr, ch
 
 	kbdev = dev_get_drvdata(dev);
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	update_time_in_state(mali_dvfs_status_current.step);
 #endif
 	if (!kbdev)
diff --git a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_dvfs.h b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_dvfs.h
similarity index 79%
rename from drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_dvfs.h
rename to drivers/gpu/arm/midgard/platform/rk/mali_kbase_dvfs.h
index 64d9dac45611..0fefc1a78a8d 100755
--- a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_dvfs.h
+++ b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_dvfs.h
@@ -1,4 +1,4 @@
-/* drivers/gpu/t6xx/kbase/src/platform/rk/mali_kbase_dvfs.h
+/* drivers/gpu/midgard/platform/rk/mali_kbase_dvfs.h
  *
  * Rockchip SoC Mali-T764 DVFS driver
  *
@@ -22,18 +22,30 @@
 #define MALI_DVFS_TIME_INTERVAL 2
 
 #define MALI_DVFS_CURRENT_FREQ 0
+#if 0
 #define MALI_DVFS_BL_CONFIG_FREQ 500
 #define MALI_DVFS_START_FREQ 400
+#endif
+typedef struct _mali_dvfs_info {
+	unsigned int voltage;
+	unsigned int clock;
+	int min_threshold;
+	int max_threshold;
+	unsigned long long time;
+} mali_dvfs_info;
 
-#ifdef CONFIG_MALI_T6XX_DVFS
-#define CONFIG_MALI_T6XX_FREQ_LOCK
+#define MALI_KHZ 1000
+extern mali_dvfs_info *p_mali_dvfs_infotbl;
+extern unsigned int MALI_DVFS_STEP;
+#ifdef CONFIG_MALI_MIDGARD_DVFS
+#define CONFIG_MALI_MIDGARD_FREQ_LOCK
 #endif
 
 void kbase_platform_dvfs_set_clock(kbase_device *kbdev, int freq);
 void kbase_platform_dvfs_set_level(struct kbase_device *kbdev, int level);
 int kbase_platform_dvfs_get_level(int freq);
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 int kbase_platform_dvfs_init(struct kbase_device *dev);
 void kbase_platform_dvfs_term(void);
 int kbase_platform_dvfs_event(struct kbase_device *kbdev, u32 utilisation);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_platform.c b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_platform.c
similarity index 87%
rename from drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_platform.c
rename to drivers/gpu/arm/midgard/platform/rk/mali_kbase_platform.c
index 157e210a7e41..544b09d388bd 100755
--- a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_platform.c
+++ b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_platform.c
@@ -11,12 +11,12 @@
  * @file mali_kbase_platform.c
  * Platform-dependent init.
  */
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_pm.h>
-#include <kbase/src/common/mali_kbase_uku.h>
-#include <kbase/src/common/mali_kbase_mem.h>
-#include <kbase/src/common/mali_midg_regmap.h>
-#include <kbase/src/linux/mali_kbase_mem_linux.h>
+#include <mali_kbase.h>
+#include <mali_kbase_pm.h>
+#include <mali_kbase_uku.h>
+#include <mali_kbase_mem.h>
+#include <mali_midg_regmap.h>
+#include <mali_kbase_mem_linux.h>
 
 #include <linux/module.h>
 #include <linux/init.h>
@@ -36,14 +36,14 @@
 #include <linux/fb.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
-#include <kbase/src/platform/rk/mali_kbase_platform.h>
-#include <kbase/src/platform/rk/mali_kbase_dvfs.h>
+#include <platform/rk/mali_kbase_platform.h>
+#include <platform/rk/mali_kbase_dvfs.h>
 
-#include <kbase/src/common/mali_kbase_gator.h>
+#include <mali_kbase_gator.h>
 
 #include <linux/rockchip/dvfs.h> 
 
-#define MALI_T7XX_DEFAULT_CLOCK 400000000
+#define MALI_T7XX_DEFAULT_CLOCK 100000
 
 
 static int mali_clk_status = 0;
@@ -57,7 +57,7 @@ int mali_dvfs_clk_set(struct dvfs_node *node,unsigned long rate)
 		printk("clk_get_dvfs_node error \r\n");
 		ret = -1;
 	}
-	ret = dvfs_clk_set_rate(node,rate);
+	ret = dvfs_clk_set_rate(node,rate * MALI_KHZ);
 	if(ret)
 	{
 		printk("dvfs_clk_set_rate error \r\n");
@@ -66,7 +66,7 @@ int mali_dvfs_clk_set(struct dvfs_node *node,unsigned long rate)
 }
 static int kbase_platform_power_clock_init(kbase_device *kbdev)
 {
-	struct device *dev = kbdev->osdev.dev;
+	//struct device *dev = kbdev->dev;
 	struct rk_context *platform;
 
 	platform = (struct rk_context *)kbdev->platform_context;
@@ -258,14 +258,14 @@ int kbase_platform_cmu_pmu_control(struct kbase_device *kbdev, int control)
 	return 0;
 }
 
-#ifdef CONFIG_MALI_T6XX_DEBUG_SYS
+#ifdef CONFIG_MALI_MIDGARD_DEBUG_SYS
 static ssize_t show_clock(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct kbase_device *kbdev;
 	struct rk_context *platform;
 	ssize_t ret = 0;
 	unsigned int clkrate;
-
+	int i ;
 	kbdev = dev_get_drvdata(dev);
 
 	if (!kbdev)
@@ -284,7 +284,10 @@ static ssize_t show_clock(struct device *dev, struct device_attribute *attr, cha
 	ret += snprintf(buf + ret, PAGE_SIZE - ret, "Current clk mali = %dMhz", clkrate / 1000000);
 
 	/* To be revised  */
-	ret += snprintf(buf + ret, PAGE_SIZE - ret, "\nPossible settings : 500, 400, 350, 266, 160, 100Mhz");
+	ret += snprintf(buf + ret, PAGE_SIZE - ret, "\nPossible settings:");
+	for(i=0;i<MALI_DVFS_STEP;i++)
+		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%d ",p_mali_dvfs_infotbl[i].clock/1000);
+		ret += snprintf(buf + ret, PAGE_SIZE - ret, "Mhz");
 
 	if (ret < PAGE_SIZE - 1)
 		ret += snprintf(buf + ret, PAGE_SIZE - ret, "\n");
@@ -313,7 +316,7 @@ static ssize_t set_clock(struct device *dev, struct device_attribute *attr, cons
 
 	if (!platform->mali_clk_node)
 		return -ENODEV;
-
+#if 0
 	if (sysfs_streq("500", buf)) {
 		freq = 500;
 	} else if (sysfs_streq("400", buf)) {
@@ -330,14 +333,10 @@ static ssize_t set_clock(struct device *dev, struct device_attribute *attr, cons
 		dev_err(dev, "set_clock: invalid value\n");
 		return -ENOENT;
 	}
+#endif
+	freq = simple_strtoul(buf, NULL, 10);
 
 	kbase_platform_dvfs_set_level(kbdev, kbase_platform_dvfs_get_level(freq));
-	/* Waiting for clock is stable
-	do {
-		tmp = __raw_readl(EXYNOS5_CLKDIV_STAT_TOP0);
-	} while (tmp & 0x1000000);
-	*/
-
 	return count;
 }
 
@@ -581,7 +580,7 @@ static ssize_t show_dvfs(struct device *dev, struct device_attribute *attr, char
 	if (!kbdev)
 		return -ENODEV;
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	if (kbase_platform_dvfs_get_enable_status())
 		ret += snprintf(buf + ret, PAGE_SIZE - ret, "mali DVFS is on\nutilisation:%d", kbase_platform_dvfs_get_utilisation());
 	else
@@ -604,20 +603,22 @@ static ssize_t show_dvfs(struct device *dev, struct device_attribute *attr, char
 static ssize_t set_dvfs(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct kbase_device *kbdev = dev_get_drvdata(dev);
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	struct rk_context *platform;
 #endif
 
 	if (!kbdev)
 		return -ENODEV;
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	platform = (struct rk_context *)kbdev->platform_context;
 	if (sysfs_streq("off", buf)) {
-		kbase_platform_dvfs_enable(false, MALI_DVFS_BL_CONFIG_FREQ);
+		//kbase_platform_dvfs_enable(false, MALI_DVFS_BL_CONFIG_FREQ);
+		kbase_platform_dvfs_enable(false, p_mali_dvfs_infotbl[MALI_DVFS_STEP-1].clock);	
 		platform->dvfs_enabled = false;
 	} else if (sysfs_streq("on", buf)) {
-		kbase_platform_dvfs_enable(true, MALI_DVFS_START_FREQ);
+		//kbase_platform_dvfs_enable(true, MALI_DVFS_START_FREQ);
+		kbase_platform_dvfs_enable(true, p_mali_dvfs_infotbl[0].clock);
 		platform->dvfs_enabled = true;
 	} else {
 		printk(KERN_DEBUG "invalid val -only [on, off] is accepted\n");
@@ -632,7 +633,8 @@ static ssize_t show_upper_lock_dvfs(struct device *dev, struct device_attribute
 {
 	struct kbase_device *kbdev;
 	ssize_t ret = 0;
-#ifdef CONFIG_MALI_T6XX_DVFS
+	int i;
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	int locked_level = -1;
 #endif
 
@@ -641,13 +643,18 @@ static ssize_t show_upper_lock_dvfs(struct device *dev, struct device_attribute
 	if (!kbdev)
 		return -ENODEV;
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	locked_level = mali_get_dvfs_upper_locked_freq();
 	if (locked_level > 0)
 		ret += snprintf(buf + ret, PAGE_SIZE - ret, "Current Upper Lock Level = %dMhz", locked_level);
 	else
 		ret += snprintf(buf + ret, PAGE_SIZE - ret, "Unset the Upper Lock Level");
-	ret += snprintf(buf + ret, PAGE_SIZE - ret, "\nPossible settings : 400, 350,266, 160, 100, If you want to unlock : 500 or off");
+	//ret += snprintf(buf + ret, PAGE_SIZE - ret, "\nPossible settings : 400, 350,266, 160, 100, If you want to unlock : 600 or off");
+	ret += snprintf(buf + ret, PAGE_SIZE - ret, "\nPossible settings :");
+	for(i=0;i<MALI_DVFS_STEP;i++)
+		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%d ",p_mali_dvfs_infotbl[i].clock/1000);
+	ret += snprintf(buf + ret, PAGE_SIZE - ret, "Mhz");
+	ret += snprintf(buf + ret, PAGE_SIZE - ret, ", If you want to unlock : off");
 
 #else
 	ret += snprintf(buf + ret, PAGE_SIZE - ret, "mali DVFS is disabled. You can not set");
@@ -667,32 +674,38 @@ static ssize_t show_upper_lock_dvfs(struct device *dev, struct device_attribute
 static ssize_t set_upper_lock_dvfs(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct kbase_device *kbdev;
+	int i;
+	unsigned int freq;
 	kbdev = dev_get_drvdata(dev);
+	freq = 0;
 
 	if (!kbdev)
 		return -ENODEV;
 
-#ifdef CONFIG_MALI_T6XX_DVFS
-	if (sysfs_streq("off", buf)) {
-		mali_dvfs_freq_unlock();
-	} else if (sysfs_streq("500", buf)) {
+freq = simple_strtoul(buf, NULL, 10);
+
+#ifdef CONFIG_MALI_MIDGARD_DVFS
+	if (sysfs_streq("off", buf)) 
+	{
 		mali_dvfs_freq_unlock();
-	} else if (sysfs_streq("400", buf)) {
-		mali_dvfs_freq_lock(4);
-	} else if (sysfs_streq("350", buf)) {
-		mali_dvfs_freq_lock(3);
-	} else if (sysfs_streq("266", buf)) {
-		mali_dvfs_freq_lock(2);
-	} else if (sysfs_streq("160", buf)) {
-		mali_dvfs_freq_lock(1);
-	} else if (sysfs_streq("100", buf)) {
-		mali_dvfs_freq_lock(0);
-	} else {
-		dev_err(dev, "set_clock: invalid value\n");
-		dev_err(dev, "Possible settings :  400, 350,266, 160, 100, If you want to unlock : 500\n");
-		return -ENOENT;
+	} 
+	else 
+	{
+		for(i=0;i<MALI_DVFS_STEP;i++)
+		{
+			if (p_mali_dvfs_infotbl[i].clock == freq) 
+			{
+				mali_dvfs_freq_lock(i);
+				break;
+			}
+			if(i==MALI_DVFS_STEP)
+			{
+				dev_err(dev, "set_clock: invalid value\n");
+				return -ENOENT;
+			}
+		}
 	}
-#else				/* CONFIG_MALI_T6XX_DVFS */
+#else				/* CONFIG_MALI_MIDGARD_DVFS */
 	printk(KERN_DEBUG "mali DVFS is disabled. You can not set\n");
 #endif
 
@@ -703,7 +716,8 @@ static ssize_t show_under_lock_dvfs(struct device *dev, struct device_attribute
 {
 	struct kbase_device *kbdev;
 	ssize_t ret = 0;
-#ifdef CONFIG_MALI_T6XX_DVFS
+	int i;
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	int locked_level = -1;
 #endif
 
@@ -712,13 +726,18 @@ static ssize_t show_under_lock_dvfs(struct device *dev, struct device_attribute
 	if (!kbdev)
 		return -ENODEV;
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	locked_level = mali_get_dvfs_under_locked_freq();
 	if (locked_level > 0)
 		ret += snprintf(buf + ret, PAGE_SIZE - ret, "Current Under Lock Level = %dMhz", locked_level);
 	else
 		ret += snprintf(buf + ret, PAGE_SIZE - ret, "Unset the Under Lock Level");
-	ret += snprintf(buf + ret, PAGE_SIZE - ret, "\nPossible settings : 500, 400, 350,266, 160, If you want to unlock : 100 or off");
+	//ret += snprintf(buf + ret, PAGE_SIZE - ret, "\nPossible settings : 600, 400, 350,266, 160, If you want to unlock : 100 or off");
+	ret += snprintf(buf + ret, PAGE_SIZE - ret, "\nPossible settings :");
+	for(i=0;i<MALI_DVFS_STEP;i++)
+		ret += snprintf(buf + ret, PAGE_SIZE - ret, "%d ",p_mali_dvfs_infotbl[i].clock/1000);
+	ret += snprintf(buf + ret, PAGE_SIZE - ret, "Mhz");
+	ret += snprintf(buf + ret, PAGE_SIZE - ret, ", If you want to unlock : off");
 
 #else
 	ret += snprintf(buf + ret, PAGE_SIZE - ret, "mali DVFS is disabled. You can not set");
@@ -737,36 +756,39 @@ static ssize_t show_under_lock_dvfs(struct device *dev, struct device_attribute
 
 static ssize_t set_under_lock_dvfs(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
+	int i;
+	unsigned int freq;
 	struct kbase_device *kbdev;
 	kbdev = dev_get_drvdata(dev);
+	freq = 0;
 
 	if (!kbdev)
 		return -ENODEV;
 
-#ifdef CONFIG_MALI_T6XX_DVFS
-	if (sysfs_streq("off", buf)) {
-		mali_dvfs_freq_under_unlock();
-	} else if (sysfs_streq("500", buf)) {
-		mali_dvfs_freq_under_lock(5);
-	} else if (sysfs_streq("400", buf)) {
-		mali_dvfs_freq_under_lock(4);
-	} else if (sysfs_streq("350", buf)) {
-		mali_dvfs_freq_under_lock(3);
-	} else if (sysfs_streq("266", buf)) {
-		mali_dvfs_freq_under_lock(2);
-	} else if (sysfs_streq("160", buf)) {
-		mali_dvfs_freq_under_lock(1);
-	} else if (sysfs_streq("100", buf)) {
-		mali_dvfs_freq_under_unlock();
-	} else {
-		dev_err(dev, "set_clock: invalid value\n");
-		dev_err(dev, "Possible settings : 500, 400,350,266, 160, If you want to unlock : 100 or off\n");
-		return -ENOENT;
+#ifdef CONFIG_MALI_MIDGARD_DVFS
+	if (sysfs_streq("off", buf)) 
+	{
+		mali_dvfs_freq_unlock();
+	} 
+	else 
+	{
+		for(i=0;i<MALI_DVFS_STEP;i++)
+		{
+			if (p_mali_dvfs_infotbl[i].clock == freq) 
+			{
+				mali_dvfs_freq_lock(i);
+				break;
+			}
+			if(i==MALI_DVFS_STEP)
+			{
+				dev_err(dev, "set_clock: invalid value\n");
+				return -ENOENT;
+			}
+		}
 	}
-#else
-	printk(KERN_DEBUG "G3D DVFS is disabled. You can not set\n");
-#endif /* CONFIG_MALI_T6XX_DVFS */
-
+#else				/* CONFIG_MALI_MIDGARD_DVFS */
+	printk(KERN_DEBUG "mali DVFS is disabled. You can not set\n");
+#endif
 	return count;
 }
 
@@ -833,7 +855,7 @@ void kbase_platform_remove_sysfs_file(struct device *dev)
 	device_remove_file(dev, &dev_attr_dvfs_under_lock);
 	device_remove_file(dev, &dev_attr_time_in_state);
 }
-#endif				/* CONFIG_MALI_T6XX_DEBUG_SYS */
+#endif				/* CONFIG_MALI_MIDGARD_DEBUG_SYS */
 
 mali_error kbase_platform_init(struct kbase_device *kbdev)
 {
@@ -847,7 +869,7 @@ mali_error kbase_platform_init(struct kbase_device *kbdev)
 	kbdev->platform_context = (void *)platform;
 
 	platform->cmu_pmu_status = 0;
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	platform->utilisation = 0;
 	platform->time_busy = 0;
 	platform->time_idle = 0;
@@ -860,9 +882,9 @@ mali_error kbase_platform_init(struct kbase_device *kbdev)
 	if (kbase_platform_power_clock_init(kbdev))
 		goto clock_init_fail;
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	kbase_platform_dvfs_init(kbdev);
-#endif				/* CONFIG_MALI_T6XX_DVFS */
+#endif				/* CONFIG_MALI_MIDGARD_DVFS */
 
 	/* Enable power */
 	kbase_platform_cmu_pmu_control(kbdev, 1);
@@ -880,9 +902,9 @@ void kbase_platform_term(kbase_device *kbdev)
 
 	platform = (struct rk_context *)kbdev->platform_context;
 
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	kbase_platform_dvfs_term();
-#endif				/* CONFIG_MALI_T6XX_DVFS */
+#endif				/* CONFIG_MALI_MIDGARD_DVFS */
 
 	/* Disable power */
 	kbase_platform_cmu_pmu_control(kbdev, 0);
diff --git a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_platform.h b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_platform.h
old mode 100644
new mode 100755
similarity index 97%
rename from drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_platform.h
rename to drivers/gpu/arm/midgard/platform/rk/mali_kbase_platform.h
index 75b0eb7f0d53..28399a8f2f5e
--- a/drivers/gpu/arm/t6xx/kbase/src/platform/rk/mali_kbase_platform.h
+++ b/drivers/gpu/arm/midgard/platform/rk/mali_kbase_platform.h
@@ -1,5 +1,4 @@
 /* drivers/gpu/t6xx/kbase/src/platform/rk/mali_kbase_platform.h
- *
  * Rockchip SoC Mali-T764 platform-dependent codes
  *
  * This program is free software; you can redistribute it and/or modify
@@ -26,7 +25,7 @@ struct rk_context {
 	struct dvfs_node * mali_pd_node;
 	struct dvfs_node * mali_clk_node;
 #endif
-#ifdef CONFIG_MALI_T6XX_DVFS
+#ifdef CONFIG_MALI_MIDGARD_DVFS
 	/*To calculate utilization for x sec */
 	int time_tick;
 	int utilisation;
diff --git a/drivers/gpu/arm/t6xx/kbase/sconscript b/drivers/gpu/arm/midgard/platform/vexpress/Kbuild
old mode 100644
new mode 100755
similarity index 76%
rename from drivers/gpu/arm/t6xx/kbase/sconscript
rename to drivers/gpu/arm/midgard/platform/vexpress/Kbuild
index a03cad481dd7..084a15613436
--- a/drivers/gpu/arm/t6xx/kbase/sconscript
+++ b/drivers/gpu/arm/midgard/platform/vexpress/Kbuild
@@ -1,5 +1,5 @@
 #
-# (C) COPYRIGHT 2010-2013 ARM Limited. All rights reserved.
+# (C) COPYRIGHT 2012-2013 ARM Limited. All rights reserved.
 #
 # This program is free software and is provided to you under the terms of the
 # GNU General Public License version 2 as published by the Free Software
@@ -14,4 +14,5 @@
 
 
 
-SConscript('src/sconscript')
+obj-y += mali_kbase_config_vexpress.o
+obj-y += mali_kbase_cpu_vexpress.o
diff --git a/drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_config_vexpress.c b/drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_config_vexpress.c
new file mode 100755
index 000000000000..01d67fdc68bb
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_config_vexpress.c
@@ -0,0 +1,323 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+
+
+#include <linux/ioport.h>
+#include <mali_kbase.h>
+#include <mali_kbase_defs.h>
+#include <mali_kbase_config.h>
+#include "mali_kbase_cpu_vexpress.h"
+
+/* Versatile Express (VE) configuration defaults shared between config_attributes[]
+ * and config_attributes_hw_issue_8408[]. Settings are not shared for
+ * JS_HARD_STOP_TICKS_SS and JS_RESET_TICKS_SS.
+ */
+#define KBASE_VE_GPU_FREQ_KHZ_MAX               5000
+#define KBASE_VE_GPU_FREQ_KHZ_MIN               5000
+
+#define KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG    15000000u      /* 15ms, an agressive tick for testing purposes. This will reduce performance significantly */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG       1	/* between 15ms and 30ms before soft-stop a job */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_CL_DEBUG    1	/* between 15ms and 30ms before soft-stop a CL job */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_DEBUG    333	/* 5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_8401_DEBUG 2000	/* 30s before hard-stop, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) - for issue 8401 */
+#define KBASE_VE_JS_HARD_STOP_TICKS_CL_DEBUG    166	/* 2.5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG   100000	/* 1500s (25mins) before NSS hard-stop */
+#define KBASE_VE_JS_RESET_TICKS_SS_DEBUG        500	/* 45s before resetting GPU, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) */
+#define KBASE_VE_JS_RESET_TICKS_SS_8401_DEBUG   3000	/* 7.5s before resetting GPU - for issue 8401 */
+#define KBASE_VE_JS_RESET_TICKS_CL_DEBUG        500	/* 45s before resetting GPU */
+#define KBASE_VE_JS_RESET_TICKS_NSS_DEBUG       100166	/* 1502s before resetting GPU */
+
+#define KBASE_VE_JS_SCHEDULING_TICK_NS          1250000000u	/* 1.25s */
+#define KBASE_VE_JS_SOFT_STOP_TICKS             2	/* 2.5s before soft-stop a job */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_CL          1	/* 1.25s before soft-stop a CL job */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS          4	/* 5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_8401     24	/* 30s before hard-stop, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) - for issue 8401 */
+#define KBASE_VE_JS_HARD_STOP_TICKS_CL          2	/* 2.5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_NSS         1200	/* 1500s before NSS hard-stop */
+#define KBASE_VE_JS_RESET_TICKS_SS              6	/* 7.5s before resetting GPU */
+#define KBASE_VE_JS_RESET_TICKS_SS_8401         36	/* 45s before resetting GPU, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) - for issue 8401 */
+#define KBASE_VE_JS_RESET_TICKS_CL              3	/* 7.5s before resetting GPU */
+#define KBASE_VE_JS_RESET_TICKS_NSS             1201	/* 1502s before resetting GPU */
+
+#define KBASE_VE_JS_RESET_TIMEOUT_MS            3000	/* 3s before cancelling stuck jobs */
+#define KBASE_VE_JS_CTX_TIMESLICE_NS            1000000	/* 1ms - an agressive timeslice for testing purposes (causes lots of scheduling out for >4 ctxs) */
+#define KBASE_VE_SECURE_BUT_LOSS_OF_PERFORMANCE	((uintptr_t)MALI_FALSE)	/* By default we prefer performance over security on r0p0-15dev0 and KBASE_CONFIG_ATTR_ earlier */
+#define KBASE_VE_POWER_MANAGEMENT_CALLBACKS     ((uintptr_t)&pm_callbacks)
+#define KBASE_VE_CPU_SPEED_FUNC                 ((uintptr_t)&kbase_get_vexpress_cpu_clock_speed)
+
+#define HARD_RESET_AT_POWER_OFF 0
+
+#ifndef CONFIG_OF
+static kbase_io_resources io_resources = {
+	.job_irq_number = 68,
+	.mmu_irq_number = 69,
+	.gpu_irq_number = 70,
+	.io_memory_region = {
+			     .start = 0xFC010000,
+			     .end = 0xFC010000 + (4096 * 4) - 1}
+};
+#endif
+
+static int pm_callback_power_on(kbase_device *kbdev)
+{
+	/* Nothing is needed on VExpress, but we may have destroyed GPU state (if the below HARD_RESET code is active) */
+	return 1;
+}
+
+static void pm_callback_power_off(kbase_device *kbdev)
+{
+#if HARD_RESET_AT_POWER_OFF
+	/* Cause a GPU hard reset to test whether we have actually idled the GPU
+	 * and that we properly reconfigure the GPU on power up.
+	 * Usually this would be dangerous, but if the GPU is working correctly it should
+	 * be completely safe as the GPU should not be active at this point.
+	 * However this is disabled normally because it will most likely interfere with
+	 * bus logging etc.
+	 */
+	KBASE_TRACE_ADD(kbdev, CORE_GPU_HARD_RESET, NULL, NULL, 0u, 0);
+	kbase_os_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_HARD_RESET);
+#endif
+}
+
+static kbase_pm_callback_conf pm_callbacks = {
+	.power_on_callback = pm_callback_power_on,
+	.power_off_callback = pm_callback_power_off,
+	.power_suspend_callback  = NULL,
+	.power_resume_callback = NULL
+};
+
+/* Please keep table config_attributes in sync with config_attributes_hw_issue_8408 */
+static kbase_attribute config_attributes[] = {
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX,
+	 KBASE_VE_GPU_FREQ_KHZ_MAX},
+
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN,
+	 KBASE_VE_GPU_FREQ_KHZ_MIN},
+
+#ifdef CONFIG_MALI_DEBUG
+/* Use more aggressive scheduling timeouts in debug builds for testing purposes */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL,
+	 KBASE_VE_JS_HARD_STOP_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL,
+	 KBASE_VE_JS_RESET_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS_DEBUG},
+#else				/* CONFIG_MALI_DEBUG */
+/* In release builds same as the defaults but scaled for 5MHz FPGA */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL,
+	 KBASE_VE_JS_HARD_STOP_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL,
+	 KBASE_VE_JS_RESET_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS},
+#endif				/* CONFIG_MALI_DEBUG */
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS,
+	 KBASE_VE_JS_RESET_TIMEOUT_MS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS,
+	 KBASE_VE_JS_CTX_TIMESLICE_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS,
+	 KBASE_VE_POWER_MANAGEMENT_CALLBACKS},
+
+	{
+	 KBASE_CONFIG_ATTR_CPU_SPEED_FUNC,
+	 KBASE_VE_CPU_SPEED_FUNC},
+
+	{
+	 KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE,
+	 KBASE_VE_SECURE_BUT_LOSS_OF_PERFORMANCE},
+
+	{
+	 KBASE_CONFIG_ATTR_GPU_IRQ_THROTTLE_TIME_US,
+	 20},
+
+	{
+	 KBASE_CONFIG_ATTR_END,
+	 0}
+};
+
+/* as config_attributes array above except with different settings for
+ * JS_HARD_STOP_TICKS_SS, JS_RESET_TICKS_SS that
+ * are needed for BASE_HW_ISSUE_8408.
+ */
+kbase_attribute config_attributes_hw_issue_8408[] = {
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX,
+	 KBASE_VE_GPU_FREQ_KHZ_MAX},
+
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN,
+	 KBASE_VE_GPU_FREQ_KHZ_MIN},
+
+#ifdef CONFIG_MALI_DEBUG
+/* Use more aggressive scheduling timeouts in debug builds for testing purposes */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_8401_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_8401_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS_DEBUG},
+#else				/* CONFIG_MALI_DEBUG */
+/* In release builds same as the defaults but scaled for 5MHz FPGA */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_8401},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_8401},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS},
+#endif				/* CONFIG_MALI_DEBUG */
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS,
+	 KBASE_VE_JS_RESET_TIMEOUT_MS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS,
+	 KBASE_VE_JS_CTX_TIMESLICE_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS,
+	 KBASE_VE_POWER_MANAGEMENT_CALLBACKS},
+
+	{
+	 KBASE_CONFIG_ATTR_CPU_SPEED_FUNC,
+	 KBASE_VE_CPU_SPEED_FUNC},
+
+	{
+	 KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE,
+	 KBASE_VE_SECURE_BUT_LOSS_OF_PERFORMANCE},
+
+	{
+	 KBASE_CONFIG_ATTR_END,
+	 0}
+};
+
+static kbase_platform_config versatile_platform_config = {
+	.attributes = config_attributes,
+#ifndef CONFIG_OF
+	.io_resources = &io_resources
+#endif
+};
+
+kbase_platform_config *kbase_get_platform_config(void)
+{
+	return &versatile_platform_config;
+}
+
+int kbase_platform_early_init(void)
+{
+	/* Nothing needed at this stage */
+	return 0;
+}
diff --git a/drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_cpu_vexpress.c b/drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_cpu_vexpress.c
new file mode 100755
index 000000000000..1b45d3cb0e35
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_cpu_vexpress.c
@@ -0,0 +1,180 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+
+
+#include <linux/io.h>
+#include <mali_kbase.h>
+#include "mali_kbase_cpu_vexpress.h"
+
+#define HZ_IN_MHZ					    (1000000)
+
+#define CORETILE_EXPRESS_A9X4_SCC_START	(0x100E2000)
+#define MOTHERBOARD_SYS_CFG_START		(0x10000000)
+#define SYS_CFGDATA_OFFSET				(0x000000A0)
+#define SYS_CFGCTRL_OFFSET				(0x000000A4)
+#define SYS_CFGSTAT_OFFSET				(0x000000A8)
+
+#define SYS_CFGCTRL_START_BIT_VALUE		  (1 << 31)
+#define READ_REG_BIT_VALUE				  (0 << 30)
+#define DCC_DEFAULT_BIT_VALUE			  (0 << 26)
+#define SYS_CFG_OSC_FUNC_BIT_VALUE		  (1 << 20)
+#define SITE_DEFAULT_BIT_VALUE			  (1 << 16)
+#define BOARD_STACK_POS_DEFAULT_BIT_VALUE (0 << 12)
+#define DEVICE_DEFAULT_BIT_VALUE	      (2 <<  0)
+#define SYS_CFG_COMPLETE_BIT_VALUE		  (1 <<  0)
+#define SYS_CFG_ERROR_BIT_VALUE			  (1 <<  1)
+
+#define FEED_REG_BIT_MASK				(0x0F)
+#define FCLK_PA_DIVIDE_BIT_SHIFT		(0x03)
+#define FCLK_PB_DIVIDE_BIT_SHIFT		(0x07)
+#define FCLK_PC_DIVIDE_BIT_SHIFT		(0x0B)
+#define AXICLK_PA_DIVIDE_BIT_SHIFT		(0x0F)
+#define AXICLK_PB_DIVIDE_BIT_SHIFT		(0x13)
+
+#define IS_SINGLE_BIT_SET(val, pos)		(val&(1<<pos))
+
+#define CPU_CLOCK_SPEED_UNDEFINED 0
+
+static u32 cpu_clock_speed = CPU_CLOCK_SPEED_UNDEFINED;
+
+static DEFINE_RAW_SPINLOCK(syscfg_lock);
+/**
+ * kbase_get_vendor_specific_cpu_clock_speed
+ * @brief  Retrieves the CPU clock speed.
+ *         The implementation is platform specific.
+ * @param[out]    cpu_clock - the value of CPU clock speed in MHz
+ * @return        0 on success, 1 otherwise
+*/
+int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock)
+{
+
+
+	if (CPU_CLOCK_SPEED_UNDEFINED != cpu_clock_speed)
+	{
+		*cpu_clock = cpu_clock_speed;
+		return 0;
+	}
+	else
+	{
+		int result = 0;
+		u32 reg_val = 0;
+		u32 osc2_value = 0;
+		u32 pa_divide = 0;
+		u32 pb_divide = 0;
+		u32 pc_divide = 0;
+		void *volatile pSysCfgReg = 0;
+		void *volatile pSCCReg = 0;
+
+		/* Init the value case something goes wrong */
+		*cpu_clock = 0;
+
+		/* Map CPU register into virtual memory */
+		pSysCfgReg = ioremap(MOTHERBOARD_SYS_CFG_START, 0x1000);
+		if (pSysCfgReg == NULL) {
+			result = 1;
+
+			goto pSysCfgReg_map_failed;
+		}
+
+		pSCCReg = ioremap(CORETILE_EXPRESS_A9X4_SCC_START, 0x1000);
+		if (pSCCReg == NULL) {
+			result = 1;
+
+			goto pSCCReg_map_failed;
+		}
+
+		raw_spin_lock(&syscfg_lock);
+
+		/*Read SYS regs - OSC2 */
+		reg_val = readl(pSysCfgReg + SYS_CFGCTRL_OFFSET);
+
+		/*Verify if there is no other undergoing request */
+		if (!(reg_val & SYS_CFGCTRL_START_BIT_VALUE)) {
+			/*Reset the CGFGSTAT reg */
+			writel(0, (pSysCfgReg + SYS_CFGSTAT_OFFSET));
+
+			writel(SYS_CFGCTRL_START_BIT_VALUE | READ_REG_BIT_VALUE | DCC_DEFAULT_BIT_VALUE | SYS_CFG_OSC_FUNC_BIT_VALUE | SITE_DEFAULT_BIT_VALUE | BOARD_STACK_POS_DEFAULT_BIT_VALUE | DEVICE_DEFAULT_BIT_VALUE, (pSysCfgReg + SYS_CFGCTRL_OFFSET));
+			/* Wait for the transaction to complete */
+			while (!(readl(pSysCfgReg + SYS_CFGSTAT_OFFSET) & SYS_CFG_COMPLETE_BIT_VALUE))
+				;
+			/* Read SYS_CFGSTAT Register to get the status of submitted transaction */
+			reg_val = readl(pSysCfgReg + SYS_CFGSTAT_OFFSET);
+
+			/*------------------------------------------------------------------------------------------*/
+			/* Check for possible errors */
+			if (reg_val & SYS_CFG_ERROR_BIT_VALUE) {
+				/* Error while setting register */
+				result = 1;
+			} else {
+				osc2_value = readl(pSysCfgReg + SYS_CFGDATA_OFFSET);
+				/* Read the SCC CFGRW0 register */
+				reg_val = readl(pSCCReg);
+
+				/*
+				   Select the appropriate feed:
+				   CFGRW0[0] - CLKOB
+				   CFGRW0[1] - CLKOC
+				   CFGRW0[2] - FACLK (CLK)B FROM AXICLK PLL)
+				 */
+				/* Calculate the  FCLK */
+				if (IS_SINGLE_BIT_SET(reg_val, 0)) {	/*CFGRW0[0] - CLKOB */
+					/* CFGRW0[6:3] */
+					pa_divide = ((reg_val & (FEED_REG_BIT_MASK << FCLK_PA_DIVIDE_BIT_SHIFT)) >> FCLK_PA_DIVIDE_BIT_SHIFT);
+					/* CFGRW0[10:7] */
+					pb_divide = ((reg_val & (FEED_REG_BIT_MASK << FCLK_PB_DIVIDE_BIT_SHIFT)) >> FCLK_PB_DIVIDE_BIT_SHIFT);
+					*cpu_clock = osc2_value * (pa_divide + 1) / (pb_divide + 1);
+				} else {
+					if (IS_SINGLE_BIT_SET(reg_val, 1)) {	/*CFGRW0[1] - CLKOC */
+						/* CFGRW0[6:3] */
+						pa_divide = ((reg_val & (FEED_REG_BIT_MASK << FCLK_PA_DIVIDE_BIT_SHIFT)) >> FCLK_PA_DIVIDE_BIT_SHIFT);
+						/* CFGRW0[14:11] */
+						pc_divide = ((reg_val & (FEED_REG_BIT_MASK << FCLK_PC_DIVIDE_BIT_SHIFT)) >> FCLK_PC_DIVIDE_BIT_SHIFT);
+						*cpu_clock = osc2_value * (pa_divide + 1) / (pc_divide + 1);
+					} else if (IS_SINGLE_BIT_SET(reg_val, 2)) {	/*CFGRW0[2] - FACLK */
+						/* CFGRW0[18:15] */
+						pa_divide = ((reg_val & (FEED_REG_BIT_MASK << AXICLK_PA_DIVIDE_BIT_SHIFT)) >> AXICLK_PA_DIVIDE_BIT_SHIFT);
+						/* CFGRW0[22:19] */
+						pb_divide = ((reg_val & (FEED_REG_BIT_MASK << AXICLK_PB_DIVIDE_BIT_SHIFT)) >> AXICLK_PB_DIVIDE_BIT_SHIFT);
+						*cpu_clock = osc2_value * (pa_divide + 1) / (pb_divide + 1);
+					} else {
+						result = 1;
+					}
+				}
+			}
+		} else {
+			result = 1;
+		}
+		raw_spin_unlock(&syscfg_lock);
+		/* Convert result expressed in Hz to Mhz units. */
+		*cpu_clock /= HZ_IN_MHZ;
+		if(!result)
+		{
+			cpu_clock_speed = *cpu_clock;
+		}
+
+		/* Unmap memory */
+		iounmap(pSCCReg);
+
+	 pSCCReg_map_failed:
+		iounmap(pSysCfgReg);
+
+	 pSysCfgReg_map_failed:
+
+		return result;
+	}
+}
diff --git a/drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_cpu_vexpress.h b/drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_cpu_vexpress.h
new file mode 100755
index 000000000000..f607d1800a72
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress/mali_kbase_cpu_vexpress.h
@@ -0,0 +1,28 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+
+
+#ifndef _KBASE_CPU_VEXPRESS_H_
+#define _KBASE_CPU_VEXPRESS_H_
+
+/**
+ * Versatile Express implementation of @ref kbase_cpuprops_clock_speed_function.
+ */
+int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock);
+
+#endif				/* _KBASE_CPU_VEXPRESS_H_ */
diff --git a/drivers/gpu/arm/t6xx/Kbuild b/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/Kbuild
old mode 100644
new mode 100755
similarity index 87%
rename from drivers/gpu/arm/t6xx/Kbuild
rename to drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/Kbuild
index 48d08835e0e6..0cb41ce8952d
--- a/drivers/gpu/arm/t6xx/Kbuild
+++ b/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/Kbuild
@@ -14,4 +14,5 @@
 
 
 
-obj-$(CONFIG_MALI_T6XX) += kbase/
+obj-y += mali_kbase_config_vexpress.o
+obj-y += mali_kbase_cpu_vexpress.o
diff --git a/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c b/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c
new file mode 100755
index 000000000000..57e86d5c8a61
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c
@@ -0,0 +1,324 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+
+
+#include <linux/ioport.h>
+#include <mali_kbase.h>
+#include <mali_kbase_defs.h>
+#include <mali_kbase_config.h>
+#include "mali_kbase_cpu_vexpress.h"
+
+/* Versatile Express (VE) configuration defaults shared between config_attributes[]
+ * and config_attributes_hw_issue_8408[]. Settings are not shared for
+ * JS_HARD_STOP_TICKS_SS and JS_RESET_TICKS_SS.
+ */
+#define KBASE_VE_GPU_FREQ_KHZ_MAX               10000
+#define KBASE_VE_GPU_FREQ_KHZ_MIN               10000
+
+#define KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG    15000000u      /* 15ms, an agressive tick for testing purposes. This will reduce performance significantly */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG       1	/* between 15ms and 30ms before soft-stop a job */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_CL_DEBUG    1	/* between 15ms and 30ms before soft-stop a CL job */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_DEBUG    333	/* 5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_8401_DEBUG 2000	/* 30s before hard-stop, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) - for issue 8401 */
+#define KBASE_VE_JS_HARD_STOP_TICKS_CL_DEBUG    166	/* 2.5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG   100000	/* 1500s (25mins) before NSS hard-stop */
+#define KBASE_VE_JS_RESET_TICKS_SS_DEBUG        500	/* 45s before resetting GPU, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) */
+#define KBASE_VE_JS_RESET_TICKS_SS_8401_DEBUG   3000	/* 7.5s before resetting GPU - for issue 8401 */
+#define KBASE_VE_JS_RESET_TICKS_CL_DEBUG        500	/* 45s before resetting GPU */
+#define KBASE_VE_JS_RESET_TICKS_NSS_DEBUG       100166	/* 1502s before resetting GPU */
+
+#define KBASE_VE_JS_SCHEDULING_TICK_NS          1250000000u	/* 1.25s */
+#define KBASE_VE_JS_SOFT_STOP_TICKS             2	/* 2.5s before soft-stop a job */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_CL          1	/* 1.25s before soft-stop a CL job */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS          4	/* 5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_8401     24	/* 30s before hard-stop, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) - for issue 8401 */
+#define KBASE_VE_JS_HARD_STOP_TICKS_CL          2	/* 2.5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_NSS         1200	/* 1500s before NSS hard-stop */
+#define KBASE_VE_JS_RESET_TICKS_SS              6	/* 7.5s before resetting GPU */
+#define KBASE_VE_JS_RESET_TICKS_SS_8401         36	/* 45s before resetting GPU, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) - for issue 8401 */
+#define KBASE_VE_JS_RESET_TICKS_CL              3	/* 3.75s before resetting GPU */
+#define KBASE_VE_JS_RESET_TICKS_NSS             1201	/* 1502s before resetting GPU */
+
+#define KBASE_VE_JS_RESET_TIMEOUT_MS            3000	/* 3s before cancelling stuck jobs */
+#define KBASE_VE_JS_CTX_TIMESLICE_NS            1000000	/* 1ms - an agressive timeslice for testing purposes (causes lots of scheduling out for >4 ctxs) */
+#define KBASE_VE_SECURE_BUT_LOSS_OF_PERFORMANCE	((uintptr_t)MALI_FALSE)	/* By default we prefer performance over security on r0p0-15dev0 and KBASE_CONFIG_ATTR_ earlier */
+#define KBASE_VE_POWER_MANAGEMENT_CALLBACKS     ((uintptr_t)&pm_callbacks)
+#define KBASE_VE_CPU_SPEED_FUNC                 ((uintptr_t)&kbase_get_vexpress_cpu_clock_speed)
+
+#define HARD_RESET_AT_POWER_OFF 0
+
+#ifndef CONFIG_OF
+static kbase_io_resources io_resources = {
+	.job_irq_number = 75,
+	.mmu_irq_number = 76,
+	.gpu_irq_number = 77,
+	.io_memory_region = {
+			     .start = 0x2F000000,
+			     .end = 0x2F000000 + (4096 * 4) - 1}
+};
+#endif
+
+static int pm_callback_power_on(kbase_device *kbdev)
+{
+	/* Nothing is needed on VExpress, but we may have destroyed GPU state (if the below HARD_RESET code is active) */
+	return 1;
+}
+
+static void pm_callback_power_off(kbase_device *kbdev)
+{
+#if HARD_RESET_AT_POWER_OFF
+	/* Cause a GPU hard reset to test whether we have actually idled the GPU
+	 * and that we properly reconfigure the GPU on power up.
+	 * Usually this would be dangerous, but if the GPU is working correctly it should
+	 * be completely safe as the GPU should not be active at this point.
+	 * However this is disabled normally because it will most likely interfere with
+	 * bus logging etc.
+	 */
+	KBASE_TRACE_ADD(kbdev, CORE_GPU_HARD_RESET, NULL, NULL, 0u, 0);
+	kbase_os_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_HARD_RESET);
+#endif
+}
+
+static kbase_pm_callback_conf pm_callbacks = {
+	.power_on_callback = pm_callback_power_on,
+	.power_off_callback = pm_callback_power_off,
+	.power_suspend_callback  = NULL,
+	.power_resume_callback = NULL
+};
+
+/* Please keep table config_attributes in sync with config_attributes_hw_issue_8408 */
+static kbase_attribute config_attributes[] = {
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX,
+	 KBASE_VE_GPU_FREQ_KHZ_MAX},
+
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN,
+	 KBASE_VE_GPU_FREQ_KHZ_MIN},
+
+#ifdef CONFIG_MALI_DEBUG
+/* Use more aggressive scheduling timeouts in debug builds for testing purposes */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL,
+	 KBASE_VE_JS_HARD_STOP_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL,
+	 KBASE_VE_JS_RESET_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS_DEBUG},
+#else				/* CONFIG_MALI_DEBUG */
+/* In release builds same as the defaults but scaled for 5MHz FPGA */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL,
+	 KBASE_VE_JS_HARD_STOP_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL,
+	 KBASE_VE_JS_RESET_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS},
+#endif				/* CONFIG_MALI_DEBUG */
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS,
+	 KBASE_VE_JS_RESET_TIMEOUT_MS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS,
+	 KBASE_VE_JS_CTX_TIMESLICE_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS,
+	 KBASE_VE_POWER_MANAGEMENT_CALLBACKS},
+
+	{
+	 KBASE_CONFIG_ATTR_CPU_SPEED_FUNC,
+	 KBASE_VE_CPU_SPEED_FUNC},
+
+	{
+	 KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE,
+	 KBASE_VE_SECURE_BUT_LOSS_OF_PERFORMANCE},
+
+	{
+	 KBASE_CONFIG_ATTR_GPU_IRQ_THROTTLE_TIME_US,
+	 20},
+
+	{
+	 KBASE_CONFIG_ATTR_END,
+	 0}
+};
+
+/* as config_attributes array above except with different settings for
+ * JS_HARD_STOP_TICKS_SS, JS_RESET_TICKS_SS that
+ * are needed for BASE_HW_ISSUE_8408.
+ */
+kbase_attribute config_attributes_hw_issue_8408[] = {
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX,
+	 KBASE_VE_GPU_FREQ_KHZ_MAX},
+
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN,
+	 KBASE_VE_GPU_FREQ_KHZ_MIN},
+
+#ifdef CONFIG_MALI_DEBUG
+/* Use more aggressive scheduling timeouts in debug builds for testing purposes */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_8401_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_8401_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS_DEBUG},
+#else				/* CONFIG_MALI_DEBUG */
+/* In release builds same as the defaults but scaled for 5MHz FPGA */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_8401},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_8401},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS},
+#endif				/* CONFIG_MALI_DEBUG */
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS,
+	 KBASE_VE_JS_RESET_TIMEOUT_MS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS,
+	 KBASE_VE_JS_CTX_TIMESLICE_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS,
+	 KBASE_VE_POWER_MANAGEMENT_CALLBACKS},
+
+	{
+	 KBASE_CONFIG_ATTR_CPU_SPEED_FUNC,
+	 KBASE_VE_CPU_SPEED_FUNC},
+
+	{
+	 KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE,
+	 KBASE_VE_SECURE_BUT_LOSS_OF_PERFORMANCE},
+
+	{
+	 KBASE_CONFIG_ATTR_END,
+	 0}
+};
+
+static kbase_platform_config versatile_platform_config = {
+	.attributes = config_attributes,
+#ifndef CONFIG_OF
+	.io_resources = &io_resources
+#endif
+};
+
+kbase_platform_config *kbase_get_platform_config(void)
+{
+	return &versatile_platform_config;
+}
+
+int kbase_platform_early_init(void)
+{
+	/* Nothing needed at this stage */
+	return 0;
+}
+
diff --git a/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c b/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c
new file mode 100755
index 000000000000..1577f8cef787
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c
@@ -0,0 +1,71 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+
+
+#include <linux/io.h>
+#include <mali_kbase.h>
+#include "mali_kbase_cpu_vexpress.h"
+
+#define HZ_IN_MHZ					    (1000000)
+
+#define CORETILE_EXPRESS_A9X4_SCC_START	(0x100E2000)
+#define MOTHERBOARD_SYS_CFG_START		(0x10000000)
+#define SYS_CFGDATA_OFFSET				(0x000000A0)
+#define SYS_CFGCTRL_OFFSET				(0x000000A4)
+#define SYS_CFGSTAT_OFFSET				(0x000000A8)
+
+#define SYS_CFGCTRL_START_BIT_VALUE		  (1 << 31)
+#define READ_REG_BIT_VALUE				  (0 << 30)
+#define DCC_DEFAULT_BIT_VALUE			  (0 << 26)
+#define SYS_CFG_OSC_FUNC_BIT_VALUE		  (1 << 20)
+#define SITE_DEFAULT_BIT_VALUE			  (1 << 16)
+#define BOARD_STACK_POS_DEFAULT_BIT_VALUE (0 << 12)
+#define DEVICE_DEFAULT_BIT_VALUE	      (2 <<  0)
+#define SYS_CFG_COMPLETE_BIT_VALUE		  (1 <<  0)
+#define SYS_CFG_ERROR_BIT_VALUE			  (1 <<  1)
+
+#define FEED_REG_BIT_MASK				(0x0F)
+#define FCLK_PA_DIVIDE_BIT_SHIFT		(0x03)
+#define FCLK_PB_DIVIDE_BIT_SHIFT		(0x07)
+#define FCLK_PC_DIVIDE_BIT_SHIFT		(0x0B)
+#define AXICLK_PA_DIVIDE_BIT_SHIFT		(0x0F)
+#define AXICLK_PB_DIVIDE_BIT_SHIFT		(0x13)
+
+#define IS_SINGLE_BIT_SET(val, pos)		(val&(1<<pos))
+
+#define CPU_CLOCK_SPEED_UNDEFINED 0
+
+#define CPU_CLOCK_SPEED_6XV7 50
+
+static u32 cpu_clock_speed = CPU_CLOCK_SPEED_UNDEFINED;
+
+static DEFINE_RAW_SPINLOCK(syscfg_lock);
+/**
+ * kbase_get_vendor_specific_cpu_clock_speed
+ * @brief  Retrieves the CPU clock speed.
+ *         The implementation is platform specific.
+ * @param[out]    cpu_clock - the value of CPU clock speed in MHz
+ * @return        0 on success, 1 otherwise
+*/
+int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock)
+{
+	/* TODO: MIDBASE-2873 - Provide runtime detection of CPU clock freq for 6XV7 board */
+	*cpu_clock = CPU_CLOCK_SPEED_6XV7;
+
+	return 0;
+}
diff --git a/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.h b/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.h
new file mode 100755
index 000000000000..f607d1800a72
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.h
@@ -0,0 +1,28 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+
+
+#ifndef _KBASE_CPU_VEXPRESS_H_
+#define _KBASE_CPU_VEXPRESS_H_
+
+/**
+ * Versatile Express implementation of @ref kbase_cpuprops_clock_speed_function.
+ */
+int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock);
+
+#endif				/* _KBASE_CPU_VEXPRESS_H_ */
diff --git a/drivers/gpu/arm/t6xx/kbase/Kbuild b/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/Kbuild
old mode 100644
new mode 100755
similarity index 87%
rename from drivers/gpu/arm/t6xx/kbase/Kbuild
rename to drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/Kbuild
index 2bbdba27d76f..32c707030b0f
--- a/drivers/gpu/arm/t6xx/kbase/Kbuild
+++ b/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/Kbuild
@@ -13,6 +13,5 @@
 #
 
 
-
-obj-y += src/
-
+obj-y += mali_kbase_config_vexpress.o
+obj-y += mali_kbase_cpu_vexpress.o
diff --git a/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_config_vexpress.c b/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_config_vexpress.c
new file mode 100755
index 000000000000..c403fde188bd
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_config_vexpress.c
@@ -0,0 +1,323 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#include <linux/ioport.h>
+#include <mali_kbase.h>
+#include <mali_kbase_defs.h>
+#include <mali_kbase_config.h>
+
+#include "mali_kbase_cpu_vexpress.h"
+
+/* Versatile Express (VE) configuration defaults shared between config_attributes[]
+ * and config_attributes_hw_issue_8408[]. Settings are not shared for
+ * JS_HARD_STOP_TICKS_SS and JS_RESET_TICKS_SS.
+ */
+#define KBASE_VE_GPU_FREQ_KHZ_MAX               40000
+#define KBASE_VE_GPU_FREQ_KHZ_MIN               40000
+
+#define KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG    15000000u      /* 15ms, an agressive tick for testing purposes. This will reduce performance significantly */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG       1	/* between 15ms and 30ms before soft-stop a job */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_CL_DEBUG    1	/* between 15ms and 30ms before soft-stop a CL job */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_DEBUG    333	/* 5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_8401_DEBUG 2000	/* 30s before hard-stop, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) - for issue 8401 */
+#define KBASE_VE_JS_HARD_STOP_TICKS_CL_DEBUG    166	/* 2.5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG   100000	/* 1500s (25mins) before NSS hard-stop */
+#define KBASE_VE_JS_RESET_TICKS_SS_DEBUG        500	/* 45s before resetting GPU, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) */
+#define KBASE_VE_JS_RESET_TICKS_SS_8401_DEBUG   3000	/* 7.5s before resetting GPU - for issue 8401 */
+#define KBASE_VE_JS_RESET_TICKS_CL_DEBUG        500	/* 45s before resetting GPU */
+#define KBASE_VE_JS_RESET_TICKS_NSS_DEBUG       100166	/* 1502s before resetting GPU */
+
+#define KBASE_VE_JS_SCHEDULING_TICK_NS          1250000000u	/* 1.25s */
+#define KBASE_VE_JS_SOFT_STOP_TICKS             2	/* 2.5s before soft-stop a job */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_CL          1	/* 1.25s before soft-stop a CL job */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS          4	/* 5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_8401     24	/* 30s before hard-stop, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) - for issue 8401 */
+#define KBASE_VE_JS_HARD_STOP_TICKS_CL          2	/* 2.5s before hard-stop */
+#define KBASE_VE_JS_HARD_STOP_TICKS_NSS         1200	/* 1500s before NSS hard-stop */
+#define KBASE_VE_JS_RESET_TICKS_SS              6	/* 7.5s before resetting GPU */
+#define KBASE_VE_JS_RESET_TICKS_SS_8401         36	/* 45s before resetting GPU, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) - for issue 8401 */
+#define KBASE_VE_JS_RESET_TICKS_CL              3	/* 3.75s before resetting GPU */
+#define KBASE_VE_JS_RESET_TICKS_NSS             1201	/* 1502s before resetting GPU */
+
+#define KBASE_VE_JS_RESET_TIMEOUT_MS            3000	/* 3s before cancelling stuck jobs */
+#define KBASE_VE_JS_CTX_TIMESLICE_NS            1000000	/* 1ms - an agressive timeslice for testing purposes (causes lots of scheduling out for >4 ctxs) */
+#define KBASE_VE_SECURE_BUT_LOSS_OF_PERFORMANCE	((uintptr_t)MALI_FALSE)	/* By default we prefer performance over security on r0p0-15dev0 and KBASE_CONFIG_ATTR_ earlier */
+#define KBASE_VE_POWER_MANAGEMENT_CALLBACKS     ((uintptr_t)&pm_callbacks)
+#define KBASE_VE_CPU_SPEED_FUNC                 ((uintptr_t)&kbase_get_vexpress_cpu_clock_speed)
+
+#define HARD_RESET_AT_POWER_OFF 0
+
+#ifndef CONFIG_OF
+static kbase_io_resources io_resources = {
+	.job_irq_number = 68,
+	.mmu_irq_number = 69,
+	.gpu_irq_number = 70,
+	.io_memory_region = {
+			     .start = 0xFC010000,
+			     .end = 0xFC010000 + (4096 * 4) - 1}
+};
+#endif
+
+static int pm_callback_power_on(kbase_device *kbdev)
+{
+	/* Nothing is needed on VExpress, but we may have destroyed GPU state (if the below HARD_RESET code is active) */
+	return 1;
+}
+
+static void pm_callback_power_off(kbase_device *kbdev)
+{
+#if HARD_RESET_AT_POWER_OFF
+	/* Cause a GPU hard reset to test whether we have actually idled the GPU
+	 * and that we properly reconfigure the GPU on power up.
+	 * Usually this would be dangerous, but if the GPU is working correctly it should
+	 * be completely safe as the GPU should not be active at this point.
+	 * However this is disabled normally because it will most likely interfere with
+	 * bus logging etc.
+	 */
+	KBASE_TRACE_ADD(kbdev, CORE_GPU_HARD_RESET, NULL, NULL, 0u, 0);
+	kbase_os_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_HARD_RESET);
+#endif
+}
+
+static kbase_pm_callback_conf pm_callbacks = {
+	.power_on_callback = pm_callback_power_on,
+	.power_off_callback = pm_callback_power_off,
+	.power_suspend_callback  = NULL,
+	.power_resume_callback = NULL
+};
+
+/* Please keep table config_attributes in sync with config_attributes_hw_issue_8408 */
+static kbase_attribute config_attributes[] = {
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX,
+	 KBASE_VE_GPU_FREQ_KHZ_MAX},
+
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN,
+	 KBASE_VE_GPU_FREQ_KHZ_MIN},
+
+#ifdef CONFIG_MALI_DEBUG
+/* Use more aggressive scheduling timeouts in debug builds for testing purposes */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL,
+	 KBASE_VE_JS_HARD_STOP_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL,
+	 KBASE_VE_JS_RESET_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS_DEBUG},
+#else				/* CONFIG_MALI_DEBUG */
+/* In release builds same as the defaults but scaled for 5MHz FPGA */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL,
+	 KBASE_VE_JS_HARD_STOP_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL,
+	 KBASE_VE_JS_RESET_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS},
+#endif				/* CONFIG_MALI_DEBUG */
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS,
+	 KBASE_VE_JS_RESET_TIMEOUT_MS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS,
+	 KBASE_VE_JS_CTX_TIMESLICE_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS,
+	 KBASE_VE_POWER_MANAGEMENT_CALLBACKS},
+
+	{
+	 KBASE_CONFIG_ATTR_CPU_SPEED_FUNC,
+	 KBASE_VE_CPU_SPEED_FUNC},
+
+	{
+	 KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE,
+	 KBASE_VE_SECURE_BUT_LOSS_OF_PERFORMANCE},
+
+	{
+	 KBASE_CONFIG_ATTR_GPU_IRQ_THROTTLE_TIME_US,
+	 20},
+
+	{
+	 KBASE_CONFIG_ATTR_END,
+	 0}
+};
+
+/* as config_attributes array above except with different settings for
+ * JS_HARD_STOP_TICKS_SS, JS_RESET_TICKS_SS that
+ * are needed for BASE_HW_ISSUE_8408.
+ */
+kbase_attribute config_attributes_hw_issue_8408[] = {
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX,
+	 KBASE_VE_GPU_FREQ_KHZ_MAX},
+
+	{
+	 KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN,
+	 KBASE_VE_GPU_FREQ_KHZ_MIN},
+
+#ifdef CONFIG_MALI_DEBUG
+/* Use more aggressive scheduling timeouts in debug builds for testing purposes */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_8401_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_8401_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS_DEBUG},
+#else				/* CONFIG_MALI_DEBUG */
+/* In release builds same as the defaults but scaled for 5MHz FPGA */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_8401},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_8401},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS},
+#endif				/* CONFIG_MALI_DEBUG */
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS,
+	 KBASE_VE_JS_RESET_TIMEOUT_MS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS,
+	 KBASE_VE_JS_CTX_TIMESLICE_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS,
+	 KBASE_VE_POWER_MANAGEMENT_CALLBACKS},
+
+	{
+	 KBASE_CONFIG_ATTR_CPU_SPEED_FUNC,
+	 KBASE_VE_CPU_SPEED_FUNC},
+
+	{
+	 KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE,
+	 KBASE_VE_SECURE_BUT_LOSS_OF_PERFORMANCE},
+
+	{
+	 KBASE_CONFIG_ATTR_END,
+	 0}
+};
+
+static kbase_platform_config virtex7_platform_config = {
+	.attributes = config_attributes,
+#ifndef CONFIG_OF
+	.io_resources = &io_resources
+#endif
+};
+
+kbase_platform_config *kbase_get_platform_config(void)
+{
+	return &virtex7_platform_config;
+}
+
+int kbase_platform_early_init(void)
+{
+	/* Nothing needed at this stage */
+	return 0;
+}
+
diff --git a/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.c b/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.c
new file mode 100755
index 000000000000..47d45e2daf69
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.c
@@ -0,0 +1,178 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#include <linux/io.h>
+#include <mali_kbase.h>
+#include "mali_kbase_cpu_vexpress.h"
+
+#define HZ_IN_MHZ					    (1000000)
+
+#define CORETILE_EXPRESS_A9X4_SCC_START	(0x100E2000)
+#define MOTHERBOARD_SYS_CFG_START		(0x10000000)
+#define SYS_CFGDATA_OFFSET				(0x000000A0)
+#define SYS_CFGCTRL_OFFSET				(0x000000A4)
+#define SYS_CFGSTAT_OFFSET				(0x000000A8)
+
+#define SYS_CFGCTRL_START_BIT_VALUE		  (1 << 31)
+#define READ_REG_BIT_VALUE				  (0 << 30)
+#define DCC_DEFAULT_BIT_VALUE			  (0 << 26)
+#define SYS_CFG_OSC_FUNC_BIT_VALUE		  (1 << 20)
+#define SITE_DEFAULT_BIT_VALUE			  (1 << 16)
+#define BOARD_STACK_POS_DEFAULT_BIT_VALUE (0 << 12)
+#define DEVICE_DEFAULT_BIT_VALUE	      (2 <<  0)
+#define SYS_CFG_COMPLETE_BIT_VALUE		  (1 <<  0)
+#define SYS_CFG_ERROR_BIT_VALUE			  (1 <<  1)
+
+#define FEED_REG_BIT_MASK				(0x0F)
+#define FCLK_PA_DIVIDE_BIT_SHIFT		(0x03)
+#define FCLK_PB_DIVIDE_BIT_SHIFT		(0x07)
+#define FCLK_PC_DIVIDE_BIT_SHIFT		(0x0B)
+#define AXICLK_PA_DIVIDE_BIT_SHIFT		(0x0F)
+#define AXICLK_PB_DIVIDE_BIT_SHIFT		(0x13)
+
+#define IS_SINGLE_BIT_SET(val, pos)		(val&(1<<pos))
+
+#define CPU_CLOCK_SPEED_UNDEFINED 0
+
+static u32 cpu_clock_speed = CPU_CLOCK_SPEED_UNDEFINED;
+
+static DEFINE_RAW_SPINLOCK(syscfg_lock);
+/**
+ * kbase_get_vendor_specific_cpu_clock_speed
+ * @brief  Retrieves the CPU clock speed.
+ *         The implementation is platform specific.
+ * @param[out]    cpu_clock - the value of CPU clock speed in MHz
+ * @return        0 on success, 1 otherwise
+*/
+int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock)
+{
+
+
+	if (CPU_CLOCK_SPEED_UNDEFINED != cpu_clock_speed)
+	{
+		*cpu_clock = cpu_clock_speed;
+		return 0;
+	}
+	else
+	{
+		int result = 0;
+		u32 reg_val = 0;
+		u32 osc2_value = 0;
+		u32 pa_divide = 0;
+		u32 pb_divide = 0;
+		u32 pc_divide = 0;
+		void *volatile pSysCfgReg = 0;
+		void *volatile pSCCReg = 0;
+
+		/* Init the value case something goes wrong */
+		*cpu_clock = 0;
+
+		/* Map CPU register into virtual memory */
+		pSysCfgReg = ioremap(MOTHERBOARD_SYS_CFG_START, 0x1000);
+		if (pSysCfgReg == NULL) {
+			result = 1;
+
+			goto pSysCfgReg_map_failed;
+		}
+
+		pSCCReg = ioremap(CORETILE_EXPRESS_A9X4_SCC_START, 0x1000);
+		if (pSCCReg == NULL) {
+			result = 1;
+
+			goto pSCCReg_map_failed;
+		}
+
+		raw_spin_lock(&syscfg_lock);
+
+		/*Read SYS regs - OSC2 */
+		reg_val = readl(pSysCfgReg + SYS_CFGCTRL_OFFSET);
+
+		/*Verify if there is no other undergoing request */
+		if (!(reg_val & SYS_CFGCTRL_START_BIT_VALUE)) {
+			/*Reset the CGFGSTAT reg */
+			writel(0, (pSysCfgReg + SYS_CFGSTAT_OFFSET));
+
+			writel(SYS_CFGCTRL_START_BIT_VALUE | READ_REG_BIT_VALUE | DCC_DEFAULT_BIT_VALUE | SYS_CFG_OSC_FUNC_BIT_VALUE | SITE_DEFAULT_BIT_VALUE | BOARD_STACK_POS_DEFAULT_BIT_VALUE | DEVICE_DEFAULT_BIT_VALUE, (pSysCfgReg + SYS_CFGCTRL_OFFSET));
+			/* Wait for the transaction to complete */
+			while (!(readl(pSysCfgReg + SYS_CFGSTAT_OFFSET) & SYS_CFG_COMPLETE_BIT_VALUE))
+				;
+			/* Read SYS_CFGSTAT Register to get the status of submitted transaction */
+			reg_val = readl(pSysCfgReg + SYS_CFGSTAT_OFFSET);
+
+			/*------------------------------------------------------------------------------------------*/
+			/* Check for possible errors */
+			if (reg_val & SYS_CFG_ERROR_BIT_VALUE) {
+				/* Error while setting register */
+				result = 1;
+			} else {
+				osc2_value = readl(pSysCfgReg + SYS_CFGDATA_OFFSET);
+				/* Read the SCC CFGRW0 register */
+				reg_val = readl(pSCCReg);
+
+				/*
+				   Select the appropriate feed:
+				   CFGRW0[0] - CLKOB
+				   CFGRW0[1] - CLKOC
+				   CFGRW0[2] - FACLK (CLK)B FROM AXICLK PLL)
+				 */
+				/* Calculate the  FCLK */
+				if (IS_SINGLE_BIT_SET(reg_val, 0)) {	/*CFGRW0[0] - CLKOB */
+					/* CFGRW0[6:3] */
+					pa_divide = ((reg_val & (FEED_REG_BIT_MASK << FCLK_PA_DIVIDE_BIT_SHIFT)) >> FCLK_PA_DIVIDE_BIT_SHIFT);
+					/* CFGRW0[10:7] */
+					pb_divide = ((reg_val & (FEED_REG_BIT_MASK << FCLK_PB_DIVIDE_BIT_SHIFT)) >> FCLK_PB_DIVIDE_BIT_SHIFT);
+					*cpu_clock = osc2_value * (pa_divide + 1) / (pb_divide + 1);
+				} else {
+					if (IS_SINGLE_BIT_SET(reg_val, 1)) {	/*CFGRW0[1] - CLKOC */
+						/* CFGRW0[6:3] */
+						pa_divide = ((reg_val & (FEED_REG_BIT_MASK << FCLK_PA_DIVIDE_BIT_SHIFT)) >> FCLK_PA_DIVIDE_BIT_SHIFT);
+						/* CFGRW0[14:11] */
+						pc_divide = ((reg_val & (FEED_REG_BIT_MASK << FCLK_PC_DIVIDE_BIT_SHIFT)) >> FCLK_PC_DIVIDE_BIT_SHIFT);
+						*cpu_clock = osc2_value * (pa_divide + 1) / (pc_divide + 1);
+					} else if (IS_SINGLE_BIT_SET(reg_val, 2)) {	/*CFGRW0[2] - FACLK */
+						/* CFGRW0[18:15] */
+						pa_divide = ((reg_val & (FEED_REG_BIT_MASK << AXICLK_PA_DIVIDE_BIT_SHIFT)) >> AXICLK_PA_DIVIDE_BIT_SHIFT);
+						/* CFGRW0[22:19] */
+						pb_divide = ((reg_val & (FEED_REG_BIT_MASK << AXICLK_PB_DIVIDE_BIT_SHIFT)) >> AXICLK_PB_DIVIDE_BIT_SHIFT);
+						*cpu_clock = osc2_value * (pa_divide + 1) / (pb_divide + 1);
+					} else {
+						result = 1;
+					}
+				}
+			}
+		} else {
+			result = 1;
+		}
+		raw_spin_unlock(&syscfg_lock);
+		/* Convert result expressed in Hz to Mhz units. */
+		*cpu_clock /= HZ_IN_MHZ;
+		if(!result)
+		{
+			cpu_clock_speed = *cpu_clock;
+		}
+
+		/* Unmap memory */
+		iounmap(pSCCReg);
+
+	 pSCCReg_map_failed:
+		iounmap(pSysCfgReg);
+
+	 pSysCfgReg_map_failed:
+
+		return result;
+	}
+}
diff --git a/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.h b/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.h
new file mode 100755
index 000000000000..3f6c68ece392
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.h
@@ -0,0 +1,26 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#ifndef _KBASE_CPU_VEXPRESS_H_
+#define _KBASE_CPU_VEXPRESS_H_
+
+/**
+ * Versatile Express implementation of @ref kbase_cpuprops_clock_speed_function.
+ */
+int kbase_get_vexpress_cpu_clock_speed(u32 *cpu_clock);
+
+#endif				/* _KBASE_CPU_VEXPRESS_H_ */
diff --git a/drivers/gpu/arm/t6xx/kbase/platform_dummy/mali_ukk_os.h b/drivers/gpu/arm/midgard/platform_dummy/mali_ukk_os.h
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/platform_dummy/mali_ukk_os.h
rename to drivers/gpu/arm/midgard/platform_dummy/mali_ukk_os.h
diff --git a/drivers/gpu/arm/midgard/sconscript b/drivers/gpu/arm/midgard/sconscript
new file mode 100755
index 000000000000..9d463784e6ac
--- /dev/null
+++ b/drivers/gpu/arm/midgard/sconscript
@@ -0,0 +1,114 @@
+#
+# (C) COPYRIGHT 2010-2013 ARM Limited. All rights reserved.
+#
+# This program is free software and is provided to you under the terms of the
+# GNU General Public License version 2 as published by the Free Software
+# Foundation, and any use by you of this program is subject to the terms
+# of such GNU licence.
+#
+# A copy of the licence is included with the program, and can also be obtained
+# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+# Boston, MA  02110-1301, USA.
+#
+#
+
+
+
+import os
+import re
+import sys
+Import('env')
+
+if Glob('tests/sconscript'):
+	SConscript( 'tests/sconscript' )
+
+mock_test = 0
+
+if env['v'] != '1':
+	env['MAKECOMSTR'] = '[MAKE] ${SOURCE.dir}'
+
+# Fake platform is a transient solution for GPL drivers running in kernel that does not provide configuration via platform data.
+# For such kernels fake_platform_device should be set to 1. For kernels providing platform data fake_platform_device should be set to 0.
+fake_platform_device = 1
+
+# Source files required for kbase.
+kbase_src = [Glob('#kernel/drivers/gpu/arm/midgard/*.c'),
+             Glob('#kernel/drivers/gpu/arm/midgard/*.c'),
+             Glob('#kernel/drivers/gpu/arm/midgard/platform/%s/*.c' % (env['platform_config'])),
+             Glob('#kernel/drivers/gpu/arm/midgard/*.h'),
+             Glob('#kernel/drivers/gpu/arm/midgard/*.h'),
+             ]
+
+if Glob('#kernel/drivers/gpu/arm/midgard/tests/internal/src/mock') and env['unit'] == '1':
+	kbase_src += [Glob('#kernel/drivers/gpu/arm/midgard/tests/internal/src/mock/*.c')]
+	mock_test = 1
+
+# we need platform config for GPL version using fake platform
+if fake_platform_device==1:
+	# Check if we are compiling for PBX
+	linux_config_file = os.path.normpath(os.environ['KDIR']) + '/.config'
+	search_term = '^[\ ]*CONFIG_MACH_REALVIEW_PBX[\ ]*=[\ ]*y'
+	REALVIEW_PBX = 0
+	for line in open(linux_config_file, 'r'):
+		if re.search(search_term, line):
+			REALVIEW_PBX = 1
+			break
+	if REALVIEW_PBX == 1 and (env['platform_config'] == 'vexpress' or env['platform_config'] == 'vexpress_virtex7_40mhz' or env['platform_config'] == 'vexpress_6xvirtex7_10mhz'):
+		sys.stderr.write("WARNING: Building for a PBX kernel but with platform_config=vexpress*\n")
+	# if the file platform config file is in the tpip directory then use that, otherwise use the default config directory
+	if Glob('#kernel/drivers/gpu/arm/midgard/config/tpip/*%s.c' % (env['platform_config'])):
+		kbase_src += Glob('#kernel/drivers/gpu/arm/midgard/config/tpip/*%s.c' % (env['platform_config']))
+	else:
+		kbase_src += Glob('#kernel/drivers/gpu/arm/midgard/config/*%s.c' % (env['platform_config']))
+	
+# Note: cleaning via the Linux kernel build system does not yet work
+if env.GetOption('clean') :
+	makeAction=Action("cd ${SOURCE.dir} && make clean", '$MAKECOMSTR')
+	cmd = env.Command(['$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/mali_platform_fake.ko'], kbase_src, [makeAction])
+else:
+	if env['os'] == 'android':
+		env['android'] = 1
+	else:
+		env['android'] = 0
+
+	if env['unit'] == '1':
+		env['kernel_test'] = 1
+	else:
+		env['kernel_test'] = 0
+
+	makeAction=Action("cd ${SOURCE.dir} && make PLATFORM=${platform} MALI_ERROR_INJECT_ON=${error_inject} MALI_ANDROID=${android} MALI_KERNEL_TEST_API=${kernel_test} MALI_UNIT_TEST=${unit} MALI_RELEASE_NAME=\"${mali_release_name}\" MALI_MOCK_TEST=%s MALI_CUSTOMER_RELEASE=${release} MALI_INSTRUMENTATION_LEVEL=${instr} MALI_COVERAGE=${coverage} %s && cp mali_kbase.ko $STATIC_LIB_PATH/mali_kbase.ko" % (mock_test, env.kernel_get_config_defines(fake_platform_device)), '$MAKECOMSTR')
+	cmd = env.Command('$STATIC_LIB_PATH/mali_kbase.ko', kbase_src, [makeAction])
+
+# Add a dependency on kds.ko.
+# Only necessary when KDS is not built into the kernel.
+#
+if env['os'] != 'android':
+	linux_config_file = os.path.normpath(os.environ['KDIR']) + '/.config'
+	search_term = '^[\ ]*CONFIG_KDS[\ ]*=[\ ]*y'
+	kds_in_kernel = 0
+	for line in open(linux_config_file, 'r'):
+		if re.search(search_term, line):
+	        # KDS in kernel.
+			kds_in_kernel = 1
+	if not kds_in_kernel:
+		env.Depends('$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/kds.ko')
+
+# need Module.symvers from ump.ko build
+if int(env['ump']) == 1:
+	env.Depends('$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/ump.ko')
+
+# Until we fathom out how the invoke the Linux build system to clean, we can use Clean
+# to remove generated files.
+patterns = ['*.mod.c', '*.o', '*.ko', '*.a', '.*.cmd', 'modules.order', '.tmp_versions', 'Module.symvers']
+
+for p in patterns:
+	Clean(cmd, Glob('#kernel/drivers/gpu/arm/midgard/%s' % p))
+	Clean(cmd, Glob('#kernel/drivers/gpu/arm/midgard/%s' % p))
+	Clean(cmd, Glob('#kernel/drivers/gpu/arm/midgard/config/%s' % p))
+	Clean(cmd, Glob('#kernel/drivers/gpu/arm/midgard/%s' % p))
+	Clean(cmd, Glob('#kernel/drivers/gpu/arm/midgard/tests/internal/src/mock/%s' % p))
+	Clean(cmd, Glob('#kernel/drivers/gpu/arm/midgard/platform/%s/%s' % ((env['platform_config']), p) ))
+
+env.ProgTarget('kbase', cmd)
+
+env.AppendUnique(BASE=['cutils_list'])
diff --git a/drivers/gpu/arm/t6xx/kbase/tests/customer/sconscript b/drivers/gpu/arm/midgard/tests/customer/sconscript
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/tests/customer/sconscript
rename to drivers/gpu/arm/midgard/tests/customer/sconscript
diff --git a/drivers/gpu/arm/t6xx/kbase/tests/sconscript b/drivers/gpu/arm/midgard/tests/sconscript
old mode 100644
new mode 100755
similarity index 100%
rename from drivers/gpu/arm/t6xx/kbase/tests/sconscript
rename to drivers/gpu/arm/midgard/tests/sconscript
diff --git a/drivers/gpu/arm/sconscript b/drivers/gpu/arm/sconscript
old mode 100644
new mode 100755
index daea3236d6e2..c31eec7cc170
--- a/drivers/gpu/arm/sconscript
+++ b/drivers/gpu/arm/sconscript
@@ -15,4 +15,4 @@
 
 
 
-SConscript('t6xx/sconscript')
+SConscript('midgard/sconscript')
diff --git a/drivers/gpu/arm/t6xx/kbase/Makefile b/drivers/gpu/arm/t6xx/kbase/Makefile
deleted file mode 100644
index 54de864b2b98..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/Makefile
+++ /dev/null
@@ -1,103 +0,0 @@
-#
-# (C) COPYRIGHT 2011-2013 ARM Limited. All rights reserved.
-#
-# This program is free software and is provided to you under the terms of the
-# GNU General Public License version 2 as published by the Free Software
-# Foundation, and any use by you of this program is subject to the terms
-# of such GNU licence.
-#
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
-#
-#
-
-
-
-# Defaults
-export PLATFORM?=rk
-export MALI_ANDROID?=1
-export MALI_UNIT_TEST?=0
-export MALI_KERNEL_TEST_API?=0
-export MALI_MOCK_TEST?=0
-export MALI_INSTRUMENTATION_LEVEL?=0
-export MALI_CUSTOMER_RELEASE?=1
-export MALI_COVERAGE?=0
-export CONFIG_MALI_NO_MALI?=n
-export CONFIG_UMP?=m
-export CONFIG_MALI_DEBUG?=y
-export CONFIG_MALI_ERROR_INJECT?=y
-export CONFIG_MALI_PLATFORM_FAKE?=y
-export CONFIG_MALI_PLATFORM_VEXPRESS?=n
-export CONFIG_MALI_PLATFORM_THIRDPARTY?=y
-export CONFIG_MALI_PLATFORM_THIRDPARTY_NAME?=rk
-export CONFIG_MALI_GATOR_SUPPORT?=y
-export CONFIG_MALI_T6XX?=m
-export CONFIG_KDS?=m
-export CONFIG_MALI_DEBUG_SHADER_SPLIT_FS?=n
-export CONFIG_MALI_TRACE_TIMELINE?=n
-
-ifeq ($(CONFIG_MALI_NO_MALI),y)
-	SCONS_CFLAGS+=-DCONFIG_MALI_NO_MALI
-endif
-ifeq ($(CONFIG_UMP),m)
-	SCONS_CFLAGS+=-DCONFIG_UMP
-endif
-ifeq ($(CONFIG_MALI_DEBUG),y)
-	SCONS_CFLAGS+=-DCONFIG_MALI_DEBUG
-endif
-ifeq ($(CONFIG_MALI_DEBUG_SHADER_SPLIT_FS),y)
-	SCONS_CFLAGS+=-DCONFIG_MALI_DEBUG_SHADER_SPLIT_FS
-endif
-ifeq ($(CONFIG_MALI_ERROR_INJECT),y)
-	SCONS_CFLAGS+=-DCONFIG_MALI_ERROR_INJECT
-endif
-ifneq ($(CONFIG_MALI_PLATFORM_FAKE),n)
-	SCONS_CFLAGS+=-DCONFIG_MALI_PLATFORM_FAKE
-endif
-ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS),y)
-	SCONS_CFLAGS+=-DCONFIG_MALI_PLATFORM_VEXPRESS
-endif
-ifeq ($(CONFIG_MALI_PLATFORM_THIRDPARTY),y)
-	SCONS_CFLAGS+=-DCONFIG_MALI_PLATFORM_THIRDPARTY
-	SCONS_CFLAGS+=-DCONFIG_MALI_PLATFORM_THIRDPARTY_NAME
-endif
-ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS_VIRTEX7_40MHZ),y)
-	SCONS_CFLAGS+=-DCONFIG_MALI_PLATFORM_VEXPRESS_VIRTEX7_40MHZ
-endif
-ifeq ($(CONFIG_MALI_GATOR_SUPPORT),y)
-	SCONS_CFLAGS+=-DCONFIG_MALI_GATOR_SUPPORT
-endif
-ifeq ($(CONFIG_KDS),m)
-	SCONS_CFLAGS+=-DCONFIG_KDS
-endif
-ifeq ($(CONFIG_MALI_TRACE_TIMELINE),y)
-	SCONS_CFLAGS+=-DCONFIG_MALI_TRACE_TIMELINE
-endif
-export SCONS_CFLAGS
-
-KDIR ?= /lib/modules/$(shell uname -r)/build
-
-# MROOT defines root of kernel device driver components
-# This makefile may reside in container directory of the kernel device driver components or within the
-# 'kbase' kernel driver component itself, so we set MROOT accordingly.
-#
-ifeq ($(wildcard $(PWD)/kbase/src/Makefile),)
-MROOT=$(PWD)/../../../../../..
-else
-MROOT=$(PWD)
-endif
-
-KBASE_PATH=$(MROOT)/kernel/drivers/gpu/arm/t6xx/kbase
-UMP_PATH=$(MROOT)/kernel/drivers/base/ump
-KDS_PATH=$(MROOT)/kernel/drivers/base/kds
-
-all:
-	$(MAKE) -C $(KDS_PATH)
-	$(MAKE) -C $(UMP_PATH)/src
-	$(MAKE) -C $(KBASE_PATH)/src
-
-clean:
-	$(MAKE) -C $(KDS_PATH) clean
-	$(MAKE) -C $(UMP_PATH)/src clean
-	$(MAKE) -C $(KBASE_PATH)/src clean
diff --git a/drivers/gpu/arm/t6xx/kbase/src/Kbuild b/drivers/gpu/arm/t6xx/kbase/src/Kbuild
deleted file mode 100644
index 9d2c1491d1a9..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/Kbuild
+++ /dev/null
@@ -1,298 +0,0 @@
-#
-# (C) COPYRIGHT 2012 ARM Limited. All rights reserved.
-#
-# This program is free software and is provided to you under the terms of the
-# GNU General Public License version 2 as published by the Free Software
-# Foundation, and any use by you of this program is subject to the terms
-# of such GNU licence.
-#
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
-#
-#
-
-
-
-# Driver version string which is returned to userspace via an ioctl
-MALI_RELEASE_NAME ?= "r4p0-01alp0"
-
-# Paths required for build
-KBASE_PATH = $(src)/../..
-KBASE_SRC_PATH = $(src)/..
-KBASE_PLATFORM_PATH = $(KBASE_SRC_PATH)/platform_dummy
-UMP_PATH = $(src)/../../../../../base
-
-ifeq ($(CONFIG_MALI_ERROR_INJECTION),y)
-MALI_ERROR_INJECT_ON = 1
-endif
-
-# Set up defaults if not defined by build system
-MALI_CUSTOMER_RELEASE ?= 1
-MALI_UNIT_TEST ?= 0
-MALI_KERNEL_TEST_API ?= 0
-MALI_ERROR_INJECT_ON ?= 0
-MALI_MOCK_TEST ?= 0
-MALI_COVERAGE ?= 0
-MALI_INSTRUMENTATION_LEVEL ?= 0
-# This workaround is for what seems to be a compiler bug we observed in
-# GCC 4.7 on AOSP 4.3.  The bug caused an intermittent failure compiling
-# the "_Pragma" syntax, where an error message is returned:
-#
-# "internal compiler error: unspellable token PRAGMA"
-#
-# This regression has thus far only been seen on the GCC 4.7 compiler bundled
-# with AOSP 4.3.0.  So this makefile, intended for in-tree kernel builds
-# which are not known to be used with AOSP, is hardcoded to disable the
-# workaround, i.e. set the define to 0.
-MALI_GCC_WORKAROUND_MIDCOM_4598 ?= 0
-
-# Set up our defines, which will be passed to gcc
-DEFINES = \
-	-DMALI_CUSTOMER_RELEASE=$(MALI_CUSTOMER_RELEASE) \
-	-DMALI_KERNEL_TEST_API=$(MALI_KERNEL_TEST_API) \
-	-DMALI_UNIT_TEST=$(MALI_UNIT_TEST) \
-	-DMALI_ERROR_INJECT_ON=$(MALI_ERROR_INJECT_ON) \
-	-DMALI_MOCK_TEST=$(MALI_MOCK_TEST) \
-	-DMALI_COVERAGE=$(MALI_COVERAGE) \
-	-DMALI_INSTRUMENTATION_LEVEL=$(MALI_INSTRUMENTATION_LEVEL) \
-	-DMALI_RELEASE_NAME=\"$(MALI_RELEASE_NAME)\" \
-	-DMALI_GCC_WORKAROUND_MIDCOM_4598=$(MALI_GCC_WORKAROUND_MIDCOM_4598)
-
-ifeq ($(CONFIG_MALI_PLATFORM_FAKE),m)
-	DEFINES += -DMALI_PLATFORM_FAKE_MODULE=1
-endif
-
-ifeq ($(KBUILD_EXTMOD),)
-# in-tree
-DEFINES +=-DMALI_KBASE_THIRDPARTY_PATH=../../$(src)/platform/$(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME)
-else
-# out-of-tree
-DEFINES +=-DMALI_KBASE_THIRDPARTY_PATH=$(src)/platform/$(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME)
-endif
-
-# Use our defines when compiling
-ccflags-y += $(DEFINES) -I$(KBASE_PATH) -I$(src)/linux -I$(KBASE_SRC_PATH) -I$(KBASE_PLATFORM_PATH) -I$(UMP_PATH) -I$(srctree)/drivers/staging/android
-subdir-ccflags-y += $(DEFINES) -I$(KBASE_PATH) -I$(src)/linux -I$(KBASE_SRC_PATH) -I$(KBASE_PLATFORM_PATH) -I$(OSK_PATH) -I$(UMP_PATH)
-
-SRC := \
-	common/mali_kbase_device.c \
-	common/mali_kbase_cache_policy.c \
-	common/mali_kbase_mem.c \
-	common/mali_kbase_mmu.c \
-	common/mali_kbase_jd.c \
-	common/mali_kbase_jm.c \
-	common/mali_kbase_cpuprops.c \
-	common/mali_kbase_gpuprops.c \
-	common/mali_kbase_js.c \
-	common/mali_kbase_js_affinity.c \
-	common/mali_kbase_js_ctx_attr.c \
-	common/mali_kbase_event.c \
-	common/mali_kbase_context.c \
-	common/mali_kbase_pm.c \
-	common/mali_kbase_pm_driver.c \
-	common/mali_kbase_pm_metrics.c \
-	common/mali_kbase_pm_ca.c \
-	common/mali_kbase_pm_ca_fixed.c \
-	common/mali_kbase_pm_always_on.c \
-	common/mali_kbase_pm_coarse_demand.c \
-	common/mali_kbase_pm_demand.c \
-	common/mali_kbase_pm_policy.c \
-	common/mali_kbase_config.c \
-	common/mali_kbase_security.c \
-	common/mali_kbase_instr.c \
-	common/mali_kbase_softjobs.c \
-	common/mali_kbase_10969_workaround.c \
-	common/mali_kbase_hw.c \
-	common/mali_kbase_utility.c \
-	common/mali_kbase_mem_lowlevel.c \
-	common/mali_kbase_debug.c \
-	common/mali_kbase_trace_timeline.c \
-	linux/mali_kbase_gpu_memory_debugfs.c \
-	linux/mali_kbase_mem_linux.c \
-	linux/mali_kbase_core_linux.c \
-	linux/mali_kbase_sync.c \
-	linux/mali_kbase_sync_user.c \
-
-ifeq ($(CONFIG_MALI_DEBUG),y)
-SRC += \
-	integration_kit/sim1_t760_run.c\
-	integration_kit/sim2_t760_run.c\
-	integration_kit/sim3_t760_run.c\
-	integration_kit/sim3_t760_mem_0.c\
-	integration_kit/sim3_t760_check_0_a.c\
-	integration_kit/sim4_t760_run.c\
-	integration_kit/MaliFns-t760.c\
-	integration_kit/MaliFns-t760perf.c\
-	integration_kit/MaliFns-generic.c
-endif
-	
-ifeq ($(MALI_CUSTOMER_RELEASE),0)
-SRC += \
-     common/mali_kbase_pm_ca_random.c \
-     common/mali_kbase_pm_demand_always_powered.c \
-     common/mali_kbase_pm_fast_start.c
-endif
-
-# Job Scheduler Policy: Completely Fair Scheduler
-SRC += common/mali_kbase_js_policy_cfs.c
-
-ifeq ($(CONFIG_MACH_MANTA),y)
-	SRC += common/mali_kbase_mem_alloc_carveout.c
-else
-	SRC += common/mali_kbase_mem_alloc.c
-endif
-
-# ensure GPL version of malisw gets pulled in
-ccflags-y += -I$(KBASE_PATH)
-
-ifeq ($(CONFIG_MALI_NO_MALI),y)
-	# Dummy model
-	SRC += common/mali_kbase_model_dummy.c
-	SRC += linux/mali_kbase_model_linux.c
-	# HW error simulation
-	SRC += common/mali_kbase_model_error_generator.c
-endif
-
-ifeq ($(MALI_MOCK_TEST),1)
-	# Test functionality
-	SRC += ../tests/internal/src/mock/mali_kbase_pm_driver_mock.c
-endif
-
-# in-tree/out-of-tree logic needs to be slightly different to determine if a file is present
-ifeq ($(KBUILD_EXTMOD),)
-# in-tree
-MALI_METRICS_PATH = $(srctree)/drivers/gpu/arm/t6xx/kbase/src/linux
-else
-# out-of-tree
-MALI_METRICS_PATH = $(KBUILD_EXTMOD)/linux
-endif
-
-# Use vsync metrics example using PL111 driver, if available
-ifeq ($(wildcard $(MALI_METRICS_PATH)/mali_kbase_pm_metrics_linux.c),)
-	SRC += common/mali_kbase_pm_metrics_dummy.c
-else
-	SRC += linux/mali_kbase_pm_metrics_linux.c
-endif
-
-ifeq ($(CONFIG_MALI_PLATFORM_FAKE),y)
-	SRC += linux/mali_kbase_platform_fake.c
-
-	ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS),y)
-		SRC += platform/vexpress/mali_kbase_config_vexpress.c \
-		platform/vexpress/mali_kbase_cpu_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_RTSM_VE_AEMV8A),y)
-		SRC += platform/rtsm_ve_aemv8a/mali_kbase_config_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_JUNO),y)
-		SRC += platform/juno/mali_kbase_config_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS_VIRTEX7_40MHZ),y)
-		SRC += platform/vexpress_virtex7_40mhz/mali_kbase_config_vexpress.c \
-		platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS_6XVIRTEX7_10MHZ),y)
-		SRC += platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c \
-		platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_GOLDFISH),y)
-		SRC += platform/goldfish/mali_kbase_config_goldfish.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_PBX),y)
-		SRC += platform/pbx/mali_kbase_config_pbx.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_PANDA),y)
-		SRC += platform/panda/mali_kbase_config_panda.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_THIRDPARTY),y)
-	ifeq ($(CONFIG_MALI_T6XX),m)
-	# remove begin and end quotes from the Kconfig string type
-	platform_name := $(shell echo $(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME))
-	MALI_PLATFORM_THIRDPARTY_DIR := platform/$(platform_name)
-	include  $(src)/platform/$(platform_name)/Kbuild
-	else ifeq ($(CONFIG_MALI_T6XX),y)
-	obj-$(CONFIG_MALI_T6XX) += platform/
-	endif
-	endif
-endif # CONFIG_MALI_PLATFORM_FAKE=y
-
-ifeq ($(CONFIG_MALI_PLATFORM_FAKE),m)
-	PSRC := linux/mali_kbase_platform_fake.c
-
-	ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS),y)
-		PSRC += platform/vexpress/mali_kbase_config_vexpress.c \
-		platform/vexpress/mali_kbase_cpu_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_RTSM_VE_AEMV8A),y)
-		PSRC += platform/rtsm_ve_aemv8a/mali_kbase_config_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_JUNO),y)
-		PSRC += platform/juno/mali_kbase_config_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS_VIRTEX7_40MHZ),y)
-		PSRC += platform/vexpress_virtex7_40mhz/mali_kbase_config_vexpress.c \
-		platform/vexpress_virtex7_40mhz/mali_kbase_cpu_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_VEXPRESS_6XVIRTEX7_10MHZ),y)
-		PSRC += platform/vexpress_6xvirtex7_10mhz/mali_kbase_config_vexpress.c \
-		platform/vexpress_6xvirtex7_10mhz/mali_kbase_cpu_vexpress.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_GOLDFISH),y)
-		PSRC += platform/goldfish/mali_kbase_config_goldfish.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_PBX),y)
-		PSRC += platform/pbx/mali_kbase_config_pbx.c
-	endif
-
-	ifeq ($(CONFIG_MALI_PLATFORM_PANDA),y)
-		PSRC += platform/panda/mali_kbase_config_panda.c
-	endif
-	
-	ifeq ($(CONFIG_MALI_PLATFORM_THIRDPARTY),y)
-	ifeq ($(CONFIG_MALI_T6XX),m)
-	# remove begin and end quotes from the Kconfig string type
-	platform_name := $(shell echo $(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME))
-	MALI_PLATFORM_THIRDPARTY_DIR := platform/$(platform_name)
-	include  $(src)/platform/$(platform_name)/Kbuild
-	else ifeq ($(CONFIG_MALI_T6XX),y)
-	obj-$(CONFIG_MALI_T6XX) += platform/
-	endif
-	endif
-
-	obj-m := mali_platform_fake.o
-	mali_platform_fake-y := $(PSRC:.c=.o)
-endif
-
-ifeq ($(CONFIG_MALI_PLATFORM_THIRDPARTY),y)
-ifeq ($(CONFIG_MALI_T6XX),m)
-# remove begin and end quotes from the Kconfig string type
-platform_name := $(shell echo $(CONFIG_MALI_PLATFORM_THIRDPARTY_NAME))
-MALI_PLATFORM_THIRDPARTY_DIR := platform/$(platform_name)
-include  $(src)/platform/$(platform_name)/Kbuild
-else ifeq ($(CONFIG_MALI_T6XX),y)
-obj-$(CONFIG_MALI_T6XX) += platform/
-endif
-endif
-
-# Tell the Linux build system from which .o file to create the kernel module
-obj-$(CONFIG_MALI_T6XX) += mali_kbase.o
-
-# Tell the Linux build system to enable building of our .c files
-mali_kbase-y := $(SRC:.c=.o)
-
-
diff --git a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_config.c b/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_config.c
deleted file mode 100644
index 843da827db01..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/common/mali_kbase_config.c
+++ /dev/null
@@ -1,610 +0,0 @@
-/*
- *
- * (C) COPYRIGHT ARM Limited. All rights reserved.
- *
- * This program is free software and is provided to you under the terms of the
- * GNU General Public License version 2 as published by the Free Software
- * Foundation, and any use by you of this program is subject to the terms
- * of such GNU licence.
- *
- * A copy of the licence is included with the program, and can also be obtained
- * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
- *
- */
-
-
-
-
-
-#include <kbase/src/common/mali_kbase.h>
-#include <kbase/src/common/mali_kbase_defs.h>
-#include <kbase/src/common/mali_kbase_cpuprops.h>
-#ifdef CONFIG_UMP
-#include <linux/ump-common.h>
-#endif				/* CONFIG_UMP */
-
-/* Specifies how many attributes are permitted in the config (excluding terminating attribute).
- * This is used in validation function so we can detect if configuration is properly terminated. This value can be
- * changed if we need to introduce more attributes or many memory regions need to be defined */
-#define ATTRIBUTE_COUNT_MAX 32
-
-/* right now we allow only 2 memory attributes (excluding termination attribute) */
-#define MEMORY_ATTRIBUTE_COUNT_MAX 2
-
-/* Limits for gpu frequency configuration parameters. These will use for config validation. */
-#define MAX_GPU_ALLOWED_FREQ_KHZ 1000000
-#define MIN_GPU_ALLOWED_FREQ_KHZ 1
-
-/* Default irq throttle time. This is the default desired minimum time in between two consecutive
- * interrupts from the gpu. The irq throttle gpu register is set after this value. */
-#define DEFAULT_IRQ_THROTTLE_TIME_US 20
-
-/*** Begin Scheduling defaults ***/
-
-/**
- * Default scheduling tick granuality, in nanoseconds
- */
-#define DEFAULT_JS_SCHEDULING_TICK_NS 100000000u  /* 100ms */
-
-/**
- * Default minimum number of scheduling ticks before jobs are soft-stopped.
- *
- * This defines the time-slice for a job (which may be different from that of a context)
- */
-#define DEFAULT_JS_SOFT_STOP_TICKS 1	/* Between 0.1 and 0.2s before soft-stop */
-
-/**
- * Default minimum number of scheduling ticks before jobs are hard-stopped
- */
-#define DEFAULT_JS_HARD_STOP_TICKS_SS_HW_ISSUE_8408 12	/* 1.2s before hard-stop, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) */
-#define DEFAULT_JS_HARD_STOP_TICKS_SS 2	/* Between 0.2 and 0.3s before hard-stop */
-
-/**
- * Default minimum number of scheduling ticks before jobs are hard-stopped
- * during dumping
- */
-#define DEFAULT_JS_HARD_STOP_TICKS_NSS 600	/* 60s @ 100ms tick */
-
-/**
- * Default minimum number of scheduling ticks before the GPU is reset
- * to clear a "stuck" job
- */
-#define DEFAULT_JS_RESET_TICKS_SS_HW_ISSUE_8408 18	/* 1.8s before resetting GPU, for a certain GLES2 test at 128x128 (bound by combined vertex+tiler job) */
-#define DEFAULT_JS_RESET_TICKS_SS 3	/* 0.3-0.4s before GPU is reset */
-
-/**
- * Default minimum number of scheduling ticks before the GPU is reset
- * to clear a "stuck" job during dumping.
- */
-#define DEFAULT_JS_RESET_TICKS_NSS 601	/* 60.1s @ 100ms tick */
-
-/**
- * Number of milliseconds given for other jobs on the GPU to be
- * soft-stopped when the GPU needs to be reset.
- */
-#define DEFAULT_JS_RESET_TIMEOUT_MS 3000
-
-/**
- * Default timeslice that a context is scheduled in for, in nanoseconds.
- *
- * When a context has used up this amount of time across its jobs, it is
- * scheduled out to let another run.
- *
- * @note the resolution is nanoseconds (ns) here, because that's the format
- * often used by the OS.
- */
-#define DEFAULT_JS_CTX_TIMESLICE_NS 50000000	/* 0.05s - at 20fps a ctx does at least 1 frame before being scheduled out. At 40fps, 2 frames, etc */
-
-/**
- * Default initial runtime of a context for CFS, in ticks.
- *
- * This value is relative to that of the least-run context, and defines where
- * in the CFS queue a new context is added.
- */
-#define DEFAULT_JS_CFS_CTX_RUNTIME_INIT_SLICES 1
-
-/**
- * Default minimum runtime value of a context for CFS, in ticks.
- *
- * This value is relative to that of the least-run context. This prevents
- * "stored-up timeslices" DoS attacks.
- */
-#define DEFAULT_JS_CFS_CTX_RUNTIME_MIN_SLICES 2
-
-/**
- * Default setting for whether to prefer security or performance.
- *
- * Currently affects only r0p0-15dev0 HW and earlier.
- */
-#define DEFAULT_SECURE_BUT_LOSS_OF_PERFORMANCE MALI_FALSE
-
-/**
- * Default setting for read Address ID limiting on AXI.
- */
-#define DEFAULT_ARID_LIMIT KBASE_AID_32
-
-/**
- * Default setting for write Address ID limiting on AXI.
- */
-#define DEFAULT_AWID_LIMIT KBASE_AID_32
-
-/**
- * Default setting for using alternative hardware counters.
- */
-#define DEFAULT_ALTERNATIVE_HWC MALI_FALSE
-
-/*** End Scheduling defaults ***/
-
-/*** Begin Power Manager defaults */
-
-#define DEFAULT_PM_DVFS_FREQ 100 /* Milliseconds */
-
-/**
- * Default poweroff tick granuality, in nanoseconds
- */
-#define DEFAULT_PM_GPU_POWEROFF_TICK_NS 400000 /* 400us */
-
-/**
- * Default number of poweroff ticks before shader cores are powered off
- */
-#define DEFAULT_PM_POWEROFF_TICK_SHADER 2      /* 400-800us */
-
-/**
- * Default number of poweroff ticks before GPU is powered off
- */
-#define DEFAULT_PM_POWEROFF_TICK_GPU 2         /* 400-800us */
-
-/*** End Power Manager defaults ***/
-
-/**
- * Default value for KBASE_CONFIG_ATTR_CPU_SPEED_FUNC.
- * Points to @ref kbase_cpuprops_get_default_clock_speed.
- */
-#define DEFAULT_CPU_SPEED_FUNC ((uintptr_t)kbase_cpuprops_get_default_clock_speed)
-
-int kbasep_get_config_attribute_count(const kbase_attribute *attributes)
-{
-	int count = 1;
-
-	if (!attributes)
-		return -EINVAL;
-
-	while (attributes->id != KBASE_CONFIG_ATTR_END) {
-		attributes++;
-		count++;
-	}
-
-	return count;
-}
-
-const kbase_attribute *kbasep_get_next_attribute(const kbase_attribute *attributes, int attribute_id)
-{
-	KBASE_DEBUG_ASSERT(attributes != NULL);
-
-	while (attributes->id != KBASE_CONFIG_ATTR_END) {
-		if (attributes->id == attribute_id)
-			return attributes;
-
-		attributes++;
-	}
-	return NULL;
-}
-
-KBASE_EXPORT_TEST_API(kbasep_get_next_attribute)
-
-uintptr_t kbasep_get_config_value(struct kbase_device *kbdev, const kbase_attribute *attributes, int attribute_id)
-{
-	const kbase_attribute *attr;
-
-	KBASE_DEBUG_ASSERT(attributes != NULL);
-
-	attr = kbasep_get_next_attribute(attributes, attribute_id);
-	if (attr != NULL)
-		return attr->data;
-
-	/* default values */
-	switch (attribute_id) {
-	case KBASE_CONFIG_ATTR_MEMORY_PER_PROCESS_LIMIT:
-		return (uintptr_t) -1;
-#ifdef CONFIG_UMP
-	case KBASE_CONFIG_ATTR_UMP_DEVICE:
-		return UMP_DEVICE_W_SHIFT;
-#endif				/* CONFIG_UMP */
-	case KBASE_CONFIG_ATTR_MEMORY_OS_SHARED_MAX:
-		return (uintptr_t) -1;
-	case KBASE_CONFIG_ATTR_MEMORY_OS_SHARED_PERF_GPU:
-		return KBASE_MEM_PERF_NORMAL;
-	case KBASE_CONFIG_ATTR_GPU_IRQ_THROTTLE_TIME_US:
-		return DEFAULT_IRQ_THROTTLE_TIME_US;
-		/* Begin scheduling defaults */
-	case KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS:
-		return DEFAULT_JS_SCHEDULING_TICK_NS;
-	case KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS:
-		return DEFAULT_JS_SOFT_STOP_TICKS;
-	case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS:
-		if (kbase_hw_has_issue(kbdev, BASE_HW_ISSUE_8408))
-			return DEFAULT_JS_HARD_STOP_TICKS_SS_HW_ISSUE_8408;
-		else
-			return DEFAULT_JS_HARD_STOP_TICKS_SS;
-	case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS:
-		return DEFAULT_JS_HARD_STOP_TICKS_NSS;
-	case KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS:
-		return DEFAULT_JS_CTX_TIMESLICE_NS;
-	case KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_INIT_SLICES:
-		return DEFAULT_JS_CFS_CTX_RUNTIME_INIT_SLICES;
-	case KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_MIN_SLICES:
-		return DEFAULT_JS_CFS_CTX_RUNTIME_MIN_SLICES;
-	case KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS:
-		if (kbase_hw_has_issue(kbdev, BASE_HW_ISSUE_8408))
-			return DEFAULT_JS_RESET_TICKS_SS_HW_ISSUE_8408;
-		else
-			return DEFAULT_JS_RESET_TICKS_SS;
-	case KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS:
-		return DEFAULT_JS_RESET_TICKS_NSS;
-	case KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS:
-		return DEFAULT_JS_RESET_TIMEOUT_MS;
-		/* End scheduling defaults */
-	case KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS:
-		return 0;
-	case KBASE_CONFIG_ATTR_PLATFORM_FUNCS:
-		return 0;
-	case KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE:
-		return DEFAULT_SECURE_BUT_LOSS_OF_PERFORMANCE;
-	case KBASE_CONFIG_ATTR_CPU_SPEED_FUNC:
-		return DEFAULT_CPU_SPEED_FUNC;
-	case KBASE_CONFIG_ATTR_GPU_SPEED_FUNC:
-		return 0;
-	case KBASE_CONFIG_ATTR_ARID_LIMIT:
-		return DEFAULT_ARID_LIMIT;
-	case KBASE_CONFIG_ATTR_AWID_LIMIT:
-		return DEFAULT_AWID_LIMIT;
-	case KBASE_CONFIG_ATTR_ALTERNATIVE_HWC:
-		return DEFAULT_ALTERNATIVE_HWC;
-	case KBASE_CONFIG_ATTR_POWER_MANAGEMENT_DVFS_FREQ:
-		return DEFAULT_PM_DVFS_FREQ;
-	case KBASE_CONFIG_ATTR_PM_GPU_POWEROFF_TICK_NS:
-		return DEFAULT_PM_GPU_POWEROFF_TICK_NS;
-	case KBASE_CONFIG_ATTR_PM_POWEROFF_TICK_SHADER:
-		return DEFAULT_PM_POWEROFF_TICK_SHADER;
-	case KBASE_CONFIG_ATTR_PM_POWEROFF_TICK_GPU:
-		return DEFAULT_PM_POWEROFF_TICK_GPU;
-
-	default:
-		KBASE_DEBUG_PRINT_ERROR(KBASE_CORE, "kbasep_get_config_value. Cannot get value of attribute with id=%d and no default value defined", attribute_id);
-		return 0;
-	}
-}
-
-KBASE_EXPORT_TEST_API(kbasep_get_config_value)
-
-mali_bool kbasep_platform_device_init(kbase_device *kbdev)
-{
-	kbase_platform_funcs_conf *platform_funcs;
-
-	platform_funcs = (kbase_platform_funcs_conf *) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_PLATFORM_FUNCS);
-	if (platform_funcs) {
-		if (platform_funcs->platform_init_func)
-			return platform_funcs->platform_init_func(kbdev);
-	}
-	return MALI_TRUE;
-}
-
-void kbasep_platform_device_term(kbase_device *kbdev)
-{
-	kbase_platform_funcs_conf *platform_funcs;
-
-	platform_funcs = (kbase_platform_funcs_conf *) kbasep_get_config_value(kbdev, kbdev->config_attributes, KBASE_CONFIG_ATTR_PLATFORM_FUNCS);
-	if (platform_funcs) {
-		if (platform_funcs->platform_term_func)
-			platform_funcs->platform_term_func(kbdev);
-	}
-}
-
-#ifdef CONFIG_UMP
-static mali_bool kbasep_validate_ump_device(int ump_device)
-{
-	mali_bool valid;
-
-	switch (ump_device) {
-	case UMP_DEVICE_W_SHIFT:
-	case UMP_DEVICE_X_SHIFT:
-	case UMP_DEVICE_Y_SHIFT:
-	case UMP_DEVICE_Z_SHIFT:
-		valid = MALI_TRUE;
-		break;
-	default:
-		valid = MALI_FALSE;
-		break;
-	}
-	return valid;
-}
-#endif				/* CONFIG_UMP */
-
-static mali_bool kbasep_validate_memory_performance(kbase_memory_performance performance)
-{
-	return performance <= KBASE_MEM_PERF_MAX_VALUE;
-}
-
-static mali_bool kbasep_validate_memory_resource(const kbase_memory_resource *memory_resource)
-{
-	KBASE_DEBUG_ASSERT(memory_resource != NULL);
-
-	if (memory_resource->name == NULL) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Unnamed memory region found");
-		return MALI_FALSE;
-	}
-
-	if (memory_resource->base & ((1 << PAGE_SHIFT) - 1)) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Base address of \"%s\" memory region is not page aligned", memory_resource->name);
-		return MALI_FALSE;
-	}
-
-	if (memory_resource->size & ((1 << PAGE_SHIFT) - 1)) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Size of \"%s\" memory region is not a multiple of page size", memory_resource->name);
-		return MALI_FALSE;
-	}
-
-	if (memory_resource->attributes != NULL) {	/* we allow NULL attribute list */
-		int i;
-
-		for (i = 0; memory_resource->attributes[i].id != KBASE_MEM_ATTR_END; i++) {
-			if (i >= MEMORY_ATTRIBUTE_COUNT_MAX) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "More than MEMORY_ATTRIBUTE_COUNT_MAX=%d configuration attributes defined. Is memory attribute list properly terminated?", MEMORY_ATTRIBUTE_COUNT_MAX);
-				return MALI_FALSE;
-			}
-			switch (memory_resource->attributes[i].id) {
-			case KBASE_MEM_ATTR_PERF_CPU:
-				if (MALI_TRUE != kbasep_validate_memory_performance((kbase_memory_performance) memory_resource->attributes[i].data)) {
-					KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "CPU performance of \"%s\" region is invalid: %d", memory_resource->name, (kbase_memory_performance) memory_resource->attributes[i].data);
-					return MALI_FALSE;
-				}
-				break;
-
-			case KBASE_MEM_ATTR_PERF_GPU:
-				if (MALI_TRUE != kbasep_validate_memory_performance((kbase_memory_performance) memory_resource->attributes[i].data)) {
-					KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "GPU performance of \"%s\" region is invalid: %d", memory_resource->name, (kbase_memory_performance) memory_resource->attributes[i].data);
-					return MALI_FALSE;
-				}
-				break;
-			default:
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid memory attribute found in \"%s\" memory region: %d", memory_resource->name, memory_resource->attributes[i].id);
-				return MALI_FALSE;
-			}
-		}
-	}
-
-	return MALI_TRUE;
-}
-
-static mali_bool kbasep_validate_gpu_clock_freq(kbase_device *kbdev, const kbase_attribute *attributes)
-{
-	uintptr_t freq_min = kbasep_get_config_value(kbdev, attributes, KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN);
-	uintptr_t freq_max = kbasep_get_config_value(kbdev, attributes, KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX);
-
-	if ((freq_min > MAX_GPU_ALLOWED_FREQ_KHZ) || (freq_min < MIN_GPU_ALLOWED_FREQ_KHZ) || (freq_max > MAX_GPU_ALLOWED_FREQ_KHZ) || (freq_max < MIN_GPU_ALLOWED_FREQ_KHZ) || (freq_min > freq_max)) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid GPU frequencies found in configuration: min=%ldkHz, max=%ldkHz.", freq_min, freq_max);
-		return MALI_FALSE;
-	}
-
-	return MALI_TRUE;
-}
-
-static mali_bool kbasep_validate_pm_callback(const kbase_pm_callback_conf *callbacks)
-{
-	if (callbacks == NULL) {
-		/* Having no callbacks is valid */
-		return MALI_TRUE;
-	}
-
-	if ((callbacks->power_off_callback != NULL && callbacks->power_on_callback == NULL) || (callbacks->power_off_callback == NULL && callbacks->power_on_callback != NULL)) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid power management callbacks: Only one of power_off_callback and power_on_callback was specified");
-		return MALI_FALSE;
-	}
-	return MALI_TRUE;
-}
-
-static mali_bool kbasep_validate_cpu_speed_func(kbase_cpuprops_clock_speed_function fcn)
-{
-	return fcn != NULL;
-}
-
-mali_bool kbasep_validate_configuration_attributes(kbase_device *kbdev, const kbase_attribute *attributes)
-{
-	int i;
-	mali_bool had_gpu_freq_min = MALI_FALSE, had_gpu_freq_max = MALI_FALSE;
-
-	KBASE_DEBUG_ASSERT(attributes);
-
-	for (i = 0; attributes[i].id != KBASE_CONFIG_ATTR_END; i++) {
-		if (i >= ATTRIBUTE_COUNT_MAX) {
-			KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "More than ATTRIBUTE_COUNT_MAX=%d configuration attributes defined. Is attribute list properly terminated?", ATTRIBUTE_COUNT_MAX);
-			return MALI_FALSE;
-		}
-
-		switch (attributes[i].id) {
-		case KBASE_CONFIG_ATTR_MEMORY_RESOURCE:
-			if (MALI_FALSE == kbasep_validate_memory_resource((kbase_memory_resource *) attributes[i].data)) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid memory region found in configuration");
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_MEMORY_OS_SHARED_MAX:
-			/* Some shared memory is required for GPU page tables, see MIDBASE-1534 */
-			if (0 == attributes[i].data) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Maximum OS Shared Memory Maximum is set to 0 which is not supported");
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_MEMORY_OS_SHARED_PERF_GPU:
-			if (MALI_FALSE == kbasep_validate_memory_performance((kbase_memory_performance) attributes[i].data)) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Shared OS memory GPU performance attribute has invalid value: %d", (kbase_memory_performance) attributes[i].data);
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_MEMORY_PER_PROCESS_LIMIT:
-			/* any value is allowed */
-			break;
-#ifdef CONFIG_UMP
-		case KBASE_CONFIG_ATTR_UMP_DEVICE:
-			if (MALI_FALSE == kbasep_validate_ump_device(attributes[i].data)) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Unknown UMP device found in configuration: %d", (int)attributes[i].data);
-				return MALI_FALSE;
-			}
-			break;
-#endif				/* CONFIG_UMP */
-
-		case KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN:
-			had_gpu_freq_min = MALI_TRUE;
-			if (MALI_FALSE == kbasep_validate_gpu_clock_freq(kbdev, attributes)) {
-				/* Warning message handled by kbasep_validate_gpu_clock_freq() */
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX:
-			had_gpu_freq_max = MALI_TRUE;
-			if (MALI_FALSE == kbasep_validate_gpu_clock_freq(kbdev, attributes)) {
-				/* Warning message handled by kbasep_validate_gpu_clock_freq() */
-				return MALI_FALSE;
-			}
-			break;
-
-			/* Only non-zero unsigned 32-bit values accepted */
-		case KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS:
-#if CSTD_CPU_64BIT
-			if (attributes[i].data == 0u || (u64) attributes[i].data > (u64) U32_MAX)
-#else
-			if (attributes[i].data == 0u)
-#endif
-			{
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid Job Scheduling Configuration attribute for " "KBASE_CONFIG_ATTR_JS_SCHEDULING_TICKS_NS: %d", (int)attributes[i].data);
-				return MALI_FALSE;
-			}
-			break;
-
-			/* All these Job Scheduling attributes are FALLTHROUGH: only unsigned 32-bit values accepted */
-		case KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS:
-		case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS:
-		case KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS:
-		case KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS:
-		case KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS:
-		case KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS:
-		case KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS:
-		case KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_INIT_SLICES:
-		case KBASE_CONFIG_ATTR_JS_CFS_CTX_RUNTIME_MIN_SLICES:
-#if CSTD_CPU_64BIT
-			if ((u64) attributes[i].data > (u64) U32_MAX) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Job Scheduling Configuration attribute exceeds 32-bits: " "id==%d val==%d", attributes[i].id, (int)attributes[i].data);
-				return MALI_FALSE;
-			}
-#endif
-			break;
-
-		case KBASE_CONFIG_ATTR_GPU_IRQ_THROTTLE_TIME_US:
-#if CSTD_CPU_64BIT
-			if ((u64) attributes[i].data > (u64) U32_MAX) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "IRQ throttle time attribute exceeds 32-bits: " "id==%d val==%d", attributes[i].id, (int)attributes[i].data);
-				return MALI_FALSE;
-			}
-#endif
-			break;
-
-		case KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS:
-			if (MALI_FALSE == kbasep_validate_pm_callback((kbase_pm_callback_conf *) attributes[i].data)) {
-				/* Warning message handled by kbasep_validate_pm_callback() */
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE:
-			if (attributes[i].data != MALI_TRUE && attributes[i].data != MALI_FALSE) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Value for KBASE_CONFIG_ATTR_SECURE_BUT_LOSS_OF_PERFORMANCE was not " "MALI_TRUE or MALI_FALSE: %u", (unsigned int)attributes[i].data);
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_CPU_SPEED_FUNC:
-			if (MALI_FALSE == kbasep_validate_cpu_speed_func((kbase_cpuprops_clock_speed_function) attributes[i].data)) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid function pointer in KBASE_CONFIG_ATTR_CPU_SPEED_FUNC");
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_GPU_SPEED_FUNC:
-			if (0 == attributes[i].data) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid function pointer in KBASE_CONFIG_ATTR_GPU_SPEED_FUNC");
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_PLATFORM_FUNCS:
-			/* any value is allowed */
-			break;
-
-		case KBASE_CONFIG_ATTR_AWID_LIMIT:
-		case KBASE_CONFIG_ATTR_ARID_LIMIT:
-			if ((u32) attributes[i].data > 0x3) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid AWID or ARID limit");
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_ALTERNATIVE_HWC:
-			if (attributes[i].data != MALI_TRUE && attributes[i].data != MALI_FALSE) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Value for KBASE_CONFIG_ATTR_ALTERNATIVE_HWC was not " "MALI_TRUE or MALI_FALSE: %u", (unsigned int)attributes[i].data);
-				return MALI_FALSE;
-			}
-			break;
-
-		case KBASE_CONFIG_ATTR_POWER_MANAGEMENT_DVFS_FREQ:
-#if CSTD_CPU_64BIT
-			if ((u64) attributes[i].data > (u64) U32_MAX) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "PM DVFS interval exceeds 32-bits: " "id==%d val==%d", attributes[i].id, (int)attributes[i].data);
-				return MALI_FALSE;
-			}
-#endif
-			break;
-
-		case KBASE_CONFIG_ATTR_PM_GPU_POWEROFF_TICK_NS:
-#if CSTD_CPU_64BIT
-			if (attributes[i].data == 0u || (u64) attributes[i].data > (u64) U32_MAX) {
-#else
-			if (attributes[i].data == 0u) {
-#endif
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid Power Manager Configuration attribute for " "KBASE_CONFIG_ATTR_PM_GPU_POWEROFF_TICK_NS: %d", (int)attributes[i].data);
-				return MALI_FALSE;
-			}
-			break;
-
-	case KBASE_CONFIG_ATTR_PM_POWEROFF_TICK_SHADER:
-	case KBASE_CONFIG_ATTR_PM_POWEROFF_TICK_GPU:
-#if CSTD_CPU_64BIT
-			if ((u64) attributes[i].data > (u64) U32_MAX) {
-				KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Power Manager Configuration attribute exceeds 32-bits: " "id==%d val==%d", attributes[i].id, (int)attributes[i].data);
-				return MALI_FALSE;
-			}
-#endif
-			break;
-
-		default:
-			KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Invalid attribute found in configuration: %d", attributes[i].id);
-			return MALI_FALSE;
-		}
-	}
-
-	if (!had_gpu_freq_min) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Configuration does not include mandatory attribute KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MIN");
-		return MALI_FALSE;
-	}
-
-	if (!had_gpu_freq_max) {
-		KBASE_DEBUG_PRINT_WARN(KBASE_CORE, "Configuration does not include mandatory attribute KBASE_CONFIG_ATTR_GPU_FREQ_KHZ_MAX");
-		return MALI_FALSE;
-	}
-
-	return MALI_TRUE;
-}
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliDefines-t760.h b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliDefines-t760.h
deleted file mode 100644
index d7a634a55412..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliDefines-t760.h
+++ /dev/null
@@ -1,1977 +0,0 @@
-
- //chenli add 
-#include <linux/kernel.h>
-#define exit(no)
-int Mali_RdReg(int unit,int core, int regnum);
-void Mali_WrReg(int unit,int core,int regnum,int value);
-int Mali_AnyInterruptCheck(int type, int i_mask, int i_value);
-void Mali_clear_irqs_and_set_all_masks (void);
-void Mali_clear_and_set_masks_for_gpu_irq (void);
-void Mali_clear_and_set_masks_for_mmu_irq (void);
-void Mali_clear_and_set_masks_for_job_irq (void);
-void Mali_SetBase(int* base);
-void Mali_Reset(void) ;
-void *Mali_LdMem(void *srcptr,int size,int ttb_base);
-void Mali_InitPerfCountersFn(int core, int cnt_num, int cnt_id);
-void Mali_InitPerfCounters();
-void Mali_InitPerfCountersFn(int core, int cnt_num, int cnt_id);
-void Mali_ReadPerfCounters();
-int Mali_InterruptCheck(int i_mask, int i_value);
-void Mali_CheckReg(int unit,int core, int regnum, int value);
-
-
-//end
-
-/**********************************************
- GPU ID 
- **********************************************/
-
-
-#ifdef GPU_ID_VALUE
-#else
-  #define GPU_ID_VALUE 0x69560002
-#endif
-
-/**********************************************
- GPU CONFIG 
- **********************************************/
-#ifdef GPU_CONFIG_N_CONTROL_BASE
-#else
-  #define GPU_CONFIG_N_CONTROL_BASE 0x0000
-#endif
-
-#ifdef JOB_CONTROL_BASE
-#else
-  #define JOB_CONTROL_BASE 0x1000
-#endif
-
-#ifdef MEM_MANAGEMENT_BASE
-#else
-  #define MEM_MANAGEMENT_BASE 0x2000
-#endif
-
-
-
-
-#ifdef GPU_IRQ_RAWSTAT
-#else
-  #define GPU_IRQ_RAWSTAT     0x0020
-#endif
-
-#ifdef GPU_IRQ_CLEAR
-#else
-  #define GPU_IRQ_CLEAR       0x0024
-#endif
-
-#ifdef GPU_IRQ_MASK 
-#else
-  #define GPU_IRQ_MASK        0x0028
-#endif
-
-#ifdef GPU_IRQ_STATUS
-#else
-  #define GPU_IRQ_STATUS      0x002C
-#endif
-
-#ifdef GPU_COMMAND
-#else
-  #define GPU_COMMAND           0x0030
-#endif
-
-#ifdef GPU_STATUS
-#else
-  #define GPU_STATUS            0x0034
-#endif
-
-#ifdef GPU_FAULTSTATUS
-#else
-  #define GPU_FAULTSTATUS       0x003C
-#endif
-
-
-
-#ifdef CYCLE_COUNT_LO
-#else
-  #define CYCLE_COUNT_LO        0x0090
-#endif
-
-#ifdef CYCLE_COUNT_HI
-#else
-  #define CYCLE_COUNT_HI        0x0094
-#endif
-
-#ifdef TIMESTAMP_LO
-#else
-  #define TIMESTAMP_LO          0x0098
-#endif
-
-#ifdef TIMESTAMP_HI
-#else
-  #define TIMESTAMP_HI          0x009c
-#endif
-
-#ifdef L2_MMU_CONFIG
-#else
-  #define L2_MMU_CONFIG      0x0f0c
-#endif
-
-
-#ifdef JOB_IRQ_RAWSTAT
-#else
-  #define JOB_IRQ_RAWSTAT         0x1000
-#endif
-
-#ifdef JOB_IRQ_CLEAR
-#else
-  #define JOB_IRQ_CLEAR           0x1004
-#endif
-
-#ifdef JOB_IRQ_MASK
-#else
-  #define JOB_IRQ_MASK            0x1008
-#endif
-
-#ifdef JOB_IRQ_STATUS
-#else
-  #define JOB_IRQ_STATUS          0x100c
-#endif
-
-#ifdef JOB_IRQ_THROTTLE
-#else
-  #define JOB_IRQ_THROTTLE        0x1014
-#endif
-
-
-
-
-
-#ifdef SHADER_PWRON_LO
-#else
-  #define SHADER_PWRON_LO         0x0180
-#endif
-#ifdef SHADER_PWROFF_LO
-#else
-  #define SHADER_PWROFF_LO        0x01c0
-#endif
-#ifdef SHADER_READY_LO
-#else
-  #define SHADER_READY_LO         0x0140
-#endif
-#ifdef SHADER_PWRTRANS_LO
-#else
-  #define SHADER_PWRTRANS_LO         0x0200
-#endif
-#ifdef SHADER_PWRACTIVE_LO
-#else
-  #define SHADER_PWRACTIVE_LO         0x0240
-#endif
-
-#ifdef SHADER_PWRON_HI
-#else
-  #define SHADER_PWRON_HI         0x0184
-#endif
-
-
-#ifdef TILER_PWRON_LO
-#else
-  #define TILER_PWRON_LO          0x0190
-#endif
-#ifdef TILER_PWROFF_LO
-#else
-  #define TILER_PWROFF_LO         0x01d0
-#endif
-#ifdef TILER_READY_LO
-#else
-  #define TILER_READY_LO          0x0150
-#endif
-#ifdef TILER_PWRTRANS_LO
-#else
-  #define TILER_PWRTRANS_LO         0x0210
-#endif
-#ifdef TILER_PWRACTIVE_LO
-#else
-  #define TILER_PWRACTIVE_LO         0x0250
-#endif
-
-#ifdef TILER_PWRON_HI
-#else
-  #define TILER_PWRON_HI          0x0194
-#endif
-
-#ifdef L2_PWRON_LO
-#else
-  #define L2_PWRON_LO             0x01A0
-#endif
-
-#ifdef L2_PWRON_HI
-#else
-  #define L2_PWRON_HI             0x01A4
-#endif
-
-#ifdef L2_PWROFF_LO
-#else
-  #define L2_PWROFF_LO         0x01e0
-#endif
-
-#ifdef L2_READY_LO
-#else
-  #define L2_READY_LO          0x0160
-#endif
-
-#ifdef L2_PWRTRANS_LO
-#else
-  #define L2_PWRTRANS_LO         0x0220
-#endif
-
-#ifdef L2_PWRACTIVE_LO
-#else
-  #define L2_PWRACTIVE_LO         0x0260
-#endif
-
-
-
-/**********************************************
- JSn
- **********************************************/
-#ifdef JSn_BASE
-#else
-  #define JSn_BASE                0x800
-#endif
-
-#ifdef JSn_CONFIG
-#else
-  #define JSn_CONFIG              0x18
-#endif
-
-#ifdef JSn_HEAD_NEXT_LO
-#else
-  #define JSn_HEAD_NEXT_LO        0x40
-#endif
-
-#ifdef JSn_HEAD_NEXT_HI
-#else
-  #define JSn_HEAD_NEXT_HI        0x44
-#endif
-
-#ifdef JSn_AFFINITY_NEXT_LO
-#else
-  #define JSn_AFFINITY_NEXT_LO    0x50
-#endif
-
-#ifdef JSn_AFFINITY_NEXT_HI
-#else
-  #define JSn_AFFINITY_NEXT_HI    0x54
-#endif
-
-#ifdef JSn_CONFIG_NEXT
-#else
-  #define JSn_CONFIG_NEXT         0x58
-#endif
-
-#ifdef JSn_COMMAND_NEXT
-#else
-  #define JSn_COMMAND_NEXT        0x60
-#endif
-
-#ifdef JSn_STATUS
-#else
-  #define JSn_STATUS              0x24
-#endif
-
-/**********************************************
- JS0 
- **********************************************/
- 
-#ifdef JS0_HEAD_NEXT_LO
-#else
-  #define JS0_HEAD_NEXT_LO        0x1840
-#endif
-
-#ifdef JS0_HEAD_NEXT_HI
-#else
-  #define JS0_HEAD_NEXT_HI        0x1844
-#endif
-
-#ifdef JS0_AFFINITY_NEXT_LO
-#else
-  #define JS0_AFFINITY_NEXT_LO    0x1850
-#endif
-
-#ifdef JS0_AFFINITY_NEXT_HI
-#else
-  #define JS0_AFFINITY_NEXT_HI    0x1850
-#endif
-
-#ifdef JS0_CONFIG_NEXT
-#else
-  #define JS0_CONFIG_NEXT         0x1858
-#endif
-
-#ifdef JS0_COMMAND_NEXT
-#else
-  #define JS0_COMMAND_NEXT        0x1860
-#endif
-
-#ifdef JS0_STATUS
-#else
-  #define JS0_STATUS              0x1824
-#endif
- 
-/**********************************************
- JS1 
- **********************************************/
-#ifdef JS1_HEAD_NEXT_LO
-#else
-  #define JS1_HEAD_NEXT_LO        0x18c0
-#endif
-
-#ifdef JS1_HEAD_NEXT_HI
-#else
-  #define JS1_HEAD_NEXT_HI        0x18c4
-#endif
-
-#ifdef JS1_AFFINITY_NEXT_LO
-#else
-  #define JS1_AFFINITY_NEXT_LO    0x18d0
-#endif
-
-#ifdef JS1_AFFINITY_NEXT_HI
-#else
-  #define JS1_AFFINITY_NEXT_HI    0x18d4
-#endif
-
-#ifdef JS1_CONFIG_NEXT
-#else
-  #define JS1_CONFIG_NEXT         0x18d8
-#endif
-
-#ifdef JS1_COMMAND_NEXT
-#else
-  #define JS1_COMMAND_NEXT        0x18e0
-#endif
-
-/**********************************************
- JS2 
- **********************************************/
-#ifdef JS2_HEAD_NEXT_LO
-#else
-  #define JS2_HEAD_NEXT_LO        0x1940
-#endif
-
-#ifdef JS2_HEAD_NEXT_HI
-#else
-  #define JS2_HEAD_NEXT_HI        0x1944
-#endif
-
-#ifdef JS2_AFFINITY_NEXT_LO
-#else
-  #define JS2_AFFINITY_NEXT_LO    0x1950
-#endif
-
-#ifdef JS2_AFFINITY_NEXT_HI
-#else
-  #define JS2_AFFINITY_NEXT_HI    0x1954
-#endif
-
-#ifdef JS2_CONFIG_NEXT
-#else
-  #define JS2_CONFIG_NEXT         0x1958
-#endif
-
-#ifdef JS2_COMMAND_NEXT
-#else
-  #define JS2_COMMAND_NEXT        0x1960
-#endif
-
-/**********************************************
- MMU 
- **********************************************/
-#ifdef MMU_IRQ_RAWSTAT
-#else
-  #define MMU_IRQ_RAWSTAT            0x2000
-#endif
-
-#ifdef MMU_IRQ_CLEAR
-#else
-  #define MMU_IRQ_CLEAR              0x2004
-#endif
-
-#ifdef MMU_IRQ_MASK
-#else
-  #define MMU_IRQ_MASK               0x2008
-#endif
-
-#ifdef MMU_IRQ_STATUS
-#else
-  #define MMU_IRQ_STATUS             0x200c
-#endif
-
-#ifdef MMU_IRQ_STATUS
-#else
-  #define MMU_IRQ_STATUS             0x200c
-#endif
-
-/**********************************************
- Memory management regs 
- **********************************************/
-#ifdef ASn_BASE
-#else
-  #define ASn_BASE                    0x400
-#endif
-
-#ifdef ASn_TRANSTAB_LO
-#else
-  #define ASn_TRANSTAB_LO             0x00
-#endif
-
-#ifdef ASn_TRANSTAB_HI
-#else
-  #define ASn_TRANSTAB_HI             0x04
-#endif
-
-#ifdef ASn_MEMATTR_LO
-#else
-  #define ASn_MEMATTR_LO              0x08
-#endif
-
-#ifdef ASn_MEMATTR_HI
-#else
-  #define ASn_MEMATTR_HI              0x0c
-#endif
-
-#ifdef ASn_LOCKADDR_LO
-#else
-  #define ASn_LOCKADDR_LO             0x10
-#endif
-
-#ifdef ASn_LOCKADDR_HI
-#else
-  #define ASn_LOCKADDR_HI             0x14
-#endif
-
-#ifdef ASn_COMMAND
-#else
-  #define ASn_COMMAND                 0x18
-#endif
-
-#ifdef ASn_FAULTSTATUS
-#else
-  #define ASn_FAULTSTATUS             0x1c
-#endif
-
-#ifdef ASn_FAULTADDR_LO
-#else
-  #define ASn_FAULTADDR_LO            0x20
-#endif
-
-#ifdef ASn_FAULTADDR_HI
-#else
-  #define ASn_FAULTADDR_HI            0x24
-#endif
-
-#ifdef ASn_STATUS
-#else
-  #define ASn_STATUS                  0x28
-#endif
-
-
-/**********************************************
- PRFCNT regs 
- **********************************************/
-#ifdef PRFCNT_CONFIG
-#else
-  #define PRFCNT_CONFIG              0x068
-#endif
-
-#ifdef PRFCNT_JM_EN
-#else
-  #define PRFCNT_JM_EN               0x06C
-#endif
-
-#ifdef PRFCNT_SHADER_EN
-#else
-  #define PRFCNT_SHADER_EN           0x070
-#endif
-
-#ifdef PRFCNT_TILER_EN
-#else 
-  #define PRFCNT_TILER_EN            0x074
-#endif
-
-#ifdef PRFCNT_L3_CACHE_EN
-#else
-  #define PRFCNT_L3_CACHE_EN         0x078
-#endif
-
-#ifdef PRFCNT_MMU_L2_EN
-#else
-  #define PRFCNT_MMU_L2_EN           0x07C
-#endif
-
-
-/**********************************************
- GPU COMMANDS 
- **********************************************/
-
-#ifdef GPU_COMMAND__CYCLE_COUNT_START
-#else
-  #define GPU_COMMAND__CYCLE_COUNT_START 5
-#endif
-
-
-#ifdef GPU_COMMAND__NOP
-#else
-  #define GPU_COMMAND__NOP 0
-#endif
-
-
-#ifdef GPU_COMMAND__SOFT_RESET
-#else
-  #define GPU_COMMAND__SOFT_RESET 1
-#endif
-
-
-#ifdef GPU_COMMAND__HARD_RESET
-#else
-  #define GPU_COMMAND__HARD_RESET 2
-#endif
-
-
-#ifdef GPU_COMMAND__PRFCNT_CLEAR
-#else
-  #define GPU_COMMAND__PRFCNT_CLEAR 3
-#endif
-
-
-#ifdef GPU_COMMAND__PRFCNT_SAMPLE
-#else
-  #define GPU_COMMAND__PRFCNT_SAMPLE 4
-#endif
-
-#ifdef GPU_COMMAND__CYCLE_COUNT_START
-#else
-  #define GPU_COMMAND__CYCLE_COUNT_START 5
-#endif
-
-#ifdef GPU_COMMAND__CYCLE_COUNT_STOP
-#else
-  #define GPU_COMMAND__CYCLE_COUNT_STOP 6
-#endif
-
-#ifdef GPU_COMMAND__CLEAN_CACHES
-#else
-  #define GPU_COMMAND__CLEAN_CACHES 7
-#endif
-
-#ifdef GPU_COMMAND__CLEAN_INV_CACHES
-#else
-  #define GPU_COMMAND__CLEAN_INV_CACHES 8
-#endif
-
-
-/**********************************************
- JSn_STATUS  DEFINES
- **********************************************/
-#ifdef JSn_STATUS__ACTIVE
-#else
-  #define JSn_STATUS__ACTIVE 0x8
-#endif
-
-/**********************************************
- Clock gating overrides
- **********************************************/
-#ifdef JM_CLOCK_GATING_OVERRIDE
-#else
-  #define JM_CLOCK_GATING_OVERRIDE      0xf00
-#endif
-
-#ifdef SC_CLOCK_GATING_OVERRIDE
-#else
-  #define SC_CLOCK_GATING_OVERRIDE      0xf04
-#endif
-
-#ifdef TILER_CLOCK_GATING_OVERRIDE
-#else
-  #define TILER_CLOCK_GATING_OVERRIDE   0xf08
-#endif
-
-#ifdef L2_CLOCK_GATING_OVERRIDE
-#else
-  #define L2_CLOCK_GATING_OVERRIDE      0xf0C
-#endif
-
-
-/**********************************************
- Hardcoded regs (autogenerated from the toplevel testbench file
- common/apb/mali_t760_apb/mali_t760_enums.sv)
- **********************************************/
-
-#ifdef GPU_ID
-#else
-	#define GPU_ID 0x0
-#endif
-
-#ifdef L2_FEATURES
-#else
-	#define L2_FEATURES 0x4
-#endif
-
-#ifdef L3_FEATURES
-#else
-	#define L3_FEATURES 0x8
-#endif
-
-#ifdef TILER_FEATURES
-#else
-	#define TILER_FEATURES 0xC
-#endif
-
-#ifdef MEM_FEATURES
-#else
-	#define MEM_FEATURES 0x10
-#endif
-
-#ifdef MMU_FEATURES
-#else
-	#define MMU_FEATURES 0x14
-#endif
-
-#ifdef AS_PRESENT
-#else
-	#define AS_PRESENT 0x18
-#endif
-
-#ifdef JS_PRESENT
-#else
-	#define JS_PRESENT 0x1C
-#endif
-
-#ifdef GPU_IRQ_RAWSTAT
-#else
-	#define GPU_IRQ_RAWSTAT 0x20
-#endif
-
-#ifdef GPU_IRQ_CLEAR
-#else
-	#define GPU_IRQ_CLEAR 0x24
-#endif
-
-#ifdef GPU_IRQ_MASK
-#else
-	#define GPU_IRQ_MASK 0x28
-#endif
-
-#ifdef GPU_IRQ_STATUS
-#else
-	#define GPU_IRQ_STATUS 0x2C
-#endif
-
-#ifdef GPU_COMMAND
-#else
-	#define GPU_COMMAND 0x30
-#endif
-
-#ifdef GPU_STATUS
-#else
-	#define GPU_STATUS 0x34
-#endif
-
-#ifdef GPU_FAULTSTATUS
-#else
-	#define GPU_FAULTSTATUS 0x3C
-#endif
-
-#ifdef GPU_FAULTADDRESS_LO
-#else
-	#define GPU_FAULTADDRESS_LO 0x40
-#endif
-
-#ifdef GPU_FAULTADDRESS_HI
-#else
-	#define GPU_FAULTADDRESS_HI 0x44
-#endif
-
-#ifdef PWR_KEY
-#else
-	#define PWR_KEY 0x50
-#endif
-
-#ifdef PWR_OVERRIDE0
-#else
-	#define PWR_OVERRIDE0 0x54
-#endif
-
-#ifdef PWR_OVERRIDE1
-#else
-	#define PWR_OVERRIDE1 0x58
-#endif
-
-#ifdef PRFCNT_BASE_LO
-#else
-	#define PRFCNT_BASE_LO 0x60
-#endif
-
-#ifdef PRFCNT_BASE_HI
-#else
-	#define PRFCNT_BASE_HI 0x64
-#endif
-
-#ifdef PRFCNT_CONFIG
-#else
-	#define PRFCNT_CONFIG 0x68
-#endif
-
-#ifdef PRFCNT_JM_EN
-#else
-	#define PRFCNT_JM_EN 0x6C
-#endif
-
-#ifdef PRFCNT_SHADER_EN
-#else
-	#define PRFCNT_SHADER_EN 0x70
-#endif
-
-#ifdef PRFCNT_TILER_EN
-#else
-	#define PRFCNT_TILER_EN 0x74
-#endif
-
-#ifdef PRFCNT_L3_CACHE_EN
-#else
-	#define PRFCNT_L3_CACHE_EN 0x78
-#endif
-
-#ifdef PRFCNT_MMU_L2_EN
-#else
-	#define PRFCNT_MMU_L2_EN 0x7C
-#endif
-
-#ifdef CYCLE_COUNT_LO
-#else
-	#define CYCLE_COUNT_LO 0x90
-#endif
-
-#ifdef CYCLE_COUNT_HI
-#else
-	#define CYCLE_COUNT_HI 0x94
-#endif
-
-#ifdef TIMESTAMP_LO
-#else
-	#define TIMESTAMP_LO 0x98
-#endif
-
-#ifdef TIMESTAMP_HI
-#else
-	#define TIMESTAMP_HI 0x9C
-#endif
-
-#ifdef TEX_FEATURES_0
-#else
-	#define TEX_FEATURES_0 0xB0
-#endif
-
-#ifdef TEX_FEATURES_1
-#else
-	#define TEX_FEATURES_1 0xB4
-#endif
-
-#ifdef TEX_FEATURES_2
-#else
-	#define TEX_FEATURES_2 0xB8
-#endif
-
-#ifdef JS0_FEATURES
-#else
-	#define JS0_FEATURES 0xC0
-#endif
-
-#ifdef JS1_FEATURES
-#else
-	#define JS1_FEATURES 0xC4
-#endif
-
-#ifdef JS2_FEATURES
-#else
-	#define JS2_FEATURES 0xC8
-#endif
-
-#ifdef JS3_FEATURES
-#else
-	#define JS3_FEATURES 0xCC
-#endif
-
-#ifdef JS4_FEATURES
-#else
-	#define JS4_FEATURES 0xD0
-#endif
-
-#ifdef JS5_FEATURES
-#else
-	#define JS5_FEATURES 0xD4
-#endif
-
-#ifdef JS6_FEATURES
-#else
-	#define JS6_FEATURES 0xD8
-#endif
-
-#ifdef JS7_FEATURES
-#else
-	#define JS7_FEATURES 0xDC
-#endif
-
-#ifdef JS8_FEATURES
-#else
-	#define JS8_FEATURES 0xE0
-#endif
-
-#ifdef JS9_FEATURES
-#else
-	#define JS9_FEATURES 0xE4
-#endif
-
-#ifdef JS10_FEATURES
-#else
-	#define JS10_FEATURES 0xE8
-#endif
-
-#ifdef JS11_FEATURES
-#else
-	#define JS11_FEATURES 0xEC
-#endif
-
-#ifdef JS12_FEATURES
-#else
-	#define JS12_FEATURES 0xF0
-#endif
-
-#ifdef JS13_FEATURES
-#else
-	#define JS13_FEATURES 0xF4
-#endif
-
-#ifdef JS16_FEATURES
-#else
-	#define JS16_FEATURES 0xF8
-#endif
-
-#ifdef JS15_FEATURES
-#else
-	#define JS15_FEATURES 0xFC
-#endif
-
-#ifdef SHADER_PRESENT_LO
-#else
-	#define SHADER_PRESENT_LO 0x100
-#endif
-
-#ifdef SHADER_PRESENT_HI
-#else
-	#define SHADER_PRESENT_HI 0x104
-#endif
-
-#ifdef TILER_PRESENT_LO
-#else
-	#define TILER_PRESENT_LO 0x110
-#endif
-
-#ifdef TILER_PRESENT_HI
-#else
-	#define TILER_PRESENT_HI 0x114
-#endif
-
-#ifdef L2_PRESENT_LO
-#else
-	#define L2_PRESENT_LO 0x120
-#endif
-
-#ifdef L2_PRESENT_HI
-#else
-	#define L2_PRESENT_HI 0x124
-#endif
-
-#ifdef L3_PRESENT_LO
-#else
-	#define L3_PRESENT_LO 0x130
-#endif
-
-#ifdef L3_PRESENT_HI
-#else
-	#define L3_PRESENT_HI 0x134
-#endif
-
-#ifdef SHADER_READY_LO
-#else
-	#define SHADER_READY_LO 0x140
-#endif
-
-#ifdef SHADER_READY_HI
-#else
-	#define SHADER_READY_HI 0x144
-#endif
-
-#ifdef TILER_READY_LO
-#else
-	#define TILER_READY_LO 0x150
-#endif
-
-#ifdef TILER_READY_HI
-#else
-	#define TILER_READY_HI 0x154
-#endif
-
-#ifdef L2_READY_LO
-#else
-	#define L2_READY_LO 0x160
-#endif
-
-#ifdef L2_READY_HI
-#else
-	#define L2_READY_HI 0x164
-#endif
-
-#ifdef L3_READY_LO
-#else
-	#define L3_READY_LO 0x170
-#endif
-
-#ifdef L3_READY_HI
-#else
-	#define L3_READY_HI 0x174
-#endif
-
-#ifdef SHADER_PWRON_LO
-#else
-	#define SHADER_PWRON_LO 0x180
-#endif
-
-#ifdef SHADER_PWRON_HI
-#else
-	#define SHADER_PWRON_HI 0x184
-#endif
-
-#ifdef TILER_PWRON_LO
-#else
-	#define TILER_PWRON_LO 0x190
-#endif
-
-#ifdef TILER_PWRON_HI
-#else
-	#define TILER_PWRON_HI 0x194
-#endif
-
-#ifdef L2_PWRON_LO
-#else
-	#define L2_PWRON_LO 0x1A0
-#endif
-
-#ifdef L2_PWRON_HI
-#else
-	#define L2_PWRON_HI 0x1A4
-#endif
-
-#ifdef L3_PWRON_LO
-#else
-	#define L3_PWRON_LO 0x1B0
-#endif
-
-#ifdef L3_PWRON_HI
-#else
-	#define L3_PWRON_HI 0x1B4
-#endif
-
-#ifdef SHADER_PWROFF_LO
-#else
-	#define SHADER_PWROFF_LO 0x1C0
-#endif
-
-#ifdef SHADER_PWROFF_HI
-#else
-	#define SHADER_PWROFF_HI 0x1C4
-#endif
-
-#ifdef TILER_PWROFF_LO
-#else
-	#define TILER_PWROFF_LO 0x1D0
-#endif
-
-#ifdef TILER_PWROFF_HI
-#else
-	#define TILER_PWROFF_HI 0x1D4
-#endif
-
-#ifdef L2_PWROFF_LO
-#else
-	#define L2_PWROFF_LO 0x1E0
-#endif
-
-#ifdef L2_PWROFF_HI
-#else
-	#define L2_PWROFF_HI 0x1E4
-#endif
-
-#ifdef L3_PWROFF_LO
-#else
-	#define L3_PWROFF_LO 0x1F0
-#endif
-
-#ifdef L3_PWROFF_HI
-#else
-	#define L3_PWROFF_HI 0x1F4
-#endif
-
-#ifdef SHADER_PWRTRANS_LO
-#else
-	#define SHADER_PWRTRANS_LO 0x200
-#endif
-
-#ifdef SHADER_PWRTRANS_HI
-#else
-	#define SHADER_PWRTRANS_HI 0x204
-#endif
-
-#ifdef TILER_PWRTRANS_LO
-#else
-	#define TILER_PWRTRANS_LO 0x210
-#endif
-
-#ifdef TILER_PWRTRANS_HI
-#else
-	#define TILER_PWRTRANS_HI 0x214
-#endif
-
-#ifdef L2_PWRTRANS_LO
-#else
-	#define L2_PWRTRANS_LO 0x220
-#endif
-
-#ifdef L2_PWRTRANS_HI
-#else
-	#define L2_PWRTRANS_HI 0x224
-#endif
-
-#ifdef L3_PWRTRANS_LO
-#else
-	#define L3_PWRTRANS_LO 0x230
-#endif
-
-#ifdef L3_PWRTRANS_HI
-#else
-	#define L3_PWRTRANS_HI 0x234
-#endif
-
-#ifdef SHADER_PWRACTIVE_LO
-#else
-	#define SHADER_PWRACTIVE_LO 0x240
-#endif
-
-#ifdef SHADER_PWRACTIVE_HI
-#else
-	#define SHADER_PWRACTIVE_HI 0x244
-#endif
-
-#ifdef TILER_PWRACTIVE_LO
-#else
-	#define TILER_PWRACTIVE_LO 0x250
-#endif
-
-#ifdef TILER_PWRACTIVE_HI
-#else
-	#define TILER_PWRACTIVE_HI 0x254
-#endif
-
-#ifdef L2_PWRACTIVE_LO
-#else
-	#define L2_PWRACTIVE_LO 0x260
-#endif
-
-#ifdef L2_PWRACTIVE_HI
-#else
-	#define L2_PWRACTIVE_HI 0x264
-#endif
-
-#ifdef L3_PWRACTIVE_LO
-#else
-	#define L3_PWRACTIVE_LO 0x270
-#endif
-
-#ifdef L3_PWRACTIVE_HI
-#else
-	#define L3_PWRACTIVE_HI 0x274
-#endif
-
-#ifdef USER_IN_00
-#else
-	#define USER_IN_00 0x400
-#endif
-
-#ifdef USER_IN_01
-#else
-	#define USER_IN_01 0x404
-#endif
-
-#ifdef USER_IN_02
-#else
-	#define USER_IN_02 0x408
-#endif
-
-#ifdef USER_IN_03
-#else
-	#define USER_IN_03 0x40C
-#endif
-
-#ifdef USER_IN_04
-#else
-	#define USER_IN_04 0x410
-#endif
-
-#ifdef USER_IN_05
-#else
-	#define USER_IN_05 0x414
-#endif
-
-#ifdef USER_IN_06
-#else
-	#define USER_IN_06 0x418
-#endif
-
-#ifdef USER_IN_07
-#else
-	#define USER_IN_07 0x41C
-#endif
-
-#ifdef USER_IN_08
-#else
-	#define USER_IN_08 0x420
-#endif
-
-#ifdef USER_IN_09
-#else
-	#define USER_IN_09 0x424
-#endif
-
-#ifdef USER_IN_10
-#else
-	#define USER_IN_10 0x428
-#endif
-
-#ifdef USER_IN_11
-#else
-	#define USER_IN_11 0x42C
-#endif
-
-#ifdef USER_IN_12
-#else
-	#define USER_IN_12 0x430
-#endif
-
-#ifdef USER_IN_13
-#else
-	#define USER_IN_13 0x434
-#endif
-
-#ifdef USER_IN_14
-#else
-	#define USER_IN_14 0x438
-#endif
-
-#ifdef USER_IN_15
-#else
-	#define USER_IN_15 0x43C
-#endif
-
-#ifdef USER_IN_16
-#else
-	#define USER_IN_16 0x440
-#endif
-
-#ifdef USER_IN_17
-#else
-	#define USER_IN_17 0x444
-#endif
-
-#ifdef USER_IN_18
-#else
-	#define USER_IN_18 0x448
-#endif
-
-#ifdef USER_IN_19
-#else
-	#define USER_IN_19 0x44C
-#endif
-
-#ifdef USER_IN_20
-#else
-	#define USER_IN_20 0x450
-#endif
-
-#ifdef USER_IN_21
-#else
-	#define USER_IN_21 0x454
-#endif
-
-#ifdef USER_IN_22
-#else
-	#define USER_IN_22 0x458
-#endif
-
-#ifdef USER_IN_23
-#else
-	#define USER_IN_23 0x45C
-#endif
-
-#ifdef USER_IN_24
-#else
-	#define USER_IN_24 0x460
-#endif
-
-#ifdef USER_IN_25
-#else
-	#define USER_IN_25 0x464
-#endif
-
-#ifdef USER_IN_26
-#else
-	#define USER_IN_26 0x468
-#endif
-
-#ifdef USER_IN_27
-#else
-	#define USER_IN_27 0x46C
-#endif
-
-#ifdef USER_IN_28
-#else
-	#define USER_IN_28 0x470
-#endif
-
-#ifdef USER_IN_29
-#else
-	#define USER_IN_29 0x474
-#endif
-
-#ifdef USER_IN_30
-#else
-	#define USER_IN_30 0x478
-#endif
-
-#ifdef USER_IN_31
-#else
-	#define USER_IN_31 0x47C
-#endif
-
-#ifdef USER_OUT_00
-#else
-	#define USER_OUT_00 0x500
-#endif
-
-#ifdef USER_OUT_01
-#else
-	#define USER_OUT_01 0x504
-#endif
-
-#ifdef USER_OUT_02
-#else
-	#define USER_OUT_02 0x508
-#endif
-
-#ifdef USER_OUT_03
-#else
-	#define USER_OUT_03 0x50C
-#endif
-
-#ifdef USER_OUT_04
-#else
-	#define USER_OUT_04 0x510
-#endif
-
-#ifdef USER_OUT_05
-#else
-	#define USER_OUT_05 0x514
-#endif
-
-#ifdef USER_OUT_06
-#else
-	#define USER_OUT_06 0x518
-#endif
-
-#ifdef USER_OUT_07
-#else
-	#define USER_OUT_07 0x51C
-#endif
-
-#ifdef USER_OUT_08
-#else
-	#define USER_OUT_08 0x520
-#endif
-
-#ifdef USER_OUT_09
-#else
-	#define USER_OUT_09 0x524
-#endif
-
-#ifdef USER_OUT_10
-#else
-	#define USER_OUT_10 0x528
-#endif
-
-#ifdef USER_OUT_11
-#else
-	#define USER_OUT_11 0x52C
-#endif
-
-#ifdef USER_OUT_12
-#else
-	#define USER_OUT_12 0x530
-#endif
-
-#ifdef USER_OUT_13
-#else
-	#define USER_OUT_13 0x534
-#endif
-
-#ifdef USER_OUT_14
-#else
-	#define USER_OUT_14 0x538
-#endif
-
-#ifdef USER_OUT_15
-#else
-	#define USER_OUT_15 0x53C
-#endif
-
-#ifdef USER_OUT_16
-#else
-	#define USER_OUT_16 0x540
-#endif
-
-#ifdef USER_OUT_17
-#else
-	#define USER_OUT_17 0x544
-#endif
-
-#ifdef USER_OUT_18
-#else
-	#define USER_OUT_18 0x548
-#endif
-
-#ifdef USER_OUT_19
-#else
-	#define USER_OUT_19 0x54C
-#endif
-
-#ifdef USER_OUT_20
-#else
-	#define USER_OUT_20 0x550
-#endif
-
-#ifdef USER_OUT_21
-#else
-	#define USER_OUT_21 0x554
-#endif
-
-#ifdef USER_OUT_22
-#else
-	#define USER_OUT_22 0x558
-#endif
-
-#ifdef USER_OUT_23
-#else
-	#define USER_OUT_23 0x55C
-#endif
-
-#ifdef USER_OUT_24
-#else
-	#define USER_OUT_24 0x560
-#endif
-
-#ifdef USER_OUT_25
-#else
-	#define USER_OUT_25 0x564
-#endif
-
-#ifdef USER_OUT_26
-#else
-	#define USER_OUT_26 0x568
-#endif
-
-#ifdef USER_OUT_27
-#else
-	#define USER_OUT_27 0x56C
-#endif
-
-#ifdef USER_OUT_28
-#else
-	#define USER_OUT_28 0x570
-#endif
-
-#ifdef USER_OUT_29
-#else
-	#define USER_OUT_29 0x574
-#endif
-
-#ifdef USER_OUT_30
-#else
-	#define USER_OUT_30 0x578
-#endif
-
-#ifdef USER_OUT_31
-#else
-	#define USER_OUT_31 0x57C
-#endif
-
-#ifdef JM_CONFIG
-#else
-	#define JM_CONFIG 0xF00
-#endif
-
-#ifdef SHADER_CONFIG
-#else
-	#define SHADER_CONFIG 0xF04
-#endif
-
-#ifdef TILER_CONFIG
-#else
-	#define TILER_CONFIG 0xF08
-#endif
-
-#ifdef L2_MMU_CONFIG
-#else
-	#define L2_MMU_CONFIG 0xF0C
-#endif
-
-#ifdef GPU_DEBUG_LO
-#else
-	#define GPU_DEBUG_LO 0xFE8
-#endif
-
-#ifdef GPU_DEBUG_HI
-#else
-	#define GPU_DEBUG_HI 0xFEC
-#endif
-
-#ifdef GPU_CHICKEN_BITS_0
-#else
-	#define GPU_CHICKEN_BITS_0 0xFF0
-#endif
-
-#ifdef GPU_CHICKEN_BITS_1
-#else
-	#define GPU_CHICKEN_BITS_1 0xFF4
-#endif
-
-#ifdef GPU_CHICKEN_BITS_2
-#else
-	#define GPU_CHICKEN_BITS_2 0xFF8
-#endif
-
-#ifdef GPU_CHICKEN_BITS_3
-#else
-	#define GPU_CHICKEN_BITS_3 0xFFC
-#endif
-
-#ifdef JOB_IRQ_RAWSTAT
-#else
-	#define JOB_IRQ_RAWSTAT 0x1000
-#endif
-
-#ifdef JOB_IRQ_CLEAR
-#else
-	#define JOB_IRQ_CLEAR 0x1004
-#endif
-
-#ifdef JOB_IRQ_MASK
-#else
-	#define JOB_IRQ_MASK 0x1008
-#endif
-
-#ifdef JOB_IRQ_STATUS
-#else
-	#define JOB_IRQ_STATUS 0x100C
-#endif
-
-#ifdef JOB_IRQ_JS_STATE
-#else
-	#define JOB_IRQ_JS_STATE 0x1010
-#endif
-
-#ifdef JOB_IRQ_THROTTLE
-#else
-	#define JOB_IRQ_THROTTLE 0x1014
-#endif
-
-#ifdef JS0_HEAD_LO
-#else
-	#define JS0_HEAD_LO 0x1800
-#endif
-
-#ifdef JS0_HEAD_HI
-#else
-	#define JS0_HEAD_HI 0x1804
-#endif
-
-#ifdef JS0_TAIL_LO
-#else
-	#define JS0_TAIL_LO 0x1808
-#endif
-
-#ifdef JS0_TAIL_HI
-#else
-	#define JS0_TAIL_HI 0x180C
-#endif
-
-#ifdef JS0_AFFINITY_LO
-#else
-	#define JS0_AFFINITY_LO 0x1810
-#endif
-
-#ifdef JS0_AFFINITY_HI
-#else
-	#define JS0_AFFINITY_HI 0x1814
-#endif
-
-#ifdef JS0_CONFIG
-#else
-	#define JS0_CONFIG 0x1818
-#endif
-
-#ifdef JS0_COMMAND
-#else
-	#define JS0_COMMAND 0x1820
-#endif
-
-#ifdef JS0_STATUS
-#else
-	#define JS0_STATUS 0x1824
-#endif
-
-#ifdef JS0_HEAD_NEXT_LO
-#else
-	#define JS0_HEAD_NEXT_LO 0x1840
-#endif
-
-#ifdef JS0_HEAD_NEXT_HI
-#else
-	#define JS0_HEAD_NEXT_HI 0x1844
-#endif
-
-#ifdef JS0_AFFINITY_NEXT_LO
-#else
-	#define JS0_AFFINITY_NEXT_LO 0x1850
-#endif
-
-#ifdef JS0_AFFINITY_NEXT_HI
-#else
-	#define JS0_AFFINITY_NEXT_HI 0x1854
-#endif
-
-#ifdef JS0_CONFIG_NEXT
-#else
-	#define JS0_CONFIG_NEXT 0x1858
-#endif
-
-#ifdef JS0_COMMAND_NEXT
-#else
-	#define JS0_COMMAND_NEXT 0x1860
-#endif
-
-#ifdef JS1_HEAD_LO
-#else
-	#define JS1_HEAD_LO 0x1880
-#endif
-
-#ifdef JS1_HEAD_HI
-#else
-	#define JS1_HEAD_HI 0x1884
-#endif
-
-#ifdef JS1_TAIL_LO
-#else
-	#define JS1_TAIL_LO 0x1888
-#endif
-
-#ifdef JS1_TAIL_HI
-#else
-	#define JS1_TAIL_HI 0x188C
-#endif
-
-#ifdef JS1_AFFINITY_LO
-#else
-	#define JS1_AFFINITY_LO 0x1890
-#endif
-
-#ifdef JS1_AFFINITY_HI
-#else
-	#define JS1_AFFINITY_HI 0x1894
-#endif
-
-#ifdef JS1_CONFIG
-#else
-	#define JS1_CONFIG 0x1898
-#endif
-
-#ifdef JS1_COMMAND
-#else
-	#define JS1_COMMAND 0x18a0
-#endif
-
-#ifdef JS1_STATUS
-#else
-	#define JS1_STATUS 0x18a4
-#endif
-
-#ifdef JS1_HEAD_NEXT_LO
-#else
-	#define JS1_HEAD_NEXT_LO 0x18c0
-#endif
-
-#ifdef JS1_HEAD_NEXT_HI
-#else
-	#define JS1_HEAD_NEXT_HI 0x18c4
-#endif
-
-#ifdef JS1_AFFINITY_NEXT_LO
-#else
-	#define JS1_AFFINITY_NEXT_LO 0x18d0
-#endif
-
-#ifdef JS1_AFFINITY_NEXT_HI
-#else
-	#define JS1_AFFINITY_NEXT_HI 0x18d4
-#endif
-
-#ifdef JS1_CONFIG_NEXT
-#else
-	#define JS1_CONFIG_NEXT 0x18d8
-#endif
-
-#ifdef JS1_COMMAND_NEXT
-#else
-	#define JS1_COMMAND_NEXT 0x18e0
-#endif
-
-#ifdef JS2_HEAD_LO
-#else
-	#define JS2_HEAD_LO 0x1900
-#endif
-
-#ifdef JS2_HEAD_HI
-#else
-	#define JS2_HEAD_HI 0x1904
-#endif
-
-#ifdef JS2_TAIL_LO
-#else
-	#define JS2_TAIL_LO 0x1908
-#endif
-
-#ifdef JS2_TAIL_HI
-#else
-	#define JS2_TAIL_HI 0x190C
-#endif
-
-#ifdef JS2_AFFINITY_LO
-#else
-	#define JS2_AFFINITY_LO 0x1910
-#endif
-
-#ifdef JS2_AFFINITY_HI
-#else
-	#define JS2_AFFINITY_HI 0x1914
-#endif
-
-#ifdef JS2_CONFIG
-#else
-	#define JS2_CONFIG 0x1918
-#endif
-
-#ifdef JS2_COMMAND
-#else
-	#define JS2_COMMAND 0x1920
-#endif
-
-#ifdef JS2_STATUS
-#else
-	#define JS2_STATUS 0x1924
-#endif
-
-#ifdef JS2_HEAD_NEXT_LO
-#else
-	#define JS2_HEAD_NEXT_LO 0x1940
-#endif
-
-#ifdef JS2_HEAD_NEXT_HI
-#else
-	#define JS2_HEAD_NEXT_HI 0x1944
-#endif
-
-#ifdef JS2_AFFINITY_NEXT_LO
-#else
-	#define JS2_AFFINITY_NEXT_LO 0x1950
-#endif
-
-#ifdef JS2_AFFINITY_NEXT_HI
-#else
-	#define JS2_AFFINITY_NEXT_HI 0x1954
-#endif
-
-#ifdef JS2_CONFIG_NEXT
-#else
-	#define JS2_CONFIG_NEXT 0x1958
-#endif
-
-#ifdef JS2_COMMAND_NEXT
-#else
-	#define JS2_COMMAND_NEXT 0x1960
-#endif
-
-#ifdef MMU_IRQ_RAWSTAT
-#else
-	#define MMU_IRQ_RAWSTAT 0x2000
-#endif
-
-#ifdef MMU_IRQ_CLEAR
-#else
-	#define MMU_IRQ_CLEAR 0x2004
-#endif
-
-#ifdef MMU_IRQ_MASK
-#else
-	#define MMU_IRQ_MASK 0x2008
-#endif
-
-#ifdef MMU_IRQ_STATUS
-#else
-	#define MMU_IRQ_STATUS 0x200C
-#endif
-
-#ifdef AS0_TRANSTAB_LO
-#else
-	#define AS0_TRANSTAB_LO 0x2400
-#endif
-
-#ifdef AS0_TRANSTAB_HI
-#else
-	#define AS0_TRANSTAB_HI 0x2404
-#endif
-
-#ifdef AS0_MEMATTR_LO
-#else
-	#define AS0_MEMATTR_LO 0x2408
-#endif
-
-#ifdef AS0_MEMATTR_HI
-#else
-	#define AS0_MEMATTR_HI 0x240C
-#endif
-
-#ifdef AS0_LOCKADDR_LO
-#else
-	#define AS0_LOCKADDR_LO 0x2410
-#endif
-
-#ifdef AS0_LOCKADDR_HI
-#else
-	#define AS0_LOCKADDR_HI 0x2414
-#endif
-
-#ifdef AS0_COMMAND
-#else
-	#define AS0_COMMAND 0x2418
-#endif
-
-#ifdef AS0_FAULTSTATUS
-#else
-	#define AS0_FAULTSTATUS 0x241C
-#endif
-
-#ifdef AS0_FAULTADDRESS_LO
-#else
-	#define AS0_FAULTADDRESS_LO 0x2420
-#endif
-
-#ifdef AS0_FAULTADDRESS_HI
-#else
-	#define AS0_FAULTADDRESS_HI 0x2424
-#endif
-
-#ifdef AS0_STATUS
-#else
-	#define AS0_STATUS 0x2428
-#endif
-
-#ifdef AS1_TRANSTAB_LO
-#else
-	#define AS1_TRANSTAB_LO 0x2440
-#endif
-
-#ifdef AS1_TRANSTAB_HI
-#else
-	#define AS1_TRANSTAB_HI 0x2444
-#endif
-
-#ifdef AS1_MEMATTR_LO
-#else
-	#define AS1_MEMATTR_LO 0x2448
-#endif
-
-#ifdef AS1_MEMATTR_HI
-#else
-	#define AS1_MEMATTR_HI 0x244C
-#endif
-
-#ifdef AS1_LOCKADDR_LO
-#else
-	#define AS1_LOCKADDR_LO 0x2450
-#endif
-
-#ifdef AS1_LOCKADDR_HI
-#else
-	#define AS1_LOCKADDR_HI 0x2454
-#endif
-
-#ifdef AS1_COMMAND
-#else
-	#define AS1_COMMAND 0x2458
-#endif
-
-#ifdef AS1_FAULTSTATUS
-#else
-	#define AS1_FAULTSTATUS 0x245C
-#endif
-
-#ifdef AS1_FAULTADDRESS_LO
-#else
-	#define AS1_FAULTADDRESS_LO 0x2460
-#endif
-
-#ifdef AS1_FAULTADDRESS_HI
-#else
-	#define AS1_FAULTADDRESS_HI 0x2464
-#endif
-
-#ifdef AS1_STATUS
-#else
-	#define AS1_STATUS 0x2468
-#endif
-
-#ifdef AS2_TRANSTAB_LO
-#else
-	#define AS2_TRANSTAB_LO 0x2480
-#endif
-
-#ifdef AS2_TRANSTAB_HI
-#else
-	#define AS2_TRANSTAB_HI 0x2484
-#endif
-
-#ifdef AS2_MEMATTR_LO
-#else
-	#define AS2_MEMATTR_LO 0x2488
-#endif
-
-#ifdef AS2_MEMATTR_HI
-#else
-	#define AS2_MEMATTR_HI 0x248C
-#endif
-
-#ifdef AS2_LOCKADDR_LO
-#else
-	#define AS2_LOCKADDR_LO 0x2490
-#endif
-
-#ifdef AS2_LOCKADDR_HI
-#else
-	#define AS2_LOCKADDR_HI 0x2494
-#endif
-
-#ifdef AS2_COMMAND
-#else
-	#define AS2_COMMAND 0x2498
-#endif
-
-#ifdef AS2_FAULTSTATUS
-#else
-	#define AS2_FAULTSTATUS 0x249C
-#endif
-
-#ifdef AS2_FAULTADDRESS_LO
-#else
-	#define AS2_FAULTADDRESS_LO 0x24A0
-#endif
-
-#ifdef AS2_FAULTADDRESS_HI
-#else
-	#define AS2_FAULTADDRESS_HI 0x24A4
-#endif
-
-#ifdef AS2_STATUS
-#else
-	#define AS2_STATUS 0x24A8
-#endif
-
-#ifdef AS3_TRANSTAB_LO
-#else
-	#define AS3_TRANSTAB_LO 0x24C0
-#endif
-
-#ifdef AS3_TRANSTAB_HI
-#else
-	#define AS3_TRANSTAB_HI 0x24C4
-#endif
-
-#ifdef AS3_MEMATTR_LO
-#else
-	#define AS3_MEMATTR_LO 0x24C8
-#endif
-
-#ifdef AS3_MEMATTR_HI
-#else
-	#define AS3_MEMATTR_HI 0x24CC
-#endif
-
-#ifdef AS3_LOCKADDR_LO
-#else
-	#define AS3_LOCKADDR_LO 0x24D0
-#endif
-
-#ifdef AS3_LOCKADDR_HI
-#else
-	#define AS3_LOCKADDR_HI 0x24D4
-#endif
-
-#ifdef AS3_COMMAND
-#else
-	#define AS3_COMMAND 0x24D8
-#endif
-
-#ifdef AS3_FAULTSTATUS
-#else
-	#define AS3_FAULTSTATUS 0x24DC
-#endif
-
-#ifdef AS3_FAULTADDRESS_LO
-#else
-	#define AS3_FAULTADDRESS_LO 0x24E0
-#endif
-
-#ifdef AS3_FAULTADDRESS_HI
-#else
-	#define AS3_FAULTADDRESS_HI 0x24E4
-#endif
-
-#ifdef AS3_STATUS
-#else
-	#define AS3_STATUS 0x24E8
-#endif
-
-#ifdef ILLEGAL_ADDRESS1
-#else
-	#define ILLEGAL_ADDRESS1 0x3000
-#endif
-
-#ifdef ILLEGAL_ADDRESS2
-#else
-	#define ILLEGAL_ADDRESS2 0x3ffc
-#endif
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-generic.c b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-generic.c
deleted file mode 100644
index c3c9cc3032dd..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-generic.c
+++ /dev/null
@@ -1,219 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-*The confidential and proprietary information contained in this file may
-*only be used by a person authorised under and to the extent permitted
-*by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011,2012-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-*This entire notice must be reproduced on all copies of this file
-*and copies of this file may only be made by a person if such person is
-*permitted to do so under the terms of a subsisting license agreement
-*from ARM Limited.
-*Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-*Revision  : $Revision: 66689 $
-*Release   : $State: $
-*-----------------------------------------------------------------------------
-* 
-*-----------------------------------------------------------------------------
-* Abstract :Implements all the generic APIs used for mali memory and register
-* compares
-*-----------------------------------------------------------------------------
-* Overview
-*----------
-* 
-**************************************************************/
-
-#include "MaliFns.h"
-//#include <stdio.h>
-//#include <string.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-
-#define printf printk
-int Mali_MemCpy(unsigned int *malidata_page,
-                unsigned int mali_va,
-                unsigned int *refdata,
-                unsigned int refoffset,
-                unsigned int len) 
-{
-  memcpy((void *)((char *)malidata_page + (mali_va % 4096)),
-               (void *)((char *)refdata + (refoffset)),
-               len * sizeof(unsigned int));
-
-  return 0;
-};
-
-int Mali_MemCpyMasked(unsigned int *malidata_page,
-                      unsigned int mali_va,
-                      unsigned int *refdata,
-                      unsigned int *refmask,
-                      unsigned int refoffset,
-                      unsigned int len) 
-{
-  unsigned int *maskptr = (unsigned int *)((char *)refmask + (refoffset));
-  unsigned int *refptr  = (unsigned int *)((char *)refdata + (refoffset));
-  unsigned int *dataptr = (unsigned int *)((char *)malidata_page + (mali_va % 4096));
-  unsigned int len2 = len;
-  unsigned int m;
-
-  while (len2--) {
-    m   = *maskptr++;
-	if (~m == 0) {
-		*dataptr = *refptr;
-	} else {
-		*dataptr = (*dataptr & ~m) | (*refptr & m);
-	}
-
-	*dataptr++;
-	*refptr++;
-  };
-
-  return 0;
-};
-
-int Mali_MemCmp(unsigned int *malidata_page,
-                unsigned int mali_va,
-                unsigned int *refdata,
-                unsigned int refoffset,
-                unsigned int len) 
-{
-  int res;
-  int i;
-  int j;
-  int step = 4;
-
-#ifdef MALINOCHECK
-  return 0;
-#endif
-
-  res = memcmp((void *)((char *)malidata_page + (mali_va % 4096)),
-               (void *)((char *)refdata + (refoffset)),
-               len * sizeof(unsigned int));
-
-  if (res) {
-
-    printf("Error during check of %x bytes from address PA:%x, VA:%x with reference data at address %x\n",
-           len * 4,
-           ((unsigned int)malidata_page + (mali_va % 4096)),
-           mali_va,
-           refdata);
-
-    return -1;
-  } else {
-    return 0;
-  };
-};
-
-int Mali_MemCmpMasked(unsigned int *malidata_page,
-                      unsigned int mali_va,
-                      unsigned int *refdata,
-                      unsigned int *refmask,
-                      unsigned int refoffset,
-                      unsigned int len) 
-{
-  int res = 0;
-
-  unsigned int *maskptr = (unsigned int *)((char *)refmask + (refoffset));
-  unsigned int *refptr  = (unsigned int *)((char *)refdata + (refoffset));
-  unsigned int *dataptr = (unsigned int *)((char *)malidata_page + (mali_va % 4096));
-  unsigned int len2 = len;
-  unsigned int m;
-
-#ifdef MALINOCHECK
-  return 0;
-#endif
-
-  while (len2--) {
-    m   = *maskptr++;
-    if ((*dataptr++ & m) != (*refptr++ & m)) {
-      res  = 1;
-      len2 = 0;
-    };
-  };
-
-  if (res) {
-    printf("Error during check of %x bytes from address PA:%x, VA:%x with reference data at address %x\n",
-           len * 4,
-           ((unsigned int)malidata_page + (mali_va % 4096)),
-           mali_va,
-           refdata);
-    return -1;
-  } else {
-    return 0;
-  };
-};
-
-int Mali_CompareRegs(unsigned int *reference_ptr, 
-                      int mali_unit,
-                     int mali_core,
-                     int lowreg, 
-                     int highreg)
-{
-  unsigned int reference_base = (unsigned int)reference_ptr;
-  unsigned int *p;
-  int i;
-  unsigned int v_mali;
-  unsigned int v_testvalue;
-
-#ifdef MALINOCHECK
-  return 0;
-#endif
-
-  reference_base = reference_base + (lowreg % 0x10);
-  p = (unsigned int *)reference_base;
-
-  for (i=0; i < (highreg-lowreg); i += 4) {
-    v_mali = Mali_RdReg(mali_unit,mali_core,lowreg+i);
-    v_testvalue = *(p + (i/4));
-    printf ("Checking Register: %08x is value %08x\n",(mali_unit << 28) + (mali_core << 16) + lowreg + i,v_testvalue);
-    if ( v_mali != v_testvalue) {
-      printf ("Reg Compare Fail: %08x; value=%08x should be=%08x\n",(mali_unit << 28) + (mali_core << 16) + lowreg + i,v_mali,v_testvalue);
-      return -1;
-    };
-  };
-  return 0;
-};
-
-void Mali_DisplayReg(int unit,int core, int regnum) {
-  int v = Mali_RdReg(unit,core,regnum);
-  printf ("Reg: 0x%08x Value: %08x\n",(unit <<28)+(core<<16)+regnum,v);
-};
-
-void Mali_CheckReg(int unit,int core, int regnum, int value) {
-  int v = Mali_RdReg(unit,core,regnum);
-  if(v != value)
-    printf ("Reg Compare Fail: 0x%08x Value: %08x should be=%08x\n",(unit <<28)+(core<<16)+regnum,v,value);
-  else
-    printf ("Reg Compare: 0x%08x Value: %08x\n",(unit <<28)+(core<<16)+regnum,v);
-};
-
-/*
- * This function simply prints out a given number of 32-bit words from a given location in memory
- * 
- * It is useful for debugging the GPU's job descriptors and any memory related issues
- */
-void Mali_PrintMem (volatile unsigned int * memory_address, unsigned int word_count)
-{
-    int j;
-    
-    printf ("Memory readout for 0x%x:\n  ", memory_address); 
-    for (j=0;j<word_count;j++)
-    {
-      if ((j%4)==0 && j != 0)
-      {
-        printf ("\n  ");
-      }
-      printf ("word[%02d]=0x%08x ", j, *memory_address); 
-      memory_address += 1;
-    }
-    printf ("\n");
-
-}
-
-void Mali_ReadDescriptor (volatile unsigned int * descriptor_address)
-{
-  Mali_PrintMem (descriptor_address, 12);
-}
-#undef printf
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-t760.c b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-t760.c
deleted file mode 100644
index 7d112d3cc443..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-t760.c
+++ /dev/null
@@ -1,366 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-*The confidential and proprietary information contained in this file may
-*only be used by a person authorised under and to the extent permitted
-*by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-*This entire notice must be reproduced on all copies of this file
-*and copies of this file may only be made by a person if such person is
-*permitted to do so under the terms of a subsisting license agreement
-*from ARM Limited.
-*Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-*Revision  : $Revision: 66689 $
-*Release   : $State: $
-*-----------------------------------------------------------------------------
-* 
-*-----------------------------------------------------------------------------
-* Abstract :Implementaion of all functions that are used to access MALI
-*-----------------------------------------------------------------------------
-* Overview
-*----------
-* 
-**************************************************************/
-
-#include "MaliDefines-t760.h"
-
-
-static int gpu_errmask = 0;
-static int mmu_errmask = 0;
-static int job_errmask = 0;
-static int* MALI_BASE;
-
-void Mali_Reset(void) 
-{
-};
-
-void Mali_SetBase(int* base)
-{
-	MALI_BASE = base;
-}
-
-#define printf printk
-void Mali_SetInterruptErrMask(int type, int e_mask)
-{
-  switch (type) {
-	  case 1 : gpu_errmask = e_mask; break;
-	  case 2 : mmu_errmask = e_mask; break;
-	  case 3 : job_errmask = e_mask; break;
-	  default : 
-		  printf("Programming Error\n"); 	
-		  exit(1);
-  }
-}
-
-void Mali_Identify(void)
-{
-	int gpuid = Mali_RdReg(0x20,0,0);
-
-	int l2features, l3features, tilerfeatures,memfeatures;
-	int mmufeatures, aspresent, jspresent;
-
-
-	printf("GPU ID=0x%08x ProductID=0x%04x, Version=r%1dp%1d Version_status=%1d\n",
-  (gpuid) & 0XFFFFFFFF,
-  (gpuid>>16) & 0xFFFF,
-  (gpuid>>12) & 0xF,
-  (gpuid>>4) & 0xFF,
-  (gpuid) & 0xF);
-
-	l2features = Mali_RdReg(0x20,0,0x4);
-	printf("L2. LineSize=%2d Associativity=%2d CacheSize=%dkB BusWidth=%3d\n",
-		   1 << ((l2features)       & 0xFF),
-		   1 << ((l2features >> 8)  & 0xFF),
-		  (1 << ((l2features >> 16) & 0xFF)) >> 10,
-		   1 << ((l2features >> 24) & 0xFF)
-		);
-
-	l3features = Mali_RdReg(0x20,0,0x8);
-	if (l3features != 0) {
-		printf("L3. LineSize=%3d Associativity=%3d CacheSize=%dkB BusWidth=%3d\n",
-			   1 << ((l3features)       & 0xFF),
-			   1 << ((l3features >> 8)  & 0xFF),
-        (1 << ((l3features >> 16) & 0xFF)) >> 10,
-			   1 << ((l3features >> 24) & 0xFF));
-	};
-
-	tilerfeatures =  Mali_RdReg(0x20,0,0xC);
-	printf("Tiler. BinSize=%4d MaxActiveLevels=%4d\n",
-		   1 << ((tilerfeatures)        & 0x3F),
-		   1 << ((tilerfeatures >> 8)   & 0xF));
-		   
-	memfeatures =  Mali_RdReg(0x20,0,0x10);
-	printf("MemFeatures. CoherentCoreGroup=%d CoherentSuperGroup=%d L2 Slices=%d\n",
-		   memfeatures & 0x1,
-		   (memfeatures > 1) & 0x1,
-       (((memfeatures>>8) & 0xf)+1));
-
-	mmufeatures =  Mali_RdReg(0x20,0,0x14);
-	printf("MMUFeatures. VA_BITS=%d PA_BITS=%d\n",
-		   mmufeatures & 0xFF,
-		   (mmufeatures >> 8) & 0xFF);
-
-	aspresent =  Mali_RdReg(0x20,0,0x18);
-	jspresent =  Mali_RdReg(0x20,0,0x1C);
-	printf("ASPresent=%08x JSPresent=%08x\n",
-		   aspresent,
-		   jspresent);
-
-}
-
-
-void *Mali_LdMem(void *srcptr,int size,int ttb_base) {
-  /* Setup MMU to point to data structures for this image */
-  Mali_WrReg(0x20,0,0x240c,0);
-  Mali_WrReg(0x20,0,0x2408,0x88888888);
-  Mali_WrReg(0x20,0,0x2404,0);
-  Mali_WrReg(0x20,0,0x2400,ttb_base|0x3);
-  printf (" - - - - - - - - > ttb_base = %x\n", ttb_base);
-  Mali_WrReg(0x20,0,0x2418,1); // Broadcast updates
-  /* Clear interrupts and enable them */
-  Mali_WrReg(0x20,0,0x2004,0xFFFFFFFF);
-  Mali_WrReg(0x20,0,0x2008,0xFFFFFFFF);
-
-  return srcptr;
-};
-
-static void Mali_GPUError(int stat,int mask,int faultstat,int faultvalo,int faultvahi)
-{
-	printf("Unexpected GPU Fault:\n");
-	printf("Int Status=%08x, Error Mask=%08x\n",stat, mask);
-	printf("FaultStats=%08x,VA=%08x%08x\n",faultstat, faultvahi,faultvalo);
-	printf ("TEST FAILED\n\n");
-	exit(1);
-}
-static void Mali_MMUError(int stat,int mask,int faultstat,int faultvalo,int faultvahi)
-{
-	printf("Unexpected MMU Fault:\n");
-	printf("Int Status=%08x, Error Mask=%08x\n",stat, mask);
-	printf("FaultStats=%08x, VA=%08x%08x\n",faultstat, faultvahi,faultvalo);
-	printf ("TEST FAILED\n\n");
-	exit(1);
-}
-static void Mali_JobError(int stat,int mask)
-{
-	printf("Unexpected Job Interrupt:\n");
-	printf("Int Status=%08x, Error Mask=%08x\n",stat, mask);
-	printf ("TEST FAILED\n\n");
-	exit(1);
-}
-
-/* This function is backwards compatible with Mali400 API
- * For T760 it checks for job interrupts if mask and value given
- * We wait for any interrupt if mask and value is all set
- */
-int Mali_InterruptCheck(int i_mask, int i_value)
-{
-	if ((i_mask == i_value) && i_mask == 0xFFFFFFFF) {
-		return Mali_AnyInterruptCheck(0,i_mask,i_value);
-	} else {
-		return Mali_AnyInterruptCheck(3,i_mask,i_value);
-	}
-}
-
-/* This function checks if we have the required interrupts.
- * It polls the Mali interrupt registers for this.
- * If we do not have the required interrupts, then it remembers which ones we 
- * have seen, and then masks them.
- */
-int Mali_AnyInterruptCheck(int type, int i_mask, int i_value)
-{
-  int done;
-
-  /* Read interrupt status */
-  int gpu_stat = Mali_RdReg(0x20,0,0x2c);
-  int job_stat = Mali_RdReg(0x20,0,0x100c);
-  int mmu_stat = Mali_RdReg(0x20,0,0x200c);
-
-  int gpu_rawstat = Mali_RdReg(0x20,0,0x20);
-  int job_rawstat = Mali_RdReg(0x20,0,0x1000);
-  int mmu_rawstat = Mali_RdReg(0x20,0,0x2000);
-
-  int v;
-
-  /* Compare against failure conditions */
-  if ((gpu_stat & gpu_errmask) != 0) {
-	  Mali_GPUError(gpu_stat,gpu_errmask,
-					Mali_RdReg(0x20,0,0x3C),
-					Mali_RdReg(0x20,0,0x40),
-					Mali_RdReg(0x20,0,0x44));
-  }
-
-  if ((mmu_stat & mmu_errmask) != 0) {
-	  Mali_MMUError(mmu_stat,mmu_errmask,
-					Mali_RdReg(0x20,0,0x201c),
-					Mali_RdReg(0x20,0,0x2020),
-					Mali_RdReg(0x20,0,0x2024));
-  }
-
-  if ((job_stat & job_errmask) != 0) {
-	  Mali_JobError(job_stat,job_errmask);
-  }
-
-  /* If no failure then test against masks as required */
-  done = 0;
-  switch (type) {
-	  // This is wait for any interrupt, so check against real interrupt outputs
-	  case 0 : done = ((gpu_stat | job_stat | mmu_stat) != 0); break;
-
-	  // These are masked checks, so check if required interrupts are triggered.
-      // We do against rawstat, since if not all required interrupts have occured
-      // then we need to mask the first ones to happen, whilst waiting for the others.
-	  case 1 : done = ((gpu_rawstat & i_mask) == i_value); break;
-	  case 2 : done = ((job_rawstat & i_mask) == i_value); break;
-	  case 3 : done = ((mmu_rawstat & i_mask) == i_value); break;
-	  default : 
-		  printf("Programming Error\n"); 	
-		  exit(1);
-  }
-
-
-
-
-
-  /* If we do not satisfy final conditions then
-   * mask all seen interrupts
-   */
-  if (!done) {
-	  // If not done then mark the interrupts we have seen
-	  Mali_WrReg(0x20,0,0x28,  Mali_RdReg(0x20,0,0x28)   &  ~gpu_stat);
-	  Mali_WrReg(0x20,0,0x1008,Mali_RdReg(0x20,0,0x1008) &  ~job_stat);
-	  Mali_WrReg(0x20,0,0x2008,Mali_RdReg(0x20,0,0x2008) &  ~mmu_stat);
-	  printf ("Interrupt - conditions not met - WFI\n");
-  }
-
-  if (done) {
-	  // When done - re-enable all the interrupts we were looking for
-	  // This is only an issue for specific interrupt testing.
-	  switch (type) {
-		  case 0 :    break;
-		  case 1 :	  Mali_WrReg(0x20,0,0x28,  Mali_RdReg(0x20,0,0x28)   | i_value); break;
-		  case 2 :	  Mali_WrReg(0x20,0,0x1008,Mali_RdReg(0x20,0,0x1008) | i_value); break;
-		  case 3 :    Mali_WrReg(0x20,0,0x2008,Mali_RdReg(0x20,0,0x2008) | i_value); break;
-		  default :
-			  printf("Programming error\n");
-			  exit(1);
-	  }
-
-	  printf ("Interrupt - conditions met - continue test\n");
-  }
-
-  printf("gpu_raw_stat = %x\n",gpu_rawstat);
-  printf("job_raw_stat = %x\n",job_rawstat);
-  printf("mmu_raw_stat = %x\n",mmu_rawstat);
-  v =  Mali_RdReg(0x20,0,0x1824);
-  printf("JS0Status = %x\n",v);
-  v =  Mali_RdReg(0x20,0,0x18a4);
-  printf("JS1Status = %x\n",v);
-  v =  Mali_RdReg(0x20,0,0x1924);
-  printf("JS2Status = %x\n",v);
-
-  return done;
-};
-
-
-void Mali_MaskAllInterrupts (void) {
-	Mali_WrReg(0x20,0,0x24,0xFFFFFFFF);
-	Mali_WrReg(0x20,0,0x1004,0xFFFFFFFF);
-	Mali_WrReg(0x20,0,0x2004,0xFFFFFFFF);
-};
-
-
-int Mali_RdReg(int unit,int core, int regnum)
-{
-  int *reg_ptr = (int *)MALI_BASE + (regnum/4);
-  return *reg_ptr;
-};
-
-
-void Mali_WrReg(int unit,int core,int regnum,int value)
-{
-  
-  int *reg_ptr = (int *)MALI_BASE + (regnum/4);
-  *reg_ptr = value;
-};
-
-unsigned int Mali_PollReg (unsigned int unit, unsigned int core, unsigned int regnum, unsigned int bit_location, unsigned int val, char * name_str)
-{
-  int regnum_value =  Mali_RdReg(0x20,0,regnum);
-
-
-  printf ("Polling (for %d) of register %s 0x%x bit %d started\n", val, name_str, regnum, bit_location);
-  
-  if (val)
-  {
-    while ((regnum_value & (1<<bit_location)) != (1<<bit_location))
-    {
-      regnum_value = Mali_RdReg(0x20,0,regnum);
-    }  
-  }
-  else
-  {
-    while ((regnum_value & (1<<bit_location)) == (1<<bit_location))
-    {
-      regnum_value = Mali_RdReg(0x20,0,regnum);
-    }  
-  }
-  printf ("Polling (for %d) of register %s 0x%x bit %d ended   current value=0x%x \n", val, name_str, regnum, bit_location, regnum_value);
-  
-  return regnum_value;
-};
-
-
-void Mali_clear_irqs_and_set_all_masks (void) {
-  Mali_clear_and_set_masks_for_gpu_irq ();
-  Mali_clear_and_set_masks_for_mmu_irq ();
-  Mali_clear_and_set_masks_for_job_irq ();
-}
-
-void Mali_clear_and_set_masks_for_gpu_irq (void) {
-  printf ("Clear the GPU IRQ flags\n");
-  Mali_WrReg(0x20,0x0, GPU_IRQ_CLEAR       , 0xFFFFFFFF);
-  printf ("Set the GPU IRQ Mask to all 1s\n");
-  Mali_WrReg(0x20,0x0, GPU_IRQ_MASK        , 0xFFFFFFFF);
-}
-void Mali_clear_and_set_masks_for_mmu_irq (void) {
-  printf ("Clear the MMU IRQ flags\n");
-  Mali_WrReg(0x20,0x0, MMU_IRQ_CLEAR       , 0xFFFFFFFF);
-  printf ("Set the MMU IRQ Mask to all 1s\n");
-  Mali_WrReg(0x20,0x0, MMU_IRQ_MASK        , 0xFFFFFFFF);
-}
-void Mali_clear_and_set_masks_for_job_irq (void) {
-  printf ("Clear the JOB IRQ flags\n");
-  Mali_WrReg(0x20,0x0, JOB_IRQ_CLEAR       , 0xFFFFFFFF);
-  printf ("Set the JOB IRQ Mask to all 1s\n");
-  Mali_WrReg(0x20,0x0, JOB_IRQ_MASK        , 0xFFFFFFFF);
-}
-
-void Mali_write_ASn_register (int ASn_reg, int n, int value_to_write) {
-  int ASn_reg_final = MEM_MANAGEMENT_BASE | ASn_BASE | ASn_reg | (n * 64);
-#ifdef DEBUG_ON
-  printf ("Write: ASn_reg_final=0x%x n=%d value=0x%x\n", ASn_reg_final, n, value_to_write);
-#endif
-  Mali_WrReg (0x20, 0, ASn_reg_final, value_to_write);
-}
-
-void Mali_write_JSn_register (int JSn_reg, int n, int value_to_write) {
-  int JSn_reg_final = JOB_CONTROL_BASE | JSn_BASE | JSn_reg | (n * 128);
-#ifdef DEBUG_ON
-  printf ("Write: JSn_reg_final=0x%x n=%d value=0x%x\n", JSn_reg_final, n, value_to_write);
-#endif
-  Mali_WrReg (0x20, 0, JSn_reg_final, value_to_write);
-}
-
-int Mali_read_JSn_register (int JSn_reg, int n) {
-  int JSn_reg_final = JOB_CONTROL_BASE | JSn_BASE | JSn_reg | (n * 128);
-  int value_read = Mali_RdReg (0x20, 0, JSn_reg_final);
-#ifdef DEBUG_ON
-  printf ("Read: JSn_reg_final=0x%x n=%d value=0x%x\n", JSn_reg_final, n, value_read);
-#endif
-  return value_read;
-}
-
-#undef printf
-
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-t760perf.c b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-t760perf.c
deleted file mode 100644
index 0c980abc42bb..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns-t760perf.c
+++ /dev/null
@@ -1,37 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-*The confidential and proprietary information contained in this file may
-*only be used by a person authorised under and to the extent permitted
-*by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011,2012-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-*This entire notice must be reproduced on all copies of this file
-*and copies of this file may only be made by a person if such person is
-*permitted to do so under the terms of a subsisting license agreement
-*from ARM Limited.
-*Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-*Revision  : $Revision: 66689 $
-*Release   : $State: $
-*-----------------------------------------------------------------------------
-* 
-*-----------------------------------------------------------------------------
-* Abstract : Mali Performance Counters
-*-----------------------------------------------------------------------------*/
-
-#include "MaliFns.h"
-
-void Mali_InitPerfCountersFn(int core, int cnt_num, int cnt_id);
-
-/* Defines for Performance Counters - Cores */
-
-
-void Mali_InitPerfCounters() {
-};
-
-void Mali_InitPerfCountersFn(int core, int cnt_num, int cnt_id) {
-};
-
-void Mali_ReadPerfCounters() {
-};
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns.h b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns.h
deleted file mode 100644
index 102542aaf1cf..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/MaliFns.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-*The confidential and proprietary information contained in this file may
-*only be used by a person authorised under and to the extent permitted
-*by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2010-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-*This entire notice must be reproduced on all copies of this file
-*and copies of this file may only be made by a person if such person is
-*permitted to do so under the terms of a subsisting license agreement
-*from ARM Limited.
-*Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-*Revision  : $Revision: 66689 $
-*Release   : $State: $
-*-----------------------------------------------------------------------------
-* 
-*-----------------------------------------------------------------------------
-* Abstract :Declaration of Mali functions 
-*-----------------------------------------------------------------------------
-* Overview
-*----------
-* 
-**************************************************************/
-
-//#define  t760 1
-/*
-#ifdef VE
-#define  MALI_BASE 0x2D000000
-#else
-#define  MALI_BASE 0xC0000000
-#endif
-*/
-/****************************************************************************
- * SYSTEM SPECIFIC FUNCTIONS                                                  
- ****************************************************************************/
-void CPU_EnableInterrupts(void);
-void CPU_DisableInterrupts(void);
-void CPU_InitialiseInterrupts(void);
-
-void Mali_WaitForClk(int);
-void Mali_WaitForInterrupt(void);
-void Mali_InstallIntHandlers(void (*callback_mali_gpu)(void), 
-                             void (*callback_mali_mmu)(void), 
-                             void (*callback_mali_job)(void));
-void Mali_Message(char *s);
-void Mali_SetupOutputFrame(void);
-void Mali_JobPartDone(void);
-
-/****************************************************************************
- * MALI REGISTER READ / WRITE
- ****************************************************************************/
-void Mali_Reset(void);
-void *Mali_LdMem(void *srcptr,int size,int ttb_base);
-void Mali_WrReg(int unit,int core,int regnum,int value);
-int  Mali_RdReg(int unit,int core,int regnum);
-unsigned int Mali_PollReg (unsigned int unit, unsigned int core, unsigned int regnum, unsigned int bit_location, unsigned int val, char * name_str);
-
-void Mali_DisplayReg(int unit,int core, int regnum);
-
-void Mali_Identify(void);
-
-int Mali_InterruptCheck(int i_mask, int i_value);
-int Mali_AnyInterruptCheck(int type, int i_mask, int i_value);
-void Mali_MaskAllInterrupts(void);
-
-void Mali_SetInterruptErrMask(int type, int e_mask);
-
-/****************************************************************************
- * MALI PERFORMANCE COUNTERS
- ****************************************************************************/
-void Mali_InitPerfCounters(void);
-void Mali_ReadPerfCounters(void);
-
-/****************************************************************************
- * UTILITY FUNCTIONS FOR COPYING DATA INTO MALI MEMORY
- ****************************************************************************/
-int Mali_MemCpy(unsigned int *malidata_page,
-                unsigned int mali_va,
-                unsigned int *refdata,
-                unsigned int refoffset,
-                unsigned int len);
-
-int Mali_MemCpyMasked(unsigned int *malidata_page,
-                      unsigned int mali_va,
-                      unsigned int *refdata,
-                      unsigned int *refmask,
-                      unsigned int refoffset,
-                      unsigned int len);
-
-/****************************************************************************
- * UTILITY FUNCTIONS FOR CHECKING TEST RESULTS
- ****************************************************************************/
-int Mali_MemCmp(unsigned int *malidata_page,
-                unsigned int mali_va,
-                unsigned int *refdata,
-                unsigned int refoffset,
-                unsigned int len);
-
-int Mali_MemCmpMasked(unsigned int *malidata_page,
-                      unsigned int mali_va,
-                      unsigned int *refdata,
-                      unsigned int *refmask,
-                      unsigned int refoffset,
-                      unsigned int len);
-
-int Mali_CompareRegs(unsigned int *reference_ptr, 
-                      int mali_unit,
-                     int mali_core,
-                     int lowreg, 
-                     int highreg);
-
-/****************************************************************************
- * FUNCTIONS THAT ARE USEFUL FOR DEBUG
- ****************************************************************************/
-void Mali_PrintMem       (volatile unsigned int * memory_address, unsigned int word_count );
-void Mali_ReadDescriptor (volatile unsigned int * descriptor_address                      );
-
-
-int RunMaliTest_sim1_t760 (int *base);
-int RunMaliTest_sim2_t760 (int *base);
-int RunMaliTest_sim3_t760 (int *base);
-int RunMaliTest_sim4_t760 (int *base);
-
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim1_t760_run.c b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim1_t760_run.c
deleted file mode 100644
index 1627fa1ef20e..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim1_t760_run.c
+++ /dev/null
@@ -1,417 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-* The confidential and proprietary information contained in this file may
-* only be used by a person authorised under and to the extent permitted
-* by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-* This entire notice must be reproduced on all copies of this file
-* and copies of this file may only be made by a person if such person is
-* permitted to do so under the terms of a subsisting license agreement
-* from ARM Limited.
-*
-* Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-* Revision  : $Revision: 66689 $
-* Release   : $State: $
-*-----------------------------------------------------------------------------*/
-
-/* 
-
-BRIEF DESCRIPTION, PURPOSE AND STRATEGY
-=======================================
-
-This test tests that most GPU registers can be read and written via the APB interface.
-
-
-
-DEBUG HINTS IN CASE OF FAILURE
-===========================
-a) Check the APB bus connections as this is the bus that is used to communicate with the Job manager.
-b) Check that the GPU's reset signal is not asserted.
-c) Check that the GPU input clock is toggling as expected.
-d) Check that the DFT signals are disabled.
-e) Check that MBIST is disabled.
-
-*/
-
-#include "MaliFns.h"
-#include "MaliDefines-t760.h"
-
-
-
-int RunMaliTest_sim1_t760_part0 ();
-static int Mali_test_reg(int unit, int core, int regnum, int read_mask, int write_mask, int reset_value, int access, char * reg_str);
-
-int log2_of_x (int myval);
-
-static int mali_step;
-
-
-int RunMaliTest_sim1_t760 (int *base) {
-
-	Mali_SetBase(base);
-    RunMaliTest_sim1_t760_part0();
- 
-};
-
-#define printf printk
-
-int RunMaliTest_sim1_t760_part0 () {
-  int res = 0;		
-  int gpuid, num_cores, l2_size, axi_width, i, as_present, js_present, core_bitmap, vTEXTURE_FEATURES_0;
-
-
-  printf("RUNNING TEST: sim1\n");
-  printf("  Purpose: Check APB register accesses\n");
-  printf("  Will check register read/write and reset value\n");
-
-  // Get current configuration to allow testing all registers
-  gpuid         = Mali_RdReg(0x20, 0, 0x0000);
-  core_bitmap   = Mali_RdReg(0x20, 0, 0x0100);
-  l2_size       = ((Mali_RdReg(0x20, 0, 0x0004) >> 16) & 0xFF);
-  axi_width     = (1 <<((Mali_RdReg(0x20, 0, 0x0004) >> 24) & 0xFF));
-  as_present    = Mali_RdReg(0x20, 0, 0x0018);
-  js_present    = Mali_RdReg(0x20, 0, 0x001c);
-  vTEXTURE_FEATURES_0 = Mali_RdReg(0x20, 0, 0x00b0);
-
-  i = core_bitmap;
-  num_cores = 0;
-  while(i) {
-    num_cores++;
-    i >>= 1;
-  }
-  printf("Selected configuration:\n");
-  printf("  Bus width: %d\n", axi_width);
-  printf("  Number of shader cores: %d\n", num_cores);
-  printf("  L2 cache size: %d kB\n", ((1<<l2_size)/1024));
-
-  printf("Reading/Writing GPU Configuration and Control registers:\n");
-  res |= Mali_test_reg (0, 0, 0x000, 0xffff0000, 0xffff0000, GPU_ID_VALUE, 1, "GPU_ID"); 
-  res |= Mali_test_reg (0, 0, 0x004, 0xffffffff, 0xffffffff, (0x00000206 + (l2_size << 16) | (log2_of_x(axi_width) << 24)), 1, "L2_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x008, 0xffffffff, 0xffffffff, 0x00000000, 1, "L3_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x00c, 0xffffffff, 0xffffffff, 0x00000809, 1, "TILER_FEATURES"); 
-#if MALI == t760
-  /*
-   Skrymir has a new field 
-    MEM_FEATURES[11:8] = L2_SLICES 
-  */
-  res |= Mali_test_reg (0, 0, 0x010, 0xffffffff, 0xffffffff, 0x00000101, 1, "MEM_FEATURES"); 
-#else
-  res |= Mali_test_reg (0, 0, 0x010, 0xffffffff, 0xffffffff, 0x00000001, 1, "MEM_FEATURES"); 
-#endif
-
-  res |= Mali_test_reg (0, 0, 0x014, 0xffffffff, 0xffffffff, 0x00002830, 1, "MMU_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x018, 0xffffffff, 0xffffffff, as_present, 1, "AS_PRESENT"); 
-  res |= Mali_test_reg (0, 0, 0x01c, 0xffffffff, 0xffffffff, js_present, 1, "JS_PRESENT"); 
-  /* GPU config regs */
-
-   res |= Mali_test_reg(0, 0, 0x020, 0xffffffff, 0xffffffff, 0x00000100, 1, "GPU_IRQ_RAWSTAT");
-   res |= Mali_test_reg(0, 0, 0x028, 0xffffffff, 0xffffffff, 0x00000000, 1, "GPU_IRQ_MASK");
-   res |= Mali_test_reg(0, 0, 0x02c, 0xffffffff, 0xffffffff, 0x00000000, 1, "GPU_IRQ_STATUS");
-
-  /* Job Control */
-
-   res |= Mali_test_reg(0, 0, 0x1000, 0xffffffff, 0xffffffff, 0x00000000, 1, "JOB_IRQ_RAWSTAT");
-   res |= Mali_test_reg(0, 0, 0x1008, 0xffffffff, 0xffffffff, 0x00000000, 1, "JOB_IRQ_MASK");
-   res |= Mali_test_reg(0, 0, 0x100c, 0xffffffff, 0xffffffff, 0x00000000, 1, "JOB_IRQ_STATUS");
-
-  /* MMU regs */
-
-  res |= Mali_test_reg(0, 0, 0x2000, 0xffffffff, 0xffffffff, 0x00000000, 1, "MMU_IRQ_RAWSTAT");
-  res |= Mali_test_reg(0, 0, 0x2008, 0xffffffff, 0xffffffff, 0x00000000, 1, "MMU_IRQ_MASK");
-  res |= Mali_test_reg(0, 0, 0x200c, 0xffffffff, 0xffffffff, 0x00000000, 1, "MMU_IRQ_STATUS");
-  
-  /*  res |= Mali_test_reg(0, 0, 0x030, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* GPU_COMMAND */ /* Write only */
-  res |= Mali_test_reg (0, 0, 0x034, 0xffffffff, 0xffffffff, 0x00000000, 1, "GPU_STATUS"); 
-  /*  res |= Mali_test_reg(0, 0, 0x038, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x03c, 0xffffffff, 0xffffffff, 0x00000000, 1, "GPU_FAULTSTATUS"); 
-  res |= Mali_test_reg (0, 0, 0x040, 0xffffffff, 0xffffffff, 0x00000000, 1, "GPU_FAULTADDRESS_LO"); 
-  res |= Mali_test_reg (0, 0, 0x044, 0xffffffff, 0xffffffff, 0x00000000, 1, "GPU_FAULTADDRESS_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x048, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x04c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x050, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* PWR_KEY */ /* Write only */
-  /*  res |= Mali_test_reg(0, 0, 0x054, 0xffffffff, 0xffffffff, 0x00000000, 0); */ /* PWR_OVERRIDE0 */ /* Need PWR_KEY to work */
-  /*  res |= Mali_test_reg(0, 0, 0x058, 0xffffffff, 0xffffffff, 0x00000000, 0); */ /* PWR_OVERRIDE1 */ /* Need PWR_KEY to work */ 
-  /*  res |= Mali_test_reg(0, 0, 0x05c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x060, 0xffffffff, 0xfffff800, 0x00000000, 0, "PRFCNT_BASE_LO"); 
-  res |= Mali_test_reg (0, 0, 0x064, 0xffffffff, 0x0000ffff, 0x00000000, 0, "PRFCNT_BASE_HI"); 
-  res |= Mali_test_reg (0, 0, 0x068, 0xffffffff, 0x000000ff, 0x00000000, 0, "PRFCNT_CONFIG"); 
-  res |= Mali_test_reg (0, 0, 0x06c, 0xffffffff, 0x000000ff, 0x00000000, 0, "PRFCNT_JM_EN"); 
-  res |= Mali_test_reg (0, 0, 0x070, 0xffffffff, 0x0000ffff, 0x00000000, 0, "PRFCNT_SHADER_EN"); 
-  res |= Mali_test_reg (0, 0, 0x074, 0xffffffff, 0x0000ffff, 0x00000000, 0, "PRFCNT_TILER_EN"); 
-  res |= Mali_test_reg (0, 0, 0x078, 0xffffffff, 0xffffffff, 0x00000000, 1, "PRFCNT_L3_CACHE_EN"); 
-  res |= Mali_test_reg (0, 0, 0x07c, 0xffffffff, 0x0000ffff, 0x00000000, 0, "PRFCNT_MMU_L2_EN"); 
-  /*  res |= Mali_test_reg(0, 0, 0x080, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x084, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x088, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x08c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x090, 0xffffffff, 0xffffffff, 0x00000000, 1, "CYCLE_COUNT_LO"); 
-  res |= Mali_test_reg (0, 0, 0x094, 0xffffffff, 0xffffffff, 0x00000000, 1, "CYCLE_COUNT_HI"); 
-  res |= Mali_test_reg (0, 0, 0x098, 0xffffffff, 0xffffffff, 0x00000000, 1, "TIMESTAMP_LO"); 
-  res |= Mali_test_reg (0, 0, 0x09c, 0xffffffff, 0xffffffff, 0x00000000, 1, "TIMESTAMP_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x0a0, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x0a4, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x0a8, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x0ac, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-
-  /* printf ("TEXTURE_FEATURES_0 is set to 0x%08x", Mali_RdReg(0x20, 0, 0x00b0)); */
-  printf ("                         \n");
-  printf ("                        Texture Compression Formats::\n");
-  printf ("                        TEXTURE_FEATURES_0 = 0x%08x\n"   , vTEXTURE_FEATURES_0);
-  printf ("                         \n");
-  printf ("                        ETC2=%d\n"                       , ((vTEXTURE_FEATURES_0>> 1)&0x00000001)                                        ); 
-  printf ("                        ETC2+EAC=%d\n"                   , ((vTEXTURE_FEATURES_0>> 3)&0x00000001)                                        );
-  printf ("                        EAC_1_COMPONENT=%d\n"            , ((vTEXTURE_FEATURES_0>> 2)&0x00000001)                                        );
-  printf ("                        EAC_2_COMPONENTS=%d\n"           , ((vTEXTURE_FEATURES_0>> 4)&0x00000001)                                        );
-  printf ("                        EAC_SNORM_1_COMPONENT=%d\n"      , ((vTEXTURE_FEATURES_0>>17)&0x00000001)                                        );
-  printf ("                        EAC_SNORM_2_COMPONENTS=%d\n"     , ((vTEXTURE_FEATURES_0>>18)&0x00000001)                                        );
-  printf ("                        ETC2+Punch-Through Alpha=%d\n"   , ((vTEXTURE_FEATURES_0>>19)&0x00000001)                                        );
-  printf ("                         \n");
-  printf ("                        NXR=%d\n"                        , ((vTEXTURE_FEATURES_0>> 6)&0x00000001)                                        );
-  printf ("                         \n");
-  printf ("                        BC1_UNORM=%d\n"                  , ((vTEXTURE_FEATURES_0>> 7)&0x00000001)                                        );
-  printf ("                        BC2_UNORM=%d\n"                  , ((vTEXTURE_FEATURES_0>> 8)&0x00000001)                                        );
-  printf ("                        BC3_UNORM=%d\n"                  , ((vTEXTURE_FEATURES_0>> 9)&0x00000001)                                        );
-  printf ("                        BC4_UNORM=%d BC4_SNORM=%d\n"     , ((vTEXTURE_FEATURES_0>>10)&0x00000001), ((vTEXTURE_FEATURES_0>>11)&0x00000001)); 
-  printf ("                        BC5_UNORM=%d BC5_SNORM=%d\n"     , ((vTEXTURE_FEATURES_0>>12)&0x00000001), ((vTEXTURE_FEATURES_0>>13)&0x00000001)); 
-  printf ("                        BC6H_UF16=%d BC6H_SF16=%d\n"     , ((vTEXTURE_FEATURES_0>>14)&0x00000001), ((vTEXTURE_FEATURES_0>>15)&0x00000001)); 
-  printf ("                        BC7_UNORM=%d\n"                  , ((vTEXTURE_FEATURES_0>>16)&0x00000001)                                        ); 
-  printf ("                         \n");
-  printf ("                        ASTC_3D_LDR=%d ASTC_3D_HDR=%d\n" , ((vTEXTURE_FEATURES_0>>20)&0x00000001), ((vTEXTURE_FEATURES_0>>21)&0x00000001)); 
-  printf ("                        ASTC_2D_LDR=%d ASTC_2D_HDR=%d\n" , ((vTEXTURE_FEATURES_0>>22)&0x00000001), ((vTEXTURE_FEATURES_0>>23)&0x00000001)); 
-  printf ("                         \n");
-  res |= Mali_test_reg (0, 0, 0x0b4, 0xffffffff, 0xffffffff, 0x0000ffff, 1, "TEXTURE_FEATURES_1"); 
-  res |= Mali_test_reg (0, 0, 0x0b8, 0xffffffff, 0xffffffff, 0x9f81ffff, 1, "TEXTURE_FEATURES_2"); 
-  /*  res |= Mali_test_reg(0, 0, 0x0bc, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x0c0, 0xffffffff, 0xffffffff, 0x0000020e, 1, "JS0_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0c4, 0xffffffff, 0xffffffff, 0x000001fe, 1, "JS1_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0c8, 0xffffffff, 0xffffffff, 0x0000007e, 1, "JS2_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0cc, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS3_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0d0, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS4_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0d4, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS5_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0d8, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS6_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0dc, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS7_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0e0, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS8_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0e4, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS9_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0e8, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS10_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0ec, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS11_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0f0, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS12_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0f4, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS13_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0f8, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS14_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x0fc, 0xffffffff, 0xffffffff, 0x00000000, 1, "JS15_FEATURES"); 
-  res |= Mali_test_reg (0, 0, 0x100, 0xffffffff, 0xffffffff,  core_bitmap, 1, "SHADER_PRESENT_LO"); 
-  res |= Mali_test_reg (0, 0, 0x104, 0xffffffff, 0xffffffff, 0x00000000, 1, "SHADER_PRESENT_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x108, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x10c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x110, 0xffffffff, 0xffffffff, 0x00000001, 1, "TILER_PRESENT_LO"); 
-  res |= Mali_test_reg (0, 0, 0x114, 0xffffffff, 0xffffffff, 0x00000000, 1, "TILER_PRESENT_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x118, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x11c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-
-#if MALI == t760
-  /* T760 has only one logical L2C */
-  res |= Mali_test_reg (0, 0, 0x120, 0xffffffff, 0xffffffff, 0x00000001, 1, "L2_PRESENT_LO"); 
-#else
-  if (num_cores>=6)
-  { /* T608 MP6 and T608 MP8 have two L2Cs*/
-    res |= Mali_test_reg (0, 0, 0x120, 0xffffffff, 0xffffffff, 0x00000011, 1, "L2_PRESENT_LO"); 
-  }
-  else
-  {
-    res |= Mali_test_reg (0, 0, 0x120, 0xffffffff, 0xffffffff, 0x00000001, 1, "L2_PRESENT_LO"); 
-  }
-#endif
-  res |= Mali_test_reg (0, 0, 0x124, 0xffffffff, 0xffffffff, 0x00000000, 1, "L2_PRESENT_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x128, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x12c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x130, 0xffffffff, 0xffffffff, 0x00000000, 1, "L3_PRESENT_LO"); 
-  res |= Mali_test_reg (0, 0, 0x134, 0xffffffff, 0xffffffff, 0x00000000, 1, "L3_PRESENT_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x138, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x13c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x140, 0xffffffff, 0xffffffff, 0x00000000, 1, "SHADER_READY_LO"); 
-  res |= Mali_test_reg (0, 0, 0x144, 0xffffffff, 0xffffffff, 0x00000000, 1, "SHADER_READY_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x148, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x14c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x150, 0xffffffff, 0xffffffff, 0x00000000, 1, "TILER_READY_LO"); 
-  res |= Mali_test_reg (0, 0, 0x154, 0xffffffff, 0xffffffff, 0x00000000, 1, "TILER_READY_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x158, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x15c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x160, 0xffffffff, 0xffffffff, 0x00000000, 1, "L2_READY_LO"); 
-  res |= Mali_test_reg (0, 0, 0x164, 0xffffffff, 0xffffffff, 0x00000000, 1, "L2_READY_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x168, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x16c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x170, 0xffffffff, 0xffffffff, 0x00000000, 1, "L3_READY_LO"); 
-  res |= Mali_test_reg (0, 0, 0x174, 0xffffffff, 0xffffffff, 0x00000000, 1, "L3_READY_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x178, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x17c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x180, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* SHADER_PWRON_LO */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x184, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* SHADER_PWRON_HI */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x188, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x18c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x190, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* TILER_PWRON_LO */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x194, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* TILER_PWRON_HI */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x198, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x19c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1a0, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* L2_PWRON_LO */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1a4, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* L2_PWRON_HI */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1a8, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1ac, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1b0, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* L3_PWRON_LO */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1b4, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* L3_PWRON_HI */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1b8, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1bc, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1c0, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* SHADER_PWROFF_LO */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1c4, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* SHADER_PWROFF_HI */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1c8, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1cc, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1d0, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* TILER_PWROFF_LO */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1d4, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* TILER_PWROFF_HI */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1d8, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1dc, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1e0, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* L2_PWROFF_LO */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1e4, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* L2_PWROFF_HI */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1e8, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1ec, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1f0, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* L3_PWROFF_LO */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1f4, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* L3_PWROFF_HI */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1f8, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x1fc, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x200, 0xffffffff, 0xffffffff, 0x00000000, 1, "SHADER_PWRTRANS_LO"); 
-  res |= Mali_test_reg (0, 0, 0x204, 0xffffffff, 0xffffffff, 0x00000000, 1, "SHADER_PWRTRANS_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x208, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x20c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x210, 0xffffffff, 0xffffffff, 0x00000000, 1, "TILER_PWRTRANS_LO"); 
-  res |= Mali_test_reg (0, 0, 0x214, 0xffffffff, 0xffffffff, 0x00000000, 1, "TILER_PWRTRANS_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x218, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x21c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x220, 0xffffffff, 0xffffffff, 0x00000000, 1, "L2_PWRTRANS_LO"); 
-  res |= Mali_test_reg (0, 0, 0x224, 0xffffffff, 0xffffffff, 0x00000000, 1, "L2_PWRTRANS_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x228, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x22c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x230, 0xffffffff, 0xffffffff, 0x00000000, 1, "L3_PWRTRANS_LO"); 
-  res |= Mali_test_reg (0, 0, 0x234, 0xffffffff, 0xffffffff, 0x00000000, 1, "L3_PWRTRANS_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x238, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x23c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x240, 0xffffffff, 0xffffffff, 0x00000000, 1, "SHADER_PWRACTIVE_LO"); 
-  res |= Mali_test_reg (0, 0, 0x244, 0xffffffff, 0xffffffff, 0x00000000, 1, "SHADER_PWRACTIVE_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x248, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x24c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x250, 0xffffffff, 0xffffffff, 0x00000000, 1, "TILER_PWRACTIVE_LO"); 
-  res |= Mali_test_reg (0, 0, 0x254, 0xffffffff, 0xffffffff, 0x00000000, 1, "TILER_PWRACTIVE_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x258, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x25c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x260, 0xffffffff, 0xffffffff, 0x00000000, 1, "L2_PWRACTIVE_LO"); 
-  res |= Mali_test_reg (0, 0, 0x264, 0xffffffff, 0xffffffff, 0x00000000, 1, "L2_PWRACTIVE_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x268, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x26c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  res |= Mali_test_reg (0, 0, 0x270, 0xffffffff, 0xffffffff, 0x00000000, 1, "L3_PWRACTIVE_LO"); 
-  res |= Mali_test_reg (0, 0, 0x274, 0xffffffff, 0xffffffff, 0x00000000, 1, "L3_PWRACTIVE_HI"); 
-  /*  res |= Mali_test_reg(0, 0, 0x278, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-  /*  res |= Mali_test_reg(0, 0, 0x27c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-
-  printf("Reading/Writing JOB Configuration and Control registers:\n");
-  /*  res |= Mali_test_reg(0, 0, 0x1000, 0xffffffff, 0xffffffff, 0x00000000, 0); */ /* JOB_IRQ_RAWSTAT */
-  /*  res |= Mali_test_reg(0, 0, 0x1004, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* JOB_IRQ_CLEAR */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x1008, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* JOB_IRQ_MASK */
-  /*  res |= Mali_test_reg(0, 0, 0x100c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* JOB_IRQ_STATUS */
-  for(i=0;i<16;i++) {
-    if( ((js_present >> i) & 1) ) {
-      res |= Mali_test_reg (0, 0, 0x1800 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1, "JSx_HEAD_LO"); 
-      res |= Mali_test_reg (0, 0, 0x1804 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1, "JSx_HEAD_HI"); 
-      res |= Mali_test_reg (0, 0, 0x1808 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1, "JSx_TAIL_LO"); 
-      res |= Mali_test_reg (0, 0, 0x180c + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1, "JSx_TAIL_HI"); 
-      res |= Mali_test_reg (0, 0, 0x1810 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1, "JSx_AFFINITY_LO"); 
-      res |= Mali_test_reg (0, 0, 0x1814 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1, "JSx_AFFINITY_HI"); 
-      res |= Mali_test_reg (0, 0, 0x1818 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1, "JSx_CONFIG"); 
-      /*  res |= Mali_test_reg(0, 0, 0x181c + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      /*  res |= Mali_test_reg(0, 0, 0x1820 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* JSx_COMMAND */ /* Write Only */
-      res |= Mali_test_reg (0, 0, 0x1824 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1, "JSx_STATUS"); 
-      /*  res |= Mali_test_reg(0, 0, 0x1828 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      /*  res |= Mali_test_reg(0, 0, 0x182c + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      /*  res |= Mali_test_reg(0, 0, 0x1830 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      /*  res |= Mali_test_reg(0, 0, 0x1834 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      /*  res |= Mali_test_reg(0, 0, 0x1838 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      /*  res |= Mali_test_reg(0, 0, 0x183c + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      res |= Mali_test_reg (0, 0, 0x1840 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 0, "JSx_HEAD_NEXT_LO"); 
-      res |= Mali_test_reg (0, 0, 0x1844 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 0, "JSx_HEAD_NEXT_HI"); 
-      /*  res |= Mali_test_reg(0, 0, 0x1848 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      /*  res |= Mali_test_reg(0, 0, 0x184c + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      res |= Mali_test_reg (0, 0, 0x1850 + i*0x80, 0xffffffff, 0x00000001, 0x00000000, 0, "JSx_AFFINITY_NEXT_LO"); 
-      res |= Mali_test_reg (0, 0, 0x1854 + i*0x80, 0xffffffff, 0x00000000, 0x00000000, 0, "JSx_AFFINITY_NEXT_HI"); 
-      res |= Mali_test_reg (0, 0, 0x1858 + i*0x80, 0xffffffff, 0x0000370f, 0x00000000, 0, "JSx_CONFIG_NEXT"); 
-      /*  res |= Mali_test_reg(0, 0, 0x185c + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* Reserved */
-      /*  res |= Mali_test_reg(0, 0, 0x1860 + i*0x80, 0xffffffff, 0xffffffff, 0x00000000, 0); */ /* JSx_COMMAND_NEXT */ /* Write Only? */
-    }
-  }
-
-  printf("Reading/Writing MMU Configuration and Control registers:\n");
-  /*  res |= Mali_test_reg(0, 0, 0x2000, 0xffffffff, 0xffffffff, 0x00000000, 0); */ /* MMU_IRQ_RAWSTAT */
-  /*  res |= Mali_test_reg(0, 0, 0x2004, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* MMU_IRQ_CLEAR */ /* Write Only */
-  /*  res |= Mali_test_reg(0, 0, 0x2008, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* MMU_IRQ_MASK */
-  /*  res |= Mali_test_reg(0, 0, 0x200c, 0xffffffff, 0xffffffff, 0x00000000, 1); */ /* MMU_IRQ_STATUS */
-  for(i=0;i<16;i++) {
-    if( ((as_present >> i) & 1) ) {
-      res |= Mali_test_reg (0, 0, 0x2400 + i*0x40, 0xffffffff, 0xfffff01f, 0x00000000, 0, "ASx_TRANSTAB_LO"); 
-      res |= Mali_test_reg (0, 0, 0x2404 + i*0x40, 0xffffffff, 0x000000ff, 0x00000000, 0, "ASx_TRANSTAB_HI"); 
-      res |= Mali_test_reg (0, 0, 0x2408 + i*0x40, 0xffffffff, 0xcfcfcfcf, 0x00000000, 0, "ASx_MEMATTR_LO"); 
-      res |= Mali_test_reg (0, 0, 0x240c + i*0x40, 0xffffffff, 0xcfcfcfcf, 0x00000000, 0, "ASx_MEMATTR_HI"); 
-      res |= Mali_test_reg (0, 0, 0x2410 + i*0x40, 0xffffffff, 0xfffff03f, 0x00000000, 0, "ASx_LOCKADDR_LO"); 
-      res |= Mali_test_reg (0, 0, 0x2414 + i*0x40, 0xffffffff, 0x0000ffff, 0x00000000, 0, "ASx_LOCKADDR_HI"); 
-      /*    res |= Mali_test_reg(0, 0, 0x2418 + i*0x40, 0xffffffff, 0xffffffff, 0x00000000, 0); */ /* ASx_COMMAND */ /* Write Only */
-      res |= Mali_test_reg (0, 0, 0x241c + i*0x40, 0xffffffff, 0xffffffff, 0x00000000, 1, "ASx_FAULTSTATUS"); 
-      res |= Mali_test_reg (0, 0, 0x2420 + i*0x40, 0xffffffff, 0xffffffff, 0x00000000, 1, "ASx_FAULTADDRESS_LO"); 
-      res |= Mali_test_reg (0, 0, 0x2424 + i*0x40, 0xffffffff, 0xffffffff, 0x00000000, 1, "ASx_FAULTADDRESS_HI"); 
-      res |= Mali_test_reg (0, 0, 0x2428 + i*0x40, 0xffffffff, 0xffffffff, 0x00000000, 1, "ASx_STATUS"); 
-    }
-  }
-  mali_step++;
-  return res;
-}
-
-
-/* Mali_test_reg
-   Test the register.
-   access: 0=RW, 1=RO
-*/
-static int Mali_test_reg(int unit, int core, int regnum, int read_mask, int write_mask, int reset_value, int access, char * reg_str) {
-  int value = Mali_RdReg(unit, core, regnum);
-  if( value != reset_value ) {
-    printf("FAILURE: Wrong reset value. Addr: 0x%08x Value: 0x%08x Expected: 0x%08x for %s\n",
-           (unit<<28)+(core<<16)+regnum, value, reset_value, reg_str);
-    return -1;
-  }
-  if( access == 0 ) {
-    Mali_WrReg(unit, core, regnum, (0xffffffff & write_mask));
-    value = Mali_RdReg(unit, core, regnum) & read_mask;
-    if( value != (0xffffffff & write_mask & read_mask) ) {
-      printf("FAILURE: Wrong value. Addr: 0x%08x Value: 0x%08x Expected: 0x%08x for %s\n",
-             (unit<<28)+(core<<16)+regnum, value, (0xffffffff & write_mask & read_mask), reg_str);
-      return -2;
-    }
-    Mali_WrReg(unit, core, regnum, (0x12345678 & write_mask));
-    value = Mali_RdReg(unit, core, regnum) & read_mask;
-    if( value != (0x12345678 & write_mask & read_mask) ) {
-      printf("FAILURE: Wrong value. Addr: 0x%08x Value: 0x%08x Expected: 0x%08x for %s\n",
-             (unit<<28)+(core<<16)+regnum, value, (0x12345678 & write_mask & read_mask), reg_str);
-      return -2;
-    }
-  }
-  printf("Register %08x:  for %s  Success!\n", (unit<<28)+(core<<16)+regnum, reg_str);
-  return 0;
-}
-
-#undef printf
-
-
-int log2_of_x (int myval) {
-  int myresult = 0;
-  while (myval > 1)
-  {
-    myval >>= 1;
-    myresult++;
-  }
-  
-  return myresult;
-}
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim2_t760_run.c b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim2_t760_run.c
deleted file mode 100644
index 3a2a578467c4..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim2_t760_run.c
+++ /dev/null
@@ -1,193 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-* The confidential and proprietary information contained in this file may
-* only be used by a person authorised under and to the extent permitted
-* by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-* This entire notice must be reproduced on all copies of this file
-* and copies of this file may only be made by a person if such person is
-* permitted to do so under the terms of a subsisting license agreement
-* from ARM Limited.
-*
-* Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-* Revision  : $Revision: 66689 $
-* Release   : $State: $
-*-----------------------------------------------------------------------------*/
-
-/* 
-
-BRIEF DESCRIPTION, PURPOSE AND STRATEGY
-=======================================
-
-This test checks that the interrupts are correctly connected by directly writing to their RAW status registers.
-
-
-DEBUG HINTS IN CASE OF FAILURE
-===========================
-a) Check the APB bus connections as this is the bus that is used to communicate with the Job manager.
-b) Check that the GPU's reset signal is not asserted.
-c) Check that the GPU input clock is toggling as expected.
-d) Check that the DFT signals are disabled.
-e) Check that MBIST is disabled.
-f) Check the GPU interrupt signals are connected correctly i.e. IRQGPU, IRQMMU and IRQJOB.
-
-*/
-
-#include "MaliFns.h"
-#include "MaliDefines-t760.h"
-
-
-int RunMaliTest_sim2_t760_part0 (void);
-int RunMaliTest_sim2_t760_part1 (void);
-int RunMaliTest_sim2_t760_part2 (void);
-int RunMaliTest_sim2_t760_part3 (void);
-
-static int mali_step;
-
-int RunMaliTest_sim2_t760 (int *base) {
-  	Mali_SetBase(base);
-  	
-	RunMaliTest_sim2_t760_part0();
-    RunMaliTest_sim2_t760_part1();
-    RunMaliTest_sim2_t760_part2();
-    RunMaliTest_sim2_t760_part3();
-
-    return 0;
-};
-
-#define printf printk
-int RunMaliTest_sim2_t760_part0 (void) {
-  int res = 0;
-
-  int gpuid, num_cores, l2_size, axi_width, i, as_present, js_present, core_bitmap;
-
-  printf("RUNNING TEST: sim2\n");
-  printf("  Purpose: Check interrupt line connectivity\n");
-  printf("  Will assert all three interrupt signals sequentially.\n");
-
-  // Get current configuration to allow testing all registers
-  gpuid         = Mali_RdReg(0x20, 0, 0x0000);
-  core_bitmap   = Mali_RdReg(0x20, 0, 0x0100);
-  l2_size       = ((Mali_RdReg(0x20, 0, 0x0004) >> 16) & 0xFF);
-  axi_width     = (1 <<((Mali_RdReg(0x20, 0, 0x0004) >> 24) & 0xFF));
-  as_present    = Mali_RdReg(0x20, 0, 0x0018);
-  js_present    = Mali_RdReg(0x20, 0, 0x001c);
-
-  i = core_bitmap;
-  num_cores = 0;
-  while(i) {
-    num_cores++;
-    i >>= 1;
-  }
-  printf("Selected configuration:\n");
-  printf("  Bus width: %d\n", axi_width);
-  printf("  Number of shader cores: %d\n", num_cores);
-  printf("  L2 cache size: %d kB\n", ((1<<l2_size)/1024));
-
-  // Clear all interrupt registers
-  Mali_WrReg(0x20,0x0,0x0024,0xFFFFFFFF); // GPU_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x1004,0xFFFFFFFF); // JOB_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x2004,0xFFFFFFFF); // MMU_IRQ_CLEAR
-
-  // Enable GPU interrupt source, disable all other interrupt sources
-  Mali_WrReg(0x20,0x0,0x0028,0x00000001); // GPU_IRQ_MASK
-  Mali_WrReg(0x20,0x0,0x1008,0x00000000); // JOB_IRQ_MASK
-  Mali_WrReg(0x20,0x0,0x2008,0x00000000); // MMU_IRQ_MASK
-
-  // Trigger GPU interrupt
-  Mali_WrReg(0x20,0x0,0x0020,0x00000001); // GPU_IRQ_RAWSTAT
-
-  mali_step++;
-  if (res == 0) {
-   return 255;
-  }
-  return res;
-}
-
-int RunMaliTest_sim2_t760_part1 (void) {
-  int res = 0;
-  int gpu_irq_status, job_irq_status, mmu_irq_status;
-  gpu_irq_status = Mali_RdReg(0x20,0x0,0x002c);
-  job_irq_status = Mali_RdReg(0x20,0x0,0x100c);
-  mmu_irq_status = Mali_RdReg(0x20,0x0,0x200c);
-  if( (gpu_irq_status == 1) && (job_irq_status == 0) && (mmu_irq_status == 0) ) {
-    printf("GPU Interrupt asserted\n");
-    Mali_WrReg(0x20,0x0,0x0024,0xFFFFFFFF); // GPU_IRQ_CLEAR
-    Mali_WrReg(0x20,0x0,0x0028,0x00000000); // GPU_IRQ_MASK
-    Mali_WrReg(0x20,0x0,0x1008,0x00000001); // JOB_IRQ_MASK
-    Mali_WrReg(0x20,0x0,0x1000,0x00000001); // JOB_IRQ_RAWSTAT
-    Mali_WrReg(0x20,0x0,0x0020,0x00000000); // GPU_IRQ_RAWSTAT
-    mali_step++;
-    return 255;
-  }
-  printf("FAILURE: Expected GPU interrupt. Got the following interrupts: GPU: %x  JOB: %x  MMU: %x\n",
-         gpu_irq_status, job_irq_status, mmu_irq_status);
-  Mali_WrReg(0x20,0x0,0x0024,0xFFFFFFFF); // GPU_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x1004,0xFFFFFFFF); // JOB_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x2004,0xFFFFFFFF); // MMU_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x0028,0x00000000); // GPU_IRQ_MASK
-  Mali_WrReg(0x20,0x0,0x1008,0x00000000); // JOB_IRQ_MASK
-  Mali_WrReg(0x20,0x0,0x2008,0x00000000); // MMU_IRQ_MASK
-  return 1;
-}
-
-int RunMaliTest_sim2_t760_part2 (void) {
-  int res = 0;
-  int gpu_irq_status, job_irq_status, mmu_irq_status;
-  gpu_irq_status = Mali_RdReg(0x20,0x0,0x002c);
-  job_irq_status = Mali_RdReg(0x20,0x0,0x100c);
-  mmu_irq_status = Mali_RdReg(0x20,0x0,0x200c);
-  if( (gpu_irq_status == 0) && (job_irq_status == 1) && (mmu_irq_status == 0) ) {
-    printf("JOB Interrupt asserted\n");
-    Mali_WrReg(0x20,0x0,0x1004,0xFFFFFFFF); // JOB_IRQ_CLEAR
-    Mali_WrReg(0x20,0x0,0x1008,0x00000000); // JOB_IRQ_MASK
-    Mali_WrReg(0x20,0x0,0x2008,0x00000001); // MMU_IRQ_MASK
-    Mali_WrReg(0x20,0x0,0x2000,0x00000001); // MMU_IRQ_RAWSTAT
-    Mali_WrReg(0x20,0x0,0x1000,0x00000000); // JOB_IRQ_RAWSTAT
-    mali_step++;
-    return 255;
-  }
-  printf("FAILURE: Expected JOB interrupt. Got the following interrupts: GPU: %x  JOB: %x  MMU: %x\n",
-         gpu_irq_status, job_irq_status, mmu_irq_status);
-  Mali_WrReg(0x20,0x0,0x0024,0xFFFFFFFF); // GPU_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x1004,0xFFFFFFFF); // JOB_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x2004,0xFFFFFFFF); // MMU_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x0028,0x00000000); // GPU_IRQ_MASK
-  Mali_WrReg(0x20,0x0,0x1008,0x00000000); // JOB_IRQ_MASK
-  Mali_WrReg(0x20,0x0,0x2008,0x00000000); // MMU_IRQ_MASK
-  return 1;
-}
-
-int RunMaliTest_sim2_t760_part3 (void) {
-  int res = 0;
-  int gpu_irq_status, job_irq_status, mmu_irq_status;
-  gpu_irq_status = Mali_RdReg(0x20,0x0,0x002c);
-  job_irq_status = Mali_RdReg(0x20,0x0,0x100c);
-  mmu_irq_status = Mali_RdReg(0x20,0x0,0x200c);
-  if( (gpu_irq_status == 0) && (job_irq_status == 0) && (mmu_irq_status == 1) ) {
-    printf("MMU Interrupt asserted\n");
-    Mali_WrReg(0x20,0x0,0x0024,0xFFFFFFFF); // GPU_IRQ_CLEAR
-    Mali_WrReg(0x20,0x0,0x1004,0xFFFFFFFF); // JOB_IRQ_CLEAR
-    Mali_WrReg(0x20,0x0,0x2004,0xFFFFFFFF); // MMU_IRQ_CLEAR
-    Mali_WrReg(0x20,0x0,0x0028,0xFFFFFFFF); // GPU_IRQ_MASK
-    Mali_WrReg(0x20,0x0,0x1008,0xFFFFFFFF); // JOB_IRQ_MASK
-    Mali_WrReg(0x20,0x0,0x2008,0xFFFFFFFF); // MMU_IRQ_MASK
-    Mali_WrReg(0x20,0x0,0x2000,0x00000000); // MMU_IRQ_RAWSTAT
-    mali_step++;
-    return 0;
-  }
-  printf("FAILURE: Expected MMU interrupt. Got the following interrupts: GPU: %x  JOB: %x  MMU: %x\n",
-         gpu_irq_status, job_irq_status, mmu_irq_status);
-  Mali_WrReg(0x20,0x0,0x0024,0xFFFFFFFF); // GPU_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x1004,0xFFFFFFFF); // JOB_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x2004,0xFFFFFFFF); // MMU_IRQ_CLEAR
-  Mali_WrReg(0x20,0x0,0x0028,0x00000000); // GPU_IRQ_MASK
-  Mali_WrReg(0x20,0x0,0x1008,0x00000000); // JOB_IRQ_MASK
-  Mali_WrReg(0x20,0x0,0x2008,0x00000000); // MMU_IRQ_MASK
-  return 1;
-}
-#undef printf
-
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_check_0_a.c b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_check_0_a.c
deleted file mode 100644
index e11f51204cfa..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_check_0_a.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-* The confidential and proprietary information contained in this file may
-* only be used by a person authorised under and to the extent permitted
-* by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-* This entire notice must be reproduced on all copies of this file
-* and copies of this file may only be made by a person if such person is
-* permitted to do so under the terms of a subsisting license agreement
-* from ARM Limited.
-*
-* Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-* Revision  : $Revision: 66689 $
-* Release   : $State: $
-*-----------------------------------------------------------------------------*/
-#include "sim3_t760_check_0_a.h"
-struct t_CheckData_sim3_t760_check_0_a CheckData_sim3_t760_check_0_a = {
-/* unsigned int data_00001000[] = */
-{
- 0x00000001,0x00000000,0x00000000,0x00000000 /* 00001000 */
-,0x00000c02,0x00000000,0x00000000,0x1234babe /* 00001010 */
-},
-};
-
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_check_0_a.h b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_check_0_a.h
deleted file mode 100644
index 186c5b228b47..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_check_0_a.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-* The confidential and proprietary information contained in this file may
-* only be used by a person authorised under and to the extent permitted
-* by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-* This entire notice must be reproduced on all copies of this file
-* and copies of this file may only be made by a person if such person is
-* permitted to do so under the terms of a subsisting license agreement
-* from ARM Limited.
-*
-* Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-* Revision  : $Revision: 66689 $
-* Release   : $State: $
-*-----------------------------------------------------------------------------*/
-struct t_CheckData_sim3_t760_check_0_a {
-  unsigned int data_00001000[8];
-};
-extern struct t_CheckData_sim3_t760_check_0_a CheckData_sim3_t760_check_0_a;
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_mem_0.c b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_mem_0.c
deleted file mode 100644
index f78689d7b538..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_mem_0.c
+++ /dev/null
@@ -1,2084 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-* The confidential and proprietary information contained in this file may
-* only be used by a person authorised under and to the extent permitted
-* by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-* This entire notice must be reproduced on all copies of this file
-* and copies of this file may only be made by a person if such person is
-* permitted to do so under the terms of a subsisting license agreement
-* from ARM Limited.
-*
-* Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-* Revision  : $Revision: 66689 $
-* Release   : $State: $
-*-----------------------------------------------------------------------------*/
-#include "sim3_t760_mem_0.h"
-volatile struct t_sim3_t760_mem_0 sim3_t760_mem_0 = {
-/* ###########################
- * PageTable
- * ########################### */
-{
- /* PageTableBase + 0x000000 = */ 
-  (unsigned int **)((char *)sim3_t760_mem_0.ttb + 0x001000 + 3), (unsigned int **)((char *)0) /* Indx = 0 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 1 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 2 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 3 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 4 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 5 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 6 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 7 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 8 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 9 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 10 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 11 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 12 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 13 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 14 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 15 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 16 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 17 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 18 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 19 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 20 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 21 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 22 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 23 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 24 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 25 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 26 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 27 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 28 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 29 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 30 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 31 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 32 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 33 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 34 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 35 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 36 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 37 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 38 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 39 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 40 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 41 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 42 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 43 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 44 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 45 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 46 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 47 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 48 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 49 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 50 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 51 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 52 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 53 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 54 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 55 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 56 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 57 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 58 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 59 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 60 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 61 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 62 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 63 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 64 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 65 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 66 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 67 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 68 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 69 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 70 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 71 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 72 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 73 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 74 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 75 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 76 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 77 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 78 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 79 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 80 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 81 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 82 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 83 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 84 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 85 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 86 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 87 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 88 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 89 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 90 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 91 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 92 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 93 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 94 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 95 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 96 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 97 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 98 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 99 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 100 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 101 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 102 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 103 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 104 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 105 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 106 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 107 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 108 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 109 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 110 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 111 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 112 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 113 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 114 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 115 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 116 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 117 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 118 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 119 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 120 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 121 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 122 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 123 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 124 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 125 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 126 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 127 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 128 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 129 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 130 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 131 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 132 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 133 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 134 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 135 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 136 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 137 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 138 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 139 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 140 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 141 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 142 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 143 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 144 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 145 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 146 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 147 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 148 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 149 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 150 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 151 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 152 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 153 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 154 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 155 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 156 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 157 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 158 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 159 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 160 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 161 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 162 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 163 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 164 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 165 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 166 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 167 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 168 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 169 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 170 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 171 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 172 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 173 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 174 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 175 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 176 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 177 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 178 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 179 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 180 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 181 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 182 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 183 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 184 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 185 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 186 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 187 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 188 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 189 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 190 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 191 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 192 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 193 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 194 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 195 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 196 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 197 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 198 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 199 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 200 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 201 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 202 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 203 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 204 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 205 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 206 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 207 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 208 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 209 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 210 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 211 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 212 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 213 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 214 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 215 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 216 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 217 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 218 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 219 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 220 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 221 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 222 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 223 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 224 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 225 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 226 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 227 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 228 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 229 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 230 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 231 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 232 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 233 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 234 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 235 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 236 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 237 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 238 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 239 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 240 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 241 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 242 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 243 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 244 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 245 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 246 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 247 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 248 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 249 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 250 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 251 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 252 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 253 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 254 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 255 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 256 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 257 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 258 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 259 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 260 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 261 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 262 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 263 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 264 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 265 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 266 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 267 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 268 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 269 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 270 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 271 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 272 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 273 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 274 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 275 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 276 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 277 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 278 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 279 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 280 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 281 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 282 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 283 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 284 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 285 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 286 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 287 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 288 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 289 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 290 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 291 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 292 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 293 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 294 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 295 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 296 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 297 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 298 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 299 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 300 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 301 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 302 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 303 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 304 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 305 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 306 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 307 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 308 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 309 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 310 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 311 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 312 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 313 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 314 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 315 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 316 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 317 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 318 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 319 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 320 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 321 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 322 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 323 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 324 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 325 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 326 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 327 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 328 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 329 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 330 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 331 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 332 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 333 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 334 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 335 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 336 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 337 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 338 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 339 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 340 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 341 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 342 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 343 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 344 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 345 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 346 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 347 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 348 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 349 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 350 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 351 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 352 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 353 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 354 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 355 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 356 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 357 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 358 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 359 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 360 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 361 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 362 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 363 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 364 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 365 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 366 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 367 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 368 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 369 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 370 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 371 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 372 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 373 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 374 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 375 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 376 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 377 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 378 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 379 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 380 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 381 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 382 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 383 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 384 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 385 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 386 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 387 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 388 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 389 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 390 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 391 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 392 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 393 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 394 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 395 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 396 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 397 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 398 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 399 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 400 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 401 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 402 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 403 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 404 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 405 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 406 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 407 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 408 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 409 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 410 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 411 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 412 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 413 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 414 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 415 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 416 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 417 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 418 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 419 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 420 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 421 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 422 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 423 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 424 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 425 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 426 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 427 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 428 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 429 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 430 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 431 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 432 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 433 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 434 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 435 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 436 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 437 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 438 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 439 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 440 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 441 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 442 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 443 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 444 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 445 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 446 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 447 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 448 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 449 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 450 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 451 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 452 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 453 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 454 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 455 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 456 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 457 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 458 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 459 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 460 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 461 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 462 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 463 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 464 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 465 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 466 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 467 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 468 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 469 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 470 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 471 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 472 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 473 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 474 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 475 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 476 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 477 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 478 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 479 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 480 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 481 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 482 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 483 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 484 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 485 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 486 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 487 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 488 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 489 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 490 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 491 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 492 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 493 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 494 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 495 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 496 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 497 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 498 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 499 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 500 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 501 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 502 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 503 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 504 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 505 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 506 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 507 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 508 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 509 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 510 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 511 */
- /* PageTableBase + 0x001000 = */ 
-, (unsigned int **)((char *)sim3_t760_mem_0.ttb + 0x002000 + 3), (unsigned int **)((char *)0) /* Indx = 0 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 1 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 2 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 3 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 4 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 5 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 6 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 7 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 8 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 9 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 10 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 11 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 12 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 13 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 14 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 15 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 16 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 17 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 18 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 19 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 20 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 21 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 22 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 23 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 24 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 25 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 26 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 27 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 28 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 29 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 30 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 31 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 32 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 33 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 34 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 35 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 36 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 37 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 38 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 39 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 40 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 41 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 42 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 43 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 44 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 45 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 46 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 47 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 48 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 49 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 50 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 51 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 52 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 53 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 54 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 55 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 56 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 57 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 58 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 59 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 60 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 61 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 62 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 63 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 64 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 65 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 66 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 67 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 68 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 69 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 70 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 71 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 72 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 73 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 74 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 75 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 76 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 77 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 78 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 79 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 80 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 81 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 82 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 83 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 84 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 85 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 86 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 87 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 88 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 89 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 90 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 91 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 92 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 93 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 94 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 95 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 96 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 97 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 98 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 99 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 100 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 101 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 102 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 103 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 104 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 105 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 106 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 107 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 108 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 109 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 110 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 111 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 112 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 113 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 114 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 115 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 116 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 117 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 118 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 119 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 120 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 121 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 122 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 123 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 124 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 125 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 126 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 127 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 128 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 129 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 130 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 131 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 132 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 133 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 134 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 135 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 136 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 137 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 138 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 139 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 140 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 141 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 142 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 143 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 144 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 145 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 146 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 147 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 148 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 149 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 150 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 151 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 152 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 153 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 154 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 155 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 156 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 157 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 158 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 159 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 160 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 161 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 162 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 163 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 164 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 165 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 166 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 167 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 168 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 169 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 170 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 171 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 172 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 173 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 174 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 175 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 176 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 177 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 178 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 179 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 180 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 181 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 182 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 183 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 184 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 185 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 186 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 187 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 188 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 189 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 190 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 191 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 192 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 193 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 194 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 195 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 196 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 197 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 198 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 199 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 200 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 201 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 202 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 203 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 204 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 205 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 206 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 207 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 208 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 209 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 210 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 211 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 212 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 213 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 214 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 215 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 216 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 217 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 218 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 219 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 220 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 221 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 222 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 223 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 224 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 225 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 226 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 227 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 228 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 229 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 230 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 231 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 232 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 233 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 234 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 235 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 236 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 237 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 238 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 239 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 240 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 241 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 242 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 243 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 244 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 245 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 246 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 247 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 248 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 249 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 250 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 251 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 252 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 253 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 254 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 255 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 256 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 257 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 258 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 259 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 260 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 261 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 262 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 263 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 264 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 265 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 266 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 267 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 268 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 269 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 270 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 271 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 272 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 273 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 274 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 275 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 276 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 277 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 278 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 279 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 280 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 281 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 282 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 283 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 284 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 285 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 286 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 287 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 288 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 289 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 290 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 291 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 292 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 293 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 294 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 295 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 296 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 297 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 298 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 299 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 300 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 301 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 302 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 303 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 304 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 305 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 306 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 307 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 308 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 309 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 310 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 311 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 312 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 313 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 314 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 315 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 316 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 317 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 318 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 319 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 320 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 321 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 322 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 323 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 324 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 325 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 326 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 327 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 328 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 329 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 330 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 331 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 332 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 333 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 334 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 335 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 336 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 337 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 338 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 339 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 340 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 341 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 342 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 343 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 344 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 345 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 346 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 347 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 348 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 349 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 350 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 351 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 352 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 353 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 354 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 355 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 356 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 357 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 358 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 359 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 360 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 361 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 362 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 363 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 364 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 365 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 366 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 367 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 368 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 369 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 370 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 371 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 372 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 373 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 374 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 375 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 376 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 377 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 378 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 379 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 380 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 381 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 382 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 383 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 384 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 385 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 386 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 387 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 388 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 389 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 390 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 391 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 392 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 393 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 394 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 395 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 396 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 397 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 398 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 399 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 400 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 401 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 402 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 403 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 404 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 405 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 406 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 407 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 408 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 409 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 410 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 411 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 412 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 413 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 414 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 415 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 416 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 417 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 418 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 419 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 420 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 421 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 422 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 423 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 424 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 425 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 426 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 427 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 428 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 429 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 430 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 431 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 432 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 433 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 434 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 435 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 436 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 437 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 438 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 439 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 440 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 441 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 442 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 443 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 444 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 445 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 446 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 447 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 448 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 449 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 450 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 451 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 452 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 453 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 454 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 455 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 456 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 457 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 458 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 459 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 460 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 461 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 462 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 463 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 464 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 465 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 466 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 467 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 468 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 469 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 470 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 471 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 472 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 473 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 474 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 475 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 476 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 477 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 478 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 479 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 480 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 481 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 482 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 483 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 484 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 485 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 486 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 487 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 488 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 489 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 490 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 491 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 492 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 493 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 494 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 495 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 496 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 497 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 498 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 499 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 500 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 501 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 502 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 503 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 504 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 505 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 506 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 507 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 508 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 509 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 510 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 511 */
- /* PageTableBase + 0x002000 = */ 
-, (unsigned int **)((char *)sim3_t760_mem_0.ttb + 0x003000 + 3), (unsigned int **)((char *)0) /* Indx = 0 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 1 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 2 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 3 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 4 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 5 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 6 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 7 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 8 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 9 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 10 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 11 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 12 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 13 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 14 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 15 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 16 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 17 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 18 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 19 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 20 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 21 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 22 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 23 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 24 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 25 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 26 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 27 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 28 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 29 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 30 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 31 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 32 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 33 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 34 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 35 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 36 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 37 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 38 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 39 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 40 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 41 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 42 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 43 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 44 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 45 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 46 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 47 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 48 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 49 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 50 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 51 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 52 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 53 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 54 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 55 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 56 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 57 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 58 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 59 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 60 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 61 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 62 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 63 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 64 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 65 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 66 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 67 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 68 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 69 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 70 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 71 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 72 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 73 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 74 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 75 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 76 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 77 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 78 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 79 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 80 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 81 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 82 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 83 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 84 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 85 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 86 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 87 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 88 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 89 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 90 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 91 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 92 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 93 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 94 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 95 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 96 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 97 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 98 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 99 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 100 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 101 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 102 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 103 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 104 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 105 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 106 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 107 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 108 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 109 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 110 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 111 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 112 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 113 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 114 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 115 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 116 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 117 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 118 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 119 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 120 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 121 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 122 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 123 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 124 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 125 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 126 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 127 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 128 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 129 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 130 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 131 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 132 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 133 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 134 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 135 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 136 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 137 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 138 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 139 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 140 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 141 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 142 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 143 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 144 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 145 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 146 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 147 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 148 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 149 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 150 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 151 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 152 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 153 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 154 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 155 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 156 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 157 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 158 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 159 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 160 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 161 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 162 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 163 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 164 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 165 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 166 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 167 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 168 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 169 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 170 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 171 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 172 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 173 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 174 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 175 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 176 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 177 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 178 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 179 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 180 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 181 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 182 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 183 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 184 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 185 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 186 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 187 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 188 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 189 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 190 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 191 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 192 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 193 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 194 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 195 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 196 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 197 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 198 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 199 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 200 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 201 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 202 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 203 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 204 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 205 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 206 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 207 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 208 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 209 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 210 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 211 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 212 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 213 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 214 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 215 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 216 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 217 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 218 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 219 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 220 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 221 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 222 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 223 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 224 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 225 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 226 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 227 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 228 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 229 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 230 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 231 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 232 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 233 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 234 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 235 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 236 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 237 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 238 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 239 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 240 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 241 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 242 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 243 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 244 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 245 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 246 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 247 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 248 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 249 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 250 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 251 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 252 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 253 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 254 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 255 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 256 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 257 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 258 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 259 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 260 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 261 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 262 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 263 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 264 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 265 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 266 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 267 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 268 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 269 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 270 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 271 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 272 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 273 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 274 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 275 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 276 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 277 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 278 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 279 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 280 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 281 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 282 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 283 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 284 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 285 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 286 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 287 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 288 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 289 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 290 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 291 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 292 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 293 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 294 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 295 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 296 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 297 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 298 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 299 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 300 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 301 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 302 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 303 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 304 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 305 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 306 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 307 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 308 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 309 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 310 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 311 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 312 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 313 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 314 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 315 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 316 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 317 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 318 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 319 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 320 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 321 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 322 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 323 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 324 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 325 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 326 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 327 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 328 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 329 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 330 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 331 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 332 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 333 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 334 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 335 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 336 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 337 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 338 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 339 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 340 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 341 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 342 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 343 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 344 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 345 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 346 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 347 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 348 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 349 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 350 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 351 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 352 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 353 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 354 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 355 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 356 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 357 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 358 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 359 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 360 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 361 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 362 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 363 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 364 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 365 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 366 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 367 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 368 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 369 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 370 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 371 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 372 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 373 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 374 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 375 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 376 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 377 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 378 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 379 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 380 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 381 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 382 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 383 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 384 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 385 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 386 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 387 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 388 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 389 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 390 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 391 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 392 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 393 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 394 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 395 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 396 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 397 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 398 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 399 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 400 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 401 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 402 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 403 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 404 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 405 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 406 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 407 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 408 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 409 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 410 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 411 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 412 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 413 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 414 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 415 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 416 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 417 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 418 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 419 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 420 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 421 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 422 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 423 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 424 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 425 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 426 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 427 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 428 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 429 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 430 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 431 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 432 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 433 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 434 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 435 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 436 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 437 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 438 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 439 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 440 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 441 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 442 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 443 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 444 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 445 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 446 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 447 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 448 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 449 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 450 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 451 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 452 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 453 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 454 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 455 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 456 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 457 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 458 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 459 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 460 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 461 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 462 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 463 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 464 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 465 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 466 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 467 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 468 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 469 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 470 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 471 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 472 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 473 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 474 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 475 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 476 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 477 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 478 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 479 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 480 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 481 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 482 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 483 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 484 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 485 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 486 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 487 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 488 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 489 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 490 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 491 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 492 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 493 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 494 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 495 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 496 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 497 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 498 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 499 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 500 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 501 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 502 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 503 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 504 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 505 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 506 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 507 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 508 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 509 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 510 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 511 */
- /* PageTableBase + 0x003000 = */ 
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 0 */
-, (unsigned int **)((char *)sim3_t760_mem_0.data_00001000 + 1 + MALI_ATTR), (unsigned int **)((char *)0) /* Indx = 1 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 2 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 3 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 4 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 5 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 6 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 7 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 8 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 9 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 10 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 11 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 12 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 13 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 14 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 15 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 16 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 17 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 18 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 19 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 20 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 21 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 22 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 23 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 24 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 25 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 26 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 27 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 28 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 29 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 30 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 31 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 32 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 33 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 34 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 35 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 36 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 37 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 38 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 39 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 40 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 41 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 42 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 43 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 44 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 45 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 46 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 47 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 48 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 49 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 50 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 51 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 52 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 53 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 54 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 55 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 56 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 57 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 58 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 59 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 60 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 61 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 62 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 63 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 64 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 65 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 66 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 67 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 68 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 69 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 70 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 71 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 72 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 73 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 74 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 75 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 76 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 77 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 78 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 79 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 80 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 81 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 82 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 83 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 84 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 85 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 86 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 87 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 88 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 89 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 90 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 91 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 92 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 93 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 94 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 95 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 96 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 97 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 98 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 99 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 100 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 101 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 102 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 103 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 104 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 105 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 106 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 107 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 108 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 109 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 110 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 111 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 112 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 113 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 114 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 115 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 116 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 117 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 118 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 119 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 120 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 121 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 122 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 123 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 124 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 125 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 126 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 127 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 128 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 129 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 130 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 131 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 132 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 133 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 134 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 135 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 136 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 137 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 138 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 139 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 140 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 141 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 142 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 143 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 144 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 145 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 146 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 147 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 148 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 149 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 150 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 151 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 152 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 153 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 154 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 155 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 156 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 157 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 158 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 159 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 160 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 161 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 162 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 163 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 164 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 165 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 166 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 167 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 168 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 169 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 170 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 171 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 172 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 173 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 174 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 175 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 176 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 177 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 178 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 179 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 180 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 181 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 182 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 183 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 184 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 185 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 186 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 187 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 188 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 189 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 190 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 191 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 192 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 193 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 194 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 195 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 196 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 197 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 198 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 199 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 200 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 201 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 202 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 203 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 204 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 205 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 206 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 207 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 208 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 209 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 210 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 211 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 212 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 213 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 214 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 215 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 216 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 217 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 218 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 219 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 220 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 221 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 222 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 223 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 224 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 225 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 226 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 227 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 228 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 229 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 230 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 231 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 232 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 233 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 234 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 235 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 236 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 237 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 238 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 239 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 240 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 241 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 242 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 243 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 244 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 245 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 246 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 247 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 248 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 249 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 250 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 251 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 252 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 253 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 254 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 255 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 256 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 257 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 258 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 259 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 260 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 261 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 262 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 263 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 264 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 265 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 266 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 267 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 268 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 269 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 270 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 271 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 272 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 273 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 274 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 275 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 276 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 277 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 278 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 279 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 280 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 281 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 282 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 283 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 284 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 285 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 286 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 287 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 288 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 289 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 290 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 291 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 292 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 293 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 294 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 295 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 296 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 297 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 298 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 299 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 300 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 301 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 302 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 303 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 304 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 305 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 306 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 307 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 308 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 309 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 310 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 311 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 312 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 313 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 314 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 315 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 316 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 317 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 318 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 319 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 320 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 321 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 322 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 323 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 324 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 325 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 326 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 327 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 328 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 329 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 330 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 331 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 332 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 333 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 334 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 335 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 336 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 337 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 338 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 339 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 340 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 341 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 342 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 343 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 344 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 345 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 346 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 347 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 348 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 349 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 350 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 351 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 352 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 353 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 354 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 355 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 356 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 357 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 358 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 359 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 360 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 361 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 362 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 363 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 364 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 365 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 366 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 367 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 368 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 369 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 370 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 371 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 372 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 373 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 374 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 375 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 376 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 377 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 378 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 379 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 380 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 381 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 382 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 383 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 384 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 385 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 386 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 387 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 388 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 389 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 390 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 391 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 392 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 393 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 394 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 395 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 396 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 397 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 398 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 399 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 400 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 401 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 402 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 403 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 404 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 405 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 406 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 407 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 408 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 409 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 410 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 411 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 412 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 413 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 414 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 415 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 416 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 417 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 418 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 419 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 420 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 421 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 422 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 423 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 424 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 425 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 426 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 427 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 428 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 429 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 430 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 431 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 432 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 433 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 434 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 435 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 436 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 437 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 438 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 439 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 440 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 441 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 442 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 443 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 444 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 445 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 446 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 447 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 448 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 449 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 450 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 451 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 452 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 453 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 454 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 455 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 456 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 457 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 458 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 459 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 460 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 461 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 462 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 463 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 464 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 465 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 466 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 467 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 468 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 469 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 470 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 471 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 472 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 473 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 474 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 475 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 476 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 477 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 478 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 479 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 480 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 481 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 482 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 483 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 484 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 485 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 486 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 487 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 488 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 489 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 490 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 491 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 492 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 493 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 494 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 495 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 496 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 497 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 498 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 499 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 500 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 501 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 502 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 503 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 504 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 505 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 506 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 507 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 508 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 509 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 510 */
-, (unsigned int **)((char *)0), (unsigned int **)((char *)0) /* Indx = 511 */
-},
-/* unsigned int sim3_t760_mem_0.data_00001000[1024] = */ 
-{
-  0x00000000, 0x00000000, 0x00000000, 0x00000000 /* 0x1000; */
-, 0x00000c02, 0x00000000, 0x00000000, 0x1234babe /* 0x1010; */
-},
-
-};
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_mem_0.h b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_mem_0.h
deleted file mode 100644
index c27a790ed9ea..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_mem_0.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-* The confidential and proprietary information contained in this file may
-* only be used by a person authorised under and to the extent permitted
-* by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-* This entire notice must be reproduced on all copies of this file
-* and copies of this file may only be made by a person if such person is
-* permitted to do so under the terms of a subsisting license agreement
-* from ARM Limited.
-*
-* Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-* Revision  : $Revision: 66689 $
-* Release   : $State: $
-*-----------------------------------------------------------------------------*/
-#define MALI_ATTR (0xC0+0x200)
-/* ###########################
- * Data structure definition for: sim3_t760_mem_0
- * ########################### */
-struct t_sim3_t760_mem_0 {
-  unsigned int **ttb[4 * 1024];
-  unsigned int data_00001000[1024];
-};
-extern volatile struct t_sim3_t760_mem_0 sim3_t760_mem_0;
-
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_run.c b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_run.c
deleted file mode 100644
index 54b17d6cc4be..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim3_t760_run.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-* The confidential and proprietary information contained in this file may
-* only be used by a person authorised under and to the extent permitted
-* by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-* This entire notice must be reproduced on all copies of this file
-* and copies of this file may only be made by a person if such person is
-* permitted to do so under the terms of a subsisting license agreement
-* from ARM Limited.
-*
-* Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-* Revision  : $Revision: 66689 $
-* Release   : $State: $
-*-----------------------------------------------------------------------------*/
-
-/* 
-
-BRIEF DESCRIPTION, PURPOSE AND STRATEGY
-=======================================
-
-This test performs a basic check on the GPU's ability to access external memory on its ACE-Lite port.
-
-A Null job descriptor is placed in memory which is then run by the GPU.  The status of the job is written back to memory (each job descriptor has a status field).
-
-On successful completion of the job, a job interrupt is triggered and the test is allowed to complete.  
-
-
-
-DEBUG HINTS IN CASE OF FAILURE
-===========================
-a) Check the APB bus connections as this is the bus that is used to communicate with the Job manager.
-b) Check that the GPU's reset signal is not asserted.
-c) Check that the GPU input clock is toggling as expected.
-d) Check that the DFT signals are disabled.
-e) Check that MBIST is disabled.
-f) Check every memory accesses from the GPU completes correctly.
-g) Check the GPU interrupt signal IRQGPU is correctly connected (sim2 should pass if this is okay).
-h) Check the GPU interrupt signal IRQMMU is correctly connected (sim2 should pass if this is okay).
-i) Check the GPU interrupt signal IRQJOB is correctly connected (sim2 should pass if this is okay).
-
-*/
-
-#include "MaliFns.h"
-#include "MaliDefines-t760.h"
-
-#include "sim3_t760_check_0_a.h"
-#include "sim3_t760_mem_0.h"
-
-int Check_sim3_t760_check_0_a (struct t_sim3_t760_mem_0 *p);
-
-int RunMaliTest_sim3_t760_part0 (void);
-int RunMaliTest_sim3_t760_part1 (void);
-
-static volatile struct t_sim3_t760_mem_0 *malidata_0;
-static int mali_step;
-
-int RunMaliTest_sim3_t760 (int *base) {
-	
-	Mali_SetBase(base);
-
-    RunMaliTest_sim3_t760_part0();
-    RunMaliTest_sim3_t760_part1();
- 
-};
-
-#define printf printk
-int RunMaliTest_sim3_t760_part0 (void) {
-  int res = 0;
-
-  int gpuid, num_cores, l2_size, axi_width, i, as_present, js_present, core_bitmap;
-
-  printf("RUNNING TEST: sim3\n");
-  printf("  Purpose: Check AXI connectivity\n");
-  printf("  Will run a simple NULL job which reads and writes data to memory.\n");
-
-  // Get current configuration to allow testing all registers
-  gpuid         = Mali_RdReg(0x20, 0, 0x0000);
-  core_bitmap   = Mali_RdReg(0x20, 0, 0x0100);
-  l2_size       = ((Mali_RdReg(0x20, 0, 0x0004) >> 16) & 0xFF);
-  axi_width     = (1 <<((Mali_RdReg(0x20, 0, 0x0004) >> 24) & 0xFF));
-  as_present    = Mali_RdReg(0x20, 0, 0x0018);
-  js_present    = Mali_RdReg(0x20, 0, 0x001c);
-
-  i = core_bitmap;
-  num_cores = 0;
-  while(i) {
-    num_cores++;
-    i >>= 1;
-  }
-  printf("Selected configuration:\n");
-  printf("  Bus width: %d\n", axi_width);
-  printf("  Number of shader cores: %d\n", num_cores);
-  printf("  L2 cache size: %d kB\n", ((1<<l2_size)/1024));
-
-  Mali_Reset();
-  printk("JOB_IRQ_CLEAR is %x\n", JOB_IRQ_CLEAR);
-  Mali_WrReg(0x20,0x0,JOB_IRQ_CLEAR,0xFFFFFFFF);
-  Mali_WrReg(0x20,0x0,JOB_IRQ_MASK,0xFFFFFFFF);
-  Mali_WrReg(0x20,0x0,JS1_HEAD_NEXT_LO,0xFFFFFFFF);
-  Mali_WrReg(0x20,0x0,TILER_PWRON_LO,0xFFFFFFFF);
-  Mali_WrReg(0x20,0x0,JS1_CONFIG_NEXT,0x00001000);
-  Mali_WrReg(0x20,0x0,JS1_HEAD_NEXT_LO,0x00001000);
-  if (num_cores>=6)
-  {
-    Mali_WrReg(0x20,0x0,JS1_AFFINITY_NEXT_LO,0x0000000F);
-  }
-  else
-  {
-    Mali_WrReg(0x20,0x0,JS1_AFFINITY_NEXT_LO,0xFFFFFFFF);
-  }
-  //(struct t_sim3_t760_mem_0 *)malidata_0 = Mali_LdMem(&sim3_t760_mem_0,sizeof(struct t_sim3_t760_mem_0),(int)sim3_t760_mem_0.ttb);
-  
-  malidata_0 = (struct t_sim3_t760_mem_0 *)Mali_LdMem(&sim3_t760_mem_0,sizeof(struct t_sim3_t760_mem_0),(int)sim3_t760_mem_0.ttb);
-  /* Enable optional performance counting */
-  Mali_InitPerfCounters();
-  Mali_WrReg(0x20,0x0,GPU_IRQ_CLEAR,0xFFFFFFFF);
-  Mali_WrReg(0x20,0x0,GPU_IRQ_MASK,0x00000000);
-  Mali_WrReg(0x20,0x0,JS1_COMMAND_NEXT,0x00000001);
-  mali_step++;
-  if (res == 0) {
-   return 254;
-  }
-  return res;
-}
-
-int RunMaliTest_sim3_t760_part1 (void) {
-  int res = 0;
-  int have_interrupts = 0;
-  /* Check for any interrupt */
-  have_interrupts = Mali_InterruptCheck(0xFFFFFFFF,0xFFFFFFFF);
-  if (!have_interrupts) {
-   return 255;
-  }
-
-  Mali_ReadPerfCounters();
-  //Mali_JobPartDone();
-  Mali_CheckReg(32, 0, 0x100c, 0x00000002);
-  res |= Check_sim3_t760_check_0_a(malidata_0);
-
-  Mali_MaskAllInterrupts();
-  mali_step++;
-  return res;
-}
-
-int Check_sim3_t760_check_0_a (struct t_sim3_t760_mem_0 *p) {
-  struct t_CheckData_sim3_t760_check_0_a *r = &CheckData_sim3_t760_check_0_a;
-  int res = 0;
-  printk("Performing data check of 32 bytes\n");
-
-  res |= Mali_MemCmp(p->data_00001000, 0x00001000, r->data_00001000, 0, 0x008);
-  /* Return -1 if a compare fail */
-  if (res) { return -1; };
-  printk("Check okay \n");
-  return 0;
-};
-#undef printf
diff --git a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim4_t760_run.c b/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim4_t760_run.c
deleted file mode 100644
index 44d7f52034e0..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/integration_kit/sim4_t760_run.c
+++ /dev/null
@@ -1,189 +0,0 @@
-/*----------------------------------------------------------------------------
-*
-* The confidential and proprietary information contained in this file may
-* only be used by a person authorised under and to the extent permitted
-* by a subsisting licensing agreement from ARM Limited.
-*
-*        (C) COPYRIGHT 2008-2009,2011-2013 ARM Limited.
-*             ALL RIGHTS RESERVED
-*             
-* This entire notice must be reproduced on all copies of this file
-* and copies of this file may only be made by a person if such person is
-* permitted to do so under the terms of a subsisting license agreement
-* from ARM Limited.
-*
-* Modified  : $Date: 2013-08-01 18:15:13 +0100 (Thu, 01 Aug 2013) $
-* Revision  : $Revision: 66689 $
-* Release   : $State: $
-*-----------------------------------------------------------------------------*/
-
-/* 
-
-BRIEF DESCRIPTION, PURPOSE AND STRATEGY
-=======================================
-
-This test checks that the GPU's different power domains can be turned on and off.
-
-It makes sure the power on or off status corresponds to the relevant domain's READY status.
-
-
-DEBUG HINTS IN CASE OF FAILURE
-===========================
-a) Check the APB bus connections as this is the bus that is used to communicate with the Job manager.
-b) Check that the GPU's reset signal is not asserted.
-c) Check that the GPU input clock is toggling as expected.
-d) Check that the DFT signals are disabled.
-e) Check that MBIST is disabled.
-
-*/
-
-#include "MaliFns.h"
-#include "MaliDefines-t760.h"
-
-int RunMaliTest_sim4_t760_part0 (void);
-
-static int mali_step;
-static int Mali_test_reg(int unit, int core, int regnum, int read_mask, int write_mask, int reset_value, int access);
-
-int RunMaliTest_sim4_t760 (int *base) {
-	
-  	Mali_SetBase(base);
-	RunMaliTest_sim4_t760_part0();
-  
-};
-#define printf printk
-int RunMaliTest_sim4_t760_part0 (void) {
-  int res = 0;
-
-  int gpuid, num_cores, l2_size, axi_width, i, as_present, js_present, core_bitmap;
-
-  printf("RUNNING TEST: sim4\n");
-  printf("  Purpose: Check APB register accesses\n");
-  printf("  Will check register read/write and reset value\n");
-
-  // Get current configuration to allow testing all registers
-  gpuid         = Mali_RdReg(0x20, 0, 0x0000);
-  core_bitmap   = Mali_RdReg(0x20, 0, 0x0100);
-  l2_size       = ((Mali_RdReg(0x20, 0, 0x0004) >> 16) & 0xFF);
-  axi_width     = (1 <<((Mali_RdReg(0x20, 0, 0x0004) >> 24) & 0xFF));
-  as_present    = Mali_RdReg(0x20, 0, 0x0018);
-  js_present    = Mali_RdReg(0x20, 0, 0x001c);
-
-  i = core_bitmap;
-  num_cores = 0;
-  while(i) {
-    num_cores++;
-    i >>= 1;
-  }
-  printf("Selected configuration:\n");
-  printf("  Bus width: %d\n", axi_width);
-  printf("  Number of shader cores: %d\n", num_cores);
-  printf("  L2 cache size: %d kB\n", ((1<<l2_size)/1024));
-
-  res |= Mali_test_reg(0, 0, 0x000, 0xffff0000, 0xffff0000, GPU_ID_VALUE, 1); /* GPU_ID */
-  res |= Mali_test_reg(0, 0, 0x100, 0xffffffff, 0xffffffff,  core_bitmap, 1); /* SHADER_PRESENT_LO */
-  res |= Mali_test_reg(0, 0, 0x110, 0xffffffff, 0xffffffff, 0x00000001, 1); /* TILER_PRESENT_LO */
-
-#if MALI == t760
-  /* T760 has only one logical L2C */
-  res |= Mali_test_reg (0, 0, 0x120, 0xffffffff, 0xffffffff, 0x00000001, 1); /* L2_PRESENT_LO */
-#else
-  if (num_cores>=6)
-  { /* T608 MP6 and T608 MP8 have two L2Cs*/
-    res |= Mali_test_reg (0, 0, 0x120, 0xffffffff, 0xffffffff, 0x00000011, 1); /* L2_PRESENT_LO */
-  }
-  else
-  {
-    res |= Mali_test_reg (0, 0, 0x120, 0xffffffff, 0xffffffff, 0x00000001, 1); /* L2_PRESENT_LO */
-  }
-#endif
-
-  res |= Mali_test_reg(0, 0, 0x140, 0xffffffff, 0xffffffff, 0x00000000, 1); /* SHADER_READY_LO */
-  res |= Mali_test_reg(0, 0, 0x150, 0xffffffff, 0xffffffff, 0x00000000, 1); /* TILER_READY_LO */
-  res |= Mali_test_reg(0, 0, 0x160, 0xffffffff, 0xffffffff, 0x00000000, 1); /* L2_READY_LO */
-  for(i=0; i<num_cores; i++) {
-    printf("Power on/off shader core #%d\n", i);
-    Mali_WrReg(0, 0, 0x180, (1<<i)); /* SHADER_PWRON_LO */
-    while( Mali_RdReg(0, 0, 0x200) ) {}
-    res |= Mali_test_reg(0, 0, 0x140, 0xffffffff, 0xffffffff, (1<<i), 1); /* SHADER_READY_LO */
-    Mali_WrReg(0, 0, 0x1c0, (1<<i)); /* SHADER_PWROFF_LO */
-    while( Mali_RdReg(0, 0, 0x200) ) {}
-    res |= Mali_test_reg(0, 0, 0x140, 0xffffffff, 0xffffffff, 0, 1); /* SHADER_READY_LO */
-  }
-
-  printf("Power on/off tiler\n", i);
-  Mali_WrReg(0, 0, 0x190, 1); /* TILER_PWRON_LO */
-  while( Mali_RdReg(0, 0, 0x210) ) {}
-  res |= Mali_test_reg(0, 0, 0x150, 0xffffffff, 0xffffffff, 1, 1); /* TILER_READY_LO */
-  Mali_WrReg(0, 0, 0x1d0, 1); /* TILER_PWROFF_LO */
-  while( Mali_RdReg(0, 0, 0x210) ) {}
-  res |= Mali_test_reg(0, 0, 0x150, 0xffffffff, 0xffffffff, 0, 1); /* TILER_READY_LO */
-
-  printf("Power on/off L2\n", i);
-#if MALI == t760
-  /* T760 has only one logical L2C */
-  Mali_WrReg(0, 0, 0x1a0, 1); /* L2_PWRON_LO */
-  while( Mali_RdReg(0, 0, 0x220) ) {}
-  res |= Mali_test_reg(0, 0, 0x160, 0xffffffff, 0xffffffff, 1, 1); /* L2_READY_LO */
-  Mali_WrReg(0, 0, 0x1e0, 1); /* L2_PWROFF_LO */
-  while( Mali_RdReg(0, 0, 0x220) ) {}
-  res |= Mali_test_reg(0, 0, 0x160, 0xffffffff, 0xffffffff, 0, 1); /* L2_READY_LO */
-#else
-  if (num_cores>=6)
-  { /* T608 MP6 and T608 MP8 have two L2Cs*/
-    Mali_WrReg(0, 0, 0x1a0, 17); /* L2_PWRON_LO */
-    while( Mali_RdReg(0, 0, 0x220) ) {}
-    res |= Mali_test_reg(0, 0, 0x160, 0xffffffff, 0xffffffff, 17, 1); /* L2_READY_LO */
-    Mali_WrReg(0, 0, 0x1e0, 17); /* L2_PWROFF_LO */
-    while( Mali_RdReg(0, 0, 0x220) ) {}
-    res |= Mali_test_reg(0, 0, 0x160, 0xffffffff, 0xffffffff, 0, 1); /* L2_READY_LO */
-  }
-  else
-  {
-    Mali_WrReg(0, 0, 0x1a0, 1); /* L2_PWRON_LO */
-    while( Mali_RdReg(0, 0, 0x220) ) {}
-    res |= Mali_test_reg(0, 0, 0x160, 0xffffffff, 0xffffffff, 1, 1); /* L2_READY_LO */
-    Mali_WrReg(0, 0, 0x1e0, 1); /* L2_PWROFF_LO */
-    while( Mali_RdReg(0, 0, 0x220) ) {}
-    res |= Mali_test_reg(0, 0, 0x160, 0xffffffff, 0xffffffff, 0, 1); /* L2_READY_LO */
-  }
-#endif
-
-
-  mali_step++;
-  return res;
-}
-
-
-/* Mali_test_reg
-   Test the register.
-   access: 0=RW, 1=RO
-*/
-static int Mali_test_reg(int unit, int core, int regnum, int read_mask, int write_mask, int reset_value, int access) {
-  int value = Mali_RdReg(unit, core, regnum);
-  if( value != reset_value ) {
-    printf("FAILURE: Wrong reset value. Addr: 0x%08x Value: 0x%08x Expected: 0x%08x\n",
-           (unit<<28)+(core<<16)+regnum, value, reset_value);
-    return -1;
-  }
-  if( access == 0 ) {
-    Mali_WrReg(unit, core, regnum, (0xffffffff & write_mask));
-    value = Mali_RdReg(unit, core, regnum) & read_mask;
-    if( value != (0xffffffff & write_mask & read_mask) ) {
-      printf("FAILURE: Wrong value. Addr: 0x%08x Value: 0x%08x Expected: 0x%08x\n",
-             (unit<<28)+(core<<16)+regnum, value, (0xffffffff & write_mask & read_mask));
-      return -2;
-    }
-    Mali_WrReg(unit, core, regnum, (0x12345678 & write_mask));
-    value = Mali_RdReg(unit, core, regnum) & read_mask;
-    if( value != (0x12345678 & write_mask & read_mask) ) {
-      printf("FAILURE: Wrong value. Addr: 0x%08x Value: 0x%08x Expected: 0x%08x\n",
-             (unit<<28)+(core<<16)+regnum, value, (0x12345678 & write_mask & read_mask));
-      return -2;
-    }
-  }
-  printf("Register %08x: Success!\n", (unit<<28)+(core<<16)+regnum);
-  return 0;
-}
-
-#undef printf
diff --git a/drivers/gpu/arm/t6xx/kbase/src/sconscript b/drivers/gpu/arm/t6xx/kbase/src/sconscript
deleted file mode 100644
index f4324adff557..000000000000
--- a/drivers/gpu/arm/t6xx/kbase/src/sconscript
+++ /dev/null
@@ -1,114 +0,0 @@
-#
-# (C) COPYRIGHT 2010-2013 ARM Limited. All rights reserved.
-#
-# This program is free software and is provided to you under the terms of the
-# GNU General Public License version 2 as published by the Free Software
-# Foundation, and any use by you of this program is subject to the terms
-# of such GNU licence.
-#
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
-#
-#
-
-
-
-import os
-import re
-import sys
-Import('env')
-
-mock_test = 0
-
-if env['v'] != '1':
-	env['MAKECOMSTR'] = '[MAKE] ${SOURCE.dir}'
-
-# Fake platform is a transient solution for GPL drivers running in kernel that does not provide configuration via platform data.
-# For such kernels fake_platform_device should be set to 1. For kernels providing platform data fake_platform_device should be set to 0.
-fake_platform_device = 1
-
-# Source files required for kbase.
-kbase_src = [Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/common/*.c'),
-             Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/linux/*.c'),
-             Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/platform/%s/*.c' % (env['platform_config'])),
-             Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/common/*.h'),
-             Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/linux/*.h'),
-             ]
-
-if Glob('#kernel/drivers/gpu/arm/t6xx/kbase/tests/internal/src/mock') and env['unit'] == '1':
-	kbase_src += [Glob('#kernel/drivers/gpu/arm/t6xx/kbase/tests/internal/src/mock/*.c')]
-	mock_test = 1
-
-# we need platform config for GPL version using fake platform
-if fake_platform_device==1:
-	# Check if we are compiling for PBX
-	linux_config_file = os.path.normpath(os.environ['KDIR']) + '/.config'
-	search_term = '^[\ ]*CONFIG_MACH_REALVIEW_PBX[\ ]*=[\ ]*y'
-	REALVIEW_PBX = 0
-	for line in open(linux_config_file, 'r'):
-		if re.search(search_term, line):
-			REALVIEW_PBX = 1
-			break
-	if REALVIEW_PBX == 1 and (env['platform_config'] == 'vexpress' or env['platform_config'] == 'vexpress_virtex7_40mhz' or env['platform_config'] == 'vexpress_6xvirtex7_10mhz'):
-		sys.stderr.write("WARNING: Building for a PBX kernel but with platform_config=vexpress*\n")
-	# if the file platform config file is in the tpip directory then use that, otherwise use the default config directory
-	if Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/linux/config/tpip/*%s.c' % (env['platform_config'])):
-		kbase_src += Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/linux/config/tpip/*%s.c' % (env['platform_config']))
-	else:
-		kbase_src += Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/linux/config/*%s.c' % (env['platform_config']))
-	
-# Note: cleaning via the Linux kernel build system does not yet work
-if env.GetOption('clean') :
-	makeAction=Action("cd ${SOURCE.dir}/.. && make clean", '$MAKECOMSTR')
-	cmd = env.Command(['$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/mali_platform_fake.ko'], kbase_src, [makeAction])
-else:
-	if env['os'] == 'android':
-		env['android'] = 1
-	else:
-		env['android'] = 0
-
-	if env['unit'] == '1':
-		env['kernel_test'] = 1
-	else:
-		env['kernel_test'] = 0
-
-	if env['platform_fake_module'] == '0':
-		makeAction=Action("cd ${SOURCE.dir}/.. && make PLATFORM=${platform} MALI_ERROR_INJECT_ON=${error_inject} MALI_ANDROID=${android} MALI_KERNEL_TEST_API=${kernel_test} MALI_UNIT_TEST=${unit} MALI_RELEASE_NAME=\"${mali_release_name}\" MALI_MOCK_TEST=%s MALI_CUSTOMER_RELEASE=${release} MALI_INSTRUMENTATION_LEVEL=${instr} MALI_COVERAGE=${coverage} %s && cp mali_kbase.ko $STATIC_LIB_PATH/mali_kbase.ko" % (mock_test, env.kernel_get_config_defines(fake_platform_device)), '$MAKECOMSTR')
-		cmd = env.Command('$STATIC_LIB_PATH/mali_kbase.ko', kbase_src, [makeAction])
-	else:
-		makeAction=Action("cd ${SOURCE.dir}/.. && make PLATFORM=${platform} MALI_ERROR_INJECT_ON=${error_inject} MALI_ANDROID=${android} MALI_KERNEL_TEST_API=${kernel_test} MALI_UNIT_TEST=${unit} MALI_RELEASE_NAME=\"${mali_release_name}\" MALI_MOCK_TEST=%s MALI_CUSTOMER_RELEASE=${release} MALI_INSTRUMENTATION_LEVEL=${instr} MALI_COVERAGE=${coverage} %s && cp mali_kbase.ko $STATIC_LIB_PATH/mali_kbase.ko && cp mali_platform_fake.ko $STATIC_LIB_PATH/mali_platform_fake.ko" % (mock_test, env.kernel_get_config_defines(fake_platform_device)), '$MAKECOMSTR')
-		cmd = env.Command(['$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/mali_platform_fake.ko'], kbase_src, [makeAction])
-
-# Add a dependency on kds.ko.
-# Only necessary when KDS is not built into the kernel.
-#
-linux_config_file = os.path.normpath(os.environ['KDIR']) + '/.config'
-search_term = '^[\ ]*CONFIG_KDS[\ ]*=[\ ]*y'
-kds_in_kernel = 0
-for line in open(linux_config_file, 'r'):
-	if re.search(search_term, line):
-        # KDS in kernel.
-		kds_in_kernel = 1
-if not kds_in_kernel:
-	env.Depends('$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/kds.ko')
-
-# need Module.symvers from ump.ko build
-if int(env['ump']) == 1:
-	env.Depends('$STATIC_LIB_PATH/mali_kbase.ko', '$STATIC_LIB_PATH/ump.ko')
-
-# Until we fathom out how the invoke the Linux build system to clean, we can use Clean
-# to remove generated files.
-patterns = ['*.mod.c', '*.o', '*.ko', '*.a', '.*.cmd', 'modules.order', '.tmp_versions', 'Module.symvers']
-
-for p in patterns:
-	Clean(cmd, Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/%s' % p))
-	Clean(cmd, Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/linux/%s' % p))
-	Clean(cmd, Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/linux/config/%s' % p))
-	Clean(cmd, Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/common/%s' % p))
-	Clean(cmd, Glob('#kernel/drivers/gpu/arm/t6xx/kbase/tests/internal/src/mock/%s' % p))
-	Clean(cmd, Glob('#kernel/drivers/gpu/arm/t6xx/kbase/src/platform/%s/%s' % ((env['platform_config']), p) ))
-
-env.ProgTarget('kbase', cmd)
-
-env.AppendUnique(BASE=['cutils_list'])
diff --git a/drivers/gpu/arm/t6xx/license.txt b/drivers/gpu/arm/t6xx/license.txt
deleted file mode 100644
index 77c14bdc45b8..000000000000
--- a/drivers/gpu/arm/t6xx/license.txt
+++ /dev/null
@@ -1,198 +0,0 @@
-GPLV2 LICENCE AGREEMENT FOR MALI GPUS LINUX KERNEL DEVICE DRIVERS SOURCE CODE
-
-THE USE OF THE SOFTWARE ACCOMPANYING THIS DOCUMENT IS EXPRESSLY SUBJECT TO THE TERMS OF THE GNU GENERAL PUBLIC LICENSE VERSION 2 AS PUBLISHED BY THE FREE SOFTWARE FOUNDATION AND SET OUT BELOW FOR REFERENCE (?GPL LICENCE?). ARM IS ONLY WILLING TO DISTRIBUTE THE SOFTWARE TO YOU ON CONDITION THAT YOU ACCEPT ALL OF THE TERMS IN THE GPL LICENCE PRIOR TO MODIFYING OR DISTRIBUTING THE SOFTWARE.
-
-
-
-Further for the period of three (3) years, ARM hereby offers to make available the source code of any part of the software program that is supplied as object code or in executable form.
-
-
-
-GPL Licence
-
-
-
-GNU GENERAL PUBLIC LICENSE
-
-Version 2, June 1991
-
-
-
-Copyright (C) 1989, 1991 Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.
-
-
-
-Preamble
-
-
-
-The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Lesser General Public License instead.) You can apply it to your programs, too.
-
-
-
-When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.
-
-
-
-To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.
-
-
-
-For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.
-
-
-
-We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.
-
-
-
-Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations.
-
-
-
-Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.
-
-
-
-The precise terms and conditions for copying, distribution and modification follow.
-
-
-
-GNU GENERAL PUBLIC LICENSE
-
-TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-
-
-0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term "modification".) Each licensee is addressed as "you".
-
-
-
-Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program).
-
-Whether that is true depends on what the Program does.
-
-
-
-1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty;
-
-and give any other recipients of the Program a copy of this License along with the Program.
-
-
-
-You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.
-
-
-
-2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:
-
-
-
-a) You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.
-
-
-
-b) You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.
-
-
-
-c) If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)
-
-
-
-These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.
-
-
-
-Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program.
-
-
-
-In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.
-
-
-
-3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:
-
-
-
-a) Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,
-
-
-
-b) Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,
-
-
-
-c) Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.)
-
-
-
-The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.
-
-
-
-If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.
-
-
-
-4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.
-
-
-
-5. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the
-
-Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.
-
-
-
-6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein.
-
-You are not responsible for enforcing compliance by third parties to this License.
-
-
-
-7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.
-
-
-
-If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.
-
-
-
-It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.
-
-
-
-This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.
-
-
-
-8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.
-
-
-
-9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.
-
-
-
-Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.
-
-
-
-10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.
-
-
-
-NO WARRANTY
-
-
-
-11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-
-
-12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
-
-/end
-
diff --git a/drivers/gpu/arm/t6xx/sconscript b/drivers/gpu/arm/t6xx/sconscript
deleted file mode 100644
index f416528c97dc..000000000000
--- a/drivers/gpu/arm/t6xx/sconscript
+++ /dev/null
@@ -1,17 +0,0 @@
-#
-# (C) COPYRIGHT 2010-2013 ARM Limited. All rights reserved.
-#
-# This program is free software and is provided to you under the terms of the
-# GNU General Public License version 2 as published by the Free Software
-# Foundation, and any use by you of this program is subject to the terms
-# of such GNU licence.
-#
-# A copy of the licence is included with the program, and can also be obtained
-# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-# Boston, MA  02110-1301, USA.
-#
-#
-
-
-
-SConscript('kbase/sconscript')
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index b59c42ba8415..6aca9688c6e0 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -23,7 +23,7 @@ source "drivers/gpu/drm/Kconfig"
 
 source "drivers/gpu/host1x/Kconfig"
 
-source "drivers/gpu/arm/t6xx/kbase/Kconfig"
+source "drivers/gpu/arm/midgard/Kconfig"
 
 config VGASTATE
        tristate
-- 
2.35.3

