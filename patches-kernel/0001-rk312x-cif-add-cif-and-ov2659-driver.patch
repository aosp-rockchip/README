From 45023a37a5cb1955210838ee543f5b54ae1c522c Mon Sep 17 00:00:00 2001
From: zyc <zyc@rock-chips.com>
Date: Fri, 8 Aug 2014 15:26:16 +0800
Subject: [PATCH] rk312x:cif: add cif and ov2659 driver.

---
 arch/arm/boot/dts/rk312x-cif-sensor.dtsi      |   23 +
 arch/arm/boot/dts/rk312x-sdk.dtsi             |    8 +-
 arch/arm/boot/dts/rk312x.dtsi                 |    8 +
 arch/arm/mach-rockchip/Makefile               |    1 +
 .../arm/mach-rockchip/board-rk30-sdk-camera.c |  104 +
 arch/arm/mach-rockchip/rk30_camera.h          |   54 +
 arch/arm/mach-rockchip/rk_camera.c            | 1332 ++++++++
 arch/arm/mach-rockchip/rk_camera.h            |  634 ++++
 .../arm/mach-rockchip/rk_camera_sensor_info.h |  383 +++
 drivers/media/Kconfig                         |    1 +
 drivers/media/Makefile                        |    6 +-
 .../media/platform/soc_camera/soc_camera.c    |   11 +-
 drivers/media/v4l2-core/videobuf-dma-contig.c |    1 +
 drivers/media/video/Kconfig                   |   22 +
 drivers/media/video/Makefile                  |    2 +
 drivers/media/video/generic_sensor.c          | 2954 +++++++++--------
 drivers/media/video/generic_sensor.h          |   46 +-
 drivers/media/video/ov2659.c                  | 2268 ++++++-------
 drivers/media/video/rk30_camera.c             | 1184 +------
 drivers/media/video/rk30_camera_oneframe.c    | 1197 +++----
 include/media/soc_camera.h                    |   43 +-
 include/media/v4l2-chip-ident.h               |    2 +-
 include/uapi/linux/v4l2-controls.h            |    7 +
 23 files changed, 5843 insertions(+), 4448 deletions(-)
 create mode 100644 arch/arm/boot/dts/rk312x-cif-sensor.dtsi
 create mode 100644 arch/arm/mach-rockchip/board-rk30-sdk-camera.c
 create mode 100644 arch/arm/mach-rockchip/rk30_camera.h
 create mode 100644 arch/arm/mach-rockchip/rk_camera.c
 create mode 100644 arch/arm/mach-rockchip/rk_camera.h
 create mode 100644 arch/arm/mach-rockchip/rk_camera_sensor_info.h
 create mode 100644 drivers/media/video/Kconfig
 create mode 100644 drivers/media/video/Makefile

diff --git a/arch/arm/boot/dts/rk312x-cif-sensor.dtsi b/arch/arm/boot/dts/rk312x-cif-sensor.dtsi
new file mode 100644
index 000000000000..613edfaba9c3
--- /dev/null
+++ b/arch/arm/boot/dts/rk312x-cif-sensor.dtsi
@@ -0,0 +1,23 @@
+#include "rk312x.dtsi" 
+#include "rk312x-pinctrl.dtsi"
+#include "../../mach-rockchip/rk_camera_sensor_info.h"
+/{
+	cif_sensor: cif_sensor{
+			compatible = "rockchip,sensor";
+		ov2659{
+			is_front = <1>; 
+			rockchip,powerdown = <&gpio3 GPIO_D7 GPIO_ACTIVE_HIGH>;
+			mir = <0>;
+			flash_attach = <0>;
+			resolution = <ov2659_FULL_RESOLUTION>;
+			pwdn_info = <ov2659_PWRDN_ACTIVE>;
+			powerup_sequence = <ov2659_PWRSEQ>;		
+			i2c_add = <ov2659_I2C_ADDR>;
+			i2c_rata = <100000>;
+			i2c_chl = <0>;
+			cif_chl = <0>;
+			mclk_rate = <24>;
+		};
+	};
+};
+
diff --git a/arch/arm/boot/dts/rk312x-sdk.dtsi b/arch/arm/boot/dts/rk312x-sdk.dtsi
index 3df8725a504a..ed8a095e3bb8 100755
--- a/arch/arm/boot/dts/rk312x-sdk.dtsi
+++ b/arch/arm/boot/dts/rk312x-sdk.dtsi
@@ -2,6 +2,8 @@
 
 #include "rk312x.dtsi"
 
+#include "lcd-b101ew05.dtsi"
+#include "rk312x-cif-sensor.dtsi"
 / {
 	fiq-debugger {
 		status = "okay";
@@ -206,7 +208,7 @@
 &rk818 {
 	gpios =<&gpio1 GPIO_B1 GPIO_ACTIVE_HIGH>,<&gpio1 GPIO_A1 GPIO_ACTIVE_LOW>;
 	rk818,system-power-controller;
-	rk818,support_dc_chg = <1>;/*1: dc chg; 0:usb chg*/
+	//rk818,support_dc_chg = <1>;/*1: dc chg; 0:usb chg*/
 
 	regulators {
 
@@ -431,3 +433,7 @@
 &pwm0 {
         status = "okay";
 };
+
+&cif_sensor{
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/rk312x.dtsi b/arch/arm/boot/dts/rk312x.dtsi
index 637a6d6c83aa..8037e9a8a3de 100755
--- a/arch/arm/boot/dts/rk312x.dtsi
+++ b/arch/arm/boot/dts/rk312x.dtsi
@@ -816,4 +816,12 @@
 			rockchip,ion_heap = <3>;
 		};
 	};
+	cif: cif@1010a000 {
+	     compatible = "rockchip,cif";
+	     reg = <0x1010a000 0x2000>;
+	     interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
+	     clocks = <&clk_gates3 3>,<&clk_gates6 5>,<&clk_gates6 4>,<&clk_cif0_in>,<&clk_cif_out>;
+	     clock-names = "pd_cif0", "aclk_cif0","hclk_cif0","cif0_in","cif0_out";
+	     status = "okay";
+	     };
 };
diff --git a/arch/arm/mach-rockchip/Makefile b/arch/arm/mach-rockchip/Makefile
index feb29aa42b7b..25417fcb20ec 100755
--- a/arch/arm/mach-rockchip/Makefile
+++ b/arch/arm/mach-rockchip/Makefile
@@ -21,3 +21,4 @@ obj-$(CONFIG_BLOCK_RKNAND) += rknandbase.o
 obj-$(CONFIG_DDR_TEST) += ddr_test.o
 obj-$(CONFIG_RK_PM_TESTS) += rk_pm_tests/
 obj-$(CONFIG_RK_FT_TEST) += rk_pm_tests/ft/
+obj-$(CONFIG_ROCK_CHIP_SOC_CAMERA) += board-rk30-sdk-camera.o
diff --git a/arch/arm/mach-rockchip/board-rk30-sdk-camera.c b/arch/arm/mach-rockchip/board-rk30-sdk-camera.c
new file mode 100644
index 000000000000..c2112ec4bc06
--- /dev/null
+++ b/arch/arm/mach-rockchip/board-rk30-sdk-camera.c
@@ -0,0 +1,104 @@
+#include "rk_camera.h"
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/delay.h>
+//*****************yzm***************
+static struct rkcamera_platform_data *new_camera_head;	
+   
+#define PMEM_CAM_SIZE PMEM_CAM_NECESSARY 
+/*****************************************************************************************
+ * camera  devices
+ * author: ddl@rock-chips.com
+ *****************************************************************************************/
+#define CONFIG_SENSOR_POWER_IOCTL_USR	   1 //define this refer to your board layout
+#define CONFIG_SENSOR_RESET_IOCTL_USR	   0
+#define CONFIG_SENSOR_POWERDOWN_IOCTL_USR	   0
+#define CONFIG_SENSOR_FLASH_IOCTL_USR	   0
+#define CONFIG_SENSOR_AF_IOCTL_USR	   0
+
+#if CONFIG_SENSOR_POWER_IOCTL_USR
+
+static int sensor_power_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+	//#error "CONFIG_SENSOR_POWER_IOCTL_USR is 1, sensor_power_usr_cb function must be writed!!";
+	return 0;
+}
+#endif
+
+#if CONFIG_SENSOR_RESET_IOCTL_USR
+static int sensor_reset_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+
+printk(KERN_EMERG "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	#error "CONFIG_SENSOR_RESET_IOCTL_USR is 1, sensor_reset_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+static int sensor_powerdown_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+
+printk(KERN_EMERG "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	#error "CONFIG_SENSOR_POWERDOWN_IOCTL_USR is 1, sensor_powerdown_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_FLASH_IOCTL_USR
+static int sensor_flash_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+
+printk(KERN_EMERG "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	#error "CONFIG_SENSOR_FLASH_IOCTL_USR is 1, sensor_flash_usr_cb function must be writed!!";
+}
+#endif
+
+#if CONFIG_SENSOR_AF_IOCTL_USR
+static int sensor_af_usr_cb (struct rk29camera_gpio_res *res,int on)
+{
+
+printk(KERN_EMERG "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	#error "CONFIG_SENSOR_AF_IOCTL_USR is 1, sensor_af_usr_cb function must be writed!!";
+}
+
+#endif
+
+static struct rk29camera_platform_ioctl_cb	sensor_ioctl_cb = {
+	#if CONFIG_SENSOR_POWER_IOCTL_USR
+	.sensor_power_cb = sensor_power_usr_cb,
+	#else
+	.sensor_power_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_RESET_IOCTL_USR
+	.sensor_reset_cb = sensor_reset_usr_cb,
+	#else
+	.sensor_reset_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_POWERDOWN_IOCTL_USR
+	.sensor_powerdown_cb = sensor_powerdown_usr_cb,
+	#else
+	.sensor_powerdown_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_FLASH_IOCTL_USR
+	.sensor_flash_cb = sensor_flash_usr_cb,
+	#else
+	.sensor_flash_cb = NULL,
+	#endif
+
+	#if CONFIG_SENSOR_AF_IOCTL_USR
+	.sensor_af_cb = sensor_af_usr_cb,	
+	#else
+	.sensor_af_cb = NULL,
+	#endif
+};
+
+#include "../../../drivers/media/video/rk30_camera.c"
+
+
diff --git a/arch/arm/mach-rockchip/rk30_camera.h b/arch/arm/mach-rockchip/rk30_camera.h
new file mode 100644
index 000000000000..5aa0b57af637
--- /dev/null
+++ b/arch/arm/mach-rockchip/rk30_camera.h
@@ -0,0 +1,54 @@
+/*
+    camera.h - PXA camera driver header file
+
+    Copyright (C) 2003, Intel Corporation
+    Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#ifndef __ASM_ARCH_CAMERA_RK30_H_
+#define __ASM_ARCH_CAMERA_RK30_H_
+
+#define RK29_CAM_DRV_NAME "rk3066b-camera"
+#define RK_SUPPORT_CIF0   1
+#define RK_SUPPORT_CIF1   0
+#define RK3288_CIF_NAME "rk3288_cif"
+#define RK3288_SENSOR_NAME "rk3288_sensor"
+
+#include "rk_camera.h"
+#include <dt-bindings/pinctrl/rockchip-rk3288.h>
+
+#define CONFIG_CAMERA_INPUT_FMT_SUPPORT     (RK_CAM_INPUT_FMT_YUV422)
+#ifdef CONFIG_SOC_RK3028
+#define CONFIG_CAMERA_SCALE_CROP_MACHINE    RK_CAM_SCALE_CROP_ARM
+#else
+#define CONFIG_CAMERA_SCALE_CROP_MACHINE    RK_CAM_SCALE_CROP_IPP
+#endif
+
+#if (CONFIG_CAMERA_SCALE_CROP_MACHINE==RK_CAM_SCALE_CROP_ARM)
+    #define CAMERA_SCALE_CROP_MACHINE  "arm"
+#elif (CONFIG_CAMERA_SCALE_CROP_MACHINE==RK_CAM_SCALE_CROP_IPP)
+    #define CAMERA_SCALE_CROP_MACHINE  "ipp"
+#elif (CONFIG_CAMERA_SCALE_CROP_MACHINE==RK_CAM_SCALE_CROP_RGA)
+    #define CAMERA_SCALE_CROP_MACHINE  "rga"
+#elif (CONFIG_CAMERA_SCALE_CROP_MACHINE==RK_CAM_SCALE_CROP_PP)
+    #define CAMERA_SCALE_CROP_MACHINE  "pp"
+#endif
+
+
+#define CAMERA_VIDEOBUF_ARM_ACCESS   1
+
+#endif
+
diff --git a/arch/arm/mach-rockchip/rk_camera.c b/arch/arm/mach-rockchip/rk_camera.c
new file mode 100644
index 000000000000..8a5e4dcb92a3
--- /dev/null
+++ b/arch/arm/mach-rockchip/rk_camera.c
@@ -0,0 +1,1332 @@
+#include "rk_camera.h"
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/moduleparam.h>
+#include <linux/of_gpio.h>
+//**********yzm***********//
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/kernel.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/of_fdt.h>
+#include <linux/module.h>
+//**********yzm***********//
+
+#define PMEM_CAM_NECESSARY	 0x00000000    //yzm
+
+static int camio_version = KERNEL_VERSION(0,1,9);//yzm camio_version
+module_param(camio_version, int, S_IRUGO);
+
+static int camera_debug = 0;//yzm camera_debug
+module_param(camera_debug, int, S_IRUGO|S_IWUSR);    
+
+#undef  CAMMODULE_NAME
+#define CAMMODULE_NAME   "rk_cam_io"
+
+#define ddprintk(level, fmt, arg...) do {			\
+	if (camera_debug >= level) 					\
+	    printk(KERN_WARNING"%s(%d):" fmt"\n", CAMMODULE_NAME,__LINE__,## arg); } while (0)
+
+#define dprintk(format, ...) ddprintk(1, format, ## __VA_ARGS__)  
+#define eprintk(format, ...) printk(KERN_ERR "%s(%d):" format"\n",CAMMODULE_NAME,__LINE__,## __VA_ARGS__)  
+#define debug_printk(format, ...) ddprintk(3, format, ## __VA_ARGS__)  
+
+static int rk_sensor_io_init(void);
+static int rk_sensor_io_deinit(int sensor);
+static int rk_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd, int on);
+static int rk_sensor_power(struct device *dev, int on);
+static int rk_sensor_register(void);
+//static int rk_sensor_reset(struct device *dev);
+static int rk_sensor_powerdown(struct device *dev, int on);
+
+static struct rk29camera_platform_data rk_camera_platform_data = {
+    .io_init = rk_sensor_io_init,
+    .io_deinit = rk_sensor_io_deinit,
+    .sensor_ioctrl = rk_sensor_ioctrl,
+    .sensor_register = rk_sensor_register,
+
+};
+
+
+static u64 rockchip_device_camera_dmamask = 0xffffffffUL;
+#if RK_SUPPORT_CIF0
+static struct resource rk_camera_resource_host_0[2] = {};
+#endif
+#if RK_SUPPORT_CIF1
+static struct resource rk_camera_resource_host_1[2] = {};
+#endif
+
+#if RK_SUPPORT_CIF0
+ struct platform_device rk_device_camera_host_0 = {
+	.name		  = RK29_CAM_DRV_NAME,
+	.id 	  = RK_CAM_PLATFORM_DEV_ID_0,				// This is used to put cameras on this interface 
+	.num_resources= 2,
+	.resource	  = rk_camera_resource_host_0,//yzm
+	.dev			= {
+		.dma_mask = &rockchip_device_camera_dmamask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data	= &rk_camera_platform_data,
+	}
+};
+#endif
+
+#if RK_SUPPORT_CIF1
+ struct platform_device rk_device_camera_host_1 = {
+	.name		  = RK29_CAM_DRV_NAME,
+	.id 	  = RK_CAM_PLATFORM_DEV_ID_1,				// This is used to put cameras on this interface 
+	.num_resources	  = ARRAY_SIZE(rk_camera_resource_host_1),
+	.resource	  = rk_camera_resource_host_1,//yzm
+	.dev			= {
+		.dma_mask = &rockchip_device_camera_dmamask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data	= &rk_camera_platform_data,
+	}
+};
+#endif
+
+
+
+static const struct of_device_id of_match_cif[] = {
+    { .compatible = "rockchip,cif" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of,of_match_cif);
+static struct platform_driver rk_cif_driver =
+{
+    .driver 	= {
+        .name	= RK3288_CIF_NAME,              
+		.owner = THIS_MODULE,
+        .of_match_table = of_match_ptr(of_match_cif),
+    },
+    .probe		= rk_dts_cif_probe,
+    .remove		= rk_dts_cif_remove,
+};
+
+static const struct of_device_id of_match_sensor[] = {
+    { .compatible = "rockchip,sensor" },
+};
+MODULE_DEVICE_TABLE(of,of_match_sensor);
+static struct platform_driver rk_sensor_driver =
+{
+    .driver 	= {
+        .name	= RK3288_SENSOR_NAME,              
+		.owner  = THIS_MODULE,
+        .of_match_table = of_match_ptr(of_match_sensor),
+    },
+    .probe		= rk_dts_sensor_probe,
+    .remove		= rk_dts_sensor_remove,
+};
+
+//************yzm***************
+
+static int rk_dts_sensor_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+static int	rk_dts_sensor_probe(struct platform_device *pdev)
+{
+	struct device_node *np, *cp;
+	int sensor_num = 0;
+	struct device *dev = &pdev->dev;
+	struct rkcamera_platform_data *new_camera_list;
+	
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+	np = dev->of_node;
+	if (!np)
+		return -ENODEV;
+	
+	for_each_child_of_node(np, cp) {
+		u32 flash_attach,mir,i2c_rata,i2c_chl,i2c_add,cif_chl,mclk_rate,is_front;
+		u32 resolution,pwdn_info,powerup_sequence;
+		
+		u32	powerdown = INVALID_GPIO,power = INVALID_GPIO,reset = INVALID_GPIO;
+		u32 af = INVALID_GPIO,flash = INVALID_GPIO;
+		struct rkcamera_platform_data *new_camera; 
+		new_camera = kzalloc(sizeof(struct rkcamera_platform_data),GFP_KERNEL);
+		if(!sensor_num)
+		{			
+			new_camera_head = new_camera;
+			rk_camera_platform_data.register_dev_new = new_camera_head;
+			new_camera_list = new_camera;
+		}
+		sensor_num ++;
+		new_camera_list->next_camera = new_camera;
+		new_camera_list = new_camera;
+	
+		if (of_property_read_u32(cp, "flash_attach", &flash_attach)) {
+				printk("%s flash_attach %d \n", cp->name, flash_attach);
+		}
+		if (of_property_read_u32(cp, "mir", &mir)) {
+				printk("%s mir %d \n", cp->name, mir);
+		}
+		if (of_property_read_u32(cp, "i2c_rata", &i2c_rata)) {
+				printk("%s i2c_rata %d \n", cp->name, i2c_rata);
+		}
+		if (of_property_read_u32(cp, "i2c_chl", &i2c_chl)) {
+				printk("%s i2c_chl %d \n", cp->name, i2c_chl);
+		}
+		if (of_property_read_u32(cp, "cif_chl", &cif_chl)) {
+				printk("%s cif_chl %d \n", cp->name, cif_chl);
+		}
+		if (of_property_read_u32(cp, "mclk_rate", &mclk_rate)) {
+				printk("%s mclk_rate %d \n", cp->name, mclk_rate);
+		}
+		if (of_property_read_u32(cp, "is_front", &is_front)) {
+				printk("%s is_front %d \n", cp->name, is_front);
+		}
+		if (of_property_read_u32(cp, "rockchip,powerdown", &powerdown)) {
+				printk("%s:Get %s rockchip,powerdown failed!\n",__func__, cp->name);				
+		}
+		if (of_property_read_u32(cp, "rockchip,power", &power)) {
+				printk("%s:Get %s rockchip,power failed!\n",__func__, cp->name);				
+		}
+		if (of_property_read_u32(cp, "rockchip,reset", &reset)) {
+				printk("%s:Get %s rockchip,reset failed!\n",__func__, cp->name);				
+		}
+		if (of_property_read_u32(cp, "rockchip,af", &af)) {
+				printk("%s:Get %s rockchip,af failed!\n",__func__, cp->name);				
+		}
+		if (of_property_read_u32(cp, "rockchip,flash", &flash)) {
+				printk("%s:Get %s rockchip,flash failed!\n",__func__, cp->name);				
+		}
+		if (of_property_read_u32(cp, "i2c_add", &i2c_add)) {
+				printk("%s i2c_add %d \n", cp->name, i2c_add);
+		}
+		if (of_property_read_u32(cp, "resolution", &resolution)) {
+				printk("%s resolution %d \n", cp->name, resolution);
+		}
+		if (of_property_read_u32(cp, "pwdn_info", &pwdn_info)) {
+				printk("%s pwdn_info %d \n", cp->name, pwdn_info);
+		}
+		if (of_property_read_u32(cp, "powerup_sequence", &powerup_sequence)) {
+				printk("%s powerup_sequence %d \n", cp->name, powerup_sequence);
+		}
+
+		strcpy(new_camera->dev.i2c_cam_info.type, cp->name);
+		new_camera->dev.i2c_cam_info.addr = i2c_add>>1;
+		new_camera->dev.desc_info.host_desc.bus_id = RK29_CAM_PLATFORM_DEV_ID+cif_chl;//yzm
+		new_camera->dev.desc_info.host_desc.i2c_adapter_id = i2c_chl;//yzm
+		new_camera->dev.desc_info.host_desc.module_name = cp->name;//const
+		new_camera->dev.device_info.name = "soc-camera-pdrv";
+		if(is_front)
+			sprintf(new_camera->dev_name,"%s_%s",cp->name,"front");
+		else
+			sprintf(new_camera->dev_name,"%s_%s",cp->name,"back");
+		new_camera->dev.device_info.dev.init_name =(const char*)&new_camera->dev_name[0];
+		new_camera->io.gpio_reset = reset;
+		new_camera->io.gpio_powerdown = powerdown;
+		new_camera->io.gpio_power = power;
+		new_camera->io.gpio_af = af;
+		new_camera->io.gpio_flash = flash;
+		new_camera->io.gpio_flag = ((INVALID_GPIO&0x01)<<RK29_CAM_POWERACTIVE_BITPOS)|((INVALID_GPIO&0x01)<<RK29_CAM_RESETACTIVE_BITPOS)|((pwdn_info&0x01)<<RK29_CAM_POWERDNACTIVE_BITPOS);
+		new_camera->orientation = INVALID_GPIO;
+		new_camera->resolution = resolution;
+		new_camera->mirror = mir;
+		new_camera->i2c_rate = i2c_rata;
+		new_camera->flash = flash_attach;
+		new_camera->pwdn_info = ((pwdn_info&0x10)|0x01);
+		new_camera->powerup_sequence = powerup_sequence;
+		new_camera->mclk_rate = mclk_rate;
+		new_camera->of_node = cp;
+			
+		//	device = container_of(&(new_camera[sensor_num].dev.desc_info),rk_camera_device_register_info_t,desc_info);
+		//	debug_printk( "sensor num %d ,desc_info point %p +++++++\n",sensor_num,&(new_camera.dev.desc_info));
+		//	debug_printk( "sensor num %d ,dev %p +++++++\n",sensor_num,&(new_camera.dev));
+		//	debug_printk( "sensor num %d ,device point %p +++++++\n",sensor_num,device);
+		    debug_printk( "******************* /n power = %x\n", power);
+			debug_printk( "******************* /n powerdown = %x\n", powerdown);
+			debug_printk( "******************* /n i2c_add = %x\n", new_camera->dev.i2c_cam_info.addr << 1);
+			debug_printk( "******************* /n i2c_chl = %d\n", new_camera->dev.desc_info.host_desc.i2c_adapter_id);
+			debug_printk( "******************* /n init_name = %s\n", new_camera->dev.device_info.dev.init_name);
+			debug_printk( "******************* /n dev_name = %s\n", new_camera->dev_name);
+			debug_printk( "******************* /n module_name = %s\n", new_camera->dev.desc_info.host_desc.module_name);
+	};
+	new_camera_list->next_camera = NULL;
+	return 0;
+}
+	
+static int rk_dts_cif_remove(struct platform_device *pdev)
+{
+	 return 0;
+}
+	
+static int rk_dts_cif_probe(struct platform_device *pdev) //yzm
+{
+	int irq,err;
+	struct device *dev = &pdev->dev;
+		
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	
+	rk_camera_platform_data.cif_dev = &pdev->dev;
+	
+	err = of_address_to_resource(dev->of_node, 0, &rk_camera_resource_host_0[0]);
+	if (err < 0){
+		printk(KERN_EMERG "Get register resource from %s platform device failed!",pdev->name);
+		return -ENODEV;
+	}
+	rk_camera_resource_host_0[0].flags = IORESOURCE_MEM;
+	//map irqs
+	irq = irq_of_parse_and_map(dev->of_node, 0);
+	if (irq < 0) {
+		printk(KERN_EMERG "Get irq resource from %s platform device failed!",pdev->name);
+		return -ENODEV;;
+	}
+	rk_camera_resource_host_0[1].start = irq;
+	rk_camera_resource_host_0[1].end   = irq;
+	rk_camera_resource_host_0[1].flags = IORESOURCE_IRQ;
+	//debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n res = [%x--%x] \n",rk_camera_resource_host_0[0].start , rk_camera_resource_host_0[0].end);
+	//debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n irq_num = %d\n",irq);
+	return 0;
+}
+	
+static int rk_cif_sensor_init(void)
+{
+	
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+	platform_driver_register(&rk_cif_driver);	
+		
+	platform_driver_register(&rk_sensor_driver);	
+
+	return 0;
+}
+	
+
+static int sensor_power_default_cb (struct rk29camera_gpio_res *res, int on)
+{
+    int camera_power = res->gpio_power;
+    int camera_ioflag = res->gpio_flag;
+    int camera_io_init = res->gpio_init;
+    int ret = 0;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    
+    if (camera_power != INVALID_GPIO)  {
+		if (camera_io_init & RK29_CAM_POWERACTIVE_MASK) {
+            if (on) {
+            	//gpio_set_value(camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+				gpio_direction_output(camera_power,1);
+				dprintk("%s PowerPin=%d ..PinLevel = %x",res->dev_name, camera_power, ((camera_ioflag&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+    			msleep(10);
+    		} else {
+    			//gpio_set_value(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+				gpio_direction_output(camera_power,0);
+				dprintk("%s PowerPin=%d ..PinLevel = %x",res->dev_name, camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+    		}
+		} else {
+			ret = RK29_CAM_EIO_REQUESTFAIL;
+			eprintk("%s PowerPin=%d request failed!", res->dev_name,camera_power);
+	    }        
+    } else {
+		ret = RK29_CAM_EIO_INVALID;
+    } 
+
+    return ret;
+}
+
+static int sensor_reset_default_cb (struct rk29camera_gpio_res *res, int on)
+{
+    int camera_reset = res->gpio_reset;
+    int camera_ioflag = res->gpio_flag;
+    int camera_io_init = res->gpio_init;  
+    int ret = 0;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    
+    if (camera_reset != INVALID_GPIO) {
+		if (camera_io_init & RK29_CAM_RESETACTIVE_MASK) {
+			if (on) {
+	        	gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+	        	dprintk("%s ResetPin=%d ..PinLevel = %x",res->dev_name,camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+			} else {
+				gpio_set_value(camera_reset,(((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+        		dprintk("%s ResetPin= %d..PinLevel = %x",res->dev_name, camera_reset, (((~camera_ioflag)&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+	        }
+		} else {
+			ret = RK29_CAM_EIO_REQUESTFAIL;
+			eprintk("%s ResetPin=%d request failed!", res->dev_name,camera_reset);
+		}
+    } else {
+		ret = RK29_CAM_EIO_INVALID;
+    }
+
+    return ret;
+}
+
+static int sensor_powerdown_default_cb (struct rk29camera_gpio_res *res, int on)
+{
+    int camera_powerdown = res->gpio_powerdown;
+    int camera_ioflag = res->gpio_flag;
+    int camera_io_init = res->gpio_init;  
+    int ret = 0;    
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
+    if (camera_powerdown != INVALID_GPIO) {
+		if (camera_io_init & RK29_CAM_POWERDNACTIVE_MASK) {
+			if (on) {
+	        	gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+	        	dprintk("%s PowerDownPin=%d ..PinLevel = %x" ,res->dev_name,camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+			} else {
+				gpio_set_value(camera_powerdown,(((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+        		dprintk("%s PowerDownPin= %d..PinLevel = %x" ,res->dev_name, camera_powerdown, (((~camera_ioflag)&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+	        }
+		} else {
+			ret = RK29_CAM_EIO_REQUESTFAIL;
+			dprintk("%s PowerDownPin=%d request failed!", res->dev_name,camera_powerdown);
+		}
+    } else {
+		ret = RK29_CAM_EIO_INVALID;
+    }
+    return ret;
+}
+
+
+static int sensor_flash_default_cb (struct rk29camera_gpio_res *res, int on)
+{
+    int camera_flash = res->gpio_flash;
+    int camera_ioflag = res->gpio_flag;
+    int camera_io_init = res->gpio_init;  
+    int ret = 0;    
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
+    if (camera_flash != INVALID_GPIO) {
+		if (camera_io_init & RK29_CAM_FLASHACTIVE_MASK) {
+            switch (on)
+            {
+                case Flash_Off:
+                {
+                    gpio_set_value(camera_flash,(((~camera_ioflag)&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+        		    dprintk("%s FlashPin= %d..PinLevel = %x", res->dev_name, camera_flash, (((~camera_ioflag)&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS)); 
+        		    break;
+                }
+
+                case Flash_On:
+                {
+                    gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    dprintk("%s FlashPin=%d ..PinLevel = %x", res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    break;
+                }
+
+                case Flash_Torch:
+                {
+                    gpio_set_value(camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    dprintk("%s FlashPin=%d ..PinLevel = %x", res->dev_name,camera_flash, ((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+	        	    break;
+                }
+
+                default:
+                {
+                    eprintk("%s Flash command(%d) is invalidate", res->dev_name,on);
+                    break;
+                }
+            }
+		} else {
+			ret = RK29_CAM_EIO_REQUESTFAIL;
+			eprintk("%s FlashPin=%d request failed!", res->dev_name,camera_flash);
+		}
+    } else {
+		ret = RK29_CAM_EIO_INVALID;
+    }
+    return ret;
+}
+
+static int sensor_afpower_default_cb (struct rk29camera_gpio_res *res, int on)
+{
+	int ret = 0;   
+	int camera_af = res->gpio_af;
+	
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	
+	if (camera_af != INVALID_GPIO) {
+		gpio_set_value(camera_af, on);
+	}
+
+	return ret;
+}
+
+/*
+static void rk29_sensor_fps_get(int idx, unsigned int *val, int w, int h)
+{
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
+    switch (idx)
+    {
+        #ifdef CONFIG_SENSOR_0
+        case 0:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_0;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_0
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_0;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_0;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_0;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_0;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_0;
+            } else if ((w==800) && (h==600)) {
+                *val = CONFIG_SENSOR_SVGA_FPS_FIXED_0;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_0;
+            }
+            break;
+        }
+        #endif
+        #ifdef CONFIG_SENSOR_1
+        case 1:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_1;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_1
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_1;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_1;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_1;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_1;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_1;
+            } else if ((w==800) && (h==600)) {
+                *val = CONFIG_SENSOR_SVGA_FPS_FIXED_1;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_1;
+            }
+            break;
+        }
+        #endif
+        #ifdef CONFIG_SENSOR_01
+        case 2:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_01;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_01
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_01;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_01;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_01;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_01;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_01;
+            } else if ((w==800) && (h==600)) {
+                *val = CONFIG_SENSOR_SVGA_FPS_FIXED_01;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_01;
+            }
+            break;
+        }
+        #endif
+        #ifdef CONFIG_SENSOR_02
+        case 3:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_02;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_02
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_02;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_02;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_02;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_02;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_02;
+            } else if ((w==800) && (h==600)) {
+                *val = CONFIG_SENSOR_SVGA_FPS_FIXED_02;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_02;
+            }
+            break;
+        }
+        #endif
+        
+        #ifdef CONFIG_SENSOR_11
+        case 4:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_11;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_11
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_11;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_11;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_11;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_11;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_11;
+            } else if ((w==800) && (h==600)) {
+                *val = CONFIG_SENSOR_SVGA_FPS_FIXED_11;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_11;
+            }
+            break;
+        }
+        #endif
+        #ifdef CONFIG_SENSOR_12
+        case 5:
+        {
+            if ((w==176) && (h==144)) {
+                *val = CONFIG_SENSOR_QCIF_FPS_FIXED_12;
+            #ifdef CONFIG_SENSOR_240X160_FPS_FIXED_12
+            } else if ((w==240) && (h==160)) {
+                *val = CONFIG_SENSOR_240X160_FPS_FIXED_12;
+            #endif
+            } else if ((w==320) && (h==240)) {
+                *val = CONFIG_SENSOR_QVGA_FPS_FIXED_12;
+            } else if ((w==352) && (h==288)) {
+                *val = CONFIG_SENSOR_CIF_FPS_FIXED_12;
+            } else if ((w==640) && (h==480)) {
+                *val = CONFIG_SENSOR_VGA_FPS_FIXED_12;
+            } else if ((w==720) && (h==480)) {
+                *val = CONFIG_SENSOR_480P_FPS_FIXED_12;
+            } else if ((w==800) && (h==600)) {
+                *val = CONFIG_SENSOR_SVGA_FPS_FIXED_12;
+            } else if ((w==1280) && (h==720)) {
+                *val = CONFIG_SENSOR_720P_FPS_FIXED_12;
+            }
+            break;
+        }
+        #endif
+        default:
+            eprintk(" sensor-%d have not been define in board file!",idx);
+    }
+}
+*/
+static int _rk_sensor_io_init_(struct rk29camera_gpio_res *gpio_res,struct device_node *of_node)
+{
+    int ret = 0;
+    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
+	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO;
+	unsigned int camera_af = INVALID_GPIO,camera_ioflag;
+    struct rk29camera_gpio_res *io_res;
+    bool io_requested_in_camera;
+	enum of_gpio_flags flags;
+	
+	struct rkcamera_platform_data *new_camera;//yzm
+	//struct device_node *parent_node;
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
+    camera_reset = gpio_res->gpio_reset;
+	camera_power = gpio_res->gpio_power;
+	camera_powerdown = gpio_res->gpio_powerdown;
+	camera_flash = gpio_res->gpio_flash;
+	camera_af = gpio_res->gpio_af;	
+	camera_ioflag = gpio_res->gpio_flag;
+	gpio_res->gpio_init = 0;
+
+    if (camera_power != INVALID_GPIO) {
+		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/ camera_power  = %x\n", camera_power );
+
+		camera_power = of_get_named_gpio_flags(of_node,"rockchip,power",0,&flags);//yzm
+		gpio_res->gpio_power = camera_power;//yzm,将io的完整信息传回去。
+
+		
+		//dev->of_node = parent_node;//将dev->of_node还原
+		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/ camera_power  = %x\n", camera_power );  
+
+		ret = gpio_request(camera_power, "camera power");    //申请名为"camera power"的io管脚
+        if (ret) {
+			
+            io_requested_in_camera = false;
+
+            if (io_requested_in_camera==false) {
+
+				new_camera = new_camera_head;
+                while (new_camera != NULL) {
+                    io_res = &new_camera->io;
+                    if (io_res->gpio_init & RK29_CAM_POWERACTIVE_MASK) {
+                        if (io_res->gpio_power == camera_power)
+                            io_requested_in_camera = true;    
+                    }
+                    new_camera = new_camera->next_camera;
+                }
+
+            }
+            
+            if (io_requested_in_camera==false) {
+                printk( "%s power pin(%d) init failed\n", gpio_res->dev_name,camera_power);
+                goto _rk_sensor_io_init_end_;
+            } else {
+                ret =0;
+            }
+        }
+      
+		gpio_res->gpio_init |= RK29_CAM_POWERACTIVE_MASK;
+        gpio_set_value(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+        gpio_direction_output(camera_power, (((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+
+		dprintk("%s power pin(%d) init success(0x%x)" ,gpio_res->dev_name,camera_power,(((~camera_ioflag)&RK29_CAM_POWERACTIVE_MASK)>>RK29_CAM_POWERACTIVE_BITPOS));
+
+    }
+/*
+    if (camera_reset != INVALID_GPIO) {
+        ret = gpio_request(camera_reset, "camera reset");
+        if (ret) {
+            io_requested_in_camera = false;
+            for (i=0; i<RK_CAM_NUM; i++) {
+                io_res = &rk_camera_platform_data.gpio_res[i];
+                if (io_res->gpio_init & RK29_CAM_RESETACTIVE_MASK) {
+                    if (io_res->gpio_reset == camera_reset)
+                        io_requested_in_camera = true;    
+                }
+            }
+
+            if (io_requested_in_camera==false) {
+                i=0;
+                while (strstr(new_camera[i].dev_name,"end")==NULL) {
+                    io_res = &new_camera[i].io;
+                    if (io_res->gpio_init & RK29_CAM_RESETACTIVE_MASK) {
+                        if (io_res->gpio_reset == camera_reset)
+                            io_requested_in_camera = true;    
+                    }
+                    i++;
+                }
+            }
+            
+            if (io_requested_in_camera==false) {
+                eprintk("%s reset pin(%d) init failed" ,gpio_res->dev_name,camera_reset);
+                goto _rk_sensor_io_init_end_;
+            } else {
+                ret =0;
+            }
+        }
+
+        if (rk_camera_platform_data.iomux(camera_reset,dev) < 0) {
+            ret = -1;
+            eprintk("%s reset pin(%d) iomux init failed", gpio_res->dev_name,camera_reset);
+            goto _rk_sensor_io_init_end_;
+        }
+        
+		gpio_res->gpio_init |= RK29_CAM_RESETACTIVE_MASK;
+        gpio_set_value(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+        gpio_direction_output(camera_reset, ((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+
+		dprintk("%s reset pin(%d) init success(0x%x)" ,gpio_res->dev_name,camera_reset,((camera_ioflag&RK29_CAM_RESETACTIVE_MASK)>>RK29_CAM_RESETACTIVE_BITPOS));
+
+    }
+*/
+	if (camera_powerdown != INVALID_GPIO) {
+		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/ camera_powerdown  = %x\n", camera_powerdown );
+
+		camera_powerdown = of_get_named_gpio_flags(of_node,"rockchip,powerdown",0,&flags);//yzm
+		gpio_res->gpio_powerdown = camera_powerdown;//yzm,将io的完整信息传回去。
+
+		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/ camera_powerdown  = %x\n", camera_powerdown );  
+		ret = gpio_request(camera_powerdown, "camera powerdown");
+        if (ret) {
+            io_requested_in_camera = false;
+
+            if (io_requested_in_camera==false) {
+				
+                new_camera = new_camera_head;
+                while (new_camera != NULL) {
+                    io_res = &new_camera->io;
+                    if (io_res->gpio_init & RK29_CAM_POWERDNACTIVE_MASK) {
+                        if (io_res->gpio_powerdown == camera_powerdown)
+                            io_requested_in_camera = true;    
+                    }
+                    new_camera = new_camera->next_camera;
+                }
+            }
+            
+            if (io_requested_in_camera==false) {
+                eprintk("%s powerdown pin(%d) init failed",gpio_res->dev_name,camera_powerdown);
+                goto _rk_sensor_io_init_end_;
+            } else {
+                ret =0;
+            }
+        }
+		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s(),iomux is ok\n", __FILE__, __LINE__,__FUNCTION__);
+        
+		gpio_res->gpio_init |= RK29_CAM_POWERDNACTIVE_MASK;
+        gpio_set_value(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+        gpio_direction_output(camera_powerdown, ((camera_ioflag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+
+		dprintk("%s powerdown pin(%d) init success(0x%x)" ,gpio_res->dev_name,camera_powerdown,((camera_ioflag&RK29_CAM_POWERDNACTIVE_BITPOS)>>RK29_CAM_POWERDNACTIVE_BITPOS));
+
+    }
+/*
+	if (camera_flash != INVALID_GPIO) {
+        ret = gpio_request(camera_flash, "camera flash");
+        if (ret) {
+            io_requested_in_camera = false;
+            for (i=0; i<RK_CAM_NUM; i++) {
+                io_res = &rk_camera_platform_data.gpio_res[i];
+                if (io_res->gpio_init & RK29_CAM_POWERDNACTIVE_MASK) {
+                    if (io_res->gpio_powerdown == camera_powerdown)
+                        io_requested_in_camera = true;    
+                }
+            }
+
+            if (io_requested_in_camera==false) {
+                i=0;
+                while (strstr(new_camera[i].dev_name,"end")==NULL) {
+                    io_res = &new_camera[i].io;
+                    if (io_res->gpio_init & RK29_CAM_POWERDNACTIVE_MASK) {
+                        if (io_res->gpio_powerdown == camera_powerdown)
+                            io_requested_in_camera = true;    
+                    }
+                    i++;
+                }
+            }
+            
+            ret = 0;        //ddl@rock-chips.com : flash is only a function, sensor is also run;
+            if (io_requested_in_camera==false) {
+                eprintk("%s flash pin(%d) init failed",gpio_res->dev_name,camera_flash);
+                goto _rk_sensor_io_init_end_;
+            }
+        }
+
+
+        if (rk_camera_platform_data.iomux(camera_flash,dev) < 0) {
+            printk("%s flash pin(%d) iomux init failed\n",gpio_res->dev_name,camera_flash);                            
+        }
+        
+		gpio_res->gpio_init |= RK29_CAM_FLASHACTIVE_MASK;
+        gpio_set_value(camera_flash, ((~camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));   //  falsh off 
+        gpio_direction_output(camera_flash, ((~camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+
+		dprintk("%s flash pin(%d) init success(0x%x)",gpio_res->dev_name, camera_flash,((camera_ioflag&RK29_CAM_FLASHACTIVE_MASK)>>RK29_CAM_FLASHACTIVE_BITPOS));
+
+    }  
+
+
+	if (camera_af != INVALID_GPIO) {
+		ret = gpio_request(camera_af, "camera af");
+		if (ret) {
+			io_requested_in_camera = false;
+			for (i=0; i<RK_CAM_NUM; i++) {
+				io_res = &rk_camera_platform_data.gpio_res[i];
+				if (io_res->gpio_init & RK29_CAM_AFACTIVE_MASK) {
+					if (io_res->gpio_af == camera_af)
+						io_requested_in_camera = true;	  
+				}
+			}
+
+			if (io_requested_in_camera==false) {
+				i=0;
+				while (strstr(new_camera[i].dev_name,"end")==NULL) {
+					io_res = &new_camera[i].io;
+					if (io_res->gpio_init & RK29_CAM_AFACTIVE_MASK) {
+						if (io_res->gpio_af == camera_af)
+							io_requested_in_camera = true;	  
+					}
+					i++;
+				}
+			}
+			
+			if (io_requested_in_camera==false) {
+				eprintk("%s af pin(%d) init failed",gpio_res->dev_name,camera_af);
+				goto _rk_sensor_io_init_end_;
+			} else {
+                ret =0;
+            }
+			
+		}
+
+
+		if (rk_camera_platform_data.iomux(camera_af,dev) < 0) {
+			 ret = -1;
+			eprintk("%s af pin(%d) iomux init failed\n",gpio_res->dev_name,camera_af); 	
+            goto _rk_sensor_io_init_end_;			
+		}
+		
+		gpio_res->gpio_init |= RK29_CAM_AFACTIVE_MASK;
+		//gpio_direction_output(camera_af, ((camera_ioflag&RK29_CAM_AFACTIVE_MASK)>>RK29_CAM_AFACTIVE_BITPOS));
+		dprintk("%s af pin(%d) init success",gpio_res->dev_name, camera_af);
+
+	}
+*/
+
+	
+_rk_sensor_io_init_end_:
+    return ret;
+
+}
+
+static int _rk_sensor_io_deinit_(struct rk29camera_gpio_res *gpio_res)
+{
+    unsigned int camera_reset = INVALID_GPIO, camera_power = INVALID_GPIO;
+	unsigned int camera_powerdown = INVALID_GPIO, camera_flash = INVALID_GPIO,camera_af = INVALID_GPIO;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+    
+    camera_reset = gpio_res->gpio_reset;
+    camera_power = gpio_res->gpio_power;
+	camera_powerdown = gpio_res->gpio_powerdown;
+    camera_flash = gpio_res->gpio_flash;
+    camera_af = gpio_res->gpio_af;
+
+	if (gpio_res->gpio_init & RK29_CAM_POWERACTIVE_MASK) {
+	    if (camera_power != INVALID_GPIO) {
+	        gpio_direction_input(camera_power);
+	        gpio_free(camera_power);
+	    }
+	}
+
+	if (gpio_res->gpio_init & RK29_CAM_RESETACTIVE_MASK) {
+	    if (camera_reset != INVALID_GPIO)  {
+	        gpio_direction_input(camera_reset);
+	        gpio_free(camera_reset);
+	    }
+	}
+
+	if (gpio_res->gpio_init & RK29_CAM_POWERDNACTIVE_MASK) {
+	    if (camera_powerdown != INVALID_GPIO)  {
+	        gpio_direction_input(camera_powerdown);
+	        gpio_free(camera_powerdown);
+	    }
+	}
+
+	if (gpio_res->gpio_init & RK29_CAM_FLASHACTIVE_MASK) {
+	    if (camera_flash != INVALID_GPIO)  {
+	        gpio_direction_input(camera_flash);
+	        gpio_free(camera_flash);
+	    }
+	}
+	if (gpio_res->gpio_init & RK29_CAM_AFACTIVE_MASK) {
+	    if (camera_af != INVALID_GPIO)  {
+	       // gpio_direction_input(camera_af);
+	        gpio_free(camera_af);
+	    }
+	}	
+	gpio_res->gpio_init = 0;
+	
+    return 0;
+}
+
+static int rk_sensor_io_init(void)
+{
+	static bool is_init = false;
+	
+	struct rkcamera_platform_data *new_camera;
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    if(is_init) {		
+		return 0;
+	} else {
+		is_init = true;
+	}
+    
+    if (sensor_ioctl_cb.sensor_power_cb == NULL)
+        sensor_ioctl_cb.sensor_power_cb = sensor_power_default_cb;
+    if (sensor_ioctl_cb.sensor_reset_cb == NULL)
+        sensor_ioctl_cb.sensor_reset_cb = sensor_reset_default_cb;
+    if (sensor_ioctl_cb.sensor_powerdown_cb == NULL)
+        sensor_ioctl_cb.sensor_powerdown_cb = sensor_powerdown_default_cb;
+    if (sensor_ioctl_cb.sensor_flash_cb == NULL)
+        sensor_ioctl_cb.sensor_flash_cb = sensor_flash_default_cb;
+    if (sensor_ioctl_cb.sensor_af_cb == NULL)
+        sensor_ioctl_cb.sensor_af_cb = sensor_afpower_default_cb;	
+
+	/**********yzm*********/
+	new_camera = new_camera_head;
+	while(new_camera != NULL)
+	{
+		if (_rk_sensor_io_init_(&new_camera->io,new_camera->of_node)<0)
+            _rk_sensor_io_deinit_(&new_camera->io);
+		new_camera = new_camera->next_camera;
+	}
+	return 0;
+}
+
+static int rk_sensor_io_deinit(int sensor)
+{
+	struct rkcamera_platform_data *new_camera;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	new_camera = new_camera_head;
+	while(new_camera != NULL)
+	{
+		_rk_sensor_io_deinit_(&new_camera->io);
+		new_camera = new_camera->next_camera;
+	}
+
+    return 0;
+}
+static int rk_sensor_ioctrl(struct device *dev,enum rk29camera_ioctrl_cmd cmd, int on)
+{
+    struct rk29camera_gpio_res *res = NULL;
+    struct rkcamera_platform_data *new_cam_dev = NULL;
+	struct rk29camera_platform_data* plat_data = &rk_camera_platform_data;
+    int ret = RK29_CAM_IO_SUCCESS,i = 0;
+    //struct soc_camera_link *dev_icl = NULL;//yzm
+	struct soc_camera_desc *dev_icl = NULL;//yzm
+	struct rkcamera_platform_data *new_camera;
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+    if (res == NULL) {
+		new_camera = new_camera_head;
+		while(new_camera != NULL)
+		{
+            if (strcmp(new_camera->dev_name, dev_name(dev)) == 0) {
+                res = (struct rk29camera_gpio_res *)&new_camera->io; 
+                new_cam_dev = &new_camera[i];
+                //dev_icl = &new_camera[i].dev.link_info;
+				 dev_icl = &new_camera->dev.desc_info;//yzm
+                break;
+            }
+            new_camera = new_camera->next_camera;;
+        }		
+    }
+    
+    if (res == NULL) {
+        eprintk("%s is not regisiterd in rk29_camera_platform_data!!",dev_name(dev));
+        ret = RK29_CAM_EIO_INVALID;
+        goto rk_sensor_ioctrl_end;
+    }
+	
+	switch (cmd)
+ 	{
+ 		case Cam_Power:
+		{
+			if (sensor_ioctl_cb.sensor_power_cb) {
+                ret = sensor_ioctl_cb.sensor_power_cb(res, on);   
+                ret = (ret != RK29_CAM_EIO_INVALID)?ret:0;     /* ddl@rock-chips.com: v0.1.1 */ 
+			} else {
+                eprintk("sensor_ioctl_cb.sensor_power_cb is NULL");
+                WARN_ON(1);
+			}
+
+			printk("ret: %d\n",ret);
+			break;
+		}
+		case Cam_Reset:
+		{
+			if (sensor_ioctl_cb.sensor_reset_cb) {
+                ret = sensor_ioctl_cb.sensor_reset_cb(res, on);
+
+                ret = (ret != RK29_CAM_EIO_INVALID)?ret:0;
+			} else {
+                eprintk( "sensor_ioctl_cb.sensor_reset_cb is NULL");
+                WARN_ON(1);
+			}
+			break;
+		}
+
+		case Cam_PowerDown:
+		{
+			if (sensor_ioctl_cb.sensor_powerdown_cb) {
+                ret = sensor_ioctl_cb.sensor_powerdown_cb(res, on);
+			} else {
+                eprintk( "sensor_ioctl_cb.sensor_powerdown_cb is NULL");
+                WARN_ON(1);
+			}
+			break;
+		}
+
+		case Cam_Flash:
+		{
+			if (sensor_ioctl_cb.sensor_flash_cb) {
+                ret = sensor_ioctl_cb.sensor_flash_cb(res, on);
+			} else {
+                eprintk( "sensor_ioctl_cb.sensor_flash_cb is NULL!");
+                WARN_ON(1);
+			}
+			break;
+		}
+		
+		case Cam_Af:
+		{
+			if (sensor_ioctl_cb.sensor_af_cb) {
+                ret = sensor_ioctl_cb.sensor_af_cb(res, on);
+			} else {
+                eprintk( "sensor_ioctl_cb.sensor_af_cb is NULL!");
+                WARN_ON(1);
+			}
+			break;
+		}
+
+        case Cam_Mclk:
+        {
+            if (plat_data->sensor_mclk && dev_icl) {
+                //plat_data->sensor_mclk(dev_icl->bus_id,(on!=0)?1:0,on);
+				plat_data->sensor_mclk(dev_icl->host_desc.bus_id,(on!=0)?1:0,on);//yzm
+            } else { 
+                eprintk( "%s(%d): sensor_mclk(%p) or dev_icl(%p) is NULL",
+                    __FUNCTION__,__LINE__,plat_data->sensor_mclk,dev_icl);
+            }
+            break;
+        }
+        
+		default:
+		{
+			eprintk("%s cmd(0x%x) is unknown!",__FUNCTION__, cmd);
+			break;
+		}
+ 	}
+rk_sensor_ioctrl_end:
+    return ret;
+}
+
+static int rk_sensor_pwrseq(struct device *dev,int powerup_sequence, int on, int mclk_rate)
+{
+    int ret =0;
+    int i,powerup_type;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    
+    for (i=0; i<8; i++) {
+
+        if (on == 1)
+            powerup_type = SENSOR_PWRSEQ_GET(powerup_sequence,i);
+        else
+            powerup_type = SENSOR_PWRSEQ_GET(powerup_sequence,(7-i));
+        
+        switch (powerup_type)
+        {
+            case SENSOR_PWRSEQ_AVDD:
+            case SENSOR_PWRSEQ_DOVDD:
+            case SENSOR_PWRSEQ_DVDD:
+            case SENSOR_PWRSEQ_PWR:
+            {  
+                ret = rk_sensor_ioctrl(dev,Cam_Power, on);
+                if (ret<0) {
+                    eprintk("SENSOR_PWRSEQ_PWR failed");
+                } else { 
+                    msleep(10);
+                    dprintk("SensorPwrSeq-power: %d",on);
+                }
+                break;
+            }
+
+            case SENSOR_PWRSEQ_HWRST:
+            {
+                if(!on){
+                    rk_sensor_ioctrl(dev,Cam_Reset, 1);
+                }else{
+                    ret = rk_sensor_ioctrl(dev,Cam_Reset, 1);
+                    msleep(2);
+                    ret |= rk_sensor_ioctrl(dev,Cam_Reset, 0); 
+                }
+                if (ret<0) {
+                    eprintk("SENSOR_PWRSEQ_HWRST failed");
+                } else {
+                    dprintk("SensorPwrSeq-reset: %d",on);
+                }
+                break;
+            }
+
+            case SENSOR_PWRSEQ_PWRDN:
+            {     
+                ret = rk_sensor_ioctrl(dev,Cam_PowerDown, !on);
+                if (ret<0) {
+                    eprintk("SENSOR_PWRSEQ_PWRDN failed");
+                } else {
+                    dprintk("SensorPwrSeq-power down: %d",!on);
+                }
+                break;
+            }
+
+            case SENSOR_PWRSEQ_CLKIN:
+            {
+                ret = rk_sensor_ioctrl(dev,Cam_Mclk, (on?mclk_rate:on));
+                if (ret<0) {
+                    eprintk("SENSOR_PWRSEQ_CLKIN failed");
+                } else {
+                    dprintk("SensorPwrSeq-clock: %d",on);
+                }
+                break;
+            }
+
+            default:
+                break;
+        }
+        
+    } 
+
+    return ret;
+}
+
+static int rk_sensor_power(struct device *dev, int on)   //icd->pdev
+{
+    int powerup_sequence,mclk_rate;
+    
+    struct rk29camera_platform_data* plat_data = &rk_camera_platform_data;
+    struct rk29camera_gpio_res *dev_io = NULL;
+    struct rkcamera_platform_data *new_camera=NULL, *new_device=NULL;
+    bool real_pwroff = true;
+    int ret = 0;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    new_camera = plat_data->register_dev_new;    //new_camera[]
+    
+	while (new_camera != NULL) {//yzm
+    //while (strstr(new_camera->dev_name,"end")==NULL) {
+
+        if (new_camera->io.gpio_powerdown != INVALID_GPIO) {		//true
+            gpio_direction_output(new_camera->io.gpio_powerdown,
+                ((new_camera->io.gpio_flag&RK29_CAM_POWERDNACTIVE_MASK)>>RK29_CAM_POWERDNACTIVE_BITPOS));            
+        }
+
+		debug_printk( "new_camera->dev_name= %s \n", new_camera->dev_name);	//yzm
+		debug_printk( "dev_name(dev)= %s \n", dev_name(dev));	 //yzm
+		
+        if (strcmp(new_camera->dev_name,dev_name(dev))) {		//当不是打开的sensor时为TRUE
+			debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i\n", __FILE__, __LINE__);//yzm
+            if (sensor_ioctl_cb.sensor_powerdown_cb && on)
+            	{
+            		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i\n", __FILE__, __LINE__);//yzm
+                	sensor_ioctl_cb.sensor_powerdown_cb(&new_camera->io,1);
+            	}
+        } else {
+            new_device = new_camera;
+            dev_io = &new_camera->io;
+            debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i\n", __FILE__, __LINE__);//yzm
+            if (!Sensor_Support_DirectResume(new_camera->pwdn_info))
+                real_pwroff = true;			
+            else
+                real_pwroff = false;
+        }
+        //new_camera++;
+        new_camera = new_camera->next_camera;//yzm
+    }
+
+    if (new_device != NULL) {
+        powerup_sequence = new_device->powerup_sequence;
+        if ((new_device->mclk_rate == 24) || (new_device->mclk_rate == 48))
+            mclk_rate = new_device->mclk_rate*1000000;
+        else 
+            mclk_rate = 24000000;
+    } else {
+        powerup_sequence = sensor_PWRSEQ_DEFAULT;
+        mclk_rate = 24000000;
+    }
+        
+    if (on) {
+		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i\n", __FILE__, __LINE__);//yzm
+        rk_sensor_pwrseq(dev, powerup_sequence, on,mclk_rate);  
+    } else {
+        if (real_pwroff) {
+            if (rk_sensor_pwrseq(dev, powerup_sequence, on,mclk_rate)<0)    /* ddl@rock-chips.com: v0.1.5 */
+                goto PowerDown;
+            
+            /*ddl@rock-chips.com: all power down switch to Hi-Z after power off*/  //高阻态
+            new_camera = plat_data->register_dev_new;
+			while (new_camera != NULL) {//yzm
+            //while (strstr(new_camera->dev_name,"end")==NULL) {
+                if (new_camera->io.gpio_powerdown != INVALID_GPIO) {
+                    gpio_direction_input(new_camera->io.gpio_powerdown);            
+                }
+                new_camera->pwdn_info |= 0x01;
+                //new_camera++;
+                new_camera = new_camera->next_camera;//yzm
+            }
+        } else {  
+PowerDown:
+            rk_sensor_ioctrl(dev,Cam_PowerDown, !on);
+
+            rk_sensor_ioctrl(dev,Cam_Mclk, 0);
+        }
+
+        mdelay(10);/* ddl@rock-chips.com: v0.1.3 */
+    }
+    return ret;
+}
+#if 0
+static int rk_sensor_reset(struct device *dev)
+{
+#if 0
+	rk_sensor_ioctrl(dev,Cam_Reset,1);
+	msleep(2);
+	rk_sensor_ioctrl(dev,Cam_Reset,0);
+#else
+    /*
+    *ddl@rock-chips.com : the rest function invalidate, because this operate is put together in rk_sensor_power;
+    */
+#endif
+	return 0;
+}
+#endif
+static int rk_sensor_powerdown(struct device *dev, int on)
+{
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	return rk_sensor_ioctrl(dev,Cam_PowerDown,on);
+}
+
+int rk_sensor_register(void)
+{
+    int i;    
+	struct rkcamera_platform_data *new_camera;	
+	
+    i = 0;
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+	new_camera = new_camera_head;
+	
+	while (new_camera != NULL) {//yzm	
+        if (new_camera->dev.i2c_cam_info.addr == INVALID_VALUE) {
+            WARN(1, 
+                KERN_ERR "%s(%d): new_camera[%d] i2c addr is invalidate!",
+                __FUNCTION__,__LINE__,i);
+            continue;
+        }
+        sprintf(new_camera->dev_name,"%s_%d",new_camera->dev.device_info.dev.init_name,i+3);
+        new_camera->dev.device_info.dev.init_name =(const char*)&new_camera->dev_name[0];//转换成指针
+        new_camera->io.dev_name =(const char*)&new_camera->dev_name[0];
+        if (new_camera->orientation == INVALID_VALUE) {        //关于前后方向
+            if (strstr(new_camera->dev_name,"back")) {		           
+                new_camera->orientation = 90;
+            } else {
+                new_camera->orientation = 270;
+            }
+        }
+        /* ddl@rock-chips.com: v0.1.3 */
+        if ((new_camera->fov_h <= 0) || (new_camera->fov_h>360))
+            new_camera->fov_h = 100;
+        
+        if ((new_camera->fov_v <= 0) || (new_camera->fov_v>360))
+            new_camera->fov_v = 100;        
+
+		new_camera->dev.desc_info.subdev_desc.power = rk_sensor_power;//yzm
+		new_camera->dev.desc_info.subdev_desc.powerdown = rk_sensor_powerdown;//yzm
+		new_camera->dev.desc_info.host_desc.board_info =&new_camera->dev.i2c_cam_info; //yzm
+
+        new_camera->dev.device_info.id = i+6;//?? platform_device.id
+		new_camera->dev.device_info.dev.platform_data = &new_camera->dev.desc_info;//yzm
+		debug_printk("platform_data(desc_info) %p +++++++++++++\n",new_camera->dev.device_info.dev.platform_data);
+		new_camera->dev.desc_info.subdev_desc.drv_priv = &rk_camera_platform_data;//yzm
+
+        platform_device_register(&(new_camera->dev.device_info));
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);  
+debug_printk("new_camera = %p +++++++++++++\n",new_camera);
+debug_printk("new_camera->next_camera = %p +++++++++++++\n",new_camera->next_camera);
+
+        new_camera = new_camera->next_camera;
+    }
+	
+		return 0;
+}
diff --git a/arch/arm/mach-rockchip/rk_camera.h b/arch/arm/mach-rockchip/rk_camera.h
new file mode 100644
index 000000000000..c2ed4d44f004
--- /dev/null
+++ b/arch/arm/mach-rockchip/rk_camera.h
@@ -0,0 +1,634 @@
+/*
+    camera.h - PXA camera driver header file
+
+    Copyright (C) 2003, Intel Corporation
+    Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef __ASM_ARCH_CAMERA_RK_H_
+#define __ASM_ARCH_CAMERA_RK_H_
+
+#include <linux/videodev2.h>
+#include <media/soc_camera.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+
+#define RK29_CAM_PLATFORM_DEV_ID 33
+#define RK_CAM_PLATFORM_DEV_ID_0 RK29_CAM_PLATFORM_DEV_ID
+#define RK_CAM_PLATFORM_DEV_ID_1 (RK_CAM_PLATFORM_DEV_ID_0+1)
+#define INVALID_VALUE -1
+#ifndef INVALID_GPIO
+#define INVALID_GPIO INVALID_VALUE
+#endif
+#define RK29_CAM_IO_SUCCESS 0
+#define RK29_CAM_EIO_INVALID -3
+#define RK29_CAM_EIO_REQUESTFAIL -2
+
+#define RK29_CAM_POWERACTIVE_BITPOS	0x00
+#define RK29_CAM_RESETACTIVE_BITPOS	0x01
+#define RK29_CAM_POWERDNACTIVE_BITPOS 0x02
+#define RK29_CAM_FLASHACTIVE_BITPOS	0x03
+#define RK29_CAM_AFACTIVE_BITPOS	0x04
+
+#define RK_CAM_NUM 0 //YZM
+#define RK29_CAM_SUPPORT_NUMS  RK_CAM_NUM
+#define RK_CAM_SUPPORT_RESOLUTION 0x800000
+
+#define _CONS(a,b) a##b
+#define CONS(a,b) _CONS(a,b)
+
+#define _CONS4(a,b,c,d) a##b##c##d
+#define CONS4(a,b,c,d) _CONS4(a,b,c,d)
+
+#define __STR(x) #x
+#define _STR(x) __STR(x)
+#define STR(x) _STR(x)
+
+ 
+/*---------------- Camera Sensor Must Define Macro Begin  ------------------------*/
+
+#define RK29_CAM_SENSOR_OV7675 ov7675
+#define RK29_CAM_SENSOR_OV9650 ov9650
+#define RK29_CAM_SENSOR_OV2640 ov2640
+#define RK29_CAM_SENSOR_OV2655 ov2655
+#define RK29_CAM_SENSOR_OV2659 ov2659
+
+#define RK29_CAM_SENSOR_OV2660 ov2660 //yzm
+
+#define RK29_CAM_SENSOR_OV7690 ov7690
+#define RK29_CAM_SENSOR_OV3640 ov3640
+#define RK29_CAM_SENSOR_OV3660 ov3660
+#define RK29_CAM_SENSOR_OV5640 ov5640
+#define RK29_CAM_SENSOR_OV5642 ov5642
+#define RK29_CAM_SENSOR_S5K6AA s5k6aa
+#define RK29_CAM_SENSOR_MT9D112 mt9d112
+#define RK29_CAM_SENSOR_MT9D113 mt9d113
+#define RK29_CAM_SENSOR_MT9P111 mt9p111
+#define RK29_CAM_SENSOR_MT9T111 mt9t111
+#define RK29_CAM_SENSOR_GT2005  gt2005
+#define RK29_CAM_SENSOR_GC0307  gc0307
+#define RK29_CAM_SENSOR_GC0308  gc0308
+#define RK29_CAM_SENSOR_GC0309  gc0309
+#define RK29_CAM_SENSOR_GC2015  gc2015
+#define RK29_CAM_SENSOR_GC0328  gc0328
+#define RK29_CAM_SENSOR_GC0329  gc0329
+#define RK29_CAM_SENSOR_GC2035	gc2035
+#define RK29_CAM_SENSOR_SIV120B  siv120b
+#define RK29_CAM_SENSOR_SIV121D  siv121d
+#define RK29_CAM_SENSOR_SID130B  sid130B
+#define RK29_CAM_SENSOR_HI253  hi253
+#define RK29_CAM_SENSOR_HI704  hi704
+#define RK29_CAM_SENSOR_NT99250 nt99250
+#define RK29_CAM_SENSOR_SP0718  sp0718
+#define RK29_CAM_SENSOR_SP0838  sp0838
+#define RK29_CAM_SENSOR_SP2518  sp2518
+#define RK29_CAM_SENSOR_S5K5CA  s5k5ca
+#define RK29_CAM_ISP_MTK9335	mtk9335isp
+#define RK29_CAM_SENSOR_HM2057  hm2057
+#define RK29_CAM_SENSOR_HM5065  hm5065
+#define RK29_CAM_SENSOR_NT99160 nt99160  //oyyf@rock-chips.com 
+#define RK29_CAM_SENSOR_NT99240 nt99240  //oyyf@rock-chips.com 
+#define RK29_CAM_SENSOR_NT99252 nt99252  //oyyf@rock-chips.com 
+#define RK29_CAM_SENSOR_NT99340 nt99340  //oyyf@rock-chips.com 
+#define RK29_CAM_ISP_ICATCH7002_MI1040  icatchmi1040   
+#define RK29_CAM_ISP_ICATCH7002_OV5693  icatchov5693
+#define RK29_CAM_ISP_ICATCH7002_OV8825  icatchov8825   //zyt
+#define RK29_CAM_ISP_ICATCH7002_OV2720  icatchov2720   //zyt
+
+#define RK29_CAM_SENSOR_NAME_OV7675 "ov7675"
+#define RK29_CAM_SENSOR_NAME_OV9650 "ov9650"
+#define RK29_CAM_SENSOR_NAME_OV2640 "ov2640"
+#define RK29_CAM_SENSOR_NAME_OV2655 "ov2655"
+#define RK29_CAM_SENSOR_NAME_OV2659 "ov2659"
+
+#define RK29_CAM_SENSOR_NAME_OV2660 "ov2660"  //yzm
+
+
+#define RK29_CAM_SENSOR_NAME_OV7690 "ov7690"
+#define RK29_CAM_SENSOR_NAME_OV3640 "ov3640"
+#define RK29_CAM_SENSOR_NAME_OV3660 "ov3660"
+#define RK29_CAM_SENSOR_NAME_OV5640 "ov5640"
+#define RK29_CAM_SENSOR_NAME_OV5642 "ov5642"
+#define RK29_CAM_SENSOR_NAME_S5K6AA "s5k6aa"
+#define RK29_CAM_SENSOR_NAME_MT9D112 "mt9d112"
+#define RK29_CAM_SENSOR_NAME_MT9D113 "mt9d113"
+#define RK29_CAM_SENSOR_NAME_MT9P111 "mt9p111"
+#define RK29_CAM_SENSOR_NAME_MT9T111 "mt9t111"
+#define RK29_CAM_SENSOR_NAME_GT2005  "gt2005"
+#define RK29_CAM_SENSOR_NAME_GC0307  "gc0307"
+#define RK29_CAM_SENSOR_NAME_GC0308  "gc0308"
+#define RK29_CAM_SENSOR_NAME_GC0309  "gc0309"
+#define RK29_CAM_SENSOR_NAME_GC2015  "gc2015"
+#define RK29_CAM_SENSOR_NAME_GC0328  "gc0328"
+#define RK29_CAM_SENSOR_NAME_GC2035  "gc2035"
+#define RK29_CAM_SENSOR_NAME_GC0329  "gc0329"
+#define RK29_CAM_SENSOR_NAME_SIV120B "siv120b"
+#define RK29_CAM_SENSOR_NAME_SIV121D "siv121d"
+#define RK29_CAM_SENSOR_NAME_SID130B "sid130B"
+#define RK29_CAM_SENSOR_NAME_HI253  "hi253"
+#define RK29_CAM_SENSOR_NAME_HI704  "hi704"
+#define RK29_CAM_SENSOR_NAME_NT99250 "nt99250"
+#define RK29_CAM_SENSOR_NAME_SP0718  "sp0718"
+#define RK29_CAM_SENSOR_NAME_SP0838  "sp0838"
+#define RK29_CAM_SENSOR_NAME_SP2518  "sp2518"
+#define RK29_CAM_SENSOR_NAME_S5K5CA  "s5k5ca"
+#define RK29_CAM_ISP_NAME_MTK9335ISP "mtk9335isp"
+#define RK29_CAM_SENSOR_NAME_HM2057  "hm2057"
+#define RK29_CAM_SENSOR_NAME_HM5065  "hm5065"
+#define RK29_CAM_ISP_NAME_ICATCH7002_MI1040 "icatchmi1040"
+#define RK29_CAM_ISP_NAME_ICATCH7002_OV5693 "icatchov5693"
+#define RK29_CAM_ISP_NAME_ICATCH7002_OV8825 "icatchov8825" //zyt
+#define RK29_CAM_ISP_NAME_ICATCH7002_OV2720 "icatchov2720" //zyt
+
+//Sensor full resolution define
+#define ov7675_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define ov9650_FULL_RESOLUTION     0x130000           // 1.3 megapixel   
+#define ov2640_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define ov2655_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define ov2659_FULL_RESOLUTION     0x200000           // 2 megapixel
+
+#define ov2660_FULL_RESOLUTION     0x200000           // 2 megapixel
+
+#define ov7690_FULL_RESOLUTION     0x300000           // 2 megapixel
+#define ov3640_FULL_RESOLUTION     0x300000           // 3 megapixel
+#define ov3660_FULL_RESOLUTION     0x300000           // 3 megapixel
+#define ov5640_FULL_RESOLUTION     0x500000           // 5 megapixel
+#if defined(CONFIG_SOC_CAMERA_OV5642_INTERPOLATION_8M)
+	#define ov5642_FULL_RESOLUTION     0x800000            // 8 megapixel
+#else	
+    #define ov5642_FULL_RESOLUTION     0x500000           // 5 megapixel
+#endif
+#define s5k6aa_FULL_RESOLUTION     0x130000           // 1.3 megapixel
+#define mt9d112_FULL_RESOLUTION    0x200000           // 2 megapixel
+#define mt9d113_FULL_RESOLUTION    0x200000           // 2 megapixel
+#define mt9t111_FULL_RESOLUTION    0x300000           // 3 megapixel
+#define mt9p111_FULL_RESOLUTION    0x500000           // 5 megapixel
+#define gt2005_FULL_RESOLUTION     0x200000           // 2 megapixel
+#if defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_5M)
+	#define gc0308_FULL_RESOLUTION     0x500000            // 5 megapixel
+#elif defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_3M)
+	#define gc0308_FULL_RESOLUTION     0x300000            // 3 megapixel
+#elif defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_2M)
+	#define gc0308_FULL_RESOLUTION     0x200000            // 2 megapixel
+#else
+	#define gc0308_FULL_RESOLUTION     0x30000            // 0.3 megapixel#endif
+#endif
+#define gc0328_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define gc0307_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define gc0309_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define gc2015_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define siv120b_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define siv121d_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define sid130B_FULL_RESOLUTION     0x200000           // 2 megapixel    
+
+#if defined(CONFIG_SOC_CAMERA_HI253_INTERPOLATION_5M) 
+	#define hi253_FULL_RESOLUTION       0x500000			// 5 megapixel
+#elif defined(CONFIG_SOC_CAMERA_HI253_INTERPOLATION_3M)
+	#define hi253_FULL_RESOLUTION       0x300000           // 3 megapixel
+#else
+	#define hi253_FULL_RESOLUTION       0x200000           // 2 megapixel
+#endif
+
+#define hi704_FULL_RESOLUTION       0x30000            // 0.3 megapixel
+#define nt99250_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define sp0718_FULL_RESOLUTION      0x30000            // 0.3 megapixel
+#define sp0838_FULL_RESOLUTION      0x30000            // 0.3 megapixel
+#define sp2518_FULL_RESOLUTION      0x200000            // 2 megapixel
+#define gc0329_FULL_RESOLUTION      0x30000            // 0.3 megapixel
+#define s5k5ca_FULL_RESOLUTION      0x300000            // 3 megapixel
+#define mtk9335isp_FULL_RESOLUTION  0x500000   		//5 megapixel
+#define gc2035_FULL_RESOLUTION      0x200000            // 2 megapixel
+#define hm2057_FULL_RESOLUTION      0x200000            // 2 megapixel
+#define hm5065_FULL_RESOLUTION      0x500000            // 5 megapixel
+#define nt99160_FULL_RESOLUTION     0x100000           // oyyf@rock-chips.com:  1 megapixel 1280*720    
+#define nt99240_FULL_RESOLUTION     0x200000           // oyyf@rock-chips.com:  2 megapixel 1600*1200
+#define nt99252_FULL_RESOLUTION     0x200000           // oyyf@rock-chips.com:  2 megapixel 1600*1200
+#define nt99340_FULL_RESOLUTION     0x300000           // oyyf@rock-chips.com:  3 megapixel 2048*1536
+#define icatchmi1040_FULL_RESOLUTION 0x200000
+#define icatchov5693_FULL_RESOLUTION 0x500000
+#define icatchov8825_FULL_RESOLUTION 0x800000					//zyt
+#define icatchov2720_FULL_RESOLUTION 0x210000                   //zyt
+#define end_FULL_RESOLUTION         0x00
+
+//Sensor i2c addr define
+#define ov7675_I2C_ADDR             0x78            
+#define ov9650_I2C_ADDR             0x60           
+#define ov2640_I2C_ADDR             0x60
+#define ov2655_I2C_ADDR             0x60
+#define ov2659_I2C_ADDR             0x60
+
+#define ov2660_I2C_ADDR             0x60   //yzm
+
+#define ov7690_I2C_ADDR             0x42
+#define ov3640_I2C_ADDR             0x78
+#define ov3660_I2C_ADDR             0x78
+#define ov5640_I2C_ADDR             0x78
+#define ov5642_I2C_ADDR             0x78
+
+#define s5k6aa_I2C_ADDR             0x78           //0x5a
+#define s5k5ca_I2C_ADDR             0x78           //0x5a
+
+#define mt9d112_I2C_ADDR             0x78
+#define mt9d113_I2C_ADDR             0x78
+#define mt9t111_I2C_ADDR             0x78           // 0x7a 
+
+#define mt9p111_I2C_ADDR            0x78            //0x7a
+#define gt2005_I2C_ADDR             0x78           
+#define gc0307_I2C_ADDR             0x42
+#define gc0328_I2C_ADDR             0x42
+#define gc0308_I2C_ADDR             0x42
+#define gc0309_I2C_ADDR             0x42
+#define gc0329_I2C_ADDR             0x62           
+#define gc2015_I2C_ADDR             0x60
+#define gc2035_I2C_ADDR             0x78            
+
+#define siv120b_I2C_ADDR             INVALID_VALUE           
+#define siv121d_I2C_ADDR             INVALID_VALUE           
+#define sid130B_I2C_ADDR             0x37
+
+#define hi253_I2C_ADDR             0x40
+#define hi704_I2C_ADDR             0x60
+
+#define nt99160_I2C_ADDR             0x54
+#define nt99240_I2C_ADDR             0x6c
+#define nt99250_I2C_ADDR             0x6c
+#define nt99252_I2C_ADDR             0x6c
+#define nt99340_I2C_ADDR             0x76
+
+#define sp0718_I2C_ADDR             0x42
+#define sp0838_I2C_ADDR             INVALID_VALUE  
+#define sp0a19_I2C_ADDR             0x7a
+#define sp1628_I2C_ADDR             0x78
+#define sp2518_I2C_ADDR             0x60 
+#define mtk9335isp_I2C_ADDR         0x50 
+#define hm2057_I2C_ADDR             0x48
+#define hm5065_I2C_ADDR             0x3e
+#define icatchmi1040_I2C_ADDR		0x78
+#define icatchov5693_I2C_ADDR       0x78
+#define icatchov8825_I2C_ADDR       0x78  //zyt
+#define icatchov2720_I2C_ADDR       0x78  //zyt
+#define end_I2C_ADDR                INVALID_VALUE
+
+
+//Sensor power down active level define
+#define ov7675_PWRDN_ACTIVE             0x01            
+#define ov9650_PWRDN_ACTIVE             0x01           
+#define ov2640_PWRDN_ACTIVE             0x01
+#define ov2655_PWRDN_ACTIVE             0x01
+#define ov2659_PWRDN_ACTIVE             0x01
+
+#define ov2660_PWRDN_ACTIVE             0x01  //yzm
+
+#define ov7690_PWRDN_ACTIVE             0x01
+#define ov3640_PWRDN_ACTIVE             0x01
+#define ov3660_PWRDN_ACTIVE             0x01
+#define ov5640_PWRDN_ACTIVE             0x01
+#define ov5642_PWRDN_ACTIVE             0x01
+
+#define s5k6aa_PWRDN_ACTIVE             0x00           
+#define s5k5ca_PWRDN_ACTIVE             0x00           
+
+#define mt9d112_PWRDN_ACTIVE             0x01
+#define mt9d113_PWRDN_ACTIVE             0x01
+#define mt9t111_PWRDN_ACTIVE             0x01  
+#define mt9p111_PWRDN_ACTIVE             0x01
+
+#define gt2005_PWRDN_ACTIVE             0x00           
+#define gc0307_PWRDN_ACTIVE             0x01
+#define gc0308_PWRDN_ACTIVE             0x01
+#define gc0328_PWRDN_ACTIVE             0x01
+#define gc0309_PWRDN_ACTIVE             0x01
+#define gc0329_PWRDN_ACTIVE             0x01           
+#define gc2015_PWRDN_ACTIVE             0x01
+#define gc2035_PWRDN_ACTIVE             0x01            
+
+#define siv120b_PWRDN_ACTIVE             INVALID_VALUE           
+#define siv121d_PWRDN_ACTIVE             INVALID_VALUE           
+#define sid130B_PWRDN_ACTIVE             0x37
+
+#define hi253_PWRDN_ACTIVE             0x01
+#define hi704_PWRDN_ACTIVE             0x01
+
+#define nt99160_PWRDN_ACTIVE             0x01
+#define nt99240_PWRDN_ACTIVE             0x01
+#define nt99250_PWRDN_ACTIVE             0x01
+#define nt99252_PWRDN_ACTIVE             0x01
+#define nt99340_PWRDN_ACTIVE             0x01
+
+#define sp0718_PWRDN_ACTIVE             0x01
+#define sp0838_PWRDN_ACTIVE             0x01  
+#define sp0a19_PWRDN_ACTIVE             0x01
+#define sp1628_PWRDN_ACTIVE             0x01
+#define sp2518_PWRDN_ACTIVE             0x01 
+#define hm2057_PWRDN_ACTIVE             0x01
+#define hm5065_PWRDN_ACTIVE             0x00
+#define mtk9335isp_PWRDN_ACTIVE         0x01 
+#define end_PWRDN_ACTIVE                INVALID_VALUE
+
+
+//Sensor power up sequence  define
+//type: bit0-bit4
+#define SENSOR_PWRSEQ_BEGIN         0x00
+#define SENSOR_PWRSEQ_AVDD          0x01
+#define SENSOR_PWRSEQ_DOVDD         0x02
+#define SENSOR_PWRSEQ_DVDD          0x03
+#define SENSOR_PWRSEQ_PWR           0x04
+#define SENSOR_PWRSEQ_HWRST         0x05
+#define SENSOR_PWRSEQ_PWRDN         0x06
+#define SENSOR_PWRSEQ_CLKIN         0x07
+#define SENSOR_PWRSEQ_END           0x0F
+
+#define SENSOR_PWRSEQ_SET(type,idx)    (type<<(idx*4))
+#define SENSOR_PWRSEQ_GET(seq,idx)     ((seq>>(idx*4))&0x0f)
+
+#define sensor_PWRSEQ_DEFAULT      (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,1)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWRDN,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,3))
+
+#define ov7675_PWRSEQ                   sensor_PWRSEQ_DEFAULT            
+#define ov9650_PWRSEQ                   sensor_PWRSEQ_DEFAULT  
+#define ov2640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov2655_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov2659_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define ov2660_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define ov7690_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov3640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov3660_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov5640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov5642_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define s5k6aa_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
+#define s5k5ca_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
+
+#define mt9d112_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define mt9d113_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define mt9t111_PWRSEQ                   sensor_PWRSEQ_DEFAULT 
+#define mt9p111_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define gt2005_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
+#define gc0307_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc0308_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc0328_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc0309_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc0329_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
+#define gc2015_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc2035_PWRSEQ                   sensor_PWRSEQ_DEFAULT            
+
+#define siv120b_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
+#define siv121d_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
+#define sid130B_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define hi253_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define hi704_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define nt99160_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define nt99240_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define nt99250_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define nt99252_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define nt99340_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define sp0718_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define sp0838_PWRSEQ                   sensor_PWRSEQ_DEFAULT  
+#define sp0a19_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define sp1628_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define sp2518_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define hm2057_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define hm5065_PWRSEQ                   (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,1)|\
+                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWRDN,0)|\
+                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,3))
+#define mtk9335isp_PWRSEQ               sensor_PWRSEQ_DEFAULT
+#define icatchov5693_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))
+                                    
+#define icatchov8825_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))     //zyt                                    
+                                    
+#define icatchov2720_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))     //zyt 
+
+#define icatchmi1040_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))
+
+#define end_PWRSEQ                      0xffffffff
+                                          
+
+
+/*---------------- Camera Sensor Must Define Macro End  ------------------------*/
+
+
+//#define RK29_CAM_POWERACTIVE_BITPOS	0x00
+#define RK29_CAM_POWERACTIVE_MASK	(1<<RK29_CAM_POWERACTIVE_BITPOS)
+#define RK29_CAM_POWERACTIVE_H	(0x01<<RK29_CAM_POWERACTIVE_BITPOS)
+#define RK29_CAM_POWERACTIVE_L	(0x00<<RK29_CAM_POWERACTIVE_BITPOS)
+
+//#define RK29_CAM_RESETACTIVE_BITPOS	0x01
+#define RK29_CAM_RESETACTIVE_MASK	(1<<RK29_CAM_RESETACTIVE_BITPOS)
+#define RK29_CAM_RESETACTIVE_H	(0x01<<RK29_CAM_RESETACTIVE_BITPOS)
+#define RK29_CAM_RESETACTIVE_L  (0x00<<RK29_CAM_RESETACTIVE_BITPOS)
+
+//#define RK29_CAM_POWERDNACTIVE_BITPOS	0x02
+#define RK29_CAM_POWERDNACTIVE_MASK	(1<<RK29_CAM_POWERDNACTIVE_BITPOS)
+#define RK29_CAM_POWERDNACTIVE_H	(0x01<<RK29_CAM_POWERDNACTIVE_BITPOS)
+#define RK29_CAM_POWERDNACTIVE_L	(0x00<<RK29_CAM_POWERDNACTIVE_BITPOS)
+
+//#define RK29_CAM_FLASHACTIVE_BITPOS	0x03
+#define RK29_CAM_FLASHACTIVE_MASK	(1<<RK29_CAM_FLASHACTIVE_BITPOS)
+#define RK29_CAM_FLASHACTIVE_H	(0x01<<RK29_CAM_FLASHACTIVE_BITPOS)
+#define RK29_CAM_FLASHACTIVE_L  (0x00<<RK29_CAM_FLASHACTIVE_BITPOS)
+
+
+//#define RK29_CAM_AFACTIVE_BITPOS	0x04
+#define RK29_CAM_AFACTIVE_MASK	(1<<RK29_CAM_AFACTIVE_BITPOS)
+#define RK29_CAM_AFACTIVE_H	(0x01<<RK29_CAM_AFACTIVE_BITPOS)
+#define RK29_CAM_AFACTIVE_L  (0x00<<RK29_CAM_AFACTIVE_BITPOS)
+
+
+
+#define RK_CAM_SCALE_CROP_ARM      0
+#define RK_CAM_SCALE_CROP_IPP      1
+#define RK_CAM_SCALE_CROP_RGA      2
+#define RK_CAM_SCALE_CROP_PP       3
+
+#define RK_CAM_INPUT_FMT_YUV422    (1<<0)
+#define RK_CAM_INPUT_FMT_RAW10     (1<<1)
+#define RK_CAM_INPUT_FMT_RAW12     (1<<2)
+
+/* v4l2_subdev_core_ops.ioctl  ioctl_cmd macro */
+#define RK29_CAM_SUBDEV_ACTIVATE            0x00
+#define RK29_CAM_SUBDEV_DEACTIVATE          0x01
+#define RK29_CAM_SUBDEV_IOREQUEST			0x02
+#define RK29_CAM_SUBDEV_CB_REGISTER         0x03
+
+#define Sensor_HasBeen_PwrOff(a)            (a&0x01)
+#define Sensor_Support_DirectResume(a)      ((a&0x10)==0x10)
+
+#define Sensor_CropSet(a,b)                  a->reserved[1] = b;
+#define Sensor_CropGet(a)                    a->reserved[1]
+
+#define RK29_CAM_SUBDEV_HDR_EXPOSURE        0x04
+
+#define RK_VIDEOBUF_HDR_EXPOSURE_MINUS_1        0x00
+#define RK_VIDEOBUF_HDR_EXPOSURE_NORMAL         0x01
+#define RK_VIDEOBUF_HDR_EXPOSURE_PLUS_1         0x02
+#define RK_VIDEOBUF_HDR_EXPOSURE_FINISH         0x03
+#define RK_VIDEOBUF_CODE_SET(rk_code,type)  rk_code = (('R'<<24)|('K'<<16)|type)
+#define RK_VIDEOBUF_CODE_CHK(rk_code)       ((rk_code&(('R'<<24)|('K'<<16)))==(('R'<<24)|('K'<<16)))
+
+enum rk29camera_ioctrl_cmd
+{
+	Cam_Power,
+	Cam_Reset,
+	Cam_PowerDown,
+	Cam_Flash,
+	Cam_Mclk,
+	Cam_Af
+};
+
+enum rk29sensor_power_cmd
+{
+    Sensor_Power,
+	Sensor_Reset,
+	Sensor_PowerDown,
+	Sensor_Flash,
+	Sensor_Af
+};
+
+enum rk29camera_flash_cmd
+{
+    Flash_Off,
+    Flash_On,
+    Flash_Torch
+};
+
+struct rk29camera_gpio_res {
+    unsigned int gpio_reset;
+    unsigned int gpio_power;
+	unsigned int gpio_powerdown;
+	unsigned int gpio_flash;
+	unsigned int gpio_af;
+	unsigned int gpio_flag;
+	unsigned int gpio_init;
+	const char *dev_name;
+};
+
+struct rk29camera_mem_res {
+	const char *name;
+	unsigned int start;
+	unsigned int size;
+    void __iomem *vbase;  //指向IO空间的指针，为了驱动程序的通用性考虑
+};
+struct rk29camera_info {
+    const char *dev_name;
+    unsigned int orientation;
+    struct v4l2_frmivalenum fival[10];
+};
+
+struct reginfo_t
+{
+	u16 reg;
+	u16 val;
+	u16 reg_len;
+	u16 rev;
+};
+typedef struct rk_sensor_user_init_data{
+	int rk_sensor_init_width;
+	int rk_sensor_init_height;
+	unsigned long rk_sensor_init_bus_param;
+	enum v4l2_mbus_pixelcode rk_sensor_init_pixelcode;
+	struct reginfo_t * rk_sensor_init_data;
+	int rk_sensor_winseq_size;
+	struct reginfo_t * rk_sensor_init_winseq;
+	int rk_sensor_init_data_size;
+}rk_sensor_user_init_data_s;
+
+typedef struct rk_camera_device_register_info {
+    struct i2c_board_info i2c_cam_info;
+	struct soc_camera_desc desc_info;//yzm
+    struct platform_device device_info;
+}rk_camera_device_register_info_t;
+
+struct rkcamera_platform_data {
+    rk_camera_device_register_info_t dev;
+    char dev_name[32];
+    struct rk29camera_gpio_res io;
+    int orientation;
+    int resolution;   
+    int mirror;       /* bit0:  0: mirror off
+                                1: mirror on
+                         bit1:  0: flip off
+                                1: flip on
+                      */
+    int i2c_rate;     /* 100KHz = 100000  */                    
+    bool flash;       /* true:  the sensor attached flash;
+                         false: the sensor haven't attach flash;
+
+                      */
+    int pwdn_info;    /* bit4: 1: sensor isn't need to be init after exit stanby, it can streaming directly 
+                               0: sensor must be init after exit standby;
+
+                         bit0: 1: sensor power have been turn off;
+                               0: sensor power is always on;
+                      */
+
+    long powerup_sequence;       /*  
+                                    bit0-bit3 --- power up sequence first step;
+                                    bit4-bit7 --- power up sequence second step;
+                                     .....
+                                  */
+    int mclk_rate;       /* MHz : 24/48 */ 
+    int fov_h;           /* fied of view horizontal */
+    int fov_v;           /* fied of view vertical */
+	struct device_node *of_node;
+	struct rkcamera_platform_data *next_camera;//yzm
+                      
+};
+
+struct rk29camera_platform_data {
+    int (*io_init)(void);
+    int (*io_deinit)(int sensor);
+	int (*sensor_ioctrl)(struct device *dev,enum rk29camera_ioctrl_cmd cmd,int on);
+
+    int (*sensor_register)(void);
+    int (*sensor_mclk)(int cif_idx, int on, int clk_rate);
+    
+    struct rkcamera_platform_data *register_dev_new;  //sensor
+	struct device *cif_dev;//yzm  host
+};
+
+struct rk29camera_platform_ioctl_cb {
+    int (*sensor_power_cb)(struct rk29camera_gpio_res *res, int on);
+    int (*sensor_reset_cb)(struct rk29camera_gpio_res *res, int on);
+    int (*sensor_powerdown_cb)(struct rk29camera_gpio_res *res, int on);
+    int (*sensor_flash_cb)(struct rk29camera_gpio_res *res, int on);
+    int (*sensor_af_cb)(struct rk29camera_gpio_res *res, int on);	
+};
+
+typedef struct rk29_camera_sensor_cb {
+    int (*sensor_cb)(void *arg); 
+    int (*scale_crop_cb)(struct work_struct *work);
+}rk29_camera_sensor_cb_s;
+
+#endif /* __ASM_ARCH_CAMERA_H_ */
+
diff --git a/arch/arm/mach-rockchip/rk_camera_sensor_info.h b/arch/arm/mach-rockchip/rk_camera_sensor_info.h
new file mode 100644
index 000000000000..475f2c3bdad9
--- /dev/null
+++ b/arch/arm/mach-rockchip/rk_camera_sensor_info.h
@@ -0,0 +1,383 @@
+#ifndef __RK_CAMERA_SENSOR_INFO_H_
+#define __RK_CAMERA_SENSOR_INFO_H_
+
+
+/*---------------- Camera Sensor Must Define Macro Begin  ------------------------*/
+#define RK29_CAM_SENSOR_OV7675 ov7675
+#define RK29_CAM_SENSOR_OV9650 ov9650
+#define RK29_CAM_SENSOR_OV2640 ov2640
+#define RK29_CAM_SENSOR_OV2655 ov2655
+#define RK29_CAM_SENSOR_OV2659 ov2659
+
+#define RK29_CAM_SENSOR_OV2660 ov2660 //yzm
+
+#define RK29_CAM_SENSOR_OV7690 ov7690
+#define RK29_CAM_SENSOR_OV3640 ov3640
+#define RK29_CAM_SENSOR_OV3660 ov3660
+#define RK29_CAM_SENSOR_OV5640 ov5640
+#define RK29_CAM_SENSOR_OV5642 ov5642
+#define RK29_CAM_SENSOR_S5K6AA s5k6aa
+#define RK29_CAM_SENSOR_MT9D112 mt9d112
+#define RK29_CAM_SENSOR_MT9D113 mt9d113
+#define RK29_CAM_SENSOR_MT9P111 mt9p111
+#define RK29_CAM_SENSOR_MT9T111 mt9t111
+#define RK29_CAM_SENSOR_GT2005  gt2005
+#define RK29_CAM_SENSOR_GC0307  gc0307
+#define RK29_CAM_SENSOR_GC0308  gc0308
+#define RK29_CAM_SENSOR_GC0309  gc0309
+#define RK29_CAM_SENSOR_GC2015  gc2015
+#define RK29_CAM_SENSOR_GC0328  gc0328
+#define RK29_CAM_SENSOR_GC0329  gc0329
+#define RK29_CAM_SENSOR_GC2035	gc2035
+#define RK29_CAM_SENSOR_SIV120B  siv120b
+#define RK29_CAM_SENSOR_SIV121D  siv121d
+#define RK29_CAM_SENSOR_SID130B  sid130B
+#define RK29_CAM_SENSOR_HI253  hi253
+#define RK29_CAM_SENSOR_HI704  hi704
+#define RK29_CAM_SENSOR_NT99250 nt99250
+#define RK29_CAM_SENSOR_SP0718  sp0718
+#define RK29_CAM_SENSOR_SP0838  sp0838
+#define RK29_CAM_SENSOR_SP2518  sp2518
+#define RK29_CAM_SENSOR_S5K5CA  s5k5ca
+#define RK29_CAM_ISP_MTK9335	mtk9335isp
+#define RK29_CAM_SENSOR_HM2057  hm2057
+#define RK29_CAM_SENSOR_HM5065  hm5065
+#define RK29_CAM_SENSOR_NT99160 nt99160  //oyyf@rock-chips.com 
+#define RK29_CAM_SENSOR_NT99240 nt99240  //oyyf@rock-chips.com 
+#define RK29_CAM_SENSOR_NT99252 nt99252  //oyyf@rock-chips.com 
+#define RK29_CAM_SENSOR_NT99340 nt99340  //oyyf@rock-chips.com 
+#define RK29_CAM_ISP_ICATCH7002_MI1040  icatchmi1040   
+#define RK29_CAM_ISP_ICATCH7002_OV5693  icatchov5693
+#define RK29_CAM_ISP_ICATCH7002_OV8825  icatchov8825   //zyt
+#define RK29_CAM_ISP_ICATCH7002_OV2720  icatchov2720   //zyt
+
+#define RK29_CAM_SENSOR_NAME_OV7675 "ov7675"
+#define RK29_CAM_SENSOR_NAME_OV9650 "ov9650"
+#define RK29_CAM_SENSOR_NAME_OV2640 "ov2640"
+#define RK29_CAM_SENSOR_NAME_OV2655 "ov2655"
+#define RK29_CAM_SENSOR_NAME_OV2659 "ov2659"
+
+#define RK29_CAM_SENSOR_NAME_OV2660 "ov2660"  //yzm
+
+
+#define RK29_CAM_SENSOR_NAME_OV7690 "ov7690"
+#define RK29_CAM_SENSOR_NAME_OV3640 "ov3640"
+#define RK29_CAM_SENSOR_NAME_OV3660 "ov3660"
+#define RK29_CAM_SENSOR_NAME_OV5640 "ov5640"
+#define RK29_CAM_SENSOR_NAME_OV5642 "ov5642"
+#define RK29_CAM_SENSOR_NAME_S5K6AA "s5k6aa"
+#define RK29_CAM_SENSOR_NAME_MT9D112 "mt9d112"
+#define RK29_CAM_SENSOR_NAME_MT9D113 "mt9d113"
+#define RK29_CAM_SENSOR_NAME_MT9P111 "mt9p111"
+#define RK29_CAM_SENSOR_NAME_MT9T111 "mt9t111"
+#define RK29_CAM_SENSOR_NAME_GT2005  "gt2005"
+#define RK29_CAM_SENSOR_NAME_GC0307  "gc0307"
+#define RK29_CAM_SENSOR_NAME_GC0308  "gc0308"
+#define RK29_CAM_SENSOR_NAME_GC0309  "gc0309"
+#define RK29_CAM_SENSOR_NAME_GC2015  "gc2015"
+#define RK29_CAM_SENSOR_NAME_GC0328  "gc0328"
+#define RK29_CAM_SENSOR_NAME_GC2035  "gc2035"
+#define RK29_CAM_SENSOR_NAME_GC0329  "gc0329"
+#define RK29_CAM_SENSOR_NAME_SIV120B "siv120b"
+#define RK29_CAM_SENSOR_NAME_SIV121D "siv121d"
+#define RK29_CAM_SENSOR_NAME_SID130B "sid130B"
+#define RK29_CAM_SENSOR_NAME_HI253  "hi253"
+#define RK29_CAM_SENSOR_NAME_HI704  "hi704"
+#define RK29_CAM_SENSOR_NAME_NT99250 "nt99250"
+#define RK29_CAM_SENSOR_NAME_SP0718  "sp0718"
+#define RK29_CAM_SENSOR_NAME_SP0838  "sp0838"
+#define RK29_CAM_SENSOR_NAME_SP2518  "sp2518"
+#define RK29_CAM_SENSOR_NAME_S5K5CA  "s5k5ca"
+#define RK29_CAM_ISP_NAME_MTK9335ISP "mtk9335isp"
+#define RK29_CAM_SENSOR_NAME_HM2057  "hm2057"
+#define RK29_CAM_SENSOR_NAME_HM5065  "hm5065"
+#define RK29_CAM_ISP_NAME_ICATCH7002_MI1040 "icatchmi1040"
+#define RK29_CAM_ISP_NAME_ICATCH7002_OV5693 "icatchov5693"
+#define RK29_CAM_ISP_NAME_ICATCH7002_OV8825 "icatchov8825" //zyt
+#define RK29_CAM_ISP_NAME_ICATCH7002_OV2720 "icatchov2720" //zyt
+
+//Sensor full resolution define
+#define ov7675_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define ov9650_FULL_RESOLUTION     0x130000           // 1.3 megapixel   
+#define ov2640_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define ov2655_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define ov2659_FULL_RESOLUTION     0x200000           // 2 megapixel
+
+#define ov2660_FULL_RESOLUTION     0x200000           // 2 megapixel
+
+#define ov7690_FULL_RESOLUTION     0x300000           // 2 megapixel
+#define ov3640_FULL_RESOLUTION     0x300000           // 3 megapixel
+#define ov3660_FULL_RESOLUTION     0x300000           // 3 megapixel
+#define ov5640_FULL_RESOLUTION     0x500000           // 5 megapixel
+#if defined(CONFIG_SOC_CAMERA_OV5642_INTERPOLATION_8M)
+	#define ov5642_FULL_RESOLUTION     0x800000            // 8 megapixel
+#else	
+    #define ov5642_FULL_RESOLUTION     0x500000           // 5 megapixel
+#endif
+#define s5k6aa_FULL_RESOLUTION     0x130000           // 1.3 megapixel
+#define mt9d112_FULL_RESOLUTION    0x200000           // 2 megapixel
+#define mt9d113_FULL_RESOLUTION    0x200000           // 2 megapixel
+#define mt9t111_FULL_RESOLUTION    0x300000           // 3 megapixel
+#define mt9p111_FULL_RESOLUTION    0x500000           // 5 megapixel
+#define gt2005_FULL_RESOLUTION     0x200000           // 2 megapixel
+#if defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_5M)
+	#define gc0308_FULL_RESOLUTION     0x500000            // 5 megapixel
+#elif defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_3M)
+	#define gc0308_FULL_RESOLUTION     0x300000            // 3 megapixel
+#elif defined(CONFIG_SOC_CAMERA_GC0308_INTERPOLATION_2M)
+	#define gc0308_FULL_RESOLUTION     0x200000            // 2 megapixel
+#else
+	#define gc0308_FULL_RESOLUTION     0x30000            // 0.3 megapixel#endif
+#endif
+#define gc0328_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define gc0307_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define gc0309_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define gc2015_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define siv120b_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define siv121d_FULL_RESOLUTION     0x30000            // 0.3 megapixel
+#define sid130B_FULL_RESOLUTION     0x200000           // 2 megapixel    
+
+#if defined(CONFIG_SOC_CAMERA_HI253_INTERPOLATION_5M) 
+	#define hi253_FULL_RESOLUTION       0x500000			// 5 megapixel
+#elif defined(CONFIG_SOC_CAMERA_HI253_INTERPOLATION_3M)
+	#define hi253_FULL_RESOLUTION       0x300000           // 3 megapixel
+#else
+	#define hi253_FULL_RESOLUTION       0x200000           // 2 megapixel
+#endif
+
+#define hi704_FULL_RESOLUTION       0x30000            // 0.3 megapixel
+#define nt99250_FULL_RESOLUTION     0x200000           // 2 megapixel
+#define sp0718_FULL_RESOLUTION      0x30000            // 0.3 megapixel
+#define sp0838_FULL_RESOLUTION      0x30000            // 0.3 megapixel
+#define sp2518_FULL_RESOLUTION      0x200000            // 2 megapixel
+#define gc0329_FULL_RESOLUTION      0x30000            // 0.3 megapixel
+#define s5k5ca_FULL_RESOLUTION      0x300000            // 3 megapixel
+#define mtk9335isp_FULL_RESOLUTION  0x500000   		//5 megapixel
+#define gc2035_FULL_RESOLUTION      0x200000            // 2 megapixel
+#define hm2057_FULL_RESOLUTION      0x200000            // 2 megapixel
+#define hm5065_FULL_RESOLUTION      0x500000            // 5 megapixel
+#define nt99160_FULL_RESOLUTION     0x100000           // oyyf@rock-chips.com:  1 megapixel 1280*720    
+#define nt99240_FULL_RESOLUTION     0x200000           // oyyf@rock-chips.com:  2 megapixel 1600*1200
+#define nt99252_FULL_RESOLUTION     0x200000           // oyyf@rock-chips.com:  2 megapixel 1600*1200
+#define nt99340_FULL_RESOLUTION     0x300000           // oyyf@rock-chips.com:  3 megapixel 2048*1536
+#define icatchmi1040_FULL_RESOLUTION 0x200000
+#define icatchov5693_FULL_RESOLUTION 0x500000
+#define icatchov8825_FULL_RESOLUTION 0x800000					//zyt
+#define icatchov2720_FULL_RESOLUTION 0x210000                   //zyt
+#define end_FULL_RESOLUTION         0x00
+
+//Sensor i2c addr define
+#define ov7675_I2C_ADDR             0x78            
+#define ov9650_I2C_ADDR             0x60           
+#define ov2640_I2C_ADDR             0x60
+#define ov2655_I2C_ADDR             0x60
+#define ov2659_I2C_ADDR             0x60
+
+#define ov2660_I2C_ADDR             0x60   //yzm
+
+#define ov7690_I2C_ADDR             0x42
+#define ov3640_I2C_ADDR             0x78
+#define ov3660_I2C_ADDR             0x78
+#define ov5640_I2C_ADDR             0x78
+#define ov5642_I2C_ADDR             0x78
+
+#define s5k6aa_I2C_ADDR             0x78           //0x5a
+#define s5k5ca_I2C_ADDR             0x78           //0x5a
+
+#define mt9d112_I2C_ADDR             0x78
+#define mt9d113_I2C_ADDR             0x78
+#define mt9t111_I2C_ADDR             0x78           // 0x7a 
+
+#define mt9p111_I2C_ADDR            0x78            //0x7a
+#define gt2005_I2C_ADDR             0x78           
+#define gc0307_I2C_ADDR             0x42
+#define gc0328_I2C_ADDR             0x42
+#define gc0308_I2C_ADDR             0x42
+#define gc0309_I2C_ADDR             0x42
+#define gc0329_I2C_ADDR             0x62           
+#define gc2015_I2C_ADDR             0x60
+#define gc2035_I2C_ADDR             0x78            
+
+#define siv120b_I2C_ADDR             INVALID_VALUE           
+#define siv121d_I2C_ADDR             INVALID_VALUE           
+#define sid130B_I2C_ADDR             0x37
+
+#define hi253_I2C_ADDR             0x40
+#define hi704_I2C_ADDR             0x60
+
+#define nt99160_I2C_ADDR             0x54
+#define nt99240_I2C_ADDR             0x6c
+#define nt99250_I2C_ADDR             0x6c
+#define nt99252_I2C_ADDR             0x6c
+#define nt99340_I2C_ADDR             0x76
+
+#define sp0718_I2C_ADDR             0x42
+#define sp0838_I2C_ADDR             INVALID_VALUE  
+#define sp0a19_I2C_ADDR             0x7a
+#define sp1628_I2C_ADDR             0x78
+#define sp2518_I2C_ADDR             0x60 
+#define mtk9335isp_I2C_ADDR         0x50 
+#define hm2057_I2C_ADDR             0x48
+#define hm5065_I2C_ADDR             0x3e
+#define icatchmi1040_I2C_ADDR		0x78
+#define icatchov5693_I2C_ADDR       0x78
+#define icatchov8825_I2C_ADDR       0x78  //zyt
+#define icatchov2720_I2C_ADDR       0x78  //zyt
+#define end_I2C_ADDR                INVALID_VALUE
+
+
+//Sensor power down active level define
+#define ov7675_PWRDN_ACTIVE             0x01            
+#define ov9650_PWRDN_ACTIVE             0x01           
+#define ov2640_PWRDN_ACTIVE             0x01
+#define ov2655_PWRDN_ACTIVE             0x01
+#define ov2659_PWRDN_ACTIVE             0x01
+
+#define ov2660_PWRDN_ACTIVE             0x01  //yzm
+
+#define ov7690_PWRDN_ACTIVE             0x01
+#define ov3640_PWRDN_ACTIVE             0x01
+#define ov3660_PWRDN_ACTIVE             0x01
+#define ov5640_PWRDN_ACTIVE             0x01
+#define ov5642_PWRDN_ACTIVE             0x01
+
+#define s5k6aa_PWRDN_ACTIVE             0x00           
+#define s5k5ca_PWRDN_ACTIVE             0x00           
+
+#define mt9d112_PWRDN_ACTIVE             0x01
+#define mt9d113_PWRDN_ACTIVE             0x01
+#define mt9t111_PWRDN_ACTIVE             0x01  
+#define mt9p111_PWRDN_ACTIVE             0x01
+
+#define gt2005_PWRDN_ACTIVE             0x00           
+#define gc0307_PWRDN_ACTIVE             0x01
+#define gc0308_PWRDN_ACTIVE             0x01
+#define gc0328_PWRDN_ACTIVE             0x01
+#define gc0309_PWRDN_ACTIVE             0x01
+#define gc0329_PWRDN_ACTIVE             0x01           
+#define gc2015_PWRDN_ACTIVE             0x01
+#define gc2035_PWRDN_ACTIVE             0x01            
+
+#define siv120b_PWRDN_ACTIVE             INVALID_VALUE           
+#define siv121d_PWRDN_ACTIVE             INVALID_VALUE           
+#define sid130B_PWRDN_ACTIVE             0x37
+
+#define hi253_PWRDN_ACTIVE             0x01
+#define hi704_PWRDN_ACTIVE             0x01
+
+#define nt99160_PWRDN_ACTIVE             0x01
+#define nt99240_PWRDN_ACTIVE             0x01
+#define nt99250_PWRDN_ACTIVE             0x01
+#define nt99252_PWRDN_ACTIVE             0x01
+#define nt99340_PWRDN_ACTIVE             0x01
+
+#define sp0718_PWRDN_ACTIVE             0x01
+#define sp0838_PWRDN_ACTIVE             0x01  
+#define sp0a19_PWRDN_ACTIVE             0x01
+#define sp1628_PWRDN_ACTIVE             0x01
+#define sp2518_PWRDN_ACTIVE             0x01 
+#define hm2057_PWRDN_ACTIVE             0x01
+#define hm5065_PWRDN_ACTIVE             0x00
+#define mtk9335isp_PWRDN_ACTIVE         0x01 
+#define end_PWRDN_ACTIVE                INVALID_VALUE
+
+
+//Sensor power up sequence  define
+//type: bit0-bit4
+#define SENSOR_PWRSEQ_BEGIN         0x00
+#define SENSOR_PWRSEQ_AVDD          0x01
+#define SENSOR_PWRSEQ_DOVDD         0x02
+#define SENSOR_PWRSEQ_DVDD          0x03
+#define SENSOR_PWRSEQ_PWR           0x04
+#define SENSOR_PWRSEQ_HWRST         0x05
+#define SENSOR_PWRSEQ_PWRDN         0x06
+#define SENSOR_PWRSEQ_CLKIN         0x07
+#define SENSOR_PWRSEQ_END           0x0F
+
+#define SENSOR_PWRSEQ_SET(type,idx)    (type<<(idx*4))
+#define SENSOR_PWRSEQ_GET(seq,idx)     ((seq>>(idx*4))&0x0f)
+
+#define sensor_PWRSEQ_DEFAULT      (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,1)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWRDN,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,3))
+
+#define ov7675_PWRSEQ                   sensor_PWRSEQ_DEFAULT            
+#define ov9650_PWRSEQ                   sensor_PWRSEQ_DEFAULT  
+#define ov2640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov2655_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov2659_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define ov2660_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define ov7690_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov3640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov3660_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov5640_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define ov5642_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define s5k6aa_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
+#define s5k5ca_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
+
+#define mt9d112_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define mt9d113_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define mt9t111_PWRSEQ                   sensor_PWRSEQ_DEFAULT 
+#define mt9p111_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define gt2005_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
+#define gc0307_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc0308_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc0328_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc0309_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc0329_PWRSEQ                   sensor_PWRSEQ_DEFAULT          
+#define gc2015_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define gc2035_PWRSEQ                   sensor_PWRSEQ_DEFAULT            
+
+#define siv120b_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
+#define siv121d_PWRSEQ                   sensor_PWRSEQ_DEFAULT         
+#define sid130B_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define hi253_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define hi704_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define nt99160_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define nt99240_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define nt99250_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define nt99252_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define nt99340_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+
+#define sp0718_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define sp0838_PWRSEQ                   sensor_PWRSEQ_DEFAULT  
+#define sp0a19_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define sp1628_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define sp2518_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define hm2057_PWRSEQ                   sensor_PWRSEQ_DEFAULT
+#define hm5065_PWRSEQ                   (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,1)|\
+                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWRDN,0)|\
+                                        SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,3))
+#define mtk9335isp_PWRSEQ               sensor_PWRSEQ_DEFAULT
+#define icatchov5693_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))
+                                    
+#define icatchov8825_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))     //zyt                                    
+                                    
+#define icatchov2720_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))     //zyt 
+
+#define icatchmi1040_PWRSEQ               (SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_PWR,0)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_HWRST,2)|\
+                                    SENSOR_PWRSEQ_SET(SENSOR_PWRSEQ_CLKIN,1))
+
+#define end_PWRSEQ                      0xffffffff
+                                          
+
+
+/*---------------- Camera Sensor Must Define Macro End  ------------------------*/
+
+#endif
+
diff --git a/drivers/media/Kconfig b/drivers/media/Kconfig
index 8c14041057d8..69ac19957b76 100644
--- a/drivers/media/Kconfig
+++ b/drivers/media/Kconfig
@@ -199,5 +199,6 @@ source "drivers/media/i2c/Kconfig"
 source "drivers/media/tuners/Kconfig"
 source "drivers/media/dvb-frontends/Kconfig"
 source "drivers/media/video/rk_camsys/Kconfig"
+source "drivers/media/video/Kconfig"
 
 endif # MEDIA_SUPPORT
diff --git a/drivers/media/Makefile b/drivers/media/Makefile
index fe039e96f9c8..6b9d6e1576b3 100644
--- a/drivers/media/Makefile
+++ b/drivers/media/Makefile
@@ -18,7 +18,8 @@ ifeq ($(CONFIG_MEDIA_CONTROLLER),y)
   obj-$(CONFIG_MEDIA_SUPPORT) += media.o
 endif
 
-obj-$(CONFIG_VIDEO_DEV) += v4l2-core/
+#obj-$(CONFIG_VIDEO_DEV) += v4l2-core/
+obj-y += v4l2-core/
 obj-$(CONFIG_DVB_CORE)  += dvb-core/
 
 # There are both core and drivers at RC subtree - merge before drivers
@@ -30,5 +31,6 @@ obj-y += rc/
 
 obj-y += common/ platform/ pci/ usb/ mmc/ firewire/ parport/
 obj-$(CONFIG_VIDEO_DEV) += radio/
-
 obj-y += video/rk_camsys/
+obj-y += video/
+obj-y += platform/
diff --git a/drivers/media/platform/soc_camera/soc_camera.c b/drivers/media/platform/soc_camera/soc_camera.c
index 3a4efbdc7668..4576be93d2b7 100644
--- a/drivers/media/platform/soc_camera/soc_camera.c
+++ b/drivers/media/platform/soc_camera/soc_camera.c
@@ -502,7 +502,7 @@ static int soc_camera_set_fmt(struct soc_camera_device *icd,
 		icd->user_width, icd->user_height);
 
 	/* set physical bus parameters */
-	return ici->ops->set_bus_param(icd);
+	return ici->ops->set_bus_param(icd, pix->pixelformat);//yzm
 }
 
 static int soc_camera_open(struct file *file)
@@ -1165,7 +1165,11 @@ static int soc_camera_probe(struct soc_camera_device *icd)
 	/* The camera could have been already on, try to reset */
 	if (ssdd->reset)
 		ssdd->reset(icd->pdev);
-
+	/*********yzm**********/	
+	ret = soc_camera_power_on(icd->pdev,ssdd);
+	if (ret < 0)
+		goto eadd;
+	/*********yzm*********/
 	mutex_lock(&ici->host_lock);
 	ret = ici->ops->add(icd);
 	mutex_unlock(&ici->host_lock);
@@ -1176,7 +1180,7 @@ static int soc_camera_probe(struct soc_camera_device *icd)
 	ret = video_dev_create(icd);
 	if (ret < 0)
 		goto evdc;
-
+	ssdd->socdev = icd;//yzm
 	/* Non-i2c cameras, e.g., soc_camera_platform, have no board_info */
 	if (shd->board_info) {
 		ret = soc_camera_init_i2c(icd, sdesc);
@@ -1264,6 +1268,7 @@ static int soc_camera_probe(struct soc_camera_device *icd)
 evdc:
 	mutex_lock(&ici->host_lock);
 	ici->ops->remove(icd);
+	soc_camera_power_off(icd->pdev,ssdd);//yzm
 	mutex_unlock(&ici->host_lock);
 eadd:
 	v4l2_ctrl_handler_free(&icd->ctrl_handler);
diff --git a/drivers/media/v4l2-core/videobuf-dma-contig.c b/drivers/media/v4l2-core/videobuf-dma-contig.c
index 67f572c3fba2..9279921ee1d8 100644
--- a/drivers/media/v4l2-core/videobuf-dma-contig.c
+++ b/drivers/media/v4l2-core/videobuf-dma-contig.c
@@ -265,6 +265,7 @@ static int __videobuf_iolock(struct videobuf_queue *q,
 			return -ENOMEM;
 		break;
 	case V4L2_MEMORY_OVERLAY:
+		 break; /* ddl@rock-chips.com : nzy modify V4L2_MEMORY_OVERLAY   */
 	default:
 		dev_dbg(q->dev, "%s memory method OVERLAY/unknown\n", __func__);
 		return -EINVAL;
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
new file mode 100644
index 000000000000..8aca45fd2f99
--- /dev/null
+++ b/drivers/media/video/Kconfig
@@ -0,0 +1,22 @@
+config ROCK_CHIP_SOC_CAMERA
+	tristate "rockchip supported soc cameras "
+	select SOC_CAMERA
+	select VIDEOBUF_DMA_CONTIG
+	default y
+	
+menu "rockchip camera sensor interface driver"
+	depends on ROCK_CHIP_SOC_CAMERA
+
+	config ROCKCHIP_CAMERA_SENSOR_INTERFACE
+		tristate "rockchip camera sensor interface driver"
+		default y
+		
+	config RK30_CAMERA_ONEFRAME
+		tristate "rk30_camera_oneframe"
+		depends on ROCKCHIP_CAMERA_SENSOR_INTERFACE
+		default y
+	
+	config OV2659
+		tristate "ov2659,support"
+		default y
+endmenu		
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
new file mode 100644
index 000000000000..7dfc4b65f8c7
--- /dev/null
+++ b/drivers/media/video/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_RK30_CAMERA_ONEFRAME) += rk30_camera_oneframe.o generic_sensor.o 
+obj-$(CONFIG_OV2659) += ov2659.o
\ No newline at end of file
diff --git a/drivers/media/video/generic_sensor.c b/drivers/media/video/generic_sensor.c
index 681fd9f2c05f..c4613b272b36 100755
--- a/drivers/media/video/generic_sensor.c
+++ b/drivers/media/video/generic_sensor.c
@@ -1,1447 +1,1519 @@
-#include <linux/videodev2.h>
-#include <linux/slab.h>
-#include <linux/i2c.h>
-#include <linux/log2.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/circ_buf.h>
-#include <linux/miscdevice.h>
-#include <media/v4l2-common.h>
-#include <media/v4l2-chip-ident.h>
-#include <media/soc_camera.h>
-#include <linux/vmalloc.h>
-#include <linux/hardirq.h>
-#include "generic_sensor.h"
-
+#include <linux/videodev2.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/log2.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/circ_buf.h>
+#include <linux/miscdevice.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/soc_camera.h>
+#include <linux/vmalloc.h>
+#include <linux/hardirq.h>
+#include "generic_sensor.h"
+#include <linux/moduleparam.h>
+ 
 /*
-*      Driver Version Note
-*v0.0.1: this driver is compatible with generic_sensor
-*v0.1.1:
-*        add WqCmd_af_continues_pause;
-*v0.1.3:
-*        add support flash control;
-*
-*v0.1.5/v0.1.7:
-*        fix use v4l2_mbus_framefmt.reserved array overflow in generic_sensor_s_fmt;  
-*v0.1.9:
-*        fix sensor_find_ctrl may be overflow;
-*v0.1.b:
-*        1. support sensor driver crop by redefine SENSOR_CROP_PERCENT;
-*        2. fix sensor_ops which is independent for driver;
-*        3. support cropcap;
-*v.0.1.c:
-*        1. modify generic_sensor_s_fmt, flash will work everytime when capture
+*      Driver Version Note
+*v0.0.1: this driver is compatible with generic_sensor
+*v0.1.1:
+*        add WqCmd_af_continues_pause;
+*v0.1.3:
+*        add support flash control;
+*
+*v0.1.5/v0.1.7:
+*        fix use v4l2_mbus_framefmt.reserved array overflow in generic_sensor_s_fmt;  
+*v0.1.9:
+*        fix sensor_find_ctrl may be overflow;
+*v0.1.b:
+*        1. support sensor driver crop by redefine SENSOR_CROP_PERCENT;
+*        2. fix sensor_ops which is independent for driver;
+*        3. support cropcap;
+*v.0.1.c:
+*        1. modify generic_sensor_s_fmt, flash will work everytime when capture
 *v.0.1.d:
 		 1. add some callbacks for icatch
-*/
-static int version = KERNEL_VERSION(0,1,0xd);
-module_param(version, int, S_IRUGO);
-
-
-static int debug;
-module_param(debug, int, S_IRUGO|S_IWUSR);
-
-#define CAMMODULE_NAME    "rk_cam_sensor"
-
-#define dprintk(level, fmt, arg...) do {			\
-	if (debug >= level) 					\
-	    printk(KERN_WARNING fmt , ## arg); } while (0)
-
-#define SENSOR_NAME_STRING() sensor->dev_name
-
-#undef SENSOR_TR
-#undef SENSOR_DG
-#define SENSOR_TR(format, ...) printk(KERN_ERR "%s(%s:%d): " format"\n", SENSOR_NAME_STRING(),CAMMODULE_NAME,__LINE__, ## __VA_ARGS__)
-#define SENSOR_DG(format, ...) dprintk(1, "%s(%s:%d): "format"\n", SENSOR_NAME_STRING(),CAMMODULE_NAME,__LINE__,## __VA_ARGS__)
-
-
-#define CONFIG_SENSOR_I2C_RDWRCHK 0
-
-static const struct rk_sensor_datafmt *generic_sensor_find_datafmt(
-	enum v4l2_mbus_pixelcode code, const struct rk_sensor_datafmt *fmt,
-	int n);
-
-int sensor_write_reg2val1(struct i2c_client *client, u16 reg,u8 val){	
-	struct rk_sensor_reg tmp_reg;
-    
-	tmp_reg.reg_mask = 0xffff;
-	tmp_reg.val_mask = 0xff;
-	tmp_reg.reg = reg;
-	tmp_reg.val = val;
-	return generic_sensor_write(client, &tmp_reg);
-}
-int sensor_write_reg2val2(struct i2c_client *client, u16 reg,u16 val){
-	struct rk_sensor_reg tmp_reg;
-    
-	tmp_reg.reg_mask = 0xffff;
-	tmp_reg.val_mask = 0xffff;
-	tmp_reg.reg = reg;
-	tmp_reg.val = val;
-	return generic_sensor_write(client, &tmp_reg);
-}
-int sensor_write_reg1val1(struct i2c_client *client, u8 reg,u8 val){
-	struct rk_sensor_reg tmp_reg;
-    
-	tmp_reg.reg_mask = 0xff;
-	tmp_reg.val_mask = 0xff;
-	tmp_reg.reg = reg;
-	tmp_reg.val = val;
-	return generic_sensor_write(client, &tmp_reg);
-}
-int sensor_write_reg1val2(struct i2c_client *client, u8 reg,u16 val){
-	struct rk_sensor_reg tmp_reg;
-    
-	tmp_reg.reg_mask = 0xff;
-	tmp_reg.val_mask = 0xffff;
-	tmp_reg.reg = reg;
-	tmp_reg.val = val;
-	return generic_sensor_write(client, &tmp_reg);
-}
-int sensor_write_reg0val0(struct i2c_client *client, u8 reg,u16 val) 
-{
-    struct generic_sensor *sensor = to_generic_sensor(client);
-
-    SENSOR_TR("SENSOR_REGISTER_LEN and SENSOR_VALUE_LEN is 0, please use generic_sensor_write directly!");
-    return -1;
-}
-/* sensor register write */
-int generic_sensor_write(struct i2c_client *client,struct rk_sensor_reg* sensor_reg)
-{
-	int err,cnt = 0,i;
-	u8 buf[6];
-	struct i2c_msg msg[1];
-	u32 i2c_speed;
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    
-	i2c_speed = sensor->info_priv.gI2c_speed;
-
-	err = 0;
-	switch(sensor_reg->reg){
-		case SEQCMD_WAIT_MS:
-            if (in_atomic())
-                mdelay(sensor_reg->val);
-            else
-			    msleep(sensor_reg->val);
-			break;
-		case SEQCMD_WAIT_US:
-			udelay(sensor_reg->val);
-			break;
-		default:          
-            cnt=0;
-            for (i=2; i>=0; i--) {
-                if(((sensor_reg->reg_mask) & (0xff<<(i*8)))) {
-                    buf[cnt++] = ((sensor_reg->reg)>>(i*8))&0xff;
-                }
-            }
-            for (i=2; i>=0; i--) {
-                if(((sensor_reg->val_mask) & (0xff<<(i*8)))) {
-                    buf[cnt++] = ((sensor_reg->val)>>(i*8))&0xff;
-                }
-            }
-            
-			msg->addr = client->addr;
-			msg->flags = client->flags;
-			msg->buf = buf;
-			msg->scl_rate = i2c_speed;		 /* ddl@rock-chips.com : 100kHz */
-			msg->read_type = 0; 			  /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */
-			msg->len = cnt;
-			cnt = 3;
-			err = -EAGAIN;
-			
-			while ((cnt-- > 0) && (err < 0)) {						 /* ddl@rock-chips.com :  Transfer again if transent is failed	 */
-				err = i2c_transfer(client->adapter, msg, 1);
-			
-				if (err >= 0) {
-                    err = 0;
-					goto write_end;
-				} else {
-					SENSOR_TR("write reg(0x%x, val:0x%x) failed, try to write again!",sensor_reg->reg, sensor_reg->val);
-					udelay(10);
-				}
-			}
-
-	}
-
-write_end:
-	return err;
-}
-
-/* sensor register write buffer */
-int generic_sensor_writebuf(struct i2c_client *client, char *buf, int buf_size)
-{
-	int err=0,cnt = 0;
-	struct i2c_msg msg[1];
-    struct generic_sensor *sensor = to_generic_sensor(client);
-            
-	msg->addr = client->addr;
-	msg->flags = client->flags;
-	msg->buf = buf;
-	msg->scl_rate = sensor->info_priv.gI2c_speed;		 /* ddl@rock-chips.com : 100kHz */
-	msg->read_type = 0; 			  
-	msg->len = buf_size;
-	cnt = 3;
-	err = -EAGAIN;
-	
-	while ((cnt-- > 0) && (err < 0)) {						 /* ddl@rock-chips.com :  Transfer again if transent is failed	 */
-		err = i2c_transfer(client->adapter, msg, 1);
-	
-		if (err >= 0) {
-            err = 0;
-			goto write_end;
-		} else {
-			SENSOR_TR("generic_sensor_writebuf failed!");
-			udelay(10);
-		}
-	}
-
-
-write_end:
-	return err;
-}
-int sensor_read_reg1val1(struct i2c_client *client, u8 reg,u8* val){
-	
-	struct rk_sensor_reg tmp_reg;
-    
-	tmp_reg.reg_mask = 0xff;
-	tmp_reg.val_mask = 0xff;
-	tmp_reg.reg = reg;
-	tmp_reg.val = 0;
-	if(generic_sensor_read(client, &tmp_reg)==0){
-		*val = (u8)(tmp_reg.val & tmp_reg.val_mask);
-	}else{
-		return -1;
-	}
-	return 0;
-}
-int sensor_read_reg2val1(struct i2c_client *client, u16 reg,u8* val){
-	
-	struct rk_sensor_reg tmp_reg;
-    
-	tmp_reg.reg_mask = 0xffff;
-	tmp_reg.val_mask = 0xff;
-	tmp_reg.reg = reg;
-	tmp_reg.val = 0;
-	if(generic_sensor_read(client, &tmp_reg)==0){
-		*val = (u8)(tmp_reg.val & tmp_reg.val_mask);
-	}else{
-		return -1;
-	}
-	return 0;
-}
-int sensor_read_reg2val2(struct i2c_client *client, u16 reg,u16* val){
-	
-	struct rk_sensor_reg tmp_reg;
-    
-	tmp_reg.reg_mask = 0xffff;
-	tmp_reg.val_mask = 0xffff;
-	tmp_reg.reg = reg;
-	tmp_reg.val = 0;
-	if(generic_sensor_read(client, &tmp_reg)==0){
-		*val = (u16)(tmp_reg.val & tmp_reg.val_mask);
-	}else{
-		return -1;
-	}
-	return 0;
-}
-int sensor_read_reg1val2(struct i2c_client *client, u8 reg,u16* val){
-	
-	struct rk_sensor_reg tmp_reg;
-    
-	tmp_reg.reg_mask = 0xff;
-	tmp_reg.val_mask = 0xffff;
-	tmp_reg.reg = reg;
-	tmp_reg.val = 0;
-	if(generic_sensor_read(client, &tmp_reg)==0){
-		*val = (u16)(tmp_reg.val & tmp_reg.val_mask);
-	}else{
-		return -1;
-	}
-	return 0;
-}
-int sensor_read_reg0val0(struct i2c_client *client, u8 reg,u16 val) 
-{
-    struct generic_sensor *sensor = to_generic_sensor(client);
-
-    SENSOR_TR("SENSOR_REGISTER_LEN and SENSOR_VALUE_LEN is 0, please use generic_sensor_read directly!");
-    return -1;
-}
-/* sensor register read */
-int generic_sensor_read(struct i2c_client *client, struct rk_sensor_reg* sensor_reg)
-{
-	int err,cnt = 0,i,bytes;
-	u8 buf_reg[3];
-	u8 buf_val[3];
-	struct i2c_msg msg[2];
-	u32 i2c_speed;
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    
-	i2c_speed = sensor->info_priv.gI2c_speed;
-	
-    cnt=0;            
-    for (i=2; i>=0; i--) {
-        if((sensor_reg->reg_mask) & (0xff<<(i*8))) {
-            buf_reg[cnt++] = ((sensor_reg->reg)>>(i*8))&0xff;
-        }
-    }
-    
-	msg[0].addr = client->addr;
-	msg[0].flags = client->flags;
-	msg[0].buf = buf_reg;
-	msg[0].scl_rate = i2c_speed;		 /* ddl@rock-chips.com : 100kHz */
-	msg[0].read_type = 2;	/* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
-	msg[0].len = cnt;
-
-    cnt=0;
-    for (i=2; i>=0; i--) {
-        if((sensor_reg->val_mask) & (0xff<<(i*8))) {
-            cnt++;
-        }
-    }
-    memset(buf_val,0x00,sizeof(buf_val));
-    
-	msg[1].addr = client->addr;
-	msg[1].flags = client->flags|I2C_M_RD;
-	msg[1].buf = buf_val;
-	msg[1].len = cnt;
-	msg[1].scl_rate = i2c_speed;						 /* ddl@rock-chips.com : 100kHz */
-	msg[1].read_type = 2;							  /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
-
-	cnt = 1;
-	err = -EAGAIN;
-	while ((cnt-- > 0) && (err < 0)) {						 /* ddl@rock-chips.com :  Transfer again if transent is failed	 */
-		err = i2c_transfer(client->adapter, msg, 2);
-		if (err >= 0) {            
-            sensor_reg->val=0;
-            bytes = 0x00;
-            for (i=2; i>=0; i--) {
-                if((sensor_reg->val_mask) & (0xff<<(i*8))) {
-                    sensor_reg->val |= (buf_val[bytes++]<<(i*8));
-                }
-            }
-			err = 0;
-            goto read_end;
-		} else {
-			SENSOR_TR("read reg(0x%x val:0x%x) failed, try to read again!",sensor_reg->reg, sensor_reg->val);
-			udelay(10);
-		}
-	}
-read_end:
-	return err;
-}
-
-/* write a array of registers  */
- int generic_sensor_write_array(struct i2c_client *client, struct rk_sensor_reg *regarray)
-{
-	int err = 0, cnt;
-	int i = 0;
-    bool streamchk;
-#if CONFIG_SENSOR_I2C_RDWRCHK
-	struct rk_sensor_reg check_reg;
-#endif
-	struct generic_sensor *sensor = to_generic_sensor(client);
-
-    if (regarray[0].reg == SEQCMD_STREAMCHK) {
-        streamchk = true;
-        i = 1;
-    } else {
-        streamchk = false;
-        i = 0;
-    }
-
-	cnt = 0;
-	while ((regarray[i].reg != SEQCMD_END) && (regarray[i].reg != SEQCMD_INTERPOLATION))
-	{
-        if (streamchk) {
-            if (sensor->info_priv.stream == false) {
-                err = -1;
-                SENSOR_DG("sensor is stream off, write array terminated!");
-                break;
-            }
-        }
-    
-		if((sensor->info_priv.gReg_mask != 0) /*&& (regarray[i].reg_mask != 0)*/)
-			regarray[i].reg_mask = sensor->info_priv.gReg_mask;
-		if((sensor->info_priv.gVal_mask != 0) /* && (regarray[i].val_mask != 0)*/)
-			regarray[i].val_mask = sensor->info_priv.gVal_mask;
-		err = generic_sensor_write(client, &(regarray[i])); 
-		if (err < 0)
-		{
-			if (cnt-- > 0) {
-				SENSOR_TR("write failed current reg:0x%x, Write array again !",regarray[i].reg);
-				i = 0;
-				continue;
-			} else {
-				SENSOR_TR("write array failed!");
-				err = -EPERM;
-				goto sensor_write_array_end;
-			}
-		} else {
-		#if CONFIG_SENSOR_I2C_RDWRCHK
-			check_reg.reg_mask = regarray[i].reg_mask;
-			check_reg.val_mask = regarray[i].val_mask;
-			check_reg.reg = regarray[i].reg;
-			check_reg.val =0;
-			generic_sensor_read(client, &check_reg);
-			if (check_reg.val!= regarray[i].val)
-				SENSOR_TR("Reg:0x%x write(0x%x, 0x%x) fail", regarray[i].reg, regarray[i].val, check_reg.val );
-		#endif
-		}
-
-		i++;
-	}
-
-
-sensor_write_array_end:
-	return err;
-}
-#if CONFIG_SENSOR_I2C_RDWRCHK
-int generic_sensor_readchk_array(struct i2c_client *client, struct rk_sensor_reg  *regarray)
-{
-	int cnt;
-	int i = 0;
-	struct rk_sensor_reg check_reg;
-    struct generic_sensor *sensor = to_generic_sensor(client);
-
-	cnt = 0;
-	while (regarray[i].reg != SEQCMD_END)
-	{
-		check_reg.reg_mask = regarray[i].reg_mask;
-		check_reg.val_mask = regarray[i].val_mask;
-		check_reg.reg = regarray[i].reg;
-		check_reg.val =0;
-		generic_sensor_read(client, &check_reg);
-		if (check_reg.val!= regarray[i].val)
-			SENSOR_TR("Reg:0x%x write(0x%x, 0x%x) fail", regarray[i].reg, regarray[i].val, check_reg.val );
-
-		i++;
-	}
-	return 0;
-}
-#endif
-
-int generic_sensor_get_max_min_res(struct rk_sensor_sequence* res_array,int num,struct rk_sensor_seq_info * max_real_res,
-										struct rk_sensor_seq_info * max_res,struct rk_sensor_seq_info *min_res){
-	int array_index = 0,err = 0;
-    
-	max_real_res->w = max_res->w = 0;
-	max_real_res->h = max_res->h =0;
-	min_res->w =  min_res->h = 10000;
-	if(!res_array || num <=0){
-		printk("resolution array not valid");
-		err = -1;
-		goto get_end;
-    }
-    
-	//serch min_res
-	while(array_index <num) {
-		if(res_array->data && res_array->data[0].reg != SEQCMD_END){
-			if(res_array->gSeq_info.w < min_res->w ||res_array->gSeq_info.h < min_res->h){
-					memcpy(min_res,&(res_array->gSeq_info),sizeof(struct rk_sensor_seq_info));
-			}
-			if((res_array->gSeq_info.w > max_real_res->w ||res_array->gSeq_info.h > max_real_res->h) 
-				&& (res_array->data[0].reg != SEQCMD_INTERPOLATION)){
-					memcpy(max_real_res,&(res_array->gSeq_info),sizeof(struct rk_sensor_seq_info));
-			}
-			if((res_array->gSeq_info.w > max_res->w ||res_array->gSeq_info.h > max_res->h) 
-				&& (res_array->data[0].reg == SEQCMD_INTERPOLATION)){
-					memcpy(max_res,&(res_array->gSeq_info),sizeof(struct rk_sensor_seq_info));
-			}
-		} 
-		
-		array_index++;
-		res_array++;
-		
-	}
-	if((max_res->w < max_real_res->w) || (max_res->h < max_real_res->h)){
-		max_res->w = max_real_res->w;
-		max_res->h = max_real_res->h;
-	}
-	printk("min_w = %d,min_h = %d ,max_real_w = %d,max_real_h = %d,max_w = %d,max_h =%d\n",
-				min_res->w,min_res->h,max_real_res->w,max_real_res->h,max_res->w,max_res->h);
-	err = 0;
-get_end:
-	return err;
-}
-
-
-// return value: -1 means erro; others means res_array array index
-//se_w & set_h have been set to between MAX and MIN
-static int sensor_try_fmt(struct i2c_client *client,unsigned int *set_w,unsigned int *set_h){
-	int array_index = 0;
-	struct generic_sensor *sensor = to_generic_sensor(client);
-	struct rk_sensor_sequence* res_array = sensor->info_priv.sensor_series;
-	int num = sensor->info_priv.num_series;
-	int tmp_w = 10000,tmp_h = 10000,tmp_index = -1;
-	int resolution_diff_min=10000*10000,resolution_diff;
-
-	while(array_index < num) {        
-        if ((res_array->data) && (res_array->data[0].reg != SEQCMD_END)) {
-            
-            if(res_array->property == SEQUENCE_INIT) {
-				tmp_index = array_index;
-				array_index++;
-				res_array++;
-				continue;
-            }
-
-            resolution_diff = abs(res_array->gSeq_info.w*res_array->gSeq_info.h - (*set_w)*(*set_h));
-            if (resolution_diff<resolution_diff_min) {
-                tmp_w = res_array->gSeq_info.w;
-				tmp_h = res_array->gSeq_info.h;
-				tmp_index = array_index;
-
-                resolution_diff_min = resolution_diff;
-            }
-            
-		}
-        array_index++;
-	    res_array++;
-	}
-	*set_w = tmp_w;
-	*set_h =  tmp_h;
-	//only has the init array
-	if((tmp_w == 10000) && (tmp_index != -1)){        
-		SENSOR_TR("have not other series meet the requirement except init_serie,array_index = %d",tmp_index);
-		*set_w = sensor->info_priv.sensor_series[tmp_index].gSeq_info.w;
-		*set_h = sensor->info_priv.sensor_series[tmp_index].gSeq_info.h;
-		goto try_end;
-	}
-	if((*set_w > sensor->info_priv.max_real_res.w) || (*set_h > sensor->info_priv.max_real_res.h)){
-		SENSOR_DG("it is a interpolation resolution!(%dx%d:%dx%d)",sensor->info_priv.max_real_res.w
-					,sensor->info_priv.max_real_res.h,*set_w,*set_h);
-		*set_w = sensor->info_priv.max_real_res.w;
-		*set_h = sensor->info_priv.max_real_res.h;
-		//find the max_real_res index
-		res_array = sensor->info_priv.sensor_series;
-		array_index = 0;
-		tmp_index = -1;
-		while(array_index < num){
-			if((res_array->data) && (res_array->data[0].reg != SEQCMD_END) && (*set_w  ==res_array->gSeq_info.w) && (*set_h ==res_array->gSeq_info.h)){
-				if((res_array->property != SEQUENCE_INIT)){
-					tmp_index = array_index;
-					break;
-				}else{
-					tmp_index = array_index;
-				}
-			}
-			array_index++;
-			res_array++ ;
-		}
-		
-	}
-try_end:
-	return tmp_index;
-}
-int generic_sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    const struct rk_sensor_datafmt *fmt;
-    int ret = 0;
-    unsigned int set_w,set_h,ori_w,ori_h;
-    
-    ori_w = mf->width;
-    ori_h = mf->height;
-    
-    fmt = generic_sensor_find_datafmt(mf->code, sensor->info_priv.datafmt,
-    						sensor->info_priv.num_datafmt);
-    if (fmt == NULL) {
-        fmt = &(sensor->info_priv.curfmt);
-        mf->code = fmt->code;
-    }
-    /* ddl@rock-chips.com : It is query max resolution only. */
-    if (mf->reserved[6] == 0xfefe5a5a) {
-        mf->height = sensor->info_priv.max_res.h ;
-        mf->width = sensor->info_priv.max_res.w;
-        ret = 0;
-        SENSOR_DG("Query resolution: %dx%d",mf->width, mf->height);
-        goto generic_sensor_try_fmt_end;
-    }
-    //use this to filter unsupported resolutions
-    if (sensor->sensor_cb.sensor_try_fmt_cb_th){
-   	    ret = sensor->sensor_cb.sensor_try_fmt_cb_th(client, mf);
-	    if(ret < 0)
-		    goto generic_sensor_try_fmt_end;
-   	}
-    if (mf->height > sensor->info_priv.max_res.h)
-        mf->height = sensor->info_priv.max_res.h;
-    else if (mf->height < sensor->info_priv.min_res.h)
-        mf->height = sensor->info_priv.min_res.h;
-
-    if (mf->width > sensor->info_priv.max_res.w)
-        mf->width = sensor->info_priv.max_res.w;
-    else if (mf->width < sensor->info_priv.min_res.w)
-        mf->width = sensor->info_priv.min_res.w;
-    set_w = mf->width;
-    set_h = mf->height;    
-    ret = sensor_try_fmt(client,&set_w,&set_h);
-    mf->width = set_w;
-    mf->height = set_h;
-    mf->colorspace = fmt->colorspace;
-    SENSOR_DG("%dx%d is the closest for %dx%d",ori_w,ori_h,set_w,set_h);
-generic_sensor_try_fmt_end:
-    return ret;
-}
-
-int generic_sensor_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *cc)
-{
-    struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    int ret=0;
-
-    cc->bounds.left = 0;
-    cc->bounds.top = 0;
-    cc->bounds.width = sensor->info_priv.max_res.w;
-    cc->bounds.height = sensor->info_priv.max_res.h;
-    
-    cc->pixelaspect.denominator = sensor->info_priv.max_res.w;
-    cc->pixelaspect.numerator = sensor->info_priv.max_res.h;
-
-    return ret;
-}
-
-int generic_sensor_enum_frameintervals(struct v4l2_subdev *sd, struct v4l2_frmivalenum *fival){
-	int err = 0,index_tmp;
-    unsigned int set_w,set_h;
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct generic_sensor *sensor = to_generic_sensor(client);
-
-	if (fival->height > sensor->info_priv.max_res.h|| fival->width > sensor->info_priv.max_res.w){
-        SENSOR_TR("this resolution(%dx%d) isn't support!",fival->width,fival->height);
-        err = -1;
-        goto enum_frameintervals_end;
-	}
-	set_w = fival->width;
-    set_h = fival->height;
-    index_tmp = sensor_try_fmt(client,&set_w,&set_h);
-    fival->discrete.denominator = sensor->info_priv.sensor_series[index_tmp].gSeq_info.fps;
-    fival->discrete.numerator = 1000;
-    fival->reserved[1] = (set_w<<16)|set_h;
-    fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
-
-    SENSOR_DG("%dx%d(real:%dx%d) framerate: %d",fival->width,fival->height,set_w,set_h,fival->discrete.denominator);
-enum_frameintervals_end:
-	return err;
-}
-
-static enum hrtimer_restart generic_flash_off_func(struct hrtimer *timer){
-	struct rk_flash_timer *fps_timer = container_of(timer, struct rk_flash_timer, timer);
-
-    generic_sensor_ioctrl(fps_timer->icd,Sensor_Flash,0);
-	return 0;
-}
-/* Find a data format by a pixel code in an array */
-static const struct rk_sensor_datafmt *generic_sensor_find_datafmt(
-	enum v4l2_mbus_pixelcode code, const struct rk_sensor_datafmt *fmt,
-	int n)
-{
-	int i;
-	for (i = 0; i < n; i++)
-		if (fmt[i].code == code)
-			return fmt + i;
-
-	return NULL;
-}
-int generic_sensor_softreset(struct i2c_client *client, struct rk_sensor_reg *series) {
-    int ret = 0;
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    
-
-    if (sensor->sensor_cb.sensor_softreset_cb)
-         sensor->sensor_cb.sensor_softreset_cb(client,series);
-    
-	/* soft reset */
-    ret = generic_sensor_write_array(client,series);
-	if (ret != 0) {
-		SENSOR_TR("soft reset failed\n");
-		ret = -ENODEV;
-	}
-    msleep(1);
-	return ret;
-    
-}
-int generic_sensor_check_id(struct i2c_client *client, struct rk_sensor_reg *series)
-{
-	int ret,pid = 0,i;
-	struct generic_sensor *sensor = to_generic_sensor(client);
-
-    if (sensor->sensor_cb.sensor_check_id_cb)
-          pid = sensor->sensor_cb.sensor_check_id_cb(client,series);
-
-    /* check if it is an sensor sensor */
-    while (series->reg != SEQCMD_END) {
-
-        pid <<= 8;
-        
-        if (sensor->info_priv.gReg_mask != 0x00) 
-            series->reg_mask = sensor->info_priv.gReg_mask;
-        if (sensor->info_priv.gVal_mask != 0x00)
-            series->val_mask = sensor->info_priv.gVal_mask;
-        
-        ret = generic_sensor_read(client, series);
-        if (ret != 0) {
-    		SENSOR_TR("read chip id failed");
-    		ret = -ENODEV;
-    		goto check_end;
-    	}
-
-        pid |= series->val;
-        series++;
-    }
-    
-	SENSOR_DG("pid = 0x%x", pid);
-
-    for (i=0; i<sensor->info_priv.chip_id_num; i++) {
-        if (pid == sensor->info_priv.chip_id[i]) {
-            sensor->model = sensor->info_priv.chip_ident;    
-            break;
-        }
-    }
-    
-	if (sensor->model != sensor->info_priv.chip_ident) {
-		SENSOR_TR("error: mismatched   pid = 0x%x\n", pid);
-		ret = -ENODEV;
-		goto check_end;
-	} else {
-        ret = 0;
-	}
-    
-check_end:
-	return ret;
-}
-
-int generic_sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
-{
-	struct soc_camera_link *icl = to_soc_camera_link(icd);
-    struct rk29camera_platform_data *pdata = icl->priv_usr;
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    struct generic_sensor *sensor = to_generic_sensor(client);
-	int ret = 0;
-
-	SENSOR_DG("%s cmd(%d) on(%d)\n",__FUNCTION__,cmd,on);
-	switch (cmd)
-	{
-        case Sensor_Power:
-        {
-			if (icl->power) {
-				ret = icl->power(icd->pdev, on);
-			} else {
-			    SENSOR_TR("haven't power callback");
-                ret = -EINVAL;
-			}
-			break;
-		}
-		case Sensor_PowerDown:
-		{
-			if (icl->powerdown) {
-				ret = icl->powerdown(icd->pdev, on);
-			} else {
-			    SENSOR_TR("haven't power down callback");
-                ret = -EINVAL;
-			}
-			break;
-		}
-		case Sensor_Flash:
-		{
-			if (pdata && pdata->sensor_ioctrl) {
-				pdata->sensor_ioctrl(icd->pdev,Cam_Flash, on);
-				if(on==Flash_On){
-                    mdelay(5);
-					//flash off after 2 secs
-					hrtimer_cancel(&(sensor->flash_off_timer.timer));
-					hrtimer_start(&(sensor->flash_off_timer.timer),ktime_set(0, 2000*1000*1000),HRTIMER_MODE_REL);
-				}
-			}
-			break;
-		}
-		default:
-		{
-			SENSOR_TR("%s cmd(%d) is unknown!",__FUNCTION__,cmd);
-			break;
-		}
-	}
-    
-	return ret;
-}
-
-int generic_sensor_init(struct v4l2_subdev *sd, u32 val)
-{
-	int ret = 0;
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct soc_camera_device *icd = client->dev.platform_data;
-	struct generic_sensor *sensor = to_generic_sensor(client);
-	int array_index = 0;
-	int num = sensor->info_priv.num_series;    
-    struct soc_camera_link *icl = to_soc_camera_link(icd);
-    struct rk29camera_platform_data *pdata = icl->priv_usr;
-    struct rkcamera_platform_data *sensor_device=NULL,*new_camera;
-
-    new_camera = pdata->register_dev_new;
-    while (strstr(new_camera->dev_name,"end")==NULL) {
-        if (strcmp(dev_name(icd->pdev), new_camera->dev_name) == 0) {
-            sensor_device = new_camera;
-            break;
-        }
-        new_camera++;
-    }
-    
-    /* ddl@rock-chips.com : i2c speed is config in new_camera_device_ex macro */
-    if (sensor_device) {
-        sensor->info_priv.gI2c_speed = sensor_device->i2c_rate;
-        sensor->info_priv.mirror = sensor_device->mirror;
-    }
-    
-    if (((sensor_device!=NULL) && Sensor_HasBeen_PwrOff(sensor_device->pwdn_info)) 
-        || (sensor_device == NULL)) {  
-        
-        //softreset callback
-        ret =  generic_sensor_softreset(client,sensor->info_priv.sensor_SfRstSeqe);
-    	if(ret != 0){
-    		SENSOR_TR("soft reset failed!");
-    		goto sensor_INIT_ERR;
-    	}
-        
-    	while(array_index < num){
-    		if(sensor->info_priv.sensor_series[array_index].property == SEQUENCE_INIT)
-    			break;
-    		array_index++;
-    	}
-    	if(generic_sensor_write_array(client, sensor->info_priv.sensor_series[array_index].data)!=0){
-    		SENSOR_TR("write init array failed!");
-    		ret = -1;
-    		goto sensor_INIT_ERR;
-    	}
-        if (sensor_device!=NULL) {
-            sensor_device->pwdn_info &= 0xfe;
-            if (sensor->sensor_cb.sensor_mirror_cb)
-                sensor->sensor_cb.sensor_mirror_cb(client, sensor->info_priv.mirror&0x01);
-            if (sensor->sensor_cb.sensor_flip_cb)
-                sensor->sensor_cb.sensor_flip_cb(client, sensor->info_priv.mirror&0x02);
-        }
-        sensor->info_priv.winseqe_cur_addr = sensor->info_priv.sensor_series + array_index;
-
-        //set focus status ,init focus
-        sensor->sensor_focus.focus_state = FocusState_Inval;
-    	sensor->sensor_focus.focus_mode = WqCmd_af_invalid;
-    	sensor->sensor_focus.focus_delay = WqCmd_af_invalid;    	
-	
-    }
-    
-    if (sensor->sensor_cb.sensor_activate_cb)
-        sensor->sensor_cb.sensor_activate_cb(client);
-   
-
-    if (sensor->flash_off_timer.timer.function==NULL)
-        sensor->flash_off_timer.timer.function = generic_flash_off_func;
-    
-	sensor->info_priv.funmodule_state |= SENSOR_INIT_IS_OK;
-    
-	return 0;
-sensor_INIT_ERR:
-	sensor->info_priv.funmodule_state &= ~SENSOR_INIT_IS_OK;
-	if(sensor->sensor_cb.sensor_deactivate_cb)
-		sensor->sensor_cb.sensor_deactivate_cb(client);
-	return ret;
-}
- int generic_sensor_set_bus_param(struct soc_camera_device *icd,
-								unsigned long flags)
-{
-
-	return 0;
-}
-
-unsigned long generic_sensor_query_bus_param(struct soc_camera_device *icd)
-{
-	struct soc_camera_link *icl = to_soc_camera_link(icd);
-	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-	struct generic_sensor *sensor = to_generic_sensor(client);
-	
-	unsigned long flags = sensor->info_priv.bus_parameter;
-
-	return soc_camera_apply_sensor_flags(icl, flags);
-}
-int generic_sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct soc_camera_device *icd = client->dev.platform_data;
-	struct generic_sensor *sensor = to_generic_sensor(client);
-
-	mf->width	= icd->user_width;
-	mf->height	= icd->user_height;
-	mf->code	= sensor->info_priv.curfmt.code;
-	mf->colorspace	= sensor->info_priv.curfmt.colorspace;
-	mf->field	= V4L2_FIELD_NONE;
-
-	return 0;
-}
-int generic_sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
-{
-    struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    const struct rk_sensor_datafmt *fmt=NULL;
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    struct rk_sensor_sequence *winseqe_set_addr=NULL;
-    struct sensor_v4l2ctrl_info_s *v4l2ctrl_info=NULL;
-    bool is_capture=(mf->reserved[0]==0xfefe5a5a)?true:false;    /* ddl@rock-chips.com : v0.1.5 */ 
-    int ret=0;
-
-    fmt =generic_sensor_find_datafmt(mf->code, sensor->info_priv.datafmt,
-    	                                sensor->info_priv.num_datafmt);
-    if (!fmt) {
-        ret = -EINVAL;
-        goto sensor_s_fmt_end;
-    }
-    
-    // get the proper series and write the array
-    ret =generic_sensor_try_fmt(sd, mf);
-    winseqe_set_addr = sensor->info_priv.sensor_series+ret;
-
-    ret = 0;    
-    if (sensor->sensor_cb.sensor_s_fmt_cb_th)
-        ret |= sensor->sensor_cb.sensor_s_fmt_cb_th(client, mf, is_capture);
-        
-    v4l2ctrl_info = sensor_find_ctrl(sensor->ctrls,V4L2_CID_FLASH); /* ddl@rock-chips.com: v0.1.3 */        
-    if (v4l2ctrl_info!=NULL) {   
-        if (is_capture) { 
-            if ((v4l2ctrl_info->cur_value == 2) || (v4l2ctrl_info->cur_value == 1)) {
-                generic_sensor_ioctrl(icd, Sensor_Flash, 1);                    
-            }
-        } else {
-            generic_sensor_ioctrl(icd, Sensor_Flash, 0); 
-        }
-    }
-    
-    if(sensor->info_priv.winseqe_cur_addr->data != winseqe_set_addr->data){       
-        ret |= generic_sensor_write_array(client, winseqe_set_addr->data);
-        if (ret != 0) {
-            SENSOR_TR("set format capability failed");
-            goto sensor_s_fmt_end;
-        }
-
-        if (sensor->sensor_cb.sensor_s_fmt_cb_bh)
-            ret |= sensor->sensor_cb.sensor_s_fmt_cb_bh(client, mf, is_capture);
-        sensor->info_priv.winseqe_cur_addr  = winseqe_set_addr;
-        SENSOR_DG("Sensor output is changed to %dx%d",winseqe_set_addr->gSeq_info.w,winseqe_set_addr->gSeq_info.h);
-    } else {
-        SENSOR_DG("Sensor output is still %dx%d",winseqe_set_addr->gSeq_info.w,winseqe_set_addr->gSeq_info.h);
-    }
-	 
-//video or capture special process
-sensor_s_fmt_end:
-    Sensor_CropSet(mf,sensor->crop_percent);    /* ddl@rock-chips.com: v0.1.b */
-	return ret;
-}
- int generic_sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct generic_sensor *sensor = to_generic_sensor(client);
-
-	if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
-		return -EINVAL;
-
-	if (id->match.addr != client->addr)
-		return -ENODEV;
-
-	id->ident = sensor->info_priv.chip_ident;		/* ddl@rock-chips.com :  Return OV2655	identifier */
-	id->revision = 0;
-
-	return 0;
-}
- 
-int generic_sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-    struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    struct sensor_v4l2ctrl_info_s *ctrl_info;
-    struct v4l2_ext_control ext_ctrl;
-    struct soc_camera_device *icd = client->dev.platform_data;
-
-    int ret = 0;
-
-    ctrl_info = sensor_find_ctrl(sensor->ctrls,ctrl->id);
-    if (!ctrl_info) {
-        SENSOR_TR("v4l2_control id(0x%x) is invalidate",ctrl->id);
-        ret = -EINVAL;
-    } else {
-        ext_ctrl.value = ctrl->value;
-        ext_ctrl.id = ctrl->id;
-        
-        ctrl->value = ctrl_info->cur_value;
-        
-        if (ctrl_info->cb) {
-            ret = (ctrl_info->cb)(icd,ctrl_info, &ext_ctrl,false);
-            if(ret == 0)
-                ctrl->value = ctrl_info->cur_value;
-        } else {
-            SENSOR_TR("v4l2_control id(0x%x) callback isn't exist",ctrl->id);
-            ret = -EINVAL;
-        }
-    }
-
-    return ret;
-}
-
-int generic_sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-    struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    struct sensor_v4l2ctrl_info_s *ctrl_info;
-    struct v4l2_ext_control ext_ctrl;
-    int ret = 0;
-
-    ctrl_info = sensor_find_ctrl(sensor->ctrls,ctrl->id);
-    if (!ctrl_info) {
-        SENSOR_TR("v4l2_control id(0x%x) is invalidate",ctrl->id);
-        ret = -EINVAL;
-    } else {
-
-        ext_ctrl.id = ctrl->id;
-        ext_ctrl.value = ctrl->value;
-        
-        if (ctrl_info->cb) {
-            ret = (ctrl_info->cb)(icd,ctrl_info, &ext_ctrl,true);
-        } else {
-            SENSOR_TR("v4l2_control id(0x%x) callback isn't exist",ctrl->id);
-            ret = -EINVAL;
-        }
-    }
-
-    return ret;
-}
-
-int generic_sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    struct sensor_v4l2ctrl_info_s *ctrl_info;
-    int ret = 0;
-
-    ctrl_info = sensor_find_ctrl(sensor->ctrls,ext_ctrl->id);
-    if (!ctrl_info) {
-        SENSOR_TR("v4l2_control id(0x%x) is invalidate",ext_ctrl->id);
-        ret = -EINVAL;
-    } else {
-        ext_ctrl->value = ctrl_info->cur_value;
-        if (ctrl_info->cb) {
-            ret = (ctrl_info->cb)(icd,ctrl_info, ext_ctrl,false);
-        } else {
-            SENSOR_TR("v4l2_control id(0x%x) callback isn't exist",ext_ctrl->id);
-            ret = -EINVAL;
-        }
-
-    }
-
-    return ret;
-}
-
-int generic_sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)
-{
-    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    struct sensor_v4l2ctrl_info_s *ctrl_info;
-    int ret = 0;
-    
-    ctrl_info = sensor_find_ctrl(sensor->ctrls,ext_ctrl->id);
-    if (!ctrl_info) {
-        SENSOR_TR("v4l2_ext_control id(0x%x) is invalidate",ext_ctrl->id);
-        ret = -EINVAL;
-    } else {        
-        if (ctrl_info->cb) {
-            ret = (ctrl_info->cb)(icd,ctrl_info, ext_ctrl,true);
-        } else {
-            SENSOR_TR("v4l2_ext_control id(0x%x) callback isn't exist",ext_ctrl->id);
-            ret = -EINVAL;
-        }
-    }
-    return 0;
-}
-  int generic_sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
- {
-	 struct i2c_client *client = v4l2_get_subdevdata(sd);
-	 struct soc_camera_device *icd = client->dev.platform_data;
-     //struct generic_sensor *sensor = to_generic_sensor(client);
-	 int i, error_cnt=0, error_idx=-1;
- 
-	 for (i=0; i<ext_ctrl->count; i++) {
-		 if (generic_sensor_g_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
-			 error_cnt++;
-			 error_idx = i;
-		 }
-	 }
- 
-	 if (error_cnt > 1)
-		 error_idx = ext_ctrl->count;
- 
-	 if (error_idx != -1) {
-		 ext_ctrl->error_idx = error_idx;
-		 return -EINVAL;
-	 } else {
-		 return 0;
-	 }
- }
-int generic_sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
-{
-    struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    //struct generic_sensor*sensor = to_generic_sensor(client);
-    int i, error_cnt=0, error_idx=-1;
-
-
-    for (i=0; i<ext_ctrl->count; i++) {
-        
-        if (generic_sensor_s_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
-            error_cnt++;
-            error_idx = i;
-        }
-    }
-
-    if (error_cnt > 1)
-        error_idx = ext_ctrl->count;
-
-    if (error_idx != -1) {
-        ext_ctrl->error_idx = error_idx;
-        return -EINVAL;
-    } else {
-        return 0;
-    }
-}
- 
- 
-long generic_sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
-{
-    struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct soc_camera_device *icd = client->dev.platform_data;
-    struct generic_sensor*sensor = to_generic_sensor(client);
-    int ret = 0;
-    int i;
-    bool flash_attach=false;
-    struct rkcamera_platform_data *new_camera;
-
-    SENSOR_DG("%s cmd: 0x%x ",__FUNCTION__,cmd);
-    switch (cmd)
-    {
-        case RK29_CAM_SUBDEV_DEACTIVATE:
-        {
-            if(sensor->sensor_cb.sensor_deactivate_cb)
-                sensor->sensor_cb.sensor_deactivate_cb(client);
-            break;
-        }
-
-        case RK29_CAM_SUBDEV_IOREQUEST:
-        {
-            sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
-            if (sensor->sensor_io_request != NULL) { 
-                sensor->sensor_gpio_res = NULL;
-                for (i=0; i<RK29_CAM_SUPPORT_NUMS;i++) {
-                    if (sensor->sensor_io_request->gpio_res[i].dev_name && 
-                        (strcmp(sensor->sensor_io_request->gpio_res[i].dev_name, dev_name(icd->pdev)) == 0)) {
-                        sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[i];
-                    }
-                }                
-            } else {
-                SENSOR_TR("RK29_CAM_SUBDEV_IOREQUEST fail");
-                ret = -EINVAL;
-                goto sensor_ioctl_end;
-            }
-            /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
-               for this project */
-            if (sensor->sensor_gpio_res) {                
-                if (sensor->sensor_gpio_res->gpio_flash == INVALID_GPIO) {
-                    flash_attach = false;
-                } else { 
-                    flash_attach = true;
-                }
-            }
-
-            new_camera = sensor->sensor_io_request->register_dev_new;
-            while (strstr(new_camera->dev_name,"end")==NULL) {
-                if (strcmp(dev_name(icd->pdev), new_camera->dev_name) == 0) {
-                    if (new_camera->flash){
-                        flash_attach = true;
-                    } else { 
-                        flash_attach = false;
-                    }
-                    break;
-                }
-                new_camera++;
-            }
-
-            if (flash_attach==false) {
-                for (i = 0; i < icd->ops->num_controls; i++) {
-                    if (V4L2_CID_FLASH == icd->ops->controls[i].id) {
-                        sensor->sensor_controls[i].id |= 0x80000000;         			
-                    }
-                }
-            } else {
-                for (i = 0; i < icd->ops->num_controls; i++) {
-                    if(V4L2_CID_FLASH == (icd->ops->controls[i].id&0x7fffffff)){
-                        sensor->sensor_controls[i].id &= 0x7fffffff;
-                    }               
-                }
-            }
-            break;
-        }
-        default:
-        {
-            SENSOR_TR("%s cmd(0x%x) is unknown !\n",__FUNCTION__,cmd);
-            break;
-        }
-    }
-sensor_ioctl_end:
-    return ret;
-}
- 
-int generic_sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
-	 enum v4l2_mbus_pixelcode *code)
-{
-
-    struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct generic_sensor*sensor = to_generic_sensor(client);
-    if (index >= sensor->info_priv.num_datafmt)
-        return -EINVAL;
-
-    *code = sensor->info_priv.datafmt[index].code;
-    return 0;
-} 
- static void sensor_af_workqueue(struct work_struct *work)
-{
-	struct rk_sensor_focus_work *sensor_work = container_of(work, struct rk_sensor_focus_work, dwork.work);
-	struct i2c_client *client = sensor_work->client;
-	struct generic_sensor*sensor = to_generic_sensor(client);
-	//struct rk_sensor_focus_cmd_info cmdinfo;
-	int zone_tm_pos[4];
-	int ret = 0;
-	
-	SENSOR_DG("%s Enter, cmd:0x%x",__FUNCTION__,sensor_work->cmd);
-	
-	switch (sensor_work->cmd) 
-	{
-		case WqCmd_af_init:
-		{
-            if (sensor->sensor_focus.focus_state == FocusState_Inval) { 
-    			if(sensor->sensor_focus.focus_cb.sensor_focus_init_cb !=NULL) {
-    				ret = (sensor->sensor_focus.focus_cb.sensor_focus_init_cb)(client);
-    			}
-    			if (ret < 0) {
-    				SENSOR_TR("WqCmd_af_init is failed in sensor_af_workqueue!");
-    			} else {
-    				if(sensor->sensor_focus.focus_delay != WqCmd_af_invalid) {
-    					generic_sensor_af_workqueue_set(client->dev.platform_data,sensor->sensor_focus.focus_delay,0,false);
-    					sensor->sensor_focus.focus_delay = WqCmd_af_invalid;
-    				}
-                    sensor->sensor_focus.focus_state = FocusState_Inited;
-    				sensor_work->result = WqRet_success;
-    			}
-            } else {
-                sensor_work->result = WqRet_success;
-                SENSOR_DG("sensor af have been inited, WqCmd_af_init is ignore!");
-            }
-			break;
-		}
-		case WqCmd_af_single:
-		{
-			if(sensor->sensor_focus.focus_cb.sensor_af_single_cb!=NULL){
-				ret = (sensor->sensor_focus.focus_cb.sensor_af_single_cb)(client);
-			}
-			if (ret < 0) {
-				SENSOR_TR("%s Sensor_af_single is failed in sensor_af_workqueue!",SENSOR_NAME_STRING());
-				sensor_work->result = WqRet_fail;
-			} else {
-				sensor_work->result = WqRet_success;
-			}
-			break;
-		}
-		case WqCmd_af_near_pos:
-		{
-			if(sensor->sensor_focus.focus_cb.sensor_af_near_cb!=NULL){
-				ret = (sensor->sensor_focus.focus_cb.sensor_af_near_cb)(client);
-			}
-			if (ret < 0)
-			   sensor_work->result = WqRet_fail;
-			else{ 
-			   sensor_work->result = WqRet_success;
-				}
-			break;
-		}
-		case WqCmd_af_far_pos:
-		{
-			if(sensor->sensor_focus.focus_cb.sensor_af_far_cb!=NULL){
-				ret = (sensor->sensor_focus.focus_cb.sensor_af_far_cb)(client);
-			}
-			if (ret < 0)
-			   sensor_work->result = WqRet_fail;
-			else 
-			   sensor_work->result = WqRet_success;
-			break;
-		}
-		case WqCmd_af_special_pos:
-		{
-			if(sensor->sensor_focus.focus_cb.sensor_af_specialpos_cb!=NULL){
-				ret = (sensor->sensor_focus.focus_cb.sensor_af_specialpos_cb)(client,sensor_work->var);
-			}
-			if (ret < 0)
-			   sensor_work->result = WqRet_fail;
-			else 
-			   sensor_work->result = WqRet_success;
-			break;
-		}
-		case WqCmd_af_continues:
-		{
-			if(sensor->sensor_focus.focus_cb.sensor_af_const_cb!=NULL){
-				ret = (sensor->sensor_focus.focus_cb.sensor_af_const_cb)(client);
-			}
-			if (ret < 0)
-			   sensor_work->result = WqRet_fail;
-			else 
-			   sensor_work->result = WqRet_success;
-			break;
-		}
-        case WqCmd_af_continues_pause:
-		{
-			if(sensor->sensor_focus.focus_cb.sensor_af_const_pause_cb!=NULL){
-				ret = (sensor->sensor_focus.focus_cb.sensor_af_const_pause_cb)(client);
-			}
-			if (ret < 0)
-			   sensor_work->result = WqRet_fail;
-			else 
-			   sensor_work->result = WqRet_success;
-			break;
-		} 
-		case WqCmd_af_update_zone:
-		{
-            mutex_lock(&sensor->sensor_focus.focus_lock);
-            zone_tm_pos[0] = sensor->sensor_focus.focus_zone.lx;
-        	zone_tm_pos[1] = sensor->sensor_focus.focus_zone.ty;
-        	zone_tm_pos[2] = sensor->sensor_focus.focus_zone.rx;
-        	zone_tm_pos[3] = sensor->sensor_focus.focus_zone.dy;
-            mutex_unlock(&sensor->sensor_focus.focus_lock);
-            
-			if(sensor->sensor_focus.focus_cb.sensor_af_zoneupdate_cb!=NULL){
-				ret = (sensor->sensor_focus.focus_cb.sensor_af_zoneupdate_cb)(client,zone_tm_pos);
-			}
-			if (ret < 0)
-			   sensor_work->result = WqRet_fail;
-			else 
-			   sensor_work->result = WqRet_success;
-			break;
-		}
-		case WqCmd_af_close:
-		{
-			if(sensor->sensor_focus.focus_cb.sensor_af_close_cb!=NULL){
-				ret = (sensor->sensor_focus.focus_cb.sensor_af_close_cb)(client);
-			}
-			if (ret < 0)
-			   sensor_work->result = WqRet_fail;
-			else 
-			   sensor_work->result = WqRet_success;
-			break;
-		}
-		default:
-			SENSOR_TR("Unknow command(%d) in %s af workqueue!",sensor_work->cmd,SENSOR_NAME_STRING());
-			break;
-	}
-    
-//set_end:    
-	if (sensor_work->wait == false) {
-		kfree((void*)sensor_work);
-	} else {
-		wake_up(&sensor_work->done); 
-	}
-	return;
-}
-
- int generic_sensor_af_workqueue_set(struct soc_camera_device *icd, enum rk_sensor_focus_wq_cmd cmd, int var, bool wait)
-{
-	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-	struct generic_sensor*sensor = to_generic_sensor(client);
-	struct rk_sensor_focus_work *wk;
-	int ret=0;
-
-	if (sensor->sensor_focus.sensor_wq == NULL) { 
-		ret = -EINVAL;
-		goto sensor_af_workqueue_set_end;
-	}
-
-	wk = kzalloc(sizeof(struct rk_sensor_focus_work), GFP_KERNEL);
-	if (wk) {
-		wk->client = client;
-		INIT_DELAYED_WORK(&wk->dwork, sensor_af_workqueue);
-		wk->cmd = cmd;
-		wk->result = WqRet_inval;
-		wk->wait = wait;
-		wk->var = var;
-		init_waitqueue_head(&wk->done);
-
-        SENSOR_DG("generic_sensor_af_workqueue_set:  cmd: %d",cmd);
-        
-		/* ddl@rock-chips.com: 
-		* video_lock is been locked in v4l2_ioctl function, but auto focus may slow,
-		* As a result any other ioctl calls will proceed very, very slowly since each call
-		* will have to wait for the AF to finish. Camera preview is pause,because VIDIOC_QBUF 
-		* and VIDIOC_DQBUF is sched. so unlock video_lock here.
-		*/
-		if (wait == true) {
-			queue_delayed_work(sensor->sensor_focus.sensor_wq,&(wk->dwork),0);
-			mutex_unlock(&icd->video_lock); 					
-			if (wait_event_timeout(wk->done, (wk->result != WqRet_inval), msecs_to_jiffies(5000)) == 0) {
-				SENSOR_TR("af cmd(%d) is timeout!",cmd);						 
-			}
-			flush_workqueue(sensor->sensor_focus.sensor_wq);
-			ret = wk->result;
-			kfree((void*)wk);
-			mutex_lock(&icd->video_lock);  
-		} else {
-			queue_delayed_work(sensor->sensor_focus.sensor_wq,&(wk->dwork),msecs_to_jiffies(10));
-		}
-	} else {
-		SENSOR_TR("af cmd(%d) ingore,because struct sensor_work malloc failed!",cmd);
-		ret = -1;
-	}
-sensor_af_workqueue_set_end:
-	return ret;
-} 
-
-
-int generic_sensor_s_stream(struct v4l2_subdev *sd, int enable)
+*/
+static int version = KERNEL_VERSION(0,1,0xd);
+module_param(version, int, S_IRUGO);
+
+
+static int debug = 0;
+module_param(debug, int, S_IRUGO|S_IWUSR);
+
+#define CAMMODULE_NAME    "rk_cam_sensor"
+
+#define dprintk(level, fmt, arg...) do {			\
+	if (debug >= level) 					\
+	    printk(KERN_WARNING fmt , ## arg); } while (0)
+
+#define SENSOR_NAME_STRING() sensor->dev_name
+
+#undef SENSOR_TR
+#undef SENSOR_DG
+#define SENSOR_TR(format, ...) printk(KERN_ERR "%s(%s:%d): " format"\n", SENSOR_NAME_STRING(),CAMMODULE_NAME,__LINE__, ## __VA_ARGS__)
+#define SENSOR_DG(format, ...) dprintk(1, "%s(%s:%d): "format"\n", SENSOR_NAME_STRING(),CAMMODULE_NAME,__LINE__,## __VA_ARGS__)
+#define debug_printk(format, ...) dprintk(3, "%s(%s:%d): "format"\n", SENSOR_NAME_STRING(),CAMMODULE_NAME,__LINE__,## __VA_ARGS__)
+
+
+#define CONFIG_SENSOR_I2C_RDWRCHK 0
+
+static const struct rk_sensor_datafmt *generic_sensor_find_datafmt(
+	enum v4l2_mbus_pixelcode code, const struct rk_sensor_datafmt *fmt,
+	int n);
+
+int sensor_write_reg2val1(struct i2c_client *client, u16 reg,u8 val){	
+	struct rk_sensor_reg tmp_reg;
+    
+	tmp_reg.reg_mask = 0xffff;
+	tmp_reg.val_mask = 0xff;
+	tmp_reg.reg = reg;
+	tmp_reg.val = val;
+	return generic_sensor_write(client, &tmp_reg);
+}
+int sensor_write_reg2val2(struct i2c_client *client, u16 reg,u16 val){
+	struct rk_sensor_reg tmp_reg;
+    
+	tmp_reg.reg_mask = 0xffff;
+	tmp_reg.val_mask = 0xffff;
+	tmp_reg.reg = reg;
+	tmp_reg.val = val;
+	return generic_sensor_write(client, &tmp_reg);
+}
+int sensor_write_reg1val1(struct i2c_client *client, u8 reg,u8 val){
+	struct rk_sensor_reg tmp_reg;
+    
+	tmp_reg.reg_mask = 0xff;
+	tmp_reg.val_mask = 0xff;
+	tmp_reg.reg = reg;
+	tmp_reg.val = val;
+	return generic_sensor_write(client, &tmp_reg);
+}
+int sensor_write_reg1val2(struct i2c_client *client, u8 reg,u16 val){
+	struct rk_sensor_reg tmp_reg;
+    
+	tmp_reg.reg_mask = 0xff;
+	tmp_reg.val_mask = 0xffff;
+	tmp_reg.reg = reg;
+	tmp_reg.val = val;
+	return generic_sensor_write(client, &tmp_reg);
+}
+int sensor_write_reg0val0(struct i2c_client *client, u8 reg,u16 val) 
+{
+    struct generic_sensor *sensor = to_generic_sensor(client);
+
+    SENSOR_TR("SENSOR_REGISTER_LEN and SENSOR_VALUE_LEN is 0, please use generic_sensor_write directly!");
+    return -1;
+}
+/* sensor register write */
+int generic_sensor_write(struct i2c_client *client,struct rk_sensor_reg* sensor_reg)
+{
+	int err,cnt = 0,i;
+	u8 buf[6];
+	struct i2c_msg msg[1];
+	u32 i2c_speed;
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    
+	i2c_speed = sensor->info_priv.gI2c_speed;
+	//debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	//debug_printk( "/~~~~~~~~~~~~/ %s:%i-------%s()client = %p\n", __FILE__, __LINE__,__FUNCTION__,client);
+
+	err = 0;
+	switch(sensor_reg->reg){
+		case SEQCMD_WAIT_MS:
+            if (in_atomic())
+                mdelay(sensor_reg->val);
+            else
+			    msleep(sensor_reg->val);
+			break;
+		case SEQCMD_WAIT_US:
+			udelay(sensor_reg->val);
+			break;
+		default:          
+            cnt=0;
+            for (i=2; i>=0; i--) {
+                if(((sensor_reg->reg_mask) & (0xff<<(i*8)))) {
+                    buf[cnt++] = ((sensor_reg->reg)>>(i*8))&0xff;
+                }
+            }
+            for (i=2; i>=0; i--) {
+                if(((sensor_reg->val_mask) & (0xff<<(i*8)))) {
+                    buf[cnt++] = ((sensor_reg->val)>>(i*8))&0xff;
+                }
+            }
+            
+			msg->addr = client->addr;
+			msg->flags = client->flags;
+			msg->buf = buf;
+			msg->scl_rate = i2c_speed;		 /* ddl@rock-chips.com : 100kHz */
+		//	msg->read_type = 0; 			  /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */
+			msg->len = cnt;
+			cnt = 3;
+			err = -EAGAIN;
+			/*
+			debug_printk( "/___________/msg->addr = %x \n",msg->addr);
+			debug_printk( "/___________/msg->flags = %x\n",msg->flags);
+			debug_printk( "/___________/msg->buf = %d\n",msg->buf);
+			debug_printk( "/___________/msg->scl_rate = %d\n",msg->scl_rate);
+			debug_printk( "/___________/msg->len = %d\n",msg->len);
+			debug_printk( "/___________/client->adapter = %p\n",client->adapter);
+			*/
+			while ((cnt-- > 0) && (err < 0)) {						 /* ddl@rock-chips.com :  Transfer again if transent is failed	 */
+				err = i2c_transfer(client->adapter, msg, 1);
+			
+				if (err >= 0) {
+                    err = 0;
+					goto write_end;
+				} else {
+					SENSOR_TR("write reg(0x%x, val:0x%x) failed, try to write again!",sensor_reg->reg, sensor_reg->val);
+					udelay(10);
+				}
+			}
+
+	}
+
+write_end:
+	return err;
+}
+
+/* sensor register write buffer */
+int generic_sensor_writebuf(struct i2c_client *client, char *buf, int buf_size)
+{
+	int err=0,cnt = 0;
+	struct i2c_msg msg[1];
+    struct generic_sensor *sensor = to_generic_sensor(client);
+            
+	msg->addr = client->addr;
+	msg->flags = client->flags;
+	msg->buf = buf;
+	msg->scl_rate = sensor->info_priv.gI2c_speed;		 /* ddl@rock-chips.com : 100kHz */
+	//msg->read_type = 0; 			  
+	msg->len = buf_size;
+	cnt = 3;
+	err = -EAGAIN;
+	
+	while ((cnt-- > 0) && (err < 0)) {						 /* ddl@rock-chips.com :  Transfer again if transent is failed	 */
+		err = i2c_transfer(client->adapter, msg, 1);
+	
+		if (err >= 0) {
+            err = 0;
+			goto write_end;
+		} else {
+			SENSOR_TR("generic_sensor_writebuf failed!");
+			udelay(10);
+		}
+	}
+
+
+write_end:
+	return err;
+}
+int sensor_read_reg1val1(struct i2c_client *client, u8 reg,u8* val){
+	
+	struct rk_sensor_reg tmp_reg;
+    
+	tmp_reg.reg_mask = 0xff;
+	tmp_reg.val_mask = 0xff;
+	tmp_reg.reg = reg;
+	tmp_reg.val = 0;
+	if(generic_sensor_read(client, &tmp_reg)==0){
+		*val = (u8)(tmp_reg.val & tmp_reg.val_mask);
+	}else{
+		return -1;
+	}
+	return 0;
+}
+int sensor_read_reg2val1(struct i2c_client *client, u16 reg,u8* val){
+	
+	struct rk_sensor_reg tmp_reg;
+    
+	tmp_reg.reg_mask = 0xffff;
+	tmp_reg.val_mask = 0xff;
+	tmp_reg.reg = reg;
+	tmp_reg.val = 0;
+	if(generic_sensor_read(client, &tmp_reg)==0){
+		*val = (u8)(tmp_reg.val & tmp_reg.val_mask);
+	}else{
+		return -1;
+	}
+	return 0;
+}
+int sensor_read_reg2val2(struct i2c_client *client, u16 reg,u16* val){
+	
+	struct rk_sensor_reg tmp_reg;
+    
+	tmp_reg.reg_mask = 0xffff;
+	tmp_reg.val_mask = 0xffff;
+	tmp_reg.reg = reg;
+	tmp_reg.val = 0;
+	if(generic_sensor_read(client, &tmp_reg)==0){
+		*val = (u16)(tmp_reg.val & tmp_reg.val_mask);
+	}else{
+		return -1;
+	}
+	return 0;
+}
+int sensor_read_reg1val2(struct i2c_client *client, u8 reg,u16* val){
+	
+	struct rk_sensor_reg tmp_reg;
+    
+	tmp_reg.reg_mask = 0xff;
+	tmp_reg.val_mask = 0xffff;
+	tmp_reg.reg = reg;
+	tmp_reg.val = 0;
+	if(generic_sensor_read(client, &tmp_reg)==0){
+		*val = (u16)(tmp_reg.val & tmp_reg.val_mask);
+	}else{
+		return -1;
+	}
+	return 0;
+}
+int sensor_read_reg0val0(struct i2c_client *client, u8 reg,u16 val) 
+{
+    struct generic_sensor *sensor = to_generic_sensor(client);
+
+    SENSOR_TR("SENSOR_REGISTER_LEN and SENSOR_VALUE_LEN is 0, please use generic_sensor_read directly!");
+    return -1;
+}
+/* sensor register read */
+int generic_sensor_read(struct i2c_client *client, struct rk_sensor_reg* sensor_reg)
+{
+	int err,cnt = 0,i,bytes;
+	u8 buf_reg[3];
+	u8 buf_val[3];
+	struct i2c_msg msg[2];
+	u32 i2c_speed;
+    struct generic_sensor *sensor = to_generic_sensor(client);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	i2c_speed = sensor->info_priv.gI2c_speed;
+	
+    cnt=0;            
+    for (i=2; i>=0; i--) {
+        if((sensor_reg->reg_mask) & (0xff<<(i*8))) {
+            buf_reg[cnt++] = ((sensor_reg->reg)>>(i*8))&0xff;
+        }
+    }
+    
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = buf_reg;
+	msg[0].scl_rate = i2c_speed;		 /* ddl@rock-chips.com : 100kHz */
+	//msg[0].read_type = 2;	/* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
+	msg[0].len = cnt;
+
+    cnt=0;
+    for (i=2; i>=0; i--) {
+        if((sensor_reg->val_mask) & (0xff<<(i*8))) {
+            cnt++;
+        }
+    }
+    memset(buf_val,0x00,sizeof(buf_val));
+    
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags|I2C_M_RD;
+	msg[1].buf = buf_val;
+	msg[1].len = cnt;
+	msg[1].scl_rate = i2c_speed;						 /* ddl@rock-chips.com : 100kHz */
+	//msg[1].read_type = 2;							  /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
+
+	cnt = 1;
+	err = -EAGAIN;
+	while ((cnt-- > 0) && (err < 0)) {						 /* ddl@rock-chips.com :  Transfer again if transent is failed	 */
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err >= 0) {            
+            sensor_reg->val=0;
+            bytes = 0x00;
+            for (i=2; i>=0; i--) {
+                if((sensor_reg->val_mask) & (0xff<<(i*8))) {
+                    sensor_reg->val |= (buf_val[bytes++]<<(i*8));
+                }
+            }
+			err = 0;
+            goto read_end;
+		} else {
+			SENSOR_TR("read reg(0x%x val:0x%x) failed, try to read again!",sensor_reg->reg, sensor_reg->val);
+			udelay(10);
+		}
+	}
+read_end:
+	return err;
+}
+
+/* write a array of registers  */
+ int generic_sensor_write_array(struct i2c_client *client, struct rk_sensor_reg *regarray)
+{
+	int err = 0, cnt;
+	int i = 0;
+    bool streamchk;
+
+#if CONFIG_SENSOR_I2C_RDWRCHK
+	struct rk_sensor_reg check_reg;
+#endif
+	struct generic_sensor *sensor = to_generic_sensor(client);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+	if (regarray[0].reg == SEQCMD_STREAMCHK) {
+        streamchk = true;
+        i = 1;
+    } else {
+        streamchk = false;
+        i = 0;
+    }
+
+	cnt = 0;
+	while ((regarray[i].reg != SEQCMD_END) && (regarray[i].reg != SEQCMD_INTERPOLATION))
+	{
+        if (streamchk) {
+            if (sensor->info_priv.stream == false) {
+                err = -1;
+                SENSOR_DG("sensor is stream off, write array terminated!");
+                break;
+            }
+        }
+    
+		if((sensor->info_priv.gReg_mask != 0) /*&& (regarray[i].reg_mask != 0)*/)
+			regarray[i].reg_mask = sensor->info_priv.gReg_mask;
+		if((sensor->info_priv.gVal_mask != 0) /* && (regarray[i].val_mask != 0)*/)
+			regarray[i].val_mask = sensor->info_priv.gVal_mask;
+		err = generic_sensor_write(client, &(regarray[i])); 
+		if (err < 0)
+		{
+			if (cnt-- > 0) {
+				SENSOR_TR("write failed current reg:0x%x, Write array again !",regarray[i].reg);
+				i = 0;
+				continue;
+			} else {
+				SENSOR_TR("write array failed!");
+				err = -EPERM;
+				goto sensor_write_array_end;
+			}
+		} else {
+		#if CONFIG_SENSOR_I2C_RDWRCHK
+			check_reg.reg_mask = regarray[i].reg_mask;
+			check_reg.val_mask = regarray[i].val_mask;
+			check_reg.reg = regarray[i].reg;
+			check_reg.val =0;
+			generic_sensor_read(client, &check_reg);
+			if (check_reg.val!= regarray[i].val)
+				SENSOR_TR("Reg:0x%x write(0x%x, 0x%x) fail", regarray[i].reg, regarray[i].val, check_reg.val );
+		#endif
+		}
+
+		i++;
+	}
+
+
+sensor_write_array_end:
+	return err;
+}
+#if CONFIG_SENSOR_I2C_RDWRCHK
+int generic_sensor_readchk_array(struct i2c_client *client, struct rk_sensor_reg  *regarray)
+{
+	int cnt;
+	int i = 0;
+	struct rk_sensor_reg check_reg;
+    struct generic_sensor *sensor = to_generic_sensor(client);
+
+	cnt = 0;
+	while (regarray[i].reg != SEQCMD_END)
+	{
+		check_reg.reg_mask = regarray[i].reg_mask;
+		check_reg.val_mask = regarray[i].val_mask;
+		check_reg.reg = regarray[i].reg;
+		check_reg.val =0;
+		generic_sensor_read(client, &check_reg);
+		if (check_reg.val!= regarray[i].val)
+			SENSOR_TR("Reg:0x%x write(0x%x, 0x%x) fail", regarray[i].reg, regarray[i].val, check_reg.val );
+
+		i++;
+	}
+	return 0;
+}
+#endif
+
+int generic_sensor_get_max_min_res(struct rk_sensor_sequence* res_array,int num,struct rk_sensor_seq_info * max_real_res,
+										struct rk_sensor_seq_info * max_res,struct rk_sensor_seq_info *min_res){
+	int array_index = 0,err = 0;
+    
+	max_real_res->w = max_res->w = 0;
+	max_real_res->h = max_res->h =0;
+	min_res->w =  min_res->h = 10000;
+	if(!res_array || num <=0){
+		printk("resolution array not valid");
+		err = -1;
+		goto get_end;
+    }
+    
+	//serch min_res
+	while(array_index <num) {
+		if(res_array->data && res_array->data[0].reg != SEQCMD_END){
+			if(res_array->gSeq_info.w < min_res->w ||res_array->gSeq_info.h < min_res->h){
+					memcpy(min_res,&(res_array->gSeq_info),sizeof(struct rk_sensor_seq_info));
+			}
+			if((res_array->gSeq_info.w > max_real_res->w ||res_array->gSeq_info.h > max_real_res->h) 
+				&& (res_array->data[0].reg != SEQCMD_INTERPOLATION)){
+					memcpy(max_real_res,&(res_array->gSeq_info),sizeof(struct rk_sensor_seq_info));
+			}
+			if((res_array->gSeq_info.w > max_res->w ||res_array->gSeq_info.h > max_res->h) 
+				&& (res_array->data[0].reg == SEQCMD_INTERPOLATION)){
+					memcpy(max_res,&(res_array->gSeq_info),sizeof(struct rk_sensor_seq_info));
+			}
+		} 
+		
+		array_index++;
+		res_array++;
+		
+	}
+	if((max_res->w < max_real_res->w) || (max_res->h < max_real_res->h)){
+		max_res->w = max_real_res->w;
+		max_res->h = max_real_res->h;
+	}
+	printk("min_w = %d,min_h = %d ,max_real_w = %d,max_real_h = %d,max_w = %d,max_h =%d\n",
+				min_res->w,min_res->h,max_real_res->w,max_real_res->h,max_res->w,max_res->h);
+	err = 0;
+get_end:
+	return err;
+}
+
+
+// return value: -1 means erro; others means res_array array index
+//se_w & set_h have been set to between MAX and MIN
+static int sensor_try_fmt(struct i2c_client *client,unsigned int *set_w,unsigned int *set_h){
+	int array_index = 0;
+	struct generic_sensor *sensor = to_generic_sensor(client);
+	struct rk_sensor_sequence* res_array = sensor->info_priv.sensor_series;
+	int num = sensor->info_priv.num_series;
+	int tmp_w = 10000,tmp_h = 10000,tmp_index = -1;
+	int resolution_diff_min=10000*10000,resolution_diff;
+
+	while(array_index < num) {        
+        if ((res_array->data) && (res_array->data[0].reg != SEQCMD_END)) {
+            
+            if(res_array->property == SEQUENCE_INIT) {
+				tmp_index = array_index;
+				array_index++;
+				res_array++;
+				continue;
+            }
+
+            resolution_diff = abs(res_array->gSeq_info.w*res_array->gSeq_info.h - (*set_w)*(*set_h));
+            if (resolution_diff<resolution_diff_min) {
+                tmp_w = res_array->gSeq_info.w;
+				tmp_h = res_array->gSeq_info.h;
+				tmp_index = array_index;
+
+                resolution_diff_min = resolution_diff;
+            }
+            
+		}
+        array_index++;
+	    res_array++;
+	}
+	*set_w = tmp_w;
+	*set_h =  tmp_h;
+	//only has the init array
+	if((tmp_w == 10000) && (tmp_index != -1)){        
+		SENSOR_TR("have not other series meet the requirement except init_serie,array_index = %d",tmp_index);
+		*set_w = sensor->info_priv.sensor_series[tmp_index].gSeq_info.w;
+		*set_h = sensor->info_priv.sensor_series[tmp_index].gSeq_info.h;
+		goto try_end;
+	}
+	if((*set_w > sensor->info_priv.max_real_res.w) || (*set_h > sensor->info_priv.max_real_res.h)){
+		SENSOR_DG("it is a interpolation resolution!(%dx%d:%dx%d)",sensor->info_priv.max_real_res.w
+					,sensor->info_priv.max_real_res.h,*set_w,*set_h);
+		*set_w = sensor->info_priv.max_real_res.w;
+		*set_h = sensor->info_priv.max_real_res.h;
+		//find the max_real_res index
+		res_array = sensor->info_priv.sensor_series;
+		array_index = 0;
+		tmp_index = -1;
+		while(array_index < num){
+			if((res_array->data) && (res_array->data[0].reg != SEQCMD_END) && (*set_w  ==res_array->gSeq_info.w) && (*set_h ==res_array->gSeq_info.h)){
+				if((res_array->property != SEQUENCE_INIT)){
+					tmp_index = array_index;
+					break;
+				}else{
+					tmp_index = array_index;
+				}
+			}
+			array_index++;
+			res_array++ ;
+		}
+		
+	}
+try_end:
+	return tmp_index;
+}
+int generic_sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    const struct rk_sensor_datafmt *fmt;
+    int ret = 0;
+    unsigned int set_w,set_h,ori_w,ori_h;
+    
+    ori_w = mf->width;
+    ori_h = mf->height;
+    
+    fmt = generic_sensor_find_datafmt(mf->code, sensor->info_priv.datafmt,
+    						sensor->info_priv.num_datafmt);
+    if (fmt == NULL) {
+        fmt = &(sensor->info_priv.curfmt);
+        mf->code = fmt->code;
+    }
+    /* ddl@rock-chips.com : It is query max resolution only. */
+    if (mf->reserved[6] == 0xfefe5a5a) {
+        mf->height = sensor->info_priv.max_res.h ;
+        mf->width = sensor->info_priv.max_res.w;
+        ret = 0;
+        SENSOR_DG("Query resolution: %dx%d",mf->width, mf->height);
+        goto generic_sensor_try_fmt_end;
+    }
+    //use this to filter unsupported resolutions
+    if (sensor->sensor_cb.sensor_try_fmt_cb_th){
+   	    ret = sensor->sensor_cb.sensor_try_fmt_cb_th(client, mf);
+	    if(ret < 0)
+		    goto generic_sensor_try_fmt_end;
+   	}
+    if (mf->height > sensor->info_priv.max_res.h)
+        mf->height = sensor->info_priv.max_res.h;
+    else if (mf->height < sensor->info_priv.min_res.h)
+        mf->height = sensor->info_priv.min_res.h;
+
+    if (mf->width > sensor->info_priv.max_res.w)
+        mf->width = sensor->info_priv.max_res.w;
+    else if (mf->width < sensor->info_priv.min_res.w)
+        mf->width = sensor->info_priv.min_res.w;
+    set_w = mf->width;
+    set_h = mf->height;    
+    ret = sensor_try_fmt(client,&set_w,&set_h);
+    mf->width = set_w;
+    mf->height = set_h;
+    mf->colorspace = fmt->colorspace;
+    SENSOR_DG("%dx%d is the closest for %dx%d",ori_w,ori_h,set_w,set_h);
+generic_sensor_try_fmt_end:
+    return ret;
+}
+
+int generic_sensor_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *cc)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    int ret=0;
+
+    cc->bounds.left = 0;
+    cc->bounds.top = 0;
+    cc->bounds.width = sensor->info_priv.max_res.w;
+    cc->bounds.height = sensor->info_priv.max_res.h;
+    
+    cc->pixelaspect.denominator = sensor->info_priv.max_res.w;
+    cc->pixelaspect.numerator = sensor->info_priv.max_res.h;
+
+    return ret;
+}
+
+int generic_sensor_enum_frameintervals(struct v4l2_subdev *sd, struct v4l2_frmivalenum *fival){
+	int err = 0,index_tmp;
+    unsigned int set_w,set_h;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct generic_sensor *sensor = to_generic_sensor(client);
+
+	if (fival->height > sensor->info_priv.max_res.h|| fival->width > sensor->info_priv.max_res.w){
+        SENSOR_TR("this resolution(%dx%d) isn't support!",fival->width,fival->height);
+        err = -1;
+        goto enum_frameintervals_end;
+	}
+	set_w = fival->width;
+    set_h = fival->height;
+    index_tmp = sensor_try_fmt(client,&set_w,&set_h);
+    fival->discrete.denominator = sensor->info_priv.sensor_series[index_tmp].gSeq_info.fps;
+    fival->discrete.numerator = 1000;
+    fival->reserved[1] = (set_w<<16)|set_h;
+    fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+
+    SENSOR_DG("%dx%d(real:%dx%d) framerate: %d",fival->width,fival->height,set_w,set_h,fival->discrete.denominator);
+enum_frameintervals_end:
+	return err;
+}
+
+static enum hrtimer_restart generic_flash_off_func(struct hrtimer *timer){
+	struct rk_flash_timer *fps_timer = container_of(timer, struct rk_flash_timer, timer);
+
+    generic_sensor_ioctrl(fps_timer->icd,Sensor_Flash,0);
+	return 0;
+}
+/* Find a data format by a pixel code in an array */
+static const struct rk_sensor_datafmt *generic_sensor_find_datafmt(
+	enum v4l2_mbus_pixelcode code, const struct rk_sensor_datafmt *fmt,
+	int n)
+{
+	int i;
+	for (i = 0; i < n; i++)
+		if (fmt[i].code == code)
+			return fmt + i;
+
+	return NULL;
+}
+int generic_sensor_softreset(struct i2c_client *client, struct rk_sensor_reg *series) {
+    int ret = 0;
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	debug_printk( "/___________/client->addr = %x \n",client->addr);
+
+    if (sensor->sensor_cb.sensor_softreset_cb)
+         sensor->sensor_cb.sensor_softreset_cb(client,series);
+	debug_printk( "/~~~~~~~~~~~~/ %s:%i-------%s()client = %p\n", __FILE__, __LINE__,__FUNCTION__,client);
+	/* soft reset */
+    ret = generic_sensor_write_array(client,series);
+	if (ret != 0) {
+		SENSOR_TR("soft reset failed\n");
+		ret = -ENODEV;
+	}
+    msleep(1);
+	return ret;
+    
+}
+int generic_sensor_check_id(struct i2c_client *client, struct rk_sensor_reg *series)
+{
+	int ret,pid = 0,i;
+	struct generic_sensor *sensor = to_generic_sensor(client);
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    if (sensor->sensor_cb.sensor_check_id_cb)
+          pid = sensor->sensor_cb.sensor_check_id_cb(client,series);
+
+    /* check if it is an sensor sensor */
+    while (series->reg != SEQCMD_END) {
+
+        pid <<= 8;
+        
+        if (sensor->info_priv.gReg_mask != 0x00) 
+            series->reg_mask = sensor->info_priv.gReg_mask;
+        if (sensor->info_priv.gVal_mask != 0x00)
+            series->val_mask = sensor->info_priv.gVal_mask;
+        
+        ret = generic_sensor_read(client, series);
+        if (ret != 0) {
+    		SENSOR_TR("read chip id failed");
+    		ret = -ENODEV;
+    		goto check_end;
+    	}
+
+        pid |= series->val;
+        series++;
+    }
+    
+	SENSOR_DG("pid = 0x%x", pid);
+
+    for (i=0; i<sensor->info_priv.chip_id_num; i++) {
+        if (pid == sensor->info_priv.chip_id[i]) {
+            sensor->model = sensor->info_priv.chip_ident;    
+            break;
+        }
+    }
+    
+	if (sensor->model != sensor->info_priv.chip_ident) {
+		SENSOR_TR("error: mismatched   pid = 0x%x\n", pid);
+		ret = -ENODEV;
+		goto check_end;
+	} else {
+        ret = 0;
+	}
+    
+check_end:
+	return ret;
+}
+
+int generic_sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
+{
+	//struct soc_camera_link *icl = to_soc_camera_link(icd);
+	struct soc_camera_desc *desc = to_soc_camera_desc(icd);
+    struct rk29camera_platform_data *pdata = desc->subdev_desc.drv_priv;//yzm
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct generic_sensor *sensor = to_generic_sensor(client);
+	int ret = 0;
+
+	SENSOR_DG("%s cmd(%d) on(%d)\n",__FUNCTION__,cmd,on);
+	switch (cmd)
+	{
+        case Sensor_Power:
+        {
+			//if (icl->power) {
+			if(desc->subdev_desc.power) {//yzm
+				ret = desc->subdev_desc.power(icd->pdev, on);//yzm
+			} else {
+			    SENSOR_TR("haven't power callback");
+                ret = -EINVAL;
+			}
+			break;
+		}
+		case Sensor_PowerDown:
+		{
+			//if (icl->powerdown) {
+			if(desc->subdev_desc.powerdown) {//yzm
+				ret = desc->subdev_desc.powerdown(icd->pdev, on);//yzm
+			} else {
+			    SENSOR_TR("haven't power down callback");
+                ret = -EINVAL;
+			}
+			break;
+		}
+		case Sensor_Flash:
+		{
+			if (pdata && pdata->sensor_ioctrl) {
+				pdata->sensor_ioctrl(icd->pdev,Cam_Flash, on);
+				if(on==Flash_On){
+                    mdelay(5);
+					//flash off after 2 secs
+					hrtimer_cancel(&(sensor->flash_off_timer.timer));
+					hrtimer_start(&(sensor->flash_off_timer.timer),ktime_set(0, 2000*1000*1000),HRTIMER_MODE_REL);
+				}
+			}
+			break;
+		}
+		default:
+		{
+			SENSOR_TR("%s cmd(%d) is unknown!",__FUNCTION__,cmd);
+			break;
+		}
+	}
+    
+	return ret;
+}
+static int sensor_v4l2ctrl_mirror_cb(struct soc_camera_device *icd, struct sensor_v4l2ctrl_info_s *ctrl_info, 
+													 struct v4l2_ext_control *ext_ctrl){
+	return 0;
+}
+static int sensor_v4l2ctrl_flip_cb(struct soc_camera_device *icd, struct sensor_v4l2ctrl_info_s *ctrl_info, 
+													 struct v4l2_ext_control *ext_ctrl){
+	return 0;
+}
+int generic_sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+	struct generic_sensor *sensor = to_generic_sensor(client);
+	int array_index = 0;
+	int num = sensor->info_priv.num_series;    
+    //struct soc_camera_link *icl = to_soc_camera_link(icd);
+	struct soc_camera_desc *desc = to_soc_camera_desc(icd);//yzm
+    struct rk29camera_platform_data *pdata = desc->subdev_desc.drv_priv;//yzm
+    struct rkcamera_platform_data *sensor_device=NULL,*new_camera;
+
+    new_camera = pdata->register_dev_new;
+    //while (strstr(new_camera->dev_name,"end")==NULL) {
+    while(new_camera != NULL){
+        if (strcmp(dev_name(icd->pdev), new_camera->dev_name) == 0) {
+            sensor_device = new_camera;
+            break;
+        }
+        //new_camera++;
+        new_camera = new_camera->next_camera;
+    }
+    
+    /* ddl@rock-chips.com : i2c speed is config in new_camera_device_ex macro */
+    if (sensor_device) {
+        sensor->info_priv.gI2c_speed = sensor_device->i2c_rate;
+        sensor->info_priv.mirror = sensor_device->mirror;
+    }
+    
+    if (((sensor_device!=NULL) && Sensor_HasBeen_PwrOff(sensor_device->pwdn_info)) 
+        || (sensor_device == NULL)) {  
+        
+        //softreset callback
+        
+		debug_printk( "/~~~~~~~~~~~~/ %s:%i-------%s()client->adapter = %p\n", __FILE__, __LINE__,__FUNCTION__,client->adapter);
+        ret =  generic_sensor_softreset(client,sensor->info_priv.sensor_SfRstSeqe);
+    	if(ret != 0){
+    		SENSOR_TR("soft reset failed!");
+    		goto sensor_INIT_ERR;
+    	}
+        
+    	while(array_index < num){
+    		if(sensor->info_priv.sensor_series[array_index].property == SEQUENCE_INIT)
+    			break;
+    		array_index++;
+    	}
+    	if(generic_sensor_write_array(client, sensor->info_priv.sensor_series[array_index].data)!=0){
+    		SENSOR_TR("write init array failed!");
+    		ret = -1;
+    		goto sensor_INIT_ERR;
+    	}
+        if (sensor_device!=NULL) {
+            sensor_device->pwdn_info &= 0xfe;
+            if (sensor->sensor_cb.sensor_mirror_cb)
+                sensor->sensor_cb.sensor_mirror_cb(client, sensor->info_priv.mirror&0x01);
+            if (sensor->sensor_cb.sensor_flip_cb)
+                sensor->sensor_cb.sensor_flip_cb(client, sensor->info_priv.mirror&0x02);
+        }
+        sensor->info_priv.winseqe_cur_addr = sensor->info_priv.sensor_series + array_index;
+
+        //set focus status ,init focus
+        sensor->sensor_focus.focus_state = FocusState_Inval;
+    	sensor->sensor_focus.focus_mode = WqCmd_af_invalid;
+    	sensor->sensor_focus.focus_delay = WqCmd_af_invalid;    	
+	
+    }
+    
+    if (sensor->sensor_cb.sensor_activate_cb)
+        sensor->sensor_cb.sensor_activate_cb(client);
+   
+
+    if (sensor->flash_off_timer.timer.function==NULL)
+        sensor->flash_off_timer.timer.function = generic_flash_off_func;
+    
+	sensor->info_priv.funmodule_state |= SENSOR_INIT_IS_OK;
+    
+	return 0;
+sensor_INIT_ERR:
+	sensor->info_priv.funmodule_state &= ~SENSOR_INIT_IS_OK;
+	if(sensor->sensor_cb.sensor_deactivate_cb)
+		sensor->sensor_cb.sensor_deactivate_cb(client);
+	return ret;
+}
+ int generic_sensor_set_bus_param(struct soc_camera_device *icd,
+								unsigned long flags)
+{
+
+	return 0;
+}
+
+unsigned long generic_sensor_query_bus_param(struct soc_camera_device *icd)
+{
+	//struct soc_camera_link *icl = to_soc_camera_link(icd);
+	struct soc_camera_desc *desc = to_soc_camera_desc(icd);//yzm
+	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+	struct generic_sensor *sensor = to_generic_sensor(client);
+	/**************yzm************/
+	struct v4l2_mbus_config cfg;	
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	cfg.flags = sensor->info_priv.bus_parameter;
+	return soc_camera_apply_board_flags(&(desc->subdev_desc), &cfg);//yzm
+	/**************yzm*************/
+}
+
+int generic_sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct generic_sensor *sensor = to_generic_sensor(client);
-    struct soc_camera_device *icd = client->dev.platform_data;
-
-    SENSOR_DG("s_stream: %d %d",enable,sensor->sensor_focus.focus_state);
-	if (enable == 1) {
-	    if(sensor->sensor_cb.sensor_s_stream_cb){
-	        sensor->sensor_cb.sensor_s_stream_cb(sd,enable);
-	    }
-		sensor->info_priv.stream = true;
-    	if (sensor->sensor_focus.sensor_wq) {
-			if (sensor->sensor_focus.focus_state == FocusState_Inval) {
-                generic_sensor_af_workqueue_set(icd, WqCmd_af_init, 0, false);				
-			}
-        }
+	struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+	struct generic_sensor *sensor = to_generic_sensor(client);
+
+	mf->width	= icd->user_width;
+	mf->height	= icd->user_height;
+	mf->code	= sensor->info_priv.curfmt.code;
+	mf->colorspace	= sensor->info_priv.curfmt.colorspace;
+	mf->field	= V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+int generic_sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+    const struct rk_sensor_datafmt *fmt=NULL;
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    struct rk_sensor_sequence *winseqe_set_addr=NULL;
+    struct sensor_v4l2ctrl_info_s *v4l2ctrl_info=NULL;
+    bool is_capture=(mf->reserved[0]==0xfefe5a5a)?true:false;    /* ddl@rock-chips.com : v0.1.5 */ 
+    int ret=0;
+
+    fmt =generic_sensor_find_datafmt(mf->code, sensor->info_priv.datafmt,
+    	                                sensor->info_priv.num_datafmt);
+    if (!fmt) {
+        ret = -EINVAL;
+        goto sensor_s_fmt_end;
+    }
+    
+    // get the proper series and write the array
+    ret =generic_sensor_try_fmt(sd, mf);
+    winseqe_set_addr = sensor->info_priv.sensor_series+ret;
+
+    ret = 0;    
+    if (sensor->sensor_cb.sensor_s_fmt_cb_th)
+        ret |= sensor->sensor_cb.sensor_s_fmt_cb_th(client, mf, is_capture);
+        
+    v4l2ctrl_info = sensor_find_ctrl(sensor->ctrls,V4L2_CID_FLASH); /* ddl@rock-chips.com: v0.1.3 */        
+    if (v4l2ctrl_info!=NULL) {   
+        if (is_capture) { 
+            if ((v4l2ctrl_info->cur_value == 2) || (v4l2ctrl_info->cur_value == 1)) {
+                generic_sensor_ioctrl(icd, Sensor_Flash, 1);                    
+            }
+        } else {
+            generic_sensor_ioctrl(icd, Sensor_Flash, 0); 
+        }
+    }
+    
+    if(sensor->info_priv.winseqe_cur_addr->data != winseqe_set_addr->data){       
+        ret |= generic_sensor_write_array(client, winseqe_set_addr->data);
+        if (ret != 0) {
+            SENSOR_TR("set format capability failed");
+            goto sensor_s_fmt_end;
+        }
+
+        if (sensor->sensor_cb.sensor_s_fmt_cb_bh)
+            ret |= sensor->sensor_cb.sensor_s_fmt_cb_bh(client, mf, is_capture);
+        sensor->info_priv.winseqe_cur_addr  = winseqe_set_addr;
+        SENSOR_DG("Sensor output is changed to %dx%d",winseqe_set_addr->gSeq_info.w,winseqe_set_addr->gSeq_info.h);
+    } else {
+        SENSOR_DG("Sensor output is still %dx%d",winseqe_set_addr->gSeq_info.w,winseqe_set_addr->gSeq_info.h);
+    }
+	 
+//video or capture special process
+sensor_s_fmt_end:
+    Sensor_CropSet(mf,sensor->crop_percent);    /* ddl@rock-chips.com: v0.1.b */
+	return ret;
+}
+ int generic_sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct generic_sensor *sensor = to_generic_sensor(client);
+
+	if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
+		return -EINVAL;
+
+	if (id->match.addr != client->addr)
+		return -ENODEV;
+
+	id->ident = sensor->info_priv.chip_ident;		/* ddl@rock-chips.com :  Return OV2655	identifier */
+	id->revision = 0;
+
+	return 0;
+}
+ 
+int generic_sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    struct sensor_v4l2ctrl_info_s *ctrl_info;
+    struct v4l2_ext_control ext_ctrl;
+	struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+    int ret = 0;
+
+    ctrl_info = sensor_find_ctrl(sensor->ctrls,ctrl->id);
+    if (!ctrl_info) {
+        SENSOR_TR("v4l2_control id(0x%x) is invalidate",ctrl->id);
+        ret = -EINVAL;
+    } else {
+        ext_ctrl.value = ctrl->value;
+        ext_ctrl.id = ctrl->id;
+        
+        ctrl->value = ctrl_info->cur_value;
+        
+        if (ctrl_info->cb) {
+            ret = (ctrl_info->cb)(icd,ctrl_info, &ext_ctrl,false);
+            if(ret == 0)
+                ctrl->value = ctrl_info->cur_value;
+        } else {
+            SENSOR_TR("v4l2_control id(0x%x) callback isn't exist",ctrl->id);
+            ret = -EINVAL;
+        }
+    }
+
+    return ret;
+}
+
+int generic_sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+    struct sensor_v4l2ctrl_info_s *ctrl_info;
+    struct v4l2_ext_control ext_ctrl;
+    int ret = 0;
+
+    ctrl_info = sensor_find_ctrl(sensor->ctrls,ctrl->id);
+    if (!ctrl_info) {
+        SENSOR_TR("v4l2_control id(0x%x) is invalidate",ctrl->id);
+        ret = -EINVAL;
+    } else {
+
+        ext_ctrl.id = ctrl->id;
+        ext_ctrl.value = ctrl->value;
+        
+        if (ctrl_info->cb) {
+            ret = (ctrl_info->cb)(icd,ctrl_info, &ext_ctrl,true);
+        } else {
+            SENSOR_TR("v4l2_control id(0x%x) callback isn't exist",ctrl->id);
+            ret = -EINVAL;
+        }
+    }
+
+    return ret;
+}
+
+int generic_sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    struct sensor_v4l2ctrl_info_s *ctrl_info;
+    int ret = 0;
+
+    ctrl_info = sensor_find_ctrl(sensor->ctrls,ext_ctrl->id);
+    if (!ctrl_info) {
+        SENSOR_TR("v4l2_control id(0x%x) is invalidate",ext_ctrl->id);
+        ret = -EINVAL;
+    } else {
+        ext_ctrl->value = ctrl_info->cur_value;
+        if (ctrl_info->cb) {
+            ret = (ctrl_info->cb)(icd,ctrl_info, ext_ctrl,false);
+        } else {
+            SENSOR_TR("v4l2_control id(0x%x) callback isn't exist",ext_ctrl->id);
+            ret = -EINVAL;
+        }
+
+    }
+
+    return ret;
+}
+
+int generic_sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    struct sensor_v4l2ctrl_info_s *ctrl_info;
+    int ret = 0;
+    
+    ctrl_info = sensor_find_ctrl(sensor->ctrls,ext_ctrl->id);
+    if (!ctrl_info) {
+        SENSOR_TR("v4l2_ext_control id(0x%x) is invalidate",ext_ctrl->id);
+        ret = -EINVAL;
+    } else {        
+        if (ctrl_info->cb) {
+            ret = (ctrl_info->cb)(icd,ctrl_info, ext_ctrl,true);
+        } else {
+            SENSOR_TR("v4l2_ext_control id(0x%x) callback isn't exist",ext_ctrl->id);
+            ret = -EINVAL;
+        }
+    }
+    return 0;
+}
+  int generic_sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
+ {
+	 struct i2c_client *client = v4l2_get_subdevdata(sd);
+	 struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+     //struct generic_sensor *sensor = to_generic_sensor(client);
+	 int i, error_cnt=0, error_idx=-1;
+ 
+	 for (i=0; i<ext_ctrl->count; i++) {
+		 if (generic_sensor_g_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
+			 error_cnt++;
+			 error_idx = i;
+		 }
+	 }
+ 
+	 if (error_cnt > 1)
+		 error_idx = ext_ctrl->count;
+ 
+	 if (error_idx != -1) {
+		 ext_ctrl->error_idx = error_idx;
+		 return -EINVAL;
+	 } else {
+		 return 0;
+	 }
+ }
+int generic_sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+    //struct generic_sensor*sensor = to_generic_sensor(client);
+    int i, error_cnt=0, error_idx=-1;
+
+
+    for (i=0; i<ext_ctrl->count; i++) {
+        
+        if (generic_sensor_s_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
+            error_cnt++;
+            error_idx = i;
+        }
+    }
+
+    if (error_cnt > 1)
+        error_idx = ext_ctrl->count;
+
+    if (error_idx != -1) {
+        ext_ctrl->error_idx = error_idx;
+        return -EINVAL;
+    } else {
+        return 0;
+    }
+}
+ 
+ 
+long generic_sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+    struct generic_sensor*sensor = to_generic_sensor(client);
+    int ret = 0;
+    int i;
+    bool flash_attach=false;
+    struct rkcamera_platform_data *new_camera;
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    SENSOR_DG("%s cmd: 0x%x ",__FUNCTION__,cmd);
+    switch (cmd)
+    {
+        case RK29_CAM_SUBDEV_DEACTIVATE:
+        {
+            if(sensor->sensor_cb.sensor_deactivate_cb)
+                sensor->sensor_cb.sensor_deactivate_cb(client);
+            break;
+        }
+
+        case RK29_CAM_SUBDEV_IOREQUEST:
+        {
+            sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
+            if (sensor->sensor_io_request != NULL) { 
+                sensor->sensor_gpio_res = NULL;
+                                
+            } else {
+                SENSOR_TR("RK29_CAM_SUBDEV_IOREQUEST fail");
+                ret = -EINVAL;
+                goto sensor_ioctl_end;
+            }
+            /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
+               for this project */
+            if (sensor->sensor_gpio_res) {                
+                if (sensor->sensor_gpio_res->gpio_flash == INVALID_GPIO) {
+                    flash_attach = false;
+                } else { 
+                    flash_attach = true;
+                }
+            }
+
+            new_camera = sensor->sensor_io_request->register_dev_new;
+            //while (strstr(new_camera->dev_name,"end")==NULL) {
+            while(new_camera != NULL){
+                if (strcmp(dev_name(icd->pdev), new_camera->dev_name) == 0) {
+                    if (new_camera->flash){
+                        flash_attach = true;
+                    } else { 
+                        flash_attach = false;
+                    }
+                    break;
+                }
+                //new_camera++;
+                new_camera = new_camera->next_camera;
+            }
+
+            if (flash_attach==false) {
+                for (i = 0; i < icd->ops->num_controls; i++) {
+                    if (V4L2_CID_FLASH == icd->ops->controls[i].id) {
+                        sensor->sensor_controls[i].id |= 0x80000000;         			
+                    }
+                }
+            } else {
+                for (i = 0; i < icd->ops->num_controls; i++) {
+                    if(V4L2_CID_FLASH == (icd->ops->controls[i].id&0x7fffffff)){
+                        sensor->sensor_controls[i].id &= 0x7fffffff;
+                    }               
+                }
+            }
+            break;
+        }
+        default:
+        {
+            SENSOR_TR("%s cmd(0x%x) is unknown !\n",__FUNCTION__,cmd);
+            break;
+        }
+    }
+sensor_ioctl_end:
+    return ret;
+}
+
+int generic_sensor_s_power(struct v4l2_subdev *sd, int on)
+{
+
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+    struct generic_sensor*sensor = to_generic_sensor(client);
+    int ret = 0;
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	if(on)
+		{
+			ret = soc_camera_power_on(icd->pdev,ssdd);
+			if(ret < 0)				
+            	SENSOR_TR("%s(%d)power_on fail !\n",__FUNCTION__,__LINE__);
+				
+		}
+	else
+		{
+		
+			v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_DEACTIVATE,NULL);
+			soc_camera_power_off(icd->pdev,ssdd);			
+			if(ret < 0)				
+            	SENSOR_TR("%s(%d)power_off fail !\n",__FUNCTION__,__LINE__);
+			
+		}
+	return ret;
+}
+
+
+ 
+int generic_sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+	 enum v4l2_mbus_pixelcode *code)
+{
+
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct generic_sensor*sensor = to_generic_sensor(client);
+    if (index >= sensor->info_priv.num_datafmt)
+        return -EINVAL;
+
+    *code = sensor->info_priv.datafmt[index].code;
+    return 0;
+} 
+ static void sensor_af_workqueue(struct work_struct *work)
+{
+	struct rk_sensor_focus_work *sensor_work = container_of(work, struct rk_sensor_focus_work, dwork.work);
+	struct i2c_client *client = sensor_work->client;
+	struct generic_sensor*sensor = to_generic_sensor(client);
+	//struct rk_sensor_focus_cmd_info cmdinfo;
+	int zone_tm_pos[4];
+	int ret = 0;
+	
+	SENSOR_DG("%s Enter, cmd:0x%x",__FUNCTION__,sensor_work->cmd);
+	
+	switch (sensor_work->cmd) 
+	{
+		case WqCmd_af_init:
+		{
+            if (sensor->sensor_focus.focus_state == FocusState_Inval) { 
+    			if(sensor->sensor_focus.focus_cb.sensor_focus_init_cb !=NULL) {
+    				ret = (sensor->sensor_focus.focus_cb.sensor_focus_init_cb)(client);
+    			}
+    			if (ret < 0) {
+    				SENSOR_TR("WqCmd_af_init is failed in sensor_af_workqueue!");
+    			} else {
+    				if(sensor->sensor_focus.focus_delay != WqCmd_af_invalid) {
+    					generic_sensor_af_workqueue_set(client->dev.platform_data,sensor->sensor_focus.focus_delay,0,false);
+    					sensor->sensor_focus.focus_delay = WqCmd_af_invalid;
+    				}
+                    sensor->sensor_focus.focus_state = FocusState_Inited;
+    				sensor_work->result = WqRet_success;
+    			}
+            } else {
+                sensor_work->result = WqRet_success;
+                SENSOR_DG("sensor af have been inited, WqCmd_af_init is ignore!");
+            }
+			break;
+		}
+		case WqCmd_af_single:
+		{
+			if(sensor->sensor_focus.focus_cb.sensor_af_single_cb!=NULL){
+				ret = (sensor->sensor_focus.focus_cb.sensor_af_single_cb)(client);
+			}
+			if (ret < 0) {
+				SENSOR_TR("%s Sensor_af_single is failed in sensor_af_workqueue!",SENSOR_NAME_STRING());
+				sensor_work->result = WqRet_fail;
+			} else {
+				sensor_work->result = WqRet_success;
+			}
+			break;
+		}
+		case WqCmd_af_near_pos:
+		{
+			if(sensor->sensor_focus.focus_cb.sensor_af_near_cb!=NULL){
+				ret = (sensor->sensor_focus.focus_cb.sensor_af_near_cb)(client);
+			}
+			if (ret < 0)
+			   sensor_work->result = WqRet_fail;
+			else{ 
+			   sensor_work->result = WqRet_success;
+				}
+			break;
+		}
+		case WqCmd_af_far_pos:
+		{
+			if(sensor->sensor_focus.focus_cb.sensor_af_far_cb!=NULL){
+				ret = (sensor->sensor_focus.focus_cb.sensor_af_far_cb)(client);
+			}
+			if (ret < 0)
+			   sensor_work->result = WqRet_fail;
+			else 
+			   sensor_work->result = WqRet_success;
+			break;
+		}
+		case WqCmd_af_special_pos:
+		{
+			if(sensor->sensor_focus.focus_cb.sensor_af_specialpos_cb!=NULL){
+				ret = (sensor->sensor_focus.focus_cb.sensor_af_specialpos_cb)(client,sensor_work->var);
+			}
+			if (ret < 0)
+			   sensor_work->result = WqRet_fail;
+			else 
+			   sensor_work->result = WqRet_success;
+			break;
+		}
+		case WqCmd_af_continues:
+		{
+			if(sensor->sensor_focus.focus_cb.sensor_af_const_cb!=NULL){
+				ret = (sensor->sensor_focus.focus_cb.sensor_af_const_cb)(client);
+			}
+			if (ret < 0)
+			   sensor_work->result = WqRet_fail;
+			else 
+			   sensor_work->result = WqRet_success;
+			break;
+		}
+        case WqCmd_af_continues_pause:
+		{
+			if(sensor->sensor_focus.focus_cb.sensor_af_const_pause_cb!=NULL){
+				ret = (sensor->sensor_focus.focus_cb.sensor_af_const_pause_cb)(client);
+			}
+			if (ret < 0)
+			   sensor_work->result = WqRet_fail;
+			else 
+			   sensor_work->result = WqRet_success;
+			break;
+		} 
+		case WqCmd_af_update_zone:
+		{
+            mutex_lock(&sensor->sensor_focus.focus_lock);
+            zone_tm_pos[0] = sensor->sensor_focus.focus_zone.lx;
+        	zone_tm_pos[1] = sensor->sensor_focus.focus_zone.ty;
+        	zone_tm_pos[2] = sensor->sensor_focus.focus_zone.rx;
+        	zone_tm_pos[3] = sensor->sensor_focus.focus_zone.dy;
+            mutex_unlock(&sensor->sensor_focus.focus_lock);
+            
+			if(sensor->sensor_focus.focus_cb.sensor_af_zoneupdate_cb!=NULL){
+				ret = (sensor->sensor_focus.focus_cb.sensor_af_zoneupdate_cb)(client,zone_tm_pos);
+			}
+			if (ret < 0)
+			   sensor_work->result = WqRet_fail;
+			else 
+			   sensor_work->result = WqRet_success;
+			break;
+		}
+		case WqCmd_af_close:
+		{
+			if(sensor->sensor_focus.focus_cb.sensor_af_close_cb!=NULL){
+				ret = (sensor->sensor_focus.focus_cb.sensor_af_close_cb)(client);
+			}
+			if (ret < 0)
+			   sensor_work->result = WqRet_fail;
+			else 
+			   sensor_work->result = WqRet_success;
+			break;
+		}
+		default:
+			SENSOR_TR("Unknow command(%d) in %s af workqueue!",sensor_work->cmd,SENSOR_NAME_STRING());
+			break;
+	}
+    
+//set_end:    
+	if (sensor_work->wait == false) {
+		kfree((void*)sensor_work);
+	} else {
+		wake_up(&sensor_work->done); 
+	}
+	return;
+}
+
+ int generic_sensor_af_workqueue_set(struct soc_camera_device *icd, enum rk_sensor_focus_wq_cmd cmd, int var, bool wait)
+{
+	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+	struct generic_sensor*sensor = to_generic_sensor(client);
+	struct rk_sensor_focus_work *wk;
+	int ret=0;
+
+	if (sensor->sensor_focus.sensor_wq == NULL) { 
+		ret = -EINVAL;
+		goto sensor_af_workqueue_set_end;
+	}
+
+	wk = kzalloc(sizeof(struct rk_sensor_focus_work), GFP_KERNEL);
+	if (wk) {
+		wk->client = client;
+		INIT_DELAYED_WORK(&wk->dwork, sensor_af_workqueue);
+		wk->cmd = cmd;
+		wk->result = WqRet_inval;
+		wk->wait = wait;
+		wk->var = var;
+		init_waitqueue_head(&wk->done);
+
+        SENSOR_DG("generic_sensor_af_workqueue_set:  cmd: %d",cmd);
+        
+		/* ddl@rock-chips.com: 
+		* video_lock is been locked in v4l2_ioctl function, but auto focus may slow,
+		* As a result any other ioctl calls will proceed very, very slowly since each call
+		* will have to wait for the AF to finish. Camera preview is pause,because VIDIOC_QBUF 
+		* and VIDIOC_DQBUF is sched. so unlock video_lock here.
+		*/
+		if (wait == true) {
+			queue_delayed_work(sensor->sensor_focus.sensor_wq,&(wk->dwork),0);
+			mutex_unlock(&icd->video_lock); 					
+			if (wait_event_timeout(wk->done, (wk->result != WqRet_inval), msecs_to_jiffies(5000)) == 0) {
+				SENSOR_TR("af cmd(%d) is timeout!",cmd);						 
+			}
+			flush_workqueue(sensor->sensor_focus.sensor_wq);
+			ret = wk->result;
+			kfree((void*)wk);
+			mutex_lock(&icd->video_lock);  
+		} else {
+			queue_delayed_work(sensor->sensor_focus.sensor_wq,&(wk->dwork),msecs_to_jiffies(10));
+		}
+	} else {
+		SENSOR_TR("af cmd(%d) ingore,because struct sensor_work malloc failed!",cmd);
+		ret = -1;
+	}
+sensor_af_workqueue_set_end:
+	return ret;
+} 
+
+
+int generic_sensor_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct generic_sensor *sensor = to_generic_sensor(client);
+    struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;
+	struct soc_camera_device *icd = ssdd->socdev;
+
+    SENSOR_DG("s_stream: %d %d",enable,sensor->sensor_focus.focus_state);
+	if (enable == 1) {
+	    if(sensor->sensor_cb.sensor_s_stream_cb){
+	        sensor->sensor_cb.sensor_s_stream_cb(sd,enable);
+	    }
+		sensor->info_priv.stream = true;
+    	if (sensor->sensor_focus.sensor_wq) {
+			if (sensor->sensor_focus.focus_state == FocusState_Inval) {
+                generic_sensor_af_workqueue_set(icd, WqCmd_af_init, 0, false);				
+			}
+        }
 	} else if (enable == 0) {
-	    sensor->info_priv.stream = false;
-	    if(sensor->sensor_cb.sensor_s_stream_cb){
-	        sensor->sensor_cb.sensor_s_stream_cb(sd,enable);
-	    }
-
-		if (sensor->sensor_focus.sensor_wq)
-            flush_workqueue(sensor->sensor_focus.sensor_wq);
-		
-	}
-	return 0;
-} 
-
-int generic_sensor_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize){
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct generic_sensor *sensor = to_generic_sensor(client);
-
-    if(sensor->sensor_cb.sensor_enum_framesizes){
-        return sensor->sensor_cb.sensor_enum_framesizes(sd,fsize);
-    }else{
-        return -1;
-    }
-
-}
-
+	    sensor->info_priv.stream = false;
+	    if(sensor->sensor_cb.sensor_s_stream_cb){
+	        sensor->sensor_cb.sensor_s_stream_cb(sd,enable);
+	    }
+
+		if (sensor->sensor_focus.sensor_wq)
+            flush_workqueue(sensor->sensor_focus.sensor_wq);
+		
+	}
+	return 0;
+} 
+
+int generic_sensor_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize){
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct generic_sensor *sensor = to_generic_sensor(client);
+
+    if(sensor->sensor_cb.sensor_enum_framesizes){
+        return sensor->sensor_cb.sensor_enum_framesizes(sd,fsize);
+    }else{
+        return -1;
+    }
+
+}
+
diff --git a/drivers/media/video/generic_sensor.h b/drivers/media/video/generic_sensor.h
index 879f18ddef36..c26ba667bc8a 100755
--- a/drivers/media/video/generic_sensor.h
+++ b/drivers/media/video/generic_sensor.h
@@ -12,8 +12,9 @@
 #include <media/v4l2-chip-ident.h>
 #include <media/soc_camera.h>
 #include <linux/vmalloc.h>
-#include <plat/rk_camera.h>
-
+#include <linux/module.h>
+#include "../../../arch/arm/mach-rockchip/rk30_camera.h"//yzm
+#include <linux/kernel.h>
 /* Camera Sensor driver */
 
 #define MIN(x,y)   ((x<y) ? x: y)
@@ -296,6 +297,7 @@ extern int generic_sensor_s_ext_control(struct soc_camera_device *icd, struct v4
 extern int generic_sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl);
 extern int generic_sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl);
 extern long generic_sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg);
+extern int generic_sensor_s_power(struct v4l2_subdev *sd, int on);//yzm
 extern int generic_sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,enum v4l2_mbus_pixelcode *code);
 extern int generic_sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf);
 extern int generic_sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id);
@@ -374,16 +376,17 @@ static inline int sensor_video_probe(struct soc_camera_device *icd,
 				   struct i2c_client *client)
 {
 	int ret;
+	
 	struct generic_sensor *sensor = to_generic_sensor(client);
 
 	/* We must have a parent by now. And it cannot be a wrong one.
 	 * So this entire test is completely redundant. */
-	if (!icd->dev.parent ||
-		to_soc_camera_host(icd->dev.parent)->nr != icd->iface) {
+	if (!icd->parent ||
+		to_soc_camera_host(icd->parent)->nr != icd->iface) {
 		ret = -ENODEV;
 		goto sensor_video_probe_end;
 	}
-
+	
 	generic_sensor_softreset(client,sensor->info_priv.sensor_SfRstSeqe);
     ret = generic_sensor_check_id(client,sensor->info_priv.sensor_CkIdSeqe);
 
@@ -420,7 +423,6 @@ static inline void sensor_v4l2ctrl_info_init (struct sensor_v4l2ctrl_info_s *ptr
 {
     ptr->qctrl->id = id;
 	ptr->qctrl->type = type;
-	strcat(ptr->qctrl->name,name);
 	ptr->qctrl->minimum = min;
 	ptr->qctrl->maximum = max;
     ptr->qctrl->step = step;
@@ -469,7 +471,7 @@ static inline int sensor_v4l2ctrl_replace_cb(struct generic_sensor *sensor, int
             ctrls->cb = cb;
             break;
         }
-    }
+    } 
 
     if (i>=num) {
         printk(KERN_ERR "%s(%d): v4l2_control id(0x%x) isn't exist\n",__FUNCTION__,__LINE__,id);
@@ -618,6 +620,7 @@ static inline int sensor_focus_default_cb(struct soc_camera_device *icd, struct
 			}
 		case V4L2_CID_FOCUS_AUTO:
 			{
+				/****************yzm**************
                 mutex_lock(&sensor->sensor_focus.focus_lock);
                 //get focuszone
                 sensor->sensor_focus.focus_zone.lx = ext_ctrl->rect[0];
@@ -641,6 +644,7 @@ static inline int sensor_focus_default_cb(struct soc_camera_device *icd, struct
 					ret = -EINVAL;
 					printk(KERN_ERR"\n %s valure = %d is invalidate..	\n",__FUNCTION__,value);
 				}
+				*///*******************yzm*************end
 				break;
 				
 			}
@@ -735,8 +739,8 @@ static inline int sensor_v4l2ctrl_flip_default_cb(struct soc_camera_device *icd,
     struct v4l2_queryctrl *controls, *control; \
     struct sensor_v4l2ctrl_info_s *ctrls; \
     struct v4l2_querymenu *menus,*menu; \
-    struct soc_camera_link *icl = to_soc_camera_link(icd); \
-    struct rk29camera_platform_data *pdata = icl->priv_usr; \
+	struct soc_camera_desc *desc = to_soc_camera_desc(icd);\
+    struct rk29camera_platform_data *pdata = desc->subdev_desc.drv_priv; \
     struct rkcamera_platform_data *sensor_device=NULL,*new_camera; \
     struct rk_sensor_reg *reg_data; \
     int config_flash = 0;\
@@ -750,12 +754,12 @@ static inline int sensor_v4l2ctrl_flip_default_cb(struct soc_camera_device *icd,
     }\
     sensor_config = SensorConfiguration;\
     new_camera = pdata->register_dev_new; \
-    while (strstr(new_camera->dev_name,"end")==NULL) { \
-        if (strcmp(dev_name(icd->pdev), new_camera->dev_name) == 0) { \
+	while(new_camera != NULL){\
+		if (strcmp(dev_name(icd->pdev), new_camera->dev_name) == 0) { \
             sensor_device = new_camera; \
             break; \
         } \
-        new_camera++; \
+        new_camera = new_camera->next_camera; \
     } \
  \
     if(sensor_device && sensor_device->flash)\
@@ -1218,6 +1222,7 @@ static inline int sensor_v4l2ctrl_flip_default_cb(struct soc_camera_device *icd,
 	.s_ext_ctrls		  = generic_sensor_s_ext_controls,\
 	.g_chip_ident	= generic_sensor_g_chip_ident,\
 	.ioctl = generic_sensor_ioctl,\
+	.s_power = generic_sensor_s_power,\
 };\
 \
 static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {\
@@ -1247,9 +1252,11 @@ MODULE_DEVICE_TABLE(i2c, sensor_id);
 			 const struct i2c_device_id *did)\
 {\
 	struct specific_sensor *spsensor=NULL;\
-	struct soc_camera_device *icd = client->dev.platform_data;\
+	struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;\
+	struct soc_camera_desc *desc = container_of(ssdd,struct soc_camera_desc,subdev_desc);\
+	struct soc_camera_device *icd = ssdd->socdev;\
 	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\
-	struct soc_camera_link *icl;\
+\
 	int ret=0;\
 \
 	if (!icd) {\
@@ -1258,8 +1265,8 @@ MODULE_DEVICE_TABLE(i2c, sensor_id);
         goto sensor_probe_end;\
 	}\
 \
-	icl = to_soc_camera_link(icd);\
-	if (!icl) {\
+	desc = to_soc_camera_desc(icd);\
+	if (!desc) {\
 		SENSOR_TR("driver needs platform data! But it is failed\n");\
 		ret = -EINVAL;\
         goto sensor_probe_end;\
@@ -1310,7 +1317,8 @@ sensor_probe_end:\
 #define sensor_remove_default_code() static int sensor_remove(struct i2c_client *client)\
 {\
 	struct generic_sensor*sensor = to_generic_sensor(client);\
-	struct soc_camera_device *icd = client->dev.platform_data;\
+	struct soc_camera_subdev_desc *ssdd = client->dev.platform_data;\
+	struct soc_camera_device *icd = ssdd->socdev;\
 	struct specific_sensor *spsensor = to_specific_sensor(sensor);\
 	int sensor_config;\
 \
@@ -1364,8 +1372,8 @@ static void __exit sensor_mod_exit(void)\
 \
 device_initcall_sync(sensor_mod_init);\
 module_exit(sensor_mod_exit);\
-\
-MODULE_DESCRIPTION(SENSOR_NAME_STRING(sensor driver));\
+MODULE_DESCRIPTION(SENSOR_NAME_STRING(sensor driver)); \
 MODULE_AUTHOR("<ddl@rock-chips.com,zyc@rock-chips.com>");\
+\
 MODULE_LICENSE("GPL");
 #endif
diff --git a/drivers/media/video/ov2659.c b/drivers/media/video/ov2659.c
index 40550a82ae6c..74d28ceda038 100755
--- a/drivers/media/video/ov2659.c
+++ b/drivers/media/video/ov2659.c
@@ -1,1137 +1,1139 @@
-
-#include "generic_sensor.h"
+
+#include "generic_sensor.h"
+#include <linux/moduleparam.h>
 /*
-*      Driver Version Note
-*v0.0.1: this driver is compatible with generic_sensor
-*v0.1.1:
-*        add sensor_focus_af_const_pause_usr_cb;
-*/
-static int version = KERNEL_VERSION(0,1,3);
-module_param(version, int, S_IRUGO);
-
-static int debug;
-module_param(debug, int, S_IRUGO|S_IWUSR);
-
-#define dprintk(level, fmt, arg...) do {			\
-	if (debug >= level) 					\
-	printk(KERN_WARNING fmt , ## arg); } while (0)
-
-/* Sensor Driver Configuration Begin */
-#define SENSOR_NAME RK29_CAM_SENSOR_OV2659
-#define SENSOR_V4L2_IDENT V4L2_IDENT_OV2659
-#define SENSOR_ID 0x2656
-#define SENSOR_BUS_PARAM                     (SOCAM_MASTER |\
-                                             SOCAM_PCLK_SAMPLE_RISING|SOCAM_HSYNC_ACTIVE_HIGH| SOCAM_VSYNC_ACTIVE_LOW|\
-                                             SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
-#define SENSOR_PREVIEW_W                     800
-#define SENSOR_PREVIEW_H                     600
-#define SENSOR_PREVIEW_FPS                   15000     // 15fps 
-#define SENSOR_FULLRES_L_FPS                 7500      // 7.5fps
-#define SENSOR_FULLRES_H_FPS                 7500      // 7.5fps
-#define SENSOR_720P_FPS                      0
-#define SENSOR_1080P_FPS                     0
-
-#define SENSOR_REGISTER_LEN                  2         // sensor register address bytes
-#define SENSOR_VALUE_LEN                     1         // sensor register value bytes
-                                    
-static unsigned int SensorConfiguration = (CFG_WhiteBalance|CFG_Effect|CFG_Scene);
-static unsigned int SensorChipID[] = {SENSOR_ID};
-/* Sensor Driver Configuration End */
-
-
-#define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
-#define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)
-
-#define SensorRegVal(a,b) CONS4(SensorReg,SENSOR_REGISTER_LEN,Val,SENSOR_VALUE_LEN)(a,b)
-#define sensor_write(client,reg,v) CONS4(sensor_write_reg,SENSOR_REGISTER_LEN,val,SENSOR_VALUE_LEN)(client,(reg),(v))
-#define sensor_read(client,reg,v) CONS4(sensor_read_reg,SENSOR_REGISTER_LEN,val,SENSOR_VALUE_LEN)(client,(reg),(v))
-#define sensor_write_array generic_sensor_write_array
-
-struct sensor_parameter
-{
-	unsigned int PreviewDummyPixels;
-	unsigned int CaptureDummyPixels;
-	unsigned int preview_exposure;
-	unsigned short int preview_line_width;
-	unsigned short int preview_gain;
-
-	unsigned short int PreviewPclk;
-	unsigned short int CapturePclk;
-	char awb[6];
-};
-
-struct specific_sensor{
-	struct generic_sensor common_sensor;
-	//define user data below
-	struct sensor_parameter parameter;
-
-};
-
-/*
-*  The follow setting need been filled.
-*  
-*  Must Filled:
-*  sensor_init_data :               Sensor initial setting;
-*  sensor_fullres_lowfps_data :     Sensor full resolution setting with best auality, recommand for video;
-*  sensor_preview_data :            Sensor preview resolution setting, recommand it is vga or svga;
-*  sensor_softreset_data :          Sensor software reset register;
-*  sensor_check_id_data :           Sensir chip id register;
-*
-*  Optional filled:
-*  sensor_fullres_highfps_data:     Sensor full resolution setting with high framerate, recommand for video;
-*  sensor_720p:                     Sensor 720p setting, it is for video;
-*  sensor_1080p:                    Sensor 1080p setting, it is for video;
-*
-*  :::::WARNING:::::
-*  The SensorEnd which is the setting end flag must be filled int the last of each setting;
-*/
-
-/* Sensor initial setting */
-static struct rk_sensor_reg sensor_init_data[] ={
-	{0x3000, 0x0f},
-	{0x3001, 0xff},
-	{0x3002, 0xff},
-	//{0x0100, 0x01},	//software sleep : Sensor vsync singal may not output if haven't sleep the sensor when transfer the array
-	{0x3633, 0x3d},
-	{0x3620, 0x02},
-	{0x3631, 0x11},
-	{0x3612, 0x04},
-	{0x3630, 0x20},
-	{0x4702, 0x02},
-	{0x370c, 0x34},
-	{0x3004, 0x10},
-	{0x3005, 0x18},
-	{0x3800, 0x00},
-	{0x3801, 0x00},
-	{0x3802, 0x00},
-	{0x3803, 0x00},
-	{0x3804, 0x06},
-	{0x3805, 0x5f},
-	{0x3806, 0x04},
-	{0x3807, 0xb7},
-	{0x3808, 0x03},
-	{0x3809, 0x20},
-	{0x380a, 0x02},
-	{0x380b, 0x58},
-	{0x380c, 0x05},
-	{0x380d, 0x14},
-	{0x380e, 0x02},
-	{0x380f, 0x68},
-	{0x3811, 0x08},
-	{0x3813, 0x02},
-	{0x3814, 0x31},
-	{0x3815, 0x31},
-	{0x3a02, 0x02},
-	{0x3a03, 0x68},
-	{0x3a08, 0x00},
-	{0x3a09, 0x5c},
-	{0x3a0a, 0x00},
-	{0x3a0b, 0x4d},
-	{0x3a0d, 0x08},
-	{0x3a0e, 0x06},
-	{0x3a14, 0x02},
-	{0x3a15, 0x28},
-		{0x4708, 0x01},
-	{0x3623, 0x00},
-	{0x3634, 0x76},
-	{0x3701, 0x44},
-	{0x3702, 0x18},
-	{0x3703, 0x24},
-	{0x3704, 0x24},
-	{0x3705, 0x0c},
-	{0x3820, 0x81},
-	{0x3821, 0x01},
-	{0x370a, 0x52},
-	{0x4608, 0x00},
-	{0x4609, 0x80},
-	{0x4300, 0x32},
-	{0x5086, 0x02},
-	{0x5000, 0xfb},
-	{0x5001, 0x1f},
-	{0x5002, 0x00},
-	{0x5025, 0x0e},
-	{0x5026, 0x18},
-	{0x5027, 0x34},
-	{0x5028, 0x4c},
-	{0x5029, 0x62},
-	{0x502a, 0x74},
-	{0x502b, 0x85},
-	{0x502c, 0x92},
-	{0x502d, 0x9e},
-	{0x502e, 0xb2},
-	{0x502f, 0xc0},
-	{0x5030, 0xcc},
-	{0x5031, 0xe0},
-	{0x5032, 0xee},
-	{0x5033, 0xf6},
-	{0x5034, 0x11},
-	{0x5070, 0x1c},
-	{0x5071, 0x5b},
-	{0x5072, 0x05},
-	{0x5073, 0x20},
-	{0x5074, 0x94},
-	{0x5075, 0xb4},
-	{0x5076, 0xb4},
-	{0x5077, 0xaf},
-	{0x5078, 0x05},
-	{0x5079, 0x98},
-	{0x507a, 0x21},
-	{0x5035, 0x6a},
-	{0x5036, 0x11},
-	{0x5037, 0x92},
-	{0x5038, 0x21},
-	
-	{0x5039, 0xe1},
-	{0x503a, 0x01},
-	{0x503c, 0x05},
-	{0x503d, 0x08},
-	{0x503e, 0x08},
-	{0x503f, 0x64},
-	{0x5040, 0x58},
-	{0x5041, 0x2a},
-	{0x5042, 0xc5},
-	{0x5043, 0x2e},
-	{0x5044, 0x3a},
-	{0x5045, 0x3c},
-	{0x5046, 0x44},
-	{0x5047, 0xf8},
-	{0x5048, 0x08},
-	{0x5049, 0x70},
-	{0x504a, 0xf0},
-	{0x504b, 0xf0},
-	{0x500c, 0x03},
-	{0x500d, 0x20},
-	{0x500e, 0x02},
-	{0x500f, 0x5c},
-	{0x5010, 0x48},
-	{0x5011, 0x00},
-	{0x5012, 0x66},
-	{0x5013, 0x03},
-	{0x5014, 0x30},
-	{0x5015, 0x02},
-	{0x5016, 0x7c},
-	{0x5017, 0x40},
-	{0x5018, 0x00},
-	{0x5019, 0x66},
-	{0x501a, 0x03},
-	{0x501b, 0x10},
-	{0x501c, 0x02},
-	{0x501d, 0x7c},
-	{0x501e, 0x3a},
-	{0x501f, 0x00},
-	{0x5020, 0x66},
-	{0x506e, 0x44},
-	{0x5064, 0x08},
-	{0x5065, 0x10},
-	{0x5066, 0x12},
-	{0x5067, 0x02},
-	{0x506c, 0x08},
-	{0x506d, 0x10},
-	{0x506f, 0xa6},
-	{0x5068, 0x08},
-	
-	
-	{0x5069, 0x10},
-	{0x506a, 0x04},
-	{0x506b, 0x12},
-	{0x507e, 0x40},
-	{0x507f, 0x20},
-	{0x507b, 0x02},
-	{0x507a, 0x01},
-	{0x5084, 0x0c},
-	{0x5085, 0x3e},
-	{0x5005, 0x80},
-	{0x3a0f, 0x30},
-	{0x3a10, 0x28},
-	{0x3a1b, 0x32},
-	{0x3a1e, 0x26},
-	{0x3a11, 0x60},
-	{0x3a1f, 0x14},
-	{0x5060, 0x69},
-	{0x5061, 0x7d},
-	{0x5062, 0x7d},
-	{0x5063, 0x69},
-	{0x3004, 0x20},
-	{0x0100, 0x01},
-	SensorEnd
-};
-/* Senor full resolution setting: recommand for capture */
-static struct rk_sensor_reg sensor_fullres_lowfps_data[] ={
-
-	{0x3503,0x03}, 
-	{0x506e,0x44},	
-	{0x5064,0x08},	
-	{0x5065,0x10},
-	{0x5066,0x18},	// zenghaihui 20110920 16
-	{0x5067,0x10},
-	{0x506c,0x08},
-	{0x506d,0x10},	
-	{0x506f,0xa6},	
-	{0x5068,0x08},
-	{0x5069,0x10},	
-	{0x506a,0x08},
-	{0x506b,0x28},
-	{0x5084,0x14},//0c
-	{0x5085,0x3c},//34	
-	{0x5005,0x80}, 
-
-
-
-	{0x5066, 0x3c}, 		
-	{0x5067, 0x1a}, 
-	{0x506a, 0x0e},    
-	{0x506b, 0x2e},    
-
-	{0x3800, 0x00}, 
-	{0x3801, 0x00}, 
-	{0x3802, 0x00}, 
-	{0x3803, 0x00}, 
-	{0x3804, 0x06}, 
-	{0x3805, 0x5f}, 
-	{0x3806, 0x04}, 
-	{0x3807, 0xbb}, 
-	{0x3808, 0x06}, 
-	{0x3809, 0x40}, 
-	{0x380a, 0x04}, 
-	{0x380b, 0xb0}, 
-	{0x3811, 0x10}, 
-	{0x3813, 0x06}, 
-	{0x3814, 0x11}, 
-	{0x3815, 0x11}, 
-
-	{0x3623, 0x00}, 
-	{0x3634, 0x44}, 
-	{0x3701, 0x44}, 
-	{0x3208, 0xa2}, 
-	{0x3705, 0x18}, 	 
-	{0x3820, 0x80}, 
-	{0x3821, 0x00}, 
-
-	{0x3003, 0x80},//10fps 
-	{0x3004, 0x20}, //10		 
-	{0x3005, 0x18}, 
-	{0x3006, 0x0d}, 
-
-	{0x380c, 0x07}, 
-	{0x380d, 0x9f}, 
-	{0x380e, 0x04}, 
-	{0x380f, 0xd0}, 
-
-	{0x370a, 0x12}, 
-	{0x4608, 0x00}, 
-	{0x4609, 0x80}, 
-	{0x5002, 0x00}, 
-
-	{0x3a08, 0x00}, 
-	{0x3a09, 0x3e},//7b 
-	{0x3a0e, 0x13},//0a 
-
-	{0x3a0a, 0x00}, 
-	{0x3a0b, 0x3e},//7b 				
-	{0x3a0d, 0x13},//0a 		
-
-	{0x4003, 0x88},
-	SensorEnd
-};
-/* Senor full resolution setting: recommand for video */
-static struct rk_sensor_reg sensor_fullres_highfps_data[] ={
-	SensorEnd
-};
-/* Preview resolution setting*/
-static struct rk_sensor_reg sensor_preview_data[] =
-{
-	{0x0100, 0x00},    //software sleep : Sensor vsync singal may not output if haven't sleep the sensor when transfer the array,
-	{0x3800, 0x00},
-	{0x3801, 0x00},
-	{0x3802, 0x00},
-	{0x3803, 0x00},
-	{0x3804, 0x06},
-	{0x3805, 0x5f},
-	{0x3806, 0x04},
-	{0x3807, 0xb7},
-	{0x3808, 0x03},
-	{0x3809, 0x20},
-	{0x380a, 0x02},
-	{0x380b, 0x58},
-	{0x380c, 0x05},
-	{0x380d, 0x14},
-	{0x380e, 0x02},
-	{0x380f, 0x68},
-	{0x3811, 0x08},
-	{0x3813, 0x02},
-	{0x3814, 0x31},
-	{0x3815, 0x31},
-	{0x3a02, 0x02},
-	{0x3a03, 0x68},
-	{0x3a08, 0x00},
-	{0x3a09, 0x5c},
-	{0x3a0a, 0x00},
-	{0x3a0b, 0x4d},
-	{0x3a0d, 0x08},
-	{0x3a0e, 0x06},
-	{0x3a14, 0x02},
-	{0x3a15, 0x28},
-	{0x3623, 0x00},
-	{0x3634, 0x76},
-	{0x3701, 0x44},
-	{0x3702, 0x18},
-	{0x3703, 0x24},
-	{0x3704, 0x24},
-	{0x3705, 0x0c},
-	{0x3820, 0x81},
-	{0x3821, 0x01},
-	{0x370a, 0x52},
-	{0x4608, 0x00},
-	{0x4609, 0x80},
-	{0x5002, 0x10},
-	{0x3005, 0x18},
-	{0x3004, 0x20},
-	{0x3503,0x00},
-	{0x0100, 0x01}, 	//software wake
-
-	SensorEnd
-};
-/* 1280x720 */
-static struct rk_sensor_reg sensor_720p[]={
-	SensorEnd
-};
-
-/* 1920x1080 */
-static struct rk_sensor_reg sensor_1080p[]={
-	SensorEnd
-};
-
-
-static struct rk_sensor_reg sensor_softreset_data[]={
-    SensorRegVal(0x0103,0x01),
-	SensorEnd
-};
-
-static struct rk_sensor_reg sensor_check_id_data[]={
-    SensorRegVal(0x300a,0),
-    SensorRegVal(0x300b,0),
-	SensorEnd
-};
-/*
-*  The following setting must been filled, if the function is turn on by CONFIG_SENSOR_xxxx
-*/
-static struct rk_sensor_reg sensor_WhiteB_Auto[]=
-{
-	{0x3406, 0x00},  //AWB auto, bit[1]:0,auto
-	SensorEnd
-};
-/* Cloudy Colour Temperature : 6500K - 8000K  */
-static	struct rk_sensor_reg sensor_WhiteB_Cloudy[]=
-{
-	{0x3406, 0x01},
-	{0x3400, 0x07},
-	{0x3401, 0x08},
-	{0x3402, 0x04},
-	{0x3403, 0x00},
-	{0x3404, 0x05},
-	{0x3405, 0x00},
-	SensorEnd
-};
-/* ClearDay Colour Temperature : 5000K - 6500K	*/
-static	struct rk_sensor_reg sensor_WhiteB_ClearDay[]=
-{
-	//Sunny
-	{0x3406, 0x01},
-	{0x3400, 0x07},
-	{0x3401, 0x02},
-	{0x3402, 0x04},
-	{0x3403, 0x00},
-	{0x3404, 0x05},
-	{0x3405, 0x15},
-	SensorEnd
-};
-/* Office Colour Temperature : 3500K - 5000K  */
-static	struct rk_sensor_reg sensor_WhiteB_TungstenLamp1[]=
-{
-	//Office
-	{0x3406, 0x01},
-	{0x3400, 0x06},
-	{0x3401, 0x2a},
-	{0x3402, 0x04},
-	{0x3403, 0x00},
-	{0x3404, 0x07},
-	{0x3405, 0x24},
-	SensorEnd
-
-};
-/* Home Colour Temperature : 2500K - 3500K	*/
-static	struct rk_sensor_reg sensor_WhiteB_TungstenLamp2[]=
-{
-	//Home
-	{0x3406, 0x01},
-	{0x3400, 0x04},
-	{0x3401, 0x58},
-	{0x3402, 0x04},
-	{0x3403, 0x00},
-	{0x3404, 0x07},
-	{0x3405, 0x24},
-	SensorEnd
-};
-static struct rk_sensor_reg *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,
-	sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,
-};
-
-static	struct rk_sensor_reg sensor_Brightness0[]=
-{
-	// Brightness -2
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Brightness1[]=
-{
-	// Brightness -1
-
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Brightness2[]=
-{
-	//	Brightness 0
-
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Brightness3[]=
-{
-	// Brightness +1
-
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Brightness4[]=
-{
-	//	Brightness +2
-
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Brightness5[]=
-{
-	//	Brightness +3
-
-	SensorEnd
-};
-static struct rk_sensor_reg *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,
-	sensor_Brightness4, sensor_Brightness5,NULL,
-};
-
-static	struct rk_sensor_reg sensor_Effect_Normal[] =
-{
-	{0x507b, 0x00},
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Effect_WandB[] =
-{
-	{0x507b, 0x20},
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Effect_Sepia[] =
-{
-	{0x507b, 0x18},
-	{0x507e, 0x40},
-	{0x507f, 0xa0},
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Effect_Negative[] =
-{
-	//Negative
-	{0x507b, 0x40}, //bit[6] negative
-	SensorEnd
-};
-static	struct rk_sensor_reg sensor_Effect_Bluish[] =
-{
-	// Bluish
-	{0x507b, 0x18},
-	{0x507e, 0xa0},
-	{0x507f, 0x40},
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Effect_Green[] =
-{
-	//	Greenish
-	{0x507b, 0x18},
-	{0x507e, 0x60},
-	{0x507f, 0x60},
-	SensorEnd
-};
-static struct rk_sensor_reg *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_WandB, sensor_Effect_Negative,sensor_Effect_Sepia,
-	sensor_Effect_Bluish, sensor_Effect_Green,NULL,
-};
-
-static	struct rk_sensor_reg sensor_Exposure0[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Exposure1[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Exposure2[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Exposure3[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Exposure4[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Exposure5[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Exposure6[]=
-{
-	SensorEnd
-};
-
-static struct rk_sensor_reg *sensor_ExposureSeqe[] = {sensor_Exposure0, sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,
-	sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,NULL,
-};
-
-static	struct rk_sensor_reg sensor_Saturation0[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Saturation1[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Saturation2[]=
-{
-	SensorEnd
-};
-static struct rk_sensor_reg *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};
-
-static	struct rk_sensor_reg sensor_Contrast0[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Contrast1[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Contrast2[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Contrast3[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Contrast4[]=
-{
-	SensorEnd
-};
-
-
-static	struct rk_sensor_reg sensor_Contrast5[]=
-{
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_Contrast6[]=
-{
-	SensorEnd
-};
-static struct rk_sensor_reg *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,
-	sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,
-};
-static	struct rk_sensor_reg sensor_SceneAuto[] =
-{
-	{0x3a00, 0x78},
-	SensorEnd
-};
-
-static	struct rk_sensor_reg sensor_SceneNight[] =
-{
-	{0x3003, 0x80},
-	{0x3004, 0x20},
-	{0x3005, 0x18},
-	{0x3006, 0x0d},
-	{0x3a00, 0x7c},
-	{0x3a02 ,0x07},
-	{0x3a03 ,0x38},
-	{0x3a14 ,0x07},
-	{0x3a15 ,0x38},
-	SensorEnd
-};
-static struct rk_sensor_reg *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight,NULL,};
-
-static struct rk_sensor_reg sensor_Zoom0[] =
-{
-	SensorEnd
-};
-
-static struct rk_sensor_reg sensor_Zoom1[] =
-{
-	SensorEnd
-};
-
-static struct rk_sensor_reg sensor_Zoom2[] =
-{
-	SensorEnd
-};
-
-
-static struct rk_sensor_reg sensor_Zoom3[] =
-{
-	SensorEnd
-};
-static struct rk_sensor_reg *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL,};
-
-/*
-* User could be add v4l2_querymenu in sensor_controls by new_usr_v4l2menu
-*/
-static struct v4l2_querymenu sensor_menus[] =
-{
-};
-/*
-* User could be add v4l2_queryctrl in sensor_controls by new_user_v4l2ctrl
-*/
-static struct sensor_v4l2ctrl_usr_s sensor_controls[] =
-{
-};
-
-//MUST define the current used format as the first item   
-static struct rk_sensor_datafmt sensor_colour_fmts[] = {
-	{V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
-	{V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG} 
-};
-static struct soc_camera_ops sensor_ops;
-
-
-/*
-**********************************************************
-* Following is local code:
-* 
-* Please codeing your program here 
-**********************************************************
-*/
-static int sensor_parameter_record(struct i2c_client *client)
-{
-	u8 ret_l,ret_m,ret_h;
-	int tp_l,tp_m,tp_h;
-	
-	struct generic_sensor *sensor = to_generic_sensor(client);
-	struct specific_sensor *spsensor = to_specific_sensor(sensor);
-
-	sensor_read(client,0x3a00, &ret_l);
-	sensor_write(client,0x3a00, ret_l&0xfb);
-
-	sensor_write(client,0x3503,0x07);	//stop AE/AG
-
-	sensor_read(client,0x3500,&ret_h);
-	sensor_read(client,0x3501, &ret_m);
-	sensor_read(client,0x3502, &ret_l);
-	tp_l = ret_l;
-	tp_m = ret_m;
-	tp_h = ret_h;
-	spsensor->parameter.preview_exposure = ((tp_h<<12) & 0xF000) | ((tp_m<<4) & 0x0FF0) | ((tp_l>>4) & 0x0F);
-	
-	//Read back AGC Gain for preview
-	sensor_read(client,0x350b, &ret_l);
-	spsensor->parameter.preview_gain = ret_l;
-
-	spsensor->parameter.CapturePclk = 24000;
-	spsensor->parameter.PreviewPclk = 24000;
-	spsensor->parameter.PreviewDummyPixels = 0;
-	spsensor->parameter.CaptureDummyPixels = 0;
-	SENSOR_DG("Read 0x350b=0x%02x  PreviewExposure:%d 0x3500=0x%02x  0x3501=0x%02x 0x3502=0x%02x",
-	          ret_l,spsensor->parameter.preview_exposure,tp_h, tp_m, tp_l);
-	return 0;
-}
-#define OV2659_FULL_PERIOD_PIXEL_NUMS  (1940)  // default pixel#(w/o dummy pixels) in UXGA mode
-#define OV2659_FULL_PERIOD_LINE_NUMS   (1238)  // default line#(w/o dummy lines) in UXGA mode
-#define OV2659_PV_PERIOD_PIXEL_NUMS   (970)  // default pixel#(w/o dummy pixels) in SVGA mode
-#define OV2659_PV_PERIOD_LINE_NUMS	  (618)   // default line#(w/o dummy lines) in SVGA mode
-
-/* SENSOR EXPOSURE LINE LIMITATION */
-#define OV2659_FULL_EXPOSURE_LIMITATION   (1236)
-#define OV2659_PV_EXPOSURE_LIMITATION	  (618)
-
-// SENSOR UXGA SIZE
-#define OV2659_IMAGE_SENSOR_FULL_WIDTH	  (1600)
-#define OV2659_IMAGE_SENSOR_FULL_HEIGHT   (1200)
-
-#define OV2659_FULL_GRAB_WIDTH				(OV2659_IMAGE_SENSOR_FULL_WIDTH - 16)
-#define OV2659_FULL_GRAB_HEIGHT 			(OV2659_IMAGE_SENSOR_FULL_HEIGHT - 12)
-static void OV2659SetDummy(struct i2c_client *client,unsigned int dummy_pixels, unsigned int dummy_lines)
-{
-	unsigned char val;
-	unsigned int temp_reg1, temp_reg2;
-	unsigned int temp_reg;
-	
-	if (dummy_pixels > 0)
-	{
-		sensor_read(client,0x380D,&val);	// HTS[b7~b0]
-		temp_reg1 = val;
-		sensor_read(client,0x380C,&val);	// HTS[b15~b8]
-		temp_reg2 = val;
-		temp_reg = (temp_reg1 & 0xFF) | (temp_reg2 << 8);
-	
-		temp_reg += dummy_pixels;
-	
-		sensor_write(client,0x380D,(temp_reg&0xFF));		 //HTS[7:0]
-		sensor_write(client,0x380C,((temp_reg&0xFF00)>>8));  //HTS[15:8]
-	}
-
-	if (dummy_lines > 0)
-	{
-		sensor_read(client,0x380F,&val);	// VTS[b7~b0]
-		temp_reg1 = val;
-		sensor_read(client,0x380E,&val);	// VTS[b15~b8]
-		temp_reg2 = val;
-		temp_reg = (temp_reg1 & 0xFF) | (temp_reg2 << 8);
-	
-		temp_reg += dummy_lines;
-	
-		sensor_write(client,0x380F,(temp_reg&0xFF));		 //VTS[7:0]
-		sensor_write(client,0x380E,((temp_reg&0xFF00)>>8));  //VTS[15:8]
-	}
-}	 /* OV2659_set_dummy */
-
-static void OV2659WriteShutter(struct i2c_client *client,bool is_preview, unsigned int shutter)
-{
-	unsigned int extra_exposure_lines = 0;
-
-	if (shutter < 1)
-	{
-		shutter = 1;
-	}
-	
-	if (is_preview) 
-	{
-		if (shutter <= OV2659_PV_EXPOSURE_LIMITATION) 
-		{
-			extra_exposure_lines = 0;
-		}
-		else 
-		{
-			extra_exposure_lines=shutter - OV2659_PV_EXPOSURE_LIMITATION;
-		}
-		
-	}
-	else 
-	{
-		if (shutter <= OV2659_FULL_EXPOSURE_LIMITATION) 
-		{
-			extra_exposure_lines = 0;
-		}
-		else 
-		{
-			extra_exposure_lines = shutter - OV2659_FULL_EXPOSURE_LIMITATION;
-		}
-		
-	}
-	
-	//AEC PK EXPOSURE
-	shutter*=16;
-	sensor_write(client,0x3502, (shutter & 0x00FF));		   //AEC[7:0]
-	sensor_write(client,0x3501, ((shutter & 0x0FF00) >>8));  //AEC[15:8]
-	sensor_write(client,0x3500, ((shutter & 0xFF0000) >> 16));	
-	
-	if(extra_exposure_lines>0)
-	{
-		// set extra exposure line [aec add vts]
-		sensor_write(client,0x3507, extra_exposure_lines & 0xFF);		   // EXVTS[b7~b0]
-		sensor_write(client,0x3506, (extra_exposure_lines & 0xFF00) >> 8); // EXVTS[b15~b8]
-	}
-	else
-	{
-		// set extra exposure line [aec add vts]
-		sensor_write(client,0x3507, 0x00);			// EXVTS[b7~b0]
-		sensor_write(client,0x3506, 0x00); // EXVTS[b15~b8]
-	}
-	
-}	 /* OV2659_write_shutter */
-static int sensor_ae_transfer(struct i2c_client *client)
-{
-	unsigned int prev_line_len,cap_line_len,shutter;
-	struct generic_sensor *sensor = to_generic_sensor(client);
-	struct specific_sensor *spsensor = to_specific_sensor(sensor);
-
-	mdelay(100);
-	shutter = spsensor->parameter.preview_exposure;
-
-	OV2659SetDummy(client,600,0);	
-	
-	prev_line_len = OV2659_PV_PERIOD_PIXEL_NUMS + spsensor->parameter.PreviewDummyPixels;
-	cap_line_len = OV2659_FULL_PERIOD_PIXEL_NUMS + spsensor->parameter.CaptureDummyPixels;
-	shutter = (shutter * spsensor->parameter.CapturePclk) / spsensor->parameter.PreviewPclk;
-	shutter = (shutter * prev_line_len) / cap_line_len;
-	shutter*=2;
-
-	OV2659WriteShutter(client,0,shutter);
-	
-	
-	return 0;
-}
-/*
-**********************************************************
-* Following is callback
-* If necessary, you could coding these callback
-**********************************************************
-*/
-/*
-* the function is called in open sensor  
-*/
-static int sensor_activate_cb(struct i2c_client *client)
-{
-    u8 reg_val;
-
-    SENSOR_DG("%s",__FUNCTION__);
-	
-	sensor_read(client,0x3000,&reg_val);
-	sensor_write(client, 0x3000, reg_val|0x03);
-	sensor_write(client, 0x3001, 0xff);
-	sensor_read(client,0x3002,&reg_val);
-	sensor_write(client, 0x3002, reg_val|0xe0);
-	
-	return 0;
-}
-/*
-* the function is called in close sensor
-*/
-static int sensor_deactivate_cb(struct i2c_client *client)
-{
-	u8 reg_val;
-	struct generic_sensor *sensor = to_generic_sensor(client);
-
-    SENSOR_DG("%s",__FUNCTION__);
-    
-	/* ddl@rock-chips.com : all sensor output pin must switch into Hi-Z */
-	if (sensor->info_priv.funmodule_state & SENSOR_INIT_IS_OK) {
-		sensor_read(client,0x3000,&reg_val);
-		sensor_write(client, 0x3000, reg_val&0xfc);
-		sensor_write(client, 0x3001, 0x00);
-		sensor_read(client,0x3002,&reg_val);
-		sensor_write(client, 0x3002, reg_val&0x1f);
-	}
-	
-	return 0;
-}
-/*
-* the function is called before sensor register setting in VIDIOC_S_FMT  
-*/
-static int sensor_s_fmt_cb_th(struct i2c_client *client,struct v4l2_mbus_framefmt *mf, bool capture)
-{
-    if (capture) {
-        sensor_parameter_record(client);
-    }
-
-    return 0;
-}
-/*
-* the function is called after sensor register setting finished in VIDIOC_S_FMT  
-*/
-static int sensor_s_fmt_cb_bh (struct i2c_client *client,struct v4l2_mbus_framefmt *mf, bool capture)
-{
-    if (capture) {
-        sensor_ae_transfer(client);
-    }
-    return 0;
-}
-static int sensor_try_fmt_cb_th(struct i2c_client *client,struct v4l2_mbus_framefmt *mf)
-{
-	return 0;
-}
-
-static int sensor_softrest_usr_cb(struct i2c_client *client,struct rk_sensor_reg *series)
-{
-	
-	return 0;
-}
-static int sensor_check_id_usr_cb(struct i2c_client *client,struct rk_sensor_reg *series)
-{
-	return 0;
-}
-
-static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)
-{
-	//struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-		
-	if (pm_msg.event == PM_EVENT_SUSPEND) {
-		SENSOR_DG("Suspend");
-		
-	} else {
-		SENSOR_TR("pm_msg.event(0x%x) != PM_EVENT_SUSPEND\n",pm_msg.event);
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int sensor_resume(struct soc_camera_device *icd)
-{
-
-	SENSOR_DG("Resume");
-
-	return 0;
-
-}
-static int sensor_mirror_cb (struct i2c_client *client, int mirror)
-{
-	char val;
-	int err = 0;
-    
-    SENSOR_DG("mirror: %d",mirror);
-	if (mirror) {
-		err = sensor_read(client, 0x3821, &val);
-		if (err == 0) {
-			val |= 0x06;
-			err = sensor_write(client, 0x3821, val);
-		}
-	} else {
-		err = sensor_read(client, 0x3821, &val);
-		if (err == 0) {
-			val &= 0xf9;
-			err = sensor_write(client, 0x3821, val);
-		}
-	}
-
-	return err;    
-}
-/*
-* the function is v4l2 control V4L2_CID_HFLIP callback  
-*/
-static int sensor_v4l2ctrl_mirror_cb(struct soc_camera_device *icd, struct sensor_v4l2ctrl_info_s *ctrl_info, 
-                                                     struct v4l2_ext_control *ext_ctrl)
-{
-	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if (sensor_mirror_cb(client,ext_ctrl->value) != 0)
-		SENSOR_TR("sensor_mirror failed, value:0x%x",ext_ctrl->value);
-	
-	SENSOR_DG("sensor_mirror success, value:0x%x",ext_ctrl->value);
-	return 0;
-}
-
-static int sensor_flip_cb(struct i2c_client *client, int flip)
-{
-	char val;
-	int err = 0;	
-
-    SENSOR_DG("flip: %d",flip);
-	if (flip) {
-		err = sensor_read(client, 0x3820, &val);
-		if (err == 0) {
-			val |= 0x06;
-			err = sensor_write(client, 0x3820, val);
-		}
-	} else {
-		err = sensor_read(client, 0x3820, &val);
-		if (err == 0) {
-			val &= 0xf9;
-			err = sensor_write(client, 0x3820, val);
-		}
-	}
-
-	return err;    
-}
-/*
-* the function is v4l2 control V4L2_CID_VFLIP callback  
-*/
-static int sensor_v4l2ctrl_flip_cb(struct soc_camera_device *icd, struct sensor_v4l2ctrl_info_s *ctrl_info, 
-                                                     struct v4l2_ext_control *ext_ctrl)
-{
-	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
-
-    if (sensor_flip_cb(client,ext_ctrl->value) != 0)
-		SENSOR_TR("sensor_flip failed, value:0x%x",ext_ctrl->value);
-	
-	SENSOR_DG("sensor_flip success, value:0x%x",ext_ctrl->value);
-	return 0;
-}
-/*
-* the functions are focus callbacks
-*/
-static int sensor_focus_init_usr_cb(struct i2c_client *client){
-	return 0;
-}
-
-static int sensor_focus_af_single_usr_cb(struct i2c_client *client){
-	return 0;
-}
-
-static int sensor_focus_af_near_usr_cb(struct i2c_client *client){
-	return 0;
-}
-
-static int sensor_focus_af_far_usr_cb(struct i2c_client *client){
-	return 0;
-}
-
-static int sensor_focus_af_specialpos_usr_cb(struct i2c_client *client,int pos){
-	return 0;
-}
-
-static int sensor_focus_af_const_usr_cb(struct i2c_client *client){
-	return 0;
-}
+*      Driver Version Note
+*v0.0.1: this driver is compatible with generic_sensor
+*v0.1.1:
+*        add sensor_focus_af_const_pause_usr_cb;
+*/
+static int version = KERNEL_VERSION(0,1,3);
+module_param(version, int, S_IRUGO);
+
+static int debug;
+module_param(debug, int, S_IRUGO|S_IWUSR);
+
+#define dprintk(level, fmt, arg...) do {			\
+	if (debug >= level) 					\
+	printk(KERN_WARNING fmt , ## arg); } while (0)
+#define debug_printk(format, ...) dprintk(1, format, ## __VA_ARGS__)  
+/* Sensor Driver Configuration Begin */
+#define SENSOR_NAME RK29_CAM_SENSOR_OV2659
+#define SENSOR_V4L2_IDENT V4L2_IDENT_OV2659
+#define SENSOR_ID 0x2656
+#define SENSOR_BUS_PARAM                     (V4L2_MBUS_MASTER |\
+                                             V4L2_MBUS_PCLK_SAMPLE_RISING|V4L2_MBUS_HSYNC_ACTIVE_HIGH| V4L2_MBUS_VSYNC_ACTIVE_LOW|\
+                                             V4L2_MBUS_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+#define SENSOR_PREVIEW_W                     800
+#define SENSOR_PREVIEW_H                     600
+#define SENSOR_PREVIEW_FPS                   15000     // 15fps 
+#define SENSOR_FULLRES_L_FPS                 7500      // 7.5fps
+#define SENSOR_FULLRES_H_FPS                 7500      // 7.5fps
+#define SENSOR_720P_FPS                      0
+#define SENSOR_1080P_FPS                     0
+
+#define SENSOR_REGISTER_LEN                  2         // sensor register address bytes
+#define SENSOR_VALUE_LEN                     1         // sensor register value bytes
+                                    
+static unsigned int SensorConfiguration = (CFG_WhiteBalance|CFG_Effect|CFG_Scene);
+static unsigned int SensorChipID[] = {SENSOR_ID};
+/* Sensor Driver Configuration End */
+
+
+#define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
+#define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)
+
+#define SensorRegVal(a,b) CONS4(SensorReg,SENSOR_REGISTER_LEN,Val,SENSOR_VALUE_LEN)(a,b)
+#define sensor_write(client,reg,v) CONS4(sensor_write_reg,SENSOR_REGISTER_LEN,val,SENSOR_VALUE_LEN)(client,(reg),(v))
+#define sensor_read(client,reg,v) CONS4(sensor_read_reg,SENSOR_REGISTER_LEN,val,SENSOR_VALUE_LEN)(client,(reg),(v))
+#define sensor_write_array generic_sensor_write_array
+
+struct sensor_parameter
+{
+	unsigned int PreviewDummyPixels;
+	unsigned int CaptureDummyPixels;
+	unsigned int preview_exposure;
+	unsigned short int preview_line_width;
+	unsigned short int preview_gain;
+
+	unsigned short int PreviewPclk;
+	unsigned short int CapturePclk;
+	char awb[6];
+};
+
+struct specific_sensor{
+	struct generic_sensor common_sensor;
+	//define user data below
+	struct sensor_parameter parameter;
+
+};
+
+/*
+*  The follow setting need been filled.
+*  
+*  Must Filled:
+*  sensor_init_data :               Sensor initial setting;
+*  sensor_fullres_lowfps_data :     Sensor full resolution setting with best auality, recommand for video;
+*  sensor_preview_data :            Sensor preview resolution setting, recommand it is vga or svga;
+*  sensor_softreset_data :          Sensor software reset register;
+*  sensor_check_id_data :           Sensir chip id register;
+*
+*  Optional filled:
+*  sensor_fullres_highfps_data:     Sensor full resolution setting with high framerate, recommand for video;
+*  sensor_720p:                     Sensor 720p setting, it is for video;
+*  sensor_1080p:                    Sensor 1080p setting, it is for video;
+*
+*  :::::WARNING:::::
+*  The SensorEnd which is the setting end flag must be filled int the last of each setting;
+*/
+
+/* Sensor initial setting */
+static struct rk_sensor_reg sensor_init_data[] ={
+	{0x3000, 0x0f},
+	{0x3001, 0xff},
+	{0x3002, 0xff},
+	//{0x0100, 0x01},	//software sleep : Sensor vsync singal may not output if haven't sleep the sensor when transfer the array
+	{0x3633, 0x3d},
+	{0x3620, 0x02},
+	{0x3631, 0x11},
+	{0x3612, 0x04},
+	{0x3630, 0x20},
+	{0x4702, 0x02},
+	{0x370c, 0x34},
+	{0x3004, 0x10},
+	{0x3005, 0x18},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x06},
+	{0x3805, 0x5f},
+	{0x3806, 0x04},
+	{0x3807, 0xb7},
+	{0x3808, 0x03},
+	{0x3809, 0x20},
+	{0x380a, 0x02},
+	{0x380b, 0x58},
+	{0x380c, 0x05},
+	{0x380d, 0x14},
+	{0x380e, 0x02},
+	{0x380f, 0x68},
+	{0x3811, 0x08},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3a02, 0x02},
+	{0x3a03, 0x68},
+	{0x3a08, 0x00},
+	{0x3a09, 0x5c},
+	{0x3a0a, 0x00},
+	{0x3a0b, 0x4d},
+	{0x3a0d, 0x08},
+	{0x3a0e, 0x06},
+	{0x3a14, 0x02},
+	{0x3a15, 0x28},
+		{0x4708, 0x01},
+	{0x3623, 0x00},
+	{0x3634, 0x76},
+	{0x3701, 0x44},
+	{0x3702, 0x18},
+	{0x3703, 0x24},
+	{0x3704, 0x24},
+	{0x3705, 0x0c},
+	{0x3820, 0x81},
+	{0x3821, 0x01},
+	{0x370a, 0x52},
+	{0x4608, 0x00},
+	{0x4609, 0x80},
+	{0x4300, 0x32},
+	{0x5086, 0x02},
+	{0x5000, 0xfb},
+	{0x5001, 0x1f},
+	{0x5002, 0x00},
+	{0x5025, 0x0e},
+	{0x5026, 0x18},
+	{0x5027, 0x34},
+	{0x5028, 0x4c},
+	{0x5029, 0x62},
+	{0x502a, 0x74},
+	{0x502b, 0x85},
+	{0x502c, 0x92},
+	{0x502d, 0x9e},
+	{0x502e, 0xb2},
+	{0x502f, 0xc0},
+	{0x5030, 0xcc},
+	{0x5031, 0xe0},
+	{0x5032, 0xee},
+	{0x5033, 0xf6},
+	{0x5034, 0x11},
+	{0x5070, 0x1c},
+	{0x5071, 0x5b},
+	{0x5072, 0x05},
+	{0x5073, 0x20},
+	{0x5074, 0x94},
+	{0x5075, 0xb4},
+	{0x5076, 0xb4},
+	{0x5077, 0xaf},
+	{0x5078, 0x05},
+	{0x5079, 0x98},
+	{0x507a, 0x21},
+	{0x5035, 0x6a},
+	{0x5036, 0x11},
+	{0x5037, 0x92},
+	{0x5038, 0x21},
+	
+	{0x5039, 0xe1},
+	{0x503a, 0x01},
+	{0x503c, 0x05},
+	{0x503d, 0x08},
+	{0x503e, 0x08},
+	{0x503f, 0x64},
+	{0x5040, 0x58},
+	{0x5041, 0x2a},
+	{0x5042, 0xc5},
+	{0x5043, 0x2e},
+	{0x5044, 0x3a},
+	{0x5045, 0x3c},
+	{0x5046, 0x44},
+	{0x5047, 0xf8},
+	{0x5048, 0x08},
+	{0x5049, 0x70},
+	{0x504a, 0xf0},
+	{0x504b, 0xf0},
+	{0x500c, 0x03},
+	{0x500d, 0x20},
+	{0x500e, 0x02},
+	{0x500f, 0x5c},
+	{0x5010, 0x48},
+	{0x5011, 0x00},
+	{0x5012, 0x66},
+	{0x5013, 0x03},
+	{0x5014, 0x30},
+	{0x5015, 0x02},
+	{0x5016, 0x7c},
+	{0x5017, 0x40},
+	{0x5018, 0x00},
+	{0x5019, 0x66},
+	{0x501a, 0x03},
+	{0x501b, 0x10},
+	{0x501c, 0x02},
+	{0x501d, 0x7c},
+	{0x501e, 0x3a},
+	{0x501f, 0x00},
+	{0x5020, 0x66},
+	{0x506e, 0x44},
+	{0x5064, 0x08},
+	{0x5065, 0x10},
+	{0x5066, 0x12},
+	{0x5067, 0x02},
+	{0x506c, 0x08},
+	{0x506d, 0x10},
+	{0x506f, 0xa6},
+	{0x5068, 0x08},
+	
+	
+	{0x5069, 0x10},
+	{0x506a, 0x04},
+	{0x506b, 0x12},
+	{0x507e, 0x40},
+	{0x507f, 0x20},
+	{0x507b, 0x02},
+	{0x507a, 0x01},
+	{0x5084, 0x0c},
+	{0x5085, 0x3e},
+	{0x5005, 0x80},
+	{0x3a0f, 0x30},
+	{0x3a10, 0x28},
+	{0x3a1b, 0x32},
+	{0x3a1e, 0x26},
+	{0x3a11, 0x60},
+	{0x3a1f, 0x14},
+	{0x5060, 0x69},
+	{0x5061, 0x7d},
+	{0x5062, 0x7d},
+	{0x5063, 0x69},
+	{0x3004, 0x20},
+	{0x0100, 0x01},
+	SensorEnd
+};
+/* Senor full resolution setting: recommand for capture */
+static struct rk_sensor_reg sensor_fullres_lowfps_data[] ={
+
+	{0x3503,0x03}, 
+	{0x506e,0x44},	
+	{0x5064,0x08},	
+	{0x5065,0x10},
+	{0x5066,0x18},	// zenghaihui 20110920 16
+	{0x5067,0x10},
+	{0x506c,0x08},
+	{0x506d,0x10},	
+	{0x506f,0xa6},	
+	{0x5068,0x08},
+	{0x5069,0x10},	
+	{0x506a,0x08},
+	{0x506b,0x28},
+	{0x5084,0x14},//0c
+	{0x5085,0x3c},//34	
+	{0x5005,0x80}, 
+
+
+
+	{0x5066, 0x3c}, 		
+	{0x5067, 0x1a}, 
+	{0x506a, 0x0e},    
+	{0x506b, 0x2e},    
+
+	{0x3800, 0x00}, 
+	{0x3801, 0x00}, 
+	{0x3802, 0x00}, 
+	{0x3803, 0x00}, 
+	{0x3804, 0x06}, 
+	{0x3805, 0x5f}, 
+	{0x3806, 0x04}, 
+	{0x3807, 0xbb}, 
+	{0x3808, 0x06}, 
+	{0x3809, 0x40}, 
+	{0x380a, 0x04}, 
+	{0x380b, 0xb0}, 
+	{0x3811, 0x10}, 
+	{0x3813, 0x06}, 
+	{0x3814, 0x11}, 
+	{0x3815, 0x11}, 
+
+	{0x3623, 0x00}, 
+	{0x3634, 0x44}, 
+	{0x3701, 0x44}, 
+	{0x3208, 0xa2}, 
+	{0x3705, 0x18}, 	 
+	{0x3820, 0x80}, 
+	{0x3821, 0x00}, 
+
+	{0x3003, 0x80},//10fps 
+	{0x3004, 0x20}, //10		 
+	{0x3005, 0x18}, 
+	{0x3006, 0x0d}, 
+
+	{0x380c, 0x07}, 
+	{0x380d, 0x9f}, 
+	{0x380e, 0x04}, 
+	{0x380f, 0xd0}, 
+
+	{0x370a, 0x12}, 
+	{0x4608, 0x00}, 
+	{0x4609, 0x80}, 
+	{0x5002, 0x00}, 
+
+	{0x3a08, 0x00}, 
+	{0x3a09, 0x3e},//7b 
+	{0x3a0e, 0x13},//0a 
+
+	{0x3a0a, 0x00}, 
+	{0x3a0b, 0x3e},//7b 				
+	{0x3a0d, 0x13},//0a 		
+
+	{0x4003, 0x88},
+	SensorEnd
+};
+/* Senor full resolution setting: recommand for video */
+static struct rk_sensor_reg sensor_fullres_highfps_data[] ={
+	SensorEnd
+};
+/* Preview resolution setting*/
+static struct rk_sensor_reg sensor_preview_data[] =
+{
+	{0x0100, 0x00},    //software sleep : Sensor vsync singal may not output if haven't sleep the sensor when transfer the array,
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x00},
+	{0x3804, 0x06},
+	{0x3805, 0x5f},
+	{0x3806, 0x04},
+	{0x3807, 0xb7},
+	{0x3808, 0x03},
+	{0x3809, 0x20},
+	{0x380a, 0x02},
+	{0x380b, 0x58},
+	{0x380c, 0x05},
+	{0x380d, 0x14},
+	{0x380e, 0x02},
+	{0x380f, 0x68},
+	{0x3811, 0x08},
+	{0x3813, 0x02},
+	{0x3814, 0x31},
+	{0x3815, 0x31},
+	{0x3a02, 0x02},
+	{0x3a03, 0x68},
+	{0x3a08, 0x00},
+	{0x3a09, 0x5c},
+	{0x3a0a, 0x00},
+	{0x3a0b, 0x4d},
+	{0x3a0d, 0x08},
+	{0x3a0e, 0x06},
+	{0x3a14, 0x02},
+	{0x3a15, 0x28},
+	{0x3623, 0x00},
+	{0x3634, 0x76},
+	{0x3701, 0x44},
+	{0x3702, 0x18},
+	{0x3703, 0x24},
+	{0x3704, 0x24},
+	{0x3705, 0x0c},
+	{0x3820, 0x81},
+	{0x3821, 0x01},
+	{0x370a, 0x52},
+	{0x4608, 0x00},
+	{0x4609, 0x80},
+	{0x5002, 0x10},
+	{0x3005, 0x18},
+	{0x3004, 0x20},
+	{0x3503,0x00},
+	{0x0100, 0x01}, 	//software wake
+
+	SensorEnd
+};
+/* 1280x720 */
+static struct rk_sensor_reg sensor_720p[]={
+	SensorEnd
+};
+
+/* 1920x1080 */
+static struct rk_sensor_reg sensor_1080p[]={
+	SensorEnd
+};
+
+
+static struct rk_sensor_reg sensor_softreset_data[]={
+    SensorRegVal(0x0103,0x01),
+	SensorEnd
+};
+
+static struct rk_sensor_reg sensor_check_id_data[]={
+    SensorRegVal(0x300a,0),
+    SensorRegVal(0x300b,0),
+	SensorEnd
+};
+/*
+*  The following setting must been filled, if the function is turn on by CONFIG_SENSOR_xxxx
+*/
+static struct rk_sensor_reg sensor_WhiteB_Auto[]=
+{
+	{0x3406, 0x00},  //AWB auto, bit[1]:0,auto
+	SensorEnd
+};
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static	struct rk_sensor_reg sensor_WhiteB_Cloudy[]=
+{
+	{0x3406, 0x01},
+	{0x3400, 0x07},
+	{0x3401, 0x08},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x05},
+	{0x3405, 0x00},
+	SensorEnd
+};
+/* ClearDay Colour Temperature : 5000K - 6500K	*/
+static	struct rk_sensor_reg sensor_WhiteB_ClearDay[]=
+{
+	//Sunny
+	{0x3406, 0x01},
+	{0x3400, 0x07},
+	{0x3401, 0x02},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x05},
+	{0x3405, 0x15},
+	SensorEnd
+};
+/* Office Colour Temperature : 3500K - 5000K  */
+static	struct rk_sensor_reg sensor_WhiteB_TungstenLamp1[]=
+{
+	//Office
+	{0x3406, 0x01},
+	{0x3400, 0x06},
+	{0x3401, 0x2a},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x07},
+	{0x3405, 0x24},
+	SensorEnd
+
+};
+/* Home Colour Temperature : 2500K - 3500K	*/
+static	struct rk_sensor_reg sensor_WhiteB_TungstenLamp2[]=
+{
+	//Home
+	{0x3406, 0x01},
+	{0x3400, 0x04},
+	{0x3401, 0x58},
+	{0x3402, 0x04},
+	{0x3403, 0x00},
+	{0x3404, 0x07},
+	{0x3405, 0x24},
+	SensorEnd
+};
+static struct rk_sensor_reg *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,
+	sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,
+};
+
+static	struct rk_sensor_reg sensor_Brightness0[]=
+{
+	// Brightness -2
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Brightness1[]=
+{
+	// Brightness -1
+
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Brightness2[]=
+{
+	//	Brightness 0
+
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Brightness3[]=
+{
+	// Brightness +1
+
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Brightness4[]=
+{
+	//	Brightness +2
+
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Brightness5[]=
+{
+	//	Brightness +3
+
+	SensorEnd
+};
+static struct rk_sensor_reg *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,
+	sensor_Brightness4, sensor_Brightness5,NULL,
+};
+
+static	struct rk_sensor_reg sensor_Effect_Normal[] =
+{
+	{0x507b, 0x00},
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Effect_WandB[] =
+{
+	{0x507b, 0x20},
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Effect_Sepia[] =
+{
+	{0x507b, 0x18},
+	{0x507e, 0x40},
+	{0x507f, 0xa0},
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Effect_Negative[] =
+{
+	//Negative
+	{0x507b, 0x40}, //bit[6] negative
+	SensorEnd
+};
+static	struct rk_sensor_reg sensor_Effect_Bluish[] =
+{
+	// Bluish
+	{0x507b, 0x18},
+	{0x507e, 0xa0},
+	{0x507f, 0x40},
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Effect_Green[] =
+{
+	//	Greenish
+	{0x507b, 0x18},
+	{0x507e, 0x60},
+	{0x507f, 0x60},
+	SensorEnd
+};
+static struct rk_sensor_reg *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_WandB, sensor_Effect_Negative,sensor_Effect_Sepia,
+	sensor_Effect_Bluish, sensor_Effect_Green,NULL,
+};
+
+static	struct rk_sensor_reg sensor_Exposure0[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Exposure1[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Exposure2[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Exposure3[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Exposure4[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Exposure5[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Exposure6[]=
+{
+	SensorEnd
+};
+
+static struct rk_sensor_reg *sensor_ExposureSeqe[] = {sensor_Exposure0, sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,
+	sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,NULL,
+};
+
+static	struct rk_sensor_reg sensor_Saturation0[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Saturation1[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Saturation2[]=
+{
+	SensorEnd
+};
+static struct rk_sensor_reg *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};
+
+static	struct rk_sensor_reg sensor_Contrast0[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Contrast1[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Contrast2[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Contrast3[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Contrast4[]=
+{
+	SensorEnd
+};
+
+
+static	struct rk_sensor_reg sensor_Contrast5[]=
+{
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_Contrast6[]=
+{
+	SensorEnd
+};
+static struct rk_sensor_reg *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,
+	sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,
+};
+static	struct rk_sensor_reg sensor_SceneAuto[] =
+{
+	{0x3a00, 0x78},
+	SensorEnd
+};
+
+static	struct rk_sensor_reg sensor_SceneNight[] =
+{
+	{0x3003, 0x80},
+	{0x3004, 0x20},
+	{0x3005, 0x18},
+	{0x3006, 0x0d},
+	{0x3a00, 0x7c},
+	{0x3a02 ,0x07},
+	{0x3a03 ,0x38},
+	{0x3a14 ,0x07},
+	{0x3a15 ,0x38},
+	SensorEnd
+};
+static struct rk_sensor_reg *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight,NULL,};
+
+static struct rk_sensor_reg sensor_Zoom0[] =
+{
+	SensorEnd
+};
+
+static struct rk_sensor_reg sensor_Zoom1[] =
+{
+	SensorEnd
+};
+
+static struct rk_sensor_reg sensor_Zoom2[] =
+{
+	SensorEnd
+};
+
+
+static struct rk_sensor_reg sensor_Zoom3[] =
+{
+	SensorEnd
+};
+static struct rk_sensor_reg *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL,};
+
+/*
+* User could be add v4l2_querymenu in sensor_controls by new_usr_v4l2menu
+*/
+static struct v4l2_querymenu sensor_menus[] =
+{
+};
+/*
+* User could be add v4l2_queryctrl in sensor_controls by new_user_v4l2ctrl
+*/
+static struct sensor_v4l2ctrl_usr_s sensor_controls[] =
+{
+};
+
+//MUST define the current used format as the first item   
+static struct rk_sensor_datafmt sensor_colour_fmts[] = {
+	{V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
+	{V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG} 
+};
+//static struct soc_camera_ops sensor_ops;//yzm
+
+
+/*
+**********************************************************
+* Following is local code:
+* 
+* Please codeing your program here 
+**********************************************************
+*/
+static int sensor_parameter_record(struct i2c_client *client)
+{
+	u8 ret_l,ret_m,ret_h;
+	int tp_l,tp_m,tp_h;
+	
+	struct generic_sensor *sensor = to_generic_sensor(client);
+	struct specific_sensor *spsensor = to_specific_sensor(sensor);
+
+	sensor_read(client,0x3a00, &ret_l);
+	sensor_write(client,0x3a00, ret_l&0xfb);
+
+	sensor_write(client,0x3503,0x07);	//stop AE/AG
+
+	sensor_read(client,0x3500,&ret_h);
+	sensor_read(client,0x3501, &ret_m);
+	sensor_read(client,0x3502, &ret_l);
+	tp_l = ret_l;
+	tp_m = ret_m;
+	tp_h = ret_h;
+	spsensor->parameter.preview_exposure = ((tp_h<<12) & 0xF000) | ((tp_m<<4) & 0x0FF0) | ((tp_l>>4) & 0x0F);
+	
+	//Read back AGC Gain for preview
+	sensor_read(client,0x350b, &ret_l);
+	spsensor->parameter.preview_gain = ret_l;
+
+	spsensor->parameter.CapturePclk = 24000;
+	spsensor->parameter.PreviewPclk = 24000;
+	spsensor->parameter.PreviewDummyPixels = 0;
+	spsensor->parameter.CaptureDummyPixels = 0;
+	SENSOR_DG("Read 0x350b=0x%02x  PreviewExposure:%d 0x3500=0x%02x  0x3501=0x%02x 0x3502=0x%02x",
+	          ret_l,spsensor->parameter.preview_exposure,tp_h, tp_m, tp_l);
+	return 0;
+}
+#define OV2659_FULL_PERIOD_PIXEL_NUMS  (1940)  // default pixel#(w/o dummy pixels) in UXGA mode
+#define OV2659_FULL_PERIOD_LINE_NUMS   (1238)  // default line#(w/o dummy lines) in UXGA mode
+#define OV2659_PV_PERIOD_PIXEL_NUMS   (970)  // default pixel#(w/o dummy pixels) in SVGA mode
+#define OV2659_PV_PERIOD_LINE_NUMS	  (618)   // default line#(w/o dummy lines) in SVGA mode
+
+/* SENSOR EXPOSURE LINE LIMITATION */
+#define OV2659_FULL_EXPOSURE_LIMITATION   (1236)
+#define OV2659_PV_EXPOSURE_LIMITATION	  (618)
+
+// SENSOR UXGA SIZE
+#define OV2659_IMAGE_SENSOR_FULL_WIDTH	  (1600)
+#define OV2659_IMAGE_SENSOR_FULL_HEIGHT   (1200)
+
+#define OV2659_FULL_GRAB_WIDTH				(OV2659_IMAGE_SENSOR_FULL_WIDTH - 16)
+#define OV2659_FULL_GRAB_HEIGHT 			(OV2659_IMAGE_SENSOR_FULL_HEIGHT - 12)
+static void OV2659SetDummy(struct i2c_client *client,unsigned int dummy_pixels, unsigned int dummy_lines)
+{
+	unsigned char val;
+	unsigned int temp_reg1, temp_reg2;
+	unsigned int temp_reg;
+	
+	if (dummy_pixels > 0)
+	{
+		sensor_read(client,0x380D,&val);	// HTS[b7~b0]
+		temp_reg1 = val;
+		sensor_read(client,0x380C,&val);	// HTS[b15~b8]
+		temp_reg2 = val;
+		temp_reg = (temp_reg1 & 0xFF) | (temp_reg2 << 8);
+	
+		temp_reg += dummy_pixels;
+	
+		sensor_write(client,0x380D,(temp_reg&0xFF));		 //HTS[7:0]
+		sensor_write(client,0x380C,((temp_reg&0xFF00)>>8));  //HTS[15:8]
+	}
+
+	if (dummy_lines > 0)
+	{
+		sensor_read(client,0x380F,&val);	// VTS[b7~b0]
+		temp_reg1 = val;
+		sensor_read(client,0x380E,&val);	// VTS[b15~b8]
+		temp_reg2 = val;
+		temp_reg = (temp_reg1 & 0xFF) | (temp_reg2 << 8);
+	
+		temp_reg += dummy_lines;
+	
+		sensor_write(client,0x380F,(temp_reg&0xFF));		 //VTS[7:0]
+		sensor_write(client,0x380E,((temp_reg&0xFF00)>>8));  //VTS[15:8]
+	}
+}	 /* OV2659_set_dummy */
+
+static void OV2659WriteShutter(struct i2c_client *client,bool is_preview, unsigned int shutter)
+{
+	unsigned int extra_exposure_lines = 0;
+
+	if (shutter < 1)
+	{
+		shutter = 1;
+	}
+	
+	if (is_preview) 
+	{
+		if (shutter <= OV2659_PV_EXPOSURE_LIMITATION) 
+		{
+			extra_exposure_lines = 0;
+		}
+		else 
+		{
+			extra_exposure_lines=shutter - OV2659_PV_EXPOSURE_LIMITATION;
+		}
+		
+	}
+	else 
+	{
+		if (shutter <= OV2659_FULL_EXPOSURE_LIMITATION) 
+		{
+			extra_exposure_lines = 0;
+		}
+		else 
+		{
+			extra_exposure_lines = shutter - OV2659_FULL_EXPOSURE_LIMITATION;
+		}
+		
+	}
+	
+	//AEC PK EXPOSURE
+	shutter*=16;
+	sensor_write(client,0x3502, (shutter & 0x00FF));		   //AEC[7:0]
+	sensor_write(client,0x3501, ((shutter & 0x0FF00) >>8));  //AEC[15:8]
+	sensor_write(client,0x3500, ((shutter & 0xFF0000) >> 16));	
+	
+	if(extra_exposure_lines>0)
+	{
+		// set extra exposure line [aec add vts]
+		sensor_write(client,0x3507, extra_exposure_lines & 0xFF);		   // EXVTS[b7~b0]
+		sensor_write(client,0x3506, (extra_exposure_lines & 0xFF00) >> 8); // EXVTS[b15~b8]
+	}
+	else
+	{
+		// set extra exposure line [aec add vts]
+		sensor_write(client,0x3507, 0x00);			// EXVTS[b7~b0]
+		sensor_write(client,0x3506, 0x00); // EXVTS[b15~b8]
+	}
+	
+}	 /* OV2659_write_shutter */
+static int sensor_ae_transfer(struct i2c_client *client)
+{
+	unsigned int prev_line_len,cap_line_len,shutter;
+	struct generic_sensor *sensor = to_generic_sensor(client);
+	struct specific_sensor *spsensor = to_specific_sensor(sensor);
+
+	mdelay(100);
+	shutter = spsensor->parameter.preview_exposure;
+
+	OV2659SetDummy(client,600,0);	
+	
+	prev_line_len = OV2659_PV_PERIOD_PIXEL_NUMS + spsensor->parameter.PreviewDummyPixels;
+	cap_line_len = OV2659_FULL_PERIOD_PIXEL_NUMS + spsensor->parameter.CaptureDummyPixels;
+	shutter = (shutter * spsensor->parameter.CapturePclk) / spsensor->parameter.PreviewPclk;
+	shutter = (shutter * prev_line_len) / cap_line_len;
+	shutter*=2;
+
+	OV2659WriteShutter(client,0,shutter);
+	
+	
+	return 0;
+}
+/*
+**********************************************************
+* Following is callback
+* If necessary, you could coding these callback
+**********************************************************
+*/
+/*
+* the function is called in open sensor  
+*/
+static int sensor_activate_cb(struct i2c_client *client)
+{
+    u8 reg_val;
+
+    SENSOR_DG("%s",__FUNCTION__);
+	
+	sensor_read(client,0x3000,&reg_val);
+	sensor_write(client, 0x3000, reg_val|0x03);
+	sensor_write(client, 0x3001, 0xff);
+	sensor_read(client,0x3002,&reg_val);
+	sensor_write(client, 0x3002, reg_val|0xe0);
+	
+	return 0;
+}
+/*
+* the function is called in close sensor
+*/
+static int sensor_deactivate_cb(struct i2c_client *client)
+{
+	u8 reg_val;
+	struct generic_sensor *sensor = to_generic_sensor(client);
+
+    SENSOR_DG("%s",__FUNCTION__);
+    
+	/* ddl@rock-chips.com : all sensor output pin must switch into Hi-Z */
+	if (sensor->info_priv.funmodule_state & SENSOR_INIT_IS_OK) {
+		sensor_read(client,0x3000,&reg_val);
+		sensor_write(client, 0x3000, reg_val&0xfc);
+		sensor_write(client, 0x3001, 0x00);
+		sensor_read(client,0x3002,&reg_val);
+		sensor_write(client, 0x3002, reg_val&0x1f);
+	}
+	
+	return 0;
+}
+/*
+* the function is called before sensor register setting in VIDIOC_S_FMT  
+*/
+static int sensor_s_fmt_cb_th(struct i2c_client *client,struct v4l2_mbus_framefmt *mf, bool capture)
+{
+    if (capture) {
+        sensor_parameter_record(client);
+    }
+
+    return 0;
+}
+/*
+* the function is called after sensor register setting finished in VIDIOC_S_FMT  
+*/
+static int sensor_s_fmt_cb_bh (struct i2c_client *client,struct v4l2_mbus_framefmt *mf, bool capture)
+{
+    if (capture) {
+        sensor_ae_transfer(client);
+    }
+    return 0;
+}
+static int sensor_try_fmt_cb_th(struct i2c_client *client,struct v4l2_mbus_framefmt *mf)
+{
+	return 0;
+}
+
+static int sensor_softrest_usr_cb(struct i2c_client *client,struct rk_sensor_reg *series)
+{
+	
+	return 0;
+}
+static int sensor_check_id_usr_cb(struct i2c_client *client,struct rk_sensor_reg *series)
+{
+	return 0;
+}
+
+static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)
+{
+	//struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+		
+	if (pm_msg.event == PM_EVENT_SUSPEND) {
+		SENSOR_DG("Suspend");
+		
+	} else {
+		SENSOR_TR("pm_msg.event(0x%x) != PM_EVENT_SUSPEND\n",pm_msg.event);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sensor_resume(struct soc_camera_device *icd)
+{
+
+	SENSOR_DG("Resume");
+
+	return 0;
+
+}
+static int sensor_mirror_cb (struct i2c_client *client, int mirror)
+{
+	char val;
+	int err = 0;
+    
+    SENSOR_DG("mirror: %d",mirror);
+	if (mirror) {
+		err = sensor_read(client, 0x3821, &val);
+		if (err == 0) {
+			val |= 0x06;
+			err = sensor_write(client, 0x3821, val);
+		}
+	} else {
+		err = sensor_read(client, 0x3821, &val);
+		if (err == 0) {
+			val &= 0xf9;
+			err = sensor_write(client, 0x3821, val);
+		}
+	}
+
+	return err;    
+}
+/*
+* the function is v4l2 control V4L2_CID_HFLIP callback  
+*/
+static int sensor_v4l2ctrl_mirror_cb(struct soc_camera_device *icd, struct sensor_v4l2ctrl_info_s *ctrl_info, 
+                                                     struct v4l2_ext_control *ext_ctrl)
+{
+	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if (sensor_mirror_cb(client,ext_ctrl->value) != 0)
+		SENSOR_TR("sensor_mirror failed, value:0x%x",ext_ctrl->value);
+	
+	SENSOR_DG("sensor_mirror success, value:0x%x",ext_ctrl->value);
+	return 0;
+}
+
+static int sensor_flip_cb(struct i2c_client *client, int flip)
+{
+	char val;
+	int err = 0;	
+
+    SENSOR_DG("flip: %d",flip);
+	if (flip) {
+		err = sensor_read(client, 0x3820, &val);
+		if (err == 0) {
+			val |= 0x06;
+			err = sensor_write(client, 0x3820, val);
+		}
+	} else {
+		err = sensor_read(client, 0x3820, &val);
+		if (err == 0) {
+			val &= 0xf9;
+			err = sensor_write(client, 0x3820, val);
+		}
+	}
+
+	return err;    
+}
+/*
+* the function is v4l2 control V4L2_CID_VFLIP callback  
+*/
+static int sensor_v4l2ctrl_flip_cb(struct soc_camera_device *icd, struct sensor_v4l2ctrl_info_s *ctrl_info, 
+                                                     struct v4l2_ext_control *ext_ctrl)
+{
+	struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if (sensor_flip_cb(client,ext_ctrl->value) != 0)
+		SENSOR_TR("sensor_flip failed, value:0x%x",ext_ctrl->value);
+	
+	SENSOR_DG("sensor_flip success, value:0x%x",ext_ctrl->value);
+	return 0;
+}
+/*
+* the functions are focus callbacks
+*/
+static int sensor_focus_init_usr_cb(struct i2c_client *client){
+	return 0;
+}
+
+static int sensor_focus_af_single_usr_cb(struct i2c_client *client){
+	return 0;
+}
+
+static int sensor_focus_af_near_usr_cb(struct i2c_client *client){
+	return 0;
+}
+
+static int sensor_focus_af_far_usr_cb(struct i2c_client *client){
+	return 0;
+}
+
+static int sensor_focus_af_specialpos_usr_cb(struct i2c_client *client,int pos){
+	return 0;
+}
+
+static int sensor_focus_af_const_usr_cb(struct i2c_client *client){
+	return 0;
+}
 static int sensor_focus_af_const_pause_usr_cb(struct i2c_client *client)
 {
     return 0;
-}
-static int sensor_focus_af_close_usr_cb(struct i2c_client *client){
-	return 0;
-}
-
-static int sensor_focus_af_zoneupdate_usr_cb(struct i2c_client *client, int *zone_tm_pos)
-{
-    return 0;
-}
-
-/*
-face defect call back
-*/
-static int 	sensor_face_detect_usr_cb(struct i2c_client *client,int on){
-	return 0;
-}
-
-/*
-*   The function can been run in sensor_init_parametres which run in sensor_probe, so user can do some
-* initialization in the function. 
-*/
-static void sensor_init_parameters_user(struct specific_sensor* spsensor,struct soc_camera_device *icd)
-{
-    return;
-}
-
-/*
-* :::::WARNING:::::
-* It is not allowed to modify the following code
-*/
-
-sensor_init_parameters_default_code();
-
-sensor_v4l2_struct_initialization();
-
-sensor_probe_default_code();
-
-sensor_remove_default_code();
-
-sensor_driver_default_module_code();
-
+}
+static int sensor_focus_af_close_usr_cb(struct i2c_client *client){
+	return 0;
+}
+
+static int sensor_focus_af_zoneupdate_usr_cb(struct i2c_client *client, int *zone_tm_pos)
+{
+    return 0;
+}
+
+/*
+face defect call back
+*/
+static int 	sensor_face_detect_usr_cb(struct i2c_client *client,int on){
+	return 0;
+}
+
+/*
+*   The function can been run in sensor_init_parametres which run in sensor_probe, so user can do some
+* initialization in the function. 
+*/
+static void sensor_init_parameters_user(struct specific_sensor* spsensor,struct soc_camera_device *icd)
+{
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+    return;
+}
+
+/*
+* :::::WARNING:::::
+* It is not allowed to modify the following code
+*/
+#if 1
+sensor_init_parameters_default_code();
+
+sensor_v4l2_struct_initialization();
+
+sensor_probe_default_code();
+
+sensor_remove_default_code();
+#endif
+sensor_driver_default_module_code();
+
diff --git a/drivers/media/video/rk30_camera.c b/drivers/media/video/rk30_camera.c
index f65ea0baf039..1991b499cc28 100755
--- a/drivers/media/video/rk30_camera.c
+++ b/drivers/media/video/rk30_camera.c
@@ -1,1107 +1,77 @@
-
-#include <mach/iomux.h>
-#include <media/soc_camera.h>
-#include <linux/android_pmem.h>
-#include <mach/rk30_camera.h>
-#ifndef PMEM_CAM_SIZE
-#include "../../../arch/arm/plat-rk/rk_camera.c"
-#else
-/*****************************************************************************************
- * camera  devices
- * author: ddl@rock-chips.com
- *****************************************************************************************/
-#ifdef CONFIG_VIDEO_RK29 
-
-static int rk_sensor_iomux(int pin)
-{    
-#if defined(CONFIG_ARCH_RK3066B) || defined(CONFIG_ARCH_RK3188)
-    iomux_set_gpio_mode(pin);
-#elif defined(CONFIG_ARCH_RK30)
-    switch (pin)
-    {
-        case RK30_PIN0_PA0: 
-		{
-			 rk30_mux_api_set(GPIO0A0_HDMIHOTPLUGIN_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA1: 
-		{
-			 rk30_mux_api_set(GPIO0A1_HDMII2CSCL_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA2:
-		{
-			 rk30_mux_api_set(GPIO0A2_HDMII2CSDA_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA3:
-		{
-			 rk30_mux_api_set(GPIO0A3_PWM0_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA4:
-		{
-			 rk30_mux_api_set(GPIO0A4_PWM1_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA5:
-		{
-			 rk30_mux_api_set(GPIO0A5_OTGDRVVBUS_NAME,0);
-			break;	
-		}
-        case RK30_PIN0_PA6:
-        {
-             rk30_mux_api_set(GPIO0A6_HOSTDRVVBUS_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PA7:
-        {
-             rk30_mux_api_set(GPIO0A7_I2S8CHSDI_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB0:
-        {
-             rk30_mux_api_set(GPIO0B0_I2S8CHCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB1:
-        {
-             rk30_mux_api_set(GPIO0B1_I2S8CHSCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB2:
-        {
-             rk30_mux_api_set(GPIO0B2_I2S8CHLRCKRX_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB3:
-        {
-             rk30_mux_api_set(GPIO0B3_I2S8CHLRCKTX_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB4:
-        {
-             rk30_mux_api_set(GPIO0B4_I2S8CHSDO0_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB5:
-        {
-             rk30_mux_api_set(GPIO0B5_I2S8CHSDO1_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB6:
-        {
-             rk30_mux_api_set(GPIO0B6_I2S8CHSDO2_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PB7:
-        {
-             rk30_mux_api_set(GPIO0B7_I2S8CHSDO3_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC0:
-        {
-             rk30_mux_api_set(GPIO0C0_I2S12CHCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC1:
-        {
-             rk30_mux_api_set(GPIO0C1_I2S12CHSCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC2:
-        {
-             rk30_mux_api_set(GPIO0C2_I2S12CHLRCKRX_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC3:
-        {
-             rk30_mux_api_set(GPIO0C3_I2S12CHLRCKTX_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC4:
-        {
-             rk30_mux_api_set(GPIO0C4_I2S12CHSDI_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC5:
-        {
-             rk30_mux_api_set(GPIO0C5_I2S12CHSDO_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC6:
-        {
-             rk30_mux_api_set(GPIO0C6_TRACECLK_SMCADDR2_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PC7:
-        {
-             rk30_mux_api_set(GPIO0C7_TRACECTL_SMCADDR3_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD0:
-        {
-             rk30_mux_api_set(GPIO0D0_I2S22CHCLK_SMCCSN0_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD1:
-        {
-             rk30_mux_api_set(GPIO0D1_I2S22CHSCLK_SMCWEN_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD2:
-        {
-             rk30_mux_api_set(GPIO0D2_I2S22CHLRCKRX_SMCOEN_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD3:
-        {
-             rk30_mux_api_set(GPIO0D3_I2S22CHLRCKTX_SMCADVN_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD4:
-        {
-             rk30_mux_api_set(GPIO0D4_I2S22CHSDI_SMCADDR0_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD5:
-        {
-             rk30_mux_api_set(GPIO0D5_I2S22CHSDO_SMCADDR1_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD6:
-        {
-             rk30_mux_api_set(GPIO0D6_PWM2_NAME,0);
-            break;	
-        }
-        case RK30_PIN0_PD7:
-        {
-             rk30_mux_api_set(GPIO0D7_PWM3_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA0:
-        {
-             rk30_mux_api_set(GPIO1A0_UART0SIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA1:
-        {
-             rk30_mux_api_set(GPIO1A1_UART0SOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA2:
-        {
-             rk30_mux_api_set(GPIO1A2_UART0CTSN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA3:
-        {
-             rk30_mux_api_set(GPIO1A3_UART0RTSN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA4:
-        {
-             rk30_mux_api_set(GPIO1A4_UART1SIN_SPI0CSN0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA5:
-        {
-             rk30_mux_api_set(GPIO1A5_UART1SOUT_SPI0CLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA6:
-        {
-             rk30_mux_api_set(GPIO1A6_UART1CTSN_SPI0RXD_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PA7:
-        {
-             rk30_mux_api_set(GPIO1A7_UART1RTSN_SPI0TXD_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB0:
-        {
-             rk30_mux_api_set(GPIO1B0_UART2SIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB1:
-        {
-             rk30_mux_api_set(GPIO1B1_UART2SOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB2:
-        {
-             rk30_mux_api_set(GPIO1B2_SPDIFTX_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB3:
-        {
-             rk30_mux_api_set(GPIO1B3_CIF0CLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB4:
-        {
-             rk30_mux_api_set(GPIO1B4_CIF0DATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB5:
-        {
-             rk30_mux_api_set(GPIO1B5_CIF0DATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB6:
-        {
-             rk30_mux_api_set(GPIO1B6_CIFDATA10_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PB7:
-        {
-             rk30_mux_api_set(GPIO1B7_CIFDATA11_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC0:
-        {
-             rk30_mux_api_set(GPIO1C0_CIF1DATA2_RMIICLKOUT_RMIICLKIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC1:
-        {
-             rk30_mux_api_set(GPIO1C1_CIFDATA3_RMIITXEN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC2:
-        {
-             rk30_mux_api_set(GPIO1C2_CIF1DATA4_RMIITXD1_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC3:
-        {
-             rk30_mux_api_set(GPIO1C3_CIFDATA5_RMIITXD0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC4:
-        {
-             rk30_mux_api_set(GPIO1C4_CIFDATA6_RMIIRXERR_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC5:
-        {
-             rk29_mux_api_set(GPIO1C5_CIFDATA7_RMIICRSDVALID_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC6:
-        {
-             rk30_mux_api_set(GPIO1C6_CIFDATA8_RMIIRXD1_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PC7:
-        {
-             rk30_mux_api_set(GPIO1C7_CIFDATA9_RMIIRXD0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD0:
-        {
-             rk30_mux_api_set(GPIO1D0_CIF1VSYNC_MIIMD_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD1:
-        {
-             rk30_mux_api_set(GPIO1D1_CIF1HREF_MIIMDCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD2:
-        {
-             rk30_mux_api_set(GPIO1D2_CIF1CLKIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD3:
-        {
-             rk30_mux_api_set(GPIO1D3_CIF1DATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD4:
-        {
-             rk30_mux_api_set(GPIO1D4_CIF1DATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD5:
-        {
-             rk30_mux_api_set(GPIO1D5_CIF1DATA10_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD6:
-        {
-             rk30_mux_api_set(GPIO1D6_CIF1DATA11_NAME,0);
-            break;	
-        }
-        case RK30_PIN1_PD7:
-        {
-             rk30_mux_api_set(GPIO1D7_CIF1CLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA0:
-        {
-             rk30_mux_api_set(GPIO2A0_LCDC1DATA0_SMCADDR4_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA1:
-        {
-             rk30_mux_api_set(GPIO2A1_LCDC1DATA1_SMCADDR5_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA2:
-        {
-             rk30_mux_api_set(GPIO2A2_LCDCDATA2_SMCADDR6_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA3:
-        {
-             rk30_mux_api_set(GPIO2A3_LCDCDATA3_SMCADDR7_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA4:
-        {
-             rk30_mux_api_set(GPIO2A4_LCDC1DATA4_SMCADDR8_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA5:
-        {
-             rk30_mux_api_set(GPIO2A5_LCDC1DATA5_SMCADDR9_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA6:
-        {
-             rk30_mux_api_set(GPIO2A6_LCDC1DATA6_SMCADDR10_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PA7:
-        {
-             rk30_mux_api_set(GPIO2A7_LCDC1DATA7_SMCADDR11_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB0:
-        {
-             rk30_mux_api_set(GPIO2B0_LCDC1DATA8_SMCADDR12_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB1:
-        {
-             rk30_mux_api_set(GPIO2B1_LCDC1DATA9_SMCADDR13_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB2:
-        {
-             rk30_mux_api_set(GPIO2B2_LCDC1DATA10_SMCADDR14_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB3:
-        {
-             rk30_mux_api_set(GPIO2B3_LCDC1DATA11_SMCADDR15_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB4:
-        {
-             rk30_mux_api_set(GPIO2B4_LCDC1DATA12_SMCADDR16_HSADCDATA9_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB5:
-        {
-             rk30_mux_api_set(GPIO2B5_LCDC1DATA13_SMCADDR17_HSADCDATA8_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB6:
-        {
-             rk30_mux_api_set(GPIO2B6_LCDC1DATA14_SMCADDR18_TSSYNC_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PB7:
-        {
-             rk30_mux_api_set(GPIO2B7_LCDC1DATA15_SMCADDR19_HSADCDATA7_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC0:
-        {
-             rk30_mux_api_set(GPIO2C0_LCDCDATA16_GPSCLK_HSADCCLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC1:
-        {
-             rk30_mux_api_set(GPIO2C1_LCDC1DATA17_SMCBLSN0_HSADCDATA6_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC2:
-        {
-             rk30_mux_api_set(GPIO2C2_LCDC1DATA18_SMCBLSN1_HSADCDATA5_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC3:
-        {
-             rk29_mux_api_set(GPIO2C3_LCDC1DATA19_SPI1CLK_HSADCDATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC4:
-        {
-             rk30_mux_api_set(GPIO2C4_LCDC1DATA20_SPI1CSN0_HSADCDATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC5:
-        {
-             rk30_mux_api_set(GPIO2C5_LCDC1DATA21_SPI1TXD_HSADCDATA2_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC6:
-        {
-             rk30_mux_api_set(GPIO2C6_LCDC1DATA22_SPI1RXD_HSADCDATA3_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PC7:
-        {
-             rk30_mux_api_set(GPIO2C7_LCDC1DATA23_SPI1CSN1_HSADCDATA4_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD0:
-        {
-             rk30_mux_api_set(GPIO2D0_LCDC1DCLK_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD1:
-        {
-             rk30_mux_api_set(GPIO2D1_LCDC1DEN_SMCCSN1_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD2:
-        {
-             rk30_mux_api_set(GPIO2D2_LCDC1HSYNC_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD3:
-        {
-             rk30_mux_api_set(GPIO2D3_LCDC1VSYNC_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD4:
-        {
-             rk30_mux_api_set(GPIO2D4_I2C0SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD5:
-        {
-             rk30_mux_api_set(GPIO2D5_I2C0SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD6:
-        {
-             rk30_mux_api_set(GPIO2D6_I2C1SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN2_PD7:
-        {
-             rk30_mux_api_set(GPIO2D7_I2C1SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA0:
-        {
-             rk30_mux_api_set(GPIO3A0_I2C2SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA1:
-        {
-             rk30_mux_api_set(GPIO3A1_I2C2SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA2:
-        {
-             rk30_mux_api_set(GPIO3A2_I2C3SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA3:
-        {
-             rk30_mux_api_set(GPIO3A3_I2C3SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA4:
-        {
-             rk30_mux_api_set(GPIO3A4_I2C4SDA_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA5:
-        {
-             rk30_mux_api_set(GPIO3A5_I2C4SCL_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA6:
-        {
-             rk30_mux_api_set(GPIO3A6_SDMMC0RSTNOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PA7:
-        {
-             rk30_mux_api_set(GPIO3A7_SDMMC0PWREN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB0:
-        {
-             rk30_mux_api_set(GPIO3B0_SDMMC0CLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB1:
-        {
-             rk30_mux_api_set(GPIO3B1_SDMMC0CMD_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB2:
-        {
-             rk30_mux_api_set(GPIO3B2_SDMMC0DATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB3:
-        {
-             rk30_mux_api_set(GPIO3B3_SDMMC0DATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB4:
-        {
-             rk30_mux_api_set(GPIO3B4_SDMMC0DATA2_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB5:
-        {
-             rk30_mux_api_set(GPIO3B5_SDMMC0DATA3_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB6:
-        {
-             rk30_mux_api_set(GPIO3B6_SDMMC0DETECTN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PB7:
-        {
-             rk30_mux_api_set(GPIO3B7_SDMMC0WRITEPRT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC0:
-        {
-             rk30_mux_api_set(GPIO3C0_SMMC1CMD_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC1:
-        {
-             rk30_mux_api_set(GPIO3C1_SDMMC1DATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC2:
-        {
-             rk30_mux_api_set(GPIO3C2_SDMMC1DATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC3:
-        {
-             rk30_mux_api_set(GPIO3C3_SDMMC1DATA2_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC4:
-        {
-             rk30_mux_api_set(GPIO3C4_SDMMC1DATA3_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC5:
-        {
-             rk30_mux_api_set(GPIO3C5_SDMMC1CLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC6:
-        {
-             rk30_mux_api_set(GPIO3C6_SDMMC1DETECTN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PC7:
-        {
-             rk30_mux_api_set(GPIO3C7_SDMMC1WRITEPRT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD0:
-        {
-             rk30_mux_api_set(GPIO3D0_SDMMC1PWREN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD1:
-        {
-             rk30_mux_api_set(GPIO3D1_SDMMC1BACKENDPWR_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD2:
-        {
-             rk30_mux_api_set(GPIO3D2_SDMMC1INTN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD3:
-        {
-             rk30_mux_api_set(GPIO3D3_UART3SIN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD4:
-        {
-             rk30_mux_api_set(GPIO3D4_UART3SOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD5:
-        {
-             rk30_mux_api_set(GPIO3D5_UART3CTSN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD6:
-        {
-             rk30_mux_api_set(GPIO3D6_UART3RTSN_NAME,0);
-            break;	
-        }
-        case RK30_PIN3_PD7:
-        {
-             rk30_mux_api_set(GPIO3D7_FLASHDQS_EMMCCLKOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PA0:
-	{
-		 rk30_mux_api_set(GPIO4A0_FLASHDATA8_NAME,0);
-		break;	
-	}
-        case RK30_PIN4_PA1:
-	{
-		 rk30_mux_api_set(GPIO4A1_FLASHDATA9_NAME,0);
-		break;	
-	}
-        case RK30_PIN4_PA2:
-	{
-		 rk30_mux_api_set(GPIO4A2_FLASHDATA10_NAME,0);
-		break;	
-	}
-			
-        case RK30_PIN4_PA3:
-	{
-		 rk30_mux_api_set(GPIO4A3_FLASHDATA11_NAME,0);
-		break;	
-	}
-        case RK30_PIN4_PA4:
-	{
-		 rk30_mux_api_set(GPIO4A4_FLASHDATA12_NAME,0);
-		break;	
-	}
-        case RK30_PIN4_PA5:
-        {
-             rk30_mux_api_set(GPIO4A5_FLASHDATA13_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PA6:
-        {
-             rk30_mux_api_set(GPIO4A6_FLASHDATA14_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PA7:
-        {
-             rk30_mux_api_set(GPIO4A7_FLASHDATA15_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB0:
-        {
-             rk30_mux_api_set(GPIO4B0_FLASHCSN1_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB1:
-        {
-             rk30_mux_api_set(GPIO4B1_FLASHCSN2_EMMCCMD_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB2:
-        {
-             rk30_mux_api_set(GPIO4B2_FLASHCSN3_EMMCRSTNOUT_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB3:
-        {
-             rk30_mux_api_set(GPIO4B3_FLASHCSN4_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB4:
-        {
-             rk30_mux_api_set(GPIO4B4_FLASHCSN5_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB5:
-        {
-             rk30_mux_api_set(GPIO4B5_FLASHCSN6_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PB6:
-        {
-             rk30_mux_api_set(GPIO4B6_FLASHCSN7_NAME ,0);
-            break;	
-        }
-        case RK30_PIN4_PB7:
-        {
-             rk30_mux_api_set(GPIO4B7_SPI0CSN1_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC0:
-        {
-             rk30_mux_api_set(GPIO4C0_SMCDATA0_TRACEDATA0_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC1:
-        {
-             rk30_mux_api_set(GPIO4C1_SMCDATA1_TRACEDATA1_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC2:
-        {
-             rk30_mux_api_set(GPIO4C2_SMCDATA2_TRACEDATA2_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC3:
-        {
-             rk30_mux_api_set(GPIO4C3_SMCDATA3_TRACEDATA3_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC4:
-        {
-             rk30_mux_api_set(GPIO4C4_SMCDATA4_TRACEDATA4_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC5:
-        {
-             rk30_mux_api_set(GPIO4C5_SMCDATA5_TRACEDATA5_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PC6:
-        {
-             rk30_mux_api_set(GPIO4C6_SMCDATA6_TRACEDATA6_NAME,0);
-            break;	
-        }
-
-
-        case RK30_PIN4_PC7:
-        {
-             rk30_mux_api_set(GPIO4C7_SMCDATA7_TRACEDATA7_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PD0:
-	    {
-		     rk30_mux_api_set(GPIO4D0_SMCDATA8_TRACEDATA8_NAME,0);			   
-		     break;	
-	    }
-        case RK30_PIN4_PD1:
-        {
-             rk30_mux_api_set(GPIO4D1_SMCDATA9_TRACEDATA9_NAME,0);             
-             break;	
-        }
-        case RK30_PIN4_PD2:
-	    {
-		     rk30_mux_api_set(GPIO4D2_SMCDATA10_TRACEDATA10_NAME,0);			            
-		     break;	
-	    }
-        case RK30_PIN4_PD3:
-        {
-             rk30_mux_api_set(GPIO4D3_SMCDATA11_TRACEDATA11_NAME,0);           
-             break;	
-        }
-        case RK30_PIN4_PD4:
-        {
-             rk30_mux_api_set(GPIO4D4_SMCDATA12_TRACEDATA12_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PD5:
-        {
-             rk30_mux_api_set(GPIO4D5_SMCDATA13_TRACEDATA13_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PD6:
-        {
-             rk30_mux_api_set(GPIO4D6_SMCDATA14_TRACEDATA14_NAME,0);
-            break;	
-        }
-        case RK30_PIN4_PD7:
-        {
-             rk30_mux_api_set(GPIO4D7_SMCDATA15_TRACEDATA15_NAME,0);
-            break;	
-        } 
-        case RK30_PIN6_PA0:
-        case RK30_PIN6_PA1:
-        case RK30_PIN6_PA2:
-        case RK30_PIN6_PA3:
-        case RK30_PIN6_PA4:
-        case RK30_PIN6_PA5:
-        case RK30_PIN6_PA6:
-        case RK30_PIN6_PA7:
-        case RK30_PIN6_PB0:
-        case RK30_PIN6_PB1:
-        case RK30_PIN6_PB2:
-        case RK30_PIN6_PB3:
-        case RK30_PIN6_PB4:
-        case RK30_PIN6_PB5:
-        case RK30_PIN6_PB6:
-			break;
-        case RK30_PIN6_PB7:
-		{
-			 rk30_mux_api_set(GPIO6B7_TESTCLOCKOUT_NAME,0);
-			break;	
-		} 
-        default:
-        {
-            printk("Pin=%d isn't RK GPIO, Please init it's iomux yourself!",pin);
-            break;
-        }
-    }
-#endif
-    return 0;
-}
-#define PMEM_CAM_BASE 0 //just for compile ,no meaning
-#include "../../../arch/arm/plat-rk/rk_camera.c"
-
-
-
-static u64 rockchip_device_camera_dmamask = 0xffffffffUL;
-#if RK_SUPPORT_CIF0
-static struct resource rk_camera_resource_host_0[] = {
-	[0] = {
-		.start = RK30_CIF0_PHYS,
-		.end   = RK30_CIF0_PHYS + RK30_CIF0_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = IRQ_CIF0,
-		.end   = IRQ_CIF0,
-		.flags = IORESOURCE_IRQ,
-	}
-};
-#endif
-#if RK_SUPPORT_CIF1
-static struct resource rk_camera_resource_host_1[] = {
-	[0] = {
-		.start = RK30_CIF1_PHYS,
-		.end   = RK30_CIF1_PHYS + RK30_CIF1_SIZE - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = IRQ_CIF1,
-		.end   = IRQ_CIF1,
-		.flags = IORESOURCE_IRQ,
-	}
-};
-#endif
-
-/*platform_device : */
-#if RK_SUPPORT_CIF0
- struct platform_device rk_device_camera_host_0 = {
-	.name		  = RK29_CAM_DRV_NAME,
-	.id 	  = RK_CAM_PLATFORM_DEV_ID_0,				/* This is used to put cameras on this interface */
-	.num_resources	  = ARRAY_SIZE(rk_camera_resource_host_0),
-	.resource	  = rk_camera_resource_host_0,
-	.dev			= {
-		.dma_mask = &rockchip_device_camera_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-		.platform_data	= &rk_camera_platform_data,
-	}
-};
-#endif
-
-#if RK_SUPPORT_CIF1
-/*platform_device : */
- struct platform_device rk_device_camera_host_1 = {
-	.name		  = RK29_CAM_DRV_NAME,
-	.id 	  = RK_CAM_PLATFORM_DEV_ID_1,				/* This is used to put cameras on this interface */
-	.num_resources	  = ARRAY_SIZE(rk_camera_resource_host_1),
-	.resource	  = rk_camera_resource_host_1,
-	.dev			= {
-		.dma_mask = &rockchip_device_camera_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-		.platform_data	= &rk_camera_platform_data,
-	}
-};
-#endif
-
-static void rk_init_camera_plateform_data(void)
-{
-    int i,dev_idx;
-    
-    dev_idx = 0;
-    for (i=0; i<RK_CAM_NUM; i++) {
-        rk_camera_platform_data.sensor_init_data[i] = &rk_init_data_sensor[i];
-        if (rk_camera_platform_data.register_dev[i].device_info.name) {            
-            rk_camera_platform_data.register_dev[i].link_info.board_info = 
-                &rk_camera_platform_data.register_dev[i].i2c_cam_info;
-            rk_camera_platform_data.register_dev[i].device_info.id = dev_idx;
-            rk_camera_platform_data.register_dev[i].device_info.dev.platform_data = 
-                &rk_camera_platform_data.register_dev[i].link_info;
-            dev_idx++;
-        }
-    }
-}
-
-static void rk30_camera_request_reserve_mem(void)
-{
-    int i,max_resolution;
-    int cam_ipp_mem=PMEM_CAMIPP_NECESSARY, cam_pmem=PMEM_CAM_NECESSARY;
-
-    i =0;
-    max_resolution = 0x00;
-    while (strstr(new_camera[i].dev.device_info.dev.init_name,"end")==NULL) {
-        if (new_camera[i].resolution > max_resolution)
-            max_resolution = new_camera[i].resolution;
-        i++;
-    }
-
-    if (max_resolution < PMEM_SENSOR_FULL_RESOLUTION_CIF_1)
-        max_resolution = PMEM_SENSOR_FULL_RESOLUTION_CIF_1;
-    if (max_resolution < PMEM_SENSOR_FULL_RESOLUTION_CIF_0)
-        max_resolution = PMEM_SENSOR_FULL_RESOLUTION_CIF_0;
-
-    switch (max_resolution)
-    {
-        case 0x800000:
-        default:
-        {
-            cam_ipp_mem = 0xC00000;
-            cam_pmem = 0x1900000;
-            break;
-        }
-
-        case 0x500000:
-        {
-            cam_ipp_mem = 0x800000;
-            cam_pmem = 0x1400000;
-            break;
-        }
-
-        case 0x300000:
-        {
-            cam_ipp_mem = 0x600000;
-            cam_pmem = 0xf00000;
-            break;
-        }
-
-        case 0x200000:
-        {
-            cam_ipp_mem = 0x600000;
-            cam_pmem = 0xc00000;
-            break;
-        }
-        case 0x210000:
-        {
-            cam_ipp_mem = 0xc00000;
-            cam_pmem = 0xc00000;
-            break;
-        }
-        case 0x100000:
-        {
-            cam_ipp_mem = 0x600000;
-            cam_pmem = 0xa00000;
-            break;
-        }
-
-        case 0x30000:
-        {
-            cam_ipp_mem = 0x600000;
-            cam_pmem = 0x600000;
-            break;
-        }
-    }
-
-    
-
-#ifdef CONFIG_VIDEO_RK29_WORK_IPP
-        rk_camera_platform_data.meminfo.vbase = rk_camera_platform_data.meminfo_cif1.vbase = NULL;
-    #if defined(CONFIG_VIDEO_RKCIF_WORK_SIMUL_OFF) || ((RK_SUPPORT_CIF0 && RK_SUPPORT_CIF1) == 0)
-        rk_camera_platform_data.meminfo.name = "camera_ipp_mem";
-        rk_camera_platform_data.meminfo.start = board_mem_reserve_add("camera_ipp_mem",cam_ipp_mem);
-        rk_camera_platform_data.meminfo.size= cam_ipp_mem;
-
-        memcpy(&rk_camera_platform_data.meminfo_cif1,&rk_camera_platform_data.meminfo,sizeof(struct rk29camera_mem_res));
-    #else
-        rk_camera_platform_data.meminfo.name = "camera_ipp_mem_0";
-        rk_camera_platform_data.meminfo.start = board_mem_reserve_add("camera_ipp_mem_0",PMEM_CAMIPP_NECESSARY_CIF_0);
-        rk_camera_platform_data.meminfo.size= PMEM_CAMIPP_NECESSARY_CIF_0;
-        
-        rk_camera_platform_data.meminfo_cif1.name = "camera_ipp_mem_1";
-        rk_camera_platform_data.meminfo_cif1.start =board_mem_reserve_add("camera_ipp_mem_1",PMEM_CAMIPP_NECESSARY_CIF_1);
-        rk_camera_platform_data.meminfo_cif1.size= PMEM_CAMIPP_NECESSARY_CIF_1;
-    #endif
- #endif
- #if PMEM_CAM_NECESSARY
-        android_pmem_cam_pdata.start = board_mem_reserve_add((char*)(android_pmem_cam_pdata.name),cam_pmem);
-        android_pmem_cam_pdata.size= cam_pmem;
- #endif
-
-}
-static int rk_register_camera_devices(void)
-{
-    int i;
-    int host_registered_0,host_registered_1;
-    struct rkcamera_platform_data *new_camera;
-    
-	rk_init_camera_plateform_data();
-
-    host_registered_0 = 0;
-    host_registered_1 = 0;
-    
-    for (i=0; i<RK_CAM_NUM; i++) {
-        if (rk_camera_platform_data.register_dev[i].device_info.name) {
-            
-            if (rk_camera_platform_data.register_dev[i].link_info.bus_id == RK_CAM_PLATFORM_DEV_ID_0) {
-            #if RK_SUPPORT_CIF0                
-                host_registered_0 = 1;
-            #else
-                printk(KERN_ERR "%s(%d) : This chip isn't support CIF0, Please user check ...\n",__FUNCTION__,__LINE__);
-            #endif
-            } 
-
-            if (rk_camera_platform_data.register_dev[i].link_info.bus_id == RK_CAM_PLATFORM_DEV_ID_1) {
-            #if RK_SUPPORT_CIF1
-                host_registered_1 = 1;
-            #else
-                printk(KERN_ERR "%s(%d) : This chip isn't support CIF1, Please user check ...\n",__FUNCTION__,__LINE__);
-            #endif
-            } 
-        }
-    }
-
-    
-    i=0;
-    new_camera = rk_camera_platform_data.register_dev_new;
-    if (new_camera != NULL) {
-        while (strstr(new_camera->dev.device_info.dev.init_name,"end")==NULL) {
-            if (new_camera->dev.link_info.bus_id == RK_CAM_PLATFORM_DEV_ID_1) {
-                host_registered_1 = 1;
-            } else if (new_camera->dev.link_info.bus_id == RK_CAM_PLATFORM_DEV_ID_0) {
-                host_registered_0 = 1;
-            }
-            new_camera++;
-        }
-    }
-    #if RK_SUPPORT_CIF0
-    if (host_registered_0) {
-        platform_device_register(&rk_device_camera_host_0);
-    }
-    #endif
-    #if RK_SUPPORT_CIF1
-    if (host_registered_1) {
-        platform_device_register(&rk_device_camera_host_1);
-    }  
-    #endif
-
-    for (i=0; i<RK_CAM_NUM; i++) {
-        if (rk_camera_platform_data.register_dev[i].device_info.name) {
-            platform_device_register(&rk_camera_platform_data.register_dev[i].device_info);
-        }
-    }
-
-    if (rk_camera_platform_data.sensor_register)
-       (rk_camera_platform_data.sensor_register)(); 
-    
- #if PMEM_CAM_NECESSARY
-    platform_device_register(&android_pmem_cam_device);
- #endif
-	return 0;
-}
-
-module_init(rk_register_camera_devices);
-#endif
-
-#endif //#ifdef CONFIG_VIDEO_RK
+   
+#include <media/soc_camera.h>
+#include <media/camsys_head.h>
+#include <linux/android_pmem.h>
+#include <linux/i2c.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include "../../../arch/arm/mach-rockchip/rk30_camera.h"//yzm
+#include "../../../arch/arm/mach-rockchip/rk_camera.h"//yzm
+//**********yzm***********//
+#include <linux/kernel.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/of_fdt.h>
+#include <linux/module.h>
+
+static int rk_dts_sensor_probe(struct platform_device *pdev);
+static int rk_dts_sensor_remove(struct platform_device *pdev);
+static int rk_dts_cif_probe(struct platform_device *pdev);
+static int rk_dts_cif_remove(struct platform_device *pdev);
+
+#include "../../../arch/arm/mach-rockchip/rk_camera.c"//yzm
+
+
+static int rk_register_camera_devices(void)
+{
+    int i;
+    int host_registered_0,host_registered_1;
+    struct rkcamera_platform_data *new_camera;    //定义的是一个sensor结构体
+
+	//printk(KERN_EMERG "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+	rk_cif_sensor_init();
+
+    host_registered_0 = 0;
+    host_registered_1 = 0;
+    
+    i=0;
+    new_camera = rk_camera_platform_data.register_dev_new;
+	//new_camera = new_camera_head;
+
+    if (new_camera != NULL) {
+        while (new_camera != NULL) {
+			if (new_camera->dev.desc_info.host_desc.bus_id == RK_CAM_PLATFORM_DEV_ID_1) {//yzm
+                host_registered_1 = 1;
+			} else if (new_camera->dev.desc_info.host_desc.bus_id == RK_CAM_PLATFORM_DEV_ID_0) {//yzm
+                host_registered_0 = 1;
+            }
+			
+            new_camera = new_camera->next_camera;
+        }
+    }
+
+    #if RK_SUPPORT_CIF0
+    if (host_registered_0) {
+        platform_device_register(&rk_device_camera_host_0);//host_0 上有sensor
+    }   //host_device_register
+    #endif
+	
+    #if RK_SUPPORT_CIF1
+    if (host_registered_1) {
+        platform_device_register(&rk_device_camera_host_1);//host_1上有sensor
+    }  //host_device_register
+    #endif
+
+
+    if (rk_camera_platform_data.sensor_register)      
+       (rk_camera_platform_data.sensor_register)();   //调用rk_sensor_register()
+
+ #if PMEM_CAM_NECESSARY
+    platform_device_register(&android_pmem_cam_device);//???
+ #endif
+	return 0;
+}
+
+
+module_init(rk_register_camera_devices);//yzm
diff --git a/drivers/media/video/rk30_camera_oneframe.c b/drivers/media/video/rk30_camera_oneframe.c
index c514ece86e44..e587777f606a 100755
--- a/drivers/media/video/rk30_camera_oneframe.c
+++ b/drivers/media/video/rk30_camera_oneframe.c
@@ -1,19 +1,9 @@
-/*
- * V4L2 Driver for RK28 camera host
- *
- * Copyright (C) 2006, Sascha Hauer, Pengutronix
- * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
+ /************yzm************
 #if (defined(CONFIG_ARCH_RK2928) ||\
      defined(CONFIG_ARCH_RK30)   ||\
      defined(CONFIG_ARCH_RK3188) ||\
      defined(CONFIG_ARCH_RK3026))
-     
+*/     
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/io.h>
@@ -34,21 +24,21 @@
 #include <linux/mutex.h>
 #include <linux/videodev2.h>
 #include <linux/kthread.h>
-#include <mach/iomux.h>
+
+//#include <mach/iomux.h>//yzm  
 #include <media/v4l2-common.h>
 #include <media/v4l2-dev.h>
 #include <media/videobuf-dma-contig.h>
 #include <media/soc_camera.h>
 #include <media/soc_mediabus.h>
-#include <mach/io.h>
-#include <plat/ipp.h>
-#include <plat/vpu_service.h>
+#include <media/videobuf-core.h>
+#include <linux/rockchip/iomap.h>
+
 #include "../../video/rockchip/rga/rga.h"
-#if defined(CONFIG_ARCH_RK30)||defined(CONFIG_ARCH_RK3188)
-#include <mach/rk30_camera.h>
-#include <mach/cru.h>
-#include <mach/pmu.h>
-#endif
+#include "../../../arch/arm/mach-rockchip/rk30_camera.h"//yzm
+
+/*******yzm*********
+
 #include <plat/efuse.h>
 #if (defined(CONFIG_ARCH_RK2928) || defined(CONFIG_ARCH_RK3026))
 #include <mach/rk2928_camera.h>
@@ -56,9 +46,18 @@
 #include <mach/pmu.h>
 #define SOFT_RST_CIF1 (SOFT_RST_MAX+1)
 #endif
+*/
 #include <asm/cacheflush.h>
 
-static int debug;
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/of_fdt.h>
+#include <media/soc_camera.h>
+#include <media/camsys_head.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+ 
+static int debug = 0;
 module_param(debug, int, S_IRUGO|S_IWUSR);
 
 #define CAMMODULE_NAME     "rk_cam_cif"   
@@ -74,6 +73,9 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define RKCAMERA_TR(format, ...)  printk(KERN_ERR "%s(%d):" format,CAMMODULE_NAME,__LINE__,## __VA_ARGS__)
 #define RKCAMERA_DG1(format, ...) wprintk(1, format, ## __VA_ARGS__)
 #define RKCAMERA_DG2(format, ...) dprintk(2, format, ## __VA_ARGS__)
+#define debug_printk(format, ...) dprintk(3, format, ## __VA_ARGS__)
+
+#define RK30_CRU_BASE 0x00 //yzm
 
 // CIF Reg Offset
 #define  CIF_CIF_CTRL                       0x00
@@ -169,11 +171,15 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define RK_SENSOR_24MHZ      24*1000*1000          /* MHz */
 #define RK_SENSOR_48MHZ      48
 
+#define __raw_readl(p)		  (*(unsigned long *)(p))
+#define __raw_writel(v,p)     (*(unsigned long *)(p) = (v))
+
 #define write_cif_reg(base,addr, val)  __raw_writel(val, addr+(base))
 #define read_cif_reg(base,addr) __raw_readl(addr+(base))
 #define mask_cif_reg(addr, msk, val)    write_cif_reg(addr, (val)|((~(msk))&read_cif_reg(addr)))
 
-#if defined(CONFIG_ARCH_RK30) || defined(CONFIG_ARCH_RK3188)
+/*********yzm***********/
+//#if defined(CONFIG_ARCH_RK30) || defined(CONFIG_ARCH_RK3188)
 //CRU,PIXCLOCK
 #define CRU_PCLK_REG30                     0xbc
 #define ENANABLE_INVERT_PCLK_CIF0          ((0x1<<24)|(0x1<<8))
@@ -190,7 +196,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define write_cru_reg(addr, val)            __raw_writel(val, addr+RK30_CRU_BASE)
 #define read_cru_reg(addr)                  __raw_readl(addr+RK30_CRU_BASE)
 #define mask_cru_reg(addr, msk, val)        write_cru_reg(addr,(val)|((~(msk))&read_cru_reg(addr)))
-#endif
+//#endif    //yzm  end
 
 #if defined(CONFIG_ARCH_RK3026)
 //CRU,PIXCLOCK
@@ -234,10 +240,10 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define mask_grf_reg(addr, msk, val)	
 #endif
 
-#define CAM_WORKQUEUE_IS_EN()  (true)
-#define CAM_IPPWORK_IS_EN()     ((pcdev->zoominfo.a.c.width != pcdev->icd->user_width) || (pcdev->zoominfo.a.c.height != pcdev->icd->user_height))
+#define CAM_WORKQUEUE_IS_EN()  (false)//(true)
+#define CAM_IPPWORK_IS_EN()     (false)//((pcdev->zoominfo.a.c.width != pcdev->icd->user_width) || (pcdev->zoominfo.a.c.height != pcdev->icd->user_height))
 
-#define IS_CIF0()		(pcdev->hostid == RK_CAM_PLATFORM_DEV_ID_0)
+#define IS_CIF0()		(true)//(pcdev->hostid == RK_CAM_PLATFORM_DEV_ID_0)
 #if (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_IPP)
 #define CROP_ALIGN_BYTES (0x03)
 #define CIF_DO_CROP 0
@@ -251,102 +257,22 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CROP_ALIGN_BYTES (0x0F)
 #define CIF_DO_CROP 1
 #endif
-//Configure Macro
-/*
-*			 Driver Version Note
-*
-*v0.0.x : this driver is 2.6.32 kernel driver;
-*v0.1.x : this driver is 3.0.8 kernel driver;
-*
-*v0.x.1 : this driver first support rk2918;
-*v0.x.2 : fix this driver support v4l2 format is V4L2_PIX_FMT_NV12 and V4L2_PIX_FMT_NV16,is not V4L2_PIX_FMT_YUV420 
-*		  and V4L2_PIX_FMT_YUV422P;
-*v0.x.3 : this driver support VIDIOC_ENUM_FRAMEINTERVALS;
-*v0.x.4 : this driver support digital zoom;
-*v0.x.5 : this driver support test framerate and query framerate from board file configuration;
-*v0.x.6 : this driver improve test framerate method;
-*v0.x.7 : digital zoom use the ipp to do scale and crop , otherwise ipp just do the scale. Something wrong with digital zoom if
-          we do crop with cif and do scale with ipp , we will fix this  next version.
-*v0.x.8 : temp version,reinit capture list when setup video buf.
-*v0.x.9 : 1. add the case of IPP unsupportted ,just cropped by CIF(not do the scale) this version. 
-          2. flush workqueue when releas buffer
-*v0.x.a: 1. reset cif and wake up vb when cif have't receive data in a fixed time(now setted as 2 secs) so that app can
-             be quitted
-          2. when the flash is on ,flash off in a fixed time to prevent from flash light too hot.
-          3. when front and back camera are the same sensor,and one has the flash ,other is not,flash can't work corrrectly ,fix it
-          4. add  menu configs for convineuent to customize sensor series
-*v0.x.b:  specify the version is  NOT sure stable.
-*v0.x.c:  1. add cif reset when resolution changed to avoid of collecting data erro
-          2. irq process is splitted to two step.
-*v0.x.e: fix bugs of early suspend when display_pd is closed. 
-*v0.x.f: fix calculate ipp memory size is enough or not in try_fmt function; 
-*v0.x.11: fix struct rk_camera_work may be reentrant
-*v0.x.13: 1.add scale by arm,rga and pp.
-          2.CIF do the crop when digital zoom.
-		  3.fix bug in prob func:request mem twice. 
-		  4.video_vq may be null when reinit work,fix it
-		  5.arm scale algorithm has something wrong(may exceed the bound of width or height) ,fix it.
-*v0.x.15: 
-*         1. support rk3066b;
-*v0.x.17: 
-*         1. support 8Mega picture;
-*v0.x.19:
-*         1. invalidate the limit which scale is invalidat when scale ratio > 2;
-*v0.x.1b: 1. fix oops bug  when using arm to do scale_crop if preview buffer is not allocated correctly 
-          2. rk_camera_set_fmt will called twice, optimize the procedure. at the first time call ,just to do the sensor init.
-
-*v0.x.1c:
-*         1. fix query resolution error;
-*v0.x.1d: 
-*         1. add mv9335+ov5650 driver;
-*         2. fix 2928 digitzoom erro(arm crop scale) of selected zone;
-*v0.x.1f:
-*         1. support rk3188; Must soft reset cif controller after each frame irq;
-*v0.2.21:
-*         1. fix ctrl register capture bit may be turn on in rk_videobuf_capture function
-*
-*v0.3.1 :
-*         1. compatible with generic_sensor;
-*
-*v0.3.3 / v0.3.5:
-*         1. fix use v4l2_mbus_framefmt.reserved array overflow in generic_sensor_s_fmt; 
-*
-*v0.3.7:
-*         1. support rk3028 , read 3028 chip id by efuse for check cif controller is normal or not; 
-*v0.3.9:
-*         1. return real sensor output size in rk_camera_enum_frameintervals;
-*         2. wake up vb after add camera work to list in rk_camera_capture_process;
-*v0.3.b:  
-*         1. this verison is support for 3188M, the version has been revert in v0.3.d;
-*v0.3.d:
-*         1. this version is support for rk3028a;
-*
-*v0.3.f:  
-*         1. this version is support query fov orientation; 
-*v0.3.0x11:
-*         1. fix vb struct may be used again which have been free after stream off, some code modify in soc_camera.c,
-*            version is v0.1.1;
-*         1. fix cif clk out can't be turn off;
-*
-*v0.3.0x12:
-*         1. modify cif irq ,remove judge reg_lastpixel==host_width. 
-* 
-*/
 
-#define RK_CAM_VERSION_CODE KERNEL_VERSION(0, 3, 0x12)
+
+#define RK_CAM_VERSION_CODE KERNEL_VERSION(0, 3, 0x15)
 static int version = RK_CAM_VERSION_CODE;
 module_param(version, int, S_IRUGO);
 
 /* limit to rk29 hardware capabilities */
-#define RK_CAM_BUS_PARAM   (SOCAM_MASTER |\
-                SOCAM_HSYNC_ACTIVE_HIGH |\
-                SOCAM_HSYNC_ACTIVE_LOW |\
-                SOCAM_VSYNC_ACTIVE_HIGH |\
-                SOCAM_VSYNC_ACTIVE_LOW |\
-                SOCAM_PCLK_SAMPLE_RISING |\
-                SOCAM_PCLK_SAMPLE_FALLING|\
-                SOCAM_DATA_ACTIVE_HIGH |\
-                SOCAM_DATA_ACTIVE_LOW|\
+#define RK_CAM_BUS_PARAM   (V4L2_MBUS_MASTER |\
+                V4L2_MBUS_HSYNC_ACTIVE_HIGH |\
+                V4L2_MBUS_HSYNC_ACTIVE_LOW |\
+                V4L2_MBUS_VSYNC_ACTIVE_HIGH |\
+                V4L2_MBUS_VSYNC_ACTIVE_LOW |\
+                V4L2_MBUS_PCLK_SAMPLE_RISING |\
+                V4L2_MBUS_PCLK_SAMPLE_FALLING|\
+                V4L2_MBUS_DATA_ACTIVE_HIGH |\
+                V4L2_MBUS_DATA_ACTIVE_LOW|\
                 SOCAM_DATAWIDTH_8|SOCAM_DATAWIDTH_10|\
                 SOCAM_MCLK_24MHZ |SOCAM_MCLK_48MHZ)
 
@@ -541,12 +467,16 @@ static const char *rk_cam_driver_description = "RK_Camera";
 
 static int rk_camera_s_stream(struct soc_camera_device *icd, int enable);
 static void rk_camera_capture_process(struct work_struct *work);
-static int rk_camera_scale_crop_arm(struct work_struct *work);
+//static int rk_camera_scale_crop_arm(struct work_struct *work);
 
 static void rk_camera_cif_reset(struct rk_camera_dev *pcdev, int only_rst)
 {
-    int ctrl_reg,inten_reg,crop_reg,set_size_reg,for_reg,vir_line_width_reg,scl_reg;
-    enum cru_soft_reset cif_reset_index = SOFT_RST_CIF0;
+/*************yzm**************
+    int ctrl_reg,inten_reg,crop_reg,set_size_reg,for_reg,vir_line_width_reg,scl_reg,y_reg,uv_reg;
+    enum rk3288_cru_soft_reset cif_reset_index = SOFT_RST_CIF0;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
 
     if (IS_CIF0() == false) { 
 #if RK_SUPPORT_CIF1
@@ -558,21 +488,26 @@ static void rk_camera_cif_reset(struct rk_camera_dev *pcdev, int only_rst)
     }
 
     if (only_rst == true) {
-        cru_set_soft_reset(cif_reset_index, true);
+        rk3288_cru_set_soft_reset(cif_reset_index, true);
         udelay(5);
-        cru_set_soft_reset(cif_reset_index, false);
+        rk3288_cru_set_soft_reset(cif_reset_index, false);
     } else {
         ctrl_reg = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
+        if (ctrl_reg & ENABLE_CAPTURE) {
+            write_cif_reg(pcdev->base,CIF_CIF_CTRL, ctrl_reg&~ENABLE_CAPTURE);
+        }
     	crop_reg = read_cif_reg(pcdev->base,CIF_CIF_CROP);
     	set_size_reg = read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE);
     	inten_reg = read_cif_reg(pcdev->base,CIF_CIF_INTEN);
     	for_reg = read_cif_reg(pcdev->base,CIF_CIF_FOR);
     	vir_line_width_reg = read_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH);
     	scl_reg = read_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL);
+    	y_reg = read_cif_reg(pcdev->base, CIF_CIF_FRM0_ADDR_Y);
+    	uv_reg = read_cif_reg(pcdev->base, CIF_CIF_FRM0_ADDR_UV);
     	
-    	cru_set_soft_reset(cif_reset_index, true);
+    	rk3288_cru_set_soft_reset(cif_reset_index, true);
     	udelay(5);
-    	cru_set_soft_reset(cif_reset_index, false); 
+    	rk3288_cru_set_soft_reset(cif_reset_index, false); 
 
         write_cif_reg(pcdev->base,CIF_CIF_CTRL, ctrl_reg&~ENABLE_CAPTURE);
 	    write_cif_reg(pcdev->base,CIF_CIF_INTEN, inten_reg);
@@ -581,7 +516,10 @@ static void rk_camera_cif_reset(struct rk_camera_dev *pcdev, int only_rst)
 	    write_cif_reg(pcdev->base,CIF_CIF_FOR, for_reg);
 	    write_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH,vir_line_width_reg);
 	    write_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL,scl_reg);
+	    write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y,y_reg);      / *ddl@rock-chips.com v0.3.0x13
+	    write_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV,uv_reg);
     }
+ *///***********yzm*************end
     return;
 }
 
@@ -593,7 +531,8 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
                                unsigned int *size)
 {
     struct soc_camera_device *icd = vq->priv_data;
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	//struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
 	unsigned int i;
     struct rk_camera_work *wk;
@@ -603,6 +542,9 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 	int bytes_per_line_host;
 	fmt.packing = SOC_MBUS_PACKING_1_5X8;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 		bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,
 						icd->current_fmt->host_fmt);
 	if(icd->current_fmt->host_fmt->fourcc ==  V4L2_PIX_FMT_RGB565)
@@ -613,7 +555,7 @@ static int rk_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,
 	else
 		bytes_per_line_host = soc_mbus_bytes_per_line(pcdev->host_width,
 					   icd->current_fmt->host_fmt);
-    dev_dbg(&icd->dev, "count=%d, size=%d\n", *count, *size);
+   // dev_dbg(&icd->dev, "count=%d, size=%d\n", *count, *size);//yzm
 
 	if (bytes_per_line_host < 0)
 		return bytes_per_line_host;
@@ -679,7 +621,10 @@ static void rk_videobuf_free(struct videobuf_queue *vq, struct rk_camera_buffer
 {
     struct soc_camera_device *icd = vq->priv_data;
 
-    dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
+    dev_dbg(icd->control, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,//yzm
             &buf->vb, buf->vb.baddr, buf->vb.bsize);
 
 	/* ddl@rock-chips.com: buf_release called soc_camera_streamoff and soc_camera_close*/
@@ -694,7 +639,7 @@ static void rk_videobuf_free(struct videobuf_queue *vq, struct rk_camera_buffer
 	 */
 	videobuf_waiton(vq, &buf->vb, 0, 0);
     videobuf_dma_contig_free(vq, &buf->vb);
-    dev_dbg(&icd->dev, "%s freed\n", __func__);
+    //dev_dbg(&icd->dev, "%s freed\n", __func__);//yzm
     buf->vb.state = VIDEOBUF_NEEDS_INIT;
 	return;
 }
@@ -705,13 +650,17 @@ static int rk_videobuf_prepare(struct videobuf_queue *vq, struct videobuf_buffer
     int ret;
     int bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,
 						icd->current_fmt->host_fmt);
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+	//dump_stack();
+	
 	if ((bytes_per_line < 0) || (vb->boff == 0))
 		return -EINVAL;
 
     buf = container_of(vb, struct rk_camera_buffer, vb);
 
-    dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,
-            vb, vb->baddr, vb->bsize);
+    //dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,//yzm
+      //      vb, vb->baddr, vb->bsize);//yzm
     
     /* Added list head initialization on alloc */
     WARN_ON(!list_empty(&vb->queue));    
@@ -755,6 +704,9 @@ static inline void rk_videobuf_capture(struct videobuf_buffer *vb,struct rk_came
 	unsigned int y_addr,uv_addr;
 	struct rk_camera_dev *pcdev = rk_pcdev;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
     if (vb) {
 		if (CAM_WORKQUEUE_IS_EN()) {
 			y_addr = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
@@ -783,14 +735,18 @@ static void rk_videobuf_queue(struct videobuf_queue *vq,
                                 struct videobuf_buffer *vb)
 {
     struct soc_camera_device *icd = vq->priv_data;
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+    //struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
 #if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vb_info;
 #endif
 
-    dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,
-            vb, vb->baddr, vb->bsize);
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    //dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %zd\n", __func__,//yzm
+      //      vb, vb->baddr, vb->bsize);//yzm
 
     vb->state = VIDEOBUF_QUEUED;
 	if (list_empty(&pcdev->capture)) {
@@ -829,37 +785,18 @@ static void rk_videobuf_queue(struct videobuf_queue *vq,
     if (!pcdev->active) {
         pcdev->active = vb;
         rk_videobuf_capture(vb,pcdev);
+        if (atomic_read(&pcdev->stop_cif) == false) {           /*ddl@rock-chips.com v0.3.0x13*/
+            write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL) | ENABLE_CAPTURE));
+        }       
     }
 }
-#if (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_IPP)
-static int rk_pixfmt2ippfmt(unsigned int pixfmt, int *ippfmt)
-{
-	switch (pixfmt)
-	{
-		case V4L2_PIX_FMT_NV16:
-		case V4L2_PIX_FMT_NV61:
-		{
-			*ippfmt = IPP_Y_CBCR_H2V1;
-			break;
-		}
-		case V4L2_PIX_FMT_NV12:
-		case V4L2_PIX_FMT_NV21:
-		{
-			*ippfmt = IPP_Y_CBCR_H2V2;
-			break;
-		}
-		default:
-			goto rk_pixfmt2ippfmt_err;
-	}
 
-	return 0;
-rk_pixfmt2ippfmt_err:
-	return -1;
-}
-#endif
 #if (CONFIG_CAMERA_SCALE_CROP_MACHINE == RK_CAM_SCALE_CROP_RGA)
 static int rk_pixfmt2rgafmt(unsigned int pixfmt, int *ippfmt)
 {
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
 	switch (pixfmt)
 	{
 		case V4L2_PIX_FMT_YUV420:
@@ -904,33 +841,8 @@ static int rk_camera_scale_crop_pp(struct work_struct *work){
 	unsigned long int flags;
 	int scale_times,w,h;
 	int src_y_offset;
-	PP_OP_HANDLE hnd;
-	PP_OPERATION init;
 	int ret = 0;
-	vipdata_base = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
-	
-	memset(&init, 0, sizeof(init));
-	init.srcAddr 	= vipdata_base;
-	init.srcFormat	= PP_IN_FORMAT_YUV420SEMI;
-	init.srcWidth	= init.srcHStride = pcdev->zoominfo.vir_width;
-	init.srcHeight	= init.srcVStride = pcdev->zoominfo.vir_height;
-	
-	init.dstAddr 	= vb->boff;
-	init.dstFormat	= PP_OUT_FORMAT_YUV420INTERLAVE;
-	init.dstWidth	= init.dstHStride = pcdev->icd->user_width;
-	init.dstHeight	= init.dstVStride = pcdev->icd->user_height;
-
-	printk("srcWidth = %d,srcHeight = %d,dstWidth = %d,dstHeight = %d\n",init.srcWidth,init.srcHeight,init.dstWidth,init.dstHeight);
-	#if 0
-	ret = ppOpInit(&hnd, &init);
-	if (!ret) {
-		ppOpPerform(hnd);
-		ppOpSync(hnd);
-		ppOpRelease(hnd);
-	} else {
-		printk("can not create ppOp handle\n");
-	}
-	#endif
+
 	return ret;
 }
 #endif
@@ -951,106 +863,8 @@ static int rk_camera_scale_crop_rga(struct work_struct *work){
 	int rga_times = 3;
 	const struct soc_mbus_pixelfmt *fmt;
 	int ret = 0;
-	fmt = soc_mbus_get_fmtdesc(pcdev->icd->current_fmt->code);
-	vipdata_base = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
-	if((pcdev->icd->current_fmt->host_fmt->fourcc != V4L2_PIX_FMT_RGB565)
-		&& (pcdev->icd->current_fmt->host_fmt->fourcc != V4L2_PIX_FMT_RGB24)){
-		RKCAMERA_TR("RGA not support this format !\n");
-		goto do_ipp_err;
-		}
-	if ((pcdev->icd->user_width > 0x800) || (pcdev->icd->user_height > 0x800)) {
-		scale_times = MAX((pcdev->icd->user_width/0x800),(pcdev->icd->user_height/0x800));		  
-		scale_times++;
-	} else {
-		scale_times = 1;
-	}
-	session.pid = current->pid;
-	INIT_LIST_HEAD(&session.waiting);
-	INIT_LIST_HEAD(&session.running);
-	INIT_LIST_HEAD(&session.list_session);
-	init_waitqueue_head(&session.wait);
-	/* no need to protect */
-	list_add_tail(&session.list_session, &rga_service.session);
-	atomic_set(&session.task_running, 0);
-	atomic_set(&session.num_done, 0);
-	
-	memset(&req,0,sizeof(struct rga_req));
-	req.src.act_w = pcdev->zoominfo.a.c.width/scale_times;
-	req.src.act_h = pcdev->zoominfo.a.c.height/scale_times;
-
-	req.src.vir_w = pcdev->zoominfo.vir_width;
-	req.src.vir_h =pcdev->zoominfo.vir_height;
-	req.src.yrgb_addr = vipdata_base;
-	req.src.uv_addr =vipdata_base + pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;;
-	req.src.v_addr = req.src.uv_addr ;
-	req.src.format =fmt->fourcc;
-	rk_pixfmt2rgafmt(fmt->fourcc,&req.src.format);
-	req.src.x_offset = pcdev->zoominfo.a.c.left;
-	req.src.y_offset = pcdev->zoominfo.a.c.top;
-
-	req.dst.act_w = pcdev->icd->user_width/scale_times;
-	req.dst.act_h = pcdev->icd->user_height/scale_times;
-
-	req.dst.vir_w = pcdev->icd->user_width;
-	req.dst.vir_h = pcdev->icd->user_height;
-	req.dst.x_offset = 0;
-	req.dst.y_offset = 0;
-	req.dst.yrgb_addr = vb->boff;
-	rk_pixfmt2rgafmt(pcdev->icd->current_fmt->host_fmt->fourcc,&req.dst.format);
-	req.clip.xmin = 0;
-	req.clip.xmax = req.dst.vir_w-1;
-	req.clip.ymin = 0;
-	req.clip.ymax = req.dst.vir_h -1;
-
-	req.rotate_mode = 1;
-	req.scale_mode = 2;
-
-	req.sina = 0;
-	req.cosa = 65536;
-	req.mmu_info.mmu_en = 0;
-
-	for (h=0; h<scale_times; h++) {
-		for (w=0; w<scale_times; w++) {
-			rga_times = 3;
-	
-			req.src.yrgb_addr = vipdata_base;
-			req.src.uv_addr =vipdata_base + pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;;
-			req.src.x_offset = pcdev->zoominfo.a.c.left+w*pcdev->zoominfo.a.c.width/scale_times;
-			req.src.y_offset = pcdev->zoominfo.a.c.top+h*pcdev->zoominfo.a.c.height/scale_times;
-			req.dst.x_offset =  pcdev->icd->user_width*w/scale_times;
-			req.dst.y_offset = pcdev->icd->user_height*h/scale_times;
-			req.dst.yrgb_addr = vb->boff ;
-		//	RKCAMERA_TR("src.act_w = %d , src.act_h  = %d! vir_w = %d , vir_h = %d,off_x = %d,off_y = %d\n",req.src.act_w,req.src.act_h ,req.src.vir_w,req.src.vir_h,req.src.x_offset,req.src.y_offset);
-		//	RKCAMERA_TR("dst.act_w = %d , dst.act_h  = %d! vir_w = %d , vir_h = %d,off_x = %d,off_y = %d\n",req.dst.act_w,req.dst.act_h ,req.dst.vir_w,req.dst.vir_h,req.dst.x_offset,req.dst.y_offset);
-		//	RKCAMERA_TR("req.src.yrgb_addr = 0x%x,req.dst.yrgb_addr = 0x%x\n",req.src.yrgb_addr,req.dst.yrgb_addr);
-
-			while(rga_times-- > 0) {
-				if (rga_blit_sync(&session, &req)){
-					RKCAMERA_TR("rga do erro,do again,rga_times = %d!\n",rga_times);
-				 } else {
-					break;
-				 }
-			}
-		
-			if (rga_times <= 0) {
-				spin_lock_irqsave(&pcdev->lock, flags);
-				vb->state = VIDEOBUF_NEEDS_INIT;
-				spin_unlock_irqrestore(&pcdev->lock, flags);
-				mutex_lock(&rga_service.lock);
-				list_del(&session.list_session);
-				rga_service_session_clear(&session);
-				mutex_unlock(&rga_service.lock);
-				goto session_done;
-			}
-			}
-	}
-	session_done:
-	mutex_lock(&rga_service.lock);
-	list_del(&session.list_session);
-	rga_service_session_clear(&session);
-	mutex_unlock(&rga_service.lock);
 
-	do_ipp_err:
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
 
 		return ret;
 	
@@ -1061,211 +875,10 @@ static int rk_camera_scale_crop_rga(struct work_struct *work){
 
 static int rk_camera_scale_crop_ipp(struct work_struct *work)
 {
-	struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);
-	struct videobuf_buffer *vb = camera_work->vb;
-	struct rk_camera_dev *pcdev = camera_work->pcdev;
-	int vipdata_base;
-	unsigned long int flags;
-
-	struct rk29_ipp_req ipp_req;
-	int src_y_offset,src_uv_offset,dst_y_offset,dst_uv_offset,src_y_size,dst_y_size;
-	int scale_times,w,h;
-	int ret = 0, scale_crop_ret=0;
-
-    /*
-    *ddl@rock-chips.com: 
-    * IPP Dest image resolution is 2047x1088, so scale operation break up some times
-    */
-    if ((pcdev->icd->user_width > 0x7f0) || (pcdev->icd->user_height > 0x430)) {
-        scale_times = MAX((pcdev->icd->user_width/0x7f0),(pcdev->icd->user_height/0x430));        
-        scale_times++;
-    } else {
-        scale_times = 1;
-    }
-    memset(&ipp_req, 0, sizeof(struct rk29_ipp_req));
-
-
-    ipp_req.timeout = 3000;
-    ipp_req.flag = IPP_ROT_0; 
-    ipp_req.store_clip_mode =1;
-    ipp_req.src0.w = pcdev->zoominfo.a.c.width/scale_times;
-    ipp_req.src0.h = pcdev->zoominfo.a.c.height/scale_times;
-    ipp_req.src_vir_w = pcdev->zoominfo.vir_width; 
-    rk_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.src0.fmt);
-    ipp_req.dst0.w = pcdev->icd->user_width/scale_times;
-    ipp_req.dst0.h = pcdev->icd->user_height/scale_times;
-    ipp_req.dst_vir_w = pcdev->icd->user_width;        
-    rk_pixfmt2ippfmt(pcdev->pixfmt, &ipp_req.dst0.fmt);    
-    vipdata_base = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;
-    src_y_size = pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;  //vipmem
-    dst_y_size = pcdev->icd->user_width*pcdev->icd->user_height;
-    for (h=0; h<scale_times; h++) {
-        for (w=0; w<scale_times; w++) {
-            src_y_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->zoominfo.vir_width 
-                        + pcdev->zoominfo.a.c.left + w*pcdev->zoominfo.a.c.width/scale_times;
-		    src_uv_offset = (pcdev->zoominfo.a.c.top + h*pcdev->zoominfo.a.c.height/scale_times)* pcdev->zoominfo.vir_width/2
-                        + pcdev->zoominfo.a.c.left + w*pcdev->zoominfo.a.c.width/scale_times;
-
-            dst_y_offset = pcdev->icd->user_width*pcdev->icd->user_height*h/scale_times + pcdev->icd->user_width*w/scale_times;
-            dst_uv_offset = pcdev->icd->user_width*pcdev->icd->user_height*h/scale_times/2 + pcdev->icd->user_width*w/scale_times;
-
-    		ipp_req.src0.YrgbMst = vipdata_base + src_y_offset;
-    		ipp_req.src0.CbrMst = vipdata_base + src_y_size + src_uv_offset;
-    		ipp_req.dst0.YrgbMst = vb->boff + dst_y_offset;
-    		ipp_req.dst0.CbrMst = vb->boff + dst_y_size + dst_uv_offset;
-    		
-            if (ipp_blit_sync(&ipp_req)){
-                RKCAMERA_TR("ipp do erro, so switch to arm \n");
-                scale_crop_ret = 0x01;
-                break;
-            }
-        }
-    }
-
-    if (scale_crop_ret == 0x01) {
-        ret = rk_camera_scale_crop_arm(work);
-    }
-
-    if (ret) {
-        spin_lock_irqsave(&pcdev->lock, flags);
-		vb->state = VIDEOBUF_NEEDS_INIT;
-		spin_unlock_irqrestore(&pcdev->lock, flags);
-		RKCAMERA_TR("Capture image(vb->i:0x%x) which IPP and ARM operated is error:\n",vb->i);
-		RKCAMERA_TR("widx:%d hidx:%d ",w,h);
-		RKCAMERA_TR("%dx%d@(%d,%d)->%dx%d\n",pcdev->zoominfo.a.c.width,pcdev->zoominfo.a.c.height,pcdev->zoominfo.a.c.left,pcdev->zoominfo.a.c.top,pcdev->icd->user_width,pcdev->icd->user_height);
-		RKCAMERA_TR("ipp_req.src0.YrgbMst:0x%x ipp_req.src0.CbrMst:0x%x \n", ipp_req.src0.YrgbMst,ipp_req.src0.CbrMst);
-		RKCAMERA_TR("ipp_req.src0.w:0x%x ipp_req.src0.h:0x%x \n",ipp_req.src0.w,ipp_req.src0.h);
-		RKCAMERA_TR("ipp_req.src0.fmt:0x%x\n",ipp_req.src0.fmt);
-		RKCAMERA_TR("ipp_req.dst0.YrgbMst:0x%x ipp_req.dst0.CbrMst:0x%x \n",ipp_req.dst0.YrgbMst,ipp_req.dst0.CbrMst);
-		RKCAMERA_TR("ipp_req.dst0.w:0x%x ipp_req.dst0.h:0x%x \n",ipp_req.dst0.w ,ipp_req.dst0.h);
-		RKCAMERA_TR("ipp_req.dst0.fmt:0x%x\n",ipp_req.dst0.fmt);
-		RKCAMERA_TR("ipp_req.src_vir_w:0x%x ipp_req.dst_vir_w :0x%x\n",ipp_req.src_vir_w ,ipp_req.dst_vir_w);
-		RKCAMERA_TR("ipp_req.timeout:0x%x ipp_req.flag :0x%x\n",ipp_req.timeout,ipp_req.flag);
-    }
-    
-	return ret;    
+   
+	return 0;    
 }
 #endif
-static int rk_camera_scale_crop_arm(struct work_struct *work)
-{
-    struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);	
-    struct videobuf_buffer *vb = camera_work->vb;	
-    struct rk_camera_dev *pcdev = camera_work->pcdev;	
-    struct rk29_camera_vbinfo *vb_info;        
-    unsigned char *psY,*pdY,*psUV,*pdUV; 
-    unsigned char *src,*dst;
-    unsigned long src_phy,dst_phy;
-    int srcW,srcH,cropW,cropH,dstW,dstH;
-    long zoomindstxIntInv,zoomindstyIntInv;
-    long x,y;
-    long yCoeff00,yCoeff01,xCoeff00,xCoeff01;
-    long sX,sY;
-    long r0,r1,a,b,c,d;
-    int ret = 0, shift_bits = 0;
-
-    src_phy = pcdev->vipmem_phybase + vb->i*pcdev->vipmem_bsize;    
-    src = psY = (unsigned char*)(pcdev->vipmem_virbase + vb->i*pcdev->vipmem_bsize);
-    psUV = psY + pcdev->zoominfo.vir_width*pcdev->zoominfo.vir_height;
-	
-    srcW = pcdev->zoominfo.vir_width;
-    srcH = pcdev->zoominfo.vir_height;
-    cropW = pcdev->zoominfo.a.c.width;
-    cropH = pcdev->zoominfo.a.c.height;
-	
-    psY = psY + pcdev->zoominfo.a.c.top*pcdev->zoominfo.vir_width+pcdev->zoominfo.a.c.left;
-    psUV = psUV + pcdev->zoominfo.a.c.top*pcdev->zoominfo.vir_width/2+pcdev->zoominfo.a.c.left; 
-    
-    vb_info = pcdev->vbinfo+vb->i; 
-    dst_phy = vb_info->phy_addr;
-    dst = pdY = (unsigned char*)vb_info->vir_addr; 
-    pdUV = pdY + pcdev->icd->user_width*pcdev->icd->user_height;
-    dstW = pcdev->icd->user_width;
-    dstH = pcdev->icd->user_height;
-
-    zoomindstxIntInv = ((unsigned long)(cropW)<<16)/dstW + 1;
-    zoomindstyIntInv = ((unsigned long)(cropH)<<16)/dstH + 1;
-#ifdef CONFIG_SOC_RK3028
-	shift_bits = (pcdev->chip_id == 0x42)?0:2;
-#endif
-    //y
-    //for(y = 0; y<dstH - 1 ; y++ ) {   
-    for(y = 0; y<dstH; y++ ) {   
-        yCoeff00 = (y*zoomindstyIntInv)&0xffff;
-        yCoeff01 = 0xffff - yCoeff00; 
-        sY = (y*zoomindstyIntInv >> 16);
-        sY = (sY >= srcH - 1)? (srcH - 2) : sY;      
-        for(x = 0; x<dstW; x++ ) {
-            xCoeff00 = (x*zoomindstxIntInv)&0xffff;
-            xCoeff01 = 0xffff - xCoeff00; 	
-            sX = (x*zoomindstxIntInv >> 16);
-            sX = (sX >= srcW -1)?(srcW- 2) : sX;
-            a = (psY[sY*srcW + sX]<<shift_bits);
-            b = (psY[sY*srcW + sX + 1]<<shift_bits);
-            c = (psY[(sY+1)*srcW + sX]<<shift_bits);
-            d = (psY[(sY+1)*srcW + sX + 1]<<shift_bits);
-
-            r0 = (a * xCoeff01 + b * xCoeff00)>>16 ;
-            r1 = (c * xCoeff01 + d * xCoeff00)>>16 ;
-            r0 = (r0 * yCoeff01 + r1 * yCoeff00)>>16;
-
-            pdY[x] = r0;
-        }
-        pdY += dstW;
-    }
-
-    dstW /= 2;
-    dstH /= 2;
-    srcW /= 2;
-    srcH /= 2;
-
-    //UV
-    //for(y = 0; y<dstH - 1 ; y++ ) {
-    for(y = 0; y<dstH; y++ ) {
-        yCoeff00 = (y*zoomindstyIntInv)&0xffff;
-        yCoeff01 = 0xffff - yCoeff00; 
-        sY = (y*zoomindstyIntInv >> 16);
-        sY = (sY >= srcH -1)? (srcH - 2) : sY;      
-        for(x = 0; x<dstW; x++ ) {
-            xCoeff00 = (x*zoomindstxIntInv)&0xffff;
-            xCoeff01 = 0xffff - xCoeff00; 	
-            sX = (x*zoomindstxIntInv >> 16);
-            sX = (sX >= srcW -1)?(srcW- 2) : sX;
-            //U
-            a = (psUV[(sY*srcW + sX)*2]<<shift_bits);
-            b = (psUV[(sY*srcW + sX + 1)*2]<<shift_bits);
-            c = (psUV[((sY+1)*srcW + sX)*2]<<shift_bits);
-            d = (psUV[((sY+1)*srcW + sX + 1)*2]<<shift_bits);
-			
-
-            r0 = (a * xCoeff01 + b * xCoeff00)>>16 ;
-            r1 = (c * xCoeff01 + d * xCoeff00)>>16 ;
-            r0 = (r0 * yCoeff01 + r1 * yCoeff00)>>16;
-
-            pdUV[x*2] = r0;
-
-            //V
-            a = (psUV[(sY*srcW + sX)*2 + 1]<<shift_bits);
-            b = (psUV[(sY*srcW + sX + 1)*2 + 1]<<shift_bits);
-            c = (psUV[((sY+1)*srcW + sX)*2 + 1]<<shift_bits);
-            d = (psUV[((sY+1)*srcW + sX + 1)*2 + 1]<<shift_bits);
-			
-            r0 = (a * xCoeff01 + b * xCoeff00)>>16 ;
-            r1 = (c * xCoeff01 + d * xCoeff00)>>16 ;
-            r0 = (r0 * yCoeff01 + r1 * yCoeff00)>>16;
-
-            pdUV[x*2 + 1] = r0;
-        }
-        pdUV += dstW*2;
-    }
-    
-    dmac_flush_range((void*)src,(void*)(src+pcdev->vipmem_bsize));
-    outer_flush_range((phys_addr_t)src_phy,(phys_addr_t)(src_phy+pcdev->vipmem_bsize));
-    
-    dmac_flush_range((void*)dst,(void*)(dst+vb_info->size));
-    outer_flush_range((phys_addr_t)dst_phy,(phys_addr_t)(dst_phy+vb_info->size));
-
-	return ret;    
-}
 static void rk_camera_capture_process(struct work_struct *work)
 {
     struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);    
@@ -1275,6 +888,9 @@ static void rk_camera_capture_process(struct work_struct *work)
     unsigned long flags = 0;    
     int err = 0;    
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     if (atomic_read(&pcdev->stop_cif)==true) {
         err = -EINVAL;
         goto rk_camera_capture_process_end; 
@@ -1315,6 +931,9 @@ static void rk_camera_cifrest_delay(struct work_struct *work)
     struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);  
     struct rk_camera_dev *pcdev = camera_work->pcdev; 
     unsigned long flags = 0;   
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
     
     mdelay(1);
     rk_camera_cif_reset(pcdev,false);
@@ -1338,6 +957,9 @@ static inline irqreturn_t rk_camera_cifirq(int irq, void *data)
     struct rk_camera_work *wk;
     unsigned int reg_cifctrl,reg_lastpix,reg_lastline;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
     write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0x0200);  /* clear vip interrupte single  */
     
     reg_cifctrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
@@ -1381,9 +1003,12 @@ static inline irqreturn_t rk_camera_dmairq(int irq, void *data)
 	struct timeval tv;
     unsigned long reg_cifctrl;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     reg_cifctrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
     /* ddl@rock-chps.com : Current VIP is run in One Frame Mode, Frame 1 is validate */
-    if (read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS) & 0x01) {
+    if (read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS) & 0x01) {   //frame 0 ready yzm
         write_cif_reg(pcdev->base,CIF_CIF_INTSTAT,0x01);  /* clear vip interrupte single  */
 
         pcdev->irqinfo.dmairq_idx++;
@@ -1465,6 +1090,9 @@ static irqreturn_t rk_camera_irq(int irq, void *data)
     struct rk_camera_dev *pcdev = data;
     unsigned long reg_intstat;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
     spin_lock(&pcdev->lock);
 
     if(atomic_read(&pcdev->stop_cif) == true) {
@@ -1491,13 +1119,18 @@ static void rk_videobuf_release(struct videobuf_queue *vq,
 {
     struct rk_camera_buffer *buf = container_of(vb, struct rk_camera_buffer, vb);
     struct soc_camera_device *icd = vq->priv_data;
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+    //struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
 #if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vb_info =NULL;
 #endif
 
 #ifdef DEBUG
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     dev_dbg(&icd->dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,
             vb, vb->baddr, vb->bsize);
 
@@ -1547,9 +1180,13 @@ static struct videobuf_queue_ops rk_videobuf_ops =
 static void rk_camera_init_videobuf(struct videobuf_queue *q,
                                       struct soc_camera_device *icd)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+    //struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     /* We must pass NULL as dev pointer, then all pci_* dma operations
      * transform to normal dma_* ones. */
     videobuf_queue_dma_contig_init(q,
@@ -1566,7 +1203,10 @@ static int rk_camera_mclk_ctrl(int cif_idx, int on, int clk_rate)
     int err = 0,cif;    
     struct rk_cif_clk *clk;
     struct clk *cif_clk_out_div;
-    
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
     cif = cif_idx - RK29_CAM_PLATFORM_DEV_ID;
     if ((cif<0)||(cif>1)) {
         RKCAMERA_TR(KERN_ERR "cif index(%d) is invalidate\n",cif_idx);
@@ -1584,19 +1224,19 @@ static int rk_camera_mclk_ctrl(int cif_idx, int on, int clk_rate)
    
     spin_lock(&clk->lock);
     if (on && !clk->on) {        
-        clk_enable(clk->pd_cif);
-        clk_enable(clk->aclk_cif);
-    	clk_enable(clk->hclk_cif);
-    	clk_enable(clk->cif_clk_in);
-    	clk_enable(clk->cif_clk_out);
+        clk_prepare_enable(clk->pd_cif);    //yzm
+        clk_prepare_enable(clk->aclk_cif);
+    	clk_prepare_enable(clk->hclk_cif);
+    	clk_prepare_enable(clk->cif_clk_in);
+    	clk_prepare_enable(clk->cif_clk_out);
         clk_set_rate(clk->cif_clk_out,clk_rate);
         clk->on = true;
     } else if (!on && clk->on) {
-        clk_disable(clk->aclk_cif);
-    	clk_disable(clk->hclk_cif);
-    	clk_disable(clk->cif_clk_in);
-    	clk_disable(clk->cif_clk_out);
-    	clk_disable(clk->pd_cif);
+        clk_disable_unprepare(clk->aclk_cif);
+    	clk_disable_unprepare(clk->hclk_cif);
+    	clk_disable_unprepare(clk->cif_clk_in);
+    	clk_disable_unprepare(clk->cif_clk_out);
+    	clk_disable_unprepare(clk->pd_cif);
         clk->on = false;
         if(cif){
             cif_clk_out_div =  clk_get(NULL, "cif1_out_div");
@@ -1607,7 +1247,7 @@ static int rk_camera_mclk_ctrl(int cif_idx, int on, int clk_rate)
             }
         }
         
-        if(IS_ERR_OR_NULL(cif_clk_out_div)) {
+        if(!IS_ERR_OR_NULL(cif_clk_out_div)) {   /* ddl@rock-chips.com: v0.3.0x13 */ 
             err = clk_set_parent(clk->cif_clk_out, cif_clk_out_div);
             clk_put(cif_clk_out_div);
         } else {
@@ -1626,6 +1266,9 @@ static int rk_camera_activate(struct rk_camera_dev *pcdev, struct soc_camera_dev
     /*
     * ddl@rock-chips.com : Cif clk control in rk_sensor_power which in rk_camera.c
     */
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
     write_cif_reg(pcdev->base,CIF_CIF_CTRL,AXI_BURST_16|MODE_ONEFRAME|DISABLE_CAPTURE);   /* ddl@rock-chips.com : vip ahb burst 16 */
     write_cif_reg(pcdev->base,CIF_CIF_INTEN, 0x01);    //capture complete interrupt enable
     return 0;
@@ -1636,6 +1279,8 @@ static void rk_camera_deactivate(struct rk_camera_dev *pcdev)
     /*
     * ddl@rock-chips.com : Cif clk control in rk_sensor_power which in rk_camera.c
     */
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
     
     return;
 }
@@ -1644,8 +1289,9 @@ static void rk_camera_deactivate(struct rk_camera_dev *pcdev)
  * there can be only one camera on RK28 quick capture interface */
 static int rk_camera_add_device(struct soc_camera_device *icd)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-    struct rk_camera_dev *pcdev = ici->priv;
+   // struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
+    struct rk_camera_dev *pcdev = ici->priv;    //在rk_camra_prob中初始化
     struct device *control = to_soc_camera_control(icd);
     struct v4l2_subdev *sd;
     int ret,i,icd_catch;
@@ -1653,6 +1299,9 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
     struct v4l2_cropcap cropcap;
     struct v4l2_mbus_framefmt mf;
     const struct soc_camera_format_xlate *xlate = NULL;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
     
     mutex_lock(&camera_lock);
 
@@ -1679,7 +1328,7 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
     if (ret)
         goto ebusy;
     /* ddl@rock-chips.com : v4l2_subdev is not created when ici->ops->add called in soc_camera_probe  */
-    if (control) {
+    if (control) {		//open时TRUE， 内核启动加载时FALSE
         sd = dev_get_drvdata(control);
 		v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_IOREQUEST,(void*)pcdev->pdata);
         #if 0
@@ -1687,8 +1336,9 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
         if (ret)
             goto ebusy;
         #endif
+		//调用generic_sensor_ioctl
         v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_CB_REGISTER,(void*)(&pcdev->icd_cb));
-
+		//调用generic_sensor_cropcap
         if (v4l2_subdev_call(sd, video, cropcap, &cropcap) == 0) {
             memcpy(&pcdev->cropinfo.bounds ,&cropcap.bounds,sizeof(struct v4l2_rect));
         } else {
@@ -1706,6 +1356,8 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
             pcdev->cropinfo.bounds.height = mf.height;
         }
     }
+
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
     pcdev->icd = icd;
     pcdev->icd_init = 0;
     
@@ -1736,26 +1388,31 @@ static int rk_camera_add_device(struct soc_camera_device *icd)
 }
 static void rk_camera_remove_device(struct soc_camera_device *icd)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+    //struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
-	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+//	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
 #if CAMERA_VIDEOBUF_ARM_ACCESS    
     struct rk29_camera_vbinfo *vb_info;
     unsigned int i;
-#endif    
+#endif 
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
 
 	mutex_lock(&camera_lock);
     BUG_ON(icd != pcdev->icd);
 
     RKCAMERA_DG1("%s driver detached from %s\n",RK29_CAM_DRV_NAME,dev_name(icd->pdev));
-
-	/* ddl@rock-chips.com: Application will call VIDIOC_STREAMOFF before close device, but
+    
+    /* ddl@rock-chips.com: Application will call VIDIOC_STREAMOFF before close device, but
 	   stream may be turn on again before close device, if suspend and resume happened. */
-	if (read_cif_reg(pcdev->base,CIF_CIF_CTRL) & ENABLE_CAPTURE) {
+	//if (read_cif_reg(pcdev->base,CIF_CIF_CTRL) & ENABLE_CAPTURE) {
+	if ((atomic_read(&pcdev->stop_cif) == false) && pcdev->fps_timer.istarted) {       /* ddl@rock-chips.com: v0.3.0x15*/
 		rk_camera_s_stream(icd,0);
-	}    
-    
-    v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_DEACTIVATE,NULL);
+	} 
+	//将DEACTIVATE 移动到generic_sensor_s_power中
+    //v4l2_subdev_call(sd, core, ioctl, RK29_CAM_SUBDEV_DEACTIVATE,NULL);//yzm
     //if stream off is not been executed,timer is running.
     if(pcdev->fps_timer.istarted){
          hrtimer_cancel(&pcdev->fps_timer.timer);
@@ -1802,12 +1459,15 @@ static void rk_camera_remove_device(struct soc_camera_device *icd)
 }
 static int rk_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
 {
-    unsigned long bus_flags, camera_flags, common_flags;
-    unsigned int cif_for = 0;
+    unsigned long bus_flags, camera_flags, common_flags = 0;
+    //unsigned int cif_for = 0;
 	const struct soc_mbus_pixelfmt *fmt;
 	int ret = 0;
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
-	struct rk_camera_dev *pcdev = ici->priv;
+	//struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
+	//struct rk_camera_dev *pcdev = ici->priv;
+
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
 
 
 	fmt = soc_mbus_get_fmtdesc(icd->current_fmt->code);
@@ -1832,22 +1492,23 @@ static int rk_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
     	default:
     		return -EINVAL;
 	}
-    
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 	if (icd->ops->query_bus_param)
     	camera_flags = icd->ops->query_bus_param(icd);
 	else
 		camera_flags = 0;
 
+/**************yzm************
     common_flags = soc_camera_bus_param_compatible(camera_flags, bus_flags);
     if (!common_flags) {
         ret = -EINVAL;
         goto RK_CAMERA_SET_BUS_PARAM_END;
     }
-
+*///***************yzm************end
     ret = icd->ops->set_bus_param(icd, common_flags);
     if (ret < 0)
         goto RK_CAMERA_SET_BUS_PARAM_END;
-
+/*
     cif_for = read_cif_reg(pcdev->base,CIF_CIF_FOR);
     
     if (common_flags & SOCAM_PCLK_SAMPLE_FALLING) {
@@ -1863,22 +1524,22 @@ static int rk_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
 			write_cru_reg(CRU_PCLK_REG30, (read_cru_reg(CRU_PCLK_REG30) & 0xFFFEFFF) | DISABLE_INVERT_PCLK_CIF1);
         }
     }
-    if (common_flags & SOCAM_HSYNC_ACTIVE_LOW) {
+    if (common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW) {
         cif_for |= HSY_LOW_ACTIVE;
     } else {
 		cif_for &= ~HSY_LOW_ACTIVE;
     }
-    if (common_flags & SOCAM_VSYNC_ACTIVE_HIGH) {
+    if (common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) {
         cif_for |= VSY_HIGH_ACTIVE;
     } else {
 		cif_for &= ~VSY_HIGH_ACTIVE;
     }
 
-    /* ddl@rock-chips.com : Don't enable capture here, enable in stream_on */
+    // ddl@rock-chips.com : Don't enable capture here, enable in stream_on 
     //vip_ctrl_val |= ENABLE_CAPTURE;
     write_cif_reg(pcdev->base,CIF_CIF_FOR, cif_for);
     RKCAMERA_DG1("CIF_CIF_FOR: 0x%x \n",cif_for);
-
+*/
 RK_CAMERA_SET_BUS_PARAM_END:
 	if (ret)
     	RKCAMERA_TR("rk_camera_set_bus_param ret = %d \n", ret);
@@ -1887,12 +1548,15 @@ static int rk_camera_set_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
 
 static int rk_camera_try_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
 {
-    unsigned long bus_flags, camera_flags;
-    int ret;
+//    unsigned long bus_flags, camera_flags;
+//    int ret;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+/**********yzm***********
 
     bus_flags = RK_CAM_BUS_PARAM;
 	if (icd->ops->query_bus_param) {
-        camera_flags = icd->ops->query_bus_param(icd);
+        camera_flags = icd->ops->query_bus_param(icd);  //generic_sensor_query_bus_param()
 	} else {
 		camera_flags = 0;
 	}
@@ -1902,7 +1566,11 @@ static int rk_camera_try_bus_param(struct soc_camera_device *icd, __u32 pixfmt)
         dev_warn(icd->dev.parent,
 			 "Flags incompatible: camera %lx, host %lx\n",
 			 camera_flags, bus_flags);
+
     return ret;
+*///************yzm **************end
+	return 0;
+
 }
 
 static const struct soc_mbus_pixelfmt rk_camera_formats[] = {
@@ -1943,11 +1611,13 @@ static const struct soc_mbus_pixelfmt rk_camera_formats[] = {
 		.packing		= SOC_MBUS_PACKING_2X8_PADHI,
 		.order			= SOC_MBUS_ORDER_LE,
 	}
+
 };
 
 static void rk_camera_setup_format(struct soc_camera_device *icd, __u32 host_pixfmt, enum v4l2_mbus_pixelcode icd_code, struct v4l2_rect *rect)
 {
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	//struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
     unsigned int cif_fs = 0,cif_crop = 0;
     unsigned int cif_fmt_val = read_cif_reg(pcdev->base,CIF_CIF_FOR) | INPUT_MODE_YUV|YUV_INPUT_422|INPUT_420_ORDER_EVEN|OUTPUT_420_ORDER_EVEN;
@@ -1955,6 +1625,9 @@ static void rk_camera_setup_format(struct soc_camera_device *icd, __u32 host_pix
 	const struct soc_mbus_pixelfmt *fmt;
 	fmt = soc_mbus_get_fmtdesc(icd_code);
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 	if((host_pixfmt == V4L2_PIX_FMT_RGB565) || (host_pixfmt == V4L2_PIX_FMT_RGB24)){
 		if(fmt->fourcc == V4L2_PIX_FMT_NV12)
 			host_pixfmt = V4L2_PIX_FMT_NV12;
@@ -2044,12 +1717,16 @@ static int rk_camera_get_formats(struct soc_camera_device *icd, unsigned int idx
 				  struct soc_camera_format_xlate *xlate)
 {
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
-    struct device *dev = icd->dev.parent;
+    //struct device *dev = icd->dev.parent;
+	struct device *dev = icd->parent;//yzm
     int formats = 0, ret;
 	enum v4l2_mbus_pixelcode code;
 	const struct soc_mbus_pixelfmt *fmt;
 
-	ret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
+	ret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);  //调用generic_sensor_enum_fmt()
 	if (ret < 0)
 		/* No more formats */
 		return 0;
@@ -2137,6 +1814,9 @@ static int rk_camera_get_formats(struct soc_camera_device *icd, unsigned int idx
 
 static void rk_camera_put_formats(struct soc_camera_device *icd)
 {
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
 	return;
 }
 static int rk_camera_cropcap(struct soc_camera_device *icd, struct v4l2_cropcap *cropcap)
@@ -2144,6 +1824,8 @@ static int rk_camera_cropcap(struct soc_camera_device *icd, struct v4l2_cropcap
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     int ret=0;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
     ret = v4l2_subdev_call(sd, video, cropcap, cropcap);
     if (ret != 0)
         goto end;
@@ -2154,9 +1836,13 @@ static int rk_camera_cropcap(struct soc_camera_device *icd, struct v4l2_cropcap
 }
 static int rk_camera_get_crop(struct soc_camera_device *icd,struct v4l2_crop *crop)
 {
-    struct soc_camera_host *ici =to_soc_camera_host(icd->dev.parent);
+    //struct soc_camera_host *ici =to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     spin_lock(&pcdev->cropinfo.lock);
     memcpy(&crop->c,&pcdev->cropinfo.c,sizeof(struct v4l2_rect));
     spin_unlock(&pcdev->cropinfo.lock);
@@ -2164,11 +1850,14 @@ static int rk_camera_get_crop(struct soc_camera_device *icd,struct v4l2_crop *cr
     return 0;
 }
 static int rk_camera_set_crop(struct soc_camera_device *icd,
-			       struct v4l2_crop *crop)
+			       const struct v4l2_crop *crop)
 {
-    struct soc_camera_host *ici =to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     spin_lock(&pcdev->cropinfo.lock);
     memcpy(&pcdev->cropinfo.c,&crop->c,sizeof(struct v4l2_rect));
     spin_unlock(&pcdev->cropinfo.lock);
@@ -2178,6 +1867,9 @@ static bool rk_camera_fmt_capturechk(struct v4l2_format *f)
 {
     bool ret = false;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     if (f->fmt.pix.priv == 0xfefe5a5a) {
         ret = true;
     }   
@@ -2203,10 +1895,12 @@ static bool rk_camera_fmt_capturechk(struct v4l2_format *f)
 static int rk_camera_set_fmt(struct soc_camera_device *icd,
 			      struct v4l2_format *f)
 {
-    struct device *dev = icd->dev.parent;
+    //struct device *dev = icd->dev.parent;
+	struct device *dev = icd->parent;//yzm
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     const struct soc_camera_format_xlate *xlate = NULL;
-	struct soc_camera_host *ici =to_soc_camera_host(icd->dev.parent);
+	//struct soc_camera_host *ici =to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
     struct v4l2_pix_format *pix = &f->fmt.pix;
     struct v4l2_mbus_framefmt mf;
@@ -2214,7 +1908,10 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     int ret,usr_w,usr_h,sensor_w,sensor_h;
     int stream_on = 0;
     int ratio, bounds_aspect;
-    
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	
 	usr_w = pix->width;
 	usr_h = pix->height;
     
@@ -2228,9 +1925,9 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     
     /* ddl@rock-chips.com: sensor init code transmit in here after open */
     if (pcdev->icd_init == 0) {
-        v4l2_subdev_call(sd,core, init, 0); 
+        v4l2_subdev_call(sd,core, init, 0);  //调用generic_sensor_init()
         pcdev->icd_init = 1;
-        return 0;
+        return 0;							//直接退出!!!!!!!
     }
     stream_on = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
     if (stream_on & ENABLE_CAPTURE)
@@ -2244,7 +1941,7 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
     mf.reserved[0] = pix->priv;              /* ddl@rock-chips.com : v0.3.3 */
     mf.reserved[1] = 0;
 
-    ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
+    ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);  //generic_sensor_s_fmt
     if (mf.code != xlate->code)
 		return -EINVAL;    		
 
@@ -2439,14 +2136,15 @@ static int rk_camera_set_fmt(struct soc_camera_device *icd,
 static int rk_camera_try_fmt(struct soc_camera_device *icd,
                                    struct v4l2_format *f)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+    //struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
 	struct rk_camera_dev *pcdev = ici->priv;
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     const struct soc_camera_format_xlate *xlate;
     struct v4l2_pix_format *pix = &f->fmt.pix;
     __u32 pixfmt = pix->pixelformat;
     int ret,usr_w,usr_h,i;
-	bool is_capture = rk_camera_fmt_capturechk(f);
+	bool is_capture = rk_camera_fmt_capturechk(f);  //检测f是否符合已设定的分辨率
 	bool vipmem_is_overflow = false;
     struct v4l2_mbus_framefmt mf;
     int bytes_per_line_host;
@@ -2454,9 +2152,12 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
 	usr_w = pix->width;
 	usr_h = pix->height;
     
-    xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    xlate = soc_camera_xlate_by_fourcc(icd, pixfmt);  //检测像素格式
     if (!xlate) {
-        dev_err(icd->dev.parent, "Format (%c%c%c%c) not found\n", pixfmt & 0xFF, (pixfmt >> 8) & 0xFF,
+        //dev_err(icd->dev.parent, "Format (%c%c%c%c) not found\n", pixfmt & 0xFF, (pixfmt >> 8) & 0xFF,
+		dev_err(icd->parent, "Format (%c%c%c%c) not found\n", pixfmt & 0xFF, (pixfmt >> 8) & 0xFF,//yzm
 			(pixfmt >> 16) & 0xFF, (pixfmt >> 24) & 0xFF);
         ret = -EINVAL;
         RKCAMERA_TR("%s(version:%c%c%c) support format:\n",rk_cam_driver_description,(RK_CAM_VERSION_CODE&0xff0000)>>16,
@@ -2489,7 +2190,7 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
     if ((usr_w == 10000) && (usr_h == 10000)) {
         mf.reserved[6] = 0xfefe5a5a;
     }
-
+	//调用generic_sensor_try_fmt()
 	ret = v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);
 	if (ret < 0)
 		goto RK_CAMERA_TRY_FMT_END;
@@ -2541,7 +2242,8 @@ static int rk_camera_try_fmt(struct soc_camera_device *icd,
 		break;
 	default:
 		/* TODO: support interlaced at least in pass-through mode */
-		dev_err(icd->dev.parent, "Field type %d unsupported.\n",
+		//dev_err(icd->dev.parent, "Field type %d unsupported.\n",
+		dev_err(icd->parent, "Field type %d unsupported.\n",//yzm
 			mf.field);
 		goto RK_CAMERA_TRY_FMT_END;
 	}
@@ -2557,6 +2259,9 @@ static int rk_camera_reqbufs(struct soc_camera_device *icd,
 {
     int i;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     /* This is for locking debugging only. I removed spinlocks and now I
      * check whether .prepare is ever called on a linked buffer, or whether
      * a dma IRQ can occur for an in-work or unlinked buffer. Until now
@@ -2576,6 +2281,9 @@ static unsigned int rk_camera_poll(struct file *file, poll_table *pt)
     struct soc_camera_device *icd = file->private_data;
     struct rk_camera_buffer *buf;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
     buf = list_entry(icd->vb_vidq.stream.next, struct rk_camera_buffer,
                     vb.stream);
 
@@ -2591,6 +2299,9 @@ static unsigned int rk_camera_poll(struct file *file, poll_table *pt)
 *card:  sensor name _ facing _ device index - orientation _ fov horizontal _ fov vertical
 *           10          5           1            3              3                3         + 5 < 32           
 */
+
+//获取设备的capabilities，看看设备具体有什么功能
+//比如是否具有视频输入,或者音频输入输出等。
 static int rk_camera_querycap(struct soc_camera_host *ici,
                                 struct v4l2_capability *cap)
 {
@@ -2600,23 +2311,21 @@ static int rk_camera_querycap(struct soc_camera_host *ici,
     char fov[9];
     int i;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+
     strlcpy(cap->card, dev_name(pcdev->icd->pdev), 18);       
     memset(orientation,0x00,sizeof(orientation));
-    for (i=0; i<RK_CAM_NUM;i++) {
-        if ((pcdev->pdata->info[i].dev_name!=NULL) && (strcmp(dev_name(pcdev->icd->pdev), pcdev->pdata->info[i].dev_name) == 0)) {
-            sprintf(orientation,"-%d",pcdev->pdata->info[i].orientation);
-            sprintf(fov,"_50_50");
-        }
-    }
 
     i=0;
     new_camera = pcdev->pdata->register_dev_new;
-    while (strstr(new_camera->dev_name,"end")==NULL) {
+    //while (strstr(new_camera->dev_name,"end")==NULL) {
+    while(new_camera != NULL){
         if (strcmp(dev_name(pcdev->icd->pdev), new_camera->dev_name) == 0) {
             sprintf(orientation,"-%d",new_camera->orientation);
             sprintf(fov,"_%d_%d",new_camera->fov_h,new_camera->fov_v);
         }
-        new_camera++;
+        new_camera = new_camera->next_camera;
     }
     
     if (orientation[0] != '-') {
@@ -2632,17 +2341,21 @@ static int rk_camera_querycap(struct soc_camera_host *ici,
     strcat(cap->card,fov);                          /* ddl@rock-chips.com: v0.3.f */
     cap->version = RK_CAM_VERSION_CODE;
     cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 
     return 0;
 }
 static int rk_camera_suspend(struct soc_camera_device *icd, pm_message_t state)
 {
-    struct soc_camera_host *ici =
-                    to_soc_camera_host(icd->dev.parent);
+    //struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
 	struct v4l2_subdev *sd;
     int ret = 0;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 	mutex_lock(&camera_lock);
 	if ((pcdev->icd == icd) && (icd->ops->suspend)) {
 		rk_camera_s_stream(icd, 0);
@@ -2671,12 +2384,15 @@ static int rk_camera_suspend(struct soc_camera_device *icd, pm_message_t state)
 
 static int rk_camera_resume(struct soc_camera_device *icd)
 {
-    struct soc_camera_host *ici =
-                    to_soc_camera_host(icd->dev.parent);
+    //struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
 	struct v4l2_subdev *sd;
     int ret = 0;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 	mutex_lock(&camera_lock);
 	if ((pcdev->icd == icd) && (icd->ops->resume)) {
 		if (pcdev->reginfo_suspend.Inval == Reg_Validate) {
@@ -2715,32 +2431,70 @@ static void rk_camera_reinit_work(struct work_struct *work)
     struct v4l2_subdev *sd;
 	struct rk_camera_work *camera_work = container_of(work, struct rk_camera_work, work);
 	struct rk_camera_dev *pcdev = camera_work->pcdev;
-    struct soc_camera_link *tmp_soc_cam_link;
+    //struct soc_camera_link *tmp_soc_cam_link;
+    struct v4l2_mbus_framefmt mf;
     int index = 0;
 	unsigned long flags = 0;
+    int ctrl;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	
     if(pcdev->icd == NULL)
         return;
     sd = soc_camera_to_subdev(pcdev->icd);
-    tmp_soc_cam_link = to_soc_camera_link(pcdev->icd);
+    //tmp_soc_cam_desc = to_soc_camera_link(pcdev->icd);//yzm
 	//dump regs
 	{
-		RKCAMERA_TR("CIF_CIF_CTRL = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_CTRL));
-		RKCAMERA_TR("CIF_CIF_INTEN = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_INTEN));
-		RKCAMERA_TR("CIF_CIF_INTSTAT = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_INTSTAT));
-		RKCAMERA_TR("CIF_CIF_FOR = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_FOR));
-		RKCAMERA_TR("CIF_CIF_CROP = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_CROP));
-		RKCAMERA_TR("CIF_CIF_SET_SIZE = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE));
-		RKCAMERA_TR("CIF_CIF_SCL_CTRL = 0x%x\n",read_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL));
-		RKCAMERA_TR("CRU_PCLK_REG30 = 0X%x\n",read_cru_reg(CRU_PCLK_REG30));
-		RKCAMERA_TR("CIF_CIF_LAST_LINE = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_LINE));
+		RKCAMERA_TR("CIF_CIF_CTRL = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_CTRL));
+		RKCAMERA_TR("CIF_CIF_INTEN = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_INTEN));
+		RKCAMERA_TR("CIF_CIF_INTSTAT = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_INTSTAT));
+		RKCAMERA_TR("CIF_CIF_FOR = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_FOR));
+		RKCAMERA_TR("CIF_CIF_CROP = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_CROP));
+		RKCAMERA_TR("CIF_CIF_SET_SIZE = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_SET_SIZE));
+		RKCAMERA_TR("CIF_CIF_SCL_CTRL = 0x%lx\n",read_cif_reg(pcdev->base,CIF_CIF_SCL_CTRL));
+		RKCAMERA_TR("CRU_PCLK_REG30 = 0X%lx\n",read_cru_reg(CRU_PCLK_REG30));
+		RKCAMERA_TR("CIF_CIF_LAST_LINE = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_LINE));
 		
-		RKCAMERA_TR("CIF_CIF_LAST_PIX = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_PIX));
-		RKCAMERA_TR("CIF_CIF_VIR_LINE_WIDTH = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH));
-    	RKCAMERA_TR("CIF_CIF_LINE_NUM_ADDR = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_LINE_NUM_ADDR));
-    	RKCAMERA_TR("CIF_CIF_FRM0_ADDR_Y = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y));
-    	RKCAMERA_TR("CIF_CIF_FRM0_ADDR_UV = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV));
-    	RKCAMERA_TR("CIF_CIF_FRAME_STATUS = 0X%x\n",read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS));
+		RKCAMERA_TR("CIF_CIF_LAST_PIX = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_LAST_PIX));
+		RKCAMERA_TR("CIF_CIF_VIR_LINE_WIDTH = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_VIR_LINE_WIDTH));
+    	RKCAMERA_TR("CIF_CIF_LINE_NUM_ADDR = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_LINE_NUM_ADDR));
+    	RKCAMERA_TR("CIF_CIF_FRM0_ADDR_Y = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_Y));
+    	RKCAMERA_TR("CIF_CIF_FRM0_ADDR_UV = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_FRM0_ADDR_UV));
+    	RKCAMERA_TR("CIF_CIF_FRAME_STATUS = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_FRAME_STATUS));
+    	RKCAMERA_TR("CIF_CIF_SCL_VALID_NUM = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_SCL_VALID_NUM));
+    	RKCAMERA_TR("CIF_CIF_CUR_DST = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_CUR_DST));
+    	RKCAMERA_TR("CIF_CIF_LINE_NUM_ADDR = 0X%lx\n",read_cif_reg(pcdev->base,CIF_CIF_LINE_NUM_ADDR));
 	}
+	
+    ctrl = read_cif_reg(pcdev->base,CIF_CIF_CTRL);          /*ddl@rock-chips.com v0.3.0x13*/
+    if (pcdev->reinit_times == 1) {
+        if (ctrl & ENABLE_CAPTURE) {        
+            RKCAMERA_TR("Sensor data transfer may be error, so reset CIF and reinit sensor for resume!\n");
+            pcdev->irqinfo.cifirq_idx = pcdev->irqinfo.dmairq_idx;
+            rk_camera_cif_reset(pcdev,false);
+
+            
+            v4l2_subdev_call(sd,core, init, 0); 
+            
+            mf.width	= pcdev->icd_width;
+            mf.height	= pcdev->icd_height;
+            mf.field	= V4L2_FIELD_NONE;            
+            mf.code		= pcdev->icd->current_fmt->code;
+            mf.reserved[0] = 0x5a5afefe;              
+            mf.reserved[1] = 0;
+
+            v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
+            
+            write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)|ENABLE_CAPTURE));
+        } else if (pcdev->irqinfo.cifirq_idx != pcdev->irqinfo.dmairq_idx) { 
+            RKCAMERA_TR("CIF may be error, so reset cif for resume\n");
+            pcdev->irqinfo.cifirq_idx = pcdev->irqinfo.dmairq_idx;
+            rk_camera_cif_reset(pcdev,false);
+            write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)|ENABLE_CAPTURE));
+        }
+        return;
+    }
     
     atomic_set(&pcdev->stop_cif,true);
 	write_cif_reg(pcdev->base,CIF_CIF_CTRL, (read_cif_reg(pcdev->base,CIF_CIF_CTRL)&(~ENABLE_CAPTURE)));
@@ -2773,12 +2527,15 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
 	struct rk_camera_dev *pcdev = fps_timer->pcdev;
     int rec_flag,i;
    // static unsigned int last_fps = 0;
-    struct soc_camera_link *tmp_soc_cam_link;
-    tmp_soc_cam_link = to_soc_camera_link(pcdev->icd);
+    //struct soc_camera_link *tmp_soc_cam_link;//yzm
+    //tmp_soc_cam_link = to_soc_camera_link(pcdev->icd);//yzm
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
 
 	RKCAMERA_DG1("rk_camera_fps_func fps:0x%x\n",pcdev->fps);
 	if ((pcdev->fps < 1) || (pcdev->last_fps == pcdev->fps)) {
-		RKCAMERA_TR("Camera host haven't recevie data from sensor,Reinit sensor delay,last fps = %d,pcdev->fps = %d!\n",pcdev->last_fps,pcdev->fps);
+		RKCAMERA_TR("Camera host haven't recevie data from sensor,last fps = %d,pcdev->fps = %d,cif_irq: %ld,dma_irq: %ld!\n",
+		            pcdev->last_fps,pcdev->fps,pcdev->irqinfo.cifirq_idx, pcdev->irqinfo.dmairq_idx);
 		pcdev->camera_reinit_work.pcdev = pcdev;
 		//INIT_WORK(&(pcdev->camera_reinit_work.work), rk_camera_reinit_work);
         pcdev->reinit_times++;
@@ -2795,7 +2552,7 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
         fival_pre = fival_nxt;
         while (fival_nxt != NULL) {
 
-            RKCAMERA_DG1("%s %c%c%c%c %dx%d framerate : %d/%d\n", dev_name(&pcdev->icd->dev), 
+            RKCAMERA_DG1("%s %c%c%c%c %dx%d framerate : %d/%d\n", dev_name(pcdev->icd->control), //yzm
                 fival_nxt->fival.pixel_format & 0xFF, (fival_nxt->fival.pixel_format >> 8) & 0xFF,
 			    (fival_nxt->fival.pixel_format >> 16) & 0xFF, (fival_nxt->fival.pixel_format >> 24),
 			    fival_nxt->fival.width, fival_nxt->fival.height, fival_nxt->fival.discrete.denominator,
@@ -2842,6 +2599,10 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
             }
         }
 	}
+
+    if ((pcdev->last_fps != pcdev->fps) && (pcdev->reinit_times))             /*ddl@rock-chips.com v0.3.0x13*/
+        pcdev->reinit_times = 0;
+	
     pcdev->last_fps = pcdev->fps ;
     pcdev->fps_timer.timer.node.expires= ktime_add_us(pcdev->fps_timer.timer.node.expires, ktime_to_us(ktime_set(3, 0)));
     pcdev->fps_timer.timer._softexpires= ktime_add_us(pcdev->fps_timer.timer._softexpires, ktime_to_us(ktime_set(3, 0)));
@@ -2853,12 +2614,15 @@ static enum hrtimer_restart rk_camera_fps_func(struct hrtimer *timer)
 }
 static int rk_camera_s_stream(struct soc_camera_device *icd, int enable)
 {
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	//struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
     int cif_ctrl_val;
 	int ret;
 	unsigned long flags;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);	
+
 	WARN_ON(pcdev->icd != icd);
 
 	cif_ctrl_val = read_cif_reg(pcdev->base,CIF_CIF_CTRL);
@@ -2902,12 +2666,13 @@ static int rk_camera_s_stream(struct soc_camera_device *icd, int enable)
         pcdev->active = NULL;
         INIT_LIST_HEAD(&pcdev->capture);
     }
-	RKCAMERA_DG1("s_stream: enable : 0x%x , CIF_CIF_CTRL = 0x%x\n",enable,read_cif_reg(pcdev->base,CIF_CIF_CTRL));
+	RKCAMERA_DG1("s_stream: enable : 0x%x , CIF_CIF_CTRL = 0x%lx\n",enable,read_cif_reg(pcdev->base,CIF_CIF_CTRL));
 	return 0;
 }
 int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frmivalenum *fival)
 {
-    struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+    //struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
     struct rk_camera_dev *pcdev = ici->priv;
     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
     struct rk_camera_frmivalenum *fival_list = NULL;
@@ -2917,6 +2682,8 @@ int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frm
     const struct soc_camera_format_xlate *xlate;
     struct v4l2_mbus_framefmt mf;
     __u32 pixfmt;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);	
     
     index = fival->index & 0x00ffffff;
     if ((fival->index & 0xff000000) == 0xff000000) {   /* ddl@rock-chips.com: detect framerate */ 
@@ -2950,12 +2717,6 @@ int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frm
         }
     }  else {  
 
-        for (i=0; i<RK_CAM_NUM; i++) {
-            if (pcdev->pdata->info[i].dev_name && (strcmp(dev_name(pcdev->icd->pdev),pcdev->pdata->info[i].dev_name) == 0)) {
-                fival_head = pcdev->pdata->info[i].fival;
-            }
-        }
-
         if (fival_head) {
             i = 0;
             while (fival_head->width && fival_head->height) {
@@ -3008,12 +2769,12 @@ int rk_camera_enum_frameintervals(struct soc_camera_device *icd, struct v4l2_frm
         } else {
             i = 0x00;
             new_camera = pcdev->pdata->register_dev_new;
-            while (strstr(new_camera->dev_name,"end")==NULL) {
+            while(new_camera != NULL){
                 if (strcmp(new_camera->dev_name, dev_name(pcdev->icd->pdev)) == 0) {
                     i = 0x01;                
                     break;
                 }
-                new_camera++;
+                new_camera = new_camera->next_camera;
             }
 
             if (i == 0x00) {
@@ -3045,8 +2806,12 @@ static int rk_camera_set_digit_zoom(struct soc_camera_device *icd,
 								const struct v4l2_queryctrl *qctrl, int zoom_rate)
 {
 	struct v4l2_crop a;
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
 	struct rk_camera_dev *pcdev = ici->priv;
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+
 #if CIF_DO_CROP    
 	unsigned long tmp_cifctrl; 
 #endif	
@@ -3116,12 +2881,12 @@ static int rk_camera_set_digit_zoom(struct soc_camera_device *icd,
 static inline struct v4l2_queryctrl const *rk_camera_soc_camera_find_qctrl(
 	struct soc_camera_host_ops *ops, int id)
 {
+/************yzm************
 	int i;
-
 	for (i = 0; i < ops->num_controls; i++)
 		if (ops->controls[i].id == id)
 			return &ops->controls[i];
-
+*///**************yzm********
 	return NULL;
 }
 
@@ -3129,13 +2894,15 @@ static inline struct v4l2_queryctrl const *rk_camera_soc_camera_find_qctrl(
 static int rk_camera_set_ctrl(struct soc_camera_device *icd,
 								struct v4l2_control *sctrl)
 {
-
-	struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	//struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
+	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);//yzm
 	const struct v4l2_queryctrl *qctrl;
     struct rk_camera_dev *pcdev = ici->priv;
 
     int ret = 0;
 
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
 	qctrl = rk_camera_soc_camera_find_qctrl(ici->ops, sctrl->id);
 	if (!qctrl) {
 		ret = -ENOIOCTLCMD;
@@ -3173,7 +2940,7 @@ static struct soc_camera_host_ops rk_soc_camera_host_ops =
     .remove		= rk_camera_remove_device,
     .suspend	= rk_camera_suspend,
     .resume		= rk_camera_resume,
-    .enum_frameinervals = rk_camera_enum_frameintervals,
+    //.enum_frameinervals = rk_camera_enum_frameintervals,
     .cropcap    = rk_camera_cropcap,
     .set_crop	= rk_camera_set_crop,
     .get_crop   = rk_camera_get_crop,
@@ -3191,86 +2958,61 @@ static struct soc_camera_host_ops rk_soc_camera_host_ops =
     .controls = rk_camera_controls,
     .num_controls = ARRAY_SIZE(rk_camera_controls)
 };
-static void rk_camera_cif_iomux(int cif_index)
+
+/**********yzm***********/
+static int rk_camera_cif_iomux(struct device *dev)
 {
-#if defined(CONFIG_ARCH_RK3066B) || defined(CONFIG_ARCH_RK3188)
-    switch(cif_index){
-        case 0:
-        {
-		    iomux_set(CIF0_CLKOUT);
-            write_grf_reg(GRF_IO_CON3, (CIF_DRIVER_STRENGTH_MASK|CIF_DRIVER_STRENGTH_8MA));
-            write_grf_reg(GRF_IO_CON4, (CIF_CLKOUT_AMP_MASK|CIF_CLKOUT_AMP_1V8));
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & (RK_CAM_INPUT_FMT_RAW10|RK_CAM_INPUT_FMT_RAW12))
-	        iomux_set(CIF0_D0);
-	        iomux_set(CIF0_D1);
-            #endif
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & RK_CAM_INPUT_FMT_RAW12)
-	        iomux_set(CIF0_D10);
-	        iomux_set(CIF0_D11);
-            RKCAMERA_TR("%s(%d): WARNING: Cif 0 is configurated that support RAW 12bit, so I2C3 is invalidate!!\n",__FUNCTION__,__LINE__);
-            #endif
-            
-            break;
-        }
-        default:
-            RKCAMERA_TR("%s(%d): Cif index(%d) is invalidate!!!\n",__FUNCTION__,__LINE__, cif_index);
-            break;
+
+    struct pinctrl      *pinctrl;
+    struct pinctrl_state    *state;
+    int retval = 0;
+    char state_str[20] = {0};
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+    strcpy(state_str,"cif_pin_jpe");
+
+	__raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);
+
+
+    //mux CIF0_CLKOUT
+
+    pinctrl = devm_pinctrl_get(dev);
+    if (IS_ERR(pinctrl)) {
+        printk(KERN_EMERG "%s:Get pinctrl failed!\n",__func__);
+        return -1;
     }
-#elif defined(CONFIG_ARCH_RK30)
-    switch(cif_index){
-        case 0:
-        {
-            rk30_mux_api_set(GPIO1B3_CIF0CLKOUT_NAME, GPIO1B_CIF0_CLKOUT);
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & (RK_CAM_INPUT_FMT_RAW10|RK_CAM_INPUT_FMT_RAW12))
-	        rk30_mux_api_set(GPIO1B4_CIF0DATA0_NAME, GPIO1B_CIF0_DATA0);
-	        rk30_mux_api_set(GPIO1B5_CIF0DATA1_NAME, GPIO1B_CIF0_DATA1);
-            #endif
-            #if (CONFIG_CAMERA_INPUT_FMT_SUPPORT & RK_CAM_INPUT_FMT_RAW12)
-	        rk30_mux_api_set(GPIO1B6_CIFDATA10_NAME, GPIO1B_CIF_DATA10);
-	        rk30_mux_api_set(GPIO1B7_CIFDATA11_NAME, GPIO1B_CIF_DATA11);
-            #endif
-            break;
+    state = pinctrl_lookup_state(pinctrl,
+                         state_str);
+    if (IS_ERR(state)){
+        dev_err(dev, "%s:could not get %s pinstate\n",__func__,state_str);
+        return -1;
         }
-        case 1:
-        {
-            rk30_mux_api_set(GPIO1C0_CIF1DATA2_RMIICLKOUT_RMIICLKIN_NAME,GPIO1C_CIF1_DATA2);
-            rk30_mux_api_set(GPIO1C1_CIFDATA3_RMIITXEN_NAME,GPIO1C_CIF_DATA3);
-            rk30_mux_api_set(GPIO1C2_CIF1DATA4_RMIITXD1_NAME,GPIO1C_CIF1_DATA4);
-            rk30_mux_api_set(GPIO1C3_CIFDATA5_RMIITXD0_NAME,GPIO1C_CIF_DATA5);
-            rk30_mux_api_set(GPIO1C4_CIFDATA6_RMIIRXERR_NAME,GPIO1C_CIF_DATA6);
-            rk30_mux_api_set(GPIO1C5_CIFDATA7_RMIICRSDVALID_NAME,GPIO1C_CIF_DATA7);
-            rk30_mux_api_set(GPIO1C6_CIFDATA8_RMIIRXD1_NAME,GPIO1C_CIF_DATA8);
-            rk30_mux_api_set(GPIO1C7_CIFDATA9_RMIIRXD0_NAME,GPIO1C_CIF_DATA9);
-            
-            rk30_mux_api_set(GPIO1D0_CIF1VSYNC_MIIMD_NAME,GPIO1D_CIF1_VSYNC);
-            rk30_mux_api_set(GPIO1D1_CIF1HREF_MIIMDCLK_NAME,GPIO1D_CIF1_HREF);
-            rk30_mux_api_set(GPIO1D2_CIF1CLKIN_NAME,GPIO1D_CIF1_CLKIN);
-            rk30_mux_api_set(GPIO1D3_CIF1DATA0_NAME,GPIO1D_CIF1_DATA0);
-            rk30_mux_api_set(GPIO1D4_CIF1DATA1_NAME,GPIO1D_CIF1_DATA1);
-            rk30_mux_api_set(GPIO1D5_CIF1DATA10_NAME,GPIO1D_CIF1_DATA10);
-            rk30_mux_api_set(GPIO1D6_CIF1DATA11_NAME,GPIO1D_CIF1_DATA11);
-            rk30_mux_api_set(GPIO1D7_CIF1CLKOUT_NAME,GPIO1D_CIF1_CLKOUT);
-            break;
-        }
-        default:
-            RKCAMERA_TR("%s(%d): Cif index(%d) is invalidate!!!\n",__FUNCTION__,__LINE__, cif_index);
-            break;
-        }
-#endif
-                
+
+    if (!IS_ERR(state)) {
+        retval = pinctrl_select_state(pinctrl, state);
+        if (retval){
+            dev_err(dev,
+                "%s:could not set %s pins\n",__func__,state_str);
+                return -1;
+
+                }
+    }
+    return 0;
             
 }
-static int rk_camera_probe(struct platform_device *pdev)
+/***********yzm***********/
+static int rk_camera_probe(struct platform_device *pdev)  //host probe
 {
     struct rk_camera_dev *pcdev;
     struct resource *res;
     struct rk_camera_frmivalenum *fival_list,*fival_nxt;
-    struct rk29camera_mem_res *meminfo_ptr,*meminfo_ptrr;
     int irq,i;
     int err = 0;
     struct rk_cif_clk *clk=NULL;
+	struct device *dev_cif = ((struct rk29camera_platform_data*)pdev->dev.platform_data)->cif_dev;//yzm
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
 
-    RKCAMERA_TR("%s version: v%d.%d.%d  Zoom by %s",RK29_CAM_DRV_NAME,(RK_CAM_VERSION_CODE&0xff0000)>>16,
+	RKCAMERA_TR("%s version: v%d.%d.%d  Zoom by %s",RK29_CAM_DRV_NAME,(RK_CAM_VERSION_CODE&0xff0000)>>16,
         (RK_CAM_VERSION_CODE&0xff00)>>8,RK_CAM_VERSION_CODE&0xff,CAMERA_SCALE_CROP_MACHINE);    
 
     if ((pdev->id == RK_CAM_PLATFORM_DEV_ID_1) && (RK_SUPPORT_CIF1 == 0)) {
@@ -3282,9 +3024,15 @@ static int rk_camera_probe(struct platform_device *pdev)
         RKCAMERA_TR("%s(%d): This chip is not support CIF0!!\n",__FUNCTION__,__LINE__);
         BUG();
     }
-    
+
+/***********yzm**********/
     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
     irq = platform_get_irq(pdev, 0);
+
+//	irq = irq_of_parse_and_map(dev_cif->of_node, 0);
+//debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n res = [%x--%x] \n",res->start , res->end);
+//debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n irq_num = %d\n", irq);
+
     if (!res || irq < 0) {
         err = -ENODEV;
         goto exit;
@@ -3297,76 +3045,52 @@ static int rk_camera_probe(struct platform_device *pdev)
     }
 
     pcdev->zoominfo.zoom_rate = 100;
-    pcdev->hostid = pdev->id;
+    pcdev->hostid = pdev->id;        //获取host的id
     #ifdef CONFIG_SOC_RK3028
     pcdev->chip_id = rk3028_version_val();
     #else
     pcdev->chip_id = -1;
     #endif
 
-	
+//***********yzm***********	
     if (IS_CIF0()) {
+		debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$/is_cif0\n");
         clk = &cif_clk[0];
-        cif_clk[0].pd_cif = clk_get(NULL, "pd_cif0");
-        cif_clk[0].aclk_cif = clk_get(NULL, "aclk_cif0");
-        cif_clk[0].hclk_cif = clk_get(NULL, "hclk_cif0");
-        cif_clk[0].cif_clk_in = clk_get(NULL, "cif0_in");
-        cif_clk[0].cif_clk_out = clk_get(NULL, "cif0_out");
+        cif_clk[0].pd_cif = devm_clk_get(dev_cif, "pd_cif0");
+        cif_clk[0].aclk_cif = devm_clk_get(dev_cif, "aclk_cif0");
+        cif_clk[0].hclk_cif = devm_clk_get(dev_cif, "hclk_cif0");
+        cif_clk[0].cif_clk_in = devm_clk_get(dev_cif, "cif0_in");
+        cif_clk[0].cif_clk_out = devm_clk_get(dev_cif, "cif0_out");
         spin_lock_init(&cif_clk[0].lock);
         cif_clk[0].on = false;
-        rk_camera_cif_iomux(0);
+        rk_camera_cif_iomux(dev_cif);//yzm
     } else {
         clk = &cif_clk[1];
-        cif_clk[1].pd_cif = clk_get(NULL, "pd_cif1");
-        cif_clk[1].aclk_cif = clk_get(NULL, "aclk_cif1");
-        cif_clk[1].hclk_cif = clk_get(NULL, "hclk_cif1");
-        cif_clk[1].cif_clk_in = clk_get(NULL, "cif1_in");
-        cif_clk[1].cif_clk_out = clk_get(NULL, "cif1_out");
+        cif_clk[1].pd_cif = devm_clk_get(dev_cif, "pd_cif0");//目前只定义了cif0 yzm
+        cif_clk[1].aclk_cif = devm_clk_get(dev_cif, "aclk_cif0");
+        cif_clk[1].hclk_cif = devm_clk_get(dev_cif, "hclk_cif0");
+        cif_clk[1].cif_clk_in = devm_clk_get(dev_cif, "cif0_in");
+        cif_clk[1].cif_clk_out = devm_clk_get(dev_cif, "cif0_out");
         spin_lock_init(&cif_clk[1].lock);
         cif_clk[1].on = false;
-        rk_camera_cif_iomux(1);
+        rk_camera_cif_iomux(dev_cif);//yzm
     }
-    
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+//***********yzm**********end    
     dev_set_drvdata(&pdev->dev, pcdev);
     pcdev->res = res;
     pcdev->pdata = pdev->dev.platform_data;             /* ddl@rock-chips.com : Request IO in init function */
-
+			//     = rk_camera_platform_data 那个大结构体yzm
 	if (pcdev->pdata && pcdev->pdata->io_init) {
-        pcdev->pdata->io_init();
+		
+        pcdev->pdata->io_init();//yzm 调用rk_sensor_io_init()
 
         if (pcdev->pdata->sensor_mclk == NULL)
             pcdev->pdata->sensor_mclk = rk_camera_mclk_ctrl;
     }
-    
-    meminfo_ptr = IS_CIF0()? (&pcdev->pdata->meminfo):(&pcdev->pdata->meminfo_cif1);
-    meminfo_ptrr = IS_CIF0()? (&pcdev->pdata->meminfo_cif1):(&pcdev->pdata->meminfo);
-    
-    if (meminfo_ptr->vbase == NULL) {
 
-        if ((meminfo_ptr->start == meminfo_ptrr->start)
-            && (meminfo_ptr->size == meminfo_ptrr->size) && meminfo_ptrr->vbase) {
-
-            meminfo_ptr->vbase = meminfo_ptrr->vbase;
-        } else {        
-        
-            if (!request_mem_region(meminfo_ptr->start,meminfo_ptr->size,"rk29_vipmem")) {
-                err = -EBUSY;
-                RKCAMERA_TR("%s(%d): request_mem_region(start:0x%x size:0x%x) failed \n",__FUNCTION__,__LINE__, pcdev->pdata->meminfo.start,pcdev->pdata->meminfo.size);
-                goto exit_ioremap_vipmem;
-            }
-            meminfo_ptr->vbase = pcdev->vipmem_virbase = ioremap_cached(meminfo_ptr->start,meminfo_ptr->size);
-            if (pcdev->vipmem_virbase == NULL) {
-                RKCAMERA_TR("%s(%d): ioremap of CIF internal memory(Ex:IPP process/raw process) failed\n",__FUNCTION__,__LINE__);
-                err = -ENXIO;
-                goto exit_ioremap_vipmem;
-            }
-        }
-    }
-    
-    pcdev->vipmem_phybase = meminfo_ptr->start;
-	pcdev->vipmem_size = meminfo_ptr->size;
-    pcdev->vipmem_virbase = meminfo_ptr->vbase;
-	
     INIT_LIST_HEAD(&pcdev->capture);
     INIT_LIST_HEAD(&pcdev->camera_work_queue);
     spin_lock_init(&pcdev->lock);
@@ -3427,11 +3151,13 @@ static int rk_camera_probe(struct platform_device *pdev)
     }
     pcdev->soc_host.drv_name	= RK29_CAM_DRV_NAME;
     pcdev->soc_host.ops		= &rk_soc_camera_host_ops;
-    pcdev->soc_host.priv		= pcdev;
+    pcdev->soc_host.priv		= pcdev;        //指向自己，在rk_camera_add_device中有调用
     pcdev->soc_host.v4l2_dev.dev	= &pdev->dev;
     pcdev->soc_host.nr		= pdev->id;
-
+debug_printk("/$$$$$$$$$$$$$$$$$$$$$$/next soc_camera_host_register\n");
     err = soc_camera_host_register(&pcdev->soc_host);
+
+
     if (err) {
         RKCAMERA_TR("%s(%d): soc_camera_host_register failed\n",__FUNCTION__,__LINE__);
         goto exit_free_irq;
@@ -3473,10 +3199,6 @@ static int rk_camera_probe(struct platform_device *pdev)
     iounmap(pcdev->base);
 exit_ioremap_vip:
     release_mem_region(res->start, res->end - res->start + 1);
-exit_ioremap_vipmem:
-    if (pcdev->vipmem_virbase)
-        iounmap(pcdev->vipmem_virbase);
-    release_mem_region(pcdev->vipmem_phybase,pcdev->vipmem_size);
 exit_reqmem_vip:
     if (clk) {
         if (clk->pd_cif)
@@ -3497,14 +3219,16 @@ static int rk_camera_probe(struct platform_device *pdev)
     return err;
 }
 
-static int __devexit rk_camera_remove(struct platform_device *pdev)
+static int __exit rk_camera_remove(struct platform_device *pdev)
 {
     struct rk_camera_dev *pcdev = platform_get_drvdata(pdev);
     struct resource *res;
     struct rk_camera_frmivalenum *fival_list,*fival_nxt;
-    struct rk29camera_mem_res *meminfo_ptr,*meminfo_ptrr;
     int i;
-    
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
+	
     free_irq(pcdev->irqinfo.irq, pcdev);
 
 	if (pcdev->camera_wq) {
@@ -3524,18 +3248,6 @@ static int __devexit rk_camera_remove(struct platform_device *pdev)
 
     soc_camera_host_unregister(&pcdev->soc_host);
 
-    meminfo_ptr = IS_CIF0()? (&pcdev->pdata->meminfo):(&pcdev->pdata->meminfo_cif1);
-    meminfo_ptrr = IS_CIF0()? (&pcdev->pdata->meminfo_cif1):(&pcdev->pdata->meminfo);
-    if (meminfo_ptr->vbase) {
-        if (meminfo_ptr->vbase == meminfo_ptrr->vbase) {
-            meminfo_ptr->vbase = NULL;
-        } else {
-            iounmap((void __iomem*)pcdev->vipmem_virbase);
-            release_mem_region(pcdev->vipmem_phybase, pcdev->vipmem_size);
-            meminfo_ptr->vbase = NULL;
-        }
-    }
-
     res = pcdev->res;
     iounmap((void __iomem*)pcdev->base);
     release_mem_region(res->start, res->end - res->start + 1);
@@ -3554,33 +3266,42 @@ static int __devexit rk_camera_remove(struct platform_device *pdev)
 static struct platform_driver rk_camera_driver =
 {
     .driver 	= {
-        .name	= RK29_CAM_DRV_NAME,
+        .name	= RK29_CAM_DRV_NAME,       //host       
     },
     .probe		= rk_camera_probe,
-    .remove		= __devexit_p(rk_camera_remove),
+    .remove		= (rk_camera_remove),
 };
 
 static int rk_camera_init_async(void *unused)
 {
-    platform_driver_register(&rk_camera_driver);
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
+    platform_driver_register(&rk_camera_driver);	
     return 0;
 }
 
-static int __devinit rk_camera_init(void)
+static int __init rk_camera_init(void)
 {
+
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
+
     kthread_run(rk_camera_init_async, NULL, "rk_camera_init");
+	
     return 0;
 }
 
 static void __exit rk_camera_exit(void)
 {
+debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()/n", __FILE__, __LINE__,__FUNCTION__);
+
     platform_driver_unregister(&rk_camera_driver);
 }
 
-device_initcall_sync(rk_camera_init);
+device_initcall_sync(rk_camera_init); //module_init();
 module_exit(rk_camera_exit);
 
 MODULE_DESCRIPTION("RKSoc Camera Host driver");
 MODULE_AUTHOR("ddl <ddl@rock-chips>");
 MODULE_LICENSE("GPL");
-#endif
+//#endif//yzm
diff --git a/include/media/soc_camera.h b/include/media/soc_camera.h
index ff77d08c30fd..8427b781e8ef 100644
--- a/include/media/soc_camera.h
+++ b/include/media/soc_camera.h
@@ -39,6 +39,10 @@ struct soc_camera_device {
 	unsigned char iface;		/* Host number */
 	unsigned char devnum;		/* Device number per host */
 	struct soc_camera_sense *sense;	/* See comment in struct definition */
+
+	struct soc_camera_ops *ops;//yzm
+	struct mutex video_lock;//yzm
+
 	struct video_device *vdev;
 	struct v4l2_ctrl_handler ctrl_handler;
 	const struct soc_camera_format_xlate *current_fmt;
@@ -73,6 +77,17 @@ struct soc_camera_host_ops {
 	struct module *owner;
 	int (*add)(struct soc_camera_device *);
 	void (*remove)(struct soc_camera_device *);
+	/****************yzm**************/
+	int (*suspend)(struct soc_camera_device *, pm_message_t);
+	int (*resume)(struct soc_camera_device *);
+	//int (*enum_frameinervals)(struct soc_camera_device *, struct v4l2_frmivalenum);
+	int (*get_ctrl)(struct soc_camera_device *, struct v4l2_control *);
+	int (*set_ctrl)(struct soc_camera_device *, struct v4l2_control *);
+	int (*s_stream)(struct soc_camera_device *, int enable);
+	const struct v4l2_queryctrl *controls;
+	int num_controls;
+	/***************yzm*****************/
+	
 	/*
 	 * .get_formats() is called for each client device format, but
 	 * .put_formats() is only called once. Further, if any of the calls to
@@ -100,7 +115,7 @@ struct soc_camera_host_ops {
 			      struct soc_camera_device *);
 	int (*reqbufs)(struct soc_camera_device *, struct v4l2_requestbuffers *);
 	int (*querycap)(struct soc_camera_host *, struct v4l2_capability *);
-	int (*set_bus_param)(struct soc_camera_device *);
+	int (*set_bus_param)(struct soc_camera_device *, __u32);//yzm
 	int (*get_parm)(struct soc_camera_device *, struct v4l2_streamparm *);
 	int (*set_parm)(struct soc_camera_device *, struct v4l2_streamparm *);
 	int (*enum_framesizes)(struct soc_camera_device *, struct v4l2_frmsizeenum *);
@@ -123,6 +138,8 @@ struct soc_camera_subdev_desc {
 	/* sensor driver private platform data */
 	void *drv_priv;
 
+	struct soc_camera_device *socdev;//yzm
+	
 	/* Optional regulators that have to be managed on power on/off events */
 	struct regulator_bulk_data *regulators;
 	int num_regulators;
@@ -131,6 +148,7 @@ struct soc_camera_subdev_desc {
 	int (*power)(struct device *, int);
 	int (*reset)(struct device *);
 
+	int (*powerdown)(struct device *, int);//yzm
 	/*
 	 * some platforms may support different data widths than the sensors
 	 * native ones due to different data line routing. Let the board code
@@ -177,7 +195,7 @@ struct soc_camera_link {
 	unsigned long flags;
 
 	void *priv;
-
+	void *priv_usr;		//yzm@rock-chips.com
 	/* Optional regulators that have to be managed on power on/off events */
 	struct regulator_bulk_data *regulators;
 	int num_regulators;
@@ -185,6 +203,7 @@ struct soc_camera_link {
 	/* Optional callbacks to power on or off and reset the sensor */
 	int (*power)(struct device *, int);
 	int (*reset)(struct device *);
+	int (*powerdown)(struct device *,int);		//yzm@rock-chips.com
 	/*
 	 * some platforms may support different data widths than the sensors
 	 * native ones due to different data line routing. Let the board code
@@ -261,6 +280,20 @@ struct soc_camera_format_xlate {
 	const struct soc_mbus_pixelfmt *host_fmt;
 };
 
+/*****************yzm***************/
+struct soc_camera_ops {
+	int (*suspend)(struct soc_camera_device *, pm_message_t state);
+	int (*resume)(struct soc_camera_device *);
+	unsigned long (*query_bus_param)(struct soc_camera_device *);
+	int (*set_bus_param)(struct soc_camera_device *, unsigned long);
+	int (*enum_input)(struct soc_camera_device *, struct v4l2_input *);
+	const struct v4l2_queryctrl *controls;
+	struct v4l2_querymenu *menus;
+	int num_controls;
+	int num_menus;
+};	
+/****************yzm***************/
+
 #define SOCAM_SENSE_PCLK_CHANGED	(1 << 0)
 
 /**
@@ -297,7 +330,11 @@ struct soc_camera_sense {
 #define SOCAM_DATAWIDTH_16	SOCAM_DATAWIDTH(16)
 #define SOCAM_DATAWIDTH_18	SOCAM_DATAWIDTH(18)
 #define SOCAM_DATAWIDTH_24	SOCAM_DATAWIDTH(24)
-
+/**************yzm***********/
+#define SOCAM_PCLK_SAMPLE_FALLING     (1<<13)
+#define SOCAM_MCLK_24MHZ        (1<<29)
+#define SOCAM_MCLK_48MHZ        (1<<31)
+//*************yzm***********end
 #define SOCAM_DATAWIDTH_MASK (SOCAM_DATAWIDTH_4 | SOCAM_DATAWIDTH_8 | \
 			      SOCAM_DATAWIDTH_9 | SOCAM_DATAWIDTH_10 | \
 			      SOCAM_DATAWIDTH_12 | SOCAM_DATAWIDTH_15 | \
diff --git a/include/media/v4l2-chip-ident.h b/include/media/v4l2-chip-ident.h
index c259b36bf1e9..4d51841a605b 100644
--- a/include/media/v4l2-chip-ident.h
+++ b/include/media/v4l2-chip-ident.h
@@ -77,7 +77,7 @@ enum {
 	V4L2_IDENT_OV2640 = 259,
 	V4L2_IDENT_OV9740 = 260,
 	V4L2_IDENT_OV5642 = 261,
-
+	V4L2_IDENT_OV2659 = 258,//YZM
 	/* module saa7146: reserved range 300-309 */
 	V4L2_IDENT_SAA7146 = 300,
 
diff --git a/include/uapi/linux/v4l2-controls.h b/include/uapi/linux/v4l2-controls.h
index 69bd5bb0d5af..67f17a1052d0 100644
--- a/include/uapi/linux/v4l2-controls.h
+++ b/include/uapi/linux/v4l2-controls.h
@@ -618,6 +618,13 @@ enum  v4l2_exposure_auto_type {
 #define V4L2_CID_FOCUS_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+11)
 #define V4L2_CID_FOCUS_AUTO			(V4L2_CID_CAMERA_CLASS_BASE+12)
 
+#define V4L2_CID_FOCUS_CONTINUOUS   (V4L2_CID_CAMERA_CLASS_BASE+4)//yzm
+#define V4L2_CID_FLASH              (V4L2_CID_CAMERA_CLASS_BASE+3)//yzm
+#define V4L2_CID_EFFECT             (V4L2_CID_CAMERA_CLASS_BASE+2)//yzm
+#define V4L2_CID_SCENE              (V4L2_CID_CAMERA_CLASS_BASE+1)//yzm
+#define V4L2_CID_FOCUSZONE          (V4L2_CID_CAMERA_CLASS_BASE+5)//yzm
+#define V4L2_CID_FACEDETECT         (V4L2_CID_CAMERA_CLASS_BASE+6)//yzm
+
 #define V4L2_CID_ZOOM_ABSOLUTE			(V4L2_CID_CAMERA_CLASS_BASE+13)
 #define V4L2_CID_ZOOM_RELATIVE			(V4L2_CID_CAMERA_CLASS_BASE+14)
 #define V4L2_CID_ZOOM_CONTINUOUS		(V4L2_CID_CAMERA_CLASS_BASE+15)
-- 
2.35.3

