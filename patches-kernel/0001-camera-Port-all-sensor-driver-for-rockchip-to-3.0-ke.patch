From 1c2e256b7b767a208ba262e212062580dc23d617 Mon Sep 17 00:00:00 2001
From: ddl <ddl@rock-chips.com>
Date: Mon, 30 Jan 2012 15:17:53 +0800
Subject: [PATCH] camera: Port all sensor driver for rockchip to 3.0 kernel

---
 drivers/media/video/Kconfig     |   98 +-
 drivers/media/video/Makefile    |    2 +-
 drivers/media/video/gc0307.c    |  222 ++-
 drivers/media/video/gc0308.c    |   20 +-
 drivers/media/video/gc0309.c    |    3 +-
 drivers/media/video/gc2015.c    |   20 +-
 drivers/media/video/gt2005.c    |   20 +-
 drivers/media/video/hi253.c     |   20 +-
 drivers/media/video/hi704.c     |   20 +-
 drivers/media/video/mt9d112.c   |  218 ++-
 drivers/media/video/mt9d113.c   |  220 ++-
 drivers/media/video/mt9p111.c   |   22 +-
 drivers/media/video/nt99250.c   |   20 +-
 drivers/media/video/ov2640_rk.c | 2956 +++++++++++++++++++++++++++++++
 drivers/media/video/ov7675.c    |   22 +-
 drivers/media/video/s5k6aa.c    |   22 +-
 drivers/media/video/sid130B.c   |   28 +-
 drivers/media/video/siv120b.c   |   20 +-
 18 files changed, 3502 insertions(+), 451 deletions(-)
 create mode 100755 drivers/media/video/ov2640_rk.c

diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 407f8c56977e..609f968c4039 100755
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -817,26 +817,26 @@ config SOC_CAMERA_MT9T031
 	  This driver supports MT9T031 cameras from Micron.
 
 config SOC_CAMERA_MT9T111
-	tristate "mt9t111 support"
+	tristate "mt9t111 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This driver supports MT9T111 cameras from Micron.
+	  This driver supports MT9T111 cameras from Micron for rockchip.
 config SOC_CAMERA_MT9P111
-	tristate "mt9p111 support"
+	tristate "mt9p111 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This driver supports MT9P111 cameras from Micron.
+	  This driver supports MT9P111 cameras from Micron for rockchip.
 config SOC_CAMERA_MT9D112
-	tristate "mt9d112 support"
+	tristate "mt9d112 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This driver supports MT9D112 cameras from Micron
+	  This driver supports MT9D112 cameras from Micron for rockchip
 
 config SOC_CAMERA_MT9D113
-	tristate "mt9d113 support"
+	tristate "mt9d113 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This driver supports MT9D113 cameras from Micron
+	  This driver supports MT9D113 cameras from Micron for rockchip
 
 config SOC_CAMERA_MT9T112
 	tristate "mt9t112 support"
@@ -888,46 +888,46 @@ config SOC_CAMERA_OV772X
 	  This is a ov772x camera driver
 
 config SOC_CAMERA_OV7675
-	tristate "ov7675 camera support"
+	tristate "ov7675 camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov7675 camera driver
+	  This is a ov7675 camera driver for rockchip
 
 config SOC_CAMERA_OV2655
-	tristate "ov2655 camera support"
+	tristate "ov2655 camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov2655 camera driver
+	  This is a ov2655 camera driver for rockchip
 
 config SOC_CAMERA_OV2659
-	tristate "ov2659 camera support"
+	tristate "ov2659 camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov2659 camera driver
+	  This is a ov2659 camera driver for rockchip
 	  
 config SOC_CAMERA_OV7690
-	tristate "ov7690 camera support"
+	tristate "ov7690 camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov7690 camera driver	  
+	  This is a ov7690 camera driver for rockchip	  
 
 config SOC_CAMERA_OV9650
-	tristate "ov9650 camera support"
+	tristate "ov9650 camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov9650 camera driver
+	  This is a ov9650 camera driver for rockchip
 
-config SOC_CAMERA_OV2640
-	tristate "ov2640 camera support"
+config SOC_CAMERA_OV2640_RK
+	tristate "ov2640 camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov2640 camera driver
+	  This is a ov2640 camera driver for rockchip
 
 config SOC_CAMERA_OV3640
-	tristate "ov3640 camera support"
+	tristate "ov3640 camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov3640 camera driver
+	  This is a ov3640 camera driver for rockchip
 choice
 	prompt "OV3640 Module Focus select"
 	depends on SOC_CAMERA_OV3640
@@ -942,10 +942,10 @@ config OV3640_FIXEDFOCUS
 endchoice
 
 config SOC_CAMERA_OV5642
-	tristate "ov5642 camera support"
+	tristate "ov5642 camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov5642 camera driver
+	  This is a ov5642 camera driver for rockchip
 choice
 	prompt "OV5642 Module Focus select"
 	depends on SOC_CAMERA_OV5642
@@ -960,10 +960,10 @@ config OV5642_FIXEDFOCUS
 endchoice
 
 config SOC_CAMERA_OV5640
-	tristate "ov5640 camera support"
+	tristate "ov5640 camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a ov5640 camera driver
+	  This is a ov5640 camera driver for rockchip
 choice
 	prompt "OV5640 Module Focus select"
 	depends on SOC_CAMERA_OV5640
@@ -996,34 +996,34 @@ config OV5640_FIXEDFOCUS_FOR_TD8801
 endchoice
 
 config SOC_CAMERA_S5K6AA
-	tristate "Samsung S5K6AA camera support"
+	tristate "Samsung S5K6AA camera support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a samsung S5K6AA camera driver
+	  This is a samsung S5K6AA camera driver for rockchip
 
 config SOC_CAMERA_GT2005
-	tristate "GT2005 support"
+	tristate "GT2005 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a GT2005 camera driver
+	  This is a GT2005 camera driver for rockchip
 
 config SOC_CAMERA_GC0307
-	tristate "GC0307 support"
+	tristate "GC0307 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a GC0307 camera driver	   
+	  This is a GC0307 camera driver for rockchip	   
 
 config SOC_CAMERA_GC0308
-	tristate "GC0308 support"
+	tristate "GC0308 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a GC0308 camera driver
+	  This is a GC0308 camera driver for rockchip
 
 config SOC_CAMERA_GC0309
-	tristate "GC0309 support"
+	tristate "GC0309 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a GC0309 camera driver
+	  This is a GC0309 camera driver for rockchip
 config SOC_CAMERA_GC0309_FOR_TD8801
 	tristate "GC0309 support for td8801"
 	depends on SOC_CAMERA && I2C
@@ -1031,40 +1031,40 @@ config SOC_CAMERA_GC0309_FOR_TD8801
 	  This is a GC0309 camera driver for td8801
 
 config SOC_CAMERA_GC2015
-	tristate "GC2015 support"
+	tristate "GC2015 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a GC2015 camera driver
+	  This is a GC2015 camera driver for rockchip
 
 config SOC_CAMERA_HI253
-	tristate "HI253 support"
+	tristate "HI253 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a HI253 camera driver
+	  This is a HI253 camera driver for rockchip
 
 config SOC_CAMERA_HI704
-	tristate "HI704 support"
+	tristate "HI704 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a HI704 camera driver
+	  This is a HI704 camera driver for rockchip
 
 config SOC_CAMERA_SIV120B
-	tristate "siv120b support"
+	tristate "siv120b support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a SIV120B camera driver
+	  This is a SIV120B camera driver for rockchip
 
 config SOC_CAMERA_SID130B
-	tristate "sid130b support"
+	tristate "sid130b support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a SID130B camera driver
+	  This is a SID130B camera driver for rockchip
 
 config SOC_CAMERA_NT99250
-	tristate "NT99250 support"
+	tristate "NT99250 support for rockchip"
 	depends on SOC_CAMERA && I2C
 	help
-	  This is a NT99250 camera driver
+	  This is a NT99250 camera driver for rockchip
 
 config SOC_CAMERA_OV9640
 	tristate "ov9640 camera support"
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 59148682b1af..bd2a658eb592 100755
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -94,7 +94,7 @@ obj-$(CONFIG_SOC_CAMERA_OV2655)		+= ov2655.o
 obj-$(CONFIG_SOC_CAMERA_OV2659)		+= ov2659.o
 obj-$(CONFIG_SOC_CAMERA_OV7690)		+= ov7690.o
 obj-$(CONFIG_SOC_CAMERA_OV9650)		+= ov9650.o
-obj-$(CONFIG_SOC_CAMERA_OV2640)		+= ov2640.o
+obj-$(CONFIG_SOC_CAMERA_OV2640_RK)		+= ov2640_rk.o
 obj-$(CONFIG_SOC_CAMERA_OV3640)		+= ov3640.o
 obj-$(CONFIG_SOC_CAMERA_OV5640)		+= ov5640.o
 obj-$(CONFIG_SOC_CAMERA_OV5640_FOR_TD8801)		+= ov5640_for_td8801.o
diff --git a/drivers/media/video/gc0307.c b/drivers/media/video/gc0307.c
index 2ee8abe3961f..38f120d99f4c 100755
--- a/drivers/media/video/gc0307.c
+++ b/drivers/media/video/gc0307.c
@@ -54,7 +54,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
 #define SENSOR_INIT_HEIGHT  480
 #define SENSOR_INIT_WINSEQADR sensor_vga
-#define SENSOR_INIT_PIXFMT V4L2_PIX_FMT_YUYV
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -1272,8 +1272,12 @@ static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);
 static int sensor_resume(struct soc_camera_device *icd);
 static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);
 static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);
+#if CONFIG_SENSOR_Effect
 static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
+#endif
+#if CONFIG_SENSOR_WhiteBalance
 static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
+#endif
 static int sensor_deactivate(struct i2c_client *client);
 
 static struct soc_camera_ops sensor_ops =
@@ -1288,18 +1292,29 @@ static struct soc_camera_ops sensor_ops =
     .num_menus		= ARRAY_SIZE(sensor_menus),
 };
 
-#define COL_FMT(_name, _depth, _fourcc, _colorspace) \
-	{ .name = _name, .depth = _depth, .fourcc = _fourcc, \
-	.colorspace = _colorspace }
+/* only one fixed colorspace per pixelcode */
+struct sensor_datafmt {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+};
 
-#define JPG_FMT(_name, _depth, _fourcc) \
-	COL_FMT(_name, _depth, _fourcc, V4L2_COLORSPACE_JPEG)
+/* Find a data format by a pixel code in an array */
+static const struct sensor_datafmt *sensor_find_datafmt(
+	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
+	int n)
+{
+	int i;
+	for (i = 0; i < n; i++)
+		if (fmt[i].code == code)
+			return fmt + i;
 
-static const struct soc_camera_data_format sensor_colour_formats[] = {
-	JPG_FMT(SENSOR_NAME_STRING(YUYV), 16, V4L2_PIX_FMT_YUYV),
-	//JPG_FMT(SENSOR_NAME_STRING(UYVY), 16, V4L2_PIX_FMT_UYVY),
-};
+	return NULL;
+}
 
+static const struct sensor_datafmt sensor_colour_fmts[] = {
+    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG},
+    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG}
+};
 typedef struct sensor_info_priv_s
 {
     int whiteBalance;
@@ -1317,7 +1332,7 @@ typedef struct sensor_info_priv_s
     unsigned char mirror;                                        /* HFLIP */
     unsigned char flip;                                          /* VFLIP */
     unsigned int winseqe_cur_addr;
-	unsigned int pixfmt;
+	struct sensor_datafmt fmt;
     unsigned int funmodule_state;
 } sensor_info_priv_t;
 
@@ -1601,10 +1616,11 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);;
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
+    const struct sensor_datafmt *fmt;
     int ret;
 
 
@@ -1656,7 +1672,13 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     //icd->user_width = SENSOR_INIT_WIDTH;
     //icd->user_height = SENSOR_INIT_HEIGHT;
     sensor->info_priv.winseqe_cur_addr  = (int)SENSOR_INIT_WINSEQADR;
-	sensor->info_priv.pixfmt = SENSOR_INIT_PIXFMT;
+    fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
+    if (!fmt) {
+        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
+        ret = -EINVAL;
+        goto sensor_INIT_ERR;
+    }
+	sensor->info_priv.fmt = *fmt;
 
     /* sensor sensor information for initialization  */
 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
@@ -1797,78 +1819,81 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
     return soc_camera_apply_sensor_flags(icl, flags);
 }
 
-static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
-    struct v4l2_pix_format *pix = &f->fmt.pix;
 
-    pix->width		= icd->user_width;
-    pix->height		= icd->user_height;
-    pix->pixelformat	= sensor->info_priv.pixfmt;
-    pix->field		= V4L2_FIELD_NONE;
-    pix->colorspace		= V4L2_COLORSPACE_JPEG;
+    mf->width	= icd->user_width;
+	mf->height	= icd->user_height;
+	mf->code	= sensor->info_priv.fmt.code;
+	mf->colorspace	= sensor->info_priv.fmt.colorspace;
+	mf->field	= V4L2_FIELD_NONE;
 
     return 0;
 }
-static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_format *f)
+static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
     bool ret = false;
 
-	if ((f->fmt.pix.width == 1024) && (f->fmt.pix.height == 768)) {
+	if ((mf->width == 1024) && (mf->height == 768)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 1280) && (f->fmt.pix.height == 720)) {
+	} else if ((mf->width == 1280) && (mf->height == 1024)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 1280) && (f->fmt.pix.height == 1024)) {
+	} else if ((mf->width == 1600) && (mf->height == 1200)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 1600) && (f->fmt.pix.height == 1200)) {
+	} else if ((mf->width == 2048) && (mf->height == 1536)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 2048) && (f->fmt.pix.height == 1536)) {
-		ret = true;
-	} else if ((f->fmt.pix.width == 2592) && (f->fmt.pix.height == 1944)) {
+	} else if ((mf->width == 2592) && (mf->height == 1944)) {
 		ret = true;
 	}
 
 	if (ret == true)
-		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, f->fmt.pix.width, f->fmt.pix.height);
+		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
 	return ret;
 }
 
-static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_format *f)
+static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
     bool ret = false;
 
-	if ((f->fmt.pix.width == 1280) && (f->fmt.pix.height == 720)) {
+	if ((mf->width == 1280) && (mf->height == 720)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 1920) && (f->fmt.pix.height == 1080)) {
+	} else if ((mf->width == 1920) && (mf->height == 1080)) {
 		ret = true;
 	}
 
 	if (ret == true)
-		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, f->fmt.pix.width, f->fmt.pix.height);
+		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
 	return ret;
 }
-
-static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    const struct sensor_datafmt *fmt;
     struct sensor *sensor = to_sensor(client);
-    struct v4l2_pix_format *pix = &f->fmt.pix;
-    const struct v4l2_queryctrl *qctrl;
-    struct soc_camera_device *icd = client->dev.platform_data;
+	const struct v4l2_queryctrl *qctrl;
+	struct soc_camera_device *icd = client->dev.platform_data;
     struct reginfo *winseqe_set_addr=NULL;
     int ret=0, set_w,set_h;
 
-	if (sensor->info_priv.pixfmt != pix->pixelformat) {
-		switch (pix->pixelformat)
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (!fmt) {
+        ret = -EINVAL;
+        goto sensor_s_fmt_end;
+    }
+
+	if (sensor->info_priv.fmt.code != mf->code) {
+		switch (mf->code)
 		{
-			case V4L2_PIX_FMT_YUYV:
+			case V4L2_MBUS_FMT_YUYV8_2X8:
 			{
 				winseqe_set_addr = sensor_ClrFmt_YUYV;
 				break;
 			}
-			case V4L2_PIX_FMT_UYVY:
+			case V4L2_MBUS_FMT_UYVY8_2X8:
 			{
 				winseqe_set_addr = sensor_ClrFmt_UYVY;
 				break;
@@ -1878,16 +1903,16 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
 		}
 		if (winseqe_set_addr != NULL) {
             sensor_write_array(client, winseqe_set_addr);
-			sensor->info_priv.pixfmt = pix->pixelformat;
-
-			SENSOR_DG("%s Pixelformat(0x%x) set success!\n", SENSOR_NAME_STRING(),pix->pixelformat);
+			sensor->info_priv.fmt.code = mf->code;
+            sensor->info_priv.fmt.colorspace= mf->colorspace;            
+			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
 		} else {
-			SENSOR_TR("%s Pixelformat(0x%x) is invalidate!\n", SENSOR_NAME_STRING(),pix->pixelformat);
+			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
 		}
 	}
 
-    set_w = pix->width;
-    set_h = pix->height;
+    set_w = mf->width;
+    set_h = mf->height;
 
 	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg!=0xff)
 	{
@@ -1936,12 +1961,12 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
         winseqe_set_addr = SENSOR_INIT_WINSEQADR;               /* ddl@rock-chips.com : Sensor output smallest size if  isn't support app  */
         set_w = SENSOR_INIT_WIDTH;
         set_h = SENSOR_INIT_HEIGHT;
-		SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,pix->width,pix->height);
+		SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,mf->width,mf->height);
     }
 
     if ((int)winseqe_set_addr  != sensor->info_priv.winseqe_cur_addr) {
         #if CONFIG_SENSOR_Flash
-        if (sensor_fmt_capturechk(sd,f) == true) {      /* ddl@rock-chips.com : Capture */
+        if (sensor_fmt_capturechk(sd,mf) == true) {      /* ddl@rock-chips.com : Capture */
             if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
                 sensor_ioctrl(icd, Sensor_Flash, Flash_On);
                 SENSOR_DG("%s flash on in capture!\n", SENSOR_NAME_STRING());
@@ -1957,7 +1982,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
         if (ret != 0) {
             SENSOR_TR("%s set format capability failed\n", SENSOR_NAME_STRING());
             #if CONFIG_SENSOR_Flash
-            if (sensor_fmt_capturechk(sd,f) == true) {
+            if (sensor_fmt_capturechk(sd,mf) == true) {
                 if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
                     sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
                     SENSOR_TR("%s Capture format set fail, flash off !\n", SENSOR_NAME_STRING());
@@ -1969,7 +1994,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
 
         sensor->info_priv.winseqe_cur_addr  = (int)winseqe_set_addr;
 
-		if (sensor_fmt_capturechk(sd,f) == true) {				    /* ddl@rock-chips.com : Capture */
+		if (sensor_fmt_capturechk(sd,mf) == true) {				    /* ddl@rock-chips.com : Capture */
 			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
 			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
 			if (sensor->info_priv.whiteBalance != 0) {
@@ -1977,7 +2002,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
 				sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
 			}
 			sensor->info_priv.snap2preview = true;
-		} else if (sensor_fmt_videochk(sd,f) == true) {			/* ddl@rock-chips.com : Video */
+		} else if (sensor_fmt_videochk(sd,mf) == true) {			/* ddl@rock-chips.com : Video */
 			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
 			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
 			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
@@ -1999,44 +2024,45 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
         SENSOR_DG("\n %s .. Current Format is validate. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),set_w,set_h);
     }
 
-	pix->width = set_w;
-    pix->height = set_h;
+	mf->width = set_w;
+    mf->height = set_h;
 
 sensor_s_fmt_end:
     return ret;
 }
 
-static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct v4l2_pix_format *pix = &f->fmt.pix;
-    bool bayer = pix->pixelformat == V4L2_PIX_FMT_UYVY ||
-        pix->pixelformat == V4L2_PIX_FMT_YUYV;
-
-    /*
-    * With Bayer format enforce even side lengths, but let the user play
-    * with the starting pixel
-    */
-
-    if (pix->height > SENSOR_MAX_HEIGHT)
-        pix->height = SENSOR_MAX_HEIGHT;
-    else if (pix->height < SENSOR_MIN_HEIGHT)
-        pix->height = SENSOR_MIN_HEIGHT;
-    else if (bayer)
-        pix->height = ALIGN(pix->height, 2);
-
-    if (pix->width > SENSOR_MAX_WIDTH)
-        pix->width = SENSOR_MAX_WIDTH;
-    else if (pix->width < SENSOR_MIN_WIDTH)
-        pix->width = SENSOR_MIN_WIDTH;
-    else if (bayer)
-        pix->width = ALIGN(pix->width, 2);
-
-    return 0;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct sensor *sensor = to_sensor(client);
+    const struct sensor_datafmt *fmt;
+    int ret = 0;
+   
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (fmt == NULL) {
+		fmt = &sensor->info_priv.fmt;
+        mf->code = fmt->code;
+	} 
+
+    if (mf->height > SENSOR_MAX_HEIGHT)
+        mf->height = SENSOR_MAX_HEIGHT;
+    else if (mf->height < SENSOR_MIN_HEIGHT)
+        mf->height = SENSOR_MIN_HEIGHT;
+
+    if (mf->width > SENSOR_MAX_WIDTH)
+        mf->width = SENSOR_MAX_WIDTH;
+    else if (mf->width < SENSOR_MIN_WIDTH)
+        mf->width = SENSOR_MIN_WIDTH;
+
+    mf->colorspace = fmt->colorspace;
+    
+    return ret;
 }
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);;
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2320,7 +2346,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);;
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2379,7 +2405,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);;
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -2669,7 +2695,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);;
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2694,7 +2720,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);;
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2767,8 +2793,6 @@ static int sensor_video_probe(struct soc_camera_device *icd,
         goto sensor_video_probe_err;
     }
 
-    icd->formats = sensor_colour_formats;
-    icd->num_formats = ARRAY_SIZE(sensor_colour_formats);
 
     return 0;
 
@@ -2779,7 +2803,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);;
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
@@ -2839,6 +2863,15 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	return ret;
 
 }
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			    enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(sensor_colour_fmts))
+		return -EINVAL;
+
+	*code = sensor_colour_fmts[index].code;
+	return 0;
+}
 static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
 	.init		= sensor_init,
 	.g_ctrl		= sensor_g_control,
@@ -2850,9 +2883,10 @@ static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
 };
 
 static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
-	.s_fmt		= sensor_s_fmt,
-	.g_fmt		= sensor_g_fmt,
-	.try_fmt	= sensor_try_fmt,
+	.s_mbus_fmt	= sensor_s_fmt,
+	.g_mbus_fmt	= sensor_g_fmt,
+	.try_mbus_fmt	= sensor_try_fmt,
+	.enum_mbus_fmt	= sensor_enum_fmt,
 };
 
 static struct v4l2_subdev_ops sensor_subdev_ops = {
@@ -2895,7 +2929,7 @@ static int sensor_probe(struct i2c_client *client,
 
     /* Second stage probe - when a capture adapter is there */
     icd->ops		= &sensor_ops;
-    icd->y_skip_top		= 0;
+    sensor->info_priv.fmt = sensor_colour_fmts[0];
 	#if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_set(&sensor->tasklock_cnt,0);
 	#endif
diff --git a/drivers/media/video/gc0308.c b/drivers/media/video/gc0308.c
index 5a8eb3c35153..67669ac38f73 100755
--- a/drivers/media/video/gc0308.c
+++ b/drivers/media/video/gc0308.c
@@ -1491,7 +1491,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -1673,7 +1673,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -1722,7 +1722,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     const struct sensor_datafmt *fmt;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -1880,7 +1880,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -1909,7 +1909,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2193,7 +2193,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2252,7 +2252,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -2542,7 +2542,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2567,7 +2567,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2645,7 +2645,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
diff --git a/drivers/media/video/gc0309.c b/drivers/media/video/gc0309.c
index 7ef21f43d2d3..dff2a47c92be 100755
--- a/drivers/media/video/gc0309.c
+++ b/drivers/media/video/gc0309.c
@@ -59,7 +59,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define CONFIG_SENSOR_Brightness	0
 #define CONFIG_SENSOR_Contrast      0
 #define CONFIG_SENSOR_Saturation    0
-#define CONFIG_SENSOR_Effect        1
+#define CONFIG_SENSOR_Effect        1 
 #define CONFIG_SENSOR_Scene         1
 #define CONFIG_SENSOR_DigitalZoom   0
 #define CONFIG_SENSOR_Focus         0
@@ -1565,7 +1565,6 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 static int sensor_deactivate(struct i2c_client *client)
 {
 	struct soc_camera_device *icd = client->dev.platform_data;
-	u8 reg_val;
     struct sensor *sensor = to_sensor(client);
 	SENSOR_DG("\n%s..%s.. Enter\n",SENSOR_NAME_STRING(),__FUNCTION__);
 
diff --git a/drivers/media/video/gc2015.c b/drivers/media/video/gc2015.c
index 657a3a6ce1b1..4f9e18f7a1b8 100755
--- a/drivers/media/video/gc2015.c
+++ b/drivers/media/video/gc2015.c
@@ -1599,7 +1599,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -1808,7 +1808,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -1857,7 +1857,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     const struct sensor_datafmt *fmt;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -2037,7 +2037,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -2066,7 +2066,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2350,7 +2350,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2409,7 +2409,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -2699,7 +2699,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2724,7 +2724,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2811,7 +2811,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
diff --git a/drivers/media/video/gt2005.c b/drivers/media/video/gt2005.c
index b7e436615d1f..607be6ed8a74 100755
--- a/drivers/media/video/gt2005.c
+++ b/drivers/media/video/gt2005.c
@@ -2246,7 +2246,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -2463,7 +2463,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -2512,7 +2512,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     const struct sensor_datafmt *fmt;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -2676,7 +2676,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -2705,7 +2705,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2989,7 +2989,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -3048,7 +3048,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -3338,7 +3338,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -3363,7 +3363,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -3450,7 +3450,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 #if CONFIG_SENSOR_Flash
diff --git a/drivers/media/video/hi253.c b/drivers/media/video/hi253.c
index 31ae238802f9..343a22c73c98 100755
--- a/drivers/media/video/hi253.c
+++ b/drivers/media/video/hi253.c
@@ -2157,7 +2157,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -2356,7 +2356,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -2405,7 +2405,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
 	const struct v4l2_queryctrl *qctrl;
@@ -2587,7 +2587,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -2616,7 +2616,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2900,7 +2900,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2959,7 +2959,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -3249,7 +3249,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -3274,7 +3274,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -3351,7 +3351,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
diff --git a/drivers/media/video/hi704.c b/drivers/media/video/hi704.c
index 5cd8e844a2e7..6c2c2659cd36 100755
--- a/drivers/media/video/hi704.c
+++ b/drivers/media/video/hi704.c
@@ -1635,7 +1635,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -1833,7 +1833,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -1882,7 +1882,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
 	const struct v4l2_queryctrl *qctrl;
@@ -2040,7 +2040,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -2069,7 +2069,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2353,7 +2353,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2412,7 +2412,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -2702,7 +2702,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2727,7 +2727,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2805,7 +2805,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
diff --git a/drivers/media/video/mt9d112.c b/drivers/media/video/mt9d112.c
index a34053e90dd6..ce7e3b709e59 100755
--- a/drivers/media/video/mt9d112.c
+++ b/drivers/media/video/mt9d112.c
@@ -56,7 +56,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
 #define SENSOR_INIT_HEIGHT  480
 #define SENSOR_INIT_WINSEQADR sensor_vga
-#define SENSOR_INIT_PIXFMT V4L2_PIX_FMT_UYVY
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	1
 #define CONFIG_SENSOR_Brightness	0
@@ -96,6 +96,8 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 
 #define SENSOR_AF_IS_ERR    (0x00<<0)
 #define SENSOR_AF_IS_OK		(0x01<<0)
+#define SENSOR_INIT_IS_ERR   (0x00<<28)
+#define SENSOR_INIT_IS_OK    (0x01<<28)
 
 #if CONFIG_SENSOR_Focus
 #define SENSOR_AF_MODE_INFINITY    0
@@ -1372,10 +1374,13 @@ static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);
 static int sensor_resume(struct soc_camera_device *icd);
 static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);
 static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);
+#if CONFIG_SENSOR_Effect
 static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
+#endif
+#if CONFIG_SENSOR_WhiteBalance
 static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
+#endif
 static int sensor_deactivate(struct i2c_client *client);
-
 static struct soc_camera_ops sensor_ops =
 {
     .suspend                     = sensor_suspend,
@@ -1387,17 +1392,28 @@ static struct soc_camera_ops sensor_ops =
     .num_controls		= ARRAY_SIZE(sensor_controls),
     .num_menus		= ARRAY_SIZE(sensor_menus),
 };
+/* only one fixed colorspace per pixelcode */
+struct sensor_datafmt {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+};
 
-#define COL_FMT(_name, _depth, _fourcc, _colorspace) \
-	{ .name = _name, .depth = _depth, .fourcc = _fourcc, \
-	.colorspace = _colorspace }
+/* Find a data format by a pixel code in an array */
+static const struct sensor_datafmt *sensor_find_datafmt(
+	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
+	int n)
+{
+	int i;
+	for (i = 0; i < n; i++)
+		if (fmt[i].code == code)
+			return fmt + i;
 
-#define JPG_FMT(_name, _depth, _fourcc) \
-	COL_FMT(_name, _depth, _fourcc, V4L2_COLORSPACE_JPEG)
+	return NULL;
+}
 
-static const struct soc_camera_data_format sensor_colour_formats[] = {
-	JPG_FMT(SENSOR_NAME_STRING(UYVY), 16, V4L2_PIX_FMT_UYVY),
-	JPG_FMT(SENSOR_NAME_STRING(YUYV), 16, V4L2_PIX_FMT_YUYV),
+static const struct sensor_datafmt sensor_colour_fmts[] = {
+    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
+    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
 };
 enum sensor_work_state
 {
@@ -1434,7 +1450,7 @@ typedef struct sensor_info_priv_s
 	int preview_w;
 	int preview_h;
     struct reginfo *winseqe_cur_addr;
-	unsigned int pixfmt;
+	struct sensor_datafmt fmt;
 	unsigned int enable;
 	unsigned int funmodule_state;
 } sensor_info_priv_t;
@@ -1754,10 +1770,11 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
+    const struct sensor_datafmt *fmt;
     int ret;
 #if (SENSOR_ID_REG != SEQUENCE_END)    
     u16 pid = 0;
@@ -1818,7 +1835,13 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     sensor->info_priv.capture_w = SENSOR_MAX_WIDTH;
     sensor->info_priv.capture_h = SENSOR_MAX_HEIGHT;
     sensor->info_priv.winseqe_cur_addr  = SENSOR_INIT_WINSEQADR;
-	sensor->info_priv.pixfmt = SENSOR_INIT_PIXFMT;
+    fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
+    if (!fmt) {
+        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
+        ret = -EINVAL;
+        goto sensor_INIT_ERR;
+    }
+	sensor->info_priv.fmt = *fmt;
 
     /* sensor sensor information for initialization  */
 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
@@ -1948,74 +1971,79 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
     return soc_camera_apply_sensor_flags(icl, flags);
 }
-
-static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
-    struct v4l2_pix_format *pix = &f->fmt.pix;
 
-    pix->width		= icd->user_width;
-    pix->height		= icd->user_height;
-    pix->pixelformat	= sensor->info_priv.pixfmt;
-    pix->field		= V4L2_FIELD_NONE;
-    pix->colorspace		= V4L2_COLORSPACE_JPEG;
+    mf->width	= icd->user_width;
+	mf->height	= icd->user_height;
+	mf->code	= sensor->info_priv.fmt.code;
+	mf->colorspace	= sensor->info_priv.fmt.colorspace;
+	mf->field	= V4L2_FIELD_NONE;
 
     return 0;
 }
-static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_format *f)
+static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
     bool ret = false;
 
-	if ((f->fmt.pix.width == 1024) && (f->fmt.pix.height == 768)) {
+	if ((mf->width == 1024) && (mf->height == 768)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 1280) && (f->fmt.pix.height == 1024)) {
+	} else if ((mf->width == 1280) && (mf->height == 1024)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 1600) && (f->fmt.pix.height == 1200)) {
+	} else if ((mf->width == 1600) && (mf->height == 1200)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 2048) && (f->fmt.pix.height == 1536)) {
+	} else if ((mf->width == 2048) && (mf->height == 1536)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 2592) && (f->fmt.pix.height == 1944)) {
+	} else if ((mf->width == 2592) && (mf->height == 1944)) {
 		ret = true;
 	}
 
 	if (ret == true)
-		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, f->fmt.pix.width, f->fmt.pix.height);
+		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
 	return ret;
 }
 
-static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_format *f)
+static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
     bool ret = false;
 
-	if ((f->fmt.pix.width == 1280) && (f->fmt.pix.height == 720)) {
+	if ((mf->width == 1280) && (mf->height == 720)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 1920) && (f->fmt.pix.height == 1080)) {
+	} else if ((mf->width == 1920) && (mf->height == 1080)) {
 		ret = true;
 	}
 
 	if (ret == true)
-		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, f->fmt.pix.width, f->fmt.pix.height);
+		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
 	return ret;
 }
-static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
-    struct v4l2_pix_format *pix = &f->fmt.pix;
+    const struct sensor_datafmt *fmt;
     struct reginfo *winseqe_set_addr=NULL;
     int ret = 0, set_w,set_h;
 
-	if (sensor->info_priv.pixfmt != pix->pixelformat) {
-		switch (pix->pixelformat)
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (!fmt) {
+        ret = -EINVAL;
+        goto sensor_s_fmt_end;
+    }
+
+	if (sensor->info_priv.fmt.code != mf->code) {
+		switch (mf->code)
 		{
-			case V4L2_PIX_FMT_YUYV:
+			case V4L2_MBUS_FMT_YUYV8_2X8:
 			{
 				winseqe_set_addr = sensor_ClrFmt_YUYV;
 				break;
 			}
-			case V4L2_PIX_FMT_UYVY:
+			case V4L2_MBUS_FMT_UYVY8_2X8:
 			{
 				winseqe_set_addr = sensor_ClrFmt_UYVY;
 				break;
@@ -2025,17 +2053,16 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
 		}
 		if (winseqe_set_addr != NULL) {
             sensor_write_array(client, winseqe_set_addr);
-			sensor->info_priv.pixfmt = pix->pixelformat;
-
-			SENSOR_DG("%s Pixelformat(0x%x) set success!\n", SENSOR_NAME_STRING(),pix->pixelformat);
+			sensor->info_priv.fmt.code = mf->code;
+            sensor->info_priv.fmt.colorspace= mf->colorspace;            
+			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
 		} else {
-			SENSOR_TR("%s Pixelformat(0x%x) is invalidate!\n", SENSOR_NAME_STRING(),pix->pixelformat);
+			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
 		}
 	}
 
-    set_w = pix->width;
-    set_h = pix->height;
-
+    set_w = mf->width;
+    set_h = mf->height;
 	if (((set_w <= 176) && (set_h <= 144)) && (sensor_qcif[0].reg!=SEQUENCE_END))
 	{
 		winseqe_set_addr = sensor_qcif;
@@ -2133,57 +2160,58 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
 		sensor->info_priv.capture_h = set_h;
 		sensor->info_priv.snap2preview = true;
 	} else if (sensor->info_priv.snap2preview == true) {
-		if (winseqe_set_addr || ((sensor->info_priv.preview_w == pix->width) && (sensor->info_priv.preview_h == pix->height))) {
+		if (winseqe_set_addr || ((sensor->info_priv.preview_w == mf->width) && (sensor->info_priv.preview_h == mf->height))) {
 			ret |= sensor_write_array(client, sensor_Capture2Preview);
 			if (ret != 0) {
 	        	SENSOR_TR("%s Capture 2 Preview failed\n", SENSOR_NAME_STRING());
 	        	goto sensor_s_fmt_end;
 	    	}
-			sensor->info_priv.preview_w = pix->width;
-			sensor->info_priv.preview_h = pix->height;
+			sensor->info_priv.preview_w = mf->width;
+			sensor->info_priv.preview_h = mf->height;
 			sensor->info_priv.snap2preview = false;
 		} else {
-			SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,pix->width,pix->height);
+			SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,mf->width,mf->height);
 		}
 	}
 
-	pix->width = set_w;
-	pix->height = set_h;
+	mf->width = set_w;
+	mf->height = set_h;
 sensor_s_fmt_end:
     return ret;
 }
 
-static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct v4l2_pix_format *pix = &f->fmt.pix;
-    bool bayer = pix->pixelformat == V4L2_PIX_FMT_UYVY ||
-        pix->pixelformat == V4L2_PIX_FMT_YUYV;
-
-    /*
-    * With Bayer format enforce even side lengths, but let the user play
-    * with the starting pixel
-    */
-
-    if (pix->height > SENSOR_MAX_HEIGHT)
-        pix->height = SENSOR_MAX_HEIGHT;
-    else if (pix->height < SENSOR_MIN_HEIGHT)
-        pix->height = SENSOR_MIN_HEIGHT;
-    else if (bayer)
-        pix->height = ALIGN(pix->height, 2);
-
-    if (pix->width > SENSOR_MAX_WIDTH)
-        pix->width = SENSOR_MAX_WIDTH;
-    else if (pix->width < SENSOR_MIN_WIDTH)
-        pix->width = SENSOR_MIN_WIDTH;
-    else if (bayer)
-        pix->width = ALIGN(pix->width, 2);
-
-    return 0;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct sensor *sensor = to_sensor(client);
+    const struct sensor_datafmt *fmt;
+    int ret = 0;
+   
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (fmt == NULL) {
+		fmt = &sensor->info_priv.fmt;
+        mf->code = fmt->code;
+	} 
+
+    if (mf->height > SENSOR_MAX_HEIGHT)
+        mf->height = SENSOR_MAX_HEIGHT;
+    else if (mf->height < SENSOR_MIN_HEIGHT)
+        mf->height = SENSOR_MIN_HEIGHT;
+
+    if (mf->width > SENSOR_MAX_WIDTH)
+        mf->width = SENSOR_MAX_WIDTH;
+    else if (mf->width < SENSOR_MIN_WIDTH)
+        mf->width = SENSOR_MIN_WIDTH;
+
+    mf->colorspace = fmt->colorspace;
+    
+    return ret;
 }
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2571,7 +2599,7 @@ static int sensor_set_focus_mode(struct soc_camera_device *icd, const struct v4l
 #endif
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2630,7 +2658,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -2947,7 +2975,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2972,7 +3000,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2996,7 +3024,7 @@ static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_stream(struct v4l2_subdev *sd, int enable)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
 
 	if (enable == 1) {
@@ -3065,8 +3093,6 @@ static int sensor_video_probe(struct soc_camera_device *icd,
         goto sensor_video_probe_err;
     }
 
-    icd->formats = sensor_colour_formats;
-    icd->num_formats = ARRAY_SIZE(sensor_colour_formats);
 
     return 0;
 
@@ -3075,7 +3101,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
@@ -3134,7 +3160,15 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	return ret;
 
 }
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			    enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(sensor_colour_fmts))
+		return -EINVAL;
 
+	*code = sensor_colour_fmts[index].code;
+	return 0;
+}
 static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
 	.init		= sensor_init,
 	.g_ctrl		= sensor_g_control,
@@ -3146,10 +3180,10 @@ static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
 };
 
 static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
-	.s_fmt		= sensor_s_fmt,
-	.g_fmt		= sensor_g_fmt,
-	.try_fmt	= sensor_try_fmt,
-	.s_stream   = sensor_s_stream,
+	.s_mbus_fmt	= sensor_s_fmt,
+	.g_mbus_fmt	= sensor_g_fmt,
+	.try_mbus_fmt	= sensor_try_fmt,
+	.enum_mbus_fmt	= sensor_enum_fmt,
 };
 
 static struct v4l2_subdev_ops sensor_subdev_ops = {
@@ -3192,7 +3226,7 @@ static int sensor_probe(struct i2c_client *client,
 
     /* Second stage probe - when a capture adapter is there */
     icd->ops		= &sensor_ops;
-    icd->y_skip_top		= 0;
+    sensor->info_priv.fmt = sensor_colour_fmts[0];
 	#if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_set(&sensor->tasklock_cnt,0);
 	#endif
diff --git a/drivers/media/video/mt9d113.c b/drivers/media/video/mt9d113.c
index 3d62c455bcfa..66f9c8ff8f37 100755
--- a/drivers/media/video/mt9d113.c
+++ b/drivers/media/video/mt9d113.c
@@ -59,7 +59,7 @@ module_param(debug, int, S_IRUGO|S_IWUSR);
 #define SENSOR_INIT_WIDTH	800			/* Sensor pixel size for sensor_init_data array */
 #define SENSOR_INIT_HEIGHT  600
 #define SENSOR_INIT_WINSEQADR sensor_init_data
-#define SENSOR_INIT_PIXFMT V4L2_PIX_FMT_UYVY
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_UYVY8_2X8
 
 #define CONFIG_SENSOR_WhiteBalance	0
 #define CONFIG_SENSOR_Brightness	0
@@ -1119,16 +1119,28 @@ static struct soc_camera_ops sensor_ops =
     .num_menus		= ARRAY_SIZE(sensor_menus),
 };
 
-#define COL_FMT(_name, _depth, _fourcc, _colorspace) \
-	{ .name = _name, .depth = _depth, .fourcc = _fourcc, \
-	.colorspace = _colorspace }
+/* only one fixed colorspace per pixelcode */
+struct sensor_datafmt {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+};
+
+/* Find a data format by a pixel code in an array */
+static const struct sensor_datafmt *sensor_find_datafmt(
+	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
+	int n)
+{
+	int i;
+	for (i = 0; i < n; i++)
+		if (fmt[i].code == code)
+			return fmt + i;
 
-#define JPG_FMT(_name, _depth, _fourcc) \
-	COL_FMT(_name, _depth, _fourcc, V4L2_COLORSPACE_JPEG)
+	return NULL;
+}
 
-static const struct soc_camera_data_format sensor_colour_formats[] = {
-	JPG_FMT(SENSOR_NAME_STRING(UYVY), 16, V4L2_PIX_FMT_UYVY),
-	JPG_FMT(SENSOR_NAME_STRING(YUYV), 16, V4L2_PIX_FMT_YUYV),
+static const struct sensor_datafmt sensor_colour_fmts[] = {
+    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
+    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
 };
 enum sensor_work_state
 {
@@ -1165,7 +1177,7 @@ typedef struct sensor_info_priv_s
 	int preview_w;
 	int preview_h;
     struct reginfo *winseqe_cur_addr;
-	unsigned int pixfmt;
+	struct sensor_datafmt fmt;
 	unsigned int enable;
 	unsigned int funmodule_state;
 } sensor_info_priv_t;
@@ -1552,10 +1564,11 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
+    const struct sensor_datafmt *fmt;
     int ret;
     u16 pid = 0;
 
@@ -1624,7 +1637,13 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
     sensor->info_priv.capture_w = SENSOR_MAX_WIDTH;
     sensor->info_priv.capture_h = SENSOR_MAX_HEIGHT;
     sensor->info_priv.winseqe_cur_addr  = SENSOR_INIT_WINSEQADR;
-	sensor->info_priv.pixfmt = SENSOR_INIT_PIXFMT;
+    fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
+    if (!fmt) {
+        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
+        ret = -EINVAL;
+        goto sensor_INIT_ERR;
+    }
+	sensor->info_priv.fmt = *fmt;
 
     /* sensor sensor information for initialization  */
 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
@@ -1758,58 +1777,55 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
     return soc_camera_apply_sensor_flags(icl, flags);
 }
-
-static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
-    struct v4l2_pix_format *pix = &f->fmt.pix;
 
-    pix->width		= icd->user_width;
-    pix->height		= icd->user_height;
-    pix->pixelformat	= sensor->info_priv.pixfmt;
-    pix->field		= V4L2_FIELD_NONE;
-    pix->colorspace		= V4L2_COLORSPACE_JPEG;
+    mf->width	= icd->user_width;
+	mf->height	= icd->user_height;
+	mf->code	= sensor->info_priv.fmt.code;
+	mf->colorspace	= sensor->info_priv.fmt.colorspace;
+	mf->field	= V4L2_FIELD_NONE;
 
     return 0;
 }
-static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_format *f)
+static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
     bool ret = false;
 
-	if ((f->fmt.pix.width == 1024) && (f->fmt.pix.height == 768)) {
+	if ((mf->width == 1024) && (mf->height == 768)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 1280) && (f->fmt.pix.height == 1024)) {
+	} else if ((mf->width == 1280) && (mf->height == 1024)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 1600) && (f->fmt.pix.height == 1200)) {
+	} else if ((mf->width == 1600) && (mf->height == 1200)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 2048) && (f->fmt.pix.height == 1536)) {
+	} else if ((mf->width == 2048) && (mf->height == 1536)) {
 		ret = true;
-	} else if ((f->fmt.pix.width == 2592) && (f->fmt.pix.height == 1944)) {
+	} else if ((mf->width == 2592) && (mf->height == 1944)) {
 		ret = true;
 	}
 
 	if (ret == true)
-		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, f->fmt.pix.width, f->fmt.pix.height);
+		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
 	return ret;
 }
 
-static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_format *f)
+static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
     bool ret = false;
 
-	if ((f->fmt.pix.width == 1280) && (f->fmt.pix.height == 720)) {
-		ret = true;  //true zyw
-	} else if ((f->fmt.pix.width == 1920) && (f->fmt.pix.height == 1080)) {
-		ret = true;  //true zyw
+	if ((mf->width == 1280) && (mf->height == 720)) {
+		ret = true;
+	} else if ((mf->width == 1920) && (mf->height == 1080)) {
+		ret = true;
 	}
 
 	if (ret == true)
-		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, f->fmt.pix.width, f->fmt.pix.height);
+		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
 	return ret;
 }
-
 static struct reginfo* sensor_fmt_catch(int set_w, int set_h, int *ret_w, int *ret_h)
 {
 	struct reginfo *winseqe_set_addr = NULL;
@@ -1870,25 +1886,32 @@ static struct reginfo* sensor_fmt_catch(int set_w, int set_h, int *ret_w, int *r
 	return winseqe_set_addr;
 }
 
-static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
-    struct v4l2_pix_format *pix = &f->fmt.pix;
+    const struct sensor_datafmt *fmt;
     struct reginfo *winseqe_set_addr=NULL;
     int ret = 0, set_w,set_h;
 
-    SENSOR_TR("%s pix->width=%d,pix->height=%d\n",__FUNCTION__,pix->width,pix->height);
+    SENSOR_TR("%s pix->width=%d,pix->height=%d\n",__FUNCTION__,mf->width,mf->height);
+
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (!fmt) {
+        ret = -EINVAL;
+        goto sensor_s_fmt_end;
+    }
 
-	if (sensor->info_priv.pixfmt != pix->pixelformat) {
-		switch (pix->pixelformat)
+	if (sensor->info_priv.fmt.code != mf->code) {
+		switch (mf->code)
 		{
-			case V4L2_PIX_FMT_YUYV:
+			case V4L2_MBUS_FMT_YUYV8_2X8:
 			{
 				winseqe_set_addr = sensor_ClrFmt_YUYV;
 				break;
 			}
-			case V4L2_PIX_FMT_UYVY:
+			case V4L2_MBUS_FMT_UYVY8_2X8:
 			{
 				winseqe_set_addr = sensor_ClrFmt_UYVY;
 				break;
@@ -1898,16 +1921,16 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
 		}
 		if (winseqe_set_addr != NULL) {
             sensor_write_array(client, winseqe_set_addr);
-			sensor->info_priv.pixfmt = pix->pixelformat;
-
-			SENSOR_DG("%s Pixelformat(0x%x) set success!\n", SENSOR_NAME_STRING(),pix->pixelformat);
+			sensor->info_priv.fmt.code = mf->code;
+            sensor->info_priv.fmt.colorspace= mf->colorspace;            
+			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
 		} else {
-			SENSOR_TR("%s Pixelformat(0x%x) is invalidate!\n", SENSOR_NAME_STRING(),pix->pixelformat);
+			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
 		}
 	}
 
-    set_w = pix->width;
-    set_h = pix->height;
+    set_w = mf->width;
+    set_h = mf->height;
 
 	winseqe_set_addr = sensor_fmt_catch(set_w, set_h, &set_w, &set_h);
 
@@ -1922,8 +1945,8 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
         	SENSOR_DG("\n%s..%s..Capture icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),__FUNCTION__,set_w,set_h);
 		} else {
 			SENSOR_DG("\n%s..%s..Video icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),__FUNCTION__,set_w,set_h);
-			sensor->info_priv.preview_w = pix->width;
-			sensor->info_priv.preview_h = pix->height;
+			sensor->info_priv.preview_w = mf->width;
+			sensor->info_priv.preview_h = mf->height;
 		}
     }
 
@@ -1937,58 +1960,61 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
 		sensor->info_priv.capture_h = set_h;
 		sensor->info_priv.snap2preview = true;
 	} else if (sensor->info_priv.snap2preview == true) {
-		if (winseqe_set_addr || ((sensor->info_priv.preview_w == pix->width) && (sensor->info_priv.preview_h == pix->height))) {
+		if (winseqe_set_addr || ((sensor->info_priv.preview_w == mf->width) && (sensor->info_priv.preview_h == mf->height))) {
 			ret |= sensor_write_array(client, sensor_Capture2Preview);
 			if (ret != 0) {
 	        	SENSOR_TR("%s Capture 2 Preview failed\n", SENSOR_NAME_STRING());
 	        	goto sensor_s_fmt_end;
 	    	}
-			sensor->info_priv.preview_w = pix->width;
-			sensor->info_priv.preview_h = pix->height;
+			sensor->info_priv.preview_w = mf->width;
+			sensor->info_priv.preview_h = mf->height;
 			sensor->info_priv.snap2preview = false;
 		} else {
-			SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,pix->width,pix->height);
+			SENSOR_TR("\n %s..%s Format is Invalidate. mf->width = %d.. mf->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,mf->width,mf->height);
 		}
 	}
 
-	pix->width = set_w;
-	pix->height = set_h;
+	mf->width = set_w;
+	mf->height = set_h;
 sensor_s_fmt_end:
     return ret;
 }
 
-static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
+static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
 	int ret = 0;
-    struct v4l2_pix_format *pix = &f->fmt.pix;
-    bool bayer = pix->pixelformat == V4L2_PIX_FMT_UYVY ||
-        pix->pixelformat == V4L2_PIX_FMT_YUYV;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct sensor *sensor = to_sensor(client);
+    const struct sensor_datafmt *fmt;
+   
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (fmt == NULL) {
+		fmt = &sensor->info_priv.fmt;
+        mf->code = fmt->code;
+	} 
 
-    SENSOR_TR("%s pix->width=%d,pix->height=%d\n",__FUNCTION__,pix->width,pix->height);
+    SENSOR_TR("%s pix->width=%d,pix->height=%d\n",__FUNCTION__,mf->width,mf->height);
 
     /*
     * With Bayer format enforce even side lengths, but let the user play
     * with the starting pixel
     */
 
-    if (pix->height > SENSOR_MAX_HEIGHT)
-        pix->height = SENSOR_MAX_HEIGHT;
-    else if (pix->height < SENSOR_MIN_HEIGHT)
-        pix->height = SENSOR_MIN_HEIGHT;
-    else if (bayer)
-        pix->height = ALIGN(pix->height, 2);
-
-    if (pix->width > SENSOR_MAX_WIDTH)
-        pix->width = SENSOR_MAX_WIDTH;
-    else if (pix->width < SENSOR_MIN_WIDTH)
-        pix->width = SENSOR_MIN_WIDTH;
-    else if (bayer)
-        pix->width = ALIGN(pix->width, 2);
-
-	if (sensor_fmt_catch(pix->width, pix->height, &pix->width, &pix->height) == NULL) {
+    if (mf->height > SENSOR_MAX_HEIGHT)
+        mf->height = SENSOR_MAX_HEIGHT;
+    else if (mf->height < SENSOR_MIN_HEIGHT)
+        mf->height = SENSOR_MIN_HEIGHT;
+
+    if (mf->width > SENSOR_MAX_WIDTH)
+        mf->width = SENSOR_MAX_WIDTH;
+    else if (mf->width < SENSOR_MIN_WIDTH)
+        mf->width = SENSOR_MIN_WIDTH;
+
+	if (sensor_fmt_catch(mf->width, mf->height, &mf->width, &mf->height) == NULL) {
         printk("%s[%d] ERR!!!!!!",__FUNCTION__,__LINE__);
-		pix->width = 0;
-		pix->height = 0;
+		mf->width = 0;
+		mf->height = 0;
 	}
 
     return ret;
@@ -1996,7 +2022,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_format *f)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2388,7 +2414,7 @@ static int sensor_set_focus_mode(struct soc_camera_device *icd, const struct v4l
 #endif
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2447,7 +2473,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     const struct v4l2_queryctrl *qctrl;   
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
@@ -2761,7 +2787,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2786,7 +2812,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2810,7 +2836,7 @@ static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_stream(struct v4l2_subdev *sd, int enable)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
 
 	if (enable == 1) {
@@ -2882,8 +2908,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
         goto sensor_video_probe_err;
     }
 
-    icd->formats = sensor_colour_formats;
-    icd->num_formats = ARRAY_SIZE(sensor_colour_formats);
+
 
     return 0;
 
@@ -2893,7 +2918,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
@@ -2950,7 +2975,15 @@ static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	return ret;
 
 }
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			    enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(sensor_colour_fmts))
+		return -EINVAL;
 
+	*code = sensor_colour_fmts[index].code;
+	return 0;
+}
 static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
 	.init		= sensor_init,
 	.g_ctrl		= sensor_g_control,
@@ -2962,12 +2995,11 @@ static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
 };
 
 static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
-	.s_fmt		= sensor_s_fmt,
-	.g_fmt		= sensor_g_fmt,
-	.try_fmt	= sensor_try_fmt,
-	.s_stream   = sensor_s_stream,
+	.s_mbus_fmt	= sensor_s_fmt,
+	.g_mbus_fmt	= sensor_g_fmt,
+	.try_mbus_fmt	= sensor_try_fmt,
+	.enum_mbus_fmt	= sensor_enum_fmt,
 };
-
 static struct v4l2_subdev_ops sensor_subdev_ops = {
 	.core	= &sensor_subdev_core_ops,
 	.video = &sensor_subdev_video_ops,
@@ -3008,7 +3040,7 @@ static int sensor_probe(struct i2c_client *client,
 
     /* Second stage probe - when a capture adapter is there */
     icd->ops		= &sensor_ops;
-    icd->y_skip_top		= 0;
+    sensor->info_priv.fmt = sensor_colour_fmts[0];
 	#if CONFIG_SENSOR_I2C_NOSCHED
 	atomic_set(&sensor->tasklock_cnt,0);
 	#endif
diff --git a/drivers/media/video/mt9p111.c b/drivers/media/video/mt9p111.c
index 6a38b91ed05d..d65188294379 100644
--- a/drivers/media/video/mt9p111.c
+++ b/drivers/media/video/mt9p111.c
@@ -2861,7 +2861,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 #if (ADJUST_OPTIMIZE_TIME_FALG == 0)
@@ -3144,7 +3144,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -3492,7 +3492,7 @@ static int sensor_cb(void *arg)
 
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
@@ -3681,7 +3681,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -3709,7 +3709,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 }
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -4107,7 +4107,7 @@ static int sensor_set_focus_mode(struct soc_camera_device *icd, const struct v4l
 #endif
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
     SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());
@@ -4167,7 +4167,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -4487,7 +4487,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
     
@@ -4514,7 +4514,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
     
@@ -4540,7 +4540,7 @@ static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_stream(struct v4l2_subdev *sd, int enable)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
 
 	if (enable == 1) {
@@ -4618,7 +4618,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 #if CONFIG_SENSOR_Flash	
diff --git a/drivers/media/video/nt99250.c b/drivers/media/video/nt99250.c
index a5776931de84..4aaaecee8aff 100755
--- a/drivers/media/video/nt99250.c
+++ b/drivers/media/video/nt99250.c
@@ -1446,7 +1446,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -1661,7 +1661,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -1710,7 +1710,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     const struct sensor_datafmt *fmt;
     struct sensor *sensor = to_sensor(client);
     struct reginfo *winseqe_set_addr=NULL;	
@@ -1915,7 +1915,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -1948,7 +1948,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2232,7 +2232,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2291,7 +2291,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -2581,7 +2581,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2606,7 +2606,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2693,7 +2693,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
diff --git a/drivers/media/video/ov2640_rk.c b/drivers/media/video/ov2640_rk.c
new file mode 100755
index 000000000000..d6b1e385668a
--- /dev/null
+++ b/drivers/media/video/ov2640_rk.c
@@ -0,0 +1,2956 @@
+#include <linux/videodev2.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/log2.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/circ_buf.h>
+#include <linux/miscdevice.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/soc_camera.h>
+#include <mach/rk29_camera.h>
+
+static int debug;
+module_param(debug, int, S_IRUGO|S_IWUSR);
+
+#define dprintk(level, fmt, arg...) do {			\
+	if (debug >= level) 					\
+	printk(KERN_WARNING fmt , ## arg); } while (0)
+
+#define SENSOR_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
+#define SENSOR_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)
+
+
+#define _CONS(a,b) a##b
+#define CONS(a,b) _CONS(a,b)
+
+#define __STR(x) #x
+#define _STR(x) __STR(x)
+#define STR(x) _STR(x)
+
+#define MIN(x,y)   ((x<y) ? x: y)
+#define MAX(x,y)    ((x>y) ? x: y)
+
+/* Sensor Driver Configuration */
+#define SENSOR_NAME RK29_CAM_SENSOR_OV2640
+#define SENSOR_V4L2_IDENT V4L2_IDENT_OV2640
+#define SENSOR_ID 0x2642
+#define SENSOR_ID1 0x2641
+#define SENSOR_MIN_WIDTH    640
+#define SENSOR_MIN_HEIGHT   480
+#define SENSOR_MAX_WIDTH    1600
+#define SENSOR_MAX_HEIGHT   1200
+#define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
+#define SENSOR_INIT_HEIGHT  480
+#define SENSOR_INIT_WINSEQADR sensor_vga
+#define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
+
+#define CONFIG_SENSOR_WhiteBalance	0
+#define CONFIG_SENSOR_Brightness	1
+#define CONFIG_SENSOR_Contrast      0
+#define CONFIG_SENSOR_Saturation    1
+#define CONFIG_SENSOR_Effect        1
+#define CONFIG_SENSOR_Scene         0
+#define CONFIG_SENSOR_DigitalZoom   0
+#define CONFIG_SENSOR_Focus         0
+#define CONFIG_SENSOR_Exposure      0
+#define CONFIG_SENSOR_Flash         0
+#define CONFIG_SENSOR_Mirror        0
+#define CONFIG_SENSOR_Flip          0
+
+#define CONFIG_SENSOR_I2C_SPEED     250000       /* Hz */
+/* Sensor write register continues by preempt_disable/preempt_enable for current process not be scheduled */
+#define CONFIG_SENSOR_I2C_NOSCHED   0
+#define CONFIG_SENSOR_I2C_RDWRCHK   0
+
+#define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
+                          SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
+                          SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
+
+#define COLOR_TEMPERATURE_CLOUDY_DN  6500
+#define COLOR_TEMPERATURE_CLOUDY_UP    8000
+#define COLOR_TEMPERATURE_CLEARDAY_DN  5000
+#define COLOR_TEMPERATURE_CLEARDAY_UP    6500
+#define COLOR_TEMPERATURE_OFFICE_DN     3500
+#define COLOR_TEMPERATURE_OFFICE_UP     5000
+#define COLOR_TEMPERATURE_HOME_DN       2500
+#define COLOR_TEMPERATURE_HOME_UP       3500
+
+#define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
+#define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)
+
+struct reginfo
+{
+    u8 reg;
+    u8 val;
+};
+
+/* init 800*600 SVGA */
+static struct reginfo sensor_init_data[] =
+{
+#if 1
+    {0xff,0x01},
+    {0x12,0x80},
+    {0xff,0x00},
+    {0x2c,0xff},
+    {0x2e,0xdf},
+    {0xff,0x01},
+
+    {0x03,0x4f},
+    {0x0f,0x4b},
+
+
+    {0x3c,0x32},
+    {0x11,0x00},
+    {0x09,0x02},
+    {0x04,0xF8},//b7,b6 directs
+    {0x13,0xe5},
+    {0x14,0x48},
+    {0x2c,0x0c},
+    {0x33,0x78},
+    {0x3a,0x33},
+    {0x3b,0xfB},
+    {0x3e,0x00},
+    {0x43,0x11},
+    {0x16,0x10},
+    {0x39,0x02},
+    {0x35,0x88},
+    {0x22,0x09},
+    {0x37,0x40},
+    {0x23,0x00},
+    {0x34,0xa0},
+    {0x36,0x1a},
+    {0x06,0x02},
+    {0x07,0xc0},
+    {0x0d,0xb7},
+    {0x0e,0x01},
+    {0x4c,0x00},
+    {0x4a,0x81},
+    {0x21,0x99},
+    
+    //{0x24,0x58},
+    //{0x25,0x50},
+    //{0x26,0x92},
+    
+    {0x24, 0x70},
+    {0x25, 0x60},
+    {0x26, 0xa4},    
+    
+    {0x5c,0x00},
+    {0x63,0x00},
+    {0x46,0x3f},
+    {0x0c,0x3c},
+    {0x61,0x70},
+    {0x62,0x80},
+    {0x7c,0x05},
+    {0x20,0x80},
+    {0x28,0x30},
+    {0x6c,0x00},
+    {0x6d,0x80},
+    {0x6e,0x00},
+    {0x70,0x02},
+    {0x71,0x94},
+    {0x73,0xc1},
+    {0x3d,0x34},
+    {0x5a,0x57},
+    {0x4f,0xbb},
+    {0x50,0x9c},
+    {0xff,0x00},
+    {0xe5,0x7f},
+    {0xf9,0xc0},
+    {0x41,0x24},
+    {0xe0,0x14},
+    {0x76,0xff},
+    {0x33,0xa0},
+    {0x42,0x20},
+    {0x43,0x18},
+    {0x4c,0x00},
+    {0x87,0xd0},
+    {0x88,0x3f},
+    {0xd7,0x03},
+    {0xd9,0x10},
+    {0xd3,0x82},
+    {0xc8,0x08},
+    {0xc9,0x80},
+    {0x7c,0x00},
+    {0x7d,0x00},//0x00//0x07
+    {0x7c,0x03},
+    {0x7d,0x48},//0x48//0x40
+    {0x7d,0x48},//0x48//0x40
+    {0x7c,0x08},
+    {0x7d,0x20},
+    {0x7d,0x10},//0x10
+    {0x7d,0x0e},//0x0e
+
+    {0x92,0x00},
+    {0x93,0x06},
+    {0x93,0xc8},//e3
+    {0x93,0x05},
+    {0x93,0x05},
+    {0x93,0x00},
+    {0x93,0x04},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x93,0x00},
+    {0x96,0x00},
+    {0x97,0x08},
+    {0x97,0x19},
+    {0x97,0x02},
+    {0x97,0x0c},
+    {0x97,0x24},
+    {0x97,0x30},
+    {0x97,0x28},
+    {0x97,0x26},
+    {0x97,0x02},
+    {0x97,0x98},
+    {0x97,0x80},
+    {0x97,0x00},
+    {0x97,0x00},
+    {0xc3,0xef},//ed
+    {0xa4,0x00},
+    {0xa8,0x00},
+
+    {0xbf, 0x00},
+    {0xba, 0xdc},
+    {0xbb, 0x08},
+    {0xb6, 0x20},
+    {0xb8, 0x30},
+    {0xb7, 0x20},
+    {0xb9, 0x30},
+    {0xb3, 0xb4},
+    {0xb4, 0xca},
+    {0xb5, 0x34},
+    {0xb0, 0x46},
+    {0xb1, 0x46},
+    {0xb2, 0x06},
+    {0xc7, 0x00},
+    {0xc6, 0x51},
+    {0xc5, 0x11},
+    {0xc4, 0x9c},
+////
+    {0xc0,0xc8},
+    {0xc1,0x96},
+    {0x86,0x3d},
+    {0x50,0x92},
+    {0x51,0x90},
+    {0x52,0x2c},
+    {0x53,0x00},
+    {0x54,0x00},
+    {0x55,0x88},
+    {0x57,0x00},
+    {0x5a,0x50},
+    {0x5b,0x3c},
+    {0x5c,0x00},
+    {0xc3,0xed},
+    {0x7f,0x00},
+    {0xda,0x01},
+    {0xe5,0x1f},
+    {0xe1,0x67},
+    {0xe0,0x00},
+    {0xdd,0xff},
+    {0x05,0x00},
+
+#endif
+#if 1
+    {0xff, 0x01},
+    {0x5d, 0x00},
+    {0x5e, 0x3c},
+    {0x5f, 0x28},
+    {0x60, 0x55},
+
+
+    {0xff, 0x00},
+    {0xc3, 0xef},
+    {0xa6, 0x00},
+    {0xa7, 0x0f},
+    {0xa7, 0x4e},
+    {0xa7, 0x7a},
+    {0xa7, 0x33},
+    {0xa7, 0x00},
+    {0xa7, 0x23},
+    {0xa7, 0x27},
+    {0xa7, 0x3a},
+    {0xa7, 0x70},
+    {0xa7, 0x33},
+    {0xa7, 0x00},//L
+    {0xa7, 0x23},
+    {0xa7, 0x20},
+    {0xa7, 0x0c},
+    {0xa7, 0x66},
+    {0xa7, 0x33},
+    {0xa7, 0x00},
+    {0xa7, 0x23},
+    {0xc3, 0xef},
+#endif
+
+
+#if 1
+    {0xff,0x00},
+    {0x92,0x00},
+    {0x93,0x06},
+    {0x93,0xc1},//e
+    {0x93,0x02},
+    {0x93,0x02},
+    {0x93,0x00},
+    {0x93,0x04},
+#endif
+
+    {0x03, 0x0f},
+    {0xe0, 0x04},
+    {0xc0, 0xc8},
+    {0xc1, 0x96},
+    {0x86, 0x3d},
+    {0x50, 0x89},
+    {0x51, 0x90},
+    {0x52, 0x2c},
+    {0x53, 0x00},
+    {0x54, 0x00},
+    {0x55, 0x88},
+    {0x57, 0x00},
+    {0x5a, 0xa0},
+    {0x5b, 0x78},
+    {0x5c, 0x00},
+    {0xd3, 0x04},
+    {0xe0, 0x00},
+
+  {0x0, 0x0}   //end flag
+
+};
+
+/* 1600X1200 UXGA */
+static struct reginfo sensor_uxga[] =
+{
+    {0xff, 0x00},
+    {0xe0, 0x04},
+    {0xc0, 0xc8},
+    {0xc1, 0x96},
+    {0x86, 0x3d},
+    {0x50, 0x00},
+    {0x51, 0x90},
+    {0x52, 0x2c},
+    {0x53, 0x00},
+    {0x54, 0x00},
+    {0x55, 0x88},
+    {0x57, 0x00},
+    {0x5a, 0x90},
+    {0x5b, 0x2c},
+    {0x5c, 0x05},
+    {0xd3, 0x82},
+    {0xe0, 0x00},
+  {0x0, 0x0}   //end flag
+};
+
+/* 1280X1024 SXGA */
+static struct reginfo sensor_sxga[] =
+{
+    {0xff, 0x00},
+    {0xe0, 0x04},
+    {0xc0, 0xc8},
+    {0xc1, 0x96},
+    {0x86, 0x3d},
+    {0x50, 0x00},
+    {0x51, 0x90},
+    {0x52, 0x2c},
+    {0x53, 0x00},
+    {0x54, 0x00},
+    {0x55, 0x88},
+    {0x57, 0x00},
+    {0x5a, 0x40},
+    {0x5b, 0x00},
+    {0x5c, 0x05},
+    {0xd3, 0x82},
+    {0xe0, 0x00},
+  {0x0, 0x0}   //end flag
+};
+
+
+static struct reginfo sensor_xga[] =
+{
+    {0xff, 0x00},
+    {0xe0, 0x04},
+    {0xc0, 0xc8},
+    {0xc1, 0x96},
+    {0x86, 0x3d},
+    {0x50, 0x00},
+    {0x51, 0x90},
+    {0x52, 0x2c},
+    {0x53, 0x00},
+    {0x54, 0x00},
+    {0x55, 0x88},
+    {0x57, 0x00},
+    {0x5a, 0x40},
+    {0x5b, 0x00},
+    {0x5c, 0x05},
+    {0xd3, 0x82},
+    {0xe0, 0x00},
+  {0x0, 0x0}   //end flag
+
+
+};
+
+
+/* 800X600 SVGA*/
+static struct reginfo sensor_svga[] =
+{
+  {0x0, 0x0}   //end flag
+};
+
+/* 640X480 VGA */
+static struct reginfo sensor_vga[] =
+{
+   {0x0, 0x0}   //end flag
+ };
+
+/* 352X288 CIF */
+static struct reginfo sensor_cif[] =
+{
+  {0x0, 0x0}   //end flag
+};
+
+/* 320*240 QVGA */
+static  struct reginfo sensor_qvga[] =
+{
+  {0x0, 0x0}   //end flag
+};
+
+/* 176X144 QCIF*/
+static struct reginfo sensor_qcif[] =
+{
+  {0x0, 0x0}   //end flag
+};
+#if 0
+/* 160X120 QQVGA*/
+static struct reginfo ov2655_qqvga[] =
+{
+
+    {0x300E, 0x34},
+    {0x3011, 0x01},
+    {0x3012, 0x10},
+    {0x302a, 0x02},
+    {0x302b, 0xE6},
+    {0x306f, 0x14},
+    {0x3362, 0x90},
+
+    {0x3070, 0x5d},
+    {0x3072, 0x5d},
+    {0x301c, 0x07},
+    {0x301d, 0x07},
+
+    {0x3020, 0x01},
+    {0x3021, 0x18},
+    {0x3022, 0x00},
+    {0x3023, 0x06},
+    {0x3024, 0x06},
+    {0x3025, 0x58},
+    {0x3026, 0x02},
+    {0x3027, 0x61},
+    {0x3088, 0x00},
+    {0x3089, 0xa0},
+    {0x308a, 0x00},
+    {0x308b, 0x78},
+    {0x3316, 0x64},
+    {0x3317, 0x25},
+    {0x3318, 0x80},
+    {0x3319, 0x08},
+    {0x331a, 0x0a},
+    {0x331b, 0x07},
+    {0x331c, 0x80},
+    {0x331d, 0x38},
+    {0x3100, 0x00},
+    {0x3302, 0x11},
+
+    {0x0, 0x0},
+};
+
+
+
+static  struct reginfo ov2655_Sharpness_auto[] =
+{
+    {0x3306, 0x00},
+};
+
+static  struct reginfo ov2655_Sharpness1[] =
+{
+    {0x3306, 0x08},
+    {0x3371, 0x00},
+};
+
+static  struct reginfo ov2655_Sharpness2[][3] =
+{
+    //Sharpness 2
+    {0x3306, 0x08},
+    {0x3371, 0x01},
+};
+
+static  struct reginfo ov2655_Sharpness3[] =
+{
+    //default
+    {0x3306, 0x08},
+    {0x332d, 0x02},
+};
+static  struct reginfo ov2655_Sharpness4[]=
+{
+    //Sharpness 4
+    {0x3306, 0x08},
+    {0x332d, 0x03},
+};
+
+static  struct reginfo ov2655_Sharpness5[] =
+{
+    //Sharpness 5
+    {0x3306, 0x08},
+    {0x332d, 0x04},
+};
+#endif
+
+static  struct reginfo sensor_ClrFmt_YUYV[]=
+{
+    //{0x4300, 0x30},
+    {0x00, 0x00}
+};
+
+static  struct reginfo sensor_ClrFmt_UYVY[]=
+{
+    //{0x4300, 0x32},
+    {0x00, 0x00}
+};
+
+#if CONFIG_SENSOR_WhiteBalance
+static  struct reginfo sensor_WhiteB_Auto[]=
+{
+    {0x3406, 0x00},  //AWB auto, bit[1]:0,auto
+    {0x0000, 0x00}
+};
+/* Cloudy Colour Temperature : 6500K - 8000K  */
+static  struct reginfo sensor_WhiteB_Cloudy[]=
+{
+    {0x3406, 0x01},
+    {0x3400, 0x07},
+    {0x3401, 0x08},
+    {0x3402, 0x04},
+    {0x3403, 0x00},
+    {0x3404, 0x05},
+    {0x3405, 0x00},
+    {0x0000, 0x00}
+};
+/* ClearDay Colour Temperature : 5000K - 6500K  */
+static  struct reginfo sensor_WhiteB_ClearDay[]=
+{
+    //Sunny
+    {0x3406, 0x01},
+    {0x3400, 0x07},
+    {0x3401, 0x02},
+    {0x3402, 0x04},
+    {0x3403, 0x00},
+    {0x3404, 0x05},
+    {0x3405, 0x15},
+    {0x0000, 0x00}
+};
+/* Office Colour Temperature : 3500K - 5000K  */
+static  struct reginfo sensor_WhiteB_TungstenLamp1[]=
+{
+    //Office
+    {0x3406, 0x01},
+    {0x3400, 0x06},
+    {0x3401, 0x2a},
+    {0x3402, 0x04},
+    {0x3403, 0x00},
+    {0x3404, 0x07},
+    {0x3405, 0x24},
+    {0x0000, 0x00}
+
+};
+/* Home Colour Temperature : 2500K - 3500K  */
+static  struct reginfo sensor_WhiteB_TungstenLamp2[]=
+{
+    //Home
+    {0x3406, 0x01},
+    {0x3400, 0x04},
+    {0x3401, 0x58},
+    {0x3402, 0x04},
+    {0x3403, 0x00},
+    {0x3404, 0x07},
+    {0x3405, 0x24},
+    {0x0000, 0x00}
+};
+static struct reginfo *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,
+    sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,
+};
+#endif
+
+#if CONFIG_SENSOR_Brightness
+static  struct reginfo sensor_Brightness0[]=
+{
+    // Brightness -2
+    {0xff, 0x01},
+    {0x24, 0x34},
+    {0x25, 0x22},
+    {0x26, 0x70},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness1[]=
+{
+    // Brightness -1
+
+    {0xff, 0x01},
+    {0x24, 0x58},
+    {0x25, 0x50},
+    {0x26, 0x92},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness2[]=
+{
+    //  Brightness 0
+
+	{0xff, 0x01},
+	{0x24, 0xa8},
+	{0x25, 0x90},
+	{0x26, 0xd6},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness3[]=
+{
+    // Brightness +1
+
+    {0xff, 0x01},
+    {0x24, 0x48},
+    {0x25, 0x40},
+    {0x26, 0x81},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness4[]=
+{
+    //  Brightness +2
+
+    {0xff, 0x01},
+    {0x24, 0x58},
+    {0x25, 0x50},
+    {0x26, 0x92},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Brightness5[]=
+{
+    //  Brightness +3
+    {0xff, 0x01},
+    {0x24, 0x70},
+    {0x25, 0x60},
+    {0x26, 0xa4},
+  {0x0, 0x0}   //end flag
+};
+static struct reginfo *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,
+    sensor_Brightness4, sensor_Brightness5,NULL,
+};
+
+#endif
+
+#if CONFIG_SENSOR_Effect
+static  struct reginfo sensor_Effect_Normal[] =
+{
+	{0xff,0x00},
+	{0x7c,0x00},
+	{0x7d,0x00},
+	{0x7c,0x05},
+	{0x7d,0x80},
+	{0x7d,0x80},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_WandB[] =
+{
+    {0xff,0x00},
+    {0x7c,0x00},
+    {0x7d,0x18},
+    {0x7c,0x05},
+    {0x7d,0x80},
+    {0x7d,0x80},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_Sepia[] =
+{
+    {0xff,0x00},
+    {0x7c,0x00},
+    {0x7d,0x18},
+    {0x7c,0x05},
+    {0x7d,0x40},
+    {0x7d,0xc0},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_Negative[] =
+{
+    {0xff,0x00},
+    {0x7c,0x00},
+    {0x7d,0x40},
+    {0x7c,0x05},
+    {0x7d,0x80},
+    {0x7d,0x80},
+  {0x0, 0x0}   //end flag
+};
+static  struct reginfo sensor_Effect_Bluish[] =
+{
+    {0Xff, 0X00},
+    {0X7c, 0X00},
+    {0X7d, 0X18},
+    {0X7c, 0X05},
+    {0X7d, 0Xa0},
+    {0X7d, 0X40},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_Green[] =
+{
+    {0Xff, 0X00},
+    {0X7c, 0X00},
+    {0X7d, 0X18},
+    {0X7c, 0X05},
+    {0X7d, 0X40},
+    {0X7d, 0X40},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Effect_Exp_Windows_Half[] =
+{
+	{0xff, 0x01},
+	{0x5d, 0x00},
+	{0x5e, 0x3c},
+	{0x5f, 0x28},
+	{0x60, 0x55},
+  {0x0, 0x0}   //end flag
+};
+static struct reginfo *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_WandB, sensor_Effect_Negative,sensor_Effect_Sepia,
+    sensor_Effect_Bluish, sensor_Effect_Green,NULL,
+};
+#endif
+#if CONFIG_SENSOR_Exposure
+static  struct reginfo sensor_Exposure0[]=
+{
+	{0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure1[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure2[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure3[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure4[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure5[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_Exposure6[]=
+{
+    {0x0000, 0x00}
+};
+
+static struct reginfo *sensor_ExposureSeqe[] = {sensor_Exposure0, sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,
+    sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,NULL,
+};
+#endif
+#if CONFIG_SENSOR_Saturation
+static  struct reginfo sensor_Saturation0[]=
+{
+	{0xff, 0x00},
+	{0x90, 0x00},
+	{0x91, 0x0e},
+	{0x91, 0x1a},
+	{0x91, 0x31},
+	{0x91, 0x5a},
+	{0x91, 0x69},
+	{0x91, 0x75},
+	{0x91, 0x7e},
+	{0x91, 0x88},
+	{0x91, 0x8f},
+	{0x91, 0x96},
+	{0x91, 0xa3},
+	{0x91, 0xaf},
+	{0x91, 0xc4},
+	{0x91, 0xd7},
+	{0x91, 0xe8},
+	{0x91, 0x20},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Saturation1[]=
+{
+    {0xff, 0x00},
+    {0x90, 0x00},
+    {0x91, 0x03},
+    {0x91, 0x0a},
+    {0x91, 0x1a},
+    {0x91, 0x3f},
+    {0x91, 0x4e},
+    {0x91, 0x5b},
+    {0x91, 0x68},
+    {0x91, 0x75},
+    {0x91, 0x7f},
+    {0x91, 0x89},
+    {0x91, 0x9a},
+    {0x91, 0xa6},
+    {0x91, 0xbd},
+    {0x91, 0xd3},
+    {0x91, 0xe5},
+    {0x91, 0x24},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Saturation2[]=
+{
+    {0xff, 0x00},
+    {0x90, 0x00},
+    {0x91, 0x04},
+    {0x91, 0x07},
+    {0x91, 0x10},
+    {0x91, 0x28},
+    {0x91, 0x36},
+    {0x91, 0x44},
+    {0x91, 0x52},
+    {0x91, 0x60},
+    {0x91, 0x6c},
+    {0x91, 0x78},
+    {0x91, 0x8c},
+    {0x91, 0x9e},
+    {0x91, 0xbb},
+    {0x91, 0xd3},
+    {0x91, 0xe5},
+    {0x91, 0x24},
+  {0x0, 0x0}   //end flag	
+};
+static struct reginfo *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};
+
+
+#endif
+#if CONFIG_SENSOR_Contrast
+static  struct reginfo sensor_Contrast0[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x10},
+    {0x7d, 0x4a},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+
+};
+
+static  struct reginfo sensor_Contrast1[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x14},
+    {0x7d, 0x40},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast2[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x18},
+    {0x7d, 0x34},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast3[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x1c},
+    {0x7d, 0x2a},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast4[]=
+{
+    {0xff,0x00},
+    {0x7c,0x00},
+    {0x7d,0x04},
+    {0x7c,0x07},
+    {0x7d,0x20},
+    {0x7d,0x24},
+    {0x7d,0x16},
+    {0x7d,0x06},
+  {0x0, 0x0}   //end flag
+};
+
+
+static  struct reginfo sensor_Contrast5[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x20},
+    {0x7d, 0x20},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast6[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x24},
+    {0x7d, 0x16},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+
+static  struct reginfo sensor_Contrast7[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x28},
+    {0x7d, 0x0c},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast8[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x2c},
+    {0x7d, 0x02},
+    {0x7d, 0x06},
+  {0x0, 0x0}   //end flag
+};
+
+static  struct reginfo sensor_Contrast9[]=
+{
+    {0xff, 0x00},
+    {0x7c, 0x00},
+    {0x7d, 0x04},
+    {0x7c, 0x07},
+    {0x7d, 0x20},
+    {0x7d, 0x30},
+    {0x7d, 0x08},
+    {0x7d, 0x0e},
+  {0x0, 0x0}   //end flag
+};
+
+
+
+static struct reginfo *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,
+    sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,
+};
+
+#endif
+#if CONFIG_SENSOR_Mirror
+static  struct reginfo sensor_MirrorOn[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_MirrorOff[]=
+{
+    {0x0000, 0x00}
+};
+static struct reginfo *sensor_MirrorSeqe[] = {sensor_MirrorOff, sensor_MirrorOn,NULL,};
+#endif
+#if CONFIG_SENSOR_Flip
+static  struct reginfo sensor_FlipOn[]=
+{
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_FlipOff[]=
+{
+    {0x0000, 0x00}
+};
+static struct reginfo *sensor_FlipSeqe[] = {sensor_FlipOff, sensor_FlipOn,NULL,};
+
+#endif
+#if CONFIG_SENSOR_Scene
+static  struct reginfo sensor_SceneAuto[] =
+{
+    {0x3a00, 0x78},
+    {0x0000, 0x00}
+};
+
+static  struct reginfo sensor_SceneNight[] =
+{
+    {0x3003, 0x80},
+	{0x3004, 0x20},
+	{0x3005, 0x18},
+	{0x3006, 0x0d},
+	{0x3a00, 0x7c},
+	{0x3a02 ,0x07},
+	{0x3a03 ,0x38},
+	{0x3a14 ,0x07},
+	{0x3a15 ,0x38},
+    {0x0000, 0x00}
+};
+static struct reginfo *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight,NULL,};
+
+#endif
+#if CONFIG_SENSOR_DigitalZoom
+static struct reginfo sensor_Zoom0[] =
+{
+    {0x0, 0x0},
+};
+
+static struct reginfo sensor_Zoom1[] =
+{
+     {0x0, 0x0},
+};
+
+static struct reginfo sensor_Zoom2[] =
+{
+    {0x0, 0x0},
+};
+
+
+static struct reginfo sensor_Zoom3[] =
+{
+    {0x0, 0x0},
+};
+static struct reginfo *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL,};
+#endif
+static const struct v4l2_querymenu sensor_menus[] =
+{
+	#if CONFIG_SENSOR_WhiteBalance
+    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 0,  .name = "auto",  .reserved = 0, }, {  .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 1, .name = "incandescent",  .reserved = 0,},
+    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 2,  .name = "fluorescent", .reserved = 0,}, {  .id = V4L2_CID_DO_WHITE_BALANCE, .index = 3,  .name = "daylight", .reserved = 0,},
+    { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 4,  .name = "cloudy-daylight", .reserved = 0,},
+    #endif
+
+	#if CONFIG_SENSOR_Effect
+    { .id = V4L2_CID_EFFECT,  .index = 0,  .name = "none",  .reserved = 0, }, {  .id = V4L2_CID_EFFECT,  .index = 1, .name = "mono",  .reserved = 0,},
+    { .id = V4L2_CID_EFFECT,  .index = 2,  .name = "negative", .reserved = 0,}, {  .id = V4L2_CID_EFFECT, .index = 3,  .name = "sepia", .reserved = 0,},
+    { .id = V4L2_CID_EFFECT,  .index = 4, .name = "posterize", .reserved = 0,} ,{ .id = V4L2_CID_EFFECT,  .index = 5,  .name = "aqua", .reserved = 0,},
+    #endif
+
+	#if CONFIG_SENSOR_Scene
+    { .id = V4L2_CID_SCENE,  .index = 0, .name = "auto", .reserved = 0,} ,{ .id = V4L2_CID_SCENE,  .index = 1,  .name = "night", .reserved = 0,},
+    #endif
+
+	#if CONFIG_SENSOR_Flash
+    { .id = V4L2_CID_FLASH,  .index = 0,  .name = "off",  .reserved = 0, }, {  .id = V4L2_CID_FLASH,  .index = 1, .name = "auto",  .reserved = 0,},
+    { .id = V4L2_CID_FLASH,  .index = 2,  .name = "on", .reserved = 0,}, {  .id = V4L2_CID_FLASH, .index = 3,  .name = "torch", .reserved = 0,},
+    #endif
+};
+
+static const struct v4l2_queryctrl sensor_controls[] =
+{
+	#if CONFIG_SENSOR_WhiteBalance
+    {
+        .id		= V4L2_CID_DO_WHITE_BALANCE,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "White Balance Control",
+        .minimum	= 0,
+        .maximum	= 4,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Brightness
+	{
+        .id		= V4L2_CID_BRIGHTNESS,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Brightness Control",
+        .minimum	= -3,
+        .maximum	= 2,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Effect
+	{
+        .id		= V4L2_CID_EFFECT,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "Effect Control",
+        .minimum	= 0,
+        .maximum	= 5,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+
+	#if CONFIG_SENSOR_Exposure
+	{
+        .id		= V4L2_CID_EXPOSURE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Exposure Control",
+        .minimum	= 0,
+        .maximum	= 6,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+
+	#if CONFIG_SENSOR_Saturation
+	{
+        .id		= V4L2_CID_SATURATION,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Saturation Control",
+        .minimum	= 0,
+        .maximum	= 2,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Contrast
+	{
+        .id		= V4L2_CID_CONTRAST,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Contrast Control",
+        .minimum	= -3,
+        .maximum	= 3,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+
+	#if CONFIG_SENSOR_Mirror
+	{
+        .id		= V4L2_CID_HFLIP,
+        .type		= V4L2_CTRL_TYPE_BOOLEAN,
+        .name		= "Mirror Control",
+        .minimum	= 0,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 1,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Flip
+	{
+        .id		= V4L2_CID_VFLIP,
+        .type		= V4L2_CTRL_TYPE_BOOLEAN,
+        .name		= "Flip Control",
+        .minimum	= 0,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 1,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Scene
+    {
+        .id		= V4L2_CID_SCENE,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "Scene Control",
+        .minimum	= 0,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_DigitalZoom
+    {
+        .id		= V4L2_CID_ZOOM_RELATIVE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "DigitalZoom Control",
+        .minimum	= -1,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 0,
+    }, {
+        .id		= V4L2_CID_ZOOM_ABSOLUTE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "DigitalZoom Control",
+        .minimum	= 0,
+        .maximum	= 3,
+        .step		= 1,
+        .default_value = 0,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Focus
+	{
+        .id		= V4L2_CID_FOCUS_RELATIVE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Focus Control",
+        .minimum	= -1,
+        .maximum	= 1,
+        .step		= 1,
+        .default_value = 0,
+    }, {
+        .id		= V4L2_CID_FOCUS_ABSOLUTE,
+        .type		= V4L2_CTRL_TYPE_INTEGER,
+        .name		= "Focus Control",
+        .minimum	= 0,
+        .maximum	= 255,
+        .step		= 1,
+        .default_value = 125,
+    },
+    #endif
+
+	#if CONFIG_SENSOR_Flash
+	{
+        .id		= V4L2_CID_FLASH,
+        .type		= V4L2_CTRL_TYPE_MENU,
+        .name		= "Flash Control",
+        .minimum	= 0,
+        .maximum	= 3,
+        .step		= 1,
+        .default_value = 0,
+    },
+	#endif
+};
+
+static int sensor_probe(struct i2c_client *client, const struct i2c_device_id *did);
+static int sensor_video_probe(struct soc_camera_device *icd, struct i2c_client *client);
+static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+static int sensor_g_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
+static int sensor_s_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
+static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);
+static int sensor_resume(struct soc_camera_device *icd);
+static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);
+static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);
+#if CONFIG_SENSOR_Effect
+static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
+#endif
+#if CONFIG_SENSOR_WhiteBalance
+static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
+#endif
+static int sensor_deactivate(struct i2c_client *client);
+
+static struct soc_camera_ops sensor_ops =
+{
+    .suspend                     = sensor_suspend,
+    .resume                       = sensor_resume,
+    .set_bus_param		= sensor_set_bus_param,
+    .query_bus_param	= sensor_query_bus_param,
+    .controls		= sensor_controls,
+    .menus                         = sensor_menus,
+    .num_controls		= ARRAY_SIZE(sensor_controls),
+    .num_menus		= ARRAY_SIZE(sensor_menus),
+};
+
+/* only one fixed colorspace per pixelcode */
+struct sensor_datafmt {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+};
+
+/* Find a data format by a pixel code in an array */
+static const struct sensor_datafmt *sensor_find_datafmt(
+	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
+	int n)
+{
+	int i;
+	for (i = 0; i < n; i++)
+		if (fmt[i].code == code)
+			return fmt + i;
+
+	return NULL;
+}
+
+static const struct sensor_datafmt sensor_colour_fmts[] = {
+    {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
+    {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
+};
+
+typedef struct sensor_info_priv_s
+{
+    int whiteBalance;
+    int brightness;
+    int contrast;
+    int saturation;
+    int effect;
+    int scene;
+    int digitalzoom;
+    int focus;
+    int flash;
+    int exposure;
+	bool snap2preview;
+	bool video2preview;
+    unsigned char mirror;                                        /* HFLIP */
+    unsigned char flip;                                          /* VFLIP */
+    unsigned int winseqe_cur_addr;
+    struct sensor_datafmt fmt;
+
+} sensor_info_priv_t;
+
+struct sensor
+{
+    struct v4l2_subdev subdev;
+    struct i2c_client *client;
+    sensor_info_priv_t info_priv;
+    int model;	/* V4L2_IDENT_OV* codes from v4l2-chip-ident.h */
+#if CONFIG_SENSOR_I2C_NOSCHED
+	atomic_t tasklock_cnt;
+#endif
+	struct rk29camera_platform_data *sensor_io_request;
+    struct rk29camera_gpio_res *sensor_gpio_res;
+};
+
+static struct sensor* to_sensor(const struct i2c_client *client)
+{
+    return container_of(i2c_get_clientdata(client), struct sensor, subdev);
+}
+
+static int sensor_task_lock(struct i2c_client *client, int lock)
+{
+#if CONFIG_SENSOR_I2C_NOSCHED
+	int cnt = 3;
+    struct sensor *sensor = to_sensor(client);
+
+	if (lock) {
+		if (atomic_read(&sensor->tasklock_cnt) == 0) {
+			while ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt>0)) {
+				SENSOR_TR("\n %s will obtain i2c in atomic, but i2c bus is locked! Wait...\n",SENSOR_NAME_STRING());
+				msleep(35);
+				cnt--;
+			}
+			if ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt<=0)) {
+				SENSOR_TR("\n %s obtain i2c fail in atomic!!\n",SENSOR_NAME_STRING());
+				goto sensor_task_lock_err;
+			}
+			preempt_disable();
+		}
+
+		atomic_add(1, &sensor->tasklock_cnt);
+	} else {
+		if (atomic_read(&sensor->tasklock_cnt) > 0) {
+			atomic_sub(1, &sensor->tasklock_cnt);
+
+			if (atomic_read(&sensor->tasklock_cnt) == 0)
+				preempt_enable();
+		}
+	}
+	return 0;
+sensor_task_lock_err:
+	return -1;  
+#else
+    return 0;
+#endif
+
+}
+static int sensor_write(struct i2c_client *client, u8 reg, u8 val)
+{
+    int err,cnt;
+    u8 buf[2];
+    struct i2c_msg msg[1];
+
+    buf[0] = reg & 0xFF;
+    buf[1] = val;
+
+    msg->addr = client->addr;
+    msg->flags = client->flags;
+    msg->buf = buf;
+    msg->len = sizeof(buf);
+    msg->scl_rate = CONFIG_SENSOR_I2C_SPEED;                                        /* ddl@rock-chips.com : 100kHz */
+    msg->read_type = 0;               /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */
+
+    cnt = 3;
+    err = -EAGAIN;
+
+    while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
+        err = i2c_transfer(client->adapter, msg, 1);
+
+        if (err >= 0) {
+            return 0;
+        } else {
+            SENSOR_TR("\n %s write reg(0x%x, val:0x%x) failed, try to write again!\n",SENSOR_NAME_STRING(),reg, val);
+            udelay(10);
+        }
+    }
+
+    return err;
+}
+
+/* sensor register read */
+static int sensor_read(struct i2c_client *client, u8 reg, u8 *val)
+{
+    int err,cnt;
+    u8 buf[1];
+    struct i2c_msg msg[2];
+
+    buf[0] = reg ;//>> 8;
+   // buf[1] = 0;
+
+    msg[0].addr = client->addr;
+    msg[0].flags = client->flags;
+    msg[0].buf = buf;
+    msg[0].len = sizeof(buf);
+    msg[0].scl_rate = CONFIG_SENSOR_I2C_SPEED;       /* ddl@rock-chips.com : 100kHz */
+    msg[0].read_type = 2;//0x55;   /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
+
+    msg[1].addr = client->addr;
+    msg[1].flags = client->flags|I2C_M_RD;
+    msg[1].buf = buf;
+    msg[1].len = 1;
+    msg[1].scl_rate = CONFIG_SENSOR_I2C_SPEED;                       /* ddl@rock-chips.com : 100kHz */
+    msg[1].read_type = 2;                             /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
+
+    cnt = 3;
+    err = -EAGAIN;
+    while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
+        err = i2c_transfer(client->adapter, msg, 2);
+
+        if (err >= 0) {
+            *val = buf[0];
+            return 0;
+        } else {
+        	SENSOR_TR("\n %s read reg(0x%x val:0x%x) failed, try to read again! \n",SENSOR_NAME_STRING(),reg, *val);
+            udelay(10);
+        }
+    }
+
+    return err;
+}
+
+/* write a array of registers  */
+static int sensor_write_array(struct i2c_client *client, struct reginfo *regarray)
+{
+    int err = 0, cnt;
+    int i = 0;
+#if CONFIG_SENSOR_I2C_RDWRCHK    
+	char valchk;
+#endif
+
+	cnt = 0;
+	if (sensor_task_lock(client, 1) < 0)
+		goto sensor_write_array_end;
+    while (regarray[i].reg != 0)
+    {
+        err = sensor_write(client, regarray[i].reg, regarray[i].val);
+        if (err < 0)
+        {
+            if (cnt-- > 0) {
+			    SENSOR_TR("%s..write failed current reg:0x%x, Write array again !\n", SENSOR_NAME_STRING(),regarray[i].reg);
+				i = 0;
+				continue;
+            } else {
+                SENSOR_TR("%s..write array failed!!!\n", SENSOR_NAME_STRING());
+                err = -EPERM;
+				goto sensor_write_array_end;
+            }
+        } else {
+        #if CONFIG_SENSOR_I2C_RDWRCHK
+			sensor_read(client, regarray[i].reg, &valchk);
+			if (valchk != regarray[i].val)
+				SENSOR_TR("%s Reg:0x%x write(0x%x, 0x%x) fail\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
+		#endif
+        }
+        i++;
+    }
+
+sensor_write_array_end:
+	sensor_task_lock(client,0);
+	return err;
+}
+#if CONFIG_SENSOR_I2C_RDWRCHK
+static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regarray)
+{
+    int cnt;
+    int i = 0;
+	char valchk;
+
+	cnt = 0;
+	valchk = 0;
+    while (regarray[i].reg != 0)
+    {
+		sensor_read(client, regarray[i].reg, &valchk);
+		if (valchk != regarray[i].val)
+			SENSOR_TR("%s Reg:0x%x read(0x%x, 0x%x) error\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
+
+        i++;
+    }
+    return 0;
+}
+#endif
+static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
+{
+	struct soc_camera_link *icl = to_soc_camera_link(icd);
+	int ret = 0;
+
+    SENSOR_DG("%s %s  cmd(%d) on(%d)\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd,on);
+
+	switch (cmd)
+	{
+		case Sensor_PowerDown:
+		{
+			if (icl->powerdown) {
+				ret = icl->powerdown(icd->pdev, on);
+				if (ret == RK29_CAM_IO_SUCCESS) {
+					if (on == 0) {
+						mdelay(2);
+						if (icl->reset)
+							icl->reset(icd->pdev);
+					}
+				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
+					ret = -ENODEV;
+					goto sensor_power_end;
+				}
+			}
+			break;
+		}
+		case Sensor_Flash:
+		{
+			struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    		struct sensor *sensor = to_sensor(client);
+
+			if (sensor->sensor_io_request && sensor->sensor_io_request->sensor_ioctrl) {
+				sensor->sensor_io_request->sensor_ioctrl(icd->pdev,Cam_Flash, on);
+			}
+            break;
+		}
+		default:
+		{
+			SENSOR_TR("%s %s cmd(0x%x) is unknown!",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
+			break;
+		}
+	}
+sensor_power_end:
+	return ret;
+}
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct sensor *sensor = to_sensor(client);
+	const struct v4l2_queryctrl *qctrl;
+    const struct sensor_datafmt *fmt;
+    char value;
+    int ret,pid = 0;
+
+    SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
+
+	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
+		ret = -ENODEV;
+		goto sensor_INIT_ERR;
+	}
+
+    /* soft reset */
+	if (sensor_task_lock(client,1)<0)
+		goto sensor_INIT_ERR;
+    ret = sensor_write(client, 0xff, 1);
+    ret |= sensor_write(client, 0x12, 0x80);
+    if (ret != 0)
+    {
+        SENSOR_TR("%s soft reset sensor failed\n",SENSOR_NAME_STRING());
+        ret = -ENODEV;
+		goto sensor_INIT_ERR;
+    }
+
+    mdelay(5);  //delay 5 microseconds
+	/* check if it is an sensor sensor */
+    ret = sensor_write(client, 0xff, 1);
+    ret |= sensor_read(client, 0x0a, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id high byte failed\n");
+        ret = -ENODEV;
+        goto sensor_INIT_ERR;
+    }
+
+    pid = value << 8;
+    ret = sensor_read(client, 0x0b, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id low byte failed\n");
+        ret = -ENODEV;
+        goto sensor_INIT_ERR;
+    }
+
+    pid |= (value & 0xff);
+
+    SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+    if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
+        sensor->model = SENSOR_V4L2_IDENT;
+    } else {
+        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+        ret = -ENODEV;
+        goto sensor_INIT_ERR;
+    }
+
+    ret = sensor_write_array(client, sensor_init_data);
+    if (ret != 0)
+    {
+        SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
+        goto sensor_INIT_ERR;
+    }
+	sensor_task_lock(client,0);
+    sensor->info_priv.winseqe_cur_addr  = (int)SENSOR_INIT_WINSEQADR;
+    fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
+    if (!fmt) {
+        SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
+        ret = -EINVAL;
+        goto sensor_INIT_ERR;
+    }
+	sensor->info_priv.fmt = *fmt;
+
+    /* sensor sensor information for initialization  */
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
+	if (qctrl)
+    	sensor->info_priv.whiteBalance = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_BRIGHTNESS);
+	if (qctrl)
+    	sensor->info_priv.brightness = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
+	if (qctrl)
+    	sensor->info_priv.effect = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EXPOSURE);
+	if (qctrl)
+        sensor->info_priv.exposure = qctrl->default_value;
+
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SATURATION);
+	if (qctrl)
+        sensor->info_priv.saturation = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_CONTRAST);
+	if (qctrl)
+        sensor->info_priv.contrast = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_HFLIP);
+	if (qctrl)
+        sensor->info_priv.mirror = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_VFLIP);
+	if (qctrl)
+        sensor->info_priv.flip = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SCENE);
+	if (qctrl)
+        sensor->info_priv.scene = qctrl->default_value;
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
+	if (qctrl)
+        sensor->info_priv.digitalzoom = qctrl->default_value;
+
+    /* ddl@rock-chips.com : if sensor support auto focus and flash, programer must run focus and flash code  */
+	#if CONFIG_SENSOR_Focus
+    sensor_set_focus();
+    qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FOCUS_ABSOLUTE);
+	if (qctrl)
+        sensor->info_priv.focus = qctrl->default_value;
+	#endif
+
+	#if CONFIG_SENSOR_Flash
+	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FLASH);
+	if (qctrl)
+        sensor->info_priv.flash = qctrl->default_value;
+    #endif
+
+    SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),((val == 0)?__FUNCTION__:"sensor_reinit"),icd->user_width,icd->user_height);
+
+    return 0;
+sensor_INIT_ERR:
+	sensor_task_lock(client,0);
+	sensor_deactivate(client);
+    return ret;
+}
+
+static int sensor_deactivate(struct i2c_client *client)
+{
+	struct soc_camera_device *icd = client->dev.platform_data;
+
+	SENSOR_DG("\n%s..%s.. Enter\n",SENSOR_NAME_STRING(),__FUNCTION__);
+
+	/* ddl@rock-chips.com : all sensor output pin must change to input for other sensor */
+#if 0	
+	sensor_task_lock(client, 1);
+    sensor_write(client, 0x3000, reg_val&0xfc);
+	sensor_write(client, 0x3001, 0x00);
+	sensor_task_lock(client, 0);
+#endif
+	sensor_ioctrl(icd, Sensor_PowerDown, 1);
+	/* ddl@rock-chips.com : sensor config init width , because next open sensor quickly(soc_camera_open -> Try to configure with default parameters) */
+	icd->user_width = SENSOR_INIT_WIDTH;
+    icd->user_height = SENSOR_INIT_HEIGHT;
+	msleep(100);
+	return 0;
+}
+
+static  struct reginfo sensor_power_down_sequence[]=
+{
+    {0x00,0x00}
+};
+static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)
+{
+    int ret;
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if (pm_msg.event == PM_EVENT_SUSPEND) {
+        SENSOR_DG("\n %s Enter Suspend.. \n", SENSOR_NAME_STRING());
+        ret = sensor_write_array(client, sensor_power_down_sequence) ;
+        if (ret != 0) {
+            SENSOR_TR("\n %s..%s WriteReg Fail.. \n", SENSOR_NAME_STRING(),__FUNCTION__);
+            return ret;
+        } else {
+            ret = sensor_ioctrl(icd, Sensor_PowerDown, 1);
+            if (ret < 0) {
+			    SENSOR_TR("\n %s suspend fail for turn on power!\n", SENSOR_NAME_STRING());
+                return -EINVAL;
+            }
+        }
+    } else {
+        SENSOR_TR("\n %s cann't suppout Suspend..\n",SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+    return 0;
+}
+
+static int sensor_resume(struct soc_camera_device *icd)
+{
+	int ret;
+
+    ret = sensor_ioctrl(icd, Sensor_PowerDown, 0);
+    if (ret < 0) {
+		SENSOR_TR("\n %s resume fail for turn on power!\n", SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+
+	SENSOR_DG("\n %s Enter Resume.. \n", SENSOR_NAME_STRING());
+
+    return 0;
+
+}
+
+static int sensor_set_bus_param(struct soc_camera_device *icd,
+                                unsigned long flags)
+{
+
+    return 0;
+}
+
+static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
+{
+    struct soc_camera_link *icl = to_soc_camera_link(icd);
+    unsigned long flags = SENSOR_BUS_PARAM;
+
+    return soc_camera_apply_sensor_flags(icl, flags);
+}
+
+static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct sensor *sensor = to_sensor(client);
+
+    mf->width	= icd->user_width;
+	mf->height	= icd->user_height;
+	mf->code	= sensor->info_priv.fmt.code;
+	mf->colorspace	= sensor->info_priv.fmt.colorspace;
+	mf->field	= V4L2_FIELD_NONE;
+
+    return 0;
+}
+static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    bool ret = false;
+
+	if ((mf->width == 1024) && (mf->height == 768)) {
+		ret = true;
+	} else if ((mf->width == 1280) && (mf->height == 1024)) {
+		ret = true;
+	} else if ((mf->width == 1600) && (mf->height == 1200)) {
+		ret = true;
+	} else if ((mf->width == 2048) && (mf->height == 1536)) {
+		ret = true;
+	} else if ((mf->width == 2592) && (mf->height == 1944)) {
+		ret = true;
+	}
+
+	if (ret == true)
+		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
+	return ret;
+}
+
+static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    bool ret = false;
+
+	if ((mf->width == 1280) && (mf->height == 720)) {
+		ret = true;
+	} else if ((mf->width == 1920) && (mf->height == 1080)) {
+		ret = true;
+	}
+
+	if (ret == true)
+		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
+	return ret;
+}
+static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct sensor *sensor = to_sensor(client);
+    const struct sensor_datafmt *fmt;
+	const struct v4l2_queryctrl *qctrl;
+	struct soc_camera_device *icd = client->dev.platform_data;
+    struct reginfo *winseqe_set_addr=NULL;
+    int ret=0, set_w,set_h;
+
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (!fmt) {
+        ret = -EINVAL;
+        goto sensor_s_fmt_end;
+    }
+
+	if (sensor->info_priv.fmt.code != mf->code) {
+		switch (mf->code)
+		{
+			case V4L2_MBUS_FMT_YUYV8_2X8:
+			{
+				winseqe_set_addr = sensor_ClrFmt_YUYV;
+				break;
+			}
+			case V4L2_MBUS_FMT_UYVY8_2X8:
+			{
+				winseqe_set_addr = sensor_ClrFmt_UYVY;
+				break;
+			}
+			default:
+				break;
+		}
+		if (winseqe_set_addr != NULL) {
+            sensor_write_array(client, winseqe_set_addr);
+			sensor->info_priv.fmt.code = mf->code;
+            sensor->info_priv.fmt.colorspace= mf->colorspace;            
+			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
+		} else {
+			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
+		}
+	}
+
+    set_w = mf->width;
+    set_h = mf->height;
+
+	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
+	{
+		winseqe_set_addr = sensor_qcif;
+        set_w = 176;
+        set_h = 144;
+	}
+	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
+    {
+        winseqe_set_addr = sensor_qvga;
+        set_w = 320;
+        set_h = 240;
+    }
+    else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
+    {
+        winseqe_set_addr = sensor_cif;
+        set_w = 352;
+        set_h = 288;
+    }
+    else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
+    {
+        winseqe_set_addr = sensor_vga;
+        set_w = 640;
+        set_h = 480;
+    }
+    else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
+    {
+        winseqe_set_addr = sensor_svga;
+        set_w = 800;
+        set_h = 600;
+    }
+	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
+    {
+        winseqe_set_addr = sensor_xga;
+        set_w = 1024;
+        set_h = 768;
+    }
+    else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
+    {
+        winseqe_set_addr = sensor_sxga;
+        set_w = 1280;
+        set_h = 1024;
+    }
+    else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
+    {
+        winseqe_set_addr = sensor_uxga;
+        set_w = 1600;
+        set_h = 1200;
+    }
+    else
+    {
+        winseqe_set_addr = SENSOR_INIT_WINSEQADR;               /* ddl@rock-chips.com : Sensor output smallest size if  isn't support app  */
+        set_w = SENSOR_INIT_WIDTH;
+        set_h = SENSOR_INIT_HEIGHT;
+		SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,mf->width,mf->height);
+    }
+
+    if ((int)winseqe_set_addr  != sensor->info_priv.winseqe_cur_addr) {
+        #if CONFIG_SENSOR_Flash
+        if (sensor_fmt_capturechk(sd,mf) == true) {      /* ddl@rock-chips.com : Capture */
+            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
+                sensor_ioctrl(icd, Sensor_Flash, Flash_On);
+                SENSOR_DG("%s flash on in capture!\n", SENSOR_NAME_STRING());
+            }           
+        } else {                                        /* ddl@rock-chips.com : Video */
+            if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
+                sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
+                SENSOR_DG("%s flash off in preivew!\n", SENSOR_NAME_STRING());
+            }
+        }
+        #endif        
+        ret |= sensor_write_array(client, winseqe_set_addr);
+        if (ret != 0) {
+            SENSOR_TR("%s set format capability failed\n", SENSOR_NAME_STRING());
+            #if CONFIG_SENSOR_Flash
+            if (sensor_fmt_capturechk(sd,mf) == true) {
+                if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
+                    sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
+                    SENSOR_TR("%s Capture format set fail, flash off !\n", SENSOR_NAME_STRING());
+                }
+            }
+            #endif
+            goto sensor_s_fmt_end;
+        }
+
+        sensor->info_priv.winseqe_cur_addr  = (int)winseqe_set_addr;
+
+		if (sensor_fmt_capturechk(sd,mf) == true) {				    /* ddl@rock-chips.com : Capture */
+        #if CONFIG_SENSOR_Effect
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
+			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
+        #endif
+        #if CONFIG_SENSOR_WhiteBalance
+			if (sensor->info_priv.whiteBalance != 0) {
+				qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
+				sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
+			}
+        #endif
+			sensor->info_priv.snap2preview = true;
+		} else if (sensor_fmt_videochk(sd,mf) == true) {			/* ddl@rock-chips.com : Video */
+		#if CONFIG_SENSOR_Effect
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
+			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
+        #endif
+        #if CONFIG_SENSOR_WhiteBalance
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
+			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
+        #endif
+			sensor->info_priv.video2preview = true;
+		} else if ((sensor->info_priv.snap2preview == true) || (sensor->info_priv.video2preview == true)) {
+		#if CONFIG_SENSOR_Effect
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
+			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
+        #endif
+        #if CONFIG_SENSOR_WhiteBalance    
+			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
+			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
+        #endif    
+			sensor->info_priv.video2preview = false;            
+			sensor->info_priv.snap2preview = false;
+		}
+        SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),__FUNCTION__,set_w,set_h);
+    }
+    else
+    {
+        SENSOR_DG("\n %s .. Current Format is validate. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),set_w,set_h);
+    }
+
+	mf->width = set_w;
+    mf->height = set_h;
+
+sensor_s_fmt_end:
+    return ret;
+}
+
+static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct sensor *sensor = to_sensor(client);
+    const struct sensor_datafmt *fmt;
+    int ret = 0;
+   
+	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
+				   ARRAY_SIZE(sensor_colour_fmts));
+	if (fmt == NULL) {
+		fmt = &sensor->info_priv.fmt;
+        mf->code = fmt->code;
+	} 
+
+    if (mf->height > SENSOR_MAX_HEIGHT)
+        mf->height = SENSOR_MAX_HEIGHT;
+    else if (mf->height < SENSOR_MIN_HEIGHT)
+        mf->height = SENSOR_MIN_HEIGHT;
+
+    if (mf->width > SENSOR_MAX_WIDTH)
+        mf->width = SENSOR_MAX_WIDTH;
+    else if (mf->width < SENSOR_MIN_WIDTH)
+        mf->width = SENSOR_MIN_WIDTH;
+
+    mf->colorspace = fmt->colorspace;
+    
+    return ret;
+}
+ static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+    if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
+        return -EINVAL;
+
+    if (id->match.addr != client->addr)
+        return -ENODEV;
+
+    id->ident = SENSOR_V4L2_IDENT;      /* ddl@rock-chips.com :  Return OV2655  identifier */
+    id->revision = 0;
+
+    return 0;
+}
+#if CONFIG_SENSOR_Brightness
+static int sensor_set_brightness(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_BrightnessSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_BrightnessSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Effect
+static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_EffectSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_EffectSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Exposure
+static int sensor_set_exposure(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_ExposureSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_ExposureSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Saturation
+static int sensor_set_saturation(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_SaturationSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_SaturationSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Contrast
+static int sensor_set_contrast(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_ContrastSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_ContrastSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Mirror
+static int sensor_set_mirror(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_MirrorSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_MirrorSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Flip
+static int sensor_set_flip(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_FlipSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_FlipSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Scene
+static int sensor_set_scene(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_SceneSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_SceneSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+    SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_WhiteBalance
+static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
+    {
+        if (sensor_WhiteBalanceSeqe[value - qctrl->minimum] != NULL)
+        {
+            if (sensor_write_array(client, sensor_WhiteBalanceSeqe[value - qctrl->minimum]) != 0)
+            {
+                SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+                return -EINVAL;
+            }
+            SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+            return 0;
+        }
+    }
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_DigitalZoom
+static int sensor_set_digitalzoom(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int *value)
+{
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct sensor *sensor = to_sensor(client);
+	const struct v4l2_queryctrl *qctrl_info;
+    int digitalzoom_cur, digitalzoom_total;
+
+	qctrl_info = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
+	if (qctrl_info)
+		return -EINVAL;
+
+    digitalzoom_cur = sensor->info_priv.digitalzoom;
+    digitalzoom_total = qctrl_info->maximum;
+
+    if ((*value > 0) && (digitalzoom_cur >= digitalzoom_total))
+    {
+        SENSOR_TR("%s digitalzoom is maximum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
+        return -EINVAL;
+    }
+
+    if  ((*value < 0) && (digitalzoom_cur <= qctrl_info->minimum))
+    {
+        SENSOR_TR("%s digitalzoom is minimum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
+        return -EINVAL;
+    }
+
+    if ((*value > 0) && ((digitalzoom_cur + *value) > digitalzoom_total))
+    {
+        *value = digitalzoom_total - digitalzoom_cur;
+    }
+
+    if ((*value < 0) && ((digitalzoom_cur + *value) < 0))
+    {
+        *value = 0 - digitalzoom_cur;
+    }
+
+    digitalzoom_cur += *value;
+
+    if (sensor_ZoomSeqe[digitalzoom_cur] != NULL)
+    {
+        if (sensor_write_array(client, sensor_ZoomSeqe[digitalzoom_cur]) != 0)
+        {
+            SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
+            return -EINVAL;
+        }
+        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, *value);
+        return 0;
+    }
+
+    return -EINVAL;
+}
+#endif
+#if CONFIG_SENSOR_Flash
+static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
+{    
+    if ((value >= qctrl->minimum) && (value <= qctrl->maximum)) {
+        if (value == 3) {       /* ddl@rock-chips.com: torch */
+            sensor_ioctrl(icd, Sensor_Flash, Flash_Torch);   /* Flash On */
+        } else {
+            sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
+        }
+        SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
+        return 0;
+    }
+    
+	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
+    return -EINVAL;
+}
+#endif
+
+static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct sensor *sensor = to_sensor(client);
+    const struct v4l2_queryctrl *qctrl;
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
+        return -EINVAL;
+    }
+
+    switch (ctrl->id)
+    {
+        case V4L2_CID_BRIGHTNESS:
+            {
+                ctrl->value = sensor->info_priv.brightness;
+                break;
+            }
+        case V4L2_CID_SATURATION:
+            {
+                ctrl->value = sensor->info_priv.saturation;
+                break;
+            }
+        case V4L2_CID_CONTRAST:
+            {
+                ctrl->value = sensor->info_priv.contrast;
+                break;
+            }
+        case V4L2_CID_DO_WHITE_BALANCE:
+            {
+                ctrl->value = sensor->info_priv.whiteBalance;
+                break;
+            }
+        case V4L2_CID_EXPOSURE:
+            {
+                ctrl->value = sensor->info_priv.exposure;
+                break;
+            }
+        case V4L2_CID_HFLIP:
+            {
+                ctrl->value = sensor->info_priv.mirror;
+                break;
+            }
+        case V4L2_CID_VFLIP:
+            {
+                ctrl->value = sensor->info_priv.flip;
+                break;
+            }
+        default :
+                break;
+    }
+    return 0;
+}
+
+
+
+static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct sensor *sensor = to_sensor(client);
+    struct soc_camera_device *icd = client->dev.platform_data;
+    const struct v4l2_queryctrl *qctrl;
+
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
+        return -EINVAL;
+    }
+
+    switch (ctrl->id)
+    {
+#if CONFIG_SENSOR_Brightness
+        case V4L2_CID_BRIGHTNESS:
+            {
+                if (ctrl->value != sensor->info_priv.brightness)
+                {
+                    if (sensor_set_brightness(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.brightness = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Exposure
+        case V4L2_CID_EXPOSURE:
+            {
+                if (ctrl->value != sensor->info_priv.exposure)
+                {
+                    if (sensor_set_exposure(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.exposure = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Saturation
+        case V4L2_CID_SATURATION:
+            {
+                if (ctrl->value != sensor->info_priv.saturation)
+                {
+                    if (sensor_set_saturation(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.saturation = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Contrast
+        case V4L2_CID_CONTRAST:
+            {
+                if (ctrl->value != sensor->info_priv.contrast)
+                {
+                    if (sensor_set_contrast(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.contrast = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_WhiteBalance
+        case V4L2_CID_DO_WHITE_BALANCE:
+            {
+                if (ctrl->value != sensor->info_priv.whiteBalance)
+                {
+                    if (sensor_set_whiteBalance(icd, qctrl,ctrl->value) != 0)
+                    {
+                        return -EINVAL;
+                    }
+                    sensor->info_priv.whiteBalance = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Mirror
+        case V4L2_CID_HFLIP:
+            {
+                if (ctrl->value != sensor->info_priv.mirror)
+                {
+                    if (sensor_set_mirror(icd, qctrl,ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.mirror = ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Flip
+        case V4L2_CID_VFLIP:
+            {
+                if (ctrl->value != sensor->info_priv.flip)
+                {
+                    if (sensor_set_flip(icd, qctrl,ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.flip = ctrl->value;
+                }
+                break;
+            }
+#endif
+        default:
+            break;
+    }
+
+    return 0;
+}
+static int sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)
+{
+    const struct v4l2_queryctrl *qctrl;
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct sensor *sensor = to_sensor(client);
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
+        return -EINVAL;
+    }
+
+    switch (ext_ctrl->id)
+    {
+        case V4L2_CID_SCENE:
+            {
+                ext_ctrl->value = sensor->info_priv.scene;
+                break;
+            }
+        case V4L2_CID_EFFECT:
+            {
+                ext_ctrl->value = sensor->info_priv.effect;
+                break;
+            }
+        case V4L2_CID_ZOOM_ABSOLUTE:
+            {
+                ext_ctrl->value = sensor->info_priv.digitalzoom;
+                break;
+            }
+        case V4L2_CID_ZOOM_RELATIVE:
+            {
+                return -EINVAL;
+            }
+        case V4L2_CID_FOCUS_ABSOLUTE:
+            {
+                ext_ctrl->value = sensor->info_priv.focus;
+                break;
+            }
+        case V4L2_CID_FOCUS_RELATIVE:
+            {
+                return -EINVAL;
+            }
+        case V4L2_CID_FLASH:
+            {
+                ext_ctrl->value = sensor->info_priv.flash;
+                break;
+            }
+        default :
+            break;
+    }
+    return 0;
+}
+static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)
+{
+    const struct v4l2_queryctrl *qctrl;
+    struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
+    struct sensor *sensor = to_sensor(client);
+    int val_offset;
+
+    qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
+
+    if (!qctrl)
+    {
+        SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
+        return -EINVAL;
+    }
+
+	val_offset = 0;
+    switch (ext_ctrl->id)
+    {
+#if CONFIG_SENSOR_Scene
+        case V4L2_CID_SCENE:
+            {
+                if (ext_ctrl->value != sensor->info_priv.scene)
+                {
+                    if (sensor_set_scene(icd, qctrl,ext_ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.scene = ext_ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Effect
+        case V4L2_CID_EFFECT:
+            {
+                if (ext_ctrl->value != sensor->info_priv.effect)
+                {
+                    if (sensor_set_effect(icd, qctrl,ext_ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.effect= ext_ctrl->value;
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_DigitalZoom
+        case V4L2_CID_ZOOM_ABSOLUTE:
+            {
+                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
+                    return -EINVAL;
+
+                if (ext_ctrl->value != sensor->info_priv.digitalzoom)
+                {
+                    val_offset = ext_ctrl->value -sensor->info_priv.digitalzoom;
+
+                    if (sensor_set_digitalzoom(icd, qctrl,&val_offset) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.digitalzoom += val_offset;
+
+                    SENSOR_DG("%s digitalzoom is %x\n",SENSOR_NAME_STRING(),  sensor->info_priv.digitalzoom);
+                }
+
+                break;
+            }
+        case V4L2_CID_ZOOM_RELATIVE:
+            {
+                if (ext_ctrl->value)
+                {
+                    if (sensor_set_digitalzoom(icd, qctrl,&ext_ctrl->value) != 0)
+                        return -EINVAL;
+                    sensor->info_priv.digitalzoom += ext_ctrl->value;
+
+                    SENSOR_DG("%s digitalzoom is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.digitalzoom);
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Focus
+        case V4L2_CID_FOCUS_ABSOLUTE:
+            {
+                if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
+                    return -EINVAL;
+
+                if (ext_ctrl->value != sensor->info_priv.focus)
+                {
+                    val_offset = ext_ctrl->value -sensor->info_priv.focus;
+
+                    sensor->info_priv.focus += val_offset;
+                }
+
+                break;
+            }
+        case V4L2_CID_FOCUS_RELATIVE:
+            {
+                if (ext_ctrl->value)
+                {
+                    sensor->info_priv.focus += ext_ctrl->value;
+
+                    SENSOR_DG("%s focus is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.focus);
+                }
+                break;
+            }
+#endif
+#if CONFIG_SENSOR_Flash
+        case V4L2_CID_FLASH:
+            {
+                if (sensor_set_flash(icd, qctrl,ext_ctrl->value) != 0)
+                    return -EINVAL;
+                sensor->info_priv.flash = ext_ctrl->value;
+
+                SENSOR_DG("%s flash is %x\n",SENSOR_NAME_STRING(), sensor->info_priv.flash);
+                break;
+            }
+#endif
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_device *icd = client->dev.platform_data;
+    int i, error_cnt=0, error_idx=-1;
+
+
+    for (i=0; i<ext_ctrl->count; i++) {
+        if (sensor_g_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
+            error_cnt++;
+            error_idx = i;
+        }
+    }
+
+    if (error_cnt > 1)
+        error_idx = ext_ctrl->count;
+
+    if (error_idx != -1) {
+        ext_ctrl->error_idx = error_idx;
+        return -EINVAL;
+    } else {
+        return 0;
+    }
+}
+
+static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
+{
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_device *icd = client->dev.platform_data;
+    int i, error_cnt=0, error_idx=-1;
+
+
+    for (i=0; i<ext_ctrl->count; i++) {
+        if (sensor_s_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
+            error_cnt++;
+            error_idx = i;
+        }
+    }
+
+    if (error_cnt > 1)
+        error_idx = ext_ctrl->count;
+
+    if (error_idx != -1) {
+        ext_ctrl->error_idx = error_idx;
+        return -EINVAL;
+    } else {
+        return 0;
+    }
+}
+
+/* Interface active, can use i2c. If it fails, it can indeed mean, that
+ * this wasn't our capture interface, so, we wait for the right one */
+static int sensor_video_probe(struct soc_camera_device *icd,
+			       struct i2c_client *client)
+{
+    char value;
+    int ret,pid = 0;
+    struct sensor *sensor = to_sensor(client);
+
+    /* We must have a parent by now. And it cannot be a wrong one.
+     * So this entire test is completely redundant. */
+    if (!icd->dev.parent ||
+	    to_soc_camera_host(icd->dev.parent)->nr != icd->iface)
+		return -ENODEV;
+
+	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
+		ret = -ENODEV;
+		goto sensor_video_probe_err;
+	}
+
+    /* soft reset */
+    ret = sensor_write(client, 0xff, 0x1);
+    if (ret != 0) {
+        SENSOR_TR("soft reset %s failed\n",SENSOR_NAME_STRING());
+        ret = -ENODEV;
+		goto sensor_video_probe_err;
+    }
+    mdelay(5);          //delay 5 microseconds
+
+    /* check if it is an sensor sensor */
+    ret = sensor_read(client, 0x0a, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id high byte failed\n");
+        ret = -ENODEV;
+        goto sensor_video_probe_err;
+    }
+    pid = value << 8;
+
+    ret = sensor_read(client, 0x0b, &value);
+    if (ret != 0) {
+        SENSOR_TR("read chip id low byte failed\n");
+        ret = -ENODEV;
+        goto sensor_video_probe_err;
+    }
+
+    pid |= (value & 0xff);
+    SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+
+    if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
+        sensor->model = SENSOR_V4L2_IDENT;
+    } else {
+        SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
+        ret = -ENODEV;
+        goto sensor_video_probe_err;
+    }
+
+    return 0;
+
+sensor_video_probe_err:
+
+    return ret;
+}
+
+static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+    struct soc_camera_device *icd = client->dev.platform_data;  
+    struct sensor *sensor = to_sensor(client);
+    int ret = 0;
+    
+	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
+	switch (cmd)
+	{
+		case RK29_CAM_SUBDEV_DEACTIVATE:
+		{
+			sensor_deactivate(client);
+			break;
+		}
+
+		case RK29_CAM_SUBDEV_IOREQUEST:
+		{
+			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
+            if (sensor->sensor_io_request != NULL) { 
+                if (sensor->sensor_io_request->gpio_res[0].dev_name && 
+                    (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
+                } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
+                    (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
+                    sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
+                }
+            } else {
+                SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
+                ret = -EINVAL;
+                goto sensor_ioctl_end;
+            }
+            /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
+               for this project */
+            #if CONFIG_SENSOR_Flash	
+        	if (sensor->sensor_gpio_res) { 
+                if (sensor->sensor_gpio_res->gpio_flash == INVALID_GPIO) {
+                    for (i = 0; i < icd->ops->num_controls; i++) {
+                		if (V4L2_CID_FLASH == icd->ops->controls[i].id) {
+                			memset((char*)&icd->ops->controls[i],0x00,sizeof(struct v4l2_queryctrl));                			
+                		}
+                    }
+                    sensor->info_priv.flash = 0xff;
+                    SENSOR_DG("%s flash gpio is invalidate!\n",SENSOR_NAME_STRING());
+                }
+        	}
+            #endif
+			break;
+		}
+		default:
+		{
+			SENSOR_TR("%s %s cmd(0x%x) is unknown !\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
+			break;
+		}
+	}
+
+sensor_ioctl_end:
+	return ret;
+
+}
+static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			    enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(sensor_colour_fmts))
+		return -EINVAL;
+
+	*code = sensor_colour_fmts[index].code;
+	return 0;
+}
+static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
+	.init		= sensor_init,
+	.g_ctrl		= sensor_g_control,
+	.s_ctrl		= sensor_s_control,
+	.g_ext_ctrls          = sensor_g_ext_controls,
+	.s_ext_ctrls          = sensor_s_ext_controls,
+	.g_chip_ident	= sensor_g_chip_ident,
+	.ioctl = sensor_ioctl,
+};
+
+static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
+	.s_mbus_fmt	= sensor_s_fmt,
+	.g_mbus_fmt	= sensor_g_fmt,
+	.try_mbus_fmt	= sensor_try_fmt,
+	.enum_mbus_fmt	= sensor_enum_fmt,
+};
+
+static struct v4l2_subdev_ops sensor_subdev_ops = {
+	.core	= &sensor_subdev_core_ops,
+	.video = &sensor_subdev_video_ops,
+};
+
+static int sensor_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+    struct sensor *sensor;
+    struct soc_camera_device *icd = client->dev.platform_data;
+    struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+    struct soc_camera_link *icl;
+    int ret;
+
+    SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
+    if (!icd) {
+        dev_err(&client->dev, "%s: missing soc-camera data!\n",SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+
+    icl = to_soc_camera_link(icd);
+    if (!icl) {
+        dev_err(&client->dev, "%s driver needs platform data\n", SENSOR_NAME_STRING());
+        return -EINVAL;
+    }
+
+    if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+        dev_warn(&adapter->dev,
+        	 "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
+        return -EIO;
+    }
+
+    sensor = kzalloc(sizeof(struct sensor), GFP_KERNEL);
+    if (!sensor)
+        return -ENOMEM;
+
+    v4l2_i2c_subdev_init(&sensor->subdev, client, &sensor_subdev_ops);
+
+    /* Second stage probe - when a capture adapter is there */
+    icd->ops		= &sensor_ops;
+    sensor->info_priv.fmt = sensor_colour_fmts[0];
+	#if CONFIG_SENSOR_I2C_NOSCHED
+	atomic_set(&sensor->tasklock_cnt,0);
+	#endif
+
+    ret = sensor_video_probe(icd, client);
+    if (ret < 0) {
+        icd->ops = NULL;
+        i2c_set_clientdata(client, NULL);
+        kfree(sensor);
+		sensor = NULL;
+    }
+    SENSOR_DG("\n%s..%s..%d  ret = %x \n",__FUNCTION__,__FILE__,__LINE__,ret);
+    return ret;
+}
+
+static int sensor_remove(struct i2c_client *client)
+{
+    struct sensor *sensor = to_sensor(client);
+    struct soc_camera_device *icd = client->dev.platform_data;
+
+    icd->ops = NULL;
+    i2c_set_clientdata(client, NULL);
+    client->driver = NULL;
+    kfree(sensor);
+	sensor = NULL;
+    return 0;
+}
+
+static const struct i2c_device_id sensor_id[] = {
+	{SENSOR_NAME_STRING(), 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sensor_id);
+
+static struct i2c_driver sensor_i2c_driver = {
+	.driver = {
+		.name = SENSOR_NAME_STRING(),
+	},
+	.probe		= sensor_probe,
+	.remove		= sensor_remove,
+	.id_table	= sensor_id,
+};
+
+static int __init sensor_mod_init(void)
+{
+    SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());
+    return i2c_add_driver(&sensor_i2c_driver);
+}
+
+static void __exit sensor_mod_exit(void)
+{
+    i2c_del_driver(&sensor_i2c_driver);
+}
+
+device_initcall_sync(sensor_mod_init);
+module_exit(sensor_mod_exit);
+
+MODULE_DESCRIPTION(SENSOR_NAME_STRING(Camera sensor driver));
+MODULE_AUTHOR("ddl <kernel@rock-chips>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/ov7675.c b/drivers/media/video/ov7675.c
index 7453d6d97499..03d19f88929f 100755
--- a/drivers/media/video/ov7675.c
+++ b/drivers/media/video/ov7675.c
@@ -1385,7 +1385,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -1562,7 +1562,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -1611,7 +1611,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
 	const struct v4l2_queryctrl *qctrl;
@@ -1789,7 +1789,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -1818,7 +1818,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2102,7 +2102,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2161,9 +2161,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
-    struct sensor *sensor = to_sensor(client);
-    struct soc_camera_device *icd = client->dev.platform_data;    
+    struct i2c_client *client = v4l2_get_subdevdata(sd);  
     const struct v4l2_queryctrl *qctrl;
     
     qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
@@ -2450,7 +2448,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2475,7 +2473,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2552,7 +2550,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
diff --git a/drivers/media/video/s5k6aa.c b/drivers/media/video/s5k6aa.c
index 96ae6dffe480..cfe412a1733d 100644
--- a/drivers/media/video/s5k6aa.c
+++ b/drivers/media/video/s5k6aa.c
@@ -3313,7 +3313,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -3584,7 +3584,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -3712,7 +3712,7 @@ static struct reginfo* sensor_fmt_catch(int set_w, int set_h, int *ret_w, int *r
 
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     const struct sensor_datafmt *fmt;
     struct sensor *sensor = to_sensor(client);    
     struct reginfo *winseqe_set_addr=NULL;
@@ -3801,7 +3801,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -3830,7 +3830,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -4117,7 +4117,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 #endif
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -4176,7 +4176,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -4466,7 +4466,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -4491,7 +4491,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -4515,7 +4515,7 @@ static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 }
 static int sensor_s_stream(struct v4l2_subdev *sd, int enable)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
 
 	if (enable == 1) {
@@ -4587,7 +4587,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
diff --git a/drivers/media/video/sid130B.c b/drivers/media/video/sid130B.c
index 89cbcfa1e8e5..ef1f427615a2 100755
--- a/drivers/media/video/sid130B.c
+++ b/drivers/media/video/sid130B.c
@@ -1676,13 +1676,12 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 }
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
     const struct sensor_datafmt *fmt;
-    char value;
-    int ret,pid = 0;
+    int ret;
 
     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
 
@@ -1899,7 +1898,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -1948,7 +1947,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
 	const struct v4l2_queryctrl *qctrl;
@@ -2128,7 +2127,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -2157,7 +2156,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2441,7 +2440,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2500,7 +2499,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -2790,7 +2789,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2815,7 +2814,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2843,9 +2842,8 @@ static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 static int sensor_video_probe(struct soc_camera_device *icd,
 			       struct i2c_client *client)
 {
-    char value;
-    int ret,pid = 0;
-    struct sensor *sensor = to_sensor(client);
+    int ret;
+    
 
     /* We must have a parent by now. And it cannot be a wrong one.
      * So this entire test is completely redundant. */
@@ -2902,7 +2900,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 }
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
diff --git a/drivers/media/video/siv120b.c b/drivers/media/video/siv120b.c
index 40eb75327829..a300398eaad4 100755
--- a/drivers/media/video/siv120b.c
+++ b/drivers/media/video/siv120b.c
@@ -1460,7 +1460,7 @@ static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd
 
 static int sensor_init(struct v4l2_subdev *sd, u32 val)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 	const struct v4l2_queryctrl *qctrl;
@@ -1649,7 +1649,7 @@ static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
 
 static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
 
@@ -1698,7 +1698,7 @@ static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefm
 }
 static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     struct reginfo *winseqe_set_addr=NULL;
@@ -1811,7 +1811,7 @@ static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 
 static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct sensor_datafmt *fmt;
     int ret = 0;
@@ -1839,7 +1839,7 @@ static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
 }
  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
 
     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
         return -EINVAL;
@@ -2136,7 +2136,7 @@ static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_que
 
 static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     const struct v4l2_queryctrl *qctrl;
 
@@ -2195,7 +2195,7 @@ static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 
 static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct sensor *sensor = to_sensor(client);
     struct soc_camera_device *icd = client->dev.platform_data;
     const struct v4l2_queryctrl *qctrl;
@@ -2485,7 +2485,7 @@ static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_c
 
 static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2510,7 +2510,7 @@ static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_control
 
 static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
 {
-    struct i2c_client *client = sd->priv;
+    struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     int i, error_cnt=0, error_idx=-1;
 
@@ -2588,7 +2588,7 @@ static int sensor_video_probe(struct soc_camera_device *icd,
 
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct i2c_client *client = sd->priv;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct soc_camera_device *icd = client->dev.platform_data;
     struct sensor *sensor = to_sensor(client);
     int ret = 0;
-- 
2.35.3

