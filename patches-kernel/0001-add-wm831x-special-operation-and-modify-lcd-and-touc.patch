From 7dd9b25f9bc92c383e4699edc51e963c89382771 Mon Sep 17 00:00:00 2001
From: luowei <lw@rock-chips.com>
Date: Wed, 6 Apr 2011 10:23:09 +0800
Subject: [PATCH] add wm831x special operation and modify lcd and touch screen
 for A22

---
 arch/arm/mach-rk29/board-rk29-a22.c           |   39 +-
 arch/arm/mach-rk29/include/mach/board.h       |    2 +-
 drivers/input/touchscreen/ili2102_ts.c        |   80 +-
 drivers/mfd/Kconfig                           |   12 +
 drivers/mfd/Makefile                          |    1 +
 drivers/mfd/wm831x-spi-a22.c                  |  845 ++++++++++
 drivers/rtc/rtc-test.c                        |    4 +-
 .../video/display/screen/lcd_ili9803_cpt4_3.c | 1441 +++++++++++++++--
 8 files changed, 2212 insertions(+), 212 deletions(-)
 create mode 100755 drivers/mfd/wm831x-spi-a22.c

diff --git a/arch/arm/mach-rk29/board-rk29-a22.c b/arch/arm/mach-rk29/board-rk29-a22.c
index aa4f45f65099..7f695933e789 100755
--- a/arch/arm/mach-rk29/board-rk29-a22.c
+++ b/arch/arm/mach-rk29/board-rk29-a22.c
@@ -139,9 +139,9 @@ struct rk29_nand_platform_data rk29_nand_data = {
 * author: zyw@rock-chips.com
 *****************************************************************************************/
 #define FB_ID                       0
-#define FB_DISPLAY_ON_PIN           RK29_PIN6_PD0
-#define FB_LCD_STANDBY_PIN          RK29_PIN6_PD1
-#define FB_LCD_CABC_EN_PIN          RK29_PIN6_PD2
+#define FB_DISPLAY_ON_PIN           INVALID_GPIO//RK29_PIN6_PD0
+#define FB_LCD_STANDBY_PIN          INVALID_GPIO//RK29_PIN6_PD1
+#define FB_LCD_CABC_EN_PIN          INVALID_GPIO//RK29_PIN6_PD2
 #define FB_MCU_FMK_PIN              INVALID_GPIO
 
 #define FB_DISPLAY_ON_VALUE         GPIO_HIGH
@@ -151,18 +151,30 @@ struct rk29_nand_platform_data rk29_nand_data = {
 static int rk29_lcd_io_init(void)
 {
 	int ret = 0;
-	rk29_mux_api_set(GPIO2C7_SPI1RXD_NAME, GPIO2H_GPIO2C6); 
-	rk29_mux_api_set(GPIO2C5_SPI1CSN0_NAME, GPIO2H_GPIO2C5); 
-	rk29_mux_api_set(GPIO2C4_SPI1CLK_NAME, GPIO2H_GPIO2C4); 	
+	//printk("rk29_lcd_io_init\n");
+	//ret = gpio_request(LCD_RXD_PIN, NULL);
+	ret = gpio_request(LCD_TXD_PIN, NULL);
+	ret = gpio_request(LCD_CLK_PIN, NULL);
+	ret = gpio_request(LCD_CS_PIN, NULL);
+	//rk29_mux_api_set(GPIO2C7_SPI1RXD_NAME,GPIO2H_GPIO2C7);
+	rk29_mux_api_set(GPIO2C6_SPI1TXD_NAME,GPIO2H_GPIO2C6);
+	rk29_mux_api_set(GPIO2C5_SPI1CSN0_NAME,GPIO2H_GPIO2C5);
+	rk29_mux_api_set(GPIO2C4_SPI1CLK_NAME,GPIO2H_GPIO2C4);
 	return ret;
 }
 
 static int rk29_lcd_io_deinit(void)
 {
 	int ret = 0;
-	rk29_mux_api_set(GPIO2C7_SPI1RXD_NAME, GPIO2H_SPI1_TXD); 
-	rk29_mux_api_set(GPIO2C5_SPI1CSN0_NAME, GPIO2H_SPI1_CSN0); 
-	rk29_mux_api_set(GPIO2C4_SPI1CLK_NAME, GPIO2H_SPI1_CLK); 
+	//printk("rk29_lcd_io_deinit\n");
+	gpio_free(LCD_CS_PIN);
+	gpio_free(LCD_CLK_PIN);
+	gpio_free(LCD_TXD_PIN);
+	//gpio_free(LCD_RXD_PIN);
+	//rk29_mux_api_set(GPIO2C7_SPI1RXD_NAME,GPIO2H_SPI1_RXD);
+	rk29_mux_api_set(GPIO2C6_SPI1TXD_NAME,GPIO2H_SPI1_TXD);
+	rk29_mux_api_set(GPIO2C5_SPI1CSN0_NAME,GPIO2H_SPI1_CSN0);
+	rk29_mux_api_set(GPIO2C4_SPI1CLK_NAME,GPIO2H_SPI1_CLK);
 	return ret;
 }
 
@@ -687,6 +699,9 @@ static struct regulator_consumer_supply dcdc1_consumers[] = {
 static struct regulator_consumer_supply dcdc2_consumers[] = {
 	{
 		.supply = "dcdc2",
+	},
+	{
+		.supply = "vcore",
 	}
 };
 static struct regulator_consumer_supply dcdc3_consumers[] = {
@@ -2706,14 +2721,14 @@ static struct spi_board_info board_spi_devices[] = {
 	},
 #endif
 
-#if defined(CONFIG_MFD_WM831X_SPI)
+#if defined(CONFIG_MFD_WM831X_SPI_A22)
 	{
 		.modalias	= "wm8310",
 		.chip_select	= 1,
-		.max_speed_hz	= 12*1000*1000,
+		.max_speed_hz	= 2*1000*1000,
 		.bus_num	= 1,
 		.irq            = RK29_PIN4_PD0,
-		.platform_data = &wm831x_platdata,
+		//.platform_data = &wm831x_platdata,
 	},
 #endif
 
diff --git a/arch/arm/mach-rk29/include/mach/board.h b/arch/arm/mach-rk29/include/mach/board.h
index 1b773db16b0a..8a111c602baa 100755
--- a/arch/arm/mach-rk29/include/mach/board.h
+++ b/arch/arm/mach-rk29/include/mach/board.h
@@ -247,7 +247,7 @@ int board_boot_mode(void);
 #ifdef CONFIG_USB_GADGET
 int board_usb_detect_init(unsigned gpio, unsigned long flags);
 #else
-static int inline board_usb_detect_init(unsigned, unsigned long) { return 0; }
+static int inline board_usb_detect_init(unsigned gpio, unsigned long flags) { return 0; }
 #endif
 
 /* for wakeup Android */
diff --git a/drivers/input/touchscreen/ili2102_ts.c b/drivers/input/touchscreen/ili2102_ts.c
index 3cdedbdbf1d2..2ed32620ab48 100755
--- a/drivers/input/touchscreen/ili2102_ts.c
+++ b/drivers/input/touchscreen/ili2102_ts.c
@@ -14,13 +14,13 @@
 #include "ili2102_ts.h"
 
 
-#if 1
+#if 0
 	#define DBG(msg...)	printk(msg);
 #else
 	#define DBG(msg...)
 #endif
 
-#define TOUCH_NUMBER 2
+#define TOUCH_NUMBER 1
 
 static int touch_state[TOUCH_NUMBER] = {TOUCH_UP,TOUCH_UP};
 
@@ -115,7 +115,7 @@ static void ili2102_ts_work_func(struct work_struct *work)
 	unsigned int x, y;
 	struct i2c_msg msg[2];
 	uint8_t start_reg;
-	uint32_t buf[4];
+	uint8_t buf[9];//uint32_t buf[4];
 	struct ili2102_ts_data *ts = container_of(work, struct ili2102_ts_data, work);
 
 	DBG("ili2102_ts_work_func\n");
@@ -130,8 +130,8 @@ static void ili2102_ts_work_func(struct work_struct *work)
 
 	msg[1].addr = ts->client->addr;
 	msg[1].flags = I2C_M_RD;
-	msg[1].len = 4 * TOUCH_NUMBER;
-	msg[1].buf = (u8*)&buf[0];
+	msg[1].len = 9;	
+	msg[1].buf = buf;//msg[1].buf = (u8*)&buf[0];
 
 	ret = i2c_transfer(ts->client->adapter, msg, 2);
     
@@ -140,46 +140,46 @@ static void ili2102_ts_work_func(struct work_struct *work)
 	printk("ili2102_ts_work_func:i2c_transfer fail =%d\n",ret);
 	}
 
-	for(i=0; i<TOUCH_NUMBER; i++)
+	if((buf[0] & 0x03) == 0)
 	{
-		if(buf[i] == 0xffffffff || buf[i] == 0)
-		{
-		  	if (touch_state[i] == TOUCH_DOWN)
-		  	{
-				DBG("ili2102_ts_work_func:buf[%d]=%d\n",i,buf[i]);
-				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0); //Finger Size
-				input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0); //Touch Size
-				input_mt_sync(ts->input_dev);
-				syn_flag = 1;
-				touch_state[i] = TOUCH_UP;
-			}
-
+	  	if (touch_state[i] == TOUCH_DOWN)
+	  	{
+			DBG("ili2102_ts_work_func:buf[%d]=%d\n",i,buf[i]);
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0); //Finger Size
+			input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0); //Touch Size
+			input_mt_sync(ts->input_dev);
+			syn_flag = 1;
+			touch_state[i] = TOUCH_UP;
 		}
-		else
+
+	}
+	else
+	{
+
+		for(i=0; i<TOUCH_NUMBER; i++)
 		{
-			#if 0
-		        x = ((buf[i] & 0xff) << 8) | ((buf[i] & 0xff00) >> 8);
-		        y = ((buf[i] & 0xff0000) >> 8) | ((buf[i] & 0xff000000) >> 24);
-			#else
-			x = (buf[i] & 0xff00)  | (buf[i] & 0xff);
-		        y = ((buf[i] & 0xff000000) >> 16) | ((buf[i] & 0xff0000) >> 16);
-			#endif
-
-			if (ts->swap_xy)
-			swap(x, y);
-
-			if (verify_coord(ts,&x,&y))
-			goto out;
+			if((buf[0]>>i)&0x01)
+			{
+				x = buf[1+(i<<2)] | (buf[2+(i<<2)] << 8);
+				y = buf[3+(i<<2)] | (buf[4+(i<<2)] << 8);
 				
-		        DBG("buf[%d]=%x X = %d, Y = %d\n", i, buf[i], x, y);
 
-		        input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 1); //Finger Size
-		        input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
-		        input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
-		        input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 5); //Touch Size
-		        input_mt_sync(ts->input_dev);
-			syn_flag = 1;
-			touch_state[i] = TOUCH_DOWN;
+				if (ts->swap_xy)
+				swap(x, y);
+
+				if (verify_coord(ts,&x,&y))
+				goto out;
+					
+			        printk("buf[%d]=%x X = %d, Y = %d\n", i, buf[i], x, y);
+
+			        input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 1); //Finger Size
+			        input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
+			        input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
+			        input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 5); //Touch Size
+			        input_mt_sync(ts->input_dev);
+				syn_flag = 1;
+				touch_state[i] = TOUCH_DOWN;
+			}
 		}
 	}
 	
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 8bc5dcc200b2..0e7a073d4472 100755
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -219,6 +219,18 @@ config MFD_WM831X_SPI
 	  when controlled using SPI.  This driver provides common support
 	  for accessing the device, additional drivers must be enabled in
 	  order to use the functionality of the device.
+
+config MFD_WM831X_SPI_A22
+	bool "Support Wolfson Microelectronics WM831x/2x PMICs with SPI for A22"
+	#select MFD_CORE
+	#select MFD_WM831X
+	depends on SPI_MASTER && GENERIC_HARDIRQS
+	help
+	  Support for the Wolfson Microelecronics WM831x and WM832x PMICs
+	  when controlled using SPI.  This driver provides common support
+	  for accessing the device, additional drivers must be enabled in
+	  order to use the functionality of the device.
+	  
 config MFD_WM8350
 	tristate
 
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index d26a4631ec3c..a3768e455e9d 100755
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -19,6 +19,7 @@ wm831x-objs			:= wm831x-core.o wm831x-irq.o wm831x-otp.o
 obj-$(CONFIG_MFD_WM831X)	+= wm831x.o
 obj-$(CONFIG_MFD_WM831X_I2C)	+= wm831x-i2c.o
 obj-$(CONFIG_MFD_WM831X_SPI)	+= wm831x-spi.o
+obj-$(CONFIG_MFD_WM831X_SPI_A22)	+= wm831x-spi-a22.o
 wm8350-objs			:= wm8350-core.o wm8350-regmap.o wm8350-gpio.o
 obj-$(CONFIG_MFD_WM8350)	+= wm8350.o
 obj-$(CONFIG_MFD_WM8350_I2C)	+= wm8350-i2c.o
diff --git a/drivers/mfd/wm831x-spi-a22.c b/drivers/mfd/wm831x-spi-a22.c
new file mode 100755
index 000000000000..9e7d9cc0b67d
--- /dev/null
+++ b/drivers/mfd/wm831x-spi-a22.c
@@ -0,0 +1,845 @@
+/*
+ * wm831x-spi.c  --  SPI access for Wolfson WM831x PMICs
+ *
+ * Copyright 2009,2010 Wolfson Microelectronics PLC.
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+#include <linux/mfd/wm831x/core.h>
+#include <linux/mfd/wm831x/pdata.h>
+#include <linux/mfd/wm831x/irq.h>
+#include <linux/mfd/wm831x/auxadc.h>
+#include <linux/mfd/wm831x/otp.h>
+#include <linux/mfd/wm831x/regulator.h>
+#include <linux/mfd/wm831x/pmu.h>
+
+
+
+/* DC-DC*/
+#define WM831X_BUCKV_MAX_SELECTOR 0x68
+#define WM831X_BUCKP_MAX_SELECTOR 0x66
+
+#define WM831X_DCDC_MODE_FAST    0
+#define WM831X_DCDC_MODE_NORMAL  1
+#define WM831X_DCDC_MODE_IDLE    2
+#define WM831X_DCDC_MODE_STANDBY 3
+
+//#define WM831X_DCDC_MAX_NAME 6
+
+/* Register offsets in control block */
+#define WM831X_DCDC_CONTROL_1     0
+#define WM831X_DCDC_CONTROL_2     1
+#define WM831X_DCDC_ON_CONFIG     2
+#define WM831X_DCDC_SLEEP_CONTROL 3
+#define WM831X_DCDC_DVS_CONTROL   4
+
+/* LDO*/
+#define WM831X_LDO_CONTROL       0
+#define WM831X_LDO_ON_CONTROL    1
+#define WM831X_LDO_SLEEP_CONTROL 2
+
+#define WM831X_ALIVE_LDO_ON_CONTROL    0
+#define WM831X_ALIVE_LDO_SLEEP_CONTROL 1
+
+static int wm831x_spi_read_device(struct wm831x *wm831x, unsigned short reg,
+				  int bytes, void *dest)
+{
+	u16 tx_val;
+	u16 *d = dest;
+	int r, ret;
+
+	/* Go register at a time */
+	for (r = reg; r < reg + (bytes / 2); r++) {
+		tx_val = cpu_to_be16(r | 0x8000);
+
+		ret = spi_write_then_read(wm831x->control_data,
+					  (u8 *)&tx_val, 2, (u8 *)d, 2);
+		if (ret != 0)
+			return ret;
+
+		//*d = be16_to_cpu(*d);
+
+		d++;
+	}
+
+	return 0;
+}
+
+static int wm831x_spi_write_device(struct wm831x *wm831x, unsigned short reg,
+				   int bytes, void *src)
+{
+	struct spi_device *spi = wm831x->control_data;
+	u16 *s = src;
+	u16 data[2];
+	int ret, r;
+
+	/* Go register at a time */
+	for (r = reg; r < reg + (bytes / 2); r++) {
+		data[0] = cpu_to_be16(r);
+		data[1] = *s++;
+		//printk("%s:reg=0x%x,data=0x%x\n",__FUNCTION__,be16_to_cpu(data[0]),be16_to_cpu(data[1]));
+		ret = spi_write(spi, (char *)&data, sizeof(data));
+		if (ret != 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+
+int wm831x_isinkv_values[WM831X_ISINK_MAX_ISEL + 1] = {
+	2,
+	2,
+	3,
+	3,
+	4,
+	5,
+	6,
+	7,
+	8,
+	10,
+	11,
+	13,
+	16,
+	19,
+	23,
+	27,
+	32,
+	38,
+	45,
+	54,
+	64,
+	76,
+	91,
+	108,
+	128,
+	152,
+	181,
+	215,
+	256,
+	304,
+	362,
+	431,
+	512,
+	609,
+	724,
+	861,
+	1024,
+	1218,
+	1448,
+	1722,
+	2048,
+	2435,
+	2896,
+	3444,
+	4096,
+	4871,
+	5793,
+	6889,
+	8192,
+	9742,
+	11585,
+	13777,
+	16384,
+	19484,
+	23170,
+	27554,
+};
+EXPORT_SYMBOL_GPL(wm831x_isinkv_values);
+
+static int wm831x_reg_locked(struct wm831x *wm831x, unsigned short reg)
+{
+	if (!wm831x->locked)
+		return 0;
+
+	switch (reg) {
+	case WM831X_WATCHDOG:
+	case WM831X_DC4_CONTROL:
+	case WM831X_ON_PIN_CONTROL:
+	case WM831X_BACKUP_CHARGER_CONTROL:
+	case WM831X_CHARGER_CONTROL_1:
+	case WM831X_CHARGER_CONTROL_2:
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+/**
+ * wm831x_reg_unlock: Unlock user keyed registers
+ *
+ * The WM831x has a user key preventing writes to particularly
+ * critical registers.  This function locks those registers,
+ * allowing writes to them.
+ */
+void wm831x_reg_lock(struct wm831x *wm831x)
+{
+	int ret;
+
+	ret = wm831x_reg_write(wm831x, WM831X_SECURITY_KEY, 0);
+	if (ret == 0) {
+		dev_vdbg(wm831x->dev, "Registers locked\n");
+
+		mutex_lock(&wm831x->io_lock);
+		WARN_ON(wm831x->locked);
+		wm831x->locked = 1;
+		mutex_unlock(&wm831x->io_lock);
+	} else {
+		dev_err(wm831x->dev, "Failed to lock registers: %d\n", ret);
+	}
+
+}
+EXPORT_SYMBOL_GPL(wm831x_reg_lock);
+
+/**
+ * wm831x_reg_unlock: Unlock user keyed registers
+ *
+ * The WM831x has a user key preventing writes to particularly
+ * critical registers.  This function locks those registers,
+ * preventing spurious writes.
+ */
+int wm831x_reg_unlock(struct wm831x *wm831x)
+{
+	int ret;
+
+	/* 0x9716 is the value required to unlock the registers */
+	ret = wm831x_reg_write(wm831x, WM831X_SECURITY_KEY, 0x9716);
+	if (ret == 0) {
+		dev_vdbg(wm831x->dev, "Registers unlocked\n");
+
+		mutex_lock(&wm831x->io_lock);
+		WARN_ON(!wm831x->locked);
+		wm831x->locked = 0;
+		mutex_unlock(&wm831x->io_lock);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wm831x_reg_unlock);
+
+static int wm831x_read(struct wm831x *wm831x, unsigned short reg,
+		       int bytes, void *dest)
+{
+	int ret, i;
+	u16 *buf = dest;
+
+	BUG_ON(bytes % 2);
+	BUG_ON(bytes <= 0);
+
+	ret = wm831x->read_dev(wm831x, reg, bytes, dest);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < bytes / 2; i++) {
+		buf[i] = be16_to_cpu(buf[i]);
+
+		dev_vdbg(wm831x->dev, "Read %04x from R%d(0x%x)\n",
+			 buf[i], reg + i, reg + i);
+	}
+
+	return 0;
+}
+
+/**
+ * wm831x_reg_read: Read a single WM831x register.
+ *
+ * @wm831x: Device to read from.
+ * @reg: Register to read.
+ */
+int wm831x_reg_read(struct wm831x *wm831x, unsigned short reg)
+{
+	unsigned short val;
+	int ret;
+
+	mutex_lock(&wm831x->io_lock);
+
+	ret = wm831x_read(wm831x, reg, 2, &val);
+
+	mutex_unlock(&wm831x->io_lock);
+
+	if (ret < 0)
+		return ret;
+	else
+		return val;
+}
+EXPORT_SYMBOL_GPL(wm831x_reg_read);
+
+/**
+ * wm831x_bulk_read: Read multiple WM831x registers
+ *
+ * @wm831x: Device to read from
+ * @reg: First register
+ * @count: Number of registers
+ * @buf: Buffer to fill.
+ */
+int wm831x_bulk_read(struct wm831x *wm831x, unsigned short reg,
+		     int count, u16 *buf)
+{
+	int ret;
+
+	mutex_lock(&wm831x->io_lock);
+
+	ret = wm831x_read(wm831x, reg, count * 2, buf);
+
+	mutex_unlock(&wm831x->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wm831x_bulk_read);
+
+static int wm831x_write(struct wm831x *wm831x, unsigned short reg,
+			int bytes, void *src)
+{
+	u16 *buf = src;
+	int i;
+
+	BUG_ON(bytes % 2);
+	BUG_ON(bytes <= 0);
+
+	for (i = 0; i < bytes / 2; i++) {
+		if (wm831x_reg_locked(wm831x, reg))
+			return -EPERM;
+
+		dev_vdbg(wm831x->dev, "Write %04x to R%d(0x%x)\n",
+			 buf[i], reg + i, reg + i);
+
+		buf[i] = cpu_to_be16(buf[i]);
+	}
+
+	return wm831x->write_dev(wm831x, reg, bytes, src);
+}
+
+/**
+ * wm831x_reg_write: Write a single WM831x register.
+ *
+ * @wm831x: Device to write to.
+ * @reg: Register to write to.
+ * @val: Value to write.
+ */
+int wm831x_reg_write(struct wm831x *wm831x, unsigned short reg,
+		     unsigned short val)
+{
+	int ret;
+
+	mutex_lock(&wm831x->io_lock);
+
+	ret = wm831x_write(wm831x, reg, 2, &val);
+
+	mutex_unlock(&wm831x->io_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wm831x_reg_write);
+
+
+static int wm831x_init(struct wm831x *wm831x)
+{
+
+/*wm831x_pre_init*/
+	wm831x_reg_write(wm831x, WM831X_POWER_STATE, 0x8804);	//900ma
+	
+/*wm831x_irq_init:irq=252,180 mask irq*/
+	wm831x_reg_write(wm831x, 0x4019, 0xffff);	
+	wm831x_reg_write(wm831x, 0x401a, 0xffff);	
+	wm831x_reg_write(wm831x, 0x401b, 0xffff);	
+	wm831x_reg_write(wm831x, 0x401c, 0xffff);	
+	wm831x_reg_write(wm831x, 0x401d, 0xffff);	
+	wm831x_reg_write(wm831x, 0x4018, 0xffff);//wm831x_reg_write(wm831x, 0x4018, 0x0);	
+	wm831x_reg_write(wm831x, 0x4019, 0xffff);	
+
+/*regulator: DCDC1: 600 <--> 1800 mV */
+	//wm831x_reg_write(wm831x, 0x401c, 0xfffe);
+	//wm831x_reg_write(wm831x, 0x401c, 0xfefe);
+
+/*regulator: DCDC2: 600 <--> 1800 mV*/ 
+	//wm831x_reg_write(wm831x, 0x401c, 0xfefc);
+	//wm831x_reg_write(wm831x, 0x401c, 0xfcfc);
+
+/* regulator: DCDC3: 850 <--> 3400 mV */
+	//wm831x_reg_write(wm831x, 0x401c, 0xfcf8);
+
+/*regulator: DCDC4: 0 <--> 30000 mV */
+	//wm831x_reg_write(wm831x, 0x401c, 0xfcf0);
+
+/*wm831x_isink_enable*/
+	wm831x_reg_write(wm831x, 0x404e, 0x8500);
+	wm831x_reg_write(wm831x, 0x404e, 0xc500);
+
+/*wm831x_isink_probe:line=203,irq=220*/
+	//wm831x_reg_write(wm831x, 0x401a, 0xffbf);
+	//wm831x_reg_write(wm831x, 0x401a, 0xff3f);
+
+
+/*regulator: LDO1: 900 <--> 3300 mV */
+	//wm831x_reg_write(wm831x, 0x401b, 0xfffe);
+
+/*regulator: LDO2: 900 <--> 3300 mV*/ 
+	//wm831x_reg_write(wm831x, 0x401b, 0xfffc);
+
+/*regulator: LDO3: 900 <--> 3300 mV */
+	//wm831x_reg_write(wm831x, 0x401b, 0xfff8);
+
+/*regulator: LDO4: 900 <--> 3300 mV */
+	//wm831x_reg_write(wm831x, 0x401b, 0xfff0);
+
+/* regulator: LDO5: 900 <--> 3300 mV */
+	//wm831x_reg_write(wm831x, 0x401b, 0xffe0);
+
+/*regulator: LDO6: 900 <--> 3300 mV */
+	//wm831x_reg_write(wm831x, 0x401b, 0xffc0);
+
+/*regulator: LDO7: 1000 <--> 3500 mV */
+	//wm831x_reg_write(wm831x, 0x401b, 0xff80);
+
+/*regulator: LDO8: 1000 <--> 3500 mV */
+	//wm831x_reg_write(wm831x, 0x401b, 0xff00);
+
+/*regulator: LDO9: 1000 <--> 3500 mV */
+	//wm831x_reg_write(wm831x, 0x401b, 0xfe00);
+
+/*regulator: LDO10: 1000 <--> 3500 mV */
+	//wm831x_reg_write(wm831x, 0x401b, 0xfc00);
+
+/*regulator: LDO11: 1200 <--> 1550 mV */
+	wm831x_reg_write(wm831x, 0x4008, 0x9716);
+	wm831x_reg_write(wm831x, 0x4006, 0x8463);
+
+/*wm831x_post_init set dcdc3=3000000mV end*/
+	wm831x_reg_write(wm831x, 0x4051, 0xfa49);
+	wm831x_reg_write(wm831x, 0x4062, 0x2156);
+	
+
+/*wm831x_post_init set ldo10=3000000mV end*/
+	wm831x_reg_write(wm831x, 0x4084, 0x201a);
+
+/*wm831x_post_init set dcdc2=1300000mV end8*/
+	wm831x_reg_write(wm831x, 0x405d, 0x4140);
+
+/* wm831x_post_init set dcdc1=1800000mV end*/
+	wm831x_reg_write(wm831x, 0x4058, 0x6168);
+
+/*wm831x_post_init set ldo1=1800000mV end*/
+	wm831x_reg_write(wm831x, 0x4069, 0x6010);
+
+/*wm831x_post_init set ldo4=2500000mV end*/
+	wm831x_reg_write(wm831x, 0x4072, 0x8017);
+
+/*wm831x_post_init set ldo7=3300000mV end*/
+	wm831x_reg_write(wm831x, 0x407b, 0xa01d);
+
+/*wm831x_post_init set dcdc4=-22mV end*/
+	wm831x_reg_write(wm831x, 0x4050, 0xf);
+
+/*wm831x_post_init set ldo2=3000000mV end*/
+	wm831x_reg_write(wm831x, 0x406c, 0x1c);
+	wm831x_reg_write(wm831x, 0x4051, 0x24b);
+
+/*wm831x_post_init set ldo3=1800000mV end*/
+	wm831x_reg_write(wm831x, 0x406f, 0x10);
+	wm831x_reg_write(wm831x, 0x4051, 0x24f);
+
+/*wm831x_post_init set ldo5=3000000mV end*/
+	wm831x_reg_write(wm831x, 0x4075, 0x1c);
+	wm831x_reg_write(wm831x, 0x4051, 0x25f);
+
+/*wm831x_post_init set ldo6=2800000mV end*/
+	wm831x_reg_write(wm831x, 0x4078, 0x1a);
+	wm831x_reg_write(wm831x, 0x4051, 0x27f);
+
+/*wm831x_post_init set ldo8=1200000mV end*/
+	wm831x_reg_write(wm831x, 0x407e, 0x4);
+	wm831x_reg_write(wm831x, 0x4051, 0x2ff);
+
+/*wm831x_post_init set ldo9=3000000mV end*/
+	wm831x_reg_write(wm831x, 0x4081, 0x1a);
+	wm831x_reg_write(wm831x, 0x4051, 0x3ff);
+
+	wm831x_reg_write(wm831x, 0x4008, 0x0);
+
+	wm831x_reg_write(wm831x, 0x4008, 0x9716);
+	wm831x_reg_write(wm831x, 0x4064, 0x104);
+	wm831x_reg_write(wm831x, 0x4008, 0x0);
+	wm831x_reg_write(wm831x, 0x4050, 0x7);
+
+/* backlight brightness=255*/
+	wm831x_reg_write(wm831x, 0x404e, 0xc500);
+	wm831x_reg_write(wm831x, 0x4050, 0xf);
+	wm831x_reg_write(wm831x, 0x404e, 0xc535);
+	wm831x_reg_write(wm831x, 0x404e, 0xc535);
+
+
+/*wm831x-rtc wm831x-rtc: rtc core: registered wm831x as rtc0*/
+	//wm831x_reg_write(wm831x, 0x4019, 0xeef7);
+	//wm831x_reg_write(wm831x, 0x4019, 0xeef3);
+	
+/*wm831x_power_probe:wm831x_power initialized*/
+	wm831x_reg_write(wm831x, 0x4008, 0x9716);
+	wm831x_reg_write(wm831x, 0x404b, 0x8812);
+
+	wm831x_reg_write(wm831x, 0x4008, 0x0);
+	wm831x_reg_write(wm831x, 0x4008, 0x9716);
+	wm831x_reg_write(wm831x, 0x4048, 0x9c21);
+
+	wm831x_reg_write(wm831x, 0x4048, 0x9c21);
+
+	wm831x_reg_write(wm831x, 0x4049, 0x44ff);
+	wm831x_reg_write(wm831x, 0x4001, 0x57);
+	wm831x_reg_write(wm831x, 0x4008, 0x0);	
+	//wm831x_reg_write(wm831x, 0x4019, 0x6ef3);
+	//wm831x_reg_write(wm831x, 0x4019, 0x2ef3);	
+	
+/*device-mapper: uevent: version 1.0.3*/
+	wm831x_reg_write(wm831x, 0x402e, 0x8000);
+	wm831x_reg_write(wm831x, 0x4014, 0x8);
+	wm831x_reg_write(wm831x, 0x402f, 0x400);
+	wm831x_reg_write(wm831x, 0x402e, 0xc000);
+
+/*gpu: power on... done!*/
+	wm831x_reg_write(wm831x, 0x402e, 0x0);
+	wm831x_reg_write(wm831x, 0x4011, 0x2100);
+	wm831x_reg_write(wm831x, 0x402e, 0x8000);
+	wm831x_reg_write(wm831x, 0x402f, 0x200);
+	wm831x_reg_write(wm831x, 0x402e, 0xc000);
+
+
+/*wm831x_isink_is_enabled:line=85*/
+/*wm831x-rtc wm831x-rtc: setting system clock to 1970-01-02 04:18:35 UTC (101915)*/
+	wm831x_reg_write(wm831x, 0x402e, 0x0);
+	wm831x_reg_write(wm831x, 0x4011, 0x100);
+
+	wm831x_reg_write(wm831x, 0x402e, 0x8000);
+	wm831x_reg_write(wm831x, 0x402f, 0x100);
+	wm831x_reg_write(wm831x, 0x402e, 0xc000);
+	wm831x_reg_write(wm831x, 0x4011, 0x100);
+	wm831x_reg_write(wm831x, 0x402e, 0x0);
+
+	printk("%s\n",__FUNCTION__);
+	
+}
+
+
+struct wm831x_on {
+	struct input_dev *dev;
+	struct delayed_work work;
+	struct wm831x *wm831x;
+	struct wake_lock 	wm831x_on_wake;
+};
+
+static struct wm831x_on *g_wm831x_on;
+
+void rk29_send_wakeup_key(void)
+{
+     
+	if(!g_wm831x_on)
+	{
+		printk("%s:addr err!\n",__FUNCTION__);
+		return;
+	}
+        input_report_key(g_wm831x_on->dev, KEY_POWER, 1);
+        input_sync(g_wm831x_on->dev);
+        input_report_key(g_wm831x_on->dev, KEY_POWER, 0);
+        input_sync(g_wm831x_on->dev);
+	//printk("%s\n", __FUNCTION__);
+}
+
+
+static void wm831x_irq_worker(struct work_struct *work)
+{
+	struct wm831x *wm831x = container_of(work, struct wm831x, irq_work);	
+	
+	wm831x_reg_write(wm831x, WM831X_INTERRUPT_STATUS_1, 0xffff);//clear all intterupt
+	rk29_send_wakeup_key();
+	//enable_irq(wm831x->irq);	
+	wake_unlock(&wm831x->irq_wake);
+	printk("%s\n",__FUNCTION__);
+}
+
+static irqreturn_t wm831x_irq_thread(int irq, void *data)
+{
+	struct wm831x *wm831x = data;
+
+	//disable_irq_nosync(irq);
+	wake_lock(&wm831x->irq_wake);
+	queue_work(wm831x->irq_wq, &wm831x->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static struct platform_driver wm831x_on_driver = {
+	.driver		= {
+		.name	= "wm831x-on",
+	},
+};
+
+static struct platform_device wm831x_on_device = {
+	.name		= "wm831x-on",
+	.id		= -1,
+	.dev = {
+		.driver = &wm831x_on_driver.driver,
+	}
+	
+};
+
+static inline void wm831x_on_init(void)
+{
+	if (platform_driver_register(&wm831x_on_driver) == 0)
+	(void) platform_device_register(&wm831x_on_device);
+}
+
+
+static int __devinit wm831x_spi_probe(struct spi_device *spi)
+{
+	struct wm831x *wm831x;
+	enum wm831x_parent type;
+	int ret,gpio,irq;
+	
+	/* Currently SPI support for ID tables is unmerged, we're faking it */
+	if (strcmp(spi->modalias, "wm8310") == 0)
+		type = WM8310;
+	else if (strcmp(spi->modalias, "wm8311") == 0)
+		type = WM8311;
+	else if (strcmp(spi->modalias, "wm8312") == 0)
+		type = WM8312;
+	else if (strcmp(spi->modalias, "wm8320") == 0)
+		type = WM8320;
+	else if (strcmp(spi->modalias, "wm8321") == 0)
+		type = WM8321;
+	else if (strcmp(spi->modalias, "wm8325") == 0)
+		type = WM8325;
+	else {
+		dev_err(&spi->dev, "Unknown device type\n");
+		return -EINVAL;
+	}
+
+	wm831x = kzalloc(sizeof(struct wm831x), GFP_KERNEL);
+	if (wm831x == NULL)
+		return -ENOMEM;
+
+	spi->bits_per_word = 16;
+	spi->mode = SPI_MODE_0;
+
+	gpio = spi->irq;
+	ret = gpio_request(gpio, "wm831x");
+	if (ret) {
+		printk( "failed to request rk gpio irq for wm831x \n");
+		return ret;
+	}
+	gpio_pull_updown(gpio, GPIOPullUp);
+	if (ret) {
+	    printk("failed to pull up gpio irq for wm831x \n");
+		return ret;
+	}	
+	irq = gpio_to_irq(gpio);
+
+	dev_set_drvdata(&spi->dev, wm831x);
+	wm831x->dev = &spi->dev;
+	wm831x->control_data = spi;
+	wm831x->read_dev = wm831x_spi_read_device;
+	wm831x->write_dev = wm831x_spi_write_device;
+
+	mutex_init(&wm831x->io_lock);
+	
+	wm831x_init(wm831x);
+	//wm831x_device_init(wm831x, type, irq);
+	
+	dev_set_drvdata(wm831x->dev, wm831x);
+	wm831x_on_init();
+
+	g_wm831x_on = kzalloc(sizeof(struct wm831x_on), GFP_KERNEL);
+	if (!g_wm831x_on) {
+		printk( "Can't allocate data\n");
+		return -ENOMEM;
+	}
+	
+	g_wm831x_on->wm831x = wm831x;
+	g_wm831x_on->dev = input_allocate_device();
+	if (!g_wm831x_on->dev) {
+		//dev_err(&wm831x->dev, "Can't allocate input dev\n");
+		return  -ENOMEM;
+	}
+
+	g_wm831x_on->dev->evbit[0] = BIT_MASK(EV_KEY);
+	g_wm831x_on->dev->keybit[BIT_WORD(KEY_POWER)] = BIT_MASK(KEY_POWER);
+	g_wm831x_on->dev->name = "wm831x_on";
+	g_wm831x_on->dev->phys = "wm831x_on/input0";
+#if 0
+	g_wm831x_on->dev->dev.parent = &wm831x_on_device.dev;
+	dev_err(&wm831x_on_device.dev, "%s\n", __FUNCTION__);
+	ret = input_register_device(g_wm831x_on->dev);
+	if (ret) {
+		printk( "Can't register input device: %d\n");
+		return  -ENOMEM;
+	}
+	
+#endif
+	
+	wm831x->irq_wq = create_singlethread_workqueue("wm831x-irq");
+	if (!wm831x->irq_wq) {
+		dev_err(wm831x->dev, "Failed to allocate IRQ worker\n");
+		return -ESRCH;
+	}
+	
+	INIT_WORK(&wm831x->irq_work, wm831x_irq_worker);
+	wake_lock_init(&wm831x->irq_wake, WAKE_LOCK_SUSPEND, "wm831x_irq_wake");
+
+	ret = request_threaded_irq(irq, wm831x_irq_thread, NULL, 
+				 IRQF_TRIGGER_FALLING,
+				   "wm831x", wm831x);
+	if (ret != 0) {
+		dev_err(wm831x->dev, "Failed to request IRQ %d: %d\n",
+			wm831x->irq, ret);
+		return ret;
+	}
+
+	enable_irq_wake(irq); // so wm831x irq can wake up system
+	/* only support on intterupt */
+	wm831x_reg_write(wm831x, WM831X_SYSTEM_INTERRUPTS_MASK, 0xefff);
+	wm831x_reg_write(wm831x, WM831X_INTERRUPT_STATUS_1_MASK, 0xefff);
+
+	return 0;
+	//return wm831x_device_init(wm831x, type, irq);
+}
+
+static int __devexit wm831x_spi_remove(struct spi_device *spi)
+{
+	struct wm831x *wm831x = dev_get_drvdata(&spi->dev);
+
+	//wm831x_device_exit(wm831x);
+
+	return 0;
+}
+
+static int wm831x_spi_suspend(struct spi_device *spi, pm_message_t m)
+{
+	struct wm831x *wm831x = dev_get_drvdata(&spi->dev);
+	return 0;
+	//return wm831x_device_suspend(wm831x);
+}
+
+static struct spi_driver wm8310_spi_driver = {
+	.driver = {
+		.name	= "wm8310",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm831x_spi_probe,
+	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
+};
+
+static struct spi_driver wm8311_spi_driver = {
+	.driver = {
+		.name	= "wm8311",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm831x_spi_probe,
+	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
+};
+
+static struct spi_driver wm8312_spi_driver = {
+	.driver = {
+		.name	= "wm8312",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm831x_spi_probe,
+	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
+};
+
+static struct spi_driver wm8320_spi_driver = {
+	.driver = {
+		.name	= "wm8320",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm831x_spi_probe,
+	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
+};
+
+static struct spi_driver wm8321_spi_driver = {
+	.driver = {
+		.name	= "wm8321",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm831x_spi_probe,
+	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
+};
+
+static struct spi_driver wm8325_spi_driver = {
+	.driver = {
+		.name	= "wm8325",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm831x_spi_probe,
+	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
+};
+
+static int __init wm831x_spi_init(void)
+{
+	int ret;
+
+	ret = spi_register_driver(&wm8310_spi_driver);
+	if (ret != 0)
+		pr_err("Failed to register WM8310 SPI driver: %d\n", ret);
+
+	ret = spi_register_driver(&wm8311_spi_driver);
+	if (ret != 0)
+		pr_err("Failed to register WM8311 SPI driver: %d\n", ret);
+
+	ret = spi_register_driver(&wm8312_spi_driver);
+	if (ret != 0)
+		pr_err("Failed to register WM8312 SPI driver: %d\n", ret);
+
+	ret = spi_register_driver(&wm8320_spi_driver);
+	if (ret != 0)
+		pr_err("Failed to register WM8320 SPI driver: %d\n", ret);
+
+	ret = spi_register_driver(&wm8321_spi_driver);
+	if (ret != 0)
+		pr_err("Failed to register WM8321 SPI driver: %d\n", ret);
+
+	ret = spi_register_driver(&wm8325_spi_driver);
+	if (ret != 0)
+		pr_err("Failed to register WM8325 SPI driver: %d\n", ret);
+
+	return 0;
+}
+subsys_initcall(wm831x_spi_init);
+
+static void __exit wm831x_spi_exit(void)
+{
+	spi_unregister_driver(&wm8325_spi_driver);
+	spi_unregister_driver(&wm8321_spi_driver);
+	spi_unregister_driver(&wm8320_spi_driver);
+	spi_unregister_driver(&wm8312_spi_driver);
+	spi_unregister_driver(&wm8311_spi_driver);
+	spi_unregister_driver(&wm8310_spi_driver);
+}
+module_exit(wm831x_spi_exit);
+
+MODULE_DESCRIPTION("SPI support for WM831x/2x AudioPlus PMICs");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mark Brown");
diff --git a/drivers/rtc/rtc-test.c b/drivers/rtc/rtc-test.c
index 51725f7755b0..1cbd16fb6d27 100644
--- a/drivers/rtc/rtc-test.c
+++ b/drivers/rtc/rtc-test.c
@@ -30,7 +30,9 @@ static int test_rtc_set_alarm(struct device *dev,
 static int test_rtc_read_time(struct device *dev,
 	struct rtc_time *tm)
 {
-	rtc_time_to_tm(get_seconds(), tm);
+	unsigned long time = 0xffffff;
+	rtc_time_to_tm(time, tm);
+	//rtc_time_to_tm(get_seconds(), tm);
 	return 0;
 }
 
diff --git a/drivers/video/display/screen/lcd_ili9803_cpt4_3.c b/drivers/video/display/screen/lcd_ili9803_cpt4_3.c
index b974a2614c53..1a39d29d0434 100755
--- a/drivers/video/display/screen/lcd_ili9803_cpt4_3.c
+++ b/drivers/video/display/screen/lcd_ili9803_cpt4_3.c
@@ -8,19 +8,23 @@
 
 /* Base */
 #define OUT_TYPE		SCREEN_RGB
-#define OUT_FACE		OUT_P888
-#define OUT_CLK			26	//***27
+#define OUT_FACE		OUT_P666
+#define OUT_CLK		26*1000*1000	//***27
+#define LCDC_ACLK       150000000     //29 lcdc axi DMA 频锟斤拷           //rk29
 
 /* Timing */
-#define H_PW			16 //8前消影
-#define H_BP			24//6
+#define H_PW			4 //8前消影
+#define H_BP			8//6
 #define H_VD			480//320	//***800 
-#define H_FP			16//60
+#define H_FP			8//60
 
-#define V_PW			2//12
-#define V_BP			2// 4
+#define V_PW			4//12
+#define V_BP			8// 4
 #define V_VD			800//480	//***480
-#define V_FP			4//40
+#define V_FP			8//40
+
+#define LCD_WIDTH       800    //need modify   //rk29
+#define LCD_HEIGHT      480
 
 /* Other */
 #define DCLK_POL		1//0 
@@ -46,7 +50,7 @@ int standby(u8 enable);
 
 
 #define DRVDelayUs(i)   udelay(i*4)
-
+#if 0
 void spi_screenreg_cmd(u8 Addr)
 {
  u32 i;
@@ -118,20 +122,24 @@ void spi_screenreg_param(u8 Param)
         TXD_CLR();
         DRVDelayUs(10);
 }
+#endif
 
 void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
 {
 	//printk("lcd_hx8357 set_lcd_info \n"); 
-    /* screen type & face */
-    screen->type = OUT_TYPE;
-    screen->face = OUT_FACE;
- 
-    /* Screen size */
-    screen->x_res = H_VD;
-    screen->y_res = V_VD;
+	/* screen type & face */
+	screen->type = OUT_TYPE;
+	screen->face = OUT_FACE;
 
-    /* Timing */
-    screen->pixclock = OUT_CLK;
+	/* Screen size */
+	screen->x_res = H_VD;
+	screen->y_res = V_VD;
+	screen->width = LCD_WIDTH;    //rk29
+	screen->height = LCD_HEIGHT;  //rk29
+
+	/* Timing */
+	screen->lcdc_aclk = LCDC_ACLK;  //rk29
+	screen->pixclock = OUT_CLK;
 	screen->left_margin = H_BP;		/*>2*/ 
 	screen->right_margin = H_FP;	/*>2*/ 
 	screen->hsync_len = H_PW;		/*>2*/ //***all > 326, 4<PW+BP<15, 
@@ -146,142 +154,1281 @@ void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
 	screen->pin_dclk = DCLK_POL;
 
 	/* Swap rule */
-    screen->swap_rb = SWAP_RB;
-    screen->swap_rg = 0;
-    screen->swap_gb = 0;
-    screen->swap_delta = 0;
-    screen->swap_dumy = 0;
-
-    /* Operation function*/
-    screen->init = init;
-    screen->standby = standby;
-    if(lcd_info)
-        gLcd_info = lcd_info;
+	screen->swap_rb = 0;
+	screen->swap_rg = 0;
+	screen->swap_gb = 0;
+	screen->swap_delta = 0;
+	screen->swap_dumy = 0;
+
+	/* Operation function*/
+	screen->init = init;
+	screen->standby = standby;
+	if(lcd_info)
+	gLcd_info = lcd_info;
+}
+
+#define PIN_BL_SET          RK29_PIN6_PD2
+void set_backlight(int brightness)
+{
+#if 0
+ 	if(gLcd_info)
+        gLcd_info->io_init();
+
+	printk("lcd_ili9803:set_backlight = %d\r\n", brightness);
+	if (brightness < 0)
+	{
+		brightness = 0;
+	}
+	if (brightness > 4)
+	{
+		brightness = 4;
+	}
+	spi_screenreg_cmd(0x51);
+	spi_screenreg_param(brightness<<5);
+		
+  	 if(gLcd_info)
+        gLcd_info->io_deinit();
+
+#endif
+
+	gpio_request(PIN_BL_SET, NULL);
+	if(brightness > 0)
+        gpio_direction_output(PIN_BL_SET,GPIO_HIGH);
+	else
+	gpio_direction_output(PIN_BL_SET,GPIO_LOW);	
+
+}
+
+void WriteCommand( int  Command)
+{
+	unsigned char i,count1, count2,count3,count4;
+	count1= Command>>8;
+	count2= Command;
+	count3=0x20;//00100000   //写命令高位
+	count4=0x00;//00000000   //写命令低位======具体请看IC的Datasheet
+	CS_CLR();
+	for(i=0;i<8;i++)
+	{
+		CLK_CLR();
+		if (count3 & 0x80) TXD_SET();
+		else             TXD_CLR();
+		CLK_SET();
+		count3<<=1;
+	}
+
+	for(i=0;i<8;i++)
+	{
+		CLK_CLR();
+		if (count1 & 0x80) TXD_SET();
+		else             TXD_CLR();
+		CLK_SET();
+		count1<<=1;
+	}
+
+	for(i=0;i<8;i++)
+	{
+		CLK_CLR();
+		if (count4 & 0x80) TXD_SET();
+		else             TXD_CLR();
+		CLK_SET();
+		count4<<=1;
+	}
+	
+	for(i=0;i<8;i++)
+	{
+		CLK_CLR();
+		if (count2 & 0x80) TXD_SET();
+		else             TXD_CLR();
+		CLK_SET();
+		count2<<=1;
+	}
+
+	CS_SET();
+
+}
+
+
+
+void WriteParameter(char DH)
+{
+	unsigned char i, count1, count2,count3,count4;
+	count1=DH>>8;
+	count2=DH;
+	count3=0x60;//写数据高位
+	count4=0x40;//写数据低位
+
+	CS_CLR();
+	/*
+	TXD_CLR();  CLK_CLR(); CLK_SET();  //WRITE
+	TXD_SET(); CLK_CLR(); CLK_SET();  //DATA
+	TXD_SET(); CLK_CLR(); CLK_SET(); //HIGH BYTE
+	TXD_CLR(); CLK_CLR(); CLK_SET();
+	TXD_CLR(); CLK_CLR(); CLK_SET();
+	TXD_CLR(); CLK_CLR(); CLK_SET();
+	TXD_CLR(); CLK_CLR(); CLK_SET();
+	TXD_CLR(); CLK_CLR(); CLK_SET();
+	*/
+	/*
+	//因为数据的高位基本是不用的，可以不传高位，直接传低位
+	for(i=0;i<8;i++)
+	{
+	CLK_CLR();
+	if (count3 & 0x80) TXD_SET();
+	else             TXD_CLR();
+	CLK_SET();
+	count3<<=1;
+	}
+
+	for(i=0;i<8;i++)
+	{
+	CLK_CLR();
+	if (count1 & 0x80) TXD_SET();
+	else             TXD_CLR();
+	CLK_SET();
+	count1<<=1;
+	}
+	*/
+
+
+	for(i=0;i<8;i++)
+	{
+		CLK_CLR();
+		if (count4 & 0x80) TXD_SET();
+		else             TXD_CLR();
+		CLK_SET();
+		count4<<=1;
+	}
+
+	for(i=0;i<8;i++)
+	{
+		CLK_CLR();
+		if (count2 & 0x80) TXD_SET();
+		else             TXD_CLR();
+		CLK_SET();
+		count2<<=1;
+	}
+
+	CS_SET();
+
 }
 
+
+void init_nt35510(void)
+{
+	WriteCommand(0X1100); 
+	mdelay(120);
+
+	WriteCommand(0X1300); 
+
+	WriteCommand(0XF000); 
+	WriteParameter(0x55);
+
+	WriteCommand(0XF001); 
+	WriteParameter(0xAA);
+
+	WriteCommand(0XF002); 
+	WriteParameter(0x52);
+
+	WriteCommand(0XF003); 
+	WriteParameter(0x08);
+
+	WriteCommand(0XF004); 
+	WriteParameter(0x01);
+
+	//Gamma setting Red
+	WriteCommand(0XD100);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD101);
+	WriteParameter(0x20);
+
+	WriteCommand(0XD102);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD103);
+	WriteParameter(0x2B);
+
+	WriteCommand(0XD104);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD105);
+	WriteParameter(0x3C);
+
+	WriteCommand(0XD106);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD107);
+	WriteParameter(0x56);
+
+	WriteCommand(0XD108);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD109);
+	WriteParameter(0x68);
+
+	WriteCommand(0XD10a);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD10b);
+	WriteParameter(0x87);
+
+	WriteCommand(0XD10c);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD10d);
+	WriteParameter(0x9E);
+
+	WriteCommand(0XD10e);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD10f);
+	WriteParameter(0xC6);
+
+	WriteCommand(0XD110);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD111);
+	WriteParameter(0xE4);
+
+	WriteCommand(0XD112);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD113);
+	WriteParameter(0x12);
+
+	WriteCommand(0XD114);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD115);
+	WriteParameter(0x37);
+
+	WriteCommand(0XD116);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD117);
+	WriteParameter(0x75);
+
+	WriteCommand(0XD118);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD119);
+	WriteParameter(0xA5);
+
+	WriteCommand(0XD11a);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD11b);
+	WriteParameter(0xA6);
+
+	WriteCommand(0XD11c);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD11d);
+	WriteParameter(0xD0);
+
+	WriteCommand(0XD11e);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD11f);
+	WriteParameter(0xF5);
+
+	WriteCommand(0XD120);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD121);
+	WriteParameter(0x0A);
+
+	WriteCommand(0XD122);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD123);
+	WriteParameter(0x26);
+
+	WriteCommand(0XD124);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD125);
+	WriteParameter(0x3B);
+
+	WriteCommand(0XD126);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD127);
+	WriteParameter(0x6B);
+
+	WriteCommand(0XD128);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD129);
+	WriteParameter(0x99);
+
+	WriteCommand(0XD12a);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD12b);
+	WriteParameter(0xDD);
+
+	WriteCommand(0XD12C);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD12D);
+	WriteParameter(0x10);
+
+	WriteCommand(0XD12E);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD12F);
+	WriteParameter(0x26);
+
+	WriteCommand(0XD130);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD131);
+	WriteParameter(0x32);
+
+	WriteCommand(0XD132);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD133);
+	WriteParameter(0x9A);
+
+	//Gamma setting Green
+	WriteCommand(0XD200);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD201);
+	WriteParameter(0xa0);
+
+	WriteCommand(0XD202);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD203);
+	WriteParameter(0xa9);
+
+	WriteCommand(0XD204);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD205);
+	WriteParameter(0xb5);
+
+	WriteCommand(0XD206);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD207);
+	WriteParameter(0xbf);
+
+	WriteCommand(0XD208);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD209);
+	WriteParameter(0xc9);
+
+	WriteCommand(0XD20a);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD20b);
+	WriteParameter(0xdc);
+
+	WriteCommand(0XD20c);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD20d);
+	WriteParameter(0xEE);
+
+	WriteCommand(0XD20e);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD20f);
+	WriteParameter(0x0A);
+
+	WriteCommand(0XD210);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD211);
+	WriteParameter(0x21);
+
+	WriteCommand(0XD212);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD213);
+	WriteParameter(0x48);
+
+	WriteCommand(0XD214);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD215);
+	WriteParameter(0x67);
+
+	WriteCommand(0XD216);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD217);
+	WriteParameter(0x97);
+
+	WriteCommand(0XD218);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD219);
+	WriteParameter(0xBE);
+
+	WriteCommand(0XD21a);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD21b);
+	WriteParameter(0xC0);
+
+	WriteCommand(0XD21c);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD21d);
+	WriteParameter(0xE1);
+
+	WriteCommand(0XD21e);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD21f);
+	WriteParameter(0x04);
+
+	WriteCommand(0XD220);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD221);
+	WriteParameter(0x17);
+
+	WriteCommand(0XD222);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD223);
+	WriteParameter(0x36);
+
+	WriteCommand(0XD224);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD225);
+	WriteParameter(0x50);
+
+	WriteCommand(0XD226);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD227);
+	WriteParameter(0x7E);
+
+	WriteCommand(0XD228);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD229);
+	WriteParameter(0xAC);
+
+	WriteCommand(0XD22a);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD22b);
+	WriteParameter(0xF1);
+
+	WriteCommand(0XD22C);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD22D);
+	WriteParameter(0x20);
+
+	WriteCommand(0XD22E);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD22F);
+	WriteParameter(0x38);
+
+	WriteCommand(0XD230);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD231);
+	WriteParameter(0x43);
+
+	WriteCommand(0XD232);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD233);
+	WriteParameter(0x9A);
+
+
+	//Gamma setting Blue
+	WriteCommand(0XD300);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD301);
+	WriteParameter(0x50);
+
+	WriteCommand(0XD302);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD303);
+	WriteParameter(0x53);
+
+	WriteCommand(0XD304);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD305);
+	WriteParameter(0x73);
+
+	WriteCommand(0XD306);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD307);
+	WriteParameter(0x89);
+
+	WriteCommand(0XD308);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD309);
+	WriteParameter(0x9f);
+
+	WriteCommand(0XD30a);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD30b);
+	WriteParameter(0xc1);
+
+	WriteCommand(0XD30c);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD30d);
+	WriteParameter(0xda);
+
+	WriteCommand(0XD30e);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD30f);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD310);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD311);
+	WriteParameter(0x23);
+
+	WriteCommand(0XD312);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD313);
+	WriteParameter(0x50);
+
+	WriteCommand(0XD314);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD315);
+	WriteParameter(0x6f);
+
+	WriteCommand(0XD316);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD317);
+	WriteParameter(0x9f);
+
+	WriteCommand(0XD318);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD319);
+	WriteParameter(0xc5);
+
+	WriteCommand(0XD31a);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD31b);
+	WriteParameter(0xC6);
+
+	WriteCommand(0XD31c);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD31d);
+	WriteParameter(0xE3);
+
+	WriteCommand(0XD31e);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD31f);
+	WriteParameter(0x08);
+
+	WriteCommand(0XD320);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD321);
+	WriteParameter(0x16);
+
+	WriteCommand(0XD322);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD323);
+	WriteParameter(0x2b);
+
+	WriteCommand(0XD324);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD325);
+	WriteParameter(0x4d);
+
+	WriteCommand(0XD326);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD327);
+	WriteParameter(0x6f);
+
+	WriteCommand(0XD328);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD329);
+	WriteParameter(0x8C);
+
+	WriteCommand(0XD32a);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD32b);
+	WriteParameter(0xd6);
+
+	WriteCommand(0XD32C);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD32D);
+	WriteParameter(0x12);
+
+	WriteCommand(0XD32E);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD32F);
+	WriteParameter(0x28);
+
+	WriteCommand(0XD330);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD331);
+	WriteParameter(0x3e);
+
+	WriteCommand(0XD332);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD333);
+	WriteParameter(0x9A);
+
+	//Gamma setting Red
+	WriteCommand(0XD400);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD401);
+	WriteParameter(0x20);
+
+	WriteCommand(0XD402);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD403);
+	WriteParameter(0x2b);
+
+	WriteCommand(0XD404);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD405);
+	WriteParameter(0x3c);
+
+	WriteCommand(0XD406);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD407);
+	WriteParameter(0x56);
+
+	WriteCommand(0XD408);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD409);
+	WriteParameter(0x68);
+
+	WriteCommand(0XD40a);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD40b);
+	WriteParameter(0x87);
+
+	WriteCommand(0XD40c);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD40d);
+	WriteParameter(0x9e);
+
+	WriteCommand(0XD40e);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD40f);
+	WriteParameter(0xc6);
+
+	WriteCommand(0XD410);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD411);
+	WriteParameter(0xe4);
+
+	WriteCommand(0XD412);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD413);
+	WriteParameter(0x12);
+
+	WriteCommand(0XD414);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD415);
+	WriteParameter(0x37);
+
+	WriteCommand(0XD416);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD417);
+	WriteParameter(0x75);
+
+	WriteCommand(0XD418);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD419);
+	WriteParameter(0xa5);
+
+	WriteCommand(0XD41a);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD41b);
+	WriteParameter(0xa6);
+
+	WriteCommand(0XD41c);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD41d);
+	WriteParameter(0xd0);
+
+	WriteCommand(0XD41e);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD41f);
+	WriteParameter(0xf5);
+
+	WriteCommand(0XD420);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD421);
+	WriteParameter(0x0a);
+
+	WriteCommand(0XD422);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD423);
+	WriteParameter(0x26);
+
+	WriteCommand(0XD424);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD425);
+	WriteParameter(0x3b);
+
+	WriteCommand(0XD426);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD427);
+	WriteParameter(0x6b);
+
+	WriteCommand(0XD428);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD429);
+	WriteParameter(0x99);
+
+	WriteCommand(0XD42a);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD42b);
+	WriteParameter(0xdd);
+
+	WriteCommand(0XD42C);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD42D);
+	WriteParameter(0x10);
+
+	WriteCommand(0XD42E);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD42F);
+	WriteParameter(0x26);
+
+	WriteCommand(0XD430);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD431);
+	WriteParameter(0x32);
+
+	WriteCommand(0XD432);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD433);
+	WriteParameter(0x9A);
+
+	//Gamma setting Green
+	WriteCommand(0XD500);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD501);
+	WriteParameter(0xa0);
+
+	WriteCommand(0XD502);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD503);
+	WriteParameter(0xa9);
+
+	WriteCommand(0XD504);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD505);
+	WriteParameter(0xb5);
+
+	WriteCommand(0XD506);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD507);
+	WriteParameter(0xbf);
+
+	WriteCommand(0XD508);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD509);
+	WriteParameter(0xc9);
+
+	WriteCommand(0XD50a);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD50b);
+	WriteParameter(0xdc);
+
+	WriteCommand(0XD50c);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD50d);
+	WriteParameter(0xee);
+
+	WriteCommand(0XD50e);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD50f);
+	WriteParameter(0x0a);
+
+	WriteCommand(0XD510);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD511);
+	WriteParameter(0x21);
+
+	WriteCommand(0XD512);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD513);
+	WriteParameter(0x48);
+
+	WriteCommand(0XD514);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD515);
+	WriteParameter(0x67);
+
+	WriteCommand(0XD516);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD517);
+	WriteParameter(0x97);
+
+	WriteCommand(0XD518);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD519);
+	WriteParameter(0xbe);
+
+	WriteCommand(0XD51a);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD51b);
+	WriteParameter(0xc0);
+
+	WriteCommand(0XD51c);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD51d);
+	WriteParameter(0xe1);
+
+	WriteCommand(0XD51e);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD51f);
+	WriteParameter(0x04);
+
+	WriteCommand(0XD520);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD521);
+	WriteParameter(0x17);
+
+	WriteCommand(0XD522);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD523);
+	WriteParameter(0x36);
+
+	WriteCommand(0XD524);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD525);
+	WriteParameter(0x50);
+
+	WriteCommand(0XD526);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD527);
+	WriteParameter(0x7e);
+
+	WriteCommand(0XD528);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD529);
+	WriteParameter(0xac);
+
+	WriteCommand(0XD52a);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD52b);
+	WriteParameter(0xf1);
+
+	WriteCommand(0XD52C);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD52D);
+	WriteParameter(0x20);
+
+	WriteCommand(0XD52E);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD52F);
+	WriteParameter(0x38);
+
+	WriteCommand(0XD530);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD531);
+	WriteParameter(0x43);
+
+	WriteCommand(0XD532);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD533);
+	WriteParameter(0x9A);
+
+	//Gamma setting Blue
+	WriteCommand(0XD600);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD601);
+	WriteParameter(0x50);
+
+	WriteCommand(0XD602);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD603);
+	WriteParameter(0x53);
+
+	WriteCommand(0XD604);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD605);
+	WriteParameter(0x73);
+
+	WriteCommand(0XD606);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD607);
+	WriteParameter(0x89);
+
+	WriteCommand(0XD608);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD609);
+	WriteParameter(0x9f);
+
+	WriteCommand(0XD60a);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD60b);
+	WriteParameter(0xc1);
+
+	WriteCommand(0XD60c);
+	WriteParameter(0x00);
+
+	WriteCommand(0XD60d);
+	WriteParameter(0xda);
+
+	WriteCommand(0XD60e);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD60f);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD610);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD611);
+	WriteParameter(0x23);
+
+	WriteCommand(0XD612);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD613);
+	WriteParameter(0x50);
+
+	WriteCommand(0XD614);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD615);
+	WriteParameter(0x6f);
+
+	WriteCommand(0XD616);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD617);
+	WriteParameter(0x9f);
+
+	WriteCommand(0XD618);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD619);
+	WriteParameter(0xc5);
+
+	WriteCommand(0XD61a);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD61b);
+	WriteParameter(0xc6);
+
+	WriteCommand(0XD61c);
+	WriteParameter(0x01);
+
+	WriteCommand(0XD61d);
+	WriteParameter(0xe3);
+
+	WriteCommand(0XD61e);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD61f);
+	WriteParameter(0x08);
+
+	WriteCommand(0XD620);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD621);
+	WriteParameter(0x16);
+
+	WriteCommand(0XD622);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD623);
+	WriteParameter(0x2b);
+
+	WriteCommand(0XD624);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD625);
+	WriteParameter(0x4d);
+
+	WriteCommand(0XD626);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD627);
+	WriteParameter(0x6f);
+
+	WriteCommand(0XD628);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD629);
+	WriteParameter(0x8c);
+
+	WriteCommand(0XD62a);
+	WriteParameter(0x02);
+
+	WriteCommand(0XD62b);
+	WriteParameter(0xd6);
+
+	WriteCommand(0XD62C);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD62D);
+	WriteParameter(0x12);
+
+	WriteCommand(0XD62E);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD62F);
+	WriteParameter(0x28);
+
+	WriteCommand(0XD630);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD631);
+	WriteParameter(0x3e);
+
+	WriteCommand(0XD632);
+	WriteParameter(0x03);
+
+	WriteCommand(0XD633);
+	WriteParameter(0x9A);
+
+	WriteCommand(0XBA00); 
+	WriteParameter(0x14);
+
+	WriteCommand(0XBA01); 
+	WriteParameter(0x14);
+
+	WriteCommand(0XBA02); 
+	WriteParameter(0x14);
+
+	WriteCommand(0XBF00); 
+	WriteParameter(0x01);
+
+	WriteCommand(0XB300); 
+	WriteParameter(0x07);
+
+	WriteCommand(0XB301); 
+	WriteParameter(0x07);
+
+	WriteCommand(0XB302); 
+	WriteParameter(0x07);
+
+	WriteCommand(0XB900); 
+	WriteParameter(0x25);
+
+	WriteCommand(0XB901); 
+	WriteParameter(0x25);
+
+	WriteCommand(0XB902); 
+	WriteParameter(0x25);
+
+
+
+	WriteCommand(0XBC01); 
+	WriteParameter(0xA0);
+
+	WriteCommand(0XBC02); 
+	WriteParameter(0x00);
+
+	WriteCommand(0XBD01); 
+	WriteParameter(0xA0);
+
+	WriteCommand(0XBD02); 
+	WriteParameter(0x00);
+
+
+	WriteCommand(0XF000); 
+	WriteParameter(0x55);
+
+	WriteCommand(0XF001); 
+	WriteParameter(0xAA);
+
+	WriteCommand(0XF002); 
+	WriteParameter(0x52);
+
+	WriteCommand(0XF003); 
+	WriteParameter(0x08);
+
+	WriteCommand(0XF004); 
+	WriteParameter(0x00);
+
+	WriteCommand(0XB100); 
+	WriteParameter(0xCC);
+
+	WriteCommand(0XBC00); 
+	WriteParameter(0x05);
+
+	WriteCommand(0XBC01); 
+	WriteParameter(0x05);
+
+	WriteCommand(0XBC02); 
+	WriteParameter(0x05);
+
+
+	WriteCommand(0XBD02); 
+	WriteParameter(0x07);
+	WriteCommand(0XBD03); 
+	WriteParameter(0x31);
+
+	WriteCommand(0XBE02); 
+	WriteParameter(0x07);
+	WriteCommand(0XBE03); 
+	WriteParameter(0x31);
+
+	WriteCommand(0XBF02); 
+	WriteParameter(0x07);
+	WriteCommand(0XBF03); 
+	WriteParameter(0x31);
+
+	WriteCommand(0XFF00); 
+	WriteParameter(0xAA);
+	WriteCommand(0XFF01); 
+	WriteParameter(0x55);
+	WriteCommand(0XFF02); 
+	WriteParameter(0x25);
+	WriteCommand(0XFF03); 
+	WriteParameter(0x01);
+
+
+	WriteCommand(0X3500); 
+	WriteParameter(0x00);
+
+	WriteCommand(0X3a00); 
+	WriteParameter(0x60);//WriteParameter(0x66);
+
+	WriteCommand(0X3600); 
+	WriteParameter(0x00);//R<->B
+
+	WriteCommand(0X2000); //
+
+	WriteCommand(0X1100); 
+	mdelay(120);
+
+	WriteCommand(0X2900); 
+
+	mdelay(100);
+	WriteCommand(0X2C00); 
+}
+
+
+
 int init(void)
 { 
 	volatile u32 data;
+	int i;
+	printk("lcd init...\n");
+	/* reset lcd to start init lcd */
+	gpio_request(RK29_PIN6_PC6, NULL);
+	gpio_direction_output(RK29_PIN6_PC6, 1);
+	gpio_direction_output(RK29_PIN6_PC6, 0);
+	mdelay(5);
+	gpio_set_value(RK29_PIN6_PC6, 1);
+	mdelay(50);
+	gpio_free(RK29_PIN6_PC6);
 
 	if(gLcd_info)
 	gLcd_info->io_init();
+	init_nt35510();
 
-	printk("lcd init...\n");
-	spi_screenreg_cmd(0xB1);
-	spi_screenreg_param(0x00);
-	spi_screenreg_cmd(0xB2);
-	spi_screenreg_param(0x10);
-	spi_screenreg_param(0xC7);
-	spi_screenreg_cmd(0xB3);
-	spi_screenreg_param(0x00);
-	spi_screenreg_cmd(0xB4);
-	spi_screenreg_param(0x00);
-	spi_screenreg_cmd(0xB9);
-	spi_screenreg_param(0x00);
-	spi_screenreg_cmd(0xC3);
-	spi_screenreg_param(0x07);
-	spi_screenreg_cmd(0xB2);
-	spi_screenreg_param(0x04);
-	spi_screenreg_param(0x0B);
-	spi_screenreg_param(0x0B);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x07);
-	spi_screenreg_param(0x04);
-	spi_screenreg_cmd(0xC5);
-	spi_screenreg_param(0x6E);
-	spi_screenreg_cmd(0xC2);
-	spi_screenreg_param(0x20);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x10);
-	mdelay(20);//20ms
-    
-	spi_screenreg_cmd(0xC8);
-	spi_screenreg_param(0xA3);
-	spi_screenreg_cmd(0xC9);
-	spi_screenreg_param(0x32);
-	spi_screenreg_param(0x06);
-	spi_screenreg_cmd(0xD7);
-	spi_screenreg_param(0x03);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x0F);
-	spi_screenreg_param(0x0F);
-	spi_screenreg_cmd(0xCF);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x08);
-	spi_screenreg_cmd(0xB6);
-	spi_screenreg_param(0x20);
-	spi_screenreg_param(0xC2);
-	spi_screenreg_param(0xFF);
-	spi_screenreg_param(0x04);
-	spi_screenreg_cmd(0xEA);
-	spi_screenreg_param(0x00);
-	spi_screenreg_cmd(0x2A);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x01);
-	spi_screenreg_param(0xDF);
-	spi_screenreg_cmd(0x2B);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x03);
-	spi_screenreg_param(0xEF);
-	spi_screenreg_cmd(0xB0);
-	spi_screenreg_param(0x01);
-	spi_screenreg_cmd(0x0C);
-	spi_screenreg_param(0x50);
-	spi_screenreg_cmd(0x36);
-	spi_screenreg_param(0x48);
-	spi_screenreg_cmd(0x3A);
-	spi_screenreg_param(0x66);
-	spi_screenreg_cmd(0xE0);
-	spi_screenreg_param(0x05);
-	spi_screenreg_param(0x07);
-	spi_screenreg_param(0x0B);
-	spi_screenreg_param(0x14);
-	spi_screenreg_param(0x11);
-	spi_screenreg_param(0x14);
-	spi_screenreg_param(0x0A);
-	spi_screenreg_param(0x07);
-	spi_screenreg_param(0x04);
-	spi_screenreg_param(0x0B);
-	spi_screenreg_param(0x02);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x04);
-	spi_screenreg_param(0x33);
-	spi_screenreg_param(0x36);
-	spi_screenreg_param(0x1F);
-	spi_screenreg_cmd(0xE1);
-	spi_screenreg_param(0x1F);
-	spi_screenreg_param(0x36);
-	spi_screenreg_param(0x33);
-	spi_screenreg_param(0x04);
-	spi_screenreg_param(0x00);
-	spi_screenreg_param(0x02);
-	spi_screenreg_param(0x0B);
-	spi_screenreg_param(0x04);
-	spi_screenreg_param(0x07);
-	spi_screenreg_param(0x0A);
-	spi_screenreg_param(0x14);
-	spi_screenreg_param(0x11);
-	spi_screenreg_param(0x14);
-	spi_screenreg_param(0x0B);
-	spi_screenreg_param(0x07);
-	spi_screenreg_param(0x05);
-	spi_screenreg_cmd(0x11);
-	mdelay(70);
-	spi_screenreg_cmd(0x29);
-	mdelay(10);
-	spi_screenreg_cmd(0x2C);
 	if(gLcd_info)
 	gLcd_info->io_deinit();
 
+	set_backlight(255);
+
     return 0;
 }
 
 int standby(u8 enable)	//***enable =1 means suspend, 0 means resume 
 {
 	int i;
-#if 1	
+	set_backlight(0);
+#if 0
     if(gLcd_info)
         gLcd_info->io_init();
 
@@ -307,26 +1454,4 @@ int standby(u8 enable)	//***enable =1 means suspend, 0 means resume
     return 0;
 }
 
-void set_backlight(int brightness)
-{
-#if 1
- 	if(gLcd_info)
-        gLcd_info->io_init();
-
-	printk("lcd_ili9803:set_backlight = %d\r\n", brightness);
-	if (brightness < 0)
-	{
-		brightness = 0;
-	}
-	if (brightness > 4)
-	{
-		brightness = 4;
-	}
-	spi_screenreg_cmd(0x51);
-	spi_screenreg_param(brightness<<5);
-		
-  	 if(gLcd_info)
-        gLcd_info->io_deinit();
 
-#endif
-}
-- 
2.35.3

