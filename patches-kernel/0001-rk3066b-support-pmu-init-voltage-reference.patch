From 3e3a0666431b137d83560fcd56d3a111246c0b1c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E5=BC=A0=E6=99=B4?= <zhangqing@rock-chips.com>
Date: Wed, 24 Oct 2012 18:18:15 +0800
Subject: [PATCH] rk3066b:support pmu init voltage reference

---
 arch/arm/mach-rk30/board-rk3066b-sdk.c      | 171 +++-
 arch/arm/mach-rk30/board-rk3066b-tps65910.c | 591 ++++++++++++++
 arch/arm/mach-rk30/board-rk3066b-wm8326.c   | 844 ++++++++++++++++++++
 arch/arm/plat-rk/include/plat/board.h       |   7 +
 4 files changed, 1611 insertions(+), 2 deletions(-)
 create mode 100755 arch/arm/mach-rk30/board-rk3066b-tps65910.c
 create mode 100755 arch/arm/mach-rk30/board-rk3066b-wm8326.c

diff --git a/arch/arm/mach-rk30/board-rk3066b-sdk.c b/arch/arm/mach-rk30/board-rk3066b-sdk.c
index 8f98e4e1ab04..55e1fef9ddb3 100755
--- a/arch/arm/mach-rk30/board-rk3066b-sdk.c
+++ b/arch/arm/mach-rk30/board-rk3066b-sdk.c
@@ -1329,15 +1329,182 @@ static struct i2c_board_info __initdata i2c0_info[] = {
 int __sramdata g_pmic_type =  0;
 #ifdef CONFIG_I2C1_RK30
 #ifdef CONFIG_MFD_WM831X_I2C
-#include "board-rk3066b-sdk-wm8326.c"
+
+#define PMU_POWER_SLEEP 		RK30_PIN0_PA1 
+
+static struct pmu_info  wm8326_dcdc_info[] = {
+	{
+		.name          = "vdd_core",   //logic
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  950000,
+	},
+	{
+		.name          = "vdd_cpu",    //arm
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  950000,
+	},
+	{
+		.name          = "dcdc3",   //ddr
+		.min_uv          = 1150000,
+		.max_uv         = 1150000,
+		.suspend_vol  =  1150000,
+	},
+	#ifdef CONFIG_MACH_RK3066_SDK
+	{
+		.name          = "dcdc4",   //vcc_io
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3000000,
+	},
+	#else
+	{
+		.name          = "dcdc4",   //vcc_io
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+		.suspend_vol  =  2800000,
+	},
+	#endif
+};
+
+static struct pmu_info  wm8326_ldo_info[] = {
+	{
+		.name          = "ldo1",   //vcc18_cif
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+	{
+		.name          = "ldo2",    //vccio_wl
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+	{
+		.name          = "ldo3",   //
+		.min_uv          = 1100000,
+		.max_uv         = 1100000,
+		.suspend_vol  =  1100000,
+	},
+	{
+		.name          = "ldo4",   //vdd11
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+		.suspend_vol  =  1000000,
+	},
+	{
+		.name          = "ldo5",   //vcc25
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+	{
+		.name          = "ldo6",   //vcc33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3300000,
+	},
+	{
+		.name          = "ldo7",   //vcc28_cif
+		.min_uv          = 2800000,
+		.max_uv         = 2800000,
+		.suspend_vol  =  2800000,
+	},
+	{
+		.name          = "ldo8",   //vcca33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3300000,
+	},
+	{
+		.name          = "ldo9",   //vcc_tp
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+		.suspend_vol  =  3300000,
+	},
+	{
+		.name          = "ldo10",   //flash_io
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+		.suspend_vol  =  1800000,
+	},
+};
+
+#include "board-rk3066b-wm8326.c"
 #endif
+
 #ifdef CONFIG_MFD_TPS65910
 #ifdef CONFIG_ARCH_RK3066B
 #define TPS65910_HOST_IRQ        RK30_PIN0_PB3
 #else
 #define TPS65910_HOST_IRQ        RK30_PIN6_PA4
 #endif
-#include "board-rk3066b-sdk-tps65910.c"
+
+#define PMU_POWER_SLEEP RK30_PIN0_PA1
+
+static struct pmu_info  tps65910_dcdc_info[] = {
+	{
+		.name          = "vdd_cpu",   //arm
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+	},
+	{
+		.name          = "vdd2",    //ddr
+		.min_uv          = 1200000,
+		.max_uv         = 1200000,
+	},
+	{
+		.name          = "vio",   //vcc_io
+		.min_uv          = 3000000,
+		.max_uv         = 3000000,
+	},
+	
+};
+static  struct pmu_info  tps65910_ldo_info[] = {
+	{
+		.name          = "vpll",   //vcc25
+		.min_uv          = 2500000,
+		.max_uv         = 2500000,
+	},
+	{
+		.name          = "vdig1",    //vcc18_cif
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+	{
+		.name          = "vdig2",   //vdd11
+		.min_uv          = 1000000,
+		.max_uv         = 1000000,
+	},
+	{
+		.name          = "vaux1",   //vcc25_hdmi
+		.min_uv          = 2500000,
+		.max_uv         = 2500000,
+	},
+	{
+		.name          = "vaux2",   //vcca33
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "vaux33",   //vcc_tp
+		.min_uv          = 3300000,
+		.max_uv         = 3300000,
+	},
+	{
+		.name          = "vmmc",   //vcc28_cif
+		.min_uv          = 2800000,
+		.max_uv         = 2800000,
+	},
+	{
+		.name          = "vdac",   //vccio_wl
+		.min_uv          = 1800000,
+		.max_uv         = 1800000,
+	},
+ };
+
+#include "board-rk3066b-tps65910.c"
 #endif
 
 static struct i2c_board_info __initdata i2c1_info[] = {
diff --git a/arch/arm/mach-rk30/board-rk3066b-tps65910.c b/arch/arm/mach-rk30/board-rk3066b-tps65910.c
new file mode 100755
index 000000000000..14c94fa02ddd
--- /dev/null
+++ b/arch/arm/mach-rk30/board-rk3066b-tps65910.c
@@ -0,0 +1,591 @@
+#include <linux/regulator/machine.h>
+#include <linux/i2c/twl.h>
+#include <linux/mfd/tps65910.h>
+#include <mach/sram.h>
+#include <linux/platform_device.h>
+
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+
+#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
+#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
+
+#define CRU_CLKGATE5_CON_ADDR 0x00e4
+#define GRF_GPIO6L_DIR_ADDR 0x0030
+#define GRF_GPIO6L_DO_ADDR 0x0068
+#define GRF_GPIO6L_EN_ADDR 0x00a0
+#define GPIO6_PB3_DIR_OUT  0x08000800
+#define GPIO6_PB3_DO_LOW  0x08000000
+#define GPIO6_PB3_DO_HIGH  0x08000800
+#define GPIO6_PB3_EN_MASK  0x08000800
+#define GPIO6_PB3_UNEN_MASK  0x08000000
+#define GPIO6_PB1_DIR_OUT  0x02000200
+#define GPIO6_PB1_DO_LOW  0x02000000
+#define GPIO6_PB1_DO_HIGH  0x02000200
+#define GPIO6_PB1_EN_MASK  0x02000200
+#define GPIO6_PB1_UNEN_MASK  0x02000000
+
+#ifdef CONFIG_MFD_TPS65910
+	
+extern int platform_device_register(struct platform_device *pdev);
+
+int tps65910_pre_init(struct tps65910 *tps65910){
+
+	int val = 0;
+	int i 	= 0;
+	int err = -1;
+		
+	printk("%s,line=%d\n", __func__,__LINE__);	
+	//gpio_request(PMU_POWER_SLEEP, "NULL");
+	//gpio_direction_output(PMU_POWER_SLEEP, GPIO_HIGH);
+
+	/*************set vdd11 (pll) voltage 1.0v********************/
+	val = tps65910_reg_read(tps65910, TPS65910_VDIG2);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VDIG2 reg\n");
+		return val;
+	}
+	val &= (~(0x3<<2));
+	err = tps65910_reg_write(tps65910, TPS65910_VDIG2, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VDIG2 reg\n");
+		return err;
+	}
+	/****************************************/
+	
+	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL2);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_DEVCTRL2 reg\n");
+		return val;
+	}
+	/* Set sleep state active high and allow device turn-off after PWRON long press */
+	val |= (DEVCTRL2_SLEEPSIG_POL_MASK | DEVCTRL2_PWON_LP_OFF_MASK);
+
+	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL2, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_DEVCTRL2 reg\n");
+		return err;
+	}
+	
+	 #if 1
+	/* set PSKIP=0 */
+        val = tps65910_reg_read(tps65910, TPS65910_DCDCCTRL);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+
+	val &= ~DEVCTRL_DEV_OFF_MASK;
+	val &= ~DEVCTRL_DEV_SLP_MASK;
+        err = tps65910_reg_write(tps65910, TPS65910_DCDCCTRL, val);
+        if (err) {
+                printk(KERN_ERR "Unable to write TPS65910_DCDCCTRL reg\n");
+                return err;
+        }
+	#endif
+	/* Set the maxinum load current */
+	/* VDD1 */
+	val = tps65910_reg_read(tps65910, TPS65910_VDD1);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VDD1 reg\n");
+		return val;
+	}
+
+	val |= (1<<5);		//when 1: 1.5 A
+	val |= (0x07<<2);	//TSTEP[2:0] = 111 : 2.5 mV/¦Ìs(sampling 3 Mhz/5)
+	err = tps65910_reg_write(tps65910, TPS65910_VDD1, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VDD1 reg\n");
+		return err;
+	}
+
+	/* VDD2 */
+	val = tps65910_reg_read(tps65910, TPS65910_VDD2);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VDD2 reg\n");
+		return val;
+	}
+
+	val |= (1<<5);		//when 1: 1.5 A
+	err = tps65910_reg_write(tps65910, TPS65910_VDD2, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VDD2 reg\n");
+		return err;
+	}
+
+	/* VIO */
+	val = tps65910_reg_read(tps65910, TPS65910_VIO);
+	if (val<0) {
+		printk(KERN_ERR "Unable to read TPS65910_VIO reg\n");
+		return -EIO;
+	}
+
+	val |= (1<<6);	//when 01: 1.0 A
+	err = tps65910_reg_write(tps65910, TPS65910_VIO, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_VIO reg\n");
+		return err;
+	}
+	#if 1
+	/* Mask ALL interrupts */
+	err = tps65910_reg_write(tps65910,TPS65910_INT_MSK, 0xFF);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_INT_MSK reg\n");
+		return err;
+	}
+	
+	err = tps65910_reg_write(tps65910, TPS65910_INT_MSK2, 0x03);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_INT_MSK2 reg\n");
+		return err;
+	}
+
+	/* Set RTC Power, disable Smart Reflex in DEVCTRL_REG */
+	#if 1
+	val = 0;
+	val |= (DEVCTRL_SR_CTL_I2C_SEL_MASK);
+	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
+	if (err) {
+		printk(KERN_ERR "Unable to write TPS65910_DEVCTRL reg\n");
+		return err;
+	}
+	printk(KERN_INFO "TPS65910 Set default voltage.\n");
+	#endif
+	#if 0
+	//read sleep control register  for debug
+	for(i=0; i<6; i++)
+	{
+        err = tps65910_reg_read(tps65910, &val, TPS65910_DEVCTRL+i);
+        if (err) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return -EIO;
+        }
+		else
+		printk("%s.......is  0x%04x\n",__FUNCTION__,val);
+	}
+	#endif
+
+	#if 1
+	//sleep control register
+	/*set func when in sleep mode */
+	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val |= (1 << 1);
+	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+	
+	/* open ldo when in sleep mode */
+        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_KEEP_LDO_ON);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val &= 0;
+	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_KEEP_LDO_ON, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+		
+	/*set dc mode when in sleep mode */
+        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_KEEP_RES_ON);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val  |= 0xff;
+	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_KEEP_RES_ON, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+	
+	/*close ldo when in sleep mode */
+        val = tps65910_reg_read(tps65910, TPS65910_SLEEP_SET_LDO_OFF);
+        if (val<0) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return val;
+        }
+	
+	val |= 0x0b;
+	err = tps65910_reg_write(tps65910, TPS65910_SLEEP_SET_LDO_OFF, val);
+	if (err) {
+		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
+				\n", TPS65910_VDIG1);
+		return err;
+	}
+	#endif
+	#if 0
+	//read sleep control register  for debug
+	for(i=0; i<6; i++)
+	{
+        err = tps65910_reg_read(tps65910, &val, TPS65910_DEVCTRL+i);
+        if (err) {
+                printk(KERN_ERR "Unable to read TPS65910_DCDCCTRL reg\n");
+                return -EIO;
+        }
+		else
+		printk("%s.......is  0x%4x\n",__FUNCTION__,val);
+	}
+	#endif
+	#endif
+	printk("%s,line=%d\n", __func__,__LINE__);
+	return 0;
+
+}
+int tps65910_post_init(struct tps65910 *tps65910)
+{
+	struct regulator *dcdc;
+	struct regulator *ldo;
+	int i=0;
+	printk("%s,line=%d\n", __func__,__LINE__);
+
+	g_pmic_type = PMIC_TYPE_TPS65910;
+	printk("%s:g_pmic_type=%d\n",__func__,g_pmic_type);
+
+	#ifdef CONFIG_RK30_PWM_REGULATOR
+	platform_device_register(&pwm_regulator_device[0]);
+	#endif
+
+	for(i = 0; i < ARRAY_SIZE(tps65910_dcdc_info); i++)
+	{
+	dcdc =regulator_get(NULL, tps65910_dcdc_info[i].name);
+	regulator_set_voltage(dcdc, tps65910_dcdc_info[i].min_uv, tps65910_dcdc_info[i].max_uv);
+	regulator_enable(dcdc);
+	printk("%s  %s =%dmV end\n", __func__,tps65910_dcdc_info[i].name, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+	}
+	
+	for(i = 0; i < ARRAY_SIZE(tps65910_ldo_info); i++)
+	{
+	ldo =regulator_get(NULL, tps65910_ldo_info[i].name);
+	regulator_set_voltage(ldo, tps65910_ldo_info[i].min_uv, tps65910_ldo_info[i].max_uv);
+	regulator_enable(ldo);
+	//printk("%s  %s =%dmV end\n", __func__,tps65910_dcdc_info[i].name, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	}
+
+	printk("%s,line=%d END\n", __func__,__LINE__);
+	
+	return 0;
+}
+
+static struct regulator_consumer_supply tps65910_smps1_supply[] = {
+	{
+		.supply = "vdd1",
+	},
+	{
+		.supply = "vdd_cpu",
+	},
+};
+static struct regulator_consumer_supply tps65910_smps2_supply[] = {
+	{
+		.supply = "vdd2",
+	},
+	
+};
+static struct regulator_consumer_supply tps65910_smps3_supply[] = {
+	{
+		.supply = "vdd3",
+	},
+};
+static struct regulator_consumer_supply tps65910_smps4_supply[] = {
+	{
+		.supply = "vio",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo1_supply[] = {
+	{
+		.supply = "vdig1",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo2_supply[] = {
+	{
+		.supply = "vdig2",
+	},
+};
+
+static struct regulator_consumer_supply tps65910_ldo3_supply[] = {
+	{
+		.supply = "vaux1",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo4_supply[] = {
+	{
+		.supply = "vaux2",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo5_supply[] = {
+	{
+		.supply = "vaux33",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo6_supply[] = {
+	{
+		.supply = "vmmc",
+	},
+};
+static struct regulator_consumer_supply tps65910_ldo7_supply[] = {
+	{
+		.supply = "vdac",
+	},
+};
+
+static struct regulator_consumer_supply tps65910_ldo8_supply[] = {
+	{
+		.supply = "vpll",
+	},
+};
+
+static struct regulator_init_data tps65910_smps1 = {
+	.constraints = {
+		.name           = "VDD1",
+		.min_uV			= 600000,
+		.max_uV			= 1500000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps1_supply),
+	.consumer_supplies =  tps65910_smps1_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_smps2 = {
+	.constraints = {
+		.name           = "VDD2",
+		.min_uV			= 600000,
+		.max_uV			= 1500000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps2_supply),
+	.consumer_supplies =  tps65910_smps2_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_smps3 = {
+	.constraints = {
+		.name           = "VDD3",
+		.min_uV			= 1000000,
+		.max_uV			= 1400000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps3_supply),
+	.consumer_supplies =  tps65910_smps3_supply,
+};
+
+static struct regulator_init_data tps65910_smps4 = {
+	.constraints = {
+		.name           = "VIO",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_smps4_supply),
+	.consumer_supplies =  tps65910_smps4_supply,
+};
+static struct regulator_init_data tps65910_ldo1 = {
+	.constraints = {
+		.name           = "VDIG1",
+		.min_uV			= 1200000,
+		.max_uV			= 2700000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo1_supply),
+	.consumer_supplies =  tps65910_ldo1_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo2 = {
+	.constraints = {
+		.name           = "VDIG2",
+		.min_uV			= 1000000,
+		.max_uV			= 1800000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo2_supply),
+	.consumer_supplies =  tps65910_ldo2_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo3 = {
+	.constraints = {
+		.name           = "VAUX1",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo3_supply),
+	.consumer_supplies =  tps65910_ldo3_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo4 = {
+	.constraints = {
+		.name           = "VAUX2",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo4_supply),
+	.consumer_supplies =  tps65910_ldo4_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo5 = {
+	.constraints = {
+		.name           = "VAUX33",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo5_supply),
+	.consumer_supplies =  tps65910_ldo5_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo6 = {
+	.constraints = {
+		.name           = "VMMC",
+		.min_uV			= 1800000,
+		.max_uV			= 3300000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo6_supply),
+	.consumer_supplies =  tps65910_ldo6_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo7 = {
+	.constraints = {
+		.name           = "VDAC",
+		.min_uV			= 1800000,
+		.max_uV			= 2850000,
+		.apply_uV		= 1,
+		
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo7_supply),
+	.consumer_supplies =  tps65910_ldo7_supply,
+};
+
+/* */
+static struct regulator_init_data tps65910_ldo8 = {
+	.constraints = {
+		.name           = "VPLL",
+		.min_uV			= 1000000,
+		.max_uV			= 2500000,
+		.apply_uV		= 1,
+		.always_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL,
+
+	},
+	.num_consumer_supplies = ARRAY_SIZE(tps65910_ldo8_supply),
+	.consumer_supplies =  tps65910_ldo8_supply,
+};
+
+void __sramfunc board_pmu_tps65910_suspend(void)
+{	
+#if 0 
+	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
+	grf_writel(GPIO6_PB1_DO_HIGH, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
+	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
+#endif
+}
+void __sramfunc board_pmu_tps65910_resume(void)
+{
+#if 0
+	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
+	grf_writel(GPIO6_PB1_DO_LOW, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
+	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
+	#ifdef CONFIG_CLK_SWITCH_TO_32K                 //switch clk to 24M
+	sram_32k_udelay(10000);
+	#else
+	sram_udelay(2000);
+	#endif
+#endif
+}
+
+static struct tps65910_board tps65910_data = {
+	.irq 	= (unsigned)TPS65910_HOST_IRQ,		
+	.irq_base = NR_GIC_IRQS + NR_GPIO_IRQS,
+	.gpio_base = TPS65910_GPIO_EXPANDER_BASE,
+	
+	.pre_init = tps65910_pre_init,
+	.post_init = tps65910_post_init,
+
+	//TPS65910_NUM_REGS = 13
+	// Regulators
+	.tps65910_pmic_init_data[TPS65910_REG_VRTC] = NULL,		
+	.tps65910_pmic_init_data[TPS65910_REG_VIO] = &tps65910_smps4,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD1] = &tps65910_smps1,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD2] = &tps65910_smps2,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD3] = &tps65910_smps3,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG1] = &tps65910_ldo1,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG2] = &tps65910_ldo2,
+	.tps65910_pmic_init_data[TPS65910_REG_VPLL] = &tps65910_ldo8,
+	.tps65910_pmic_init_data[TPS65910_REG_VDAC] = &tps65910_ldo7,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX1] = &tps65910_ldo3,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX2] = &tps65910_ldo4,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX33] = &tps65910_ldo5,
+	.tps65910_pmic_init_data[TPS65910_REG_VMMC] = &tps65910_ldo6,
+
+ 
+};
+
+#endif
+
diff --git a/arch/arm/mach-rk30/board-rk3066b-wm8326.c b/arch/arm/mach-rk30/board-rk3066b-wm8326.c
new file mode 100755
index 000000000000..f606f6b0f8bf
--- /dev/null
+++ b/arch/arm/mach-rk30/board-rk3066b-wm8326.c
@@ -0,0 +1,844 @@
+#include <linux/regulator/machine.h>
+#include <linux/mfd/wm831x/pdata.h>
+#include <linux/mfd/wm831x/core.h>
+#include <linux/mfd/wm831x/gpio.h>
+#include <linux/mfd/wm831x/pmu.h>
+
+#include <mach/sram.h>
+#include <linux/earlysuspend.h>
+
+#define cru_readl(offset)	readl_relaxed(RK30_CRU_BASE + offset)
+#define cru_writel(v, offset)	do { writel_relaxed(v, RK30_CRU_BASE + offset); dsb(); } while (0)
+
+#define grf_readl(offset)	readl_relaxed(RK30_GRF_BASE + offset)
+#define grf_writel(v, offset)	do { writel_relaxed(v, RK30_GRF_BASE + offset); dsb(); } while (0)
+
+#define CRU_CLKGATE5_CON_ADDR 0x00e4
+#define GRF_GPIO6L_DIR_ADDR 0x0030
+#define GRF_GPIO6L_DO_ADDR 0x0068
+#define GRF_GPIO6L_EN_ADDR 0x00a0
+#define CRU_CLKGATE5_GRFCLK_ON 0x00100000
+#define CRU_CLKGATE5_GRFCLK_OFF 0x00100010
+#define GPIO6_PB1_DIR_OUT  0x02000200
+#define GPIO6_PB1_DO_LOW  0x02000000
+#define GPIO6_PB1_DO_HIGH  0x02000200
+#define GPIO6_PB1_EN_MASK  0x02000200
+#define GPIO6_PB1_UNEN_MASK  0x02000000
+
+/* wm8326 pmu*/
+#if defined(CONFIG_GPIO_WM831X)
+static struct rk29_gpio_expander_info wm831x_gpio_settinginfo[] = {
+	{
+		.gpio_num = WM831X_P01,	// tp3
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_LOW,
+	},
+	{
+		.gpio_num = WM831X_P02,	//tp4
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P03,	//tp2
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P04,	//tp1
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P05,	//tp1
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P06,	//tp1
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P07,	//tp1
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P08,	//tp1
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P09,	//tp1
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P10,	//tp1
+		.pin_type = GPIO_IN,
+	},
+	{
+		.gpio_num = WM831X_P11,	//tp1
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+	{
+		.gpio_num = WM831X_P12,
+		.pin_type = GPIO_OUT,
+		.pin_value = GPIO_HIGH,
+	},
+};
+#endif
+
+#if defined(CONFIG_MFD_WM831X)
+
+#define UNLOCK_SECURITY_KEY     ~(0x1<<5)
+#define LOCK_SECURITY_KEY       0x00
+
+static struct wm831x *Wm831x;
+
+static int wm831x_pre_init(struct wm831x *parm)
+{
+	int ret;
+	Wm831x = parm;
+//	printk("%s\n", __func__);
+	gpio_request(PMU_POWER_SLEEP, "NULL");
+	gpio_direction_output(PMU_POWER_SLEEP, GPIO_LOW);
+
+	#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION
+	#ifdef CONFIG_BATTERY_RK30_VOL3V8
+	wm831x_set_bits(parm,WM831X_SYSVDD_CONTROL ,0xc077,0xc035);	  //pvdd power on dect vbat voltage
+	printk("+++The vbat is too low+++\n");	
+	#endif
+	#endif
+	
+	ret = wm831x_reg_read(parm, WM831X_POWER_STATE) & 0xffff;
+	wm831x_reg_write(parm, WM831X_POWER_STATE, (ret & 0xfff8) | 0x04);
+
+	wm831x_set_bits(parm, WM831X_RTC_CONTROL, WM831X_RTC_ALAM_ENA_MASK, 0x0400);//enable rtc alam
+	//BATT_FET_ENA = 1
+	wm831x_reg_write(parm, WM831X_SECURITY_KEY, 0x9716);	// unlock security key
+	wm831x_set_bits(parm, WM831X_RESET_CONTROL, 0x1003, 0x1001);
+	ret = wm831x_reg_read(parm, WM831X_RESET_CONTROL) & 0xffff & UNLOCK_SECURITY_KEY;	// enternal reset active in sleep
+//	printk("%s:WM831X_RESET_CONTROL=0x%x\n", __func__, ret);
+	wm831x_reg_write(parm, WM831X_RESET_CONTROL, ret);
+
+	wm831x_set_bits(parm,WM831X_DC1_ON_CONFIG ,0x0300,0x0000); //set dcdc mode is FCCM
+	wm831x_set_bits(parm,WM831X_DC2_ON_CONFIG ,0x0300,0x0000);
+	wm831x_set_bits(parm,WM831X_DC3_ON_CONFIG ,0x0300,0x0000);
+	wm831x_set_bits(parm,0x4066,0x0300,0x0000);
+
+#ifndef CONFIG_MACH_RK3066_SDK
+	wm831x_set_bits(parm,WM831X_LDO10_CONTROL ,0x0040,0x0040);// set ldo10 in switch mode
+#endif
+	wm831x_set_bits(parm,WM831X_STATUS_LED_1 ,0xc300,0xc100);// set led1 on(in manual mode)
+	wm831x_set_bits(parm,WM831X_STATUS_LED_2 ,0xc300,0xc000);//set led2 off(in manual mode)
+
+	wm831x_set_bits(parm,WM831X_LDO5_SLEEP_CONTROL ,0xe000,0x2000);// set ldo5 is disable in sleep mode 
+	wm831x_set_bits(parm,WM831X_LDO1_SLEEP_CONTROL ,0xe000,0x2000);// set ldo1 is disable in sleep mode 
+	
+	wm831x_reg_write(parm, WM831X_SECURITY_KEY, LOCK_SECURITY_KEY);	// lock security key
+
+	return 0;
+}
+static int wm831x_mask_interrupt(struct wm831x *Wm831x)
+{
+	/**************************clear interrupt********************/
+	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_1,0xffff);
+	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_2,0xffff);
+	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_3,0xffff);
+	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_4,0xffff);
+	wm831x_reg_write(Wm831x,WM831X_INTERRUPT_STATUS_5,0xffff);
+	
+	wm831x_reg_write(Wm831x,WM831X_SYSTEM_INTERRUPTS_MASK,0xbedc); //mask interrupt which not used
+	return 0;
+	/*****************************************************************/
+}
+
+#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION
+static int wm831x_low_power_detection(struct wm831x *wm831x)
+{
+	#ifdef CONFIG_BATTERY_RK30_VOL3V8
+	wm831x_reg_write(wm831x,WM831X_SYSTEM_INTERRUPTS_MASK,0xbe5c); 	
+	wm831x_set_bits(wm831x,WM831X_INTERRUPT_STATUS_1_MASK,0x8000,0x0000);	
+	wm831x_set_bits(wm831x,WM831X_SYSVDD_CONTROL ,0xc077,0x0035);		//set pvdd low voltage is 3.1v hi voltage is 3.3v 
+	#else
+	wm831x_reg_write(wm831x,WM831X_AUXADC_CONTROL,0x803f);     //open adc 
+	wm831x_reg_write(wm831x,WM831X_AUXADC_CONTROL,0xd03f);
+	wm831x_reg_write(wm831x,WM831X_AUXADC_SOURCE,0x0001);
+	
+	wm831x_reg_write(wm831x,WM831X_COMPARATOR_CONTROL,0x0001);
+	wm831x_reg_write(wm831x,WM831X_COMPARATOR_1,0x2844);   //set the low power is 3.1v
+	
+	wm831x_reg_write(wm831x,WM831X_INTERRUPT_STATUS_1_MASK,0x99ee);
+	wm831x_set_bits(wm831x,WM831X_SYSTEM_INTERRUPTS_MASK,0x0100,0x0000);
+	if (wm831x_reg_read(wm831x,WM831X_AUXADC_DATA)< 0x1844){
+		printk("The vbat is too low.\n");
+		wm831x_device_shutdown(wm831x);
+	}
+	#endif
+	return 0;	
+}
+#endif
+
+#define AVS_BASE 172
+int wm831x_post_init(struct wm831x *Wm831x)
+{
+	struct regulator *dcdc;
+	struct regulator *ldo;
+	int i = 0;
+	
+	g_pmic_type = PMIC_TYPE_WM8326;
+	printk("%s:g_pmic_type=%d\n",__func__,g_pmic_type);
+
+	for(i = 0; i < ARRAY_SIZE(wm8326_dcdc_info); i++)
+	{
+	dcdc =regulator_get(NULL, wm8326_dcdc_info[i].name);
+	regulator_set_voltage(dcdc, wm8326_dcdc_info[i].min_uv, wm8326_dcdc_info[i].max_uv);
+	regulator_set_suspend_voltage(dcdc, wm8326_dcdc_info[1].suspend_vol);
+	regulator_enable(dcdc);
+	printk("%s  %s =%dmV end\n", __func__,wm8326_dcdc_info[i].name, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+	}
+	
+	for(i = 0; i < ARRAY_SIZE(wm8326_ldo_info); i++)
+	{
+	ldo =regulator_get(NULL, wm8326_ldo_info[i].name);
+	regulator_set_voltage(ldo, wm8326_ldo_info[i].min_uv, wm8326_ldo_info[i].max_uv);
+	regulator_set_suspend_voltage(ldo, wm8326_ldo_info[i].suspend_vol);
+	regulator_enable(ldo);
+	//printk("%s  %s =%dmV end\n", __func__,tps65910_dcdc_info[i].name, regulator_get_voltage(ldo));
+	regulator_put(ldo);
+	}
+	
+	wm831x_mask_interrupt(Wm831x);
+
+	#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION
+	wm831x_low_power_detection(Wm831x);
+	#endif
+	
+	printk("wm831x_post_init end");
+	return 0;
+}
+
+static int wm831x_last_deinit(struct wm831x *Wm831x)
+{
+	struct regulator *ldo;
+
+	printk("%s\n", __func__);
+	ldo = regulator_get(NULL, "ldo1");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo2");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo3");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo4");
+	//regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo5");
+//	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo6");
+//	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo7");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo8");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo9");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	ldo = regulator_get(NULL, "ldo10");
+	regulator_disable(ldo);
+	regulator_put(ldo);
+
+	return 0;
+}
+
+struct wm831x_status_pdata wm831x_status_platdata[WM831X_MAX_STATUS] = {
+	{
+		.default_src = WM831X_STATUS_OTP,
+		.name = "wm831x_status0",
+		.default_trigger = "wm831x_otp",
+	},
+	{
+		.default_src = WM831X_STATUS_POWER,
+		.name = "wm831x_status1",
+		.default_trigger = "wm831x_power",
+	},
+};
+
+static struct regulator_consumer_supply dcdc1_consumers[] = {
+	{
+		.supply = "vdd_core",
+	}
+};
+
+static struct regulator_consumer_supply dcdc2_consumers[] = {
+	{
+		.supply = "vdd_cpu",
+	}
+	
+};
+
+static struct regulator_consumer_supply dcdc3_consumers[] = {
+	{
+		.supply = "dcdc3",
+	}
+};
+
+static struct regulator_consumer_supply dcdc4_consumers[] = {
+	{
+		.supply = "dcdc4",
+	}
+};
+
+#if 0
+static struct regulator_consumer_supply epe1_consumers[] = {
+	{
+		.supply = "epe1",
+	}
+};
+
+static struct regulator_consumer_supply epe2_consumers[] = {
+	{
+		.supply = "epe2",
+	}
+};
+#endif
+
+static struct regulator_consumer_supply ldo1_consumers[] = {
+	{
+		.supply = "ldo1",
+	}
+};
+
+static struct regulator_consumer_supply ldo2_consumers[] = {
+	{
+		.supply = "ldo2",
+	}
+};
+
+static struct regulator_consumer_supply ldo3_consumers[] = {
+	{
+		.supply = "ldo3",
+	}
+};
+
+static struct regulator_consumer_supply ldo4_consumers[] = {
+	{
+		.supply = "ldo4",
+	}
+};
+
+static struct regulator_consumer_supply ldo5_consumers[] = {
+	{
+		.supply = "ldo5",
+	}
+};
+
+static struct regulator_consumer_supply ldo6_consumers[] = {
+	{
+		.supply = "ldo6",
+	}
+};
+
+static struct regulator_consumer_supply ldo7_consumers[] = {
+	{
+		.supply = "ldo7",
+	}
+};
+
+static struct regulator_consumer_supply ldo8_consumers[] = {
+	{
+		.supply = "ldo8",
+	}
+};
+
+static struct regulator_consumer_supply ldo9_consumers[] = {
+	{
+		.supply = "ldo9",
+	}
+};
+
+static struct regulator_consumer_supply ldo10_consumers[] = {
+	{
+		.supply = "ldo10",
+	}
+};
+
+static struct regulator_consumer_supply ldo11_consumers[] = {
+	{
+		.supply = "ldo11",
+	}
+};
+
+struct regulator_init_data wm831x_regulator_init_dcdc[WM831X_MAX_DCDC] = {
+	{
+		.constraints = {
+			.name = "DCDC1",
+			.min_uV = 600000,
+			.max_uV = 1800000,	//0.6-1.8V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(dcdc1_consumers),
+		.consumer_supplies = dcdc1_consumers,
+	},
+	{
+		.constraints = {
+			.name = "DCDC2",
+			.min_uV = 600000,
+			.max_uV = 1800000,	//0.6-1.8V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(dcdc2_consumers),
+		.consumer_supplies = dcdc2_consumers,
+	},
+	{
+		.constraints = {
+			.name = "DCDC3",
+			.min_uV = 850000,
+			.max_uV = 3400000,	//0.85-3.4V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(dcdc3_consumers),
+		.consumer_supplies = dcdc3_consumers,
+	},
+	{
+		.constraints = {
+			.name = "DCDC4",
+			.min_uV = 850000,
+			.max_uV = 3400000,	//0.85-3.4V
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_STANDBY | REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST | REGULATOR_MODE_IDLE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(dcdc4_consumers),
+		.consumer_supplies = dcdc4_consumers,
+	},
+};
+
+#if 0
+struct regulator_init_data wm831x_regulator_init_epe[WM831X_MAX_EPE] = {
+	{
+		.constraints = {
+			.name = "EPE1",
+			.min_uV = 1200000,
+			.max_uV = 3000000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(epe1_consumers),
+		.consumer_supplies = epe1_consumers,
+	},
+	{
+		.constraints = {
+			.name = "EPE2",
+			.min_uV = 1200000,
+			.max_uV = 3000000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(epe2_consumers),
+		.consumer_supplies = epe2_consumers,
+	},
+};
+#endif
+
+struct regulator_init_data wm831x_regulator_init_ldo[WM831X_MAX_LDO] = {
+	{
+		.constraints = {
+			.name = "LDO1",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo1_consumers),
+		.consumer_supplies = ldo1_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO2",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo2_consumers),
+		.consumer_supplies = ldo2_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO3",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo3_consumers),
+		.consumer_supplies = ldo3_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO4",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo4_consumers),
+		.consumer_supplies = ldo4_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO5",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo5_consumers),
+		.consumer_supplies = ldo5_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO6",
+			.min_uV = 900000,
+			.max_uV = 3300000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo6_consumers),
+		.consumer_supplies = ldo6_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO7",
+			.min_uV = 1000000,
+			.max_uV = 3500000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo7_consumers),
+		.consumer_supplies = ldo7_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO8",
+			.min_uV = 1000000,
+			.max_uV = 3500000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo8_consumers),
+		.consumer_supplies = ldo8_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO9",
+			.min_uV = 1000000,
+			.max_uV = 3500000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo9_consumers),
+		.consumer_supplies = ldo9_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO10",
+			.min_uV = 1000000,
+			.max_uV = 3500000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo10_consumers),
+		.consumer_supplies = ldo10_consumers,
+	},
+	{
+		.constraints = {
+			.name = "LDO11",
+			.min_uV = 800000,
+			.max_uV = 1550000,
+			.apply_uV = true,
+			.valid_ops_mask = REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+			.valid_modes_mask = REGULATOR_MODE_IDLE | REGULATOR_MODE_NORMAL,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(ldo11_consumers),
+		.consumer_supplies = ldo11_consumers,
+	},
+};
+
+static int wm831x_init_pin_type(struct wm831x *wm831x)
+{
+	struct wm831x_pdata *pdata;
+	struct rk29_gpio_expander_info *wm831x_gpio_settinginfo;
+	uint16_t wm831x_settingpin_num;
+	int i;
+
+	if (!wm831x || !wm831x->dev)
+		goto out;
+
+	pdata = wm831x->dev->platform_data;
+	if (!pdata)
+		goto out;
+
+	wm831x_gpio_settinginfo = pdata->settinginfo;
+	if (!wm831x_gpio_settinginfo)
+		goto out;
+
+	wm831x_settingpin_num = pdata->settinginfolen;
+	for (i = 0; i < wm831x_settingpin_num; i++) {
+		if (wm831x_gpio_settinginfo[i].pin_type == GPIO_IN) {
+			wm831x_set_bits(wm831x,
+					WM831X_GPIO1_CONTROL + i,
+					WM831X_GPN_DIR_MASK | WM831X_GPN_TRI_MASK,
+					1 << WM831X_GPN_DIR_SHIFT | 1 << WM831X_GPN_TRI_SHIFT);
+		if (i == 1) {
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_POL_MASK,
+						0x0400);
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_FN_MASK,
+						0x0003);				
+			}	// set gpio2 sleep/wakeup
+			
+		if (i == 9) {
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_PULL_MASK,
+						0x0000);      //disable pullup/down
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_PWR_DOM_MASK,
+						0x0800); 
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_ENA_MASK,
+						0x0000); 
+			}  //set gpio10 as adc input
+					
+		} else {
+			wm831x_set_bits(wm831x,
+					WM831X_GPIO1_CONTROL + i,
+					WM831X_GPN_DIR_MASK | WM831X_GPN_TRI_MASK,
+					1 << WM831X_GPN_TRI_SHIFT);
+			if (wm831x_gpio_settinginfo[i].pin_value == GPIO_HIGH) {
+				wm831x_set_bits(wm831x, WM831X_GPIO_LEVEL, 1 << i, 1 << i);
+			} else {
+				wm831x_set_bits(wm831x, WM831X_GPIO_LEVEL, 1 << i, 0 << i);
+			}
+			if (i == 2) {
+				wm831x_set_bits(wm831x,
+						WM831X_GPIO1_CONTROL + i,
+						WM831X_GPN_PWR_DOM_MASK | WM831X_GPN_POL_MASK |WM831X_GPN_FN_MASK,
+						1 << WM831X_GPN_POL_SHIFT | 1 << WM831X_GPN_PWR_DOM_SHIFT | 1 << 0);
+
+			}	// set gpio3 as clkout output 32.768K
+			
+		}
+	}
+
+#if 0
+	for (i = 0; i < pdata->gpio_pin_num; i++) {
+		wm831x_set_bits(wm831x,
+				WM831X_GPIO1_CONTROL + i,
+				WM831X_GPN_PULL_MASK | WM831X_GPN_POL_MASK | WM831X_GPN_OD_MASK | WM831X_GPN_TRI_MASK,
+				1 << WM831X_GPN_POL_SHIFT | 1 << WM831X_GPN_TRI_SHIFT);
+
+		ret = wm831x_reg_read(wm831x, WM831X_GPIO1_CONTROL + i);
+		printk("Gpio%d Pin Configuration = %x\n", i, ret);
+	}
+#endif
+
+out:
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void wm831x_pmu_early_suspend(struct regulator_dev *rdev)
+{
+	struct regulator *dcdc;
+	struct regulator *ldo;
+	printk("%s\n", __func__);
+	
+	dcdc = regulator_get(NULL, "dcdc4");	//vcc_io
+	regulator_set_voltage(dcdc, 2800000, 2800000);
+	regulator_set_mode(dcdc, REGULATOR_MODE_STANDBY);
+	regulator_enable(dcdc);
+	printk("%s set dcdc4 vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo1");	//
+	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+	
+	ldo = regulator_get(NULL, "ldo4");
+	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+	
+	ldo = regulator_get(NULL, "ldo6");
+	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo8");
+	regulator_set_mode(ldo, REGULATOR_MODE_IDLE);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);	
+		
+}
+void wm831x_pmu_early_resume(struct regulator_dev *rdev)
+{
+	struct regulator *dcdc;
+	struct regulator *ldo;
+	printk("%s\n", __func__);
+	
+	dcdc = regulator_get(NULL, "dcdc4");	//vcc_io
+	regulator_set_voltage(dcdc, 3000000, 3000000);
+	regulator_set_mode(dcdc, REGULATOR_MODE_FAST);
+	regulator_enable(dcdc);
+	printk("%s set dcdc4 vcc_io=%dmV end\n", __func__, regulator_get_voltage(dcdc));
+	regulator_put(dcdc);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo1");	//
+	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo4");
+	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo6");
+	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);
+
+	ldo = regulator_get(NULL, "ldo8");
+	regulator_set_mode(ldo, REGULATOR_MODE_NORMAL);
+	regulator_enable(ldo);
+	regulator_put(ldo);
+	udelay(100);	
+}
+#else
+void wm831x_pmu_early_suspend(struct regulator_dev *rdev)
+{
+}
+void wm831x_pmu_early_resume(struct regulator_dev *rdev)
+{
+}
+#endif
+
+void __sramfunc board_pmu_wm8326_suspend(void)
+{	
+#if 0
+	cru_writel(CRU_CLKGATE5_GRFCLK_ON,CRU_CLKGATE5_CON_ADDR); //open grf clk
+	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
+	grf_writel(GPIO6_PB1_DO_HIGH, GRF_GPIO6L_DO_ADDR);  //set gpio6_b1 output low
+	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
+#endif
+}
+void __sramfunc board_pmu_wm8326_resume(void)
+{
+#if 0
+	grf_writel(GPIO6_PB1_DIR_OUT, GRF_GPIO6L_DIR_ADDR);
+	grf_writel(GPIO6_PB1_DO_LOW, GRF_GPIO6L_DO_ADDR);     //set gpio6_b1 output high
+	grf_writel(GPIO6_PB1_EN_MASK, GRF_GPIO6L_EN_ADDR);
+#ifdef CONFIG_CLK_SWITCH_TO_32K
+	sram_32k_udelay(10000);
+#else
+	sram_udelay(10000);
+#endif
+#endif
+}
+static struct wm831x_pdata wm831x_platdata = {
+
+	/** Called before subdevices are set up */
+	.pre_init = wm831x_pre_init,
+	/** Called after subdevices are set up */
+	.post_init = wm831x_post_init,
+	/** Called before subdevices are power down */
+	.last_deinit = wm831x_last_deinit,
+
+#if defined(CONFIG_GPIO_WM831X)
+	.gpio_base = WM831X_GPIO_EXPANDER_BASE,
+	.gpio_pin_num = WM831X_TOTOL_GPIO_NUM,
+	.settinginfo = wm831x_gpio_settinginfo,
+	.settinginfolen = ARRAY_SIZE(wm831x_gpio_settinginfo),
+	.pin_type_init = wm831x_init_pin_type,
+	.irq_base = NR_GIC_IRQS + NR_GPIO_IRQS,
+#endif
+
+	/** LED1 = 0 and so on */
+	.status = { &wm831x_status_platdata[0], &wm831x_status_platdata[1] },
+
+	/** DCDC1 = 0 and so on */
+	.dcdc = {
+		&wm831x_regulator_init_dcdc[0],
+		&wm831x_regulator_init_dcdc[1],
+		&wm831x_regulator_init_dcdc[2],
+		&wm831x_regulator_init_dcdc[3],
+	},
+
+	/** EPE1 = 0 and so on */
+	//.epe = { &wm831x_regulator_init_epe[0], &wm831x_regulator_init_epe[1] },
+
+	/** LDO1 = 0 and so on */
+	.ldo = {
+		&wm831x_regulator_init_ldo[0],
+		&wm831x_regulator_init_ldo[1],
+		&wm831x_regulator_init_ldo[2],
+		&wm831x_regulator_init_ldo[3],
+		&wm831x_regulator_init_ldo[4],
+		&wm831x_regulator_init_ldo[5],
+		&wm831x_regulator_init_ldo[6],
+		&wm831x_regulator_init_ldo[7],
+		&wm831x_regulator_init_ldo[8],
+		&wm831x_regulator_init_ldo[9],
+		&wm831x_regulator_init_ldo[10],
+	},
+};
+#endif
diff --git a/arch/arm/plat-rk/include/plat/board.h b/arch/arm/plat-rk/include/plat/board.h
index 7e6e65e4aff6..63053b939655 100755
--- a/arch/arm/plat-rk/include/plat/board.h
+++ b/arch/arm/plat-rk/include/plat/board.h
@@ -74,6 +74,13 @@ extern __sramdata  int g_pmic_type;
 #define pmic_is_tps65910()  (g_pmic_type == PMIC_TYPE_TPS65910)
 #define pmic_is_act8931()  (g_pmic_type == PMIC_TYPE_ACT8931)
 
+struct  pmu_info {
+	char		*name;
+	int		min_uv;
+	int		max_uv;   
+	int          suspend_vol;
+};
+
 struct rk29_fb_setting_info {
 	u8 data_num;
 	u8 vsync_en;
-- 
2.35.3

