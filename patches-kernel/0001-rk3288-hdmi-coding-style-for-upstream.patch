From ddc1df017794d6e4018b29834cec0128246446d9 Mon Sep 17 00:00:00 2001
From: zwl <zwl@rock-chips.com>
Date: Tue, 27 May 2014 11:48:09 +0800
Subject: [PATCH] rk3288 hdmi: coding style for upstream

---
 .../rockchip/hdmi/chips/rk3288/rk3288_hdmi.c  |  253 +--
 .../rockchip/hdmi/chips/rk3288/rk3288_hdmi.h  |    3 +-
 .../hdmi/chips/rk3288/rk3288_hdmi_hw.c        | 1382 ++++++++++-------
 .../hdmi/chips/rk3288/rk3288_hdmi_hw.h        |  381 +++--
 4 files changed, 1102 insertions(+), 917 deletions(-)

diff --git a/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi.c b/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi.c
index 1a54a9254efb..ced94b12f8ec 100644
--- a/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi.c
+++ b/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi.c
@@ -32,16 +32,18 @@
 #include "rk3288_hdmi_hw.h"
 #include "rk3288_hdmi.h"
 
-
 #define grf_readl(offset)	readl_relaxed(RK_GRF_VIRT + offset)
-#define grf_writel(v,offset) 	do{ writel_relaxed(v, RK_GRF_VIRT + offset);dsb();} while (0)
+#define grf_writel(v, offset)				\
+do {							\
+	writel_relaxed(v, RK_GRF_VIRT + offset);	\
+	dsb();						\
+} while (0)
 #define HDMI_PD_ON		(1 << 0)
 #define HDMI_PCLK_ON		(1 << 1)
 #define HDMI_HDCPCLK_ON		(1 << 2)
 
-extern irqreturn_t hdmi_irq(int irq, void *priv);
 
-static struct rk3288_hdmi_device *hdmi_dev = NULL;
+static struct rk3288_hdmi_device *hdmi_dev;
 
 #if defined(CONFIG_DEBUG_FS)
 static const struct rk3288_hdmi_reg_table hdmi_reg_table[] = {
@@ -55,7 +57,7 @@ static const struct rk3288_hdmi_reg_table hdmi_reg_table[] = {
 	{AUDIO_SAMPLER_BASE, AHB_DMA_STPADDR_SET1_0},
 	{MAIN_CONTROLLER_BASE, MC_SWRSTZREQ_2},
 	{COLOR_SPACE_CONVERTER_BASE, CSC_SPARE_2},
-	{HDCP_ENCRYPTION_ENGINE_BASE, HDCP_REVOC_LIST},	//HDCP_REVOC_LIST+5059
+	{HDCP_ENCRYPTION_ENGINE_BASE, HDCP_REVOC_LIST},
 	{HDCP_BKSV_BASE, HDCPREG_BKSV4},
 	{HDCP_AN_BASE, HDCPREG_AN7},
 	{ENCRYPTED_DPK_EMBEDDED_BASE, HDCPREG_DPK6},
@@ -65,43 +67,49 @@ static const struct rk3288_hdmi_reg_table hdmi_reg_table[] = {
 
 static int rk3288_hdmi_reg_show(struct seq_file *s, void *v)
 {
-	int i = 0,j = 0;
+	int i = 0, j = 0;
 	u32 val = 0;
-	seq_printf(s, "\n>>>hdmi_ctl reg");
-	for (i = 0; i < 16; i++) {
+
+	seq_puts(s, "\n>>>hdmi_ctl reg");
+	for (i = 0; i < 16; i++)
 		seq_printf(s, " %2x", i);
-	}
-	seq_printf(s, "\n-----------------------------------------------------------------");
 
-	for(i = 0; i < ARRAY_SIZE(hdmi_reg_table); i++) {
-		for(j = hdmi_reg_table[i].reg_base; j <= hdmi_reg_table[i].reg_end; j++) {
+	seq_puts(s,
+		   "\n-----------------------------------------------------------------");
+
+	for (i = 0; i < ARRAY_SIZE(hdmi_reg_table); i++) {
+		for (j = hdmi_reg_table[i].reg_base;
+		     j <= hdmi_reg_table[i].reg_end; j++) {
 			val = hdmi_readl(hdmi_dev, j);
-			if((j - hdmi_reg_table[i].reg_base)%16==0)
-				seq_printf(s,"\n>>>hdmi_ctl %2x:", j);
-			seq_printf(s," %02x",val);
+			if ((j - hdmi_reg_table[i].reg_base) % 16 == 0)
+				seq_printf(s, "\n>>>hdmi_ctl %2x:", j);
+			seq_printf(s, " %02x", val);
 
 		}
 	}
-	seq_printf(s, "\n-----------------------------------------------------------------\n");
+	seq_puts(s,
+		   "\n-----------------------------------------------------------------\n");
 
 	return 0;
 }
 
-static ssize_t rk3288_hdmi_reg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+static ssize_t rk3288_hdmi_reg_write(struct file *file, const char __user *buf,
+				     size_t count, loff_t *ppos)
 {
 	u32 reg;
 	u32 val;
 	char kbuf[25];
+
 	if (copy_from_user(kbuf, buf, count))
 		return -EFAULT;
 	sscanf(kbuf, "%x%x", &reg, &val);
-        if ((reg < 0) || (reg > I2CM_SCDC_UPDATE1)) {
-                dev_info(hdmi_dev->dev, "it is no hdmi reg\n");
-                return count;
-        }
+	if ((reg < 0) || (reg > I2CM_SCDC_UPDATE1)) {
+		dev_info(hdmi_dev->dev, "it is no hdmi reg\n");
+		return count;
+	}
 	dev_info(hdmi_dev->dev, "/**********rk3288 hdmi reg config******/");
 	dev_info(hdmi_dev->dev, "\n reg=%x val=%x\n", reg, val);
-        hdmi_writel(hdmi_dev, reg, val);
+	hdmi_writel(hdmi_dev, reg, val);
 
 	return count;
 }
@@ -109,29 +117,28 @@ static ssize_t rk3288_hdmi_reg_write(struct file *file, const char __user *buf,
 static int rk3288_hdmi_reg_open(struct inode *inode, struct file *file)
 {
 	struct rk3288_hdmi_device *hdmi_dev = inode->i_private;
-	return single_open(file,rk3288_hdmi_reg_show,hdmi_dev);
+
+	return single_open(file, rk3288_hdmi_reg_show, hdmi_dev);
 }
 
 static const struct file_operations rk3288_hdmi_reg_fops = {
-	.owner		= THIS_MODULE,
-	.open		= rk3288_hdmi_reg_open,
-	.read		= seq_read,
-	.write          = rk3288_hdmi_reg_write,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.owner = THIS_MODULE,
+	.open = rk3288_hdmi_reg_open,
+	.read = seq_read,
+	.write = rk3288_hdmi_reg_write,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 #endif
 
-
-struct hdmi* rk3288_hdmi_register_hdcp_callbacks(
-					 void (*hdcp_cb)(void),
-					 void (*hdcp_irq_cb)(int status),
-					 int (*hdcp_power_on_cb)(void),
-					 void (*hdcp_power_off_cb)(void))
+struct hdmi *rk3288_hdmi_register_hdcp_callbacks(void (*hdcp_cb) (void),
+					void (*hdcp_irq_cb) (int status),
+					int (*hdcp_power_on_cb) (void),
+					void (*hdcp_power_off_cb) (void))
 {
 	struct hdmi *hdmi_drv = NULL;
 
-	if(hdmi_dev == NULL)
+	if (hdmi_dev == NULL)
 		return NULL;
 
 	hdmi_drv = &hdmi_dev->driver;
@@ -149,13 +156,14 @@ static void rk3288_poll_delay_work(struct work_struct *work)
 {
 	struct hdmi *hdmi_drv = &hdmi_dev->driver;
 
-	if(hdmi_drv->suspend == 0) {
-		if(hdmi_drv->enable == 1) {
+	if (hdmi_drv->suspend == 0) {
+		if (hdmi_drv->enable == 1)
 			hdmi_irq(0, hdmi_drv);
-		}
-		if(hdmi_dev->irq == 0) {
-			queue_delayed_work(hdmi_drv->workqueue, &hdmi_dev->delay_work, msecs_to_jiffies(HDMI_POLL_MDELAY));
-		}
+
+		if (hdmi_dev->irq == 0)
+			queue_delayed_work(hdmi_drv->workqueue,
+					   &hdmi_dev->delay_work,
+					   msecs_to_jiffies(HDMI_POLL_MDELAY));
 	}
 }
 #endif
@@ -163,15 +171,15 @@ static void rk3288_poll_delay_work(struct work_struct *work)
 static int rk3288_hdmi_clk_enable(struct rk3288_hdmi_device *hdmi_dev)
 {
 	if ((hdmi_dev->clk_on & HDMI_PD_ON) && (hdmi_dev->clk_on & HDMI_PCLK_ON)
-		&& (hdmi_dev->clk_on & HDMI_HDCPCLK_ON)) {
+	    && (hdmi_dev->clk_on & HDMI_HDCPCLK_ON))
 		return 0;
-	}
 
 	if ((hdmi_dev->clk_on & HDMI_PD_ON) == 0) {
 		if (hdmi_dev->pd == NULL) {
 			hdmi_dev->pd = devm_clk_get(hdmi_dev->dev, "pd_hdmi");
 			if (IS_ERR(hdmi_dev->pd)) {
-				dev_err(hdmi_dev->dev, "Unable to get hdmi pd\n");
+				dev_err(hdmi_dev->dev,
+					"Unable to get hdmi pd\n");
 				return -1;
 			}
 		}
@@ -181,9 +189,11 @@ static int rk3288_hdmi_clk_enable(struct rk3288_hdmi_device *hdmi_dev)
 
 	if ((hdmi_dev->clk_on & HDMI_PCLK_ON) == 0) {
 		if (hdmi_dev->pclk == NULL) {
-			hdmi_dev->pclk = devm_clk_get(hdmi_dev->dev, "pclk_hdmi");
+			hdmi_dev->pclk =
+			    devm_clk_get(hdmi_dev->dev, "pclk_hdmi");
 			if (IS_ERR(hdmi_dev->pclk)) {
-				dev_err(hdmi_dev->dev, "Unable to get hdmi pclk\n");
+				dev_err(hdmi_dev->dev,
+					"Unable to get hdmi pclk\n");
 				return -1;
 			}
 		}
@@ -193,9 +203,11 @@ static int rk3288_hdmi_clk_enable(struct rk3288_hdmi_device *hdmi_dev)
 
 	if ((hdmi_dev->clk_on & HDMI_HDCPCLK_ON) == 0) {
 		if (hdmi_dev->hdcp_clk == NULL) {
-			hdmi_dev->hdcp_clk = devm_clk_get(hdmi_dev->dev, "hdcp_clk_hdmi");
+			hdmi_dev->hdcp_clk =
+			    devm_clk_get(hdmi_dev->dev, "hdcp_clk_hdmi");
 			if (IS_ERR(hdmi_dev->hdcp_clk)) {
-				dev_err(hdmi_dev->dev, "Unable to get hdmi hdcp_clk\n");
+				dev_err(hdmi_dev->dev,
+					"Unable to get hdmi hdcp_clk\n");
 				return -1;
 			}
 		}
@@ -208,9 +220,8 @@ static int rk3288_hdmi_clk_enable(struct rk3288_hdmi_device *hdmi_dev)
 
 static int rk3288_hdmi_clk_disable(struct rk3288_hdmi_device *hdmi_dev)
 {
-	if (hdmi_dev->clk_on == 0) {
+	if (hdmi_dev->clk_on == 0)
 		return 0;
-	}
 
 	if ((hdmi_dev->clk_on & HDMI_PD_ON) && (hdmi_dev->pd != NULL)) {
 		clk_disable_unprepare(hdmi_dev->pd);
@@ -222,7 +233,8 @@ static int rk3288_hdmi_clk_disable(struct rk3288_hdmi_device *hdmi_dev)
 		hdmi_dev->clk_on &= ~HDMI_PCLK_ON;
 	}
 
-	if ((hdmi_dev->clk_on & HDMI_HDCPCLK_ON) && (hdmi_dev->hdcp_clk != NULL)) {
+	if ((hdmi_dev->clk_on & HDMI_HDCPCLK_ON)
+	    && (hdmi_dev->hdcp_clk != NULL)) {
 		clk_disable_unprepare(hdmi_dev->hdcp_clk);
 		hdmi_dev->clk_on &= ~HDMI_HDCPCLK_ON;
 	}
@@ -236,16 +248,18 @@ static int rk3288_hdmi_drv_init(struct hdmi *hdmi_drv)
 	struct rk_screen screen;
 
 	rk_fb_get_prmry_screen(&screen);
-	hdmi_dev->lcdc_id = (screen.lcdc_id == 0) ? 1 : 0;	//hdmi is extend as default,TODO modify if hdmi is primary
-	printk("HDMI Source Lcdc id = %d\n", hdmi_dev->lcdc_id);
-        grf_writel(HDMI_SEL_LCDC(hdmi_dev->lcdc_id), RK3288_GRF_SOC_CON6);	//lcdc source select
-	if(hdmi_dev->lcdc_id == 0)
+
+	/* hdmi is extend as default,TODO modify if hdmi is primary */
+	hdmi_dev->lcdc_id = (screen.lcdc_id == 0) ? 1 : 0;
+	/* lcdc source select */
+	grf_writel(HDMI_SEL_LCDC(hdmi_dev->lcdc_id), RK3288_GRF_SOC_CON6);
+	if (hdmi_dev->lcdc_id == 0)
 		hdmi_drv->lcdc = rk_get_lcdc_drv("lcdc0");
 	else
 		hdmi_drv->lcdc = rk_get_lcdc_drv("lcdc1");
-	if(IS_ERR(hdmi_drv->lcdc))
-	{
-		dev_err(hdmi_drv->dev, "can not connect to video source lcdc\n");
+	if (IS_ERR(hdmi_drv->lcdc)) {
+		dev_err(hdmi_drv->dev,
+			"can not connect to video source lcdc\n");
 		ret = -ENXIO;
 		return ret;
 	}
@@ -267,14 +281,15 @@ static void rk3288_hdmi_early_suspend(void)
 {
 	struct hdmi *hdmi_drv = &hdmi_dev->driver;
 
-	if(hdmi_drv->suspend)
+	if (hdmi_drv->suspend)
 		return;
 
-	hdmi_dbg(hdmi_drv->dev, "hdmi enter early suspend pwr %d state %d\n", hdmi_drv->pwr_mode, hdmi_drv->state);
+	hdmi_dbg(hdmi_drv->dev, "hdmi enter early suspend pwr %d state %d\n",
+		 hdmi_drv->pwr_mode, hdmi_drv->state);
 	flush_delayed_work(&hdmi_drv->delay_work);
 	mutex_lock(&hdmi_drv->enable_mutex);
 	hdmi_drv->suspend = 1;
-	if(!hdmi_drv->enable) {
+	if (!hdmi_drv->enable) {
 		mutex_unlock(&hdmi_drv->enable_mutex);
 		return;
 	}
@@ -285,7 +300,7 @@ static void rk3288_hdmi_early_suspend(void)
 	hdmi_drv->wait = 1;
 	queue_delayed_work(hdmi_drv->workqueue, &hdmi_drv->delay_work, 0);
 	wait_for_completion_interruptible_timeout(&hdmi_drv->complete,
-							msecs_to_jiffies(5000));
+						  msecs_to_jiffies(5000));
 	flush_delayed_work(&hdmi_drv->delay_work);
 	rk3288_hdmi_clk_disable(hdmi_dev);
 	return;
@@ -295,7 +310,7 @@ static void rk3288_hdmi_early_resume(void)
 {
 	struct hdmi *hdmi_drv = &hdmi_dev->driver;
 
-	if(!hdmi_drv->suspend)
+	if (!hdmi_drv->suspend)
 		return;
 
 	hdmi_dbg(hdmi_drv->dev, "hdmi enter early resume\n");
@@ -303,20 +318,22 @@ static void rk3288_hdmi_early_resume(void)
 	mutex_lock(&hdmi_drv->enable_mutex);
 	hdmi_drv->suspend = 0;
 	rk3288_hdmi_initial(hdmi_drv);
-	if(hdmi_dev->irq == 0){
+	if (hdmi_dev->irq == 0) {
 #ifdef HDMI_INT_USE_POLL
-		queue_delayed_work(hdmi_drv->workqueue, &hdmi_dev->delay_work, msecs_to_jiffies(5));
+		queue_delayed_work(hdmi_drv->workqueue, &hdmi_dev->delay_work,
+				   msecs_to_jiffies(5));
 #endif
-	}
-	else if(hdmi_drv->enable){
+	} else if (hdmi_drv->enable) {
 		enable_irq(hdmi_drv->irq);
 	}
-	queue_delayed_work(hdmi_drv->workqueue, &hdmi_drv->delay_work, msecs_to_jiffies(10));
+	queue_delayed_work(hdmi_drv->workqueue, &hdmi_drv->delay_work,
+			   msecs_to_jiffies(10));
 	mutex_unlock(&hdmi_drv->enable_mutex);
 	return;
 }
 
-static int rk3288_hdmi_fb_event_notify(struct notifier_block *self, unsigned long action, void *data)
+static int rk3288_hdmi_fb_event_notify(struct notifier_block *self,
+				       unsigned long action, void *data)
 {
 	struct fb_event *event = data;
 	int blank_mode = *((int *)event->data);
@@ -329,8 +346,7 @@ static int rk3288_hdmi_fb_event_notify(struct notifier_block *self, unsigned lon
 			rk3288_hdmi_early_suspend();
 			break;
 		}
-	}
-	else if (action == FB_EVENT_BLANK) {
+	} else if (action == FB_EVENT_BLANK) {
 		switch (blank_mode) {
 		case FB_BLANK_UNBLANK:
 			rk3288_hdmi_early_resume();
@@ -344,7 +360,7 @@ static int rk3288_hdmi_fb_event_notify(struct notifier_block *self, unsigned lon
 }
 
 static struct notifier_block rk3288_hdmi_fb_notifier = {
-        .notifier_call = rk3288_hdmi_fb_event_notify,
+	.notifier_call = rk3288_hdmi_fb_event_notify,
 };
 
 #if defined(CONFIG_OF)
@@ -353,7 +369,7 @@ static int rk3288_hdmi_parse_dt(struct rk3288_hdmi_device *hdmi_dev)
 	int val = 0;
 	struct device_node *np = hdmi_dev->dev->of_node;
 
-	if(!of_property_read_u32(np, "rockchips,hdmi_audio_source", &val))
+	if (!of_property_read_u32(np, "rockchips,hdmi_audio_source", &val))
 		hdmi_dev->driver.audio.type = val;
 
 	return 0;
@@ -372,7 +388,7 @@ static int rk3288_hdmi_probe(struct platform_device *pdev)
 	struct hdmi *dev_drv = NULL;
 
 	hdmi_dev = kzalloc(sizeof(struct rk3288_hdmi_device), GFP_KERNEL);
-	if(!hdmi_dev) {
+	if (!hdmi_dev) {
 		dev_err(&pdev->dev, ">>rk3288_hdmi_device kzalloc fail!");
 		return -ENOMEM;
 	}
@@ -382,14 +398,13 @@ static int rk3288_hdmi_probe(struct platform_device *pdev)
 	mutex_init(&hdmi_dev->int_mutex);
 
 	rk3288_hdmi_parse_dt(hdmi_dev);
-	//TODO Daisen wait to add cec iomux
+	/* TODO Daisen wait to add cec iomux */
 
-	/*enable pd and pclk and hdcp_clk*/
-	if (rk3288_hdmi_clk_enable(hdmi_dev) < 0) {
+	/* enable pd and pclk and hdcp_clk */
+	if (rk3288_hdmi_clk_enable(hdmi_dev) < 0)
 		goto err0;
-	}
 
-	/*request and remap iomem*/
+	/* request and remap iomem */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(hdmi_dev->dev, "Unable to get register resource\n");
@@ -401,16 +416,16 @@ static int rk3288_hdmi_probe(struct platform_device *pdev)
 	hdmi_dev->regbase = devm_ioremap_resource(hdmi_dev->dev, res);
 	if (IS_ERR(hdmi_dev->regbase)) {
 		ret = PTR_ERR(hdmi_dev->regbase);
-		dev_err(hdmi_dev->dev, "cannot ioremap registers,err=%d\n",ret);
+		dev_err(hdmi_dev->dev, "cannot ioremap registers,err=%d\n",
+			ret);
 		goto err0;
 	}
 
-	/*init hdmi driver*/
+	/*init hdmi driver */
 	dev_drv = &hdmi_dev->driver;
 	dev_drv->dev = &pdev->dev;
-	if(rk3288_hdmi_drv_init(dev_drv)) {
+	if (rk3288_hdmi_drv_init(dev_drv))
 		goto err0;
-	}
 
 	dev_drv->workqueue = create_singlethread_workqueue("hdmi");
 	INIT_DELAYED_WORK(&(dev_drv->delay_work), hdmi_work);
@@ -427,13 +442,17 @@ static int rk3288_hdmi_probe(struct platform_device *pdev)
 #ifndef HDMI_INT_USE_POLL
 	/* get and request the IRQ */
 	dev_drv->irq = platform_get_irq(pdev, 0);
-	if(dev_drv->irq <= 0) {
-		dev_err(hdmi_dev->dev, "failed to get hdmi irq resource (%d).\n", hdmi_dev->irq);
+	if (dev_drv->irq <= 0) {
+		dev_err(hdmi_dev->dev,
+			"failed to get hdmi irq resource (%d).\n",
+			hdmi_dev->irq);
 		ret = -ENXIO;
 		goto err1;
 	}
 
-	ret = devm_request_irq(hdmi_dev->dev, dev_drv->irq, hdmi_irq, 0, dev_name(hdmi_dev->dev), dev_drv);
+	ret =
+	    devm_request_irq(hdmi_dev->dev, dev_drv->irq, hdmi_irq, 0,
+			     dev_name(hdmi_dev->dev), dev_drv);
 	if (ret) {
 		dev_err(hdmi_dev->dev, "hdmi request_irq failed (%d).\n", ret);
 		goto err1;
@@ -441,15 +460,18 @@ static int rk3288_hdmi_probe(struct platform_device *pdev)
 #else
 	hdmi_dev->irq = 0;
 	INIT_DELAYED_WORK(&hdmi_dev->delay_work, rk3288_poll_delay_work);
-	queue_delayed_work(dev_drv->workqueue, &hdmi_dev->delay_work, msecs_to_jiffies(1));
+	queue_delayed_work(dev_drv->workqueue, &hdmi_dev->delay_work,
+			   msecs_to_jiffies(1));
 #endif
 
 #if defined(CONFIG_DEBUG_FS)
-        hdmi_dev->debugfs_dir = debugfs_create_dir("rk3288-hdmi", NULL);
+	hdmi_dev->debugfs_dir = debugfs_create_dir("rk3288-hdmi", NULL);
 	if (IS_ERR(hdmi_dev->debugfs_dir)) {
-		dev_err(hdmi_dev->dev,"failed to create debugfs dir for rk3288 hdmi!\n");
+		dev_err(hdmi_dev->dev,
+			"failed to create debugfs dir for rk3288 hdmi!\n");
 	} else {
-		debugfs_create_file("hdmi", S_IRUSR, hdmi_dev->debugfs_dir, hdmi_dev, &rk3288_hdmi_reg_fops);
+		debugfs_create_file("hdmi", S_IRUSR, hdmi_dev->debugfs_dir,
+				    hdmi_dev, &rk3288_hdmi_reg_fops);
 	}
 #endif
 
@@ -463,8 +485,10 @@ static int rk3288_hdmi_probe(struct platform_device *pdev)
 #endif
 	hdmi_unregister_display_sysfs(dev_drv);
 
-	//iounmap((void*)hdmi_dev->regbase);
-	//release_mem_region(res->start,hdmi_dev->regsize_phy);
+	/*
+	iounmap((void*)hdmi_dev->regbase);
+	release_mem_region(res->start, hdmi_dev->regsize_phy);
+	*/
 err0:
 	rk3288_hdmi_clk_disable(hdmi_dev);
 	dev_info(hdmi_dev->dev, "rk3288 hdmi probe error.\n");
@@ -478,10 +502,10 @@ static int rk3288_hdmi_remove(struct platform_device *pdev)
 	struct rk3288_hdmi_device *hdmi_dev = platform_get_drvdata(pdev);
 	struct hdmi *hdmi_drv = NULL;
 
-	if(hdmi_dev) {
+	if (hdmi_dev) {
 		hdmi_drv = &hdmi_dev->driver;
 		mutex_lock(&hdmi_drv->enable_mutex);
-		if(!hdmi_drv->suspend && hdmi_drv->enable)
+		if (!hdmi_drv->suspend && hdmi_drv->enable)
 			disable_irq(hdmi_drv->irq);
 		mutex_unlock(&hdmi_drv->enable_mutex);
 		free_irq(hdmi_drv->irq, NULL);
@@ -491,28 +515,28 @@ static int rk3288_hdmi_remove(struct platform_device *pdev)
 
 		fb_unregister_client(&rk3288_hdmi_fb_notifier);
 
-		#ifdef CONFIG_SWITCH
+#ifdef CONFIG_SWITCH
 		switch_dev_unregister(&(hdmi_drv->switch_hdmi));
-		#endif
+#endif
 		hdmi_unregister_display_sysfs(hdmi_drv);
 
-		//iounmap((void*)hdmi_drv->regbase);
-		//release_mem_region(hdmi_drv->regbase_phy, hdmi_drv->regsize_phy);
+		/*
+		iounmap((void*)hdmi_drv->regbase);
+		release_mem_region(hdmi_drv->regbase_phy,
+					hdmi_drv->regsize_phy);
+		*/
 		rk3288_hdmi_clk_disable(hdmi_dev);
 		fb_destroy_modelist(&hdmi_drv->edid.modelist);
-		if(hdmi_drv->edid.audio)
-			kfree(hdmi_drv->edid.audio);
-		if(hdmi_drv->edid.specs)
-		{
-			if(hdmi_drv->edid.specs->modedb)
-				kfree(hdmi_drv->edid.specs->modedb);
+		kfree(hdmi_drv->edid.audio);
+		if (hdmi_drv->edid.specs) {
+			kfree(hdmi_drv->edid.specs->modedb);
 			kfree(hdmi_drv->edid.specs);
 		}
 
 		kfree(hdmi_dev);
 		hdmi_dev = NULL;
 	}
-	printk(KERN_INFO "rk3288 hdmi removed.\n");
+	dev_info(hdmi_dev->dev, "rk3288 hdmi removed.\n");
 	return 0;
 }
 
@@ -522,14 +546,14 @@ static void rk3288_hdmi_shutdown(struct platform_device *pdev)
 }
 
 static struct platform_driver rk3288_hdmi_driver = {
-	.probe		= rk3288_hdmi_probe,
-	.remove		= rk3288_hdmi_remove,
-	.driver		= {
-		.name	= "rk3288-hdmi",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(rk3288_hdmi_dt_ids),
-	},
-	.shutdown   = rk3288_hdmi_shutdown,
+	.probe = rk3288_hdmi_probe,
+	.remove = rk3288_hdmi_remove,
+	.driver = {
+		   .name = "rk3288-hdmi",
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(rk3288_hdmi_dt_ids),
+		   },
+	.shutdown = rk3288_hdmi_shutdown,
 };
 
 static int __init rk3288_hdmi_init(void)
@@ -544,4 +568,3 @@ static void __exit rk3288_hdmi_exit(void)
 
 device_initcall_sync(rk3288_hdmi_init);
 module_exit(rk3288_hdmi_exit);
-
diff --git a/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi.h b/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi.h
index 9b332f8cdacb..41055d4e45ee 100644
--- a/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi.h
+++ b/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi.h
@@ -7,7 +7,8 @@
 #define ENABLE		16
 #define HDMI_SEL_LCDC(x)	((((x)&1)<<4)|(1<<(4+ENABLE)))
 
-extern struct hdmi* rk3288_hdmi_register_hdcp_callbacks(
+extern irqreturn_t hdmi_irq(int irq, void *priv);
+extern struct hdmi *rk3288_hdmi_register_hdcp_callbacks(
 					 void (*hdcp_cb)(void),
 					 void (*hdcp_irq_cb)(int status),
 					 int  (*hdcp_power_on_cb)(void),
diff --git a/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi_hw.c b/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi_hw.c
index b34c973fedf2..baeea2db90a6 100644
--- a/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi_hw.c
+++ b/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi_hw.c
@@ -2,39 +2,39 @@
 #include <linux/interrupt.h>
 #include "rk3288_hdmi_hw.h"
 
-
-static const struct phy_mpll_config_tab PHY_MPLL_TABLE[] = {	//opmode: 0:HDMI1.4 	1:HDMI2.0
-//     	pixclock    pixrepet	    colordepth	            prepdiv  tmdsmhl opmode  fbdiv2  fbdiv1  ref_cntrl nctrl propctrl intctrl gmpctrl
-	{27000000,	0,	HDMI_COLOR_DEPTH_8BIT,		0,	0,	0,	2,	3,	0,	3,	7,	0,	3},
-	{27000000,	0,	HDMI_COLOR_DEPTH_10BIT,		1,	0,	0,	5,	1,	0,	3,	3,	0,	0},
-	{27000000,	0,	HDMI_COLOR_DEPTH_12BIT,		2,	0,	0,	3,	3,	0,	3,	3,	0,	0},
-	{27000000,	0,	HDMI_COLOR_DEPTH_16BIT,		3,	0,	0,	2,	3,	0,	2,	5,	0,	1},
-	{74250000, 	0,	HDMI_COLOR_DEPTH_8BIT, 		0,	0,	0, 	4, 	3,	3,	2,	7,	0, 	3},
-	{74250000,	0,	HDMI_COLOR_DEPTH_10BIT,		1,	0,	0,	5,	3,	3,	2,	7,	0,	2},
-	{74250000,	0,	HDMI_COLOR_DEPTH_12BIT,		2,	0,	0,	1,	2,	0,	1,	7,	0,	2},
-	{74250000,	0,	HDMI_COLOR_DEPTH_16BIT,		3,	0,	0,	1,	3,	0,	1,	7,	0,	2},
-	{148500000, 	0, 	HDMI_COLOR_DEPTH_8BIT,  	0, 	0,	0,	1,	1,	0,	1,	0,	0,	3},
-	{148500000,	0,	HDMI_COLOR_DEPTH_10BIT,		1,	0,	0,	5,	1,	3,	1,	7,	0,	3},
-	{148500000,	0,	HDMI_COLOR_DEPTH_12BIT,		2,	0,	0,	1,	2,	1,	0,	7,	0,	3},
-	{148500000,	0,	HDMI_COLOR_DEPTH_16BIT,		3,	0,	0,	1,	1,	0,	0,	7,	0,	3},
-	{297000000,	0, 	HDMI_COLOR_DEPTH_8BIT,		0, 	0, 	0, 	1, 	0, 	0, 	0, 	0, 	0, 	3},
-	{297000000,	0, 	HDMI_COLOR_DEPTH_10BIT,		1, 	3, 	1, 	5, 	0, 	3, 	0, 	7, 	0, 	3},
-	{297000000,	0, 	HDMI_COLOR_DEPTH_12BIT,		2, 	3, 	1, 	1, 	2, 	2, 	0, 	7, 	0, 	3},
-	{297000000, 	0, 	HDMI_COLOR_DEPTH_16BIT,  	3, 	3, 	1, 	1, 	1, 	0, 	0, 	5, 	0, 	3},
-	{594000000,	0, 	HDMI_COLOR_DEPTH_8BIT, 		0, 	3, 	1, 	1, 	0, 	0, 	0, 	3, 	0, 	3},
+static const struct phy_mpll_config_tab PHY_MPLL_TABLE[] = {	/* opmode: 0:HDMI1.4     1:HDMI2.0 */
+/*      pixclock    pixrepet        colordepth	    prepdiv  tmdsmhl opmode  fbdiv2  fbdiv1  ref_cntrl nctrl propctrl intctrl gmpctrl */
+	{27000000,	0,	HDMI_COLOR_DEPTH_8BIT,	0,	0,	0,	2,	3,	0,	3,	7,	0,	3},
+	{27000000,	0,	HDMI_COLOR_DEPTH_10BIT,	1,	0,	0,	5,	1,	0,	3,	3,	0,	0},
+	{27000000,	0,	HDMI_COLOR_DEPTH_12BIT,	2,	0,	0,	3,	3,	0,	3,	3,	0,	0},
+	{27000000,	0,	HDMI_COLOR_DEPTH_16BIT,	3,	0,	0,	2,	3,	0,	2,	5,	0,	1},
+	{74250000,	0,	HDMI_COLOR_DEPTH_8BIT,	0,	0,	0,	4,	3,	3,	2,	7,	0,	3},
+	{74250000,	0,	HDMI_COLOR_DEPTH_10BIT, 1,	0,	0,	5,	3,	3,	2,	7,	0,	2},
+	{74250000,	0,	HDMI_COLOR_DEPTH_12BIT,	2,	0,	0,	1,	2,	0,	1,	7,	0,	2},
+	{74250000,	0,	HDMI_COLOR_DEPTH_16BIT, 3,	0,	0,	1,	3,	0,	1,	7,	0,	2},
+	{148500000,	0,	HDMI_COLOR_DEPTH_8BIT,	0,	0,	0,	1,	1,	0,	1,	0,	0,	3},
+	{148500000,	0,	HDMI_COLOR_DEPTH_10BIT,	1,	0,	0,	5,	1,	3,	1,	7,	0,	3},
+	{148500000,	0,	HDMI_COLOR_DEPTH_12BIT,	2,	0,	0,	1,	2,	1,	0,	7,	0,	3},
+	{148500000,	0,	HDMI_COLOR_DEPTH_16BIT,	3,	0,	0,	1,	1,	0,	0,	7,	0,	3},
+	{297000000,	0,	HDMI_COLOR_DEPTH_8BIT,	0,	0,	0,	1,	0,	0,	0,	0,	0,	3},
+	{297000000,	0,	HDMI_COLOR_DEPTH_10BIT,	1,	3,	1,	5,	0,	3,	0,	7,	0,	3},
+	{297000000,	0,	HDMI_COLOR_DEPTH_12BIT,	2,	3,	1,	1,	2,	2,	0,	7,	0,	3},
+	{297000000,	0,	HDMI_COLOR_DEPTH_16BIT,	3,	3,	1,	1,	1,	0,	0,	5,	0,	3},
+	{594000000,	0,	HDMI_COLOR_DEPTH_8BIT,	0,	3,	1,	1,	0,	0,	0,	3,	0,	3},
 };
 
-const struct phy_mpll_config_tab* get_phy_mpll_tab(int pixClock, char pixRepet, char colorDepth)
+const struct phy_mpll_config_tab *get_phy_mpll_tab(int pixClock, char pixRepet,
+						   char colorDepth)
 {
 	int i;
 
-	if(pixClock == 0)
+	if (pixClock == 0)
 		return NULL;
 
-	for(i = 0; i < ARRAY_SIZE(PHY_MPLL_TABLE); i++)
-	{
-		if((PHY_MPLL_TABLE[i].pix_clock == pixClock) && (PHY_MPLL_TABLE[i].pix_repet == pixRepet)
-			&& (PHY_MPLL_TABLE[i].color_depth == colorDepth))
+	for (i = 0; i < ARRAY_SIZE(PHY_MPLL_TABLE); i++) {
+		if ((PHY_MPLL_TABLE[i].pix_clock == pixClock)
+		    && (PHY_MPLL_TABLE[i].pix_repet == pixRepet)
+		    && (PHY_MPLL_TABLE[i].color_depth == colorDepth))
 			return &PHY_MPLL_TABLE[i];
 	}
 	return NULL;
@@ -42,51 +42,59 @@ const struct phy_mpll_config_tab* get_phy_mpll_tab(int pixClock, char pixRepet,
 
 static void rk3288_hdmi_av_mute(struct hdmi *hdmi_drv, int enable)
 {
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
-	hdmi_msk_reg(hdmi_dev, FC_GCP, m_FC_SET_AVMUTE, v_FC_SET_AVMUTE(enable));
+	hdmi_msk_reg(hdmi_dev, FC_GCP, m_FC_SET_AVMUTE,
+		     v_FC_SET_AVMUTE(enable));
 #if 0
 	/* audio mute priority: AVMUTE, sample flat, validity */
 	/* AVMUTE also mutes video */
 	value = enable ? 0xF : 0;
-	hdmi_msk_reg(hdmi_dev, FC_AUDSCONF, m_AUD_PACK_SAMPFIT, v_AUD_PACK_SAMPFIT(value));
+	hdmi_msk_reg(hdmi_dev, FC_AUDSCONF, m_AUD_PACK_SAMPFIT,
+		     v_AUD_PACK_SAMPFIT(value));
 #endif
 }
 
 static void rk3288_hdmi_set_pwr_mode(struct hdmi *hdmi_drv, int mode)
 {
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
-	if(hdmi_drv->pwr_mode == mode)
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	if (hdmi_drv->pwr_mode == mode)
 		return;
 
-	dev_printk(KERN_INFO, hdmi_drv->dev, "%s change pwr_mode %d --> %d\n", __FUNCTION__, hdmi_drv->pwr_mode, mode);
+	dev_printk(KERN_INFO, hdmi_drv->dev, "%s change pwr_mode %d --> %d\n",
+		   __func__, hdmi_drv->pwr_mode, mode);
 
-	switch(mode)
-	{
-		case NORMAL:
-			hdmi_writel(hdmi_dev, MC_CLKDIS, 0x00);
-			break;
-		case LOWER_PWR:
-			hdmi_writel(hdmi_dev, MC_CLKDIS, 0xff);
-			hdmi_msk_reg(hdmi_dev, PHY_CONF0, m_TMDS_EN | m_TXPWRON_SIG | m_ENHPD_RXSENSE_SIG,
-				v_TMDS_EN(0) | v_TXPWRON_SIG(0) | v_ENHPD_RXSENSE_SIG(1));
-			break;
-		default:
-			hdmi_dbg(hdmi_drv->dev, "unkown hdmi pwr mode %d\n",mode);
+	switch (mode) {
+	case NORMAL:
+		hdmi_writel(hdmi_dev, MC_CLKDIS, 0x00);
+		break;
+	case LOWER_PWR:
+		hdmi_writel(hdmi_dev, MC_CLKDIS, 0xff);
+		hdmi_msk_reg(hdmi_dev, PHY_CONF0,
+			     m_TMDS_EN | m_TXPWRON_SIG | m_ENHPD_RXSENSE_SIG,
+			     v_TMDS_EN(0) | v_TXPWRON_SIG(0) |
+			     v_ENHPD_RXSENSE_SIG(1));
+		break;
+	default:
+		hdmi_dbg(hdmi_drv->dev, "unkown hdmi pwr mode %d\n", mode);
 	}
 	hdmi_drv->pwr_mode = mode;
 }
 
-//i2c master reset
+/* i2c master reset */
 void rk3288_hdmi_i2cm_reset(struct rk3288_hdmi_device *hdmi_dev)
 {
-	hdmi_msk_reg(hdmi_dev, I2CM_SOFTRSTZ, m_I2CM_SOFTRST, v_I2CM_SOFTRST(0));
+	hdmi_msk_reg(hdmi_dev, I2CM_SOFTRSTZ, m_I2CM_SOFTRST,
+		     v_I2CM_SOFTRST(0));
 	udelay(100);
 }
 
 void rk3288_hdmi_reset(struct hdmi *hdmi_drv)
 {
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
 	hdmi_writel(hdmi_dev, MC_SWRSTZREQ, 0x00);
 	udelay(100);
@@ -97,7 +105,7 @@ void rk3288_hdmi_reset(struct hdmi *hdmi_drv)
 
 	rk3288_hdmi_i2cm_reset(hdmi_dev);
 #if 1
-	//reset PHY
+	/* reset PHY */
 	hdmi_writel(hdmi_dev, MC_PHYRSTZ, v_PHY_RSTZ(1));
 	udelay(100);
 	hdmi_writel(hdmi_dev, MC_PHYRSTZ, v_PHY_RSTZ(0));
@@ -108,12 +116,14 @@ void rk3288_hdmi_reset(struct hdmi *hdmi_drv)
 
 int rk3288_hdmi_detect_hotplug(struct hdmi *hdmi_drv)
 {
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 	u32 value = hdmi_readl(hdmi_dev, PHY_STAT0);
 
-	hdmi_dbg(hdmi_drv->dev, "[%s] reg%x value %02x\n", __FUNCTION__, PHY_STAT0, value);
+	hdmi_dbg(hdmi_drv->dev, "[%s] reg%x value %02x\n", __func__,
+		 PHY_STAT0, value);
 
-	if((value & m_PHY_HPD) || ((value & 0xf0) == 0xf0))
+	if ((value & m_PHY_HPD) || ((value & 0xf0) == 0xf0))
 		return HDMI_HPD_ACTIVED;
 	else
 		return HDMI_HPD_REMOVED;
@@ -124,106 +134,130 @@ int rk3288_hdmi_read_edid(struct hdmi *hdmi_drv, int block, unsigned char *buff)
 	int i = 0, n = 0, index = 0, ret = -1, trytime = 2;
 	int offset = (block % 2) * 0x80;
 	int interrupt = 0;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
-	hdmi_dbg(hdmi_drv->dev, "[%s] block %d\n", __FUNCTION__, block);
+	hdmi_dbg(hdmi_drv->dev, "[%s] block %d\n", __func__, block);
 
-	//Set DDC I2C CLK which devided from DDC_CLK to 100KHz.
+	/* Set DDC I2C CLK which devided from DDC_CLK to 100KHz */
 	hdmi_writel(hdmi_dev, I2CM_SS_SCL_HCNT_0_ADDR, 0x7a);
 	hdmi_writel(hdmi_dev, I2CM_SS_SCL_LCNT_0_ADDR, 0x8d);
-	hdmi_msk_reg(hdmi_dev, I2CM_DIV, m_I2CM_FAST_STD_MODE, v_I2CM_FAST_STD_MODE(STANDARD_MODE));	//Set Standard Mode
+	hdmi_msk_reg(hdmi_dev, I2CM_DIV, m_I2CM_FAST_STD_MODE,
+		v_I2CM_FAST_STD_MODE(STANDARD_MODE));	/* Set Standard Mode */
 
-	//Enable I2C interrupt for reading edid
-	hdmi_writel(hdmi_dev, IH_MUTE_I2CM_STAT0, v_SCDC_READREQ_MUTE(0) | v_I2CM_DONE_MUTE(0) | v_I2CM_ERR_MUTE(0));
+	/* Enable I2C interrupt for reading edid */
+	hdmi_writel(hdmi_dev, IH_MUTE_I2CM_STAT0,
+		    v_SCDC_READREQ_MUTE(0) | v_I2CM_DONE_MUTE(0) |
+		    v_I2CM_ERR_MUTE(0));
 	hdmi_msk_reg(hdmi_dev, I2CM_INT, m_I2CM_DONE_MASK, v_I2CM_DONE_MASK(0));
-	hdmi_msk_reg(hdmi_dev, I2CM_CTLINT, m_I2CM_NACK_MASK | m_I2CM_ARB_MASK, v_I2CM_NACK_MASK(0) | v_I2CM_ARB_MASK(0));
+	hdmi_msk_reg(hdmi_dev, I2CM_CTLINT, m_I2CM_NACK_MASK | m_I2CM_ARB_MASK,
+		     v_I2CM_NACK_MASK(0) | v_I2CM_ARB_MASK(0));
 
 	hdmi_writel(hdmi_dev, I2CM_SLAVE, DDC_I2C_EDID_ADDR);
 	hdmi_writel(hdmi_dev, I2CM_SEGADDR, DDC_I2C_SEG_ADDR);
 	hdmi_writel(hdmi_dev, I2CM_SEGPTR, block / 2);
-	while(trytime--) {
-		for(n = 0; n < HDMI_EDID_BLOCK_SIZE / 8; n++) {
+	while (trytime--) {
+		for (n = 0; n < HDMI_EDID_BLOCK_SIZE / 8; n++) {
 			hdmi_writel(hdmi_dev, I2CM_ADDRESS, offset + 8 * n);
-			//enable extend sequential read operation
-			if(block == 0)
-				hdmi_msk_reg(hdmi_dev, I2CM_OPERATION, m_I2CM_RD8, v_I2CM_RD8(1));
+			/* enable extend sequential read operation */
+			if (block == 0)
+				hdmi_msk_reg(hdmi_dev, I2CM_OPERATION,
+					     m_I2CM_RD8, v_I2CM_RD8(1));
 			else
-				hdmi_msk_reg(hdmi_dev, I2CM_OPERATION, m_I2CM_RD8_EXT, v_I2CM_RD8_EXT(1));
+				hdmi_msk_reg(hdmi_dev, I2CM_OPERATION,
+					     m_I2CM_RD8_EXT, v_I2CM_RD8_EXT(1));
 
 			i = 20;
-			while(i--)
-			{
+			while (i--) {
 				msleep(1);
 				interrupt = hdmi_readl(hdmi_dev, IH_I2CM_STAT0);
-				if(interrupt)
-					hdmi_writel(hdmi_dev, IH_I2CM_STAT0, interrupt);
+				if (interrupt)
+					hdmi_writel(hdmi_dev, IH_I2CM_STAT0,
+						    interrupt);
 
-				if(interrupt & (m_SCDC_READREQ | m_I2CM_DONE | m_I2CM_ERROR))
+				if (interrupt &
+				    (m_SCDC_READREQ | m_I2CM_DONE |
+				     m_I2CM_ERROR))
 					break;
 				msleep(4);
 			}
 
-			if(interrupt & m_I2CM_DONE) {
-				for(index = 0; index < 8; index++) {
-					buff[8 * n + index] = hdmi_readl(hdmi_dev, I2CM_READ_BUFF0 + index);
+			if (interrupt & m_I2CM_DONE) {
+				for (index = 0; index < 8; index++) {
+					buff[8 * n + index] =
+					    hdmi_readl(hdmi_dev,
+						       I2CM_READ_BUFF0 + index);
 				}
 
-				if(n == HDMI_EDID_BLOCK_SIZE / 8 - 1) {
+				if (n == HDMI_EDID_BLOCK_SIZE / 8 - 1) {
 					ret = 0;
-					hdmi_dbg(hdmi_drv->dev, "[%s] edid read sucess\n", __FUNCTION__);
+					hdmi_dbg(hdmi_drv->dev,
+						 "[%s] edid read sucess\n",
+						 __func__);
 
-				#ifdef HDMI_DEBUG
-					for(i = 0; i < 128; i++) {
+#ifdef HDMI_DEBUG
+					for (i = 0; i < 128; i++) {
 						printk("%02x ,", buff[i]);
-						if( (i + 1) % 16 == 0)
+						if ((i + 1) % 16 == 0)
 							printk("\n");
 					}
-				#endif
+#endif
 					goto exit;
 				}
 				continue;
-			} else if((interrupt & m_I2CM_ERROR) || (i == -1)) {
-				hdmi_err(hdmi_drv->dev, "[%s] edid read error\n", __FUNCTION__);
+			} else if ((interrupt & m_I2CM_ERROR) || (i == -1)) {
+				hdmi_err(hdmi_drv->dev,
+					 "[%s] edid read error\n",
+					 __func__);
 				rk3288_hdmi_i2cm_reset(hdmi_dev);
 				break;
 			}
 		}
 
-		hdmi_err(hdmi_drv->dev, "[%s] edid try times %d\n", __FUNCTION__, trytime);
+		hdmi_err(hdmi_drv->dev, "[%s] edid try times %d\n",
+			 __func__, trytime);
 		msleep(100);
 	}
 
 exit:
-	//Disable I2C interrupt
-	hdmi_msk_reg(hdmi_dev, IH_MUTE_I2CM_STAT0, m_I2CM_DONE_MUTE | m_I2CM_ERR_MUTE, v_I2CM_DONE_MUTE(1) | v_I2CM_ERR_MUTE(1));
+	/* Disable I2C interrupt */
+	hdmi_msk_reg(hdmi_dev, IH_MUTE_I2CM_STAT0,
+		     m_I2CM_DONE_MUTE | m_I2CM_ERR_MUTE,
+		     v_I2CM_DONE_MUTE(1) | v_I2CM_ERR_MUTE(1));
 	hdmi_msk_reg(hdmi_dev, I2CM_INT, m_I2CM_DONE_MASK, v_I2CM_DONE_MASK(1));
-	hdmi_msk_reg(hdmi_dev, I2CM_CTLINT, m_I2CM_NACK_MASK | m_I2CM_ARB_MASK, v_I2CM_NACK_MASK(1) | v_I2CM_ARB_MASK(1));
+	hdmi_msk_reg(hdmi_dev, I2CM_CTLINT, m_I2CM_NACK_MASK | m_I2CM_ARB_MASK,
+		     v_I2CM_NACK_MASK(1) | v_I2CM_ARB_MASK(1));
 	return ret;
 }
 
 static int rk3288_hdmi_video_forceOutput(struct hdmi *hdmi_drv, char enable)
 {
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
-
-	hdmi_msk_reg(hdmi_dev, FC_DBGFORCE, m_FC_FORCEAUDIO, v_FC_FORCEAUDIO(0));
-
-	if(enable) {	/*Force output Blue*/
-		hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x00);	/*R*/
-		hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x00);	/*G*/
-		hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0xff);	/*B*/
-		hdmi_msk_reg(hdmi_dev, FC_DBGFORCE, m_FC_FORCEVIDEO, v_FC_FORCEVIDEO(1));
-	}
-	else {
-		hdmi_msk_reg(hdmi_dev, FC_DBGFORCE, m_FC_FORCEVIDEO, v_FC_FORCEVIDEO(0));
-		hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x00);	/*R*/
-		hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x00);	/*G*/
-		hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0x00);	/*B*/
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+
+	hdmi_msk_reg(hdmi_dev, FC_DBGFORCE, m_FC_FORCEAUDIO,
+		     v_FC_FORCEAUDIO(0));
+
+	if (enable) {		/* Force output Blue */
+		hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x00); /*R*/
+		hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x00); /*G*/
+		hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0xff); /*B*/
+		hdmi_msk_reg(hdmi_dev, FC_DBGFORCE, m_FC_FORCEVIDEO,
+				 v_FC_FORCEVIDEO(1));
+	} else {
+		hdmi_msk_reg(hdmi_dev, FC_DBGFORCE, m_FC_FORCEVIDEO,
+			     v_FC_FORCEVIDEO(0));
+		hdmi_writel(hdmi_dev, FC_DBGTMDS2, 0x00); /*R*/
+		hdmi_writel(hdmi_dev, FC_DBGTMDS1, 0x00); /*G*/
+		hdmi_writel(hdmi_dev, FC_DBGTMDS0, 0x00); /*B*/
 	}
 
 	return 0;
 }
 
-static int rk3288_hdmi_video_frameComposer(struct hdmi *hdmi_drv, struct hdmi_video_para *vpara)	//TODO Daisen wait to add support 3D
+/* TODO Daisen wait to add support 3D */
+static int rk3288_hdmi_video_frameComposer(struct hdmi *hdmi_drv,
+					   struct hdmi_video_para *vpara)
 {
 	int h_act = 0, v_act = 0;
 	int h_syncdelay = 0, v_syncdelay = 0;
@@ -233,16 +267,18 @@ static int rk3288_hdmi_video_frameComposer(struct hdmi *hdmi_drv, struct hdmi_vi
 	int hsync_pol = hdmi_drv->lcdc->cur_screen->pin_hsync;
 	int de_pol = (hdmi_drv->lcdc->cur_screen->pin_den == 0) ? 1 : 0;
 	struct fb_videomode *mode = NULL;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
 	mode = (struct fb_videomode *)hdmi_vic_to_videomode(vpara->vic);
-	if(mode == NULL) {
-		hdmi_err(hdmi_drv->dev, "[%s] not found vic %d\n", __FUNCTION__, vpara->vic);
+	if (mode == NULL) {
+		hdmi_err(hdmi_drv->dev, "[%s] not found vic %d\n", __func__,
+			 vpara->vic);
 		return -ENOENT;
 	}
 
 	hdmi_drv->pixclock = mode->pixclock;
-	switch(vpara->color_depth) {
+	switch (vpara->color_depth) {
 	case HDMI_COLOR_DEPTH_8BIT:
 		hdmi_drv->tmdsclk = mode->pixclock;
 		break;
@@ -260,11 +296,18 @@ static int rk3288_hdmi_video_frameComposer(struct hdmi *hdmi_drv, struct hdmi_vi
 		break;
 	}
 
+	/* cfg to bypass hdcp data encrypt */
 	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0, m_ENCRYPT_BYPASS | m_HDMI_DVI,
-		v_ENCRYPT_BYPASS(1) | v_HDMI_DVI(vpara->output_mode));	//cfg to bypass hdcp data encrypt
-	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF, m_FC_VSYNC_POL | m_FC_HSYNC_POL | m_FC_DE_POL | m_FC_HDMI_DVI | m_FC_INTERLACE_MODE,
-		v_FC_VSYNC_POL(vsync_pol) | v_FC_HSYNC_POL(hsync_pol) | v_FC_DE_POL(de_pol) | v_FC_HDMI_DVI(vpara->output_mode) | v_FC_INTERLACE_MODE(mode->vmode));
-	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF, m_FC_VBLANK, v_FC_VBLANK(mode->vmode));
+		     v_ENCRYPT_BYPASS(1) | v_HDMI_DVI(vpara->output_mode));
+	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF,
+		     m_FC_VSYNC_POL | m_FC_HSYNC_POL | m_FC_DE_POL |
+		     m_FC_HDMI_DVI | m_FC_INTERLACE_MODE,
+		     v_FC_VSYNC_POL(vsync_pol) | v_FC_HSYNC_POL(hsync_pol) |
+		     v_FC_DE_POL(de_pol) | v_FC_HDMI_DVI(vpara->
+							 output_mode) |
+		     v_FC_INTERLACE_MODE(mode->vmode));
+	hdmi_msk_reg(hdmi_dev, FC_INVIDCONF, m_FC_VBLANK,
+		     v_FC_VBLANK(mode->vmode));
 
 	h_act = mode->xres;
 	hdmi_writel(hdmi_dev, FC_INHACTIV1, v_FC_HACTIVE1(h_act >> 8));
@@ -282,7 +325,8 @@ static int rk3288_hdmi_video_frameComposer(struct hdmi *hdmi_drv, struct hdmi_vi
 	hdmi_writel(hdmi_dev, FC_INVBLANK, (v_blank & 0xff));
 
 	h_syncdelay = mode->right_margin;
-	hdmi_writel(hdmi_dev, FC_HSYNCINDELAY1, v_FC_HSYNCINDEAY1(h_syncdelay >> 8));
+	hdmi_writel(hdmi_dev, FC_HSYNCINDELAY1,
+		    v_FC_HSYNCINDEAY1(h_syncdelay >> 8));
 	hdmi_writel(hdmi_dev, FC_HSYNCINDELAY0, (h_syncdelay & 0xff));
 
 	v_syncdelay = mode->lower_margin;
@@ -295,46 +339,55 @@ static int rk3288_hdmi_video_frameComposer(struct hdmi *hdmi_drv, struct hdmi_vi
 	v_sync = mode->vsync_len;
 	hdmi_writel(hdmi_dev, FC_VSYNCINWIDTH, (v_sync & 0xff));
 
-	/*Set the control period minimum duration(min. of 12 pixel clock cycles, refer to HDMI 1.4b specification)*/
+	/* Set the control period minimum duration
+	* (min. of 12 pixel clock cycles, refer to HDMI 1.4b specification)
+	*/
 	hdmi_writel(hdmi_dev, FC_CTRLDUR, 12);
 	hdmi_writel(hdmi_dev, FC_EXCTRLDUR, 32);
 #if 0
-	if(hdmi_drv->tmdsclk > 340000000) {	//used for HDMI 2.0 TX	//TODO Daisen wait to modify HDCP KEEPOUT
-		hdmi_msk_reg(hdmi_dev, FC_INVIDCONF, m_FC_HDCP_KEEPOUT, v_FC_HDCP_KEEPOUT(1));
-		hdmi_msk_reg(hdmi_dev, FC_SCRAMBLER_CTRL, m_FC_SCRAMBLE_EN, v_FC_SCRAMBLE_EN(1));
+	/* used for HDMI 2.0 TX TODO Daisen wait to modify HDCP KEEPOUT */
+	if (hdmi_drv->tmdsclk > 340000000) {
+		hdmi_msk_reg(hdmi_dev, FC_INVIDCONF, m_FC_HDCP_KEEPOUT,
+			     v_FC_HDCP_KEEPOUT(1));
+		hdmi_msk_reg(hdmi_dev, FC_SCRAMBLER_CTRL, m_FC_SCRAMBLE_EN,
+			     v_FC_SCRAMBLE_EN(1));
 	}
 
 	/* spacing < 256^2 * config / tmdsClock, spacing <= 50ms
 	 * worst case: tmdsClock == 25MHz => config <= 19
-	 */
+	*/
 	hdmi_writel(hdmi_dev, FC_EXCTRLSPAC, 1);
 
-	/*Set PreambleFilter*/
+	/* Set PreambleFilter */
 	for (i = 0; i < 3; i++) {
 		value = (i + 1) * 11;
-		if (i == 0)		/*channel 0*/
+		if (i == 0)		/* channel 0 */
 			hdmi_writel(hdmi_dev, FC_CH0PREAM, value);
-		else if (i == 1)	/*channel 1*/
+		else if (i == 1)	/* channel 1 */
 			hdmi_writel(hdmi_dev, FC_CH1PREAM, value & 0x3f);
-		else if (i == 2)	/*channel 2*/
+		else if (i == 2)	/* channel 2 */
 			hdmi_writel(hdmi_dev, FC_CH2PREAM, value & 0x3f);
 	}
 #endif
-	/*Set PixelRepetition:No pixel repetition*/
-	hdmi_writel(hdmi_dev, FC_PRCONF, v_FC_PR_FACTOR(vpara->pixel_repet + 1));
+	/* Set PixelRepetition:No pixel repetition */
+	hdmi_writel(hdmi_dev, FC_PRCONF,
+		    v_FC_PR_FACTOR(vpara->pixel_repet + 1));
 
 	return 0;
 }
 
-static int rk3288_hdmi_video_packetizer(struct hdmi *hdmi_drv, struct hdmi_video_para *vpara)
+static int rk3288_hdmi_video_packetizer(struct hdmi *hdmi_drv,
+					struct hdmi_video_para *vpara)
 {
 	unsigned char color_depth = 0;
 	unsigned char output_select = 0;
 	unsigned char remap_size = 0;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
-	if (vpara->output_color == VIDEO_OUTPUT_RGB444 || vpara->output_color == VIDEO_OUTPUT_YCBCR444
-							|| vpara->output_color == VIDEO_OUTPUT_YCBCR420) {
+	if (vpara->output_color == VIDEO_OUTPUT_RGB444
+	    || vpara->output_color == VIDEO_OUTPUT_YCBCR444
+	    || vpara->output_color == VIDEO_OUTPUT_YCBCR420) {
 
 		switch (vpara->color_depth) {
 		case HDMI_COLOR_DEPTH_8BIT:
@@ -359,8 +412,9 @@ static int rk3288_hdmi_video_packetizer(struct hdmi *hdmi_drv, struct hdmi_video
 			break;
 		}
 
-		/*Config Color Depth*/
-		hdmi_msk_reg(hdmi_dev, VP_PR_CD, m_COLOR_DEPTH, v_COLOR_DEPTH(color_depth));
+		/* Config Color Depth */
+		hdmi_msk_reg(hdmi_dev, VP_PR_CD, m_COLOR_DEPTH,
+			     v_COLOR_DEPTH(color_depth));
 	} else if (vpara->output_color == VIDEO_OUTPUT_YCBCR422) {
 
 		switch (vpara->color_depth) {
@@ -379,47 +433,65 @@ static int rk3288_hdmi_video_packetizer(struct hdmi *hdmi_drv, struct hdmi_video
 		}
 
 		output_select = OUT_FROM_YCC422_REMAP;
-		/*Config remap size for the different color Depth*/
-		hdmi_msk_reg(hdmi_dev, VP_REMAP, m_YCC422_SIZE, v_YCC422_SIZE(remap_size));
+		/* Config remap size for the different color Depth */
+		hdmi_msk_reg(hdmi_dev, VP_REMAP, m_YCC422_SIZE,
+			     v_YCC422_SIZE(remap_size));
 	} else {
-		hdmi_err(hdmi_drv->dev, "invalid output color type: %d", vpara->output_color);
+		hdmi_err(hdmi_drv->dev, "invalid output color type: %d",
+			 vpara->output_color);
 		return -1;
 	}
 
-	/*Config pixel repettion*/
-	hdmi_msk_reg(hdmi_dev, VP_PR_CD, m_DESIRED_PR_FACTOR, v_DESIRED_PR_FACTOR(vpara->pixel_repet));
+	/* Config pixel repettion */
+	hdmi_msk_reg(hdmi_dev, VP_PR_CD, m_DESIRED_PR_FACTOR,
+		     v_DESIRED_PR_FACTOR(vpara->pixel_repet));
 	if (vpara->pixel_repet > 0)
-		hdmi_msk_reg(hdmi_dev, VP_CONF, m_PIXEL_REPET_EN | m_BYPASS_SEL, v_PIXEL_REPET_EN(1) | v_BYPASS_SEL(0));
+		hdmi_msk_reg(hdmi_dev, VP_CONF, m_PIXEL_REPET_EN | m_BYPASS_SEL,
+			     v_PIXEL_REPET_EN(1) | v_BYPASS_SEL(0));
 	else
-		hdmi_msk_reg(hdmi_dev, VP_CONF, m_PIXEL_REPET_EN | m_BYPASS_SEL, v_PIXEL_REPET_EN(0) | v_BYPASS_SEL(1));
-
-	/*config output select*/
-	if (output_select == OUT_FROM_PIXEL_PACKING) { /* pixel packing */
-		hdmi_msk_reg(hdmi_dev, VP_CONF, m_BYPASS_EN | m_PIXEL_PACK_EN | m_YCC422_EN | m_OUTPUT_SEL,
-			v_BYPASS_EN(0) | v_PIXEL_PACK_EN(1) | v_YCC422_EN(0) | v_OUTPUT_SEL(output_select));
-	} else if (output_select == OUT_FROM_YCC422_REMAP) { /* YCC422 */
-		hdmi_msk_reg(hdmi_dev, VP_CONF, m_BYPASS_EN | m_PIXEL_PACK_EN | m_YCC422_EN | m_OUTPUT_SEL,
-			v_BYPASS_EN(0) | v_PIXEL_PACK_EN(0) | v_YCC422_EN(1) | v_OUTPUT_SEL(output_select));
-	} else if (output_select == OUT_FROM_8BIT_BYPASS || output_select == 3) { /* bypass */
-		hdmi_msk_reg(hdmi_dev, VP_CONF, m_BYPASS_EN | m_PIXEL_PACK_EN | m_YCC422_EN | m_OUTPUT_SEL,
-			v_BYPASS_EN(1) | v_PIXEL_PACK_EN(0) | v_YCC422_EN(0) | v_OUTPUT_SEL(output_select));
+		hdmi_msk_reg(hdmi_dev, VP_CONF, m_PIXEL_REPET_EN | m_BYPASS_SEL,
+			     v_PIXEL_REPET_EN(0) | v_BYPASS_SEL(1));
+
+	/* config output select */
+	if (output_select == OUT_FROM_PIXEL_PACKING) {	/* pixel packing */
+		hdmi_msk_reg(hdmi_dev, VP_CONF,
+			     m_BYPASS_EN | m_PIXEL_PACK_EN | m_YCC422_EN |
+			     m_OUTPUT_SEL,
+			     v_BYPASS_EN(0) | v_PIXEL_PACK_EN(1) |
+			     v_YCC422_EN(0) | v_OUTPUT_SEL(output_select));
+	} else if (output_select == OUT_FROM_YCC422_REMAP) {	/* YCC422 */
+		hdmi_msk_reg(hdmi_dev, VP_CONF,
+			     m_BYPASS_EN | m_PIXEL_PACK_EN | m_YCC422_EN |
+			     m_OUTPUT_SEL,
+			     v_BYPASS_EN(0) | v_PIXEL_PACK_EN(0) |
+			     v_YCC422_EN(1) | v_OUTPUT_SEL(output_select));
+	} else if (output_select == OUT_FROM_8BIT_BYPASS || output_select == 3) {
+		/* bypass */
+		hdmi_msk_reg(hdmi_dev, VP_CONF,
+			     m_BYPASS_EN | m_PIXEL_PACK_EN | m_YCC422_EN |
+			     m_OUTPUT_SEL,
+			     v_BYPASS_EN(1) | v_PIXEL_PACK_EN(0) |
+			     v_YCC422_EN(0) | v_OUTPUT_SEL(output_select));
 	}
-
 #if defined(HDMI_VIDEO_STUFFING)
-	/* YCC422 and pixel packing stuffing*/
+	/* YCC422 and pixel packing stuffing */
 	hdmi_msk_reg(hdmi_dev, VP_STUFF, m_PR_STUFFING, v_PR_STUFFING(1));
-	hdmi_msk_reg(hdmi_dev, VP_STUFF, m_YCC422_STUFFING | m_PP_STUFFING, v_YCC422_STUFFING(1) | v_PP_STUFFING(1));
+	hdmi_msk_reg(hdmi_dev, VP_STUFF, m_YCC422_STUFFING | m_PP_STUFFING,
+		     v_YCC422_STUFFING(1) | v_PP_STUFFING(1));
 #endif
 	return 0;
 }
 
-int rk3288_hdmi_video_sampler(struct hdmi *hdmi_drv, struct hdmi_video_para *vpara)
+int rk3288_hdmi_video_sampler(struct hdmi *hdmi_drv,
+			      struct hdmi_video_para *vpara)
 {
 	int map_code = 0;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
-	if (vpara->input_color == VIDEO_INPUT_COLOR_RGB || vpara->input_color == VIDEO_INPUT_COLOR_YCBCR444
-							|| vpara->input_color == VIDEO_INPUT_COLOR_YCBCR420) {
+	if (vpara->input_color == VIDEO_INPUT_COLOR_RGB
+	    || vpara->input_color == VIDEO_INPUT_COLOR_YCBCR444
+	    || vpara->input_color == VIDEO_INPUT_COLOR_YCBCR420) {
 
 		switch (vpara->color_depth) {
 		case HDMI_COLOR_DEPTH_8BIT:
@@ -438,7 +510,8 @@ int rk3288_hdmi_video_sampler(struct hdmi *hdmi_drv, struct hdmi_video_para *vpa
 			map_code = VIDEO_RGB444_8BIT;
 			break;
 		}
-		map_code += (vpara->input_color == VIDEO_INPUT_COLOR_YCBCR444) ? 8 : 0;
+		map_code +=
+		    (vpara->input_color == VIDEO_INPUT_COLOR_YCBCR444) ? 8 : 0;
 	} else if (vpara->input_color == VIDEO_INPUT_COLOR_YCBCR422) {
 		/* YCC422 mapping is discontinued - only map 1 is supported */
 		switch (vpara->color_depth) {
@@ -456,59 +529,71 @@ int rk3288_hdmi_video_sampler(struct hdmi *hdmi_drv, struct hdmi_video_para *vpa
 			break;
 		}
 	} else {
-		hdmi_err(hdmi_drv->dev, "invalid input color type: %d", vpara->input_color);
+		hdmi_err(hdmi_drv->dev, "invalid input color type: %d",
+			 vpara->input_color);
 		return -1;
 	}
 
-	//Set Data enable signal from external and set video sample input mapping
-	hdmi_msk_reg(hdmi_dev, TX_INVID0, m_INTERNAL_DE_GEN | m_VIDEO_MAPPING, v_INTERNAL_DE_GEN(0) | v_VIDEO_MAPPING(map_code));
+	/* Set Data enable signal from external
+	* and set video sample input mapping
+	*/
+	hdmi_msk_reg(hdmi_dev, TX_INVID0, m_INTERNAL_DE_GEN | m_VIDEO_MAPPING,
+		     v_INTERNAL_DE_GEN(0) | v_VIDEO_MAPPING(map_code));
 
 #if defined(HDMI_VIDEO_STUFFING)
 	hdmi_writel(hdmi_dev, TX_GYDATA0, 0x00);
 	hdmi_writel(hdmi_dev, TX_GYDATA1, 0x00);
-	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING, m_GYDATA_STUFF, v_GYDATA_STUFF(1));
+	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING, m_GYDATA_STUFF,
+		     v_GYDATA_STUFF(1));
 	hdmi_writel(hdmi_dev, TX_RCRDATA0, 0x00);
 	hdmi_writel(hdmi_dev, TX_RCRDATA1, 0x00);
-	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING, m_RCRDATA_STUFF, v_RCRDATA_STUFF(1));
+	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING, m_RCRDATA_STUFF,
+		     v_RCRDATA_STUFF(1));
 	hdmi_writel(hdmi_dev, TX_BCBDATA0, 0x00);
 	hdmi_writel(hdmi_dev, TX_BCBDATA1, 0x00);
-	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING, m_BCBDATA_STUFF, v_BCBDATA_STUFF(1));
+	hdmi_msk_reg(hdmi_dev, TX_INSTUFFING, m_BCBDATA_STUFF,
+		     v_BCBDATA_STUFF(1));
 #endif
 	return 0;
 }
 
-static int rk3288_hdmi_read_phy(struct rk3288_hdmi_device *hdmi_dev, int reg_addr)
+static int rk3288_hdmi_read_phy(struct rk3288_hdmi_device *hdmi_dev,
+				int reg_addr)
 {
 	int trytime = 2, i = 0, op_status = 0;
 	int val = 0;
 
-	while(trytime--) {
+	while (trytime--) {
 		hdmi_writel(hdmi_dev, PHY_I2CM_ADDRESS, reg_addr);
 		hdmi_writel(hdmi_dev, PHY_I2CM_DATAI_1, 0x00);
 		hdmi_writel(hdmi_dev, PHY_I2CM_DATAI_0, 0x00);
 		hdmi_writel(hdmi_dev, PHY_I2CM_OPERATION, m_PHY_I2CM_READ);
 
 		i = 20;
-		while(i--) {
+		while (i--) {
 			msleep(1);
 			op_status = hdmi_readl(hdmi_dev, IH_I2CMPHY_STAT0);
-			if(op_status)
-				hdmi_writel(hdmi_dev, IH_I2CMPHY_STAT0, op_status);
+			if (op_status)
+				hdmi_writel(hdmi_dev, IH_I2CMPHY_STAT0,
+					    op_status);
 
-			if(op_status & (m_I2CMPHY_DONE | m_I2CMPHY_ERR)) {
+			if (op_status & (m_I2CMPHY_DONE | m_I2CMPHY_ERR)) {
 				break;
 			}
 			msleep(4);
 		}
 
-		if(op_status & m_I2CMPHY_DONE) {
-			val = (hdmi_readl(hdmi_dev, PHY_I2CM_DATAI_1) & 0xff) << 8;
+		if (op_status & m_I2CMPHY_DONE) {
+			val = hdmi_readl(hdmi_dev, PHY_I2CM_DATAI_1);
+			val = (val & 0xff) << 8;
 			val += (hdmi_readl(hdmi_dev, PHY_I2CM_DATAI_0) & 0xff);
-			hdmi_dbg(hdmi_dev->dev, "phy_reg0x%02x: 0x%04x", reg_addr, val);
+			hdmi_dbg(hdmi_dev->dev, "phy_reg0x%02x: 0x%04x",
+				 reg_addr, val);
 			return val;
-		}
-		else {
-			hdmi_err(hdmi_dev->dev, "[%s] operation error,trytime=%d\n", __FUNCTION__,trytime);
+		} else {
+			hdmi_err(hdmi_dev->dev,
+				 "[%s] operation error,trytime=%d\n",
+				 __func__, trytime);
 		}
 		msleep(100);
 	}
@@ -516,34 +601,37 @@ static int rk3288_hdmi_read_phy(struct rk3288_hdmi_device *hdmi_dev, int reg_add
 	return -1;
 }
 
-static int rk3288_hdmi_write_phy(struct rk3288_hdmi_device *hdmi_dev, int reg_addr, int val)
+static int rk3288_hdmi_write_phy(struct rk3288_hdmi_device *hdmi_dev,
+				 int reg_addr, int val)
 {
 	int trytime = 2, i = 0, op_status = 0;
 
-	while(trytime--) {
+	while (trytime--) {
 		hdmi_writel(hdmi_dev, PHY_I2CM_ADDRESS, reg_addr);
 		hdmi_writel(hdmi_dev, PHY_I2CM_DATAO_1, (val >> 8) & 0xff);
 		hdmi_writel(hdmi_dev, PHY_I2CM_DATAO_0, val & 0xff);
 		hdmi_writel(hdmi_dev, PHY_I2CM_OPERATION, m_PHY_I2CM_WRITE);
 
 		i = 20;
-		while(i--) {
+		while (i--) {
 			msleep(1);
 			op_status = hdmi_readl(hdmi_dev, IH_I2CMPHY_STAT0);
-			if(op_status)
-				hdmi_writel(hdmi_dev, IH_I2CMPHY_STAT0, op_status);
+			if (op_status)
+				hdmi_writel(hdmi_dev, IH_I2CMPHY_STAT0,
+					    op_status);
 
-			if(op_status & (m_I2CMPHY_DONE | m_I2CMPHY_ERR)) {
+			if (op_status & (m_I2CMPHY_DONE | m_I2CMPHY_ERR)) {
 				break;
 			}
 			msleep(4);
 		}
 
-		if(op_status & m_I2CMPHY_DONE) {
+		if (op_status & m_I2CMPHY_DONE) {
 			return 0;
-		}
-		else {
-			hdmi_err(hdmi_dev->dev, "[%s] operation error,trytime=%d\n", __FUNCTION__, trytime);
+		} else {
+			hdmi_err(hdmi_dev->dev,
+				 "[%s] operation error,trytime=%d\n",
+				 __func__, trytime);
 		}
 		msleep(100);
 	}
@@ -551,362 +639,412 @@ static int rk3288_hdmi_write_phy(struct rk3288_hdmi_device *hdmi_dev, int reg_ad
 	return -1;
 }
 
-int rk3288_hdmi_config_phy(struct hdmi *hdmi_drv, unsigned char pixel_repet, unsigned char color_depth)
+int rk3288_hdmi_config_phy(struct hdmi *hdmi_drv, unsigned char pixel_repet,
+			   unsigned char color_depth)
 {
 	int stat = 0, i = 0;
 	const struct phy_mpll_config_tab *phy_mpll = NULL;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
-	hdmi_msk_reg(hdmi_dev, PHY_I2CM_DIV, m_PHY_I2CM_FAST_STD, v_PHY_I2CM_FAST_STD(0));
+	hdmi_msk_reg(hdmi_dev, PHY_I2CM_DIV, m_PHY_I2CM_FAST_STD,
+		     v_PHY_I2CM_FAST_STD(0));
 
-	//power on PHY
+	/* power on PHY */
 	hdmi_writel(hdmi_dev, PHY_CONF0, 0x3a);
-	//hdmi_msk_reg(hdmi_dev, PHY_CONF0, m_PDDQ_SIG | m_TXPWRON_SIG, v_PDDQ_SIG(1) | v_TXPWRON_SIG(0));
+	/*
+	hdmi_msk_reg(hdmi_dev, PHY_CONF0, m_PDDQ_SIG | m_TXPWRON_SIG,
+		     v_PDDQ_SIG(1) | v_TXPWRON_SIG(0));
+	*/
 
-	//reset PHY
+	/* reset PHY */
 	hdmi_writel(hdmi_dev, MC_PHYRSTZ, v_PHY_RSTZ(1));
 	msleep(5);
 	hdmi_writel(hdmi_dev, MC_PHYRSTZ, v_PHY_RSTZ(0));
 
-	//Set slave address as PHY GEN2 address
+	/* Set slave address as PHY GEN2 address */
 	hdmi_writel(hdmi_dev, PHY_I2CM_SLAVE, PHY_GEN2_ADDR);
 
-	//config the required PHY I2C register
-	phy_mpll = get_phy_mpll_tab(hdmi_drv->pixclock, pixel_repet, color_depth);
-	if(phy_mpll) {
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_OPMODE_PLLCFG, v_PREP_DIV(phy_mpll->prep_div) | v_TMDS_CNTRL(phy_mpll->tmdsmhl_cntrl) | v_OPMODE(phy_mpll->opmode) |
-			v_FBDIV2_CNTRL(phy_mpll->fbdiv2_cntrl) | v_FBDIV1_CNTRL(phy_mpll->fbdiv1_cntrl) | v_REF_CNTRL(phy_mpll->ref_cntrl) | v_MPLL_N_CNTRL(phy_mpll->n_cntrl));
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_PLLCURRCTRL, v_MPLL_PROP_CNTRL(phy_mpll->prop_cntrl) | v_MPLL_INT_CNTRL(phy_mpll->int_cntrl));
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_PLLGMPCTRL, v_MPLL_GMP_CNTRL(phy_mpll->gmp_cntrl));
-	}
-	if(hdmi_drv->pixclock <= 74250000) {
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL, v_OVERRIDE(1) | v_SLOPEBOOST(0)
-			| v_TX_SYMON(1) | v_TX_TRAON(0) | v_TX_TRBON(0) | v_CLK_SYMON(1));
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_TERM_RESIS, v_TX_TERM(R100_Ohms));
+	/* config the required PHY I2C register */
+	phy_mpll =
+	    get_phy_mpll_tab(hdmi_drv->pixclock, pixel_repet, color_depth);
+	if (phy_mpll) {
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_OPMODE_PLLCFG,
+				      v_PREP_DIV(phy_mpll->prep_div) |
+				      v_TMDS_CNTRL(phy_mpll->tmdsmhl_cntrl) |
+				      v_OPMODE(phy_mpll->opmode) |
+				      v_FBDIV2_CNTRL(phy_mpll->fbdiv2_cntrl) |
+				      v_FBDIV1_CNTRL(phy_mpll->fbdiv1_cntrl) |
+				      v_REF_CNTRL(phy_mpll->ref_cntrl) |
+				      v_MPLL_N_CNTRL(phy_mpll->n_cntrl));
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_PLLCURRCTRL,
+				      v_MPLL_PROP_CNTRL(phy_mpll->prop_cntrl) |
+				      v_MPLL_INT_CNTRL(phy_mpll->int_cntrl));
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_PLLGMPCTRL,
+				      v_MPLL_GMP_CNTRL(phy_mpll->gmp_cntrl));
 	}
-	else if(hdmi_drv->pixclock == 148500000) {
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL, v_OVERRIDE(1) | v_SLOPEBOOST(3)
-			| v_TX_SYMON(1) | v_TX_TRAON(0) | v_TX_TRBON(0) | v_CLK_SYMON(1));
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_TERM_RESIS, v_TX_TERM(R100_Ohms));
-	}
-	else if(hdmi_drv->pixclock == 297000000) {
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL, v_OVERRIDE(1) | v_SLOPEBOOST(2)
-			| v_TX_SYMON(1) | v_TX_TRAON(0) | v_TX_TRBON(0) | v_CLK_SYMON(1));
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_TERM_RESIS, v_TX_TERM(R100_Ohms));
-	}
-	else if(hdmi_drv->pixclock > 297000000) {
-		//TODO Daisen wait to add and modify
-		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_TERM_RESIS, v_TX_TERM(R13333_Ohms));
+	if (hdmi_drv->pixclock <= 74250000) {
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL,
+				      v_OVERRIDE(1) | v_SLOPEBOOST(0)
+				      | v_TX_SYMON(1) | v_TX_TRAON(0) |
+				      v_TX_TRBON(0) | v_CLK_SYMON(1));
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_TERM_RESIS,
+				      v_TX_TERM(R100_Ohms));
+	} else if (hdmi_drv->pixclock == 148500000) {
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL,
+				      v_OVERRIDE(1) | v_SLOPEBOOST(3)
+				      | v_TX_SYMON(1) | v_TX_TRAON(0) |
+				      v_TX_TRBON(0) | v_CLK_SYMON(1));
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_TERM_RESIS,
+				      v_TX_TERM(R100_Ohms));
+	} else if (hdmi_drv->pixclock == 297000000) {
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_CLKSYMCTRL,
+				      v_OVERRIDE(1) | v_SLOPEBOOST(2)
+				      | v_TX_SYMON(1) | v_TX_TRAON(0) |
+				      v_TX_TRBON(0) | v_CLK_SYMON(1));
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_TERM_RESIS,
+				      v_TX_TERM(R100_Ohms));
+	} else if (hdmi_drv->pixclock > 297000000) {
+		/* TODO Daisen wait to add and modify */
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_TERM_RESIS,
+				      v_TX_TERM(R13333_Ohms));
 	}
 
-	if(hdmi_drv->pixclock < 297000000)
-                rk3288_hdmi_write_phy(hdmi_dev, PHYTX_VLEVCTRL, v_SUP_TXLVL(20) | v_SUP_CLKLVL(19));
-        else
-                rk3288_hdmi_write_phy(hdmi_dev, PHYTX_VLEVCTRL, v_SUP_TXLVL(17) | v_SUP_CLKLVL(16));
+	if (hdmi_drv->pixclock < 297000000)
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_VLEVCTRL,
+				      v_SUP_TXLVL(20) | v_SUP_CLKLVL(19));
+	else
+		rk3288_hdmi_write_phy(hdmi_dev, PHYTX_VLEVCTRL,
+				      v_SUP_TXLVL(17) | v_SUP_CLKLVL(16));
 
-	//power on PHY
+	/* power on PHY */
 	hdmi_writel(hdmi_dev, PHY_CONF0, 0x6e);
-	//hdmi_msk_reg(hdmi_dev, PHY_CONF0, m_PDDQ_SIG | m_TXPWRON_SIG | m_ENHPD_RXSENSE_SIG,
-		//v_PDDQ_SIG(0) | v_TXPWRON_SIG(1) | v_ENHPD_RXSENSE_SIG(1));
-
-	//check if the PHY PLL is locked
-	#define PHY_TIMEOUT	10000
-	while(i++ < PHY_TIMEOUT) {
+	/*
+	hdmi_msk_reg(hdmi_dev, PHY_CONF0,
+		     m_PDDQ_SIG | m_TXPWRON_SIG | m_ENHPD_RXSENSE_SIG,
+		     v_PDDQ_SIG(0) | v_TXPWRON_SIG(1) | v_ENHPD_RXSENSE_SIG(1));
+	*/
+
+	/* check if the PHY PLL is locked */
+#define PHY_TIMEOUT	10000
+	while (i++ < PHY_TIMEOUT) {
 		if ((i % 100) == 0) {
 			stat = hdmi_readl(hdmi_dev, PHY_STAT0);
-			if(stat & m_PHY_LOCK) {
-				//hdmi_writel(hdmi_dev, PHY_STAT0, v_PHY_LOCK(1));
+			if (stat & m_PHY_LOCK) {
 				break;
 			}
 		}
 	}
-	if((stat & m_PHY_LOCK) == 0) {
+	if ((stat & m_PHY_LOCK) == 0) {
 		stat = hdmi_readl(hdmi_dev, MC_LOCKONCLOCK);
-		hdmi_err(hdmi_dev->dev, "PHY PLL not locked: PCLK_ON=%d,TMDSCLK_ON=%d\n", (stat & m_PCLK_ON) >> 6, (stat & m_TMDSCLK_ON) >> 5);
+		hdmi_err(hdmi_dev->dev,
+			 "PHY PLL not locked: PCLK_ON=%d,TMDSCLK_ON=%d\n",
+			 (stat & m_PCLK_ON) >> 6, (stat & m_TMDSCLK_ON) >> 5);
 		return -1;
 	}
 
 	return 0;
 }
 
-int rk3288_hdmi_config_vsi(struct hdmi *hdmi_drv, unsigned char vic_3d, unsigned char format, int auto_send)
+int rk3288_hdmi_config_vsi(struct hdmi *hdmi_drv, unsigned char vic_3d,
+			   unsigned char format, int auto_send)
 {
-        int i = 0;
-	unsigned char data[3] = {0};
+	int i = 0;
+	unsigned char data[3] = { 0 };
 	int id = 0x000c03;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
-        hdmi_dbg(hdmi_drv->dev, "[%s] vic %d format %d.\n", __FUNCTION__, vic_3d, format);
-        hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_VSD_AUTO, v_VSD_AUTO(0));
+	hdmi_dbg(hdmi_drv->dev, "[%s] vic %d format %d.\n", __func__,
+		 vic_3d, format);
+	hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_VSD_AUTO, v_VSD_AUTO(0));
 	hdmi_writel(hdmi_dev, FC_VSDIEEEID0, id & 0xff);
 	hdmi_writel(hdmi_dev, FC_VSDIEEEID1, (id >> 8) & 0xff);
 	hdmi_writel(hdmi_dev, FC_VSDIEEEID2, (id >> 16) & 0xff);
 
-	data[0] = format << 5;	//PB4 --HDMI_Video_Format
-	switch(format)
-        {
-                case HDMI_VIDEO_FORMAT_4Kx2K:
-                        data[1] = vic_3d;	//PB5--HDMI_VIC
-                        data[2] = 0;
-                        break;
-                case HDMI_VIDEO_FORMAT_3D:
-			data[1] = vic_3d << 4;	//PB5--3D_Structure field
-			data[2] = 0;		//PB6--3D_Ext_Data field
-			break;
-		default:
-			data[1] = 0;
-			data[2] = 0;
-			break;
-        }
+	data[0] = format << 5;		/* PB4 --HDMI_Video_Format */
+	switch (format) {
+	case HDMI_VIDEO_FORMAT_4Kx2K:
+		data[1] = vic_3d;	/* PB5--HDMI_VIC */
+		data[2] = 0;
+		break;
+	case HDMI_VIDEO_FORMAT_3D:
+		data[1] = vic_3d << 4;	/* PB5--3D_Structure field */
+		data[2] = 0;		/* PB6--3D_Ext_Data field */
+		break;
+	default:
+		data[1] = 0;
+		data[2] = 0;
+		break;
+	}
 
-	for (i = 0; i < 3; i++) {
+	for (i = 0; i < 3; i++)
 		hdmi_writel(hdmi_dev, FC_VSDPAYLOAD0 + i, data[i]);
-	}
 
 	if (auto_send) {
-		hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_VSD_AUTO, v_VSD_AUTO(auto_send));
-	}
-	else {
+		hdmi_msk_reg(hdmi_dev, FC_DATAUTO0, m_VSD_AUTO,
+			     v_VSD_AUTO(auto_send));
+	} else {
 		hdmi_msk_reg(hdmi_dev, FC_DATMAN, m_VSD_MAN, v_VSD_MAN(1));
 	}
 
 	return 0;
 }
 
-static void rk3288_hdmi_config_avi(struct hdmi *hdmi_drv, unsigned char vic, struct hdmi_video_para *vpara)
+static void rk3288_hdmi_config_avi(struct hdmi *hdmi_drv, unsigned char vic,
+				   struct hdmi_video_para *vpara)
 {
 	unsigned char colorimetry, ext_colorimetry, aspect_ratio, y1y0;
 	unsigned char rgb_quan_range = AVI_QUANTIZATION_RANGE_DEFAULT;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
-	//Set AVI infoFrame Data byte1
-	if(vpara->output_color == VIDEO_OUTPUT_YCBCR444)
+	/* Set AVI infoFrame Data byte1 */
+	if (vpara->output_color == VIDEO_OUTPUT_YCBCR444)
 		y1y0 = AVI_COLOR_MODE_YCBCR444;
-	else if(vpara->output_color == VIDEO_OUTPUT_YCBCR422)
+	else if (vpara->output_color == VIDEO_OUTPUT_YCBCR422)
 		y1y0 = AVI_COLOR_MODE_YCBCR422;
-	else if(vpara->output_color == VIDEO_OUTPUT_YCBCR420)
+	else if (vpara->output_color == VIDEO_OUTPUT_YCBCR420)
 		y1y0 = AVI_COLOR_MODE_YCBCR420;
 	else
 		y1y0 = AVI_COLOR_MODE_RGB;
 
-	hdmi_msk_reg(hdmi_dev, FC_AVICONF0, m_FC_ACTIV_FORMAT | m_FC_RGC_YCC, v_FC_RGC_YCC(y1y0) | v_FC_ACTIV_FORMAT(1));
-
-	//Set AVI infoFrame Data byte2
-	switch(vic)
-	{
-		case HDMI_720x480i_60Hz_4_3:
-		case HDMI_720x576i_50Hz_4_3:
-		case HDMI_720x480p_60Hz_4_3:
-		case HDMI_720x576p_50Hz_4_3:
-			aspect_ratio = AVI_CODED_FRAME_ASPECT_4_3;
-			colorimetry = AVI_COLORIMETRY_SMPTE_170M;
-			break;
-		case HDMI_720x480i_60Hz_16_9:
-		case HDMI_720x576i_50Hz_16_9:
-		case HDMI_720x480p_60Hz_16_9:
-		case HDMI_720x576p_50Hz_16_9:
-			aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
-			colorimetry = AVI_COLORIMETRY_SMPTE_170M;
-			break;
-		default:
-			aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
-			colorimetry = AVI_COLORIMETRY_ITU709;
+	hdmi_msk_reg(hdmi_dev, FC_AVICONF0, m_FC_ACTIV_FORMAT | m_FC_RGC_YCC,
+		     v_FC_RGC_YCC(y1y0) | v_FC_ACTIV_FORMAT(1));
+
+	/* Set AVI infoFrame Data byte2 */
+	switch (vic) {
+	case HDMI_720x480i_60Hz_4_3:
+	case HDMI_720x576i_50Hz_4_3:
+	case HDMI_720x480p_60Hz_4_3:
+	case HDMI_720x576p_50Hz_4_3:
+		aspect_ratio = AVI_CODED_FRAME_ASPECT_4_3;
+		colorimetry = AVI_COLORIMETRY_SMPTE_170M;
+		break;
+	case HDMI_720x480i_60Hz_16_9:
+	case HDMI_720x576i_50Hz_16_9:
+	case HDMI_720x480p_60Hz_16_9:
+	case HDMI_720x576p_50Hz_16_9:
+		aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
+		colorimetry = AVI_COLORIMETRY_SMPTE_170M;
+		break;
+	default:
+		aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
+		colorimetry = AVI_COLORIMETRY_ITU709;
 	}
 
-	if(vpara->color_depth > HDMI_COLOR_DEPTH_8BIT) {
+	if (vpara->color_depth > HDMI_COLOR_DEPTH_8BIT) {
 		colorimetry = AVI_COLORIMETRY_EXTENDED;
 		ext_colorimetry = 6;
-	}
-	else if(vpara->output_color == VIDEO_OUTPUT_RGB444) {
+	} else if (vpara->output_color == VIDEO_OUTPUT_RGB444) {
 		colorimetry = AVI_COLORIMETRY_NO_DATA;
 		ext_colorimetry = 0;
 	}
 
-	hdmi_writel(hdmi_dev, FC_AVICONF1, v_FC_COLORIMETRY(colorimetry) | v_FC_PIC_ASPEC_RATIO(aspect_ratio) | v_FC_ACT_ASPEC_RATIO(ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME));
+	hdmi_writel(hdmi_dev, FC_AVICONF1,
+		    v_FC_COLORIMETRY(colorimetry) |
+		    v_FC_PIC_ASPEC_RATIO(aspect_ratio) |
+		    v_FC_ACT_ASPEC_RATIO
+		    (ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME));
 
-	//Set AVI infoFrame Data byte3
-	hdmi_msk_reg(hdmi_dev, FC_AVICONF2, m_FC_EXT_COLORIMETRY | m_FC_QUAN_RANGE,
-		v_FC_EXT_COLORIMETRY(ext_colorimetry) | v_FC_QUAN_RANGE(rgb_quan_range));
+	/* Set AVI infoFrame Data byte3 */
+	hdmi_msk_reg(hdmi_dev, FC_AVICONF2,
+		     m_FC_EXT_COLORIMETRY | m_FC_QUAN_RANGE,
+		     v_FC_EXT_COLORIMETRY(ext_colorimetry) |
+		     v_FC_QUAN_RANGE(rgb_quan_range));
 
-	//Set AVI infoFrame Data byte4
+	/* Set AVI infoFrame Data byte4 */
 	hdmi_writel(hdmi_dev, FC_AVIVID, (vic & 0xff));
 
-	//Set AVI infoFrame Data byte5
-	hdmi_msk_reg(hdmi_dev, FC_AVICONF3, m_FC_YQ | m_FC_CN, v_FC_YQ(YQ_LIMITED_RANGE) | v_FC_CN(CN_GRAPHICS));
+	/* Set AVI infoFrame Data byte5 */
+	hdmi_msk_reg(hdmi_dev, FC_AVICONF3, m_FC_YQ | m_FC_CN,
+		     v_FC_YQ(YQ_LIMITED_RANGE) | v_FC_CN(CN_GRAPHICS));
 
 }
 
-
 static const char coeff_csc[][24] = {
-		//   G		R	    B		Bias
-		//   A1    |	A2     |    A3     |	A4    |
-		//   B1    |    B2     |    B3     |    B4    |
-		//   C1    |    C2     |    C3     |    C4    |
-	{	//CSC_RGB_0_255_TO_RGB_16_235_8BIT
-		0x1b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,		//G
-		0x00, 0x00, 0x1b, 0x80, 0x00, 0x00, 0x00, 0x20,		//R
-		0x00, 0x00, 0x00, 0x00, 0x1b, 0x80, 0x00, 0x20,		//B
+	/*   G          R           B           Bias	*/
+	/*   A1    |    A2     |    A3     |    A4    |	*/
+	/*   B1    |    B2     |    B3     |    B4    |	*/
+	/*   C1    |    C2     |    C3     |    C4    |	*/
+	{	/* CSC_RGB_0_255_TO_RGB_16_235_8BIT */
+	 0x1b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,	/* G */
+	 0x00, 0x00, 0x1b, 0x80, 0x00, 0x00, 0x00, 0x20,	/* R */
+	 0x00, 0x00, 0x00, 0x00, 0x1b, 0x80, 0x00, 0x20,	/* B */
 	},
-	{	//CSC_RGB_0_255_TO_RGB_16_235_10BIT
-		0x1b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,		//G
-		0x00, 0x00, 0x1b, 0x80, 0x00, 0x00, 0x00, 0x80,		//R
-		0x00, 0x00, 0x00, 0x00, 0x1b, 0x80, 0x00, 0x80,		//B
+	{	/* CSC_RGB_0_255_TO_RGB_16_235_10BIT */
+	 0x1b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,	/* G */
+	 0x00, 0x00, 0x1b, 0x80, 0x00, 0x00, 0x00, 0x80,	/* R */
+	 0x00, 0x00, 0x00, 0x00, 0x1b, 0x80, 0x00, 0x80,	/* B */
 	},
 #if 0
-	{	//CSC_RGB_0_255_TO_ITU601_16_235_8BIT
-		0x25, 0x91, 0x13, 0x23, 0x07, 0x4c, 0x00, 0x00, 	//Y
-		0xe5, 0x34, 0x20, 0x00, 0xfa, 0xcc, 0x02, 0x00, 	//Cr
-		0xea, 0xcd, 0xf5, 0x33, 0x20, 0x00, 0x02, 0x00, 	//Cb
+	{	/* CSC_RGB_0_255_TO_ITU601_16_235_8BIT */
+	 0x25, 0x91, 0x13, 0x23, 0x07, 0x4c, 0x00, 0x00,	/* Y */
+	 0xe5, 0x34, 0x20, 0x00, 0xfa, 0xcc, 0x02, 0x00,	/* Cr */
+	 0xea, 0xcd, 0xf5, 0x33, 0x20, 0x00, 0x02, 0x00,	/* Cb */
 	},
-	{	//CSC_RGB_0_255_TO_ITU601_16_235_10BIT
-		0x25, 0x91, 0x13, 0x23, 0x07, 0x4c, 0x00, 0x00, 	//Y
-		0xe5, 0x34, 0x20, 0x00, 0xfa, 0xcc, 0x08, 0x00, 	//Cr
-		0xea, 0xcd, 0xf5, 0x33, 0x20, 0x00, 0x08, 0x00, 	//Cb
+	{	/* CSC_RGB_0_255_TO_ITU601_16_235_10BIT */
+	 0x25, 0x91, 0x13, 0x23, 0x07, 0x4c, 0x00, 0x00,	/* Y */
+	 0xe5, 0x34, 0x20, 0x00, 0xfa, 0xcc, 0x08, 0x00,	/* Cr */
+	 0xea, 0xcd, 0xf5, 0x33, 0x20, 0x00, 0x08, 0x00,	/* Cb */
 	},
-	{	//CSC_RGB_0_255_TO_ITU709_16_235_8BIT
-		0x2d, 0xc6, 0x0d, 0x9b, 0x04, 0x9f, 0x00, 0x00, 	//Y
-		0xe2, 0xef, 0x20, 0x00, 0xfd, 0x11, 0x02, 0x00,		//Cr
-		0xe7, 0x55, 0xf8, 0xab, 0x20, 0x00, 0x02, 0x00, 	//Cb
+	{	/* CSC_RGB_0_255_TO_ITU709_16_235_8BIT */
+	 0x2d, 0xc6, 0x0d, 0x9b, 0x04, 0x9f, 0x00, 0x00,	/* Y */
+	 0xe2, 0xef, 0x20, 0x00, 0xfd, 0x11, 0x02, 0x00,	/* Cr */
+	 0xe7, 0x55, 0xf8, 0xab, 0x20, 0x00, 0x02, 0x00,	/* Cb */
 	},
-	{	//CSC_RGB_0_255_TO_ITU709_16_235_10BIT
-		0x2d, 0xc6, 0x0d, 0x9b, 0x04, 0x9f, 0x00, 0x00, 	//Y
-		0xe2, 0xef, 0x20, 0x00, 0xfd, 0x11, 0x08, 0x00,		//Cr
-		0xe7, 0x55, 0xf8, 0xab, 0x20, 0x00, 0x08, 0x00, 	//Cb
+	{	/* CSC_RGB_0_255_TO_ITU709_16_235_10BIT */
+	 0x2d, 0xc6, 0x0d, 0x9b, 0x04, 0x9f, 0x00, 0x00,	/* Y */
+	 0xe2, 0xef, 0x20, 0x00, 0xfd, 0x11, 0x08, 0x00,	/* Cr */
+	 0xe7, 0x55, 0xf8, 0xab, 0x20, 0x00, 0x08, 0x00,	/* Cb */
 	},
 #else
-	{	//CSC_RGB_0_255_TO_ITU601_16_235_8BIT
-		0x20, 0x40, 0x10, 0x80, 0x06, 0x40, 0x00, 0x40,		//Y
-		0xe8, 0x80, 0x1c, 0x00, 0xfb, 0x80, 0x02, 0x00,		//Cr
-		0xed, 0x80, 0xf6, 0x80, 0x1c, 0x00, 0x02, 0x00,		//Cb
+	{	/* CSC_RGB_0_255_TO_ITU601_16_235_8BIT */
+	 0x20, 0x40, 0x10, 0x80, 0x06, 0x40, 0x00, 0x40,	/* Y */
+	 0xe8, 0x80, 0x1c, 0x00, 0xfb, 0x80, 0x02, 0x00,	/* Cr */
+	 0xed, 0x80, 0xf6, 0x80, 0x1c, 0x00, 0x02, 0x00,	/* Cb */
 	},
-	{	//CSC_RGB_0_255_TO_ITU601_16_235_10BIT
-		0x20, 0x40, 0x10, 0x80, 0x06, 0x40, 0x01, 0x00,		//Y
-		0xe8, 0x80, 0x1c, 0x00, 0xfb, 0x80, 0x08, 0x00,		//Cr
-		0xed, 0x80, 0xf6, 0x80, 0x1c, 0x00, 0x08, 0x00,		//Cb
+	{	/* CSC_RGB_0_255_TO_ITU601_16_235_10BIT */
+	 0x20, 0x40, 0x10, 0x80, 0x06, 0x40, 0x01, 0x00,	/* Y */
+	 0xe8, 0x80, 0x1c, 0x00, 0xfb, 0x80, 0x08, 0x00,	/* Cr */
+	 0xed, 0x80, 0xf6, 0x80, 0x1c, 0x00, 0x08, 0x00,	/* Cb */
 	},
-	{	//CSC_RGB_0_255_TO_ITU709_16_235_8BIT
-		0x27, 0x40, 0x0b, 0xc0, 0x04, 0x00, 0x00, 0x40,		//Y
-		0xe6, 0x80, 0x1c, 0x00, 0xfd, 0x80, 0x02, 0x00,		//Cr
-		0xea, 0x40, 0xf9, 0x80, 0x1c, 0x00, 0x02, 0x00,		//Cb
+	{	/* CSC_RGB_0_255_TO_ITU709_16_235_8BIT */
+	 0x27, 0x40, 0x0b, 0xc0, 0x04, 0x00, 0x00, 0x40,	/* Y */
+	 0xe6, 0x80, 0x1c, 0x00, 0xfd, 0x80, 0x02, 0x00,	/* Cr */
+	 0xea, 0x40, 0xf9, 0x80, 0x1c, 0x00, 0x02, 0x00,	/* Cb */
 	},
-	{	//CSC_RGB_0_255_TO_ITU709_16_235_10BIT
-		0x27, 0x40, 0x0b, 0xc0, 0x04, 0x00, 0x01, 0x00,		//Y
-		0xe6, 0x80, 0x1c, 0x00, 0xfd, 0x80, 0x08, 0x00,		//Cr
-		0xea, 0x40, 0xf9, 0x80, 0x1c, 0x00, 0x08, 0x00,		//Cb
+	{	/* CSC_RGB_0_255_TO_ITU709_16_235_10BIT */
+	 0x27, 0x40, 0x0b, 0xc0, 0x04, 0x00, 0x01, 0x00,	/* Y */
+	 0xe6, 0x80, 0x1c, 0x00, 0xfd, 0x80, 0x08, 0x00,	/* Cr */
+	 0xea, 0x40, 0xf9, 0x80, 0x1c, 0x00, 0x08, 0x00,	/* Cb */
 	},
 #endif
-		//Y		Cr	    Cb		Bias
-	{	//CSC_ITU601_16_235_TO_RGB_0_255_8BIT
-		0x20, 0x00, 0x69, 0x26, 0x74, 0xfd, 0x01, 0x0e, 	//G 
-		0x20, 0x00, 0x2c, 0xdd, 0x00, 0x00, 0x7e, 0x9a, 	//R
-		0x20, 0x00, 0x00, 0x00, 0x38, 0xb4, 0x7e, 0x3b,		//B
+	/* Y             Cr          Cb          Bias */
+	{	/* CSC_ITU601_16_235_TO_RGB_0_255_8BIT */
+	 0x20, 0x00, 0x69, 0x26, 0x74, 0xfd, 0x01, 0x0e,	/* G */
+	 0x20, 0x00, 0x2c, 0xdd, 0x00, 0x00, 0x7e, 0x9a,	/* R */
+	 0x20, 0x00, 0x00, 0x00, 0x38, 0xb4, 0x7e, 0x3b,	/* B */
 	},
-	{	//CSC_ITU709_16_235_TO_RGB_0_255_8BIT
-		0x20, 0x00, 0x71, 0x06, 0x7a, 0x02, 0x00, 0xa7, 	//G
-		0x20, 0x00, 0x32, 0x64, 0x00, 0x00, 0x7e, 0x6d, 	//R
-		0x20, 0x00, 0x00, 0x00, 0x3b, 0x61, 0x7e, 0x25, 	//B
+	{	/* CSC_ITU709_16_235_TO_RGB_0_255_8BIT */
+	 0x20, 0x00, 0x71, 0x06, 0x7a, 0x02, 0x00, 0xa7,	/* G */
+	 0x20, 0x00, 0x32, 0x64, 0x00, 0x00, 0x7e, 0x6d,	/* R */
+	 0x20, 0x00, 0x00, 0x00, 0x3b, 0x61, 0x7e, 0x25,	/* B */
 	},
 };
 
-static int rk3288_hdmi_video_csc(struct hdmi *hdmi_drv, struct hdmi_video_para *vpara)
+static int rk3288_hdmi_video_csc(struct hdmi *hdmi_drv,
+				 struct hdmi_video_para *vpara)
 {
 	int i, mode, interpolation, decimation, csc_scale;
 	const char *coeff = NULL;
 	unsigned char color_depth = 0;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
-	if ((vpara->input_color == vpara->output_color) && (vpara->color_limit_range == 0)) {
-		hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL, m_FEED_THROUGH_OFF, v_FEED_THROUGH_OFF(0));
+	if ((vpara->input_color == vpara->output_color)
+	    && (vpara->color_limit_range == 0)) {
+		hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL, m_FEED_THROUGH_OFF,
+			     v_FEED_THROUGH_OFF(0));
 		return 0;
 	}
 
-	if(vpara->input_color == VIDEO_INPUT_COLOR_YCBCR422 &&
-		(vpara->output_color == VIDEO_OUTPUT_RGB444 || vpara->output_color == VIDEO_OUTPUT_YCBCR444)) {
+	if (vpara->input_color == VIDEO_INPUT_COLOR_YCBCR422 &&
+	    (vpara->output_color == VIDEO_OUTPUT_RGB444
+	     || vpara->output_color == VIDEO_OUTPUT_YCBCR444)) {
 		interpolation = 1;
-		hdmi_msk_reg(hdmi_dev, CSC_CFG, m_CSC_INTPMODE, v_CSC_INTPMODE(interpolation));
+		hdmi_msk_reg(hdmi_dev, CSC_CFG, m_CSC_INTPMODE,
+			     v_CSC_INTPMODE(interpolation));
 	}
 
-	if((vpara->input_color == VIDEO_INPUT_COLOR_RGB || vpara->input_color == VIDEO_INPUT_COLOR_YCBCR444)
-		&& vpara->output_color == VIDEO_OUTPUT_YCBCR422) {
+	if ((vpara->input_color == VIDEO_INPUT_COLOR_RGB
+	     || vpara->input_color == VIDEO_INPUT_COLOR_YCBCR444)
+	    && vpara->output_color == VIDEO_OUTPUT_YCBCR422) {
 		decimation = 1;
-		hdmi_msk_reg(hdmi_dev, CSC_CFG, m_CSC_DECIMODE, v_CSC_DECIMODE(decimation));
+		hdmi_msk_reg(hdmi_dev, CSC_CFG, m_CSC_DECIMODE,
+			     v_CSC_DECIMODE(decimation));
 	}
 
-	switch(vpara->vic)
-	{
-		case HDMI_720x480i_60Hz_4_3:
-		case HDMI_720x576i_50Hz_4_3:
-		case HDMI_720x480p_60Hz_4_3:
-		case HDMI_720x576p_50Hz_4_3:
-		case HDMI_720x480i_60Hz_16_9:
-		case HDMI_720x576i_50Hz_16_9:
-		case HDMI_720x480p_60Hz_16_9:
-		case HDMI_720x576p_50Hz_16_9:
-			if (vpara->input_color == VIDEO_INPUT_COLOR_RGB && vpara->output_color >= VIDEO_OUTPUT_YCBCR444) {
-				mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;
-				csc_scale = 0;
-			} else if (vpara->input_color >= VIDEO_OUTPUT_YCBCR444 && vpara->output_color == VIDEO_OUTPUT_RGB444) {
-				mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
-				csc_scale = 1;
-			}
-			break;
-		default:
-			if (vpara->input_color == VIDEO_INPUT_COLOR_RGB && vpara->output_color >= VIDEO_OUTPUT_YCBCR444) {
-				mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;
-				csc_scale = 0;
-			} else if (vpara->input_color >= VIDEO_OUTPUT_YCBCR444 && vpara->output_color == VIDEO_OUTPUT_RGB444) {
-				mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;
-				csc_scale = 1;
-			}
-			break;
+	switch (vpara->vic) {
+	case HDMI_720x480i_60Hz_4_3:
+	case HDMI_720x576i_50Hz_4_3:
+	case HDMI_720x480p_60Hz_4_3:
+	case HDMI_720x576p_50Hz_4_3:
+	case HDMI_720x480i_60Hz_16_9:
+	case HDMI_720x576i_50Hz_16_9:
+	case HDMI_720x480p_60Hz_16_9:
+	case HDMI_720x576p_50Hz_16_9:
+		if (vpara->input_color == VIDEO_INPUT_COLOR_RGB
+		    && vpara->output_color >= VIDEO_OUTPUT_YCBCR444) {
+			mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;
+			csc_scale = 0;
+		} else if (vpara->input_color >= VIDEO_OUTPUT_YCBCR444
+			   && vpara->output_color == VIDEO_OUTPUT_RGB444) {
+			mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;
+			csc_scale = 1;
+		}
+		break;
+	default:
+		if (vpara->input_color == VIDEO_INPUT_COLOR_RGB
+		    && vpara->output_color >= VIDEO_OUTPUT_YCBCR444) {
+			mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;
+			csc_scale = 0;
+		} else if (vpara->input_color >= VIDEO_OUTPUT_YCBCR444
+			   && vpara->output_color == VIDEO_OUTPUT_RGB444) {
+			mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;
+			csc_scale = 1;
+		}
+		break;
 	}
 
-	if ((vpara->input_color == VIDEO_INPUT_COLOR_RGB) && (vpara->output_color == VIDEO_OUTPUT_RGB444)
-							&& (vpara->color_limit_range == 1)) {
+	if ((vpara->input_color == VIDEO_INPUT_COLOR_RGB)
+	    && (vpara->output_color == VIDEO_OUTPUT_RGB444)
+	    && (vpara->color_limit_range == 1)) {
 		mode = CSC_RGB_0_255_TO_RGB_16_235_8BIT;
 		csc_scale = 1;
 	}
 
 	switch (vpara->color_depth) {
-		case HDMI_COLOR_DEPTH_8BIT:
-			color_depth = COLOR_DEPTH_24BIT;
-			break;
-		case HDMI_COLOR_DEPTH_10BIT:
-			color_depth = COLOR_DEPTH_30BIT;
-			mode += 1;
-			break;
-		case HDMI_COLOR_DEPTH_12BIT:
-			color_depth = COLOR_DEPTH_36BIT;
-			mode += 2;
-			break;
-		case HDMI_COLOR_DEPTH_16BIT:
-			color_depth = COLOR_DEPTH_48BIT;
-			mode += 3;
-			break;
-		default:
-			color_depth = COLOR_DEPTH_24BIT;
-			break;
+	case HDMI_COLOR_DEPTH_8BIT:
+		color_depth = COLOR_DEPTH_24BIT;
+		break;
+	case HDMI_COLOR_DEPTH_10BIT:
+		color_depth = COLOR_DEPTH_30BIT;
+		mode += 1;
+		break;
+	case HDMI_COLOR_DEPTH_12BIT:
+		color_depth = COLOR_DEPTH_36BIT;
+		mode += 2;
+		break;
+	case HDMI_COLOR_DEPTH_16BIT:
+		color_depth = COLOR_DEPTH_48BIT;
+		mode += 3;
+		break;
+	default:
+		color_depth = COLOR_DEPTH_24BIT;
+		break;
 	}
 
 	coeff = coeff_csc[mode];
-	for(i = 0; i < 24; i++) {
+	for (i = 0; i < 24; i++) {
 		hdmi_writel(hdmi_dev, CSC_COEF_A1_MSB + i, coeff[i]);
 	}
 	hdmi_msk_reg(hdmi_dev, CSC_SCALE, m_CSC_SCALE, v_CSC_SCALE(csc_scale));
-	/*config CSC_COLOR_DEPTH*/
-	hdmi_msk_reg(hdmi_dev, CSC_SCALE, m_CSC_COLOR_DEPTH, v_CSC_COLOR_DEPTH(color_depth));
+	/* config CSC_COLOR_DEPTH */
+	hdmi_msk_reg(hdmi_dev, CSC_SCALE, m_CSC_COLOR_DEPTH,
+		     v_CSC_COLOR_DEPTH(color_depth));
 
-	//enable CSC
-	hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL, m_FEED_THROUGH_OFF, v_FEED_THROUGH_OFF(1));
+	/* enable CSC */
+	hdmi_msk_reg(hdmi_dev, MC_FLOWCTRL, m_FEED_THROUGH_OFF,
+		     v_FEED_THROUGH_OFF(1));
 	return 0;
 }
 
-
-int rk3288_hdmi_config_video(struct hdmi *hdmi_drv, struct hdmi_video_para *vpara)
+int rk3288_hdmi_config_video(struct hdmi *hdmi_drv,
+			     struct hdmi_video_para *vpara)
 {
 	rk3288_hdmi_av_mute(hdmi_drv, 1);
 
-	//Color space convert
 	if (rk3288_hdmi_video_forceOutput(hdmi_drv, 1) < 0)
 		return -1;
 	if (rk3288_hdmi_video_frameComposer(hdmi_drv, vpara) < 0)
@@ -920,43 +1058,58 @@ int rk3288_hdmi_config_video(struct hdmi *hdmi_drv, struct hdmi_video_para *vpar
 
 	if (vpara->output_mode == OUTPUT_HDMI) {
 		rk3288_hdmi_config_avi(hdmi_drv, vpara->vic, vpara);
-		hdmi_dbg(hdmi_drv->dev, "[%s] sucess output HDMI.\n", __FUNCTION__);
-
-		if ( vpara->format_3d != 0)
-                        rk3288_hdmi_config_vsi(hdmi_drv, vpara->format_3d, HDMI_VIDEO_FORMAT_3D, 1);
-		#ifndef HDMI_VERSION_2
-                else if ((vpara->vic > 92 && vpara->vic < 96) || (vpara->vic == 98)) {
+		hdmi_dbg(hdmi_drv->dev, "[%s] sucess output HDMI.\n",
+			 __func__);
+
+		if (vpara->format_3d != 0)
+			rk3288_hdmi_config_vsi(hdmi_drv, vpara->format_3d,
+					       HDMI_VIDEO_FORMAT_3D, 1);
+#ifndef HDMI_VERSION_2
+		else if ((vpara->vic > 92 && vpara->vic < 96)
+			 || (vpara->vic == 98)) {
 			vpara->vic = (vpara->vic == 98) ? 4 : (96 - vpara->vic);
-                        rk3288_hdmi_config_vsi(hdmi_drv, vpara->vic, HDMI_VIDEO_FORMAT_4Kx2K, 1);
-                }
-		#endif
-                else
-                        rk3288_hdmi_config_vsi(hdmi_drv, vpara->vic, HDMI_VIDEO_FORMAT_NORMAL, 1);
-	}
-	else {
-		hdmi_dbg(hdmi_drv->dev, "[%s] sucess output DVI.\n", __FUNCTION__);
+			rk3288_hdmi_config_vsi(hdmi_drv, vpara->vic,
+					       HDMI_VIDEO_FORMAT_4Kx2K, 1);
+		}
+#endif
+		else
+			rk3288_hdmi_config_vsi(hdmi_drv, vpara->vic,
+					       HDMI_VIDEO_FORMAT_NORMAL, 1);
+	} else {
+		hdmi_dbg(hdmi_drv->dev, "[%s] sucess output DVI.\n",
+			 __func__);
 	}
 
 	rk3288_hdmi_set_pwr_mode(hdmi_drv, NORMAL);
-	rk3288_hdmi_config_phy(hdmi_drv, vpara->pixel_repet, vpara->color_depth);
+	rk3288_hdmi_config_phy(hdmi_drv, vpara->pixel_repet,
+			       vpara->color_depth);
 	return 0;
 }
 
-static void rk3288_hdmi_config_aai(struct hdmi *hdmi_drv, struct hdmi_audio *audio)
+static void rk3288_hdmi_config_aai(struct hdmi *hdmi_drv,
+				   struct hdmi_audio *audio)
 {
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
-
-	//Refer to CEA861-E Audio infoFrame
-	//Set both Audio Channel Count and Audio Coding Type Refer to Stream Head for HDMI
-	hdmi_msk_reg(hdmi_dev, FC_AUDICONF0, m_FC_CHN_CNT | m_FC_CODING_TYEP, v_FC_CHN_CNT(0) | v_FC_CODING_TYEP(0));
-
-	//Set both Audio Sample Size and Sample Frequency Refer to Stream Head for HDMI
-	hdmi_msk_reg(hdmi_dev, FC_AUDICONF1, m_FC_SAMPLE_SIZE | m_FC_SAMPLE_FREQ, v_FC_SAMPLE_SIZE(0) | v_FC_SAMPLE_FREQ(0));
-
-	//Set Channel Allocation
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+
+	/* Refer to CEA861-E Audio infoFrame */
+	/* Set both Audio Channel Count and
+	* Audio Coding Type Refer to Stream Head for HDMI
+	*/
+	hdmi_msk_reg(hdmi_dev, FC_AUDICONF0, m_FC_CHN_CNT | m_FC_CODING_TYEP,
+		     v_FC_CHN_CNT(0) | v_FC_CODING_TYEP(0));
+
+	/* Set both Audio Sample Size and
+	* Sample Frequency Refer to Stream Head for HDMI
+	*/
+	hdmi_msk_reg(hdmi_dev, FC_AUDICONF1,
+		     m_FC_SAMPLE_SIZE | m_FC_SAMPLE_FREQ,
+		     v_FC_SAMPLE_SIZE(0) | v_FC_SAMPLE_FREQ(0));
+
+	/* Set Channel Allocation */
 	hdmi_writel(hdmi_dev, FC_AUDICONF2, 0x00);
 
-	//Set LFEPBLDOWN-MIX INH and LSV
+	/* Set LFEPBLDOWN-MIX INH and LSV */
 	hdmi_writel(hdmi_dev, FC_AUDICONF3, 0x00);
 }
 
@@ -965,149 +1118,169 @@ int rk3288_hdmi_config_audio(struct hdmi *hdmi_drv, struct hdmi_audio *audio)
 	int word_length = 0, channel = 0, mclk_fs;
 	unsigned int N = 0, CTS = 0;
 	unsigned char layout_value = 0;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
-	if(audio->channel < 3)
+	if (audio->channel < 3)
 		channel = I2S_CHANNEL_1_2;
-	else if(audio->channel < 5)
+	else if (audio->channel < 5)
 		channel = I2S_CHANNEL_3_4;
-	else if(audio->channel < 7)
+	else if (audio->channel < 7)
 		channel = I2S_CHANNEL_5_6;
 	else
 		channel = I2S_CHANNEL_7_8;
 
-	switch(audio->rate)
-	{
-		case HDMI_AUDIO_FS_32000:
-			mclk_fs = FS_256;
-			if(hdmi_drv->pixclock >= 594000000)
-				N = N_32K_HIGHCLK;
-			else if(hdmi_drv->pixclock == 297000000)
-				N = N_32K_MIDCLK;
-			else
-				N = N_32K_LOWCLK;
-
-			CTS = CALC_CTS(N, hdmi_drv->tmdsclk/1000, 32);	//div a num to avoid the value is exceed 2^32(int)
-			break;
-		case HDMI_AUDIO_FS_44100:
-			mclk_fs = FS_256;
-			if(hdmi_drv->pixclock >= 594000000)
-				N = N_441K_HIGHCLK;
-			else if(hdmi_drv->pixclock == 297000000)
-				N = N_441K_MIDCLK;
-			else
-				N = N_441K_LOWCLK;
-
-			CTS = CALC_CTS(N, hdmi_drv->tmdsclk/100, 441);
-			break;
-		case HDMI_AUDIO_FS_48000:
-			mclk_fs = FS_256;
-			if(hdmi_drv->pixclock >= 594000000)	//FS_153.6
-				N = N_48K_HIGHCLK;
-			else if(hdmi_drv->pixclock == 297000000)
-				N = N_48K_MIDCLK;
-			else
-				N = N_48K_LOWCLK;
-
-			CTS = CALC_CTS(N, hdmi_drv->tmdsclk/1000, 48);
-			break;
-		case HDMI_AUDIO_FS_88200:
-			mclk_fs = FS_256;
-			if(hdmi_drv->pixclock >= 594000000)
-				N = N_882K_HIGHCLK;
-			else if(hdmi_drv->pixclock == 297000000)
-				N = N_882K_MIDCLK;
-			else
-				N = N_882K_LOWCLK;
-
-			CTS = CALC_CTS(N, hdmi_drv->tmdsclk/100, 882);
-			break;
-		case HDMI_AUDIO_FS_96000:
-			mclk_fs = FS_256;
-			if(hdmi_drv->pixclock >= 594000000)	//FS_153.6
-				N = N_96K_HIGHCLK;
-			else if(hdmi_drv->pixclock == 297000000)
-				N = N_96K_MIDCLK;
-			else
-				N = N_96K_LOWCLK;
-
-			CTS = CALC_CTS(N, hdmi_drv->tmdsclk/1000, 96);
-			break;
-		case HDMI_AUDIO_FS_176400:
-			mclk_fs = FS_256;
-			if(hdmi_drv->pixclock >= 594000000)
-				N = N_1764K_HIGHCLK;
-			else if(hdmi_drv->pixclock == 297000000)
-				N = N_1764K_MIDCLK;
-			else
-				N = N_1764K_LOWCLK;
-
-			CTS = CALC_CTS(N, hdmi_drv->tmdsclk/100, 1764);
-			break;
-		case HDMI_AUDIO_FS_192000:
-			mclk_fs = FS_256;
-			if(hdmi_drv->pixclock >= 594000000)	//FS_153.6
-				N = N_192K_HIGHCLK;
-			else if(hdmi_drv->pixclock == 297000000)
-				N = N_192K_MIDCLK;
-			else
-				N = N_192K_LOWCLK;
-
-			CTS = CALC_CTS(N, hdmi_drv->tmdsclk/1000, 192);
-			break;
-		default:
-			hdmi_err(hdmi_drv->dev, "[%s] not support such sample rate %d\n", __FUNCTION__, audio->rate);
-			return -ENOENT;
+	switch (audio->rate) {
+	case HDMI_AUDIO_FS_32000:
+		mclk_fs = FS_256;
+		if (hdmi_drv->pixclock >= 594000000)
+			N = N_32K_HIGHCLK;
+		else if (hdmi_drv->pixclock == 297000000)
+			N = N_32K_MIDCLK;
+		else
+			N = N_32K_LOWCLK;
+
+		/* div a num to avoid the value is exceed 2^32(int) */
+		CTS = CALC_CTS(N, hdmi_drv->tmdsclk / 1000, 32);
+		break;
+	case HDMI_AUDIO_FS_44100:
+		mclk_fs = FS_256;
+		if (hdmi_drv->pixclock >= 594000000)
+			N = N_441K_HIGHCLK;
+		else if (hdmi_drv->pixclock == 297000000)
+			N = N_441K_MIDCLK;
+		else
+			N = N_441K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_drv->tmdsclk / 100, 441);
+		break;
+	case HDMI_AUDIO_FS_48000:
+		mclk_fs = FS_256;
+		if (hdmi_drv->pixclock >= 594000000)	/* FS_153.6 */
+			N = N_48K_HIGHCLK;
+		else if (hdmi_drv->pixclock == 297000000)
+			N = N_48K_MIDCLK;
+		else
+			N = N_48K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_drv->tmdsclk / 1000, 48);
+		break;
+	case HDMI_AUDIO_FS_88200:
+		mclk_fs = FS_256;
+		if (hdmi_drv->pixclock >= 594000000)
+			N = N_882K_HIGHCLK;
+		else if (hdmi_drv->pixclock == 297000000)
+			N = N_882K_MIDCLK;
+		else
+			N = N_882K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_drv->tmdsclk / 100, 882);
+		break;
+	case HDMI_AUDIO_FS_96000:
+		mclk_fs = FS_256;
+		if (hdmi_drv->pixclock >= 594000000)	/* FS_153.6 */
+			N = N_96K_HIGHCLK;
+		else if (hdmi_drv->pixclock == 297000000)
+			N = N_96K_MIDCLK;
+		else
+			N = N_96K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_drv->tmdsclk / 1000, 96);
+		break;
+	case HDMI_AUDIO_FS_176400:
+		mclk_fs = FS_256;
+		if (hdmi_drv->pixclock >= 594000000)
+			N = N_1764K_HIGHCLK;
+		else if (hdmi_drv->pixclock == 297000000)
+			N = N_1764K_MIDCLK;
+		else
+			N = N_1764K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_drv->tmdsclk / 100, 1764);
+		break;
+	case HDMI_AUDIO_FS_192000:
+		mclk_fs = FS_256;
+		if (hdmi_drv->pixclock >= 594000000)	/* FS_153.6 */
+			N = N_192K_HIGHCLK;
+		else if (hdmi_drv->pixclock == 297000000)
+			N = N_192K_MIDCLK;
+		else
+			N = N_192K_LOWCLK;
+
+		CTS = CALC_CTS(N, hdmi_drv->tmdsclk / 1000, 192);
+		break;
+	default:
+		hdmi_err(hdmi_drv->dev,
+			 "[%s] not support such sample rate %d\n", __func__,
+			 audio->rate);
+		return -ENOENT;
 	}
 
-	switch(audio->word_length)
-	{
-		case HDMI_AUDIO_WORD_LENGTH_16bit:
-			word_length = I2S_16BIT_SAMPLE;
-			break;
-		case HDMI_AUDIO_WORD_LENGTH_20bit:
-			word_length = I2S_20BIT_SAMPLE;
-			break;
-		case HDMI_AUDIO_WORD_LENGTH_24bit:
-			word_length = I2S_24BIT_SAMPLE;
-			break;
-		default:
-			word_length = I2S_16BIT_SAMPLE;
+	switch (audio->word_length) {
+	case HDMI_AUDIO_WORD_LENGTH_16bit:
+		word_length = I2S_16BIT_SAMPLE;
+		break;
+	case HDMI_AUDIO_WORD_LENGTH_20bit:
+		word_length = I2S_20BIT_SAMPLE;
+		break;
+	case HDMI_AUDIO_WORD_LENGTH_24bit:
+		word_length = I2S_24BIT_SAMPLE;
+		break;
+	default:
+		word_length = I2S_16BIT_SAMPLE;
 	}
 
-	hdmi_dbg(hdmi_drv->dev, "rate = %d, tmdsclk = %d, N = %d, CTS = %d\n",  audio->rate, hdmi_drv->tmdsclk, N, CTS);
-	/* more than 2 channels => layout 1 else layout 0 */
-	layout_value = (audio->channel > 2) ? 1 : 0;	//TODO Daisen wait to modify
-	hdmi_msk_reg(hdmi_dev, FC_AUDSCONF, m_AUD_PACK_LAYOUT, v_AUD_PACK_LAYOUT(layout_value));
-
-	if(hdmi_drv->audio.type == INPUT_SPDIF) {
-		hdmi_msk_reg(hdmi_dev, AUD_CONF0, m_I2S_SEL, v_I2S_SEL(AUDIO_SPDIF_GPA));
-		hdmi_msk_reg(hdmi_dev, AUD_SPDIF1, m_SET_NLPCM | m_SPDIF_WIDTH, v_SET_NLPCM(PCM_LINEAR) | v_SPDIF_WIDTH(word_length));
-		//Mask fifo empty and full int and reset fifo
-		hdmi_msk_reg(hdmi_dev, AUD_SPDIFINT, m_FIFO_EMPTY_MASK | m_FIFO_FULL_MASK, v_FIFO_EMPTY_MASK(1) | v_FIFO_FULL_MASK(1));
-		hdmi_msk_reg(hdmi_dev, AUD_SPDIF0, m_SW_SAUD_FIFO_RST, v_SW_SAUD_FIFO_RST(1));
-	}
-	else {
-		hdmi_msk_reg(hdmi_dev, AUD_CONF0, m_I2S_SEL | m_I2S_IN_EN, v_I2S_SEL(AUDIO_I2S) | v_I2S_IN_EN(channel));
-		hdmi_writel(hdmi_dev, AUD_CONF1, v_I2S_MODE(I2S_STANDARD_MODE) | v_I2S_WIDTH(word_length));
-		//Mask fifo empty and full int and reset fifo
-		hdmi_msk_reg(hdmi_dev, AUD_INT, m_FIFO_EMPTY_MASK | m_FIFO_FULL_MASK, v_FIFO_EMPTY_MASK(1) | v_FIFO_FULL_MASK(1));
-		hdmi_msk_reg(hdmi_dev, AUD_CONF0, m_SW_AUD_FIFO_RST, v_SW_AUD_FIFO_RST(1));
+	hdmi_dbg(hdmi_drv->dev, "rate = %d, tmdsclk = %d, N = %d, CTS = %d\n",
+		 audio->rate, hdmi_drv->tmdsclk, N, CTS);
+	/* more than 2 channels => layout 1 else layout 0
+	* TODO Daisen wait to modify
+	*/
+	layout_value = (audio->channel > 2) ? 1 : 0;
+	hdmi_msk_reg(hdmi_dev, FC_AUDSCONF, m_AUD_PACK_LAYOUT,
+		     v_AUD_PACK_LAYOUT(layout_value));
+
+	if (hdmi_drv->audio.type == INPUT_SPDIF) {
+		hdmi_msk_reg(hdmi_dev, AUD_CONF0, m_I2S_SEL,
+			     v_I2S_SEL(AUDIO_SPDIF_GPA));
+		hdmi_msk_reg(hdmi_dev, AUD_SPDIF1, m_SET_NLPCM | m_SPDIF_WIDTH,
+			     v_SET_NLPCM(PCM_LINEAR) |
+			     v_SPDIF_WIDTH(word_length));
+		/* Mask fifo empty and full int and reset fifo */
+		hdmi_msk_reg(hdmi_dev, AUD_SPDIFINT,
+			     m_FIFO_EMPTY_MASK | m_FIFO_FULL_MASK,
+			     v_FIFO_EMPTY_MASK(1) | v_FIFO_FULL_MASK(1));
+		hdmi_msk_reg(hdmi_dev, AUD_SPDIF0, m_SW_SAUD_FIFO_RST,
+			     v_SW_SAUD_FIFO_RST(1));
+	} else {
+		hdmi_msk_reg(hdmi_dev, AUD_CONF0, m_I2S_SEL | m_I2S_IN_EN,
+			     v_I2S_SEL(AUDIO_I2S) | v_I2S_IN_EN(channel));
+		hdmi_writel(hdmi_dev, AUD_CONF1,
+			    v_I2S_MODE(I2S_STANDARD_MODE) |
+			    v_I2S_WIDTH(word_length));
+		/* Mask fifo empty and full int and reset fifo */
+		hdmi_msk_reg(hdmi_dev, AUD_INT,
+			     m_FIFO_EMPTY_MASK | m_FIFO_FULL_MASK,
+			     v_FIFO_EMPTY_MASK(1) | v_FIFO_FULL_MASK(1));
+		hdmi_msk_reg(hdmi_dev, AUD_CONF0, m_SW_AUD_FIFO_RST,
+			     v_SW_AUD_FIFO_RST(1));
 	}
 
-	hdmi_msk_reg(hdmi_dev, AUD_INPUTCLKFS, m_LFS_FACTOR, v_LFS_FACTOR(mclk_fs));
+	hdmi_msk_reg(hdmi_dev, AUD_INPUTCLKFS, m_LFS_FACTOR,
+		     v_LFS_FACTOR(mclk_fs));
 
-	//Set N value
+	/* Set N value */
 	hdmi_msk_reg(hdmi_dev, AUD_N3, m_AUD_N3, v_AUD_N3(N >> 16));
 	hdmi_writel(hdmi_dev, AUD_N2, (N >> 8) & 0xff);
 	hdmi_writel(hdmi_dev, AUD_N1, N & 0xff);
-	//Set CTS by manual
+	/* Set CTS by manual */
 	hdmi_msk_reg(hdmi_dev, AUD_CTS3, m_N_SHIFT | m_CTS_MANUAL | m_AUD_CTS3,
-		v_N_SHIFT(N_SHIFT_1) | v_CTS_MANUAL(1) | v_AUD_CTS3(CTS >> 16));
+		     v_N_SHIFT(N_SHIFT_1) | v_CTS_MANUAL(1) | v_AUD_CTS3(CTS >>
+									 16));
 	hdmi_writel(hdmi_dev, AUD_CTS2, (CTS >> 8) & 0xff);
 	hdmi_writel(hdmi_dev, AUD_CTS1, CTS & 0xff);
 
-	hdmi_msk_reg(hdmi_dev, MC_CLKDIS, m_AUDCLK_DISABLE, v_AUDCLK_DISABLE(0));
+	hdmi_msk_reg(hdmi_dev, MC_CLKDIS, m_AUDCLK_DISABLE,
+		     v_AUDCLK_DISABLE(0));
 	rk3288_hdmi_config_aai(hdmi_drv, audio);
 
 	return 0;
@@ -1115,15 +1288,16 @@ int rk3288_hdmi_config_audio(struct hdmi *hdmi_drv, struct hdmi_audio *audio)
 
 void rk3288_hdmi_control_output(struct hdmi *hdmi_drv, int enable)
 {
-	hdmi_dbg(hdmi_drv->dev, "[%s] %d\n", __FUNCTION__, enable);
-	if(enable == 0) {
+	hdmi_dbg(hdmi_drv->dev, "[%s] %d\n", __func__, enable);
+	if (enable == 0) {
 		rk3288_hdmi_av_mute(hdmi_drv, 1);
-	}
-	else {
-		if(hdmi_drv->pwr_mode == LOWER_PWR)
+	} else {
+		if (hdmi_drv->pwr_mode == LOWER_PWR)
 			rk3288_hdmi_set_pwr_mode(hdmi_drv, NORMAL);
 
-		/* disable blue screen transmission after turning on all necessary blocks*/
+		/* disable blue screen transmission
+		* after turning on all necessary blocks
+		*/
 		rk3288_hdmi_video_forceOutput(hdmi_drv, 0);
 		rk3288_hdmi_av_mute(hdmi_drv, 0);
 	}
@@ -1131,7 +1305,8 @@ void rk3288_hdmi_control_output(struct hdmi *hdmi_drv, int enable)
 
 int rk3288_hdmi_insert(struct hdmi *hdmi_drv)
 {
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 
 	/* report HPD state to HDCP (after configuration) */
 	hdmi_msk_reg(hdmi_dev, A_HDCPCFG0, m_RX_DETECT, v_RX_DETECT(1));
@@ -1142,83 +1317,84 @@ int rk3288_hdmi_insert(struct hdmi *hdmi_drv)
 int rk3288_hdmi_removed(struct hdmi *hdmi_drv)
 {
 	rk3288_hdmi_set_pwr_mode(hdmi_drv, LOWER_PWR);
-	dev_printk(KERN_INFO , hdmi_drv->dev , "Removed.\n");
+	dev_printk(KERN_INFO, hdmi_drv->dev, "Removed.\n");
 	return 0;
 }
 
 int rk3288_hdmi_initial(struct hdmi *hdmi_drv)
 {
-        int rc = HDMI_ERROR_SUCESS;
+	int rc = HDMI_ERROR_SUCESS;
 
 	hdmi_drv->pwr_mode = NORMAL;
 	hdmi_drv->insert = rk3288_hdmi_insert;
-        hdmi_drv->remove = rk3288_hdmi_removed;
-        hdmi_drv->control_output = rk3288_hdmi_control_output;
-        hdmi_drv->config_video = rk3288_hdmi_config_video;
-        hdmi_drv->config_audio = rk3288_hdmi_config_audio;
-        hdmi_drv->detect_hotplug = rk3288_hdmi_detect_hotplug;
-        hdmi_drv->read_edid = rk3288_hdmi_read_edid;
+	hdmi_drv->remove = rk3288_hdmi_removed;
+	hdmi_drv->control_output = rk3288_hdmi_control_output;
+	hdmi_drv->config_video = rk3288_hdmi_config_video;
+	hdmi_drv->config_audio = rk3288_hdmi_config_audio;
+	hdmi_drv->detect_hotplug = rk3288_hdmi_detect_hotplug;
+	hdmi_drv->read_edid = rk3288_hdmi_read_edid;
 
 	rk3288_hdmi_reset(hdmi_drv);
 
-	if(hdmi_drv->hdcp_power_on_cb)
+	if (hdmi_drv->hdcp_power_on_cb)
 		rc = hdmi_drv->hdcp_power_on_cb();
 
-        return rc;
+	return rc;
 }
 
 irqreturn_t hdmi_irq(int irq, void *priv)
 {
 	struct hdmi *hdmi_drv = (struct hdmi *)priv;
-	struct rk3288_hdmi_device *hdmi_dev = container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
+	struct rk3288_hdmi_device *hdmi_dev =
+	    container_of(hdmi_drv, struct rk3288_hdmi_device, driver);
 	int phy_int = 0, i2cm_int = 0, phy_i2cm_int = 0, cec_int = 0;
 	int aud_dma_int = 0;
 
-	//read interrupt
+	/* read interrupt */
 	phy_int = hdmi_readl(hdmi_dev, IH_PHY_STAT0);
 	i2cm_int = hdmi_readl(hdmi_dev, IH_I2CM_STAT0);
 	phy_i2cm_int = hdmi_readl(hdmi_dev, IH_I2CMPHY_STAT0);
 	cec_int = hdmi_readl(hdmi_dev, IH_CEC_STAT0);
 	aud_dma_int = hdmi_readl(hdmi_dev, IH_AHBDMAAUD_STAT0);
-	//hdcp_int = hdmi_readl(hdmi_dev, A_APIINTSTAT);
+	/*
+	hdcp_int = hdmi_readl(hdmi_dev, A_APIINTSTAT);
+	*/
 
-	//clear interrupt
+	/* clear interrupt */
 	hdmi_writel(hdmi_dev, IH_PHY_STAT0, phy_int);
 	hdmi_writel(hdmi_dev, IH_I2CM_STAT0, i2cm_int);
 	hdmi_writel(hdmi_dev, IH_I2CMPHY_STAT0, phy_i2cm_int);
 	hdmi_writel(hdmi_dev, IH_CEC_STAT0, cec_int);
 	hdmi_writel(hdmi_dev, IH_AHBDMAAUD_STAT0, aud_dma_int);
-	//hdmi_writel(hdmi_dev, A_APIINTCLR, hdcp_int);
+	/*
+	hdmi_writel(hdmi_dev, A_APIINTCLR, hdcp_int);
+	*/
 
-	//HPD or RX_SENSE
-	if((phy_int & m_HPD) || ((phy_int & 0x3c) == 0x3c)) {
-		if(hdmi_drv->state == HDMI_SLEEP)
+	/* HPD or RX_SENSE */
+	if ((phy_int & m_HPD) || ((phy_int & 0x3c) == 0x3c)) {
+		if (hdmi_drv->state == HDMI_SLEEP)
 			hdmi_drv->state = WAIT_HOTPLUG;
-		queue_delayed_work(hdmi_drv->workqueue, &hdmi_drv->delay_work, msecs_to_jiffies(5));
+		queue_delayed_work(hdmi_drv->workqueue, &hdmi_drv->delay_work,
+				   msecs_to_jiffies(5));
 	}
-
-	//I2CM write or read result
-	if(i2cm_int & (m_SCDC_READREQ | m_I2CM_DONE | m_I2CM_ERROR)) {
-		//spin_lock(&hdmi_drv->irq_lock);
+	/* I2CM write or read result */
+	if (i2cm_int & (m_SCDC_READREQ | m_I2CM_DONE | m_I2CM_ERROR)) {
+		/* spin_lock(&hdmi_drv->irq_lock); */
 		hdmi_dev->i2cm_int = i2cm_int;
-		//spin_unlock(&hdmi_drv->irq_lock);
+		/* spin_unlock(&hdmi_drv->irq_lock); */
 	}
-
-	//PHY I2CM write or read result
-	if(phy_i2cm_int & (m_I2CMPHY_DONE | m_I2CMPHY_ERR)) {
-		//mutex_lock(&hdmi_dev->int_mutex);
+	/* PHY I2CM write or read result */
+	if (phy_i2cm_int & (m_I2CMPHY_DONE | m_I2CMPHY_ERR)) {
+		/* mutex_lock(&hdmi_dev->int_mutex); */
 		hdmi_dev->phy_i2cm_int = phy_i2cm_int;
-		//mutex_unlock(&hdmi_dev->int_mutex);
+		/* mutex_unlock(&hdmi_dev->int_mutex); */
 	}
-
-	//CEC
-	if(cec_int) {	//TODO Daisen wait to modify
+	/* CEC */
+	if (cec_int) {
 	}
-
-	//HDCP
-	if(hdmi_drv->hdcp_irq_cb)
+	/* HDCP */
+	if (hdmi_drv->hdcp_irq_cb)
 		hdmi_drv->hdcp_irq_cb(i2cm_int);
 
 	return IRQ_HANDLED;
 }
-
diff --git a/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi_hw.h b/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi_hw.h
index 22047cae6cb1..6d175c372a02 100644
--- a/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi_hw.h
+++ b/drivers/video/rockchip/hdmi/chips/rk3288/rk3288_hdmi_hw.h
@@ -2,9 +2,9 @@
 #define _RK3288_HDMI_HW_H
 #include "../../rk_hdmi.h"
 
-#define HDMI_INT_USE_POLL 1	//TODO Daisen wait to modify
+#define HDMI_INT_USE_POLL 1	/* TODO Daisen wait to modify */
 
-enum PWR_MODE{
+enum PWR_MODE {
 	NORMAL,
 	LOWER_PWR,
 };
@@ -12,26 +12,26 @@ enum {
 	OUTPUT_DVI = 0,
 	OUTPUT_HDMI,
 };
-enum{
+enum {
 	INPUT_IIS,
 	INPUT_SPDIF
 };
 
 /* Color Space Convertion Mode */
 enum {
-	CSC_RGB_0_255_TO_RGB_16_235_8BIT,	//RGB 0-255 input to RGB 16-235 output that is 8bit clolor depth
-	CSC_RGB_0_255_TO_RGB_16_235_10BIT,	//RGB 0-255 input to RGB 16-235 output that is 8bit clolor depth
-	CSC_RGB_0_255_TO_ITU601_16_235_8BIT,	//RGB 0-255 input to YCbCr 16-235 output according BT601 that is 8bit clolor depth
-	CSC_RGB_0_255_TO_ITU601_16_235_10BIT,	//RGB 0-255 input to YCbCr 16-235 output according BT601 that is 10bit clolor depth
-	CSC_RGB_0_255_TO_ITU709_16_235_8BIT,	//RGB 0-255 input to YCbCr 16-235 output accroding BT709 that is 8bit clolor depth
-	CSC_RGB_0_255_TO_ITU709_16_235_10BIT,	//RGB 0-255 input to YCbCr 16-235 output accroding BT709 that is 10bit clolor depth
-	CSC_ITU601_16_235_TO_RGB_16_235_8BIT,	//YCbCr 16-235 input to RGB 16-235 output according BT601 that is 8bit clolor depth
-	CSC_ITU709_16_235_TO_RGB_16_235_8BIT,	//YCbCr 16-235 input to RGB 16-235 output according BT709 that is 8bit clolor depth
-	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,	//YCbCr 16-235 input to RGB 0-255 output according BT601 that is 8bit clolor depth
-	CSC_ITU709_16_235_TO_RGB_0_255_8BIT	//YCbCr 16-235 input to RGB 0-255 output according BT709 that is 8bit clolor depth
+	CSC_RGB_0_255_TO_RGB_16_235_8BIT,	/* RGB 0-255 input to RGB 16-235 output that is 8bit clolor depth */
+	CSC_RGB_0_255_TO_RGB_16_235_10BIT,	/* RGB 0-255 input to RGB 16-235 output that is 8bit clolor depth */
+	CSC_RGB_0_255_TO_ITU601_16_235_8BIT,	/* RGB 0-255 input to YCbCr 16-235 output according BT601 that is 8bit clolor depth */
+	CSC_RGB_0_255_TO_ITU601_16_235_10BIT,	/* RGB 0-255 input to YCbCr 16-235 output according BT601 that is 10bit clolor depth */
+	CSC_RGB_0_255_TO_ITU709_16_235_8BIT,	/* RGB 0-255 input to YCbCr 16-235 output accroding BT709 that is 8bit clolor depth */
+	CSC_RGB_0_255_TO_ITU709_16_235_10BIT,	/* RGB 0-255 input to YCbCr 16-235 output accroding BT709 that is 10bit clolor depth */
+	CSC_ITU601_16_235_TO_RGB_16_235_8BIT,	/* YCbCr 16-235 input to RGB 16-235 output according BT601 that is 8bit clolor depth */
+	CSC_ITU709_16_235_TO_RGB_16_235_8BIT,	/* YCbCr 16-235 input to RGB 16-235 output according BT709 that is 8bit clolor depth */
+	CSC_ITU601_16_235_TO_RGB_0_255_8BIT,	/* YCbCr 16-235 input to RGB 0-255 output according BT601 that is 8bit clolor depth */
+	CSC_ITU709_16_235_TO_RGB_0_255_8BIT	/* YCbCr 16-235 input to RGB 0-255 output according BT709 that is 8bit clolor depth */
 };
 
-/*VIC VIDEO FORMAT*/
+/* VIC VIDEO FORMAT */
 enum {
 	HDMI_VIDEO_FORMAT_NORMAL = 0,
 	HDMI_VIDEO_FORMAT_4Kx2K,
@@ -39,14 +39,14 @@ enum {
 };
 
 #define HDMI_SCL_RATE		(100*1000)
-#define DDC_I2C_EDID_ADDR	0x50	// 0xA0/2 = 0x50
-#define DDC_I2C_SEG_ADDR	0x30	// 0x60/2 = 0x30
+#define DDC_I2C_EDID_ADDR	0x50	/* 0xA0/2 = 0x50 */
+#define DDC_I2C_SEG_ADDR	0x30	/* 0x60/2 = 0x30 */
 
-/*Register and Field Descriptions*/
-/*Identification Registers*/
+/* Register and Field Descriptions */
+/* Identification Registers */
 #define IDENTIFICATION_BASE		0x0000
 
-#define	DESIGN_ID 			0x0000
+#define DESIGN_ID			0x0000
 #define REVISION_ID			0x0001
 #define PRODUCT_ID0			0x0002
 #define PRODUCT_ID1			0x0003
@@ -77,8 +77,7 @@ enum PHYTYPE {
 #define m_AHB_AUD_DMA		(1 << 1)
 #define m_GP_AUD		(1 << 0)
 
-
-/*Interrupt Registers*/
+/* Interrupt Registers */
 #define INTERRUPT_BASE                  0x0100
 
 #define IH_FC_STAT0			0x0100
@@ -112,7 +111,7 @@ enum PHYTYPE {
 #define IH_PHY_STAT0			0x0104
 #define m_RX_SENSE3		(1 << 5)
 #define m_RX_SENSE2		(1 << 4)
-#define m_RX_SENSE1 		(1 << 3)
+#define m_RX_SENSE1		(1 << 3)
 #define m_RX_SENSE0		(1 << 2)
 #define m_TX_PHY_LOCK		(1 << 1)
 #define m_HPD			(1 << 0)
@@ -235,21 +234,21 @@ enum PHYTYPE {
 #define IH_MUTE_AHBDMAAUD_STAT0		0x0189
 #define IH_MUTE				0x01ff
 
-/*Video Sampler Registers*/
+/* Video Sampler Registers */
 #define VIDEO_SAMPLER_BASE		0x0200
 
 #define TX_INVID0			0x0200
 #define m_INTERNAL_DE_GEN	(1 << 7)
 #define v_INTERNAL_DE_GEN(n)	(((n)&0x01) << 7)
-enum VIDEO_MODE{
+enum VIDEO_MODE {
 	VIDEO_RGB444_8BIT = 0x01,
 	VIDEO_RGB444_10BIT = 0x03,
 	VIDEO_RGB444_12BIT = 0x05,
 	VIDEO_RGB444_16BIT = 0x07,
-	VIDEO_YCBCR444_8BIT = 0x09,	//or YCbCr420
-	VIDEO_YCBCR444_10BIT = 0x0b,	//or YCbCr420
-	VIDEO_YCBCR444_12BIT = 0x0d,	//or YCbCr420
-	VIDEO_YCBCR444_16BIT = 0x0f,	//or YCbCr420
+	VIDEO_YCBCR444_8BIT = 0x09,	/* or YCbCr420 */
+	VIDEO_YCBCR444_10BIT = 0x0b,	/* or YCbCr420 */
+	VIDEO_YCBCR444_12BIT = 0x0d,	/* or YCbCr420 */
+	VIDEO_YCBCR444_16BIT = 0x0f,	/* or YCbCr420 */
 	VIDEO_YCBCR422_12BIT = 0x12,
 	VIDEO_YCBCR422_10BIT = 0x14,
 	VIDEO_YCBCR422_8BIT = 0x16
@@ -272,8 +271,7 @@ enum VIDEO_MODE{
 #define TX_BCBDATA0			0x0206
 #define TX_BCBDATA1			0x0207
 
-
-/*Video Packetizer Registers*/
+/* Video Packetizer Registers */
 #define VIDEO_PACKETIZER_BASE		0x0800
 
 #define VP_STATUS			0x0800
@@ -295,11 +293,11 @@ enum PIXEL_REPET {
 	PIXEL_SENT_3TIMES,
 	PIXEL_SENT_4TIMES,
 	PIXEL_SENT_5TIMES,
-        PIXEL_SENT_6TIMES,
-        PIXEL_SENT_7TIMES,
+	PIXEL_SENT_6TIMES,
+	PIXEL_SENT_7TIMES,
 	PIXEL_SENT_8TIMES,
-        PIXEL_SENT_9TIMES,
-        PIXEL_SENT_10TIMES
+	PIXEL_SENT_9TIMES,
+	PIXEL_SENT_10TIMES
 };
 #define m_DESIRED_PR_FACTOR	(0x0f << 0)
 #define v_DESIRED_PR_FACTOR(n)	(((n)&0x0f) << 0)
@@ -321,7 +319,7 @@ enum {
 #define v_PR_STUFFING(n)	(((n)&0x01) << 0)
 
 #define VP_REMAP			0x0803
-enum YCC422_SIZE{
+enum YCC422_SIZE {
 	YCC422_16BIT = 0,
 	YCC422_20BIT,
 	YCC422_24BIT
@@ -358,8 +356,7 @@ enum {
 #define m_OINTFULL_BYPASS	(1 << 1)
 #define m_OINTEMPTY_BYPASS	(1 << 0)
 
-
-/*Frame Composer Registers*/
+/* Frame Composer Registers */
 #define FRAME_COMPOSER_BASE		0x1000
 
 #define	FC_INVIDCONF			0x1000
@@ -493,7 +490,7 @@ enum {
 };
 
 #define	FC_AVICONF0			0x1019
-#define m_FC_RGC_YCC_2		(1 << 7)	//use for HDMI2.0 TX
+#define m_FC_RGC_YCC_2		(1 << 7)	/* use for HDMI2.0 TX */
 #define v_FC_RGC_YCC_2(n)	(((n)&0x01) << 7)
 #define m_FC_ACTIV_FORMAT	(1 << 6)
 #define v_FC_ACTIV_FORMAT(n)	(((n)&0x01) << 6)
@@ -523,7 +520,7 @@ enum {
 #define v_FC_NUN_PIC_SCALE(n)	(((n)&0x03) << 0)
 
 #define	FC_AVIVID			0x101c
-#define m_FC_AVIVID_H		(1 << 7)	//use for HDMI2.0 TX
+#define m_FC_AVIVID_H		(1 << 7)	/* use for HDMI2.0 TX */
 #define v_FC_AVIVID_H(n)	(((n)&0x01) << 7)
 #define m_FC_AVIVID		(0x7f << 0)
 #define v_FC_AVIVID(n)		(((n)&0x7f) << 0)
@@ -552,7 +549,7 @@ enum {
 #define	FC_AUDICONF2			0x1027
 
 #define	FC_AUDICONF3			0x1028
-#define m_FC_LFE_PBL		(0x03 << 5)	//only use for HDMI1.4 TX
+#define m_FC_LFE_PBL		(0x03 << 5)	/* only use for HDMI1.4 TX */
 #define v_FC_LFE_PBL(n)		(((n)&0x03) << 5)
 #define m_FC_DM_INH		(1 << 4)
 #define v_FC_DM_INH(n)		(((n)&0x01) << 4)
@@ -563,9 +560,9 @@ enum {
 #define	FC_VSDSIZE			0x102a
 #define	FC_VSDIEEEID1			0x1030
 #define	FC_VSDIEEEID0			0x1031
-#define	FC_VSDPAYLOAD0 			0x1032	//0~23
-#define	FC_SPDVENDORNAME0 		0x104a	//0~7
-#define	FC_SPDPRODUCTNAME0 		0x1052	//0~15
+#define	FC_VSDPAYLOAD0			0x1032	/* 0~23 */
+#define	FC_SPDVENDORNAME0		0x104a	/* 0~7 */
+#define	FC_SPDPRODUCTNAME0		0x1052	/* 0~15 */
 #define	FC_SPDDEVICEINF			0x1062
 
 #define	FC_AUDSCONF			0x1063
@@ -577,16 +574,16 @@ enum {
 #define	FC_AUDSSTAT			0x1064
 #define	FC_AUDSV			0x1065
 #define	FC_AUDSU			0x1066
-#define	FC_AUDSCHNLS0			0x1067	//0~8
-#define	FC_CTRLQHIGH 			0x1073
+#define	FC_AUDSCHNLS0			0x1067	/* 0~8 */
+#define	FC_CTRLQHIGH			0x1073
 #define	FC_CTRLQLOW			0x1074
 #define	FC_ACP0				0x1075
-#define	FC_ACP16 			0x1082	//16~1
-#define	FC_ISCR1_0 			0x1092
-#define	FC_ISCR1_16			0x1093	//16~1
-#define	FC_ISCR2_15 			0x10a3	//15~0
+#define	FC_ACP16			0x1082	/* 16~1 */
+#define	FC_ISCR1_0			0x1092
+#define	FC_ISCR1_16			0x1093	/* 16~1 */
+#define	FC_ISCR2_15			0x10a3	/* 15~0 */
 
-#define	FC_DATAUTO0 			0x10b3
+#define	FC_DATAUTO0			0x10b3
 #define m_SPD_AUTO		(1 << 4)
 #define v_SPD_AUTO(n)		(((n)&0x01) << 4)
 #define m_VSD_AUTO		(1 << 3)
@@ -622,11 +619,11 @@ enum {
 #define	FC_RDRB5			0x10bd
 #define	FC_RDRB6			0x10be
 #define	FC_RDRB7			0x10bf
-#define	FC_MASK0 			0x10d2
-#define	FC_MASK1 			0x10d6
-#define	FC_MASK2 			0x10da
+#define	FC_MASK0			0x10d2
+#define	FC_MASK1			0x10d6
+#define	FC_MASK2			0x10da
 
-#define	FC_PRCONF 			0x10e0
+#define	FC_PRCONF			0x10e0
 #define m_FC_PR_FACTOR		(0x0f << 4)
 #define v_FC_PR_FACTOR(n)	(((n)&0x0f) << 4)
 
@@ -641,42 +638,41 @@ enum {
 #define	FC_GMD_UP			0x1102
 #define	FC_GMD_CONF			0x1103
 #define	FC_GMD_HB			0x1104
-#define	FC_GMD_PB0			0x1105	//0~27
+#define	FC_GMD_PB0			0x1105	/* 0~27 */
 
-#define	FC_DBGFORCE 			0x1200
+#define FC_DBGFORCE			0x1200
 #define m_FC_FORCEAUDIO		(1 << 4)
 #define v_FC_FORCEAUDIO(n)	(((n)&0x01) << 4)
 #define m_FC_FORCEVIDEO		(1 << 0)
 #define v_FC_FORCEVIDEO(n)	(((n)&0x01) << 0)
 
-#define	FC_DBGAUD0CH0			0x1201	//aud0~aud2 ch0
-#define	FC_DBGAUD0CH1 			0x1204	//aud0~aud2 ch1
-#define	FC_DBGAUD0CH2 			0x1207	//aud0~aud2 ch2
-#define	FC_DBGAUD0CH3 			0x120a	//aud0~aud2 ch3
-#define	FC_DBGAUD0CH4 			0x120d	//aud0~aud2 ch4
-#define	FC_DBGAUD0CH5 			0x1210	//aud0~aud2 ch5
-#define	FC_DBGAUD0CH6 			0x1213	//aud0~aud2 ch6
-#define	FC_DBGAUD0CH7 			0x1216	//aud0~aud2 ch7
-#define	FC_DBGTMDS0 			0x1219
+#define	FC_DBGAUD0CH0			0x1201	/* aud0~aud2 ch0 */
+#define	FC_DBGAUD0CH1			0x1204	/* aud0~aud2 ch1 */
+#define	FC_DBGAUD0CH2			0x1207	/* aud0~aud2 ch2 */
+#define	FC_DBGAUD0CH3			0x120a	/* aud0~aud2 ch3 */
+#define	FC_DBGAUD0CH4			0x120d	/* aud0~aud2 ch4 */
+#define	FC_DBGAUD0CH5			0x1210	/* aud0~aud2 ch5 */
+#define	FC_DBGAUD0CH6			0x1213	/* aud0~aud2 ch6 */
+#define	FC_DBGAUD0CH7			0x1216	/* aud0~aud2 ch7 */
+#define	FC_DBGTMDS0			0x1219
 #define	FC_DBGTMDS1			0x121a
 #define	FC_DBGTMDS2			0x121b
 
-
-/*HDMI Source PHY Registers*/
+/* HDMI Source PHY Registers */
 #define HDMI_SOURCE_PHY_BASE		0x3000
 
 #define PHY_CONF0			0x3000
-#define m_POWER_DOWN_EN		(1 << 7)		//enable depend on PHY_GEN2=0 and PHY_EXTERNAL=0
+#define m_POWER_DOWN_EN		(1 << 7)	/* enable depend on PHY_GEN2=0 and PHY_EXTERNAL=0 */
 #define v_POWER_DOWN_EN(n)	(((n)&0x01) << 7)
-#define m_TMDS_EN		(1 << 6)		//enable depend on PHY_GEN2=0 and PHY_EXTERNAL=0
+#define m_TMDS_EN		(1 << 6)	/* enable depend on PHY_GEN2=0 and PHY_EXTERNAL=0 */
 #define v_TMDS_EN(n)		(((n)&0x01) << 6)
-#define	m_SVSRET_SIG		(1 << 5)		//depend on PHY_MHL_COMB0=1
+#define	m_SVSRET_SIG		(1 << 5)	/* depend on PHY_MHL_COMB0=1 */
 #define v_SVSRET_SIG(n)		(((n)&0x01) << 5)
-#define m_PDDQ_SIG		(1 << 4)		//depend on PHY_GEN2=1 or PHY_EXTERNAL=1
+#define m_PDDQ_SIG		(1 << 4)	/* depend on PHY_GEN2=1 or PHY_EXTERNAL=1 */
 #define v_PDDQ_SIG(n)		(((n)&0x01) << 4)
-#define m_TXPWRON_SIG		(1 << 3)		//depend on PHY_GEN2=1 or PHY_EXTERNAL=1
+#define m_TXPWRON_SIG		(1 << 3)	/* depend on PHY_GEN2=1 or PHY_EXTERNAL=1 */
 #define v_TXPWRON_SIG(n)	(((n)&0x01) << 3)
-#define m_ENHPD_RXSENSE_SIG	(1 << 2)		//depend on PHY_GEN2=1 or PHY_EXTERNAL=1
+#define m_ENHPD_RXSENSE_SIG	(1 << 2)	/* depend on PHY_GEN2=1 or PHY_EXTERNAL=1 */
 #define v_ENHPD_RXSENSE_SIG(n)	(((n)&0x01) << 2)
 #define m_SEL_DATAEN_POL	(1 << 1)
 #define v_SEL_DATAEN_POL(n)	(((n)&0x01) << 1)
@@ -713,8 +709,7 @@ enum {
 #define PHY_PLLCFGFREQ1			0x300b
 #define PHY_PLLCFGFREQ2			0x300c
 
-
-/*I2C Master PHY Registers*/
+/* I2C Master PHY Registers */
 #define I2C_MASTER_PHY_BASE		0x3020
 
 #define	PHY_I2CM_SLAVE			0x3020
@@ -772,8 +767,7 @@ enum {
 #define	PHY_I2CM_FS_SCL_LCNT_0_ADDR	0x3032
 #define	PHY_I2CM_SDA_HOLD		0x3033
 
-
-/*Audio Sampler Registers*/
+/* Audio Sampler Registers */
 #define AUDIO_SAMPLER_BASE		0x3100
 
 #define AUD_CONF0			0x3100
@@ -811,9 +805,9 @@ enum I2S_WIDTH {
 	I2S_19BIT_SAMPLE,
 	I2S_20BIT_SAMPLE,
 	I2S_21BIT_SAMPLE,
-        I2S_22BIT_SAMPLE,
-        I2S_23BIT_SAMPLE,
-        I2S_24BIT_SAMPLE,
+	I2S_22BIT_SAMPLE,
+	I2S_23BIT_SAMPLE,
+	I2S_24BIT_SAMPLE,
 };
 #define m_I2S_WIDTH		(0x1f << 0)
 #define v_I2S_WIDTH(n)		(((n)&0x1f) << 0)
@@ -838,31 +832,31 @@ enum I2S_WIDTH {
 
 /***************N-CTS Table**************/
 /*	TMDS LOWCLK:	<=148.5M	*/
-/*	TMDS MIDCLK: 	297M		*/
-/*	TMDS HIGHCLK: 	594M		*/
-#define N_32K_LOWCLK 		0x1000
+/*	TMDS MIDCLK:	297M		*/
+/*	TMDS HIGHCLK:	594M		*/
+#define N_32K_LOWCLK		0x1000
 #define N_32K_MIDCLK		0x0c00
 #define N_32K_HIGHCLK		0x0c00
-#define N_441K_LOWCLK 		0x1880
+#define N_441K_LOWCLK		0x1880
 #define N_441K_MIDCLK		0x1260
 #define N_441K_HIGHCLK		0x24c0
-#define N_48K_LOWCLK 		0x1800
-#define N_48K_MIDCLK 		0x1400
-#define N_48K_HIGHCLK 		0x1800
-#define N_882K_LOWCLK 		0x3100
-#define N_882K_MIDCLK 		0x24c0
-#define N_882K_HIGHCLK 		0x4980
+#define N_48K_LOWCLK		0x1800
+#define N_48K_MIDCLK		0x1400
+#define N_48K_HIGHCLK		0x1800
+#define N_882K_LOWCLK		0x3100
+#define N_882K_MIDCLK		0x24c0
+#define N_882K_HIGHCLK		0x4980
 #define N_96K_LOWCLK		0x3000
 #define N_96K_MIDCLK		0x2800
 #define N_96K_HIGHCLK		0x3000
-#define N_1764K_LOWCLK 		0x6200
-#define N_1764K_MIDCLK 		0x4980
-#define N_1764K_HIGHCLK 	0x9300
-#define N_192K_LOWCLK 		0x6000
-#define N_192K_MIDCLK 		0x5000
-#define N_192K_HIGHCLK 		0x6000
-
-#define CALC_CTS(N, TMDSCLK, FS)	((N) / 32) * (TMDSCLK) / ((FS) * 4)
+#define N_1764K_LOWCLK		0x6200
+#define N_1764K_MIDCLK		0x4980
+#define N_1764K_HIGHCLK		0x9300
+#define N_192K_LOWCLK		0x6000
+#define N_192K_MIDCLK		0x5000
+#define N_192K_HIGHCLK		0x6000
+
+#define CALC_CTS(N, TMDSCLK, FS)	(((N) / 32) * (TMDSCLK) / ((FS) * 4))
 /****************************************/
 
 #define AUD_N1				0x3200
@@ -921,8 +915,7 @@ enum {
 #define m_SPDIF_WIDTH		(0x1f << 0)
 #define v_SPDIF_WIDTH(n)	(((n)&0x1f) << 0)
 
-
-/*Generic Parallel Audio Interface Registers*/
+/* Generic Parallel Audio Interface Registers */
 #define GP_AUDIO_INTERFACE_BASE		0x3500
 
 #define	GP_CONF0			0x3500
@@ -930,29 +923,27 @@ enum {
 #define	GP_CONF2			0x3502
 #define	GP_MASK				0x3506
 
-
-/*Audio DMA Registers*/
+/* Audio DMA Registers */
 #define AUDIO_DMA_BASE			0x3600
 
 #define	AHB_DMA_CONF0			0x3600
 #define	AHB_DMA_START			0x3601
 #define	AHB_DMA_STOP			0x3602
 #define	AHB_DMA_THRSLD			0x3603
-#define	AHB_DMA_STRADDR_SET0_0		0x3604	//0~3
-#define	AHB_DMA_STPADDR_SET0_0 		0x3608	//0~3
-#define	AHB_DMA_BSTADDR0 		0x360c	//0~3
-#define	AHB_DMA_MBLENGTH0 		0x3610	//0~3,
-#define	AHB_DMA_MASK 			0x3614
-#define	AHB_DMA_CONF1 			0x3616
-#define	AHB_DMA_BUFFMASK 		0x3619
-#define	AHB_DMA_MASK1 			0x361b
+#define	AHB_DMA_STRADDR_SET0_0		0x3604	/* 0~3 */
+#define	AHB_DMA_STPADDR_SET0_0		0x3608	/* 0~3 */
+#define	AHB_DMA_BSTADDR0		0x360c	/* 0~3 */
+#define	AHB_DMA_MBLENGTH0		0x3610	/* 0~3 */
+#define	AHB_DMA_MASK			0x3614
+#define	AHB_DMA_CONF1			0x3616
+#define	AHB_DMA_BUFFMASK		0x3619
+#define	AHB_DMA_MASK1			0x361b
 #define	AHB_DMA_STATUS			0x361c
 #define	AHB_DMA_CONF2			0x361d
-#define	AHB_DMA_STRADDR_SET1_0 		0x3620	//0~3
-#define	AHB_DMA_STPADDR_SET1_0 		0x3624 	//0~3
-
+#define	AHB_DMA_STRADDR_SET1_0		0x3620	/* 0~3 */
+#define	AHB_DMA_STPADDR_SET1_0		0x3624	/* 0~3 */
 
-/*Main Controller Registers*/
+/* Main Controller Registers */
 #define MAIN_CONTROLLER_BASE		0x4000
 
 #define MC_CLKDIS			0x4001
@@ -982,8 +973,8 @@ enum {
 #define v_II2S_SWRST(n)         (((n)&0x01) << 3)
 #define m_PREP_SWRST            (1 << 2)
 #define v_PREP_SWRST(n)         (((n)&0x01) << 2)
-#define m_TMDS_SWRST          	(1 << 1)
-#define v_TMDS_SWRST(n)       	(((n)&0x01) << 1)
+#define m_TMDS_SWRST		(1 << 1)
+#define v_TMDS_SWRST(n)		(((n)&0x01) << 1)
 #define m_PIXEL_SWRST           (1 << 0)
 #define v_PIXEL_SWRST(n)        (((n)&0x01) << 0)
 
@@ -1008,12 +999,12 @@ enum {
 #define v_TMDSCLK_ON(n)         (((n)&0x01) << 5)
 #define m_PREPCLK_ON            (1 << 4)
 #define v_PREPCLK_ON(n)         (((n)&0x01) << 4)
-#define m_I2SCLK_ON            	(1 << 3)
-#define v_I2SCLK_ON(n)         	(((n)&0x01) << 3)
+#define m_I2SCLK_ON		(1 << 3)
+#define v_I2SCLK_ON(n)		(((n)&0x01) << 3)
 #define m_SPDIFCLK_ON           (1 << 2)
-#define v_SPDIFCLK_ON(n)       	(((n)&0x01) << 2)
-#define m_CECCLK_ON            	(1 << 0)
-#define v_CECCLK_ON(n)         	(((n)&0x01) << 0)
+#define v_SPDIFCLK_ON(n)	(((n)&0x01) << 2)
+#define m_CECCLK_ON		(1 << 0)
+#define v_CECCLK_ON(n)		(((n)&0x01) << 0)
 
 #define MC_HEACPHY_RST			0x4007
 #define m_HEAC_PHY_RST		(1 << 0)
@@ -1027,8 +1018,7 @@ enum {
 #define m_AHB_AUD_DMA_RST       (1 << 7)
 #define v_AHB_AUD_DMA_RST(n)    (((n)&0x01) << 7)
 
-
-/*Color Space Converter Registers*/
+/* Color Space Converter Registers */
 #define COLOR_SPACE_CONVERTER_BASE	0x4100
 
 #define	CSC_CFG				0x4100
@@ -1040,8 +1030,8 @@ enum {
 #define	CSC_SCALE			0x4101
 #define m_CSC_COLOR_DEPTH	(0x0f << 4)
 #define v_CSC_COLOR_DEPTH(n)	(((n)&0x0f) << 4)
-#define m_CSC_SCALE       	(0x03 << 0)
-#define v_CSC_SCALE(n)       	(((n)&0x03) << 0)
+#define m_CSC_SCALE		(0x03 << 0)
+#define v_CSC_SCALE(n)		(((n)&0x03) << 0)
 
 #define	CSC_COEF_A1_MSB			0x4102
 #define	CSC_COEF_A1_LSB			0x4103
@@ -1070,11 +1060,10 @@ enum {
 #define	CSC_SPARE_1			0x411a
 #define	CSC_SPARE_2			0x411b
 
-
-/*HDCP Encryption Engine Registers*/
+/* HDCP Encryption Engine Registers */
 #define HDCP_ENCRYPTION_ENGINE_BASE	0x5000
 
-#define	A_HDCPCFG0 			0x5000
+#define	A_HDCPCFG0			0x5000
 #define m_HDCP_ENHANCE_LIKE	(1 << 7)
 #define v_HDCP_ENHANCE_LIKE(n)	(((n)&0x01) << 7)
 #define m_I2C_FAST_MODE		(1 << 6)
@@ -1153,7 +1142,7 @@ enum {
 #define v_HSYNC_POL(n)		(((n)&0x01) << 1)
 
 #define	A_OESSWCFG			0x500a
-#define	A_COREVERLSB 			0x5014
+#define	A_COREVERLSB			0x5014
 #define	A_COREVERMSB			0x5015
 
 #define	A_KSVMEMCTRL			0x5016
@@ -1165,7 +1154,7 @@ enum {
 #define m_KSV_MEM_REQ		(1 << 0)
 #define v_KSV_MEM_REQ(n)	(((n)&0x01) << 0)
 
-#define	HDCP_BSTATUS_0 			0x5020
+#define	HDCP_BSTATUS_0			0x5020
 #define m_MAX_DEVS_EXCEEDED	(1 << 7)
 #define m_DEVICE_COUNT		(0x7f << 0)
 
@@ -1178,14 +1167,13 @@ enum {
 #define	HDCP_M0_5			0x5027
 #define	HDCP_M0_6			0x5028
 #define	HDCP_M0_7			0x5029
-#define	HDCP_KSV			0x502a	//0~634
-#define	HDCP_VH 			0x52a5	//0~19
-#define	HDCP_REVOC_SIZE_0 		0x52b9
+#define	HDCP_KSV			0x502a	/* 0~634 */
+#define	HDCP_VH				0x52a5	/* 0~19 */
+#define	HDCP_REVOC_SIZE_0		0x52b9
 #define	HDCP_REVOC_SIZE_1		0x52ba
-#define	HDCP_REVOC_LIST			0x52bb	//0~5059
-
+#define	HDCP_REVOC_LIST			0x52bb	/* 0~5059 */
 
-/*HDCP BKSV Registers*/
+/* HDCP BKSV Registers */
 #define HDCP_BKSV_BASE			0x7800
 
 #define	HDCPREG_BKSV0			0x7800
@@ -1194,8 +1182,7 @@ enum {
 #define	HDCPREG_BKSV3			0x7803
 #define	HDCPREG_BKSV4			0x7804
 
-
-/*HDCP AN Registers*/
+/* HDCP AN Registers */
 #define HDCP_AN_BASE			0x7805
 
 #define	HDCPREG_ANCONF			0x7805
@@ -1211,13 +1198,12 @@ enum {
 #define	HDCPREG_AN6			0x780c
 #define	HDCPREG_AN7			0x780d
 
-
-/*Encrypted DPK Embedded Storage Registers*/
+/* Encrypted DPK Embedded Storage Registers */
 #define ENCRYPTED_DPK_EMBEDDED_BASE	0x780e
 
-#define	HDCPREG_RMCTL 			0x780e
+#define	HDCPREG_RMCTL			0x780e
 #define m_DPK_DECRYPT_EN	(1 << 0)
-#define v_DPK_DECRYPT_EN(n)	(((n)&0x01) <<0)
+#define v_DPK_DECRYPT_EN(n)	(((n)&0x01) << 0)
 
 #define	HDCPREG_RMSTS			0x780f
 #define m_DPK_WR_OK_STS		(1 << 6)
@@ -1233,26 +1219,24 @@ enum {
 #define	HDCPREG_DPK5			0x7817
 #define	HDCPREG_DPK6			0x7818
 
-
-/*CEC Engine Registers*/
+/* CEC Engine Registers */
 #define CEC_ENGINE_BASE			0x7d00
 
-#define	CEC_CTRL 			0x7d00
-#define	CEC_MASK 			0x7d02
-#define	CEC_ADDR_L 			0x7d05
+#define	CEC_CTRL			0x7d00
+#define	CEC_MASK			0x7d02
+#define	CEC_ADDR_L			0x7d05
 #define	CEC_ADDR_H			0x7d06
 #define	CEC_TX_CNT			0x7d07
 #define	CEC_RX_CNT			0x7d08
-#define	CEC_TX_DATA0 			0x7d10	//txdata0~txdata15
-#define	CEC_RX_DATA0 			0x7d20	//rxdata0~rxdata15
-#define	CEC_LOCK 			0x7d30
+#define	CEC_TX_DATA0			0x7d10	/* txdata0~txdata15 */
+#define	CEC_RX_DATA0			0x7d20	/* rxdata0~rxdata15 */
+#define CEC_LOCK			0x7d30
 #define	CEC_WKUPCTRL			0x7d31
 
-
-/*I2C Master Registers*/
+/* I2C Master Registers */
 #define I2C_MASTER_BASE			0x7e00
 
-#define	I2CM_SLAVE 			0x7e00
+#define	I2CM_SLAVE			0x7e00
 #define	I2CM_ADDRESS			0x7e01
 #define	I2CM_DATAO			0x7e02
 #define	I2CM_DATAI			0x7e03
@@ -1316,19 +1300,19 @@ enum {
 #define m_I2CM_READ_UPDATE	(1 << 0)
 #define v_I2CM_READ_UPDATE(n)	(((n)&0x01) << 0)
 
-#define	I2CM_READ_BUFF0 		0x7e20	//buff0~buff7
-#define	I2CM_SCDC_UPDATE0 		0x7e30
+#define	I2CM_READ_BUFF0			0x7e20	/* buff0~buff7 */
+#define	I2CM_SCDC_UPDATE0		0x7e30
 #define	I2CM_SCDC_UPDATE1		0x7e31
 
-
-
-/*********************************************HDMI TX PHY Define Start*********************************************/
+/*
+* HDMI TX PHY Define Start
+*/
 #define PHYTX_OPMODE_PLLCFG		0x06
 enum {
-	PREP_DIV_BY_2 = 0,	//16 bits
-	PREP_DIV_BY_15,		//12 bits
-	PREP_DIV_BY_125,	//10 bits
-	PREP_DIV_BY_1,		//8 bits
+	PREP_DIV_BY_2 = 0,	/* 16 bits */
+	PREP_DIV_BY_15,		/* 12 bits */
+	PREP_DIV_BY_125,	/* 10 bits */
+	PREP_DIV_BY_1,		/* 8 bits */
 };
 #define m_PREP_DIV		(0x03 << 13)
 #define v_PREP_DIV(n)		(((n)&0x03) << 13)
@@ -1340,7 +1324,7 @@ enum {
 };
 #define m_TMDS_CNTRL		(0x03 << 11)
 #define v_TMDS_CNTRL(n)		(((n)&0x03) << 11)
-enum OPMODE{
+enum OPMODE {
 	OP_HDMI_14 = 0,
 	OP_HDMI_20,
 };
@@ -1404,7 +1388,7 @@ enum {
 #define m_MPLL_GMP_CNTRL	(0x03 << 0)
 #define v_MPLL_GMP_CNTRL(n)	(((n)&0x03) << 0)
 
-enum TERM_RESIS{
+enum TERM_RESIS {
 	R50_Ohms = 0,
 	R5714_Ohms,
 	R6667_Ohms,
@@ -1418,7 +1402,6 @@ enum TERM_RESIS{
 #define m_TX_TERM		(0x07 << 0)
 #define v_TX_TERM(n)		(((n)&0x07) << 0)
 
-
 struct phy_mpll_config_tab {
 	u32 pix_clock;
 	u8 pix_repet;
@@ -1435,9 +1418,9 @@ struct phy_mpll_config_tab {
 	u16 gmp_cntrl;
 };
 
-/********************************************* HDMI TX PHY Define End *********************************************/
-
-
+/*
+* HDMI TX PHY Define End
+*/
 
 struct rk3288_hdmi_reg_table {
 	int reg_base;
@@ -1445,52 +1428,54 @@ struct rk3288_hdmi_reg_table {
 };
 
 struct rk3288_hdmi_device {
-	int			irq;
-	void __iomem  		*regbase;
-	int			regbase_phy;
-	int			regsize_phy;
-	int 			lcdc_id;
-	int			i2cm_int;
-	int 			phy_i2cm_int;
-	unsigned char		clk_on;
-	struct mutex 		int_mutex;
-	struct device 		*dev;
-	struct clk		*pd;
-	struct clk		*pclk;				//HDMI AHP clk
-	struct clk		*hdcp_clk;
-	struct hdmi 		driver;
-        struct dentry           *debugfs_dir;
+	int irq;
+	void __iomem *regbase;
+	int regbase_phy;
+	int regsize_phy;
+	int lcdc_id;
+	int i2cm_int;
+	int phy_i2cm_int;
+	unsigned char clk_on;
+	struct mutex int_mutex;
+	struct device *dev;
+	struct clk *pd;
+	struct clk *pclk;	/* HDMI AHP clk */
+	struct clk *hdcp_clk;
+	struct hdmi driver;
+	struct dentry *debugfs_dir;
 #ifdef HDMI_INT_USE_POLL
-	struct delayed_work	delay_work;
+	struct delayed_work delay_work;
 #endif
 };
 
-
 static inline u32 hdmi_readl(struct rk3288_hdmi_device *hdmi_dev, u16 offset)
 {
 	return readl_relaxed(hdmi_dev->regbase + (offset) * 0x04);
 }
 
-static inline int hdmi_writel(struct rk3288_hdmi_device *hdmi_dev, u16 offset, u32 val)
+static inline int hdmi_writel(struct rk3288_hdmi_device *hdmi_dev, u16 offset,
+			      u32 val)
 {
-        int ret = 0;
-        writel_relaxed(val, hdmi_dev->regbase + (offset) * 0x04);
-        return ret;
+	int ret = 0;
+	writel_relaxed(val, hdmi_dev->regbase + (offset) * 0x04);
+	return ret;
 }
 
-static inline int hdmi_msk_reg(struct rk3288_hdmi_device *hdmi_dev, u16 offset, u32 msk, u32 val)
+static inline int hdmi_msk_reg(struct rk3288_hdmi_device *hdmi_dev, u16 offset,
+			       u32 msk, u32 val)
 {
-        int ret = 0;
-        u32 temp;
-        temp = readl_relaxed(hdmi_dev->regbase + (offset) * 0x04) & (0xFF - (msk));
-        writel_relaxed(temp | ( (val) & (msk) ),  hdmi_dev->regbase + (offset) * 0x04);
-        return ret;
+	int ret = 0;
+	u32 temp;
+	temp =
+	    readl_relaxed(hdmi_dev->regbase + (offset) * 0x04) & (0xFF - (msk));
+	writel_relaxed(temp | ((val) & (msk)),
+		       hdmi_dev->regbase + (offset) * 0x04);
+	return ret;
 }
 
-
 int rk3288_hdmi_initial(struct hdmi *hdmi_drv);
 void rk3288_hdmi_control_output(struct hdmi *hdmi_drv, int enable);
-int rk3288_hdmi_config_phy(struct hdmi *hdmi_drv, unsigned char pixel_repet, unsigned char color_depth);
-
+int rk3288_hdmi_config_phy(struct hdmi *hdmi_drv, unsigned char pixel_repet,
+			   unsigned char color_depth);
 
 #endif
-- 
2.35.3

