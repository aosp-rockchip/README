From 44d7c4c0d2e2abd1774d4c4b1fa7514a7b852212 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E5=BC=A0=E6=98=8A?= <zhanghao@rock-chips.com>
Date: Fri, 18 Nov 2011 10:44:59 +0800
Subject: [PATCH] wm831x:fix building error

---
 drivers/mfd/wm831x-core.c              |  32 ++------
 drivers/mfd/wm831x-i2c.c               |  58 +++----------
 drivers/mfd/wm831x-irq.c               | 109 ++++---------------------
 drivers/mfd/wm831x-spi.c               |  70 ++--------------
 drivers/power/wm831x_charger_display.c |  67 +++++++++++++--
 drivers/power/wm831x_power.c           |  16 ++--
 drivers/regulator/wm831x-dcdc.c        |  95 ++++++++++++---------
 drivers/regulator/wm831x-isink.c       |   8 +-
 drivers/regulator/wm831x-ldo.c         |  82 ++++++++-----------
 drivers/video/backlight/wm831x_bl.c    |   8 +-
 include/linux/mfd/wm831x/core.h        |  36 +++++---
 include/linux/mfd/wm831x/pdata.h       |  19 +----
 include/linux/mfd/wm8994/pdata.h       |  88 +-------------------
 13 files changed, 236 insertions(+), 452 deletions(-)
 mode change 100644 => 100755 drivers/mfd/wm831x-core.c
 mode change 100644 => 100755 drivers/mfd/wm831x-i2c.c
 mode change 100644 => 100755 drivers/mfd/wm831x-spi.c
 mode change 100644 => 100755 include/linux/mfd/wm831x/core.h
 mode change 100644 => 100755 include/linux/mfd/wm8994/pdata.h

diff --git a/drivers/mfd/wm831x-core.c b/drivers/mfd/wm831x-core.c
old mode 100644
new mode 100755
index 11a390a02e28..1bfd65bd3743
--- a/drivers/mfd/wm831x-core.c
+++ b/drivers/mfd/wm831x-core.c
@@ -1460,7 +1460,7 @@ int wm831x_device_init(struct wm831x *wm831x, unsigned long id, int irq)
 	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
 	int rev;
 	enum wm831x_parent parent;
-	int ret, i;
+	int ret;
 
 	mutex_init(&wm831x->io_lock);
 	mutex_init(&wm831x->key_lock);
@@ -1558,15 +1558,6 @@ int wm831x_device_init(struct wm831x *wm831x, unsigned long id, int irq)
 		dev_info(wm831x->dev, "WM8325 revision %c\n", 'A' + rev);
 		break;
 
-<<<<<<< HEAD
-	case WM8326:
-		parent = WM8326;
-		wm831x->num_gpio = 12;
-		dev_info(wm831x->dev, "WM8326 revision %c\n", 'A' + rev);
-		break;
-
-=======
->>>>>>> parent of 15f7fab... temp revert rk change
 	default:
 		dev_err(wm831x->dev, "Unknown WM831x device %04x\n", ret);
 		ret = -EINVAL;
@@ -1601,17 +1592,6 @@ int wm831x_device_init(struct wm831x *wm831x, unsigned long id, int irq)
 		}
 	}
 
-	if (pdata) {
-		for (i = 0; i < ARRAY_SIZE(pdata->gpio_defaults); i++) {
-			if (!pdata->gpio_defaults[i])
-				continue;
-
-			wm831x_reg_write(wm831x,
-					 WM831X_GPIO1_CONTROL + i,
-					 pdata->gpio_defaults[i] & 0xffff);
-		}
-	}
-
 	ret = wm831x_irq_init(wm831x, irq);
 	if (ret != 0)
 		goto err;
@@ -1647,9 +1627,12 @@ int wm831x_device_init(struct wm831x *wm831x, unsigned long id, int irq)
 		break;
 
 	case WM8320:
+		ret = mfd_add_devices(wm831x->dev, -1,
+				      wm8320_devs, ARRAY_SIZE(wm8320_devs),
+				      NULL, 0);
+		break;
+
 	case WM8321:
-	case WM8325:
-	case WM8326:
 		ret = mfd_add_devices(wm831x->dev, -1,
 				      wm8320_devs, ARRAY_SIZE(wm8320_devs),
 				      NULL, 0);
@@ -1766,8 +1749,6 @@ int wm831x_device_suspend(struct wm831x *wm831x)
 
 	return 0;
 }
-<<<<<<< HEAD
-=======
 void wm831x_enter_sleep(void){
 #if 1//def CONFIG_RK2818_SOC_PM
 	struct regulator *dcdc;
@@ -1861,7 +1842,6 @@ int wm831x_device_restart(struct wm831x *wm831x)
 	return 0;
 }
 
->>>>>>> parent of 15f7fab... temp revert rk change
 
 MODULE_DESCRIPTION("Core support for the WM831X AudioPlus PMIC");
 MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/wm831x-i2c.c b/drivers/mfd/wm831x-i2c.c
old mode 100644
new mode 100755
index a905baf527bb..3d109a52cd56
--- a/drivers/mfd/wm831x-i2c.c
+++ b/drivers/mfd/wm831x-i2c.c
@@ -52,27 +52,6 @@ static int wm831x_i2c_write_device(struct wm831x *wm831x, unsigned short reg,
 				   int bytes, void *src)
 {
 	struct i2c_client *i2c = wm831x->control_data;
-<<<<<<< HEAD
-	struct i2c_msg xfer[2];
-	int ret;
-
-	reg = cpu_to_be16(reg);
-
-	xfer[0].addr = i2c->addr;
-	xfer[0].flags = 0;
-	xfer[0].len = 2;
-	xfer[0].buf = (char *)&reg;
-
-	xfer[1].addr = i2c->addr;
-	xfer[1].flags = I2C_M_NOSTART;
-	xfer[1].len = bytes;
-	xfer[1].buf = (char *)src;
-
-	ret = i2c_transfer(i2c->adapter, xfer, 2);
-	if (ret < 0)
-		return ret;
-	if (ret != 2)
-=======
 	unsigned char msg[bytes + 2];
 	int ret;
 
@@ -84,7 +63,6 @@ static int wm831x_i2c_write_device(struct wm831x *wm831x, unsigned short reg,
 	if (ret < 0)
 		return ret;
 	if (ret < bytes + 2)
->>>>>>> parent of 15f7fab... temp revert rk change
 		return -EIO;
 
 	return 0;
@@ -94,19 +72,13 @@ static int wm831x_i2c_probe(struct i2c_client *i2c,
 			    const struct i2c_device_id *id)
 {
 	struct wm831x *wm831x;
-<<<<<<< HEAD
-
-=======
 	int ret,gpio,irq;
 
->>>>>>> parent of 15f7fab... temp revert rk change
 	wm831x = kzalloc(sizeof(struct wm831x), GFP_KERNEL);
 	if (wm831x == NULL)
 		return -ENOMEM;
 
 	i2c_set_clientdata(i2c, wm831x);
-<<<<<<< HEAD
-=======
 	
 	gpio = i2c->irq;
 	ret = gpio_request(gpio, "wm831x");
@@ -121,17 +93,12 @@ static int wm831x_i2c_probe(struct i2c_client *i2c,
 	}	
 	irq = gpio_to_irq(gpio);
 	
->>>>>>> parent of 15f7fab... temp revert rk change
 	wm831x->dev = &i2c->dev;
 	wm831x->control_data = i2c;
 	wm831x->read_dev = wm831x_i2c_read_device;
 	wm831x->write_dev = wm831x_i2c_write_device;
 
-<<<<<<< HEAD
-	return wm831x_device_init(wm831x, id->driver_data, i2c->irq);
-=======
 	return wm831x_device_init(wm831x, id->driver_data, irq);
->>>>>>> parent of 15f7fab... temp revert rk change
 }
 
 static int wm831x_i2c_remove(struct i2c_client *i2c)
@@ -143,16 +110,16 @@ static int wm831x_i2c_remove(struct i2c_client *i2c)
 	return 0;
 }
 
-static int wm831x_i2c_suspend(struct device *dev)
+static int wm831x_i2c_suspend(struct i2c_client *i2c, pm_message_t mesg)
 {
-	struct wm831x *wm831x = dev_get_drvdata(dev);
+	struct wm831x *wm831x = i2c_get_clientdata(i2c);
 
 	return wm831x_device_suspend(wm831x);
 }
 
-static int wm831x_i2c_resume(struct device *dev)
+static int wm831x_i2c_resume(struct i2c_client *i2c)
 {
-	struct wm831x *wm831x = dev_get_drvdata(dev);
+	struct wm831x *wm831x = i2c_get_clientdata(i2c);
 	int i;
 	//set some intterupt again while resume 
 	for (i = 0; i < ARRAY_SIZE(wm831x->irq_masks_cur); i++) {
@@ -184,24 +151,20 @@ static const struct i2c_device_id wm831x_i2c_id[] = {
 	{ "wm8320", WM8320 },
 	{ "wm8321", WM8321 },
 	{ "wm8325", WM8325 },
-	{ "wm8326", WM8326 },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, wm831x_i2c_id);
 
-static const struct dev_pm_ops wm831x_pm_ops = {
-	.suspend = wm831x_i2c_suspend,
-	.resume = wm831x_i2c_resume,
-};
 
 static struct i2c_driver wm831x_i2c_driver = {
 	.driver = {
-		.name = "wm831x",
-		.owner = THIS_MODULE,
-		.pm = &wm831x_pm_ops,
+		   .name = "wm831x",
+		   .owner = THIS_MODULE,
 	},
 	.probe = wm831x_i2c_probe,
 	.remove = wm831x_i2c_remove,
+	.suspend = wm831x_i2c_suspend,
+	.resume = wm831x_i2c_resume,
 	.shutdown = wm831x_i2c_shutdown,
 	.id_table = wm831x_i2c_id,
 };
@@ -209,7 +172,6 @@ static struct i2c_driver wm831x_i2c_driver = {
 static int __init wm831x_i2c_init(void)
 {
 	int ret;
-
 	printk("%s \n", __FUNCTION__);
 	ret = i2c_add_driver(&wm831x_i2c_driver);
 	if (ret != 0)
@@ -217,8 +179,8 @@ static int __init wm831x_i2c_init(void)
 
 	return ret;
 }
-subsys_initcall(wm831x_i2c_init);
-
+//subsys_initcall(wm831x_i2c_init);
+fs_initcall(wm831x_i2c_init);
 static void __exit wm831x_i2c_exit(void)
 {
 	i2c_del_driver(&wm831x_i2c_driver);
diff --git a/drivers/mfd/wm831x-irq.c b/drivers/mfd/wm831x-irq.c
index 5baffaaef70f..04f3a69943b7 100755
--- a/drivers/mfd/wm831x-irq.c
+++ b/drivers/mfd/wm831x-irq.c
@@ -18,15 +18,13 @@
 #include <linux/irq.h>
 #include <linux/mfd/core.h>
 #include <linux/interrupt.h>
-
+#include <linux/slab.h>
 #include <linux/mfd/wm831x/core.h>
 #include <linux/mfd/wm831x/pdata.h>
 #include <linux/mfd/wm831x/gpio.h>
 #include <linux/mfd/wm831x/irq.h>
 
 #include <linux/delay.h>
-<<<<<<< HEAD
-=======
 #include <linux/wakelock.h>
 /*
  * Since generic IRQs don't currently support interrupt controllers on
@@ -37,7 +35,6 @@
  * interrupts, but hopefully won't last too long.
  */
 #define WM831X_IRQ_TYPE IRQF_TRIGGER_LOW
->>>>>>> parent of 15f7fab... temp revert rk change
 
 struct wm831x_irq_data {
 	int primary;
@@ -405,28 +402,13 @@ static void wm831x_irq_disable(struct irq_data *data)
 	//printk("%s:irq=%d\n",__FUNCTION__,irq);
 }
 
-static void wm831x_irq_disable(unsigned int irq)
-{
-	struct wm831x *wm831x = get_irq_chip_data(irq);
-	struct wm831x_irq_data *irq_data = irq_to_wm831x_irq(wm831x, irq);
-
-	wm831x->irq_masks_cur[irq_data->reg - 1] |= irq_data->mask;
-	//printk("%s:irq=%d\n",__FUNCTION__,irq);
-}
-
 static int wm831x_irq_set_type(struct irq_data *data, unsigned int type)
 {
 	struct wm831x *wm831x = irq_data_get_irq_chip_data(data);
-	int val, irq;
-
-<<<<<<< HEAD
-	irq = data->irq - wm831x->irq_base;
+	int val, irq = 0;
 
-	if (irq < WM831X_IRQ_GPIO_1 || irq > WM831X_IRQ_GPIO_11) {
-=======
 	irq = irq - wm831x->irq_base;
 	if (irq < WM831X_IRQ_GPIO_1 || irq > WM831X_IRQ_GPIO_12) {
->>>>>>> parent of 15f7fab... temp revert rk change
 		/* Ignore internal-only IRQs */
 		if (irq >= 0 && irq < WM831X_NUM_IRQS)
 			return 0;
@@ -452,17 +434,17 @@ static int wm831x_irq_set_type(struct irq_data *data, unsigned int type)
 			       WM831X_GPN_INT_MODE | WM831X_GPN_POL, val);
 }
 
-static int wm831x_irq_set_wake(unsigned irq, unsigned state)
+static int wm831x_irq_set_wake(struct irq_data *data, unsigned state)
 {	
-	struct wm831x *wm831x = get_irq_chip_data(irq);	
-
+	struct wm831x *wm831x = irq_data_get_irq_chip_data(data);
+	int irq = data->irq;
 	//only wm831x irq
 	if ((irq > wm831x->irq_base + WM831X_IRQ_TEMP_THW) &&( irq < wm831x->irq_base + WM831X_NUM_IRQS)) 
 	{
 		if(state)
-		wm831x_irq_unmask(irq);	
+		wm831x_irq_enable(data);
 		else	
-		wm831x_irq_mask(irq);
+		wm831x_irq_disable(data);
 		return 0;
 	}
 	else
@@ -475,23 +457,13 @@ static int wm831x_irq_set_wake(unsigned irq, unsigned state)
 }
 
 static struct irq_chip wm831x_irq_chip = {
-<<<<<<< HEAD
 	.name			= "wm831x",
 	.irq_bus_lock		= wm831x_irq_lock,
 	.irq_bus_sync_unlock	= wm831x_irq_sync_unlock,
 	.irq_disable		= wm831x_irq_disable,
 	.irq_enable		= wm831x_irq_enable,
 	.irq_set_type		= wm831x_irq_set_type,
-=======
-	.name = "wm831x",
-	.bus_lock = wm831x_irq_lock,
-	.bus_sync_unlock = wm831x_irq_sync_unlock,
-	.disable = wm831x_irq_disable,
-	.mask = wm831x_irq_mask,
-	.unmask = wm831x_irq_unmask,
-	.set_type = wm831x_irq_set_type,
-	.set_wake	= wm831x_irq_set_wake,
->>>>>>> parent of 15f7fab... temp revert rk change
+	.irq_set_wake	= wm831x_irq_set_wake,
 };
 
 #if WM831X_IRQ_LIST
@@ -558,18 +530,6 @@ static void wm831x_irq_worker(struct work_struct *work)
 	
 	mutex_lock(&wm831x->irq_lock);
 
-	/* The touch interrupts are visible in the primary register as
-	 * an optimisation; open code this to avoid complicating the
-	 * main handling loop and so we can also skip iterating the
-	 * descriptors.
-	 */
-	if (primary & WM831X_TCHPD_INT)
-		handle_nested_irq(wm831x->irq_base + WM831X_IRQ_TCHPD);
-	if (primary & WM831X_TCHDATA_INT)
-		handle_nested_irq(wm831x->irq_base + WM831X_IRQ_TCHDATA);
-	if (primary & (WM831X_TCHDATA_EINT | WM831X_TCHPD_EINT))
-		goto out;
-
 	for (i = 0; i < ARRAY_SIZE(wm831x_irqs); i++) {
 		int offset = wm831x_irqs[i].reg - 1;
 		
@@ -630,9 +590,6 @@ static void wm831x_irq_worker(struct work_struct *work)
 	mutex_unlock(&wm831x->irq_lock);
 	
 out:
-	/* Touchscreen interrupts are handled specially in the driver */
-	status_regs[0] &= ~(WM831X_TCHDATA_EINT | WM831X_TCHPD_EINT);
-
 	for (i = 0; i < ARRAY_SIZE(status_regs); i++) {
 		if (status_regs[i])
 			wm831x_reg_write(wm831x, WM831X_INTERRUPT_STATUS_1 + i,
@@ -695,33 +652,18 @@ int wm831x_irq_init(struct wm831x *wm831x, int irq)
 				 0xffff);
 	}
 
+	if (!irq) {
+		dev_warn(wm831x->dev,
+			 "No interrupt specified - functionality limited\n");
+		return 0;
+	}
+
 	if (!pdata || !pdata->irq_base) {
 		dev_err(wm831x->dev,
 			"No interrupt base specified, no interrupts\n");
 		return 0;
 	}
 
-<<<<<<< HEAD
-	if (pdata->irq_cmos)
-		i = 0;
-	else
-		i = WM831X_IRQ_OD;
-
-	wm831x_set_bits(wm831x, WM831X_IRQ_CONFIG,
-			WM831X_IRQ_OD, i);
-
-	/* Try to flag /IRQ as a wake source; there are a number of
-	 * unconditional wake sources in the PMIC so this isn't
-	 * conditional but we don't actually care *too* much if it
-	 * fails.
-	 */
-	ret = enable_irq_wake(irq);
-	if (ret != 0) {
-		dev_warn(wm831x->dev, "Can't enable IRQ as wake source: %d\n",
-			 ret);
-	}
-
-=======
 	wm831x->irq_wq = create_singlethread_workqueue("wm831x-irq");
 	if (!wm831x->irq_wq) {
 		dev_err(wm831x->dev, "Failed to allocate IRQ worker\n");
@@ -729,7 +671,6 @@ int wm831x_irq_init(struct wm831x *wm831x, int irq)
 	}
 
 	
->>>>>>> parent of 15f7fab... temp revert rk change
 	wm831x->irq = irq;
 	wm831x->flag_suspend = 0;
 	wm831x->irq_base = pdata->irq_base;
@@ -737,7 +678,7 @@ int wm831x_irq_init(struct wm831x *wm831x, int irq)
 	wake_lock_init(&wm831x->irq_wake, WAKE_LOCK_SUSPEND, "wm831x_irq_wake");
 	wake_lock_init(&wm831x->handle_wake, WAKE_LOCK_SUSPEND, "wm831x_handle_wake");
 #if WM831X_IRQ_LIST
-	wm831x->handle_wq = create_rt_workqueue("wm831x_handle_wq");
+	wm831x->handle_wq = create_workqueue("wm831x_handle_wq");
 	if (!wm831x->handle_wq) {
 		printk("cannot create workqueue\n");
 		return -EBUSY;
@@ -764,25 +705,6 @@ int wm831x_irq_init(struct wm831x *wm831x, int irq)
 		irq_set_noprobe(cur_irq);
 #endif
 	}
-<<<<<<< HEAD
-
-	if (irq) {
-		ret = request_threaded_irq(irq, NULL, wm831x_irq_thread,
-					   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
-					   "wm831x", wm831x);
-		if (ret != 0) {
-			dev_err(wm831x->dev, "Failed to request IRQ %d: %d\n",
-				irq, ret);
-			return ret;
-		}
-	} else {
-		dev_warn(wm831x->dev,
-			 "No interrupt specified - functionality limited\n");
-	}
-
-
-
-=======
 #if (WM831X_IRQ_TYPE == IRQF_TRIGGER_LOW)
 	ret = request_threaded_irq(wm831x->irq, wm831x_irq_thread, NULL, 
 				 IRQF_TRIGGER_LOW| IRQF_ONESHOT,//IRQF_TRIGGER_FALLING, // 
@@ -799,7 +721,6 @@ int wm831x_irq_init(struct wm831x *wm831x, int irq)
 	}
 
 	enable_irq_wake(wm831x->irq); // so wm831x irq can wake up system
->>>>>>> parent of 15f7fab... temp revert rk change
 	/* Enable top level interrupts, we mask at secondary level */
 	wm831x_reg_write(wm831x, WM831X_SYSTEM_INTERRUPTS_MASK, 0);
 
diff --git a/drivers/mfd/wm831x-spi.c b/drivers/mfd/wm831x-spi.c
old mode 100644
new mode 100755
index 97c8dab6c954..5635be1c9622
--- a/drivers/mfd/wm831x-spi.c
+++ b/drivers/mfd/wm831x-spi.c
@@ -14,10 +14,10 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/pm.h>
 #include <linux/spi/spi.h>
 #include <linux/gpio.h>
 
+
 #include <linux/mfd/wm831x/core.h>
 
 static int wm831x_spi_read_device(struct wm831x *wm831x, unsigned short reg,
@@ -29,24 +29,14 @@ static int wm831x_spi_read_device(struct wm831x *wm831x, unsigned short reg,
 
 	/* Go register at a time */
 	for (r = reg; r < reg + (bytes / 2); r++) {
-<<<<<<< HEAD
-		tx_val = r | 0x8000;
-
-=======
 		tx_val = cpu_to_be16(r | 0x8000);
 		//printk("read:reg=0x%x,",reg);
->>>>>>> parent of 15f7fab... temp revert rk change
 		ret = spi_write_then_read(wm831x->control_data,
 					  (u8 *)&tx_val, 2, (u8 *)d, 2);
 		if (ret != 0)
 			return ret;
-<<<<<<< HEAD
-
-		*d = be16_to_cpu(*d);
-=======
 		//printk("rec=0x%x\n",be16_to_cpu(*d));
 		//*d = be16_to_cpu(*d);
->>>>>>> parent of 15f7fab... temp revert rk change
 
 		d++;
 	}
@@ -64,15 +54,9 @@ static int wm831x_spi_write_device(struct wm831x *wm831x, unsigned short reg,
 
 	/* Go register at a time */
 	for (r = reg; r < reg + (bytes / 2); r++) {
-<<<<<<< HEAD
-		data[0] = r;
-		data[1] = *s++;
-
-=======
 		data[0] = cpu_to_be16(r);
 		data[1] = *s++;
 		//printk("write:reg=0x%x,send=0x%x\n",reg, data[0]);
->>>>>>> parent of 15f7fab... temp revert rk change
 		ret = spi_write(spi, (char *)&data, sizeof(data));
 		if (ret != 0)
 			return ret;
@@ -85,12 +69,8 @@ static int __devinit wm831x_spi_probe(struct spi_device *spi)
 {
 	struct wm831x *wm831x;
 	enum wm831x_parent type;
-<<<<<<< HEAD
-
-=======
 	int ret,gpio,irq;
 
->>>>>>> parent of 15f7fab... temp revert rk change
 	/* Currently SPI support for ID tables is unmerged, we're faking it */
 	if (strcmp(spi->modalias, "wm8310") == 0)
 		type = WM8310;
@@ -104,8 +84,6 @@ static int __devinit wm831x_spi_probe(struct spi_device *spi)
 		type = WM8321;
 	else if (strcmp(spi->modalias, "wm8325") == 0)
 		type = WM8325;
-	else if (strcmp(spi->modalias, "wm8326") == 0)
-		type = WM8326;
 	else {
 		dev_err(&spi->dev, "Unknown device type\n");
 		return -EINVAL;
@@ -118,8 +96,6 @@ static int __devinit wm831x_spi_probe(struct spi_device *spi)
 	spi->bits_per_word = 16;
 	spi->mode = SPI_MODE_0;
 
-<<<<<<< HEAD
-=======
 	gpio = spi->irq;
 	ret = gpio_request(gpio, "wm831x");
 	if (ret) {
@@ -133,18 +109,13 @@ static int __devinit wm831x_spi_probe(struct spi_device *spi)
 	}	
 	irq = gpio_to_irq(gpio);
 
->>>>>>> parent of 15f7fab... temp revert rk change
 	dev_set_drvdata(&spi->dev, wm831x);
 	wm831x->dev = &spi->dev;
 	wm831x->control_data = spi;
 	wm831x->read_dev = wm831x_spi_read_device;
 	wm831x->write_dev = wm831x_spi_write_device;
 
-<<<<<<< HEAD
-	return wm831x_device_init(wm831x, type, spi->irq);
-=======
 	return wm831x_device_init(wm831x, type, irq);
->>>>>>> parent of 15f7fab... temp revert rk change
 }
 
 static int __devexit wm831x_spi_remove(struct spi_device *spi)
@@ -156,31 +127,24 @@ static int __devexit wm831x_spi_remove(struct spi_device *spi)
 	return 0;
 }
 
-static int wm831x_spi_suspend(struct device *dev)
+static int wm831x_spi_suspend(struct spi_device *spi, pm_message_t m)
 {
-	struct wm831x *wm831x = dev_get_drvdata(dev);
-
+	struct wm831x *wm831x = dev_get_drvdata(&spi->dev);
 	spin_lock(&wm831x->flag_lock);
 	wm831x->flag_suspend = 1;
 	spin_unlock(&wm831x->flag_lock);
-
 	return wm831x_device_suspend(wm831x);
 }
 
-static const struct dev_pm_ops wm831x_spi_pm = {
-	.freeze = wm831x_spi_suspend,
-	.suspend = wm831x_spi_suspend,
-};
-
 static struct spi_driver wm8310_spi_driver = {
 	.driver = {
 		.name	= "wm8310",
 		.bus	= &spi_bus_type,
 		.owner	= THIS_MODULE,
-		.pm	= &wm831x_spi_pm,
 	},
 	.probe		= wm831x_spi_probe,
 	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
 };
 
 static struct spi_driver wm8311_spi_driver = {
@@ -188,10 +152,10 @@ static struct spi_driver wm8311_spi_driver = {
 		.name	= "wm8311",
 		.bus	= &spi_bus_type,
 		.owner	= THIS_MODULE,
-		.pm	= &wm831x_spi_pm,
 	},
 	.probe		= wm831x_spi_probe,
 	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
 };
 
 static struct spi_driver wm8312_spi_driver = {
@@ -199,10 +163,10 @@ static struct spi_driver wm8312_spi_driver = {
 		.name	= "wm8312",
 		.bus	= &spi_bus_type,
 		.owner	= THIS_MODULE,
-		.pm	= &wm831x_spi_pm,
 	},
 	.probe		= wm831x_spi_probe,
 	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
 };
 
 static struct spi_driver wm8320_spi_driver = {
@@ -210,10 +174,10 @@ static struct spi_driver wm8320_spi_driver = {
 		.name	= "wm8320",
 		.bus	= &spi_bus_type,
 		.owner	= THIS_MODULE,
-		.pm	= &wm831x_spi_pm,
 	},
 	.probe		= wm831x_spi_probe,
 	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
 };
 
 static struct spi_driver wm8321_spi_driver = {
@@ -221,10 +185,10 @@ static struct spi_driver wm8321_spi_driver = {
 		.name	= "wm8321",
 		.bus	= &spi_bus_type,
 		.owner	= THIS_MODULE,
-		.pm	= &wm831x_spi_pm,
 	},
 	.probe		= wm831x_spi_probe,
 	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
 };
 
 static struct spi_driver wm8325_spi_driver = {
@@ -232,21 +196,10 @@ static struct spi_driver wm8325_spi_driver = {
 		.name	= "wm8325",
 		.bus	= &spi_bus_type,
 		.owner	= THIS_MODULE,
-		.pm	= &wm831x_spi_pm,
-	},
-	.probe		= wm831x_spi_probe,
-	.remove		= __devexit_p(wm831x_spi_remove),
-};
-
-static struct spi_driver wm8326_spi_driver = {
-	.driver = {
-		.name	= "wm8326",
-		.bus	= &spi_bus_type,
-		.owner	= THIS_MODULE,
-		.pm	= &wm831x_spi_pm,
 	},
 	.probe		= wm831x_spi_probe,
 	.remove		= __devexit_p(wm831x_spi_remove),
+	.suspend	= wm831x_spi_suspend,
 };
 
 static int __init wm831x_spi_init(void)
@@ -277,17 +230,12 @@ static int __init wm831x_spi_init(void)
 	if (ret != 0)
 		pr_err("Failed to register WM8325 SPI driver: %d\n", ret);
 
-	ret = spi_register_driver(&wm8326_spi_driver);
-	if (ret != 0)
-		pr_err("Failed to register WM8326 SPI driver: %d\n", ret);
-
 	return 0;
 }
 subsys_initcall(wm831x_spi_init);
 
 static void __exit wm831x_spi_exit(void)
 {
-	spi_unregister_driver(&wm8326_spi_driver);
 	spi_unregister_driver(&wm8325_spi_driver);
 	spi_unregister_driver(&wm8321_spi_driver);
 	spi_unregister_driver(&wm8320_spi_driver);
diff --git a/drivers/power/wm831x_charger_display.c b/drivers/power/wm831x_charger_display.c
index 36fc26d04f7f..c08fa6bbcc18 100755
--- a/drivers/power/wm831x_charger_display.c
+++ b/drivers/power/wm831x_charger_display.c
@@ -38,7 +38,6 @@
 #include <linux/mfd/wm831x/irq.h>
 #include <linux/power_supply.h>
 
-
 #define READ_ON_PIN_CNT 20/*11*/
 #define BACKLIGHT_CNT	2
 #define OPEN_CNT		18
@@ -113,10 +112,21 @@ static int charger_logo_display(struct linux_logo *logo)
 	return 0;
 }
 
+extern int charger_suspend(void);//xsf
+
 static int charger_backlight_ctrl(int open)
 {
 	DBG("%s:open=%d\n",__FUNCTION__,open);
+	int ret;
+
+#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
+	charger_suspend();
+	return 0;
+#else
 	return rk29_backlight_ctrl(open);
+#endif
+
+
 }
 
 static int wm831x_read_on_pin_status(struct wm831x_chg *wm831x_chg)
@@ -279,7 +289,7 @@ static int wm831x_check_on_pin(struct wm831x_chg *wm831x_chg)
 		if(wm831x_chg->cnt_on >= 1)
 		{
 			wm831x_chg->flag_bl = !wm831x_chg->flag_bl;
-			charger_backlight_ctrl(wm831x_chg->flag_bl);			
+			charger_backlight_ctrl(wm831x_chg->flag_bl);
 			wm831x_chg->cnt_on = 0;	
 			if(wm831x_chg->flag_bl)
 			{
@@ -297,6 +307,7 @@ static int rk29_charger_display(struct wm831x_chg *wm831x_chg)
 	int status;
 	struct linux_logo* chargerlogo[8];
 	int ret,i;
+	int count = 0;
 	
 	wm831x_chg->flag_chg = wm831x_read_chg_status(wm831x_chg);
 	if(!wm831x_chg->flag_chg)
@@ -320,9 +331,12 @@ static int rk29_charger_display(struct wm831x_chg *wm831x_chg)
 				wm831x_chg->flag_chg = wm831x_read_chg_status(wm831x_chg);
 				if(!wm831x_chg->flag_chg)
 				kernel_power_off();
+			#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
+				ret = charger_logo_display(chargerlogo[i]);
+			#else
 				if(wm831x_chg->flag_bl != 0)
 				ret = charger_logo_display(chargerlogo[i]);
-
+			#endif
 				DBG("%s:i=%d\n",__FUNCTION__,i);
 
 				msleep(200);	
@@ -335,8 +349,13 @@ static int rk29_charger_display(struct wm831x_chg *wm831x_chg)
 		}
 		else if(status == BAT_DISCHARGING)
 		{
+
+		#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
+			charger_logo_display(chargerlogo[7]);
+		#else
 			if(wm831x_chg->flag_bl != 0)
 			charger_logo_display(chargerlogo[7]);
+		#endif
 			msleep(200);
 			wm831x_check_on_pin(wm831x_chg);
 			msleep(200);
@@ -352,6 +371,10 @@ static int rk29_charger_display(struct wm831x_chg *wm831x_chg)
 				wm831x_chg->cnt_disp = 0;
 				wm831x_chg->flag_bl = 0;
 				charger_backlight_ctrl(wm831x_chg->flag_bl);
+		#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
+				wm831x_chg->flag_suspend = 0;
+		#endif
+
 			}
 			wm831x_chg->cnt_disp = 0;
 		}
@@ -374,11 +397,26 @@ static int rk29_charger_display(struct wm831x_chg *wm831x_chg)
 	return 0;
 
 }
+int charge_status;
+static irqreturn_t wm831x_charge_irq(int irq, void *data)
+{
+
+	printk("wm831x_charge_irqxxaddxsf\n");
+	return IRQ_HANDLED;
+
+
+}
+extern struct wm831x_on *g_wm831x_on;
+ irqreturn_t wm831x_on_irq(int irq, void *data);
 
 static int __devinit wm831x_chg_probe(struct platform_device *pdev)
 {
 	struct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);;
 	struct wm831x_chg *wm831x_chg;
+
+//	struct wm831x_on *wm831x_on = container_of(wm831x,struct wm831x_on,*(wm831x));
+
+
 	int ret;
 	
 	wm831x_chg = kzalloc(sizeof(struct wm831x_chg), GFP_KERNEL);
@@ -386,6 +424,7 @@ static int __devinit wm831x_chg_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Can't allocate data\n");
 		return -ENOMEM;
 	}
+	charge_status = 1;
 	printk("%s:start\n",__FUNCTION__);
 	wm831x_chg->wm831x = wm831x;
 	wm831x_chg->flag_chg = 0;
@@ -393,16 +432,34 @@ static int __devinit wm831x_chg_probe(struct platform_device *pdev)
 	wm831x_chg->flag_bl = 1;
 	wm831x_chg->cnt_on = 0;
 	wm831x_chg->flag_suspend = 0;
-	
 	platform_set_drvdata(pdev, wm831x_chg);
+
+#ifdef CONFIG_RK29_CHARGE_EARLYSUSPEND
+	wm831x_chg->flag_chg = wm831x_read_chg_status(wm831x_chg);
+	if(wm831x_chg->flag_chg != 0)
+	{
+		free_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON,g_wm831x_on);
+		request_threaded_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON,
+						NULL, wm831x_charge_irq,IRQF_TRIGGER_RISING, "wm831x_charge",
+					   wm831x_chg);
+
+		ret = rk29_charger_display(wm831x_chg);
+
+
+		free_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON,wm831x_chg);
+		request_threaded_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON,
+			NULL, wm831x_on_irq,IRQF_TRIGGER_RISING, "wm831x_on",  g_wm831x_on);
+	}
+#else
 	disable_irq_nosync(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON);
 	ret = rk29_charger_display(wm831x_chg);
 	enable_irq(wm831x_chg->wm831x->irq_base + WM831X_IRQ_ON);
+#endif
 	wm831x_chg->flag_chg = 0;
 	wm831x_chg->flag_bl = 1;
 	wm831x_chg->cnt_on = 0;
 	wm831x_chg->flag_suspend = 0;
-
+	charge_status = 0;
 	printk("%s:exit\n",__FUNCTION__);
 	return 0;
 
diff --git a/drivers/power/wm831x_power.c b/drivers/power/wm831x_power.c
index 1fd5e93204d2..51f9b54baa40 100755
--- a/drivers/power/wm831x_power.c
+++ b/drivers/power/wm831x_power.c
@@ -168,7 +168,7 @@ static int wm831x_power_read_voltage(struct wm831x *wm831x,
 	int ret;
 	ret = wm831x_auxadc_read_uv(wm831x, src);
 	if (ret >= 0)
-		val->intval = ret / 1000;
+		val->intval = ret;
 	
 	return ret ;
 }
@@ -184,7 +184,7 @@ int wm831x_read_batt_voltage(void)
 	}
 	
 	ret = wm831x_auxadc_read_uv(g_wm831x_power->wm831x, WM831X_AUX_BATT);
-	return ret / 1000;
+	return ret;
 }
 //EXPORT_SYMBOL_GPL(wm831x_get_batt_voltage);
 
@@ -475,6 +475,7 @@ static int wm831x_bat_check_status(struct wm831x *wm831x, int *status)
 	if (ret < 0)
 		return ret;
 
+
 	switch (ret & WM831X_CHG_STATE_MASK) {
 	case WM831X_CHG_STATE_OFF:
 		*status = POWER_SUPPLY_STATUS_NOT_CHARGING;
@@ -605,7 +606,7 @@ static int wm831x_bat_get_prop(struct power_supply *psy,
 {
 	struct wm831x_power *wm831x_power = dev_get_drvdata(psy->dev->parent);
 	struct wm831x *wm831x = wm831x_power->wm831x;
-	int ret = 0;
+	int  ret = 0;
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_STATUS:
@@ -619,7 +620,7 @@ static int wm831x_bat_get_prop(struct power_supply *psy,
 		break;
 	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
 		//ret = wm831x_power_read_voltage(wm831x, WM831X_AUX_BATT, val);
-		val->intval = wm831x_power->batt_info.voltage*1000;//uV
+		val->intval = wm831x_power->batt_info.voltage;//uV
 		break;
 	case POWER_SUPPLY_PROP_HEALTH:
 		//ret = wm831x_bat_check_health(wm831x, &val->intval);
@@ -716,6 +717,7 @@ static irqreturn_t wm831x_pwr_src_irq(int irq, void *data)
 	power_supply_changed(&wm831x_power->usb);
 	power_supply_changed(&wm831x_power->wall);
 
+
 	return IRQ_HANDLED;
 }
 
@@ -986,7 +988,7 @@ static void wm831x_batt_work(struct work_struct *work)
 	}
 	power->batt_info.voltage = val.intval;
 
-	wm831x_batt_vol_level(power, val.intval, &level);
+	wm831x_batt_vol_level(power, val.intval / 1000, &level);
 	//mod_timer(&power->timer, jiffies + msecs_to_jiffies(power->interval));
 
 	if (online != power->batt_info.online || status != power->batt_info.status
@@ -1093,7 +1095,7 @@ static __devinit int wm831x_power_probe(struct platform_device *pdev)
 
 	power->interval = TIMER_MS_COUNTS;
 	power->batt_info.level = 100;
-	power->batt_info.voltage   = 4200;
+	power->batt_info.voltage   = 4200000;
 	power->batt_info.online    = 1;
 	power->batt_info.status    = POWER_SUPPLY_STATUS_DISCHARGING;
 	power->batt_info.health    = POWER_SUPPLY_HEALTH_GOOD;
@@ -1236,7 +1238,7 @@ static ssize_t power_prop_show(struct device *dev,
 	ret = wm831x_power_read_voltage(g_wm831x_power->wm831x, WM831X_AUX_BATT, &val);
 	if (ret < 0)
 		return ret;
-	wm831x_batt_vol_level(g_wm831x_power, val.intval, &level);
+	wm831x_batt_vol_level(g_wm831x_power, val.intval / 1000, &level);
 	//printk("batt_vol = %d batt_level = %d\n", val.intval, level);
 	//
 	sprintf(buf, "power_status=%#x\n"
diff --git a/drivers/regulator/wm831x-dcdc.c b/drivers/regulator/wm831x-dcdc.c
index 5ae9605aed1a..5607a160fde5 100755
--- a/drivers/regulator/wm831x-dcdc.c
+++ b/drivers/regulator/wm831x-dcdc.c
@@ -32,6 +32,13 @@
 #include <linux/timer.h>
 #include <linux/string.h>
 
+//#include "../../arch/arm/mach-rk29/include/mach/gpio.h"
+
+//#include <linux/hrtimer.h>
+
+
+
+
 #define WM831X_BUCKV_MAX_SELECTOR 0x68
 #define WM831X_BUCKP_MAX_SELECTOR 0x66
 
@@ -126,7 +133,6 @@ static unsigned int wm831x_dcdc_get_mode(struct regulator_dev *rdev)
 		return REGULATOR_MODE_IDLE;
 	default:
 		BUG();
-		return -EINVAL;
 	}
 }
 
@@ -307,7 +313,9 @@ static int wm831x_buckv_set_dvs(struct regulator_dev *rdev, int state)
 
 	return 0;
 }
+//wm831x_buckv_get_voltage
 
+int wm831x_reg_read(struct wm831x *wm831x, unsigned short reg);
 static int wm831x_buckv_read_voltage(struct regulator_dev *rdev)
 {
 	int vol_read;
@@ -323,10 +331,12 @@ static int wm831x_buckv_read_voltage(struct regulator_dev *rdev)
 	vol_read = (ret-8)*12500 + 600000;
 
 	return vol_read;
-}
 
+
+
+}
 static int wm831x_buckv_set_voltage(struct regulator_dev *rdev,
-				    int min_uV, int max_uV, unsigned *selector)
+				    int min_uV, int max_uV)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = dcdc->wm831x;
@@ -338,8 +348,6 @@ static int wm831x_buckv_set_voltage(struct regulator_dev *rdev,
 	if (vsel < 0)
 		return vsel;
 
-	*selector = vsel;
-
 	/* If this value is already set then do a GPIO update if we can */
 	if (dcdc->dvs_gpio && dcdc->on_vsel == vsel)
 		return wm831x_buckv_set_dvs(rdev, 0);
@@ -401,14 +409,14 @@ static int wm831x_buckv_set_suspend_voltage(struct regulator_dev *rdev,
 	return wm831x_set_bits(wm831x, reg, WM831X_DC1_SLP_VSEL_MASK, vsel);
 }
 
-static int wm831x_buckv_get_voltage_sel(struct regulator_dev *rdev)
+static int wm831x_buckv_get_voltage(struct regulator_dev *rdev)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 
 	if (dcdc->dvs_gpio && dcdc->dvs_gpio_state)
-		return dcdc->dvs_vsel;
+		return wm831x_buckv_list_voltage(rdev, dcdc->dvs_vsel);
 	else
-		return dcdc->on_vsel;
+		return wm831x_buckv_list_voltage(rdev, dcdc->on_vsel);
 }
 
 /* Current limit options */
@@ -427,9 +435,11 @@ static int wm831x_buckv_set_voltage_step(struct regulator_dev * rdev, int min_uV
 	struct wm831x *wm831x = dcdc->wm831x;
 	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
 
+
 	//if(strcmp(rdev->constraints->name,"DCDC2") != 0)
 	if(strcmp(pdata->dcdc[1]->consumer_supplies[1].supply,"vcore") != 0)
 	{
+
 		ret = wm831x_buckv_set_voltage(rdev,min_uV,max_uV);
 	}
 	else
@@ -454,9 +464,12 @@ static int wm831x_buckv_set_voltage_step(struct regulator_dev * rdev, int min_uV
 
 			if(new_min_uV > min_uV) //0<  old_vol - min_uV < 100000 ||0< new_min_uV  - min_uV < 1000000
 			{
+
 				ret = wm831x_buckv_set_voltage(rdev,min_uV,max_uV);
 				usleep_range(1000,1000);
+
 			}
+
 		}
 		else                    //rise  voltage
 		{
@@ -475,10 +488,12 @@ static int wm831x_buckv_set_voltage_step(struct regulator_dev * rdev, int min_uV
 				ret = wm831x_buckv_set_voltage(rdev,min_uV,max_uV);
 				usleep_range(1000,1000);
 			}
+
 		}
-	}
 
+	}
 	return ret;
+
 }
 
 static int wm831x_buckv_set_current_limit(struct regulator_dev *rdev,
@@ -513,19 +528,20 @@ static int wm831x_buckv_get_current_limit(struct regulator_dev *rdev)
 	return wm831x_dcdc_ilim[val & WM831X_DC1_HC_THR_MASK];
 }
 
-static int wm831x_dcdc_set_suspend_enable(struct regulator_dev *rdev)
+int wm831x_dcdc_set_suspend_enable(struct regulator_dev *rdev)
 {
+
         return 0;
 }
-
-static int wm831x_dcdc_set_suspend_disable(struct regulator_dev *rdev)
+int wm831x_dcdc_set_suspend_disable(struct regulator_dev *rdev)
 {
+
         return 0;
 }
 
 static struct regulator_ops wm831x_buckv_ops = {
 	.set_voltage = wm831x_buckv_set_voltage_step,
-	.get_voltage_sel = wm831x_buckv_get_voltage_sel,
+	.get_voltage = wm831x_buckv_get_voltage,
 	.list_voltage = wm831x_buckv_list_voltage,
 	.set_suspend_voltage = wm831x_buckv_set_suspend_voltage,
 	.set_current_limit = wm831x_buckv_set_current_limit,
@@ -665,8 +681,9 @@ static __devinit int wm831x_buckv_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,
-				   IRQF_TRIGGER_RISING, dcdc->name, dcdc);
+	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_uv_irq,
+				 IRQF_TRIGGER_RISING, dcdc->name,
+				 dcdc);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -674,8 +691,9 @@ static __devinit int wm831x_buckv_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "HC");
-	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_oc_irq,
-				   IRQF_TRIGGER_RISING, dcdc->name, dcdc);
+	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_oc_irq,
+				 IRQF_TRIGGER_RISING, dcdc->name,
+				 dcdc);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request HC IRQ %d: %d\n",
 			irq, ret);
@@ -687,7 +705,7 @@ static __devinit int wm831x_buckv_probe(struct platform_device *pdev)
 	return 0;
 
 err_uv:
-	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
+	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
 err_regulator:
 	regulator_unregister(dcdc->regulator);
 err:
@@ -700,11 +718,12 @@ static __devinit int wm831x_buckv_probe(struct platform_device *pdev)
 static __devexit int wm831x_buckv_remove(struct platform_device *pdev)
 {
 	struct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);
+	struct wm831x *wm831x = dcdc->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	free_irq(platform_get_irq_byname(pdev, "HC"), dcdc);
-	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
+	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "HC"), dcdc);
+	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
 	regulator_unregister(dcdc->regulator);
 	if (dcdc->dvs_gpio)
 		gpio_free(dcdc->dvs_gpio);
@@ -736,7 +755,7 @@ static int wm831x_buckp_list_voltage(struct regulator_dev *rdev,
 }
 
 static int wm831x_buckp_set_voltage_int(struct regulator_dev *rdev, int reg,
-					int min_uV, int max_uV, int *selector)
+					int min_uV, int max_uV)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = dcdc->wm831x;
@@ -750,20 +769,16 @@ static int wm831x_buckp_set_voltage_int(struct regulator_dev *rdev, int reg,
 	if (wm831x_buckp_list_voltage(rdev, vsel) > max_uV)
 		return -EINVAL;
 
-	*selector = vsel;
-
 	return wm831x_set_bits(wm831x, reg, WM831X_DC3_ON_VSEL_MASK, vsel);
 }
 
 static int wm831x_buckp_set_voltage(struct regulator_dev *rdev,
-				    int min_uV, int max_uV,
-				    unsigned *selector)
+				    int min_uV, int max_uV)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	u16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;
 
-	return wm831x_buckp_set_voltage_int(rdev, reg, min_uV, max_uV,
-					    selector);
+	return wm831x_buckp_set_voltage_int(rdev, reg, min_uV, max_uV);
 }
 
 static int wm831x_buckp_set_suspend_voltage(struct regulator_dev *rdev,
@@ -771,12 +786,11 @@ static int wm831x_buckp_set_suspend_voltage(struct regulator_dev *rdev,
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	u16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;
-	unsigned selector;
 
-	return wm831x_buckp_set_voltage_int(rdev, reg, uV, uV, &selector);
+	return wm831x_buckp_set_voltage_int(rdev, reg, uV, uV);
 }
 
-static int wm831x_buckp_get_voltage_sel(struct regulator_dev *rdev)
+static int wm831x_buckp_get_voltage(struct regulator_dev *rdev)
 {
 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = dcdc->wm831x;
@@ -787,12 +801,12 @@ static int wm831x_buckp_get_voltage_sel(struct regulator_dev *rdev)
 	if (val < 0)
 		return val;
 
-	return val & WM831X_DC3_ON_VSEL_MASK;
+	return wm831x_buckp_list_voltage(rdev, val & WM831X_DC3_ON_VSEL_MASK);
 }
 
 static struct regulator_ops wm831x_buckp_ops = {
 	.set_voltage = wm831x_buckp_set_voltage,
-	.get_voltage_sel = wm831x_buckp_get_voltage_sel,
+	.get_voltage = wm831x_buckp_get_voltage,
 	.list_voltage = wm831x_buckp_list_voltage,
 	.set_suspend_voltage = wm831x_buckp_set_suspend_voltage,
 
@@ -855,8 +869,9 @@ static __devinit int wm831x_buckp_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,
-				   IRQF_TRIGGER_RISING,	dcdc->name, dcdc);
+	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_uv_irq,
+				 IRQF_TRIGGER_RISING, dcdc->name,
+				 dcdc);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -877,10 +892,11 @@ static __devinit int wm831x_buckp_probe(struct platform_device *pdev)
 static __devexit int wm831x_buckp_remove(struct platform_device *pdev)
 {
 	struct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);
+	struct wm831x *wm831x = dcdc->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
+	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
 	regulator_unregister(dcdc->regulator);
 	kfree(dcdc);
 
@@ -982,9 +998,9 @@ static __devinit int wm831x_boostp_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,
-				   IRQF_TRIGGER_RISING, dcdc->name,
-				   dcdc);
+	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_uv_irq,
+				 IRQF_TRIGGER_RISING, dcdc->name,
+				 dcdc);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -1005,10 +1021,11 @@ static __devinit int wm831x_boostp_probe(struct platform_device *pdev)
 static __devexit int wm831x_boostp_remove(struct platform_device *pdev)
 {
 	struct wm831x_dcdc *dcdc = platform_get_drvdata(pdev);
+	struct wm831x *wm831x = dcdc->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
+	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
 	regulator_unregister(dcdc->regulator);
 	kfree(dcdc);
 
diff --git a/drivers/regulator/wm831x-isink.c b/drivers/regulator/wm831x-isink.c
index 99f214dd2286..e754528100f8 100755
--- a/drivers/regulator/wm831x-isink.c
+++ b/drivers/regulator/wm831x-isink.c
@@ -200,15 +200,10 @@ static __devinit int wm831x_isink_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq(pdev, 0);
-<<<<<<< HEAD
-	ret = request_threaded_irq(irq, NULL, wm831x_isink_irq,
-				   IRQF_TRIGGER_RISING, isink->name, isink);
-=======
 	printk("%s:line=%d,irq=%d\n",__FUNCTION__,__LINE__,irq);
 	ret = wm831x_request_irq(wm831x, irq, wm831x_isink_irq,
 				 IRQF_TRIGGER_RISING, isink->name,
 				 isink);
->>>>>>> parent of 15f7fab... temp revert rk change
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request ISINK IRQ %d: %d\n",
 			irq, ret);
@@ -229,10 +224,11 @@ static __devinit int wm831x_isink_probe(struct platform_device *pdev)
 static __devexit int wm831x_isink_remove(struct platform_device *pdev)
 {
 	struct wm831x_isink *isink = platform_get_drvdata(pdev);
+	struct wm831x *wm831x = isink->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	free_irq(platform_get_irq(pdev, 0), isink);
+	wm831x_free_irq(wm831x, platform_get_irq(pdev, 0), isink);
 
 	regulator_unregister(isink->regulator);
 	kfree(isink);
diff --git a/drivers/regulator/wm831x-ldo.c b/drivers/regulator/wm831x-ldo.c
index 214ac7200e43..885844a33524 100755
--- a/drivers/regulator/wm831x-ldo.c
+++ b/drivers/regulator/wm831x-ldo.c
@@ -115,8 +115,7 @@ static int wm831x_gp_ldo_list_voltage(struct regulator_dev *rdev,
 }
 
 static int wm831x_gp_ldo_set_voltage_int(struct regulator_dev *rdev, int reg,
-					 int min_uV, int max_uV,
-					 unsigned *selector)
+					 int min_uV, int max_uV)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -136,20 +135,16 @@ static int wm831x_gp_ldo_set_voltage_int(struct regulator_dev *rdev, int reg,
 	if (ret < min_uV || ret > max_uV)
 		return -EINVAL;
 
-	*selector = vsel;
-
 	return wm831x_set_bits(wm831x, reg, WM831X_LDO1_ON_VSEL_MASK, vsel);
 }
 
 static int wm831x_gp_ldo_set_voltage(struct regulator_dev *rdev,
-				     int min_uV, int max_uV,
-				     unsigned *selector)
+				     int min_uV, int max_uV)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_LDO_ON_CONTROL;
-
-	return wm831x_gp_ldo_set_voltage_int(rdev, reg, min_uV, max_uV,
-					     selector);
+	//printk("%s base=%x,%d,%d\n", __FUNCTION__,ldo->base,min_uV,max_uV);
+	return wm831x_gp_ldo_set_voltage_int(rdev, reg, min_uV, max_uV);
 }
 
 static int wm831x_gp_ldo_set_suspend_voltage(struct regulator_dev *rdev,
@@ -157,12 +152,11 @@ static int wm831x_gp_ldo_set_suspend_voltage(struct regulator_dev *rdev,
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_LDO_SLEEP_CONTROL;
-	unsigned int selector;
 
-	return wm831x_gp_ldo_set_voltage_int(rdev, reg, uV, uV, &selector);
+	return wm831x_gp_ldo_set_voltage_int(rdev, reg, uV, uV);
 }
 
-static int wm831x_gp_ldo_get_voltage_sel(struct regulator_dev *rdev)
+static int wm831x_gp_ldo_get_voltage(struct regulator_dev *rdev)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -175,7 +169,7 @@ static int wm831x_gp_ldo_get_voltage_sel(struct regulator_dev *rdev)
 	//printk("%s base=%x,ret=%x\n", __FUNCTION__,ldo->base,ret);
 	ret &= WM831X_LDO1_ON_VSEL_MASK;
 
-	return ret;
+	return wm831x_gp_ldo_list_voltage(rdev, ret);
 }
 
 static unsigned int wm831x_gp_ldo_get_mode(struct regulator_dev *rdev)
@@ -305,7 +299,7 @@ int wm831x_ldo_set_suspend_disable(struct regulator_dev *rdev)
 
 static struct regulator_ops wm831x_gp_ldo_ops = {
 	.list_voltage = wm831x_gp_ldo_list_voltage,
-	.get_voltage_sel = wm831x_gp_ldo_get_voltage_sel,
+	.get_voltage = wm831x_gp_ldo_get_voltage,
 	.set_voltage = wm831x_gp_ldo_set_voltage,
 	.set_suspend_voltage = wm831x_gp_ldo_set_suspend_voltage,
 	.get_mode = wm831x_gp_ldo_get_mode,
@@ -368,9 +362,9 @@ static __devinit int wm831x_gp_ldo_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = request_threaded_irq(irq, NULL, wm831x_ldo_uv_irq,
-				   IRQF_TRIGGER_RISING, ldo->name,
-				   ldo);
+	ret = wm831x_request_irq(wm831x, irq, wm831x_ldo_uv_irq,
+				 IRQF_TRIGGER_RISING, ldo->name,
+				 ldo);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -391,10 +385,11 @@ static __devinit int wm831x_gp_ldo_probe(struct platform_device *pdev)
 static __devexit int wm831x_gp_ldo_remove(struct platform_device *pdev)
 {
 	struct wm831x_ldo *ldo = platform_get_drvdata(pdev);
+	struct wm831x *wm831x = ldo->wm831x;
 
 	platform_set_drvdata(pdev, NULL);
 
-	free_irq(platform_get_irq_byname(pdev, "UV"), ldo);
+	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), ldo);
 	regulator_unregister(ldo->regulator);
 	kfree(ldo);
 
@@ -432,8 +427,7 @@ static int wm831x_aldo_list_voltage(struct regulator_dev *rdev,
 }
 
 static int wm831x_aldo_set_voltage_int(struct regulator_dev *rdev, int reg,
-				       int min_uV, int max_uV,
-				       unsigned *selector)
+					 int min_uV, int max_uV)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -453,20 +447,16 @@ static int wm831x_aldo_set_voltage_int(struct regulator_dev *rdev, int reg,
 	if (ret < min_uV || ret > max_uV)
 		return -EINVAL;
 
-	*selector = vsel;
-
 	return wm831x_set_bits(wm831x, reg, WM831X_LDO7_ON_VSEL_MASK, vsel);
 }
 
 static int wm831x_aldo_set_voltage(struct regulator_dev *rdev,
-				   int min_uV, int max_uV, unsigned *selector)
+				     int min_uV, int max_uV)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_LDO_ON_CONTROL;
-
 	printk("%s base=%x,min_uV=%d,%d\n", __FUNCTION__,ldo->base,min_uV,max_uV);
-	return wm831x_aldo_set_voltage_int(rdev, reg, min_uV, max_uV,
-					   selector);
+	return wm831x_aldo_set_voltage_int(rdev, reg, min_uV, max_uV);
 }
 
 static int wm831x_aldo_set_suspend_voltage(struct regulator_dev *rdev,
@@ -474,12 +464,11 @@ static int wm831x_aldo_set_suspend_voltage(struct regulator_dev *rdev,
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_LDO_SLEEP_CONTROL;
-	unsigned int selector;
 
-	return wm831x_aldo_set_voltage_int(rdev, reg, uV, uV, &selector);
+	return wm831x_aldo_set_voltage_int(rdev, reg, uV, uV);
 }
 
-static int wm831x_aldo_get_voltage_sel(struct regulator_dev *rdev)
+static int wm831x_aldo_get_voltage(struct regulator_dev *rdev)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -492,7 +481,7 @@ static int wm831x_aldo_get_voltage_sel(struct regulator_dev *rdev)
 	printk("%s base=%x,ret=%x\n", __FUNCTION__,ldo->base,ret);
 	ret &= WM831X_LDO7_ON_VSEL_MASK;
 
-	return ret;
+	return wm831x_aldo_list_voltage(rdev, ret);
 }
 
 static unsigned int wm831x_aldo_get_mode(struct regulator_dev *rdev)
@@ -573,7 +562,7 @@ static int wm831x_aldo_get_status(struct regulator_dev *rdev)
 
 static struct regulator_ops wm831x_aldo_ops = {
 	.list_voltage = wm831x_aldo_list_voltage,
-	.get_voltage_sel = wm831x_aldo_get_voltage_sel,
+	.get_voltage = wm831x_aldo_get_voltage,
 	.set_voltage = wm831x_aldo_set_voltage,
 	.set_suspend_voltage = wm831x_aldo_set_suspend_voltage,
 	.get_mode = wm831x_aldo_get_mode,
@@ -635,8 +624,9 @@ static __devinit int wm831x_aldo_probe(struct platform_device *pdev)
 	}
 
 	irq = platform_get_irq_byname(pdev, "UV");
-	ret = request_threaded_irq(irq, NULL, wm831x_ldo_uv_irq,
-				   IRQF_TRIGGER_RISING, ldo->name, ldo);
+	ret = wm831x_request_irq(wm831x, irq, wm831x_ldo_uv_irq,
+				 IRQF_TRIGGER_RISING, ldo->name,
+				 ldo);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",
 			irq, ret);
@@ -657,8 +647,9 @@ static __devinit int wm831x_aldo_probe(struct platform_device *pdev)
 static __devexit int wm831x_aldo_remove(struct platform_device *pdev)
 {
 	struct wm831x_ldo *ldo = platform_get_drvdata(pdev);
+	struct wm831x *wm831x = ldo->wm831x;
 
-	free_irq(platform_get_irq_byname(pdev, "UV"), ldo);
+	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), ldo);
 	regulator_unregister(ldo->regulator);
 	kfree(ldo);
 
@@ -691,8 +682,7 @@ static int wm831x_alive_ldo_list_voltage(struct regulator_dev *rdev,
 
 static int wm831x_alive_ldo_set_voltage_int(struct regulator_dev *rdev,
 					    int reg,
-					    int min_uV, int max_uV,
-					    unsigned *selector)
+					    int min_uV, int max_uV)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -706,20 +696,16 @@ static int wm831x_alive_ldo_set_voltage_int(struct regulator_dev *rdev,
 	if (ret < min_uV || ret > max_uV)
 		return -EINVAL;
 
-	*selector = vsel;
-
 	return wm831x_set_bits(wm831x, reg, WM831X_LDO11_ON_VSEL_MASK, vsel);
 }
 
 static int wm831x_alive_ldo_set_voltage(struct regulator_dev *rdev,
-					int min_uV, int max_uV,
-					unsigned *selector)
+				     int min_uV, int max_uV)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_ALIVE_LDO_ON_CONTROL;
 
-	return wm831x_alive_ldo_set_voltage_int(rdev, reg, min_uV, max_uV,
-						selector);
+	return wm831x_alive_ldo_set_voltage_int(rdev, reg, min_uV, max_uV);
 }
 
 static int wm831x_alive_ldo_set_suspend_voltage(struct regulator_dev *rdev,
@@ -727,12 +713,11 @@ static int wm831x_alive_ldo_set_suspend_voltage(struct regulator_dev *rdev,
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	int reg = ldo->base + WM831X_ALIVE_LDO_SLEEP_CONTROL;
-	unsigned selector;
 
-	return wm831x_alive_ldo_set_voltage_int(rdev, reg, uV, uV, &selector);
+	return wm831x_alive_ldo_set_voltage_int(rdev, reg, uV, uV);
 }
 
-static int wm831x_alive_ldo_get_voltage_sel(struct regulator_dev *rdev)
+static int wm831x_alive_ldo_get_voltage(struct regulator_dev *rdev)
 {
 	struct wm831x_ldo *ldo = rdev_get_drvdata(rdev);
 	struct wm831x *wm831x = ldo->wm831x;
@@ -745,7 +730,7 @@ static int wm831x_alive_ldo_get_voltage_sel(struct regulator_dev *rdev)
 
 	ret &= WM831X_LDO11_ON_VSEL_MASK;
 
-	return ret;
+	return wm831x_alive_ldo_list_voltage(rdev, ret);
 }
 
 static int wm831x_alive_ldo_get_status(struct regulator_dev *rdev)
@@ -767,7 +752,7 @@ static int wm831x_alive_ldo_get_status(struct regulator_dev *rdev)
 
 static struct regulator_ops wm831x_alive_ldo_ops = {
 	.list_voltage = wm831x_alive_ldo_list_voltage,
-	.get_voltage_sel = wm831x_alive_ldo_get_voltage_sel,
+	.get_voltage = wm831x_alive_ldo_get_voltage,
 	.set_voltage = wm831x_alive_ldo_set_voltage,
 	.set_suspend_voltage = wm831x_alive_ldo_set_suspend_voltage,
 	.get_status = wm831x_alive_ldo_get_status,
@@ -925,8 +910,7 @@ static int __init wm831x_ldo_init(void)
 	if (ret != 0)
 		pr_err("Failed to register WM831x alive LDO driver: %d\n",
 		       ret);
-
-	return 0;
+    return 0;
 }
 subsys_initcall(wm831x_ldo_init);
 
diff --git a/drivers/video/backlight/wm831x_bl.c b/drivers/video/backlight/wm831x_bl.c
index cea8e23f0937..bb8ac47c51f2 100755
--- a/drivers/video/backlight/wm831x_bl.c
+++ b/drivers/video/backlight/wm831x_bl.c
@@ -154,7 +154,7 @@ static int wm831x_backlight_get_brightness(struct backlight_device *bl)
 	return data->current_brightness;
 }
 
-static const struct backlight_ops wm831x_backlight_ops = {
+static struct backlight_ops wm831x_backlight_ops = {
 	.options = BL_CORE_SUSPENDRESUME,
 	.update_status	= wm831x_backlight_update_status,
 	.get_brightness	= wm831x_backlight_get_brightness,
@@ -268,10 +268,9 @@ static int wm831x_backlight_probe(struct platform_device *pdev)
 	data->current_brightness = 0;
 	data->isink_reg = isink_reg;
 
-	props.type = BACKLIGHT_RAW;
-	props.max_brightness = BL_SET;
+	props.max_brightness = max_isel;
 	bl = backlight_device_register("wm831x", &pdev->dev, data,
-				       &wm831x_backlight_ops, &props);
+				       &wm831x_backlight_ops);
 	if (IS_ERR(bl)) {
 		dev_err(&pdev->dev, "failed to register backlight\n");
 		kfree(data);
@@ -279,6 +278,7 @@ static int wm831x_backlight_probe(struct platform_device *pdev)
 	}
 
 	bl->props.brightness = BL_INIT_VALUE;
+	bl->props.max_brightness= BL_SET;
 
 	platform_set_drvdata(pdev, bl);
 
diff --git a/include/linux/mfd/wm831x/core.h b/include/linux/mfd/wm831x/core.h
old mode 100644
new mode 100755
index 4b217b9b8fc7..b702517a76bc
--- a/include/linux/mfd/wm831x/core.h
+++ b/include/linux/mfd/wm831x/core.h
@@ -249,16 +249,6 @@ enum wm831x_parent {
 	WM8325 = 0x8325,
 };
 
-enum wm831x_parent {
-	WM8310 = 0x8310,
-	WM8311 = 0x8311,
-	WM8312 = 0x8312,
-	WM8320 = 0x8320,
-	WM8321 = 0x8321,
-	WM8325 = 0x8325,
-	WM8326 = 0x8326,
-};
-
 struct wm831x {
 	struct mutex io_lock;
 
@@ -361,4 +351,30 @@ int wm831x_device_restart(struct wm831x *wm831x);
 int wm831x_irq_init(struct wm831x *wm831x, int irq);
 void wm831x_irq_exit(struct wm831x *wm831x);
 
+static inline int __must_check wm831x_request_irq(struct wm831x *wm831x,
+						  unsigned int irq,
+						  irq_handler_t handler,
+						  unsigned long flags,
+						  const char *name,
+						  void *dev)
+{
+	return request_threaded_irq(irq, NULL, handler, flags, name, dev);
+}
+
+static inline void wm831x_free_irq(struct wm831x *wm831x,
+				   unsigned int irq, void *dev)
+{
+	free_irq(irq, dev);
+}
+
+static inline void wm831x_disable_irq(struct wm831x *wm831x, int irq)
+{
+	disable_irq(irq);
+}
+
+static inline void wm831x_enable_irq(struct wm831x *wm831x, int irq)
+{
+	enable_irq(irq);
+}
+
 #endif
diff --git a/include/linux/mfd/wm831x/pdata.h b/include/linux/mfd/wm831x/pdata.h
index accc729c7970..92cefe8721e1 100755
--- a/include/linux/mfd/wm831x/pdata.h
+++ b/include/linux/mfd/wm831x/pdata.h
@@ -82,10 +82,7 @@ struct wm831x_touch_pdata {
 	int isel;              /** Current for pen down (uA) */
 	int rpu;               /** Pen down sensitivity resistor divider */
 	int pressure;          /** Report pressure (boolean) */
-	unsigned int data_irq; /** Touch data ready IRQ */
-	int data_irqf;         /** IRQ flags for data ready IRQ */
-	unsigned int pd_irq;   /** Touch pendown detect IRQ */
-	int pd_irqf;           /** IRQ flags for pen down IRQ */
+	int data_irq;          /** Touch data ready IRQ */
 };
 
 enum wm831x_watchdog_action {
@@ -123,23 +120,11 @@ struct wm831x_gpio_keys_pdata {
 #define WM831X_MAX_LDO    11
 #define WM831X_MAX_ISINK  2
 
-#define WM831X_GPIO_CONFIGURE 0x10000
-#define WM831X_GPIO_NUM 16
-
 struct wm831x_pdata {
-	/** Used to distinguish multiple WM831x chips */
-	int wm831x_num;
-
 	/** Called before subdevices are set up */
 	int (*pre_init)(struct wm831x *wm831x);
 	/** Called after subdevices are set up */
 	int (*post_init)(struct wm831x *wm831x);
-<<<<<<< HEAD
-
-	/** Put the /IRQ line into CMOS mode */
-	bool irq_cmos;
-
-=======
 	/** Called before subdevices are power down */
 	int (*last_deinit)(struct wm831x *wm831x);
 	//add by sxj	
@@ -148,10 +133,8 @@ struct wm831x_pdata {
 	int  settinginfolen;	
 	int (*pin_type_init)(struct wm831x *wm831x);	
 	//above add by sxj
->>>>>>> parent of 15f7fab... temp revert rk change
 	int irq_base;
 	int gpio_base;
-	int gpio_defaults[WM831X_GPIO_NUM];
 	struct wm831x_backlight_pdata *backlight;
 	struct wm831x_backup_pdata *backup;
 	struct wm831x_battery_pdata *battery;
diff --git a/include/linux/mfd/wm8994/pdata.h b/include/linux/mfd/wm8994/pdata.h
old mode 100644
new mode 100755
index b47b3cb86c06..f63b990b366e
--- a/include/linux/mfd/wm8994/pdata.h
+++ b/include/linux/mfd/wm8994/pdata.h
@@ -26,20 +26,10 @@ struct wm8994_ldo_pdata {
 	struct regulator_init_data *init_data;
 };
 
-#define WM8994_CONFIGURE_GPIO 0x10000
+#define WM8994_CONFIGURE_GPIO 0x8000
 
 #define WM8994_DRC_REGS 5
-<<<<<<< HEAD
-#define WM8994_EQ_REGS  20
-#define WM8958_MBC_CUTOFF_REGS 20
-#define WM8958_MBC_COEFF_REGS  48
-#define WM8958_MBC_COMBINED_REGS 56
-#define WM8958_VSS_HPF_REGS 2
-#define WM8958_VSS_REGS 148
-#define WM8958_ENH_EQ_REGS 32
-=======
 #define WM8994_EQ_REGS  19
->>>>>>> parent of 15f7fab... temp revert rk change
 
 /**
  * DRC configurations are specified with a label and a set of register
@@ -69,58 +59,8 @@ struct wm8994_retune_mobile_cfg {
         u16 regs[WM8994_EQ_REGS];
 };
 
-<<<<<<< HEAD
-/**
- * Multiband compressor configurations are specified with a label and
- * two sets of values to write.  Configurations are expected to be
- * generated using the multiband compressor configuration panel in
- * WISCE - see http://www.wolfsonmicro.com/wisce/
- */
-struct wm8958_mbc_cfg {
-	const char *name;
-	u16 cutoff_regs[WM8958_MBC_CUTOFF_REGS];
-	u16 coeff_regs[WM8958_MBC_COEFF_REGS];
-
-	/* Coefficient layout when using MBC+VSS firmware */
-	u16 combined_regs[WM8958_MBC_COMBINED_REGS];
-};
-
-/**
- * VSS HPF configurations are specified with a label and two values to
- * write.  Configurations are expected to be generated using the
- * multiband compressor configuration panel in WISCE - see
- * http://www.wolfsonmicro.com/wisce/
- */
-struct wm8958_vss_hpf_cfg {
-	const char *name;
-	u16 regs[WM8958_VSS_HPF_REGS];
-};
-
-/**
- * VSS configurations are specified with a label and array of values
- * to write.  Configurations are expected to be generated using the
- * multiband compressor configuration panel in WISCE - see
- * http://www.wolfsonmicro.com/wisce/
- */
-struct wm8958_vss_cfg {
-	const char *name;
-	u16 regs[WM8958_VSS_REGS];
-};
-
-/**
- * Enhanced EQ configurations are specified with a label and array of
- * values to write.  Configurations are expected to be generated using
- * the multiband compressor configuration panel in WISCE - see
- * http://www.wolfsonmicro.com/wisce/
- */
-struct wm8958_enh_eq_cfg {
-	const char *name;
-	u16 regs[WM8958_ENH_EQ_REGS];
-};
-=======
 #define PCM_BB 1
 #define NO_PCM_BB 0
->>>>>>> parent of 15f7fab... temp revert rk change
 
 struct wm8994_pdata {
 	int gpio_base;
@@ -140,18 +80,6 @@ struct wm8994_pdata {
         int num_retune_mobile_cfgs;
         struct wm8994_retune_mobile_cfg *retune_mobile_cfgs;
 
-	int num_mbc_cfgs;
-	struct wm8958_mbc_cfg *mbc_cfgs;
-
-	int num_vss_cfgs;
-	struct wm8958_vss_cfg *vss_cfgs;
-
-	int num_vss_hpf_cfgs;
-	struct wm8958_vss_hpf_cfg *vss_hpf_cfgs;
-
-	int num_enh_eq_cfgs;
-	struct wm8958_enh_eq_cfg *enh_eq_cfgs;
-
         /* LINEOUT can be differential or single ended */
         unsigned int lineout1_diff:1;
         unsigned int lineout2_diff:1;
@@ -160,23 +88,14 @@ struct wm8994_pdata {
         unsigned int lineout1fb:1;
         unsigned int lineout2fb:1;
 
-	/* IRQ for microphone detection if brought out directly as a
-	 * signal.
-	 */
-	int micdet_irq;
-
-        /* WM8994 microphone biases: 0=0.9*AVDD1 1=0.65*AVVD1 */
+        /* Microphone biases: 0=0.9*AVDD1 1=0.65*AVVD1 */
         unsigned int micbias1_lvl:1;
         unsigned int micbias2_lvl:1;
 
-        /* WM8994 jack detect threashold levels, see datasheet for values */
+        /* Jack detect threashold levels, see datasheet for values */
         unsigned int jd_scthr:2;
         unsigned int jd_thr:2;
 
-<<<<<<< HEAD
-	/* WM8958 microphone bias configuration */
-	int micbias[2];
-=======
 		//for phonepad
 		unsigned int no_earpiece:1;      // =1  don't have a earpiece,  =0   has a earpiece
 		unsigned int sp_hp_same_channel:1;
@@ -205,7 +124,6 @@ struct wm8994_pdata {
 	int BT_incall_mic_vol;			//max = 6, min = -57
 	int recorder_vol;				//max = 60 , min = -16
 		
->>>>>>> parent of 15f7fab... temp revert rk change
 };
 
 #endif
-- 
2.35.3

